00:00:07 <uptick> i see
00:00:11 <uptick> makes sense
00:00:58 <davean> yah, install and new-install are mostly related by using some of the same namespace for where you put stuff and the fact that the things they do conceptually relate
00:01:16 <uptick> but say if i'm interested in checking out the lib folder, since it doesn't create it in ~/.cabal, where does it actually reside? 
00:01:16 <davean> one is not a minor modification of the other so much as a different system for accomplishing similar goals.
00:01:38 <davean> uptick: it should be in a subdirectory of .cabal
00:01:43 <davean> uptick: tehy aren't at the top level of .cabal
00:01:48 <uptick> ya i'll stick with new-install then. it also didn't give me that WARNING during cabal install cabal-install
00:01:53 <davean> they're seperate into what they are, and what compiler they're built with
00:02:18 <uptick> about not creating symlink in .cabal/bin for cabal because the file exists there already but it not managed by cabal... which i'm guessing is probably relating to using the ghcup script or something
00:02:26 <davean> uptick: look in ~/.cabal/store/ghc-8.6.3/ or whatnot
00:02:52 <davean> (your compiler version probably is older than mine, so change version number accordingly)
00:02:59 <uptick> davean: ah ok. i'll check it out once i install again
00:03:06 <uptick> ya it's 8.4.4
00:03:23 <uptick> ghcup install only gives me 8.4.4 as the best, latest version :(
00:03:34 <davean> Eh, don't worry about it
00:03:36 <uptick> tidal has been tested with 8.4.4 so it's no problem
00:03:40 <cfraz89> you can install 8.6.3 if you want
00:03:48 <davean> but yah, you'll have things like "adjunctions-4.4-ab1c2dfdb9d2e5ae341f89d4a6d7e86b6d056f61c54c8bc22902dd196239e596"
00:03:59 <cfraz89> the mantainer is a bit conservative about new versions of ghc lol
00:04:08 <cfraz89> i'll ping him about the cabal warning though
00:04:20 <davean> and that example is a particular configuration of the adjunctions pacage, at version 4.4
00:04:28 <davean> the hash just seperates out WHICH configuration
00:04:33 <cfraz89> but yeah if you want latest and greatest, ghcup install latest should work
00:04:42 <uptick> ah ok
00:04:48 <uptick> i'll just stick with 8.4.4 for now
00:05:00 <uptick> man, thanks so much for clarifying these nuiances for me :D
00:05:03 <uptick> really appreciate it
00:06:16 <davean> No problem - its interesting. Thats a way to use cabal I've not seen before (the thing in emacs building something using a global configuration)
00:06:41 <cfraz89> i want to say someone needs to write a guide
00:06:46 <cfraz89> but i'm too lazy to write a guide
00:07:07 <uptick> https://tidalcycles.org/index.php/Welcome
00:07:09 <uptick> this is the program
00:07:21 <davean> well i think maybe tidal's emacs plugin should perhaps change how it does its build but I think they did it that way to make things work with the old install command easier
00:08:10 <uptick> it would've been a lot simpler if i could just install haskell stuff via my Linux's package manager, but archlinux i guess dynamically link haskell libraries and turn them to arch packages so most people avoid getting haskell stuff through the manager and prefer to get them directly 
00:08:22 <davean> ugh yah, arch
00:08:27 <davean> I do no understand their decision
00:08:46 <davean> They somehow seem to persist in thinking Haskell acts like C
00:08:52 <davean> inspit of all evidence
00:30:55 * hackage boolector 0.0.0.8 - Haskell bindings for the Boolector SMT solver  http://hackage.haskell.org/package/boolector-0.0.0.8 (DeianStefan)
00:33:03 <uptick> davean: just checked ~/.cabal/store/ghc-8.4.4/.... the lib folders and stuff are all there :P
00:41:55 <tsahyt> I'm dealing with what is essentially a length indexed vector built with conses, and I need some instances for it. All of these are derivable via Generic, but I'd like the instances as if Vec 3 a was representationally Vec a a a, i.e. a three tuple. how much of an abuse would it be to handwrite a generic instance to that effect? is it even possible?
00:41:58 --- mode: glguy set +v frowny
00:51:54 <mniip> tsahyt, depends, what does your type look like?
00:57:36 <tsahyt> mniip: it's essentially just the standard length indexed vector example, specialized to one contained type, with GADTs, + an extra field in the nil constructor, and a phantom parameter
00:58:06 <tsahyt> data DBAtom (n :: Symbol) (a :: Nat) where { DBMeta :: UTCTime -> DBAtom n 0; DBField :: Text -> DBAtom n a -> DBAtom n (a + 1) }
00:59:10 <tsahyt> I should probably switch the parameter naming around, having a for the length is a bit confusing I guess
00:59:35 <mniip> hmm, can Generics even be derived for a type like this
01:01:21 <tsahyt> how?
01:01:32 <mniip> that's a question
01:01:50 <mniip> anyway, is 'a' going to be a small compile time known constant?
01:01:50 <tsahyt> oh, I misread
01:02:24 <tsahyt> it's a constant that I get out of an invocation of someNatVal, but it's generally small
01:02:46 <tsahyt> generally ~3 or so. but I can't place an upper bound on it
01:02:46 <mniip> then you'll have Very Bad issues with type inference
01:04:09 <tsahyt> well, I thought since a can be determined in all places where this type is used, that wouldn't be much of an issue
01:04:20 <tsahyt> since I don't actually need to infer it
01:04:25 * hackage aws-lambda-haskell-runtime 1.0.8 - Haskell runtime for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.0.8 (NickSeagull)
01:05:21 <mniip> you'll need to prove to GHC that your program is correct
01:06:27 <mniip> anyway
01:07:11 <mniip> there will probably be no issue with defining  instance Generic DBAtom n 0  and  instnance Generic (DBAtom n a) => Generic (DBAtom n (a + 1))
01:07:24 <mniip> with Rep being :*: in the latter case, just like for tuples
01:07:31 <mniip> the issue will be in using this
01:07:43 <tsahyt> I'll look at the tuples instance
01:07:50 --- mode: glguy set +v nickednamed
01:08:26 <mniip> tsahyt, do you know how to write  broadcast :: KnownNat a => UTCTime -> Text -> DBAtom n a
01:08:46 <mniip> (which would create a vector of arbitrarily length filled with the same entry)
01:09:01 <tsahyt> I think so, yes
01:09:58 <mniip> ok, would you be using unsafeCoerce, singletons, or typelits-witnesses?
01:10:25 * hackage tidal 1.0.4 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.4 (AlexMcLean)
01:12:07 <tsahyt> mniip: typelits-witnesses, probably. I'd like to stay away from singletons
01:12:36 <tsahyt> hm.. apparently this package is now deprecated in favour of singletons
01:12:42 <nickednamed> Hi guys. Newbie question. I am learning Haskell by trying to write a simple algorithmic trading bot (to automate losing my money), and I have some design questions. Should I use "Websockets" (wuss library), or REST (wreq, req) or stream http requests (http-conduit)? I'm leaning towards websockets/wuss due to the supposed performance benefit.
01:13:11 <mniip> tsahyt, yeah it's not immediately obvious that you'd at all need something like this
01:13:25 <mniip> but that's the kind of tool you'll need to write broadcast
01:13:40 <mniip> and the same sort of problem will come up when you try to use your generic instance
01:13:42 <mniip> which is why I asked
01:15:25 <tsahyt> mniip: well I do need some way to convince GHC about the 0 case, and possibly about the step from a+1 to a
01:15:42 <mniip> exactly
01:15:58 <tsahyt> mniip: FWIW I'm not opposed to using inductively defined nats either
01:16:09 <tsahyt> in my experience that simplifies some things
01:16:12 <mniip> yes
01:16:24 <mniip> I have actually thrown together a package for this type of thing
01:16:36 <mniip> check this one out http://hackage.haskell.org/package/singleton-typelits-0.1.0.0/docs/GHC-TypeLits-Induction.html#v:induceIsZero
01:17:12 <tsahyt> oh that might be useful
01:17:25 * hackage tidal 1.0.5 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.5 (AlexMcLean)
01:18:27 <tsahyt> oh, despite the name it actually doesn't depend on singletons
01:18:28 <mniip> the story with this package is that induceIsZero uses  instance NatSingleton NatIsZero
01:18:34 <mniip> which in turn uses unsafeCoerce
01:18:52 <mniip> the idea was to round up all such unsafeCoerces in one package
01:18:57 <mniip> so that a user doesn't have to
01:19:16 <mniip> and you definitely need an unsafeCoerce at /some/ point
01:19:28 <mniip> singleton uses unsafeCoerces generously internally
01:19:46 <tsahyt> well there's also the option of using typechecker plugins
01:19:55 <tsahyt> iirc the clash project had one
01:20:01 <mniip> oh whoops
01:20:06 <mniip> induceIsZero is not what you want
01:20:09 <mniip> you want inducePeano
01:21:13 <mniip> even with typechecker plugins
01:21:24 <tsahyt> so what this type says is that given a proof that if P holds at n, then P holds at n+1, as well as a proof that P holds at 0, it gives you a proof that P holds for all n, is that right?
01:21:36 <mniip> you need something to go  Dict (KnownNat n) -> Either (Dict (n ~ 0)) (Dict (n ~ 1 + k, KnownNat k))
01:21:54 <mniip> tsahyt, yes
01:22:29 <tsahyt> and since proofs are all constructive that means I can use this function to build DBAtom n a, for all a, as long as a is known
01:22:55 <mniip> yes
01:23:19 <tsahyt> hm, I'll start playing around with that a bit. I've had similar problems to solve every time I used typelits. it's nice to have induction abstracted out like this
01:24:07 <mniip> beware, I don't think this library has been used by anyone yet
01:24:19 <tsahyt> what I haven't faced yet is writing Generic instances, and in particular not Generic instances that flatten out the type
01:25:01 <mniip> there's no such thing as flattening out the typ
01:25:13 <mniip> if anything, Rep's are more tree-ey than the original type
01:25:59 <mniip> % import GHC.Generics
01:26:00 <yahb> mniip: 
01:26:16 <mniip> % data Foo = Foo Int Char Bool deriving Generic
01:26:16 <yahb> mniip: ; <interactive>:3:39: error:; * Can't make a derived instance of `Generic Foo': You need DeriveGeneric to derive an instance for this class; * In the data declaration for `Foo'
01:26:25 <mniip> % :set -XDeriveGeneric
01:26:25 <yahb> mniip: 
01:26:27 <mniip> % data Foo = Foo Int Char Bool deriving Generic
01:26:27 <yahb> mniip: 
01:26:34 <mniip> % :kind! Rep Foo
01:26:35 <yahb> mniip: Rep Foo :: * -> *; = D1 ('MetaData "Foo" "Ghci4" "interactive" 'False) (C1 ('MetaCons "Foo" 'PrefixI 'False) (S1 ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 Int) :*: (S1 ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 Char) :*: S1 ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy) (Rec0 Bool))))
01:27:28 <tsahyt> mniip: the important thing for me is that it's a bunch of simple fields with :*: between them, rather than Rep recursing. now tbh I don't know anywhere near enough about how Generic works, so maybe I'm completely off anyhow
01:27:44 <tsahyt> recursing is the wrong way to say it
01:27:49 <mniip> huh?
01:27:53 <mniip> is there a difference?
01:28:10 <Christienne> There should be an easy way to update platform without uninstalling and downloading, but owell.
01:28:46 <tsahyt> mniip: I think phrased differently it needs to generate a single constructor with a product of a+1 fields
01:29:07 <mniip> does the metadata matter?
01:29:40 <tsahyt> no, I don't think so
01:29:58 <tsahyt> The UTCTime does, but the metadata in Generic doesn't really for my usecase
01:31:32 <mniip> then there's no difference
01:31:50 <tsahyt> i.e. given data V3 = V3 Text Text Text UTCTime, Rep (DBAtom n 3) should look like the derived instance for Rep V3, up to order of fields.
01:33:03 <mniip> well, ignoring D1/C1/S1, what other difference do you have in mind
01:35:32 <tsahyt> the resulting instance mustn't use :+:
01:39:09 <tsahyt> i.e. it must be a chain of :*:
01:49:43 --- mode: glguy set +v lysgaard
01:49:54 <lysgaard> I have an Ast datatype where i am getting a lot of type parameters for different pluggable parts. I started using Functor and had one parameter for the variable names. Now I am using Bifunctor and have two parameters, variable names, and the numeric constant. Now I want to add another parameter, but there is not a TriFunctor package.
01:50:11 <lysgaard> I feel like I am missing some basic abstraction over type parameters.
01:50:31 <lysgaard> Anyone had a similar problem and if so, how did you end up solving it?
01:51:03 <tsahyt> hm, at first try I already get conflicting family instance declarations when I try to define Rep (DBAtom n 0) and Rep (DBAtom n a) in their respective instances
01:51:33 <tsahyt> I tried adding constraints like (a ~ (b+1)) to the instance. it also doesn't let me define an instance for (DBAtom n (a + 1))
02:28:23 <jollygood2> am I being too playful in here?  [path, intArg] -> maybe (return ()) (someAction path) (readMaybe intArg)
02:28:30 <jollygood2> part of case args of
02:29:28 <ski> sounds ok
02:29:50 <ski> (you could possibly use a view pattern, i think ..)
02:31:17 --- mode: glguy set +v pythonisbetterth
02:31:50 <merijn> jollygood2: Needs a couple of extra where/let bindings for readability, but seems perfectly reasonable
02:32:50 <merijn> jollygood2: Oh, actually
02:33:03 <merijn> That's just for_/forM_/mapM_ in disguise :p
02:33:06 <merijn> :t for_
02:33:07 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
02:33:25 <merijn> :t for_ Nothing
02:33:27 <lambdabot> Applicative f => (a -> f b) -> f ()
02:34:37 <jollygood2> interesting,  I did not see that!
02:34:48 <merijn> jollygood2: Yeah, I always forget it to :p
02:36:26 <jollygood2> am I the only one who has to always look up signatures of maybe and fromMaybe before using them?
02:37:40 <merijn> jollygood2: There's a trick!
02:38:10 <merijn> jollygood2: Like many similar functions (either, bool, etc.) it follows the "elimination rule"-order, so they follow the order of constructor definition
02:38:11 <jollygood2> do tell :)
02:38:22 <merijn> "data Maybe a = Nothing | Just a" <- nothing is handled first
02:38:41 <merijn> Similarly "data Either a b = Left a | Right b" <- left is handled first
02:39:06 <merijn> "data Bool = False | True" <- false first (which is why bool isn't named "if")
02:39:11 <merijn> > bool 1 2 True
02:39:13 <lambdabot>  2
02:39:43 <jollygood2> :t fromEither
02:39:44 <lambdabot> error: Variable not in scope: fromEither
02:39:55 <ski> @type either
02:39:56 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:40:46 <ski> @type maybe
02:40:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:43:46 <jollygood2> merijn, thanks. I'm seeing the pattern
02:43:57 <asheshambasta> Aeson accumulative + custom errors: https://github.com/bos/aeson/issues/683 
02:44:07 <asheshambasta> (From what I see this is not achievable with Aeson yet)
02:45:58 <merijn> asheshambasta: I think the problem is that aeson builds on attoparsec which I think only supports string parse errors
02:46:23 <merijn> asheshambasta: So the first step would be to try and generalise attoparsec to support a more general error type, then aeson could reuse that
02:47:44 <asheshambasta> merijn: correct me if I'm wrong, but doesn't it only entail adding a data constructor to the `Result` sum type within Aeson? The errors occuring due to internal parsing (which has to do with the very json format) could still use the standard `Error String` constructor
02:48:14 <asheshambasta> and one could add say; ErrorCustom :: AesonCustomErr e => e -> Result a
02:48:25 <merijn> asheshambasta: Well, you'd need some additional work to propagate errors through the parse process and combine multiple errors, I think?
02:48:58 <merijn> But I don't think it'd be particularly hard. Megaparsec does something similar, so you could look at that for inspiration
02:49:33 <asheshambasta> merijn: for accumulative errors, I think some work was done with (<*>+) that accumulates errors
02:50:49 <merijn> Mind you, I don't know too much of attoparsec's internals, but trifecta and megaparsec both support it, so it should not be TOO hard. The biggest problem I see is the bottleneck of bos being so busy that getting quick feedback might take a bit. I'm not sure if there are other maintainers for attoparsec that respond faster
02:51:29 <asheshambasta> merijn: yeah, I wouldn't mind contributing and getting my hands dirty as soon as time permits
02:52:41 <asheshambasta> I'm just a little surprised, since in distributed settings, something like this is pretty standard (and I don't mean to be pedantic)
02:53:39 <merijn> asheshambasta: I think it's mostly "no one has needed it before", a quick glance at attoparsec's parser and IResult type suggest it should be pretty straightforward
02:57:28 <asheshambasta> merijn: cool, I'll dig in and see if I can come up with something that suits my use case; and propose a patch 
03:00:38 <merijn> asheshambasta: Basically, the parser has a continuation for failures and an annotation functions which both currently take Strings, so that's a matter of generalising them. The tricky part will be messing around and finding a good abstraction for representing the errors. For that you might wanna look at megaparsec
03:01:44 --- mode: glguy set +v allenleein
03:02:55 * hackage aivika 5.9 - A multi-method simulation library  http://hackage.haskell.org/package/aivika-5.9 (DavidSorokin)
03:03:55 * hackage aivika-transformers 5.9 - Transformers for the Aivika simulation library  http://hackage.haskell.org/package/aivika-transformers-5.9 (DavidSorokin)
03:07:06 <allenleein> hi anyone here
03:07:45 <allenleein> I'm a CS beginner, which language you would recommend me to learn first? Haskell or Purescript?
03:07:57 <merijn> allenleein: Depends on what your goal is?
03:08:51 <allenleein> build a full-stack web app
03:09:11 <merijn> I don't even know what "full-stack web app" means these days
03:10:10 <sm> this is #haskell, I'll save us some time. Haskell.
03:10:29 <allenleein> a slack clone 
03:11:09 <asheshambasta> allenleein: I'd say that is quite a giant project, if by clone you really mean _clone_ 
03:11:32 <yushyin> but please, not yet another chat system.
03:11:47 <yushyin> ;-)
03:13:10 <allenleein> :) thanks 
03:13:49 <ski> allenleein : you should learn different languages, expressing different programming paradigms, anyway
03:30:32 <jollygood2> is there a more generic filter-like function that accepts Maybe? for example, f (>0) (Just 0) => Nothing;  f (>0) (Just 1) => Just 1
03:38:05 <jle`> jollygood2: mfilter :)
03:38:09 <jle`> > mfilter (> 0) (Just 0)
03:38:11 <lambdabot>  Nothing
03:38:17 <jle`> > mfilter (> 0) (Just 1)
03:38:20 <lambdabot>  Just 1
03:38:22 <jollygood2> :t mfilter
03:38:23 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
03:38:49 <jollygood2> nice
03:39:16 <jle`> mfilter p x = x >>= \v -> v <$ guard (p v)
03:39:28 <jle`> hm...not sure if that helps at all
03:39:48 <jle`> with understanding
03:39:54 <jle`> but if you already know guard, then it makes more sense :)
03:42:21 <jollygood2> I vaguely know what guard is. iirc it is related to calling fail in do
03:42:22 <jollygood2> :t guard
03:42:23 <lambdabot> Alternative f => Bool -> f ()
03:43:12 <zzz> what is the source for the current typeclass/type hierarchy?
03:43:13 <jollygood2> or, rather, fail in do is syntactic sugar for guard
03:43:53 <dminuoso> jollygood2: No, fail is something of its own.
03:44:07 <jle`> jollygood2: it's close in spirit, though
03:44:19 <dminuoso> jle`: It all boils down to `mempty` essentially
03:44:24 <dminuoso> err jollygood2!
03:44:31 <ski> @type empty
03:44:32 <lambdabot> Alternative f => f a
03:44:35 <Ariakenom> :t \b -> if b then empty else pure ()
03:44:36 <lambdabot> Alternative f => Bool -> f ()
03:44:44 <ski> @type guard
03:44:45 <lambdabot> Alternative f => Bool -> f ()
03:44:51 <jle`> in most instances of MonadPlus, empty = fail ""
03:45:10 <jle`> so you can substitute it in your head in most situations
03:45:28 <jle`> i think the two have a shared history
03:45:30 <dminuoso> Oops! I meant `empty` of course. :)
03:46:19 <jle`> if their history is not shared, it's at least convergent
03:47:25 <ski> Agda has an interesting alternative to `fail', apparently
03:47:38 <jle`> pun intended?
03:47:56 <ski> hm ?
03:48:33 <ski> i mean you can write stuff like `do Just x <- blah where {Nothing -> bleh}; ..x..'
03:48:42 <Ariakenom> zzz:  could you elaborate?
03:48:56 --- mode: glguy set +v Botebo
03:49:13 <ski> so you can attach alternative branches to a binding command in `do'
03:50:01 <Botebo> Moreover, I'm not sure is all that stringly conversion in my solution will make everything slow.
03:51:10 <ski> Botebo : you'd better repeat your first statement, since it didn't make it through, due to you not being voiced then
03:52:41 <jle`> 🎿 oh, i was referring to Alternative being the typeclass that provides empty
03:52:55 <ski> .. oh
03:53:05 <zzz> Ariakenom: where are the relations between all the types and classes documented?
03:53:09 <jle`> so in Haskell, Alternative is itself an alternative to fail
03:53:38 <jle`> but it looks like you were talking about the do notation short circuiting syntax
03:53:44 <jle`> for patterns
03:53:55 <Ariakenom> zzz: ... all of them? like an overview?
03:54:08 <zzz> Ariakenom: yes
03:54:21 <zzz> well the ones in Prelude
03:55:07 <Ariakenom> zzz: how about https://wiki.haskell.org/Typeclassopedia
03:56:19 <Ariakenom> maybe there's some haskell tutorial that has a nice chapter as well
03:56:43 <ski> it seems like part of the motivation for `fail' was related to the one for `HasCallStack'
03:56:43 <zzz> i was thinking something more like this https://www.haskell.org/onlinereport/basic.html#sect6.3
03:57:28 <ski> jle` : yes, `fail' was introduced for a failing match in `do' to expand to
03:58:04 <ski> @undo do () <- foo; bar
03:58:05 <lambdabot> foo >>= \ a -> case a of { () -> bar; _ -> fail ""}
03:58:27 <Ariakenom> zzz: what's lacking from what you linked?
03:58:28 <Botebo> ski: I think I solved it. I'll just use JSON. That aught to be much faster than this scheme I have in mind. I was just hoping there was a faster binary serialisation scheme I could use for Persistent Entities and hand-written datatypes, so I could persiste them on memcache via one method. 
03:58:41 <Botebo> I just hope JSON is fast enough. Thanks, ski.
03:58:57 <zzz> Ariakenom: Is this complete and up to date?
03:59:11 <ski> Botebo : we still don't know what "it" is, since we only got your second message "Moreover, I'm not sure is all that stringly conversion in my solution will make everything slow.", not your first one, since you haven't repeated it yet
04:00:29 <Botebo> WAs my original message too long, ski? It shows up as two messages on my side. Let me paraphrase/summarise.
04:00:30 <Ariakenom> zzz: nope
04:00:49 <zzz> Ariakenom: that's the thing
04:01:01 <zzz> im searching for the current source
04:01:07 <ski> Botebo : nope, that's not the issue. the issue is that since there's been spam waves in Freenode, people in here can't talk, unless voiced or identified
04:01:07 <zzz> can't find it
04:01:51 <Botebo> ski: What is voicing, now? I'm not an IRC veteran. >.<
04:01:54 <ski> Botebo : when they first attempt to say something, i believe glguy has a script which will auto-voice them (if it doesn't appear to look spammy), but they still have to repeat what they said first, for it to go through, then
04:02:03 <Ariakenom> zzz: here's the 2010 version of the report, you had 98 https://www.haskell.org/onlinereport/haskell2010/
04:02:28 <ski> Botebo : it is possible to set a "channel mode" on a channel, so that only people in the channel who have been explicitly "voiced" can speak in the channel
04:03:02 <ski> (Botebo : or rather, they can still speak, but noone else will see what they said (well, the script in question can see it, otherwise it wouldn't work))
04:04:01 <Ariakenom> zzz: not sure what the latest information is
04:04:15 <zzz> Ariakenom: thank you
04:05:13 <Ariakenom> zzz: glad I could be of help at last :p
04:06:01 <Ariakenom> zzz: there' also hoogle https://www.haskell.org/hoogle/
04:06:58 <Botebo> Ski . I should repeat my message because the first message voiced me. Thanks. Lemme do that. :-)
04:07:28 <ski> Botebo : i think glguy's script should already have sent you a message telling you to repeat it. but you may have missed that
04:07:54 <ski> (at least, that's how i imagine it's being done)
04:08:27 <Botebo> ski: quote " 13:48 -!- mode/#haskell [+v Botebo] by glguy "
04:08:39 <ski> that's the script voicing you, yes
04:08:50 <Botebo> I'm trying to develop a slightly "generic" method to store data on memcache. The memcache library simple takes ByteString, which is perfect. But now I need a way to serialise not only user-space data (my own datatypes), but also Entity objects created by Persistent. I don't believe I can add arbitrary serialisation typeclasses to Persistent schema and stuff, but the solution I have settled upon is to 
04:08:56 <Botebo> derive PersistField instances (via JSON) for my user-space datatypes, and have that be converted to ByteString by the path PersistField -> PersistValue -> Show. Is there an easier way to have my cake and eat it, by allowing Persistent's auto-generated data to be stored inthe same memcached server as bespoke datatypes, without what feels like a dirty hack?
04:09:30 <ski> <Botebo> Moreover, I'm not sure is all that stringly conversion in my solution will make everything slow.
04:09:33 <ski> that's better
04:10:25 <ski> (now, i don't know anything about `memcache' or `persistent' .. but now at least you have a chance of someone else seeing your question, and being able to help)
04:10:31 <Botebo> ski: that being said, I'm probably over-complicating things. I should just use JSON and be done with it. I was hoping there was some magic binary serialisation scheme used by Persistent, by I see that it basically uses PersistField, which provides Aeson instances.
04:14:52 --- mode: glguy set +v lcrmchl
04:16:47 <lcrmchl> hello #haskell
04:22:45 <Ariakenom> hello lcrmchl 
04:24:43 <lcrmchl> what's good Ariakenom.. please help.. i always see this when trying to message someone "You must log in with services to message this user"
04:25:17 <merijn> lcrmchl: People can configure things so only identified users can message them to reduce spam
04:26:10 <lcrmchl> merijn: please how
04:26:20 <merijn> "/msg nickserv help"
05:05:55 * hackage unbeliever 0.7.3.0 - Opinionated Haskell Interoperability  http://hackage.haskell.org/package/unbeliever-0.7.3.0 (AndrewCowie)
05:05:56 <cocreature> Hm, is there a way to limit the allocations via RTS options? I can only find a way to limit heap size but that seems like I’m probably asking to create a flaky test
05:26:27 <trcc> Hi guys. When I cabal new-build a project using Haskell and FFI then it works fine. But when I cabal new-repl it, I get an error that it cannot find a function that I export from my hs library and use in my c file. The relevant files are here: https://gist.github.com/CThuleHansen/8070abed39ba0722a789a0da0871a177 anyone know what to add?
05:28:29 <merijn> trcc: You're compiling it as a library, but I think you want to compile that as an executable with a non-haskell main
05:29:03 <merijn> trcc: See the cabal file here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
05:29:27 <trcc> it is to be a library
05:29:34 <trcc> merijn: 
05:32:53 <merijn> ugh...composing functions within an Applicative is a hassle...
05:33:22 <arthurxavierx> `ado` to the rescue
05:33:56 <ski> composing, how ?
05:35:53 <merijn> ski: I have (a -> b -> c), "f a" and "d -> b" and need to construct "f (d -> c)" but ends up as a mess to write
05:37:37 <trcc> merijn: do I have to compile as an executable with a non-haskell main to use cabal new-repl?
05:37:46 <trcc> the project is to be a library
05:38:11 <trcc> cannot get dante to work either
05:38:19 <merijn> trcc: not sure what's going on and debugging linker issues over IRC is more work than I have time for now :)
05:38:27 <trcc> haha 
05:38:30 <trcc> understandable
05:38:36 <trcc> thank you though
05:38:56 <merijn> Applicative do my be the solution, I suppose
05:39:16 <merijn> I think I basically only support GHC 8.4 anyway :p
05:41:03 <ski> @type \f i g -> (\a d -> f a (g d)) <$> i  -- merijn, i suppose something like this ?
05:41:04 <lambdabot> Functor f => (t1 -> t2 -> t3) -> f t1 -> (t4 -> t2) -> f (t4 -> t3)
05:41:55 <Ariakenom> merijn: that's actually just Functor
05:42:09 <ski> one could say `\a -> f a . g'
05:42:59 <merijn> ski: Yeah, but with f and g being expressions making like 5 definitions to make things fit is a bit obnoxious...
05:43:46 <ski> ok
05:43:49 <ski> can `ApplicativeDo' expand to just a `Functor' constraint ?
05:44:05 <merijn> hmm, actually looks like my simplification wasn't quite right anyway
05:45:00 <cocreature> ski: iirc yes
05:49:44 <merijn> 10 minutes of type tetris later it works :p
05:50:48 <merijn> I love it when I manage to fix a problem without ever taking the time to understand it :p
05:53:01 <ski> @quote twice.as.hard
05:53:01 <lambdabot> Kernighan&Plauger says: "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to
05:53:01 <lambdabot> debug it." -- Brian W. Kernighan,P. J. Plauger in "The Elements of Programming Style"
05:54:38 <ski> perhaps effectively using typeful programming can reduce that gap ?
05:54:57 <ski> or perhaps one could say that some of the smarts resides in the type checker ?
05:55:18 <ski> (just pondering that quote, in the context of what you said)
05:57:17 <merijn> ski: I think so, yes
05:57:27 <Ariakenom> so you mean I have to be twice as smart as ghc :/
06:07:52 --- mode: glguy set +v Y_Sharoda
06:08:08 --- mode: glguy set +v hPutBuf
06:09:02 <hPutBuf> Hello, I am wondering what is the fastest way to write a ByteArray# with hPutBuf. Does anyone have experience with this?
06:09:27 <hPutBuf> The function hPutBuf looks like this http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hPutBuf
06:09:48 <hPutBuf> hPutBuf :: Handle -> Ptr a -> Int -> IO ()
06:10:42 <hPutBuf> So that uses a (Ptr a) and you can definitely make one of those from a ByteArray# with (byteArrayContents# :: ByteArray# -> Addr#)
06:10:54 <hPutBuf> But I am not using pinned ByteArray#
06:11:20 <hPutBuf> So I guess the question is, could there be a GC _while_ hPutBuf is running that'd break this?
06:11:34 <merijn> hPutBuf: That sounds like a question for #ghc :)
06:12:02 <phadej> yes, there could be GC which moves `ByteArray#`
06:12:18 <phadej> byteArrayContents# should really be -> IO Addr#
06:12:23 <hPutBuf> merijn: ah, I did not know about #ghc. I can try there.
06:12:42 <hPutBuf> phadej: I know there can be a GC that moves it, but I also know that certain operations block GCs
06:14:34 <phadej> I wouldn't rely on that
06:14:48 <phadej> -threaded e.g. is already quite non-deterministic
06:15:32 <phadej> hPutBuf: look how ShortByteString operations are made
06:15:43 <phadej> or actually, just use ShortByteString, as it's a wrapper over ByteArray#
06:17:31 <phadej> seems there aren't IO operations, I guess it's the reason, you really need to pin a memory to pass it to C-land to be printed out
06:17:45 <hPutBuf> It looks like there are not hPut functions in http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Short.html
06:17:57 <hPutBuf> For various reasons, ShortByteString does not suit my purposes.
06:18:09 <hPutBuf> I am just gonna ask in #ghc
06:22:52 --- mode: glguy set +v default_
06:31:18 <hPutBuf> It seems like this is too risky with the information I was able to obtain so far.
06:31:48 <hPutBuf> I have heard that GC is blocked on foreign function calls, which seems like this particular case.
06:32:01 <hPutBuf> But I'm not certain enough to go for it right now
06:42:38 <fendor> can stack somehow dump the config it is using?
06:49:23 * ski . o O ( `void foo(const size_t N,int (*parr)[N]);' )
06:52:36 <hodapp> ski: we don't dependently-type C in here >:O
06:54:00 <ski> it appears the former is allowed in GCC ..
06:54:23 <ski> but
06:54:32 * ski . o O ( `int (*bar(const size_t N))[N];' )
06:54:34 <ski> isn't
06:54:59 <hodapp> o_O
06:56:15 <dmwit> ski: It doesn't mean what you want it to mean, though.
06:56:24 <dmwit> It doesn't check that callers provide the right size of array.
06:56:51 <merijn> dmwit: It does in C99, optional annex
06:57:09 <merijn> dmwit: Or rather, mandatory annex in C99, it was made optional in C11 for being too hard to implement
06:57:21 <merijn> So no mainstream compiler ever robustly supported it
06:57:48 <merijn> dmwit: Boom! Lawyered! :p
07:00:22 <dmwit> Personally, I feel that nothing you said contradicts anything I said.
07:03:28 <ski> i was pondering to which extent this could be seen as dependent types sneaking into C
07:08:58 <sproingie> considering they still decay into an untyped pointer ...
07:09:12 --- mode: glguy set +v Ulbrec
07:09:19 <ski> ?
07:10:22 <sproingie> as in, it won't actually enforce that declaration, right?
07:11:04 <merijn> sproingie: It has to in C99 (although no compiler did)
07:12:43 <sproingie> and thus do the buffer overruns continue
07:13:19 --- mode: glguy set +v SUbbi
07:13:56 <ski> i don't think it would help with malicious buffer overruns
07:15:04 <sproingie> if you made all indexes into said array Fin?  (I'm like brand new to DT, so I may be totally off here)
07:15:13 <glguy> C99 specifies that's the user gets the sizes right, so the compiler doesn't need to check them :)
07:15:57 <sproingie> ah, nasal demons if they don't match up, not a compile error?
07:16:31 <glguy> You can use different expressions as long as the values are the same
07:16:52 <ski> `Fin' ?
07:17:01 <glguy> Maybe you declared the vla : int xs[rand()]
07:17:29 <glguy> If you want to refer to it later you'll need a different expression that evaluated too the actual size
07:17:42 <sproingie> Fin n being a bounded int < n, something i don't imagine C would have :p
07:18:01 <ski> `sizeof xs / sizeof xs[0]'
07:19:11 <glguy> Yup, that'd get the size back out and you could use it when passing that array to a function
07:19:22 <ski> sproingie : oh, ok. i was only considering how to specify the intended size, rather than specifying indices were in bounds
07:20:10 <ski>   foo(sizeof xs / sizeof xs[0],&xs);
07:20:40 <glguy> Vlas aren't necessarily stack allocated, and you can't longjmp out of a scope that has allocated one
07:21:05 <ski> hmm .. interesting
07:22:01 --- mode: glguy set +v philzook
07:47:34 <merijn> It's time for the semi-annual "Oh god, I'm so happy I rewrote this in Haskell so that refactoring is easy"-appreciation moment :>
07:48:25 * hackage hapistrano 0.3.8.0 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.8.0 (juanpaucar)
07:49:55 * hackage ngx-export-tools 0.4.2.2 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.2.2 (lyokha)
07:51:01 <bwe> I have a weird web site that expects json as one GET param, without escape characters. Data.Aeson's encode produces escape characters. How can I get the encoded JSON as String without any escape characters?
07:53:40 <lyxia> what escape characters?
07:54:07 <bwe> print $ Prelude.filter (/= '\\') "[{\"key\": \"value\"}]"
07:54:54 <bwe> lyxia: the String with backslash-escaped characters is the result of ToJSON instance.
07:55:26 <geekosaur> that coems from displayintg it as a string in source format (i.e. show theString).
07:55:53 <bwe> > show "[{\"key\": \"value\"}]"
07:55:55 <lambdabot>  "\"[{\\\"key\\\": \\\"value\\\"}]\""
07:56:36 <geekosaur> you do see the "" around it, rrigth? do you think tose are part of the string's value?
07:58:32 <lyxia> don't use print/show
07:58:40 <bwe> geekosaur: Actually I did not consider them as part of the string's value, initially. 
08:00:24 <lyxia> this filter does nothing because there are no backslashes in the actual string, they are details of the source code only.
08:00:35 <sm> merijn: \o/
08:01:11 <merijn> "show" ing a string turns it into "a string of valid Haskell syntax for the original string", which is now what you want when outputting things
08:01:28 <bwe> lyxia: I want to assign "[{\"key\": \"value\"}]" to a record of another type. However, those backslashes show up in the output of BL.putStrLn $ encode bodyData -- bodyData has a record holding "[{\"key\": \"value\"}]".
08:01:57 <cocreature> that looks like bodyData is already encoded
08:02:06 <cocreature> why are you encoding it again?
08:02:35 <merijn> sm: Had to make changes across 12 files to accommodate a new feature and the entire task consisted of "modify the core SQL query and it's type, then keep propagating the type changes until GHC stops reporting type errors" :p
08:02:37 <geekosaur> or it hasa String embedded that should actually be a JSON object 
08:04:23 <bwe> cocreature: bodyData serialises GET QueryParams to req, so one GET QueryParam is a JSON represented as String.
08:04:32 <geekosaur> that would be a harder problem especially if there's no way to recast bodyData as a JSOB object instead of its String rep
08:05:32 <lyxia> bwe: it might be more efficient to just show your code at this point.
08:11:04 <cocreature> some web APIs have an option to both provide raw input and input that should be encoded as json so if your input is already encoded you need to use the former
08:11:32 <cocreature> but yeah I agree with lyxia, seeing the code is easier at this point
08:12:22 <merijn> There's no easy way to write a NaN literal, is there?
08:13:13 <Y_Sharoda> Hello, I am using template haskell to generate an instance of TUnfold class based on the code here: https://gist.github.com/yasminemmagdi/2d1afb5f7c703e82b6164e2d3292227f 
08:13:16 <cocreature> merijn: sadly no, the same holds for +/-infinity
08:13:18 <bwe> cocreature, lyxia: I agree. I am about to leave right now. I will prepare some code I can share with you.
08:13:31 <merijn> cocreature: ugh :\
08:13:34 <Y_Sharoda> I don't know how to pattern match on the input to tunfold 
08:13:50 <cocreature> merijn: 0/0 is at least short :)
08:14:02 <Solonarv> > 1/0 :: Double
08:14:04 <lambdabot>  Infinity
08:14:13 <Solonarv> > 1/-0 :: Double
08:14:14 <merijn> cocreature: Yeah, but now I need to worry about ensuring it doesn't end up getting recomputed
08:14:15 <lambdabot>  error:
08:14:15 <lambdabot>      • Variable not in scope: (/-) :: Integer -> Integer -> Double
08:14:15 <lambdabot>      • Perhaps you meant one of these:
08:14:38 <merijn> cocreature: Because computing 0/0 >5million times seems excessive
08:14:40 <Rembane> > (1/0) * -1.0 :: Double
08:14:42 <lambdabot>  error:
08:14:42 <lambdabot>      Precedence parsing error
08:14:43 <lambdabot>          cannot mix ‘*’ [infixl 7] and prefix `-' [infixl 6] in the same infi...
08:14:53 <cocreature> merijn: well making a top-level definition for that should be easy enough
08:14:55 <Solonarv> > -1 / 0 :: Double
08:14:58 <lambdabot>  -Infinity
08:15:03 <cocreature> also I would kind of hope thata the optimizer rewrites this to nan
08:15:12 <lyxia> Y_Sharoda: you can use th-abstraction to grab type information from typename
08:15:17 <cocreature> but ofc I haven’t actually checked this
08:15:18 <merijn> Anyway, I guess technically Infinity would be a better value anyway...
08:15:22 <lyxia> Y_Sharoda: https://hackage.haskell.org/package/th-abstraction-0.2.10.0/docs/Language-Haskell-TH-Datatype.html#v:reifyDatatype
08:17:57 <Y_Sharoda> lyxia: will try this, thank you 
08:18:09 <Solonarv> ...whoa, ghci -ddump-simpl actually just works
08:20:07 <cocreature> who doesn’t love seeing some messy core in ghci :)
08:20:23 <Solonarv> cocreature: a quick test indicates that 0/0 does not get rewritten to NaN
08:20:38 <Solonarv> cocreature: use -dsuppress-all as well ;)
08:20:52 <cocreature> :(
08:21:07 <cocreature> Solonarv: not even in some cmm optimization?
08:21:21 <cocreature> yes I am just trying to get you to read through cmm for me so I don’t have to :)
08:21:27 <Solonarv> Hmm, good point -- I only checked core
08:21:48 <cocreature> and ofc if cmm doesn’t help, I’m going to ask you to use -fllvm and read through the llvm ir ;)
08:23:41 <geekosaur> NaN literals are tricky since a NaN contans more information than the printable representation usually shows
08:24:54 <cocreature> geekosaur: hm what information are you referring to?
08:25:49 <Solonarv> signaling vs. quiet is one of them
08:25:57 <ggole> 0/0 won't generate strange NaN payloads though
08:26:16 <cocreature> Solonarv: ah right, thanks
08:26:30 <geekosaur> cocreature, on intel at least the "unspecified" bits often contain an indication of the origin of the NaN
08:26:44 <geekosaur> i.e. overflow, non-real result, etc.
08:27:44 <Solonarv> also, the cmm for that still has a '0 / 0' in it
08:28:09 <Solonarv> D1 = %MO_F_Quot_W64(0.0 :: W64, 0.0 :: W64);
08:28:13 <Y_Sharoda> lyxia: Thank you for the suggestion. Unfortunately it does not solve my problem. I do not have a problem knowing information about the constructor, as much as it is how to write down the pattern match syntax that is accepted by template haskell 
08:28:53 <Y_Sharoda> I know the constructor has name MkRec2 and two arguments.. how to write that pattern within the declaration quotes? 
08:28:57 <lyxia> Y_Sharoda: you should use the function from the TH.Lib module
08:29:07 <Solonarv> Apparently I don't have LLVM available, so I can't check that.
08:30:05 <cocreature> Solonarv: fair enough :)
08:30:42 <Solonarv> and yes, I did pass -O2 :>
08:31:10 <lyxia> Y_Sharoda: tunfold $(conP conName [varP x, varP y]) = ...
08:32:53 <ggole> gcc emits a division unless -ffast-math is given, which seems right
08:34:22 <ggole> Although, hmm, that might be undefined in C
08:34:26 <cocreature> ggole: hm, why is optimizing 0/0 to nan not compliant with ieee?
08:34:55 * hackage stack2cabal 1.0.1 - Convert stack projects to cabal.project + cabal.project.freeze  http://hackage.haskell.org/package/stack2cabal-1.0.1 (tseenshe)
08:35:23 <ggole> The result might depend on rounding modes or some silly rubbish like that.
08:35:45 <ggole> (I don't know whether it does or not, actually.)
08:35:50 * cocreature sighs
08:36:22 <cocreature> (not because of you :))
08:36:33 <geekosaur> it could, especially those unspecified bits I metnioned --- but arguably if you're asking for that kind of optimization, you get what you asked for
08:36:45 <geekosaur> (hence -ffast-math in gcc)
08:38:37 <cocreature> geekosaur: right but if they’re unspecified I would have thought that optimizing would be fine even without -ffast-math
08:39:15 <geekosaur> unspecified at thee level of the standard. useful for FP debugging, whichis why Intel and some others do it
08:39:50 <cocreature> maybe I’m misremembering but I thought -ffast-math was specifically for things that violate the standard
08:39:55 <cocreature> i.e. associativity
08:40:00 <cocreature> s
08:40:04 <cocreature> s/i.e./e.g./
08:40:31 <ggole> Yeah, the optimiser can assume all sorts of things with -ffast-math
08:40:32 <geekosaur> yes, tis is kinda a abuse of the intent, unless you extend "standard" to "CPU specifciation"
08:41:28 <cocreature> clearly we need two separate flags: -ffast-math and -fvery-fast-math
08:47:25 * hackage interpolator 0.1.1 - Runtime interpolation of environment variables in records using profunctors  http://hackage.haskell.org/package/interpolator-0.1.1 (dfithian)
08:50:14 <nshepperd1> -fslow-math?
08:54:49 <cocreature> nshepperd1: and if you combine -ffast-math and -fslow-math you’ll get the wrong results but you’ll get them slow!
08:55:23 <cocreature> the best of both worlds
08:59:25 * hackage network-arbitrary 0.4.0.1 - Arbitrary Instances for Network Types  http://hackage.haskell.org/package/network-arbitrary-0.4.0.1 (alunduil)
09:05:03 <elgoosy> hi, for someone using shm (structured haskell mode) in emacs, if I select some manually the highlighted node color 'overpaints' the selection color. Is a there a way to change this?
09:05:25 <elgoosy> *text
09:06:22 <Y_Sharoda> lyxia: Yes, this solves my problem.. Thank you so much 
09:11:51 <Bish> am i right that fromEnum does overflow when having a sufficent big Integer?
09:12:24 <glguy> "fromEnum and toEnum should give a runtime error if the result value is not representable in the result type. For example, toEnum 7 :: Bool is an error."
09:12:39 <Bish> glguy: but it is :o
09:12:48 <glguy> You should mostly forget about the Enum class, it's an implementation detail of [x..y] syntax
09:12:49 <Bish> fromEnum 10000000000000000000000000000000000000000000123123213123112312313123123213
09:13:35 <geekosaur> yeh, it doesn't catch that
09:16:13 <Bish> shouldn't that make sense?
09:17:36 <geekosaur> hypothetically. practically, Enum and Bounded haver a lot of warts, and if you want "make sense" you really want something different from both
09:18:29 <geekosaur> as glguy said, they're not there to follow rules, they're there to implement other functionality
09:19:28 <c_wraith> I still think the specified Enum instance for Float and Double is bad.
09:19:48 <c_wraith> I'd rather not have the instances than have those instances.
09:22:55 * hackage stack2cabal 1.0.2 - Convert stack projects to cabal.project + cabal.project.freeze  http://hackage.haskell.org/package/stack2cabal-1.0.2 (tseenshe)
09:33:55 <Bish> c_wraith: nul, why is that?
09:34:27 <Bish> lul*
09:35:34 <c_wraith> > [1.0, 1.3 .. 2]
09:35:36 <lambdabot>  [1.0,1.3,1.6,1.9000000000000001]
09:35:47 <c_wraith> looks reasonable.
09:35:49 <c_wraith> but..
09:36:01 <c_wraith> > [1.0, 1.3 .. 2.1]
09:36:03 <lambdabot>  [1.0,1.3,1.6,1.9000000000000001,2.2]
09:36:08 <c_wraith> what?
09:36:28 <glguy> next time don't pick the wrong upper bound!
09:36:36 <Bish> oh, i see that's why
09:40:50 <dminuoso> :t fromEnum
09:40:51 <lambdabot> Enum a => a -> Int
09:41:31 <dminuoso> 18:27        @glguy | [17:12:02] "fromEnum and toEnum should give a runtime error if the result value is not representable in the result type. For example, toEnum 7 :: Bool is an error."
09:41:38 <dminuoso> glguy: Why should such instances exist at all?
09:41:55 <glguy> dminuoso: Because the other methods of the class can be implementeded
09:42:16 <glguy> the class is a hack to allow the range syntax, once you forget that it exists it doesn't matter that fromEnum does that
10:18:37 <larryba> is there no foldr with no default value?
10:18:41 <larryba> @hoogle Foldable t => (a -> b -> b) -> t a -> b
10:18:42 <lambdabot> Prelude foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
10:18:42 <lambdabot> Prelude foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
10:18:42 <lambdabot> Data.List foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
10:19:09 <larryba> ok, weird, https://hoogle.haskell.org/ did not find that one. 
10:21:29 <larryba> more type strict
10:22:00 <cocreature> the typesearch in hoogle 5 isn’t particularly good
10:22:16 <cocreature> also note that hoogle.haskell.org and haskell.org/hoogle are not the same thing
10:22:34 <larryba> I know, I thought hoogle.haskell.org is the recommended one? which one is hoogle 5?
10:22:36 --- mode: glguy set +v euler2718
10:23:24 <cocreature> hoogle.haskell.org is hoogle 5
10:23:34 <cocreature> and the one I would recommend but it does have a worse typesearch
10:23:54 <cocreature> but the index of haskell.org/hoogle is out of date and it indexes very little so even the better type search isn’t really useful
10:24:23 <larryba> I did give it the wrong type though (and, actually, I can't even use foldr1 because of the type difference)
10:24:25 * hackage vivid-supercollider 0.4.1.2 - Implementation of SuperCollider server specifications  http://hackage.haskell.org/package/vivid-supercollider-0.4.1.2 (TomMurphy)
10:25:05 <cocreature> I’m not sure what you’re looking for then
10:25:34 <larryba> I was looking for foldr1, but I forgot that elements must match accumulator. and I was puzzled why hoogle wasn't finding it
10:26:13 <cocreature> note that this isn’t some arbitrary restriction imposed by foldr1. you can’t implement something like foldr1 where the accumulator has a different type
10:26:20 <larryba> I know
10:27:00 <larryba> my actual question (give me a moment)
10:27:22 <larryba> (well this was actual too, I just didn't plan to even have this issue, and was thinking I was going mad, and that foldr1 doesn't exist :) )
10:29:42 <larryba> is there a more concise way to write this in parsec?   let prefixes = map (try . string) ["prefix1", "prefix2" ... ] in matchedPrefix <- foldr (\x acc -> x <|> acc) (head prefixes) (tail prefixes)
10:29:58 <larryba> (prefixes don't all start with the same substring)
10:30:00 <merijn> larryba: foldr with <|> is just asum :p
10:30:02 <merijn> :t asum
10:30:03 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:30:43 <larryba> oh? interesting
10:30:47 <larryba> :t (<|>)
10:30:48 <lambdabot> Alternative f => f a -> f a -> f a
10:31:04 <larryba> I am using parsec's (<|>) though
10:31:07 <phadej> :t choice
10:31:08 <lambdabot> error:
10:31:08 <lambdabot>     • Variable not in scope: choice
10:31:08 <lambdabot>     • Perhaps you meant ‘choose’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
10:31:12 <larryba> (<|>) :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
10:31:23 <devoid> :t <~~~~>
10:31:24 <phadej> it's the same
10:31:25 <lambdabot> error: parse error on input ‘<~~~~>’
10:31:26 <merijn> larryba: Parsec's <|> is "the same"
10:31:34 <devoid> :t <<<<<<<<>
10:31:35 <lambdabot> error: parse error on input ‘<<<<<<<<>’
10:31:50 <merijn> larryba: It has a slightly different precedence/fixity than Alternative's <|>, but that's it
10:32:12 <merijn> larryba: (This is because parsec and it's <|> predate the existence of Applicative and Alternative)
10:32:24 <merijn> larryba: I would also recommend against basing new codebases on Parsec
10:32:30 <phadej> asum has a name in parsec; http://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Combinator.html#v:choice
10:32:31 <devoid> :t <>>!@#myOwnOperatorThatIJustDefinedButNobodyElseCanUnderstandWithoutReadingTheDocumentation
10:32:32 <lambdabot> error: parse error on input ‘<>>!@#’
10:32:45 <larryba> so I could just hide Parsec's (<|>) and import Alternatives one, and use asum
10:32:54 <merijn> larryba: Megaparsec started as a fork of parsec, is more actively maintained and has ugly warts like this mismatch fixed
10:32:56 <phadej> devoid: FYI, you can query lambdabot in /query or via /msg
10:33:06 <devoid> phadej: then nobody else would experience my frustration
10:33:18 <phadej> ...
10:33:26 <merijn> larryba: It should also be a near drop-in replacement for parsec
10:33:39 <larryba> this is pretty old code that uses Parsec, unless MegaParsec is a drop-in replacement I'll have to continue using Parsec for this project
10:33:56 <geekosaur> for starters, you don't seem to get that to speak of an operator instead of actually having ti do something, it needs to be in parens
10:33:59 <larryba> I can try it
10:34:08 <merijn> larryba: It's near drop-in enough to be worth a try
10:34:15 <merijn> larryba: https://markkarpov.com/megaparsec/switch-from-parsec-to-megaparsec.html
10:34:44 <merijn> larryba: It depends a bit on the complexity of your current parser, of course and what parsec features you use exactly
10:34:45 <larryba> was Alternative's <|> inspired by Parsec?
10:35:07 <merijn> larryba: Yes, but in the design it was decided Parsec's fixity wasn't quite right
10:35:31 <merijn> larryba: The fixity chance has stopped parsec from replacing it's <|> with the one from Alternative, but other than that they should be identical
10:39:12 <phadej> kind of funny that megaparsec mentions (in comparison to trifecta) that megaparsec has less dependencies (which is true); but I had to port one lib to parsec because it has even less dependencies :P
10:40:48 <larryba> btw, just realized that with the way I rewrote the code, I can use foldr1
10:41:28 <larryba> good to know about MegaParsec, I'll use it in future projects, but I have to finish this one quickly. thanks all
10:48:24 <cocreature> I’m pretty happy that I’m usually not working on projects where I need to worry about the dependency footprint of megaparsec
10:49:20 <hyperisco> looks lightweight to me
10:50:34 <hyperisco> on the other hand I passed up using These from https://hackage.haskell.org/package/these because... well look at it
10:50:49 <hyperisco> how in the world does aeson get in there
10:51:38 <phadej> because having aeson-these felt stupid
10:52:10 <hyperisco> maybe aeson is the problem
10:52:28 <phadej> (these's dependencies are essentially lens + aeson)
10:52:40 <phadej> well, there is data-or
10:53:05 <hyperisco> I just redefined the data type… took about 10 lines
10:54:26 <phadej> well, These.hs is 402 lines, and I for sure have used all the instances defined there :)
10:54:43 <phadej> (i.e. I don't consider lens heavy dependency)
10:55:09 <cocreature> but you can’t use megaparsec because it’s heavy on deps? :)
10:55:17 <Levy[m]> General useful module + general useful module instances
10:55:17 <Levy[m]> Dependency when there's generally no need is quite annoying
10:55:27 <phadej> cocreature: no, I use trifecta
10:55:36 <phadej> because it's not heavy on deps either
10:56:00 <cocreature> phadej: didn’t you mention porting from megaparsec to parsec because of deps before?
10:56:17 <phadej> cocreature: yes, but that was for very special need (of criterion)
10:56:24 <cocreature> ah I see
10:56:49 <cocreature> although criterion already takes ages to compile due to statistics so adding some reasonably small deps doesn’t seem that big of a deal tbh
10:57:04 <phadej> cocreature: it introduces cycles in dependency tries
10:57:18 <phadej> trees, IIRC
10:58:01 <phadej> but I don't remember the details
10:59:28 <cocreature> ah fair enough
11:01:08 <bwe> lyxia, cocreature: Okay, I've isolated the problem into a minimum working example with expected and actual result, including the code that actually produces the actual result: https://gist.github.com/benjaminweb/59c7480344b7d5619cda519706205467
11:02:21 <bwe> I would appreciate you to share your understanding of the problem to see whether we have the same understanding.
11:02:55 <phadej> ah, no I remember
11:03:15 <phadej> I had to fork because megaparsec was GHC >= 7.8
11:03:33 <phadej> and we had to support older GHCs for criterion
11:03:49 <phadej> s/no/now/
11:04:02 <phadej> so it wasn't dep footprint, but support window
11:09:42 <cocreature> bwe: that doesn’t actually typecheck
11:09:55 <cocreature> bwe: persons is of type String but you’re passing it personList which is not of type String
11:10:37 <cocreature> so for starters change the type
11:12:58 <cocreature> Then you end up with https://gist.github.com/cocreature/70899799928d0f108908d8e9d05d03e9 which seems right to me
11:22:33 <bwe> cocreature: Yes, you got me here at changing the productive code to some non-compiling before pasting. Yup, it does compile. Unfortunately it is not right: The given API returns a valid response only if any escape backslash is absent in the query URL. How can I do that? https://gist.github.com/cocreature/70899799928d0f108908d8e9d05d03e9#gistcomment-2792795
11:29:44 <cocreature> bwe: there shouldn’t be any backslash in the data sent to the server. the backslash is coming from the fact that it is enclosed in a json string
11:33:54 <bwe> cocreature: Assuming this, should I have any backslash in the output of putStrLn then?
11:34:40 <cocreature> bwe: depends on what you intend to pass as the argument to putStrLn?
11:35:04 <cocreature> if you call putStrLn "{\"param1\":\"foo\",\"persons\":[{\"age\":\"23\",\"gender\":\"male\"}]}" you won’t see any backslashes
11:35:13 <cocreature> and that’s what the server should receive as well
11:37:18 <clever> i get a similar mess when i blindly do silly things like: print $ show foo
11:37:53 <cocreature> print $ show is almost certainly wrong, regardless of what foo is :)
11:38:07 <clever> yeah
11:38:17 <clever> and i often do: print $ "foo" <> show bar
11:38:18 <clever> as well
11:38:43 <cocreature> you need more putStrLn in your life :)
11:39:12 <clever> yeah
11:39:26 <cocreature> but yeah I’ve definitely done the same thing :)
11:39:31 <Welkin> what is with all of you and your obsession with money? `print $`
11:42:28 <Levy[m]> printing it
11:42:30 <Levy[m]> specifically
11:43:00 --- mode: glguy set +v adam_
11:43:12 <zachk> Welkin, just loves him some parentheses :) 
11:44:25 <adam_> when my ghcid reloads it only shows one screens worth of errors, then stops.  any idea what's going on?
11:44:26 <Welkin> I do
11:45:21 <lavalike> I think that's just what ghcid is programmed to do
11:45:22 <cocreature> adam_: that’s kind of the point of ghcid no?
11:45:44 <Levy[m]> adam_: could you perhaps send a paste of the errors?
11:46:27 <lavalike> maybe it could be hooked to less(1) and some signal to make less re-read the stdin on command? someone with unix knowledge might know
11:46:49 <adam_> @cocreature I guess so -- I figured it would show all the errors/warnings on each load
11:46:49 <lambdabot> Unknown command, try @list
11:46:56 <adam_> cocreature: I guess so -- I figured it would show all the errors/warnings on each load
11:48:59 <adam_> thanks!
11:50:22 <bwe> cocreature: I wished, you were right. But the response I get from the server does not convinces me: https://gist.github.com/benjaminweb/59c7480344b7d5619cda519706205467
11:51:03 <bwe> cocreature: Do you see the multiple backslashes? Is that what we want?
11:51:58 <bwe> cocreature: The result with single backslashes is after using putStrLn (yes, I need to use it more often, agreed!); I've updated the gist to reflect that behaviour.
11:54:06 <cocreature> bwe: right you are seeing the single backslashes since the data is embedded in a json string as I’ve mentioned before
11:54:31 <cocreature> bwe: really all that Haskell code isn’t really relevant here. try sending a query using curl
11:54:47 <cocreature> where your query parameter contains a quote somewhere
11:55:39 --- mode: glguy set +v asaltz
11:55:53 <cocreature> e.g. curl 'https://httpbin.org/get?param="foo"'
11:57:05 --- mode: glguy set -v asaltz
12:02:30 <merijn> Are where blocks reevaluated for every invocation of a function? i.e. if I have a binding that does not depend on function inputs is it evaluated only once?
12:02:59 <amalloy> merijn: yes, just like let
12:03:11 <merijn> bah
12:03:21 <c_wraith> depends on what ghc decides to do.
12:03:24 <amalloy> it has to be, because patterns can depend on values in where clauses
12:03:29 <c_wraith> they certainly can be floated
12:03:31 <cocreature> with -fful--laziness it should be floated out
12:03:37 <cocreature> (if it can be)
12:03:41 * ski would like to have something like SML's `local'-`in'-`end', in Haskell
12:04:04 <merijn> cocreature: I'll just make it a top level binding
12:04:08 <cocreature> which is the great thing about full-laziness and also the terrible thing :)
12:04:45 <cocreature> merijn: I wouldn’t bother tbh. if it doesn’t depend syntactically on the inputs, GHC is pretty reliable at floating it out
12:05:00 <cocreature> which is a pitty because when you don’t want that to happen, things get rather tricky
12:05:19 <bwe> cocreature: I've got it. The escaping was no problem at all. Since I considered it as one, I did not see that a request param had the wrong information
12:05:25 <merijn> > 1/0 :: Double
12:05:27 <lambdabot>  Infinity
12:06:02 <Welkin> > round (1/0)
12:06:04 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
12:06:09 <Welkin> hahaha
12:06:11 <Welkin> what!
12:06:16 <ski> in `local <decls 0> in <decls 1> end', the bindings introduced by the declarations in `<decls 0>' are visible in the declarations `<decls 1>'. but only the bindings introduced by the latter declarations are made available from the whole compound declaration for use outside of this local scope
12:06:24 <merijn> :t round
12:06:26 <lambdabot> (Integral b, RealFrac a) => a -> b
12:06:35 <Welkin> I know
12:06:42 <Welkin> I was converting to an integral
12:06:45 <merijn> Welkin: I think that's just some libgmp weirdness
12:06:54 <phadej> > maxBound :: Double
12:06:56 <lambdabot>  error:
12:06:56 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘maxBound’
12:06:56 <lambdabot>      • In the expression: maxBound :: Double
12:06:59 <Welkin> I suppose there is no Infinity for integral values
12:06:59 <phadej> argh
12:06:59 <cocreature> > round (1/0) :: Int
12:07:02 <lambdabot>  0
12:07:12 <merijn> That...is wrong
12:07:20 <cocreature> > round (-1/0) :: Int
12:07:22 <lambdabot>  0
12:07:26 <cocreature> > round (0/0) :: Int
12:07:28 <lambdabot>  0
12:07:40 <merijn> Like, I'm not sure what it *should* round to, but not that
12:07:47 <phadej> > round (0/0 :: Rational) :: Int
12:07:47 <cocreature> I conclude, round always returns 0 regardless of its input
12:07:49 <lambdabot>  *Exception: Ratio has zero denominator
12:07:56 <ski> so, you could define operations in `<decls 0>' which would be in scope in the definition equations in `<decls 1>', but since we're not talking about "attaching to defining equations" here, as with `where', `<decls 0>' would be elaborated once, and not once for each time each function in `<decls 1>' was called
12:08:05 <Welkin> `round (1/0) :: Integer` gives  179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
12:08:25 <Welkin> `round (1/0) :: Int` gives 0
12:08:35 <Welkin> it makes no sense
12:08:37 <phadej> 1/0 there is Double
12:08:45 <Welkin> ah, I see
12:09:01 <Welkin> maxBound :: Double
12:09:04 <geekosaur> it's doing something fast thatdosn't even pretend to handle NaN or Inf
12:09:05 <Welkin> > maxBound :: Double
12:09:07 <lambdabot>  error:
12:09:07 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘maxBound’
12:09:07 <lambdabot>      • In the expression: maxBound :: Double
12:09:11 <phadej> i tried that ;)
12:09:23 <phadej> > round (1/0 :: Float) :: Integer
12:09:23 <c_wraith> iirc there are some rewrite rules for round with Double
12:09:25 <lambdabot>  340282366920938463463374607431768211456
12:09:29 <Welkin> > 2^63 - 1
12:09:31 <lambdabot>  9223372036854775807
12:09:39 <phadej> you get about maxbound
12:09:43 <Welkin> so that makes no sense still
12:10:00 <phadej> well, is there a lot of sense in 1/0 to begin with? :)
12:10:10 <Welkin> it's undefined
12:10:12 <merijn> phadej: For Double there is
12:10:14 <merijn> Welkin: No
12:10:18 <Welkin> but that is how we create Inifinity in programs
12:10:36 <merijn> Welkin: IEE754 clearly specificies that dividing a positive number by 0 the result is positive infinity
12:10:47 <phadej> merijn: but why you would convert it to Integer or Int?
12:11:02 <merijn> phadej: That's unrelated to the sensibility of 1/0 :)
12:11:13 <geekosaur> Welkin, if you go digging in the source you'll find code that deconstructs Doubel into its mantissa/exponent and computes a "fast round". with a comment saying it doesn't even try to handle NaN/Inf and they get garbage
12:11:13 <phadej> throwing a (pure) exception would be make as little sense
12:11:47 <merijn> Dammit...optparse's Alternative instance is made of lies...
12:12:06 <merijn> Or rather, the Alternative instance of ReadM
12:12:34 <cocreature> merijn: how so?
12:13:48 <merijn> cocreature: I have "(Right <$> auto) <|> (Left <$> auto) :: ReadM (Either Text Int64)"
12:14:18 <merijn> cocreature: I'd expect that to parse any Int64 and return a Text otherwise, but instead non-numeric values result in parse failure
12:15:18 <jle`> interesting
12:15:21 <merijn> oh...maybe auto for text is a mess
12:15:28 <jle`> it looks like under the hood it uses a Free Alternative implementation
12:15:47 <merijn> It relies on Read, so maybe it's just being stupid and I need to fmap T.pack too
12:16:13 <Solonarv> > read "test" :: Text
12:16:15 <lambdabot>  error:
12:16:15 <lambdabot>      Not in scope: type constructor or class ‘Text’
12:16:28 <Solonarv> % read "test" :: Data.Text.Text
12:16:29 <yahb> Solonarv: "*** Exception: Prelude.read: no parse
12:16:31 <jle`> merijn: auto uses 'read', right?  so it would only take quoted and escaped strings
12:16:42 <Solonarv> % read "\"test\"" :: Data.Text.Text
12:16:43 <yahb> Solonarv: "test"
12:17:07 <Solonarv> I think there's a ready-made ReadM for any IsString instance
12:17:10 <jle`> merijn: i feel like a-text-parser-or-an-int-parser would always succeed on the text parser, if you're just taking any string
12:17:11 <merijn> oh...I need str
12:17:22 <merijn> str :: IsString s => ReadM s
12:17:57 <Solonarv> ah, that's what it is
12:18:13 <merijn> Fixed \o/
12:18:19 <jle`> or just T.pack <$> readerAsk
12:19:02 <jle`> merijn: but remember str/readerAsk will never fail
12:19:08 <jle`> so the left hand side of <|> will never be reached
12:20:28 <merijn> jle`: <|> is left to right, generally
12:20:46 <jle`> ah, i mean right hand side :)
12:21:07 <merijn> jle`: If you notice the ordering you'll notice that the Text is the 2nd part of the parser
12:21:15 <jle`> :O
12:21:19 <jle`> now that's confusing
12:21:21 <jle`> i see my confusion now
12:21:34 <jle`> the left hand side is labeled right, and the right hand side is labeled left
12:21:37 <merijn> I don't remember why that order :p
12:21:58 <jle`> it reminds me of those "say the word, not the color" exercises
12:22:28 <merijn> jle`: But it compiles so I'm not fucking with it for a slightly more logical order that might requires tens of renamings everywhere :p
12:22:43 <hyperisco> tens?!
12:22:56 <jle`> clearly you should switch to a dynamic language
12:23:20 <merijn> hyperisco: No clue where I use all that and how much that change cascades further...must've been a reason I wrote it like this
12:23:45 <merijn> hyperisco: I vaguely recall using Validation or sequence somewhere, so probably for that
12:44:05 <zachk> what does an error from cabal/ghc like this mean:  Could not find module `Prelude'   Perhaps you haven't installed the "dyn" libraries for package `base-4.11.1.0'?
12:44:52 <merijn> zachk: That you're probably on Arch?
12:45:02 <zachk> windows :-/
12:45:09 <merijn> zachk: Ah...hmmm
12:45:28 <hyperisco> aren't those… I can't remember… for cross compiling?
12:45:31 <merijn> zachk: It'd help to know how you installed GHC, how you're building, etc.
12:45:39 <zachk> i am passing cabal a : --enable-executable-dynamic , not sure what that does, the doc for clash recommends it 
12:45:50 <zachk> haskell platform ghc version 8.4.2 
12:45:59 <merijn> Ah...
12:46:17 <zachk> oh wait it says other for install commands
12:46:21 <merijn> I vaguelly recall dynamic libraries being broken on Windows for a while, not sure if that was in GHC 8.4
12:46:22 <zachk> maybe I should try that :)
12:47:17 <merijn> ok, doesn't seem to be 8.4 according to the release notes
13:08:54 --- mode: glguy set +v chalo
13:14:07 <pounce> What's the difference between <$> and <$!> ? (and why does the latter have to be in the monad class?)
13:14:25 <hyperisco> :t (<$!>)
13:14:26 <lambdabot> Monad m => (a -> b) -> m a -> m b
13:15:11 <hyperisco> going to guess it has something to do with strictness
13:15:28 <Solonarv> Yes, <$!> forces the result (the 'b')
13:15:33 <pounce> yeah, but why is it that the strictness has to do with monads
13:15:41 <pounce> couldn't you have a strict map on any functor?
13:16:07 <Solonarv> no, consider: data Unit a = Unit
13:16:22 <Solonarv> clearly this is a functor, but there isn't any value to force!
13:17:46 <pounce> hmm
13:17:53 <hyperisco> it is also a Monad
13:19:06 <Solonarv> ah, right. Bah.
13:20:23 <hyperisco> with >>= you can force the result to depend on the result of the mapping function, but not with fmap
13:21:44 <hyperisco> and this is just because with >>= you get to say what the next monadic value is, so you can add a dependency to it with seq
13:22:05 <jle`> Solonarv: Unit is also a Monad, though
13:22:11 <jle`> (the one you defined)
13:22:25 <Solonarv> yes, hyperisco pointed this out already. It was a bad example.
13:22:30 <jle`> oh, ah
13:22:36 <jle`> i missed that
13:23:20 <sonofentropy> hi, is there a way to export my session from ghci to hs file? do you know about any place i can find some info?
13:24:27 <pounce> ooh i didn't know ghci had breakpoints
13:27:39 <zachk> sonofentropy, I would just code in text edtior and :load it into ghci 
13:28:14 <merijn> sonofentropy: ghci doesn't really support that, no
13:28:37 <merijn> I think someone was working on ghci based Jupyter notebooks, but tbh, I just do what zachk says
13:28:38 <sonofentropy> zachk: i’m actually doing a crazy exercise, id like to write few simple exercises ghci only and export the sessions to review my thought process
13:29:17 <sonofentropy> editor -> ghci -> git loop is way toooo tedious 
13:29:28 <Welkin> what is git in there for?
13:29:40 <sonofentropy> to record notes
13:29:53 <sonofentropy> and experiment with different ideas
13:29:56 <Welkin> I don't see how it's tedious to write your code, use a keyboard shortcut to save, then type :r in ghci to reload
13:32:45 <sonofentropy> Welkin: hmm, well i have similar loop in emacs now, but I still believe there is a faster way to it
13:33:41 <sonofentropy> especially when doing research and experimenting, maybe in abstract way, i want to retain different branches of ideas and experiments in form of a conversation with haskell
13:34:09 <pounce> use acme? :/
13:34:11 <Welkin> you can save a new file each time
13:34:16 <Welkin> C-x C-w
13:34:18 <zachk> sonofentropy, you can make your own ghci commands, I forget the details, perhaps you could have a custom command in your .ghci that runs the command and appends it to a textfile 
13:34:24 <Welkin> it can contain all of your comments etc.
13:38:25 * hackage filestore 0.6.3.4 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.3.4 (JohnMacFarlane)
13:39:31 <sonofentropy> hmm, oh, I actually found the dummiest answer to my problem: ~./ghc/ghci_history under git, and auto versioning as zachk says as a custom ghci command  
13:40:22 <zachk> sonofentropy, I believe ghci runs your commands kind of in the IO monad most of the time, so you might need to wrap your code in a main 
13:40:41 <crestfallen> hi how do I get rid of this long note and have ghci load as it does in lines 17-22 ? https://paste.ee/p/b0pEY    thanks
13:41:34 <crestfallen> I forget what I did in stack config when it began to load this way..
13:41:45 <fr33domlover> Q: I have an algorithm that gradually adds stuff to a HashMap, in each step it has to lookup stuff, update and insert back inside. But when a key is added it never gets removed to it's guaranteed a future lookup will succeed. My code has to handle HashMap.lookup returning Nothing althougn it practically can't happen - is there a way I can use types to mark that guarantee and have the lookup always succeed
13:41:47 <fr33domlover> for a key I already inserted?
13:42:01 <fr33domlover> Like some HashMap that records the keys in the type?
13:42:23 <comerijn> fr33domlover: Can you? Probably. Will it be worth the hassle? Probably not.
13:42:28 <sonofentropy> thanks zachk, I will experiment with few different ways ^w^
13:43:36 <fr33domlover> comerijn, well, it could be worth it in the sense of catching errors :P
13:43:57 <fr33domlover> Just wondering if such a thing exists
13:44:46 <__monty__> fr33domlover: Just use M.! and catch any errors and throw "This shouldn't happen /shrug." : )
13:45:48 <crestfallen> i.e. it used to load with just lines 17-22
13:46:06 <c_wraith> fr33domlover, have you seen the justified-containers package?
13:46:10 <fr33domlover> __monty__, yeah that's what I'm doing :P
13:46:31 <c_wraith> @hackage justified-containers
13:46:31 <lambdabot> http://hackage.haskell.org/package/justified-containers
13:47:24 <fr33domlover> c_wraith, nope, looking at it now thanks :)
13:49:16 <zachk> fr33domlover, there is fromJust in Data.Maybe, or you can just use fmap or do notation with the Maybe monad 
13:51:24 <__monty__> zachk: In the case of Data.Map I think both intent and performance are better for (!) than fromJust after lookup.
13:51:25 <amalloy> zachk: fromJust is not really any different from using M.!, and fmap/do only help if you're willing for your whole computation to be in Maybe
13:51:48 <amalloy> if you believe it can never fail, i wouldn't put the computation in Maybe
13:51:57 <crestfallen> or perhaps there is a flag to use. "st" is an alias for stack ghci      https://paste.ee/p/b0pEY
13:52:02 <zachk> you could also use maybe with a sane or insane default 
13:52:25 <Welkin> if it cannot fail it shouldn't be a maybe
13:52:37 <Welkin> but yes I have run into this problem a lot when using Map/Set or similar
13:52:40 <comerijn> Welkin: Not always feasible to encode that
13:53:19 <Welkin> so in the case of Nothing I just have to act like nothing happened
13:53:22 <Welkin> it feels very dirty
13:53:37 <Welkin> essentially it fails silently
13:53:54 <Welkin> because I *know* the key exists in the Map based on some other data
13:54:05 <Welkin> and if it's not there, well, there is nothing to do
13:54:19 <Rembane> fromMaybe (error "This really shouldn't happen...")
13:54:41 <Tuplanolla> The canonical error message is "The impossible just happened".
13:54:41 <Welkin> but do you reall want the entire application to fail?
13:54:54 <Welkin> if it's not something critical
13:55:14 <Welkin> I'm running into this problem now with Elm
13:55:16 <jle`> to me, returning Maybe is a part of the public API
13:55:18 <Rembane> It depends on the application. 
13:55:32 <Welkin> but runtime exceptions/failures are not allowed in code
13:56:03 <Welkin> so the only option is to silently fail
13:56:13 <Welkin> or call some javascript through a port that blows it up somehow
13:56:32 <c_wraith> too bad elm doesn't give you the tools things like justified-containers or gdp provide to put that information into the type system.
13:56:43 <Welkin> gdp?
13:56:58 <c_wraith> @hackage gdp
13:56:58 <lambdabot> http://hackage.haskell.org/package/gdp
13:57:08 <c_wraith> ghosts of departed proofs.
13:57:25 <c_wraith> an extension of the idea from justified-containers.
13:59:13 <Welkin> elm is great, but I do wish the type system had just a little more functionality. I've had to compromise at times by not having access to things like functional dependencies
14:00:28 <Welkin> how is ghcjs doing lately? Any word on haskell -> wasm?
14:00:40 <comerijn> Welkin: There's a wasm effort independent of ghcjs
14:00:53 <comerijn> I don't think ghcjs is trying to support wasm anytime soon
14:01:04 <comerijn> (But I could be wrong)
14:02:19 <Solonarv> Welkin: haskell->wasm implemented TodoMVC recently, there's a post on /r/haskell about it
14:02:34 <Solonarv> It's an independent effort from GHCJS though
14:06:19 <Rembane> Solonarv: This one? https://www.reddit.com/r/haskell/comments/a7x9c5/tweag_io_ghc_webassembly_backend_reaches_todomvc/
14:06:32 <Solonarv> Yes, that's the one I was thinking of
14:10:20 <Rembane> Sweet! 
14:10:28 <Wizek> Anyone here who has ran into a stack unregistering loop?
14:11:00 <Wizek> similar to this: https://stackoverflow.com/questions/45770444/what-can-cause-stack-build-to-keep-unregistering-local-dependencies-every-time?
14:56:37 --- mode: glguy set +v vyraj
16:18:55 * hackage slack-verify 0.1.0.0 - Slack API Request Verification HMAC  http://hackage.haskell.org/package/slack-verify-0.1.0.0 (kkweon)
16:43:55 <royal_screwup21> I'm trying to write a simple dsl. Why is my address field set to null, when it should be "foo"? https://thepasteb.in/p/zmh81jRLK4otZ
16:46:33 <zachk> royal_screwup21, what language is that?
16:46:41 <royal_screwup21> kotlin
16:47:13 <royal_screwup21> I know offtopic, but give how functional my problem is I thought I'd try anyway :)
16:49:11 <Solonarv> I don't actually know enough of the syntactic constructs in there to know what's going on
16:50:23 <Solonarv> I'd suggest trying #kotlin ? :P
16:51:40 <royal_screwup21> no responses :(
17:39:12 * hackage typesafe-precure 0.7.2.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  http://hackage.haskell.org/package/typesafe-precure-0.7.2.1 (igrep)
17:45:23 <Solonarv> question: I'm getting a 'permission denied' error using cabal new-build on windows, here's the error - https://gist.github.com/Solonarv/cd99581494b343e4a81272ce35a6e9d2
17:45:37 <Solonarv> Anyone know what's up with that?
17:50:05 <dmj`> Solonarv: windows?
17:50:09 <dmj`> bruh
17:50:33 <Solonarv> bruh
17:50:36 <Solonarv> dont diss me
17:51:32 <Solonarv> jokes aside, I'm somewhat stuck on windows ATM
17:56:52 <dmj`> Solonarv: can you gist that log file it produced
17:57:45 <Solonarv> one sec
17:57:50 <dmj`> bruh
17:58:50 <Solonarv> pff, I can't - permission denied
17:59:34 <dmj`> Solonarv: do you have cygwin installed
17:59:47 <Solonarv> probably somewhere
17:59:49 <dmj`> Solonarv: or can you cabal new-build with verbosity
18:01:28 <Solonarv> Added -v output to the gist
18:04:21 <Solonarv> Doesn't really have any extra info :/
18:05:42 <dmj`> Solonarv: stack?
18:06:04 <dmj`> Solonarv: apecs configures fine for me on Darwin
18:06:12 <Solonarv> yeah, I have that installed. Want me to try building with it?
18:06:21 <dmj`> couldn't hurt
18:06:36 <dmj`> would help to isolate the issue
18:07:00 <dmj`> Solonarv: there is a linux sub system for windows now, you could install nix on it and do real haskell dev
18:07:11 <Solonarv> I'm not on win10
18:07:20 <dmj`> bruh
18:07:39 <Solonarv> and that doesn't help if I'm trying to write something that'll run on windows outside of WSL
18:08:52 <Solonarv> bah, stack can't parse my cabal file. Time to upgrade, I guess?
18:10:06 <Solonarv> I don't think cabal or apecs are the culprit, though. That log file isn't accessible through other means (e.g. notepad) either.
18:12:48 <dmj`> Solonarv: can you try vanilla cabal
18:12:48 <Solonarv> I can't even delete it1
18:12:57 <dmj`> Solonarv: that's weird you can't delete it...
18:13:09 <dmj`> Solonarv: can you `cabal new-clean` ?
18:13:11 <dmj`> is that a thing
18:13:16 <dmj`> I don't use `cabal` or `stack`
18:13:21 <Solonarv> yeah I honestly think this file has a spook
18:13:31 <dmj`> Solonarv: blow it up
18:15:27 <Solonarv> hmmm... I think there might be a ghost process holding on to it?
18:16:02 <Solonarv> yeah, there was a ghost ghc process for some reason
18:18:06 <Solonarv> I killed it, now it's working
18:18:53 <Solonarv> Sure would be nice to get a proper error message instead of a "permission denied" stonewall
18:19:20 <Solonarv> dmj`: thanks for the help!
18:19:38 <dmj`> Solonarv: it's working? nice!
18:20:17 <Solonarv> yup, at least it seems to
18:20:45 <Solonarv> it's taking awfully long to build but tbh that's not very surprising on my system
18:20:59 <illandan[m]> dmj`: Just curious, if you don't use cabal or stack, how do you work with other haskell libraries in your code?
18:21:18 <illandan[m]> dmj`: do you manually run Setup.lhs and install them ?
18:21:31 <illandan[m]> *Setup.hs - but you get where I'm going with this
18:22:08 <Solonarv> nix, I assume
18:23:14 <dmj`> illandan[m]: yes, I use nix to build and incrementally develop haskell packages with a customized shell.nix
18:23:39 <dmj`> illandan[m]: inside your shell.nix you can define a shell hook and make functions like function build () { runghc Setup.hs configure && runghc Setup.hs build } 
18:23:55 <dmj`> illandan[m]: then when you enter the shell with `nix-shell` you can just call `build`
18:24:02 <dmj`> or even w/o entering the shell `nix-shell --command build`
18:24:42 <illandan[m]> dmj`: Ah, nix. Okay - I briefly toyed with nix, but didn't do much with it other than installing the one package I wanted to play with 
18:25:11 <Solonarv> nitpick: that's still using Cabal-the-library, just not cabal-install :>
18:25:21 <dmj`> Solonarv: sure :)
18:25:22 * illandan[m] adds Nix to the TODO file
18:25:37 <dmj`> illandan[m]: it's extremely powerful, you can have an entire company's infra in a single set.
18:28:26 <dmj`> illandan[m]: here's a good list of things you can do to alter your haskell build using nix https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/lib.nix
18:29:32 <illandan[m]> dmj`: Thanks, will take a look. The one time I played with it, I didn't like exposing / (/opt, I think), even as an one-time setup. 
18:30:49 <Solonarv> IIRC nix lives almost entirely in /nix
18:31:34 <dmj`> illandan[m]: if you ever plan on doing anything sophisticated like calling into other langs, using third-party deps. It quickly becomes a garbage fire if you're using just stack or cabal.
18:32:02 <illandan[m]> Yeah, think so. So, I was looking at guix as an alternative to play with. Never got around to it, though
18:34:20 <dmj`> illandan[m]: Using scheme would probably be more pleasant than nix
18:34:34 <dmj`> illandan[m]: but I'm not sure it has an ecosystem like that of nixpkgs
18:35:03 <dmj`> illandan[m]: guix uses the nix daemon though
18:35:55 * hackage aws-lambda-haskell-runtime 1.0.9 - Haskell runtime for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.0.9 (NickSeagull)
18:36:08 <illandan[m]> dmj`: It's growing and I think it's comparable to nix - the only thing going against it is, it's lack of support for non-free apps/packages
18:36:29 <illandan[m]> Not sure if it allows packages outside the gnu org
18:37:37 <illandan[m]> It's totally in my TODO list, need to check both guix and Nix
18:41:57 <dmj`> interesting, I wonder if it just uses nixpkgs
18:44:32 <illandan[m]> dmj`: Here's an old blog post that talks about the package manager is really the same between guix and nix: http://sandervanderburg.blogspot.com/2012/11/on-nix-and-gnu-guix.html
18:50:40 <dmj`> illandan[m]: "The Nix expression language is a lazy purely functional language, whereas Guix uses eager evaluation, although the derivation files that are produced and built are still processed lazily by the Nix worker." that's a trip dude
18:50:53 <dmj`> illandan[m]: laziness does make a lot of sense for package management, not sure how I feel about this
18:52:41 <illandan[m]> dmj`: Old post - I'd give it the benefit of doubt :-)
18:53:08 <illandan[m]> It's from 2012, we should read everything it says with a grain of salt
18:53:33 <dmj`> I dunno man, you just don't change your language's evaluation strategy
18:55:18 <Levy[m]> It still only evaluates as much of the dependency graph as it needs to
18:55:44 <Levy[m]> There shouldn't be much of a change when the daemon is finally replaced
19:00:52 <illandan[m]> Levy: There's a plan to replace nix-daemon? Do you have a link that talks about it?
19:03:43 <Levy[m]> I'll check the mainling list, they haven't updated it for quite a while now and everything new is in guile
19:08:09 <Levy[m]> There's no concrete plan as of now but several hints have been given by Ludo and others so can interpret as you wish. Though avoiding upstream means the nix-daemon used by guix missed out on quite a few performance updates along with making an update quite a bit of work.
19:10:13 <illandan[m]> Levy: Ah, okay. Thanks - it had me a little amused, btw :-)
21:23:51 --- mode: glguy set +v derelict
21:31:50 <hololeap> i'm trying to understand the vault library: what purpose it serves and what makes it different from a regular immutable map. in the docs and the blog it says that it is a persistent store, but i don't know what that is supposed to mean
21:50:49 <infinisil> hololeap: A regular Map can't store values of different types, `Map Int String` can't store `[String]`'s
21:51:34 <infinisil> hololeap: And persistent because you can't ever change it, it's an immutable data structure and you can keep old versions around that will never change. IORef in comparison doesn't do that
21:58:53 <hololeap> infinisil: thanks for the answer
23:37:55 * hackage recursion 2.2.0.1 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-2.2.0.1 (vmchale)
