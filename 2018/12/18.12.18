00:02:48 <suzu> @t curry
00:02:48 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
00:02:53 <suzu> @type curry
00:02:54 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:03:02 <suzu> @type uncurry
00:03:03 <lambdabot> (a -> b -> c) -> (a, b) -> c
00:03:16 <suzu> i always get these swapped lol
00:07:00 <ski> `curry' returns a function in curried style
00:12:16 <suzu> curry un-tuples a function
00:12:20 <suzu> uncurry tuples a function
00:12:34 <suzu> curry adds partial application
00:12:36 <suzu> uncurry removes it
00:12:43 <suzu> i guess that's not too hard ot remember if i put it that way
00:29:31 <jle`> suzu: you can also think of currying in terms of the actual action of currying
00:30:07 <ski> @type uncurry curry
00:30:09 <lambdabot> ((a, b) -> c, a) -> b -> c
00:30:23 <jle`> suzu: do you know what currying is? like, the function transformation
00:30:58 <ski> (one can think of that as (non-curriedly) partially applying a (non-curried) function, to an argument. therefore one can think of `curry' as (curriedly) applying a (non-curried) function, to an argument)
00:31:02 <jle`> suzu: currying is when you take a multi-argument function and turn it into a single-argument function returning a function
00:31:14 <jle`> so, that's exactly what 'curry' does
00:31:20 <jle`> it takes a (a, b) -> c, a multi-argument function
00:31:29 <jle`> and turns it into an a -> b -> c, a single argument function returning a function
00:31:34 <jle`> 'curry' *curries* the function
00:31:51 <jle`> an `(a, b) -> c` is a function that takes an 'a' and a 'b'
00:32:02 <ski> (note : Haskell doesn't have multi-argument functions. they have to be encoded, if expressed in Haskell. curried style is one way to do that encoding. tupled style is another way)
00:32:03 <jle`> and a `a -> (b -> c)` is the curried form of that function
00:32:15 <jle`> an `(a, b) -> c` is, essentially, a multi-argument function
00:32:41 <jle`> because it's how you'd define a multi-argument function in other languages
00:32:41 <ski> (and `curry',`uncurry' translates between these two encodings, for two-argument functions)
00:32:43 <jle`> `foo(x,y)`
00:32:49 <jle`> is how you'd define a multi-argument function in other languages
00:33:19 <jle`> like callMyFunction(arg1,arg2,arg3)
00:33:26 <jle`> is C-style function application
00:33:44 <jle`> so we can do the same thing in haskell, `callMyFunction (arg1,arg2,arg3)`
00:34:18 <jle`> a function like `myFunction :: (Int, Bool) -> String` is something you'd call as `myFunction(3, True)`
00:34:28 <suzu> yes, i know what currying yeah
00:34:32 <suzu> currying is, yeah *
00:34:33 <jle`> *currying* `myFunction` would be turning it into an Int -> (Bool -> String)
00:34:46 <jle`> so 'curry' will curry a function
00:34:54 <jle`> in that sense, it's hard to mix them up :)
00:35:16 <jle`> 'curry' is actually currying
00:35:51 <ski> > let max (x,y) | x <= y = y | otherwise = x in map (map max) [[(x,y) | x <- [0 .. 3] ] | y <- [0 .. 3]]  -- `max' is not like a two-argument function in say C, we can apply it to a *pair* of numbers directly, instead of explicitly having to give both arguments separately
00:35:53 <lambdabot>  [[0,1,2,3],[1,1,2,3],[2,2,2,3],[3,3,3,3]]
00:36:01 <jle`> if you think "i have a multi-argument function that i want to curry.", then use curry
00:36:15 <jle`> if you think "i have a curried function that i want to turn into a multi-argument function. i want to uncurry it." then use uncurry
00:36:44 <jle`> in short: if you want to curry a function, use curry :)
00:37:38 <ski> > let max (x,y) | x <= y = y | otherwise = x in map (map max); p = (5,3) in max p  -- simpler example of same thing. we don't have to write `max (5,3)' or `max (fst p,snd p)' here
00:37:41 <lambdabot>  <hint>:1:60: error: parse error on input ‚Äò;‚Äô
00:37:57 <ski> er
00:38:05 <ski> > let max (x,y) | x <= y = y | otherwise = x; p = (5,3) in max p  -- simpler example of same thing. we don't have to write `max (5,3)' or `max (fst p,snd p)' here
00:38:07 <lambdabot>  5
01:02:45 --- mode: glguy set +v Guest83
01:07:07 <Guest83> https://www.youtube.com/watch?v=xZmZ9U79MgU
01:29:48 <julianleviston> Guest83: pokemon videos aren‚Äôt really on topic ;-)
01:36:37 <fnurglewitz> julianleviston: maybe it's a pokemon game written in Haskell
01:55:26 <koz_> inb4 'monads are like Eevees'.
01:57:35 * hackage cloudi 1.7.5 - Haskell CloudI API  http://hackage.haskell.org/package/cloudi-1.7.5 (okeuday)
01:57:58 <bartavelle> more like magikarp >=>
02:00:52 <coldpress> this is now a pokemon channel
02:19:14 <tdammers> well, at least there is a golang version, aptly named "Pok√©mon Go"
02:32:29 <DigitalKiwi> tdammers: https://pbs.twimg.com/media/Dur8xE9XgAE-sEv.jpg:large
02:33:32 <tdammers> :)
02:57:02 <Athas> Does anyone here have experience or documentation regarding packaging Haskell programs for Debian?
03:17:16 --- mode: glguy set +v Guest2
03:50:32 <lavalike> @package cabal-debian
03:50:32 <lambdabot> http://hackage.haskell.org/package/cabal-debian
03:50:35 <lavalike> Athas: maybe this is a start
03:51:30 <Athas> lavalike: thanks.  I also found #debian-haskell on OFTC.
03:54:34 * hackage ngx-export-tools 0.4.2.0 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.2.0 (lyokha)
03:55:21 <nan`> ewo
04:46:04 <cjay-> What's the best way to do conversions like '(a, Maybe b) -> Maybe (a,b)', or similar things with Either or swapped order in the tuple? I came up with 'uncurry (\a -> fmap (\b -> (a,b)))', but that's still ugly and might count as obfuscated code.
04:47:31 <hpc> :t sequence
04:47:32 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:47:38 --- mode: glguy set +v Flyers
04:47:51 <tdammers> I'd just spell it out
04:47:52 <hpc> > sequence ((), Just "")
04:47:54 <lambdabot>  Just ((),"")
04:48:27 <hpc> i don't know that sequence is the best expression of that idea, but it has that type
04:48:46 <tdammers> or maybe write it in applicative style: \t -> (fst t,) <$> snd t
04:49:17 <tdammers> or maybe even with a do block: \(a, mb) -> do { b <- mb; return (a, b) }
04:50:28 <cjay-> hmm tuple sections makes it a bit nicer
04:51:21 <hpc> :t traverse
04:51:22 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:52:26 <hpc> i think that do-notation one is the most clear
04:52:46 * hackage jose 0.8.0.0 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.8.0.0 (frasertweedale)
04:56:25 <tdammers> yes, I'm quite partial to that as well
04:56:34 <tdammers> signals the intent
04:57:01 <cjay-> oh, sequence actually does the right thing. might no be intuitive though.
04:57:05 <cjay-> or sequenceA for non-monads
04:58:01 <cjay-> I'm so used to sequence being applied to lists
04:58:19 <tdammers> the name is a bit misleading
04:58:28 <hpc> it used to be just for lists
04:59:26 <tdammers> I think the original situation that led to its inception was "I have a list of IO actions that I need to run in sequence"
04:59:55 <tdammers> but now you can also have a Maybe of Lists, for example
05:00:00 <nan`> hello, i am debugging a program that outputs an error. It prints a CallStack of a single line (from HasCallStack). The callstack is only one line long. I noticed if i add "HasCallStack =>" constraint to the enclosing function i get a two line trace. Is there any way, during debugging, to infer HasCallStack everywhere?
05:00:09 <cjay-> yeah. maybe it should get an alternative name. insideOut or something like that.
05:00:57 <tdammers> it's not that bad after all, I think
05:01:09 <hpc> it can't be named flip, without additional instances
05:01:16 <hpc> :t sequence const
05:01:17 <lambdabot> Traversable ((->) a) => b -> a -> a
05:01:23 <tdammers> you can use the list-of-actions metaphor as a mnemoic, and still understand the generalization
05:05:05 <cjay-> I'm not sure making types of functions like that more general is a good idea. It certainly causes confusion.
05:05:13 <cjay-> There could be two versions like with map and fmap
05:06:43 <tdammers> the Haskell community, for better or worse, loves generalizing things
05:06:57 <tdammers> and I believe it usually pays off
05:07:04 <hpc> tdammers: in general, at least
05:08:14 <Ariakenom_> -.-
05:09:16 * hackage unix-time 0.4.2 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.4.2 (KazuYamamoto)
05:09:51 <hpc> generalization works out really well in haskell because it simultaneously gives you more freedom and more knowledge
05:10:02 <hpc> which is pretty rare in other languages
05:10:17 <hpc> more freedom because you can use the function in more places
05:10:26 <hpc> and more knowledge because more general types admit fewer valid definitions
05:10:36 <hpc> :t id -- the only well-defined function of this type
05:10:37 <lambdabot> a -> a
05:10:45 <hpc> :t (+1) -- not even close to the only function of this type
05:10:46 <lambdabot> Num a => a -> a
05:13:31 <__monty__> Though to be fair, the prelude has things like map because of cjay-'s concerns.
05:14:01 <cjay-> hpc: good point about the 'more knowledge' part
05:14:42 <Ariakenom_> fmap with laws is the same
05:16:52 <cjay-> generalization is awesome, it's just that names signal intent. when something suddenly becomes more general, it doesn't signal the same intent any more.
05:17:01 <hpc> that's true
05:18:15 <hpc> signaling intent is one of my favorite weird things about programming that people don't really think about
05:18:25 <hpc> you can write two pieces of code that look very different
05:18:32 <hpc> they both compute the exact same identical desired result
05:18:35 <hpc> but one of them is WRONG
05:22:37 <beginnerSOL-M> Hey, we have this function: 06[a] -> Int -> a , can we say this function takes ONE argument? I know that this function "looks like" it takes TWO arguments, but my question is based on the concept of CURRYING. can we "technically" say it takes ONE argument ? I'm asking this because I'm thinking about this: 06[a] -> ( Int -> a )
05:23:01 <nan`> does anyone know where i can read about how HasCallStack works and why it works that way? Something beyond the docs at https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stack.html
05:25:39 --- mode: glguy set +v daniel_bla
05:25:48 --- mode: glguy set +v shiat
05:26:29 <Ariakenom_> beginnerSOL-M: Yes, it takes one argument [a] and returns a function (Int -> a)
05:29:04 <lyxia> nan`: https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack/ImplicitLocations
05:31:02 <Ariakenom_> beginnerSOL-M: I would say every 2-argument function is also a 1-argument function.
05:32:02 --- mode: glguy set +v default
05:32:36 <beginnerSOL-M> Ariakenom_ Ok, now, can we also say this function returns one element of type ùëé from a list?
05:34:27 <__monty__> beginnerSOL-M: All haskell functions are one-argument functions.
05:35:17 <beginnerSOL-M> __monty__ ok, can we also say this function returns one element of type ùëé from a list?
05:35:18 <Ariakenom_> beginnerSOL-M: You mean if we can deduce that from the signature?
05:35:36 <beginnerSOL-M> Ariakenom_ Yes
05:36:13 <__monty__> Yes, we can, from this signature [a] -> Int -> a, not from this one though Int -> a
05:36:25 <beginnerSOL-M> Or we can object that "a" could be something other than "being an element of that list" ?
05:36:41 <__monty__> If you know nothing else about a you can't.
05:37:21 <__monty__> The something else could me (Monoid a) for example, in which case it could return mempty rather than an element.
05:37:38 <Ariakenom_> well it's from the list or some error. and from Int -> a it's just some error
05:38:07 <Ariakenom_> with some syntactic subtleties related to scoping
05:38:36 <__monty__> Yes, or bottom technically. But I always reason fast and loose : )
05:39:22 <berndl> Would someone explain to me how Haskell is determining the type of fmap counit . unit in this code: https://pastebin.com/raw/YtniBpWP
05:39:33 <__monty__> Since haskell's type system isn't sound I *think* we can't actually conclude anything from any type signature technically.
05:39:40 <beginnerSOL-M> :) But I can't understand it, this is one of the chapter exercises from the HaskellBook (chapter 5, a multiple choice question), sounds like first and second choices are both correct.
05:41:10 <beginnerSOL-M> A function of type [a] -> Int -> a
05:41:10 <beginnerSOL-M> a) takes one argument
05:41:11 <beginnerSOL-M> b) returns one element of type ùëé from a list
05:41:12 <beginnerSOL-M> c) must return an Int value
05:41:13 <beginnerSOL-M> d) is completely fictional
05:41:25 <berndl> OK, nevermind.
05:41:28 <nan`> lyxia: thanks i'll check it out
05:41:58 <__monty__> beginnerSOL-M: b) isn't true. The function returned *by* the function taking one argument of type [a] is a function that returns an element from a list.
05:42:02 <berndl> It's instantiating a = G b.
05:43:29 <beginnerSOL-M> __monty__ You mean the Int -> a part?
05:43:57 <__monty__> beginnerSOL-M: Yes, the function with that type is a function that returns an element of a list.
05:44:36 <beginnerSOL-M> __monty__ so what does the entire function return? what is that "a" ?
05:45:05 --- mode: glguy set +v Flyers
05:45:09 <beginnerSOL-M> Can't understand it :(
05:46:06 <__monty__> beginnerSOL-M: You seem to already understand it. [a] -> Int -> a is the same thing as [a] -> (Int -> a), not just looks like the same thing or something, it's the exact same thing.
05:46:36 <__monty__> So the function takes a list and returns a function. This returned function is the function with the behavior in b).
05:47:01 <__monty__> But the question isn't about the returned function it's about the original function.
05:47:25 <marxS> hey, so somebody sent me this link yesterday http://colah.github.io/posts/2015-09-NN-Types-FP/
05:47:26 <DigitalKiwi> which is (!!)
05:47:33 <marxS> and it was interesting but it seemed a little primitive
05:47:39 <marxS> has there been anymore exploration of this area?
05:48:14 <beginnerSOL-M> __monty__ Oh, got it, thanks :-)
05:56:27 <Guest83> https://www.youtube.com/watch?v=1GIxaS6Ubh4
06:13:08 * hackage container 1.1.6 - Containers abstraction and utilities.  http://hackage.haskell.org/package/container-1.1.6 (iamrecursion)
06:27:34 <dminuoso> @let data Foo = Foo Int String
06:27:36 <lambdabot>  Defined.
06:28:07 <dminuoso> @let bar = Foo 1 "magic"
06:28:08 <lambdabot>  Defined.
06:28:48 <dminuoso> @let txt = case bar of Foo _i t -> t
06:28:50 <lambdabot>  Defined.
06:28:59 <dminuoso> Is there a more compact way to do this binding `txt`?
06:30:37 <dminuoso> Although.. I guess this is pretty compact already. :)
06:30:49 <[Leary]> @let Foo _i txt' = bar
06:30:50 <lambdabot>  Defined.
06:30:53 <[Leary]> > txt'
06:30:55 <lambdabot>  "magic"
06:33:10 <Ariakenom_> like let (_i, txt) = (1, "magic")
06:33:19 * hackage convert 1.5.1 - Safe and unsafe data conversion utilities with strong type-level operation. checking.  http://hackage.haskell.org/package/convert-1.5.1 (iamrecursion)
06:37:09 * hackage functor-utils 1.17.2 - Collection of functor utilities, providing handy operators, like generalization of (.).  http://hackage.haskell.org/package/functor-utils-1.17.2 (iamrecursion)
06:39:41 * hackage impossible 1.1.4 - Set of data and type definitions of impossible types. Impossible types are useful when declaring type classes / type families instances that should not be expanded by GHC until a specific type is provided in order to keep the types nice and readable.  http://hackage.haskell.org/package/impossible-1.1.4 (iamrecursion)
06:40:38 <Putonlalla> The documentation for `base` says that "the thread itself can't be garbage collected until you drop the `ThreadId`. This misfeature will hopefully be corrected at a later date". Does this suggest that I should not rely on this behavior or that the behavior should be standardized?
06:41:34 * hackage layered-state 1.1.5 - Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.  http://hackage.haskell.org/package/layered-state-1.1.5 (iamrecursion)
06:41:37 <Ariakenom_> Putonlalla: Does it matter if you rely on it or not?
06:41:45 <Putonlalla> Avoiding stale references doesn't sound like a misfeature to me.
06:42:39 <dminuoso> [Leary]: Oh wow! Simpler than I thought. :)
06:42:42 <dminuoso> [Leary]: Thank you.
06:43:35 * hackage layouting 1.1.4 - General layouting library. Currently supports layouting 2D areas and can be used as a backend for text pretty printing or automatic windows layouting managers.  http://hackage.haskell.org/package/layouting-1.1.4 (iamrecursion)
06:43:42 <davean> Putonlalla: the miss-feature is that it holds memory around that it doesn't need to
06:44:01 <dminuoso> Ariakenom_: Yeah that's not an option, the data type is from a library - otherwise I would have included field accessors. :)
06:44:36 <davean> Putonlalla: I'm not sure how you rely on it blocking GC
06:46:05 * hackage lens-utils 1.4.6 - Collection of missing lens utilities.  http://hackage.haskell.org/package/lens-utils-1.4.6 (iamrecursion)
06:46:28 <Putonlalla> If your thread dies and gets garbage collected, what guarantees that the next thread you start has a `ThreadId` that is distinct from the now-stale `ThreadId` you didn't inspect yet, davean?
06:46:37 --- mode: glguy set +v euler2718
06:48:04 <davean> The fact that ThreadId is a reference.
06:48:05 * hackage monad-branch 1.0.4 - Monadic abstraction for computations that can be branched and run independently.  http://hackage.haskell.org/package/monad-branch-1.0.4 (iamrecursion)
06:48:53 <davean> its uniqueness and its holding memory are entirely seperate issues
06:49:09 <davean> You can get all 4 combinations of those two characturistics
06:49:10 <Putonlalla> Are they? How do you guarantee uniqueness without using any memory?
06:50:21 <dmwit> UUIDs, perhaps
06:50:23 * hackage monoid 0.1.9 - Monoid type classes, designed in modular way, distinguish Monoid from Mempty and Semigroup. This design allows mempty operation don't bring Semigroups related constraints until (<>) is used.  http://hackage.haskell.org/package/monoid-0.1.9 (iamrecursion)
06:50:25 <davean> Well theres a few ways - the most obvious becomes when you realize the language is garbage collected
06:50:41 <davean> But you can do it without GC easily too
06:51:52 <dmwit> Oh, reading the context, please ignore my UUID comment. It's completely unrelated.
06:52:08 <Putonlalla> I think you're still assuming that the `ThreadId` holds some information, not just everything that goes into creating a thread.
06:52:18 <dmwit> Putonlalla: Reaping the data structures referenced by a dead thread and reaping the ThreadId itself are just two completely separate actions.
06:52:25 <davean> Yep
06:52:31 <Putonlalla> Yes, this confused me.
06:52:34 <davean> Plus the actual value of the ThreadId can change
06:52:36 <dmwit> Putonlalla: Reaping the data referenced by a dead thread doesn't necessarily mean you stop using the memory you need to remember which ThreadIds are used.
06:52:48 <davean> The GC can rewrite ThreadId#
06:52:54 <Putonlalla> Everything makes sense, but the documentation could be better.
06:53:05 <davean> How?
06:53:14 * hackage prologue 3.2.6 - Better, more general Prelude exporting common utilities.  http://hackage.haskell.org/package/prologue-3.2.6 (iamrecursion)
06:54:24 <dmwit> Now that we have WeakRef it probably isn't even that hard to fix -- should be no new tricks needed in the GC or anything.
06:55:08 * hackage terminal-text 1.1.2 - Text data type for styled terminal output, including all standard ANSI effects (bold, italic, blinking) and ANSI / 256 / truecolor colors support for Unix and Windows (whenever possible).  http://hackage.haskell.org/package/terminal-text-1.1.2 (iamrecursion)
06:57:05 * hackage typelevel 1.2.3 - Useful type level operations (type families and related operators).  http://hackage.haskell.org/package/typelevel-1.2.3 (iamrecursion)
06:57:14 <davean> Putonlalla: it even calls out that they're different in the documentation
06:59:05 * hackage vector-text 1.1.6 - Text implementation based on unboxed char vector.  http://hackage.haskell.org/package/vector-text-1.1.6 (iamrecursion)
07:31:50 <fr33domlover> In OverloadedStrings, when is 'fromString' applied, as build time or as runtime?
07:32:23 <geekosaur> runtime. also true of Num's fromInteger
07:33:00 <geekosaur> there is currently no way to get things to be evaluated at compile time, aside from TH/QQ with limitations
07:33:37 <merijn> Add an asterisk there :p
07:33:39 <fr33domlover> geekosaur, thanks :) Yeah I've been using some TH/QQ but it's such a trivial case I was hoping to avoid it
07:34:06 <merijn> Because in reality GHC generate specific binary literals for string literals and the fromString can be replaced with RULE so that it doesn't actually run on an actual String
07:34:24 <merijn> For example, Text goes straight from dense binary blob to Text's binary format without going through String
07:34:51 <merijn> fr33domlover: What are you using it for?
07:34:54 <geekosaur> true. bu it's still happening at runtime, it's just the formatis different
07:35:19 <geekosaur> (and doesn't match Text'sintrnal format, so stll runtime overhead to upack/repack)
07:35:36 <fr33domlover> merijn, to have typed URIs in my code. I guess if I verify them once, I can use 'fromString' and be sure it will succeed at runtime :p
07:35:52 <merijn> fr33domlover: Ah, sounds like you need exactly what I wrote :)
07:36:16 <fr33domlover> merijn, hm what did you write?
07:36:25 <merijn> fr33domlover: I have (long term) plans to change the API a bit, but it's already usable: https://hackage.haskell.org/package/validated-literals
07:37:28 <merijn> fr33domlover: It does use TH, but it's quite nice, I think :) It solves exactly the problem you have of "I want to apply a partial fromString, at compile time!" and as a bonus, the current version actually embeds the result of the conversion in the compiled code, rather than redoing it at compile time
07:37:34 * hackage posix-paths 0.2.1.6 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.2.1.6 (NiklasHambuechen)
07:37:55 <merijn> oh, hmm...apparently I didn't release my current version on Hackage yet
07:39:54 <merijn> I should finally fix that, then...maybe over Christmas
07:40:43 <merijn> fr33domlover: Things like typed URIs was one of the use-cases I had ;)
07:41:51 <merijn> fr33domlover: Depending on how much you like to mess around and experiment you can take the 'test' branch from git and play with it. Any comments/feedback on it before I finalise it would be useful :)
07:42:51 <titusg> Hi, I've got a problem getting ghc-mod to work, fails building cabal-helper -- https://gist.github.com/jimburton/7895d937fe60d0e97deac3eb29f2ab32 any ideas?
07:43:04 <fr33domlover> merijn, it feels like the Data.Default of compile time literals ^_^ That's basically what I do, I have a 'parseURI' function and I wrapped it with TH to produce the literal at compile time
07:44:38 <fr33domlover> merijn, btw perhaps you could reuse the TH Lift class?
07:44:42 <merijn> fr33domlover: I was initially trying to get this functionality into GHC, but they wanted a proof-of-concept to see if anyone wants it
07:44:53 <fr33domlover> Like if a type has an instance, use it to produce the literal?
07:45:06 <merijn> fr33domlover: It already uses Lift by default :p The new version in my test branch makes that more explicit
07:45:46 <fr33domlover> merijn, ah great :)
07:46:01 <merijn> fr33domlover: The default implementation for "spliceValid" uses Lift, but the spliceValid setup is...a bit hacky
07:46:38 <merijn> fr33domlover: I plan to switch to this: https://github.com/merijn/validated-literals/blob/test/ValidLiterals.hs#L66-L77 (also adds error reporting!)
07:47:46 <merijn> That leaves less room for "wrong" implementations :)
07:49:05 * hackage snap 1.1.2.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-1.1.2.0 (DougBeardsley)
07:49:31 <fr33domlover> merijn, looks great!! :)
07:49:45 <fr33domlover> I like the separation between the TH and the validation
07:50:30 <merijn> fr33domlover: Yeah, I wanted for (most cases) to allow people to use it *without* needing to know TH. At first that was messy, but now that GHC has -XDeriveLift that's much easier
07:50:52 <merijn> Because if you can derive a Lift instance you need 0 TH to write instances
07:51:38 <merijn> liftResult just exists so you can work around things that *can't* be Lift instances (like the ByteString example: https://github.com/merijn/validated-literals/blob/test/examples/ByteString.hs#L21-L22)
07:51:41 <fr33domlover> merijn, yeah I'm using it for my URI use case
07:56:01 <fr33domlover> merijn, if GHC had this thing I'd definitely use it
07:56:19 <fr33domlover> Actually, it seems much better than fromString or fromList to me
08:02:51 <merijn> That's why I wrote it :p
08:03:19 <merijn> fr33domlover: Help increase adoption, so next time I bring it up on the GHC trac I can point to uses of that library ;)
08:12:42 <codedmart> Is `floatingOrInteger` the best way to go `Scientific -> Integer`?
08:14:42 <dminuoso> Wow what interesting behavior. So I managed to change something in such a way, that my program gets progressively slower - and my profiling output is a little borked (it seems to be doing something wrong with cost centers)
08:15:18 <dminuoso> Specifically I'm getting a particular cost center that has a 99% individual cost with no costs below it.
08:20:25 <cocreature> dminuoso: maybe you just haven‚Äôt generated any cost centres below it?
08:21:13 <dminuoso> cocreature: Mmm why would that happen?
08:21:37 <tdammers> cost centres don't generate themselves
08:21:57 <tdammers> there's a switch to automatically generate them for top-level identifiers, but other than that, you have to explicitly add them
08:23:18 <cocreature> there is also a switch to generate them for more than top-level identifiers but it‚Äôs still a switch
08:23:29 <dminuoso> Oh. I feel almost silly.
08:23:42 <dminuoso> I kind of expected new-build's --enable-profiling to do that for me.
08:23:44 <cocreature> also those switches are to be used with caution as cost centres mess with optimizations
08:23:56 <cocreature> dminuoso: cabal has a profiling-detail flag
08:24:54 <cocreature> iirc cabal defaults to exported functions for libs and top-level functions for executables
08:25:15 <dminuoso> That would explain it.
08:30:18 <lortabac> hello, can anyone suggest me an alternative to selda for Postgresql?
08:30:23 <dminuoso> cocreature: Great thanks, this looks much better. Now I have a real mystery to debug :)
08:30:38 <dminuoso> lortabac: postgresql-simple
08:31:20 <lortabac> dminuoso: I would prefer a library that handles migrations
08:32:22 <dminuoso> lortabac: You could use a mini library like `drifter` to handle migrations for you.
08:33:01 <lortabac> dminuoso: that's what I used to do, but I prefer handling migrations in the code
08:33:20 <dminuoso> cocreature: Oh hah turns out it was a neatly placed infinite loop that just burned CPU so much, that other threads were slowed down. :)
08:33:38 <lortabac> dminuoso: the problem with manual migrations is that I know that sooner or later I make mistakes
08:34:20 <lortabac> selda is very well designed IMHO, but it has too many bugs
08:34:43 <dminuoso> lortabac: Which is why a non-magic library might be more sensible.
08:34:44 * hackage haskell-names 0.9.6 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.9.6 (AlexandrRuchkin)
08:39:15 <lortabac> dminuoso: oh, drifter looks interesting
08:43:09 <nefple[m]> Semi-related, just curious if there's any code-first migration libraries?
08:43:44 <dminuoso> What is code-first exactly?
08:44:09 <nefple[m]> Write your models (in code) and generate migrations based on those models/changes to those models
08:44:32 <tdammers> that would require expressing changes to the models somehow, no?
08:44:42 <tdammers> or at least tracking them
08:45:32 <lortabac> nefple[m]: selda, that's the reason why I'm using it
08:45:32 <nefple[m]> Yeah, I think usually there's a tool that looks at your models, looks at your current schema, and diffs them
08:45:54 <nefple[m]> Oh lol, nice
08:46:26 <lortabac> but it has lots of bugs, and not enough man power to fix them
08:49:06 <nefple[m]> I also see postgresql-orm in hackage
08:52:52 <dminuoso> nefple[m]: The main issue I have with that, is that often the model change alone is not expressive enough for non-trivial tasks.
08:53:07 <dminuoso> Schema migrations frequently go hand in hand with data migrations.
08:53:28 <dminuoso> Or you end up with scenarios where you avoid data migrations because your code-first migration approach cant incorporate the latter one.
08:53:45 <dminuoso> (Accumulating cruft and legacy)
08:54:38 <dminuoso> Here I simply have simple up/down scripts for each migration, a small table that tracks which migrations were run - and an orchestrator that just runs the up/down scripts as needed for deploy/rollback scenarios.
08:54:58 <dminuoso> Any "accidents" are caught by running this in test/staging pipelines.
08:59:55 <lortabac> nefple[m]: dminuoso: most of the problems I am actually having with the "code-first" approach are related to indexes
09:00:30 <lortabac> for various reasons it's very hard to express indexes in the model
09:00:50 <lortabac> and there are lot of edge cases
09:01:34 <lortabac> dminuoso 's solution is simpler indeed, I think that's what I'll end up doing
09:36:56 <fr33domlover> @help
09:36:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:37:02 <fr33domlover> @help tell
09:37:02 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
09:37:38 <fr33domlover> @tell merijn Hi, will you be pushing the new version of validated-literal to Hackage? I'd love to use it
09:37:38 <lambdabot> Consider it noted.
09:38:39 <fr33domlover> @tell merijn Although even if you don't yet, I can still use it directly from git :)
09:38:39 <lambdabot> Consider it noted.
09:39:46 --- mode: glguy set +v _bo
09:40:48 <_bo> Hello lads! Reading learnyouahaskell and wanted ask what's the difference between writing "do 0 = []" and "do n | n == 0 = [] otherwise..."?
09:41:24 <_bo> Is there any reason for using guards instead of just adding another function declaration for a very specific case?
09:41:35 <geekosaur> nothing; the first gets changed to the second. bt only for numric literals
09:41:59 <geekosaur> for enumerated types, the first is faster and avoids requiring an Eq instance
09:42:22 <Boomerang> _bo: You would want to use guards when the condition is more complicated, for example `even n`
09:42:29 <__monty__> _bo: You can't always express things as pattern matches `f a b | a == b =...` can't be expressed without the guard.
09:43:41 <Boomerang> geekosaur: pattern matching on `0` does require Num and Eq, but yes when you pattern match on a constructor you don't need Eq
09:44:04 <geekosaur> yes, that was my point
09:44:55 <Boomerang> :t let f 0 = "test" in f
09:44:55 <_bo> Oh, ok, I see, thank you everybody
09:44:56 <lambdabot> (Eq a, Num a) => a -> [Char]
09:52:26 <nefple[m]> What's the difference between `let f 0 = "test" in f` and `let f 0 = "test"` ? Why the "in"?
09:52:48 <nefple[m]> Is it just for the `:t`?
09:53:44 <seishun> :t \x y -> fromEnum $ x == y
09:53:45 <lambdabot> Eq a => a -> a -> Int
09:53:53 <seishun> is there a simpler way to define this function?
09:53:55 <_bo> BTW, can anyone suggest an IDE that would help with syntax highlight and probably even point me to the syntax errors, because ghci is way too hardcore for me
09:53:58 <koala_man> nefple[m]: the latter is a ghci specific thing
09:54:35 <glguy> nefple[m]: (let f 0 = "test" in f) makes an expression
09:54:39 <nefple[m]> @koala_man ah, ok. Thanks
09:54:39 <lambdabot> Unknown command, try @list
09:54:49 <glguy> nefple[m]: It's not really about GHCi
09:55:20 <glguy> nefple[m]: when you write: let <definitions> in <expression>; all of the definitions are in scope for to be used in the expression
09:55:26 <koala_man> fair enough
09:55:39 <nefple[m]> So it's like a lambda, but with pattern-matching?
09:56:04 <glguy> lambdas are a syntax for defining an anonymous function value
09:56:42 <amx> _bo: this is a neverending pain point... currently I use VS Code with the haskell syntax extension, as well as ghcid in a terminal
09:57:17 <amx> _bo: you can also try haskell-ide-engine, supposedly that works well already, but I didn't try it yet
09:58:36 <geekosaur> nefple[m], let without in is part of do syntax, and turns into: let ... in do ...
09:59:01 <dminuoso> data Env = Env { env_pool :: Pool (forall s. DbHandle s) }, what is the idiomatic way of encoding this without enabling impredicative polymorphism?
09:59:01 <dminuoso> Would that be with just a newtype wrapper and ExistentialTypes?
09:59:06 <geekosaur> haskell deals in expressions. "do" creates a large expression.
10:01:25 <dminuoso> err *ExistentialQuantification of course
10:02:00 <lyxia> dminuoso: newtype AllHandle = AllHandle (forall s. DbHandle s)
10:02:12 <dminuoso> lyxia: Ah, gotcha.
10:02:36 <dminuoso> lyxia: Is that not impredicative polymorphism too though?
10:02:47 <lyxia> no
10:03:16 <dminuoso> Or is that a form that happens to be supported by GHC?
10:03:37 <lyxia> you could put it that way yes
10:05:34 * hackage HDBC-postgresql 2.3.2.6 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.3.2.6 (rsoeldner)
10:11:56 <dmwit> dminuoso: Yes, it is a special form that's well-supported. That form in particular is RankNTypes, and for reasons I don't fully understand allowing impredicativity only under arrows is easier (possible) to support than allowing impredicativity under all type-level terms.
10:15:57 <pounce> gah, i really want to use a package but i think it's outdated XwX. Also cabal is confusing
10:18:16 <amx> pounce: could be. might not be. impossible to say with that description.
10:19:57 <pounce> yeah... sorry. I'm pretty sure it is: http://hackage.haskell.org/package/PSQueue
10:20:24 <dmwit> seishun: I think that's about as simple as it gets.
10:21:14 <amx> pounce: that should be an easy fix for any hackage trustee
10:21:20 <dmwit> :t (.) (.) (.) fromEnum (==)
10:21:22 <lambdabot> Eq a => a -> a -> Int
10:21:34 <dmwit> seishun: If you hate your readers, ^ =)
10:21:46 <dmwit> I explicitly recommend not doing this.
10:21:57 <seishun> trying to figure out how it works...
10:22:15 <Solonarv> :t let owl = ((.) . (.)) in fromEnum `owl` (==)
10:22:15 <DigitalKiwi> LGTM
10:22:16 <lambdabot> Eq a => a -> a -> Int
10:22:56 <glguy> amx: Package trustees can't upload new versions of things, they can only revise bounds
10:23:04 <dmwit> seishun: Of course, it's simpler to avoid needing this in the first place.
10:23:48 <seishun> :t ((.) . (.)) fromEnum (==)
10:23:50 <lambdabot> Eq a => a -> a -> Int
10:24:03 <amx> pounce: what is the problem exactly? No install plan due to base < 4.11?
10:24:54 <geekosaur> is there some reason that particular package is needed? there's several pq/psq packages on hackage
10:25:34 <geekosaur> (although if it's a dependency of something else, that won't help)
10:25:57 <dmwit> I wonder what bad property of outdated things pounce is concerned about in particular.
10:26:14 <glguy> The bound for PSQueue is there because the package isn't compatible with other versions
10:31:39 <pounce> amx: I'm not sure. Here's what cabal's saying: https://ptpb.pw/mwaP dmwit: the only main problem I have with it is that I can't figure out how to install it :p
10:31:50 <amx> I see. In that case I would just copy the source to my project, fix the Prelude import to make it work with newer base and be done with it.
10:32:12 <pounce> sounds good ^^
10:32:41 <pounce> all I'm really looking for is a clean priority queue with a decrease priority method, do y'all know of any?
10:33:10 <sm> psqueues ?
10:34:29 <glguy> pounce: It's not compatible with the version of GHC you're using
10:34:30 <glguy> rejecting: base-4.12.0.0/installed-4.1... (conflict: PSQueue => base>=4
10:34:48 <glguy> base comes with GHC and you can't upgrade it without upgrading GHC
10:35:00 <glguy> (that's how to interpret that message)
10:35:23 <pounce> ah, I see
10:37:03 <pounce> sm: I saw this and didn't think there was an altor priority method, but now that I'm looking at it closer it might be possible.
10:40:28 <sm> pass (-1) I guess
10:41:31 <shapr> I just used ghcup to install 8.6.3 on my new laptop, I really like ghcup
10:41:50 <shapr> it's very close to rustup, I can have multiple versions installed and switch among them
10:42:04 <glguy> Oh my, I missed 8.6.3 coming out :)
10:42:29 <shapr> glguy: try installing it with ghcup!
10:42:37 <MarcelineVQ> shapr: neat I'mma try that to see if it fixed my cabal troubles
10:42:39 <glguy> Does that work on mac?
10:42:45 <shapr> uh, I don't know
10:42:55 <shapr> I'm boring, I only use Linux
10:42:56 <glguy> Installing GHC has never been trouble for me, I don't know what an extra tool would do
10:43:06 <MarcelineVQ> "ghcup makes it easy to install specific versions of ghc on GNU/Linux as well as MacOS (aka Darwin),"
10:43:42 <shapr> I do intro to Haskell pretty often, getting GHC installed on a random person's system has caused me much frustration in the past, this seems to fix most of my troubles.
10:43:56 <glguy> I guess I should practice using it so I can tell other people how to.
10:44:44 <shapr> Also discovered that using compiling Haskell code with GHC on 12 cores eats 2% of my battery per minute
10:44:58 <sm> stack can do it on windows too
10:45:45 <shapr> sm: yeah, I dunno if ghcup works on windows
10:47:37 <glguy> shapr: OK, ghcup is pretty slick
10:48:12 <pounce> I want to write Dijkstra's algorithm in hs :o
10:51:53 <nefple[m]> I did (most of) my DS&A class in Haskell and remember Dijkstra's being particularly state-y and tricky.
10:54:05 * hackage semilattices 0.0.0.3 - Semilattices  http://hackage.haskell.org/package/semilattices-0.0.0.3 (robrix)
10:54:23 <dminuoso> Mmm, why do I get the error regarding an escaping type variable if I use the newtype RankNType encoding of an existential, but not with the data ExistentialQuantification?
10:54:34 <dminuoso> https://gist.github.com/dminuoso/f123b740825d52ad803a041244b3ac2f
10:55:05 <glguy> dminuoso: Those aren't two different encodings of the same thing
10:55:14 <glguy> They are two different things
10:59:04 <Solonarv> ghcup does not work on windows AFAIK
11:00:34 <Solonarv> I installed it with `stack setup --resolver ghc-8.6.3 --install-ghc` and then added `dirname $(stack exec --resolver ghc-8.6.3 -- where ghc)` to my PATH
11:01:57 <dminuoso> glguy: What's the difference between moving the forall in front of or behind the type constructor?
11:02:03 <dminuoso> Err. *data constructor in fact!
11:02:36 <cocreature> dminuoso: one creates an existential constructor and one creates a constructor with a polymorphic field
11:02:40 <dminuoso> Ah!
11:10:47 <monochrom> Sometimes, "forall" really means forall. >:)
11:12:18 <dminuoso> glguy: My question remains then, in what way is a type variable escaping?
11:14:30 <cocreature> dminuoso: pool has type Pool (Ldap s) for some fixed s. it doesn‚Äôt have type forall s. Pool (Ldap s)
11:16:36 <monochrom> I am unable to explain escaping, but yeah I can say that pool is monomorphic, "AllLdap foo" requires foo to be polymorphic.
11:17:52 <monochrom> pool is monomorphic because if you have "\pool -> ..." that pool is monomorphic. The Haskell Report requires this.
11:18:17 <monochrom> You have "\pool -> ..." because do-notation desugaring.
11:18:27 <cocreature> that‚Äôs not true in the context of RankNTypes is it?
11:18:45 <monochrom> It is still true when you don't have enough type annotations.
11:19:08 <cocreature> right but you can‚Äôt fix this with type annotations here so the reason is different
11:19:20 <cocreature> :t (>>=)
11:19:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:19:32 <cocreature> we don‚Äôt have impredicate types so "a" has to be monomorphic
11:19:47 <monochrom> Oh! Yes that's a closer cause.
11:21:22 <monochrom> What is the type of createPool?  (I need only to see its type variables. and "forall"s if any.)
11:21:50 <pounce> Just wondering, how would I turn a [Maybe a] to an [a] where the `Nothing` elements are removed
11:22:12 <cocreature> pounce: catMaybes
11:22:14 <geekosaur> :t catMaybes
11:22:15 <lambdabot> [Maybe a] -> [a]
11:22:47 <pounce> Where do I import this from?
11:22:55 <cocreature> @hoogle catMaybes
11:22:55 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:22:55 <lambdabot> Data.Conduit.List catMaybes :: Monad m => Conduit (Maybe a) m a
11:22:55 <lambdabot> Distribution.Compat.Prelude.Internal catMaybes :: () => [Maybe a] -> [a]
11:23:02 <nefple[m]> :t filter isJust
11:23:02 <nefple[m]> It's in Data.Maybe I believe
11:23:03 <lambdabot> [Maybe a] -> [Maybe a]
11:23:04 <geekosaur> or: \xs -> [ x | Just x <- xs ]
11:23:07 <dminuoso> monochrom: https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html#v:createPool 
11:23:08 <pounce> thanks :)
11:23:08 <monochrom> God I miss impredicativity on odd-number days.
11:23:28 <cocreature> filter isJust isn‚Äôt sufficient, you still need to map fromJust after that which is kind of silly
11:24:15 <pounce> geekosaur: oh yeah... it might be better to just do this with list comprehensions 
11:24:18 <dminuoso> cocreature: The error message still strikes me as odd. It rather sounds like a unification problem where it cant unify `forall s. s` with `s0` for some instantiated type variable s0
11:24:32 <dminuoso> Or wait.
11:24:37 <dminuoso> It can unify them, which is the problem.
11:24:46 <dminuoso> So now I have s0 leaked outside.
11:25:12 <dminuoso> Or.. Im not entirely sure here. 
11:25:31 <cocreature> yeah I‚Äôm not sure I entirely understand the escaping here
11:25:37 <cocreature> might just be a weird error message
11:26:16 <pounce> I always get in the mindset of just using filters/folds/etc. When list comprehensions are probably easier XwX
11:27:09 <dminuoso> cocreature: At least I understand what you said, and why my code is wrong. So thats been very helpful, thanks to all of you
11:27:11 <geekosaur> list comprehensions are sugar for that
11:27:32 <monochrom> Is it imperative that you must pass around a polymorphic forall s. Pool (Ldap s)?
11:28:25 <dminuoso> monochrom: So I have functions along the lines of `(forall s. Ldap s -> IO a) -> IO a` where I use the quantification to prevent accidents where ldap connections are leaked.
11:29:28 <monochrom> That is the opposite of forall s. Pool (Ldap s). Or forall s. Ldap s.
11:30:17 <monochrom> Admire my mathemagic:  (forall s. L s -> T) = (exists s. L s) -> T  so you would like an existential type instead.
11:32:20 <dminuoso> monochrom: Yeah, so all I did was add resource-pool to the mix and I didn't want to drag a pointless type variable along.
11:32:32 <dminuoso> So I guess `data AllLdap = forall s. AllLdap { getPool :: Pool (Ldap s) }` is really what I want.
11:33:25 <monochrom> There is a deeper question that bugs me.
11:34:42 <dminuoso> monochrom: One that bugs me is.. it seems I shouldnt be able to use `getPool` at all.
11:34:48 <dminuoso> In fact, what type does it even have
11:34:58 <monochrom> So createPool is polymorphic, if you give it create :: IO Int it will give you pool :: Pool Int, if you give it create :: IO Foo it will give you pool :: Pool Foo, etc.
11:36:04 <monochrom> So at this point you're giving it create :: IO (Ldap s), and it's happy to give you pool :: Pool (Ldap s). Up to this point s is still an unknown (but it's going to be monormorphic).
11:36:41 <monochrom> The hope is type inference can look at the rest of the context and find out where you nail s.  But your code doesn't.
11:37:03 <monochrom> It is kind of like the "show . read" problem.
11:37:36 <dminuoso> Heh indeed getPool is unusable.
11:37:44 <dminuoso>  Cannot use record selector ‚ÄògetPool‚Äô as a function due to escaped type variables
11:37:55 <dminuoso> Now this escaped type variable I understand. =)
11:38:29 <dminuoso> monochrom: Does it really matter in this case though?
11:39:06 <monochrom> This consideration leads me to believe that "data Env s = ... Pool (Ldap s) ..." is not a pointless introduction of a type variable.
11:39:14 <dminuoso> monochrom: The reason it's relevant for `show . read` is that the choice of types is actually meaningful. When you instantiate a type variable and toss it away because it's an existential and it's scope has ended..
11:39:29 <dminuoso> Mmmm.
11:39:49 <monochrom> Yeah to be sure it bugs me but I haven't checked what the compiler says.  Maybe it's actually OK.
11:40:17 <monochrom> I'm going to whip up a toy example to see what really happens.
11:40:34 <dminuoso> monochrom: Please do let me know about your findings, Im really curious what you find out.
11:41:39 <cocreature> as a rule of thumb, unless GADTs are involved existentials mostly don‚Äôt solve the problems people try to use them for :)
11:42:37 <dminuoso> cocreature: Im just trying to apply the ST trick.. prevent the escaping of an Ldap connection handle while holding an escaped Ldap connection handle in my hand.
11:43:09 <day> how can i lazily repeat a given random element [Int] e.g. "[1,2,3] -> [1,2,3,1,2,3..]" ?
11:43:21 <lyxia> cycle
11:43:24 <dminuoso> Im slowly realizing that my entire attempt is quite.. silly.
11:43:31 <lyxia> > cycle [1,2,3]
11:43:32 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
11:46:41 <jadrian> to use Control.Categories.Cartesian, don't I just need to list categories-1.0.7 in stack.yaml under extra-deps?
11:46:42 <day> lambdabot: thanks
11:46:47 <day> lyxia*
11:46:52 <jadrian> referring to this: from http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Category-Cartesian.html
11:46:58 <monochrom> The ST technique goes like this: All functions except one stays rank-1 type, e.g., "newRef :: ST s (Ref s)", "readSTRef :: Ref s -> ST s Whatever".  You have only one function, an "eliminator", that goes rank-2 and it goes like "runST :: (forall s. ST s a) -> a"
11:49:28 <cocreature> And then you hack ($) in the hopes that people get less confused by the lack of impredicative types and end up confusing them more :)
11:50:13 <monochrom> Oh God, why is "data Hide = forall a. (Hide (Pool a))" a syntax error?! I thought it's always harmless to add redundant parentheses!
11:50:46 <dminuoso> @let a :: (Int); a = 1
11:50:48 <lambdabot>  Defined.
11:50:56 <monochrom> Actually now with BlockArguments you no longer need $ for that.  runST do pure ()  is just fine!
11:51:24 <cocreature> monochrom: you don‚Äôt need the forall for that to break, data T = (C) is also a syntax error
11:51:28 <Solonarv> Yeah, BlockArguments is awesome
11:52:06 <monochrom> runSudo do make me a sandwich :)
11:52:09 <adamCS> If anyone is good with Vinyl/Frames:  I'm trying to build a general "aggregate" fold over a frame (a collection of vinyl Rec ElField).  I can write it for concrete types but when I try to generalize it, I am getting an ambiguous type error that I don't understand and can't banish with various subset constraints: https://pastebin.com/BGy8q3rt
11:52:57 <pounce> I've finished writing one function XwX
11:53:08 <adamCS> Any thoughts, hints, or pointers for how to understand what's going on are most welcome.  
11:53:27 <dminuoso> cocreature: But yeah, https://gist.github.com/dminuoso/a54dc9663adadbc0d7b5ab40a3b0f092 so what happens I think is, in line 6 `g` is used with some instantiated type variable `a0`.
11:54:21 <dminuoso> But that would mean that the inner type of `R` must be `a0` while still being available outside of (R r) (since it came from line 6)
11:57:05 <dminuoso> Oh well screw it, Im getting rid of this attempt - too many quantifications flying around left and right for no benefit.
12:01:53 <lyxia> adamCS: as is ambiguous, try adding a (Proxy as) argument
12:02:54 <adamCS> lyxia: really?  It says as0, which I assumed meant some other thing that was an intermediate step.  But I'll try...
12:04:58 <lyxia> GHC adding 0's to your type variables is a pretty good sign of ambiguity
12:05:37 <lyxia> it also says "in the ambiguity check for aggregateblablah"
12:09:29 <adamCS> lyxia:  That worked!  Thanks!  I understood what the ambiguity part meant but somehow thought is twas having trouble inferring the right type for an intermediate step.  My mistake.
12:10:54 <lyxia> To your defense interpreting the error message does require some experience :)
12:11:23 <tdammers> and in GHC's defense, we're working on that
12:11:39 <adamCS> lyxia, tdammers: :)
12:12:46 <adamCS> huh.  Now that function compiles but trying to use it with concrete types causes ghc to slowly grow large...
12:14:52 <adamCS> 12 GB and growing.  Maybe time to give up, though it was sort of pretty to have it be that general.
12:16:34 <shapr> glguy: yay! plz file any bugs or suggestions for ghcup, I suggested list and some other features that were quickly added
12:17:06 <cocreature> so emacs is eight megabytes and constantly swapping. how do we butcher "GHC" into an acronym that makes fun of its memory usage? :)
12:18:39 <Solonarv> Gigabytes something something
12:18:52 --- mode: glguy set +v Guest14993
12:18:56 <geekosaur> giant huffing core
12:19:00 <Guest14993> I'm trying to write a monadic parser
12:19:07 <shapr> Guest14993: how's that going?
12:19:17 <Guest14993> But I can't wrap my head around how it works :(
12:19:18 <Solonarv> Gigabytes h<something> consumed?
12:19:44 <Guest14993> I have a file and I want to make a datatype of it
12:19:52 <dmwit> giant heap consumer
12:20:02 <cocreature> dmwit: nice!
12:20:08 <Guest14993> But do I first have to parse it and then evaluate it to make my datatype?
12:20:17 <shapr> Guest14993: https://gist.github.com/shapr/f4c9f2a1d6d269f404277ae3bd89afdd ?
12:20:19 <Solonarv> dmwit: ooh that's a good one!
12:20:48 <dmwit> Guest14993: Let's get precise! What is the "it" in "parse it"? How about the "it" in "evaluate it"?
12:21:15 <Guest14993> So I have a file that describes a world in a game
12:21:32 <Guest14993> Now I have an instance that represents that world
12:21:50 <Guest14993> And I want to parse that file into a world type
12:23:22 <dmwit> I'm on board so far.
12:24:08 <Guest14993> So for example, one of the lines in the file is height: 2
12:24:14 <dmwit> Love it.
12:24:33 <Guest14993> But I have no clue how to parse it so I can make a World
12:25:58 <dmwit> Okay. Have you tried looking for any tutorials? If not, we can help you cook up some search terms.
12:26:17 <dmwit> It's probably not sensible to try to rewrite a parser combinator library tutorial in real time over IRC.
12:26:49 <Guest14993> Yeah no, that's totally not my intention, I really want to write it myself :D
12:27:46 <dmwit> Oh. So are you looking for a tutorial on writing your own parser combinator library?
12:27:47 <Guest14993> And I found some tutorials, but they all seem to be for parsing a custom programming language
12:27:57 <dmwit> That... seems a bit advanced, given that you haven't had experience even using one yet.
12:28:13 <Guest14993> All I want to do is make an object starting from a file :(
12:28:46 <dmwit> That... *is* a custom programming language.
12:28:53 <dmwit> The programs just don't have conditionals. =)
12:29:03 <dmwit> (Or maybe they even do!)
12:29:20 <Guest14993> Oooh
12:30:05 <Guest14993> That makes sense
12:30:49 <Guest14993> That actually makes a lot of sense, thanks dmwit!
12:30:49 <dmwit> I guess now it makes sense to make sure I understand the goals. Are your goals to make progress in developing your game, or to make progress in understanding how to use parser combinator libraries, or what?
12:32:09 <Guest14993> The goal is to understand how a monadic parser works
12:32:29 <dmwit> Okay, cool. Then I think you are spending your effort in the right place.
12:32:37 <dmwit> Let us know if you have more targeted questions that we can help with, for sure.
12:33:29 <Guest14993> Thanks dmwit!
12:33:58 <Levy[m]> A parser of things is a function of string to a list of thing and string. Once you have that type the type system will mostly guide you
12:34:51 <Levy[m]> Implement Functor, Applicative, and Monad (via join is easier)
12:34:53 <dmwit> That's a good description of the ReadS parser library. But there are other libraries out there that don't use that implementation strategy.
12:35:22 <Levy[m]> Yep but it's one of the simpler ones to start with
12:35:56 <Guest14993> Levy that I get, but I don't get how you make up more "complex" things
12:36:08 <Guest14993> So I got my type World 
12:36:25 <Guest14993> but that contains multiple types (for example Tile)
12:36:42 <Guest14993> Do I need to write multiple parser for each type?
12:37:10 <Guest14993> e.g. a parser for a digit, a parser for a tile...
12:37:14 <Guest14993> And then combine them?
12:37:19 <tdammers> yes, that's basically how you do it
12:37:29 <hyperisco> Guest14993, I can link you to my undergrad paper where I develop general CFG parser combinators
12:37:44 <Guest14993> That would be appreciated hyperisco :)
12:37:53 <hyperisco> Guest14993, at the time I was just learning Haskell so maybe it will be approachable to you. In fact that project is how I learned Haskell.
12:38:05 <tdammers> and part of the beauty of applicative and monadic parsers is that many of the combinators you need can be written in a completely generic fashion using only these typeclasses
12:38:29 <hyperisco> I don't go into monadic parsing because it is irrelevant for CFGs
12:38:36 <Levy[m]> once you learn how to build the primitives in this one most other parsers should become rather simple
12:38:51 <tdammers> for example, if you have a parser for integers (let's call it intP), and a newtype Foo = Foo Int, then you can use fmap over the parser to turn it into a parser of Foo
12:39:01 <Levy[m]> Oh and Alternative is nice
12:39:04 <tdammers> fooP = Foo <$> intP
12:39:10 <hyperisco> Guest14993, https://github.com/erisco/acrid-parser/blob/master/doc/paper.pdf
12:39:14 <tdammers> oh yes, alternative too
12:39:35 <Levy[m]> After monadic, arrow parsers are fun
12:39:46 <Guest14993> Thanks guys :)
12:41:06 <hyperisco> I take an approach that leans into Applicative parsing, so it starts as something simpler than that.
12:42:26 <tdammers> applicative before monadic makes sense
12:57:43 <vaibhavsagar> why does Haddock have strict version bounds for each version of base?
12:57:57 <vaibhavsagar> e.g. why can't I use Haddock 2.21 with GHC 8.4?
13:00:00 <geekosaur> becaue haddock relies on ghc internals to e.g. figure out type information
13:00:22 <geekosaur> it's not quite a custom ghc backend
13:01:33 <monochrom> You cannot build a mismatched version of haddock.  But once you have obtained an exe you can use it anywhere.
13:11:25 <pounce> How can I make it so one of my types can be printed?
13:12:23 <tdammers> ?
13:12:31 <tdammers> the type itself?
13:12:36 <tdammers> or values of that type?
13:14:14 <pounce> of values of the type.
13:15:45 <tdammers> make a Show instance
13:15:49 <tdammers> :t print
13:15:51 <lambdabot> Show a => a -> IO ()
13:15:59 <monochrom> You cannot do this within your program. But you can ask in the REPL (which is an over-seer).  :type True
13:16:04 <pounce> I may be doing things wrong, I've never declared new types in hs yet. I want to declare a type `Graph` which is pretty much a map from nodes (which are Ord) to a list of edges (which are a weight, node tuple). Right now I'm just doing it with type aliases but this seems bad :x 
13:16:08 <monochrom> Oh nevermind.
13:16:35 <tdammers> you can either manually write the Show instance, like so:
13:16:43 <tdammers> instance Show Graph where
13:16:50 <tdammers>     show g = ...
13:16:55 <monochrom> If you're using a type alias then nothing needs to be done.
13:17:09 <tdammers> ^ indeed
13:17:14 <pounce> hmm
13:17:16 <Solonarv> if you didn't actually declare any fresh types, you're at the "mercy" of whoever declared the types you're using
13:17:31 <monochrom> At this point we're speaking in vagarities.  Show actual code.
13:17:53 <monochrom> And if you have attempted something that fails, show details.
13:18:34 <pounce> will do :p https://ptpb.pw/iCHE/hs (feel free to get mad about how I make graphs too, I'm just trying it out XwX )
13:19:04 <pounce> this is what I currently have... but I think I should make it better by doing something like making `Node`s be anything Ord
13:19:19 <Solonarv> That's actually a pretty reasonable way to encode directed graphs, I think
13:19:26 <pounce> \o/
13:19:35 <monochrom> OK this type of graphs is already printable by default.  What have you tried such that you don't get printing?
13:20:59 <pounce> ..well currently I'm still working on getting ghc to see one. I'm asking more preemptively and trying to see if how I'm doing graphs is ok
13:22:57 --- mode: glguy set +v Boarders
13:23:12 --- mode: glguy set -v Boarders
13:23:41 <Boarders> I am trying to use the text-show package and replace some show instances with it, but our show instances make heavy use of lines
13:23:56 <Boarders> does anyone have any suggestion what to do in order to emulate the behaviour?
13:24:17 <glguy> if you have custom rendering logic in your show instances then you should probably just fix your show instances
13:24:35 <Boarders> glguy: what do you mean by that?
13:24:54 <pounce> oh, it looks like how I'm going list comprehensions wrong. This fails with `non exhaustive pattern` in the Maybe match. Is there some way I can work the list comprehension so that it only yields a value if the function returns Just x ?
13:24:57 <monochrom> Sorry, emulate what behaviour?
13:25:14 <Boarders> like if I wanted to do the same rendering that uses unlines but with TextShow
13:25:33 <monochrom> Does Text have unlines?
13:26:03 <Boarders> it has lines and unlines
13:26:08 <Boarders> also Builder has unlines but no lines
13:26:17 <Boarders> so convert to an intermediate text value?
13:26:19 <glguy> Boarders: Show instances aren't the place for custom formatting
13:26:22 <monochrom> Because lines would be an "unbuilder".
13:26:32 <Boarders> glguy: I know but it is not my call to make the change atm
13:26:42 <monochrom> Or in other words, lines is the wrong direction.
13:27:05 <Boarders> yeah it would be nice if there were a typeclass method that gives you back [Builder] for when you want to build up intermediate expressions
13:27:12 <Boarders> but that might be too much my specific use case
13:27:37 <glguy> If you have a different use case in mind and you're already switching classes it's probably worth making a new class
13:28:32 <monochrom> pounce: Do you have a decision on what to do if connected node other = Nothing?
13:28:41 <Boarders> the use case is rendering text to a file
13:28:57 <Boarders> I tried asking about it here but people just told me not to as though I had a say in the matter 0_o
13:29:16 <pounce> monochrom: yeah, I want it to not be in the list
13:30:27 <monochrom> > [ x | let Just x = Nothing ]
13:30:30 <lambdabot>  [*Exception: <interactive>:3:11-26: Irrefutable pattern failed for pattern J...
13:30:37 <monochrom> Oh, that's too bad.
13:31:16 <monochrom> OK try this, it's going to be a bit strange:  Just weight <- [connected node other]
13:31:35 <monochrom> Here is an example of the principle behind:
13:31:43 <monochrom> [ x | Just x <- [Nothing] ]
13:31:48 <monochrom> err
13:31:50 <monochrom> > [ x | Just x <- [Nothing] ]
13:31:52 <lambdabot>  []
13:32:10 <pounce> yeah, I was thinking about changing to that, but then I saw that `let` compiled and I thought it worked XwX. That makes sense though
13:32:13 <monochrom> Here is a less boring example:
13:32:31 <monochrom> > [ x | a <- [Just 1, Nothing], Just x <- [a] ]
13:32:33 <lambdabot>  [1]
13:32:46 <pounce> ooh
13:32:49 <shiona> > [ x | [x] <- [[],[1],[2,3],[4]]] -- hmm
13:32:52 <lambdabot>  [1,4]
13:33:11 <monochrom> Yeah "let" has a different semantics.
13:34:52 <pounce> ok, well the Graph ends up as displaying in a very ugly way, but it's good enough ^w^
13:38:34 <Solonarv> There's nothing stopping you from writing whatever function 'Graph -> String' you care to, if you want to display it differently
13:40:27 <pounce> good point haha
14:00:14 <pounce> Is there any way to display a raw string in ghci instead of the quoted and escaped string?
14:01:42 <Solonarv> % "some string"
14:01:42 <yahb> Solonarv: "some string"
14:01:49 <Solonarv> % putStrLn "some string"
14:01:49 <yahb> Solonarv: some string
14:02:01 <geekosaur> use putStr or putStrLn instead of print, show, or the default which is more or less print
14:03:40 <monochrom> My http://www.vex.net/~trebla/haskell/string-print-show-read.xhtml explains why you get quotes and escapes.
14:04:16 --- mode: glguy set +v gabe4k
14:06:20 <gabe4k> I'm using Data.Map.Strict with string right now heh
14:06:51 <c_wraith> that seems pretty pointless. :P
14:15:14 <Bish> the documentation states there are array operations that "modify" it without copying
14:15:23 <Bish> what does copying mean in a haskell context
14:16:17 <monochrom> Actually which operation is it?
14:18:01 <Bish> god, i can't find it
14:18:17 <Solonarv> you're probably thinking of take/drop/slice
14:18:25 <Bish> maybe
14:18:37 <Solonarv> "copying" means the same thing it means in any other language
14:19:02 <Bish> yeah but so far "copying" wasn't possible in my haskell understanding
14:19:07 <Bish> things can only be referenced
14:19:24 <monochrom> This is referring to under the hood.  You won't easily observe it.
14:19:26 <Bish> but not mdified
14:19:51 <c_wraith> Haskell is full of modification. you just don't see it, because of purity.
14:19:51 <cjay-> does anyone see an alternative for sequenceTill that I had to define myself right above that spot? https://github.com/cjay/adventOfCode2018/blob/adbad02cf01cd9e1ec48213d1b9adbc83ab807e8/src/Day13.hs#L133
14:20:04 <Solonarv> The difference is whether the new array refers to the *same* "back-end" data structure, or a fresh one
14:20:15 <c_wraith> by which I specifically mean laziness is modification. not anything magical.
14:20:36 <Solonarv> It won't change the answer you're getting, but it will change how amny CPU cycles and how much memory your program uses on the way
14:22:56 <c_wraith> cjay-, short circuiting operations like that usually are not something the Applicative/Traversable combinators give you.
14:24:55 <c_wraith> cjay-, you might be able to find a perfect combination of wrapper types that turn it into a foldMap or something, but that's probably the wrong way to try to factor it.
14:27:16 <cjay-> c_wraith: should I approach the problem differently? I know I could ask the parser lib for the source position, but documentation says it's slow, and doesn't solve the general problem
14:27:37 <c_wraith> I don't see anything wrong with what you're doing.
14:27:46 <cjay-> ok thanks
14:27:54 <c_wraith> at least at that level. I didn't look to see how it was being used. :)
14:28:12 <c_wraith> but the function you asked about is perfectly fine.
14:28:25 <Bish> Solonarv: thanks, that helped
14:32:51 <cjay-> c_wraith: should I propose sequenceTill as a candidate for inclusion in Control.Applicative.Combinators somewhere? :)
14:49:22 <c_wraith> cjay-, in its current form, it doesn't seem that general. it's mostly. just parsing where it makes sense. but if you came up with a generic story for short-circuiting that happened to express your use case, more people might be interested.
14:58:25 * hackage tasty-test-vector 0 - Test vector support for tasty.  http://hackage.haskell.org/package/tasty-test-vector-0 (davean)
14:59:55 * hackage supervisors 0.2.0.0 - Monitor groups of threads with non-hierarchical lifetimes.  http://hackage.haskell.org/package/supervisors-0.2.0.0 (isd)
15:02:48 --- mode: glguy set +v ayylmao
15:04:49 <__monty__> le sigh, how difficult can it be to get a ghc with squeal-postgresql 0.4?
15:05:56 <__monty__> * using nix, wrong channel, apologies.
15:54:45 <coldpress> > putStrLn "some string"
15:54:47 <lambdabot>  <IO ()>
15:55:09 <Solonarv> lambdabot is not a ghci session! :>
15:55:14 <coldpress> whoops
15:55:27 <Solonarv> % putStrLn "some string" -- but yahb is!
15:55:27 <yahb> Solonarv: some string
15:55:47 <hpc> > readFile "/etc/passwd"
15:55:48 <Solonarv> They also both work in PMs
15:55:49 <lambdabot>  <IO [Char]>
15:55:50 <hpc> er
15:55:55 <hpc> % readFile "/etc/passwd"
15:55:55 <yahb> hpc: *** Exception: /etc/passwd: openFile: does not exist (No such file or directory)
15:56:07 <coldpress> lol
15:56:16 <hpc> it's fun to play with yahb's sandbox in pm
15:56:36 <coldpress> % readFile "$USER/.bash_profile"
15:56:36 <yahb> coldpress: *** Exception: $USER/.bash_profile: openFile: does not exist (No such file or directory)
15:57:02 <hpc> in a pm :P
15:57:16 <coldpress> what does pm mean?
15:57:24 <Solonarv> private message
15:57:31 <novum> /query yahb
16:01:37 <novum> simply because it interests me, I'd like to improve my haskell skills. I attempted to last semester. I learned it half decently using just ghci stack and vim, but I felt a little lost. Of course, I used the main ghc website and used the online resources, but I still just feel a little lost (which is to be expected since haskell is my first function language). Does anyone have any tips or pointers? I know I
16:01:39 <novum> can't become a masser haskeller over night, but any bread crumb for a poor, hungry noob would be appreciated
16:03:25 <Solonarv> It's hard to just give general tips, did you have any specific isses?
16:04:11 <novum> I do not understand monads beyond that they (I think) allow for unsafe operations
16:04:59 <novum> I wouldn't know how to create a useful haskell program that allows for input
16:05:17 <novum> Eventually, I would like to use xmonad as my window manager
16:05:44 --- mode: glguy set +v Logio
16:05:45 <novum> (if I find haskell worth using to describe my window management needs and capabilities)
16:06:25 * hackage regex 1.0.1.5 - Toolkit for regex-base  http://hackage.haskell.org/package/regex-1.0.1.5 (ChrisDornan)
16:06:34 <Logio> novum: the IO type allows IO (i.e. unsafe) operations, it just happens to be a monad
16:07:12 <novum> yeah I mostly understand that. I haven't actually tried to haskell recently. I'll shut up until I run into an actual dilemma. sorry+thanks
16:07:22 <Solonarv> it also only allows them in a safe way, so saying "IO allows unsafe operations" is a bit misleading
16:08:03 <Solonarv> "IO allows you to interact with the outside world safely" is a better phrasing, IMO
16:08:33 <Logio> I wouldn't say that, IO encapsulates the unsafeness of the outside world
16:08:44 <novum> I understand, for I have researched it before. But my main issue is that I wouldn't recognize when to use a monad, and I am even a bit iffy on the syntax/construction. I understand vaguely what they are.
16:08:53 <Logio> type safety in general then guarantees that you are safe
16:09:25 * hackage proto-lens-protoc 0.4.0.2 - Protocol buffer compiler for the proto-lens library.  http://hackage.haskell.org/package/proto-lens-protoc-0.4.0.2 (JudahJacobson)
16:09:29 <Solonarv> Fortunately you rarely need to use "a monad"; instead you need to use some specific type, which happens to be a monad
16:10:02 <nshepperd> IO allows you to launch the missiles, ensuring that your enemies are at least as unsafe as you are.
16:10:05 <novum> ok here is my biggest angry-face about all of this: when I was learning haskell, everyone tried to relate it back to non-functional languages. This led me to not fully understand how everything works .. for example monads
16:11:00 <Logio> do you happen to have any advanced math background?
16:11:15 <novum> I like the maths
16:11:25 * hackage regex-with-pcre 1.0.1.5 - Toolkit for regex-base  http://hackage.haskell.org/package/regex-with-pcre-1.0.1.5 (ChrisDornan)
16:11:41 <novum> hit me with your best shot
16:11:55 * hackage regex-examples 1.0.1.5 - Tutorial, tests and example programs for regex  http://hackage.haskell.org/package/regex-examples-1.0.1.5 (ChrisDornan)
16:11:59 <Logio> if you are comfortable with abstract algebra it is probably best to try and get an understanding of haskell concepts through that rather than analogies to other languages 
16:13:12 <Logio> for the best shot, I can only tell you that monads are just monoids in the category of endofunctors
16:13:19 <novum> https://www.startpage.com/do/metasearch.pl?query=abstract%20algebra%20haskell
16:13:51 <Logio> which I actually find a very clear and succint explanation of them these days, but it takes quite a bit of ruminating for it to feel like that
16:14:41 <novum> I just want to be able to read and understand haskell ‚Ä¶ I can parse out the general idea, but the syntactic constructions are hard to understand
16:14:55 <novum> and write it
16:14:55 <Logio> for the layman explanation of monads, I would just say that it's a generalization of combining functions together in a certain way
16:14:57 <c_wraith> then ignore theory and just write some code.
16:15:19 <c_wraith> nothing replaces doing in the learning process.
16:15:52 <novum> I did ‚Ä¶ will just keep using the same tutorials I was using and whatever new ones I find I guess
16:15:52 <Logio> is there anything specific you feel you have trouble with?
16:16:07 <c_wraith> don't use tutorials. write code.
16:16:49 <jackdk> :t (>=>)
16:16:50 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:17:15 <novum> c_wraith, done: https://ptpb.pw/B7N0.png
16:17:24 <novum> ok. what now? this is easier than I thought!
16:17:30 <hpc> novum: technically that was typing code
16:17:33 <hpc> better get a pencil :D
16:17:38 <c_wraith> a tutorial is a guided path. it might show you a couple pretty sights, but you'll only ever see the superficial bits.
16:17:46 <jackdk> novum: if you've got a maths background it may help to know that (>=>) is equivalent in power to (>>=) and also to join
16:17:54 <c_wraith> to really learn something, you have to do it yourself.
16:18:14 <Solonarv> You might also find it enlightening to compare the types of ($), fmap, <*> and =<<
16:18:19 <novum> I understand, but I fear you underestimate my lack of haskellian understanding
16:18:47 <jackdk> but the laws for (>=>) come out pretty nicely: (>=>) is associative, and `pure` (historically also called `return`) is an identity
16:18:54 <jackdk> (for (>=>))
16:18:57 <Logio> novum: one tip I can give you is to spend time on figuring out the precedence rules
16:19:05 <novum> think of me as a 4 year old who jumped into a pool and clambered up the steps yet who now wants to learn how to swim
16:19:14 <novum> but I suppose you're right. I will keep coding
16:19:40 <MarcelineVQ> strongly agree with c_wraith. find something you'd like to make and make it, ask for help as you get stuck
16:19:42 <hpc> find some small programs you think are useful and write those in haskell
16:19:54 <hpc> that's how you get generally comfortable with a language
16:19:58 <novum> (* | novum doesn't know what to make)
16:20:00 <Solonarv> In this analogy, does the 4yo learn by having people explain to them how to move arms & legs, or by getting in the water and actually moving arms & legs?
16:20:02 <jackdk> I think c_wraith is on the money: it feels like there's a lot of implicit knowledge that just gets built up as you learn how the tools feel in your hands
16:20:13 <jackdk> +1 Solonarv
16:20:25 <novum> Solonarv, just asking *if* someone has a decent guide
16:20:53 <jackdk> although there is a point in swimming lessons where you refine technique and talk about specific arm movements, etc. I think this analogy still holds
16:21:02 <c_wraith> novum, maybe try to do some advent of code problems, if you are drawing a blank on what to do?
16:21:13 <MarcelineVQ> I'm partial to the haskell wikibook these days, as far as guides go
16:21:16 <novum> is that a website?
16:21:20 <c_wraith> yeah
16:21:26 <Solonarv> @where book
16:21:26 <lambdabot> http://haskellbook.com/
16:21:32 <Solonarv> ah, that's not the one
16:21:52 <MarcelineVQ> https://en.wikibooks.org/wiki/Haskell is the one I refernce
16:21:52 <novum> I'll find it. was looking for something like that ‚Ä¶ wanted to be able to practice c++, haskell, perl, and various other languages
16:23:37 <jackdk> Solonarv's remark about comparing the types of functor/applicative/monad functions is also very useful, because you start to get a feel for why certain things only become possible as you tighten your constraint from Functor -> Applicative -> Monad
16:23:46 <apoc> i think that haskellbook doesnt have the best reputation, there are better ones to learn haskell?
16:23:48 <novum> what is up with all of this advent stuff?
16:24:06 <novum> I just wrote an article for *ANOTHER* advent "calendear" ‚Ä¶ they are all the rage these days
16:24:22 <MarcelineVQ> They've been around for awhile, used to be chocolates
16:24:25 <hpc> it'll be over in...
16:24:32 <hpc> 12-ish days
16:24:36 <novum> ha. ha.
16:24:37 <Solonarv> Well, you know, biggest holiday in the western hemisphere and all that
16:24:52 <MarcelineVQ> hpc: not 7?
16:25:02 <hpc> oh right
16:25:14 <novum> yeah they only go 'til 25th
16:26:26 <c_wraith> novum, well, in any case, it's one repository of ideas for small projects - though they are sort of unusual tasks. usually you don't p
16:26:29 <c_wraith> err
16:26:44 <c_wraith> usually you don't have such precise problems to solve.
16:27:17 <Solonarv> They *are* a good way to learn, but you might end up learning more about data structures & algorithms than about the language you're using
16:27:20 <novum> looking for a website that has beg, interm, expert challenges for various languages. will find with a quick !sp search though
16:28:14 <novum> Solonarv, *you* are a data structure & an algorithm.
16:28:30 <novum> do you need some ice for that burn?
16:28:31 <Solonarv> Technically true.
16:28:46 <hpc> it's like the end of a story for children
16:28:47 <glguy> I think the AoC problems are great for learning about the language itself and structuring things with functional programming
16:28:55 <hpc> the hash table was inside you all along!
16:28:56 <Solonarv> Yeah but you are made of atoms! HAH!
16:29:03 <glguy> You just have to decide to put an emphasis on your program structure and not just stop when you get an answer
16:29:14 <novum> Solonarv, how do you know? I might be pure energy.
16:29:35 <hpc> mass is just energy waiting to happen
16:29:48 <Solonarv> <something something E=mc¬≤>
16:29:51 <novum> but energy is not necessarily an atom.
16:30:46 <novum> but thanks. I'm going to be having so much fun learning. ^u^
16:31:00 <novum> see you all around (or whatever) o/<3
16:31:15 <Solonarv> I mean if you are somehow not made of atoms I would suggest grabbing the nearest physicist and biologist and telling them you've got some Nobel prizes waiting for them :>
16:45:55 * hackage antiope-athena 6.2.0 -   http://hackage.haskell.org/package/antiope-athena-6.2.0 (alexeyraga)
16:47:25 * hackage antiope-core 6.2.0 -   http://hackage.haskell.org/package/antiope-core-6.2.0 (alexeyraga)
16:48:55 * hackage antiope-contract 6.2.0 -   http://hackage.haskell.org/package/antiope-contract-6.2.0 (alexeyraga)
16:50:41 * hackage antiope-sqs 6.2.0, antiope-sns 6.2.0, antiope-s3 6.2.0, antiope-messages 6.2.0, antiope-dynamodb 6.2.0 (alexeyraga)
16:53:25 * hackage barbies 1.1.0.0 - Classes for working with types that can change clothes.  http://hackage.haskell.org/package/barbies-1.1.0.0 (DanielGorin)
17:05:20 <isd> Hey all. Is there a way to query whether the allocation limit is currently enabled? I don't see this as part of the API: https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Conc.html#g:3
17:05:35 <isd> I guess you could just temporarily set it to -1 and see if it throws, but if there's a cleaner way that would probably be preferable.
17:07:29 <koz_> Has someone made a wiki powered by Haskell?
17:21:24 <isd> Also, does anyone know how sparks interact with the allocation limit? are they treated as part of the thread they're created in, or their own threads or...?
17:22:52 <buhman> koz_: is https://jaspervdj.be/hakyll/ not good enough for you?
17:23:09 <buhman> or http://hackage.haskell.org/package/slick
17:23:13 <buhman> or any of the others
17:23:59 <koz_> buhman: I didn't say they weren't - just wanted to know what's out there.
17:24:43 <enedil> Hello
17:24:50 <koz_> enedil: Hola.
17:25:54 <enedil> Could you help with this:
17:25:55 <enedil> https://gist.github.com/enedil/8aa4dc77891b31c5fe987242c52dd92d
17:26:10 <enedil> That's what I got after `cabal install pandoc-include`
17:32:34 <geekosaur> template-haskell should have come with ghc. how did you install it?
17:37:13 <enedil> geekosaur, via dnf (Fedora's package manager)
17:41:55 <enedil> geekosaur, dnf says template-haskell is already installed, somehow cabal doesn't see it
17:42:15 <geekosaur> is there a devel package for it?
17:42:22 * geekosaur istrying tof nd package information
17:43:20 <enedil> geekosaur, yes, there is, I'm installing it right now
17:49:12 <isd> enedil: what version does dnf say you have?
17:49:18 <isd> Ah, the devel package is probably necesary.
17:50:51 <enedil> isd, 2.12.0.0, but this probably doesn't matter as I got devel package and now cabal doesn't complain, I waiting for compilation of pandoc-include to finish 
17:51:05 <enedil> It has hell lots of dependencies
17:51:11 <geekosaur> yep
17:54:39 <pounce1> So I have a function which returns a Maybe. How can I return one thing if it is `Nothing` and another if it's `Just x`? This is at the very beginning of my function, so I'd like to use something clean like pattern matching, but I can't figure out how. (I know I can use `maybe` but this seems messy)
17:55:05 <geekosaur> foo Nothing = ...; foo (Just x) = ...
17:55:23 <geekosaur> if it's not a parameter, you want to use case for pattern matching
18:02:47 <amalloy> pounce1: `maybe` is often less messy, depending on how long the cases are. but indeed if you're calling this function and would like to use pattern matching, you can write something like: foo x y = case bar x of ...
18:04:13 <enedil> Now I have such error:
18:04:14 <enedil> https://gist.github.com/b00d6126279cab500602c86d71712e9b
18:04:48 <enedil> It looks like an error in code
18:06:57 <pounce1> yeah, I think I'm going to use case
18:08:10 <pounce> I'm mad because I just realized I have to carry another value through all my functions >:(
18:08:25 * hackage hakyll-images 0.1.0 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.1.0 (LaurentRDC)
18:20:37 --- mode: glguy set +v saad404
18:45:25 * hackage hosc 0.17 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.17 (RohanDrape)
18:46:06 <dmwit> pounce: You might like to google "incremental ad-hoc parameter abstraction".
18:46:25 * hackage hsc3 0.17 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.17 (RohanDrape)
18:49:29 <pounce> this is cool ^^ The new parameter needs to be part of the algorithm I think though. I'm just having a little trouble translating this imperative algorithm to a recursive functional one
19:02:25 <pounce> `(const ((), Just (new_dist, ())))` oh my is this lisp
19:03:03 <geekosaur> suture syndrome
19:32:25 * hackage hw-ip 2.0.0.0 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-2.0.0.0 (arbornetworks)
19:32:49 <pounce> aaah compiled!
19:37:55 * hackage yx 0.0.1.0 - Row-major coordinates  http://hackage.haskell.org/package/yx-0.0.1.0 (mtth)
19:42:18 <mud> pounce: What algorithm, out of curiosity?
19:43:07 * hackage more-containers 0.1.2.0 - A few more collections  http://hackage.haskell.org/package/more-containers-0.1.2.0 (mtth)
19:43:38 <pounce> mud: dijkstra's
19:47:19 <mud> Ahh, cool
19:48:12 <pounce> it will be if I can ever get it to work XwX
19:51:15 --- mode: glguy set +v Ulbrec
19:53:55 * hackage tidal 1.0.3 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.3 (AlexMcLean)
19:55:34 <nfd9001> oooookay i'm in dependency hell and i need some help. Nuked all of the installed packages in ~/.ghc and ~/.cabal, I believe. Try to install Stack and it fails the same place everything was failing last time (missing file in data-default-class)
19:55:48 <nfd9001> I'm running Arch and trying to not get stuck in the Arch dephell again
19:56:11 <glguy> .ghc and .cabal shouldn't have anything to do with stack
19:56:13 <nfd9001> very very close to just installing a nixos stratum because i'm running Bedrock and starting over
19:56:27 <nfd9001> glguy: stack isn't installed. i'm trying to install it with cabal
19:57:55 <glguy> nfd9001: I don't know. The best think to do is make a big transcript of the commands you ran and the output you got and  share that via a pastebin to see if anyone recognizes the problem
19:58:41 <MarcelineVQ> I wouldn't bother with that if you want stack on arch, just grab a linuix x64 bin and stick it in ~/.local/bin https://github.com/commercialhaskell/stack/releases
19:59:04 <outoftheloop> nfd9001: I highly recommend using stack-static from the AUR and avoid Haskell packages from the community repos
19:59:24 <nfd9001> this really sounds like a good idea
19:59:25 <outoftheloop> You will be bombared with updates loads of them on a daily basis
19:59:36 <MarcelineVQ> that's another good option, I use a bin because I upgrade from git so a package didn't make sense for me
19:59:48 <MarcelineVQ> that it to say, stack upgrade --git
19:59:54 <outoftheloop> I have since installed static stack and install all dependencies via stack
20:00:00 <nfd9001> i'm okay with getting tons of stuff from Pacman, honestly, doesn't really matter that much to me
20:00:18 <outoftheloop> you have many options haha
20:00:18 <nfd9001> but it doesn't change that the setup I've got is badly busted no matter how you look at it
20:00:26 <nfd9001> TOO many options imo
20:00:40 <outoftheloop> yes that is why i think using static bin is better
20:01:05 <nfd9001> ideally i want my system package manager to handle as much of my package management as possible
20:01:12 <outoftheloop> it will eliminate both the multiple updates and dependency hell you are facing, hopefully...
20:01:17 <nfd9001> but this is sort of a labyrinthine hellscape
20:01:17 <glguy> It easiest way to solve the problem of installing stack is not to install it, of course
20:01:25 <outoftheloop> Another option is nix :)
20:01:36 <nfd9001> yeah, heavily considering nix just for kicks
20:01:37 <outoftheloop> still new to Haskell so havent touch that
20:01:51 <nfd9001> considering installing nixos
20:01:53 <outoftheloop> definitely something to look at
20:01:58 <maerwald> nfd9001: don't
20:02:05 <nfd9001> i'm running a meta-distro, might as well look at it for funsies
20:02:16 <MarcelineVQ> "<nfd9001> ideally i want my system package manager to handle as much of my package management as possible" the purpose of stack is that it manages packages/dependencies itself so that ideal is a bit at odds
20:02:56 <nfd9001> MarcelineVQ: well, if i'm using a bunch of Hackage packages off AUR, i'm at the AUR maintainers' mercy
20:03:05 <nfd9001> just as soon go right to hackage/stackage
20:03:19 <nfd9001> on the other hand, merely installing Haskell with my package manager sounds sane
20:04:21 <maerwald> Depends on how it was packaged, as for arch linux, the answer is "not very well"
20:04:30 <nfd9001> mhmm
20:05:27 * hackage yx 0.0.1.1 - Row-major coordinates  http://hackage.haskell.org/package/yx-0.0.1.1 (mtth)
20:05:50 <nfd9001> well, the hell starts with ghc losing all of its static libraries by default
20:05:56 <geekosaur> I think you'll find virtually every language community other than C/C++ will tell you not to use the package manager unless it's casual
20:05:59 <nfd9001> and then it gets more confusing
20:06:04 <geekosaur> you're on arch
20:06:11 <geekosaur> using the package manager is not sane
20:06:21 <nfd9001> point taken
20:06:27 <nfd9001> if you're writing for glibc, awesome
20:06:33 <nfd9001> else, uhh
20:06:51 <geekosaur> really, they managed to screw things up really badly. it's fine for their packagingneeds, a nightmare for everyone else
20:06:52 <maerwald> geekosaur: for rust it works... ish, except you don't really have a notion of "libraries" anymore
20:07:10 <nfd9001> and then you have Python, which is Python
20:07:18 <maerwald> python packaging works fine
20:07:29 <outoftheloop> rustup, pyenv rbenv are awesome
20:07:52 <outoftheloop> rustup is in the repos but the other two in AUR
20:07:54 <maerwald> outoftheloop: you missed ghcup there :P
20:08:07 <outoftheloop> no idea about that!
20:08:16 <outoftheloop> is it the haskell equivalent?
20:08:23 <outoftheloop> still a beginner so apologies
20:09:17 --- mode: glguy set +v cfraz89_
20:09:21 <outoftheloop> i am confused
20:09:36 <outoftheloop> i thought the equivalent is stack am I wrong?
20:09:56 <cfraz89_> stack does a lot of things
20:10:17 <cfraz89_> build system that also transparently downloads the ghc version the project needs
20:10:18 <outoftheloop> so is ghcup and stack the same in terms of functionality?
20:10:22 <outoftheloop> I see
20:10:33 <outoftheloop> so stack can do everything ghcup can do
20:10:38 <maerwald> outoftheloop: yes, ghcup was inspired by rustup
20:10:42 <outoftheloop> is there a point to ghcup then?
20:10:59 <maerwald> stack does a lot of things and forces you into its design decisions
20:11:00 <outoftheloop> i love rustup but shouldnt we stick to stack?
20:11:02 <maerwald> ghcup just installs GHC
20:11:10 <outoftheloop> interesting
20:11:18 <geekosaur> if your opiniois that stack is the be-all and end-all, sure
20:11:36 <outoftheloop> is not. i am just a beginner so i cannot form an opinon just yet
20:11:45 <geekosaur> buytu you think "we" should stick to stack?
20:12:00 <outoftheloop> is interesting that there is no de facto framework for haskell
20:12:09 <maerwald> I'm wondering if there is an equivalent to stack in other languages
20:12:10 <outoftheloop> stack, ghcup, nix
20:12:21 <puffnfresh> I use Nix, it's awesome, but not easy to start with
20:12:22 <cfraz89_> meh you could say the same for java
20:12:27 <cfraz89_> gradle, mavent, ant
20:12:44 <outoftheloop> java is bad though /s
20:12:53 <outoftheloop> haha please dont hate me
20:13:02 <outoftheloop> what do you guys recommend to use for a beginner
20:13:07 <maerwald> GHC
20:13:10 <outoftheloop> what should i be learning?
20:13:11 <puffnfresh> Scala has sbt, cbt, mill, maven, gradle, ant, bazel, pants...
20:13:14 <outoftheloop> i guess all?
20:13:18 <Axman6> puffnfresh is one of the rare unicorns who's managed to successfully use nix 
20:13:26 <outoftheloop> haha
20:13:28 * Axman6 removes tongue from cheek
20:13:31 <puffnfresh> <3 Nix
20:13:40 <outoftheloop> nix it is then
20:13:44 <puffnfresh> there's a whole team inside of Axman6's company that use NixOS for everything
20:13:48 <outoftheloop> uninstalling stack now
20:13:50 <cfraz89_> lol don't start with nix
20:13:53 <outoftheloop> haha
20:14:05 <puffnfresh> I say don't start with Nix, nor Stack, nor Cabal
20:14:11 <outoftheloop> ah yes
20:14:14 <outoftheloop> there is cabal as well
20:14:20 <puffnfresh> start with GHC
20:14:26 <outoftheloop> so ghcup then?
20:14:30 <outoftheloop> sounds good
20:14:41 <Axman6> puffnfresh: I hear they've nearly finished compiling their systems, just a month left to go!
20:14:42 <maerwald> Yeah, please learn an entire package management system with its own configuration language, 50 hours of tutorials and reading through tons of issue tracker comments and blog posts... just so that you can install GHC, haha
20:15:02 <maerwald> aka nix
20:15:05 <outoftheloop> appreciate the feedback, i will stick to ghcup for now
20:15:18 <nfd9001> maerwald: sounds like lovely fun
20:15:24 <cfraz89_> yeah imo ghcup -> install ghc -> compile files straight
20:15:29 <nfd9001> not if you just want one build setup working, but in general
20:15:30 <outoftheloop> i am still using the terminal going through the haskellbook by the time i finish we may have nix 2,0
20:15:31 <Axman6> I've been using Haskell for a decade and never heard of ghcup, just my two cents
20:15:32 <puffnfresh> I agree cfraz89_
20:15:46 <glguy> Axman6: It's new, and pretty slick
20:15:56 <outoftheloop> i like new shiny things
20:16:18 <outoftheloop> ghcup looks interesting a the simplest of all
20:16:19 <maerwald> Main challenges are portability of GHC bindists and distro detection, so that can still be a bit flaky
20:16:37 <puffnfresh> outoftheloop: ummm Nix 2.1 was released recentlyf :)
20:16:39 <maerwald> But stack also has these, to some degree
20:16:54 <cfraz89_> @maerwald wrote it so if you have problems bug him
20:16:54 <lambdabot> Unknown command, try @list
20:16:58 <outoftheloop> puffnfresh: damn haha
20:17:20 <outoftheloop> so one moment please
20:17:27 <outoftheloop> can ghc install libraries?
20:17:33 <cfraz89_> maerwald wrote it so if you have problems bug him
20:17:46 <outoftheloop> without cabal or stack?
20:18:19 <maerwald> outoftheloop: not really
20:18:25 <maerwald> that's like asking gcc to install for you
20:18:43 <cfraz89_> not really, once you're comfy enough to start pulling in libs maybe graduate to cabal or stack
20:18:51 <outoftheloop> i see
20:18:51 <cfraz89_> ghcup can also install cabal for you so there's that
20:18:53 <srk> or nix!
20:19:01 <maerwald> ghci is your friend until then (interactive console)
20:19:11 <outoftheloop> so we do need one of the options cabal nix or stack
20:19:40 <outoftheloop> i mean if we end up using a library and need stack we might as well use stack for ghc installation...
20:19:40 <maerwald> Wait, there are even more options, someone recommended guix for haskell a few weeks ago xD
20:19:51 <srk> with nix you still (can) use cabal
20:20:17 <outoftheloop> ok cabal vs stack enlighten me
20:20:24 <cfraz89_> depends how you're going about learning i guess
20:20:33 <outoftheloop> i thought everyone is shifting to stack...
20:20:35 <srk> cabal new-* commands covers most of what stack does 
20:20:39 <maerwald> cabal vs stack... 
20:20:43 <puffnfresh> outoftheloop: I'm not
20:20:45 <puffnfresh> never will
20:20:48 <glguy> outoftheloop: stack got popular before we had the new-build stuff
20:20:50 <outoftheloop> i am confused
20:20:50 <Axman6> stack uses cabal, but handles libraries and versioning (philosophically) differently
20:20:52 <outoftheloop> haha
20:21:15 <srk> I'm shifting from stack to cabal & nix :)
20:21:15 <outoftheloop> cabal can do everything stack can and vice versa?
20:21:29 <maerwald> Not exactly
20:21:30 <MarcelineVQ> mostly, cabal doesn't install ghc for you though.
20:21:38 <Solonarv> Not exactly, but reasonably close
20:21:39 <maerwald> But there is a common feature... globally cached libraries
20:21:40 <cfraz89_> ghcup + cabal will get you to a similar place as stack
20:22:02 <outoftheloop> ghcup + cabal will get you to a similar place as stack --> that sounds good to me
20:22:18 <outoftheloop> is it better for a beginner such as myself compared to raw stack?
20:22:28 <maerwald> Previously people were using cabal sandboxes, where you re-install every library for a single project without sharing. Stack first implemented "safe" sharing between projects, cabal implemented it later
20:22:39 <puffnfresh> just start with GHC, come back to this problem when you need to solve it
20:22:55 <outoftheloop> puffnfresh: ok thank you
20:23:02 <Solonarv> (meaning: when you need a third-party library)
20:23:39 <puffnfresh> my team is learning Haskell, they've never used Cabal nor Stack
20:24:05 <glguy> That way they can't escape once they've learned their stuff :)
20:24:16 <outoftheloop> your team at work i guess? or something else?
20:25:26 <cfraz89_> outoftheloop just checking you're on a *nix right?
20:26:17 <outoftheloop> i am jealous, i would love to join a team for some haskell learning and work...
20:26:36 <outoftheloop> yeap, Nix OS
20:26:58 <outoftheloop> joking, Arch Linux haha
20:27:05 <cfraz89_> lol ok
20:27:24 <novum> emacs is the best os woot
20:29:04 <outoftheloop> this is the light hearted topics i am here to discuss , vim vs emacs cabal vs stack etc
20:29:21 <Arahael> outoftheloop: Don't be evil.
20:29:59 <maerwald> real men use nano
20:30:01 <outoftheloop> haha
20:30:26 <outoftheloop> ed...
20:30:42 <MarcelineVQ> I use nano ;__; over vi anyway
20:30:55 <puffnfresh> outoftheloop: yes, my team at work, Atlassian
20:31:00 <puffnfresh> outoftheloop: wanna move to Bengaluru India??
20:31:02 <puffnfresh> we're hiring :)
20:31:03 <julianleviston> puffnfresh: zomg hi :)
20:31:10 <MarcelineVQ> There's not a lot of vs here, in the grand scheme of things at least, mostly people just want things to work out for othersd
20:31:18 <Arahael> puffnfresh: Is that where you guys moved to? India?
20:31:22 <outoftheloop> puffnfresh: oh hello there
20:31:31 <julianleviston> puffnfresh: I‚Äôm in tassie at the moment hehe :)
20:31:41 <cfraz89_> Yessss fellow Aussie
20:31:47 <puffnfresh> julianleviston: lol enjoy!!!
20:32:03 <julianleviston> puffnfresh: I saw you‚Äôd moved to india :)
20:32:04 <puffnfresh> I live in Tassie, except I live in Bengaluru for 6 months :)
20:32:17 <julianleviston> puffnfresh: visiting fam.
20:32:21 <outoftheloop> puffnfresh: i would love to but a. i am from you and cannot relocate b. i am a haskell beginner but experienced with many other languages and tech haha
20:32:31 <outoftheloop> *far from
20:33:00 <puffnfresh> outoftheloop: that's fine, we've hired 7 people with 0 Haskell experience
20:33:05 <outoftheloop> definitely will be looking into contributing to some foss projects in the future though
20:33:21 <outoftheloop> puffnfresh: for haskell work? man that is soo cool
20:33:43 <Levy[m]> sounds nice
20:33:51 <outoftheloop> 10 years of experience in haskell, visited moon at least once is the type of adverts i see
20:33:52 <maerwald> sounds weird
20:34:11 <maerwald> Yes, if you haven't been to the moon you shouldn't be doing haskell xD
20:34:18 <outoftheloop> haha
20:34:30 <outoftheloop> no wonder haskell is not commonly used in production
20:34:35 <geekosaur> HR's kinda infamous for that, though
20:34:42 <puffnfresh> outoftheloop: we have integration tooling (between Jira, Bitbucket, Slack, etc.) written in Haskell, and 1 small production service
20:34:47 <MarcelineVQ> well, of course it isn't, everyone's a lunatic
20:34:50 <puffnfresh> then we have 100k lines of purely functional Scala
20:34:52 <geekosaur> the running joke is the instant a new technologyshwos up HR will be looking for mnimum 10 years experience
20:34:55 <outoftheloop> that is why i am learning to incorporate it into our solutions and make hell for other developers who wont be able to read it
20:35:13 <maerwald> puffnfresh: Scala is not purely functional :)
20:35:22 <Levy[m]> lures you in with haskell to throw scala at you
20:35:39 <puffnfresh> maerwald: it CAN be used to do pure FP, just with a HUGE amount of effort
20:35:41 <outoftheloop> puffnfresh: sounds very intersting indeed, hope all is going well with the business!
20:35:47 <puffnfresh> we have done it, by investing that huge effort
20:35:56 <outoftheloop> still better than doinf python ruby c++ all day
20:36:00 <maerwald> puffnfresh: "purely functional" is a property of the language and its evaluation, not a result of how you program :P
20:36:22 <outoftheloop> i mean Rust is awesome but no one will switch their C or C++ code to Rust
20:36:25 <Levy[m]> outoftheloop: Python isn't really that bad... if you follow fantasyland which nobody does
20:36:30 <puffnfresh> maerwald: no, disagree
20:36:39 <puffnfresh> purely functional is a property of expressions
20:36:46 <outoftheloop> python is not bad but is not as intersting 
20:36:54 <outoftheloop> no language is bad
20:37:04 <Levy[m]> em
20:37:15 <outoftheloop> is just that everyones tastes are different
20:37:19 <maerwald> puffnfresh: https://pdfs.semanticscholar.org/32ff/28cb5b5c990fe7bdca510040ea22f5c13316.pdf
20:37:25 <julianleviston> hehe :)
20:37:26 <outoftheloop> using the right tool for the job i guess
20:37:41 --- mode: glguy set +v Ulbrec
20:37:46 <maerwald> puffnfresh: Oh well, if you say it that way
20:37:47 <Levy[m]> Ah, but there isn't really a "right tool for the job" from the start
20:37:48 <Levy[m]> there never is
20:37:55 * hackage yx 0.0.2.0 - Row-major coordinates  http://hackage.haskell.org/package/yx-0.0.2.0 (mtth)
20:38:12 <outoftheloop> another of my favourite topics popped up is  insert language purely functional or can it do functional programming
20:38:17 <julianleviston> puffnfresh: no remote?
20:38:25 <julianleviston> puffnfresh: I thought you did only remote
20:38:27 <puffnfresh> julianleviston: no remote, trying to build a team here in Bengaluru
20:38:27 <maerwald> puffnfresh: and how do you know your code is purely functional when the language doesnt enforce it? :)
20:38:42 <puffnfresh> julianleviston: yeah usually, but we're building a functional programming team, so I'm here for a while :)
20:38:47 <puffnfresh> will go remote again
20:38:52 <outoftheloop> maerwald: you hope so
20:39:01 <maerwald> puffnfresh: you could as well say "my C code is memory safe" and it might be, because you were careful, but then it might blow up when you run it
20:39:03 <puffnfresh> maerwald: LOOKING VERY CAREFULLY
20:39:06 <outoftheloop> that is why i decided to learn haskell i like the stictness of it
20:39:10 <puffnfresh> maerwald: yes, this happens
20:39:11 <Levy[m]> outoftheloop: well I can asure you that pure functional programming in py works slowly
20:39:20 <puffnfresh> then we say "whoops, Scala" and fix it
20:39:30 <maerwald> puffnfresh: and as such, it's very vague to talk about "purely functional" in a language that is fundamentally impure
20:39:32 <outoftheloop> Levy[m]: i can imagine
20:39:40 <puffnfresh> maerwald: I don't think it's vague
20:39:44 <Levy[m]> it's "better" with the tuple goodness AFRP brings
20:40:00 <outoftheloop> Levy[m]: if there is no right tool for the job how do you decide what to use for a project?
20:40:03 <maerwald> puffnfresh: let's put it this way: I would never believe someone saying "my C program is memory safe" or "my Java code is pure" :)
20:40:03 <Levy[m]> (it slows down to a crawl)
20:40:21 <puffnfresh> maerwald: I have written purely functional Java code
20:40:27 <puffnfresh> feel free to not believe me, but I have
20:40:27 <maerwald> I don't believe you!
20:40:28 <outoftheloop> i mean right tool - more like suitable i guess
20:40:29 <maerwald> haha
20:40:39 <puffnfresh> you have too btw
20:40:40 <Levy[m]> outoftheloop: You pick the language which you're comfortable with and that has better tools for the domain. Then you make  it the tool for the job
20:40:49 <puffnfresh> I wrote 1 + 2 in Java one day
20:40:59 <puffnfresh> you are welcome to not believe that maerwald
20:41:02 <outoftheloop> pffft i have written non pure functional code inhaskell
20:41:15 <Levy[m]> sin
20:41:19 <maerwald> puffnfresh: I know what you mean, but you never really know when you wrote pure or impure code, nor can you properly reason about it
20:41:26 <outoftheloop> Levy[m]: yes i guess it comes down to the guy who starts the project 
20:41:31 <maerwald> Except for small expressions
20:41:41 <puffnfresh> maerwald: you can reason about it, Fast and Loosely
20:41:53 <z0> 3
20:41:58 <maerwald> Then there is no point in haskell if reasoning about purity is so easy in impure languages
20:42:21 <puffnfresh> maerwald: I do not claim easy
20:42:28 <puffnfresh> I claim VERY HARD
20:42:40 <Levy[m]> maerwald: could always restrict to a pure subset and have a linter scream at them
20:42:41 <maerwald> And error prone
20:42:55 <puffnfresh> maerwald: yes
20:43:03 <puffnfresh> the alternative is Haskell, I agree, do that
20:43:36 <z0> > (x:[]) == [x]
20:43:38 <lambdabot>  True
20:43:51 <Levy[m]> if only Blodwen were a few more years into development... no more exceptions (well.. most are gone)
20:55:52 <nfd9001> mmmmmmmkay
20:56:26 <nfd9001> just nuked every haskell package on my machine from orbit and i'm doing stack-static, thanks outoftheloop 
20:56:48 <outoftheloop> nfd9001: glad to be of assistance
20:56:56 <outoftheloop> hope it works out for you
20:57:22 <monochrom> Does "stack-static" mean you're on archlinux and you need to explicitly request statically linked tools?
20:57:58 <koz_> monochrom: Yes, as Arch dynalinks by default.
20:58:00 <koz_> It's a nuisance.
20:58:33 <outoftheloop> yeap
21:07:10 <nfd9001> monochrom: all of the official packages ship without static linking tools by default
21:07:29 <nfd9001> if you just install ghc and try to build something, it will usually just fail and say the static libraries are missing
21:07:54 <nfd9001> so you have to remember to tell it you want the dynamic ones, or set up some special configs
21:08:55 <nfd9001> very confusing for new users
21:31:11 <pounce> Is there a way to split a string on an character? Like if I have "1,2,3" I want to get [1,2,3]
21:32:13 <xacktm> splitOn shoudl do it
21:32:19 <xacktm> from `split` package
21:37:03 <cocreature> there is also wordsBy depending on what semantics you want for successive commas
21:37:22 <geekosaur> also that does only half of it
21:37:38 <geekosaur> you will get ["1","2","3"]
21:37:42 <cocreature> good point
21:38:49 <pounce> yeah, just need to map read
21:39:09 <julianleviston> haha safety alert ;)
21:39:33 <pounce> in other words... Dijkstra's seems to be working!
21:40:16 <kadoban> pounce: What'd you use for a heap?
21:40:47 <pounce> I ended up using Data.OrdPSQ from psqueues
21:40:59 <kadoban> Ahh
21:49:33 <Big_G> Lol. Why am I not surprised to see you here kadoban
21:50:43 <kadoban> I am all places
21:50:55 <MarcelineVQ> can confirm
21:51:09 <pounce> kadoban: yeah, using the psqueues one is sort of a pain but it works fine
21:52:03 <MarcelineVQ> "<julianleviston> haha safety alert ;)" traverse readMay ? :>
21:52:35 <kadoban> Ya, best I could think up was IntSet or something from the standard library, but it's probably not a great heap
21:52:41 <monochrom> Priority search queue is exactly right because you need both "I want to lookup by name so I can bump down its priority" and "OK now who has the lowest priority?"
21:52:54 <kadoban> And IIRC in djikstra's you actually want a heap of pairs too, so that'd not be great
21:54:19 <kadoban> Oh. I usually just use the little trick of inserting the cost and the node name and ignoring pops that have already been processed. That's probably more of a competitive programming trick than anything someone would use in real code though
21:55:42 <monochrom> I have seen competitive competitors just dump everything into an array with no particular order/reorder and just do linear search every time.
21:56:31 <monochrom> And sometimes I am lazy too so I do that in my official solutions to my Dijkstra or Prim assignments but the sad thing is that's still twice as fast as most student code.
21:57:56 <kadoban> Haha, for small N I guess that'd work
22:01:26 <cocreature> for large N you just crash so that you can claim that once you fix the minor bug you would also outperform other people‚Äôs solution for large N
22:18:29 <pounce> oof took 8min to solve the project euler problem
22:30:13 <dminuoso> monochrom, cocreature: Okay so I realized the mistake yesterday. My could have been `Pool (Ldap ())` just fine, since I have no need to have any quantification. As long as I have some `with :: (forall s. Ldap s -> IO a) -> IO a` that does the job I want just fine.
22:31:02 <dminuoso> Okay, writing stuff immediately after waking up before changing seems to increase the amount of typing errors..
22:43:04 --- mode: glguy set -v cfraz89
23:28:01 * hackage extensible 0.5 - Extensible, efficient, optics-friendly data types and effects  http://hackage.haskell.org/package/extensible-0.5 (FumiakiKinoshita)
23:36:53 <trcc> Haha had an issue when testing my library implemented with Haskell using FFI. My test was in a separate application written in C, that loaded and invoked functions on the haskell library. Guess where the error was? :D
23:37:06 <trcc> After half an hour of traces ^^
23:40:29 <bahamas> hello. I'm running `cabal update` or new-update and I get "truncated tar archive". what do I need to delete to fix this?
23:47:50 <shiona> trcc: UB in C code?
23:54:06 <dminuoso> bahamas: Can you gist the full output when you try to run `new-update`?
23:54:17 <trcc> shiona: hehe ye
23:55:08 <bahamas> dminuoso: it's broken for all cabal commands. even just running `cabal new-install hlint` gives me the same error
23:55:28 <bahamas> cabal new-install hlint
23:55:28 <bahamas> truncated tar archive
23:55:43 <cocreature> find ~/.cabal -name '*tar*'
23:55:48 <cocreature> should at least give you a hint :)
23:57:05 <bahamas> yeah. I nuked the packages dir
23:57:18 <bahamas> this sounds like a bug to me, no?
23:57:38 <bahamas> it occurred after I interrupted a cabal update with Ctrl-C
23:58:04 <cocreature> yeah I would search the issue tracker and open a new one if it doesn‚Äôt already exist.
23:58:11 <cocreature> seems like something cabal should be able to recover from
