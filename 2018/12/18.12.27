00:05:47 --- mode: glguy set -v t[m]
01:00:07 <Arahael> I've a large data structure - an AST, actually.  I want to be able to iterate over all nodes of a particular type, what's the best, most generic way to allow me to do this?
01:00:31 <koz_> You can just use pattern matching and recursion?
01:00:40 <koz_> I assume the AST is some kind of recursive type.
01:01:44 <Arahael> It's indeed some kind of recursive type.  I could just use pattern matching and recusion, however, I gave each node in the AST it's own type.
01:02:00 <Arahael> So doing this for type A is going to be tedious as I'll have to do it again for type B.
01:03:17 <Arahael> I wrote typeclasses that allow me to 'print' this (like Show, but with a custom syntax) - this took ~400 lines, so I'm hoping to avoid such duplication.
01:04:16 <AfC> iqubic: you might want to look at library prettyprinter and it's sibling prettyprinter-ansi-terminal modern update on -wl-
01:07:21 <Arahael> koz_: I was thinking I could define lenses, and then use those to locate those parts where I know there are the respective nodes, but this leads to programmer error as I'd have to manually locate those nodes.
01:10:37 <lyxia> What do you mean you gave each node its own type
01:10:57 <koz_> lyxia: I think Arahael means 'my AST is not a sum type'.
01:11:35 <Arahael> My AST represents a Delphi unit file.
01:12:14 <Arahael> So, I have a type that represents "Unit" - the file itself, which could either be 'DelphiUnit a b c d e f', or 'Program [d]', each of ehich in turn can have... And so on...
01:13:33 <Arahael> The AST is here: https://github.com/arafangion/delphiparser/blob/master/src/DelphiAst.hs
01:14:11 * Arahael welcomes any suggestions!
01:19:26 <ClaudiusMaximus> Arahael: not used it myself, but the documentation for uniplate looks interesting
01:19:51 <lyxia> also syb
01:20:15 <Arahael> Hmm, so you are proposing I do this with generics?
01:21:00 <ClaudiusMaximus> you did ask
01:22:05 <Arahael> ClaudiusMaximus: I'm just surprised that the answer involved generics. :)
01:23:04 <MarcelineVQ> generics always seems to come up when people ask about AST's in here. it's suspicious if you ask me
01:24:47 <lyxia> well the point of generics is to work on types without naming them, so that scales to large types.
01:26:48 <Arahael> Just to be clear, I can't do this with lenses and traversables, whilst avoiding code duplication if I wanted to iterate over a different type instead?
01:27:29 <Arahael> Eg, today, I want to collect all the TypeName instances (and be aware of where they were found in the structure).  Tomorrow, I want to locate all the classes instead.
01:28:33 <lyxia> I think lenses and traversals are an orthogonal question.
01:28:50 * hackage mismi-p 0.0.2 - A commmon prelude for the mismi project.  http://hackage.haskell.org/package/mismi-p-0.0.2 (nhibberd)
01:29:24 <lyxia> lenses can be derived generically, but there might not be an existing implementation for what you are looking for.
01:29:49 <Arahael> lyxia: I've been learning about lenses at work, I think you're right there, they're quite orthogonal.  A traverse, hwoever, I don't yet understand.  I was hoping that they would let me "iterate" over the data structure, hwoever, it sounds more like a transform where I would have to define a visitor that has been implemented for every tyep it contains?
01:29:51 * hackage mismi-s3 0.0.2, mismi-s3-core 0.0.2, mismi-core 0.0.2, mismi-kernel 0.0.2 (nhibberd)
01:31:47 <lyxia> traversals and lenses are very similar so in a high-level discussion like this one I consider them the same
01:33:44 <Arahael> lyxia: Hmm, that's curious as I thought I understood lenses, but *not* traversals.
01:37:54 <Arahael> Hmm, maybe what I want are actually zippers - and uniplate looks like it may have a convenient way for me to get them with my ADT.
01:38:16 <Arahael> (This is because I would like to have an idea of "where" the value was found)
01:40:30 <Arahael> I presume I could define helper routines, such as "nextTypeName", to move the context to the location of the next type name.
02:11:19 <AJTJ> hey
02:11:26 <AJTJ> I'm new to Haskell
02:11:31 <AJTJ> who actually uses it
02:13:49 <Rembane> AJTJ: Facebook uses it for their abuse handling system.
02:17:37 <koz_> We all use it.
02:17:40 <koz_> For assorted things.
03:17:42 <sm> g'day all
03:35:43 <delYsid> Rembane: Which isn't exactly advertisment in favour of Haskell... :-)
03:50:43 <shafox> i am building a library for which at the start the process, it should know all the services/programs are operational and this too per thread basis, actually  i am not sure what i am looking for to search.  what should I be searching for more answers . ? 
04:00:02 <sm> refine the question a bit..
04:00:34 <sm> you want to query the OS to find out what other processes are running ?
04:04:06 <ph88> when i have   bla <- getIOString    how can i annotate bla to be of type  String ?
04:05:29 --- mode: glguy set +v mreh
04:05:32 --- mode: glguy set -v mreh
04:06:32 <ski> @type do bla :: String <- getLine; putStrLn (reverse bla)
04:06:33 <lambdabot> IO ()
04:07:07 <ph88> oh left of the arrow
04:07:12 <ph88> ok ill try just a moment
04:07:15 <mniip> that requires ScopedTyVars
04:07:36 <mniip> without them you need to write   do bla <- getIOString :: IO String
04:07:52 <ski> you could alternatively add an ascription on the use of `bla' .. or what mniip said
04:09:01 <ph88> what's the difference in hpack default-extensions and other-extensions ?
04:11:51 <Solonarv> default-extensions are extensions that will be enabled in every source file, other-extensions just indicates this this extension is used in at least one source file
04:12:50 <Solonarv> (this is a cabal feature and has nothing to do with hpack, btw)
04:14:04 <ph88> so other-extensions is useful to let users of the package know which extensions are used ?
04:14:25 <ph88> and default-extensions is also to let users know which extensions are used but at the same time enables this extensions for every source file ?
04:15:19 <Solonarv> Correct
04:15:31 <ph88> so other-extensions is supposed to be used with language pragma in file ?
04:15:37 <Solonarv> Yes
04:15:59 <ph88> by the way .. if i enable an extensions but don't use it's features can it introduce some overhead in the compiled program ?
04:16:24 <Solonarv> In principle yes, in practice that can only happen for a small handful of extensions
04:16:31 <ph88> ok
04:17:00 <mreh> breaking apart an acid-state database into modules is pretty difficult, the `Update`s and `Query`s in sub modules have to reference the state type in `AcidState state` so you get cyclic dependencies
04:17:33 <Solonarv> other-extensions/default-extensions also allow cabal to figure out ahead of time if the compiler you're using supports the extensions used in the package
04:18:21 <ph88> great Solonarv 
04:18:37 <Solonarv> This is not really necessary in practice nowadays, since nearly everyone uses GHC or a variant of it, but it's still useful
04:19:06 <hpc> it leaves things open for a new experimental compiler, which there have been a few of in the past
04:22:11 <ph88> how do i go from CSize to Int ?
04:22:43 <Solonarv> fromIntegral should work
04:23:19 <ph88> eh sorry the other way around i mean
04:23:23 <ph88> from Int to CSize
04:24:08 <hpc> fromIntegral should still work
04:24:15 <ph88> cool ^^
04:30:28 <ph88> when i define both an executable and a library for the build, how do i make the library source files accessible from the executable? 
04:37:32 <Solonarv> add the library to the executable's dependencies 
04:37:57 <Solonarv> (if your package is called 'foobar', then the library is also called 'foobar')
04:42:29 <ph88> great
04:42:49 <ph88> i'm getting build errors now though https://bpaste.net/show/0e9fde04bbc9 https://bpaste.net/show/15e4b5e7ebfc  why is the linker having problems ?
04:43:16 <ph88> oh .. actually now that i look at it i know why :|
04:43:29 <ph88> seems that my system installed library is for 32bit code units only
05:28:35 --- mode: glguy set +v Ulbrec
05:38:00 <ph88> if i put build-type: Configure which needs a configure file in the root of project to be called. Can the configure file be cross platform ?
05:40:34 <ph88> don't think so tbh :|
05:45:19 <domenkozar> so how can I determine what IO functions are lazy/strict? In particular: Data.Text.IO.{readFile,writeFile} and Data.ByteString.{readFile,writeFile} and
05:45:34 <domenkozar> well I guess copyFile is strict.
05:46:10 --- mode: glguy set +v turba_dilatatio
05:47:51 <ph88> domenkozar, as far as i know everything is lazy unless it's explicitly strict
05:48:51 <turba_dilatatio> Hello all.  I've run into a bit of a challenge: I would like to implement a function which takes a function reference as an argument, then call that function reference therein.
05:50:11 <turba_dilatatio> A non-working example is: move recurse maze cx cy = recurse (recurse) maze cx cy
05:50:50 <ph88> turba_dilatatio, don't think "function reference" is a thing in haskell, maybe just function as value ?
05:51:24 <pavonia> recurse probably also needs some arguments
05:51:43 <ph88> turba_dilatatio, maybe provide some more code
05:55:20 <turba_dilatatio> Example of working recursive function calling itself: https://repl.it/repls/SerpentineDualParameter
05:56:27 <turba_dilatatio> However, I would like to be able to, for example in a unit test, pass in a fake move function defined in the unit test, to verify that the real "move" function is recursively calling the fake with the proper parameters.
05:59:21 <pavonia> turba_dilatatio: Can you also show the code that is not working for you?
06:03:16 <ski> turba_dilatatio : did you intend something like `moveVia :: (Maze -> Int -> Int -> Result) -> (Maze -> Int -> Int -> Result)' for the latter definition ?
06:04:06 <ph88> turba_dilatatio, you are better of testing "hasNext maze cx cy" because under this condition your move function will be called
06:04:52 * ski would probably switch to guards, here
06:06:10 <turba_dilatatio> I updated the repl with the example and error I receive.
06:06:29 <ski> `v' is unused
06:07:05 <ski> (and, with what i suggested, you'd not pass `recurse' to itself. and you could define `move = moveVia move')
06:07:12 <turba_dilatatio> As this is my first attempt with Haskell, I didn't worry about best practices and improved syntax.  I'll provide a link to the github for anyone that wants to have a good laugh.
06:07:53 <ski> the occurs check error is because you try to pass `recurse' to itself
06:07:56 <ph88> so cabal has a configure command ?
06:08:18 <turba_dilatatio> @ski I think I see what you are saying; moveVia is the conduit to pass move to itself?
06:08:18 <lambdabot> Maybe you meant: wiki src ask
06:08:26 <ski> turba_dilatatio : not that bad, for a first attempt
06:09:16 <turba_dilatatio> https://github.com/calledtoconstruct/maze/tree/joseph/Haskell/version-1.0
06:10:04 <ski> turba_dilatatio : yes. and you could try passing a function that does more to `moveVia', for the testing. i'm not sure how well that will work out, but that's what you seemed to want to do
06:11:13 <ski> turba_dilatatio : if you try to define a function `f :: A -> B' that you can pass to itself, like `f f', then that means that the argument type `A' must be equal to the whole type `A -> B' of the function `f'
06:12:00 <ski> turba_dilatatio : so `A = A -> B = (A -> B) -> B = ((A -> B) -> B) -> B = ... = (((...) -> B) -> B) -> B'. that's the infinite type the error message was complaining about
06:12:19 <ph88> how can i detect if cmake is available on the system from haskell code ?
06:12:54 <turba_dilatatio> I tried writing the updated type declaration of move (with the recurse arg) and quickly realized the infinite type declaration issue...
06:13:28 <ski> (it would be possible to make the type system allow such infinite types. but it turns out that it's usually a mistake (such as in this case), when you run into it, and therefore it's declared a type error by the type system. if you really want to express such a type (and sometimes you do), you can explicitly wrap into a new recursive data type)
06:13:47 <turba_dilatatio> but I was hoping there would be some language feature or syntactical sugar that would allow me to say   f :: f -> Maze -> Int -> Int -> Result
06:14:50 <ski> (btw, with enough polymorphism, it is possible to pass a function to itself, like `id id'. but strictly speaking, that's passing the function to a specialized version of the polymorphic function)
06:14:53 <sproingie> looks vaguely like fix
06:15:21 <ggole> 'Infinite' isn't really the best terminology, since the type is finite when viewed as a graph
06:15:50 <ggole> Although I suppose it doesn't matter much if you aren't going to allow them
06:16:05 <ski> (OCaml allows cyclic/infinite types. it needs it to express structural typing of object types. but the cycle must pass through at least one object type. if you pass `-rectypes' to the interactor, that restriction is lifted, in case you want to play with it)
06:16:28 <ski> sometimes people would call it a "rational type"
06:16:46 <ski> "cyclic" and "equirecursive" are also terms that are used
06:17:30 <ggole> 'Cyclic' is reasonable.
06:17:39 <oldandwise> what is <$>
06:17:48 <ski> ("isorecursive" would be when `A' isn't equal to `B', but is isomorphic to it, via an explicit isomorphism, like `newtype A = MkA {unA :: A -> B}'. here `MkA' and `unA' are the two directions of the isomorphism)
06:17:49 <sproingie> oldandwise: infix alias for fmap
06:18:08 <ski> (er, isn't equal to `A -> B', i should've said)
06:18:25 <sproingie> called <$> because you can think of it vaguely like $ but "adapted" for the type on the right
06:18:38 <turba_dilatatio> I'm happy to at least have a working application; the purpose of the question was, in the near future, to re-write it using test driven development.  Given the python version, where I wrote it test first, it was necessary to implement the function argument in order to force the recursion from the unit testing.  (verify that it was recursively calling and passing appropriate parameters)
06:18:59 <ski> turba_dilatatio : if you really want to pass `recurse' to itself, it's possible. but i think it's probably both sufficient and nicer/easier to do it with `moveVia' as i suggested
06:19:31 * ski idly wonders whether turba_dilatatio knows about QuickCheck
06:20:14 <ski> hmm
06:20:14 * freeman42x[nix] idly wonders whether ski knows about hedgehog.
06:20:48 <ski> hm, i didn't. ty :)
06:21:06 <turba_dilatatio> @ski  Yes, I was introduced that QuickCheck, but I have yet to use it.
06:21:06 <lambdabot> Maybe you meant: wiki src ask
06:22:22 <ski> turba_dilatatio : fwiw, it's not IRC custom to prefix people's nicknames with sigils like `@' when addressing or mentioning them. simply mention their nickname, e.g. at the start of the message, followed by a comma or a colon (if you use tab-expansion in your IRC client, it'll possibly do that for you)
06:23:07 <ski> (you have a higher chance of them getting alerted to the message, if the nickname is the first thing in the message)
06:24:53 <sproingie> plus, @foo tends to be the way to trigger bots on irc (including lambdabot as you can see)
06:26:58 <turba_dilatatio> Thanks!
06:27:03 * ski isn't sure how turba_dilatatio was intending to do the checking of the recursive call
06:27:29 <ski> i.e. do you just want to call `error' if you see arguments passed that you didn't expect ?
06:27:47 <ski> or do you want to return some kind of summary of the test done ?
06:28:44 <sproingie> i'd suggest testing behaviors, not low-level mechanics like "was this function called?"
06:29:18 <turba_dilatatio> ski, currently the move will recursively attempt to run the whole maze.  For testing purposes, I may want to verify only that it 1) leaves a breadcrumb at the proper place and 2) calls the recursive function with the x, y of the next location.
06:30:29 <ski> i think i'd probably focus on testing `leaveBreadcrumb' and `findNextInMaze', for those
06:30:35 <turba_dilatatio> One of the (intended) challenges of TDD is understanding the problem well enough to write a test that drives the writing of the code.
06:30:55 <sproingie> craft a test that could only succeed if the recursive step is taken.  otherwise it's like testing whether a loop actually, well, loops.  the compiler makes sure that happens.
06:31:04 <ski> (also, did you intend to use `v' or not ?)
06:31:33 <turba_dilatatio> No, `v` is unused and I'll replace it with `_`
06:31:39 <ph88> does haskell have something like "which" so i can find the path to an executable ?
06:31:41 * ski did think it sounded similar to `i++;  // increment i'
06:32:38 <sproingie> ph88: http://hackage.haskell.org/package/directory-1.3.3.1/docs/System-Directory.html#v:findExecutable
06:33:38 <ph88> thank you sproingie 
06:44:04 <merijn> Boxing day is when you delete all -XMagicHash from your Haskell code, right? </day late humour>
06:44:48 <sproingie> too early in the morning for magic hash
06:47:16 <merijn> Nearly 16.00 here :p
06:53:50 <ph88> how come the link to createProcess https://hackage.haskell.org/package/directory-1.3.3.1/docs/System-Directory.html#v:findExecutable points to a 404 page ?
06:55:00 <merijn> ph88: Because someone build the docs wrong, because that function is not from that package
06:55:16 <ph88> should i report a bug about it ?
06:55:41 <Tuplanolla> Locally-built documentation seems to have the same issue, so yes.
06:55:59 <ph88>  to where should the bug be reported ?
06:57:37 <Tuplanolla> The issue is that `directory` does not depend on `process`, so the module cannot be referenced.
06:57:56 <sproingie> ph88: https://github.com/haskell/directory/issues (as shown on the main hackage page for directory)
06:58:15 <ph88> maybe there is no option for haddock to point to other modules
07:00:18 <sproingie> but if there's no dependency, not sure how haddock will find it.  probably just need to de-link it then.
07:00:31 <ph88> how do i put stdout and stderr in the same stream with System.Process ?
07:00:50 <alx741> hello everyone, quick question: How is it called when f(g(x)) = g(f(x)) ?
07:01:12 <Tuplanolla> We say `f` and `g` commute, alx741.
07:02:36 <Tuplanolla> We also say `f` is commutative if it commutes with `swap`.
07:02:38 <sproingie> ph88: this might help: https://stackoverflow.com/questions/28869164/haskell-system-process-createprocess-redirect-stdout-and-stderr
07:03:07 <Tuplanolla> (Should your `g` be `swap`.)
07:04:12 <ph88> sproingie, that example uses two file handles .. i want to mux stdout and stderr together in one handle  like  |&   bash pipe
07:04:25 <sproingie> ph88: so use the same file handle for both
07:04:29 <ph88> ok
07:04:39 <alx741> oh! this was bothering me for hours, nice to know!, thank you Tuplanolla 
07:05:58 <ph88> how can i make something like   tee   so that when i get stdout/stderr from my called process i can both print them to screen and also write to a file ?
07:06:15 <ph88> calledProcess |& tee myfile.txt
07:07:46 <sproingie> looks like if you want to redirect stdout globally, there's hDuplicateTo
07:08:02 <sproingie> but if you're already using createProcess, probably best to do it expliitly
07:10:56 <ski> Tuplanolla : if it absorbs `swap' ?
07:12:16 <ski> (note that `swap . swap = swap . swap')
07:12:36 <Tuplanolla> I guess I should have said that instead, ski.
07:14:50 <Tuplanolla> Yes, indeed.
07:35:20 --- mode: glguy set +v kenardes
07:41:20 * hackage vabal 1.1.0 - the cabal companion  http://hackage.haskell.org/package/vabal-1.1.0 (Franciman)
07:45:22 <ph88> why doesn't this have a description of the data constructor? https://hackage.haskell.org/package/process-1.6.5.0/docs/System-Process.html#t:ProcessHandle 
07:47:00 <merijn> ph88: What sort of documentation would you expect? It is a handle for the process you created.
07:47:08 --- mode: glguy set -v kenardes
07:48:51 <ph88> merijn, i was expecting the data constructor there .. but maybe the internal values are not supposed to be used. But now in the doc it looks like it's a type without data constructor o_O
07:49:01 <ph88> https://hackage.haskell.org/package/process-1.6.5.0/docs/src/System.Process.Common.html#ProcessHandle
07:49:03 <merijn> ph88: The data constructor is not exported
07:49:16 <merijn> ph88: You can't pattern match or construct values of ProcessHandle yourself
07:49:19 <ph88> ok
07:49:49 <merijn> ph88: So there is a constructor, you're just not allowed to see it/know what it is (because it's an internal implementation detail)
07:50:30 <sproingie> ph88: BTW, have you seen Shelly?  i've not used it but it looks like it might handle a lot of your use cases more simply than using createProcess by hand
07:51:03 <ph88> sproingie, there is also turtle :P but it doesn't have good support for regular expressions which i use a lot with shell scripts
07:51:53 <sproingie> shelly does look like something that would be able to implement a tee easily.  i imagine you could get at the raw process if you had to
07:54:02 <__monty__> ph88: Where do you use regexes? Do you mean globs?
07:54:11 <ph88> __monty__, for utility scripts all the time
07:54:35 <__monty__> But bash doesn't provide regexes afaik?
07:54:38 <sproingie> it does
07:54:50 <ph88> but i use php for such scripts because i don't know bash well
07:56:59 <__monty__> Can you give an example, sproingie?
07:57:13 <__monty__> I thought it was only some commands that implement regex syntax.
07:57:20 <__monty__> So it's not built-in like globs.
07:57:37 <ph88> __monty__, sed is often used in bash scripts
07:57:39 <sproingie> __monty__:  [[ hello =~ ^h[aeiou]l+o$ ]] && echo "yep"
07:58:16 <__monty__> ph88: But sed does its own regex handling? So it'd work fine with turtle?
07:58:20 <sproingie> basically a =~ operator like perl and the regexes are pretty much posix
07:58:54 <ph88> __monty__, i'm not sure if it's the point of turtle to be calling into external program a lot. Maybe it is
07:59:04 <__monty__> Can't imagine it's very common though. For one it's a bashism. I haven't encountered it ever.
07:59:42 <__monty__> ph88: I thought it was to be a shell replacement. Not a GNU utilities replacement.
07:59:54 <sproingie> i use regexes in bash scripts all the time.  still haven't taken to using bash arrays though
08:00:16 <sproingie> about the time i start needing those, i switch to perl
08:00:25 <ph88> __monty__, i guess that's why i use php instead of bash :P
08:01:32 <metalrain> I hate how bash treats whitespace, I make so many mistakes that I don't notice unless I try all code paths manually 
08:02:08 <sproingie> shell parsing and escaping is fraught with error
08:04:32 <sproingie> that behavior is another pain point that causes shell scripts to switch to perl
08:04:45 <drewr> metalrain: https://www.shellcheck.net/?
08:05:13 <drewr> at least helps when you _have_ to write bash (and it's written in haskell)
08:05:38 <__monty__> Friends don't let friends script shell without shellcheck.
08:06:46 <ph88> how can i write this code the right way ? https://bpaste.net/show/82bbbe5e6959 
08:08:02 <ph88> return exit_code is missing from the paste
08:08:55 <sproingie> == doesn't do pattern matching
08:11:02 <sproingie> you need to do something like `case log of (Just log_path) ...` or pattern match in the runCommand definition
08:12:34 <ph88> wait a moment
08:13:35 <sproingie> for ensuring handles get closed, you probably want to be using 'bracket'
08:14:26 <ph88> i made it like this now  https://bpaste.net/show/bf49398d67ac
08:14:29 <sproingie> (from Control.Exception)
08:16:26 <[Leary]> @hoogle whenJust
08:16:26 <lambdabot> Control.Monad.Extra whenJust :: Applicative m => Maybe a -> (a -> m ()) -> m ()
08:16:26 <lambdabot> Extra whenJust :: Applicative m => Maybe a -> (a -> m ()) -> m ()
08:16:26 <lambdabot> Data.GI.Base.Utils whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
08:17:01 <[Leary]> It's good for this kind of thing. Though the pattern match is fine.
08:17:13 <ski> aka `for_'
08:17:14 <merijn> [Leary]: You want forM_/for_
08:18:06 <[Leary]> Whichever form you fancy.
08:19:07 <[Leary]> I usually use flip foldMap myself.
08:20:15 <merijn> :t flip foldMap
08:20:16 <lambdabot> (Monoid c, Foldable t) => t a -> (a -> c) -> c
08:21:14 <Solonarv>  But that one doesn't work the same for every applicative
08:21:38 <Solonarv> if m ~ IO it's the same, but if m ~ Maybe or m ~ [] it isn't
08:23:14 <[Leary]> It's a little different, but it's the same in the most common use case, and I find it the more preferable generalisation of that case.
08:34:22 <ph88> i have this Setup.hs file https://bpaste.net/show/9f734f47f840 compiles well but cmake.log stays empty. I only see the output of cmake in my terminal it doesn't get into the log. I want to have similar functionality like   cmake |& tee cmake.log
08:38:16 <sproingie> ph88: i think you have the args to hDuplicateTo reversed
10:39:36 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam | glguy's AoC leaderboard code 43100-84040706'
10:39:36 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Fri Nov 30 18:55:32 2018]
10:39:36 --- names: list (clog spacejam sproingie revprez marsam carif bendo pie__ acowley armyriad forell jeltsch raingloom cschneid abhixec libertyprime FreeBirdLjj noan Deide rcdilorenzo dpyro Phil25 DTZUZO robink R0b0t1` poljar1 ym555 dale erisco_ KeyJoo CoderPuppy conal lukeshu binq_ orion savolla osa1 HarveyPwca LysergicDreams gienah rblaze Gurkenglas gxt quipa al-damiri jluttine nullifidian perrier-jouet smitop lquenti mcc UpstreamSalmon Lord_of_Life aarvar stevenxl)
10:39:36 --- names: list (michalrus oo_miguel revprez_anz isgy __monty__ eldritch rain1 trobotham niklasl2 inkbottle TonCherAmi fmixing howdoi vukasink Lycurgus stmcxf_ kmelva merijn dddddd Xal daeler mort mizu_no_oto urodna +turba_dilatatio jchia_2 ccomb milanj_ +Ulbrec imdoor m0w tito_04 Snircle jchia tomsen Cale elfets lee_ freeman42x[nix] simukis ph88 shafox cybai [Leary] Unode pfurla_ Solonarv reactormonk Synthetica catsup AJTJ ashirase thunderrd tromp grembeter[m])
10:39:36 --- names: list (zargoertzel streamline_ phma slomo thc202 caryoscelus rofl_ justanotheruser Boobie lockestep Ericson2314 bind day XCE i1nfusion drbean lassulus lagothrix keep_learning_M Destol tehidiot[m] platz zzz remexre sleblanc elgot cchalmers Axman6 gbellinoz_ tomku xiongchenyu6 markedfinesse yumh dxtr infinisil Neuromancer Akii Niamkik ironChicken Anthaas jan-sipr +i8hantanu kasra sud0 alx741 eschnett_ azahi notzmv OnkelTem cafphtgfeomt zv saml p0lyph3m lalbornoz)
10:39:36 --- names: list (wildlander noctux Sose dongcarl ecx bas080 piyush-kurur noumenon amtematem condy carbolymer_ phreedom__ cads Cthalupa danso nfd9001 monochrom appleclusters Meanirelli moei mupf iltiades toovs khisanth_ nyaomi coeus OpenSorceress parkie213[m] alyptik dmiles immae _deepfire tombusby DrAwesomeClaws Jesin tomboy65 underikar MonkeyNOS a3x hackage wonko7 grumble Frans-Willem Bergle_1 Reisen Fistine ibttis lugh seizo ahihi sitischu[m] xkapastel pacak1 mudri)
10:39:36 --- names: list (cyphase DexterLB moony abrar wz1000 ClaudiusMaximus veverak PragCypher statusfailed zaquest markus1189 seanparsons MarcelineVQ ^W APic emilypi texasmynsted ephemient Ckat JSharp Stanley00 AfC t7 pigsalsa gentauro atk bydo +ACheesyName nshepperd erikd kuttifunk +rezzme s_jmp jtcs devurandom dustinm pranz3 sputny[m] junoII noCheese Tesseraction TipsyMe TyrfingMjolnir +fcse revprez_stg shutdown_-h_now blue_feint riatre cheater leothrix drdo juri_ yaroot)
10:39:36 --- names: list (irdr troydm pierrot Unhammer Tene ryantm SCHAPiE greeny1 clever duncan^ lkurusa sw1nn secretmessage philippirrip @glguy Ewout fryguybob dave_uy typedrat ByronJohnson axios buhman tinwood vk3wtf ixian ego jchristopher[m] apeyroux velmacat betz\[m]1 m1dnight_ kav JoelMcCracken edwtjo jstolarek dmwit mimi_vx iomonad lnostdal bluepixe1 +pythonisbetterth spion nicoulaj Foritus Ranhir gspia Guest314 lyxia adw[m] thebnq atraii kmels treehaqr mr_yogurt cods)
10:39:36 --- names: list (drewr albel727 nahra martingale shiona +spinye[m] davl mnrmnaugh nimbleark ab9rf amiri ahri +JoelMcCracken[m] ayk[m] iskander kini mulderr tnks geranim0 ianp anishathalye lag k4rtik Tops2 suzu crooked akshayn_ powerbit swalladge kjak magicman GGMethos agrif ctrd ephemera_ energizer sdx23 kenziefc[m] qnikst wamaral cthyga[m] Kiruwa pittma theorbtwo brent80_plow TallerGhostWalt ekleog srhb dminuoso m-renaud wtw sclv +coot__ linoge Nascha ancarda niko tjbp)
10:39:36 --- names: list (hpc chin-tastic kisller[m] redfish64 ArneB jhammons goreye lexi-lambda gsingh93 trillpoli[m] avn nille kungp devalot ezyang nikivi Jinxit bwe Jonathan[m] cgfbee meinside ghuntley urdh elpfen[m] Moyst nefple[m] kAworu paraseba pita megaTherion moobar ycheng Jezus jzl shaney[m] Zoddo Fairy twk- grasm[m] otulp hvr tomdavidson[m] verite abbe ft StoneToad arianvp Nik05 rruizt echoreply Majiir kark polman zenspider mceier DTZUZU Flonk aramiscd toppler)
10:39:36 --- names: list (mountaingoat winny drewbarbs shachaf bgamari keep_learning test654321[m] jle` Putonlalla _dga Jaxan TommyC mulk wagle nckx sphalerite mikeplus64 bbaren bartavelle PyroLagus cwolf[m] alextes +cyjiao_ AndreasK gonz_ stux|RC-- bjobjo dolio kalloc johnw ralu iiska[m] asjo` infinity0 DenisLehmann[m] jorj marble_visions geronimogarcia rembo10 awal jakt[m] themsay[m] jokester Blkt yushyin stass ian5v Rembane pepijndevos hc madnight amalloy wto verement abra0)
10:39:36 --- names: list (jonatan alp PLPD-Bot typetetris Profpatsch ManiacTwister nek0 lsuess[m] lainsce[m] Deadhand ne Willis kloeri obiwahn cjay- jonge @Sigyn martin--t esph_ aurieeeh auri_ obfusk rokhuz segfaulthunter Jonno_FTW qwitwa[m] Enigmagic guios M0x8badf00d[m] earthy asm89 kaaloo[m] +nybble41[m] ktorek[m] lixl03[m] jschaefer152[m] MichalLaskus[m] vk3wtf[m] onesadcookie[m] Martin333[m] Richard[m] muratanil[m] qffr[m] veggero[m] tmsc[m] M566754567gh[m] Obscurity[m])
10:39:36 --- names: list (jhhuh[m] telser[m] kebertx[m] stammon whitebluff-actua hsw[m] xiaia[m] silforion[m] hogarth[m] tfc[m] chaseroycroft[m] ArchieT[m] redrooster[m] Christophe[m] killjoyy[m] d-fish chickenbuttscrat k0d3fr34k[m] arrdem[m] dnk8n[m] loco_joe[m] kedah[m] DarkBuzz[m] lurpam[m] kxra[m] benedik[m] fre[m] lowryder shafoo1 hdurer[m] silasnordgren[m] pagoda_5bIvanoP4 nitrix-mas psiska[m]1 johnnyv[m]1 cepxuo1 jix_ efskap_ Zemyla mstruebing hive-mind xacktm amatecha)
10:39:36 --- names: list (nkaretnikov milessabin amarrella unsymbol artify[m] tabaqui1 lokydor nonzen h11 divVerent bobach[m] yahb boj tdammers greensalmon[m] sigmundv feuerbach richi235 r3drim[m] comboy TimWolla pdgwien Philonous apoc hgfedcba[m] biocage[m]1 +Firedancer [df] opqdonut Bish sqrt2 tsahyt +aleator CindyLinz cheers flux lambdabot tumdedum pong joncfoo fredcy_ sw4n koz_ droplet aporia[m] javaperl[m] kwantam wrengr_away hiptobecubic pigs [exa] Tuplanolla liff)
10:39:36 --- names: list (dominicusin[m] jwynn6 fr33domlover tigerchops ent Taneb pittma[m] gkobeaga[m] jb55 kipras`away russruss rootnode caa51h codedmart scarbo[m] jenkee[m] periapseez[m] Tristan raatiniemi Heartmender jakehehrlich_ +Logio oresama[m] tehidiot datajerk slickmick fiatjaf cppxor2arr lortabac Someguy123 catern acro pacak sdrodge rinfiyks niklasb_ Amadiro qzo runawayfive Firedancer_ cross Twey lantti bjs mou_ w1gz dogui_ aweinstock telser- ion diginet mauke_ sujeet)
10:39:36 --- names: list (anderson chivay Charn quaestor tv nrdxw[m] Franciman quarters Tspoon_ intelux ibebel[m] mrd michaelpj aldum vistefan[m] dsturnbull bod_ Guillaum incomprehensibly nurupo loc hjozwiak Orbstheorem neobrain mankyKitty harmaahylje thegod[m] atomi bradparker kristjansson wildsebastian runeks spinda mgttlinger[m] +kyagrd_ zxrf Robin_Jadoul TMA janosch haasn n-st setre raoulb humanwire[m] DigitalKiwi Wizek stiell cow-orker xnyhps potato44[m] BL[m] freusque[m])
10:39:36 --- names: list (adziahel[m] leonardo2718[m] diazkun[m] cynick HalfEatenPie mniip polux hpd centril bs tril[m] ftop so tdd123[m] quicksilver asp4s[m] nbouscal blakec[m] rotty averell luqui xplat jhgarner[m] d6e kahuna[m] _flow_ cocreature Forkk kittyal4 Jacoby6000 linduxed vaibhavsagar +jackboy[m] markhuge_ Adluc srk strangeglyph tessier fiddlerwoaroof dsal ksonj[m] moriacat bsima eikke zabracks bengt_ dan64- carc freusque Intensity MasseR krystianbajno _6a68 sepp2k)
10:39:36 --- names: list (Liskni_si iphy rann amx debugloop +hpd[m]1 RusAlex spacekitteh[m] +Levy[m] fredcy Madars meck +Ferdirand pikhq dredozubov cpape nopf brisbin lachenmayer bcoppens xelxebar teto ZeWeaver[m] optimizationproc enick_867 yhylord[m] zonderping[m] yajaru[m] unclechu qwqdw[m] rhc[m] hyp3rbor3ax[m] kitsune[m] jayjay[m] mubareksd[m] test05[m] riquipuig[m] v45h[m] pauls_sondrel[m] acidrain_burns[m citrusmunch[m] tigermants[m] SamuelHenrique[m illandan[m] hjulle)
10:39:36 --- names: list (max3raza[m] xobroll[m] sixtysixfps[m] dandan[m] squallcx[m] seeh[m] Etsi[m] wst[m] guillaumecherel[ mimi55555[m] mrbackend[m] monomono[m] NoSwear[m] volslinger[m] t[m] lmiskiew[m] jakubdaniel[m] zebz[m] frump[m] traxticlet[m] cryptomann[m] acomar[m] trimple[m] M1206378[m] happy_gnu[m] mikeavenatti[m] dotglitch[m] flyingclam[m] Fede[m] dubaduba[m] acertain Noughtmare[m] chreekat[m] tet[m] ambler[m] Hanma[m] jlavelle[m] fabianhjr[m] jangsentry10032[)
10:39:36 --- names: list (jansc[m] el_tejon[m] ejpcmac peel lierdakil[m] kaychaks[m] bmjh[m] jibby[m] abhir00p[m] dsr[m] lightandlight[m] WilliamHamilton[ TuXic[m] elijordan alanz[m] berdario[m] fgaz Barnabas[m] asm[m] aloiscochard[m] sudden Fubar^ eagleflo vqrs domenkozar implementation_ phadej kqr zfnmxt barrucadu geal reverse_light realloc maerwald celphi Wamanuz Vq tripty koala_man shapr Dunatotatos ski animeshs tolt awx_ qz scinawa ventonegro amuck t36s milli` Cathy jkarni_)
10:39:36 --- names: list (max3raza_ ephemeron idupree2 aidecoe bspar_ sivs_ rizary pent bitonic +higherorder_ scav Tritlo +Peter_Storm__ techieAgno2tic thi +simony_ NemesisD pgiarrusso eacameron +koankeeper janne luminous dilinger PHO benjamin-l lpvb NinjaTrappeur bdw SrPx Chousuke korans noko_ aib sis7 coldpress M2tias uwap beka joeyh bandali pikajude jrslepak mxf EvanR natim87 ubercow stefan-__ orzo +nickoralias djanatyn mitch_ leah2 benzrf jp rotaerk no-n cjh` a3Dman_)
10:39:36 --- names: list (salparadise pdxleif jackhill saurik_ cesardv_ joehillen trebuh delYsid heath evilmonads mud rzmt stylewarning glowpelt parseval rkrishnan Tourist toure|gone lstdgtfp sbrg deu seliopou bob_twinkles lieven mtjmullen abuss gluegadget soitgoes ljhms yarnspinner pyrtsa spoonm nshepperd1 Guest51120 Patternmaster teej Bigcheese +feepo thoughtpolice PoliticsII sgraf nilOps rom1504 Novitsh DwarfMaster vimto dysfigured umpc shrifbot joeytwiddle vxe Shockk ruffy_)
10:39:36 --- names: list (jdevlieghere fairfieldt maxvaillancourt1 free-zombie oberstein rj1 olspookishmagus reyu avp lukelau h30 exarkun_ jophish kaol PotatoGim dgpratt `slikts arw solarus +newhoggy_ heyj sm cjwelborn mantovani jfredett betawaffle runde soncodi thallada cemerick carter johs nh2 __4matter hsiktas darthThorik mgttlinger dukedave billstclair adamse thoradam jzelinskie ajmcmiddlin banjiewen +paf31_ +sppky +fingerzam +mbeidler _ceb steell Konehaltia zenzike Izeau)
10:39:36 --- names: list (mingc Guest40074 giraffe Dabo Ke pakettiale +corlock_ joel135 zerokarmaleft drager dejanr_ Ekho lispy Klumben SolarAquarion thaumavorio ambrosia Geekingfrog worch ids1024 Randy metalrain SegFaultAX monad_cat mtift bertschneider eribeiro gargawel graingert arkeet geekosaur raid noexcept hexagoxel Athas benl23_ Nikotiini baweaver habbah absence violeta Kneiva bollu d3lxa adamCS cyberlard sssilver mahalex rootmos wraithm c50a326 wayne_ ctag1 dibblego Ring0`)
10:39:36 --- names: list (phaazon int-e ammar2 parenthetical chindy cgoldamm1r nbathum mikolaj tureba Arguggi_ turol luigy Clint puffnfresh rodlogic Adeon Velpoman avocado Deewiant ullbeking dpn` alexelcu furnost hodapp adarshaj terrorjack klugez saidinwot lavalike mcspud +ranberry__ defanor gremax ryjm bafain Ornedan lpsmith Nizumzen systemfault nemesit|znc Kamuela ryzokuken fnurglewitz +isacl_ pasukon beaky +exferenceBot @ChanServ davean qdickon sms Saizan syamaoka SquidDev)
10:39:36 --- names: list (pharaun Arahael dyl PierreM bitemyapp Mon_Ouie flogfr blackdog_ ynyounuo petercommand Hijiri burp peschkaj verlet64 alanz andjjj23 rodgzilla nyaray__ gregberns statusbot cloudhead rslima_ nano- Jon gothos dexterfoo tazjin elvishjerricco angerman dmj` integral georgew stvc Detson haveo mpickering akermu edwardk epta Guest11673 UserOO7 vodkaInferno c_wraith kubrat jackieh__ Grominet zymurgy Jello_Raptor iron_houzi runit michalisko greeny__ jvanbure dh)
10:39:36 --- names: list (vin-ivar iravid jonrh jgornick v0d1ch ocharles nisstyre adius Annihitek fluxi- sshine cbmuser exio4 hiredman mmaruseacph2 rntz pwestling kosmikus mrm Squarism dfordivam)
10:59:06 <seishun> :t reverse . sortOn (\(a, b) -> (a + b, a - b))
10:59:08 <lambdabot> (Num b, Ord b) => [(b, b)] -> [(b, b)]
10:59:17 <seishun> how can I write this without reverse?
10:59:57 <seishun> assuming `a + b` and `a - b` are arbitrary functions
11:00:07 <merijn> :t comparing
11:00:08 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:00:26 <merijn> seishun: "flip" :p
11:00:35 <merijn> :t sortOn
11:00:36 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
11:00:38 <merijn> :t sortBy
11:00:40 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
11:00:54 <merijn> ok, so sortOn makes it tricky
11:01:03 <Solonarv> that's what Dual is for
11:01:08 <merijn> > sortBy (flip comparing) [1..5]
11:01:10 <lambdabot>  error:
11:01:10 <lambdabot>      • Couldn't match type ‘b -> Ordering’ with ‘Ordering’
11:01:10 <lambdabot>        Expected type: (b -> a) -> (b -> a) -> Ordering
11:01:16 <merijn> > sortBy (flip compare) [1..5]
11:01:19 <lambdabot>  [5,4,3,2,1]
11:01:51 <Solonarv> > sortOn Dual [1..5]
11:01:53 <lambdabot>  [1,2,3,4,5]
11:01:55 <MarcelineVQ> Solonarv: Down :>
11:02:01 <Solonarv> bah, thanks
11:02:07 <Solonarv> > sortOn Down [1..5]
11:02:09 <lambdabot>  [5,4,3,2,1]
11:03:01 <seishun> but what if I want to sort depending on `foo x` and if it's equal then on `bar x`
11:03:42 <merijn> seishun: Ah, you mean lexicographical sort?
11:04:06 <ph88> can i create an in-memory Handle for reading and writing ?
11:04:13 <seishun> yes, but with key functions
11:04:28 <Solonarv> that's exactly what the 'Ord' instance for tuples does
11:04:37 <merijn> > sortBy (comparing snd <> comparing fst) [(x,y) | x <- [1..5], y <- [6..10]]
11:04:38 <geekosaur> :t sortOn (?f <> ?g)
11:04:39 <lambdabot>  [(1,6),(2,6),(3,6),(4,6),(5,6),(1,7),(2,7),(3,7),(4,7),(5,7),(1,8),(2,8),(3,...
11:04:39 <lambdabot> (?g::a -> b, ?f::a -> b, Monoid b, Ord b) => [a] -> [a]
11:05:07 <merijn> > sortBy (comparing (Down . snd) <> comparing fst) [(x,y) | x <- [1..5], y <- [6..10]]
11:05:10 <lambdabot>  [(1,10),(2,10),(3,10),(4,10),(5,10),(1,9),(2,9),(3,9),(4,9),(5,9),(1,8),(2,8...
11:05:11 <Solonarv> geekosaur: ooh, I'd never thought to use implicit params that way!
11:05:27 <geekosaur> that's the main reason lbot hs them enaled
11:05:35 <Solonarv> :t sortOn (Down . ?foo &&& ?bar)
11:05:36 <geekosaur> it's really convenient
11:05:36 <lambdabot> (?foo::a2 -> a1, ?bar::a2 -> c', Ord c', Ord a1) => [a2] -> [a2]
11:05:38 <merijn> Solonarv: I think he means key functions, rather than concrete tuple elements
11:06:24 <merijn> seishun: The answer is "the amazing monoid instance for functions solves this for you!" but someone else has to explain that, because I'm too busy to explain the details :)
11:07:30 <geekosaur> ph88, there may be something on hackage for that
11:07:49 <ph88> knob
11:07:56 <seishun> maybe you could just provide the code that would do the same as `reverse . sortOn (x -> (foo x, bar x))` and I would figure it out
11:08:27 <geekosaur> generally we consider something like Chan to be more appropriate in that case
11:09:03 <ph88> geekosaur, i want https://hackage.haskell.org/package/process-1.6.5.0/docs/System-Process.html#v:createProcess to write into memory instead of stdout or a file
11:09:22 <merijn> seishun: THat one is just "sortOn (\x -> Down (foo x, bar x))"
11:09:25 <ph88> i must supply https://hackage.haskell.org/package/process-1.6.5.0/docs/System-Process.html#t:StdStream 
11:09:41 <ph88> i have only the choice of Handle and Pipe
11:09:47 <seishun> okay that's simple enough, thanks
11:09:48 <Solonarv> seishun: or if you prefer pointfree, 'sortOn (Down . (foo &&& bar))'
11:09:54 <geekosaur> you can't use an in-memory handle there, because its given to the subprocess
11:09:59 <geekosaur> its memory is not your memory
11:10:13 <geekosaur> you need a pipe
11:10:27 <seishun> :t (&&&)
11:10:28 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:10:49 <ph88> geekosaur, how can i let it know which pipe to use? CreatePipe doesn't accept argument
11:11:02 <Solonarv> seishun, less confusingly: (&&&) -> (a -> b -> c) -> (a -> b -> d) -> (a -> b -> (c, d))
11:11:07 <merijn> Solonarv: "sortBy (comparing (Down . foo) <> comparing (Down . bar))" would work too (or maybe foo and bar need to be reversed? I was too lazy to figure out that formulation
11:11:14 <Solonarv> ph88: it creates a new one and gives it back to you
11:11:25 <infinisil> :t \foo bar -> sortOn (Down <<< (foo &&& bar))
11:11:26 <seishun> I see
11:11:27 <lambdabot> (Ord c', Ord c) => (a -> c) -> (a -> c') -> [a] -> [a]
11:11:34 <geekosaur> it creates one and gives you your end. the other end is the subprocesse['s stdin / stdout / stderr depending on where you specified it
11:11:55 <ph88> ah i get it
11:11:59 <ph88> thank you, i will try
11:12:50 * hackage brick 0.46 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.46 (JonathanDaugherty)
11:13:20 * hackage category 0.2.1.0 - Categorical types and classes  http://hackage.haskell.org/package/category-0.2.1.0 (MatthewFarkasDyck)
11:13:49 <seishun> wait, what's Down
11:13:53 <seishun> :t Down
11:13:55 <lambdabot> a -> Down a
11:14:05 <merijn> seishun: A newtype that reverses ordering
11:14:12 <merijn> @hoogle Down
11:14:12 <lambdabot> Data.Ord newtype Down a
11:14:12 <lambdabot> Data.Ord Down :: a -> Down a
11:14:12 <lambdabot> GHC.Exts newtype Down a
11:14:50 * ski idly wonders why that's not called `Opposite', e.g.
11:15:08 <merijn> seishun: "newtype Down a = Down a", basically
11:15:19 <seishun> ah, it's in Data.Ord. hoogle was pointing me to scary-sounding GHC.Exts
11:15:48 <geekosaur> so you looked only at the last line?
11:16:35 <mniip> is there a name for an applicative functors where  f <*> x = flip id <$> x <*> f
11:16:37 <dminuoso> seishun: In Haskell it is common to use newtype wrappers for the sole purpose of having different instance implementations. Especially typeclasses like Ord or Semigroup/Monoid are good examples.
11:16:41 <mniip> s/an//
11:17:54 <dminuoso> mniip: commutative applicative functors?
11:18:28 <larryba> hello. why is this function not catching thrown exception? https://pastebin.com/3T0mHqN1
11:18:52 <merijn> larryba: Because reliably catching exceptions from pure code is hard
11:18:59 <mniip> dminuoso, hmm
11:19:13 <larryba> merijn, even when catching it in IO code?
11:19:14 <merijn> larryba: Basically, due to laziness the exception doesn't get raised until catch has returned
11:19:18 <geekosaur> larryba, because you are passing back a lazy thunk
11:19:27 <larryba> oh
11:19:31 <dminuoso> larryba: error is *not* thrown in IO.
11:19:33 <geekosaur> return lifts pure code, the pure code is not therebye valuated
11:19:44 <merijn> larryba: Unless the throw happens in IO too (via throwIO), it can sometimes be triggered outside brackets (also why error and throw are evil)
11:19:46 <dminuoso> larryba: It's part of why error is so highly problematic.
11:19:59 <merijn> larryba: A more concrete solution to your problem: use Text.Read.readMaybe :)
11:20:08 <dminuoso> It's very tricky to catch right (you either dont catch enough, or you can catch too much - or you are catching in the wrong place)
11:20:12 <merijn> > Text.Read.readMaybe "foo" :: Maybe Int
11:20:14 <lambdabot>  error:
11:20:14 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
11:20:14 <lambdabot>      No module named ‘Text.Read’ is imported.
11:20:17 <larryba> so what should I do? leave this function as is, or force evaluation of the actions result?
11:20:19 <merijn> aww
11:20:24 <larryba> merijn, that was just a test if my function works
11:20:25 <dminuoso> larryba: Never use `read`
11:20:39 <Akii> never is such a harsh word
11:20:44 <merijn> larryba: Oh, you mean the testing the catch?
11:20:49 <larryba> yes
11:20:51 <merijn> larryba: Use throwIO to raise an error
11:21:13 <dminuoso> Akii: I find it really good practice to use `readMaybe`, and scrutinize into an error message `case Nothing -> panic "impossible: this should be readable"`
11:21:15 <merijn> larryba: throwIO uses the IO to ensure the exception is raised before returning, so it can never escape a catch when using throwIO
11:22:15 <larryba> the point of this function is to prevent "Uncaught exception" being seen by the user, suggesting that there's a bug in my code. so maybe I should force evaluation of catch, or something?
11:22:55 <merijn> larryba: There's a simpler solution :p
11:23:07 <dminuoso> Akii: So yes. Im very confident in "never use read"
11:23:11 <merijn> larryba: There is a top-level "uncaught exception handler" just override that one :p
11:23:20 <merijn> larryba: (That's what's printing them)
11:23:22 <dminuoso> read is a very very very partial function. =)
11:23:41 <merijn> larryba: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Conc.html#v:setUncaughtExceptionHandler
11:23:51 <Akii> dminuoso you're of course right
11:24:10 <merijn> larryba: Then just replace it with a handler that logs it somewhere, rather than printing where the user sees it
11:24:21 <larryba> merijn that looks to be what I want
11:25:47 <johnw> i'd like to use watchman for running brittany on Haskell files; does anyone know how to use this tool? I'm having a very hard time finding any resources on it, but it sounds like it might fit the bill nicely.
11:28:29 <larryba> just out of curiosity I tried to make it catch read too. this worked.  catchAllAndQuit action = catch (evaluate . force =<< action) reportAndExit
11:29:24 <larryba> but I think that is not something that would be needed if catchAllAndQuit was used around entire body of main? 
11:32:00 <dminuoso> merijn: Regarding commutative applicative functors, this is a prime example of why Applicative hides the true nature with the baked-in `($)` behavior.
11:33:00 <merijn> dminuoso: Wrong person, probably? :p
11:33:07 <dminuoso> Oh yes! I meant mniip.
11:33:17 <dminuoso> merijn: Too many people starting with `m` in this channel, my mind was wired wrong.
11:34:20 <ph88> how can i do hGetLine on two handles at the same time? because i want to process some data as soon as the first handle is ready which i don't know which one it will be
11:34:41 <mniip> dminuoso, well otherwise it might be fairly hard to see the connection between
11:34:43 <mniip> :t fmap
11:34:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:34:45 <mniip> :t ap
11:34:47 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:34:48 <mniip> :t (=<<)
11:34:50 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:35:12 <dminuoso> mniip: If you considered `class Functor f => Monoidal f where unit :: f a; (**) :: f a -> f b -> f (a, b)`, you could state the law as `f ** g ~= g ** f` 
11:35:34 <mniip> yeah sure
11:35:43 <mniip> I am very familiar with the classical CT formulation
11:35:48 <Solonarv> ph88: there might be a select() equivalent somewhere?
11:35:53 <mniip> also you want  unit :: f ()
11:36:13 <dminuoso> Ops yeah, that was a slip on my part.
11:36:20 --- mode: glguy set +v joeldx
11:36:26 <joeldx> Hi,
11:36:27 <ph88> Solonarv, equivalent to what ?
11:36:48 <mniip> dminuoso, I'm mostly struggling with covariant powerset these days
11:36:52 <Solonarv> ph88: a Haskell equivalent to the C function select()
11:36:56 <mniip> it has some obvious not obvious properties
11:36:56 <ph88> ah
11:37:10 <koala_man> ph88: do you want to process two independent streams concurrently, or do you want to get the first and then cancel the other?
11:37:53 <ph88> koala_man, read from stdout and stderr handle line by line write to buffer as soon as one completes a line. Don't want to cancel the other
11:37:55 <mniip> Solonarv, considering the IO management baked into the RTS you're better off by writing two forkIO (not forkOS) threads - one for each stream
11:38:22 <Solonarv> Ah, that'd work too. I thought maybe there was a select() equivalent baked into the RTS somewhere.
11:38:23 <amalloy> ph88: i see https://stackoverflow.com/q/11744527/625403
11:38:40 <koala_man> ph88: sounds like you just want forkIO then. afaik it'll essentially use select() for scheduling
11:38:53 <merijn> Solonarv: Yes, it's called threads :p
11:39:02 <Solonarv> heh
11:39:06 <joeldx> Problem: Using the http.client library, I think i understood how to build a request using let req = parseUrl; What I am struggling with is in encapsulating the request in a function, such that it has type String -> String -> m Request, where the two strings might be the url field/ parameters passed in the body
11:39:21 <koala_man> ph88: is it the same buffer by the way?
11:39:51 <merijn> Solonarv: The RTS uses select/kqueue/epoll to block/schedule threads waiting for IO
11:40:05 <mniip> yeah hopefully not select
11:41:07 <ph88> koala_man, o dpm
11:41:14 <ph88> i don't think i will be using the same buffer
11:41:19 <ph88> premature enter there :P
11:41:39 <koala_man> ok. if you were going to merge them, you wouldn't have to go through this
11:43:12 <ph88> koala_man, merge ?
11:43:26 <ph88> i don't know .. i'm looking at the hGetLine function at the moment .. i think it uses it's own buffer
11:43:33 <ski> mniip : hm, have been pondering relation between the two powerset functors as well ..
11:43:52 <koala_man> ph88: I mean if you ran a process and wanted both stdout and stderr to go to some logging buffer
11:44:06 <ph88> koala_man, i want. but line by line .. not characters mixed
11:44:44 <geekosaur> ph88,typically we have a thread for each Handle adn then use something like Chan / TChan to forward to a third thread
11:45:02 <geekosaur> you don't use select directly6, threads do that for you
11:45:26 <ph88> ok so i do forkIO for each handle and in that thread i do hGetLine and then Chan/TChan to send it to the main thread to handle results ?
11:45:27 <geekosaur> remember that forkIO threads are lightweight compared to POSIX threads; you're not incurring much overhead to do this
11:45:34 <geekosaur> eys
11:46:02 <koala_man> ph88: if you need that guarantee, sure. realistically, programs are written in such a way that 2>&1 won't make the output useless
11:46:03 <joeldx> hi again, follow up to the previous problem:
11:46:04 <merijn> ph88: You can have >10k threads on a machine >100k if you're on a server
11:46:05 <geekosaur> well, ou may want a third thread
11:46:05 <joeldx> https://codeshare.io/5omrZM
11:47:04 <geekosaur> the process may exit before or after the last write reaches your process (it's asynchronous and up to OS scheduling), you reallyw ant the thread that does waitForProcess to not also be handlingthe I/O
11:47:18 <lavalike> did I dream that the parallel package was part of the standard ghc distribution?
11:47:19 <geekosaur> especially if ou're doing an open3 type of thing (that si, also writing tot he process's stdin)
11:48:02 <merijn> lavalike: Are you maybe thinking of Data Parallel Haskell? (That was in ghc)
11:48:43 <mniip> ski, nah, my frustration was more about, they say if H is normal in G then G/H is a group since xHyH=xyHH=xyH, but what does that even mean?
11:49:27 <geekosaur> process is. neither parallel nor async is
11:54:36 <ph88> how does Control.Parallel.Strategies compare to Control.Concurrent ?
11:55:00 <merijn> They're entirely different thing, so...
11:55:12 <ski> mniip : hmm
11:55:17 <ph88> i never understood how they were so different
11:55:33 <ski> one is for concurrency, the other for parallelism
11:55:59 <mniip> ski, the notation xHyH itself relies on the fact that group multiplication, when lifted through covariant powerset, remains associative
11:56:32 <elben> I'm trying to convert my stack projects to nix, but for whatever reason my data-files are not being transferred to the new build. I suppose my problem is from cabal and not nix. `stack build` would produce the data-files in the local build directory, but cabal `new-build` (ran in the nix-shell) does not spit out the data-files that I need. Here is my cabal file: https://github.com/elben/pong-wars/blob/nix/pong-wars.cabal (and cabal
11:56:32 <elben> 2nix conversion: https://github.com/elben/pong-wars/blob/nix/pong-wars.nix) and my terminal output: https://gist.github.com/elben/f712e9d91475fc5749085faa6e10738a . Am I misusing cabal somehow? I started this project using stack, and it's worked there.
11:57:37 <kmelva> Why does OpenGL package use StateVar? Why not just keep everythin in IO,what StateVar brings?
11:57:40 <geekosaur> @where parconc
11:57:40 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
11:58:59 <Solonarv> StateVar *is* in IO
11:59:00 <geekosaur> kmelva, "keep everything in IO" says nohting abut how you keep it in IO. StateVar is about that "how"
11:59:04 <c_wraith> elben: are you using the Paths module? see http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
11:59:12 <ski> mniip : hm, i heard something about that, recently, i think
11:59:47 <mniip> ski, the liftA2 theorem?
11:59:50 <kmelva> geekosaur: hm, still not getting it :). I'm using OpenGLRaw, and I 'keep in it in IO' by just writing functions in IO?
12:00:19 <geekosaur> it's a convenient shorthand for managing state in IO
12:00:26 <Solonarv> well yes, OpenGL is supposed to be a "higher-level" layer over OpenGLRaw
12:00:27 <geekosaur> yes, you an do it by hand. it's a pain.
12:00:50 <Solonarv> StateVar just packages up getWhatever and setWhatever into one first-class value
12:01:00 <lavalike> merijn: I thought I didn't need to install parallel the last time I wanted to see if parMap helped me, but that may be because I already had parallel installed for some other reason, so it was never part of ghc's installed modules?
12:01:03 <kmelva> I'm just about few thousand lines in OpenGLRaw, but no pain so far :)
12:01:27 <kmelva> guess I'll have to find a simple example or something... 
12:01:37 <Solonarv> TBH I'm finding OpenGL harder to use than OpenGLRaw... which is entirely due to documentation
12:01:55 <elben> c_wraith: I do use `getDataFileName ` from the Paths_ module in my code. I don't create my own like that blog post suggests. My problem is that cabal build (and new-build) is not including my data-files files in the package
12:02:32 <kmelva> Solonarv: yeah, I can follow any old OpenGL tutorial and follow along with OpenGLRaw... and I actually understand what's going on :)
12:02:50 <sm> johnw: I don't know watchman.. it looks relatively complicated. I can vouch for http://eradman.com/entrproject/
12:02:59 <kmelva> sure, things probably change as the app grows... but so far so good
12:03:28 <Solonarv> Exactly. OpenGL is just different enough from the C API that the C documentation isn't very useful, and not documented enough to figure out how to use it directly
12:03:30 <c_wraith> elben: what do you mean by "in the package"?
12:04:08 <Solonarv> ...it doesn't help that in OpenGL, functions and their types are frequently split across 4+ modules
12:04:46 <elben> c_wraith: hmm ok, i think i'm mistaken. when I cat the cabal-generated Paths_pong_wars.hs, I do see a datadir variable defined, and my data files are indeed in the path specified there. So I think my program is not running for some other reason... (It was crashing with the cabal build, and I assumed it had to do with missing data files since i dind't see it in the local `dist-newstyle` folder
12:08:40 <sm> johnw: ls *.hs | entr brittany --write-mode=inplace *.hs
12:09:50 <johnw> sm: i think watchman isn't playing well with direnv (which I use to enter and exit nix-shell environments)
12:10:07 <sm> I'm not too surprised
12:11:07 <sm> it might be great, I just don't know why it's so massive compared to the other file watching tools
12:11:17 <johnw> me either
12:11:25 <johnw> I finally found docs in markdown format in their source tree
12:12:30 * sm is reading https://facebook.github.io/watchman/
12:15:13 <ph88> how can i find out of the handle is still open/readable and then read a line with https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:hGetLine ? maybe after i check if it's still readable and the actual read it's being closed by another thread.
12:15:36 <ph88> this function throws an exception so it's safer to use https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-IO-Handle.html#v:hGetLine 
12:15:58 <Solonarv> The function from bytestring should throw as well
12:16:26 <ph88> ok
12:16:39 <ph88> strange it's not in the docs o_O
12:17:29 <Solonarv> ah, I'm wrong - it seems to not throw
12:20:35 <geekosaur> ph88, don't read from multiple threads
12:20:41 <geekosaur> you get zero guarantees
12:21:04 <geekosaur> inclduing that fi it' a stream, youdont' kbnow which thread gets which data
12:21:14 <geekosaur> because there is no concept of message. nto even a line.
12:21:30 <Solonarv> ph88's use case has each thread reading from its own handle
12:21:34 <ph88> i'm only reading from one thread for each handle
12:21:58 <ph88> i'm just wondering how i should close the handles
12:22:08 <ph88> and how i signal to the reading thread in time that it's closed
12:22:21 <ph88> should i close the handles first or should i wait for the process to finish first
12:22:58 <geekosaur> neither. let each thread read and close at its EOF. separate thread waits for process
12:23:10 <geekosaur> theOS is asynchronus, there is no guarantee what order any of them happens in
12:23:33 <ph88> if i use this function how can i detect that EOF ? https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:hGetLine
12:24:15 <Solonarv> I think you want to use hGetSome instead
12:24:17 <ph88> will it just return an empty ByteString if EOF is reached ? or will it be an empty line by the output .. i don't know
12:24:26 <ph88> Solonarv, and then find lines myself ?
12:24:57 <Solonarv> Yes
12:25:17 <ph88> o_O
12:25:44 <amalloy> ph88: http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#g:11
12:25:56 <geekosaur> hGetLine throws isEOFError wt ed of file
12:25:59 <geekosaur> at end
12:26:19 <Solonarv> the one from bytestring?
12:26:58 <geekosaur> what else would it do?
12:27:25 <geekosaur> it's not IO (Maybe String), its only option at EOF is to throw
12:28:22 <Tuplanolla> It could return garbage in true C fashion.
12:28:40 <Solonarv> It could even return empty, or block forever
12:28:42 <amalloy> geekosaur: it could obviously return an empty string, or make up any other string that it likes. that sounds like a bad idea, but so does throwing an exception without documenting it
12:29:42 <geekosaur> this, sadly, is par. but I defautl to System.IO docs in that case and isEOFError is docd there
12:29:48 <amalloy> (hGetLine in System.IO documents the exception, but the one in bytestring doesn't)
12:31:12 <Solonarv> geekosaur: that doesn't help when you're looking at a different function
12:31:57 <geekosaur> I cannot speak to why theByteString maintainers did it
12:32:23 <geekosaur> sadly Isuspect a lot of this stuff dates from when it was ripped outof ghc
12:33:10 <seishun> :t groupBy ((==) `on` fst)
12:33:12 <lambdabot> Eq a => [(a, b)] -> [[(a, b)]]
12:33:20 <seishun> is this an idiomatic way to group by first element of tuple?
12:33:59 <mniip> ski, I wonder if a quotient set can be thought of as subset^op
12:35:04 <Tuplanolla> :t groupBy (comparing fst) -- You could do this, but with `==`, seishun.
12:35:05 <lambdabot> error:
12:35:05 <lambdabot>     • Couldn't match type ‘Ordering’ with ‘Bool’
12:35:05 <lambdabot>       Expected type: (a, b) -> (a, b) -> Bool
12:35:23 <seishun> I tried that too
12:35:30 <geekosaur> :t equating
12:35:31 <lambdabot> error: Variable not in scope: equating
12:35:32 <mniip> Tuplanolla, yeah there isn't a shortcut for 'on (==)'
12:35:34 <geekosaur> ah well
12:43:23 --- mode: glguy set +v [sterni]
12:43:51 <[sterni]> hello everybody..just a question.. did anybody know nevergreen...?
12:50:48 <johnw> is that related to Haskell? I haven't heard of it
12:50:48 <[sterni]> hm...
12:51:07 <[sterni]> it's a person...just asking..sorry
12:55:44 --- mode: glguy set +v tharuk
12:57:15 <ski> mniip : not sure what "the `liftA2' theorem" is
12:57:34 <ski> mniip : how would that quotient as subset^op work ?
12:59:38 <mniip> ski, see near the bottom in https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#t:Applicative
13:00:14 <mniip> if forall x y z, p (q x y) z = f x (g y z),  then  liftA2 p (liftA2 q x y) z = liftA2 f x (liftA2 g y z)
13:02:23 <Solonarv> it's a more general form of 'if (<>) is associative, then liftA2 (<>) is also associativ'
13:03:49 <[sterni]> sorry for interrupting... bye
13:10:06 <elben> I tried to blow away my nix installation (/nix, ~/.cabal/) to reinstall everything. Now I get this error when trying to build a nix project: "ghc: can't find a package database at /Users/myusername/.cabal/store/ghc-8.4.4/package.db". What is suppose to be generating these cabal package dbs?
13:10:59 <ACheesyName> say I have two state machines, A and B. one has function transitionA :: A -> Data.Aeson.Value -> (A, Data.Aeson.Value) and the other has transitionB :: B -> Data.Aeson.Value -> (B, Data.Aeson.Value). now I want to write a function that can import a list of state machines and run their transition functions independently of their types. is this possible in haskell? I don't need the ultimate in performance I just want something th
13:14:08 --- mode: glguy set +v atz
13:14:47 <AfC> ACheesyName: what's the type of the list?
13:15:55 <ACheesyName> well that would be one problem I'm stumped on hence the question
13:16:50 * hackage hw-mquery 0.1.0.3 - Monadic query DSL  http://hackage.haskell.org/package/hw-mquery-0.1.0.3 (haskellworks)
13:16:52 <ACheesyName> one idea that comes to mind is to implement a type representing the union of A and B
13:17:05 <ACheesyName> as in C's union types
13:17:16 <Solonarv> have you thought about Either?
13:17:22 <ACheesyName> a bunch of maybe's and only one active
13:17:50 <ski> ok
13:18:50 <ski> (and no, that was not what i had heard about lifting algebraic laws to subsets)
13:19:43 <oo_miguel> I created a project via stack new/stack setup and the .cabal file seems to be derived from the package.yaml. Do I need to add my dependencies to both of them?
13:20:18 <kadoban> oo_miguel: Typically you'd just edit package.yaml and allow the cabal file to be generated
13:20:43 <merijn> package.yaml is unrelated to stack, that's related to hpack (which stack uses by default)
13:20:54 <Solonarv> Or delete package.yaml and just edit the cabal file
13:21:12 <Solonarv> I'd recommend that approach
13:21:17 <merijn> oo_miguel: I would personally recommend not relying on hpack, just use the .cabal file and stack.yaml without "package.yaml"
13:22:27 <Solonarv> seconded
13:22:52 <oo_miguel> doany from the stack commands take this package.yaml file into account or change it? (beside the initial creation)
13:22:58 <oo_miguel> do any*
13:23:12 <Solonarv> stack build and all the related commands
13:23:20 <merijn> oo_miguel: Stack just calls hpack to generate the cabal file from package.yaml and then uses the cabal file
13:23:41 <Solonarv> But I think if the .cabal file is newer it won't be overwritten
13:23:42 <oo_miguel> I adapted the cabal file ONLY and build seemd *NOT* to refresh it anymore
13:23:49 <oo_miguel> Solonarv: ah allright
13:23:53 <Solonarv> Ah, seems I'm right
13:24:14 <MarcelineVQ> Yes, if you edit the cabal file it won't overwrite it anymore, it should also warn you of that though iirc
13:24:52 <oo_miguel> MarcelineVQ: oops it warns me indeed. missed that message
13:25:38 <Solonarv> If you're not going to use package.yaml I would recommend deleting it
13:25:46 <oo_miguel> It even suggests what you guys told me. that I can simply delete the package.yaml... 
13:25:48 <MarcelineVQ> I would also reccomend not using package.yaml for now, if you're still learning about cabal files. If you understand how to use a cabal file then there's no harm in learning package.yaml as well.
13:25:57 <oo_miguel> I will do that now. thank you everybody
13:27:51 <merijn> MarcelineVQ, oo_miguel: Note of dissent to MarcelineVQ: I think package.yaml is actively harmful to use, even if you do understand cabal as it means your repo isn't buildable by others without them installing extra tooling (hpack)
13:29:29 <oo_miguel> merijn: makes sense. I will just revert to package.yaml if I need some of its features I can not get without it (I assume there are any :P )
13:29:33 <MarcelineVQ> It would be my own practice to include the cabal file instead of the package.yaml when sharing but I can see how that wouldn't be the general default of people
13:30:04 <geekosaur> actually it provides nothing,it's a way to create simple cabal files in yaml syntax
13:30:06 <MarcelineVQ> oo_miguel: there are none, it's just a slightly more convenient way to specify a file
13:30:12 <geekosaur> go beyond what it does and you need the caba file
13:30:24 <Solonarv> package.yaml is a specification for generating a blah.cabal, so it is impossible for it to support a feature that cabal doesn't
13:31:50 * hackage mismi-p 0.0.3 - A commmon prelude for the mismi project.  http://hackage.haskell.org/package/mismi-p-0.0.3 (nhibberd)
13:32:13 <merijn> MarcelineVQ: Right, but then you need to maintain two files, rather than just 1 file :p
13:33:20 <merijn> oo_miguel: There were some things with shared blocks of properties across multiple build targets, but cabal now supports those too, so AFAICT there's nothing package.yaml adds that .cabal can't do
13:33:21 * hackage mismi-s3 0.0.3, mismi-s3-core 0.0.3, mismi-core 0.0.3, mismi-kernel 0.0.3 (nhibberd)
13:33:28 <merijn> Anyhoo...time for me to call it a night...
13:34:29 <Solonarv> There is one convenience thing hpack supports that cabal doesn't (yet): not having to list all your modules explicitly
13:36:11 <MarcelineVQ> Of which that specific feature contains a bug I've had to help 3 people with hehe, related to using the same src dir for different stanzas confusing the main-is: section. Which isn't a good idea anyway though
13:37:07 <MarcelineVQ> specifically it was this or a version of it https://github.com/sol/hpack/issues/344
13:52:20 <__monty__> Doesn't cabal as shebang interpreter help with that? Anything small enough to warrant not bothering listing the dependencies is probably small enough to fit a single "script," right?
13:52:40 <__monty__> I know nix-shell as shebang helps with the issue either way.
13:53:04 <AfC> oo_miguel: to answer your original question, no you only need to edit package.yaml and next time you run `stack build` (it will run hpack and) it will regenerate your thing.cabal file.
13:53:27 <__monty__> Hmm, no, you still list them explicitly for nix-shell, just don't need a cabal project set up.
13:53:56 <AfC> It's quite transparent and easy to use. We've adopted it quite widely and are really happy with it atm.
13:57:31 <Solonarv> cabal-as-shebang is not actually documented and I'm not sure how well itworks
13:58:19 <Solonarv> ...at least I can't recall seeing it even mentioned in the online docs
13:59:39 * hackage mstate 0.2.8 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2.8 (NilsSchweinsberg)
14:12:40 <zzach> Unable to compile the hackage package zmqat-0.2.0.0 . Diffculty is to find an appropriate options module. ghc compiler says that Module Options does not export Pattern(..) . What options package has to be included?
14:13:24 <coldpress> is there any way to avoid the EmptyCase pragma? i can't find pragma notes in the GHC 7.8.x migration guide
14:15:15 <mniip> zzach, sounds like they didn't include Options in other-modules in their cabal file
14:15:27 <mniip> and it didn't get added to the sdist tarball when uploading to hackage
14:15:33 <mniip> cf https://github.com/k0ral/zmqat/blob/master/src/Options.hs
14:17:50 <zzach> @mnilp: Thanks for pointing to the Options.hs file in the zmqat distribution (there is also another hackage package options, giving of course errors).
14:17:50 <lambdabot> Unknown command, try @list
14:18:28 <zzach> mnilp, thanks for pointing to the Options.hs file in the zmqat distribution (there is also another hackage package options, giving of course errors).
14:18:56 <DigitalKiwi> try tab complete usernames
14:18:57 <Solonarv> coldpress: define "avoid". You can always write 'x `seq` case x of _ -> error "impossible"', but 'case x of {}' is much shorter
14:21:10 <coldpress> Solonarv: thank you! which class does the "avoid" function belong to?
14:21:51 <Solonarv> Huh?
14:22:07 <Solonarv> Which 'avoid' function are you talking about?
14:22:43 <coldpress> oh you meant "avoid" as in error "impossible"?
14:22:54 <geekosaur> you asked how to _avoid_ the extesion..
14:23:23 <Solonarv> Indeed.
14:23:40 <coldpress> ah i see
14:36:08 <zzach> mnilp: zmqat compilation now working, thanks very much.
14:41:07 --- mode: glguy set +v mreh
14:41:23 --- mode: glguy set -v mreh
14:48:40 <mreh> hmm, does ghcid work with bracket?
14:49:50 <mreh> it might be when I kill my docker container actually, it says it's shutting it down, but clearly the ghcid process doesn't have time to cleanup, as I've still got .lock files around when I restart
14:54:12 <AfC> mreh: yes it does ... mostly
14:55:30 <AfC> mreh: I sometimes get stale (or worse 100% spinning) ghc processes, but that was correlated with a nasty deadlock I was troubleshooting.
14:56:25 <mreh> AfC: it seems fine when it's reloading, but shutting down it doesn't work at all
14:56:50 <mreh> it's quite possible the process is being terminated immediately though
14:58:40 <mreh> using acid-state I've gained all the convenience of using Haskell data structures but lost all the convenience of having handy tools to browse my data
14:59:15 <mreh> I might have to spin up a remote instance that I can query while my app runs
15:07:09 <xelxebar> Hello, Haskell. Hope you all had an enjoyable Christmas
15:10:05 <Rembane> 'twas legendary.
15:10:51 * hackage hw-mquery 0.2.0.0 - Monadic query DSL  http://hackage.haskell.org/package/hw-mquery-0.2.0.0 (haskellworks)
15:11:41 <xelxebar> I'm trying to figure out a nice/natural/elegant way to represent graphs. After floundering around a good bit with my own newbie thoughts and getting nowhere fast, I went ahead and consulted the web. This led me to Martin Erwig's "Inductive Graphs and Functional Graph Algorithms" which I'm looking at now.
15:12:34 <Solonarv> there's an algebraic graphs library, xelxebar
15:12:52 <Solonarv> @hackage algebraic-graphs
15:12:52 <lambdabot> http://hackage.haskell.org/package/algebraic-graphs
15:13:24 <xelxebar> Solonarv: Excellent. I'll take a look at that. Thanks!
15:14:29 <xelxebar> Is there anything else I should look at? It's mainly for my own pedagogy.
15:14:54 <xelxebar> Rembane: legendary? How so??
15:14:55 <Solonarv> I'm not super familiar with graphs, so that's the only library I'm aware of
15:15:01 <Tuplanolla> Haskell doesn't have a strong corpus of graph theory packages.
15:17:17 <xelxebar> That very fact gives me a fuzzy feeling that there's a good mathematical reason why...
15:17:21 <Rembane> xelxebar: I shovelled tons of snow and solved some advent of code challenges. 
15:17:52 <Rembane> xelxebar: Have you read Erwig's paper?
15:18:42 <Tuplanolla> The reason is that trying to match BGL would take tens of thousands of man hours.
15:20:26 <Rembane> Or maybe all the classical graph algorithms are very imperative in their nature.
15:21:22 <xelxebar> I just discovered the paper and thought I'd bother you guys before diving in
15:21:55 <lavalike> Rembane: that sounds legendary indeed
15:22:57 <Rembane> lavalike: ^^ my legends are small, like Tao koans.
15:22:58 <Tuplanolla> It also seems that graph theory is a big and ugly theory with a poorly organized metatheory, just like real analysis.
15:23:07 <mniip> graphs are an inherently dysfunctional data structure
15:23:43 <Rembane> mniip: Interesting, why? 
15:24:22 <mniip> with any efficient representation, they aren't functionally mutable
15:24:26 <mniip> you have to rebuild the whole
15:24:42 <xelxebar> Tuplanolla: How are graphs with cycles actually dealt with in practice? algebraic-graphs, some BGL wrapper, some other problem-specific, less elegant datatype?
15:25:14 --- mode: glguy set -v higherorder
15:25:16 <mniip> Rembane, much like a doubly linked list
15:25:55 <Rembane> mniip: I didn't really think of that until now. Interesting! 
15:26:16 <Rembane> mniip: So graphs are like a doubly linked list but worse?
15:26:40 <mniip> yes
15:28:08 <mniip> you can build something monstrous like a map of sets
15:28:26 <mniip> but that just shows how both of those structures are better and more functional than graphs
15:28:28 <Tuplanolla> With a set of index mappings, usually, xelxebar.
15:29:22 <Solonarv> xelxebar: in algebraic-graphs, I think 'overlay (connect a b) (connect b a)' should work?
15:29:47 <Rembane> mniip: Can you use the graph algorithms by using those better data structures?
15:30:11 <Solonarv> Rembane: graph algorithms are independent of the underlying implementation, they are defined in terms of graph operations
15:30:48 <mniip> Rembane, with logarithmic everything
15:31:24 <mniip> logarithmic edge test, insertion, deletion etc
15:31:58 <DigitalKiwi> BGL == boost graph library?
15:31:59 <Solonarv> I think there's a paper somewhere saying that purely-functional data structures can't be better than logarithmic
15:32:13 <Tuplanolla> Yes, DigitalKiwi.
15:32:20 <DigitalKiwi> thank
15:33:05 <mniip> Solonarv, yeah you can't implement an array with better than logarithmic access
15:33:19 <mniip> and a graph can be abused as that
15:33:47 <mniip> it's really simple
15:33:50 <Solonarv> Of course, if you have non-purely-functional primitives you can get better than logarithmic perf for for some operations :>
15:34:03 <mniip> all constructors have a fixed arity
15:34:23 <Solonarv> Oh, duh! that's a really intuitive reason
15:34:56 <Tuplanolla> All this graph talk reminds me of a question I never found an answer to. Can you fuse the Boyer--Myrvold test with edge insertion to obtain node and edge insertion with amortized constant time complexity?
15:35:50 <Rembane> mniip, Solonarv: Sweet! Thank you! 
15:36:00 <Solonarv> Do you have a link to the paper? I really want to read it now
15:36:02 <Tuplanolla> (I guess logarithmic is fine too.)
15:36:18 <MarcelineVQ> mniip, Solonarv: pardon me but what does constructor arity tell you about the logarithmic (complexity?) you're talking about currently?
15:36:35 <mniip> of course, for all practical purposes, log n < 50 or so
15:36:35 <binq_> https://stackoverflow.com/questions/53950118/templatehaskell-seems-to-not-be-reporting-what-function-it-needs-to-be-imported
15:36:36 <larryba> @pl (\e -> f e >> return undefined)
15:36:36 <lambdabot> (>> return undefined) . f
15:36:55 <binq_> anybody have any idea why the following is happening: https://stackoverflow.com/questions/53950118/templatehaskell-seems-to-not-be-reporting-what-function-it-needs-to-be-imported
15:37:23 <Solonarv> larryba: even easier: (undefined <$) . f
15:37:26 <mniip> MarcelineVQ, refocusing from a data structure to one of its constituent parts takes constant time
15:37:56 <larryba> thanks
15:37:56 <mniip> MarcelineVQ, if you have a finite number of data constructors, with n being the maximum arity along those,
15:38:20 <mniip> you can only fit n^k items into a datastructure such that any item can be accessed in k time
15:38:39 <mniip> therefore if you store m items, best you can do to access them is log_n m
15:39:59 <Solonarv> Is that result from Chris Okasaki's thesis?
15:40:01 <MarcelineVQ> I believe I follow that, thank you mniip
15:40:27 <mniip> Solonarv, I came up with that independently a while ago
15:40:36 <mniip> never actually formalized the proof until 5 minutes ago
15:40:55 <Solonarv> Fair enough, it s pretty simple once you come up with it
15:41:10 <mniip> yeah
15:42:37 <larryba> what do you think of this? code looks a bit sketchy, particularly return undefined part. it seems safe, though
15:42:47 <larryba> https://pastebin.com/MWZzLs36
15:44:20 <mniip> why the return undefined
15:44:23 <mniip> why not return ()
15:44:29 <larryba> types don't match
15:44:35 <larryba> :t catch
15:44:36 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
15:45:05 <mniip> you want to void inside the 'try' part
15:45:10 <mniip> not outside the whole catch
15:45:47 <larryba> oh, good point
15:46:14 <ski> larryba : "it seems safe" -- if the resulting `()' is forced, you'll get an error
15:46:23 <Solonarv> try this: catch (evaluate . rnf =<< action) userReport
15:46:43 <larryba> ski doesn't void $ take care of that?
15:47:08 <ski> hm, you're right
15:47:25 <Solonarv> Still messy and unnecessary
15:47:30 <larryba> mniip's version is nicer obviously, but mine doesn't seem unsafe
15:47:32 <ski> (but not if you move the `void' into the first argument, but not the second)
15:47:41 <Solonarv> Use 'rnf'
15:48:06 <Solonarv> It is exactly the function meaning "fully evaluate the argument and then return ()"
15:48:11 <_deepfire> lyxia: another PR:  https://github.com/Lysxia/type-map/pull/8
15:48:13 <Solonarv> also: don't catch SomeException
15:48:17 <hpc> basically it avoids having to tiptoe around that function in the future, since it "looks" fully defined
15:49:03 <larryba> Solonarv, what should I catch instead? the point of this function is to catch all errors
15:49:34 <Solonarv> Leave it polymorphic. If you really do want to catch *all* errors, you can always specialize to SomeException.
15:49:35 <ski>   reportErrors userReport = handle userReport (evaluate . rnf =<<)
15:50:04 <ski> (er, also with an extra `.')
15:50:09 <larryba> so something like this? reportErrors :: (Exception e, NFData a) => (e -> IO ()) -> IO a -> IO ()
15:50:24 <Solonarv> Looks about right
15:50:31 <Solonarv> Give me a minute to type up a gist
15:50:44 <larryba> maybe even reportErrors :: (Exception e, NFData a) => (e -> IO b) -> IO a -> IO b
15:50:51 <larryba> but I'm not sure when that would be useful
15:51:51 <larryba> ski looks good
15:52:04 <Solonarv> No, that doesn't work - if no exception is thrown, it can't return a value
15:52:17 <larryba> ah, yes
15:53:47 <Solonarv> larryba: https://gist.github.com/Solonarv/04642ee8351ff8af775582bbb7bb2818
15:56:48 <larryba> Solonarv cool. I also have ignoreErrors :: NFData a =>  IO a -> IO (), I'm not sure 100 how to let user decide what exceptions are caught. accept a dummy argument, and then do something like undefined :: ExceptionType?
15:57:11 <Solonarv> The modern answer is: use TypeApplications
15:58:30 <zachk> Solonarv, what are typeApplications?
15:58:38 <Solonarv> for example, 'forceCatch @ErrorCall printAndSwallowError whatever'
15:58:52 <Solonarv> zachk: the '@ErrorCall' part of my above example
15:59:08 <Solonarv> It's enabled by the TypeApplications language extension 
15:59:39 <Solonarv> Basically, it lets you explicitly specialize a polymorphic type
16:00:21 * ski would like to be able to say `id @a (x :: a9
16:00:21 <Solonarv> % let { forceCatch :: (Exception e, NFData a) => (e -> IO ()) -> IO a -> IO (); forceCatch handler a = catch (evaluate . rnf =<< a) handler }
16:00:22 <yahb> Solonarv: ; <interactive>:21:35: error:; Not in scope: type constructor or class `NFData'; Perhaps you meant `Data' (imported from Data.Data)
16:00:33 * ski would like to be able to say `id @a (x :: a) :: a = x'
16:00:48 <Solonarv> % let { forceCatch :: (Exception e, NFData a) => (e -> IO ()) -> IO a -> IO (); forceCatch handler a = catch (evaluate . rnf =<< a) handler }
16:00:49 <yahb> Solonarv: 
16:00:55 <Solonarv> % :t forceCatch
16:00:55 <yahb> Solonarv: (Exception e, NFData a) => (e -> IO ()) -> IO a -> IO ()
16:01:06 <c_wraith> ski: pretty sure Rich Eisenberg has proposed that
16:01:13 <Solonarv> % :t forceCatch @ErrorCall
16:01:13 <yahb> Solonarv: NFData a => (ErrorCall -> IO ()) -> IO a -> IO ()
16:01:30 <ski> c_wraith : without requiring a type signature ?
16:01:41 <c_wraith> https://github.com/ghc-proposals/ghc-proposals/pull/155
16:01:52 <c_wraith> it's specifically about lambdas
16:02:04 <Solonarv> % forceCatch print (return (0/0 :: Rational))
16:02:05 <yahb> Solonarv: ; <interactive>:27:1: error:; * Ambiguous type variable `a0' arising from a use of `forceCatch'; prevents the constraint `(Exception a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Exception Dynamic -- Defined in `Data.Dynamic'; instance [safe] Exception Void -- Defined in `Data.
16:02:07 <c_wraith> But if it's added, it probably would cover non-lambda bindings too
16:02:25 <Solonarv> % forceCatch @ArithException print (return (0/0 :: Rational))
16:02:26 <yahb> Solonarv: Ratio has zero denominator
16:02:45 <larryba> Solonarv, @ErrorCall fills in first constraint, in this case `e'?
16:02:49 <c_wraith> ski: oh.  the first comment covers exactly that.
16:03:06 <larryba> > fmap @Maybe
16:03:08 <lambdabot>  error:
16:03:08 <lambdabot>      Pattern syntax in expression context: fmap@Maybe
16:03:08 <lambdabot>      Did you mean to enable TypeApplications?
16:05:20 <Solonarv> larryba: precisely
16:05:47 <larryba> neat
16:05:51 <Solonarv> more specifically, it fills in the first type variable - doesn't have to be a constraint
16:06:01 <Solonarv> % :t map @Int
16:06:02 <yahb> Solonarv: (Int -> b) -> [Int] -> [b]
16:06:08 <Solonarv> % :t map
16:06:08 <yahb> Solonarv: (a -> b) -> [a] -> [b]
16:06:10 <larryba> how would it work with ignoreErrors, though? there's no Exception e there. so I still have to take a dummy argument? ignoreErrors :: NFData a =>  IO a -> IO ()
16:08:03 <Solonarv> In that case you'd write its signature as 'ignoreErrors :: forall e a. (Exception e, NFData a) => IO a -> IO ()'
16:08:25 <Solonarv> (you need the AllowAmbiguousTypes extension to allow that)
16:17:22 <larryba> signature worked (I had to add RankNTypes). but now I'm not sure how to propagate exception constraint to forceCatch? ignoreErrors = forceCatch (const $ return ())
16:17:30 <larryba> * Could not deduce (Exception b0)  arising from a use of `forceCatch'
16:19:42 <geekosaur> AllowAmbiguousTypes mroe or less requires TypeApplications, I think?
16:20:28 <c_wraith> Not always.  The extension existed before TypeApplications, so someone must have had *some* use for it.
16:20:53 <Solonarv> larryba: you need a type application in the body
16:21:17 <Solonarv> i.e. 'forceCatch @e (const (pure ()))'
16:21:33 <Solonarv> You may need to turn on ScopedTypeVariables so that 'e' is in scope
16:22:28 <larryba> that worked!
16:23:42 <Solonarv> TypeApplications + AllowAmbigousTypes + ScopedTypeVariables are really nice to use together :D
16:29:24 <larryba> I like TypeApplications. a lot nicer than writing entire signature
16:37:59 <Solonarv> Or vomiting (Proxy :: Proxy blah) all over the place
16:42:05 <infinisil> Agreed ^^
16:44:27 <Solonarv> it even makes Proxy-vomit a bit less painful, since you can write (Proxy @blah) instead
17:07:44 <sososasa> I have a simple function which is giving me an ambiguous type error. Why might be the problem?
17:07:45 <sososasa> https://gist.github.com/samanShresthaRay/0dc50a450787b65a6a92b114a88b84ad
17:09:42 <sososasa> Whenever we supply a non-empty list, things work fine but and empty list is causing error
17:09:52 <geekosaur> because it doesn't know what typeof list
17:10:24 <geekosaur> if it hs elements, it can infer the type; with the example, it sees Num a => a and uses defaulting to get Integer
17:10:56 <Solonarv> The solution is to fix the type somehow. The Haskell98 way is to add a type ascription, for example ([] :: [()]) instead of a bare []
17:11:30 <geekosaur> also ghci has ExtendedDefaultRules enabled and would infer a ~ ()
17:11:37 <sososasa> Can we make it general? For instance, make it work from [Char] and [Int] both
17:11:48 <geekosaur> (dot turn that on in programs unless you want to deal with unexpected types)
17:11:52 <geekosaur> it will work for both
17:12:06 <Solonarv> It already works for any type of list, that's *why* the type is ambiguous
17:12:09 <geekosaur> the actual *specific* use needs to know what type to sue *there*
17:12:37 <sososasa> geekosaur++
17:12:43 <sososasa> Solonarv++
17:12:46 <geekosaur> but you can tel it any type because it's polymorphic. youmust tell it which type
17:13:11 <Solonarv> small tip: 'putStrLn $ show blah' can be written 'print blah'
17:14:42 <sososasa> That fixed it
17:15:27 <geekosaur> you can alsoavodi this with:   default (Integer, Double, ())
17:16:04 <sososasa> where should we define this?
17:16:04 <Solonarv> (this is a top-level declaration)
17:16:08 <geekosaur> but now type inference may unexpectedly give you () and an easy to diagnose type error can become a harder one in a distant place in your program
17:16:19 <Solonarv> The usual location is right below all your imports
17:16:24 <geekosaur> by conventon it'dbe up at the top
17:16:52 <geekosaur> rightma fter the imports. doesn't have to be there btu that kind of thing should be specified up front so people reading the source know it ahead of time
17:17:29 <sososasa> So default (Integer, Double, ()) is saying that if the type is ambiguous then just default it to either Integer, Double or Empty?
17:17:49 <Solonarv> (), not Empty - but yes
17:17:54 <geekosaur> it tries each in order untl it typechecks
17:17:55 <sososasa> OK
17:18:25 <geekosaur> the default default is (Integer, Double) which is why saying '2+ 3' in ghci doesn't throw a type error
17:18:43 <Solonarv> (actually, GHCi has slightly more general defaulting, no?)
17:18:54 <geekosaur> yes, I mentioned ExtendedDefaultRules
17:19:00 <geekosaur> which does that and more
17:19:17 <geekosaur> including loosening up type inference around various tyepclasses
17:19:48 <geekosaur> it also adds lists to the default for Foldable
17:22:21 <sososasa> SOlonarv, geekosaur: so the compiler throws another error when I define default. It says The default type ‘()’ is not an instance of ‘Num’
17:22:40 <Solonarv> ah, you may need ExtendedDefaultRules for that to be legal?
17:22:51 <geekosaur> I thought not. hm.
17:23:09 * geekosaur pokes
17:23:34 <geekosaur> (slowly... network sucks today)
17:24:16 <sososasa> {-# LANGUAGE ExtendedDefaultRules #-} is the way to go
17:24:55 <geekosaur> yeh, it'll just make for even more confusing type errors on typos/thinkos
17:25:06 <geekosaur> its off in programs as opposed to ghci for a reason
17:25:59 <geekosaur> in particular the default for Foldable means what would be easily diagnosed type errors can explode randomly as the inferred type is only detected to be wrong somewhere else
17:26:32 <geekosaur> defaulting + type inference has kinda nasty action-at-a-distance 
17:27:01 <sososasa> So how should I code this to make it more general? AND not use {-# LANGUAGE ExtendedDefaultRules #-}
17:27:16 <geekosaur> aain, it is alreadyegenral. that is the problem
17:27:56 <geekosaur> haskell will always require use sites to be fully typed, if you have something that is fully polymorphic it can't figure out a type for itself
17:28:17 <geekosaur> so being too general has costs, just as being too specific has costs
17:30:01 <geekosaur> ah, sadly youdo need ExtendedDefautlRules for that defautl decl
17:30:09 <geekosaur> but that gets you all the other stuff as well
17:30:21 <geekosaur> this should probably be more granular
17:30:34 <sososasa> so I am looking at the other possible solutions and this one has no problems:
17:30:39 <sososasa> elementAt :: [a] -> Int -> aelementAt list i    = list !! (i-1)
17:30:55 <sososasa> elementAt :: [a] -> Int -> a
17:31:03 <sososasa> elementAt list i    = list !! (i-1)
17:31:10 <sososasa> forget the first line
17:31:47 <sososasa> we dont even need to use {-# LANGUAGE ExtendedDefaultRules #-}. Why may that be?
17:34:29 <Solonarv> I don't know, your example is insufficient
17:34:50 <Solonarv> defaulting kicks in when you *use* a polymorphic function, not when you define it
17:34:59 <Solonarv> Here you simply defined one.
17:35:34 <sososasa> Hold on. I will put a gist.github link to better explain
17:37:04 <sososasa> https://gist.github.com/samanShresthaRay/0dc50a450787b65a6a92b114a88b84ad
17:40:24 <Solonarv> As I said, the ambiguity here comes from the *use site*. elementAt' isn't actually used anywhere, so obviously there can't be any ambiguous use sites.
18:38:18 <remexre> is there something like the lens (.=), (+=), etc., but allow me to keep track of what parts of the data structure were read from/written to in some way?
18:41:34 <c_wraith> remexre: that's not something lens has any way of doing.
18:41:52 <remexre> is there something similar that does?
18:42:45 <c_wraith> I can envision building such a system, but it would have to work pretty differently from how lens works
18:43:11 <c_wraith> Can you just do some sort of checkpoint/diff system?
18:43:20 <remexre> I need to keep track of what gets read, too
18:46:05 <c_wraith> ah, I see.  I wrote a system somewhat like that for doing testing once.  It's something you can do, but it's *very* different from how lens works.  You need to actually reify your accessors, not just use an implicit encoding as functions.
18:46:24 <c_wraith> The whole thing needs to be a lot less generic, much more wedded to the data representation
18:48:10 <remexre> I'll try that then, thanks
19:07:38 --- mode: glguy set +v Ulbrec
19:20:51 <skamalc> #ubuntu
19:45:01 <ACheesyName> my first infinite list function: https://repl.it/repls/OnlyUnpleasantAutocad . code review please?
19:54:40 <Arahael> So.. Yesterday I asked for easy ways to iterate over a complex AST, and discussions initially recomended just pattern matching - which I rejected and then we discussed generics and the like.
19:54:53 <Arahael> Turns out pattern matching - boring pattern matching - is remarkably good.
19:55:14 <notzmv> true
20:00:10 <c_wraith> Arahael, it's true!
20:00:48 <c_wraith> also, everything else has to. boil down to pattern matching the AST eventually anyway.
20:01:36 <Arahael> Indeed.
20:13:21 <dmj`> nobody is too good for pattern matching
20:14:54 <MarcelineVQ> maybe some people are, either that or they're bools. hmmm, not quite...
20:21:35 <geekosaur> which is pattern matching in candy wrappers anyway
20:25:59 <Arahael> MarcelineVQ: They could also be *nothing*.
20:29:46 <monochrom> Haha great.
21:30:16 <dmwit> ACheesyName: Hm? I see no infinite list there.
21:33:42 <ACheesyName> dmwit: sorry I had reused the repl. I just put the infinite list back
21:35:41 <dmwit> too many parens =)
21:36:17 <dmwit> Also the concept of the code smells. Generally if you're doing lots of splitting you are either really expert and doing something super clever, or a novice and haven't yet understood how to do randomness in Haskell.
21:38:09 <dmwit> (Another syntactic complaint: you might like to learn about the "as" clause that can go in an import statement. e.g. `import System.Random as Rand` or similar, and then you can do `Rand.RandomGen` and `Rand.split` instead of the longer `System.Random.RandomGen` and `System.Random.split`.)
21:41:10 <dmwit> :t unfoldr
21:41:11 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
21:42:07 <zenspider> halp: https://gist.github.com/zenspider/208eb2e92eab7b432961eb436da4ac61#file-19-prof-L66-L111
21:42:09 <zenspider> and: https://github.com/SeaRbSg/advent_of_code/blob/master/zenspider/2018/19.hs
21:42:26 <dmwit> :t \f -> unfoldr (Just . first f . split)
21:42:27 <lambdabot> error:
21:42:27 <lambdabot>     • Couldn't match type ‘(b, Splitter a1)’ with ‘[a1] -> [[a1]]’
21:42:27 <lambdabot>       Expected type: ([a1] -> [[a1]]) -> (a, Splitter a1)
21:42:37 <dmwit> :t \f -> unfoldr (Just . first f . System.Random.split)
21:42:38 <lambdabot> RandomGen g => (g -> a) -> g -> [a]
21:42:42 <zenspider> I'm trying to figure out how to force calls to happen so the parse phase is DONE before the execution phase. I think this is really slowing my code down
21:43:05 <dmwit> ACheesyName: ^ =)
21:43:11 <ACheesyName> wow
21:46:03 <dmwit> ACheesyName: But I think `\f -> unfoldr (Just . f)` is more likely to be what you should actually be using: take a function which uses a StdGen in the idiomatic way and returns both a "random" output value and an updated StdGen.
21:46:08 <dmwit> :t \f -> unfoldr (Just . f)
21:46:09 <lambdabot> (a1 -> (a2, a1)) -> a1 -> [a2]
21:46:45 <dmwit> Specifically, (\f -> unfoldr (Just . f)) :: (StdGen -> (a, StdGen)) -> StdGen -> [a]
21:47:20 <dmwit> Typically the `f` you supply this will will call things like `random` and `randomR`, not `split`.
21:47:37 <ACheesyName> sure
21:54:27 <dmwit> :t unfoldr.(Just.) -- y tho
21:54:28 <lambdabot> (b -> (a, b)) -> b -> [a]
23:03:22 <johnw> does anyone know how to force -j1 when running tasty with defaultMain
23:11:05 <osa1> johnw: I think you need to set this option: http://hackage.haskell.org/package/tasty-1.2/docs/Test-Tasty-Runners.html#t:NumThreads
23:11:23 <johnw> yes, I just can't figure out how to actually do that...
23:11:31 <johnw> I can make an OptionSet containing that option
23:11:37 <johnw> but that doesn't give me an Ingredient
23:11:44 <osa1> johnw: http://hackage.haskell.org/package/tasty-1.2/docs/Test-Tasty.html#v:adjustOption
23:12:40 <osa1> so `defaultMain (adjustOption ... tests)`
23:12:52 <johnw> ah, thanks
23:17:01 <johnw> defaultMain $ localOption (NumThreads 3) $ testTree ...
