00:00:05 <jle`> > 9 + (3 * 4)
00:00:07 <lambdabot>  21
00:02:46 <jle`> 'push 3, push 4, pop-2-and-*, push 9, pop-2-and-+'
00:06:40 <nfd> Probably isn't the right place to ask, but I'm trying to install taffybar with stack and it's failing at the contents of a package stack is convinced i do have installed
00:07:38 <nfd> https://hastebin.com/luratozowi.coffeescript
00:07:53 <suzu> whats the error?
00:08:11 <nfd> that file should be supplied by gi-cairo, which stack is convinced is installed
00:08:26 <nfd> in fact, it was installed higher up in the stack dependencies
00:08:49 <nfd> suzu: that pastebin work?
00:17:38 <suzu> do you know what version stack thinks it installed?
00:19:12 <nfd> gi-cairo-1.0.17
00:20:16 <nfd> the version i found on git is 1.0.18; I'd doubt that this would've been added in a minor bump
00:21:18 <nfd> in fact, i'm now sure it's been there since 1.0.16
00:22:47 <nfd> Wasn't changed since
00:24:12 <suzu> hmm idk :(
00:38:23 <energizer> how do you write a thunk?
00:40:21 <Ariakenom_> cemerick: did you do a perf comparison against Float vs Double for https://github.com/cemerick/silly-shootout/blob/63c6d1c385c532725e7051156ddd380047ff1e17/Bench.hs ?
00:43:39 <energizer> oh that was easy
00:46:59 <dminuoso> energizer: thunks are not something "you write", but something that GHC generates.
00:47:28 <dminuoso> energizer: In particular it is a way how GHC represents suspended evaluation.
00:48:36 <energizer> dminuoso: what i meant is `f x g = x`
00:48:54 <tdammers> you could say that you "write a thunk" by writing an expression that involves non-strict evaluation semantics
00:49:11 <tdammers> but that's not really helpful
00:49:27 <dminuoso> Also it's not very correct with respect to potential code transformations.
00:49:34 <tdammers> true
00:49:46 <tdammers> thunks are pretty much a transparent implementation detail
00:49:57 <Ariakenom> [0..] is how you write a thunk
00:50:15 <tdammers> the whole point is that you don't need to know whether an expression has been evaluated yet, until you need its value
00:50:20 <suzu> \_ -> is how you write a thunk
00:50:27 <suzu> everything is thunked though
00:50:28 <dminuoso> suzu: No, that's just a function.
00:50:43 <suzu> er yeah thats true
00:50:48 <suzu> \_ -> is a thunk in an eager language
00:50:52 <dminuoso> energizer: In Haskell when we say "thunk" we tend to mean the representation GHC choses to implement lazy evaluation.
00:51:18 <energizer> dminuoso: i see
00:51:50 <tdammers> let x = 1 + 1 in (x, x)
00:51:52 <suzu> the closest you can get to manipulating them is boxed and unboxed values
00:51:58 <suzu> afaik
00:52:11 <tdammers> before you evaluate the (x, x) part, x is probably going to be bound to a thunk
00:53:00 <tdammers> and after you have evaluated the expression fully, all the thunks in that expression will have been resolved
00:53:04 <dminuoso> Or, if ski was here, they'd point out that Haskell does not have lazy evaluation, but rather non-strict semantics.
00:53:14 <tdammers> but what happens in between is at least partially at the compiler's discretion
00:53:19 <dminuoso> So thunks are GHC's way of implementing non-strict semantics.
00:53:35 <dminuoso> Which happens to give us lazy evaluation.
00:53:55 <dminuoso> The difference being that there are other ways to implement non-strict semantics.
00:55:21 <Ariakenom> tdammers: if the number type is polymorphic in your case ghc has to make a thunk I'd think
00:55:52 <Ariakenom> well something non-strict I suppose
00:56:45 <tdammers> Ariakenom: when I said "evaluate fully", I was assuming that completely resolving all the types to be monomorphic would be part of it.
00:57:06 <tdammers> > print (let x = 1 + 1 in (x, x) :: (Int, Int))
00:57:08 <lambdabot>  <IO ()>
00:57:10 <tdammers> something like that
00:57:34 <suzu> why is that in angled brackets?
00:57:42 <tdammers> that's a lambdabotism
00:57:52 <tdammers> lambdabot doesn't run IO actions
00:58:02 <suzu> i see
00:58:13 <tdammers> so when you hand it something that evaluates to IO something, it'll just dump the type in angle brackets
00:58:26 <tdammers> > show (let x = 1 + 1 in (x, x) :: (Int, Int))
00:58:28 <lambdabot>  "(2,2)"
00:58:29 <dminuoso> > show getLIne
00:58:31 <lambdabot>  error:
00:58:31 <lambdabot>      • Variable not in scope: getLIne :: ()
00:58:31 <lambdabot>      • Perhaps you meant one of these:
00:58:33 <dminuoso> > show getLine
00:58:35 <lambdabot>  "<IO [Char]>"
00:58:40 <Ariakenom> % print (let x = 1 + 1 in (x, x)
00:58:40 <yahb> Ariakenom: ; <interactive>:39:31: error: parse error (possibly incorrect indentation or mismatched brackets)
00:58:45 <Ariakenom> % print (let x = 1 + 1 in (x, x))
00:58:45 <yahb> Ariakenom: (2,2)
00:58:53 <dminuoso> suzu: ^- so it seems that lambdabot has an instance Show a => Show (IO a)
00:59:10 <dminuoso> And it just `show`s IO actions. 
00:59:22 <dminuoso> Sadly being morally incorrect.
00:59:54 <tdammers> ghci is also morally incorrect in that regard, though in a different way
00:59:59 <dminuoso> Or wait, `instance Show (IO a)` in fact, possibly with some reflection constraint in the way
01:00:08 <dminuoso> tdammers: What way is that
01:00:25 <tdammers> it special-cases IO actions
01:01:42 <tdammers> and then it special-cases IO () actions within that special case
01:01:58 <tdammers> as a result, "hello" and print "hello" produce the exact same output
01:02:14 <tdammers> but (print "hello" >> return 1) prints two lines
01:02:36 <tdammers> (print "hello" >> return ()) however only prints the "hello" line
01:02:46 <dminuoso> Ohh right.
01:02:58 <tdammers> convenient, but not still morally incorrect
01:03:06 <tdammers> s/not //
01:03:20 <dminuoso> tdammers: Im just sad that `Show` is abused so wildly to not do Show-like things. :(
01:03:24 <Ariakenom> % (print "hello" >> return ())
01:03:25 <yahb> Ariakenom: "hello"
01:03:26 <dminuoso> Like pretty printing.
01:03:27 <Ariakenom> (print "hello" >> return 1)
01:03:32 <Ariakenom> % (print "hello" >> return 1)
01:03:32 <yahb> Ariakenom: "hello"; 1
01:03:48 <dminuoso> But then again, the fault may lie with the name of the class.
01:06:18 <dminuoso> `show` is a kind of `reflect` whereas `read` is a kind of `reify`
01:07:52 <Ariakenom> . o O (rewrite Generic to work only via strings)
01:08:11 <day> if i have two lists of lists called x and y and i want to pass each element of these two lists to a function, how do i do that? i was thinking "mapM func x y"
01:08:59 <dminuoso> Ariakenom: I wonder, are there types that cannot have Show/Read but Generic?
01:09:03 <dminuoso> Sensibly I mean.
01:09:40 <day> aside from it not working im also not sure how mapM would know thta i want [0] [0], [1] [1] as opposed to [0] [0], [0] [1]  
01:10:02 <Solonarv> Anything with a field that's a function? (or, in fact, anything non-showable)
01:10:20 <dminuoso> Oh.
01:11:12 <Ariakenom> day: zipWith (+) [1,2,3] [4,5]
01:11:19 <Ariakenom> % zipWith (+) [1,2,3] [4,5] -- day
01:11:20 <yahb> Ariakenom: [5,7]
01:11:46 <Ariakenom> % zipWith (++) ["1","2","3"] ["a","b"]
01:11:46 <yahb> Ariakenom: ["1a","2b"]
01:11:55 <dminuoso> > getZipList ((*) <$> ZipList [1,2,3] <*> ZipList [3,4,5])
01:11:57 <lambdabot>  [3,8,15]
01:12:38 <dminuoso> This would work more easily for the general case I guess.
01:17:42 <day> > zipWith (++) [1,2] [3,4]
01:17:44 <lambdabot>  error:
01:17:44 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_11234’
01:17:44 <lambdabot>      • In the expression: e_11234
01:17:52 <energizer> foldl seems similar to python's reduce, but curried i guess?
01:18:27 <jle`> all "multi-argument" functions are curried :0
01:18:30 <jle`> :)
01:18:40 <jle`> as a cultural thing
01:18:57 <energizer> other than the fact that it's curried, is it the same as reduce?
01:19:00 <jle`> if you're comparing foldl :: (b -> a -> b) -> b -> [a] -> b, vs. foldl :: (b -> a -> b, b, [a]) -> b
01:19:09 <jle`> the former is curried, the latter is uncurried
01:19:16 <jle`> there are some differences
01:19:46 <jle`> reduce is closer to foldr1 or foldl1
01:20:07 <jle`> i think in spirit it's closer to foldr than foldl
01:20:26 * hackage fedora-dists 1.0.0.2 - Library for Fedora distribution versions  http://hackage.haskell.org/package/fedora-dists-1.0.0.2 (JensPetersen)
01:20:39 <jle`> but it could maybe be interpreted as closer to foldl too
01:20:48 <jle`> i guess it depends on how you interpret it
01:20:58 <jle`> actually, i should just check
01:21:47 <jle`> the way it's introduced here, http://book.pythontips.com/en/latest/map_filter.html#reduce
01:21:56 <jle`> is basically foldl', yes
01:22:15 <jle`> foldl would be the explicit loop
01:23:01 <jle`> foldl' basically abstracts over an imperative alogorithm: you (1) initialize your accumulator, (2) step through each item in the list and aggregate the item into the accumulator, (3) return the final result
01:23:17 <jle`> reduce is a little more muddled, because mainly there's no "initialization" involved in reduce
01:23:37 <energizer> reduce has an optional third argument that's placed before the other items if present
01:24:20 <energizer> https://docs.python.org/3/library/functools.html#functools.reduce
01:24:55 <jle`> ah, thanks for linking to actual docs, i was trying to find them :)
01:26:08 <jle`> i think then, yes, reduce with an initializer is closest in spirit to foldl'
01:26:59 <energizer> cool. thanks
01:27:00 <jle`> but the docs have some ambiguity: it says that the initializer is placed "before the items of the sequence in the calculation"
01:27:18 <jle`> if this is true, then this would make it different from foldl, and closer to foldl1
01:27:33 <jle`> in foldl, the initializer isn't added to the sequence, it's treated as the initialization value for the accumulator
01:27:52 <jle`> so it's never involved in the sequence, so you get some different semantics in some situations
01:27:55 * hackage blas-ffi 0.1 - Auto-generated interface to Fortran BLAS  http://hackage.haskell.org/package/blas-ffi-0.1 (HenningThielemann)
01:28:29 <jle`> so i think, if anything, reduce would be closest to `foldl1` in haskell, not `foldl`.  reduce-with-initializer would be foldl1 + cons
01:28:38 <jle`> the difference is subtle
01:29:12 <energizer> alright
01:29:30 <jle`> so as a broad general sense, "reduce" is similar, in the spirit of what it is meant to do, to "foldl".  but on the actual detail level of implementation and technicalities in semantics, it's closer to foldl1
01:30:20 <jle`> the difference is that the initializer in foldl is treated as a separate value that is never a part of the list, but the analogous initializer in foldl1 would be treated as a part of the list, pre-pendended before you start reducing
01:30:59 <jle`> the latter seems to be what the documentation suggests that reduce does
01:31:24 --- mode: glguy set +v checkinn
01:31:56 <jle`> > foldl1 (+) [1..10]
01:31:58 <lambdabot>  55
01:32:03 <jle`> ^ energizer 
01:32:22 <jle`> foldl1 treats the initial item in the list as the initial state of the accumulator
01:32:54 <jle`> and implementing reduce-with-initailizer would be like: foldl1 (+) (initializer:[1..10])  <- initializer is added to the start of the list
01:32:57 <energizer> mhmm
01:34:08 <jle`> the main practical difference in Haskell is that foldl lets your accumulator have a different type than the items in the list
01:34:41 <jle`> since with foldl, your accumulator is always going to have the same type as the items in the lists, since all lists hare homogeneous, and so the first item in the list has the same type as every other item in the list
01:35:28 <jle`> but in python, lists are heterogeneous, so the analogy is not so straightforward
01:35:46 <jle`> *since with foldl, 
01:36:16 <energizer> in the "roughly equivalent" code snippet in the docs, it shows it's never actually added to the list (not that really makes a difference in python)
01:37:14 <energizer> just instead of doing the first loop on the first element of the list, it does it on the initializer
01:41:01 <dminuoso> energizer: there's one important difference: and that has to do with non-strict semantics.
01:41:10 <jhrcek> Does haskell syntax make it possible to combine "import X (x)" and "import X hiding (y)" into single import statement?
01:43:16 <dminuoso> jhrcek: Nope.
01:45:02 <dminuoso> jhrcek: Refer to "5.3 Import Declaration" in https://www.haskell.org/definition/haskell2010.pdf to get a concise answer as to what import statements may look like
01:49:12 <jhrcek> dminuoso: That's useful. Thank you :)
01:50:03 --- mode: glguy set +v mreh
01:57:55 * hackage path-io 1.4.1 - Interface to ‘directory’ package for users of ‘path’  http://hackage.haskell.org/package/path-io-1.4.1 (mrkkrp)
01:59:03 <dminuoso> % import from Prelude hiding ()
01:59:03 <yahb> dminuoso: ; <interactive>:59:8: error: parse error on input `from'
01:59:13 <dminuoso> % import Prelude hiding ()
01:59:14 <yahb> dminuoso: 
02:09:35 --- mode: glguy set +v rawca
02:10:31 --- mode: glguy set +v cr0d
02:10:32 <cr0d> And stumbled upon the sentence: 
02:10:38 <cr0d> `:module supports the * modifier on modules, which opens the full top-level scope of a module, rather than just its exports.`
02:10:57 <cr0d> What's the difference between opening the "full-top level scope" and exporting?
02:17:45 <dminuoso> cr0d: A module might not export every top level identifier.
02:31:49 <dminuoso> Does `Text` have an underlying ByteString?
02:40:44 <Solonarv> dminuoso: no. Text is backed by a ByteArray#, ByteString is backed by a ForeignPtr Word8.
02:41:23 <Solonarv> However ShortByteString is also backed by a ByteArray#
02:43:07 <Solonarv> (I found this out by checking the source for Text and ByteString)
02:43:09 <dminuoso> Mmm. I guess Ill store my secrets in a ByteString then, it seems easier to encode a worst constant-time equality on that.
02:43:22 <dminuoso> Rather than fiddling around with some ByteArray# I know nothing about.
02:45:36 <nyc> What makes a ByteArray# different from a ForeignPtr Word8?
02:47:26 <Solonarv> I don't know GHC internals well enough to answer with more than this: what makes an Int different from a Char?
02:47:29 <dminuoso> nyc: ByteString allows me to chop off one byte at a time with `unsafeHead/unsafeTail`. I have absolutely *no* clue what those do with Text.
02:48:15 <dminuoso> A quick glance suggests it's not constant-time.
02:48:40 <dminuoso> Solonarv: Do you happen to know from the top off your head whether I could access that ByteArray# through some interface?
02:49:17 <Solonarv> Not at all. The only things I know about ByteArray# are guesses based on its name
02:49:28 <dminuoso> Fair enough, thanks for the help though.
02:49:40 <Solonarv> (i.e. it's a contiguous array of bytes, and it's primitive/wired-in)
02:49:45 <Ariakenom> nyc: I'd tihnk ByteArray# is moved normally by GC while the foreign is not
02:50:32 <dminuoso> Guess Ill stick to storing secrets in ByteString, at least I can access that trivially and reason about it.
02:51:00 <dminuoso> Or I could just use String *shrugs*
02:51:44 --- mode: glguy set +v wacckzacck
02:52:04 <Ariakenom> dminuoso: what properties are you looking for?
02:52:31 <dminuoso> Ariakenom: Constant worst-time equality.
02:53:21 <Solonarv> I'm not sure *any* byte-array-like structure can offer that
02:53:31 <Ariakenom> Could you elaborate?
02:53:54 <dminuoso> Solonarv: https://gist.github.com/dminuoso/124b3c9d49fabd9566128fe78d1629d8
02:54:29 <Solonarv> I mean... what exactly is this meant to be constant with respect to?
02:55:06 <dminuoso> Solonarv: So imagine you are just testing a user supplied secret against a stored secret.
02:55:10 --- mode: glguy set +v nickednamed
02:55:32 * Solonarv nods along
02:56:23 <dminuoso> Solonarv: So efficient attempts might reject comparing "aab" against "aac" earlier than say comparing "xyz" against "abc".
02:56:56 <Solonarv> Oh!
02:57:09 <Solonarv> I thought you meant "O(1) worst-case performance"
02:57:26 <Solonarv> but actually you meant "always hits the 'worst-case' performance"?
02:57:34 <dminuoso> Yeah.
02:57:49 <Ariakenom> Ya that's what I parsed as well
02:57:54 <dminuoso> Sorry about that =)
02:57:54 <Solonarv> Ah, so you just want to not fast-path to ward off timing attacks. Makes sense.
02:58:10 <dminuoso> Yeah. I mean I could also use something like Argon2..
02:58:25 <dminuoso> And then rely on naive equality.
02:58:49 <Ariakenom> actually getting the same time you need to go below assembly though ... to figure out how long things take based on actual values
02:59:26 <Ariakenom> ex xor 0 0 may be faster others
02:59:58 <Solonarv> Right, the CPU might throw fast-path-shaped wrenches at you... but that's not a field where I know more than "it exists"
03:00:27 <dminuoso> Ariakenom: in fact `xor 0 0` is a guaranteed "faster than others" on modern intel chips.
03:00:34 <dminuoso> Or no ..
03:00:37 <dminuoso> `xor eax eax` is =P
03:00:44 <dminuoso> Sorry. Brain too slow.
03:03:00 <dminuoso> Ariakenom, Solonarv: But yeah... I guess there's too many reasons not to be naive and use Argon2.
03:03:28 <dminuoso> "Turn the timing attack problem into an already solved cryptographic problem"
03:05:45 <Solonarv> When it comes to crypto I do advocate not rolling your own.
03:06:01 <Solonarv> (this does not come from a place of confidence - I know very little about crypto)
03:07:05 <dmwit> Comparing text for equality correctly is pretty hard in its own right, even if you don't care about timing attacks.
03:07:42 <Solonarv> It's a lot easier if you're comparing ASCII or binary blobs.
03:08:54 <dmwit> If you know you're doing that, then yes, absolutely use ByteString and not Text.
03:09:14 <dmwit> dminuoso: You might also like http://hackage.haskell.org/package/securemem-0.1.10/docs/Data-SecureMem.html
03:10:32 <dminuoso> dmwit: Mm its an interesting primitive. It seems unsuitable for my current needs, but it's something I should bookmark for the future. :)
04:35:28 <Ariakenom> dminuoso: yes I almost said something about xor eax eax there
04:36:32 <Ariakenom> just couldn't formulate anything related before I had to go
04:41:23 <day> why is haskell returning this type? [([1,2],[5,6])] :: (Num t1, Num t) => [([t], [t1])]
04:41:25 * hackage keystore 0.8.1.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.8.1.1 (ChrisDornan)
04:41:35 <day> why is it not [([t], [t])] ?
04:42:07 <Solonarv> why would it be?
04:42:19 <day> both are the same type
04:42:22 <Ariakenom> > (1,2) -- day
04:42:24 <lambdabot>  (1,2)
04:42:24 <Ariakenom> :t (1,2) -- day
04:42:25 <lambdabot> (Num b, Num a) => (a, b)
04:42:29 <Ariakenom> sry meant the type
04:42:39 <Ariakenom> do you get why those are different day?
04:42:54 <Solonarv> while they're certainly allowed to be the same, they don't have to be
04:45:17 <dmwit> day: How do you know both are the same type?
04:48:26 <day> dmwit: i figured it out. my function is supposed to get ([Integer],[Integer]). if you ask the question in reverse i agree they can differ
04:48:45 <day> but for w/e reason my definition didnt work, which it now does
04:59:59 <jollygood2> is it possible to check version of some package in ghci? (I am using stack if it matters)
05:01:05 <Solonarv> in ghci? no, not as far as I know.
05:02:01 <jollygood2> so how do I check? I can dig through .stack-work directory, but there's probably a better way?
05:02:02 <hpc> probably import Paths_nameofpackage
05:02:32 <Solonarv> if you go to https://stackage.org/YOUR_RESOLVER_HERE there's a list of all the packages in that snapshot
05:02:36 <hpc> stack uses the version you explicitly pick, if it's outside of LTS
05:02:44 <hpc> or whatever is in the LTS you picked
05:03:11 <Solonarv> If you added the package as an extra-dep you presumably already specified a version
05:03:48 <jollygood2> I didn't add it, it is in LTS. there's no way to check this without visiting stackage page? that is even worse than looking .stack-work directory (it requires internet connection, and their website working)
05:04:31 <Ariakenom> Hey, is Float slower than Double? I saw a 20x slowdown when I did a brief test.
05:04:42 <Solonarv> The file desribing the snapshot should also be somewhere in ~/.stack, but I'm not sure where exactly
05:05:11 <jollygood2> what if I wasn't using stack? how would I check? maybe same method works
05:05:48 <Solonarv> If you aren't using stack, you're probably using cabal, and the usual practice there is to specify a version yourself
05:07:03 <hpc> if you are using stack, you should still also be usinng cabal
05:07:15 <hpc> (stack.yaml and packagename.cabal instead of package.yaml)
05:07:26 <jollygood2> if I pulled lens it also pulled 50+ other packages. I may specify version of the lens, but not version of other 50+
05:07:53 <hpc> Ariakenom: depends on the cpu, but i wouldn't be surprised
05:08:06 <hpc> float is a pretty garbage type
05:08:17 <Solonarv> If you've used 'cabal new-freeze' to pin dependency versions, the versions are recorded in a file named cabal.project.freeze
05:08:18 <Ariakenom> hpc: I was thinking 20x had to be due to ghc
05:08:45 <hpc> it's probably a combination of things
05:09:13 <Solonarv> You can ask cabal to calculate a set of working bounds with 'cabal gen-bounds'
05:09:16 <hpc> float instructions being maybe slower than doubles, not being able to make as convenient of optimizations
05:09:34 <jollygood2> it is weird that this information isn't accessible in ghci. it loaded the package, it should know its version
05:09:37 <hpc> maybe with doubles you're getting simd where with floats you aren't
05:10:32 <hpc> jollygood2: packaging is more of a build-time concept than a runtime concept
05:10:52 <jollygood2> :show packages
05:11:32 <jollygood2> above works! lists all the loaded packages, and their versions. just accidentally stumbled upon it
05:11:59 <Solonarv> oh, heh - that solves it
05:14:15 <jollygood2> yeah, it worked. and  I am unfortunately using latest version of pdf-toolbox-document, which chokes on the document I have to parse. any other recommendations for converting pdf to text, so I can parse the document with Parsec?
05:28:25 <Solonarv> pandoc?
05:28:47 <Solonarv> jollygood2: ^
05:29:54 <jollygood2> thanks. I'll try it
05:34:26 <jollygood2> in Parsec, is there a case-insensitive `string' equivalent?
05:38:24 --- mode: glguy set +v Flyers
05:43:47 <jollygood2> caseInsensitiveChar c = char (toLower c) <|> char (toUpper c)
05:45:01 <jollygood2> caseInsensitiveString = mapM caseInsensitiveChar
05:45:13 <merijn> That's...not going to be very efficient
05:46:51 <jollygood2> can it be any more efficient?
05:46:55 * hackage aws-lambda-haskell-runtime 1.0.5 - Haskell runtime for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.0.5 (NickSeagull)
05:51:00 * hackage radius 0.6.0.0 - Remote Authentication Dial In User Service (RADIUS)  http://hackage.haskell.org/package/radius-0.6.0.0 (erick)
05:58:25 * hackage eventsource-store-specs 1.2.1 - Provides common test specification for Store implementation.  http://hackage.haskell.org/package/eventsource-store-specs-1.2.1 (YorickLaupa)
05:58:55 * hackage eventsource-stub-store 1.1.1 - An in-memory stub store implementation.  http://hackage.haskell.org/package/eventsource-stub-store-1.1.1 (YorickLaupa)
06:16:04 <dminuoso> :t GHC.Generics.to
06:16:05 <lambdabot> GHC.Generics.Generic a => GHC.Generics.Rep a x -> a
06:16:14 <dminuoso> What's with that second type parameter for `Rep`? What is that for?
06:48:07 --- mode: glguy set +v Y_Sharoda
06:50:49 <Y_Sharoda> Hello, I am working with template haskell trying to generate an instance of class 
06:50:51 <Y_Sharoda> class TUnfold t where     tunfold :: t a -> [a]
06:50:55 <Y_Sharoda> for the type 
06:51:04 <Y_Sharoda> data Rec2 a = MkRec2 { c0 :: a, c1 :: a} deriving (Show, Eq)
06:51:29 <Y_Sharoda> The instance should look like: 
06:51:30 <Y_Sharoda> instance TUnfold Rec2 where     tunfold (MkRec2 x y) = [x,y]
06:51:55 * hackage skip-var 0.1.0.0 - Skip variables  http://hackage.haskell.org/package/skip-var-0.1.0.0 (dtaskoff)
06:51:56 <Y_Sharoda> I use the following template haskell code 
06:52:09 <Y_Sharoda> genInst_TUnfold :: Name -> DecsQ genInst_TUnfold name = do    TyConI (DataD _ _ _ _ [RecC conName fields] _) <- reify name    x <- newName "x"     y <- newName "y"    return $ [InstanceD Nothing [] (ConT name)                        [FunD ('tunfold) $ [Clause [ConP conName [VarP x,VarP y]]                                                    (NormalB $ ListE [VarE x,VarE y]) [] ]]] 
06:53:16 <Y_Sharoda> but when I call it using $(genInst_TUnfold ''Rec2)
06:53:43 <Y_Sharoda> I get error: Expecting one more argument to ‘Rec2’        Expected a constraint, but ‘Rec2’ has kind ‘* -> *’
06:53:43 <lyxia> Y_Sharoda: can you paste your code in https://gist.github.com
06:55:55 * hackage th-abstraction 0.2.9.0 - Nicer interface for reified information about data types  http://hackage.haskell.org/package/th-abstraction-0.2.9.0 (ryanglscott)
07:00:03 <Y_Sharoda> lyxia: here is the link: https://gist.github.com/yasminemmagdi/2d1afb5f7c703e82b6164e2d3292227f 
07:00:45 <Y_Sharoda> loading the Tuple file gives error: Expecting one more argument to ‘Rec2’        Expected a constraint, but ‘Rec2’ has kind ‘* -> *’
07:14:02 <mniip> dminuoso, not used
07:14:11 <mniip> it's to use the same primitive TyCons in Rep1
07:14:27 <mniip> to :: Generic a => Rep a x -> a
07:14:33 <mniip> to1 :: Generic1 a => Rep1 a x -> a x
07:14:38 * hackage type-map 0.1.4.0 - Type-indexed maps  http://hackage.haskell.org/package/type-map-0.1.4.0 (lyxia)
07:15:21 <lyxia> Y_Sharoda: your instance at the moment is just    instance Rec2 where    but you want    instance TUnfold Rec2 where
07:15:47 <lyxia> Y_Sharoda: so line 19 should apply the type constructor TUnfold to (ConT name)
07:28:22 <Y_Sharoda> Lyxia: Thank you so much.. It is working now 
07:36:21 <byorgey> ski, merijn: I didn't see the context but I saw ski mention an example of a commutative but not associative binary operation.  Almost any symmetric function of 2 arguments works; associativity is pretty special.
07:36:32 <byorgey> e.g. f a b = a^2 + b^2
07:36:56 --- mode: glguy set +v Flyers
07:36:56 --- mode: glguy set -v Flyers
07:39:08 --- mode: glguy set +v nluuu
07:44:45 <Solonarv>  - <dminuoso> What's with that second type parameter for `Rep`? What is that for?
07:45:24 <Solonarv> Something to do with re-using the same encoding for typesthat take arguments
07:47:09 --- mode: glguy set +v Ulbrec
07:51:53 <Solonarv> % :k! GHC.Generics.Rep Maybe -- dminuoso
07:51:53 <yahb> Solonarv: unknown command ':k!'; use :? for help.
07:52:05 <Solonarv> % :kind! GHC.Generics.Rep Maybe
07:52:05 <yahb> Solonarv: ; <interactive>:1:18: error:; * Expecting one more argument to `Maybe'; Expected a type, but `Maybe' has kind `* -> *'; * In the first argument of `GHC.Generics.Rep', namely `Maybe'; In the type `GHC.Generics.Rep Maybe'
07:52:47 <Solonarv> Okay, I have no idea.
08:00:10 --- mode: glguy set +v Y_Sharoda
08:05:59 <shapr> GOOD MORNING #haskell !
08:06:03 <shapr> it's a lovely day for code!
08:07:39 <tdammers> my work today so far disagrees
08:07:53 <tdammers> my parser has decided to eat input without leaving a trace
08:08:00 <tdammers> and I can't figure out how and why
08:08:07 <tdammers> guess I need better debugging skills
08:08:27 <dminuoso> Yeah, writing Haskell lets your debugging skills degrade.
08:12:49 <tdammers> damn
08:13:19 <shapr> tdammers: is your parser in Haskell?
08:13:38 <c_wraith> eh. different set of debugging skills. I'm rusty enough with haskell that I've recently been utterly baffled by a type error that was originally caused by providing the wrong type to a type constructor, followed by a correct but related type.
08:15:28 <c_wraith> it told me the correct type was wrong, and it took me 30 minutes to figure out where the incorrect type was coming from. it was especially bothersome because which one was an error should have been obvious from the context, but unification never made it that far.
08:26:25 * hackage aws-lambda-haskell-runtime 1.0.6 - Haskell runtime for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.0.6 (NickSeagull)
08:26:42 <lavalike> I've been using Debug.Trace a lot, wanna hug to death whoever implemented it
08:31:14 <Solonarv> oh it's in base? I'd thought it was in some other package!
08:32:06 <Geekingfrog> I'm experiencing a race condition when trying to pipe stdout of a subprocess to stdin of another subprocess. Demo program there: http://ix.io/1wrs
08:33:19 <Geekingfrog> It seems that if the second subprocess starts before the first one, then it doesn't wait to read from stdin and hangs forever. I'm not super familiar with supbrocesses so I may very well mess up some of the plumbing there
08:33:51 <[Leary]> % let ghettoTrace s = unsafePerformIO (s <$ print s); fac n | n == 0 = 1 | otherwise = ghettoTrace n * fac (n - 1) in fac 5
08:33:51 <yahb> [Leary]: 5; 4; 3; 2; 1; 120
08:34:54 <dmwit> Ariakenom: One time you taught me how to ask ghci `:t id @(a -> b)` (namely, use `:t id @(_ -> _)`). Follow-up problem: can I ask `:t id @(a -> a)` somehow?
08:34:59 <dmwit> This is the closest I've gotten:
08:35:03 <dmwit> % type Tmp a = a -> a
08:35:04 <yahb> dmwit: 
08:35:08 <dmwit> % :t id @(Tmp _)
08:35:09 <yahb> dmwit: Tmp w -> Tmp w
08:35:20 <dmwit> But it would be nice to have the temporary type alias expanded away in the answer.
08:35:33 <c_wraith> Geekingfrog, pipes are terrifying. what if you just make stdout from one stdin of the other
08:35:55 * hackage typed-spreadsheet 1.1.4 - Typed and composable spreadsheets  http://hackage.haskell.org/package/typed-spreadsheet-1.1.4 (GabrielGonzalez)
08:37:46 <[Leary]> % type Join f a = f a a
08:37:46 <yahb> [Leary]: 
08:37:59 <[Leary]> % :t id @(Join (->) _)
08:37:59 <yahb> [Leary]: Join (->) w -> Join (->) w
08:38:01 <Geekingfrog> c_wraith, that was my initial attempt, but I didn't find any api to do that. With typed-process, getStdout doesn't work on the created ProcessConfig
08:38:10 <[Leary]> % :t! id @(Join (->) _)
08:38:10 <yahb> [Leary]: unknown command ':t!'; use :? for help.
08:38:18 <[Leary]> % :type! id @(Join (->) _)
08:38:18 <yahb> [Leary]: unknown command ':type!'; use :? for help.
08:38:23 <[Leary]> che
08:38:26 <dmwit> You're thinking of :kind!
08:38:40 <dmwit> But it also has the same type-variable-scoping-problem that the :t query does in the first place...
08:38:41 <c_wraith> Geekingfrog, well that sounds like a bug in typed-process... 
08:39:05 <dmwit> You can forall it, but, well, I dunno. Seems like I'm bending over backwards just to ask my question in a language GHC understands.
08:39:41 <dmwit> % :kind! forall w. Tmp w -> Tmp w
08:39:42 <yahb> dmwit: forall w. Tmp w -> Tmp w :: *; = Tmp w -> Tmp w
08:40:04 <dmwit> Hah! And it doesn't even expand bare type aliases. Using a type family as a fancy type alias would be a fine workaround for that, though.
08:40:16 <dmwit> % type family Tmp2 a; type instance Tmp2 a = a
08:40:17 <yahb> dmwit: 
08:40:25 <dmwit> % :kind! forall w. Tmp2 w -> Tmp2 w
08:40:25 <yahb> dmwit: forall w. Tmp2 w -> Tmp2 w :: *; = w -> w
08:40:50 <dmwit> ....typo'd my Tmp2 definition. Whatever, I feel my point is made.
08:49:04 * hackage hinterface 0.8.1 - Haskell / Erlang interoperability library  http://hackage.haskell.org/package/hinterface-0.8.1 (SvenHeyll)
08:52:26 * hackage turtle 1.5.13 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.5.13 (GabrielGonzalez)
09:43:04 <ski> byorgey : sure, "commutative" = "symmetric" here, yes ?
09:43:43 <jadrian> why is map not defined over traversable?
09:43:56 <jadrian> everything else appears to have been lifted except for map
09:44:36 <Solonarv> the correct class would Functor, and you're thinking of fmap
09:46:26 * hackage google-server-api 0.3.0.0 - Google APIs for server to server applications  http://hackage.haskell.org/package/google-server-api-0.3.0.0 (arowM)
09:46:29 <Solonarv> As to why map hasn't been generalized yet: I think it'd cause some old code to now have an ambiguous type, and so it's be rejected? something like that.
09:49:24 <jadrian> Solonarv: not really, I mean map... 
09:49:50 <dmwit> What behavior do you want that fmap does not have?
09:49:52 <Solonarv> Right, I'm not super coherent right now. Need sleep but it's too early.
09:49:55 * hackage aws-lambda-haskell-runtime 1.0.7 - Haskell runtime for AWS Lambda  http://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.0.7 (NickSeagull)
09:50:06 <MarcelineVQ> Solonarv: I've seen arguments for keeping things like map for the clearer error messages, especially in relation to teaching new people
09:50:18 <jadrian> dmwit: I was referring to map, not fmap
09:50:25 <Solonarv> dmwit: I think they were asking why map hasn't been generalized the way e.g. Foldable functions have been
09:50:53 <dmwit> Because we already had the general version available as fmap.
09:51:15 <dmwit> and, or, foldr etc. didn't have general counterparts yet.
09:51:57 <jadrian> dmwit:  right, ok hadn't thought of it like that
09:52:28 <jadrian> dmwit: when you said "we already had the general version available as fmap." I was thinking, well that applies to "map" over lists too
09:53:06 <jadrian> dmwit: but indeed we don't really need a more generic map since we have fmap but we did need folds et al
09:53:14 <jadrian> fair point
10:04:25 * hackage json 0.9.3 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.9.3 (IavorDiatchki)
10:21:58 --- mode: glguy set +v boxscapeR
10:24:09 <nan`> i have a template haskell question: is 'fail' in the Q monad supposed to make TH fail at compilation time?
10:24:20 <nan`> cuz my TH seems to be blowing right through my fails
10:24:26 <nan`> (really new to TH)
10:25:42 <glguy> Yes, it fails at compile time
10:25:47 <cocreature> nan`: I would expect it to fail at compile time but not that it fails when you use splice your TH somewhere. not if you simply define it
10:33:14 <nan`> weird it seems to blow right by my fail and any error, but if i call a function and put an error there it stops compilation
10:34:02 <cocreature> nan`: can you show us the code?
10:51:53 <kritzefitz> When I need a FIFO queue where items are inserted at the end individually and emptied all at once, is there a rule of thumb if a Sequence or a list that's reversed when needed is faster?
10:52:28 <c_wraith> kritzefitz, list is probably faster there.
10:53:05 <c_wraith> kritzefitz, Data.Sequence has notable constant factors. a single reverse on a list isn't going to outweigh them.
10:53:23 <monochrom> Rule of thumb is slower iff more featureful.
10:54:10 <kritzefitz> Okay. Thanks for the advice!
11:05:11 <nan`> https://pastebin.com/Y0ay57jF
11:05:27 <nan`> (see line with  "above fail only works if this line is uncommented")
11:06:03 <nan`> if i don't uncomment that line the fail doesn't break compilation like i want it to
11:09:14 --- mode: glguy set +v JoelMcCracken[m]
11:09:19 <monochrom> Yay actual code.
11:15:39 <day> does anyone happen to have an advent of code example for the 1st day? mine should work, it's just way to slow
11:16:22 <c_wraith> day, for part 2? are you using Data.Set?
11:16:44 <day> no im not. but i was already told to do so. just trying to understand how to 
11:17:02 <day> right now im comparing [Integer] -> Integer
11:17:21 <day> which stops working at around 10-20k iterations
11:17:43 <c_wraith> build a helper that's Set -> [Integer] -> Integer
11:18:24 <c_wraith> that should be your recursive function.
11:18:48 <c_wraith> every time you see a new element, call it with an updated Set containing that element.
11:19:30 <c_wraith> the duplicate will be somewhere between 100k and 150k elements in, depending on your data set.
11:22:08 <day> c_wraith: so i build a tree out of the elements which gets compared to the new element, which then gets added to the tree?
11:22:34 <day> i earlier read that Data.Sets are implemented with balanced binary trees
11:22:40 <cocreature> nan`: where are you calling that code?
11:22:41 <c_wraith> ... yes, but don't think about the implementation of Data.Set.
11:22:49 <c_wraith> that's just a detail.
11:22:52 <day> yeah just curious, because it's new to me
11:22:57 <cocreature> nan`: if it fails, it should fail where you splice it not in the definition
11:23:05 <c_wraith> the important part is that insert and member are efficient.
11:24:27 <koz_> day: Small nitpick - self-balancing binary trees.
11:24:29 <nan`> cocreature: https://pastebin.com/EqaHJ0Q9
11:25:25 <cocreature> nan`: what exactly are you hoping to get out of "runIO getArgs".
11:26:53 <nan`> well this is from the snap framework, i think he wants the arguments to the compiler so he can use them in the interpreter
11:27:10 <c_wraith> nan`, oh, so you're talking about my code. 
11:27:16 <c_wraith> it's an ugly hack
11:27:48 <nan`> c_wraith: i am trying to debug a problem i'm having in development mode
11:27:50 <c_wraith> but it's the only thing I found that was even close to reliable for getting the necessary compiler flags.
11:28:35 <c_wraith> everything else required things like linking to the same version of Cabal that cabal-install was built with, or other similarly untenable approaches.
11:28:38 <nan`> c_wraith: basically it says "flags: '-XHaskell98 Site Application' not recognized" if i use "Other-Modules: Site Application" in the cabal file
11:29:21 <c_wraith> nan`, I really wish ghc's argument parser was exported.
11:29:55 <nan`> somehow -XHaskell98 is being tied up with the Other-Modules
11:30:08 <nan`> as a single quoted arg
11:30:09 <c_wraith> nan`, everything I did in there is a bad attempt to guess how to parse arguments like ghc does. it's getting it wrong there. it thinks -XHaskell98 takes arguments
11:30:40 <nan`> c_wraith: yes from the groupby; i really just wanted to test development mode because it will make my work faster
11:31:04 <cocreature> hm, I’m still confused as to why "fail" doesn’t fail for you. I just tried it locally in some minimal example and it definitely does fail at compile time for me
11:31:22 <cocreature> so the only thing that I can come up with is that for some reason you are not compiling the code that splices this
11:32:03 <monochrom> Me too.
11:32:30 <c_wraith> nan`, it's been like 5 years since I dealt much with that code. I remember it just being a bundle of hacks. just keep adding hacks, unless somehow ghc eventually decides to export its argument parser.
11:33:24 <cocreature> just show that code to some GHC dev. They’ll be so disgusted that they’ll export the args parser in no time :)
11:36:49 <nan`> cocreature: it's really weird, if i add that putStrLn it fails properly
11:57:27 <day> c_wraith: trying to implement it with Data.Set. http://dpaste.com/2G50MF8 Im not quite sure how to approach it
12:00:17 <day> c_wraith: forget it. it's totally wrong
12:16:17 <ACheesyName> http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/ I'm stumped at jellybean. how could banana and unicorn ever be used to -eliminate- m? they always introduce it. can anyone give me a hint?
12:18:10 <ski> ACheesyName : `banana' both introduces and eliminates
12:18:38 <ski> (as is `jellybean' supposed to)
12:31:54 <amalloy> ACheesyName: consider that `a` might be `m c`, for some c. then banana :: (m c -> m b) -> m (m c) -> m b
12:33:30 <amalloy> someone stop me if that's misleading, but i think that's one way you could use banana to eliminate m
12:34:57 <dyl> Who puts jellybeans and bananas in their burritos?
12:48:36 <kritzefitz> When I have an attoparsec parser like this `(string "\0" <|> string "\0\0") >> string "\1"`, attoparsec apparently never tries the second alternative, but fails on "\0\0\1". Can I make it backtrack correctly for such cases?
12:48:55 * hackage amqp-worker 0.2.5 - High level functions for working with message queues  http://hackage.haskell.org/package/amqp-worker-0.2.5 (seanhess)
12:50:22 <amalloy> kritzefitz: the backtracking combinator is called `try`
12:50:44 <kritzefitz> amalloy: Yes, but I can't seem to figure out, where I have to apply it.
12:51:02 <amalloy> (try (string "\0") <|> ...)
12:51:08 <amalloy> er, no
12:51:10 <kritzefitz> Also, the documentation for try says, that attoparsec should already backtrack automatically.
12:51:51 <cocreature> if you use string "
12:51:55 <amalloy> kritzefitz: if you swapped the order of your <|>s that should be better
12:52:10 <cocreature> string "\0\1" <|> string "\0\0\1" thinks should work out properly
12:52:12 <energizer> data Shape = Circle Float Float Float | Rectangle Float Float Float Float   
12:52:34 <energizer> Are `Shape` and `Circle` both data constructors?
12:52:46 <amalloy> energizer: Circle and Rectangle are
12:52:50 <cocreature> Shape is a type
12:52:50 <geekosaur> Circle and Rectangle. Shape is the type constructor
12:53:12 <kritzefitz> amalloy: Yes, but only because my exmaple is actually too simple, for what I'm trying to do. The second alternative should be an catchall alternative that is only relevant if the first alternative fails.
12:53:19 <cocreature> kritzefitz: the backtracking that attoparsec does refers to things like a <
12:53:27 <cocreature> a <|> b where it will backtrack if a fails
12:53:35 <kritzefitz> cocreature: I see.
12:53:37 <cocreature> but if a succeeds then it won’t go back at some later point
12:54:07 <dmwit> kritzefitz: No, you must refactor your grammar.
12:54:10 <cocreature> so either swap the order or combine the strings
12:54:16 <dmwit> I, too, have been bitten by this lie in the attoparsec documentation.
12:55:13 <day> how exactly would a function need to look that takes [Integer] checks if the Int exists in a Set and if it doesnt puts it in and returns the found Int? What i managed to get is this, which isnt exactly much http://dpaste.com/3T0M6S6
12:55:46 <kritzefitz> cocreature: I'm afraid that isn't easily done in my specific case.
12:56:06 <kritzefitz> But i guess I can actually restructure my parsing at some other point to circumvent this problem entirely.
12:56:08 <dmwit> day: You will have to return both the updated Set and whatever other observation you wanted to make.
12:57:20 <dmwit> day: e.g. a type like `find :: [Integer] -> Set Integer -> Either (Set Integer) Integer` might do, where you interpret a `Left` as "it wasn't there yet, but here's the new set with it inserted" and a `Right` as "it was there already, and here it is again for you".
12:57:24 <day> dmwit: yeah i noticed it's quite annoying to make it recursive 
12:57:51 <dmwit> Or maybe something else. I don't really understand either your English description or your code sample.
12:58:14 <dmwit> (For example, you say "check if the Int exists in a Set". Which Int is *the* Int?)
12:58:17 <day> forget the code sample 
12:58:48 <day> x:xs of the passed [Integer]
12:59:15 <day> so if x isnt in the Set then add x to set rinse repeat
12:59:29 <dmwit> Are you just looking for fromList?
12:59:32 <dmwit> :t S.fromList
12:59:33 <lambdabot> Ord a => [a] -> S.Set a
12:59:50 <dmwit> :t \orig new -> S.union orig (S.fromList new)
12:59:51 <lambdabot> Ord a => S.Set a -> [a] -> S.Set a
13:00:01 <dmwit> :t \new orig -> S.union orig (S.fromList new)
13:00:03 <lambdabot> Ord a => [a] -> S.Set a -> S.Set a
13:00:14 <day> i know that one, but if i use fromList on [1,1,2,3,4] it will just write 1,2,3,4 into the set without me knowing that 1 existed twice, right?
13:00:27 <dmwit> If you want multiplicities, you don't want Set.
13:00:32 <dmwit> ?hackage multiset
13:00:33 <lambdabot> http://hackage.haskell.org/package/multiset
13:01:02 <day> no i dont want multiples. my goal is to find the multiple in a long list. im supposed to use Set because it makes the existance check fast
13:02:53 <day> existence*
13:03:21 <energizer> So Circle is just a function that takes three arguments and returns a Shape object?
13:03:28 --- mode: glguy set +v spinye[m]
13:04:01 <geekosaur> mostly. it can also be used in pattern matching to disassemble a Shape
13:04:34 <hyperisco> newtype Set a = Set [a]
13:04:45 * Solonarv_ recoils in horror
13:04:47 <energizer> geekosaur: that's what this is `surface (Circle _ _ r) = pi * r ^ 2 `
13:04:58 <geekosaur> yes
13:05:02 <energizer> ok
13:05:09 <hyperisco> instance Eq a => Eq (Set a) where (Set a) == (Set b) = nub a == nub b
13:05:17 <dmwit> day: Okay. I don't really know how to give you a hint that doesn't give away the answer.
13:05:28 <hyperisco> you can thank me later
13:05:50 * geekosaur hands hyperisco [1..]
13:06:19 <hyperisco> ah for that you want to use my unreleased group set library I was just talking about in the other channel
13:06:24 <dmwit> day: `S.member` can be used to check if a value is already in a set.
13:06:34 <dmwit> day: Then you can use if/then/else to dispatch on that.
13:06:37 <day> dmwit: that i know
13:06:38 <dmwit> :t S.member
13:06:39 <lambdabot> Ord a => a -> S.Set a -> Bool
13:06:56 <day> but how can i use S.member in conjunction with fromList?
13:07:37 <dmwit> day: Given the more detailed description of what you want to do, I don't think my previous advice applies.
13:07:50 <dmwit> day: Let that be a lesson to you about describing your goals carefully from the get-go. =)
13:08:22 <day> in case you have read it, it is about the Advent of code day 1 part 2
13:08:48 <day> well no matter where you start. you always end up missing valuable info
13:09:17 <day> but yeah sorry for the confusion
13:10:00 <hyperisco> geekosaur, if you say nice things to me I might be motivated to release it
13:10:01 <dmwit> (Or you can use `case` for a more uniform dispatch. Or guards. Or, or, or...)
13:10:22 <day> hm havent seen case yet
13:10:29 * dmwit hands geekosaur data-ordlist
13:10:55 <dmwit> day: Then use if/then/else. It's perfectly suitable. You can learn other ways once you have a first way working that you understand well.
13:11:14 <day> that was the initial idea 
13:12:58 <hyperisco> recognise me geekosaur-sama
13:15:50 <dmwit> hyperisco: I briefly considered saying nice things to you, but on rereading it was clear that only nice things from geekosaur could motivate you.
13:16:42 * geekosaur was just being a smartaleck about simple set implementations…
13:17:09 <dmwit> Well I hope you've learned your lesson!
13:27:07 <beginnerSOL-M> Hey. is this a typo in HaskellBook or this sentence is correct? "for the function 04convList :: a -> [a] , unless the result is [], the resulting list has values that are all the same 04value. The list will always be the same length."
13:27:08 <beginnerSOL-M> same "value" or "type" ?
13:27:27 <hyperisco> beginnerSOL-M, both
13:27:39 <monochrom> No typo. Same value.
13:27:48 <ClaudiusMaximus> i give you an 'a', what can you do with it
13:27:49 <beginnerSOL-M> Can't understand it.
13:28:28 <monochrom> OK beginnerSOL-M, would you mind playing a game with me?
13:28:34 <beginnerSOL-M> nothing in terms of operations that come from typeclasses, we don't have typeclasses
13:28:45 <hyperisco> promise it is not called "Thermonuclear War"
13:28:52 <beginnerSOL-M> monochrom ok
13:28:57 <beginnerSOL-M> :D
13:28:59 <monochrom> Maybe I should describe the game first so you can decide.
13:29:23 <monochrom> You code up your own version of convList.  It must have type a->[a].  Don't make it Int->[Int] or something.
13:30:02 <monochrom> Then I'm going to ask you "what's the result of convList ()".  Based on your answer I'll predict what will happen to convList 24, convList 'x', etc.
13:30:29 <beginnerSOL-M> monochrom I know that we have parametric polymorphism here and we can do nothign to that "a" other than ignoring it or returning it or maybe passing it to some other expression.
13:30:35 <monochrom> Don't tell me your code, just tell me the test result of a simple test like convList (). Then I'll know.
13:30:45 <beginnerSOL-M> But my problem is that "list".
13:31:31 <hyperisco> okay, now pick a number between 1 and 9, then multiply by 6, then subtract 4, then divide by 2, then…
13:31:44 <monochrom> IMO it's pointless to essayly discuss this until you have played this game, even played this game for many rounds with various attempts of trying to foil me.
13:32:38 <monochrom> I won't see your code but based on one single test case I can make seemingly prophetic predictions.  Are you in?
13:32:46 * beginnerSOL-M monochrom ok, doesn't work, can't do anything "with" that "a".
13:33:07 <monochrom> What doesn't work? The game hasn't even started.
13:33:10 <nfd9001> you should probably make a function that doesn't return bot
13:33:25 <monochrom> I'm fine with bottom too.
13:33:37 <hyperisco> ;)
13:33:53 <monochrom> If convList () goes "undefined", then convList 42 also goes "undefined". Simple.
13:34:00 <monochrom> I can't lose this game. Try me.
13:34:23 <hyperisco> he's the Akinator of parametricity
13:34:39 <nfd9001> heck, i'll just hand you a list of bottoms, that'll teach ya
13:34:43 <nfd9001> (also works)
13:34:49 <monochrom> If you're wondering, I'm philosophically against "explain in your own words to show you understand".  Essay writing is too cheap.  Real understaning is getting code to work and making correct predictions.
13:35:19 <monochrom> In fact I believe in "explain in your own words to show you're full of it".
13:35:20 <hyperisco> you mean I can't learn to program from a thesaurus?
13:35:41 <monochrom> Hell you can't even program with merely type synonyms!
13:35:41 <beginnerSOL-M> monochrom so one implementation could be convList x = [x] ???
13:35:43 <nfd9001> beginnerSOL-M: so, my dude, actually break open ghci and write some function :: (a -> [a])
13:35:48 <monochrom> Yes.
13:35:50 <nfd9001> beginnerSOL-M: absolutely
13:36:33 <beginnerSOL-M> so convList 43 will be [42] ?
13:36:35 <monochrom> But why tell me your code? Just tell me "OK my secret code gives convList () = [()]" and watch me telepathically guess "oh so convList 42 = [42]"
13:36:42 <beginnerSOL-M> 43*
13:36:42 <monochrom> I mean, >:)
13:36:50 <monochrom> Yeah!
13:37:30 <pounce> > fix (\x -> [x])
13:37:32 <lambdabot>  error:
13:37:32 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
13:37:32 <lambdabot>      • In the expression: x
13:37:36 <pounce> hehe
13:37:47 <beginnerSOL-M> Holy ***, I just got it.
13:37:52 <nfd9001> :D
13:38:09 <monochrom> See the power of trying things out to experience it?
13:38:25 <beginnerSOL-M> I don't know why I have problems with parametric polymorphism.
13:38:39 <hyperisco> I don't understand it either so don't feel bad
13:38:57 <beginnerSOL-M> monochrom of course, it was a great lesson, thanks :)
13:39:10 <beginnerSOL-M> hyperisco :D
13:39:37 <hyperisco> brain melted at the formalism for functions
13:40:56 <nfd9001> beginnerSOL-M: just remember: if your function doesn't know what's being passed to it, it can't really change that value. It can embed that value in things all it wants or hand that value off to something that understands it, of course
13:41:14 <ski> @check let xs = [] in all (\x -> all (\y -> x == y) xs) xs
13:41:16 <lambdabot>  +++ OK, passed 100 tests.
13:41:30 <Christienne> How do I register here?
13:41:34 <beginnerSOL-M> I have another question, this is from HaskellBook and this time about ad-hoc polymorphism, can't fully understand it. "This ad-hoc-ness is constrained by the types in the typeclass that defines the methods and Haskell’s requirement that typeclass instances be unique for a given type."
13:41:37 <nfd9001> if we put any constraint on what type a was, we couldn't make that guarantee
13:41:49 <hyperisco> ski, see I thought the same thing, so I don't know why they bothered stating that as an exception
13:42:00 <hyperisco> ski, but degenerate cases seem to bother people.
13:42:07 <nfd9001> beginnerSOL-M: are there any specific typeclasses you're familiar with? Applicative maybe?
13:42:24 <nfd9001> or Monoid?
13:42:26 <ski> Christienne : try `/msg NickServ help register' to get more info on how to register
13:42:39 <beginnerSOL-M> nfd9001 this was great, thanks.
13:43:00 <monochrom> If you have a type class, you kind of "know more" about the type you receive. You "know" in the sense of you have more methods to play with.
13:43:16 <hyperisco> beginnerSOL-M, as the addage goes, we can write code for you but we can't understand it for you
13:43:19 <nfd9001> and one type can't be a member of the same typeclass twice
13:43:26 <beginnerSOL-M> nfd9001 No, I just finished the chapter on Types, will start studying typeclasses tomorrow
13:43:38 <nfd9001> oh, ok, i'll give you a quick explanation
13:43:47 <monochrom> For example if you are writing "foo :: a -> a -> Bool" you can't try "foo x y = x==y". But if you are allow "Eq a" then suddenly you have that optional.
13:43:58 <nfd9001> typeclasses are kind of like interfaces in Java, if you're familiar
13:44:00 <monochrom> s/allow/allwoed/
13:44:25 <ski> nfd9001 : first language
13:44:35 <nfd9001> oh ok
13:44:37 <Christienne> ski: I mean to be registered in this channel
13:44:49 <nfd9001> beginnerSOL-M: so we don't need to fully explain typeclasses to explain what this means
13:44:50 <ski> Christienne : no such thing. you just talk here
13:45:20 <nfd9001> there's a typeclass called Semigroup. if a type "has an instance of Semigroup", it means it provides functions that match all of the types of semigroup
13:45:26 <hyperisco> you can send your yearly channel subscription payment to my email address
13:45:44 <monochrom> Christienne_: If you saw "registered" it means registering to nickserv generally, that's all.
13:45:58 <nfd9001> Semigroup only requires that you implement one function: (<>) :: a -> a -> a
13:46:02 <beginnerSOL-M> Actually my problem is with that last part, "Haskell’s requirement that typeclass instances be unique for a given type."
13:46:12 <nfd9001> getting there :D
13:46:14 <Ariakenom> hyperisco: you'll get it in $mostRecentCryptocoin
13:46:48 <nfd9001> beginnerSOL-M: so it's just like an associative operator. 
13:46:55 <hyperisco> I'm heavily invested in cryptofutures
13:47:24 <nfd9001> if i wanted to write my own instance of Semigroup for Num (the type of numbers), I could define (<>) like this:
13:47:36 <nfd9001> a <> b = a + b
13:47:45 <ski> Christienne : if you have a (Haskell-related) question, just ask it
13:47:51 <nfd9001> it's an associative operator. that's the only requirement.
13:48:01 <nfd9001> But a <> b = a * b would also work!
13:48:27 <nfd9001> if I made two different instances of Semigroup for num, Haskell wouldn't know which meaning of (<>) I meant
13:48:41 <nfd9001> i could want to add two numbers, or i could want to multiply them
13:48:53 <ski> nfd9001 : "Num (the type of numbers)"
13:48:58 <beginnerSOL-M> How does it know?
13:48:59 <nfd9001> loosely
13:49:23 <nfd9001> how does it know what? which one to use?
13:49:33 <beginnerSOL-M> yes
13:49:48 <nfd9001> it can't know which one to use, and that's why you aren't allowed to make multiple instances of the same typeclass for one type
13:50:23 <nfd9001> both functions have types that satisfy the meaning of "Semigroup", but do totally different things
13:50:28 --- mode: glguy set +v Christienne_
13:50:33 <jle`> beginnerSOL-M: "how would it know" is exactly the reason why you aren't allowed to have more than one instance of a given typeclass for a type :)
13:51:23 <nfd9001> there's a trick for working around this if you know you might want to use different sorts of (<>) for one value
13:51:28 <beginnerSOL-M> Holy ***, let me read everything again.
13:51:42 <nfd9001> you can just wrap them in another type so that Haskell can figure out what you meant
13:52:09 <ski> @let instance Semigroup Integer where {(<>) = (+)}; instance Semigroup Integer where {(<>) = (*)};
13:52:10 <lambdabot>  .L.hs:159:10: error:
13:52:10 <lambdabot>      Duplicate instance declarations:
13:52:10 <lambdabot>        instance [safe] Semigroup Integer -- Defined at .L.hs:159:10
13:52:25 <hyperisco> my life is steeped in type classes now
13:52:32 * ski looks at Christienne_
13:52:33 <nfd9001> same ;_;
13:52:55 <hyperisco> you can't put the tea back in the bag, so make sure this is what you want
13:53:17 * Christienne_ hides
13:53:33 <hyperisco>  /me
13:53:55 <hyperisco> nailed it
13:54:45 --- mode: glguy set +v vansonsa_
13:55:52 <beginnerSOL-M> nfd9001 Beautiful.
13:56:48 --- mode: glguy set +v Christienne_
13:56:59 <Christienne_> hyperiso: Lol.
13:57:46 <nfd9001> beginnerSOL-M: so if i did "newtype Product = Num; newtype Sum = Num;", I could then implement Semigroup for both of them and have access to both definitions
13:58:05 <beginnerSOL-M> nfd9001 There's something I can't understand here, the "things" that can have instances of typeclasses are "types". so why did you say "instances of Semigroup for Num" ? typeclasses can have instances of typeclasses too?
13:58:09 <nfd9001> Then Sum <> Sum and Product <> Product would make sense
13:58:51 <ski> nfd9001 : those `newtype' declarations make no sense
13:59:04 <ski> (in fact they're syntactically illegal)
13:59:17 <ski> @let newtype Product = Num
13:59:18 <nfd9001> i'm playing really fast and loose here
13:59:18 <lambdabot>  Parse failed: newtype declaration constructor must have exactly one parameter.
13:59:42 <hyperisco> play a little slower and tighter
13:59:42 * ski would prefer if nfd9001 picked some specific numeric type to play with
13:59:48 <nfd9001> mhmm
14:00:02 <jle`> beginnerSOL-M: right, Num isn't something that can be an instance of Semigroup 
14:00:07 <hyperisco> spitball with the pros
14:00:13 <jle`> but you can write: `newtype SemiInt = SemiInt Int`
14:00:16 <hyperisco> like myself
14:00:21 * hyperisco puts on shades
14:00:26 <jle`> `newtype ProdInt = ProdInt Int`, or `newtype SumInt = SumInt Int`
14:00:35 * ski suspects this sloppiness doesn't help beginnerSOL-M that much. especially if they want to try out the given code snippets, to play with them
14:00:43 <monochrom> Pro tip: Test your code against GHCi before showing to beginners.
14:00:44 <jle`> and you can give `ProdInt` and `SumInt` both different instances of Semigroup
14:00:59 --- mode: glguy set -v binq
14:01:06 <beginnerSOL-M> jle` so I'm confused now.
14:01:35 <nfd9001> my bad beginnerSOL-M 
14:01:47 <jle`> beginnerSOL-M: Num can't be an instance of Semigroup
14:01:55 <jle`> because it's a typeclass, not a 'type'
14:02:02 <ski> @newtype ProdInt = ProdInt Int deriving Show; newtype SumInt = SumInt Int deriving Show
14:02:02 <lambdabot> Unknown command, try @list
14:02:05 <nfd9001> but a type that is an instance of Num can also be an instance of Semigroup
14:02:07 <beginnerSOL-M> jle` that's why I'm confused
14:02:08 <hyperisco> type class classes aren't available until GHC 9
14:02:15 <jle`> beginnerSOL-M: right, nfd9001 was lying earlier :)
14:02:29 <jle`> or at least, bending the truth slightly ;)
14:02:29 * hyperisco waits for someone to push up their "actually" glasses
14:02:36 <ski> @let getProdInt (ProdInt n) = n; getSumInt (SumInt n)
14:02:36 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
14:02:47 <beginnerSOL-M> nfd9001 got it :)
14:03:16 <jle`> beginnerSOL-M: for example, say you want to write an instance of Semigroup for Int
14:03:20 <nfd9001> so you could make an instance of Semigroup for Integer, which is also an instance of Num, and therefore knows what (+) means
14:03:26 <ski> @let instance Semigroup ProdInt where {ProdInt m <> ProdInt n = ProdInt (m * n)}; instance Semigroup SumInt where {SumInt m <> SumInt n = SumInt (m + n)};
14:03:27 <lambdabot>  .L.hs:159:20: error:
14:03:27 <lambdabot>      Not in scope: type constructor or class ‘ProdInt’
14:03:27 <lambdabot>      Perhaps you meant ‘Product’ (imported from Data.Semigroup)
14:03:32 <jle`> but you have a couple of options: you can do (<>) = (*), or (<>) = (+)
14:03:43 <ski> @let newtype ProdInt = ProdInt Int deriving Show; newtype SumInt = SumInt Int deriving Show
14:03:44 <lambdabot>  Defined.
14:03:45 <jle`> but because Int is only allowed to have one instance of Semigroup, you can't do both
14:03:47 <ski> @let instance Semigroup ProdInt where {ProdInt m <> ProdInt n = ProdInt (m * n)}; instance Semigroup SumInt where {SumInt m <> SumInt n = SumInt (m + n)};
14:03:48 <lambdabot>  Defined.
14:03:50 <beginnerSOL-M> nfd9001 Now I get it :)
14:04:05 <jle`> so something people oftne do is wrap their type in a newtype, so each newtype gets its own Semigroup instance
14:04:24 <jle`> so if i wrap my Int in ProdInt, then (<>) is multiplication.  and if i wrap my Int in SumInt, then (<>) is addition
14:04:31 <jle`> (piggybacking off of ski's examples)
14:04:37 <jle`> > SumInt 1 <> SumInt 4
14:04:39 <lambdabot>  error:
14:04:39 <lambdabot>      Ambiguous occurrence ‘<>’
14:04:39 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
14:04:45 <jle`> > SumInt 1 Data.Semigroup.<> SumInt 4
14:04:47 <lambdabot>  SumInt 5
14:04:59 <jle`> > ProdInt 2 Data.Semigroup.<> SumInt 7
14:05:01 <lambdabot>  error:
14:05:01 <lambdabot>      • Couldn't match expected type ‘ProdInt’ with actual type ‘SumInt’
14:05:01 <lambdabot>      • In the second argument of ‘(Data.Semigroup.<>)’, namely
14:05:07 <jle`> > ProdInt 2 Data.Semigroup.<> ProdInt 7
14:05:09 <lambdabot>  ProdInt 14
14:05:11 <jle`> sorry, typo :)
14:05:22 <jle`> so in that case, SumInt 1 <> SumInt 4 = SumInt (1 + 4), so <> is +
14:05:35 <jle`> and ProdInt 2 <> ProdInt 7 = ProdInt (2 * 7), so <> is *
14:05:57 <jle`> it's just a common hacky trick people use to 'fake' multiple instances of a typeclass for a given type
14:06:23 <beginnerSOL-M> jle` got it, thanks :)
14:06:25 <ski> hyperisco : actually, would regulars here do that, in front of a beginner ?
14:06:27 * binq shrugs
14:06:48 <hyperisco> ski, lmao you do that
14:06:56 * ski grins
14:07:06 <jle`> to be honest i've never found it to be the cleanest thing...but it works, heh
14:07:22 <jle`> applications of this technique are all over the standard libraries
14:07:29 <hyperisco> making asides about advanced topics to beginners is a treasured pastime
14:07:48 * Christienne_ starts reading
14:08:21 <hyperisco> that's how we supplant good ideas into people's heads
14:08:22 * geekosaur is actually not fond of that, especially when someone weak on either English or Western culture is involved
14:08:22 <nfd9001> i mean, it's passably useful when it comes to understanding why we can't have multiple instances of the same typeclass for the same type
14:08:48 <nfd9001> "here's how you can do that; you need new types"
14:09:15 <jle`> it's useful, but i'm talking about an idea of cleanliness
14:09:22 <jle`> modern haskell relies on this trick
14:09:45 <jle`> so it's gotta be useful, at least
14:10:01 <jle`> but more in a 'it's the best we got' sort of way :)
14:10:10 * ski . o O ( "Unclean! Unclean! or purity issues in declarative constraint logic programming" by Ralph Becket in 2006-03 at <https://www.mercurylang.org/documentation/papers.html#g12_unclean> )
14:11:03 <jle`> i'm even more a non-fan of purescript's named instances
14:11:11 <beginnerSOL-M> One general question quys, I did some research before choosing Haskell as my first programming language. My question is about modeling or designing real world stuff in Haskell, like modeling a human being. in OOP languages they can use objects and it "feels" intuitive and close to the real world. I'm curious to know how Haskellers model a human being in Haskell (like class properties and methods in OOP)?
14:11:51 <nfd9001> depends on how granular you want to get :D
14:11:54 <rom1504> modeling a human being is a very rare thing
14:12:03 <rom1504> maybe you meant modeling an user ?
14:12:06 <jle`> probably as a data type and record field, maybe hiding accessors
14:12:06 <ldlework> beginnerSOL-M: OOP is just a pattern for organizing state
14:12:16 <ldlework> There's plenty of ways to organize state.
14:12:17 <beginnerSOL-M> doesn't have to be a human being, can be a car, or anything.
14:12:25 <jle`> modeling a car is easy
14:12:36 <jle`> data Car = Car { carModel :: String, carYear :: Int }
14:12:57 <jle`> you have to be a bit more specific about what aspects you want to model, however :)
14:13:07 <beginnerSOL-M> yeah, I'm just curious to know how Haskeller define a "thing" and give it properties and actions.
14:13:29 <rom1504> actions are functions
14:13:32 <nfd9001> So we give it actions by defining functions that use its data
14:13:36 <ski> "it \"feels\" intuitive" doesn't mean it is
14:13:42 <beginnerSOL-M> jle` so these are its properties, what about the actions that a car has?
14:13:47 <jle`> beginnerSOL-M: they'd be functions
14:14:23 <rom1504> a function that take a car and maybe some other things and do things
14:15:08 <jle`> beginnerSOL-M: but also, remember that taking contrived examples like this in a vacuum might not necessarily give you any good insight
14:15:16 <beginnerSOL-M> In OOP, it "feels" like an object has some stuff for itself, data and actions associated with it, how do Haskellers do it? How do you define a set of operations that are exclusive to a "car"?
14:15:18 <jle`> 'modeling a car', 'modeling a human' doesn't make sense in a vacuum
14:15:26 <jle`> what do you want to actually do, in the long run?
14:15:28 <jle`> beginnerSOL-M: that's what types are for
14:15:29 <geekosaur> beginnerSOL-M, one problem with the OOP approach is it tends to encourage something that is often brought up in beginner OOP courses, but which continues to be a problem in less obvious forms: Tree.bark() vs. Dog.bark()
14:15:38 <jle`> `myFunction :: Car -> ...`, is exclusive to Car's
14:15:42 <nfd9001> "how do you do things that look like object-oriented programming" is what we're trying to answer
14:15:44 <jle`> you can use myFunction on Int's or Bools
14:16:12 <jle`> the type signature is what gives it its exclusivity
14:16:13 <ski> s/can/can't/
14:16:21 <jle`> ah yeah, you can't use myFunction on Int's or Bools
14:16:49 <jle`> nfd9001: right, but sometimes these "things" don't make sense because the way you solve a problem from the top-down view is different entirely
14:16:55 <beginnerSOL-M> jle` my main goal is developing web apps with Haskell and maybe Elm, not sure about Elm yet. I always have ideas and I really like building startups. 
14:17:09 <jle`> beginnerSOL-M: right, by 'in the long run', i mean, what are you going to use that Car model to do?
14:17:22 <jle`> are you going to use it to display its make and year on a website?
14:17:31 <jle`> in taht sense, you can write a displayCar :: Car -> String
14:17:42 <jle`> displayCar will only work on Car's, so it's exclusive to cars
14:18:01 <rom1504> you can put it in a car.hs too
14:18:03 <ski> @quote other.car
14:18:03 <lambdabot> gwern says: his other car is a cdr
14:18:11 <jle`> things like objects and classes are a tool to help with a specific approach/structure of problem-solving
14:18:24 <jle`> but it might not make sense at all if you're in an alternative approach/structure of problem solving
14:18:56 <jle`> it's kind of like someone who has lived their entire life underwater in scuba gear, contemplating living on the surface
14:19:10 <jle`> "if you live on the surface and there's no water, then how are you going to carry around a scuba tank? it's way too heavy"
14:19:35 <jle`> asking "how do people on land carry their scuba tanks everywhere?" already implants assumptions that will mislead your journey
14:19:37 <Christienne_> The question was confusing to read because Haskell is different to OOP...
14:20:16 <nfd9001> so, yeah, you can model things that look like OOP, but that isn't necessarily the most natural way to do things in Haskell
14:20:37 <monochrom> Did you just explain why the Little Mermaid was doomed to be miserable? >:)
14:20:38 <jle`> or someone who has lived their entire life in a space suit in space who is contemplating living on the surface. "i don't think i could live on the surface, walking around in a space suit would be too difficult."
14:21:31 <jle`> so asking "how would i model <contrived example that is suited for OOP> in haskell?" is a question that might not be the most insighful
14:21:55 <jle`> by that i mean, a uestion that might not give the most insightful answers
14:22:07 <nfd9001> doesn't mean you were wrong to ask it, of course
14:22:40 <monochrom> Or why the boy in The Space Between Us won't have a future with his Earth girlfriend, at least not in the sense of "one day we will have a child"...
14:22:43 <Christienne_> Maybe something along defining a model
14:23:09 <nfd9001> monochrom: hey, they could adopt one
14:23:11 * nfd9001 shrugs
14:23:13 <jle`> yeah, i don't mean to say that the question isn't insightful, but that the answers might not be too helpful
14:23:47 <monochrom> "not wrong to ask" is a very low bar.
14:24:10 <beginnerSOL-M> jle` Got it. Understand your point. let me ask it this way, maybe I can make myself clear. let's imagine that I have a concept in my website called a "user", I want to know if there is a way, in Haskell, to "pack" BOTH data and functions (that operate on that data) ABOUT USER in one place.
14:24:20 <monochrom> Part of learning includes learning to ask better and better questions. As opposed to feeling entitled to ask anything.
14:24:26 <jle`> beginnerSOL-M: you mean, like a module?
14:24:43 <beginnerSOL-M> jle` I don't know what a module is yet.
14:24:49 <monochrom> Entitlement is an anti-thesis to learning and we need to crack down on it.
14:25:01 <jle`> beginnerSOL-M: ah. in haskell, you can write a program over multiple files
14:25:14 <jle`> so you can have one file that is just for users and user-related functions
14:25:30 <beginnerSOL-M> I'm studying chapter 5 of HaskellBook, haven't studied "module" yet.
14:26:00 <jle`> there's also some namespacing you can do, so that functions from different files can be accessed under different categories/namespaces
14:26:09 <beginnerSOL-M> jle` thanks god, just wanted to know this "module".
14:26:18 <jle`> but if you want to use functions from a different file (module), you can import them from that other file/module
14:26:27 <monochrom> beginnerSOL-M, it is possible that you don't need to bundle data and function.  In some scenerios maybe you do, but then it's just a record that contains both data fields and function fields.
14:26:31 <geekosaur> one problem with asking how you'd model X in a differet language paradigm is that X may itself be mis-specified for that paradigm. What's the problem that you are trying to solve with X in OOP? That could well lead to something unlike X in the lazy pure FP paradigm
14:27:02 <geekosaur> (for "car", you probably have *something* conceptually similar, but done rather differently)
14:27:44 <nfd9001> so where in Java you'd access a property of your User, in Haskell you pass your User to a function that uses it
14:28:06 <beginnerSOL-M> jle` got it.
14:28:09 <nfd9001> in Java, you'd put static and class "methods" in the same class as the User
14:28:13 <jle`> beginnerSOL-M: but you're right to suspect that there might be a bigger problem other than just namespacing/physical location
14:28:40 <widmur> Hello all. Is this an appropriate place for beginner questions?
14:28:41 <jle`> there's a more fundamental issue here that java and haskell have to balance/make trade-offs for, called the "expression problem"
14:28:44 <jle`> widmur: yes :)
14:28:56 <nfd9001> in Haskell, you'd define the User, define the behavior, and then bundle it together in a "module". there's nothing special about the "module" other than it makes it easier to draw in multiple different definitions at once
14:29:07 <nfd9001> whereas a java Class is kind of special
14:29:42 <nfd9001> by "draw in" i mean "use in a different part of your program"
14:29:43 <jle`> beginnerSOL-M: the expression problem is roughly about what else you have to change when you change some part of your model
14:29:51 <beginnerSOL-M> I haven't written any OOP code guys, that was just a curiosity.
14:30:20 <Christienne_> As a beginner, it really confuses me when a reference compares a Haskell method to other programming languages because it distracts me with, for example: classes, that I can't even use when programming in Haskell... but maybe it's just me. Thank God for HaskellBook
14:30:23 <nfd9001> Yeah, of course. Your question did actually demonstrate some knowledge of how OOP works, actually
14:30:23 <jle`> beginnerSOL-M: on one extreme, changing your type requires changing all of the functions/actions that work on your type
14:30:50 <nfd9001> Christienne_: understandable
14:31:03 <jle`> beginnerSOL-M: and on the other extreme, um. i forgot actually, i feel like i had thought this out in my head
14:31:11 <ski> Christienne_ : well, there are "type classes" in Haskell .. not that they're similar to "classes" in OO, though
14:31:22 <jle`> but my point was that java and haskell, OoP and FP, all have to balance different manifestations of the expression problem
14:31:30 <jle`> so this is probably the tension you are feeling
14:31:36 <monochrom> People dig analogies. But you know that if analogies never break, then there is no need to learn new things. By definition "new" means no analogy with old things.
14:31:47 <jle`> not necessarily the "in one place" part, but rather the "scope of changes i need to make" part
14:31:59 * hackage interpolator 0.1 - Runtime interpolation of environment variables in records using profunctors  http://hackage.haskell.org/package/interpolator-0.1 (dfithian)
14:32:06 <beginnerSOL-M> nfd9001 I did some research about paradigms, languages, etc before choosing Haskell.
14:32:13 <nfd9001> i can tell :)
14:32:20 <Christienne_> ski: Yes! Even 'results' or '=' comparison it just add confusion.
14:32:36 <nfd9001> just be aware that Haskell programmers solve problems in a very different way from the way most programmers do
14:33:10 <ski> and we're proud of it :)
14:34:25 <beginnerSOL-M> jle` got it :)
14:34:25 <beginnerSOL-M> nfd9001 that's why I ask these kinda questions, want to learn "that" way :)
14:34:26 <nfd9001> oh yeah monochrom i think you were the one who (in my own words, not yours) told me to quit being a dumbass a few months ago?
14:34:30 <nfd9001> just wanted to thank you again for that
14:34:34 <nfd9001> it was helpful
14:37:09 <Christienne_> beginnerSOL-M: There's this Real Haskell Book that do tons of analogies
14:37:15 * Christienne_ feels bad
14:37:30 <ski> @where RWH
14:37:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:37:31 <ski> ?
14:37:41 <nfd9001> i know most resources assume Haskell isn't your first language
14:37:45 <beginnerSOL-M> Christienne_ real Hakell book? which one?
14:39:04 <beginnerSOL-M> Ah, Real world Haskell, I've seen it but I think it's heavy for me.
14:39:18 <ski> i think people claim it hasn't aged that well
14:39:32 <monochrom> nfd9001: Err what did I do?! But heh OK!
14:39:40 * ski smiles
14:39:46 <widmur> Thanks jle`. I'm working through Haskell Programming from First Principles. One of the exercises asks why the expression 6 / length [1, 2, 3] fails. As far as I understand, the (/) operator requires that both arguments and the return type have a type that has an instance of the Fractional type class. The 'length' function returns an Int, and there is no such Fractional Int. If this is the case, how does Haskell resolve something like 6 
14:39:46 <widmur> / 3? In the REPL, :type 6 yields Num p => p. But Num is not a type.
14:40:14 <jle`> widmur: right, type inference gives you the "most polymorphic possible" type
14:40:27 <nfd9001> monochrom: the real gist of it was that i was slightly tangled up by foldl. the specific example was flattening an infinitely long list of integers to a string
14:40:34 <jle`> widmur: so 6, a polymorphic literal, is inferred to have the type "p, for any p that has a Num instance"
14:40:42 <ski> widmur : numeric literals like `6',`3' are polymorphic, overloaded over all numeric types. so `6' can be an `Int', but can also be a `Float'
14:40:52 <ski> @type 6
14:40:54 <lambdabot> Num p => p
14:40:54 <ski> @type 6.5
14:40:56 <lambdabot> Fractional p => p
14:41:02 <jle`> widmur: when you actually *use* 6, then type inference will kick in to pick the instance of Num that 6 needs to be in order to make things work
14:41:03 <ski> `6.5' can't be an `Int', though
14:41:32 <jle`> widmur: how to read `Num p => p` is `any p, but with the restriction that p is an instance of Num`
14:41:40 <ski> widmur : .. but there's *no* implicit conversion between different numeric types. it's just that numeric literals will have the type that the context expects them to have
14:41:43 <nfd9001> was trying to convince myself that list >>= show wasn't going to take a stupid amount of time
14:42:00 <ski> nfd9001 : it's just `concatMap'
14:42:24 <nfd9001> :t concatMap
14:42:25 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
14:42:42 <ski> @type concatMap :: (a -> [b]) -> [a] -> [b]
14:42:43 <lambdabot> (a -> [b]) -> [a] -> [b]
14:42:49 <nfd9001> yeah, i suppose that'd do
14:42:59 <ski> @type (=<<) :: (a -> [b]) -> [a] -> [b]
14:43:01 <lambdabot> (a -> [b]) -> [a] -> [b]
14:43:31 <beginnerSOL-M> jle` can we say "if it can be any Num type then it means it can be a Fractional too" ??? (by "any Num type" I mean any type that has an instance of Num")
14:44:09 <nfd9001> ski: you reckon that'd be faster for an infinite a?
14:44:10 <jle`> beginnerSOL-M: almost. we can say that if it can be any Num instance, then it can also be any Fractional instance
14:44:13 <monochrom> "can be any" is tricky to interpret, requires mind-reading.
14:45:09 <Christienne_> ski: I can't do some exercises in it (since I'm limiting myself to TypeClasses at the moment) because the GHC version was around 6 when it was written.
14:45:09 <jle`> formally we say that (forall p. Num p => p) is a subclass of (forall p. Fractional p => p)
14:45:30 <monochrom> What you need is some specific statements like "if you write 6 where a fraction is expected, it's fine, e.g., 6 * 0.5"
14:45:42 <nfd9001> basically, we need to know that p is a Num because we need to know there's an implementation of (+) there
14:45:59 <jle`> um, i always mix up if it's a subclass or superclass
14:46:00 <nfd9001> we don't need to know specifically what that (+) does or what type p is otherwise
14:46:16 <ski> nfd9001 : i don't understand the question
14:46:25 * hackage lambdabot-xmpp 0.1.0.0 - Lambdabot plugin for XMPP (Jabber) protocol  http://hackage.haskell.org/package/lambdabot-xmpp-0.1.0.0 (SergeyAlirzaev)
14:46:41 <jle`> oh yeah, it's a subclass i'm pretty sure
14:46:43 <boj> given some service i have no control over that gives back cyclic data, is there a way to keep the data types in separate modules? or do i have to merge the data types into the same module?
14:47:02 <nfd9001> ski: is "list `concatMap` show" appreciably faster than "list >>= show" here?
14:47:05 <ski> Christienne_ : *nod*
14:47:16 <jle`> boj: it's better to keep them in the same model, but you can also fiddle around with hs-boot, but it's probably not worth it
14:47:23 <monochrom> "can be any" is ambiguous because there are two opponents, the author and the user.  The author's freedom of "I can choose anything" opposes the user's freedom of "I can choose any".  Therefore harping on "any" completely misses the point.
14:47:25 * hackage notmuch 0.1.0.0 - Haskell binding to Notmuch, the mail indexer  http://hackage.haskell.org/package/notmuch-0.1.0.0 (frasertweedale)
14:47:28 <jle`> *module
14:47:34 <boj> jle`: alright, thanks
14:47:41 <nfd9001> concatMap is useful for Foldables in general, but it isn't strictly necessary for this one task
14:47:57 <ski> beginnerSOL-M : we talked a little about "any" vs. "every", the other day, yea ?
14:48:06 <widmur> Ah, okay. I thought there was some type inference happening after compile-time. It's just compiler magic. Thanks for your help all.
14:48:14 <beginnerSOL-M> ski yeah ;-)
14:48:26 <ski> nfd9001 : should be the same (modulo your type error)
14:48:42 <monochrom> When you write "6 * x" you are the user of 6 (the compiler is the author) so you are the one with the freedom to choose "I want it Double because my x is Double".
14:48:56 <jle`> widmur: i wouldn't quite call it compiler magic, maybe hindley-milner typechecker 'non-magic'
14:49:30 <beginnerSOL-M> thanks guys for your help.
14:49:42 <ski> Christienne_ : "it" being RWH, rather than HPFFP, i take it (?)
14:50:23 --- mode: glguy set +v chalo
14:50:29 <chalo> Hola, alguien habla español?
14:50:31 <monochrom> People are selfish therefore every time a promise of the form "... any ..." is made, everyone thinks it means they themselves are in control.  This is why there were two world wars.
14:51:02 <ski> jle` : s/is a subclass of/can be specialized (and then generalized) into/
14:51:38 <jle`> hm, i should probably say subtype, not subclass
14:51:45 <Christienne_> Yes! HPFFP is fantastic. Many have said that it's a standalone book but I still tried to see other explanation from other references just so I could see one concept with another type of explanation, but yeah.
14:51:53 <chalo> Im right if I say that "f h j = sum. map j . filter h" is "f :: num a => (a->a) -> (a->a) -> [a] -> a" ?
14:51:56 <widmur> @chalo: Puede tratar #haskell.es.
14:51:56 <lambdabot> Unknown command, try @list
14:51:57 <ski> chalo : #haskell.es
14:52:14 <aplainzetakind> I think HPFFP has a great table of contents.
14:52:18 <nfd9001> which is HPFFP?
14:52:20 <chalo> ski: widmur thks
14:52:29 <jle`> chalo: you can just ask the typechecker :)
14:52:38 <Christienne_> monochrom: yeah...
14:52:41 <jle`> :t \h j -> sum . map j . filter h
14:52:42 <lambdabot> Num c => (a -> Bool) -> (a -> c) -> [a] -> c
14:52:58 <chalo> jle`: how can i do it?
14:53:08 <jle`> i just did it :)
14:53:11 <jle`> one line above your message
14:53:21 <jle`> so ti's slightly different. h isn't (a -> a), but (a -> Bool)
14:53:27 <chalo> ahahah
14:53:30 <chalo> with lambda :)
14:53:32 <jle`> since filter takes an (a -> Bool), not (a -> a)
14:53:40 <ski> chalo : `filter' takes a predicate, iow a function that returns a `Bool'. so `h' has type `a -> Bool', for some type `a'
14:53:42 <jle`> right, or you could also give it a name and check the type of the name
14:53:44 <chalo> ahhh filter use (a->bool)
14:53:49 <chalo> C:
14:53:50 <ski> @type filter
14:53:50 <jle`> @let fff h j = sum . map j . filter h
14:53:51 <lambdabot> (a -> Bool) -> [a] -> [a]
14:53:53 <lambdabot>  Defined.
14:53:56 <jle`> :t fff
14:53:57 <lambdabot> Num c => (a -> Bool) -> (a -> c) -> [a] -> c
14:54:18 <jle`> also, map is more polymorphic in the general situation; it can change the type too, potentially
14:54:44 <chalo> is necesary (a->c) ? if they are the same type, i mean, num
14:54:53 <chalo> it should be (a->a)?
14:55:03 <ski> Christienne_ : happy you like it :)
14:55:13 <jle`> it isn't necessarily type-changing
14:55:18 <jle`> it could potentially also keep the type the same
14:55:51 * ski idly recalls Wittgenstein insisting in Tractatus that different variables had to stand for different values
14:56:02 <chalo> its just to say that there is a transfomation there? only that?
14:57:00 <geekosaur> chalo: the function j only needs to produce a value whose type has a Num instance. it's up to that function to determine how it does it and what it starst from. if you have control over j, you can use a function (Num a => a -> a). function f doesn't control this.
14:57:02 <jle`> chalo: yeah, that it has to be a function
14:57:08 <geekosaur> that's wat the type is tellingyou
14:57:16 <jle`> chalo: (a -> b), the -> means it has to be a function
14:57:23 <jle`> so you can't give it Int, but you can give it Int -> Bool
14:57:34 <jle`> as long as the type has -> in it, aka a function type
14:58:16 <chalo> ahaha rigt, its because i dont know it but i know that its a function right?
14:58:22 <jle`> mhm
14:58:28 <jle`> yes
14:58:36 <chalo> f doesnt knows i mean
14:58:59 <jle`> as you wrote it, it doesn't care what 'a' and 'b' are, but just that it is a function
14:59:16 <chalo> but i know that it should be num, cuase then there is a sum
14:59:28 <jle`> it knows at least that the result type has to have a Num instance
14:59:33 <jle`> but not necessarily the input type
14:59:54 <chalo> ahah nice, im getting better on this topic
14:59:55 <jle`> or at least, it needs at least the result type to have a Num instance
15:00:09 <jle`> nothing similar is required of the input type
15:00:19 <chalo> seems really confuse to me, but im on the road
15:00:39 <binq> chalo: (id :: forall a b c. ((a ~ c), (b ~ c)) => a -> b)
15:00:44 <chalo> aha i inerstand thks a lot
15:00:46 <jle`> (by the way, this is why i don't like the insistence that 'everything is a function' in Haskell. if you really did think 'everything was a function', then saying "map has to take a function" is meaningless)
15:00:48 <chalo> understand*
15:00:52 <jle`> chalo: no problem :)
15:01:31 <chalo> haha i really don like that type of excercices
15:01:45 <monochrom> I think only 3rd-rate tutorials say "everything is a function".
15:01:46 <chalo> but i think haskell is interesting
15:01:55 <jle`> chalo: once you do a few more, this becomes a little more natural :)
15:01:57 <chalo> when your not studying it
15:02:00 <ski> in Haskell, every function is a function.
15:02:00 <chalo> ajaja
15:02:06 <jle`> chalo: haha, that might be true :p
15:02:17 <ski> also, every non-function is a non-function, in Haskell.
15:02:19 <monochrom> 1st-rate tutorials just have you read the precise type because even "it's a function" is pretty informationless.
15:02:30 <binq> unless it is a constraint of course
15:02:34 <chalo> jle`: jaja sure, im getting better every time i try
15:02:46 <chalo> i still hate that anyway
15:02:49 <chalo> jaja
15:03:12 * ski . o O ( tautology class )
15:07:07 * Solonarv . o O ( in some technical sense, '6 :: forall p. Num p => p' is a function )
15:08:15 <nfd9001> this is the lambda calculus; we don't need no stinkin' values
15:08:36 <nfd9001> just do all your programming in GADTs with UndecidableInstances on
15:08:53 <Solonarv> That's not what I meant. It's perfectly reasonable to extend the lambda calculus with ADTs and "primitive" types.
15:09:15 * ski . o O ( delta-conversion )
15:09:28 <Solonarv> and: technically all you need is one letter and the parentheses
15:13:56 <ski> (wg 21
15:54:56 <koz_> Solonarv: What distinguishes a function from a polymorphic constant?
15:55:49 <c_wraith> koz_, https://stackoverflow.com/questions/53856606/why-is-this-unsafecoerce-not-unsafe
15:57:04 <c_wraith> koz_, ie... sometimes nothing at all.
15:59:11 <koz_> Lol.
15:59:20 <koz_> Interesting. Thanks c_wraith.
16:02:09 <Zemyla> koz_: A polymorphic constant is a function that takes a dictionary, I'm pretty sure.
16:02:22 <koz_> Zemyla: Yeah, under the covers.
16:03:03 <Zemyla> Is that like "in bed"?
16:12:16 <geekosaur> at least in the sense that what goes on there isn't your business unless you're a direct participant (here meaning the compiler) >.>
16:12:22 <monochrom> No, it's like when you are dining in a nice restaurant but then you get curious and go into their kitchen.
16:12:49 <monochrom> (and for example discover that they use their bare hands for your raw fish sushi)
16:13:34 <monochrom> (Oh actually that one the sushi chefs do it in public so let me revise that to they use their bare hands for your caeser salad)
16:14:33 <monochrom> (Also as per Ratatouille you discover a rat in charge.)
16:16:33 <monochrom> Next question: What's the difference between ketchup and sugared red-coloured starched vinegar?
16:16:36 <hpc> it's like discovering that soup doesn't have a five second rule
16:16:52 <monochrom> What's the five second rule?
16:16:53 <dmwit> Soup? You mean wet salad?
16:17:21 <hpc> monochrom: if you drop something you have five seconds to eat it
16:17:45 <dmwit> The rule is restrictive on bacteria. They are not permitted to get on the food for five seconds.
16:19:41 <glguy> I watched a Vsauce episode on the 5 second rule. It turns out that the rule is not scientifically sound :-O
16:19:56 <geekosaur> ketchup is differently non-Newtonian?
16:21:18 <geekosaur> strictly speaking, no, it's not. practically speaking, as soon as the food is opened (or taken out of an environment at a safe temperature) it's already been colonized. and the whole "must be sterile" thing leads to allergies.
16:21:40 <hpc> "must be sterile" is how you get flavorless hospital food
16:21:50 <glguy> There are different bacteria on the floor than in the air, in most places, it turns out
16:21:54 <hpc> (hospital chefs have a crazy complicated job)
16:22:23 <glguy> "most be sterile" is how you misrepresent an attention to hygiene
16:22:49 <hpc> well, that too
16:23:01 <hpc> food is not sterile pretty much by definition
16:23:06 <monochrom> Oh! Maybe s/starch/xanthum gum/ >:)
16:23:58 <hpc> speaking of haskell, dealing with large custom file formats is a pain
16:24:09 <hpc> if i was using any other language i don't know what i would do
16:24:55 <monochrom> You would allow yourself some bugs and a lot of "unsupported".
16:25:18 <hpc> pretty much
16:25:25 <monochrom> This is why Microsoft breaks standards left right and centre.
16:25:33 <hpc> i am already excluding some parts of the format, but only because i need a printer and not a parser
16:25:41 <hpc> and those parts of it are redundant
16:25:51 <hpc> (the file format here is pf.conf)
16:31:55 * hackage th-abstraction 0.2.10.0 - Nicer interface for reified information about data types  http://hackage.haskell.org/package/th-abstraction-0.2.10.0 (ryanglscott)
16:37:27 <jadrian> does QuickCheck need to be added as an extra-dep in stack?
16:37:53 <glguy> jadrian: Depends if your resolver has it or not and if you want the version that's in the resolver or not
16:39:24 <jadrian> glguy: I'm just using a standard stack installation... I would expect it to have it
16:39:36 <glguy> jadrian: There's no standard resolver, you have to pick one
16:39:51 <glguy> Is there a specific problem you're having?
16:39:52 <jadrian> glguy: that may explain a lot
16:40:25 * hackage stackage-to-hackage 1.1.0 - Convert stack.yaml to cabal.project + cabal.project.freeze  http://hackage.haskell.org/package/stackage-to-hackage-1.1.0 (tseenshe)
16:40:54 <jadrian> glguy: I just wanted to give QuickCheck a go, so I did `stack new`, added QuickCheck to the dependencies on package.yaml and thought that would work
16:41:14 <jadrian> glguy: stack build worked fine, and emacs wasn't showing any error
16:41:25 * hackage stack2cabal 1.0.0 - Convert stack projects to cabal.project + cabal.project.freeze  http://hackage.haskell.org/package/stack2cabal-1.0.0 (tseenshe)
16:41:26 <glguy> so it worked?
16:41:27 <jadrian> glguy: but ghci couldn't find the missing package
16:41:35 <geekosaur> ghci, or stack ghci?
16:41:38 <jadrian> ah
16:41:40 <jadrian> :/
16:41:44 <glguy> How'd you run ghci? If you're using stack you have to use stack for everything
16:41:46 <jadrian> geekosaur: good point
16:41:57 <jadrian> I'm tired :L
16:42:10 <jadrian> glguy: indeed not smart
17:06:10 <atondwal> so my racketeer friend was struggling with understanding the Haskell naming conventions
17:06:51 <atondwal> I explained to him that in the Haskell world, not only do we use Pure Functional Programming, we also use Purely Hungarian Notation!
17:19:22 <Maxdamantus> xInt :: IntType
17:19:59 * geekosaur wonders if that's snark about field labels
17:20:01 <Maxdamantus> or maybe it's `xIntType :: IntTypeType`
17:20:19 <Maxdamantus> or `xIntType0 :: IntType0Type1Type2...`
17:20:50 <Maxdamantus> This purely Hungarian notation doesn't seem to work.
17:27:25 * hackage matrices 0.5.0 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.5.0 (kaizhang)
17:28:33 <geekosaur> hungry notation?
17:42:32 <dmwit> atondwal: Which names in particular are you thinking of? I guess you could see the common "s" suffix as a kind of Hungarian-like notation.
17:42:39 <dmwit> Maybe "With" and "On" similarly?
17:42:44 <dmwit> Is that the kind of thing you're thinking of?
17:43:34 <c_wraith> perhaps record accessors?
17:44:20 <atondwal> dimwit: yeah, I was talking about x/xs, but also in my codebase I use "t" for Type a lot and "rt" for refinement type, usually without saying what they are because most of the time the function to too short/general to make naming them useful
17:45:15 <atondwal> "purely hungarian" as in the variable name does tell you anything other than it's type :)
17:48:22 <atondwal> let's see... what's the last thing I had open in hackage? I'll use recursion-schemes as an example: http://hackage.haskell.org/package/recursion-schemes-5.1/docs/src/Data.Functor.Foldable.html#zygoHistoPrepro
17:49:15 <atondwal> so a "zygoHistoPrepro f g t" take functions f and g and a memeber of Type t
17:49:46 <c_wraith> I mean... the argument is better if you don't quite something that was literally added to the library as a joke. :)
17:49:51 <c_wraith> *quote
17:50:04 <atondwal> fair, but the argument itself is a joke
17:52:21 <atondwal> but this is actually a thing! look at the instances for Data.Traversable http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html#line-237
17:53:01 <atondwal> the variable names we see: f, x, y, ys, arr
17:53:24 <atondwal> this is just a function of writing really very generic code
17:53:33 <geekosaur> I wouldn't call that hungarian notation. it *is* "thats all we know about it"
17:54:01 <geekosaur> high levels of abstraction bring their own problems when you can't say anything substantive about the abstract
17:54:27 <atondwal> right so if we called them fFunctionToTraverse that would be a (poor) use of hungarian notation
17:54:32 <geekosaur> (see also "generalized abstract nonsense")
17:54:43 <atondwal> but that's just adding stuff to the var name for no reason
17:55:33 <atondwal> alright I guess this is one of those jokes that was only funny to me
17:56:25 <geekosaur> it happens. I've dropped a few over the past few days that went flying overhead >.>
19:35:43 <ACheesyName> are multi parameter type classes "bad"? I get "Use MultiParamTypeClasses to allow multi-parameter classes"
19:36:35 <geekosaur> not bad, just not part of the standard
19:37:15 <geekosaur> they need either functional dependencies or type families to be usable, and both have roadblocks for inclusion in standard Haskell
19:38:00 <glguy> You won't need them for most Haskell you write, every once and a while they're useful though
19:38:13 <ACheesyName> what I really want to do is define a class for state machines https://repl.it/repls/SpitefulLightpinkRepositories is there a better way to do it?
19:38:40 <cocreature> why do you want to make this a typeclass?
19:39:10 <cocreature> I would probably just stuff those functions in a record and pass that around
19:39:40 <cocreature> there is way more than one reasonable state machine for two given types
19:39:57 <cocreature> so using a typeclass doesn’t make that much sense
19:41:51 <dyl> A good rule of thumb I’ve learned from experience is to invoke the principle of 0-1-2-many. 
19:42:07 <dyl> If there’s 1, use a typeclass. If there’s 2 of many use records. 
19:42:10 <dyl> or*
19:43:04 <dyl> I know the traditional formulation is 0-1-N, but there are special cases where 2 makes sense.
19:43:14 <dyl> (And they’re almost all of the special cases.) 
19:44:39 <dyl> But ACheesyName it’s worth considering that _some_ concerns may fit usage of a typeclass, while others may not.
19:44:47 <cocreature> it might be worth pointing out that it is about having 1 instance _per type_. I’ve also seen people reach for a typeclass when they only have one instance overall which is usually a case of premature abstraction
19:45:38 <dyl> Another helpful idea is to just, whenever you consider using a typeclass, try to think of at least three distinct (and not debug/trivial) instances. 
19:45:49 <glguy> So much help for one question with no follow ups :)
19:45:51 <dyl> Try to work through a few useful functions you could see applying generally. 
19:46:16 <dyl> If you can’t find them, a typeclass probably isn’t the move.
19:46:58 <dyl> Excessive concretion is bad, but so is excessive modularity. Use good judgement. 
19:47:10 <dyl> Excessive abstraction* (though still true with my brain fart)
19:49:01 <ACheesyName> well the idea is each state machine would have a different 'a type in my usecase. the typeclass is just there to typecheck that, e.g., initialize returns the same kind of thing that is taken by transition
19:50:49 <ACheesyName> but it sounds like multi-param typeclasses are difficult to set up so I'll probably take out the typeclass in that case
19:51:05 <glguy> It's just not the right choice for what you're doing
19:58:45 <energizer> Is there a compact list of what each piece of syntax means? just so i can reference it quickly to remind myself as I'm learning. `class Functor f where `, `instance Functor [] where`
20:00:00 <energizer> or maybe that's not syntax. but some small thing that i can quickly look at to remmber what all those things are called and what they do
20:01:53 <energizer> ah https://wiki.haskell.org/Keywords
20:02:09 <dmwit> http://cheatsheet.codeslower.com/CheatSheet.pdf maybe
20:05:22 <energizer> thanks
20:05:25 * hackage avro 0.4.1.1 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.4.1.1 (alexeyraga)
21:42:59 --- mode: glguy set +v philzook
21:46:49 <philzook> Hi, I was trying my first stab at using rewrite rules and was having a lot of difficulty getting anything to fire. Would someone be willing to take a look at my repo?
21:47:04 <philzook> https://github.com/philzook58/not-bad-ccc/blob/master/src/CCC.hs
22:36:31 --- mode: glguy set +v philzook
22:38:16 <nyc> I think I grok GADT's as phantom types now.
22:53:25 <bahamas> is there any reason why cabal doesn't automatically run `new-update` or `update` when it doesn't find the hackage package list?
22:55:44 <davean> yes
22:55:59 <davean> Thats a shocking event that changes how things work in the background without control of the developer
22:57:04 <bahamas> davean: what do you mean?
22:58:02 <geekosaur> for starters, you may not want it to make network accesses
22:58:30 <davean> bahamas: also it changes what packages are available so when you rebuild it it might get another build plan entirely
22:58:33 <geekosaur> for a second, if you're in a corporate context, you may well want to make it use a local repo instead of hackage
22:58:46 <davean> bahamas: you've just made a system-level change without prompting or warning
22:58:49 <geekosaur> and that
23:02:00 <bahamas> I think this is a matter of different philosophies. I don't see how it's a big deal that you downloaded the package index from hackage. you can delete it, if it's not what you want
23:02:25 <davean> Its a big deal because it can break random stuff on your system you aren't interacting with ATM
23:02:41 <bahamas> what can it break?
23:02:46 <davean> any haskell build
23:02:57 <jle`> hooray, haddocks working for GHC 8.6 with plugins again :D https://github.com/haskell/haddock/pull/983
23:03:28 <davean> and you wouldn't delete it - you'd pin it to the date stamp you had it at before
23:03:28 <bahamas> davean: sounds like the build process is fragile then, if just downloading a package index can break it
23:03:37 <davean> bahamas: no not at all
23:04:08 <davean> bahamas: The build process is context dependent specificly on that state and how ever tight you tighten it down from there.
23:04:20 <davean> You're specificly changing the one thing it is dependant on
23:04:26 <davean> without controls
23:05:26 <davean> if you want a specific build to happen say that
23:06:11 <bahamas> davean: I just want not to run a command which cabal can very well run by itself
23:06:16 <davean> even then though it has to be in context of the package index - if what the versions are aren't in your package index you can't configure that build so rolling back to a version before the specific build configuration won't work
23:06:28 <bahamas> davean: if there is no index present, it could assume there was no build done
23:08:58 <davean> Ok, well, even if that was true - which it isn't - you ready to pay everyone's multi-thousand dollar phone bill for accidently running that command when roaming internationally?
23:09:55 <davean> Because from what you've given you *can't know what the command will do until you run it*
23:16:17 <bahamas> davean: ok. I think there might a different approach to this. I'm talking in the context of just installing cabal. is it safe to assume that if you just installed it, then it would be safe for it to also download the hackage index?
23:17:05 <bahamas> it just looks pointless for cabal to tell me: I don't have the hackage index. here, call me with this command, so I can download it
23:18:35 <davean> that seems more reasonable but doesn't cover like the distro install approach well. One could argue an index should be bundled with that or a download option given at install time.
23:18:44 <davean> I will say I often use cabal with no index at all
23:20:31 <bahamas> maybe you do. I don't even know how I would use it without an index.
23:20:58 <davean> Well, to build a set of packages you already ahve
23:21:29 <bahamas> as an example, I was never asked to download the package index, when using pip (python equivalent)
23:21:37 <davean> or to build a package which only depends on OS provided packages.
23:21:46 <davean> It doesn't download it
23:21:51 <davean> It does an online search
23:22:17 <davean> which is also why you need all those virtualenv things in python
23:22:33 <davean> you were talking about unreliable builds ...
23:23:09 <bahamas> well, considering the phrase cabal hell, I don't think cabal fared any better until recently
23:23:59 <davean> Eh, there were solutions but they required learning, which people didn't like to do. I think we've recently reduced the amount of understandign required to get what msot people want most of the time
23:24:52 <davean> It always weirds me out how many people use a tool without reading the docs first
23:25:32 <bahamas> like I said, I think it's a matter of different philosofies. I believe that if you can make it easier for the user, you should
23:25:46 <davean> Sure
23:25:55 <davean> I'd agree - hence the new-build stuff
23:26:01 <davean> though that also makes it harder on the user
23:26:34 <davean> Mostly it allows all the options though and keeps people from shootign themselvesi n the foot without learning what they're doing first
23:27:06 <bahamas> maybe the power user. it's been mostly a pleasant experience. and it worked in cases when slack didn't
23:28:09 <bahamas> I meant to say "maybe it makes it harder for the power user". for a beginner like me, it made things easier
23:28:35 <davean> I've never liked starting as a beginner, personally I try to skip that stage.
23:30:08 <davean> I really don't get people's alergy to reading the documentation before doign something.
23:33:06 <uptick> hey while we're on the topic of cabal and those cabal commands and arguments, could someone take a look at a question i have that i posted on haskell's reddit page? :D
23:33:33 <davean> uptick: link?
23:33:44 <uptick> https://www.reddit.com/r/haskell/comments/a7wfkd/using_ghcup_to_setup_haskell_and_installing_cabal/
23:38:47 <uptick> pretty lengthy post - i apologize in advance :D
23:40:14 --- mode: glguy set +v cfraz89
23:40:15 <cfraz89> if you use new-build it will fetch it as needed
23:41:57 <cfraz89> installing dependencies manually is basically the v1 way of using cabal
23:43:25 <davean> cfraz89: it won't update the index automaticly
23:43:36 <davean> it downloads them when it configures if not told not to
23:43:54 <cfraz89> nope, but cabal new-update will update the index anyway right?
23:44:02 <cfraz89> which he's doing before updating cabal-install
23:46:42 <uptick> so new-install wont install the libraries, it will just fetch it as needed? whereas install will create the lib folder in ./cabal globally so it's there to be accessed all the time? i mean if both work, i should just new-install since the old way is going to be phased out?
23:48:20 <cfraz89> new-install does install the libraries too
23:48:30 <cfraz89> new-build will build your project, downloading dependencies as needed
23:48:36 <uptick> where though. i dont see any new folders :(
23:48:40 <cfraz89> it's likely what you want
23:49:08 <cfraz89> then once project's build, you can use new-exec to run
23:49:12 <davean> uptick: install puts it in ~/.cabal
23:49:17 <davean> by default
23:49:23 <cfraz89> or new-install project-name
23:49:32 <cfraz89> to install your own binary
23:49:41 <cfraz89> new-build builds into dist-newstyle by default fwiw
23:49:50 <cfraz89> in the project folder
23:51:53 <davean> new-install is pretty close to pointless for most scenarios outside of executables.
23:53:44 <uptick> i'm pretty much only using haskell 'cuz i need to download this cabal program
23:54:31 <uptick> so i don really have the need for any project build or need to separate these project environment
23:54:54 <uptick> so my best bet is to just use install then? have cabal put the stuff in my ~/.cabal
23:55:27 <cfraz89> hrmmm tidal looks like a library though...
23:55:29 <cfraz89> not a program?
23:55:46 <cfraz89> so assuming you have some code somewhere using it that needs building?
23:56:06 <uptick> ah yes library for making sounds. and i use it in emacs 
23:56:13 <cfraz89> ahhhh
23:56:20 <uptick> i got the tidal package from melpa to interface with it
23:56:36 <cfraz89> yeah i guess new-install would work for you then
23:56:40 <davean> Ah thats the core point here!
23:56:42 <cfraz89> pretty unusual use case
23:56:49 <davean> Because that *is* building stuff
23:57:02 <davean> and it needs to be able to find the right stuff
23:57:10 <uptick> so for my case, new-install or install? :D
23:57:17 <davean> I assume its using the global(ish) package space
23:57:30 <cfraz89> if new-install works for you, use it
23:57:35 <uptick> i mean from my testing both work
23:57:40 <cfraz89> its going to end up replacing install anyway as default
23:57:49 <uptick> new-prefix works ONLY if i add the --lib argument 
23:58:07 <uptick> whereas install with no argument works 
23:58:13 <davean> uptick: it doesn't really matter, new-install is probably cleaner but install will cause you to bump into any issues earlier. Basicly the only start to differ if you need more libraries for your use case
23:58:59 <cfraz89> install is effectively on its way to deprecation-land
23:59:19 <uptick> but how come tidal only works if i use the --lib argument when using new-install?
23:59:32 <cfraz89> just different semantics for the new-* commands
23:59:40 <cfraz89> since its a whole different subsystem
23:59:55 <cfraz89> i guess it makes sense, tidal is a lib after all
