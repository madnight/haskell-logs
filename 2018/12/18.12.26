00:13:20 * hackage salak 0.2.0 - Configuration Loader  http://hackage.haskell.org/package/salak-0.2.0 (leptonyu)
01:38:20 * hackage postgresql-simple-migration 0.1.13.1 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.13.1 (ameingast)
01:55:15 <Franciman> Hi
01:56:40 <Franciman> when publishing an executable on Hackage, should I also add: ghc-options: -O 
01:56:40 <Franciman> ?
01:56:45 <Franciman> in the cabal file?
02:01:20 * hackage yam 0.4.0 - Yam Web  http://hackage.haskell.org/package/yam-0.4.0 (leptonyu)
02:30:32 * hackage vabal 1.0.0 - the cabal companion  http://hackage.haskell.org/package/vabal-1.0.0 (Franciman)
04:04:49 <merijn> hmm, I need help coming up with a nice (short!) name for "f :: Monoid m => Bool -> m -> m; f b v = if b then v else mempty"
04:05:23 <mniip> "when", except that's taken
04:05:33 <merijn> mniip: That's my problem, yes :p
04:06:36 <mniip> generalize to Enum and call it "times"?
04:06:40 <mniip> False is 0 and True is 1 :P
04:08:39 <merijn> That's awful >.>
04:09:48 <dongcarl> In Haskell, is it possible to replace one function inside a library while leaving everything else intact?
04:10:50 * hackage cabal2nix 2.13 - Convert Cabal files into Nix build instructions.  http://hackage.haskell.org/package/cabal2nix-2.13 (PeterSimons)
04:10:51 <merijn> dongcarl: Without forking/otherwise creating a copy? No.
04:11:28 <piyush-kurur> dongcarl: do you mean something like import Foo hiding (foo); and then define foo the way you want but I suspect this is probably not what you really wanted
04:11:48 <merijn> I'd say this rather strongly depends on what he *really* wants :)
04:11:50 * hackage hopenssl 2.2.4 - FFI Bindings to OpenSSL's EVP Digest Interface  http://hackage.haskell.org/package/hopenssl-2.2.4 (PeterSimons)
04:12:23 <dongcarl> I want to replace the implementation for: https://hackage.haskell.org/package/xmonad-contrib-0.15/docs/src/XMonad.Util.NamedScratchpad.html#someNamedScratchpadAction, but I call https://hackage.haskell.org/package/xmonad-contrib-0.15/docs/src/XMonad.Util.NamedScratchpad.html#allNamedScratchpadAction directly
04:12:56 <dongcarl> specifically, the `W.shiftWin` is problematic for me because I don't always want the window at the top of the stack
04:13:29 <dongcarl> I guess I can just copy those over?
04:21:50 * hackage hasbolt-extras 0.0.0.14 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.14 (ozzzzz)
04:22:44 <merijn> dongcarl: I think there was an #xmonad channel too, they might have more useful feedback
04:23:00 <dongcarl> Right... Just trying to learn Haskell too haha
04:23:15 <dongcarl> Question: any way to import functions that are not exported?
04:23:26 <merijn> Also no
04:23:35 <dongcarl> :-/
04:26:21 <merijn> dongcarl: I think you should just be able to copy the someNamedScratchpadAction implementation and tweak it to your liking, though?
04:26:50 <dongcarl> merijn: Right... But it calls non-exported functions from that module...
04:27:01 <dongcarl> So I gotta copy everything over...
04:27:07 <merijn> hmm, which ones?
04:27:19 <dongcarl> `findByName`
04:27:22 <dongcarl> `runApplication`
04:27:55 <dongcarl> What I want to modify is really the `W.shiftWin` inside `someNamedScratchpadAction`
04:31:04 <merijn> dongcarl: There's basically two solutions: 1) patch xmonad-contrib to support what you want (for example, creating a version of someNamedScratchpadAction that takes W.shiftWin as argument) or 2) wrap someNamedScratchpadAction with a function that undoes the shifting
04:32:46 <Lears> If you want to extend the module without breaking its existing interface, xmonad-contrib is open to pull requests.
04:32:54 <dongcarl> merijn: Thanks for the help, I think I'll just do something hacky for now... Perhaps I can ask the xmonad people if it's possible to override the entire `XMonad.Util.NamedScratchpad` module with a local modified copy
04:33:45 <merijn> dongcarl: I mean, you can just clone it, modify locally and develop against the local clone
04:35:14 <merijn> dongcarl: I mean, modifying someNamedScratchpadAction could be as little work as defining someNamedScratchpadActionWith which takes a function as first argument (which you use instead of W.shiftWin) and defining someNamedScratchpadAction as "someNamedScratchpadActionWith W.shiftWin" that'd be backwards compatible and let you do whatever.
04:37:09 <dongcarl> This might be a stupid question but... it seems like I can just download https://github.com/xmonad/xmonad-contrib/blob/master/XMonad/Util/NamedScratchpad.hs and modify and import accordingly?
04:46:19 <ph88> can somebody help me read some code? i can't figure out where the contents of this file are being generated https://github.com/haskell/hsc2hs/blob/master/Main.hs#L130 
04:55:21 <lavalike> wasn't parallel part of the standard ghc distribution?
04:56:16 --- mode: glguy set +v zclod
04:58:48 <merijn> dongcarl: Sure, depends a bit on how you're building how to exactly do it, but shouldn't be hard
04:59:07 <dongcarl> Haha yeah I figured it out :-)
05:00:18 <lyxia> ph88: that outName gets passed to outputter, which is either outputCross or outputDirect.
05:00:36 <ph88> lyxia, yes there i'm getting lost in the outputter
05:00:52 <merijn> So, no naming suggestions for my monoid function?
05:00:58 <ph88> lyxia, i think there is a C file being generated with code in C.hs that in turn creates the .hs file
05:01:13 <ph88> i want to change the codegen for the hs file .. i think there is a bug in there
05:01:29 <ph88> but now i don't even get to see that C file that is being generated
05:01:36 <ph88> i think after it's being run it's being deleted right away
05:02:22 <lyxia> ph88: https://github.com/haskell/hsc2hs/blob/master/DirectCodegen.hs#L92 outName is passed here, so you have to find what process execProgName is.
05:02:53 <ph88> process ?
05:03:26 <lyxia> I would bet "rawSystemWithStdOutL" is spawning a process.
05:04:13 <ph88> ah great i found a --keep-files flag .. now the .c file is there
05:10:07 <zclod> hi i'm using beautiful folds library and I wonder why in the Scan/Folding typeclasses the arguments of the methods prefix and postfix are inverted wrt the standard fold/scan methods. If i want to use a L type as scanl I would expect to write (scanl prefix1 L) but the arguments are flipped. Am I missing something?
05:10:35 <merijn> zclod: What is the "beautiful folds" library?
05:10:47 <zclod> folds package
05:11:31 <Lears> merijn: Imo it's a competing implementation of 'when' (a better one), so you should actually just call it that and let any importer choose which one they want in their unqualified scope.
05:11:32 <merijn> Ok...I'm way too tired to make sense of that :p
05:11:55 <merijn> Lears: 1) I dislike confusing people and 2) I actually use when in this code too
05:12:36 <merijn> (people includes myself :p)
05:12:56 <merijn> I considered "whenM", but that seems confusing too
05:13:19 <Lears> Yeah, M suffix belongs to Monad; that ship's sailed.
05:14:13 <Lears> Imo the Applicative when should be whenA.
05:15:15 <Lears> Which is just \b -> getAp . when . Ap
05:15:35 <Lears> Err, s/when/when b/
05:19:20 <rorycrispin> Hey, I'm trying to come up with a type for addressing some data, I have this so far `data Target = Line Int | Register Char | Range (Target, Target)` But I only ever want Range to contain Lines or Registers so I feel like a recursive type is the wrong idea here - is there a better structure for this please?
05:20:16 <merijn> rorycrispin: eh... "data Target = Line Int | Register Char" and "data Range = Range Target Target"? >.>
05:22:56 <rorycrispin> @merjin okay thanks, should my functions all accept Either Range Target then?
05:22:56 <lambdabot> Unknown command, try @list
05:40:13 <seishun> what would be the best data structure for indexed updates with constant size?
05:42:21 * hackage LParse 0.3.0.0 - A continuation-based parser library  http://hackage.haskell.org/package/LParse-0.3.0.0 (Sacchan)
05:42:39 <sm> what are indexed updates ?
05:43:38 <seishun> updating the value at a given index
05:44:51 <sm> and constant size means the number of values is finite and doesn't change often, I guess
05:45:19 <seishun> yes, it doesn't change after creation
05:45:21 <tabaqui> Hey all
05:45:32 <sm> have you seen the array and vector packages ?
05:45:58 <seishun> I've looked at Array but couldn't figure out how to use it
05:46:00 <tabaqui> How should I use c2hs correctly? I have "foreign import WINDOWS_CCONV" that is compiled correctly in .hs error but raises parser error in .chs
05:46:11 * sm is guessing maybe MArray 
05:46:36 <tabaqui> *"is compiled correctly in .hs, but raises..."
05:48:06 <sm> import Data.Array.MArray, a <- newArray (0,10) 0  -- new mutable array of 10 zeros, I think
05:48:16 <merijn> sm: vector is the way to go if you only need 1D arrays
05:48:30 <merijn> @hackage vector
05:48:30 <lambdabot> http://hackage.haskell.org/package/vector
05:50:09 <seishun> this page says Vector should be included with Haskell Platform but I don't have it https://www.haskell.org/platform/contents.html
05:50:15 <sm> import Data.Vector.Mutable, a <- new 10  -- I guess
05:50:41 <merijn> seishun: There's two platforms installers "core" and "full"" and I think the latter is deprecated
05:51:49 <seishun> I see, it seems they stopped producing them https://github.com/haskell/haskell-platform/issues/318
05:52:14 <merijn> seishun: Stack and cabal should be easily be able to install it for you, though
05:57:42 <syntaxfree> sorry, what happened to haskell-blah?
05:58:04 <syntaxfree> also if there's a freenode channel about DSLs that helps too, but I planned on asking on -blah
05:58:39 * sm makes an MArray: a :: IOUArray Int Int <- newArray (0,10) 0
05:59:05 <merijn> syntaxfree: haskell-blah had different ops from #haskell, they insisted on making the channel require SSL to join, -offtopic was created as an alternative (with the same ops as #haskell)
05:59:17 <merijn> syntaxfree: Overtime I think most people have drifted to -offtopic
05:59:27 <syntaxfree> merijn: thank you very much. 
05:59:41 <merijn> syntaxfree: Not sure if anything specific happened to -blah to make you ask (as I drifted over a long time ago too :p)
06:02:45 * sm makes a mutable vector: a :: IOVector Int <- new 10
06:04:27 <seishun> why choose IOUArray over STUArray?
06:04:58 <sm> I don't know
06:05:26 <lavalike> because you also want to do IO
06:05:56 <seishun> and if I don't?
06:06:04 <lavalike> then you don't need the IO version
06:06:11 <ski> then `ST' is probably nicer
06:06:41 <lavalike> this might come in handy: https://www.vex.net/~trebla/haskell/annote-STArray.xhtml
06:06:52 * sm picked IO because ST probably required more import searching
06:06:55 <seishun> you can write a pure function that wraps ST unlike IO, right?
06:07:01 <ski> yes
06:07:28 <sm> I got the impression from some haddock that array was more efficient than vector for mutating a few elements in place without copying everything, is that wrong ?
06:07:34 <lavalike> that's the beauty of it, also remember that ST is a strict monad, that bit me in the past :D
06:08:51 <merijn> sm: It depends whether you use mutable vectors or not
06:09:15 <merijn> sm: Updating an immutable vector will copy everything (whereas Array will share slices, I tink)
06:09:27 <merijn> sm: But mutable vector should have 0 overhead
06:11:20 <sm> makes sense, thanks
06:12:44 <sm> then I think the main reason you'd choose arrays is if you want a non-single-integer index
06:13:52 <sm> an index that isn't a simple integer
06:27:50 <merijn> For some weird reason I can't get --enable-profiling compilation to work in my project, it fails in...GHCi?! I have no idea WTF is going
06:29:22 <merijn> looks like this error, except I don't use backpack: https://ghc.haskell.org/trac/ghc/ticket/14212
06:31:56 <merijn> So I just can't enable profiling for packages with TH? That seems a weird restriction
06:34:46 --- mode: glguy set +v TaufRaz_
06:41:29 <merijn> Ok, so any tips on figuring out the stack trace for a function without profiling?
06:45:47 <seishun> :t (- 2)
06:45:48 <lambdabot> Num a => a
06:46:00 <seishun> is it possible to write a function that subtracts two without a lambda?
06:46:21 <merijn> :t subtract
06:46:22 <lambdabot> Num a => a -> a -> a
06:46:28 <merijn> > subtract 2 3
06:46:30 <lambdabot>  1
06:46:35 <seishun> nice
06:46:44 <merijn> seishun: You're not the first to need that ;)
06:47:13 <ne> :t ((-)2)
06:47:15 <lambdabot> Num a => a -> a
06:47:26 <seishun> I guess they added it specifically for this use case
06:47:39 <merijn> ne: That means something different
06:47:42 <merijn> seishun: Yeah
06:47:55 <ne> oops
07:00:01 <epta> with GeneralizedNewtypeDeriving it's possible to `newtype A = A { unA :: Text } deriving IsString'. How to do the same using DerivingVia?
07:05:07 <seishun> if I use mapM in State monad, will the state be "updated" after each element?
07:06:49 <vaibhavsagar> seishun: yes, if you update the state in each action
07:08:20 <seishun> I see, thanks
07:08:25 <vaibhavsagar> > flip runState 0 $ mapM (\i -> modify' (+i)) [1..5]
07:08:27 <lambdabot>  ([(),(),(),(),()],15)
07:08:45 <vaibhavsagar> > flip runState 0 $ mapM (\i -> modify' (*i)) [1..5]
07:08:46 <lambdabot>  ([(),(),(),(),()],0)
07:09:26 <seishun> what's modify'?
07:09:35 <ski> @type modify'
07:09:37 <lambdabot> MonadState s m => (s -> s) -> m ()
07:09:55 <vaibhavsagar> it's a combination of get and put
07:09:56 <ski> given a state update function, modify the implicit state
07:10:13 <ski> iirc this one also forces the state
07:10:33 <vaibhavsagar> modify f === get >>= \a -> put (f a)
07:10:56 <vaibhavsagar> ski is right, there is modify and modify' that differ in terms of strictness
07:14:30 <merijn> oh god...
07:14:56 <merijn> System SQLite version is so ancient it doesn't support half of the SQL queries >.>
07:15:21 <vaibhavsagar> why do you need to depend on the system sqlite version?
07:16:09 <merijn> vaibhavsagar: I don't, persistent ship's with it's own copy, but I was using the executable to test stuff, but I can't test my queries because it's that damn old >.>
07:18:20 * hackage happstack-server 7.5.1.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.5.1.2 (JeremyShaw)
07:19:33 <vaibhavsagar> merijn: I see, good that it's not a showstopper
07:21:18 <merijn> vaibhavsagar: It's just death by 1000 papercuts of annoying problems >.>
07:21:40 <vaibhavsagar> just like all other software development :)
07:25:17 <sm> code golf/exploring haskell UX for simple console games: https://www.reddit.com/r/haskell/comments/a9olvk/how_to_change_the_mindset_to_fp/ecl714s/
07:30:05 <ACheesyName> is there anywhere I can get an approximate chart of haskell usage over time?
07:30:58 <ph88> is there a pragma to surpress (a particular) error for a single line ?
07:31:24 <cocreature> ph88: sadly no
07:31:53 <cocreature> there is an ancient issue for supressing warnings locally but nothing much has happened there recently
07:32:01 <ph88> ok
07:33:51 <merijn> Actually, looks like the day is partially saved...
07:34:18 <merijn> I need to rewrite a ton of shit to fix an issue, but I forgot SQLite added window functions recently! That'll make stuff a ton easier :D
07:34:50 * hackage happstack-server-tls 7.1.6.6 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.6.6 (JeremyShaw)
07:41:58 <sm> ACheesyName: not really. You could ask #hackage or #stackage for traffic stats
07:42:41 <sm> or you could look at creations of haskell projects on githubs
07:43:25 <sm> or the monthly traffic of haskell mail lists
07:44:30 <sm> or hackage package creation/release times
07:50:58 <Lears> I recall watching an SPJ talk that had some charts in it. It might have been this one: https://www.youtube.com/watch?v=06x8Wf2r2Mc
07:51:41 <sm> there's also the TIOBE and PYPL popularity indexes, which aren't much use
07:51:44 <merijn> Lears: FYI, those charts are completely made up :p
07:52:55 * hackage safecopy 0.9.4.3 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.9.4.3 (JeremyShaw)
08:09:24 <seishun> what's the general approach when you need `filter` both on lists and sequences?
08:10:04 <saml> :t filter
08:10:06 <lambdabot> (a -> Bool) -> [a] -> [a]
08:10:15 <saml> :i Seq
08:10:20 <saml> :t Seq
08:10:22 <lambdabot> error:
08:10:22 <lambdabot>     • Data constructor not in scope: Seq
08:10:22 <lambdabot>     • Perhaps you meant variable ‘seq’ (imported from Prelude)
08:11:09 <ClaudiusMaximus> seishun: qualified imports; eg:  import Data.Sequence(Seq) ; import qualied Data.Sequence as Seq ; ... Seq.filter ...
08:11:23 <saml> both Seq and List are monads, no?
08:11:35 <saml> there should be monadic filter
08:11:57 <ski> @hoogle MonadPlus m => (a -> Bool) -> m a -> m a
08:11:57 <lambdabot> Control.Monad mfilter :: (MonadPlus m) => (a -> Bool) -> m a -> m a
08:11:57 <lambdabot> Data.List.Class filter :: MonadPlus m => (a -> Bool) -> m a -> m a
08:11:57 <lambdabot> Control.Monad.Plus mreturn :: MonadPlus m => (a -> Maybe b) -> a -> m b
08:12:16 <ClaudiusMaximus> :t filterM 
08:12:17 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
08:12:44 <ski> that's different
08:13:11 <ski> > filterM (const [False,True]) "abc"
08:13:13 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
08:13:31 <ClaudiusMaximus> @check \f (xs :: String) -> filter f xs == mfilter f xs
08:13:31 <lambdabot>  <unknown>.hs:1:19:ScopedTypeVariables language extension is not enabled. Ple...
08:13:46 <ClaudiusMaximus> @check \f xs -> filter f xs == mfilter f (xs :: String)
08:13:48 <lambdabot>  +++ OK, passed 100 tests.
08:13:52 <ski> > mfilter (odd . fromEnum) "abc"
08:13:54 <lambdabot>  "ac"
08:14:40 <infinisil> There's mono-traversable's filter, which works on any kind of sequence: https://hackage.haskell.org/package/mono-traversable-1.0.10.0/docs/Data-Sequences.html#v:filter
08:15:07 <saml> > Seq.fromList "abc"
08:15:09 <lambdabot>  fromList "abc"
08:15:25 <saml> > mfilter (odd . fromEnum) $ Seq.fromList "abc"
08:15:28 <lambdabot>  fromList "ac"
08:15:34 <saml> heheheheehheehhehehehe
08:15:47 <ski> > Seq.filter (odd . fromEnum) (Seq.fromList "abc")
08:15:49 <lambdabot>  fromList "ac"
08:15:55 <saml> so, the answer is mfilter (odd . fromEnum)
08:16:45 <seishun> why does Data.Sequence provide a filter if mfilter works?
08:16:47 <saml> and now there can be surprising memory leak or excessive computation when using mfilter as opposed to filter, right?
08:17:50 * hackage happstack-authenticate 2.3.4.14 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-2.3.4.14 (JeremyShaw)
08:18:37 <saml> @src Seq.filter
08:18:37 <lambdabot> Source not found. You type like i drive.
08:18:49 <saml> probably Seq.filter is specialization
08:19:32 <seishun> like `Set.member` vs `elem`?
08:19:58 <seishun> I got burned hard on that one...
08:20:17 <saml> filter p = foldl' (\ xs x -> if p x then xs `snoc'` x else xs) empty
08:20:43 <saml> that's Seq.filter. how many runtime dispatching is going on??
08:21:32 <saml> mfilter p ma = do { a <- ma; if p a then return a else mzero }
08:22:00 <infinisil> mono-traversable's filter won't incur any runtime cost for sure btw
08:22:14 <infinisil> It's just a typeclass abstracting all the filter functions of different types
08:23:10 <saml>  filter f = fromList . List.filter f . otoList
08:23:30 <saml> looks like mono-traversable first converts to list?
08:23:37 <infinisil> That's just the default implementation
08:23:51 <infinisil> It gets overridden for the instances
08:24:48 <infinisil> https://hackage.haskell.org/package/mono-traversable-1.0.10.0/docs/src/Data.Sequences.html#line-914
08:25:24 <saml> filter = Seq.filter
08:26:46 <saml> So, Data.Sequences.filter gets inlined to either List.filter or Seq.filter?
08:27:20 * hackage reform 0.2.7.3 - reform is a type-safe HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.7.3 (JeremyShaw)
08:27:50 <ph88> does someone here has experience with C -> HSC -> HS conversion ?  https://bpaste.net/show/ef3dae3d7d56  i don't understand where the two Ptr on line 29 come from. Also i wonder what the type should be of the field on line 32 (which is now not correct)
08:28:07 <infinisil> saml: Yea
08:28:47 <infinisil> And it even works for Text and ByteString, which is neat
08:28:50 <infinisil> And Vector
08:33:30 <int-e> ph88: #globalvar PCRE2_SPTR8 , Ptr CUChar  is where they appear to come from... should that be another synonym_t?
08:34:01 <ph88> int-e, i only see one Ptr there .. i don't understand why i get two Ptr later
08:34:14 <int-e> ph88: the foreign import imports the *address* of a global variable called PCRE2_SPTR8.
08:34:23 <int-e> ph88: hence the second Ptr.
08:34:56 <saml> that's nice. 
08:34:57 <ph88> why add an extra pointer indirection ?
08:36:22 <int-e> ph88: Basically there are no foreign values in Haskell, only pointers to them.
08:37:00 <ph88> ok but i can just as well be pointing to the cost directly from haskell, no ?
08:37:19 <int-e> "cost"?
08:37:26 <ph88> const   online 5
08:37:28 <ph88> 4*
08:37:35 <ph88> ah wait i get it .. then i would have a haskell pointer and a C pointer pointing to the same thing. If one of them changes i'm fucked
08:37:41 <int-e> ph88: that line is a type definition
08:37:57 <int-e> ph88: that's why I asked whether you really wanted another synonym_t.
08:38:41 <ph88> int-e, i didn't write the original header file. What do you mean "another" synonym_t  i just see one
08:39:21 <int-e> ph88: did you write the HSC file?
08:39:30 <ph88> i think the synonym_t is irrelevant here
08:39:32 <ph88> all files are generated
08:39:33 <int-e> ph88: because that isn't aligned with the C header.
08:39:36 <ph88> c2hsc & hsc2hs
08:40:06 <int-e> So c2hsc is going wrong.
08:40:23 <ph88> i don't see it going wrong, what do you mean ?
08:40:23 <int-e> Maybe it's being confused by the 'const'.
08:41:08 <int-e> ph88: typedef const PCRE2_UCHAR8  *PCRE2_SPTR8;  doesn't declare a global variable. It declares a type alias, PCRE2_UCHAR8.
08:41:32 <ph88> aah like that
08:42:15 <ph88> #synonym_t PCRE2_UCHAR8 , Ptr CUChar   should be this then ?
08:42:42 <int-e> yes. (since there's not way of expressing the const part in the FFI, as far as I know)
08:43:27 <ph88> c2hsc does a 80% conversion (from the README)
08:43:31 <ph88> i'm already using sed for other things
08:43:35 <ph88> i'll add this
08:43:55 * hackage userid 0.1.3.3 - The UserId type and useful instances for web development  http://hackage.haskell.org/package/userid-0.1.3.3 (JeremyShaw)
08:45:45 <int-e> ph88: That said, whenever you declare a global variable, when you import it, you'll be importing its address as a Ptr value; note that you cannot change that pointer, it's more like a reference in C++.
08:46:29 <ph88> got it
08:47:54 <ph88> wow
08:47:56 <ph88> it ..
08:47:58 <ph88> compiles xD
08:48:23 <ph88> 1800 lines of haskell code without any further error
08:48:27 <ph88> that's a pretty good conversion tool
08:53:22 <ph88> for FFI do i need unsafePerformIO ?
08:54:01 <Solonarv> Sometimes
08:55:15 <Solonarv> If you're importing a pure function and you give it a Haskell-side type like 'Int -> Int', GHC will more or less automatically insert an unsafePerformIO
08:58:50 <Solonarv> well, you can do this for non-pure functions as well, but that's not a good idea.
09:08:14 <_deepfire> Sometimes GHC adds a kind variable to the explicit list of type variables you provide for a top-level binding.
09:08:30 <_deepfire> How do you determine what causes it to do so?
09:08:54 <_deepfire> I've provided explicit kinds for all type vars, but GHC insists it needs the kind var..
09:11:01 <Solonarv> It happens any time a kind is needed, I think?
09:11:39 <_deepfire> I think that's more like when GHC thinks there is a type that is kind-polymorphic
09:12:08 <_deepfire> But I think I nailed down all type vars to a monomorphic kind..
09:12:11 <ph88> must i copy values over FFI or can i pin ghi memory ?
09:12:47 <Solonarv> Haskell values can be pinned, but I'm not familiar with the details
09:13:10 <Solonarv> for example, ByteString is always pinned
09:14:38 <_deepfire> I must be wrong somewhere, but the problem is I lack tools to figure out _where_ I'm wrong..
09:16:05 <Solonarv> What's the code that's exhibiting an unexpected kind var?
09:19:50 * hackage hsx2hs 0.14.1.4 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.14.1.4 (JeremyShaw)
09:19:54 <lyxia> there's probably some GHC option to print the complete kind signature, so you can see where that extra kind is used
09:20:11 <_deepfire> Solonarv: thank you for caring to ask! I'm afraid it's not sufficiently compact for a presentation, though..
09:20:21 <_deepfire> lyxia: interesting!  Will look..
09:23:23 <_deepfire> and indeed, -fprint-explicit-kinds does exist!
09:24:08 * _deepfire makes a mental note to RTFM harder next time he needs more information from the compiler..
09:24:23 <_deepfire> lyxia: thank you!
09:24:49 <Solonarv> You can also add -fprint-explicit-foralls
09:30:50 * hackage web-routes-th 0.22.6.4 - Support for deriving PathInfo using Template Haskell  http://hackage.haskell.org/package/web-routes-th-0.22.6.4 (JeremyShaw)
09:32:39 <_deepfire> Good point, thanks!
09:36:07 <ph88> Text is utf-16 right ?
09:36:23 <merijn> ph88: Internally it uses utf-16, yes
09:36:31 <ph88> why not utf-8 ?
09:36:48 <merijn> Because the last time someone implemented a utf-8 version it was slower
09:37:01 <ph88> wow really
09:37:11 <ph88> is there even an utf-8 type in haskell ?
09:37:26 <merijn> ph88: What do you mean by "utf-8" type?
09:37:52 <ph88> internally use utf-8
09:37:56 <lyxia> there's text-utf8
09:38:01 <ph88> ah ok
09:39:58 <Solonarv> if you want to pass UTF-8 text to some C code you can also use Data.Text.encodeUtf8 and Data.ByteString.useAsCString
09:40:54 <_deepfire> Turns out it's insufficient to provide a kind sig to the class' method's forall bindings -- they're needed in the TC head as well.
09:43:05 <_deepfire> As far as I was able to find out, the method's forall bindings might have monomorphic kinds, but the instances will be still treated as potentially kind-polymorphic.
09:43:31 <_deepfire> ..unless the TC head's vars are also declared to be kind-monomorphic.
09:44:43 <ph88> how can i use c2hs to create a hs file? the readme talking about a chs binding module file which i don't have
09:45:16 <lyxia> _deepfire: indeed
09:50:52 <nan`> is there any way to get the currently building 'PackageDescription' in template haskell?
09:52:19 <nan`> like im in TH and i want to know the cabal information for the current build process
09:56:41 * hackage happstack-server-tls 7.1.6.7 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.6.7 (JeremyShaw)
09:58:20 * hackage morphisms-functors 0.1.3 - Functors, theirs compositions and transformations  http://hackage.haskell.org/package/morphisms-functors-0.1.3 (iokasimovmt)
10:09:50 <binq> @jle` going through your excellent "Introduction to Singletons," on part 3 now!
10:09:50 <lambdabot>  Parse failed: Parse error: EOF
10:11:07 * hackage web-plugins 0.2.9.1 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.9.1 (JeremyShaw)
10:11:39 <Solonarv> binq: you don't need an @ to mention people :>
10:12:00 <binq> I do have a @
10:12:07 <binq> oh don't
10:12:10 <binq> ok thanks
10:15:37 <Solonarv> no, I mean you don't need to (for example) type @Solonarv to mention me; the name is enough, no special characters needed
10:15:48 <binq> ok
10:38:40 <seishun> is there a way to get useful call stacks in ghci? mine just says "error, called at libraries\\containers\\Data\\Sequence\\Internal.hs:2055:7 in containers-0.6.0.1:Data.Sequence.Internal"
10:39:57 <phadej> I think you (or some lib you use) did something violating invariants of Seq
10:40:16 <ym555> https://downloads.haskell.org/~ghc/6.12.1/docs/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
10:40:32 <ym555> https://donsbot.wordpress.com/2007/11/14/no-more-exceptions-debugging-haskell-code-with-ghci/
10:40:43 <ym555> seishun: i think this is what you need?
10:40:56 <seishun> yeah ":set -fbreak-on-exception" and ":trace myfun" did the trick
10:41:27 <phadej> There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger
10:42:07 <seishun> and the issue was `[0..length groups]`... forgot to add `- 1`
10:42:32 <ym555> classic 
10:43:33 <phadej> advice: rethink your problem not ot use indices
10:43:56 <phadej> it might be a puzzle, but hopefully a rewarding one
10:45:00 <phadej> e.g. using foldrWithIndex or something else *WithIndex
10:45:05 <seishun> yeah, I know, this is a temporary solution
10:45:27 <phadej> Nothing is more persistent than temporary solution. (Finnish proverb)
10:45:57 --- mode: glguy set +v i8hantanu
10:50:43 <ph88> how can i convert from Word32 to Int ?
10:51:13 <Ke> fromIntregral iirc
10:51:54 <Ke> or do you need a safe conversion?
10:52:12 <Tuplanolla> You can use `fromEnum` too.
10:52:19 <ph88> it's the size of a piece of memory i want to allocate
10:52:30 <ph88> https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-C-Types.html#t:CSize
10:52:37 <ph88> Word64 by the way
10:52:48 <ph88> https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Alloc.html#v:callocBytes
10:53:11 <Ke> could it be more than 2GiB?
10:54:34 <Ke> I don't even know what fromIntegral does on error conditions, does it just do what is convenient in asm or throw an exception
10:54:38 <ph88> that's very unlikely
10:55:28 <bifunc2> I've been using https://hackage.haskell.org/package/lmdb-simple-0.4.0.0
10:55:28 <bifunc2> Does anyone here know if individual puts (one per transaction) is any less efficient than a bunch of puts per transaction?
10:55:40 <bifunc2> Sorry for the LMDB question, but I don't see an LMDB channel..
10:56:01 <_deepfire> phadej: quite well-known among Russian people as well..
10:57:25 <c_wraith> bifunc2: in a typical ACID environment, the answer is often "it could be either, benchmark"
10:58:13 <c_wraith> bifunc2: sometimes transaction open/close overhead is significant enough that you want to do as much as you can in one transaction.  sometimes the overhead scales superlinearly with the number of operations in the transaction.  Sometimes both are factors.
10:59:21 * hackage boomerang 1.4.5.6 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.4.5.6 (JeremyShaw)
11:00:13 <monochrom> Ke: Depends on the actual types but most of them do truncation, no error.  You should check.
11:00:49 <monochrom> Perhaps s/check/test/
11:01:23 <c_wraith> also, it *should* depend only on the output type.  toInteger should always be exact, so it's only fromInteger that makes choices
11:01:36 <monochrom> Yeah.
11:01:38 <c_wraith> Of course, something could always have a sketchy Integral instance.
11:02:43 <Ke> well in this case it's Int and you will have an error condition
11:02:59 <bifunc2> c_wraith ok, thank you
11:03:34 <monochrom> > fromIntegral (283947839247839247893247892594805 :: Integer) :: Int
11:03:35 <lambdabot>  -7292132254909259659
11:03:38 <monochrom> There.
11:04:34 <Ke> heh, though Word64 is easier, you could truncate to 31 bits and always get at least the sign right
11:04:54 <Ke> though then casting bak would get you a bigger error
11:04:58 <Ke> back
11:05:40 <monochrom> Um I thought it's idempotent? Not bigger error after more iterations?
11:05:49 <phadej> _deepfire: :)
11:05:57 <monochrom> > fromIntegral (fromIntegral (fromIntegral (283947839247839247893247892594805 :: Integer) :: Int) :: Integer) :: Int
11:05:59 <lambdabot>  -7292132254909259659
11:06:07 <Solonarv> Int is larger than Word32, so a Word32 -> Int conversion should be lossless
11:06:32 <Ke> huh?
11:06:42 <monochrom> Ah but Int depends on GHC bitsize.  There is 32-bit GHC and 64-bit GHC.
11:06:44 <Ke> is haskell Int 64 bit
11:06:51 <glguy> Int is guaranteed to be at least 29 bits
11:06:57 <monochrom> n-bit GHC gives n-bit Int and Word.
11:07:00 <Solonarv> I thought it was more than that?
11:07:24 <monochrom> Hey so everyone "thinks" without testing and without empirical evidence?
11:07:25 <Solonarv> let me find a source
11:07:43 <Solonarv> Ah, it is indeed at least 29 bit. I misremembered.
11:07:57 --- mode: glguy set +v void404
11:08:29 <monochrom> Did you know that's how classical Greek philosophers, even the greatest blockbuster ones, "thought" that when an object falls it falls at constant speed no acceleration? Even after they saw that a stream of water breaks after falling a large distance?
11:08:59 <glguy> [-2^29 .. 2^29-1] more specifically
11:09:03 <monochrom> Because they loved to think and never thought of testing.
11:09:13 <glguy> You get a sign bit, too
11:09:40 --- mode: glguy set +v i8hantanu
11:10:47 <ph88> when i pass a null StablePtr to a C external library can it be mutated by that library ?
11:11:33 <Ke> monochrom: that could have been caused by eg. surface tension
11:11:34 <monochrom> What is "it"? The pointer itself?
11:12:20 <ph88> yes the pointer itself
11:12:29 <Solonarv> If you pass a pointer to a C library, the C library can mutate the target of that pointer (if the pointer is valid), but it can't change what the pointer points to
11:12:46 <Ke> you can always tweak your model a bit, only after quite a bit of tweaking you might notice the model is bad
11:12:58 <monochrom> OK I know how to answer after you answer this question. When I pass a number 4 to C, can 4 be mutated by C code?
11:13:55 <ph88> ok ok ^^
11:16:15 <monochrom> Solonarv: "target of pointer" is not "what the pointer points to"?
11:16:46 <Solonarv> Bah, words are complicated
11:17:03 <sonofentropy> hi, what are you favourite examples of clever pattern matching in haskell code?
11:17:18 <Solonarv> In this context, I meant: "what the pointer points to" = address; "target of pointer" = value(s) at that address
11:19:20 <Tuplanolla> :t \ x -> case x :: Void of {} -- sonofentropy
11:19:21 <lambdabot> Void -> p
11:19:36 <monochrom> My favourite example is extremely dumb code that refuses to use pattern matching; furthermore refuses to even refactor. Therefore, compared to that, even vanilla "case ... of [] -> ... x:xs -> ..." is pretty clever.
11:20:14 <monochrom> I had student code that went like "f xs = ... head (tail (tail xs)) ... head (tail (tail xs)) ... head (tail (tail xs)) ..." it's an eyesore.
11:20:38 <Solonarv> Do view patterns count? They can be pretty neat.
11:21:22 <Solonarv> Relatedly, pattern guards
11:21:29 <sonofentropy> Solonarv: sure ^w^
11:21:51 <Tuplanolla> Looks like `LambdaCase` cannot handle empty matches.
11:22:12 <sonofentropy> Tuplanolla: could you tell me more about you case? I don’t get it O.o
11:22:33 <Solonarv> % :t (\case{}) :: forall a. Void -> a
11:22:34 <yahb> Solonarv: Void -> a
11:22:41 <monochrom> Tuplanolla: If it were supported, would the syntax be "(\ -> )"? >:)
11:22:54 <Tuplanolla> Oh, nice, it does.
11:23:02 <Tuplanolla> Since `Void` has no constructors, you have no cases to match, sonofentropy.
11:23:03 <monochrom> Oh! It works, just need layout
11:23:23 <Solonarv> Just like empty case normally does, I think?
11:23:31 <Tuplanolla> Actually...
11:23:39 <Solonarv> It might work without layout in some situations
11:23:41 <monochrom> % :t (\case)
11:23:41 <sonofentropy> oh, that’s interesting 
11:23:41 <yahb> monochrom: p1 -> p2
11:23:42 <Tuplanolla> :t \ case
11:23:43 <lambdabot> p1 -> p2
11:23:54 <monochrom> Neato.
11:24:28 <ski> @type \case {}
11:24:29 <lambdabot> p1 -> p2
11:24:53 <ph88> i want to export some function pointer to be used in an external C library. I can do this per function call. But i think it's more efficient to do it at the start and end of the haskell program. However i'm making a library so how do i make sure the user of my library does the initialization ?
11:25:11 <monochrom> p1->p2 is right because nothing says that you are not attempting a deliberately non-exhaustive thing.
11:25:38 <glguy> If you use empty case with a nonempty type it just generates a default case that throws a pattern match fail error
11:25:56 <monochrom> Yeah Haskell is still a partial function language.
11:26:04 * hackage elf 0.30 - An Elf parser  http://hackage.haskell.org/package/elf-0.30 (wangbj)
11:26:05 <Solonarv> ph88: write a function 'initMyLibrary :: IO MyLibraryContext', and make your functions take a 'MyLibraryContext' argument
11:26:39 <ph88> Solonarv, i'm also considering putting the whole thing in a ResourceT or something .. maybe that would also work ?
11:27:00 <ski> > (\case {}) (undefined :: Void)
11:27:01 <lambdabot>  *Exception: Prelude.undefined
11:27:05 <ski> > (\False -> ()) True
11:27:07 <lambdabot>  *Exception: <interactive>:3:2-13: Non-exhaustive patterns in lambda
11:27:10 <Solonarv> Yes, that works too
11:27:10 <ski> > (\case {False -> ()}) True
11:27:12 <lambdabot>  *Exception: <interactive>:3:2-20: Non-exhaustive patterns in case
11:27:44 <ph88> what should i choose?  'initMyLibrary :: IO MyLibraryContext'   or  ResourceT  ?
11:27:56 <Solonarv> Depends on the library
11:28:09 <monochrom> ResourceT incurs an extra dependency.
11:29:00 <ph88> if i use  'initMyLibrary :: IO MyLibraryContext'   do my users have to pass the context all over the place ?
11:29:12 <monochrom> Yes. Both of you do.
11:29:15 <ph88> maybe after the init call there is some way to hide the context ?
11:29:20 <ph88> for the user
11:29:27 <monochrom> That would be ReaderT
11:29:44 <Solonarv> (or your own monad transformer based on ReaderT)
11:30:10 <Solonarv> (that's actually how ResourceT is implemented internally)
11:30:18 <ph88> how would it look for the user   after the init function ?
11:30:58 <ph88> ah he has to do  runReader
11:31:01 <ph88> i get it
11:31:21 <Solonarv> Or: runMyLibraryT $ do blah blah
11:32:02 <Solonarv> with runMyLibraryT :: MyLibraryT m a -> m a
11:32:13 <Solonarv> (plus some constraints on 'm')
11:32:28 <phadej> withMyLibrary :: (MyLibraryContext -> IO r) -> IO r
11:32:32 <phadej> if context needs clean-up
11:32:41 <sonofentropy> Solonarv: thanks for mentioning view patterns, I wasn’t aware of them, neat stuff
11:32:41 <ph88> yes needs cleanup too
11:33:34 <Solonarv> Yeah, phadej's suggestion is actually equivalent to ReaderT / a custom transformer
11:33:35 <ph88> but i guess for short lived programs it will be automatically cleaned when the program ends
11:33:53 <ph88> maybe i can implement both and the user can choose if he wants to enforce cleanup or not
11:34:12 <phadej> well, it's better to use with* pattern, and use bracket to implement it
11:34:22 <phadej> than when "small program" becomes "big program" you don't need to worry
11:34:36 <Solonarv> It's still useful to expose standalone init/free functions, I think
11:35:03 <ph88> i've read that ResourceT is like a better version of bracket
11:35:10 <phadej> Solonarv: yes, and you need them to implmenet `with*` (using `bracket`)
11:35:21 <phadej> err, "better" is not onedimensional thing
11:36:23 <phadej> even the author itself says:
11:36:24 <phadej> Summary: ResourceT is a great tool, used to solve real problems when dealing with constrained resources and runtime exceptions. However, in the wild, it is often overused for situations where its full power isn’t needed. If you want more information on ResourceT, c
11:36:56 <phadej> https://www.fpcomplete.com/blog/2018/10/resourcet-necessary-evil
11:37:09 <phadej> also tl;dr if you don't use conduit, you don't need resourcet :)
11:39:01 <phadej> and even in conduit "static" resource allocations is simpler without resourcet
11:40:47 <ph88> should i put the bracket function in my library or let the user use it ?
11:41:10 <phadej> you should put withMyLibrary in your library
11:41:11 <Mrbuck> hey any devop here working or using haskell ? I got a new job where software defined networking is needed .....I will be using tools like docker, kubernetes, jenkins
11:43:24 <Solonarv> expose the following functions (for init/cleanup): 'initBlah :: IO BlahContext, cleanupBlah :: BlahContext -> IO (), withBlah :: (BlahContext -> IO a) -> IO a'
12:07:46 <ph88> how do i get a StablePtr to Text ?
12:11:53 <phadej> `newStablePtr`?
12:12:46 --- mode: glguy set +v fpnewb
12:12:51 * hackage harp 0.4.3.2 - HaRP allows pattern-matching with regular expressions  http://hackage.haskell.org/package/harp-0.4.3.2 (JeremyShaw)
12:13:10 <chessai> ph88: are you asking for a function of type `StablePtr a -> Text`?
12:14:14 <ph88> chessai, Text -> StablePtr ??
12:14:23 <ph88> i don't know if i'm suppose to unwrap the Text
12:14:27 <chessai> ph88: what phadej said then
12:14:37 <ph88> when i look at the definition there is a lot more stuff in there which is not the raw text
12:14:47 <chessai> ph88: newStablePtr :: Text -> IO (StablePtr Text)
12:15:09 <ph88> ok but how can i be sure that i'm just pointing to the beginning of the text ?
12:15:14 <lyxia> well Text is a record
12:15:59 <phadej> if you want to pass ptrs to C,maybe you should use http://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Foreign.html ?
12:16:33 <chessai> ph88: i guess you could discard the slicing information (offset, length) and just create a StablePtr to the underlying array 
12:16:38 <chessai> cool package phadej
12:16:49 <chessai> oh
12:16:53 <chessai> thats just in text, duh
12:17:00 <phadej> :)
12:17:03 <chessai> for some reason i thought it said 'text-foreign' in the url
12:17:30 <ph88> i didn't find a useful function there
12:17:41 <chessai> ph88: what are you trying to do
12:17:43 <phadej> useAsPtr ?
12:17:48 <phadej> I guess that's what you want
12:17:52 <phadej> but yes, what you try to do
12:17:58 <phadej> I sense a strong XY-problem her
12:18:06 <ph88> get a StablePtr Word16   from Text
12:18:09 <phadej> too little details on a big goal
12:18:17 <phadej> wjy StablePtr, and not ForeignPtr or ptr?
12:18:24 <ph88> because i want to pin memory
12:18:30 <c_wraith> StablePtr doesn't pin memory
12:18:58 <ph88> In some cases, you may want to give to the foreign code an opaque reference to a Haskell value that you will retrieve later on. You need to be sure that the value is not collected between the time you give it and the time you retrieve it. Stable pointers have been created exactly to do this. You can wrap a value into a StablePtr and give it to the foreign code (StablePtr is one of the marshallable foreign types).
12:19:02 <ph88> i want to do this
12:19:08 <c_wraith> it's just a hash table from ids that happen to be compatible with void * in C to Haskell values.  The Haskell values can still be moved around.
12:19:12 <geekosaur> where did you findthat text
12:19:21 <ph88> https://wiki.haskell.org/Foreign_Function_Interface
12:19:39 <c_wraith> that text doesn't say that memory is pinned
12:19:50 <ph88> i want to do what is in the text i just pasted
12:19:53 <c_wraith> It says that the StablePtr will remain valid
12:19:55 <geekosaur> StablePtr is for Cloud Haskell, a stable name for a movable value that Haskell but not C can deal with.
12:20:10 <c_wraith> geekosaur: StablePtr long predates Cloud Haskell
12:20:39 <geekosaur> mr, confusing it aren';t I
12:20:42 <ph88> i get a Ptr from the StablePtr before i pass it to C code
12:20:49 <c_wraith> what?  no, that's entirely wrong
12:20:51 <comerijn> StablePtr is just for keeping Haskell values life across GC when their might be no root on the Haskell side
12:20:54 <phadej> don't confuse StablePtr with StaticPtr
12:20:59 <geekosaur> rigjt
12:21:04 <c_wraith> Don't ever get a Ptr from a StablePtr
12:21:13 <c_wraith> you'll break all sorts of things
12:21:34 <phadej> ph88: use `useAsPtr`
12:21:37 <c_wraith> what do you *actually* want to do?
12:21:39 <phadej> it will give you a Ptr
12:21:45 <phadej> to the textual contents
12:21:50 <phadej> and manage copying/freeing
12:22:58 <ph88> i have an external library function which wants a   Ptr CUShort    I have a Text and i don't want to copy the value. I want to go from Text to Ptr CUShort
12:23:07 <phadej> you have to copy
12:23:17 <phadej> that's the cost of FFI
12:23:24 <ph88> o_O
12:23:38 <c_wraith> the C code could mutate the array
12:23:46 <c_wraith> The only way to make that safe is to copy
12:23:46 <phadej> you move from managed memory to unmanaged
12:23:47 <phadej> that's not free
12:24:14 <geekosaur> if you know wiith complete certainty the C code only reads, theres probably some unsafe function
12:24:22 <geekosaur> if you lie to it, it will bite you
12:24:44 <phadej> the contents of text may move
12:24:55 <c_wraith> lying to the FFI is a great way to segfault your programs. :)
12:24:58 <ph88> how do i prevent GC from moving the memory around when external function is called ? or is this implicit ?
12:25:22 <phadej> just don't. believe. Make it the simple way, and then worry about performance
12:25:39 <Tuplanolla> Isn't that what `ForeignPtr` is for?
12:26:00 <ph88> i thought that's what StablePtr is for
12:26:09 <phadej> Tuplanolla: text isn't backed by ForeignPtr
12:26:19 <c_wraith> Tuplanolla: ForeignPtr is for calling a native deallocator when the haskell Ptr gets GC'd
12:26:40 <Tuplanolla> Right you are.
12:26:42 <geekosaur> Text doesn;t. ByteString dos (and uses pinnd memory,which si allocated separately)
12:26:59 <c_wraith> ph88: StablePtr is for passing an *opaque* pointer to C memory.  It's unusable from C.
12:27:10 <geekosaur> thsi implies you don't pin a pointer, although you may get certain guarantees over a single FFI call
12:27:16 <c_wraith> ph88: it's only for APIs that use callbacks and pass void * around
12:28:00 <Tuplanolla> I have been lucky enough to not do this very often.
12:28:05 <ph88> why can't i point it the the Text then ?
12:28:13 <c_wraith> because that's not what it does
12:28:19 <c_wraith> it does not point *to* anything
12:28:23 <c_wraith> it's fake
12:28:36 <c_wraith> it's just a reference to a Haskell value in a hash table managed by the RTS
12:28:36 <ph88> it's not a value ?
12:28:39 <c_wraith> no
12:28:58 <ph88> what hash table is this ?
12:29:08 <c_wraith> hidden somewhere in the RTS.  don't worry about it
12:29:18 <ph88> what is the purpose of this hash table ?
12:29:26 <c_wraith> to make it work
12:29:28 <glguy> What if ph88 asked harder, could he get zero copy marshalling for Text?
12:29:29 <c_wraith> don't worry about it
12:29:51 <c_wraith> the important part is that a StablePtr should only be passed to an API asking for a void *
12:30:09 <phadej> glguy: make a lib with `Text` interface but using `ForeignPtr` as the backing implementation, with all pros and cons
12:30:38 <c_wraith> because StablePtr values *aren't pointers*
12:30:52 <c_wraith> they just happen to be compatible with the native representation of void *
12:30:54 <glguy> If I was working such a library, it would use utf8 instead of 16
12:31:37 <phadej> glguy: well, that's different design decisions
12:31:42 <phadej> there _is_ text-utf8
12:31:55 <c_wraith> ph88: just copy.  It's the correct thing to do.
12:32:11 <c_wraith> ph88: if you wanted to write broken fast code, why not skip the FFI entirely?
12:32:37 <c_wraith> ph88: it's a lot simpler and faster if you don't care about not crashing
12:33:19 <comerijn> So, suppose I have a text the includes escaped characters (\n, etc.) is there an easy way to "unescape" them?
12:33:58 <phadej> > readMaybe "\"foo\\nbar\"" :: Maybe String
12:34:00 <lambdabot>  error:
12:34:00 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe String
12:34:13 <glguy> You'd have to implement an function that implements the particular escaping syntax you have in mind
12:34:16 <comerijn> phadej: There's more junk in there, so that's not gonna fly
12:34:19 <ph88> c_wraith, i would like to call an external C library from my haskell. It can skip FFI ? o_O
12:34:25 <comerijn> glguy: Really just \n, tbh
12:34:44 <glguy> That's going to make it pretty easy for you to implement
12:34:47 <geekosaur> I'd just pattern match it away unless I knew for certain no other \s mattered
12:35:08 <comerijn> glguy, geekosaur: I just want my error handling to print my SQL queries as something readable rather than 100 line queries concatted to a single giant line >.>
12:35:54 <comerijn> I suppose just T.replace "\\n" "\n" should work...
12:36:20 <glguy> As long as you don't support escaping backslash
12:36:20 <geekosaur> if I reallyc ared Id' see if someone came up with an SQL prettypritnr >.>
12:36:41 <comerijn> geekosaur: Not yet, afaik, because I have looked before :p
12:36:41 <geekosaur> (realy wouldn't surprise me)
12:36:47 <geekosaur> oh well
12:36:51 <comerijn> geekosaur: Also, there are C function prepended too
12:36:53 <ph88> When i have a (Text (Array ByteArray# Int) Int Int)  (all data constructors)  and i read "Bytestrings are currently allocated as pinned memory, so that the bytestring contents can be passed to FFI calls if necessary." how do i get a pointer to ByteArray# and read the text from external library  ?
12:37:14 <phadej> bytestring and bytearray# is different things
12:37:18 <ph88> hmm ok
12:37:21 <comerijn> ph88: You are making your life unnecessarily difficult
12:37:41 <comerijn> ph88: And when you see ByteArray# you really *don't* want to head further in that direction unless you know what you're doing
12:37:45 <ph88> comerijn, i tend that do that sometimes, but it's a matter of understanding as well
12:38:41 <comerijn> hmmm, apparently T.replace is *not* enough...
12:38:46 <ph88> i really really like to do zero copying and FFI
12:39:21 <geekosaur> youa re working with haskell, you should get over that
12:39:41 <comerijn> Ah...maybe I should just apply things to the actual right data >.>
12:39:43 <geekosaur> unless you really like sharing an address space with a malevolent agent of chaos
12:39:57 <phadej> yes, more constructive is to reimplement the FFI part in Haskell
12:40:09 <ph88> i don't mind trying and finding out it wasn't a good idea
12:40:11 <phadej> or do so much stuff there that copying is not a problem perforamce-wise
12:53:37 <mpickering> Is there an equivalent of `to` for setting (using lenses)?
12:54:02 <mpickering> Something like `(a -> s -> s) -> Setter s s a a`
13:02:02 <glguy> mpickering: it's likely to be in Control.Lens.Setter
13:02:26 <mpickering> `sets` seems to have approximately the right type 
13:02:29 <mpickering> thanks!
13:11:53 * hackage forsyde-shallow 3.3.3.0 - ForSyDe's Haskell-embedded Domain Specific Language.  http://hackage.haskell.org/package/forsyde-shallow-3.3.3.0 (ugeorge)
13:15:51 <comerijn> ok, so dumb SQL question: What JOIN do I want if I have two tables A and B and want every row in A concatted with every row in B? cross product, basically?
13:17:06 <geekosaur> that's what you get with JOIn without ON (and no applicable WHERE constraints)
13:17:33 <geekosaur> or no JOIN at all
13:17:55 <comerijn> geekosaur: JOIN without on seems to get me "syntax error", but I won't rule out me messing up elsewhere in the code :p
13:18:12 <geekosaur> tbh was wondering of that would happen so no JOIN\
13:18:15 <geekosaur> ergh
13:18:30 * geekosaur hates thiskeybaord
13:18:42 <geekosaur> tbh was wondering if that would happen. so, no JOIN
13:18:47 <comerijn> geekosaur: At least, CROSS and LEFT JOIN result in that
13:18:48 <geekosaur> cross product is the default
13:19:12 <comerijn> Although the web seems to suggest it should work, so I'll look into other places I might be screwing up :p
13:21:02 <koala_man> mysql happily accepts 'select * from foo join bar;'
13:21:25 <koala_man> as well as '.. on 1=1'
13:21:38 <comerijn> Like I said, I might be messing up elsewhere, lemme check...
13:21:54 <geekosaur> ...from foo, bar;
13:22:14 <comerijn> brb
13:26:00 <merijn> you guys are all right, as was my initial attempt, looks like the culprit is elsewhere in the query...
13:28:07 <merijn> Apparently my CTE isn't pleasing to SQLite
13:31:32 <merijn> Oh, rats...I apparently don't know proper parentheses hygiene...
13:31:49 --- mode: glguy set +v thony
13:50:20 * hackage hsx2hs 0.14.1.5 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.14.1.5 (JeremyShaw)
13:54:36 <merijn> In other news, I don't think language implementors care enough about making language easy enough for format in a pretty way... >.>
14:04:22 --- mode: glguy set +v thony
14:04:57 <thony> hello
14:05:06 <ph88> c_wraith, can you comment on this https://stackoverflow.com/a/4504674/1833322 the guy lists StablePtr as "raw memory" .. how does that compare to what you were saying about a hashtable in the RTS ?
14:15:50 <c_wraith> ph88: it's a bit inaccurate on the details, but it doesn't impact the main point, which is that ghc can automatically marshall values of those types.
14:16:27 <iqubic> Well, I just switched to using nix to manage my haskell builds.
14:16:38 <c_wraith> ph88: but StablePtr is a fake pointer.  It's a pointer as far as marshalling is concerned, but it's fake.
14:16:39 <iqubic> Now I'm getting weird errors in emacs.
14:17:00 <ph88> c_wraith, what's a fake pointer ?
14:17:30 <c_wraith> it's something that's a valid pointer as far as C is concerned, but doesn't point to any particular value if you dereference it
14:17:47 <iqubic> Emacs is telling me that Data.Functor.Foldable.TH isn't on the search path and therefore isn't a valid import.
14:18:07 <c_wraith> are you running emacs from nix?
14:18:18 <iqubic> No.
14:18:28 <iqubic> I am not doing that, which is an issue I think.
14:18:37 <c_wraith> well if the libraries are only made visible within nix, you need to run emacs with the same nix environment
14:18:52 <iqubic> Right... Except I really don't want to do that.
14:19:11 <iqubic> I wish there was another way to do it.
14:19:52 <c_wraith> You might be able to run ghcid or whatever else you're using from nix
14:20:24 <iqubic> What is ghcid?
14:20:35 <iqubic> I'm using Cabal to build things.
14:21:10 <c_wraith> or dante or whatever
14:21:29 <__monty__> iqubic: ghcid is awesome. I'd look at jwiegley's nix-config, I'm sure he has the nix+haskell+emacs thing sorted out ; )
14:21:35 <iqubic> I'm using dante. 
14:21:50 <iqubic> I'm not using ghcid. Should I switch to ghcid?
14:21:55 <c_wraith> whatever you like
14:22:41 <iqubic> Oh, hey... Jwiegley made use-package.
14:23:07 <iqubic> Or he has a fork of it or something.
14:23:24 <MarcelineVQ> dante is nix aware, if you have a shell.nix and default.nix in your project root it looks like, based on the script's contents
14:23:44 <__monty__> iqubic: As the emacs maintainer I'm sure he's done some work on emacs things... : )
14:24:00 <iqubic> MarcelineVQ: You'd think that would be true, but my screen says otherwise.
14:24:59 <iqubic> https://imgur.com/a/gKfRFYg
14:26:44 <iqubic> I am able to run "nix-shell" and then "cabal repl" to get a repl with recursion-schemes in there. Why doesn't this work?
14:31:15 <iqubic> So, what should I do here?
14:33:17 <_deepfire> iqubic: it's likely that you need to set the 'dante-project-root' variable
14:33:26 <iqubic> really?
14:33:31 <iqubic> How do I do that>
14:33:35 <iqubic> s/>/?/
14:33:55 <_deepfire> iqubic: normally, I use .dir-locals.el for that
14:34:53 <iqubic> I see.
14:35:04 <iqubic> And what would that look like for my project?
14:35:09 <_deepfire> I wish dante had better chops at determining project root, but I never found how to avoid having to use per-project setting of that variable..
14:36:05 <_deepfire> ((nil . ((dante-project-root .    "~/your-project")))) should work
14:36:32 <_deepfire> It's ugly, granted, but I never found a better solution
14:36:53 <iqubic> Do you use Nix too?
14:36:57 <_deepfire> yes
14:37:14 <iqubic> Ah. Cool.
14:37:33 <iqubic> So can you give me an example .dir-locals.el file?
14:37:41 <_deepfire> I just did : -)
14:39:18 <iqubic> Do I need a certain package in order to get this to work?
14:40:34 <_deepfire> Nope, .dir-locals.el is standard emacs functionality for setting buffer-local-vars
14:40:58 <iqubic> nice.
14:41:35 <iqubic> I'm not sure that worked.
14:41:39 <iqubic> How do I test it?
14:43:39 <_deepfire> In your source buffer: M-x eval-expression, then enter 'dante-project-root' as the expr to eval
14:44:56 <_deepfire> You might need to close the source buffer and reopen it -- or actually ever restart emacs -- dir-local files are cached
14:48:23 <iqubic> So, I just got dir-locals working, but I'm still getting my import flagged as an error.
14:49:08 <iqubic> _deepfire: Do you know what's going on here?
14:51:51 <_deepfire> iqubic: that depends on what command dante is trying to run
14:52:10 <iqubic> Well, it actually looks like this is a flycheck issue.
14:52:39 <iqubic> Because I think dante relies on flycheck to do the error showing.
14:52:45 <nsxt> Noobie here. I'm really struggling with generating unique (integer) identifiers. I'm using the "fgl" library and want to create arbitrary graphs and then possibly combine them later at will (meaning I won't know the node identifiers ahead of time, but I do know that they all need to be unique).
14:53:50 <iqubic> _deepfire: the word "import" is underlined with the message: "could not find module `Data.Functor.Foldable.TH`"
14:57:04 <iqubic> So I don't know how to fix this right now.
14:57:20 <_deepfire> iqubic: there are two important variables at play: 1. what's in your cabal file, and 2. what command dante is trying to run
14:58:49 <iqubic> 1. http://dpaste.com/2QM0TH6 2. I'm not sure.
14:59:17 <iqubic> https://imgur.com/a/POQc8hv
14:59:18 <glguy> nsxt: you can renumber one of the two graphs when you combine it with the other
15:00:09 <ClaudiusMaximus> or renumber both:  l -> 2 * l ; r -> 2 * r + 1 ?
15:01:01 <ClaudiusMaximus> (depends on your combining strategy and whether it is a bounded Int)
15:02:09 <glguy> If it's fgl, then it's bounded
15:03:20 <iqubic> _deepfire: you got any ideas?
15:04:23 <_deepfire> iqubic: figuring out the second point is important
15:04:45 <iqubic> How do I figure out what command is being run?
15:04:58 <_deepfire> then you can replicate the failure dante is getting
15:06:26 <iqubic> IDK how to figure this out.
15:06:33 <_deepfire> iqubic: you could start with M-x apropos-variable, and 'dante'
15:08:05 <nsxt> glgy, ClaudiusMaximus: I don't think renumbering would work, because I will want to keep open the possibility of `a` being fed to `b`, which is then fed to `c` with the original `a`. If I'd renumbered `a`, I've basically lost the original reference to it (and don't want a duplicate of it in the graph).
15:09:10 <iqubic> _deepfire: How do you deal with this situation? I'm sure you have to deal getting external deps working.
15:13:57 <iqubic> _deepfire: M-x apropos-variable isn't working.
15:16:55 * hackage forsyde-deep 0.2.0 - ForSyDe's Haskell-embedded Domain Specific Language.  http://hackage.haskell.org/package/forsyde-deep-0.2.0 (ugeorge)
15:19:27 <iqubic> _deepfire: Look at the last few sections of this: https://github.com/travisbhartwell/nix-emacs
15:19:43 <iqubic> Scroll to the bottom of the page.
15:20:58 <iqubic> Does that look good?
15:25:17 <_deepfire> iqubic: first thing you need to figure out is to reproduce the problem manually, without dante obscuring things
15:25:31 <_deepfire> Then you'll be able to debug
15:27:46 <romildo> What would be a point free version of the following function?    \x -> let y = f x in y == a || y == b
15:29:04 <ski>   (`elem` [a,b]) . f
15:53:10 <johnw> iqubic: :)
16:17:52 <merijn> Whoo! It's almost "my major refactor is done and everything still seems to work o' clock"
16:18:32 <marvin3> @pl  \x -> let y = f x in y == a || y == b
16:18:32 <lambdabot> liftM2 (||) (a ==) (b ==) . fix . const . f
16:18:39 <marvin3> :-D
16:19:05 <ski> great :)
16:19:52 <hpc> just in time for extended read-only friday
16:20:18 <hpc> it's a holiday, you can't risk a git push breaking production
16:20:27 <hpc> there could be some node module that depends on your code
16:20:42 <geekosaur> tell that to some of the commercial web sites I've visited over the past few days
16:20:50 <merijn> hpc: 1) I don't have a production, 2) holidays are for people who don't have thesises (thesi?) to finish >.>
16:21:28 <hpc> ah right
16:21:42 <merijn> hpc: I was planning to "quickly refactor" this last friday >.>
16:21:49 <hpc> :/
16:21:57 <merijn> I've been working pretty much non-stop since then, not counting christmas dinners >.>
16:29:19 <dumbintel> what OS are you guys running?
16:29:41 * DigitalKiwi uses at least 7
16:29:50 <hpc> do VMs count?
16:30:02 <dumbintel> primary
16:30:44 <aplainzetakind> merijn: theses
16:35:11 <ph88> is there magic in newPinnedByteArray ? it seems to be the same as the (non-pinned ?) newByteArray  http://hackage.haskell.org/package/primitive-0.6.2.0/docs/src/Data-Primitive-ByteArray.html#newPinnedByteArray
16:40:14 --- mode: glguy set +v blocboy
16:48:56 * hackage happstack-server 7.5.1.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.5.1.3 (JeremyShaw)
17:02:42 <ph88> c_wraith, the docs on StablePtr says that it's a reference to a Haskell expression. Is that not a particular value?
17:17:51 <amalloy> ph88: it doesn't look the same to me. it calls newPinnedByteArray# instead of newByteArray#
17:18:30 <ph88> amalloy, ah an oversight by me :(
17:18:50 <ph88> amalloy, but it's recursive no? the function name is the same
17:18:53 <amalloy> no
17:19:10 <ph88> o_O
17:19:10 <amalloy> names with a # are typically referring to GHC primitives or other magic: https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/src/GHC.PrimopWrappers.html#newByteArray%23
17:19:44 <ph88> ah ok got it
17:21:53 <amalloy> funnily enough when you follow that link you get to a definition that does just look like endless recursion, but i assume it is actually somehow special to the runtime or GHC
17:26:54 <zzz> general question: what are some important optimisations (syntactic or otherwise) regarding bijective functions?
17:28:32 <zzz> if any
17:33:30 <amalloy> that seems like a pretty broad question
17:34:40 <amalloy> arguably the stuff in Data.Coerce is an optimisation related to bijective functions (really, isomorphic types)
17:37:15 <geekosaur> amalloy & ph88, it's a primop, the haskell definition exists only to hold docs and (for primitive types) build info tables
17:39:20 <ACheesyName> is there something like assocmin a b c d in haskell which does if a < b then c else d?
17:40:19 <amalloy> bool (a < b) d c
17:40:32 <amalloy> er, that's wrong order
17:40:41 <amalloy> bool d c (a < b)
17:40:49 <amalloy> :t bool
17:40:50 <lambdabot> a -> a -> Bool -> a
17:41:25 <ACheesyName> works for me
17:42:18 <amalloy> ph88: ultimately the magic appears to originate at https://ghc.haskell.org/trac/ghc/browser/ghc/rts/PrimOps.cmm#L79
17:47:14 <ph88> https://github.com/ghc/ghc/blob/master/rts/sm/Storage.c#L988-L1068
17:58:51 * hackage tensors 0.1.1 - Tensor in Haskell  http://hackage.haskell.org/package/tensors-0.1.1 (leptonyu)
18:00:53 <coldpress> is it possible to return a dynamically typed value?
18:02:14 <coldpress> e.g. https://pastebin.com/T1jdzRWH , but instead of raising error and ending execution, I return a "polymorphic" warning message and continue program execution
18:16:15 <coldpress> nevermind, I'll use MonadError from https://stackoverflow.com/questions/38960583
18:32:14 <iqubic> _deepfire: So it turns out that setting the project root was all I needed to do. However, since dante only checks that value when starting, I needed to restart dante to get this to work.
18:33:48 <iqubic> Alright, this is weird as heck.
18:34:43 <iqubic> So I have this: http://dpaste.com/3G1WF3B
18:36:20 <iqubic> And I'm getting an error when trying to compile it: Parse error: module header, import declaration or top-level declaration expected.
18:36:48 <iqubic> GHC thinks the error stems from the use of makeBaseFunctor
18:37:10 <iqubic> But I have sources that say this is exactly what you do: https://hackage.haskell.org/package/recursion-schemes-5.1/docs/Data-Functor-Foldable-TH.html
18:38:32 <iqubic> Anyone know why this isn't working properly.
18:38:45 <iqubic> ??
18:42:28 <amalloy> iqubic: https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial
18:42:37 <amalloy> most notably you are missing {-# LANGUAGE TemplateHaskell #-}
18:42:44 <iqubic> Oh. I see.
18:44:08 <iqubic> Now I'm running into other issues.
18:44:25 <amalloy> congratulations
18:44:38 <sososasa> Does anyone have a link to a good fold explanation? 
18:45:32 <iqubic> amalloy: Yep. Programming is the one area where new errors are good.
18:46:37 <amalloy> sososasa: like "the beginner's guide to folding lists", or "the deep theory behind the idea of folding arbitrary data structures"?
18:46:54 <sososasa> Ok I will look into it.
18:47:02 <sososasa> thanks amalloy
18:47:38 <amalloy> neither of those are articles that exist AFAIK. i was asking what kind of intro you want
18:47:39 <iqubic> Illegal family instance for `Data.Functor.Foldable.Base` (Use TypeFamilies to allow indexed type families) In the type instance declaration for `Data.Functor.Foldable.Base`
18:47:47 <iqubic> What the heck does that mean?
18:48:07 <iqubic> All I did was add the TemplateHaskell pragma to my code.
18:48:44 <sososasa> amalloy: beginner's guide definitely
18:48:49 <MarcelineVQ> amalloy, sososasa: https://web.archive.org/web/20180522053624/http://ertes.eu/tutorial/foldr.html
18:49:11 <sososasa> amalloy: I was looking into this but not for beginner like me https://wiki.haskell.org/Foldr_Foldl_Foldl'
18:49:28 <amalloy> iqubic: good news: makeBaseFunctor successfully expanded the TH into ordinary haskell that uses features you don't have enabled
18:49:38 <iqubic> Oh. I see.
18:50:12 <iqubic> Is there a way to see what code is produced by the template haskell call?
18:50:25 <Solonarv> It means you need another language extension: TypeFamilies
18:50:30 <Solonarv> iqubic: ^
18:52:22 <sososasa> MarcelineVQ++
18:52:34 <iqubic> Solonarv: Yes, that's right.
18:52:46 <iqubic> I do need that for the Base wrapper to work.
18:59:20 * hackage wai-secure-cookies 0.1.0.3 -   http://hackage.haskell.org/package/wai-secure-cookies-0.1.0.3 (alaminium)
19:04:20 * hackage hspec-wai 0.9.2 - Experimental Hspec support for testing WAI applications  http://hackage.haskell.org/package/hspec-wai-0.9.2 (SimonHengel)
19:05:23 * hackage hspec-wai-json 0.9.2 - Testing JSON APIs with hspec-wai  http://hackage.haskell.org/package/hspec-wai-json-0.9.2 (SimonHengel)
19:13:09 <iqubic> Alright: I want a pretty printer. Which one should I use, and is there a guide to using it?
19:47:24 <vaibhavsagar> iqubic: -ddump-splices
19:47:31 <vaibhavsagar> for your TH question
19:52:30 <ACheesyName> is there something like a canonical indenter for haskell code? something that will take an indented file and improve it without changing the meaning
19:56:19 <geekosaur> there'sonly one real indenter out there, but no standard indentation
19:56:50 <geekosaur> andthere's no reliable way to take incorrectlyidnented code and "fix" it
19:58:16 <geekosaur> like a few minutes ago I pointed somene to missing indentation that moved a binding from a "where" to top level. onlya human can determine that that was the case, sicne it would be "correct" now btu potentially break later with other where clauses added
19:59:00 <geekosaur> "brittany"is the indenter btw. it sued to support several styles but because everyone does their own it wasn't worth maintaining that. so it does the author's preferred style now]
20:05:43 <DigitalKiwi> is hindent not a real indenter?
20:06:11 <geekosaur> I thiouth vbrittany was its replacement?
20:06:21 <geekosaur> guess not
20:06:34 <geekosaur> so tw then
20:06:36 <geekosaur> two
20:06:54 <geekosaur> which itself tells  you something
20:07:49 <geekosaur> and it looks like brittany is less complete than I thought, so you proabbly want hindent
20:07:54 <DigitalKiwi> I feel like there might be more too but those are the only two I can think of offhand
20:07:56 <geekosaur> unless the git version is better
20:08:55 <ACheesyName> well I'm installing it with cabal now
20:09:11 <geekosaur> hindent used to support multple styls but now it's just fpcomplete's internal stye iirc
20:09:33 <geekosaur> you'll see a --style opton for backward compat but its help tells you it's ignored nw
20:10:49 <DigitalKiwi> petition to start a gofundme to get geekosaur a new keyboard
20:11:17 <geekosaur> am liely to vbe out of here on sat. and hopefully have room for one
20:11:32 <geekosaur> this one's only redeeming feature is it fits in available space
20:12:36 <DigitalKiwi> https://www.reddit.com/r/haskell/comments/8x0x77/brittany_vs_hindent_vs_stylishhaskell/
20:42:03 <ACheesyName> great -- hindent doesn't compile during cabal install
21:19:45 <Ericson2314> Does anyone know something like Default for decidably maybe-inhabited types?
21:20:09 <iqubic> How common is it to see a haskell source file that starts with a giant list of language pragmas?
21:20:11 <Ericson2314> basically I have a GADT doing a binary relation with a functional depedency. AKA I encoding my map at the top level
21:20:32 <Ericson2314> iqubic: ubiquitous if giant is say >=5
21:20:43 <Ericson2314> and now I want to do map lookup
21:21:11 <iqubic> to me giant is five or more.
21:21:13 <Ericson2314> so I want `LoneOrNone (MyBInRel a)`
21:29:32 <Ericson2314> Eh, made my one
21:36:51 <sclv> very common. typical files have around 7
21:44:07 <iqubic> What pretty printer library do y'all recommend?
21:44:20 * hackage Fin 0.2.7.0 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.7.0 (MatthewFarkasDyck)
21:52:20 * hackage network-uri-json 0.2.0.0 - FromJSON and ToJSON Instances for Network.URI  http://hackage.haskell.org/package/network-uri-json-0.2.0.0 (alunduil)
22:08:55 <Ericson2314> iqubic: what are you trying to do?
22:09:31 <iqubic> I have a data type for an AST. I'm trying to print it in a pretty way.
22:13:25 <_deepfire> iqubic: wl-pprint-extras is a fairly common choice
22:13:35 <iqubic> Cool.
22:15:49 <_deepfire> Actually, sorry, ansi-wl-pprint is the common choice, but -extras is a nice angle on the same thing.
22:16:35 <iqubic> Is there a good guide on using that anywhere?
22:18:49 <_deepfire> The hackage page for the module is a good start: http://hackage.haskell.org/package/wl-pprint-extras-3.5.0.5/docs/Text-PrettyPrint-Free.html
22:20:55 <_deepfire> There's also a paper about the Wadler-Leijen pretty-printer, if you care for it -- it's linked on that page
22:28:20 * hackage bifunctor 0.1.0.0 - Bifunctors  http://hackage.haskell.org/package/bifunctor-0.1.0.0 (MatthewFarkasDyck)
22:33:50 * hackage compositional-data 0.1.0.0 - Compositional Data Types  http://hackage.haskell.org/package/compositional-data-0.1.0.0 (MatthewFarkasDyck)
22:54:50 * hackage compositional-data 0.1.0.1 - Compositional Data Types  http://hackage.haskell.org/package/compositional-data-0.1.0.1 (MatthewFarkasDyck)
23:14:20 * hackage gi-gdkx11 3.0.4 - GdkX11 bindings  http://hackage.haskell.org/package/gi-gdkx11-3.0.4 (inaki)
23:21:24 --- mode: glguy set +v t[m]
