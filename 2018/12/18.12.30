00:48:25 <James123> Hello, let's say I have e.g. Int -> Maybe Int. However, I want this function to have access to state, basically an incrementing counter. If I understand correctly, now the type of the function shold become Int -> IO (Maybe Int)?
00:55:20 <ClaudiusMaximus> James123: you can do without the sledgehammer of IO, if you  have  Int -> s -> (s, Maybe Int)  for some s, this is essentially the State monad
00:56:31 <ClaudiusMaximus> :t \n -> do { counter <- get; put (counter + 1) ; return (if n < counter then Just n else Nothing }
00:56:32 <lambdabot> error: parse error on input ‘}’
00:56:36 <ClaudiusMaximus> :t \n -> do { counter <- get; put (counter + 1) ; return (if n < counter then Just n else Nothing) }
00:56:38 <lambdabot> (Ord a, Num a, MonadState a m) => a -> m (Maybe a)
00:58:41 <ClaudiusMaximus> > let f = \n -> do { counter <- get; put (counter + 1) ; return (if n < counter then Just n else Nothing) } in runState (replicateM 10 (f 5)) 0
00:58:43 <lambdabot>  ([Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Just 5,Just 5,Just 5,Just ...
01:00:38 <James123> ClaudiusMaximus, thank you very much
03:09:23 * hackage dhall-to-cabal 1.3.1.0 - Compile Dhall expressions to Cabal files  http://hackage.haskell.org/package/dhall-to-cabal-1.3.1.0 (OliverCharles)
03:42:22 * hackage hw-xml 0.1.0.4 - Conduits for tokenizing streams.  http://hackage.haskell.org/package/hw-xml-0.1.0.4 (haskellworks)
04:07:45 --- mode: glguy set +v Guest79
04:35:03 <Ferdirand> bon, j'ai a peine du gprs
04:36:33 <julianleviston> la langue d’habitude ici n’est pas francais, mais anglais. (the usual language here isn’t french, it’s english)
04:39:37 <Ferdirand> i know, sorry, wrong channel
04:39:50 <Ferdirand> i'm behind an awfully slow gprs line and my term is lagging
04:53:23 * hackage unliftio 0.2.10 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  http://hackage.haskell.org/package/unliftio-0.2.10 (MichaelSnoyman)
04:55:00 --- mode: glguy set +v pulcher
04:55:04 <Athas> Is there a function of type '(a -> IO b) -> [a] -> IO [b]' that evaluates each list entry in parallel, but with at most 'getNumCapabilities' simultaneous threads?
04:55:35 <Athas> I can also accept a more generic type.
04:58:34 <julianleviston> mapConcurrently ?
04:59:10 <julianleviston> or forConcurrently, if you want that arg order.
04:59:13 <julianleviston> http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html
04:59:49 <Athas> julianleviston: does that bound the number of worker threads spawned?
04:59:56 <Athas> Reading the source code, it seems not to.
05:00:24 <Athas> Wait, maybe I'm reading this wrong.  I'm not familiar with the async code.
05:00:31 <julianleviston> Oops sorry forgot that bit.
05:01:19 <julianleviston> I thought GHC would already just do that tho… 
05:01:42 <julianleviston> depending on what you mean by bound.
05:02:35 <Athas> I am spawning external processes to do the work, and there is no need to spawn more than the number of cores.
05:02:45 <Athas> The GHC runtime won't help with that, unfortunately.
05:03:21 <Athas> Maybe I should just not worry.  Cores and memory are plentiful!
05:03:40 <julianleviston> Ah, this will be threads in the sense of GHC threads, I think… so that probably won’t work well, I guess.
05:04:11 <julianleviston> but it would seem that you actually want to control the process spawning yourself, so you probably want to write your own function?
05:04:22 <Athas> This sounds interesting: http://hackage.haskell.org/package/async-pool-0.9.0.2/docs/Control-Concurrent-Async-Pool.html
05:04:48 <Athas> Yes, I can write it myself, but there's lots of fiddly details with making sure the threads shut down again.  I'd prefer using something that has already been debugged.
05:05:01 <julianleviston> I’m kind of confused. Threads or processes?
05:05:07 <Athas> I have spent enough time teaching concurrent programming to know that it should always be avoided!
05:05:27 <Athas> I want to launch a number of GHC threads, and each of these threads will then launch a Unix process to carry out some useful work.
05:05:36 <julianleviston> that seems… strnage.
05:05:38 <julianleviston> strange*
05:05:56 <Athas> Well, consider if you have a directory of 100 .c files, and you want to compile each of them with 'gcc'.
05:06:06 <julianleviston> that’s to say… it doesn’t sound like you want to use an automated thing. You want to detect number of cores, then spawn precisely that many processes, yeah?
05:06:08 <Athas> That is essentially the problem I have (except not .c and not gcc).
05:06:31 <julianleviston> Ah, ok. 
05:06:59 <lavalike> Athas: I'm almost sure the answer is in here https://simonmar.github.io/pages/pcph.html
05:07:01 <julianleviston> then the pool library sounds ideal.
05:07:17 <Athas> Control.Concurrent.Async.Pool looks exactly like what I need.
05:07:34 <julianleviston> yup
05:07:35 <Athas> lavalike: which part?  I read that book once, but it is pretty outdated now, I thought.
05:07:49 <julianleviston> how is outdated?
05:07:51 <Athas> I also think async is already in my dependency hierarchy somewhere, so double win.
05:07:58 <julianleviston> sweet :)
05:08:13 <Athas> julianleviston: the book is from 2013.  which Haskell libraries maintain API stability for five years?
05:08:19 <c_wraith> Athas: if the history of make means anything, you want more workers than CPU cores.  Compiling is rarely CPU bound
05:08:42 <c_wraith> still less than "all of them", but the number of cores is an odd choice.
05:08:46 <julianleviston> Athas: I found it useful in 2018 :)
05:08:51 <lavalike> Athas: I wish I could tell you
05:08:56 <julianleviston> Athas: pretty sure all the lbiraries have the same APIs :)
05:09:24 <Athas> Hm, unfortunately async-pool is not in stackage.
05:09:41 <Athas> c_wraith: I am not compiling, I am doing something else that is definitely CPU-bound.
05:09:54 <Athas> But you are right that the optimal number of workers is pretty fuzzy.  getNumCapabilities is just a handy proxy.
05:10:25 <ph88> hey guys, i'm running stack in the Visual Studio console. Why do i get mingw32 as "operating system" ?
05:11:34 <julianleviston> Athas: seems to be in hackage doesn’t it? http://hackage.haskell.org/package/async-2.2.1
05:11:49 <Athas> ph88: mingw32 is name for the GNU/GCC based compiler environment on Windows.
05:11:56 <ph88> i know that
05:12:13 <julianleviston> ph88: reformulate your question maybe?
05:12:13 <Athas> julianleviston: yes, and it also seems to be making its way into Stackage, so it's all good.
05:12:29 <ph88> i want to compile 64 bits and prefer the visual studio compiler
05:12:29 <julianleviston> Athas: oh sorry I thought you said hackage. You said stackage :)
05:29:54 <ph88> does ghc on windows need to compile with mingw or is visual studio also possible ?
05:32:57 <julianleviston> I would be surprised if it needed mingw. the env in visual studio you’re using might be using mingw tho for the command line or plugin it’s using to compile with?
05:33:48 <julianleviston> but this isn’t actual knowledge, it’s just my guess. Sorry.
05:36:26 <julianleviston> ph88: are you using the platform? if you start it with that directly, does it also report mingw?
05:37:16 <ph88> julianleviston, im on windows now
05:37:24 <ph88> i think ghc stuff ships with mingw
05:37:35 <julianleviston> yeah, I understand. when I say “platfom” i mean the haskell platform.
05:38:20 <ph88> https://github.com/ghc/ghc/search?q=mingw&unscoped_q=mingw
05:38:28 <ph88> i'm not using haskell platform, i use stack
05:38:56 <julianleviston> it wouldn’t surprise me to find out that stack uses mingw. 
05:40:01 <Solonarv> It does.
05:41:31 <ph88> if i have mingw32 do i get a 32 bits compiled binary ?
05:41:49 <Solonarv> I don't think so
05:42:50 <hpc> stack manages mingw anyway right? i would just trust that it picks whatever is appropriate for your machine
05:44:28 <Solonarv> Actually, GHC on windows comes with its own mingw install
05:44:38 <hpc> ah, even better then
05:44:42 <hpc> because stack manages ghc too
05:48:31 <ph88> should a report a ghc bug that i get mingw32 instead of mingw64 ?
05:50:16 <sm> ph88: you know there's 32 and 64 bit versions of stack for windows ?
05:50:37 <hvr> why should that matter?
05:51:30 <ph88> sm, i have 64 bits version of stack
05:51:31 <hvr> or does X-bit stack require X-bit ghc on bi-endian platforms?
05:52:32 <sm> just a drive by comment, ignore me if not relevant
05:53:01 * hvr is actually curious about it 
05:53:49 <sm> I assume the 64-bit stack download uses 64-bit ghc, and vice versa
05:54:48 <ph88> hvr, maybe it is because i already had git bash installed
05:59:00 <sternmull> hvr: 32 bit vs 64 is independent of endianess. In fact for mingw it is little endian in both cases.
06:00:46 <sternmull> (yeah, probably nobody cares in this context, just had the urge to point that out)
06:30:12 <hvr> sternmull: yeah, I misspoke... I meant to say "biarch"
06:30:29 <hvr> or whatever the term is to denote systems which support two ISAs
06:30:41 <hvr> which differe merely by wordsize
06:30:59 <hvr> bi-wordsize? :-)
06:49:10 <sternmull> I don't know the right word either. Maybe "multimode" (because there is also a 16bit mode, so there are at least three modes for x86-64 CPUs).
07:22:19 <sternmull> Oh man. Looking at Haskell again after a while and had a hard time to understand why and how "(<$) = fmap . const" works. Took a while to notice that const will evaluate to a unary function when one argument is applied. Now it is obvious... but that won't be the last time such a simple piece of code makes me scratch my head for a while.
07:25:58 <mouse07410> I'm having a problem with Cabal failing to install packages. Message is:
07:27:42 <mouse07410> dieVerbatim: user error (cabal: /usr/local/bin/ghc excited with an error:
07:28:59 <mouse07410> error:
07:29:08 <mouse07410> Could not find module 
07:29:48 <mouse07410> 'Distribution. Extra. Doctest'
07:30:35 <mouse07410> There are files missing in the 'cabal-doctest-1.0.6' package
07:30:53 * hackage non-empty-containers 0.1.4.0 -   http://hackage.haskell.org/package/non-empty-containers-0.1.4.0 (fosskers)
07:31:28 <ph88> mouse07410, maybe because there are spaces in the module name
07:31:34 <mouse07410> I ran "ghc-pkg check" and of course it reports ok
07:32:44 <mouse07410> This is on MacOS, with Haskell Platform Core 8.6.3 installed a-fresh. 
07:33:58 <mouse07410> ph88 in what module name? I see no spaces, only periods
07:58:22 * hackage first-class-families 0.4.0.0 - First class type families  http://hackage.haskell.org/package/first-class-families-0.4.0.0 (lyxia)
08:20:23 * hackage patience 0.2.1.0 - Patience diff and longest increasing subsequence  http://hackage.haskell.org/package/patience-0.2.1.0 (chessai)
08:23:38 <ph88> is it a good idea to let my library throw exceptions ?
08:31:16 <lyxia> I don't think so.
08:32:08 <mouse07410> Any idea how to remedy this problem with cabal-doctest package?
08:50:19 <sclv> mouse07410: are you doing dynamic builds?
08:51:24 <sclv> if so then https://github.com/phadej/cabal-doctest/issues/24 and https://github.com/haskell/cabal/issues/1720
09:03:59 --- mode: glguy set +v Ashjkaell
09:04:57 --- mode: glguy set -v Ashjkaell
09:05:23 <Ashjkaell> (Repeated, I hope not doubled) Hey all :-) ! I'm learning Haskell and had some weird (stupid) questions; Since functions don't have side effects is there a philosophical difference between a function which takes ``zero'' arguments and a value directly bound to a name ?
09:06:31 <Ashjkaell> The types seem to suggest this: a -> a -> a takes ``2'' arguments (if we don't think about currying), a -> a takes 1, is ``a`` a function of zero args or an element of type ``a`` ?
09:07:44 <Solonarv> Both (they mean the same thing)
09:11:18 <Ashjkaell> Thanks Solonarv :-)
09:11:45 <__monty__> Ashjkaell: http://conal.net/blog/posts/everything-is-a-function-in-haskell
09:12:55 <Ashjkaell> __monty__: Awesome ! Thanks alot for the reference.
09:13:25 <__monty__> np
09:27:52 * hackage z85 0.0.0 - Implementation of the z85 binary codec  http://hackage.haskell.org/package/z85-0.0.0 (athanclark)
09:32:18 <Ashjkaell> Is it possible to define a function with type a->a other than the identity ? (If you assume nothing about type a). Intuitively I would say no, but maybe it plays with the axiom of choice ?
09:34:27 <ggole> Terms with type a -> a can diverge in various ways.
09:34:53 * hackage z85 0.0.1 - Implementation of the z85 binary codec  http://hackage.haskell.org/package/z85-0.0.1 (athanclark)
09:35:00 <ggole> Other than that, (various spellings of) identity is it
09:36:21 <centril> ggole: there's also: http://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html#v:trace
09:37:31 <ph88> How can i peek an array given a start Ptr and length and a haskell type ?  i'm looking here but don't find a suitable function https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Array.html#g:7
09:37:44 <centril> @let foo = trace "bar"
09:37:45 <lambdabot>  .L.hs:178:7: error: Variable not in scope: trace :: [Char] -> t
09:37:45 <lambdabot>      |
09:37:45 <lambdabot>  178 | foo = trace "bar"
09:37:56 <ggole> centril: right, you can also cheat that way
09:38:00 <centril> @let foo = Debug.Trace.trace "bar"
09:38:01 <lambdabot>  .L.hs:178:7: error:
09:38:01 <lambdabot>      Not in scope: ‘Debug.Trace.trace’
09:38:01 <lambdabot>      No module named ‘Debug.Trace’ is imported.
09:38:19 <centril> " Lambdabot has a huge list of imports. If it can't find the name of a function you specified, try the fully qualified name. There is no way of importing modules manually."
09:38:23 <centril> lambdabot: why do you lie?
09:38:58 <ph88> oh got it   peekElemOff
09:39:08 <centril> ggole: ye; parametricity is subtle that way
09:39:41 <ggole> I suppose you can do similar 'cheaty' things like seq, too
09:40:04 <Ashjkaell> Haha ;-), thanks centril and ggole in anycase ! My question was based from using Hoogle, the fact that you can search for functions super reliably based on type is pretty awesome !
09:40:09 <ggole> So there are actually lots of choices other than id, with the proviso that they sort of don't count.
09:41:22 * hackage constraint 0.1.2.0 - Reified constraints  http://hackage.haskell.org/package/constraint-0.1.2.0 (MatthewFarkasDyck)
09:41:28 <wroathe> I'm noticing that haskell devs usually put pragmas for language extensions in each source file like so: https://github.com/haskell-servant/servant/blob/master/servant/src/Servant/API/Sub.hs#L1-L4
09:41:41 <wroathe> But stack and cabal offer the ability to pass these to GHC during compilation
09:41:47 <centril> ggole: So if you'd explain to a Java or C++ programmer why parametricity is important, what would you say?
09:42:12 <wroathe> Why not just enable these language pragmas in stack's package.yaml?
09:42:23 <MarcelineVQ> wroathe: readers of the source file can easily see what's applying to that file when they're part of the file itself, and there's no hidden options affecting things unaware
09:42:40 <centril> On the other hand I really wish we could add some extensions to the report
09:42:51 <centril> The number of pragmas give Haskell an unbelievably bad reputation
09:42:51 <MarcelineVQ> haskell dev is quite open so readable source matters
09:43:06 <ggole> I would probably waffle about how Haskell programs almost never cheat in those ways in practice, so reasoning in terms of parametricity is more or less justified
09:43:50 <wroathe> MarcelineVQ: So you're saying it's widely accepted that explicitly stating language extensions per file is the preferred practice?
09:43:53 * hackage constraint 0.1.2.1 - Reified constraints  http://hackage.haskell.org/package/constraint-0.1.2.1 (MatthewFarkasDyck)
09:43:55 <MarcelineVQ> yes
09:43:55 <centril> ggole: no I don't mean about the cheating... forget that; pretend you cannot cheat... what would you say to convince a Java/C++ programmer that parametricity is practically useful?
09:44:26 <centril> emphasis on *practical*
09:44:47 <ggole> Hmm, good question.
09:45:12 <centril> My argument is primarily about documentation and that it enhances the value of types
09:45:21 <centril> i.e. it reduces the global reasoning footprint
09:45:35 <centril> but that's a handwavy non-concrete argument
09:46:34 <ggole> Certain things being off the table when you see a type variable is valuable, yes
09:47:05 <wroathe> centril: Yeah, I'm trying to wrap my head around some of the prior art that Servant is built on, and the first code block in one of the author's posts starts off by slamming down 6 different language extensions that are required :P
09:47:27 <wroathe> Each one of those represents a new concept that I need to slog through before I can get to the meat of what I'm trying to learn
09:47:55 <centril> ah; as long as I don't see IncoherentInstances or OverlappingInstances I'm mostly happy
09:48:14 <centril> I'd be happy for those to be removed from GHC
09:48:33 <wroathe> https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/#preparations
09:50:06 <centril> MarcelineVQ: like... why is LambdaCase, TupleSections, GADTSyntax not part of the report yet...?
09:52:39 <int-e> centril: Useless, useless, and GADTs are not in the report either?
09:52:48 <MarcelineVQ> Would guess it's mostly because the report itself hasn't been revised in awhile
09:53:16 <centril> int-e: GADTs and their syntax are not the same thing
09:53:28 <centril> LambdaCase being useless... really?
09:54:08 <int-e> Like all syntactic sugar. (Also, yeah, I have yet to use them... I find the syntax awkward.)
09:55:11 <centril> int-e: So... shall we likewise remove `if a then b else c`?
09:55:30 <int-e> I'm half teasing though. Regarding GADT syntax, if we didn't have GADTs, the GADT syntax wouldn't be missed.
09:55:52 * hackage ribosome 0.1.2.0 - api extensions for nvim-hs  http://hackage.haskell.org/package/ribosome-0.1.2.0 (tek)
09:55:53 <centril> LambdaCase I find quite useful for writing small composable functions that immediately match on their scrutinee
09:56:25 <int-e> Seriously speaking, I think MarcelineVQ's answer is quite accurate.
09:57:23 <ph88> how can i make a   Ptr Word16   from   CSize  ?
09:57:35 <centril> MarcelineVQ: that's a bummer; it would be good for Haskell prime to include some non-type-system extensions at least and some type system extensions that have no open questions
10:01:21 <int-e> centril: the first two at least have a page on the Haskell' wiki: https://prime.haskell.org/wiki/TupleSections and https://prime.haskell.org/wiki/LambdaCase
10:02:17 <int-e> (Though the latter has a different syntax than what's implemented in ghc. Oops.)
10:02:37 <int-e> And these are stubs rather than full-fledged specifications. Bad sign.
10:03:14 <centril> int-e: I mean; \case  needs a small change to the grammar and then a trivial desugaring by eta expansion
10:03:25 <centril> anything else needed for specification?
10:04:02 <int-e> and then there's the fact that https://prime.haskell.org/ticket/41 (LambdaCase) is 13 years old, and https://prime.haskell.org/ticket/69 (TupleSections) as well.
10:04:45 <int-e> I guess nobody cares strongly enough about either of these.
10:04:52 * hackage z85 0.0.2 - Implementation of the z85 binary codec  http://hackage.haskell.org/package/z85-0.0.2 (athanclark)
10:04:56 <centril> :/
10:07:03 <ph88> is it safe to replace  CUShort with Word16   in FFI ?
10:08:00 <int-e> centril: But to answer your question about if-then-else, that turns what would be awful type errors into much easier to understand syntax errors. In contrast, TupleSections and LambdaCase mostly save you a little bit of typing, and coming up with a fresh name (which is a source of errors I guess, so there is a small benefit on that front).
10:09:46 <centril> int-e: well I find people are bad at naming, so forcing folks to invent a fresh one-letter name to immediately case on seems bad
10:09:52 <centril> it's not about the "more typing"
10:10:24 <centril> what's the value of   foo x = case x of ...    when I can just write  foo = \case ...
10:11:10 <crysikrend> Hey everyone, I'm using Network.WebSockets and Iwas wondering if there was an easy way of having multiple connections so that the clients could communicate to each other? Right now, every client kind of has their own 'instance' which is great, but they do not know of each other. How would I go about hooking two of them up?
10:11:37 <int-e> centril: what's the value of foo = \case ... when I can just write  foo x = case x of ...?
10:12:10 <int-e> (besides I'm must more likely to write  foo case1 = alt1; foo case2 = alt2 ...)
10:12:14 <int-e> *much
10:12:22 * hackage constraint 0.1.3.0 - Reified constraints  http://hackage.haskell.org/package/constraint-0.1.3.0 (MatthewFarkasDyck)
10:16:49 <__monty__> I like the first order case idea. Let's do "case 1 -> x; 2 -> y; 3 -> z of" so it reads better too. : >
10:22:35 <Solonarv> wroathe: stack doesn't touch language extensions at all, and package.yaml isn't strictly speaking a "stack thing" - it's the configuration file for hpack, which simply generates a blah.cabal file
10:22:55 <int-e> Is the Haskell' process obsolete now that there's basically only one Haskell implementation remaining?
10:23:49 <monochrom> No because the Haskell' process is still the process that will say which extensions will be enabled by default so you don't have to do it manually. >:)
10:24:23 <centril> int-e: I find  foo case 1 = alt1 \n foo case2 = alt2  to be distasteful due to reptition
10:25:11 <monochrom> So think of the fact that although a country has only one Congress / House of Commons it still needs a Senate / House of Lords. >:)
10:25:25 <int-e> centril: FWIW, I do consider this foremost a matter of taste. (And a lot of that is just continuation of acquired habits...)
10:26:11 <centril> int-e: I personally find that the terseness and eta-reduced form (I'm of the pointfree persuasion, yes) encourages many small and testable top level definitions, which seems like a good SE principle
10:26:53 * hackage google-static-maps 0.6.0.0 - Bindings to the Google Maps Static API (formerly StaticMaps API)  http://hackage.haskell.org/package/google-static-maps-0.6.0.0 (mpilgrem)
10:26:56 <centril> monochrom: The Swedish parliament has only one house... :)
10:27:44 <int-e> centril: ... let's stop here, the next thing I was going to write was terribly condescending.
10:27:53 <mouse07410> :-)
10:28:11 <centril> int-e: I appreciate your constraint... ;)
10:28:29 <shachaf> int-e är inte svensk.
10:28:39 <the_2nd> I have a .cabal that builds 7 executables. How can I avoid listing all my files multiple times in exposed-modules? I tried following this example, but it still exports A, B, C multiple times https://www.haskell.org/cabal/release/cabal-1.18.1/doc/users-guide/developing-packages.html#example-a-package-containing-a-library-and-executable-programs 
10:29:02 <int-e> shachaf is breaking the boundaries of reality.
10:29:05 <the_2nd> or do I just define some sort of Lib.hs that exports everything?
10:29:28 <shachaf> int-e: At least I'm not terribly condescending!
10:29:39 <shachaf> ...Who am I kidding.
10:29:47 <Solonarv> the_2nd: you don't need to add library modules to an executable's other-modules, AFAIK
10:30:02 <mouse07410_> In general I find that extra terseness adversely effects software quality and thus isn't a good SE
10:30:09 <the_2nd> will try as in the example without other-modules
10:30:32 <Solonarv> Usually I have a library in ./lib, and executable(s) in ./exe1, /.exe2, and so on
10:31:40 <ph88> is there take and drop combined into one function for Text ?
10:32:02 <centril> shachaf: do you belong to the Church of Haskell (Chalmers) by any chance?
10:32:04 <mouse07410_> Seems that ./bin would be a better place for the executables?
10:32:15 <Solonarv> ph88: should be called splitAt, I think
10:32:17 <the_2nd> nah, still requires me to expose them in the executables
10:32:35 <Solonarv> mouse07410_: ./bin is for binary files, the source code of my executables isn't a binary file!
10:32:46 <Solonarv> ./bin is where I might expect build products to end up
10:32:47 <ph88> Solonarv, i don't want to start at the first character, and i don't care about the remaining two pieces
10:33:19 <Solonarv> oh, now I see what you mean. Try looking for 'slice'.
10:33:24 <shachaf> centril: Nope.
10:33:55 <centril> shachaf: ah; haskeller + Swede usually means a Chalmers student or alumni :)
10:34:13 <shachaf> I'm not a Swede, and I don't even speak Swedish.
10:34:28 <mouse07410_> Ah, the *source* fur the executables - yeah, then makes perfect sense
10:34:33 <MarcelineVQ> the linked example isn't stellar for multiple executables, in that example they should have TestPackage in their build-depends so that A, B, C are available to them without being listed
10:35:12 <Solonarv> oh yes, indeed - your executables should *depend* on your library
10:35:30 <Solonarv> (you can also have one or more internal libraries for the same purpose)
10:42:34 <Solonarv> (the_2nd: is there a reason you're looking at the docs for cabal 1.18? that's quite an old version)
10:43:24 <the_2nd> nah, just what google spit out
10:45:02 <the_2nd> I think I need multiple .cabal files?
10:45:38 <Solonarv> No, you don't.
10:45:50 <the_2nd> or have a file reexporting the internals?
10:45:53 <Solonarv> Up-to-date docs are at https://cabal.readthedocs.io
10:45:54 <the_2nd> MyLib.hs
10:45:58 <Solonarv> You don't need that either!
10:47:48 <the_2nd> https://www.haskell.org/cabal/release/cabal-1.18.1/doc/users-guide/developing-packages.html#example-a-package-containing-a-library-and-executable-programs
10:47:55 <ph88> are there a bunch of predefined Exceptions i can use, like  https://secure.php.net/manual/en/spl.exceptions.php  ?
10:47:59 <the_2nd> there A, B, C are exported as well
10:48:09 <Solonarv> example structure for: https://github.com/Solonarv/scorch
10:48:12 <the_2nd> or listed via other-modules
10:48:33 <the_2nd> common, ah
10:48:37 <the_2nd> will try, thanks
10:48:49 <MarcelineVQ> the_2nd: share your file
10:49:41 <Solonarv> the_2nd: I don't know why you focused on the common stanza in my file. That just saves me from repeating the same list of language extensions twice.
10:57:23 * hackage constrained-category 0.1.0.0 - Constrained Categories  http://hackage.haskell.org/package/constrained-category-0.1.0.0 (MatthewFarkasDyck)
11:02:10 <the_2nd> Solonarv, I have to make some changes to the folder structure, but I hope it'll work then
11:04:16 <the_2nd> thank you
11:28:55 <c50a326> how do you know what kind to give to a typeclass implementation? I'm always confused with this
11:29:50 <c50a326> e.g. for my own List type (data List a = Nil | a ::: List a), if I want to impl Functor it's `instance Functor List where` but if I want to impl Semigroup it's apparently `instance Semigroup (List a) where`
11:31:21 <c50a326> I guess I can :k Functor, Semigroup, in ghci... but how do I get intuition?
11:31:48 <c50a326> I mean why is: Semigroup :: * -> Constraint
11:34:34 <monochrom> You can infer a lot from the method types. In fact the computer does.
11:34:58 <MarcelineVQ> class Functor f where fmap :: (a ->​ b) -> f a -> f b observe the position of the f here, it's being applied to some type a, a is an argument to -> which has the kind * ->​ * -> * so f must have some kind * -> * since a is kind * and f is applied to a
11:35:12 <monochrom> Yeah, like that.
12:13:16 <statusbot> Maintenance update: Hackage shutting down for hardware migration *now* -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c2924690a18e204ab36cc6f
12:17:24 <larryba> hello. will `void $ <function that returns mapM f xs>' be as efficient as copying that functions body and replacing mapM with mapM_?
12:18:07 <hpc> @src mapM_
12:18:07 <lambdabot> mapM_ f as = sequence_ (map f as)
12:18:12 <hpc> @src sequence_
12:18:12 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:18:25 <larryba> yes, I meant sequence_ $ .., not void $
12:18:33 <hpc> probably
12:19:08 <hpc> well
12:19:37 <hpc> if you really want to be sure you can check the core they compile to
12:19:43 <hpc> or time it
12:20:18 <hpc> the answer to performance questions is usually to measure it
12:20:58 <larryba> I don't know anything about core. and just to be clear, I don't care about code inlining, but whether mapM will still be collecting results
12:21:04 <larryba> (and I actually did mean void $, function is calling mapM, not map)
12:21:23 <hpc> ah
12:22:26 <hpc> you can probably count on the list of results being created, but with nothing referencing it so it gets GC'd immediately
12:23:03 <hpc> so it doesn't increase the memory use of your program and in terms of instructions it's on the level of adding a register increment to the inner loop
12:23:12 <argent0> Are the docs down? http://hackage.haskell.org/package/first-and-last/docs/Data-Monoid-First.html
12:23:28 <infinisil> argent0: 21:12:54 <statusbot> Maintenance update: Hackage shutting down for hardware migration *now* -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c2924690a18e204ab36cc6f 
12:23:35 <hpc> argent0: hackage just went down for a hardware upgrade, you missed statusbot by about 5 minutes
12:23:48 <infinisil> (21:12:54 is 10 minutes ago for my time)
12:24:00 <argent0> hpc: ok, thanks
12:24:29 <hpc> infinisil: i used metric minutes
12:24:53 <larryba> hpc, I see. not a big overhead
12:25:29 <infinisil> Hah
12:25:39 <infinisil> hpc: Imagine americans using a different time unit
12:26:10 <hpc> as if time isn't hard enough
12:29:20 <statusbot> Maintenance update: Hackage succesfully migrated & operational again; please report any regressions you notice -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c2924690a18e204ab36cc6f
12:32:26 <ph88> hurray !
12:33:23 * hackage massiv 0.2.6.0 - Massiv (Массив) is an Array Library.  http://hackage.haskell.org/package/massiv-0.2.6.0 (lehins)
12:39:52 * hackage hasmin 1.0.3 - CSS Minifier  http://hackage.haskell.org/package/hasmin-1.0.3 (contivero)
12:42:52 * hackage google-maps-geocoding 0.5.0.0 - Bindings to the Google Geocoding API (formerly MapsGeocoding API)  http://hackage.haskell.org/package/google-maps-geocoding-0.5.0.0 (mpilgrem)
12:45:52 * hackage filesystem-abstractions 0 - A shared set of abstractions and types for representing filessytem data.  http://hackage.haskell.org/package/filesystem-abstractions-0 (davean)
12:48:22 * hackage miss 0 - A Haskell git implimentation  http://hackage.haskell.org/package/miss-0 (davean)
12:49:22 * hackage miss-porcelain 0 - Useability extras built on top of miss.  http://hackage.haskell.org/package/miss-porcelain-0 (davean)
12:53:18 <larryba> hpc, hmm, will haskell at one point be allocating a list with 1 million elements? or it is optimized away as a loop?
12:53:33 <larryba> not sure how to interpret "GCed immediately"
12:55:07 <hpc> so, (and this is all ghc-specific)
12:55:26 <hpc> ghc has a generational garbage collector, and its allocator is pretty unique too
12:55:53 <hpc> allocations happen in a range of memory sequentially
12:56:12 <hpc> when data is written there, it's written at a location and then a pointer to that location is incremented by the size of that data
12:56:26 <hpc> then when it's full, the data in that range is garbage-collected
12:56:39 <hpc> data that has references is moved out, and becomes "old"
12:56:43 <hpc> or whatever the proper term is
12:57:36 <hpc> so lots of created data that gets thrown away immediately is the ideal use case for memory allocations
12:58:33 <larryba> so, basically, even if I do that with 1 million elements, it will be allocating small chunks of that list, and GC'ing them as it goes?
12:59:27 <hpc> yeah
12:59:34 <hpc> and that's if it isn't optimized out anyway
12:59:40 <larryba> neat
12:59:42 <hpc> that's basically the worst likely case
13:13:42 <ph88> how do i refactor these two pieces of codes so that the differences between them go into separate functions and i call those functions with the similarities ?  https://bpaste.net/show/4346620514d1
13:22:52 * hackage generic-data 0.4.0.0 - Utilities for GHC.Generics  http://hackage.haskell.org/package/generic-data-0.4.0.0 (lyxia)
13:24:36 <lyxia> ph88: can you post more context, where are all these identifiers bound
13:54:20 <ph88> lyxia, https://bpaste.net/show/d6f7c6498ed4
13:57:47 <lyxia> all these parameters definitely don't make life easy :)
13:58:14 <lyxia> are all the p_ variables of the same type and allocated the same way between the two versions?
13:59:22 <lyxia> maybe you can pull out just BA.withByteArray and useAsPtr
14:01:33 <wroathe> Servant api types use a strange '[...] syntax for one of the type parameters, e.g.: type MyApi = "hello" :> "world" :> Get '[JSON] World
14:01:41 <wroathe> Does anyone know where '[] is defined? I'm having trouble finding it
14:01:53 <lyxia> It's part of the DataKinds extension
14:02:06 <wroathe> lyxia: gracias
14:02:31 <lyxia> the quote "promotes" a data constructor so it can be used in types
14:21:52 * hackage chromatin 0.1.1.0 - neovim package manager  http://hackage.haskell.org/package/chromatin-0.1.1.0 (tek)
14:26:42 <wroathe> Is "lifting" somewhat of an overloaded term in the haskell ecosystem? It seems like I see lots of disparate things referred to as lifting...
14:29:02 <Cale> wroathe: yeah, it's quite overloaded. It has the general sense of taking something from a "smaller" or "more restricted" set, and generalising it to a "larger" or "more inclusive" one.
14:32:00 <wroathe> Cale: Yeah, in this case I'm looking over the docs on Monad transformers and I see them explaining the way in which liftM and liftIO differ
14:32:38 <wroathe> Cale: For the uninitiated like me, the first definition I acquired is that you can "lift" a function into a monadic context to operate on it's inner value
14:32:48 <wroathe> Then liftIO comes along...
14:35:33 <lyxia> If my package's only changes are to ensure compatibility with newer versions of dependencies, while losing compatibility with older versions, but the API is the same, according to the PVP my A.B.C can remain the same right?
14:36:44 <larryba> wroathe, as a side node, you don't need Monads to do that, Functor will do
14:38:04 --- mode: glguy set +v mreh
14:38:15 <amalloy> larryba: well, or applicative
14:38:29 <wroathe> larryba: Well, in this case I'm trying to decouple Servant API code (that needs functions that return a Handler) from my library code (that uses IO)
14:38:30 <larryba> not for liftM
14:38:36 <amalloy> functor if it's a 1-argument function
14:38:45 <larryba> as is liftM :)
14:39:08 <wroathe> The docs mention stuff like liftIO $ myLibraryOperation foo bar
14:41:24 <mreh> hmm, is beam-migrate-cli not on (st|h)ackage yet?
14:43:18 <mreh> ah, it's not relaesed yet
15:10:52 * hackage generic-data-surgery 0.2.0.0 - Surgery for generic data types  http://hackage.haskell.org/package/generic-data-surgery-0.2.0.0 (lyxia)
15:20:16 <sternmull> The "Typeclassopedia" explains the instance of Functor for tuple that the tuple is seen as pair of an "annotation" and a value. This is the first time i get a good explanation why the Functor maps over the second element.
15:20:44 <fr33domlover> Is there a way to check if a given value is in WHNF? I wrote a variant of foldl' but unsure it's correct
15:21:03 <fr33domlover> (i.e. thunks don't get built, like the regular foldl')
15:22:04 <sternmull> fr33domlover: You should be able to inspect the value with ghci. It can print without forcing evaluation, so you should be able to see if you have thunks or evaluated values.
15:25:33 <sternmull> Is this interpretation of tuple explained anywhere else? The documentation of Functor does not mention what you would expect for that instance. The haskell language report doesn't say anything about the meaning of a tuple.
15:31:00 <hpc> fr33domlover: :print in ghci
15:31:14 <hpc> and :sprint for simple output
15:31:40 <fr33domlover> sternmull, hpc thanks I'll try :) sternmull I remember reading about it too, maybe in the Haskell Wikibook?
15:31:51 <hpc> sternmull: a better way to see why it's the second element is to follow the types
15:31:56 <hpc> :t fmap
15:31:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:32:19 <hpc> to make (f a) and (f b) unify with tuple types, f = (,) c
15:32:32 <hpc> if you apply the type parameters in order, that makes c the first element and a/b the second
15:33:02 <fr33domlover> sternmull, personally I find myself never using that Functor instance, I just use 'first' and 'second' from Bifunctor
15:33:25 <hpc> once you have the type (a -> b) -> (c, a) -> (c, b), there's only one value of that type which doesn't reference bottom
15:33:31 <hpc> @djinn (a -> b) -> (c, a) -> (c, b)
15:33:31 <lambdabot> f a (b, c) = (b, a c)
15:34:42 <hpc> looking at the types like this works for every other Functor instance as well
15:39:34 <fr33domlover> hpc, sternmull how do I tell from :print and :sprint whether there are thunks?
15:39:38 <sternmull> hpc: Ok... makes technically sense. But so far i had no plausible explanation why that would make sense for (,). It just seemed an arbitrary decision "We have two type parameters for tuple but only one for Functor... so which one do we use in Functor? Ah, just pick the second one, no one will care."
15:39:50 <fr33domlover> It keeps displaying "x = _"
15:40:31 <mniip> fr33domlover, is x polymorphic
15:40:44 <mniip> or rather, does it have a constraint
15:40:59 <larryba> sternmull, it is impossible to write Functor instance for tuple that maps over first parameter, or over both
15:41:19 <fr33domlover> mniip, yeah it does! Should I specify specific type to see if thunks get created?
15:41:38 <fr33domlover> e.g. replace Num constraint with explicit Int etc.
15:41:39 <sternmull> larryba: Over both? But only when all elements have the same type, right?
15:41:48 <hpc> fr33domlover: thunks are underscores - you'd be surprised at what doesn't go through a thunk though
15:41:53 <mniip> fr33domlover, you should specify the type and bind it to a new monomorphic name
15:42:11 <hpc> a value with a constructor at the head starts with that constructor evaluated, for instance
15:42:44 <hpc> lists are also a bit awkward, but that's the formatter for :print more than lists themselves
15:42:47 <larryba> sternmull, you still can't write it. try for: data Tuple a b = Tuple (a, b)
15:43:21 <hpc> sternmull: it's the order the parameters are in
15:43:23 <larryba> instance Functor Tuple where =>   * Expecting one more argument to `Tuple'       Expected kind `* -> *', but `Tuple' has kind `* -> * -> *'
15:43:25 <hpc> (,) a b
15:43:38 <hpc> or if you show all the parens, ((,) a) b
15:43:55 <hpc> unifying that with f c produces the following equations in the type checker:
15:43:56 <sternmull> but "data Tuple a Tuple (a, a)" should work.
15:43:58 <hpc> f = (,) a
15:43:59 <hpc> c = b
15:44:20 <hpc> that's the whole reason
15:44:35 <hpc> if you wrote data BackwardsTuple a b = Pair b a
15:45:31 <fr33domlover> let a :: Int; a = foldl' (+) 0 $ replicate 10 1
15:45:37 <fr33domlover> mniip, like this? ^
15:45:42 <hpc> now it works the other way, because the type parameters map to the opposite side of the tuple at the value level
15:45:47 <fr33domlover> :print a still says a = _
15:46:08 <sternmull> hpc: Yes, i understand that.
15:47:11 <mniip> % let a :: Int; a = foldl' (+) 0 $ replicate 10 1
15:47:11 <yahb> mniip: 
15:47:17 <mniip> % :print a
15:47:17 <yahb> mniip: a = (_t2::Int)
15:47:19 <mniip> % a
15:47:19 <yahb> mniip: 10
15:47:21 <mniip> % :print a
15:47:21 <yahb> mniip: a = 10
15:49:13 <fresheyeball> anyone out there use Beam?
15:49:26 <fr33domlover> mniip, but then foldl' and foldr show the same result? I'd like to be able to see the difference, to see if my function works like foldl': https://share.riseup.net/#6Ll_kUKjdhBqouTO2N0lYQ
15:49:53 <mniip> I'm afraid you can't
15:49:54 <sternmull> hpc: It was just the intuition that was missing for the instance. I saw some convoluted explanation why the Functor instance for tuple makes sense this way... but it didn't really gave an example on why it would make sense to see it this way. The "a tuple is an annotated value" made it click for me (matches well with my knowledge of std::map in C++).
15:50:45 <fresheyeball> https://dpaste.de/YWKO/raw
15:50:57 <fresheyeball> for the life of me I can't get the constraints right
15:51:05 <fr33domlover> mniip, does it look like it's written correctly though? ^_^ I just based it on the foldl' from base
15:52:19 <lyxia> fr33domlover: another thing you might want to check out is StrictCheck https://hackage.haskell.org/package/StrictCheck
15:53:16 <hpc> fr33domlover: use an operation that isn't commutative
15:59:19 <fr33domlover> hpc, I tried with (:) but still got a = _ which is same as what I get with foldr
16:00:13 <fr33domlover> If someone can look at my function that would be wonderful :) I'm just not sure in 100% it's correctly strict the way foldl' is
16:01:29 <c_wraith> it'
16:01:41 <c_wraith> it's weird to call that fold, when it's a fold+filter
16:01:58 <c_wraith> err, fold + early termination?  ok, that makes a bit more sense
16:02:11 <hpc> fr33domlover: now do stuff that evaluates only part of the result
16:02:30 <hpc> like take 3, or isJust, or similar
16:02:43 <c_wraith> it follows the right pattern
16:04:02 <fr33domlover> c_wraith, yup fold + early termination ^_^
16:04:56 <c_wraith> k is applied to the right argument, ($!) is in the right place.
16:06:43 <c_wraith> I'd rather use foldl' + takeWhile + toList unless benchmarking told me it was a problem, though.
16:08:15 <fr33domlover> c_wraith, I simply copied the default foldl' implementation from Data.Foldable, just added the "if p z" part
16:15:05 <fresheyeball> actually, here is a better way of wording my problem
16:18:46 <fresheyeball> is there a way in beam to be polymorphic over tables?
16:20:22 * hackage haskell2020 0.1.0.0 - Haskell 2020[draft] Standard Library  http://hackage.haskell.org/package/haskell2020-0.1.0.0 (HerbertValerioRiedel)
16:43:42 <AfC> lyxia: yes, I think that's right.
16:51:52 <AfC> lyxia: (there's no explicit obligation to maintain build compatibility with any particular version of a dependency. If you have to bump a lower bound, you bump a lower bound).
16:55:00 <xelxebar> How does one go about installing lambdabot and goa locally these days? I recently discovered the "GHCi on Acid" setup described on the GHC/GHCi wiki, but install things with stack requires inordinate amounts of extra-deps
17:10:58 <dmj`> xelxebar: can always just use IRC
17:19:10 <iqubic> What are the S K I combinators?
17:19:26 <iqubic> I know that K = const, but I'm not sure what S and I are.
17:20:10 <Cale> I is id
17:20:17 <iqubic> What is S?
17:20:18 <Cale> S is <*> for (->) e
17:20:18 <Axman6> s is ap
17:20:19 <shachaf> I *am* id
17:20:37 <Axman6> I is id innit
17:20:42 <Cale> i.e. S f g x = f x (g x)
17:21:31 <monochrom> @type const <*> const
17:21:33 <lambdabot> b -> b
17:24:22 * hackage threads-extras 0.1.0.3 - Extends the threads package with a bounded thread group  http://hackage.haskell.org/package/threads-extras-0.1.0.3 (JonathanFischoff)
17:27:02 <iqubic> monochrom: Why are you looking at the type of "const <*> const"?
17:27:08 <iqubic> What do you need that for?
17:27:31 <Axman6> that's SKK
17:27:38 <Axman6> K`S`K
17:27:47 <iqubic> Sure. Why is that helpful?
17:28:07 <iqubic> What are the S K I combinators useful for?
17:28:14 <Axman6> they're turing complete
17:28:25 <Axman6> and I is redundant, since I = SKK
17:28:49 <iqubic> Also, I'm not seeing the isomorphism between S f g x = f x $ g x and <*> for (->)
17:29:05 <iqubic> How do you know those are the same function?
17:29:19 <Axman6> try it, look at the definitions
17:29:39 <iqubic> I don't know how <*> is defined for (->)
17:29:53 <iqubic> I don't even know what pure looks like for ((->) e)
17:30:28 <Axman6> :t (<*>) @((-> e)
17:30:29 <lambdabot> error: parse error on input ‘->’
17:30:34 <Axman6> :t (<*>) @((->) e)
17:30:36 <lambdabot> error: parse error on input ‘->’
17:31:27 <iqubic> :t (<*>)
17:31:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:31:39 <iqubic> That looks like (.)
17:31:48 <iqubic> Or not...
17:31:52 <Axman6> that becomes: (e -> (a -> b)) -> (e -> a) -> (e -> b)
17:32:17 <iqubic> Right.
17:32:24 <Axman6> so you have: s f g = ?
17:32:30 <iqubic> I don't know.
17:32:40 <Axman6> (or s f g x = ? if you prefer)
17:32:50 <Axman6> well figure it out, you wanted to know the answer, find it
17:33:08 <iqubic> f x has type (a -> b
17:33:15 <iqubic> g x has type a
17:33:37 <iqubic> so it's s f g x = f x $ g x
17:33:54 <Axman6> there you go, proof
17:34:03 <iqubic> Not sure how to write that without explicitly listing x as a parameter.
17:34:17 <iqubic> Also, what does pure look like for ((->) e)?
17:34:25 <Axman6> I don;t believe you can, since dpoing so requires ap/<*>
17:34:43 <Axman6> well, what would the type of pure be for ((->) e)
17:34:48 <Axman6> :t pure
17:34:50 <lambdabot> Applicative f => a -> f a
17:35:05 <Axman6> replace f with ((->) e)
17:35:08 <iqubic> a -> (e -> a)
17:35:18 <iqubic> Oh, wait that's const or K
17:35:45 <iqubic> is that right?
17:35:47 <Axman6> yep ;)
17:35:58 <iqubic> Cool
17:36:46 <iqubic> And I assume fmap for ((->) e) is (.)
17:36:57 <Axman6> and since we know SKK should be id, or I, we see that pure <*> pure is...
17:37:01 <Axman6> :t pure <*> pure
17:37:02 <lambdabot> error:
17:37:02 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
17:37:02 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
17:37:12 <Axman6> :t pure <*> pure :: (a -> a)
17:37:13 <lambdabot> error:
17:37:13 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
17:37:13 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
17:37:16 <Axman6> :(
17:37:32 <Axman6> :t const <*> const :: (a -> a)
17:37:33 <lambdabot> a -> a
17:38:13 <iqubic> Why is that ID?
17:39:26 <Axman6> walk through it
17:40:04 <iqubic> s f g x = f x $ g x.
17:40:20 <iqubic> s const const x = const x $ const x
17:40:35 <iqubic> s const const x = const x (const x)
17:40:42 <iqubic> = const x
17:40:51 <Axman6> nearly
17:40:54 <iqubic> but I'm not sure where to go with that.
17:40:59 <Axman6> that last step is wrong
17:41:14 <iqubic> s const const x = const x (const x)
17:41:21 <iqubic> Not sure where to go with that.
17:41:28 <Axman6> what's the definition of const
17:41:40 <iqubic> const a b = a
17:41:52 <Axman6> so, const x (const x) = ?
17:41:53 <iqubic> s const const x = const x (const x)
17:42:08 <iqubic> = const x
17:42:10 <iqubic> = x
17:42:14 <Axman6> good
17:42:23 <iqubic> I see. That's weird.
17:43:22 <iqubic> so why do we have I if we can just use S K K
17:43:54 <Axman6> simpler to type?
17:44:31 <iqubic> I suppose.
17:44:47 <Axman6> it is often called the SK calculus though
17:44:59 <iqubic> Does anyone ever use the monad instance of ((->) e)?
17:45:22 <Axman6> all the time, that's what Reader is (though wrapped in a newtype)
17:45:27 --- mode: glguy set +v manjaroi3
17:45:38 <iqubic> huh?
17:45:55 <iqubic> :k Reader
17:45:56 <lambdabot> * -> * -> *
17:46:03 <iqubic> :t Reader
17:46:04 <lambdabot> error:
17:46:04 <lambdabot>     • Data constructor not in scope: Reader
17:46:04 <lambdabot>     • Perhaps you meant one of these:
17:46:07 <Axman6> > ((+) <$> (*100) <*> (+10)) 7
17:46:09 <lambdabot>  717
17:46:21 <Axman6> trchnically that's just using applicative
17:46:30 <iqubic> What does that do?
17:46:37 <Axman6> anyway, it's useful when you need to pass the same argument to multiple functions
17:46:44 <Axman6> @src Reader
17:46:44 <lambdabot> type Reader r = ReaderT r Identity
17:46:45 <lambdabot> --OR
17:46:45 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
17:47:07 <iqubic> Wait.. That's just (100 * 7) + (10 + 7)
17:47:13 <iqubic> = 717.
17:47:17 <Axman6> yep
17:47:42 <Axman6> notice that 7 got passdedf to both the functions, without me having to give it a name
17:47:48 <iqubic> yes.
17:48:02 <manjaroi3> /msg NickServ help
17:48:02 <iqubic> And then it used + to glue the results together.
17:48:17 <iqubic> > ((,) <$> (*100) <*> (+10)) 7
17:48:18 <manjaroi3> :q
17:48:19 <lambdabot>  (700,17)
17:48:42 <iqubic> I see. That did exactly what I thought it would do.
17:49:11 <Axman6> > do { a <- (*100); b <- (+10); c <- pure (a + 2*b); pure (c + a)} 7
17:49:13 <lambdabot>  <hint>:1:66: error: parse error on input ‘7’
17:49:23 <Axman6> > (do { a <- (*100); b <- (+10); c <- pure (a + 2*b); pure (c + a)}) 7
17:49:25 <lambdabot>  1434
17:49:30 <Axman6> > (do { a <- (*100); b <- (+10); c <- pure (a + 2*b); pure (c + a)}) x
17:49:32 <lambdabot>  x * 100 + 2 * (x + 10) + x * 100
17:49:33 <iqubic> ((combine) <$> (f) <*> (g)) x = combine (f x) (g x)
17:50:11 <iqubic> is my last statement correct there?
17:50:19 <Axman6> yes
17:50:22 <iqubic> Cool.
17:50:38 <Axman6> > (h <$> f <*> g) x
17:50:40 <lambdabot>  error:
17:50:40 <lambdabot>      • Could not deduce (Show a0) arising from a use of ‘h’
17:50:40 <lambdabot>        from the context: FromExpr t
17:50:42 <Axman6> :(
17:50:51 <Axman6> :t f
17:50:52 <lambdabot> FromExpr a => a
17:50:59 <Axman6> :t f'
17:51:01 <lambdabot> FromExpr a => a
17:51:08 <Axman6> > (f' <$> f <*> g) x
17:51:10 <lambdabot>  error:
17:51:10 <lambdabot>      • Could not deduce (Show a0) arising from a use of ‘f'’
17:51:10 <lambdabot>        from the context: FromExpr t
17:51:20 <Axman6> > (f' <$> f <*> g) x :: Expr
17:51:23 <lambdabot>  error:
17:51:23 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘f'’
17:51:23 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:51:46 <iqubic> Well, I was doing some coding the other day and saw that monoid is now a subclass of semigroup in GHC proper.
17:51:52 <iqubic> When did that change happen.
17:51:54 <iqubic> ??
17:52:38 <iqubic> I'm refering to the fact that we now have "Class Semigroup a => Monoid a where..."
17:52:53 <Axman6> check the ghc release notes
17:53:08 <iqubic> I will.
17:53:17 <MarcelineVQ> in a new enough ghc you can also write: :doc Monoid
17:53:18 <iqubic> It's just unexpected to see that.
17:53:25 <Axman6> :o
17:53:26 <MarcelineVQ> Which will say __NOTE__: 'Semigroup' is a superclass of 'Monoid' since /base-4.11.0.0/
17:53:50 <MarcelineVQ> Which doesn't quite tell you ghc version but you can look up from there
17:54:04 <iqubic> I wanted to know what the GHC version was.
17:54:05 <Axman6> :O:O:O
17:54:18 <Axman6> I hadn't seen :doc before
17:54:42 <Axman6> I think I remember reading about it in the release notes but didn't try it
17:55:07 <iqubic> I think GHC 8.4.4 has that feature baked in.
17:55:23 * hackage hw-streams 0.0.0.9 - Primitive functions and data types  http://hackage.haskell.org/package/hw-streams-0.0.0.9 (haskellworks)
17:56:12 <MarcelineVQ> What's nice about a doc feature is that this is a big win for editor integration, one of the nicer things about idris for example is that you can request the 'doc' for some identifier you're looking at at-will, such a feature for haskell is a big deal
17:56:35 <MarcelineVQ> at-will in yout editor I mean, as well as the repl
17:58:13 <iqubic> I don't think my editor tools have that feature built in.
17:58:43 <iqubic> What else does ":doc" do besides giving that __NOTE__ thing.
17:59:34 <Axman6> show documentation :\
17:59:42 <MarcelineVQ> Gives the the documenation you'd see in haddock
17:59:50 <jean-lopes> ;
17:59:50 <MarcelineVQ> So laws and such for monoid
18:00:08 <iqubic> Oh... That's really cool.
18:01:38 <iqubic> Does :doc work for functions defined in external libraries downloaded from hackage?
18:01:57 <MarcelineVQ> afaik it works as long as the haddock docs are built for them
18:02:14 <MarcelineVQ> but I've not tried
18:15:23 <ACheesyName> Perhaps you haven't installed the profiling libraries for package ‘random-1.1’? <-- how do I fix this?
18:15:57 <Clint> how did you install random?
18:16:05 <ACheesyName> I forget
18:16:11 <ACheesyName> probably with cabal
18:18:32 <jle`> iqubic: note that ghc versions are tied to base versions
18:19:00 <jle`> @tell iqubic so knowing base essentially determines the ghc version
18:19:00 <lambdabot> Consider it noted.
18:19:37 <jle`> @tell iqubic i always use this as a reference https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
18:19:38 <lambdabot> Consider it noted.
18:19:40 <ACheesyName> I think the right command is: cabal install --reinstall -p random but it tells me that doing so would break other installed packages
18:19:59 --- mode: glguy set +v adetokunbo
18:20:01 <ACheesyName> I guess this is why you use stack
18:21:59 <adetokunbo> hello!
18:24:02 <adetokunbo> when using type applications, specifying one type looks like >>> id @Int 3
18:24:21 <adetokunbo> what if I need to specify multiple types ?
18:30:49 <jle`> adetokunbo: you can do `fmap @[] @Int`
18:31:18 <jle`> ? :t fmap @[] @Int
18:31:29 <jle`> ... i forgot how to use yahb heh
18:31:37 <adetokunbo> jle`: thanks, I'll give that a try
18:32:14 <jle`> % 
18:32:14 <yahb> jle`: 
18:32:34 <jle`> % :t fmap @[] @Int
18:32:34 <yahb> jle`: (Int -> b) -> [Int] -> [b]
18:32:53 <jle`> % :t fmap @IO @String
18:32:53 <yahb> jle`: (String -> b) -> IO String -> IO b
18:32:59 <jle`> % :t fmap @IO @String @Bool
18:32:59 <yahb> jle`: (String -> Bool) -> IO String -> IO Bool
18:33:15 <jle`> adetokunbo: the order usually is the order that the type variables first appear in the type signature
18:33:28 <jle`> adetokunbo: unless the type variables are explicitly given using forall. syntax
18:35:17 <adetokunbo> jle`: thanks - I was missing the bit about the order :) 
19:38:51 <iqubic> Is this channel dead?
19:38:56 <Clint> no
19:39:57 <iqubic> Why is no one talking right now?
19:40:40 <MarcelineVQ> you're talking
19:41:01 <amalloy> evidently nobody has anything to say at the moment
19:59:51 <ACheesyName> what data structure do you use in haskell when you need efficient random access, random replace, random delete?
20:06:52 * hackage hw-streams 0.0.0.10 - Primitive functions and data types  http://hackage.haskell.org/package/hw-streams-0.0.0.10 (haskellworks)
20:10:27 <pavonia> ACheesyName: For delete, is releasing memory important?
20:11:21 <ACheesyName> I would say yes. my program currently allocates 17GB total
20:14:04 <ACheesyName> well maybe it's not so important to release memory; the program does 100 randomly-generated test cases that are independent so the memory for each test case could be released at the end of it
20:16:59 <pavonia> For random access and update a mutable Array or Vector are suitable
20:23:01 <ACheesyName> I'll look into the vector out of interest but I now realize it's probably not much use I just profiled the program and most of the time is lost in random number generation
20:27:48 <coldpress> is there an elegant way to, given some parser functions, unparse an AST to recover the original input?
20:31:23 <koz_> coldpress: You could define an isomorphism between the input and an AST, but that's difficult to do in general. Consider comments, for example. Or whitespace.
20:31:43 <coldpress> ignore whitespace
20:40:15 <AfC> coldpress: if the transformation is lossless, then a way to do this sort of thing could be a Prism / Iso
20:41:13 <MarcelineVQ> coldpress: there are parsers that are also pretty printers aka Reversible parsing or Invertible Syntax. libs such as boomerang, syntax, Roundtrip, invertible-syntax
20:44:49 <coldpress> MarcelineVQ: I understand they exist, but I'd rather understand the inner workings
20:51:06 <bifunc2> Is folding sequences (Data.Sequence) always strict?
20:51:10 <bifunc2> (like foldl' is for lists)
20:54:50 <coldpress> will comonads work?
20:55:02 <coldpress> for unparsing
20:56:23 <mniip> comonadic coparsing
21:02:31 <Tops2> coldpress: https://youtu.be/IJ_bVVsQhvc?t=18m2s (I linked the position where he starts talking about Printers)
21:16:10 <jle`> coldpress: check out bidirectional parsers
21:16:31 <jle`> there's some body of theory on it
21:17:23 <coldpress> Tops2: so i just need to define Decidable and Divisible?
21:18:11 <jle`> coldpress: you can't do it without explicitly implementing for it
21:18:37 <jle`> abstractions work the other way around, you don't 'add Decidable', and suddenly it's Decidable
21:19:00 <jle`> instead, something is already Decidable, and you write an instance for it
21:20:03 <jle`> besides free constructions, like free monoids and free monads, for example :)
21:22:15 <jle`> in the end, though those free constructions just delay the actual logic you're goign to have to implement
21:22:47 <jle`> but it can be a convenient way to separate concerns
21:33:21 <dmj`> free stuff has hella' allocations tho, caveat emptor
21:37:59 <larryba> hello. I am reading https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions , that tries to demonstrate issues with catching SomeException (catching async exceptions, causing some unwanted consequences). but I can't replicate this behavior. I even changed his timeout for 10 ms code to infinite recursion, and timeout is still able to kill the thread. what gives?  http://dpaste.com/3HQEPV6
21:39:28 <larryba> were there some changes since that article was written?
21:41:19 <osa1> larryba: try compiling with threaded runtime
21:41:30 <larryba> I did
21:41:43 <larryba> tried in ghci, compiled with normal flags, and with threaded runtime. same behavior
21:43:34 <osa1> larryba: first, timeout will be able to kill the thread unless you mask async exceptions in the thread
21:43:38 <osa1> which is not the case in this code
21:43:45 <osa1> so I don't know why you're expecting timeout to not kill the thread
21:44:26 <Arahael> osa1: He's probably expecting that "catching all exceptions" catches all exceptions.
21:44:36 <larryba> osa1 because article above said it won't.
21:44:39 <larryba> worker's catchAny catches all exceptions, and therefore treats the timeout exception as if it was thrown from dangerous itself. It therefore continues processing, completely ignoring the command to timeout.
21:44:51 <larryba> ^^ from https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
21:45:57 <osa1> Arahael: does it not? I see that it's catching "timeout" exception
21:47:01 <larryba> oh
21:47:15 <osa1> larryba: maybe the article is wrong, I don't know (haven't read it). what I know is this code is working as expected.
21:47:45 <larryba> I don't know what I was thinking
21:49:24 <larryba> timeout should have killed thread worker was running in, but instead, worker thought it was exception thrown from dangerous, and continued on its merry way
21:52:19 <larryba> adding     threadDelay 10000000 at the bottom of worker action demonstrates the issue better
22:03:14 <dmj`> what's the best way to go from [Word8] -> Vector Word16
22:12:23 * hackage streamly 0.6.0 - Beautiful Streaming, Concurrent and Reactive Composition  http://hackage.haskell.org/package/streamly-0.6.0 (harendra)
22:14:18 <MarcelineVQ> drink water
22:15:31 <MarcelineVQ> dmj`: given that that's upsizing, fromList . map fromIntegral seems pretty reasonable. I'm assuming Vector has fromList
22:19:26 <dmj`> yea but I think I need to combine two Word8s into a Word16
22:19:49 <dmj`> can just do some masking I guess
22:27:19 <dmj`> MarcelineVQ: I'm implementing a virtual machine
22:28:46 <MarcelineVQ> gonna make a ps3 emulator?
22:29:46 <dmj`> MarcelineVQ: lol that would be intense
22:30:24 <dmj`> omg https://github.com/RPCS3/rpcs3
22:30:26 <dmj`> some people
22:31:45 <dmj`> MarcelineVQ: its this one https://justinmeiners.github.io/lc3-vm/
22:31:55 <MarcelineVQ> hehe yeah, it's quite active dev too :> I'm patiently awaiting for that to run a certain game without crashing after too many screen transitions. I've got a script set up to pull and built it every couple days
22:32:28 <MarcelineVQ> oh that's fun dmj`
22:33:21 <dmj`> MarcelineVQ: yea! it def. is. Working on the TRAP routines right now
22:33:28 <dmj`> MarcelineVQ: https://github.com/dmjio/LC3/blob/master/src/Main.hs
22:34:01 <dmj`> real nice with lens + state monad
22:34:58 <dmj`> might be fun to do the assembler too
22:36:18 <MarcelineVQ> I was doing similar in a dependent language recently, defining assembly for some chip, got sidetracked though.
22:37:14 <dmj`> yea, getting nerd-sniped on something else is all too common
22:37:34 <dmj`> hard to stay focused these days, too much stimuli
22:47:23 <MarcelineVQ> can recommend factoring out all the r0/r1 in loop and trading that space you saved for more descriptive names for r0/r1
22:53:23 <iqubi4> Is this working
22:54:21 <dmj`> MarcelineVQ: yea, should be src and dest instead
22:55:22 * hackage grid 7.8.12 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.12 (AmyDeBuitleir)
22:55:25 <MarcelineVQ> dmj`: aha, I wouldn't have guessed that hehe
22:58:24 <dmj`> MarcelineVQ: just added TRAP, unsure I did it right though for puts and putsp. 
22:59:07 <MarcelineVQ> dunno about that, just started learning this stuff recently, maybe I should try this tut and we can compare
22:59:14 <MarcelineVQ> you sure like guards :D
22:59:18 <pounce> if i have an Ord a then is [a] Ord too?
22:59:54 <dmj`> MarcelineVQ: all about that guard life
22:59:56 <MarcelineVQ> yep instance Ord a => Ord [a]
22:59:58 <larryba> MonadThrow is pretty awesome. is anyone using it?
23:00:04 <pounce> cool
23:00:45 <larryba> same function can be used in Maybe, Either or IO monads, with no conversions. http://dpaste.com/1DVE9GM
23:03:29 <dmj`> MarcelineVQ: they actually care about the specific address in memory the instructions get loaded to
23:09:14 <rnmhdn> how can I have a haskell repl in linux?
23:09:22 <rnmhdn> I've already installed ghc
23:09:30 <iqubi4> rnmhdn: 
23:09:37 <iqubi4> Just run ghci
23:10:15 <rnmhdn> nice, some people use something that it's prompt starts with lambda sign, what is that?
23:10:28 <rnmhdn> btw i is for interpreter?
23:10:57 <iqubi4> interactive actually.
23:11:00 <larryba> haskell that is emacs haskell mode. but you can set prompt in ghci too
23:11:10 <larryba> ^^ rnmhdn
23:11:20 <dmj`> :set prompt "λ "
23:11:51 <rnmhdn> no I don't want it to look like that I wanna know what that person was using 
23:11:58 <rnmhdn> it also starts off saying a lot of hacking awaits
23:12:04 <rnmhdn> if I crash ...
23:12:37 <coldpress> huh, which person?
23:13:16 <rnmhdn> https://www.youtube.com/watch?v=fCoQb-zqYDI
23:15:16 <coldpress> pretty sure he uses emacs
23:15:29 <iqubi4> Yes. That is indeed emacs
23:16:52 <coldpress> or you could learn Vim then use haskeline's vi mode
23:31:53 * hackage matchable 0.1.2 - A type class for Matchable Functors.  http://hackage.haskell.org/package/matchable-0.1.2 (viercc)
23:34:18 <larryba> > join [[1,2,3],[4,5,6]]
23:34:20 <lambdabot>  [1,2,3,4,5,6]
