00:28:37 <koz_> OK, bug found - caused by premature optimization...
01:58:11 <Jetien> join #nixos
02:00:37 <c50a326> "3.2.4 Define a function intpairs so that (intpairs n) is a list of all distinct pairs of integers 1 <= x , y <= n." (Bird, Wadler, Introduction to Functional Programming)
02:00:52 <c50a326> What's 'x' all about here? :S
02:01:25 <c50a326> oh nvm sorry
02:02:19 <c50a326> both elements should be greater than 1 and less than n... wow that was like the dumbest elementary school question I just asked... how embarrassing...
02:02:31 <c50a326> first brain exercise of the morning, excuse me
02:03:44 <bor0> well it doesn't say exactly that. the first element should be greater than or equal to 1, and the second should be less than or equal to n (second being 0 will work according to this given definition)
02:03:47 <bor0> it's a bit vague
02:04:59 <bor0> "all pairs (x, y) for 1 <= x, y <= n" sounds better
02:05:45 <bor0> actually I just wrote what you wrote, but I misread yours as (1 <= x), (y <= n). first brain exercise for me, too :D
02:05:59 <c50a326> yeah that's the kind of confusion my brain was going through actually lol
02:06:15 <Ariakenom> silly informal math syntax
02:06:28 <bor0> brain parsing!
02:07:27 <bor0> 1 <= x <= n, 1 <= y <= n works at any time of the day! :)
02:07:42 <Ariakenom> let f a = 1 <= a && a <= n in f x && f y
02:11:02 <Ariakenom> x `elem` [1..n] && y `elem` [1..n]
02:11:52 <bor0> > let intpairs n = [ (x, y) | x <- [1..n], y <- [1..n] ] in intpairs 3
02:11:54 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
02:13:19 <Ariakenom> > let n=3 in liftA2 (,) [1..n] [1..n]
02:13:21 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
02:13:53 <Putonlalla> @let intpairs = join (liftA2 (,)) . enumFromTo 1
02:13:55 <lambdabot>  Defined.
02:15:40 <c50a326> you can't go backwards like [5..1]? Hmm
02:16:05 <Ariakenom> > [5,4 .. 1]
02:16:05 <c50a326> obviously have `reverse` for that I guess
02:16:07 <lambdabot>  [5,4,3,2,1]
02:16:09 <c50a326> oh, cool
02:17:41 <merijn> c50a326: Various combinations of .. are syntax for the functions from the Enum class (specifically, enumFrom, enumFromThen, enumFromTo, enumFromThenTo, but they don't compare the begin and end elements
02:21:41 <liste> > [1.0, 1.1 .. 2.0]
02:21:43 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
02:21:54 <liste> > [1.7, 1.8 .. 2.0]
02:21:56 <lambdabot>  [1.7,1.8,1.9000000000000001,2.0]
02:22:29 <liste> there was some gotcha in that for Doubles
02:22:33 <liste> but I can't remember now
02:22:55 <Ariakenom> > [0,2 .. 3.0]
02:22:57 <lambdabot>  [0.0,2.0,4.0]
02:27:19 <c50a326> https://ptpb.pw/NtWk/hs this can't be right... it just prints out [(n,n,n,n), (n-1,n-1,n-1,n-1) ... and so on]... but then that does seem to fulfill the exercise question... hmm
02:27:40 <c50a326> also I just googled quadruples and pythagorean quadruples are supposed to be like a^2 + b^2 + c^2 = d^2
02:27:48 <c50a326> not a^2 + b^2 = c^2 + d^2
02:27:58 <c50a326> wonder if it's a trick or mistaken question
02:28:12 <c50a326> (it's in the paste in the comment)
02:29:52 <berndl>  ##dependent
02:33:19 <merijn> liste: The Double one is evil, that's the gotcha
02:34:16 <merijn> It tries to hack around compounding rounding errors, but that ends up overshooting the end condition
02:34:25 <merijn> > [0,2..3]
02:34:28 <lambdabot>  [0,2]
02:34:39 <merijn> Compare that to Ariakenom's example for Double
02:34:56 <merijn> Just don't ever use Enum for Double, tbh
02:36:57 <liste> map fromIntegral [0,2..3] :: [Double]
02:37:00 <liste> > map fromIntegral [0,2..3] :: [Double]
02:37:02 <lambdabot>  [0.0,2.0]
02:47:39 <c50a326> poweror x n = [ x' + x' | n' <- [n, n-1 .. 0], n' > 0, x' <- repeat x ] -- why does this loop infinitely when called with `poweror 2 5` ?
02:47:57 <c50a326> obviously because of `repeat`, but surely the n should reach 0 and everything should stop...
02:49:01 <merijn> c50a326: Well, why wouldn't it?
02:49:26 <merijn> c50a326: There's always another x to try
02:50:19 <c50a326> oh yeah it doesn't need any n's lol
02:50:24 <merijn> c50a326: You're looping over two lists there, "[n, n-1..0]" and "repeat x", for every elements in the first list *and* every element in the second it'll run
02:50:36 <merijn> And since the second never finishes, it'll keep going forever
03:11:14 <nshepperd1> > fromEnum 0.7
03:11:16 <lambdabot>  0
04:11:53 --- mode: glguy set +v dataN
04:12:07 --- mode: glguy set -v dataN
04:24:12 <c50a326> hey what's up with this https://lpaste.net/3467837988715626496 howcome I can't do point-free/partial stuff here?
04:24:44 <tdammers> c50a326: because you're trying to cross two args off the end
04:24:54 <merijn> c50a326: "zipWith (*)" gets only one argument before getting passed to sum
04:25:16 <Axman6> expand the definition of (.) and you'll find you have written \x -> sum (zipWith (*) x)
04:25:52 <Axman6> so you end up with the equivalent of sp' xs ys = sum (zipWith (*) xs) ys
04:26:08 <c50a326> so what do you do?
04:26:24 <merijn> c50a326: Only chop of one argument
04:26:25 <Axman6> use the top definition, it's fine
04:26:29 <merijn> Or use superconfusing combinators
04:27:02 <Axman6> you _could_ make it point free, but it's not nice; sp' = (sum .) . zipWith (*) -- IIRC
04:27:43 <Axman6> @pl sp xs ys = sum $ zipWith (*) xs ys
04:27:43 <lambdabot> sp = (sum .) . zipWith (*)
04:27:49 * Axman6 nailed it
04:27:52 <c50a326> ah, the book thing I'm reading, their zipwith function takes a tuple of lists
04:28:07 <c50a326> so they can make scalar product point-free more easily that way I guess
04:29:09 <mnoonan> I like this combinator, personally: f .: g = \x y -> f (g x y)
04:29:49 <mnoonan> then you can do "sum .: zipWith (*)"
04:32:27 <hxclurk> Hello
04:33:00 <Axman6> o/
04:33:25 <Gurkenglas> ((f .: g) x = f . g x, compare with (f . g) x = f $ g x)
04:33:53 <hxclurk> I have only minimal experience with functional languages (did some Scheme with SICP book) but have a lot of experience with languages not purely functional, I wanted to ask, which tutorial/book/resource would be best for someone like me to start learning Haskell? I have checked few but they were assuming that reader had no programming experience whatsoever.
04:36:15 <phadej> hxclurk: https://www.cambridge.org/fi/academic/subjects/computer-science/programming-languages-and-applied-logic/programming-haskell-2nd-edition might suit you
04:37:08 <hxclurk> Thank you
04:37:32 <lalbornoz> https://www.goodreads.com/book/show/25587599-haskell-programming-from-first-principles
04:37:44 <phadej> that's definitely not good for people with programming experienc
04:38:01 <phadej> from first principles is way too slow paced for that
04:38:10 <phadej> (and too thick)
04:38:17 <hpc> hxclurk: depending on your programming style with scheme, you may find the hardest thing to learn is just how to not reflexively drop back into imperative style ;)
04:39:08 <hxclurk> hpc: I don't have one because I used Scheme only for going through few chapters of SICP
04:41:52 <phadej> SICP silently introduces imperative stuff in chapter 2. :)
05:05:27 <dataN> how can this be written? https://lpaste.net/1021191571988545536
05:05:52 <dataN> functions can be defined using conditional guards, such as f a | otherwise = a
05:06:01 <dataN> but this is not available for type families
05:07:00 <dataN> how can a pattern be skipped if it does not match a type equality?
05:07:10 <phadej> type family Helper input output where Helper input 'True = ...; ... type Real a = Helper a (OtherFamily a)
05:07:20 <phadej> i.e. you have to do tricks
05:07:25 <phadej> and auxiliary families
05:08:15 <phadej> or use `If` type-family
05:08:19 <dataN> thats more like an if then else pattern?
05:08:33 <phadej> yeah
05:08:41 <dataN> but this cant easily be extended to matching arbitrarily many patterns 
05:09:15 <phadej> 1) type-level haskell is not term level haskell 2) term level haskel has a lot of syntax sugar :)
05:09:38 <dataN> ok, nested if statements it is!
05:09:48 <phadej> yeah, the best you can do now :(
05:10:07 <dataN> thanks
05:10:58 <dataN> is it bad syntak to be able to use whats written on like 26 of the paste?
05:11:10 <dataN> syntax* 
05:11:46 <dataN> Illegal qualified type: ('True ~ IsConstraint a) => a
05:11:55 <dataN> ConstraintArity ('True ~ IsConstraint a => a :: *) = Just (Arity a)
05:12:25 <phadej> it's wrong. You cannot make decisions based on whether a constraint is satisfiable
05:12:30 <dataN> which should fail to match and then try the next pattern
05:13:26 <phadej> so you /could/ have syntax sugar like ConstraintArity a | IsConstraint a = Just (Arity a) -- because IsConstraint :: ... -> Bool
05:13:43 <phadej> but there isn't such
05:14:38 <phadej> (and it's problematic too because type families are weird)
05:14:41 <dataN> oh so its only because this constraint will always return a Bool kinded type... 
05:14:57 <phadej> IsConstraint is /type family/
05:15:47 <dataN> right yeah sorry, s/constraint/type family
05:17:38 <dataN> any ideas about a type family State for Unfold to use in PolyKinded?
05:17:47 <dataN> (in the paste)
05:18:20 <dataN> cant quite figure how to write that 
05:18:44 <dataN> (tpye family version of type State s a = s -> (a,s)
05:18:48 <dataN> )
05:19:53 <dataN> unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:20:32 <dataN> maybe in needs a symbol for the state function...
05:22:11 <phadej> dataN: you might enjoy reading https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/ug-prizes-201718/Csongor-Kiss-Higher-order-type-level-programming-in-Haskell.pdf
05:22:32 <phadej> i.e. TL;DR what you try to do is very painful to do in current GHC Haskell
05:22:45 <dataN> and if this was of a class Unfoldable f where unfoldr :: (b -> Maybe (a, b)) -> b -> f a, how can such a class be written at type level?
05:24:24 <dataN> the paper has something similar;
05:25:48 <dataN> class Functor 0 (f :: * ~> *) where fmap0 :: (a → b) → f @@ a → f @@ b
05:26:01 <dataN> class Functor'
05:26:17 <dataN> but this lower case fmap is not a type family
05:28:04 <dataN> its possbile to write type level Fmap, but there is no way to make a constraint for all the types it is defined over?
05:30:25 --- mode: glguy set +v astrix
05:31:27 <astrix> Hi I am using cabal new-build to build my project. but the final executable gets stored in an obscure location like "dist-newstyle/build/x86_64-osx/ghc-8.2.2......."
05:32:02 <astrix> do I have to always move to that location and execute it
05:32:13 <astrix> I tried something like cabal new-run
05:32:32 <astrix> but that doesn't seem to work. I thought the task of new-run is to run the executable
05:32:39 <astrix> it just says "up to date"
05:33:06 <astrix> so how do I run an executable in cabal without always switching to the remote directory
05:33:12 <petercommand> cabal exec?
05:33:19 <phadej> cabal new-run should work
05:33:38 <phadej> cabal new-run exe-name -- --flags
05:34:00 <dataN> "GHC supports kind classes via a poly-kinded type class definition" from "Promoting Functions to Type Families in Haskell, Richard A. Eisenberg, 2014"
05:34:05 <dataN> https://repository.brynmawr.edu/cgi/viewcontent.cgi?referer=https://www.google.co.uk/&httpsredir=1&article=1000&context=compsci_pubs
05:34:15 <milesrout> has nobody noticed that the error message for the pattern matcher exceeding its iteration limit has a typo?
05:34:26 <milesrout> "to set the maximun number of iterations to n"
05:34:27 <petercommand> hmm, what's the difference between 'cabal exec' and 'cabal run'?
05:34:38 <milesrout> because I've read that error message dozens of times and I only noticed it today
05:34:55 <milesrout> and I googled it and it appears in 2016, so the typo has been around for a while
05:35:08 <phadej> petercommand: `run` "builds" and "runs", `exec` setups an environment as if you were building etc.
05:35:55 <astrix> cabal new-run <exe-name> just emits "Up to date"
05:36:16 <phadej> - cabal new-run [TARGET [ARGS]] runs the executable specified by the target; 
05:36:18 <phadej> - cabal new-exec [FLAGS] [--] COMMAND [--] [ARGS] runs the specified command using the project’s environment
05:36:28 <phadej> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-new-run & https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-new-exec
05:36:55 <phadej> astrix: are you sure your program isn't just `main = return ()` - should it output something etc?
05:37:19 <phadej> and what's cabal --version says (I recommend upgrading to cabal-install-2.4.0.0)
05:37:49 <astrix> my program actually writes a file
05:38:11 <astrix> and I am using Cabal 2.0.0.2 and cabal-install 2.0.0.0
05:38:26 <phadej> please upgrade, and try again
05:38:27 <astrix> I don't seem to have anything called "new-exec" in this version
05:38:46 <phadej> astrix: you shouldn't use new-exec for this anyway
05:39:41 <hexagoxel> my code gives "no instance A X", but when I implement "instance B X", the error vanishes. "instance B X" does not imply "instance A X". Is this bad error message caused by OverlappingInstances?
05:39:45 <astrix> alright I will try upgrading
05:40:38 <lyxia> hexagoxel: I think we need to see the code
05:40:48 <hexagoxel> (and sorry, i don't have a minimal testcase for this, yet - wondering if this is a known issue in some way)
05:41:44 <lyxia> does "instance B X" have no constraints?
05:42:42 <lyxia> and is B not a multiparam typeclass with fundeps?
05:43:19 <lyxia> (trying to enumerate all I can think of)
05:44:43 <hexagoxel> A is https://hackage.haskell.org/package/groundhog-0.9.0/docs/Database-Groundhog-Core.html#t:PrimitivePersistField
05:44:53 <hexagoxel> B is https://hackage.haskell.org/package/groundhog-0.9.0/docs/Database-Groundhog-Core.html#t:PrimitivePersistField
05:45:05 <hexagoxel> whoops
05:45:16 <hexagoxel> B is https://hackage.haskell.org/package/groundhog-0.9.0/docs/Database-Groundhog-Core.html#t:PurePersistField
05:46:05 <dataN> sounds repetitive 
05:46:50 <hexagoxel> i think the involved overlapping is at https://hackage.haskell.org/package/groundhog-0.9.0/docs/src/Database.Groundhog.Expression.html#line-70
05:48:04 <hexagoxel> lyxia: so i think the answers are: no fundeps, and A and B share the same superclass.
05:52:26 <hexagoxel> i wonder if this a result of the tricks laid out in https://wiki.haskell.org/GHC/AdvancedOverlap
05:54:25 <milesrout> flexiblecontexts is fairly safe right
05:56:03 <davr0s> IO monad source:   bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s)
05:56:03 <davr0s>   .... what are those (#   #) ?  'template haskell' ?   
05:56:17 <milesrout> i think that's an unboxed tuple right
05:56:35 <milesrout> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/primitives.html#unboxed-tuples
06:02:09 <dataN> hexagoxel: the error messages from that kind of style are not so helpful because of how it confuses the compiler sure
06:18:08 <davr0s> so I have a bunch of functions which  do sometihng like this:-
06:18:43 <davr0s> foo ::   Source ->  Maybe (t, Source )     ... a primitive parser 
06:19:24 <davr0s> the question I have is,    can I 'instance some classes'  to make these work with the official '>>='   etc
06:19:40 <davr0s> or do you have to start out very differently
06:20:21 <pie_> i found some code for it but has anyone here actually used code across haskell/python python/haskell
06:20:33 <davr0s> wuold i have to adapt them a bit eg    foo::  ((),Source)  ->  Maybe (t,Source)
06:20:50 <Ariakenom> davr0s: You'd want a newtype
06:21:17 <Ariakenom> newtype Parser a = Parser (Source -> Maybe (t,Source))
06:21:19 <davr0s> (i can see how to make my own 'combinator' , i think thats the pattern i implemented with my `orElse`)
06:21:51 <Ariakenom> and then you can instance Monad Parser where (>>=)  = ...
06:22:09 <davr0s> Ariakenom ok - i had started down that route literally, 
06:22:35 <davr0s> i'll try a bit more and see how far I get..
06:22:56 <davr0s> at least i know thats a valid step thanks
06:23:34 <Ariakenom> np this will be the best parser
06:26:32 <davr0s> i was always confused by my reading of ::IO t  ... but I think I saw a description that it actually works a bit like  IO t =  ::World->(World,t))   .. so it is actually   tacking a 'world parameter' onto functions    (to make actions hat take a world and update it)   ?
06:26:59 <ski> yes and no
06:27:06 <davr0s> i always wanted to read >>= as 'composing actions, which you can squirt a value through...'   but my misreading of 'IO ' was retarding that, 
06:27:14 <Ariakenom> Myself I'm not a fan of that view for understanding IO
06:27:25 <davr0s> supopsedly it's also intrinsic to the implementation
06:28:04 <ski> that can be a useful stepping-stone, for some people, to understand `IO' as a state-threading computation. however, that model doesn't describe interleaving (scheduling) of processes/threads, e.g.
06:28:18 <Ariakenom> How was the actions view a misread?
06:28:21 --- mode: glguy set +v Boarders
06:28:50 <davr0s> i think i read it right,   but wasn't quite seeing how that meshed with what I mis-read about IO t
06:29:20 <Ariakenom> Hm, I don't get what misread means here.
06:29:23 <cocreature> imho the best way of viewing IO is to see a value of type IO a as some kind of AST that represents the instructions for computing a value of type a
06:29:25 --- mode: glguy set -v Boarders
06:29:41 <davr0s> i.e. i think I got ">>=" right, but understanding IO wrongly stopped me cementing my reading of >>=
06:30:22 <maerwald> cocreature: what?
06:30:24 <ski> in GHC, `IO' is internally implemented by threading around a `RealWorld' token (which will get removed (occupy zero bits) when compiled down to machine code). the purpose of this is to ensure that data dependencies of this `RealWorld' imply the intended control dependencies (what happens before what). however, it's better to think of this implementation as not written in Haskell, but in a language with side-effects, which looks like Haskell
06:30:42 <ski> (hr, prob. cut off near ".., but in a language with side-effects, which looks like Haskell")
06:30:45 <davr0s>  "it's composed actions,  which can be applied to  a world , to produce a value'?
06:31:26 <davr0s> the point is however IO does or doen't work under the hood, the way all the >>= stuff works really is more like that? (combinign actions to squirt a value thru)
06:31:58 <ski> produce a value, *and* a new state of the world, is what the `State RealWorld' model would give you
06:32:43 * ski idly wonders whether davr0s has already seen (and grokked) the state monad
06:34:45 <maerwald> I more and more feel it's rarely a good idea to share ones own intuition about concept XY. Give pointers on how to build up intuition instead
06:34:48 <ski> (another problem with threading a `RealWorld' state around is that this really should require something like uniqueness types (as in Clean and Mercury), or linear types (perhaps recent work by Simon, ...). ordinary Haskell doesn't give you the guarantee that a `RealWorld' state is used exactly once (not copied, say))
06:35:40 <ski> (i suppose Rust has something similar, though i'm not enough familiar with that to compare)
06:35:43 <maerwald> I think we already lost him
06:35:45 <cocreature> davr0s: I think “combining actions to squirt a value thru” is too vague to say whether it’s true or not
06:35:54 <Ariakenom> ski: since there is no way to combine it there is just a single threading of the token
06:36:39 <ski> Ariakenom : you could, inadvertently (or not), reuse an earlier token (throwing away a later one). that's bad
06:36:45 <davr0s> cocreature could you make a statement at a similar level that is more instructive
06:36:50 <cocreature> davr0s: you can think of main :: IO () as producing some kind of AST that represents the IO actions that is then interpreted by the RTS
06:37:05 <ski> Ariakenom : hm, or perhaps you're saying that then the dead branch wouldn't be forced ?
06:37:29 <davr0s> ok, so there really is no 'value squirting' in the IO model
06:37:39 <cocreature> I still have no idea what that is supposed to mean, sorry :)
06:37:42 <maerwald> value squirting...
06:37:42 <Ariakenom> ski: yes
06:38:17 <davr0s> (no necesary value squirting) .. think of all the OOP code which really does pass 'system objects' areound or make methods on a system object. there's a pointer to a current state, an aweful lot
06:38:35 <davr0s> although perhaps you're saying the system globals really are a special case
06:38:38 <Putonlalla> If you squeeze values hard enough, some juice will come out, maerwald.
06:38:48 <maerwald> lol
06:38:49 <ski> a value of type `IO a' can be seen as a "series of instructions (possibly including branches, loops, &c.)" or a "recipe", for how to interact with the world (the OS) to obtain a result value of type `a'
06:39:27 <maerwald> IO is just instructions for the RTS, nothing happens during evaluation
06:39:41 <cocreature> Haskell separates execution (i.e. the execution of IO actions) from evaluation, e.g., evaluating 1 + 1 to 2
06:39:55 <davr0s> maerwald that i get
06:40:16 <ski> there's a notion of "execution of action", for `IO'-actions, this is done by the RTS. an `IO'-action (a value of type `IO a', for some type `a') is executed by following the instructions for interaction, eventually getting back a value of type `a' (or perhaps not, if there's an exception ...)
06:40:31 <davr0s> or i think i get.   "composing actions...', it's just i was adding 'squitr a value through' thinking of OOP value with a 'system' pointer
06:40:36 <Ariakenom> concurrent monad tutorials are the best monad tutorials
06:41:45 <ski> `(>>=)' combines an action of type `IO a' and a function that given a result of the previous action, of type `a', will produce a "continuation" action `IO b'. one can think of this function-producing-an-action as "an action which depends on the result of a previous action". `(>>=)' combines these two pieces into a new action of type `IO b'
06:41:54 <maerwald> there is not much magical about IO. I don't know why people write essays about it
06:42:17 <maerwald> You can have similar things in other programming languages, except it's rarely the default
06:42:40 <ggole> IO lists in Erlang are kinda similar
06:43:46 <ski> such that : if the resulting action of type `IO b' is ever executed by the RTS, then that happens as : the action of type `IO a' is first executed, then its result of type `a' (unless there's an exception) is passed to the function, producing an action of type `IO b' describing how to continue (which may depend on the value produced in the previous step)
06:43:51 <ski> then we simply follow the "instructions" in this `IO b' action (and its result will be the result of the overall combined action)
06:45:13 <ski> (in any case, there's rarely a value of type `a' "hiding inside" a value of type `IO a'. generally the result is constructed as a result of the OS interaction. hence, there is no function of type `IO a -> a', since an `IO a' is not a "container containing an `a'")
06:46:05 <nshepperd> >>= combines a monad tutorial of type 'Tutorial a' and a function of type 'a -> Tutorial b' to produce a new monad tutorial, which first executes the first one, then, upon failing to understanding it executes the second one
06:46:37 <maerwald> a sequence of information is not a tutorial :)
06:46:47 <ski> conceptually, you could think of an `IO a' very roughly as a string, representing a program in an imperative programming language, and `(>>=)' is then roughly concatenation of such program strings
06:46:56 <ski> or, instead of strings, you can think of ASTs
06:47:22 <ski> and the RTS would then be thought of as interpreting/executing these imperative programs, constructed at run-time by the Haskell program
06:47:58 <mlehmk> (>>=) makes "statements" go from left to right in reading direction, just like do notation makes it from top to bottom
06:48:13 <dolio> It's pretty difficult to think of it as a string.
06:48:14 <ski> so, conceptually the Haskell program computes (evaluates to) an imperative program, which is then executed. in actuality, these two processes, evaluation vs. execution, are interleaved
06:48:28 <ski> dolio : hence "very roughly" :)
06:48:34 <ski> @quote stark
06:48:34 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
06:48:43 <maerwald> and a sequence of information is not an interaction ;)
06:50:52 <ski> (fwiw, using `fmap' to combine a function of type `a -> b' with an action of type `IO a', into an action of type `IO b', amounts to appending a post-processing step (the function) on the given action. that function will only be used when the resulting action is executed. generally, execution can cause evaluation, but evaluation on its own never causes execution (let's ignore you-know-what))
06:51:41 <ski> davr0s : .. i'm not sure whether this has made the picture any clearer for you, or perhaps more muddled ?
06:53:22 <davr0s> well.   i was reading >>= as sometihng that would compose actions that 'you will squirt a value through when demanded' ... thene being unsure (due to the type signature of IO stuff NOT looking like that). --- although I was always assuming 'IO' *is* still composing actions. 
06:53:41 <davr0s> it's whether or not all the >>= stuff implies 'actions that will work sucessively on a value...'
06:53:59 <ski> `(>>=)' is composing actions (`IO'-actions or otherwise)
06:54:50 <maerwald> I thought >=> is composing actions
06:55:13 <ski> heh, there's several variant notions of "composing" :)
06:55:36 <ski>   (>>) :: IO a -> IO b -> IO b  -- perhaps it's easier to see the composition (sequencing) of actions in this type signature
06:56:30 <davr0s> >>= invlves passing a value through them as well?('actions that produce values, to feed into the next one..'
06:56:33 <ski>   (>>=) :: IO a -> (a -> IO b) -> IO b  -- the difference in this case is that we don't throw away the result of the first action, but pass it as a parameter to the second, which is thereby allowed to depend on that value, so it can decide which further action to take, depending on result of previous action
06:56:37 <maerwald> saying both (m a) and (a -> m b) are actions is a bit inconsistent
06:56:52 <davr0s> like C# |>  but monadic?
06:57:05 <davr0s> ok
06:57:17 <ski>   (>=>) :: (a -> IO b) -> (b -> IO c) -> (a -> IO c)  -- is also closely relation, except here we also (explicitly) pass an "input value" to the first action
06:57:29 <maerwald> it seems the problem here is not IO, but monadic functions
06:57:35 <davr0s> yes
06:57:44 <maerwald> so. forget about IO
06:57:52 <ski> (er, s/closely relation/closely related/)
06:58:00 <maerwald> look at "Maybe a"
06:58:11 <maerwald> effects are easier to "observe"
06:58:16 <ski> you talked about parsers before, the same idea of execution of actions exists there
06:58:24 <ski> (or `Maybe', if you prefer)
06:58:35 <maerwald> play around with >>=, fmap etc while using Maybe something
06:58:41 * ski isn't familiar with `|>' in C#
06:58:54 <maerwald> start up ghci and do it now!
06:59:34 <ski> (the main difference between `Parser' and `IO' here would be that you don't need the RTS to execute a `Parser'-action, you can just use a function `parse :: Parser a -> Source -> Maybe a')
07:00:41 <ski> (and in the case of a `Maybe'-action, you can directly pattern-match (or use `maybe',`fromMaybe',&c.) to "start execution")
07:00:53 <maerwald> ski: slow down
07:01:06 <davr0s> right i was doing that a bit  (eturn ..)>>=(->Just..) >>= () .. let me find the output
07:01:13 <maerwald> good
07:01:32 <ski> maerwald : *nod*, i was (currently) finished
07:02:14 <davr0s> 'return' lifts?? into the monad to 'start squirting it...'  sorry to keep saying that lol.   my 'actions' were Just(+10)  ectc
07:02:37 <maerwald> show your code
07:03:03 <ski> `return x' is always a "trivial action" that performs no effects at all, when executed, just hands back `x' as result value of the execution
07:03:18 <maerwald> look up the Monad instance for Maybe
07:03:34 <davr0s> (Just 5) >>= (Just.(+10))>>=(Just.(+ 100))
07:03:46 <ski> (in the case of `Maybe', "an effect" means a failing computation (using `Nothing'))
07:04:21 <davr0s> right i get that far,  at any point it could make aa 'Nothing' and stop
07:04:22 <ski> in that case you compose your action from three components, all of which are effect-free
07:05:00 <ski> yes, the effect is to short-circuit the remainder of the `Maybe'-execution and stop, as soon as an intermediate failure (`Nothing') is reached
07:05:25 <ski> ("effect" in both senses of the word, both the technical and the non-technical)
07:05:53 <ski> it might be more interesting to have example code which can sometimes fail
07:07:43 <maerwald> davr0s: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-836
07:08:26 <davr0s> maerwald thanks again  - yes i'd also got as far as reasing this stuff, but you've pointed me a bit earlier (i was reading IO instances)
07:09:35 <davr0s> i think i get how and why >>= works with maybe.    
07:09:49 <ski> one possible example would be to have a tree with integer weights in the leaves. one could consider building such things with branches out of thread, and hang them as decoration on your porch. these were called mobiles, and the main question is whether a mobile is balanced (all subtrees also needs to be balanced)
07:10:20 <maerwald> ski: what??
07:10:38 <ski> (if you want, you could add horizontal distances from the joining point to where subtrees extend)
07:11:13 <ski> maerwald : a simple, concrete (although not very "useful") example of where the `Maybe'-monad can be used
07:11:39 <maerwald> davr0s: now close the page and write Maybe instance yourself
07:11:45 <maerwald> without looking at it (including applicative)
07:11:51 <maerwald> which is probably the most difficult one
07:12:05 * nshepperd hangs a monad out to dry
07:12:14 <ski> the main task would be to define an operation `weight :: Mobile -> Maybe Integer' that fails if the mobile is not balanced, otherwise gives its weight
07:12:31 * Ariakenom binds nshepperd 's monad to the line
07:14:40 <maerwald> davr0s: after that, you can try writing a parser with monad etc. instances following lecture and exercise 10 from https://www.cis.upenn.edu/~cis194/spring13/lectures.html
07:14:51 <maerwald> which is a bit more involved
07:14:57 <davr0s> i dont want a solution now,    i'm trying to tread the path... i'm was trying to implment this  https://pastebin.com/G6jKwqx4
07:15:12 <davr0s> basically what i have is a working parser,   
07:15:56 <davr0s> i've got a little DIY combinator in one part, but another load of stuff that i'm trying to refactor to look like combinator-able things,   and refactor again to use the 'official' monads where possible.
07:16:32 <davr0s> there's a bunch of code that does things like       Accumulator->Source->   (Accumulator,Source)
07:16:57 <hexagoxel> with groundhog, is there a high-level way of writing joins?
07:16:57 <davr0s> the parts where i used a combinator it returned a Maybe ...
07:17:28 <davr0s> the rest of the parts I was matching on stuff to check what to do - I can see if it was all returning "maybes" then i could refactor it all to the combinator approach
07:18:06 <davr0s> (instead of "if the next char is this,   update the accum this way.. else if ..."  >>>     try_parse1 `orElse` tryParse2 ..   
07:18:52 * ski . o O ( <http://web.archive.org/web/20010424181426im_/http://www.cs.chalmers.se:80/Cs/Research/Functional/Pictures/logo.gif> )
07:19:37 <ski> davr0s : the pattern `Just (final,input_rest2)' needs to be fixed
07:20:42 <maerwald> yes, the type error tells you what is wrong :P
07:21:03 <dmwit> Shameful. Data.Time.Format.ISO8601 doesn't support the Y10K format yet.
07:21:14 <ski> (the error message doesn't seem to apply to the given code in the paste, btw)
07:22:03 <davr0s> What I can also say is that yesterday *did* feel like a bit of a breakthrough i.e. i did use enough that I could go ahead and 'solve my problems' with the amount of haskell i can use now, without it being too uncomfortable, but I was DIY-ing stuff that I know is done better in the libraries. It's just unless I can DIY a certain level, I wont understand the libraries (IMO)
07:22:23 <maerwald> davr0s: check the type of "action" and "action val"
07:22:27 * ski nods to davr0s
07:23:21 <maerwald> add more type annotations to your code (you know how to do inline type signatures right?)
07:23:40 <davr0s> what went much better yesterday was use of I.. (parsing some stuff) and O (generating stuff.. spitting it out formated, writing files).  Fundementally thats enough for me to really 'use' it.  And I have done interactive GL stuff in past "forays into haskell"
07:23:42 <ski> @quote how.they.roll
07:23:42 <lambdabot> sproingie says: i'd rather reinvent wheels when i have to learn how they roll anyway
07:23:44 <ski> @quote reinventing.things
07:23:44 <lambdabot> clsmith says: i find programming in haskell is mostly about reinventing things and then discovering them in Prelude
07:25:34 <ski> @quote reinvent.monads
07:25:34 <lambdabot> Pseudonym says: Those who reinvent monads are doomed to understand them.
07:27:44 <ski> from one POV, monads are "just" a reappearing boiler-plate pattern (or rather a family of analogous such patterns), which `(>>=)' and `return' help abstract away and hide
07:28:11 --- mode: glguy set +v bodisiw
07:28:20 --- mode: glguy set -v bodisiw
07:28:31 <bodisiw> if i'm using stack and find myself in need of a transitive dependency, what's the right way to go about it and make sure i get the right version?  e.g., i was using OpenGL and found myself in need of Data.StateVar.get
07:28:52 <ski> from this POV, `(>>=)' for `Maybe' just helps avoid repeatedly nested `case'-`of's on `Maybe', where all `Nothing' branches map to `Nothing' (short-circuiting)
07:29:46 <ski> and `(>>=)' for `State s' just helps avoid manually threading a state (a sequence of state values) through a computation (easily using the wrong state at the wrong time, if done manually)
07:30:19 <cocreature> bodisiw: add the StateVar package to the build-depends section in your cabal file
07:30:19 <dmwit> bodisiw: Just add `StateVar` to your dependency list.
07:31:30 <bodisiw> and stack is smart enough to resolve version constraints from the OpenGL package?  so would i want to add my own version constraints in package.yml, or just let solver handle it?
07:31:31 <dmwit> You can put version bounds on it as usual if you want. The Cabal library (used by both stack and cabal-install) will make sure that the version choses matches both your constraints and whatever constraints OpenGL set.
07:31:44 <dmwit> s/choses/chosen/
07:32:35 <bodisiw> alright, makes sense, thanks! just trying to figure out the best practice 
07:33:07 <cocreature> bodisiw: stack will definitely ensure that the version of OpenGL that you are using is linked against the same version of StateVar that you get via your build-depends
07:33:30 <cocreature> oh I should have taken a closer look. I just repeated what dmwit already said, sry :)
07:33:31 <dmwit> People are divided on "best practice" in regards to version constraints. Personally I think you should it include them.
07:34:35 <bodisiw> dmwit, i think i agree with that, but there doesn't seem to be any shortcut for automatically adding them
07:34:37 <dmwit> Advantages of including them: if the configuration of your package succeeds, it's much more likely to build and work right. Advantages of not including them: configuration is more likely to succeed in the future.
07:34:47 <dmwit> bodisiw: No, there isn't. =(
07:35:10 <dmwit> cabal-install has a way to generate a freeze file that you can copy-and-paste from.
07:35:29 <bodisiw> ahh, that's probably what i am looking for
07:36:17 <dmwit> (But beware that the constraints put in the freeze file are *very* restrictive. They identify *a single version*. Usually you want to at least specify a version range that allows bugfix releases.)
07:36:31 <maerwald> lower bounds are not very controversial, only upper bounds (because most of the time, they are wrong)
07:36:45 <maerwald> yeah, freeze files are useful if you distribute an app 
07:36:52 <maerwald> not for libraries
07:37:38 <dmwit> e.g. freeze-file will say foo-0.1.2.3.4, but sane default range would probably be either foo>=0.1 && <0.2 or foo>=0.1.2 && <0.1.3, depending on how exactly you import things from foo.
07:37:47 <dmwit> ...and how paranoid you are ;-)
07:38:09 <maerwald> well, those are upper bounds, which are likely not correct
07:38:37 <dmwit> "correct" is just one of many possible positive properties for a version constraint.
07:38:48 <dmwit> As I think I highlighted above.
07:38:53 <bodisiw> maerwald, for reproducability (including bugs) they are correct :-)
07:39:03 <maerwald> bodisiw: no, for that you use freeze files or stackage
07:39:07 <maerwald> not upper bounds
07:39:08 <bodisiw> oh
07:39:13 <maerwald> or nix
07:39:16 <bodisiw> touche
07:39:35 <maerwald> version constraints are there to express what a package builds against, not to give reproducibility
07:39:53 <bodisiw> i have only ever put a major version for the upper bound
07:40:25 <maerwald> drop all upper bounds and keep your app up to date (if you can't and know a build failure, set an upper bounds)
07:40:36 <maerwald> add a freeze file for your users so they can build without build failures
07:41:37 <dmwit> Perhaps we should crystallize this argument once and for all on the wiki somewhere, so that we can point people to a single reference with the full discussion as necessary.
07:41:49 <dmwit> I don't suppose anybody has done this yet...?
07:42:05 <dmwit> It has been years with no new point from either side arising.
07:45:34 * nshepperd . o O (which is more 'correct': upperBound = ∞, which is more than the true upper bound, or upperBound = x, which is less than the true upper bound?)
07:46:14 <maerwald> It would be very short: people have been abusing upper bounds for so long that no one can distinguish "doesn't build with >=x.y" from "I don't know if it builds with >=x.y". And no one even knows why we need the former case (because we don't)
07:46:38 <maerwald> err, the latter case
07:47:38 <tdammers> the problem is that you can't be sure whether it's going to build with a version that doesn't exist yet
07:47:44 <davr0s> oh here's a question .  I see "class Alternative  .. <|>" and "Text.ParsreCombinators.Parsec ... <|>".   it doesn't like me importing both.   are they mutually excusive.  (i.e. namespace clash pretty much... "Parsec reuses the symbol in a better way..")
07:47:51 <maerwald> tdammers: that's not a problem, that's development
07:48:02 <tdammers> it is a problem
07:48:09 <maerwald> if you want "buildability" there are already solutions
07:48:30 <tdammers> you wrote code. it works now. but if a new version of some package gets released, it might cease to work. that's bad.
07:48:37 <cocreature> davr0s: you might want to use megaparsec instead of parsec which among other things just uses the standard operators from existing typeclasses instead of defining conflicting operators
07:48:38 <maerwald> and one solution is fixing the understanding of what backwards compatibility is in the ecosystem
07:48:45 <maerwald> because there is none
07:48:46 <nshepperd> anything that makes 'cabal install foo' fail to work is a problem
07:48:57 <tdammers> and "just keep changing your code whenever that happens for all eternity" is not a good solution
07:49:08 <maerwald> tdammers: yes, backwards compatibility
07:49:30 <maerwald> and if you want buildability, you can use stackage and freeze files
07:49:32 <lyxia> davr0s: use Text.Parsec
07:50:02 <tdammers> but freezing means you're missing out on bugfixes
07:50:05 <lyxia> davr0s: and if you have both, keep Alternative's (<|>) since it's more general
07:50:09 <maerwald> tdammers: upper bounds too
07:50:23 <tdammers> some bugfixes, yes
07:50:26 <maerwald> yes
07:50:28 <tdammers> but not all
07:50:36 <maerwald> not an interesting argument there
07:50:41 <maerwald> you can update freeze files
07:51:14 <tdammers> the argument only really makes sense in a scenario where you expect to release a package and then not have to touch it ever again
07:51:22 <maerwald> upper bounds break the semantics of build dependencies and slow down ecosystem movement, adaption of new GHC versions and try to solve an unrelated problem that is not to be fixed by upper bounds
07:51:42 <maerwald> we should fix the understanding of backwards compatibility
07:52:30 <tdammers> I don't think that understanding needs fixing
07:52:37 <maerwald> I strongly disagree
07:52:49 <maerwald> there is no backwards compatibility
07:53:01 <maerwald> people just say PVP or semver and remove API and let you deal with the mess
07:53:08 <maerwald> no deprecation phase, nothing
07:53:37 <maerwald> and then wonder why our tooling is so complicated :)
07:53:49 <tdammers> so the argument isn't really about whether the mechanisms we have are correct or not; it's about whether people are using them responsibly
07:54:16 <maerwald> yes, upper bounds are misused and no one cares about backwards compatibility (which is why upper bounds are misused)
07:54:29 <tdammers> PVP pretty much nails compatibility (a few weak spots nonwithstanding), but it turns out that actually applying it correctly is too damn difficult for humans, and Haskell is too damn flexible to automate it
07:54:34 <maerwald> because no one trusts library maintainers to not break backwards compat
07:54:52 * hexagoxel . o O (there is no truth when it comes to definitions. whether "upper bounds" are misused purely depends on the definition of the term)
07:55:21 <dolio> I don't think it's really that difficult.
07:55:29 <maerwald> hexagoxel: they have two different semantics. And one of them is not needed.
07:55:32 <dolio> Unless you're one of the few people with like 90 packages.
07:55:50 <tdammers> from a user perspective, it's easy. either import everything qualified / specific, and depend on A.B.*, or import unqualified and depend on A.B.C.*
07:56:01 <phadej> maerwald: omitting upper bounds "only" makes hackage trustees busy: http://hackage.haskell.org/packages/recent/revisions.html
07:56:10 <maerwald> dolio: I work on a project with more than that and I removed stack and only had to fix two packages, no upper bounds whatsoever
07:56:24 <maerwald> and now run cabal new-update and cabal new-build 
07:56:26 <phadej> it's sad that list is so short, you'd see alot of my, hvr, george and other names
07:56:31 <phadej> fixing up wrong metadata
07:56:55 <maerwald> it's not that hard
07:57:19 <hexagoxel> maerwald: that's like saying "it never takes more than 1 sec on my machine" to the claim that your algorithm is not O(n).
07:57:22 <maerwald> phadej: revisions are another wart ;)
07:58:15 <c_wraith> maerwald: huh.  I've had a lot of problems caused by optimistic/missing upper bounds.  Nearly a 100% correlation to "written by a stack user".
07:58:21 <phadej> I disagree completely. PVP is a contract which allows maitnainers to break.
07:58:32 <maerwald> anyway, half of the problems I have with haskell ecosystem I never had in Go... not because go tooling is better (it isn't), but people are VERY careful about backwards compatibility
07:58:36 <phadej> there is nothing wrong to use not-latest version of some dependency
07:59:11 <maerwald> c_wraith: yes, stack had a negative effect on the ecosystem
07:59:29 <maerwald> not their fault, but that's what happened
08:00:05 <c_wraith> phadej: related to that, I wish there was a better way of documenting "these major versions are still maintained" on hackage.  It might encourage the maintenance of multiple major versions more often.
08:00:33 <phadej> c_wraith: yes, though I  don't know anyone (maybe Nikita?) who does that
08:00:54 <phadej> i.e. makes minor releases for "past" major versions
08:00:57 <c_wraith> phadej: Maybe if it was visible, more people would do it. :)
08:01:13 <c_wraith> peer pressure!
08:01:31 <maerwald> phadej: PVP is a failed experiment, it increases tooling complexity, slows down updates, makes the ecosystem complicated and people not care about designing their API carefully. You can still use the versioning parts of it, but how to deal with breaking API changes is something else.
08:01:35 <phadej> c_wraith: I consider that too much to ask for non-paid work
08:02:09 <phadej> maerwald: sorry, I don't take non-constructive comments. Propose something better.
08:02:17 <maerwald> phadej: I did
08:02:24 <tdammers> IMO PVP is a great idea, it's just that Haskell isn't suitable for it :x
08:02:27 <phadej> where?
08:02:46 <maerwald> phadej: in the beginning of the discussion already
08:02:51 <maerwald> and I gave examples :)
08:03:56 <EvanR> god created the best versioning system: 0, 1, 2, ...
08:03:56 <phadej> ok, it scrolled from my backlog. Yet "people not caring about API design" and versioning scheme doesn't seem to be related
08:04:38 <phadej> If there wouldn't be a uniform way to communicate breaking changes, then people would  be afraid to introduce  them
08:05:04 <phadej> which would in worst case cause avoiding refactorings, which "have to be made"
08:05:19 <maerwald> phadej: backwards compatibility, deprecation phase, frequent build fixes by maintainers (can be supported by the platform with reverse dep checks), specialized tooling for "must be guaranteed to build" (which we already have), ...
08:06:06 <phadej> maerwald: what you mean by backwards compatibility?
08:06:06 <maerwald> other ecosystems do that
08:06:36 <maerwald> try very hard to not break API... at all... and if you do, rename functions/modules, start a deprecation phase
08:06:47 <maerwald> users will update in time
08:07:03 <maerwald> a few lib maintainers do that, but not enough
08:07:41 <phadej> I repeat myself:  there's nothing wrong to stay at the old version. Also upgrading to newer versions in Haskell is not extremely hard. Many maintainers write changelogs, some even upgrade hints
08:08:01 <maerwald> ofc there is something wrong, the depgraph
08:08:24 <maerwald> and missing out on bugfixes (potentially security bugfixes)
08:08:25 <phadej> renaming modules, avoiding breaking API etc. will only cause very ugly API at the end
08:08:30 <maerwald> no
08:08:33 <maerwald> look at Go ecosystem
08:08:34 <maerwald> works fine
08:09:03 <phadej> Comparing Go to Haskell is no-argument. They don't have `lens`
08:09:18 <maerwald> I'm not comparing programming languages
08:09:23 <phadej> which is somewhat research topic, which we just don't know how to do right
08:09:28 <phadej> so we need to _experiment_
08:09:38 <tdammers> lens, a.k.a. the "install the entire library ecosystem" metapackage :D
08:09:39 <maerwald> lens doesn't break API often
08:09:45 <phadej> maerwald: it does
08:09:51 <maerwald> haven't noticed
08:09:51 <phadej> look at the major bumps
08:09:57 <phadej> it breaks in corners
08:10:05 <maerwald> also, that's a fairly weird argument
08:10:20 <tdammers> it's also a matter of priorities - false positives vs. false negatives
08:10:28 <maerwald> you're presenting one package to justify that the whole ecosystem doesn't need to care about backwards compatibility
08:10:40 <maerwald> or that it cannot
08:10:45 <maerwald> even lens could
08:10:53 <tdammers> "this will definitely work" and "this will definitely break" are the easy cases, but the interesting parts happen in the part between those
08:11:41 <tdammers> that said, backwards compatibility is definitely something people think about quite a bit. it's not like people make breaking changes all the time without giving it any thought whatsoever
08:11:58 <maerwald> tdammers: Cabal (the library) breaks all the time :P
08:12:18 <maerwald> supporting more than 2 versions is an exercise in ifdefs
08:13:00 <phadej> Why you have to support many?
08:13:03 <phadej> (more)
08:13:18 <maerwald> phadej: ghc-mod has to
08:13:39 <phadej> and tht's not a one package to justify...?
08:13:48 <maerwald> ?
08:14:02 <phadej> ghc-mod is a special case
08:14:25 <maerwald> you asked a specific question
08:14:36 <maerwald> I didn't say everyone has to support 2 versions of Cabal
08:14:55 <maerwald> but even if you don't you have to fix your code all the time
08:15:10 <maerwald> which was the point
08:15:23 <maerwald> ofc, Cabal is special
08:15:44 <maerwald> but even that could be done more carefully imo, some breaking API changes are really just function renames
08:17:30 <nshepperd> are you just saying people should have fewer major pvp releases
08:17:52 <nshepperd> that seems to be what 'care about backward compatibility' comes to
08:19:13 <maerwald> nshepperd: in some cases it's also possible to just keep old API around
08:19:45 <maerwald> deprecate the whole module even
08:20:21 <cocreature> additions don’t require a major bump so “keep old API around” still amounts to “have fewer major pvp releases”
08:20:27 <maerwald> and yes, in some ecosystem people would rather create a new package if they break more than half of their API
08:20:53 <phadej> but what's the point, if that old package is not updated
08:21:01 <phadej> what's wrong with dependening on _old_ major release
08:21:02 <maerwald> is it not?
08:21:30 <tdammers> in most cases it's not, no
08:21:38 <maerwald> in haskell ecosystem you mean?
08:21:45 <tdammers> in general
08:21:56 <tdammers> nobody likes to work for free
08:22:11 <tdammers> packages get maintained either because people use them themselves, or because they get paid to maintain them
08:22:16 * dmwit . o O ( We should not have upper bounds. That way when I want to improve my API based on what I learned from using it, I can be forced to completely rename my package and somehow find a way to tell all my users about it. )
08:22:21 <maerwald> gtk+2 still received updates for quite some time
08:22:31 <maerwald> and you can install gtk+2 and gtk+3 in parallel
08:22:36 <maerwald> imagine you couldn't
08:22:40 <maerwald> because of PVP
08:22:54 <tdammers> gtk+2 is one of the few exceptions where there are enough stakeholders willing to put effort towards keeping the old version maintained
08:22:59 <tdammers> most software is not like that
08:23:33 <tdammers> not being able to install multiple versions of the same thing into the same package DB is a problem, but it's an orthogonal one
08:23:36 <maerwald> dmwit: ghc shows deprecation warnings
08:23:55 <tdammers> and the solution we currently have is to just use separate package DB's for separate projects vOv
08:24:33 <dmwit> I am responding to, "in some ecosystems people would rather create a new package if they break more than half of their API". To me this sounds dumb, and exactly the kind of thing versioning is intended to be for. Bump the version appropriately and be on your way.
08:24:51 <maerwald> dmwit: not if you want it to be installable in parallel
08:25:04 <maerwald> that's what I was referring to with that example
08:25:13 <dmwit> I have multiple versions of many packages installed.
08:25:23 <dmwit> Hell, for some packages I probably have multiple copies of the same version.
08:25:48 <maerwald> in one project?
08:25:52 <dmwit> (Or: I look forward to your example of an application that uses both gtk+2 and gtk+3 in a single run of its executable.)
08:26:19 <maerwald> dmwit: for something like servant/scotty that might actually be very likely
08:26:31 <maerwald> but that wasn't my point at all
08:26:34 <maerwald> those are edge cases
08:26:35 <nshepperd> (if you want it to be installable in parallel *in the same program* you'll need to also rename all the modules)
08:26:46 <maerwald> nshepperd: of course
08:27:43 <hexagoxel> that's why your top-level module identifier should be just the package name!
08:27:49 * hexagoxel starts the next discussion and runs away
08:27:55 <nshepperd> hehe
08:28:04 <nshepperd> (in which case it really is an entirely different library)
08:28:19 <maerwald> anyway, I don't see a problem with putting more effort into backwards compatibility... except that it's, well... effort
08:28:38 <dmwit> I agree, you should put more effort into backwards compatibility.
08:28:55 <nshepperd> so anyway, if you're still saying "let's have less major pvp releases", i'm all for that
08:29:02 <zzz> hi. i'm having trouble understanding example I found, because the syntax is unfamiliar to me (what is the -> doing here?): `type Predicate a = a -> Bool`
08:29:04 <maerwald> nshepperd: partly yeah
08:29:11 <nshepperd> i'm lucky, my libraries don't have any users
08:29:25 <nshepperd> so I don't have to put effort into backward compatibility
08:29:26 <dmwit> zzz: It's the normal old "function type" arrow.
08:29:31 <dmwit> zzz: Same as here:
08:29:39 <dmwit> > let f :: Int -> Int; f x = x + 1 in f 3
08:29:41 <lambdabot>  4
08:29:48 <maerwald> nshepperd: another thing I noticed is that some people change the *behavior* of functions and say "oh well PVP". But imo, you should **never** do that, ever. No matter the versioning scheme.
08:29:59 <dmwit> % type Predicate a = a -> Bool
08:29:59 <yahb> dmwit: 
08:30:19 <hexagoxel> can me move the whole pvp/bounds/versioning discussion to -overflow, pls?
08:30:23 <dmwit> % let f :: Int -> Bool; f x = x == 0; g :: Predicate Int; g x = x == 0 in (f 3, g 3)
08:30:23 <yahb> dmwit: (False,False)
08:30:31 <dmwit> zzz: ^
08:30:38 <roconnor> Hi, is Applicative part of the modern Prelude?
08:30:44 <maerwald> I wanted to write clojurescript code but you guys sidetracked me!
08:31:00 <maerwald> (or I tried to procrastinate)
08:31:10 <dmwit> roconnor: yep http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Applicative
08:31:52 <roconnor> dmwit: do you happend to know when that appeared?
08:32:01 <roconnor> oh it probably says
08:32:07 <phadej> base-4.8
08:32:18 <roconnor> phadej: thanks
08:33:11 <dmwit> roconnor: https://github.com/quchen/articles/blob/master/applicative_monad.md has a complete timeline at the end
08:34:31 <Taneb> Got a minimal case for a failure in either cabal or haddock
08:34:47 <Taneb> https://gist.github.com/Taneb/cafb8a4433298a24a100708a8529495a
08:35:21 <Taneb> Running "cabal haddock" with these gets a frustrating and confusing linker error
08:36:11 <Taneb> Where should I report this?
08:37:47 <phadej> Taneb: can you try with cabal-install-2.4? (and if it happens still report to haskell/cabal github)
08:38:39 <unclechu> hi there, about haddock syntax, how to use line-breaks in bulleted lists? if i just separate paragraphs by empty (commented) lines - next paragraph rendered just as out of list, indentation doesn't help here
08:39:04 <Boomerang> It still happens with `cabal-install-2.4` and `cabal new-haddock`
08:39:13 <MarcelineVQ> Taneb: what is the error?
08:40:29 <Taneb> MarcelineVQ: I've added it as a comment to the gist
08:48:37 <Taneb> phadej: I've reported the issue
08:51:16 <phadej> Taneb: thanks
09:11:06 <maerwald> hmm, we have no ghc-up system, right?
09:11:12 <maerwald> (compare to rust-up)
09:12:05 <phadej> we have haskell platform
09:12:24 <maerwald> I mean a script
09:12:30 <maerwald> not a platform, not stack
09:13:33 <phadej> add-apt-repository ppa:hvr/ghc && apt-get update && apt-get install ghc-8.6.1 cabal-install-2.4
09:13:46 <maerwald> that's not distro agnostic
09:13:51 <phadej> why should it be?
09:14:03 <maerwald> because there is more than debian
09:15:48 <[exa]> why would you need a script for installing software using the userfriendly package manager?
09:16:16 <maerwald> yeah, doesn't make any sense
09:16:31 <maerwald> which is why ghcup would behave like rustup, totally distro agnostic
09:16:46 <maerwald> basically doing the stack part of "download and manage toolchain", but only that
09:16:53 <phadej> again, we have haskell platform
09:17:05 <phadej> it's not a script, but not much worse
09:17:05 <maerwald> that's not managing multiple GHCs
09:17:10 <phadej> it does
09:17:13 <maerwald> check rustup to know what I mean
09:17:17 <phadej> you install older platforms
09:17:35 <phadej> but by all means, you can make one, and maintain it
09:17:45 <maerwald> I know
09:17:51 <maerwald> which is why I asked the question
09:17:58 <phadej> (I do for osx, so I can say it!)
09:18:11 <phadej> which remind me that I should add ghc-8.6 there
09:21:49 <Athas> lens seems like it has broken compatibility (judging by the version number) dozens of times.
09:22:22 <Athas> I'm curious what those changes have been.  More generally, has anyone done studies on why/how Haskell packages break compatibility?
09:23:01 <Athas> Is it because of significant API improvements, due to upstream changes in dependencies, or things that are related to Haskell's design in the first place (like typeclass instance fiddling)?
09:24:15 <geekosaur> Athas, quite a lot of the story is in https://wiki.haskell.org/Shared_libraries_and_GHC
09:24:50 <Athas> geekosaur: I don't follow.  What does that have to do with API stability?
09:25:08 <Athas> The inlining stuff is about *ABI* stability, which I don't expect anywhere.
09:25:11 <geekosaur> tl;dr: cross-module inlining is necessary for any performance, but forces binary level compatibility
09:25:39 <geekosaur> that's exactly the point. once it's in the ,.hi file for inlining, API stability si ABI stability
09:25:54 <geekosaur> and API includes what nstances are avalable, etc.
09:26:53 <Athas> I still don't follow.  You only need to bump the version number when *removing* instances.
09:27:21 <Athas> Are you saying 'lens' would have had fewer compatibility breaks if GHC did not use inlining, but paid the indirection cost at runtime?
09:27:26 <geekosaur> yes
09:27:36 <geekosaur> and those indirection costs would be severe]
09:27:51 <cocreature> I feel like you are talking about different notions of compatibility
09:27:54 <geekosaur> (this has been tried. ghc works the way it does for a reason)
09:27:57 <Athas> Yeah, I'm confused.
09:28:17 <Athas> The lens version bumps follow the rules outlined by the PVP (I suppose), and the PVP does not mention GHC at all.  It goes solely by the source language semantics.
09:28:34 <cocreature> Athas is talking about compatibility in the sense of “if I recompile against the new version of lens, does my code compile and work as before”
09:28:50 <cocreature> that doesn’t seem like something affected by cross module inlining
09:28:53 <Athas> I'm only concerned with the reason why Haskell packages bump the first two parts of the version number so frequently.
09:28:55 <geekosaur> PVP does in fact have knowledge ofhow ghc does things baked into it, just nto by name
09:30:07 <Athas> I still don't understand.  Can you explain which nodes in https://pvp.haskell.org/#decision-tree would be different if GHC did not use inlining?
09:30:41 <c50a326> import Data.List (\\) -- howcome this parse errors?
09:31:00 <Athas> c50a326: import Data.List ((\\))
09:31:05 <c50a326> ah
09:32:17 <nshepperd> cross module inlining means that even pvp minor version bumps can be ABI incompatible
09:32:42 <nshepperd> which seems irrelevant to talking about pvp major version changes
09:32:47 <Athas> Yes, but ABI compatibility is not a big deal, I think.  Lots of languages have no ABI compatibility.
09:33:26 <geekosaur> you are still wrong there
09:33:41 <geekosaur> the ABI is part of the API as soon as something lands in the .hi file for inlining
09:33:54 <nshepperd> what?
09:33:57 <geekosaur> all the guts are exposed where you don't expect them to be
09:34:09 <Athas> But you can always just delete all *.hi files before compiling.
09:34:25 <Athas> It's not about stability at all, just (re)compilation performance.  The PVP doesn't care about that in any way I can see.
09:34:29 <geekosaur> including for the precompiled packages? (which will break them)
09:34:42 <nshepperd> we're not talking about precompiled packages
09:34:47 <geekosaur> nobody ever understand this, soe veryone alwasy complains
09:34:56 <Athas> Who care about those?  The PVP doesn't, and Hackage does not support it at all AFAIK.
09:36:37 <geekosaur> wtf is base but aprecompiled package
09:36:42 <nshepperd> are you suggesting that lens has bumped the major version number in order to prevent precompiled packages from breaking?
09:36:51 <nshepperd> that sounds like a very silly idea
09:36:58 <geekosaur> every packages precompiled, not custom built againand aaine very time youbuild yurprogram 
09:37:13 <geekosaur> really, never mind. Ishould not hae replied.
09:37:50 <geekosaur> youall knw hw it must absolutely work, won;t look at the deails because you know yualread know them
09:38:10 <Athas> Anyway, Haskell/Hackage is the most unstable package ecosystem I've used (in terms of API stability, not code quality where it is probably best).  I'm curious why that is.
09:38:43 <Athas> It may just be community preference for aggressive refactoring (which may the reason for the high code quality), but it might also be due to some language quirks.  That would be useful information.
09:39:38 <nshepperd> geekosaur: which part of https://pvp.haskell.org/#decision-tree mentions *unexported* constructors of data types due to cross-module inlining?
09:39:50 <Athas> For example, I note that orphan instances (whether added or removed) always require a major version bump.  A new dependency adding one does too.  Does that matter a lot in practice?
09:40:19 <geekosaur> insofar as tis spooky action at a distance, yes
09:40:20 <dminuoso> Athas: It's to be a contrapoint for Golang - they'd probably refuse changing an API regardless of how bad and broken it was..
09:40:51 <Athas> dminuoso: maybe, but Go's type system is also so weak that you can do a lot of changes without changing the types.
09:41:05 <geekosaur> bt I dont get to fd=go into detail, nshepperd wants e to go cross-reference the PVP against ghc for him, this willt ake a while even though he knows it's trivial
09:41:24 <c50a326> https://i.imgur.com/LGqO7LU.png is it that 1,4,5,6 are true; 2,3 are false?
09:41:42 <nshepperd> geekosaur: what you're saying just doesn't make sense
09:41:52 <geekosaur> whatevrf
09:41:54 <geekosaur> OI did say Isouldnot have responded
09:42:05 <geekosaur> go look at hat's really going o
09:42:06 <nshepperd> geekosaur: are you saying you have to bump the pvp major version whenever you break ABI compatibility?
09:42:21 <nshepperd> geekosaur: because that makes the pvp decision tree pointless
09:42:37 <nshepperd> you would just bump the major version any time you change any data type whatever
09:42:47 <geekosaur> athan, to e specific: this is the same problem as why ghc may nto assume that it knows what instances are in scope at compile time. an orphan insance chanegs it for code that knows about nothing but the class
09:43:17 <geekosaur> nshepperd, it's more complex tan that, althoguh that woudl "slve" a bunch of problems(but meas whle program compilation, in practice)
09:43:46 <geekosaur> pvp is based around what changes are known to cause what oproblms. andhas been patched a feew tmes when new ones were found, wic si where te "oops, secretly depends on ghc" tends to slip in
09:43:48 <c50a326> geekosaur: are you drunk or on a mobile? :o
09:43:51 <nshepperd> problems that can be solved by just not using dynamic linking
09:44:00 <geekosaur> I am using a keyboard that wants me to type at abut half the speed I am
09:44:08 <c50a326> ah lol fair enough :p
09:44:38 <geekosaur> nshepperd, ad indeed that is why ghc defaults to static. andthen you get arch
09:44:49 <geekosaur> which switched to all-dynamic
09:45:13 <nshepperd> geekosaur: how is it more complex? any change to a data type means that some inlined function might by completely wrong for the new constructors, means that the ABI is incompatible
09:45:57 <nshepperd> unless you go to the effort of NOINLINING every function that works with your unexported data type
09:46:46 <geekosaur> nshepperd, by more comlex I mean that the pvp goes to some effort to figure out exactly what ABI level changes cause what API level probles, instead of just saying "its broke"
09:46:46 <geekosaur> nshepperd, by more comlex I mean that the pvp goes to some effort to figure out exactly what ABI level changes cause what API level probles, instead of just saying "its broke"
09:46:47 <geekosaur> oops
09:46:53 <nshepperd> this definitely isn't how the pvp works according to that doc
09:47:24 <Athas> Every potential breakage pointed out by the PVP would also break in a non-inlining compiler.
09:47:32 <Athas> Hell, it breaks in Hugs, which is just an interpreter.
09:50:29 <nshepperd> I don't think I have ever reused a compiled package while recompiling one of its dependencies
09:50:40 <nshepperd> which is when ABI compatibility would matter
09:51:14 <nshepperd> i don't think that's even allowed now. with cabal
09:52:24 <nshepperd> *recompiling a new version of a dependency
10:06:21 <dminuoso> This is so bizarre. So Im used to writing Rails apps with full blown ORM AR magic - and I just rolled SQL from hand with just postgresql-simple, and it feels so much cleaner.
10:06:28 <dminuoso> Suddenly I can look at my code and say with confidence what it does.
10:06:46 * dminuoso tosses persistent aside
10:14:37 <[exa]> dminuoso: persistent is for people who can't normal form
10:14:59 <Athas> dminuoso: magic is about misdirection and confusion.  This also applies to programming.
10:19:21 <c50a326> https://ptpb.pw/9710/hs is there a nice enough way to write this as a single list comprehension, or is this about as pretty as it's gonna get?
10:20:41 <cocreature> c50a326: you probably want to use "partition" to avoid filtering the list twice
10:20:52 <cocreature> tbh I wouldn’t use a list comprehension here at all
10:21:28 <c50a326> ah it's and exercise in "Introduction to Functional Programming", in a chapter which is all about using zips in list comprehensions
10:21:47 <c50a326> s/and/an
10:22:28 <cocreature> > let (evens, odds) = partition even [1,3,5,2,4,6] in concat (transpose [even, odds])
10:22:30 <lambdabot>  error:
10:22:30 <lambdabot>      • Couldn't match expected type ‘[a]’
10:22:30 <lambdabot>                    with actual type ‘Integer -> Bool’
10:22:35 --- mode: glguy set +v dasli
10:22:44 --- mode: glguy set -v dasli
10:22:52 <dmwit> s/even,/evens/
10:22:56 <dmwit> ,
10:23:16 <cocreature> > let (evens, odds) = partition even [1,3,5,2,4,6] in concat (transpose [evens, odds])
10:23:18 <lambdabot>  [2,1,4,3,6,5]
10:23:22 <cocreature> there we go :)
10:24:14 <c50a326> oh that's pretty nice
10:24:17 <c50a326> partition and transpose
10:29:04 <c50a326> is "inverse" the same as "dual"?
10:29:22 <c50a326> I mean if a function has an inverse function, is that the same as it being a "dual" or whatever, and the dual function?
10:33:33 <lyxia> I know "inverse function", never heard of "dual function"
10:35:42 <hyperisco> "dual" is portable terminology, as far as I know it. So in the context of functions, "dual" could mean "inverse".
10:36:14 <c50a326> ah I don't know anything about "dual" really... just something I've seen when reading around...
10:37:08 <lyxia> you can make "dual" mean just about anything if you look hard enough.
10:37:13 <dmwit> None of the meanings I know of for "dual" match up with any of the meanings I know of for "inverse".
10:39:53 --- mode: glguy set +v dataN
10:40:09 --- mode: glguy set -v dataN
10:40:53 <dataN> why wont Constraint match under this definition of type equality? https://lpaste.net/8972626086563151872
10:44:33 <Zajcev> hello guyz
10:45:50 <lyxia> dataN: maybe it's a bug
10:46:52 <Zajcev> I have silly question, I'm new in haskell and yesod, I'm stucked ... I have build hello world yesod with stack on desktop, it's working with stack devel, but how to get it to my web server? some tutorial for noobs? :-)
10:47:21 <dataN> yes there are tutorials for noobs online 
10:47:27 <[exa]> kindof depends on what kind of web server do you have
10:47:58 <Zajcev> I'd like to use warp + nginx + reverse proxy
10:50:03 <Zajcev> dataN: do you have link or what to google? :-)
10:50:22 --- mode: glguy set +v MichielDC
10:51:34 <dataN> have you tried searching?
10:52:10 <MichielDC> Can someone explain me (<$)? If I do 'True <$ f', f will get evaluated right?
10:53:36 <dataN> lyxia: this works, but its strange that _ wouldnt match Constraint https://lpaste.net/8748673048502075392
10:53:43 <Zajcev> dataN: of course
10:54:07 <phadej> MichielDC: x <$ f = (\ _ -> x) <$> f
10:54:37 <dataN> did you manage to find a suitable Yesod tutorial?
10:55:13 <Zajcev> yesod book
10:55:14 <lyxia> dataN: that's troubling
10:55:33 <Zajcev> and other, but what I miss is what should be installed on server
10:58:34 <dmwit> MichielDC: Hm, hard to say anything less tautological than "`f` will only get evaluated to the extent needed to calculate `True <$ f`.".
10:58:54 <dmwit> > let f = [error "this exception is never thrown] in True <$ f -- for example
10:58:56 <lambdabot>  <hint>:1:76: error:
10:58:56 <lambdabot>      lexical error in string/character literal at end of input
10:59:03 <dmwit> > let f = [error "this exception is never thrown"] in True <$ f -- for example
10:59:05 <lambdabot>  [True]
11:00:16 <dmwit> > let f = error "not thrown a":error "not thrown b" in head (True <$ f) -- perhaps even more surprising example: we haven't even figured out the "shape" of `f` by the type the calculation is done
11:00:18 <lambdabot>  True
11:19:06 --- mode: glguy set +v cygnus
11:21:52 --- mode: glguy set +v jtdaugherty
12:08:35 --- mode: glguy set +v dataN
12:08:43 --- mode: glguy set -v dataN
12:09:14 <dataN> what does it (the 'f' ) mean to write (xs :: f a)
12:09:57 <monochrom> A type variable that has kind * -> *
12:10:06 <dataN> like a type family?
12:10:24 <monochrom> Insufficient information for a meaningful answer.
12:10:30 <dataN> or is that ~>
12:10:47 <monochrom> If you're asking whether I had typo in my answer, no.
12:11:06 <monochrom> OK apart from spacing. * -> *
12:11:20 <dataN> so its not a type family because its not * ~> *
12:11:30 <monochrom> Insufficient information for a meaningful answer.
12:11:36 <dataN> ok
12:11:46 <monochrom> Or rather, s/meaningful/non-tautological/
12:11:55 <monochrom> Really, "xs :: f a" says almost nothing.
12:11:56 <dataN> can pattern match on -> to give something like fold
12:12:12 <dataN> but * -> * -> * is not f * for any f
12:12:13 <monochrom> I'm pretty sure -> cannot be a pattern.
12:12:44 <dataN> sure can, like this; https://lpaste.net/8748673048502075392
12:13:06 <dataN> f matches -> fine
12:13:19 <monochrom> I can't find "->" in that code.
12:13:21 <dmwit> With sufficient extensions, it may only mean a type variable that has kind `K1 -> K2` for some kinds `K1` and `K2`.
12:13:45 <dataN> :k Monoid
12:13:47 <lambdabot> * -> Constraint
12:14:02 <monochrom> And type families are not pattern matching.
12:14:13 <dataN> ok
12:14:49 <dataN> is there a word for whats being matched on if its not a pattern?
12:15:11 <dmwit> I admit I'm kind of surprised that `Kind (a :: k) = k` is allowed. I wonder if that's really doing what a surface reading says it would do.
12:15:29 <dmwit> Perhaps `Kind (a :: m) = k` would do the same thing, e.g.
12:15:33 <dolio> I don't think variables range over families, so you know it isn't one of those.
12:16:25 <dataN> k would then only be in scope from the type family head, and as this is the same as the kind of 'a' then its ok
12:16:58 <dmwit> Just musing. Not objecting to the code.
12:17:06 <lyxia> Kind does do the right thing, I have no idea why that is a sensible thing to define.
12:18:27 <monochrom> You can say "closed type family" for this one. For the open ones, you can say "instance of type family".
12:19:03 <monochrom> But there is no "->" in that code, therefore nothing is matching against ->.
12:19:41 <monochrom> If I wrote code like "f (x:xs) = whatever", you get to say "aha x:xs is the pattern there". You don't get to say "aha [] is the pattern there".
12:19:52 <dataN> dmwit: it works exactly as expected, even with ScopedTypeVariables 
12:20:51 <monochrom> And if you say "but conceptually..." well that's euphemism for sloppy thinking, along with "intuitively..."
12:20:52 <dmwit> monochrom: `Kind Monoid` has "->", and acts as an argument to a type family.
12:20:57 <dataN> well, the thing being matched is more like a pattern than a type family
12:22:36 <dataN> the -> intersperse the constituent kinds, and could be replaced by ': in the type variable equivilant of Data.Foldable.toList
12:23:04 <dataN> however (* -> * -> ... -> *) is not f * for any *
12:23:09 <dataN> for any f
12:23:51 <dataN> e.g.
12:23:52 <dataN> type family UnsafeGet' (xs :: f a) :: (a,f a)
12:24:26 <dataN> would work still with setting f a = k
12:25:04 <dataN> and then could have an instance defined for (k :: *)
12:25:22 <dataN> which can then be seen to be foldable
12:25:32 <dataN> but there is no foldable f to speak about
12:25:34 <monochrom> dmwit: Could you walk me through it? Because I mean the closest I could get to is the clause "Last (f a b) = b" in which I could understand that f becomes instantiated to -> but the pattern is "f a b" not "a -> b".
12:25:55 <dataN> f = ->
12:26:02 <dataN> f a b = a -> b
12:26:44 <dataN> for a type level Vector, f = ':
12:26:51 <dataN> they are both foldable
12:27:05 <dataN> sorry List, not Vector
12:28:43 <dataN> according to this https://ghc.haskell.org/trac/ghc/ticket/9063
12:29:05 <dataN> kindclasses are classes over Proxy kinds
12:29:35 <dataN> and it would be nice to write Foldable as a kindclass, but this aspect is confusing
12:30:08 <dataN> as is the proxy kinds, because maybe Kind (demotion) is equivalent 
12:30:48 <dataN> (this aspect being how to handle the lack of 'f' to define the class over)
12:32:02 <dmwit> monochrom: The ghci query is `:kind! IsConstraint Monoid`.
12:32:32 <dmwit> monochrom: `IsConstraint Monoid` -> `Last (Kind Monoid) == Constraint` -> Last (* -> Constraint) == Constraint`
12:32:44 <dmwit> monochrom: in this third step we have "->"
12:33:34 <dmwit> (forgot a backtick before the final Last, sorry)
12:41:35 --- mode: glguy set +v dataN_
12:41:42 --- mode: glguy set -v dataN_
12:41:46 <dataN_> here is Fold; https://gist.github.com/dataN-hs/ee768f89f421e659923462e94f34b1d1
12:42:02 <dataN_> (an attempt at least)
12:42:15 <dataN_> any ideas what to do about folding kinds?
12:50:59 --- mode: glguy set +v dataN
13:01:46 <monochrom> Hrm GHC 8.6.1's "deriving via".
13:02:45 <dataN> at term level, Foldable has a default from a defining superclass Get, but at type level, all kinds seem to have Get, as the matching over -> or ': shows above
13:02:46 <monochrom> Hey https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html is still 8.4.3 :)
13:03:47 <monochrom> And "deriving strategies".
13:04:32 <dataN> that means type level traversable should be simple to write (other than the Applicative Constraint) as only specification of the constructor is required
13:04:53 <monochrom> Hey \∩/ "Programs are no longer constrained by the Windows MAX_PATH file path length limit. The file path limit is now approximately 32,767 characters" that's really nice finally!
13:06:01 <dataN> I wonder how to bring the constructor into scope..
13:06:52 <dataN> :k ':
13:06:53 <lambdabot> error: Operator applied to too few arguments: :
13:07:00 <dataN> :k '[Int]
13:07:02 <lambdabot> [*]
13:07:53 <monochrom> Haha 8.6.1 recognizes both "GeneralisedNewtypeDeriving" and "GeneralizedNewtypeDeriving". "British spelling since 8.6.1"
13:11:44 <monochrom> Haha DerivingVia looks pretty nice actually.
13:12:55 --- mode: glguy set +v jrp_
13:13:38 <jrp_> Hi, Is there a more idiomatic way of writing:   product' :: [Either Error Integer] -> Either Error Integer   ;   product' xs = product <$> sequenceA xs  ?
13:14:21 <lyxia> I don't think so.
13:14:25 <vaibhavsagar> jrp_: `traverse product`?
13:14:47 <vaibhavsagar> no, that's not quite right
13:14:53 <phadej> vaibhavsagar: ;)
13:14:59 <monochrom> \∩/ BlockArguments so finally we can write "withFile blahblahblah \h -> hGetLine"
13:15:07 --- mode: glguy set +v test
13:15:27 <test> @djinn id ? a -> a
13:15:28 <lambdabot> Cannot parse command
13:15:46 <phadej> i don't think one can write product' shorter. I wish we had fmapTraverse f g = fmap f . traverse g
13:16:37 <Guest96818> @djinn a -> a
13:16:38 <lambdabot> f a = a
13:17:03 <Guest96818> @djinn Monad m => (a -> b) -> [a] -> m [b]
13:17:03 <lambdabot> Error: Undefined type []
13:17:38 <dataN> this works for retrieving the constructor of a kind; https://lpaste.net/7843603953244700672
13:17:49 <monochrom> djinn knows very little. Try exferenceBot.
13:18:23 <ski> monochrom : yay !
13:18:57 <ski> (how about `do',`let',`case',`if' ?)
13:19:18 <monochrom> "do" is in too.  when (x > 0) do print x
13:19:36 <ski> nice
13:19:56 <monochrom> Or better yet, runST do { ... }  where we really need it.
13:20:26 <ski> yea, and hopefully the `$' hack won't be needed, eventually
13:20:41 <monochrom> Can we take away the first-class status of $ now because we no longer need it? :)
13:21:55 <jrp_> The pointfree version reads product' = (product <$>) . sequenceA  which seems a bit obscure to me
13:22:34 <monochrom> I think "let" is in too. The user guide is actually surprisingly imprecise. It keeps speaking in terms of "etc" and "they include". You can't be sure what is out.
13:23:18 <monochrom> But "They include do, lambda, if case, and let. Some GHC extensions also ... mdo, \case, and proc".
13:23:33 <monochrom> err, s/if case/if, case/
13:25:34 <ski> ok
13:27:25 <dataN> with;
13:27:26 <dataN> type family ConstructorOf (k :: xs) :: x ~> xs ~> xs where  ConstructorOf (f a b) = TyCon2 '(:)
13:27:34 <dataN>  :kind ConstructorOf (* -> * -> *) ConstructorOf (* -> * -> *) :: x ~> (* ~> *)
13:27:51 <dataN> but it should be * instead of x
13:28:18 <dataN> oops, that should be TyCon2 f
13:28:41 * ski . o O ( `prod (| l0,e0 ; n |) = (| e1 ; product (| l1,n |) |) where (| e1,l1 |) = sequenceA (| l0,e0 |)' )
13:29:37 <dataN>  :kind ConstructorOf (* -> * -> * -> *) ConstructorOf (* -> * -> * -> *) :: x ~> (* ~> *)
13:31:08 <dataN> ConstructorOf '[ 'True ] :: x ~> ([Bool] ~> [Bool])
13:31:55 <dataN> ConstructorOf ((* -> *) -> * -> *) :: x ~> (* ~> *)
13:32:47 <monochrom> jrp_: I would either keep it pointful as "product' xs = product <$> sequenceA xs" or if I feel like pointfree I would use "fmap product . sequenceA" and spare myself an unnecessary infixness that doesn't belong.
13:34:18 <jrp_> Thanks!
13:34:20 <ski> (or perhaps `liftA')
13:38:40 <jrp_> And then, if I take another step and use product' in an expression like          maximum <$> traverse product' ys    ?   (It seems clear to me, but  perhaps the combo can be simplified)
13:43:30 <monochrom> @type traverse (fmap product . sequenceA)
13:43:31 <lambdabot> (Traversable t2, Traversable t1, Num b, Applicative f) => t1 (t2 (f b)) -> f (t1 b)
13:44:13 <monochrom> Eh, that doesn't really help.
13:44:33 <monochrom> @type traverse
13:44:34 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:46:02 <monochrom> I don't think I can simplify it.
13:46:38 <jrp_> OK.  Thanks.  I was hoping that I hadn't missed something too obvious!
14:40:08 <WilhelmVonWeiner> Can I define a type restricted to the range 0-31 (i.e. 5 bits)?
14:41:00 <shachaf> There's no particularly nice built-in way to do that.
14:41:31 <EvanR> you can define an abstract data type to represent those values, and control how they can be created and used
14:41:38 <EvanR> using "smart constructors"
14:44:41 <WilhelmVonWeiner> I'll look them up, thanks.
15:06:02 --- mode: glguy set +v navtypeeee
15:06:07 <navtypeeee> hey guys need help on a problem
15:06:14 <navtypeeee> would be great if anyone can help
15:06:17 <navtypeeee> ill post the problem 
15:06:42 <navtypeeee> Digit is a digit in base 10, in other words an Int in [0..9] -} type Digit = Int {- Number is a list of digits representing a positive integer   the list will be in reverse (i.e., form lower order to higher order digit)   the list will not have leading zeroes -} type Number = [Digit]   {- addb takes 3 arguments   1. A positive integer, represented as a list of digits, in reverse        (In other words, it goes from lowest order
15:07:13 <navtypeeee> let me re phrase
15:07:16 <navtypeeee> Digit is a digit in base 10, in other words an Int in [0..9]
15:07:29 <navtypeeee> type Digit = Int {- Number is a list of digits representing a positive integer
15:07:43 <navtypeeee>  the list will be in reverse (i.e., form lower order to higher order digit) 
15:07:49 <navtypeeee>  the list will not have leading zeroes -} 
15:10:17 --- mode: glguy set +v dataN
15:10:28 --- mode: glguy set -v dataN
15:10:33 <dataN> :k class
15:10:35 <lambdabot> error: parse error on input ‘class’
15:11:10 <droplet> Can I write an instance for Functor where the functorial parameter isn't the last? Say for example if I want some fmap over the Left of an Either
15:11:26 <shachaf> Not directly.
15:11:40 <shachaf> You can use another class for functoriality on the second-to-last argument.
15:11:57 <shachaf> Or you can use a newtype wrapper.
15:12:07 <droplet> Alright thanks
15:12:08 <monochrom> What is "functorial parameter"?
15:12:58 <monochrom> The other class is "Bifunctor" or something like that name.
15:13:19 <shachaf> Bifunctor is a good class for this also, for something which is a functor in two arguments.
15:13:33 <droplet> Sure, perhaps Either was a bad example
15:13:46 <droplet> I want to only be functorial in the first argument
15:13:57 <shachaf> You mean in the second-to-last argument.
15:14:17 <shachaf> In general it's pretty annoying that you need to define all these classes to talk about variance in Haskell.
15:15:07 <droplet> Fair, I'm mostly just curious if there's some syntax for instances where it's not just arguments from the right
15:15:29 <shachaf> Nope.
15:16:26 <monochrom> In System F you would use a type-level lambda.
15:16:57 <monochrom> But System F also denies you type inference because type-level lambda does.
15:17:45 <droplet> right, a type-level lambda felt like the right solution but I suspected that's not a thing in haskell
16:43:10 <davr0s> some things give me irrational discomfort.. others the opposite.  I really enjoy the ability to write stuff reversed compared to imperative code...  "function = main expression where <sub-expressions...>"
16:44:16 <davr0s> "function =  <salient guts of the calculation>   where  <deeper nesting and read further for the setup details..>
16:49:22 <zzz> hi. new to haskell. having trouble understanding the kind of (->). can anyone point me to a comprehensive explanation?
16:51:31 <shachaf> You can pretend it's * -> * -> * if you're not using fancy extensions
16:51:46 <shachaf> Are you looking for details about fancy extensions?
16:52:57 <zzz> shachaf: no, i just dont get what `(->) :: TYPE q -> TYPE r -> *` means
16:52:58 <koz_> As an aside, how do you pronounce '* -> *'? I've always read it 'star to star'.
16:53:18 <koz_> (or should it be 'Type to Type' now?)
16:53:45 <zzz> koz_: that would make more sense
16:54:05 <koz_> zzz: 'Type to Type' you mean?
16:54:26 <nshepperd> i think i would pronounce * as star
16:54:47 <zzz> well yes, * is a concrete type
16:55:28 <zzz> but i dont know what the convention i
16:55:38 <koz_> That's what I'm curious about as well.
16:56:29 <nshepperd> zzz: if you're curious about the 'TYPE q / TYPE r' and why that's not *, the search term is 'levity polymorphism'
16:57:05 <hpc> what's the etymology of "levity" in this context?
16:57:08 * ski . o O ( <https://ghc.haskell.org/trac/ghc/wiki/LevityPolymorphism> )
16:57:18 <nshepperd> it's so that you can use (->) with functions that accept unboxed values (which have a different kind than *)
16:57:41 <nshepperd> and.. stuf
16:58:43 <zzz> nshepperd: thanks. that's exactly what I was looking for
16:58:50 <ski> davr0s : ooc, what gives discomfort ?
16:59:10 <nshepperd> i guess it's sort of a pun? levity ~ 'liftedness'
16:59:21 <nshepperd> levity is the antonym of gravity
16:59:55 <ski> @wn levity
16:59:57 <lambdabot> *** "levity" wn "WordNet (r) 3.0 (2006)"
16:59:57 <lambdabot> levity
16:59:57 <lambdabot>     n 1: feeling an inappropriate lack of seriousness [ant:
16:59:57 <lambdabot>          {gravity}, {solemnity}]
16:59:57 <lambdabot>     2: a manner lacking seriousness
17:02:01 <hpc> nshepperd: ah, perhaps
17:02:58 * nshepperd actually googled 'liftedness polymorphism', not remembering the proper term
17:39:47 <zzz> can't I use type constraints on type sysnonyms: `type NumToStr = (Num a) => a -> String` ?
17:40:15 <shachaf> You can use constraints.
17:40:18 <geekosaur> not usefully. more to the point,t hat 'a' can't be used usefuly
17:40:21 <shachaf> The question is where "a" comes from.
17:40:35 <geekosaur> because it only excists nside the type synonym
17:40:47 <geekosaur> it will never unify with any other type
17:40:56 <zzz> oh
17:41:01 <geekosaur> (try making it a parameter)
17:41:08 <zzz> ok
17:41:09 <shachaf> I mean, it could, it depends on what you mean.
17:41:12 <zzz> I think i get it
17:42:41 <zzz> so constraints belong only in function definitions
17:42:58 <shachaf> No, constraints have nothing to do with this.
17:43:09 <shachaf> If you write "type T = a -> String" you'll run into all the same problems.
17:43:15 <geekosaur> ^
17:44:00 <geekosaur> that said, it's usually better to be explicit in function definitions… but you can constrain a type parameter
17:44:48 <geekosaur> someone reading your functgion later may be annoyed that they hve to track down the type alias to see the constraint(s) though
17:45:08 <geekosaur> (remember, that will include you 6 months from now)
17:48:46 <zzz> ok thanks. for now, I'm not interested in what's better but in what's possible, as that's what's useful to me until I have a basic understanding of how the language works
17:50:34 <zzz> the fact that I could use arrows in type synonym definitions just came to my attention and I'm trying to make sense of it
17:51:10 <shachaf> There's no magic in arrows, they're just another type.
17:51:16 <shachaf> Compare: type T = Maybe a
17:54:22 --- mode: glguy set +v dataN
17:54:32 --- mode: glguy set -v dataN
17:54:49 <dataN> @Undefine 
17:54:49 <lambdabot> Undefined.
17:54:56 <dataN> @let type A = * -> Constraint
17:54:56 <lambdabot>  Parse failed: Parse error: *
17:55:02 <dataN> @let type A = (* -> Constraint)
17:55:03 <lambdabot>  Parse failed: Parse error: ->
17:55:20 <ski> that looks like a kind, not a type
17:55:36 <ski> are you looking for kind synonyms ?
17:55:48 <dataN> % type A = * -> Constraint
17:55:48 <yahb> dataN: 
17:55:54 <dataN> ski: yes
17:56:12 <dataN> % :kind (Monoid :: A)
17:56:12 <yahb> dataN: (Monoid :: A) :: * -> Constraint
17:56:23 <dataN> % :kind (Monoid :: ((* -> Constraint) :: *))
17:56:23 <yahb> dataN: (Monoid :: ((* -> Constraint) :: *)) :: * -> Constraint
17:56:31 <dataN> % :kind (Monoid :: (forall k. k :: *))
17:56:32 <yahb> dataN: ; <interactive>:1:2: error:; * Expecting one more argument to `Monoid'; Expected kind `forall k. k', but `Monoid' has kind `* -> Constraint'; * In the type `(Monoid :: (forall k. k :: *))'
17:56:41 <dataN> :-(
17:56:53 <ski> is that using `TypeInType' ?
17:56:57 <dataN> yes
17:57:49 <dataN> another example;
17:57:53 <dataN> % :kind ([] :: ((* -> *) :: *))
17:57:53 <yahb> dataN: ([] :: ((* -> *) :: *)) :: * -> *
17:58:02 <dataN> % :kind ([] :: (forall k. k :: *))
17:58:02 <yahb> dataN: ; <interactive>:1:2: error:; * Expecting one more argument to `[]'; Expected kind `forall k. k', but `[]' has kind `* -> *'; * In the type `([] :: (forall k. k :: *))'
17:58:26 <dataN> whats up with that?
17:59:06 <ski> % :kind (Const () :: forall a. a -> *)
17:59:06 <yahb> ski: ; <interactive>:1:2: error:; * Expected kind `forall a. a -> *', but `Const ()' has kind `k0 -> *'; * In the type `(Const () :: forall a. a -> *)'
17:59:26 <dataN> even worse!
17:59:51 <ski> dataN : in your case, it looks like you're doing something similar to `not :: forall a. a -> Bool', except on the type level
18:00:17 <ski> (well, or even `False :: forall a. a')
18:00:30 <ski> @type False :: forall a. a
18:00:31 <lambdabot> error:
18:00:31 <lambdabot>     • Couldn't match expected type ‘a1’ with actual type ‘Bool’
18:00:31 <lambdabot>       ‘a1’ is a rigid type variable bound by
18:00:37 <dataN> hmm
18:00:56 <ski> going the other way around sounds more reasonable
18:01:05 <ski> but my example failed as well ..
18:01:56 <ski> perhaps there's no (re)generalization of type terms
18:02:16 <dataN> trying to express (* -> * -> .... -> Constraint)
18:02:41 * ski isn't sure when that would be useful
18:02:57 <dataN> as in, right at the top; type A = PolyConstraint
18:03:07 <UNCLE_PROTON> hi friends can you teach me a haskell to learn a recursion?
18:03:12 <UNCLE_PROTON> or should i use OCAML
18:03:19 <ski> "poly constraint" ?
18:03:41 <zzz> yeah. nice learning curve, haskell…
18:03:42 <ski> UNCLE_PROTON : either will teach you recursion, most probably (if you stick through)
18:03:50 <ski> zzz ?
18:03:51 <dataN> and then could write Monoid :: A, or (State :: * -> * -> Constraint) :: A
18:04:28 * ski doesn't follow the latter
18:04:41 <dataN> type PolyConstraint = forall k. ('True ~ IsConstraintKind k) => (k :: *)
18:04:58 <dataN> type family IsConstraintKind (c :: (k :: *)) :: Bool where  IsConstraintKind x = (Last x) == Constraint
18:05:00 <UNCLE_PROTON> SKI do i need to do something special to learn the recursion
18:05:13 <dataN> then there are type families for Last and == which are obvious
18:05:32 <ski> UNCLE_PROTON : follow a textbook, perhaps. do exercises
18:05:38 <UNCLE_PROTON> what about LISP?
18:06:11 <ski> dataN : sure you don't want `exists' (and `*>') ?
18:06:12 <ski> hmm
18:06:20 <dataN> !?!?
18:06:32 <ski> UNCLE_PROTON : you could try Scheme, it's not so bad. SICP is nice
18:06:36 <UNCLE_PROTON> OK
18:06:42 <ski> @where SICP
18:06:42 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
18:06:42 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
18:06:53 <UNCLE_PROTON> do you all talk about projects in haskell or just the language SEMANTICS and compiler nerdy stuffs
18:07:01 <UNCLE_PROTON> like real work for money stuff
18:07:26 <dataN> well technically thats off topic
18:08:12 <ski> dataN : a type having kind `forall k. ('True ~ IsConstraintKind k) => (k :: *)' would mean it has all the kinds `Constraint',`* -> Constraint',`* -> * -> Constraint',`* -> * -> * -> Constraint',&c. at the same time, iiuc. -- which doesn't sound reasonable
18:08:28 <ski> UNCLE_PROTON : both
18:08:33 <UNCLE_PROTON> why for being offtopic big deal? esp if project using the haskell
18:08:37 <dataN> there are some guidelines for what this channel is for somewhere
18:09:00 <UNCLE_PROTON> i just like talk make frens program funt hings
18:09:11 <dataN> projects in haskell are obviously on topic, questions about what the channel is for has been answered
18:09:27 --- mode: ChanServ set +o shachaf
18:09:46 <UNCLE_PROTON> OK
18:09:54 <dataN> not well admittedly! but trying to talk about haskell yes
18:10:19 <UNCLE_PROTON> mane folks just talk about language and compiler stufts like Ca nd argue standards stuff and no real project talk happens
18:10:28 <UNCLE_PROTON> C*
18:10:50 <dataN> entertaining conjecture about haskell being convinced as industrially relevant is pushing it 
18:10:59 --- mode: shachaf set +b *!*weenis@2607:5300:60:41a::*
18:10:59 --- kick: UNCLE_PROTON was kicked by shachaf (UNCLE_PROTON)
18:11:11 <ski> protontorpedo ?
18:11:54 <dataN> C#?
18:12:03 --- mode: shachaf set -o shachaf
18:12:51 <dataN> ski: yes thats exactly what polykinded was supposed to mean
18:12:55 <dataN> no, PolyConstraint
18:13:40 <ski> dataN : so you want a TC that can be applied to as many arguments as the caller wants, giving a `Constraint' result ?
18:13:53 <dataN> why is that not reasonable but (*) (*->*) (*->*->*) etc all being :: * is ok?
18:14:20 <ski> perhaps i was misguessing what you were intending
18:15:07 <ski> in any case, arbitrary-arity stuff tends to be icky
18:15:08 <dataN> class (n ~ ConstraintArity q, k ~ KindN n) => SomeClass n (q :: PolyConstraint) (args :: k) where
18:15:36 <ski> (if you do it with dependent types, then i suppose it can be ok. perhaps you're trying to emulate a use like that, in Haskell&extensions)
18:15:36 <dataN> type family KindN (n :: N) :: (k :: *) 
18:16:08 <dataN> type ConstraintArity x = Length (Init x)
18:16:52 <dataN> oh maybe thats mixing levels error
18:17:27 <dataN> its supposed to get the number of * before the -> Constraint 
18:18:10 <dataN> yes, to make a class that can take any constraint as an argument, regardless of its Arity
18:18:21 <dataN> to make Constraints polymorphic as kinds are
18:18:44 <dataN> but the forall. didnt work
18:19:10 <dataN> % :kind (Monoid :: ((* -> Constraint) :: *))
18:19:10 <yahb> dataN: (Monoid :: ((* -> Constraint) :: *)) :: * -> Constraint
18:19:20 <dataN> % :kind (Monoid :: (forall k. k :: *))
18:19:20 <yahb> dataN: ; <interactive>:1:2: error:; * Expecting one more argument to `Monoid'; Expected kind `forall k. k', but `Monoid' has kind `* -> Constraint'; * In the type `(Monoid :: (forall k. k :: *))'
18:19:57 <dataN> maybe there is another way
18:24:49 <dataN> instead of trying to give the Constraint returning thing a list of arguments, it just leaves them interspersed with -> as this seems to be the same
18:28:05 <dataN> class (n ~ ConstraintArity p, args ~ KindN n) => Typed n (q :: p) args 
18:28:22 <dataN> this gives a more meaningful error
18:29:12 <dataN> Couldn't match kind `Last p0 == Constraint' with 'True       Expected kind: IsConstraintKind p0
18:30:08 <dataN> i guess without a paste its pretty hard to understand actually, one sec
18:40:02 <dataN> here, this compiles https://lpaste.net/7817717639890862080
18:42:50 <dataN> ski: ^
18:45:05 --- mode: ChanServ set +o dmwit
18:46:24 --- mode: dmwit set -o dmwit
18:49:57 <dataN> polyconstraints work too now without the forall. https://lpaste.net/5315854608210329600
18:49:59 <dataN> thanks
18:50:48 <dataN> its just sugar on a kind constraint
19:01:44 <zenspider> halp... what is (->) as an operator and where the hell do I even look it up? hoogle is a strike out. Specifically looking at hutton ch 12 and implementing applicative for it.
19:02:05 <ski> it's the function type constructor
19:02:07 <monochrom> Unfortunately (->) is not an operator.
19:02:19 <zenspider> I thought maybe it meant that type decls were expressions but (::) is a strike out too
19:02:28 <geekosaur> that alsois not an operator
19:02:39 <ski> it's built-in to the language, not defined by `data' nor `newtype'
19:02:39 <zenspider> so just the syntax in (\x -> x) ?
19:03:04 <ski> that's a different sense of `->'. i was talking about `->' occuring in types
19:03:15 <monochrom> An regarding "instance Applicative ((->) e)" this (->) has nothing to do with the "->" in "\x -> x".
19:03:36 <zenspider> ok. so I was a bit more correct in my assumption that it had to do with type decls?
19:03:46 <ski> it has to do with types
19:03:52 <geekosaur> well, \ ... -> ... is specfic syntax, not an operator
19:03:54 <ski> just like `Maybe' has to do with types
19:04:04 <monochrom> You may need to consider the prospect that no one asks "what does comma mean" because a lot of unrelated syntax constructs just use the same comma for no reason.
19:05:14 <ski> if you write `Integer -> Bool', then that's the same as `(->) Integer Bool'. compare with `Either Integer Bool'. both `(->)' and `Either' are type constructors, taking two (type) arguments
19:06:20 <ski> now, `Either e' can be made into an applicative functor. similarly, it so happens that `(->) rho' also can
19:06:41 <monochrom> At any rate, suppose you understand that "Either e a" means "(Either e) a" therefore "instance Applicative (Either e)" is legal, therefore "e -> a" means "((->) e) a" therefore "instance Applicative ((->) e)" is legal.
19:07:58 <monochrom> And when you actually have to write the code for pure and <*>, the worst guidance is your intuition and argumentative essay skills.
19:08:37 <monochrom> The best guidance is specializing pure's and <*>'s type for ((->) e). Namely, pure :: a -> (e -> a), and ...
19:08:47 <zenspider> monochrom: hah. well. that's the task at hand. but they've not mentioned anything about (->) yet, so it seems really off base.
19:08:54 <monochrom> (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
19:09:20 <zenspider> that's a start at least... I can at least pretend to work with it and see where I get
19:13:42 <zenspider> the type checker is clearly lying to me... presumably because this other error is getting in the way of it getting more fine grained? How do I negate: Duplicate instance declarations: instance Applicative ((->) a) 
19:14:06 <zenspider> do I have to run entirely w/o prelude?
19:16:19 <monochrom> You can't completely get rid of Prelude because you need Applicative.
19:18:28 <shachaf> The instance is defined in the same module that defines Applicative, so you won't be able to define it yourself easily.
19:18:34 <monochrom> In this case, the easiest workaround is to define your own class "MyApp" and it just clones Applicative, then you do "instance MyApp ((->) whatever)" instead.
19:19:03 <shachaf> You can define your own Applicative class if you want. Or if you're just writing the functions to learn about them you can define them outside of a class.
19:19:49 <monochrom> The most interesting workaround is to clone too, but this time git clone GHC.
19:19:56 <zenspider> yeah. I added MyApplicative and copied the type signatures above... they seem wrong atm. not sure which part yet.
19:20:28 <monochrom> You need to copy the original "a -> f a" etc types, not my types.
19:20:51 <monochrom> My types are for guidance, just like the commented out types in the textbook.
19:21:35 <monochrom> Here: class MyApplicative f where { mypure :: a -> f a; <<*>> :: f (a -> b) -> f a -> f b }
19:21:46 <monochrom> Maybe >*< is shorter.
19:22:07 <monochrom> Err I need parentheses too. (>*<) :: f (a -> b) -> f a -> f b
19:33:37 <zenspider> why does hoogle hate (->) ?
19:33:51 <zenspider> and/or ... how do I find the real Applicative instance for it?
19:34:15 <shachaf> Probably look in Control.Applicative
19:34:42 <shachaf> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html
19:36:34 <zenspider> so... search hackage for base?
19:37:39 <zenspider> ok. so I got pure = const... that seemed obvious
19:38:01 <zenspider> I f'd up <*> entirely? the real one has a third arg?
19:38:34 <Arahael> WHere can I learn about the ExtendedDefaultRules?
19:38:39 <Arahael> (Shelly seems to require this)
19:38:43 <zenspider> wait! no! I think I got it! eab >*< ea = \e -> eab e (ea e)
19:38:54 <zenspider> where the \e is the 3rd arg
19:38:57 <shachaf> There's only one reasonable implementation for that instance, so you can just use the type checker to help you.
19:39:00 <shachaf> Yep, that's right.
19:39:33 <zenspider> I still don't know how to USE it... :P but that's beside the point, I guess
19:39:35 <thebnq> > ((*) <$> (+1) <*> (+2)) 3
19:39:37 <lambdabot>  20
19:39:45 <monochrom> GHC user's guide has ExtendedDefaultRules.
19:40:08 <shachaf> Does your book talk about that?
19:40:30 <shachaf> I read the first edition of that book which I think predated Applicative
19:40:58 <Arahael> monochrom: It does, here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extended-rules-around-default-declarations
19:40:58 <zenspider> I think I like my infix form better... as it has helped me think of `(>*<) :: f (a -> b) -> f a -> f b` more accurately as `(>*<) :: f (a -> b) -> (f a -> f b)`
19:41:11 <Arahael> monochrom: However, it doesn't really make much sense to me, as I'm still figuring haskell out.
19:41:26 <zenspider> thank you everyone
19:42:08 <Arahael> monochrom: With it, however, `cmd "uname" "-a"` works, without it, it doesn't.
19:42:33 <monochrom> You'll need to be pretty familiar with several classes in Prelude, and the default rules in standard Haskell, before extended default rules can be explained.
19:43:23 <Arahael> monochrom: Which classes?
19:43:56 <monochrom> Like Num and Eq.
19:45:14 <Arahael> Sure, I believe I know those typeclasses.
19:46:26 <Arahael> So it must be the default rules I still need to understand  The section 5.4.8 isn't entirely clear to me either.
19:48:06 <monochrom> Haskell 2010 section 4.3.4 is on defaulting.
19:49:24 <Arahael> Thanks for that!
19:50:56 <Arahael> Actually that sounds fairly simple - there's a bunch of rules for defaulting, and they're pretty restrictive.  ExtendedDefaultRules effectively makes it behave more like ghci.
19:51:07 <Arahael> By adding additional rules that allow defaults.
20:44:52 <zenspider> In https://gist.github.com/9926608823a6ee7fd58d098776379b2a I've got 2 versions of the same (rough) thing. A monadic version (which I pulled from a John Hughes paper) and a non-monadic version... As I understand it, `do` ensures that the whole thing is wrapped up in the Monad monad, and therefore sequenced linearly. The pattern matching version does't have that restriction, so haskell is free to do the code out of order / in parallel /
20:44:52 <zenspider> whatever, right?
20:45:24 <zenspider> Is there some way to look at what ghc produces (preferably NOT at the assembly level) so I can better understand the pros/cons of each approach?
20:46:19 <geekosaur> -ddump-ds perhaps. -ddump-simpl is better but is core instead of haskell
20:46:38 <c_wraith> I think core is the right level to look at a lot of things
20:47:16 <geekosaur> the pattern version still does some order enforcing, because (Just x) (Just y) will force those in that order and iirc is required to
20:47:57 <c_wraith> yes, the spec lays out the order of pattern matches in a single big match happen
20:48:03 <c_wraith> -happen
20:48:12 <geekosaur> (given laziness, you would have a proble if you assumed alater parameter that coudl be botom wouldn't evaluated for some valus of an earlier one
20:48:33 <geekosaur> gah, this keyboard
20:49:29 <geekosaur> given laziness, you would have a problem if you assumed a later parameter that could be bottom wouldn't be evaluated for some values of an earlier one, by ordering… then the compiler reordered them
20:50:20 <zenspider> what is supposed to happen / be produced by either dump flag?
20:50:25 <zenspider> I'm getting nothing
20:50:30 <zenspider> (but the executable)
20:50:45 <geekosaur> if you're using stack, ti dumped a *.dump-ds or *.dump-simpl file somewhere under ~/.stack-work
20:50:50 <zenspider> (and a .o and .hi file)
20:51:42 <geekosaur> also if you did;'t change the source, you want -fforce-recomp or it'll just relink what it has alreadycompiled
20:52:02 <zenspider> I just used ghc... I have yet to figure out stack. It seems a mess to me
20:52:10 <geekosaur> and ignore the dump opts because it didn't compile anything
20:52:20 <metalrain> so compiler ensures that first argument is evaluated first with barriers or something and prevents cpu from doing out of order execution? 
20:52:40 <geekosaur> cpu's eval is its own problem; its nto suposed to reorder nw ays tat affect this
20:53:49 <geekosaur> otherwise anything with a data dependency would be broken by any cpu with speculative execution
20:54:55 <geekosaur> and the compiler can't alwasy tell when that happens in most languages so wouldn't always be able to insert barrier instructons
20:55:48 <geekosaur> and if you always insert them, you're losing all the benefit of reordering and might as well not have it enabled on the cpu]\
20:57:19 <geekosaur> in fact, iirc this is behind one of the recent security issues: it silently ignores "bad access" traps during speculative execution… allowing a timing attack
20:57:39 <geekosaur> because they still take some time even if they are ignored
20:58:50 <geekosaur> (worse, if it's valid memory it gets read anyway and you can sniff the result; that's the easier of the recent attacks to exploit)
21:00:51 <geekosaur> anyway it can't speculatively execute into an infinite loop, it needs too much of the CPU to do the loop part
21:56:10 <slack1256> Has anyone had luck with running a gtk-gi app on windows?
22:55:25 <pie_> :( https://old.reddit.com/r/haskell/comments/9fefoe/if_you_had_the_ultimate_power_and_could_change/e60mows/ 
23:00:34 <nitrix> Does someone quickly happens to know how pattern matching is implemented in GHC? Does every function has a very complex switch case, or is the compiler able to identitfy which pattern is a match ahead of time and optimize this into its own isolated function?
23:02:12 <nitrix> (I'm guessing there has to be a fallback for when arguments are only know at runtime)
23:02:16 <nitrix> *known
23:05:22 <cocreature> nitrix: ghc does have a case-of-known-constructor transformation (not sure if that’s still its name these days) for eliminating pattern matches
23:05:30 <cocreature> but obviously that doesn’t work in all cases
23:05:39 <dminuoso> nitrix: You can observe the generated core and stg code to see what's happening beneath.
23:06:25 <nitrix> cocreature: Thanks for the new term. I'll try to look in that direction.
23:07:05 <ggole> case-of-known-constructor is an optimisation. Translating pattern matching is... translation.
23:07:06 <nitrix> I want to see what happens for polymorphic functions, when they are known.
23:07:54 <ggole> There's a chapter in Peyton-Jones's book about pattern matching, but it might be a bit out of date.
23:08:08 <nitrix> ggole: I _just_ opened that :P
23:08:11 <nitrix> 4.1
23:08:18 <ggole> In particular, it doesn't cover or-patterns.
23:08:29 <cocreature> we still don’t have or-patterns in Haskell
23:08:39 <cocreature> so at least in that sense it is not out of date :)
23:08:44 <ggole> Oh, never mind then. :p
23:08:49 <dminuoso> ggole: He has a book? :o
23:09:03 <nitrix> dminuoso: https://www.microsoft.com/en-us/research/wp-content/uploads/1987/01/slpj-book-1987-small.pdf
23:09:05 <ggole> Yeah, on implementing functional languages
23:09:08 <cocreature> nitrix: you might be interested in https://www.microsoft.com/en-us/research/wp-content/uploads/1998/09/comp-by-trans-scp.pdf
23:09:45 <cocreature> nitrix: GHC will attempt to specialize polymorphic functions in most cases
23:09:47 <ggole> nitrix: are you writing a compiler that has to implement pattern matching, or just curious about what happens under the hood?
23:09:50 <nitrix> I'm doing a message passing language and the pattern matching is where the overhead is.
23:09:57 <dminuoso> nitrix: Oh that's just great. :)
23:10:07 <ggole> You might want to find Maranget's papers as well, then
23:10:18 <ggole> "Optimising pattern matching" in particular
23:11:29 <nitrix> ggole: Luc Maranget ?
23:11:34 <ggole> Yep
23:11:36 <nitrix> Got it.
23:11:55 <ggole> pauillac.inria.fr/~maranget/opt-pat.ps.gz
23:12:11 <nitrix> (http://pauillac.inria.fr/~maranget/papers/opat/)
23:12:42 <cocreature> https://www.microsoft.com/en-us/research/wp-content/uploads/2017/03/santos-thesis.pdf might also be worth a look
23:13:19 <nitrix> The only reason why it's a problem is because I'm not requiring the user to provide type signatures for functions.
23:14:16 <cocreature> nitrix: but you are working in a typed setting, i.e., you are inferring the types yourself?
23:14:20 <nitrix> The type inference system is really good, to the point where I'm totally okay with the idea of not even presenting the user with any types. Even diagnostic messages are simply saying "You tried to send a message of the format X to actor Y, but it wont understand it"
23:15:02 <nitrix> cocreature: It is typed and it's able to be inferred. The user cannot give hints other than by usage though.
23:15:17 <cocreature> I don’t see how it matters for the optimizer if types are user-specified or inferred
23:15:20 <dminuoso> What exactly does this error regarding functional dependencies mean? https://gist.github.com/dminuoso/570715d0c1695095377f2cb206c5b81c
23:16:28 <dminuoso> Is it that GHC infers that since IOException unqiuely identifies IO in MonadError, that if I use `throwError` in IO, then whatever I throw *has* to be of type IOException - and it fails to match this with the actual type (ServantErr)?
23:16:45 <nitrix> cocreature: Well, if type signatures were required, I could break each pattern into its own isolated function and isolate them a lot more easily. I guess some of them would still need to do pattern matching for specific Int values and stuff, but it wouldn't be as problematic as it is currently.
23:17:06 <nitrix> cocreature: Right now, the overhead is just too big. I need _some_ optimization somewhere.
23:17:44 <ggole> If you haven't written a match compiler, then how are you translating patterns at the moment?
23:17:52 <ggole> Just trying each one in order?
23:18:05 <nitrix> Correct. Very naively :P
23:18:10 <cocreature> dminuoso: right, the functional dependency on MonadError tells GHC that if you use throwError in IO you have to throw something of IOException
23:18:31 <ggole> I see. Well, it should be easy enough to improve on that.
23:18:42 <cocreature> nitrix: my point is the user can specify the same signature that you infer so it doesn’t really matter whether the signature comes from the inference or from the user
23:18:52 <dminuoso> cocreature: What exactly is the point of that functional dependency?
23:18:52 <dminuoso> cocreature: Naively I might think this is overly restrictive.
23:19:50 <cocreature> for most functional dependencies, the advantage is better inference
23:20:00 <dminuoso> Or is this the magic that lets mtl figure out how to automagically lift things?
23:20:25 <nitrix> cocreature: ggole: I'll read all the material you guys gave me first and we'll discuss further once I know a little more what I'm getting into :)
23:20:36 <cocreature> nitrix: have fun! :)
23:25:23 <dminuoso> cocreature: I see, so if there exists a functional dependency `x -> y` then infering y means we have also inferred x?
23:25:23 <dminuoso> Oh no the other way actually. =)
23:26:00 <cocreature> dminuoso: right for MonadError if you know what "m" is then you know what the error type is
23:29:23 <maerwald> there is also an mtl implementation with type families
23:48:02 --- mode: glguy set +v piyush-k`
23:50:40 <piyush-k`>  Is there a experimental hackage instance that is particularly Is there a experimental hackage instance that is particularly designed for packages that want to seriously use backpack ?
