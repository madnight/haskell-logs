00:09:27 <koz_> trcc: Woah, nice.
00:09:39 <trcc> :)
00:29:22 <thebnq> Interesting, I thought years ago there was some difficulty haskell on the JVM ... something changed?
00:30:54 <liste> well someone made Eta
00:31:24 <liste> there's no inherent problems with Haskell on JVM, nobody just made a compatible and complete enough implementation
00:33:24 <quicksilver> there are some impedance mismatches in the memory allocator and GC, I believe
00:33:30 <quicksilver> which make it hard to do well
00:33:37 <quicksilver> not the same as impossible, of course
00:35:09 <liste> quicksilver: you mean "regular" JVM GC/allocator being inefficient for Haskell?
00:48:23 <quicksilver> yes.
01:06:39 <delYsid> oh, this certainly looks better then "abusing" the state monad. https://ocharles.org.uk/posts/2013-02-12-quick-dsls-with-endo-writers.html
01:06:52 <delYsid> Any comments on this approach?  Looks like I want to do this.
01:08:46 <tsahyt> why is tail partial? it seems like one could define tail [] = []
01:08:54 <oak> at least Frege manages to do quite well with JVM's GC
01:18:07 <geekosaur> tsahyt, only if you also define returning the last item as doing so in a 1-item list
01:19:35 <tsahyt> can you give an example of what you mean? I'm not sure I understand. last . tail == last already doesn't hold for 1 element lists
01:20:24 <geekosaur> > tail [3]
01:20:27 <lambdabot>  []
01:20:47 <tsahyt> but this wouldn't change
01:20:48 <geekosaur> er, no. derp
01:21:34 <geekosaur> consider
01:21:43 <geekosaur> > tail [[],[]]
01:21:45 <lambdabot>  [[]]
01:22:27 <geekosaur> gah, I know what I'm thinking of and not expressing it. there's a case that is ambiguous
01:22:47 <geekosaur> and I should ave been in bed several hours ago :(
01:24:45 <tsahyt> well for [[]], last [[]] == tail [[]], but that's already true with the current definition
01:31:44 <marvin2> :t last [[]]
01:31:46 <lambdabot> [a]
01:31:49 <marvin2> :t tail [[]]
01:31:50 <lambdabot> [[a]]
01:32:31 <tsahyt> hm, that's true as well
01:32:37 <tsahyt> I was thinking about values
01:32:47 <tsahyt> > (last [[]], tail [[]])
01:32:49 <lambdabot>  ([],[])
01:35:45 <marvin2> hmm
01:35:46 <marvin2> > let xs = [[]] in last xs == tail xs
01:35:48 <lambdabot>  True
01:35:52 <marvin2> how does this compile?
01:36:39 <Ferdirand> because [[a]] is a special case of [a] ?
01:36:58 <marvin2> what is the type of xs in above expression?
01:37:08 <Ariakenom> [[a]] is a special case of [b] where b=[a]
01:37:29 <Ariakenom> :t [[]]
01:37:30 <lambdabot> [[a]]
01:37:53 <Ariakenom> maybe you're wondering about defaulting
01:38:18 <tsahyt> :t tail [[]] :: [[a]]
01:38:19 <lambdabot> [[a]]
01:38:35 <tsahyt> :t tail [[]] :: b ~ [a] => [b]
01:38:36 <lambdabot> [[a]]
01:38:38 <tsahyt> yea
01:39:16 <marvin2> > let xs = [] :: [a]; ys = [] :: [[a]] in xs == ys
01:39:19 <lambdabot>  True
01:39:47 <tsahyt> a0 is still free to unify with [a1]
01:40:09 <tsahyt> > let xs = [] :: [Char]; ys = [] :: [[Char]] in xs == ys
01:40:11 <lambdabot>  error:
01:40:11 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
01:40:12 <lambdabot>        Expected type: [Char]
01:40:49 <marvin2> don't we need concrete types to use ==?
01:41:04 <Ariakenom> yes, that's where defaulting comes in
01:41:07 <Ariakenom> > 1+1
01:41:10 <lambdabot>  2
01:41:24 <marvin2> > let xs = [[]] in last xs == tail xs
01:41:27 <lambdabot>  True
01:41:32 <merijn> Pretty sure this works because lambdabot is like ghci and has extended defaulting
01:41:38 <marvin2> what is the type of xs above, that last xs and tail xs result in the same type
01:41:50 <cocreature> marvin2: the type of xs is [[()]]
01:42:05 <Ariakenom> there's a list of types to choose when the choice is ambiguous. ghci does more defaulting than ghc
01:42:24 <cocreature> oh wait that doesn’t explain the last vs tail thing
01:42:24 <marvin2> > let xs = [[()]] in last xs == tail xs
01:42:28 <lambdabot>  error:
01:42:29 <marvin2> yep
01:42:30 <Ariakenom> > maxBound
01:42:30 <lambdabot>      • Couldn't match type ‘[()]’ with ‘()’
01:42:32 <lambdabot>        Expected type: [()]
01:42:34 <lambdabot>  ()
01:42:41 <Ariakenom> :t maxBound
01:42:42 <lambdabot> Bounded a => a
01:42:44 <Ariakenom> > maxBound
01:42:46 <lambdabot>  ()
01:43:05 <Ariakenom> ghci chooses a type based on a default list
01:43:12 <Ariakenom> like () for Bounded a => a
01:43:27 <cocreature> Ariakenom: but what does it actually default to here?
01:43:55 <cocreature> :t \xs -> last xs == tail xs
01:43:56 <lambdabot> error:
01:43:57 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ [a]
01:43:57 <lambdabot>     • In the second argument of ‘(==)’, namely ‘tail xs’
01:44:10 <cocreature> huh
01:44:15 <Ariakenom> huh
01:44:58 <cocreature> it looks like it infers a polymorphic type for xs but then monomorphizes last xs and tail xs
01:45:25 <Ariakenom> huh
01:45:44 <cocreature> so xs has type [[a]], tail xs has type [[()]] and last xs also has type [[()]]
01:45:53 <cocreature> defaulting needs to die
01:46:15 <Ariakenom> and a remains unspecified
01:46:37 <cocreature> it’s not unspecified, it’s polymorphic
01:46:59 <Ariakenom> yes, not concrete
01:47:10 <merijn> Ariakenom: Concrete is a bad term that should stop being used
01:47:18 <merijn> Because no one agrees on what concrete means
01:47:34 <cocreature> > let xs = [[]] :: [[a]] in (last xs :: [[()]]) == (tail xs :: [[()]])
01:47:36 <lambdabot>  True
01:47:39 <cocreature> ^ marvin2 
01:49:08 <marvin2> so xs has polymorphic type, and ghci's defaulting used xs of different concrete type when applying last vs tail?
01:49:41 <merijn> marvin2: See previous remark about "concrete" being terminology you're better of forgetting :)
01:49:49 <MarcelineVQ> no, last and tail are using the same type
01:50:09 <merijn> I should get quchen to write up one of my complaints about "concrete type" in his FBUT so I can just link my answer... :p
01:50:33 <cocreature> MarcelineVQ: no they are not, for "last" a is instantiated with [()] and for "tail" a is instantiated with ()
01:51:22 <MarcelineVQ> Really? Oh those signature are for the result. I blame let for this more than defaulting.
01:51:38 <merijn> marvin2: In this case "monomorphic type" would be less ambiguous (optionally you could say "monomorphic type of kind *", but that's implicit in the context here)
01:58:44 <koz_> merijn: I can just see you graffiti'ing the link to that explanation on every concrete building ever.
02:17:47 <quicksilver> I think that occurs check error is right.
02:18:39 <quicksilver> I think that polymorphic inference/defaulting violates ..
02:18:41 <quicksilver> erm...
02:18:47 <quicksilver> some of my expectations, at least :)
02:19:33 <quicksilver> I feel like it violates some reasonable expectations about substitutability of xs
02:19:54 <Ariakenom> default ()
02:23:45 <Taneb> > show . read $ "()"
02:23:48 <lambdabot>  "()"
02:24:09 <Ariakenom> % show . read $ "()"
02:24:10 <yahb> Ariakenom: "()"
02:24:19 <Ariakenom> % default ()
02:24:20 <yahb> Ariakenom: 
02:24:21 <Ariakenom> % show . read $ "()"
02:24:21 <yahb> Ariakenom: ; <interactive>:31:1: error:; * Ambiguous type variable `a0' arising from a use of `show'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in `
02:24:59 <Ariakenom> right, I don't know how to reset yahb though
02:32:23 <delYsid> Hmm, typeclasses still behave unexpectedly to me.
02:32:49 <ggVGc> I'm still quite undecided if I like them
02:32:57 <ggVGc> I tend to use records of functions a lot more nowadays
02:33:16 <mniip> Ariakenom, :q
02:33:19 <mniip> or %kill
02:33:25 <ggVGc> I feel pretty much too dumb to use 80% of haskell, so I just use the stuff I find straighforward
02:33:41 <liste> ggVGc: sounds like a good idea
02:34:09 <ggVGc> I feel typeclasses have caused me a lot of problems from mis-use or misunderstanding, which when I use records just don't happen
02:34:22 <ggVGc> but I might not be seeing the good usecases
02:34:42 <Ariakenom> ggVGc: like Functor?
02:34:54 <mniip> Monad
02:34:57 <mniip> Eq
02:34:58 <liste> typeclasses with laws are nice
02:35:14 <ggVGc> yeah, I guess I should have clarified what I meant
02:35:16 <mniip> Num
02:35:33 <Ariakenom> > let nan = 0/0 in nan == nan
02:35:34 <ggVGc> of course I use the typeclasses that are part of the language, with laws and elaborate theory behind them that make sense
02:35:36 <lambdabot>  False
02:35:40 <ggVGc> but for my own uses cases I don't really use them
02:37:47 <Ariakenom> %kill
02:37:47 <yahb> Ariakenom: Done
02:37:58 <Ariakenom> % putStrLn "Hello world"
02:37:58 <yahb> Ariakenom: Hello world
02:44:17 --- mode: glguy set +v la5tl19ht
02:44:44 --- mode: glguy set +v dataN
02:44:50 --- mode: glguy set -v dataN
02:46:35 <merijn> Welp...I decided to safe future me a bunch of time: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
02:46:39 <merijn> Any proofreaders?
02:46:57 <dataN> GHC tells me it has a new language feature; https://gist.github.com/dataN-hs/342240296d21b8a0b7a5ecb7dd51e8b1
02:51:26 <oisdk> merijn had a quick read, couldn't see any mistakes
02:51:34 <dataN> merijn; s/terms/term
02:51:45 <dataN> and how is kind k not of any kind?
02:51:52 <oisdk> although i'm not sure about "Maybe a = polymorphic"
02:52:10 <Ariakenom> merijn: "Values always have types of kind *" not true
02:52:23 <dataN> :k ([]::k)
02:52:25 <lambdabot> error: Not in scope: type variable ‘k’
02:52:36 <dataN> :k ([]::forall k. k)
02:52:37 <lambdabot> error:
02:52:37 <lambdabot>     Illegal kind: forall k. k
02:52:37 <lambdabot>     Did you mean to enable TypeInType?
02:52:45 <dataN> % :k ([]::forall k. k)
02:52:45 <yahb> dataN: ; <interactive>:1:2: error:; * Expecting one more argument to `[]'; Expected kind `forall k. k', but `[]' has kind `* -> *'; * In the type `([] :: forall k. k)'
02:53:05 <merijn> Ariakenom: Eh, yes it is
02:53:15 <merijn> Ariakenom: Well, unless you wanna go into # and all that
02:53:30 <merijn> Ariakenom: Which, really, if you know about that, you already know enough not to be confused
02:53:49 <Ariakenom> I know # but used concrete
02:54:00 <dataN> then there are only monomorphic types of kind k or * ?
02:54:14 <merijn> Ariakenom: I mean "know enough to not be confused by my statement of all values having types of kind *"
02:54:26 <dataN> wait nvm
02:54:30 <merijn> dataN: I mean some arbitrary, but specific kind :)
02:54:47 <merijn> dataN: i.e. "k = * -> *" or "k = * -> (* -> *) -> *", etc.
02:55:34 <dataN> so of sort * or k ?
02:56:06 <merijn> dataN: Well, there's infinite kinds other than * so I can't write all of those out :p
02:56:16 <Ariakenom> It just stood out as imprecise terminology on a rant about precise terminology
02:56:33 <merijn> Ariakenom: It's not imprecise, though. Because Haskell2010 doesn't have all those other kinds
02:56:40 <dataN> can anyone see the gist above for what is this new language feature? 
02:56:45 <merijn> Ariakenom: *GHC* has those kinds, but Haskell2010 does not
02:56:59 <merijn> Ariakenom: So I stand by my simpler choice :)
02:57:10 <dataN> maybe with comment about how its being used re type family superclasses
02:57:57 <merijn> dataN: I'm not sure what your question about your gist is?
02:58:20 <dataN> is that what its doing...
02:58:40 <Ariakenom> in the same spirit does TypeInType affect that statement too?
02:58:56 <merijn> dataN: It'd also help clarify which new feature you're referring too?
02:58:59 <dataN> it says it needs ConstrainedClassMethods
02:59:05 <Ariakenom> maybe a note about Type=*
02:59:07 <merijn> Ariakenom: I dunno, TypeInType confuses the fuck outta me
02:59:09 <oisdk> merijn your examples of polymorphic vs. monomorphic might be clearer with some quantifiers, actually
02:59:22 <merijn> Ariakenom: So I'm going to continue on ignoring it until I need it
02:59:34 <merijn> I find stratified universes so much simpler than TypeInType
02:59:36 <dataN> so are A_class and B_class superclasses of C_type ?
03:00:08 <merijn> oisdk: Maybe, but then it might also confuse people, especially beginners, so I'm on the fence
03:00:31 <dataN> wait no, A_class is a superclass of C_type and B_class is a constraint on its first argument
03:00:31 <oisdk> probably right
03:01:08 <dataN> its these kind of statements that I'm not really sure about and need better explaining... 
03:01:11 <merijn> oisdk: I'm gonna leave it as is for a bit and see what confuses people when I link it
03:01:52 <oisdk> dunno if i'm confused by it or just being pedantic
03:02:39 <merijn> oisdk: I mostly see "concrete type" used by beginners (I think LYAH uses it?), which probably haven't seen explicit forall's yet, so I think that might confuse them more
03:03:35 <oisdk> yeah i also just realised the non polymorphic case i was thinking about (existentials) *also* uses the forall syntax in haskell
03:04:15 <dataN> normally a type family expressing the defining function of a class of only one defining function can be written as a type level version of that class, but then it lacks the ability to give a constraint on the kind the type family version of the class is defined over. I'm wondering if the above is an example of how to achieve this
03:06:08 <Boomerang> What is the rationale behind ViewPattern scoping rules? `f g (g -> x) = x` works but `f (g -> x) g = x` doesn't.
03:06:38 <maerwald> is there a way to emulate stackage behavior in cabal new-build and disallow building any dependency that is not in stackage? Currently, I just use the stackage cabal.config, but that is not 100% consistent with stack behavior
03:07:27 <mniip> Boomerang, f k (($ k) -> x) = x
03:08:34 <Boomerang> Wow :o
03:08:49 <cocreature> dataN: ConstrainedClassMethods isn’t a new feature. have you looked at the docs for it?
03:09:38 <dataN> ok not new, but it would be a new way to solve that problem if it does
03:10:44 <dataN> sorry, it might not be new, but the more important thing is it might not solve that problem
03:11:31 <Boomerang> mniip: That's pretty cool :) My actual use case was closer to `f (g b -> a) b = something a b`
03:11:50 <Boomerang> But I can use a flipped version of `f` I guess :)
03:14:59 <dataN> cocreature: they are sparse, and dont help with this question 
03:15:47 <maerwald> cabal new-build --run-tests doesn't run tests
03:17:12 <dataN> possibly even its a misnomer, as it may be the constraint on the class itself which is doing the type family supperclass, of thats what it could be seaid to be doing
03:21:52 <dataN> possibly the only difference is making the compiler give a "no instance for class ... " error, instead of just failing to match a type family instance and returning the !kind test applied only as far as possible, which is kind of like a runtime error
03:22:08 <Athas> Any ETA on the next GHC release?
03:22:18 <dataN> the idea is to use the type system to give a compile time error for missing superclass instances. 
03:22:54 <dataN> just wondering if this concept is clear and if the above example manages to achieve this; 
03:22:59 <dataN> https://gist.github.com/dataN-hs/342240296d21b8a0b7a5ecb7dd51e8b1
03:23:33 <hvr> Athas: "when it's ready"
03:24:35 <hvr> maerwald: we recently added a feature to disallow deps that aren't mentioned in a freeze file
03:24:52 <hvr> maerwald: or more generally, that weren't explicitly mentioned in a `constraint`
03:25:06 <cocreature> dataN: I have no idea what you mean by that. you claim that you want to get a compile time error for missing superclass instances but a) don’t you already get that and b) your gist doesn’t actually show any error so it’s hard to say how it’s supposed to achieve this
03:25:49 <sgraf> Athas: I'm not sure if that's an admissable heuristic, but you can look at https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.6.1 and see which tickets still need fixing
03:29:00 <dataN> cocreature: commenting out the instances results in an error, but if the type families were declared at top level (not in a class) then it would just fail to match them at "runtime" (a call to !kind)
03:30:41 <cocreature> dataN: so how do ConstrainedClassMethods help with anything here? the behavior of the type families is entirely unaffected by the existence of c_func which is the only method that makes use of this
03:33:03 <dataN> right, thats why it might be a misnomer. thats just something thats needed to constraint the arguments, such as when making a type family for Traverse where one of the parameters of its kind needs to be an instance of the type family version of Applicative, for example
03:34:12 <dataN> the idea is that when writing "sub type families" that they be put in a class with a constraint to the class containing the "super type family" as an associated type
03:35:40 <dataN> possibly an empty class could be included as a constraint added to allow the user to say that the class was written with associated type families for each of its defining functions
03:37:18 <revtintin> \q
03:37:49 --- mode: glguy set +v greg__
03:40:35 <dataN> cocreature: type C_type (b' :: B_type 'B) :: c uses the constraint no?
03:42:47 <cocreature> dataN: no it doesn’t. you can remove all typeclass methods and disable ConstrainedClassMethods and it will behave exactly like it does now https://gist.github.com/cocreature/f6f1bdae85e7ca079cf43614553c3ead
03:45:13 <dataN> oh right,  type C_type (c') = 'True does not use the B constraint...
03:51:48 <dataN> maybe there is a way to write it so it would be like the 'Applicative f' constraint of Traverse ?
03:52:32 <dataN> so that it would give an error if it was called with a type that does not have this instance?
03:57:12 <merijn> Any experts on ResourceT and async exceptions? My cleanup operation appear to run without async exceptions masked
04:02:18 <merijn> Ah, I see what's going on, lack of uninterruptibleMask strikes again!
04:10:51 <dataN> oh, seems that there is no point of ConstrainedClassMethods as they should be placed at the class head
04:11:03 <dataN> (the constraints)
04:48:30 <cheater> hi
04:50:02 <cheater> i have a record of type T, and a list of functions of type T -> T. What's the best way to apply them all to T? just foldl (flip id) ... ? this is basically me setting default options, and then adding the ability to override (T -> T) - is there a better idiom for doing this?
04:50:41 <eR2oIEUwCAx1oEbG> Hello
04:51:30 <Ariakenom> :t flip id
04:51:32 <lambdabot> b -> (b -> c) -> c
04:51:39 <eR2oIEUwCAx1oEbG> Is anyone here familiar with cabal? The #hackage channel seems pretty silent so I thought i'd ask here
04:51:44 <Ariakenom> :t (&)
04:51:46 <lambdabot> a -> (a -> b) -> b
04:52:10 <lyxia> eR2oIEUwCAx1oEbG: just ask
04:52:57 <Ariakenom> :t foldl (&) (1::Int)
04:52:59 <lambdabot> Foldable t => t (Int -> Int) -> Int
04:53:02 <eR2oIEUwCAx1oEbG> So my end goal is to extract a list of module names from a .cabal file
04:53:19 <Ariakenom> :t foldl (.) id
04:53:20 <eR2oIEUwCAx1oEbG> But I'm confused by what the purpose of GenericPackageDescription serves
04:53:20 <lambdabot> Foldable t => t (c -> c) -> c -> c
04:54:01 <eR2oIEUwCAx1oEbG> What is the meaning of the output for condLibrary :: Maybe (CondTree ConfVar [Dependency] Library) ?
04:54:44 <Ariakenom> cheater: as a minor comment I prefer foldl (.) id
04:55:35 <Ariakenom> Ariakenom: should they be a list or just a function already composed with (.)?
04:55:36 <merijn> Ariakenom: "foldMap Endo"! :)
04:55:57 <eR2oIEUwCAx1oEbG> I see that I can get a Maybe Library from PackageDescription, but is there a difference between that list and the tree?
04:56:17 <Ariakenom> merijn: pretty much why I prefer it :)
04:56:31 <Ariakenom> the associativity
04:57:42 <dataN> cocreature: https://gist.github.com/dataN-hs/b48ff6d956bcb8ca47281ac9d90f424e
04:59:23 <lyxia> eR2oIEUwCAx1oEbG: there's an explanation of the difference of the two package description at the top of https://hackage.haskell.org/package/Cabal-2.4.0.1/docs/Distribution-Types-PackageDescription.html#t:PackageDescription
05:00:15 <eR2oIEUwCAx1oEbG> Ah, thanks! I guess I was too engrossed with following links that I didn't look at the top of the page
05:04:43 <eR2oIEUwCAx1oEbG> am I correct that it's refering to this feature: https://www.haskell.org/cabal/release/cabal-1.24.1.0/doc/users-guide/developing-packages.html#meaning-of-field-values-when-using-conditionals ?
05:06:05 --- mode: glguy set +v dataN_
05:17:21 <tsaka__> I have 2 functions that are supposed to be equal and a (tractable) list of all relevant inputs. How to test them with HSpec such that the test output format shows exactly which input failed?
05:17:24 <tsaka__> https://github.com/tsoernes/haskelldca/blob/master/test/GridneighsSpec.hs
05:18:04 <tsaka__> ^ Thats what I've got so far. It works but the  test output is not readable since all inputs are compared
05:18:52 <tsaka__> maybe there should be one "it 'description+input' A `shouldBe` B" for each input
05:19:59 <merijn> tsaka__: Why not use quickcheck, rather than a fixed list?
05:20:16 <merijn> tsaka__: QuickCheck gets you the "report failed input" part for free
05:20:36 <tsaka__> merijn: So long as all the inputs in the list are tested and no more then its good
05:20:48 <merijn> tsaka__: Why exactly those?
05:21:17 <tsaka__> merijn: those are the only inputs the functions will be used for 
05:22:04 <cocreature> tsaka__: how about for_ [1..4] $ \d -> for_ gridIdxs $ \cell -> p1 d cell `shouldBe` p2 d cell
05:22:39 <cocreature> if d can really only be 1,2,3,4 then you might want to make a sumtype for that instead of using an Int
05:22:46 <lyxia> eR2oIEUwCAx1oEbG: yes
05:29:55 <tsaka__> @cocreature That works, although only outputs are shown in the test failue; not inputs. One solution is to zip inputs with outputs but that causes an unnescecary comparison between inputs
05:29:55 <lambdabot> Unknown command, try @list
05:30:31 <dmwit> tsaka__: (p1 d cell, d, cell) `shouldBe` (p2 d cell, d, cell) ;-)
05:30:54 <cheater> Ariakenom: thanks
05:31:35 <dmwit> tsaka__: If you *really* want to avoid comparing cells, you can `newtype Input a = Input a; instance Eq (Input a) where _ == _ = True`
05:32:27 <cocreature> tsaka__: how about shouldSatisfy (d,cell) $ (\(d',cell') -> p1 d' cell' == p2 d' cell'
05:32:39 <tsaka__> dmwit: thank you, while not a problem in this case, I just wanted to know how to do so in general
05:32:42 <merijn> hmmm
05:32:50 <cocreature> although I guess that doesn’t show you the outputs if things don’t match
05:33:11 <cocreature> you can always write your own combinators
05:33:16 <dmwit> tsaka__: How about `for_ [1..4] $ \d -> for_ gridIxs $ \cell -> it ("implementions should match on " ++ show (d, cell)) (p1 d cell `shouldBe` p2 d cell)`
05:33:47 <cppxor2arr> what does the type constraint `Num (a -> a)` mean?
05:33:59 <dmwit> cppxor2arr: It means you've accidentally applied a number literal to an argument.
05:34:06 <dmwit> cppxor2arr: Look for a missing infix operator or similar.
05:34:14 <cppxor2arr> ok thanks i was a bit confused
05:34:37 <dmwit> :t 1 2
05:34:38 <lambdabot> (Num (t1 -> t2), Num t1) => t2
05:34:43 <dmwit> :t 1 + 2
05:34:44 <lambdabot> Num a => a
05:34:46 <cocreature> cppxor2arr: to elaborate on what dmwit says, integer literals are polymorphic in Haskell so 1 has type Num a => a
05:34:57 <cocreature> so if you try to use it as a function you end up with Num (a -> a)
05:35:19 <dmwit> It might actually be a bit tricky to literally end up with `Num (a -> a)`. But possible, I'm sure.
05:35:30 <dmwit> :t let x = 3 in 1 x + x
05:35:32 <lambdabot> (Num (t -> a), Num t, Num a) => a
05:35:46 <cppxor2arr> :t foldr (.) id [(+1)] (+1)
05:35:48 <lambdabot> (Num (a -> a), Num a) => a -> a
05:35:54 <dmwit> :t (\x -> 1 x + x) 3
05:35:56 <lambdabot> (Num (a -> a), Num a) => a
05:35:59 <cocreature> :t let x = 3 in x (x 1)
05:36:00 <lambdabot> (Num (t1 -> t2), Num (t2 -> t3), Num t1) => t3
05:36:07 <cppxor2arr> cool :D
05:36:11 <dmwit> cocreature: let polymorphism is killing you =)
05:36:21 <cocreature> dmwit: yeah I just realized :)
05:37:05 <dmwit> cppxor2arr: Ah, yeah, you probably just want `1` at the end, not `(+1)`.
05:37:13 <dmwit> :t foldr (.) id [(+1)] 1
05:37:15 <lambdabot> Num b => b
05:37:37 <dmwit> :t (+1) 1
05:37:39 <lambdabot> Num a => a
05:37:42 <dmwit> :t (+1) (+1)
05:37:43 <lambdabot> (Num (a -> a), Num a) => a -> a
05:39:12 <merijn> ugh...there's no real convenient way to match "everything but this exception" is there?
05:39:20 <dmwit> Interesting. Okay, next time somebody asks I will try to remember to fix "applied a number literal to an argument" to "used a number literal as a function". Subtle difference.
05:40:12 <cocreature> merijn: that seems like a pretty weird thing to want given that anyone is free to create new exception types at any time
05:40:36 <Ariakenom> merijn: catch special return normally. catch all. ?
05:40:37 <merijn> cocreature: I'm using forkFinally and want do rethrow the exception somewhere else *except* my own
05:41:36 <merijn> cocreature: "Left exc | Nothing :: Maybe MyException <- fromException exc -> throwTo threadId exc" works, but is...massively ugly
05:41:57 <cocreature> doesn’t seem so bad
05:42:37 <cocreature> I suppose you could also wrap your thread in a catch that catches your exception
05:42:50 <cocreature> and then in your finalizer you know it’s not your exception
05:42:58 <cocreature> although that gets tricky if it’s an async exception
05:43:02 <merijn> cocreature: Not quite, because my exception is async
05:43:21 <merijn> cocreature: And it's getting raised inside the finally part of forkFinally (sometimes, anyway)
05:44:29 <merijn> cocreature: Basically, I have an async exception for graceful shutdown, but sometimes it hits threads that were already shutting down. Which all behaves fine, but triggers ugly prints to stderr, so I want to intercept them
06:00:29 <delYsid> The idiomatic haskell program... Consists of 6 language extensions, 20 imports, and 1 line of Perl :-)
06:00:41 <merijn> Is there a way to override the default childHandler for forkIO or do I need to copy async's approach and write my own using fork#?
06:00:45 <delYsid> I always felt like Haskell replaces Perl in my life, although 15 years after I gave up on it :-)
06:01:31 <ggVGc> sounds weird
06:01:40 <ggVGc> how does haskell fill any of the use cases of perl?
06:01:49 <phadej> easily
06:01:51 <Rembane> It's quite good for glue code. 
06:02:04 <ggVGc> I mena, I don't know perl, and never used it, but I think the tasks solved by perl are more commonly done with something like python?
06:02:26 <phadej> ... or Haskell :)
06:03:17 <ggVGc> hm, I tried using haskell as a "coordinator in the middle" tool, but it always felt overkill and not very comfortable
06:03:26 <phadej> bunch of bash scripts -> bunch of perl scripts -> .... -> Haskell -- evolution of Ops automation
06:03:30 <ggVGc> maybe I am doing it wrong
06:03:47 <ggVGc> do you use any of the shell monad things? like turtle?
06:03:48 <delYsid> ggVGc: I am a braille display user.  Terse text has always been an advantage for me, since I do not need to scroll so often.  Perl, with its "lets use a lot of operators" style played in that ballpark for me.  And haskell, while it is a totally different language, sort of fills the samehunger for terse languages.
06:03:52 --- mode: glguy set +v nut
06:03:57 <delYsid> (for me)
06:04:19 <ggVGc> delYsid: cool that's a perspective someone like me wouldn't generally think of
06:04:30 <delYsid> yeah, sure.
06:04:40 <Rembane> You could do this in bash instead, but yeah... https://github.com/Rembane/Mute/blob/master/app/Main.hs
06:04:43 <phadej> ggVGc: not really. For running individial commands (e.g. no piping) raw `process` is nice enough
06:04:47 <ggVGc> in that sense I can see how haskell is a better perl for you delYsid 
06:05:02 <dmwit> delYsid: Man, you must *love* layout.
06:05:10 <delYsid> ggVGc: Yeah, its a shallow joke, but it has some truth to it, for me at least.
06:05:44 <dmwit> Maybe on a braille display it's not a big deal, but a screen reader seems like it would choke hard.
06:05:50 <delYsid> dmwit: I do.  In fact, people that break indentation make me really go crazy.
06:06:01 <ggVGc> why have more than one line?
06:06:19 <delYsid> dmwit: I dont code with speech output, although I know people that can do that.
06:06:30 <delYsid> ggVGc: My point! :-)
06:07:06 <ggVGc> delYsid: as a side note, I highly respect people with vision impairments that still proficiently use computers
06:07:09 <delYsid> Anyone care to take a look at my first EDSL?  I'd like to know if I am doing something terribly wrong.
06:07:16 <delYsid> https://blind.guru/MenuDSL.hs
06:07:21 <ggVGc> it must be quite challenging
06:07:35 <ggVGc> since the computer world really doesn't care much about blind users
06:07:40 <ggVGc> unfortunately
06:07:54 <delYsid> ggVGc: I highly respect everyone that can stand working with computers :-)
06:07:59 <ggVGc> I try to not be part of the problem, but I really am, because it always slips my mind when I work
06:08:31 <delYsid> ggVGc: Dont worry, the real world doesnt care about blind people either.
06:08:33 <quicksilver> I used to play MUDs which were popular with blind users (via a screen reader)
06:08:42 <quicksilver> at the risk of slipping a long long way off topic
06:08:54 <ggVGc> I've worked a lot with e-learning things, and norway has made new laws saying all websites for learning have to be accessible, which force it on me, and I realized how much I don't think about it
06:08:58 <quicksilver> couldn't believe how they could comprehend the wall of text at 2x reading speed or something
06:09:06 <ggVGc> delYsid: that's true :(
06:09:19 <merijn> quicksilver: Even sighted you become adept at speedreading MUD output, in my experience
06:09:29 <quicksilver> well of course
06:09:36 <merijn> Although text-to-speech it becomes speed hearing, I suppose ;)
06:09:38 <delYsid> ggVGc: Dont get me started on e-learning.  We are witnessing the destruction of web accessibility right now.  In about 10 years, almost nobody with a strong visual impairment will be able to do anything with a computer, at least nothing interesting.
06:09:44 <quicksilver> but speed reading is comprehensible to me, speed listening to a screen reader at high speed
06:09:50 <quicksilver> ... is a whole new skill
06:09:57 <Rembane> MUD <3
06:10:32 <ggVGc> delYsid: I used to live in Vietnam for a while, and once saw an older blind man crossing the street. In case you don't know, the way you cross the road in Vietnam is that you just look a bit for a slot, and then you walk slowly, and let all the motorbikes and cars drive around you. If there's a bus you don't walk. The guy stood there for a while, then he just walked slowly out
06:10:38 <ggVGc> I tried doing it a few times
06:10:50 <ggVGc> completely nervewrecking and impossible for me
06:10:51 <delYsid> quicksilver: Nah, not really.  Your speech synthesizer will pronounce every word exactly the same way.  If you listen to it for 2 weeks, you will automatically up the speed.
06:11:29 <quicksilver> delYsid: I'm sure that's true. But being able to respond in real time to a competitive PvP setting
06:11:46 <quicksilver> the popular clients attached sound effects to some words or phrases too
06:12:45 <delYsid> I am a braille guy, probably because I am from Europe.  We do get these devices around here, contrary to US citizens which usually have no social system to support them.
06:13:52 <delYsid> So, anyone got the time to tell me if I am completely off-track here? https://blind.guru/MenuDSL.hs
06:14:18 <delYsid> Or does that look like something a Haskell person would do?
06:15:47 <delYsid> (scroll to bottom of file for use-case)
06:16:52 <quicksilver> I'm not convinced I'd actually use a Monad for that kind of DSL
06:16:56 <quicksilver> but, it definitely looks cute
06:17:56 <ggVGc> delYsid: I'm kind of confused of your magic numbers in the menu builder
06:18:58 <delYsid> ggVGc: Just an example placeholder.  In Brick, you usually define a data type to "name" things, like data Name = Menubar | FileMenu | FileOpen | ..., but I was too lazy to do that in the example, so I picked n ~ Int
06:20:20 <delYsid> quicksilver: I use a nested list in my current impl, but optional values are getting a bit noisy (Nothing Nothing...), so I came up with this for nicer syntax.  However, I am totally open to better suggestions.
06:20:56 <EvanR> Just Nothing ?
06:22:51 <ggVGc> delYsid: ah, right, so it's meny IDs
06:23:30 <quicksilver> delYsid: Yes. It's not the first time I've seen the argument that do lets you use simple adjacency (and layout) instead of explicit list brackets
06:23:36 <delYsid> ggVGc: Brick calls them resource names, but yeah.
06:23:53 <quicksilver> to me it feels like a (mild) abuse and the [,[,,],] don't bother me that much
06:23:57 <quicksilver> but it's a question of taste.
06:24:35 <delYsid> quicksilver: Thats why I am asking, because I have a feeling this is overdoing things.  However, the resulting syntax is really very cute to work with.
06:26:47 <delYsid> However, syntax is one thing, not having to write out optional values is the real win.
06:26:52 <dmwit> I'm not in love with the repetition in the definitions of MenuM, SubmenuM, MenuItemM. But the parameterized alternatives I can think of would be a bit annoying to read.
06:27:46 <delYsid> dmwit: I am aware that I could abstract this away, but I didnt feel like complicating things more.
06:28:38 <delYsid> Anyway, the endo-writer trick is pretty, I feel like I learnt something today.
06:29:05 <delYsid> My first version used State, and that turned out to be more ugly.
06:29:14 <ggVGc> delYsid: well,you asked if this is what a haskell person would do, and overdoing it is exactly what haskell people do!
06:29:19 <ggVGc> so you're doing great
06:30:10 <dmwit> delYsid: Am I reading this right that every menu has exactly three layers? (Menu, Submenu, MenuItem)?
06:31:11 <delYsid> dmwit: Right now, yes.
06:31:21 <dmwit> I feel like it would be more flexible if menus had a list of `Either Menu MenuItem` or similar.
06:31:52 <delYsid> dmwit: Yeah, it should be recursive, but I havent figured out how to render that, so...
06:32:00 <dmwit> ah =)
06:34:06 <dmwit> Man, I have so many questions now. Please tell me if this gets annoying.
06:34:21 <dmwit> How does a braille display handle brick's border characters?
06:34:28 <delYsid> Nested lists vs monadic do: I have a suspicion that an eDSL is easier to change without breaking user code, am I wrong?
06:35:08 <dmwit> I think it's probably pretty similar.
06:35:44 <dmwit> At worst if you have a combinator that takes a list you can call `sequence` on it, so it shouldn't be harder to change.
06:35:55 <dmwit> (Like, in the implementation of the combinator.)
06:36:24 <delYsid> But isnt it easier to add things?  If I add something to a nested list-like thing, user code breaks.  However, if I add a new function to my edsl, user code could survive unchanged, no?
06:36:59 <dmwit> I'm not sure I understood that yet.
06:37:20 <delYsid> dmwit: Regarding borders, what do you want to know?  How a particular border character is represented in Braille?
06:38:26 <dmwit> Well, I guess my question is this: I sort of thought braille had a smallish alphabet. But Unicode is very big. Does this mean that every character that isn't in the smallish alphabet throws off the layout of the entire screen?
06:38:47 <dmwit> brick in particular relies heavily on all characters being the same width.
06:38:52 <delYsid> dmwit: https://github.com/brltty/brltty/blob/master/Tables/Text/boxes.tti
06:39:02 <dmwit> (Or at least predicting well how wide a character is.)
06:39:08 <dmwit> thanks!
06:40:02 <delYsid> dmwit: It is pretty much the same as with a plain virtual terminal.  Linux only has 512 glyphs.  So if you work with unicode, you cant represent every character.  Same with braille, we have 8 dots, so 256 possible combinations.
06:40:29 <phadej> so no Agda for you :/
06:40:40 <delYsid> dont get me started.
06:41:12 <delYsid> Haskell does that sort of thing also, horrible, inaccessible.
06:42:09 <dmwit> Anyway, for your question: I guess there's not that much difference between `dropDownMenu 0 [a, b, c]` and `dropDownMenu 0 $ do { a; b; c }` in terms of forward- or backward-compatibility.
06:44:05 <delYsid> dmwit: As long as it is *just* a list, yeah.  But if I add more (Maybe) arguments to my smart constructor, I see breakage while I *think* some of that could be avoided with this dsl-thing.
06:44:41 <dmwit> Perhaps!
06:47:37 <dmwit> I find the order that the dots are numbered in brltty bizarre. I'm guessing there's some kind of legacy system that needs backwards-compatibility or something?
06:48:36 <delYsid> dmwit: Braille started out as a 6-dot system.  When computers came along, it was obvious that it needed 2 more dots.
06:48:45 <dmwit> there it is
06:49:26 <delYsid> So 7 and 8 were added at the bottom, to avoid having to change everything, including how dots are named.
06:51:12 <delYsid> Braille can even encode music notation.  That is a pretty crazy compression thingy. http://bmc.blind.guru/goldberg.html#variation-1
06:51:30 <delYsid> An inherently 2d notation system cramped into a linear format.
06:52:09 <delYsid> I always wanted to rewrite my braille music compiler thing in haskell, I wonder if I will ever come to it.
06:52:26 <dmwit> Wow, that is incredibly dense.
06:52:33 <delYsid> it is
06:53:39 <delYsid> And contrary to public believe, it *is* machine readable :-)
06:54:00 <delYsid> I have code to convert such scores into LilyPond.
06:54:35 <delYsid> i.e., read/interpret the braille, and spit out the same music in LilyPond format.
06:55:19 <ggVGc> delYsid: surprised you're not into APL
06:55:21 <ggVGc> maybe you are
06:56:02 <delYsid> ggVGc: Nope.
06:56:33 <delYsid> I have an autogenerated tutorial for braille music code, in case anyone wants to deepdive: http://bmc.blind.guru/tutorial.html
06:58:46 <ggVGc> delYsid: do you use the music program Reaper?
06:59:12 <delYsid> ggVGc: Since I am about to google that, no.
06:59:40 <ggVGc> alright :) Just wanted to ask, because there's a guy posting fairly often on the forums who's blind, and I'm amazed at what he does
06:59:45 <delYsid> Looks like a GUI thing, no?
06:59:48 <ggVGc> yeah
07:00:05 <ggVGc> delYsid: but it's highly scriptable, and he somehow uses it
07:00:06 <delYsid> no, I am not into guis.
07:00:14 <ggVGc> yeah it seems very hard
07:00:16 <julianleviston> MacOS is incredibly accessible.
07:00:25 <julianleviston> (for the blind / deaf). Maybe he uses that.
07:00:29 <ggVGc> julianleviston: possibly that's how he uses it, yeah
07:00:32 <delYsid> julianleviston: And broken :-)
07:00:33 --- mode: glguy set +v Boarders
07:00:38 <ggVGc> but he has several tricks, I think . Hence why he posts a lot
07:00:45 <julianleviston> I was watching a guy use an iPhone the other day who was blind on the tram, it was amazing
07:00:56 <ggVGc> anyway would have been a funny coincidence delYsid, since you were writing about music
07:00:57 --- mode: glguy set -v Boarders
07:01:09 <delYsid> Windows is still the major platform for blind users.
07:01:10 <ggVGc> julianleviston: yeah that sounds a bit tough..
07:01:22 <delYsid> Many tried to have a love afair with Apple, but gave up
07:02:07 <delYsid> ggVGc: No, I am not the only one.
07:02:53 <dmwit> delYsid: cool tutorial!
07:03:51 <delYsid> dmwit: Thanks!  I wrote it to close the gap between sightedc newbies and experts.  Most learning material is pretty awkward.
07:04:01 <ggVGc> delYsid: haha, yeah, but it never hurts to hunt for coincidences
07:14:22 <merijn> Remind me, aside from leaking finite resources like Handles, there's no real problem with unsafeInterleaveIO, yes?
07:14:24 <delYsid> OK, l8r guys.  Have to move.
07:14:52 <dmwit> merijn: No, it breaks referential transparency completely.
07:14:59 <merijn> dmwit: How so?
07:15:14 <dmwit> The order in which you force the answer can change the value you observe.
07:15:37 <dmwit> Think of interleaving an action which bumps a counter in an IORef, and returning a tuple with the result of doing that twice.
07:15:53 <dmwit> Maybe you get (1,2), or maybe you get (2,1), depending on which order your read the parts of the tuple in.
07:16:18 <merijn> dmwit: okay, lemme rephrase. In the specific example of, say, https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Concurrent-Chan.html#v:getChanContents not much can go wrong, yes?
07:16:38 <merijn> dmwit: As it's impossible to affect the observable order there
07:17:17 <Ariakenom> it's not that bad. the order of effects is allowed to be different because unsafeInterleaveIO has IO effects
07:17:17 <dmwit> Yes, getChanContents is safe. They have taken on the proof burden of using unsafeInterleaveIO.
07:17:38 <dmwit> Ariakenom: The order of effects is changed by modifying the *pure* computation you do on the returned value.
07:17:43 <dmwit> Ariakenom: That's not okay.
07:18:09 <Ariakenom> consider replacing it with forkIO; sleep; change;
07:18:37 <merijn> dmwit: Basically, I have my own written version of getChanContents and I just realised it's massively simplify some code to switch to it.
07:18:41 <Ariakenom> that can behave differently every time. and can behave like interleave
07:19:13 <Ariakenom> unsafeInterleaveIO isn't unsafe like unsafePerformIO is. as in it doesn't break any rules
07:19:32 <Ariakenom> it's just tricky
07:19:54 <dmwit> Ariakenom: https://mail.haskell.org/pipermail/haskell/2009-March/021064.html
07:20:03 <merijn> In fact, this simplifies things so much it's mindblowing I haven't seen it before...
07:21:28 <dmwit> Ariakenom: This is a direct break of referential transparency. That is not something you can achieve with boring old forkIO.
07:22:17 <dmwit> Ariakenom: Changes *only to pure code* -- and even changes which *do not change the semantics* of the pure code -- lead to differing behaviors.
07:23:08 <Ariakenom> meh. you could have pure code leading to different behaviour without it. by it taking more time to execute
07:23:32 <dmwit> You can't observe "taking more time" from within pure code. You need to do IO for that.
07:23:45 <dmwit> This doesn't require doing any IO to observe the difference.
07:26:37 <c_wraith> in other words, unsafeInterleaveIO (and unsafeInterleaveST, which is even worse in a couple ways) allows you to introduce a dependency on evaluation order, when evaluation order should be unobservable by Haskell semantics
07:29:22 <c_wraith> (I say unsafeInterleaveST is worse because it can be used within a function in a manner that is completely invisible in the type. At least uses of unsafeInterleaveIO show IO in the type)
07:30:11 <dmwit> merijn: Actually, getChanContents is safe, but only under the assumption that you don't read from that `Chan` ever again after calling it.
07:31:16 <merijn> dmwit: Ah, thanks for reminding my why I wrote my version in such a confusing way :)
07:31:27 <merijn> dmwit: Because mine prevents exactly that problem from occuring :p
07:31:28 <dmwit> (But I think it's pretty normal to have no other readers, either before or after, so that's not an unbearable restriction.)
07:31:45 <c_wraith> this is where uniqueness types would help!
07:32:22 <c_wraith> ...  admittedly, not so much with Chan.  But with that package that splits chan into a reader and writer half, then it would help.
07:32:30 <dmwit> merijn: It wouldn't be too hard to implement the type `IO (a -> IO (), [a])`, which returns a way to write to a chan and the contents of the chan. This would guarantee that you can't misuse `getChanContents`.
07:32:37 <merijn> c_wraith: Like my package that does that ;)
07:33:01 <dmwit> % import Control.Concurrent.Chan
07:33:01 <yahb> dmwit: 
07:33:27 <merijn> c_wraith: In fact, I'm hoping to put Control.Concurrent.Chan into the ground once I've sorted the remaining issues
07:33:28 <dmwit> % :t do { chan <- newChan; contents <- getChanContents chan; return (writeChan chan, contents) }
07:33:28 <yahb> dmwit: IO (a -> IO (), [a])
07:35:18 <c_wraith> merijn: the biggest issue with Chan from my point of view is that it doesn't provide back-pressure.  Fortunately, there are lots of bounded variants available.  Does your library have a bounded variant?
07:35:54 <merijn> c_wraith: There's more issues than that, like the fact that you can't sensibly use getChanContents since it'll never terminate, etc.
07:36:51 --- mode: glguy set +v Afzal
07:37:03 <dmwit> ?
07:37:04 <merijn> c_wraith: I kept reinventing the same things on top of Chan and some of my suggestions for changes/improvements to Control.Concurrent.Chan where said to need real world testing first, so I've been working on my own "batteries included" version
07:37:08 <c_wraith> merijn: that's not really the same level of issue.  It doesn't result in programs consuming gigabytes too much memory
07:37:10 <dmwit> You can send a "terminate" message in your channel.
07:37:27 <merijn> dmwit: That won't stop getChanContents infinite recursion, though
07:37:52 <c_wraith> merijn: getChanContents uses co-recursion.  It stops when you stop consuming the list.
07:37:53 <dmwit> It will if your consumer stops matching on the list produced by it.
07:38:31 <merijn> c_wraith: I do have a back pressure parallel map/fold on top of my Chan implementation, though
07:38:53 <merijn> c_wraith: Including some wrappers to get parallel conduits :)
07:39:59 <merijn> Which works great! *
07:40:12 <merijn> * - Massive restructuring requiring bug not withstanding >.>
07:40:14 <c_wraith> *
07:42:40 <merijn> c_wraith: Initially I was just trying to fix the space leak you get when trying to use Chan without a guaranteed reader (i.e. writing notifications to a Chan and having readers subscribe to them by doing dupChan)
07:45:25 <merijn> c_wraith: I've been working on getting the API ready for a first "real" release, so if you have a wishlist of missing things, lemme know: https://hackage.haskell.org/package/broadcast-chan-0.2.0/candidate
07:49:39 <c50a326> hey what funky stuff can I do with the monads/applicatives for Maybe and/or Either?
07:50:17 <delYsid> Use >>= and <*>
07:50:27 <c50a326> lol yes that's what I mean
07:51:00 <c50a326> I mean I've written this https://ptpb.pw/9E6x/hs and I know how to write it using >>= -> notation instead
07:51:15 <c50a326> but it's pretty stupid, I don't know what I'd actually use it for in practicality
07:52:04 <delYsid> c50a326: It is going to get interesting if you dont know if your maybe is a just or nothing.
07:52:11 <mlehmk> it becomes interesting if you have Nothing or Left a
07:52:50 <delYsid> I think of >>= as a way to pass a Maybe a to a function that takes an a and returns a Maybe a.
07:53:43 <delYsid> > (+) <$> Just 1 <*> Just 2
07:53:45 <merijn> c50a326: Well, suppose you have "checkUrl :: String -> Maybe URL"
07:53:46 <lambdabot>  Just 3
07:53:56 <delYsid> > (+) <$> Just 1 <*> Nothing
07:53:58 <lambdabot>  Nothing
07:54:06 <merijn> c50a326: When you call checkUrl on a String you won't know if it returns Nothing or not
07:54:10 <delYsid> > (+) <$> Nothing *> Just 2
07:54:12 <lambdabot>  Nothing
07:55:06 <Ariakenom> merijn: are there any good STM channels?
07:56:08 <merijn> Ariakenom: The STM channels in base already avoid the issue of broadcasting, extending further with STM channel support is on my to do list, but not anytime soon
07:56:52 <merijn> Ariakenom: Need to finish the regular channels first. Also working on better benchmarks so I can see what to optimise
07:57:03 <delYsid> c50a326: Try writing it as a nested case.  That makes it pretty clear why Functor, Applicative and Monad are useful for Maybe.
07:57:28 <Ariakenom> merijn: sounds good. just asking because you wrote plural "various (closable) STM channels"
07:58:56 <delYsid> > case Just 1 of { Nothing -> Nothing; Just x -> case Just 2 of { Nothing -> Nothing; Just y -> Just (x+y)}}
07:58:59 <lambdabot>  Just 3
07:58:59 <merijn> Ariakenom: You can even achieve that by just having a TVar Bool to check whether it's closed
08:00:14 <delYsid> c50a326: Writing it applicative style makes all the Nothing -> Nothing cases go away.
08:00:36 <greymalkin> I keep getting segfaults
08:00:48 <merijn> greymalkin: Impressive
08:01:24 <Ariakenom> merijn: yes stm makes things easier
08:01:48 <greymalkin> As far as I can tell, it's coming from readTMVar (at least that's the last exception shown with -xc)
08:02:12 <greymalkin> Specifically, the readTMVar in Async.withAsync
08:02:27 <barrucadu> greymalkin: Do you have a small self-contained example you can share?
08:02:40 <delYsid> > (\x y -> case x of { Nothing -> Nothing; Just x' -> case y of { Nothing -> Nothing; Just y' -> Just (x'+y')}}) (Just 1) (Just 2)
08:02:42 <lambdabot>  Just 3
08:03:38 <dmwit> merijn: There is another way to stop getChanContents' infinite recursion, by the way: if there are no other references to the Chan outstanding (this is sufficient but not necessary). For example:
08:03:45 <dmwit> % newChan >>= getChanContents :: IO [()]
08:03:50 <yahb> dmwit: [Timed out]
08:04:15 <dmwit> Eh, try it in ghci or a compiled program. You'll see `Exception: thread blocked indefinitely in an MVar operation`.
08:04:32 <merijn> dmwit: That's not a particularly clean way of finishing a finite list
08:05:06 <barrucadu> dmwit: Though, the docs say you shouldn't rely on that
08:05:38 <dmwit> merijn: Demanding cleanliness sounds like moving the goalposts to me. =)
08:07:01 <greymalkin> barrucadu: Unfortunately, I have no way of boiling it down.
08:07:43 * dmwit . o O (<merijn> I didn't say "clean" but I did say "sensible". <dmwit> DRAT)
08:07:44 <greymalkin> It's a relatively massive conglomeration of REST calls, WebSockets, STM, and threads.
08:08:45 <mpickering> What's the difference between shell and proc in System.Process? It seems it's not just "proc s args = shell (s ++ " " ++ args)"
08:09:07 <merijn> mpickering: The difference between the "system" and "execve" syscalls
08:09:28 <dmwit> mpickering: Without looking at the docs, my guess would be: `shell` invokes a shell to do shell-style parsing of the string you give it. `proc` just stuffs its arguments directly in the argument list without any parsing at all.
08:09:30 <merijn> mpickering: Shell, as the name implies, literally passes your commandline to the default shell
08:09:33 <greymalkin> But I'm going to start by sharing the same TLS manager, which I'm not currently doing.
08:09:54 <merijn> mpickering: Whereas proc (like execve and friends) directly calls the target binary
08:10:14 <dmwit> mpickering: So e.g. `proc "foo" ["*"]` would hand the program `foo` a literal string containing the character '*', whereas `shell "foo *"` would call a shell to expand `*` into a list of all the files in the CWD, then pass those each as arguments to `foo`.
08:10:30 <mpickering> ok, it seems that calling`nix-shell` with `proc` doesn't really work
08:10:36 <mpickering> ok
08:10:43 <merijn> dmwit: That's why I wrote the imminently more sensible and cleaner: https://hackage.haskell.org/package/broadcast-chan-0.2.0/candidate/docs/BroadcastChan.html#v:getBChanContents :)
08:12:40 <merijn> Now I just need to make my last remaining bugfix suck less donkey balls :)
08:12:53 <maerwald> merijn: afais, they cause the same syscall
08:13:36 <maerwald> http://hackage.haskell.org/package/process-1.6.4.0/docs/src/System.Process.Posix.html#commandToProcess
08:13:53 <maerwald> and then that gets mangled somewhere else
08:14:35 <dmwit> maerwald: That's okay, `system` isn't even a syscall in the first place. merijn was telling a pedagogically-sound lie.
08:15:21 <merijn> I suppose execve isn't technically a syscall either >.>
08:15:24 <greymalkin> Are there any guidelines about how long to leave an HTTP.Conduit Manager open? I don't know if it needs to be closed regularly or not.
08:17:12 <maerwald> https://github.com/haskell/process/blob/36a3ad577e31e8c3336c7464b252fc2c9b01a20c/cbits/runProcess.c#L60 oh boy
08:17:17 <maerwald> that's what we call
08:17:32 <mpickering> I want to call `nix-shell --run "echo version" -p bash` but the error is `error: unrecognised flag '--run "echo version"'`
08:17:43 <maerwald> glad I mostly use the unix package and not process
08:17:53 <mpickering> My call to `proc` is `p3 = proc "nix-shell" ["--run \"echo version\"", "-p bash"] `
08:18:49 <barrucadu> mpickering: That's passing "--run \"echo version\"" as a single argument, similarly for "-p bash"
08:19:03 <mpickering> lol I found something that works. `p3 = proc "nix-shell" ["--run", "\"\"echo version\"\"", "-p bash"] `
08:19:13 <dmwit> mpickering: You want... yes that.
08:19:14 <barrucadu> There's no need for the quotes
08:19:37 <barrucadu> ["--run", "echo version", "-p", "bash"]
08:19:40 <dmwit> mpickering: In fact you probably want `proc "nix-shell" ["--run", "echo version", "-p", "bash"]`.
08:19:43 <mpickering> so there isn't
08:20:02 <dmwit> I'm honestly a bit surprised that `"-p bash"` worked how you want it to.
08:20:06 <dmwit> (Maybe it didn't!)
08:20:32 <mpickering> I think that bit does work
08:20:54 <mpickering> as you might expect, my actual command is more complicated
08:20:56 <mpickering> thanks all
08:25:15 <delYsid> I have to admit, I don't get how partial application and composition work together.  I know the resulting type of map.map, but I cant explain to myself how that actually works.  unary function composition is straightforward, but what does actually happen when I compose binary functions?
08:25:39 <merijn> delYsid: All functions are unary :)
08:26:03 <delYsid> merijn: Yeah, I know, but that doesnt help in that case
08:26:07 <merijn> delYsid: Keep in mind that "map :: (a -> b) -> [a] -> [b]" is identical to "map :: (a -> b) -> ([a] -> [b])"
08:26:51 <merijn> delYsid: "(map . map) f" is equivalent to "map (map f)", yes?
08:27:02 <cocreature> :t (.)
08:27:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:27:19 <merijn> delYsid: Since "f.g" = "\x -> f (g x)"
08:27:24 <cocreature> you need to unify a -> b with x -> y -> ([x] -> [y])
08:27:38 <cocreature> eh that’s missing parenthesis
08:27:45 <cocreature> (x -> y) -> ([x] -> [y])
08:27:54 <cocreature> so a = x -> y and b = [x] -> [y]
08:28:15 <cocreature> therefore the first argument has to be of type ([x] -> [y]) -> c
08:28:56 <cocreature> now unify (p -> q) -> ([p] -> [q]) with ([x] -> [y]) -> c and you get p = [x], q = [y] and c = [[x]] -> [[y]]
08:29:18 <delYsid> merijn: oh, the f of the outer map is actually [a] -> [b], I think I get it now
08:32:12 <delYsid> woah, this has to settle, but I feel like I just cracked a pretty important nut.
08:34:16 <delYsid> I so love partial application.  I miss it in every other language since I dicovered the concept with Haskell. many years ago.
08:36:16 <c_wraith> I knew of partial application long before I knew about Haskell. shortly before I learned Haskell, I actually asked someone if the language had automatic currying. I didn't understand his laughter until he finally stopped an explained it to me.
08:36:53 <c_wraith> *and
08:37:04 <maerwald> what was so funny about it?
08:38:16 <c_wraith> you know who the language was named after?
08:38:20 <maerwald> yeah
08:38:49 <maerwald> I wouldn't expect anyone to know though, so yeah
08:39:13 <delYsid> I got a taste of it when playing with lisp, but it is a lot more interesting ina language that actually supports it first-class.
08:39:38 <c_wraith> he didn't think it was a bad question. just that it would have been really ironic if it didn't have currying.
08:55:18 <quicksilver> FWIW, I disagree
08:55:26 <quicksilver> haskell doesn't have automatic currying
08:55:40 <quicksilver> no part of haskell automatically converts functions into a curried form
08:56:17 <quicksilver> it's just that functions are either "always" or "conventionally" written in curried form
08:56:33 <quicksilver> (depending whether or not you consider it reasonable to equate tuples with multiple arguments)
08:57:55 <maerwald> quicksilver: I disagree, you can write functions in both curried and uncurried form.
08:58:45 <quicksilver> if that is your view, I don't see why you'd disagree with what I said.
08:58:56 <maerwald> just pitching up the nitpicking
08:59:40 <quicksilver> it sounds like you probably take the view that (a,b) -> c is the type of an uncurried function in haskell?
09:00:06 <berndl> Isn't automatic currying when you do e.g. (2+) or (+2) ?
09:00:20 <maerwald> quicksilver: sure
09:00:25 <quicksilver> I don't think so. I think that's a form of partial application, berndl.
09:00:33 <berndl> Ah, OK.
09:00:51 <quicksilver> maerwald: ok so then I would say "functions are conventionally written in curried form, but can be written with multiple arguments"
09:01:13 <quicksilver> the contrary view is that a function with a type which looks like (a,b)->c has only one argument (which is a tuple).
09:01:27 <quicksilver> if you take that view, then you have no choice - all functions are curried, and multiple arguments aren't possible.
09:01:34 <quicksilver> they're both consistent it's just about naming stuff.
09:01:59 <quicksilver> but in *neither* of those choices of naming things do you get anything I would call "automatic currying".
09:02:08 <quicksilver> I fear I'm being pointlessly pedantic.
09:02:10 <maerwald> great, now we have dissolved any possible consensus :)
09:02:18 <glguy> I agree
09:08:46 <coldpresent> why does vim's % key binding not work inside expressions with lambdas?
09:08:56 <coldpresent> it gives weird behavior, like jumping to the wrong paranthesis
09:09:57 <coldpresent> if \(, does vim not count the ( after \ as a bracket?
09:27:19 <sternmull> Is there a common way to evaluate a sequence of "IO (Maybe a)" actions until the first returns nothing? Explicit recursion is the best i have right now. But i bet there is a library function that makes this a oneliner.
09:28:53 <byorgey> sternmull: so you want  [IO (Maybe a)] -> IO [a] ?
09:28:55 <dminuoso> sternmull: Do you perhaps mean to use `MaybeT IO`
09:28:57 <benzrf> sternmull: you want https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html
09:29:01 <benzrf> haha jinx
09:29:30 <benzrf> anyway that'd be sequence on MaybeT IO i think
09:29:38 <byorgey> no, it isn't
09:29:48 <byorgey> sequence on MaybeT IO  will fail if any of the subcomputations fail
09:29:52 <sternmull> but isn't that return Nothing unless all return Just?
09:30:00 <benzrf> oh crap you're right
09:30:13 <benzrf> oops
09:31:03 <byorgey> sternmull: I don't know of any library function that will do this as a oneliner.  Intuitively, it is fundamentally interleaving IO and Maybe effects.  Any generic library functions are going to work with the effects separately.
09:32:13 <pavonia> sternmull: Have you looked at monad-loops?
09:32:42 <sternmull> never came across something like that
09:32:45 <byorgey> actually I don't even know of a library function [Maybe a] -> [a]  which gives you all the a's until the first Nothing.
09:33:06 <sternmull> byorgey: Yeah, hoogle also dosn't know one.
09:33:19 <byorgey> but even if you had one (call it untilNothing), it wouldn't help: you could do   fmap untilNothing . sequence   but that's wrong since it runs *all* the IO computations and then throws away the results after the first Nothing.
09:33:29 <sternmull> ah, wait. At list not if IO is involved.
09:33:36 <sternmull> list = least
09:33:56 <pavonia> There actually is whileJust
09:34:23 <byorgey> pavonia: where is that from?
09:34:32 <pavonia> monad-loops
09:36:04 <sternmull> i basically wondered if there is a general pattern to repeat an IO action and collecting its results until a condition for its result is met. Much like a while-loop in an imperative language that appends inputs to a list.
09:36:06 <dminuoso> :t filterM
09:36:08 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
09:36:19 <merijn> @hackage monad-loops
09:36:20 <lambdabot> http://hackage.haskell.org/package/monad-loops
09:36:22 <dminuoso> :t untilM
09:36:23 <lambdabot> error:
09:36:23 <lambdabot>     • Variable not in scope: untilM
09:36:23 <lambdabot>     • Perhaps you meant ‘until’ (imported from Prelude)
09:36:30 <merijn> sternmull: See that package :)
09:36:39 <byorgey> sternmull: ah, you want  IO (Maybe a) -> IO [a],  not  [IO (Maybe a)] -> IO [a]
09:37:07 <byorgey> sternmull: in that case I think 'whileJust' from monad-loops is exactly what you want
09:37:50 <sternmull> merijn, byorgey: Thanks, looking at it.
09:44:48 <spietz> can't lens do that using something like traverseOf?
09:54:03 <dminuoso> Oh yeah. Arrows do-notation with opaleye. This is.. weird?
09:54:07 <cocreature> spietz: what exactly loop until a condition is met? that doesn’t really sound like a traversal to me
09:54:15 <dminuoso> First time Im seeing these in the field.
10:04:18 <sternmull> i always feel pretty lost when i have to implement non-trivial loops with Haskell. Things that are easily expressed with nested while/for-loops in imperative languages often hard to figure out and at the end look very heterogeneous and make my code hard to read.
10:05:12 <int-e> :t forM_
10:05:13 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
10:05:19 <sternmull> is there a small set of general building blocks that make it easy to map imperative code like that to Haskell?
10:06:15 <sternmull> int-e: But forM can't abort the iteration early.
10:06:42 <sternmull> same for mapM, sequence etc.
10:07:09 <Rembane> sternmull: What about these? https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
10:07:19 <Rembane> sternmull: Will they help you to do what you want?
10:08:38 <sternmull> Rembane: I was pointed to that here a few minutes ago and it helped me to solve my current problem. But i am not sure if this will be enough to also solve all my future problems.
10:09:48 <Rembane> sternmull: I see. I was AFK then. It is hard to anticipate all your future problems, if you check back here we can throw more links at you. :)
10:10:41 <Rembane> sternmull: In my experience monad-loops solve the most of my looping problems. And when it doesn't I write a custom recursive function.
10:10:56 <mnoonan> sternmull: you can get early-failing behavior through ExceptT e m, too
10:11:01 <sternmull> It feels very strange to me that primitive operations like conditional loops require a bunch of library functions. I also tend to forget what function i have to use in all the situations (map/for{M,}{,_}, sequence, filter, ...).
10:11:17 <mnoonan> sternmull: maybe they aren't as primitive as you would think :)
10:13:11 <sternmull> mnoonan: It is probably a bit unfair complain that a functional language makes it difficult for me to implement imperative loops. But in practice this is a very common pattern that is often needed and should be easy to write and to understand.
10:13:41 <opqdonut> an imperative loop can be expressed as a tail-recursive helper function
10:13:45 <mnoonan> honestly, I have not found it to be so common a pattern as I had first expected
10:13:47 <opqdonut> with one argument per loop variable
10:14:01 <opqdonut> but yeah, you don't need it that often
10:14:36 <sternmull> opqdonut: But then i have to pass all the context down into that helper functions, which makes it more difficult to understand.
10:14:47 <opqdonut> nah
10:14:51 <opqdonut> use a where or a let
10:14:55 <opqdonut> so you can use all the context
10:15:06 <opqdonut> you merely need one argument for every variable you _update_ in the loop
10:15:47 <opqdonut> and this pattern can express some things _better_ than a loop
10:15:57 <opqdonut> you can have multiple mutually recursive functions and encode a state machine
10:19:12 <sternmull> opqdonut: I wrote this https://pastebin.com/vre1mKVS, where i involuntarily had to pass "it" as an argument. Could i have avoided that?
10:19:44 <opqdonut> yeah, use a let
10:21:00 <opqdonut> like do: it <- foo; z <- bar; let go Nothing = ...; go (Just x) = ... in go z
10:21:22 <dmwit> sternmull: Turn this around: I find it quite exceptional that Haskell has a way to create new looping constructs just by writing functions. Try to think of other languages where for loops are a function call and not built-in primitives.
10:21:22 <opqdonut> (the in for the let is actually optional since you're inside a do-block, but I'd use it anyway in this case)
10:24:32 <dmwit> That said, the API of this thing you appear to be interacting with is very un-Haskell-ic, which is probably a big part of your problem.
10:24:34 <sternmull> opqdonut: Thanks! I was sure i was missing something but for some reason i don't really think about the let expression.
10:25:13 <dmwit> In most cases, where other languages would use an iterator with a type like `(s, s -> (a, Maybe s))`, Haskell just uses `[a]`.
10:26:20 <mnoonan> sternmull: ahh, I'm a little less surprised now that I see what you're doing. It looks like text-icu is just a thin wrapper around libicu, so it isn't exactly idiomatic
10:27:13 <sternmull> dmwit: Yes, i am aware that the ICU API is highly imperative and IO heavy. But that only made me more curious how i can use it within Haskell.
10:27:28 <sternmull> mnoonan: Yep.
10:27:39 <sternmull> but that only makes it more interesting :)
10:53:17 <Ariakenom> are there any guidelines around order of arguments? "putMVar :: MVar a -> a -> IO ()" looks flipped to me
10:54:52 <Garmy> https://wiki.haskell.org/Parameter_order ?
10:55:04 <sternmull> i think the arguments are often in an order that allows effective use of partial application
11:00:41 <Ariakenom> Garmy: thanks. does still look flipped after reading those rules. I had to flip it for my >>= and traverse usage but maybe the other way is more common
11:05:43 <joe616> /close
11:06:20 --- mode: glguy set +v dmrd_
11:07:08 --- mode: glguy set -v dmrd_
11:17:33 <Ariakenom> but ... it compiled ... :(
11:26:22 <Athas> Offhand, can anyone here think of a compiler for a functional language that does loop/block tiling?
11:30:30 <Ariakenom> oh my thread didn't have time do do anything when the main thread quit. why does it do that?
11:33:04 <cocreature> Ariakenom: because that’s how GHC behaves, if the main thread exits everything dies immediately
11:33:16 <Ariakenom> that's not a why answer :)
11:33:18 <cocreature> if you don’t want that you have to wait for other threads to terminate (e.g. using the async lib)
11:33:20 <Ariakenom> although not doing that would have been worse in this case .. good thinking!
11:33:40 <Ariakenom> I know. But why
11:34:54 <cocreature> because you can recover the behavior where the main thread waits using a library (e.g. async) so it makes sense to have the primitive (i.e. forkIO) be as simple as possible
11:35:08 <shachaf> @where+ fplunch https://fplab.bitbucket.io/posts.html
11:35:09 <lambdabot> Good to know.
11:35:17 <shachaf> In case anyone was wondering where those posts went!
11:35:34 <geekosaur> that's not really ghc as such. the proble is thatthreads are owned by processes, on both windows and posix. if the process goes away, all its threads must as wel
11:36:00 <Ariakenom> ghc threads aren't OS threads
11:36:01 <geekosaur> you can to soem extent deal with this y treating the main thread as a subthread… whichc auses problems with likage to C libraries that use thread-local state and assume the main thread is shared state
11:36:15 <geekosaur> btu they have to run in OS threads at some point
11:36:37 <merijn> Athas: Besides the obvious SAC answer?
11:36:44 <geekosaur> even the "non-threaded" runtime uses OS threads; it just dosn['t use them for user-defined Haskel "threads"
11:37:45 <geekosaur> in particualr, most opengl implementations don't work if not run in the main thread
11:37:49 <eacameron> Is it possible for a GC run to be delayed when a system is under extreme load? I'd imagine that GC must be scheduled in just like any thread work (OS threads or not)
11:38:05 <Athas> merijn: ah, yes, I see it has something.
11:38:22 <Ariakenom> geekosaur: yes but all that means is that the main lang-thread has to run on the main os-thread
11:38:22 <eacameron> I have a process that spiked memory when the system was under extreme load, but I can't get it to spike memory under normal load.
11:38:31 <Ariakenom> not that it has to be the main os-thread
11:38:32 <geekosaur> gc isn't so much scheduled as evoked whenebver a thread tries to alocate. there is a timer tick, btu that just sets a flag that si checkd when soemthing allocates
11:38:46 <fresheyeball> I have a weird one
11:39:06 <fresheyeball> I have a singleton like this `data Foo = Bar | Baz`
11:39:10 <geekosaur> which is also why non-allocating loops tend to be unnterruptible: interrutps likewise set a flag checked when smething allocates
11:39:15 <fresheyeball> and a GADT like this
11:39:20 <eacameron> geekosaur: Hm, so this could happen if the entire haskell app was not getting scheduled
11:39:48 <eacameron> After allocating a lot of memory or something?
11:39:54 <fresheyeball> data F (x :: Foo) where bar :: Foo 'Bar; baz :: Foo 'Baz; barBas :: Foo x
11:40:04 <cocreature> eacameron: maybe more load just boils down to more requests stacking up in your application?
11:40:16 <fresheyeball> now I add another constructor to Foo
11:40:19 <geekosaur> that would be my first guess
11:40:41 <fresheyeball> I need `BarBaz` to be either `Foo 'Bar` or `Foo 'Baz` but not the new constructor
11:40:42 <eacameron> cocreature: geekosaur: the load is actually not in my app itself. It's other processes
11:40:48 <geekosaur> more spawned worker threads not getting scheduled (see why thread pools exist), etc.
11:40:48 <fresheyeball> so I tried something like this
11:41:16 <fresheyeball> BarBaz :: ((x == 'Qux) ~ 'False) => Foo x
11:41:17 <cocreature> eacameron: sure but if you have some kind of workqueue in your app and the rate of incoming tasks stays the same and your system is under higher load the size of that queue will increase
11:41:32 <fresheyeball> which looks right and compiles fine
11:41:42 <fresheyeball> but when using the BarBaz constuctor I get an error like this
11:42:03 <eacameron> cocreature: I guess that's the same kind of issue I was thinking of, except in terms of GC not getting a chance to run
11:42:08 <fresheyeball> Couldn't match type "'Bar == 'Qux` with `'False`
11:42:20 <fresheyeball> I would expect that to match!
11:42:38 <eacameron> cocreature: But I guess it wouldn't actually be garbage yet, is what your saying.
11:42:45 <eacameron> That's plausible.
11:42:46 <cocreature> eacameron: that doesn’t have anything to do with GC. you can’t GC your queue, you actually need to process it
11:43:05 <geekosaur> Ariakenom, the problem there is you can't always control the lifetime of process-owned resources that way. It is possile to have "lang-threads" still rning, "main thread" "exited"/waiting for them… and libcd cleanup running, such that some resources have gone away that those threads need
11:43:15 <eacameron> cocreature: yeah that's possible
11:43:24 <geekosaur> it's all rather tricky and the current design came from tripping over the sharp edges
11:44:06 <Athas> merijn: do you know if they wrote a paper about that?  I can find some references to tiling in one file in my ~2012-era SaC code, but not that it is used anywhere.
11:44:16 <Athas> (But I find the code completely inscrutable anyway.)
11:44:46 <cocreature> fresheyeball: which version of (==) are you using here?
11:45:04 <geekosaur> and every solution has its own problms. ghc uses this one and it works well for hiow ghc ./ haskell s generally used. js uses a different one that works reasonably well for that… but often assumes things forced on it by usually being a langauge hostd in a browser; some of node.js's problems come from those assumptions
11:45:44 <merijn> Athas: Dunno about papers, but Artem Shinkarov's (spelling modulo diacritics) was about inferring optimal array layout for loop blocking, then propagating that out so that all arrays are laid out for optimal inner loops, so perhaps that has some pointers?
11:45:58 <Ariakenom> geekosaur: this seems like a good why, thanks. what's libcd cleanup?
11:45:58 <merijn> Athas: I can try asking Clemens tomorrow if he has any pointers
11:46:29 <geekosaur> "libc cleanup" (this keyboard is still harshing my buzz). C's own runtime
11:46:37 <fresheyeball> cocreature: Data.Type.Equality
11:46:48 <geekosaur> I keep typing faster than the keyboard can keep up with
11:47:54 <merijn> geekosaur: Are you typing on a potato? o.O
11:48:11 <geekosaur> no, just a cheap usb keyboard that has trouble keeping up
11:48:37 <cocreature> fresheyeball: do you have some minimal example to reproduce that error?
11:49:33 <Ariakenom> allright, I can see how this way stays furthest from sharp edges
11:50:38 <texasmynsted> if I am in a cabal sandbox, I add a dependency to by cabal file and then build and the dependency is not found. Then all I should need to do is cabal install --only-dependencies right?
11:51:02 <merijn> texasmynsted: Right. Although you may wanna consider switching to new-build over sandboxes
11:51:03 <texasmynsted> or maybe not even that
11:51:04 <geekosaur> well, stay away from the ones that usually affect haskell. but can trip over others, for example the one your'e complaining about
11:51:16 <merijn> texasmynsted: Because new-build is pretty much 100% superior to manual sandboxes
11:51:19 <texasmynsted> yeah. Will switch for next project
11:51:40 <geekosaur> there's no single soluton that addresses all of them; it's all tradeoffs adn youhave to pick the tradeoffs that fit your needs best and work around any that are left
11:53:58 <merijn> texasmynsted: It shouldn't really require any work or effort to switch, tbh. Just "cabal new-build" should work. If you wanna depend on local (modified) copies of packages you need a one line file, but that's it
11:54:12 <Ariakenom> eh, there's probably a best choice :p. I just wondered because I ran into it and saw someone ask yesterday as well
11:55:20 <fresheyeball> co https://hastebin.com/piyaridovu.rb
11:55:25 <fresheyeball> cocreature: ^^
11:55:52 <texasmynsted> thank you
11:55:59 <cocreature> fresheyeball: that compiles for me?
11:56:13 <fresheyeball> cocreature: what ghc are you on?
11:56:17 <cocreature> 8.4.3
11:56:56 <cocreature> interesting 8.2.2 fails
11:57:07 <fresheyeball> lame
11:57:15 <fresheyeball> I am on 8.0.2 because work
11:58:56 <fresheyeball> I get the error with 8.4.1 as well
11:59:14 <fresheyeball> https://hastebin.com/ogobelugap.coffeescript
11:59:53 <cocreature> I don’t have 8.4.1 (and using 8.4.1 is pretty silly when there is 8.4.3)
12:00:08 <fresheyeball> well like I said, in real life I have to make this work on 8.0.2
12:00:26 <cocreature> take a look at the docs in Data.Type.Equality “A type family to compute Boolean equality. Instances are provided only for open kinds, such as * and function kinds.”
12:00:36 <cocreature> you don’t have an open kind
12:00:48 <cocreature> so that’s just expected behavior with 8.0.2
12:01:07 <fresheyeball> *cranky face*
12:01:25 <fresheyeball> any suggestion?
12:01:37 <cocreature> not sure if you can write your own instances for that type family but you can definitely create your own type family
12:02:05 <cocreature> although in the long term, convincing work™ to upgrade is probably the saner choice if you want to use any of the somewhat modern type-level features
12:03:27 <fresheyeball> yeah making my own family did the trick
12:03:31 <fresheyeball> will make a note
12:07:59 <merijn> Bleh...GHC needs more ways to hook into the runtime's blocking functionality...
12:09:08 <merijn> I just want to block on two MVar's >.<
12:10:48 <c_wraith> when you want that, you probably really want STM
12:11:14 <merijn> c_wraith: I don't, because one thing is already fixed to be an MVar
12:11:22 <merijn> c_wraith: So that's a non-starter
12:11:51 <merijn> c_wraith: I also fundamentally disagree with everyone's knee jerk "you probably want an MVar"-response.
12:12:04 <merijn> There's nothing inherently unsafe or problematic about racing two MVars
12:14:51 <c_wraith> not inherently. but in practice, 99% of people who want that also want some stronger transactional properties and just haven't realized it yet.
12:16:21 <merijn> c_wraith: The problem is that you often already *have* MVar based stuff somewhere and if you want to integrate you need this functionality. Going to STM doesn't help, because now you're forced to spawn 1 thread per MVar you need to deal with and make life 1000% more complicated in terms of exception safety and introduce overhead
12:16:49 <merijn> c_wraith: The fact that *most* people should want STM is not a very good argument for making something that's otherwise safe and sensible impossible
12:17:30 <vilu> Hi, I'm actually running into this issue with Purescript but I guess the problem I have could be applicable to Haskell
12:17:32 <vilu> https://gist.github.com/vilu/199800172d827d9a546910f5ffc81e37
12:17:41 <merijn> Threads are cheap, but not free and needing at least 2 thread context switches for something isn't free either
12:17:41 <vilu> I have this do notation from a code example 
12:18:09 <vilu> I'm having a hard time understanding, what the actual monad is that I'm inside of.
12:18:10 <c_wraith> I dunno. "very few people want it and it's actually quite hard to get correct" is a pretty good reason for no one to step up and volunteer to do something.
12:18:37 <fresheyeball> vilu: 
12:18:38 <merijn> Although, at this point the exception safety part is the most worrying part
12:18:52 <vilu> On the one hand the H.liftAff is there, on the other hand H.get (which operates on state monad) is also there.
12:18:59 <fresheyeball> you are in the "H.HalogenM State Query () Output"
12:19:01 <fresheyeball> Monad
12:19:06 <c_wraith> yeah, exception safety is a *huge* deal
12:19:22 <c_wraith> and it's really subtle. I'm sure it can done, but it's hard.
12:19:25 <vilu> Okay, that's what I actually thought.
12:19:26 <merijn> c_wraith: tbh, I think the current exceptions implementation is completely fucked
12:19:28 <fresheyeball> vilu: oh wait no
12:19:31 <vilu> But that leaves me with even more questions
12:19:33 <fresheyeball> that makes no sense
12:19:36 <vilu> Oh no?
12:19:48 <fresheyeball> so a Monad must be of kind `* -> *`
12:19:56 <merijn> c_wraith: I have a vision of what I'd like to see, but I think it's to backwards incompatible to ever make it into GHC/the wider ecosystem
12:19:59 <fresheyeball> but (Aff :: * -> *)
12:20:12 <merijn> Which is rather demotivating in terms of working on it
12:20:16 <fresheyeball> so HalogenM must be an alias or a type family
12:20:23 <fresheyeball> that returns the actual monad
12:21:10 <c_wraith> I really dislike it when people use type aliases like that.
12:21:25 <c_wraith> it just ruins reasoning based on the syntactic form of the type.
12:21:30 <vilu> fresheyeball it is 
12:21:36 <fresheyeball> type HalogenM s act = HalogenM' s (act Unit)
12:21:56 <fresheyeball> newtype HalogenM' s act ps o m a = HalogenM (Free (HalogenF s act ps o m) a)
12:22:07 <fresheyeball> a type alias on a newtype on a damnit DeGoes!
12:22:08 <vilu> https://gist.github.com/vilu/6d7afd9c564f5caf01e1631c28c575a7
12:22:55 <fresheyeball> vilu: so the Monad is `HalogenM' s`
12:23:22 <fresheyeball> but you can only return something in `act` and even then, only with `Unit`
12:23:28 <fresheyeball> so given you earlier thing
12:23:55 <fresheyeball> oh god 
12:24:00 <fresheyeball> vilu: I am still wrong
12:24:04 <fresheyeball> because curry
12:24:26 <fresheyeball> you are in the `HalogenM' s act ps o m` Monad
12:25:07 <fresheyeball> some people solve problems by adding term level variables, Halogen does it by adding type level variables 
12:27:07 <vilu> Hehe, no worries. I thought I understood these things
12:27:48 <fresheyeball> yeah, and HalogenM is defined in terms of a Free Monad on the HalogenF functor
12:27:55 <vilu> I wanted to extract a method that does modifies the state in one way if the responseE is left and in another way if it's right.
12:28:08 <vilu> But I can't even figure out what the signature of that method would have to be for it to fit in there.
12:28:23 <fresheyeball> and its a UI library, so why not just stack abstraction on top of performance destroying abstraction?
12:29:33 <vilu> I do not know :) I didn't write it. So far I like the library besides when I dive into things I don't always understand things quickly :)
12:29:38 <vilu> or ever.
12:31:09 <Ariakenom> "Time as measured by the Earth." awfully specific for a Haskell package
12:31:33 <Ariakenom> what's a good action to get timestamps?
12:32:19 <sm> _o/  <- international signal for "send more timestamps"
12:34:02 <c_wraith> Ariakenom, I mean, that's what most time libraries are for. if they have solar/lunar relations and leap days/seconds and time zones and don't support relativity, they're basically only useful on earth.
12:34:03 * Ariakenom *confusion*
12:34:17 <c_wraith> Ariakenom, they just don't... say so.
12:35:55 <vilu> fresheyball, thanks for the help so far. Do you have any pointers on how to define a function that would fit in there I tried this "updateStateFromLoginRequest :: Either String LoginResponse -> H.HalogenM State Query () Output Aff" but it complained about being given Kind when expecting Kind -> Kind 
12:36:13 <Zipheir> "The extraterrestial behavior of the functions in this library is unspecified."
12:36:14 <vilu> Or, it might be the other way around I haven't yet deciphered all the error messages.
12:41:14 <geekosaur> c_wraith, tell me about it
12:42:12 <c_wraith> geekosaur, sorry, all I know is that all time libraries are bad and broken and no one should ever write any code that has to do with time. excuse me while I go fix this job scheduler.
12:42:16 <geekosaur> (have been working on a story. currently tracking timelines for 20 planets… using notional sunrise/sunset because nobody's time libs are set up for that)
12:42:32 <c_wraith> oh, nice.
12:42:40 <geekosaur> and "set up for that" iis itself tricky
12:43:00 <geekosaur> I knwo what's needed and basically refuse to enter that cesspool
12:43:16 <geekosaur> because it's a story, and nto worth it
12:45:41 <geekosaur> (timeline generator is in haskell, of course)
12:46:15 --- mode: glguy set +v humanoyd
12:46:41 <humanoyd> vilu: in the first gist you posted, note that eval is a natural transformation (the squiggly arrow), so you need something like "updateStateFromLoginRequest :: Either String LoginResponse -> HalogenM State Query () Output Aff ()"
12:48:38 <fragamus> https://gist.github.com/fragamus/588c2ccf7f04f4897cf62ed4842ed1eb
12:48:58 <fragamus> Hi I need some help with existentials
12:49:35 <fragamus> I call a function that returns a Some OneTwoThree
12:49:48 <fragamus> and OneTwoThree is a GADT
12:49:59 <Ariakenom> Does this behave timestamp-y? {a<-getPOSIXTime; threadDelay 1000000; b<-getPosixtime; pure (b-a)} should be almost 1?
12:50:24 <fragamus> and then I call a function to pattern match on the existential
12:50:38 <c_wraith> Ariakenom, that's what I'd expect, assuming 6 zeroes in that constant. (counting is hard)
12:50:43 <fragamus> It correctly determines which tag was used
12:51:00 <Ariakenom> c_wraith: ok
12:51:13 <Ariakenom> I'll be more demaning. it should be at least 1
12:51:18 <Ariakenom> demanding
12:51:21 <fragamus> but I can't manage to do anything with the data
12:51:50 <c_wraith> fragamus, you have to work within the context of the pattern match, and the type can't escape.
12:51:57 <geekosaur> Ariakenom, I thinkt he only ironclad guarantee is the secodn shoudl be greater tan the first. btu it's up to OS scheduling and on a highly loaded machinethe difference might be >1
12:52:09 <geekosaur> and on some RTOSes with POSIX-like interfces ti will occasioally be 0
12:52:13 <geekosaur> glah
12:52:32 <geekosaur> and some realtime OSes with POSIX-like interfaces, it will occasionally be 0
12:52:34 <merijn> Ariakenom: What are you trying to do?
12:52:42 <Ariakenom> threadDelay "There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified."
12:53:16 <Ariakenom> So I'm just wondering if that posix time is adjusted. I just didn't see it stated explicitly
12:53:37 <fragamus> c_wraith: the type can't escape from the pattern match?
12:53:44 <geekosaur> I wonder how carefully they verify that. btu I don't think there's a port of GHC to a realtime OS
12:54:21 <Ariakenom> then I claim the port is faulty and feel ok about it
12:54:26 <fragamus> what makes existentials better than an inert hunk of matter
12:55:00 <c_wraith> fragamus, you can move all logic that cares about the type into the pattern match.
12:55:00 <geekosaur> (the actual offset might be 0.999998 btu that will expose as 0)
12:55:11 <wroathe> Is there a way to strictly evaluate an expression and cache the result in GHCI? I've got a function I'm trying to get the idea of the performance of without factoring in the running time of building up it's input
12:55:32 <merijn> @hackage criterion -- wroathe 
12:55:32 <lambdabot> http://hackage.haskell.org/package/criterion -- wroathe
12:55:47 <wroathe> I've got a function that generates a large tree, and another function that computes it's depth. I'm trying to trace the running time of the function that computes it's depth
12:55:56 <wroathe> Yeah, Criterion is great, but it's a little heavy for what I'm trying to do
12:56:05 <fragamus> c_wraith: what if I want to, say, add the x and y on line 11 of my gist
12:56:21 <merijn> wroathe: You could deepseq the input and store it in a variable
12:56:24 <wroathe> I don't even plan on timing this, just want to be able to see if my implementation finishes as quickly as I think it should
12:56:36 <dmwit> wroathe: `let x = expensiveComputation` ?
12:56:37 <c_wraith> fragamus, can you link again?
12:56:44 <merijn> Also, for ghetto timing there is
12:56:47 <merijn> @hackage timeit
12:56:47 <geekosaur> note that ghci is a bad place to test that in general
12:56:47 <lambdabot> http://hackage.haskell.org/package/timeit
12:56:51 <fragamus> https://gist.github.com/fragamus/588c2ccf7f04f4897cf62ed4842ed1eb
12:57:24 <geekosaur> the bytecode backend doesn't support e.g. optimization, for reasons that are hard to fix
12:57:50 <Ariakenom> merijn: "What are you trying to do?" I'm doing a bad FRP implementation. And getting timestamp for frames
12:57:58 <geekosaur> so it can behave rather differently than compiled code. of course you could use -fobject-code
12:58:22 <geekosaur> tbh you probably want a finer grained time api than posix's
12:59:05 <wroathe> geekosaur: Yeah, but I'd be surprised if that made a difference when talking about something that runs in exponential time vs linear time over a tree with 500,000 nodes...
12:59:09 <c_wraith> fragamus, no way to do that. your GADT doesn't contain enough information to recover the type of a by matching on it.
12:59:26 <wroathe> geekosaur: But I'm no expert in compiler optimizations
12:59:37 <c_wraith> fragamus, in fact, that's not a GADT. it's an ADT written with GADT syntax
12:59:58 <geekosaur> wroathe, it can, because unoptimized might be O(soemthing other than 1) when optimization might find a way to maek it O(1), or otherwise better time complexity
13:00:10 <luqui> well we could just say "generalized GADT" to cover that case ;-)
13:00:16 <geekosaur> laziness allows some surprising tricks in that area
13:00:18 <c_wraith> fragamus, sorry, not even written with GADT syntax. I overlooked that detail entire.
13:00:22 <c_wraith> +ly
13:00:55 <c_wraith> fragamus, to recover types from a GADT, the constructors need to specify them.
13:01:00 <geekosaur> whch is why we often write tings that look O(horrid) but run fast when compiled
13:01:02 --- mode: glguy set +v zhaskell
13:01:32 <luqui> geekosaur: example?
13:01:33 <zhaskell> My compiled binary executable doesn't output to stdout is this normal?
13:01:38 <wroathe> geekosaur: Yeah, I'm looking forward to diving into the mysteries of GHC optimizations at a later date, but right now I'm just looking for a way to jury rig strict eval in GHCI
13:02:00 <merijn> zhaskell: How are you printing?
13:02:05 <wroathe> geekosaur: I get your point, but executing something in GHCI is still a reasonable exercise for the time investment
13:02:06 <c_wraith> wroathe, bind it to a variable then have ghci print it. done!
13:02:08 <geekosaur> luqui, list / stream fusion comes to mind
13:02:32 <luqui> that doesn't change the asymptotics though... right?
13:02:48 <geekosaur> looks like it ought to be slow O(n), compiles to a fast loop that;'s nearly O(1)
13:02:48 <jle`> zhaskell: sometimes haskell programs don't output to stdout
13:02:53 <merijn> luqui: Yes it does
13:02:55 <c_wraith> wroathe, binding to a variable will keep the evaluated version around, having ghci print it will evaluate it.
13:02:59 <jle`> for example, the program `main :: IO (); main = return ()`
13:03:01 <zhaskell> jle: my one does
13:03:05 <jle`> this will not output anything to stdout when run
13:03:18 <wroathe> c_wraith: What I'm trying to do is something like this: treeDepth $ gameTree emptyGrid O where the result of gameTree is precomputed
13:03:18 <fragamus> c_wraith lemme attempt a fix
13:03:27 <geekosaur> ifyou throw it at a long enough list you migth start to notice the n
13:03:28 <merijn> luqui: Note that, contrary to popular misinterpretation, you don't have to change the complexity class to be asymptotically faster
13:03:31 <wroathe> c_wraith: Simply printing the result doesn't fix that
13:03:42 <jle`> zhaskell: are you saying that your program is intended to write to stdout, but the executable doesn't reflect this?
13:03:59 <jle`> it's hard to diagnose this without looking at the program
13:04:04 <luqui> merijn: that sounds tautologically false to me.  there must be some different usages of words there... like maybe "asymptotically faster" means something that i don't know about
13:04:17 <merijn> luqui: The strict definition of "f is asymptotically faster than g" is "there is an 'n' such that for all x > n the runtime of f(x) < g(x)"
13:04:19 <jle`> but yeah, normally if your haskell program is written to write to stdout, then the compiled binary will output to stdout
13:04:23 <zhaskell> merijn:  The stdout comes from the logger provided by Persistent. So when the app connects there should be an initial bit of output
13:04:30 <c_wraith> wroathe, let y = gametree emptygrid 0
13:04:35 <geekosaur> zhaskell, there are some speed bumps there that don't necessarily invlve haskell. windows requires a program to be marked specially to have console access, for example
13:04:41 <c_wraith> wroathe, then print y
13:04:48 <geekosaur> otherwise stdout just disappears
13:04:50 <jle`> zhaskell: does 'putStrLn "hello"` work?
13:04:56 <merijn> luqui: If the complexity clas of f and g is different (i.e. O(n) vs O(log n)) this is obviously true, which is the classic example everyone thinks of)
13:05:05 <zhaskell> its a docker image running on fedora
13:05:08 <c_wraith> wroathe, ie, name and share the part you dont want re-evaluated
13:05:18 <luqui> merijn: well that's a lame definition.   if you removed one instruction from an algorithm you would get an "asymptotically faster" algorithm
13:05:21 <merijn> luqui: However, if f and g are both O(n) but f is a constant factor faster than g, than it's still asymptotically faster than g
13:05:22 <luqui> even if it was a noop
13:05:29 <geekosaur> and if you link to any gui functions, that flag gets turned off
13:05:30 <zhaskell> jle- Ill try that
13:06:04 <dmwit> merijn: Where have you seen that definition?
13:06:09 <luqui> and in that case, colloquially,. i would want to say "faster, but asymptotically equivalent"
13:06:40 <merijn> dmwit: Complexity theory class, but I think last time I got into an IRC flamewar about this I think I managed to find it in CLSR too
13:06:41 <dmwit> It certainly doesn't match anything I've ever seen. I've tried to find something on Wikipedia about it, and the closest I got was Asymptotically_optimal_algorithm, which *is* about complexity classes.
13:06:51 <merijn> dmwit: But my copy of CLSR is in the office, so I can't look it up
13:07:25 <luqui> anyway, putting that aside, list fusion doesn't *change the complexity class*, right?
13:07:42 <geekosaur> usually not, but it can depend on what's getting fused.
13:07:48 <wroathe> c_wraith: Oh, that worked perfectly actually
13:07:51 <merijn> Wait, I screwd up that acronym, CLRS
13:07:52 <wroathe> c_wraith: Thanks!
13:08:03 <c_wraith> wroathe, you're welcome
13:08:06 <wroathe> I just assumed GHCI was constantly re-evaling that
13:08:07 <geekosaur> O(n**2) sometimes can turn into O(n), iirc
13:08:40 <luqui> hmm.  yeah i guess if you can fuse a left-nested series of appends or something...
13:09:04 <geekosaur> btu yes, mostly what it does is reduce consants to the pointthat O(n) runs faster than a naive O(log n) with a large constant factor
13:09:11 <c_wraith> wroathe, it's a little subtle. if a "constant" is type class polymorphic, it can get re-evaluated because ghci makes it a function behind the scenes.
13:09:24 <luqui> anyway "we write code that looks asymptotically horrid but ends up being fast" is not something i often experience
13:09:34 <luqui> so i'm curious about examples...
13:10:15 <c_wraith> wroathe, but if a value is monomorphic, it will be shared across all places where the same binding is shared
13:10:31 <zhaskell> weird so main = putStrLn "boo"      prints to Stdout
13:11:47 <jle`> zhaskell: ah okay, it might be a part of how the persistent logger wqorks then
13:12:42 <cocreature> my guess would be that it might be a buffering issue
13:12:47 <zhaskell> Yes I think you are right
13:13:50 <wroathe> c_wraith: Do you have some documentation on hand that defines "type class polymorphic"?
13:14:16 <merijn> zhaskell: Wait, persistent logging? I think a lot of that defaults to NoLoggingT unless you change it
13:14:24 <merijn> zhaskell: Which just ditches any log messages
13:14:47 <merijn> zhaskell: You need to actually have a MonadLogger instance logging to somewhere in your transformer stack
13:16:22 <zhaskell> Sorry be back online later have to go
13:17:55 <wroathe> geekosaur: I'm not saying this will always work, or that it's representative of the actual numbers I'd see with highly optimized code, but this gave me a reasonable estimate for the amount of time that's being spent actually constructing the data structure...
13:17:58 <wroathe> *Main> treeDepth y 9 (16.47 secs, 11,116,789,864 bytes)
13:18:03 <wroathe> *Main> treeDepth y 9 (0.38 secs, 178,352,496 bytes)
13:18:36 <shachaf> I'm pretty skeptical of optimizations that make a big difference and also fire unpredictably.
13:18:56 <dstolfa> shachaf: so... almost all LLVM and GCC optimisations? :-)
13:19:11 <dstolfa> heuristics everywhere!
13:19:34 <shachaf> Some of them are pretty predictable.
13:19:48 <shachaf> The unpredictable ones... Well, yes, use with care.
13:20:07 <shachaf> In particular I'm skeptical of being told to rely on an optimization when it might work or might not work, who knows.
13:20:12 <dstolfa> shachaf: well, mostly ones related to dead code elimination and the likes. register allocation can be unpredictible depending on the instruction scheduling, which depends on alias analysis, which is pretty painful
13:20:16 <dstolfa> anything vectorisation-based is also nasty
13:20:55 <merijn> dstolfa: That's why we have constexpr-if now!
13:21:08 <shachaf> Auto-vectorization can indeed be pretty fishy if you rely on it.
13:21:27 <dstolfa> for that matter, there's anything CFG-related with deep polymorphism that's painfully unpredictible and llvm does it backwards, while gcc does it forwards (optimising SCCs that is)
13:21:34 <dstolfa> shachaf: yeah, especially the polyhedral bits
13:21:43 <dstolfa> well, polytope in reality
13:22:46 <shachaf> Anyway even vectorization is only a constant factor improvement.
13:23:18 <shachaf> But to tell me "write code that looks quadratic and hope the compiler recognizes a pattern and turns it linear" is asking for a lot.
13:23:22 <dstolfa> shachaf: sure, but still awfully unpredictible, especially when padding is required and depends on alias analysis :-)
13:23:30 <dstolfa> shachaf: yeah, that's also bad
13:23:42 <shachaf> Yes, aliasing rules are no fun.
13:23:43 <dstolfa> a compiler does a lot, but it does so with heuristics for the most part
13:23:44 <fool> what's the typeclass for stuff with which you can do [x..y] ?
13:23:53 <merijn> fool: Enum
13:23:56 <shachaf> :t \x y -> [x..y]
13:23:58 <lambdabot> Enum a => a -> a -> [a]
13:24:06 <shachaf> That's the one.
13:24:59 <fool> it's not working in reverse order :(
13:25:05 <fool> nevermind :)
13:26:47 <geekosaur> for that, you need
13:26:53 <geekosaur> > [4,3..1]
13:26:55 <lambdabot>  [4,3,2,1]
13:27:01 <geekosaur> aka enumFromThenTo
13:27:22 <geekosaur> without that it will always use succ
13:28:05 <geekosaur> because otherwise the compiler woudl need to understand the intent of every type with an Enum instance, including user defined ones with custom instances
13:29:16 <fool> have you good insights in writing guis with haskell ?
13:29:28 <geekosaur> it isn't and can't vbe general, the compiler doesn't have a mathematician on call or an interface to OEIS built in or etc
13:29:50 <fool> geekosaur: talking about guis ?
13:30:06 <geekosaur> no, still answering the questionI had been answering
13:30:09 <Ariakenom> my event joining now "works" because timestamps :D
13:30:12 <fool> ho yeah
13:31:07 <Ariakenom> "works" because I'm sure it's still racey
13:31:28 <noidedsuper> Quick question about newtype deriving: I have a type `Backend` which is parameterized over three types (so it's `data Backend a b c = ...`). I also have a type newtype ChannelBackendT s r t m a = 
13:31:28 <noidedsuper>         ChannelBackendT { getChannelBackendT :: ReaderT (Backend s r t) m a }. Is there any way to make GHC derive the functor, applicative, monad, etc. instances for me for that?
13:32:10 <phadej> noidedsuper: GeneralizedNewtypeDeriving
13:32:35 <noidedsuper> I tried that, it apparently can't make the derived instances for me (somehow)
13:32:46 <Ariakenom> what do you call semigroup's <>? append?
13:34:13 <fool> mappend
13:34:28 <fool> (for the monoid instance)
13:34:43 <fool> (suppose it's the same for semigroup from yesterday's discussion
13:35:14 <jose_zap> I call it append
13:36:02 <geekosaur> the Semigroup class calls it sappend, iirc
13:37:11 <noidedsuper> In an abstract algebra sense I've heard people call the normal group operator "times" or "dot" on occasion 
13:39:06 <dstolfa> noidedsuper: people often call it multiplication as well
13:39:41 <dstolfa> i just call it an automorphism set when talking in mathematical terms
13:39:52 <dstolfa> if people look at me angry, i say the group's multiplication operator
13:43:59 <noidedsuper> Also, it turns out that "DeriveAnyClass" was breaking "GeneralizedNewtypeDeriving". Whoops.
13:44:08 <noidedsuper> At least I can delete these ugly handwritten instances
13:48:11 <geekosaur> there's an extension for that in 8.4+ iirc
13:48:29 <geekosaur> DerivingVia lets you say which one should be used
13:52:39 <phadej> DerivingStrategies
13:54:10 <fool> is there a #stack channel ?
13:54:25 <geekosaur> #haskel-stack
13:54:26 <geekosaur> er
13:54:31 <geekosaur> #haskell-stack
13:55:19 <geekosaur> "stack" is just a bit too generic when everyone and their pet moose calls their web framework a "stack"
13:55:36 <Tuplanolla> Should've called it Smack.
13:55:44 <tdammers> it's a terrible name that way
13:55:57 <geekosaur> could be worse… "go"
13:56:13 <fool> seems dead
13:56:28 <fool> i cannot import System.Random
13:56:32 <tdammers> slvkjsfdlakf would have been a better name
13:56:41 <geekosaur> you need the "random" package
13:56:42 <fool> I assumed I have to add a specific dependency in package.yaml.
13:56:47 <fool> yes, I added it
13:56:55 <geekosaur> just because it's in the System namespce doesn't mean it's in base
13:57:49 <fool> you lost me :)
13:58:05 <fool> I mean I added the dependency to my stack.yaml file
13:58:19 <Tuplanolla> Add it to the Cabal file too, fool.
13:58:31 <fool> but isn't the cabal file automatically generated ?
13:58:40 <Tuplanolla> No.
13:59:10 <jose_zap> fool if you use package.yaml it is
13:59:48 <fool> i'm using package.yaml ? no i'm not using it
13:59:57 <fool> actually i'm not using it. Maybe I should ?
14:00:00 <fool> I think I should
14:00:15 <fool> yes i'm using it. what a fool
14:00:21 <glguy> No, it's better not using package.yaml and working with the .cabal file directly
14:00:28 <fool> are you sure ?
14:00:33 <glguy> I am!
14:00:46 <Ariakenom> threadDelay and timestamps being different types is somewhat annoying (Int and POSIXTime)
14:01:02 <Ariakenom> *using different types
14:01:07 <fool> ha now it works
14:01:11 <fool> glguy: but why ?
14:02:07 <glguy> The package.yaml is less compatible with the rest of the ecosystem, and is just an extra indirection for producing the stuff that needs to go in the .cabal file, is an extra thing to learn, limits who can help you with issues, uses yaml
14:03:05 <fool> ok
14:05:28 <geekosaur> package.yaml works in simple cases to autogenerate a cabal file and I think some other things. it's a bit too easy to confuse the cabal file generator, though
14:06:35 <geekosaur> sometimes you want to start with it, generate the basic cabal file once, then remove package.yaml and use the cabal file thereafter
14:12:20 <fool> ok
14:12:55 <fool> what's the interest of clojure compared to haskell ?
14:13:42 <fool> i'm reading this https://aphyr.com/posts/340-reversing-the-technical-interview and it seems interesting and probably easier to use that language 
14:13:48 <fool> to do fancy special stuff
14:13:52 <hodapp> some people like Lisp, dynamic typing, and the ability to use the JVM
14:14:29 <fool> the jvm is slow :]
14:14:40 <fool> (startup time are actually)
14:15:23 <benzrf> fool: they are very different languages
14:15:28 <benzrf> it's an odd question to ask
14:15:42 <fool> benzrf: i suspect they are
14:16:28 <fool> the real question would be: what would use clojure for that you wouldn't do with Hask ?
14:16:38 <fool> would -> would you
14:16:47 <fool> more close to my original question
14:24:00 <fool> nvm
14:24:32 <Tuplanolla> I wouldn't interface with Java libraries, fool.
14:24:42 <Tuplanolla> That's about all I can think of.
14:25:14 <phadej> they are both very expressive higher level languages
14:25:36 <phadej> so an expert in clojure will be more productive that intermediate haskeller, and vice versa
14:28:43 <phadej> and as for FP thingies, experts in both have similar ideas how to structure applications etc. the ideas happen to look quite different, as it's silly not to use language strenghts
14:33:49 <ab9rf> the universal rule when deciding on a language to use is that you should use the language which which you (the developer or developer team) can implement the needed solution most efficiently
14:36:03 <fool> I was thinking more about metaprogramming actually 
14:37:33 <hodapp> metaprogramming is one of those weird things in that it is less and less useful the more and more a language lets you roll your own abstractions and compose them
14:38:14 <fool> maybe but it looks fun
14:38:26 <hodapp> it's "fun" until you need to do real work in it
14:38:47 <hodapp> and then you realize that generated code can produce some of the most disgusting hells you'll ever have to debug
14:39:18 <Tuplanolla> I have yet to encounter a language, where metaprogramming is both useful and pleasant.
14:39:22 <fool> I agree it is not exactly something that you'll try for solid stuff on which your living depend but experimentally it's a thing I'd like to explore.
14:39:31 <hodapp> well, take a look at Template Haskell.
14:41:29 <hodapp> and Lisp is also sort of known for its macros, though I don't recall offhand how much of this Clojure provides
14:42:57 <hodapp> doesn't Oleg Kiselyov have some papers on hygienic Lisp macros or something?
14:51:50 <koz_> hodapp: Clojure does have a great degree of macrology, based on Common Lisp's macros I think.
14:52:07 <koz_> Scheme macros are _more_ hygienic, since they rely on pattern matching, not 'build code out of symbols'.
15:12:04 <fool> am I the only guy to think that all the mathematics should use french terms ?
15:12:25 <fool> I stumbled on « epic » and « monic » in a « CT for computations » book
15:12:48 <fool> this is called épimorphisme and monomorphism respectively in french
15:12:56 <dstolfa> fool: yeah, that refers to epimorphisms and monomorphisms, essentially a more general way to state injectivity and surjectivity
15:12:58 <glguy> No, there's probably someone somewhere that agrees with you.
15:13:05 <fool> this is much more clear. 
15:13:27 <fool> glguy: more than one would be sweet.
15:13:43 <fool> I was just thinking that epic and monic are not really good terms 
15:13:54 <fool> it was invented by an american
15:14:15 <dstolfa> fool: what do you mean? they're awesome. have you ever concluded a theorem with: "thus, f is epic!"
15:14:55 <fool> that just does not mean anything in the context but good pun
15:15:17 <fool> it's mac lane fault
15:15:22 <fool> american CT school
15:15:31 <dstolfa> fool: it is a good pun, but it does mean that f is an epimorphism, it's a widely used term actually :-)
15:15:44 <dstolfa> a lot of non-US/UK books use that term too
15:16:34 <fool> well in some sense it seems that CT is just a generalization of set theories (aka objects) and functions (aka arrows)
15:16:59 <fool> why make it more complicated than it is by adding more and more terms.
15:17:01 <fool> but 
15:17:22 <fool> i'm being puny 
15:17:42 <dstolfa> fool: i wouldn't say that. the terms were added to disambiguate the existing terms from more general ones
15:17:48 <glguy> In any case, this channel is focused on Haskell the programming language.
15:18:03 <dstolfa> glguy++
15:18:05 <dstolfa> and i need to sleep!
15:18:10 <dstolfa> fool: have fun learning CT :-)
15:18:31 <Tuplanolla> You can come over to ramble on #haskell-offtopic, fool.
15:18:58 <shachaf> But this particular rambling seems pretty unproductive so I recommend dropping it.
17:51:12 --- mode: glguy set +v dataN
17:51:29 --- mode: glguy set -v dataN
17:59:25 <dataN> when defining the type family equivalent of traverse, placing the type family version of (<*>) in the Applicative class does not make the compiler return a "no instance Applicative" error if this instance is missing at some use site. This is because of the possibility that the instance is found in a pattern of an open type family at top level?
18:00:08 <dataN>  i.e. while functions declared in classes cannot have patterns matched on the type of their arguments in definitions at top level, open type families can. can the compiler be made to return the desired error?
18:03:25 <lyxia> at this point associated types are just sugar for type families
18:04:26 <lyxia> so no there is no way to get a "no typeclass found" error if you want to keep your family open
18:04:32 <dataN> lyxia: declaring them in a class makes no difference to the scope of their availability ?
18:04:46 <lyxia> no difference
18:07:55 <dataN> wouldnt it be be better if it was not possible to write definitions for open type families declared in a class definition except in the corresponding class instances ? 
18:08:28 <dataN> trying to do that with functions would result in a duplicate definition error.
18:08:28 <lyxia> wait, that's already the case
18:09:11 <lyxia> I probably misunderstood your previous question, but if you have an associated type, you must define its equations under instances for the corresponding class.
18:11:44 --- mode: glguy set +v dataN_
18:12:14 <dataN_> ah, your right, sorry.
18:13:50 <dataN_> sorry my browser keeps crashing
18:14:50 <dataN_> was there a suggestion of how to write Traverse as a type family where the Applicative constraint would be typechecked properly? 
18:16:02 <lyxia> I don't think that's possible, there is no analogue of type classes for kinds.
18:19:09 <dataN_> but if associated types cant have be defined except in class instances, they the compiler should be able distinguish that from top level open type families, as it already does recognise the difference for the "duplicate Definition" error just described. 
18:19:43 <lyxia> sure, but I mean that's not implemented currently
18:20:22 <lyxia> there was a paper in ICFP about that just last year
18:20:46 <lyxia> http://ittc.ku.edu/~garrett/pubs/morris-icfp2017-families-extended.pdf
18:21:30 --- mode: glguy set +v dataN
18:26:23 <dataN> this paper says it needs "explicit coercions witnessing equality between types and usable in type conversions" to be added to System-FC. but why? its just to distinguish between open type families decaled at top level and associated types, which already exists!
18:28:02 <dataN> well they are trying to achieve something other than just an error if they are coercing types... 
18:28:19 <dataN> so I'm not sure this paper is about the same thing
18:29:29 <lyxia> these coercions are part of system FC
18:30:08 <lyxia> the paper mentions them as the difference between F and FC, that's not part of their contribution
18:31:56 <lyxia> isn't the second contribution listed on page two what you're actually interested in
18:32:20 <dataN> oh right, CFC is just a simplification of System FC.
18:33:18 <dataN> e design of constrained type families (§4), which relaxes the assumption of totality by using type class predicates to characterize the domains of defnition of partial type families.
18:33:33 <lyxia> yes
18:34:14 <dataN> how is it to relax "the assumption of totality"?
18:35:15 <lyxia> if you apply a type family to a term for which it is not defined and you don't get an error, one way to interpret that is that the compiler assumes the family is total.
18:37:05 <dataN> so it would still be total, but only in the scope of a constraint. seems like whats needed
18:46:37 <dataN> not sure 'closed type classes' is the same... 
18:48:14 <lyxia> that's a different contribution
18:49:35 <dataN> its a way to make the associated type total by kind of having an associated closed type family
18:50:48 <dataN> it would still need to be open as associated types are currently, does that mean it cant be total? and if so, does that mean it does not need to be total to get the desired error?
18:53:24 <lyxia> total = it is defined for every type,  partial = it is defined for every type satisfying a constraint
18:56:57 <dataN> oh so they were just suggesting a way to make associated types total, not that its what was needed for constrained type families. 
18:58:11 <leonardus> What might this code be doing? https://i.imgur.com/6rdduYq.jpg
18:58:20 <leonardus> oh nevermind
19:00:24 <dmrd_> I've been following a couple tutorials on GHC-as-a-library using the default stack configs and have stumbled into walls due, apparently, to stack defaulting to the newest GHC version (8.x.x). Am I correct in assuming that most people leveraging GHC-as-a-library are defaulting to older GHC versions?
19:02:00 <glguy> I wouldn't expect that to  be the case
19:02:03 <MarcelineVQ> probably not. stack also doesn't default to the newest ghc, it uses the ghc that relates to the chosen resolver specified in your projects stack.yaml or the global yaml .stack/global-project/stack.yaml
19:02:42 <dmrd_> hmm, very odd. I'll try to come up with a reproducible example perhaps tomorrow. Thanks for the insight :)
19:05:19 <MarcelineVQ> it's worth nothing that 8.x.x isn't very specific, version-wise. if you mean any 8.x.x the oldest is a year and a half old and the newest is 2 months
19:05:54 <MarcelineVQ> *worth noting
22:11:56 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
22:11:56 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
22:11:56 --- names: list (clog wonko7 takuan ackthet aarvar arthurjames Lowl3v3l gienah lassulus abueide revprez_stg yunhao94 jedws lostman joeytwiddle pfurla jhrcek joshsh pimlu andreabedini rprije Lycurgus tommd forgottenone erikd EdJoJob umbriel MoarSpaceFi Ayo coldpresent DeltaManiac justsomeguy dented42 jkachmar piyush-kurur codesoup jaziz carlomagno ego SlashLife solarus kerrhau lukelau mnoonan nowhere_man orion_ Sgeo_ teeps survove banc theDon luqui tristanp Lightform)
22:11:56 --- names: list (marvin2 esrse eschnett tzemanovic nighty- nckx SenasOzys armyriad droplet poljar jackdk enterprisey bilal80 bbear ChaiTRex mauke daniel-s andyhuzhill Axman6 eiGHttt zv tromp rcdilorenzo carlosdagos YongJoon peayogurt Anthaas_ jluttine nfd9001 libertyprime elated elfets_ luhliarik__ DTZUZO_ hamishmack Destol infinisil loli duncan^ Saulzar djbeau ggVGc lemonpepper24 zaquest toovs Jesin hololeap tomboy64 +zhaskell juri_ inkbottle sleepster dan_f tomku klntsky)
22:11:56 --- names: list (sigmundv wpcarro Zipheir raingloom gxt LastTalon dmrd_ wtw Randy staafl Lears nbunjevac Annihitek cross slomo darithorn dpyro polux36 jchia_ bean_to_bar cement seizo unlink2 xplat bennofs thalesmg tsaka__ jrslepak thunderrd ByronJohnson Big_G pavonia emerson ddellacosta lrwz ClaudiusMaximus noan kuko urdh hpc sw1nn michaelhamel__ stux|RC pulec eR2oIEUwCAx1oEbG sqrt2 kuttifunk haveo gabiruh tuckerwales +la5tl19ht jeeeunevans catsup ashirase Syllo[m])
22:11:56 --- names: list (tpsinnem pie_ maerwald wonko77 harfangk chpatrick valdyn phreedom mnrmnaugh khisanth_ NB0X-Matt-CA jdemler boj mounty Digit pi-victor Fubar^ mountaingoat ekleog selfsymmetric-mu lagothrix stiell Fairy cyphase Cale gehmehgeh beeman sgflt mkoenig ma27 verement mounty1 megaTherion darjeeling_ mulderr dedgrant machinedgod hph^ gentauro hiptobecubic polman Akii_ adius byorgey Vq avocado nano- lawlesseel awal acarrico APic saml amiri petermw Sose @Sigyn)
22:11:56 --- names: list (dueltodeath[m] lortabac Cthalupa yrid bafain jle` Izeau dcoutts dmiles abuss nadare sgraf pbodev2 Miroboru nyaomi drbean XCE ycheng pikhq hackage edwtjo WhistlePayer bydo atk shutdown_-h_now jchia haasn DTZUZU michaelpj martingale nilOps Detson cow-orker lvmbdv cchalmers lnostdal jkup nisstyre AWizzArd sdrodge Myrl-saki Tesseraction asjo PLPD-Bot mingc pong Unhammer emilypi dustinm subttle dolio nh2 siers ManiacTwister forsakennobility nwf AgustinM[m])
22:11:56 --- names: list (jokester troydm qzo justan0theruser SquidDev bluepixel zygentoma[m] fryguybob GamboPango Folkol Profpatsch vvz Athas mubareksd[m] hpd wollw2 llwu xanderio domenkozar m4lvin Guest33092 mupf implementation cjwelborn l\i\a tombusby cheater _6a68 mmaruseacph2 liyang zzz dpower trebuh koala_man markus1189 MonkeyNOS gspia fluxit Maxdamantus dmwit Ivan__1 Ewout spopo fugyk c-rog ephemera_ ju6ju8oo noam__ Foritus vqrs pranz ahihi Moyst electrocat cgfbee ynyounuo)
22:11:56 --- names: list (makergrl DrAwesomeClaws iomonad drewr quarters dan64 tdammers jhammons Arguggi tsmc[m] vimto michalrus lpsmith loc bollu flebron cesardv d6e_ worch veverak spinda lantti atomi Ke plaerema1s wayne habbah_ riquipuig[m] martin--t_ niklasl c_wraith Guest55562 wamaral Unode endofline Fylwind jvanbure marble_visions kadoban yazmir8azyr Shockk gsingh93 GGMethos vaibhavsagar dredozubov mutantmell kqr zipper mimi_vx rntz exio4 Liskni_si vin-ivar burp_ adarshaj)
22:11:56 --- names: list (pwestling rootmos blackdog_ spoke syamaoka oak yarnspinner mhanu[m] bartavelle pbodev1 ibraheemmoosa[m] jdt aksz kav yaroot AndreasK bwe isenmann esp32_prog rory M2tias xnyhps monochrom koz_ forell _dga ericsagnes quicksilver revprez_anz greeny__ swalladge bas080 tnks dibblego mikolaj_ terkwood nksegos_ samueloliveira[m luke-clifton[m] insanitea salek_ shrifbot NightA Charn nshepperd omilu bbaren m1dnight_ joeyh keep_learning nshepperd1 johnw jb55 dschoepe)
22:11:56 --- names: list (bind leothrix agrif drager sz0 lkurusa bornjre ps-auxw m0rphism grumble Chousuke debugloop pepijndevos lambdabot ion violeta leonardo2718[m] Ckat Meanirelli rotty Wamanuz2 maralago Tehnix deba5e12 NinjaTrappeur bertschneider__ sis7 Konehaltia Hotkeys unsymbol alip nille thebnq nek0 philippirrip hydraz secretmessage Arahael UnlawfulMonad buhman yahb ftlight joehillen texasmynsted SCHAPiE M12407-[m] glowpelt jetpack_joe centril monad_cat stvc kryft Tspoon_)
22:11:56 --- names: list (klugez guillaumecherel[ pacak rgh[m] jmnk barrucadu devurandom case_ ramslee MindlessDrone kjak Ekho[m] trigalero[m] pikachoum[m] sudoreboot[m] braunseb[m] lions[m] yajaru[m] unclechu aloiscochard[m] qxjit[m] rhc[m] lurpam[m] rihardsk[m] ludovicdanjoumad dkasak[m] saidinwot ski lpvb ArchieTMichaKrzy petrolifero[m] dminuoso hvr ryantm seliopou ixian jdnavarro scinawa Tops2 davl cpup geodesic[m] mitch_ clownpriest[m] cppxor2arr Pepe_ rzmt lieven averell zxrf)
22:11:56 --- names: list (fregex hpd[m] bananagram `whoami` yumh freeFall3 ricky_clarkson efskap buoto banjiewen nurupo arsaes[m] georgew bcmiller rawles spacebug toppler miklcct schnozzle riatre Klumben salparadise richi235 rafadc bs telser bgamari albel727 Lord_of_Life PoliticsII pasukon fnurglewitz typetetris thoughtpolice sariyar heyj lierdakil[m] mrbackend[m] mattp__ kwibus[m] hc liste canta fredcy pikajude Soft DexterLB acowley carter vistefan[m] ocharles mcspud jinblack)
22:11:56 --- names: list (tripty ibttis PyroLagus int-e pharaun uwap int0x27h zaiste abbe sssilver geronimogarcia jol uptime aramiscd teej bt machinedgod_ mrherder cpape drewbarbs Ranhir mniip ScriptRunner avn bcoppens alexknvl phaazon tessier Guillaum akshayn huytd flogfr wildsebastian NickHu_ eagleflo [df] Guest77842 Guest43012 mantovani Drezil nopf s4msung yushyin noctux Blkt ab9rf exarkun1 andresbach[m] hdurer[m] oberstein pta2002 terrorjack paroxp isacl_ ecx sw4n underikar)
22:11:56 --- names: list (capitalistsuprem srk Mon_Ouie nullifidian chin-tastic dpn` paf31 jtcs mitchellsalad__ fingerzam[m] v0d1ch kipras`away umpc _flow_ lukeshu carc jibby[m] knoppaz[m] ZeWeaver[m] applecluster[m] kedah[m] revskill[m] ktaylora[m] dotglitch[m] M0x8badf00d[m] Christophe[m] tet[m] benzrf Fede[m] noteventime pagoda_5bIvanoPa kxra[m] silvio[m] Bigcheese dr34dl0ck[m] slugwurths-reven etarnvik[m] guest3321[m] integral Zoddo mpickering gonz_ feepo coot tsahyt beaky sclv)
22:11:56 --- names: list (mgaare fr33domlover mankyKitty Hafydd Saizan trobotham diginet Nascha NemesisD GreenSand mgttlinger ancarda jzelinskie eacameron Kamuela runde milessabin kaychaks srid fingerzam sppky sshine luigy bitemyapp tlevine1 Orbstheorem el_tejon[m] bjobjo lag mikolaj adaschma[m] pyrtsa jlavelle[m] idupree rj1 reedhhw[m] swhalen kubrat dmj` lalbornoz sms Deewiant_ duairc_ albertsg[m] +k0d3fr34k[m] johs adamse Philonous hendi madnight_ comboy Entroacceptor jonge)
22:11:56 --- names: list (betawaffle mujx[m]2 puffnfresh magicman [exa] Tuplanolla hive-mind kaychaks[m] monomono[m] phadej systemfault lainon[m]1 kalhuzcxv[m] glguy[m] telser[m] Noughtmare[m] Grgoire[m] ocharles[m] piluex[m] gregoiregeis[m] qwqdw[m] killjoyy[m] squallcx[m] trixon[m] loco_joe[m] tmallard[m] DarkBuzz[m] arthurxavierx[m] Makinit[m] acomar[m] BL[m] M2mol[m] mimi55555[m] psiska[m] random_tester[m] dotty[m] silasnordgren[m] acertain hsw[m] nbardiuk[m] Etsi[m] lycium[m])
22:11:56 --- names: list (thejonny[m] mith[m] elijordan jansc[m] tfc[m] bmjh[m] KevinMGranger[m] masaeedu[m] themsay[m] Barnabas[m] fgaz johnnyv[m] MatrixTravelerbo jangsentry10032[ wuffie[m] alanz[m] ahri[m] abhir00p[m] sevanspowell[m] lightandlight[m] dvgroc[m] ft tv jesyspa rotaerk qdickon angerman bigs danza-cloud elvishjerricco lucas8 nemesit|znc alp PHO newhoggy ryzokuken enojelly Velpoman jakehehrlich_ CindyLinz badzergling nitrix rom1504 Heartmender Niamkik iphy zyla__)
22:11:56 --- names: list (runawayfive h30 Forkk edwardk tureba Xal azahi nuxdie tjbp PierreM kini subleq jgornick korans soncodi nashimus saftsuse c50a326 dave_uy Adeon kaol Enigmagic zfnmxt twk- tazjin WilhelmVonWeiner salva dexterfoo caa51h sdx23 MarcelineVQ deu aldum darthThorik PotatoGim wz1000 TommyC ammar2 djanatyn cgoldammer exferenceBot paraseba abra0 Majiir hexagoxel drdo owlscientist leah2 Ekho bob_twinkles cynick pierrot hiredman tkr zerokarmaleft jix_ pakettiale ruffy_)
22:11:56 --- names: list (Rembane Solarion quaestor jstolarek lispy Jonno_FTW bengt_ rkrishnan mxf_ otulp statusfailed MasseR srhb hoke_t Xandaros @ChanServ pdxleif bjs epta defanor Tritlo_ pgiarrusso fairfieldt echoreply6 aweinstock JSharp Jaxan rizary rann shapr flux tolt scav jml cjh` bitonic etrepum HalfEatenPie amuck sudden malthe t36s Nikotiini Cathy dpanth3r awx_ qz EvanR micro nsnc dfordivam xaimus Clint absence Kneiva Guest11673 dqd pita xpoqp ralu lachenmayer)
22:11:56 --- names: list (Patternmaster Squarism mrm techieAgnostic jw358 hodapp datajerk mahalex kosmikus +aleator Guest10816 acro greymalkin Hijiri Guest40074 bod_ catern ptek __4matter beka shachaf anderson jkarni christopher eldritch a3f esph aib UserOO7 adamCS kloeri cyberlard cloudhead statusbot Flonk gregberns raoulb stefan-__ Adluc nyaray__ sujeet galingale iross jorj rodgzilla andjjj23 alanz Taneb verlet64 markmarkmark linduxed cic asm89 geal chelfi peschkaj runit xacktm)
22:11:56 --- names: list (parenthetical jackhill iron_houzi ranberry__ Jello_Raptor meck lugh simony baweaver lavalike Zemyla jophish metalrain cheshircat zymurgy gluegadget petercommand CrazedProgrammer scav_ jzl tapeinos hsiktas dysfigured Intensity carbolymer infinity0 tismith spoonm delYsid obfusk erratum nbathum cbarrett aidecoe bdw SolarAquarion rslima_ duoi sm nsncfriend vodkaInferno dh +orzo earthy thaumavorio tinwood niko Putonlalla michalisko toure|gone Dabo chindy)
22:11:56 --- names: list (capisce hjozwiak pmade EdwardIII joncfoo wagle mceier coeus aurieeeh moony Willis wraithm meinside d3lxa ironChicken obiwahn amx l8star apoc lyxia sigmundv_ @glguy cods typedrat TimWolla noexcept geekosaur arw haircode kipd mikeplus64 jackieh_ dukedave jfredett dgpratt cocreature dyl Ferdirand thoradam cjay- SegFaultAX natim87 aminb Jon brisbin iravid ventonegro ambrosia_ Nik05 gothos Guest58440 jonrh christianpoveda bradparker davean dsal milli)
22:17:07 <Zemyla> What the heck is Crosswalk?
22:42:26 <koz_> :t execState
22:42:27 <lambdabot> State s a -> s -> s
22:43:03 <koz_> :t foldM
22:43:04 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
22:52:51 <dminuoso> So Ive been staring at this piece of code for 20 minutes: https://github.com/axman6/servant-prometheus/blob/master/lib/Servant/Prometheus.hs#L86-L94 and there must be something I dont see.
22:53:01 <dminuoso> gauge :: Info -> Metric Gauge
22:53:06 <dminuoso> register :: MonadIO m => Metric s -> m s
22:53:22 <dminuoso> How the heck does this even type check (Metric does not have an instance MonadIO).
22:54:25 <jle`> it doesn't have to, does it?
22:54:40 <dminuoso> jle`: So this is in do-notation. In what monad exactly?
22:54:52 <jle`> oh are you talking about the type signature or the implementation
22:54:53 <jle`> let me look
22:55:20 <jle`> what am i looking at?
22:55:39 <dminuoso> jle`: Do you see this do block? https://github.com/axman6/servant-prometheus/blob/master/lib/Servant/Prometheus.hs#L82-L98
22:55:40 <jle`> what line do you think shouldn't typecheck?
22:55:43 <jle`> ah i see
22:56:20 <dminuoso> This thing looks like it's in the "Metric" Monad (which does not have a Monad instance), and later (where it uses `register`) it appears to be in the IO monad
22:56:55 <jle`> what is the definition of Metric?
22:56:59 <jle`> is it a type synonym for IO?
22:57:06 <dminuoso> https://hackage.haskell.org/package/prometheus-client-1.0.0/docs/Prometheus.html#t:Metric
22:57:23 <dminuoso> jle`: Well its a newtype around it.
22:58:52 <jle`> hm yeah weird if those type signatures for guage and register are what they are in this code
22:59:18 <cocreature> dminuoso: maybe it was written for a different version of prometheus-client?
22:59:49 <dminuoso> cocreature: Good lord you are spot on.
22:59:54 <dminuoso> Thanks.
23:00:05 <dminuoso> My brain was getting more twisted by the minute heh.
23:01:49 <dminuoso> Also thank you jle`.
23:13:35 <dmj`> TIL Int8 is really Int
23:13:39 <dmj`> data {-# CTYPE "HsInt8" #-} Int8 = I8# Int#
23:13:46 <dmj`> maybe types are a lie
23:15:32 <cocreature> dmj`: it’s Int in terms of memory usage but the operations treat it like it’s an Int8
23:15:57 <dmj`> cocreature: right, makes sense. But still...
23:17:11 <cocreature> it doesn’t matter that much. most of the time you care about memory usage it’s because you have a sequence of those and then an unboxed vector gives you the right space usage
23:19:40 <dmrd_> Hi all! Been using  GHC-as-a-library today. Can't quite figure out how to set static flags. Any clues?
23:46:35 <dmrd_> nevermind, got it to work :)
23:49:45 <trcc> Anyone familiar with eta lang? Having a issue with building a jar that I can use in other Java projects. java.lang.NoClassDefFoundError: eta/runtime/stg/Closure
23:57:45 <ricky_clarkson> trcc: Never heard of it, but it sounds like it needs some eta runtime jar. You could probably persuade your build system or something standalone like onejar/fatjar to roll that into your jar, but at least in the normal Java ecosystem that's unusual.
23:58:16 <trcc> ricky_clarkson: I will try to look up fatjar. Thanks
