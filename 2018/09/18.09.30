00:01:29 <kosmikus> typetetris: oh, quite a few
00:17:15 <typetetris> There are at least three talks in parallel, which I would like to visit :( binomial heaps, ghc type checker plugins and the restful web service stuff.
00:17:29 <typetetris> I probably visit the hands on workshop and watch the others later.
00:53:08 <JonReed> Has any of you used parser libraries like Parsec and Megaparsec with GHCJS? Which library do you think I should go for, if I want reasonable performance after it's been compiled with GHCJS? Megaparsec claims to be a lot faster when compiled with GHC, but so far I'm trying to install it and i's running its test suite for 10 minutes already.
00:54:33 <JonReed> I know that Parsec should have workable performance, based on http://markup.rocks/ which compiled Pandoc with GHCJS to use inside the browser
00:55:42 <JonReed> But I wonder that even though Megaparsec claims to be faster natively, there is something I'll shoot myself in the foot if I start writing for GHCJS
01:19:32 --- mode: glguy set +v searcher
01:19:35 <searcher> hi
01:26:14 <typetetris> JonReed: Probably just try it out. Make some small parser (with megaparsec and parsec) and feed it a lot of data. So you have a comparison. Should just take a day or two tops, if you are unfamiliar with that stuff.
02:30:07 <mniip> what name would one give to (const .)
02:30:48 <koz_> :t (const .)
02:30:50 <lambdabot> (a1 -> a2) -> a1 -> b -> a2
02:31:14 <koz_> absorb?
02:31:17 <koz_> ignore?
02:31:24 <mniip> more like "defer"
02:31:29 <koz_> Yeah, 'defer' works.
02:31:46 <mniip> @let defer = (const .)
02:31:47 <lambdabot>  Defined.
02:31:52 <mniip> :t defer (defer (defer id))
02:31:54 <lambdabot> a2 -> b1 -> b2 -> b3 -> a2
02:31:57 <mniip> :t const (defer (defer id))
02:31:58 <lambdabot> b1 -> a2 -> b2 -> b3 -> a2
02:32:01 <mniip> :t const (const (defer id))
02:32:02 <lambdabot> b1 -> b2 -> a2 -> b3 -> a2
02:32:04 <mniip> :t const (const (const id))
02:32:05 <lambdabot> b1 -> b2 -> b3 -> a -> a
02:33:37 <mniip> the real plan of course is to use it at the type level
02:35:32 <mniip> @let abs f x y e = liftA2 f x y e
02:35:34 <lambdabot>  Defined.
02:36:26 <mniip> :t abs (abs (abs id)) (defer (defer id)) (abs (abs (abs id)) (const (defer id)) (const (const id)))
02:36:28 <lambdabot> error:
02:36:28 <lambdabot>     Ambiguous occurrence ‘abs’
02:36:28 <lambdabot>     It could refer to either ‘Prelude.abs’,
02:36:37 <mniip> dammit
02:36:39 <mniip> @let abst f x y e = liftA2 f x y e
02:36:40 <lambdabot>  Defined.
02:36:50 <mniip> :t abst (abst (abst id)) (defer (defer id)) (abst (abst (abst id)) (const (defer id)) (const (const id)))
02:36:50 <JonReed> Which nix package provides `ghcjs`? I have tried `haskell.packages.ghcjs.ghcWithPackages` and it seems to compile packages with ghcjs, but the environment it results in has no `ghcjs` command.
02:36:51 <lambdabot> (b -> t1) -> (t2 -> b) -> t2 -> t1
02:44:19 <mniip> hmm, technically,
02:44:22 <mniip> const = defer id
02:44:36 <mniip> but I don't like that contraction
02:47:12 <mniip> I also don't like the fact that it takes a deep walk to distinguish 'const (... const id)' from 'const (... const (const value))'
02:54:26 <oldandwise> help how to make this work. Input of [1,2,3,4,5] should do 1+2-3+4-5. It alternates between + and -. What I have is http://termbin.com/37hr
02:55:28 <oldandwise> no higher libraries pls
02:56:20 <mniip> that layout looks messed up
02:57:08 <mniip> oldandwise, have you considered writing a simple pair of mutually recursive functions
02:58:20 <oldandwise> i don't know what i consider. I want to see some snippets that work
02:58:41 <Maxdamantus> or doing something involving `cycle [1, -1]` and `zipWith`
02:59:23 <mniip> that I haven't thought of
02:59:41 <cocreature> > sum (zipWith (*) (cycle [1,-1]) [1,2,3,4,5])
02:59:43 <lambdabot>  3
03:00:13 <mniip> adding v [] = v; adding v (x:xs) = subtracting (v + x) xs
03:00:23 <mniip> subtracting v [] = v; subtracting v (x:xs) = adding (v - x) xs
03:00:50 <oldandwise> cocreature: didn't work
03:01:01 <oldandwise> cocreature: for [1,2,3] should be 0
03:01:32 <mniip> 1 : cycle [1, -1]
03:01:46 <cocreature> ah yeah, forgot that the first is different
03:11:30 <oldandwise> thanks cocreature , this works: f (x:xs) = x:zipWith (*) (cycle [1,-1]) xs
03:12:59 <cocreature> oldandwise: that will fail for an empty list
03:13:04 <cocreature> try mniip’s suggestion
03:14:41 <oldandwise> cocreature: adding, f [] = 0
03:15:50 <cocreature> that’s a type error :)
03:16:11 <cocreature> but yeah you can change f but replacing cycle [1,-1] by 1:cycle [1,-1] seems like the easier solution
03:16:36 <mniip> if I do outermost beta-reduction on an expression with no free variables, there's no way I can miscapture a variable right?
03:18:38 <mniip> because the rhs of the application I am reducing must necessarily have no FVs too
03:49:05 <royal_screwup21> what does fromIntegral really do? Says here it converts an Integrat to NUM but I don't quite understand the example. sqrt 3 vs sqrt (fromIntegral 3) give me the same result -- when should I use fromIntegral then?
03:49:11 <royal_screwup21> https://wiki.haskell.org/Converting_numbers
03:49:19 <royal_screwup21> Integral*
03:49:52 <cocreature> royal_screwup21: it’s useful if let’s say you have a value of type Int and you need a value of type Integer
03:50:05 <cocreature> since integer literals are already polymorphic there is no point in applying fromIntegral to them
03:51:51 <Forgetaboutit>  /leave
03:55:28 <Forgetaboutit> Is there a datatype in a Haskell library which safely encodes the presence of at least one of two different values?  Something like `data AtLeast1Of2 a b = OnlyOne a | OnlyTwo b | Both a b`? I'm especially interested in the combinators available on this type; also interesting to me are its typeclass instances.
03:55:39 <mniip> Forgetaboutit, These
03:56:03 <mniip> there's the chronicle monad http://hackage.haskell.org/package/these-0.7.5/docs/Control-Monad-Chronicle.html
03:56:28 <mniip> or well just http://hackage.haskell.org/package/these-0.7.5/docs/Data-These.html
03:58:07 <Forgetaboutit> Perfect, just what I was looking for!  Thank you.
03:59:22 <Forgetaboutit> Is there also a corresponding type for at most one of two?
03:59:48 <mniip> Maybe (Either a b)
04:00:13 <mniip> not too awkward of an encoding
04:00:33 <mniip> These was needed because A+B+AB does get into awkward territory
04:35:06 <mniip> there we go
04:35:54 <mniip> a combinator calculus that lambda calculus can be turned into by a trivial top-down walk over the AST
04:36:43 <mniip> https://lpaste.net/9127868349491970048
04:38:01 <[exa]> foldr (:$:) part is best
04:38:27 <royal_screwup21> how long does it to become productive with haskell, relative to learning languages like go, python or java?
04:38:31 <royal_screwup21> take*
04:39:12 <[exa]> roughly same, there's a lot of good learning material now
04:39:13 <Lycurgus> longer
04:39:47 <[exa]> except you might be already biased towards go&python&java by other non-functional programming experience
04:39:49 <cocreature> royal_screwup21: it really depends on how exactly you are comparing. learning python when you know java will be faster than learning Haskell when you know java but if you don’t know any language, the differences are probably not that large
04:40:18 <mniip> [exa], I have a different version where k and env use Comb -> Comb functions directly instead of [Comb] lists
04:40:23 <[exa]> royal_screwup21: also, haskell doesn't stop at "productive level" :D
04:40:45 <Lycurgus> yeah, if you already know prolog, ocaml, smalltalk or some other lang with an unconventional model of computation then should be same
04:40:51 <[exa]> mniip: mind if I show this to students?
04:41:07 <mniip> [exa], I don't know, do you see educational value in it?
04:41:56 <royal_screwup21> hmm I've been reading lyah (onto the last few chapters now) and trying out a few problems on project euler, but can't say I really know much...maybe I've been reading it wrong...
04:42:20 <mniip> it's something I've been ironing out as a potential encoding in a higher-/poly-kinded Generic replacement
04:42:40 <mniip> so IKDL would be type combinators rather than functions
04:42:42 <[exa]> mniip: well I'd otherwise need to hack together something similar myself :] and the environment treatment in your case is cool
04:42:46 <cocreature> royal_screwup21: lyah isn’t particularly good at teaching you to write useful stuff. you are going to have to find your own projects for that and work on those
04:42:54 <Lycurgus> lyah is considered trite, banal at this point
04:43:15 <mniip> [exa], mind that k is always just a list of K's
04:43:18 <Lycurgus> here in the post peak hs period
04:43:20 <mniip> so foldl/foldr doesn't matter
04:46:41 <mniip> [exa], before showing it to anybody, are you sure you comprehend it yourself :P
05:22:16 <[exa]> mniip: well I'm parsing that now :D thanks for reminder :]
06:06:30 <WilliamHamilton[> osa1: hi! I have a question about Show instances in generics-mrsop
06:07:19 <WilliamHamilton[> how can I in practice use show over an expression like `deep @FamFoo exampleFoo`, given that I defined the family for Foo via deriveFamily?
06:08:02 <WilliamHamilton[> the problem is that there is not a `Show1` instance for `Data.Functor.Const.Const ()`
06:12:12 <WilliamHamilton[> osa1: more generally, is there a reason `Show` instances for `Rep` and `Fix` should be more difficult to write in this framework than in `generics-sop`?
06:13:43 <osa1> WilliamHamilton[: sorry, I don't know any of those libraries. if you stick around someone who knows will probably answer. 
06:14:44 <WilliamHamilton[> osa1: I'm very sorry, I was under the impression that you were one of the authors of `generics-mrsop`!
06:15:11 <osa1> no worries :)
06:18:56 <WilliamHamilton[> anyone knows the irc handler of the authors of https://dl.acm.org/citation.cfm?id=3241786 ?
06:22:30 <lavalike> WilliamHamilton[: did you already figure out that show instances are in a separate module?
06:23:42 <WilliamHamilton[> lavalike: yes, but in the last version on hackage, the part which is the show for the `shallow representation` has been commented out, and the one which is the show for the `deep representation` has the problem I was mentioning before
06:23:54 <WilliamHamilton[> `Const ()` not being `Show1`
06:24:07 <lavalike> WilliamHamilton[: finding this was also interesting https://github.com/VictorCMiraldo/generics-mrsop/blob/4eb8a91ba519ad3e9a06d2ff53ba546b94018dfc/src/Generics/MRSOP/AG.hs#L52
06:25:11 <WilliamHamilton[> lavalike: very well, thanks, I missed that, and that solves my problem for the deep part
06:25:18 <lavalike> yay!!
06:26:21 <WilliamHamilton[> yeah! but I'd still like to know about the shallow one, if someone knows
06:26:47 <lavalike> maybe sending them an email is the shortest path
06:27:17 <lavalike> there are official emails here: https://victorcmiraldo.github.io/data/tyde2018_draft.pdf
06:27:40 <WilliamHamilton[> I'll do that, thank you for your help
06:27:42 <WilliamHamilton[> !
06:27:44 <lavalike> my pleasure!
06:57:56 <vagrant-x> hi!
06:59:19 <lavalike> howdy
07:01:42 <vagrant-x> :) I'm to be off-topic, but I'm new to irc and was told that this was a very active channel. does anyone here know of any general channels that are still active
07:02:06 <lavalike> vagrant-x: try #irchelp or #freenode
07:02:21 <vagrant-x> ah thanks!
07:02:47 <lavalike> np!
07:45:02 <blackandblue> cocreature, hi
07:45:42 <fiatjaf> I'm the biggest haskell noob ever
07:46:10 <fiatjaf> I'm trying to parse an URL with Network.URI
07:46:19 <fiatjaf> that may fail
07:46:28 <fiatjaf> how do I exit when there's a failure?
07:53:49 <c_wraith> fiatjaf: there are quick-and-dirty approaches like using "error" to crash the program.  In general I recommend against that, and recommend just handling the lack of parse result in the main-line logic instead
07:57:45 <hpc> the last 5 packages in a row i have looked at in hackage don't have docs built on their latest versions :/
07:58:08 <learnerx> royal_screwup21 if you're interested
07:58:27 <learnerx> I'm working on a haskell guide which is, in my opinion, better than lyah
07:58:44 <royal_screwup21> sure, let
07:58:48 <royal_screwup21> let's have i
07:58:51 <royal_screwup21> it*
08:00:10 <learnerx> royal_screwup21, sure just gotta upload it somewhere
08:01:23 <davr0s> i kind of wish you could destructure without writing the name of the type, although i know you must for variants
08:01:47 <davr0s>    do_soemthign    (_  part0 part1  part2) ..    .. that sort of thing
08:02:02 <c_wraith> davr0s: eh?  you only need to write the name of the constructors to pattern match.  Not the type.
08:02:16 <davr0s> sorry for that inaccuracy
08:02:31 <davr0s> thats what i mean - the fact you still have to write a name
08:02:53 <davr0s> (which you might repeat in the signature  often)
08:03:09 <davr0s> i get that writing it once can constrain type inference
08:03:36 <davr0s> but what would be nice if you could write it in one place (the function signature) or the other (desructuing the arg)
08:04:07 <learnerx> https://anchpop.github.io/wise_mans_haskell/index.html royal_screwup21
08:04:13 <learnerx> any feedback would be greatly appreciated
08:04:36 <royal_screwup21> thanks! Will check it out
08:05:08 <learnerx> if youve started lyah you can probably skip to # Types and type signatures at least
08:06:14 <royal_screwup21> nothing about monads? :(
08:06:25 <c_wraith> monads are less important than you think
08:06:30 <royal_screwup21> woops
08:07:12 <learnerx> royal_screwup21 monads are in there
08:07:14 <learnerx> at the bottom
08:07:34 <learnerx> I don't have a ton of detail in there yet
08:07:59 <learnerx> but they are briefly discussed
08:08:31 <c_wraith> As with all abstractions, they're best learned by exposure to concrete cases.  Learn IO, higher-kinded types, and higher-order functions.  Eventually, you'll see the pattern and go "oh, that's all it is?"
08:09:57 <merijn> royal_screwup21: Did you learn monoids when you were taught how to do addition and multiplication in school? I suspect not, and it's for the same reason you don't really need to worry about "learning/understanding monads", you can get the generalisation without first learning individual instances of a pattern
08:10:35 <learnerx> and monads are actually pretty simple
08:11:09 <learnerx> they're a convenient way to add context to a value
08:12:47 <learnerx> for example the Maybe monad says "this value might not exist"
08:12:55 <learnerx> the List monad says "there may be one or more of this value"
08:12:59 <c_wraith> they're simple, but they're abstract in a direction most people are unfamiliar with.  Being simple doesn't mean "obvious".  It just means that there isn't a lot of complexity.
08:13:24 <learnerx> the Writer monad says "this value has some logging info attached to it"
08:13:25 <learnerx> etc
08:13:57 <learnerx> Then >>= lets you use these values in functions that don't care about the extra context
08:14:37 <learnerx> aka they're just monoids in the category of endofunctors, what's the problem
08:15:51 <davr0s> https://stackoverflow.com/questions/16633123/compiler-switch-to-turn-debugging-messages-on-off << this suggests using the C preprocessor of all things to enable/disable debug messages dynamically.  is there a more 'official' way, like a release build flag.    (what i'd have in mind is 'trace' debug and 'asserts' being disabled.
08:16:34 <davr0s> i can get by with what i have now because i can leave bits of debug in there, just manually nulled out. i tend to work that way anyway, i.e. focus on debugging one thing instead of tracing everything
08:17:21 <learnerx> debugging in haskell could be better
08:17:22 <davr0s> (ie. using trace, then manually swapping in a trivial  'notrace ...' once it worksso it's there if i break somethign in future ..)
08:17:32 <learnerx> this is why I just don't write bugs
08:17:39 <merijn> davr0s: You can make the CPP flag conditional on a commandline option (-DRELEASE) or something, then have a cabal flag that adds that commandline option and then having cabal default to that flag disabled
08:18:12 <davr0s> learnerx honestly i was struggling with that but thinking 'make things right through writing it better at every step..' , but honestly now i've got "trace" in my repetoir i'm much happier.
08:18:38 <merijn> @quote oasis
08:18:39 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:18:57 <learnerx> davr0s no doubt
08:19:10 <learnerx> I wish I could use a real debugger though
08:19:46 <davr0s> i was basically on the verge of building something to recover imperative style debugging by collecting report values or something. (probably along the lines of what parsers do but simplified). 
08:19:55 <merijn> ghci has a debugger built in
08:20:04 <merijn> @quote stream.of.conc
08:20:04 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
08:20:06 <merijn> hmmm
08:20:08 <davr0s> in particular i've been trying to fix clipping bugs in some geometry processing code
08:20:29 <davr0s> Whilst the process conceptualy is very elegant viewed pure-functionally..
08:20:55 <davr0s> ... when something goes wrong, you want to think of it as a series of steps to find where, with the ability to visualize intermediate states.
08:21:14 <merijn> @quote cmccann stream.of
08:21:14 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
08:21:48 <davr0s> yeah lazy eval will confuse it but that looks fascinating to observe 
08:22:35 <davr0s> what i always used to do back in C is just draw this debug to the screen immediately
08:22:37 <davr0s> and you know,
08:22:46 <davr0s> as soon as OS's made that hard, writing this kind of code got harder.
08:23:30 <royal_screwup21> I'm trying to find the 1st duplicate that occurs in a list. Here's what I tried with Data.Set https://thepasteb.in/p/Elh12ZDKXDAim I'm not quite sure where I'm going wrong (added the traceback too) - I'd love a pointer or two in the right direction :)
08:23:32 <learnerx> davr0s are you working with 3d geometry?
08:23:50 <davr0s> what i could do now is make something that parses the 'debug print output' on the fly to dispaly some realtime image buffer , to emulate how I worked back in 1995
08:23:53 <davr0s> learnerx yes
08:24:06 <learnerx> interesting
08:24:12 <learnerx> that's similar to a project I wanted to work on
08:24:46 <learnerx> and you're right that being able to see intermediate geometry would be very nice
08:25:14 <davr0s> learnerx my enthusiasm for haskell rollercoasters. i still find all this way easier in C and C++ for reasons i'm alluding to now, despite the appeal of haskell generally . i find the segfaults in C/C++ aren't a problem. my time goes into things like clipping bugs, and figuring out how to interpret other peoples files
08:25:38 <davr0s> i still want to master haskell though, it's addictive and i'm sold on the principles
08:25:57 <learnerx> davr0s my interest in haskell is stifled by the lack of tutorials
08:26:10 <davr0s> anyway learnerx  it seems there is an avenue via 'trace'.
08:26:10 <learnerx> which is why I'm writing mine
08:26:23 <davr0s> i should make this 'text->graphical output thing' for other reasons
08:26:46 <davr0s> somethig ilke picking up  LINE(...)  etc and interpretting as drawing commands 
08:27:02 <learnerx> it's a bit ridiculous that when you ask for a haskell tutorial, you're told "just spend $60 on this 1200 page book written by a scumbag bro"
08:27:02 <davr0s> then dynamically resizing a canvas to display them as they come in
08:27:10 <davr0s> hhah
08:27:38 <dmwit> learnerx: ... what
08:27:43 <dmwit> learnerx: You are spoiled for choices.
08:27:47 <dmwit> ?wiki Tutorials
08:27:47 <lambdabot> https://wiki.haskell.org/Tutorials
08:28:04 <dmwit> (I personally recommend the Gentle Intro.)
08:28:19 <learnerx> woah, I never said there weren't any tutorials
08:28:23 <davr0s> something thats dawned on me is there's a subset of haskel you can still do nontrivial things with , thats not so hard to learn. all the monads etce tc etc... is there to make it *even more* elegant and tame stateful code (?). the thing is.. there's still non-trivial things you can write with a haskell subset that complement other langauges
08:28:34 <learnerx> I just said everyone recommends functional programming from first principles 
08:28:37 <davr0s> what if you just used haskell for transforming data and did anything stateful in <something else..>
08:28:59 <dmwit> learnerx: "Everyone"?
08:29:16 <dmwit> Empirical point against your claim: I recommend the Gentle Intro.
08:29:38 <learnerx> davr0s that was my plan
08:29:46 <learnerx> There's a program called blender
08:29:53 <davr0s> yes6
08:29:57 <learnerx> I wanted to rewrite the modelling code in haskell
08:30:02 <learnerx> while leaving the rest of it in c
08:30:28 <davr0s> nice idea
08:30:45 <davr0s> have you heard of wings3d aswell - it's written in erlang, it's not as huge as blender.
08:31:01 <davr0s> i have wondered if translating wings3d into haskell might be more tractable
08:31:11 <davr0s> smaller program, already closer to haskells ideas.
08:31:49 <davr0s> let me google , "wings3d haskell port" ..
08:32:25 <learnerx> blender isn't that huge
08:32:36 <learnerx> only about 2 million lines, most of which are in C
08:32:51 <davr0s> learnerx http://www.wings3d.com/?page_id=676   https://github.com/bjorng/wings
08:33:06 <davr0s> learnerx . lol, I call 2mloc a huge project.
08:33:10 <learnerx> them being in C means you can call them from haskell, so if you were to rewrite it you could do it incrementally 
08:33:31 <learnerx> 2 million lines but consider how many are totally unrelated to modelling
08:33:42 <learnerx> probably less than 500k lines of actual modelling code in there
08:33:55 <davr0s> thats still a lot to convert
08:33:57 <learnerx> and that's in c which means it'd be 100k of haskell code
08:34:05 <learnerx> if that
08:34:15 <learnerx> but I'm not gonna do it
08:34:17 <learnerx> so it's moot
08:34:30 <davr0s> have you considered trying rust aswell
08:34:38 <davr0s> C -> Rust might be an intersting path (C++ to rust is harder!)
08:34:39 <learnerx> I have never tried it
08:34:48 <davr0s> because Rust is even more inter-operable with C 
08:35:43 <davr0s> learnerx i'm perpetually resisting an itch to write my own modeller (again). of course right now i have that itch with haskell.
08:35:56 <learnerx> davr0s join me
08:36:03 <learnerx> I'm writting an all-haskell game engine
08:36:16 <davr0s> learnerx mind if i pm ?
08:36:22 <learnerx> not at all
08:59:36 <dstolfa> hmm, if i have data Foo = Foo { a :: Int } and data Bar = Bar { a :: Int }, why does haskell complain? when would this be ambiguous?
09:00:14 <severen> Because it effectively defines functions for a
09:00:27 <severen> And since they are different types and Haskell doesn't support overloading it doesn't work
09:00:34 <dstolfa> severen: i still don't see why that's a problem in a language that supports polymorphism...?
09:01:11 <dmwit> dstolfa: What should be the type of `a` in your opinion?
09:01:47 <dstolfa> dmwit: Foo + Bar -> Int, + denoting a sum
09:01:59 <dmwit> Okay. Haskell's type language does not have sums.
09:02:03 <dstolfa> :(
09:02:34 <severen> Records have some of Haskell's more painful points, as I understand it
09:03:09 <severen> I'm pretty new to Haskell though so maybe it's not that bad :p
09:03:10 <dstolfa> okay, well, thanks for clearing it up :-)
09:03:52 <dmwit> Well, I mean, I'm not sure I cleared it up, just moved the question. I'm surprised the next sentence from you wasn't, "Why doesn't Haskell's type language have sums?". =P
09:03:58 <geekosaur> the closest you get, and an alternative approach similar to the one used by lens, is a typeclass along the lines of `Has "a"' (with a type level string). I gather work in that direction has stalled
09:04:54 <geekosaur> one problem being the answers to the question dmwit just asked :)
09:05:20 <dmwit> Anyway, I don't know why there aren't sums. I expect it's one of two things: 1. performance 2. having them would make every stupid bug well-typed. I'm leaning pretty strongly towards 2 as a main motivator.
09:05:20 <dstolfa> dmwit: well, it doesn't really matter currently -- i'm just trying to build an interface to C structs here. i think it might be a bit of an overkill to get into a language design discussion over that :-)
09:05:48 <nshepperd> 3. it probably breaks inference somehow
09:05:56 <dstolfa> dmwit: it does have sums to *some* extent, data Qux = A | B is a sum
09:06:05 <dstolfa> or at the very least a coproduct
09:06:06 <dmwit> It's also possible that you would lose the principal typing property.
09:06:11 <nshepperd> since it would be a kind of subtyping
09:06:24 <geekosaur> inference is the big one I was getting at, yes
09:06:40 <dmwit> dstolfa: Right. And we have `Either a b`. But you can't pass an `a` to a function that expects an `Either a b` or vice versa.
09:06:44 <geekosaur> it'd also make for very slow compilation even wen it is inferrable
09:07:02 <dmwit> dstolfa: So it's not a sum in the sense I expect you meant.
09:07:09 <learnerx> dstolfa there is a ghc extension that supports what youre after
09:07:19 <dstolfa> dmwit: yeah, that's why i said to some extent rather than that it does have sums
09:07:21 <hexagoxel> does anyone have ghcid set up for a multi-package project so that it reloads when a internal dependency was updated and builds cleanly?
09:07:28 <dstolfa> learnerx: oh?
09:07:37 <geekosaur> because pretty much every type has to eb expressed as a complex constraint instead
09:07:41 <dmwit> dstolfa: DuplicateRecordFields
09:07:55 <learnerx> https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#duplicate-record-fields
09:07:59 <dmwit> dstolfa: But it does a lot less than you want it to.
09:08:03 <nshepperd> Has "a" seems like a perfectly good solution though imo
09:08:16 <dmwit> dstolfa: In particular you can only use the field in patterns and constructor applications -- you can't use it as a record accessor at all.
09:08:41 <cocreature> blackandblue: hi?
09:08:48 <learnerx> it could be ambiguous as a record accessor, no?
09:09:31 <dstolfa> learnerx: it could, but then you just fail to typecheck
09:10:37 <dmwit> Okay, the documentation corrects me: it is possible but painful to use duplicate fields as record accessors.
09:11:03 <dstolfa> honestly i just ought to rename my type constructors here
09:11:10 <dstolfa> it's not worth the pain
09:11:27 <dmwit> The two common solutions are to put the records in separate modules or to use Hungarian notation.
09:11:37 * dstolfa shivers at hungarian notation
09:11:48 <learnerx> what is hungarian notation?
09:12:02 <dstolfa> learnerx: prefix the name of a record with a part of the type name
09:12:02 <dmwit> Yeah, I like the "separate module" solution, too, in part because it lets the user choose their preferred Hungarian notation prefix. =)
09:12:27 <dmwit> Or to avoid the prefix entirely if they only need one of the two.
09:12:47 <dstolfa> learnerx: so if you have data Foo, you might say data Foo = Foo { fa :: Int } and for Bar, data Bar = Bar { ba :: Int }
09:12:55 <dstolfa> but usually for longer names there are a few more letters
09:13:02 <dstolfa> dmwit: yeah, agreed
09:13:03 <dstolfa> i'll do that
09:13:03 <dstolfa> thanks
09:13:06 <nshepperd> data Cat = Cat { catPaw :: Paw } ; data Dog = Dog { dogPaw :: Paw }
09:14:32 <learnerx> do the hungarians really have a monopoly on that
09:14:46 * dmwit ponders whether a "we allow but never infer sum types" policy would fix most of the objections
09:15:04 <dmwit> learnerx: No, just naming rights. =)
09:15:25 <dmwit> And remember the first law of mathematics: it isn't named after the guy what discovered it.
09:15:57 <geekosaur> it was named after *a* hungarian. compare "(reverse) polish notation". and never ask why people name things th way they do; you''l start wondering how we made t out of the trees without tripping over our own feet .
09:18:56 <nshepperd> I think defining a record should automatically generate the appropriate lenses, traversals, prisms, using Has
09:19:04 <dstolfa> dmwit: i think the way to do it would be to not infer anything at the start and require explicit type annotations. i'm fairly certain that in many cases you could in fact safely infer the types -- but there are definitely edge cases where it becomes nasty -- especially if you allow different types of the type constructors on the right side, i.e. if you allow PI types instead of just regular function types
09:19:24 <hexagoxel> ah - the solution is to use ghcid --run=":!touch ghcid.success"  and  ghcid --reload="ghcid.success"
09:19:25 <nshepperd> and then obj { field = x } should desugar into (field .= x) obj
09:21:25 * nshepperd . o O ([1, 2, 3] { traverse = 'a' }  =  "aaa")
09:29:50 <lyxia> Is that worth losing type inference in otherwise unambiguous cases
09:35:27 <nshepperd> probably not
09:37:50 <dstolfa> lyxia: it pretty much depends on how often do you have cases like that versus how bad the workaround actually is
09:37:56 <dstolfa> the workaround is not horrible, so that's okay
09:39:10 <learnerx> By the way, if anyone would like a copy of the haskell book
09:39:17 <learnerx> dm me for info
09:57:06 <max3> how do i use control.monad in a stack project?
09:57:25 <max3> i.e. if i want to include it in dependencies what's it called
09:57:31 <max3> and generally how do i figure this out
10:00:41 <lyxia> you just need to have base as a dependency in your .cabal file
10:00:54 <lyxia> like every other package out there
10:01:08 <max3> stack says don't change .cabal
10:01:14 <max3> change package.yaml instead
10:01:23 <lyxia> then change package.yaml
10:01:26 <max3> ...
10:01:42 <max3> what is the name of the dependency
10:01:55 <max3> it's not control.monad
10:01:56 <lyxia> package.yaml is used to generate the .cabal file.
10:01:58 <lyxia> It's "base"
10:02:14 <lyxia> Control.Monad is a module in the standard library, called "base"
10:03:34 <max3> thanks
10:05:04 <dstolfa> oh god why would anyone ever do this... i'm building an FFI towards C and the C code has an implementation of a doubly linked list saying struct list { list *prev; list *next; }; and then in every structure they say struct foo { list foos; ... };. how the hell do i even FFI this
10:05:24 <dstolfa> the amount of casts is ridiculous
10:05:32 <dstolfa> i'm calling the police
10:06:21 <dstolfa> they rely on the first struct member having the same address as the struct allocation itself
10:06:50 <nshepperd> ah, poor man's OOP
10:07:22 <nshepperd> gobject does that as well
10:07:32 <nshepperd> iirc
10:08:06 <dstolfa> i'm unsure how to make FFI happy with this if i change anything in haskell
10:08:37 <ggole> That's the idiomatic way to do lists in C, although usually you use a container_of macro instead of just assuming the offset
10:09:28 <dstolfa> ggole: there's no idiomatic way to do lists in C, there are only opinions
10:09:28 <yushyin> yup, seen that in the linux kernel list implementation
10:10:01 <max3> this sounds like a dumb question but is there anyway to emulate duck typing in haskell? yes i'm aware of typeclasses 
10:10:20 <ggole> There's also reimplementing list code for each structure you want to have in a list, of course.
10:10:22 <max3> i'm just wondering since haskell seems like a language where anything is possible if you try hard enough
10:10:40 <dstolfa> ggole: or go all out with insanity and do something like tree and queue, as seen in FreeBSD and Linux
10:10:49 <dstolfa> everything with macros
10:10:53 <dstolfa> then at least i don't need FFI...
10:10:55 <max3> and so i'm curious if there's a way to foil the type system too
10:11:06 <ggole> It's the same idea for any linked structure, really
10:11:47 <dstolfa> ggole: yeah, but at least doing with next/prev without assuming offsets makes it less of a nightmare to deal with in the FFI interface
10:11:57 <ggole> For FFI it sucks, yeah
10:12:39 <ggole> For C code in which you have to handle allocation failure carefully it can be more attractive than the alternative, because intrusive list operations never allocate
10:13:33 <learnerx> max3 you can turn off typechecking in haskell
10:13:40 <max3> learnerx, how?
10:13:40 <dmwit> nshepperd: There is a feature of the record system that I have occasionally used and which is significantly more painful in lens-land.
10:13:45 <learnerx> in ghc I mean
10:13:47 <jw358> is there a link somewhere about where i'm supposed to read about putting built executables on github releases via travis?
10:14:17 <max3> learnerx, unsafeCoerce?
10:14:19 <max3> interesting
10:14:26 <learnerx> there's a ghc option for it as well
10:14:29 <learnerx> but I can't remember
10:14:30 <dmwit> nshepperd: Namely, think of `data Foo a = Foo { field1, field2 :: a, others :: Whatever }`. One can `foo { field1 = True, field2 = False }` even if `foo` is not of type `Foo Bool`.
10:14:31 <dstolfa> ggole: you can always do something like this as well: https://github.com/freebsd/freebsd/blob/master/sys/sys/queue.h#L232. doesn't it's very nice though
10:15:10 * dstolfa needs soap for his eyes
10:15:49 <monochrom> Soap stings your eyes.
10:15:51 <nshepperd> max3: well, you can implement python in haskell. python objects are basically Map String Dynamic
10:16:15 <monochrom> What you need is one of those Johnson&Johnson baby shampoo which doesn't sting your eyes. >:)
10:16:33 <max3> nshepperd, what is `Dynamic`?
10:17:06 <dmwit> max3: exists a. Typeable a *> a
10:17:07 <max3> nshepperd, what's funny is that you're right (now that i think about it) - every python object is basically a dict
10:17:20 <dmwit> max3: (Now ask me, "what is exists a. t?" and "what is *>?" ;-)
10:17:21 <nshepperd> a box that can contain any datatype, and has runtime type information so that you can check what type it is
10:17:22 <royal_screwup21> I want to create an Eq instance on this datatype data Animal a = Cat a | Dog a
10:17:36 <max3> dmwit, yes of course i was just about to
10:17:38 <max3> nshepperd, interesting 
10:17:45 <max3> royal_screwup21, just derive Eq
10:18:02 <royal_screwup21> How do I go about this? Should I do "instance Eq Animal a where" ...
10:18:18 <dmwit> royal_screwup21: Sure, though the syntax is `instance Eq (Animal a) where ...`.
10:18:32 <geekosaur> max3, uless it's an exercise and writing it manual is the point
10:18:33 <dmwit> royal_screwup21: `Eq` instances in particular are so straightforward that the compiler will write them for you if you ask nicely.
10:18:36 <max3> royal_screwup21, and then define (==) (iirc)
10:18:43 <royal_screwup21> ah cool
10:18:45 <max3> geekosaur, yes you're right
10:19:19 <dmwit> royal_screwup21: (And the way to ask nicely is either `data Animal a = ... deriving Eq` or `data Animal a = ...; deriving instance Eq a => Eq (Animal a)` with suitable extensions.
10:19:24 <dmwit> )
10:19:44 <max3> is there an intuitive explanation for why [] as a Monad behaves the way it does?
10:19:49 <learnerx> yes
10:19:52 <dmwit> royal_screwup21: ...which reminds me, if you write it yourself, you'll *probably* want to include an `Eq a` constraint in your instance, as in `instance Eq a => Eq (Animal a) where ...`.
10:20:02 <learnerx> it's to simulate non-determinism max3
10:20:36 <dmwit> max3: You might like "You Could Have Invented Monads" by sigfpe, which includes the list monad as one of the ones you're invited to invent.
10:20:51 <learnerx> imagine you have a function that takes a licence plate and returns a list of speeding tickets that a car with that licence plate has recieved
10:21:09 <max3> i think i've read that but i don't remember if there's an argument there for why Monad [] should behave the way it does
10:21:09 <learnerx> and you have a function which, given a name, returns all the licence plates they've ever owned
10:21:13 <dmwit> ?where ychim
10:21:14 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:21:31 <learnerx> a natural use of these two functions would be to get a list of all the speeding tickets that person has ever recieved 
10:21:35 <dmwit> max3: There is. I just reviewed to make sure before I suggested it.
10:21:42 <max3> dmwit, okay thank you
10:21:51 <learnerx> for that you would just do getAllLicencePlates >>= getTicketsForPlate
10:22:02 <monochrom> If you grok list comprehension, you grok the [] monad.
10:22:21 <learnerx> it requires thinking of functions that return lists as "functions that return 0 or more values"
10:22:23 <max3> learnerx, sure that makes sense. i guess i was wondering if there were a "universal" reason for why a "monadic" sequence should behave as such
10:22:49 <monochrom> So let's head over to #python and tease them with "is there an intuitive explanation of list comprehension?" >:)
10:22:53 <dmwit> No. Each monad must be motivated on its own merits.
10:23:39 <learnerx> if a function returns 0 or more values, you can think of it as being "not really sure" which value that function should return
10:23:41 <learnerx> for example
10:23:58 <learnerx> sqrt can return a positive or a negative value for any sqrt operation
10:24:12 <geekosaur> max3, it's even possible tohave multiple monads for a given type (although when modeled as Haskel typeclasses, only one instance is permitted; see the Sum and Product newtypes, because there's similarly multiple monoids on numbers)
10:24:16 <learnerx> you could imagine sqrt` which returns sqrt and -squt
10:24:21 <learnerx> *-sqrt
10:24:40 <max3> sqrt isn't a function. you need to pick a branch :)
10:24:41 <geekosaur> for lists, theres the monad we use as its Monad instance, and there's another one based on zip lists
10:24:53 <royal_screwup21> I'm stuck. I have a data type like so: data Animal a = Cat a | Dog a . I want to it so that if Cat and Dog have the same values (eg: 20, Dog 20) then they are equal. Otherwise the Dog type is always greater. I tried something like this: https://thepasteb.in/p/66hVv45718wiW but I can't wrap my head around how to proceed
10:24:54 <dmwit> There is no monad based on zip lists.
10:25:06 <royal_screwup21> Cat 20*
10:25:37 <dmwit> But your example of monoids is a good one, because any two monoids on a single type T gives rise to two monads on the type (,) T.
10:26:30 <learnerx> royal_screwup21 you say "greater" but that's an eq typeclass
10:26:41 <dmwit> royal_screwup21: Haskell doesn't support patterns of the kind you used there, where you use the same variable name twice in a single pattern match.
10:26:56 <dmwit> royal_screwup21: If you want that, you must give two different variables and explicitly check for equality (or whatever other property) yourself.
10:27:05 <dmwit> royal_screwup21: e.g. `Cat a == Dog b = a == b`.
10:27:37 <max3> learnerx, any relation to racerx ? lol
10:27:43 <dmwit> royal_screwup21: Once you've done that, you have only three other patterns to flesh out before you're done: `Cat a == Cat b = ...; Dog a == Cat b = ...; Dog a == Dog b = ...`.
10:27:43 <royal_screwup21> ah cool thanks, that clears it up
10:27:57 <learnerx> max3, nope
10:28:12 <learnerx> just was gonna pick "learner" then realized that was probably already taken
10:28:16 <max3> learnerx, https://en.wikipedia.org/wiki/Racer_X_(character)
10:29:35 <learnerx> I should compile hugs to js and stick it on my website
10:40:04 <WilhelmVonWeiner> Check out Elm.
10:40:40 <WilhelmVonWeiner> Oh, nevermind. Don't, then.
10:42:18 <max3> WilhelmVonWeiner, why?
10:43:35 <max3> anyone with experience with miso?
10:44:55 <WilhelmVonWeiner> Why "Don't"? Because I misinterpreted, I thought learnerx was saying they'd like to put hugs compiled code as JS on their website
10:45:22 <learnerx> WilhelmVonWeiner that isn't what I meant
10:45:29 <learnerx> I meant I want to have a haskell repl on my site
10:45:56 <WilhelmVonWeiner> As I said, "Oh, nevermind. Don't, then."
10:45:56 <learnerx> which hugs lends itself to
10:46:08 <learnerx> oh
10:46:08 <learnerx> right
10:46:12 <learnerx> gotcha
10:46:21 <learnerx> elm is pretty nice
10:49:08 <dmwit> learnerx: It will probably be significantly less immediate effort (though does cause a longer-term hosting commitment) to interpret the code server-side.
10:50:05 <learnerx> dmwit: it look like Chris Done already did it
10:50:06 <learnerx> https://www.tryhaskell.org/hugs
10:50:21 <learnerx> but it's slow and js runs out of memory sometimes
10:51:12 <davr0s> (is tha your site/turorial?)
10:51:26 <learnerx> no, that's Chris Done's site
10:51:57 <learnerx> I agree that doing it server side would probably be nicer
10:52:36 <droplet> I might be misunderstanding something, but is there a reason there's no sMul in Data.Singletons.TypeLits, analogous to sDiv?
10:54:42 <mniip> droplet, it's part of the promoted Num typeclass I think
10:55:14 <mniip> %* in Data.Singletons.Prelude.Num
10:56:02 <droplet> Hm but that's for SNum, not for SNat
10:56:22 <mniip> SNat is an instance
10:56:48 <droplet> missed that SNum's a typeclass - my mistake
10:57:17 <droplet> thanks!
11:10:55 --- mode: glguy set +v hakl
11:21:16 --- mode: glguy set +v noipmups
11:21:21 <noipmups> Is there any lens function which let me insert value into a Data.Set?
11:23:18 <c_wraith> noipmups: You can use at from Control.Lens.At
11:23:50 <cocreature> > set (at 1) (Just ()) Data.Set.empty
11:23:52 <lambdabot>  fromList [1]
11:26:02 <robstrrr> Hello, experimenting with Servant & custom monad stack, is there a better way for nat transformation as my `nt` function https://gist.github.com/rsoeldner/4a5527be8b79c781f41574d3eeff017a ?
11:26:42 <c_wraith> > set (at 1) Nothing (S.fromList [0..3]) -- also can delete!
11:26:45 <lambdabot>  fromList [0,2,3]
11:29:16 <learnerx> Where does stack look for tests?
11:29:25 <tsaka__> If you have functions on a record which are some non-trivial form of getters (which does not change state) yet you use that record as a state variable in your program.. Do you make the function "MyState -> [Int]" or "(MonadState MyState m) => m [Int]"
11:29:37 <tsaka__> both work but which one do you prefer and why
11:30:52 <c_wraith> tsaka__: almost always the former, because you can use gets to convert it to the latter with one extra function
11:31:24 <dmwit> learnerx: I don't know stack, but if I had to guess I would guess it reuses cabal's testing mechanism. So take a look at the `test-suite` stanza docs for cabal.
11:32:04 <learnerx> I have a `src` folder and a `test` folder, and I've added `test` to my `hs-source-dirs` in cabal. I expected `stack build --test` to automatically run them, but I guess not
11:32:11 <lyxia> robstrrr: it looks like nt has too many arguments there
11:32:13 <learnerx> dmwit thanks for thet ip
11:32:17 <learnerx> the tip
11:33:56 <robstrrr> lyxia: whup, you are right, corrected now
11:34:20 --- mode: glguy set +v dataN
11:34:35 <dataN> I keep seeing errors like this;https://lpaste.net/5997526610268389376
11:35:44 <inquisitiv3> I'm having trouble with compiling some code. It's a textbook exercise from *Get Programming with Haskell*. https://gist.github.com/inquisitiv3/f701a0c7a24d1fa0795b460a01f18e4a#file-robot-hs-L22-L24
11:35:50 <lyxia> robstrrr: you can replace (either ...) with (first toServantErr)
11:36:33 <inquisitiv3> I've highlighted the lines of code that cause the error.
11:36:55 <lyxia> robstrrr: or (withExceptT toServantErr) to the left of ExceptT
11:38:56 <dataN> seems like the associated type isnt getting evaluated, for some unknown reason 
11:40:08 <robstrrr> lyxia: where is first defined ? :-/, withExceptT is neat
11:41:38 <lyxia> robstrrr: Data.Bifunctor
11:42:02 <robstrrr> lyxia: ty
11:42:51 <lyxia> inquisitiv3: you should get the habit of annotating all toplevel functions with their types
11:43:24 <dmwit> Okay, I have a design question. I've got `step1 :: Args1 -> IO Result1` and `step2 :: Args2 -> IO Result2`, where `Args1` and `Args2` use the record+Default trick to give the appearance of optional named arguments. `Args2` contains a value of type `Result1`. Now I want to write `bothSteps :: BothArgs -> IO Result2`; how do I avoid code duplication when defining `BothArgs`?
11:44:24 --- mode: glguy set -v dataN
11:44:34 <dmwit> That is, I want all the fields of `Args1`, and all but the `Result1` field of `Args2`, without re-listing all those fields manually, and I want to reuse the `Default` instances for `Args1` and `Args2` if possible.
11:44:38 <dataN> maybe it would help if there was some code to accompany this jargon 
11:44:59 <dmwit> Okay, sure.
11:47:15 <mniip> dmwit, do field puns help?
11:48:46 <dataN> btw, is there a reason the error keeps reappearing? its not clear why this error happens? 
11:49:53 <mniip> dataN, PolyKinds might be an issue here
11:50:04 <mniip> try restricting the kinds of a,r
11:50:37 <mniip> % type family F a where F Int = Bool
11:50:38 <yahb> mniip: 
11:50:45 <dmwit> https://lpaste.net/7160902529130168320
11:50:45 <mniip> % :kind! F Int
11:50:45 <yahb> mniip: F Int :: *; = Bool
11:50:52 <mniip> hmm
11:51:16 <mniip> it is defaulted here i guess
11:51:19 <dataN> with;
11:51:21 <dataN> class Flagged (a :: *) where   type FlagType a = (r :: *) | r -> a
11:51:26 <dmwit> mniip: I don't think so, but I guess I'm not sure what you've got in mind.
11:51:27 <dataN> the error remains unchanged 
11:52:12 <dmwit> (The paste above has a bad solution to my problem, together with some comments on what I don't like about it.)
11:54:58 <dataN> dmwit: ok, that explains a lot of what you were saying.
11:55:16 <dataN> what was the proposed solution?
11:55:18 --- mode: glguy set +v m4ur0
11:55:39 <dmwit> BothArgsBad/bothBad is the bad solution. I'm not certain what mniip was proposing.
11:57:31 <dataN> why not just take (Args1,Args2) ?
11:57:55 <dmwit> Because I don't want the user to be forced to create a Result1 out of thin air that will be ignored.
11:58:19 <dmwit> (Even the `Default Args2` instance is a bit of a lie, honestly.)
11:58:35 <dmwit> (For the same reason: it's forced to invent a Result1 out of thin air.)
11:59:17 <dataN> wait, but if defaults are given, then this shouldnt be much to ask!
12:00:21 <dmwit> Okay. I abstracted too much. `Result1` contains `Handle`s, which can't be created outside of `IO`. So in my real code I can't even write `instance Default Args2` in a total way.
12:01:40 <dataN> right, so the Defaults are only to be called for use with BothArgs, avoiding their impossible defaults from being used
12:03:32 <dmwit> I think I will `data Args2 a = Args2 { field21 :: a, ... }`. Then `step2 :: Args2 Result1 -> IO Result2` and `bothBad :: (Args1, Args2 ()) -> IO Result2` is not too bad.
12:05:15 <dataN> using this kind of syntax this way seems to work fine
12:06:42 <dataN> that is, the 1st and 3rd of your 'bad' points seem unavoidable. perhaps 2 can be avoided by reusing the defaults available for the other datatypes...
12:09:17 <dataN> mniip: this version with kind annotations for 'a' and 'r' has the same error; https://lpaste.net/8481012078184759296
12:44:42 <davr0s> was after this [(k,v)]->[(k, [v])] or better still   [(k,v)]->Map k [v] ,
12:45:04 <davr0s> multi-map or somehing ii forget n sepples
12:47:56 <dmwit> davr0s: https://stackoverflow.com/q/12398458/791604
12:48:10 <dmwit> Obviously my answer is the objectively superior answer. ;-)
12:49:05 <davr0s> i'm thinking i do want to use Map to acheive this as thats better for what comes next.
12:49:24 <dmwit> I agree. Map is the way to go. (This is why my answer addresses how to do this with Map.)
13:02:44 --- mode: glguy set +v GHCBuildingButOu
13:02:48 <GHCBuildingButOu> Hi!!!
13:03:39 <GHCBuildingButOu> I'm trying to build GHC, but I'm out of memory - is there a way to tell make or configure to use less memory to build with?
13:04:49 --- mode: glguy set +v dataN
13:05:15 <dataN> right, so that error might have been something to do with type family injectivity. 
13:05:20 <dataN> this version; https://lpaste.net/3629155770647445504
13:06:16 <dataN> works, and solves the inference problem (maybe) through bidirectional functional dependencies on the "FlagType" which is represented as an additional parameter rather than an associated type family
13:06:50 <dataN> does that sound plausible? 
13:07:16 <dataN> class Flagged (a :: *) where   type FlagType a = (r :: *) | r -> a
13:07:26 <dataN> vs
13:07:27 <dataN> class Flagged (a :: *) (t :: *) | a -> t, t -> a
13:08:36 <dataN> both directions of functional dependency are required and give errors if removed.
13:09:05 <dataN> so is the problem that it was not to be expected that the associated injective type would manage to do that
13:09:07 <dmwit> GHCBuildingButOu: Hm, I don't think so.
13:09:19 <dmwit> GHCBuildingButOu: You could try -j1, maybe, to ask it to only spawn one other process at a time.
13:09:45 <dmwit> GHCBuildingButOu: You could also poke around with GHC RTS options for maximum heap size.
13:10:04 <dmwit> GHCBuildingButOu: I think there's an environment variable you can set to affect that.
13:11:23 <dmwit> GHCBuildingButOu: e.g. from the docs try `export GHCRTS=-M2G` to ask GHC itself not to use more than two gigs of heap.
13:14:32 <lyxia> dataN: Or maybe it's a bug in GHC
13:15:29 <dataN> couldnt quite get it to the point where the error was comprehendable enough to open a GHC trac  
13:20:14 <davr0s> silly habits burned in from imperative code, very often i want to write the args of maps and folds backwards (so i have little helpers for that) .. i do see there's 'forM.. ' (?) in the stdlib.   I totally get why the args are the way they are, more usefl for currying
13:23:39 --- mode: glguy set +v ScriptRu-
13:24:32 --- mode: glguy set -v ScriptRunner
13:25:48 <ScriptRunner> This is what I've got so far, https://pastebin.com/20tPeJaJ
13:26:21 <ScriptRunner> I think its the pattern - I'm not sure what would be a alternative to that?
13:26:24 <dmwit> davr0s: Yep, sometimes one order is more appropriate, sometimes the other. Sometimes the returned value matters, sometimes it doesn't. That's why `traverse`/`traverse_` and `for`/`for_` all exist.
13:26:46 <ddellacosta> can anyone suggest any good resources for learning what Proxy is all about?
13:26:56 <dmwit> :t lookup -- ScriptRunner
13:26:57 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:27:17 <dataN> ddellacosta: easiest just to say here
13:27:29 <dmwit> ScriptRunner: Anyway, you just need parentheses. `lookUp chr ((a, b) : xs)`
13:27:36 <dataN> was there a question?
13:27:45 <lyxia> dataN: a type family that doesn't reduce when it should is not clear enough of a bug?
13:28:19 <dmwit> ddellacosta: Sure. Here's how it goes. I bet you've sometimes wished for `class NameThatType a where name :: String`.
13:28:34 <dataN> lyxia: as long as it should... thats the thing that wasnt easy to show
13:28:36 <dmwit> ddellacosta: That doesn't work well, because then `name` has an ambiguous type, and there's no way to specify it.
13:28:36 <ddellacosta> dataN: no specific question, trying to understand it in general
13:28:44 <dataN> chances are it shouldnt...
13:28:55 <dmwit> ddellacosta: Even `name :: NameThatType Bool => String` doesn't actually choose the `Bool` instance, it just demands that a `Bool` instance be in scope.
13:29:11 <ScriptRunner> Thanks for the help everyone, such a silly mistake! :-(
13:29:26 <dmwit> ddellacosta: So in the bad old days we would write `class NameThatTypeU a where name :: a -> String` and write in the documentation, "Don't look at the first argument!".
13:29:42 <dmwit> ddellacosta: Then when we wanted to use it, we'd write `name (undefined :: Bool)` and we'd be off to the races.
13:30:03 <dmwit> ddellacosta: But people went, "Hey, that `undefined` is really unfortunate. What if some instance breaks protocol and looks at the argument? Ouch!".
13:30:28 <dataN> ddellacosta: sometimes a function does not use all of the parameters of a class it belongs to, in which case these parameters are ambiguous when that function is used, which instance of the class should be used if the function doesnt mention all the types that would specify the required instance?
13:30:48 <dmwit> ddellacosta: This is where `Proxy` steps in. Because `Proxy :: Proxy Bool` can always be written for whatever type you want, and is fully-defined, it doesn't have that problem.
13:31:19 <dmwit> ddellacosta: So slightly better is `class NameThatTypeP where name :: Proxy a -> String`.
13:31:40 <dmwit> ddellacosta: But then people noticed it can get even better still, because we can actually ask the type system to enforce that the first argument is never looked at.
13:32:00 <ddellacosta> dmwit: so to step back a bit, this is if we don't actually want to use the type variable `a` at the value level but want to ensure it's defined? I think I'm a bit confused as to when that would come up, so while I understand the mechanics of what you're saying I'm a bit stumped on the "why" still
13:32:18 <dmwit> ddellacosta: So the idiom (pre-TypeApplications) was `class NameThatTypep where name :: proxy a -> String`. Then use sites look like e.g. `name (Proxy :: Proxy Bool)`.
13:32:52 <dmwit> ddellacosta: Yep, it's for when you want a map from types to values of some specific type.
13:32:53 <ddellacosta> dataN: that's helpful!
13:33:19 <dmwit> ddellacosta: e.g. some name that we could show to users, or an Int telling the number of bytes used to represent that type, or similar
13:33:19 <ddellacosta> dmwit: okay this is starting to come together I think
13:33:48 <dataN> there is new syntax which says that with AllowAmbiguosTypes and TypeApplications, the function definition can just be written without mentioning all the type parameters to its class, and the ambiguity can be resolved by passing @ symbols instead of using Proxy types, where these "type applications" specifying the class almost like a type annotation 
13:34:10 <ddellacosta> dmwit: any chance you have a good example of a codebase or gist/lpaste I can take a look at to show me an idiomatic usage of this?
13:34:20 <ddellacosta> dataN: interesting
13:34:36 <ddellacosta> it's starting to click but I think I need to read some code first
13:34:59 <dataN> data Proxy (a :: *) = Proxy
13:35:15 <dataN> :t Proxy :: Proxy Int
13:35:16 <lambdabot> Proxy Int
13:35:33 <dataN> @Undefined 
13:35:33 <lambdabot> Undefined.
13:35:39 <dmwit> (Proxy is actualy poly-kinded.)
13:35:45 <dmwit> (Not *.)
13:35:50 <dataN> data Proxy (a :: k) = Proxy
13:36:26 <monochrom> Proxy is the best thing since undefined. >:)
13:36:28 <dataN> right, and if the kind annotation is omitted it still compiles if PolyKinds is off 
13:36:39 <dataN> but then breaks 
13:36:56 <dataN> @let class A a b c where f :: b -> c
13:36:57 <lambdabot>  .L.hs:159:9: error:
13:36:57 <lambdabot>      • Could not deduce (A a0 b c)
13:36:57 <lambdabot>        from the context: A a b c
13:37:08 <dataN> @let class A a b c where f :: Proxy a -> b -> c
13:37:09 <lambdabot>  Defined.
13:37:43 <dataN> @let instance A Int Int Int where f _ b = b
13:37:45 <lambdabot>  Defined.
13:37:54 <dmwit> ddellacosta: http://hackage.haskell.org/package/json-schema-0.7.4.2/docs/Data-JSON-Schema-Types.html is an example, I guess
13:38:03 <dataN> > A (Proxy :: Proxy Int) (1 :: Int)
13:38:05 <lambdabot>  error:
13:38:05 <lambdabot>      Data constructor not in scope: A :: Proxy Int -> Int -> t
13:38:14 <dataN> > f (Proxy :: Proxy Int) (1 :: Int)
13:38:16 <lambdabot>  error:
13:38:16 <lambdabot>      Ambiguous occurrence ‘f’
13:38:16 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
13:38:23 <dmwit> ddellacosta: Though it doesn't use the pre-TypeApplications best practice of the time of using `proxy a` instead of `Proxy a`.
13:38:24 <dataN> > A.f (Proxy :: Proxy Int) (1 :: Int)
13:38:26 <lambdabot>  error:
13:38:26 <lambdabot>      Not in scope: ‘A.f’
13:38:26 <lambdabot>      Perhaps you meant ‘L.f’ (line 159)
13:38:32 <dataN> urgh
13:38:41 <ddellacosta> dmwit: thanks
13:39:04 <dataN> @let class A a b c where functionA :: Proxy a -> b -> c
13:39:05 <lambdabot>  .L.hs:164:1: error:
13:39:06 <lambdabot>      Multiple declarations of ‘A’
13:39:06 <lambdabot>      Declared at: .L.hs:158:1
13:39:10 <dmwit> ddellacosta: I feel like I remember complaining about something in base that made this same mistake (and it got corrected), which would be nice because it would presumably also be a nice simple example, but I can't think of where it was now...
13:39:11 <ddellacosta> and dataN too, thanks for your help in understanding this both of you, I really appreciate it. Going to go bang my head against it some more
13:39:13 <dataN> @Undefined 
13:39:14 <lambdabot> Undefined.
13:39:16 <dataN> @let class A a b c where functionA :: Proxy a -> b -> c
13:39:17 <lambdabot>  Defined.
13:39:25 <ddellacosta> dmwit: ah well, if you think of it let me know!
13:39:26 <dataN> @let instance A Int Int Int where functionA _ b = b
13:39:27 <lambdabot>  Defined.
13:39:35 <dataN> > functionA (Proxy :: Proxy Int) (1 :: Int)
13:39:37 <lambdabot>  error:
13:39:37 <lambdabot>      • No instance for (A Int Int ()) arising from a use of ‘e_11’
13:39:37 <lambdabot>      • In the expression: e_11
13:39:48 <dataN> > (functionA (Proxy :: Proxy Int) (1 :: Int)) :: Int
13:39:50 <lambdabot>  1
13:39:53 <dataN> woot!
13:40:19 <dmwit> ddellacosta: For examples of the pre-Proxy version, check out bitSizeMaybe and bitSize from Data.Bits.
13:40:26 <dmwit> ddellacosta: ...and finiteBitSize.
13:40:29 <ddellacosta> okay cool
13:46:39 <dmwit> ddellacosta: Ah, yes, I remember now: GHC.TypeLits is full of proxies.
13:46:51 <ddellacosta> nice, thanks dmwit
13:47:22 <dmwit> Looks like it still uses Proxy in a few places it doesn't need to.
14:20:07 --- mode: glguy set +v piark_
14:22:48 <GHCBuildingButOu> I'm trying to build GHC on a server with less than a GB of RAM using docker. It's not working. Suggestions?
14:23:07 <hpc> get a gig of ram?
14:23:32 <hpc> or fake it with a swap partition?
14:23:46 <hpc> (not sure how docker handles that sort of thing)
14:24:37 <hpc> i built ghc once on a gig of ram and mentioned it here, everyone was shocked that it actually worked
14:24:49 <hpc> so you need at least that much i think
14:25:38 <dmwit> GHCBuildingButOu: Did you see my suggestions above...?
14:26:04 <davean> swap will be *slow* - why aren't you using a binary dist GHCBuildingButOu?
14:26:55 <GHCBuildingButOu> hpc: I'm on a linode - dmwit I'll look for them.
14:27:12 <fiatjaf> I'm getting Couldn't match type ‘Data.Text.Internal.Text’ with ‘Text’
14:27:41 <fiatjaf> I suppose this is due to some basic misunderstanding all begginers make, right?
14:27:44 <fiatjaf> what is it?
14:27:49 <GHCBuildingButOu> -j1 gave me a different error message
14:28:04 <fiatjaf> (I'm getting an url param from a scotty application and passing it to a hasql statement)
14:28:06 <davean> linode definately provides instances with more than a gig of RAM
14:28:41 <davean> infact, I'm not aware of them offering ones with less
14:29:51 <GHCBuildingButOu> dmwit: can you point me to docs on that environment variable? 
14:30:36 <hpc> fiatjaf: make sure it's the right Text
14:30:44 <hpc> fiatjaf: there's strict and lazy Text types
14:31:15 <fiatjaf> I know, but I'm using the lazy type
14:31:35 <fiatjaf> and apparently scotty and hasql also use the lazy type
14:31:55 <fiatjaf> what if I was using strict and a library required lazy?
14:32:10 <davean> fiatjaf: just convert them
14:32:17 <hpc> ^
14:32:26 <GHCBuildingButOu> It's a 1GB instance with about 250k to overhead/docker
14:33:18 <davean> Do you mean 250MiB? 250k is fairly negligable
14:34:09 <GHCBuildingButOu> hpc: how did you do it on a gig? docker? nix? minimal OS? special env variables? arguments to config?
14:34:29 <hpc> GHCBuildingButOu: just a plain physical debian box
14:34:54 <hpc> it was maybe using swap and i didn't notice?
14:35:16 <hpc> davean is right though, use a binary dist
14:35:29 <hpc> what distro are you on?
14:35:50 <fiatjaf> how do I convert?
14:35:55 <fiatjaf> hoogle isn't helping
14:37:32 <fiatjaf> toStrict / fromStrict
14:37:55 <hpc> heh, beat me to it
14:45:15 <tsaka__> So, I've made a simulator in Haskell. Every n'th simulator iteration, a string is supposed to be printed about run statistics so far. However they all print out instantaneously, with statistics of the initial state
14:45:31 <tsaka__> It seems that lazyness is killing the program; but how can I locate it?
14:45:47 <tsaka__> are not the MonadState and IO monads both sequential?
14:47:55 <davean> tsaka__: IO is (sorta) sequential.
14:48:05 <davean> tsaka__: I expect your code - why don't you show it?
14:48:19 <tsaka__> 1 min
14:49:28 <dmwit> GHCBuildingButOu: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-environment
14:49:47 <tsaka__> davean: https://github.com/tsoernes/haskelldca/blob/bf69c40ab0742823da17ffa080bd9c4f756047e8/src/Simulator.hs#L213
14:50:04 <GHCBuildingButOu> dmwit: thanks!!
14:50:29 <tsaka__> 'Main' pretty much takes you to 'runSim' then it continues upwards on the page (in control flow) from there
14:55:54 <davean> tsaka__: I assume you think statePartM updates the stats in some what or something
14:56:11 <tsaka__> davean: yes, that would be the intention
14:57:13 <lyxia> tsaka__: Did you mean that the state does not seem to be changing?
14:57:28 <davean> tsaka__: so why do you use modify so much?
14:57:38 <davean> tsaka__: whats up with your statePartM code?
14:58:21 <tsaka__> statePartM is a reimplementation of Lens.zoom which is compliant with a MonadRandom constraint instead of StateT
14:59:21 <davean> You could use typeclasses for it though and not convert so much
15:00:24 <tsaka__> can you use multiple typeclasses all of which require some form of state?
15:00:35 <tsaka__> without doing all that zooming/converting
15:01:43 <lyxia> instead of zooming you can use a single MonadState s, and only access parts of s with lenses.
15:01:48 <davean> of course
15:01:57 <davean> it owuld probably make this code a lot simpler
15:02:11 <davean> tsaka__: http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-TH.html#v:makeClassy
15:02:32 <tsaka__> lyxia: that's what I'm doing now
15:03:09 <davean> No, you're not.
15:03:20 <davean> You're using a MonadState SimState
15:03:28 <davean> and a MonadState Stats
15:03:53 <tsaka__> yes, correct. And Stats is  part of simstate, accessed with a lens.
15:04:20 <lyxia> but when you run the inner action, the inner action is not accessing the simstate with the lens
15:04:26 <davean> What lyxia just aid
15:04:40 <lyxia> <3
15:04:50 <tsaka__> no, that's right. State segregation.
15:05:10 <tsaka__> This way, you can see in the function declaraion which part of the state you're accessing
15:05:20 <davean> No you can do that using MonadState s
15:05:30 <davean> all this buys you is a bunch of stuff in the middle
15:06:15 <lyxia> (MonadState Stats m) becomes (MonadState s m, Has s Stats), you can still only see the relevant part of the state.
15:06:25 <tsaka__> by state segregation I mean that different parts of the program are solely responsible for a their own part of the state
15:06:28 <davean> right
15:06:39 <tsaka__> by looking at the function sig. you can see and verify that only sub parts are modified
15:06:42 <tsaka__> right?
15:06:48 <davean> Which lyxia does, you're thing just creates noise
15:06:56 <davean> 's
15:07:39 <tsaka__> so if you're using lenses inside the function instead, you can't easily see, nor verify with types, which part of the (effectively) global state is modified by a function by looking at its signature
15:07:46 <davean> Yes you can
15:07:48 <tsaka__> how
15:07:50 <davean> See what lyxia said
15:07:52 <davean> its right there
15:07:58 <davean> "Has s Stats"
15:08:06 <tsaka__> what is that
15:08:13 <davean> The only thing that knows is that "s" has a Stats component that it can work with
15:08:14 <davean> see my link
15:08:39 <davean> and #~ replaces.
15:08:42 <tsaka__> ahh I see.
15:08:53 <tsaka__> that is pretty cool. ill do that instead
15:10:01 <davean> As a benefit, "s" can be something that the function knows to have any number of pieces 
15:10:09 <davean> so you don't need different types for segrigation
15:18:04 <tsaka__> where is that "Has" from?
15:18:24 <davean> lens
15:18:31 <davean> makeClassy
15:19:28 <tsaka__> Control.Lens? .TH?
15:19:57 <tsaka__> (the new hoogle is down)
15:20:35 <geekosaur> there's some migration going on
15:25:33 <davean> tsaka__: http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-TH.html#v:makeClassy
15:25:59 <max3> can someone explain to me how is it that query1 has the type it does here https://paste.rs/PhW.hs
15:30:24 <lyxia> max3: _join teachers courses _ _ :: [(Teacher, Course)]
15:30:54 <lyxia> max3: so given HINQ (m a -> m b) (m a) (m a -> m a) you get that m = [] and a = (Teacher, Course)
15:31:39 <lyxia> then _select (teacherName . fst) :: [(Teacher, _)] -> [Name]
15:31:48 <lyxia> so b = Name
15:41:39 <abhir00p[m]> Is hoogle down?
15:46:17 <rotaerk> hmm would the 'accelerate' library be useful for writing realtime rendering software, like games?
15:46:34 <rotaerk> is it just for computation (i.e. using the compute pipeline) or does it interact with the graphics pipeline at all
15:47:01 <geekosaur> abhir00p[m], I see discussion of a backend migration going on, so likely some things are down during
15:48:30 <geekosaur> (and may be until subsequent dns updates, also discussed)
15:49:13 <abhir00p[m]> thanks geekosaur 
15:50:08 <mrjake> https://lpaste.net/8509290795696652288 Has anyone had success transferring gzipped data over http?
15:50:28 <max3> sorry i got disconnected but can someone explain to me how is it that query1 has the type it does here https://paste.rs/PhW.hs
15:53:17 <max3> oh i just got it
15:53:35 <max3> the HINQ type is HINQ m a b, which is not the same as the data constructor
15:55:43 <geekosaur> thisis why we often disrecommend using the same name for type and data constructors
15:55:58 <geekosaur> the compiler has no trouble keeping them separate. people, not so much
15:58:05 <max3> geekosaur, yea in the beginning that threw me
16:07:48 <shachaf> Would you say that (exists x. x) has only one inhabitant?
16:07:55 <shachaf> (Or two if you include _|_?)
16:08:47 <shachaf> If so, is there some sort of naturality involved?
16:12:28 <lyxia> It has many inhabitants but they are observationally indistinguishable
16:12:57 <shachaf> How many inhabitants would you say "forall a. a -> a" has?
16:13:01 <lyxia> one
16:13:19 <shachaf> Not many that are observationally indistinguishable?
16:13:32 <lyxia> right
16:13:54 <shachaf> What's the difference between those two statements?
16:14:59 <lyxia> If we call (,) the constructor for exists, (Int, 0) and (Int, 1) are two distinct inhabitants of exists x. x
16:15:12 <lyxia> but you can't write a function (exists x. x) -> Bool to distinguish them
16:15:25 <shachaf> What makes them distinct?
16:15:52 <lyxia> one has a 0 as its second component, the other has a 1.
16:15:57 <granttrec> is miranda off topic here?
16:16:40 <c_wraith> granttrec, probably slightly less than most places. but it's not really on-topic either.
16:18:08 <shachaf> Miranda™ is a trademark of Research Software Limited
16:18:49 <granttrec> ok just want to ask about higher order functions not really miranda specific syntax
16:18:55 <shachaf> lyxia: Yes, but if it's not distinguishable, in what sense is it different?
16:19:13 <piark_> bye
16:22:20 <granttrec> so in this snippet twice takes two arguments but not sure how this is distrubtued on the first line, I know its left assoc but it seems like there are not enough arguments https://paste.ee/p/ZvPna
16:26:26 <lyxia> shachaf: when using the language it's true that we only care about observational distinctions, so I guess the difference only matters for doing metatheory
16:28:06 <learnerx> I can import Test.Hspec just fine, but I can't import Test.QuickCheck
16:28:23 <learnerx> I was under the impression that once I had hspec as a dependency I should be able to import quickcheck without issue
16:30:00 <lyxia> learnerx: no you need to add every package whose modules you import as a dependency.
16:32:42 <learnerx> lyxia appreciate it
16:32:52 <learnerx> I assume quickcheck is in stackage lts?
16:32:57 <lyxia> yes
16:33:24 <learnerx> do I have to do any capitalization tricks
16:33:32 <learnerx> it can't find "quickcheck"
16:33:36 <lyxia> QuickCheck
16:34:03 <learnerx> one would wonder why these things are case sensitive 
16:34:11 <lyxia> indeed, that is silly
16:37:25 <lyxia> granttrec: in this case it might be better to think of functions as only taking one argument (possibly producing another function)
16:39:23 <granttrec> lyxia: is this because of currying or does that not apply here
16:43:12 <fiatjaf> I have an Either and I'm using case .. of to deal with its values
16:43:21 <fiatjaf> how do I use the `do` notation in this case?
16:44:12 <fiatjaf> (specifically, I'm trying to convert a Text into a number using Text.Read.decimal)
16:44:40 <lyxia> granttrec: yes that's currying, twice is curried.
16:44:52 <fiatjaf> I just need an example so perhaps my mind can grasp the concept better
16:45:10 <granttrec> ok that makes sense
16:46:48 <GHCBuildingButOu> dmwit: I set the variable to GHCRTS='-M500M' and new error: ghc: panic! (the 'impossible' happened)   (GHC version 8.2.2 for x86_64-unknown-linux):         heap overflow
16:47:31 <lyxia> fiatjaf: do { x <- u ; v x }   is equivalent to  case u of Left e -> Left e ; Right x -> v x
16:48:15 <lyxia> fiatjaf: do { x <- u ; y <- v x ; w x y }   is equivalent to   case u of Left e -> Left e ; Right x -> case v x of Left e -> Left e ; Right y -> w x y
16:48:51 <lyxia> I can put it in a paste if you'd like to see it indented properly
16:49:21 <fiatjaf> that's not necessary
16:50:18 <fiatjaf> but where do I introduce that do?
16:50:33 <fiatjaf> I'm in the middle of another `do`
16:53:43 <rotaerk> fiatjaf, so? :)
16:54:06 <learnerx> Why does this not compile? It's a quickcheck test
16:54:07 <learnerx>         property $ \xs -> if isValidChannelName "haskell"
16:54:18 <rotaerk> do { a; b; do { c; d; e }; f }
16:54:30 <lyxia> fiatjaf: do blocks are expressions, you can put them anywhere you need an expression of type (Either _ _) for example
16:54:31 <learnerx> https://hastebin.com/ikofoqagex.bash
16:54:34 <learnerx> ^ errror
16:54:54 <dmwit> GHCBuildingButOu: I guess I'm not too surprised that 500MB isn't enough heap to compile GHC.
16:55:12 <learnerx> compiling ghc took over an hour on my machin
16:55:15 <shachaf> lyxia: Would you say "\x -> x" and "\x -> id x" are equal, but (0 :: exists x. x) and (1 :: exists x. x) aren't?
16:55:28 <fiatjaf> main = do { u <- whatever; x <- do { x <- u; y x } }
16:55:35 <fiatjaf> is that correct?
16:56:13 <geekosaur> learnerx, when everything was generaized to Foldable, it became necessary to say wich Foldable in some cases. (in simple cases, it may be able to assume lists)
16:56:44 <learnerx> geekosaur do I need to wrap the whole lambda in a type signature?
16:56:57 <geekosaur> and I'm guessing y6ou also have OvrloadedStrings enabled, othewise the string woudl do it
16:57:05 <learnerx> I don't
16:57:08 <learnerx> well I might
16:57:13 <learnerx> this is the default stack project
16:57:22 <rotaerk> fiatjaf, grammatically, yes, that's fine.  Although:  do { x <- u; y x }  can be replaced with:  u >>= y
16:57:43 <geekosaur> oh, hm, nom, you're not using the strig directly
16:58:11 <geekosaur> so you need to specify that xs :: String
16:58:11 <GHCBuildingButOu> I discovered that free swap is about ~444 so I'm bumping to 1188M...
16:58:48 <fiatjaf> got it.
16:58:49 <fiatjaf> great lesson. thank you lyxia and rotaerk.
16:58:50 <GHCBuildingButOu> new memory error! :)
16:59:02 <rotaerk> fiatjaf, well, technically not fine, in that your last expression within the do block can't be be a <- binding
16:59:44 <GHCBuildingButOu> trying again with make -j1
17:00:04 <lyxia> shachaf: yes, I would consider things equal up to beta-equivalence by default
17:00:10 <geekosaur> learnerx, you can probably just change it to:   elem '#' (xs :: String)
17:01:29 <GHCBuildingButOu> coolio: https://gitlab.com/jgkamat/rmsbolt
17:02:03 <fiatjaf> rotaerk, well, ok, makes sense.
17:02:23 <lyxia> shachaf: There are certainly contexts where we can think of (exists x. x) as having one inhabitant, but parametricity seems more difficult to reason about than beta-reduction in general.
17:02:44 <GHCBuildingButOu> tmux doesn't use a lot of ram, right?
17:02:56 <shachaf> lyxia: Yes.
17:06:35 <geekosaur> GHCBuildingButOu, tmux itself doesn't (usually; don't do something like specifying large amounts of per-window scrollback), things run in it might
17:07:33 <GHCBuildingButOu> ok... I'll try killing tmux and trying the compile again - anecdotally, people have done it on one GB
17:07:53 <GHCBuildingButOu> what about docker?
17:08:43 <geekosaur> most cases I've heard of involved adding swap. and using build flavour quick, which disables optimizations which can take a lot of memory
17:09:18 <geekosaur> ...why would you expect docker to help? it's not going to make your machine have more memory
17:10:44 <GHCBuildingButOu> I mean does docker use a lot of memory?
17:11:01 <GHCBuildingButOu> I'm running docker in tmux...
17:11:18 <GHCBuildingButOu> now I'm running docker without tmux...
17:11:23 <GHCBuildingButOu> omg
17:11:26 <GHCBuildingButOu> it's working!
17:12:10 <geekosaur> it can, yes.
17:12:29 <geekosaur> less than other virtualization/islation solutions, btu f you're short on memory it's better to do without
17:12:41 <learnerx> wait a sec
17:12:45 <learnerx> how does quickcheck work
17:12:47 <GHCBuildingButOu> it's still working!
17:13:01 <learnerx> my test doesn't seem to fail even when my lambda always returns `False`
17:13:01 <GHCBuildingButOu> f'ing tmux!
17:13:23 <lyxia> learnerx: paste your code?
17:14:12 <learnerx> lyxia nvm
17:14:15 <learnerx> was editing the wrong file
17:14:24 <learnerx> how does quickcheck respond to exceptions
17:14:33 <learnerx> will a triggered exception count as a failure?
17:15:07 <lyxia> I think it will
17:15:40 <jle`> oh hey neat, Data.Monoid.Ap is nowin base
17:15:58 <learnerx> doesn't seem to be
17:16:16 <jle`> *now in
17:23:03 <lyxia> @check undefined :: Bool
17:23:05 <lambdabot>  *** Failed! Exception: 'Prelude.undefined
17:23:05 <lambdabot>  CallStack (from HasCallStack): error, called at libraries/base/GHC/Err.hs:79...
17:23:28 <lyxia> learnerx: ^ looks like a failure
17:54:39 <koz_> jle`: I'm just waiting for hdevtools support. :(
17:55:02 <jle`> :(
18:12:46 --- mode: glguy set +v giuseppe_
18:14:22 <GHCBuildingButOu> ok
18:14:58 <GHCBuildingButOu> I got through 270/270 compilations while building GHC (finally)
18:15:21 <jle`> :D
18:15:25 <giuseppe_> guys, i have a university homework in which i need to rewrite the map function. can you guys show me what's wrong with this? https://gist.github.com/agfp/08e2810b71e4e3ee3a52262808d0688f
18:17:32 <jle`> koz_: btw, if you're interested, i wouldn't mind if you helped review my singletons part 3 post before i release it mon or tue :) https://blog.jle.im/entry/introduction-to-singletons-3.html ; note it only covers half as much as i had originally planned because it took longer than i thought
18:17:55 <jle`> giuseppe_: are you defining this in ghci?
18:18:08 <giuseppe_> jle`: yes
18:18:10 <jle`> giuseppe_: if you are, ghci is considering that the second line is "over-writing"/shadowing the first line
18:18:21 <jle`> so it's like defining map, and then re-defining it as map' f (x:xs) = ...
18:18:37 <jle`> that's why you get a non-exhaustive pattern error, since the original map' f [] = ... definition is overwritten
18:19:04 <giuseppe_> thanks
18:19:07 <jle`> if you define it in a file and import the file then you can get the right behavior
18:19:15 <jle`> you can also use a "multi-line" let in ghci
18:19:29 <jle`> let map' _ [] = []; map' f (x:xs) = f x : map' f xs
18:19:41 <jle`> that should define all of map' and its patterns as a single binding
18:21:37 <giuseppe_> jle`: thanks very much man, it worked
18:21:38 <koz_> jle`: Consider it done! 
18:22:08 <GHCBuildingButOu> ghc-cabal: Most RTS options are disabled. Link with -rtsopts to enable them. ghc/ghc.mk:111: ghc/stage1/package-data.mk: No such file or directory make[1]: *** [libraries/binary/ghc.mk:3: libraries/binary/dist-boot/package-data.mk] Error 1 make: *** [Makefile:123: all] Error 2
18:23:10 <GHCBuildingButOu> I have a ghc executable
18:23:49 <GHCBuildingButOu> ghc --interactive tells me `GHCi, version 8.2.2: http://www.haskell.org/ghc/  :? for help`
18:24:14 <GHCBuildingButOu> I built master, why would it be 8.2.2?
18:25:27 <dmwit> Have you installed it? Is the install directory on your PATH? Have you asked your shell to rescan its PATH since it got installed?
18:25:49 <Zemyla> Type "which ghci" in your command line.
18:28:16 <GHCBuildingButOu> oh, yeah
18:28:25 <koz_> jle`: Is there a reason why Decision's Disproved constructor needs a 'Refuted a'?
18:28:31 <GHCBuildingButOu> dmwit: thanks
18:28:34 <koz_> Wouldn't it just be fine to have 'Disproved'?
18:29:20 <dmwit> Hoogle is down. =(
18:30:31 <koz_> Especially given that in the knockSomeDoor example, you just ignore it anyway.
18:33:50 <davean> GHCBuildingButOu: you still haven't said why you're building it instead of using a binary distribution
18:34:28 <koz_> jle`: Also footnote 1 has a typo: it should be '...Haskell where all values...'.
18:41:23 <GHCBuildingButOu> davean: I just needed to prove to myself that I could, plus I wanted to get to where I would be able to contribute to it. I've got several contributions into CPython.
18:42:19 <davean> well then you probably want to avoid the perf build - its by FAR the most expensive and not what you'll want to dev on usually
18:42:35 <davean> Avoiding perf will probably shrink the memory usage and will definately shrink the time
18:49:19 <GHCBuildingButOu> davean: thanks, how do I know the difference between those builds?
18:49:42 <davean> well, its documented on the GHC wiki under building GHC
18:51:51 <davean> Its also documented in mk/build* in the git repo
18:52:05 <GHCBuildingButOu> where's the executable supposed to be?
18:52:36 <GHCBuildingButOu> inplace/bin/ghc-stage2
18:52:41 <davean> yes
18:53:25 <GHCBuildingButOu> that directory doesn't exist...
18:54:22 <davean> root@arm96:~/ghc# ls mk/build.mk.sample 
18:54:24 <davean> mk/build.mk.sample
18:54:32 <davean> If that doesn't exist, you don't have a valid GHC checkout.
18:54:48 <GHCBuildingButOu> ok...
18:55:07 <davean> Maybe you downloaded the source tarball
18:55:14 <davean> which isn't where you'd want to work on patches from
18:55:57 <davean> # Fast build with optimised libraries, no profiling (RECOMMENDED):
18:56:00 <davean> #BuildFlavour = quick
18:56:02 <davean> is probably what you want
18:56:19 <Athas> rotaerk: Accelerate works fine for low-latency things like games.
18:56:23 <GHCBuildingButOu> I used git
18:56:33 <Athas> Many of the Accelerate examples are real-time visualisations.
18:57:10 <GHCBuildingButOu> and the docker buildpath
18:57:25 <davean> GHCBuildingButOu: Did you not run boot?
18:57:32 <GHCBuildingButOu> I ran boot
18:57:49 <davean> http://git.haskell.org/ghc.git/tree/HEAD:/mk
18:57:54 <davean> Like, its in the git repo
18:58:02 <davean> If you don't have it, something is massively wrong
18:58:52 <GHCBuildingButOu> $ ls mk/build.mk.sample returns mk/build.mk.sample
18:59:07 <davean> right, so it exists
19:00:23 <rotaerk> Athas, does it actually use vertex, tesselation, fragment, etc shaders?
19:00:41 <rotaerk> or does it rely strictly on compute shaders for GPU work
19:01:09 <rotaerk> it just seems like a generic "array processing" thing, and I'm not sure how that would relate to shaders...
19:03:10 <rotaerk> I saw that there was a ray-tracer example, but the impression I got was that it was just using compute shaders to do the calculations, and then gloss to display it, rather than using a graphics pipeline
19:05:17 <mac10688> http://hackage.haskell.org/package/servant-0.14.1/docs/src/Servant.API.Sub.html#%3A%3E
19:05:25 <mac10688> In this definition what is k again?
19:05:39 <mac10688> I understand a :: * would be that the a has kind of *
19:05:45 <mac10688> but what is path :: k?
19:05:51 <c_wraith> polykinds
19:05:56 <c_wraith> It's a polymorphic kind
19:06:01 <c_wraith> Could be anything
19:06:17 <mac10688> so what could you not do if :: k was left off?
19:06:17 <c_wraith> *, or * -> *, or (* -> *) -> *, or things that require other extensions
19:06:33 <c_wraith> It would require you to only ever use it with one kind of type
19:07:11 <mac10688> oh
19:07:32 <c_wraith> Actually, it would infer the polymorphic kind with PolyKinds enabled.  In which case, it's really just documentation
19:08:23 <mac10688> interesting
19:10:40 <mac10688> so for that function. k can be anything but a has to be a kind of *
19:10:44 <c_wraith> yes
19:10:57 <mac10688> and one * means it is complete. It doesn't take any more arguments
19:11:23 <c_wraith> Oh, most of the time, the path is probably going to be of kind Symbol (type-level string literal).  Servant uses some advanced features
19:11:52 <c_wraith> Unless it's a fancier segment type
19:12:28 <mac10688> I feel like servant is the most precise and developed piece I've seen so far. It's what I really want. I just have to figure out it's definitions
19:12:46 <mac10688> with servant I see a clear path on how to use purescript with it
19:12:58 <mac10688> if i wanted
19:21:17 <Athas> rotaerk: right, Accelerate is in principle just for computation.  I don't think you can access the graphics-specific hardware.
19:21:28 <rotaerk> I see; thanks
19:21:55 <Athas> But aren't most of those shaders built with the ordinary computation hardware?  There are a few exotic things like texture objects, of course, but the fixed function pipeline is long gone.
19:22:57 <Athas> If you want to do game graphics, you are probably better off using an OpenGL or Vulkan wrapper.  But Accelerate would be a good fit for e.g. the physics engine.
19:23:27 <rotaerk> well, there's a well defined graphics pipeline, at least according to the vulkan spec, but I don't know how much of that is an invention of the graphics APIs and how much of it corresponds to specialized hardware
19:24:18 <rotaerk> yeah, for some of the simulation computations, I'm definitely planning to use compute shaders and considering accelerate
20:04:49 <GHCBuildingButOu> I unset GHCRTS and I'm back in business!
20:05:33 <GHCBuildingButOu> thanks everyone for trying to help me!
20:16:12 <jle`> koz_: Decision a means you can prove yes or no.  Maybe a means you can prove yes, but not no
20:16:45 <koz_> jle`: But Refuted a is a synonym for a -> Void.
20:17:06 <jle`> yeah.  ah, do you mean why it isn't just directly (a -> Void) ?
20:17:17 <koz_> Or why is it there at all?
20:17:29 <jle`> (a -> Void) is a proof for "no"
20:17:34 <jle`> a is a proof for "yes"
20:18:12 <jle`> so it makes it the equivalent of the True/False for normal propositions
20:18:22 <koz_> Yes, I understand that much - but 'Refuted a' is a statement 'no proof can exist'. So why have to construct an a -> Void instead of just having an option to say 'nope'.
20:18:27 <koz_> Let me spell out what I mean.
20:18:51 <jle`> koz_: ah. well, if we used `Maybe a`, and we get `Just`, we know that it's true.  but if we get `Nothing`, there's no information
20:18:56 <jle`> it could be True, it could be False?
20:19:15 <koz_> jle`: data Decision a = Proved a | Disproved.
20:19:21 <jle`> ah yeah, that's what i mean by Maybe
20:19:31 <koz_> If we _have_ a proof, we have it in 'a'. If we don't, who cares?
20:19:31 <jle`> so a decision function is a `Sing x -> Decision (P x)`
20:20:34 <jle`> if decision functions were `Sing x -> Maybe (P x)`, then we have a silly possible function
20:20:39 <jle`> myDecision _ = Nothing
20:21:00 <jle`> it's a guaruntee for the consumer of the Decision that the writer of Decision just didn't write 'const Nothing'
20:21:25 <jle`> if you use a decision function and got Nothing, your response would be 'oh gee, so is it true or not? i'll never know now."
20:22:06 <jle`> if you don't trust the writer of the decision function, you'd never know they were just cheating and wrote const Nothing
20:22:21 <jle`> and also it helps you as someone who is writing the decision function, as well
20:22:31 <koz_> I'm not sure I see how the other definition helps that though.
20:22:32 <jle`> because it prohibits you from being lazy and accidentally saying something isn't true
20:22:43 <koz_> OK, could you please tell me why?
20:22:45 <jle`> you actually have to *prove*/earn your "not true"
20:22:45 <koz_> I'm not seeing it.
20:23:10 <jle`> ah, well, consider the decision function for Knockable, Sing s -> Decision (Knockable s)
20:23:26 <jle`> we know that this is true for 'Closed and 'Locked, but not for 'Opened
20:23:40 <geekosaur> isn't this "absence of evidence is not evidence of absence"?
20:23:56 <jle`> however, if it was Sing s -> Maybe (Knockable s), then we could just write isKnockable _ = Nothing
20:24:16 <jle`> and falsely assert that 'Closed and 'Locked are unknockable
20:24:52 <koz_> But what stops us writing something equally trivial anyway? Can't we just send _every_ case into $ \case and be done?
20:25:05 <jle`> no, because \case {} isn't valid for the 'Closed and 'Locked cases
20:25:12 <jle`> they will be incomplete pattern matches, and therefore a partial (bottom) function
20:25:48 <jle`> (and GHC will warn you as well)
20:26:13 <jle`> we're precluding partial functions and bottom from our discussion, heh
20:26:15 <koz_> I'm sorry if I'm being obtuse, but why would they be incomplete?
20:26:43 <jle`> hm, what situation are you talking about where you would use this?
20:27:21 <koz_> Your claim is that having Decision ~ Maybe can allow us to construct the Ian Paisley proof (NO NO NO NO).
20:27:41 <GHCBuildingButOu> I'm giving up on trying to compile ghc on a linode with 1GB. :/ so what's the right way to get a haskell environment on a box like that anyways?
20:27:42 <koz_> However, I'm not seeing how Decision being written the way it is prevents us from doing something essentially equivalent.
20:27:52 <nitrix> GHCBuildingButOu: docker.
20:28:08 <jle`> koz_: how would you write Sing s -> Decision (Knockable s) in a way that is "wrong" ?
20:28:13 <GHCBuildingButOu> nitrix: not nix? 
20:28:19 <nitrix> There are docker images with GHC environment all setup, ready to run your Haskell applications.
20:28:28 <nitrix> Use nix if you prefer nix.
20:28:29 <koz_> Like, if I wrote isKnockable = \case SOpened -> Disproved $ \case; SClosed -> Disproved $ \case; SLocked -> Disproved $ \case
20:28:39 <GHCBuildingButOu> nah, I want to try docker more.
20:28:50 <koz_> Essentially claiming I've 'disproved' this for everything.
20:29:00 <GHCBuildingButOu> I want to learn Haskell on it.
20:29:15 <jle`> koz_: the SClosed and SLocked cases aren't valid
20:29:24 <koz_> jle`: What makes them invalid?
20:29:25 <GHCBuildingButOu> nitrix: what's the best docker image in your opinion?
20:29:37 <jle`> koz_: you're giving a partial function to Disproved
20:29:37 <koz_> That's the part I'm not seeing.
20:29:49 <koz_> OH!
20:29:53 * koz_ hits self.
20:29:56 <nitrix> GHCBuildingButOu: The idea being that you compile on a system that has more resources for the system that has less resources, but since both environments are identical, you shouldn't have any problems from copying the binary (which, if you do things right, you export/import the image anyway).
20:30:01 <jle`> heh, no need to hit yourself :)
20:30:09 <koz_> OK, thanks, I tripped over syntax.
20:30:13 <koz_> _Now_ it makes sense.
20:30:14 <nitrix> GHCBuildingButOu: No idea. You can make one yourself in a few lines.
20:30:20 <GHCBuildingButOu> I was hoping to get the latest ghc.
20:30:30 <jle`> in the SClosed branch, you'd need to give a (Knockable 'Closed -> Void), but no such total function exists
20:31:04 <nitrix> GHCBuildingButOu: 8.4 ?
20:31:14 <GHCBuildingButOu> I think there's a newer one
20:31:21 <nitrix> Oh 8.6
20:31:21 <jle`> yeah i could probably explain that part a little better :)
20:31:42 <koz_> I'd certainly appreciate such an explanation, because it seriously threw me.
20:31:58 <koz_> I was like 'why isn't Decision just a special kind of Maybe?'.
20:31:59 <GHCBuildingButOu> I'll ask google then
20:32:17 <jle`> koz_: ah, yeah :) it could probably be clearer
20:32:25 <nitrix> GHCBuildingButOu: If you use stack for your project, then you pretty much don't have to worry about it anyway. Stack will download the newer GHC.
20:32:55 <jle`> koz_: another answer that shows up in practice but not much in the post is that we can use the Disproved branch to create more complex proofs
20:33:08 <koz_> But yeah, other than that, this is awesome and I can't wait to teach my first-year logic student^W^W^Wcompiler more logic.
20:33:35 <jle`> thanks for the reading over, i appreciate it :)
20:33:54 <koz_> jle`: No worries - I love the work!
20:34:05 <jle`> but yea if you're interested in more Refuted shenanigans, check out Exercise 3
20:34:13 <jle`> where we use the Refuted branch
20:34:27 <GHCBuildingButOu> nitrix: ok, I rm -rf'd the ghc directory, I'm about to install a new stack now
20:34:34 <jle`> also exercise 2 is fun cause you can use refuted's to build more complex refuted's
20:55:02 <koz_> jle`: Yo dawg, I herd u liek Refuteds...
20:55:33 <jle`> double-negatives become a fun thing if you forget about bottom ;)
20:55:53 <koz_> jle`: Bottom ruins everything.
20:56:07 <jle`> try writing Refuted (Refuted (Knockable s)) -> Knockable s
20:57:00 <monochrom> It's bottom all the way down.
20:57:46 <davean> GHCBuildingButOu: There binary dists for basicly everything - tarballs which you can configure and install for linux/freebsd/osx/windows, or if you use Debian/Ubuntu theres repositories and you can install via that ... etc
20:59:00 <jle`> koz_: it can be useful to just 'pretend' it doesn't exist :) in this case the compiler still helps you prove things so it's just a matter of discipline i suppose
20:59:29 <koz_> Yeah, as with a lot of Haskell things.
20:59:55 <koz_> jle`: Could you give me some advice/guidance/rules/logical reasoning about when I should use Control.Monad.State.Lazy versus Control.Monad.State.Strict?
21:00:07 <jle`> koz_: btw, what footnote typo are were talking about earlier?
21:00:16 <koz_> jle`: 'haskell' instead of 'Haskell'.
21:00:25 <koz_> Footnote 1.
21:00:46 <jle`> ah, i see, thanks :)
21:01:14 <jle`> hm, i haven't worked too much with the difference between them.  i know the lazy version can be used to do some effects interleaving stuff
21:02:05 <jle`> but that's not something i would ever really rely on
21:02:25 <koz_> I've used lazy state to do something like nub infinite lists (after which I take the amount I really needed), but otherwise, no ideas.
21:02:56 <jle`> yeah, i'd prefer a more principled method of dealing with evaluation
21:03:21 <koz_> jle`: What do you mean?
21:03:50 <jle`> a kind where things don't explode if you look at them the wrong way
21:04:22 <koz_> Lol, fair enough.
21:05:32 <GHCBuildingButOu> davean: I was hoping to use 8.6...
21:06:35 <koz_> jle`: I think in a less busy week, and when I've gotten the worst uglies out of it, I might blog about that typesafe Gamberger-Lavrac implementation.
21:06:49 <koz_> I did a _significant_ refactor on it to make it less hideous, but it still has some very inelegant moments.
21:11:30 <jle`> koz_: would be happy to read that post :D
21:24:41 <orzo> What's a good lookup-table for 32-byte keys?
21:25:00 <orzo> Data.Map? bytestring-trie?  Nested IntMap?
21:25:40 <orzo> HashMap?
21:26:16 <orzo> considering I expect the 32 bytes to be fairly random, maybe just taking the first 8 as an Int hash with HashMap would be best
21:27:20 <koz_> orzo: HashMap would be my suggestion.
21:27:21 <orzo> 32byte lookups are pretty common as it's the sha256 size or curve25519 public key size
21:27:33 <koz_> jle`: I might need your help eliminating those inelegancies.
21:28:04 <orzo> koz, hashmap with the hash i said, or hashmap with whatever is default hash for bytestring
21:28:55 <koz_> orzo: Given that you know it's 32 bytes, you probably might want a fixed-length newtype wrapper with a Hashable instance. Whether the 'first 8 bytes' thing works or not I can't really say.
21:30:04 <orzo> in my particular situation, i'm looking at X25519 public keys
21:30:26 <orzo> i'd also want it to be suitale for sha256 hashes
21:31:45 <orzo> i could save the 32-byte word as 4 Word64s and just use the first one, or if that's a bad idea, xor them or something
21:31:59 <koz_> orzo: There's a package you might find useful for that.
21:32:07 <orzo> oh yea?
21:32:27 <koz_> https://www.stackage.org/lts-12.11/package/data-dword-0.3.1.2
21:33:10 <`Guest00000> *what* does (***) actually do? how do you name the operation? what's the verb?
21:33:19 <koz_> :t (***)
21:33:20 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:33:22 <`Guest00000> (.) is composing
21:33:27 <`Guest00000> (***) is juxtaposing?
21:34:04 <orzo> it's a cartesion product on functions
21:34:19 <koz_> orzo: That's _one_ interpretation of it, yes.
21:34:23 <koz_> It works for arbitrary arrows.
21:34:31 <koz_> Basically, you run both of the input arrows 'in parallel'.
21:34:32 <orzo> (f *** g) x = (f x, g x)
21:34:43 <orzo> i mostly use it as this
21:34:56 <orzo> s/mostly/always/
21:35:04 <koz_> orzo: I'm rather fond of (>>>) for similar purposes.
21:35:05 <orzo> you've used it otherwise?
21:35:10 <`Guest00000> it's a (natural) language question
21:35:13 <julianleviston> I got the impression he was asking how you say it
21:35:16 <julianleviston> s/he
21:35:20 <`Guest00000> related to FPLs
21:35:25 <koz_> `Guest00000: Oh, OK.
21:35:26 <koz_> Not sure then.
21:35:39 <julianleviston> then again hwo do we say (.) generally? I usually say “dot”.
21:35:45 <koz_> I always wonder how to say the 'symboly' names.
21:35:52 <julianleviston> how do we say (>>=)? I usually say “bind”
21:35:53 <koz_> julianleviston: I use 'dot' also.
21:36:06 <orzo> i don't say "dot" for compose
21:36:06 <julianleviston> what about (>>) ? I usually say greater greater
21:36:08 <`Guest00000> but what does (.) do? it *composes*
21:36:22 <julianleviston> so the fact that we all say different things makes me think maybe it’s just not important what we say.
21:36:38 <koz_> julianleviston: It can be helpful to have a consistent vocabulary.
21:36:47 <`Guest00000> BUT, OTOH, if it was *really* unimportant what wa say...
21:36:54 <julianleviston> It can be… but it doesnt matter much.
21:37:10 <julianleviston> I say only as much as I need to say to get the meaning of what I mean across as do we usually all right?
21:37:15 <orzo> since *** is a cartesian product, maybe "product with"
21:37:25 <julianleviston> sounds good… if it conveys the meaning
21:37:52 <julianleviston> what do we call (natural language) “…” ? some people call it elipsis, others call it dot dot dot.
21:37:56 <julianleviston> Does it matter?
21:38:23 <orzo> .. is common in haskell, but ... is unusual
21:38:39 <julianleviston> I’m talking about three dots… irrespective of whether it’s haskell or another language (like say english)
21:38:46 <`Guest00000> i have an inclination to make my speech correctly interpretable in presence of only little, basic context
21:38:58 <julianleviston> me too
21:39:06 <orzo> i wonder why .. was chosen in a situation where english language and mathematical tradition both use ...
21:39:10 <julianleviston> there are always assumptions tho… and that’s fine.
21:39:22 <`Guest00000> orzo: [-5..5] in pascal
21:39:36 <`Guest00000> var a: array [0..999] of Integer;
21:39:42 <julianleviston> probably laziness… I dn’t wantt o type … if I can type ..
21:40:00 <`Guest00000> maybe this can be counted as 'PL tradition'
21:40:06 <julianleviston> how do we pronounce [1..2]? sometimes I say “a range from one to two” but mostly I say “1 dot dot 2"
21:40:10 <orzo> yeah, but you also don't want all the small operators reserved by the prelude
21:40:16 <orzo> or syntax
21:40:22 <`Guest00000> my question is less about pronunication
21:40:26 <julianleviston> that’s probably another discussion.
21:40:34 <`Guest00000> and more about terminology
21:40:41 <julianleviston> `Guest00000: what do you mean? ;-)
21:41:02 <julianleviston> are you asking “well if (.) is function composition, what is…”?
21:41:29 <orzo> I don't know why, but in math, I always want to see a comma before the ... if it implies a continuing list, so the lack of the comma is jaring in haskell
21:41:55 <julianleviston> I think orzo answered you `Guest00000 
21:42:15 <julianleviston> `[1,2..8]` ?
21:42:52 <orzo> yeah [1,2..8] looks bad to me, should be [1,2,...8] or even [1,2,...,8]
21:43:09 <julianleviston> oic
21:43:44 <`Guest00000> i'm asking, what's best way to name what (***) does in neutral style
21:44:11 <orzo> . is to "compose" as *** is to "product with"
21:44:14 <orzo> that was my answer
21:44:28 <julianleviston> yeah he answered you… > orzo: it's a cartesion product on functions
21:44:36 <`Guest00000> Arrow in haskell really is for computations
21:44:54 <`Guest00000> so it seems it isn't just "product with"
21:45:12 <`Guest00000> what does (***) do with computations?
21:45:27 <orzo> it forms their product :P
21:45:57 <orzo> i guess you could say "cartesian product with" if you really feel it's unclear
21:46:48 <`Guest00000> "cartesian product with" is less clear than what i want
21:47:03 <`Guest00000> so. i'll use 'juxtaposing'
21:47:31 <`Guest00000> because you can't tell a programmer "function f is cartesian producted with function g", they won't understand you
21:47:48 <orzo> not even a haskell programmer?
21:47:51 <orzo> heh
21:48:02 <`Guest00000> not any one
21:48:07 <`Guest00000> (***) is very basic
21:48:52 <orzo> haskellers talk about "product types"
21:49:08 <orzo> that seems uncontroversial
21:49:13 <orzo> so why not product functions
21:51:02 <orzo> product functions is what you need in order to act on product types
21:56:49 --- mode: ChanServ set +o glguy
21:57:52 <orzo> I think that if *** is juxtaposing, then (.) is "nesting"
22:00:29 <orzo> It'd probably be a strange kind of justice if we eschewed all math vocabulary and spoke stricktly in in-group jargon
22:00:44 <julianleviston> (.) is **function** composition, right? is (***) **type** composition?
22:00:54 <`Guest00000> "if we eschewed XXX and spoke in YYY"
22:00:54 <julianleviston> most likely entirely not.
22:01:46 <`Guest00000> what does it mean to compose types?
22:02:25 <`Guest00000> maybe type composition is value-kind relation
22:04:15 <julianleviston> this conversation seems a little bit… fraught… mostly because FP doesn’t have a good set of meta-terms for these things. Category theory sort of does… 
22:04:34 <julianleviston> ironically we need a metalinguistic algebra ;-)
22:05:12 <orzo> I actually think more highly of programmers track record at creating jargon than mathematicians who seem to put little or no thought into it
22:05:26 <orzo> Take "category" for example, or "group"
22:05:38 <orzo> such ridiculously general english words
22:05:51 <julianleviston> thats the point tho
22:05:57 <orzo> at least a programmer would have the decency to coin something people would recognize as something they don't know
22:06:12 <julianleviston> ah
22:06:56 <julianleviston> Like, say, int or number? :lol:
22:07:25 <orzo> number is programmer jargon
22:07:33 <orzo> int is, and makes my point
22:07:57 <julianleviston> Int isn’t always the same, tho. 
22:08:14 <julianleviston> it’s too difficult a topic to expect any kind of sane answer IMO
22:08:49 <orzo> a better counter-example to my faith in coders would be "class"
22:09:06 <orzo> and "type"
22:09:26 <orzo> which are as bad as group and category
22:10:44 <orzo> i'll chalk it up to the bad influence of math people though
22:10:48 <orzo> :P
22:12:02 <granttrec> i feel really dumb I need a break down of this function: add x y = x + y, so all functions will be curried so the type is Num x => x -> x -> x so add x y is left associative
22:12:26 <granttrec> but I cant visualize how this happens
22:12:34 <orzo> is this some kind of brain teaser compsci class question?
22:12:53 <orzo> oh wait
22:12:57 <mniip> granttrec, left associative?
22:12:58 <mniip> what
22:13:00 <orzo> nm, i missed the word "add"
22:13:15 <mniip> you mean 'add x y = (add x) y
22:13:16 <mniip> '
22:13:25 <orzo> i thought you were making a recursive function x y = x + y, which must have a strange Num instance
22:13:35 <granttrec> mniip: yeah
22:14:12 <julianleviston> add = \x -> \y -> x + y
22:14:21 <mniip> well that declaration desugars into- what julianleviston juts said
22:15:02 <`Guest00000> orzo: maybe mathematicians and programmers are doing exact same thing? mathematicians deal with mathematics, programmers deal with programming idioms. mathematics is much more abstract than programming idiomatics
22:15:06 <julianleviston> This might help granttrec http://www.happylearnhaskelltutorial.com/1/make_decisions.html#s8.7
22:16:12 <`Guest00000> maybe the process of term coining is similar or same, and the level of abstractness of concepts influences the level of generality of terms?
22:16:31 <mniip> `Guest00000, are you talking about Control.Arrow.***
22:16:32 <orzo> i odn't think so
22:16:38 <`Guest00000> mniip: right
22:17:06 <mniip> that's evidencing the cartesian structure of the category
22:17:17 <`Guest00000> ohoo
22:17:20 <`Guest00000> "evidencing"...
22:17:22 <julianleviston> `Guest00000: language unfortunately *implies* perspective, and so we won’t most likely ever get to a single viewpoint on a thing… so it’s fine to have many ways to talk about things… but it implies that we’ll need to know the audience of our communication if we want to make clear communication…
22:17:27 <mniip> witnessing?
22:18:01 <mniip> no, evidencing is an actual word
22:18:07 <`Guest00000> that's very technical on the conceptual level
22:19:46 <granttrec> so add 2 1 is applied on 2 first which results in what?
22:20:07 <orzo> in a function that adds 2 to it's argument
22:20:17 <mniip> granttrec,   add 2 = (\x -> \y -> x + y) 2
22:20:21 <mniip> = \y -> 2 + y
22:21:26 <mniip> `Guest00000, if you're familiar with diagrammatic properties of bimonoidal categories, this is like placing two arrows alongside eachother
22:22:01 <granttrec> so its safe to say from left to right it creates/returns a function ? or I am still not getting it
22:22:18 <orzo> at least programmers use of "type" and "class" are pretty general things, but mathematicians take general words like "field" and use it to refer to fairly specific things (at least in so far as math subject matter)
22:22:36 <orzo> they do it a lot 
22:22:51 <mniip> granttrec, are you familiar with any other programming languages
22:23:22 <granttrec> yeah java, c, python, octave etc
22:23:34 <`Guest00000> maybe it seems to you that "class" is general because you're a programmer and 'class' is really general in programming... but ungeneral just commonly
22:23:35 <mniip> okay, a direct translation into python would be
22:23:43 <mniip> add = lambda x: lambda y: x + y
22:23:49 <`Guest00000> maybe it would be the same with 'field' and mathematicians
22:23:51 <mniip> and then you invoke it with  add(2)(1)
22:24:08 <`Guest00000> as a structure, field is abstract...
22:24:42 <mniip> `Guest00000, you seem to have spiraled down to philosophy
22:27:15 <granttrec> mniip: thank you
22:27:38 <`Guest00000> (interesting, why is 'to spiral' used commonly in place of 'to fall down'...)
22:28:12 <mniip> to indicate the gradual descent rather than an ever accelerating freefall
22:28:51 <geekosaur> airplanes in uncontrolled descent have a certain tendency to do that (see also tailspin)
22:29:19 <geekosaur> aklthough that's not usually "gradual"
22:29:40 <mniip> etymology man!
22:30:23 <julianleviston> This conversation has gone off topic.
22:30:57 <`Guest00000> let's talk about writing airplane software in haskell...
22:32:30 <granttrec> lol
22:32:43 <mniip> I would guess airplane software needs realtime guarantees
22:32:46 <mniip> which haskell is not great at
22:33:23 <`Guest00000> (stop the world... let's garbage collect.)
22:33:34 <`Guest00000> stop the airplane
22:35:01 <geekosaur> don't they already have to deal with bsods in flight?
22:39:09 --- mode: glguy set +v randomHuman
22:39:38 <randomHuman> i have a small doubt https://lpaste.net/6408354495717179392 
22:42:18 <cocreature> randomHuman: you can certainly reference it but if you try to use it such that m = IO and there is no instance you will get a type error
22:42:42 <cocreature> if there would be an instance then you could use it in that way
23:07:02 <koz_> If I have some kind of AST type, and I wanna do transformations on it, what would be a good choice of library?
23:08:52 <cocreature> koz_: depends on your transformations I suppose. biplate (or the lens implementation of biplate) can often be convenient
23:09:07 <koz_> cocreature: Is biplate a library name?
23:10:45 <randomHuman> Couldn't match type ‘[Char]’ with ‘Char’  arising from the literal ‘"HelloWorld"’ what does this mean ?
23:10:46 <julianleviston> http://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Biplate.html
23:10:48 --- mode: glguy set +v piyush-kurur
23:11:02 <koz_> julianleviston: Thanks.
23:11:26 <piyush-kurur> cabal haddock --builddir="$dir" --for-hackage --haddock-option=--hyperlinked-source does not seem to produce the documentation tarball
23:11:36 <julianleviston> comes from the scrap your boilerplate paper originally, I’m pretty sure.
23:11:40 <piyush-kurur> is there something that I am missing cabal version 2.2
23:12:10 <piyush-kurur> cocreature: cabal-install version 2.2, it does not seem to
23:12:10 <piyush-kurur> 	       produce documentation locally using the --for-hackage flag
23:12:11 <julianleviston> randomHuman: [Char] is String. 
23:12:26 <piyush-kurur> oops I am completely confused with this voiced thing
23:12:41 <piyush-kurur> let me try again
23:12:50 <julianleviston> randomHuman: (ie String is an alias for a List of Char)… so it’s possible you’re passing a String where it’s expecting a Char I guess
23:16:08 <cocreature> piyush-kurur: that should work I think? where have you looked for the tarball?
23:16:09 <mac10688> in servant i see i can declare a type like this
23:16:10 <mac10688> type UserAPI3 = "users" :> "list-all" :> "now" :> Get '[JSON] [User]
23:16:15 <cocreature> piyush-kurur: also you might want to upgrade to 2.4
23:16:39 <mac10688> how can i declare a type like that? I thought types were like type UserApi3 = [String]
23:16:54 <mac10688> is there a language extension that let's me declare types like that?
23:17:06 <geekosaur> randomHuman, you might show the code that produced that error. to a pastebin like gist.github.com, preferably
23:17:19 <geekosaur> mac10688, several in fact :)
23:17:37 <piyush-kurur> cocreature: okey so my message was getting there
23:17:52 <mac10688> oh
23:17:56 <piyush-kurur> It creates a directory with all the relevant contents
23:18:04 <piyush-kurur> but not its tarball
23:18:28 <piyush-kurur> cocreature: okey I missed the 2.4 thing I will try out
23:18:34 <cocreature> piyush-kurur: maybe try new-haddock? it’s been a while since I’ve used the non new-* stuff
23:18:43 <cocreature> in that case the flag is --haddock-for-hackage
23:20:35 <geekosaur> mac10688, https://haskell-servant.readthedocs.io/en/stable/tutorial/ApiType.html look at the pragmas in the program header
23:21:18 <piyush-kurur> cocreature: thanks I will try
23:21:54 <cocreature> piyush-kurur: maybe builddir just doesn’t apply and it still ends up in dist?
23:22:03 <cocreature> I definitely have built doc tarballs with 2.2
23:23:47 <mac10688> thanks geekosaur i was checking them out earlier. I get how the typeoperators let's me use :> but DataKinds is kind of eluding me
23:23:55 <mac10688> http://ponies.io/posts/2014-07-30-typelits.html
23:24:01 <mac10688> this looked like a good article on datakinds
23:24:13 <mac10688> but I don't see about using strings as types, just Symbol
23:24:37 <cocreature> mac10688: string literals at the type-level have kind Symbol
23:24:39 <geekosaur> that is a little unclear at first. the kind of a type-level string is Symbol
23:25:00 <mac10688> Is this stuff considered intermediate haskell or advanced?
23:25:07 <mac10688> ok so datakinds let me use strings
23:25:43 <mac10688> I think if I have a better understanding of DataKinds, the servant api will make a lot more sense to me
23:25:55 <mac10688> because they use that and Proxy a lot
23:26:09 <mac10688> i kind of get the idea behind proxy
23:26:16 <cocreature> I’d say it’s definitely advanced
23:27:05 <mac10688> good because I'm getting tired of finding out there's a whole other layer to this onion before I can use haskell comfortably. Knowing this is considered advanced gives me hope to keep going
23:30:03 <cocreature> mac10688: if you’re looking for something easier to get started with, maybe take look at scotty instead of servant
23:30:04 <geekosaur> servant tries to kep thinsg to where they can give you recipes without your havingto understand the whole type level schtick
23:31:28 <mac10688> thanks. I've checked scotty but Servant gives me a better feeling on the inside. I just have to dig deep and get through this. I know glory is waiting for me
23:31:53 <mac10688> servant on the backend and purescript on the front end will make my year
23:32:35 <maerwald> scotty is much much easier
23:33:57 <maerwald> if you don't want to generate clients, scotty is a better choice imo
23:34:06 <piyush-kurur> cocreature: okey I moved to cabal 2.4 and everything was easy thanks (new-haddock + upload)
23:35:31 <cocreature> piyush-kurur: glad to hear that!
23:35:51 <piyush-kurur> cocreature: one problem though
23:36:18 <piyush-kurur> my package uses backpack and now there is almost no documentation as the haddock stuff is in the signature files
23:36:44 <piyush-kurur> It is not clear how to enable displaying those
23:38:44 <cocreature> I don’t think there is a good story for haddock and backpack atm but it might be worth checking the haddock issue tracker
