00:07:24 <trcc> ricky_clarkson: yaay. Working 
00:07:27 <trcc> Thank you
00:12:05 <SaraDR> Hi humanoids! I'm trying to understand Tasty/hunit, for writing unit testing.
00:12:16 <SaraDR> I'm not sure how to unit test, if a monad fails: https://pastebin.com/raw/5DSvQc02
00:12:51 <jle`> SaraDR: you can't directly check if all monads fail in general
00:12:56 <jle`> SaraDR: but you can look at properties of your specific monad
00:13:18 <jle`> SaraDR: remember that fail is just a typeclass method that all monads implement in their own way
00:13:28 <jle`> there actually aren't any laws involving fail that all monads are required to follow
00:13:42 <SaraDR> And I set that to an Either type, so fail maps to Left string.
00:13:43 <jle`> so there is no 'universal' fail behavior you can exploit
00:14:07 <SaraDR> I guess maps is a wrong word, but I defined my fail to Left String
00:14:45 <SaraDR> And when I unit test, it works fine when I do Right <some value>, but not sure what I should compare with when I do Left, for things that called fail.
00:14:53 <jle`> yeah, you can check if something is Left, but it's possible that there are other ways to get a Left that don't involve fail
00:14:59 <jle`> SaraDR: ah, i see
00:15:13 <jle`> SaraDR: you can check if `isLeft x` is True
00:15:22 <jle`> :t isLeft (Left "hello")
00:15:25 <lambdabot> Bool
00:15:26 <jle`> > isLeft (Right True)
00:15:29 <lambdabot>  False
00:15:29 <jle`> > isLeft (Left "hello")
00:15:32 <lambdabot>  True
00:15:44 <jle`> or well, you can check if `isLeft x` if you can check predicates in general
00:16:37 <SaraDR> I'll a bit and see if I can make that work then, thanks jle`.
00:16:56 <jle`> np
00:17:21 <jle`> and again it doesn't necessarily test if 'fail' is called because you might have gotten a Left in ways that don't involve fail
01:08:35 --- mode: glguy set +v austin
01:10:44 <austin> haskell
01:10:54 <Rembane> YEs!
01:18:47 <Ariakenom> austin: your first message seems to have been. lost you probably have a pm
01:19:34 <Ariakenom> ... been lost. you ...
01:40:35 <bahamas> hello. I want to modify programmatically the file used by hpack (package.yaml). I see that hpack exposes some modules, but it's not clear to me what I can use to access settings from the file. does anyone have any idea?
01:41:25 <merijn> Only unhelpful ones :p
01:41:43 <bahamas> merijn: we can start with them
01:44:19 <merijn> bahamas: I don't actually use hpack, so most of my suggestions would consist of either 1) write your own parser/prettyprinter for it or 2) don't use it, neither of which are particularly helpful :p
01:45:27 <bahamas> alright
01:49:29 <merijn> bahamas: But why exactly are you needing/wanting to modify them programmatically?
01:53:52 <bahamas> merijn: I want to be able to add a library to dependencies in the same style as yarn add or cargo add
02:30:18 --- mode: glguy set +v guessWho
02:30:42 <guessWho> how to deal with -Wsimplifiable-class-constraints are they any resources ?? i couldn't find much 
02:32:30 <merijn> that warning is so new Google doesn't even find anything...
02:33:08 <merijn> As for what to do about it. Well, simplify your class constraint?
02:33:18 <merijn> guessWho: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wsimplifiable-class-constraints
02:40:54 <maerwald> Network.BSD is gone, what are you supposed to use instead?
02:41:56 <merijn> maerwald: Gone from where?
02:42:04 <maerwald> well, not gone, but deprecated
02:42:32 <maerwald> I don't see any information what to use instead
02:43:37 <merijn> Depends on what you were using it for?
02:45:53 <maerwald> getHostByName and getHostName only it seems
02:46:48 <merijn> Pretty sure you can replace those with getAddrInfo
02:46:52 <merijn> from Network.Socket
02:53:52 <thyr15t0r> hello folks! i am full total beginner. what diferent between import Data.List and :m + Data.List?
02:55:10 <xanderio> thyr15t0r: the last one only works in ghci
02:55:42 <thyr15t0r> <xanderio> thanks
03:02:16 <thyr15t0r> may I use $ instead . sometimes?  fn xs=sum . replicate 100 $ length xs is same  fn xs=sum $ replicate 100 $ length xs
03:02:37 <merijn> thyr15t0r: You should always prefer . over $
03:03:20 <thyr15t0r> is dot faster than dollar?
03:03:56 <byorgey> no
03:04:10 <merijn> Dot is more future proof. If you have a long sequence functions being composed, then you can lift any random sub-section out, assign it to a name to refactor the sequence
03:04:25 <merijn> This does *not* work with $ as the result isn't guaranteed to type-check
03:04:25 <byorgey> thyr15t0r: do you know the definitions of ($) and (.) ?
03:04:48 <cocreature> “you should always prefer . over $” is somewhat misleading. you can’t always replace one by the other
03:05:07 <thyr15t0r> <byorgey> yes. but sometimes i can use $ and . as same functions
03:05:15 <merijn> cocreature: "prefer . over $" obviously carries the implicit context "if both work"
03:05:31 <thyr15t0r> thanks guys
03:05:35 <elated> . is more fun
03:05:36 <merijn> cocreature: You cannot prefer . if it doesn't work
03:05:38 <byorgey> thyr15t0r: no, they aren't the same function.  Sometimes either one works just because  (f . g) x = f (g x) = f $ g x
03:05:56 <cocreature> merijn: right, I know what you are trying to say but I have seen more than one beginner assume that (.) and ($) are always interchangable so I wanted to point that ou explicitely
03:08:01 <tdammers> actually, dot vs. dollar may occasionally hit different optimization paths in GHC, and that could, in theory, make one approach faster than the other, especially in code that uses lots of INLINEs and RULEs. But in a perfect world, GHC's optimizer should be good enough to end up optimizing both constructs into the exact same intermediate code
03:09:20 <tdammers> merijn: preferring things that don't work is how PHP folks roll though, and they seem to be doing fine (where "fine" is defined according to that comic with the melting dog)
03:14:31 <Boomerang> (.) vs ($) also matters with ImplicitParams or reflection. Constraints aren't propagated the same way and if I remember correctly GHC cheats a bit with ($) to make it work as it does.
03:15:05 <xanderio> is there a way to crose-compile haskell
03:15:26 <dstolfa> xanderio: i don't see why not, given it uses LLVM?
03:15:50 <dstolfa> unless there's some nasty bits about runtime
03:16:01 <cocreature> things are more complex than “ghc uses llvm” but yeah you can cross-compile
03:16:30 <dstolfa> cocreature: sure, i'm simplifying, but in principle you should be able to just use a different llvm backend (modulo all the bits in the runtime of course)
03:17:04 <cocreature> dstolfa: not really, the LLVM IR emitted by GHC is already target specific (e.g. word sizes are fixed)
03:17:13 <cocreature> and that ignores cross-compiling TH which is far from trivial
03:17:40 <dstolfa> cocreature: that's a bit unfortunate
03:17:43 <dstolfa> but as long as it works
03:18:09 <superlinux> hello. I am trying to install yesod. and when I use `stack build` , I am stuck at this point. I use linux btw. Configuring pcre-light-0.4.0.4...    Cabal-simple_mPHDZzAJ_2.2.0.1_ghc-8.4.3: The program 'pkg-config' version    >=0.9.0 is required but it could not be found.
03:18:18 <merijn> Also, LLVM is far from the default for GHC
03:18:34 <merijn> superlinux: You don't have libpcre installed
03:18:39 <cocreature> right although as long as you stick to the supported version of LLVM it usually works fine
03:18:41 <superlinux> i did
03:18:51 <merijn> superlinux: pkg-config is for C libraries
03:18:57 <superlinux> i installed : apt-get install libpcre-dev
03:19:02 <dstolfa> yeah changing llvm versions is god awful for any compiler
03:19:16 <merijn> superlinux: Apparently your pkg-config setup is not aware of it being installed
03:19:35 <cocreature> it’s not complaining about not finding pcre, it’s complaining about not finding pkg-config
03:19:43 <cocreature> so you need to install that as well
03:19:44 <merijn> oh, right
03:20:02 <superlinux> ah right yes.
03:20:24 <superlinux> cocreature, so what should I do to get pkg-config?
03:20:38 <merijn> apt-get install pkg-config, presumably
03:20:44 <cocreature> yeah
03:21:21 <superlinux> merijn, I have just done it.. I will see if it works now 
03:21:42 <merijn> superlinux: Your pkg-config install also has to be aware of the pcre lib
03:21:53 <superlinux> pkg-config is missing . I installed it
03:22:14 <cocreature> superlinux: do you have an executable called pkg-config?
03:22:23 <cocreature> maybe it’s split up in pkg-config and pkg-config-dev or something like that
03:22:29 <superlinux> it works now. thanks.
03:22:38 <superlinux> it's moving on
03:24:18 <superlinux> good. compilation is done.
03:24:23 <superlinux> thanks fellows
03:24:24 <maerwald> merijn: well, getAddrInfo is much more shaky and more work.
03:24:38 <maerwald> no idea why they thought it's a good idea to remove simple functions
03:29:10 <maerwald> now you get back SockAddr and have to pattern match against it, decide what happens for non-matches...
03:30:38 <maerwald> basically re-implementing what was already there :>
03:37:50 --- mode: glguy set +v dataN
03:38:18 --- mode: glguy set +v dataN_
03:38:27 <dataN_> class q (forall a.Definition q a) => Defines q where data Definition (q :: * -> Constraint) (a :: *) :: *
03:56:39 <xacktm> hi I have two data types that are semantically similar and want to map them to a "meta type"  Example is data Foo { fooTitle :: Text } ; data Bar { barTitle :: Text } and I can map them to data Meta { title :: Text } - I can write `mkMetaFromFoo :: Foo -> Meta` and `mkMetaFromBar :: Bar -> Meta` but can I write a function `mkMetaFromAnything` ?
03:56:55 <maerwald> That's one thing that has to change in the haskell ecosystem: just removing API. You deprecate it, add migration instructions in your changelog and remove it after 1-2 years. Currently it's just remove and publish. And then people are confused why we have version bound mess
04:03:53 --- mode: glguy set +v Alex_
04:04:52 <dataN_> as the above requires quantified constraints, a "flagged" version can be used. this has the advantage of allowing the user to choose between various instances by supplying different values of this Flag type;
04:04:58 <merijn> xacktm: You could make a typeclass and make Foo and Bar instances, but not sure that's worth the bother
04:05:25 <dataN_> class Define q where data Definition (q :: * -> Constraint) (a :: *) :: *
04:05:29 <Alex_> Hello! How do I make Boehm-Berarducci encoding of inductive type where one of self-references is parameterized with different type? I.e. `data F a = Empty | NonEmpty (F Int)`
04:05:37 <dataN_> class Define q => Flagged q where 
04:05:46 <dataN_>  type Flag q
04:05:50 <dataN_>  definition :: Flag q -> Definition q (a !?)
04:06:13 <xacktm> hmm
04:24:07 <mpickering> Has anyone used `hpp` rather than `cpphs`, do they work comparably?
04:34:49 <mpickering> Nevermind, I don't even need any cpp
04:36:11 --- mode: glguy set +v hpc
04:36:14 --- mode: glguy set -v hpc
04:36:25 <hpc> mpickering: that's pretty much how every "how do i X in CPP" question goes
04:37:33 <mpickering> the concept of CPP is somewhat good
04:37:36 <mpickering> the implementation is very bad
04:40:41 <tdammers> CPP sits in an awkward niche between plain old code writing and full-on literate programming
04:42:02 <hpc> i think i would describe CPP as a bash-level tool
04:42:08 <hpc> it treats code as strings
04:42:20 <hpc> and you might as well just run sed in your Makefile instead
04:42:48 <tdammers> well yeah
04:42:53 <hpc> a true language preprocessor would operate on the data structures of the language
04:43:14 <tdammers> or, if you have to use a dedicated tool, make it more powerful, which, if you do it in full consequence, amounts to literate programming
04:43:22 <hpc> common lisp has that, though it's lacking in a lot of ways
04:43:33 <hpc> scheme has better macros
04:43:36 <tdammers> Haskell has TH, but that too is lacking direly
04:43:37 <hpc> template haskell is typed
04:43:46 <merijn> Typed TH is quite nice
04:44:06 <tdammers> one thing that is painfully lacking in TH is the ability to manipulate modules and imports
04:44:09 <hpc> i think my issue with TH is that the language is already so powerful
04:44:27 <hpc> i don't think there's any value in metaprogramming if you already have everything you would ever want and more at the regular programming level
04:44:35 <maerwald> tdammers: please, you want ruby? write ruby :P
04:45:58 <maerwald> I just feel TH is one of those things you don't just occasionally get into. You need a damn good reason and even then you don't like it.
04:46:33 <merijn> hmm, hackagebot no longer reports uploads?
04:46:35 <hpc> oh man, i would have such a good rant about ruby if i could just understand the bad parts properly
04:46:44 <hpc> it's so confusing trying to read someone else's code
04:47:08 <maerwald> hpc: the funny thing is, ruby advocates keep telling me that the creator specifically designed the language after the "least surprise" principle
04:47:12 <maerwald> and they are not even joking!
04:47:21 <MarcelineVQ> merijn: I think it only reports during a lul
04:47:41 <merijn> MarcelineVQ: bleh...then how am I supposed to subtly pimp my packages? >.>
04:48:06 <MarcelineVQ> Pretend you have a problem you need solving and then link the package you stumbled upon ;>
04:48:18 <MarcelineVQ> 'Why, this solves it neatly!'
04:48:19 <hpc> merijn: put it in your ptr record
04:48:35 <merijn> hpc: ptr?
04:48:38 <hpc> then when you join, ~merijn@i-invented-lenses.isp.com or whatever :P
04:48:48 <hpc> in dns
04:49:08 <merijn> Also, "it reports during a lul" is equivalent to "doesn't report" in #haskell :p
04:49:44 <mpickering> Manipulating modules and imports in a typed manner is really hard though. 
04:50:04 <mpickering> I don't see how the metaprogram level is different to the normal program level.
04:50:26 * mpickering happens to be writing some unrelated CPP to the earlier question right now
04:51:47 <merijn> MarcelineVQ: Small packages that solve niche problems are my forte :p
04:51:59 <tdammers> maerwald: actually, I think Rubyists often misunderstand the relevant quotes from Matz. He talks about the "least surprise" principle a lot, but he has also stated repeatedly that Ruby often fails to follow it
04:52:10 <MarcelineVQ> merijn: name your next package forte
04:53:10 <merijn> MarcelineVQ: That'd solve the hardest part of writing a package!
04:53:17 <MarcelineVQ> Yes.
04:53:21 <tdammers> mpickering: manipulating modules and imports is also something that would probably break Haskell in its current form
04:53:39 <mpickering> that does seem likely
04:53:44 <mpickering> it's not something I have ever desired to do
04:53:51 <tdammers> mpickering: then again, doing it in a "typed" way doesn't have to be tricky; it depends on the kind of guarantees you want out of it
04:54:03 <mpickering> One thing that is missing from typed template haskell is the ability to quote types. 
04:54:55 <tdammers> frankly, I've never even considered using typed TH - after all, TH is effectively typed already, because the output has to pass through the type checker anyway, so it's not like we're winning anything fundamental here, essentially we only get better type errors
04:55:19 <tdammers> type errors that refer to actual hand-written source code instead of generated AST
04:55:32 <tdammers> and also type errors at the TH producer site rather than the user site
04:56:08 <tdammers> but either way, we still get compile-time errors if and when we break things, so it's much smaller benefit than having a type checker at all
04:56:18 <mpickering> typed TH is more principled to write as the code is correct by construction. 
04:56:38 <tdammers> sure
04:56:45 <mpickering> The errors happen during normal type checking rather than the unfortunate necessary type checking when untyped code is spliced in
04:57:02 <tdammers> yes, I know how it works
04:57:21 <tdammers> but from a practical perspective, the difference isn't as fundamental as you'd hope it would be
04:57:43 <mpickering> I like how you can use normal compiler features like typed holes with typed template haskell in order to guide program construction
04:58:14 <tdammers> OK, that part is useful
05:05:19 <merijn> Typed TH also lets you do stuff based on the type of the expression
05:06:53 <merijn> Which lets you do things like, at compile time selecting which code to run depending on the type of the resulting expression
05:07:06 <Alex_> haskell is for pussies
05:07:09 <hpc> typed TH is written with a keyboard instead of a pen and paper
05:07:27 --- mode: ChanServ set +o dmwit
05:07:36 --- kick: Alex_ was kicked by dmwit (no thanks)
05:07:46 --- mode: dmwit set -o dmwit
05:09:11 --- mode: glguy set +v dataN
05:09:42 <dataN> what this error? https://gist.github.com/dataN-hs/eb908b994a3bbe25b71f07102f04c541
05:09:48 <dataN> something to do with TypeInType
05:10:08 <merijn> hmmm, API design question
05:10:32 <dataN> Expected kind `p -> q -> x', but Act' has kind `* -> forall a -> a'
05:10:59 <dataN> e.g. why is * not in (p::*) ?
05:11:40 <merijn> So I have 2 channel types (in and out, basically) and some functions work on both types (albeit with slightly different connotations) would you prefer a single function with a note how behaviour differs between types, or separate functions for each channel type?
05:12:34 <merijn> For example "isChanClosed :: Chan dir a -> IO Bool" returns True for input channels if they are closed, but True for out channels if they're closed AND empty
05:12:35 <MarcelineVQ> is it being the bad guy to suggest both?
05:12:46 --- mode: glguy set +v cger
05:13:10 <merijn> MarcelineVQ: I don't think both makes sense?
05:13:37 <cger> hello
05:13:54 <hpc> i think that's a weird enough distinction that i would initially question why out channels aren't truly closed until they are also empty
05:14:07 <hpc> and if a channel is closed if it's closed and empty, what does that second "closed" mean?
05:14:34 <hpc> because the user is just going to want isChanTheOtherKindOfClosed
05:14:36 <merijn> hpc: Mostly, because checking whether it is closed is prohibitively expensive if it's not empty
05:14:41 <hpc> ah
05:14:51 <dataN> :k (* :: (p :: *))
05:14:53 <lambdabot> error:
05:14:53 <lambdabot>     Not in scope: type constructor or class ‘*’
05:14:53 <lambdabot> error: Operator applied to too few arguments: *
05:15:00 <dataN> % :k (* :: (p :: *))
05:15:00 <yahb> dataN: ; <interactive>:1:8: error: Not in scope: type variable `p'
05:15:09 <dataN> hmm
05:15:11 <merijn> hpc: I'm not sure what you mean by "second closed"?
05:15:30 <dmwit> dataN: `Act' f a :: a` looks suspicious to me. You are using `a` at two different "levels" there.
05:15:43 <hpc> "out channel closed" = "channel is mystery-closed and channel is empty"
05:15:46 <dataN> % :k forall p. (* :: (p :: *))
05:15:46 <yahb> dataN: ; <interactive>:1:12: error:; * Expected kind `p', but `*' has kind `*'; * In the type `forall p. (* :: (p :: *))'
05:15:52 <hpc> you have two notions of closed for out channels here
05:16:14 <merijn> hpc: No?
05:16:33 <merijn> hpc: What is the second notion of closed?
05:16:37 <dmwit> dataN: Certainly the claimed kind (`* -> forall a -> a`) looks like gibberish to me, though I'm not familiar enough with TypeInType to confidently label it a bug.
05:16:42 <cger> :k popCount.pred.ap(xor)pred<$>[1..32]
05:16:44 <dmwit> dataN: What kind did you expect `Act'` to have?
05:16:44 <lambdabot> error:
05:16:44 <lambdabot>     Illegal symbol '.' in type
05:16:44 <lambdabot>     Perhaps you meant to write 'forall <tvs>. <type>'?
05:16:58 <hpc> merijn: one notion of closed is what's returned by isChanClosed
05:17:00 <dmwit> cger: You probably want :t, not :k.
05:17:04 <merijn> hpc: In essence, "out channel is closed" = reads will never succeed
05:17:08 <cger> thanks dmwit
05:17:09 <hpc> merijn: the other notion is the "closed" in your "but True for out channels if they're closed AND empty"
05:17:14 <cger> :t popCount.pred.ap(xor)pred<$>[1..32]
05:17:15 <lambdabot> [Int]
05:17:18 <dataN> type family Act' (f' :: f) (a' :: a) :: a
05:17:24 <merijn> hpc: Those two notions aren't really observable, though
05:17:39 <dmwit> dataN: Okay. That's definitely not what you wrote there.
05:18:01 <dmwit> dataN: What you wrote was `type family Act' (f' :: f) (a' :: a) :: a'` (note the extra ' at the end).
05:18:04 <merijn> hpc: Because there's no way to observe whether an out channel is closed before it's empty
05:18:45 <merijn> hpc: Unless you have both 1) a copy of the original in channel and 2) stored that those two correspond
05:18:48 <dmwit> dataN: If I give `Act'` the kind annotation you just did, I get a very different error (and it's quite understandable).
05:18:51 <hpc> so an output channel isn't like say, a unix pipe
05:18:56 <cger> thats the ruler sequence btw, im learning haskell and decided to try a golf :)
05:19:02 <hpc> where something on the other end occasionally refills the buffer?
05:19:09 <dataN> dmwit: works with; type instance Definition2' (Act' ::  ((p :: *) -> (q :: *) -> q)) (f :: p) (a :: q) = (* :: *)
05:19:18 <dmwit> dataN: right
05:19:18 <dataN> thanks
05:19:30 <merijn> hpc: "closed and empty" would basically correspond to "reads return EOF"
05:19:50 <hpc> ah
05:19:55 <merijn> hpc: Although I suppose files can have stuff appended later
05:20:02 <hpc> so both of these then are chanReachedEOF
05:20:15 <hpc> an input channel closes if it gets eof from the thing feeding into it
05:20:19 <dataN> but then it complains that Act' has not been given enough arguments
05:20:24 <hpc> and an output channel never returns anything after it sends eof
05:20:32 <hpc> that would be how you make both consistent
05:20:45 <dmwit> hpc: Reading from a pipe can either block (if the writer is still around but hasn't written enough yet) or give you EOF (if the writer died). They're observably different from the reader's end.
05:20:52 <merijn> hpc: Basically, "isClosed" corresponds to "writes can never succeed" for input channels and "reads can never succeed" for output channels
05:21:13 <dataN> a symbol could be used, but it would just be a newtype wrapper, and it wouldnt have the correct kind
05:21:48 <merijn> hpc: Which is, in a sense, equivalent behaviour. But also operationally slightly different
05:22:12 <mpickering> Is there a way to turn off -Werror which works for all versions of GHC back to ghc-7.6? -Wno-all doesn't work in versions earlier than 7.10
05:22:18 <merijn> hpc: The docs would have to clarify the operational difference, but I'm not sure that warrants having two separate functions
05:22:36 <dmwit> mpickering: My first guess would be -Wno-error. Second would be -Wwarn.
05:31:04 <mpickering> ok if this works then there will be a release of an 8.6.1 compatible haskell-src-exts finally
05:31:31 <mpickering> it had done the trick it seems 
05:33:18 <delYsid> I like lurking on haskell-cafe, but I wonder if there are any other classic mailing lists with a bit more traffic that I am missing?
05:40:12 <merijn> -cafe is the most active one, I think
05:40:25 <merijn> There's also -libraries for discussion on the core libraries and ghc-devs
05:51:31 <cppxor2arr> woah discovered monad-loops here
05:53:28 <dataN> at type level!?
05:56:05 <cppxor2arr> @hackage monad-loops
05:56:05 <lambdabot> http://hackage.haskell.org/package/monad-loops
05:59:07 <delYsid> :t whileM
05:59:08 <lambdabot> error: Variable not in scope: whileM
05:59:16 <delYsid> nice one anyways.
06:00:25 <dataN> whats an example of passing a proxy kind to a type family?
06:08:20 <dmwit> dataN: I eventually decided to report it as a bug. https://ghc.haskell.org/trac/ghc/ticket/15658
06:08:34 <dmwit> (Couldn't find anything about this strange syntax in the GHC docs.)
06:10:48 <dataN> but there must be a way to pass something of the correct kind (corresponding to the unapplied type family), even if it means defining a proxy alongside its definition, since the symbols are already required.
06:11:12 <dataN> and yeah, thats the strangest type ever!
06:12:08 <lyxia> there's one occurence of an explicitly bound kind https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#inferring-dependency-in-datatype-declarations
06:13:24 <dataN> lyxia: but still there is no way to infer the kind of an unapplied type family
06:13:41 <lyxia> you can't use unapplied type families in the first place
06:13:46 <dataN> right!
06:15:07 <lyxia> so the error message is wrong but you're supposed to get an error of some kind in that snippet of your
06:15:26 <dataN> but the idea would be to write a kind synonym such as could then be used on the lhs of the :: in the type family declaration  
06:15:31 <dataN> rhs*
06:15:52 <dataN> ohno, because it needs the arguments on the lhs and only the return type on the lhs
06:17:09 <dataN> oh and it couldnt be a synonym because that would complain about being unapplied also
06:18:09 <dataN> oh maybe a synonym could be made at the lower level and then used as a kind
06:19:55 <dataN> still it would be good to write a type family which could return this rather than having to write it explicitly. much like the defunctionalisation symbols
06:20:39 <lyxia> I'm not sure how what you wrote benefits from the fact that Act is not defunctionalized
06:20:41 <dataN> maybe it could unwrap a symbol to do so
06:21:47 <dataN> lyxia: just meaning that the unnaplied type family cant be passed to a type family to return the symbols
06:23:12 <dataN> shouldnt we be able to infer kind of the family from *any* of the symbols? using the same type family to do this conversion..
06:24:25 <dataN> in which case might it be possible to do the inverse, to infer the symbols from a proxy of the kind of the type family? 
06:24:34 <lyxia> if you pass symbols around then you wouldn't need to pass the unapplied type family around, that's the whole point.
06:25:00 <dataN> just need its kind to bind the other variables 
06:26:14 <dataN> like pattern matching on an unapplied class 
06:26:34 <dataN> but the symbols all have funky kinds
06:27:44 <lyxia> not much funkier than type families
06:27:54 <dataN> yeah much!
06:32:30 <dataN> this works! https://gist.github.com/dataN-hs/eb908b994a3bbe25b71f07102f04c541
06:34:50 <dataN> so then a list of all the symbols types could be generated with a recursion similar to finding the Arity of a kind, but could the data declerations be generated similarly? and the Apply instances?
06:38:23 <dataN> I think they can, could do that
06:39:11 <dataN> its just a newtype wrapper on the generated list, and an instance can take a Nat parameter 
06:56:40 --- mode: glguy set +v Boarders
06:57:26 --- mode: glguy set -v Boarders
07:40:26 <delYsid> Woah, Data.Sequence is fast/efficient.  Kind of makes [] look pretty bad
07:42:03 <delYsid> got about 30x less allocations after switching my hand-written non-deterministic algo from [] to Data.Sequence.
07:46:51 <Boarders> if I have a class that gives a lens called something like:
07:46:58 <Boarders> hasField s t a b
07:47:07 <Boarders> then what should the functional depenency be?
07:47:37 <Boarders> currently I have: HasField s t a b | s -> a, t -> b, s b -> t, t a -> s
07:48:58 <cocreature> Boarders: that seems too restrictive. e.g. if s = (a,b) you want a lens for both the first element and the second element so s does definitely not determine a
07:50:52 <Boarders> could you clarify? I would have something like HasFirst (a,b) (a',b) a a'
07:50:59 <Boarders> that seems like s does determine a, no?
07:51:13 <cocreature> Boarders: right but then you can’t have HasFirst (a,b) (a,b') b b'
07:51:33 <cocreature> that’s the same choice of s but two different as
07:51:57 <phadej> Boarders: check Each
07:51:59 <Boarders> ah ok, hmm
07:52:06 <cocreature> s b -> t, t a -> s seem like they might be alright but I am also not sure that buys you a whole lot in terms of inference
07:52:19 <phadej> class Each s t a b | s -> a, t -> b, s b -> t, t a -> s where
07:52:25 <phadej> looks like yours
07:53:15 <Boarders> I set it as I did because often I will have given s and t in the type signature and I want it to figure out a and b which might be polymorphic
07:53:21 <phadej> class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where
07:53:27 <Boarders> phadej: I'll have a look, thanks
07:53:53 <phadej> cocreatures' point is abit moot, as for other part you'll have Field2
07:54:42 <cocreature> sure if you make different typeclasses for different fields you can get it to work
07:54:52 <cocreature> maybe I misunderstood the point of HasField
07:55:28 <phadej> or then: class HasField (field :: Symbol) s t a b | s field -> a, t field -> b, s field b -> t, t field a -> s where
07:55:32 <phadej> from http://hackage.haskell.org/package/generic-lens-1.0.0.2/docs/Data-Generics-Product-Fields.html
07:55:51 <phadej> if you really want same class for different fields
07:56:30 <Boarders> cocreature: yeah, I was doing one class per field
07:56:44 <Boarders> fancy
07:57:19 <phadej> Boarders: generic-lens makes code feel very dynamic-like
07:57:22 <phadej> in good and bad
08:15:24 <jose_zap> I find that lens in general make things feel and behave like a dynamically  typed language sometimes
08:15:37 <jose_zap> specially aeson-lens
08:17:04 <tdammers> aeson *is* essentially "dynamically typed"
08:17:06 <tdammers> or rather, JSON is
08:18:40 <shapr> jose_zap: when I'm teaching, I tell students Haskell is dynamically typed at compile time, if you leave of the type signatures.
08:19:04 <jose_zap> tdammers shapr very true
08:19:12 <shapr> I know the current fashion is to add type signatures to everything, but that's not my preference.
08:19:48 <jose_zap> I did not mean to say it as a bad thing, it is actually quite relaxing to use aeson-lens to traverse nested structures
08:20:15 <tdammers> shapr: and you can get away with that, because "dynamically typed" doesn't have a widely agreed-upon rigid meaning!
08:20:16 <jose_zap> with the same caveats that a dynamically typed language would probably have, minus the runtime exceptions
08:20:34 <shapr> tdammers: ha, hadn't thought of that
08:21:31 <shapr> Although I have seen speed increases from more specific types, most of the time I don't worry about that.
08:28:19 <dminuoso> What other languages call "dynamic typing" is called `Dynamic' in Haskell. What other languages call "static typing" is called a type system.
08:30:36 <dminuoso> And hooray, I think I finally understand MonadBaseControl. =)
08:31:09 <maerwald> tdammers: what people don't get is that CS is not only academic, but also artistic. So we also have to have an artistic ad-hoc way to talk about how things feel to you as an artist/programmer. The theoretical part cannot catch all of it.
08:31:31 <ski> (it would be nice if `Dynamic' could handle universal quantification. iirc, the corresponding thing in Clean can .. also has nice pattern-matching support on type representations)
08:31:58 <tdammers> maerwald: I wouldn't call that part "CS", but yes, there is definitely an artistic / intuitionistic part to it
08:32:15 <maerwald> it should be part of CS!
08:32:21 * ski . o O ( Intuitionistic logic )
08:32:36 <dminuoso> ski: What would that look like?
08:32:37 * tdammers . o O ( Secret pun unlocked! )
08:32:41 <ski> (is art science ?)
08:33:16 <maerwald> ski: is that a scientific question? xD
08:33:28 --- mode: glguy set +v salinas
08:33:56 <salinas> Hey guys, I need some help with string encoding. It's a newbie question
08:33:59 <dminuoso> ski: That question is rather simple to answer, but give me a definition of `art` and a definition of `science` that you have in mind first.
08:34:05 <ski> dminuoso : something like `dynApply (Dyn f :: a -> b) (Dyn x :: a) = Just (Dyn (f x) :: b); dynApply _ _ = Nothing'
08:34:12 <ski> @type Data.Dynamic.dynApply
08:34:14 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
08:34:39 <dminuoso> salinas: Just ask away
08:34:41 <ski> maerwald : i think it isn't. perhaps a philosophical question
08:34:50 <maerwald> an artist would never ask for a definition, but for an *idea*
08:35:04 <maerwald> there you got your implicit answer
08:35:08 <salinas> I'm making a json string to send it to an api. I'm using Network.HTTP.Simple
08:35:23 <salinas> But the string gets encoded
08:35:24 <ski> dminuoso : or were you asking about the universal quantification part ?
08:35:28 <salinas> This is what im doing
08:35:40 <salinas> https://pastebin.com/u8kkc9Gy
08:35:47 <dminuoso> ski: Oh that last question was regarding "art" and "science". But yes that also.
08:35:50 <dminuoso> ski: Im reading it. :)
08:35:54 <dminuoso> Or rather processing.
08:36:52 <salinas> Should I build the string in a different way?
08:36:58 <dminuoso> salinas: JSON is, by definition, UTF8 encoded. 
08:37:03 <dminuoso> If that helps.
08:37:15 <ski> dminuoso : hm, actually the type ascriptions should be on the argument to `Dyn', not on the result of applying `Dyn'
08:37:38 <ski> (the result of applying `Dyn' would have type `Dynamic')
08:37:56 <dminuoso> ski: What is a type ascription?
08:38:03 <salinas> Yeah, if I run the function in ghci is printed as:
08:38:29 <salinas> "{\"carrier\": \"fedex\"}"
08:38:44 <cocreature> salinas: what do you expect to happen instead?
08:38:47 <ski> dminuoso : the point is that it would be nice if we could match a type-rep inside a `Dynamic' to a given type-rep of some given type, or indeed of another type-rep from inside another `Dynamic', by using plain pattern-matching, rather than explicitly mucking around with `TypeRep's
08:39:15 <dminuoso> ski: Ah.
08:39:16 <salinas> But when I try to send it with Network.HTTP.Simples setRequestBodyJSON it sends as:
08:39:32 <salinas> "\"{\\\"carrier\\\": \\\"fedex\\\"}\"
08:39:40 <ski> dminuoso : and one should be able to name (and match on) parts of such type-reps (after pattern-matching), not just the whole type of the value inside a `Dynamic'
08:39:40 <salinas> Like it's extra encoded
08:40:20 <ski> dminuoso : the whole (or at least most of the) reason `Data.Dynamic' exports `dynApply' is that it's tedious to express this oneself
08:40:29 <maerwald> what's a good alternative for STMContainers.Set without an odd non-common dependency
08:40:55 <c_wraith> ski, wasn't there a proposal to change the the type of the Dyn constructor to Typeable a => a -> Dynamic? 
08:41:01 <ski> dminuoso : Clean added a new pattern form for (their equivalent to) `Dynamic', to avoid this nonsense
08:41:13 <cocreature> salinas: ah I see what’s going on. setRequestBodyJSON expects a Haskell value and will then convert that to a JSON string for you. however you are already passing it a json string so it escapes all the json characters in that so it is treated like a single string
08:41:28 <ski> c_wraith : perhaps (i can't recall hearing about it), though i don't see how that would help with the issue here
08:41:29 <salinas> exactly
08:41:53 <dmwit> salinas: Build an aeson Value, not a String, in `trackPayload`.
08:42:09 <cocreature> ski: make a type like "data Payload { carrier :: String, service :: String, locale :: String, trackNos :: Int }" and provide a ToJSON instance for that
08:42:09 <ski> @type Data.Dynamic.Dynamic
08:42:11 <lambdabot> base-4.10.1.0:Data.Typeable.Internal.TypeRep a -> a -> Dynamic
08:42:12 <dmwit> salinas: Or use one of the `setRequestBody` functions that accept raw strings.
08:42:15 <cocreature> eh that was for salinas 
08:42:26 <cocreature> and then have trackPayload construct that value
08:42:27 * ski smiles
08:42:53 <salinas> ok, thank you guys
08:46:23 <ski> dminuoso : a type ascription is an expression of the form `<expr> :: <type>'. i also use this name for patterns of the form `<pat> :: <type>'. otoh a declaration `<id> : <type>' is not an ascription, it's a type signature (as you know)
08:47:03 <ski> (er, `<id> :: <type>', that should be)
08:49:45 <ski> so, if i'm fixing the `dynApply' example, it would look something like
08:49:54 <ski>   dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
08:50:15 <ski>   dynApply (Dyn (f :: a -> b)) (Dyn (x :: a)) = Just (Dyn (f x :: b))
08:50:26 <ski>   dynApply  _                   _             = Nothing
08:53:10 <ski> the idea being that the `Dyn (<pat> :: <type>)' patterns here would implicitly extract the type-rep inside the `Dynamic', matching it against `<type>', and matching tyvars (which are known to have a `Typeable' constraint, say) which have already been bound by earlier such patterns for equality
08:53:48 <ski> (any tyvars bound would presumably also introduce known `Typeable' constraints for them)
08:54:46 <ski> (i suppose one could imagine using a new keyword for `Dyn', because it looks like this functionality wouldn't be available for ordinary data constructors ?)
08:54:56 <ski> (or could it ?)
08:57:17 <ski> (perhaps, somehow, using `Typeable' constraints on existentials would automatically introduce the above matching functionality ?)
09:00:04 <phadej> ski: https://github.com/ghc-proposals/ghc-proposals/pull/126 would make work with Dyn ok-ish
09:01:41 --- mode: glguy set +v renard`chase
09:02:56 <phadej> ski: and there's App pattern in http://hackage.haskell.org/package/base-4.11.1.0/docs/Type-Reflection.html
09:04:37 <ski> phadej : ty, will check later
09:04:48 <phadej> so maybe it will look like (Dyn (App (App arr (a @ a) (b @ b) f)
09:05:16 <phadej> not sure where to insert TypeApplications
09:05:25 <ski> mm, looks better than nothing
09:05:56 * ski isn't sure about what the `@'s for
09:06:05 <ski> (hm, type applications ?)
09:06:26 <phadej> ski: so you can "bind" the existential variables
09:06:42 <phadej> iirc, didn't read the final version of the ghc-proposal
09:07:13 <ski> mhm
09:07:21 * ski gotta go
09:09:35 <renard`chase> Ok, nvm, it worked when I compiled the thing, just not when I ran it through ghci
09:11:01 --- mode: glguy set +v renard`chase
09:11:33 <renard`chase> Ok, it occurse to me that I sent my question when I wasn't voiced
09:12:32 <renard`chase> So for anyone woundering about the random statement I just made. I asked how I could get Haskell to everything in the main function. It looks like it does that though when I compile the program, just not when I run it through ghci
09:12:33 <texasmynsted> I am looking here ---> https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
09:13:09 <texasmynsted> What I want to do is install stylish-haskell, globally using cabal. What is the right way to do this?
09:13:30 <texasmynsted> without nix I would do "cabal install stylish-haskell"
09:13:36 <phadej> texasmynsted: with cabal-install-2.4 `cabal new-install stylish-haskell`
09:14:09 <texasmynsted> why the cabal-install-2.4 part?
09:14:22 <phadej> because older cabal-install don't have working new-install
09:14:38 <phadej> (and you have to use workarounds)
09:14:49 <phadej> not sure, maybe 2.2 works too though
09:15:04 <texasmynsted> strangely I do not see cabal-install* anything in my path
09:15:13 <phadej> cabal --version
09:15:29 <texasmynsted> 2.0.1.1
09:15:33 <phadej> well, too old.
09:15:35 <texasmynsted> hmm.
09:16:11 <phadej> https://www.haskell.org/cabal/download.html has binaries for 2.2 (and hopefully soon for 2.4)
09:16:20 <maerwald> how random are arbitrary instances? I mean, say... email addresses. For a test suite, would you want to track generated emails as to not get duplicates?
09:16:51 <maerwald> or is that case negligible
09:17:08 <texasmynsted> I am not sure how cabal was installed last time...
09:17:29 <phadej> texasmynsted: where it lives, what `which cabal` says
09:17:44 <phadej> and what operating system you are using
09:17:49 <texasmynsted>  /usr/loal/bin/cabal
09:17:59 <texasmynsted> oops /usr/local/bin/cabal
09:18:04 <texasmynsted> mac
09:18:59 <texasmynsted> fairly sure I used haskell platform
09:19:19 <phadej> unfortunataely I don't remember how HP handles updates
09:21:03 <phadej> but, I just built cabal-install-2.4 for osx: https://haskell.futurice.com/; the cabal-88738ba53...
09:21:23 <phadej> so you can grab the .xz, and unzip the binary, and place it in your $PATH
09:21:29 <Cale> maerwald: Depends on the instance -- it just defines a generator.
09:21:49 <phadej> but that's quite unofficial way :)
09:22:33 <Cale> maerwald: If your test relies on not having duplicates, I would recommend generating a Set
09:23:10 <maerwald> Cale: yes, I do that already
09:26:21 <texasmynsted> https://www.haskell.org/cabal/download.html
09:26:48 <texasmynsted> I should be able to do this, yes? "cabal install Cabal cabal-install"?
09:26:58 <texasmynsted> ignore the last ?
09:27:06 <texasmynsted> The question mark
09:27:08 <maerwald> Cale: just feels a bit superflous... I mean how often would you actually get a collision
09:27:17 <maerwald> I don't care about entropy...
09:28:24 <phadej> texasmynsted: yes, `cabal install cabal-install` might work
09:28:48 <phadej> (after cabal update)
09:29:13 <phadej> but I'd still grab a binary from haskell.org or the other link
09:29:28 --- mode: glguy set +v mnick
09:29:28 <phadej> (and if former, than `new-install cabal-install`)
09:29:31 <Cale> maerwald: A lot of instances that generate random strings pick a length at random first, and then pick random characters for that string. Depending on the size parameter, getting length 0 might be rather easy.
09:29:53 <texasmynsted> sigh. I get a --root-cmd message. https://github.com/haskell/cabal/issues/3353
09:30:00 <texasmynsted> I did --dry-run
09:30:17 <texasmynsted> why would you use the binary install?
09:30:51 <maerwald> Cale: https://privatebin.net/?bef640d7375eccdb#u0F8F5DPARzWcsbTmG7nzv4TXQnne5cw95H3roVMM8M= this is the instance
09:31:04 <maerwald> it's between 5 and 15 chars for the name part
09:31:19 <phadej> texasmynsted: because you won't run into issues as you did with --root-cmd :P
09:31:19 <maerwald> I think that's already quite enough
09:31:34 <texasmynsted> ok
09:31:39 <phadej> and yes, never run `cabal` as root
09:31:53 <maerwald> cabal as root should be less dangerous than stack, heh
09:32:30 <texasmynsted> would there be an advantage to download the source tar ball and build/install that?
09:34:22 <sclv> the root-cmd msg is just a warning that says if you have that in your config it ignores it?
09:36:07 <texasmynsted> won't I continue to get that message after installing the new cabal?
09:36:16 <sclv> yes but its just a warning
09:36:33 <sclv> that says there's an old line in your ./~cabal/config
09:36:35 <sclv> that you can delete
09:36:39 <sclv> since it is disregarded
09:36:44 <sclv> so you can delete the line
09:37:06 <sclv> or you can ignore the message and not delete the line and just see the messages in the future. it doesn't matter :-)
09:38:46 <texasmynsted> ok, I will delete the line
09:39:01 <texasmynsted> Not sure where to put the cabal binary...  Still looking
09:39:26 <sclv> typically you'd replace the one in /usr/local/bin/cabal or /usr/bin/cabal
09:39:33 <texasmynsted> it seems that the cabal that is in /usr/local/bin is a shell script looking for something called cabal.real
09:40:02 <sclv> yes, that's an artifact of how the platform manages it
09:41:13 <texasmynsted> so what happens if I later "upgrade" my haskell platform by re-installing haskell platform. Will it over-write my binary with that shell script?
09:41:24 <sclv> yes
09:41:32 <texasmynsted> :/
09:41:34 <texasmynsted> hm
09:41:42 <sclv> sec
09:43:09 <sclv> texasmynsted: if you replace cabal.real in /Library/Haskell/current/bin/
09:43:18 <sclv> then that will upgrade the cabal in the current version of the platform
09:43:30 <sclv> and if you install a newer platform you'll get the cabal that ships with _that_ platform
09:43:47 <sclv> but if you switch back (using activate-hs to swap versions) you'll get the upgraded cabal rather than the extant one
09:44:46 <texasmynsted> but if I do cabal install Cabal cabal-install then I will get whatever the current version of cabal-install is... And if that is not modern enough I could upgrade with the binary. Right?
09:45:07 <sclv> right
09:45:10 <sclv> you can just cabal install it
09:45:55 <texasmynsted> :-)
09:46:00 <texasmynsted> Will see what happens
09:46:10 <texasmynsted> Then hopefully make notes to myself for next time.
09:48:13 <texasmynsted> hmm tells me that I need to --force-reinstalls, and that will break some packages. It should just fix/upgrade the packages that would be broken right?
09:48:38 <sclv> no don't do that
09:48:47 <sclv> that's why the binary upgrade path is preferred
09:48:50 <sclv> or using a sandbox
09:48:57 <merijn> Or new-build!
09:49:06 <texasmynsted> hmm
09:49:24 <sclv> things you cabal install btw are put into `~/Library/Haskell/bin/` btw
09:49:26 <texasmynsted> I am sold on new-build. I just need to know what to do to fix my existing install
09:49:28 <sclv> (i.e. your local library)
09:49:36 <sclv> so you can just make sure that comes first on the path
09:49:42 <sclv> and not worry about any of the other stuff
09:49:47 <texasmynsted> It is first in path
09:49:47 <sclv> and drop the binary there :-)
09:49:53 <merijn> texasmynsted: Judging by ~/Library I'm guessing you're on OSX?
09:49:57 <texasmynsted> yes
09:49:57 <sclv> ok, then just drop the cabal binary in there and yr done
09:50:31 <merijn> texasmynsted: Honestly, I don't even bother with platform anymore on OSX. I just do the same thing everywhere: install GHC via the bindists and build cabal myself
09:50:32 <texasmynsted> and remember to binary "upgrade" cabal if I ever haskell platform upgrade
09:51:02 <sclv> texasmynsted: once you have a cabal with working new-build you can new-build upgrade too :-)
09:51:15 <sclv> or use the cabal that ships with the platform, since that's always the latest
09:51:19 <merijn> texasmynsted: both cabal and GHC play nicely with multiple versions on the same machine, so doing it that way is simplest
09:51:20 <sclv> at the time the platform is cut
09:51:25 <sclv> etc
09:51:55 <texasmynsted> So maybe now is the time to remove what I have and go --> "install GHC via the bindists and build cabal myself" route?
09:52:04 <sclv> no need to though
09:52:10 <sclv> you like have everything in working order on your machine
09:52:11 <merijn> Well, for new-build you might wanna be using cabal-install HEAD until 2.4 or so is released :)
09:52:14 <sclv> and you have a new cabal binary!
09:52:16 <sclv> so like
09:52:22 <sclv> just use what you have
09:53:32 <texasmynsted> so the newest binary is 2.2, to get the 2.4 I need source.
09:53:47 <texasmynsted> I am guessing building from source is simple right?
09:55:16 <sclv> relatively simple, yes
09:55:31 <sclv> new-build works fine in 2.2. what HEAD brings are improvements to the greater suite of new- commands
09:57:12 <texasmynsted> ok, then unless merijn has the his process documented someplace I will just use the binary.
09:59:57 <texasmynsted> :-) Thank you both
10:02:58 <texasmynsted> ok, binary installed. 
10:03:57 <texasmynsted> so to install stylish-haskell "globall" I just use the non Nix style of install?
10:04:45 <cocreature> texasmynsted: cabal 2.2 should have a new-install that works for packages from hackage iirc
10:05:42 <texasmynsted> hah right. That was the point of all this I guess.
10:05:46 <sclv> or just "cabal get xxx" then "cabal new-build xxx" and then copy the binary yourself :-)
10:07:31 <texasmynsted> Is there a way to find all the stuff that was "instaled" via "cabal install" and replace it with "cabal new-install"?  Maybe just ls -l ~/Library/Haskell/bin, and new-install those.
10:08:31 <sclv> there's no reason you need to do that
10:08:37 <sclv> the binaries are the same once they're built
10:09:11 <maerwald> texasmynsted: ghc-pkg list shows globally installed packages for a ghc version
10:09:18 <c_wraith> new-build just adds way more ways to find a successful build plan.
10:09:31 <maerwald> you can remove the .cabal folder too maybe (maybe you want to keep the binaries though)
10:09:56 <c_wraith> I find the config file is what I want to keep most.
10:10:49 <texasmynsted> looks like new-install installs to ~/.cabal/bin rather than ~/library/Haskell/bin
10:10:56 <texasmynsted> not sure that is just what the doc says
10:11:58 <maerwald> new-install doesn't seem to work for me consistently
10:12:17 <sclv> it might not pick up on the setting in the cabal file on where to put stuff
10:12:34 <texasmynsted> so to "upgrade" I just do a "cabal new-update&&cabal new-install foo" and I will get a new foo
10:12:40 <sclv> when you run it on something you can see
10:14:22 <maerwald> using cabal as a project tool is reasonable, but as a package manager to keep stuff up to date... meh
10:17:53 <infinisil> Combination with Nix recommended :)
10:18:10 <maerwald> except now you need to learn nix
10:19:00 <texasmynsted> hm. It says "--symlink-bindir" not used or defined in my cabal config.  I will look for where stylish-haskell was installed and update the config to point there... I guess.
10:23:24 <texasmynsted> merijn what do you have as your symlink-bindir? /usr/local/bin ?
10:24:34 <texasmynsted> The docs do not tell me how this works. Looks like stylish-haskell binary was built into ~/.cabal/store/ghc-8.2.2/stylsh-hskll-0.9.2.0-167990aa/bin/stylish-haskell
10:25:21 <maerwald> last time I tried stylish-haskell it did nothing xD
10:25:36 <sclv> just install it with symlink-bindir pointing wherever you want
10:25:37 <sclv> its up to you
10:26:45 <texasmynsted> so maybe ~/Library/Haskell/bin, since that is where `cabal install` puts things?
10:28:02 --- mode: glguy set +v helges
10:29:45 <helges> I've found a Haskell module that looks interesting, Data.Metrology. Can I install that with stack? Stack is new to me; I've only used Haskell Platform before.
10:30:23 <geekosaur> generally you need to put it in package.yaml as an extra-deps
10:30:40 <geekosaur> unless it's in stackage and whatever resolver you're using
10:31:05 <maerwald> or just use cabal
10:31:12 <cocreature> s/package.yaml/stack.yaml/
10:31:20 <geekosaur> er, sorry, yes
10:31:25 <cocreature> you also need to add it to package.yaml/your cabal file as a dependency
10:31:30 <maerwald> yeah, package.yaml is another problem
10:31:49 <geekosaur> but I'm tempted to say that fi you're using the Platform, youw ant to look at cabal new-build instead of changing your whole workflow
10:33:55 <helges> I don't have a workflow, I'm new to Haskell too. Can I do "stack intall mywantedpackage", where mywantedpackage is the package that contains Data.Metrology? It is likely to exist in Stack?
10:34:22 <maerwald> if you are new to haskell, stick to cabal
10:34:28 <maerwald> stack solves a particular problem
10:34:38 <maerwald> unless you hit that sort of problem, there is no reason to use it
10:34:55 <helges> OK, so how do I install a package with cabal then? How can I find out the package name?
10:35:12 <maerwald> @hoogle Data.Metrology
10:35:13 <lambdabot> module Data.Metrology
10:35:14 <dmwit> helges: `cabal install <package-name>`.
10:35:28 <maerwald> https://hayoo.fh-wedel.de/?query=Data.Metrology
10:35:38 <maerwald> seems to be part of the "units" package
10:35:43 <helges> Is Data.Metrology the package name?
10:35:48 <maerwald> no, see above
10:36:19 <maerwald> @hayoo Data.Metrology
10:36:20 <lambdabot> Unknown command, try @list
10:36:22 <maerwald> sad
10:36:30 <maerwald> no hayoo command?
10:36:54 <dmwit> helges: You can probably find out the package easily from the website that showed you that Data.Metrology exists. Where did you find Data.Metrology?
10:37:24 <sclv> helges: so the typical way you use a package is to create a project (using cabal init or the like) that depends on it, and then use it from within that package, rather than installing it globally
10:37:27 <helges> Google lead me to https://github.com/goldfirere/units
10:37:28 <sclv> you can do this with either cabal or stack
10:37:48 <maerwald> helges: use hayoo
10:37:52 <dmwit> (By the by, I would love for `cabal` to have a `find-module` command, and it at least in principle does have all the information it needs to implement one.)
10:37:56 <cocreature> helges: right so the package name is "units"
10:38:05 <maerwald> yes, as already explained :D
10:38:48 <helges> OK, thanks!
10:38:54 <dmwit> helges: From that page, you can learn that the package name is `units` by clicking the only `.cabal` file and looking at the `name:` field. You can also just clone that repo and run `cabal install` from inside to get the package without knowing its name.
10:39:15 <texasmynsted> sigh now I get a message that my haskell-stack is outdated. 
10:39:22 <dmwit> Either procedure should reliably work for any single-package git repo.
10:40:20 <cocreature> texasmynsted: "stack upgrade" should do the trick
10:40:58 <texasmynsted> ok, I will try that
10:42:06 <texasmynsted> well could I not do "cabal new-install stack"?
10:42:40 * texasmynsted shrug
10:42:49 <texasmynsted> trying "cabal new-install stack"
10:42:55 <texasmynsted> who knows what will happen
10:42:57 <texasmynsted> heh
10:42:59 <maerwald> snoyman will love you for that :D
10:43:08 <texasmynsted> why?
10:43:31 <maerwald> because he is a cabal fan! No... because he would probably say "never do that" haha
10:43:42 <texasmynsted> I am trying not to use stack but some things want it, like haskell-mode in emacs
10:44:13 <texasmynsted> I guess I will find out what problems this will cause
10:44:22 <maerwald> yeah, intero also depends on stack
10:48:21 <bwe> How can I repeatedly apply a function x times to a value, to its result...?
10:49:57 <Cale> Well, there's iterate
10:50:09 <Cale> iterate f x = [x, f x, f (f x), ...]
10:53:54 <Cale> If f is strict, and n is large, you may wish to avoid directly indexing the nth element of that list though, since that will create a situation requiring a large stack.
10:55:35 <Cale> That performance issue can be avoided by first applying  strictList = foldr (\x xs -> x : (x `seq` xs)) []  to the resulting list, before using !! on it.
10:56:55 <Cale> This simply forces previous elements of the list to be evaluated before the tail is observed, so that you don't get to the millionth element and have a gigantic f (f (... (f x) ...)) built up in memory that now needs to be evaluated all at once.
11:06:19 <eacameron> Anyone seen a build with -prof *fix* a memory leak? With -prof we see great memory usage. Without it, memory climbs.
11:08:16 <c_wraith> eacameron, my guess would be that profiling disabled the full laziness transform, and it's being applied incorrectly in optimized builds.
11:08:17 <Cale> eacameron: That's interesting. Maybe -prof is hindering some "optimisation" which isn't
11:08:31 <Cale> yeah
11:08:40 <c_wraith> full laziness is the most common culprit for "incorrect optimization"
11:09:20 <c_wraith> it can certainly lead to excess memory consumption.
11:09:38 <eacameron> c_wraith: Cale: We'll try turning that off!
11:10:41 <c_wraith> eacameron, if that's the culprit, try to nail down the exact binding causing problems and narrow disabling the optimization as much as you can. it can give asymptotic improvements when it works, and you want to keep it around when it does.
11:12:14 <eacameron> c_wraith: Good to know. thanks
11:13:01 <badzergling> a noticeable aspect of this memory usage is that heap profile shows steady state consumption of about 35M (after a spike around 500M at startup).  with profiling options turned on, htop reports memory usage at steady state around 256M without changing for hours.  same exuctable with no +RTS options and it grows slowly over time.
11:17:03 <jose_zap> badzergling what ghc version?
11:17:36 <badzergling> jose_zap: 8.0.2
11:18:31 <jose_zap> badzergling have you tried compiling with the -fno-full-laziness flag?
11:18:42 <badzergling> no.  i'll give that a try.
11:24:24 <bwe> Cale: Thanks, iterate does the job.
11:41:29 <cynick> m
11:43:02 <MarcelineVQ> I agree.
11:54:22 <badzergling> c_wraith: jose_zap: thanks -fno-full-laziness seems to make a difference.  
11:54:28 <jose_zap> good news :)
11:55:18 <jose_zap> now you need to test if using a recent ghc and recent libraries makes that flag unnecessary
12:35:52 <badzergling> apparently that flag alone doesn't fix the leak, together, `-prof` and `-fno-full-laziness` seem to resolve the leak, but either alone leaks.  `-prof` and actually using some heap profiling `+RTS` options also resolve the leak...
12:36:54 <cocreature> badzergling: do you have some kind of minimal example? that sounds very suspicious
12:37:03 <cocreature> I definitely wouldn’t rely on profiling options to fix a leak
12:43:10 <monochrom> OTOH I wouldn't rely on -prof not interfering with leaks and lack of leaks either.
12:43:56 <cocreature> right I’m not surprised that -prof might change the behavior. but the behavior that you should be worried about is the one without -prof
12:44:17 <monochrom> Although, I'm still basing on a many-years-old incident that -prof did interfere.  I may be outdated on this.
12:45:09 <cocreature> it definitely does still interfere
12:45:40 <monochrom> Yikes. I wonder what causes it and how to fix.
12:47:42 <cocreature> I don’t think it’s really a solvable problem. if you want a way to have profiling not inferfer with optimizations you need to use ticky-ticky profiling
12:48:57 <monochrom> I don't want to believe that. Then again I am not putting work into this, so I am not complaining. :)
12:50:04 <cocreature> monochrom: fair enough but let me at least quote spj on this “It's extremely difficult to combine (a) cost-centre profiling with (b) lots of optimisation. It's a research question and GHC doesn't solve it.” ofc that doesn’t mean that it’s impossible but it’s definitely not a simple fix
12:50:53 <monochrom> Personally my troubleshooting strategy is: I forsake -prof altogether. I understand lazy evaluation and core sufficiently that watching htop and reading core tells me more than -prof does.
12:51:03 <EvanR> spj, ﷽
12:51:32 <cocreature> monochrom: yeah but reading core scales fairly badly to giant code bases
12:52:04 <sud0> hello. I'm using aeson to decode and parse a simple JSON API. I was reading about it and in order to process such data, I need to write specific data types for my JSON
12:52:22 <EvanR> you don't necessarily have to do that
12:52:31 <EvanR> aeson's json Value can be inspected directly
12:52:35 <sud0> is there an easy way? seems so... tedious
12:52:53 <EvanR> in the long run custom data types are a better idea, but you don't need them to get started
12:52:56 <sud0> EvanR: mind explaining or suggest some further reading
12:53:12 <EvanR> look in the aeson haddocks, Value is the data type to represent arbitrary json
12:53:16 <EvanR> without restriction
12:53:29 <monochrom> I haven't done giant code bases. But supposedly use bisection to isolate the diff between small space and big space. Then you know which 10 lines of code to read the core of.
12:53:54 <cocreature> in some sense I’d say reading core and profiling are also somewhat complementary and one does not replace the other
12:54:12 <cocreature> profiling tells you where the hotspots are, reading core can help you reduce/remove those hotspots
12:54:30 <cocreature> you are not going to find the bottleneck in your app by looking at core in most cases
12:55:10 <EvanR> sud0: decode :: FromJSON a => ByteString -> Maybe a
12:55:30 <EvanR> Value happens to be a FromJSON type, so you could require decode return a Value (Maybe)
12:56:01 <EvanR> instead of a custom type
12:56:50 <EvanR> however, you probably consume json in a way that require a certain structure. And this is where custom types and further validation/parsing in aeson comes in
12:57:25 <sud0> decode returns a fromList [...]
12:57:43 <EvanR> what decode returns depends on `a'
12:58:01 <EvanR> which depends on context, or your type signatures
12:58:03 <monochrom> sud0: In the long run, it is best to design your own type.  In the short term, what EvanR says about Value, sure.
12:58:42 <sud0> ok. thank you both
12:59:18 <monochrom> Basically the difference between engineering and scripting.
13:01:32 <EvanR> or the difference between installing an outlet, a wall switch, and a circuit for a garbage disposal. Or plugging the garbage disposal into a power strip plugged into an extension cord
13:01:43 <sud0> I guess I shouldn't be a lazy sack and write those types
13:01:49 <EvanR> sorry i started working as an electrician
13:02:00 <sud0> I was in fact doing it, but I thought asking in here first
13:02:18 <sud0> EvanR: lol
13:03:55 <EvanR> unrelated... i just noticed the Encoding' thing in aeson, with it's phantom type for what it is encoded as. Very inspiring ontologically
13:04:29 <phadej> EvanR: thanks
13:04:46 <EvanR> not sure why its in the external docs though
13:05:16 <phadej> because sometimes you need to construct raw `Encoding` values
13:05:22 <phadej> in fact, I did just an hour ago
13:05:38 <phadej> or not "raw", but by hand
13:08:08 --- mode: glguy set +v helges
13:13:09 --- mode: glguy set +v canonrush
13:13:27 <reygoch> Is it possible to bring a runtime Int value into the type level? We do have Nat kind but so far I've only been able to bring Nats down to the value level, and not the other way around
13:14:06 <monochrom> You will incur a KnownNat constraint and possibly an existential type.
13:18:47 <monochrom> There is a very simple distinction between what can be done and what can't be done.  A value is dynamic, a type is static.
13:19:44 <reygoch> monochrom: Hm.. so Nat is a no go than?
13:20:00 <dmwit> You can make an existential.
13:20:06 <dmwit> It may be enough for what you want, not sure.
13:20:34 <canonrush> trying to get started with Backpack, but confused about "Non-library component has unfilled requirements"
13:20:40 <reygoch> I want to read in a list of strings from a file and make it so that it has type `Vector 5 Text` for example
13:20:44 <canonrush> my implementation has everything in the sig
13:21:09 <canonrush> the error message gives no guidance as to what is unfilled, or even what unfilled means
13:21:47 <monochrom> When a dynamic value is "lifted" (whatever that means) to the static type level, since the value is statically unknown, you expect to receive it as a type variable, and it stays as such.
13:22:13 <dmwit> reygoch: For `data SomeVector a = forall n. SomeVector (Vector n a)`, you can read a list of strings and shove them in a `SomeVector Text`.
13:23:05 <monochrom> Then at best you only have "Maybe (Vector 5 Text)" because you can't just dictate that the file satisfies the 5.
13:23:28 <reygoch> So, how would I implement safe operations like concatenation?
13:23:34 <dmwit> reygoch: ...Well, *maybe* you can do that. Depends on the definition of Vector. =P
13:23:56 <dmwit> What's unsafe about concatenation?
13:23:57 <reygoch> I guess I need to make a data type which can represent length both on a type and value level, right?
13:24:00 <dmwit> It's indexing that's unsafe.
13:24:09 <dmwit> That cannot be made safe when indexing into user input.
13:24:16 <dmwit> Because users are stupid and wrong. ;-)
13:24:26 <monochrom> "Parsing" and "data validation" exist because there are syntax errors and invalid data whenever you receive stuff from the outside world.
13:24:30 <reygoch> I wanted to say that I get something like concat :: Vec n a -> Vec m a -> Vec (n+m) a
13:24:53 <EvanR> that works for any n and m
13:25:15 <EvanR> even if they are unknown
13:25:18 <dmwit> reygoch: But my point is that concat always works, no matter what n and m are. So the untyped version, Vec a -> Vec a -> Vec a, is just as safe.
13:26:12 <dmwit> You don't put the length into the type so that *concat* is safe. You put it there so that taking a value out of the vector is safe.
13:26:17 <reygoch> dmwit: Yes, sure, that wasn't the best example
13:26:47 <EvanR> index :: Vec n a -> Fin n -> a
13:27:18 <EvanR> index :: Vec n a -> m -> m `LT` n -> a
13:27:48 <monochrom> I don't understand the leap from "I'm reading a file" to "I'm appending vectors".  I might understand if you confirmed "yeah they're orthogonal questions".
13:28:15 <reygoch> monochrom: reading lines from a file into a vector of strings
13:28:36 <reygoch> Just an example for dynamic vector
13:29:00 <EvanR> yeah so in your accumulator youll be increasing the type of the vector by 1 each time, so the loop better be polymorphic in the n
13:29:19 <EvanR> and you have no way to know what n will be after it stops
13:29:27 <EvanR> assuming it stops
13:29:49 <reygoch> EvanR: I'd read it in a normal list and count it and pass that length when converting it into a vector with typed length
13:29:53 <reygoch> that was my idea anyway
13:30:24 <reygoch> dmwit: how does one get length of a vector into that "hidden" `SomeVector` example
13:30:42 <EvanR> same issue with the length of an arbitrary list
13:31:10 <EvanR> you cant set the type of the vector to a concrete number at runtime
13:31:13 <dmwit> reygoch: cons :: a -> SomeVector a -> SomeVector a; cons x (SomeVector xs) = SomeVector (realCons x xs)
13:31:20 <bwe> How can I make the intersection of two lists, that is elements in both lists?
13:31:27 <dmwit> reygoch: Where `realCons :: a -> Vector n a -> Vector (n+1) a`.
13:31:52 <reygoch> Oh...
13:31:55 <reygoch> nice
13:31:57 <reygoch> thanks
13:31:58 <EvanR> > [1,2,4,5,6] `intersect` [2,3,4,5,9]
13:32:00 <lambdabot>  [2,4,5]
13:32:02 <dmwit> reygoch: (But don't do this. There's really no benefit to this vs. a vector that doesn't track its length. ...which is kind of my point.)
13:32:27 <bwe> EvanR: thx.
13:32:43 <reygoch> So there is no way to actually access that n later?
13:32:51 <EvanR> dmwit: there might be, if the rest of the system is design to use length indexed vector
13:33:02 <dmwit> reygoch: You can store a singleton representing the n.
13:33:11 <roconnor> Hi all.  What's the best way of interfacing a foriegn ccall with a ShortByteString.  I have a C function that takes a ptr and I want a haskell interface with a ShortByteString parameter?
13:33:39 <reygoch> dmwit: ok, I guess I'm going to read up on singletons
13:34:16 <dmwit> reygoch: Depending on the implementation of Vector, you can likely recover n by pattern-matching on the vector itself just as efficiently as by pattern-matching on a singleton.o
13:35:09 <EvanR> is "singletons." the same answer as "store the n along with the vector itself" ?
13:35:41 <EvanR> (n, myVec) :: (Int, SomeVec a)
13:35:46 <reygoch> EvanR: if it is, than that isn't really storing the list length in the type, right?
13:36:09 <EvanR> it isnt, but it might make way more sense
13:36:22 <reygoch> but it ain't what I'm after :D
13:36:39 <reygoch> I want safe matrix operations and such :D
13:36:40 <EvanR> storing sounds like runtime activities. Types do not exist at runtime to store anything in
13:37:08 <EvanR> if you want matrix operations, you dont necessarily need the actual n
13:37:24 <EvanR> since the type checker makes sure what youre going to do is well formed
13:37:49 <reygoch> How can he do that if the matrix is dynamically loaded?
13:37:54 <monochrom> roconnor: Maybe go through [Word8] or ByteString first...
13:38:18 <EvanR> what is your Vec made of?
13:38:21 <EvanR> at runtime
13:39:31 <Lycurgus> "at runtime" has a discordant sound here, as if it were an affront to the mathesis
13:39:56 <monochrom> Sorry, what is mathesis?
13:39:58 <EvanR> if its a linked list, then you can imagine how the algorithm goes. if its an array with sized stored, well there you are
13:40:22 <EvanR> if its an array without size stored, then youre screwed
13:41:12 <Lycurgus> more jangling sounding real things. en.wikipedia.org/wiki/Mathesis_universalis
13:41:23 <EvanR> *that doesn't cover all the possible ways to implement matrices
13:42:13 <Lycurgus> said concept underlies hs as a programming model based pure mathematics
13:42:46 <monochrom> Unfortunately Haskell's dynamic semantics is also full of math.
13:43:27 <monochrom> This is what's wrong with the Curry Howard zealots. They think that all of the math happens statically.
13:44:50 <dmwit> Here's what existentially quantifying the length of a length-indexed vector can get you: at significant syntactic cost, and significant runtime cost, the compiler will verify that you have done a bounds check each time you index into the vector.
13:45:24 <EvanR> hmm, is there a runtime cost?
13:45:54 <roconnor> monochrom: how do I do it with ByteString?
13:45:58 <dmwit> Here's what making your vector an abstract type can get you: at no syntactic cost and no runtime cost, but minor module-creation-time programmer time cost, the compiler will verify that you have done a bounds check each time you index into the vector.
13:46:00 <EvanR> assuming you need to do the checks, and you can't satisfy the checker some other way that its checked
13:46:24 <Lycurgus> *based on
13:46:29 <dmwit> EvanR: Yes, and a hefty one: most implementations work by storing the length of the vector as a Peano nat, and comparisons on those are SLOW SLOW SLOW.
13:47:00 <dmwit> EvanR: If the length of the vector is existentially quantified, because it came from user input, you cannot avoid the check.
13:47:22 <EvanR> ah ok. thats a few "gotchas" in a row...
13:47:49 <dmwit> EvanR: And even if you can avoid the check, the index itself is almost certainly stored as a Peano nat, so indexing is SLOW SLOW SLOW.
13:47:56 <EvanR> to get the type straight and make the execution remotely sane, we still have a lot of work to do
13:48:23 <phadej> dmwit: it's not much slower than !! 
13:48:25 <phadej> on lists
13:48:26 <EvanR> get work done with abstract data types today
13:48:31 <roconnor> monochrom: ah useAsCStringLen!
13:48:35 <dmwit> phadej: No, but much slower than (!) on Seq.
13:48:45 <dmwit> phadej: And slower still compared to (!) on Array.
13:48:59 <monochrom> roconnor: There are a couple of "unsafePackCString" things in Data.ByteString.Unsafe. 
13:49:55 <monochrom> There are also not-unsafe versions in Data.ByteString.
13:53:57 <phadej> dmwit: I lost what you argue about. Do you say that peano nats are bad, but also approaches like http://hackage.haskell.org/package/sized-0.3.0.0/docs/Data-Sized.html
13:55:39 <EvanR> is not-not-unsafe = unsafe a law?
13:56:24 <phadej> EvanR: not-not-not A -> not A is a theorem
13:57:10 <EvanR> right
13:58:04 <ym555> :nmap <Space> :go
13:58:15 <ym555> :nmap <Space> :go
13:58:24 <phadej> doesn't work on IRC!
13:58:32 <ym555> sorry lol
13:58:38 <phadej> no worries
14:14:07 <tathougies> Any suggestions on getting haskell-src-exts to compile on memory constrained machines?
14:14:09 <tathougies> https://circleci.com/gh/tathougies/beam/33
14:15:33 <Lycurgus> x-compile
14:16:36 <shapr> there are some GHC options that will cut down memory use, but I suspect it'll increase your compile time too much
14:26:38 <merijn> hmmm, what does the PVP say about changes to a function's type that are 100% backwards compatible? i.e. I have a function 'foo' whose type gets generalised so that it can be applied to more things. Would that require a version bump?
14:31:57 <monochrom> "Bad" is vague. Peano nats are exponential-time.
14:40:06 <Solonarv> exponential in what sense? addition is linear-time, afaik
14:41:51 <monochrom> In the sense that an n-bit number takes 2^n space in unary notation.
14:43:10 <EvanR> so exponential space in the number of bits (itself a log measure of the numbers size)
14:43:16 <EvanR> so it all cancels out
14:43:45 <dmwit> phadej: Sure, in most implementations I've seen, getting your hands on an Ordinal n suitable for use with a SomeSized f nat a will require a bounds check, generally on a Peano nat so that the index on the Peano nat can be reflected well enough into the type system to compare with the existentially quantified singleton.
14:43:49 <EvanR> O(0): everybody gives up and goes to lunch
14:44:04 <dmwit> phadej: So even if you use a type with good indexing properties you *still* have to pay the cost.
14:44:26 <merijn> hmm, what's the easiest way to generate a random value of a type that has an Eq instance?
14:44:40 <merijn> Or should I just say "meh" and just generate a random Int
14:44:54 <monochrom> Prime factorization would not be considered computationally difficult if the input were in unary notation.
14:45:19 <dmwit> merijn: The easiest way is to use the Arbitrary instance for that type.
14:45:47 <phadej> dmwit: why SomeSized f?
14:46:02 <phadej> why not Sized f n?
14:46:05 <dmwit> phadej: Because it's coming from user input apparently.
14:46:11 <merijn> dmwit: No, I don't even care about what type it generates, as long as it has an Eq instance
14:46:22 <dmwit> merijn: Then use ()
14:46:40 <dmwit> (Or: I don't believe that you don't care what type it generates.)
14:46:46 <merijn> dmwit: That's not very random for testing
14:46:47 <phadej> dmwit: you can and should reify size early ans not wrap/unwrap it all the time
14:47:02 <merijn> dmwit: I'm testing whether two polymorphic operation have the same result
14:47:15 <monochrom> merijn: dmwit is saying you actually care.
14:47:48 <monochrom> But the easiest way is to add a Random constraint.
14:48:12 <phadej> dmwit: SomeSized f is indeed a pessimisation compared to `f`
14:48:14 <dmwit> merijn: Choose a type to test them on.
14:48:58 <monochrom> Yes. Parametric polymorphism implies that you can extrapolate from one type to all types.
14:49:13 <dmwit> Hm. I'm not sure I'd go that far.
14:49:23 <phadej> QuickCheck has A B C wrappers over Int, if you need many different types
14:49:27 <dmwit> Depending on exactly where your quantifiers are.
14:49:29 <monochrom> Suppose you give me "f :: a -> [a]".  Sure I still don't know what it does.
14:49:42 <dmwit> Parametric polymorphism implies that there is a choice of type for which you can generalize from that type to all types. =)
14:49:44 <monochrom> But I only have to try "f ()".
14:49:54 <dmwit> But you still might have to be smart to pick the right type.
14:50:23 <monochrom> If f () = [(), (), ()] then I know that f "hello" = ["hello", "hello", "hello"] too. You have no choice.
14:50:57 <monochrom> If you say your type is not as simple as a -> [a], then let's talk.
14:51:02 <monochrom> BRING IT ON
14:52:21 <monochrom> (I really fail to understand the mentality of asking a question such that minimum information is revealed in the question and maximum elaborate is expected of the answer.)
14:53:06 <shachaf> monochrom: Someone asked the question recently: How many functions : forall a. Preorder a -> Preorder a are there?
14:53:12 <monochrom> (Especially in an environment free of tuition fee or consultation fee.)
14:54:24 <monochrom> What is the definition of Preorder?
14:55:42 <shachaf> A reflexive transitive relation on a
14:56:03 <shachaf> Really this question is still a bit underspecified.
14:56:05 <monochrom> But at any rate, my example of a->[a] is not a bad example. There are infinitely many functions of that type. Even if you just count total functions. The point is I just have to test at one type one value to nail it.  Or generally just a few types and a few values.
14:57:36 <monochrom> Also "testing" carries the connotation of "doesn't have to nail it, just have to be good enough confidence" so you can even decrease the number of test cases further if you're OK with "just high confidence, doesn't have to nail it"
14:58:14 <dmwit> shachaf: Follow-up question: which type has more implementations, a -> b or Void -> b?
14:59:59 <shachaf> dmwit: This is in a well-behaved language without partial value nonsense, not in Haskell.
15:00:28 <monochrom> The preorder question is interesting.
15:00:28 <dmwit> monochrom: A fun result in this domain not obviously related to parametricity: a sorting network which works correctly on bits works correctly on any ordered type.
15:01:19 <dmwit> https://en.wikipedia.org/wiki/Sorting_network#Zero-one_principle
15:02:19 <monochrom> Hey that's nice.
15:03:21 <dmwit> shachaf: Part of the joy of my question is that the answers to my question are so surprisingly different in those two settings.
15:03:53 <monochrom> Yeah a simulation relation is also a commuting diagram quite like min-of-f = f-of-min, eh?
15:05:09 <shachaf> Did you know sorting networks work on values that don't have decidable comparison?
15:05:20 <shachaf> For example infinite lists of bits, or computable reals.
15:05:28 <monochrom> No.
15:05:33 <dmwit> What does that mean?
15:05:44 <shachaf> min and max are computable for computable reals.
15:06:02 <shachaf> So you can view each edge in a sorting network as computing (min(x,y),max(x,y))
15:06:16 <dmwit> Oh, neat!
15:06:54 <shachaf> This is pretty strange if you think of sorting algorithms as extracting some permutation information from the input and then applying the permutation.
15:06:55 <c_wraith> wait, min and max are computable for computable reals?
15:06:59 <EvanR> haha
15:07:00 <EvanR> awesome
15:07:15 <EvanR> and so all the min and max stuff on distributed systems applies
15:07:32 <EvanR> computable reals win flawless victory... maybe
15:07:42 <dmwit> shachaf: Okay, I have a question about your preorder question. What does reflexive mean?
15:08:04 <EvanR> c_wraith: if they are equal... then either ones works as the output
15:08:20 <EvanR> otherwise either prefix works
15:08:22 <monochrom> c_wraith: Recall that with min(x,y) you don't have to first find out who is smaller, you just have to start telling me the stream of digits of the answer.
15:08:44 <c_wraith> monochrom, ah, clever. so it's productive.
15:08:46 <dmwit> c_wraith: Suppose you represent computable reals as a sequence of rationals. Then min and max can operate pointwise.
15:08:56 <monochrom> If I'm going to read the 1st n digits of the answer, you just need to examine the first n digits of x and y.
15:09:16 <monochrom> The showbiz knows. Streaming is the future!
15:09:20 <dmwit> monochrom: I'm surprised at you. I would have expected you of all people not to fall into the "first n digits" trap. =P
15:09:27 <c_wraith> dmwit, only pointwise until the first non-equal point is foj d.
15:09:32 <c_wraith> *found
15:09:46 <dmwit> c_wraith: No, it can proceed pointwise indefinitely.
15:09:59 <monochrom> dmwit: What is that trap?
15:10:25 <shachaf> dmwit: https://twitter.com/arntzenius/status/1039533494504968192 is the source of this puzzle
15:10:33 <dmwit> monochrom: You can't in general know the first digit of a computable real.
15:10:46 <dmwit> monochrom: You may have to keep looking arbitrarily deep to know whether it's going to "round up" or "round down".
15:11:16 <c_wraith> dmwit, well, it's a pointwise algorithm. but it's not just min or max of the points.
15:11:23 <monochrom> I kind of require and assume no rounding.
15:12:03 <dmwit> monochrom: https://en.wikipedia.org/wiki/Rounding#Table-maker's_dilemma
15:12:11 <monochrom> I just go with Turing's definition of computing [real] numbers.
15:12:13 <dmwit> c_wraith: Yes, it's just min or max of the points.
15:12:19 <dmwit> monochrom: Turing got it wrong.
15:13:24 <dmwit> monochrom: ...for essentially the same reason that 0.999999... = 1.
15:13:27 <c_wraith> dmwit, so.. min(1.5, 2.4) = 1.4?
15:13:57 <dmwit> c_wraith: No. But also the representation of the computable real 1.5 as a sequence of rationals is not [1,0.5].
15:14:42 <monochrom> I don't accept that sequence of rationals solves that problem. It just manipulates people's expectation.
15:14:43 <EvanR> actually you could take any (working) "digits" real from monochrom and convert it to a working one
15:14:59 <c_wraith> oh, you're assuming a representation that most libraries don't use.
15:15:01 <EvanR> so its morally correct
15:15:23 <EvanR> the one libraries use can be converted to any working representation
15:15:37 <dmwit> c_wraith: In fact I am assuming the representation that CReal uses: give me an ULP, and I'll give you a rational within 1 ULP of the right number.
15:16:25 <dmwit> c_wraith: You can choose to represent this as a function, or as a sequence of rationals with implicit ULPs decreasing by a factor of 2 at each step; both are common choices.
15:16:26 <EvanR> assuming somebody gives you two reals that dont fail to give the next digit, it will work
15:16:36 <dmwit> c_wraith: In either representation, min and max proceed pointwise.
15:21:27 <dmwit> EvanR: I reject your argument. `\() -> 0` converts any () to a computable real, but I don't consider () a morally correct representation of computable reals.
15:22:28 <monochrom> That just means EvanR's wording was too simple.
15:22:36 <dmwit> No, it turns out to be fundamental.
15:22:41 <dmwit> This is surprising, I agree.
15:23:43 <monochrom> But in my case I consider it psychological (even fundamentally psychological) not logical-mathematical (not even fundamentally logical-mathematical).
15:24:32 <EvanR> no
15:24:44 <EvanR> i understand the situation, i'm trying to throw monochrom a bone :)
15:24:59 <monochrom> I'm asked for seven digits and I answer "0.9999999". Some people then just presume, out of the blue, that I'm not going for 1.
15:25:20 <EvanR> if you have an infinite stream of digits, then it can be mapped to an equivalent in value computable real in a proper representation
15:26:12 <monochrom> But if I do the sequence of rationals and answer "9/10, 99/10, ..,. 9999999/10000000", then suddenly people understand, out of the blue, that I have some possibiility of going for 1?!
15:26:31 <monochrom> I mean yes people do that, but they're wrong, not me, not Turing. It's psychological.
15:26:56 --- mode: glguy set +v dmrd_
15:27:15 <monochrom> Like what's the logical mathematical difference between "0.9999999 but there are more digits to come" and "9/10, 99/10, ..,. 9999999/10000000"?
15:27:22 --- mode: glguy set -v dmrd_
15:27:30 <EvanR> when i see unformatted doubles like 0.9999999999 i assume out of the blue its 1
15:28:14 <dmrd_> not sure if my last message got in (was not voiced) so here it goes again: anyone here familiar with `Core`? What is this `__DEFAULT ->` construct, and can it somehow be suppressed in the output / is it not actually part of core and instead just metada. Sorry if accidental spam there :)
15:28:23 <geekosaur> ...but it would be wise to know whether that's a mathematical real number, or a computer faking it with foating point
15:28:28 <geekosaur> floating
15:28:39 <geekosaur> althoigh one could argue "foading", soemtimes
15:30:12 <monochrom> geekosaur: Is it OK if I say that both the outputter and the inputter already agree that they're doing computable reals?
15:31:50 <geekosaur> even there I woudl have to ask *how* they're being computed; "computable" doesn't commit to much. but I'm down the rabbit hole as soon as I ask "how" anyway
15:32:08 <EvanR> min and max can work just juggling digits one by one, thats pretty cool
15:32:37 <EvanR> min of 0.9999... and 1.0000... is 0.9999... :)
15:32:46 <monochrom> dmrd_: __DEFAULT is the fall-through case. You can't get rid of it, because in most cases it is reachable code.  Do be warned that in core the cases are not nicely ordered, i.e., if a case comes later, it doesn't mean that it is tested for first.  Very often __DEFAULT comes first actually, but it is still the last resort.
15:32:50 <geekosaur> dmrd_, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType#Caseexpressions see at "model call-by-value"
15:34:02 <dmrd_> monochrom: and geekosaur: I see. It's syntax threw me off and I assumed that it may be just 'fluff'. Thanks for clarifying :) 
15:34:37 <monochrom> geekosaur: OK, so the two parties can agree that they're doing computabel reals, and now debate of the merits of various specific formats.  I am carrying out that debate.  Why sequence of digits does not have more "what if you do rounding" issues than sequence of rationals.
15:35:49 <monochrom> Eww typo. s/if a case comes later/if a case comes earlier/
15:36:08 <shachaf> whoa, I looked away and the computable real discussion is still ongoing
15:37:02 <geekosaur> actually, I was snarking at EvanR and somehow ended up in a debate with a mathematician
15:37:28 <geekosaur> which I kinda refuse to get into; I'm a sysadmin dabbling in the elder arts.
15:38:04 <shachaf> I agree with dmwit. Thinking of computable reals as a sequence of digits doesn't work.
15:38:08 <EvanR> as long as its bankers rounding we're all saved in the end
15:39:25 <monochrom> OK, what works?
15:39:48 <monochrom> Bear in mind that I have shown how sequence of rationals breaks just as much.
15:40:13 <EvanR> no sequence of rationals can be added, digits cant
15:40:20 <EvanR> so it doesnt break as much
15:40:41 <monochrom> Ah, I see, sorry.
15:40:52 <EvanR> (unless you use redundant "10+" digits)
15:42:06 <shachaf> Why do sequences of rationals break?
15:42:16 <dmrd_> folks hate to interrupt but I can't seem to effectively search for this info online. In fact, I'd appreciate some tips on this. But more concretely, how is one supposed to read the following snipped of core: `break<2>(ds)`?  As in, what does the number inside the brackets represent and how come there is a variable in parenthesis?
15:42:29 <shachaf> For any error you can name, a sequence of rationals will give you an estimate within that error.
15:42:49 <shachaf> I don't object to sequences of digits of the form "0.9, 0.99, 0.999, ..."
15:43:03 <shachaf> Only to "9, 9, 9, ..."
15:44:06 <monochrom> I haven't seen "break<2>(ds)" or similar.
15:44:41 <EvanR> stuff like 9/10 + 9/100 + 9/1000 + 11/10000 + 13/100000 + will also work, as long as the components do not grow too fast.
15:45:17 <EvanR> makes computation a lot easier if you dont need to carry :)
15:46:00 <dmrd_> here's a github gist of my situation in case that helps: https://gist.github.com/davidmrdavid/ff2c73a77c2a2860b0e2174cdea1b3ab
15:51:54 <monochrom> I see. If you are OK with pretending that break<3>(ds) just means ds, then cool. If not, if you already know that much and now want to find what break<3> adds, then I don't know, this is new to me.
15:53:00 <dmrd_> all good. appreciate you giving it a look monochrom :)
15:54:57 <monochrom> Hrm how do I get this? I'm doing -ddump-simpl and not getting break<n>.
16:01:08 <dmrd_> monochrom: I'm calling GHC as a library from within haskell. Here's a gist with the rough pattern: https://gist.github.com/davidmrdavid/b9ac5c61d6511585cabecd0bc4508611
16:01:39 <dmrd_> you'd need `ghc` and `ghc-paths` as dependencies. I'm using `liquidhaskell` to ANF the code but that is irrelevant for the example so I've commented it out
16:02:31 <dmrd_> a colleague of mine suggests that it may be the locations at which you can place a breakpoint when using a debugger
16:02:46 <dmrd_> and that the variable names inside the parenthesis might be the variables that you can inspect at that break point
16:02:56 <dmrd_> that seems reasonable
16:10:19 <hexagoxel> dmrd_: as a sidenote, as you are using setSessionDynFlags, i hope you are aware of https://ghc.haskell.org/trac/ghc/ticket/15541
16:12:11 <dmrd_> hexagoxel: looking at the ticket at a glance, I don't think I fully grasp its implications. i'll keep on reading
16:12:18 <monochrom> dmrd_: This comes really close to what you have: ghci F.hs -dsuppress-idinfo -dsuppress-coercions -dsuppress-type-applications -dsuppress-uniques -ddump-simpl
16:12:50 <monochrom> Note the "ghci".  So they are break points and they are there because ghci.
16:13:18 <dmrd_> oooooh
16:13:34 <monochrom> Basically you're using GHC-API's "load" so it is equivalent to ghci's :load
16:13:40 <dmrd_> monochrom: it's probably because I enabled the code to be interactively interpreted
16:13:44 <dmrd_> yeah yeah
16:13:57 <dmrd_> thanks monochrom ! Good catch
18:58:26 <milesrout> is there an existing parser combinator that lets you express N optional parsers in any order but each at most once? i.e. (a, b, ab, ba, []) or ([], a, b, c, ab, ba, bac, cba, etc.)
18:58:30 <milesrout> or do i have to write this
19:00:51 <zfnmxt> Does anyone here know any nice resources/papers on Hindley-Milner type inference (of a introductory nature)? Pierce's TAPL and Advanced TAPL has some decent stuff, but if anyone is aware of other good things, let me know!
19:01:49 <milesrout> zfnmxt: 'write you a haskell' was good enough for me to implement it in another language and feel like I have a decent intuition for it, but obviously it's not very academic
19:02:10 <zfnmxt> milesrout: I've already done that too :) 
19:02:49 <zfnmxt> I wish it had more theoretical development/explanation.
19:04:45 <zfnmxt> For example, the "generalization" rule is just stated. Had to wrestle with it for a while to understand the restriction on free type variables and such. 
19:09:03 <coldpresent> zfnmxt: i second that reference to HM-Calculus
19:09:30 <coldpresent> s/reference to/request for/
19:22:20 <maerwald> "cabal check" is a bit weird
19:22:36 <maerwald> asking me if I'm sure that I want license XY
19:42:12 <blankhart> how sure are you though?
19:46:34 <milesrout> maerwald: which license?
20:22:17 --- mode: glguy set +v dataN
20:22:28 --- mode: glguy set -v dataN
20:22:45 <dataN> is there another name for;
20:22:46 <dataN> data Taco f g a = Taco a | Burrito (f (Taco g f a))
20:22:47 <dataN> ?
20:22:59 <dataN> other than;
20:23:00 <dataN> data Burrito f g a = Burrito a | Taco (f (Burrito g f a))
20:24:22 <blankhart> Chimichanga?
20:28:28 <dataN> blankhard: no you cant just keep adding new types of mexican food containers because then how would you control the order of nesting?
20:29:31 <blankhart> burrito.........Monad?
20:33:27 <dataN> data Wrap f g a = Burrito (g (Wrap f g a)) | Taco (f (Wrap f g a))
20:37:04 <dataN> blankheart: no because there would be a different type of bind
20:38:49 <dataN> or would there?
20:44:07 <dyl> wrap, you mean?
20:49:08 <coldpresent> burritos bring to my mind monads as well
20:55:00 <coldpresent> dataN: why is it that in all your definitions, one of the data parameters is not used?
21:05:17 <MarcelineVQ> johnw: what are these sort of notation called, where does one learn them?  ≜    ≈     ∆; Γ ⊢ x : T    re: https://www.cs.purdue.edu/homes/bendy/Fiat/FiatByteString.pdf
21:07:16 <MarcelineVQ> also   { x : τ | P (x, e1, ..., en)}    or   e1 ⊇ e2   are these all from a common subject a person can persue or a mix of things?
21:07:47 <coldpresent> |- is turnstile, meaning "entails" or "proves"
21:11:33 <EvanR> type theory, logic
21:12:03 <coldpresent> you can check out the Stanford Logic course on Coursera, not sure if it's still free
21:12:39 <EvanR> your second notation derives from earlier logic notation, i have here some really old articles (pre 1900) where they have a backwards C instead of ⊇ for implies heh
21:18:43 <MarcelineVQ> Thank you both, all these rabbit holes man, so many rabbits
21:19:04 <MarcelineVQ> I literally can't even hold all these flopping thumpers
21:24:53 <EvanR> ~.
21:25:07 <EvanR> interesting
21:26:57 <coldpresent> i believe backwards-subset comes from the set-theoretic view of "implies"
21:34:36 <blankhart> i believe the rabbits come from unicode
21:35:20 <coldpresent> is there any reference to understanding two homomorphic functions between two algebraic data structures? in the last paragraph of 3.2 http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf
21:37:40 <coldpresent> where the definition of each homomorphic function refers to the other homomorphic function
22:28:40 <boj> is hoogle not accessible right now?
22:29:04 <maerwald> boj: works here
22:29:33 <boj> maerwald: alright, probably my end then
22:30:08 <boj> there it goes
22:57:24 <dminuoso> class (Applicative b, Applicative m, Monad b, Monad m) => MonadBase b m | m -> b where liftBase :: b α -> m α
22:57:37 <dminuoso> Is it assumed that `m` is not only a monad, but a transformed monad with `b` as its base?
22:58:20 <dminuoso> The reason Im asking is because this relationship is not explicitly documented in http://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html
23:25:56 <maerwald> getting a compile error about "cannot find object file ...Foo.dyn_o" while before that exact line it compiles Foo.p_o. What is going on there?
23:27:28 <dminuoso> maerwald: How did you compile your file?
23:27:58 <maerwald> dminuoso: with cabal new-build 
23:28:03 <maerwald> stack has the same error
23:30:40 <maerwald> it happens in a file that uses template haskell
23:31:11 <cocreature> maerwald: are you on 8.4? TH and profiling have definitely had problems in earlier releases
23:31:47 <dminuoso> https://hackage.haskell.org/package/managed
23:32:14 <dminuoso> This looks fairly interesting, seems I could get rid of MonadBaseControl with this =)
23:32:26 <maerwald> cocreature: yes, profiling is enabled too
23:33:33 <maerwald> ghc-8.4.3
23:38:09 <cocreature> maerwald: I don’t recall encountering problems with 8.4 myself but might be a good idea to go through the bugtracker
23:51:11 <koz_> How are all the Haskell folks today?
23:58:20 <[exa]> koz_: apparently everyone's busy programming haskell
23:58:52 <koz_> [exa]: Fair point.
