00:13:38 <gentauro> %t one = 1 : one
00:13:49 <gentauro> % one = 1 : one
00:13:49 <yahb> gentauro: 
00:13:59 <gentauro> % take 10 one
00:13:59 <yahb> gentauro: [1,1,1,1,1,1,1,1,1,1]
00:15:11 <gentauro> % :t one
00:15:11 <yahb> gentauro: Num a => [a]
00:16:46 <gentauro> is there a way to generate an infinite list of IO?
00:17:22 <Franciman> gentauro, what do you mean? You could do
00:17:33 <geekosaur> probably, but it will tend to be strict
00:17:33 <Franciman> return $ [1..]
00:17:53 <geekosaur> depending on whether you mean an infinite sequence in IO, ro an infinite sequence of IO
00:18:15 <gentauro> I mean, I need a need a inifinte list of a specific type (in this case of Key which is just (Word8, Word8, Word8, Word8)
00:18:37 <Franciman> also, pipes' Producers or ListT done right may be helpful
00:18:40 <gentauro> the Keys will needs to be randomly generated
00:18:57 <geekosaur> unsafeInterleaveIO comes to mind
00:19:09 <gentauro> and the size of the list will be limited by data with `zip`
00:19:26 <gentauro> example: zip finiteSet infRandomKeys
00:19:29 <Axman6> sounds like you're heading into lazy IO territory
00:19:42 <gentauro> Axman6: yeah, pretty much
00:20:08 <Axman6> sounds like a bad idea to me ;)
00:20:24 <gentauro> Axman6: well tell that to the peps who write RFCs ...
00:20:25 <gentauro> :|
00:20:28 <geekosaur> :t unsafeInterleaveIO
00:20:30 <lambdabot> error: Variable not in scope: unsafeInterleaveIO
00:20:34 <dminuoso> Axman6: Ever since I understood how lazy IO works it became obvious to me how problematic lazy IO really is.
00:20:38 <geekosaur> :t System.IO.Unsafe.unsafeInterleaveIO
00:20:39 <Axman6> @hoogle unsafeInterleaveIO
00:20:39 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
00:20:40 <lambdabot> IO a -> IO a
00:20:52 <Axman6> it's type should be MAgic#
00:20:56 <gentauro> Axman6: can't do unsafe
00:21:04 <gentauro> :)
00:21:17 <geekosaur> your alternative is using pips/conduit/etc.
00:21:19 <geekosaur> pipes
00:21:34 <Axman6> dminuoso: yes, it's a hack at best
00:22:01 <geekosaur> if those scare you too much or won't fit your use case somehow, then unsafeInterleaveIO is it
00:22:14 <dminuoso> Axman6: It was really surprising to learn that GHC at least ties execution of IO into evaluation though
00:23:17 <gentauro> geekosaur: like I said, I can't do unsafe
00:23:34 <geekosaur> you are tryng to emulate stuff intended for a C environment
00:23:47 <geekosaur> one way or another, theres going to be unsafe somewhere
00:23:52 <nshepperd1> Does it have to be IO? You can generate infinite lists of randoms purely
00:24:40 <gentauro> % RND.randoms <$> RND.getStdGen :: IO [ Word8 ]
00:24:40 <yahb> gentauro: ; <interactive>:98:1: error:; Not in scope: `RND.randoms'; Perhaps you meant one of these: `R.randoms' (imported from System.Random), `R.random' (imported from System.Random), `R.randomR' (imported from System.Random); No module named `RND' is imported.; <interactive>:98:17: error:; Not in scope: `RND.getStdGen'; Perhaps you meant one of these: `R.getStdGen' (imported from System.Ran
00:24:58 <gentauro> % System.Random.randoms <$> System.Random.getStdGen :: IO [ Word8 ]
00:25:04 <yahb> gentauro: [119,178,81,253,154,8,25,168,190,93,229,176,59,109,231,24,192,39,216,100,175,15,118,121,92,82,87,55,6,236,26,237,44,220,111,76,74,182,27,1,192,44,64,85,240,183,106,134,26,148,207,3,84,148,28,16,41,122,132,249,248,176,229,42,88,179,148,126,74,226,141,18,16,5,109,55,190,169,66,12,176,32,81,53,74,164,71,144,29,247,225,181,220,165,45,194,167,86,56,106,58,53,247,45,55,164,181,79,161,127,73,175,97,184,5
00:25:12 <gentauro> that would generate infinite amount of bytes
00:25:23 <gentauro> I'm just trying to generate inf many of a specific type
00:25:50 <gentauro> (should be possible without making usage of "strange" stuff)
00:26:16 <MarcelineVQ> entirely possible, problem description unclear
00:26:27 <gentauro> I guess I could try to implement the type class of Random for my type
00:27:33 <geekosaur> depends on how random it's supposed to be, given you claimed an RFC.
00:27:34 <nshepperd1> You should be able to write something that samples your type in lazy State StdGen
00:27:54 <geekosaur> althought here are pure crypto RNGs given appropriate seeds from IO
00:28:18 <nshepperd1> Then it's just evalState . sequence . repeat x
00:28:42 <gentauro> since I'm on a *nix box and that's what I'm aiming for, I would rely on /dev/random
00:28:59 <gentauro> which is what System.Random is built on iirc
00:29:14 <nshepperd1> Or if you need csprng security your state needs to be some crypto rng state yeah
00:30:01 <geekosaur> System.Random is built on a low quality PRNG seeded from /dev/random
00:30:26 <geekosaur> whose main claim to fame is it has a "split" operation wose behavior is at least soemwhat characterized
00:37:27 <mniip> hmm
00:38:03 <mniip> PRNGs are usually thought of as a kind of moore machine
00:38:11 <mniip> this on the other hand produces a binary tree not a list
00:42:08 <superlinux> hello. how can I make stack download all packages then build them all when running `stack install blah` ?
00:48:11 <geekosaur> isn't that what it normally does? or do you mean you don't want it to cache prebuilt packages?
00:50:09 <mniip> is there a package with like some instances of Control.Category
00:50:25 <mniip> ekmettian "categories" seems to mostly define new classes
01:02:57 <cppxor2arr> wow looks like i should hang around here: > let pairs = zip <*> tail in pairs [0..10]
01:04:00 <Ariakenom> > let pairs = zip <*> tail in pairs [0..10]
01:04:03 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
01:05:38 <mniip> > zip`ap`tail $ []
01:05:40 <lambdabot>  []
01:05:56 <mniip> zip is right-lazy, eh?
01:06:02 <cppxor2arr> ye
01:06:30 <opqdonut> > zip [1] (1:undefined)
01:06:32 <lambdabot>  [(1,1)]
01:06:51 <Ariakenom> zip (1:undefined) [1]
01:06:54 <Ariakenom> > zip (1:undefined) [1]
01:06:56 <lambdabot>  [(1,1)*Exception: Prelude.undefined
01:07:22 <mniip> > zipWith undefined [] undefined
01:07:24 <lambdabot>  []
01:08:02 <mniip> it's almost like,
01:08:05 <mniip> @src zipWith
01:08:05 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
01:08:05 <lambdabot> zipWith _ _      _      = []
01:08:09 <Ariakenom> mniip: Did you know that undefined is not a function?
01:08:22 <mniip> undefined can be anything you want it to be
01:08:34 <mniip> (even an unlifted-kinded term)
01:08:46 <Ariakenom> really?
01:08:54 <mniip> % I# undefined
01:08:58 <yahb> mniip: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:1:4 in interactive:Ghci4
01:09:03 <cppxor2arr> ok this is cool
01:09:37 <mniip> % let x :: Void#; x = undefined; in ()
01:09:37 <yahb> mniip: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:2:21 in interactive:Ghci4
01:10:02 <mniip> (unlifted-kinded bindings are strict)
01:11:02 <Ariakenom> % :k I#
01:11:02 <yahb> Ariakenom: I# :: Int# -> Int
01:11:17 <mniip> yeah that's the Int constructor
01:11:22 <Ariakenom> % :k Int#
01:11:22 <yahb> Ariakenom: Int# :: TYPE 'GHC.Exts.IntRep
01:12:12 <Ariakenom> yes, wanted to see it's unliftedness
01:13:14 <mniip> I remember someone here was wondering if there's a function that would evaluate its argument when it was _applied_ rather than when its result was evaluated
01:13:27 <mniip> and everyone was like nooo, and I came up with:
01:13:55 <mniip> % force :: a -> Void#; force x = seq x (\() -> void#) ()
01:13:56 <yahb> mniip: 
01:14:09 <mniip> % let x = force () in ()
01:14:09 <yahb> mniip: ()
01:14:12 <mniip> % let x = force undefined in ()
01:14:12 <yahb> mniip: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:7:15 in interactive:Ghci6
01:16:02 <Ariakenom> % :k Void#
01:16:02 <yahb> Ariakenom: Void# :: TYPE ('TupleRep '[])
01:16:37 <Ariakenom> ... shouldn't that be Unit#?
01:17:10 <mniip> kind-of
01:17:23 <mniip> think C void :P
01:17:43 <Ariakenom> ya but I don't want to :)
01:18:12 <Ariakenom> that terminology crash had me confused for a bit. but I get it
01:18:29 <Ariakenom> cool hack!
01:25:39 <AWizzArd> I have a few extensions turned on with GHC 8.2. Now ghci shows me for   :k (->)   the kind:   (->) :: TYPE q -> TYPE r -> *
01:25:53 <AWizzArd> Why is it ending in a `*` and not ending in just  `TYPE`?
01:26:07 <AWizzArd> Why is it mixing notations?
01:26:26 <asheshambasta> How does one go about defining "hierarchies" like these in Haskell? https://gist.github.com/asheshambasta/8e3de44ad83164396aaad44e23089999
01:27:46 <Ariakenom> AWizzArd: * is more specific than TYPE x, though?
01:28:25 <AWizzArd> Ariakenom: I thought that `TYPE` can occur standalone, without kind variables.
01:28:25 <Ariakenom> * is the normal lifted kind while TYPE x can be Void# mentioned above
01:28:41 <Ariakenom> * = Type /= TYPE
01:28:46 <AWizzArd> Oh.
01:28:57 <AWizzArd> There is `TYPE` _and_ there is `Type`?
01:28:58 <mniip> * = TYPE LiftedRep
01:29:06 <mniip> * = Type
01:29:54 <AWizzArd> Ooh okay. So the capitalized `Type` stands for the inhabited kind. While `TYPE` needs a kind variable?
01:32:23 <mniip> in GHC.Exts there's literally
01:32:28 <mniip> type Type = TYPE LiftedRep
01:33:12 <AWizzArd> Hmm okay I see.
01:33:32 <AWizzArd> Interesting. I wasn’t aware of the uppercase TYPE. Only read about the capitalized one so far.
01:37:03 <Ariakenom> % let x = undefined :: Void# in () -- great snippet, thanks mniip
01:37:03 <yahb> Ariakenom: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:10:9 in interactive:Ghci6
01:38:11 <mniip> hmm, the category of strict categories has a sort of monoidal structure
01:38:28 <mniip> if you split it into subcategories according to the cardinality of object sets
01:38:40 <mniip> hmm that's not strong enough
01:38:51 <mniip> according to equality of object sets
01:39:15 <mniip> then you can do componentwise product, and the thin connected groupoid as the identity
01:39:58 <superlinux> geekosaur, stack does not download all the dependencies in a single batch. 
01:44:18 <Ariakenom> If I want to search and find Void#. Where do I do that?
01:45:15 <MarcelineVQ> https://hoogle.haskell.org/?hoogle=Void%23
01:46:29 <Ariakenom> MarcelineVQ: thanks. new hoogle finds it. old didn't
02:31:06 <merijn> hmmm
02:32:12 <merijn> I don't suppose there's a way to turn an argument to a TH function into a quoted expression? i.e. I want to apply the function without manually quoting the thing I'm applying it to
02:32:30 <merijn> So "$(foo 15)" Rather than "$(foo [| 15 \])"
02:34:00 <merijn> Alternatively, a method of lifting/defaulting polymorphic literals to a specific datatype would work too, as long as I could avoid the needless "ambiguous types" they produce
02:36:21 <merijn> I was thinking of simply having "data Literal = String String | Num Integer | Fractional Rational", and implementing IsString/Num/Fractional, but that, of course, breaks down as soon as you realise you can't really implement things correctly for those classes with that type
02:41:59 <merijn> Dammit...I really wish the Haskell report had taken more care to distinguish literals from just random polymorphic values
02:53:26 <Ariakenom> merijn: "can't implement things correctly" bottom is always correct
02:53:43 * Ariakenom leers evilly
02:53:48 <merijn> Bottom always type checks, it is far from always correct
02:58:02 <maqbool> An applicative functor has more structure than a functor but less than a monad What is the meaning of structure(Is it same as # of  operations?) 
02:58:27 <maqbool> https://wiki.haskell.org/Applicative_functor
03:00:59 <MarcelineVQ> I wonder what is meant by that, more laws maybe
03:02:16 <MarcelineVQ> maybe they mean it in some Catergory sense, dunno anything about that
03:05:41 <booglewoogle> hey. i'm a bit confused about how foldrs on infinite lists are handled: the accumulator is only entering the picture as an argument together with the very last element on the list by definition. when foldring on an infinite list, does it just interpret the infinite list as the list of those elements needed for evaluation so the acc can enter right there?
03:06:17 <tdammers> sounds more like an informal description
03:06:44 <tdammers> the only "structure" that a Functor has is fmap with its shape-preserving property
03:06:54 <booglewoogle> that would be a different thing than, say, "take 5 [1..]", right? since it actually has to change the argument to work with foldr
03:07:32 <tdammers> > foldr (+) 0 [1..]
03:07:39 <lambdabot>  mueval-core: Time limit exceeded
03:07:39 <lambdabot>  mueval: ExitFailure 1
03:08:43 <tdammers> can you implement foldr and foldl yourself? If so, then it should be easier to understand how they work
03:08:52 <booglewoogle> > take 20 $ foldr (+) 0 [1..]
03:08:54 <lambdabot>  error:
03:08:55 <lambdabot>      • No instance for (Enum [()]) arising from a use of ‘e_12001’
03:08:55 <lambdabot>      • In the expression: e_12001
03:08:59 <booglewoogle> hmm
03:09:05 <booglewoogle> the question came up here: https://pastebin.com/9CmaLDz8
03:09:29 <sshine> why doesn't 'Data.Function.fix :: (a -> a) -> a' have an 'Eq a => ...'?
03:09:32 <booglewoogle> ruler evaluates just fine, and the accumulator (repeat 19 here) doesn't play any role in it
03:09:44 <tdammers> :t foldr
03:09:45 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:10:04 <tdammers> so conceptually :: (a -> b -> b) -> b -> [a] -> b
03:10:10 <booglewoogle> yep
03:10:16 <tdammers> so how would you implement that
03:10:27 <tdammers> foldr f x [
03:10:38 <tdammers> foldr f x [] = x -- obviously
03:10:52 <tdammers> foldr f x (y:ys) = ?
03:11:08 <booglewoogle> that'd be 
03:11:18 <MarcelineVQ> sshine: why should it?
03:11:30 <booglewoogle> f y (foldr f x ys)
03:11:51 <lavalike> @src fix
03:11:52 <lambdabot> fix f = let x = f x in x
03:12:15 <tdammers> so what happens when you pass an infinite list of y's?
03:12:38 <tdammers> you get something like f y0 (f y1 (f y2 (f y3 ...
03:13:07 <lavalike> sshine: one way to figure that out is imagining that repeated application of f actually halts at a finite point, it is not checking whether x == f x
03:13:16 <booglewoogle> yea, and the x moves ever further to the right, never entering the picture defacto if you evaluate the whole thing, right?
03:13:28 <tdammers> you can't evaluate the whole thing
03:13:33 <tdammers> not completely, that is
03:13:39 <booglewoogle> yea i mean hypothetically
03:13:49 <tdammers> right
03:14:02 <tdammers> you'd have to reach the end in order to demand x, but there is no end
03:14:08 <lavalike> sshine: that is let x = f x tells us, by replacing the left side into the right side, that x = f (f x) [ the x on the right replaced with the x on the left, which is = f x ]
03:14:15 <tdammers> but depending on how you implement f, the whole thing may still terminate
03:14:42 <booglewoogle> so when i do a take 20, it has to reduce the argument 'ys' to just however many elements of the infinite list are needed for evaluation, correct? so it reaches the accumulator
03:15:03 <tdammers> ah, your take 20 didn't work because foldr in this case is supposed to return Integer or sth
03:15:09 <tdammers> so it simply doesn't typecheck
03:15:15 <booglewoogle> ah
03:15:23 <booglewoogle> yeah, okay
03:15:26 <tdammers> but if your f builds another list, then you can call take on that
03:15:42 <tdammers> take 20 $ foldr (:) [] [0..]
03:15:47 <tdammers> > take 20 $ foldr (:) [] [0..]
03:15:48 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
03:15:54 <tdammers> see? that terminates
03:16:00 <booglewoogle> yeah
03:16:25 <booglewoogle> ya, i had it terminate in a function similar to this -- https://pastebin.com/9CmaLDz8 -- and the fact that it terminated at all confused me
03:16:37 <tdammers> that's due to lazy evaluation
03:17:15 <tdammers> take 20 only demands the first 20 elements of the result, and thus after the 20th element, the second argument to (:) isn't demanded, and so the foldr recursion isn't evaluated any further
03:17:31 <tdammers> > take 20 [0..] -- is more obvious
03:17:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
03:17:40 <booglewoogle> yeah
03:17:42 <booglewoogle> i got that
03:17:46 <booglewoogle> so what i mean is:
03:17:58 <booglewoogle> when i do
03:18:16 <booglewoogle> > take 3 $ foldr (:) [] [0..]
03:18:18 <lambdabot>  [0,1,2]
03:18:35 <booglewoogle> it does do: take 3 foldr (:) [] [0,1,2] really
03:18:40 <booglewoogle> thus changing an argument to foldr
03:18:48 <tdammers> no
03:18:55 <tdammers> no, it doesn't do that really
03:18:57 <booglewoogle> because if it used [1..] it wouldn't reach the acc
03:18:59 <booglewoogle> okay
03:19:06 <booglewoogle> hm
03:19:34 <tdammers> > take 5 $ foldr (++) "world" (map show [23..])
03:19:37 <lambdabot>  "23242"
03:20:00 <tdammers> it doesn't change foldr's argument; it just doesn't demand all of its return value
03:20:19 <tdammers> and that lack of demand, so to speak, bleeds through the entire function application chain, down to foldr
03:20:31 <booglewoogle> okay
03:20:37 <booglewoogle> i think something's clicking
03:22:08 <tdammers> :)
03:22:44 <booglewoogle> oof
03:23:07 <booglewoogle> it's still blurry
03:23:24 <tdammers> try evaluating that thing using pen and paper
03:23:29 <tdammers> the whole thing
03:23:39 <tdammers> take 3 $ foldr (:) [] [0..]
03:23:45 <booglewoogle> yeah, i actually have
03:23:50 <booglewoogle> what baffles me here is
03:24:31 <lavalike> a text editor also works (:
03:28:02 <booglewoogle> okay
03:28:07 <booglewoogle> >take 3 $ foldr (\x (y:ys) -> (x+y):ys ) [3] [1..]
03:28:35 <booglewoogle> oh maybe i did this wrong
03:28:53 <geekosaur> it's call by need. if there's no need, there's no call. "take 5" needs only 5 items from the list, so no need for anything else to be done once it has them
03:29:12 <booglewoogle> i'm looking for an example where the value of the acc matters, so it has to be included for the evaluation to be correct
03:29:47 <booglewoogle> and to get the first 5 elements of that folded list, it has to calculate something with this acc somewhere, right?
03:30:26 <booglewoogle> so if it does this with some fixed element x in [1..], it's basically changing the argument to [1..x], doesn't it?
03:30:41 <booglewoogle> because that's where by definition foldr would combine x with the acc
03:30:45 <geekosaur> and you missed a space after the > there
03:30:56 <tdammers> my first example requires the accumulator
03:31:02 <tdammers> > foldr (+) 0 [1..]
03:31:09 <lambdabot>  mueval-core: Time limit exceeded
03:31:47 <tdammers> it's essentially 1 + 2 + 3 + ... + ∞ + 0
03:32:12 <booglewoogle> if it was +5 tho
03:32:28 <tdammers> > foldr (+) 5 [1..] -- you mean?
03:32:28 <booglewoogle> it would have to do for, say take 3, 1+2+3+5
03:32:35 <lambdabot>  mueval: ExitFailure 1
03:32:50 <tdammers> > foldr (+) 5 (take 3 [1..])
03:32:53 <lambdabot>  11
03:32:59 <tdammers> that obviously terminates, because now the list isn't infinite anymore
03:33:22 <booglewoogle> nene, i mean
03:33:27 <booglewoogle> nono*
03:33:40 <booglewoogle> > take 3 $ foldr (+) 5 [1..]
03:33:43 <lambdabot>  error:
03:33:43 <lambdabot>      • No instance for (Enum [()]) arising from a use of ‘e_1351’
03:33:43 <lambdabot>      • In the expression: e_1351
03:33:48 <tdammers> that doesn't typecheck
03:33:55 <booglewoogle> at some point +5 has to happen
03:33:56 <tdammers> because the result of folding with (+) is not a list
03:34:13 <tdammers> +5 can't happen as long as the list is infinite
03:34:22 <booglewoogle> by definition, if you write it out, this is (1+(2+(3+(... +5)...))
03:34:39 <booglewoogle> but it's moving the +5 to the left
03:34:44 <booglewoogle> next to the 3
03:34:56 <tdammers> that can only happen if the argument list is finite
03:35:06 <booglewoogle> yeah
03:35:53 <booglewoogle> this is why i felt like it would be changing the argument (during and only for evaluation) to [1,2,3], because only here (if you apply definition of foldr) the +5 would come next to the 3 when writing out the sum
03:43:35 <booglewoogle> oh whoops, i was in a train of thought up there... 
03:43:41 <booglewoogle> > take 3 $ foldr (\x (y:ys) -> (x+y):y:ys ) [5] [1..]
03:43:47 <booglewoogle> this is better
03:43:48 <lambdabot>  mueval-core: Time limit exceeded
03:45:12 <booglewoogle> so it actually doesn't change the arguments and thus doesn't evaluate huh.. i may be overseeing something very simple here, but why does 'ruler' evaluate here https://pastebin.com/9CmaLDz8 then?
03:45:38 <fendor> > take 1 $ foldr (\x (y:ys) -> y:(x+y):ys ) [5] [1..]
03:45:45 <lambdabot>  mueval-core: Time limit exceeded
03:45:45 <lambdabot>  mueval: ExitFailure 1
03:45:50 <merijn> hmm
03:46:07 <merijn> What is the Typed TH equivalent of lift?
03:50:44 <phadej> merijn: none: https://ghc.haskell.org/trac/ghc/ticket/14671
03:51:48 <MarcelineVQ> @src foldr
03:51:48 <lambdabot> foldr f z []     = z
03:51:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:52:35 <merijn> phadej: bleh
03:53:33 <MarcelineVQ> interleaveList doesn't try to see what constructor ys is made of, so when we have f x (foldr f z xs)  where f is interleaveList, we don't immediately demand ys which is (foldr f z xs)
03:54:08 <MarcelineVQ> So we don't have to keep recursing foldr unless it's demanded, like  take 20  is demanding
03:54:47 <phadej> merijn: world is never ready
03:56:59 <MarcelineVQ> I realize that's not especially informative if you don't already understand how constructors relate to evaluation in haskell, but I'm not confident in explaining that also.
03:57:35 <MarcelineVQ> rather there's a good folding tutorial I'm entirely failing to find currently
03:57:46 <booglewoogle> heh, i was gonna ask how that interconnects
03:59:45 <booglewoogle> thanks either way! at least i now have an idea on where to look
04:01:31 <MarcelineVQ> Ah, so it was ertes after all http://ertes.eu/tutorial/foldr.html  I never did go throught this tutorial myself so I'm not sure how comprehensive it is in the 'why' department.
04:01:52 <MarcelineVQ> But at the very least you won't know less by the time you've worked through it
04:03:22 <booglewoogle> still confused in this sense: the leftmost interleaveList in the last line has to pluck elements from the list that is in the rightmost parentheses, which is built by the foldr, which therefore has to dish out the first few elements at some point without. here it works easy because the repeat 19 doesn't play any role for any finite left part of the list, but i wonder: what if it did, how exactly would the whole term being 
04:03:22 <booglewoogle> evaluated, including the accumulator, look
04:04:11 <tdammers> it would have to be a finite list, or a fold function that isn't foldr
04:04:14 <booglewoogle> MarcelineVQ: thanks!
04:05:19 <booglewoogle> tdammers: so it actually realizes here a priori that the value of the acc isn't needed (only the type) and evaluates on this ground?
04:05:43 <tdammers> no, it just starts evaluating things as they are needed, and never gets to the point where it needs acc
04:06:42 <tdammers> if you ask Haskell what the elements of the infinite list [0..] are, it doesn't go "oh, but I can't tell you that, because you see the list is infinite, and if I wanted to enumerate its elements, I'd have to hold an infinite list in my finite memory"
04:06:59 <tdammers> instead, it will happily start printing them, evaluating the list as needed
04:07:00 <booglewoogle> hrng, but foldr is right-associative, isn't it? so 'starting to evaluate''s first step includes the accumulator?
04:07:09 <tdammers> no
04:07:17 <tdammers> associativity has nothing to do with it really
04:07:40 <booglewoogle> okay
04:07:46 <tdammers> and the "r" in "foldr" doesn't mean right-associative in the usual sense; it means that foldr "recurses to the right"
04:07:54 <booglewoogle> yeah
04:07:58 <booglewoogle> okay
04:08:32 <tdammers> I think one important thing to understand here is that Haskell's list syntax is just syntax sugar for repeated applications of the list constructor (:)
04:08:41 <tdammers> i.e., [1,2,3] == 1:2:3:[]
04:09:00 <tdammers> so say you have f a b; what do you need in order to figure out its value?
04:09:15 <tdammers> well, first you need to know the definition of f
04:09:22 <booglewoogle> depends on its definition, no?
04:09:22 <booglewoogle> yea
04:09:26 <tdammers> let's say it is this: f x y = y
04:09:39 <booglewoogle> okay
04:09:56 <tdammers> OK, so now we can substitute that into our equation, and get (\x y -> y) a b
04:09:59 <booglewoogle> so i just need y and x isn't evaluated because of laziness
04:10:04 <tdammers> right
04:10:08 <merijn> hmm, is "runIO $ throwIO err" the right way to throw exceptions in the Q monad?
04:10:53 <booglewoogle> so when i have
04:11:04 <booglewoogle> foldr f z (x:xs) = x `f` foldr f z xs
04:12:35 <booglewoogle> hm
04:15:17 <MarcelineVQ> haskell has non-strict semantics if you want a possibly more useful term to google than lazy
04:15:47 <MarcelineVQ> But you should finish your thought there first
04:17:11 <booglewoogle> i'm trying to bring the pieces you gave me so far together -- but maybe another angle could help
04:17:26 <booglewoogle> looking at "take 3 $ foldr (\x (y:ys) -> (x+y):y:ys ) [5] [1..]"
04:17:59 <booglewoogle> could you write out for me the term that defacto gets reduced/evaluated here?
04:18:09 <booglewoogle> like it's written out here https://wiki.haskell.org/Foldr_Foldl_Foldl'
04:19:41 <geekosaur> > take 3 $ foldr (\x (y:ys) -> (x+y):y:ys ) [5] [a,b,c,d,e]
04:19:44 <lambdabot>  [a + (b + (c + (d + (e + 5)))),b + (c + (d + (e + 5))),c + (d + (e + 5))]
04:21:58 <sshine> MarcelineVQ, lavalike: thanks for the explanation of fix.
04:22:08 <lavalike> sshine: sure thing!
04:25:43 <merijn> dminuoso: ping?
04:25:47 <booglewoogle> okay, back now..
04:25:59 <booglewoogle> was there a reply to my last question?
04:26:10 <MarcelineVQ> geekosaur had an example
04:26:26 <MarcelineVQ> "<booglewoogle> could you write out for me the term that defacto gets reduced/evaluated here?"  to a point it can be shown but [1..] will not terminate given your f. take 3 has no say in the matter because your f is demanding the next call of foldr by inspecting the constructor (:) of it's 2nd argument
04:27:20 <booglewoogle> okay
04:28:05 <booglewoogle> thanks for copying it, and thanks geekosaur for the reply!
04:28:15 <MarcelineVQ> gj geekosaur!
04:30:14 <Saizan> does the windows haskell platform come with a shell capable of running a configure script? (needed for old-time, needed for cpphs)
04:32:24 <merijn> I need help with the hardest problem in programming: Naming things. I have a datatype for defining how to handle exceptions, but I can't figure out how to name it. "Handler" is already taken by Control.Exception.Handler anyone got brilliant suggestions?
04:32:46 <merijn> Or should I just say "screw it!" and shadow it?
04:33:09 <MarcelineVQ> ExceptionAbbatoir
04:33:29 <Ariakenom> booglewoogle: that wasn't a copy. here's the example:
04:33:32 <mfukar> `MotherHandler`
04:33:36 <Ariakenom> > take 3 $ foldr (\x (y:ys) -> (x+y):y:ys ) [5] [a,b,c,d,e]
04:33:38 <lambdabot>  [a + (b + (c + (d + (e + 5)))),b + (c + (d + (e + 5))),c + (d + (e + 5))]
04:35:00 <booglewoogle> Ariakenom: oh, i see, thanks. m-hm.
04:35:01 <Ariakenom> merijn: Manager, as all things should be named
04:35:54 <Ariakenom> strategy?
04:36:38 <MarcelineVQ> Wrangler
04:38:54 <Ariakenom> don't :: ExceptionStrategy
04:42:49 <booglewoogle> take 3 $ foldr f (repeat 19) (fmap repeat [1..]) where f (x:xs) ys = x : f ys xs
04:43:05 <booglewoogle> (how can i do a recursive function definition like this inline?)
04:43:08 <booglewoogle> this evaluates
04:43:16 <booglewoogle> i mean, if f is defined elsewhere
04:43:42 <MarcelineVQ> > let f (x:xs) ys = x : f ys xs in take 3 $ foldr f (repeat 19) (fmap repeat [1..])
04:43:45 <lambdabot>  [1,2,1]
04:44:08 <booglewoogle> oh i see, thank you
04:44:21 <MarcelineVQ> you have more options in source code, that's just easiest for lambdabot
04:44:28 <booglewoogle> alright
04:58:26 <booglewoogle> okay, i was trying to write this out like "(f (repeat 1) (f (repeat 2) (...", hitting the wall again, but writing it out incrementally with the definition of f instead, like (1:f(repeat 2)...) helped seeing how the list here really is constructed in a way where the acc never comes into play
04:58:53 <booglewoogle> so i think i realized the constructor's meaning here
04:59:12 <booglewoogle> i was too fixated on the first one and its right-associativity
05:00:27 <booglewoogle> but the pack was reshuffled when i actually reduced f incrementally
05:01:27 <booglewoogle> well, i'll read up on that fold tutorial and see if i may be on a hot track here. thanks again everyone for helping me out!
05:01:54 <Ariakenom> good luck! oh and have fun
05:02:04 <c50a326> https://ptpb.pw/nHRl/hs why does this, when I do `gcd' 1024 768`, print: WriterT (Identity (256,["1024 mod 768 = 256","768 mod 256 = 0","Finished with 256"])) -- and not Writer (256,... ?
05:02:35 <c50a326> in the type sig for the function I have ... -> Writer [String] Int
05:03:54 <bbaren> c50a326: `Writer w` is defined as `WriterT w Identity`.
05:04:15 <bbaren> So it’s just GHC printing in an unexpected way.
05:09:16 <merijn> hmm, there's no combinaion of "forkIOUnmask" and "forkFinally"?
05:11:51 <merijn> ah, wait, I think forkFinally is good enough for me
05:20:55 <merijn> If I wanna wait until a semaphere hits a specific value (without taking it) then I guess I just have to do "waitQSemN mySem n >> signalQSemN mySem n"?
05:28:18 <MarcelineVQ> merijn: Not much else in the way of options it looks like, was gonna suggest finally instead of >> but waitQSemN has exception safety in it, so it might end up double-signaling if that was done
05:28:56 <merijn> MarcelineVQ: I came up with a different solution of just using two separate semaphores, which is probably cleaner anyway
05:29:02 <MarcelineVQ> You rogue
05:29:09 <merijn> (one to check for termination, the other for *graceful* termination)
05:30:51 <merijn> Now I just need a bunch of tests to check if it actuallys works, but I hate writing tests :p
05:31:58 <MarcelineVQ> at least mvar's tend to let you know if things have gone sour
05:42:13 <chindy> Is there a purely functional data structure that models a tree with upward and downard traversal
05:45:18 <merijn> Is there any cost associated with liftIO or can I just wrap everything in liftIO and assume that if it's used as IO directly the liftIO is basically free?
05:49:46 <MarcelineVQ> merijn: if ghc is smart enough to replace id x with x, I really hope it is :X
05:50:23 <electrocat> if unsure, check the core output :p
05:53:28 <Boarders> is it always the case that GHC will optimise sum to use a strict accumulator or minimum or etc?
05:53:48 <Boarders> and if so what are the use cases of a strict foldMap?
05:54:10 <Boarders> (strict in the passed accumulator I should probably say)
05:54:31 <MarcelineVQ> no it's not always the case, instead it always depends on your Foldable definitions for your type
05:55:19 <Ariakenom> > sum [1..10000000]
05:55:25 <lambdabot>  mueval-core: Time limit exceeded
05:55:27 <Ariakenom> > foldl' (+) 0 [1..10000000]
05:55:30 <lambdabot>  50000005000000
05:55:37 <dminuoso> merijn: pong
05:55:47 * pong
05:55:53 <Ariakenom> Boarders: no strict accumulator
05:57:28 <jose_zap> sum is a famously bad function still in the prelude. There should at least be a sum' like there is a foldl'
05:57:39 <merijn> dminuoso: I slightly reworked the current definition to this: https://github.com/merijn/validated-literals/blob/test/ValidLiterals.hs
05:58:15 <merijn> dminuoso: Basically, get rid of the hackySpliceValid nonsense and just straight up using Lift, but by having it inside the Validate class you don't have to rely on orphan Lift instances
05:58:34 <merijn> dminuoso: Of course, if you *have* a lift instance it's basically free
05:59:23 <merijn> dminuoso: The ByteString one has an example (as you can't simply Lift ByteString directly)
06:07:40 <Boarders> https://lpaste.net/3708294717784457216
06:08:11 <Boarders> if I have code like this then is f2 slower than f1 and if so how bad is it?
06:08:13 <MarcelineVQ> Boarders: I am also curious about when/where ghc determines it can replace foldl with foldl' however, if it does, which I am under the impression it did.
06:08:36 <merijn> MarcelineVQ: It doesn't
06:08:49 <merijn> MarcelineVQ: But strictness analysis might make things strict, I think
06:09:13 <MarcelineVQ> Mystery solved I guess hehe. A perusal of ghc source didn't turn up anything foldl specific.
06:09:42 <Boarders> does strictness analysis depend on the monoid? As in does it work for sum because it knows that (<>) @Sum is strict in the first parameter?
06:11:07 <phadej> (<>) @Sum isn't necessarily strict
06:11:16 <MarcelineVQ> were you asking about monoids earlier as well?
06:11:17 <phadej> depends on the Num
06:12:40 <MarcelineVQ> I thought you were asking about Foldable since you said sum and minimum
06:14:14 <Boarders> MarcelineVQ: sum is implemented via foldMap as a default definition
06:14:47 <Boarders> I think it used to be implemented by foldl
06:15:21 <Boarders> and I was wondering about the use cases of a strict foldMap over what ghc will do for you
06:20:55 <merijn> hmm, does hackagebot no longer announce uploads?
06:22:31 <MarcelineVQ> probably waits for a quiet moment
06:28:46 <dmwit> shachaf: ah
06:49:34 <Boarders> does anyone know how I can look at core when building a stack project. I tried adding:
06:49:40 <Boarders> ghc-options:
06:49:56 <Boarders> "$locals": -ddump-simpl
06:50:04 <Boarders> to my stack.yaml but I don't think it worked
06:51:42 <MarcelineVQ> add it to your cabal file
06:52:06 <MarcelineVQ> or package.yaml if that's what you're using
06:53:16 <electrocat> what does break<0>() mean in core?
06:53:33 <MarcelineVQ> you migh even just want to add it to a cli command rather than as a project setting, I don't know if it still does but back when I had that on and I ran ghci it would dump a lot of stuff in the src dir instead of the build dirs
06:54:19 <MarcelineVQ> like  stack build --ghc-options="-fforce-recomp -ddump-simpl"
06:54:45 <MarcelineVQ> you tend to want -fforce-recomp for these sorts of things, which isn't especially fun as a whole-project setting
06:58:33 <MarcelineVQ> actually -fforce-recomp doesn't seem to affect stack, which is a hassle, so the command might be more like   stack clean && stack build --ghc-options="-ddump-simpl"
07:01:51 * hackage purescript-iso 0.0.3 - Isomorphic trivial data type definitions over JSON  http://hackage.haskell.org/package/purescript-iso-0.0.3 (athanclark)
07:03:53 <c_wraith> MarcelineVQ: there is definitely code in GHC that was added specifically to make foldl more efficient
07:04:04 <c_wraith> MarcelineVQ: it just isn't about strictness. :)
07:10:29 <MarcelineVQ> there's rewrite rules for the list folders but I was unable to find mention of foldl in ghc itself, aside from it actually being used in the code :>
07:17:42 <c_wraith> MarcelineVQ: it's the Call Arity analysis.  It was added specifically so that foldl could participate in foldlr/build fusion efficiently
07:19:15 <MarcelineVQ> thank you
07:21:22 <Boarders> MarcelineVQ: do you know where stack puts -ddump-simpl by any change?
07:21:24 <Boarders> chance*
07:22:45 <MarcelineVQ> I do, and you can too with a quick   find -name "*dump*"  :>
07:22:58 <MarcelineVQ> because the actual path is toodamnlong to type out
07:23:17 <Boarders> cool, thanks!
07:23:27 <Boarders> I wasn't sure even what the files looked like
07:26:40 <dmwit> strace -e trace=file ;-)
07:38:37 <lingeeal> Hi, I quite confused about associativity in >>=. So I thought that an operator is considered to have associativity property when you can do this: (a `op` b) `op` c = a `op` (b `op` c). However, (m >>= f) >>= g = m >>= (\x -> f x >>= g) uses totally different stuff to state it abides the law. It should be (m >>= f) >>= g = m >>= (f >>= g) which of course does not hold. What is it im no getting here?
07:43:11 <phadej> lingeeal: there's a version of the law stated using >=>, which is "prettier"
07:43:30 <mnoonan> lingeeal: there is a closely related operator (>=>) that is associative in the normal way, and that turns out to be equivalent to the weirder way for (>>=)
07:43:33 <mnoonan> :t (>=>)
07:43:35 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:43:59 <phadej> https://wiki.haskell.org/Monad_laws
07:44:25 <dminuoso> And you can trivially translate the >=> into >>= by just pretending the first arrow to be `() -> ..`
07:45:02 <dminuoso> How did I survive without ligatures. :o
07:45:07 <mnoonan> @src (>=>)
07:45:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:45:13 <mnoonan> oh lambdabot, you card
07:45:23 <Boarders> :)
07:45:39 <mnoonan> http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Control.Monad.html#%3E%3D%3E  <- src for (>=>)
07:47:37 <lingeeal> but syntactically (m >>= f) >>= g = m >>= (f >>= g) is not equal, so how can operator  >>= be considerered associative?
07:47:44 <Boarders> associativity for join is very much associativity but doesn't "look like" it either. It states: join .  join === join . fmap join
07:48:22 <Boarders> it is not stating that bind is an associative operator but what it means for a monad to be associative in terms of bind
07:48:56 <shapr> dminuoso: pragmata pro?
07:49:26 <lingeeal> (10 - 3) - 2 = 10 - (3 - 2) + 4
07:49:34 <lingeeal> minus is associative too then :)
07:49:40 <shapr> on a vaguely related note this is pleasant: https://chris-martin.github.io/haskell-aligned/
07:49:47 <lingeeal> Boarders: ok, i see
07:49:53 <dminuoso> shapr: I dont feel like spending 60 bucks on ligatures.
07:49:56 <shapr> ah, ok
07:49:57 <dminuoso> So it's just fira code.
07:50:35 <shapr> now I want to see associativity aligned
07:55:06 <mnoonan> lingeeal: sure, if you define x + y as x - (0 - y), then addition is associative when this law holds: (A - (0 - B)) - (0 - C) == A - (0 - (B - (0 - C)))
07:55:14 <mnoonan> obviously :)
07:56:11 <shapr> oh, I like this also: https://gist.github.com/MaxwellBo/9ef5704b325e09afaffee050a91d9c91
07:56:12 <shapr> so pretty
08:03:52 <phadej> : t fmap.fmap
08:04:02 <phadej> :t fmap.fmap
08:04:04 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:04:43 <phadej> too general expression used. confusing
08:23:16 * hackage atomic-modify 0.1.0.2 - A typeclass for mutable references that have an atomic modify operation.  http://hackage.haskell.org/package/atomic-modify-0.1.0.2 (chris_martin)
08:27:09 <berndl> Why won't the following work: https://pastebin.com/raw/q5LjRELt ? I get an "Illegal instance declaration" error.
08:27:56 <pavonia> It tells you an extension to enable to make it work, no?
08:28:17 * hackage data-forest 0.1.0.7 - A simple multi-way tree data structure.  http://hackage.haskell.org/package/data-forest-0.1.0.7 (chris_martin)
08:30:04 <quicksilver> you probably don't want it, anyway
08:30:07 <berndl> pavonia: Yes, but that won't make it work. It just gives me another error.
08:30:20 <pavonia> What error?
08:30:21 <berndl> The constraint ‘Foo f’ is no smaller than the instance head...
08:30:31 <quicksilver> you probably hope that means "every instance of Foo becomes an instance of Bar"
08:30:51 <quicksilver> but what it actually means is "every type becomes an instance of Bar (but gains a Foo constraint)"
08:31:15 <berndl> quicksilver: I see.
08:31:32 <berndl> So how do I do "every instance of Foo becomes an instance of Bar" ?
08:31:40 <tdammers> you don't
08:32:03 <tdammers> instead, you write Bar's methods in terms of Foo
08:33:03 <tdammers> if, additionally, you need to have types that have no Foo instances to support the same methods, then you do need the Bar typeclass, but then I'd personally provide a wrapper newtype that turns an arbitrary type with a Foo instance into something that has a Bar instance
08:33:08 <berndl> Should I make a barFoo :: (Foo f) => a -> f a ?
08:33:30 <tdammers> something like that, yes
08:44:29 * hackage deferred-folds 0.9.7 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.9.7 (NikitaVolkov)
08:45:30 * hackage fizzbuzz-as-a-service 0.1.0.3 - FizzBuzz as a service  http://hackage.haskell.org/package/fizzbuzz-as-a-service-0.1.0.3 (chris_martin)
08:46:53 <Boarders> does anyone know if there is a good reason why there is no foldl1' function?
08:47:47 <quicksilver> Boarders: none except this one? http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#v:foldl1-39-
08:48:10 <Boarders> I meant for foldable in general
08:48:15 <quicksilver> ah
08:48:59 * hackage hpp 0.6.1 - A Haskell pre-processor  http://hackage.haskell.org/package/hpp-0.6.1 (AnthonyCowley)
08:49:13 <quicksilver> no :)
08:51:59 * hackage multi-instance 0.0.0.3 - Typeclasses augmented with a phantom type parameter  http://hackage.haskell.org/package/multi-instance-0.0.0.3 (chris_martin)
08:52:59 * hackage intro 0.5.1.0 - Safe and minimal prelude  http://hackage.haskell.org/package/intro-0.5.1.0 (minad)
08:53:59 * hackage paripari 0.2.1.0 - Parser combinators with fast-path and slower fallback for error reporting  http://hackage.haskell.org/package/paripari-0.2.1.0 (minad)
08:54:59 * hackage mvar-lock 0.1.0.2 - A trivial lock based on MVar.  http://hackage.haskell.org/package/mvar-lock-0.1.0.2 (chris_martin)
09:03:49 <EvanR> the intro package ... doesn't have >>
09:04:13 <EvanR> but *> is harder to type and not as visually pleasing :(... 
09:05:01 <EvanR> also, cycleMay and cycleDef are safe in the sense that they are total, but don't cover the case where the input list is known to be non empty. theres no nonemptyCycle, despite NonEmpty being in the prelude
09:05:53 <EvanR> cycle :: NonEmpty a -> Stream a
09:07:02 * hackage text-replace 0.0.0.3 - Simple text replacements from a list of search/replace pairs  http://hackage.haskell.org/package/text-replace-0.0.0.3 (chris_martin)
09:14:13 <berndl> All this wrapping/unwrapping types is pretty annoying...
09:14:57 <glguy> If it's not paying off, don't do it
09:17:04 <maerwald> berndl: quite a general statement, anything more specific?
09:18:34 <Boarders> berndl: I find this newtype stuff a bit underrated. You might find it useful: http://hackage.haskell.org/package/newtype-0.2
09:18:35 <berndl> maerwald: Yes. Every time I need to define a type class for certain functors, I have to create a wrapper data type.
09:19:24 <berndl> Coming from Agda, this feels painful.
09:19:27 <Boarders> There are usually legitimately many instances though so seems reasonable
09:20:45 <glguy> berndl: It sounds like you have a problem with some specific code you're writing. If you showed that code people might understand what you were doing
09:20:49 <Boarders> in agda you carry around an equality relation and various proofs of properties satisfied which feels much worse to me
09:21:37 <pgiarrusso> Boarders: agda has instance arguments, basically type classes without xoherence
09:21:42 <berndl> glguy: Say I wanted to define Monoid (a -> a). I can't. I have to create a wrapper: data Endo a = Endo (a -> a).
09:23:20 <Boarders> because (Sum Int) -> (Sum Int) has multiple potential monoid instances
09:23:53 <pgiarrusso> Wait, isn’t that legal but orphan
09:23:56 <pgiarrusso> ?
09:25:46 <Taneb> pgiarrusso: you'd need overlapping instances and a few other extensions, too (flexible instance, I think?)
09:26:22 <glguy> berndl: I'm guessing that's not actually one of the things you were trying to define
09:26:38 <berndl> glguy: Actually, it is.
09:26:58 <glguy> You're reimplementing stuff from Data.Monoid? Is it for exercises?
09:27:12 <berndl> glguy: Yes.
09:27:26 <Boarders> what is painful about working with Endo?
09:28:15 <berndl> The extra wrapping/unwrapping makes the code harder to understand and to type.
09:28:53 <glguy> OK, then my original message works out; if it's not paying off, don't do it
09:30:30 <pgiarrusso> glguy: but then you can’t use the instances
09:30:45 <pgiarrusso> berndl: that’s the price to pay for coherence
09:30:58 <pgiarrusso> Agda eschews coherence and has other tradeoffs
09:31:23 <pgiarrusso> Tho dependent types let you fix the most serious issues haskell would have without coherence (say, sets)
09:31:45 <glguy> pgiarrusso: We haven't seen the code that's needing the instances, so we can't weigh in on that. Often the newtype wrappers can be hidden behind one implementation of something and the rest of the code doesn't need to know
09:32:21 <Boarders> https://lpaste.net/335981582030471168
09:32:33 <Boarders> this is what the newtypes stuff would look like berndl
09:33:37 <Boarders> you can use coerce from Data.Coerce for the packing and unpacking I believe but I don't know if that makes a difference
09:45:07 <berndl> Boarders: I've seen that before somewhere.
09:45:37 <Boarders> it is from conor mcbride
09:46:06 <Boarders> he also has a magic function called ala attached to the idea
09:49:49 <berndl> Boarders: I remember seeing it in "The Essence of the Iterator Pattern". I guess they took it from McBride?
09:50:35 <Boarders> I think so, apparently the idea originates in the language epigram that they designed
09:53:44 <MarcelineVQ> they?
09:53:52 <butterthebuddha> Has anybody here worked at/works at Galosi?
09:53:55 <butterthebuddha> Galois*
09:53:55 <berndl> pgiarrusso: In the newer versions Idris you also need wrappers now, unfortunately.
09:54:52 <MarcelineVQ> *the first they
09:55:54 <Boarders> singular they
10:06:25 <glguy> butterthebuddha has a tired laptop, but there are a few people from Galois here
10:06:47 <shapr> tired laptop?
10:07:31 <shapr> This was great for today's lunchtime class: https://chris-martin.github.io/haskell-aligned/
10:07:50 <shapr> ohh, I get it. went to sleep
10:28:31 <dmwit> ?tell butterthebuddha IAmA Galwegian, AMA
10:28:31 <lambdabot> Consider it noted.
10:30:17 <fommil> I'm a Belfastian
10:30:28 <vaibhavsagar> how do I pass stack an --enable-executable-dynamic flag?
10:30:49 <dmwit> shapr: Nice!
10:31:03 <dmwit> shapr: But this is an objectively superior alignment for the liftAs. ;-) https://lpaste.net/8700922912070172672
10:32:49 <dmwit> Not sure I understand the "The monoid in Monad" section, though.
10:33:16 <shapr> dmwit: put up a PR
10:34:05 * hackage lambda-calculus-interpreter 0.1.0.0 - Lambda Calculus interpreter  http://hackage.haskell.org/package/lambda-calculus-interpreter-0.1.0.0 (xeontem)
10:36:38 <glguy> dmwit: How about https://lpaste.net/3171643656570404864 :-O
10:38:05 <glguy> Kind of captures the right-associativity of -> better?
10:38:18 <glguy> each new argument is kind of the one on the left
10:38:31 <t7> ya
10:38:52 <glguy> and don't forget:    pure :: r -> f r, which fits into that nicely, but lpaste.net is low feature now and I can't just edit the paste
10:40:20 <glguy> https://lpaste.net/677757036288540672
10:40:31 <Hotkeys> I like the idea of the alignment but the ones with gobs of whitespace around some of the symbols are harder to sight read for me
10:41:22 <MarcelineVQ> It's a little akward, in fact I wonder if it would be more readable putting in opposite order, liftA3, A2, etc..
10:41:32 <dmwit> glguy: Yeah, I just submitted a PR for pure. Your alignment is an interesting one, too...
10:41:41 <MarcelineVQ> While we're doing insane crazy things by and for crazy people
10:44:07 <dmwit> Ultimately I didn't make a PR changing the alignment. Adding pure seems wholly unobjectionable, but it's tougher for me to articulate exactly what it is about the alternate alignments that I like better (even though I do like them better).
10:44:46 <EvanR> if you change alignment the DM may require you take an experience points penalty
10:44:52 <MarcelineVQ> I think they're quite scary. I imagine them as raptor paddocks you see, and they can clearly climb out the right sides
10:45:21 <glguy> All the raptor paddocks I've visited have been quite scary.
10:46:44 <MarcelineVQ> glguy, don't go to dino zoo's that do coupon days, it's just not a good sign
10:47:05 <dmwit> Did you know that the "pter" in "pterodactyl" and "helicopter" come from the same root?
10:47:09 <glguy> It was a Groupon; it said "last meal free"
10:47:21 <glguy> Kind of a weird discount
10:47:48 <nbunjevac> why is 'f :: (((a -> b) -> c) -> d) -> d' an "impossible" function? Is it because of return type which can't be figured out or is there something deeper going on here?
10:48:13 <nbunjevac> also, is it same as 'f :: a -> b -> c'? Is it also "impossible"?
10:48:14 <EvanR> last mean free, so only eat one meal
10:48:26 <EvanR> if you eat zero meals, does it error out and give you infinite money
10:49:20 <c_wraith> nbunjevac, as an implementor of such a function, how do you get a value of type d (which you know nothing about) to return?
10:50:17 <EvanR> the issue being you know nothing about c
10:50:31 <shapr> is there an IRC channel for ICFP? :-)
10:50:39 <shapr> just curious who's showing up when
10:50:49 <nbunjevac> yeah, the function argument can return d, but then we don't know anything about c
10:51:11 <EvanR> (((a -> b) -> Bool) -> d) -> d would be possible
10:51:25 <EvanR> \f -> f (\_ -> True)
10:51:41 <EvanR> erm...
10:51:48 <EvanR> yeah
10:52:19 <nbunjevac> oh, interesting
10:52:27 <dmwit> nbunjevac: Simplify even further. a -> b -> c is also impossible; a -> b is also impossible; a is also impossible.
10:52:37 <dmwit> If you understand the last one, it will be easy to lift that intuition to the previous ones.
10:53:23 <nbunjevac> that's what I thought, thanks a lot guys
10:53:40 <nbunjevac> and gals :P
10:56:04 * hackage stache 2.0.0 - Mustache templates for Haskell  http://hackage.haskell.org/package/stache-2.0.0 (mrkkrp)
11:01:04 * hackage http2-client-grpc 0.5.0.3 - Implement gRPC-over-HTTP2 clients.  http://hackage.haskell.org/package/http2-client-grpc-0.5.0.3 (LucasDiCioccio)
11:05:11 <Boarders> if you have a type with one var like (a -> a) -> a then you can tell if it is inhabited by putting a =0 and computing 0 ^ (0 ^ 0) = 0 ^ 1 = 0 so it is not inhabited
11:05:32 <Boarders> not sure if there is something equivalent for multiple variables
11:06:04 <Boarders> maybe you are freely allowed to substitute 0 or 1 for every parameter and you have to get a non-zero answer
11:06:35 * hackage cue-sheet 2.0.0 - Support for construction, rendering, and parsing of CUE sheets  http://hackage.haskell.org/package/cue-sheet-2.0.0 (mrkkrp)
11:10:58 <lyxia> This trick doesn't model parametricity
11:11:05 * hackage haskoin-store 0.1.3 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.1.3 (xenog)
11:11:20 <lyxia> see what (Either a (a -> Void)) gives you
11:15:59 <Boarders> yeah, I guess it is not intuitionistic
11:18:51 <drager> Hi, I don't know haskell but I'm currently reading some haskell code. What does the asks function from Control.Monad.Reader do?
11:19:12 <shachaf> droplet: Are you the person who asked about Nu?
11:20:53 <dmwit> drager: The Reader monad (transformer) gives you a way to carry around some configuration information. `ask` retrieves the configuration information. Frequently, your configuration is a record or similar and you want access to a specific field or do some simple calculation on the configuration. You could do this with `fmap fieldName ask`, but this is such a common use that there's a dedicated name for it; 
11:20:59 <dmwit> `asks f` applies `f` to the configuration and returns the result.
11:22:03 <dmwit> I don't know why pluralizing is the convention for this, but it is; e.g. `gets f` is `fmap f get`, and I think there are a few other examples of this lying around.
11:24:09 <drager> dmwit: Alright, I think I get that right. Thanks
11:25:37 <geekosaur> iirc the s stands for selector
11:25:47 <sleepster> what would be the easiest way to read well-defined data from disk directly into memory into a data record in Haskell?
11:26:38 <sleepster> One example of this might be an ELF file or a persisted tcp packet
11:29:08 <dmwit> https://hackage.haskell.org/package/bytestring-mmap perhaps
11:30:17 <dmwit> Your plan of "directly into data record" is unlikely to happen. Haskell doesn't give you a way to control the memory layout of its data types, and even the additional control GHC gives you above and beyond the Haskell Report is very unlikely to be enough.
11:31:05 <sleepster> thanks dmwit . I'll take a look at this.
11:33:14 <EvanR> you can create a short vector of heterogenous boxed values, and use accessors similar to record field accessors on them
11:35:01 <EvanR> or if the underlying data is purely binary, use a ByteString and provide a view layer to look at the parts
11:35:27 <EvanR> i'm not sure how the performance of any of this adds up
11:40:26 <vaibhavsagar> how do I pass stack an --enable-executable-dynamic flag?
11:40:38 <vaibhavsagar> like with cabal?
11:42:34 * hackage flight-igc 1.0.0 - A parser for IGC files.  http://hackage.haskell.org/package/flight-igc-1.0.0 (philderbeast)
12:01:35 * hackage uniform-pair 0.1.14 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.14 (ConalElliott)
12:12:34 * hackage uniform-pair 0.1.15 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.15 (ConalElliott)
12:18:56 <dmwit> A small puzzle for you. (Not a difficult one.) Const does not have a Monad instance. Proxy does have a Monad instance. Const () and Proxy are isomorphic (and the isomorphism is an Applicative morphism). What gives?
12:21:44 * lyxia makes a proposal for instance (() ~ b) => Monad (Const b).
12:22:00 <fommil> dmwit: validation and either are isomorphic at the data level
12:22:11 <fommil> there is an advantage to have an Applicative but not a Monad
12:22:41 <int-e> dmwit: have we reached the point of no return...
12:22:49 <dmwit> fommil: Yes, but the isomorphism is not an Applicative morphism.
12:22:59 <dmwit> int-e: v. good =)
12:23:19 <fommil> dmwit: right. I must admit I'm struggling to see what the advantage of having an Applicative only would be for Const. I wasn't aware it could have a monad.
12:23:34 <fommil> of course one of the most popular uses is to optimse a free applicative
12:23:35 <dmwit> fommil: It can't. That's part of the puzzle. =)
12:23:49 <fommil> oh, I get you. Then Proxy is voodoo
12:24:06 <fommil> isn't Proxy using some language extension?
12:24:14 <dmwit> lyxia: Perhaps we should have a new typeclass Unique with instances for (), Identity (), etc. =)
12:24:25 <dmwit> fommil: No language extensions needed for Proxy and its Monad instance.
12:24:49 <fommil> dmwit: http://dev.stephendiehl.com/hask/#proxies
12:25:02 <fommil> this is the only context for Proxy that I have
12:25:17 <dmwit> fommil: That is the same Proxy. But I was very careful about my statement.
12:25:31 <dmwit> Extensions are frequently used in the definition of Proxy, but it's not needed if all you want is the Monad instance.
12:25:36 <fommil> ah
12:26:29 <dmwit> int-e: Man. Your answer just keeps getting better.
12:26:34 <lyxia> Empty a => Unique (Maybe a) ... :D
12:26:51 <dmwit> int-e: At first pass, I had understood the "no return" pun, but not the "point of" pun. =D
12:27:15 <dmwit> lyxia: =D
12:28:33 <lyxia> unique :: Unique a => a   with the law "forall x, x = unique"
12:46:35 <ixxie> how does Vim fare for Haskell development?
12:48:03 <vaibhavsagar> ixxie: which aspect of Haskell development?
12:48:16 <vaibhavsagar> you can edit text with it pretty efficiently
12:48:29 <vaibhavsagar> in that respect it fares well
12:48:51 <Franciman> ixxie, you may want to look at haskell-ide-engine, for autocomplete diagnostics etc
12:48:59 <Franciman> or intero, IIRC there is a plugin for vim too
12:49:22 <vaibhavsagar> or you could use ghcid in a separate terminal split/window
12:49:24 <vaibhavsagar> that'
12:49:37 <vaibhavsagar> s pretty good and editor-agnostic
12:49:46 <vaibhavsagar> Hi erikd!
12:50:08 <Franciman> ghcid is super cool, yeah!
12:50:32 <vaibhavsagar> I like that it consistently and reliably works wherever GHC does
12:50:50 <vaibhavsagar> so if it's broken, something is very wrong and you're probably not going to get much work done anyway
12:51:50 <ixxie> I guess what I am getting at is - could Vim + plugins + terminal utilities compete with some more elaborate IDE?
12:52:14 <vaibhavsagar> ixxie: that's the aim of Haskell IDE Engine
12:52:23 <vaibhavsagar> but IMHO the answer is no
12:52:55 <vaibhavsagar> I hear VSCode is currently the closest experience to an IDE, but there are no really good ones for Haskell
12:52:57 <cocreature> it depends on whether you are talking about some hypothetical elaborate IDE or about actual IDEs that we have right now
12:53:10 <ixxie> heh lol
12:53:21 <ixxie> I don't know the situation
12:53:44 <vaibhavsagar> I had a good experience with hdevtools+vim when I was starting out
12:53:46 <ixxie> I haven't done more than a tutorial or two in Haskell but I am currently setting up neovim and plan to dip into Haskell in the coming year
12:54:05 <vaibhavsagar> ghcid has especially good integration with neovim
12:54:21 <vaibhavsagar> see https://github.com/ndmitchell/ghcid/tree/master/plugins/nvim
12:54:36 <ixxie> neat
12:55:06 <cocreature> I would recommend to not invest too much time into trying to get tooling to work when you’re just starting out, so just stick to syntax highlighting + ghcid/ghci. it is pretty easy to invest a ton of time into trying to figure out tooling without actually getting to the point where it helps more than it harms.
12:55:25 <Zipheir> ixxie: Remember, you can program with anything.
12:55:25 <vaibhavsagar> ixxie: FWIW I use vim for all my Haskelling
12:55:44 <cocreature> you can always revisit things once you’re more experienced but as a beginner it just adds one more source of trouble and confusion
12:55:52 <vaibhavsagar> tmux with two panes, vim in one and ghcid in the other is sufficient for my purposes
12:56:42 <Zipheir> vaibhavsagar++, simple and hard to break.
12:58:04 <ixxie> sounds good to me
12:58:20 <ixxie> Zipheir: you can cut bread with a baseball bat, it doesn't mean its easy
12:58:58 <vaibhavsagar> ixxie: I use Nix a fair bit and AFAICT all the other approaches are a pain in the butt to set up each time
12:59:11 <vaibhavsagar> ghcid is simple and reliable, and works amazingly well
13:02:50 <ixxie> vaibhavsagar: NixOS user here xD
13:04:53 <aldum> well, kudos
13:05:09 <aldum> I've been meaning to try that, but systemd...
13:27:20 <merijn> hmmm, I'm torn between replacing a tuple with a datatype with fieldnames and just keeping the tuple since it's only used once in the code :\
13:29:10 <dstolfa> merijn: if it's evident on why it's there, keep the product, otherwise name it
13:30:16 <dolio> I would keep the tuple if it's only used in one spot, probably.
13:30:59 <dstolfa> dolio: yeah but if it's a tuple that makes no sense when written as ( , ), it might help to name things in order to clarify things from just the type signature
13:31:02 <dolio> Like, if you just need to return 5 things from one function for use in one other function, it doesn't seem like it's its own conceptual thing.
13:32:03 <Eduard_Munteanu> Just don't add 'lens' as a dependency just for that thing. :P
13:32:28 <Solonarv> add lens as a dependency so you can slack off while it compiles :P
13:32:28 <dolio> Lens is already a dependency, of course. :þ
13:40:45 <dstolfa> lenses. lenses everywhere
13:40:49 <dstolfa> also add prisms for good measure
13:44:40 <Solonarv> pfft, tuples are so 2016 - don't return (a, b, c), return forall r. (a -> b -> c -> r) -> r !
13:47:18 <h30> ~.
13:49:36 <dmwit> Solonarv: Works great until you update the second field with an expensive `b -> b` modification and discover that this gets recomputed every time you inspect the `b`...
13:52:29 <Solonarv> well, that doesn't really happen if you're just using it as multiple-return-value
13:55:20 <kritzefitz> Can I (easily) make a traversal from a list of lenses?
13:55:54 <byorgey> kritzefitz: what would it do?
14:01:11 <kritzefitz> get/set all the places the individual lenses point to?
14:01:28 <byorgey> no, that's not possible, since the targets of the lenses could overlap
14:01:38 <heptahedron> kritzefitz: I think that violates a traversal law since it'd visit some more than once
14:01:38 <heptahedron> yeah
14:01:59 <kritzefitz> Ok
14:02:31 <kritzefitz> Ah, yes. I only thought about setting them, but updating them would be really weird.
14:03:06 <heptahedron> I have a tree structure, where each node can either be a leaf or a vector of nodes, and I have an indexing function that takes a list of indices and descends through the tree, occasionally expanding a leaf into another branch node, and I want these changes to be persisted in e.g. a state monad
14:03:47 <heptahedron> Is there an example of such a thing anyone could direct me toward? My current solution is fairly messy and mixes CPS and applicative style
14:06:36 <kritzefitz> Can I do that with a Fold instead? Lens laws apparently do not apply to them.
14:08:36 <dmwit> kritzefitz: Even setting is weird. e.g. think of the id and (+1) lenses that take Word8s to Word8s.
14:09:25 <kritzefitz> I see
14:13:37 <dmwit> heptahedron: How about just expanding all leafs all the time, right from the getgo at creation time? =)
14:13:44 <dmwit> Gotta take advantage of that laziness.
14:14:26 <dmwit> :t \x -> fix (Node x . repeat)
14:14:27 <lambdabot> a -> Tree a
14:15:36 <heptahedron> dmwit: That's honestly probably a viable solution to this, but I'm still interested in how I could accomplish it without that
14:15:45 <mniip> :t fix . (:)
14:15:45 <heptahedron> consider it a form of masochism
14:15:46 <lambdabot> a -> [a]
14:27:34 * hackage network-api-support 0.3.4 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.3.4 (MarkHibberd)
14:28:02 <dmwit> heptahedron: I guess I'd start here: https://lpaste.net/7038323724415664128
14:28:14 <merijn> There's no bracket that has different handlers for exceptional/unexceptional exit, is there?
14:29:02 <dmwit> heptahedron: My two next steps would be to worker-wrapper transform so `defTree` is shared among all recursive calls, and track whether anything changed to avoid lots of reallocation in case no modifications are needed.
14:29:51 <geekosaur> merijn, how would that differ from chaining the successful-exit one onto the first IO action?
14:30:17 <merijn> geekosaur: I suppose...
14:30:42 <merijn> geekosaur: It'd differ in how easily I can lift the common code out 3 different things :p
14:30:49 <heptahedron> dmwit: worker-wrapper transform, hm? I'll have to look that up
14:31:08 <heptahedron> thanks a lot for the help
14:33:05 * hackage postmark 0.2.5 - Library for postmarkapp.com HTTP Api  http://hackage.haskell.org/package/postmark-0.2.5 (MarkHibberd)
14:34:13 <tysonzero> does anyone know how to call "getElementById" in ghcjs-dom?
14:34:18 <tysonzero> It seems suspiciously missing
14:35:40 <dmwit> merijn: `catch`...?
14:36:04 * hackage postmark 0.2.6 - Library for postmarkapp.com HTTP Api  http://hackage.haskell.org/package/postmark-0.2.6 (MarkHibberd)
14:37:26 <tysonzero> this is so frustrating, GHCJS-DOM seems super comprehensive but it seems to be missing something so incredibly basic
14:41:30 <tysonzero> should i be using something instead of ghcjs-dom?
14:43:12 <hamishmack> tysonzero https://github.com/ghcjs/ghcjs-dom/blob/master/ghcjs-dom-jsffi/src/GHCJS/DOM/JSFFI/Generated/NonElementParentNode.hs#L39
14:45:09 <tysonzero> I saw that but the link is dead
14:45:32 <tysonzero> so i assumed it wasn't a good idea to rely on it
14:45:37 <tysonzero> and wasnt sure if that was the document one
14:45:39 <hamishmack> So import GHCJS.DOM.NonElementParentNode (getElementById)
14:45:40 <tysonzero> should I just use it?
14:46:23 <hamishmack> What do you mean by "the link is dead" ?
14:48:04 <tysonzero> the link to the mozilla documentation
14:48:08 <tysonzero> next to the definition
14:48:09 <tysonzero> just 404's
14:48:31 <hamishmack> Oh those documentation links are auto generated and do not always work
14:49:06 <tysonzero> oh rip
14:49:11 <tysonzero> thats unfortunate
14:49:20 <hamishmack> The problem here is that WebKit IDL files (which ghc-dom is generated from) have an extra inteface that mozila does not have in their docs
14:49:33 <tysonzero> interesting, and it seems like vice-versa is true too
14:49:40 <tysonzero> mozilla has things in a certain place that WebKit does not
14:49:47 <tysonzero> although WebKit might copy the functionality and put it somewhere else
14:49:51 <tysonzero> but like in a different hierarchy spot
14:52:41 <tysonzero> thanks
14:55:06 <tysonzero> What's the best way to find the functions i'm looking for in jsaddle/ghcjs-dom? Is there a way to search for all functions that have type `T` in the covariant position?
14:55:18 <mniip> hmm
14:55:39 <tysonzero> e.g. I know how to get a `CanvasRenderingContext2D` in JavaScript pretty easily, but getContext in ghcjs-dom doesnt give me one
14:55:44 <tysonzero> and I cant use uncheckedCastTo either
14:56:07 <tysonzero> but if i use the FFI it works fine, but i'd rather not if I don't have to
14:56:21 <hamishmack> Ideally functions docs would link to https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById
14:57:29 <mniip> is "ListT done right" just a *->* kinded fixpoint over  Compose m ListF
14:57:32 <tysonzero> Yeah that would be nice
14:57:32 <mniip> if one could say that
14:57:44 <hamishmack> FWIW the other instance of IsNonElementParentNode (DocumentFragment) has the same broken link on mozilla's docs fro DocuementFragment https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment
14:58:11 <mniip> not even that
14:58:30 <mniip> /\m. /\a. Fix (Compose m (ListF a))
14:58:35 <tysonzero> Hmm https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D just tells me to use getContext("2d"), but that just doesnt work in GHCJS-DOM
14:58:47 <mniip> contrasting with  [] ~ /\a. Fix (ListF a)
14:59:15 <hamishmack> IIRD you can do `castTo CanvasRenderingContext2D` on the result from getContext
14:59:29 <hamishmack> IIRC
15:00:17 <mniip> I'm curious why this holds though
15:01:24 <tysonzero> Woah looks like castTo works
15:01:29 <tysonzero> but not uncheckedCastTo
15:02:52 <hamishmack> Oh interesting that sounds like it might be a bug
15:02:54 <tysonzero> ok wtf is going on
15:03:00 <tysonzero> they have the same type signature in GHCI
15:03:06 <tysonzero> although it could be a divergence between ghc and ghcjs
15:03:11 <mniip> if I make  ListF' a as = Maybe (a, Maybe (a, as))
15:03:23 <mniip> still isomorphic to [] via Fix
15:03:40 <mniip> that wouldn't produce a monad transformer would it
15:05:37 <hamishmack> tysonzero please file an issue on ghcjs-dom (with sample code if you can)
15:06:58 <tysonzero> alright will do
15:08:01 <hamishmack> I think uncheckedCastTo is pure right?
15:08:06 <hamishmack> castTo is in IO
15:09:12 <hamishmack> Well in MonadDOM (aka MonadJSM)
15:10:05 * hackage grpc-etcd-client 0.1.1.2 - gRPC client for etcd  http://hackage.haskell.org/package/grpc-etcd-client-0.1.1.2 (LucasDiCioccio)
15:20:39 <atchoum> happy new year
15:21:06 <atchoum> I mean happy Roch achana
15:21:43 <infinisil> Whoa
15:21:45 <infinisil> lens is magical
15:21:57 <lyxia> is it
15:21:58 <heptahedron> infinisil: what makes you say that
15:22:10 <infinisil> Just wrote `      definitions . at 1 . _Just . numUses += 1`
15:22:12 <infinisil> in my code
15:22:21 <infinisil> Instead of the ugly thing I had before that
15:22:38 <heptahedron> that is pretty clean
15:22:54 <ChaiTRex> I'm about to start using Control.Parallel for concurrency with a minimization problem. What's the best way for a thread to tell other threads about a more minimal result it just found?
15:23:04 <shachaf> infinisil: ix 1 = at 1 . _Just
15:23:06 <jle`> infinisil: definitions . ix 1 . numUses += 1
15:23:13 <infinisil> Ohhhh
15:23:16 <infinisil> Even better, thanks
15:23:23 <ChaiTRex> (so that other threads can stop working if they know they can't reach that)
15:23:24 <atchoum> ChalTrex: I think this is not strictly haskell related
15:23:56 <atchoum> ChaiTRex: but you should be able to do that by using a shared data structure and updating its content to the current minimum
15:24:07 <atchoum> I mean my answer is not strictly haskell related
15:24:08 <jle`> infinisil: 'at' is for situations where you would want to be able to change membership or non-membership as well as just the contents
15:24:24 <ChaiTRex> atchoum: What are some good shared data structures for Control.Parallel?
15:24:27 <atchoum> https://www.pastiebin.com/5b9840232087b <- can I use something like a => Orderable or something like that ?
15:24:33 <atchoum> ChaiTRex: Dunnow
15:24:40 <jle`> infinisil: 'ix' leaves membership-or-non-membership unchanged
15:24:50 <infinisil> jle`: Ah that makes sense, was a bit confused by what I should use
15:25:05 <ChaiTRex> atchoum: Oh, no problem.
15:25:07 <atchoum> ChaiTRex: I only did IPC  on light thread
15:25:19 <atchoum> (with another language by the way, so very much depending on the interpreter)
15:26:28 <jle`> atchoum: that depends, what are you trying to do?
15:26:36 <jle`> atchoum: does your current code work as it is?
15:26:40 <geekosaur> atchoum, that should be Eq a => [a] -> [a]. if you're planning to use other comparison ops later, then Ord instead of Eq
15:26:51 <atchoum> well I just wanted to know if further precision in my signature would be useful or not
15:27:11 <jle`> atchoum: first get it to compile first :)
15:27:13 <atchoum> jle`: yeah, I think the type inference algorithm works
15:27:19 <atchoum> jle`: it works
15:27:33 <jle`> but usually we try to make type signatures as general as possible, so they are useful for more things
15:27:38 <atchoum> but I was wondering if further annotation was mandatory, or if it was making a difference
15:27:52 <geekosaur> Eq should be required there. Ord would't do anything
15:27:53 <jle`> there's even a warning for type signatures that are too restrictive for their implementations, -Wredundant-constraints
15:28:00 <jle`> atchoum: mandatory...by who?
15:28:04 <ChaiTRex> atchoum: Basically, you use the typeclasses that the functions in your function require.
15:28:05 <atchoum> geekosaur: yeah whatever
15:28:13 <jle`> atchoum: are you following a style guide?
15:28:16 <ChaiTRex> atchoum: Those are the only mandatory typeclasses.
15:28:23 <jle`> the only real "mandatory" things should be enforced by the compiler
15:28:41 <atchoum> ChaiTRex: geekosaur: jle`: couldn't the compiler already know that (Eq a) is required here ?
15:28:45 <atchoum> I mean
15:28:57 <jle`> atchoum: if you leave off the type signature, then it will infer Eq a => [a] -> [a]
15:28:59 <atchoum> If you had an example of anything not an instance of Eq, I could tyr.
15:29:11 <ChaiTRex> atchoum: Yes, but part of typing things is telling the compiler how you think things work so that it can correct you if needed.
15:29:17 <jle`> however, if you manually give a type signature, then the compiler will complain if the type signature you specify is not compatible with your function
15:29:20 <atchoum> jle`: but does the type signature here is not enforcing (Eq a) on a ? ?
15:29:25 <jle`> atchoum: it does not
15:29:33 <jle`> the paste you gave shouldn't compile
15:29:39 <atchoum> it works in ghci
15:29:54 <infinisil> Is there a way to use lens' %= with a Monady function?
15:30:02 <infinisil> Oh wait, isn't that called zoom or so
15:30:07 <jle`> atchoum: how are you loading it into ghc?
15:30:14 <jle`> *ghci
15:30:17 <atchoum> :load myscript.hs
15:31:19 <atchoum> jle`: 
15:31:26 <atchoum> well you were right it did not compile
15:31:27 <atchoum> my mistake
15:31:28 <jle`> it doesn't seem to work for me
15:31:38 <atchoum> but without type signature it works
15:31:49 <jle`> if you leave off the type signature, ghc will infer compress :: Eq a => [a] -> [a]
15:31:49 <atchoum> that's copy pasting wo type signature into ghci for you
15:31:55 <atchoum> yes
15:31:59 <atchoum> that's what it does
15:32:00 <ChaiTRex> atchoum: Another thing is that your type signature should tell human readers exactly what inputs are allowed. If you leave of Eq a, it'll mislead people.
15:32:03 <jle`> but you gave it an incompatible type signature
15:32:16 <jle`> atchoum: it's the same thing as if you had written `compare :: (Bool, Double)`
15:32:30 <jle`> the type signature you give is incompatible with the function's implementation
15:33:00 <jle`> the point is a little subtle actually and it's something that is easy to miss when you're starting haskell
15:33:02 <jle`> *compress
15:33:22 <jle`> atchoum: the type signature `compress :: [a] -> [a]` is a *promise* that your function will work for *any* 'a' it is given
15:33:45 <jle`> it means that you can call compress and pick *any* type for 'a'.  that is the promise that your type signature states
15:33:56 <atchoum> https://www.pastiebin.com/5b9840232087b is working
15:33:58 <jle`> however, this promise is not fulfilled by the implementation
15:34:20 <jle`> that's because the implementation you gave cannot work for all types you could pick for 'a'
15:34:22 <atchoum> jle`: so compiler complains
15:34:23 <atchoum> fair enough
15:34:36 <jle`> yeah, because the type signature you declared is incompatible with the implementation of the function
15:34:47 <jle`> the function's implementation fails to deliver on the promise of its type signature
15:35:29 <atchoum> yeah
15:35:33 <atchoum> compiler is fine
15:35:36 <atchoum> working ok
15:35:41 <jle`> one way to look at it is by explicitly quantifying the 'a' type variable; you can write `compress :: forall a. [a] -> [a]`
15:35:50 <jle`> which means "this function will work for *any* a"
15:35:56 <atchoum> that's amazing btw compared to dynamic language what you can achiev with compilers
15:36:05 <jle`> and then if you look at the implementation and see that this isn't true
15:36:13 <jle`> atchoum: yeah, it's pretty awesome :)
15:36:20 <atchoum> jle`: not familiar with forall stuff
15:36:36 <atchoum> dunno if its useful for first stage haskell.
15:36:36 <jle`> this is the best part about haskell, I think.  after all of the syntax buzz fades away
15:37:03 <jle`> atchoum: `forall a. [a] -> [a]` ust means that your function will be [a] -> [a], for *all* possible a's
15:37:09 <jle`> all chosen a's, I mean
15:37:23 <jle`> it does help clarify some confusion into what type signatures really say, i think
15:37:47 <jle`> when coming from other languages, a lot of people bring in the intuition that [a] -> [a] might work "for some" a's
15:38:11 <jle`> and write something like compress [True, False] = [False]
15:38:18 <jle`> compress :: [a] -> [a]
15:38:20 <atchoum> jle`: I mean i'm familiar with quantifiers but not with fancy haskell typing using quantifiers
15:38:32 <atchoum> I learnt yesterday what monic and epic are :(
15:38:32 <jle`> "it works for a being Bool, why doesn't it compile?"
15:38:49 <atchoum> s/:(/:p
15:39:11 <atchoum> jle`: but basically writing programs like theorems is useful in any context :p
15:39:20 <jle`> atchoum: i'm not really talking about these quantifiers in terms of logic, i just basically explained all there is to know about the syntax here heh
15:39:46 <jle`> if you want, we can write it as english, compress :: for any a you pick, [a] -> [a]
15:39:50 <atchoum> I mean even if it's not strictly true mathematically speaking, it brings interesting questions to the table for the average code monky
15:40:09 <jle`> er, compress :: for any a the caller picks, [a] -> [a]
15:40:51 <jle`> i think it's useful to always remember that this is how type variables work in haskell, because of a lot of misconceptions that pop up when starting
15:40:56 <jle`> myFunc :: a -> a
15:40:57 <atchoum> mm not used to static compilers
15:40:58 <jle`> myFunc True = False
15:41:10 <jle`> people are often confused that this doesn't compile, because...well, it works when a is Bool, right?
15:41:42 <atchoum> jle`: this function wouldn't pattern match for other types, that's what you mean ?
15:41:55 <atchoum> well a is kind of `any`
15:42:09 <jle`> i guess i'm saying that the meaing of "a" as a type variable can be unclear when you start out
15:42:12 <atchoum> jle`: are you sure it's not compilinig ?
15:42:34 <jle`> atchoum: do you think it should be compiling? :) try it out
15:42:38 <geekosaur> pattern matching can't disciminate types
15:42:44 <jle`> @let myFunc :: a -> a; myFunc True = False; myFunc False = True
15:42:46 <lambdabot>  .L.hs:188:8: error:
15:42:46 <lambdabot>      • Couldn't match expected type ‘a’ with actual type ‘Bool’
15:42:46 <lambdabot>        ‘a’ is a rigid type variable bound by
15:42:49 <atchoum> jle`: indeed it doesnt work
15:42:52 <jle`> ^ compile error
15:42:54 <atchoum> that's weird
15:42:59 <atchoum> that's static typing for you
15:43:10 <jle`> not necessarily static typing; this works in other languages with static typing
15:43:22 <atchoum> you mean wo
15:43:24 <jle`> the difference is what type variables 'mean' in haskell
15:43:46 <atchoum> geekosaur: it could (ala python : if isinstance(foo, bar))
15:43:48 <jle`> when you write a type signature `myFunc :: a -> a`, it doesn't mean "myFunc is a -> a for some a"
15:44:06 <jle`> it means "myFunc :: forall a. a -> a", or "myFunc :: for any a that the caller picks, a -> a"
15:44:28 <jle`> it means that myFunc has to work for *any* 'a' that the caller picks, be it Int, Double, String, (Char -> Float), ,etc.
15:44:38 <atchoum> jle`: so really the haskell compiler is enforcing type cheking at compile time
15:44:58 <atchoum> you don't have type errors at runtime ?
15:45:00 <atchoum> never ?
15:45:02 <jle`> atchoum: the type checking at compile time isn't the issue, because a lot of static languages also check types at compiletime
15:45:11 <jle`> and will accept this
15:45:23 <hpc> all static-typed languages check types at compile time :P
15:45:24 <atchoum> jle`: that's not exactly what I meant
15:45:32 <atchoum> hpc: java ?
15:45:54 <Solonarv_1> yes, java too
15:45:57 <atchoum> jle`: hpc: I mean really java can be used a lot more dynamically
15:46:22 <hpc> atchoum: what you're thinking of as types at runtime is actually just a tag on each object that says what its class is
15:46:22 <atchoum> and you can end up easily with runtime errors because this or that object doesn't have the required property
15:46:43 <Solonarv> haskell doesn't do any run-time type checking because it doesn't *have* types at runtime; they're erased
15:46:52 <jle`> atchoum: i'm not talking about checking types at compile-time here, i'm more talking about a particular quirk in Haskell's type system in specific
15:47:05 <jle`> compared to, say, Java's static type system
15:47:24 <hpc> in java this is tag is invisible, but in other OO languages it takes the form of a pointer added to the struct, or in say javascript a member of the hash called the prototype
15:47:37 <jle`> atchoum: but you are right in that, yes, haskell's "type errors" are at compile-time, not runtime :)
15:47:47 <hpc> or dict, i forget what it's called
15:47:52 <jle`> so this does remove a lot of unit tests and stuff that you'd have to do in other languages
15:48:03 <hpc> so runtime "type errors" only mean a mismatch in the tags on the objects
15:48:23 <jle`> atchoum: going along what you're saying, haskellers often exploit this to an extreme 
15:48:37 <Solonarv> and haskell's particular type system means you even get some free theorems for polymorphic types
15:48:50 <jle`> atchoum: a lot of times haskellers will create types that are much more specific than just Int, Double; they'll create types that also encode the logic of their program
15:49:05 <jle`> atchoum: and the benefit is that now ghc will also catch *logic* errors, as well
15:49:11 <jle`> becasue you've effectively turned logic errors into type errors
15:49:18 <jle`> a common example is using Maybe
15:49:20 <benzrf> well, all type errors are logic errors of some kind
15:49:30 <hpc> benzrf: pun intended?
15:49:38 <jle`> hehe
15:49:45 <benzrf> hpc: not at all O:
15:49:59 <jle`> atchoum: so by doing this, we actually move a lot of 'logic' errors to compile-time too, eliminating even more unit tests and classes of bugs and errors
15:50:17 <jle`> this is something that Haskell is especially known for, that is pretty difficult to do in other static languages like java or c
15:51:00 <hpc> this is also something that's finally catching on in new programming languages
15:51:18 <hpc> rust moves large classes of C mistakes into its type system
15:51:32 <hpc> like use after free
15:52:04 <infinisil> I bet there's something I can do to make this code more lensy: https://gist.github.com/Infinisil/672cf98354b68734f478f4640467e42e
15:52:07 <infinisil> Very ugly right now
15:52:15 <benzrf> well, the purpose of a type system is to classify the behavior of programs and restrict your ability to combine programs whose behaviors would combine in a way that results in undesirable or undefined behavior
15:52:24 <Solonarv> for a haskell example, you don't need a test to know that a function with the type "forall a b. (a, b) -> (b, a)" will swap the values in the tuple
15:52:34 <atchoum> jle`: hpc: encoding programs into types is very mathematical at some point.
15:52:39 <benzrf> but in languages like java, you can fit only a small amount of information about a program into the types assigned in it
15:52:50 <jle`> atchoum: it is to the extent that all programming is mathematical
15:52:56 <benzrf> Solonarv: actually, it could be partial.
15:53:09 <jle`> but it isn't any more mathematical than most of what most programmers do
15:53:14 <hpc> atchoum: the generality of it is, but once you're in the right frame of mind it's easy to find places where it doesn't take much math at all
15:53:18 <atchoum> jle`: basically agreeing
15:53:19 <hpc> atchoum: like sized arrays, say
15:53:29 <atchoum> hpc: dunnow 
15:53:41 <Solonarv> true, but it's often sound to go "assume this isn't partial"
15:53:42 <atchoum> I mean using quantifiers is very mathematical
15:53:47 <hpc> atchoum: if you have the idea of "there's some notion of type-level numbers and we can operate on them"
15:54:00 <hpc> which you already have if you make say, an Object[5]
15:54:02 <jle`> atchoum: no more mathematical than writing a SQL query
15:54:03 <benzrf> atchoum: writing functions is identical to proving universally quantified statements
15:54:13 <jle`> or an accessor method for a class
15:54:16 <hpc> and now add foralls and some other operations on them
15:54:22 <atchoum> benzrf: say that to the average programmer :o
15:54:24 <benzrf> atchoum: so you are already using the exact same parts of your brain as in math
15:54:35 <atchoum> benzrf: but basically your right :DDDD
15:54:40 <hpc> now you can write say, (++) :: Array n a -> Array m a -> Array (n + m) a
15:54:58 <benzrf> atchoum: well, i mean that in both in the sense that there's a formal isomorphism for appropriate notions of "function" *and* in the sense that they are cognitively nearly equivalent
15:55:18 <hpc> appending the two arrays is one of very very few definitions that can ever satisfy that type
15:55:43 <benzrf> the ability to reason about a universally quantified variable and the ability to reason about an argument to your function are essentially the same
15:56:20 <atchoum> benzrf: yeah
15:56:38 <atchoum> for the most part i'm happy 
15:57:14 <benzrf> :)
15:57:21 <atchoum> benzrf: didn't you arrive at a point where you had to deal with a messy code base ?
15:57:37 <mniip> 1536706419 [01:53:39] <benzrf> atchoum: writing functions is identical to proving universally quantified statements
15:57:47 <mniip> curry-howard immensely helped me grasp calculus back in the days
15:57:54 <benzrf> :D
15:58:03 <benzrf> atchoum: not really, i havent had any major programming jobs yet :>
15:58:05 <benzrf> (i'm a student)
15:58:10 <atchoum> ha so 
15:58:24 <atchoum> youre on the good side of the bareer so to speak :>
15:58:27 <mniip> benzrf, ah who here isn't a student
15:58:28 <benzrf> haha
15:58:28 <atchoum> hehe
15:59:04 <hpc> mniip: the professors, duh
15:59:17 <benzrf> i mean, i *have* occasionally delved into messy codebases briefly when trying to find bugs in the software i use, but thats not rly comparable
15:59:29 <benzrf> er, when trying to figure out the source of bugs ive already found i mean
16:00:16 <Solonarv> I'm not enrolled, so I'm technically not a student ;)
16:01:06 <mniip> speaking of which
16:01:17 <mniip> yall know any remote vaguely FP-related jobs :D
16:02:38 <Solonarv> apart from the occasional job advert on /r/haskell, I got nothing
16:02:52 <Solonarv> (uh, job adverts posted by other people, not by me)
16:06:11 <hexagoxel> in the spirit of "monoid in the category of .." can we start calling if-then-else "dynamic dependent type reification"? :D
16:06:30 <tysonzero> Issue created: https://github.com/ghcjs/ghcjs-dom/issues/86
16:10:34 * hackage lambda-calculus-interpreter 0.1.0.1 -   http://hackage.haskell.org/package/lambda-calculus-interpreter-0.1.0.1 (xeontem)
16:11:34 * hackage lambda-calculus-interpreter 0.1.0.2 - Lambda Calculus interpreter  http://hackage.haskell.org/package/lambda-calculus-interpreter-0.1.0.2 (xeontem)
16:21:14 <monochrom> Using the math part of your brain for Haskell is right.
16:21:46 <monochrom> Some people still write like "f $ a+b" because they're still refusing to think algebra.
16:25:25 <koala_man> wait, what's wrong with 'f $ a+b'? 
16:25:52 <monochrom> It depends on why you wrote it.
16:26:01 <koala_man> what's the alternative?
16:26:19 <monochrom> Some people wrote it because they hate "f (a+b)" and they're like "how to eliminate parentheses?".
16:26:48 <monochrom> Now lurk in ##c for a while to see if anyone asks "how to eliminate curry braces?"
16:28:52 <glguy> monochrom: You have to let a+b breathe! The parentheses look like they're closing in on it. And who doesn't like a little more money?
16:29:20 <monochrom> @quote monochrom \root.of.all.evil
16:29:20 <lambdabot> monochrom says: premature opinion is the root of all evil.
16:29:25 <monochrom> err not that one
16:29:28 <monochrom> @quote monochrom root.of.all.evil
16:29:28 <lambdabot> monochrom says: premature opinion is the root of all evil.
16:29:34 <monochrom> @quote monochrom \$
16:29:34 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
16:29:47 <monochrom> nevermind. was looking for "$ is the root of all evil"
16:29:58 <shachaf> This is why you should use Polish notation. No parentheses necessary.
16:30:21 <shachaf> f + a b
16:30:42 <lyxia> do Polish people talk like that
16:31:12 <monochrom> I have thought that through. If you don't know arities up front, you will need parentheses, for Polish notation. Just look at Scheme.
16:31:40 <shachaf> But in Haskell you know arities up front, more or less.
16:32:10 <shachaf> But I suppose not entirely? I don't know whether you could make it work
16:32:12 <ab9rf> haskell doesn't really have arities.
16:32:37 <glguy> We'd just need to introduce an operator for application
16:32:41 <glguy> $ f + a b
16:32:48 <monochrom> OK, I have "id id id" in Polish notation. Do I mean "(id id) id" or do I mean "id (id id)"?
16:32:48 <glguy> and we're back in busine$$
16:32:54 <shachaf> Yes, that's the problem.
16:33:00 <glguy> monochrom: $ $ id id    or   $ id $ id id
16:33:12 <glguy> Problem moved
16:33:15 <ab9rf> heh
16:33:37 <glguy> oops, first one should have been :   $ $ id id id
16:33:45 <Solonarv> are we unlambda now?
16:34:00 <glguy> That seems like one of those questions that requires a website to answer.
16:35:15 <monochrom> Just wait til you get an undecidable question. :)
17:00:35 * hackage algebraic-graphs 0.2 - A library for algebraic graph construction and transformation  http://hackage.haskell.org/package/algebraic-graphs-0.2 (snowleopard)
17:11:05 * hackage sparrow 0.0.2.2 - Unified streaming dependency management for web apps  http://hackage.haskell.org/package/sparrow-0.0.2.2 (athanclark)
17:18:24 <likdiswenis> hi, all. one thing ppl like about go is that deployment is a breeze - single binary. the same is true for haskell, no? i never see it being stated as a benefit to using haskell like it so often is for golang. why is this?
17:19:42 <ab9rf> likdiswenis: because it's not true?
17:20:03 <carlosdagos> I don't think that's true in all cases, you can of course build your binaries statically. In the NixOS community there's an effort to have all haskell binaries built statically, for example: https://github.com/NixOS/nixpkgs/issues/43795
17:21:04 <ab9rf> likdiswenis: to be honest, i think you'll find that haskellers generally do not care terribly much about what golang enthusiasts think
17:21:46 <carlosdagos> There's some things to consider if you take that route, for example the some software licenses don't allow you to compile against them statically (for example, `integer-simple` vs `integer-gmp`)
17:21:54 <monochrom> It is true for most cases. GHC makes exes that statically link Haskell libraries. (C/foriegn libraries dynamically linked on Linux. Not sure about Windows and MacOS.)
17:22:29 <monochrom> (And I'm referring to default. You can change it.)
17:23:40 <monochrom> Golang probably has very few other things to boast about.
17:24:16 <ab9rf> especially since paradigmatically golang and haskell are quite possibly as antipodean as you can get
17:24:52 <monochrom> With Haskell we don't even have enough time to enumerate the benefits during programming.
17:25:51 <dolio> Does go produce universal binaries cross compiled on every architecture?
17:26:37 <dolio> Or do people mostly copy their exes between machines that are almost the same?
17:26:40 <sshine> I'm revising the example on https://exercism.io/tracks/haskell -- what's a good example? the quicksort thing has always struck me as odd, since it isn't really a quicksort.
17:26:44 <ab9rf> dolio: heh
17:26:46 <carlosdagos> There's benefits of a having a statically linked binary, but I don't know if the effort is really worth it. In terms of simplifying the deployment, as far as I know aren't most people are just containerizing their apps anyway? Maybe there's more goodies out of it, but I'm not aware. 
17:26:49 <monochrom> In fact people actually tell us that the other side of the single-exe coin is a disadvantage. The other side is "why are your exes so bloody huge like 2MB?!"
17:27:04 <ab9rf> dolio: someone asked me the other day if it was possible to make a single file that was both a ELF binary and a PE binary
17:27:09 <ab9rf> dolio: sadly, it is not.
17:27:12 <sshine> Axman6, did you get started on giving feedback on Exercism, by the way? I noticed that you had joined their Slack channel. :)
17:28:31 <dolio> Yeah, I think getting the compiled code somewhere else is probably not the most difficult part of deployment.
17:34:43 <mnoonan> ab9rf: you *can* do ELF and COM, but that's not quite so interesting...
17:39:50 <ab9rf> mnoonan: which one is COM?
17:40:21 <ab9rf> old scool dos?
17:42:34 <geekosaur> yes
17:42:35 <mnoonan> ab9rf: yeah, the "anything goes, I'll just start running this" one :)
17:42:47 <geekosaur> which is basically a real mode memory image,w ith few constrants
17:43:50 <mnoonan> I guess you could probably make it extract and run an exe payload.
17:44:07 <ab9rf> yeah, as i recall it just loaded the file into memory (or the first 64k of it, if it was longer htan that), and transferred contrtol to 0x100
17:55:08 <Axman6> sshine: yep
17:56:34 * hackage massiv 0.2.1.0 - Massiv (Массив) is an Array Library.  http://hackage.haskell.org/package/massiv-0.2.1.0 (lehins)
18:37:11 <jle`> Data.Map having M.lookup yet M.findWithDefault (instead of M.lookupWithDefault) throws me off every time v.v
19:03:00 <monochrom> Perfect naming can only be done with pefect knowledge of the future.
19:03:44 <monochrom> Just like perfect pre-fetching, perfect caching, perfect OS scheduler, ...
19:07:06 <monochrom> Eh, massiv sounds interesting.
19:08:01 <monochrom> Haha bound checks are enabled and disabled with a build-time flag.
19:25:41 <dmrd_> Any of your know how to deal with CPP pre-processing tags in Haskell-Src-Exts? No matter how much I change the parsing options, I can't seem to get it right
19:40:34 * hackage sensu-run 0.6.0.2 - A tool to send command execution results to Sensu  http://hackage.haskell.org/package/sensu-run-0.6.0.2 (MitsutoshiAoe)
19:44:40 <johnnymacs> Is it true that y combinator can be used as a while loop that does not stack overflow in non-lazy languages with proper lambdas?
19:47:23 <sshine> yeees.
19:51:58 <johnnymacs> thanks
19:59:59 <maerwald> are generics faster these days than TH wrt json instance deriving for example?
20:01:19 <c_wraith> TH-generated code can always be the fastest.  But TH runs so slowly you might never make that time back up.
20:01:32 <maerwald> oh, I mean in terms of compile time
20:01:48 <c_wraith> Oh.  TH has always been slower
20:03:17 <ab9rf> c_wraith: write many, run once?
20:03:32 <benzrf> lol
20:19:08 <mniip> an eta-expanded Y combinator can be used in call by value languages
20:19:44 <mniip> fix f = let x = \y -> f x y in x
20:19:51 <mniip> er
20:20:01 <mniip> fix f = let x = \y -> f (x y) y in x
20:20:06 <mniip> something like this
20:21:39 <mniip> fix f = let x = \y -> f x y in x
20:21:40 <mniip> there
20:26:51 <jle`> maerwald: i usually consider it as TH is slow compile, faster runtime, Generics is fast compile, slow runtime
20:27:47 <jle`> not slow and fast in an absolute sense, but in terms of the priorities/design goals
20:51:43 <cheater> hi
20:52:27 <cheater> is there a type that is like undefined, in that it will fit whatever type is necessary due to unification, and will not create problems, until you try to run code with it?
20:52:49 <mniip> jle`, why is TH so sllow anyway
20:53:26 <c_wraith> cheater: Any
20:53:32 <cheater> i just want to write down some functions but i don't know what type they'll have yet
20:53:36 <cheater> hmm
20:53:39 <cheater> :i Any
20:53:55 <c_wraith> https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#t:Any
20:53:56 <cheater> @hoogle Any
20:53:57 <lambdabot> Data.Monoid newtype Any
20:53:57 <lambdabot> Data.Monoid Any :: Bool -> Any
20:53:57 <lambdabot> Data.Semigroup newtype Any
20:54:06 <cheater> hm
20:54:08 <c_wraith> Notably, *not* those ones.
20:54:16 <nshepperd> undefined isn't a type
20:54:24 <c_wraith> nshepperd: exactly?
20:54:43 <nshepperd> so, fixing that confusion seems like the first step to answering the question
20:54:53 <c_wraith> nshepperd: what confusion?
20:55:04 <c_wraith> nshepperd: I think you may have misread the question.
20:55:08 <cheater> nshepperd's confusion.
20:55:35 <nshepperd> maybe
20:56:25 <cheater> c_wraith: so basically what i really want is a type so i can write foo :: Bar, and it's obvious that Bar is a placeholder, and it will not cause a compile error, but would possibly cause a warning, or a runtime error if used
20:56:27 <nshepperd> i'm not sure what a 'type that is like undefined' is supposed to be
20:56:37 <cheater> c_wraith: does Any do that?
20:56:46 <nshepperd> you can enable -XPartialTypeSignatures and put _ in your type sig
20:56:51 <nshepperd> and let ghc infer what the _ is
20:57:00 <cheater> but if it can't infer it'll error out
20:57:05 <cheater> that's not what i want
20:57:09 <cheater> i want it to not care
20:57:25 <cheater> Prelude GHC.Exts> :i Any
20:57:25 <cheater> type family Any :: k0 	-- Defined in ‘GHC.Types’
20:57:33 <cheater> i'm not sure how to read that
20:57:33 <nshepperd> I don't see how you can compile the code without caring
20:57:40 <cheater> i know
20:58:00 <jle`> mniip: i wouldn't say it's slow an absolute sense, but in this specific situation we're comparing codegen to just "normal" haskell functions when we use Generics
20:58:19 <cheater> c_wraith, how does one read "type family Any :: k0"? what does that mean?
20:59:09 <badzergling> practically speaking, `Any` is a type (family) which all terms inhabit.
20:59:20 <c_wraith> It's a zero-arg type family that can have any kind.  But it has no instances, so it's always "stuck"
20:59:49 <cheater> mhm
21:00:07 <cheater> that sounds like just what i'm looking for then
21:00:13 <cheater> let me try it out, thanks :)
21:00:25 <badzergling> this will not save you if ghc cannot actually figure out what type your program is supposed to have,  it can't blithely agree that "yes, that type is in the `Any` family" unless it *has* a type.
21:00:41 <jle`> Any is kind of close to the void pointer in C i think
21:00:58 <jle`> the only way to work with values of its type is by using unsafeCoerce
21:01:05 * hackage microspec 0.2.0.1 - Tiny QuickCheck test library with minimal dependencies  http://hackage.haskell.org/package/microspec-0.2.0.1 (TomMurphy)
21:01:06 <blankhart> is cheater not just looking for a universally quantified type?
21:01:07 <jle`> all you know is that it's some boxed value
21:01:31 <nshepperd> i think cheater is looking for -fdefer-type-errors
21:02:13 <jle`> cheater: you can also write foo :: _
21:02:18 <badzergling> what actually do you want to happen in your program with this untypable term?
21:02:19 <nshepperd> although i also don't think that, because if you're going to defer type errors why bother compiling it in the first place
21:02:21 <jle`> Any is not really meant as a "placeholder type"
21:10:53 <blankhart> Data.Void is a sort of singleton type for undefined
21:11:26 <blankhart> if you wanted to write down a function and make sure it is never called until you figure out what to put there
21:15:56 <maerwald> it seems the stache documentation is incorrect https://hackage.haskell.org/package/stache-2.0.0/docs/Text-Mustache.html#v:compileMustacheText it's strict text
21:17:10 <blankhart> should we all start a software consultancy to promote kind-driven development
21:18:35 <nshepperd> partiallyWrittenFunction :: Void -> _
21:18:54 <nshepperd> then you could fill in holes in your function with absurd, even
21:19:28 <jle`> that's absurd
21:19:44 <nshepperd> ;)
21:20:13 <geekosaur> absurd-driven development?
21:22:48 <nshepperd> i mean, i've never actually done this. when i have a partially written function that doesn't compile, i comment it out until i feel like working on it
21:22:56 <blankhart> it's clear that function requires one parameter, i just don't know what yet
21:24:04 <nshepperd> or put in 'error's if i'm testing something unrelated to the part that's incomplete
21:33:37 <maerwald> I forgot what was the main advantage of megaparsec over parsec?
21:57:52 <delYsid> IIRC it was better error messages?
22:00:12 <cocreature> maerwald: https://github.com/mrkkrp/megaparsec#megaparsec-vs-parsec
22:03:38 <maerwald> well, not a neutral write-up :P
22:03:41 <maerwald> but I guess
