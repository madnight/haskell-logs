00:06:30 <dmwit> redfish64: consider (Any, [x]) instead of ([x], Bool). the Monad instance comes in very handy, then
00:09:18 <dmwit> return gives you the "unmodified" flag; `modified = tell (Any True)` can be used to set the modified flag; do notation can be used to build the list from recursive calls and automatically combine their flags
00:13:11 <dmwit> e.g. mapM doSomethingToEachElement just does the Right Thing
00:24:54 <lavalike> neat
01:43:05 <kove-w-o-salter> Hi, everyone. I'm writing a QuasiQuoter which should only be used as an Exp (not a Pat, Type or Dec). I would like a compile-time error to be generated if the user has used my QuasiQuoter as a Pat, Type or Dec. So, my question is: how do I generate a GHC compile time error?
01:43:49 <kove-w-o-salter> I'm currently using run-time errors but I feel that this is very poor and unpleasant.
01:46:01 <Cale> kove-w-o-salter: Runtime errors are compile time errors for quasiquoters
01:48:27 <kove-w-o-salter> Cale: I'm very sorry. You're right (I didn't think that one through enough). Sorry for waisting your time.
01:55:54 <kove-w-o-salter> Cale: I'm very new to TH and partially forgot that I was using it; thank you for snapping me out of my delusion.
02:31:46 <c50a326> data RoseTree a = Node a [RoseTree a] deriving (Show, Eq) -- sorry but how do I actually make one of these RoseTree's in ghci?
02:31:56 <c50a326> I must be being damn stupid but everything I'm trying is not working :(
02:32:06 <c50a326> (I've not long woken up)
02:32:49 <c50a326> let someTree = Node 5 [Node 6, Node 7, Node 8]; let someTree = Node 5 [6, 7, 8]; that kind of thing
02:33:20 <c50a326> ah :t Node is probably helpful
02:34:09 <c50a326> let someTree = (Node "Hi" [(Node "Hi again" [], Node "Hey" [])])
02:35:11 <c50a326> ah finally
02:35:27 <c50a326> let someTree = Node "Hi" [Node "Hi again" [], Node "Hey" []] -- this worked
02:47:53 <lavalike> c50a326: indeed, your 'Node 6', 7 and 8 were missing their own list of children: 'Node 6 []' and so forth
02:54:59 <c50a326> ah, it said somewhere that ghc 8.0.2 shipped with cabal-install 1.24 ... I just grabbed a tarball and built it and can't see any cabal-install stuff anywhere... (least not in the bin dir of the built stuff)
02:55:24 <c50a326> (apparently I need a cabal version 1.24 in my path for ghcjs to work... ghcjs is a nightmare :o)
03:09:06 <c50a326> ah changing stack lts in global project and then `stack install cabal-install` did the trick
03:09:14 <c50a326> let's see if ghcjs doesn't blow up now :o
03:35:44 <c50a326> dang, it's not kidding when it says "this will take a long time" ... it's been nearly 30 minutes
04:14:37 <absence> is there a better way than [minBound ..] to get a list of a type's values?
04:35:38 <dmwit> absence: You might like:
04:35:40 <dmwit> ?hackage universe
04:35:40 <lambdabot> http://hackage.haskell.org/package/universe
04:36:29 <dmwit> Which, unlike `[minBound ..]`, actually promises to list all of a type's values. It also works on many things that `[minBound ..]` doesn't, e.g. non-`Bounded` types like `Integer` and non-`Enum` types like `(Bool, Bool)`.
04:47:23 <c50a326> I'm getting "irrefutable pattern failed" https://ptpb.pw/_L84/hs#L-77 which I guess is happening because there's sometimes [] or [t], is there a nice way to write this? All I can think of is adding some "if then else"
04:47:38 <c50a326> or maybe a case of thing
04:54:05 <ggVGc> is there a config format that allows pure functions?
04:54:10 <ggVGc> would be cool I think
04:54:24 <dmwit> c50a326: I would use `case`, yes. `case subtrees t of [] -> []; st:sts -> {- as before -}`
04:54:27 <ggVGc> like, YAML but with pure functions so you could generalise some config stuff
04:54:29 <deltasquared> I'm not sure if nix expressions count (pop into my head because of what I was about to write)
04:54:32 <ggVGc> but not do any side effects
04:54:33 <dmwit> ggVGc: Dhall
04:54:44 <ggVGc> ah, that's interesting
04:54:45 <ggVGc> thanks
04:55:34 <deltasquared> anyway, re: nix, yesterday I was informed distro packaged haskell libs can cause issues, so today I'm going to try out bootstrapping with nix's ghc etc. instead
04:56:04 <ggVGc> dmwit: this is real cool, I've thought about creating something like Dhall for a long time
04:56:07 <ggVGc> turns out someone did!
04:56:37 <dmwit> ^_^
04:56:56 <dmwit> Got that "damn, now I don't get credit -- but I must have been on the right track" feel, hey?
04:57:43 <deltasquared> meanwhile I'm more of "oh that's cool, but I disagree with xyz, I wonder if I can do it anway" person...
04:57:54 <deltasquared> somewhat to my detriment
04:58:02 <ggVGc> dmwit: no, just happy it exists. I would never have started making it
04:58:12 <ggVGc> I don't get that credit thing anymore
04:58:16 <dmwit> hooray!
04:58:18 <ggVGc> because I generally don't want to make software
04:58:20 <ggVGc> but I feel I have to
04:58:35 <deltasquared> to plug a hole you feel is neglected?
04:58:45 <deltasquared> no phrasing...
04:59:31 <ggVGc> I just feel I'm a user with uncommon preferences, and I have to scratch my own itch a lot
04:59:40 <ggVGc> also obsessive about certain use patterns
04:59:51 <ggVGc> so then I make my own software for it
05:00:07 <deltasquared> ggVGc: I know the feeling re: uncommon prefs, and for having to write things for that too
05:01:46 <ggVGc> deltasquared: it always turns out subpar though :(
05:01:51 <ggVGc> anyway, gonna use Dhall now
05:01:53 <ggVGc> and not make one!
05:01:54 <dmwit> Meanwhile my own personal annoyance in this domain is that tools like find and grep and test should use a real zeroth-order logic syntax instead of the awful abomination they have each cooked up.
05:01:56 <ggVGc> hooray
05:02:15 <dmwit> (Hence the configuration language I made for pulp.)
05:02:15 <ggVGc> dmwit: patch all of them. I'm sure the world will accept your changes
05:05:35 <tdammers> I think as far as configuration languages go, there's a sweet spot somewhere in between YAML and JSON
05:05:59 <deltasquared> so... no love for S-expressions? :>
05:06:07 <deltasquared> I don't mean lisp, I mean S-exprs as the base syntax
05:06:16 <tdammers> syntax shmyntax
05:06:21 <deltasquared> though what the keywords would be then is anyone's guess
05:07:05 <tdammers> the problems usually start when people start making the configuration mechanism more powerful than JSON
05:07:20 <tdammers> it seems benign - a few abstractions here, some dynamic stuff there
05:07:27 <deltasquared> tdammers: I guess that's more an issue of accidentally turing complete
05:07:38 <deltasquared> or starting to encroach on that
05:07:39 <tdammers> but before you realize it, you're building an embedded programming language
05:07:50 <tdammers> yeah, turing completeness is one problem that can occur
05:08:09 <tdammers> but at that point, you are no longer configuring the system, you are scripting it
05:08:33 <tdammers> and IMO you're better off admitting that, and using a proper scipting language instead
05:09:27 <tdammers> I'd much rather have an embedded Lua or JS interpreter in the host application than some abomination like Ansible playbooks that pretends to be a declarative configuration format but really amounts to a very shitty scripting language with uncomfortable syntax and bad design
05:09:48 <deltasquared> you say scripting language and my brain goes "lua!" before I realise.... imperative language, functional programming language IRC channel. *ducks*
05:10:04 <dmwit> Lua isn't a swear word, even here.
05:10:21 <deltasquared> dmwit: I actually find myself writing functional abstractions in lua a bit
05:10:29 <deltasquared> mostly folds or iterator fmaps
05:10:33 <dmwit> Have you seen https://github.com/GaloisInc/galua? =)
05:11:55 <deltasquared> interesting, effectively a lua interpreter in haskell, and a web UI. very interesting indeed
05:13:12 * deltasquared ponders writing lazy thunks in lua
05:13:29 <deltasquared> I mean, we have GHCJS, it's not completely crazy
05:18:40 <tsaka__> How old on average are packages when included in a Stack resolver LTS release?
05:18:51 <tsaka__> And what does "support" in LTS in this context imply?
05:27:00 <halogenandtoast> If I wanted to make an indentation aware parser, but indentation could only be 2 spaces, would I need to make a special parser type where the m is a ReaderT?
05:27:10 <halogenandtoast> in 
05:27:11 <halogenandtoast> data ParsecT s u m a
05:27:59 <halogenandtoast> I know there is the indents package, but the indentation amount/type doesn't seem configurable
05:35:46 * deltasquared checks an old static binary he made for a system program
05:35:57 <deltasquared> wh- how did I never spot the fact it was only 7k
05:36:29 <deltasquared> that's actually pretty impressive, though that program never relied on a whole lot I guess
05:38:55 <lyxia> halogenandtoast: yes that sounds like a good way to do it
05:39:44 <halogenandtoast> lyxia: thanks, hopefully I can figure it out
05:51:33 <deltasquared> lolwhat why is cabal etc. from nix showing 1.0T for virt mem in htop...
06:01:39 <int-e> deltasquared: That this is true for all Haskell programs (as long as you're using ghc-8.0 or later). https://ghc.haskell.org/trac/ghc/ticket/14193 suggests that this isn't going to change any time soon.
06:04:00 <deltasquared> int-e: I figured it may be something to do with heap space. that said, it is concerning that this would prevent me from using haskell programs on a system with overcommit disabled.
06:04:17 <deltasquared> said disable of overcommit is a rather large hammer, but one I have had to reach for before
06:04:37 <deltasquared> thankfully the "earlyoom" daemon has provided a saner alternative for the time being.
06:05:37 <deltasquared> ah, MADVISE_DONTNEED, ok then
06:28:55 <ggVGc> wish I could do haskell today :(
06:29:06 <hodapp> why can't you
06:29:42 <ggVGc> because, you know, work that actually pays money and that I promised people to do
06:29:47 <ggVGc> even though I don't have time
06:29:54 <ggVGc> I work weekends almost every week
06:30:09 <ggVGc> two weeks ago I logged 55h in 4 days
06:30:11 <ggVGc> was a bit rough
06:30:14 <dmwit> Oh, dang. I hope you get compensated appropriately!
06:30:35 <ggVGc> not really, but I'm finishing this gig to be nice to the guy I'm doing it for
06:30:39 <ggVGc> but it's a buit crap
06:30:45 <ggVGc> just trying to get it out of my life now
06:31:22 <ggVGc> dmwit: I just usually manage to somehow have two fulltime jobs
06:31:28 <ggVGc> even though I'm aiming for part time contracts
06:31:51 <ggVGc> e.g not doing so well on my work management
06:32:13 <dmwit> Sorry to hear that. I hope you find a workflow that helps you mitigate that.
06:33:29 <ggVGc> so I can do more haskell!
06:33:36 <dmwit> ...yeah, that. =)
06:33:42 <f-a> say I want to `cat file.txt | haskell-progr`, what do I need inside my main to read the piped content?
06:34:00 <ggVGc> I feel a like I'm having trouble advancing in haskell tbh. Feels like I need to be more around others who use it daily
06:34:04 <ggVGc> e.g having it as a day jo b
06:34:11 <dmwit> f-a: Any of the usual suspects should work just fine. `getChar` is the most basic; `getLine` and `getContents` are interesting alternate choices.
06:34:28 <ggVGc> f-a: I usually use getLine
06:34:32 <dmwit> f-a: Also, use `haskell-progr < file.txt` instead. ;-)
06:34:34 <ggVGc> because I find linewise processing ewasier
06:34:46 <ggVGc> but I guess it depends on what input data you're expecting
06:34:54 <ggVGc> getChar might be necessary based on expected usecase
06:35:09 <f-a> dmwit: thanks. yeah I always forget unix syntax! what's the difference in behaviour between Contents and Line?
06:35:13 <ggVGc> getContents is fine if you're not needing stream processing I guess
06:35:25 <ggVGc> f-a: afaik, getContents will read everything into memory?
06:35:33 <ggVGc> but now that I think about it, maybe not?
06:35:42 <ggVGc> is getContents lazy?
06:35:45 <dmwit> f-a: getContents does lazy IO to give you a String that behaves like it has the entire contents of stdin.
06:35:50 <ggVGc> ah, sweet
06:35:53 <ggVGc> I didn't know that
06:35:59 <EvanR> ggVGc: what about your promises to haskell (tm) >:)
06:36:03 <dmwit> (Lazy IO is only vaguely related to pure laziness.)
06:36:43 <ggVGc> EvanR: was my promise to get a haskell day job?
06:36:44 <ggVGc> I don't remember
06:36:57 <ggVGc> or I didn't get this joke :(
06:37:09 <deltasquared> is there documentation anywhere of environment variables that affect GHC behaviour? in particular, library search path, but I was curious to see if there was a general list
06:37:36 <EvanR> its no joke
06:37:43 <ggVGc> EvanR: listening to nectarine again now btw
06:37:45 <ggVGc> been a long time
06:37:52 <EvanR> scenestream yeah
06:38:07 <EvanR> totally off topic!
06:38:13 <dmwit> deltasquared: No central resource, unfortunately. I've wanted that to live in the "flag reference" section of the GHC documentation for a while now.
06:38:45 <deltasquared> dmwit: or like built into --help or something...
06:39:18 <dmwit> --help is nice, but I think it's good for it to be a summary of the frequently used stuff rather than trying to be exhaustive.
06:39:52 <dmwit> The exhaustive help for GHC is just... too exhausting. =P
06:39:57 <deltasquared> anyway, that leads onto the following: I have run cabal install of a package from a user account which I intend to act as a shared store of haskell packages - given that user's home dir and assuming I can access it from another user, what variables would I set to get ghc/ghci to pick them up?
06:40:08 <deltasquared> dmwit: --help=envvars? *shrug*
06:40:35 <deltasquared> a random DDG search suggests GHC_PACKAGE_PATH
06:40:53 <dmwit> That seems reasonable.
06:41:08 <dmwit> You might also be interested in https://github.com/hvr/cabal-env
06:41:29 <dmwit> ...if I'm guessing your motivation for installing packages as a separate user correctly, which I may not be.
06:42:16 <ggVGc> is it blasphemy to say that I've started disliking haskell syntax more and more over the past year?
06:42:24 <ggVGc> I think, since doing more Elixir..
06:42:27 <deltasquared> dmwit: it's mainly a separation of concerns thing - I like to keep package retrieval things confined to other users
06:42:50 <ggVGc> I think haskell the language design is real nice, but maybe not haskell the syntax
06:42:56 <dmwit> deltasquared: v. paranoid. I approve.
06:43:25 <ggVGc> are there any efforts on basically doing an alternative haskell compiling to core?
06:43:30 <ggVGc> like elixir did for erlang
06:43:40 <deltasquared> dmwit: the other thing, being that I don't want to have lots of encrypted storage around, so having it in a sep. user means I don't have to worry so much about it being encrypted - my dev user's home *is*, and I don't want that user to be able to write anywhere unencrypted.
06:44:02 <deltasquared> so again, one user for downloading packages, one for doing actual development
06:44:06 <dmwit> ggVGc: Try Liskell! All the pain of Haskell's wide collection of available syntactic form, plus all the annoyance of Lisp's parentheses.
06:44:16 <ggVGc> :(
06:44:17 <deltasquared> dmwit: that's a thing?
06:44:33 <ggVGc> never been into lisp really
06:44:39 <ggVGc> which makes me probably not a proper programmer
06:44:57 <dolio> I've never seen anything I like better than Haskell syntax wise.
06:45:01 <deltasquared> I haven't into lisp, I don't care much for another imperative language semantics. S-exprs however are of interest
06:45:10 <ggVGc> I think what I miss a lot in haskell doesn't have to do only with syntax though, but with row polymorphism. I've always reallu liked it
06:45:31 <dmwit> deltasquared: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
06:45:35 <ggVGc> when i first went from F# to haskell, row polymorphism is what I missed. And what I really like in PureScript
06:45:49 <deltasquared> specifically that in theory a recursive context-free parse of a mildly restricted S-expression language would be stupidly easy to parse
06:45:59 <EvanR> yes that is blasphemy
06:46:53 <dolio> There are some with cool features that essentially look like Haskell.
06:47:02 <ggVGc> actually, maybe I meant structural subtyping and not row polymorphism
06:47:08 <ggVGc> either way, I wish haskell had it
06:47:17 <deltasquared> dmwit: ... this is very much like something I came up with once, in particular the (=> ...) thing and such for constraints
06:47:25 <EvanR> there are a few "records done right plans"
06:47:31 <ggVGc> dolio: perhaps I just need to up my haskell writing game
06:47:36 <EvanR> but its too late to do any of them for haskell
06:47:37 <ggVGc> but I find it hard to write readable haskell code
06:47:45 <ggVGc> it takes a lot of effort from me, which is annoying
06:47:57 <EvanR> (every time i say that, ghc goes ahead and does it)
06:48:01 <dolio> Well, I definitely don't get that.
06:48:11 <dolio> From a pure layout perspective.
06:48:29 <ggVGc> it's not only layout I think, but also syntax constructs
06:48:34 <ggVGc> I feel forced into weird situations often
06:48:43 <dolio> Almost everything else I eventually have trouble putting on screen in a good way.
06:49:05 <dolio> Like, eventually it's a choice between super long lines, or unsatisfactory ways of breaking them up.
06:49:13 * ski . o O ( Liskell, a SExp syntax for Haskell, by therp, at <https://web.archive.org/web/20120609122549/http://www.liskell.org/> )
06:50:39 <EvanR> agreed its easy to get into weird situations
06:50:59 <EvanR> but i just make more lines in my where clauses (maybe nested wheres) and break it up
06:51:21 <EvanR> you can remove a whole do block and stick it on a new where line
06:52:01 <EvanR> it all ends up looking more or less rectangular most of the time
06:52:25 <ggVGc> EvanR: it's not only about layout for me. I feel I often have to make bindings I might not want to make etc.
06:52:31 <dolio> Actually, I think a lot of the redundancy in Haskell/GHC is why I don't run into this problem.
06:52:45 <ggVGc> I can't put my finger on it, but I feel there's deficiencies in the haskell syntax that make things harder than they need to be for me
06:52:49 <dolio> Like, the, "there's only one way to do things," dictum is fundamentally at odds with this.
06:53:35 <dmwit> I think the main thing that I find annoying is having to put everything in A-normal form for monadic code.
06:53:48 <deltasquared> dmwit: so what would I set for GHC_PACKAGE_PATH, would it be the package.conf.d with all the .conf files for packages in
06:54:03 <dmwit> Dunno. Have you looked for this info in the FM?
06:54:08 <deltasquared> dmwit: the FM?
06:54:17 <dmwit> fine manual
06:54:27 <deltasquared> dmwit: I'm reading https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#the-ghc-package-path-environment-variable
06:54:39 <deltasquared> however, this only mentions single files for the value of that env var
06:54:55 <deltasquared> oh wait, package databases... let's look at that
06:55:03 <deltasquared> aaah, bingo, it is that
06:55:41 <deltasquared> ... erm, now I'm getting a lot of errors related to System.IO not being imported...
06:55:51 <deltasquared> then ghci just died
06:55:59 <deltasquared> am I missing a package perhaps
06:56:09 <dmwit> You probably want to include at least the system package DB in your package path.
06:57:16 <dmwit> You can use ghc-pkg list (with the environment variable unset) to find out where it lives.
06:58:08 <dmwit> It occurs to me that this whole setup is probably not going to smoothly interoperate with having multiple GHCs installed.
06:59:03 <deltasquared> dmwit: I'm not needing of that right now, this is just for local development of my own things
06:59:16 <dmwit> Probably the package environment file mechanism is going to be smoother for that, since it allows a redirection through an arch-os-version directory.
06:59:28 <dmwit> (But will only work on newer GHCs.)
07:00:48 <deltasquared> hmm, system.IO belongs to base, I thought it did. so why is this exploding then...
07:00:51 <dmwit> Come to think of it, you'll probably be bumping into all kinds of fun and annoying edges. The tools weren't really designed with this in mind, I don't think.
07:01:17 <deltasquared> dmwit: would not be the first time I've been known for blowing myself into holes, not to worry
07:01:19 <dmwit> deltasquared: What's the exact error? What happened when you tried my advice above on fixing it?
07:02:04 <deltasquared> dmwit: ghci blows up as follows on launch:
07:02:05 <deltasquared> <interactive>:1:6: error:
07:02:05 <deltasquared>     Not in scope: ‘System.IO.hSetBuffering’
07:02:06 <deltasquared>     No module named ‘System.IO’ is imported.
07:02:16 <deltasquared> a bunch of similar errors, then it dies.
07:02:28 <dmwit> What does ghc-pkg list base say?
07:02:32 <halogenandtoast> Shouldn't this type synonym take 4 arguments? type Parsec s u = ParsecT s u Identity
07:02:40 <halogenandtoast> when I try to do something similar I get a compiler error
07:02:43 <dmwit> halogenandtoast: Convince me.
07:03:11 <deltasquared> dmwit:
07:03:13 <deltasquared> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
07:03:13 <deltasquared> /usr/local/cabal/ghc/x86_64-linux-8.4.3/package.conf.d/
07:03:14 <deltasquared>     (no packages)
07:03:25 <deltasquared> hmm, so what's up with this... *runs suggestion*
07:03:49 <halogenandtoast> dmwit: ? https://gist.github.com/halogenandtoast/465d516292b555b03c90accabe207cbf
07:03:51 <dmwit> deltasquared: Okay. I think you have not followed my advice from 8 minutes ago. =)
07:04:05 <dmwit> halogenandtoast: No, I mean: convince me it should take four arguments.
07:04:16 <dmwit> halogenandtoast: That will give me a way to point out where your reasoning is incorrect. =)
07:04:17 <deltasquared> dmwit: would you mind saying that again then, because my brain is trying to go two ways at once here :?
07:04:29 <dmwit> deltasquared: You probably want to include at least the system package DB in your package path.
07:04:34 <Myrl-saki> Is there a language where IO is modeled as FRP?
07:04:34 <dmwit> You can use ghc-pkg list (with the environment variable unset) to find out where it lives.
07:04:53 <Myrl-saki> Just curious if it's been done before.
07:04:57 <deltasquared> dmwit: it lives in base... but cabas has a copy of it too. I kinda wanted to rely on cabal only.
07:05:08 <deltasquared> s/cabas/cabal/
07:05:15 <dmwit> deltasquared: base is provided by the system package DB.
07:05:38 <dmwit> cabal does not (and cannot) provide it. It's wired deep into the GHC internals.
07:05:43 <deltasquared> right... hmm
07:05:59 <deltasquared> after all this mess to *avoid* the system DB due to apparently arch's ones being broken...
07:06:12 <deltasquared> that said, using nix's ghc right now, maybe that problem will go away.
07:06:14 <halogenandtoast> dmwit: I see that ParsecT is a newtype declaration, not data
07:06:20 <halogenandtoast> so that answers my question
07:06:30 <dmwit> Huh. It does?
07:06:52 * dmwit can't figure any reason newtype vs. data should make a difference to how many arguments there are
07:07:58 <halogenandtoast> when I have a type declaration that has 4 arguments, and I create a new type declaration without those 4 I get a compiler error, I assumed I wouldn't, I assumed I'd essentially get a type waiting for the last argument
07:08:26 <halogenandtoast> but the compiler yells at me "The type synonym ‘IndentParsecT’ should have 4 arguments, but has been given 3"
07:08:36 <halogenandtoast> I assumed I was doing the same thing Parsec was
07:08:38 <halogenandtoast> but I'm not
07:08:58 <dmwit> Ah. Sure, there's a difference between type and newtype here. Not data and newtype, though.
07:09:01 <dmwit> Anyway.
07:09:12 <halogenandtoast> Yeah agreed, I said the wrong thing :\
07:09:16 <dmwit> halogenandtoast: You can just leave `a` off of both sides of the equation for `IndentParsecT`.
07:10:23 <halogenandtoast> dmwit: yup thanks
07:11:41 <dmwit> deltasquared: I mean, you could always try to write only Haskell that doesn't require `base`. That would be a fun challenge!
07:11:47 <deltasquared> dmwit: the system DB currently is a path in a nix store path, which isn't exposed by any profile. relying on that wouldn't move with upgrades and/or would break on a store GC.
07:11:53 <dmwit> Sort of restricts you to libraries only, though. No IO!
07:12:34 <deltasquared> in other words, your suggestion is not a permanent fix to what I'm trying to do. that said, I'll try it anyhow
07:13:09 <deltasquared> seeing as there's no way in the env var to say "default plus this directory"
07:13:32 <dmwit> deltasquared: Just another reason to switch to package environment files, I guess. One of the available directives for those is `global-package-db`, which lets GHC use whatever path it's got baked into it for that.
07:14:06 <deltasquared> ... oooooh, wait, if you put a colon at the end, it appends the defaults
07:14:49 <deltasquared> well, I did that and ghci has reached the prompt, that's an improvement
07:14:55 <dmwit> deltasquared: ...but both the user and system databases. Up to you to decide whether that's a problem.
07:15:07 <deltasquared> dmwit: I don't have a user DB currently, so no
07:15:38 <dmwit> What I'm saying is that it makes installing to your user database instead of the other user's database silently appear to work.
07:16:03 <dmwit> Even though you might wish it would cause some kind of message reminding you of your package discipline.
07:16:14 <deltasquared> dmwit: I won't be running cabal or such on this dev user for the time being, but I'll bear that in mind
07:16:26 * dmwit nods agreeably
07:17:16 <deltasquared> dmwit: hey, if you don't blow things up every now and again you're not learning! :P
07:17:31 <dmwit> ah, well... you can also learn by watching dmwit blow things up =P
07:17:33 <deltasquared> now to try the package I originally came through all this mess for...
07:17:50 <deltasquared> I hope refined was worth all this
07:23:53 --- mode: glguy set +v MEME_SUPREME
07:30:14 <deltasquared> ooh, fancy predicate failure messages. me likey
07:33:00 <maerwald> constraint from project config TODO requires ==4.11.1.0
07:33:06 <maerwald> what does that mean
07:33:53 <dmwit> Heh. If that's from the latest release of cabal I'd file a bug.
07:34:37 <deltasquared> right, next question, is there a way to tell cabal to keep source code around on disk so I can have a peek
07:34:46 <dmwit> If I had to guess, it means you specified version 4.11.1.0 in either cabal.project or cabal.project.local and this caused a conflict with some other dependency constraints.
07:34:48 <deltasquared> or maybe just the docs... where have they gotten to..
07:35:11 <dmwit> deltasquared: cabal unpack
07:35:59 <sphinxo> is it possible to use servant + persistent + servant-swagger and generate swagger documentation for my persistant models without having to redefine them as normal haskell datatypes? 
07:36:22 <maerwald> dmwit: I didn't
07:36:30 <deltasquared> dmwit: cheers
07:37:00 <deltasquared> ... ah, it's trying to unpack in the cwd, 'mkay, I need a place for this
07:37:25 <dmwit> maerwald: Maybe paste the whole error. No promises that I'll be able to deliver even if you do that, though.
07:37:58 <maerwald> dmwit: oh, it seems there was a freeze file
07:38:01 <dminuoso> sphinxo: persistent is not magic, it genereates data types.
07:38:22 <maerwald> the error is not particularly descriptive though
07:38:25 <maerwald> TODO.. right
07:39:23 <dminuoso> sphinxo: Dunno if persistent already provides you with Generic instances, but you could make a standalone deriving instance for Generic for your model, and then rely on HasSwagger to do the right thing.
07:41:40 <sphinxo> dminuoso: i get some missing instances from the swagger internals but I think I just need to implement Generic for Key
07:43:46 <sphinxo> Thanks dminuoso 
07:45:00 <absence> dmwit: thanks for the universe link earlier, looks interesting
07:45:14 * deltasquared looks into how predicates are written for refined
07:45:31 <deltasquared> ... is that a monad transformer... oh dear. just when I thought I could sneak by without having to get my head around those
07:46:17 <maerwald> rejecting: hsfm-0.0.0.1 (conflict: gtk2hs-buildtools==0.13.4.0, hsfm => gtk2hs-buildtools>=0.15)
07:46:21 <maerwald> what does that mean
07:46:31 <maerwald> what is setting it to 0.13.4.0?
07:46:52 <dmwit> should say earlier in the message
07:47:17 <maerwald> it doesn't
07:47:19 <dmwit> if not, try adding --constraint gtk2hs-buildtools>=0.15 to the build line to get further error text about that specific constraint
07:48:19 <maerwald> nothing useful
07:48:30 <dmwit> full error text?
07:48:35 <maerwald> https://lpaste.net/3771118132135985152
07:49:09 <dmwit> still have a freeze file?
07:49:24 <dmwit> "user target" means "you asked for this".
07:50:00 <maerwald> hm, it just seems there is no 0.15 lol
07:50:01 <dmwit> Again possibly via your cabal.project or cabal.project.local.
07:50:14 <maerwald> they just bumped the other packages to 0.15
07:50:18 <maerwald> https://github.com/gtk2hs/gtk2hs
07:51:58 <dminuoso> Mmm so top level expressions of type Q monad get executed by TH automatically? 
07:52:12 <dminuoso> I somehow would have expected this needed explicit splicing
07:52:21 <dmwit> I think they must specifically be Q Decl.
07:52:25 <dmwit> Or Q [Decl] maybe.
07:52:41 <dmwit> The implicit splicing thing is considered a misfeature by many.
07:52:56 <safinaskar> hi
07:53:12 <safinaskar> safe haskell can be used to create plugin system
07:53:23 <safinaskar> but how to load the plugins dynamically?
07:53:30 <safinaskar> without restarting main program?
07:54:13 <dminuoso> dmwit: Fair enough, so I guess there is no harm in replacing implicit splices with explicit ones?
07:54:28 <dminuoso> I really dislike how hidden the TH magic is
07:54:32 <dmwit> dminuoso: correct
07:54:40 <dminuoso> dmwit: Great thans.
07:56:04 <tsaka__> Is there a way to combine state monads?
07:57:00 <dmj`> tsaka__: you can combine product types into a single product type, and then use that as the s in your State s a
07:58:23 <dminuoso> Emacs users, how do you generally run your code? Do you `M-x term` into say `cabal new-repl` and then continuously `:r` your code?
07:58:34 <tsaka__> dmj`: When you've done that, how to use functions on a single state monad inside the big combinator-state-monad?
07:58:50 <dmj`> dminuoso: using haskell-mode you can just C-c C-l to send to it to repl
07:58:53 <dmwit> tsaka__: zoom from lens makes that pretty convenient.
07:59:20 <dmj`> tsaka__: if you had both products in a tuple, you can use the `use` function from lens
07:59:45 <dmj`> tsaka__: do { value <- use (someField . _1); liftIO (print value) }
08:00:28 <dmj`> tsaka__: or use microlens, its like smaller lens
08:00:49 <dmj`> dminuoso: sometimes I open an eshell, go into nix-shell inside of that eshell, then start ghcid
08:01:40 <dminuoso> dmj`: Why go through nix-shell?
08:02:46 <dmj`> dminuoso: to ensure I have the correct deps, not necessary if you don’t use nix and ghcid is smart enough to find the ghc-pkg list for your project. Nix gives me isolation, so I know exactly what ghc-pkg list I’m using. If you call stack exec — ghc-pkg list it can potentially show multiple package lists
08:03:13 <dmj`> dminuoso: nix-shell —command ‘ghc-pkg list'
08:03:41 <dmj`> dminuoso: since I don’t have ghc installed globally that will give me the deps from the /nix/store in a shell according to what cabal2nix produced.
08:04:45 <dminuoso> dmj`: Fair enough, Im not very familiar with nix so Im not exactly sure what that means - but I think I have a very rough idea. 
08:05:37 <dminuoso> dmj`: how could stack not give me enough isolation to produce multiple package lists for `stack exec -- ghc-pkg list`?
08:06:37 <dmj`> dminuoso: by default ghc comes with boot packages, bytestring, binary, etc. but if you want aeson you have to install it somewhere. Here is a nix command to fetch aeson for the latest stable ghc, and execute a command in a shell to tell you its version.  `nix-shell -p 'haskellPackages.ghcWithPackages (p: [p.aeson])' --command 'ghc-pkg list aeson’`
08:07:30 <dmj`> dminuoso: I’m not sure, ghc by default can work with multiple package lists, but this can cause conflicts I believe.
08:09:00 <dmj`> dminuoso: cabal and stack abstract you from what’s really going on behind the scenes. Just using runghc, Setup.hs and a ghc-pkg list (these used to be constructed manually with makefiles) is a good exercise
08:09:46 <dmj`> dminuoso: stack and cabal are invoking ghc-pkg at some point, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-management-the-ghc-pkg-command
08:15:41 <dminuoso> dmj`: Is this related to the `.ghc.environment...` file produced by new-build?
08:16:03 <dminuoso> Over the past few weeks I switched everything to new-build (merijn made me do it), so..
08:18:34 <maerwald> it feels more powerful than stack, more flexible and less broken (especially profiling builds)
08:19:01 <dminuoso> And much less documented!
08:19:11 <dminuoso> It's the one issue I have with new-*
08:19:51 <geekosaur> keep in mind that stack is less flexble for a reason… granting that that reason may not align with your intent
08:20:06 <dmj`> dminuoso: I don’t know, I’m not sure about the intention of .ghc.environment files. But have seen them pop up when using cabal new-build.
08:20:27 <maerwald> geekosaur: everything has a reason, doesn't mean it's a good reason :)
08:32:41 --- mode: glguy set +v apman
08:54:46 --- mode: glguy set +v AxelBoldt
08:55:43 <tsaka__> In microlens, how to create an ASetter which sets the field of a record?
08:56:16 <AxelBoldt> Is something wrong with the web server? The recommended Windows download https://haskell.org/platform/download/8.4.3/HaskellPlatform-8.4.3-full-x86_64-setup.exe gives "File not found"
09:00:57 <AxelBoldt> Ah, I found it at https://downloads.haskell.org/~platform/8.4.3/HaskellPlatform-8.4.3-full-x86_64-setup.exe
09:01:49 <AxelBoldt> Someone should tell the webmaster to change the link at https://www.haskell.org/platform/windows.html
09:03:39 * hexagoxel forwards this to #haskell-infrastructure
09:35:44 <jle`> tsaka__: usually you'd create a lens that sets that field
09:35:45 --- mode: glguy set +v WarzoneCommand
09:35:54 <jle`> tsaka__: and lens unifies with ASetter/can be used as an ASetter
09:37:17 <WarzoneCommand> Question: since a while intero seems to be using some flag to defer typeerrors while loading a module in the repl. Does anyone know if I can disable that? I find it terribly annoying 
09:38:40 --- mode: glguy set -v WarzoneCommand
10:23:02 <deidyomega> I'm having trouble understanding how to pass in a tuple into a function, then evaulate the internal values
10:23:03 <deidyomega> https://gist.github.com/deidyomega/fad42bb4e526718608e98fd25b20c65e
10:23:46 <cocreature> deidyomega: you can’t select the first element of a tuple using [0]
10:24:05 <cocreature> deidyomega: you can use the "fst" function for that but in this case pattern matching is probably the better option
10:24:21 <deidyomega> cocreature: how do I select the first element, or use pattern  matching?
10:24:28 <cocreature> "get_winner (fstHand, sndHand) | …"
10:24:39 <cocreature> then fstHand will refer to the first element and sndHand will refer to the second
10:26:49 <deidyomega> hmm, i edited the code, still didn't work, if you refresh that gist, I pasted the new code and the error I'm getting
10:27:41 <cocreature> deidyomega: are you sure that is the code you are using? the line numbers in the error message don’t match up
10:28:09 <cocreature> it looks like you might have forgotten the call to "print" in the code that you are actually using
10:28:26 <deidyomega> Yeah, I commented out most of my code, so I could focus on only the thing that was breaking
10:28:49 <deidyomega> god dang it
10:28:56 <deidyomega> Okay, thanks, and I'm an idiot 
10:32:00 <EvanR> to evaluate something in haskell, you must first evaluate something that uses it
10:32:04 <EvanR> and so on
10:32:13 <EvanR> AD INFINITUM
10:33:09 <EvanR> ultimately evaluation is driven by the IO actions with arguments, and by machine arithmetic which needs its argument right now
10:44:00 <Moosef> Could anyone help me with a "Real World Haskell" book problem?
10:45:18 <cocreature> Moosef: just ask your question directly :)
10:45:20 <c_wraith> Moosef: best results are obtained by just asking your question.  If anyone paying attention can answer it, they will
10:45:51 <ggVGc> nonsene, there's no haskell in the real world
10:49:09 <absence> if i have "someMaybeT <|> someOtherMaybeT <|> pure whatever", it will aslways succeed, but i end up with a "dummy" Maybe that i know will always contain a value. is there a more elegant way than fromJust to handle such a case?
10:49:53 <tsaka__> If you have lots of component with state, you can use the State monad with a record of all the components and lenses to zoom in on a particular component. How do you then deal with functions that update the state of 2 components at once?
10:49:57 <Moosef> Here is my question: where are these errors coming from in trying to compile this function https://lpaste.net/5814500530319261696?
10:50:50 <c_wraith> Moosef: you're attempting to pattern-match a string against an expected Char argument
10:51:11 <c_wraith> Moosef: the second error message makes that clearer than the first
10:52:10 <c_wraith> Moosef: to get a more useful message, you can put a type on the binding for next
10:52:20 <c_wraith> Moosef: that will cause the compiler to generate more local error messages
10:52:57 <cocreature> absence: remove the "pure …" part and instead use fromMaybe
10:53:09 <Moosef> c_wraith: Thanks a lot that fixed it up for me, and I wouldn't have thought to type my helper function for that reason. I will try to remember it in the future.
10:53:40 <cocreature> :t \x y def -> fmap (fromMaybe def) (runMaybeT (x <|> y)) -- absence 
10:53:41 <lambdabot> error:
10:53:41 <lambdabot>     Variable not in scope: runMaybeT :: f a -> f1 (Maybe b)
10:53:51 <cocreature> @let import Control.Monad.Trans.Maybe
10:53:52 <lambdabot>  Defined.
10:53:53 <cocreature> :t \x y def -> fmap (fromMaybe def) (runMaybeT (x <|> y)) -- absence 
10:53:54 <lambdabot> Monad f => MaybeT f b -> MaybeT f b -> b -> f b
10:54:26 <c_wraith> Moosef: yeah, it's a good general-purpose technique.  If you're getting a type error and you're not sure where it's from, it's worth adding type signatures to local bits just to narrow down where what you think and what the compiler think differe
10:54:47 <absence> cocreature: i guess i simplified my example a bit too much. i don't have a pure value there in my code, but an action that uses the underlying monad. it always returns Just though
10:55:00 <absence> cocreature: but maybe i can still get that to work with fromMaybe, i'll try
10:55:07 <cocreature> tsaka__: write a lens that focuses on a tuple of the components that you care about and then use that with zoom
10:56:54 <cocreature> :t \x y def -> maybe pure def =<< runMaybeT (x <|> y) -- absence 
10:56:56 <lambdabot> Applicative f => MaybeT ((->) a1) a2 -> MaybeT ((->) a1) a2 -> (a2 -> a1 -> f a1) -> a1 -> f a1
10:57:06 <cocreature> :t \x y def -> maybe def pure =<< runMaybeT (x <|> y) -- absence 
10:57:07 <lambdabot> Monad m => MaybeT m b -> MaybeT m b -> m b -> m b
10:57:12 <cocreature> that’s better :)
11:08:49 <absence> cocreature: right, exactly :) i might just make that into an operator. thanks!
11:09:34 <tsaka__> cocreature: Another issue: When writing functions that operate on a non-unit subset of the state components -- Is it feasible to use "State (Comp1, Comp2)" instead of a datastructure with Comp1 and Comp2? I tried zooming with tuple lenses "_1" without luck
11:11:27 <cocreature> tsaka__: that should work, can you provide some minimal example of what problem you ran into with _1?
11:20:58 <tsaka__> cocreature: https://lpaste.net/1707815044273668096
11:23:34 <cocreature> tsaka__: that looks like you haven’t imported _1 (for the lens lib that’s exported from Control.Lens but you appear to be using some other lens lib)
11:23:51 <mojjoo> hi! is there a way to construct a list with the do notation in situations you'd like to avoid the list literal beacuse it gets nested and clumpsy?
11:25:27 <Ariakenom> mojjoo: you can use line breaks and indentation with a list literal
11:25:37 <dmwit> > do { c <- "hello, mojjoo!"; n <- [2, 5]; replicate n c }
11:25:39 <lambdabot>  "hhhhhhheeeeeeellllllllllllllooooooo,,,,,,,       mmmmmmmooooooojjjjjjjjjjjj...
11:26:00 <dmj`> mojjoo: the do syntax will assume you have lists present you’d like to transform (use `concatMap` on)
11:26:50 <mojjoo> basically I'm lokking for this: `xs = do { addItem "x"; do addItem "y" } :: [String]` ... whereas (xs == ["x", "y"])
11:27:16 <dmwit> > fst $ do { tell ["x"]; tell ["x"] }
11:27:18 <mojjoo> It just about syntactic sugar (no need for the actual list monad)
11:27:18 <lambdabot>  error:
11:27:18 <lambdabot>      • No instance for (MonadWriter [[Char]] ((,) ()))
11:27:18 <lambdabot>          arising from a use of ‘e_1’
11:27:56 <mojjoo> dmwit... yeah I thougth about this, the writer monad
11:28:35 <dmwit> > execWriter $ do { tell ["x"]; tell ["y"] }
11:28:38 <lambdabot>  ["x","y"]
11:28:49 <dmwit> Hmph. I thought (,) had a MonadWriter instance, but I guess not.
11:29:39 <mojjoo> nice..
11:29:50 <dmwit> mojjoo: Anyway I don't understand that. Why would you prefer that to `xs =\n\t[ "x"\n\t, "y"\n\t]`?
11:31:31 <mojjoo> I am also not sure if it's such a good idea.. It's maybe bracket-phobia or so... :)
11:32:24 <int-e> xs = 1 : 2 : [] -- you can fall back to first principles
11:32:58 <dmwit> hehe
11:33:09 <dmwit> xs = 1 : 2 : mempty -- look ma, no brackets!
11:33:34 <mojjoo> actually not a bad idea...
11:36:35 <dmwit> (And then you might think, "man, I have to repeat that tell [...] pattern a lot. I know, I'll use `mapM` to get rid of that repetition. `mapM (tell . pure) ["x","y"]`" ;-)
11:38:11 --- mode: glguy set +v dataN
11:39:53 <dmj`> dmwit: back to square one :) 
11:40:04 <int-e> dmwit: well you can write a preprocessor
11:40:16 <int-e> also, has anybody suggested template haskell?
11:40:52 <dmj`> int-e: hmm, could do a quasiquoter
11:41:21 <int-e> dmj`: I know I brought it up... but please don't :)
11:41:27 <dmj`> myList = [list| a b c d |]
11:41:30 <dmj`> int-e: too late
11:42:58 <int-e> > words "a b c d e"
11:43:01 <lambdabot>  ["a","b","c","d","e"]
11:43:07 <int-e> I have, on occasion, done that.
11:44:25 <dmj`> :t traverse Data.Text.readMaybe . words
11:44:26 <lambdabot> error:
11:44:26 <lambdabot>     Not in scope: ‘Data.Text.readMaybe’
11:44:26 <lambdabot>     No module named ‘Data.Text’ is imported.
11:44:40 <dmj`> :t traverse Text.Read.readMaybe . words
11:44:41 <lambdabot> Read b => String -> Maybe [b]
11:45:31 <dmwit> dmj`: Now use that to get a `Maybe [Either () ()]`. ;-)
11:46:22 <dmwit> % :m + Unsafe.Coerce
11:46:23 <yahb> dmwit: 
11:46:29 <dmwit> % unsafeCoerce () :: Either () ()
11:46:29 <yahb> dmwit: 
11:46:35 <dmwit> hmmm... =)
11:46:56 <int-e> that.... ought to crash
11:47:18 <dmj`> :t traverse (Text.Read.readMaybe :: String -> Maybe (Either () ())) . words
11:47:19 <lambdabot> String -> Maybe [Either () ()]
11:47:37 <dmwit> Maybe! Or maybe you get lucky and the right thing appears in memory where () was.
11:47:38 <int-e> % unsafeCoerce (Just ()) :: Either () () -- may have a chance
11:47:38 <yahb> int-e: 
11:47:45 <int-e> or not.
11:47:47 <int-e> % Just 1
11:47:47 <yahb> int-e: 
11:47:47 <dmwit> dmj`: It's got the right type... but does it got the right behavior?
11:47:55 <dmwit> % :q
11:47:55 <yahb> dmwit: 
11:47:57 <dmwit> % 3
11:47:57 <yahb> dmwit: 
11:48:01 <dmwit> % :}
11:48:02 <yahb> dmwit: syntax: :module [+/-] [*]M1 ... [*]Mn
11:48:04 <int-e> % print 3
11:48:04 <yahb> int-e: 3
11:48:07 <dmwit> % 3
11:48:07 <yahb> dmwit: 3
11:48:18 <dmwit> % :m + Unsafe.Coerce
11:48:18 <yahb> dmwit: 
11:48:23 <dmwit> % unsafeCoerce () :: Either () ()
11:48:23 <yahb> dmwit: Left [Segmentation fault]
11:48:32 <dmwit> yay
11:48:43 <int-e> % :m + Unsafe.Coerce
11:48:44 <yahb> int-e: 
11:48:48 <int-e> % unsafeCoerce (Just ()) :: Either () ()
11:48:49 <yahb> int-e: Right ()
11:49:27 <lavalike> eep!
11:49:42 <dmwit> dmj`: Oh, dang, I want to change my challenge. I want it to be `Either Int Int` instead of `Either () ()`.
11:50:24 <dmwit> I thought I was being clever by choosing the minimal thing, but instead I left myself open to loopholes.
11:51:25 <dmwit> int-e: (Luckily, getting a `Just 0` from `read` will still run into the same problem I'm trying to get dmj` to notice about getting a `Right 0` from it.)
11:52:43 <int-e> > (traverse Text.Read.readMaybe . words $ "Left(1) Right(1)") :: Maybe [Either Int Int]
11:52:45 <lambdabot>  Just [Left 1,Right 1]
11:52:56 <dmwit> oh, well done
11:53:12 <dmwit> v. sneaky
11:53:30 --- mode: glguy set +v yev
11:54:26 <dmwit> int-e++
11:55:25 <dataN> > read "Left(1)" :: Either Int Int
11:55:27 <lambdabot>  Left 1
11:56:36 <dmj`> > traverse readMaybe (words "()”)
11:56:38 <lambdabot>  <hint>:1:32: error:
11:56:38 <lambdabot>      lexical error in string/character literal at end of input
11:56:45 <dmj`> > traverse readMaybe (words "()")
11:56:47 <lambdabot>  error:
11:56:47 <lambdabot>      • Variable not in scope: readMaybe :: String -> f b
11:56:47 <lambdabot>      • Perhaps you meant ‘Text.Read.readMaybe’ (imported from Text.Read)
11:57:01 <dmj`> > traverse Text.Read.readMaybe (words "()")
11:57:03 <lambdabot>  Just [()]
12:04:11 <dataN> % unsafeCoerce True :: Either () ()
12:04:11 <yahb> dataN: Right [Segmentation fault]
12:04:20 <dataN> % unsafeCoerce False :: Either () ()
12:04:21 <yahb> dataN: Left [Segmentation fault]
12:06:04 <hpc> that's a new one
12:07:32 <lavalike> % unsafeCoerce Right (0,[]) :: [Int]
12:07:33 <yahb> lavalike: [283483237968]
12:08:51 <lavalike> I guess it's nondet
12:08:54 <lavalike> % unsafeCoerce Right () :: [Int]
12:08:54 <yahb> lavalike: [139760056100624[Segmentation fault]
12:08:58 <lavalike> % unsafeCoerce Right () :: [Int]
12:08:59 <yahb> lavalike: [140503658432272]
12:21:15 <absence> is there a way to test the text written to stdout by an io action in hspec?
12:22:12 <dstolfa> absence: `shouldBe`
12:22:19 <dstolfa> oh, written to stdout
12:22:23 <dstolfa> not sure
12:22:24 <dstolfa> :/
12:22:49 <dstolfa> absence: can't you get the string before it's being written out?
12:23:04 <byorgey> maybe it's written out in lots of tiny pieces
12:23:27 <cocreature> absence: there are some packages for redirecting and capturing stdout, e.g., https://hackage.haskell.org/package/system-posix-redirect-1.1.0.1/docs/System-Posix-Redirect.html
12:23:41 <cocreature> there’s nothing built into hspec directly afaik
12:24:32 <dstolfa> cocreature: i mean yeah, you can set the "new" stdout in *nix, but it's the nicest way to do it. sometimes you just don't have a choice though
12:25:08 <absence> hmm, i'm on windows, so i guess i'll have to figure something else out
12:25:42 <dstolfa> s/the nicest way/not the nicest way/
12:25:55 <dstolfa> absence: i'm sure windows has something similar you can hook into
12:26:06 <dstolfa> maybe not already built in hackage, but you can probably just kind of do it yourself
12:42:11 <tsaka__> Im having some issues retrieving an element from a hashmap the record of a state monad ...
12:42:12 <tsaka__> https://lpaste.net/7912049471196758016
12:42:34 <tsaka__> (that's with the microlenses library which supposedly is a strict subset of the usual lens library)
12:43:30 <cocreature> tsaka__: did you mean to use mapM instead of mapM_ in line 30?
12:43:43 <cocreature> mapM_ will give you back a "m ()" so "event" will be of type "()"
12:44:11 <tsaka__> cocreature: Uhm yes. Still errors though -- same line
12:44:28 <tsaka__> Expected type: StateT EventGen Identity Event          Actual type: StateT EventGen Identity (t0 b0)
12:44:57 <cocreature> :t mapM
12:44:58 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:45:07 <cocreature> event will be of type "t b"
12:45:20 <cocreature> apparently Event is not of that form (which would only be possible if it’s a type synonym)
12:45:35 <cocreature> tsaka__: maybe you want "fmap" instead of "mapM"?
12:46:03 <tsaka__> Yep fmap that's it
12:46:06 <benzrf> haha
12:46:09 <tsaka__> that worked, thank you
12:52:17 <Ariakenom> replace ghc type errors with cocreature live chat
12:54:29 <dmj`> the cocreature irc ghc plugin
12:57:07 <cocreature> I should sell subscriptions for that
12:59:09 <dmj`> cocreature commentary on type errors for premium members
12:59:23 <dmj`> I’d pay
13:01:14 <tdammers> make that a GHC plugin
13:01:41 <tdammers> oh wait you just said exactly that
13:03:01 <dmj`> ¯\_(ツ)_/¯
13:08:10 <dmwit> lavalike: You probably wanted `unsafeCoerce (Right (0, [])) :: [Int]` (note the extra parentheses). But it probably still won't do what you're hoping for, because `(,)` introduces an extra layer of indirection that `(:)` doesn't have.
13:09:49 <benzrf> ok i dont have any context, why the fuck is unsafeCoerce being thrown around
13:09:58 <lavalike> dmwit: couldn't come up with a type whose second constructor has 2 slots :)
13:11:57 <dmwit> Yeah, I'm having trouble thinking of one, too. =)
13:12:02 <dmwit> benzrf: shitposting
13:13:55 <benzrf> shiptoasting
13:19:45 <xacktm> is it possible to remove the lambda or is it just obfuscating? ((fromMaybe "" . (\s -> f s a b c)) <$> (i .: "field")
13:20:25 <hpc> both ;)
13:20:48 <xacktm> thougth so heh
13:20:49 <dmwit> ?pl \s -> f s a b c
13:20:49 <lambdabot> flip (flip (flip f a) b) c
13:21:03 <dmwit> flippin' hell
13:21:06 <xacktm> ah flip
13:21:11 <xacktm> lol
13:21:16 * dmwit high fives xacktm
13:21:33 <xacktm> :D
13:22:32 <xacktm> well thanks, I guess I'll keep it
13:23:33 <fendor> > let flip4 f a b c d = f d a b c 
13:23:35 <lambdabot>  <no location info>: error:
13:23:35 <lambdabot>      not an expression: ‘let flip4 f a b c d = f d a b c ’
13:23:45 <fendor> @let flip4 f a b c d = f d a b c 
13:23:46 <lambdabot>  Defined.
13:24:41 <fendor> i suppose, such a function is considered to be unethical? 
13:28:48 <geekosaur> more insanity-inducing
13:30:36 <fendor> well, a lot of haskell code is insanity inducing :P
13:32:00 <dmwit> Nothing wrong with it. It's just too specialized to be worth defining. The lambda is perfectly readable.
13:32:01 <koz_> Where did the 'use X in anger' meme come from?
13:33:21 <dmwit> https://english.stackexchange.com/q/30939/77295 says from the military. Shots fired in anger are different from shots fired in practice.
13:33:47 <texasmynsted> if I want ghci in color, is the best way, this way? --> https://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
13:34:09 <koz_> dmwit: Ah, OK. It's just that I saw Sandy Maguire use it a bunch of times, thought it was a him thing, and then I heard Edward use it in a talk, so I was wondering if it's a Haskell meme or something else.
13:34:11 <dmwit> texasmynsted: Why stop at color? https://github.com/gibiansky/IHaskell
13:34:13 <koz_> Thanks for the definitive source.
13:34:35 <koz_> Also, would it be correct to refer to a monoid as a 'pointed semigroup'?
13:34:55 <dmwit> semigroup with identity would probably be clearer
13:34:58 <geekosaur> also it kinda predates "meme" having crawled out of the depths of dictionaries
13:35:09 <dmwit> "pointed" usually just means you pick one with no special laws about which one you picked.
13:35:36 <koz_> dmwit: Ah, OK. It's just that whenever I've heard of 'pointed X', the thing you pick _does_ have additional rules.
13:35:42 <koz_> s/does/did/
13:35:46 <mnoonan> you at least usually assume functions take points to points
13:36:13 <texasmynsted> I just want color in command line ghci
13:39:08 <texasmynsted> hmm. maybe this is actually the correct solution https://wiki.haskell.org/GHCi_in_colour
13:40:29 <dmwit> koz_: Hm. Like what?
13:41:30 <dmwit> The only two examples I know of are pointed sets and pointed spaces, neither of which demand anything special of their point.
13:42:26 <koz_> dmwit: The most recent thing I remember is Edward's talk about monad homomorphisms (https://www.youtube.com/watch?v=YTaNkWjd-ac) discussing MPointed and MFunctor.
13:42:38 <koz_> Although maybe I just assumed that.
13:43:29 <dmwit> Okay. I'm not going to watch more than an hour of video to find what you're talking about.
13:43:34 <texasmynsted> seems odd that there is -fdiagnostics-color, but not normal syntax coloring 
13:44:48 <koz_> dmwit: It's fine - thanks for correcting me on that one.
13:45:05 <koz_> I'll just remember from now on that 'pointed X' doesn't assume anything special about their points.
13:59:55 <ocharles> Anyone have a trick to get GHC to accept this program without a type annotation? https://gist.github.com/ocharles/11df5069f254c60ea6a51d958648ecef
14:00:07 <ocharles> I'd like it to infer that c ~ MonadIO, but it won't, despite knowing that must be true
14:06:41 <dataN> how would that work? c could be anything
14:07:39 <ocharles> there are plenty of (* -> *) -> Constraints that it *could* be, but MonadIO would be the "smallest", in some sense
14:08:00 <Ariakenom> theoretically defaulting could work
14:08:10 <dstolfa> unless someone implemented a smaller one? :-)
14:08:14 <Ariakenom> but yes it's incorrect that it must be true
14:08:27 <ocharles> in the same sense that `foo = liftIO (putStrLn "Hello")` infers as foo :: MonadIO m => m ()
14:09:06 <dataN> so you want to kind of infer the constraint so that it can be passed as an argument?
14:09:17 <dataN> so you want to kind of infer the constraint so that it can be passed as an argument?
14:09:48 <dataN> Ariakenom: what defaulting?
14:09:59 <ocharles> dataN: yea
14:10:20 <ocharles> my only option so far is TypeApplications and saying @MonadIO
14:10:23 <ocharles> not awful, but a shame
14:10:33 <geekosaur> Ariakenom is hoping that 'default' can be expanded to constraints instead of types
14:10:54 <MarcelineVQ> error is a little vague to me, isn't it successful in deducing c to be MonadIO ? And it wants to know what  MonadIO m  you're going to use? Isn't this a monomorphism thing?
14:11:23 <threewood> What's 'a'?
14:11:43 <threewood> Is it supposed to be    c m => m a?
14:12:06 <dataN> it would just get a forall from the typechecker no?
14:12:35 <dataN> forall a. Constrained MonadIO a
14:12:52 <threewood> Yeah but does it mean
14:12:57 <threewood> what is it supposed to mean
14:13:04 <geekosaur> hm, isn't the problem here that ghc refuses to infer those types?
14:13:35 <geekosaur> (this one is inferrable but nobody wants to add the extra complexity iirc)
14:14:56 <dataN> yeah, that would not do what wanted which is equivalent to creating a dictionary from an inferred constraint 
14:15:46 <ocharles> MarcelineVQ: the monomorphism restriction flags don't change anything here
14:16:01 <MarcelineVQ> Yes it doesn't seem to affect anything
14:17:13 <dataN> newtype Constrained c m a = Constrained (c m => m a)
14:17:20 <dataN> Couldn't match type `a' with `()'         `a' is untouchable
14:17:49 <dataN> maybe its a similar situation for m
14:18:58 <ocharles> newtype Constrained c m a = Constrained ( c => m () ) also doesn't give much
14:20:27 <ocharles> My guess is this can't be done
14:27:57 <dataN> (p => a) -> p
14:32:10 <benzrf> you're doing existential types
14:32:36 <benzrf> oh wait no you arent
14:32:53 <benzrf> @let newtype Constrained p m a = Constrained (forall a. c m => m a) -- maybe?
14:32:55 <lambdabot>  .L.hs:170:53: error: Not in scope: type variable ‘c’
14:32:55 <lambdabot>      |
14:32:55 <lambdabot>  170 | newtype Constrained p m a = Constrained (forall a . c m => m a)
14:32:58 <benzrf> oop
14:33:02 <benzrf> @let newtype Constrained c m a = Constrained (forall a. c m => m a) -- maybe?
14:33:03 <lambdabot>  Defined.
14:33:06 <benzrf> :t Constrained
14:33:08 <lambdabot> forall k1 k2 (c :: (k1 -> *) -> Constraint) (m :: k1 -> *) (a :: k2). (forall (a1 :: k1). c m => m a1) -> Constrained c m a
14:36:02 <ocharles> Yea, that was tried above. It still can't infer c ~ MonadIO
14:36:25 <ocharles> Plus I do want m universally quantified, but that's something else
14:36:40 <ocharles> I'll live with needing an explicit type application, it's not the end of the world
15:52:36 <davr0s> whats the popularity curve of haskell these days
15:55:35 <pothepanda> should be high ?
15:59:13 <oak> Just out of curiosity I made a small Google Trends comparison: https://trends.google.fi/trends/explore?date=all&q=%2Fm%2F03j_q,%2Fm%2F03yb8hb,%2Fm%2F091hdj
15:59:50 <davr0s> i am bouncing, infrequently:
16:00:16 <davr0s> C++ (years of habit) <-> Rust  <->  Haskell (ok lets do it properly!)
16:00:24 <davr0s> i need to explain with a cyclical state diagram
16:00:57 <davr0s> writing haskell remains alluring, so much elegance in it
16:01:19 <davr0s> but then when i come to do practical things I gravitate backward
16:01:55 <hpc> try to make rust your default language instead of C++, maybe?
16:02:33 <davr0s> part of this process goes... "ok if i'm going to do it properly, lets use Haskell as the new thing and keep C++ for the C++-ey-stuff"
16:03:11 <davr0s> 1st world problems i know :)
16:04:44 <davr0s> i picked it up again today , had great fun , perhaps i should force myself to learn some new part (like that state monad stuff.. I can't remember that) 
16:11:33 <davr0s> i seem to remember a reason being given why haskell prefers the opposite to F#'s  |> idea of piping e.g. "foo... |> bar.. |> baz..."   vs   foo .. $  bar ...  $ baz ...
16:12:15 <hpc> because what you actually prefer in haskell is foo . bar . baz
16:12:25 <hpc> which is the same order as function composition in math
16:21:26 <koz_> You can get something like F#'s with >>> from Control.Category.
16:21:32 <koz_> (specifically for functions)
16:22:12 <koz_> s/F#'s/F#'s |>/
16:22:31 <davr0s> hpc ok thanks,  last time i think the reason given was sometihng like "because it looks more like dragging lazy eval from the right" but your reason makes more sense.
16:34:25 <dmj`> davr0s: what kind of practical things do you hesitate to do in haskell, just curious
16:35:13 <Cale> davr0s: Well, also under lazy evaluation when you have something like f (g (h x)), it's really f which is evaluated first, and the as-yet-unevaluated expression g (h x) is effectively substituted into its body
16:35:38 <davr0s> whenever i dabble with it , i enjoy 'generating'  something, but as soon as i come to read files (e.g. getting a 3d model in..)  in I start being irationally uneasy... it's not like it seems 'impossible', it's just a weird sensation
16:35:54 <Cale> (actually, references to that expression are substituted, such that if any one of the occurrences is evaluated, the work is shared between them)
16:36:21 <Cale> Really, reading files in Haskell is not so different from how you'd do it in any imperative language.
16:36:22 <davr0s> i guess it might pass if i actually force myself a few times.. instead of just binning it for safety
16:37:16 <Cale> There are some funky lazy-I/O things you can use, but if you stick to strict ByteString and Text, everything will behave as you'd expect.
16:37:55 <hpc> you should also learn parsing
16:39:12 <dmj`> davr0s: before reaching for a streaming library (or some other complicated API), try reading files with the bytestring library, using Data.ByteString.Lazy.readFile, and potentially using the binary library. You can go really far with just the boot packages. 
16:39:15 <Cale> (lazy I/O can be convenient, particularly for small scripts where you want to read in and process a small number of large files, but it is rather strange, since using it causes I/O to be triggered by *evaluation* which is unusual in Haskell generally.)
16:39:31 <davr0s> right there's a big case for working through some new part of the ecosystem rather than just fudging it with basics. (r.e. lazy io, i gather lazyiness genearlly helps you right)
16:39:56 <Cale> Lazy I/O and lazy evaluation are pretty different things.
16:40:09 <davr0s> lazy eval is what i meant in that statement
16:40:28 <davr0s> i did pick up that you refer to something else i havent' touched yet
16:40:33 <Cale> But yeah, lazy I/O wouldn't exist if we didn't also have lazy evaluation
16:40:56 <davr0s> how many of you use haskell in a day job, in anger
16:41:00 <Cale> I do
16:41:09 <davr0s> here's me just trying to amuse myself in new ways really
16:41:18 <Clint> depends which day it is
16:41:23 <Cale> I refuse to program in anything else.
16:41:51 <dmj`> Cale: you’ve earned that right :) 
16:42:05 <davr0s> I'd have needed C or C++ as the main language in any work i did, but plenty of tasks around it could have been done in haskell
16:43:35 <dmj`> davr0s: Haskell on the job is great if you keep it basic. It doesn’t suddenly mean you don’t have to abide by good software engineering principles like keep-it-simple stupid, separation of concerns, single responsibility principle, etc. Resist premature abstraction or you can code yourself into a corner quickly.
16:44:23 <davr0s> hah i was just looking at what i was writing there and thinking "ok what will that look like to me 8weeks from now.."
16:44:25 <dmj`> davr0s: you should try using hsc2hs to call into your C and/or C++ code, Haskell is good glue code for systems that usually always works.
16:44:30 <Cale> Yeah, it takes some time to develop a good sense of taste for abstraction.
16:44:56 <Cale> There *are* problems where all the fancy type system features begin to shine, but they're less common than you'd think
16:44:57 <davr0s> dmj` plenty of work i did involved just conditioning data that c++ would then use.
16:45:05 <Cale> Very plain Haskell will take you a very long way
16:45:12 <davr0s> so i could have used anything that can read and write a file.
16:47:45 <dmj`> Cale: preach, I’m tired of the hype trains, streaming libraries, lens craziness, GADTs indexed by promoted sums. Give me alex, happy, hsc2hs, bytestring, text, mtl and vanilla ADTs
16:48:02 <dmj`> davr0s: are you just exposing a C interface from the C++ (i.e. extern C {  } )
16:48:29 <davr0s> (there is strange nostalgia as well as it being utterly fresh i.e. (i) before i ever discovered OOP i basically did use the equivalent of sum-types in my very earliest asm work (a little tag that says what following thing is) and (ii) relying more on function names than IDE object autocomplete takes me back to early C coding)
16:48:57 <Cale> dmj`: I say this, but as we speak, I've been working on a library which defines a datatype of kind (((* -> *) -> *) -> *) -> (* -> *) -> *, where the first parameter is expected to be a GADT indexed on functor-parametric container types, lol.
16:49:13 <davr0s> dmj` right now i'm not even thinking about interfacing C or C++ and haskell - just doing something that involves transforming data - it can interact through files 
16:49:19 <Cale> and there are JSON instances for this
16:49:20 * dmj` *face-palms hard*
16:49:22 <Cale> lol
16:49:39 <Cale> so you can imagine the level of constraint-hackery required to make that all work
16:49:54 <Cale> but it really is getting us somewhere good
16:50:39 <dmj`> Cale: yea but you’re probably one of the only people I’d trust know that haha
16:51:31 <dmj`> davr0s: nice, yea lazy bytesting read file is your best friend, and if your data is predictable, you can use a binary instance and just decode it line by line (or whatever delimits your data). It’s struct packing at that point, and it can get real fast. 
16:53:07 <dmj`> davr0s: depends on your data though, what kind of data do you deal with
16:53:59 <davr0s> nothing big, it would load into memory in one go fine. just some 3d models , i was actually going to try writing an importer for "MagicaVoxel" format aswell
16:54:03 <Cale> All our apps have this same thing they need to do where we need to be able to aggregate information about what data the user is supposed to be looking at, and then on the backend, keep track of who is interested in what when data is updated. By working with types that are parameterised by a functor, we can plug in Proxy or (Const SelectedCount) (reference counting is important for efficiency on the frontend) to get something akin to 
16:54:03 <Cale> "blank forms" which are our queries.
16:54:25 <Cale> and then by putting in Identity, we get a type for the response
16:54:53 <Cale> and by putting in something like Map ClientKey, we can maintain many users' responses in a single structure
16:55:05 <davr0s> do you use it for web apps? ('response')
16:55:14 <Cale> yeah, this is for web applications
16:55:34 <Cale> Both our frontends (web and mobile) and backends are written in Haskell
16:55:44 <davr0s> wow
16:56:01 <davr0s> at which point i could inquire about haskell/emscripten or JS backends ..
16:56:05 --- mode: glguy set +v sevanspowell[m]
16:56:13 <Cale> We're using GHCJS and Reflex-DOM
16:56:29 <davr0s> webassembly is going to transform this too right
16:56:49 <sevanspowell[m]> Hey, is anyone familiar with how to create a PrivateKey from a String/File? I'm struggling to connect the dots. The closest I can find is the Read instance for PrivateKey, but that fails and doesn't give me very good error messages.
16:56:49 <Cale> Yeah, it'll be really nice when there's a WebAssembly backend for GHC
16:57:30 <MarcelineVQ> Cale: seen https://github.com/tweag/asterius ?
16:57:32 <dmj`> davr0s: yea but that will take some time, things like garbage collection and concurrency still need to be spec’d and them implemented afaik. And the DOM spec too… again afaik
16:57:49 <Cale> So anyway, to finish the story I was telling there, we have these functor indexed containers, and then we wanted a way to aggregate an arbitrary bunch of those, and not have to write a dozen or so different instances
16:57:55 <dmj`> sevanspowell[m]: can you paste your code? 
16:58:25 <sevanspowell[m]> ```
16:58:38 <MarcelineVQ> in a pastebin of some kind like gist
16:58:45 <Cale> So we have a functor-indexed container type (which I call a Vessel) which is intended to be keyed by a GADT, where the index of the GADT tells you what sort of functor-indexed container lies at that key.
16:58:53 <Cale> (which might be another Vessel)
16:59:01 * sevanspowell[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/aDcIUuCzeIyosQwfkyyLZARR >
16:59:08 <sevanspowell[m]> integration-tests: Prelude.read: no parse
16:59:14 <Cale> So this lets us have dynamically-updating live applications, and nest their communication protocols neatly.
17:00:12 * sevanspowell[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/HjFxZLBpIlvqVVFNngRPtXri >
17:00:45 <Cale> and you get JSON and all sorts of algebraic instances (we need the thing to be a Group in some cases)
17:00:49 * sevanspowell[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/KNewCUUQFxMdglUohGnndowD >
17:01:07 <Cale> sevanspowell[m]: You're sending long messages and matrix is mangling them into links...
17:01:52 <geekosaur> what I woudl wonder is whether it's obeyingthe expectations for read/show
17:02:30 <Cale> sevanspowell[m]: Which library are you using for PrivateKey?
17:02:51 <sevanspowell[m]> cryptonite
17:02:53 <geekosaur> which means you'd want to read . show $ unlines ..., because it would want a String in source format
17:03:26 <Cale> cryptonite's Read instance for PrivateKey is just a derived one
17:03:34 <Cale> it reads Haskell source code for a record
17:03:40 <Cale> http://hackage.haskell.org/package/cryptonite-0.25/docs/src/Crypto-PubKey-RSA-Types.html#PrivateKey
17:05:11 <sevanspowell[m]> Ah yes, that makes sense Cale . PrivateKey does have a public constructor I can use, but I don't know how to map between my private key file and the fields expected by the constructor.
17:05:38 <Clint> sevanspowell[m]: what's the format of your private key file?
17:07:28 <sevanspowell[m]> Just the typical key generated from a ssh-keygen, I'll grab the exact format in a sec.
17:08:48 <hpc> a read instance is never going to give you a private key data structure from an openssl string
17:08:56 <hpc> it cannot be done, the key could have a password
17:09:10 <hpc> maybe try http://hackage.haskell.org/package/HsOpenSSL-0.11.4.15/docs/OpenSSL-PEM.html
17:10:03 <Clint> sevanspowell[m]: 
17:10:03 <Clint> TODOS NUESTROS PRODUCTOS SON ELABORADOS SIN GLUTEN*
17:10:05 <Clint> er
17:10:09 <Clint> sevanspowell[m]: https://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.7/docs/Crypto-PubKey-OpenSsh.html
17:10:16 <joebobjoe> hi I have a data compression/encoding question. given raw binary data, I need to encode it as a valid hostname following the rules of https://tools.ietf.org/html/rfc1123. I have never developed a coding scheme before? how would I go about deriving an efficient coding scheme
17:10:55 <joebobjoe> hostnames can contain the chars A-Z a-z 0-9 and hyphen. hyphen can only be internal
17:11:01 --- mode: glguy set +v amackillop
17:11:21 <joebobjoe> with a strange constraint like that, I know I can just not use hyphens. but is there a more efficient coding scheme that can fully pack the bits?
17:11:51 <hpc> joebobjoe: naively, base26
17:12:02 <Cale> or base 36
17:12:13 <hpc> i don't think you can start a domain name with a number either
17:12:18 <Cale> ah
17:12:24 <joebobjoe> you can accortding to that rfc
17:12:29 <hpc> although maybe i am wrong, i erred on the side of safety
17:12:31 <hpc> ah
17:12:33 <joebobjoe> to the naïve implementation is best?
17:12:54 <hpc> if you really don't feel like coding anything difficult, base16 but map digits to
17:12:55 <Cale> I wouldn't bother, but I'd really want to ask what I'm doing with my life
17:12:59 <hpc> > take 16 ['a'..]
17:13:01 <lambdabot>  "abcdefghijklmnop"
17:13:07 <joebobjoe> I was hoping I wouldn't have to invent some complicated state machine and have to learn everything about the theory of computation and coding theory
17:13:10 <geekosaur> 3com.com thouht differently, ad made it stick
17:14:05 <Cale> joebobjoe: Why are you encoding arbitrary data in the form of domain names?
17:14:20 <Cale> Hijacking DNS for communication purposes?
17:14:34 <joebobjoe> I'm just wondering, given two grammars, is there a generic method I can use to derive an efficient coding scheme that is as space efficient as possible]
17:15:09 <hpc> joebobjoe: if you can enumerate the valid strings of both grammers, it's pretty trivial
17:15:19 <hpc> zip (enumerate grammar1) (enumerate grammar2)
17:15:35 <sevanspowell[m]> Yeh, that definitely makes sense hpc . So the missing link is that I needed to recognize the format of the text file. Thanks for your help everyone.
17:21:07 <joebobjoe> hpc, are you saying I can actually do this? just type in the two grammars and I automatically have an encoder?
17:21:12 <joebobjoe> I'm guessing it is not that easy
17:21:30 <joebobjoe> new to haskell, too. so I don't understand how zipping grammars would help me unless you are trying to show something conceptually
17:22:02 <dmj`> joebobjoe: if you use alex, it will construct (and merge) finite state machines for you, and it can operate on ascii data
17:22:25 <dmj`> joebobjoe: you just define the regular expressions (and character sets), then alex generates a haskell file to do it for you, that’s how GHC works too
17:22:26 <joebobjoe> what? this actually exists?
17:22:32 <Cale> joebobjoe: That's a very impractical suggestion: he's saying just enumerate all the strings of both grammars and keep looking until you find the string you wanted to translate
17:22:54 <dmj`> joebobjoe: yes, I wrote one for graphql, it works best for well-defined grammars with lexical specs
17:23:02 <joebobjoe> Cale, OH! I see thanks
17:23:03 <dmj`> joebobjoe: and its faster than monadic parser combinators
17:23:36 <joebobjoe> dmj`, how would parser combinators help me encode data form one format to another? I'd still have to devise a coding scheme
17:26:35 <dmj`> joebobjoe: It depends on what you’re doing. Monadic parser combinators are nice because it conflates lexing and parsing together, so its convenient. It also allows for backtracking, alex is more well-suited for context free grammars, but also allows you to later state machines on top of each other (using codes). 
17:27:20 <dmj`> joebobjoe: I’m still confused about your problem, are you saying you have data and you need to encode it to the binary spec defined in this host RFC, or are you trying to parse a host from binary data
17:27:22 <dmj`> joebobjoe: or both
17:27:40 <joebobjoe> dmj`, encoding and decoding binary data into and out of a hostname
17:27:40 <dmj`> s/later/layer
17:27:44 <joebobjoe> I'm hiding data in a hostname
17:29:10 <joebobjoe> dmj`, would alex efficiently encode data in terms of speed?
17:29:24 <joebobjoe> does it guarantee bounds on the encoding/decoding operations?
17:29:30 <joebobjoe> complexity*
17:29:53 <dmj`> joebobjoe: alex is only for decoding into tokens, which can then be parsed into a grammar using happy. Encoding would something like pretty-printing
17:30:40 <dmj`> joebobjoe: you can also use readp/parsec/megaparsec, etc. with a stream of alex tokens (it’s just a list of matched and lexed binary data at that point)
17:30:44 <dmj`> @package bytestring-lexing
17:30:44 <lambdabot> http://hackage.haskell.org/package/bytestring-lexing
17:30:50 <dmj`> is helpful here too
17:31:15 <joebobjoe> dmj`, I'm not talking about developing a language-agnostic coding scheme to code binary data into a hostname
17:31:20 <joebobjoe> how would parsers help me here?
17:31:34 <joebobjoe> parsing != encoding as far as I know
17:32:03 <dmj`> joebobjoe: yes, I agree
17:32:10 <dmj`> joebobjoe: so maybe you should show me input and expected output
17:35:43 <joebobjoe> dmj`, input: binary, output: rfc 1123 hostname
17:35:49 <joebobjoe> to encode
17:35:53 <joebobjoe> then opposite to decode
17:36:28 <joebobjoe> 0xfeefe -> host35u1-523f
17:36:38 <joebobjoe> the later is a valid hostname and can be sent over dns
17:37:06 * dmj` reads spec
17:37:10 <dmwit> joebobjoe: I actually answered a SO question about this that you may find interesting.
17:37:14 <dmj`> first off, I’m sure someone has done this
17:37:54 <dmwit> https://stackoverflow.com/q/23923229/791604
17:38:07 <dmwit> You may also like the "Every Bit Counts" paper (linked in my answer there).
17:38:14 <joebobjoe> they have. this is a project for school. I am tunneling http over dns. I know I can just use base**, but I am curious how much more space efficient I can get the messages if I use the full grammar of the hostname
17:38:20 <joebobjoe> since dns packets are limited in size
17:38:30 <joebobjoe> thanks dmwit 
17:39:46 <joebobjoe> I don't even know what the godel number is
17:39:51 <joebobjoe> yup, just using base32
17:40:12 <joebobjoe> bookmarked the so question to understand hopefully at a later date
18:09:08 --- mode: glguy set +v sebastianrkg
18:09:52 <sebastianrkg> seemingly like it's not possible, but just to check--any way to run threadscope in a Windows environment to profile a Haskell application running inside WSL/Ubuntu for Windows?
18:09:58 <sebastianrkg> *seeming like
18:44:19 --- mode: glguy set +v sebastianrkg
18:56:29 <tcsiwula> Need some help on the best way to systematically approach resolving Haskell errors in a code base I just jumped into. Current error: Ambiguous type variable https://gist.github.com/tcsiwula/683ad8e525e496e7b7da768c95e68471
19:20:30 <dmj`> was this discontinued? https://ghc.haskell.org/trac/ghc/wiki/ObjectiveC
19:24:51 <geekosaur> "Last modified 4 years ago"
19:25:11 <dmj`> sure, but plenty of things are like that in ghc, but they still got implemented
19:25:55 <geekosaur> and apple has been making things more and more difficult; even getting plain ghc to work right on recent OS X has required massive amounts of work
19:26:24 <geekosaur> 8.6.1 claims to have finally solved the load commands table issue. (now I expect apple to break it again)
19:27:21 <dmj`> Ugh, apple is a problem, wish carbon never got discontinued. Having a C API to cocoa would have been nice. Needing XCode is really clunky too.
19:48:59 <dmwit> If it were possible to systematically resolve errors, you'd be out of a job.
20:04:30 <dmj`> dmwit: when you put it that way :) 
20:13:20 --- mode: glguy set +v largerobot
20:30:40 * dmj` wonders why the ghc api can’t be used in ghci 
20:33:17 * geekosaur wonders if it's reentrant
20:33:35 <geekosaur> suspect it's not, there's some magic globals (contemplate unsafeDynFlags)
20:33:40 <geekosaur> I think thats the name
20:34:04 <geekosaur> and ghci is itself based on ghc-api
20:40:48 <MarcelineVQ> dmj`: can't be used?
20:41:14 <MarcelineVQ> adapting the example at https://wiki.haskell.org/GHC/As_a_library works just fine in ghci
20:41:27 <dmj`> MarcelineVQ: well, it shows up as hidden in my ghc-pkg list
20:42:19 <MarcelineVQ> Oh you're not sure how to have ghci be aware of the package? dunno, I cheated via  stack ghci --package ghc
20:42:39 <maerwald> what effect does this have https://lpaste.net/888022434484060160 ...will it compile the current local project with O0 or O2?
20:43:42 <dmj`> MarcelineVQ: oh! guess I just needed to be explicit `ghci -package ghc` works, but `ghci` alone does not
20:43:43 <dmj`> https://gist.github.com/dmjio/bc97a1d4ead4e97b99c149bc625f0a11
20:46:27 <geekosaur> ghc api package is hidden byd efault
20:46:34 <geekosaur> you can ghc-pkg unhide it
20:47:27 <dmj`> ah, well I’m a up a creek since my ghc-pkg list is stuck in the /nix/store, cannot mutate it
20:49:01 <geekosaur> there's probably some nix rune that will do it, but I'm not very up on nix details
20:51:45 <jackdk> dmj` what is the package name of the ghc api? I was able to do `import Annotations` from a `ghci -package ghc`
20:52:06 <jackdk> within the following nix-shell call: `nix-shell -p 'haskellPackages.ghcWithPackages(p: [p.ghc])'`
20:52:14 <dmj`> jackdk: yea that looks right
20:52:53 <dmj`> jackdk: add —command to that nix shell call
20:52:58 <jackdk> oh I see, we're back up to where you were.
20:53:04 <dmj`> does ghc show up twice
20:53:18 <dmj`> It’s a boot package so it might be null in nixpkgs
20:53:27 <jackdk> it's in `hackage-packages.nix`
20:54:06 <jackdk> shrug
20:54:36 <dmj`> jackdk: are you on osx?
20:54:55 <jackdk> GNU/nixos
20:55:55 <dmj`> jackdk: oh, but can you expose it
20:56:00 <dmj`> it shouldn’t let you expose it
20:56:30 <dmj`> `ghc-pkg expose ghc`
20:57:19 <jackdk> yep, same here.
20:58:11 <geekosaur> you can drop a file that tells nix-shell to do that -p
20:59:14 <jackdk> because it's a boot package the -p changes nothing afaict, and knowing how to expose the package is beyond my ken
20:59:37 <jackdk> maybe ask in #nixos?
21:00:23 <dmj`> It’s not possible to mutate it unless you change the way the package is constructed in Haskell-modules
21:00:39 <dmj`> There might be a flag to override and expose it
21:00:57 <dmj`> But once you’re in the shell there’s no changing it without compromising the store
21:14:32 --- mode: glguy set +v petrolifero[m]
21:28:37 <dmwit> maerwald: Perhaps test with a ghc-options: -DOPT=1 vs -DOPT=2 or something.
21:28:44 <dmwit> computer *science*
21:30:49 --- mode: glguy set +v JJ21
21:37:20 <fresheyeball> hey out there
21:37:34 <fresheyeball> I am trying to parse a [(k,v)] with Data.Configurator
21:37:45 <fresheyeball> there is a Configured instance for lists
21:37:51 <fresheyeball> and one for tuples 
21:38:02 <fresheyeball> but I have no clue what a tuple looks like in configurator syntax
21:41:23 <jle`> fresheyeball: really the documentation should tell this
21:41:35 <fresheyeball> jle`: it doesnt though
21:41:37 <jle`> but if you look at stackage docs they have links to source in the instance list https://www.stackage.org/haddock/lts-12.10/configurator-0.3.0.0/Data-Configurator-Types.html#t:Configured
21:41:51 <jle`> fresheyeball: ah yeah i meant that in an exasparated "sigh, documentation is supposed to be used for this, but it isn't"
21:42:05 <jle`> unfortunately haddock linking is a bit weird too and the source link goes to the wrong module
21:42:21 <jle`> but it does say "Defined in module ..." at least, for that instance
21:42:28 <jle`> ideally documentation should specify this, heh
21:42:32 <fresheyeball> https://github.com/bos/configurator/blob/master/Data/Configurator/Instances.hs#L110
21:42:41 <jle`> you shuold always document your instances if they aren't the only possible instance
21:42:59 <maerwald> dmwit: I cannot follow
21:43:09 <jle`> fresheyeball: ah yeah that's it.
21:43:23 <jle`> fresheyeball: it looks like it's basically supposed to be a list
21:43:31 <jle`> and the first item in the list is the first field, the second item is the second field
21:45:43 <koz_> When I look at the Foldable laws, everything seems to be defined based on foldMap. However, no laws seem to specify what foldMap should be. How come this is the case?
22:01:11 <fresheyeball> well this is very annoying
22:01:26 <fresheyeball> no matter what I seem to try, the [] is not parsing to a tuple
22:01:57 <jle`> koz_: it's a fundamental issue with Foldable, in that there are no actual laws
22:02:39 <jle`> koz_: however, there are some well-defined laws for Traversable, and if a type is an instance of both, foldMap should be foldMapDefault, which respects Traversable laws
22:02:59 <jle`> koz_: for non-Traversable Foldables however, there isn't any satisfactory way to rigorously describe what foldMap should be
22:03:40 <jle`> Foldable has been called a classic example of the ad-hoc typeclass
22:06:27 <jle`> koz_: in an informal sense foldMap is like concatMap over "every item in a container"
22:06:55 <jle`> s/concatMap/mconcat
22:10:11 <jle`> if a type is Traversable however, you do get some interesting properties you can enforce.  for example, foldMap is only allowed to traverse each element at most once
22:10:25 <jle`> but it doesn't enforce anything about order
22:13:23 <koz_> jle`: OK, thanks. I guess that's what the Haskell Wikibooks article means when it says that Foldable is 'both principled and general-purpose in that it has no laws of its own'.
22:13:53 <jle`> however i think the docs would probably benefit from an informal description of expectations of foldMap
22:14:14 <jle`> hm, docs for foldMap do say this
22:25:28 <fresheyeball> can I check if a set is a subset of another set?
22:25:40 <koz_> :t isSubsetOf
22:25:41 <lambdabot> error:
22:25:41 <lambdabot>     • Variable not in scope: isSubsetOf
22:25:42 <lambdabot>     • Perhaps you meant one of these:
22:25:59 <fresheyeball> koz_: thanks
22:26:12 <koz_> fresheyeball: http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html#v:isSubsetOf
22:26:27 <koz_> There's an analog for HashSet if that's what you're using.
22:39:55 <koz_> Also jle`: Is there anything reasonably natural that is Foldable and a Functor, but _not_ Traversable?
22:46:04 <c_wraith> koz_: sure.   data Repeated a = Repeated Int a  -- representing n copies of the same value.  It can have perfectly good Functor and Foldable instances, but not Traversable
22:49:02 <koz_> c_wraith: Oh, OK. Yeah, I see that.
22:55:23 <benzrf> ooh. neat
22:55:44 <koz_> benzrf: Yeah, it took me a while to realize why, but yeah, that's pretty clever.
23:13:40 <ktonga> hi, have a question, is there a way to map the result of a multi arg function? something like `(a -> b -> c) -> (c -> d) -> a -> b -> d`
23:14:22 <dminuoso> :t (.) . (.)
23:14:23 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
23:14:32 <cocreature> please don’t actually use that
23:14:44 <ktonga> a lambda is preferred?
23:14:52 <cocreature> imho yes
23:15:04 <dminuoso> ktonga: It depends on your use case really. I name this combinator (.:) and use it sometimes.
23:15:21 <ktonga> it's a pitty coz i need the same args but just to apply a transformation on the result :(
23:16:08 <dminuoso> Though Ive come to prefer (fmap . fmap) because its a bit easier for me to read :)
23:16:24 <ktonga> i have a function that takes exactly what i get from a servant routing but returns an IO so i only need to liftIO to Handler
23:17:43 <cocreature> use a lambda or if you find yourself wanting to do this more than once define a lifted version of that function
23:42:42 <Zemyla> > (ord maxBound + 1) / 32
23:42:44 <lambdabot>  error:
23:42:44 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
23:42:44 <lambdabot>      • In the expression: (ord maxBound + 1) / 32
23:42:50 <Zemyla> > (ord maxBound + 1) `div` 32
23:42:52 <lambdabot>  34816
23:56:44 <dminuoso> cocreature: Why do you dislike (.:) so much?
23:59:48 <cocreature> dminuoso: 1. it’s not sufficiently common that you can expect everyone to know it so you make it harder for people to understand your code 2. it doesn’t make the code that much shorter 3. I don’t think it aids readability 4. if you’re actually worried about readability I think you’re better off solving this another way, e.g., for the previous example of lifting an IO function, just define the
23:59:50 <cocreature> lifted function once and then use that
