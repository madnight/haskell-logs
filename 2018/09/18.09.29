00:27:56 --- mode: glguy set +v Valxxxxx
00:28:01 <Valxxxxx> Hello here
00:29:01 <Valxxxxx> Could anyone here help me with Fmt lib? I need to create a Buildable instance for [*] type, any ideas?
00:35:50 <cocreature> Valxxxxx: what exactly do you mean by “[*] type” here?
00:36:23 <Valxxxxx> the error is
00:36:27 <cocreature> types of kind [*] don’t have runtime values so presumably that’s not what you mean
00:37:10 <Valxxxxx> Could not deduce Buildable (cons [type2]))
00:37:54 <Valxxxxx> and cons is Cons a = Cons {unCons :: a}
00:38:03 <cocreature> please show us the code producing the error and the full error message in some pastebin site (e.g. github gist)
00:42:12 <mniip> shachaf, I wonder if there's a RuntimeRep variant we could use and a kind we could attribute to a special "unboxed" #-> arrow to get analogous results
00:43:59 <shachaf> Analogous what to what?
00:44:30 <mniip> did you miss the thing where we discussed unpacking uniformly represented closures into register tuples
00:45:45 <mniip> to differentiate between e.g (+) :: Int -> Int -> Int which is a static piece of code and can be passed as a simpler pointer; and  (x +) :: Int -> Int  which is a closure containing one free variable value
00:47:05 <mniip> so that not all partial applications create closures
00:47:18 <shachaf> I didn't see any of that.
00:47:22 <mniip> :(
00:48:23 <shachaf> That's what I get for reading a couple of lines and replying
00:49:05 <mniip> I guess I'ma concentrate the thoughts into some gist
00:52:25 <ggole> How does that avoid creating closures?
01:09:08 <mniip> shachaf, ggole https://gist.github.com/mniip/bf49d552f4deb7227f8133a80ce2f3aa
01:11:46 <ggole> Oh, I see. It's type level support for lambda lifting.
01:12:31 <ggole> mniip: I would be cautious, since lambda lifting is not always beneficial for performance
01:13:33 <mniip> ggole, not exactly
01:13:59 <mniip> rather type support for the haskell-implicit stg-explicit list of free variables
01:14:37 <ggole> But what you're suggesting is passing those free variables as arguments (eg, in registers)
01:15:08 <ggole> That's lambda lifting, or something very close to it
01:15:23 <ggole> (Unless I've misunderstood something.)
01:15:46 <mniip> I guess there's no difference between lambda lifting and passing a closure in unpacked form
01:19:36 <ggole> Being able to opt into it rather than have an optimiser guess where it might be helpful might be nice
01:20:14 <ggole> The thing about lifting is that it can harm performance by turning conditional loads that rarely occur into loads that always occur (eg, unspilling in order to populate an argument register)
01:21:05 <ggole> Not as much of an issue if the programmer is in the driving seat
01:33:05 --- mode: glguy set +v guest1234
01:47:50 <mniip> ggole, of course
01:48:07 <mniip> my current idea is an unboxed arrow type constructor
01:48:16 <mniip> so that you can explicitly specify the lambda lifted functions
01:49:04 <shachaf> I think an unboxed arrow would be nice in general.
01:53:45 <mniip> shachaf, maybe one day we can write explicitly allocation free code
02:17:07 <davr0s> i should measure, but if you build things by concatenating to the end of a link list... can that (through the power of lazy eval.. building a graph of ops - actualy still figure out turning it into a generative sequence  list1++list2... the demanding to consume from that node first evals 'list1' items, until there are no moren then evals 'list2' items..?
02:33:29 <immae> Hi everyone, I’m trying to figure out if there is a way to write this code in a better way : https://paste.ee/p/zWP4I i.e. having a kind of fold that would take in input a list of action (getLine's) rather than its result (l <- replicateM n getLine). I would have thought that foldM would do something like that, but it seems not. Did I miss something, or is this the way to do? (I’m still quite a beginner
02:33:31 <immae> in haskell, and now I’m trying to learn higher-level functions to write "cleaner" code. Please redirect me if I’m in the wrong channel)
02:49:13 <Ariakenom> :t sequence -- something like this immae ?
02:49:14 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:50:24 <Ariakenom> no I suppose not. I didn't understand the question
02:52:48 <immae> Ariakenom: I’m not sure that what I ask is feasible. In other words, would you have written the code I pasted this way or would you have used another higher-level function?
02:53:06 <immae> I don’t feel that sequence is what I’m looking for but I may be missing something
02:54:15 <Ariakenom> That looks good to me.
02:54:20 <immae> (the integrateToMap is a dummy function, the real one is more complicated, my question is about simplifying the "replicateM n getLine" + foldl)
02:54:21 <maerwald> anyone wants to test https://github.com/hasufell/ghcup
02:54:25 <immae> Ok thanks Ariakenom 
02:56:12 <immae> Ariakenom: how would you have done it if n was 10M and you didn’t want to read it all before "integrating" it to your map (for instance, because you would throw away some and end with a reasonnably-sized map)
02:57:53 <Ariakenom> I see. You want some higher order thingie where you can build the map while you read
02:58:19 <immae> yes
03:00:33 <Ariakenom> You can use foldM like you were thinking. something like foldM (\m _ -> getLine >>= integrateToMap m) [1..n]
03:03:01 <Ariakenom> There may be some laziness issue where you should force the map each iteration. I'm no expert though
03:03:17 <immae> Oh. Right, no, your solution is perfect
03:03:42 <immae> I mean, it’s what my head wanted but I couldn’t figure it out :)
03:05:14 <Ariakenom> I wouldn't call it simpler though. Seems a bit more complicated
03:05:38 <immae> Yes, but more suitable for the "big n" case
03:08:18 <berndl> Hi guys/gals. I'm trying to figure out something with the tagless final encoding.
03:08:37 <immae> (The exact correct line was `foldM (\acc _ -> getLine >>= return . integrateToMap acc) e [1..n]`, but you gave me the right direction, thanks for your help!)
03:08:48 <berndl> Say I have `class IntList a { nil :: a; cons :: Int -> a -> a }`
03:09:02 <berndl> How would I encode the map operation in this setting?
03:09:53 <berndl> newtype Map = Map { map :: ??? }
03:11:23 <immae> berndl: map is an operation that acts on lists only, you may want to make your IntList an instance of Functor, and implement fmap there instead
03:13:25 <immae> (hmm sorry I realize I have probably misunderstood your question, forget what I said)
03:13:45 <berndl> immae: OK.
03:15:12 <thyr15t0r> I instaled gtk on windows. and it works
03:15:16 <thyr15t0r> ))
03:15:45 <thyr15t0r> but i can't install glade libs from hackage
03:17:26 <thyr15t0r> can you help me to do? cabal wrote: (conflict: pkg-config package libglade -2.0>=2.0.0, not found in the pkg-config database)
03:19:31 <cocreature> thyr15t0r: that means that you haven’t installed the glade C library
03:20:08 <cocreature> berndl: does "newtype Map a = Map { map :: (Int -> Int) -> a }" work out?
03:21:15 <thyr15t0r> <cocreature> what to use cabal or pacman for that library?
03:21:36 <cocreature> thyr15t0r: pacman, cabal is for installing Haskell libraries not C libraries
03:21:58 <thyr15t0r> <cocreature> yes) jast ask)
03:22:12 <cocreature> thyr15t0r: also fwiw "<nickname>" is usually used for quotes, if you want to direct a message at someone use "nickname:" :)
03:22:49 <thyr15t0r> cocreature: ok
03:36:33 <berndl> cocreature: If I use the definition of Map, what would the IntList Map instance look like?
03:40:10 <cocreature> berndl: how about https://gist.github.com/cocreature/6c04ae50d2ad98e77dffd25eb43b0ce5
03:40:45 <berndl> Checking.
03:44:37 <berndl> cocreature: it compiles. I'm trying to figure out how to use it now...
03:45:36 <berndl> Say I have expr1 = cons 1 nil, I'm not sure how to use Map on it.
03:46:28 <cocreature> berndl: updated the gist to add an example
03:48:26 <berndl> Nice. Thanks cocreature. I realize the mistake I was making.
03:48:35 <berndl> *realized
03:56:50 <inquisitiv3> I'm trying to do an exercise from the book *Get Programming with Haskell*. I'm having trouble with exercise 9.1 where I should implement the `elem` function with `filter` and `length`. My current solution and the error message I get: https://gist.github.com/inquisitiv3/dde6b4712da30eca97893f9b11e92729
03:57:37 <inquisitiv3> I think it's the lambda function that I use with filter is the cause of the problem, but I'm not sure how I should use it.
03:58:56 <cocreature> inquisitiv3: the function that you pass to filter receives the individual elements not the whole list
03:59:05 <cocreature> so don’t pattern match on the cons constructor using y:ys
03:59:15 <cocreature> just (\y -> y == x) or even (==x) should do the trick
04:06:08 <inquisitiv3> cocreature: Thanks! I updated the file as you described, but now I receive a compile error when I try to reload the file in GHCi. I'm having a hard time trying to understand GHC's error messages.
04:06:18 <inquisitiv3> I've updated the gist with the new code.
04:06:22 <inquisitiv3> And error message
04:08:05 <cocreature> inquisitiv3: you can only use (==) on types that are an instance of Eq
04:08:16 <cocreature> so you need to change the type signature to Eq a => a -> [a] -> Bool
04:09:46 <inquisitiv3> cocreature: Aah, thanks! I forgot to test to comment the type declaration. Thanks for your help!
04:10:33 <davr0s> (spent a little time improving my emacs haskell setup, hacky assists- spawning greps, e.g. (i) when entering camelC..ase symbols, grep for the previous bit,   or when pressing the space bar after a long symbol, grepping for things that look like a function def.   i had something similar with Rust doing greps when you press "_" , that language is especially grep-friendly)
04:11:34 <davr0s> getting the function or type definition onscreen *somewhere* helps jog memory regarding params.. not quite parameter completion but better than nothing!
04:50:34 <thyr15t0r> cocreature: i ca't find glade C library. where to take it?
04:50:36 --- mode: glguy set +v WilhelmV1nWeiner
04:50:42 <WilhelmV1nWeiner> I could use a mutable array in Haskell but is there a more eloquent solution
04:51:04 <WilhelmV1nWeiner> in C I would use an array of n elements and change 
04:51:15 <WilhelmV1nWeiner> them at will
04:52:01 <WilhelmV1nWeiner> (To represent a linear block of memory with `n` 32 bit cells)
04:52:41 <cocreature> thyr15t0r: mingw/mingw-w64-x86_64-libglade looks promising
04:53:34 <cocreature> WilhelmV1nWeiner: you could use an IntMap depending on your requirements but there is nothing wrong with using a mutable array if it fits your usage pattern
04:55:41 <typetetris> How do I build the executable for a test-suite with cabal, without executing it?
04:56:34 <cocreature> typetetris: cabal new-build <componentname>
04:57:19 <typetetris> What does that `new-build` thing entail?
04:57:51 <cocreature> new-build is the new nix-style builds that will replace regular build in the not too distant future
04:58:31 <cocreature> which supports multi-package projects, global caching of dependencies, …
04:58:35 <typetetris> ok, I use nix and have a nix shell with all dependencies already loaded, I hope in that case it will not try to provide the dependencies on its own?
04:59:20 <cocreature> right if the dependencies are already installed then it won’t reinstall them
05:00:27 <cocreature> I think regular build also supports passing in a componentname but it’s been so long since I’ve had to use that that I’ve forgotten :)
05:01:23 <typetetris> Ok. The component names can have those prefixes like `exe:` is there a prefix for test-suites? And as a bonus, where is that stuff documented? (Didn't find it in the cabal user guide).
05:02:42 <cocreature> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-new-build has a description
05:03:43 <typetetris> Thank you very much!
06:04:51 --- mode: glguy set +v jvanbruegge
06:13:15 --- mode: glguy set -v jvanbruegge
06:30:42 --- mode: glguy set +v mauro_
06:31:37 <davr0s> interseting.  now i have  a clipping bug. 
06:34:30 <davr0s> in c++ i would have been straight into asserts
06:34:56 <davr0s> i have a place where I return a pair of maybe's , but actually it's invalid if *both* are nothing. it must have one or the other 'Just..'  
06:35:29 <davr0s> hence it seems useful to make a NonEmptyMaybePair (3 valid cases)
06:37:12 <cocreature> davr0s: we do have asserts in Haskel :)
06:37:16 <cocreature> *Haskell
06:37:27 <davr0s> heh easy way out :) but i guess you can strip them out.
06:37:46 <cocreature> right just like in c++ you can disable them with a compiler flag
06:37:48 <davr0s> i guess it's like panic!() in rust. they explain it's valid to spawn a thread that could fail
06:40:28 <davr0s> i see the signature 'assert Bool->a->a' - i'm guessing this slots into an expression, passing a value through...    calcSomethingElse   $veryfyIt   $calcSomething..      //   verifyIt x = assert (validation) x
06:41:17 <tsaka__> :t Control.Monad.State.Lazy.modify'
06:41:18 <lambdabot> MonadState s m => (s -> s) -> m ()
06:41:35 <tsaka__> What if that function is (s -> m s)?
06:41:38 <tsaka__> See: https://lpaste.net/8965198949942034432
06:42:13 <tsaka__> (Line 50) ^
06:45:53 <cocreature> :t \f -> put =<< f =<< get -- tsaka__ 
06:45:54 <lambdabot> MonadState a m => (a -> m a) -> m ()
07:07:05 <dmwit> davr0s: The "these" package has your NonEmptyMaybePair.
07:07:16 <davr0s> nice, thanks
07:17:29 <tsaka__> I've made my own 'zoom' function from Control.Zoom, but I can't get it to work if its a standalone-function, just if its inline: https://lpaste.net/3513896303169896448
07:23:08 <cocreature> tsaka__: looks like a rank error, what you might want is "statePartM :: MonadState s m => Lens' s s' -> (forall n. MonadState s' n => n (a, s')) -> m ()"
07:23:32 <cocreature> although at that point you could also use "statePartM :: MonadState s m => Lens' s s' -> State s' (a, s') -> m ()
07:24:10 <cocreature> or StateT s' m (a, s')
07:28:27 <cocreature> tsaka__: although I would argue that if you really want to use MonadState you are better off working with Has-classes and keep the state the same
07:28:39 <cocreature> MonadState and zoom just don’t work together very well
07:35:13 <tsaka__> cocreature: The first suggestion compiles, but the resulting function cannot be called from 'environmentStep' because the MonadReader cannot be inferred
07:35:55 <cocreature> tsaka__: right, the first option requires that it only depends on a MonadState constraint
07:36:15 <cocreature> the StateT s' m (a, s') works assuming the additional constraint pass through StateT
07:36:16 <tsaka__> The second suggestion compiles and can be used, however I don't understand why you can constrain it to StateT while 'generateNewEvent' is constrained to MonadState only
07:37:00 <cocreature> tsaka__: when you use generateNewEvent you are allowed to choose "m" however you want as long as the constraints are satisfied
08:03:02 <max3> i'm using vscode with haskell ide engine (and hence stack). here are my .cabal and .yaml https://paste.rs/S1K.yml
08:03:11 <max3> why am i getting "Could not find module ‘Data.Map’
08:03:11 <max3> Use -v to see a list of the files searched for."
08:03:20 <max3> when importing Data.Map as Map
08:03:25 <max3> in the editor
08:03:46 --- mode: glguy set +v robstr
08:05:26 <robstr> Hello, I struggle with the `servant-docs` package, when generating markdown documentation it indent the Examples and github is not able to display this correctly. Does someone else had this issue ?
08:18:14 <hpc> max3: the executable requires it but not the library, perhaps?
08:18:24 <max3> hpc, isn't it in the stl though?
08:18:38 <hpc> it's in containers, not base
08:18:43 <max3> ah
08:21:40 <tsaka__> if you end up writing lots of diverse helper functions, which are not domain-specific, do you just end up dumping all of them into a Utils.hs file 
08:22:21 <tsaka__> or keep them where they are used the most, even if not exclusively, and even if not related to the domain of the module/file at all
08:27:20 <dmwit> max3: Also the "stl" is for C++. No templates in Haskell, so no standard template library. =)
08:27:26 <max3> right
08:27:36 <max3> *prelude
08:31:17 <roberth> hello, I've found this interesting type with an Applicative that helps with parsing things of multiple types that are allowed to appear in any mixed order
08:31:22 <roberth> is this something that already exists in a library somewhere? https://gist.github.com/roberth/dc90ba82976d10d75caf2122c6812032
08:43:37 <cocreature> roberth: not sure about your specific implementation but “parsing things of multiple types that are allowed to appear in any mixed order” very much reminds me of optparse-applicative
08:45:57 <max3> god ghc is a dog
08:46:03 <max3> compiling 
08:54:34 <infinisil> Hey, how can I get the number of cores?
08:56:43 <c_wraith> Do you want the number of physical cores, or the number of haskell threads running?
08:56:51 <hpc> http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Conc-Sync.html#v:getNumProcessors
08:57:02 <c_wraith> because that api there does the latter
08:57:20 <c_wraith> err.  haskell execution threads, not fork* threads
08:57:50 <infinisil> AH yeah just found that too
08:58:29 <infinisil> Hmm I'm not sure, I just have some map like operation I want to execute in parallel as fast as possible
08:58:41 <infinisil> Should I use getNumCapabilities or getNumProcessors?
08:58:44 <c_wraith> then that's what you want
08:58:56 <c_wraith> oh, Capabilities is what you want
08:59:12 <infinisil> When would one want one vs the other?
08:59:12 <c_wraith> because that's how much parallelism you actually can have
08:59:24 <c_wraith> or maybe the min of the two
08:59:37 <c_wraith> because they both cap your possible parallel execution
09:00:37 <infinisil> I can't imagine capabilities set to anything above the processor count
09:00:47 <infinisil> " It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores"
09:01:03 <infinisil> So I'll just use that
09:02:40 <infinisil> (Along with async-pool)
09:05:45 <geekosaur> in the general case, there are times when its useful (you're assuming some threads / capablities are blocked on IO). the way the ghc runtime handles that, that one doesn't apply. but there might be other such cases
09:05:54 <greymalkin> infinisil: Are the operations pure? If so, you might just need to mark it up with `par` and `pseq` rather than manually controlling the parallelism
09:07:01 <roberth> cocreature: thanks :) I've had a look and optparse-applicative doesn't provide this abstraction
09:07:31 <roberth> it does seem like many (p1 <|> p2 <|> ...) should work fine in optparse-applicative, so you could use Gather on top of it
09:08:08 <infinisil> greymalkin: Yeah I can make them pure
09:09:02 <greymalkin> That's typically the way to do it, then; the `par` markup doesn't interfere with being pure, so you get parallelism without the hassle of bridging through IO.
09:09:05 <infinisil> greymalkin: But I have a list of inputs, not just a couple elements
09:09:19 <infinisil> I see
09:10:28 <greymalkin> One of the tests that has been used is dot-product of 10 million doubles; I think it should be suitable for large lists :)
09:11:25 <infinisil> Oh actually, I don't think it's pure, because I need STM
09:12:12 --- mode: glguy set +v dataN
09:12:14 <infinisil> Okay I'll be a bit more descriptive with what I'm doing
09:12:16 --- mode: glguy set -v dataN
09:12:19 <dataN> https://gist.github.com/dataN-hs/0f6b0c6b5f860e182599ad0b9f322977
09:14:52 <infinisil> Simplified I have results :: [a], toProcess :: [b], f :: b -> a, shouldInsert :: [a] -> a -> Bool
09:15:52 <infinisil> f is very expensive, toProcess can be very big. when shouldInsert returns True for a certain [a], a, the a should be inserted into results, and be used for all future shouldInsert calls
09:16:04 <infinisil> That's what I need STM for
09:18:08 <infinisil> Currently I have this implemented without parallelism by just using State [a] ()
09:19:42 <infinisil> Not sure if I can use par for that
09:20:41 <Berra> Can someone just help me understand how I am way way wrong in this, simple example here https://privatebin.net/?4184a6e05bf98324#rnRiBet4+1OnXrT+lH3yuX95uo5IzWOYPYRIb1qHVtE=
09:21:27 <Berra> I'm trying to define a specific HList to use as a type, but I'm just misguided
09:21:48 <dataN> :t mapAccumrbut its a value?
09:21:49 <lambdabot> error:
09:21:49 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:21:53 <dataN> oops!
09:22:38 <dataN> your trying to return a type as a value 
09:23:58 <dataN> did you mean to use a Proxy?
09:25:59 <Berra> dataN: How should the proxy be used to correctly check that the constructed X is according to MyX?
09:26:38 <Niklas9751> Why is it that the lift function has to be defined separately for each monad, where as liftM can be defined in a universal way?
09:26:59 <dataN> you want to check the F or G or the Int values?
09:28:30 <dataN> maybe if the example was written using a Proxy to begin with it would be more clear what you mean
09:28:32 <Berra> dataN: The entire thing?
09:32:32 <dataN> myX :: Proxy MyX; myX = Proxy :: Proxy (G [ F 1 ,F 2 ,F 3])
09:32:35 <dataN> writing;
09:32:37 <dataN> myX :: Proxy MyX myX = Proxy :: Proxy (G [ F 2 ,F 2 ,F 3])
09:32:45 <dataN> gives;
09:32:46 <dataN> Couldn't match type `2' with `1'       Expected type: Proxy MyX
09:32:51 <dataN> ...
09:33:41 <dataN> {-# Language DataKinds , GADTs , KindSignatures , PolyKinds#-}  data Proxy (a :: k) = Proxy
09:34:39 <dataN> Hi, this code gives a really odd error, would anyone be able to explain why? https://gist.github.com/dataN-hs/0f6b0c6b5f860e182599ad0b9f322977
09:35:18 <Berra> dataN: Thank you, helps me in the right direction!
09:36:35 <ski> Niklas9751 : `lift' is defined for monad transformers, not monads
09:37:24 <ski> Niklas9751 : `liftM' can be defined in terms of `(>>=)' and `return', which are defined separately for each monad
09:38:45 <max3> is there no way to apply `maybeInc = (+) <$> Just 1` to a `Just 2`
09:39:37 <dataN> :t <*>
09:39:38 <lambdabot> error: parse error on input ‘<*>’
09:39:44 <max3> applicative?
09:39:44 <dataN> :t (<*>)
09:39:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:39:57 <max3> yes that's the next section in this book
09:40:04 <dataN> :t (+) <$> Just 1
09:40:06 <lambdabot> Num a => Maybe (a -> a)
09:40:08 <max3> but oh
09:40:10 <max3> *oh okay
09:40:17 <max3> i also don't understand the type
09:40:22 <max3> Maybe (Integer -> Integer)
09:40:30 <ski> max3 : `(+) <$> Just 1 = Just ((+) 1)'
09:40:31 <max3> in what sense is maybeInc a Maybe a function?
09:40:44 <max3> ah
09:40:53 <max3> lol that answers my question perfectly ski
09:41:03 <max3> thanks!
09:41:42 <dataN> :t (+) $ 1
09:41:43 <lambdabot> Num a => a -> a
09:42:05 <dataN> :t <$>
09:42:06 <lambdabot> error: parse error on input ‘<$>’
09:42:08 <dataN> :t fmap
09:42:09 <ski> unless you wanted to familiarize yourself with `<$>' and `(<*>)', it'd be easier to skip the `Maybe' in `maybeInc'
09:42:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:42:13 <dataN> :t (<$>)
09:42:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:42:19 <ski> (since you're always `Just' anyway)
09:54:50 <dataN> https://gist.github.com/dataN-hs/0f6b0c6b5f860e182599ad0b9f322977
09:55:09 <dataN> the error is so strange, there seems to be no reason it shouldnt be able to use the associated type
09:55:45 <dataN> the code in the comment shows a short example which works as expected 
09:56:40 <dataN> the flagged superclass to Switch means the associated type should be in scope, but it fails to resolve it
09:59:50 <thyr15t0r> hello
10:01:06 <thyr15t0r> looks like no way to insta͚̭͙̹̲ͭͩll glade package on 8.4.3 on win
10:06:56 <cocreature> thyr15t0r: why do you even want to do that? the docs of the glade package mention that this functionality is provided by gtk itself these days
10:07:29 <cocreature> maybe you just want the glade tool rather than the glade Haskell library?
10:12:22 <thyr15t0r> cocreature: compilation of 'imort Graphics.UI.Gtk.Glade' returns an error 'Could not find module'. I just want something for glade xml interpretation
10:13:47 <cocreature> thyr15t0r: that module is from the old gtk2hs package. have you looked at the example in the haskell-gi repository https://github.com/haskell-gi/haskell-gi/blob/6314b296233e0d7ab72f7d5ee8b1b4b235defd95/examples/introductory/src/builder.hs#L50
10:13:58 <geekosaur> you do not want to use libglade. libglade was for early gtk 2.x. later gtk 2.x and gtk 3.x have a better built-in mechanism usi8ng similar but incompatible xml
10:14:11 --- mode: glguy set +v dataN
10:18:15 <akr> Hi there, I have a web application I normally start by wrapping it in spawn-fcgi. I'm a bit hazy on what exactly spawn-fcgi does and what I would like to do is start my application from within ghci. How can I do this?
10:20:26 --- mode: glguy set +v electroc1t
10:20:46 <thyr15t0r> cocreature: this listing is still difficult for me. i'm a  cucumber beginner, i'm on page 140 of my haskell textbook)))
10:20:53 --- mode: glguy set -v electrocat
10:21:06 <electrocat> akr: if you want to use ghci, maybe use a http server instead of fcgi?
10:21:40 <akr> electrocat: hmm, well normally I am using nginx with spawn-fcgi
10:21:58 <cocreature> thyr15t0r: glade will give you a .ui file. this snippet should show you how you can load that .ui file
10:22:07 <electrocat> that's fine for in production, but when you're developing, it's maybe easier to run a webserver from ghci
10:22:46 <geekosaur> thyr15t0r, sticking to gtk2hs won't help. it will make things worse because gtk2hs is old and doesn't and can't really support modern gtk. gi is the replacement.
10:23:02 <akr> electrocat: true, though now I need to modify my codebase to support this :)
10:23:12 <akr> I was hoping for some smart hack
10:23:24 <thyr15t0r> my glade makes .glade files
10:23:26 <akr> like, still suing spawn-fcgi but so that it drops me into the repl instead of forking
10:23:40 <geekosaur> so if you can get gtk2hs to build at all, some things probably won't work right
10:23:49 <akr> but it doesn't look like spawn-fcgi supports that
10:24:12 <electrocat> akr: yeah, i don't think that's a thing you can do
10:24:19 <electrocat> the fcgi host needs to start the process iirc
10:24:51 <electrocat> you probably can, but it's probably a lot of work
10:24:58 <akr> electrocat: okay, I see
10:25:06 <monochrom> thyr15t0r: If you are a beginner, then perhaps you should postpone this project.
10:25:12 <thyr15t0r> oh yes! now a see the world in real colors
10:26:36 <thyr15t0r> monochrom: I thought that for Haskell there is something like Delphi drag and drop gui construktor
10:26:52 <geekosaur> you want gtk's glade program.
10:27:08 <geekosaur> we don't reinvent that just to have one in haskell, when the standard one works.
10:27:12 <monochrom> Everyone thought that. Because everyone thought someone else has already done it.
10:27:20 <geekosaur> gi can then load the generated ui
10:28:16 <thyr15t0r> i have got gi. but i need documentation. don't know which way to approach him
10:29:01 <geekosaur> you want the standard gtk documentatio; gi doesn't documnt thatbecause it's just making the standard gtk stuff available from haskell
10:30:37 <geekosaur> so it only shows the differences neded to use it from haskell. there's a lot of gtk documentation; rewriting it all wouldn't be worth it.
10:31:13 <geekosaur> and would mean constantly looking for changes in upstream gtk and copying those changes into our own documentation
10:31:46 <geekosaur> (at the level of code, gi is autogenerated from the installed gtk. this doesn't work so well for documentation)
10:32:17 <thyr15t0r> нou are really smart guys. еhank you for helping me. This 5 days of gui solution search  were not easy. today i got a knoleadge
10:33:45 <dataN> tomorrow you get a spellchecker 
10:34:39 <geekosaur> or in my case maybe a keyboard that can handle >8wpm
10:35:18 <monochrom> Actually I haven't noticed a typo from you for a while. Almost forgot your keyboard issues. :)
10:35:44 <geekosaur> they still happen. I'm being more careful about going back and fixing the errors
10:36:00 <geekosaur> had to fix 2 in that line ^
10:36:08 <monochrom> The story of TCP/IP.
10:36:40 <dataN> did anyone see this error? https://gist.github.com/dataN-hs/0f6b0c6b5f860e182599ad0b9f322977
10:37:23 <monochrom> I don't understand the error, so meh.
10:37:49 <ab9rf> i refuse to look at the error :)
10:37:50 <monochrom> Have you read Eisenberg's thesis? It is everything about Dependent Haskell.
10:38:00 <ab9rf> if monochrom doesn't understand it, there's no chance i will
10:38:26 <ab9rf> also, my browser is occupied
10:38:35 <monochrom> That one, I think it's just because I don't care about Dependent Haskell so I don't bother.
10:38:58 <monochrom> Like, I don't know lex and yacc either, similarly.
10:39:19 <ab9rf> i used to know yacc
10:39:32 <dataN> oh so because it uses one associated type its suddenly dependant haskell?
10:39:34 <ab9rf> but that was so long ago
10:40:36 <infinisil> Ugh, I'm heavily confused by pure parallelism
10:40:42 <monochrom> IMO yes. But I'm naive. You can just consider what I said to be a tangent.
10:40:47 <dataN> most of the functions there are not used, just included so that when this works its a better reference 
10:41:20 --- mode: glguy set +v MrL567
10:42:36 <ab9rf> hm, reading the ghc wiki pn DependentHaskell
10:42:50 <dataN> monochrom: its good we have TypeInType now, but ever since I started using it the errors I get are not receiving well 
10:43:13 <monochrom> Then maybe it's bad, not good.
10:44:14 <ab9rf> sometimes a "feature" that makes a tool harder to use is a feature you should avoid
10:44:16 <dataN> what the code?
10:44:54 <ab9rf> using a hole hawg to drill pilot holes to hang a painting, for example
10:45:24 <c_wraith> Possibly still better than a jackhammer?
10:45:31 <ab9rf> c_wraith: only marginally. 
10:45:42 <ab9rf> c_wraith: and actually more likely to cause operator injury
10:45:44 <dataN> the whole point of this approach is to get an api to a reasonably useful hack, so that the details and complexities can be easily incorporated into code 
10:46:37 <monochrom> I was going to explain what I mean with a little description of the flaw and cognitive dissonance in human psychology, but I'm sure the point would be lost, so meh.
10:46:57 <dataN> well, so that the complexities of the hack can be used without having to cope with these kind of errors
10:47:14 <ab9rf> aw
10:48:30 <dataN> monochrom: would it help if it was rewritten with less unnecessary code? 
10:48:48 <ab9rf> dataN: it pains me that you need to ask that question.
10:49:08 <dataN> hrmpf
10:49:17 <dataN> ok 
10:50:22 <ab9rf> although this discussion is reminding me of a critique of haskell programmers i saw the other day
10:50:37 <monochrom> heh
10:50:56 <ab9rf> a critique that i cannot say is entirely without merit
10:53:46 <dataN> ok here, https://lpaste.net/913617729443856384
10:54:39 <dataN> to compare with this which works
10:54:40 <dataN> https://lpaste.net/5255017667772809216
10:55:16 <dataN> oops, the error on the first is this; https://lpaste.net/211766175732858880
10:57:03 <dataN> the associated type is being used as a kind annotation, which is shown to work in the second paste
10:58:14 --- mode: glguy set +v dataN_
11:35:13 --- mode: glguy set +v romanix
11:35:18 <romanix> Hi guys! I'm trying to understand when values get garbage collected in Haskell. Specifically, does Haskell garbage collect data passed in as function arguments during that function's execution?
11:39:32 <lyxia> that can happen
11:39:54 <lyxia> there's no guarantee though
11:41:15 <[exa]> romanix: statistically for most functions out there the answer is "no" though
11:42:23 <[exa]> romanix: is there something why the exact place of garbage collection would matter to you?
11:43:25 * ski idly wonders how "during that function's execution" is defined
11:44:50 <romanix> Yes. I have an IO action that receives a couple of large lists (rows from DB) as arguments and I'd like to free the memory they occupy as soon as possible.
11:46:03 <c_wraith> romanix: you probably don't want to run the GC when it's not needed.
11:46:25 <ski> as long as you don't keep around references to the earlier cells in the list, the GC should be able to drop those
11:46:34 <c_wraith> romanix: in particular, you probably want those large values to be *eligible* for collection as soon as possible
11:46:47 <c_wraith> romanix: which is very different from *collected* as soon as possible
11:50:28 <romanix> ski, I assume using let combinedLists = listA ++ listB counts as a reference?
11:54:17 <cocreature> romanix: reference to what?
11:55:04 <nshepperd> things are eligible for garbage collection when they're not needed any more
11:55:23 <cocreature> if unevaluated this will reference listA and listB, once evaluated this will reference the elements of listA (but not the cons cells) and listB
11:56:02 <nshepperd> being referenced in the computation of some value that is needed and hasn't yet been evaluated, is one way a thing can be needed
12:00:36 <romanix> Thanks for the tips guys. I need to read up on this more thoroughly though. It's still a bit magic to me.
12:02:25 <Younder> In Haskell laziness is a virtue
12:03:57 <ski> @quote great.virtues
12:03:58 <lambdabot> LarryWall says: We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.
12:04:06 <ski> @quote a.great.virtue
12:04:06 <lambdabot> Dijkstra says: Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better.
12:07:37 <hpc> @quote defun
12:07:37 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
12:07:50 <hpc> aw
12:11:18 <nshepperd> heh
12:15:26 <Younder> I thought I invented low-brow. The return to neandertal grunts..
12:18:32 <Younder> Usually during games like ma hong or chess. Uh, Eh, arg, duh etc.
12:22:38 <Unode> I'm reading some haskell code that makes heavy use of the inline pragma. Reading on what inlining is, I understand it's a performance thing. However I don't understand the wording. What exactly is inlining and what does 'replacing a function with its definition' mean?
12:24:38 <cocreature> Unode: let’s say you have defined f x y = x + y and you have a second function g x y = f x y
12:24:46 <cocreature> if you inline f you end up with g x y = x + y
12:28:04 <Younder> make it anonymous it it is that trivial
12:32:22 <maerwald> anyone wants to try https://github.com/hasufell/ghcup feel free to send me comments
12:34:45 <Unode> cocreature: so you remove the function call. Ok. And the warnings on the wiki page, I take it that if that function is used in many locations, the binary produced expands in proportion to the size of f 's definition?
12:35:43 <Unode> is the overhead of calling f that large to justify inlining? Or is this so low level that it impacts CPU caches and such?
12:36:02 <cocreature> in Haskell the primary benefit of inlining is that it can enable further optimizations
12:36:29 <cocreature> so it’s not so much about inlining itself as it is about optimizing the definition based on information from its usesite
12:37:48 <Unode> cocreature: so then taking it to the other extreme. Why don't we simply inline everything?
12:38:12 <Solonarv_> because that destroys sharing and blows up binary size
12:38:45 <cocreature> Unode: first you can’t inline everything, e.g., consider a recursive function
12:39:00 <cocreature> second, you blow up compile times to the point where it gets unbearable
12:39:04 <Solonarv_> consider "let x = <something expensive> in f x x": if x is inlined, it'll get calculated twice
12:39:34 <cocreature> and finally often it doesn’t actually provide a benefit and the increased code size (which can also have a performance impact) can even make things worse
12:43:32 <Unode> Solonarv_ cocreature: thanks for the feedback. Just trying to understand what motivates people to use this pragma. On some libs it's used quite extensively.
12:47:22 <cocreature> Unode: one particular reason for why inlining can be important in Haskell is so that rewrite rules (which are used for list fusion among other things) can fire
12:49:04 <epta> isn't default inlining performed by compiler good enough?
12:50:47 <epta> related thread https://www.reddit.com/r/haskell/comments/6bojlj/inlineing_a_case_study/
12:51:38 <cocreature> sometimes it is good enough, sometimes it isn’t. that’s why you have the option to control it
12:55:26 <tdammers> https://ghc.haskell.org/trac/ghc/ticket/15488#comment:17 <- is an example of a fairly benign-looking program that, due to excessive inlining, blows up compile times in a spectacular manner
12:55:55 <tdammers> and no, the default, while pretty good, doesn't have all the information
13:15:02 --- mode: glguy set +v Adser
13:34:56 <Unode> curious, does excessive inlining also increase memory requirements during compilation? I recall one particular version of a library causing a somewhat simple function to require over 4GB of RAM to compile.
13:35:36 <hpc> i forget what this bug was, but...
13:35:38 <hpc> @quote cost.me
13:35:38 <lambdabot> roconnor says: oh no. edwardk and I can never meet otherwise it will be revealed that I am actually him in a very short costume.
13:35:41 <hpc> @quote cost.me
13:35:41 <lambdabot> roconnor says: oh no. edwardk and I can never meet otherwise it will be revealed that I am actually him in a very short costume.
13:35:44 <hpc> D:
13:36:30 <hpc> @quote largest.program
13:36:30 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
13:36:30 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
13:44:30 <Unode> tdammers: interesting read on the ghc issue
13:45:31 <Unode> hpc: hehe, outch
13:51:31 --- mode: glguy set +v noipmups
13:51:41 <noipmups> Is it possible to use .~ lens combinator with an "IO a" value and assign just "a"?
13:53:07 --- mode: glguy set +v dataN
13:59:21 <phadej> noipmups: you can
13:59:22 <phadej> git@github.com:phadej/hs-jose.git
13:59:23 <phadej> ah
13:59:25 <phadej> > return "foo" & mapped .~ "bar" :: IO String
13:59:27 <lambdabot>  <IO [Char]>
13:59:31 <phadej> but it's a bit silly :S
14:00:08 <noipmups> phadej: Thanks. Why it's silly?
14:01:13 <phadej> I'd just use fmap
14:01:19 <phadej> "bar" <$ return "foo" :: IO String
14:01:24 <phadej> > "bar" <$ return "foo" :: IO String
14:01:26 <lambdabot>  <IO [Char]>
14:01:40 <phadej> i.e. if you want to run an IO computation, but return something else
14:02:18 <phadej> lens use here will unnecessarily obfuscate
14:02:27 <phadej> "you can doesn't mean you should"
14:03:04 <phadej> > do { return "foo"; return "bar" } -- even more clear
14:03:06 <lambdabot>  error:
14:03:06 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M445891495273...
14:03:06 <lambdabot>        prevents the constraint ‘(Show (m0 [Char]))’ from being solved.
14:03:13 <phadej> > do { return "foo"; return "bar" } :: IO String -- even more clear
14:03:15 <lambdabot>  <IO [Char]>
14:04:06 <noipmups> phadej: Oh, I see. I'm still wrapping my head around lens.
14:05:25 <Unode> on debugging haskell code. Is there any reasonable GUI alternative to setting breakpoints and stepping through the code manually in ghci?
14:07:46 <monochrom> I think no.
14:09:02 <dataN> Unode: for type checking?
14:10:08 <dataN> thats the only imperative like part of the debugging process
14:10:32 <Unode> dataN: for any kind of :break :step interaction. Getting lost in having to visually parse the line,row coordinates into my text editor and back
14:10:59 <royal_screwup21> super new to haskell. I've written up a function to calculate the max in a list of integers, but I'm wondering: how do I create a "cache" maxi xs?   https://thepasteb.in/p/mwh13Qm37gDf5 I don't want to have to recalculate it every time...
14:11:40 <dataN> Unode: but stepping how? down each line? thats not how haskell compiles
14:12:31 <royal_screwup21> like, in my conditions, I've got things like "x >maxi xs"  I want to store store the value of this maxi xs, so I don't have to recalculate it
14:12:57 <royal_screwup21> s/conditions/guards
14:13:17 <dataN> a where clause?
14:13:23 <royal_screwup21> ah where
14:13:26 <royal_screwup21> yup thanks :)
14:20:24 <dataN> Unode: it would help to know if its a compile or runtime error. 
14:20:44 <Unode> dataN: I'm not sure I understand what ou are getting at. First time trying this kind of debugging so I'm still figuring things out. I didn't mention compilation, only debugging in the sense of understanding what is going on.
14:21:27 <Unode> Mostly after seeing it in this oldish video: https://www.youtube.com/watch?v=1OYljb_3Cdg
14:22:12 <dataN> wouldnt this be a better reference? https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-debugger.html
14:27:17 <Unode> dataN: Yes, thanks for the link. Thought that's still with direct GHCi interaction. I was wondering for any GUI that would provide a somewhat similar experience to other imperative languages, but then again I guess my question doesn't apply in the same extent.
14:27:46 <dataN> what do you need it to do?
14:28:43 <dataN> IDEs for imperative languages just give the option to break at some line, is that what you mean?
14:29:31 <dataN> maybe its not so different from getting the types at the place an 'error' is thrown  
14:29:36 <Unode> set breakpoints in context with the editor is one aspect which would help already.
14:30:31 <dataN> I heard emacs is used to do some pretty complex things, maybe there is something built for that which is available 
14:39:07 <noipmups> What's the difference between withMVar (withMVarMasked) and modifyMVar?
14:39:38 <noipmups> The documentation is not much clear for me.
14:40:34 <phadej> withMVar doesn't change the value
14:40:43 <phadej> it only let you grab it
14:42:05 <phadej> noipmups: click "Source" in haddock, you'll see how they differ
14:42:57 <noipmups> phadej: Wow, thanks! I didn't know about that.
14:43:53 <noipmups> phadej: I'm probably confused because there is no "MVar a -> (a -> IO b) -> IO b" function for updating the value.
14:44:58 <noipmups> phadej: I'm looking for something like modifyMVar, but without the "a -> IO (a, b)" boilerplate.
14:45:19 <phadej> noipmups: you mean `MVar a -> (a -> IO a) -> IO a` ?
14:45:44 <noipmups> phadej: Oh, your right.
14:45:52 <royal_screwup21> I tried to create a module like so: https://thepasteb.in/p/BghPrLyZq2xfY In a different file, I tried to import the module and use the add function https://thepasteb.in/p/GZhWRz6j8Z6FV I'm getting an error saying the add function is not in scope: https://thepasteb.in/p/Z4hPLW0Ov97CG How do I fix this?
14:46:04 <phadej> the reason why modifyMVar is :: MVar a -> (a -> IO (a, b)) -> IO b
14:46:09 <phadej> is because it more general
14:46:20 <phadej> you can return either old, or new, or something else out of it
14:46:39 <phadej> `MVar a -> (a -> IO a) -> IO a` is ambiguous (is it old or new? we'd need two functions)
14:48:14 <royal_screwup21> ah nvm
15:09:20 --- mode: glguy set +v dataN
15:09:29 <dataN> whats this? 
15:09:30 <dataN> data X f a = X (f (X f a) -> X f a)
15:10:37 <c_wraith> a data type
15:10:55 <ski> `a' is unused
15:11:25 <jle`> dataN: are you familiar with ADT syntax and how to declar data types in Haskell?
15:12:27 <jle`> something like `data MyType a b = MyConstr (a -> b)` is a declaration of the tparameterized type `MyType a b`, with a single constructor `MyConstr` that 'contains' an (a -> b)
15:14:34 <dataN> the 'a' could be used in generating the function of the new X
15:15:17 <ski> (based on earlier pastes like <https://gist.github.com/dataN-hs/0f6b0c6b5f860e182599ad0b9f322977>, i suspect dataN knows the basics of `data' declarations)
15:15:34 <ski> `X f a' is iso to `X f b', for all `a' and `b'
15:15:36 <jle`> ah okay. was just trying to figure out the specific question that was being asked
15:15:53 <jle`> or at least getting to a level of detail that is deeper than 'whats this' heh
15:16:39 <ski> so we could simplify to `data Z f = MkZ (f (Z f) -> Z f)', with `Z f' corresponding to `X f a'
15:17:32 <dataN> data X f a = X (f a (X f a) -> X f a)
15:18:04 <dataN> then the container can use a somehow independent of how it uses the X
15:18:09 <ski> so `fix (MkZ . const) :: forall f. Z f' would be an element, i suppose
15:18:37 <ski> dataN : yea, then `a' wouldn't be useless
15:19:18 <dataN> it was a mistake to think the 'a' could be obtained by examining the function
15:19:34 <dmwit> dataN: Looks a bit like a catamorphism.
15:19:47 <ski> reminds me a bit of `Santa'
15:20:16 <ski>   newtype Santa a = MkS (Santa a -> a)
15:20:54 <ski> we could pick `f' as `Maybe', e.g.,  and see what elements we could construct
15:21:11 <ski> (preferably without general recursion)
15:21:43 <dataN> Nothing -> Z Maybe 
15:22:02 <dataN> how about f = []
15:22:12 <ski> or `f = Const a'
15:22:54 <ski> then `Z (Const a)' is iso to `a -> Z (Const a)' .. which seems pretty useless
15:23:05 <dataN> f a b = (a,[b])
15:23:29 <ski> (perhaps it would be nicer with `f' contravariant in the last argument ..)
15:23:32 <monochrom> My angle is newtype Sink a = Ctor (a -> Sink a)
15:23:55 <dataN> type Y f a = (a,[Y f a]) -> Y f a
15:24:10 <ski> yea, it's like `munch _ = munch'
15:24:58 <dataN> type Y a = (a,[Y a]) -> Y a
15:25:27 <ski>   Z Maybe  =  Z Maybe * (Z Maybe -> Z Maybe)
15:26:06 <ski> hrm
15:26:35 <ski> i think with only `Z f' (or `Z f a') in the result type of the function, it will be pretty useless, still
15:26:45 <ski> we can't extract any info
15:27:36 <ski> if you try `newtype T f = MkT (T f -> f (T f))', then perhaps that might be more useful
15:28:33 <ski> (or even `newtype U f g = MkU (f (U f g) -> g (U f g))')
15:29:18 <dataN> data Z2 f g a b = MkZ2 (f a (Z2 f a b) -> g b (Z2 f a b))
15:29:57 <dataN> data Z2 f g a b = MkZ2 (f a (Z2 f g a b) -> g b (Z2 f g a b))
15:30:23 <dataN> does that have more information than U?
15:30:29 <ski> hm, i think those `a' and `b' parameters aren't really that useful. you could instead pass partially applied `f' and `g' as parameters
15:30:30 <dataN> the snd version
15:31:42 <ski> (might be useful if you wanted to make a `Functor' or `Bifunctor' instance, or something of that sort (fitting a given interface). but otherwise not really increasing expressivity)
15:32:25 <dataN> data V f x where V :: ?(V f x -> x) => (f (V x) -> V x)
15:32:34 <ski>   Z2 f g a b  =  U (f a) (g b)  -- basically
15:32:40 <dataN> -> V f x
15:33:07 * ski can't parse that
15:33:20 <dataN>  data V f x where V :: ?(V f x -> x) => (f (V f x) -> V f x) -> V f x
15:33:27 <ski> what's the `?' ?
15:33:47 <dataN> un unamed implicit parameter ...
15:34:37 <dataN> just to avoid storing this extract function along with the function to stop it being able to be changed as new functions are generated
15:35:45 <ski> so more or less `V f x  =  (V f x -> x) * (f (V f x) -> V f x)' ?
15:36:43 <dataN> that gives the option that the 'V f x -> x' of the 'V f x' on the far rhs could be different
15:37:58 <dataN> which is fine, but it then makes the extract of the internal nested functions need to be used in the upper layers, which sounds complicated 
15:38:38 <ski> well .. i'm not sure of the semantics of this `?(...)' constraint
15:38:51 <dataN> the constraint just makes it a completely separate problem how to extract the info / run the functions 
15:40:44 <dataN> i.e. if f was list, the structure could be laziliy evaluated to get the lengths of these lists to some depth.
15:41:49 <dataN> or if they contain more information, like being isomorphic to 'f a' above, then these may have functions over them, maybe they should be constraints too?
15:42:48 <dataN> its defiantly easier to capture all of this just with the constraint that some function of type V f x -> x exists 
15:43:37 <dataN> but otherwise it also have; f (V f x) -> x
15:44:33 <dataN> as '(f (V f x) -> V f x) -> x' is impossible?
15:45:09 <ski> `const c' should work, if `c :: x'
15:46:07 <dataN> the only options do not use the supplied function?
15:46:30 <dataN> informationless might be a better way to put it
15:46:58 <dataN> and such options should be prevented
15:48:26 <dataN> data V f x where V :: ?(f (V f x) -> x) => (f (V f x) -> V f x) -> V f x
15:48:59 <dataN> that actually captures the '(V f x) -> something' which is neat 
15:49:36 <dataN> huh!? oh no
15:50:05 <dataN> there are no 'f (V f x)'
15:50:24 <dataN> nor 'V f x', thats terrible 
15:51:23 <dataN> type V f a b = State (V f a b) b
15:51:49 <infinisil> Can anybody tell me why there's no function split :: Char -> String -> [String]?
15:52:08 <dataN> what about Data.List.Split?
15:53:05 <monochrom> What should split do?
15:53:06 <infinisil> Ah heh, alright
15:53:18 <dataN> type V f a b = (f (V f a b)) -> (b, f (V f a b#))
15:53:19 <infinisil> monochrom: Should be pretty obvious from the type
15:53:54 <phadej> infinisil: check `split` package
15:53:57 <dataN> thats, V f a b = State (f (V f a b)) b
15:54:00 <phadej> and it's description for the "why"
15:54:24 <phadej> its*
15:54:25 <dataN> sji: ^
15:54:29 <dataN> ski: ^
15:55:17 <infinisil> phadej: Yeah that's what monochrom meant with Data.List.Split
15:55:49 <dataN> the idea is that V updates a container of itself and returns a value.
15:57:24 <dataN> though its still better if there just exists another function exists to use it to obtain something other than new functions which return themselves 
15:58:55 <infinisil> phadej: Not sure what you mean with the ""why"" though
16:01:03 <dataN> the idea is that if a function is used to write new functions, like idk a neural net that made new neural nets, its pretty useless unless these can be used for something else. but, if the new nets being added to the list being used to produce them were improving, having more input nets to choose from, then maybe these are fundamental components, and can be reused by some other function 
16:01:22 <phadej> infinisil: you asked "Can anybody tell me *why*", package's description has an answer http://hackage.haskell.org/package/split
16:03:11 <infinisil> Ah, that was more of a "why is there no such function in base"
16:03:17 <ski> dataN : `a' unused again
16:03:53 <dataN> thats, V f b = State (f (V f b)) b
16:04:07 <dataN> but anyway, these 'b' values are kind of ruining the point
16:05:07 <dataN> the nets should be used by another function 
16:05:09 <ski>   V f b  =  U f (Comp ((,) b) f)
16:06:18 <dataN> maybe its setting f = g in U
16:06:20 <dataN> newtype U f g = MkU (f (U f g) -> g (U f g))
16:07:14 * ski still isn't convinced dataN has a sensible use for these types in mind
16:07:38 <dataN> nested monte carlo machines?
16:08:22 <dataN> anyway, the representation of the function isnt important, it should be producing new versions of itself which are better
16:08:57 <dataN> at producing new, better versions of itself 
16:09:18 <phadej> do you have something working? :)
16:09:20 <dataN> it just seemed like a pretty good abstraction
16:09:31 <monochrom> That is very deep and profound philosophy. Because you can't even make any observation of values of that type.
16:09:52 <dataN> phadej: yeah, the monte carlo version works good, I like it because its a very short piece of code that does this
16:10:14 <phadej> and it uses this V type?
16:10:30 <dataN> its something similar
16:11:04 <phadej> something similar isn't that
16:11:13 <phadej> what you use in your monte carlo code?
16:11:49 <dataN> there are a lot of ways of writing these things as you can see from the scrollup, it was probably only a variation 
16:12:16 <phadej> no, please tell exactly what you use
16:12:22 <dataN> what>
16:12:30 <phadej> that will bring substance to this otherwise abstact discussion
16:12:39 <phadej> if you have a version which /works/
16:12:55 <dataN> whats being discussed is an abstract recursion scheme
16:12:59 <dataN> which does exactly this
16:13:20 <monochrom> Perhaps you should just walk away from an abstraction discussion.
16:14:55 <dataN> no, the idea is to keep it abstract, to avoid hungry learners from jumping on you to get details of how to write self reproducing code!
16:15:18 <dataN> neural nets are interesting too, as if they can be "better" by being able to find component networks 
16:16:02 <dataN> the idea of the container 'f' was to store the various nets, and having access to this to produce new networks 
16:18:33 <dataN> there is a distinction between ASTs and NNs for this because of the ability to tune weights in an established way, and that the prime factors are kind of more easy to combine using these weights
16:19:16 <phadej> I have that very strong feeling that you abstract too early, or too much, or actually both
16:20:31 <davr0s> just discovered trace, that helps alot. closer to the imperative style debugging i have been missing. (i'd sort of being trying to climb the mountain of doing without and introducing more ways of returning diagnostics from inside calculations.. but.. life's too short.)
16:21:11 <MarcelineVQ> phadej: Make it work, then make it right, then make it general?
16:21:29 --- mode: glguy set +v dataN_
16:24:18 <phadej> davr0s: trace is sometimes handy indeed
16:25:15 <davr0s> seems easy enough to wrap the return value and have another debug string generated inside that it takes
16:25:54 <phadej> davr0s: traceShowId ?
16:26:07 <phadej> there's plenty of variants
16:26:44 <davr0s> yeah i see somme useful ones there
16:29:47 <ski> @package hood
16:29:47 <lambdabot> http://hackage.haskell.org/package/hood
16:29:58 <ski> davr0s : ^ might be interesting
16:31:28 <davr0s> looks awesome
16:32:04 <davr0s> i imagine there's scope for some interesting graphical tools here if the world had a lot more time for this niche
16:32:20 <davr0s> trace is enough for me now though :)
16:42:10 <geekosaur> you might also be interested in ghc-vis
16:42:26 <monochrom> hood may be outdated, as in incompatible with recent GHC.
16:43:06 <geekosaur> and I could see someone starting with ghci-ng (unbundled ghci for development and testing) and one of those to come up with a fancier
16:43:16 <geekosaur> er. fancier ui
16:43:35 <monochrom> As for generally all GUI-related work in the Haskell community, you need to recall the Aesop fable of the congress of the mice.
16:43:53 <geekosaur> that would be why it hasn't been done yet, yes :)
16:44:41 <monochrom> All mice agree that a bell needs to be hanged under their enemy the cat's neck.  They also all agree that someone else ought to do it.
16:45:25 <infinisil> Um, I'm having some trouble understanding how I'm supposed to use async-pool (cc johnw )
16:45:27 <monochrom> Plus, I can add an Adam-Smith-vs-Karl-Marx angle to it. They also all agree that the someone else ought to do it for free.
16:45:42 <infinisil> Namely, I'm getting "*** Exception: thread blocked indefinitely in an STM transaction"
16:47:00 <infinisil> I'm using withTaskGroup 4 $ \group -> <an action that spawn many many more IO actions through mapTasks>
16:47:53 <infinisil> johnw informed me here before (https://github.com/jwiegley/async-pool/issues/7#issuecomment-390442726) that I'm supposed to call runTaskGroup
16:48:14 <infinisil> When am I supposed to call that? I can't find anything in the docs
16:49:56 <infinisil> I also tried using withTaskGroupIn instead: https://hackage.haskell.org/package/async-pool-0.9.0.2/docs/src/Control-Concurrent-Async-Pool-Internal.html#withTaskGroupIn
16:50:13 <infinisil> Because that uses runTaskGroup internally. But I'm still getting the same error after some time
17:01:52 <infinisil> Oh
17:01:54 <infinisil> https://github.com/jwiegley/async-pool/issues/4
17:01:56 <infinisil> Great
17:02:22 <infinisil> Won't be using async-pool then :/
17:19:49 <ym555> is there is anything like dante for vim? I wanted something lightweight that just uses ghci, but can't find any and I don't want to switch to emacs just for haskell :P.
17:21:53 <MarcelineVQ> Not that has come up so far, though it does seem to be desired. ghcid helps a lot. the haskell ide engine also has neo-vim bindings iirc
17:49:51 <texasmynsted> given that I want to use ghcid like "ghcid -c 'cabal new-repl' --reload=./foo.hs -T Main.main". Is there a simple way to cabal init, for multiple files without making multiple directories?
17:50:33 <texasmynsted> I just want to make a bunch of simple "example" type haskell files and use ghcid while I am making them.
17:50:40 <texasmynsted> I am not sure the best way to do this...
18:49:51 --- mode: glguy set +v koz_
18:50:01 --- mode: glguy set -v koz_
18:50:06 <koz_> Whoops.
18:50:09 <koz_> Whenever I 'stack build' anything, I always get this in the output: ignoring (possibly broken) abi-depends field for packages.
18:50:16 <koz_> Is this something I should worry about, and can I make this go away?
18:53:05 <ChaiTRex> koz_: See https://github.com/haskell/cabal/issues/5465
18:53:32 <MarcelineVQ> No, yes, don't worry about it though, it's a ghc issue
18:53:48 <koz_> MarcelineVQ and ChaiTRex: Thank yoU!
19:06:24 <learnerx> sorry for the absolute newb questions
19:06:30 <learnerx> I can't figure out stack one bit
19:06:42 <koz_> learnerx: What's the exact issue you're having?
19:06:56 <learnerx> I'd like to use this library in my program
19:06:57 <learnerx> https://github.com/mrkgnao/silica
19:07:51 <learnerx> I've put this in my stack.yaml
19:08:30 <learnerx> what I don't understand is where I need to go from here?
19:08:48 <koz_> learnerx: stack build?
19:08:51 <learnerx> (unchanged from the "simple" template)
19:08:59 <learnerx> stack build gives an error
19:09:09 <koz_> Could you paste your stack.yaml?
19:09:57 <learnerx> https://hastebin.com/luhaxetevu.http 
19:10:04 <learnerx> koz_
19:11:32 <koz_> What's the error from stack build?
19:12:45 <learnerx> src\Main.hs:2:1: error:
19:12:46 <learnerx> xe:irc --ghc-options " -ddump-hi -ddump-to-file -fdiagnostics-color=always"
19:12:52 <learnerx> whoops
19:12:59 <learnerx> meant to hastebin that
19:13:51 <koz_> Wait, is that it?
19:14:17 <learnerx> yeah, I assumed there was some other step I had to take, like to modify my .cabal
19:14:50 <koz_> Yeah, you need to add the library to your build-depends.
19:14:52 <koz_> Did you?
19:14:54 <learnerx> I added `import Silica` to my `Main.hs` as well
19:14:56 <learnerx> I did not
19:15:01 <koz_> Yeah, you gotta dot hat.
19:15:06 <koz_> s/dot hat/do that/
19:16:04 <learnerx> then I get this error
19:16:05 <learnerx> https://hastebin.com/yajubasufo.http
19:16:26 <learnerx> here is my new build-depends
19:16:58 <kvda> Still not grokking how Functors applies to kinds that are not *, or * -> *
19:17:24 <kvda> Ok you can pick the outermost a the one to fmap on with * -> * -> *
19:17:29 <mniip> kvda, not sure what you mean by that sentence there
19:17:42 <kvda> But how do you modify the other types?
19:17:49 <mniip> are you talking about regular Data.Functor.Functor
19:18:10 <koz_> learnerx: That library needs an older base than the one you're using.
19:18:20 <kvda> A functor for an Either type makes sense, since the left type is the error type
19:18:21 <kvda> it doesn't hold a value
19:18:24 <koz_> You have 4.11.1.0, and it's hard-capped at 4.10.
19:18:37 <mniip> the Either datatype is not a Functor
19:18:40 <mniip> it's of the wrong kind
19:18:44 <koz_> (it also needs ghc-proofs to be added to extra-deps)
19:18:49 <mniip> @let instance Functor Either
19:18:50 <lambdabot>  .L.hs:163:18: error:
19:18:51 <lambdabot>      • Expecting one more argument to ‘Either’
19:18:51 <lambdabot>        Expected kind ‘* -> *’, but ‘Either’ has kind ‘* -> * -> *’
19:19:04 <mniip> (Either a) has the right kind though, for any a
19:19:08 <mniip> and is a Functor
19:19:18 <kvda> Yes I think I understand that mniip 
19:19:27 <mniip> :t fmap
19:19:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:19:34 <mniip> substitute 'Either x' for 'f'
19:19:48 <mniip> you get a well-kinded function
19:19:48 <kvda> So for Either a value is ingored. 
19:19:55 <mniip> ?
19:20:02 <mniip> what does anything I said have to do with values
19:20:14 <kvda> We have to partially apply Either to make it a functor
19:20:38 <mniip> we partially apply a type constructor
19:20:43 <mniip> no values anywhere nearby yet
19:21:05 <kvda> Does Either a not imply a value?
19:21:07 <geekosaur> ...and base version is a proxy for ghc version, here 4.10 being 8.2.1
19:21:21 <mniip> 'Either a' has the wrong kind for having values
19:21:23 <koz_> And from the looks of it, you're on 8.4.2.
19:21:28 <koz_> (I _think_)
19:21:32 <mniip> to have values you need *
19:21:37 <mniip> which 'Either a' is not
19:21:53 <kvda> is a not a stand in for a value?
19:22:01 <geekosaur> 8.4.2 or 8.4.3
19:22:01 <learnerx> koz_ thanks for your help so far
19:22:19 <koz_> learnerx: To fix this, you might wanna switch to an 8.2 resolver.
19:22:22 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory is useful for this kind of thing
19:22:26 <mniip> kvda, it is a type variable sure but so?
19:22:28 <koz_> Which is the lts-11.* series I think.
19:22:43 <learnerx> woah
19:22:45 <koz_> Yeah, the latest is 11.22.
19:23:01 <learnerx> My resolver is `resolver: lts-12.10`
19:23:06 <kvda> mniip how do you act on that value, as you do on 'b' in the Either type, with fmap
19:23:19 <koz_> learnerx: It seems that library hasn't been updated for GHC 8.4 yet.
19:23:22 <learnerx> are you saying I should downgrade? I'm not sure I understand
19:23:22 <mniip> that's not the question you were asking 5 minutes ago
19:23:25 <geekosaur> right, you need anolder reslver whch specifes ghc 8.2 or earlier
19:23:28 <kvda> It's even more obvious if you larger product types, ie SomeType a b c d
19:23:41 <kvda> d will be the value you act through Functor instance
19:23:46 <kvda> what about a b c?
19:23:47 <mniip> you can't do anything about that with stock Data.Functor.fmap
19:23:54 <koz_> learnerx: that library won't work on GHC 8.4. This means that your resolver (which is what decides what GHC/packages get used) has to be no later than 11.22.
19:24:07 <geekosaur> for this project (you can specify per project; downgrading what you are building here won;'t affect other things)
19:24:10 <learnerx> koz_: for reasons other than the base?
19:24:15 <koz_> You can change it in your stack.yaml, then run stack setup, then stack build.
19:24:19 <kvda> I see, that's essentially my question, it seems like my data model should be changed
19:24:20 <mniip> you can use one of the other kinds of functor classes
19:24:20 <geekosaur> base is hardwired into ghc
19:24:22 <koz_> learnerx: Specifically _because_ of base.
19:24:26 <mniip> Bifunctor, Profunctor, etc
19:24:30 <koz_> The version of base silica can use is _hard capped_ at 4.10.
19:24:32 <geekosaur> you can't run ghc 78.4 with the base from ghc 8.2
19:24:35 <geekosaur> 8.4
19:24:42 <kvda> I've heard of Bifunctor what does Profunctor do?
19:24:45 <mniip> or there's a mechanism which which 'Functor' can be extended to do whatever
19:24:48 <koz_> geekosaur: What year will we have GHC 78.4? :P
19:25:08 <geekosaur> yu'd have to ask whichever simon is in charge then :p
19:25:11 <koz_> (and will it have full dependent typing :P)
19:25:14 <mniip> but that relies on a while flock of haskell extensions and I'm not sure you can find it in a library
19:25:18 <kvda> Is is true then if you have Type a b c d you might consider modelling it differently to get composability with famp?
19:25:31 <learnerx> koz_: I can easily change the `.cabal` file on that package, would changing it to allow `base < 5` be sufficient? 
19:25:33 <kvda> *fmap
19:25:38 <koz_> learnerx: It's not _your_ issue.
19:25:42 <koz_> It's the silica library.
19:25:50 <mniip> kvda, a Profunctor is a functor  C^op x D -> E
19:26:00 <koz_> So unless you wanna fork it and change it manually (and deal with whatever breakages this will cause), that's not an option.
19:26:07 <mniip> it has 2 arguments and is contravariant in the first but covariant in the second
19:26:16 <mniip> as evidenced by the function:
19:26:17 <mniip> :t dimap
19:26:19 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
19:26:19 <learnerx> well when I was debugging this issue I already did that
19:26:27 <koz_> Wait what.
19:26:29 <mniip> contrast with Bifunctor:
19:26:30 <mniip> :t bimap
19:26:31 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
19:26:36 <geekosaur> learnerx, you can try it but that often means incompatiobility. one possible problm here would be the Monoid-Semigroup rearrangement which would cause some older code to not compile
19:26:36 <koz_> So you _forked silica_, and pointed stack at the fork?
19:26:39 <koz_> And it compiled?
19:26:43 <learnerx> not yet
19:27:05 <learnerx> I now have this error when building
19:27:05 <learnerx> In the dependencies for silica-0.1.0.0:
19:27:20 <kvda> Thanks mniip :)
19:27:30 <mniip> kvda, do you have a lot of types of high kinds?
19:27:31 <kvda> It seems like I have to model my types differently 
19:27:42 <mniip> if it's just one consider just writing your own auxiliary functions
19:27:43 <learnerx> I can just not use this library or change my resolver like you suggested
19:28:19 <kvda> mniip , fn like setType (Type a b), getType, etc that act on the 'a'? mniip 
19:28:29 <mniip> no
19:28:43 <learnerx> but koz_ if  this error is easily resolved I'd like to do it that way
19:29:30 <koz_> learnerx: That's the whole point - it's _not_ easily resolved, except by changing the resolver.
19:29:43 <koz_> Which is arguably the 'easiest' way, unless you actually need GHC 8.4.3 for something.
19:29:45 <mniip> kvda, a set of functions Type a b c d -> Type a b c d' , Type a b c d -> Type a b c' d , ...
19:30:05 <mniip> evidencing its functoriality in all arguments you need
19:30:48 <learnerx> koz_: I don't, but for various reasons I have to use my own fork anyway, so if I can get thinks working on that fork on the ghc 8.4.3 that would be best
19:31:08 <learnerx> if not though, I don't need to use the latest version of ghc for this
19:31:12 <kvda> yes that's what i meant mniip. ie. if 'a' is Name then, setName would be setName :: Type a b c d  -> Type a b c d 
19:31:17 <koz_> learnerx: In that case, fork silica, try upping the base bounds, then compiling that.
19:31:24 <koz_> If it builds, point stack to the fork and go from there.
19:31:32 <koz_> If not, then you can think about how to fix it.
19:31:40 <koz_> (or downgrade resolver, one or the other)
19:31:41 <mniip> kvda, that wouldn't be "set"Name
19:31:47 <mniip> it would be mapName
19:31:56 <mniip> (a -> a') -> Type a b c d -> Type a' b c d
19:32:22 <mniip> after all, you might not always have exactly one Name to set
19:32:27 <kvda> Good point
19:32:50 <kvda> So it's essentially an fmap without the instances
19:32:57 <mniip> without the class yes
19:33:12 <learnerx> koz_: it compiles
19:33:23 <kvda> Got it, that's very helpful thanks mniip. It explains certain patterns in Elm too
19:33:30 <koz_> learnerx: After you increased the base bounds?
19:33:44 <koz_> Mind pasting its (modified) .cabal file?
19:34:33 <learnerx> koz_: https://hastebin.com/safozifefu.makefile line 34
19:34:58 <koz_> OK, so now, point stack at your fork and try again.
19:35:18 <learnerx> koz_: that gets me this error
19:35:19 <learnerx> In the dependencies for silica-0.1.0.0:
19:35:28 <koz_> Mind pasting the whole error message?
19:35:33 <koz_> Or is that it?
19:35:36 <learnerx> Error: While constructing the build plan, the following exceptions were encountered:
19:35:37 <learnerx> nsider trying 'stack solver', which uses the cabal-install solver to attempt to find some
19:35:39 <learnerx> dretips\wise_mans_haskell\wise_mans_haskell\haskelltests\projects\irc\stack.yaml:
19:35:49 <koz_> (via a pastebin if you wouldn't mind)
19:36:22 <learnerx> I made a hastebin but forgot to copy the link :') 
19:36:23 <learnerx> https://hastebin.com/xuhiweweno.http
19:36:39 <koz_> Add ghc-proofs to your extra-deps.
19:36:51 <koz_> (in stack.yaml)
19:36:59 <koz_> Since silica needs it, and it's not on Stackage.
19:37:47 <learnerx> koz_: something like ghc-proofs >= 0.1.1?
19:37:52 <learnerx> `ghc-proofs >= 0.1.1`
19:39:08 <koz_> learnerx: That won't work. Read this: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps
19:39:22 <koz_> (short version is 'it needs to be something like 'ghc-proofs-0.1.1')
19:41:38 <learnerx> koz_: this is my build-depends
19:41:41 <learnerx>   build-depends:       ghc-proofs-0.1.1,
19:41:51 <koz_> It needs to be in your stack.yaml.
19:42:04 <koz_> Not your build-depends. It's a dependency of silica, not of your project (unless you're actually using it).
19:42:19 <learnerx> oh jeez
19:42:23 <learnerx> I misread your message
19:44:07 <learnerx> So this is my new extra-deps
19:44:08 <learnerx> extra-deps:
19:44:19 <learnerx> oh wait
19:44:23 <learnerx> ghc-proofs has issues too
19:44:38 <learnerx> this is getting to be too large of a rabbit hole for me to go down
19:45:59 <learnerx> koz_: thanks for your help, I'll just deal with lens
19:46:07 <koz_> learnerx: As I suspected. There's probably a reason that the person who wrote (or maintains, can't tell) the library didn't do it.
19:46:23 <koz_> learnerx: Out of interest, what are you using lens for?
19:46:34 <learnerx> Just trying to learn it
19:46:48 <learnerx> not trying to use it for any particular reason
19:47:03 <texasmynsted> wow there are only 42 people in hackage
19:47:23 <learnerx> In general, can I just change stack.yaml to add a dependancy, or do I always have to change my .cabal
19:47:51 <learnerx> *?
19:48:02 <koz_> learnerx: It depends.
19:48:10 <koz_> If you plan to _use_ the library yourself, then you gotta do both.
19:48:25 <koz_> If it's a dependency that you're not using yourself, just adding it to extra-deps in the stack.yaml's fine.
19:49:16 <learnerx> are there any plans to change this in the future?
19:49:40 <learnerx> I'm used to tools like yarn where I can run a single command to add a dependancy 
19:49:44 <learnerx> I'm used to tools like yarn where I can run a single command to add a dependency 
19:49:48 <learnerx> whoops
19:50:17 <koz_> learnerx: No idea - you'd have to ask the Stack devs, or perhaps someone who knows Stack better than I do.
19:50:23 <koz_> (which is probably most everyone)
19:50:32 <texasmynsted> see there you used multiple commands for one sentince
19:50:45 <koz_> (because my approach to Stack is similar to this: https://xkcd.com/1597/)
19:51:36 <learnerx> koz_ thanks for all your help
19:51:52 <koz_> learnerx: No worries! Good luck with lens.
19:57:16 <cppxor2arr> i always wondered what do i do if im changing some code for a commit/PR and someone's PR gets merged first (affecting same code im changing)
19:58:14 <learnerx> branch, merge in their changes to your branch, merge branch back into master
19:58:38 <marvin2> learnerx, I'm not sure if you already know this, but you only need to add extra-deps line in stack.yaml if package you're using isn't part of stackage. if it is, you just add it to build-depends in your cabal file
19:59:11 <learnerx> marvin2: I did not know that
20:00:14 <lyxia> cppxor2arr: I would rebase then force-push
20:00:42 <cppxor2arr> ok learned something new
20:06:41 <mniip> interesting
20:11:39 <koz_> Under which circumstances should I use the lazy or strict State from mtl? 
20:11:51 <koz_> I'm unsure what the difference would be and under what circumstances.
20:16:32 <learnerx> What's the opinion here of alternative preludes such as RIO? https://github.com/commercialhaskell/rio
21:54:47 <jb55> learnerx: a lot are bad but rio is decent
22:14:41 <cocreature> learnerx: it depends on whether you want to build a public library that other people depend on or some internal lib or an executable. in the latter case alternative preludes are perfectly fine if you feel like they help you. in the former case, I wouldn’t use an alternative prelude that actually makes fundamental changes (there are alternative preludes that mostly just reexport things and those are fine in
22:14:43 <cocreature> this case)
22:41:27 <mniip> I never realized before
22:41:29 <mniip> but
22:41:52 * nitrix holds his breath
22:42:03 <mniip> the covariant powerset endofunctor is actually lax monoidal in Set over cross product
22:42:16 * nitrix pffffffftttttt.
22:42:24 <mniip> and, say, language concatenation is just liftA2 word concatenation
22:44:05 <mniip> list builder notation <-> set builder notation
22:44:10 <mniip> [] <-> covariant powerset
22:44:55 <mniip> is the powerset a monad?
22:44:56 <mniip> probably
22:45:11 <mniip> actually yes why not
22:45:41 <mniip> composition in Kleisli(powerset) (the category of nondeterministic functions) is definitely associative
22:45:42 <nitrix> Proofs!
22:47:05 <nitrix> mniip: I just want you to know you make me feel really dumb right now :P
22:47:59 <mniip> return(a) = {a}
22:48:11 <mniip> bind(a, f) = {y | x in a, y in f(x)}
22:50:24 <osa1> in haskell-gi is there a way to see all attributes available for an object type? I just created a TreeStore but I'm not sure how to set the column types on initialization.
22:57:04 <mniip> actually screw bind
22:57:13 <mniip> join(a) = {y | x in a, y in x}
23:00:37 <cocreature> osa1: the bindings are autogenerated afaik so the official docs should help https://developer.gnome.org/gtk3/stable/GtkTreeStore.html
23:00:50 <cocreature> osa1: see https://github.com/haskell-gi/haskell-gi#translating-from-the-c-api-to-the-haskell-gi-generated-api for how names are translated
23:01:31 <osa1> cocreature: I'm already looking at that page, but AFAICS it doesn't tell what the attribute name is for column types
23:01:43 <osa1> cocreature: maybe there isn't an attribute for it, I don't know
23:03:01 <osa1> this seems to work: #setColumnTypes tree_store []
23:03:14 <osa1> but I can't do tree_store <- new Gtk.TreeStore [ #columnTypes := [] ]
23:06:00 <cocreature> osa1: my understanding is that the second syntax only works for properties and judging from the docs columnTypes isn’t a property
23:15:41 <typetetris> learnerx: I found protolude to be convincing and it doesn't entails lots of dependencies, like other prelude alternatives do.
23:27:08 <typetetris> Somebody goes to haskell exchange in london in two weeks?
23:46:40 <kosmikus> typetetris: yes :)
23:51:31 <typetetris> kosmikus: What talk are especially looking forward to?
