00:27:45 <dyl> monochrom: I find it really depends on the subject matter and speaker.
00:28:22 <dyl> Even within a specific area like “FP/Haskell concepts”. 
00:35:19 <maerwald> pie_: I do haskell coding on nordic viking music xD
00:35:52 <maerwald> I think it fits the strong type system
00:36:26 <pie_> maerwald, WOO-OH-OH, WOO-OH-OH, WOO-O-O-O-OOOOOO
00:51:26 --- mode: glguy set +v dataN
00:51:31 --- mode: glguy set -v dataN
00:52:36 <dataN> are overlapping instances completely disallowed now? getting a "Duplicate instance deceleration"...
00:53:26 <dataN> https://lpaste.net/5178317476080910336
00:54:02 <dataN> declaration*
00:55:17 <dataN> expecting them to be matched in top down order... 
01:02:29 <cocreature> dataN: yes they are allowed (and have been disallowed in the past). if one of the instance heads is more specific than the other you can use OVERLAPPING/OVERLAPPABLE pragmas but that’s clearly not the case here
01:03:48 <dataN> -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS
01:03:55 <dataN> hmm, ok
01:04:47 <dataN> I guess thats why its not giving advice to use the OverlappingInstances Language extension anymore 
01:05:36 <dataN> cocreature: will it then match top down as desired? 
01:06:30 <dataN> oh, actually it gives the same error just with an [overlap ok] statement 
01:08:47 <dataN> the idea was to use ImplicitParams in the more elaborate undecidable overlapping constraint, and have the more simple constraint provide these ImplicitParams
01:09:35 <dataN> so that when the ImplicitParams were not specified, it would definitely choose the instance with the simple constraint
01:11:28 <dataN> but then when the class method of the instance with simple constraint calls itself with the provided ImplicitParams, then it might enter a loop unless it can definitely use the instance that also requires the ImplicitParams are provided.
01:12:33 <cocreature> dataN: as I mentioned overlapping instances only help if one of the instance heads is more specific
01:12:38 <cocreature> your instance heads are the same
01:12:49 <cocreature> and “top down” doesn’t make sense in the precence of multiple modules
01:13:12 <dataN> yeah but UndecidableSuperclasses wouldnt work over several modules
01:13:41 <dataN> the idea with these Undecidable loops is to put all the instances together like in a closed type family 
01:15:59 <dataN> also, using this approach, the ImplicitParams would be used as a flag to provide an interface that other classes could use to disambiguate instances. so this hack would only need to be used here and it would then mean it would solve this issue everywhere else
01:17:47 <dataN> if a method was called without the ImplicitParams in scope, then the default instance would provide them, otherwise, the ImplicitParams can be provided to access the alternative definitions
01:18:23 <dataN> without the option of providing an Overlapping Undecidable default, then a class couldnt be used unless the ImplicitParams were provided
01:19:53 <dataN> as the instance must match over an unaltered type, there seems to be no way to make a more specific instance head, and the diambiguation must rely on the constraints
01:24:25 <dataN> admittedly, the ImplicitParam can be fo the form Maybe... so that it would mean the use only has to write Nothing as the ImplicitParam, but it would be good if there was a way that this could be provided in the way described to avoid this, so that existing code without having to add the ImplictParam around the call site to this existing code.
01:25:23 <dataN> user*
01:25:42 <dataN> so that existing code can be used without*
01:29:50 <dataN> such a flag should be seen as an extension, providing extra information to an instance, if the Maybe.. ImplicitParams have to be provided, then providing Nothing as an ImplicitParam, seems like its a restriction... but other than that I guess the user just has to provide these. 
01:30:26 <dataN> returning later with demonstration of this. maybe a good thing its not able to use this overlapping hack.
01:57:51 --- mode: glguy set +v nokomprendo
03:05:00 <maerwald> oh boy, now the useless bumping base upper version bound starts again
03:05:10 <maerwald> this is really not how things should be done
03:05:27 <maerwald> it slows down migration and ghc updates
03:07:41 <vilu> Hi, lately I'm working a bit with #purescript, it seems as if the IRC channel is very inactive. I've read that functionalprogramming.slack.com could be more active. However, seems like I need an invite. Can anyone help?
03:12:04 <koz_> maerwald: What's this in reference to?
03:12:34 <maerwald> koz_: the ghc-8.6.1 release?
03:12:56 <koz_> maerwald: Oh wait, that's happening? When?
03:19:47 <maerwald> yes
03:43:47 <lavalike> vilu: https://fpchat-invite.herokuapp.com
04:32:57 <vilu> Thanks
04:38:09 <hexagoxel> what is the real, non-404 ghc-8.6.1 download link?
05:15:24 <aurieeeh> Hello! Is there something like `maybeToEither :: Maybe a -> Either () a` or `maybeToEither :: e -> Maybe a -> Either e a` in base? It feels like such a common function.
05:18:26 <xacktm> @hoogle Maybe a -> Either e a
05:18:27 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
05:18:27 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
05:18:27 <lambdabot> Data.Either.Combinators rightToMaybe :: Either a b -> Maybe b
05:18:51 <xacktm> hmm not that hoogle can see
05:18:52 --- mode: glguy set +v dataN
05:19:02 --- mode: glguy set -v dataN
05:19:37 <dataN> so apparently ImpicitParams cant be used in calsses or instances, but Print seems to use something that might do.
05:19:52 <dataN> cant undertand the following though; instance (flag ~ HFalse) => ShowPred a flag
05:19:58 <dataN> of; https://wiki.haskell.org/GHC/AdvancedOverlap
05:20:25 <dataN> since the only instances defined return HTrue, e.g. instance ShowPred Int  HTrue
05:20:57 <dataN> how does it manage to have a default value with no instance defined?
05:24:21 <xacktm> @hoogle e -> Maybe a -> Either e a
05:24:22 <lambdabot> Control.Error.Safe justErr :: e -> Maybe a -> Either e a
05:24:22 <lambdabot> Control.Error.Util note :: a -> Maybe b -> Either a b
05:24:22 <lambdabot> Data.Either.Extra maybeToEither :: a -> Maybe b -> Either a b
05:24:34 <dataN> the example uses TypeCast so its not obvious if this is just an omission 
05:24:43 <xacktm> aurieeeh: check out Data.Either.Extra
05:25:51 <dataN> the example that uses type families has a catchall;   ShowPred a     = HFalse
05:26:08 <dataN> of; type family ShowPred a where
05:26:16 <dataN> (closed type family) 
05:26:47 <dataN> but the example using OverlappingInstances has no corresponding statment 
05:28:47 <hexagoxel> dataN: `instance (flag ~ HFalse) => ShowPred a flag` is a catch-all too, no?
05:29:33 <dataN> haxagonel: but there is nothing which returns HFalse
05:31:09 <dataN> infact, it simply states that as this cant be satisfied, "the other constraint, Print' flag a, will be checked"
05:33:10 <dataN> ohh, is it the kind that is checked by the equality ~
05:34:51 <dataN> so that the constraint in '(HTrue ~ HFalse) => ShowPred a flag' is satisfied where an instance for instance 'ShowPred a HTrue' exists for some 'a'
05:35:13 <dataN> (which seems counterintuitive)
05:36:04 <dataN> sorry, those are quote marks, not promotion symbols... probably should start using `quote'
05:36:43 <hexagoxel> no, that instance does not apply, because it is overlapped by the more specific instances below
05:36:54 <hexagoxel> `instance ShowPred Int  HTrue` etc.
05:37:09 <dataN> no thats infix
05:38:39 <dataN> then the line `instance (flag ~ HFalse) => ShowPred a flag' is redundant?
05:39:21 <hexagoxel> no, it applies whenever there is no overlapping instance
05:39:48 <dataN> oh, it *sets* flag equal to HFalse?
05:40:59 <dataN> otherwise, how can it apply? if no instance returning HFalse is ever provided?
05:41:50 <dataN> (flag ~ HFalse) seems like it can never be satisfied 
05:42:30 <hexagoxel> i think reading that instance as "setting" the flag is correct.
05:43:01 <hexagoxel> why? why could flag not be HFalse?
05:45:04 <hexagoxel> (and fyi markdown uses `these` for inline quotes, and imo `this' does not help because `this'` is a valid identifier in haskell.
05:45:08 <hexagoxel> )
05:46:01 <dataN> because no instance returning HFalse is ever written 
05:46:28 <dataN> it says;
05:46:29 <dataN>  Since the first constraint didn't resolve with flag = HTrue, Print' HTrue a will not be satisfied. However, Print' HFalse a allows us to unify (flag ~ HFalse) in the ShowPred a constriaint. Consequently the whole constraint is satisfied.
05:47:14 <dataN> it seems to run the equality inference backwards and essentially provide this instance !?
05:47:50 <hexagoxel> (are you mixing up solutions 1 and 2?)
05:48:23 <dataN> no, avoiding 2, using 1 3 and 4
05:48:50 <dataN> well actually no, also not using type familes, but some of the comments seems like they refer to 1
05:49:40 <dataN> not using type families because they I'm aware of any way they can be reified
05:49:49 <dataN> but nvm that
05:51:13 <dataN> (possibly using associated types of locally instantiated classes...)
06:01:07 <dataN> hexagonel: is there any way to explain this curious inference? 
06:03:26 <hexagoxel> dataN: regarding "essentially provide this instance" - no, the instance was there: »instance (flag ~ HFalse) => ShowPred a flag«. only its context was not satisfied just yet.
06:04:43 <hexagoxel> i am really not sure i can explain it better than that paragraph you quote, to be honest :(
06:06:12 <hexagoxel> perhaps writing out the steps when there is no Show/ShowPred HTrue instance would be helpful?
06:07:24 <dataN> "the instance" was "its context"
06:07:51 <dataN> so anyway, it somehow satisfies this context
06:08:07 <dataN> if not by providing an instance, then how?
06:08:15 <hexagoxel> 1) looking for Print a, where there is no Show a
06:08:30 <hexagoxel> 2) must satisfy (ShowPred a flag, Print' flag a)
06:09:48 <hexagoxel> 3) there are no overlapping instances, so there only is »instance (flag ~ HFalse) => ShowPred a flag«
06:10:04 <hexagoxel> 4) must satisfy (flag ~ HFalse, Print' flag a)
06:11:36 <dataN> hmm, still just meaning 1)
06:12:19 <dataN> certainly the closed type familes version is totally clear
06:13:34 <dataN> oh, those are the steps the complier takes, sorry
06:13:50 <dataN> compiler*
06:16:52 <hexagoxel> 5) there is »instance Print' HFalse a«, which resolves that
06:17:28 <dataN> so somehow the constraint of 2) has been rewitten to that of 4), using 3) which is not satisfied...
06:17:43 <hexagoxel> i _think_ the functional dependency does not need to be mentioned in that process, although i might be wrong.
06:18:10 <dataN> hmm? whats that, the defintion of TypeCast right at the bottom?
06:19:21 <hexagoxel> how is it not satisfied? i added the »flag ~ HFalse« constraint.
06:24:40 <dataN> so why not just write 'instance (flag ~ HFalse) => ShowPred a flag' as 'instance ShowPred a HFalse'
06:25:06 <dataN> this would overlap everything else right?
06:25:38 <hexagoxel> because functional dependency
06:25:44 <dataN> so is this using the order the compiler checks the constraints?
06:25:59 <dataN> im not sure what about functional dependency 
06:29:54 <hexagoxel> you can try it yourself. see what errors you get if you write »ShowPred a HFalse« or if you omit the functional dependency entirely.
06:32:28 <c50a326> if you've got a type like a representation of RGB, so 3 ints in a triple, is it better to just use [Int,Int,Int] rather than (Int,Int,Int), since they're all the same type them being workable Functor etc is useful?
06:33:04 <hpc> [Int, Int, Int] isn't a thing
06:33:21 <hpc> i would think about what i am trying to express, here
06:33:25 <c50a326> sorry lol [Int] I mean
06:33:33 <hpc> rather than if it behaves the same when compiled
06:33:41 <hpc> use [a] for a variable number of the same type of thing
06:33:53 <hpc> use (a, b, c) for a known number of different types of things
06:33:58 <hpc> RGB is a known size, 3 elements
06:34:10 <hpc> and if you sort of squint, each color is a different thing
06:34:28 <c50a326> well they're all 256-bit ints aren't they?
06:34:34 <hpc> maybe in the future for some reason you need some weird CMYK colorspace with fewer bits for K or whatever
06:34:41 <c50a326> I just want to practice some number distribution stuff on RGB values
06:34:42 <Ariakenom> c50a326: data Vec3 a = Vec3 a a a
06:34:59 <Ariakenom> is a type that's used
06:35:33 <hpc> Vec3 is another idea, or you can decide you don't want to reason about anything less than the RGB triple itself
06:35:39 <hpc> and make data RGB = RGB Int Int Int
06:36:49 <hpc> in general in programming, deciding between equivalent representations is a communication problem
06:38:17 <dataN> c50a326: you shouldnt use Int, but a nested Either () 256 long...
06:39:03 <hpc> dataN: nested Either Void, all we need is the constructor choice :P
06:39:52 <c50a326> oh cool, `newtype RGB = RGB Int Int Int` can derive Functor
06:40:17 <hpc> eh? that's a kind error
06:40:35 <mniip> that's neither a newtype nor a correctly kinded deriving declaration
06:40:36 <c50a326> oh shit yeah sorry, the check thing in my editor didn't work until after I deleted some stuff
06:40:46 <hpc> hehe
06:41:12 <hpc> one of my favorite ways to debug someone else's problem is to just type "lakjhsdflkjahsdlkjhasdlkjhaslkdjh" into their text editor and see if it still compiles and runs
06:41:20 <c50a326> yeah,     • Cannot derive well-kinded instance of form ‘Functor (RGB ...)’
06:41:29 <c50a326> oh well, maybe I can write the instance myself
06:41:54 <mniip> c50a326, good luck with that I guess?
06:42:25 <c50a326> oh yeah it'd need to be `data RGB a`
06:44:03 <c50a326> Can't make a derived instance of ‘Functor RGB’: You need DeriveFunctor to derive an instance for this class
06:45:30 <c50a326> this works at least https://ptpb.pw/y3ez/hs
06:47:04 <dataN> hpc: Free but with a Nat parameter?
06:47:37 <dataN> (to indicate depth of nesting...)
06:48:18 <Ariakenom> c50a326: add {-# LANGUAGE DeriveFunctor #-} to top of file?
06:48:36 <Ariakenom> but wait why would that be necessary
06:48:46 <dataN> so with functional dependencies, how do they work anyway? there is no specifying how the inference is made, does it just satisfy the compiler?
06:49:05 <ggVGc> how can I write this better to not need the restConnsTmp binding? https://gist.github.com/b2c593ef517765c2375f3d450bbc0ff0
06:49:15 <ggVGc> I find code like this very error prone, but I don't know how to do better :(
06:49:22 <hpc> dataN: class Foo determining determined | determining -> determined
06:49:40 <hpc> after the pipe is what specifies the inference
06:50:21 <hpc> whenever it sees a value for determining, it looks at the instances in scope to see if it can pick a value for determined
06:50:30 <hpc> er, it being the compiler
06:51:09 <dataN> hexagonel: the error without the fundep is; Could not deduce (ShowPred a flag0)       from the context: (ShowPred a flag, Print' flag a)         bound by an instance declaration:                    forall a flag. (ShowPred a flag, Print' flag a) => Print a
06:52:04 <hpc> without any further constraints on flag, it could be anything
06:52:11 <hpc> it's like doing (show 0) :: String
06:52:15 <hpc> it could be "0" or "0.0"
06:52:44 <hpc> if you had say, class Print' flag a | a -> flag, or something like that
06:52:56 <dataN> yeah thats right
06:52:59 <hpc> then when it examines the type of whatever that operation is, it goes "i know what a is"
06:53:11 <hpc> follows the fundep to "i will also know what flag is", and it's satisfied
06:53:36 <hpc> the cost is that when you write instances of Print', every 'a' can only have one corresponding 'flag'
06:53:42 <dataN> are associated types make this explict?
06:54:36 <hpc> associated types don't appear in the signature of the class, and are determined by every class parameter
06:55:08 <hpc> so like, class Foo a b c where type D it'stooweekendyformetorememberthis
06:55:30 <hpc> is pretty close to class Foo a b c d | a b c -> d
06:55:40 <dataN> oh ok
06:56:00 <hpc> there's some nuance to it which i never learned properly, i don't write these sorts of type classes very often
06:56:20 <dataN> somehow the fundep in the above example made a type equality bind an instances that was not ever provided...
06:57:11 <dataN> i.e. in Solution 1. of https://wiki.haskell.org/GHC/AdvancedOverlap
06:57:26 <dataN> all the instances are of the form; instance ShowPred Int  HTrue
06:57:30 <dataN> never ending in HFalse
06:57:55 <dataN> yet somehow ; instance (flag ~ HFalse) => ShowPred a flag 
06:59:56 <hpc> ah
07:00:07 <hpc> that has... OverlappingInstances?
07:00:20 <hpc> so it resolves overlap by specificity
07:00:30 <hpc> things with variables are less specific than things with actual types
07:00:32 <dataN> is passed by the fundep on ShowPred to determine 'flag' from 'a'
07:00:47 <dataN> to instance (ShowPred a flag, Print' flag a) => Print a where
07:00:57 <hpc> so when it sees ShowPred Int, it picks the instance where it's Int instead of where it's a
07:01:09 <hpc> then follows the fundep and determines flag ~ HTrue
07:01:11 <dataN> and used by;  instance Print' HFalse a where
07:02:42 <dataN> recall; class ShowPred a flag | a->flag
07:04:33 <dataN> so 'Print a' tries to satisfy its constraints, and fails to show that flag ~ HTrue if no instances are defined of ShowPred for 'a'.
07:05:07 <dataN> but somehow manages to use this to invoke the Print' HFalse a instance
07:06:32 <dataN> somehow it uses this with 'instance (flag ~ HFalse) => ShowPred a flag'
07:07:10 <dataN> so this is used *unless* it can prove flag ~ HTrue
07:07:41 <dataN> but i dont get how it defers this check, it seems like it must be something to do with the order the compiler checks everything
07:08:38 <dataN> i.e. whyisnt it used when there *are* instances of 'ShowPred a HTrue' for some 'a'
07:08:59 <hpc> overlapping instances are selected by specificity
07:09:46 <dataN> whats that mean?
07:10:17 <hpc> Capital Letter Types are more specific than lower case variables
07:10:33 <hpc> and there are various rules for deciding if an instance as a whole is more or less specific using that logic
07:10:35 <dataN> awesome hack
07:10:41 <lyxia> dataN: have you read https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
07:12:21 <dataN> "An instance declaration is more specific than another iff the head of former is a substitution instance of the latter"
07:12:39 <hpc> ah that's what it was
07:15:16 <dataN> ah so thats what IncoherentInstances is, why neither is more specific. 
07:15:21 <dataN> when*
07:15:30 <dataN> maybe this can be applied to; https://lpaste.net/5178317476080910336?
07:15:32 <dataN> https://lpaste.net/5178317476080910336
07:15:33 <dataN> ?
07:16:04 <dataN> but there is a problem about the constraints there, maybe something with equalities could help?
07:16:35 <Lycurgus> why did you repeat that URL?
07:16:44 <oldandwise> curious, is there a character-based diff tool? Not line-based
07:17:08 <lyxia> does diff not have an option for that
07:17:50 <oldandwise> lyxia: all diff tools i've known have lines as the atoms
07:18:08 <Lycurgus> aren't all diff tools character based?
07:18:32 <Lycurgus> (excluding binary)
07:19:03 <oldandwise> line-based diff tool could not zoom-in into what has change in a line. It just decides, the line is no longer the same
07:19:25 <oldandwise> all diff tools are like that.. they are all line-based
07:20:47 <Lycurgus> if you say so, I'm just old
07:21:12 <hpc> all diff tools are diff tools
07:22:35 <barrucadu> git can do "word diff", where it highlights changes in a line
07:22:57 <barrucadu> I'd be surprised if no other diff tool could
07:26:31 <oldandwise> ok.. just found 'meld'
07:29:11 <dataN> so the type equality hack is that by matching on a polymorphic variable fixed by an equality constraint context, it is less specific than if the type it is set equal to were used in the instance head rather than the context. 
07:29:37 <dataN> and so it is matched after the more specific OverlappingInstances
07:30:30 <dataN> and in this way can serve as a catchall for when an instance is not provided
07:37:56 <dmwit> http://hackage.haskell.org/package/Diff takes arbitrary Eq a => [a]'s, and so can be character-based or line-based at your pleasure.
07:38:03 <dmwit> But the person who cares is gone, I suppose.
07:42:43 <ggVGc> what have I made here? applySnd ::  (b -> c) -> (a, b) -> (a, c)
07:42:43 <ggVGc> applySnd f (a, b) = (a, f b)
07:43:37 <dmwit> > fmap f (a, b)
07:43:39 <lambdabot>  error:
07:43:39 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M688806465579...
07:43:39 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
07:43:47 <dmwit> > fmap f (a, b) :: (Expr, Expr)
07:43:49 <lambdabot>  (a,f b)
07:44:33 <dmwit> ggVGc: See also: Data.Bifunctor.{first,second}
07:45:33 <ggVGc> hm, why is the Functor implementation of (a, b) to apply it to the second argument?
07:45:54 <dmwit> Neat, TIL about Data.Semigroup.ArgMin
07:46:10 <dmwit> ggVGc: Just look at the type. No other choice.
07:46:14 <dmwit> :t fmap
07:46:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:46:25 <dmwit> :t fmap @((,) x)
07:46:26 <lambdabot> error:
07:46:27 <lambdabot>     Pattern syntax in expression context: fmap@((,) x)
07:46:27 <lambdabot>     Did you mean to enable TypeApplications?
07:46:36 <dmwit> % :t fmap @((,) x)
07:46:36 <yahb> dmwit: ; <interactive>:1:12: error: Not in scope: type variable `x'
07:46:43 <dmwit> % :t fmap @((,) _)
07:46:43 <yahb> dmwit: (a -> b) -> (w, a) -> (w, b)
07:47:27 <mniip> % :t first @(,)
07:47:27 <yahb> mniip: ; <interactive>:1:1: error: No instance for (Arrow (,)) arising from a use of `first'
07:47:36 <mniip> % :t Data.Bifunctor.first @(,)
07:47:37 <yahb> mniip: (a -> b) -> (a, c) -> (b, c)
07:47:42 <mniip> % :t Data.Bifunctor.second @(,)
07:47:42 <yahb> mniip: (b -> c) -> (a, b) -> (a, c)
07:48:03 <mniip> on the other hand there's the cartesian structure of Hask
07:48:09 <mniip> % :t Control.Arrow.first @(->)
07:48:09 <yahb> mniip: (b -> c) -> (b, d) -> (c, d)
07:48:13 <mniip> % :t Control.Arrow.second @(->)
07:48:13 <yahb> mniip: (b -> c) -> (d, b) -> (d, c)
07:48:18 <dmwit> ggVGc: There is a Functor instance for `(,) x _`. There is no Functor instance for `(,) _ x` because we don't have syntax in Haskell for that. We don't have syntax in Haskell for that because the obvious way to allow that kind of thing in general would make type inference need higher-order unification, which is undecidable.
07:51:09 <ggVGc> dmwit: thanks!
07:51:29 <ggVGc> well, now this works, without the temporary binding.. but I find it highly unreadable, https://gist.github.com/b2c593ef517765c2375f3d450bbc0ff0
07:51:32 <ggVGc> :(
07:52:01 <ggVGc> afer years of haskell on and off, I still struggle with writing readable code
07:53:05 <Lycurgus> meld is basically same as kdiff3 et all but it looks nicer
07:53:12 <Lycurgus> *et. al.
07:54:04 <lavalike> ggVGc: how about:  resolveRepeaterConnections repeaterID = filter (isConnectedFrom repeaterID) . filter (isConnectedTo repeaterID)
07:54:12 <Lycurgus> and the superior gui amounts to superior function albeit the other program is more solid
07:54:59 * Lycurgus didn see oldandwise's departure
07:55:00 <dmwit> ggVGc: This looks a lot like http://hackage.haskell.org/package/fgl-5.6.0.0/docs/Data-Graph-Inductive-Graph.html#v:delNode to me
07:55:11 <lavalike> ggVGc: you can make it harder to read by smushing the predicates together with liftM2 (&&) but I wouldn't worry about that (:
07:55:46 <lavalike> oh I might have gotten the predicates backwards, but you get the idea
07:56:13 <dmwit> But lavalike's suggestion is very nice and a much less intrusive modification. =)
08:00:44 <dmwit> ggVGc: And by the way, I see no problem with creating extra bindings in the name of readability. Giving a good, descriptive name to a subterm does a ton for readability and the whole point of laziness is that it has no performance cost.
08:04:48 <infinisil> dmwit: I don't know what higher-order unification is, but isn't it (like many things) only undecidable *in general*?
08:05:54 <dataN> ok
08:06:00 <dataN> here is the solution; https://lpaste.net/1392328023977492480
08:06:59 <dataN> to compare with; https://lpaste.net/5178317476080910336
08:13:44 <Myrl-saki> @pl (==) <$> filter (not . isDigit) <*> filter (not . isDigit)
08:13:44 <lambdabot> (==) <$> filter (not . isDigit) <*> filter (not . isDigit)
08:13:52 <Myrl-saki> Well, he's not wrong.
08:14:09 <sud0> lol
08:14:19 <Myrl-saki> @pl liftA2 (==) ( filter (not . isDigit)) ( filter (not . isDigit))
08:14:19 <lambdabot> liftA2 (==) (filter (not . isDigit)) (filter (not . isDigit))
08:14:39 <Myrl-saki> Oh right. I remember now. I use liftA2 join.
08:16:11 <Myrl-saki>  filter (not . isDigit)
08:16:13 <Myrl-saki> Er
08:16:15 <Myrl-saki> :t join (liftA2 (==)) (filter $ not . isDigit)
08:16:16 <lambdabot> [Char] -> Bool
08:16:40 <Myrl-saki> This still feels wrong, I feel like there was something better.
08:16:43 <lavalike> Myrl-saki: the other way around: filter (liftM2 (&&) pred1 pred2)
08:17:52 <lavalike> > filter (liftM2 (&&) even (>10)) [1..20]
08:17:54 <lambdabot>  [12,14,16,18,20]
08:18:19 <Myrl-saki> lambdabot: Nice. :P
08:18:24 <Myrl-saki> lavalike: **
08:18:32 <Myrl-saki> lavalike: Why would you have 2 common characters with lambdabot? :P
08:18:41 <lavalike> (:
08:29:05 <dminuoso> && looks weird with fira code.
08:44:27 <dmwit> infinisil: What is the distinction between "undecidable" and "undecidable in general"?
08:46:20 <infinisil> dmwit: Many problems are only undecidable in general, but have many special cases that are decidable
08:46:38 <infinisil> "undecidable" doesn't specify that
08:47:56 <dmwit> It is probably worth a publication to carve out some interesting, nontrivial extension to Haskell's typeclass mechanism that allows `Functor ((,) _ x)` and remains decidable.
08:48:00 <dminuoso> infinisil: As in "the halting problem is only undecidable in general, but possibly decidable for some specific program"?
08:48:14 <infinisil> dminuoso: Yea
08:48:34 <dmwit> Like I said: "the *obvious* way to extend Haskell leads to an undecidable problem".
08:48:43 <dmwit> If you have a nonobvious way, by all means advocate for it.
08:49:20 <lyxia> for any specific program it either terminates or it doesn't
08:49:31 <infinisil> Ah, I guess undecidable has "in general" in it's definition (from wiki): "an undecidable problem is a decision problem for which it is proved to be impossible to construct an algorithm that always leads to a correct yes-or-no answer"
08:49:47 <lyxia> So it doesn't seem meaningful to say whether the halting problem is "decidable" for a given program.
08:50:22 <dminuoso> lyxia: Not quite because you still have the variability of the input.
08:51:00 <dminuoso> I may be misunderstanding something here.
08:51:01 <lyxia> dminuoso: replace "for any specific program" with "for any specific program and input" in my sentence then
08:51:06 <dminuoso> lyxia: Ah.
08:52:14 <tsaka__> Say you have a data struct with some int fields. Is it possible to construct a function which takes such a struct and a 'getter'-function for accessing an int-field,  and increments the int?
08:52:34 <dmwit> tsaka__: This is the exact problem space that the lens package sits in.
08:52:53 <dmwit> A lens is, to summarize to the point of incorrectness, a bundled-together getter and setter.
08:54:08 <maerwald> to me, a lens is something that breaks my hasktags :P
08:54:35 <maerwald> (jk... well, actually not, but it was a joke)
08:55:02 <tsaka__> I see. So it's not a trivial task to construct such a function without lenses
08:55:06 <dminuoso> tsaka__: It quite is.
08:55:18 <dminuoso> tsaka__: lens just abstracts it away into a composable way of dealing with nested updates and queries.
08:55:27 <dminuoso> And extends the idea so much further.
08:55:42 <dminuoso> tsaka__: But you dont need it if you just want to update a single field. :)
08:56:02 <dminuoso> % data Some = Some { a :: Int, b :: Int, c :: Int }
08:56:02 <yahb> dminuoso: 
08:57:38 <tsaka__> data Stats = Stats { x :: Int, y :: Int }
08:57:40 <tsaka__> incrStats :: (Stats -> Int) -> Stats -> Stats
08:57:41 <tsaka__> incrStats getter = ?
08:58:06 <dminuoso> tsaka__: Oh. Yes then lens like dmwit said.
09:03:09 <sud0> is there a way to use forkIO for other rather than IO ()
09:03:18 <sud0> in my case it's a Net () monad
09:04:43 <sud0> nevermind, I'm dumb.
09:05:05 <dminuoso> sud0: There is forkIO in unliftio if that helps =)
09:49:21 <i-am-the-slime> Is there any way to generate a hoogle database for no more or less than what's in the current project?
10:07:16 <growpotkin> Hey is there some list comprehension magic that behaves like a "choose" combination. ex : Make a pair combination of all members of a list. [ (x,y) | y <- (delete x list) | x <- list ] but like, less ugly?
10:08:52 <dmj`> growpotkin: thats a cartesian product
10:09:10 <dmj`> > (,) <$> [1..3] <*> [1..3]
10:09:13 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:09:27 <cocreature> growpotkin: sadly there isn’t. Cale has been fighting for getting a "select" function into base but it never happened
10:09:29 <dmj`> growpotkin: what are you trying to filter out
10:10:08 <cocreature> growpotkin: https://mail.haskell.org/pipermail/libraries/2008-February/009270.html provides an implementation that you can copy in your project
10:10:25 <growpotkin> I have just been writing a lot of permutation and combination stuff lately and have run into this type of thing a lot
10:10:39 <growpotkin> the existing list comprehension is SO close to being perfect for this
10:11:04 <growpotkin> thank y'all :)
10:11:30 <cocreature> growpotkin: the selectSplit function in that same post might also be useful
10:11:39 <growpotkin> this is perfect 
10:11:42 <growpotkin> ty cocreature
10:19:51 <Welkin> who else is going to strangeloop?
10:21:28 <deltasquared> haven't spotted a channel specifically for cabal, so asking here, first time usage of cabal, what would be the best way to set up a system wide cabal cache of sorts?
10:21:34 <glguy> I'll be at ICFP (which is co-located)
10:21:47 <deltasquared> specifically, I'm using linux and I'd rather not have cabal's stuff in my home directory is all.
10:22:19 <Welkin> The Little Typer was just released a couple days ago. Has anyone rwad it yet? It teaches dependent types using scheme.
10:22:26 <Welkin> read*
10:22:34 <deltasquared> I could try making a special user for that and symlinking to that user's .cabal dir I guess, though I was wondering if that would have any caveats.
10:22:58 <dmj`> deltasquared: sounds like you want something like nix which constructs GHC package lists and stores them in an isolated location
10:23:12 <deltasquared> gah, why did I know nix was going to be brought up xD
10:23:15 <Welkin> hi dmj` 
10:23:17 <dmj`> deltasquared: but cabal new-build has nix-style local builds now
10:23:20 <dmj`> Welkin: o/
10:23:36 <Welkin> cabal new-* is awesome
10:23:43 <deltasquared> one moment, still having to read manual pages
10:23:50 <dmj`> deltasquared: https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
10:24:15 <cocreature> you can use --store-dir to change the location of the store if you really don’t want it to be in ~/.cabal/store
10:24:24 <deltasquared> ah, building targets inside the project directory... hmm
10:24:33 <glguy> GHC 8.6.1 and cabal-install 2.4.0.0 are out now. The updates to cabal-install make new-* better still
10:24:38 <deltasquared> cocreature: would it be a case then of getting ghc and ghci to pick up that dir
10:24:41 <monochrom> dmj`: "nix-style" is not nix.  But look for "nix integration" instead.
10:24:56 --- mode: glguy set +v dataN
10:25:25 <dmj`> monochrom: right, nix-style has nothing to do with nix, but the concept of project isolation
10:25:52 <cocreature> deltasquared: as long as you work in a cabal project it will invoke ghc correctly
10:26:15 <deltasquared> cocreature: I see. I have to admit thus far I have largely not looked into proper project files
10:26:45 <cocreature> you can make it work with ghc/ghci directly but learning to work with projects is a better way to spend your time imho
10:26:45 <dmj`> deltasquared: nix absolves you from using cabal (the executable) entirely, and you can simply call runghc Setup.hs —build 
10:26:58 <deltasquared> re: no project files, partly because until now I've been able to rely just on the ghc-static collection in arch linux.
10:27:45 <dmj`> deltasquared: Arch and nix do not work well together at all
10:27:47 <deltasquared> but now I really want to play with https://hackage.haskell.org/package/refined
10:27:49 <dmj`> just fair warning
10:28:01 <Welkin> arch and haskell do not work well together
10:28:03 <MarcelineVQ> dmj`: Why not?
10:28:05 <deltasquared> dmj`: I've managed to get it sort of working before now, though no shared user support
10:28:13 <deltasquared> Welkin: oh?
10:28:15 <dmj`> deltasquared: nix-shell -p ‘haskellPackages.ghcWithPackages (p: with p; [ refined ])’ 
10:28:21 <cocreature> arch & nix work together just fine. I’ve used that setup for months
10:28:42 <dmj`> The install didn’t work ootb IIRC
10:28:43 <cocreature> and arch & haskell also work together fine. what can cause problems is installing Haskell packages via pacman
10:28:55 <cocreature> dmj`: that has been fixed for quite some time afaik
10:29:02 <deltasquared> cocreature: eeehhh... but I use shellcheck from the repositories
10:29:06 <dmj`> cocreature: installing nix via pacman ? 
10:29:21 <dmj`> cocreature: or just using nix’s install script with curl on arch
10:29:23 <cocreature> dmj`: no, just follow the regular nix installation instructions in the nix manual
10:29:32 <cocreature> deltasquared: yeah I would recommend against doing that :)
10:29:42 <deltasquared> welp, there goes my evening
10:30:12 <deltasquared> not that it's anyone's fault, just that it seems to be another one of those "you really ought to do it this way" times that involves a fair amount of cursing on my part while I figure it out
10:30:29 <deltasquared> cue an evening of said transition
10:32:06 <deltasquared> well, I'm not using shellcheck right now, at least. though I note that arch-packaged ghc depends on ghc-libs, which provides a bunch of distro-built haskell packages
10:32:51 <Welkin> I don't waste time with distro packages for haskell
10:33:05 <Welkin> install haskell platform in seconds, or the bin dist
10:33:29 <deltasquared> Welkin: why, packages from hackage often need more up to date anyway?
10:34:22 <deltasquared> ghc is the sticker, I'd really rather not install binaries for the compiler from outside the distro
10:34:24 <Welkin> I also don't waste time with quirky linux distros either
10:34:30 <Welkin> deltasquared: why not?
10:34:34 <Welkin> it is trivially easy
10:34:43 <Welkin> you can have multiple versions of ghc installed too
10:34:47 <cocreature> installing ghc via your distro is fine (as long as you don’t mind it potentially being out of date)
10:34:59 <cocreature> the problems usually start when you install other haskell packages
10:35:24 <glguy> deltasquared: Installing development environment outside of the distro is common for more than just Haskell. It's rare to want to tie the versions of things you're developing with to distro updates
10:35:34 <Welkin> for anything programming related I almost never use distro packages
10:36:21 <deltasquared> glguy: it's to do with native library versioning - if I were to do that I'd probably want to build from source... which could take a while. argh.
10:36:34 <Welkin> I even isntall emacs from source
10:36:48 <dataN> its normal for a build tool to fetch the most up to date compiler 
10:37:49 <deltasquared> hrm. I'm not sure what to do now
10:37:57 <maerwald> dataN: no
10:38:32 <Welkin> your cabal project is set to use a specific compiler, whichever one you have on your path, or that you specify with flags
10:39:45 <dataN> cygwin/msys/mingw sure was slow
10:40:53 <i-am-the-slime> How would I generate a database for only the files in the current project?
10:41:05 <dataN> do people still use apt-get in makefiles?
10:41:13 <deltasquared> ewww
10:41:16 <deltasquared> that sounds horrible
10:41:48 <maerwald> deltasquared: in a way, it's ok, because it will fail ony my distro :)
10:42:15 <deltasquared> likewise
10:43:39 <deltasquared> ok, I appreciate the warnings that have been stated here, and I'll bear them in mind. however, because I often have to blow things up to appreciate such, I'll go and try that shared user cache idea anyways
10:43:55 <deltasquared> if it doesn't work I will try to keep it mostly to myself so as to avoid "I told you so" :)
10:45:19 <deltasquared> ^ rip
10:46:56 <dataN> batch + curl ?
10:46:59 <i-am-the-slime> How can I generate a local hoogle database for only the given project?
10:47:56 <growpotkin> cocreature you're the best :D `combinePairs = concatMap (\(_,x,xs) -> [(x,y) | y<-xs]) . selectSplit`
11:05:14 <MarcelineVQ> Is sharing a side-effect?
11:06:11 <hpc> from what i have seen, sharing is considered an implementation detail
11:06:17 <hpc> and outside the meaning of a program
11:06:37 <deltasquared> certainly my understanding of it is that it doesn't affect the program's semantics
11:06:46 <monochrom> Depends on what's being shared?
11:07:20 <deltasquared> argh. I shall have to go now to check on dinner
11:08:28 <monochrom> If you share mutable variables, you do have effects. But usually we speak of reading and writing as the effects, not the sharing.
11:12:25 <growpotkin> sharing is a social construct
11:12:48 <monochrom> Haha.
11:13:25 <monochrom> Please don't anthropomophize the parts of a computer program.
11:13:57 <byorgey> they don't like it when you do that
11:14:28 <growpotkin> ;)
11:15:01 <deltasquared> oh dear. so building refined using cabal now (same situation as described earlier, some distro packaged libs present) and I'm getting a *bunch* of missing files errors from modules which are in the distro packages.
11:15:09 <deltasquared> I suspect this may be one of those "I told you so things"
11:15:29 <hpc> yep
11:15:45 <hpc> always use the same packaging method for everything
11:15:47 <MarcelineVQ> Yes, there's a real mashup of static vs dynamic packages when using any of the distro packages
11:15:56 <glguy> It's not fun if you tell yourself "you told me so" and rob someone of the chance to tell you themselves :(
11:16:19 <deltasquared> glguy: alright fine, tell me if it makes you feel better :P
11:16:40 <Welkin> cool look
11:16:41 <Welkin> https://www.amazon.com/Haskell-School-Music-Signals-Symphonies/dp/1108416756/
11:16:58 <deltasquared> I'm just trying to think what would be the best way to proceed now. I'd have to completely ditch the distro ghc too, because it's dependencies pull in some of those troublesome libs
11:17:00 <Welkin> Paul Hudak's post-humous book
11:17:33 <deltasquared> either that or I go with nix once again I guess.
11:17:57 <monochrom> arch adds an extra complication because of its religious crusade against static linking.
11:19:05 <deltasquared> I wasn't aware the maintainers had explicitly declared as such
11:19:40 <hpc> deltasquared: it's like any other war nowadays, it's unofficial ;)
11:19:45 <deltasquared> then again I've never tried to do the necessary hoop jumping to get something into a distro repo. ain't nobody got time for that
11:19:47 <Welkin> which is one of many reasons I ditched arch
11:20:04 <deltasquared> Welkin: why, because they said "it's this way, fsck you"?
11:20:30 <Welkin> I don't have time to waste on made-up problems
11:20:32 <MarcelineVQ> I'm sure it's nothing so direct as that, just people with their own ideas of what's good that aren't shared byother people
11:20:38 <MarcelineVQ> I've been using stack on arch to avoid these issues, though now that there's a new ghc and cabal release I'll probably try using those directly again and see if cabal-install works on this weird machine again finally
11:21:10 <monochrom> Mind you, using stack on arch (or on anything) is a special case of "don't use the distro's GHC".
11:21:23 <deltasquared> MarcelineVQ: so do you use the distro packaged ghc or upstream binaries in your case
11:21:25 <monochrom> Because stack downloads and installs GHC on its own.
11:21:35 <deltasquared> I'm just wondering how best to proceed to get out of this problem
11:21:40 <MarcelineVQ> You can use the distro ghc with stack, but monochrom's statement is generally true
11:22:01 <monochrom> Yeah non-default you can do anything you like.
11:22:02 <Welkin> there are so many other options besides arch
11:22:17 <Welkin> why would you stay in an abusive house?
11:22:23 <deltasquared> Welkin: that's a whooooole different argument, that would likely be offtopic fairly fast
11:22:31 <deltasquared> (I have not seen the abuse you speak of)
11:22:33 <monochrom> Non-default you can even modify stack's asm code so it includes a web browser too.
11:22:48 <MarcelineVQ> monochrom: hey now, this is a conversation in good faith :>
11:23:33 <monochrom> Sure, good faith is when I say "stack does/doesn't XXX" then everyone agrees that it means I'm speaking of the default.
11:25:16 <monochrom> Conversely when you say "everyone loves haskell!" I agree that it means the domain of "everyone" is #haskell participants and it also just means "statistically most people".
11:25:51 <deltasquared> idk, is there a guide for a non-distro ghc then, like where do I get a bootstrap tarball or something
11:26:05 <monochrom> There are two.
11:26:13 <Welkin> deltasquared: you don't need a guide
11:26:24 <Welkin> just install haskell platform, or the binary + cabal
11:26:33 <Welkin> haksell platform installs in seconds
11:26:37 <monochrom> One is download from www.haskell.org/ghc. Its makefile can do install. It's binary.
11:26:43 <MarcelineVQ> A guide is kind of helpful so you know what yo pass to  ./configure
11:26:48 <monochrom> OK I can't count. There are three.
11:27:22 <Welkin> https://www.haskell.org/platform/linux.html
11:27:25 <monochrom> Another one is what Welkin said. Haskell Platform. Again it's binary. (Don't bother building from source. You have more than a bootstrapping problem.)
11:27:47 <monochrom> Third one is use stack. It downloads and installs its own GHC.
11:27:53 <monochrom> (And binary again.)
11:28:29 <monochrom> No there is no "I don't trust binary, how to build from source?" guide unless you accept a bootstrapping challenge.
11:28:34 <elvishjerricco> (Nix has been the most reliable way to install GHC by far for me)
11:28:34 <MarcelineVQ> There's even the nix contingency now, which has various guides one can google for getting ghc going on it afaik
11:28:48 <monochrom> Haskell is not PHP. You are not going to build from source with just a C compiler.
11:28:52 <dmj`> elvishjerricco: here here
11:29:06 <Welkin> or
11:29:06 <Welkin> https://www.haskell.org/ghc/download_ghc_8_6_1.html
11:29:10 <elvishjerricco> Don't even need to do all the crazy haskell nix stuff. Just get cabal-install and GHC with Nix and do things normally
11:29:11 <Welkin> https://hackage.haskell.org/package/cabal-install
11:29:37 <monochrom> Yeah what elvishjerricco says sounds good too. Gosh now there are four guides.
11:29:57 <glguy> We are going to need a guide for all these guides
11:29:58 <MarcelineVQ> deltasquared: you'll want to roll a die or flip a coin at this point, it turns out what when a human is given many options they tend to elect for none of them
11:30:05 <monochrom> You want a guide? We can give you as many conflicting guides as there are #haskell participants. >:)
11:30:14 <deltasquared> elvishjerricco: that sounds like a good approach then
11:30:38 <Welkin> I just realised 8.6.1 came out yesterday
11:30:44 <monochrom> Oh you want the guide instead? Sure every #haskell participant believes that their guide is the guide.
11:30:56 <deltasquared> if nix provides a "saner ghc" in this case (one that doesn't drag along dynamic packages) I'll try that route
11:31:03 <deltasquared> anyway, AFK now because dinner
11:31:08 <glguy> Welkin: new cabal-install, too
11:31:12 <Welkin> the easiest solution is always haskell platform
11:31:14 <elvishjerricco> deltasquared: Keep in mind I think the pacman based install of Nix is bad. Better to do as https://nixos.org/nix/download describes.
11:31:15 <Welkin> I have tried all of them
11:31:31 <Welkin> nix is the hardest in my experience
11:31:44 <Welkin> if it works, it works great, but if it doesn't then good luck
11:31:45 <elvishjerricco> Er, https://nixos.org/nix/download.html
11:32:00 <monochrom> I agree about Haskell Platform in terms of short terms.
11:32:01 <glguy> Nix is a bunch of stuff to learn if all you wanted was an easy GHC installation
11:32:21 <monochrom> In the long term I need to know your future before I can deduce what's best for your future.
11:32:22 <elvishjerricco> Welkin: I disagree. I think that's the case when you use Nix for all your Haskell deps too
11:32:30 <elvishjerricco> Just gettin GHC and cabal-install is stupid simple
11:32:51 <Welkin> haskell platform is my go-to for the first time ghc install. From there I can do whatever I want, including using it to bootstrap other ghc installs
11:33:15 <glguy> Yeah, there's been much more time discussing alternatives than it takes to just install Haskell platform
11:33:19 <monochrom> Ah yeah that's an excellent point.
11:33:25 <elvishjerricco> Assuming the platform reliably supports your distro, which it often doesn't
11:33:51 <monochrom> It always supports my distro. :)
11:34:41 <monochrom> Also, ignore how its web page suggests you to go back to your distro. Get the "generic linux" binary.
11:35:20 <elvishjerricco> How does that know which curses version to use?
11:35:38 <i-am-the-slime> How do you feel playing machine?
11:36:16 <Welkin> are there release notes for cabal 2.4?
11:36:20 <monochrom> I parted my way from Haskell Platform because its docs are full of broken links because of its naive build process.  But at every Haskell Platform release I take its package list and tell cabal to build the same thing.
11:37:17 <monochrom> It doesn't use curses, does it?
11:37:46 <monochrom> I think the time when ghci used [n]curses was long gone.
11:38:13 <elvishjerricco> monochrom: I don't think so.
11:38:17 <elvishjerricco> Maybe I'm wrong
11:38:26 <sclv> i've been thinking about changing the platform soon
11:38:29 <elvishjerricco> But I thought GHC was definitely linked with ncurses
11:38:29 <sclv> want to put out an email about it
11:38:51 <sclv> basically scrap all the separate build stuff and make it genuinely just a binary installer that wraps up the component tools
11:39:17 <sclv> and in the process move to just minimal for installer and keep full as an advisory list
11:39:35 <sclv> should fix the rough edges, and also full makes less sense than ever in the new-build world
11:39:49 <sclv> but rewriting all the installers to be different is actually a fair amount of work
11:40:11 <elvishjerricco> That's a very good point about new-build
11:40:13 <sclv> and genuinely wrap the ghc installer instead of pre-installing and wrapping the binaries
11:40:41 <sclv> for 8.6 i'm thinking maybe just get rid of core/full and only have core
11:40:46 <sclv> and full as a list
11:40:57 <sclv> but without the benefits of redoing the installers entirely
11:41:24 <monochrom> Plus I failed to tell you I actually edit the list to cut out GL stuff and add in aeson cassava hmatrix :)
11:41:31 <elvishjerricco> sclv: Maybe cave it for when new-build is the default?
11:41:41 <elvishjerricco> Save, not cave
11:42:09 <sclv> monochrom: once the full is decoupled from actually installing stuff, i think we can freely make those sorts of changes much better
11:42:25 <sclv> so it stops being "stalled" 
11:42:53 <sclv> and returns to being a genuinely evolving "standard packages" list
11:44:12 <growpotkin> I have a nice shell.nix that I use for all my haskell stuff if you're interested.
11:44:30 <growpotkin> the documentation on that sort of thing as admittingly convoluted
12:07:37 <deltasquared> elvishjerricco: thanks for the tip; I have always installed nixos from "upstream" as it were.
12:08:09 <elvishjerricco> deltasquared: Maybe the pacman install is better now, but it used to just break immediately
12:08:32 <elvishjerricco> deltasquared: I'm assuming you were planning on installing Nix on Arch
12:08:50 <deltasquared> elvishjerricco: I don't see much a point using the pacman way, as soon as the /nix tree is ready it becomes more or less free standing. and yes to installing on arch
12:09:17 <elvishjerricco> deltasquared: Yea, plus, if you let Nix install itself, it can upgrade itself with `nix upgrade-nix`
12:09:44 <deltasquared> I would have gone full nixos before now if it weren't for certain disagreements I had with nixos trying to do too much for my liking, but that's a story for another time and another channel I suspect.
12:10:03 <elvishjerricco> deltasquared: Meet me in #nixos-chat; I may have some tips for you :)
12:30:52 --- mode: glguy set +v davidm_
12:31:43 --- mode: glguy set +v albert
12:33:52 <davidm_> Hey guys I have got a problem solving parsing an arrays using readP, I am using chainl and it takes ages to finish
12:34:29 <davidm_> is here anyone with skills with readP library
12:34:30 <davidm_> ?
12:34:33 <dmj`> davidm_: can you paste your code
12:35:04 <c_wraith> chainl will go O(n^2) with an array - or a list, which you're much more likely to be using
12:37:14 <davidm_> chainl (tokenP parseSubAdd) (infixTokenP "===") Undefined,  chainl (tokenP parseSubAdd) (infixTokenP "<") Undefined,   parseSubAdd
12:37:27 <davidm_> this is the part which makes it really slow
12:37:49 <davidm_> it is enclosed in choice
12:38:20 <davidm_> but I would like to the option rather fail then return Undefined
12:44:17 <davidm_> or even better question would be how to enforce chainl to fail if the operator is not successful?
12:46:35 <deltasquared> g/c
12:46:38 <deltasquared> ... argh
12:46:42 <deltasquared> sorry, buffer garbage
12:53:39 <crestfallen> hi does the following function return a functor?  ...
12:53:46 <crestfallen> > tx = (<$>) length
12:53:47 <lambdabot>  <hint>:1:4: error:
12:53:48 <lambdabot>      parse error on input ‘=’
12:53:48 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
12:54:07 <crestfallen> wha
12:54:18 <crestfallen> sorry
12:54:34 <crestfallen> @let tx = (<$>) length
12:54:35 <lambdabot>  Defined.
12:55:22 <crestfallen> > tx [(Just 4.5),(Just 2), (Just 3.3), Nothing, (Just 5.66)]
12:55:25 <lambdabot>  [1,1,1,0,1]
12:55:59 <crestfallen> so that is not returning a functor, correct?
12:56:12 <glguy> Are you trying to say "function"?
12:56:12 <deltasquared> oooh, I want to try the bot out now...
12:56:29 <deltasquared> which one was <$> again, was that infix fmap
12:56:30 <crestfallen> no
12:56:36 <crestfallen> :t tx
12:56:37 <lambdabot> (Functor f, Foldable t) => f (t a) -> f Int
12:56:40 <monochrom> Yes infix fmap
12:56:45 <deltasquared> :t (<$>)
12:56:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:56:49 <glguy> crestfallen: Right, it's returning a function
12:57:28 <crestfallen> please explain exactly what that output is glguy 
12:57:29 <monochrom> I wouldn't even use the word "return".
12:57:46 <glguy> The expression has a function type
12:58:06 <deltasquared> wait, surely that would be (length <$>)... or why not just (fmap length)
12:58:27 <monochrom> Yeah it's fmap length.
12:58:30 <glguy> (length <$>); (<$>) length; fmap length   all the same deal
12:58:41 <deltasquared> :t length
12:58:42 <lambdabot> Foldable t => t a -> Int
12:58:56 <monochrom> But it's useful to learn section syntax too.
12:58:57 <deltasquared> huh, didn't think to try length on Maybe, but I guess that figures
12:59:03 <crestfallen> I like prefix notation not sure why. but ...
12:59:36 <monochrom> Yeah recently length foldl foldr etc have been generalized from list to a lot of types such as Maybe etc., generally the Foldable class.
12:59:41 <crestfallen> deltasquared, please hold on I can't keep track of the advice
13:00:01 <deltasquared> crestfallen: very well, I shall curb my enthusiasm :P
13:00:12 <monochrom> deltasquared is not giving you advice. deltasquared is talking to me.
13:00:34 <monochrom> You don't tell everyone to stop talking just for you.
13:01:09 <deltasquared> eeeeh, monochrom it kinda sounded like they were having some difficulty, I would give them the benefit of the doubt
13:01:31 <crestfallen> I wasn't doing that. 
13:01:57 <glguy> deltasquared: there's history you don't appear to be aware of
13:02:29 <deltasquared> glguy: as in, previous behaviour with this particular person?
13:02:34 <crestfallen> sorry I'll get off now, I was merely trying to read the posts
13:03:11 <crestfallen> I wasn't telling people to stop talking. 
13:04:32 <deltasquared> crestfallen: in any case, from what I understand of your original question, it doesn't return a functor, it returns a function operating on one (given constraints on the element type originating from length, namely Foldable)
13:04:48 <crestfallen> monochrom make no mistake, you are mean
13:07:04 <lortabac> hello, I am looking for good resources for learning how to write a compiler for a simple dependently-typed language
13:08:12 <lortabac> I don't care much about parsing and code generation, I am more interested in the type-checking part
13:09:35 <Welkin> lortabac: a book just came out 5 days ago called The Little Typer that does just that
13:09:38 <dmwit> lortabac: http://thelittletyper.com/
13:09:54 <Welkin> I am considering getting it, but there is no preview
13:10:04 <Welkin> I'm familiar with the author's other books though
13:10:06 <absence> if i need something like span/break, but want to fold over the items in parallel so i can use the value of the fold for the predicate, are there any clever tricks or libraries to check out, or do i just have to implement it manually?
13:10:10 <dmwit> I found it insufferably verbose, but I'm also a PL expert and so not really in the intended audience.
13:10:54 <dmwit> But it is, like, exactly answering the question you asked. =P
13:11:24 <lortabac> dmwit: I have very little experience in writing compilers
13:11:49 <lortabac> so I might be in the intended audience :)
13:11:51 <Welkin> if you can write a scheme, that's good enough
13:11:53 <Welkin> I've done it
13:12:03 <dmwit> lortabac: I think you might be right!
13:12:13 <shapr> I need ( parenal ) guidance.
13:12:19 <deltasquared> I would normally hazard that most of couldn't write a compiler, but I'm aware doing so is more prevalent in haskell, so I won't jump to conclusions for everyone here
13:12:28 <Welkin> that book uses a custom language called "pie" implemented in racket (which is a language meant for creating other languages)
13:12:31 <deltasquared> *most of us
13:13:55 <Welkin> lortabac: also see https://beautifulracket.com/
13:13:56 <lortabac> Welkin: dmwit: does the book say anything about type inference?
13:14:10 <shapr> deltasquared: it's easier to cheat when building compilers in Haskell
13:14:16 <deltasquared> shapr: "cheat"?
13:15:12 <shapr> parsing is easier, converting a parse tree into something else is easier.
13:15:42 <deltasquared> I wouldn't call that "cheating", just a natural consequence of the paradigm and libraries
13:15:44 <shapr> I wrote several recursive descent parsers in Java and C, and decided that was a difficult task, but it's much easier in Haskell.
13:17:57 <monochrom> Algebraic data types and pattern matching certainly make things more high-level. After getting used to them, you certainly find that manual tagging and tag checking feel like assembly programming.
13:19:18 <deltasquared> I think there will be a *lot* of things I will miss from haskell when I manage to secure a job, which looks likely to be in imperative languages of the C/C++ family.
13:20:01 <amx> bracketeer
13:20:10 <cocreature> deltasquared: sounds like you might want to try finding a Haskell job :)
13:20:11 <amx> sorry, wrong window
13:20:13 <Welkin> where are people still using c and c++ outside of game development, hft, and legacy software?
13:20:32 <deltasquared> Welkin: idk, I'm just saying what's on my CV, which is limited having just graduated
13:20:48 <deltasquared> what's *common* out there is C# and .NET runtime
13:20:50 <Welkin> that's normal for most cs grads to only have ever used c or c++ or java
13:21:04 <Welkin> 99% of the time you will not be doing that at work
13:21:06 <lortabac> deltasquared: FYI my company is hiring for a Haskell position :P
13:21:09 <glguy> Welkin: embedded development, aircraft stuff, and also basically everything else
13:21:14 <deltasquared> lortabac: great, they in the UK? :P
13:21:24 <deltasquared> should mention, I'm british
13:21:27 <lortabac> in France, but remote should be possible
13:22:01 <lortabac> s/my company/the company I work for
13:22:28 <Welkin> glguy: that is very niche
13:22:51 <deltasquared> lortabac: alas I have to say unless you're willing to like do an intership program I can't say I'd be very impressive
13:22:57 <glguy> Welkin: I talk to a lot of people, it's the most common language experience I find people have
13:23:00 <[exa]> Welkin: there's the kernel, system libraries, crypto, and all the device drivers
13:23:01 <Welkin> most programming work these days is for the web
13:23:13 <MarcelineVQ> absence: is it possible to make it clearer what you mean?
13:23:44 <glguy> Of course I'm talking to a slice of the programming community interested in working at Galois
13:23:51 <glguy> so there's that selection bias
13:25:35 --- mode: glguy set +b *!*@188.126.46.247
13:25:35 --- kick: Paradise was kicked by glguy (Paradise)
13:26:26 --- mode: glguy set -b *!*@188.126.46.247
13:26:56 <growpotkin> I graduate in the fall and would definitely enjoy working with FP instead of the zillion Brokers and DoD labs that are always recruiting
13:27:01 <Welkin> no paradise for you
13:27:04 <orzo> Given (Int -> a), I would like to construct a lazy (near infinite) object (IntMap a).  Is that doable?
13:27:28 <glguy> No, IntMap is not lazy in its keys
13:27:35 <Welkin> IntMap is limited to 2^32
13:27:38 <glguy> But maybe take a look at MemoTrie
13:28:15 <glguy> Welkin: How so?
13:28:16 <Welkin> 2^31
13:28:35 <orzo> thanks glguy, besides MemoTrie, know any other options off hand?
13:28:59 <absence> MarcelineVQ: let's see... say you have a list of numbers, and you want to break the list when the sum reaches a certain value
13:29:00 <glguy> orzo: What dimension do you want it to be different from MemoTrie?
13:29:41 <[exa]> growpotkin: why not try a phd?
13:29:43 <orzo> i haven't even looked at memotrie yet, I was just figuring to get a list of dependencies to choose from
13:29:54 <orzo> since i dont have memotrie installed
13:32:52 <Welkin> try a phd? What you mean is throw away 10 years of your life working as an underpaid slave for a professor
13:32:53 <absence> MarcelineVQ: one could use scanl to pair the running sum with the values, and then use the regular span function, but i want the original tail without the paired sums
13:33:01 <hexagoxel> how i can check for ghcjs from CPP?
13:33:25 <hexagoxel> i.e. which defines does ghcjs make?
13:35:15 * hexagoxel made a lucky guess for __GHCJS__
13:35:40 <deltasquared> hexagoxel: most headers have a #ifdef _HEADER_NAME_H guard, but I wouldn't count on that to be stable.
13:35:57 <deltasquared> (if we're talking about the C preprocessor)
13:38:10 <orzo> Wait, IntMap is restrcited to 2^31 ?  I thought it would do 2^64 on a 64-bit ghc
13:38:42 <glguy> orzo: It certainly seems to be documented to do that
13:38:48 <glguy> (64-bit on such a machine)
13:39:21 <orzo> oh, welkin gave me pause
13:41:26 <monochrom> orzo: It is possible to borrow ideas from MemoTrie's code instead of installing it.
13:42:05 <jmcarthur> I also thought IntMap supported the full range of Ints
13:42:12 <monochrom> Then again may as well do it to any binary search tree implementation.  Usually there is just one bang you have to delete.
13:43:39 <monochrom> IntMap doesn't use a binary search tree though. I don't know how lazy you can make it.
13:44:15 <liyang> IntMap does support 2^64 entries on a 64-bit arch… we relied on it (via EnumMap) at my last job.
13:45:40 <orzo> you actually filled it up to 2^64 entries?
13:45:46 <monochrom> I did a PhD and it was not underpaid slave of a professor.
13:46:25 <monochrom> Instead, I was a slave of my own passion. I liked academia and I liked doing my thesis on lazy evaluation.
13:47:10 <monochrom> I wouldn't call it underpaid though. The market price for either my passion or my take on lazy evaluation is close to $0 to begin with.  So I actually got paid more than that.
13:47:36 <liyang> orzo: well, not quite. Used a bit-packed representation of a small struct as the key via `EnumMap`, and we definitely used more than 32 bits in the encoding…
13:48:41 <monochrom> My pay was maybe 1/5 or 1/10 of a typical programmer but it was overpay considering the market price of what I sold.
13:49:35 <monochrom> The left-wing people keep making the mistake of comparing themselves to rich people who are selling something else, rather than comparing to the market price of what they themselves actually offer.
13:50:59 <monochrom> But you do have to consider the scenerio that you may be facing a trade-off between doing what you like but getting low pay, vs what you don't like but getting high pay.
13:51:15 <monochrom> Not to say that everyone faces this trade-off.
13:52:29 <Welkin> or doing what you don't like, and getting low pay
13:52:33 <Welkin> which is more likely
13:54:39 <rotaerk> :t compare <> compare
13:54:40 <lambdabot> Ord a => a -> a -> Ordering
13:55:35 <dmwit> lortabac: I'm not sure if it touches on inference much! Inference in dependently-typed languages is a very interesting topic indeed.
15:05:20 --- mode: glguy set +v smudge
15:05:29 <smudge> hi guys are there haskell packages which aren't available on windows?
15:06:03 <benzrf> > (compare <> compare) 3 4
15:06:05 <glguy> smudge: Some package depend on the unix package, which isn't available on unix. It's not the common case but it happens. Other instances would be a package that has a native library dependency that doesn't support Windows
15:06:06 <lambdabot>  LT
15:06:11 <benzrf> > (compare <> compare) 3 3
15:06:13 <lambdabot>  EQ
15:06:14 <benzrf> interesting
15:06:55 <benzrf> oh, sure, it's just doing "compare x y <> compare x y"
15:06:58 <[exa]> benzrf: it gets squished into compare 3 3 <> compare 3 3
15:06:58 <glguy> > map (\x -> compare x x) [LT, EQ, GT]
15:07:00 <lambdabot>  [EQ,EQ,EQ]
15:07:05 <smudge> glguy: hmm ok, would it say somewhere on hackage if it wasn't available on windows?
15:07:15 <glguy> > map (\x -> x <> x) [LT, EQ, GT]
15:07:16 <benzrf> > LT <> GT
15:07:17 <lambdabot>  [LT,EQ,GT]
15:07:17 <lambdabot>  LT
15:07:49 <[exa]> smudge: afaik the 'portability' thingy is reserved for language-specific stuff, but I can imagine there could be a notice
15:08:02 <glguy> smudge: Depends on if the author thought to mention it or not
15:08:18 <hpc> for the most part, loss of windows compatibility comes from some C library it interfaces with
15:09:58 <smudge> hpc: ok, well it's HDBC which I'd imagine gets used a lot, so hopefully I'm safe to assume it's supported
15:10:53 <hpc> "ODBC was originally developed by Microsoft and Simba Technologies during the early 1990s, ..." probably :P
15:12:29 <smudge> hpc: ahhh ok, and HDBC uses ODBC?
15:15:45 <hpc> they don't say it explicitly, but i would be beyond surprised if they didn't
15:18:34 --- mode: glguy set +v anrock
15:22:15 <anrock> Hey guys. I'm trying to parse two space separated ints from stdio and instantly bind them and having troubles with lifting read to IO. Here is my non-working code: [a, b] <- (read . words <$> getLine) :: IO [Int]. 
15:23:16 <lyxia> anrock: words produces a list of strings, read expects a string as input
15:23:57 <lyxia> anrock: you need to apply read to *each* element of the list created with words, so (map read . words <$> getLine)
15:24:04 <anrock> lyxia: yeah, i've managed to lift read to IO via pure and then fmap it, but got IO [(String -> a)]. How i do i lift and apply at the same time?
15:24:21 <anrock> Oh!
15:24:43 <ChaiTRex> :t map read . words <$> getLine :: IO [Int]
15:24:44 <lambdabot> IO [Int]
15:26:14 <dmj`> :t mapM readMaybe . words <$> getLine
15:26:15 <lambdabot> error:
15:26:15 <lambdabot>     Variable not in scope: readMaybe :: String -> m b
15:27:11 <anrock> There is no way to write using infix <$>?
15:27:27 <anrock> s/write/write it/
15:28:07 <dmj`> `fmap`
15:28:52 <anrock> `fmap` is the same thing. I mean i can't write read . words <$><$> getLine
15:28:52 <ChaiTRex> :t (map read . words) <$> (getLine)
15:28:53 <lambdabot> Read b => IO [b]
15:29:42 <ChaiTRex> anrock: I'm confused. <$> is in infix form. It's in the middle of map read . words and getLine.
15:30:10 <ChaiTRex> Oh, I see.
15:30:15 <anrock> :)
15:31:02 <ChaiTRex> :t read <$> words <$> getLine
15:31:03 <lambdabot> error:
15:31:03 <lambdabot>     • Couldn't match type ‘[Char]’ with ‘Char’
15:31:03 <lambdabot>       Expected type: String -> String
15:32:09 <tommd> :t map read <$> words <$> getLine
15:32:10 <lambdabot> Read b => IO [b]
15:33:55 <anrock> :t (read <$>) . words <$> getLine
15:33:56 <lambdabot> Read b => IO [b]
15:34:02 <anrock> Ugly as hell, tho
15:34:22 <ChaiTRex> :t (read <$>) <$> words <$> getLine
15:34:23 <lambdabot> Read b => IO [b]
15:34:44 <ChaiTRex> @unpl (read <$>) <$> words <$> getLine
15:34:44 <lambdabot> (((\ a0 -> read <$> a0) <$> words) <$> getLine)
15:34:47 <[exa]> so we've got 2 functors here, what about Compose?
15:36:56 --- mode: glguy set +v steve2343243
15:37:04 <steve2343243> Hi! Does anyone know how I parse a Float/Double number using the Earley parsing library?
15:37:36 <anrock> btw, anyone using vim/neovim with hie?
15:38:25 <anrock> I wonder if anyone managed to setup hover working like in VSCode - so it's automatically appears when cursor is over something
18:31:33 --- mode: glguy set +v SPACE_AIDS
18:36:18 <dmwit> ?tell anrock In addition to the other excellent advice, when reading things in IO, you should prefer readIO to read. This ensures that parse errors get noticed in a timely way. So consider `mapM readIO . lines =<< getLine` instead of `map read . lines <$> getLine`.
18:36:18 <lambdabot> Consider it noted.
18:37:26 <SPACE_AIDS> y not just tell him urself
18:37:36 <dmwit> They're not here at the moment.
18:37:41 <SPACE_AIDS> OKAY
18:48:38 <cppxor2arr> how do i distribute haskell binaries? preferably so there is just one binary file to distribute which can run on the same os and architecture.
18:49:21 <SPACE_AIDS> you can embed it into python interpret
18:49:37 <koz_> cppxor2arr: You can use 'stack build' to make one if you're using Stack.
18:49:47 <dmwit> I don't think there's a lot of tooling around that at the moment. The state of the art seems to be "build it with static linking (the default) and copy the binary to wherever".
18:50:13 <dmwit> Bigger projects that don't do this each have their own homebrew solution, I think.
18:51:03 <dmwit> (And yes, either cabal or stack are suitable for the "build it with static linking" step.)
18:51:16 <cppxor2arr> hmm ok i'll try with cabal
18:51:40 <cppxor2arr> just doing "cabal build" will statically link?
18:53:05 <dmwit> Depends on how you got GHC, I think, not on cabal. By default cabal doesn't pass flags to either turn it on or off.
18:53:35 <dmwit> The official GHC bindists static link by default, but I think e.g. Arch does (or did) something wonky with the distro GHC.
18:54:23 <dmwit> You can check your final binary with ldd; if you see only a few lines referencing things like libgmp and libHsrts, you got a static build; if you see a lot of lines referencing libraries with long names and maybe version hashes, you got a dynamic build.
18:54:31 <SPACE_AIDS> you can use a monad too
18:54:45 <cppxor2arr> hmm ok
18:55:31 <koz_> dmwit: Does, AFAIK.
18:56:31 <dmwit> thanks
18:56:40 <SPACE_AIDS> your welcome
18:56:47 <dmj`> :t (+)
18:56:48 <lambdabot> Num a => a -> a -> a
18:57:22 <koz_> Is there something like 'count :: (Foldable t) => (a -> Bool) -> t a -> Int' which tells me how many a's match the given predicate in the Foldable?
18:57:47 <dmj`> :t mapM Text.Read.readMaybe . words <$> getLine
18:57:49 <lambdabot> Read b => IO (Maybe [b])
18:57:57 <dmwit> koz_: Nothing prebundled, but it's easy as pie to build.
18:58:05 <SPACE_AIDS> fuck yes pie
18:58:08 <koz_> dmwit: Figured I'd ask in case it already exists somewhere.
18:58:48 <dmwit> SPACE_AIDS: If you have nothing constructive to add, you are welcome to remain silent.
18:59:05 <dmj`> :t \predicate -> length . filter predicate
18:59:07 <lambdabot> (a -> Bool) -> [a] -> Int
18:59:28 <SPACE_AIDS> dmwit: that's pretty rude and a violation of code of conduct :(
18:59:31 <SPACE_AIDS> i was trying to help
18:59:31 <dmwit> dmj`: Not all foldables have a sensible implementation of filter. Think of `Identity` e.g.
18:59:46 <dmj`> dmwit: ah, good point
18:59:46 --- mode: ChanServ set +o dmwit
19:00:33 <dmwit> SPACE_AIDS: This is your second warning. You don't get a third.
19:00:37 <dmj`> SPACE_AIDS: in general, there is an attempt to keep a somewhat professional tone on this channel.
19:00:58 <SPACE_AIDS> dmj`: i was trying to be, and i don't appreciate being threatned for not doing anything wrong :( i wasn't trying to cause issue
19:01:08 <elated> could probably start by kicking someone making a joke out of aids in their name
19:01:20 <dmwit> Further discussion of the rules and what happened here is welcome in #haskell-ops. It is no longer welcome here in #haskell.
19:01:30 <SPACE_AIDS> okay friend
19:01:32 <dmj`> SPACE_AIDS: it’s fine, that’s why its called a warning. Now you know.
19:01:52 <SPACE_AIDS> i wish to follow code of conduct , i hear so much about it and want to comply
19:02:01 * koz_ just realized recently that you can define 'toList' as 'foldMap pure'.
19:02:20 <dmj`> koz_: neat!
19:02:32 <koz_> dmj`: It's _terribly_ inefficient for many Foldables though.
19:02:59 <dmj`> koz_: sure I can imagine
19:03:23 <koz_> You can also do 'length' as 'foldMap (const 1)' I think.
19:03:29 <koz_> Wait, no, that won't work, sadly.
19:03:41 <koz_> You have to do some Sum - getSum wrapping.
19:04:42 --- mode: dmwit set -o dmwit
19:05:27 <dmwit> Just getSum, thankfully, now that Sum is a Num instance. =)
19:05:50 <koz_> > getSum . foldMap (const 1) $ [1,2,3,4]
19:05:52 <lambdabot>  4
19:05:54 <koz_> Woah, nice.
19:06:33 <dmwit> :t \p -> getSum . foldMap (Sum . fromEnum . p)
19:06:34 <lambdabot> (Enum a1, Foldable t) => (a2 -> a1) -> t a2 -> Int
19:06:51 <dmwit> koz_: (...and `Bool` is an instance of `Enum`. Try not to think about it too hard.)
19:07:14 <koz_> dmwit: Mapping False <-> 0, True <-> 1 I guess?
19:07:30 <dmwit> It's the derived instance for `data Bool = False | True`, so yep.
19:07:43 <koz_> That actually makes a degree of sense.
19:07:53 <koz_> (even if it's just an accident of the data constructor ordering)
19:07:55 <koz_> (I guess)
19:08:19 <dmwit> I'm pretty sure it was deliberate.
19:08:30 <koz_> I can't imagine it wasn't.
19:08:57 <koz_> (my original sentence wasn't well-phrased)
19:09:53 <geekosaur> I actually wouldn't be that surprised if something somewhere in the rts relies on being able to treat the constructor tag as an Int#
19:10:29 <dmwit> Yes, the temptation would be great. =)
19:11:08 <koz_> Where can I find Sum/getSum?
19:11:13 <dmwit> ?index Sum
19:11:14 <lambdabot> Data.Monoid, Data.Functor.Sum
19:11:19 <koz_> Oh, nice.
19:11:42 <dmwit> I'm... actually a bit surprised. I wonder how long it's been since ?index's database has been updated.
19:12:23 <koz_> Does anyone know when Stack is going to support GHC 8.6.1?
19:14:12 <slack1256> Some functions I've seen are so abstracted on their arguments that you cannot infer how to use them without seeing a code example (which usually they don't provide)
19:14:25 <koz_> slack1256: For example?
19:14:25 <slack1256> For example, on diagrams most functions are like that
19:14:57 <dmwit> slack1256: Hm. Maybe. But then diagrams also has a significant body of tutorial and documentation writing which lives in addition to the bare types.
19:15:31 <dmwit> The haddocks are just one source for understanding diagrams.
19:15:50 <slack1256> Exactly, you have to rely on good tutorials for really abstract functions signatures
19:16:05 <slack1256> Yet that isn't a problem when programming with concrete types
19:16:09 <dmwit> https://diagrams.github.io/
19:17:09 <dmwit> Sure. But concrete types have their own costs vis-a-vis reusability.
19:17:26 <slack1256> Yes
19:17:53 <slack1256> But I see a kind of tradeoff, between usability at the get-go and reusability
19:18:11 <dmwit> No objection here.
19:18:16 <koz_> :t uncurry
19:18:17 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:18:20 <dmwit> I use vim, but not because it's easy to get started with it.
19:19:04 <dmwit> koz_: Perhaps you have the same problem I do: I can never remember which one is uncurry and which one is curry. =)
19:19:11 <koz_> dmwit: You're right, I do.
19:19:17 <slack1256> I wonder if we can close the gap. Maybe defining some kind of alternate signature with commonly instantiated types?
19:19:51 <SPACE_AIDS> hi fends, how can i embed the haskell interpret in side program?
19:19:55 <koz_> slack1256: The main advantage of this kind of generality is that we can have fewer functions that operate on more things.
19:19:57 <dmwit> My advisor in grad school mused similarly. It would be interesting to see this worked out in detail -- but it also seems like it would be a pretty significant additional effort for library authors.
19:20:35 <dmwit> SPACE_AIDS: The GHC API is the canonical way. There are a few libraries built on top of it that may be worth checking out as well, especially mueval I think is the popular one.
19:21:34 <SPACE_AIDS> oh is that the gutenburg shell thing?
19:21:38 <SPACE_AIDS> or maybe that's the azure stuff
19:22:13 <dmwit> Those don't ring a bell for me. My initial guess is that they're unrelated.
19:22:22 <SPACE_AIDS> okay fend
19:22:30 <SPACE_AIDS> i get technologicals messed up sometimes
19:24:25 <dmwit> slack1256: You could perhaps explore this yourself by building a `beginners-diagrams` package that re-exported lots of `diagrams` functions with concretized types. =)
19:24:54 <slack1256> Perhaphs
19:25:22 <slack1256> I'll probably just start a blog with introductions for packages I use.
19:25:27 <geekosaur> something to kep in mindis that such embedding doesn't give direct access to your program's internals; it will be a separate instance
19:25:29 <dmwit> Good idea!
19:25:46 <slack1256> I am interested on how quickly people can pick-up new libraries, because for my is really hard.
19:26:14 <dmwit> Depends a lot on the library.
19:26:43 <koz_> Seconding what dmwit said. sqlite-simple took me about 3 minutes; fixed-vector-hetero is _still_ incomprehensible.
19:26:46 <geekosaur> and on the people
19:26:51 <dmwit> For me getting up and running with diagrams specifically was pretty quick. The documentation is really very good. A few hours spent reading, then within another few hours I had some bad-looking diagrams.
19:27:26 <dmwit> Another few hours + some discussion in #diagrams and I had smoothed out most of the rough edges and turned them into acceptable-looking diagrams.
19:27:39 <dmwit> I think. That could just be my rosy-memory glasses, but I don't think so.
19:32:38 <koz_> ?index both
19:32:38 <lambdabot> bzzt
19:32:41 <koz_> :(
19:32:49 <dmwit> ?hoogle both
19:32:49 <lambdabot> Control.Lens.Traversal both :: Bitraversable r => Traversal (r a a) (r b b) a b
19:32:50 <lambdabot> Lens.Micro both :: Traversal (a, a) (b, b) a b
19:32:50 <lambdabot> Data.Tuple.Extra both :: (a -> b) -> (a, a) -> (b, b)
19:33:04 <koz_> Thanks dmwit.
19:33:44 <dmwit> barrucadu: You should deprecate the both package in favor of Option!
19:35:06 <dmwit> koz_: Depending on what you're using it for, and what your current dependency list looks like, you might also like bimap.
19:35:09 <dmwit> :t bimap
19:35:11 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
19:35:16 <dmwit> :t join bimap
19:35:17 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
19:35:21 <koz_> dmwit: I actually need bitraverse, since I've got Maybe at play as well.
19:35:31 <dmwit> oooo, what's that?
19:35:32 <dmwit> :t bitraverse
19:35:34 <lambdabot> error:
19:35:34 <lambdabot>     • Variable not in scope: bitraverse
19:35:34 <lambdabot>     • Perhaps you meant one of these:
19:35:53 <dmwit> Ah. Seems like a reasonable thing to want.
19:35:54 <koz_> dmwit: Applicative f => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
19:36:12 <koz_> (well, Bitraversable t also but yeah)
19:36:17 <dmwit> right
19:36:26 <koz_> I didn't know about the 'join bimap' trick though - thanks.
19:40:27 <koz_> dmwit: Would 'join bitraverse' work analogously?
19:40:52 <dmwit> Why not ask GHC? =)
19:40:54 <dmwit> (yes)
19:41:02 <koz_> dmwit: Aweosme.
19:43:44 <MarcelineVQ> % :t join @((->)_)
19:43:44 <yahb> MarcelineVQ: (w -> w -> a) -> w -> a
19:45:00 <MarcelineVQ> :t join `asAppliedTo` BT.bitraverse
19:45:02 <lambdabot> (Applicative f, BT.Bitraversable t) => ((b -> f d) -> (b -> f d) -> t b b -> f (t d d)) -> (b -> f d) -> t b b -> f (t d d)
19:45:08 <MarcelineVQ> That's a mouthful :>
19:45:25 <koz_> :t asAppliedTo
19:45:26 <lambdabot> (a -> b) -> a -> a -> b
19:45:31 <koz_> Oh, lol.
19:50:02 <koz_> :t fromIntegral
19:50:03 <lambdabot> (Num b, Integral a) => a -> b
19:50:32 <kove-w-o-salter> :t map
19:50:33 <lambdabot> (a -> b) -> [a] -> [b]
19:50:48 <kove-w-o-salter> Wow lambdabot is amazing!
19:51:21 <MarcelineVQ> it's pretty neat
19:51:46 --- mode: glguy set +v yolo123
19:53:10 <kove-w-o-salter> > toUpper $ concat $ words "What is your name?"
19:53:11 <lambdabot>  error:
19:53:11 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
19:53:11 <lambdabot>      • In the second argument of ‘($)’, namely
19:53:27 <yolo123> HEY PEEPS HOW R Y ALL?
19:53:30 <dmwit> > map toUpper $ concat $ words "What is your name?"
19:53:32 <lambdabot>  "WHATISYOURNAME?"
19:53:36 <kove-w-o-salter> > map toUpper $ concat $ words "What is your name?"
19:53:37 <lambdabot>  "WHATISYOURNAME?"
19:53:42 <SPACE_AIDS> HI YOLO123
19:53:57 <kove-w-o-salter> dmwit: sorry about my typo.
19:54:06 <yolo123> WHICH COUNTRY DO U ALL BELON TO?
19:54:18 <SPACE_AIDS> AMERICATOWN
19:54:18 <dmwit> kove-w-o-salter: No needs for apology. Playing with lambdabot (and getting it wrong) is a time-honored tradition. =)
19:54:40 <kove-w-o-salter> dmwit: thanks :)
19:54:41 <dmwit> yolo123: This channel is primarily for discussion about Haskell, a programming language. Please stay on-topic.
19:55:22 <yolo123> I AM QUIET NEW TO IRC, WHAT EXACTLY IS THE POINT OF USING FREENODE IN THIS ERA?, JUST  A CURUOSITY
19:55:48 <dmwit> yolo123: That's a fascinating question, but not on-topic here.
19:56:12 <kove-w-o-salter> Does anyone know how to do use multi-line code in lambda-bot?
19:56:45 <dmwit> kove-w-o-salter: I don't think it's possible. Though of course you can use explicit braces and semicolons instead of layout as you always can in Haskell.
19:57:01 <dmwit> Makes me wonder what yahb will do with :{ ...
19:57:03 <dmwit> % :{
19:57:03 <yahb> dmwit: 
19:57:07 <dmwit> hmm... =)
19:57:24 <dmwit> % foo = answer where
19:57:24 <yahb> dmwit: 
19:57:31 <dmwit> %   answer = 3
19:57:31 <yahb> dmwit: 
19:57:33 <dmwit> % :}
19:57:33 <yahb> dmwit: 
19:57:36 <dmwit> % foo
19:57:36 <yahb> dmwit: 3
19:57:38 <dmwit> yikes
19:57:59 <MarcelineVQ> a little wordy
19:58:05 <dmwit> kove-w-o-salter: I think if you want to play with that feature of yahb I'm going to ask that you do it primarily via privmsg. =)
19:58:07 <kove-w-o-salter> dmwit: I was trying to import a class from a module and get the type of a function in that class.
19:58:10 <geekosaur> why is someone fromt he cobol era asking about something from decades later?
19:58:15 <koz_> Someone should modify yahb to say 'OK, keep going' every time it's waiting for another line.
19:58:53 <dmwit> koz_: Ah, okay. So lambdabot has a small selection of modules which you can import via ?let import Foo.Bar. yahb has a different selection. No guarantees that what you want will be available.
19:59:09 <dmwit> sorry, misnick
19:59:10 <kove-w-o-salter> dmwit: Sorry. I only just saw your message. I will do it privately.
19:59:20 <koz_> dmwit: No worries - it's helpful to know.
20:00:12 <dmwit> kove-w-o-salter: Oh, I just meant specifically yahb's multiline functionality, because it's so verbose. General playing is fine in here if it's not too extensive, and often helpful (as others can help you spot your errors).
20:01:05 <kove-w-o-salter> dmwit: no worries.
20:09:15 <koz_> mniip: I was wondering - is there any particular reason you don't give an instance of Hashable for Finite in finite-typelits? You provide Generic, so it'd be like, a single line and a hashable dependency. I guess I could use getFinite and hash that (or define an orphan), but I was curious at the rationale.
20:15:29 <mniip> koz_, the bunch of those instances were added in an ad-hoc manner
20:15:51 <mniip> "I want Finite to have NFData! I want finite to have Generic!"
20:16:02 <koz_> mniip: Ah, OK. Well, if you could add a Hashable instance, and don't mind the hashable dep, I would be very grateful. :)
20:37:03 <dmwit> perhaps hackage should have a canonical home for orphan instances
20:37:54 <dmwit> give it a type and a class and it would point you at the package that provides that orphan, e.g.
20:40:24 <dmwit> i mean, it isn't that unusual for neither the type nor the class to want to depend on the other. having a lean dependency tree is a virtue
20:40:41 <geekosaur> or packdeps.haskellers.com?
20:43:06 <dmwit> sure, though i think that would be much less discoverable for orphan instance package authors
20:45:49 <dmwit> i guess you're thinking it would be automatic. that could be nice but seems... hard. i was imagining a sort of registry where you could put packages that existed solely for orphan instances
20:48:51 <geekosaur> seems to me that would just be a category tag
20:51:04 <dmwit> sure, but i want the ability for authors to declare their orphans and for users to search for an orphan
20:52:20 <dmwit> and i want to encourage the practice of putting orphans in their own package with no other functionality
20:52:54 <dmwit> to address the problem that two packages with the same orphan can't both be used
20:57:35 <koz_> dmwit: That would be really useful. I only discovered Data.Vector.Instances() recently, for example.
20:57:55 <dmwit> ...and i want it to be red, and 0-60 in under 3s, and good gas mileage, and with a sun roof...
20:59:14 <koz_> :t foldM
20:59:15 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
21:24:10 --- mode: glguy set +v yes
21:26:59 --- mode: glguy set +v yev
21:28:48 --- mode: glguy set -v yev
23:14:55 <redfish64> If I have a function such as "foo :: [x] -> [x]" which may or may not return the argument untouched , and it is important to the caller to know whether the return value is different from the argument, is there an efficent way to tell?
23:15:44 <redfish64> Or would it be better to do something like "foo :: [x] -> ([x],Bool)" where Bool indicates whether the list returned is exactly the same as the argument
23:15:59 <cocreature> redfish64: change the type to [x] -> Maybe [x] and return Nothing instead of returning the argument untouched
23:16:06 <cocreature> (or make a custom sumtype instead of using Maybe)
23:16:12 <redfish64> Alright, that's what I thought
23:16:14 <redfish64> thanks
23:17:03 --- mode: glguy set +v tauro
