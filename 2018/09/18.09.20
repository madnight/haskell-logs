00:00:05 <sj1k> Afternoon o/
00:00:52 <koz_> sj1k: \o/
00:00:58 <coldpresent> what does big lambda mean in lambda calculus?
00:01:10 <dminuoso> coldpresent: It's just a symbol.
00:01:12 <koz_> coldpresent: What does big lamdba even look like?
00:01:12 <coldpresent> does it define a function that takes a type as input?
00:01:26 <dminuoso> coldpresent: Kind of. But it's a bit more rudimentary than a function.
00:01:45 <dminuoso> coldpresent: Lambda abstractions operate by mechanical "replacing" on application.
00:01:55 <cocreature> koz_: Λ
00:02:00 <koz_> Oh, right.
00:02:00 <coldpresent> why differentiate it from small lambda?
00:02:18 <dminuoso> coldpresent: Ohh wait, a big lambda. In what context?
00:02:20 <coldpresent> small lambda also allows beta reduction, what's the difference?
00:02:31 <dminuoso> coldpresent: Where did you read it?
00:03:03 <coldpresent> http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf section 3.8
00:03:30 <coldpresent> hard to see, either it's a big lambda, or it's a very fat ^
00:04:00 <dminuoso> coldpresent: That's from System F.
00:04:08 <dminuoso> coldpresent: In Haskell you type it as "forall" =P
00:04:12 <dminuoso> Kind of.
00:04:24 <coldpresent> right, thanks!
00:07:11 <dminuoso> coldpresent: In Haskell this is basically reflected in this: A polymorphic value `x :: forall t. t` can be thought of as an abstraction over a type t: Λt.x^t 
00:07:31 <dminuoso> And you can apply this to some type
00:07:52 <dminuoso> :t fmap
00:07:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:08:19 <coldpresent> and here it's forall a,b. Got it, thanks!
00:08:45 <dminuoso> coldpresent: forall f a b.
00:08:51 <dminuoso> Dont forget the poor functor =)
00:09:14 <tdammers> instance Functor Poor where ... ?
00:10:30 <dminuoso> tdammers: I wouldn't be surprised if Edward had something like that in his millions lines of code..
00:11:51 <dminuoso> coldpresent: It also kind of shows why returning a polymorphic value gives the *caller* the possibility of picking a type - because he just gets a /\ abstraction that he can apply to whatever type he wants (possibly limited by constraints)
00:13:05 <koz_> dminuoso: As t approaches infinity, the probability that Edward has implemented something approaches 1, for all values of 'something'.
00:13:08 <coldpresent> dminuoso: thanks, i thought that f being constrained by Functor meant that it wasn't under /\
00:13:53 <dminuoso> coldpresent: All it does is just limit the possible types you can apply it to.
00:13:55 <dminuoso> For example:
00:14:02 <dminuoso> :t (fmap @[])
00:14:03 <lambdabot> error:
00:14:04 <lambdabot>     Pattern syntax in expression context: fmap@[]
00:14:04 <lambdabot>     Did you mean to enable TypeApplications?
00:14:09 <dminuoso> % :set -XTypeApplications
00:14:09 <yahb> dminuoso: 
00:14:16 <dminuoso> % :t (fmap @Maybe)
00:14:16 <yahb> dminuoso: (a -> b) -> Maybe a -> Maybe b
00:14:20 <dminuoso> % :t (fmap @Maybe @Int)
00:14:20 <yahb> dminuoso: (Int -> b) -> Maybe Int -> Maybe b
00:14:22 <dminuoso> % :t (fmap @Maybe @Int @Float)
00:14:22 <yahb> dminuoso: (Int -> Float) -> Maybe Int -> Maybe Float
00:14:49 <dminuoso> coldpresent: The `Functor` constraint just limits my possible choices for the first type parameter.
00:14:58 <dminuoso> Namely for all those types that have an instance Functor.
00:15:42 <coldpresent> dminuoso: it limits the types, which is why I thought it wasn't under /\ (that means forall types?)
00:15:54 <dminuoso> coldpresent: The full and explicit type is:
00:16:09 <dminuoso> fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
00:17:00 <dminuoso> "for all choices of f, a and b, where `f` has an instance Functor`, fmap has the type (a -> b) -> f a -> f b
00:17:39 <coldpresent> alright, this time i fully understand, so f is still under /\, but limited
00:17:42 <dminuoso> I dont know how constraints play into System F though =)
00:19:20 <coldpresent> probably to allow functions like polymorphic equality, see section 3.4 of the same paper
00:47:35 <mniip> 9/20/2018 [10:17:15] <coldpresent> alright, this time i fully understand, so f is still under /\, but limited
00:47:46 <mniip> the '=>' highlights an analogy to functions
00:49:17 <mniip> It's like an implication. It's like you have to pass the "proof" of 'Functor f' to this function
01:04:07 <dminuoso> % data Test a
01:04:07 <yahb> dminuoso: 
01:04:19 <dminuoso> % :t fmap @Test
01:04:19 <yahb> dminuoso: ; <interactive>:1:1: error: No instance for (Functor Test) arising from a use of `fmap'
01:04:38 <dminuoso> mniip: I kind of which this would work :P
01:04:40 <dminuoso> *wish
01:13:25 --- mode: glguy set +v reygoch
01:13:59 --- mode: glguy set -v reygoch
01:14:23 <reygoch> Hey, did anyone use safe links with servant and nested generic records? I'm having some trouble getting links to the nested parts of an API.
01:18:09 <alp> reygoch, you created an issue about it right?
01:18:21 <reygoch> yes
01:18:53 <reygoch> Although I'm not sure If I'm just dumb or if this is some kind of bug
01:19:34 <alp> reygoch, I'll take a close look later today
01:19:47 <reygoch> Ok, thanks
01:19:51 <alp> if you could provide a self contained example
01:19:56 <reygoch> I have
01:19:58 <alp> that I can just put in a file and load in ghci
01:20:03 <alp> with imports etc
01:20:07 <alp> that would be perfect
01:20:13 <reygoch> Ok, I'll complete it
01:20:18 <alp> thanks!
01:29:07 <reygoch> alp, I've updated my example so now it's just copy pasta to test
01:41:22 <merijn> Can I define my own defaulting for a typeclass?
01:44:02 <merijn> i.e. I'd like values of type "MonadIO m => m a" to get defaulted to "IO a"
01:49:51 <dminuoso> % default MonadIO IO
01:49:51 <yahb> dminuoso: ; <interactive>:14:9: error: parse error on input `MonadIO'
01:51:45 <Ariakenom> % default (IO)
01:51:45 <yahb> Ariakenom: ; <interactive>:15:1: error:; * The default type `IO' is not an instance of `Num' or `Show' or `Eq' or `Ord' or `Foldable' or `Traversable'; * When checking the types in a default declaration
01:52:17 <Ariakenom> % :set DoTheThingIWant
01:52:17 <yahb> Ariakenom: Some flags have not been recognized: DoTheThingIWant
01:52:25 <Ariakenom> -.-
01:52:32 <dminuoso> % :set -XMakeItWork
01:52:33 <yahb> dminuoso: Some flags have not been recognized: -XMakeItWork
01:54:01 <dminuoso> merijn: What do you use MonadIO for anyway?
01:54:07 <dminuoso> Is it to make testing easier?
01:55:30 <merijn> dminuoso: Tasty.HUnit's @? has this annoying AssertionPredicable class on it which leads to ambiguous types when I pass it "MonadIO m => m Bool" values
01:56:17 <dminuoso> merijn: https://prime.haskell.org/wiki/Defaulting
01:56:20 <dminuoso> Mmm.
01:56:24 <merijn> dminuoso: And annotating the types everywhere is annoying
01:56:54 <dminuoso> merijn: How's the positioning of the type arguments? Is TypeApplications an option?
01:57:32 <lavalike> merijn: maybe make a new helper?
01:58:17 <merijn> lavalike: Defining custom operator variations that are similar but different to Tasty.HUnit also seems rather obnoxious for anyone reading it
01:58:56 <lavalike> import hiding, redefine, with stricter type?
01:58:57 <merijn> Also, the rules for defaulting are surprisingly hard to find in either the Report or User's Guide
01:59:23 <merijn> lavalike: The problem is that I use it with Bool input too, so I need at least two variations for that approach
02:18:41 <merijn> hmm, I should really get back to writing a working vim fold implementation for Haskell...
02:20:19 <cocreature> I’ll take an ugly type annotation over defaulting any day
02:20:52 <merijn> cocreature: Yeah, but in this case it's just a bunch of tests where I never want anything else anyway
02:21:45 <cocreature> merijn: hide the operator from hunit and define a specialized version of the same name?
02:22:10 <merijn> cocreature: Yeah, that's what I had so far, but then I realised I need it with regular Bool too >.>
02:27:32 --- mode: glguy set +v GIra
02:47:59 --- mode: glguy set +v jackyx[m]
02:48:48 --- mode: glguy set +v la5tl19ht
03:10:04 <pie_> anyone here know much about "persistent data structure"s?
03:11:34 <pie_> i'm thinking it would be cool if i could have a versioned data structure with fork/merge/etc, that would by this facilitate caching as well
03:12:07 <pie_> and i haven't figured out which yet, but i'd want the versioning for either a DAG or a generic graph
03:12:20 <pie_> i mean directed graph
03:15:14 <liste> pie_: Okasaki may have something for that
03:15:55 <liste> (Chris Okasaki: Purely Functional Data Structures)
03:16:52 <pie_> idk, having read okasaki's table of contents, more or less all of it sounds alien to me
03:17:13 <pie_> ok well not all of it
03:17:55 <pie_> but I don't know a whole lot of algorithms/datastructrues in any case
03:18:02 <koz_> pie_: I would suggest learning some.
03:18:30 <koz_> Since persistent data structures kinda assume you know about the non-persistent kind at least a little.
03:21:49 <pie_> ok actually i might be able to be more specific in a useful way, I want to version a data-flow graph thing
03:22:50 <pie_> somethng you'd use a node editor for
03:23:01 <pie_> the DAG/graph restriction is undecided because I don't know if I should allow "cycles" or not
03:23:57 <pie_> I kind of feel like I shouldn't, but that feels unnecessarily restrictive if I can have some kind of ?fixpoint operator? wrapping a loop
03:24:06 <pie_> but I guess thats a second unrelated question
03:24:30 <pie_> this just seems like it could be pretty cool but I just don't know enough about the subject area :(
03:27:21 <pie_> why have VCS style history? because linear undo/redo is unnecessarily constraining
03:32:12 --- mode: glguy set +v akara
03:32:27 <akara> I want to dump the assembly file output from a cabal project
03:32:43 <akara> I tried adding -ddump-asm to the ghc-options field of the cabal file
03:32:55 <akara> but i am not sure where it is dumping the assembly
03:33:06 <akara> how do I achieve this
03:35:22 <cocreature> akara: how are you building the project?
03:35:37 <akara> cabal new-build
03:35:44 <maerwald> when you turn on profiling with new-build and then turn it off again, do you still keep the profiling build?
03:36:09 <cocreature> it should end up somewhere in dist-newstyle. try something like "find dist-newstyle -name '*asm*'"
03:36:27 <cocreature> also note that you need to force a recompilation (e.g. by deleting dist-newstyle)
03:42:01 <alp> reygoch, replied :)
03:42:31 --- mode: glguy set +v reygoch
03:42:47 <reygoch> alp, Just reading it, thanks :D
03:45:37 <alp> reygoch, btw there's #servant, in which your servant questions are less likely to get lost =)
03:47:11 <reygoch> alp, thanks, didn't know that. IRC is kinda a new thing to me :D
03:57:32 <lukelau> Is it possible to tell cabal to use a specific version of ghc installed via stack?
04:00:56 <cocreature> lukelau: you can either put it in your PATH or use the -w option to pass the path to the ghc binary
04:01:05 <lukelau> cocreature: thanks
04:02:11 <merijn> maerwald: Yes
04:02:39 <cocreature> merijn, maerwald: that’s true for your dependencies but not for your local packages iirc
04:02:48 <merijn> maerwald: The packages installed with profiling into the global store have a different tag and local build products are stored in separate directories depending on optimisation/profiling directories
04:03:05 <cocreature> there is a different directory for optimisation levels but not for profiling
04:03:06 <merijn> cocreature: It keeps different dirs for optimisations, I thought it did for profiling too, but no 100% sure
04:03:18 <merijn> maerwald: ok, so only for non-local packages
04:03:33 <cocreature> I made a patch for that at some point but apparently it caused some problems and I never found the time to investigate
04:38:47 --- mode: glguy set +v FM_
04:43:10 <inquisitiv3> I'm trying to create a very simple stack project with QuickCheck as a dependency. `QuickCheck` is added to the `extra-deps` list in `stack.yaml`. The project was created with `stack new [name] simple`. But when I run `stack build` inside the dir.
04:43:53 <inquisitiv3> I get the error message "[path]/blackjack/QuickCheck/: getDirectoryContents:openDirStream: does not exist (No such file or directory)
04:43:59 <inquisitiv3> "
04:44:45 <inquisitiv3> It's a schoolproject. I'm trying to avoid having QuickCheck globally installed if's possible.
04:44:57 <cocreature> inquisitiv3: can you show us stack.yaml and also the cabal file?
04:45:21 <barrucadu> There might also be a package.yaml
04:45:33 <cocreature> ah I see what’s going on. you have added QuickCheck as a path to extra-deps
04:45:34 <lyxia> You shouldn't need to add QuickCheck to extra-deps
04:45:34 --- mode: glguy set +v hk_
04:45:41 <cocreature> so it tries to find it on your local hard disk
04:46:04 <cocreature> as lyxia mentioned you don’t need to add it to extra-deps at all, what you need to do is to add it as a dependency in your cabal file
04:47:11 <inquisitiv3> cocreature: https://gist.github.com/inquisitiv3/846b085c7d4973b627df1b5d7d7d5f49
04:48:44 <inquisitiv3> Aha
04:49:32 <inquisitiv3> Should I edit the cabal file directly, or use package.yaml? This is the first time ever I try to set stack up, and the documentation for stack seems to say that package.yaml is preferable?
04:49:43 <cocreature> if you have a package.yaml file you need to edit that
04:49:54 <cocreature> you can also delete the package.yaml file and edit the cabal file instead
04:49:58 <jackyx[m]> https://getcryptotab.com/515109
04:50:14 <cocreature> what you shouldn’t do is have a package.yaml file but edit the cabal file since in that case it is autogenerated from the package.yaml file
04:50:39 <inquisitiv3> Great! Thanks! 
05:28:56 --- mode: glguy set +v dataN
05:29:25 <dataN> can a type family be used as the argument supplied to a type instance?
05:30:53 <dstolfa> dataN: what do you mean by type family and type instance here
05:35:36 --- mode: glguy set +v dataN_
05:35:43 <dataN_> e.g. https://pastebin.com/UncWjybY
05:36:55 <dataN_> it give an error of; Illegal type synonym family application in instance
05:37:06 <dataN_> type instance B (A Int) = Bool
05:40:26 <dataN_> maybe thats to stop potentially infinitely recursive type families from having to be checked against   
05:41:28 <c50a326> hey, in the Mark P. Jones paper on "... Overloading and Higher-Order Polymorphism", when it gets into trees, there's a symbol `:^:` used and not explained and not found on Hoogle. What's this? o
05:41:42 <c50a326> e.g. data BinTree a = Leaf a | BinTree a :^: BinTree a
05:42:16 <Ariakenom> c50a326: that declares a constructor
05:42:39 <Ariakenom> like Data List a = Empty | a : List a
05:43:11 <dataN_> here is an example where this kind of use is motivated; https://pastebin.com/8rHbNmxd
05:43:32 <Ariakenom> replacing : with Cons gives us Data List a = Empty | Cons a (List a)
05:45:05 <c50a326> Ariakenom: so it's the same as: data BinTree a = Leaf a | BinTree a : Bintree a -- ?
05:45:13 <liste> c50a326: you can define symbolic constructors if they start with >
05:45:16 <liste> :
05:45:40 <liste> eg. "data MySum = Int :+: Int", "5 :+: 6 :: MySum"
05:45:49 <Ariakenom> data BinTree a = Leaf a | Branch (BinTree a) (Bintree a)
05:46:04 <Ariakenom> where branch is named (:^:)
05:46:11 <c50a326> ah okay
05:46:15 <c50a326> cheers
05:53:01 <dataN_> here is the closest thing to whats wanted that compiles; https://pastebin.com/hH4UjWAL
05:54:23 <dataN_> its trying to say that an associated type should be defined over the result of another 
05:56:16 <dataN_> its similar to wanting a function thats defined over a specific value, so that then a type with only this value is needed
05:58:22 <oisdk> +dataN_ as far as I know you can't do that, no
05:58:22 <dataN_> type families match over all types of some kind, the question is how to express that a type family must be defined for a specific type
05:58:48 <oisdk> because if you instead wrote
05:58:59 <oisdk> type instance B Int = String
05:59:09 <oisdk> (sorry, id you wrote that also)
05:59:16 <oisdk> it wouldn't know how to choose between them
06:00:23 <dataN_> right, so then the idea is to restrict the kind so that the only inhabitant is the desired type
06:02:03 <oisdk> Yeah, you can do that, but you'd need to use classes w/ type families
06:02:12 <oisdk> Don't think you can do it with type families alone at the moment
06:02:13 <merijn> dataN_: tbh, at this point wouldn't your life be MUCH simpler if you just used Idris?
06:02:24 <oisdk> https://stackoverflow.com/questions/14133121/can-i-constrain-a-type-family
06:02:39 <merijn> dataN_: The stuff you're doing is the incredibly painful cutting edge of GHC extension abuse
06:02:41 <dataN_> is that the same issue?
06:04:56 <dataN_> hmm yes, an equality constraint on the type might have worked
06:05:57 <EvanR> "just" use idris
06:06:19 <mpickering> If I have a handle and call hClose on it, it should no longer appear in the output of lsof?
06:06:25 <dataN_> huh, well until then the only thing to do is to give "directions" to the user to say how its supposed to work
06:06:36 <dstolfa> EvanR: yeah, porting codebases is easy :-)
06:06:41 <dstolfa> especially large ones!
06:12:59 <oisdk> +dataN_  https://pastebin.com/WteF5P2C
06:17:10 --- mode: glguy set +v dataN
06:17:11 <cocreature> dstolfa: the larger the codebase the easier it gets! that’s how this works, right?
06:17:20 <dstolfa> cocreature: yep! :-)
06:17:39 <dataN> heres the unconstrained code for the application; https://pastebin.com/8RnVVLeC
06:18:25 --- mode: glguy set +v dataN__
06:18:25 <dmwit> mpickering: Maybe, unless it was previously semiclosed.
06:18:51 <mpickering> The situation is that these handles are created and then passed to `proc`
06:19:04 <mpickering> I then call `hClose` on them but they still appear in `lsof` and leak
06:19:19 <dmwit> I wouldn't be surprised to learn that proc semicloses its arguments.
06:19:40 <dmwit> Which `proc` is this? The one I can see in the `system` package accepts strings, not handles.
06:19:41 <mpickering> What does to be semiclosed mean?
06:19:49 <mpickering> System.Process
06:20:02 <merijn> EvanR: To be fair, he's been asking questions/running headfirst into problematic type level stuff for the past few days...The kind of stuff that's super hard to get working in Haskell, so the question is if it's worth the effort
06:20:07 <dmwit> https://hackage.haskell.org/package/process-1.6.4.0/docs/System-Process.html#v:proc <- no handles in the arguments to this function
06:20:43 <dmwit> Semiclosed means the handle isn't available for further action via the usual handle-based IO actions, but its contents has been stuffed into some lazy IO action.
06:20:51 <mpickering> dmwit: Ah I mean that they are used in CreateProcess
06:20:52 <dmwit> e.g. hGetContents semicloses its argument.
06:21:40 <mpickering> So I have to force something in order to get the handle to close?
06:22:45 <merijn> mpickering: Depends what you did with it?
06:23:30 <mpickering> The process is passed to `withCreateProcess`
06:24:15 <mpickering> and inside that, there's a call to waitForProcess
06:24:36 <dataN__> merijn: its not that these things are needed for "linear types", but as the most abstract approach is available at term level, it would be good to see that what approach works at type level. https://gist.github.com/dataN-hs/e0a154cd485d34d8a1c0c35dc49bebd2
06:25:14 <dataN__> this "flagged definition" stuff is just another attempt to wrangle overlapping instances
06:25:41 <merijn> dataN__: I like to think of myself as a -XKitchenSink haskell programmer, but honestly this stuff is just way to complex for me to bother even trying to comprehend >.>
06:25:55 <dmwit> mpickering: Not sure. I did a bit of source diving; assuming you're passing these handles as StdStreams using UseHandle, my read is that they should be truly closed in the parent process (but kept open in the child process, of course).
06:31:03 <mpickering> dmwit: So what precisely are you suggesting? That I need to call hClose myself?
06:31:56 <dataN__> e.g. 'get' has the same type as 'state', and 'set' has the same type as 'act', e.g. functions using act should be able to be used with (:)
06:32:31 <dataN__> zippers which are coupled pairs of lenses can then use more generalised higher order functions 
06:34:16 <dataN__> trying not to use local instances (e.g. an instance of Act resulting from the instance of Set for (:)) by using flags instead 
06:35:54 <dmwit> mpickering: I am suggesting that the handle will still show up in lsof, and must, because the *child* is using that handle. If you want it to disappear, that's on the child to close it. I am also saying that if you observe that the parent still has the handle open, then I do not have an explanation for this observation.
06:37:27 <mpickering> I think I might have solved it
06:38:01 <mpickering> I fully evaluated the result of `waitForProcess` and then closed the two handles.
06:38:06 <mpickering> seems to have stopped the leak
06:53:42 <mpickering> indeed that worked, thanks dmwit and merijn for your considerations
07:51:48 --- mode: glguy set +v Boarders
07:52:07 --- mode: glguy set -v Boarders
07:52:56 --- mode: glguy set +v Jante
07:55:00 <Jante> Are there Functors for which one couldn’t express something with equivalent functionality via lenses? Or can - in principle - all Functors always be replaced by lenses/optics?
07:55:37 <Ariakenom> Jante: the type "Lens" does use Functor in the definition
07:56:17 <Taneb> Jante: what do you mean by that?
07:56:52 <Taneb> Lenses allow us to modify (a -> b) -> s -> t and to view s -> a
07:57:06 <Taneb> All functors, the modify works, (a -> b) -> f a -> f b
07:57:12 <Taneb> But for many view doesn't make sense
08:00:39 <Jante> When I have a type data Foo a b c d for which (Foo a b c) I can implement a Functor instance then calling fmap and such a value resembles kind of a “setter” on the `d`.
08:01:02 <jchia_> itraverse is to ifor as imap is to x. Is there an x that exists in a commonly-used library?
08:01:17 <Jante> It seems that with a Lens I could also create such a setter, but on top of that possibly also one that can change the a/b/c types.
08:01:18 <jchia_> Basically, looking for flip imap.
08:01:29 <jchia_> but in a preexisting function
08:05:53 <Ariakenom> Jante: If you have a Lens and a Functor instance for a thing you can use the Lens instead. But you can't replace Functor with Lens since not all Functor things can have a Lens
08:06:22 <Ariakenom> "IO a" can have Functor IO but not a Lens to the a
08:07:39 <Ariakenom> is it "Lens' (IO a) a"? I'm not familiar with lenses
08:08:15 <Taneb> Ariakenom: yes, Lens' (IO a) a is correct
08:08:23 <Ariakenom> woo
08:08:38 <Taneb> (or Lens (IO a) (IO b) a b for the type-changing variety)
08:09:32 <Ariakenom> yes, that's what I meant
08:09:45 <Ariakenom> I just realised and went to the docs
08:12:21 <Taneb> Aaaargh, I'm trying to switch from GHC 8.2 to GHC 8.4 and one of the packages we have at work errors weirdly when trying to generate the haddocks
08:18:29 <Jante> Ariakenom and Taneb: thx for the insights.
08:27:36 <dmwit> Jante: In fact, *most* functors do not have a lens that corresponds to its fmap.
08:28:07 <dmwit> Proxy a has no values of type a for the lens to look at; but for most other functors the problem is that there can be too many, e.g. [a], Map k a, Tree a, etc.
08:28:16 <Ariakenom> what does *most* mean here?
08:29:04 <dmwit> It means: trawl through Hackage. Count the number of Functor instances. Now count the number of Functor instances that directly correspond to a lens. The first number is much bigger than the second.
08:29:16 <EvanR> most of the numbers are not 1
08:29:32 <EvanR> the population of 'a' which lets you view 
08:33:07 <Ariakenom> EvanR: most of the (Nat, Nat) tuples aren't (_,1)?
08:34:38 --- mode: glguy set +v dataN
08:34:42 <EvanR> true
08:34:55 <EvanR> i will now come up with a reason why
08:34:56 <dataN> is there a way to return a datatype from a type level list of types corresponding to the types of its records? 
08:35:14 <Ariakenom> :)
08:35:39 <dataN> sorry, not records, as they wouldnt have names, but just the types of a product datatype
08:36:11 <EvanR> type level proj
08:36:26 <EvanR> Fst (A,B) = A
08:36:29 <EvanR> Snd (A,B) = B
08:36:49 --- mode: glguy set +v lilduckie6431[m]
08:37:09 <EvanR> all your product types are of the form (A,B) right? :)
08:38:03 <EvanR> Ariakenom: if you have a increasing nested subsets of (N,N) then the proportion of (_,1) tends to zero
08:39:27 <EvanR> increasing in such a way that any (i,j) is eventually covered
08:40:06 <dataN> data D q a :: * requires a datatype is specified, it wont accept a list of types instead 
08:41:14 <Ariakenom> EvanR: I'm not convinced there's not sequence of (i,j) where the ratio is greater
08:42:10 <EvanR> youre right, this increasing subset thing needs more flesh
08:42:23 <Ariakenom> I feel like the ratio may tend to infinity with the right choice
08:43:02 <dataN> also, a datatype requires that values of those types exist.
08:43:28 <dataN> maybe something like a TypedVector
08:43:36 <EvanR> lay out the (N,N) elements in a grid. now select a starting point. at each step expand your subset in each direction
08:44:14 <dataN> but that still doesnt have kind *
08:45:45 <MarcelineVQ> jchia_: why a pre-existing one?
08:45:47 <EvanR> so, this is really a property of the intuitive grid picture which technically has nothing to do with (N,N) as a set
08:46:14 <jchia_> MarcelineVQ: Simply for brevity.
08:46:27 <EvanR> because you are correct that the elements can be listed where every other is a (_,1)
08:48:28 <c50a326> hey I'm checking out Hakyll, I'm just wondering how `stack exec site watch` does what it does, site.hs doesn't seem to have any webservery stuff in it
08:48:52 <c50a326> and I can't see any clues in stack.yaml or in the cabal file
08:49:48 <Ariakenom> EvanR: heh infinities
08:49:49 <MarcelineVQ> jchia_: a possibly extra import is brevity? hehe   just to be clear you're after  f a -> (key -> a -> b) -> f b  ?
08:51:16 <jchia_> MarcelineVQ: I already have imap, itraverse & ifor in my custom prelude. If this function exists, I won't reinvent the wheel and I'll just reexport it from my custom prelude. Yes.
09:07:16 <Jante> Is there a Bifunctor for State? Would it make sense to be able to change the type of the state?
09:07:59 <EvanR> if State = (,) yes, but there goes your Monad
09:08:25 <Taneb> Jante: it's difficult to define a Bifunctor for State because the state is used both as the input and output of a function, s -> (a, s)
09:08:44 <EvanR> oh nvm s -> (a,s)
09:08:46 <jchia_> MarcelineVQ: This function is just 'flip imap'. The bigger problem is I'm not sure what to call it even if I were to define it myself.
09:09:14 <phadej> <@&>
09:09:27 <dstolfa> phadej: is that a thing
09:09:31 <phadej> no
09:09:32 <dstolfa> :t (<@&>)
09:09:33 <lambdabot> error:
09:09:34 <lambdabot>     • Variable not in scope: <@&>
09:09:34 <lambdabot>     • Perhaps you meant ‘<&>’ (imported from Control.Lens)
09:09:35 <dstolfa> damn it
09:09:39 <dstolfa> it looked like a nice flower
09:10:05 <phadej> :t (^@~)
09:10:06 <lambdabot> error:
09:10:07 <lambdabot>     • Variable not in scope: ^@~
09:10:07 <lambdabot>     • Perhaps you meant one of these:
09:10:09 <phadej> hmm
09:10:12 <phadej> it could been
09:10:15 <EvanR> > let (@->--) = () in (@->--)
09:10:17 <lambdabot>  ()
09:11:04 <phadej> :t (%@~)
09:11:06 <lambdabot> AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
09:11:07 * EvanR waits for every professional programmer to explain thats why haskell sucks
09:11:39 <phadej> :t \x f -> x & itraverse %@~ f
09:11:41 <lambdabot> error:
09:11:41 <lambdabot>     • Couldn't match type ‘Indexed i a1 (Identity b)’
09:11:41 <lambdabot>                      with ‘i0 -> a -> Identity b1’
09:11:57 <phadej> :t \x f -> x & itraversed %@~ f
09:11:59 <lambdabot> TraversableWithIndex i t => t a -> (i -> a -> b) -> t b
09:12:04 <phadej> like a boss
09:13:51 <phadej> so.... following lens naming scheme, I could  imagine `imap = <@$>`, `<@&> = flip imap`
10:00:25 <dminuoso> I want to use `persistent` for the sole purpose of having declarative migrations baked into my code to simplify schema changes over the lifetime of my app.
10:00:34 <dminuoso> Is this silly?
10:09:16 <liste> dminuoso: and sql for everything else?
10:37:00 <dataN> % :k (forall a. a :: ((* -> *) :: *)) Int
10:37:00 <yahb> dataN: (forall a. a :: ((* -> *) :: *)) Int :: *
10:37:10 <dataN> % :k (forall a. a :: ((* -> forall b. b) :: *)) Int
10:37:10 <yahb> dataN: ; <interactive>:1:12: error:; * Expected kind `* -> forall b. b', but `a' has kind `k0'; * In the type `(forall a. a :: ((* -> forall b. b) :: *)) Int'
10:38:43 <dataN> % :k (* -> forall b. b)
10:38:43 <yahb> dataN: (* -> forall b. b) :: *
10:41:15 --- mode: glguy set +v vigenere
10:43:43 <dataN> % :k (forall a. a :: forall b. b)
10:43:43 <yahb> dataN: ; <interactive>:1:12: error:; * Expected kind `forall b. b', but `a' has kind `k0'; * In the type `(forall a. a :: forall b. b)'
10:44:37 <infinisil> dminuoso: That sounds reasonable, and I might go for that as well
10:45:02 <infinisil> Also, relational databases are just really useful
10:46:43 <delYsid> I will celebrate once I can turn on NoKindIsStar.
10:47:39 <infinisil> delYsid: What's that?
10:47:58 <delYsid> >8.6 will rename * to Type.
10:49:02 <dataN> % :k forall k. (forall a k. a :: (* -> k)) Int
10:49:02 <yahb> dataN: ; <interactive>:1:11: error:; * Expected kind `k0', but `(forall a k. a :: (* -> k)) Int' has kind `k'; * In the type `forall k. (forall a k. a :: (* -> k)) Int'
10:49:19 <dataN> huh, that works in ghci
10:50:00 <dataN> :k forall k. (forall a. a :: (* -> k)) Int
10:50:02 <lambdabot> k
10:50:49 <infinisil> Neato, getting closer to Idris everyday
10:54:14 <delYsid> I find * hard to read, so Type is going to improve things.
11:21:19 <dyl> Are we going to get pi quantification in the end?
11:21:30 <dyl> I'm not sure which solution was settled on.
11:32:17 --- mode: glguy set +v zoulock
11:34:22 <zoulock> Hello
11:34:47 <zoulock> How could I implement something like untilNothing :: IO (Maybe a) -> [a] ?
11:36:23 <zoulock> I've tried this, but gives an error: https://gist.github.com/zoulock/38bca607e03dc0d27236e8f2acf86d5f
11:40:50 <oak> what are you trying to achieve in bigger picture?
11:41:34 <oak> function that takes list of Maybe a's and returns list of a until first Nothing encountered?
11:41:43 <zoulock> yes
11:41:54 <phadej> you cannot get rid of IO
11:41:57 <aarvar> zoulock: you probably want IO (Maybe a) -> IO [a]
11:42:12 <zoulock> wow, you're right
11:42:13 <oak> Maybe drop the IO completely and make it a pure function
11:42:17 <aarvar> the only function of type IO (Maybe a) -> [a] is `const []`
11:42:42 <aarvar> IO functions are pure
11:43:04 <lavalike> :t fmap maybeToList
11:43:05 <lambdabot> Functor f => f (Maybe a) -> f [a]
11:45:11 <luqui> aarvar ugh.  the word "pure" should mean *something*.
11:45:27 <aarvar> zoulock: also checking isJust and then using fromJust is an antipattern
11:45:31 <aarvar> pattern match instead
11:45:52 <zoulock> how can I pattern match in a do block?
11:45:58 <luqui> so like, io functions are pure in a sense relative to other PLs, but in the context of a conversation about haskell, io is pretty much the definition of impure
11:46:13 <MarcelineVQ> zoulock: you can use case where you're using if
11:46:17 <aarvar> luqui: it's a pure function which returns an IO action
11:46:24 <MarcelineVQ> that is to say, instead of if, if you want
11:46:37 <luqui> yeah i get that.  that's what I call an "impure function", colloquially
11:46:55 <aarvar> which is fine, but I think that sort of thing confuses beginners
11:47:32 <luqui> "drop the IO and make it a pure function" is a completely clear sentence
11:47:55 <aarvar> as evidence see all the people who think "IO/monads are an escape hatch to allow side effects in the language", etc
11:48:17 <luqui> monads aren't, but IO is
11:48:19 <luqui> ok anyway
11:48:24 <luqui> this is going to flamey territory
11:48:44 <luqui> sorry for being so vitriolic
11:49:10 <aarvar> luqui: it's clear, and also technically wrong, given that all functions are pure. Call me a pedant if you will :)
11:49:13 <luqui> "drop the IO and make it a function outside of IO"
11:49:15 <luqui> is that acceptable?
11:49:20 <Chousuke> IO alone doesn't really allow side-effects though, does it? unsafePerformIO does I guess.
11:50:07 <hexagoxel> if we allow as evidence what any group of people think, you can argue really weird shit
11:50:46 <Ariakenom> One thing I like about haskell is that you can often be entirely precise and say the type signature you mean
11:50:58 <aarvar> hexagoxel: well, I was suggesting it as evidence that the imprecise terminology confuses people
11:51:03 <Ariakenom> abstract but not vague
11:51:42 <MarcelineVQ> > (\x -> case x of Nothing -> "not a thing"; Just y -> "number: " ++ show y) (Just 12)
11:51:44 <lambdabot>  "number: 12"
11:51:48 <MarcelineVQ> > (\x -> case x of Nothing -> "not a thing"; Just y -> "number: " ++ show y) Nothing
11:51:51 <lambdabot>  "not a thing"
11:51:57 <aarvar> I'm not sure what other evidence one could have of people being confused, other than people thinking confused things
11:52:00 <MarcelineVQ> zoulock: this is what I mean by case
11:52:53 <luqui> aarvar, well now i can meet you at your level of pedantry.  someone thinking something is not evidence, it's not observable ;-)
11:53:01 <MarcelineVQ> Note that there's not need there to ask isJust or request fromJust, the presence of Just in each case is bare to see
11:53:02 <hexagoxel> aarvar: and i was refusing to accept a vague reference to people's thought as evidence
11:53:21 <aarvar> hexagoxel: sure, I'm just speculating
12:00:32 <dmwit> :t let loop = do v <- ?act; case v of Nothing -> return []; Just x -> fmap (x:) loop in loop
12:00:33 <nitrix> Chousuke: IO doesn't allow side-effects, but it does allow effects.
12:00:33 <lambdabot> (Monad f, ?act::f (Maybe a)) => f [a]
12:01:59 <aarvar> nitrix: one then of course has to ask what an effect is
12:02:15 <hexagoxel> zoulock: if the syntax is an issue, you can find several similar examples around https://hackage.haskell.org/package/monad-loops-0.4.3/docs/src/Control-Monad-Loops.html#whileJust_
12:02:24 <nitrix> aarvar: Are you asking me?
12:02:40 <aarvar> I guess
12:02:49 <Ariakenom> nitrix: that distinction isn't really agreed upon. even though I do
12:04:24 <hexagoxel> zoulock: that module already contains `unfoldM` which is what you want, but it is implemented via something more general, so i hope it is not too much of a spoiler.
12:05:39 <nitrix> "I guess". Sometimes I wonder if people are being noisy just to be be noisy.
12:06:03 <nitrix> You don't see this often on #haskell :p
12:07:12 <aarvar> nitrix: I was more making a rhetorical point that the word "effect" is rather vague
12:07:15 <aarvar> or at least it can be
12:10:11 <aarvar> nitrix: e.g., if I have foo :: [Int], is foo effectful?
12:10:38 <aarvar> after all, [] can be used to express the "effect" of nondeterminism
12:11:41 <nitrix> There's no way to know, as the Standard Report doesnt have a word about effects. I supposed if main has the signature :: [Int] and the runtime gave particuliar meaning to some Ints, possibly.
12:13:14 <aarvar> nitrix: okay, so you want to reserve the word "effect", for IO
12:14:15 <nitrix> As long as you understand IO as I/O, not the type IO, we're probably getting closer, yeah.
12:14:21 <nitrix> I don't think determinacy (and various other computational models) relates to effects.
12:14:29 <Ariakenom> STM ?
12:14:37 <aarvar> State?
12:14:43 <aarvar> LinearState?
12:15:04 <aarvar> IO is really LinearState isn't it?
12:16:36 <zoulock> hexagoxel: thank you!
12:17:24 <nitrix> That's an interesting observation. From inside a State monadic computation, things would appear as effectful, yet from the outside, the effects aren't visible.
12:19:09 <dolio> No, IO is not linear state.
12:20:11 <aarvar> dolio: well, maybe it shouldn't be, though that's how it's implemented
12:20:34 <dolio> Yeah, but it doesn't make sense to think of it that way.
12:21:30 <dolio> GHC just implements IO by having functions with side effects.
12:22:03 <aarvar> well, if they were linear they wouldn't have side effects would they?
12:22:07 <dolio> Yes.
12:22:17 <aarvar> how so
12:23:01 <dolio> The token passing is not an adequate way of modelling what I/O does without incorporating the I/O into the description of functions.
12:24:05 <dolio> Because you can have infinite sequences of function calls that produce observable behavior even though you will never get back a token from them.
12:24:31 <dolio> And those are observably different than infinite sequences of function calls that do not produce any output.
12:26:20 <nitrix> Does this relates to the Halting Problem?
12:26:31 <dolio> I don't think so.
12:26:49 <aarvar> dolio: hm...
12:27:07 <dolio> It's more that `Token -> (Token, a)` is only adequate if your I/O stuff is guaranteed to terminate.
12:27:23 <dolio> Otherwise you need something more coinductive.
12:27:56 <aarvar> what if we imagined the Token being evaluated lazily though
12:27:59 <dolio> I guess it's related in that sense.
12:28:02 <aarvar> the token could be coindutctive
12:28:08 <aarvar> *coinductive
12:28:37 <dolio> The result type is irrelevant, I think.
12:29:25 <dolio> Certainly the token type is.
12:29:26 <aarvar> I suppose you're right
12:29:35 <dolio> The problem is modelling it as state.
12:30:14 <aarvar> maybe it should be an update monad instead?
12:31:10 <aarvar> na, idk
12:33:04 <dolio> Something more continuation-based works, I think.
12:33:13 <dolio> Some kind of infinite tree.
12:43:38 <dmwit> dolio: Hold up, even in the fully-terminating world you must have observations that are distinct from the value of the returned token.
12:44:51 <dmwit> dolio: \x -> print True and then return (x, ()) is observably different from \x -> print False and then return (x, ()).
12:44:57 <dmwit> dolio: So the semantics of your (Token -> (Token, a)) function can't be just the pure semantics already, even with termination.
12:45:11 <dmwit> And once you admit that, I don't see why "nonterminating and no output" and "nonterminating and yes output" should be a problem.
12:46:32 <dolio> `\x -> print True and then return (x, ())` isn't really well formed. You're not passing a token to `print True`, and if you pass x, it's not linear.
12:47:09 <dolio> You also get a token back from printing that you're dropping, which is also non-linear.
12:49:25 <dolio> Making the definition of IO abstract can prevent you from doing non-linear things. But then it still doesn't work.
12:53:11 <dolio> Also doing I/O via uniqueness types in e.g. Clean and Mercury doesn't exactly make sense.
12:54:36 <dolio> But it avoids your examples.
12:54:53 <dmwit> Here when I wrote `print True` I meant "do the underlying, untyped IO stuff in the RTS".
12:55:04 <dmwit> You have to have some primitive finally which does not respect the typing discipline.
12:55:14 <dmwit> I'm talking here about the use of that primitive.
12:56:13 <dmwit> So it's the primitive boolean-printer given to you by the runtime. It makes an observable change to the terminal and then returns the token it was handed.
12:56:15 <dolio> The primitive for print is `print# :: Token -> String -> Token`, and Tokens are linear.
12:56:47 <dolio> That's not the proposed explanation.
12:57:08 <dolio> The explanation is that the change to your terminal is represented by returning a different token.
12:57:24 <dolio> Because the tokens are 'states of the world'.
12:58:03 <dmwit> Hm. I always sort of assumed `data Token = Token` in these explanations.
12:58:37 <dmwit> It's used linearly, but there's no sense making up different ones.
12:58:39 <dolio> And that can make sense if every computation eventually finishes and tells you what the state of the world is at the end.
12:59:16 <dolio> But `forever $ print True` doesn't even give you back the end state of the world.
12:59:26 <dolio> It just keeps computing new worlds forever.
13:09:05 <dyl> Currently building a copy of GHC with afl-fuzz instrumentation.
13:09:19 <dyl> I wonder what we can get this to generate by fuzzing runhaskell.
13:09:35 <dyl> I'm going to feed it the keywords and all of Prelude.
13:15:35 <trcc> hmm is it possible to specify a relative uri?
13:16:14 <trcc> or are URIs always absolute?
13:20:56 <dyl> trcc that would be a 'URI reference'
13:21:07 <dyl> Which is either a proper URI or a relative path.
13:21:21 <dyl> (aka a relative reference)
13:21:37 <trcc> ah never heard of URI reference
13:23:23 --- mode: glguy set +v tms__
13:23:26 <trcc> dyl: so a URI reference is leaving of the file part (the scheme) when constructing a path
13:23:45 <dyl> Yes, and it can be any subset of the sub-components on the right too.
13:24:01 <trcc> can you elaborate on the last part?
13:24:09 <dyl> Look at the examples on WIkipedia.
13:24:23 <dyl> Or in the RFC: https://tools.ietf.org/html/rfc3986
13:24:27 <dyl> RFCs are your friends.
13:24:42 <trcc> thanks
13:28:05 --- mode: glguy set +v kolden
13:48:20 <Fare> Does Haskell have a standard or semi-standard name for Schönfinkel's Z combinator? zcompose :: (b -> c) -> (a -> b) -> a -> c  zcompose x y z = x (y z)
13:48:45 <dibblego> @type (.)
13:48:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:24:26 <ggVGc> can someone tell me what I'm trying to do here? https://gist.github.com/c96d6cb5a875db2e6bc3ede964353ed3
14:24:37 <ggVGc> seems there is a much better way to write that
14:24:41 <ggVGc> which I can't see now
14:53:34 <mpickering> dmwit: Earlier you were right about the handles, it turned out there was one more place they were opened and not closed I missed.
14:53:45 <int-e> > Just False <|> Just True
14:53:47 <lambdabot>  Just False
14:55:20 <int-e> > map (any (== 1)) [Nothing, Just 1, Just 0]
14:55:22 <lambdabot>  [False,True,False]
14:56:15 <int-e> ggVGc: how about `any`?
15:16:37 <argent0> Hi, why does `a` requires a `Monoid` instance? https://lpaste.net/2500664589776060416
15:17:02 * argent0 9 loc + 10 loe
15:18:25 <hpc> argent0: b = Maybe a
15:18:47 <hpc> Monoid a => Monoid (Maybe a)
15:18:54 <hpc> and that's how the constraint appears
15:19:10 <argent0> hpc: thanks
15:21:52 <Cale> argent0: Also, that won't do what you're suggesting it will -- it's going to combine all the elements satisfying the predicate
15:22:25 <Cale> i.e. it's effectively  mconcat . filter p
15:24:06 <int-e> ggVGc: to clarify, what I had in mind was:  any isRepeaterDef srcDef || any isRepeaterDef dstDef
15:24:53 <int-e> :t any . any
15:24:54 <lambdabot> (Foldable t2, Foldable t1) => (a -> Bool) -> t1 (t2 a) -> Bool
15:37:25 <argent0> Cale: Yes, it was wrong. But I fixed it: https://lpaste.net/4646115150581989376
15:42:44 <Cale> argent0: Yeah, that's the same as "First" from Data.Monoid.
15:45:31 <argent0> Cale, thanks is there a way to find all monoid instances? Or how did you know?
15:45:59 <kvda> What would a functor implementation for type with kind * -> * -> * look like? Is the 2nd type ignored/returned like in the constant * kind case?
15:48:25 <hpc> what would the type of fmap be?
15:49:33 <kvda> Say you have 'data Test = Nothing | One a | Two a b'
15:49:59 <kvda> What would be functor instance for it? Particulary for the Two constructor
15:50:24 <hpc> i assume you meant data Test a b
15:50:33 <kvda> yes pardon
15:50:47 <kvda> To me it seems you'd ignore b and apply a in Two's case, but not sure if that's correct
15:50:49 <hpc> look at the Functor instance for Either
15:51:03 <hpc> instance Functor (Either a) where ...
15:51:06 <hpc> f = Either a
15:51:07 <shachaf> If you mean the Haskell class Functor, the instance would have fmap :: (a -> b) -> Two x a -> Two x b
15:51:14 <hpc> and then f :: * -> *
15:51:17 <hpc> and problem solved
15:51:40 <kvda> Thanks, Either should have occured to me as a good case
15:51:41 <shachaf> If you mean functoriality more generally, there are lots of ways to express it. Two is a functor in both of its arguments.
15:52:06 <koz_> shachaf: Would Two admit a Bifunctor instance?
15:52:08 <koz_> I assume yes.
15:54:31 <kvda> shachaf oh that makes sense, have an instance for Two case
15:55:39 <Cale> argent0: I just knew because I'd read the library's documentation before
16:20:22 <dmwit> mpickering: welp. Glad you got it working in the end.
16:21:57 <dmwit> ggVGc: M.member srcID defs || M.member dstID defs
16:22:21 <wroathe> Is there a function in base that lets you perform an IO action conditionally?
16:22:26 <wroathe> Without having to use if/case or w/e
16:22:40 <dmwit> ggVGc: (The result of `isRepeaterDef` is completely ignored in your current code.)
16:22:47 <wroathe> like doAction True (hSetBuffering ...)
16:22:51 <WinchellsM> Simula is Linux VR Desktop for the HTC Vive -- built via Haskell over the Godot game engine: https://d.tube/#!/v/sudoreboot/t026ny0m
16:22:54 <WinchellsM> We're looking for alpha testers (from any distro, but Ubuntu/Debian in particular).
16:22:59 <WinchellsM> Is anyone here interested?
16:23:01 <WinchellsM> :-)
16:23:05 <int-e> :t when
16:23:06 <lambdabot> Applicative f => Bool -> f () -> f ()
16:23:15 <wroathe> int-e: gracias
16:58:40 <hololeap> i'm playing with something that combines two recursive data structures using an F-algebra. i'm calling it a "bicatamorphism". has anyone heard of this being before, or is it relatively novel? (here's my code: http://dpaste.com/0BN75XA)
16:58:55 <hololeap> *being done
17:33:20 <dmwit> ?tell hololeap That (bicata) is pretty mind-bending. Good job!
17:33:20 <lambdabot> Consider it noted.
17:40:11 <sj1k> Just started learning haskell yesterday and was wondering, are there any standard style guides? (similar to python's pep8)
17:40:19 <sj1k> Couldn't find anything from a google search
17:40:31 <boj> sj1k: there are a few, but not exactly a community standard
17:40:38 <sj1k> Fair enough.
17:42:06 <sj1k> I suppose I'll develop my own style
17:42:08 <sj1k> :D
17:42:47 <boj> i used this one as a base for my team, we are quite happy with it - https://github.com/frontrowed/guides/blob/master/haskell-style.md
17:43:26 <boj> it aligned really close with how i was doing things anyways
17:44:52 <sj1k> Thanks, ill check it out.
17:46:40 <sj1k> A lot of things in there that go over my head but ill keep it bookmarked
18:20:02 <Axman6> gret food, excellent coffee, near the beach and the snow
18:26:13 <Axman6> uh, wrong window
18:39:13 <siwica> When composing types, is it possible to prevent a type variable from being higher-kinded if not otherwise restricted? E.g. could a define an Identity newtype such that `Identity Int` is valid but `Identity Just` is not?
18:39:45 <jackdk> set -XKindSignatures and then `newtype Foo (x :: *) = ...`?
18:40:35 <dmwit> siwica: That is already the case for Identity.
18:40:40 <dmwit> :k Identity
18:40:42 <lambdabot> * -> *
18:41:37 <dmwit> :k Identity Just -- kind error
18:41:38 <lambdabot> error:
18:41:39 <lambdabot>     • Expecting one more argument to ‘'Just’
18:41:39 <lambdabot>       Expected a type, but ‘'Just’ has kind ‘a0 -> Maybe a0’
18:41:47 <siwica> Ok, thanks! I didn't now about KindSignatures
18:42:21 <siwica> dmwit: I was defining my `own newtype Identity = Identity { runIdentity :: a }`, should have said this.
18:42:36 <dmwit> siwica: The inferred kind for Identity already has the property you want.
18:42:52 <dmwit> % newtype MyIdentity a = MyIdentity { runMyIdentity :: a }
18:42:52 <yahb> dmwit: 
18:42:55 <dmwit> % :k MyIdentity
18:42:55 <yahb> dmwit: MyIdentity :: * -> *
18:43:08 <dmwit> % :k MyIdentity Just -- still a kind error
18:43:08 <yahb> dmwit: ; <interactive>:1:12: error:; * Expecting one more argument to `Just'; Expected a type, but `Just' has kind `a0 -> Maybe a0'; * In the first argument of `MyIdentity', namely `Just'; In the type `MyIdentity Just'
18:44:51 <siwica> % newtype MyIdentity a = MyIdentity { runMyIdentity :: a }
18:44:51 <yahb> siwica: 
18:45:07 <siwica> :t MyIdentity Just
18:45:09 <lambdabot> error:
18:45:09 <lambdabot>     • Data constructor not in scope:
18:45:09 <lambdabot>         MyIdentity :: (a0 -> Maybe a0) -> t
18:45:16 <dmwit> % :t MyIdentity Just
18:45:16 <yahb> dmwit: MyIdentity (a -> Maybe a)
18:45:22 <dmwit> But this has *nothing* to do with kinds.
18:45:36 <siwica> Ok, then I am missunderstanding something.
18:45:49 <dmwit> Yes, I thought you might have. =)
18:46:36 <dmwit> Perhaps you can motivate your problem a bit more.
18:47:25 <siwica> Ok, I think I understand
18:47:41 <byorgey> 'Identity Just'?  Surely you mean 'Identity Maybe'?  It seems unnecessary to bring type promotion into it
18:47:53 <dmwit> It is not yet clear what they mean...
18:47:57 <dmwit> At least to me.
18:47:59 <siwica> Yes, I mixed up data and type constructor
18:49:56 <siwica> But it would be possible to define an Identity so that `Identity Maybe` is a valid type constructor (* -> *) ?
18:50:15 <siwica> (Using KindSignatures)
18:50:52 <dmwit> No, the inferred kind for `Identity` is also the most general kind it can be given. If you want a different kind, you'll have to change the RHS of the = in the newtype definition.
18:50:57 <dmwit> But e.g.
18:50:59 <dmwit> :k Proxy Maybe
18:51:01 <lambdabot> *
18:51:17 <dmwit> :k WriterT Bool Maybe
18:51:18 <lambdabot> * -> *
18:51:33 <byorgey> siwica: since values of type  Identity a  contain a value of type 'a', that means 'a' must have kind *
18:51:57 <dmwit> So it is certainly possible to define a new type with a different definition than Identity's definition that then has a different kind.
18:52:17 <siwica> Ah, I see. I though a could in theory have any kind, e.g. also (* -> *)
18:52:33 <siwica> So type variables always have kind *?
18:52:36 <dmwit> No.
18:52:56 <dmwit> Before we see the RHS (namely `= Identity { runIdentity :: a }`), we don't know what kind the variable has.
18:53:36 <monochrom> A type variable takes on a kind that fits the rest of the code.
18:53:37 <dmwit> But because `a` is used as a type in `= Identity { runIdentity :: a }`, we learn something about what kind `a` must have.
18:53:50 <dmwit> We would learn something different if we saw, say, `= Identity { runIdentity :: a Int }`.
18:54:09 <siwica> Ah, I understand. So type variables on the RHS have kind * then?
18:54:13 <monochrom> (If the rest of the code is contradictory, you get no type variable, in fact you get no code at all.)
18:54:22 <siwica> And the LHS follows from that?
18:54:26 <dmwit> Then we would learn that `a` must be something that can be applied to `Int`, hence have kind `* -> ???`, and also that it must return a type, hence have kind `??? -> *`; putting these two facts together we'd learn that `a :: * -> *`.
18:54:48 <dmwit> No, the type variables on both sides have the same kind. But all fields of a data type must have kind `*`.
18:55:17 <dmwit> So if you see `a Int` as the type of a field, then you know `a Int :: *`. Likewise if you see `a` as the type of a field, then you know `a :: *`.
18:56:20 <siwica> Ok, thank you! I understand now.
18:57:57 <dmwit> I said "the type variables on both sides have the same kind". This was not carefully said, and maybe misleading. What I should have said is "type variables have the same kind on both sides".
18:58:39 <siwica> I got what you meant though
18:58:45 <dmwit> `a` has the same kind on both sides of the equality; `b` has the same kind on both sides of the equality; `c` has the same kind on both sides of the equality. It is possible but not guaranteed that `a` has the same kind as `b` or `c` on either side.
18:58:49 <dmwit> Great. =)
18:58:58 <siwica> The statement "fields of a data type must have kind `*`." cleared it up for me
18:59:07 <siwica> Everything else follows from that I think
18:59:08 <dmwit> Double great. =)
18:59:20 <dmwit> A lot does follow from that, yeah.
19:00:21 <dmwit> Though I wonder whether the original question has gotten lost in this discussion. Do you feel it's been answered?
19:00:27 <siwica> I got a bit confused, but thanks for your explanation!
19:01:50 <siwica> It got answered I think. 
19:02:31 <dmwit> yay!
19:03:43 <monochrom> It comes from a wider, self-obvious principle. Iff a type has values, the type's kind is *.
19:03:45 <siwica> Maybe it would be an interesting (yet maybe a dumb) question if fields of a data type could possibly also have a different kind. Let's say * -> *.
19:04:12 <monochrom> So if you start writing like "f x = ..." the type of x, no matter what, has kind *.
19:04:52 <dmwit> siwica: All terms are given a type of kind *.
19:05:08 <monochrom> You put values into fields. So field types need to have kind * too.
19:05:21 <dmwit> siwica: So... no. Data constructors cannot both take a term as an argument and have an argument of kind other than *.
19:05:41 <siwica> Yes, makes sense if I think about it. 
19:06:11 <siwica> Thanks both of you for your help!
19:07:14 <dmwit> (As for "self-obvious", I am not convinced. It wasn't even always the case in Haskell -- we used to have another kind, #, which also had types inhabited by terms.)
19:07:29 <dmwit> s/Haskell/GHC/ sure
19:08:04 <monochrom> Oh oops
19:09:00 <byorgey> and some types have kind Constraint, and have values.
19:09:04 <monochrom> But equally applies to fields. Recall "data Int = I# Int#"
19:09:13 <dmwit> byorgey: ah?
19:09:49 <byorgey> for example   (the dictionary for Num Int) :: Num Int :: Constraint
19:10:14 <dmwit> monochrom: I claimed it as a fact, which I don't dispute. I'm objecting to the fact being labeled "self-obvious", not to its truth. =)
19:10:15 <monochrom> Dictionaries are not values until you dive into core.
19:10:21 <byorgey> I'm using "has values" a bit loosely, since you can't directly work with those values in surface Haskell
19:11:16 <monochrom> Plus one day I'm going to build an implementation of Haskell that doesn't even use dictionaries for constraints.
19:11:32 <byorgey> OK, fair enough.
19:11:33 <dmwit> byorgey: But the language you can work with them in doesn't have the Constraint kind...
19:11:49 <byorgey> dmwit: oh, good point, I forgot about that =)
19:15:05 <dolio> There's still essentially #.
19:15:22 <dolio> It just has a longer name now.
19:15:46 <siwica> Btw. totally unrelated: What level of Haskell expertice would one need in order to have a reasonable chance of being employed writing Haskell? It seems jobs are still quite rare.
19:18:32 <dmwit> I am only slightly more expert in Haskell now than I was when I was hired for my current job, in which the majority of my work is Haskell.
19:19:40 <dmwit> Some of my coworkers were p. expert Haskellers before they were hired; but many of them didn't know Haskell at all. On the other hand, most of them were p. expert at several other languages, often including functional ones.
19:19:46 <dmwit> So... it's complicated?
19:23:09 <siwica> I am still finishing my physics degree and consider to either going for a PhD (which will probably lead to a physics career) or going into Software Engineering. But I am mainly interested in functional programming and don't really want to spend my time writing Java or C++.
19:25:04 <ab9rf> siwica: do the physics. you won't have your job eliminated simply because of a trend shift.
19:30:43 <aarvar> siwica: or do programming since it's harder
19:31:58 <siwica> aarvar: programming is harder than physics?
19:32:26 <aarvar> well, that's what Dijkstra concluded at least
19:33:11 <siwica> aarvar: reference?
19:33:12 <siwica> :)
19:33:31 <aarvar> one sec
19:33:38 <ab9rf> physics experiments have a quantifiable metric for success :)
19:33:59 <aarvar> ab9rf: does mathematics?
19:34:08 <ab9rf> nah, there are no failures in mathematics
19:34:24 <ab9rf> instead, you get papers about mustard watches.
19:36:42 <siwica> And experiments are only half of physics
19:44:41 <dysfigured> fresh stack install, nothing haskell related installed anywhere, stack install ghc-mod seems to fail...
19:44:54 <Axman6> stack setup?
19:45:07 <dysfigured> already did that
19:45:25 <Axman6> "seems to fail" isn't very helpful...
19:46:36 <dysfigured> http://ix.io/1n9K
19:49:30 <aarvar> siwica: not sure if he ever wrote anything comparing programming and physics, but he gave up becoming a theoretical physicist to become one of the first programmers before programmers were even really a thing
19:49:45 <aarvar> and he did write about how programming is the hardest branch of mathematics
19:51:37 <aarvar> siwica: you might read https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html and https://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html
19:52:00 <aarvar> or maybe only the beginning of the former
19:52:46 <aarvar> (and the entirety of the latter)
19:52:53 <dysfigured> am i just using too new a version of ghc for ghc-mod?
19:54:12 <siwica> aarvar: I think he was devoting half of his time to theoretical physics and the other half  to programming for a whie and did not know which of the two to pursue further. I think he found both disciplines to be quite challenging.
19:55:33 <siwica> Ah, that's what it also says in the first essay
19:56:05 <aarvar> pretty sure he said he chose programming because he decided it was the greater challenge
19:56:12 <aarvar> though maybe not in that one
19:56:24 <boj> siwica: haskell jobs are pretty rare, and teams that want outright haskell experience tend to know exactly what they want. in my case, i'll take someone with practical development experience on big projects and train them up on haskell. so far it's worked out fine
19:56:24 <dukedave> Is there any reason for starting a line in a `do` block with `void $`, like this? https://github.com/LumiGuide/haskell-opencv/blob/master/opencv-extra/src/OpenCV/Extra/XFeatures2d.hs#L146
19:56:47 <geekosaur> dysfigured, yes
19:57:06 <siwica> aarvar: Although programming at his time was definitely completely different to what people do in industry nowadays
19:57:06 <boj> dukedave: usually when you want to drop the results and avoid a warning telling to you to do _ <- f instead
19:57:34 <dukedave> boj: ah, because warning, yeah I bet that's it, thanks
19:57:36 <dysfigured> boj: hire me plz lol
19:57:54 <geekosaur> and too new a Cabal library because some dependency probably needs the entire package database exposed during Setup (a somewhat dangerous proposition, which is why newer stack and Cabal both dislike it)
19:58:07 <aarvar> siwica: well, he was ahead of his time (as well as our current time) in that he emphasized e.g. the use of formal methods
19:58:21 <siwica> boj: But that must take up for a year for them to be productive I guess?
19:58:57 <dysfigured> fwiw (anecdotally) i just introduced somebody to haskell yesterday and they're already up and running doing programming challenges with it
19:58:59 <boj> siwica: depends on the person, but people are committing code in a couple weeks, and understanding stuff between 1-3 months
19:59:46 <aarvar> just take mathematicians and teach them haskell :)
20:00:31 <aarvar> make sure they dont know what a for loop is
20:00:34 <geekosaur> and then you get haskell programmer confused about needing to use fromIntegral, because its' all one big set to them >.>
20:00:59 <aarvar> geekosaur: I guess you have to teach them type theory first
20:01:15 <siwica> boj: Ok, I see!
20:01:33 <siwica> What would your expectations in terms of formal education be?
20:01:50 <boj> siwica: nil. i have a degree in art and japanese :D
20:02:04 <siwica> :D
20:03:01 <boj> if we were hiring a junior programmer someone with a CS degree would probably come out ahead, but people in the middle of their careers are judged based on their actual development experience (regardless of tools)
20:03:16 <aarvar> siwica: "In 1955 I took the decision not to become a theoretical physicist, but  to become a programmer instead. I took that decision because I had  concluded that of theoretical physics and programming, programming  embodied the greater intellectual challenge."
20:03:21 <aarvar> https://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1308.html
20:03:53 <siwica> I have been writing production code for a company for 3+ years (mostly Python) now, getting payed for doing Linux administration, but lack experience in larger projects. So I guess that's something I should work on in order to be considered employable?
20:04:42 <aarvar> ew, python. You may have already suffered too much brain damage
20:05:11 <boj> siwica: sounds like you have a good start at least. really depends on the company, what they are hiring for, and what they want
20:06:47 <boj> siwica: contributing to haskell open source will definitely give you a leg up
20:06:57 <siwica> boj: Just a bit intimidated as everyone writing Haskell seems to have a PhD at least :)
20:07:24 <aarvar> siwica: pretty sure most of them dont
20:08:00 <siwica> boj: Yeah, I should look for an interesting open source project 
20:08:05 * geekosaur has nothing beyond undergrad
20:08:31 <geekosaur> then again, I haven't done a whole lot beyond some contribs to xmonad, and some personal stuff
20:16:41 <dysfigured> google is failing me, how do i downgrade stack's ghc version so i can have a working ghc-mod again
20:17:26 <aarvar> dysfigured: pick a different resolver
20:17:28 <boj> dysfigured: i think you swap the lts version
20:20:47 <dysfigured> ah, so i change  ~/.stack/global-project/stack.yaml  ..and now i have to figure out which resolver version i need
20:21:32 <boj> peek at https://www.stackage.org
20:21:52 <aarvar> dysfigured: you can also do stack --resolver=whatever
20:21:54 <dysfigured> oh. i'm over here reading stack docs. and it's right ther in the front
20:21:55 <aarvar> I think
20:22:53 <dysfigured> if 8.4 is only a few days old, i'm happy to stick to roll back to 8.2 for a bit until ghc-mod catches up
20:23:38 <dysfigured> sorry, i started dabbling with haskell like a year ago and haven't touched it much sense, trying to dig back into it again
20:23:58 <dysfigured> also, typing is hard and my fingers are on autopilot or something
20:24:52 <aarvar> dysfigured: 8.4 is pretty old
20:25:21 <geekosaur> and yet not; ghc has a faster release schedule now
20:25:24 <aarvar> as in like half a year
20:25:39 <geekosaur> which does things dependent on its guts, like ghc-mod, no favors
20:26:20 <dysfigured> :| great, same problem again http://ix.io/1n9O
20:26:30 <aarvar> geekosaur: ghc-mod can just support every other version xd
20:31:05 <dysfigured> guess ill just roll back further
20:31:27 <mac10688> data QueryParams (sym :: Symbol) (a :: *)
20:31:35 <mac10688> Can someone help me make sense of this signature?
20:31:55 <mac10688> I've made Data and type before but now it looks alien
20:32:22 <dysfigured> although, really, i just like ghc-mod for editor integration, am i just trying to use old tools? should i be using something else?
20:35:51 <boj> dysfigured: take a look at ghcid
20:37:07 <byorgey> mac10688: I assume you would know what  data QueryParams sym a   means
20:37:15 <byorgey> mac10688: that adds kind signatures to sym and a
20:37:49 <mac10688> Symbol is a kind signature? a :: * could make sense
20:37:55 <mac10688> but sym :: Symbol?
20:38:14 <byorgey> yes, see http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-TypeLits.html
20:38:14 <geekosaur> Symbol is the kind of a type-level string
20:38:30 <mac10688> thank you
20:39:09 <geekosaur> which in the context of a query probably means a field name
20:39:23 <mac10688> yeah I think that's the case
20:41:23 <dysfigured> hm intero seems popular
20:50:47 <dysfigured> oh wow. and for good reason
20:50:53 <dysfigured> neovim package works great
21:00:22 <maerwald> creat, ghc 8.4.3 keeps panicing
21:00:49 <maerwald> then I have to remove everything with cabal new-clean before it works again
21:01:33 <maerwald> 8.2.2 did not have this
21:02:56 <dysfigured> maerwald: i thought most people migrated to stack these days?
21:03:11 <maerwald> stack doesn't use ghc?
21:03:58 <glguy> dysfigured: No, that's not the case
21:05:27 <dysfigured> ignore me i have no idea what i'm talking about
21:09:39 <jle`> mac10688: it might help to read it as the updated kind of types, data QueryParams (sym :: Symbol) (a :: Type)
21:10:18 <jle`> so it's clear that Type is not any special kind, and that not all kinds are based on *
21:11:32 <jle`> there are many kinds even in "normal" haskell that aren't *
21:11:48 <jle`> and in GHC haskell you can even define your own custom kinds
21:18:49 <mac10688> yeah i'm looking through the documentation on GHC.TypeLits. I just don't get it. Between these weird kindsignatures and Proxy
21:19:08 <mac10688> I get that servant is using Symbol to capture strings
21:19:15 <mac10688> but why not String or ByteString
21:19:50 <mac10688> data Summary (sym :: Symbol)
21:19:52 <mac10688> why not
21:20:03 <mac10688> data Description = Description String
21:20:26 <mac10688> woops
21:20:34 <mac10688> data Summary = Summary String
21:20:43 <mac10688> >>> type MyApi = Summary "Get book by ISBN." :> "books" :> Capture "isbn" Text :> Get '[JSON] Book
21:20:58 <mac10688> i mean it's the same thing. They both take string as an input
21:21:15 <mac10688> http://hackage.haskell.org/package/servant-0.14.1/docs/Servant-API.html#t:Summary
21:22:16 <jle`> mac10688: the point is that you are specifying your API by its type
21:22:35 <jle`> the `Description` type doesn't say anything about any strings that might be in it
21:22:56 <jle`> but `QueryParams "hello" Int`, the *type*, has "hello" directly in the type
21:23:43 <jle`> mac10688: there isn't much in the docs to GHC.TypeLits that is too relevant here, I think
21:24:07 <jle`> the only thing you need to know that `"Blablah"` is a valid type you can use in your type signatures
21:24:17 <jle`> and that it has kind Symbol
21:24:29 <jle`> just ilke, say, `Maybe` is a valid type you can use in your type signatures, and it has kind `Type -> Type`
21:25:09 <mac10688> are you familiar with c# or java for me to draw a connection and you validate it?
21:25:12 <mac10688> is it like generics?
21:25:23 <mac10688> like List<T> list = new List<T>()
21:25:32 <mac10688> where it's letting me specify the type
21:25:34 <jle`> the basic principle servant is following is "specify as much information about behavior in your types", and Symbol, the kind, is a way to be more expressive in your types
21:25:45 <jle`> mac10688: yes, sorta, except in jav generics, T must be a type of some value
21:25:50 <jle`> like Int, etc.
21:26:32 <jle`> if we're going from java, the analogy would be QueryParam<Sym,T>
21:26:45 <jle`> and you could "instantiate" it as QueryParam<"Blah",Integer>
21:27:06 <mac10688> ok interesting
21:27:13 <jle`> it's just a normal type parameter, like you see all the time in Haskell.  it's just that the type parameter is a string, instead of, say, Int or Bool
21:27:13 <mac10688> and that's what Proxy class is for too?
21:27:33 <jle`> i wouldn't say that Proxy (the type) is 'for' that
21:27:54 <jle`> not sure what 'that' means exactly either here
21:28:12 <mac10688> err, is that what Servant is using it for? Because I see Proxy everywhere too. It says Proxy is like const but at a different level
21:28:13 <mac10688> that being
21:28:31 <mac10688> a way to define the type in the api
21:28:39 <jle`> ah yeah, not quite, Proxy is mostly just there to help the type checker
21:28:42 <boj> Proxy is a nice way to ferry an unknown type along, but still be used sanely. at least that is how i understand it
21:29:51 <jle`> it's a type system hack to help the type inferencing algorithm infer your type variables
21:29:51 <mac10688> http://hackage.haskell.org/package/servant-0.14.1/docs/Servant-API.html#v:header
21:29:51 <jle`> otherwise it's impossible for type inference to infer some things
21:29:51 <jle`> mac10688: yeah, "ideally" the type of header will be `header :: ByteString`
21:30:01 <jle`> however, this trips up the type inference
21:30:32 <jle`> because which instance of FramingRender are you getting the header of?
21:30:37 <jle`> do you see how this would trip up ghc/type inference?
21:30:50 <jle`> let's say i wrote an instance of FramingRender Double Bool
21:31:04 <jle`> with a `header` for that speicifc instance
21:31:29 <jle`> what if i then used `header :: ByteString` in code?  how would GHC know which instance of FramingRender i wanted to get the header for?
21:33:28 <jle`> the Proxy is used there as an ignored dummy argument that allows the caller to give enough information to ghc for type inference to figure out which instance of FramingRender you want the header of
21:33:28 <mac10688> ok that actually makes sense
21:33:28 <mac10688> i read a blog post that touched on that idea the other day
21:33:28 <mac10688> about how the caller specifies the type
21:33:28 <mac10688> in haskell that is
21:33:28 <jle`> it should be noted that for the past year or two, we don't technically need to require dummy arguments like this anymore
21:33:28 <mac10688> oh?
21:33:28 <jle`> since GHC added a feature that lets users specify types directly, without hacks like Proxy
21:33:28 <boj> jle`: is that where you do like @Maybe ?
21:33:28 <jle`> yeah, you can directly "fill in" type variables with TypeApplications syntax
21:33:54 <MarcelineVQ> would that help for header? are strategy and a visible?
21:33:54 <jle`> the feature isn't perfect and there are some issues, but for the most part, new libraries have stopped using the Proxy hack
21:34:17 <jle`> yeah, the type of header becomes `header :: forall strategy a. FramingRender strategy a => ByteString`
21:34:43 <jle`> so you could call it with `header @Double @Bool` to get the header for the `FramingRender Double Bool` instance's header
21:35:17 <jle`> many new/fresh libraries that don't have to worry about backwards compatibility have switched to this.
21:35:33 <texasmynsted> not really sure where to ask this... but here goes. I have a cabal based project. Using emacs with haskell mode. Get error "Try installing a more recent version of haskell-stack-ghc"
21:35:49 <texasmynsted> not sure why stack is needed for a non-stack project.
21:36:29 <texasmynsted> I did a "cabal new-install stack" (I think that was the command)
21:36:31 <mac10688> thanks jle`. I'm going to digest this information now
21:36:36 <jle`> np :)
21:36:52 <texasmynsted> stack is the latest, 1.7.1 when I do stack --version 
21:39:15 <dysfigured> texasmynsted: not an answer to your question, but i just found intero which is some real fancy emacs tooling for haskell  https://commercialhaskell.github.io/intero/ 
21:39:30 <dysfigured> it is designed for stack tho
21:40:10 <texasmynsted> yeah.
21:40:24 <texasmynsted> I want to use cabal not stack where possible
21:41:02 <boj> intero is tightly coupled with stack i believe
21:41:12 <dysfigured> oh. why? is stack bad or something?
21:41:16 <boj> dante was an alternative, not sure if people still use it
21:42:21 <texasmynsted> I have tried both cabal and stack. I am back to cabal now, and want to stick with it
21:42:55 <texasmynsted> But now I can not get type inspection to work in emacs. SIgh
21:42:57 <MarcelineVQ> texasmynsted: https://github.com/flycheck/flycheck/issues/847 is suggesting the mere presence of stack can mess with things in this case
21:43:55 <dysfigured> interesting.. i started on cabal and then it seemed like the community was shifting to stack and so i've been using it for my occasional tinkering with haskell..
21:43:55 <MarcelineVQ> There's a pr related to it but it wasn't merged it looks like https://github.com/flycheck/flycheck/pull/857
21:55:08 <jackdk> I still use dante, because it can also handle projects that use nix for dependency management (specifically reflex stuff in my case, but nix is pretty neat in general)
21:55:29 <texasmynsted> dante?
21:55:48 <MarcelineVQ> https://github.com/jyp/dante
21:56:05 <aarvar> texasmynsted: do you have a stack.yaml?
21:56:34 <aarvar> or did the project ever have one? It might incorretly think it's a stack project then
21:57:00 <aarvar> or maybe you need to set the haskell process type or something
22:00:09 <texasmynsted> no stack.yaml
22:01:35 <texasmynsted> ever have one? Maybe, but I do not think so. How do I clean any trace of stack away?
22:02:07 <MarcelineVQ> in a project? you'd remove .stack-work/ and stack.yaml and project.yaml
22:02:23 <MarcelineVQ> *package.yaml
22:02:51 <MarcelineVQ> though that last one shouldn't matter, come to think of it
22:03:47 * texasmynsted shrug
22:03:52 <texasmynsted> those do not exist.
22:03:57 <texasmynsted> oh well thank you anyway
22:16:05 <texasmynsted> The work-around I found was to disable that check in flycheck, in emacs.
22:16:29 <texasmynsted> Heh, I guess I am using only cabal now 
22:37:44 --- mode: glguy set +v rc17
23:23:26 <f-a> I messed up my cabal folder because power outage. I always forget: if I want to axe all and start from new, which subfolders should I rm?
23:23:34 <f-a> and should I remove .ghc too?
23:25:21 <cocreature> f-a: removing .ghc is the important part usually
23:25:36 <cocreature> if you use new-build .cabal/store is important as well
23:25:47 <f-a> yeah, new build user
23:25:50 <cocreature> if you messed up things during a cabal update you might also need to remove other directories
23:27:02 <f-a> thanks cocreature 
23:34:50 <sm> how do you check the version of a dep used by cabal new-build, after it's finished ?
23:35:07 <sm> it's not just ghc-pkg list DEP I assume
23:35:29 <sclv> look at the plan.json
23:36:16 <sm> thx sclv
23:36:58 <mac10688> data (path :: k) :> (a :: *)
23:37:07 <mac10688> I understand that type a is constrained to type *
23:37:11 <mac10688> but what is type k?
23:37:22 <mac10688> path :: k
23:37:57 <mac10688> http://hackage.haskell.org/package/servant-0.14.1/docs/Servant-API-Sub.html#t::-62-
23:38:33 --- mode: glguy set +v allenleein
23:39:41 <cocreature> mac10688: it’s a kind variable
23:39:51 <cocreature> you can instantiate it to * but also to other kinds
23:39:59 <cocreature> like a type variable but for kinds
23:41:29 <mac10688> wow, ok I'll try to let that information settle
23:41:36 <mac10688> I might come back with more questions tomorrow
23:47:54 <bahamas> hello. where is `decodeFileWithWarnings` taken from in this file if the import hides it? https://github.com/sol/hpack/blob/master/src/Hpack/Yaml.hs
23:51:17 <cocreature> bahamas: looks like it’s coming from Data.Yaml.Include
23:51:30 <lortabac> hello, I am trying to write an type-equality function for a singleton, I am not sure how to proceed. The code is here: https://lpaste.net/2147947070676271104
23:51:55 <lortabac> naive recursion does not work, of course, because the types are not the same
23:52:57 <bahamas> cocreature: aha. that's why I couldn't find it in the repo itself. I thought maybe hpack redefined it somewhere
23:54:56 <cocreature> lortabac: pattern match on Refl and then construct a new Refl: https://gist.github.com/cocreature/55e1639512abda5cca8e3919d7827254
23:55:33 <lortabac> cocreature: ok, let me try
23:58:21 <lortabac> cocreature: it works, but I have no idea why :)
23:59:15 <lortabac> cocreature: I guess because we provide an equality proof each time we pattern-match
