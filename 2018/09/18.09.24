00:23:12 <dminuoso> What exactly is the point of Control.*
00:23:54 <dminuoso> cocreature: I have mixed feelings about your argument. The same could be said about any generalization or magic, but (.:) is something that may just be underused.
00:24:20 <dminuoso> The desire to compose a multi-arg function with another is not a rare thing.
00:24:38 <hc> > :t (.:)
00:24:40 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:24:52 <hc> What's the type of .: ?
00:26:15 <lavalike> :t (.) . (.)
00:26:16 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
00:27:36 <jackdk> :t fmap fmap fmap
00:27:38 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
00:28:03 <hc> what does it do?
00:28:32 <jackdk> composition. feed the eventual output of the second function into the first
00:28:47 <hc> oh ok :)
00:28:50 <cocreature> dminuoso: sure but I think if you introduce a new generalization it’s up to you to justify its necessity and for (.:) I have never heard a convincing argument
00:28:55 <hc> have you got a practical exaple?
00:29:03 <hc> where it's really useful, i mean
00:29:31 <cocreature> hc: it’s like (.) but for two arguments (f . g) x = f (g x) and (f .: g) x y = f (g x y)
00:29:48 <hc> ah, thanks!
00:30:52 <jackdk> the example from the scrollback, ICYMI, by ktonga > i have a function that takes exactly what i get from a servant routing but returns an IO so i only need to liftIO to Handler
00:30:57 <dminuoso> hc: A possibly simpler way to think about it is as `(fmap . fmap)`
00:31:10 <dminuoso> hc: If that confuses you it may be time to learn about the Functor instance of ((->) a) =)
00:31:11 <cocreature> how is that simpler …
00:31:57 <dminuoso> cocreature: If we take the container model and think of a function as a container indexed by its argument, then (a -> b -> c) is just a nested container.
00:32:46 <dminuoso> And to operate on the values of a nested container you could either `fmap (fmap g)`, or by applying (.) you'd rewrite it into `(fmap . fmap) g`
00:33:03 <dminuoso> (.) . (.) is harder to understand intuitively
00:33:06 <dminuoso> For me at least.
00:33:30 <cocreature> hm, that still seems objectively far more complicated than (f . : g) x y = f (g x y) which is something that you can pretty much understand after looking at a Haskell tutorial for 30 minutes
00:33:49 <dminuoso> cocreature: You misunderstand, not as *using* it
00:33:53 <dminuoso> But for defining (.:)
00:34:02 <dminuoso> To understand why (.:) works I mean
00:34:37 <cocreature> oh so you mean fmap . fmap is easier to understand than (.) . (.), not easier to understand than my definition?
00:34:54 <dminuoso> cocreature: Yes.
00:34:59 <cocreature> fair enough
00:35:13 <dminuoso> cocreature: Or possibly easier to understand your definition as well, but that goes into "its individual" territory
00:36:00 <juhp> haskell-cafe@googlegroups.com ???
00:36:10 <lavalike> good question
00:36:25 <dminuoso> cocreature: No actually I prefer the `fmap . fmap` model over (f . : g) x y = f (g x y)
00:36:28 <dminuoso> :P
00:37:35 <cocreature> dminuoso: your brain is just broken apparently :)
00:37:55 <dminuoso> cocreature: thank you :)
00:44:44 <dyl> dminuoso: [”semantic editor combinators” intensify]
00:44:51 <dyl> intensifies*?
00:45:21 <dyl> And what about
00:45:27 <dyl> > traverse . traverse 
00:45:29 <lambdabot>  error:
00:45:30 <lambdabot>      • No instance for (Typeable f0)
00:45:30 <lambdabot>          arising from a use of ‘show_M1379547422394553491598’
00:45:37 <dyl> :t traverse . traverse 
00:45:39 <lambdabot> (Traversable t2, Traversable t1, Applicative f) => (a -> f b) -> t1 (t2 a) -> f (t1 (t2 b))
00:45:42 <dyl> There we go.
00:45:59 <koz_> dyl: This reminds me of the first Edward talk I watched.
00:46:05 <koz_> (where he talked about lenses I think)
00:46:08 <dyl> Lenses and traversals?
00:46:10 <dyl> Yeah, me too haha
00:46:15 <dyl> That’s what I was alluding to.
00:46:25 <dyl> Great talk.
00:46:30 <dyl> NYC Haskell group I believe. 
00:46:37 <koz_> dyl: Edward is a very engaging speaker.
00:47:12 <dyl> Plus the formulation of lenses as things composable with (.) and the intuition of functions as functors as indexed containers really click nicely.
00:47:54 <phadej> :t foldMap . foldMap
00:47:56 <lambdabot> (Foldable t2, Foldable t1, Monoid m) => (a -> m) -> t1 (t2 a) -> m
00:47:56 <dyl> Edward Kmett: writes inscrutable yet useful Haskell libraries, but has the charisma and stage presence to actually explain them.
00:48:31 <dyl> :t mapM . mapM
00:48:32 <lambdabot> (Traversable t2, Traversable t1, Monad m) => (a -> m b) -> t1 (t2 a) -> m (t1 (t2 b))
01:24:26 <koz_> In a lot of places (including here: https://stackoverflow.com/questions/31317036/are-these-premises-about-folds-and-recursion-right), I see claims like 'in general, foldr is equivalent to recursion'. Is there some source proving this?
01:34:30 <dminuoso> dyl: The semantic editor combinator topic was really amazing. :)
01:35:04 <scriptdevil> koz_: Not all recursive procedures AFAIK - but a fairly common subclass  - A Tutorial on the universality and expressiveness of folds: http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
01:35:05 <koz_> dyl: As Edward himself put it: "I spend a lot of time reifying category theory into Haskell libraries."
01:35:20 <koz_> scriptdevil: Thank you - that's beautiful.
01:35:56 <dminuoso> koz_: http://ertes.eu/tutorial/foldr.html is one tutorial that explores the "foldr is like maybe but with recursion" topic
01:36:06 <dminuoso> Really lovely that his website is still up.
01:36:23 <koz_> dminuoso: Wait, ertes... is that who I think it is?
01:36:40 <dminuoso> koz_: I can only answer that question if I knew what you are thinking.
01:37:00 <koz_> dminuoso: https://blog.jle.im/entry/in-memory-of-ertugrul-soylemez.html
01:37:11 <dminuoso> koz_: That's the one.
01:37:15 <koz_> Woah.
01:37:23 <yushyin> :(
01:37:27 <jle`> :(
01:37:30 <koz_> lift blow (mind koz_)
01:37:34 <koz_> ^
01:37:59 <koz_> The significance of that post, and many others like it, _just_ clicked for me.
01:38:19 <dminuoso> koz_: Which post do you mean?
01:38:27 <koz_> dminuoso: The one I just linked from jle` 's blog.
01:58:05 <bahamas> anyone using the dramforever.vscode-ghc-simple VS Code extension. I have an issue with it: if I add an import Data.Aeson for example and I don't have `aeson` listed as a dependency, the import is underlined with red. the problem is that the underline doesn't disappear after I add aeson to dependencies.
01:58:45 <bahamas> I see in this issue that the extension doesn't detect changes to the cabal file https://github.com/dramforever/vscode-ghc-simple/issues/7. is this the cause of the issue that I'm seeing?
02:03:06 <cocreature> bahamas: yeah that sounds like that’s probably it. have you tried restarting it as recommended in the same issue?
02:03:58 <bahamas> cocreature: now I don't get the error, but next time I see I'll try
02:17:28 <bahamas> I'm trying to parse a yaml file and change something in it. someone recommend lens-aeson, so I'm using this as an example, but when I print I only see an empty list
02:17:31 <bahamas> https://lpaste.net/863511485622517760
02:18:54 <bahamas> I realize that the yaml file has a different structure, so I changed `print $ bs.^..values` to `print $ bs.^.._Object` (I don't know if that makes sense, tbh)
02:20:06 <cocreature> bahamas: an empty list is what you get when your traversal doesn’t target anything so presumably your query doesn’t match the structure of the yaml file
02:20:25 <cocreature> if you show us the yaml file you’re using (or ideally a simplified version) it might be easier to say what the right traversal would be
02:21:10 <bahamas> cocreature: it's the hpack format and I want to extract the dependencies
02:21:43 <cocreature> bahamas: your code appears to be reading a file called colors.json and lookup a key called "color" so that definitely does not match the hpack format
02:22:00 <bahamas> cocreature: yes, sorry. I'll paste my actual code
02:22:18 <bahamas> https://lpaste.net/6401088038117572608
02:28:35 <cocreature> bahamas: lens-aeson tries to decode your bytestring as json not yaml. you first need to decode the yaml to an aeson Value and then you can apply lens-aeson to that. here’s an example https://gist.github.com/f222aff12c583269f1f810e4b681da14
02:35:41 <bahamas> cocreature: I'm running out of battery, so I'll check later. thank you!
02:41:04 <sheyll> hi, why does a Control.Lens.Fold need the Contravarient constraint?
02:42:51 <Taneb> sheyll: it prevents you from being able to change the "a" and hence the "s" (because the Identity functor is not contravariant")
02:44:04 <sheyll> ahhhhhhhh    omg this makes sense thanks a bunch
02:44:41 <sheyll> so i cnnot do anything with it
02:45:24 <Taneb> You can think of the f in a Fold as being something like "Const e" for some Monoid e
02:45:40 <sheyll> yup, I think I get it
02:45:53 <Taneb> So it's kind of like Monoid e => (a -> e) -> s -> e
02:46:24 <sheyll> funny trick
02:46:27 <Taneb> (I think it's provable that any Contravariant Applicative is equivalent to Const e for some monoid e, but I'm not sure)
02:48:06 <Taneb> sheyll: best thing is, it's a funny trick that a) we can express a Fold in the same shape as a Lens or a Prism, and use Lenses and Prisms as Folds, and b) GHC can optimize it away entirely
02:48:44 <sheyll> uhm ... really!? great
02:49:13 <Taneb> > (1, 2) ^.. _2
02:49:15 <lambdabot>  [2]
02:49:23 <Taneb> > Just "hello" ^.. _Just
02:49:25 <lambdabot>  ["hello"]
02:51:35 <Taneb> And at the use case of (^..), the Fold is completely monomorphic as "Getting (Endo [a]) s a" which is coercible to "(a -> [a] -> [a]) -> s -> [a] -> [a]" which GHC knows how to handle
02:53:35 <sheyll> > (Node "this is "  [Node "nice" [], Node "great" []]) ^.. root
02:53:37 <lambdabot>  ["this is "]
02:53:54 <sheyll> > (Node "this is "  [Node "nice" [], Node "great" []]) ^.. branches
02:53:56 <lambdabot>  [[Node {rootLabel = "nice", subForest = []},Node {rootLabel = "great", subFo...
02:54:08 <sheyll> > (Node "this is "  [Node "nice" [], Node "great" []]) ^.. branches .root
02:54:10 <lambdabot>  error:
02:54:11 <lambdabot>      • Couldn't match type ‘Tree a’ with ‘[Tree [Char]]’
02:54:11 <lambdabot>        Expected type: (a -> Const (Endo [a]) a)
02:54:27 <sheyll> > (Node "this is "  [Node "nice" [], Node "great" []]) ^.. branches .folded.root
02:54:29 <lambdabot>  ["nice","great"]
02:54:47 <sheyll> ok sorry
02:56:52 <Taneb> > (Node "this is "  [Node "nice" [], Node "great" []]) ^.. cosmos.root
02:56:54 <lambdabot>  ["this is ","nice","great"]
02:57:02 <Taneb> And because String is a Monoid...
02:57:09 <Taneb> > (Node "this is "  [Node "nice" [], Node "great" []]) ^. cosmos.root
02:57:11 <lambdabot>  "this is nicegreat"
02:57:18 <lavalike> :t (^..)
02:57:19 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
02:57:58 <lavalike> "cosmos"
02:58:08 <Taneb> http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Plated.html#v:cosmos
02:58:42 <lavalike> if you say so
03:05:18 <maerwald> stack currently doesn't cache builds per optimization level or profiling right?
03:07:01 <dminuoso> What is the advantage of `newtype`ing a monad transformer stack with GeneralizedNewtypeDeriving all the instances back over just using a type alias?
03:08:15 <tdammers> it's still a separate type, and you can still only operate on it via those instances, but not via direct access to the internals
03:08:22 <tdammers> unless you expose the constructor, that is
03:08:38 <dminuoso> tdammers: Well the constructor is exposed.
03:08:52 <tdammers> hmm, then you're not really winning much
03:08:55 <dminuoso> tdammers: Specifically Im wondering about the Handler monad of servant-server
03:10:04 <tdammers> could be just one of those cases where you follow a general rule-of-thumb; not because it's the best solution for the situation at hand, but just because it is sometimes the better approach, and won't hurt otherwise, and keeping to a consistent style makes it easier to work with the code in general
03:10:50 <Taneb> You can get cleaner type errors in some cases
03:11:21 <dminuoso> Taneb: Ah I suppose that's one advantage indeed.
03:11:42 <dminuoso> This is funny: Can't make a derived instance of ‘Generic (Freyja a)’ (even with cunning GeneralizedNewtypeDeriving):
03:11:53 <dminuoso> =)
03:13:58 <sheyll> @Taneb thanks for pointing out cosmos
03:13:58 <lambdabot> Unknown command, try @list
03:14:32 <Taneb> sheyll: Control.Lens.Plate has a whole bunch of cool combinators for homogenously recursive datatypes
03:15:09 <sheyll> yeah I just saw universe :)
03:19:16 <c50a326> god damn it I can't do it :( this bloody drawTree bollocks from this bloody paper http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf
03:20:06 <c50a326> how the f are you supposed to be able to like branch off into char the '|' char... I mean you want to draw the damned tree like @---5 where @ is a root (I'm just considering for BinTree at the moment) and 5 is the leaf
03:20:40 <c50a326> so I've implemented labTree for it like so https://ptpb.pw/GcSl/hs
03:21:14 <c50a326> but with the drawTree thing, it seems to me like you need to know how far into the tree you are
03:21:28 <c50a326> we have a paths function, a bfs function, a dfs function
03:22:01 <c50a326> I've looked at the outputs of those against some whatever data with `mapM_ (putStrLn . show) (paths myBinTree) or whatever...
03:23:53 <c50a326> oh wait maybe this combine function might be useful
03:25:25 <c50a326> oh no that's basically just zipWith isn't it
03:26:46 <c50a326> oh I think I have an idea... maybe I can use the paths function and work only with the last path and the current path
03:28:33 <safinaskar> if i type https://www.haskell.org/hoogle/?hoogle=liftcallcc , i see that there is a lot of functions liftCallCC in different modules
03:28:37 <safinaskar> what this means?
03:28:52 <safinaskar> we have C++-style function overloading?!
03:29:18 <dminuoso> safinaskar: No.
03:29:25 <dminuoso> safinaskar: Just separate definitions in different modules.
03:29:51 <safinaskar> dminuoso: so, this is simply different functions?
03:29:54 <cocreature> yes
03:30:23 <cocreature> if you import multiple definitions of the same name you will get an error and need to resolve it, e.g., by using qualified imports
03:31:21 <cocreature> we do have actual overloading in the form of typeclasses
03:31:31 <sheyll> :)
03:31:55 <dminuoso> safinaskar: In a way you could think of this as "manual namespace based overloading" because all those liftCallCC appear to have the intention of being specialized implementations.
03:32:12 <dminuoso> But that would only apply to this particular function in this particular library.
03:33:12 <safinaskar> i think this is wrong design. we should have one liftCallCC function for all transformers. it should have type "(MonadTrans t) => ..."
03:34:06 <safinaskar> do you agree?
03:35:04 <jle`> safinaskar: is that possible to implement?
03:35:44 <cocreature> safinaskar: how would you express CallCC m (Maybe a) (Maybe b) -> CallCC (MaybeT m) a b in terms of MonadTrans?
03:36:16 <jle`> safinaskar: remember that if you are defining a function to work polymorphically over all MonadTrans t, then the only function you are allowed to use is 'lift'
03:36:20 <sheyll> similar types of values, are calles "similar" because you can do the same stuff with them  (math operations for example). So haskell allows the programmer to define "classes" of  things that only the define the functions they share
03:36:49 <dminuoso> Im sure its expressible if you just enable -XAllTheTypeExtensions, sprinkle some singletons over it and turn every typo into a diagnostic that requires 3 PhDs just to understand.
03:37:15 <sheyll> omg ICE train Wifi sucks
03:37:49 <cocreature> dminuoso: I doubt that. there is nothing in the type system that relates Maybe and MaybeT so generalizing this isn’t really possible
03:38:09 <sheyll> I bet there is a lens for that
03:39:18 <dminuoso> cocreature: Is it possible to establish a connection between Maybe and MaybeT in CT?
03:39:24 <dminuoso> Surely there is a relationship.
03:40:11 <cocreature> sure my point is none of the reasonably common abstractions that we have in Haskell captures this relationship so without making up your own you are not going to get anywhere
03:40:53 <cocreature> for monads where the non-transformer version is just the transformer specialized to Identity mmorph often helps capturing this relationshpi
03:41:25 --- mode: glguy set +v ii-safinaskar
03:41:57 <ii-safinaskar> hi
03:42:22 <liste> hi ii-safinaskar 
03:43:36 <safinaskar> so, i propose add "liftCallCC" into definition of class MonadTrans
03:43:48 <safinaskar> will this work?
03:44:02 <dminuoso> 12:35      cocreature | safinaskar: how would you express CallCC m (Maybe a) (Maybe b) -> CallCC (MaybeT m) a b in terms of MonadTrans?
03:45:04 <cocreature> even if you ignore that I would expect liftCallCC to require something like MonadTransControl
03:45:16 <cocreature> probably there is a version of liftCallCC in terms of MonadTransControl somewhere
03:46:13 <cocreature> there is https://hackage.haskell.org/package/transformers-lift-0.2.0.1/docs/Control-Monad-Trans-Lift-CallCC.html which appears to be close to what I had in mind
03:46:14 <dminuoso> Mmm, is there a way to search hoogle for things with a `MonadTransControl t` contraint in it?
03:46:31 <cocreature> but tbh I don’t think I’ve ever used liftCallCC so I might be wrong here :)
03:47:02 <dminuoso> cocreature: The *Control packages are somewhat scary. :(
03:47:13 <dminuoso> That is MonadBaseControl and MonadTransControl are really weird to read.
03:48:11 <cocreature> they’re not only weird to read they also have at least somewhat questionable semantics
03:48:53 <cocreature> which is why packages like unliftio that attempt to solve a similar problem explicitely forbid certain instances
03:49:23 <dminuoso> cocreature: isnt MonadUnliftIO limited to only ReaderT in effect?
03:49:31 <merijn> dminuoso: Basically, yes
03:49:40 <cocreature> right
03:49:44 <merijn> Or at least, things isomorphic to it
03:50:25 <merijn> As a result it's a lot easier to understand and use
03:50:53 <dminuoso> Doesn't that mean that unliftio is not very useful for non-trivial transformer stacks? Or what I missing here.
03:51:13 <merijn> Yes, no, maybe
03:51:44 <merijn> I find it very useful with things like LoggingT from MonadLogger
03:52:37 <dminuoso> merijn: Is LoggingT just a glorified `ReaderT Logger`?
03:52:46 <cocreature> dminuoso: you’re missing that the people that like unliftio also tend to be in the “non-reader-like transformer stacks on top of IO are often a bad idea”-camp :)
03:52:46 <merijn> dminuoso: Yes
03:53:14 <merijn> dminuoso: ResourceT and LoggingT are both basically just ReaderT in disguise
03:54:21 <ii-safinaskar> dminuoso: cocreature: here is how i would declare "liftCallCC": http://paste.debian.net/hidden/b1163053/
03:55:49 <cocreature> ii-safinaskar: so now you can write a type signature but can you write an implementation in terms of only the other functions provided by MonadTrans? if not, why put it into MonadTrans instead of a separate subclass?
03:56:17 <dminuoso> cocreature: Those people - do they prefer to work in named IO then? I guess you lose out on some of the cooler patterns (unless you are willing to abuse exceptions heavily).
03:56:26 <dminuoso> *naked IO!
03:56:49 <dminuoso> At least MaybeT has proven to be quite interesting for its MonadPlus instance for me a few times.
03:58:57 <cocreature> dminuoso: I think the argument is often oversimplified. MaybeT or ExceptT in isolated parts of your code is totally fine. however, in that case you usually also don’t need monad-control. what (according to some people and I do at least sympathize with those arguments) should be avoided is to have some “App” monad that mixes StateT/ExceptT/… and put everything in that
03:59:55 <dminuoso> cocreature: Mmm, so you would add a layer to your stack locally for the MaybeT/MonadPlus effect, and peel it off right afterwards?
04:00:04 <cocreature> yep
04:05:25 <cocreature> dminuoso: ofc it probably makes more sense to see this as a guideline than a hard rule but the existence of monad-control and the confusion and problems caused by it already provide a fairly strong argument for this style :)
04:06:04 <merijn> The most damning argument against monad-control is that the main people involved with it are now the ones pushing unliftio :p
04:06:15 <safinaskar> thanks everybody
04:06:47 <cocreature> merijn: is that true? I thought monad-control was mostly bas’ project and I don’t think he’s working on unliftio
04:08:45 <merijn> cocreature: Well, the only times I've encounted monad-control and co in the Real World was using snoyberg libs, but he's ripped it out of almost all of them
04:09:31 <cocreature> ah yeah he was definitely a heavy user
04:10:16 <merijn> Also, unlike monad-control unliftio-core is super lightweight int erms of dependencies, which is nice
04:13:54 <merijn> Anyone know if the 8.6.1 user guide is online somewhere?
04:16:00 <phadej> merijn: https://downloads.haskell.org/~ghc/8.6.1/docs/html/users_guide/
04:16:44 <phadej> looks like 8.6.1, but not complete
04:17:24 <Jante> Is there a way to use RankN types in a signature to allow      foo f = (f 7, f True)    to be a valid function? For example I could pass in    g x = (x, x)  and we know that this program is correct. Can I tell GHC somehow?
04:18:00 <merijn> Jante: That should work fine with RankN types?
04:18:38 <Jante> merijn: I wonder if it does and if yes what the type signature would look like.
04:19:24 <merijn> "foo :: (forall a . a -> Foo) -> (Foo, Foo)"
04:20:50 <Jante> merijn: yes, when I declare my own type then it would easily work.
04:24:33 <ScriptRunner> Hi, everyone what is the best way of making a string title case using list comprehension?
04:24:36 <phadej> forall (a. a -> r) -> (r, r) -- works equally well
04:25:18 <ScriptRunner> I can make the whole thing lower case, but I'm stuck how to make the first character upper case.
04:25:41 <merijn> ScriptRunner: Pattern match and replace the first element?
04:26:33 <cocreature> phadej: that won’t let you allow to pass in g x = (x, x) would it?
04:26:44 <deltasquared> phadej: you just reminded me I really need to get my head around forall notation
04:27:03 <ScriptRunner> merijn: How would I go about pattern matching it. Using mod?
04:27:10 <cocreature> you need something like (forall a. a -> f a) -> (f Int, f Bool) for that and then newtype (a, a)
04:27:45 <ScriptRunner> cocreature: Was that for me?
04:27:56 <cocreature> no for phadej/Jante
04:28:02 <merijn> deltasquared: It's not all that magical, tbh. It literally means "forall types a". In "normal" Haskell notation it's just implicit
04:28:05 <merijn> :t Nothing
04:28:06 <lambdabot> Maybe a
04:28:08 <ScriptRunner> Okay, no worries
04:28:36 <cocreature> > (unwords . map (\s -> case s of [] -> []; (c : cs) -> toUpper c : cs) . words) "hello world"
04:28:39 <lambdabot>  "Hello World"
04:28:39 <merijn> deltasquared: GHC implicitly treats "Maybe a" as "forall a . Maybe a" meaning "for all types 'a' that you can think of, this type has type 'Maybe a'"
04:28:43 <phadej> cocreature: that would need higher order unification, i.e. foo :: (forall a. a -> f a) -> (f Int, f Bool)
04:28:43 <cocreature> ^ how about that ScriptRunner 
04:28:46 <deltasquared> merijn: hmm, I recall being thrown with the magic type signature that runST uses to ensure you can't leak out it's "interior mutability"
04:29:09 <deltasquared> :t runST
04:29:10 <lambdabot> (forall s. ST s a) -> a
04:29:14 <phadej> to unify `f` with `\(b :: Type) -> (b, b)`
04:29:19 <merijn> deltasquared: Well, that trick relies on Rank2 types, which is basically "forall in places other than the left most part of the type"
04:29:32 <cocreature> phadej: right, that’s why I added “newtype (a, a)”
04:29:48 <cocreature> e.g. newtype V2 a = V2 (a, a)
04:30:02 <cocreature> (or just make a separate type if you don’t need tuples for something else)
04:30:02 <merijn> deltasquared: I have an example that might clarify when/why you might need Rank2 types: https://gist.github.com/merijn/77e3fa9757658e59b01d
04:30:31 <deltasquared> mfw accidentally copy-pastes my password into google because that was what was on my clipboard, including a newline char >_>
04:30:46 <deltasquared> damnit why does there have to be selection and clipboard separate in X11
04:30:46 <merijn> deltasquared: forall is (basically) about "who get's to decide what a type variable ends up being?", i.e. the *caller* or the *function being called*
04:31:13 <deltasquared> merijn: so it's to do with deduction rules?
04:31:17 <merijn> deltasquared: My gist showing one of the simplest examples when that might matter
04:31:40 <merijn> deltasquared: As in, the function "mangle" has to decide what the type will be, because only the function mangle actually knows
04:32:25 <merijn> deltasquared: The "forall a . Num a => a -> a -> a" boils down to "if you give me a function AND promise that it will work for *any* type that happens to be a Num instance, then this will work"
04:32:54 <deltasquared> merijn: right, so it's basically allowing polymorphic calls internally in a way?
04:33:07 <merijn> deltasquared: Not "in a way", that's literally what it is :)
04:33:10 <deltasquared> without it being selected "externally" I guess
04:33:16 <deltasquared> ok, that sort of figures...
04:33:25 <deltasquared> I need to turn that over in my head a few times
04:33:36 <merijn> deltasquared: Normally the caller gets to fill in "a -> a" well, I will give you "Int -> Int", deal with it
04:33:39 <deltasquared> like so much in haskell, a lot of information in not a lot of text, heh
04:34:01 <merijn> forall lets you say "You can *only* pass me functions working for *all* types, and I will pick which one!"
04:34:28 <deltasquared> beat that, object oriented languages
04:34:28 <merijn> Which is normally not very useful, since not a lot of functions work on everything. But when combined with typeclass constraints (like in the gist) you can make it more useful
04:35:43 <merijn> deltasquared: runST then in turn abuse this trick by requiring the input "ST s a" to work for ALL possible values 's', but, because *internally* things will work for one specific 's' you can't leak details in a way that breaks things
04:36:13 <merijn> deltasquared: The "Lazy Functional State Threads" paper explains the entire trick in quite some detail and is a pretty accessible read
04:36:51 <deltasquared> I can't remember if I saved that paper or not when I came across the link last time, gib sec
04:37:33 <deltasquared> it appears not, on account of my downloads folder is full of random crap right now
04:37:45 <deltasquared> just "oh, that looks cool", saves it, then don't get around to it >_>
04:37:57 <merijn> Story of my life ;)
04:39:01 <deltasquared> might as well try and get my head around refine's Predicates while I'm at it. oh boy, monad transformers.
04:39:06 <deltasquared> :t RefineT
04:39:07 <lambdabot> error: Data constructor not in scope: RefineT
04:39:11 <deltasquared> ... hmm, what was that again
04:39:58 <deltasquared> no, it was RefineT... can I get the bot to import
04:40:17 <deltasquared> just for discussion really, I have cabal unpack'd source here anyways
04:41:02 <merijn> deltasquared: The trick boils down to: Every mutable operation in ST returns a value whose type has 's' inside it. runST requires actions that work for *all* 's', but internally uses a specific one. So any details of the mutation (e.g. STRef) that you happen to leak out of runST will have 's' fixed to a specific one, and thus aren't legal inputs for runST (since they no longer work for *all* 's', just a 
04:41:08 <merijn> single one)
04:42:39 <deltasquared> merijn: right, so all the things you'd use to produce ST monad actions (writeSTRef I guess for instance) must be able to adapt to that internal parameter in turn I would take
04:42:42 <deltasquared> :t writeSTRef
04:42:44 <lambdabot> STRef s a -> a -> ST s ()
04:42:54 <merijn> deltasquared: Yes
04:43:21 <merijn> deltasquared: Technically you can even pass in STRef's from another transaction, you can just never read them
04:43:45 <deltasquared> right, because the returned monad action wouldn't work with >>= and such
04:43:46 <merijn> Because writeSTRef/readSTRef would break the result's 's' polymorphism
04:57:00 <ScriptRunner> Hi guys, from my previous question when would guards be used over a pattern? Thanks 
04:58:08 <cocreature> ScriptRunner: you probably have to remind us of your previous question :)
04:58:24 <liste> ScriptRunner: when you want to match based on some boolean condition, not a constructor
04:59:05 <liste> eg "odd x | x % 2 == 0 = False | x % 2 == 1 = True"
04:59:22 <ScriptRunner> cocreature: it was trying to make only the first letter of a sting upper case and the rest lower case using list comprehension. 
05:01:13 <cocreature> ScriptRunner: have you seen the solution I posted?
05:03:25 <deltasquared> :t unless
05:03:26 <lambdabot> Applicative f => Bool -> f () -> f ()
05:03:49 <deltasquared> brb, looking up docs.
05:05:53 <deltasquared> bah, nix's ghc doesn't come with docs for base... now where have those gone
05:08:30 <dminuoso> cocreature: Yeah. For me it's not viable because I really do need that MaybeT on the outermost layer.
05:08:33 <cocreature> deltasquared: there are your docs https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:unless
05:08:55 <cocreature> dminuoso: everywhere? that seems somewhat unlikely
05:09:11 <dminuoso> cocreature: Im writing a server combinator framework where a handler might at any point decide that it doesn't feel responsible, so it will produce `skipHandler = mzero` and then the next handler will be tested until one is found that feels responsible.
05:09:42 <dminuoso> cocreature: So at the outermost layer I have some `handler = msum handlers`
05:10:00 <deltasquared> cocreature: no worries, I found it, just used hoogle
05:10:17 <deltasquared> brb later, doing some car stuff
05:10:39 <dminuoso> cocreature: It's some domain specific stuff, we kind of need this "late opt-out" for handlers... I mean we could use exceptions for this - but that feels much worse.
05:11:26 <cocreature> not sure exceptions are necessarily worse
05:12:03 <cocreature> or if you don’t need the MaybeT behavior within a handler you could have the handlers return IO (Maybe …) and then wrap that in MaybeT to call asum
05:13:19 <dminuoso> cocreature: so `handler = (asum . fmap MaybeT) handlers` ?
05:13:34 <dminuoso> Or rather... `handler = (runMaybeT . asum . fmapMaybeT) handlers`
05:13:57 <dminuoso> I suppose that might work... mmm
05:15:26 <tsaka__> Say your inside a "State (A, B, C) ()" monad. You can drop down into the component of the state using lenses, e.g. "zoom _1" which drops you down into the "State A" monad. How can you drop down into the "State (A, B)" monad?
05:15:58 <tsaka__> That is, zoom in on multiple parts at once
05:16:17 <cocreature> tsaka__: write a Lens (a, b, c) (d, e, c) (a, b) (d, e) and use that with "zoom"
05:16:41 <tsaka__> man these types
05:16:49 <dminuoso> cocreature: I mean there's some up and downsides for this.
05:17:17 <dminuoso> Right now I was glad to had some `Realm :: String -> Magick String` combinator that would automatically skip the handler if the Realm didn't match.
05:17:28 <dminuoso> *realm :: String -> Magick String
05:17:34 <tsaka__> cocreature: I tried "alongside _1 _2" But without luck, is there a way for combining lenses in this way, not sequentially but in parallel?
05:18:03 <dminuoso> If I didn't have a global MaybeT inside my Magick stack, then the only way to make it just work would be by using exceptions
05:18:08 <dminuoso> At least the way I can see
05:18:41 <dminuoso> `throwIO skipHandler` feels just wrong :(
05:18:44 <cocreature> tsaka__: there is something in Control.Lens.Unsound (although I’m not sure that has been released) but as the module name suggests that’s somewhat dubious (the problematic case is if the lenses overlap). I would just write the lens yourself
05:19:28 <dminuoso> Although Ive come at a point where Im convinced anymore that exceptions are bad for control flow. I mean at the very core they *are* control flow.
05:20:02 <cocreature> you can certainly make good arguments for using exceptions here: they are faster and they don’t require messing with monad-control
05:20:40 <cocreature> the obvious downside is that you don’t see the early exit in the type signature. but your handler can throw exceptions either way, do you really want to handle exceptions differently from returning Nothing?
05:21:32 <dminuoso> cocreature: Well you dont see the early exit in the type signature anyway if you use a type alias/newtype for the transformer stack.
05:21:50 <dminuoso> You'd have to go to the definition site, and whether its baked into the type of just in the haddock documentation seems of little consequence
05:21:52 <Ariakenom> why would you try the next handler for another exception?
05:21:58 <MasseR> Is it bad form to advertise job openings in here?
05:22:11 <mnoonan> tsaka__: what happened with `alongside _1 _2`?
05:22:19 <cocreature> MasseR: I don’t think so, you might also want to try haskell-cafe and /r/haskell
05:23:17 <MasseR> Our company Relex Oy is searching for a couple of haskellers to work on an internal deployment application: https://relex.recruiterbox.com/jobs/fk01gjr/
05:23:19 <mnoonan> oh wait, I see, the resulting type isn't what you want at all
05:23:34 <dminuoso> cocreature: I mean it's a bit funny because in reality I have something closer to `IO (Maybe (Maybe Answer))` in my stack
05:23:46 <dminuoso> Where the outer Maybe is for the asum instance, and the inner is for disregarding a packet..
05:24:07 <dminuoso> Although... maybe Im appraoching this all wrong.
05:24:28 <mnoonan> tsaka__: this is probably relevant: https://stackoverflow.com/questions/36521208/how-to-make-the-product-of-two-lenses
05:24:31 <dminuoso> PErhaps it makes more sense to have some `data Response = Skip | Discard | Respond Packet` and then have a simple loop that goes through handlers..
05:24:51 <tsaka__> mnoonan: https://lpaste.net/5618955857652875264
05:24:51 <dminuoso> At any rate, I really like my implicit early exit :P
05:31:26 <tsaka__> @mnoonan It compiles with the 'fakeIt' lens from that post
05:31:27 <lambdabot> Unknown command, try @list
05:52:46 <julianleviston> that “do be do be do” paper is really great https://arxiv.org/abs/1611.09259
05:57:08 <juhp> julianleviston: thanks looks very interesting
05:57:40 <julianleviston> conor mcbride is so great
05:58:20 <juhp> yeah
06:01:41 <cppxor2arr> should i use *> instead of >>, traverse_ instead of mapM_, etc.?
06:01:54 <cppxor2arr> Applicative over Monad?
06:03:20 <olligobber> cppxor2arr, applicative is more general, so if you want your code to be more generalised use applicative
06:03:42 <cppxor2arr> ok ^_^ applicative it is
06:03:45 <cocreature> cppxor2arr: if you are working with a concrete instance it doesn’t really matter in almost all cases. if you are polymorphic in the monad/applicative then I would go for the more general version
06:04:19 <deltasquared> cocreature: there is the thought that having code be general if possible can yield interesting combinations later when you swap out the instance
06:04:26 <deltasquared> or it could just not be useful, but hey
06:06:11 <cocreature> deltasquared: swapping out a Monad for something that’s only an Applicative is just so rare ime that I don’t think it’s worth optimizing for that
06:06:52 <bahamas> cocreature: what you gave me earlier works. thank you!
06:06:55 <dminuoso> Doesn't making things more generic decrease optimization chances?
06:07:07 <dminuoso> Or is that only about concrete vs typeclass overloaded?
06:07:22 <deltasquared> if in doubt, pragma specialise I guess
06:11:56 <csaurus> I have a ghci question, is there any way to close open files? I'm doing debugging on my main action, but sometimes I Ctrl-C to kill it. I'd like to be able to set some breakpoints and start it again
06:12:16 <csaurus> but can't due to files being locked or sockets still being bound, these are confirmed with lsof
06:12:46 <cocreature> csaurus: that sounds like you should be using "bracket" or "withFile" to deal with files instead of separate calls to open and close a file
06:12:56 <deltasquared> :t bracket
06:12:57 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:13:23 <deltasquared> brb docs again
06:13:40 <cocreature> ctrl-c raises an exception so if you use bracket files will be closed properly
06:13:44 <csaurus> ah ok, I'll look into that. It's a servant application 
06:13:54 <cocreature> and really all resource handling should be done in an exception safe way
06:13:54 <csaurus> that's good to know! thanks!
06:14:03 <tommd> Curiously, does `System.Mem.performGC` do the trick?
06:14:09 <dminuoso> oo
06:14:17 <tommd> Not to say better cleanup on exceptions isn't preferred.
06:14:50 <csaurus> I understand, the true solution is better resource management but I'll see if performGC does it
06:15:08 <deltasquared> that's interesting, bracket (hOpen ...) hClose (\x -> ...) reminds me a lot of go's deferral mechanism
06:15:20 <dminuoso> servant with bracket is fun.
06:15:28 <deltasquared> as in, f = open(...); defer f.close()
06:16:12 <deltasquared> once again, the fact that all of this stuff is library functions is one thing that just amazes me with haskell
06:17:27 <cocreature> deltasquared: tbf the exception system is not just a library feature.
06:17:28 <dminuoso> deltasquared: Haskell has next to no builtin features or keywords.
06:17:50 <c50a326> how are you supposed to know the kind of "x and y" to write a tree-drawing function using recursion?
06:17:55 <dminuoso> deltasquared: Even the semicolon that other languages have is abstracted away in a function in Haskell - making it more powerful and programmable. :)
06:18:07 <dminuoso> deltasquared: Like the semicolon in go.
06:18:23 <deltasquared> dminuoso: desugars to >> or >>= from do notation IIRC
06:18:29 <dminuoso> deltasquared: Yup exactly.
06:18:39 <deltasquared> (depending on if the value of an action gets used)
06:18:53 <cocreature> c50a326: can you be a bit more precise? I have no idea what you mean by x and y here
06:19:12 <deltasquared> speaking of do-notation, nice little trick I discovered recently, do notation with maybe. useful for unwrapping a bunch of things or returning Nothing
06:19:19 <csaurus> tommd: System.Mem.performGC doesn't appear to fix it. I'll look into brackets though
06:19:45 <c50a326> cocreature: well I'm trying to do this thing that this paper gives as an exercise to the reader http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf (can C-f for "drawTree")
06:19:58 <dmwit> maerwald: Using CPP, you can write a program that detects whether it was compiled with -DOPT=1 or -DOPT=2. e.g. something like `{-# LANGUAGE CPP #-} main = print OPT`. I dunno, may need some #ifs or something. Then instead of `optimization: 0` and `optimization: 2` you can use `ghc-options: -DOPT=0` and `ghc-options: -DOPT=2` to determine which of the two options got passed to your program.
06:20:08 <c50a326> it's just not clear to me how you're supposed to know "where you are" in order to be able to output the right things at the right points in the algorithm
06:20:47 <c50a326> I don't even know what to try... not sure if I'm best off trying to use their dfs/bfs/paths/combine functions, or if I should just do from scratch using the subtrees function
06:20:59 <dmwit> Perhaps you should pass "where you are" as an argument to the function.
06:21:02 <cocreature> c50a326: you don’t need to recurse on drawTree you can have drawTree call a helper function that takes additional arguments (e.g. the current indentation) and recurse on that
06:21:08 <deltasquared> c50a326: one moment, let me look at what the output is like
06:21:35 <dminuoso> deltasquared: The cool thing is that you get access to things like >=> and many monadic combinators. This is when things start to get crazy. :)
06:21:57 <deltasquared> :t >=>
06:21:58 <lambdabot> error: parse error on input ‘>=>’
06:22:02 <deltasquared> :t (>=>)
06:22:03 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:22:07 <deltasquared> every time
06:22:16 <deltasquared> I forgot the infix override brackets
06:23:26 <deltasquared> dminuoso: so.... >=> is like function composition? though admittedly with the arguments reversed with respect to your garden variety (.) if I'm reading that right
06:23:35 <cocreature> :t (<=<)
06:23:36 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
06:23:38 <cocreature> that might be more familiar
06:24:04 <deltasquared> when dealing with (.) for a bit your brain starts to get used to the left-wards style...
06:24:52 <dminuoso> deltasquared: It's called kleisli composition yes. :)
06:25:06 <deltasquared> bah, I'm not going to remmeber that name! :P
06:25:14 <cppxor2arr> woah!
06:25:14 <dmwit> Good!
06:25:28 <cppxor2arr> > randomRIO >=> print $ (1,5)
06:25:30 <lambdabot>  <IO ()>
06:25:32 <dminuoso> deltasquared: (\_ -> getLine) (\x -> putStrLine ("hello " <> show x))
06:25:35 <dmwit> Life hack: when mixing (>>=) and (.), don't. Mix (=<<) and (.) instead.
06:25:42 <dminuoso> deltasquared: the idea of creating an arrow that uses >>= to connect these two :)
06:25:49 <deltasquared> "arrow"
06:25:50 <deltasquared> oh dear
06:26:01 <deltasquared> FRP stay out of my head a minute
06:26:14 <deltasquared> (another thing my brain has failed to comprehend thus far)
06:26:26 <dminuoso> deltasquared: functions of the shape `a -> m b` are called kleisli arrows. Dont pay attention to the word "arrow" :)
06:26:43 <deltasquared> I'll just think of arrows as "the thing that appears in functions" then :P
06:27:06 <dminuoso> deltasquared: consider functions and function composition
06:27:18 <dminuoso> deltasquared: then consider (a -> m b) things and (<=<) which is kleisli composition
06:27:19 <bbear> btw, when you write f:: a-> b, if f is an arrow, is a an object or a category ?
06:27:25 <dminuoso> deltasquared: arrows just generalize this! 
06:27:36 <dminuoso> deltasquared: both follow a similar pattern
06:27:46 <dmwit> bbear: object
06:31:01 <dmwit> (Por que no las dos? Consider f : C -> D in CAT.)
06:32:19 <dminuoso> deltasquared: the idea is that `(a -> b)` has some input `a` and some output `b`. (a -> m b) has some input `a` and some output `b`
06:38:57 <dmwit> Wow. This error is really misleading. https://lpaste.net/5499622910047813632
06:39:28 <dmwit> Or maybe "confusing" is more accurate than "misleading". I dunno.
06:39:44 <deltasquared> dminuoso: right, maybe you'd be able to help me with arrows as they came un in FRP then? I recall the description of them being like monadic actions but with the input parameter being explicit in the type, instead of just action to be "run later" 
06:40:51 <deltasquared> it occured to me the other day, in that case if IO was RealWorld -> (a, RealWorld) *hand waving of how IO works starts here* then would those kinds of arrows be more like (a, RealWorld) -> (b, RealWorld)
06:41:13 <deltasquared> though then again I could still be wrong. idk. I should probably play with an FRP gui toolkit sometime
06:42:46 <dmwit> Sure, `a ~> b = (a, RealWorld) -> (b, RealWorld)` would be fine. `a ~> b = a -> RealWorld -> (b, RealWorld)` would be fine, too; no need to do anything special here.
06:43:36 <dminuoso> deltasquared: The point of `Arrow` is that the similarity of `(a -> b)` and (a -> m b)` is that in both cases you can think of them as `Arrow a b`, as in "something that goes from `a` to `b`" equipped with a) a way to lift a function (a -> b) into that arrow, and b) a way to compose two arrows.
06:44:00 <dmwit> (The nice thing about not being clever is that you don't need access to the internals to do it. You could literally type `type a ~> b = a -> IO b` into ghci.)
06:44:25 <dminuoso> If it were. Of course that's a bit handwavy with the types there.
06:49:22 <dminuoso> :t randomRIO
06:49:24 <lambdabot> Random a => (a, a) -> IO a
06:49:35 <dminuoso> :t Kleisli randomRIO
06:49:36 <lambdabot> Random b => Kleisli IO (b, b) b
06:50:07 <deltasquared> dminuoso: I think hand-waving the types is kinda implied with a lot of stuff modelling side effects for explaination purposes...
07:01:30 <tsaka__> is it common practice to have constructors, e.g. "mkMyRecord", inside a Reader monad to avoid taking arguments but retrieve them with 'ask'. In my particular case, only 1 record of the type will be instantiated
07:09:11 <lyxia> tsaka__: do you have an example
07:13:02 <tsaka__> lyxia: Say you're making a sudoku game (or whatever) and read in board size from command-line and put it in a reader monad (with a lot of other configuration, like difficulty, database-port, etc) and then have a "mkBoard :: Reader Conf Board" which reads board dimensions from the config
07:14:02 <tsaka__> instead of "mkBoard :: Int -> Int -> Board" which seems a bit unnecessary if a) There are many arguments and b) All arguments originate from the Reader config
07:14:56 <fizbin> Suppose xs :: [Thing], and foo :: Thing -> Bool, and bar :: Thing -> Bool. What's the most elegant way of saying "there exists an x in xs such that (foo x) and (bar x') for all other x' in xs"?
07:16:46 <dminuoso> fizbin: Do you have an `Eq Thing`?
07:16:57 <lyxia> tsaka__: have you also considered    mkBoard :: Conf -> Board
07:17:42 <tsaka__> lyxia: Yes. I'm unsure when to pass things instead of using a reader monad
07:18:05 <dminuoso> Maybe Im missing something, but is there a simpler way to write this natural transformation from `ReaderT (Pool Connection) a` to servants `Handler a`? https://gist.github.com/dminuoso/8ebe527917567ff8ead80ca8b14405b5
07:18:18 <lyxia> tsaka__: just pass things around, Reader on its own is not that useful
07:18:26 <fizbin> dminuoso: I do, but it's possible that in terms of ==, there may be repeats in the xs list. There are possible Things that are both "foo" and "bar", some that are neither, and plenty that are either just "foo" or just "bar".
07:18:26 <deltasquared> tsaka__: well, I'd hardly be an authority, but if in doubt, keep it simple (tm)
07:20:22 <Entroacceptor> tsaka__: I'm no authority either, but I've definitely seen the Reader used that way.
07:21:29 <dminuoso> Entroacceptor: The `Reader` newtype is kind of useless, since you already have the Functor/Applicative/Monad instance for ((->) a)
07:21:40 <fizbin> Best I have so far is: thereExistsOneFooAndRestBar [] = False; thereExistsOneFooAndRestBar (x:xs) = (foo x && all bar xs) || (bar x && thereExistsOneFooAndRestBar xs)
07:22:35 <dminuoso> fizbin: Why do you need the "rest" there.
07:23:42 <dminuoso> fizbin: I mean presume you have some [x, y, x, w] and `foo x` holds, does `bar` need to hold for [y, x, w] or just [y, w]?
07:24:09 <fizbin> dminuoso: For all of [y, x, w]
07:25:10 <dminuoso> fizbin: Then the word "rest" seems superfluous.
07:26:16 <fizbin> Well, except that if the list is [a, b, c, d, e] and (foo c), then I only need (all bar [a, b, d, e]).  In that case, I don't car about (bar c)
07:27:02 <lyxia> dminuoso: catch _ ex  is  try _
07:28:16 <lyxia> dminuoso: and if you are willing to rely on the underlying representation of Handler, that may be  coerce (try (runReaderT h e))
07:30:20 <lyxia> dminuoso: case _ of Right a -> pure a ; Left e -> throwError e   is   liftEither _
07:30:44 <lyxia> dminuoso: so another way would be   liftIO (runReaderT h e) >>= liftEither
07:32:17 <dminuoso> lyxia: Interesting,  coerce (try (runReaderT h e)) does not work without adding some type annotations.
07:32:54 <dminuoso> but `coerce (try @ServantErr (runReaderT h e)) would do nicely.
07:35:48 <lyxia> oh right, there is nothing constraining the error type for try.
07:38:39 <dataN> % unsafeCoerce (undefined :: forall p. p 'True) :: Bool
07:38:40 <yahb> dataN: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:2:15 in interactive:Ghci5
07:39:19 <dataN> is there no way to demote a promoted value back to value level?
07:39:32 <lyxia> singletons
07:39:46 <dataN> how do they do that
07:39:57 <nshepperd> dataN: you need a typeclass to do that
07:40:32 <dataN> for every datatype that this is over?
07:40:41 <lyxia> class Singleton (a :: k) where singleton :: k    instance Singleton 'True where singleton = True
07:40:44 <merijn> dataN: Basically, yes
07:41:10 <merijn> I'll refer back to my remark from several days ago: "Are you sure you wouldn't rather do this in, e.g., Idris?" :)
07:41:21 <dataN> what, haskell?
07:41:32 <EvanR> wasnt it "*just* do it in idris" :)
07:41:36 <merijn> dataN: Whatever you are doing :)
07:41:52 <merijn> EvanR: Perhaps
07:41:59 <merijn> I'm getting old, so my memory is shoddy :p
07:42:22 <EvanR> idris has its own can of worms :(
07:42:26 <dminuoso> lyxia: Thank you, I think the `coerce + try` way feels like the right way to go.
07:42:29 <cryptokey> If I have a data type defined like data MyType = Number Int | Boolean Bool, then how could I pass in a MyType that specifically contains an Integer to test the case of MyType where it's an integer?   Currently when I do this,I get a couldn't match expercted type error if I just pass in an integer. 
07:42:37 <dminuoso> Your input is, as always, much appreciated. :)
07:42:45 <cryptokey> (using quickCheck)(
07:43:27 <dataN> maybe it can avoid having to do reflection over polykinded constraints 
07:43:40 <merijn> dataN: I mean, all this type level stuff and promoting/reifying values as types and vice-versa is trivial in Idris (and other dependently typed languages) it is (and for the forseeable future) will remain utter shite to do in Haskell
07:44:02 <merijn> There's a reason why the initial singletons paper was called "Hasochism" after all :p
07:44:02 <EvanR> you wont have to do any of this in idris
07:44:05 <EvanR> at all
07:44:08 <dminuoso> cryptokey: Do you have the code you are trying together with the error message?
07:44:19 <dataN> why, because the reified datatype needs to have a singleton instance?
07:44:29 <cryptokey> dminuoso, yes, I'll make a paste
07:44:35 <c50a326> why does this https://ptpb.pw/hKHH/hs give this error? https://lpaste.net/4914941457195859968 if I remove the type sig for the nested function, it doesn't complain (though the function is still completely wrong and doesn't work for intended purposes lol)
07:44:54 <c50a326> and is there an easy way to :t such nested functions after removing the type sig?
07:45:15 <merijn> dataN: Because Haskell isn't dependently typed, you can't really reify types back into values. Singletons hacks around this by abusing typeclasses and having one instance per type to do the reification
07:45:16 <dminuoso> c50a326: ScopedTypeVariables *shrugs*
07:45:29 <dminuoso> c50a326: But that's just a thought after looking at your paste for like 2 seconds.
07:45:39 <dataN> merijn: haskell seems perfectly able to do whats necessary 
07:45:49 <merijn> dataN: It is *able* to
07:45:54 <dminuoso> merijn: Stephanie can make Haskell dependently typed!
07:45:57 <dminuoso> =P
07:46:10 <dminuoso> Im excited to see her talk in 2 weeks.
07:46:14 <merijn> dataN: I'm just saying that there is no way around the pain and misery you're experiencing to get to that point :)
07:46:32 <dataN> there isnt a problem of using its more advanced features to express what couldnt be expressed otherwise 
07:46:34 <merijn> dataN: (while pointing out that the pain and misery is only present in Haskell)
07:46:47 <Taneb> I've got a warning that a function generated by template Haskell has a missing type signature, but when I try to add the type signature I get an error that the type signature doesn't have a binding
07:46:54 <Taneb> What can I do about this?
07:46:56 <dminuoso> c50a326: Ah yeah, it's ScopedTypeVariables that you need. The reason is, without that extention the inner `t` is a separate quantification.
07:46:57 <davr0s> i just tried hoogle, none the wiser.. does this exist:  orElse::(a->Maybe b)->(a->Maybe b)->(a->Maybe b)     - compose to failable functions, same input/output- call the second if the first fails
07:47:12 <dminuoso> c50a326: Also note that you also need to explicitly use `forall t` (with the extension)
07:47:18 <cryptokey> dminuoso: https://lpaste.net/6375538871106535424
07:47:19 <dataN> merijn: learning is to be encouraged 
07:47:45 <c50a326> dminuoso: it doesn't complain when the type sig is removed, maybe the extension is enabled by default and puts the forall thing in the type sig for me...
07:47:55 <dataN> a library can benefit from using available language features 
07:48:14 <dminuoso> c50a326: If you explicitly annotate it, you introduce fresh type variables.
07:48:16 <dataN> and helper functions can be developed to reduce the complication for the user
07:48:21 <dminuoso> c50a326: It cant unify with those
07:48:35 <dminuoso> c50a326: If you dont explicitly annotate it, it will infer things automatically because hindley milner.
07:48:55 <dataN> if this was clear from the choice of Idris then it should be enough now
07:49:25 <dminuoso> c50a326: The reason is that you are using a type variable from the outer scope. In order to do that, you have to turn on an extension (one I argue should be in the Haskell report), and (to avoid legacy problems) introduce `t` in the outer scope explicitly via forall.
07:49:43 <c50a326> ah okay, cool
07:50:01 <c50a326> now I know what forall is for at least :)
07:50:19 <dminuoso> c50a326: You could think of `forall` as being implicit whenever you have a type variable. :)
07:51:42 <dminuoso> cryptokey: What exactly is `Expr` in the value world?
07:51:44 <EvanR> dataN: its a shame that its so much simpler with DT
07:52:09 <EvanR> but we dont yet have the concrete tech to exploit it
07:52:29 <dminuoso> c50a326: Also note that you do not need the constraint in the inner annotation.
07:53:05 <dminuoso> c50a326: so `drawTree :: forall t. DrawTree t => ...` in the outer definition, and then `drawTree'' :: Int -> t -> [String]` in the inner definition.
07:53:09 <dataN> if the limit of whats possible now changes in the future it will only be easier to write these highly expressive programs 
07:54:11 <dataN> but whats possible now is possible even if its complex, and without such examples it wouldnt be easy to see how extra features could help
07:56:18 <dataN> matching on more specific overlapping instances seems to be a way to define local instances globally and have only the flag to choose to enable them need be reflected, reducing the arity of the reflected argument and removing the complication of reflection of polykinds
07:56:41 <nshepperd> dataN: did you expect "unsafeCoerce :: p 'True -> Bool" to do anything useful 
07:56:50 <cryptokey> Does anybody know how I can pass in a particular case of a data type to a quickCheck test?  i.e. My data type can be an integer, boolean, etc, but I just want to test with an integer.   But if I pass in an integer, it gives me an error because my function expects the data type, not an integer:  https://lpaste.net/5820258311936671744
07:57:08 <dataN> nshepperd, it would have been good if it had been able to recover the promoted value 
07:57:31 <dminuoso> cryptokey: You *probably* want to be using GADTs already.
07:57:51 <cocreature> you really don’t need GADTs for that
07:57:58 <nshepperd> unsafeCoerce just reinterprets the bits of the value
07:57:59 <dminuoso> No you dont. Im just saying..
07:58:13 * dminuoso shrugd
07:58:13 <nshepperd> it'll return False if p is any normal proxy type like Proxy
07:58:14 <Ariakenom> c50a326: to :t inside an expression you can use TypedHoles where you give the type the signature x::_
07:58:15 <dminuoso> or not 
07:58:19 <cocreature> cryptokey: prop_tailCallsAtomic num = tailCalls (Number num) == []
07:58:23 <nshepperd> which only has one constructor
07:58:34 <dataN> % unsafeCoerce (Proxy :: forall p. p 'True) :: Bool
07:58:34 <yahb> dataN: ; <interactive>:3:15: error:; * Couldn't match type `p' with `Proxy'; `p' is a rigid type variable bound by; an expression type signature:; forall (p :: Bool -> *). p 'True; at <interactive>:3:24-40; Expected type: p 'True; Actual type: Proxy 'True; * In the first argument of `unsafeCoerce', namely `(Proxy :: forall p. p 'True)'; In the expression
07:58:45 <dataN> % unsafeCoerce (Proxy :: Proxy 'True) :: Bool
07:58:45 <yahb> dataN: False
07:58:53 <dataN> % unsafeCoerce (Proxy :: Proxy 'False) :: Bool
07:58:53 <yahb> dataN: False
07:58:58 <dataN> well thats no good
07:59:14 <cocreature> the type isn’t represented at runtime
07:59:23 <cocreature> so there is no way that unsafeCoerce could behave differently here
07:59:58 <cocreature> unsafeCoerce is literally “let’s pretend this piece of memory has a different type than GHC thinks it does”
08:00:02 <dataN> but there are no values of 'True as its not a type,it has kind Bool
08:00:41 <cocreature> the type argument is completely irrelevant here. unsafeCoerce sees the value at runtime not the type
08:00:55 <dataN> can that Singletons class defined above be derived?
08:00:57 <cryptokey> cocreature, I'm getting a similar error as before for that unfortunately.  https://lpaste.net/1935954515807174656
08:01:01 <nshepperd> understanding why this doesn't work seems like it should take precedence over charging ahead on some quixotic quest to implement advanced reflection stuff
08:01:29 <cocreature> cryptokey: change the type signature to Int -> Bool
08:01:32 <dataN> nshepperd: sure, anyway its nearly there 
08:01:32 <cryptokey> cocreature:  Ohh, I needed to say it took in Int
08:01:54 <cryptokey> cocreature:  Thanks a bunch!
08:03:04 <dataN> the it can be decided how practical it is 
08:05:53 <nshepperd> it seems like you don't understand haskell so I don't see how you can know that it's nearly there
08:06:10 <dataN> this reflected Monad works, but the reflection mechanism is not polykinded, so there is difficulty using it with arbitrary constraints over multiparameter typeclasses
08:06:11 <dataN> https://gist.github.com/dataN-hs/9c7e6106b2bbb992c1a2de25b2bdd930
08:09:34 <dataN> still would be good to be able to write deriving Singeleton though
08:09:36 <dataN> for; class Singleton (a :: k) where singleton :: k    instance Singleton 'True where singleton = True
08:10:01 <dataN> well, without the instance...
08:10:28 <dataN> then any promoted value of a datatype could be demoted without the excess boilerplate.
08:10:39 <dataN> seems like thats not unreasonable
08:12:12 <dataN> nsepperd: describing the current goal before its complete doesnt make that goal somehow fantastic 
08:28:34 <mikail_> I am designing an application at the moment and I researching various technologies (Scala, Akka, Erlang/Elixir, Kafka, Haskell). One significant part of the application will require messaging and for this I want to utilise a priority queue (FIFO). My question is what is the fastest priority queue in Haskell for writing to tail, and popping from head?
08:29:51 <dminuoso> mikail_: Kind of depends on what your other requirements are.
08:30:44 <mikail_> dminuoso, for example?
08:31:12 <dminuoso> mikail_: Control.Concurrent.STM.TQueue
08:31:32 <dminuoso> mikail_: For example if you want to do this from within STM.
08:31:41 <EvanR> is that a "priority" queue though
08:32:30 <mikail_> EvanR, Data.Heap?
08:34:54 <dminuoso> EvanR: Well there are a few PQueues based on STM around, but they dont seem to be well maintained mmm.
08:38:19 <mikail_> dminuoso, I'm also looking at unagi-chan
08:48:23 <dmwit> fizbin: Using regex-applicative, isJust . match (() <$ many (psym bar) <* psym foo <* many (psym bar))
08:49:46 <fizbin> Hrm...
08:50:49 <cocreature> mikail_: if you actually want a priority queue instead of just a queue (without special support for priorities), take a look at https://hackage.haskell.org/package/psqueues
08:51:18 <tommd> mikail_: I don't know of any benchmark of haskell priority queues but have always had http://hackage.haskell.org/package/meldable-heap in my mind if I needed one.
08:51:46 <mikail_> thanks, I'll take a look at those
08:52:18 <mikail_> my company is thinking of Kafka, but I don't want to bring in a beast like that for such a simple use case that we have
08:52:43 <tommd> It probably isn't immediately what you want since it uses Ord and has no value associated to the `a` type (key, basically).  You can leverage this and a matching hashmap or similar for most uses.
08:53:10 <lavalike> what is the difference between say a Map and one of those priority queues?
08:53:12 <tommd> mikail_: I recently used the zeromq4 bindings and have been pleased - but that is a different offering than Kafka.
08:53:25 <cocreature> yeah kafka plays in a completely different league. I can’t imagine many usecases where you end up having to choose between kafka and psqueues
08:53:55 <tommd> lavalike: A PQ serves up elements based on some priority - so low priority elements even if they were added first will be served after high priority elements.
08:55:05 <cocreature> tommd: right but a Map where you use the priority as the key and deleteMax will get you pretty close to that
08:55:14 <lavalike> tommd: is that different than Data.Map.lookupMin, say? (or deleteFindMin if you will)
08:55:56 <EvanR> mikail_: unagi-chan is also not a priority queue
08:56:42 <mikail_> EvanR, it states in their github README that it has FIFO semantics which is what I want
08:56:50 <lavalike> maybe a priority queue handles items with the same priority, whereas Map doesn't like insertions of multiple items with the same key? (I'm speculating)
08:56:52 <EvanR> FIFO versus priority
08:56:59 <EvanR> see above discussion
08:58:11 <cocreature> lavalike: ah right, that’s a good point!
08:58:36 <lavalike> ha! I see
08:59:35 <tommd> Stability depends on the pq implementation - some have stability where the first come first serve while others do not.
08:59:45 <lavalike> that makes sense
08:59:51 <heptahedron> Is the Parsec monad law-abiding?? It doesn't seem like it would be from the way its definition for `pure` but I haven't slept all night
08:59:54 <lavalike> I think I literally never used a pq to solve a problem in practice
09:00:32 <lavalike> heptahedron: I think you can be fairly assured that it is conforming by the stress test of years of use? Few monads have more users
09:00:34 <tommd> mikail_: So do you actually need to set different priorities for different messages a la a priority queue or are you actually just looking for a message queue?
09:00:58 <mikail_> tommd, just a plain message queue
09:01:24 <heptahedron> lavalike: that's what I was inclined to believe, I guess I'm just having trouble seeing how the left and right identity hold when `pure` only calls the `eok` continuation with the pure value http://hackage.haskell.org/package/parsec-3.1.13.0/docs/src/Text.Parsec.Prim.html#parserReturn
09:01:26 <dmwit> heptahedron: Should be. What in particular makes you concerned?
09:01:35 <heptahedron> dmwit: see above haha
09:02:08 <heptahedron> I only came across this because I had doubts in my own hand-rolled CPS monad implementation 
09:02:34 <tommd> mikail_: I'll be back soon if you want to discuss, but if you don't need a broker then zeromq works well for me (https://gist.github.com/TomMD/7f51ae6c353b25c27c98e76c6df3e388)
09:04:16 <dmwit> heptahedron: The left identity law looks pretty straightforward to me, provided `mergeError (unknownError s) err = err`.
09:04:27 <dmwit> heptahedron: Do you want to walk through that one to start?
09:04:38 <dmwit> Might give you a clue about addressing the right identity law.
09:04:41 <mikail_> tommd, thanks I'll take a look. Will ping you if I need more info.
09:07:22 <hexagoxel> heptahedron, dmwit: might be worth reducing it to the primitive CPS-with-escape monad: https://hackage.haskell.org/package/contstuff-1.2.6/docs/Control-ContStuff-Trans.html#t:EitherT
09:09:41 <heptahedron> oi, I really should have tried harder to sleep last night lol
09:11:58 <heptahedron> Oh, okay, I see my monad should be law-abiding as well
09:15:03 <heptahedron> One I still don't know that I could probably figure out if I had more time to investigate and weren't a zombie: why is it common to see the success continuations in e.g. `ParsecT` and `LogicT` accept a failure result in addition to their expected values? Does that lessen the amount that has to be kept on the heap when e.g. backtracking?
10:17:54 <michalrus> Uhhh, what should I do with this error?
10:17:54 <michalrus>     • Redundant constraint: HasCallStack
10:18:07 <fresheyeball> michalrus: remove the constraint
10:18:12 <michalrus> It kind of makes sense, but HasCallStack is different.
10:18:29 <michalrus> Yea… But I want a callstack there. :p
10:18:46 <fresheyeball> michalrus: well it would appear you are not having a callstack there
10:18:56 <fresheyeball> as in the implimentation of your term, does not use HasCallStack
10:19:08 <fresheyeball> so if you are looking for a call stack there, the constraint is not enough
10:19:35 <michalrus> Yes, but if an exception is thrown, then functions with HasCallStack will be included in the call stack, no?
10:19:59 <michalrus> I want this one to be included.
10:20:07 <fresheyeball> your code is not able to through an excpetion with a call stack though, not yet anyway
10:20:38 <michalrus> But I’m not using the call stack per se in that function.
10:20:40 <fresheyeball> you need to have something in the implimentation that needs HasCallStack for that constraint to be needed
10:20:41 <michalrus> Hmmm.
10:21:03 <fresheyeball> if you don't need it in that function, remove the constraint
10:21:15 <fresheyeball> when you are in a context that needs it GHC will demand the constraint
10:21:25 <fresheyeball> its just that your function can be used with or without that constraint right now
10:21:33 <fresheyeball> so its best not to have the constraint for generality 
10:22:02 <michalrus> Yes, it can, but if I don’t include the constraint, and then throw an exception, this function will not be included in the reported callstack of that exception.
10:22:14 <michalrus> That’s how it works, isn’t it? http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stack.html
10:22:20 <michalrus> *doesn’t
10:22:24 <fresheyeball> I might be wrong then
10:22:34 <fresheyeball> if it infact works that way (which is not my expectation)
10:22:54 <fresheyeball> then you can get around this by using `GHC_OPTIONS` pragma to allow the redundant constraint
10:22:55 <lyxia> it doesn't seem to work that way
10:23:04 <lyxia> you need to have HasCallStack constraints all the way
10:23:14 <fresheyeball> how if it works that way, then I would expect call stacks to be basically worthless as most functions don't have that constrain
10:23:32 * michalrus scratching head
10:23:39 <tommd> You can pass additional options to cause implict stack constraints.
10:24:17 <michalrus> Yes, but I don’t want full stacks, just for the ones I add the constraint to.
10:24:21 <dmwit> michalrus: That should be a warning, not an error.
10:24:57 <michalrus> dmwit: it is, but not with -Wall, I like it as an error, apart from for HasCallStack. =)
10:25:14 <michalrus> *-Werror
10:26:06 <lyxia> I don't think you can use GHC's callstack mechanism if you just want a few functions here and there to add themselves to the stack
10:26:33 <dmwit> michalrus: Okay, I have a cunning plan.
10:26:43 <michalrus> I could add a dead binding of `where _ = callStack` to the end, as the warnings manual suggests.
10:26:48 <dmwit> michalrus: Disable -Werror for one module, in which you define `useConstraint :: HasCallStack => ()`.
10:27:12 <dmwit> michalrus: Then when you want a callstack, you put `HasCallStack` in your context as usual, and add `where () = useConstraint` to its implementation.
10:27:38 <dmwit> Oh, the manual gives an official recommendation of doing essentially this, eh? =D
10:27:44 <michalrus> Haha, yes. =P
10:27:50 <lyxia> michalrus: if you silence the warning you might as well not have a HasCallStack constraint in the first place
10:28:22 <michalrus> lyxia: but that’s how they work until you enable implicit HasCallStack for all functions, via a GHC flag? Hmmm.
10:28:28 <lyxia> I mean, if you silence it in that way
10:28:28 <michalrus> lyxia: but HasCallStack is special.
10:28:35 <michalrus> I’m a bit lost.
10:28:35 <dmwit> lyxia: Are you sure?
10:28:45 <fresheyeball> michalrus: I see the problem, damn
10:28:47 <cocreature> michalrus: HasCallStack won’t propagate through a function that doesn’t have a HasCallStack constraint
10:29:33 <dmwit> Dang, that's true.
10:29:38 <michalrus> Oh. :o
10:29:52 <cocreature> here’s a simple test program https://gist.github.com/66f7ed918919fce37cff2241dfafe67a
10:30:56 <lyxia> When you call a function with a HasCallStack constraint, GHC does a bit of magic to add something to the stack.
10:31:25 <lyxia> but if you just have the constraint lying around and don't call a function that needs it, nothing happens
10:31:51 <michalrus> Ohhhhhhhh, I get it.
10:33:10 <michalrus> OK, clear.
10:33:15 <michalrus> Sorry for the confusion. ^.^
10:33:29 <michalrus> And thank you, all!
10:41:28 <osa1> which directory do I nuke when I get this error from stack: "installed package haddock-library-1.4.5 is broken due to missing package haddock-library-1.4.5-JMywL3gQR7h8vuSGU4Yu5w-attoparsec" ?
10:41:56 <osa1> ~/.stack/snapshots?
10:53:41 <MarcelineVQ> osa1: did you google that error in case nuking things isn't the option to persue?
10:55:11 <osa1> MarcelineVQ: yeah. in any case I just deleted ~/.stack and it's compiling now.
11:31:37 <michalrus> Interesting that not all -Wredundant-constraints are discovered with optimizations turned off.
11:39:53 <geekosaur> it's not that uncommon that a compiler simply doesn't keep track of everything needed unless it's there for optimization. and that that's done because it's part of what makes compiling with optimization slower than without
11:41:20 <mniip> michalrus, much like in gcc
11:41:48 <mniip> most of the stuff that goes into -Wall isn't caught without -O
11:49:12 <michalrus> I see. =) Thanks!
12:01:04 <davr0s> is there a more elegant way to write this (especially curious if it already exists)  https://pastebin.com/8VYvt47T
12:01:41 <lyxia> liftA2 (<|>)
12:02:06 <davr0s> ok thanks
12:02:47 <dataN> :t maybe
12:02:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:03:42 <davr0s> :t <|>
12:03:44 <lambdabot> error: parse error on input ‘<|>’
12:03:51 <davr0s> :t (<|>)
12:03:52 <lambdabot> Alternative f => f a -> f a -> f a
12:04:26 <davr0s> :t (liftA2 (<|>)
12:04:27 <lambdabot> error:
12:04:27 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:04:29 <davr0s> :t (liftA2 (<|>))
12:04:31 <lambdabot> (Applicative f2, Alternative f1) => f2 (f1 a) -> f2 (f1 a) -> f2 (f1 a)
12:05:32 <dataN> :t return :: a -> Maybe a
12:05:34 <lambdabot> a -> Maybe a
12:05:39 <tsaka__> Given that I'm in the "State A ()" monad, and I create a "b :: B", is there a way to do computations in the "State (A, B) ()" monad? I tried but failed: https://lpaste.net/7270402866370576384
12:06:29 <davr0s> as an excercise i've written something to parse JSON (writing somethign to parse data structures in haskell still makes me uncomfortable compared to C++ .. ) , it's not completely horrible now but i'd like to see what the  accepted way to do things is.. i'm also pretty sure there's a load of places where things like the state monad(???)or other would streamline it
12:07:00 <davr0s> i was starting to use >> etc in do blocks outside of IO examples in my last haskell forray but i've forgotten the details
12:07:15 <merijn> davr0s: "Written something to parse JSON" as in "using a JSON parser" or as in "writing my own JSON parser"?
12:07:47 <davr0s> writing my own JSON parser, as an exercerise (i'm guessing there's a library arlready)
12:07:52 <EvanR> monadic/applicative parser combinators to produce ADTs vs C++... shudder
12:08:12 <dataN> apparently its not possible to obtain e.g. the first type matched by print because of the interaction of IncoherentInstances and OverlappingInstances breaking the specificity matching meachanism it relies upon
12:09:25 <cocreature> tsaka__: looks like you need a call to "lift"
12:10:37 <cocreature> tsaka__: if you take a close look at the error message it tells you that it expects something of type "t m a" but you are giving it "m a". "lift" is exactly the function that lets you embed an "m a" inside "t m a"
12:14:39 <tsaka__> cocreature: that worked. Is there a way to create that function more elegantly? I mean I have to pull out "state A" manually, run "state (A,B)" computations with execStateT and put the state back in.
12:16:22 <dataN> davr0s: the Reader-like constraint is not enough to let the functions that require a State-like constraint.
12:18:51 <cocreature> :t (\a -> assign _2 =<< zoom _1 a) :: State a b -> State (a, b) ()
12:18:53 <lambdabot> State a b -> State (a, b) ()
12:18:57 <cocreature> ^ tsaka__ how about that?
12:25:06 <lavalike> :o
12:25:45 <tsaka__> Where would you use that in the pasted function?
12:26:24 <cocreature> tsaka__: you’ll have to isolate that to some standalone example. there is too much going on to easily see how this would apply. however this does solve the problem that you have described so presumably it can be used :)
12:26:54 <lavalike> cocreature: are all four of those lens operators?
12:27:14 <tsaka__> assign, zoom, _1 and _2 are all lens ops
12:27:19 <lavalike> yes, those
12:27:50 <cocreature> lavalike: I wouldn’t call them operators (that’s usually reserved for infix operators) but yeah they all come from lens
12:28:36 <lavalike> thingies that do operations
12:28:54 <tsaka__> (functions)
12:29:07 <lavalike> :t _1
12:29:08 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
12:31:01 <lavalike> @info Field1
12:31:01 <lambdabot> Field1
12:31:28 <lavalike> might have been the wrong way to go about that
12:31:54 <cocreature> % :i Field1
12:31:54 <yahb> cocreature: class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where; _1 :: Lens s t a b; default _1 :: (GHC.Generics.Generic s, GHC.Generics.Generic t, Control.Lens.Tuple.GIxed Control.Lens.Tuple.N0 (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Lens s t a b; -- Defined in `Control.Lens.Tuple'; instance [safe] Field1 (Identity a) (Identity b) a b -- Defined in `Control.Lens.Tuple'; instance [safe
12:32:07 <cocreature> although you might just want to use your local ghci instance at this point
12:32:18 <lavalike> look at all those functional dependencies
12:54:22 <tombusby> hey, is there an official apt repository for ghc/cabal/stack? I have an assignment where I need ghc >= 8.2 and cabal-install >= 2.0.
12:54:51 <tombusby> But doing apt haskell-platform or apt ghc haskell cabal installs ghc 8.0.2 and cabal 1.24.0.2
12:56:04 <tombusby> this looks promising actually: https://launchpad.net/~hvr/+archive/ubuntu/ghc
12:56:05 <sclv> tombusby: what os?
12:56:09 <tombusby> Ubuntu
12:56:12 <sclv> oh right if you're ubuntu then yes, use that
12:56:35 <tombusby> sclv: thx
13:18:03 <Boarders> I have some sort of behaviour messing up with compact regions. Here is a minimal example that messes up for me: https://lpaste.net/1212947611053457408
13:18:46 <Boarders> when run it gives: "compact-vector: Data.Vector.Mutable: unitialised element"
13:19:27 <Boarders> @bgamari (if you are curious)
13:19:27 <lambdabot> Unknown command, try @list
13:23:35 <cocreature> Boarders: didn’t you ask that same question a while back? or was that someone else?
13:23:49 <Boarders> I did
13:23:53 <Boarders> but it was a different error
13:24:19 <Boarders> that was fromList in Data.Vector messing up with compact regions by allocating too much space
13:24:29 <Boarders> this is parTraversable messing up
13:26:23 <Boarders> (the previous thing was this problem: https://github.com/haskell/vector/issues/220 )
13:26:54 <cocreature> well it’s the same problem
13:27:20 <cocreature> the vector API operates under the assumption that by not exposing the constructor it’s safe if it presents you only the initialized slize
13:27:23 <cocreature> *slice
13:28:05 <cocreature> that no longer holds in the presence of compact regions since there is no way for them to take this into account when compacting the Array
13:29:14 <cocreature> if you apply "force" before compacting things work properly
13:31:42 <Boarders> adding force does not seem to fix the issue
13:31:49 <Boarders> unless I am doing something wrong
13:32:24 <Boarders> I specifically only get this error when using "withStrategy (ParTraversable rpar)"
13:38:39 <Boarders> I also don't understand saying "this is the same bug"
13:38:55 <Boarders> well I fixed the fromList bug in the code base and it works so I would say it is different
13:39:04 <Boarders> even if it is still to do with how vector works
13:41:14 <dolio> It's essentially the same bug, because it's compact regions violating invariants that are otherwise not violated in vector.
13:43:26 <dolio> That it's not neccessary to create new underlying storage with exactly the number of elements that are used according to the length stored in the wrapper.
13:43:44 <dolio> Because no one will try to use them.
13:44:06 <cocreature> Boarders: if I add force around the whole definition of vec3 it does not crash for me
13:44:20 <Boarders> ok, I'll give that a try
13:44:41 <Boarders> do you think it is because traverse for Vector uses fromList again
13:44:42 <dolio> It may have been fixed for fromList, but there are probably a bunch of other places that make that assumption.
13:46:25 <cocreature> the fact that here it only seems to be reproducible with the parallel version is odd
13:53:25 <Boarders> cocreature: sorry to be a nuissance, could you say precisely where you put force
13:53:28 <Boarders> if I do
13:53:48 <Boarders> vec3 :: V.Vector Int; vec3 = force (withStrategy (parTraversable rpar) $  zipWith (+) vec1 vec2)
13:53:53 <Boarders> I still get the unitialised error
14:17:01 <Boarders> cocreature: It is just because parTraversable calls traversable I think which calls fromList
14:24:19 <apostolis> Is there a way for the compiler to show me the types of the local variables of a function?
14:24:44 <apostolis> I use emacs. And the function has errors.
14:28:55 <dmwit> -fdefer-type-errors can help with the latter.
14:29:03 <dmwit> I'm afraid the former is terminal, though.
14:32:47 <apostolis> dmwit : Thanks
14:36:16 --- mode: glguy set +v dasli
14:36:40 --- mode: glguy set -v dasli
14:37:06 <apostolis> I was inserting a reduntant "pure" to a string. The compiler turned the string into [[Char]]. This does not make any sense.
14:39:25 <hpc> String is [Char]
14:39:37 <hpc> presumably in this case the (pure whatever) is supposed to also be a list
14:39:40 <dmwit> apostolis: Makes sense to me. `type String = [Char]` and `pure :: a -> [a]`.
14:39:41 <hpc> so put more list brackets around that
14:40:09 <dmwit> More specifically, `pure :: [Char] -> [[Char]]`. ;-)
14:40:15 <apostolis> The Functor was not a List.
14:40:27 <dmwit> Obviously it was. =)
14:41:12 <dmwit> If you show us enough code to reproduce the problem, we may be able to explain in further detail. Bonus points for minimizing it first.
14:42:00 <apostolis> It was in a let statement like this : let x = pure s.
14:42:26 <apostolis> I pressume that x can have any type, thus the type till now cannot be deduced.
14:43:34 <dmwit> No, Haskell (without extensions, anyway) enjoys a property called "principal types": every well-typed term has a unique most-general type.
14:44:16 <dmwit> Without knowing the type of `s` I can't say what that would be, but if you say `s :: String`, then `x :: Applicative f => f String` would be its principal type.
14:44:47 <apostolis> And we do not know f, thus f is not necessaryt a List.
14:45:00 <dmwit> Sure. It's not necessarily apart from list, either.
14:45:54 <dmwit> But also this is not enough code to reproduce your problem. =)
14:46:06 <apostolis> My point is that the compiler shouldn't return ab error as if it was. (Maybe it deduced it from somewhere else though)
14:46:27 <dmwit> My point exactly: you almost certainly had another part of the code which caused it to choose f ~ [].
14:51:21 <apostolis> dmwit : +1
14:54:44 <geekosaur> at the end of the ay, any haskell program is a single expression, on which type inference can be done. which can lead to apparent "spooky action at a distance" if you don't keep this in mind
14:54:58 <geekosaur> *day
15:02:48 --- mode: glguy set +v geekyblinder
15:11:25 <ab9rf> universe creation through type inference
15:12:45 --- mode: glguy set +v sleepster
15:16:56 --- mode: glguy set +v specialOne
15:17:26 --- mode: glguy set +v Boarders
15:19:31 <specialOne> Should I read Category Theory for Programmers? 
15:19:49 <geekosaur> oly if your eally care that much
15:19:55 <phadej> if you are interested in CT
15:20:09 <geekosaur> it won't teach youanyting useful for learning Haskell
16:41:20 <davr0s> before i roll something .. is there a list type that can be guaranteed to have 1 element
16:41:54 <mniip> NonEmpty
16:41:57 <davr0s> a wrapper for  (t,[t])  looking like one iterable i guess
16:42:03 <davr0s> ok ince
16:42:06 <davr0s> ok nice^
16:42:12 <nitrix> NonEmpty from Data.List.NonEmpty
16:42:19 <hpc> mniip: you answered too fast, i was going to go with the uselessly correct answer of Identity
16:42:30 <hpc> :D
16:42:50 <davr0s> and yes i did really mean 'at least one element', not 1 element
16:43:17 <davr0s> i'm guessing "identity" is a functor with exactly one element perhaps
16:43:24 <mniip> in hindsight, why is NonEmpty not defined with
16:43:34 <mniip> data NonEmpty a = a :| Maybe (NonEmpty a)
16:44:04 <nitrix> Maybe to simplify the implementation. It can piggy back on [] and all the stream fusion it does?
16:44:13 <tommd> Lots of optimizations on lists exist and lots of functions are specialized on lists?
16:44:38 <davr0s> i was thinking of (t,[t]), is that how it works under the hood?
16:44:53 <hpc> it's not specifically a tuple, but yeah
16:44:56 <nitrix> davr0s: data NonEmpty a = a :| [a]
16:45:13 <nitrix> davr0s: They chose the constructor (:|) instead of (,) but it's very similar, yeah.
16:45:13 <davr0s> i'm going to have to read up on :| ..
16:45:28 <hpc> that's just an arbitrary operator name
16:45:30 <tommd> There's not much to read.
16:45:33 <hpc> it's being defined along with the type
16:45:56 <hpc> davr0s: you can define infix constructors if you start them with ':'
16:46:01 <hpc> because that's the only upper-case symbol
16:46:28 <hpc> (it's already used for list cons, so it make sense)
16:46:37 <mniip> uppercase symbol always cracks me up
16:46:46 <hpc> mniip: i phrase it that way on purpose every time
16:46:57 <hpc> > isUpper ':'
16:46:59 <lambdabot>  False
16:47:04 <hpc> OH NO
16:47:55 <hpc> oh well
16:49:00 <hpc> davr0s: and yeah, newtype Identity a = Identity {runIdentity :: a}
16:49:40 <hpc> davr0s: it's the type-level equivalent of id, if you ever try out type-level programming
16:50:05 <davr0s> that sounds too much like 'template metaprogramming'..
16:50:45 <davr0s> although it might not be as insane here i suppose
16:51:19 <hpc> you'd be shocked by how much sense it makes
17:03:57 <hololeap> :'
17:23:10 <tikhon> hey, is there a way to check if a name is in scope in a module with Template Haskell?
17:25:37 <tikhon> hey, is there a way to check if a name is in scope in a module with Template Haskell?
17:25:41 <tikhon> oops, sorry
17:28:04 <lyxia> tikhon: https://hackage.haskell.org/package/template-haskell-2.13.0.0/docs/Language-Haskell-TH.html#g:6
17:28:21 <tikhon> oh thanks, totally missed that in the documentation
17:31:26 <tikhon> do you know if there's a way to look up whether a base name exists qualified with an unknown prefix?
17:33:10 <lyxia> do these functions not do that?
17:35:05 <tikhon> hmm, good question—I assumed they look the name up exactly (ie "foo" will find foo but not Module.foo)
17:35:08 <tikhon> but I haven't checked
17:35:10 <tikhon> let me try it
17:37:18 <tikhon> yeah, looks like it looks up the full name
17:37:49 <tikhon> so lookupValueName "foo" will not find "Module.foo"
17:44:44 <lyxia> tikhon: I don't know a solution. What do you need this for?
17:45:57 <tikhon> I'm generating Haskell types from an external IDL that has its own kind of module
17:47:01 <tikhon> so if I have one IDL module that imports another, I want to either generate *all* the types I need or rely on existing identifiers in scope
17:47:19 <tikhon> (so that people could reuse the Haskell modules that correspond to modules in the IDL)
17:47:49 <tikhon> it works a lot like C programs with #ifdef
17:48:22 <tikhon> right now, it will only work if you import the corresponding modules unqualified—that's a restriction I can live with, but it isn't ideal
17:48:43 <tikhon> not sure my explanation makes much sense
19:53:42 <justekud> Curious to meet 1+ ppl tonight excited by crazy rare weird software engineer kinda like zombie (handicapped big) + simultaneously superman (rare level advanced) ...
20:49:17 --- mode: glguy set +v sebastianrkg
20:51:47 <sebastianrkg> I notice a bunch of entries in GHC profiling with the prefix "CAF". Is this something expected? An excerpt from the profile doc I generated: https://pastebin.com/raw/BtA95PbA
20:52:50 <sebastianrkg> Also, in that same document, MAIN takes 33.6% of the CPU time. Shouldn't MAIN be something that has 0 self time and 100% total time (maybe we don't count forked threads)?
20:53:55 <Tops2> I'm as clueless as you, but afaik it stands for Constant Applicative Form https://wiki.haskell.org/Constant_applicative_form
20:54:13 <sebastianrkg> yeah, I read that too. It only mystified me further
20:56:08 <sebastianrkg> I'm actually not sure that it's the same abbreviation, since it seems so unrelated
20:58:21 <sebastianrkg> although "A CAF can always be lifted to the top level of the program" seems to align with the way it is showing up in profiling
20:58:33 <Tops2> Where I stumbled upon it, it's explained as 'expressions that are top-level and unconstrained': http://hackage.haskell.org/package/enumerate-0.2.2/docs/Enumerate-Enum.html
20:59:54 <sebastianrkg> hmm, okay, interesting. None of them are cost centers (which makes sense per their definition) so I just won't worry about it for the moment
21:00:14 <sebastianrkg> any reason MAIN would profile as taking 33% of CPU time?
21:00:29 <sebastianrkg> ...34%, more accurately, I suppose
21:01:43 <boj> do you have something looping while waiting to poll in main?
21:02:45 <sebastianrkg> yeah, that's what I'm thinking, I have a loop to prevent the main thread from finishing that I hacked in at the beginning of this project, instead of using the nicer async abstractions
21:03:01 <sebastianrkg> liftIO $ forever $ threadDelay 1000000
21:03:34 <sebastianrkg> time to make that nicer
21:07:47 <koz_> jle`: I could use some help with some dependent type stuff: https://lpaste.net/6667793953737146368
21:08:12 <koz_> (if you can, of course)
21:22:30 <jle`> koz_: do you want the n and m to come from runtime?
21:22:39 <jle`> or is it statically known
21:39:00 <koz_> n and m are both runtime.
21:39:09 <koz_> (specifically from the SQLite database)
21:39:25 <koz_> The idea is that I go something like:
21:39:33 <koz_> 1) Use getNumExamples to fish out what n should be
21:39:52 <koz_> 2) Use getNumAttributes + getTableNames to fish out what m (and attrNames) should be
21:39:58 <koz_> 3) Return _something_ in IO.
21:40:27 <koz_> I guess it'd be something like (forall n m . (KnownNat n, KnownNat m) => DataSetMeta n m -> r) -> r, but I am unsure how IO comes into all this.
21:48:06 <koz_> jle`: ^
22:06:22 <jle`> koz_: yea you'd probably do something like (forall n m. (KnownNat n, KnownNat m) => DataSetMeta n m -> IO r) -> IO r
22:06:39 <koz_> Ah, so the IO has to go _there_.
22:07:09 <jle`> doesn't necessarily have to, but it's good practice i think
22:07:22 <jle`> since presumably you'd want to do IO at some point
22:07:26 <isd> Hey all. I'm looking at tagging an 0.3 release of https://hackage.haskell.org/package/capnp. There's a lot of generated code in there, and some modules are really not intended to be imported by humans (particularly the Capnp.ById hierarchy), so I'd like to hide them in the docs. I've got an {-# OPTIONS_HADDOCK hide #-} in the source for the relevant modules, which when I do cabal haddock doesn't generate them as desired. but I tried pas
22:07:26 <isd> sing the options in the script at https://hackage.haskell.org/upload, and the candidate package still lists the modules (though they aren't links): https://hackage.haskell.org/package/capnp-0.3.0.0/candidate. If possible I'd like to avoid the clutter; is there any way to get hackage to just not show those?
22:07:27 <jle`> but yeah the end has to be IO r
22:07:36 <jle`> koz_: i talk about a similar pattern in https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html
22:07:47 <koz_> OK, so the overall type sig is something like getDSM :: T.Text -> (forall n m . (KnownNat n, KnownNat m) => DataSetMeta n m -> IO r) -> IO r?
22:07:55 <koz_> Oh, cool, I'll read that.
22:07:58 <jle`> mhm
22:09:13 <jle`> the alternative would be (... -> r) -> IO r, but i think it's better to (... -> IO r) -> IO r
22:09:25 <jle`> because the former can be implemented using the latter
22:10:01 <jle`> there's some nice symmetry too
22:10:22 <jle`> `(... -> r) -> r` actually fits the Cont pattern, and `(... -> IO r) -> IO r` fits the ContT IO pattern, actually
22:10:33 <koz_> I had the feeling you'd mention Cont somewhere.
22:10:46 <jle`> yeah, the first is essentially Cont and the second is ContT IO
22:11:13 <koz_> Would it be a good idea for me to use ContT IO like that? Or should I be doing something with MonadCont from mtl instead?
22:11:23 <koz_> I don't foresee needing anything else in the monadic stack.
22:11:23 <jle`> it's not possible to use Cont/ContT because of the RankN type
22:11:27 <koz_> :(
22:11:29 <jle`> it's just in the same spirit
22:11:36 <jle`> i know :/
22:12:04 <jle`> it just roughly fits the same shape, Cont r a = (a -> r) -> r
22:12:05 <koz_> I guess ContT requires something like (a -> r) -> r instead of (forall a . a -> r ) -> r?
22:12:08 <koz_> Ah.
22:12:10 <jle`> and here we have (forall a. a -> r) -> r
22:12:13 <jle`> so the a is "hidden"
22:12:35 <koz_> So you can't have ContT, since that's parameterized over said a, right?
22:12:38 <jle`> ContT IO r a is (a -> IO r) -> IO r, and here we have (forall a. a -> IO r) -> IO r
22:12:56 <jle`> yeah, it's sort of like `exists a. ContT IO r a`
22:13:18 <jle`> but that's not a very useful type in practice because it doesn't have its useuful Monad, Functor, Applicative, etc. instances
22:13:29 <jle`> which is the reason why we use Cont/ContT newtype in the first place
22:15:54 <koz_> jle`: OK, I've gotten this far: https://lpaste.net/8463801826402107392
22:16:23 <koz_> I'm guessing I have to do some pattern matching on SomeNats to pull out appropriate Proxies, but I'm not sure how I go from there.
22:18:11 <jle`> koz_: once you get your result, you feed f to it
22:18:23 <jle`> f (the DataSetMeta n m)
22:18:38 <jle`> er, feed it to f
22:18:48 <koz_> Yeah, but how do I get a DataSetMeta n m with the correct n and m based on what I fish out of the database?
22:19:16 <koz_> In particular, DataSetMeta requires a Data.Vector.Sized.Vector m T.Text to be constructed first.
22:19:41 <jle`> ah okay.  how do you want to construct that vector?
22:19:50 <jle`> but yeah, a good next step would be to get the type variable 'm' into scope
22:20:07 <koz_> So I need to grab attributeNum and turn it into a SomeNat.
22:20:12 <koz_> (then pattern match)
22:20:26 <jle`> thanks to do notation you can do something like SomeNat (Proxy :: Proxy m) <- pure $ someNatVal theNumber
22:20:37 <jle`> or otherwise manually pattern and case match yeah
22:20:51 <koz_> Oh you can do that? Woah.
22:22:06 <jle`> it's a cute trick i lean on a bit too much, haha
22:23:36 <jle`> with singletons it'd be SomeSing Sing <- pure $ toSing theNumber
22:24:20 <jle`> er, SomeSing (Sing :: Sing m), or SomeSing (SNat :: Sing m)
22:24:35 <koz_> So I guess with that, I can use fromList from Data.Vector.Sized (and a fromJust)?
22:24:41 <jle`> but also there's a GHC feature in the works that would allow you to do SomeSing (Sing @m) which is kinda cute
22:25:00 <jle`> koz_: that sounds dangerous ....
22:25:06 <jle`> where is the number and list coming from?
22:25:27 <koz_> jle`: attributeNum and tableNames are guaranteed (as far as the database is concerned) to be 'compatible'.
22:25:50 <koz_> (that is, length tableNames == attributeNum)
22:26:08 <koz_> So in this case, it's actually safe.
22:26:58 <jle`> hm sure, i guess so then. assuming you're not using fromJust but giving a proper error message
22:27:09 <koz_> Well, what would be the right way?
22:27:17 <koz_> (as in, non-dangerous?)
22:27:37 <jle`> your database's api would ideally already be type-safe ;)
22:27:43 <koz_> It's SQLite.
22:27:50 <koz_> So yeah, good luck there. :P
22:27:58 <jle`> but then, why even ask for attributeNum ?
22:28:13 <jle`> can't you ignore it?
22:28:15 <koz_> I guess I could just use length tableNames,
22:28:24 <koz_> Since that's what m is.
22:28:33 <isd> Ended up going ahead and publishing it as is. Still interested in a better solution for the next release though, if anyone has ideas.
22:28:48 <jle`> koz_: yeah, but instead of length tableNames, you can just directly use withSized 
22:29:11 <koz_> https://www.stackage.org/haddock/nightly-2018-09-23/vector-sized-1.0.4.0/Data-Vector-Sized.html#v:withSized <-- this one here?
22:29:11 <jle`> or withSizedList
22:29:19 <koz_> Yeah, I was thinking withSizedList.
22:29:30 <jle`> yeah, withSizedList :: [a] -> (forall a. KnownNat n => Vector n a -> r) -> r
22:29:47 <koz_> So how would I use it in this case?
22:30:04 <koz_> I have tableNames, whose length I want to become the 'm' in the resulting DataSetMeta.
22:30:24 <jle`> withSizedList tableaNames $ \tableNamesVec ->
22:30:25 <jle`>     ...
22:30:33 <koz_> Oh, I see.
22:30:59 <koz_> So you basically just say 'supposing you have such a vector, do this to it, whatever its size'.
22:31:01 <jle`> the m is already in tableNamesVec, you don't have to work with it manually
22:31:07 <jle`> mhm
22:32:15 <jle`> you'll start to see that this (.. -> r) -> r, etc. pattern chains pretty well
22:32:17 <koz_> How would I write this inside my do-block though? I need a DataSetMeta n m -> IO r, and this doesn't quite give me the type I want.
22:32:40 <koz_> Oh wait never mind.
22:32:43 <jle`> koz_: no, that's the type that the user gives you
22:32:52 <jle`> you just have to give it the DataSetMeta n m, to get the IO r
22:34:06 <jle`> it's the 'double negative' game, heh
22:34:31 <jle`> in (X -> Y) -> Z, the (X -> Y) is in the negative position, so X is actually in the positive position
22:34:57 <koz_> So something like: https://lpaste.net/6312523076579885056 ?
22:35:18 <koz_> (except unsure how to go from here)
22:35:42 <jle`> you can just put 'f' in that _
22:35:52 <koz_> Oh wait that works?
22:36:08 <koz_> OK, that makes sense.
22:36:21 <koz_> Now I just have to do a proof that exampleNum ~ n or so.
22:36:22 <jle`> yeah, that's how writing these continuation-style functions work; your rseult is the user's callback function applied to the value you create
22:36:48 <jle`> oh i guess you also need to give what @n is
22:37:03 <jle`> yeah, you'd probably have to write f @n (DataSetMeta c tableVec)
22:37:27 <jle`> getting n the SomeNat way
22:37:41 <koz_> Yay, it works!
22:37:49 <jle`> :D
22:38:05 <koz_> OK, that makes sense, despite being a bit different to think about.
22:38:42 <jle`> yeah, you're getting used to writing continuation-style, which isn't exclusive to this dependent typed stuff, people write this way in normal contexts too, we're just not used to it in haskell
22:39:16 <koz_> Well, final getDSM is four lines sans type sig.
22:39:17 <jle`> you could also switch to wrapped-existential style as well, which is more 'tradtionally haskell' i suppose
22:39:26 <koz_> What would that look like?
22:39:45 <jle`> well you'd write a wrapper over DataSetMeta that hides the type variables
22:40:13 <koz_> So something like ExistentialDSM = forall n m . EDSM etc etc?
22:40:18 <koz_> And then give back one of them?
22:40:26 <jle`> like data SomeDSM = forall n m. (KnownNat n, KnownNat m) => SomeDSM -> DataSetMeta n m
22:40:36 <koz_> Ah, you need constraints of course.
22:40:37 <jle`> getDSM :: T.Text -> IO SomeDSM
22:40:44 <cppxor2arr> how do i make "parseMaybe parser" return "Maybe Text" instead? https://paste.fedoraproject.org/paste/YpYxJDVjLwIhb7dx7GC2ZQ
22:40:52 <jle`> * forall n m (KnownNat n, KnownNat m) => SomeDSM (DataSetMeta n m)
22:41:30 <jle`> cppxor2arr: what does it return currently?
22:41:32 <koz_> I think I'll try the continuation-driven one. It's probably something I need to get used to.
22:41:36 <cppxor2arr> jle`: Maybe String
22:42:43 <jle`> cppxor2arr: you could fmap T.pack
22:42:47 <jle`> the result
22:42:57 <jle`> :t fmap T.pack :: Maybe String -> Maybe T.Text
22:42:58 <lambdabot> error:
22:42:58 <lambdabot>     Not in scope: ‘T.pack’
22:42:58 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
22:43:12 <cppxor2arr> jle`: is there a more generalized version of "many" or a Text version?
22:44:16 <jle`> generalized in what way?
22:44:34 <jle`> ah yeah hm, the best way would probably just T.pack <$> many theThing
22:44:48 <cocreature> many (satisfy …) can be replaced by takeWhileP
22:44:50 <cppxor2arr> ok
22:44:59 <cocreature> which will be significantly more efficient and will give you back a Text
22:45:34 <cocreature> anySingle = satisfy (\_ -> True)
22:45:56 <cocreature> although you probably don’t want to use "many anySingle" unless you want to consume the remainder of your parse input
22:46:52 <cppxor2arr> yeah i was playing around
22:55:29 <cppxor2arr> what's the "Maybe String" (Name for a single token in a row) for? can i somehow reference the token with the name?
22:55:39 <cppxor2arr> in takeWhileP
22:56:44 <cocreature> cppxor2arr: for error messages
22:56:51 <cppxor2arr> oh ok
23:41:10 <cheater> hi
23:41:17 <olligobber> hi
23:41:19 <cheater> how long is icfp & co going to continue for?
23:41:33 <cheater> when do all the ancillary events end?
23:42:01 <trcc> Woaw, I haven't really used semaphores in java for quite some time. Now I am using it, and I have no idea what is executed when
23:42:13 <trcc> release one here, something over there executes etc
23:42:18 <trcc> a complete mess
23:43:06 <dminuoso> trcc: That's a usage problem, not a problem of semaphores or Java.
23:43:17 <trcc> dminuoso: I am well aware
23:43:23 <trcc> but seems to happen more often than not
23:43:31 <bahamas> hello. I have this code https://lpaste.net/614956561357340672. the print shows that key returns a list that contains an Array. is there a way to get that Array directly without the list?
23:43:54 <dminuoso> trcc: One issue may be that semaphores are too often mentioned when talking about concurrency. They are great *primitives* to built abstractions upon.
23:44:03 <dminuoso> But they rarely serve well when used in higher level code to "synchronize things"
23:44:31 <cocreature> bahamas: you can use ^? instead of ^.. which will give you back a Maybe instead of a list
23:44:41 <trcc> dminuoso: sometimes it is an easy fix to make a new feature work without changing too much code. Which it is in this case. Quick feature 
23:44:59 <cocreature> or if you are really sure that the key exists you can use ^?! which will crash if the key doesn’t exist
23:45:52 <bahamas> cocreature: the key should be there, but I'd rather not crash, just in case someone did something wrong with the file
23:45:58 <koz_> jle`: I'm stuck again trying to work with my data: https://lpaste.net/1738665807245737984
23:46:17 <koz_> (ClassAttribute n is a newtype around a sized Vector of Word8s)
23:46:26 <bahamas> cocreature: what can I read to become more familiar with lens?
23:48:21 <cocreature> bahamas: https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html is probably a good start. however, lens-aeson goes a bit beyond the basic lens knowledge that this will teach you. I mostly picked up the more advanced stuff gradually when I needed it instead of reading a tutorial
23:48:55 <bahamas> cocreature: yeah, I found that tutorial but it didn't help much in this case. alright, I'll just wing it for now
23:49:52 <bahamas> cocreature: btw, regarding my task. my goal is to check if the array contains a string. if it doesn't, I want to add the string while preserving alphabetical order. is there a lens way to do this or should I just do it "by hand"?
23:51:26 <cocreature> bahamas: I would use lens to get to the array and then use "modify" on that array and do the “check if array contains string & if not insert”-part by hand
23:55:35 <bahamas> cocreature: alright. thanks!
