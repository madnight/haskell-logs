00:28:34 * hackage lambda-calculus-interpreter 0.1.0.3 - Lambda Calculus interpreter  http://hackage.haskell.org/package/lambda-calculus-interpreter-0.1.0.3 (xeontem)
00:38:17 <mniip> a "library" with exposed-modules: Lib, Parser, Utils;  huh
00:40:20 <Axman6> sounds like someone's school project
00:41:28 <cocreature> clearly it’s missing the Types module
01:01:11 <Taneb> :D
01:19:35 * hackage shakespeare 2.0.16 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.16 (MichaelSnoyman)
01:20:53 <tazjin> is it possible to configure intero (the emacs mode) to pass certain options to ghci when starting it up? Specifically I'm trying to set `fno-defer-out-of-scope-variables`, but putting it in a `.ghci` file seems to have no effect (despite ghci logging that it's loading it)
01:21:04 * hackage shakespeare 2.0.17 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.17 (MichaelSnoyman)
01:21:19 <tazjin> (without that option GHC logs a panic when trying to print certain values on 8.4.3)
01:25:21 <tazjin> additionally, is there a way to list all options that are set in an active ghci session?
01:37:11 <maerwald> what are the major advantages for updating from ghc 8.2.2 to 8.4.3?
01:37:23 <maerwald> did compile time get better?
01:39:15 <jose_zap> maerwald https://ghc.readthedocs.io/en/latest/8.4.1-notes.html
01:39:27 <jose_zap> if it got faster, I did not notice
02:01:13 <delYsid> maerwald: I noticed executable size going down a bit.  My hakyll site binary is roughly 700k smaller.
02:03:49 <maerwald> the Semigroup constraint on Monoid is quite annoying, causing a lot of compile failures in deps
02:13:46 <merijn> It'll pass, like AMP
02:16:37 <maerwald> seems most libraries don't really provide upgrade instruction when they break their API
02:17:09 <maerwald> conduit removed ResumableSource, but... that's it. No deprecation phase even
02:26:34 * hackage docker-build-cacher 2.1.0 - Builds a services with docker and caches all of its intermediate stages  http://hackage.haskell.org/package/docker-build-cacher-2.1.0 (lorenzo)
02:33:13 <merijn> bleh...too bad the MonadUnliftIO exception stuff isn't in unliftio-core :\
02:37:47 <sshine> why, when I have {-# LANGUAGE RebindableSyntax #-} at the top of my source file, does it say that String and Maybe are not valid type constructors? I'm not using the GHC extension, I merely enabled it.
02:38:25 <merijn> sshine: That sounds unrelated, tbh. paste a minimal file with the issue?
02:40:13 <cocreature> sshine: RebindableSyntax implies NoImplicitPrelude
02:40:17 <sshine> https://gist.github.com/sshine/5409b91ec3bcaba1a256bc5da83dd491
02:40:18 <sshine> cocreature, ah!!
02:40:20 <cocreature> so you need to import String and Maybe from somewhere
02:41:02 <sshine> cocreature, thanks.
02:49:46 <fendor> is there library to convert a record a to b and vice versa, if a is a flat representation of b?
02:57:14 <jle`> fendor: can you give an example
02:58:46 <fendor> jle`, i have a dto `Dto { a :: Text, b :: Text}` and i want something like `Model {a :: Text, c :: M { b :: Text } }`
02:59:22 <jle`> what is that second thing supposed to be
02:59:41 <jle`> @let data Foo1 = Foo1 Int Double
02:59:42 <fendor> jle`, its just a nested representation
02:59:43 <lambdabot>  Defined.
02:59:47 <jle`> @undefine
02:59:47 <lambdabot> Undefined.
02:59:55 <jle`> @let data Foo1 = Foo1 Int Double deriving (Show, Generic)
02:59:56 <lambdabot>  .L.hs:159:27: error:
02:59:56 <lambdabot>      Not in scope: type constructor or class ‘Generic’
02:59:56 <lambdabot>      |
03:00:02 <jle`> @let import GHC.Generics
03:00:03 <lambdabot>  Defined.
03:00:05 <jle`> @let data Foo1 = Foo1 Int Double deriving (Show, Generic)
03:00:06 <lambdabot>  Defined.
03:00:16 <jle`> @let data Foo2 = Foo2 Int Double deriving (Show, Generic)
03:00:18 <lambdabot>  Defined.
03:00:29 <cocreature> I don’t know any existing lib for that but TH or generics should help
03:00:59 <fendor> they probably can, but it is too much work to write custom TH
03:01:02 <jle`> @let foo1to2 :: Foo1 -> Foo2; foo1to2 = to . from
03:01:03 <lambdabot>  .L.hs:166:11: error:
03:01:03 <lambdabot>      Ambiguous occurrence ‘to’
03:01:03 <lambdabot>      It could refer to either ‘Lens.to’,
03:01:10 <jle`> @let import GHC.Generics as Generic
03:01:12 <lambdabot>  Defined.
03:01:18 <jle`> @let foo1to2 :: Foo1 -> Foo2; foo1to2 = Generic.to . Generic.from
03:01:20 <lambdabot>  .L.hs:167:24: error:
03:01:20 <lambdabot>      • Couldn't match type ‘"Foo1"’ with ‘"Foo2"’
03:01:20 <lambdabot>        Expected type: Foo1
03:01:51 <jle`> hm that was supposed to work
03:03:41 <jle`> oh i see
03:03:54 <jle`> the metadata doesn't match
03:04:11 <int-e> :t Generic.to
03:04:13 <lambdabot> Generic a => Rep a x -> a
03:04:43 <jle`> the problem is the Metadata constructor
03:04:58 <jle`> *constructor metadata
03:05:46 <int-e> Well the immediate problem is that "Rep a x" mentions the type "a" of what's being encoded.
03:05:48 <jle`> hm, you could do it if you strip the metadata and re-add it.  the generics-sop library actually does this
03:06:05 <jle`> int-e: yeah, but it would work if Rep a x ~ Rep a c
03:06:11 <jle`> :t Generic.to . Generic.from
03:06:12 <lambdabot> (Rep a ~ Rep c, Generic a, Generic c) => a -> c
03:06:17 <cocreature> int-e: Rep is a type family, as long as both resolve to the same thing that’s fine
03:06:20 <jle`> it doesn't require that a ~ c
03:06:23 <cocreature> the problem is that due to metadata they don’t
03:06:42 <cocreature> but either way it won’t help you with flattening a record
03:06:58 <kosmikus> with metadata, they'd still be coercible into each other
03:07:21 <jle`> the problem is that the two metadatas have different types
03:07:22 <int-e> cocreature: ah. thanks for making me feel stupid, I should've checked that
03:07:34 <jle`> the type of the metadata of Foo1 is different than the type of the metadata from Foo2
03:07:43 <int-e> (or, quite possibly, known)
03:07:45 <kosmikus> jle`: yes, but as I said, they're Coercible
03:08:00 <jle`> ah i see, capital-C coercible
03:08:12 <kosmikus> yes, sorry
03:08:40 <jle`> oh hey, it works :O
03:08:41 <cocreature> int-e: no worries, we all forget things constantly :)
03:08:56 <jle`> % data Foo1 = Foo1 Int Double deriving (Show, Generic)
03:08:56 <yahb> jle`: ; <interactive>:11:45: error: Not in scope: type constructor or class `Generic'
03:09:06 <jle`> % import GHC.Generics as G
03:09:06 <yahb> jle`: 
03:09:08 <jle`> % data Foo1 = Foo1 Int Double deriving (Show, Generic)
03:09:08 <yahb> jle`: ; <interactive>:13:45: error:; * Can't make a derived instance of `Generic Foo1': You need DeriveGeneric to derive an instance for this class; * In the data declaration for `Foo1'
03:09:16 <jle`> er, you'll just have to trust me :)
03:09:37 <jle`> if we do foo1to2 :: Foo1 -> Foo2; foo12 = G.to @Foo2 . coerce . G.from @Foo1
03:10:06 <jle`> % :set -XDeriveGeneric -XTypeApplications
03:10:06 <yahb> jle`: 
03:10:11 <cocreature> or just unsafeCoerce
03:10:13 <jle`> % data Foo1 = Foo1 Int Double deriving (Show, Generic)
03:10:13 <yahb> jle`: 
03:10:13 * cocreature runs away
03:10:19 <jle`> % data Foo2 = Foo2 Int Double deriving (Show, Generic)
03:10:20 <yahb> jle`: 
03:10:44 <jle`> % import Data.Coerce
03:10:44 <yahb> jle`: 
03:10:58 <jle`> % let foo12 :: Foo1 -> Foo2; foo12 = to @Foo2 . coerce . from @Foo1
03:10:58 <yahb> jle`: ; <interactive>:18:36: error:; Ambiguous occurrence `to'; It could refer to either `G.to', imported from `GHC.Generics'; or `Control.Lens.to', imported from `Control.Lens' (and originally defined in `Control.Lens.Getter'); <interactive>:18:56: error:; Ambiguous occurrence `from'; It could refer to either `G.from', imported from `GHC.Generics'; 
03:11:08 <jle`> % let foo12 :: Foo1 -> Foo2; foo12 = G.to @Foo2 . coerce . G.from @Foo1
03:11:09 <yahb> jle`: 
03:11:16 <jle`> % foo12 (Foo1 7 10.3)
03:11:16 <yahb> jle`: Foo2 7 10.3
03:11:17 * cocreature applauds
03:11:31 <jle`> good night yall :)
03:11:43 <jle`> should work if they are records too
03:11:43 <fendor> its actually noon
03:11:53 <jle`> i mean, good night as in i'm going to bed :)
03:12:04 <fendor> hehe, good night ;)
03:13:19 <ph88> is it possible to make let binding in hamlet ?
03:23:32 <jle`> would be ironic if you couldn't, given the name
03:28:52 <maerwald> where did "stimes" of Semigroup go?
03:29:15 <Axman6> @hoogle stimes
03:29:16 <lambdabot> Data.Semigroup stimes :: (Semigroup a, Integral b) => b -> a -> a
03:29:16 <lambdabot> ClassyPrelude stimes :: (Semigroup a, Integral b) => b -> a -> a
03:29:16 <lambdabot> GitHub.Internal.Prelude stimes :: (Semigroup a, Integral b) => b -> a -> a
03:29:29 <Taneb> maerwald: Data.Semigroup
03:29:34 <Taneb> It hasn't moved
03:34:23 <maerwald> right, it's just not in Prelude
03:34:33 <maerwald> I find that confusing
03:34:50 <maerwald> making half of a class available in Prelude, the other half somewhere else
03:39:18 <maerwald> stack keeps unregistering 4 packages on every build lol
03:39:33 <maerwald> and then builds them again
03:41:30 <MarcelineVQ> are they git or local packages?
03:43:17 <maerwald> neither
03:48:19 <Axman6> are they packages mentioned in you stack.yaml file?
03:55:05 * hackage rocksdb-query 0.1.2 - RocksDB database querying library for Haskell  http://hackage.haskell.org/package/rocksdb-query-0.1.2 (xenog)
04:03:51 <maerwald> no
04:09:23 <fendor> how can I efficiently prepend some text in a file?
04:15:34 * hackage rocksdb-query 0.1.3 - RocksDB database querying library for Haskell  http://hackage.haskell.org/package/rocksdb-query-0.1.3 (xenog)
04:18:04 * hackage pretty-show 1.8.2 - Tools for working with derived `Show` instances and genericinspection of values.  http://hackage.haskell.org/package/pretty-show-1.8.2 (IavorDiatchki)
04:22:34 * hackage rocksdb-query 0.1.4 - RocksDB database querying library for Haskell  http://hackage.haskell.org/package/rocksdb-query-0.1.4 (xenog)
04:25:21 <Axman6> fendor: most file systems don't have a way to do that efficiently afaik
04:25:55 <hc> Axman6: which ones do?
04:26:06 <Axman6> none that I know of :)
04:26:38 <hc> fendor: what are you trying to achieve?
04:29:46 <fendor> hc, i just want to prepend a string to file that will potentially grow large in size. Often I have to read the most recent line.
04:31:37 <hc> fendor: will it be prepend only? or are you also going to append?
04:31:45 <hc> also, what is the purpose of the operation?
04:31:53 <hc> perhaps it can be implemented by some other means?
04:34:43 <suzu> how large is large in size?
04:34:52 <suzu> are you okay with loading the entire contents into memory every time you prepend?
04:35:35 * hackage rfc1751 0.1.0 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/rfc1751-0.1.0 (xenog)
04:37:04 * hackage constrained-categories 0.3.1.1 - Constrained clones of the category-theory type classes, using ConstraintKinds.  http://hackage.haskell.org/package/constrained-categories-0.3.1.1 (leftaroundabout)
04:38:05 * hackage rfc1751 0.1.1 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/rfc1751-0.1.1 (xenog)
04:39:18 <dmwit> fendor: I note that the goal "I have to read the most recent line" could also be achieved by appending instead. Most filesystems support efficient appending to files.
04:39:57 <fendor> hc, yes it would only prepend.
04:40:00 <hc> dmwit: which ones don't? ;)
04:40:12 <hc> fendor: well in that case, you can do it as dmwit suggests
04:40:25 <fendor> suzu, unknown, but i would rather want to avoid loading into memory
04:40:38 <fendor> dmwit, can i also read efficiently the last line?
04:40:43 <dmwit> hc: none that I know of :)
04:40:51 <MarcelineVQ> be sneaky, be the sneakiest, write a new file each write and concat them when the program ends
04:41:26 <fendor> MarcelineVQ, while a sneaky attempt, it is a server application that should rarely shutdown :P
04:41:31 <dmwit> fendor: Pretty efficiently. You can seek to the end of the file, and gradually work your way backwards in larger and larger chunks until you find the line terminator.
04:41:37 <MarcelineVQ> amortize that action like some terrible monster
04:41:47 <hpc> write a FUSE driver that writes files to disk in reverse
04:41:54 <hpc> :P
04:41:59 <MarcelineVQ> sever app? db?
04:42:00 <fendor> ok, maybe my use case is unclear, i want to add content and i want to read the latest content, both happens frequently
04:42:10 <hc> fendor: then it's even easier
04:42:18 <hc> fendor: just keep reading beyond the end of the file
04:42:19 <fendor> Servant App
04:42:36 <dmwit> I maintain my position.
04:42:42 <suzu> why don't you append rather than prepend?
04:42:43 <dmwit> Append to add content, seek backwards from the end to read content.
04:42:47 <suzu> ^ this
04:42:59 <Axman6> yeah definitely that
04:43:05 <suzu> prpeending requires you to "push" everything over
04:43:09 <suzu> prepending*
04:43:14 <fendor> if this is efficient, i will do that :) 
04:43:28 <fendor> then how do i seek in haskell? :D 
04:43:35 <dmwit> fendor: Alternatively: append content, and keep a second file which only has the latest data. No seek shenanigans needed, plus efficiently store a log of all content.
04:43:40 <Axman6> hSeek or something?
04:43:44 <Axman6> @hoogle seek
04:43:44 <lambdabot> GHC.IO.Device seek :: IODevice a => a -> SeekMode -> Integer -> IO ()
04:43:44 <lambdabot> Control.Comonad.Store seek :: ComonadStore s w => s -> w a -> w a
04:43:44 <lambdabot> Control.Comonad.Store.Class seek :: ComonadStore s w => s -> w a -> w a
04:43:45 <hpc> fendor: it's how every log file has worked for the past 60 years ;)
04:43:49 <Axman6> @hoogle hseek
04:43:50 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
04:43:50 <lambdabot> GHC.IO.Handle hSeek :: Handle -> SeekMode -> Integer -> IO ()
04:43:50 <lambdabot> Sound.File.Sndfile hSeek :: Handle -> SeekMode -> Count -> IO Count
04:44:02 <hc> hpc: except journald ones, I think
04:44:27 <fendor> dmwit, that approach sounds promisisng as well...
04:44:30 <suzu> use SeekFromEnd as your seekmode
04:44:31 <hpc> journald logs work the same, they're just binary
04:44:35 <Axman6> also, alternative, and possibly safer suggestion: use sqlite
04:44:36 <suzu> with a distance of 0
04:44:39 <MarcelineVQ> with prior art in mind is there a lib he could use to streamline this particular need?
04:44:49 <suzu> yes, a database
04:44:51 <hc> hpc: aren't they also indexed? I thought journald works more like a db than a regular log file
04:45:02 <MarcelineVQ> I already said db, you guys are cribbing my cool :>
04:45:06 <suzu> oh hehe
04:45:09 * suzu ducks
04:45:31 <fendor> yeah, suzu, i like YOUR idea about a databse
04:45:38 <Axman6> oi!
04:45:51 <Axman6> sqlite was my idea!
04:46:03 <fendor> no, a database is not applicable because it some proof of concept abomination that should not use a sql database
04:46:14 <fendor> i was joking :D 
04:46:28 <MarcelineVQ> sqlite is a file based db, it's quite useful for concept abominations
04:46:37 <dmwit> Honestly, for a first pass, `appendFile log newData >> writeFile latest newData` should be fine for writing and `readFile latest` should be fine for reading (maybe with some code to force the results of the read). No real need for a library, I think.
04:46:43 <hpc> MarcelineVQ: tail -f?
04:47:09 <Axman6> dmwit: atomicity?
04:47:28 <dmwit> Then again, I think I'd probably only `readFile` once at program startup and just keep the latest data in an MVar or something.
04:47:46 <MarcelineVQ> hpc that's neat
04:48:31 <fendor> dmwit, i need the latest data of a whole filesystem, for each file, there is a metadata file that contains metadata and i want to be able to read the latest metadata
04:48:41 <fendor> of each file
04:49:02 <Axman6> if you need to do anything more than just read the most recently written data, which an MVar or IORef would be sufficient for, then sqlite is definitely much saner han trying to make your own ghetto database using a file
04:49:05 <maerwald> yeah, stack unregisters and rebuilds groom, haskell-src-exts, haskell-src-meta and interpolatedstring-perl6 over and over again
04:49:22 <Axman6> fendor: sounds like a database to me ;)
04:49:32 <maerwald> and those are quite slow to build
04:49:42 <suzu> yeah keep in mind as you implement this you will make bugs and such that will take time to investigate
04:49:51 <suzu> it may be "faster" to just throw sqlite at it and move on
04:49:55 <fendor> Axman6, it kind of is, but I am the poor fella that has to implement some alternative idea, because the sql solution has performance issues ^^
04:50:06 <dmwit> Axman6: What's that?
04:50:09 <Axman6> fendor: have you used sqlite?
04:50:21 <Axman6> dmwit: touche
04:51:00 <Axman6> https://www.sqlite.org/whentouse.html
04:51:23 <merijn> fendor: Which SQL solution?
04:51:23 <dmwit> uh
04:52:19 <fendor> Axman6, i havent used anything, I just have to implement a prove of concept backend solution based on git :P 
04:52:21 <merijn> fendor: With the questions you're asking right now I think it's doubtful that whatever you're going to implement yourself is going to perform better than SQLite
04:52:24 <fendor> merijn, of some company
04:52:33 <fendor> merijn, i dont think so either
04:52:36 <dmwit> I'm sure you and your coworkers have more information than me about this, but a priori "This SQL database is too slow, I'm gonna make my own database with blackjack and hookers" sounds kinda dumb to me.
04:52:38 <Axman6> "Many programs use fopen(), fread(), and fwrite() to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these ad hoc data files. Contrary to intuition, SQLite can be faster than the filesystem for reading and writing content to disk."
04:53:20 <Axman6> there are libraries for interacting with git
04:53:21 <fendor> dmwit, yeah, to me, too, but here i am
04:53:57 <dmwit> There's gotta be an extra sentence in there like, "and here's the specific guarantees of the SQL database that we don't care about and are going to relax" for that to make sense.
04:54:40 <fendor> dmwit, i fear, there is not really an extra sentence that i know of
04:55:07 <cocreature> obviously all people writing sql dbs are just stupid and you are going to do much better than them!
04:55:25 <hpc> dmwit: i heard they're getting better, but historically sqlite has been extremely not ACID
04:55:26 <suzu> yeha fuck dbs
04:55:34 <suzu> abuse the filesystem
04:55:35 <dmwit> Perhaps it would behoove you to spend a few hours discussing this with the folks that are asking you to do this.
04:55:45 <fendor> cocreature, i dont think so, but my superior thinks that we can do it better somehow
04:55:56 <suzu> ask them how
04:55:57 <hpc> i quite like relational databases though, sql is one of the most expressive DSLs i have ever used
04:56:03 <cocreature> fendor: ask your superior to explain why they think that :)
04:56:15 <suzu> your superior sounds like mine and i'm quitting in a month
04:56:21 <fendor> suzu, haha, same :D 
04:56:25 <suzu> :P
04:56:40 <fendor> but I just quit because i wanna finish uni
04:57:01 <suzu> nah i quit because i'm tired of dealing with their incompetence
04:57:14 <suzu> using haskell at work is neat, but everything around me is melting and on fire all the time
04:57:31 <suzu> if y'all got any of them startup ideas..
04:57:34 <fendor> cocreature, i talked to him about it, but i agree at some point I am just like, I dont know their software well enough and their problems, so, i suppose ill try to implement his idea
04:58:04 * hackage docker-build-cacher 2.1.1 - Builds a docker image and caches all of its intermediate stages  http://hackage.haskell.org/package/docker-build-cacher-2.1.1 (lorenzo)
04:58:52 <Taneb> suzu: whereabouts are you based? I'm work for a company that uses Haskell heavily that's hiring in Cambridge, UK
04:59:11 <dmwit> suzu: Galois is hiring.  https://galois.com/careers/
04:59:19 <suzu> based in Toronto, Canada and San Francisco, USA
04:59:33 <Axman6> Taneb: which company?
04:59:46 <suzu> i'm not sure i'm really interesting in pursuing yet another job tbh
04:59:51 <Taneb> Axman6: Myrlte ( https://www.myrtle.ai/ )
04:59:53 <suzu> interested*
05:00:37 <Taneb> Axman6: we write compilers from neural network specifications to hardware description languages
05:00:49 <suzu> that's pretty neat
05:01:20 <Axman6> Taneb:  very cool. Wasn't... Lee Pike or someone working on something similar?
05:02:05 <Axman6> hmm, no, who was it
05:02:21 <Taneb> Axman6: googling Lee Pike, it seems he is doing something similar, but I'm not personally aware of details
05:02:22 <Axman6> I was interested in applying for a job with them but being in the US made it pretty unappealing
05:02:30 <merijn> hmmm, I need a better way to linewrap long function in "foo <- someLong fun expr here"
05:02:32 <suzu> loll
05:02:36 <merijn> Any opinions?
05:02:41 <Axman6> oh it was him, Groq
05:02:47 <suzu> foo <-\n\t someLong fun expr here
05:02:49 <Taneb> Axman6: if the UK's any better, apply here! :D
05:03:01 <dmwit> merijn: I like `foo <- someLong\n\tfun\n\texpr\n\there`.
05:03:05 <merijn> suzu: Yeah, that's what I did, except then it's still too long :)
05:03:07 <Axman6> Taneb: it's definitely more appealing.
05:03:14 <suzu> break the args with \n\t like dmwit suggested
05:03:20 <Axman6> Australia's a pretty great place to live though
05:03:32 <suzu> there's no right to remain silent in the UK y'all
05:03:36 <suzu> dealbreakkerr
05:03:56 <Taneb> Axman6: oh yeah, I've got relatives in Melbourne, it's really nice
05:04:19 <Axman6> Melbourne's ok I guess, better than Sydney
05:04:28 <Axman6> Canberra's where it's at though
05:04:37 <Taneb> suzu: I'm pretty sure there is... but that's getting off topic
05:04:45 <Taneb> Axman6: I've never been to Canberra, I'd love to visit
05:04:54 <suzu> I have been to canberra! it is boring af
05:05:03 <Axman6> you're boring af
05:05:04 <suzu> the design of the city is neat though. bunch of rings
05:05:25 <Axman6> Canberra does a great job of hiding what's great from the (interstate) immigrants
05:05:26 <suzu> i mean, i went there briefly for work and didn't know anybody, so it can only be so interesting anyway
05:05:52 <Taneb> I've got to go for lunch now
05:05:52 <Axman6> gret food, excellent coffee, near the beach and the snow
05:06:23 <Axman6> Enjoy!
05:20:04 <delYsid> oh, Control.Category.(>>>) plays pretty nice with lens
05:20:35 <Axman6> how so?
05:20:48 <Axman6> :t Control.Category.(>>>)
05:20:50 <lambdabot> error:
05:20:50 <lambdabot>     Not in scope: data constructor ‘Control.Category’
05:20:50 <lambdabot>     Perhaps you meant variable ‘Control.Category.id’ (imported from Control.Category)
05:21:05 * hackage quickcheck-classes 0.4.14.2 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.4.14.2 (andrewthad)
05:21:36 <delYsid> instead of s & ... & ..., I can say ... >>> ...
05:21:56 <Axman6> I like the way & reads
05:22:06 <delYsid> msg t = set status t >>> exitMenu >>> continue
05:22:08 <delYsid> vs
05:22:28 <delYsid> msg t s = s & set status t & exitMenu & continue
05:22:34 <Axman6> a thing and set this to that and modify this with f and set this other thing to that
05:24:22 <cocreature> galaxy brain: msg t = continue . exitMenu . set status t
05:28:33 <cheater> jle`: thanks
05:41:21 <pacak> Is there a way to tell stack to use hackage db and ignore whatever stack prefers to use by default?
05:42:04 * hackage jinquantities 0.1.0 - Unit conversion and manipulation library.  http://hackage.haskell.org/package/jinquantities-0.1.0 (Novadiscovery)
05:42:08 <merijn> pacak: Eh, at that point what's the point of using stack?
05:42:58 <MarcelineVQ> that's somewhat counter to stack's role, you can put the things you want from hackage in extra-deps in your project's stack.yaml
05:43:33 <pacak> merijn: Well, it's a good question, it helps with installing specific version ghc but that's about it.
05:43:37 <cocreature> pacak: what specifically do you mean by that? stack does use the hackage db, it just requires that versions are fixed. either implicitely via your resolver or explicitely via extra-deps
05:44:21 <delYsid> I seem to remember seeing ghc taking more then 100% cpu (threaded...).  Am I imagining things, or how do I make my stack project tell ghc to use more cores?
05:44:44 <pacak> cocreature: I want to use stuff from hackage without listing like half of hackage in extra-deps
05:45:03 <cocreature> so you want stack to do automatic dependency solving?
05:45:15 <cocreature> the only option for that is "stack solver" which never seems to work for me
05:46:17 <dmwit> delYsid: Compile with -threaded, run with +RTS -N
05:46:19 <pacak> cocreature: I see, seems like a typical state of odd features in stack.
05:46:48 <dmwit> delYsid: Oh, I misread, sorry.
05:46:51 <merijn> pacak: I just install GHC via bindist and use cabal, tbh
05:46:57 <sshine> I'm toying around with RebindableSyntax. if I'm doing 'do { guard foo; guard bar; return baz } where (>>) = ...' and I'd like to make 'guard' a part of the implicit (>>), then what do I do? I rewrote it into 'guard foo >> guard bar >> return baz' and reasoned that I want to add 'where (>>) m1 m2 = guard m1 >> m2', but this is wrong.
05:47:16 <sshine> (so yeah, I wanna try and use do-blocks as guards, heh.)
05:47:38 <merijn> pacak: The bindists are the most robust & portable way of doing GHC installs in my experience, and GHC releases aren't *that* frequent that it's problem to do manually
05:48:28 <dmwit> sshine: Presumably you would `do { foo; bar; return baz } where x >> y = {- however you were defining (>>) before -} (guard x) y`.
05:48:34 * hackage jinquantities 0.1.1 - Unit conversion and manipulation library.  http://hackage.haskell.org/package/jinquantities-0.1.1 (Novadiscovery)
05:48:38 <pacak> merijn: Tempted to do the same, just need to explain to other developers...
05:49:45 <MarcelineVQ> If that's an odd feature in stack you're not using stack for its intended purpose, which is fine but using a can opener to open a pickle jar doesn't mean a can opener has odd features :>
05:49:51 <sshine> dmwit, yes!! I actually had a top-level 'composeMaybe = (>>)' because I sorta knew I needed it, but then I couldn't find a place for it.
05:49:55 <sshine> dmwit, woohoo!
05:49:58 <sshine> dmwit, thanks!
05:51:21 <cocreature> pacak: well stack started out with the premise of providing reproducible builds so requiring version pinning is pretty consistent with that goal
06:01:49 <fendor> why does neither turtle nor classy-prelude have appendFile function? 0.o
06:04:00 <cocreature> fendor: https://hackage.haskell.org/package/turtle-1.5.10/docs/Turtle-Prelude.html#v:append
06:06:20 <fendor> yeah, but why does it have a readTextFile and writeTextFile but not appendTextFile?
06:08:36 <Boomerang> fendor: Have a look at `openFile` from `System.IO`. You can specify `AppendMode`
06:08:54 <hexagoxel> fendor: they probably forgot to reexport https://hackage.haskell.org/package/system-fileio-0.3.16.4/docs/Filesystem.html#v:appendTextFile
06:10:06 <hexagoxel> (in the case of turtle. no idea bout classy)
06:10:19 <fendor> hexagoxel, i see, maybe ill open an issue
06:13:05 <gentauro> not to self. Never ever use `undefined` again :|
06:13:16 <gentauro> used a few hours debugging what the hell was wrong ..
06:13:31 <gentauro> not to self = note to self
06:13:39 <merijn> gentauro: Typed holes FTW \o/
06:13:47 <cocreature> gentauro: how do you create a problem using undefined that takes a few hours to figure out? the exception should make it pretty easy to figure out what is wrong, no?
06:14:01 <gentauro> cocreature: no exception what so ever :|
06:14:10 <merijn> cocreature: You have to figure out where the exception is coming from and that it isn't being swallowed
06:14:28 <gentauro> merijn: exactly, working with Maybe hides it totally :|
06:14:37 <Myrl-saki> Okay, um, I'm starting to feel stupid here.
06:14:38 <cocreature> that’s why you shouldn’t catch all exceptions :)
06:14:47 <Myrl-saki> How would you write a textual replace in Haskell?
06:14:54 <merijn> cocreature: True, but also unhelpful ;)
06:14:57 <gentauro> cocreature: I was catching anything, just using bind (>>=)
06:15:09 <Myrl-saki> Maybe use the (a,) monad with splitAt?
06:15:17 <Boomerang> I use `error "My.Module.myFunction: Some hopefully helpful error message but as least easily grepable."` :D
06:15:21 <gentauro> Boomerang: `AppendMode`? How do you handle that with lazy IO?
06:15:44 <merijn> Solution: Don't use lazy IO? :)
06:15:46 <cocreature> gentauro: if you use undefined it throws an exception so either you’ve not used it and in that case it doesn’t cause problems either or you have used it and catched the exception somewhere
06:16:00 <Myrl-saki> Yeah, splitAt doesn't exactly work either.
06:16:12 <sshine> gentauro, why was undefined bad to use? I would have imagined that either I'd get a runtime exception saying something about undefined, and I'd know to look for that, and if it doesn't throw an exception, the bug is related to code other than undefined..
06:16:17 <Boomerang> If you look at the source of `appendTextFile` (which I didn't know about), it uses `AppendMode`. So I'm sure it's safe enough ^^
06:16:44 <merijn> sshine: Then you might leave undefined hanging around to throw an exception at some indefinite point in the future
06:16:49 <sshine> gentauro, did you have a runtime system where exceptions where somehow hidden from stdout/stderr?
06:17:01 <merijn> sshine: better just use typed holes and get a compile time warning about accidentally leaving any in the code
06:17:04 <jose_zap> gentauro you can one of the preludes that mark both error and undefined with a warning when you compile
06:17:08 <sshine> merijn, in Soviet Haskell, undefined is a function!
06:17:19 <jose_zap> that way is ok to use it during development, but will get a visible error when compiling
06:17:36 <merijn> jose_zap: Why not typed holes?
06:17:53 <jose_zap> type holes are also great :)
06:17:55 <gentauro> cocreature: the exact problem was that i inferred my type in case of a flag: `(flag,key@Key b1 b2 b3 b4) = case mkey of Just k -> (True, k) Nothing -> (False, undefined)
06:18:00 <gentauro> that is the exact code
06:18:28 <Myrl-saki> Maybe NonEmpty 
06:18:34 <merijn> jose_zap: typed holes do everything undefined does, except better :)
06:18:36 <gentauro> when no key, cos I had a deconstructed type
06:18:37 <hexagoxel> (writing to files is never lazy)
06:18:40 <Taneb> Aww, I can't put an annotation on an imort
06:18:41 <Taneb> *mport
06:18:45 <gentauro> it "crashed" but didn't throw an exception
06:18:49 <Taneb> **import (what is wrong with my hands today)
06:19:59 <gentauro> I solved it by: `(flag,key) = case mkey of Just k -> (True, k) Nothing -> (False, undefined)` and then just `if flag then let Key b1 b2 b3 b4 = key in ...`
06:20:31 <gentauro> trying to solve type holes with math is always not straightforward in Haskell (I can see)
06:20:58 <gentauro> specially if runtime doesn't thrown an exception :|
06:21:27 <merijn> gentauro: Just replace "undefined" with "_"
06:21:52 <gentauro> Do any of you know if SPJ though of VB `on error resume next` when he designed the language?
06:22:20 <Boomerang> gentauro: If you're going to replace undefined with a default value: flag = isJust mkey; key = fromMaybe defaultvalue mkey :)
06:22:29 <gentauro> merijn: that isn't going to work ;)
06:22:35 <merijn> gentauro: Why not?
06:22:48 <gentauro> % foo 1 = 2; foo n = _
06:22:51 <yahb> gentauro: ; <interactive>:1:1: error:; GHC internal error: `Ghci5.it' is not in scope during type checking, but it passed the renamer; tcl_env of environment: [roJQ :-> Identifier[foo::forall a p. (Eq a, Num a, Num p) => a -> p, TopLevelLet]]
06:22:56 <gentauro> merijn: see above
06:23:01 <merijn> What's the problem?
06:23:18 <merijn> Unless your GHC is prehistoric it has typed hole support
06:23:41 <Myrl-saki> Is there a :: NonEmpty a -> [a]?
06:24:05 <merijn> Myrl-saki: toList? :p
06:24:10 <gentauro> merijn: is this prehistoric? https://www.stackage.org/lts-12.00 
06:24:14 <Taneb> :t toList
06:24:15 <lambdabot> error:
06:24:16 <lambdabot>     Ambiguous occurrence ‘toList’
06:24:16 <lambdabot>     It could refer to either ‘F.toList’,
06:24:18 <Myrl-saki> Thanks.
06:24:26 <electrocat> Data.List.NonEmpty toList :: NonEmpty a -> [a]
06:24:38 <merijn> gentauro: Works fine in GHC 8.4 (and really i think everything after 7.2 or so)
06:24:47 <Taneb> So yeah, there's Data.List.NonEmpty.toList and Data.Foldable.toList which'll both work, Myrl-saki
06:25:07 <electrocat> dont forget the OverloadedLists toList
06:25:09 <electrocat> :p
06:25:30 <Myrl-saki> areistarotenra
06:25:31 <merijn> electrocat: That'd be "fromList", no?
06:25:42 <Myrl-saki> I just realized that my code doesn't type-check, ffs.
06:26:04 <electrocat> merijn: https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#v:toList
06:26:06 <gentauro> merijn: `Found hole: _ :: Key` error
06:26:11 <electrocat> has both
06:26:14 <gentauro> my GHC will not do that
06:26:28 <gentauro> merijn: do I need to add (remove) any compiler flags?
06:26:35 <merijn> gentauro: That's what it's supposed to do. If you want to actually run it you can compile with -fdefer-typed-holes
06:27:17 <merijn> gentauro: That's the entire point, _ is a compile error which you can defer using -fdefer-typed-holes so you use that while developing/testing and then you simply compile without -fdefer-typed-holes to get GHC to tell you if you missed implementing any
06:28:06 <electrocat> -fdefer-typed-holes is nice :) i always leave it on
06:28:36 <Myrl-saki> And I thought I could finally use comonad. :(
06:29:09 <Boomerang> electrocat: -fdefer-type-errors is where I'm at :D
06:29:13 <gentauro> merijn: so this is better to use that undefined, as it will point out all the points where I made "sloppy" code?
06:29:23 <merijn> Yes
06:29:30 <gentauro> roger that
06:29:36 <merijn> Boomerang: defer-type-errors is awful :(
06:29:47 <Boomerang> Well yes ^^
06:29:50 <merijn> Boomerang: Then you lose the ability to typecheck while developing
06:29:58 <merijn> defer-typed-holes is much saner!
06:30:14 <Boomerang> But would you leave it on?
06:30:23 <electrocat> doesn't -fdefer-type-errors turn them into warnings?
06:30:28 <electrocat> or is that just with -Wall?
06:30:45 <merijn> electrocat: Maybe, it's been awhile since I looked at defer-type-errors
06:30:56 <Taneb> The trick is to use -fdefer-type-erros and -Werror
06:31:04 <electrocat> lol
06:31:16 <gentauro> % mempty
06:31:16 <yahb> gentauro: ()
06:31:20 <merijn> Basically, shortly before defer-typed-holes was released is when I last looked at it :p
06:31:24 <gentauro> % :t mempty
06:31:24 <yahb> gentauro: Monoid a => a
06:31:26 <danr> iosevka and fira mono also have haskelly ligatures
06:31:35 <danr> eeh hello from the backlog, sorry
06:31:46 <merijn> bleh...
06:31:48 <jose_zap> gentauro fwiw if you use the haskell-ide-engine you can continue to get feedback from the compiler in your editor even when using type holes
06:32:12 <merijn> So is there a version of <* and void that have a Monad constraint? GHC 7.8 is being a PITA >.>
06:32:26 <Boomerang> If you use many type holes, give them names: _key, _foo, _bar :)
06:32:41 <electrocat> Boomerang: oh cool, didn't know that
06:32:50 <cocreature> merijn: protip: drop support for 7.8 until someone complains which never happens :)
06:33:31 <gentauro> Boomerang: thx for the tip
06:33:31 * dmwit points at forehead
06:33:37 <dmwit> users can't complain if you don't have any users
06:33:37 <merijn> cocreature: Up until this refactor I was succesfully handling all the way back to 7.6 :p
06:33:45 <gentauro> makes the warnings more understandable !!!
06:34:08 <Boarders> does anyone know why foldl1 here: http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Foldable.html#foldl1
06:34:20 <Boarders> cases as it does rather than on null
06:34:37 <Taneb> Boomerang: does that work?
06:34:45 <cocreature> if someone complains, I probably could be bothered to support older versions of GHC but so far whenever I actually asked users everyone seems fine with supporting the last 3 versions
06:34:47 <cocreature> Taneb: it does!
06:34:53 <dmwit> Boarders: What's your proposed alternative?
06:35:08 <Boarders> I don't have one, but I am not a politician standing for election
06:35:09 <Taneb> cocreature: oh, neat!
06:35:33 <dmwit> Boarders: Okay. I can't defend this solution against another solution without knowing what the other solution is.
06:36:02 <dmwit> Boarders: Except to say: "this solution exists, and that one doesn't", which is in all honesty a pretty good defense.
06:36:05 <electrocat> 3 versions, that means 1.5 years of support these days
06:36:40 <xenog> wraithm, o/
06:36:43 <gentauro> merijn: so I changed my `undefined` for `_NAME` as Boomerang suggested. Now the compiler tells me that I should probably replaced `_NAME` with `undefined`
06:36:53 <gentauro> is GHC having a laugh?
06:37:01 <dmwit> or is merijn?
06:37:05 <Boarders> yeah I guess you can't case on null without wanting toList and tail, so it makes sense dmwit
06:37:07 <merijn> gentauro: Wut? Can you paste that warning/error?
06:37:08 <gentauro> dmwit: why not both?
06:38:02 <jose_zap> gentauro heh, yeah one of the suggestions is always undefined, when it cannot find a better fit
06:38:03 <gentauro> `Valid substitutions include: undefined :: forall (a :: TYPE r)`
06:38:06 <gentauro> :| 
06:38:10 <merijn> gentauro: Oh
06:38:16 <dmwit> Boarders: I don't really understand where you'd be putting the "null" call in the first place.
06:38:26 <gentauro> jose_zap: but is just not a suggestion, it's a `Valid` suggestion :)
06:38:28 <merijn> gentauro: GHC's new helpful errors try and find values in scope that match the type and suggest those
06:38:44 <jose_zap> gentauro well, the function fits fine, so it is valid
06:38:45 <merijn> gentauro: And it just happens to go "welp, undefined is the only thing in scope that matches!"
06:38:49 <cocreature> iirc undefined is not shown in 8.6
06:39:01 <merijn> I'm....not completely happy with the super verbose new errors
06:39:15 <gentauro> merijn: they look like Elms so I am :)
06:39:19 <merijn> I can fit a lot less useful info on my screen
06:39:35 <gentauro> merijn: i have coded pro for 3 years for C++
06:39:38 <merijn> I hate having to scroll through compiler error output...if I wanted that I'd go back to template C++
06:39:48 <dmwit> Boarders: I suspect you've misunderstood something. But I'm not sure what, and it's hard to guess with you being so cagey about what you mean by "why doesn't it use null".
06:39:58 <Boarders> dmwit: if it was just lists you can do like: {case null xs of; True -> error...; False -> foldl f (head xs) (tail xs)} I think
06:40:03 <gentauro> from that period, every error message I have seen is a trillion times better (generics in C++ is a nightmare)
06:40:20 <cocreature> Boarders: but what is the advantage of that over pattern matching?
06:40:26 <cocreature> personally I find that harder to read
06:40:33 <dmwit> Boarders: Ah, got it.
06:40:34 <cocreature> and performance will definitely not be better
06:41:02 <dmwit> Boarders: Okay, think about `data Pair a = Pair a a`.
06:41:09 <Boarders> I wasn't meaning to come across as cagey, more like "I didn't think about this enough and am surely going to get owned"
06:41:33 <electrocat> any ghcid users noticed that the color output isn't always the same/correct?
06:41:39 <gentauro> hmmmm, could it be that I'm using several threads and when one of them reach undefined it just terminated without no error message? It has to be that 
06:41:42 <Boarders> I was thinking about it btw because I was wondering what a strict foldl1 would look like
06:41:42 <dmwit> Boarders: The inhabitants of `Pair`s always have two "elements". So there is no way to make a new analogous `Pair` where you've pulled out the first element and you have just one "element" left in the new `Pair`.
06:42:06 <Ariakenom> Boarders: did you replace the value undefined with _NAME rather than the typed hole _ with _NAME?
06:42:23 <dmwit> Boarders: So you can't use `Pair`'s `foldl` to implement `Pair`'s `foldl1` in the way you're proposing.
06:43:40 <dmwit> (This is a general problem. Not all `Foldable`s have a clean way to "delete" a particular element.)
06:44:08 <cocreature> oh I misunderstood the question, ignore me :)
06:44:40 <Boarders> dmwit: yeah I realise now I was thinking too much about lists
06:44:58 <dmwit> Yeah. =)
06:45:07 <dmwit> Lists are a good intro, but there's lots of other shapes of Foldable things.
06:45:25 <Boarders> zipper for the head of a list makes it deceptive
06:46:27 <Boarders> somehow I would need a foldable for a zipper to make this a reasonable suggestion, at which point it sounds ridiculous
06:49:46 <gentauro> btw, do anybody know if there is a LinkTaxMonadEU?
06:50:04 <hexagoxel> > foldr1 const (True:undefined)
06:50:08 <lambdabot>  *Exception: Prelude.undefined
06:50:12 <hexagoxel> hum
06:50:32 <gentauro> % head [ 42, undefined ] 
06:50:32 <yahb> gentauro: 42
06:50:51 <hexagoxel> > foldr const False (True:undefined)
06:50:54 <lambdabot>  True
06:51:05 <hexagoxel> that does not look consistent
06:51:32 <gentauro> hexagoxel: `undefined` is pretty bad :|
06:51:37 <hexagoxel> hahaha
06:51:55 <gentauro> % null = undefined
06:51:55 <yahb> gentauro: 
06:52:11 <gentauro> % foo = 42 + null
06:52:11 <yahb> gentauro: 
06:52:24 <gentauro> % print foo
06:52:25 <yahb> gentauro: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:25:8 in interactive:Ghci12
06:52:27 <gentauro> :D
06:52:28 <hexagoxel> dmwit: so i don't have a better alternative yet either, but if there is something _wrong_ about the current implementation, that is valid input still, is it not :p
06:53:24 <gentauro> shouldn't people be using `Void` instead of `undefined`?
06:53:40 <hexagoxel> that's not even the same namespace
06:53:57 <gentauro> no?
06:54:03 <Ariakenom> Void is a type
06:54:47 <dmwit> hexagoxel: I'm not sure I understand the question yet.
06:54:49 <hexagoxel> gentauro: i think `undefined` is a perfectly fine instance of a bottom if you indeed need a bottom
06:56:17 <gentauro> hexagoxel: I tend to fall back to it's usage when I can solve it with math
06:56:39 <hexagoxel> foldr1 is too strict, and stricter than foldr (which is the inconsistent bit)
06:57:04 * hackage rfc1751 0.1.2 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/rfc1751-0.1.2 (xenog)
06:58:26 <Boomerang> > foldr1 const (True:undefined:undefined)
06:58:28 <lambdabot>  True
06:58:38 <gentauro> Example: I only want to work with 4 bit, therefore `case n .&. 3 of 0 -> 0 1 -> 1 2 -> 2 3 -> 3 n -> undefined as I know `n` will never be reached cos of `mod` 4
06:58:47 <gentauro> for that cases I tend to use undefined
06:59:07 <gentauro> but sometimes I get carried on and use it on something I shouldn't which is a no-go
06:59:17 <julianleviston> > :t (.&.)
06:59:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:59:33 <gentauro> % :t Data.Bits.(.&.)
06:59:33 <yahb> gentauro: ; <interactive>:1:1: error:; Not in scope: data constructor `Data.Bits'; No module named `Data' is imported.
06:59:46 <gentauro> > :t Data.Bits.(.&.)
06:59:49 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:59:53 <julianleviston> Thx I found it on hoogle. :)
07:00:16 <gentauro> can somebody please fix lambdabot and yahb ? No `Data.Bits`?
07:00:24 <gentauro> julianleviston: :)
07:00:33 <Taneb> @let import Data.Bits
07:00:35 <lambdabot>  Defined.
07:00:40 <Taneb> :t (.&.)
07:00:42 <lambdabot> Bits a => a -> a -> a
07:00:46 <gentauro> Taneb: thx
07:00:56 <gentauro> :t (.&.)
07:00:57 <lambdabot> Bits a => a -> a -> a
07:01:08 <gentauro> lambdabot: has global state? :o
07:01:17 <Boarders> :)
07:01:26 <geekosaur> temporary global state
07:02:12 <gentauro> geekosaur: have anybody hacked any of them?
07:02:21 <hexagoxel> Boomerang: ah, good point. i think i have to take back what i said.
07:03:07 <MarcelineVQ> hexagoxel: why is that?
07:03:36 <geekosaur> gentauro, define "hacked"
07:04:15 <gentauro> geekosaur: anybody "f**ked them up"?
07:04:44 <geekosaur> it's pretty well sandboxed;"global sate" here does nto mean unsafePerformIO, just shared defs that are easy to make go away if needed
07:04:45 <gentauro> like running an inf loop
07:05:25 <gentauro> geekosaur: ahhh
07:05:57 <quicksilver> > length [1..]
07:06:03 <quicksilver> ^^ infinite loop
07:06:03 <lambdabot>  mueval-core: Time limit exceeded
07:06:10 <hexagoxel> MarcelineVQ: because you cannot be less strict. You have to know whether to return x1, or evaluate `const x1 _`, so it must be strict in the spine after the first element.
07:06:39 <cdo> Hey, does anyone know of a nice DEFLATE implementation? Found pure-zlib but it's only the decompression algorithm.
07:07:33 <hexagoxel> that `const` is not strict does not help
07:09:27 <lavalike> cdo: does a zlib binding count https://www.stackage.org/haddock/lts-12.9/zlib-bindings-0.1.1.5/Codec-Zlib.html
07:10:52 <hexagoxel> Boarders: independent of strictness, it seems that both the `toList` and the "fold over Maybes" approach will allocate some constructor - (:) or Just - at each step. So I am not sure if there is a good argument _against_ using toList.
07:11:13 <cdo> lavalike: was hoping to find one in pure haskell but yeah will probably end up using that tbh
07:11:18 <hexagoxel> but there may be fusion magic, you never know.
07:12:05 <lavalike> cdo: maybe this one's better https://www.stackage.org/haddock/lts-12.9/zlib-0.6.2/Codec-Compression-Zlib.html
07:15:03 <cdo> lavalike: ah yeah, cheers :)
07:28:47 <dmwit> gentauro: I generally prefer `error` to `undefined` for dead branches. It gives me a spot to put an explanation of why I think the branch is dead.
07:36:01 <quicksilver> even leaving it out gives a better error
07:36:05 <quicksilver> than undefined.
07:54:04 <Boomerang> Is there a way to get cabal to list available targets?
07:59:06 <dmwit> Boomerang: https://github.com/haskell/cabal/issues/1382 and https://github.com/haskell/cabal/pull/1932 make me think the answer is no
07:59:47 <dmwit> (The latter because the way bash completion appears to work at the moment is by grepping through *.cabal... yuck.)
08:02:39 <Boomerang> Thanks! :) It's a shame it doesn't exist. Ideally I would want a list of all targets by types (library, executables, tests, benchmarks) and whether the target is buildable. I always forget to type some extra flags like --enable-tests or custom ones to disable specific test-suites...
08:04:21 <dmwit> Hm. I'm not sure I see how the feature you're proposing helps with remembering to say --enable-tests.
08:04:56 <kosmikus> it would definitely be a useful feature, though
08:04:59 <Boomerang> I'm imagining a tool that can tell me a target exist even if it is not buildable
08:05:09 <kosmikus> if only to understand what cabal considers to be part of the current project
08:05:15 <kosmikus> and what it e.g. expands "all" to
08:05:35 <dmwit> Boomerang: I think at the moment if you don't pass --enable-tests, targets like test:foo don't even exist...
08:05:40 <Boomerang> Maybe I should just grep/sed the *.cabal ^^
08:05:55 <Boomerang> Ah that's a shame
08:06:19 <merijn> Boomerang: Are ou using new-build?
08:06:32 <Boomerang> No, nix and old cabal
08:06:36 <merijn> ah
08:06:47 <merijn> Because I think cabal-plan can get you what you want for new-build
08:06:56 <Boomerang> I do like new-build for my personal projects :)
08:07:15 <phadej> Boomerang: https://github.com/haskell-hvr/cabal-plan/blob/7e9bc5d83cbaeca3fa6327d645775aee5f48c662/src-exe/cabal-plan.hs#L115
08:08:15 <Boomerang> Ah yeah that looks promising!
08:08:18 <kosmikus> phadej: is there any good reason why cabal-plan isn't just part of cabal-install? it's much less discoverable being an additional tool.
08:08:52 <kosmikus> phadej: in fact, I've just been looking for it before you mentioned it here, remembering that it exists, but couldn't recall the name, and therefore failed to find it.
08:09:34 <merijn> kosmikus: So that you can use it without depending on cabal?
08:10:03 <merijn> kosmikus: Of course cabal could depend on cabal-plan, but since I don't think it's completely stabilised yet you might wanna avoid that
08:10:10 <phadej> kosmikus: good question. The lib is useful outside Cabal for sure. Exe started as a demo for the lib, but features indeed should be ported back into cabal-install
08:13:04 * hackage rank-product 0.2.1.0 - Find the rank product of a data set.  http://hackage.haskell.org/package/rank-product-0.2.1.0 (GregorySchwartz)
08:13:28 <phadej> personally my personal blocker for porting anything, is that I just don't know how to use cabal's cli-parsing framework :)
08:13:49 <Boomerang> It looks like `cabal-plan` only works with `new-build`, still looks interesting though!
08:14:12 <phadej> Boomerang: hopefully soon new-build will be the only build
08:14:14 <kosmikus> merijn: ok, independent use may be a valid point.
08:14:50 <kosmikus> Boomerang: why would you not just use new-build?
08:16:30 <Boomerang> kosmikus: I got used to cabal with nix enabled so I don't even have to open a nix shell. That doesn't seem to work with new-*. It's a minor incovenient really, I should try a cabal new-* workflow with nix :) 
08:17:27 <kosmikus> hmm, I'm using new-* plus nix for most of my projects. I'm not aware that there's a way to use the old style commands that isn't supported by new. Of course, that's not saying there isn't one.
08:18:15 <kosmikus> I do typically use shells though to establish what toolchain I want to use for a particular project, and what native dependencies.
08:18:17 <Boomerang> I meant that in ~/.cabal/config I have nix set to True, is there a different config for new-*?
08:26:08 <gentauro> OK, so my websocket, have been ping/ponging and sending messages non-stop for the last hour and a half. I think I can conclude that it works :)
08:26:39 <gentauro> is there a way to generate strings of size `n`?
08:26:59 <gentauro> like a `lorem ipsum` but for Haskell?
08:28:17 <geekosaur> sounds like a variant of QC's arbitrary?
08:31:48 <dmwit> gentauro: replicateM n randomIO
08:32:04 <Taneb> > replicateM 3 ['a'..'z']
08:32:04 * hackage rank-product 0.2.1.1 - Find the rank product of a data set.  http://hackage.haskell.org/package/rank-product-0.2.1.1 (GregorySchwartz)
08:32:06 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
08:33:30 <dmwit> (But you probably want something with a smaller distribution than randomIO; e.g. you could get things with \NULs and \EOFs and \374229s and all kinds of terrible junk in them.)
08:34:32 <dmwit> % replicateM 10 (randomRIO (' ','z'))
08:34:33 <yahb> dmwit: "kCM7:n\"+$<"
08:38:15 <gentauro> dmwit: that is perfect
08:38:27 <gentauro> I need to ensure all corner cases are handled :)
08:43:00 <Solonarv_> % sample arbitrary :: IO String
08:43:00 <yahb> Solonarv_: ; <interactive>:30:1: error:; * Variable not in scope: sample :: t0 -> IO String; * Perhaps you meant one of these: `Q.sample' (imported from Test.QuickCheck), `simple' (imported from Control.Lens), Q.sample' (imported from Test.QuickCheck); <interactive>:30:8: error:; * Variable not in scope: arbitrary; * Perhaps you meant one of these: `Q.arbitrary' (imported from Test.QuickCheck), `Q
08:43:15 <Solonarv_> % Q.sample Q.arbitrary :: IO String
08:43:15 <yahb> Solonarv_: ; <interactive>:31:1: error:; * Couldn't match type `()' with `[Char]'; Expected type: IO String; Actual type: IO (); * In the expression: Q.sample Q.arbitrary :: IO String; In an equation for `it': it = Q.sample Q.arbitrary :: IO String
08:43:33 <Solonarv_> % Q.sample Q.arbitrary @String
08:43:33 <yahb> Solonarv_: ; <interactive>:32:1: error:; * Cannot apply expression of type `IO ()'; to a visible type argument `String'; * In the expression: Q.sample Q.arbitrary @String; In an equation for `it': it = Q.sample Q.arbitrary @String
08:44:04 <Solonarv_> % Q.sample (Q.arbitrary @String)
08:44:04 <yahb> Solonarv_: ""; "'"; ")"; ""; "^\225920M\623031.!a"; "G?"; "\EOT\218962\854308\457789`\1037113w;"; "\DC3Q"; "\25149q\221346a\155111\a\736890\438511^"; "{\748135Esz\1013224\STXu2v\365907\\\n\SUBw7z"; "w%\882869KORkXz"
08:54:04 * hackage rank-product 0.2.2.0 - Find the rank product of a data set.  http://hackage.haskell.org/package/rank-product-0.2.2.0 (GregorySchwartz)
08:55:04 * hackage QuickCheck 2.12.3 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.12.3 (NickSmallbone)
09:03:04 * hackage QuickCheck 2.12.4 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.12.4 (NickSmallbone)
09:17:29 <Taneb> Thing I just found out works: "import qualified Foo as Bar.Baz"
09:20:20 <Solonarv_> huh, neat
09:21:44 <Taneb> (or, in this case, import Data.ByteString.Base64.URL as Base64.URL)
09:43:39 <quicksilver> the dots in package names don't really "mean anything" to haskell
09:44:06 <Taneb> I know, it was just something it never occured to me to try
09:56:03 <maerwald> stack still reinstalling groom, haskell-src-exts, haskell-src-meta, interpolatedstring-perl6 unconditionally on every project build
09:56:03 <maerwald> great
10:04:53 <maerwald> probably caused by hackage revision, which are unfortunately misdesigned
10:04:59 <maerwald> https://github.com/commercialhaskell/stack/issues/3151
10:06:26 <maerwald> causes metadata updates to go unnoticed by anything that relies on versions to be the single source of truth
10:18:10 <davean> no, revisions *are* versioned
10:18:18 <davean> stack just doesn't use the full version
10:21:24 <davean> maerwald: http://hackage.haskell.org/package/haskell-src-exts-1.20.2/revisions/
10:22:27 <davean> The hackage API is actually amazingly well documented - I had to go through it all when I made skete-haskell
10:22:52 <davean> The only thing that was lacking for me was a feed of revision data instead of package uploads, but they added that quickly
10:25:21 <maerwald> I know revisions are versioned, but it's an unidiomatic way to do metadata updates
10:27:54 <davean> Well thats clearly an oppinion statement
10:28:18 <davean> though I could argue by example its very idiomatic
10:28:50 <davean> With a long history, by pointing to tarballs with configure and make fixes and no new version release, just a tarball replacement, back into the '90s
10:29:38 <davean> Also that same sort of system exists in, say, debian's package system
10:29:59 <maerwald> it causes problems for distributions too
10:30:06 <maerwald> you cannot just fetch a tarball
10:30:13 <maerwald> now you have to fetch metadata from a custom place too
10:30:19 <maerwald> because the tarball is not self-contained anymore
10:30:25 <maerwald> no other ecosystem does that, to my knowledge
10:30:51 <davean> That part is less common
10:31:02 <davean> though I think ruby does?
10:31:51 <davean> ReinH commented on the same think doing skete-ruby
10:32:15 <Clint> the ruby ecosystem: a shining example of good practices
10:32:31 <davean> Clint: idiomatic has nothing to do with good :)
10:32:37 <davean> Infact, its often bad
10:33:05 <Clint> fair enough
10:33:09 <davean> idiomatic generally acts as exceptions to the rules of system the idiom generally resides in infact
10:33:15 <davean> thats what makes it idiomatic traditionally
10:33:33 <davean> If it wasn't special it litterly wouldn't be idiomatic
10:35:52 <davean> I'd agree that providing the revisioned tarball would be better, and skete-haskell does
10:38:20 <maerwald> keep things simple, don't try to be too smart, don't create additional API for people who just want to fetch... a tarball
10:39:44 <davean> maerwald: I'd agree if hackage was a fileserver
10:40:10 <Athas> maerwald: you can just ignore the revisions, can't you?
10:41:02 <maerwald> Athas: and then have unbuildable deps?
10:41:52 <maerwald> so e.g. if you write a cabal2<distro> tool, you also need to be revision aware and figure out what to do
10:41:55 <Athas> maerwald: that's what the non-revision world is like.  (Or you can use stack or 'cabal freeze'.)
10:42:03 <Athas> The Haskell world is pretty spoiled for options.
10:42:29 <maerwald> I don't see an argument
10:42:47 <maerwald> but yeah, these are the options, but as I said, stack seems to have problem with that too
10:44:01 <Athas> I think stack just ignores revisions now.
10:44:04 <maerwald> there was a happy-1.19.9@rev:2 in extra-deps, which worked fine for 8.2.2 lts
10:44:12 <maerwald> but for 8.4.3 it blew up
10:44:30 <Athas> You can depend on specific revisions in a .cabal file now?
10:44:36 <maerwald> stack.yaml
10:44:36 <Athas> Ah, you mean stack.yaml?
10:45:14 <Athas> Well, if you use extra-deps, then you move outside the walled garden.  I also don't think stack guarantees that upgrading from one lts to another (across major versions) is going to be smooth.
10:45:18 <Athas> Works fine for me.
10:45:36 <maerwald> I don't think that's a sufficient explanation though
10:45:48 <maerwald> there is something with revisions that causes stack to constantly rebuild some stuff
10:45:55 <maerwald> https://github.com/commercialhaskell/stack/issues/3922
10:46:02 <maerwald> https://github.com/commercialhaskell/stack/issues/3151
10:46:56 <maerwald> 3922 looks like it could be a stack bug even
11:03:39 <Athas> I am looking for a name for a higher-order function.  In Haskell, its type would be something like:
11:03:39 <Athas> f :: [a] -> (a -> a -> a) -> [(Int, a)] -> [a]
11:03:40 <Athas> It is kind of a fold updating a histogram.  For each value in [(Int, a)], it updates the corresponding index in the given [a] using the combining function of type 'a -> a -> a'.
11:04:56 <Athas> Maybe something like "reduce by key".  In practice, there is also a neutral element for the updating function (and it is further associative and commutative).
11:05:14 <davean> maerwald: how could the rebuilding not be a stack bug?
11:06:09 <oisdk> Athas that seems like it'd be pretty slow on lists. (O(n^2), right?) Anyway, that function *is* defined in Data.Vector http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html#v:accum
11:07:04 <Athas> oisdk: yes, I don't actually need it in Haskell - I was just seeking inspiration for a name.
11:07:18 <Athas> I feel 'accum' is too vague.  That might as well just be an ordinary fold or reduction.
11:08:24 <davean> Athas: you're like ... augmenting a list with extra data? sort of a indexed merge?
11:08:54 <Athas> davean: in practice, it will be an array.  It is more like updating a histogram, except that you don't just "count" things - the function doesn't have to be addition.
11:09:26 <Athas> It can also be seen as a fold/reduction where you have several concurrent accumulators (identified by their position in an array).
11:10:20 <davean> Athas: augment?
11:11:20 <Athas> Can't say I like it much.  There are many related operations that could also be named that.
11:11:34 * hackage streamly 0.5.1 - Beautiful Streaming, Concurrent and Reactive Composition  http://hackage.haskell.org/package/streamly-0.5.1 (harendra)
11:11:50 <davean> Athas: yah, its the best I had :/
11:12:05 <Athas> This is among the hardest problems in computer science.
11:12:42 <cocreature> Athas: I might use something like "updateAt"
11:13:58 <Athas> Not too bad.
11:15:08 <cocreature> that at least suggests that the Int is an index and at that point you can probably guess the rest from the type
11:15:53 <davean> I definately like that
11:16:01 <Athas> In the autoparallelisation literature, this is called a "generalized reduction", but I think that is a terrible term.
11:16:12 <Athas> And not particularly well established anyway.
11:16:17 <cocreature> “generalized reduction” could be pretty much anything :)
11:17:07 <davean> well, its more general than just reduction we know that ...
11:17:29 <davean> so it can't be just reduction, it COULD be anything else that one could impliment reduction with ...
11:17:43 <davean> Its probably turing machines.
11:18:01 <davean> "Generalized ___"s always are
11:24:21 <Athas> I think I will go by reduce_by_key (this is for a language with snake_case).
11:25:51 <cocreature> Athas: hm reduceByKey makes me immediately think of the operation in MapReduce-like frameworks which is more something like reduceByKey :: [(k,v)] -> (v -> v -> v) -> [(k,v)]
11:26:08 <dmwit> Athas: Data.Map calls this fromListWith.
11:26:16 <Solonarv_> you could also make the type more polymorphic: [a] -> (a -> b -> a) -> [(Int, b)] -> [a]
11:26:32 <Athas> Solonarv_: that won't support a parallel implementation.
11:26:41 <Athas> cocreature: yes, it's certainly closely related.
11:26:53 <Athas> This one is slightly more general.
11:28:04 <cocreature> Athas: maybe reduceByIndex?
11:28:17 <Athas> Yes, that is better.
11:28:17 <Solonarv_> ah, true - but that's unsound anyway unless you require that the combining function must be associative (I think ?)
11:28:29 <Athas> Solonarv_: yes, it must be associative and commutative.
11:28:48 <Athas> This function is specialised to arrays, so the "key" must always be an index.  No point in hiding that.
11:32:23 <gabe4k> Does cabal have a config option to print absolute paths (instead of relative paths) for build errors?
11:33:17 <cocreature> gabe4k: if anything, that would probably have to be a GHC option but afaik that option does not exist.
11:36:10 <davean> In general I don't think absolute paths are a solvable problem in POSIX
11:37:20 <davean> that is to say, the is no requirement an absolute path exists
11:38:08 <geekosaur> mroe precisely, no requirement that it be accessible\
11:38:15 <davean> Yes
11:38:56 <davean> well, more than that theres also the length issues and such
11:39:41 <davean> And the path that you'd generate to a file based on the pwd and the relative, might map to another file
11:39:47 <dolio> Does POSIX allow non-well-founded directory structures?
11:39:51 <davean> so it might be accessable but incorrect
11:39:52 <dolio> Like Aczel's set theory.
11:40:13 <cocreature> davean: in which case does it map to a different file?
11:40:15 <davean> quicksilver: which is a MUCH stronger issue that "mearly not accessible"
11:40:37 <davean> cocreature: create a directory, go into it, delete directory from its parent, recreate, create a file in both
11:40:43 <cocreature> ah right
11:40:47 <davean> now you have two files with the same absolute path but different contents
11:41:04 <davean> gabe4k: So, I'd sy your request leads to insanity :)
11:41:08 <geekosaur> and ten there's how symlinsk to direcories confuse things
11:41:19 <davean> geekosaur: oh yes
11:41:26 <dolio> I guess you can be well-founded without being accessible. Like a universe.
11:41:26 <gabe4k> I guess the real problem is, I'm using cabal new-build, and the relative paths omit the package directory. So VSCode isn't recognizing the filepaths
11:42:05 <Vyse007> Anyone here have some experience with parsec? I am trying to parse a simple string with a few simple rules but all these different tutorials are really confusing...
11:42:29 <cocreature> Vyse007: many people here have experience with parsec, just ask your question directly :)
11:42:29 <davean> gabe4k: Ah, that seems a more solvable problem
11:44:31 <hexagoxel> you can create files in deleted directories? wut
11:44:41 <davean> hexagoxel: of course
11:44:45 <davean> hexagoxel: well
11:44:47 <davean> no
11:44:51 <davean> the directory isn't deleted
11:44:58 <davean> the *LINK* to it in its parent is
11:45:08 <davean> POSIX filesystems are garbage collected
11:45:15 <davean> your presence in the directory is a reference
11:45:21 <davean> you can also link a directory from N places
11:45:43 <davean> So you never delete a file in POSIX, you remove the link and if its ref count is 0, it is dropped
11:45:55 <Vyse007> Awesome! I am just trying to parse a string, with the only rules being that each character is not an unsupported character (i have a list for these). So I write something like 'many1 (noneOf <mylistOfUnsupportedChars>)' which only fails if the unsupported character is the first character in the string. How do I check the entire string, character by character? Sorry but I can't wrap my head around monadic parsing yet... 
11:46:17 <davean> you can relink an unlinked file - just look at what process has a handle to it and give a name to the inode its connected to
11:46:26 <hexagoxel> what filesystems expose such a posix interface?
11:46:39 <davean> hexagoxel: many files *never* get names in POSIX, temp files of certain kinds specificly
11:47:04 <davean> hexagoxel: any with a POSIX API, so any you access via UNIX that doesn't have MAJOR issues really - IE FAT has major issues
11:47:18 <cocreature> Vyse007: that should work, can you show us some minimal example of the exact parser that you use and an input that should fail but doesn’t?
11:47:42 <davean> hexagoxel: If you're using a filesystem native to Mac OS X, Linux, FreeBSD ... they all do this
11:47:55 <davean> NTFS and FAT are the exceptions
11:48:16 <ab9rf> actually, ntfs is not an exception
11:48:27 <davean> ab9rf: Uh, later versions aren't
11:48:28 <hexagoxel> and here i though "the only case i remember observing something like this was on a FAT".. :D
11:48:29 <ab9rf> it's just that the linux interface TO NTFS is incomplete
11:48:33 <davean> ab9rf: I think the first version is
11:48:51 <davean> Albet good luck FINDing a v1 NTFS volume ...
11:49:11 <davean> By the time they added the POSIX subsystem to NT NTFS was POSIX supporting
11:49:30 <Vyse007> cocreature: https://lpaste.net/4855415512575770624
11:49:54 <ab9rf> but this is off topic
11:50:01 <davean> It is
11:50:12 <ab9rf> and nobody is answering Vyse007's question
11:50:23 <ab9rf> oh, wait, cocreature did, sorry, missed it in the noise
11:51:28 <cocreature> Vyse007: thanks but that has a syntax error in line 1 (string literals need double quotes), it is missing imports and you haven’t provided the example that doesn’t behave as you would like
11:51:30 <ab9rf> Vyse007: that production will match if there is at least one non-nonsupported character. it will then leave the first non-nonsupported character on the input stream
11:52:27 <Vyse007> cocreature: Sure, let me whip up a full example.
11:52:29 <cocreature> it might just be as simple as using "parse (parseIdentifier <* eof) …" to ensure that no input is left over
11:53:35 <Vyse007> ab9rf: Thanks for taking a look, not sure I understand you though. For a string like, say "124$", it will produce an output of "124", whereas I expect it to error out.
11:54:19 <cocreature> Vyse007: that’s because you are not consuming all input
11:54:28 <cocreature> try "parseIdentifier <* eof" as I suggested
11:54:37 <cocreature> that will force you to consume all input or produce a parse failure
11:54:49 <Vyse007> Aah, I see. Hold on let me give that a try.
11:56:31 <Vyse007> cocreature: Thanks, that works as expected. I was under the impression that the entire string will be consumed...
11:57:03 <cocreature> Vyse007: it makes more sense if you think about this parser being embedded in a larger context. at that point you don’t want it to parse everything
11:59:07 <davean> Specificly all parsers are the same. How can you know when it should parse everything? This follows from the types a bit though one might assume that 'parse' would add it I suppose
12:00:30 <Vyse007> That does make sense, now that I think about it. 
12:11:43 <Ganwell> Hi, I am newbie I have substituted a definition, expecting the resulting expression to be the same, but that is not true and I don't know what concept or feature I don't understand. https://gist.github.com/ganwell/bd799082e231e327d29ef720c95cdef5
12:14:01 <cocreature> Ganwell: the extensions enabled via LANGUAGE pragmas in a file don’t apply to definitions that you make in GHCi (they can’t: you can load more than one file with conflicting pragmas)
12:14:12 <cocreature> Ganwell: so presumably the file has one of those extensions turned on
12:14:39 <cocreature> if you try something like ":set -XGADTs" to enable the extension in ghci, the error should go away
12:15:07 <cocreature> ah and I think the monomorphism restriction which is turned off by default in ghci might also come into play here
12:17:41 <Ganwell> cocreature: Thanks for your answer, wouldn't that mean if I do the substitution in the source-code it would work? Here is the error I get from the compiler: https://gist.github.com/ganwell/d8a30706b6d0f9e1d59b5a624f0ca8c8
12:18:51 <Ganwell> I guess I am playing with too advanced libraries for a newbie.
12:19:02 <cocreature> Ganwell: that fails for probably a very similar reason: the extension is turned on in the module that defines lexeme (some module in megaparsec itself) but it’s not turned on in Waedl.Parser
12:19:37 <Ganwell> cocreature: ah, now I get it thanks!
12:19:47 <MarcelineVQ> what does the actual source file look like?
12:22:26 <Ganwell> MarcelineVQ: https://gist.github.com/ganwell/ab45fb964538f6a9847ef986d83ab651 I did qualified imports in order to learn where things come from.
12:27:52 <MarcelineVQ> Interesting, yeah, weird how lexeme is good and lexeme2 isn't. You can avoid this for now via a type signature, like  lexeme2 :: Parser a -> Parser a
12:28:54 <MarcelineVQ> Parser is defined in Text.Megaparsec I think, it's a type synonym for  ParsecT Void String Identity a
12:29:08 <dstolfa> MarcelineVQ: don't think it is
12:29:15 <dstolfa> MarcelineVQ: not last i used it anyway (today)
12:30:08 <MarcelineVQ> oh he had defined it in the source file already, neat
12:30:24 <MarcelineVQ> Well anyway, give your stuff type signatures :>
12:31:15 <Ganwell> MarcelineVQ: Yes, either enabling the extensions like cocreature said or putting type signature in front works. I still don't understand the concept, but at least I know what to google for. Thanks a lot.
12:32:28 <cocreature> Ganwell: "ws" has a more restricted type than C.space due to the monomorphism restriction
12:32:50 <cocreature> if you enable NoMonomorphismRestriction then the "ws" will get its most general type and you will get an error for lexeme as well
12:37:04 <cocreature> Ganwell: https://stackoverflow.com/questions/32496864/what-is-the-monomorphism-restriction has a pretty good explanation
12:40:05 * hackage concurrency-benchmarks 0.1.1 - Benchmarks to compare concurrency APIs  http://hackage.haskell.org/package/concurrency-benchmarks-0.1.1 (harendra)
12:43:36 <greymalkin> either-5 seems to have lost the Control.Monad.Trans.Either that was present in all 4.x releases, but the documentation still claims it's there.
12:44:25 <hexagoxel> greymalkin: which documentation makes that claim?
12:45:33 <greymalkin> hexagoxel: First paragraph "This provides an Either monad transaformer that"...
12:46:40 <hexagoxel> probably an oversight that was fixed in 5.0.1
12:47:10 <greymalkin> hexagoxel: Nope, changelog indicates that support for it was dropped in favor of ExceptT
12:48:14 <hexagoxel> no, i meant the package description should have changed on the ->5 transition, but was only done on 5->5.0.1
12:52:48 <Ganwell> cocreature: Thanks, I need to understand it better, but I was already able to get all the signatures that it compiles: https://gist.github.com/ganwell/db41e7a2e555ea9712ebad4fc4b0a26a
12:56:59 <cocreature> Ganwell: right, if you explicitely restrict the type using a type signature you avoid the problem
13:18:34 * hackage first-class-families 0.2.0.0 - First class type families  http://hackage.haskell.org/package/first-class-families-0.2.0.0 (lyxia)
13:21:48 <monochrom> Haha neat.
13:24:35 <dmwit> lyxia: Yeah, but can it do type-level typeclasses?
13:30:59 <wpcarro> Does anyone know if it's possible to search Hoogle for a return type given any combination of input types where input order is not dependent and some inputs are optional
13:31:50 <wpcarro> Or do users have to permute all combinations and search individually?
13:34:45 <MarcelineVQ> I can hear gears churning
13:35:17 <MarcelineVQ> Or grinding maybe, clacking? Anyway that's a tough question to parse, do you have an example/mockup?
13:35:46 <MarcelineVQ> Oh what you're wanting to type into hoogle and what you're hoping it would give you?
13:35:49 <MarcelineVQ> *Of what
13:37:05 <wpcarro> Say I have String -> Int -> Boolean -> Boolean. From what I can tell, Hoogle only returns functions whose arguments are String -> Int -> Boolean... but say I want to also see Int -> String -> Boolean -> Boolean or even Boolean -> Int -> String -> Boolean
13:37:06 <lyxia> dmwit: it turns out polykinds already give you something like overloading (there's fmap in Fcf with that release)
13:41:27 <wpcarro> I'm basically asking if there is a flag I can set to inform Hoogle that parameter order is not important to me?
13:42:21 <infinisil> Hey, my code currently has something like this: do { mval <- use $ myMap . at 0; case mval of    Nothing -> return ()      Just val -> myFun val }
13:42:45 <infinisil> This is using lens of course. But I feel like there must be some better way
13:43:03 <monochrom> I would do exactly that.
13:43:22 <infinisil> Is there some lens function to run a monoidal action on a value gotten from a lens?
13:43:30 <infinisil> if that exists
13:43:36 <monochrom> But subjective personal preference being subjective person, there is also "x >>= \case ..."
13:43:38 <infinisil> Maybe something with traversed
13:43:46 <infinisil> Ah yeah
13:44:01 <infinisil> I feel like there should be a one-line equivalent, but I can't find it
13:46:19 <infinisil> I guess `  maybe (return ()) decrease _key` works, not really lensy though
13:46:21 <MarcelineVQ> oh there's ways to one line that, are there ways to do it clearer?
13:46:46 <infinisil>   use (scope . at var) >>= maybe (return ()) decrease
13:46:57 <infinisil> Um, function names changed
13:46:57 <monochrom> Unfortunately "clear" is also subjective personal.
13:47:22 <infinisil> use (myMap . at var) >>= maybe (return ()) myFun
13:47:41 <infinisil> Good enough for me :P
13:48:14 <MarcelineVQ> infinisil: don't forget to comment above it what that does
13:48:51 <infinisil> I guess
13:49:59 <MarcelineVQ> With a fair degree of firmness I think commentary should outweigh code in a volume comparison. Like if the code was an olympic swimmer and the commentary was a sumo wrestler.
13:50:27 <MarcelineVQ> And you stick them in a pool and they both float, but there's still a pretty obvious dichotomy
13:50:51 <infinisil> Lol
13:50:52 <monochrom> Like this? http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs  TEE HEE HEE
13:51:00 <MarcelineVQ> Yes.
13:51:46 <MarcelineVQ> If you come back to that after the heat-death of this universe you'll be able to figure it out pretty quickly.
13:57:39 <monochrom> http://www.multivax.com/last_question.html implies that if you come back at all after the heat death, you will even figure out creation itself. >:)
14:09:04 * hackage pier-core 0.2.0.0 - A library for writing forwards-declared build systems in haskell.  http://hackage.haskell.org/package/pier-core-0.2.0.0 (JudahJacobson)
14:10:04 * hackage pier 0.2.0.0 - Yet another Haskell build system.  http://hackage.haskell.org/package/pier-0.2.0.0 (JudahJacobson)
14:15:09 <dmwit> lyxia: eep
14:15:31 <dmwit> monochrom: It is easy to recover from heat death. You just have to wait a very, very long time.
14:22:28 <wpcarro> Does anyone know if it's possible to create a Hoogle database for a local project? It seems like the `--local` flag that I'm providing to `hoogle` on CLI isn't working
14:22:43 <wpcarro> I've read the manual and README on Github and can't seem to query my project
14:27:01 <Boarders> is there any reason why NFData doesn't have a helper function foldl'' that does a foldl whilst forcing the accumulator to normal form
14:27:06 <Boarders> does that have bad semantics or something
14:27:10 <Boarders> or just doesn't fit with the package
14:30:11 <lyxia> that sounds horrible for performance
14:30:46 <Boarders> how so?
14:31:02 <Boarders> wouldn't it be better if you were wanting to do some kind of fold of pairs of Ints or similar
14:31:28 <Boarders> like the kind of thing where you introduce a custom type of strict pairs
14:32:10 <Boarders> or various other types where the weak head normal form is not useful for a foldl
14:34:50 <Boarders> lyxia?
14:35:17 <Boarders> (sorry I am just about to leave so wanted to catch how wrong headed I am about NFData)
14:36:15 <lyxia> I guess that's not so bad for pairs, I was thinking of larger structures.
14:37:33 <Boarders> maybe it is not that useful
14:37:47 <Boarders> it'd just be for cases like pairs or Maybe Int or whatever
14:39:04 * hackage ghc-exactprint 0.5.8.0 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.5.8.0 (AlanZimmerman)
16:12:58 <disconsis> quit
16:51:11 <ChaiTRex> Is there a simpler version of this:
16:51:14 <ChaiTRex> > zipWith ($) <$> (replicateM 5 [fst, snd]) <*> pure (zip [1..] [10..])
16:51:16 <lambdabot>  [[1,2,3,4,5],[1,2,3,4,14],[1,2,3,13,5],[1,2,3,13,14],[1,2,12,4,5],[1,2,12,4,...
16:55:02 <hpc> ChaiTRex: i think if i was forced to simplify it, i would make it easier to read but longer
16:55:31 <hpc> but i wouldn't change it unless i had to, i think it's probably fine
16:55:44 <hpc> as long as you're familiar with that replicateM trick
16:56:35 <ChaiTRex> hpc: OK, thanks.
17:00:57 <lyxia> > zipWith ($) <$> replicateM 5 [id, (+ 10)] <*> [1..]
17:00:59 <lambdabot>  error:
17:00:59 <lambdabot>      • No instance for (Enum [Integer]) arising from a use of ‘e_15101’
17:00:59 <lambdabot>      • In the expression: e_15101
17:01:19 <lyxia> > zipWith ($) <$> replicateM 5 [id, (+ 10)] <*> [[1..]]
17:01:22 <lambdabot>  [[1,2,3,4,5],[1,2,3,4,15],[1,2,3,14,5],[1,2,3,14,15],[1,2,13,4,5],[1,2,13,4,...
17:01:41 <lyxia> close enough
17:02:24 <lyxia> > zipWith ($ [1 ..]) <$> replicateM 5 [id, (+ 9)]
17:02:26 <lambdabot>  error:
17:02:27 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘b -> c’
17:02:27 <lambdabot>        Expected type: [[[Integer] -> b -> c]]
17:02:33 <Axman6> I feel there's a filterM alternative but can't figure it out
17:02:43 <lyxia> > ($ [1 ..]) <$> replicateM 5 [id, (+ 9)]
17:02:46 <lambdabot>  error:
17:02:46 <lambdabot>      • Couldn't match type ‘[Integer -> Integer]’ with ‘[Integer] -> b’
17:02:46 <lambdabot>        Expected type: [[Integer] -> b]
17:03:35 <Axman6> > bool <$> [1,2,3] <*> [10,20,30]) <*> [True, False]
17:03:37 <lambdabot>  <hint>:1:32: error: parse error on input ‘)’
17:03:44 <Axman6> > bool <$> [1,2,3] <*> [10,20,30] <*> [True, False]
17:03:47 <lambdabot>  [10,1,20,1,30,1,10,2,20,2,30,2,10,3,20,3,30,3]
17:08:19 <dataN> what is the status of partially applied type families?
17:12:21 <dataN> is it possible using TypeInType?
17:12:25 <ChaiTRex> lyxia: Thanks, that simplifies it somewhat.
17:13:02 <nshepperd> there's no plan for partially applied type families to work
17:13:39 <nshepperd> (where 'work' means "possible to have type variable with that value" presumably)
17:14:21 <nshepperd> dataN: on the other hand -XDependentHaskell, whenever it happens, will presumably have a solution that will do whatever you want partially applied type families for
17:14:36 <dataN> there are some references online to; UnsaturatedTypeFamilies 
17:15:58 <dataN> and this; https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126904.html
17:16:25 <dataN> sorry thats not the first post; https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126893.html
17:17:30 <nshepperd> ah, i see there's a whitepaper on it too
17:17:50 <dataN> I can write; type family All (f :: a -> Bool) (xs :: [a]) :: Bool
17:17:56 <dataN> but cant use it...
17:18:47 <dataN> a data family can be partially applied, but then there is a newtype wrapper to contend with
17:19:55 <nshepperd> https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/ug-prizes-201718/Csongor-Kiss-Higher-order-type-level-programming-in-Haskell.pdf seems to state that the extension has been written and might be merged 'at some point'
17:20:23 <nshepperd> but it might also be rolled into DependentHaskell
17:20:37 <dataN> 'type family SomeFunc (n::N) :: Bool' can be rewritten 'type family SomeFunc :: N -> Bool'
17:20:47 <dataN> but then its not possible to write an instance
17:23:34 <dataN> nshepperd: does this mean that it is possible to build or download a version of ghc that enables this extension? (UnsatureatedTypeFamilies)
17:33:10 <benzrf> dataN_: honestly, at this point why dont you just use idris or something
17:33:12 <benzrf> :p
17:35:23 <dataN_> if the ghc fork can be built it would mean the type level Comonad could be fmapped over, which is the current goal. 
17:37:41 <dataN_> its for a cyclic type level list of types where adjacent types can be used at each element. 
17:39:20 <dataN_> without this its not possible to write a style of recursion scheme over types parametrised by Nats which are indexes of a type list 
17:40:27 <dataN_> but where the Nat can be omitted by using local adjacency.  
17:40:37 <dataN_> (with cyclic boundaries.)
17:42:00 <dataN_> ok, so it wouldnt be so easy to demonstrate if we had different GHCs
17:42:22 <dataN_> but its not easy to write if it does not compile.
17:43:25 <dataN_> possibly it can be written without higher order functions...
17:43:45 <dataN_> but its a serious setback 
17:44:51 <dataN_> ok, if thats the only option...
17:45:49 <dataN_> maybe its worth discussing if a workaround using data families if possible... 
17:47:45 <dataN_> hmm, maybe they can have type equality mapped over the dataconstructor using InjectiveTypes...
17:51:42 <dataN_> benzrf: because its for a haskell graph library
17:51:52 <benzrf> jesus
17:53:18 <dataN_> they are naturally expressed using cyclic trees in a lazy language.
17:54:15 <dataN_> the zipper Comonad instance gives an efficient stencil convolution based on Kan extension 
17:54:39 <dataN_> just not quite at type level yet
17:55:30 <dataN_> which is neither lazy nor supporting classes or partial application for higher order functions.
17:55:55 <dataN_> maybe idris has this, but at the moment its not something to consider 
17:57:19 <geekosaur> uhhh... honestly, it's way mroe sensible to consider than haskell at this point
17:58:25 <Axman6> why do you say that?
17:59:08 <monochrom> Because if you actually treat the type language as a full-blown programming language then Haskell is not it.
18:09:34 <nshepperd> and I thought I was doing too much type level programming using Nats to represent tensor dimensions
18:22:45 <rotaerk> nshepperd, that's what the easytensor library does
18:34:34 * hackage pier-core 0.2.0.1 - A library for writing forwards-declared build systems in haskell.  http://hackage.haskell.org/package/pier-core-0.2.0.1 (JudahJacobson)
18:35:34 * hackage pier 0.2.0.1 - Yet another Haskell build system.  http://hackage.haskell.org/package/pier-0.2.0.1 (JudahJacobson)
18:45:14 <cheater> what type has 0 constructors?
18:45:20 <cheater> i understand 
18:45:29 <cheater> i understand () has one constructor called (), right?
18:45:35 <cheater> so what type has 0?
18:46:06 <dmwit> ?src Void
18:46:06 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:46:09 <dmwit> well
18:46:13 <dmwit> data Void -- is the source
18:46:31 <dmwit> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Void.html#Void
18:47:30 <cheater> i thought () was called void?
18:47:38 <dmwit> Why did you think that?
18:47:51 <cheater> because everyone i know calls () void
18:47:57 <cheater> i guess Unit is better though
18:47:59 <dmwit> Well, you should correct them. =)
18:48:17 <cheater> "everyone i know" meaning the few people who called it that in my presence. not actually everyone
18:48:20 <cheater> ok
18:48:39 <dmwit> Anyway, I think it doesn't matter much what you call it.
18:49:04 <dmwit> % data BlurgleWurgleZorpaProz
18:49:04 <yahb> dmwit: 
18:51:38 <dmwit> % let blurgawurgasurdaproz :: BlurgleWurgleZorpaProz; blurgawurgasurdaproz x = case x of
18:51:38 <yahb> dmwit: ; <interactive>:35:53: error:; * Couldn't match expected type `BlurgleWurgleZorpaProz' with actual type `p0 -> p1'; * The equation(s) for `blurgawurgasurdaproz' have one argument,; but its type `BlurgleWurgleZorpaProz' has none
18:51:45 <dmwit> % let blurgawurgasurdaproz :: BlurgleWurgleZorpaProz -> a; blurgawurgasurdaproz x = case x of
18:51:45 <yahb> dmwit: 
19:00:39 <ab9rf> blurgle?
19:01:12 <dmj`> class Blurgle a where blurgle :: Blurgle -> a
19:05:22 <Solonarv_> empty case without an explicit {} looks weird to me
19:13:03 <infinisil> Hey, when I have some cabal project depending on another cabal project in a subdirectory, how do I make cabal build/repl find the dependency?
19:15:24 <dmwit> infinisil: You don't. You make cabal new-build/new-repl find the dependency.
19:15:31 <dmwit> And you do it by making a cabal.project file.
19:16:01 <cheater> that stuff is pretty funny
19:16:49 <infinisil> dmwit: Oh, no way to do it with the old commands
19:16:51 <infinisil> ?
19:18:31 <dolio> You can, but it's easier with the new one.
19:19:31 <infinisil> Alright
19:20:02 <infinisil> Okay, but now a problem: I can change a file in the dependent cabal project, but doing :r in the new-repl doesn't reload anything
19:20:17 <infinisil> It only reloads changes of the main project
19:20:33 <infinisil> Is there a way to have it reload stuff without exiting the repl?
19:24:16 <infinisil> Oh, yeah it doesn't work
19:24:35 <infinisil> Trying to load them both at once with `cabal new-repl a b` gives
19:25:00 <infinisil> "cabal: Cannot open a repl for multiple components at once. The targets 'a' and 'b' refer to different components.. The reason for this limitation is that current versions of ghci do not supportloading multiple components as source. Load just one component and when you make changes to a dependent component then quit and reload."
19:25:32 <infinisil> That sucks, oh well
19:28:34 * hackage generic-data 0.2.0.0 - Utilities for GHC.Generics  http://hackage.haskell.org/package/generic-data-0.2.0.0 (lyxia)
19:38:19 <infinisil> dolio: Oh actually, I need to do it with cabal build, because haskell-ide-engine doesn't support cabal new-build
19:38:21 <infinisil> (yet)
19:38:43 <infinisil> How does that go?
19:39:13 <dolio> You can create a sandbox and then add sources to the sandbox.
19:39:23 <dolio> I'm not 100% sure how it works.
19:39:48 <dolio> Hopefully that's enough of a lead.
20:39:24 <dmj`> Does anyone know where the BNF for json-path resides?
20:39:36 <dmj`> referring to this json-path
20:39:37 <dmj`> http://goessner.net/articles/JsonPath/
20:42:40 <koz_> jle`: For this https://blog.jle.im/entry/introduction-to-singletons-1.html#the-singletons-library, what do I need to import to write the 'genSingletons' part?
20:42:46 <koz_> (as well as enabling TH obviously)
20:57:20 <dataN> where are ->> and @@ found? as described in; 2014 Promoting Functions to Type Families in Haskell by Richard A. Eisenberg and Jan Stolarek
21:01:22 <jle`> koz_: Data.Singletons.TH maybe?  i wonder if Data.Singletons allso already has it
21:05:03 <dataN> what kind of documentation is this!? http://hackage.haskell.org/package/singletons-2.4.1/docs/Data-Promotion-TH.html#t:Apply
21:08:56 <dataN> here is the relevant excerpt; https://lpaste.net/7963576223911641088
21:09:21 <jle`> hehe
21:09:25 <jle`> haddock sort of fails for this kind of stuff
21:09:59 <jle`> oh unless you mean the words used in the documentation
21:10:18 <dataN> maybe its just template haskell
21:10:21 <jle`> yeah 'defunctionalization' isn't really a useful word unless you are used to defunctionalization as a technique in compilers
21:10:28 <dataN> not at all!
21:10:42 <dataN> what about ->> ?
21:10:52 <jle`> but yeah the long list of instances in the haddocks is a bit unweildy
21:11:02 <jle`> dataN: do you have a link to the paper you are talking about?
21:11:07 <jle`> it's probably not called ->> anymore in singletons
21:11:38 <jle`> (@@) still is in the singletons library though
21:11:43 <jle`> it's basically a type synonym for Apply
21:11:49 <jle`> an infix alias
21:11:57 <jle`> like fmap and <$>
21:12:04 <dataN> https://repository.brynmawr.edu/cgi/viewcontent.cgi?referer=https://www.google.co.uk/&httpsredir=1&article=1000&context=compsci_pubs
21:12:10 <dataN> not sure how permanent that is
21:13:02 <jle`> ah yeah, so in that paper, what they call (@@) is Apply in singletons
21:13:12 <jle`> and (@@) is an infix alias now
21:13:17 <dataN> oh right, so they are using ->> like ~>
21:13:55 <jle`> yeah, ->> is now ~>
21:14:05 <jle`> they actually define it on page 4
21:15:34 <jle`> wikipedia has a good example of what defunctionalization is in https://en.wikipedia.org/wiki/Defunctionalization
21:15:41 <jle`> it actually uses haskell code incidentally
21:16:14 <jle`> the basic idea is that instead of actually working with functions, you work with a data type whose constructors are all of the possible functions
21:16:35 <jle`> and then you write one master "interpret" function that pattern matches on that type and interprets the functions they represent
21:17:03 <jle`> kind of the like expression data type that a lot of haskell intro classes use
21:17:21 <jle`> data Expr = Lit Int | Add Expr Expr | Mul Expr Expr
21:17:24 <dataN> they write; DropWhileEnd p eta1 = (FoldrSym0 @@ (LambdaSym0 @@ p @@ eta1) @@ NilSym0) @@ eta1
21:17:32 <dataN> but dont define FoldrSym0
21:18:13 <jle`> Section 4 describes this a bit more
21:18:23 <jle`> FoldrSym0 is the defunctionalized "constructor" of Foldr
21:18:32 <dataN> so its derived?
21:19:13 <jle`> not necessarily 
21:19:18 <jle`> you could manually defunctionalize Foldr
21:19:20 <dataN> oh, so these suffix numbers are something to do with these possible functions?
21:19:31 <jle`> FoldrSym0 is the naming convention for a defunctionalized Foldr
21:20:04 <jle`> remember that defunctionalization transforms functions into constructors representing functions
21:20:19 <jle`> and FoldrSym0 is the name of the constructor that Foldr is defunctionalized as
21:20:22 <jle`> as a naming convention
21:20:31 <koz_> jle`: I'm having a bit of trouble with the interaction of singletons and injective type families.
21:20:55 <koz_> Let me paste two relevant files.
21:21:14 <koz_> Actually just one, OK.
21:22:02 <jle`> dataN: defunctionalization associates each function with a constructor of a data type that represents all possible functions, and FoldrSym0 is, by naming convention, the constructor of that data type that represents the Foldr function
21:22:57 <dataN_> we could start from this; https://lpaste.net/2877566992410214400
21:23:00 <jle`> honestly i think it's a little ugly still, after using singletons for almost two years now, but it's what we have i guess heh
21:23:28 <jle`> dataN_: ah yeah, did you read my previous messages before you just joined?
21:23:34 * hackage hw-ip 0.2.0.3 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-0.2.0.3 (haskellworks)
21:23:40 <jle`> dataN_: right, that's Foldr, a type family, a type level "function"
21:23:55 <jle`> so defunctionalization transforms functions into just normal constructors, non-functions
21:24:04 <koz_> jle`: Paste here: https://lpaste.net/8979599137766899712
21:24:28 <dataN_> last message I had was from koz referring to 2 pastes 
21:24:39 <jle`> dataN_: so if your function is called Foldr, we can create a constructor FoldrSym0 that represents Foldr
21:24:47 <jle`> dataN_: ah yeah there was one mssage after that and before you joined
21:25:19 <jle`> koz_: any way you can make the example a little smaller heh
21:25:48 <koz_> jle`: Let me see if I can remove a few unnecessary details.
21:26:44 <koz_> The line numbers won't match up, but the errors _should_ still be consistent - I don't really wanna delete that code.
21:26:55 <koz_> jle`: Better? https://lpaste.net/32922303008342016
21:30:28 <jle`> koz_: hm, what happens if you simplify ValueType
21:30:36 <koz_> jle`: I _just_ thought I'd try it.
21:30:46 <jle`> ValueType (Attribute 'Discrete 'Mandatory a) = a
21:31:08 <jle`> er
21:31:14 <koz_> The type family becomes non-injective then.
21:31:33 <jle`> hm
21:31:44 <koz_> And I think I'd need to grab _two_ singletons to make that work.
21:31:49 <jle`> does it?
21:31:53 <koz_> Since it needs to know both t and p to decide.
21:31:53 <jle`> ah i see
21:32:25 <jle`> i think the problem is the forall a part
21:32:46 <jle`> try matching on Disc vs Cont
21:32:57 <koz_> Ah yeah, that might do it.
21:32:58 <jle`> then it won't be trying to match forall a, but Disc and Cont
21:33:05 <dataN_> this looks like a good definition what you describe, from the paper; "To write the instances for our defunctionalized symbols, we must create a new symbol for every level of partial application."
21:33:34 <jle`> dataN_: yeah, that's essentially it
21:33:55 <jle`> the "every level of partial application" is the part that makes it a little more confusing
21:33:57 <koz_> Yep, that does it!~
21:34:02 <jle`> koz_: hooray :D
21:34:03 <dataN_> oh right, and then they swap the -> and ->> around...
21:34:20 <jle`> dataN_: it might be easier to understand defunctionalization by looking at single-argument type families first
21:34:23 <koz_> I'm _slowly_ getting the hang of all this dependent typing magic.
21:34:31 <jle`> and moving on to multi-argument type families after you have a firm grasp of that
21:34:39 <dataN_> functor would be fine...
21:34:40 <jle`> koz_: moving faster than me probably :)
21:34:49 <jle`> dataN_: functor?
21:34:51 <koz_> jle`: My background is logic and data structures.
21:34:56 <dataN_> Fmap
21:35:02 <koz_> So as long as I understand it from those perspectives, it actually isn't too weird.
21:35:04 <jle`> fmap still has two arguments so it might be confusing
21:35:17 <jle`> koz_: it's good to be able to hold on to some foundation :) less vertigo that way for sure
21:35:23 <jle`> once you make the connection things become nicer
21:35:29 <dataN_> oh right, yeah, the only problem is with partially applied type families
21:35:32 <koz_> It's one reason I like Haskell so much.
21:35:44 <koz_> I don't have to do _two_ levels of translation to go from theory to code.
21:35:49 <jle`> dataN_: try first naybe type family Negate (b :: Bool) :: Bool where Negate 'True = 'False; Negate 'False = 'True
21:35:57 <koz_> (well, two is best-case scenario for most proglangs)
21:37:48 <jle`> dataN_: creating the symbol you'd get data NegateSym0 (tf :: TyFun Bool Bool)
21:38:04 <dataN_> jle': so far have this; https://lpaste.net/2643125171765903360
21:38:49 <dataN_> the problem was that writing Ones required type level All, which required unstaturated type families
21:39:23 <jle`> dataN_: right, this is the problem that defunctionalization eventually solves
21:39:30 <dataN_> so really, the two argument type functions are the more relevant 
21:39:39 <dataN_> :t all
21:39:40 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
21:39:49 <dataN_> :t fmap
21:39:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:39:56 <jle`> instead of 'All' taking an (a -> Bool), it will instead take a *regular data type*
21:40:02 <jle`> that "represents" an a -> Bool
21:40:11 <dataN_> oh
21:40:29 <koz_> jle`: OK, now I'm getting this: https://lpaste.net/8677687718819397632
21:40:31 <jle`> so that's why i suggest writing a defunctionalized (a -> Bool)
21:40:31 <dataN_> :t (==1)
21:40:33 <lambdabot> (Num a, Eq a) => a -> Bool
21:40:44 <koz_> I'm not sure why it assumes a 'fresh' type for go2 as opposed to the Cont a it should be.
21:40:57 <jle`> dataN_: try defunctionalized IsZero
21:41:03 <jle`> *defunctionalizing IsZero
21:41:03 <dataN_> ok
21:41:22 <jle`> the data type you'll create will be `data IsZero (tf :: TyFun N Bool)`
21:41:31 <jle`> the tf type parameter is "phantom"
21:41:34 <dataN_> thanks
21:41:39 <jle`> and really, that's it
21:41:54 <dataN_> oh, but where is the type family?
21:41:56 <jle`> er sorry, data IsZeroSym0 (tf :: TyFun N Bool)
21:42:20 <jle`> so now when you call `All`, you won't give it IsZero
21:42:27 <dataN_> shouldnt we expect 'type family IsZero a :: Bool'
21:42:30 <jle`> you'll give it IsZeroSym0, a regular data type
21:42:53 <jle`> at this point you will write All to accept a (N ~> Bool)
21:43:05 <jle`> so you'll write All to accept an (N ~> Bool)
21:43:13 <jle`> which is the exact kind that IsZeroSym0 has
21:44:22 <jle`> koz_: does it work if you manually specify 'a' with type applications?
21:44:24 <dataN_> @let data TyFun :: * -> * -> *
21:44:26 <lambdabot>  Defined.
21:44:34 <koz_> jle`: Where would I need to specify it?
21:44:41 <dataN_> @let data IsZeroSym0 (tf :: TyFun N Bool)
21:44:42 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
21:44:57 <jle`> koz_: "...arising from use of `HS.insert`", that's where I'd start
21:46:08 <jle`> koz_: or you can just add the Hashable constraints directly in the function's constraints
21:47:37 <koz_> By 'function' you mean go2?
21:47:48 <jle`> koz_: uniqueValues ?
21:47:56 <koz_> I did though.
21:48:07 <koz_> forall t p a . (Hashable (ValueType (Attribute t p a)) ..
21:48:12 <jle`> i mean Hashable (Cont a)
21:48:21 <koz_> Oh wait, you can do that?
21:48:27 <jle`> why not :)
21:48:44 <jle`> it might not be what you want in the end (you might only want to require Hashable (Cont a) in some situations) but it's worth seeing if it works i think heh
21:49:02 <koz_> Nope, that doesn't help.
21:49:11 <koz_> It still complains about the Cont a1 thing.
21:49:20 <koz_> I don't understand why it assumes the type is _different_.
21:51:10 <jle`> what is your version with the type applications?
21:51:28 <jle`> and remember in haskell type variables are assumed to be different unless proven to be the same
21:51:34 <koz_> How would I write that?
21:52:13 <jle`> make sure that type of HS.insert is what you think it is
21:52:54 <koz_> So would I need to replace (`HS.insert` hs) with something like (`HS.insert` hs :: Cont a -> HS.HashTable (Cont a))?
21:52:59 <koz_> Or is that not how you phrase it?
21:53:32 <jle`> something like that yeah, or (\k -> HS.insert @(Cont a) k hs), maybe
21:53:37 <jle`> depending on how the type variables are arranged
21:54:22 <buhman> fhttps://ptpb.pw/dPq1
21:54:44 <koz_> jle`: Ah, occurs check on HS.toList. Apparently trying to construct a1 ~ Cont a1 won't go well.
21:54:51 <buhman> https://ptpb.pw/dPq1/hs ; is there a way to do that, only actually working?
21:55:02 <koz_> Since I apparently _expect_ an '[a]', but giving a '[Cont a]'.
21:55:23 <koz_> OH EMM GEE.
21:55:29 <koz_> I am a colossal dork.
21:55:35 <jle`> it happens to all of us :)
21:55:51 <koz_> If you look at ContAttribute's definition, my idiocy will be laid completely bare.
21:57:20 <dataN_> jle': it gives this error; https://lpaste.net/398264191279955968
21:58:22 <dminuoso> Hiya. Is there a more concise way to write this? https://gist.github.com/dminuoso/35fbc2b8118187afab4d3403996f6e4d
21:58:35 <dminuoso> Im thinking there must be a way more expressive way
21:58:37 <koz_> jle`: Thanks so much!
21:59:36 <koz_> jle`: Is there some way to not have to have go and go2 as separate functions like that? They're _awfully_ similar.
22:00:21 <dataN_> buhman: try; data RLE a = RLE (Int, a) | a
22:01:03 <jle`> dataN_: you probably want to define an instance for Apply
22:01:13 <jle`> dataN_: Apply is the type family, not @@
22:01:41 <jle`> @@ is just a type synonym
22:01:41 <lambdabot>  is just a type synonym
22:01:47 <jle`> thanks lambdabot
22:01:52 <MarcelineVQ> @botsnack
22:01:52 <lambdabot> :)
22:01:52 <dataN_> haha
22:02:15 <dataN_> the paper is slightly confusing for that
22:02:38 <jle`> yeah heh, the paper defines (@@) as the type family, but in this case Apply is
22:02:59 <koz_> Gotta have everything look like lens^W^W^Wbe infix.
22:03:51 <jle`> koz_: what happens when you just combine them?
22:03:56 <jle`> just use go only?
22:04:59 <jle`> uniqueValues (Column a v) = case a of DiscAttribute _ -> go v sing; COntAttribute _ -> go v sing
22:05:18 <dataN_> should it be possible to derive Map from Foldr ?
22:05:32 <jle`> dataN_: do you mean define Map in terms of Foldr?
22:05:45 <dataN_> yeah sure
22:05:49 <jle`> yeah, map f = foldr ((:) . f)
22:05:57 <jle`> er, foldr ((:) . f) []
22:05:59 <dataN_> no but with type families
22:06:07 <fragamus> I need a little help with deriving an aeson instance https://gist.github.com/fragamus/1662aadf0929a9f9df97c1be9aaa8df4
22:06:13 <jle`> yeah, it should be the same thing, just defunctionalized
22:06:24 <dataN_> *yikes*
22:06:45 <koz_> jle`: I get my ValueType (Attribute t 'Mandatory a) ~ a deduction problem again.
22:06:59 <jle`> dataN_: singletons has TH to automatically defunctionalize, but that's no fun, right :)
22:07:08 <koz_> jle`: I see what you did there.
22:07:32 <dataN_> jle': it wouldnt be the same
22:07:34 <jle`> koz_: even if you take v as an argument?
22:07:53 <jle`> dataN_: basically you'd have to defunctionalize (.) as well
22:08:18 <dataN_> ok, that would probably have been the complication
22:08:23 <koz_> jle`: Nope, not even then.
22:08:34 <jle`> hm
22:08:40 <jle`> oh, maybe put the pattern match in the definition of go
22:08:48 <jle`> er wait then you'd still ahve to duplicate
22:09:03 <koz_> Is it because the type synonym family needs to know t as well?
22:09:13 <koz_> I can slap that in a singleton and pass it along too if it helps.
22:09:40 <jle`> that might be it, worth a shot :)
22:10:06 <jle`> dataN_: the naming convention for defunctionalized infix operators is pretty gross tho
22:10:14 <koz_> So the function call will be 'go sing sing'.
22:10:16 <koz_> :D
22:10:18 <jle`> :D
22:11:08 <dataN_> it would just be ComposeSym0 ?
22:11:16 <cocreature> now I want irc to be a voice chat so I can hear koz_ singing
22:11:36 <koz_> cocreature: You can watch my stream on Twitch if you want an idea of my singing voice.
22:11:44 <koz_> If you tune in to my next one, I'll sing a song for you. :P
22:11:55 <jle`> dataN_: yeah, you can call it that.  the convention in the paper is :.$
22:12:09 <cocreature> koz_: send me the link when you’re streaming :)
22:12:23 <koz_> cocreature: What timezone are you in?
22:12:30 <jle`> dataN_: except, (:.$) is a function that takes "3" arguments
22:12:41 <cocreature> koz_: CEST
22:12:54 <jle`> dataN_: so this is definitely a new type of beast
22:13:04 <koz_> Ah, so UTC+2.
22:13:21 <koz_> I'm UTC+12.
22:13:29 <jle`> dataN_: try another example of a two-argument function first, like Xor, maybe
22:13:32 <koz_> Might have to stream early just for you. :P
22:13:48 <jle`> dataN_: so this is the trick to make things generalize
22:14:04 <jle`> XorSym0, you'd want to have be Bool ~> (Bool ~> Bool)
22:14:19 <dataN_> so its just the same except it needs to pass to the next most partially applied version...
22:14:24 <jle`> er, well.  i meant to say, you might initially think you want Bool ~> (Bool -> Bool)
22:14:36 <jle`> return a type family, essentially
22:14:45 <jle`> but, it makes a lot more sense if Bool ~> (Bool ~> Bool)
22:14:50 <maerwald> it seems cabal2nix is kinda of broken, because it depends on nix-specific shell scripts when running
22:14:50 <jle`> it's more versatile
22:15:16 <cocreature> koz_: twitch can record streams ;)
22:15:20 <jle`> we basically have XorSym0 "return" a *new* defunctionalization symbol, Bool ~> Bool
22:15:26 <koz_> cocreature: Oh, you can watch a recording of me then.
22:15:36 <koz_> I'll sing on stream just for you and give you the link.
22:15:53 <koz_> (and confuse the hell out of my audience, just for extra fun)
22:16:12 <jle`> dataN_: and we call *that* one XorSym2 b
22:16:33 <jle`> so the full set of defunctionalzation symbols for Xor are:
22:16:53 <jle`> data XorSym2 (b :: Bool) (tf :: TyFun Bool Bool)
22:17:02 <jle`> or data XorSym2 :: Bool -> (Bool ~> Bool)
22:17:09 <jle`> er sorry, XorSym1
22:17:17 <dataN_> right
22:17:18 <jle`> data XorSym1 (b :: Bool) (tf :: TyFun Bool Bool)
22:17:29 <jle`> the 1 mnemonic is "it expects one actual Bool argument"
22:17:36 <jle`> and then we write
22:17:45 <jle`> data XorSym0 :: Bool ~> (Bool ~> Bool)
22:17:58 <jle`> type instance Apply XorSym0 b = XorSym1 b
22:18:04 <dataN_> data XorSym2 :: Bool -> Bool -> Bool
22:18:14 <dataN_> or does it not go that far?
22:18:14 <jle`> type instance Apply (XorSym1 b) c = Xor b c
22:18:22 <jle`> dataN_: that's not necessary, because XorSym2 is just Xor
22:18:36 <dataN_> ah, ok
22:18:36 <jle`> oh, actually it would be useful
22:18:41 <jle`> hm let me check
22:18:56 <koz_> @pl \x hs -> Maybe hs (`HS.insert` hs) x
22:18:56 <lambdabot> flip (ap Maybe (flip HS.insert))
22:19:06 <jle`> ah yeah, we do go that far. it's useful because it can be partially applied
22:19:09 <koz_> Wait whoops.
22:19:13 <koz_> @pl \x hs -> maybe hs (`HS.insert` hs) x
22:19:13 <lambdabot> flip (ap maybe (flip HS.insert))
22:19:43 <dataN_> the paper just gives it is a type synonym
22:19:46 <jle`> dataN_: actually, hm, nevermind
22:19:49 <jle`> yeah, you're right
22:19:51 <jle`> i wonder why it exists
22:19:58 <jle`> it might just exist for consistency's sake
22:21:07 <jle`> ah yeah, that's what the paper says: "The definition for MapSym2 is not strictly necessary in our scheme; it is included to parallel ..."
22:21:12 <jle`> so it's just there for consistency
22:21:21 <dataN_> seems so
22:21:33 <jle`> it makes the Apply instances a little more symmetric
22:21:39 <dataN_> ok, this might take some time
22:21:44 <jle`> type instance Apply XorSym0 a = XorSym1 b
22:22:01 <dataN_> Map via Foldr using (:.$)
22:22:01 <jle`> type instance Apply (XorSym1 a) b = XorSym2 a b
22:22:17 <jle`> instead of, what I wrote earlier, type instance Apply (XorSym1 a) b = Xor a b
22:22:24 * jle` shrugs
22:23:44 <jle`> dataN_: so since you're directly applying (.), you can just use (:.$$$)
22:23:47 <dataN_> right, with; type XorSym2 = Xor
22:23:48 <jle`> instead of (:.$)
22:24:13 <jle`> the convention here is a little confusing so feel free to call it ComposeSym0, ComposeSym1, ComposeSym2, ComposeSym3
22:24:19 <jle`> (the last one optional)
22:24:53 <dataN_> it seems like a good convention, it matches the Arity, and represents complete application
22:24:56 <jle`> you can use ComposeSym2 because you have two arguments you can apply immediately, (:) and f
22:25:06 <jle`> ah yeah. maybe not confusing, but just ugly
22:25:21 <dataN_> oh, so why defunctionalize (:) at all?
22:25:29 <dataN_> if it does not need to be partially applied?
22:25:39 <jle`> well becuase the defunctionalized (.) takes a defunctioanlized symbol
22:26:13 <jle`> (:.$) :: (b ~> c) ~> (a ~> b) ~> (a ~> c)
22:26:50 <jle`> beucase that's sort of the whole point in the first place
22:27:12 <jle`> and, you can always convert a (a -> b) into an (a ~> b)
22:27:21 <dataN_> (:.$$) :: (b ~> c) -> (a ~> b) ~> (a ~> c)
22:27:23 <jle`> but you can't convert an (a ~> b) into an (a -> b) in the general case
22:27:43 <jle`> it's this problem that the whole defunctionalization system is meant to solve, essentially
22:27:56 <jle`> yup
22:28:10 <dataN_> thanks
22:28:56 <jle`> i'm not sure if the paper gives this, but the singletons library gives a way to directly turn any type constructor like (:) into a defunctionalization symbol
22:29:12 <jle`> it's called TyCon1, TyCon2, etc.
22:30:06 <jle`> data TyCon2 (tc :: a -> b -> c) (tf :: TyFun a (b ~> c))
22:30:18 <jle`> data TyCon1 (tc :: a -> b) (tf :: TyFun a b)
22:30:27 <jle`> type instance Apply (TyCon1 tc) a = tc a
22:30:47 <jle`> type instance Apply (TyCon2 tc) a = TyCon1 (tc a)
22:31:01 <jle`> this one is a little confusing because the 1, 2, 3 order is backwards from the Sym0, Sym1, Sym2 order, heh
22:31:47 <jle`> te singletons library actually has multi-arity TyCon constructor that works if you are not in a polykinded situation, so TyCon1 = Tycon, TyCon2 = TyCon, it's a cute trick
22:33:10 <koz_> jle`: This is as simple as I could make it: https://lpaste.net/7194772520967340032
22:34:17 <jle`> koz_: whoa, that's a big improvement :)
22:34:18 <koz_> Turns out my type synonym family was overconstrained.
22:34:31 <koz_> Since I could have just written this:
22:34:56 <koz_> https://lpaste.net/1573444011711004672
22:35:25 <koz_> Still not injective, which is somewhat sadface, but ultimately we can't have everything.
22:35:39 <jle`> oh yeah that was what i suggested earlier, but yeah it makes it not injective
22:35:51 <jle`> but do you take advantage of injectivity anywhere?
22:35:51 <koz_> It was already non-injective.
22:36:00 <koz_> I don't _think_ so.
22:36:14 <jle`> it was injective before i believe
22:36:18 <jle`> because it was partial
22:36:19 <koz_> Yeah, it was.
22:36:30 <jle`> now it's total :)
22:36:31 <koz_> So I guess I'm just being less dishonest. :P
22:36:49 <jle`> you went from an injective partial function to a non-injective total function
22:37:24 <jle`> singletons is hot tonight in #haskell
22:37:34 <koz_> No kidding.
22:37:43 <koz_> Although that was me cargo-culting and asking for help, a lot.
22:38:04 <koz_> I've been using a lot of phantom types lately though, and promoting a lot of stuff.
22:38:30 <jle`> phantom types are a really good balance i think at where haskell still feels "natural" to some extent
22:38:42 <koz_> Yeah, but you hit the wall pretty quickly.
22:39:22 <koz_> Once you start having to inform your first-year logic student^W^W^Wcompiler about what exactly which phantom demonstrates about what.
22:40:37 <koz_> And all this because I wanted a typesafe way to write the Gamberger-Lavrac feature construction algorithm.
22:41:21 <jle`> one neat thing about haskell is that you often look at a program you wrote 3 or 6 months ago and see a way to re-write it in a cleaner and simpler way once you see the higher level of what you were struggling with at the time
22:41:35 <jle`> this type level stuff often is the same way, i've found
22:41:44 <koz_> This is story of my life in Haskell right there.
22:49:39 <Hotkeys> I just spent an hour wrapping my head around "powerset = filterM (const [True, False])"
22:49:46 <Hotkeys> fun times
22:49:50 <koz_> Hotkeys: Yeah, I've seen that one.
22:49:54 <koz_> It's pretty miraculous.
22:50:53 <jle`> cute af
22:51:31 <Hotkeys> I ended up having to look at the definition of filterM to properly grok it
22:52:11 <jle`> powerset xs = do x <- xs; choice <- [True, False]; guard choice; pure x
22:53:46 <jle`> oh wait that is wrong
22:53:56 <jle`> oops
22:54:40 <jle`> @let maybepowerset xs = do x <- xs; choice <- [True, False]; guard choice; pure x
22:54:40 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
22:54:51 <jle`> @let maybepowerset xs = do { x <- xs; choice <- [True, False]; guard choice; pure x }
22:54:51 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
22:55:03 <jle`> % let maybepowerset xs = do x <- xs; choice <- [True, False]; guard choice; pure x
22:55:03 <yahb> jle`: 
22:55:09 <jle`> % maybepowerset "abc"
22:55:09 <yahb> jle`: "abc"
22:55:14 <jle`> hehe
22:55:43 <koz_> % filterM (const [True, False]) [1,2,3]
22:55:43 <yahb> koz_: [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
22:55:47 <koz_> Woah.
22:56:06 <Hotkeys> I ended up breaking it down to the first step
22:56:23 <jle`> list is the "probability" monad, so (\_ -> [True, False]) is splitting things up into "inclusion or exclusion" choices
22:56:25 <Hotkeys> % ((\ flg -> if flg then (x:) else id) <$> [True, False] <*> [[]]
22:56:25 <yahb> Hotkeys: ; <interactive>:40:64: error: parse error (possibly incorrect indentation or mismatched brackets)
22:56:26 <jle`> and each item gives you a split
22:56:29 <Hotkeys> oops premature
22:56:38 <Hotkeys> % (\x -> (\ flg -> if flg then (x:) else id) <$> [True, False] <*> [[]]) 1
22:56:39 <yahb> Hotkeys: [[1],[]]
22:57:09 <Hotkeys> doing this ^ is what made it click for me
23:02:41 <dataN_> ok, this works; https://lpaste.net/6530644962097233920
23:02:44 <dataN_> thats Xor
23:03:30 <dataN_> but for (.) its more complicated because it should have 'Compose f g x' where there is an another argument 
23:03:31 <jle`> nice :)
23:04:23 <jle`> i'd build things up step by step
23:05:00 <koz_> > bool 1 2 True
23:05:00 <jle`> hm, but for the final type family you mean
23:05:02 <lambdabot>  2
23:05:30 <dataN_> also not sure how to use TyCon; https://lpaste.net/8585069287406829568
23:05:34 <jle`> dataN_: type family Compose (f :: b ~> c) (g :: a ~> b) (x :: a) :: c where Compose f g x = f @@ (g @@ x)
23:06:05 <jle`> and you do need UndecidableInstances, yes
23:06:20 <jle`> er, i think so
23:06:37 <dataN_> and then the (:.$$) needs another argument?
23:07:02 <jle`> your (:.$$) looks right
23:07:16 <jle`> remember that (b ~> c) -> (a ~> b) ~> (a ~> c)
23:07:24 <jle`> is really just (b ~> c) -> (a ~> b) ~> a ~> c
23:08:17 <jle`> it's just that the "fully saturated" version will be (:.$$$$), not (:.$$$)
23:08:23 <dataN_> ah
23:08:57 <jle`> and if you're going to call them (:.$), (:.$$), etc., might as well call the type family (.), not Compose :)
23:09:10 <dataN_> ok, so it has arity 4 because its composing functions, and the last set of parenthesis are dismantled 
23:09:17 <jle`> type family (.) (f :: b ~> c) (g :: a ~> b) (x :: a) :: c where (f . g) x = f @@ (g @@ x)
23:09:35 <jle`> dataN_: well, arity 3
23:09:43 <jle`> it's the same deal as the value-level (.)
23:09:47 <dataN_> Illegal symbol '.' in type
23:09:48 <jle`> :t (.)
23:09:49 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:09:52 <jle`> dataN_: aw man
23:10:00 <jle`> that makes me sad
23:10:43 <mniip> dataN_, TypeOperators
23:10:56 <mniip> that or
23:10:59 <mniip> (.) f g x = ...
23:11:21 <dataN_> TypeOpperators is on...
23:11:46 <mniip> % type family (.) (f :: b -> c) (g :: a -> b) (x :: a) :: c where (f . g) x = f (g x)
23:11:46 <yahb> mniip: ; <interactive>:42:14: error:; Illegal symbol '.' in type; Perhaps you meant to write 'forall <tvs>. <type>'?
23:11:51 <mniip> % type family (.) (f :: b -> c) (g :: a -> b) (x :: a) :: c where (.) f g x = f (g x)
23:11:51 <yahb> mniip: ; <interactive>:43:14: error:; Illegal symbol '.' in type; Perhaps you meant to write 'forall <tvs>. <type>'?
23:11:56 <mniip> curious
23:11:56 <jle`> it might just be that (.) is not a legal name for a type
23:12:04 <mniip> possibly
23:12:05 <jle`> i can see why it might cause confusion
23:12:12 <dataN_> thats why it needs a : prefix right?
23:12:20 <jle`> forall a. . a -> . a
23:12:42 <jle`> dataN_: that's why the singletons library defines it as (:.), but it doesn't necessarily have to be (:0
23:13:43 <dataN_> no? something about capitalised symbols?
23:13:55 <jle`> it could be (..) too
23:14:15 <jle`> % type family (..) (f :: b -> c) (g :: a -> b) (x :: a) :: c where (..) f g x = f (g x)
23:14:15 <yahb> jle`: ; <interactive>:44:14: error: parse error on input `..'
23:14:18 <jle`> oh maybe not
23:14:40 <jle`> dataN_: ah, actually yeah i think you're right
23:14:47 <jle`> hm.
23:14:59 <jle`> no, it's weird because (++) is an allowed type family name
23:15:26 <jle`> % type family (+.) (f :: b -> c) (g :: a -> b) (x :: a) :: c where (+.) f g x = f (g x)
23:15:26 <yahb> jle`: 
23:15:30 <jle`> yeah, that works
23:15:54 <jle`> we're reaching the sort of obscure edge cases of haskell syntax heh
23:17:24 <jle`> % type family (...) (f :: b -> c) (g :: a -> b) (x :: a) :: c where (...) f g x = f (g x)
23:17:24 <yahb> jle`: 
23:17:50 <dataN_> this works; https://lpaste.net/6885263944823341056
23:17:57 <jle`> i think it's just that "." (at the type level) and ".." (at both type and value) are reserved as syntax keywords
23:18:14 <jle`> so you can't have a value called (..), and you can't have a type called (.)
23:18:20 <dataN_> ok that makes sense
23:18:34 <jle`> since they are syntax keywords
23:18:46 <jle`> it's the same as, say, not allowing 'of' as a value or variable
23:18:49 <jle`> or 'if'
23:19:23 <dataN_> but how were the TyCon supposed to be used? did they enable some brevity?
23:19:46 <jle`> TyCon2 :: (a -> b -> c) -> (a ~> b ~> c)
23:20:02 <jle`> so you'd use it to create an insta defunctionalization symbol for (:)
23:20:24 <jle`> because now you have `TyCon2 (:) :: a ~> [a] ~> [a]`
23:20:56 <jle`> which is something you can give to (:.$$$), since it matches the shape of its first argument
23:20:56 <dataN_> so can the arity 4 version be used for (.)?
23:21:17 <jle`> (:.$$$) :: (b ~> c) -> (a ~> b) -> (a ~> c)
23:21:27 <jle`> and you can give TyCon2 (:) to (:.$$$)
23:21:37 <jle`> dataN_: in your case you'd be using the two-argument form
23:22:09 <dataN_> TyCon2 (:.)
23:22:12 <jle`> you can't give (:) directly to (:.$$$) etc., because they take (b ~> c) and (:) is an (b -> ...)
23:22:23 <jle`> dataN_: remember that the function we are lifting is:
23:22:30 <jle`> map f = foldr ((:) . f) []
23:22:37 <dataN_> oh
23:22:42 <jle`> we need to give (:) and f to (.)
23:22:59 <jle`> that is, we need to give (':) and f to (:.$$$)
23:23:22 <jle`> but (:.$$$) expects something of the form (b ~> c), but (':) is of form (b -> ...)
23:23:34 <jle`> it expects a defunctionalization symbol, not an actual function
23:23:40 <dataN_> right
23:24:20 <jle`> so we use `TyCon2 '(:)` to create an "instant" defunctionaliation symbol for (:)
23:24:52 <jle`> so we can use TyCon2 '(:), instead of manually defining new defunc symbols from scratch like we did for Xor, IsZero, (.), etc.
23:25:14 <jle`> you *could* manually define defunc symbols, if you wanted to, using the same scheme
23:25:30 <jle`> TyCon2 is just a nice combinator that can automatically give us a defunc symbol for any type constructors
23:26:29 <jle`> it might be a nice exercise to manually define the defunc symbols for '(:) (ConsSym0, ConsSym1, the optional ConsSym2)
23:26:44 <jle`> but since you already defined the defunc symbols for Xor and (.), i don't think it'd teach you much at this point
23:26:58 <jle`> as in, it's basically as trivial as defining the defunc symbols for Xor
23:27:06 <jle`> s/trivial/complex
23:27:54 <dataN_> so can the (:.) and Xor be rewritten using this same trick?
23:28:01 <jle`> the reason why we can't use TyCon2 for Xor and skip defining XorSym0/XorSym1 is that `TyCon2 tc` requires that tc can be partially applied
23:28:08 <jle`> but Xor and (:.) cannot be partially applied
23:28:34 <jle`> so, the TyCon1/TyCon2/etc. trick only works for a -> b -> c's that can be partially applied.  so, basically, only type constructors (and not type families or type synonyms)
23:28:58 <dataN_> fine
23:29:33 <dataN_> slightly confused about Foldr though
23:29:37 <jle`> `TyCon2 Xor` isn't valid because Xor the type family can't be partially applied, but `TyCon2 '(:)` is valid because '(:) the type constructor can be partially applied
23:29:53 <dataN_> as in, it takes a defunctionalisation, but why bother actually defunctionalising it?
23:30:05 <jle`> so we basically internalize this as "TyConN is a trick for type consturctors"
23:30:19 <jle`> dataN_: well, then we can give partially applied functions to it
23:30:23 <jle`> like ((:) . f)
23:30:46 <jle`> if it took an actuall (a -> b -> b), then we can't pass in anything partially applied
23:31:04 <jle`> (except for type constructors)
23:31:04 * hackage antiope-contract 6.0.2 -   http://hackage.haskell.org/package/antiope-contract-6.0.2 (newhoggy)
23:31:13 <dataN_> type family Foldr (a ~> b ~> b) -> [a] :: [b]
23:31:36 <dataN_> :: b, sorry
23:32:00 <jle`> it's the same situation as type family (:.) (f :: b ~> c) (g :: a ~> b) (x :: a) :: c
23:32:04 * hackage antiope-athena 6.0.2 -   http://hackage.haskell.org/package/antiope-athena-6.0.2 (newhoggy)
23:32:08 <jle`> (:.) is defined to take *defunctionalization symbols*
23:32:22 <jle`> same as Foldr
23:32:36 <dataN_> type family Foldr (f :: a ~> b ~> b) (xs :: [a]) :: b
23:33:04 * hackage antiope-sqs 6.0.2, antiope-sns 6.0.2, antiope-s3 6.0.2, antiope-messages 6.0.2, antiope-dynamodb 6.0.2, antiope-core 6.0.2 (newhoggy)
23:33:28 <dataN_> still not sure that (:.) needed defunctionalising 
23:34:52 <jle`> type family Foldr (f :: a ~> b ~> b) (z :: b) (xs :: [a]) :: b
23:35:04 <dataN_> oh right
23:35:23 <jle`> dataN_: the main idea is to eliminate functions completely, and work only with defunctionalization symbols
23:35:30 <jle`> the whole way through
23:35:45 <jle`> that way we don't have to ever worry about partial applications, higher order functions, etc.
23:36:06 <jle`> remember the Expr data type that is often used intro to haskell classes:
23:36:08 <dataN_> Foldr is a higher order function...
23:36:20 <jle`> data Expr = Lit Int | Add Expr Expr | Mul Expr Expr
23:36:33 <jle`> we don't have anyt functions.  we just have a nested collection of non-function data types
23:36:36 <jle`> dataN_: ah, but is it? ;)
23:36:47 <jle`> (f :: a ~> b ~> b) is not a higher order function
23:36:53 <jle`> it's just a non-function data type
23:37:30 <jle`> we're replacing functions (like a -> b -> b) with non-function tokens/symbols/data types
23:37:43 <jle`> don't be fooled by the ~> looking like an arrow
23:37:59 <jle`> an (a ~> b ~> b) is not a function, the choice of (~>) is just to trick the brain
23:38:12 <jle`> it just looks like (->), but only at a superficial level
23:38:17 <jle`> at the typographical level
23:38:45 <jle`> a type of kind (a ~> b ~> b) is not a function, but a fully saturated data type, like `IO Int` or `Double`
23:39:28 <jle`> it's basically like defining `type a ~~> b = Either a b`.... `a ~~> b` looks typographically like a function, but it really isn't.
23:41:29 <jle`> (technically it's not fully saturated at the implementation level, but you should think of it as a non-function symbol or token)
23:42:57 <jle`> the entire idea of defunctionalization is to replace all functions with symbols/tokens representing functions. it's done for a variety of reasons in compiler implementations, but in our case the main purpose is to allow partially applied type families to work.  because we no longer pass around type families, but, rather, tokens/symbols representing type families
23:43:10 <maerwald> stack is not buildable with ghc-8.4?
23:43:15 <dataN_> jle': ok, heres Foldr working https://lpaste.net/5098956268681297920
23:43:39 <jle`> dataN_: nice :)
23:44:04 <jle`> now the next part is to *construct* something of essentially the same kind as XorSym0
23:44:19 <jle`> an `a ~> [b] ~> [b]`, this time
23:44:35 <jle`> you are given:
23:44:50 <jle`> TyCon2 '(:) :: b ~> ([b] ~> [b])
23:45:21 <dataN_> ok
23:45:26 <jle`> (:.$$$) (f :: a ~> b) (g :: b ~> c) :: a ~> c
23:45:36 <jle`> er, swap the a/b/c's in those,
23:45:50 <jle`> and `someUserFunc :: a ~> b`
23:46:39 <jle`> one way you can look at this is that `:.$$$` is a type constructor that takes two defunctionalization symbols and returns a new defunctionalization symbol
23:47:06 <jle`> so you want to make a defuncationalization symbol...so just give :.$$$ two defunctionalization symbols :)
23:50:21 <maerwald> is there a way to tell stack to generate a specific .cabal file with its internal hpack version?
23:51:54 <jle`> maerwald: what do you mean exactly?
23:52:07 <jle`> if you want a specific .cabal file, you can just use the one you are referring to?
23:52:11 <MarcelineVQ> is there a way to use stack 'as hpack'?
23:52:11 <jle`> instead of using hpack
23:52:22 <maerwald> jle`: hpack generates .cabal files
23:52:26 <dminuoso> How do I efficiently generate alpha numeric (ascii) bytestrings with QuickCheck?
23:52:37 <maerwald> stack has an internal hpack version to do that
23:52:42 <maerwald> but you have no control over what it does
23:52:45 <jle`> maerwald: yes, but if you have a specific .cabal file you want, and you already have it on hand, then you can just use the one you have on hand, right?
23:52:50 <maerwald> no
23:53:00 <maerwald> I want to generate the .cabal file via stack
23:53:12 <maerwald> because if you use hpack directly, stack will start ignoring it
23:53:12 <jle`> from a specific package.yaml file?
23:53:15 <dminuoso> Asking because this is (obviously) hilariously inefficient: arbitrary `suchThat` all isAscii
23:53:19 <maerwald> yes, that's what hpack does
23:53:37 <dminuoso> (or equivalent)
23:54:19 <jle`> dminuoso: if you're using QuickCheck you can make an arbitrary [OnlyAscii], where OnlyAscii is a newtype wrapper over Char whose arbitrary instance generates only ascii chars
23:54:29 <jle`> this is one situation where i think libs like hedgehog shine
23:55:02 <maerwald> MarcelineVQ: yeah, something like 'stack hpack'
23:55:21 <dminuoso> jle`: Mmm, and then just `pack` that String for the `OnlyAsciiBS` Arbitrary instance?
23:55:25 <maerwald> you can't write a shake rule for .cabal files because stack just generates everything and doesn't let you control how hpack is invoked
23:55:44 <maerwald> if you use hpack directly, stack will complain that .cabal has been modified and will not regenerate ever again
23:56:07 <MarcelineVQ> have you experimented with --with-hpack already?
23:56:10 <dminuoso> Oh..
23:56:15 <dminuoso> :k ASCIIString
23:56:17 <lambdabot> *
23:57:05 <dataN_> should Map use Foldr1?
23:57:29 <dataN_> and guard for the empty list?
23:57:46 <maerwald> MarcelineVQ: not an option, this has to be transparent, because other people use plain 'stack'
23:58:11 <maerwald> for the docker configuration however, I need to generate .cabal files manually
23:58:13 <MarcelineVQ> maerwald: One thing to check is the stack hpack and your hpack you tried to gen the cabal with the same version? Maybe it's making a different version or hash and this is why stack is discounting it
23:59:00 <MarcelineVQ> note the metadata at the top of the generated cabal file for comparison
23:59:43 <MarcelineVQ> I've no idea if that's what stack checks though, or if it just compares file modified timestamp or w/e
