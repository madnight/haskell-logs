00:12:34 * hackage drifter-sqlite 0.1.0.0 - SQLite support for the drifter schema migraiton tool  http://hackage.haskell.org/package/drifter-sqlite-0.1.0.0 (MichaelXavier)
00:42:29 <mniip> hmm
00:42:33 <mniip> polykinded constructors
01:01:45 --- mode: glguy set +v titan_
01:50:26 <bwe> I am in a forM_ construct. How can I access the no. of the element, ie. a counter?
01:52:18 <cocreature> bwe: forM_ (zip [0..] xs) $ \(i, x) -> …
01:53:34 <julianleviston> forM_’s second argument is a Traversable. the length function takes a traversable.
01:54:05 <julianleviston> Sorry, first argument
01:54:26 <cocreature> julianleviston: length takes something that is an instance of Foldable to be precise
01:54:54 <julianleviston> Sorry, yeah I said Traversable instead of Foldable.
01:54:59 <julianleviston> My bad :)
01:55:17 <cocreature> but I’m also not sure how "length" really helps here
01:55:43 <julianleviston> s/he wanted to know the number of elements, not the “current index” necessarily
01:56:04 <cocreature> “counter” very much sounds like “current index” instead of the number of elements :)
01:56:07 <julianleviston> depends, I guess, what “in a forM_ construct” means.
01:56:29 <julianleviston> Oh, sorry, I didn’t read the question properly. Wow. utter fail. Sorry :)
02:01:12 <bwe> https://bpaste.net/show/6a6ba26fa2e2 -- may this be caused by OverloadedStrings?
02:02:07 <cocreature> bwe: no that is probably caused by you trying to treat segmentNr as if it was a Text
02:02:36 <cocreature> you probably need a "Text.pack (show segmentNr)" somewhere
02:03:19 <bwe> cocreature: Exactly. Works. I wondered about the place of the error being raised.
02:05:30 <cocreature> bwe: [0..] desugars to "enumFrom 0". you tried to use that as if it had type [Text] so GHC looks for an Enum instance of Text
02:06:02 <cocreature> if that instance existed you would get another error about Text not being an instance of Num
02:10:04 * hackage megaparsec 7.0.1 - Monadic parser combinators  http://hackage.haskell.org/package/megaparsec-7.0.1 (mrkkrp)
02:20:04 * hackage xml-conduit 1.8.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.8.0.1 (koral)
02:20:14 <xacktm> `cabal new-build` conceptually will leave garbage over time in the trash on the filesystem; is one supposed to collect them for removal?  If so, how?
02:23:02 <cocreature> xacktm: atm your best bet is to occassionally nuke the store
02:23:55 --- mode: glguy set +v Jetien
02:23:56 <xacktm> ok, kind of a bit much, but .. works I guess :)
02:24:19 <Jetien> Hi, is there a operator that lets me write this more elegantly?: runReaderT (evalStateT (runModuleRead x) Map.empty) paths
02:26:34 --- mode: glguy set +v aveltras
02:31:08 <aveltras> hi, has anyone encountered the problem where you can't build the package zlib-0.6.2 (brought as a dependency by warp-3.2.25) because it spits the error "* Missing (or bad) header file: zlib.h Missing (or bad) C library: z" ? I'm using cabal new-repl
02:31:36 <aveltras> i've installed many zlib packages through apt (im on ubuntu) but it doesn't change anything
02:32:33 <MarcelineVQ> did they end with -dev ? I think those are the ones that have header files, dunno though
02:33:10 <MarcelineVQ> -dev or -devel
02:33:28 <aveltras> yes i installed also the -dev versions of those packages, i've browsed google and didn t find answers to those who asked about the same issue
02:33:40 <MarcelineVQ> shucks
02:44:32 <julianleviston> :t loop
02:44:33 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
03:08:34 * hackage set-of 0.1.0.0 - Sets of fixed size, with typelits  http://hackage.haskell.org/package/set-of-0.1.0.0 (fresheyeball)
03:15:04 * hackage mmark 0.0.6.0 - Strict markdown processor for writers  http://hackage.haskell.org/package/mmark-0.0.6.0 (mrkkrp)
03:16:49 <cocreature> averell: does this only happen with new-repl, i.e., does new-build work?
03:40:34 * hackage http2-client-grpc 0.5.0.4 - Implement gRPC-over-HTTP2 clients.  http://hackage.haskell.org/package/http2-client-grpc-0.5.0.4 (LucasDiCioccio)
04:04:34 * hackage set-of 0.1.0.1 - Sets of fixed size, with typelits  http://hackage.haskell.org/package/set-of-0.1.0.1 (fresheyeball)
04:12:04 * hackage opaleye 0.6.7002.0 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7002.0 (tomjaguarpaw)
04:14:04 * hackage grpc-api-etcd 0.2.0.0 - Generated messages and instances for etcd gRPC.  http://hackage.haskell.org/package/grpc-api-etcd-0.2.0.0 (LucasDiCioccio)
04:31:09 --- mode: glguy set +v zhaskell
04:31:47 <zhaskell> Can you compile your project on one OS and then execute it under a different one or will this fail? (Assuming both are X86 Linux)
04:33:30 <acoret_laptop> zhaskell: if you compile with static link,i should work
04:33:31 <maerwald> depends
04:34:10 <cocreature> building a fully statically linked binary isn’t as easy as it sounds, e.g., statically linking glibc doesn’t really work so you need to have a musl setup or something like that
04:34:44 <cocreature> if you only care about one specific target, it’s probably easier to just build things in a docker container or something like that
04:41:02 <tdammers> as long as the libc's on both targets are compatible, just static-linking everything else should Just Work
04:41:42 <tdammers> then again, if both are x86 linux, why not just make targeted builds for both, using VMs or containers or chroots or some such?
04:48:04 * hackage grpc-etcd-client 0.1.2.0 - gRPC client for etcd  http://hackage.haskell.org/package/grpc-etcd-client-0.1.2.0 (LucasDiCioccio)
04:49:34 * hackage mmark-cli 0.0.4.0 - Command line interface to the MMark markdown processor  http://hackage.haskell.org/package/mmark-cli-0.0.4.0 (mrkkrp)
04:50:05 <c50a326> first thing I did this morning is write instances of Functor, Applicative and Monad for (State s), and they all compile and seem logical! I'm so proud! What's the best way to check their correctness?
04:50:07 <c50a326> https://ptpb.pw/N-19/hs
04:50:34 <c50a326> all I can think of at the moment is looking at other instance code online and compare the logic
04:53:08 <tdammers> write some test cases that rely on their respective laws
04:53:27 <tdammers> or even quickcheck test
05:02:03 <maerwald> feels a bit awkward, just prove it on paper
05:08:51 <tdammers> frankly, for Functor there really isn't a lot of leeway for making it wrong in ways that will still compile
05:12:34 * hackage benchpress 0.2.2.11 - Micro-benchmarking with detailed statistics.  http://hackage.haskell.org/package/benchpress-0.2.2.11 (willsewell)
05:14:35 --- mode: glguy set +v greg___
05:50:34 * hackage japanese-calendar 0.1.0.1 - Data type of Japanese Calendar (Wareki).  http://hackage.haskell.org/package/japanese-calendar-0.1.0.1 (nakaji_dayo)
05:51:06 <dmwit> tdammers: fmap f (x:xs) = f x:f x:fmap f xs ;-)
05:52:18 <dmwit> To make my point more general: fmap f act = act >> realFmap f act
05:53:37 <tsaka__> Say that your program needs the first 1000 fibonacci numbers. You'll never need any more than that, and they don't change. How to generate them on program startup ONCE such that they are globally availably without having to pass them around?
05:56:04 * hackage Persistence 1.1.4 - Quickly detect clusters and holes in data.  http://hackage.haskell.org/package/Persistence-1.1.4 (Ebanflo)
06:01:16 <noan> Anyone by chance familiar with aeson's error "Error in $: Failed reading: satisfy"? I can't get any sense of what's going wrong with it
06:05:16 <electrocat> tsaka__: just bind it to a top-level variable
06:05:48 <tsaka__> electrocat: it will be generated only once, or every time module is imported?
06:05:52 <electrocat> GHC will usually  just compute it once, the first time it's used, and then leave it evaluated in memory
06:09:50 <electrocat> tsaka__: just once
06:12:04 * hackage Persistence 1.1.4.1 - Quickly detect clusters and holes in data.  http://hackage.haskell.org/package/Persistence-1.1.4.1 (Ebanflo)
06:15:38 <hpd[m]> Is there a name for `\def -> lens (fromMaybe def) (const Just)`? Should be a lens that replaces Nothing with a default value like `non`, but always sets Justs.
06:21:14 <merijn> cabal-install question, if I have a symlink to a source file (because it's shared between multiple packages) will "cabal sdist" properly copy said source file into the tarball?
06:28:51 <tsaka__> is there a type class with a function yielding the "0" value, i.e. "0.0" for floats, "0" for ints, "false" for bools
06:30:04 <cocreature> tsaka__: 0 value only makes sense with respect to some kind of addition and at that point you end up with the Monoid typeclass where mempty will give you a “zero value”
06:30:56 <electrocat>  > mempty :: Sum Int
06:31:09 <electrocat> > mempty :: Sum Int
06:31:11 <lambdabot>  Sum {getSum = 0}
06:31:21 <electrocat> > mempty :: Sum Float
06:31:23 <lambdabot>  Sum {getSum = 0.0}
06:31:28 <electrocat> > mempty :: Sum Bool
06:31:30 <lambdabot>  error:
06:31:30 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘mempty’
06:31:30 <lambdabot>      • In the expression: mempty :: Sum Bool
06:31:34 * hackage potoki-core 2.3 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.3 (NikitaVolkov)
06:31:55 <cocreature> > mempty :: Any 
06:31:57 <lambdabot>  Any {getAny = False}
06:32:05 <tsaka__> I'm trying to create a return type polymorphic function which yields an array of "zeros" for the given shape
06:32:18 <tdammers> dmwit: there is certainly *some* leeway
06:32:19 <tsaka__> I got this far:
06:32:21 <tsaka__> zeros :: (Monoid e, Unbox e, Shape sh) => sh -> Array U sh e
06:32:24 <tsaka__> zeros sh = fromList sh (replicate (size sh) mempty)
06:32:34 <tsaka__> where the arrays are from REPA
06:33:04 * hackage potoki 2.1 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.1 (NikitaVolkov)
06:33:35 <cocreature> tsaka__: for that I wouldn’t couple this to a typeclass. how about "replicate :: (Unbox e, Shape sh) => sh -> e -> Array U sh e" instead?
06:34:21 <tsaka__> that seems sensible, ill do that
06:35:58 <merijn> So...cabal-install and symlinks? Anyone know what happens?
06:36:25 <electrocat> merijn: why don't just try it out?
06:36:35 <electrocat> don't you*
06:37:04 * hackage indexation 0.6.2.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.6.2.1 (NikitaVolkov)
06:38:53 <merijn> electrocat: Because that involves inventing a standalone example to test that with which seems a lot of hassle if anyone already knows...
06:39:47 <kreetx> an mtl question: has anyone tried to implement a class "RunMonad" where for each monad there is a function run implemented, and the type of it is an associated type dependent on the monad?
06:40:10 <cocreature> kreetx: what would be the point of that typeclass?
06:40:13 <kreetx> point being that runIdentity needs no other arguments than the monad itself, runState takes an initial state, etc
06:40:26 <kreetx> so you could have a single function to run a monad
06:40:32 <kreetx> cocreature: ^
06:40:32 <cocreature> everything needs different arguments so you can’t abstract in any useful way over this
06:40:44 <cocreature> so the only thing you gain is that you can reuse the name
06:41:13 <cocreature> which at best saves you a bit of typing (which is never your bottleneck) but also makes it harder to figure out what the code is doing
06:41:24 <kreetx> but you could have a monad stack, and maybe implement runDefault for each, while using defaults for each of the values needed
06:41:44 <kreetx> and then you could switch the stack around when you need to
06:42:11 <cocreature> I still doubt that you gain anything by doing that but to answer your original question: afaik there is no such typeclass
06:42:20 <kreetx> yup
06:42:27 <kreetx> I see what you mean, too
06:43:02 <kreetx> but since I have several custom monads then I often forget what the function's name was to actually run it
06:43:20 <kreetx> I could have a convention for it -- but then, why not a typeclass
06:43:46 <merijn> making a typeclass because you can is rarely useful, tbh
06:44:15 <cocreature> kreetx: the thing is, if you forget what stack you are in and thereby what function name you need to use, the reader of your code will probably also not know what stack the code is operating in
06:44:22 <cocreature> if there is an explicit run function that’s easy to see
06:44:33 <electrocat> it might be cool if you just did 'runMonad :: MonadStackSignature' and it figures out everything by itself
06:44:49 <electrocat> but indeed, that is rarely useful
06:47:19 <kreetx> I guess I'm trying to cut down complexity -- since when I see a 'runMonad' and also the type signature then I know what it will do
06:47:53 <kreetx> and having runRWST, runIdentity etc doesn't add much -- they are all in the signature too 
06:48:06 <cocreature> I’d say introducing a new typeclass increases complexity instead of cutting it down
06:48:35 <cocreature> sure it’s in the type signature but then you are forcing users to run a typechecker in their head to figure out what it resolves to
06:48:50 --- mode: glguy set +v Boarders
06:48:57 <cocreature> sometimes that’s obvious but at that point writing the right method is also easy and when it’s not then it’s helpful when reading the code
06:49:30 --- mode: glguy set -v Boarders
06:50:03 <Boarders> probably stupid question: what are the cases where you would want a strict field that is not unpacked?
06:50:32 <cocreature> Boarders: very simple example: a strict Bool
06:50:53 <merijn> cocreature: Why would you not want to unpack a Bool?
06:51:06 <cocreature> merijn: because you can’t. GHC does not unpack sumtypes
06:51:23 <merijn> What? I think you can?
06:51:41 <cocreature> I’m more than happy to be proven wrong here but sadly I’m pretty sure about this :)
06:51:57 <cocreature> we have unboxed sums by now but only as a primitive, the UNPACK pragma does not yet apply to sumtypes
06:51:58 <merijn> cocreature: Then you couldn't unpack anything
06:52:20 <merijn> Not quite sure how I'd check this, though
06:52:30 <cocreature> “Any single-constructor data is eligible for unpacking”
06:52:44 <cocreature> quoted from the user guide
06:53:13 <electrocat> does GHC unpack stuff automatically when fields are strict? or is the pragma always needed?
06:53:26 <merijn> electrocat: It doesn't automatically unpack strict fields
06:53:38 <cocreature> merijn: GHC also warns that UNPACK has no effect if you try to use it on Bool
06:53:39 <merijn> Also, plenty of strict things can't be unpacked
06:53:57 <cocreature> GHC does unpack small strict fields automatically if it can
06:54:02 <cocreature> if you compile with optimizations
06:54:14 <cocreature> and there is a flag for doing it for large fields as well
06:54:20 <electrocat> cocreature: cool
06:54:32 <merijn> "GHC may or may not unpack things if it decides it wants to and you have the right optimisation level" isn't quite the same as "GHC unpacks strict fields automatically"
06:55:30 <electrocat> should've phrased it better
06:55:37 <Boarders> are there theoretical reasons for wanting a strict field that is not unpacked?
06:55:54 <cocreature> GHC will always unpack small fields if you compile with -O and -O2 is a stronger guarantee than “ghc may or may not unpack things” :)
06:56:14 <merijn> Boarders: The fact that you can't unpack all strict fields? The fact that it might be a pessimisation to always unpack?
06:56:22 <cocreature> Boarders: yes, if you have a large field it can be benefitial to share it
06:56:34 * hackage Persistence 1.1.4.2 - Quickly detect clusters and holes in data.  http://hackage.haskell.org/package/Persistence-1.1.4.2 (Ebanflo)
06:57:01 <Boarders> ah I see, thanks cocreature
06:57:20 <cocreature> which is also why GHC by default only unpacks small strict fields
06:57:50 <electrocat> i guess for when a dereference costs more than just making a copy
06:57:51 <merijn> How is small defined?
06:58:29 <cocreature> <= pointer size iirc
06:58:48 <cocreature> with some exceptions on 32bit systems where it also applies to some 64bit things like Double iirc
06:59:24 <merijn> hmm, looks like cabal sdist just copies the symlink target when dealing with links, so yay?
06:59:45 <merijn> That means I can commit more horrific CPP crimes
06:59:51 <electrocat> :p
07:02:35 <merijn> Clearly the solution to "maintaining the same export list across multiple modules to get nice re-export docs" is a major hassle, but so are "ugly random order re-export docs" can be solved by just moving the export list to a separate file, symlinking it and then #including it in each export list! \o/
07:10:52 <fendor> when should prefer `MonadIO m => m ()` over `IO ()`?
07:10:56 <fendor> *should i prefer
07:13:55 <Boarders> fendor: my reason for preferring type classes like this when writing the code is I don't want to get locked into a particular design choice and then have to make enormous numbers of changes
07:14:34 <julianleviston> If one is writing library code - and some say all code we write should be library code - then it’s much more flexible.
07:15:02 <maerwald> IO when it's inherently IO, MonadIO when it happens to also need some IO. Doing MonadIO is unconditionally is pretty weird imo, especially if you are on systems programming level
07:15:44 <maerwald> if you need more flexibility in the future, just refactor your code... haskell is good at it
07:15:48 <merijn> I dunno, having to continually lift things when using IO is annoying
07:16:14 <maerwald> don't overdesign
07:16:36 <maerwald> you have a strong type system that guides your refactoring ;)
07:17:17 <tdammers> ^ this, pretty much
07:17:34 <tdammers> start with a simple solution; and then when a refactoring opportunity arises, refactor
07:17:53 <tdammers> IME even very intrusive refactorings usually turn out easier and less problematic than expected
07:18:01 <merijn> tdammers: I don't think that argument applies for this case
07:18:25 <fendor> tdammers, also, it is certainly not applicative to IO heavy code.
07:18:32 <fendor> *applicable
07:18:39 <merijn> tdammers: as in, if I have a library that has an API that has a bunch of functions resulting in IO, then having them actually be IO means you have to liftIO every individual use when you use the library
07:18:45 <tdammers> I still think it holds
07:18:55 <c_wraith> fendor: I don't see why not.  I've done it.
07:18:56 <merijn> tdammers: If the library has "MonadIO m => m a" result values you can "Just use it"
07:18:58 <tdammers> maybe not across library boundaries
07:19:25 <ggVGc> I have a sudden strong urge to write haskell.. but there are so many other things I should be doing instead
07:19:27 <fendor> c_wraith, i wrote turtle heavy shell script code, nothing can save me from switiching up two statements in a do block
07:19:28 <MarcelineVQ> re a solution to the earlier question about computing 1000 fibs on program start, am I being dumb here or is this a reasonable way main = let !xs = foldl' (\xs x -> x`seq`xs) () (take 1000 fibs) in ... 
07:19:54 <ggVGc> fendor: are you using turtle regularly?
07:20:09 <fendor> ggVGc, No. only once, wanted to give it a try
07:20:11 <c_wraith> fendor: is that a mistake you make when refactoring?  I mean, sure, it can go wrong, but it's not typical of the class of mistakes that belong in the "I need to change the design" bucket.
07:20:25 <merijn> tdammers: As in, right now I'm using IO here: https://hackage.haskell.org/package/broadcast-chan-0.1.0/docs/Control-Concurrent-BroadcastChan.html for the new version I'm working on I've just turned everything into "MonadIO m => m ()" instead, because I almost always use it within some monad stack
07:20:35 <ggVGc> fendor: and how was it?
07:20:39 <fendor> c_wraith, that is just a mistake that not even haskell can save you from, not that is a inherent design flaw
07:20:43 <ggVGc> I once did the same thing with scala for a project.. and wasn't happy
07:20:53 <merijn> tdammers: So I don't think "just default to IO and refactor into lifting when needed" is necessarily the best default
07:20:58 <fendor> ggVGc, Kind of annoying, using Shell is really tricky, imo.
07:20:59 <c_wraith> fendor: it also has nothing to do with IO.  
07:21:20 <c_wraith> fendor: all you need is branches to make that mistake :)
07:21:25 <merijn> ggVGc: I can give you some haskell stuff todo :p
07:21:45 <ggVGc> plzno :(
07:21:47 <fendor> c_wraith, fair enough
07:21:56 <ggVGc> I have haskell code to hack on, but it'd be irresponsible to prioritise it
07:22:11 <merijn> ggVGc: I still need a bunch of tests implemented, I've got a feature wishlist for Haddock I don't have time for and someone needs to update cabal's flag filtering for 8.6.1 :p
07:22:34 <fendor> however, so, there is no consens when monadIO should be used?
07:22:34 <ggVGc> well... I've got two jobs and starting full time studies on monday
07:22:44 <ggVGc> and I have to go through expenses receipts for my accountant
07:22:50 <ggVGc> all of these are more boring than haskell
07:22:53 <ggVGc> but nore necessary...
07:22:59 <merijn> ggVGc: I know the feeling :)
07:23:04 <MarcelineVQ> Seems like the concensus is it varies by use an experience
07:23:15 <merijn> ggVGc: I'm releasing a new version of this library to avoid writing on my thesis xD
07:23:37 <merijn> Although, I at least use it in the code for my thesis, so...
07:23:52 <ggVGc> should have made the library your thesis
07:24:10 <merijn> Too simple for that :p
07:25:19 <fendor> MarcelineVQ, thats a terrible consens, because now I still dont know when it should be used :D 
07:26:40 <tdammers> merijn: more like, "refactor when you can tell it's going to be useful"
07:27:22 <c_wraith> fendor: I will use MonadIO for library code that makes the most sense used in transformer stacks.  Otherwise (application code or library actions that are simple enough to stand alone) I just use IO
07:27:23 <MarcelineVQ> You could post your code and see if there's an opinion on whether MonadIO makes sense for what you're doing
07:28:08 <tdammers> one argument against MonadIO is avoiding dependencies
07:28:14 <MarcelineVQ> For me, so far, it just adds an layer of annoyance to work around in the most general case. And it's not exactly hard to add MonadIO later
07:28:18 <tdammers> whether it's a strong argument stands to reason
07:28:39 <cocreature> tdammers: that’s not really an argument anymore now that MonadIO is in base
07:28:43 <fendor> MarcelineVQ, currently, its mainly about an library, that is used in my code base. Every siganture uses IO and i use in my currently pretty shallow monad transformer stack. I'm thinking about changing the signature in the library
07:28:43 <c_wraith> also, I don't use MonadIO constraints on type variables that appear in negative positions, because that usually causes confsion
07:28:51 <tdammers> cocreature: oh, right, hah
07:29:04 * tdammers feels old
07:29:12 <fendor> but it does not really matter in this case, since using liftIO isnt a big deal currently
07:29:19 <electrocat> how hard would it be to write a TH function that lifts definitions in entire modules
07:29:33 <merijn> tdammers: MonadIO is in base now
07:30:02 <fendor> tdammers, also i am using ClassyPrelude and lens, hence i am already using most depedencies :D 
07:30:11 <fendor> thanks to haskell, the executable is still pretty small.
07:30:41 <fendor> c_wraith, yeah, that would be a follow up question about `unliftio` which I dont get at all :D 
07:31:32 <c_wraith> see?  confusion: caused. :)
07:32:27 --- mode: glguy set +v zhaskell_
07:33:35 <fendor> c_wraith, the confusion is not caused by monadio :D it is caused by one of its limitations and haskell exception management :D 
07:34:06 <fendor> however, MonadIO is helpful, if you want to introduce a monad stack later on
07:34:14 <fendor> *transformer stack
07:34:42 <c_wraith> It's not just about exception management.
07:34:50 <c_wraith> It's about all sorts of non-linear control flow.
07:35:38 <maerwald> don't start the sad thread about exceptions!
07:35:55 <c_wraith> New threads, deterministic simulation of nondeterminism, non-exceptional short-circuiting
07:36:00 <fendor> i know, there are a lot of trigger points :P
07:36:15 <c_wraith> And all the crazy things one could (but probably shouldn't) do with ContT
07:37:12 <fendor> that looked like a fun monad transformer. Not as much fun as tardis however.
07:37:28 <c_wraith> They're different kinds of crazy :)
07:37:42 <fendor> i can imagine. ^^ 
07:38:07 <fendor> maerwald, i actually dont think any longer that the exception system is sad in haskell, almost no other language got it any better.
07:38:50 <cocreature> stack ContT on top of TardisT or the other way around to turn the craziness up to 11
07:39:11 <fendor> i suppose that might be hard to follow
07:39:25 <maerwald> fendor: Java has
07:40:50 <fendor> maerwald, runtime vs checked vs optional which you can almost never use in a declartive style due to the `variable must be effectively final` limitation.
07:41:47 <maerwald> When looking at haskell code, I have to trust the documentation to tell me the truth about the exceptions. In java I have at least some reasoning about what a function may throw
07:42:23 <maerwald> and almost no one unit tests their exceptions, so the documentation may say whatever
07:42:57 <maerwald> and suddenly another codepath is triggered and your application blows up
07:42:58 <fendor> maerwald, i have the feeling that currently most people are switchign to runtime exceptions in java. At least the last libraries i have dealt with did. Then it is the same problem
07:42:59 <maerwald> or fires missiles
07:43:17 <maerwald> sure, but that's not the fault of the language is it?
07:43:21 <maerwald> you have the tools
07:43:44 <fendor> in haskell, you also have the tools, catch it, and return an either, similar to rust
07:44:01 <maerwald> nah, you don't have checked exceptions in haskell
07:44:07 <maerwald> and they don't show up in your type signature ;)
07:44:33 <fendor> When you use something like `Either Error Result`, it is kind of like an exception
07:44:49 <maerwald> it's not checked at all, it's just what you chose to turn into an either
07:45:10 <dstolfa> exceptions are evil anyway
07:45:13 * dstolfa avoids them
07:45:36 <julianleviston> no IO then?
07:45:39 <fendor> right, but I think that it has similar power, especially when using EitherT or somethign like that
07:45:47 <maerwald> then you haven't used rust long enough to be annoyed by not having exceptions :P
07:45:52 <dstolfa> julianleviston: i avoid I/O as much as possible, yes
07:45:57 <dstolfa> maerwald: i don't write rust
07:46:23 <dstolfa> maerwald: i write Isabelle, Ott, Haskell, OCaml, C (kernels), C++ (LLVM)
07:46:39 <dstolfa> i've also done agda but i currently can't use it anywhere :-(
07:46:43 * dstolfa likes agda
07:46:43 <fendor> maerwald, probably
07:47:05 <dstolfa> Isabelle is nice though, even though i'm quite new to it
07:47:17 <dstolfa> proving larger things is relatively straightforward
07:47:34 <tdammers> exceptions are the lesser evil in some cases
07:47:49 <tdammers> especially when other evils are involved already, like, say, lazy IO
07:48:23 <fendor> it's all evil in the end, computers are horrible and annoying. 
07:48:41 <maerwald> cluttering your whole callstack with Maybe and Either just because there can be a failure is a) very annoying and b) can also easily lead to you handling an error to early or ignoring it. While with exceptions, you handle it only where you actually want
07:48:57 <tdammers> open file, getContents, return to caller, caller does time consuming thing and then tries to evaluate your string, but the file has been overwritten
07:49:09 <tdammers> granted, that's a problem with lazy IO more than with exceptions
07:49:16 <maerwald> never use lazy IO
07:49:16 <dstolfa> maerwald: i take it you haven't implemented exception handling code in compilers then
07:49:22 <dstolfa> it's nasty.
07:49:23 <dstolfa> very nasty.
07:49:36 <dolio> That has nothing to do with lazy I/O.
07:49:50 <dolio> It's a problem with not reading entire files into memory as fast as possible.
07:50:28 <Eduard_Munteanu> A lack of file locking.
07:50:33 <tdammers> a strict getContents should block until the file has been read entirely, no?
07:50:49 <dolio> It could, if you want to waste memory.
07:51:40 <dolio> Most people try really hard to incrementally process files, and it still has that same problem even if it's not 'lazy'.
07:53:14 <dolio> I mean, I actually think most 'problems' with lazy I/O don't make much sense as problems specific to lazy I/O.
07:53:33 <dolio> They're just problems with I/O.
07:54:02 <dolio> Because it's already concurrent.
07:54:04 <dstolfa> dolio: there seems to be a trend of effectful things being problematic in general
07:54:55 <dolio> Even if your getContents is strict, you could get interrupted by someone else who's modifying the same file, and see an inconsistent state.
07:56:21 <dolio> If you want to fix it, you need to change the way files work to be persistent once you open them or something.
07:58:34 * hackage deptrack-core 0.1.0.0 - DepTrack Core types and model.  http://hackage.haskell.org/package/deptrack-core-0.1.0.0 (LucasDiCioccio)
08:04:45 <delYsid> > (1,2) & _1 %%~ (\x -> [x])
08:04:48 <lambdabot>  [(1,2)]
08:04:56 <delYsid> er, why?
08:05:26 <dstolfa> :t %%Z
08:05:28 <lambdabot> error: parse error on input ‘%%’
08:05:29 <dstolfa> :t %%~
08:05:30 <lambdabot> error: parse error on input ‘%%~’
08:05:35 <dstolfa> what the hell is that symbol
08:05:41 <thebnq> :t (%%~)
08:05:43 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
08:05:51 * dstolfa needs to fix his fonts
08:05:56 <dstolfa> also lol
08:05:58 <dstolfa> fstab
08:05:59 <dstolfa> stabby stab
08:06:38 <thebnq> :p
08:07:14 <delYsid> oh, I am an idiot.
08:09:00 <thebnq> delYsid: probably not, it feels like a more obscure operator
08:14:28 <Solonarv_> fun fact: (%%~) = id
08:14:50 <Solonarv_> > (1,2) & _1 (\x -> [x])
08:14:51 <glguy> it's the operator for traverseOf
08:14:53 <lambdabot>  [(1,2)]
08:15:33 <Solonarv_> so if you like being extra confusing... just elide it!
08:16:06 <julianleviston> Well, id specialised for that specific type, no? ;-)
08:16:22 <Solonarv_> yes, yes
08:16:23 <thebnq> I saw that in the documentation and was trying to figure out if (%%~) ≡ id was a trick equivalence
08:16:52 <julianleviston> It has the type signature of any lens IIRC
08:17:08 <Solonarv_> nope; consider the definition of LensLike: type LensLike f s t a b = (a -> f b) -> s -> f t
08:18:37 <julianleviston> (a -> f b) -> s -> f t *is* a lens
08:18:51 <julianleviston> (with a Functor constraint in there, of course)
08:20:03 <Solonarv_> yes, that's why the type synonym is called LensLike ;)
08:20:32 <Solonarv_> a Lens is forall f. Functor f => LensLike f
08:21:03 <thebnq> I feel like LensLike is more like LensForSureWithConstraint f
08:21:51 <julianleviston> lenses are really quite simple when you realise it’s nothing much mor than a function that can grab some thing (content) out of another thing (shell with content), and transform either the shell or the content.
08:22:03 <julianleviston> (or both)
08:24:54 <thebnq> sure, but i think the confusing part is how many more names for specific cases there are
08:25:23 <julianleviston> Yeah, the choice of functor is what makes it a real blast :)
08:28:39 --- mode: glguy set +v KingoftheHobos
08:28:58 <KingoftheHobos> I'm curious; does anybody know what's going on with 8.6.1? I've expected it to be released weeks ago.
08:29:11 <maerwald> I'm looking for a monad, it sounded like Comonad, but it actually isn't. I forgot lol
08:31:12 <MarcelineVQ> is the Co or the monad the bigger clue?
08:31:31 <maerwald> it also has a ligher functor thing, wrapping a function or something
08:32:10 <MarcelineVQ> Codensity Coyoneda
08:32:34 <MarcelineVQ> probably most of the Co's given this crowd <_<
08:32:54 <Solonarv_> well, there are *other* optics, like forall f. Applicative f => LensLike f
08:32:59 <Solonarv_> IIRC that's a Traversal
08:33:02 <MarcelineVQ> ConT
08:33:27 <Solonarv_> hmmm... is there a CoConT ?
08:34:22 <cocreature> KingoftheHobos: releases are usually delayed for a bit since there are always a few issues that come up during testing. take a look at the open issues to get an idea of what’s holding up the release atm https://ghc.haskell.org/trac/ghc/query?status=infoneeded&status=patch&status=merge&status=upstream&status=new&group=status&milestone=8.6.1
08:35:03 <c50a326> is this code smell? https://ptpb.pw/ie9x/hs
08:35:23 --- mode: glguy set +v danysdragons
08:35:26 <c50a326> I know I can use a list comprehension which would look much nicer, is there something else I can do instead of a list comprehension though?
08:35:27 <KingoftheHobos> CoConT would be data CoContT r w a = CoContT (w r -> a) w r
08:35:34 * hackage groundhog-inspector 0.9.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-inspector-0.9.0 (BorisLykah)
08:35:39 <KingoftheHobos>  CoContT (w r -> a) (w r) i mean
08:36:09 <KingoftheHobos> i don't know of any library that provides it, but it's a comonad by using the same definitions as Density
08:36:25 <KingoftheHobos> It's kind of a variant of StoreT
08:36:42 <dminuoso> c50a326: Are you sure the implementation is even correct?
08:36:45 <cocreature> c50a326: I’m not sure that code actually behaves as you would like it to. there is a partial pattern match on p1 s and you are just throwing away xs
08:36:57 <c50a326> oh, yeah it's probably completely wrong also... lol...
08:37:00 <c50a326> damn :(
08:37:10 <cocreature> the same holds for p2 ys and ys'
08:37:24 <dminuoso> c50a326: When implementing a monad/applicative implementation of parser, dont make it a parser problem - if you can make it a StateT problem.
08:38:06 <c50a326> dminuoso: pardon?
08:38:12 <_sras_> Can some one please take a look at this article that I have written, and tell me all the things I have got wrong. The article is a sort of "demystification" on `Typeable` typeclass. Here is the link https://sras.me/haskell/what-the-heck-is-typeable.html
08:38:16 <c50a326> aren't Parser and State just fundamentally different types? :S
08:38:37 <dminuoso> c50a326: Parser a ~ StateT String [] a
08:38:43 <c50a326> I was playing with State instances this morning, I think I wrote correct implementations of those, well at least they compiled
08:38:52 <dminuoso> c50a326: It's really the same thing. :)
08:38:54 <KingoftheHobos> that's the naive implementation
08:39:01 <KingoftheHobos> and is really inefficient
08:39:27 <c50a326> ah yeah that makes sense
08:40:19 <c50a326> so what's the benefit of using StateT over Parser? is that what you're suggesting?
08:40:34 <c50a326> (if they're just basically the same thing, when StateT String [] a)
08:43:17 --- mode: glguy set +v shinyoshi
08:43:21 <shinyoshi> Hi
08:45:46 <Solonarv_> I think what's being suggested is that since StateT String [] a already has an Applicative instance, you can just re-use that instead of implementing it by hand
08:46:11 <maerwald> MarcelineVQ: ah, contravariant functor was one
08:46:15 <c50a326> oh but this is a learning exercise
08:46:37 <Solonarv_> in that case replace "re-use" with "look at"
08:46:55 <dminuoso> Solonarv_: No thats not the point
08:47:00 <maerwald> that took me 10 minutes of grepping IRC logs on my server lol
08:47:28 <KingoftheHobos> I think I understand what dminuoso was talking about when he said "dont make it a parser problem"
08:47:59 <KingoftheHobos> Implement the applicative/monad instances for your Parser, but try to be agnostic about its intended use.
08:48:12 <dminuoso> ^-
08:48:17 <KingoftheHobos> Instead, try to implement it like a stateful list monad 
08:48:36 <dminuoso> KingoftheHobos: You read my mind =)
08:50:04 <KingoftheHobos> And since Parser is the same as (StateT String [] a), you can try to look at how the Applicative/Monad instance for that specific transformer stack would look like.
08:52:02 <wz1000> I have TypeRep (t -> k) and TypeRep t. How do I get TypeRep k?
08:52:04 * hackage deptrack-devops 0.1.0.0 - DepTrack applied to DevOps.  http://hackage.haskell.org/package/deptrack-devops-0.1.0.0 (LucasDiCioccio)
08:52:18 <dminuoso> c50a326: The reason why `StateT String []` is a useful intuition, is because it tells you that this is actually a monad transformer stack at work.
08:52:50 <dminuoso> c50a326: THat being said, you might want to understand the purpose of the list. Do you know what the Applicative/Monad instance of [] models?
08:55:08 <shinyoshi> how much math needed for haskell
08:55:32 <KingoftheHobos> Not as much as some people insist!
08:55:36 <Solonarv_> *needed*? not that much
08:55:50 <monochrom> This much: http://www.vex.net/~trebla/haskell/prerequisite.xhtml
08:55:57 <KingoftheHobos> A lot of Haskell is inspired by the deep end of maths, but you don't need to know them in order to make use of them.
08:56:18 <c50a326> dminuoso: list comprehensions! right?
08:56:25 <Solonarv_> and also, you can learn them through haskell; prior knowledge isn't required
08:56:45 <Solonarv_> c50a326: list comprehensions are *related*, in that they're equivalent to do-notation
08:56:47 <KingoftheHobos> The difficulties with learning Haskell is mostly due to it's so unlike every other language you're likely to know. 
08:56:51 <c50a326> which I'm just trying to figure out actually... I mean I know I can write the applicative for Parser a like: Parser $ \s -> [ (f a, xs') | (f, xs) <- p1 s, (a, xs') <- p2 xs ]
08:57:14 <c50a326> but I was really want to feel as intimate with the inner workings as possible
08:57:22 <c50a326> so maybe I'll review [] Applicative/Monad
08:57:25 <KingoftheHobos> that looks right!
08:57:59 <KingoftheHobos> but alright, you're right about its connection to list comprehensions
08:58:55 <KingoftheHobos> basically, the lists (<*>) and (>>=) create are contain each possible answer you can get by applying each possible function to each possible argument
08:59:33 <Solonarv_> (note: (>>=) is concatMap)
09:00:49 <KingoftheHobos> Like Solonarv said, (=<<) is concatMap. what i said about "each possible combination of function and argument" is what (<*>) does
09:02:45 <dyamon> Hi guys, I was looking at Data.Functor.Identity and the Functor instance of Identity seems to be `fmap = coerce`. So I looked for `coerce`, and the description says I can jump from the concrete to the abstract side of a newtype. Does this mean that everytime I want to manually make a newtype instance of Functor, I just need to call `coerce`?
09:03:53 <KingoftheHobos> If you're making a newtype instance of an already existing function, you can call "coerce fmap", yeah.
09:04:15 <dminuoso> c50a326: No the point is not list comprehensions
09:04:22 <KingoftheHobos> However, there's an extension for just those specific cases that exists to eliminate such boilerplate!
09:04:30 <dminuoso> c50a326: The point is what does the applicative/monad instance actually mean. They model non-determinism.
09:04:40 <dminuoso> c50a326: Do you know what non-determinism means?
09:04:46 <KingoftheHobos> tried to aviod using that word
09:05:06 <dminuoso> Oh Im sorry! Ill let you talk. :)
09:05:17 <KingoftheHobos> nono, go on ahead
09:06:00 <KingoftheHobos> Anyhow dyamon, the extension is GeneralizedNewtypeDeriving . By turning it on, you can make newtype instances "inherit" instances of the type they wrap by simply deriving that instance.
09:07:01 <dyamon> KingoftheHobos: yes yes I know about that
09:07:11 <KingoftheHobos> Oh, sorry. What were you asking about then?
09:07:16 <dyamon> thats why I said *manually*
09:07:56 <dyamon> so I can just write the new instance like `fmap = coerce` for any newtype I want to make into a Functor
09:08:05 <Solonarv_> no, no
09:08:13 <KingoftheHobos> that only work if the newtype only wraps the a.
09:08:35 <c50a326> dminuoso: sorry was brb, I thought all haskell was supposed to be kind of deterministic in a way? isn't it like "pure"?
09:09:03 <KingoftheHobos> Yeah, that's why we say lists only "model" nondeterminism
09:09:15 <KingoftheHobos> like how State models implicit state.
09:09:52 <KingoftheHobos> The point of the list monad is to be able to work with, and produce, multiple different answers, or none at all
09:09:55 <KingoftheHobos> like nondeterminism
09:10:08 <c50a326> gonna have a read of this https://stackoverflow.com/questions/20638893/how-can-non-determinism-be-modeled-with-a-list-monad
09:11:19 <Solonarv_> c50a326: [] models "nondeterminism" by working with a list of all the possible answers
09:12:24 <dminuoso> c50a326: A list can be thought of as a "single answer" but you are not sure which. 
09:12:46 <dminuoso> c50a326: So if you have [10, 20, 40] it could be thought of "unsure whether 10, 20 or 40".
09:12:57 <dyamon> KingoftheHobos: so works in any newtype with kind (* -> *)?
09:13:41 <c_wraith> ...  it works in any place it type-checks.
09:14:50 <KingoftheHobos> dyamon: when it comes to Identity, it coerce works because the type of fmap for identity is '(a -> b) -> Identity a -> Identity b'. coerce takes the first argument, with type '(a -> b)', and coerces it to '(Identity a -> Identity b)'
09:15:35 <KingoftheHobos> that only works because a and (Identity a) have the same representations; that is to say, the (Identity a) wraps 'a', and nothing else.
09:16:22 <c_wraith> And coerce is implemented such that it fails to type check if it's not valid to use
09:16:27 <dminuoso> c50a326: The Functor instance lets you calculate with that "fuzzy" answer. fuzzy = [10, 20, 50]; So to add 5 to your fuzzy answer, you do `(+5) <$> fuzzy` 
09:16:32 <c_wraith> So if the type checker accepts it, it's valid.
09:17:47 <dminuoso> c_wraith: And once you go down that road, `[(+5), (*2)]` is a fuzzy operation (again you are not sure which to take). So if you have some "not sure which operation" [(+5), (*2)] and some "not sure which number" [10, 20, 40], how would you apply one to the other? Since you are neither sure about which operation nor about which number to take, the only sensible thing is to do some kind of cartesian product.
09:17:48 <KingoftheHobos> It wouldn't work for a newtype like 'newtype StringReader a = StringReader (String -> a)'
09:18:01 <dminuoso> Sorry. c50a326 ^-
09:18:08 <dyamon> KingoftheHobos: alright: but if I have, say, `newtype Foo a = Foo { unFoo :: Either String [a] }`  does `coerce` turn `a -> b` into `Either String [a] -> Either String [b]`?
09:18:32 <KingoftheHobos> No, since those types aren't coercible with one another.
09:18:40 <dyamon> KingoftheHobos: oh sorry didn't see your last message
09:20:07 <dyamon> KingoftheHobos: ok so the problem is that I'm missing something about Coerce :) I guess I'll have a look at that!
09:20:13 <dyamon> Thanks guys!
09:21:23 <KingoftheHobos> What makes two things coercible is if they have exactly the same memory representation, and newtypes are guaranteed to have the same memory representation as the one field they wrap. Note - not type parameter, but rather, the field.
09:21:58 <c_wraith> Well, it's a bit more subtle than that.  Exactly the same memory representation, *and* no extra role restrictions.
09:23:00 <c_wraith> the types being changed must have a phantom or representational role.
09:26:12 <dyamon> I see, I got the idea! Do you have anything to read about that?
09:26:39 <KingoftheHobos> let me look around, the wiki should probably have a page on it somewhere...
09:27:40 <c_wraith> https://wiki.haskell.org/GHC/Coercible is a reasonable starting point
09:28:27 <dyamon> thanks also Data.Coerce points to thishttps://ghc.haskell.org/trac/ghc/wiki/Roles 
09:28:34 * hackage potoki-core 2.3.0.1 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.3.0.1 (NikitaVolkov)
09:29:01 <KingoftheHobos> i feel like the wiki's page ain't detailed enough.
09:29:23 <ab9rf> they never re
09:29:32 <KingoftheHobos> and is "You can unwrap a newtype using coerce only if the corresponding constructor is in scope" even correct?
09:31:57 <KingoftheHobos> this blogpost looks reasonably detailed: http://reasonablypolymorphic.com/blog/roles/
09:33:44 <Solonarv_> that is indeed correct: for a newtype Foo = MkFoo { getFoo :: Bar }, the Coercible Foo Bar instance is only in scope when MkFoo is
09:34:11 <Solonarv_> this is the case to prevent you from breaking newtype-enforced invariants with a coerce
09:34:21 <KingoftheHobos> huh! didn't know that. cool!
09:38:54 <infinisil> Hey, when I use a monad transformer stack, does the order matter?
09:39:15 <c_wraith> sometimes
09:39:54 <infinisil> Well, I'm finding out that I can't use functions like `mapExceptT` if the top-most transformer isn't ExceptT
09:40:02 <infinisil> :t mapExceptT
09:40:03 <lambdabot> (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b
09:40:04 * hackage potoki-core 2.3.0.2 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.3.0.2 (NikitaVolkov)
09:40:34 <infinisil> Hmm.. but then I can't use other such functions for other monads, e.g. mapStateT
09:40:43 <Solonarv_> :t hoist
09:40:44 <lambdabot> error: Variable not in scope: hoist
09:40:51 <Solonarv_> blergh
09:41:10 <Solonarv_> % :t hoist
09:41:10 <yahb> Solonarv_: ; <interactive>:1:1: error: Variable not in scope: hoist
09:42:17 <Solonarv_> there is hoist :: (MonadTrans t, Monad m, Monad n) => (m ~> n) -> t n ~> t m
09:42:37 <Solonarv_> somewhere in mtl or transformers (I might not have gotten the signature exactly right)
09:43:14 <infinisil> Solonarv_: This? https://hackage.haskell.org/package/mmorph-1.1.2/docs/Control-Monad-Morph.html#v:hoist
09:43:39 <dyamon> KingoftheHobos: thanks! I'll give this a try too!
09:43:57 <Solonarv_> yes, that
09:44:13 <infinisil> Solonarv_: Or this: https://hackage.haskell.org/package/free-5.1/docs/Control-Monad-Trans-Free-Church.html#v:hoistFT
09:44:45 <infinisil> I have no idea what the ~> means there :o
09:45:09 <c_wraith> it's a type synonym
09:45:12 <c_wraith> click on it
09:45:36 <Solonarv_> so if you have an ExceptT e (StateT s m) stack, you can use hoist (mapStateT f) to modify the StateT layer
09:45:59 <infinisil> That's pretty neat
09:46:03 <Solonarv_> type (~>) f g = forall a. f a -> g a
09:46:17 <benzrf> so i was thinking about the clowns and jokers paper again
09:46:27 <infinisil> But isn't this straying a bit from the things one would usually do? I can't imagine normal people using hoist
09:46:41 <c_wraith> infinisil: why not?  It's a normal thing to want to do
09:47:05 <Solonarv_> honestly, I don't think you need the map***T functions very often
09:47:30 <benzrf> and it occurred to me that you could achieve something almost the same as its notion of dissection by using a Traversable instance along with a type along these lines https://benzrf.com/uploads/7ac06cf8e10c16b6.png
09:47:43 <benzrf> is there any advantage of the way it's done in that paper?
09:47:48 <benzrf> or did that paper just predate Traversable?
09:47:55 <infinisil> Hmm yeah, I'm only using mapExceptT right now, and that use is not even really justified. I'm using it to have a small error hierarchy
09:48:32 <Solonarv_> this looks like some Conduit/Pipes precursor to me
09:49:47 <benzrf> Solonarv_: i was actually gonna use pipes directly to test out this thought, but then i found that i'd need to import the Internal module to be able to do the step-by-step feeding i'd need, and i ended up finding it simpler to just implement that right there :)
09:49:55 <benzrf> the name Client is from pipes
09:53:03 <KingoftheHobos> how do you guys pronounce "<*"? There's "bind" for ">>=", "then" for ">>"/"*>" and "ap" for "<*>". "<*" is the odd one out. I've taken to calling it "pass" or "pass-through."
09:53:04 * hackage groundhog-th 0.9.0.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.9.0.1 (BorisLykah)
10:04:32 <monochrom> "then but use the first guy's return value"
10:04:48 <monochrom> @quote monochrom modem
10:04:48 <lambdabot> No quotes match. Sorry.
10:04:58 <monochrom> @quote modem
10:04:59 <lambdabot> hpc says: wget is one of my favorite zmodem emulators
10:05:04 <monochrom> heh
10:05:47 <dminuoso> KingoftheHobos: applicative const?
10:06:41 <dminuoso> It's just a thought, so you could maybe call it ap-const.
10:20:18 <ab9rf> man, zmodem
10:20:21 <ab9rf> i do not miss those days
10:20:57 <ab9rf> i remember about a decade ago having to figure out how to send a file with xmodem in order to reload firmware on a bit of network hardware
10:28:04 * hackage wilton-ffi 0.3.0.3 - Haskell modules support for Wilton JavaScript runtime  http://hackage.haskell.org/package/wilton-ffi-0.3.0.3 (Wilton)
10:42:45 <ktor> hi, have you tried to use hie-8.4.3 with vim8.1 (LanguageClient-neovim) on windows10? If you do, please help! I do experience a strange problem you could have solved already.
10:46:09 <dyl> Question: why is it that with TypeInType enabled I can’t demote a type to a term of type type?
10:47:09 <dyl> That is, is there something that being able to do this with would break?
10:47:38 <dyl> I guess you’d be able to write things like:
10:47:41 <dyl> I.e. write a function foo :: Type -> Type, foo t = (t, t)
10:48:05 <dyl> I’m not really sure how that would meaningfully work at runtime.
10:48:46 <dyl> I guess this is what GHC.Type.Typeable/TypeRep is more or less. 
10:50:02 <dyl> Agh wait all of Typeable has been overhauled, I’m mixing up different versions of reflection.
11:07:13 --- mode: glguy set +v arpl
11:08:06 <arpl> RBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBRBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRBGRGBGBGRBRGRGRBGBRBRB
11:13:35 <maerwald> someone fell asleep
11:18:34 <pavonia> Could be a code golf exercise: Write a minimal function that reproduces the pattern
11:18:44 <arpl> maerwald: Was that to my message?          Probably my initial message got ´spam stopped´. Will resend.
11:19:06 <arpl> Hello, I have a 52 (53) week schedule of 3 shifts (Red, Green, Blue) as a given (from the Fire Department). There must be a pattern in there, but I can´t find it. What would be a good way to go about finding it? [Will paste it in the next message.]
11:19:48 <c_wraith> the problem is underspecified.  you can find infinite patterns that fit any data set
11:21:44 <arpl> c_wraith: Yes, it is. There must be a scheduling logic but I don´t know what it is. Can´t contact anyone now. (Weekend and the Fire Department in question is in the ´Florence area´ so they are not too keen answering this kind of thing now, I think. : )
11:22:19 <pavonia> It seems to be `cycle "RBGBRBRBGRGBGBGRBRGRG"`
11:22:44 <c_wraith> that sounds like a good candidate pattern :)
11:22:57 <blankhart> hello rain man
11:23:36 <c_wraith> (Ideally, you'd want to specify something like "minimal Kolmogorov complexity", but that is very dependent on computation model)
11:23:46 <EvanR> :let f 'R' = 'A'; f 'G' = 'T'; f 'B' = 'C'
11:23:57 <EvanR> @let f 'R' = 'A'; f 'G' = 'T'; f 'B' = 'C'
11:23:58 <lambdabot>  Defined.
11:24:09 <EvanR> > map f "RBGBRBRBGRGBGBGRBRGRG"
11:24:11 <lambdabot>  error:
11:24:11 <lambdabot>      Ambiguous occurrence ‘f’
11:24:11 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
11:24:22 <EvanR> > map L.f "RBGBRBRBGRGBGBGRBRGRG"
11:24:24 <lambdabot>  "ACTCACACTATCTCTACATAT"
11:24:35 <EvanR> your plot is revealed
11:25:04 <arpl> pavonia: Thank you!       That is a 21 day repeating cycle! That suffices for me right now. It would fit ´scheduling logic´. Thanks again!
11:25:18 <pavonia> No problem
11:26:41 <arpl> I´m glad it is not a problem here! : ) With the FD every question seems to be a problem. ; )
11:32:47 --- mode: glguy set +v orzo
11:33:35 <orzo> Sort of like cflow, but for haskell.
11:37:06 <orzo> (Sorry if repeat, glguy said something about needing +v.). Is there a static-analysis tool that will build the following graph?:  Every top-level binding is a node and there is an edge from node1 to node2 iff node2 occurs in the definition of node1.
11:38:47 <ab9rf> i've never seen anything like that
11:39:41 <cocreature> there are tools for building dependency graphs on a module level but I haven’t seen anything that operates on the level of top-level definitions
11:43:35 <stevenxl> Hi everyone. I'm trying to run a script using `stack myscript.hs`. When I run that I get the following error: Local packages are not allowed when using the script command. Where is this local package found so I can delete it?
12:01:29 <infinisil> orzo: I'm actually just doing something like that
12:01:58 <infinisil> I just use a free variable analysis to determine the dependencies
12:04:04 * hackage zephyr 0.2.0 - Zephyr tree shaking for PureScript Language  http://hackage.haskell.org/package/zephyr-0.2.0 (coot)
12:20:37 <jle`> stevenxl: can you paste your script?
12:42:45 --- mode: glguy set +v Virgil_
12:43:46 <orzo> infinisil, i'm interested.  Is there a github where i can watch your progress?
12:44:18 <infinisil> Well there is, but it's not really organized and I'm currently just experimenting around
12:44:48 <orzo> well, i'll clone and ignore then?
12:44:53 <orzo> :)
12:47:16 <infinisil> orzo: Well here is the most important bit: https://github.com/Infinisil/nixbot/blob/master/nix-session/src/Nix/Session.hs#L44-L55
12:47:26 <infinisil> I'm not using it to its full potential right now though
12:51:20 <orzo> thanks
13:12:34 * hackage stack-tag 0.2.0 - Create etags for Haskell projects based on Stack snapshots  http://hackage.haskell.org/package/stack-tag-0.2.0 (ChristopherReichert)
13:23:27 <stevenxl> jle`: Apologies that I am replying a bit late. You can find the script here (https://gist.github.com/StevenXL/3764b8887b40325349020595d472a044). 
13:23:39 <crestfallen> hi please explain how Boolean is isomorphic to Either id id. I don't get this
13:25:23 <ab9rf> heh
13:25:42 <crestfallen> so one parameter to Either needs to be True
13:26:11 <ab9rf> what's "Either id id"?
13:26:32 <crestfallen> id
13:26:44 <ab9rf> :t Either id id
13:26:45 <lambdabot> error:
13:26:46 <lambdabot>     • Data constructor not in scope:
13:26:46 <lambdabot>         Either :: (a0 -> a0) -> (a1 -> a1) -> t
13:26:56 <ab9rf> there's no "Either" data constructor
13:27:01 <ab9rf> Either is a type constructor
13:27:13 <ab9rf> "Either id id" is invalid
13:27:42 <crestfallen> what about Either (Unit, Unit)
13:27:52 <ab9rf> so i can't say its isomorphic to anything because it has no meaning
13:28:00 <crestfallen> this is how the blog post was written
13:28:03 <ab9rf> that's an incompletely applied type constructor
13:28:24 <crestfallen> yeah thanks it didn't look right to me.
13:28:37 <ab9rf> we could talk about Either () ()
13:29:18 <crestfallen> please do
13:30:20 <crestfallen> > :t Either () ()
13:30:22 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:30:47 <crestfallen> :t Either () ()
13:30:48 <lambdabot> error:
13:30:48 <lambdabot>     • Data constructor not in scope: Either :: () -> () -> t
13:30:48 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
13:31:14 <crestfallen> oh well I suck
13:31:58 <ab9rf> the data constructors are Left and Right
13:32:02 <ab9rf> :t Left ()
13:32:03 <lambdabot> Either () b
13:32:07 <ab9rf> :t Right ()
13:32:09 <lambdabot> Either a ()
13:33:00 <ab9rf> so the isomorphism is between Bool (which has two inhabitants, True and False) and Either () () (which also has two inhabitants, Left () and Right ())
13:33:25 <ab9rf> there are subtle differences, hwoever, when yu consider bottom
13:33:41 <crestfallen> hmm
13:34:17 <ab9rf> Either () () has _|_, Left _|_, and Right _|_ as additional inhabitants, while Bool only has _|_
13:35:53 <crestfallen> yeah I don't get this quite yet
13:37:49 <ab9rf> well, let's ignore _|_ for now
13:38:04 <ab9rf> Bool has two possible values, or inhabitants, which are True and False
13:38:18 <crestfallen> ab9rf, ok
13:38:50 <ab9rf> the unit type, which we call () in Haskell, has exactly one possible value, which we also call ()
13:38:59 <ab9rf> you'll also see it called Unit
13:39:03 <ab9rf> or sometimes Void
13:39:43 <ab9rf> Either a b has as many possible value as a has, plus however many b has
13:40:09 <ab9rf> this is because each value in Either is either Left a or Right b.
13:40:42 <crestfallen> right that is (*), or AND
13:41:38 <crestfallen> hold on
13:41:49 <ab9rf> so, the two values in Either () () are Left () and Right ()
13:42:08 <ab9rf> which yuo can place in one to one correspondence with the True and False of Bool
13:42:21 <ab9rf> and so they're isomorphic, disregarding bottom
13:43:04 <crestfallen> ok so even though there is no | in Either, it is an addition type (+) OR
13:43:10 <ab9rf> correct, it's an addition type
13:43:27 <ab9rf> that's because it's defined as Either a b = Left a | Right b
13:44:08 <ab9rf> the Left constructor has the same number of inhabitants as its enclosed type, a
13:44:20 <ab9rf> and the Right constructor the same as its enclosed type, b
13:44:47 <crestfallen> so the side of the pipe that is inhabited, can we say that is True?
13:45:13 <crestfallen> its not a Boolean value, but..
13:45:14 <ab9rf> you can choose arbitrarily wehther to associate Left () with True or with False
13:46:54 <ab9rf> by convention we tend to use Left for "failures" and Right for "successes", so mapping Left () to False would likely make the existing combinators behave more "expectedly" when used with Either () ()
13:49:12 <crestfallen> right. also in logic, implication has ' not P | Q ' . is that related?
13:49:21 <ab9rf> not really, no
13:49:48 <ab9rf> at least not in any way that is obvious to me
13:50:22 <crestfallen> thanks yeah it explains why Bool is defined with False on the left side
13:51:12 <crestfallen> I mean, is that convention only, and not based on logic?
13:52:16 <geekosaur> there are things it helps with, but less due to logic than operationally (for example, fromEnum False == 0 which is convenient)
13:53:17 <crestfallen> interesting, thank you kindly. I'm a little fuzzy
13:53:27 <geekosaur> you gain a very tiny speed boost from treating the constructor tag as a machine level bitwise boolean
13:53:53 <ab9rf> sorry, i had to step away
13:53:55 <geekosaur> but in terms of the logic itself, there's no difference
13:54:09 <ab9rf> my son is recovering from major surgery and i'm prone to having to help him with some thing or another
13:54:43 <crestfallen> ab9rf, blessings to your family
13:56:00 <crestfallen> that's interesting, being an english speaker, of course everything is better from left to Right :)
13:56:58 <ab9rf> yes, the interpretation of Left and Right is dextrocentric :)
13:58:33 <geekosaur> data Aut a b = Sinistro a | Dextro b
14:00:13 <ab9rf> geekosaur: gah, you're making me think of algol now
14:00:47 <monochrom> Algol was nice. Still is, just a bit less.
14:01:41 <jle`> crestfallen: if two data types are isomorphic, it means that it is possible to write an `to :: a -> b` and `from :: b -> a` such that `to . from = id` and `from . to = id`
14:02:16 <jle`> crestfallen: in many (most?) cases, there are actually many possible such pairs of functions
14:02:20 <monochrom> I think we over-abuse the word "isomorphic" when we just mean "bijection".
14:03:02 <jle`> i think that's fair too :)
14:03:11 <jle`> crestfallen: the only requirement is that at least one to/from pair exists
14:03:12 <Solonarv> an isomorphism typically also preserves some laws or operations, on top of being a bijection
14:03:16 <monochrom> Actually s/we/you/ because I don't do it. :)
14:03:37 <Solonarv> although in colloquial usage it's left ambiguous *which* laws are preserved
14:05:37 --- mode: glguy set +v knupfer
14:06:29 <knupfer> Any news on ghc861?
14:08:05 <crestfallen> thanks jle` et al ..
14:09:24 <crestfallen> well I'm beginning to understand homomorphism. I've been watching the bartosz lectures which are helping.
14:14:05 <fragamus> cale you here?
14:18:04 * hackage boolector 0.0.0.6 - Haskell bindings for the Boolector SMT solver  http://hackage.haskell.org/package/boolector-0.0.0.6 (DeianStefan)
14:21:05 <n_blownapart> Solonarv, but also a homomorphism must preserve operations; I mean any morphism needs to know 'to' and 'from' to, well typecheck, right?
14:23:30 <Solonarv> homomorphisms don't have to be bijective
14:23:30 <crestfallen> why did the irc swith my nick..
14:25:49 <crestfallen> sorry do you mean they cannot be bijective?
14:26:22 <Solonarv> no, I mean what I said
14:26:29 <crestfallen> ok thanks
14:26:32 <Solonarv> homomorphisms preserve shape (in some sense)
14:26:44 <Solonarv> an isomorpism is a homomorphism that can also be reversed
14:27:02 <jle`> homomorphisms can be bijective...
14:27:10 <jle`> there's nothing saying they aren't allowed to be, heh
14:27:40 <crestfallen> in the case of monoid, it's alway uni-directional right?
14:27:51 <ab9rf> not necessarily
14:28:06 <crestfallen> oh brother
14:28:08 <jle`> consider the monoid homorphism from (Integer, +) to (Integer, +)
14:28:11 <monochrom> What is "uni-directional"?
14:28:20 <jle`> defined by to = id
14:28:41 <jle`> this is a proper monoid homorphism, and is also a bijection
14:28:42 <ab9rf> a very boring homomorphism, but it one
14:29:59 <jle`> it's a monoid homomorphism because to mempty = mempty, and to (x <> y) = to x <> to y 
14:32:28 <crestfallen> jle`, thanks need to process this..
14:33:43 <ktor> jose_zap: buggy version was c72c54359891d4763211968bd623e4a773ff7e99
14:35:29 <jose_zap> ktor interesting, because not much has changed after that
14:35:45 <jose_zap> well, not true
14:35:56 <jose_zap> a bunch of submodules got upgraded
15:01:41 --- mode: glguy set +v braulio
15:45:20 <Wyv3rn> hey all, how would I find the index of the smallest Int from a list?
15:46:19 <dmwit> :t minimum . flip zip [0..]
15:46:20 <lambdabot> (Enum b, Num b, Ord b, Ord a) => [a] -> (a, b)
15:47:32 <Solonarv> :t minimum . (`zip` [0..]) -- I prefer this syntax, which is that same thing
15:47:34 <lambdabot> (Enum b, Num b, Ord b, Ord a) => [a] -> (a, b)
15:49:51 <dmj`> > \xs -> minimum xs`elemIndex` xs
15:49:53 <lambdabot>  <[()] -> Maybe Int>
15:50:04 <dmwit> But it's so fun to hear "flip zip zero dot" in your head when you read mine.
15:50:17 <dmwit> dmj`: That requires two passes through xs, though. Could be a memory leak, depending on surrounding code.
15:50:31 <dmj`> dmwit: eek! 
15:51:04 <monochrom> Yeah beware of two-pass algorithms. Try to design transducer algorithms instead.
15:51:29 * dmj` makes note about transducers
15:55:34 * hackage boolector 0.0.0.7 - Haskell bindings for the Boolector SMT solver  http://hackage.haskell.org/package/boolector-0.0.0.7 (DeianStefan)
16:09:07 <ab9rf> transducer. i saw that somewhere else recently
16:23:53 <mbwgh> Is it normal that heap profiles have time scales that are way off? I have a program that runs out of file descriptors, but cleans up after itself and exits "normally". The heap profile seems to hint that ARR_WORDS (Text or ByteString I presume) are accumulating, reaching a peak at the very end, which is about 25MB. But the time scale only goes up to 14 seconds or so
16:27:52 <mbwgh> Is this a real/user/sys time kind of thing?
16:36:49 <tsaka__> given a 3D repa array, how to fill a column (e.g. all Z for a given X, Y) with a 1D list? Is it possible to do without IO() ?
17:10:00 --- mode: glguy set +v dataN
17:10:10 --- mode: glguy set -v dataN
17:10:21 <dataN> do we have type level thunks?
17:11:40 <Solonarv> nope, type level computation is eager
17:12:15 <dataN> maybe thats not the right way to think about this but, suppose there is a type level vector of types corresponding to a vector of values, where each value is of a different type, stored in the types vector at the corresponding index
17:12:33 --- mode: glguy set +v hpc
17:12:36 --- mode: glguy set -v hpc
17:12:43 <Solonarv> yes? that doesn't have anything to do with thunks
17:12:47 <dataN> but rather than storing the type of each value, just storing an argument to a type family, which is left unaplied
17:12:51 <hpc> isn't type level computation strongly normalizing so it doesn't matter?
17:13:42 <Solonarv> I mean, if you store A instead of F A (where F is the type family, and A is the argument) that's not a thunk
17:14:13 <dataN> but storing F also
17:14:25 <dataN> for the list it would be a partially applied Map F
17:15:18 <Solonarv> so.... storing (F, A) instead of (F A) ?
17:15:31 <dataN> ok, so thunks are unevaluated lazy function applications, so eager types means this is not a thunk.. maybe its a difference list?
17:15:43 <dataN> Solonarv: yes
17:16:04 <dataN> difference lists are so like thunk chains it was confused
17:16:38 <Solonarv> IIUC you can't have type families that aren't fully applied
17:16:50 <dataN> well, the symbol of one
17:17:15 <dataN> the defunctionalisation, TyFun or (~>) or whatever its called
17:17:53 <Solonarv> yeah, with defunctionalization you can do that
17:18:14 <dataN> so then there can be streams at type level that are almost lazy?
17:19:24 <dataN> >take 10 [1..] 
17:19:28 <dataN> > take 10 [1..] 
17:19:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:20:06 <dataN> > take 10 (iterate (+1) 0)
17:20:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
17:20:18 <dataN> @src iterate 
17:20:18 <lambdabot> Source not found. My pet ferret can type better than you!
17:20:34 <dataN> anyway, these should be thunkified
17:20:39 <dataN> at type level
17:21:04 <dataN> would that work?
17:21:41 <dataN> ("left as partially applied symbols of type families")
17:23:21 <dataN> not sure how to make it call the next application when needed though...
17:23:56 <Solonarv> ^ that is exactly why defunctionalisation is clunky
17:24:52 <dataN> its just a state though right?
17:25:51 <dataN> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
17:26:32 <dataN> build g = g (:) []
17:26:43 <dataN> for making infinite lists...
17:27:05 <dataN> probably impossible at type level?
17:27:41 <dataN> unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
17:28:52 <dataN> seems like that could used to make just enough of the list as currently used and retain the state 'b' 
17:30:19 <dataN> so then instead of passing an infinite list around you just use (b,(b -> Maybe (a, b)))
17:31:14 <dataN> (maybe even the function can be available via a constraint on b, but that is more complicated at type level. kind matching might work?)
17:32:03 <dataN> and then things like mapping over a list would take something of that type as an argument instead, and return another of modified type.
17:32:24 <dataN> or possibly left unevaluated in a thunk like difference list
17:33:21 <dataN> Solonarv: is that what you mean clunky?
17:33:21 <nh2> how can I execute a ghci command (e.g. ":load Myfile.hs") from the command line?
17:33:48 <dmwit> nh2: Doesn't `ghci Myfile.hs` work for that?
17:34:05 <Solonarv> dataN: mostly, I'm referring to the fact that you need some kind of Eval type family
17:34:23 <nh2> dmwit: I want to execut a given command, e.g. ":mycustomcommand" after ghci startup
17:34:34 <dmwit> nh2: Put it in your ~/.ghci
17:34:39 <dataN> Solonarv: what, like in here? http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/33/slides/wg28.hs
17:34:50 <nh2> dmwit: no, my ghci already contains something else. This is as part of a script
17:34:56 <nh2> (my .ghci)
17:35:16 <dmwit> nh2: As far as I know there's no way to connect to an already-running ghci. You'll just have to commandeer its stdin.
17:35:27 <dmwit> Like, right from the start.
17:35:31 <dataN> or do you mean another Eval? in which case can you clarify? 
17:35:32 <dmwit> Can't be done after it's already running.
17:35:56 <nh2> dmwit: I'm thinking of something like `ghc -E` but that doesn't work with ghci
17:36:47 <dmwit> nh2: "-E stop after generating preprocessed, de-litted Haskell" ... ?
17:38:18 <dmwit> nh2: You might like -ghci-script.
17:38:50 <nh2> "echo ':mycomand' | ghci' seems to work
17:38:50 <justsomeguy> I'm not sure if this will be helpful, but I thought I'd mention it: https://github.com/nelhage/reptyr
17:39:06 <nh2> dmwit: you might be onto something here, indeed I used -E when I meant -e, perhaps -e actually works too
17:39:09 <nh2> will try that now
17:40:12 <dmwit> nh2: `echo :mycommand | ghci` is just one possible implementation (a particularly unsophisticated one) of "commandeer its stdin".
17:41:00 <justsomeguy> starting it in a tmux session is another possible way to get access to it's stdin.
17:43:36 <nh2> dmwit: yes, I know, that's what I meant
17:45:08 <nh2> hmm, `runhaskell Setup.hs repl myexe --builddir=dist/build-repl '--ghc-options=-e :bla'`
17:45:09 <nh2> doesn't work since
17:45:09 <nh2> ghc: on the commandline: cannot use `--make' with `-e'
17:45:09 <nh2> looks like Cabal sillily doesn't provide a way to pass something to the actual --interactive invocation only, and passes those things to previous --make invocatins too
17:45:54 <nh2> justsomeguy: tmux seems a bit cumbrsome to call from a script ;)
17:49:08 <monochrom> Actually does Setup.hs even have "repl"?
17:51:49 <nh2> monochrom: yes, Setup.hs has everything the Cabal package provides
17:56:08 <justsomeguy> nh2: It's doable, but ugly: 'tmux new-session -d -s ghci_session ghci \;  send-keys -t ghci_session "this goes to stdin"'.
18:08:51 <justsomeguy> ...which means I completely agree, but was somehow compelled to look up how to do that.
18:09:23 <justsomeguy> :^p
18:11:49 --- mode: glguy set +v sebastianrkg
18:18:52 <ab9rf> wee
18:51:59 <sleepster> in haskell, is it a code smell to see a lot of "do"s
18:52:11 <sleepster> I feel like "do" is an imperitive programming thing
18:53:47 <MarcelineVQ> If you're actually needing to use >>= then do is quite appropriate for readability
18:54:32 <MarcelineVQ> But if you have an example then people could better advise
18:56:06 <sleepster> oh sure.  so I was looking at this code here (https://github.com/dbousamra/hnes/blob/master/src/Emulator/PPU.hs) where I see every function is using Monads
18:56:08 <mekeor> > do x <- ["alice","bob"]; return ("hello " ++ x)
18:56:10 <lambdabot>  ["hello alice","hello bob"]
18:56:36 <sleepster> every function is using do so I think it is written an more of imperitive style but I am not sure if there is an alternative
18:57:02 <dmwit> sleepster: At a first glance, none of this looks egregious to me. Quite clean, honestly.
18:57:34 <sleepster> I think so too
18:57:38 <ab9rf> sleepster: tjere
18:57:45 <ab9rf> sleepster: there's nothing wrong with using do
18:57:57 <sleepster> alrighty that's good :)
18:58:08 <ab9rf> sleepster: the main thing to watch for is the ossibility that you are introducing sequencing when it is not appropriate
18:58:10 <Solonarv> contrary to popular belief, haskell is a pretty decent imperative language ;)
18:58:12 <sleepster> I am very new at haskell and I am just reading through the "Real World Haskell" book
18:59:08 <ab9rf> sleepster: this looks pretty nice, actually
18:59:25 <dmwit> Yeah, this is not the work of a Haskell beginner.
18:59:44 <ab9rf> sleepster: i don't know a damn thing about what the functions you're calling do, but i can understand fairly well what is going on here just by scanning the code
18:59:57 <sleepster> thanks everyone.  I have been trying to find good references to follow so I'll keep this code in my bookmarks for future
19:00:19 <sleepster> oh this isn't my code :)
19:00:24 <ab9rf> well, whatever :)
19:00:32 <sleepster> I am just learning .. my code is vomit 
19:00:46 <ab9rf> sleepster: the main thing is to write code that can be understood
19:00:49 <sleepster> I was just trying to find a good solid example so found this one
19:02:49 --- mode: glguy set +v brunooo
19:03:22 <brunooo> Hi, I've got a stack issue
19:03:29 <mmaruseacph2> what's the issue?
19:04:20 <brunooo> basically, I can't use the "stack solver" command because my cabal version is 2.2.0.0
19:04:42 <brunooo> I'm not sure how to downgrade cabal or fix the issue
19:04:44 <mmaruseacph2> are you on the latest stack version?
19:04:54 <mmaruseacph2> stck upgrade
19:04:59 <mmaruseacph2> *stack upgrade
19:05:35 <brunooo> yep
19:05:47 <mmaruseacph2> you could also try stack upgrade --git
19:05:50 <brunooo> 1.7.1
19:05:56 <mmaruseacph2> to get the latest latest version
19:06:11 --- mode: glguy set +v brunooo
19:06:30 <mmaruseacph2> or open an issue at https://github.com/commercialhaskell/stack/issues
19:06:41 <mmaruseacph2> unfortunately I'm travelling so cannot debug more :(
19:06:45 <brunooo> oops I quitted by mistake
19:07:07 <dmwit> You can `cabal install cabal-install --constraint 'cabal-install<=2.1'` if you don't remind replacing your `cabal` executable.
19:07:36 <brunooo> okay I'll try that after trying stack upgrade --git
19:07:39 <dmwit> Or whatever version constraint you want. `cabal-install==0.4.0` if you really want to cry
19:07:48 <greymalkin> Is there a reason that seq is not defined as `seq :: a -> a` but rather as `seq :: a -> b -> b` ?
19:08:07 <dmwit> greymalkin: Yes. Everything already gets evaluated to WHNF when it's evaluated to WHNF.
19:08:46 * greymalkin confused
19:08:51 <dmwit> greymalkin: The promise of `seq a b` is that by the time `b` is evaluated to WHNF, `a` is, too.
19:09:05 <dmwit> greymalkin: You could imagine a new thing, `seqGreymalkin x = seq x x`, if type `a -> a`.
19:09:26 <dmwit> greymalkin: But it wouldn't be useful, because all that `seqGreymalkin a` would promise is that by the time `a` is evaluated to WHNF, `a` is, too.
19:09:50 <dmwit> greymalkin: But we can just use `a` instead of `seqGreymalkin a` to get that same promise, so `seqGreymalkin` is kind of pointless.
19:09:50 <greymalkin> Ah, that explains the name, too.
19:10:54 <greymalkin> So using `seq` inside, say the value portion of a concurrent map's `insert` doesn't necessarily clear up a space leak if the value is never used.
19:10:57 <greymalkin> ?
19:11:03 <dmwit> (Also I was slightly imprecise. What I really meant is that by the time `seq a b` is evaluated to WHNF, `a` is, too. It's not like just having `seq a b` somewhere in your program means that forcing some *other* reference to `b` will also magically force `a`.)
19:11:24 <dmwit> greymalkin: right
19:11:47 <greymalkin> That could explain why I'm still experiencing a rather rapid (24hr or less) space leak.
19:12:13 <greymalkin> And why I've now gotten "strange closure" crashes more than a few times.
19:12:34 <dmwit> Adding `seq` should not produce strange closure crashes.
19:12:54 <dmwit> If you have good evidence that it does, you should file a bug against GHC with some details.
19:14:47 <Solonarv> there's also stronger variant of seq, appropriately called deepseq
19:14:58 <greymalkin> I non-sequitized. I meant that since strange closure crashes seem to be correlated with either memory corruption or inconsistent concurrent evaluation, my level of parallelism without having properly evaluated the tables may be the cause of the "strange closure" crashes I occasionally see.
19:15:09 <Solonarv> it works the same way, but replace "evaluated to WHNF" with "fully evaluated"
19:15:38 <greymalkin> Solonarv: However, if I'm understanding `seq` correctly, then `deepseq` would not solve the problem any better if the `b` were not evaluated at all.
19:15:48 <dmwit> (And there's pseq, which guarantees that the first argument is forced before the second one is and that the first one's exception is chosen if both are exceptions.)
19:16:30 <Solonarv> right, that's a bit of a gotcha about seq: it doesn't actually guarantee ordering
19:18:45 <greymalkin> Anything I'm putting into the tables is likely just pure thunks, since the data from which it derrives is either STM or IO.  Am I correct in assuming that functions in those monads are (usually, excluding tilde notation) evaluated by the time the function ends?
19:23:07 <dmwit> I find the question a bit puzzling in a couple ways.
19:23:26 <dmwit> But the short answer is, no, an `IO a` has not necessarily forced its `a` by the time it's done executing.
19:23:51 <dmwit> % return (error "if you see this message, i've been forced") >> return ()
19:23:51 <yahb> dmwit: 
19:24:18 <dmwit> % return (error "if you see this message, i've been forced") >> putStrLn "if it was ever going to be forced, it would happen before this message appears"
19:24:18 <yahb> dmwit: if it was ever going to be forced, it would happen before this message appears
19:24:39 <greymalkin> Hmm.
19:24:55 <greymalkin> % return (error "if...")
19:24:55 <yahb> greymalkin: 
19:25:19 <greymalkin> I'm not sure that returning an (IO a) counts as evaluating the (IO a)
19:25:25 <dmwit> You might like `evaluate :: a -> IO a`. It ensures that its argument has been forced by the time the resultion action has finished executing.
19:25:50 <dmwit> greymalkin: Are you familiar with the distinction between evaluation and execution?
19:26:29 <dmwit> Evaluating is figuring out "what a thing is". Executing is "taking the actual actions stored in an `IO a`".
19:26:44 <dmwit> So, this evaluates an IO action without executing it:
19:26:51 <dmwit> % seq (putStrLn "hi") ()
19:26:51 <yahb> dmwit: ()
19:27:24 <dmwit> You cannot execute an IO action without first evaluating it. But you don't need to evaluate it *fully* to start executing; e.g.
19:27:35 <dmwit> the following one will interleave evaluation and execution:
19:28:06 <dmwit> % let loop _ = putStrLn "hi" >> loop () in loop ()
19:28:12 <yahb> dmwit: hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; hi; 
19:28:21 <greymalkin> You said "executing" above, but rather than executing an IO a, you returned it.
19:28:32 <greymalkin> :t return (error "thing")
19:28:34 <lambdabot> Monad m => m a
19:28:40 <dmwit> (The action `loop ()` is an infinite thing, so it can't be fully evaluated. But you don't need to fully evaluate to start executing it.)
19:29:16 --- mode: glguy set +v dataN
19:29:20 <glguy> In "let x = 1 : x in x" do we consider x able to be fully evaluated?
19:29:20 <dmwit> greymalkin: `return (error "thing")` is already an IO action. I executed it.
19:29:30 --- mode: glguy set -v dataN
19:29:32 <dmwit> glguy: A subtlety that I wanted to avoid. =)
19:29:50 <glguy> I was thinking we would
19:29:54 <dataN> argh, these type level runtime errors are destroy https://gist.github.com/dataN-hs/b26b747653c0f12795263a2d7b34550a
19:31:03 <dmwit> greymalkin: That is, I took all the actual actions stored in `return (error "thing")` -- which, in this case, isn't any actions at all.
19:32:18 <greymalkin> Right, `return` doesn't execute its argument necessarily.
19:32:30 <dmwit> It *definitely* doesn't execute its argument.
19:32:35 <dmwit> It also doesn't evaluate its argument.
19:33:05 <dmwit> And executing a `return` does not require evaluating its argument, either.
19:39:29 <dataN> got it! check updated gist 
19:40:57 <dataN> type family Loop (n :: N) (f ::(a ~> a)) (b :: x) :: x where  Loop Z _ x = x  Loop (S n) f xs = Loop n f (f @@ xs)
19:40:58 <dataN> type family Loop (n :: N) (f ::(a ~> a)) (b :: a) :: a where  Loop Z _ x = x  Loop (S n) f xs = Loop n f (f @@ xs)
19:41:20 <dataN> why does the typechecker not help with this?
19:45:28 <ab9rf> because you didn't give it enough cookies
19:45:47 <dmwit> Seems a p. legit question to me on its face.
19:45:55 <infinity0> could someone explain to me why loadAll2 can't be defined : https://repl.it/repls/PuzzlingLavishTitle
19:46:04 --- mode: glguy set +v sebastiankg
19:46:15 <infinity0> that website is running ghc 8.0 which gives a slightly unhelpful error message, ghc 8.4.3 gives instead:
19:46:28 <dmwit> dataN: Ah, got it.
19:46:31 <infinity0> ‘r0’ is untouchable inside the constraints: r0 ref bound by the type signature for: loadAll2 :: forall ref. r0 ref => ref -> m (PSAny r0)
19:46:54 <infinity0> even though i have "forall a r m" so i'm not sure why ghc thinks the second r should be treated as a distinct r0 variable
19:47:03 <dmwit> dataN: Your first Loop works properly if the compiler can determine that x ~ a... otherwise it just doesn't have any matching clauses in the `where`.
19:47:21 <dmwit> dataN: It might help to think of type families as being a collection of distinct families, one for each kind it's used at.
19:47:58 <dmwit> dataN: At the kinds where `x` and `a` are distinct, the second `Loop` clause simply doesn't exist.
19:48:22 <dmwit> ("the second `Loop` clause" means "the `Loop (S n) f xs = ...` clause")
19:48:36 <greymalkin> dmwit: Thank you so much for your help.  I have a lot of `seq a a` stuff to clean up.
19:48:43 <dmwit> greymalkin: Good luck!
19:53:27 <dataN> dmwit: if there is a way to enforce this kind of equality constraint it would be good, because the DupV function is now complaining about n /~ Length xs
19:55:16 <dmwit> infinity0: puzzling
19:56:13 <dmwit> infinity0: It does compile if you turn on the suggested extension (AllowAmbiguousTypes). But I'm not sure why it's needed.
19:56:39 <infinity0> hm i thought that extension basically just "moves the problem elsewhere" so didn't want to enable it
19:57:39 <infinity0> usually with error messages involving that extension, the solution is to add a ghost parameter somewhere so you can pass in the correct type, but not sure how that applies to this situation
19:57:40 <dmwit> Yes, that's sensible reasoning. It might actually be enlightening to try turning on that extension and then calling `loadAll2` to see whether the problem does indeed crop up elsewhere.
19:57:51 <Solonarv> it does move the problem elsewhere, but you can *solve* the problem at that other location (using TypeApplications)
19:57:51 <dmwit> If it does, it might tell you something about why GHC considers this type ambiguous.
19:58:18 <infinity0> the underlying problem is it's treating my second "r" as distinct from the first "r" though, according to that error message
19:58:23 <dmwit> Solonarv: But that's not clear to me here, because all the type variables in the context seem to appear in the types on the right of the `=>`. So why is it ambiguous?
19:58:23 <infinity0> indeed if i just wrap it in a newtype it all works
19:58:42 --- mode: glguy set +v dataN_
19:58:48 <infinity0> the "ambiguous" stuff i think is a red herring and is basically a result of treating the two rs as distinct...
19:59:01 --- mode: glguy set -v dataN_
19:59:23 <Solonarv> don't you have to list *all* type variables if you use an explicit forall ?
19:59:32 <sebastiankg> the Data.Aeson.Encoding.Internal function `float` (seen here: https://goo.gl/kFY97w) is taking up a huge amount of time in my application, according to profiling
19:59:38 <dmwit> Solonarv: Yes. So what?
19:59:43 <sebastiankg> I'm encoding from Float to JSON, is Double or some other type a more natural conversion?
19:59:54 <Solonarv> well, that signature lists `ref`, but not `r`...
20:00:16 <dmwit> Solonarv: `ref` is bound by a `forall` in the first argument.
20:00:22 <dmwit> Solonarv: It's a rank-2 type.
20:00:34 <dmwit> (And `ref` is not mentioned outside that `forall`.)
20:00:55 <infinity0> it's forall r a. (..) (forall ref . (stuff involving r )) -> (..)
20:01:08 <greymalkin> sebastiankg: Aeson?
20:01:12 <infinity0> ghc is somehow choosing to treat the inner r as distinct from the outer r
20:01:19 <Solonarv> oh I see
20:01:32 <Solonarv> (your code is taking forever to load so I didn't see it yet)
20:01:39 <dataN_> dmwit: sorry, my scrollup is gone, did you mention a way to put a type equality constraint into line 82 of https://gist.github.com/dataN-hs/b26b747653c0f12795263a2d7b34550a
20:01:55 <dmwit> infinity0: Honestly I suspect some kind of odd kind-matching problem is quietly and confusingly contributing. But I can't work out what it would be.
20:02:11 <greymalkin> sebastiankg: If so, Data.Scientific is the type that Aeson uses internally, and you can get to it from Float with (fromRational . realToFrac)
20:02:27 <sebastiankg> Aeson, yeah
20:02:28 <dataN_> (of 'type stencil.hs')
20:02:28 <dmwit> dataN_: No. I don't know what you mean.
20:03:06 <sebastiankg> oh, okay. I also convert to C Doubles elsewhere in the application too, so I'll have to balance which type is best as an intermediary
20:03:07 <dataN_> oh right sorry its line 37
20:03:31 <infinity0> dmwit: oh interesting thanks, i managed to fix the r/r0 issue by giving a kind for r
20:03:31 <dataN_> type family DupV (xs :: Vector n a) :: Vector (LengthV xs) (Vector n a) where  DupV xs = ReplicateV xs (LengthV xs)
20:03:53 <dataN_> it wants n ~ LengthV xs
20:04:08 <infinity0> dmwit: oh actually no, false alarm. it's still there, just the error messages got re-ordered
20:04:24 <greymalkin> sebastiankg: Unless you're using the Float for some other integration (such as functions from `statistics`) Double might be a better match for your internal data as well.
20:05:09 <sebastiankg> greymalkin: yeah, I'm not married to the Float, I was foolishly using it initially because I use Elm on the frontend which also uses Floats
20:05:18 <sebastiankg> but those two types may only share a name
20:05:53 <sebastiankg> greymalkin: would you think Double may convert more nicely to the Data.Scientific equivalent as well?
20:06:19 <greymalkin> Floats are less precise, and both Float and Double use the same instruction set on the CPU, so there's not much performance difference.
20:06:57 <greymalkin> Double converts the same way as Floats, so there's not too much difference there either.
20:07:31 <sebastiankg> Hmm, okay. That conversion seriously takes about 50% of the time of the execution of my program at the moment, I may try just passing around the Data.Scientific types
20:08:45 <dataN_> and about the comment about type family errors, its not that x /~ a should match some pattern of a type family, its that if x /~ a then f would be supplied the wrong argument, and that should not compile, but if it does, then its type should fix a ~ x
20:08:47 <greymalkin> Actually, it looks like `fromFloatDigits` may be a better way to convert to Scientific.
20:08:56 <dmwit> infinity0: FWIW if I turn on AllowAmbiguousTypes, I'm able to call `loadAll2` just fine.
20:09:13 <dmwit> infinity0: So I'd both file a bug (this type shouldn't need AAT) and turn on AAT for now.
20:09:53 <infinity0> ok, will do thanks
20:10:10 <greymalkin> sebastiankg: As long as you don't need to do a lot of arithmetic on them, Scientific would probably be better.
20:10:24 <dmwit> infinity0: Oh, well, actually: I need to use TypeApplications to call it.
20:10:37 <dmwit> infinity0: So now I don't know whether I would call it a bug or not.
20:10:43 <dmwit> I don't know what to make of this at all, really.
20:10:49 <aarvar> looks like a bug?
20:11:15 <dmwit> It really doesn't seem like it should need AAT+TA...
20:11:27 <aarvar> `r` isn't ambiguous, but it says it is
20:12:10 <aarvar> oh, wait, maybe not
20:12:51 <aarvar> "Couldn't match type ‘r0’ with ‘r’  ‘r0’ is untouchable"
20:13:19 <sebastiankg> greymalkin: okay, I'll go rifle through my source code and ponder this. I do a bit of arithmetic, but it may still be worth it
20:13:25 <sebastiankg> greymalkin: thanks for the help
20:13:58 <dataN_> type family DupV (xs :: Vector n a) :: Vector n (Vector n a) where  DupV (xs :: Vector n a) = ReplicateV xs n
20:14:20 <dataN_> that works, still loops though
20:15:59 <dmwit> infinity0: It's a beautiful (and short) puzzle. Thank you for sharing it. I don't know the answer. =P
20:16:33 <infinity0> hehe glad you liked it, and hopefully we'll get an answer on the bug i'm about to file
20:17:26 <aarvar> hmm, thinking it's not a bug
20:20:03 <aarvar> when you call it, `loadAll2 f`, it gets expanded to `loadAll2 (\x -> f x)`
20:21:04 <dmwit> Surely not.
20:21:29 <dmwit> I don't know of any other time when GHC eta-expands a thing; why would it here?
20:22:10 <aarvar> it does for RankNTypes, I think
20:22:22 <aarvar> then the type of `f x` can't be used to infer `r`, since `r` is untouchable
20:22:54 <dmwit> Are you sure? Is that documented somewhere?
20:23:18 <aarvar> er, or maybe it doesnt
20:23:28 <aarvar> but it at least eta-expands the type argument?
20:24:01 <aarvar> er, type argument and constraint argument
20:24:09 <dmwit> What does eta expansion mean for types?
20:24:44 <aarvar> `loadAll2 f` becomes `loadAll2 (\@ref @e -> f @whatever)`
20:25:20 <aarvar> er, not @e
20:25:32 <aarvar> imagine some syntax for a constraint argument
20:25:39 <dmwit> sure
20:26:07 <aarvar> but maybe this isn't relevant anyway
20:26:18 <dmwit> /\ref. \dict => f @ref {dict} -- or whatever
20:26:26 <dmwit> This I could believe.
20:26:31 <aarvar> point is `r` becomes untouchable in the argument
20:27:47 <dmwit> Anyway, I stand by my previous declaration of confusion. But then I've never really understood the whole "untouchable" story.
20:28:38 <infinity0> i'm trying to think of a suitable title for this ticket
20:28:39 <aarvar> or maybe it is a bug, but if it is then it's because inference with gadts is overly conservative, I think
20:30:20 <infinity0> "ghc disassociates constraint type parameter in certain cases of higher-ranked polymorphism causing "untouchable" and "ambiguous types" errors"?
20:30:25 <aarvar> infinity0: "ambiguous untouchable variable in RankN type"?
20:30:39 <aarvar> it's not disaccociating anything is it?
20:31:02 <infinity0> well it's "disassociating" the inner r from the outer r, i'm not sure if that is the right word to use here
20:31:18 <aarvar> to infer `r`, it needs to be able to solve `r ref => r ~ r0`, which it can't
20:31:37 <infinity0> but i explicitly wrote r in the type signature
20:31:56 <infinity0> i never wrote r0, ghc is splitting my r into (r and r0)
20:32:22 <aarvar> r0 is what it's instantiating `r` with when checking for ambiguity, I think
20:35:44 <infinity0> hm i see
20:35:51 <aarvar> to check if `forall x. f x` is ambiguous, I assume it tries to solve for `x0 ~ x1` given `f x0 ~ f x1`?
20:36:14 <aarvar> or something like that
20:37:40 <dataN_> is there no way to see which type family fails to match?
20:38:04 <dmwit> :kind! will evaluate as far as possible
20:38:13 <dmwit> Any type family applications remaining in the result fail to match.
20:38:38 <dmwit> It might be nice to have a single-stepper for type evaluation, too, but I don't think there is one.
20:39:10 <dataN_> just a catch all pattern error would be enough
20:39:16 <dataN_> ERROR!
20:39:40 <dataN_> but this type family is not possible.
20:39:49 <dataN_> it should have any kind
20:40:38 <dataN_> type family ERROR (a :: x) where  ERROR (a :: x) = a
20:40:44 <dataN_> but thats just id!
20:41:34 <dataN_> type family ERROR (a :: x) :: x
20:42:06 <dmwit> I think there's a `type family TypeError (x :: Symbol) :: y`. But I'm having trouble finding documentation on it right now.
20:42:40 <dmwit> here we go: https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#t:TypeError
20:46:21 <dataN_> yeah cant find the source for ErrorMessage. didnt know Chars could be promoted like that
20:47:28 <dataN_> thats should help thanks
20:48:34 <dataN_> but still, this is like using a language without a typechecker, its ...
20:50:19 <dataN_> still not as bad as trying to use python 
20:51:14 <emilypi> if you find python distasteful, there's always https://github.com/qfpl/hpython
20:51:15 <emilypi> :)
20:54:37 <dataN_> well thats a good idea, marred only by its use of python 
21:01:20 <geekosaur> oneof these days, dataN migt een coem to understand that, just maybe, Haskell does to have Idris's type system hiding underneath, it has Haskell's type system
21:01:45 <emilypi> was that a sentence?
21:02:26 <geekosaur> somewhere under the typoes
21:02:31 <emilypi> :P
21:02:57 <geekosaur> "might even", "dos not have"
21:03:23 <geekosaur> I swear this keyboard only supports like 5wpm max
21:04:37 <dmj`> It’s not possible w/ alex to make the delimiter of a csv lexer dynamic... right?
21:04:46 <aarvar> geekosaur: and neither of them is good enough xd
21:07:20 <monochrom> I wonder why Haskell attracts Curry-Howard zealots who take Curry-Howard too seriously in the context of Haskell.
21:11:49 <mekeor> monochrom: what does it mean to take the Curry-Howards isomorphism /too seriously/?
21:12:27 <blankhart> HOW DARE YOU QUESTION THE CURRY-HOWARD ISOMORPHISM
21:13:55 <monochrom> Look at what dataN is doing. Look at everyone who seeks to express every conceivable proposition in Haskell types and be disappointed that the Haskell type system is actually not Godel-complete.
21:15:48 <dataN_> its just a case of knowing how to use these new language features properly
21:16:29 <dataN_> the approach seems to be to write functions at value level and promote them
21:18:23 <dataN_> that way the typechecker can do its magic and runtime like compile time errors dont happen 
21:21:20 <dataN_> however, then we wouldnt have any idea what kinds of improvements were needed to do type level programming, and it would rely on template haskell and increase the learning overhead which should be avoided to understand how your code works 
21:23:29 <dataN_> if functions over graphs use type level graphs then this lifting recursion needs understanding 
21:24:48 <dataN_> because otherwise the promotion mechanism itself would need to be understood to see if it could handle this
21:29:23 <monochrom> No, Haskell does not promote term-level functions to types.
21:29:28 <dataN_> which means understanding the type level code it would produce. so, writing that code rather than learning template haskell
21:29:31 <dataN_> hmm?
21:30:44 <dataN_> $(singletons [d|
21:31:03 <monochrom> You do not already know? If you write "foo False = True; foo True = False" there is nothing to promote that to the type level.
21:31:04 <dataN_> and then just copy paste the term level code
21:31:37 <c_wraith> Just try it with some code that uses Double
21:31:56 <dataN_> shant
21:34:46 <dataN_> also it seems to help learn what actually makes the haskell type system work, and how in the future it might be able to give better support to avoid type level programming errors
21:36:10 <dataN_> apparently there is a type superclass interface in the works, which would be fun
21:36:53 <dataN_> maybe that would allow promoted dictionaries too 
21:39:16 <dataN_> then maybe could have something like a tagged overlapping superclass giving errors named by type family for unmatched patterns, but dont know how to make it the last pattern to be matched
21:41:16 <dataN_> (could do it at term level too if that was possible...)
21:42:08 <dataN_> but apparently the choice for haskell is that totality checking raises a warning rather than an error, or maybe there is a flag...
21:43:14 <dataN_> wait no, thats for classes not matching datatypes. sorry
21:44:23 <dataN_> why dont we have that? and for type families too? that would fix this problem
21:45:39 <dataN_> well, guess I'll just stick to writing catchall cases! 
21:48:17 <koz_> As a complete aside, which version of GHC is the QuantifiedConstraints extension due to appear in?
21:49:23 <dataN_> is there a flag to turn on warnings for incomplete datatype / type family matches? that would at least help find all the places the catchall cases go
21:50:49 <MarcelineVQ> koz_: https://ghc.haskell.org/trac/ghc/ticket/2893 milestone set as 8.6.1  so not before that
21:51:04 <koz_> MarcelineVQ: Thanks - so still a while off.
21:51:51 <mniip> 9/16/2018 [06:27:22] <dmwit> Anyway, I stand by my previous declaration of confusion. But then I've never really understood the whole "untouchable" story.
21:52:01 <MarcelineVQ> Not forever away, but there isn't a 8.6.1 release candidate yet
21:52:26 <mniip> it is pretty much always dangerous to unify two variables under a local equational constraint
21:53:20 <MarcelineVQ> koz_: You can probably try it out on master if you're excited to see it in action
21:53:21 <mniip> if you have foo :: (forall c. (a ~ b) => c) -> ...; and foo (x :: d)
21:53:35 <mniip> you ask GHC to solve (a ~ b) => (c ~ d)
21:54:06 <mniip> even if a,b seem unrelated to c,d it might be unsound to ignore the a~b and zonk d in place of c
21:54:22 <koz_> MarcelineVQ: Not that much, lol.
21:54:31 <koz_> I'll wait patiently, it just seems like a cool thing.
21:54:36 <mniip> that's the untouchable story
21:55:11 <aarvar> mniip: do you mean foo :: forall c. ((a ~ b) => c) -> ....; ?
21:55:23 <mniip> yes I guess
21:55:40 <aarvar> if you introduce `c` at the same time as the equality then it's touchable isn't it?
21:55:54 <mniip> no
21:56:29 <mniip> the forall still comes before the =>
21:56:37 <aarvar> really?
21:56:51 <mniip> yes
21:56:53 <aarvar> > let foo :: forall a b. (forall c. (a ~ b) => c) -> a -> b; foo f = undefined in foo
21:56:56 <lambdabot>  error:
21:56:56 <lambdabot>      • Couldn't match expected type ‘()’
21:56:56 <lambdabot>                    with actual type ‘(forall c. a0 ~ b0 => c) -> a0 -> b0’
21:57:09 <mniip> that's an ambiguous type
21:57:36 <mniip> because it would try to solve c1 ~ c2 to check the unambiguity of that higher ranked argument
21:57:40 <mniip> and c is untouchable
21:57:58 <aarvar> I was thinking it is touchable...
21:58:07 <mniip> ah no wait, guess it wouldn't do that
21:58:36 <mniip> @let foo :: forall a b. (forall c. (a ~ b) => c) -> a -> b; foo f = undefined
21:58:37 <lambdabot>  Defined.
21:58:44 <aarvar> ah
21:58:44 <mniip> :t foo
21:58:45 <lambdabot> (forall c. a ~ b => c) -> a -> b
21:58:49 <aarvar> now move the `c` outside
21:58:54 <mniip> yeah the issue comes from
21:59:04 <mniip> @let foo' :: forall a b c. ((a ~ b) => c) -> a -> b; foo' f = undefined
21:59:05 <aarvar> @let bar :: forall a b c. ((a ~ b) => c) -> a -> b; foo f = undefined
21:59:05 <lambdabot>  .L.hs:164:9: error:
21:59:05 <lambdabot>      • Couldn't match expected type ‘c0’ with actual type ‘c’
21:59:05 <lambdabot>          ‘c0’ is untouchable
21:59:06 <lambdabot>  .L.hs:164:1: error:
21:59:06 <lambdabot>      The type signature for ‘bar’ lacks an accompanying binding
21:59:07 <lambdabot>      |
21:59:47 <mniip> I did actually investigate a bit whether it's possible to relax the touchability
22:00:01 <mniip> turns out it's trickier than it seems
22:00:16 <aarvar> @let baz :: forall c. forall a b. (a ~ b) => a -> b -> c; baz = undefined
22:00:17 <lambdabot>  Defined.
22:00:44 <aarvar> oops
22:00:45 <mniip> that gets tidied to a simpler type
22:00:48 <mniip> :t baz
22:00:50 <lambdabot> b -> b -> c
22:01:14 <aarvar> forall a. forall b. can end up being different than forall a b. I think
22:01:24 <mniip> hold on lemme pull up my emails with eisenberg
22:01:27 <aarvar> though not in that example. that was dumb
22:03:59 <dataN_> does the version without the forall c. make the (a ~ b) jump to the far left like an opened Dict?
22:04:23 <mniip> okay wow
22:04:24 <aarvar> @let baz :: forall a b. (forall c. forall x. (a ~ b) => x -> c) -> a -> b; baz f = undefined
22:04:25 <lambdabot>  .L.hs:167:1: error:
22:04:25 <lambdabot>      Duplicate type signatures for ‘baz’
22:04:25 <lambdabot>      at .L.hs:164:1-3
22:04:31 <aarvar> @let qux :: forall a b. (forall c. forall x. (a ~ b) => x -> c) -> a -> b; baz f = undefined
22:04:32 <lambdabot>  .L.hs:167:1: error:
22:04:32 <lambdabot>      The type signature for ‘qux’ lacks an accompanying binding
22:04:32 <lambdabot>      |
22:04:36 <aarvar> woops
22:04:38 <mniip> lpaste is blocked by roskomnadzor
22:04:42 <aarvar> @let qux :: forall a b. (forall c. forall x. (a ~ b) => x -> c) -> a -> b; qux f = undefined
22:04:44 <lambdabot>  Defined.
22:04:55 <aarvar> hm, maybe not
22:06:02 <aarvar> mniip: relax it in what way?
22:06:39 <mniip> aarvar, well clearly c is independent from a,b so how can "touching" c be a problem?
22:07:53 <aarvar> mniip: well, it's not clear is it?
22:08:00 <mniip> yes
22:08:02 <aarvar> c could be a function of a and/or b
22:08:31 <mniip> https://bpaste.net/raw/03ce96f0f009
22:11:19 <koz_> mniip: Wow really?
22:11:32 <koz_> (the RosKomDadzor thing)
22:12:33 <koz_> s/Dad/Nad/
22:13:16 <mniip> koz_, all of 46.101.128.0/17 due to telegram
22:15:03 <koz_> mniip: Ouch.
22:16:34 * hackage japanese-calendar 0.1.0.2 - Data type of Japanese Calendar (Wareki).  http://hackage.haskell.org/package/japanese-calendar-0.1.0.2 (nakaji_dayo)
22:17:38 <mniip> and I shit you not when you file a removal request their blanket response is mindbogglingly stupid
22:19:54 <mniip> they equate the case when multiple websites are hosted from a single IP and blocking said IP results in unavailability of "innocent" websites (understandable); to the case when they block an IP range
