00:03:24 <lingeeal> Hi, functions involved with IO type are not referentially transparent. Is this is statement tru?
00:03:30 <lingeeal> *true?
00:08:15 <mniip> infinity0, definitely a bug
00:08:18 <mniip> here's my minimal example https://repl.it/repls/LoyalLiveMaintenance
00:09:09 <infinity0> so reading these docs about injectivity it only talks about deducing that a = b after knowing that F a = F b
00:09:58 <infinity0> however what we're doing here is deducing that a = c after knowing that F a = c
00:10:48 <Ariakenom> lingeeal: They are referentially transparent. I'd point out that "IO ()" is not a function
00:10:50 <mniip> true but
00:10:55 <mniip> r -> xs means "r determines xs"
00:11:31 <infinity0> it does sound like it should work yes, but i wonder if they missed this case in their analysis and what other cases they might have missed
00:11:38 <infinity0> anyway, i guess i'll go file a bug on trac?
00:12:19 <mniip> infinity0, here's an even smaller eaxmple https://repl.it/repls/LoyalLiveMaintenance
00:13:30 <lingeeal> Ariakenom: How? a function returning IO String can return 'receipe to return Hello" one time, and 'receipe to return World' another time, passing the same argument. This cleary is the opposite of referentially transparent. Dont get it. Or does the type IO String have only one value = 'Instructions to return a string'?
00:14:08 <mniip> infinity0, I guess the qeustion is determining the b
00:14:33 <mniip> if you have F a ~ r ~ F b, you know a ~ b but you don't know b
00:14:34 <jle`> lingeeal: a function returning an IO String is pure
00:14:46 <jle`> lingeeal: it returns the same recipe every time
00:15:24 <jle`> working with `IO a`, as a value, is referentially transparent
00:15:31 <mniip> infinity0, I guess you might have to somehow demonstrate the b
00:16:40 <infinity0> what does it mean to "demonstrate" here?
00:16:55 <mniip> infinity0, nevermind, it is a bug
00:17:02 <lingeeal> so then it's true when i say that IO String type contains one value
00:17:05 <lingeeal> ?
00:17:18 <mniip> infinity0, irrefutably this shouldn't happen https://repl.it/repls/LoyalLiveMaintenance
00:17:38 <mniip> lingeeal, the IO String type contains many values
00:17:42 <Ariakenom> lingeeal: "getLine :: IO String" isn't a recipe to read "hello". It is what reads different things at different times
00:18:44 <mniip> er
00:18:49 <mniip> infinity0, I didn't update the paste
00:19:03 <infinity0> oh yes i was wondering
00:19:21 <mniip> https://repl.it/repls/LoyalLiveMaintenance
00:19:22 <mniip> there
00:19:22 <dminuoso> lingeeal: You could say that `getLine = getLine`, if (IO a) had an Eq instance.
00:20:10 <infinity0> ouch yes mniip 
00:20:31 <infinity0> do you want to file the bug or shall i? not sure if i have the right bg vocab for it but would be happy to follow along, i just created an account
00:20:46 <lingeeal> this does not make any sense..:( If a function says it returns IO String and its implementation open a file and prints its content, one time its prints "hello", another "world" (cause I opened the file and changed it). How is it referentially transparent? 
00:20:53 <mniip> infinity0, I can do it
00:21:00 <dminuoso> lingeeal: So `IO String` is a *recipe*, maybe filled with instructions to go to stdin and read some characters. That recipe is always the same, because the instructions remain the same.
00:21:18 <dminuoso> lingeeal: The `String` part does not denote that it has a `String` buried inside, but rather that it "would" produce a String if executed.
00:21:53 <lingeeal> dminuoso: then IO String has to contain only one recipe for referential transparency to hold
00:21:53 <mniip> much like Proxy String doesn't actually contain a stirng
00:22:06 <mniip> a particular IO String is only one recipe
00:22:10 <dminuoso> lingeeal: Well `IO String` is a type for *many* recipes.
00:22:15 <lingeeal> it says with same input returns same output -> which implies same recipe always
00:22:17 <dminuoso> lingeeal: But `getLine` is a particular recipe.
00:22:17 <mniip> much like a particular Int can be the number three
00:22:40 <mniip> you're mixing up something on the underlying logical level
00:22:48 <lingeeal> dminuoso: of course, i mean a recipe of one particular functino
00:22:52 <infinity0> mniip: great thanks, please cc me on the bug report i have the same username. the wiki page for injective type families also says "Use Keyword = InjectiveFamilies to ensure that a ticket ends up on these lists."
00:23:06 <mniip> yeah I am familiar
00:23:07 <lingeeal> like getLine's IO string is supposed to return always the same recipe, right?
00:23:11 <dminuoso> lingeeal: Yes!
00:23:14 <dminuoso> lingeeal: Precisely.
00:23:20 <lingeeal> :) thank you
00:23:21 <mniip> one thing I'd need to look up is whether to CC simonjp or goldfire
00:23:40 <Ariakenom> lingeeal: You can think of IO String being "String f();" from another language. You can call it and it will run.
00:23:44 <dminuoso> lingeeal: You could even force the evaluation of that recipe - but that has no effect really.
00:24:47 <Ariakenom> "openAndRead :: Filename -> IO ()" can then be seen as "(string f2()) f1(string filename);"
00:25:01 <dminuoso> lingeeal: The real interesting bit now is: A function: `execute :: IO String -> String` does not exist. 
00:25:11 <dminuoso> (Well it does, but lets really not dive into that because it distracts from the important parts)
00:25:29 <Ariakenom> calling it with the filename returns a "function" (it's not a haskell function) that will perform the effects later.
00:26:34 <mniip> infinity0, possibly related to https://ghc.haskell.org/trac/ghc/ticket/10833
00:27:29 <mniip> it is
00:27:34 <mniip> https://ghc.haskell.org/trac/ghc/ticket/12199 is closed as duplicate of 10833
00:30:36 <mniip> inconsistent huh
00:30:53 <infinity0> ah thanks for taking a deeper look. sounds like some theoretical issues there blocking it
00:31:47 <aleator> Has there been a change on how unary - (minus) is parsed between ghc 8.2 and ghc 8.4? 
00:36:12 <aleator> Has there been a change on how unary - (minus) is parsed between ghc 8.2 and ghc 8.4? 
00:38:07 <jle`> not that i know of aleator 
00:39:16 <mniip> what's a good good inductive set of combinators for expressing various   a1 -> a2 -> ... an -> ak
00:40:30 <mniip> @pl \a b c d e f g h -> d
00:40:30 <lambdabot> const (const (const (const . const . const . const)))
00:40:49 <mniip> not sure if like
00:41:11 <shachaf> Looks reasonably straightforward?
00:41:19 <shachaf> I mean, not for writing actual code.
00:41:29 <aleator> jle`: I have an expression `(-150 .* norm (shipPos .- clickPos))` which compiles on lts-9.something, and is a type error on lts-12.9. Changing it to `(negate 150 .* norm (shipPos .- clickPos))` fixes things, which I find quite surprising
00:41:59 <mniip> maybe X = B K
00:41:59 <jle`> huh
00:42:07 <jle`> i feel like that shouldn't be a type error but a parse error
00:42:09 <mniip> and then K (K (K (X (X (X (X I)))))
00:42:26 <jle`> > (-150 * 3)
00:42:29 <lambdabot>  -450
00:42:30 <jle`> oh hey it works
00:42:36 <jle`> unary - is weird
00:43:30 <mniip> ok, fair enough
00:44:41 <mniip> K :: a -> b -> a;  X :: (a -> b) -> a -> c -> b;  I :: a -> a;  L :: (a -> b -> c) -> (d -> a) -> (d -> b) -> d -> c
00:44:43 <aleator> jle': Yeah, it's bit like the unary - is now parsed with different precedence than before.
00:44:46 <mniip> and Y :: (a -> a) -> a
00:45:03 <jle`> aleator: i don't see anything in the release notes but sometimes they miss including things in the notes
00:46:09 <aleator> Yeah. Well, that kinda puts the unary minus even more firmly to the category "do not use". :)
00:47:47 <mniip> pardon the lousy syntax,
00:47:48 <mniip> Hyper = Y ((->) `L (L (L I))` (X (X I) `L (L (L I))` K (K I) `L (L (L I))` K (X I)) `L (L (L I))` (K (K I)))
00:51:01 <mniip> oops
00:51:16 <mniip> K (K (K (->)))
01:07:48 <Ariakenom> Is there a list of things built with frp in some shape somewhere?
01:11:36 <infinity0> mniip: luckily i managed to work around the issue https://repl.it/repls/DelectableDarksalmonNanotechnology
01:12:04 * hackage hriemann 0.3.3.3 - A Riemann Client for Haskell  http://hackage.haskell.org/package/hriemann-0.3.3.3 (shmish111)
01:12:05 <infinity0> by defining another HListLoad data type where the type param is the same as the regular HList but the internal structure expresses what i wanted with the fmap
01:12:34 <infinity0> i don't need arbitrary fmaps so this is good enough
01:14:05 <mniip> infinity0, I think the funciton would be much better written as 3 equations
01:14:34 <infinity0> sequenceLoad? oh yeah i actually did that originally but changed it because i thought that might be affecting the errors
01:49:16 <dminuoso> Is there some library that lets me pretty print arbitrary Show'able things with line breaks? Ive tried `pretty-show` but `ppShow` doesn't seem to insert line breaks on my data types
01:49:39 <merijn> dminuoso: There is! But I forgot what the name is
01:53:20 <Cale> There's groom
01:53:30 <Cale> which is just a trivial application of haskell-src-exts
01:53:45 <Cale> it just parses and then immediately pretty prints whatever
01:55:18 <jose_zap> dminuoso you mean that you are adding the line breaks yourself or you want the library to handle that for you?
01:56:56 <merijn> Cale: I recall using a library that would just layout existing show output prettily
01:57:08 <merijn> So you could drop it in without modifying your datatypes, etc.
01:57:18 <merijn> But I can't recall *at all* what i's called
01:57:29 <dminuoso> merijn: Just found https://hackage.haskell.org/package/pretty-simple 
01:57:33 <dminuoso> Which seems to do the job.
01:58:17 <Cale> http://hackage.haskell.org/package/groom-0.1.2.1/docs/src/Text-Groom.html#groom
01:58:32 <merijn> dminuoso: I think that's the one
01:58:48 <merijn> dminuoso: Also, unrelated but amazing to know about: the tree-diff package
01:59:02 <merijn> (Pretty sure that combination was how I found it)
02:13:29 <rudolfs> hello
02:18:21 <dminuoso> merijn: Gah just slightly annoying to have Text now there.
02:25:29 <berndl> Is there a way to make something like the following work: https://pastebin.com/raw/ae7jfgJg
02:25:30 <maerwald> T.unpack
02:25:43 <maerwald> :P
03:00:43 <AWizzArd> How cool is it to write a `head` function that expects a NonEmpty list so that it won’t fail? I think it’s not really useful.
03:01:25 <AWizzArd> How would I get such a NonEmpty value? I have a list and first need to call `null` on it to check if it is not empty. Only if it is not empty I can call the unsafe `head` function from prelude and extract the first item.
03:01:46 <AWizzArd> Then I can push it on a NonEmpty list and finally can call the safe `head` function, only to get back the item I am interested in.
03:05:25 <tdammers> or you write code that uses NonEmpty lists throughout, and never ever has empty lists at all
03:05:57 <tdammers> by the same logic, why would you ever have values that aren't wrapped in a Maybe? that just means you have to check that your value isn't Nothing all the time
03:06:03 <Taneb> Or you can write a function with type [a] -> NonEmpty a, using pattern matching
03:06:05 <jle`> AWizzArd: you're basically just saying that it's useless in the case where you take things directly from a list :P
03:06:22 <jle`> AWizzArd: it's useful when you never had a list in the first place
03:06:42 <AWizzArd> jle`: yes, when I am in the process of constructing it that will work.
03:06:59 <jle`> AWizzArd: there are many ways to get a NonEmpty without ever using a list
03:07:00 <AWizzArd> jle`: but for example as a filter result it’s less useful.
03:07:14 <jle`> most of the useful NonEmpty usages don't involve lists of any sort
03:07:22 <Boomerang> It can be useful with functions like `group`, `groupBy` (from Data.List.NonEmpty) for example :)
03:07:25 <jle`> or well, don't involve any [a]'s
03:07:34 <jle`> AWizzArd: what is a filter result?
03:07:50 <Cale> AWizzArd: There is https://hackage.haskell.org/package/semigroups-0.16.0.1/docs/Data-List-NonEmpty.html
03:08:00 <Cale> ah, already mentioned :)
03:08:56 <jle`> AWizzArd: NonEmpty isn't useful in every situation, of course.  example: when you want to represent an IO action, you'd use `IO a`, not `NonEmpty a`
03:09:09 <jle`> but in the situations it is designed for, it is very useful
03:09:23 <jle`> most of these situations don't involve getting something from a list, heh
03:10:59 <jle`> AWizzArd: but for what it's worth also, you wouldn't need to use unsafe head or null to create a NonEmpty from a list
03:11:23 <jle`> that's actually probably a really bad way to go about that, heh
03:11:45 <jle`> since yes it does default the purpose of everything in the first place :)
03:13:00 <jle`> @let toNonEmpty :: [a] -> Maybe (NE.NonEmpty a); toNonEmpty [] = Nothing; toNonEmpty (x:xs) = Just (x NE.:| xs)
03:13:01 <lambdabot>  Defined.
03:13:15 <jle`> no head or null or any other unsafe functions required :)
03:13:41 <jle`> AWizzArd: of course if you want to get the head of a [a] list, you wouldn't convert to NonEmpty.
03:13:56 <jle`> AWizzArd: you'd only use NonEmpty's head if you had a NonEmpty at hand, that was never a list in the first place probably
03:15:29 <matheus23> Hi! Has anyone tried to work with the haskell-ide-engine and vscode? I've got hie installed from their repo and the vscode extension. However the plugin doesn't work. When I run hie-wrapper in the console, it reports that it can't find "hie-8.4.3", however, which hie-8.4.3 reports my ~/.local/bin/hie-8.4.3 directory.
03:15:55 <maerwald> stack still copies non-changed binaries over and over again 
03:16:12 <tdammers> time for yet another Haskell build tool
03:16:15 <maerwald> and it's quite slow at it
03:17:46 <maerwald> tdammers: I would be already happy to remove hpack
03:17:50 <maerwald> next goal is to remove stack, yes
03:18:09 <maerwald> and then remove shake and just use make ;)
03:19:38 <jose_zap> matheus23 is ~/.local/bin/ in your path? Are you maybe changing the PATH in a way the wrapper cannot find the executable?
03:21:09 <matheus23> jose_zap: yes, I can run "hie-8.4.3" form my console. And running echo $PATH shows ~/.local/bin/ in there
03:22:36 <jose_zap> can you bin the output of the wrapper?
03:22:47 <matheus23> I tried setting "languageServerHaskell.hieExecutablePath": "${HOME}/.local/bin/hie-8.4.3" in my vscode settings. Now I have hlint suggestions, but the extension fails to run cabal configure. (Which is weird. I have a new-build style project, no 'dist' directory, etc.)
03:22:57 <jose_zap> let's also move this conversation to #haskell-ide-engine
03:23:46 <matheus23> jose_zap: I'm there
03:24:27 <BL[m]> Hello. Could someone help with this? I understand, what ScopedTypeVariables does, but why do I need it to annotate statements in do-notation? as far as i can tell, it has nothing to do with scope
03:30:41 <dminuoso> BL[m]: ScopedTypeVariables is an alternative to Proxy.
03:33:21 <cocreature> BL[m]: signatures on patterns are part of ScopedTypeVariables
03:33:28 <dminuoso> BL[m]: Consider a polymorphic type to be an abstraction a type, not unlike a lambda abstraction. That is `fmap :: forall a b f. (Functor f) => (a -> b) -> f a -> f b` can be thought of a type parametrized over 
03:33:32 <cocreature> BL[m]: if your binding in do notation is polymorphic then it actually makes sense
03:34:03 <cocreature> dminuoso: that doesn’t really explain why you need ScopedTypeVariables for "do x :: Int <- …; …"
03:34:03 <dminuoso> Ohh wait I misunderstood. Ignore my remarks.
03:34:23 <dminuoso> cocreature: Total brainfart.
03:34:30 <dminuoso> I repeatedly read TypeApplications.
03:34:33 <dminuoso> =)
03:34:49 <cocreature> ah now your comments make a lot more sense :)
03:39:09 <BL[m]> cocreature: i'm afraid, i can't see the part "signatures on patterns..." in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables. And when you talk about binding being polymorphic, do you mean polymorphic in monad or in type? If the latter, I can't see it: when writing type signature, I just specialize that polymorphic expression to concrete type, still no scope?
03:41:06 <cocreature> BL[m]: if you do something "do x :: a <- …; …" and use a after the ; then it will refer to the one bound there
03:41:32 <cocreature> the fact that you also need ScopedTypeVariables if there is no type variables is involved is somewhat confusing but that’s what we’ve got
03:42:42 <cocreature> BL[m]: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=scopedtypevariables#pattern-type-signatures that’s the relevant part of the docs
03:42:49 <BL[m]> ah, yes, this way it's a little bit logical, but still isn't convincing that much, because it has nothing to with type variable bound in forall :)
03:43:10 <BL[m]> thank you
03:44:03 <cocreature> iirc at some point there was a PatternSignatures extension
03:54:13 <merijn> hmm, so if I already have an Internal module, how do I name an exposed module that contains "things users shouldn't need"? (i.e. some confusingly typed exports I use to build on the package in other related packages)
03:54:24 <merijn> Right now it's called Utils, but that seems wrong
03:57:19 <Boomerang> You could have an `Internal` module that you export. And a `ReallyInternal` that you don't ^^
03:57:29 <Boomerang> (with a better name for `ReallyInternal`)
03:57:37 <tdammers> Data.MyLib.Internal.Internal :x
03:57:43 <merijn> Boomerang: Coming up with better names is the problem I'm having :p
03:57:57 <merijn> tdammers: I'm a sophisticated person, I don't use a Data or Control prefix :p
03:58:11 <Boomerang> Internal.Internal seems like a great solution! :D
03:58:36 <tdammers> merijn: no no no, you got that wrong - Data. means you're pragmatic and hard-working, Control. means you're sophisticated and smart
03:58:53 <cocreature> Control.Data.Internal.Utils.Types
03:58:59 <Ariakenom> merijn: death to Data
03:59:32 <Boomerang> Or you could expose My.Module.Internal but not expose My.Module.Internal.*
03:59:35 <tdammers> Boomerang: no, it's not - IMO the implied contract with "Internal" is "you can play with this, but I will probably change things without prior notice, and anything in here is not considered part of the API"
04:00:09 <Ariakenom> Data.Concurrent.Control
04:01:54 <merijn> tdammers: In this case I would consider it a fairly stable part of the API, but only for people doing very specific things (i.e. I have separate packages for pipes/conduit/etc. build on top of my code, but these functions are really only for people implementing a package like that)
04:02:16 <merijn> tdammers: So Joe Random hacker who is just *using* the library, rather than extending it that way probably should stay away
04:03:23 <cocreature> merijn: you could go for something like the .Core convention pipes uses
04:04:04 <tdammers> .Misc; .Hooks; .Extra; .Extensions... idk
04:04:15 <cocreature> .Foobar
04:04:31 <merijn> .HereBeDragons
04:04:36 <Ariakenom> .Data
04:05:04 <matheus23> .NotPorn
04:11:09 <tdammers> import Control.Data as Data.Control
04:17:00 <matheus23> Has anyone tried editor integration with the combination of: ghc 8.4, cabal new-build and vscode?
04:18:51 <matheus23> ghc-mod doesn't support ghc >= 8.2, haskell-ide-engine doesn't support cabal new-build, the vscode-ghc-simple plugin doesn't support new-build either, ghcid doesn't seem to work with new-build either
04:22:34 * hackage nqe 0.5.0 - Concurrency library in the style of Erlang/OTP  http://hackage.haskell.org/package/nqe-0.5.0 (xenog)
04:22:57 <merijn> matheus23: ghcid works with new-build if you specify a custom command
04:22:57 <cocreature> matheus23: ghcid does support new-build, try "ghcid -c 'cabal new-repl'"
04:29:44 <merijn> And while I'm asking hard naming questions: How would you name a datatype containing the allocation, cleanup, and work value for a "bracket"?
04:30:01 <merijn> Right now I have "Allocator", but that seems misleading
04:30:53 <Ariakenom> just Task?
04:31:14 <Ariakenom> TaskWithResource
04:31:29 <amx> bracketeer
04:31:46 <Ariakenom> yes ^
04:33:29 <Ariakenom> Bracket
04:34:05 * hackage haskoin-node 0.6.0 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-node-0.6.0 (xenog)
04:35:57 <dmwit> Do you ever do anything with such a data type besides calling `bracket` with its contents?
04:36:28 <dmwit> (If not, how about calling it `IO`?)
04:36:29 <merijn> dmwit: No, but since it's part of the public API I decided that having named fields would be slightly user friendlier
04:37:01 <merijn> dmwit: That's not general enough, because the entire point is that it's to be called with bracket's other than Control.Exception.bracket :)
04:37:34 <dmwit> Okay, okay, you caught me. How about calling it `m`?
04:37:39 <merijn> dmwit: Initially I had the bracket function as argument to my code and just returned a single final action, but that was a horrific monster
04:37:58 <merijn> dmwit: Doesn't work, because not all brackets allow the allocation and action in the same monad
04:38:46 <dmwit> Oh yeah? Neat! I take it this means you are cooking up your own library for generalizing bracket, then?
04:38:47 <merijn> dmwit: Consider Acquire from MonadResource which requires allocation and cleanup in IO or the bracket from MonadSafe which has separate monads for allocation and cleanup
04:39:17 <merijn> dmwit: No, I'm just returning the individual actions so that I can wrap them with the relevant bracket I care about
04:39:51 <merijn> dmwit: So I can share the actual logic across conduit/pipes/etc.
04:47:52 <c50a326> in this example from "... First Principles" https://lpaste.net/2790696348226158592 the 'do' notation is used neither in a monad or a list comprehension or with 'in', so I'm wondering how it "sugars" ?
04:49:14 <c50a326> the code seems to be synonymous with using let, in instead of do, let
04:49:18 <Ariakenom> c50a326: do {let x = []; x}
04:49:19 <merijn> c50a326: That use of let inside do gets desugred to "let in"
04:49:30 <merijn> @undo do { let x = []; x }
04:49:31 <lambdabot> <unknown>.hs:1:20:Parse error: }
04:49:40 <merijn> @undo let x = []; x
04:49:40 <lambdabot> <unknown>.hs:1:14:Parse error: EOF
04:49:43 <merijn> hmm
04:50:17 <Cale> c50a326: That's awkward, you'd never ordinarily write that, though it is valid.
04:51:00 <merijn> c50a326: Keep in mind that do notation, being syntactic sugar, is a *syntactic* rewrite and doesn't actually look at the types of things it rewrites
04:51:19 <merijn> c50a326: This means that do (ab)use like this works fine iff the resulting unsugared version happens to be correct
04:51:26 <Cale> do { let { <decls> } ; x } = let { <decls> } in do { x } = let { <decls> } in x
04:52:12 <c50a326> ah I suppose do only starts being monadic when you use a '<-'
04:52:44 <c50a326> ... probably using words wrong but whatever :p
04:53:14 <merijn> c50a326: Right, <- ends up desugaring to >>= which is what ends up enforcing a Monad constraint
04:54:14 <berndl> Is there a way to simulate a class constraint like this: class Monoid (f a) => FreeMonoid f ?
04:56:11 <merijn> heh, maybe I should call "public internals" just "externals" :p
04:56:25 <hexagoxel> c50a326: do { a; b } already necessitates a monad
04:57:20 <Ariakenom> :t \a b -> do {a; b}
04:57:21 <lambdabot> Monad m => m a -> m b -> m b
04:57:39 <tdammers> similar to how "public API" is a bit of a tautology
04:57:54 <Ariakenom> but you can use the ApplicativeD extension to reduce it to applicative
04:58:01 <Ariakenom> ApplicativeDo
04:59:47 <aldum> l
05:00:08 <merijn> Cale: While you're here. I recall there is some freenode bot for quickly banning spam that all #haskell ops have access to?
05:02:27 <aldum> ChanServ?
05:02:51 <merijn> aldum: No, that's manual. There's some regex based bot that quickly kills spam
05:04:02 <merijn> Unrelatedly: Can I stop Haddock showing an explicit forall when I used ScopedTypeVariables?
05:05:21 <Boomerang> Wrapper function without the forall?
05:06:51 <c_wraith> merijn: not since the introduction of TypeApplication, which makes the order type variables are written in an explicit forall significant
05:07:10 <merijn> Dammit
05:07:21 <merijn> That's annoying as shit
05:07:43 <merijn> I don't need forall making my intimidating types more intimidating
05:08:01 <Boomerang> I wish the order of the arguments in the forall appeared in `:t`
05:08:25 <cocreature> Boomerang: :set -fprint-explicit-foralls
05:08:44 <Boomerang> Oh! :D Nice one, I'll have put that in my .ghci
05:09:01 <ph88> i ran the ghc test suite, is my ghc ok with this? https://bpaste.net/show/2dc5d75c3cc0 or do i need to worry something is horribly wrong ?
05:09:23 <merijn> So I'm stuck writing a wrapper function if I want to avoid explicit forall's in haddock?
05:11:34 * hackage servant-auth-token 0.5.5.0 - Servant based API and server for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-0.5.5.0 (NCrashed)
05:12:45 <c50a326> hexagoxel: but in the example I linked, the type of the function we're in is :: (a, a, a) ... I don't see a monad instance of this in Control.Monad, so how can it work? 
05:13:28 <hexagoxel> c50a326: yeah, i was a bit sloppy, let me rephrase
05:13:54 <hexagoxel> do { a; b } where a is not of the form "let .." already implies a monad
05:14:04 <c50a326> ah, ok, thanks
05:15:25 * dminuoso .oO( ApplicativeDo )
05:18:03 <Boomerang> :t (>>=) @((->) _) -- I couldn't see the example, but was it using this Monad instance by any chance?
05:18:04 <lambdabot> error: parse error on input ‘->’
05:18:34 <Boomerang> @let set -XTypeApplications
05:18:34 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
05:19:08 <hexagoxel> yeah, with ApplicativeDo this might be weakened to Applicative, and with RecursiveDo it might be strengthened to MonadFix
05:19:20 <Ariakenom> % :t (>>=) @((->) _)
05:19:20 <yahb> Ariakenom: (w -> a) -> (a -> w -> b) -> w -> b
05:26:53 <Boomerang> @undo do { let { x = [] }; x }
05:26:53 <lambdabot> let { x = []} in x
05:30:47 <merijn> ugh...the only thing more annoying than documenting things is documenting things where you just barely understand what it's doing >.>
05:37:54 <fendor> are there old hoogle databases from stack lts? 
05:52:55 <ph88> anyone know which version of llvm ghc 8.6 uses ?
05:53:12 <ph88> i guess 6.0 just like head ?
05:53:34 <stiell> When trying to use TemplateHaskell functions such as deriveJSON and deriveSafeCopy on type constructors that have a type variable with a custom kind, I get the error "Expected kind ‘CustomKind’, but ‘n_avaV’ has kind ‘*’". Is there any way to get these TemplateHaskell functions to generate the correct code?
05:57:55 <Ganwell> I needed a function than can join a x y where x y can both be String or Char. I ended up using MultiParamTypeClasses and now I am worried, that I used a lot of magic for something, that could very simple: https://gist.github.com/ganwell/78632c6d30a2d8551be1987d58387c6c
05:59:04 * hackage haskoin-store 0.2.0 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.2.0 (xenog)
05:59:30 <Boomerang> stiell: Would putting a kind signature help? https://hackage.haskell.org/package/template-haskell-2.13.0.0/docs/Language-Haskell-TH.html#v:KindedTV
06:05:02 <gentauro> what is wrong with people (reddit.com/r/haskell "best introduction to lenses in Haskell" -> https://www.youtube.com/watch?v=qfCd89enCXE)
06:06:04 * hackage ghc-typelits-knownnat 0.6 - Derive KnownNat constraints from other KnownNat constraints  http://hackage.haskell.org/package/ghc-typelits-knownnat-0.6 (ChristiaanBaaij)
06:06:20 <Boarders> if I have an instance for something like monoid for a type I define then can I specialise it at that type?
06:06:36 <Boarders> and if so where do you put the pragma?
06:13:04 * hackage haskoin-store 0.2.1 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.2.1 (xenog)
06:24:43 <stiell> Boomerang: where would I put that?
06:24:59 <stiell> Problem example: https://gist.github.com/stiell/67aa6ee760db7fb3c94f180fc50adc9d
06:28:44 <cocreature> Ganwell: why do you need x and y to be both String and Char?
06:29:37 <cocreature> Ganwell: I would just require the caller to convert their Char to a String and only accept String (or Text)
06:31:34 * hackage ghc-typelits-extra 0.3 - Additional type-level operations on GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-extra-0.3 (ChristiaanBaaij)
06:39:04 * hackage odbc 0.2.1 - Haskell binding to the ODBC API, aimed at SQL Server driver  http://hackage.haskell.org/package/odbc-0.2.1 (ChrisDone)
06:49:35 <stiell> (It appears deriveJSON does work in the minimal example, but deriveSafeCopy doesn't. With deriveJSON I have a different problem in my real code: I need to somehow modify the context of the generated instances.)
06:59:52 <Ganwell> cocreature: I wanted to write this [1] in applicative form, because it looks more like a grammer, but it seems a bad idea. [1] https://gist.github.com/ganwell/c9bdcc1c317d699236d31c080c1c5e87
07:03:55 <merijn> @where ops
07:03:55 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
07:04:06 <merijn> Pinging some op to #haskell-ops :)
07:15:38 <matheus23> Everyone thats curious: I found a solution for getting type errors reported in vscode with cabal and newstyle builds and ghc 8.4 :) Basically I'm using ghcid --command "cabal new-repl" -o ghcid.txt (and a .ghci file in my project directory with :set -ferror-spans) all with a super simple vscode extension: haskell-ghcid. Can recommend :)
07:16:06 <Ganwell> cocreature: I've got something that looks nice, without magic: joinA3 x y z = [x] ++ y ++ [z]; lit = liftA3 (joinA3) litSep litString litSep. Thanks a lot.
07:16:43 <merijn> hmm, there's really no ops around?
07:27:21 <maerwald> matheus23: ghcid doesn't work for projects with multiple targets though
07:27:38 <matheus23> hmm
07:27:40 <maerwald> and upstream doesn't seem too interested to fix
07:28:16 <matheus23> what exactly do you mean by multiple targets? One ghc project and one ghcjs project?
07:28:32 <maerwald> https://github.com/ndmitchell/ghcid/issues/175
07:28:38 <merijn> I've been working on a ghcid-based tool that works properly in that setting, but it's far from done and I don't have a lot of time to work on it
07:32:57 <maerwald> merijn: repo link?
07:35:07 <tsaka__> With Repa, I don't really understand why the result of computations are wrapped in arbitrary monads. For example: "let [w] = foldP (+) 0 arr" then printing in ghci yields "w=AUnboxed Z [55.0]" with type "w :: Array U DIM0 Double". However if we instead do "let w = foldP (+) 0 arr", then it still prints the same but has type "w :: Monad m => m (Array U DIM0 Double)". Which monad "m" is that?
07:35:15 <matheus23> maerwald: I'm confused. Doesn't ghcid --command "stack ghci exe:my-executable" work?
07:35:29 <matheus23> or however the syntax of stack ghci with specifying the executable works :S
07:36:31 <Athas> tsaka__: by the type of foldP, whichever one you like!  My guess is that it's so it can call 'fail'. 
07:36:58 <Ariakenom> yes m is arbitrary. in your first example it's []
07:37:17 <maerwald> matheus23: see https://github.com/ndmitchell/ghcid/issues/175#issuecomment-403265406
07:37:22 <Ariakenom> and it's just put in pure I guess
07:37:32 <delYsid> Before I upload this to cabal, could someone please have a look? https://github.com/mlang/brick-dropdownmenu
07:37:35 <tsaka__> how can the result of the fold be instantiated and printed without specifying which monad to use?
07:37:57 <Athas> tsaka__: ghci will default to IO and just print it.
07:38:23 <matheus23> maerwald: did you run "stack ghci --main-is <xxx>:exe:<xxx>" in your project directory, did it work?
07:38:35 <matheus23> the error message seems to be a parse error from stack, not from ghcid
07:39:04 <maerwald> matheus23: see the issue, I've explained it there already
07:39:39 <maerwald> the ghcid parser is broken
07:39:41 <matheus23> maerwald: I read through the whole issue conversation, I still don't quite understand, sorry
07:39:50 <maerwald> I even point to the exact line
07:39:56 <c50a326> hey I'm trying that thing I've seen some of you guys doing with type applications, I want to see the :t (>>=) for State, so I tried `:t (>>=) @(State s)` but it says the type variable s isn't in scope
07:40:11 <c50a326> I guess I can just use Int or whatever
07:40:32 <maerwald> matheus23: it splits --command='stack ghci --main-is <xxx>:exe:<xxx>' wrong
07:40:33 <matheus23> maerwald: ok but the lines you linked were just in case you used a .ghcid file, did you try it without one? Then those lines shouldn't be executed
07:40:37 <maerwald> it just splits be whitespace
07:41:05 <maerwald> I use it via my editor, as explained
07:41:45 <matheus23> maerwald: so... you mean an extension runs ghcid for you, right? or an editor plugin?
07:41:53 <c50a326> ah I can use @(State _) also
07:42:20 <maerwald> matheus23: the plugin is in that very repository, see https://github.com/ndmitchell/ghcid/tree/master/plugins/nvim
07:42:29 <maerwald> the issue title already says "fails with nvim" ;)
07:43:30 <c50a326> also I was trying to write the type sig for (>>=) in the State monad myself, I came up with: (>>=) :: State (s -> (a, s)) -> ((s -> (a, s)) -> State (t -> (b, t))) -> State (t -> (b, t))
07:43:39 <c50a326> which is wrong, it's: (>>=) :: State s a -> (a -> State s b) -> State s b
07:43:58 <c50a326> but maybe someone could tell me how wrong I was and why, or something
07:45:06 <tsaka__> Which monad should I use for the Repa fold, if I just want the result? Doing "let [w] = ..." seems fine but it does come with an extra list allocation
07:45:06 <cocreature> c50a326: I think you might have confused the State data constructor and the State type constructor
07:45:19 <cocreature> the State type constructor takes two arguments s and a
07:45:39 <cocreature> the State data constructor takes one argument of type s -> (a, s) and constructs a value of type State s a
07:45:52 <Athas> tsaka__: Control.Monad.Identity.
07:45:55 <Boomerang> maerwald: Look at the bottom of that readme for the nvim plugin: `:Ghcid -c command`
07:46:31 <Boomerang> Try: `:Ghcid -c "stack ghci --main-is <xxx>:exe:<xxx>"`
07:46:35 <Athas> Man, the Repa types are complicated.
07:47:06 <dmwit> c50a326: Besides what cocreature said, I think there's two other high-level places where you got the type wrong.
07:47:11 <Boomerang> Or was that what you meant with `--command`?
07:47:30 <tsaka__> ahihi: can the Identity monad be escaped? Can I get an "a" from "Identity a"?
07:47:36 <dmwit> c50a326: One is that the state types have to be the same in all the arguments and the result type. Your `s` and `t` is too optimistic -- it's not possible in general to chain together actions which operate on different types of state.
07:47:47 <Athas> tsaka__: yes, runIdentity.
07:48:10 <dmwit> c50a326: And the second is that `(>>=)`'s second argument is a function which takes a bare (non-monadic) value. So your `((s -> (a, s)) -> ...)` should be just `(a -> ...)` instead.
07:49:00 <c50a326> ok, thank yoU!
07:51:15 <jose_zap> tsaka__ maybe you already know this, but hoogle is a great help to answer that typeof questions https://www.haskell.org/hoogle/?hoogle=Identity+a+-%3E+a
07:54:31 <elated> https://gist.github.com/TiredSounds/da1791a12c571d91abbbba913a6edc42 how come "mappend x mempty" pattern matches here? GHC tells me it's redundant when I add it explicitly
07:55:02 <dmwit> elated: The pattern `mempty` matches any value, and binds it to the name `mempty`.
07:55:18 <dmwit> elated: It does *not* match a value, check that it is equal to `mempty`, and then proceed, as you are probably thinking it does.
07:55:36 <elated> ah!
07:56:21 <c50a326> ooo lpaste.net is down :o
07:56:28 <c50a326> for me, anyway
07:56:31 <Ariakenom> elated: You probably want to use guards
07:56:36 <dmwit> lpaste has been in its death throes for a while.
07:57:00 <Ariakenom> nevermind me
07:57:53 <dmwit> Yeah, I think not guards. You want to avoid calling `(==)` here to avoid an unnecessary `Eq` constraint.
07:57:57 <c50a326> are lines 5-7 correct? https://ptpb.pw/NZ5M/hs it seems like it requires s0 to be computed/known before it can be, seems impossibly circular?
07:58:39 <c50a326> this is from https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
07:58:52 <Rembane> c50a326: (y, s2) are defined at line 7, and can be used by line 5 if that's what your concern is?
07:59:15 <Rembane> c50a326: You can rewrite it as a let-in-expression if that makes more sense to you
08:00:07 <c50a326> but line 7 requires line 6 to be computed... and line 6 requires line 5... it seems to me?
08:00:56 <Rembane> c50a326: Line 5 requires that there is a s0, and if q' gets called there should be one as an argument. 
08:01:45 <c50a326> oh q' is a function
08:01:58 <c50a326> sorry
08:02:06 <Rembane> No worries. It's some really dense code. :)
08:39:59 <acoret_laptop> i got a problem,does ghc break in archlinux? or i make some stupid mistake? "123" =~ "123" failed,i have imported Text.Regex.Posix 
08:42:29 <cocreature> acoret_laptop: what exactly do you mean by “failed”?
08:43:10 <acoret_laptop> cocreature: it tell me error,Non type-variable argument, RegexContext Regex [Char] target,but book tell me it should work
08:43:59 <cocreature> acoret_laptop: which book? can you show us what exactly it says?
08:44:11 <cocreature> either way this is definitely not related to using archlinux
08:45:08 <acoret_laptop> cocreature: real word haskell,i found answer, i need start ghci with -XFlexibleContexts
08:45:26 <acoret_laptop> cocreature: thanks
08:45:32 <cocreature> acoret_laptop: that fixes the error but I suspect that in this case you probably want to provide a type annotation instead
08:45:40 <cocreature> e.g. "123" =~ "123" :: Bool
08:46:31 <acoret_laptop> cocreature: yes,big mistake.thanks a lot
08:47:19 --- mode: ChanServ set +o glguy
08:50:42 --- mode: glguy set +v dataN
08:50:42 --- mode: glguy set +v dataN
08:50:52 --- mode: glguy set -v dataN
08:50:53 --- mode: glguy set -v dataN
09:04:32 <maerwald> uh, brittany takes 20+ seconds on 1100 loc file
09:07:10 --- mode: glguy set +v titan_
09:10:59 <mniip> hey glguy
09:11:05 <mniip> I came up with a cooler encoding
09:11:28 <ph88> below 0 ?
09:11:43 <glguy> mniip: What's that?
09:11:51 <mniip> I mean for generics
09:12:00 <glguy> Sure, what's the encoding?
09:12:49 <hexagoxel> maerwald: this is the third time in the last couple days that you name some potential problem in brittany, yet you still have not reacted to my attempts to find a solution to the first issue you mentioned.
09:13:06 <mniip> I don't have a good name for this function yet, but basically,
09:13:09 <maerwald> hexagoxel: where is that attempt
09:13:13 <mniip> x = (const .)
09:13:15 <maerwald> I'm not subscribed to any issues
09:13:44 <mniip> and then L short for liftA2 @((->) _)
09:13:46 <hexagoxel> i see that you also complained about hindent, so it is somewhat balanced, but may i kindly request to open issues in the tracker?
09:14:00 --- mode: glguy set +v dataN
09:14:09 --- mode: glguy set -v dataN
09:14:23 <mniip> so first you replace all applications with I lifted with L as many times as there are parameters
09:14:31 <ph88> ah brittany was a code formatter, was it not ?
09:14:40 <mniip> then in each argument to L you use K and X applied to I to form a selector
09:14:45 <mniip> e.g
09:15:00 <dataN> Lifted Lenses? 
09:15:04 <mniip> data Foo a f = Foo (f a)
09:15:34 <mniip> '\a f -> f a' turns into L (L I) (\a f -> f) (\a f -> a)
09:15:48 <hexagoxel> maerwald: i replied in-channel a few days ago, and wrote you an @tell message approx. 48h ago.
09:16:00 <mniip> and in turn  L (L I) (K I) (X I)
09:16:03 <maerwald> oh, I rarely query those
09:16:12 <mniip> no wait
09:16:20 <maerwald> pm is preferred
09:16:25 <mniip> yeah right that's correct
09:16:41 <mniip> and then of course you have the Y combinator for things like
09:16:53 <mniip> Hyper a b = Hyper b a -> b
09:17:04 <maerwald> also, I'm investigating code formatters on the fly. creating a ticket requires a good case to make
09:17:10 <acoret_laptop> i got a other question, is that possible about this? Could not find module ‘Prelude’
09:17:12 <mniip> Y (\hyper a b -> (->) (hyper b a) b)
09:17:12 <maerwald> not just "I don't like this"
09:17:28 <hexagoxel> ph88: yes
09:18:31 <dataN> is the term levity for things like sort, or just for * :: * ?
09:18:48 <acoret_laptop> i try to install pandoc,but i tell me ,install zip-archive failed
09:19:19 <maerwald> I don't even know how to query messages sent to lambdabot
09:19:37 <dataN> i.e. is "more lifted" the same as "of higher levity" ?
09:19:37 --- mode: glguy set +v _sras_
09:20:01 <_sras_> Is the "Typeable" type class special cased by the GHC in anyway?
09:20:06 <maerwald> hexagoxel: so I don't know what you wrote me...
09:20:12 <geekosaur> _sras_, very
09:20:42 <geekosaur> it's autogenerated, handld specially in the typechckr, and making your own is an error. derivng etc. is permtited but deprecated
09:21:33 <geekosaur> ghc needs to use it internally to ensure type safety, so it's pretty much read only for users
09:21:44 <_sras_> geekosaur, deriving is deprecated?
09:21:47 <hexagoxel> maerwald: look, i don't see it as my job to search through my scrollback. if you want any issues resolved, feel free to use the tracker, where i can be relatively certain that an answer will reach you or other interested parties.
09:22:05 <hexagoxel> it is at https://github.com/lspitzner/brittany/issues
09:22:36 <tdammers> deriving is redundant, because everything is Typeable by default now
09:22:54 <geekosaur> _sras_, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-typeable-instances
09:23:07 <geekosaur> "Derived instances of Typeable may be declared if the DeriveDataTypeable extension is enabled, but they are ignored, and they may be reported as an error in a later version of the compiler."
09:24:45 <maerwald> hexagoxel: well, if you want me to respond to something, I have to be able to read it right? ;)
09:25:07 <geekosaur> maybe you two shoudl learn about email. or web forums?
09:25:15 <maerwald> pm in irc works fine
09:25:16 <geekosaur> orbug trackers
09:25:23 <maerwald> and this was just an irc discussion
09:25:54 <maerwald> no idea how lambda bot works, @help doesn't show me much either
09:26:27 <maerwald> never used it for messages
09:26:39 <dataN> it would be good to be able to have function promotion without template haskell 
09:26:59 <c50a326> what's another type that's like State (that is a Monad and a newtype that wraps a function)? I think I just about grok State, I want to practise on something else
09:27:24 <dataN> Codensity 
09:28:11 <dataN> runCodensity :: forall b. (a -> m b) -> m b	
09:28:49 <dataN> its the continuation monad
09:29:22 <dataN> oh wait, maybe without the forall
09:31:13 <fresheyeball> I need help reasoning throught an abstraction
09:31:24 <fresheyeball> Lets say we have a type for 2 element sets
09:31:28 <fresheyeball> Set2
09:31:34 <Vyse007> Another parsec query - how do you match zero or one time? 'many' applies zero or more times, and 'many1' applies one or more times. Use case is that if I have something like "<a><b>c", where "a" and "b" are optional. I suppose spamming 'try' everywhere is one way... 
09:31:34 <_sras_> geekosaur, I looked at that page, and It is not clear to me. Does it mean that I won't be able to use Typeable with user defined data types?
09:31:44 <fresheyeball> so we can easily write something like
09:31:57 <fresheyeball> toTuple :: Ord a => Set2 a -> (a, a)
09:32:01 <geekosaur> _sras_, every type hasa Typeable instance, generatdby the compiler
09:32:09 <geekosaur> you have no say over its existence or its value
09:32:09 <cocreature> Vyse007: "optional"
09:32:16 <geekosaur> but you can rely on it being there
09:32:35 <fresheyeball> now lets say we have a type for directional tuples
09:32:54 <fresheyeball> data Directional a = Directional { from :: a, to :: a }
09:33:26 <fresheyeball> now lets say we go from Set2 to Directional
09:33:37 <Vyse007> cocreature: Thanks. I looked at the doc but somehow didn't notice this.
09:33:40 <fresheyeball> toDirectional :: Ord a => Set2 a -> Directional a
09:33:41 <geekosaur> you stil need to have it as a constraint if needed,ut you never have to ask for it to be created, because ghc always creates it for its own use
09:33:51 <fresheyeball> that is fine and dandy, and very easy to write
09:34:21 <fresheyeball> but Set2 does is not ordered on Eq, so semantically, the fact that `a` has Ord, does not mean the Set2 is ordered
09:34:53 <fresheyeball> so there are 2 valid implimentations of toDirectional
09:34:56 <hexagoxel> maerwald: and i wrote you in here, when you were present. feel free to read that.
09:35:16 <fresheyeball> so to control which direction we go, we need another type?
09:35:27 <fresheyeball> data Direction = Id | Reverse
09:35:29 <fresheyeball> and we get
09:35:30 <hexagoxel> if that is too vague of a reference, tough luck. you chose this form of communication.
09:35:46 <fresheyeball> toDirectional :: Direction -> Set2 a -> Directional a
09:36:15 <_sras_> geekosaur, Oh. I see. But I saw this comment in reddit from "edwardkmmet" that says "Otherwise you always have to worry about someone doing typecase and mucking with your ability to reason with parametricity." 
09:36:16 <fresheyeball> that works too and is not entirely unpleasent 
09:36:22 <_sras_> geekosaur, https://www.reddit.com/r/haskell/comments/4mu30y/what_is_the_point_of_typeable/d3yakg6/
09:36:38 <fresheyeball> however, the data Direction encoding is kind of annoying
09:36:49 <fresheyeball> I might want to determine direction in my code logically based on a number
09:36:56 <fresheyeball> where we could having something like this
09:37:12 <geekosaur> _sras_, that's just what I said earlier: [14 16:33:19] <geekosaur> you stil need to have it as a constraint if needed,ut you never have to ask for it to be created, because ghc always creates it for its own use
09:37:13 <_sras_> isn't that comment talking about issues with having instances of typeable automatically available?
09:37:23 <fresheyeball> toDirection :: Num a => a -> Direction; toDirection x = if x < 0 then Reverse else Id
09:37:26 <_sras_> geekosaur, Ah.Yes.
09:37:27 <maerwald> hexagoxel: I did, but I have no idea what you mean with "attempt to fix the first issue", which you apparently sent to lambdabot, not me
09:37:29 <geekosaur> it is magically created; it is not magically always visible
09:37:46 <maerwald> so I can't comment on it
09:37:49 <hexagoxel> maerwald: let me switch to pm for this
09:37:51 <fresheyeball> so now I am thinking this might be a typeclass somehow
09:37:51 <geekosaur> because if it were, anyoen could use it to typecase behidn your back. you stil need to declare that any given expression is making use of it
09:37:54 <fresheyeball> such that
09:38:23 <fresheyeball> toDirectional :: HasDirection a => a -> Set2 b -> Directional b
09:38:26 <_sras_> geekosaur, Yes. Thank you. I get it now.
09:38:31 <fresheyeball> err
09:38:47 <fresheyeball> toDirectional :: (HasDirection a, Ord b) => a -> Set2 b -> Directional b
09:39:16 <fresheyeball> So my question is, is there a name for what I am observing here?
09:39:33 <fresheyeball> Are there known laws for the HasDirection typeclass?
09:39:47 <fresheyeball> Is this a thing? Am I developing an anti-pattern here?
09:41:16 <fresheyeball> Is there maybe a class around negatiablity?
09:41:39 <fresheyeball> where we can determine if the term is positive or negative? 
09:42:09 <fresheyeball> kind of a class of types that are surjective to types with only 2 inhabitants?
10:01:57 <wroathe> In situations where both let and where can serve the same purpose which do people typically use, and why?
10:03:56 <maerwald> how can you tell stack to recompile an installed package
10:04:09 <maerwald> e.g. because you want to apply different ghc options
10:05:23 <maerwald> tried: stack install --force-dirty --ghc-options=-fforce-recomp
10:05:25 <maerwald> doesn't work
10:16:04 * hackage haskoin-node 0.6.1 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-node-0.6.1 (xenog)
10:58:17 <ph88> how can i let stack build only with 2 cores instead of all 4 cores ?
10:58:53 <cocreature> ph88: stack build -j2 should work I think?
10:59:31 <ph88> ah yes thx
10:59:34 * hackage haskoin-store 0.2.2 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.2.2 (xenog)
10:59:35 <ph88> i put that with ghc-options before
11:09:38 <dmwit> wroathe: where, because I prefer to think of "what is the answer" first and "how do I compute it" second. But I see no problem with `let`/`in`.
11:11:07 <dmwit> I generally prefer where-bound things to go top-down (i.e. earlier bindings are defined in terms of later bindings) and let-bound things to go bottom-up.
11:15:11 <dmwit> ?tell fresheyeball You might be interested in the Down newtype. `Down a` is just like `a`, except its `Ord` instance is reversed. Sounds like just what you want for your `Set2` question.
11:15:11 <lambdabot> Consider it noted.
11:21:21 <glittershark> let foo = iso hither thither where { hither = ... ; thither = ... }
11:21:33 <glittershark> I can't believe I wrote this code but also I'm delighted
11:22:15 <crestfallen> hi I've been studying the algebraic representation for List, Tree, and counting inhabitants of (a -> b). where should I go from here, ie now that I know the principle behind counting inhabitants of a Type ? 
11:22:48 <cocreature> crestfallen: write actual programs? :)
11:23:03 <dmwit> cocreature++
11:24:36 <crestfallen> well, why does the taylor series keep coming up while studying these ideas?
11:25:01 <dmwit> Counter-question: how come thermal expansion doesn't come up very much while studying these ideas?
11:25:01 <crestfallen> and catalan numbers.
11:25:13 <crestfallen> goodbye
11:25:22 <dmwit> There's *lots* of ideas in math. ...
11:25:28 <dmwit> Guess I won't finish that thought.
11:29:20 <MarcelineVQ> Should I ​be concerned if thermal expansion does keep coming up?
11:31:04 <dmwit> I dunno. Probably not.
11:31:49 <dmwit> If you study a lot of related things, there's bound to be some concept that comes up a lot. That's the only point I was trying to make.
11:34:08 <dmwit> But this is starting to verge on tautology, since if you press me on what I mean by "a lot of related things" maybe I will end up at "well if you study them and some concept comes up a lot, they're related".
11:34:33 <MarcelineVQ> You know what comes up most often? tautology
11:34:50 <MarcelineVQ> Though not as much as composition.
11:37:04 * hackage haskoin-store 0.2.3 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.2.3 (xenog)
11:47:11 <merijn> I forgot, who was working on haddock again?
11:48:34 * hackage crypto-enigma 0.0.2.13 - An Enigma machine simulator with display.  http://hackage.haskell.org/package/crypto-enigma-0.0.2.13 (Orome)
11:55:45 <cocreature> merijn: alex biehl
11:57:44 <merijn> cocreature: Actually, since you use new-build too: Do you know what might be causing "new-haddock" to not include documentation for re-exported symbols? Re-exports from base appear to be fine, but from other dependencies appear problematic?
11:58:44 <cocreature> merijn: have you installed docs for those dependencies?
11:59:26 <Ariakenom> tautology's are underrated. the mundane needs to be stated, because it probably wasn't mundane at first
11:59:44 <merijn> cocreature: Yes, no, maybe?
11:59:48 <merijn> cocreature: How do I check?
12:00:52 <merijn> cocreature: I have "documentation: True" in my cabal.project?
12:01:32 <cocreature> that should help if you have set that before building the deps
12:01:39 <merijn> Also not really sure how I'd make it build the docs if they were missing...
12:01:53 <cocreature> afaik you can’t easily (short of deleting things in the store)
12:02:05 <cocreature> I think things have improved somewhat in HEAD but I don’t know the current state
12:02:23 <merijn> I'm running HEAD from about 1 or 2months ago
12:02:31 <cocreature> the fact that building docs for deps is still somewhat flaky is the only reason why I still bother building docs with sandboxes and not new-build
12:03:00 <merijn> So I guess I'll just have to nuke the store. Was there anything magic I had to do besides nuke the store dir?
12:03:59 <cocreature> you could also just temporarily set --store-dir or whatever the flag is called
12:04:19 --- mode: glguy set +v jpynchon
12:05:05 <merijn> cocreature: Yeah, but if this is the issue I want to rebuild stuff with documentation enabled anyway :p
12:09:00 --- mode: glguy set +v i0-dfn
12:09:14 <i0-dfn> how do i pass an associated type family constructor to a data kinds constructor? ghc is complaining about "type family ‘Ref’ should have 1 argument, but has been given none"
12:09:17 <i0-dfn> https://repl.it/repls/ImmaculateRecklessCoin
12:10:37 <i0-dfn> i can work around it by moving Req inside TyEqAll but it seems like my first example really should work
12:10:46 <i0-dfn> s/Req/Ref
12:12:07 --- mode: glguy set +v dataN
12:12:09 <cocreature> merijn: but if it isn’t you haven’t nuked everything for no reason :)
12:12:17 <dmwit> i0-dfn: Alas, you can't partially apply type families.
12:13:03 <i0-dfn> ah ok :( is there a reason behind that, or a link to an issue i can cite in my comment for the workaround
12:13:54 <dmwit> Hm. I'd poke around in the original type families paper; if it's anywhere, it's there.
12:14:07 --- mode: glguy set -v dataN
12:14:36 <dataN> GHC says; https://pastebin.com/5AtTpWrL
12:15:33 <i0-dfn> ah i see this https://github.com/ghc-proposals/ghc-proposals/pull/52
12:17:05 <cocreature> dataN: GHC will never be able to deduce n' because there might be multiple n' for which AtT ts n' maps to the same type
12:17:08 <i0-dfn> mniip: wondering what the status on that is ^
12:17:20 <dataN> oh no!
12:19:19 <dataN> how does it work then?
12:20:19 <dataN> because its saying something about injective types?
12:20:58 <cocreature> if AtT was injective then GHC would have a chance of deducing n' from the return type
12:21:15 <dataN> oh right, so there is hope
12:21:20 <dataN> that is good
12:21:30 <cocreature> in this case it looks like you probably want the N parameter to be a singleton and then use the type-level nat as the argument to AtT
12:22:14 <mniip> i0-dfn, abandoned of sorts
12:22:29 <mniip> there's a lot of theoretical foundational stuff to be ironed out
12:22:43 <mniip> this probably won't come separately from dependent haskell
12:23:34 <i0-dfn> ah ok, i guess my workaround isn't too ugly i can keep it for a while
12:27:43 <Fare> Is there a good pubsub infrastructure for in-process concurrent haskell programs?
12:28:07 <dataN> cocreature: whats the syntax for doing so>
12:28:08 <dataN> ?
12:28:30 <Fare> i.e. using mvars
12:29:43 <cocreature> dataN: this is not about syntax. you need to make a new datatype corresponding to the singleton version of N and use that
12:30:10 <monochrom> Fare: No, but the "async" library solves some of the same problems pubsub solves.
12:30:18 <dataN> oh right, not to make AtT injective...
12:31:11 <dataN> and isnt that just 'N ?
12:31:17 <cocreature> dataN: AtT is not injective so syntax for marking a type family injective is completely useless here
12:33:05 --- mode: glguy set +v dataN_
12:33:16 --- mode: glguy set -v dataN_
12:34:22 <dataN_> what part of Nat being a singleton would help?
12:35:01 <cocreature> dataN_: what matters is that you have a type-level version of the index so you can use it as the argument to AtT
12:35:32 <cocreature> if you make it a singleton, you get the advantage of being able to just pattern match on it on the value-level, if you use a Proxy or TypeApplications instead you’ll probably have to go for typeclass induction
12:36:36 <dataN_> thats not like writing 'AtT ts (n' :: N)'
12:38:41 <dataN_> oh it should be n not n', maybe that could be the problem 
12:40:41 <dataN_> that seems to give another error; https://pastebin.com/WtJbJ7L8
12:41:55 <cocreature> dataN_: that doesn’t make sense. "n" in "AtT ts n" is the index but in "TypedVector n xs" it’s the length
12:42:04 <cocreature> dataN_: here’s the singleton version https://gist.github.com/cocreature/2741b6fb79f9fe77ac0789ab491ac684
12:43:33 <cocreature> fwiw it is also not really helpful to have TypedVector store both the list of types and the length. you can always deduce the length from the list of types
12:44:34 * hackage itcli 0.1.8.3 - Issue Tracker for the CLI  http://hackage.haskell.org/package/itcli-0.1.8.3 (theNerd247)
12:48:04 <dataN_> so the idea with 'data SNat (n :: N)' is instead of writng (n :: N) which is a kind error, to instead write 'SNat n'
12:48:30 <i0-dfn> is there a standard way to "try to convert a normal list into a list-of-length-N" where the latter list encodes N in its type, such as HList
12:48:49 <i0-dfn> i'm not sure how to do this and also satisfy the type-checker
12:49:18 <dataN_> cocreature: oh that seems to be an artefact from wanting TypedVector to be a Vector also containing a Vector of the same length
12:49:22 <glittershark> i0-dfn: it's possible with recursive typeclasses
12:50:00 <glittershark> `class AsVector (n :: Nat) where asVector :: [a] -> Vec n a`
12:50:20 <glittershark> `instance AsVector 0 where asVector [] = Just Nil; asVector _ = Nothing`
12:50:33 <glittershark> er, the class should have `asVector :: [a] -> Maybe (Vec n a)`
12:50:34 * hackage follow 0.1.0.0 - Haskell library to follow content published on any subject.  http://hackage.haskell.org/package/follow-0.1.0.0 (cram1010)
12:50:55 <cocreature> yeah just return a Maybe
12:51:05 <i0-dfn> i see i'll have a play around with that, thanks glittershark!
12:52:12 <ph88> how can i know for sure which ghc version stack is using ?
12:52:19 <ph88> i'm trying to use a ghc that i just compiled
12:52:20 <glittershark> stack exec -- ghc --version
12:54:38 <dataN_> cocreature: trying to write the type family version of AtT as; type family AtTV (ts :: Vector n k) (SNat n') :: * throws an error 
12:55:21 <Boarders> what is the idiomatic way to write something in lens that gets a field and then sets it?
12:55:36 <dataN_> writing (n' :: SNat n'')  works but maybe thats not correct
12:56:16 <ph88> so when i do    PATH=~/haskell/forks/ghc-8.6/inplace/bin:$PATH stack exec ghc --system-ghc --allow-different-user -- --version      i still get ghc 8.4 instead of 8.6
12:57:46 <cocreature> dataN_: why do you want to use SNat in the type family? the point of singletons like SNat is that they give you a one-to-one correspondance between values and a type parameter so you can fake dependent types that way. if you just have a type family, you can work with the type directly and don’t need a singleton
12:59:37 <MarcelineVQ> ph88: have you tried with an absolute path?
12:59:47 <MarcelineVQ> I'm not sure just pointing to the bins is correct anyway, but I'd try that first
13:00:03 <ph88> i tried now, still the same
13:00:38 <ph88> there is no "ghc" binary in that directory by the way ... there is "runghc"
13:00:41 <glittershark> ph88: you could try https://gist.github.com/DanBurton/43b5f5155fdd1affd02f6e86f37da9ae
13:00:58 <glittershark> obviously that requires recompiling ghc...
13:01:37 <MarcelineVQ> ph88: what does  cat runghc  point to?
13:01:55 <ddellacosta> Boarders: did you figure this out? Sounds like you want `set`, have you gone through this: https://github.com/ekmett/lens/wiki/Examples (for example)?
13:03:01 <ph88> MarcelineVQ, https://bpaste.net/show/7d24a8b4a544
13:03:14 <Boarders> yeah I had something like: f = (myInnerInnerfield .~ Blah ) . getInnerField
13:03:19 --- mode: glguy set +v dataN
13:03:20 <Boarders> and I wondered if there was something better than that
13:03:24 <Boarders> if you see what I mean
13:03:37 --- mode: glguy set -v dataN
13:03:57 <dataN> this is the same kind of error about injectivity? https://pastebin.com/FKcxfkSj
13:03:59 <MarcelineVQ> oh it's using stage2, stack probably has no idea what that is
13:04:26 <ddellacosta> Boarders: oh--so maybe you simply want to get the value first and modify it with the function `Blah`, since you want that value in the end anyways, right?
13:04:27 <MarcelineVQ> I could only get stack to care about a custom ghc by building a bin dist from source and pointing to that in a stack.yaml
13:05:05 * hackage alg 0.2.7.0 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.7.0 (MatthewFarkasDyck)
13:05:07 <ddellacosta> oh but I guess you are modifying something an extra layer deeper than what you want back? (based on your naming scheme, hard to tell otherwise)
13:05:14 <dataN> or maybe thats just what it says when it cant infer the types correctly
13:05:46 <MarcelineVQ> ph88: to get ghc into a form stack can be aware of you need to  https://ghc.haskell.org/trac/ghc/wiki/Building/Installing
13:05:48 <ddellacosta> yeah if that's the case not sure if you're gonna get much more concise, but maybe there are some lens code golfers on here who want to try...
13:06:21 <Boarders> ddellacosta: I have something like A{ af = B {bf = 0, bs = 'a'}, bs = ()} and want to get the B and then set the first field
13:06:35 <ph88> :*(
13:18:34 <ddellacosta> huh lpaste is down?
13:18:58 <ddellacosta> so yeah Boarders maybe there's a more concise way but this is what I came up with: https://gist.github.com/ddellacosta/22d3543daa099f41e25f77be8c681e3d
13:19:08 <ddellacosta> you could use operators I guess but I find this easier to read
13:19:12 --- mode: glguy set +v zincy
13:19:29 <ddellacosta> I kinda fudged your example record type
13:19:52 <zincy> Does anyone have production Haskell experience with containers or AWS?
13:20:05 <zincy> *here
13:21:13 <Boarders> ddellacosta: that makes sense, I decided on something pretty much identical (the example record I said were nonsense anyway)
13:21:48 <ddellacosta> Boarders: yeah I'm not sure what I came up with is any more concise or better than what you had in the first place, but I also don't know there's much else to do with it that is better
13:40:13 <Solonarv> with operators it would be : (a ^. af) & bf +~ 1
13:40:45 <Solonarv> you might be able to drop the parens, dunno
13:46:36 <glittershark> Is there any way of constraining one of the type parameters of a GADT to be either one concrete type or another, and then have GHC's totality checker use that knowledge?
13:47:02 <glittershark> so like where today I can do `data Foo a where FooI :: Foo Int` or `data Foo a where FooAny :: Foo a`
13:47:23 <glittershark> I'd like to be able to do `data Foo a where FooIB :: Foo (Int | Bool)`
13:47:36 <dmwit> glittershark: Sounds like you want DataKinds.
13:47:39 <glittershark> I could do it with a typeclass constraint on the constructor, but the totality checker ignores it
13:48:04 <glittershark> dmwit: the actual code is already using DataKinds. What I want is the ability to disallow one of the *members* of a DataKind
13:48:20 <glittershark> or explicitly only allow a list of members
13:48:53 <dmwit> data TyRepr = IntRepr | BoolRepr; type family TyOfTyRepr where TyOfTyRepr IntRepr = Int; TyOfTyRepr BoolRepr = Bool; data Foo a where Foo :: TyOfTyRepr a -> Foo a
13:48:55 <glittershark> I'm currently 90% sure that what I'm asking for is just not possible
13:49:53 <dmwit> (I went a step above and beyond your request: I also gave Foo's constructor a field of the type listed in its type parameter, which you didn't ask for but probably meant.)
13:50:04 <glittershark> I didn't mean it
13:50:13 <dmwit> Okay, then just drop the type family and the argument.
13:50:23 <glittershark> sure, but I can't have eg
13:50:37 <dmwit> data TyRepr = IntRepr | BoolRepr; data Foo (a :: TyRepr) where Foo :: Foo a
13:51:11 <glittershark> data K = A | B | C ; data Foo :: K -> Type where { FooAny :: Foo a ; FooAB :: Foo ('A | 'B); FooC :: Foo 'C }
13:51:34 <Solonarv> not as far as I know, no
13:51:52 <glittershark> yeah this feels like I'd need subtyping
13:51:59 <Solonarv> you could approximate it with promoted Either (or higher-arity sums)
13:52:05 <glittershark> ech
13:52:12 <glittershark> that changes the kind of Foo though
13:52:43 <Solonarv> Hm. yeah, it does
13:54:16 <glittershark> again, I can easily do `type family In (x :: k) (xs :: [k]) :: Constraint where { In a (a ': _) = () ; In a (_ ': as) = In a as ; In a [] ; = TypeError "nope" }
13:54:49 <glittershark> and make it `FooAB :: a `In` '['A, 'B] => Foo a`
13:54:56 <glittershark> but the totality checker pays zero attention
13:55:01 <glittershark> which, duh
13:55:07 <dmwit> FooAB :: Foo (Fam a); type family Fam a where Fam C = A; Fam x = x -- =P
13:55:38 <glittershark> don't think you can use a type family application on the return type of a GADT
13:56:16 * glittershark goes back to Agda in a huff
13:56:59 <dmwit> glittershark: works here
13:57:17 <dmwit> ...with sufficient extensions turned on
13:57:30 <glittershark> I turn on all extensions
13:57:38 * glittershark doesn't fear the extension
13:58:00 <shachaf> I fear ImpredicativeTypes
13:58:18 <glittershark> ImpredicativeTypes and ImplicitParams
13:58:19 <glittershark> sure
13:58:31 <shachaf> I understand ImplicitParams at least.
13:58:34 <glittershark> I was being pretty tongue-in-cheek, lol
13:58:45 <shachaf> Does GHC even have ImpredicativeTypes nowadays?
13:59:00 <shachaf> Seems so. But the meaning of that extension changes all the time, as I recall things.
13:59:23 <geekosaur> still there btu the plan is to move to using TypeApplication
13:59:35 <glittershark> >  We've made various attempts to support impredicativity, so there is a flag -XImpredicativeTypes. But it doesn't work, and is absolutely unsupported. If you use it, you are on your own; I make no promises about what will happen. 
13:59:37 <lambdabot>  <hint>:1:55: error: parse error on input ‘,’
13:59:47 <glittershark> https://ghc.haskell.org/trac/ghc/wiki/ImpredicativePolymorphism
14:00:25 <dmwit> glittershark: The following compiles for me: https://gist.github.com/dmwit/cf9154e425665bac2516ccf847971f36
14:00:48 <glittershark> huh!
14:01:13 <glittershark> Does the totality checker know that (x :: FooAB C) is impossible though?
14:01:38 <dmwit> sure does
14:02:07 <dmwit> Oh, wait, I didn't read that carefully.
14:02:14 <dmwit> Let me test again.
14:02:34 * hackage hs2ats 0.3.0.4 - Create ATS types from Haskell types  http://hackage.haskell.org/package/hs2ats-0.3.0.4 (vmchale)
14:03:21 <dmwit> glittershark: No, it does not. =P
14:03:41 <glittershark> well, hmm
14:03:57 <glittershark> when you type apply `FooAB @C` you actually get `FooAB @A`
14:04:00 <glittershark> er
14:04:04 <dmwit> correct
14:04:05 <glittershark> `:: Foo 'A`
14:04:31 <dmwit> But -Wincomplete-patterns still complains if you don't include FooAB in a list of patterns for a Foo C.
14:04:53 <glittershark> yeah.
14:04:57 <glittershark> that's the bit I want
14:05:04 <dmwit> You can muck with that with the newish {-# COMPLETE #-} pragma, I think.
14:05:09 <glittershark> oh!
14:05:12 <Solonarv> actually... what about this:
14:05:13 <Solonarv> % type family In (xs :: [k]) (x :: k) :: k where In (a ': _) a = a; In (_ ': as) a = In as a; In '[] a = 'TypeError ('Text "nope")
14:05:13 <yahb> Solonarv: ; <interactive>:76:116: error:; Not in scope: data constructor `Text'; Perhaps you meant one of these: variable `text' (imported from Text.PrettyPrint.HughesPJ), variable `next' (imported from System.Random)
14:05:15 <glittershark> there's a pragma for that :0
14:06:04 * hackage dockerfile 0.2.0 - A Haskell DSL for generating Dockerfiles  http://hackage.haskell.org/package/dockerfile-0.2.0 (ChristopherReichert)
14:06:08 <glittershark> Solonarv: still don't think that'd work with the totality checker
14:06:32 <glittershark> dmwit: what I'm reaching for is something that'd yell at me if I added a new thing and forgot to pattern match on it
14:06:52 <glittershark> like obviously I can `patternMatchingFunction _ = error "impossible"` but that's not growth-safe
14:07:23 <Solonarv> (you'd use it with a FooAB :: Foo (In '['A, 'B] a) constructor) - I think it's worth trying
14:09:35 <monochrom> What does the GHC User Guide say about its totality checker and what it does and what it doesn't?
14:10:07 <monochrom> Is it true that today people refuse to dig into docs, and instead just presume features from names?
14:10:37 <glittershark> I'm not presuming that GHC's totality checker will work here
14:10:51 <glittershark> I'm asking if there's a trick to make it work
14:10:56 <monochrom> If I also mentioned that GHC supports type-level naturals, do people just take that and assume that type-level primality test is supported too?
14:11:52 <glittershark> Solonarv: https://gist.github.com/glittershark/7c266fbaf0e48a17251451a126cc975b still gives an incomplete match warning
14:12:19 <MarcelineVQ> monochrom: Is that something found in the user guide?
14:12:46 <Solonarv> well damn
14:13:17 <MarcelineVQ> on the subject though https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=totality#complete-pragmas
14:13:59 <ph88> MarcelineVQ, i have now "installed" ghc after building, but i still don't get the right ghc version with stack
14:14:15 <MarcelineVQ> ph88: Do you keep logs?
14:14:38 <ph88> from what ?
14:14:41 <MarcelineVQ> here
14:14:47 <ph88> yes
14:15:04 <MarcelineVQ> k check what I said yesterday about how I was able to get that to work for me. I've never tried the method you're using
14:15:04 <ph88> only when i'm online though
14:16:44 <ph88> this? >> I could only get stack to care about a custom ghc by building a bin dist from source and pointing to that in a stack.yaml
14:17:14 <MarcelineVQ> I'm reasonably sure I said more than that, but maybe I'm unreasonable so I'll check
14:17:19 <merijn> If you want to control your GHC, stack is probably not the right tool :)
14:17:50 <monochrom> stack is a jealous god.
14:18:02 <merijn> One of the points of stack is that it "takes care" of getting the right GHC for a snapshot, etc. Which means that if you want a *different* GHC than that, stack is going to harsh your mellow :p
14:19:04 <MarcelineVQ> '<MarcelineVQ>   ph88: The easiest way to use a custom ghc wth stack that I found was to build a bindist from the source code and specify a path to it via https://docs.haskellstack.org/en/stable/yaml_configuration/#setup-info  and  https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-variant
14:19:40 <monochrom> Actually does it have to be built from source?
14:20:33 <MarcelineVQ> No
14:21:21 <MarcelineVQ> I guess this is where you say there's a release candidate ^^;
14:21:49 <MarcelineVQ> https://downloads.haskell.org/~ghc/8.6.1-beta1/
14:22:15 <merijn> hmmm, I don't suppose anyone knows how (if at all possible) I can control the way module re-exports are rendered in Haddock?
14:22:19 <MarcelineVQ> ph88: You'll probably want to check the dates on that though, to be certain it contains the patch from the trac you wanted
14:22:37 <EvanR> (rewind... GHC has a totality checker?)
14:23:03 <MarcelineVQ> EvanR: for pattern matches
14:23:29 <merijn> It appears to use some weird random order, because it's not the export order and not alphabetical
14:23:55 <EvanR> ah complete pattern match check
14:24:24 <MarcelineVQ> ph88: because this isn't quite a release candidate yet, so it's not guranteed to have that 8.6.1 milestone trac change you were after
14:25:10 <oldandwise> is 8.6.1 has windows 32-bit support?
14:26:08 <MarcelineVQ> "<monochrom> Actually does it have to be built from source?" rather what I mean by that is when using ghc from source, a bindist was the easiest (read: only I found) way to get stack to accept it. I did forget about things like https://downloads.haskell.org/~ghc/8.6.1-beta1/ though, and one has to be more careful about what a beta contains if they're after a specific thing
14:29:40 <MarcelineVQ> Additionally there's the trouble of having to set up a custom package snapshot to use the thing, something I never conquered but has had more support for it added since I tried.
14:37:35 <Solonarv> if I understand the changes correctly, it *should* be fairly easy to make a custom snapshot that's just an existing snapshot + a different Ghc
14:38:06 <merijn> So, does anyone know if there's a way to control how re-exports are rendered, or do I just have to manually list all of them in the export list to control that?
14:39:20 <ph88> MarcelineVQ, ah good point so it can be that i even downloaded the wrong sources -_____-
14:39:20 <dmj`> Has there really never been written a CSV lexer in alex ?
14:39:34 <dmj`> that operates on raw bytes
14:39:53 <ph88> MarcelineVQ, do you know which sources i should download to get what will become 8.6.1 ? which branch is that ?
14:40:03 <dmj`> I want a finite state machine that lexes in linear time
14:40:54 * dmj` is outraged
14:41:57 --- mode: glguy set +v dataN
14:42:06 --- mode: glguy set -v dataN
14:42:17 <ph88> i like to have a ghc version that fixes this bug https://ghc.haskell.org/trac/ghc/ticket/15164 and this bug https://ghc.haskell.org/trac/ghc/ticket/15529 
14:43:01 <dataN> whats wrong now? https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
14:43:37 <Solonarv> psst dataN if you name your file something.hs you'll get syntax highlighting
14:43:57 <ph88> MarcelineVQ, i tried ghc-variant before .. i couldn't get it to work :'(
14:44:09 <dataN> check
14:44:12 <ph88> this was like half a year ago when i tried to make some changes in base
14:44:41 <Solonarv> ah, thanks - much more readable
14:46:21 <EvanR> i want a lexer that runs in log time, or negative complexity time
14:46:38 <EvanR> or O(1/n)
14:46:43 <Rembane> So you gain time when it runs?
14:48:51 <dataN> Solonarv: is it legible? 
14:49:18 <Solonarv> yes, yes
14:49:39 <Solonarv> EvanR: no, that would be O(f(x)) with f(x) < 0
14:49:59 <Solonarv> O(1/n) still takes positive time, but is faster on longer inputs
14:50:08 <jle`> yeah, an O(-n) would be a time machine
14:50:40 <dataN> so fast!
14:50:52 <Rembane> It's a part of the very advanced algorithms course
14:51:17 <shachaf> O(1/n) is a thing that can come up when talking about amortized runtime, I think.
14:51:28 <Rembane> Cool
14:52:50 <Solonarv> dataN: it's a bit tangential, but every use of * could be replaced with a poly-kinded variable
14:52:58 <dataN> tried that
14:53:02 <dataN> goes mad
14:53:04 <Solonarv> (except for the one in the definition of Vector)
14:53:20 <Solonarv> mad? did you turn on PolyKinds?
14:53:24 <dataN> argh!
14:54:03 <Solonarv> Also, even when you do mean *, I'd recommend using Type instead, for reasons of future-proofing
14:54:35 <dataN> that would be good for Map with 'k1 -> k2', but edit would still be 'k -> k' instead of '* -> *'
14:55:16 <Solonarv> yes, of course
14:56:58 <dataN> for compatibility with # ?
14:57:22 <dataN> not sure what else does Type do
14:57:55 <EvanR> * = Type
14:57:58 <dataN> aside from containing itself 
14:58:04 <Solonarv> * and Type are the same thing, but * causes a lot of wrinkles with regards to parsing
14:58:25 <Solonarv> and also conflicts with the multplication operator (from GHC.TypeNats)
14:58:38 <EvanR> in the future they are laughing at us for using *, and also still calling it * because people are still catching up
14:58:53 <EvanR> the vast blogosphere uses *
14:59:11 <merijn> And * is less typing than Type! :p
14:59:18 <Solonarv> eh, the NoStarIsType proposal is only a few months old IIRC
14:59:53 <EvanR> can they name the unboxed kinds too please
15:00:08 <EvanR> kind #
15:00:19 <dataN> its nice for intuition because it is like a wildcard, and without knowing that Type is exactly the same, it is raising doubt
15:00:31 <jle`> but it's not a wildcard
15:00:35 <MarcelineVQ> "<ph88> MarcelineVQ, ah good point so it can be that i even downloaded the wrong sources -_____-" if you grabbed master you have it, my point was about the bindist link earlier, https://downloads.haskell.org/~ghc/8.6.1-beta1/
15:01:23 <dataN> its more like a wildcard of every type of unit arity 
15:01:50 <dataN> jle': maybe you can see this error? https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
15:02:32 <dataN> s/see/explain how to fix it or what it means
15:03:42 <Solonarv> Technically # is TYPE 'Unlifted
15:03:45 <Solonarv> or something like that
15:04:20 <dataN> negative levity!
15:05:01 <Solonarv> dataN: actually, I think this is happening because evaluation of type families is insufficiently eager
15:05:40 <dataN> neither sufficiently eager, nor lazy...
15:06:05 <dataN> kind of indifferent 
15:07:08 <Solonarv> or there's some mixing of levels going on, I'm not sure
15:09:49 <dataN> so Type includes (* -> *) ?
15:09:59 <ph88> MarcelineVQ, master when i compile that it says it's 8.7 ? o_O   do you think the bindist is often updated ?
15:11:11 <dataN> ok, now it gives this; https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
15:11:20 <merijn> ph88: Odd numbered GHC versions are dev versions
15:11:23 <dataN> f :: * -> * is not of type *
15:11:34 <merijn> ph88: So 8.5 became 8.6 upon release and 8.7 will become 8.8 upon release
15:11:37 <dataN> so it cant be used as an argument to the type family...
15:12:06 <merijn> ph88: Because master is already moving on past 8.6.1 :)
15:13:24 <Solonarv> weeeelll....
15:13:30 <Solonarv> % :k (* -> *)
15:13:30 <yahb> Solonarv: (* -> *) :: *
15:13:53 <dataN> Expecting one more argument to `(f :: * -> *)'       Expected a type, but `(f :: * -> *)' has kind `* -> *'
15:13:58 <merijn> tbh, TypeInType is super confusing to me
15:14:05 <merijn> I prefer stratified kinds
15:14:26 <Solonarv> % set -XNoTypeInType
15:14:26 <yahb> Solonarv: ; <interactive>:78:6: error: Data constructor not in scope: XNoTypeInType :: ASetter s t a b -> b -> s -> t
15:14:38 <Solonarv> % :set -XNoTypeInType
15:14:38 <yahb> Solonarv: 
15:14:45 <Solonarv> % :k (* -> *)
15:14:45 <yahb> Solonarv: (* -> *) :: *
15:14:53 <jle`> dataN: (f :: * -> *) does not have kind *
15:15:04 <jle`> dataN: but (* -> * :: *) does have kind *
15:15:19 <Solonarv> f has kind (* -> *), which in turn has kind *
15:15:36 <jle`> yes, True has type Bool which in turn has kind */Type
15:15:47 <jle`> but that doesn't mean that True has type Type
15:17:41 <Solonarv> exactly
15:18:25 <dataN> oh right, it needs to know the type at that index in the list
15:19:50 <merijn> hmmm, do I manually write out 20 element export lists to get nicely organised docs and say "fuck it" and just go with haddock's random ordering >.>
15:20:00 <Solonarv> yes
15:20:02 <Solonarv> (sorry)
15:21:42 <Solonarv> less facetiously, explicit export lists are considered good practice anyway
15:21:56 <EvanR> the question is whether you carefully curate it or not
15:22:29 <merijn> Solonarv: I have explicit export lists for modules, I'm talking about re-exports here
15:22:36 <Solonarv> oh, right
15:22:41 <merijn> Solonarv: So basically, this is the original module: https://hackage.haskell.org/package/broadcast-chan-0.2.0/candidate/docs/BroadcastChan.html
15:22:57 <dataN> ok, thats working, but the test fails; https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
15:22:59 <merijn> Solonarv: But the re-exports here: https://hackage.haskell.org/package/broadcast-chan-0.2.0/candidate/docs/BroadcastChan-Throw.html#g:1 appear to be in random order
15:23:21 <merijn> Solonarv: But duplicating the entire export list across several modules to get consistent ordering seems like a maintenance hassle
15:23:33 <merijn> (hence why I've already opened a Haddock issue :p)
15:24:09 <Solonarv> also, duplicating the export list means it's possible to neglect updating it in one place - not ideal
15:24:33 <merijn> Solonarv: Right
15:24:41 <merijn> Solonarv: Which is why I don't like that idea :)
15:24:59 <merijn> But I also don't like the random jumble
15:25:09 <merijn> If it was at least alphabetical it'd make some sense
15:25:14 <Solonarv> understandable
15:25:29 <Solonarv> I don't think there's really a right answer tbh
15:25:37 <Solonarv> (apart from "fix haddock")
15:25:42 <dataN> thought it could be an index out of bounds error making put not work, but decrimenting SN3 to SN2 does not help
15:25:45 <merijn> Solonarv: Yeah, that was my plan so far :p
15:26:07 <merijn> Or rather, my plan was "bug people into fixing Haddock, then generate new docs" :p
15:27:28 <ph88> MarcelineVQ, it works with flag  --skip-ghc-check
15:28:18 <ph88> PATH=~/haskell/forks/ghc-8.6-install/bin:$PATH stack exec ghc --skip-ghc-check --system-ghc --allow-different-user -- --version
15:29:55 <Wyv3rn> hey all, how would i return a tuple from a list of tuples?
15:30:25 <Wyv3rn> Well, more specifically, I need to search for a tuple from a list and then return that tuple
15:30:48 <marvin2> search by tuple, fst or snd?
15:31:09 <Wyv3rn> fst
15:31:38 <Wyv3rn> the tuple is (char, Int)
15:32:00 <jle`> Wyv3rn: can you give an example of a list you want to search for a tuple from?
15:33:20 <dataN> :t find
15:33:22 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:33:50 <marvin2> I could swear there was a function that does exactly that, searches a list of tuples by fst. but if there isn't, find will do
15:33:57 <benzrf> :t lookup
15:33:58 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:34:02 <marvin2> ^^ that is the one
15:34:16 <benzrf> :t lookupBy
15:34:16 <Wyv3rn> [('a', 8), ('b', 95), ('c', 37)]
15:34:17 <lambdabot> error:
15:34:17 <lambdabot>     • Variable not in scope: lookupBy
15:34:17 <lambdabot>     • Perhaps you meant one of these:
15:34:22 <jle`> :t find . fst
15:34:23 <benzrf> oh i guess that's not a thing
15:34:23 <lambdabot> Foldable t => (a -> Bool, b) -> t a -> Maybe a
15:34:27 <jle`> oh heh
15:34:35 <jle`> marvin2: it doesn't quite return the tuple itself though
15:34:41 <benzrf> oh, that's true
15:34:53 <benzrf> in the case of lookup you don't need the first one
15:34:58 <marvin2> jle` yeah.. probably why hoogle wasn't finding it
15:35:00 <benzrf> if you have some other predicate then it might be relevant
15:35:40 <dataN> :t find . (. fst)
15:35:42 <lambdabot> Foldable t => (b1 -> Bool) -> t (b1, b2) -> Maybe (b1, b2)
15:35:48 <jle`> :t find . lmap fst
15:35:49 <lambdabot> Foldable t => (b1 -> Bool) -> t (b1, b2) -> Maybe (b1, b2)
15:36:48 <marvin2> > find ((=='h') . fst) (zip "hello" [1..])
15:36:50 <lambdabot>  Just ('h',1)
15:41:59 <dataN> apparently, the calls to this are turning n' into n'0 and becoming ambiguous;
15:42:00 <dataN> editTV :: TypedVector (ts :: Vector n *) -> SNat n' -> (AtV ts n' -> b) -> TypedVector (PutV ts n' b)
15:42:16 <dataN> or something like that
15:44:41 * dmwit prefers filter to find
15:44:50 <dataN> and yes, all the functions in the module should use traverse or fold, but thats not happening yet. their arguments are in the wrong order too :-(
15:46:03 <dataN> wait, I need tacos 
15:46:32 <dyl> dataN: don’t we all?
15:49:04 <geekosaur> except when we need burritos
16:04:31 <ph88> does mgsloan visit irc ?
16:08:49 <geekosaur> rarely, from what I've seen, and nto usually in this channel
16:08:51 <oldandwise> why is python used among scientists, than haskell? 
16:09:19 <oldandwise> ... say, the genome project for example... it change from perl to python
16:09:23 <hodapp> oldandwise: because Python has like 67,819 libraries
16:09:36 <hodapp> and it's incredibly easy to write shitty Python bindigs to shitty C/C++ libraries
16:09:37 <geekosaur> their decision ,nto ours; try asking them
16:09:48 <geekosaur> a lot of it is "X used it so I wil"
16:09:51 <hodapp> and because numpy, scipy, and matplotlib exist
16:10:06 <geekosaur> and they used perl for years befoe starting o switch to python
16:10:49 <hodapp> and because whatever insults you may lob against Python that are totally valid, Python has two huge advantages
16:11:03 <hodapp> which are: it's not R, and it's not MATLAB
16:11:09 <oldandwise> scientists as they are, they should have been more mathematical in doing computer programming...
16:11:32 <hodapp> the mathematics scientists tend to be interested in are of a very specific sort
16:11:43 <geekosaur> ^
16:11:53 <Solonarv_> specifically: numerics
16:11:55 <geekosaur> geneticists are not mathy types, in general
16:11:58 <Solonarv_> and statistics
16:12:09 <hodapp> and sometimes, you just want to get your bloody SVD computed and not worry much about how
16:13:13 <hodapp> also, as much as I've used Haskell and as much as I rather dislike Python, I've yet to find anything comparable to NumPy
16:13:14 <oldandwise> how is haskell fare with python in machine learning then?
16:13:28 <hodapp> ML is still extremely Python-heavy for a lot of the same reasosns
16:14:17 <hodapp> and a lot of this is because things like TensorFlow and MXNet have first-class support for it, and Keras is written in it
16:14:31 <hodapp> there are Haskell bindings to TensorFlow but I've yet to try using them
16:15:04 <geekosaur> the same logic thatthiks they should be mathy thinsk they shoudl understand the cognitive basis of neural networks, yet http://languagelog.ldc.upenn.edu/nll/?p=36447 and https://rocknrollnerd.github.io/ml/2015/05/27/leopard-sofa.html type things are widespread
16:15:22 <geekosaur> since that's how neural networks work
16:15:48 <geekosaur> but the people using them even in research have no idea how they actually work, and you get that
16:16:27 <hodapp> neural nets were inspired by some notion of the brain's cognition and then quickly diverged to "this works, let's pretend to figure out why but mostly just write hundreds of articles gloating about how well this works"
16:16:28 <oldandwise> is it not  due to haskell being hard to optimized (for speed) than its imperative equivalents?
16:16:43 <Solonarv_> nope, haskell is pretty fast
16:16:58 <Solonarv_> and if it isn't fast enough you can always bind to C instead
16:17:02 <geekosaur> it is largely becfause they stick to what they can ask their buddies about, wch is python, perl, R/matlab
16:17:05 <hodapp> the speed of Haskell is pretty irrelevant here considering that *Python* is the language preferred
16:17:06 <ph88> hodapp, what's against R ?
16:17:33 <oldandwise> Solonarv_: i know.. but isn't haskell's logic foundation, causing misinterpretation and slows things if not done correctly?
16:17:35 <hodapp> ph88: it's a horribly ugly language that is a fractal of stupid corner-cases and typing that makes JavaScript's look strong
16:18:13 <ggVGc> I think it's very reasonable to use python for scientific work. As programmers we're quite interested in correct and bug-free programs, mainly because we need to maintain and extend them. I'm guess most of the code scientists write spit out what they want and then it's correct
16:18:21 <oldandwise> hodapp: well, python can easily drop to C++.. coz it's imperative loves side-effect...
16:18:24 <geekosaur> technicial questions ave nothing to do with it, social issues have everything to do with it, theirfrends / colleagues use X so they use X
16:18:25 <ggVGc> and you'd rather not spend any time doing "good programs"
16:18:28 <ggVGc> when the data is out, it's out
16:18:31 <ggVGc> and you can get on with your life
16:18:38 <ph88> my friend said i should learn it because statistics use it
16:18:41 <ggVGc> so types probably get in the way
16:18:47 <hodapp> oldandwise: one can about as easily call C/C++ from Haskell
16:19:11 <hodapp> oldandwise: so it mostly comes down to what was already written in Python
16:19:14 <geekosaur> nobody thinks about types, about speed, about "pretty", etc.
16:19:29 <ph88> optimising haskell for speed is not easy i think
16:19:39 <oldandwise> ph88: yeah.. 
16:19:43 <geekosaur> so this is a meaningless question that misses the point completely
16:19:52 <hodapp> ever tried to optimize Python for speed?
16:19:53 <ggVGc> I think if you're in the middle of processing data from some experiment, dealing with haskells type system probably gets in the way
16:19:55 <geekosaur> nobody asks that question
16:19:57 <ggVGc> a lot
16:20:02 <oldandwise> ph88: coz haskell has ties to logic rigors
16:20:17 <dataN> image recognition using NNs are common, but NNs are not the best way to approach this problem as they converge slowly compared to conjugate gradient 
16:20:17 <hodapp> "ties to logic rigors" whaaa
16:20:18 <geekosaur> they ask colleageu how to do X, they get a python program and change t to do what they want
16:20:38 <dmj`> > let 3 + 1 + 1 in 3
16:20:41 <lambdabot>  <hint>:1:15: error: parse error on input ‘in’
16:20:46 <hodapp> dataN: I am unaware of anything that currently comes anywhere close to surpassing convnets for image recognition
16:20:50 <dmj`> > let 3 = 1 + 1 in 3
16:20:52 <lambdabot>  3
16:20:54 <hodapp> when it comes to empirical resutls
16:21:02 <ggVGc> hodapp: what about humans?
16:21:09 <dataN> hodapp: http://people.maths.ox.ac.uk/thompson/BT_PPT.pdf
16:21:12 <hodapp> ggVGc: humans smell bad
16:21:18 <ggVGc> so does python :(
16:21:30 <Solonarv_> haskell's static checks make optimisation *easier*, not harder
16:21:52 <ph88> oldandwise, i haven't been able to see core output of my program and reading it is hard too .. and this is sometimes needed
16:21:57 <oldandwise> hodapp: i meant, in python... you are always free to do shortcuts... without any responsibility or care what lambda calculus roles... etc
16:22:17 <ggVGc> I'm guessing a lot of scientific computing is similar to creative programming, which I do a bit with music, and then the end result is the answer to if the program was correct or not, and I'd rather not deal with typing my program
16:22:23 <hodapp> dataN: I don't think a compressive sensing paper with zero empirical results on anything has any relation to the current performance of convnets
16:22:42 <dataN> do you have their RIP curves to hand?
16:22:48 <ph88> and then there is gc ofcourse
16:22:56 <oldandwise> haskell adheres to lambda calculus
16:23:22 <hodapp> dataN: this says nothing about actual performance
16:23:32 <oldandwise> whereas, python adheres nothing...
16:23:54 <Solonarv_> haskell compiler know they can freely replace (blah ... (expensiveComputation x) ... (expensiveComputation x)) with (let y = expensiveComputation x in blah ... y ... y), in every single case
16:24:02 <dataN> hodapp: the lack of ability to reason about NNs seems to be the root of this problem and the resulting widespread unjustifiable use 
16:24:53 <oldandwise> step-debugging in FP? is it even healthy?
16:25:05 <geekosaur> it's possible to reason about them. they mostly don't
16:25:06 <dataN> now, this availability results in a lot of demonstrations of them working, but usually not as well as they should
16:25:26 <Solonarv_> sure, but they're evaluation steps instead of execution steps
16:25:34 <oldandwise> hard to step-debug logic mechanically
16:26:26 <oldandwise> i'm aware, these two have ancient roots between Turing vs Alonso church computation models
16:26:43 <dataN> geekosaur: oh sure, found one; http://adamsc.mycpanel.princeton.edu/documents/YapCharlesRozell_2012SSP.pdf
16:27:43 <geekosaur> I have an essay about DNNs, how they're used and abused, waiting for me to get over [redacted] (as if)
16:28:03 <geekosaur> there's another problem lurking once they get past the current ons, with more or less the same cause in reverse
16:28:34 <oldandwise> we need a killer app
16:32:28 <hodapp> dataN: yes, to be clear, convnets are an architecture that has no good explanation from a theoretical standpoint and they are disgustingly overparametrized and kept in check only with a huge amount of regularization
16:32:58 <hodapp> dataN: they don't work as well as they should, they work far, far better than they should considering their complexity
16:33:03 <dataN> so research using available interfaces to existing NN libs is completely different in terms of requirements placed on the language than researchers writing thier own, where simplicity to express linear algebra is the requirement. 
16:33:13 <dataN> python for the former, matlab for the latter.
16:33:56 <hodapp> MATLAB has a place and time
16:34:06 <dataN> haskell has a less widely adopted scripting interface to these available libs, and is less easy to use to write custom linear algebra. 
16:34:06 <hodapp> (in the trashcan, right now... but I digress)
16:34:54 <hodapp> honestly, linear algebra in Python is about as easy as MATLAB at this point, and you don't have to put up with all the Mathworks garbage and licensing
16:36:14 <dataN> anyway, the point is that haskell will be able contribute more when its linear algebra interface is similarly expressive so that the type safety becomes useful
16:36:52 <dataN> normally people just contend with runtime errors
16:38:21 <dataN> probably the performance benefit over matlab or python for linear algebra would be the fundamental selling point  
16:38:37 <MarcelineVQ> "<ph88> MarcelineVQ, master when i compile that it says it's 8.7 ? o_O   do you think the bindist is often updated ?" I don't think bindists gets up updated no, there's periodically new releases and candidates here https://downloads.haskell.org/~ghc/
16:39:03 <ph88> ah ok
16:39:23 <ph88> it works with --skip-ghc-check
16:40:14 <dataN> oh, just for the scrollup after that, can i just ask again if there is a way to understand why this ambiguity arises? https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
16:40:30 <MarcelineVQ> ph88: that's good you got it working
16:40:58 <ph88> ye just after that i get build errors in cabal package
16:41:01 <ph88> and i give up :p
16:41:26 <oldandwise> let us, for example, look at software version control: darcs vs git
16:41:36 <dataN> hodapp: yeah, the restrictions that need to be applied to allow mathematical reasoning result in some unconventional nets
16:42:19 <oldandwise> i would like to see haskell excell here.. a domain that is very symbolic and closed and pure... analyzing source codes, etc...
16:43:38 <geekosaur> but it's the same problem: nobody picks a version control system based on its technical underpnnings
16:44:11 <dataN> thats the idea expressed in the "pushing the RIP phase transition" paper describes. what happens beyond the limit of the provable regions of performance
16:44:22 <oldandwise> geekosaur: source controls involves graphs, and isn't this the forte of haskell?
16:44:34 <geekosaur> you're not getting it
16:44:44 <geekosaur> yes, everyone is a comuter following strictly logicval rules to make decisions
16:45:09 <geekosaur> in reality, essentially nobody does that
16:45:36 <oldandwise> geekosaur: but if they see, a superiour feature... they will switch
16:45:42 <geekosaur> they use what they've heard of, what everyone they know is using (which often means: nothing), etc
16:45:50 <geekosaur> no, actually, they mostly don't
16:46:06 <geekosaur> linux refused to use a vcs for over a decade
16:46:18 <geekosaur> nobody cares about technical concerns or "superiority"
16:47:02 <dataN> a machine learning approach to linux version control?
16:47:13 <oldandwise> ? then why is linux here then?
16:47:59 <oldandwise> we are driven by technical edge...
16:48:18 <oldandwise> is why, we drop visual basic
16:48:57 <dataN> right, but the dynamics of legacy systems is a strong contender 
16:49:39 <geekosaur> lots of people havenot dropped visual basic
16:49:50 <oldandwise> so what... we have lambda calculus at our back
16:50:10 <dataN> but no type level fusion!
16:50:19 <dmwit> dataN: It's ambiguous because `SN3` is a type, not a computation; so it's not in scope; so GHC has no idea what type it should have.
16:51:12 <dataN> dmwit: is it beyond saving? 
16:51:28 <dmwit> dataN: You probably just want `sn3 = SS (SS (SS SZ))` instead of `type SN3 = SS (SS (SS SZ))`.
16:51:41 <dataN> brarg
16:52:37 <hodapp> dataN: what sort of restrictions?
16:52:49 <dmwit> dataN: ...in fact, you want `sn2 = SS (SS SZ)`. =P
16:52:56 <dmwit> dataN: With that change, it compiles for me.
16:53:43 <dataN> yay it works! https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
16:53:57 <dataN> hodapp: such as those of the echonet paper linked above
16:54:21 <MarcelineVQ> dataN: neat, what does it do?
16:54:51 <dataN> makes lists like tuples 
16:54:53 <dmwit> hmmm...
16:54:58 <dmwit> % :set -XDataKinds
16:54:59 <yahb> dmwit: 
16:55:15 <hodapp> dataN: what sort of meaningful reasoning/interpretation does this enable for a neural net?
16:55:26 <dmwit> % data RecNat a where Z :: RecNat Z; S :: RecNat n -> RecNat (S n)
16:55:26 <yahb> dmwit: ; <interactive>:82:33: error:; * Data constructor `Z' cannot be used here (it is defined and used in the same recursive group); * In the first argument of `RecNat', namely `Z'; In the type `RecNat Z'; In the definition of data constructor `Z'
16:55:34 <dmwit> shame
16:56:26 <dataN> hodapp: many proofs use the Restricted Isometry Property
16:56:43 <dataN> again, thats discussed in the first paper above
16:58:47 --- mode: glguy set +v dataN_
16:58:56 --- mode: glguy set -v dataN_
16:59:56 <Solonarv_> dataN : actually, what does this do that HList doesn't?
17:00:03 <Solonarv_> practically, I mean
17:03:08 <hodapp> dataN_: this doesn't really say anything about the models being more meaningful in terms of interpretability, nor even a hint at how it could be expected to handle (for instance) feature learning or the sorts of model biases required for meaningful recognition
17:39:47 <dataN_> hodapp: I dont know why NNs are more used for those tasks, possibly just because its the only way to demonstrate their performance without the option of being able to derive expressions for their convergence rates. 
17:42:49 <dataN_> sparse optimisation for noisy signal recovery takes a much more rigorous, as discussed above, and achieve the theoretical optimal performance where possible. as this has been established, the remaining work is in widening this region and developing analytic tools that can be applied beyond the RIP boundary.  
17:43:37 <dataN_> there is simply no need, from a theoretical perspective, to use the kinds of benchmarks common for NNs
17:44:20 <dataN_> approach*
17:51:09 <hodapp> dataN_: they're used more for those tasks *because they actually work*
17:51:18 <hodapp> this is not complicated or subtle. at all.
17:52:42 <dataN_> is the problem about understanding how modified gradient descent can be applied to those cases? 
17:54:44 <dataN_> thats the point anyway. because the NN theorists are forced to use practical examples to prove performance, then examples are available which can more easily be adapted to industrial uses.  
17:55:05 <dataN_> this usually gives no guarantees however.
17:55:58 <dataN_> where such guarantees can be proven mathematically, the absence of adaptable examples in the literature is a barrier to widespread industrial addoption.
17:56:34 <dataN_> where these guaranties are required however, the optimisation routines developed in compressed sensing are those that are used. 
17:57:22 <hodapp> industry as a general rule is uninterested in that which is "proven mathematically", in part because of the huge surplus of things that have supposed theoretical proofs of their superiority
17:57:47 <dyl> Just a sanity check, what would this Agda look like translated to use dependent haskell/singletons?
17:57:48 <dyl> data SET : Set where
17:57:48 <dyl>   set : (X : Set) → (X → SET) → SET
17:58:07 <dataN_> hodapp: there is nothing "supposed" about it
17:58:22 <dataN_> thats the point of a proof 
17:58:46 <dyl> So SET isn't written parametrized (it's just "SET") but you can still match/get out X.
17:59:34 <dyl> Originally I was using:
17:59:36 <dyl> data SET where Set :: forall (a :: Type). (a -> SET) -> SET
17:59:47 <dyl> But I can't get a back out, it's fully erased, and I need it in a type family. 
18:02:06 <hodapp> dataN_: there is everything "supposed" about proofs when it comes to the actual value and interpretation of the proof
18:10:57 <dataN_> hodapp: fair enough. but proofs of convergence, and performance guarantees of optimisation routines are pretty much the most fundamentally important applications of maths, so there is no doubt
18:12:23 <dataN_> in many important applications, CGIHT outperforms NNs in a real and significant way
18:12:59 <dataN_> and the extent of these applications is widening. 
18:13:08 <dyl> Bah, this hurts my head.
18:14:06 <hodapp> dataN_: what applications in specific?
18:14:29 <dataN_> where the restricted isometry property can be proven
18:15:08 <hodapp> that doesn't sound anything like an application
18:15:33 <dyl> I'm not sure how to just use singletons for passing a type as a term, basically :/.
18:15:38 <dataN_> separating noisy signals is the application it was developed for
18:17:07 <duncan^> 3  /buffer 124
18:21:13 <c_wraith> dyl, usually it involves passing a GADT where matching on it gives you the type (in a local context, anyway)
18:21:34 <dyl> c_wraith do you know what the correct translation of that agda would be?
18:21:40 <dyl> Set :: Sing a -> (a -> SET) -> SET doesn't seem to be right.
18:21:52 <hodapp> dataN_: well, denoising isn't too common an NN usage, though it is one thing they've tried to do with autoencoders
18:22:36 <dyl> Here's the Agda again:
18:22:38 <dyl> data SET : Set where
18:22:38 <dyl>   set : (X : Set) → (X → SET) → SET
18:22:52 <dyl> There's just so much in singletons and I'm not really sure how to properly translate this. 
18:23:02 <dyl> Rather than Set I want Type (*).
18:23:08 <dyl> (I have TypeInType enabled, for reasons.)
18:23:11 <c_wraith> dyl, why are you doing that? singletons are how to work around not being agda. :)
18:23:21 <dyl> Because I want to.
18:23:40 <hodapp> that and NVidia, Disney, and maybe Sony have papers in the past year or two on their magic denoising convnets specifically for monte carlo approximation noise
18:23:41 <dyl> But I'm at a stumbling block because I can't even figure out this really basic transaltion.
18:23:49 <dyl> I can't find a good set of examples.
18:23:51 <dataN_> hodapp: right, so where performance guarantees are available, NNs are not used. 
18:24:10 <dyl> Basically c_wraith: how would I translate the (X : Set) parameter? 
18:26:12 <hodapp> dataN_: performance guarantees are established for a lot of ML (see computational learning theory) but not too usefully so
18:26:56 <dataN_> hodapp: these kinds of stochastic methods that perform well far from the optimal setting are difficult to reason about algebraically 
18:28:30 <dyl> I just need to see an example haha, I know it’s not useful.
18:39:13 <dataN_> here is the example updated to show a function applied to a Typed Vector changing the type of one of the values it stores 
18:39:13 <dataN_> https://gist.github.com/dataN-hs/0aa36672625ed6bc4bdd03959f7b07f0
18:52:35 <MarcelineVQ> dyl: as a 1:1, maybe https://gist.github.com/MarcelineVQ/2f4f07eadedff7feaadebd7e91ceebb1  I've no idea what you would do from there though
18:56:44 <MarcelineVQ> as an aside, on my ghc vrsion you don't need TypeInType for this if you use * instead of Set or Type, I'm really not sure why
19:01:32 <MarcelineVQ> Oh I see in the scrollback you're asking about singletons, not just what that notation might transfer to
19:07:26 <ktonga> hi there. i get an error with the linker while trying to build hie (stack)
19:07:39 <ktonga> /usr/bin/ld.gold: error: cannot find -ltinfo
19:07:40 <ktonga> collect2: error: ld returned 1 exit status
19:07:40 <ktonga> `gcc' failed in phase `Linker'. (Exit code: 1)
19:08:19 <geekosaur> what platform/distribution?
19:08:23 <ktonga> there is an issue in GH https://github.com/haskell/haskell-ide-engine/issues/517 but the solution there does not work for me
19:08:38 <ktonga> ubuntu
19:08:46 <geekosaur> stack doesn't isntall OS/system provided libraries for you
19:08:54 <ktonga> i have ghc globally installed with nix-env
19:09:43 <ktonga> what would be that missing lib?
19:10:06 <geekosaur> it told you, tinfo
19:11:01 <ktonga> oh didn't parse the error properly  then :)
19:11:07 <geekosaur> forubuntu that is libtinfo-dev package. but if you have nxi installed, you may need its versio
19:11:12 <geekosaur> I'm looking
19:15:08 <geekosaur> if the system library isn't enough because it's looking in nix: nix-env --install ncurses
19:28:11 <ktonga> i tried again with `stack --nix` and it seems it's getting farther now, if it fails i'll try intalling ncurses as you suggested
19:28:21 <ktonga> thanks for the help geekosaur
19:29:06 <geekosaur> o, so you todl it to use nix and it's either installed there or nix installed it based on the derivaton stack gave it.
19:29:26 <geekosaur> nix does simplify some thngs. of course, it can aslo confuse the heck out of you.
19:30:26 <ktonga> it seems that with --nix stack will install system dependencies if they are specified by the libs which need them
19:31:02 <ktonga> that's what i understood when reading through https://github.com/NixOS/nixpkgs/issues/15995
19:31:20 <geekosaur> well, no. it still can't run th system package manager. but nix can autoinstall things, as I said; using --nix tells stack to ask nix for things
19:31:58 <geekosaur> nsx installs its own versions; apt packages won't see things installed by nix, and vice versa
19:32:06 <geekosaur> *nix
19:32:10 <ktonga> yeah it runs within a nix-shell adding some extra packages before starting the build
19:32:32 <geekosaur> it's kinda like installing a separate OS in a custom sandbox
19:32:40 <ktonga> i dont have anything related to haskell installed via apt
19:33:04 <ktonga> so maybe the best is getting this system libs via nix as i do for ghc and cabal 
19:34:18 <ktonga> it finished ok, but now i guess i have to use stack always inside a nix-shell to have those libs in the path
19:35:23 <ktonga> running out of battery here, sorry if i suddenly disappear :)
19:41:34 <greymalkin> Anyone use optparse-applicative in connection to a configuration file? 
19:42:32 <greymalkin> I want to get the command line parameter for the configuration file, parse it, and then apply the remaining command line arguments to that base configuration, but I don't see a clean way to do that.
19:44:53 <maerwald> you just create to configuration data structures and merge them, also utilizing a Default instance
19:45:07 <maerwald> s/to/two/
19:46:29 <greymalkin> Yeah, but then there's an unweildy number of Maybe values
19:47:13 <maerwald> Why
19:47:21 <greymalkin> For instance, a `flag` set to 'True' in the configuration file does not merge well with a following commandline option that sets it to False; so it would have to be a Maybe Bool rather than just a Bool.
19:47:35 <maerwald> does not merge well?
19:47:41 <maerwald> what does that mean
19:47:48 <maerwald> merging means you just overwrite things
19:48:07 <c_wraith> greymalkin: for configs, you often want the First or Last wrappers over just Maybe (pun intended)
19:49:05 <maerwald> sounds like you have dependencies between flags
19:49:21 <greymalkin> c_wraith: Do you know of an example of that?
19:49:48 <c_wraith> No.  I only know what it does.
19:50:17 <greymalkin> maerwald: No, one flag which is also a configuration item (say "fire missile") default is False, config file says True, then command line says False.
19:51:07 <ggVGc> what's the deal currently with stack and cabal?
19:51:41 <ggVGc> I haven't had a non-stack project in years now, but I hear cabal has had a lot of improvements making stack maybe not necessary for a lot of cases?
19:52:00 <c_wraith> I've never needed stack.
19:52:45 <maerwald> greymalkin: I don't really see the problem, except for some sort of perfectionaism
19:53:08 <maerwald> ggVGc: cabal cannot specify remote repositories still afaik
19:54:24 <maerwald> greymalkin: in which case you need to be more specific what you want
19:58:36 <maerwald> https://github.com/lspitzner/brittany/blob/4cb3b96f073fb391d765a38bb757c369f050e079/src/Language/Haskell/Brittany/Internal/Config/Types.hs#L51
19:58:45 <maerwald> https://github.com/lspitzner/brittany/blob/ab389fe66fa34a7bef649cd996e5d81103ae4324/src/Language/Haskell/Brittany/Internal/Config.hs#L285
19:58:54 <maerwald> this looks like an example of Last
19:58:58 <maerwald> greymalkin: ^
20:09:35 <coldpresent> why are methods with tuple args in Prelude defined only for finitely many tuples?
20:11:32 <coldpresent> can't we recursively define methods over many-element tuples?
20:11:36 <geekosaur> nope
20:11:49 <ab9rf> coldpresent: we want the prelude to be able to load in finite time
20:11:50 <geekosaur> you can do it with enerics, btu that's painfully slow
20:12:14 <geekosaur> *generics
20:12:45 <geekosaur> tuples are not recursive types. (try using fst or snd on a 3-tuple)
20:13:13 <ab9rf> you cannot construct a 3-tuple from a 2-tuple
20:13:19 <julianleviston> HList is probably more interesting
20:16:11 <coldpresent> thanks all
20:21:26 <maerwald> I'm imagining haskell with clojure syntax right now
20:22:08 <ggVGc> I think what we need is an embedded APL in haskell
20:23:27 <ab9rf> everything is better read right to left
20:23:44 <maerwald> ab9rf: it doesn't matter, as long as it's consistent
20:23:45 <ggVGc> actually checking APL repos on GH now..
20:24:14 <ab9rf> it's been decades since i saw actual APL code
20:24:15 <ggVGc> doesn't seem too great
20:24:24 <ggVGc> https://github.com/Dyalog/MiServer/blob/master/Core/Utils.dyalog
20:24:34 <ab9rf> code that actually does something, as opposed to just random snippets
20:24:49 <ggVGc> right, I've never seen an actual APL program before
20:24:52 <ggVGc> so this is new for me
20:25:05 <ggVGc> I think I vote no for embedded APL in haskell after all
20:25:10 <maerwald> lol
20:25:47 <ab9rf> what you don't want to use overstruck characters to indicate comments?
20:26:13 <ggVGc> I have modest requirements, such as wanting the majority of terminals to be able to render my code
20:26:26 <maerwald> who is using terminals these days for programming?
20:26:29 <ab9rf> hey, they're in unicode!
20:27:43 <ggVGc> ab9rf: my other modest requirement is being able to type the code in my programs with my standard keyboard layout
20:28:13 <ab9rf> picky picky
20:28:41 <maerwald> that's already hard in haskell if you have english keyboard, but german keybindings
20:29:03 <maerwald> >< and | are gone :)
20:29:43 <maerwald> so you need a hotkey for switching layout for a single button press
20:29:57 <ggVGc> I've been using UK layout for about 10 years
20:30:04 <ggVGc> by far the best for programming in my experience
20:30:19 <maerwald> well, because you've used it for 10 years...
20:30:25 <ggVGc> I jsut switch to swedish when I need to type umlaut characters
20:30:57 <ab9rf> and to think that my main irritation is in getting §
20:31:08 <ggVGc> maerwald: no, not because of that. Because []{}()<>#' are all either single letter or with shift
20:31:18 <ggVGc> ab9rf: I find ^ terrible
20:31:25 <ggVGc> but I remapped it in vim
20:31:32 <ggVGc> actually, same for $
20:32:00 <ggVGc> but there's no physical way for me to hit ^ comfortably without moving one hand too much
20:32:17 <ggVGc> 6 is really a crappy button
20:33:38 <maerwald> ^ is comfortable in german layout
20:34:34 <maerwald> maybe there should be a programming layout
20:34:47 <ggVGc> ab9rf: have you ever actually written an APL program?
20:34:56 <ggVGc> I've never spoken to anyone who has
20:34:58 <ggVGc> it seems terrible
20:35:34 <dolio> I know people here have written J programs.
20:35:47 <dolio> That's pretty close.
20:36:06 <ggVGc> yeah, J is basically ascii APL right?
20:36:12 <dolio> Yeah.
20:36:17 <ggVGc> quicksort=: (($:@(<#[), (=#[), $:@(>#[)) ({~ ?@#)) ^: (1<#)
20:36:18 <ggVGc> :(
20:36:25 <ggVGc> I mean...
20:36:31 <maerwald> wait, that looks like it's actually perl!
20:38:23 <ggVGc> all of a sudden it doesn't seem like haskell has much of an operator problem at all
20:39:33 <julianleviston> haha well when your whole language *is* operators, I guess so ;-)
20:42:24 <maerwald> threading macro in clojure is so much nicer than foo . bar . baz
20:43:58 <maerwald> when reading clojure code, the first 1 or 2 characters of a line already tell you how to read, there is no back and forth scanning, jumping between top-bottom, looking for hidden where clauses or lets or figuring out what infix operators mean
20:44:17 <maerwald> so reading is much faster... but reasoning not xD
20:44:42 <ggVGc> I don't know clogure, but are you talking about piping vs composition?
20:44:55 <ggVGc> e.g baz |> bar |> foo
20:44:59 <ggVGc> rather than foo . bar .baz
20:45:14 <maerwald> foo . bar . baz $ val
20:45:14 <maerwald> (-> val baz bar foo)
20:45:35 <maerwald> beginning of the line/brackets tells you what is happening
20:45:42 <maerwald> how to read it
20:45:46 <ggVGc> I write a lot of Elixir nowadays, and a lot of it is built around piping. I kind of don't like it at all
20:45:57 <maerwald> no confusion, not surprise
20:46:02 <ggVGc> because the return type of the expression is the last term
20:46:06 <ggVGc> rather than at the start
20:46:25 <ggVGc> like, length . findStuff $ something
20:46:32 <ggVGc> is really clear that I'll get a number
20:46:38 <ggVGc> the moment I start reading
20:47:22 <maerwald> is it? imagine you have a complicated fmap in the front, now guess what you get
20:48:26 <ggVGc> I don't think that's a good comparison
20:48:32 <maerwald> I see it all the time
20:48:46 <maerwald> so when looking at a line, I never know what type it is
20:48:57 <maerwald> the order doesn't help me
20:49:07 <maerwald> unless it's just prelude functions ;)
20:53:24 <maerwald> if only clojure was strongly typed
20:55:23 <greymalkin> huh.
20:55:25 <greymalkin> coinexmachina: internal error: evacuate: strange closure type 38157289
20:59:52 <greymalkin> I just wish I knew what caused it.
21:14:14 <dmj`> lexing bytestrings w/ alex is so underrated
21:14:30 <dmj`> almost as underrated as ghc.generics
21:21:40 <acoret_laptop> is takeMVar  an atomic action?
21:24:26 <dmj`> acoret_laptop: takeMVar combined with a putMVar, and put your action in the middle That’s what modifyMVar’ is, or withMVar
21:25:06 <dmj`> > This function is only atomic if there are no other producers for this 'MVar'.
21:25:09 <lambdabot>  <hint>:1:30: error: parse error on input ‘if’
21:26:11 <acoret_laptop> dmj`: thanks a lot
21:40:32 --- mode: glguy set +v Poi
21:46:30 <Poi>  /help
21:55:16 <dmj`> acoret_laptop: np
23:40:27 <dyl> ggVGc: I’m currently working on AyyPL, a dialect of APL entirely using emoji.
23:40:32 <dyl> It’s going to be horrible.
23:44:00 <sleepster> is GUI development with Haskell okay?
23:44:24 <dmj`> sleepster: yes
23:44:27 <dmj`> sleepster: it’s great
23:44:35 <dmj`> sleepster: https://haskell-miso.org 
23:44:40 <sleepster> oh nice :) I am here https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
23:44:45 <sleepster> but it is showing a lot of options
23:44:51 <sleepster> thanks dmj` , I will give that a look
23:45:20 <julianleviston> Normally when people say “GUI development”, do they mean frontend web development?
23:46:34 <sleepster> oh, I was meaning client-side UI development
23:47:57 <julianleviston> Do you mean web or native?
23:48:06 <julianleviston> Anyway, miso is web.
23:50:43 <dmj`> you can probably put miso in electron and call it a desktop app
23:50:45 <dmj`> https://electronjs.org/
