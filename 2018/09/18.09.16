00:58:34 * hackage cloudi 1.7.4 - Haskell CloudI API  http://hackage.haskell.org/package/cloudi-1.7.4 (okeuday)
01:15:29 <mniip> hmm
01:15:41 <mniip> gotta follow SPJ's advice and write stuff up in articles
01:39:57 <julianleviston> mniip: about what?
01:46:35 <mniip> julianleviston, the gist is to not try to do all the research first and then write up a paper, but rather start a paper and let the process of writing the paper force to do the right reseach
01:46:58 <maerwald> that's weird
01:47:09 <julianleviston> oh interesting
01:47:25 <mniip> maerwald, quoting SPJ, you might find you're missing a whole chapter
01:47:37 <maerwald> what chapter
01:48:10 <MarcelineVQ> If it wasn't missing you'd know.
01:48:25 <maerwald> thanks
01:50:09 <maerwald> who has an overview of the FRP libs out there
01:50:34 <mcspud> I use React + ImmutableJS + Ramda + RxJS if that helps maerwald 
01:51:03 <maerwald> React?
01:51:06 <mcspud> err ignore that, I thought you were asking about front end 
01:51:55 <maerwald> I don't know RxJS but the rest is not FRP
01:52:34 <maerwald> frontend is also fine
01:53:25 <maerwald> e.g. a useful alternative to clojurescript + react + om
02:02:23 <julianleviston> maerwald: assuming you’ve already read https://wiki.haskell.org/Functional_Reactive_Programming which is a bit long in the tooth?
02:06:51 <maerwald> Whenever I read wiki.haskell.org I am just confused, so no 
02:07:06 <maerwald> is the list up to date?
02:07:31 <maerwald> https://github.com/gelisam/frp-zoo
02:07:33 <maerwald> seems interesting
02:13:41 <maerwald> I don't understand half of the readme, lol
02:17:28 <julianleviston> Sorry, yeah, “long in the tooth” means a bit out of date, possibly.
02:18:30 <julianleviston> reflex is probably a good place to take a look, tho. 
02:18:46 <julianleviston> https://reflex-frp.org
02:19:04 <Gurkenglas> Where do we get our free theorems generated for us these days?
02:22:50 <mniip> ?free gurkenglas :: (a -> b) -> a -> b
02:22:50 <lambdabot> g . h = k . f => g . gurkenglas h = gurkenglas k . f
02:29:29 <hololeap> honestly, i found reflex to be way too intimidating (and not very well documented) to start picking up the basics of FRP. writing something simple with reactive-banana is a better place to start IMO
02:32:11 <hololeap> i have heard that reactive-banana is not as good as reflex in terms of speed and power, but it is written to be simple and understandable
02:34:18 <maerwald> this is nice https://www.youtube.com/watch?v=Agu6jipKfYw
02:34:38 <maerwald> hololeap: well, I definitely prefer simple and understandable over expressivity and power
02:41:42 <maerwald> the way he explains it, we should avoid higher-order FRP
02:48:35 <julianleviston> Evan’s take on FRP isn’t really what conal meant by it, AFAIK
02:49:34 <maerwald> conal?
02:50:14 <julianleviston> Conal Ellilott — he “invented” the term.
02:50:26 <julianleviston> http://conal.net
02:51:58 <julianleviston> AFAICS the primary thrust of what he was intending, or primary message, was that signals are continuous functions over time… in the sense that they don’t involve discrete events… because the degradation of signal appears when one bakes down into a specific finite resolution.
02:53:44 <maerwald> Evan is not talking about the academic definition, but about the design space that library implementations take
02:53:50 <julianleviston> Yep.
02:54:14 <julianleviston> Libraries or not, it’s a watering down of the ideas in the space, which is pretty unfortunate.
02:54:34 <julianleviston> …which is a subtle idea, so of course got largely misunderstood by most people. People grasped the *reactive* part rather than the *functional* part, and functions in programming generally don’t mean what mathematicians mean by functions, so the original message seems to have devolved. You get some pretty powerful and interesting properties if you follow the idea of mathematical functions on time.
02:56:12 <maerwald> I don't see the point really
02:56:44 <maerwald> the talk is pretty clear about the scope and motivation, I don't find it confusing at all
02:57:20 <maerwald> it talks about practical trade offs
02:57:40 <maerwald> which is exactly what people care about who choose an approach
02:58:45 <Cale> Avoiding higher order FRP is a good way to ensure your FRP system won't really be able to manage anything remotely interesting -- most UIs really want to have parts that are able to switch between different views.
03:00:45 <maerwald> do you have an example?
03:00:49 <Cale> (It's worth noting that Elm gave up on FRP a couple years after that talk)
03:01:27 <Cale> Consider for example, a calendar widget that switches between some different views -- perhaps a day view, a week view, and a month view.
03:02:12 <julianleviston> Yeah I just assumed Maerwald knew that.
03:02:20 <julianleviston> (knew that Elm doesn’t do FRP at all anymore)
03:02:24 <maerwald> sure
03:04:32 <Cale> Just for the sake of simplicity, let's suppose that all it does is to tell which scheduled activity the user clicked on, so from the perspective of the rest of the world, it might produce an Event Activity
03:05:56 <Cale> Of course, when we write the day, week, and month calendars, they're going to produce an Event of the same sort. If we're going to switch between UIs for each of them, when we switch to a new one, we'll get a different Event Activity at that moment
03:06:55 <Cale> So, we'll want some way to say, "Give me the Event which fires when the Event Activity *for the currently displayed interface* fires", i.e. switch between them
03:08:04 * hackage vector-algorithms 0.8.0.0 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.8.0.0 (ErikDeCastroLopo)
03:08:16 <Cale> So, you'll have some Behavior (Event Activity), and you'll want to get an Event Activity -- that's a higher order switching function.
03:10:01 <Cale> Of course, in this particular case, one option would be to just run all the UIs at once, and merge their individual results -- but that isn't always a great plan. Sometimes you don't want to pay to have them all constructed and running at once.
03:12:15 <maerwald> For frontend ui code, I think it would be pretty easy to avoid that complexity. For something else (like game dev), probably not
03:12:54 <julianleviston> If you’re interested, it might be nice to listen to Conal talk about it… I like conal’s talks… https://www.youtube.com/watch?v=j3Q32brCUAI
03:14:03 <Cale> In a game, you're likely to have lots of interesting switching as you need to create and remove AIs and other components from the world
03:14:51 <maerwald> yeah
03:15:05 <maerwald> but in frontend, I wouldn't choose that and rather remove UI complexity
03:15:06 <Cale> But even in comparatively simple web frontend code, it comes up like once or twice a day that you need some kind of switching of some sort (or at least it would be awkward to avoid it)
04:07:40 <tsaka__> case expressions need not cover all cases in haskell?
04:07:45 <tsaka__> but guards do?
04:08:35 <Cale> Guards needn't either
04:09:08 <Cale> Though you really ought to try to make pattern matches total, and the compiler will try to warn you when they're not
04:16:08 <maerwald> yeah, avoid _ -> matches though
04:16:44 <maerwald> it's total, but might surprise you during refacotring
04:28:34 * hackage servant-auth-token 0.5.6.0 - Servant based API and server for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-0.5.6.0 (NCrashed)
04:29:25 <c50a326> hey how do you define list stuff yourself? I mean it's already defined in Prelude... I've been fooling around with this kind of code using a Cons a (MyList a) | Empty kinda thing, but failing hard https://ptpb.pw/J3nr/hs maybe I'd be better if I could use [] syntax
04:29:47 <c50a326> or is there a good tutorial or something on this?
04:30:46 <Cale> c50a326: Why are you mappending all those things together?
04:31:11 <c50a326> Cale: I was just playing with it to see if I could make something that worked and then figure out why it worked after, lol...
04:31:27 <Cale> b and d are lists
04:31:31 <Cale> a and c are not
04:31:37 <Cale> (not necessarily anyway)
04:32:04 * hackage cdeps 0.1.1.8 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.8 (vmchale)
04:32:55 <Cale> Also note that line 14 makes line 13 redundant
04:33:53 <Cale> (and if you write the usual instance, it will make line 15 redundant as well)
04:34:16 <Cale> The usual behaviour of mappend is to concatenate the lists
04:34:24 <Cale> > mappend [1,2,3] [4,5]
04:34:26 <lambdabot>  [1,2,3,4,5]
04:34:43 <Cale> So  mappend (Cons x xs) ys = Cons x (mappend xs ys)
04:34:58 --- mode: glguy set +v zhaskell
04:36:37 <atchoum> how do you write quick tests for haskell ?
04:37:05 <atchoum> I mean, tests that could be executed at compile time for example, or tests that could be run with a special command ?
04:38:00 <atchoum> I mean maybe quick check is overkill but if that's all there is then I'd go for it.
04:38:16 <maerwald> just write a unit test with hspec
04:38:32 <atchoum> thanks.
04:38:38 <atchoum> i'm trying it right now.
04:38:54 <maerwald> https://hspec.github.io/
04:39:03 <atchoum> i'm on the same page
04:48:53 <atchoum> cool
04:52:57 <c50a326> how does it know to use `Empty <> x` as `x <> Empty`
04:53:27 <Rembane> Does it know commutativity as a concept?
04:57:12 <c50a326> I don't know about that :o also, I've fixed Semigroup/Monoid definitions and done a Functor definition: https://ptpb.pw/ErwA/hs howcome the Semigroup/Monoid defs require the type variable in the instance declaration, but Functor does not?
04:58:03 <Rembane> :k Semigroup
04:58:04 <lambdabot> error:
04:58:05 <lambdabot>     Not in scope: type constructor or class ‘Semigroup’
04:58:08 <Rembane> :k Monoid
04:58:09 <lambdabot> * -> Constraint
04:58:12 <Rembane> :k Functor
04:58:14 <lambdabot> (* -> *) -> Constraint
04:58:20 <c50a326> ah yes, I remember that now, thanks
04:59:08 <c50a326> are there any classes that are like (* -> * -> *) -> Constraint?
04:59:27 <Rembane> :k Either
04:59:28 <lambdabot> * -> * -> *
04:59:30 <Rembane> :D
04:59:35 <Rembane> It only misses Constraint...
04:59:42 <Rembane> :k Bifunctor
04:59:44 <lambdabot> (* -> * -> *) -> Constraint
05:00:16 <Rembane> Which is why Bifunctor is quite useful when working with Either.
05:01:46 <c50a326> ah yeah I saw Bifunctor when I was wanting to map functions over tuples
05:05:08 <c50a326> but how can <>'ing lists be commutative when [4,5,6] ++ [1,2,3] /= [1,2,3] ++ [4,5,6]? I suppose it's commutative if there's a []
05:05:39 <mniip> 9/16/2018 [14:58:47] <c50a326> are there any classes that are like (* -> * -> *) -> Constraint?
05:05:46 <mniip> Bifunctor, Profunctor, Category
05:05:55 <mniip> Arrow, Choice,
05:06:21 --- mode: glguy set +v Jetien
05:06:24 <Jetien> hi! what is the total alterantive to (!!)? I couldn't find any [a] -> Int -> Maybe a in hoogle
05:07:50 <c50a326> ah I get it, if the Empty def is like: `Empty <> _ = Empty` and then the next def is `(Cons x xs) <> ys = Cons x (xs <> ys)` then it just keeps consing if ys is Empty
05:08:06 <mniip> :t \i -> lookup i . zip [0..]
05:08:07 <lambdabot> (Enum a, Num a, Eq a) => a -> [b] -> Maybe b
05:08:21 <mniip> not sure if a good idea performance wise though
05:08:37 <c50a326> oops I meant `Empty <> x = x` above
05:08:38 <tdammers> Jetien: (!!) on lists is O(n), so if you're going to index lists by integer index, you should probably consider a different data structure, e.g. Vector
05:09:24 <c50a326> but then surely adding `x <> Empty = x` would make it more efficient because it doesn't have to do all that consing when there's an empty list on the right and a long list on the left...
05:09:31 <c50a326> but maybe the compiler is smart about this kind of thing
05:10:04 <mniip> c50a326, that would make it strict in the rhs
05:10:31 <c50a326> mniip: how?
05:10:48 <mniip> > take 3 $ [1,2,3] <> undefined
05:10:51 <lambdabot>  [1,2,3]
05:30:06 <atchoum> how can I tell where the module I want to import is ?
05:30:18 <atchoum> I mean I put Question09 module into question_09.hs file
05:30:25 <atchoum> but I can't import it from question_10.hs file
05:30:57 <hpc> it needs to be Question09.hs, to start
05:31:30 <hpc> import Foo.Bar.Baz always looks for Foo/Bar/Baz.hs, from some directory root
05:32:52 <atchoum> yeah just read that
05:32:54 <atchoum> thanks
05:32:59 <atchoum> I'll have to rename everything
05:35:35 * hackage mameya 0.2.0 - Static Website Generator in Haskell  http://hackage.haskell.org/package/mameya-0.2.0 (bururabit)
05:36:59 <atchoum> is it a good idea to have transitive imports ?
05:37:43 <atchoum> ok it's not working anyway
05:38:10 <atchoum> i'm asking because I wanted to know if I could import some lib in only one module and then import that lib from that module elsewhere else in my program 
05:38:44 <atchoum> I'm always confused with the difference between `Int` and `Integer`
05:40:13 <julianleviston> > maxBound :: Int
05:40:16 <lambdabot>  9223372036854775807
05:40:17 <julianleviston> > maxBound :: Integer
05:40:19 <lambdabot>  error:
05:40:19 <lambdabot>      • No instance for (Bounded Integer)
05:40:19 <lambdabot>          arising from a use of ‘maxBound’
05:40:27 <hpc> personally the only guideline i follow for imports is never do cyclic imports
05:40:30 <atchoum> ok Integer has arbitrary size
05:40:42 <atchoum> hpc: doesn't the compiler enforce it ?
05:40:55 <hpc> you can do some nonsense with .hs-boot files to make it work
05:41:04 * hackage mameya 0.2.0.1 - Static Website Generator in Haskell  http://hackage.haskell.org/package/mameya-0.2.0.1 (bururabit)
05:41:07 <hpc> and some people say it's worth the effort, but i think it's anti-modular
05:41:14 <atchoum> :)
05:41:32 <atchoum> hpc: avoiding circular imports is like avoiding cycles in the import tree, isn't it ?
05:41:34 <hpc> anything beyond that though, i base on how i want to factor out the problem i am trying to solve
05:41:37 <hpc> yeah
05:41:50 <hpc> atchoum: in the simplest case consider cyclic imports A <-> B
05:42:01 <hpc> atchoum: you can never reason about one module independently of the other
05:42:05 <hpc> if it's not cyclic
05:42:06 <hpc> A -> B
05:42:12 <hpc> or A -> C, B -> C
05:42:22 <hpc> you can separate out the leaves of the import tree
05:42:34 * hackage mameya 0.2.1 - Static Website Generator in Haskell  http://hackage.haskell.org/package/mameya-0.2.1 (bururabit)
05:42:38 <hpc> think about them on their own terms, "compress" that into whatever they export
05:42:44 <hpc> and work your way up the tree
05:44:03 <hpc> it's the logical extension of no cyclic package dependencies, imo :D
05:47:56 <atchoum> hpc: it is viewed as clean design to have a proper hierarchical tree.
05:48:06 <atchoum> I'm doing this: https://wiki.haskell.org/99_questions/11_to_20
05:50:07 <dmwit> atchoum: Not sure I 100% understand, but you can `module Foo (module Bar) where import Bar` to re-export everything from another module or `module Foo (this, that, theOther) where import Bar` to re-export only select things.
05:51:35 <hpc> ah, i see
05:52:35 <hpc> i found a neat trick in someone else's package
05:52:54 <hpc> module Foo (module Reexports) where import Bar as Reexports; import Baz as Reexports; ...
05:54:10 <dmwit> Probably also worth knowing about `module Foo (module Foo, bar) where import Bar`. Lets you export everything you normally would without an explicit export list, plus `Bar.bar`.
05:55:04 <hpc> oh wow, didn't know about that
05:59:34 <dmwit> Right? Every once in a while you learn something about the language and go... "huh, the committee thought of that??".
05:59:59 <dmwit> \& is the other one that gets me feeling that way.
06:01:14 <MarcelineVQ> What is \& ?
06:01:40 <dmwit> > ("\14H","\1")
06:01:42 <lambdabot>  ("\SO\&H","\SOH")
06:02:00 <dmwit> > "lol\&\&\&\&\&lm\&\&ao"
06:02:02 <lambdabot>  "lollmao"
06:02:50 <dmwit> > ("\32\&1", "\321")
06:02:52 <lambdabot>  (" 1","\321")
06:04:05 <maerwald> the committe summons every 8 years in Rivendell
06:06:17 <MarcelineVQ> dmwit: thank you, that "\32\&1" example is the one that made it clear
06:06:32 <monad_cat> The demand analyzer in GHC that outputs to Core sometimes outputs annotations like `<L, 1*U(U)>`. What does `1*` mean in this context?
06:25:39 <julianleviston> if I compile a file with -ddump-ds where is the core spat out?
06:26:26 <julianleviston> or should I be using -fext-core ?
06:28:49 <MarcelineVQ> depends how you're building but you probably want -ddump-to-file set
06:28:56 <MarcelineVQ> idk what -fext-core is
06:29:30 <julianleviston> Oh nevermind, it turns out my stage2 compiler is doing something different than the normal one
06:29:45 <MarcelineVQ> are you after ds (desugaring) specifically?
06:29:45 <julianleviston> any idea how to get *that* to dump core? I actually want it to dump the stage before that (parse)
06:30:10 <julianleviston> what I really want is -ddump-parsed
06:31:18 <julianleviston> All good I’ve got it now. 
06:31:23 <MarcelineVQ> found -ddump-parsed ?
06:31:42 <julianleviston> I needed -ddump-simpl
06:31:55 <MarcelineVQ> Oh, em, are you sure?
06:31:55 <julianleviston> for core, which is why that wasn’t giving me what I expected...
06:32:48 <julianleviston> Sorry, two questions at once helps no one.
06:32:58 <MarcelineVQ> simpl is pretty late in the process, though not as late as prep
06:33:46 <julianleviston> I’m across them all now, it seems :)
06:38:04 <julianleviston> It *is* a bit weird to me that the output of -ddump-parsed isn’t `HsSyn`, but I guess it’s pretty-printed `HsSyn` which is fairly identical to ordinary haskell source
06:38:17 <_sras_> Can some one please review my post here, https://sras.me/haskell/what-the-heck-is-typeable.html ?
06:38:19 <julianleviston> I learned the hard way that there’s no show instance for that.
06:39:41 <julianleviston> _sras_ doesn’t typeable also let us delve into generics and let us do dynamic programming? at least… that was what I thought one of its major drawcards was.
06:40:47 <_sras_> julianleviston, What is wrong with dynamic programming that is, if it can be done safely. I think that is what typeable enables one to do in Haskell.
06:41:24 <_sras_> julianleviston, What is wrong with dynamic programming, that is, if it can be done safely? I think that is what Typeable enables one to do in Haskell.
06:42:53 <_sras_> julianleviston, I think I have addressed something similar at the end of the post.
06:43:01 <julianleviston> Kinda.
06:43:07 <julianleviston> It’s an interesting post!
06:46:37 <julianleviston> Oh nice I just found the -dppr-debug flag
06:52:04 * hackage stache 2.0.1 - Mustache templates for Haskell  http://hackage.haskell.org/package/stache-2.0.1 (mrkkrp)
07:04:01 <_sras_> julianleviston, Thank you.
07:07:09 <hexagoxel> _sras_: you might want to mention that the `Dynamic` type is usage-wise identical to the Typeable-existential.
07:08:52 <hexagoxel> well, unless you really need to recover the dictionary. i am not aware of cases where that is important.
07:09:04 * hackage aos-signature 0.1.0 - An implementation of the AOS signatures  http://hackage.haskell.org/package/aos-signature-0.1.0 (sdiehl)
07:10:04 * hackage with 0.1.0 - Simple open product type  http://hackage.haskell.org/package/with-0.1.0 (iokasimovmt)
07:13:16 <blankhart> i think i saw existentials/typeable used that way in the eve library and one other place i can't remember
07:14:15 <blankhart> it might be worth referencing the scrap your boilerplate paper even in passing
07:14:33 --- mode: glguy set +v haskell_noob5
07:18:45 <hexagoxel> if you really have to grab some short name from the package namespace just for some infix pair type, why name it "with" when "pair" is available oO
07:20:16 <cocreature> hexagoxel: I’m not even sure why this is supposed to be an “open product type”
07:21:22 <haskell_noob5> I needed some help in using lens for a library:: here is the gist :https://gist.github.com/dinkarganti/b966a550f72306bcfc811c5b0c689ec7 How do I update the structure with a new apiversion in my example? thanks.
07:21:54 <hexagoxel> cocreature: not en"close"d by parentheses!
07:22:12 <cocreature> hexagoxel: please tell me that this is not the real reason …
07:22:54 <hexagoxel> i don't know the uploaded either :)
07:23:04 <hexagoxel> *uploader
07:23:13 <cocreature> that package just makes me sad
07:23:50 <cocreature> it doesn’t even derive any instances
07:24:50 <Athas> It already has five stars on GitHub!
07:29:46 <_sras_> hexagoxel, I didn't know that! Thankyou. 
07:35:32 <zfnmxt> What's the recommended way for dealing with using a function that was added to a library in a recent snapshot,  while maintaing support for older snapshots? I'd like to just add the function in manually for the older snapshots, but I'm not sure how to handle this. (Is there something like an #if oldSnap shot ... for both imports/function definitions?) 
07:36:49 <zfnmxt> I guess I could just explicitly import everything I use, not import the new function, and simply define that new function. But that seems kind of jank. 
07:37:33 <cocreature> zfnmxt: it doesn’t make sense to check for the snapshot since someone can build a package without a stackage snapshot or use a snapshot but change the library version
07:37:39 <cocreature> zfnmxt: but you can check for the library version, see https://cabal.readthedocs.io/en/latest/developing-packages.html#conditional-compilation
07:38:36 <zfnmxt> cocreature: Is checking the version considered better practice than just doing what I said above with the explicit imports?
07:39:31 <cocreature> depends on the function I suppose. if your own implementation is in some way inferior to the one in the lib than I would definitely go for the version checking approach
07:39:56 <cocreature> if you are just copying the definition from the newer version, then it might be easier to avoid that
07:40:17 <zfnmxt> I'd just do the latter. The function is all of 4 tokens or something. 
07:46:20 <dmwit> (e.g. many of the new Data.Map functions are more efficient than can be implemented with the old interface)
07:58:34 * hackage blunk-hask-tests 0.2 - Tests for the Blunk sequencer library.  http://hackage.haskell.org/package/blunk-hask-tests-0.2 (demigod)
08:03:23 <dmj`> > sizeOf (undefined :: Char)
08:03:25 <lambdabot>  error:
08:03:25 <lambdabot>      • Variable not in scope: sizeOf :: Char -> t
08:03:25 <lambdabot>      • Perhaps you meant one of these:
08:11:33 <atchoum> how do you do you package in Haskell ?
08:11:41 <atchoum> I am in a root folder (say '.')
08:12:00 <atchoum> I have two folders in it: `Mod1` and `Mod2`
08:12:22 <atchoum> How, from the `Mod2` folder, do I import the content of the `Mod1/Mod1A.hs` ?
08:12:38 <glguy> import Mod1.Mod1A
08:13:14 <glguy> You specify the root source directories in your project's .cabal file under hs-source-dirs:, and if you don't then the default is the directory containing the cabal file
08:13:28 <glguy> imports are resolved relative to those source directories
08:13:34 * hackage deptrack-dot 0.1.0.0 - Facilitate Graphviz representations of DepTrack dependencies.  http://hackage.haskell.org/package/deptrack-dot-0.1.0.0 (LucasDiCioccio)
08:13:36 <atchoum> glguy: so you answer implies that I should have created a cabal project first ?
08:14:14 <glguy> If you're just using ghci directly, set your current directory to the one containing Mod1 and Mod2
08:14:16 <cocreature> atchoum: once you move beyond a single source file that is usually a good idea
08:14:21 <glguy> then the imports will resolve correctly
08:14:24 <atchoum> I didn't do that, I must create it then. Is cabal the only way or should I do it with Stack / whatever other tools is suggested ?
08:14:41 <glguy> cabal-install (cabal executable) is the suggested tool
08:16:22 <atchoum> I only have stack ghc :(
08:17:53 <glguy> OK, there're tutorials online for getting stack working if that's all you have
08:17:57 <atchoum> yes
08:18:00 <atchoum> i'm using them
08:18:02 <atchoum> thanks
08:18:12 <atchoum> I have zero experience with haskell packaging.
08:18:38 <atchoum> could a package name starts with numeral chars ? Like `99Bottles` for example ?
08:18:45 <cocreature> you can either install cabal and use "cabal init" and "stack init" to create the stack.yaml file, use "stack new" in an empty directory and copy the source files over afterwards or write the cabal file yourself (which isn’t too hard if you copy some example) and then run "stack init"
08:19:02 <dmwit> % sizeOf 'a' -- dmj` 
08:19:02 <yahb> dmwit: 4
08:20:19 <maerwald> zero experience means cabal is probably easiest
08:20:24 <dmj`> dmwit: nice, thanks
08:20:25 <atchoum> yes :(
08:20:34 <atchoum> that's what I'm currently experiencing.
08:20:35 <dmj`> % sizeOf (undefined :: Int)
08:20:36 <yahb> dmj`: 8
08:20:41 <dmj`> fast!
08:20:52 <dmj`> lambdabot takes its sweet time
08:25:05 <atchoum> stack is cool
08:25:24 <maerwald> until you actually have to use it :P
08:25:30 <maerwald> in a regular workflow
08:26:03 <maerwald> if cabal only supported remote repos
08:27:19 <fendor> maerwald, knowing i will cause a flame war, I use it on a regular workflow and rarely experience any problems, what are you referring to?
08:28:14 <atchoum> fendor: with the willing to temper this not-yet-born flame war, stack uses as a default the Package.cabal file, that's  courteous.
08:28:30 <atchoum> It gives a warning though :p
08:29:49 <atchoum> Mmh I think things are getting serious when you can package in an industrial fashion your application.
08:29:54 <maerwald> fendor: oh, tons of things, e.g. "stack ghci" is slow, so you have to use "stack exec ghci" to load less modules, which then fails due to TH or something else. Then you have shadowed dependency problems
08:29:54 <maerwald> then you have problems with docker setup because stack bundles an internal hpack version and you have no control over how it is invoked and it will generate all files, because it's stack
08:29:54 <maerwald> then stack re-copies all binaries, no matter whether they have actually been rebuilt, which can take quite some time
08:30:25 <maerwald> then stack downloads semi-random ghc binaries which may not work on your distro
08:31:26 <maerwald> stacks nix integration is kinda broken too
08:31:46 <maerwald> you have to *disable* it so stack works under nix :o ... we have to patch stack basically so nix shells work
08:32:04 <fendor> maerwald, i understand the criticism, does cabal do it better? 
08:32:33 <maerwald> also, running cabal from within a stack script may not work at all, because stack sets some environment variables
08:32:39 <maerwald> which breaks cabal
08:33:01 <maerwald> probably a rare use case, but I found that funny anyway
08:33:22 <fendor> does cabal support docker builds, etc? 
08:33:52 <maerwald> fendor: cabal sandboxes are the only thing that works properly. But it's annoying to set up when you have custom repositories and then have to deal with submodules and cabal sandbox add-source etc
08:34:19 <maerwald> what do you mean with "support docker builds"?
08:34:52 <dmwit> Oh, this is fun. Now complain about new-*.
08:35:01 <fendor> stack has a own section in stack.yaml for creating a docker container for your application.
08:35:25 <fendor> however, on nixos, i had weird linking issues in the container so i used another dockerfile
08:35:35 <maerwald> We use shake for building docker images
08:35:44 <maerwald> not sure if stack could handle the same complexity
08:35:53 <cocreature> conclusion: all tools suck and we need a new tool that sucks just as much but in slightly different ways
08:36:05 <maerwald> cocreature: cabal sandboxes don't suck :)
08:36:07 <fendor> cocreature, birth of another haskell build tool! 
08:36:11 <maerwald> they just lack a few features
08:36:22 <fendor> which are hopefully added soonish
08:36:24 <dmj`> https://xkcd.com/927/
08:36:33 <maerwald> no, less build tools
08:36:49 <dmwit> new-* has completely subsumed sandboxes for me. For many of my coworkers, too, with the one exception being that new-haddock still really bites and sandboxes do haddocks much better.
08:36:59 * dmj` goes back to runghc Setup.hs
08:37:05 <maerwald> last time I checked new-install was still not working
08:37:17 <maerwald> and it also comes with the "global cache" problems
08:37:28 <dmwit> You can make named caches.
08:37:44 <dmwit> But what are the "global cache" problems?
08:37:46 <maerwald> isn't that basically a sandbox then? :P
08:37:53 <cocreature> dmj`: also new-build just doesn’t support GHC’s qAddDependentFile feature
08:37:58 <cocreature> eh that was for dmwit 
08:38:06 <dmwit> maerwald: No, because you can still have multiple versions of a single package in one of the named caches.
08:38:31 <dmwit> cocreature: Oh, yeah, that's true. That is super annoying, and that's been very painful for me.
08:39:34 <cocreature> it’s one of those things that is mostly fine since at least I don’t use this feature that often but makes it completely unusable for projects that do make use of it
08:39:42 <dmwit> (...and named caches can have multiple copies of the same package/version pair with different dependencies/flags, etc. just like the global cache. But you get my point.)
08:41:54 <maerwald> dmwit: how do you clean up unsued versions?
08:42:17 <dmwit> new-gc is coming, I believe. Not here yet, though, true.
08:42:31 <maerwald> that would be a significant feature
08:42:52 <maerwald> but then it feels like docker, lol
08:44:25 <maerwald> also wondering... can you write stack-like scripts with new-*?
08:44:41 <maerwald> which have dependencies
08:47:52 <maerwald> https://github.com/haskell-lisp/historic-lisk oh boy, beautiful
08:50:34 * hackage Oslo-Vectize 0.2 - Tests for the Blunk sequencer library.  http://hackage.haskell.org/package/Oslo-Vectize-0.2 (demigod)
08:50:36 <dmwit> maerwald: What are stack-like scripts?
08:50:54 <dmwit> Like, a Haskell program that uses stuff from the project?
08:51:12 <dmwit> If so, you can just make a normal Haskell program and use runghc on it.
08:52:30 <maerwald> https://privatebin.net/?79ee9770c2522056#UF+DZKHf4mg3Sm9XCsddrAG/11MEZU/RDjZ2W2m+/Q8=
08:52:40 <maerwald> dmwit: with custom dependencies?
08:53:10 <maerwald> not stuff from the project
08:54:17 <atchoum> how do you store tests in your stack project ?
08:54:45 <atchoum> I mean I have a test folder, mmmh.
08:54:50 <atchoum> pondering and wondering
08:55:18 <atchoum> runghc doesn't work anymor, it says could not find module 'Test.Hspec'
08:56:21 <dmwit> maerwald: You'd have to list them in optional-packages.
08:56:59 <`Guest00000> oh, how cute https://wiki.haskell.org/User:Ashley_Y#Compilers
08:57:40 <maerwald> dmwit: but this is a script, not a project file
08:57:49 <maerwald> like you can literally put it anywhere
08:57:56 <atchoum> now that i'm using stack, should I totally discard cabal file ?
08:58:16 <dmwit> maerwald: I see. Then no, new-* doesn't have a way to do that as far as I know.
08:58:32 <dmwit> atchoum: nah
08:58:38 <dmwit> stack will use your cabal file.
08:58:40 <`Guest00000> only digits aren't enumerated
08:59:08 <cocreature> atchoum: you can either use a package.yaml file from which stack will automatically generate a cabal file or delete the package.yaml file (if you have one) and edit the cabal file directly
08:59:31 <maerwald> not confusing at all for a beginner to handle 3 tools :P
08:59:58 <dmwit> To be fair, we did say he could do it without cabal or stack, just start ghci from the directory with Mod1 and Mod2 in it.
09:01:47 <dmwit> ?hoogle Ord k => k -> Map k v -> (Maybe v, Map k v)
09:01:48 <lambdabot> FiniteMap insertList :: Ord key => [(key, elt)] -> Map key elt -> Map key elt
09:01:49 <lambdabot> Data.Map.Internal fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
09:01:49 <lambdabot> Data.Map.Lazy fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
09:03:37 <dmwit> I can sort of get what I want with updateLookupWithKey, but it seems kind of roundabout.
09:04:08 <dmwit> (I want to look up a key and delete it from the map in the same pass.0
09:08:30 <glguy> (\m k f -> m & at k %%~ \x -> (x, fmap f x)) :: Ord k => M.Map k v -> k -> (v -> v) -> (Maybe v, M.Map k v)
09:08:58 <glguy> containers has alterF now, which remembers the path from the lookup to do the insert
09:10:03 <glguy> :t M.alterF (\x -> (x,fmap ?f x)) ?k ?m
09:10:04 * hackage miconix-test 0.2 - Tests for the miconix sequencer library.  http://hackage.haskell.org/package/miconix-test-0.2 (demigod)
09:10:05 <lambdabot> (?m::M.Map k a, ?k::k, ?f::a -> a, Ord k) => (Maybe a, M.Map k a)
09:12:37 <dmwit> :t M.updateLookupWithKey (\_ _ -> Nothing) ?k ?m
09:12:38 <lambdabot> (?m::M.Map k a, ?k::k, Ord k) => (Maybe a, M.Map k a)
09:13:04 <glguy> The alter version also allows you to do things like handle missing elements and delete
09:13:20 <glguy> :t M.alterF (\x -> (x,Nothing)) ?k ?m
09:13:21 <lambdabot> (?m::M.Map k a, ?k::k, Ord k) => (Maybe a, M.Map k a)
09:13:43 * dmwit nods agreeably
09:14:53 <dmwit> alterF is pretty powerful.
09:15:18 * dmj` can’t find a paper :( 
09:16:09 <dmj`> Haskell SpriteKit — Transforming an Imperative Object-oriented API into a Purely Functional One, seems all of Chakravarty’s papers are now access forbidden, http://www.cse.unsw.edu.au/~chak/papers/CK17.html
09:20:01 <dmwit> Looks like Manuel's entire page there is 403'd. He'd probably want to know about that -- you should tweet at him or send him an email!
09:21:15 <dmwit> http://justtesting.org/ seems to be his new site, but it links to unsw for the research papers.
09:22:42 <Myrl-saki> Does stackage mean "stable hackage" or "stack hackage"
09:22:56 --- mode: glguy set +v panther99
09:22:57 <Athas> It predates stack, so the former I would say.
09:23:08 <Myrl-saki> Oh, thanks. TIL...
09:23:41 <Athas> dmwit: guess the UNSW is salty about him switching jobs!
09:24:51 <panther99> Hello everyone, I don't know if it's okay to ask this here; is it normal for haskell-ide-engine to take so much time to build? 
09:24:59 <Athas> panther99: yes.
09:30:36 <dmj`> dmwit: I’ll try tweeting to him
09:31:51 --- mode: glguy set +v panther99_
09:32:52 <MarcelineVQ> panther99, panther99_, Athas: Though one should determine how much time that is in case it's not so normal
09:34:08 <Athas> Sure.  Most, but not all Haskell-related questions can be answered with "yes, it's supposed to be that slow".
09:34:38 <MarcelineVQ> ehe
09:34:52 <c50a326> How can I make this MyList https://ptpb.pw/E1f0/hs so that I can consFoldR (+) over it? I've tried with (<>) lists of lists and it seems to work, would like to be able to consFoldR (+) though
09:35:10 <hololeap> is there a name for a data structure like this? `Cofree (Map k) v`
09:36:38 <hololeap> where you can lookup lists of type `[k]`
09:36:48 <dmwit> trie
09:37:15 <hololeap> oh, thanks dmwit. i've been using it a lot and i figured i couldn't be the first one to think of it
09:37:19 <dmwit> If you start vetting trie implementations on Hackage, watch out for path compression. Having it is good and makes a big difference.
09:38:14 <dmwit> Although I guess tries are closer to Cofree (Map k) (Maybe v).
09:39:58 <hololeap> doesn't the `Map k` imply a `Maybe v` result (at least if you are using `Map.lookup`)?
09:40:36 <hololeap> (a catamorphism using `Map.lookup`)
09:40:48 <dmwit> hololeap: Think about a trie that contains a value for "hello" but not one for "hell".
09:41:20 <hololeap> could it contain a value for both "hell" and "hello"??
09:43:34 * hackage alg 0.2.7.0 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.7.0 (MatthewFarkasDyck)
09:43:37 * hackage crypto-enigma 0.0.2.13 - An Enigma machine simulator with display.  http://hackage.haskell.org/package/crypto-enigma-0.0.2.13 (Orome)
09:43:38 * hackage mameya 0.2.1, mameya 0.2.0.1, mameya 0.2.0 (bururabit)
09:43:40 * hackage deptrack-dot 0.1.0.0, deptrack-devops 0.1.0.0, deptrack-core 0.1.0.0, grpc-etcd-client 0.1.2.0, grpc-api-etcd 0.2.0.0, http2-client-grpc 0.5.0.4 (LucasDiCioccio)
09:43:42 * hackage potoki-core 2.3.0.2, potoki-core 2.3.0.1, indexation 0.6.2.1, potoki 2.1, potoki-core 2.3 (NikitaVolkov)
09:43:45 * hackage xml-conduit 1.8.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.8.0.1 (koral)
09:43:47 * hackage aos-signature 0.1.0 - An implementation of the AOS signatures  http://hackage.haskell.org/package/aos-signature-0.1.0 (sdiehl)
09:43:48 * hackage set-of 0.1.0.1, set-of 0.1.0.0 (fresheyeball): https://qbin.io/bare-wish-7mb8
09:43:50 * hackage cloudi 1.7.4 - Haskell CloudI API  http://hackage.haskell.org/package/cloudi-1.7.4 (okeuday)
09:43:51 * hackage cdeps 0.1.1.8, hs2ats 0.3.0.4 (vmchale): https://qbin.io/israel-put-krp1
09:43:54 * hackage benchpress 0.2.2.11 - Micro-benchmarking with detailed statistics.  http://hackage.haskell.org/package/benchpress-0.2.2.11 (willsewell)
09:43:55 * hackage groundhog-th 0.9.0.1, groundhog-inspector 0.9.0 (BorisLykah): https://qbin.io/track-url-w4ns
09:43:58 * hackage vector-algorithms 0.8.0.0 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.8.0.0 (ErikDeCastroLopo)
09:44:00 * hackage follow 0.1.0.0 - Haskell library to follow content published on any subject.  http://hackage.haskell.org/package/follow-0.1.0.0 (cram1010)
09:44:02 * hackage boolector 0.0.0.7, boolector 0.0.0.6 (DeianStefan): https://qbin.io/op-again-l2sv
09:44:03 <Tuplanolla> Hackage storm!
09:44:03 * hackage stack-tag 0.2.0, dockerfile 0.2.0 (ChristopherReichert): https://qbin.io/china-types-oza3
09:44:06 * hackage wilton-ffi 0.3.0.3 - Haskell modules support for Wilton JavaScript runtime  http://hackage.haskell.org/package/wilton-ffi-0.3.0.3 (Wilton)
09:44:07 * hackage with 0.1.0 - Simple open product type  http://hackage.haskell.org/package/with-0.1.0 (iokasimovmt)
09:44:10 * hackage drifter-sqlite 0.1.0.0 - SQLite support for the drifter schema migraiton tool  http://hackage.haskell.org/package/drifter-sqlite-0.1.0.0 (MichaelXavier)
09:44:12 * hackage itcli 0.1.8.3 - Issue Tracker for the CLI  http://hackage.haskell.org/package/itcli-0.1.8.3 (theNerd247)
09:44:13 * hackage miconix-test 0.2, Oslo-Vectize 0.2, blunk-hask-tests 0.2 (demigod)
09:44:16 * hackage servant-auth-token 0.5.6.0 - Servant based API and server for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-0.5.6.0 (NCrashed)
09:44:17 * hackage haskoin-store 0.2.3, haskoin-store 0.2.2, haskoin-node 0.6.1 (xenog)
09:44:19 * hackage zephyr 0.2.0 - Zephyr tree shaking for PureScript Language  http://hackage.haskell.org/package/zephyr-0.2.0 (coot)
09:44:19 --- mode: glguy set +q hackage!*@*
09:44:41 <c50a326> How can I make this MyList https://ptpb.pw/E1f0/hs so that I can consFoldR (+) over it? I've tried with (<>) lists of lists and it seems to work, would like to be able to consFoldR (+) though
09:44:54 --- mode: glguy set -q hackage!*@*
09:45:22 <c_wraith> c50a326: that's...  not a foldr
09:45:29 <Athas> Busy day on Hackage!
09:45:42 <c_wraith> or the bot was just restarted. :)
09:45:52 <c_wraith> c50a326: that's a foldl
09:45:58 <c50a326> oh crap
09:46:06 <c50a326> well, s/R/L/g :p
09:46:13 <c_wraith> :)
09:46:39 <c_wraith> it should just work with (+).  how is it failing?  (If it's a compile error, can you add it to the paste?)
09:47:11 <c50a326> https://ptpb.pw/6d3F/hs
09:47:26 <hololeap> my particular implementation i've been playing around with is `Cofree (Map k) Bool`, so that at some level of the catamorphism, if your list ends it returns the Bool, but if `Map.lookup` returns nothing, it returns False
09:47:40 <c_wraith> c50a326: The problem there is that you made the base case of the addition an empty list
09:47:50 <c_wraith> c50a326: so the compiler is complaining that lists aren't numbers
09:48:03 <c_wraith> c50a326: try a different base case
09:48:07 <hololeap> but i guess Bool is a special case of Maybe x ... (Maybe ())
09:48:59 <c50a326> oh yeah my z is Empty lol
09:49:52 <c50a326> yeah works now, ty
09:52:12 <JohnnyL> Does one need to use all these fancy mathematical structures beyond learning Monads in haskell to program financials or games?
09:52:27 <c_wraith> JohnnyL: you never need them
09:52:35 <c_wraith> JohnnyL: but sometimes they let you share some code
09:52:51 <c_wraith> JohnnyL: or maybe let you separate concerns in a better way
09:54:10 <dmj`> JohnnyL: you’ll probably end up writing more FFI code than anything else if you want to write games or do finance.
09:54:24 <pzp> Is it possible to programmatically add a dependency to package.yaml when using Stack? 
09:55:16 <pzp> Something like `npm install --save`
09:55:27 <Tuplanolla> @hackage inline-c -- With this package, you never need to learn anything new, JohnnyL.
09:55:28 <lambdabot> http://hackage.haskell.org/package/inline-c -- With this package, you never need to learn anything new, JohnnyL.
09:56:05 <hololeap> you need the store comonad to program conway's game of life /sarc
09:56:42 <maerwald> pzp: you want stack to generate package.yaml and then run hpack to generate .cabal out of the generated yaml?
09:57:04 <hololeap> not really, but the fancy mathematical structures really can be helpful for lots of different problems
09:59:17 <pzp> maerwald: Not exactly. I am setting up automatic test infrastructure and would like to be able to generate a new stack project to test each upload. The problem is that the program being tested depends on HUnit and I am not sure how to add that as a dep without editing the package.yaml file manually.
10:01:02 <maerwald> pzp: https://hackage.haskell.org/package/hpack-0.31.0/docs/Hpack-Yaml.html
10:02:58 <dmj`> Tuplanolla: until you need C++ ...
10:03:42 <pzp> maerwald: That seems like overkill just to add a single line to package.yaml... are there no command line options I can use to do this?
10:04:06 <maerwald> echo?
10:04:13 <maerwald> sed
10:04:40 <maerwald> package.yaml is a file you are supposed to edit manually
10:05:03 <pzp> hmm yeah maybe sed could work
10:05:08 <pzp> I'll try that thanks for your help
10:08:48 <ben> quick q: how is foldl' pronounced?
10:09:00 <cocreature> ben: foldl prime
10:09:03 <ben> cool
10:09:05 <ben> cheers
10:09:15 <cocreature> or strict foldl
10:10:18 --- mode: glguy set +v zhaskell_
10:10:35 <zhaskell_> Is there a way to have stack build output to a custom directory called build?
10:11:03 <zhaskell_> As in output just the executable file
10:11:54 <atchoum> JohnnyL: part of the problem is that « fancy mathematical structures » are actually kind of machine gun/laser when the average programmer using for / while loop is stuck at stone age.
10:12:16 <atchoum> Unfortunately it forces the good programmer to be a bit of a mathematician, and that can be daunting at time.
10:12:23 <atchoum> Needs rigour and formalism and work.
10:12:54 <atchoum> How much does it make us better programmer is hard to tell.
10:13:27 <MarcelineVQ> zhaskell_: Yes, but it will likely complain.   stack --local-bin-path <the path> install hpack
10:13:36 <hexagoxel> TIL internet is a stone-age technology
10:13:45 <zhaskell_> Whats hpack for?
10:14:16 <MarcelineVQ> ah sorry, ignore hpack, it was leftover on my end ehe.  stack --local-bin-path <the path> install  is sufficient from within your project directory
10:14:35 <zhaskell_> Ok is there anyway to get the absolute path to the built executable when stack has no extra args
10:14:47 <zhaskell_> Because its complaining
10:15:02 <MarcelineVQ> you can also add this to your stack.yaml if you wanted it to be automatic, though you'd still need to use  stack install   or   stack build --copy-bins
10:15:37 <MarcelineVQ> the path to the directory, or to the executable?
10:15:56 <maerwald> https://hackage.haskell.org/package/directory-1.3.3.1/docs/System-Directory.html#v:getTemporaryDirectory this looks quite unsafe
10:16:07 <maerwald> it doesn't use P_tmpdir
10:16:19 <zhaskell_> the path to the executable
10:16:30 <zhaskell_> The end goal is to copy the executable into a docker container
10:16:42 <zhaskell_> As part of a build process
10:17:31 <MarcelineVQ> Then probably no, since stack can build multiple executables in one invocations afaik
10:18:04 <zhaskell_> ooh local-bin-path worked
10:18:09 <MarcelineVQ> but you can ask for the rdir of the build artifacts via    stack path --dist-dir
10:18:09 <zhaskell_> how do I add it to stack yaml
10:18:16 <atchoum> is there some kind of internal resistance in the Haskell community to move all the cabal only compatible package under the stack tool ?
10:19:05 <MarcelineVQ> you add  local-bin-path:  <the path>
10:19:08 <glguy> Yes, the community is resisting cabal files being trapped behind hpack format
10:19:27 <atchoum> One official build/dl/packaging tool is always a good thing.
10:19:32 * Clint squints.
10:19:46 <monochrom> Yes, and the official one is cabal. >:)
10:19:48 <maerwald> I want a tool to generate stack.yaml
10:19:53 <rotaerk> I don't really see what stack has to offer; I just use nix + cabal new-*
10:20:03 <zhaskell_> thanks
10:20:07 <rotaerk> and nix just resolves my non-haskell dependencies
10:20:09 <atchoum> are you sure of that ?
10:20:11 <zhaskell_> whats the difference between stack build and install
10:20:11 <MarcelineVQ> maerwald: given what as input?
10:20:12 <cocreature> atchoum: what is a “cabal only compatible package”?
10:20:13 <rotaerk> (and the haskell tools themselves)
10:20:19 <maerwald> MarcelineVQ: it should "just work"
10:20:34 <atchoum> I mean is the haskell community conservative about its package manager ?
10:20:36 <MarcelineVQ> but what is it working from
10:20:41 <MarcelineVQ> A cabal file?
10:20:45 <atchoum> The answer seems to be « yes » at some extent.
10:21:02 <maerwald> rotaerk: sure, but not everyone wants to spend time on learning the whole nix language, the oddities and bugs of nix packaging etc just so they can build a haskell project. It's effort
10:21:02 <MarcelineVQ> cause if you just want an lts you just go  echo "resolver: blah" > stack.yaml
10:21:16 <MarcelineVQ> maerwald: if you want a stack.yaml and have a cabal file  stack init   does this
10:21:26 <maerwald> MarcelineVQ: I'm just joking...
10:21:28 <MarcelineVQ> and stack init --solver does is better
10:21:43 <rotaerk> maerwald, what I use nix for is mostly optional; it just sets up my development environment in a way that's independent of my machine's global environment
10:21:52 <rotaerk> but you can resolve those dependencies manually
10:22:13 <rotaerk> once in my nix-shell, I let cabal resolve all my haskell packages
10:22:19 <maerwald> nix is a lot of work, because its configuration is not trivial
10:22:29 <maerwald> once you have the config working, it's nice, but it's effort
10:22:32 <rotaerk> I don't really see any value in the nixpkgs hackagePackages collection
10:23:07 <rotaerk> maerwald, this is the extent of my nix configuration: https://github.com/Rotaerk/vulkanTest/blob/sandbox/sandbox/shell.nix
10:23:12 <maerwald> I feel it's like telling someone to learn docker just to build their project ;) cabal should be enough
10:23:12 <cocreature> atchoum: I’d say the competition between stack and cabal is mostly healthy and has pushed both tools forward.
10:23:20 <rotaerk> cabal isn't enough
10:23:38 <cocreature> at least on a technical level, the resulting fights are definitely not healthy
10:23:40 <maerwald> I said *should*
10:24:23 <maerwald> but live is not always easy
10:24:26 <rotaerk> so that shell.nix is just providing me my requested version of ghc, cabal, ghcid, and vulkan-tools
10:24:40 <rotaerk> if you want to install those manually, fine, you can avoid nix
10:24:40 <atchoum> cocreature: I could have misinterpreted your sentence, but yeah, ok
10:24:59 <atchoum> I imagine both authoring community want to go to a 100%compatible ecosystem
10:25:15 <cocreature> atchoum: you can use packages created with cabal with stack and the other way around
10:25:43 <hexagoxel> rotaerk: can you recommend a particular up-to-date haskell+nix tutorial? the ones i recently tried all broke on trying the most basic first steps.
10:25:45 <rotaerk> (and a bunch of libraries)
10:25:47 <maerwald> sometimes I forget which tool generates what file
10:25:57 <MarcelineVQ> hexagoxel: you tried gabriels?
10:26:01 <hexagoxel> yes
10:26:11 <rotaerk> hexagoxel, not really.  I don't really agree with a lot of them
10:26:25 <zhaskell_> nix documentation is hostile to beginners
10:26:38 <rotaerk> you can read the nix, nixpkgs, and nixos manuals to learn, and nixpkgs does cover haskell somewhat
10:26:38 <MarcelineVQ> nix docs looked pretty great to me, there's just a shitload to learn.
10:26:41 <maerwald> nix documentation is just a mass of information, but nothing of it is concise :P
10:26:56 <rotaerk> but the nix documentation is *not* complete; sometimes you just have to dig into the nixpkgs source
10:26:57 <maerwald> good documentation is well structured
10:27:22 <cocreature> also often there are 5 different ways of doing the same thing and it is far from obvious what the most recent and recommended way is
10:27:32 <maerwald> yeah, with different quirks and bugs
10:27:53 <rotaerk> it *is* a pain to learn, although what I've settled on as an "ideal" usage of it doesn't actually require knowing a whole lot
10:28:11 <rotaerk> (ideal for haskell dev, that is)
10:28:23 <atchoum> is there anything close to hoogle but for java type signatures ?
10:28:31 <maerwald> imo, time-spent and value is not on the same level, unless you seriously use it for CI/CD
10:28:40 <zhaskell_> rotaerk: Thats a good principle for learning most things in computing
10:29:11 <maerwald> and then you want only one guy to do that and not be bothered
10:29:19 <rotaerk> I'm not speaking in principles or abstractions; I'm just saying that the concrete way in which I use it now doesn't depend on a whole lot of knowledge
10:29:30 <rotaerk> I used to use it in a much more complicated way but that doesn't buy me much
10:29:41 <maerwald> well, then your use of nix actually doesn't have a lot of pros!
10:29:54 <rotaerk> what do you mean?
10:30:04 <maerwald> the way people use it is to have a complete input specification of the environment
10:30:19 <maerwald> just to fire up ghc is a bit boring
10:30:38 <maerwald> I can just download it :)
10:30:41 <monochrom> You can say that to everyone who buys a Lego kit.
10:31:11 <rotaerk> this lets me have multiple co-existing projects, each of which are using different versions of GHC, different versions of non-haskell libraries, etc
10:31:11 <maerwald> people don't do lego these days anymore
10:31:16 <monochrom> Ideally everyone who buys a Lego kit builds both what's in the instruction manual and also what they think up themselves.
10:31:53 <monochrom> In practice most of the rest of us just build what's in the instruction manual and marvel at it and stop.
10:32:30 <rotaerk> the thing that I abandoned was using nix to actually build my project, which is not all that helpful
10:32:30 <monochrom> We are not getting the pros of it which is to unleash our creativity. But meh. You can't force us to do anything. It's my Lego kit.
10:33:12 * cocreature takes away monochrom’s lego kit
10:33:52 <monochrom> More ObCabally, there are a few programs I cabalize just because it's a better makefile.  I am not even packaging.  You can again say I'm not getting the pros of cabal.  But what can you do?
10:33:55 <atchoum> haha
10:34:00 <rotaerk> because nix-build is much slower than cabal-building, is complicated as hell to setup, much worse than cabal at resolving hackage packages, and might be using unexpected flags and such with cabal/ghc
10:34:38 <cocreature> monochrom: take away your makefiles!
10:34:39 <rotaerk> so for developing a project, setting up a nix shell seems to be the best usage for nix with haskell
10:34:50 <maerwald> Makefiles? The new toy is shake
10:35:01 <maerwald> makefiles are too simple and ordinary!
10:35:20 <monochrom> shake has too many dependencies.
10:35:36 <maerwald> that just means it's *powerful*
10:35:37 <maerwald> hehe
10:36:16 <dmj`> rotaerk: setting up a nix-build is very simple with cabal2nix and nixpkgs-unstable works well w/ linux
10:36:27 <rotaerk> nah
10:36:35 <dmj`> yah
10:36:40 <maerwald> deploying via nix sounds scary though, using for CI is ok, because of binary cache
10:36:42 <atchoum> is there any standard function that, from a given text, output the frequency of its characters ?
10:36:53 <rotaerk> cabal2nix is sufficient for creating a derivation for your haskell project, but resolving its dependencies is not so easy
10:36:57 <dmj`> maerwald: deploying via nix is fantastic
10:37:14 <dmj`> rotaerk: why not?
10:37:31 <rotaerk> because your project may depend on specific version ranges of other hackage packages, and nixpkgs's haskell packages are all just the latest versions
10:37:37 <dmj`> maerwald: binary cache will only work if the hashes produced by your pinned version of nixpkgs exist on the cached server
10:37:40 <rotaerk> (at least, the latest on hackage)
10:37:52 <maerwald> maerwald: erm, obviously
10:38:03 <dmj`> rotaerk: nixpkgs copies stackage
10:38:06 <rotaerk> sometimes you have to override the versions of nixpkgs by, say, pulling the source from github or something, or setting new flags
10:38:15 <maerwald> yes
10:38:17 <dmj`> rotaerk: that’s true of stackage as well
10:38:34 <maerwald> weird, when I moved to ghc-8.4 and fixed the stack config, nix was broken :)
10:38:49 <maerwald> took half a week to fix it
10:38:50 <monochrom> I would blame it on stack. :)
10:38:52 <rotaerk> I haven't used stackage, myself
10:39:12 <cocreature> atchoum: I don’t think there is a standard config but it’s a 2-3 line function (funnily enough, I was actually asked to write that function in an interview recently)
10:39:25 <rotaerk> I mean, compare this: https://github.com/Rotaerk/vulkanTest/blob/sandbox/sandbox/shell.nix
10:39:44 <rotaerk> to this: https://github.com/Rotaerk/vulkanTest/blob/sandbox/vulkan-tutorial/vulkan-tutorial.nix
10:39:54 <rotaerk> and the several other nix files side-by-side with that one
10:40:11 <atchoum> cocreature: haskell interview ?
10:40:20 <atchoum> what a lucky guy
10:40:41 <cocreature> atchoum: yep, haskell interview :)
10:41:50 <rotaerk> using nix-build isn't something you generally want to do with your own project; you only want a shell *anyway*
10:42:27 <maerwald> you mean you only want a shell :P
10:43:23 <atchoum> I think you can do that with Data.Map.alter
10:43:28 <atchoum> sounds complicated
10:43:34 <rotaerk> I mean, in the simpler case (first link) I'm directly building a shell; in the second case, I'm building a derivation that allows me to nix-build my entire project, which can then be trivially used to build a shell
10:43:41 <rotaerk> but the former was much simpler to do
10:44:04 <maerwald> nix is powerful but unhygienic
10:44:39 <maerwald> it's one of those tools I might silently use, but never advertise
10:46:25 <rotaerk> you also should use nix for the convenience of the dependency resolution, but should *not* make your project absolutely depend on it
10:46:29 <cocreature> atchoum: insertWith is sufficient
10:46:56 <rotaerk> so non-nix-users can build your project (if they resolve the dependencies through other means)
10:47:02 <maerwald> rotaerk: gnah, we already use everything, nix, stack, hpack, docker, shake, ...
10:47:23 <monochrom> Don't forget ant. ?:)
10:47:41 * rotaerk doesn't know anything about hpack or shake, and not much at all about docker.
10:48:16 <maerwald> hpack is the thing that stack silently bundles and executes :P
10:48:22 <rotaerk> oh
10:48:36 <maerwald> you are using package.yaml?
10:48:36 <ab9rf> i have "figure out how to use docker" as a to-do list item
10:48:48 <maerwald> ab9rf: copy paste Dockerfiles
10:49:09 <rotaerk> who are you asking about package.yaml?
10:49:16 <maerwald> rotaerk: you
10:49:20 <ab9rf> maerwald: i prefer to have some degree of understanding what the tool is doing before i use t
10:49:24 <rotaerk> no, isn't that a stack thing?
10:49:40 <rotaerk> I don't use stack; not sure what it has to offer over cabal new-* stuff
10:49:41 <zhaskell_> ab9rf: I got horrible build times inside Docker containers
10:49:48 <maerwald> ab9rf: but that's the thing, you don't have to understand much, the gotchas come later, the "language" is simple
10:49:55 <zhaskell_> try to build outside and then copy in the executable
10:50:34 <zhaskell_> ab9rf: Watch a docker tutorial on youtube and thats enough you need to know to use it
10:50:40 <maerwald> writing Dockerfiles is an effort of copy-paste and modify, occasionally looking up documentation. You don't have to sit down and fight through tons of documentation... unless... 
10:51:02 <ab9rf> zhaskell_: i hate youtube tutorials. i prefer to read stuff
10:51:19 <maerwald> you hit one of those weird quirks of docker while your volumes go crazy
10:51:21 <zhaskell_> ok read a tutorial and you are good to go
10:51:29 <maerwald> and you need to actually understand what docker does
10:51:30 <zhaskell_> docker networking ...
10:51:31 <maerwald> then you have fun
10:51:31 <zhaskell_> ugh
10:51:34 <ab9rf> yeah, i'm abot a third of the way through it
10:51:56 <ab9rf> why would it be diffucult? i've done virtual networking inside hypervisors before, why would it be any different?
10:52:20 <zhaskell_> I don't know about networking but its not intuitive with docker
10:52:27 <zhaskell_> youll be fine
10:53:02 <maerwald> docker network is also buggy and unreliable
10:53:19 <maerwald> fetching from ubuntu/debian mirrors occasionally fails with checksum errors
10:53:23 <maerwald> while it works fine on the bare host
10:53:45 <maerwald> there are probably 10+ issues with 300 comments about it on the issue tracker
10:53:50 <maerwald> don't bother reading them :P
10:54:15 <ab9rf> zhaskell_: i've been a network engineer for a decade :)
10:54:58 <zhaskell_> Thats hilarious I barely know the difference between a static and dynamic IP
10:55:13 <zhaskell_> Heres a question for you
10:55:22 <zhaskell_> whats the difference between a VPC and VPN
10:55:52 <ab9rf> it would be easier to list the ways that they're similar
10:55:58 <cocreature> here’s a question for you: what does that have to do with Haskell? if the answer is nothing move it to a different channel :)
10:56:04 <ab9rf> they both have "virtual" and "private" in the name :)
10:56:06 * Clint claps.
10:56:49 <monochrom> That's a cool answer to generally all "what's the difference" questions.
10:58:38 <zhaskell_> hehe
11:00:33 <zhaskell_> I read that template haskell shouldn't be used in production. Is this true?
11:00:43 <monochrom> Wow. No.
11:01:20 <monochrom> The Internet is full of crazy opinions. No?
11:01:35 <zhaskell_> Stephen Diehl's blog is where I read that
11:01:50 <zhaskell_> http://www.stephendiehl.com/posts/production.html
11:02:18 <glguy> You can't believe everything you read on the Internet
11:03:26 <rotaerk> haskell shouldn't be used in production; it's unsupportable.  use C and Perl
11:03:48 <rotaerk> s/C/C++
11:03:49 <zhaskell_> ok phew
11:05:15 <zhaskell_> Has anyone used Beam for connecting to Postgres?
11:05:45 <zhaskell_> I have used Persistent but was thinking of trying something new
11:05:56 <ab9rf> why would it be bad to use TH in production?
11:06:28 <ab9rf> TH code can be slow to compile but the resulting code is neither less efficient nor less safe than non-TH code
11:07:19 <zhaskell_> I think he cites long compile times and memory leaks
11:07:48 <zhaskell_> That is another fear lots of people have about Haskell in production. Memory leaks
11:07:48 <c_wraith> production is when long compile times don't matter.
11:08:03 <zhaskell_> haha exactly
11:09:39 <tdammers> the biggest issue with TH, IMO, is how it makes cross-compilation difficult by intermingling the build host with the target platform
11:10:19 <ab9rf> yeah, that is potentially a problem
11:11:11 <zhaskell_> tdammers: Whats the build host?
11:11:18 <zhaskell_> The os it was built on?
11:11:22 <tdammers> zhaskell_: the system that the build runs on
11:11:34 <zhaskell_> How can they be intermingled
11:11:40 <zhaskell_> is it not all just C code in the end
11:11:56 <tdammers> uhm, no. GHC hasn't been compiling via C for ages
11:11:58 <zhaskell_> I guess the issue is they make system calls
11:12:04 <tdammers> no, not really
11:12:17 <tdammers> you see, in order to expand TH, you need to actually run it, which means you need to compile it
11:12:20 <zhaskell_> so what happens when ghc compiles
11:12:32 <ab9rf> it's more that it's possible for achitectural constants to leak from the TH build environment into the app build environment
11:12:33 <tdammers> but the TH needs to run on the build host, whereas the final binary needs to run on the target platform
11:12:34 <zhaskell_> ah makes sense hence long builds
11:12:40 <zhaskell_> ah
11:12:55 <ab9rf> maybe maxbound Int is different on the target than the build
11:13:11 <ab9rf> that's just an example, there are endless possibilities
11:13:14 <zhaskell_> so try and keep dev and production environments to same os
11:13:26 <ab9rf> except you can't do that in many cases
11:13:34 <zhaskell_> why not
11:13:48 <ab9rf> you want to try to spin up a build environment for a microcontroller?
11:14:12 <zhaskell_> no thanks :P
11:14:17 <tdammers> mobile is another common example - you don't want iOS as your main driver on your dev workstation
11:14:32 <tdammers> (or consumer-grade android, for that matter)
11:14:48 <zhaskell_> cant you develop inside  a vm?
11:15:05 <tdammers> sometimes
11:15:13 <tdammers> in many cases, that's the easiest solution
11:15:29 <tdammers> but in the microcontroller or iOS cases, that's still not a great option
11:15:43 <Solonarv> sure, you can compile in a VM - but in other languages you don't need to do even that
11:16:23 <tdammers> Solonarv: point in case, in languages like Python or PHP, compilation happens on the target system almost by definition
11:16:54 <Solonarv> right, I was talking about compiled languages in the traditional sense
11:16:55 <zhaskell_> So an interpeter is a compiler that is running continously?
11:17:15 <zhaskell_> hence no host target disparity
11:17:16 --- mode: glguy set +v dataN
11:17:25 <ab9rf> zhaskell_: the lin between "interpreter" and "compiler" is a lot blurrier than your Intro CS teacher likely led you to believe
11:17:45 <zhaskell_> Is it like running compile in watch mode :D
11:18:07 <ab9rf> i annoyed my daughter with a 15-minute rant about that a few weeks ago (she is taking AP Computer Science in high school this term)
11:18:45 <Solonarv> many interpreted languages have an intermediate bytecode format, because it turns out text isn't a very efficient format to execute
11:18:58 <Solonarv> and then there's JIT, which muddies the waters further
11:19:07 <ab9rf> and some cimpilers compile to a byte code which is then compiler again at runtime
11:19:14 <ab9rf> is java interpreted or compiled?
11:19:24 <ab9rf> does it matter?
11:19:24 <c_wraith> sometimes it's compiled 3 times
11:19:26 <ab9rf> no :)
11:19:29 <zhaskell_> ab9rf - The stuff I learned in school was simplified to the point of being useless
11:19:41 <Solonarv> "is java interpreted or compiled" - yes ;)
11:20:20 <dmwit> If you think that there are no problems porting a Python program to a different architecture because Python is interpreted, I think you maybe haven't ported a Python program to another architecture.
11:20:29 <ab9rf> Solonarv: virtually all "interpreted" languages at least reduce the source to an IR of some sort
11:20:39 --- mode: glguy set +v telneter
11:21:04 * hackage activitypub 0.1.0.0 - ActivityPub Haskell Library  http://hackage.haskell.org/package/activitypub-0.1.0.0 (LukeHoersten)
11:21:10 <ab9rf> about the only ones that don't are shell languages like bash
11:21:19 <Solonarv> the source is compiled to JVM bytecode, which in turn is interpreted/JIT-compiled by the JVM (i.e. the 'java' executable)
11:22:05 <ab9rf> don't forget that on most processors, machine instructions are JIT-compiled to microcode :)
11:24:05 <dataN> why am I getting segfaults instead of runtime compile time errors?
11:24:59 <gentauro> dataN: runtime compile errors? What is that?
11:25:07 <ab9rf> what's a runtime compile error?
11:25:14 <gentauro> I thought you either had compile errors or runtime errors ...
11:25:20 <ab9rf> are you recursively invoking the compiler?
11:25:29 <dataN> reflection
11:25:32 <c_wraith> well, I guess you could link ghc into your program.
11:25:42 <ab9rf> c_wraith: i've seen people do that
11:25:49 <gentauro> reflection in HS?
11:25:50 <c_wraith> ab9rf: I've done it
11:25:51 <gentauro> :|
11:25:51 <ab9rf> c_wraith: usually for code analysis tools, though
11:26:10 <ab9rf> gentauro: it's theoretically possible to do, although it's no something people do often
11:26:11 <cocreature> dataN: you’re going to have to provide more details if you expect anyone to provide a useful answer
11:26:48 <dataN> it uses UnsafeCoerce and UnsafeCoerceConstraint to give local instances that can be generated by values 
11:26:48 <gentauro> ab9rf: you mean you could parse code right? Or are you speaking on reflecting a binary?
11:27:08 <cocreature> dataN: well unsafeCoerce is pretty much asking for a segfault
11:27:15 <cocreature> if you use it incorrectly
11:27:23 <cocreature> so I’m not sure what you’re expecting to happen instead
11:27:55 <dataN> that some time could be spent actually compiling at runtime instead of just giving the option to bypass the compiler to give runtime instances
11:28:03 <c_wraith> dataN: unsafeCoerce is promising the compiler that you're right, whatever it thinks.  So it doesn't generate errors.
11:28:26 <c_wraith> dataN: if you're wrong, it generates broken code.  Because you told it you're right.
11:28:32 <JohnnyL> dmj`, c_wraith: okay thanks!
11:28:49 <cocreature> if your cast is safe you can use "coerce" instead and GHC will check things for you
11:29:00 <ab9rf> if you make false promises to the compiler, you will get what you ask for
11:29:32 <cocreature> or if you want a runtime typecheck there are things like Typeable’s "cast"
11:29:34 * hackage shikensu 0.3.9 - Run a sequence of functions on in-memory representations of files  http://hackage.haskell.org/package/shikensu-0.3.9 (icidasset)
11:29:46 <dataN> not sure that reification can be implemented using coerce 
11:30:10 <ab9rf> oh, reification. i thought you said reflection before.
11:30:20 <dataN> same thing?
11:30:25 <JohnnyL> Tuplanolla: Very nice! Now we know that Haskell is more than a true systems language!
11:30:34 <ab9rf> not in any universe i inhabit
11:30:47 <ab9rf> sigh
11:30:50 <cocreature> ab9rf: well the package is called reflection
11:31:21 <cocreature> dataN: you are right that it cannot be implemented using coerce but I’m also not sure what runtime check you expect to be inserted here
11:31:35 <cocreature> there is no runtime type info that you could check
11:31:57 <ab9rf> haskell doesn't carry type info at runtime
11:32:17 --- mode: glguy set +v panther99
11:32:34 <dataN> maybe e.g. giving a Monoid instance parametrised by a value generated at runtime
11:32:40 <c_wraith> (except in cases where a Typeable constraint is required to be checked dynamically, but then you see it in the type of things that use it)
11:33:15 <dataN> heres something similar just for example https://gist.github.com/dataN-hs/18caf53bb6c97ef9a29e663e1e61baf8
11:33:23 <ab9rf> i need t spend more time exploring Typeable and such not
11:33:44 <c_wraith> ab9rf: it's actually really clever...  Now that you're not allowed to create your own instances.
11:33:52 <panther99> Hello everyone, it's me again... I installed haskell-ide-engine but I can't get it to work with VS Code. I added it to path (~/.profile) but I can't run it
11:34:11 <ab9rf> oh, this package. i was reading that paper just the other day
11:35:19 <dataN> "recode" being the funtion that could be used
11:35:28 <cocreature> ab9rf: the paper is pretty complicated iirc, the implementation is very simple. it just unsafe coerces to a function that accepts the constraint dictionary
11:35:36 <alanz> panther99, you need to add $HOME/.local/bin to your path (if on a linuxy machine)
11:36:21 <panther99> Nope, I'm on Mac. It's in /Users/nikola/.local/bin. I added it to ~/.profile but when I try to run hie it says that command is unknown
11:36:39 <panther99> export PATH=/Users/nikola/.local/bin
11:36:47 <cocreature> panther99: have you logged out and back in since you added the path?
11:37:02 <hpc> are you appending to PATH or overwriting it completely?
11:37:08 <panther99> Yes, I reopened iTerm
11:37:15 <ab9rf> you need to resource .profile, and you prob ably don't want to just replace PATH like that
11:37:29 <panther99> I'm adding to .profile directly
11:37:29 <ab9rf> you really want export PATH=/wh/er/ev/er:$PATH
11:37:31 <panther99> Via Vim
11:37:54 <cocreature> .profile isn’t reloaded everytime iirc, it’s only loaded in login shells
11:37:59 <panther99> Wait, I'll try it now
11:38:09 <ab9rf> i don't know macs
11:38:21 <ab9rf> on a linux system, .profile is only loaded for login shells
11:38:27 <ab9rf> non-login shells only load .bashrc
11:38:50 <monochrom> It is possible that on Mac every terminal window is a login shell.
11:38:59 <panther99> Nope, solution with $PATH doesn't work either.
11:39:38 <ab9rf> this is beyond my ken, i don't use pomes
11:39:48 <monochrom> It is also unwise to use ~ in PATH. Use $HOME instead.
11:40:03 <cocreature> panther99: alright, so open a new terminal and run "echo $PATH". is the path that you added in there?
11:40:22 <dmwit> It is fine to use ~ in PATH if you know your shell will expand it.
11:40:39 <c_wraith> I trust my shell to do everything it can to spite me
11:40:45 <monochrom> Yeah but that's more yak shaving.
11:41:04 <panther99> cocreature: no, it isn't
11:41:16 <dmwit> e.g. zsh expands ~ inside environment variable definitions.
11:41:27 <monochrom> Rebooting is the surest way. :)  (Also a sledgehammer.)
11:41:56 <monochrom> "Mac and zsh" is a very low-probability event.
11:41:59 <dmwit> monochrom: Did you hear the latest fun thing in Windows? "fast reboot", which is not labeled that but as "reboot", just hibernates briefly.
11:42:39 <dmwit> monochrom: /r/iiiiiiitttttttttttt have been having a blast with that one. People will honestly tell you "I rebooted this morning" and also have their computer report 30 days of uptime.
11:42:42 <cocreature> panther99: then my “log out and back in” advice applies :)
11:42:53 <monochrom> Heh. To be fair, many states don't survive hibernation so it does reset so states.
11:43:06 <dmwit> Many don't... and many do. =)
11:43:48 <panther99> Problem is solved; I just had to use set -U fish_user_paths /Users/nikola/.local/bin/ $fish_user_paths
11:43:59 <panther99> But thanks anyway
11:48:34 * hackage expressions 0.2 - Expressions and Formulae a la carte  http://hackage.haskell.org/package/expressions-0.2 (jakubdaniel)
11:48:54 <koala_man> hey, this Cabal issue is due to the host proxy settings or something, right? https://gist.github.com/koalaman/d93445b0d8abd803e11580b989a1a0a6
11:49:08 <koala_man> cabal: <socket: 10>: resource vanished
11:58:19 <ab9rf> dmwit: i hate fast reboot.
11:59:03 <ab9rf> "resource vanished"
11:59:06 <ab9rf> that's a great message
12:00:06 <glguy> I like a nice, slow reboot. I want to feel like something important is happening
12:00:27 <hpc> who needs fast reboot when you have 1000 day uptimes anyway
12:00:28 <ab9rf> koala_man: it means that something went wrong downloading something
12:00:48 <ab9rf> koala_man: it could be due to a proxy issue, or it could be due to something else
12:01:18 <dataN> Data.Typable.cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b
12:02:00 <hodapp> my reboots used to be much, much slower because I'd do silly things - like boot the system through some manual process involving me using GRUB commands to explicitly set root FS and kernel and then completely forgot to put these settings into the normal configuration file
12:02:20 <hodapp> and then go so long without a reboot that I forget what I did to boot in the first place
12:02:27 <monochrom> heh
12:02:49 <hodapp> I wish I were joking
12:03:33 <dataN> using2 :: forall p f a x. ReifiableConstraint2 p => Def2 p f -> (p f => x) -> x
12:03:49 <dataN> (not yet got a PolyKinded version...)
12:04:30 <dataN> and then Def2 is generated at runtime
12:04:38 <dataN> not sure how to use cast instead
12:05:11 <sclv> koala_man: if you can run cabal directly you can pass a verbosity flag to get more info or set a particular http transport known to work
12:05:23 <monochrom> Control.Exception shows typical use of cast.
12:06:38 <hodapp> dataN: re: "these kinds of stochastic methods that perform well far from the optimal setting are difficult to reason about algebraically" - when it comes to performance over real data I am unaware of any sort of formal tests that predict anything about optimality, aside from things like PAC correctness, VC dimensions, and Rademacher complexity which prove only very pessimistic bounds
12:06:40 <dataN> maybe it would be used to rewrite reify?
12:07:19 <cocreature> dataN: without a Typeable constraint somewhere there is no chance of using cast
12:07:58 <hodapp> so in cases like that where the problem isn't well-defined formally (say, object recognition tests from real imagery), it's hard to justify that they perform "far from optimal"
12:08:12 <dataN> hmm, so that would replace Def2?
12:09:08 <monochrom> \∩/ PAC
12:09:28 <hodapp> monochrom: you've worked with the Probably Approximately Correct framework?
12:09:53 <dataN> referring to;http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Typeable.Internal.html#TypeRep
12:10:17 <monochrom> Naw. But I'm interested and I'm reading Valiant's layperson book.
12:10:54 <hodapp> what book's that?
12:11:58 <monochrom> "Probably Approximately Correct: Nature's Algorithms for Learning and Prospering in a Complex World"
12:12:14 <hodapp> huh
12:13:45 <hodapp> the theorem to prove the performance of boosting under certain constraints is pretty fascinating too
12:14:58 <dataN> hodapp: right, bounds are usually surpassed. the idea of being "far from optimal setting" (in the cases such as "perfect reconstruction" of a sparse signal using few projections) is that the bounds that can be proven become increasingly poorly representative of the realistic performance as the conditions such as the restricted isometry property holding are deviated from 
12:16:31 <hodapp> dataN: but how does any of this apply to the sorts of things that, for instance, convnets or even xgboost (both stochastic methods) are commonly used on?
12:16:53 <dataN> hodapp: a good example of a common application is matrix completion 
12:18:22 <dataN> where both compressed sensing and ML algorithms perform well, and the former has provable bounds.
12:19:28 <dataN> sorry, this may be the case for the latter, but it would take some research to find those references 
12:20:04 * hackage expressions-z3 0.2 - Encode and Decode expressions from Z3 ASTs  http://hackage.haskell.org/package/expressions-z3-0.2 (jakubdaniel)
12:21:51 <ab9rf> i still remember someone who came up with a really complex ML algorithm that was supposed to detect "rudeness" that was basically just a fuck/shit/piss detector
12:22:20 <ab9rf> google spent quite a bit of money on that and got nothing out of it
12:23:03 <dataN> hodapp: a quick search finds this; https://arxiv.org/abs/1605.07221 but its something that would need more time for a discussion 
12:27:55 <hodapp> dataN: I did some work in matrix completion for recommender systems via a few stochastic algorithms at https://hodapple.com/blag/posts/2018-04-08-recommender-systems-1.html and would be curious for a utility matrix on the order of 100,000 x 100,000 what compressed sensing algorithms here both are scalable and have guaranteed bounds
13:20:17 <dukedave> Could anyone suggest what the single quotes (e.g. in 'D)  in this type signature are for? https://github.com/LumiGuide/haskell-opencv/blob/master/opencv-examples/src/face-detect.hs#L53
13:20:36 <EvanR> look up DataKinds in the GHC manual
13:20:57 <dukedave> EvanR: thanks!
13:21:26 <EvanR> 'D disambiguates between D the constructor and D the type that datakinds produces
13:22:07 <EvanR> if you need to, sometimes it obvious by context
13:23:23 <dukedave> EvanR: ah, therein probably lies the answer to my follow up question, which was going to be, "because it doesn't seem to matter if I remove them?" XD
13:23:38 <EvanR> yeah
13:24:20 <EvanR> you can't put regular constructors into a type signature
13:24:52 <EvanR> so on line 53 it knows that D and S are types
13:32:09 <monochrom> Now I see how DataKinds can mislead the OOP-minded to think that it means suddenly each data constructor becomes a subtype.
13:34:28 <EvanR> D the type is a subtype of D the value... or er what
13:34:57 <EvanR> everything is a class *slams the door*
13:35:12 <monochrom> Naw, the other way round. If "data X = C1 Int | C2 Bool", the OOP-minded really want to believe that C1 and C2 are subtypes of X.
13:35:47 <monochrom> So previously we have been able to refute that with "but C1 is a term not a type".
13:36:28 <monochrom> By now DataKinds says that C1 is a type, too. Albeit completely unrelated to type X.
13:36:59 <EvanR> you are truly evil for coming up with this interpretation
13:37:04 <monochrom> But of course human nature being what it is, it wants to ignore the "albeit unrelated" part.
13:37:04 <EvanR> it didn't need to exist
13:37:46 --- mode: glguy set +v anon
13:38:06 <monochrom> I'm saying that people are going to come up with it indepedently.
13:38:31 <monochrom> In fact I'm inspired by "<EvanR> you can't put regular constructors into a type signature"
13:41:12 <dukedave> I'm going to go ahead and ignore that until I've finished reading http://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html, right?: )
13:41:26 <Guest82515> Anyone have an example of how the reflectRecFold function in superrecords is supposed to be used?
13:43:19 <fool> https://github.com/elijahbal/99-questions
13:45:13 <monochrom> dukedave: I think https://aphyr.com/posts/342-typing-the-technical-interview is more funny. :)
13:45:25 <dmwit> monochrom: Get inspired by "put regular constructors into a type signature" another way: https://hackage.haskell.org/package/regex-type
13:46:13 <monochrom> Haha the creativity of humanity is boundless.
13:47:46 <monochrom> Or maybe it's the depravity of humanity.
13:50:45 <monochrom> I consider the following two to be equivalent: 1. Someone learned that in C you could do "struct X { int i; char[0] extra; };" "malloc(sizeof(X) + 200)" and went crazy on subclassing in C.  2. Someone learned GHC extensions and went crazy on universal Turing machines and lambda calculus at the type level.
13:53:38 <ancarda> Can someone help me setup code coverage with Stack? The docs mention having both `src` and `test` can be problematic, but removing `src` will cause my tests to fail to compile as it tries to build the library but can't find the internal modules the library's surface module depends on
13:53:50 <hpc> monochrom: i wouldn't have hired that guy because he forgot about DataKinds
13:53:52 <hpc> :D
13:54:00 <monochrom> Haha
13:56:30 <geekosaur> ancarda, you generally want to expose things like that as internals modules, not build them again a second time. different inlining can potentially lead to problems otherwise.
13:57:28 <fool> "<monochrom> I consider the following two to be equivalent: 1. Someone learned that in C you could do "struct X { int i; char[0] extra; };" "malloc(sizeof(X) + 200)" and went crazy on subclassing in C.  2. Someone learned GHC extensions and went crazy on universal Turing machines and lambda calculus at the type level." <- can you prove it ?
13:57:33 <geekosaur> (cross-module inlining is a thing for performance but means you can't trust the binary forms of recompiled modules to be the same every time)
13:58:12 <ancarda> geekosaur: Sorry, I'm not following -- are you saying I should export all modules of the library? Even those that are internal and contain messy implementation details?
13:58:48 <geekosaur> if you need to reference them from the test suite, yes. Otherwise, cme up with a testing API you can export
13:59:07 <geekosaur> or move the internals tests into the library
14:01:24 <ancarda> How can I do the latter (move the tests into the library)?
14:08:23 <dataN> hodapp: not sure what factors influence the ability to work with such large matrices, but perhaps a comparison of CS algorithms would help choose the most appropriate, and under what conditions the restricted isometry property holds 
14:10:08 <geekosaur> ancarda, … it's your library. I assume you know it well enough to be able to do that; I don't
14:11:06 <geekosaur> or if you were asking me to organize for you, that doesn't quite work either
14:11:35 --- mode: glguy set +v dataN_
14:12:13 <dataN_> its easiest to understand as the truncated spectral decomposition of a sparse matrix  
14:12:41 <ancarda> geekosaur: I was asking how one would do that. I don't know Haskell very well
14:13:55 <dataN_> repeated projection onto an updated approximate support leads to the iterative hard thresholding family of algorithms
14:16:41 <geekosaur> this isn't about haskell, it's about library design
14:17:31 <Solonarv> you could do something like this, if you really want to: https://gist.github.com/Solonarv/fdc472450ea20a18a93ba438c5a5995b
14:17:47 <dataN_> im not sure what hodapp was getting at, but it started as a discussion about linear algebra in haskell
14:18:40 <dyamon> hi guys...I was here a couple of days ago asking about `coerce` and its use in the Functor instantiation of Identity. Now all the representation equivalence is clear but I still have a question. If in Identity `fmap = coerce` why does it turn `(a -> b)` in `Identity a -> Identity b` and not `Identity (a -> b)`?
14:19:02 <ancarda> Solonarv: Thanks, that looks promising!
14:20:10 <Solonarv> dyamon: coerce is polymorphic; coerce (f :: a -> b) can be Identity (a -> b), but it can also be (Identity a -> Identity b)
14:20:12 <dmwit> dyamon: If `f :: a -> b`, then `coerce f` can indeed be given both types `Identity a -> Identity b` and `Identity (a -> b)`.
14:20:41 <dmwit> dyamon: The type signature for `fmap` (in the definition of the `Functor` class) disambiguates between which is needed.
14:20:45 <dmwit> ?src Functor
14:20:45 <lambdabot> class Functor f where
14:20:45 <lambdabot>     fmap :: (a -> b) -> f a -> f b
14:22:43 <dmwit> dyamon: Or, more to the point: if `w` and `x` have the same representation, and `y` and `z` have the same representation, then `w -> y` and `x -> z` have the same representation.
14:23:17 <dmwit> dyamon: So since `a` and `Identity a` have the same representation and `b` and `Identity b` have the same representation, it follows that `a -> b` and `Identity a -> Identity b` have the same representation.
14:23:56 <dyamon> dmwit: which is the same as Identity (a -> b) right?
14:24:04 <dmwit> Sure.
14:24:14 <dmwit> Same representation, anyway.
14:24:23 <dmwit> Not same in the eyes of the type-checker, of course. =)
14:24:39 <dmwit> The type checker hallucinates many distinctions that don't exist at runtime.
14:25:09 <dmwit> The poor thing even thinks Int and Ptr () are different. =)
14:25:45 <Solonarv> well, they *are* different on some platforms, no?
14:25:59 <dmwit> Perhaps. And they're the same on some, too.
14:26:13 <dyamon> dmwit: this leaves me a bit confused... they are not equivalent when it comes to math, right?
14:26:39 <dmwit> E_TOOVAGUE
14:26:47 <Solonarv> depends on your definition of "equivalent"
14:27:19 <dmwit> (What does "not equivalent when it comes to math" mean?)
14:27:29 <dyamon> sure... sorry, my knowledge in category theory is still at an apprentice level
14:28:48 <ab9rf> equivalence is what you make of it
14:29:13 <dataN_> hodapp: I think this is what you want; https://people.maths.ox.ac.uk/tanner/papers/BlTaWe_cgiht.pdf
14:30:15 <dyamon> Let's make tiny steps. If I look at Identity (a -> b), I'm looking at a morphism in the subcategory Identity of Husk...is it somewhat correct?
14:30:23 <dyamon> *Hask
14:30:31 <dmwit> No.
14:30:33 <ab9rf> corn husk
14:30:44 <dyamon> dmwit: sweet
14:30:49 <dmwit> Morphisms in the Identity subcategory are arrows from objects in the subcategory to objects in the subcategory.
14:30:58 <dmwit> All the objects are of the form `Identity X` for some `X`.
14:31:08 <ab9rf> this is where i always get lost
14:31:11 <dmwit> So arrows in the Identity subcategory have types like `Identity X -> Identity Y`.
14:31:14 <dyamon> so it is Identity a -> Identity b
14:31:18 <dmwit> right
14:31:19 <dyamon> ok got iy
14:31:59 <dyamon> but then Identity (a -> b) is just another object
14:32:23 <dmwit> Well. So one fix is to say, "If I look at [Identity a -> Identity b], I'm looking at a morphism in the Identity subcategory.". Another fix is to say, "If I look at Identity (a -> b), I'm looking at [an object] in the Identity subcategory.".
14:32:30 <dmwit> dyamon: right, exactly
14:34:18 <dmwit> (It is good to remember this principle when looking at GHC type errors, too: type errors are a mismatch between two things, and you can change either one or both. GHC is *pretty good* at picking the one it makes more sense to change, but...)
14:37:03 <dukedave> R.e. `DataKinds`: I get that when I `data Nat = Zero` I also get a `'Zero` with kind `Nat`, but: Is there be a way to define `'Zero` (and kind `Nat`) without also defining the `Nat` type and `Zero` function (i.e. the way `DataKinds` does it)?
14:37:29 <glguy> dukedave: That feature is in discussion, but not in GHC yet
14:38:12 <dukedave> glguy: Okay cool. If my question makes enough sense to have an answer, then I'll assume I'm not too far off on my understanding :D
14:38:50 <dmwit> Can you get halfway there by just not exporting the type Nat and the data constructor Zero?
14:39:38 <glguy> dmwit: To do that you have to make type synonyms like on Crucible
14:39:49 <glguy> It's makes a bit of a mess and the haddocks pay for it
14:40:16 <dmwit> bummer
14:41:34 <infinity0> i'm trying to unify two type-level trees, by defining an additional parameter that captures their "structure", to be unified. it's not working though:
14:41:35 <infinity0> https://repl.it/repls/RawExhaustedArray
14:41:36 <dyamon> dmwit: but then is there any relation between `Idenitity a -> Identity b` and `Identity (a -> b)`? Why the type system is able to choose between the two just like that? Or is it just applying `coerce` as much as it can going  `a -> b`, `Identity (a -> b)` and finally `Identity a -> Identity b` which happens to be what it needs to typecheck correctly?
14:42:17 <infinity0> "Could not deduce: xs ~ 'TLeafS from the context: (ss ~ 'TLeaf, rs ~ 'TLeafS)" -- shouldn't this be inferrable from the definition of HTreeS ?
14:42:31 <infinity0> TLeaf only appears on the RHS of one constructor
14:42:32 <aarvar> dmwit: "All the objects are of the form `Identity X` for some `X`"
14:42:42 <aarvar> this doesn't really make sense, does it?
14:44:45 <glguy> aarvar: When you're making an instance of Functor, the quantified type of fmap is fixed
14:44:58 <aarvar> you could have a category where the objects are types and a morphism from A to B is a function `Identity A -> Identity B`, but `Identity A` wouldn't be the object, `A` would be
14:45:05 <glguy> so type inference tells us what type coerce should take on
14:46:11 <dmwit> aarvar: I can have whatever collection of objects I want, so long as I obey the identity/composition laws.
14:46:41 <dmwit> dyamon: No, there are not two applications of `coerce`, just one.
14:47:13 <dmwit> dyamon: However, it *does* know both the type it's starting from and the type it needs to get to, and there *is* a fairly sophisticated search process to make sure that the two are actually coercible.
14:47:18 <aarvar> dmwit: well, you'd generally have a type of objects, wouldn't you?
14:47:28 <dmwit> dyamon: The paper has the full details on how the search proceeds.
14:47:45 <dmwit> aarvar: Dunno. Depends what you mean by "type".
14:48:18 <dmwit> aarvar: Probably no, for most sensible meanings of "type" I can think of.
14:49:41 <dmwit> e.g. most of the objects in CAT don't correspond in any sensible way with a Haskell type.
14:49:50 <aarvar> dmwit: well, you can define a category as consisting of a type of objects, Obj : Type, and for every two objects a type of morphisms, Hom : Obj -> Obj -> Type, and so on
14:50:49 <dmwit> I think category theorists try to avoid specifying exactly what theory is used to describe objects. Type theory is one way, but set theory is fine, as is category theory itself.
14:52:08 <dmwit> But we're divering a bit, I think, since it's not my real objection to your objection.
14:52:20 <dmwit> I'm just as happy choosing my collection of objects to be a collection in type theory if you want.
14:52:48 <dmwit> My stance of "I can have whatever collection of objects I want, including the collection that only contains types of the form Identity X for some X" stands.
14:54:36 <dmwit> dyamon: I guess your misunderstanding is basically this: you are thinking that the only thing that `coerce` can do is wrap or unwrap an outermost layer of newtyping.
14:54:54 <aarvar> I mean, if we wanted to compose arrows of the form `Identity a -> Identity b`, we might define `type IdentityMorphism a b = Identity a -> Identity b` and `compose :: IdentityMorphism b c -> IdentityMorphism a b -> IdentityMorphism a c`
14:55:08 <dmwit> dyamon: But that's incorrect. `coerce` can reach arbitrarily "deep" into a type to do its wrapping and unwrapping, and can do arbitrarily many kinds of wrapping and unwrapping at once.
14:55:16 <aarvar> and then the objects are clearly `a` `b` and `c`, not `Identity a`, `Identity b`, and `Identity c`
14:56:15 <dmwit> dyamon: If you wanted, you could `coerce :: (Sum a -> All -> (Identity b, c)) -> a -> Bool -> (b, Identity (Identity (Identity c)))`.
14:57:38 <dmwit> aarvar: No, I define `type IdentityMorphism (Identity a) (Identity b) = Identity a -> Identity b`. After all, all my objects have the form `Identity X`, so this is fine and not partial.
14:59:39 <dmwit> > filter id $ coerce [Any True, Any False, Any False, Any True]
14:59:41 <lambdabot>  error:
14:59:41 <lambdabot>      • Variable not in scope: coerce :: [Any] -> [Bool]
14:59:41 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
14:59:45 <dmwit> % filter id $ coerce [Any True, Any False, Any False, Any True]
14:59:46 <yahb> dmwit: [True,True]
15:00:05 <aarvar> I guess you could define the type of objects as Σ(A : Type). Σ(B : Type). A = Identity B
15:00:09 <dmwit> dyamon: ^ an example of not just unwrapping a top-level newtype wrapper
15:00:17 <aarvar> but I think that's just equivalent to Type...
15:01:02 <dmwit> huh?
15:01:07 <dmwit> Why are you making this so complicated??
15:02:16 <aarvar> well, that's how you would define the subset of types A which are equal to Identity B for some type B
15:02:38 <dataN_> showP :: forall p n. Show n => p n -> String
15:03:25 <dataN_> with TypeApplications can this proxy type be shown?
15:04:08 <dmwit> ?free showP :: (n -> String) -> p n -> String
15:04:09 <lambdabot> Extra stuff at end of line
15:05:14 <infinity0> i managed to simplify the example down to 4-5 lines, could someone take a look? https://repl.it/repls/RawExhaustedArray
15:05:21 <dataN_> it needs the forall for TypeApplications..
15:05:43 <dmwit> dataN_: Anyway, all functions of this type are going to be either undefined or ignore their first argument entirely.
15:06:09 <dmwit> dataN_: You can of course show a `Proxy n`. This also ignores the proxy entirely, by coincidence. =)
15:06:36 <dataN_> right, thats why its forall p, its like proxy, thats how to pass around these types
15:06:56 <dmwit> Okay. Once again I have failed to understand your question.
15:07:20 <dmwit> Let's start here: are you trying to implement a function named `showP` with the type you stated above?
15:07:54 <dataN_> yes, and the body of the function would be something like (show (undefined :: n)) /
15:08:00 <dataN_> but thats confusing 
15:09:04 <dataN_> maybe it needs a instance for forall p. Show a => Show (p a)
15:09:27 <dmwit> Can you describe what you are hoping this function will do for you?
15:10:08 <dataN_> show a type?
15:10:56 <dmwit> ah!
15:11:02 <dmwit> Okay, then you probably want a Typeable constraint.
15:11:42 <dmwit> :t show . typeRep
15:11:43 <lambdabot> forall k (a :: k) (proxy :: k -> *). Typeable a => proxy a -> String
15:12:00 <dmwit> > show . typeRep $ [()]
15:12:02 <lambdabot>  "()"
15:12:08 <dmwit> > show . typeRep $ [64]
15:12:11 <lambdabot>  "Integer"
15:13:34 <dmwit> infinity0: The caller of `y`, not the implementor, gets to choose `xs`.
15:13:57 <glguy> shapr: Yay, you're doing Exapunks :)
15:15:06 <dmwit> infinity0: If I choose `y :: HTree_ TLeafS -> HTreeS {- something that isn't obviously TLeaf -} TLeafS`, then `x` isn't a suitable return value.
15:15:41 <shapr> glguy: doing sound synthesis on an FPGA today, fighting my lack of knowledge of verilog
15:16:08 <shapr> glguy: but yeah, if I ever get spare time again, I'll finish exapunks
15:16:31 <infinity0> dmwit: right that's what i don't get, by the definition of HTreeS it is obvious though - the only way to get HTreeS _ TLeafS is if _ is TLeaf
15:16:48 <dataN_> dmwit: there is; http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Typeable.Internal.html#showTypeable
15:16:49 <dmwit> infinity0: There is always Any. =)
15:16:56 <dataN_> but this does not use the Show instance for n
15:17:01 <dmwit> infinity0: (A sort of type-level undefined which inhabits every kind and is distinct from every type.)
15:17:18 <dmwit> dataN_: How can it? There's no values of type `n`.
15:17:30 <dmwit> At least not necessarily.
15:18:01 <infinity0> hm, so what's the best way to express "xs has to have same structure as ss"
15:18:06 <dataN_> n :: Nat btw
15:18:36 <dmwit> dataN_: Even worse. There are no terms (not even `undefined`) whose type is classified by Nat. =)
15:18:52 <dataN_> so is there a Show instance for Show n => Proxy n ?
15:18:59 <dmwit> infinity0: A type family which translates from one to the other.
15:19:06 <dmwit> dataN_: yes
15:19:20 <dataN_> which uses Typable?
15:19:23 <dmwit> dataN_: In fact, there is a Show instance for Proxy n which doesn't require anything special about n. =)
15:19:35 <dmwit> No, it does not use Typeable. Or else you would see Typeable in the constraints.
15:20:01 <dataN_> hmm, so why cant there be a show instance forall p a. (p a) ?
15:20:27 <infinity0> dmwit: ok i'll try that, thanks
15:20:30 <dmwit> Parametricity prevents you from observing anything about values classified by type variables.
15:20:50 <dataN_> so I should use Proxy and not p?
15:21:23 <dmwit> "Should" is hard. It depends on what you want to achieve. I doubt using `Proxy`'s `Show` instance will achieve what you want, but I have a history of being bad at predicting what you want.
15:21:29 <dataN_> or add a 'Show (p a)' constraint?
15:22:40 <dmwit> How about you give a few example input/output pairs.
15:23:56 <dataN_> showP (Proxy Z) = "Proxy Z",showP (Proxy (S Z)) = "Proxy (S Z)", and similarly for 'p' in place of 'Proxy'
15:24:16 <dataN_> depending on the Show instance for some 'p'
15:24:21 <dmwit> The `Proxy` data constructor does not take any arguments.
15:24:33 <dataN_> Proxy :: Proxy Z
15:24:49 <dmwit> % data Peano = Z | S Peano
15:24:50 <yahb> dmwit: 
15:25:02 <dmwit> % show . typeRep $ (Proxy :: Proxy Z)
15:25:02 <yahb> dmwit: "'Z"
15:25:07 <dmwit> % show . typeRep $ (Proxy :: Proxy (S Z))
15:25:07 <yahb> dmwit: "'S 'Z"
15:25:09 <dmwit> done
15:25:30 <c50a326> Parser a -> (a -> Parser b) -> Parser b -- if the first argument (Parser a) is p and the second argument (a -> Parser b) is f, then applying Parser a to an input string gives [(a, String)], applying f gives [Parser b] and I want to return just `Parser b` ... How should this behave? Apply each element of [Parser b] to parse each of the String part of the list returned by running Parser a?
15:25:31 <dataN_> (showP :: (Proxy (n :: N))) (Proxy :: Proxy Z) = "Proxy Z"
15:25:36 <dmwit> % show . typeRep $ (undefined :: p (S Z)) -- just to prove it ain't Proxy-specific
15:25:36 <yahb> dmwit: "'S 'Z"
15:26:09 <dmwit> c50a326: You have a thinko.
15:26:24 <dmwit> c50a326: You say, "applying f gives [Parser b]". My question is: applying `f` to *what*, exactly?
15:26:47 <c50a326> to each a in [(a, String)] from the running of the `Parser a` on the input string
15:27:11 <dmwit> Then you have a [(Parser b, String)].
15:27:17 <dmwit> That's a pretty nice type to have...
15:27:23 <dataN_> dmwit: but what if the Show instance for (S Z) was "One"... the Typable version wouldnt work
15:27:53 <c50a326> dmwit: should we just return the `Parser b` from the first element?
15:27:54 <dmwit> dataN_: S Z doesn't have a Show instance, and can't. It doesn't have the right kind to have a Show instance.
15:28:30 <dmwit> c50a326: Depends exactly what you want. But what *I* would want is to run each Parser b on the String it's paired up with, and get all the results from all of them.
15:29:45 <dataN_> show :: N -> String
15:31:41 <dataN_> fromN :: N -> Int; fromN Z = 0; fromN (S n) = succ (fromN n), instance Show N where  show  = show . fromN
15:31:51 <infinity0> dmwit: not sure what you meant. if i define a type family from Tree to TreeS i get the same error about "could not deduce", OTOH if i define a type family from TreeS to Tree i get an extra type variable on the RHS i don't know what to do with..
15:32:06 <infinity0> i also tried doing it with a typeclass similar to HList's "SameLength'" but that didn't work either..
15:33:44 <dataN_> but that should have been clear from wanting it to use the Show instance of the proxied type
15:35:04 <dmwit> infinity0: `type family FromS x where FromS TLeafS = TLeaf; y :: HTree_ ss -> HTreeS (FromS ss) ss` works for me.
15:37:01 <infinity0> ahhh ok didn't know about the :: syntax, i was doing FromS (TNodeS ls rs) = TNode a (FromS ls) (FromS rs)
15:37:02 <dmwit> dataN_: Okay. I think I understand what you want. You'll need to make a class to lower your type-level expression to a computation-level one; e.g. `class Lower (n :: Peano) where lower :: p n -> Int` with instances for `Z` and `Lower n => Lower (S n)`.
15:37:11 <infinity0> then ofc ghc complains about the a on the RHS
15:37:15 <infinity0> great, thanks!
15:38:26 <dmwit> infinity0: uh, just to be clear, the `y :: ...` is not part of the type family's `where` block.
15:38:35 <dmwit> It's part of the top-level module's `where` block.
15:39:14 <infinity0> oh, sorry. yes my "real example" is bigger and defines the binary Node part of it as well
15:39:51 <dmwit> I'm pretty sure we're talking past each other. But if you have got the idea and it's working for you, I'm just as happy not to clear things up.
15:40:45 <c50a326> dmwit: like this? https://ptpb.pw/_RiA/hs
15:41:27 <dmwit> c50a326: yeah!
15:41:30 <dmwit> c50a326++
15:41:49 <infinity0> dmwit: i haven't got a solution yet, it sounds like what i want to do is impossible with this approach, even in your solution for the simple case you're getting rid of the xs type param
15:42:02 <infinity0> but nvmd i'll think about what you said about Any and maybe will figure it out later
15:42:13 <dmwit> infinity0: Not getting rid of it. Just computing it from `ss`.
15:42:28 <dmwit> You want the two parameters to be linked, right? `FromS` gives the link.
15:42:38 <dmwit> You can also go the other direction, of course.
15:42:44 <infinity0> in my "real example" the xs contains extra information than ss, and i can't define that extra information on the RHS of a type family
15:44:35 <infinity0> hm let me try the other way round though
15:45:45 <infinity0> yeah, the other way around doesn't work, same error :(
15:45:59 <dataN_> dmwit: https://pastebin.com/3jK4CBQr
15:46:32 <infinity0> https://repl.it/repls/DarkorangeSpotlessPhysics
15:50:01 <dmwit> infinity0: Yeah, okay, I think I'm convinced now that you're going to have to wrap this in an existential.
15:50:41 <dmwit> Which... actually seems kind of right?
15:51:03 <dmwit> Since `ss` doesn't determine `xs`, you don't get to return just any `xs` you want -- the implementor has to be in charge of choosing one.
15:51:33 <dmwit> ah!
15:51:35 <dmwit> I have an idea.
15:52:15 <infinity0> the overall thing i was trying to do was to use ss to constraint two (HTreeS xs ss) and (HTreeS ys ss)
15:53:20 <infinity0> one of them being a input param, the other being the output
15:54:04 <dmwit> infinity0: https://gist.github.com/dmwit/ec5ac46d00dbf8ed3e70bdac7c090556
15:56:06 <dmwit> infinity0: But why do you need `y` for that? Can't you leave the `ss` argument off of `HTreeS` entirely and just write `foo :: ToS xs ~ ToS ys => HTreeS xs -> HTreeS ys -> whatever`?
15:57:11 <dmwit> or `foo :: ToS xs ~ ToS ys => HTreeS xs -> HTreeS ys` or whatever
15:57:17 <dyamon> dmwit: sorry went afk for a bit...anyway now I think it makes sense. So can one say that coerce operates on a transitive closure of `~`? So if `a ~ b` and `b ~ c`, `coerce` can jump from `a` to `c` in one go? Hence we go back to the original matter `Identity (a -> b)` and `Identity a -> Identity b` might not be equivalent (for some definition of equivalence) but we know that `(Identity (a -> b)) ~ 
15:57:23 <dyamon> (Identity a -> Identity b)` 
15:57:39 <dmwit> dyamon: Transitive closure, yes. Congruence closure, even.
15:58:16 <dmwit> dyamon: But it's not important here. `a -> b` and `Identity a -> Identity b` are equivalent in just one step, no applications of transitivity needed.
15:59:00 <dmwit> dyamon: Because of the rule I stated earlier: there's an instance `(Coercible i1 i2, Coercible o1 o2) => Coercible (i1 -> o1) (i2 -> o2)`.
15:59:06 <dmwit> (roughly)
15:59:56 <dmwit> (Though I stated it in terms of some `w`, `x`, `y`, and `z` and used English instead of Haskell syntax last time. ;-)
16:02:23 <dmwit> dyamon: And, well, in `instance Functor Identity where fmap = coerce` we are not jumping between `Identity (a -> b)` and `Identity a -> Identity b`. We're jumping between `a -> b` and `Identity a -> Identity b`. The type `Identity (a -> b)` simply doesn't enter the picture at all.
16:03:09 <dyamon> dmwit: because of the rule you just mentioned right?
16:03:44 <dmwit> yes
16:04:45 <infinity0> dmwit: omitting ss was my first attempt yes but i couldn't get that working either so i tried with an explicit unifier. i'll try ToS xs ~ ToS ys though, thanks
16:04:51 <dyamon> Instantiating the rule we should have `(Coercible a (Identity a), Coercible b (Identity b)) => Coercible (a -> b) (Identity a -> Identity b)`
16:05:02 <dmwit> dyamon: perfect instantiation
16:05:53 <dyamon> dmwit: I'm sending you a hug and a bag of cookies right now!
16:06:34 * hackage yesod-paginator 1.1.0.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-1.1.0.1 (PatrickBrisbin)
16:06:47 <dmwit> =D
16:07:46 <dmwit> infinity0: It's possible you'll need a class for `foo`, of course...
16:09:08 <infinity0> i don't understand how your solution works lol, also why does it break if i remove y completely from the class
16:09:18 <dyamon> Thanks a lot, again! Precious help as always!
16:10:17 <infinity0> ah, it's fine if i give xs a kind signature
16:11:18 <dmwit> Yeah, giving `y` a type signature was in part a sneaky trick to avoid needing a kind signature.
16:11:49 <infinity0> hm but it doesn't work if i move y out of the class and give it a Y xs => constraint
16:12:00 <dmwit> Yes, it must be part of the class.
16:13:40 <dmwit> In short: when it's in the class, it's a potentially different implementation for each choice of `xs`. Outside the class, it must work the "same way" for all choices of `xs`.
16:14:21 <dmwit> So this is in essence a way to dispatch on `xs`.
16:16:15 <infinity0> but if i give it a Y xs => constraint isn't that also disaptching on xs?
16:18:40 <dmwit> Only if you dispatch via a class method.
16:18:44 <dmwit> With no methods available, that's kind of hard.
16:26:35 --- mode: glguy set +v joshsh
16:27:30 <joshsh> repeating per glguy:
16:27:31 <joshsh> a question for the category theorists: is there a well-known technique for defining bidirectional mappings between ADTs? For example, I have an application which consumes schemas in any of a number of related formats, and translates them into any of the other formats. So far, I have developed one-way mappings in either direction from a neutral schema language, but I wonder if there is a better way.
16:29:04 <pavonia> Isn't that what lenses or prisms are for?
16:29:38 <Cale> Not... necessarily. There's Iso
16:29:56 <joshsh> perhaps -- is there a way one could define just one lens, as opposed to one in each direction? 
16:30:00 <Cale> But that's not necessarily any better than just using a pair of inverse maps
16:30:08 <joshsh> the challenge is that none of the mappings are 1:1. There are features in each of the formats / ADTs that are not expressed in the other ADTs
16:30:16 <Cale> ah
16:30:26 <joshsh> although all are "pretty close"
16:31:05 <joshsh> btw. I have not seen Control.Lens.Iso; looking now
16:31:21 <Cale> It's not appropriate then, since you don't want isomorphisms
16:31:48 <joshsh> right, hmm
16:31:53 <dmwit> joshsh: Part of my thesis work was on symmetric lenses -- which can lose information in both directions. (Unlike traditional lenses which require thaty ou lose information in only one direction.)
16:32:19 <joshsh> I will check that out, dmwit. Do you have a link?
16:32:27 <dmwit> I can point you at a paper which can give you some ideas for the laws you want, but there's no library that you could just plug in and use.
16:32:49 <dmwit> joshsh: "Symmetric Lenses" on dmwit.com
16:33:12 <joshsh> that's good information. I didn't want to go too far down the two-way map rabbit hole if there is a better solution
16:33:12 <dmwit> 2010-09
16:33:17 <joshsh> looking, thanks
16:37:32 <dmwit> You could also look into triple-graph grammars (I never did quite grok these), and there's one more approach with some pretty heavy category theory. Let me see if I can find the relevant discussion in my thesis so I can point you at a reference or two.
16:39:01 <joshsh> the paper appears to be exactly the discussion I am looking for
16:39:08 <dmwit> great =)
16:40:07 <dmwit> I can no longer find the papers I'm thinking of with the heavy CT. Sorry...
16:41:22 <joshsh> np. Will read up on TGGs, as well. Thanks again
16:55:04 * hackage fast-tags 1.5.0 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.5.0 (EvanLaforge)
16:56:55 <c50a326> https://ptpb.pw/wNQ0/hs line 64 and 65 are equivalent, right?
16:57:43 <c_wraith> yes
16:58:05 <c50a326> I'm having a real hard time wrapping my head around how this actually works... you provide `string` with a string and it returns a Parser which will Parse that String, if it's at the beginning of the input string (and it's happy to add leftovers in the leftovers String bit...)
16:58:13 <c50a326> I know how to use it
16:58:30 <c50a326> but it looks to me like it just returns a Parser of the input string in any case
16:58:36 <c50a326> which I suppose it does! that kind of makes sense
16:58:43 <c50a326> provided that each char in the string is...
16:58:52 <c50a326> the char/satisfy bit is kind of lost on me...
16:59:04 <c50a326> it checks that each char in the string is in fact each char in the string? I mean what the hell
16:59:12 <c50a326> oh yeah
16:59:23 <c50a326> for the new input string, because we're creating a function to be used later?
16:59:25 <c50a326> so do I get it?
17:00:06 <c_wraith> It's kind of hard to just...  understand.  You get way more out of building a super-primitive version.
17:00:28 <c50a326> that's what this is supposed to be! lol
17:00:41 <c50a326> I feel like I mostly get it :\ lol
17:01:20 <dmwit> c50a326: Be careful to differentiate between the argument to `string` and the `String` that's being parsed.
17:01:52 <dmwit> c50a326: In `string s`, the `s` is an argument to `string`. It returns a parser that checks that the string being parsed matches `s`.
17:02:44 <dmwit> e.g. `parse (string s) s` would "succeed", but `parse (string s) t` would "fail" if `t` was very different from `s`.
17:03:01 <c50a326> is the `char s >> string cs` part just to fail under certain circumstances though?
17:03:32 <dmwit> Sure: `char c` fails exactly when the string being parsed doesn't start with `c`, and `string cs` fails exactly when the string being parsed doesn't start with `cs`.
17:03:53 <c50a326> oh yes of course
17:04:00 <c50a326> I keep forgetting that we're in partial/higher-order land
17:04:03 <c50a326> it's so easy to forget lol
17:04:16 <c50a326> I need to move my brain into an abstract time-space
17:04:23 <dmwit> =)
17:04:54 <c50a326> ... and every time I remember my head just feels... odd and tired... lol
17:05:08 <c50a326> I want to cry and laugh, it's quite beautiful I suppose, but gosh...
17:09:06 <c50a326> oh so this is why they say about burritoes... it's because we're creating a recipe for something later... but it's a bad analogy because other programming could easily be described this way... seems more accurate that we might be creating recipes that create recipes...
17:09:59 <dmwit> I like the recipe analogy. It's much better than the burrito explanation. I will not deign to elevate the burrito explanation to the level of analogy.
17:12:26 <jackdk> I don't like the burrito analogies because they don't transmit information. If I explain something with a metaphor, then I expect behaviour within the metaphor should correspond to behaviour of the thing-being-explained-with-metaphor. The burrito "explanation" fails this test in nearly every way
17:12:49 <jackdk> and if you have to add a bunch of caveats to your metaphor, you have a bad metaphor
17:13:42 <Zipheir> But a good burrito, maybe.
17:14:34 <jackdk> if I'm hungry at 3am I'm not gonna go looking for a monad
17:15:13 <jackdk> https://argumatronic.com/posts/2018-09-02-effective-metaphor.html is a great article/talk-summary about how metaphors work, using monoid as the core haskell example
17:36:29 <Zipheir> Silly question, but what tuple spacing style do people prefer? (x,y,z) or (x, y, z) or some more refined rule?
17:43:07 <jackdk> personally, the second
17:43:13 <yushyin> ^ same
17:46:39 <dmwit> ( x\n, y\n, z\n) -- ;-)
17:49:13 <Zipheir> dmwit: I think I've seen that style somewhere...
17:49:24 <Zipheir> ty all for the feedback :)
17:55:04 * hackage f-ree-hack-cheats-free-v-bucks-generator 0.2 - Tests for the miconix sequencer library.  http://hackage.haskell.org/package/f-ree-hack-cheats-free-v-bucks-generator-0.2 (takloban)
17:59:08 <Clint> wat
18:00:00 <dmwit> I've mentioned it in #hackage. I trust the trustees will do something sensible about that.
18:02:01 <ab9rf> oi
18:03:16 <ab9rf> you wouldn't think that hackage would have enough exposure to be worth spamming
18:06:06 <jle`> ab9rf: i heard someone suggest that it's appealing because of the common associations of the word "hack" in "hackage"
18:08:04 * hackage free-v-bucks-generator-no-survey 0.2 - Tests for the miconix sequencer libraries.  http://hackage.haskell.org/package/free-v-bucks-generator-no-survey-0.2 (takloban)
18:09:04 * hackage mameya 0.2.1, mameya 0.2.0.1, mameya 0.2.0 (bururabit)
18:09:07 * hackage deptrack-dot 0.1.0.0, deptrack-devops 0.1.0.0, deptrack-core 0.1.0.0, grpc-etcd-client 0.1.2.0, grpc-api-etcd 0.2.0.0, http2-client-grpc 0.5.0.4 (LucasDiCioccio)
18:09:09 * hackage potoki-core 2.3.0.2, potoki-core 2.3.0.1, indexation 0.6.2.1, potoki 2.1, potoki-core 2.3 (NikitaVolkov)
18:09:11 * hackage shikensu 0.3.9 - Run a sequence of functions on in-memory representations of files  http://hackage.haskell.org/package/shikensu-0.3.9 (icidasset)
18:09:14 * hackage xml-conduit 1.8.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.8.0.1 (koral)
18:09:16 * hackage aos-signature 0.1.0 - An implementation of the AOS signatures  http://hackage.haskell.org/package/aos-signature-0.1.0 (sdiehl)
18:09:17 * hackage set-of 0.1.0.1, set-of 0.1.0.0 (fresheyeball): https://qbin.io/tv-met-dfr7
18:09:19 * hackage cloudi 1.7.4 - Haskell CloudI API  http://hackage.haskell.org/package/cloudi-1.7.4 (okeuday)
18:09:21 * hackage cdeps 0.1.1.8 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.8 (vmchale)
18:09:23 * hackage benchpress 0.2.2.11 - Micro-benchmarking with detailed statistics.  http://hackage.haskell.org/package/benchpress-0.2.2.11 (willsewell)
18:09:25 * hackage groundhog-th 0.9.0.1, groundhog-inspector 0.9.0 (BorisLykah): https://qbin.io/dp-god-uosq
18:09:27 * hackage vector-algorithms 0.8.0.0 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.8.0.0 (ErikDeCastroLopo)
18:09:30 * hackage free-v-bucks-generator-no-survey 0.2, f-ree-hack-cheats-free-v-bucks-generator 0.2 (takloban): https://qbin.io/stress-saving-5dco
18:09:31 * hackage boolector 0.0.0.7, boolector 0.0.0.6 (DeianStefan): https://qbin.io/tattoo-buses-ebf7
18:09:34 * hackage stack-tag 0.2.0 - Create etags for Haskell projects based on Stack snapshots  http://hackage.haskell.org/package/stack-tag-0.2.0 (ChristopherReichert)
18:09:36 * hackage wilton-ffi 0.3.0.3 - Haskell modules support for Wilton JavaScript runtime  http://hackage.haskell.org/package/wilton-ffi-0.3.0.3 (Wilton)
18:09:38 * hackage fast-tags 1.5.0 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.5.0 (EvanLaforge)
18:09:40 * hackage activitypub 0.1.0.0 - ActivityPub Haskell Library  http://hackage.haskell.org/package/activitypub-0.1.0.0 (LukeHoersten)
18:09:42 * hackage with 0.1.0 - Simple open product type  http://hackage.haskell.org/package/with-0.1.0 (iokasimovmt)
18:09:44 * hackage drifter-sqlite 0.1.0.0 - SQLite support for the drifter schema migraiton tool  http://hackage.haskell.org/package/drifter-sqlite-0.1.0.0 (MichaelXavier)
18:09:46 * hackage expressions-z3 0.2, expressions 0.2 (jakubdaniel): https://qbin.io/ui-paint-wan8
18:09:48 * hackage yesod-paginator 1.1.0.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-1.1.0.1 (PatrickBrisbin)
18:09:49 * hackage miconix-test 0.2, Oslo-Vectize 0.2, blunk-hask-tests 0.2 (demigod)
18:09:52 * hackage servant-auth-token 0.5.6.0 - Servant based API and server for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-0.5.6.0 (NCrashed)
18:09:54 * hackage zephyr 0.2.0 - Zephyr tree shaking for PureScript Language  http://hackage.haskell.org/package/zephyr-0.2.0 (coot)
18:09:55 * hackage Persistence 1.1.4.2, Persistence 1.1.4.1, Persistence 1.1.4 (Ebanflo)
18:09:57 * hackage japanese-calendar 0.1.0.2, japanese-calendar 0.1.0.1 (nakaji_dayo): https://qbin.io/broad-za-1uji
18:09:59 * hackage stache 2.0.1, mmark-cli 0.0.4.0, mmark 0.0.6.0, megaparsec 7.0.1 (mrkkrp)
18:10:01 * hackage opaleye 0.6.7002.0 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7002.0 (tomjaguarpaw)
18:12:21 <ab9rf> wtf
18:13:14 <jle`> probably just hackagebot rebooting
18:18:04 * hackage free-v-bucks-generator-no-survey 0.3 - Fortnite Hack Cheats Free V Bucks Generator.  http://hackage.haskell.org/package/free-v-bucks-generator-no-survey-0.3 (takloban)
18:31:04 * hackage free-v-bucks-generator-ps4-no-survey 0.2 - Fortnite Hack Cheats Free V Bucks Generator.  http://hackage.haskell.org/package/free-v-bucks-generator-ps4-no-survey-0.2 (takloban)
18:32:44 <ChaiTRex> That's definitely not an ad.
18:32:48 <ChaiTRex> Definitely.
18:33:34 <Solonarv_> I am... impressed?
18:39:34 * hackage mameya 0.2.1, mameya 0.2.0.1, mameya 0.2.0 (bururabit)
18:39:37 * hackage deptrack-dot 0.1.0.0, deptrack-devops 0.1.0.0, deptrack-core 0.1.0.0, grpc-etcd-client 0.1.2.0, grpc-api-etcd 0.2.0.0, http2-client-grpc 0.5.0.4 (LucasDiCioccio)
18:39:38 * hackage potoki-core 2.3.0.2, potoki-core 2.3.0.1, indexation 0.6.2.1, potoki 2.1, potoki-core 2.3 (NikitaVolkov)
18:39:41 * hackage shikensu 0.3.9 - Run a sequence of functions on in-memory representations of files  http://hackage.haskell.org/package/shikensu-0.3.9 (icidasset)
18:39:43 * hackage xml-conduit 1.8.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.8.0.1 (koral)
18:39:46 * hackage aos-signature 0.1.0 - An implementation of the AOS signatures  http://hackage.haskell.org/package/aos-signature-0.1.0 (sdiehl)
18:39:47 * hackage set-of 0.1.0.1, set-of 0.1.0.0 (fresheyeball): https://qbin.io/films-reach-kgy8
18:39:49 * hackage cloudi 1.7.4 - Haskell CloudI API  http://hackage.haskell.org/package/cloudi-1.7.4 (okeuday)
18:39:51 * hackage cdeps 0.1.1.8 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.8 (vmchale)
18:39:53 * hackage benchpress 0.2.2.11 - Micro-benchmarking with detailed statistics.  http://hackage.haskell.org/package/benchpress-0.2.2.11 (willsewell)
18:39:55 * hackage groundhog-th 0.9.0.1, groundhog-inspector 0.9.0 (BorisLykah): https://qbin.io/inside-enzyme-2bq4
18:39:57 * hackage vector-algorithms 0.8.0.0 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.8.0.0 (ErikDeCastroLopo)
18:40:00 * hackage free-v-bucks-generator-ps4-no-survey 0.2, free-v-bucks-generator-no-survey 0.3, free-v-bucks-generator-no-survey 0.2, f-ree-hack-cheats-free-v-bucks-generator 0.2 (takloban)
18:40:02 * hackage boolector 0.0.0.7, boolector 0.0.0.6 (DeianStefan): https://qbin.io/drinks-shine-5oj7
18:40:04 * hackage stack-tag 0.2.0 - Create etags for Haskell projects based on Stack snapshots  http://hackage.haskell.org/package/stack-tag-0.2.0 (ChristopherReichert)
18:40:06 * hackage wilton-ffi 0.3.0.3 - Haskell modules support for Wilton JavaScript runtime  http://hackage.haskell.org/package/wilton-ffi-0.3.0.3 (Wilton)
18:40:09 * hackage fast-tags 1.5.0 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.5.0 (EvanLaforge)
18:40:11 * hackage activitypub 0.1.0.0 - ActivityPub Haskell Library  http://hackage.haskell.org/package/activitypub-0.1.0.0 (LukeHoersten)
18:40:12 * hackage with 0.1.0 - Simple open product type  http://hackage.haskell.org/package/with-0.1.0 (iokasimovmt)
18:40:15 * hackage drifter-sqlite 0.1.0.0 - SQLite support for the drifter schema migraiton tool  http://hackage.haskell.org/package/drifter-sqlite-0.1.0.0 (MichaelXavier)
18:40:16 * hackage expressions-z3 0.2, expressions 0.2 (jakubdaniel): https://qbin.io/wind-peers-9q08
18:40:19 * hackage yesod-paginator 1.1.0.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-1.1.0.1 (PatrickBrisbin)
18:40:20 * hackage miconix-test 0.2, Oslo-Vectize 0.2, blunk-hask-tests 0.2 (demigod)
18:40:23 * hackage servant-auth-token 0.5.6.0 - Servant based API and server for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-0.5.6.0 (NCrashed)
18:40:25 * hackage zephyr 0.2.0 - Zephyr tree shaking for PureScript Language  http://hackage.haskell.org/package/zephyr-0.2.0 (coot)
18:40:26 * hackage Persistence 1.1.4.2, Persistence 1.1.4.1, Persistence 1.1.4 (Ebanflo)
18:40:28 * hackage japanese-calendar 0.1.0.2, japanese-calendar 0.1.0.1 (nakaji_dayo): https://qbin.io/novel-da-atry
18:40:29 * hackage stache 2.0.1, mmark-cli 0.0.4.0, mmark 0.0.6.0, megaparsec 7.0.1 (mrkkrp)
18:40:31 * hackage opaleye 0.6.7002.0 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7002.0 (tomjaguarpaw)
18:42:54 --- mode: ChanServ set +o dmwit
18:43:03 --- mode: dmwit set -v hackage
18:43:27 --- mode: dmwit set -o dmwit
18:43:47 <ChaiTRex> Does hackage spit out a flood like that often?
18:43:59 <dmwit> Dunno. This is the third time today I've seen it.
18:44:09 <jle`> it's likely to be some backlog glitch i think
18:44:16 <dmwit> yeah
18:44:18 <nsnc> hackage was hacked
18:44:18 <jle`> state is weird
18:44:24 <nsnc> glitch in the matrix
18:44:33 <jle`> managing state is difficult
18:44:35 <dmwit> I can't remember who runs it, but we'll try to get in contact with them and re-enable it when it's behaving better.
18:44:43 <ChaiTRex> It's possible Hackage was hacked.
18:45:05 <glguy> Maybe it's aliens?
18:45:08 <jle`> ChaiTRex: do you mean hackage, or the hackagebot?
18:45:15 --- mode: glguy set +q hackage!*@*
18:45:17 <ChaiTRex> Hackage.
18:45:30 <ChaiTRex> vector-algorithms is never updated.
18:45:31 <jle`> possibly, but i don't think that would cause behavior in hackagebot like we are observing
18:45:46 <jle`> since hackagebot and hackage are different entities
18:46:09 <ChaiTRex> I'll investigate vector-algorithms to see.
18:46:29 <glguy> https://github.com/erikd/vector-algorithms/commit/3525389409b992004f1818960313bd3360fd3573
18:47:00 <ChaiTRex> Ahh, excellent.
18:47:25 <jle`> hackagebot and hackage are unrelated and run on different servers, so i don't think this can be seen as any indication that hackage was hacked or not
18:47:47 <ChaiTRex> OK, that makes sense.
18:48:17 <erikd> glguy: yeah, that happened some time before i became the maintainer. hoping this is the least painful fix for everyone
18:48:34 <erikd> co-maintainer i should say :)
18:59:52 <geekosaur> someoen reboted themachnethat bto runs on and forgot to disableautostart?
18:59:57 <geekosaur> mumble
19:00:23 <geekosaur> someone rebooted the machine that bot runs on, and forgot to disable autostart?
19:03:30 <jle`> his mindset is interesting but not necessarily novel
19:03:33 <jle`> .
19:03:54 <jle`> ah sorry, accidental keypress
19:06:29 <mniip> that's not normal
19:12:06 --- mode: glguy set +v mark___
19:13:56 <koz_> jle`: I just read 'You could ahve invented matrices'.
19:14:04 <koz_> Seriously, you managed to make me care about linear algebra.
19:14:07 <koz_> Well done.
19:14:11 <koz_> Seriously great.
19:17:18 <mark___> Hi, I'm a Haskell newb playing around with the brick library, and I had a Lens question.
19:17:40 <mark___> https://gist.github.com/mark-keaton/79b07a2749d2fa2d677433419f176476
19:18:03 <mark___> How do I use a lens to just add a value to the end of a List? (Like in my gist for addUser)
19:19:51 <koz_> mark___: You want this: http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Setter.html#v:over
19:20:11 <mniip> dmwit, glguy who'd've thought one can mess up such a simple bot feature: https://github.com/sopel-irc/sopel/issues/1056
19:20:19 <koz_> (also, just because I'm a pedant, [a] is _not_ an array in any sense of the idea)
19:22:08 <mark___> Hi koz_, thanks for the help.. Let me look at the docs and see if I can grok
19:28:03 <maerwald> new-build cannot pick up a local cabal config?
19:28:17 <dmwit> mniip: ouch
19:29:50 <mniip> there's a timer thing, turns out when the bot autoreconnects the modules are reloaded and the timer is duplicated
19:30:08 <maerwald> it seems it just ignores cabal.config from the project directory
19:36:24 <maerwald> https://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project seems so
19:38:59 <Axman6> mark___: You can use over to do something like: over myList (++[newElement]), but if you need to do a lot of appending, then you might want to pick a better structure than list, like Data.Seq
19:39:46 <Axman6> if the order doesn't matter then you can use over myList (newUser:) to prepend them
19:41:10 <mark___> Thanks guys, once I get this working, i'll probably switch to Data.Seq. So far so good
19:42:15 <Axman6> does the order matter?
19:42:50 <mark___> Yeah
19:42:58 <mark___> It's a chat log
19:43:07 <koz_> Yeah, definitely don't use lists then.
19:43:31 <koz_> Also, hai Axman6!
19:43:40 <Axman6> o/
19:44:44 <jackdk> \o
19:45:10 <Axman6> :o
19:45:34 <ab9rf> well, if order matters but you can cope with backwards... :)
19:45:35 <koz_>  \o/
19:46:12 <ab9rf>  /°\
19:47:33 <coldpresent>  \./
19:49:55 <koz_>  \../
19:50:02 <koz_> (are we defining new lens operators?)
19:51:06 <ab9rf> heheh
19:51:11 <mark___> Pls no... There are enough already :coldsweat:
19:51:24 <ab9rf> MOAR OPURRATORS!
19:51:33 <koz_> mark___: They're quite logical, but I understand why you find it overwhelming.
19:51:49 <koz_> Lens is, like many Edward libraries, incredibly powerful, incredibly general, and incredibly well-founded.
19:56:58 <koz_> (that can, however, make them incredibly intimidating)
20:00:18 <ab9rf> edward is good at making highpower chainsaws with extremely complex control modules
20:00:35 <koz_> ab9rf: Heavily logical law-abiding chainsaws, at that.
20:00:49 <ab9rf> indeed
20:01:42 <ab9rf> i haven't used lens that much, but what i have used hasn't really felt intimidating
20:01:51 <koz_> ab9rf: Imagine being new to Haskell.
20:01:54 <ab9rf> there are parts that are opaque to me still
20:02:13 <koz_> I've found that, every time I thought I needed lenses, I actually didn't need lenses.
20:02:15 <ab9rf> but the documentation is clear enough on them that i can still use them even though i don't fully understand them
20:02:27 <ab9rf> koz_: i've had the same experience.
20:02:42 <koz_> I'm sure there are use cases where lenses really help, but I guess they're not mine.
20:02:48 <ab9rf> so far every use case i've had that involved lenses turned out to be solvable with something less nuclear
20:03:11 <koz_> Yeah, lenses are an ant-killing flamethrower.
20:03:20 <koz_> (or at least have been in my case)
20:03:22 <ab9rf> really useful if you have a million unwanted ants
20:04:14 * koz_ is really looking forward to QuantifiedConstraints.
20:04:34 <koz_> Not least of all because it makes it possible to define Generic over (certain) GADTs.
20:08:30 <jle`> koz_: thanks, i appreciate it the kind words :)
20:09:44 <maerwald> https://privatebin.net/?9a5b312facd5c5b2#4Xr/lcGXjswqJkLFw+I8sw+bDQ4drYfrWcq4x4HoeVw= weird, I don't have this problem with stack
20:09:58 <maerwald> not even with cabal sandbox afair
20:10:15 <koz_> maerwald: AFAIR?
20:10:23 <ab9rf> "as far as i remember"
20:10:31 <koz_> Ah.
20:10:33 <ab9rf> or recall, either is appropriate
20:10:48 <koz_> I don't think I've seen that before - usually it's afaik and afaict.
20:11:04 <ab9rf> i've also seen afaicg
20:11:09 <maerwald> ok
20:11:14 <koz_> As far as I could ...?
20:11:22 <ab9rf> "can guess"
20:11:27 <koz_> Ah.
20:11:34 <koz_> Isn't that just afaict?
20:12:01 <coldpresent> why not just a simple "iirc"?
20:12:13 <koz_> coldpresent: Yeah I guess.
20:12:50 <koz_> jle`: Any chance you're working on part 3 of your guide to singletons?
20:13:35 <maerwald> good we talked about it
20:16:29 <dmj`> dmwit: got this CSV lexer to 80MB/s :) 97% productive, 3MB heap used. Respectable!
20:16:29 <maerwald> https://matrix.hackage.haskell.org/package/interpolatedstring-perl6
20:20:31 <jle`> koz_: funny you ask, i actually recently started workign on it again :)
20:20:38 <koz_> jle`: Yay!
20:20:45 <koz_> Lookin' forward to it.
20:21:10 <maerwald> I don't see anything in the .cabal file that would explain the <1.25 constraint https://hackage.haskell.org/package/interpolatedstring-perl6-1.0.0/interpolatedstring-perl6.cabal
20:24:03 <maerwald> https://github.com/haskell/cabal/issues/5278
20:38:47 <geekosaur> yeh, that means it expets newer cabal library to blow chunks because it can't figure out how to do custom setup. which is a problm in both cabal-install and stack, because there's a severe bootstapping issue
20:40:49 <geekosaur> there's a stack ticket about trying to build gtk2hs, that hinges around that bootstrapping issue and is more or less why both do this. cabal 1.24 and earlier expose all packages ghc knows about for setup, stack and later cabalw ant more control and setup faisl because the packages it wants are all hidden, by default only base is exposed
20:40:52 <maerwald> except cabal doesn't tell me it just added an upper bound and why
20:42:00 <geekosaur> so there;'s a hack to force it to use the older cabal lib that exposes everythng, otherwise you need a custom setup stanza to tell it what to expose liek stack and newer cabal require
20:42:36 <geekosaur> wich worked then but not so much now because not everyone has cabal 1.24 any more
20:45:01 <maerwald> I would prefer it just errors out instead of doing implicit stuff
20:45:04 <geekosaur> it's all ki8nda frustrating because with stack and new cabal that kind of package is a time bomb looking for an excuse to go off, they expect you to pollute our global package database for their convenience
20:45:19 <geekosaur> *your global packagedb
20:46:01 <geekosaur> and people get pissy if it just says "no"
20:46:31 <maerwald> well, these things go unnoticed if there are no errors and no one bothers fixing anything
20:47:26 <geekosaur> this hack came out of originally doing what you ant, and ten a bunch fo packages refusing to build "for no good reason" when they had built with older stack/cabal
20:47:49 <geekosaur> kinda hard to satisfy two groups who want diametrcally opposite things
20:48:08 <maerwald> it's very simple. correctness over convenience
20:49:36 <maerwald> especially when this thing builds my project...
20:50:15 <maerwald> build systems and package managers should be as strict as possible
20:51:02 <geekosaur> "it's very simle, I'm right they're wrong" the people who demanded thsi behavior didn't buy that argument then
20:51:15 <geekosaur> I;'m not sure they;ve converted to yoou religion now
20:52:26 <maerwald> religion? :>
20:53:37 <maerwald> it's not hard to see what happens if the fundamental tools of e.g. your distribution are whacky... then people come up with workarounds, get used to workaround and these break their systems occasionally, so they write tools that reverse-fix their systems
20:53:52 <maerwald> all happened :P
20:53:59 <maerwald> not necessarily in haskell, but...
20:55:32 --- mode: glguy set +v dataN
20:56:01 <dataN> why cant I write; type family Get (xs :: f a) :: '(a,Maybe (f a))
20:56:03 <dataN> ?
20:56:29 <dataN> GHC says; Expected a type, but '(a, Maybe (f a)) has kind `(k0, *)'
20:56:48 <dataN> cant it see 'a' ?
20:58:18 <glguy> And you didn't mean: type family Get (xs :: f a) :: (a , Maybe (f a)) ?
20:58:47 <dataN> oh, yeah that works... sry
21:01:23 <dataN> is there a way to do type level let bindings?
21:06:55 <pavonia> `(a ~ f b c) => a -> a` is basically a let, no?
21:08:42 <dataN> so I could write ((x,Maybe xs') ~ Get xs) => 
21:08:45 <dataN> ?
21:09:25 <dataN> and does that work in a type family?
21:10:33 <dataN> like; type family X (xs :: f a) :: ... where X xs = ((x,Maybe xs') ~ Get xs) => ...
21:32:30 <dataN> pavonia: this does not work; https://gist.github.com/dataN-hs/90652aec7c806930aec2feb65ac85ec0
21:47:05 --- mode: glguy set +v madMartian666
21:47:27 <madMartian666> glguy: did my last message transmit to the channel?
21:48:41 <geekosaur> the first one doesn't, no, irc provides no way to tell the server to go back and let the last message through
21:49:24 <geekosaur> and if glguy tried to relay, it would claim to have come from him, not from you
21:49:40 <geekosaur> which messes up replies a bit
22:07:28 <dataN> hmm with a forall to bring the types into scope it almost works;
22:07:29 <dataN> type Test2 = (forall x xs. '(x,xs) ~ (Get (Bool ': Int ': '[])) => Set '(x,xs))
22:07:35 <dataN> Expected a type, but `Set '(x, xs)' has kind `[*]'
22:07:48 <dataN> type Test1 = Set (Get (Bool ': Int ': '[]))
22:07:55 <dataN> works though...
22:08:21 <dataN> cant quite tell why one would give that error but not the other
22:13:30 <dataN> :k Test1 = Test1 :: [*]
22:13:32 <lambdabot> error:
22:13:32 <lambdabot>     parse error on input ‘=’
22:13:32 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
22:13:43 <dataN> shut up lambdabot
22:14:57 <dataN> is it because the RHS of the constraint => needs to be a type?
22:15:14 <dataN> if thats so, how can this approach work?
22:20:38 <Cale> dataN: What's going on here?
22:22:00 <Cale> oh, just found your paste
22:22:19 <dataN> https://gist.github.com/dataN-hs/90652aec7c806930aec2feb65ac85ec0
22:23:26 <Cale> What are you trying to do?
22:23:47 <dataN> something like let binding at type level
22:24:01 <dataN> have just updated it to include the above error
22:26:59 <Cale> ah, this probably requires something newer than 8.4.3
22:28:01 <dataN> but thats the current version!
22:28:48 <Cale> Well, I don't get the same errors as you when building with 8.4.3
22:29:01 <Cale> (In particular, TypeError and Text aren't bound)
22:29:53 <dataN> oops, updated that
22:30:44 <Cale> ah, okay
22:33:37 <dataN> @let type A = (forall (x::Int). ('(x,())~'(Int,())) => x :: Int)
22:33:39 <lambdabot>  .L.hs:170:31: error:
22:33:39 <lambdabot>      • Expected kind ‘Int’, but ‘x’ has kind ‘*’
22:33:39 <lambdabot>      • In the type ‘(forall (x :: Int).
22:34:17 <dataN> type A = (forall (x::Int). () => x)
22:34:21 <dataN> @let type A = (forall (x::Int). () => x)
22:34:22 <lambdabot>  Defined.
22:35:37 <Cale> So what kinds did you intend for x and xs to have there?
22:36:55 <dataN> @let type A = (forall x. ('(x,())~'(Int,())) => x )
22:36:56 <lambdabot>  .L.hs:172:1: error:
22:36:56 <lambdabot>      Multiple declarations of ‘A’
22:36:56 <lambdabot>      Declared at: .L.hs:170:1
22:37:02 <dataN> @let type B = (forall x. ('(x,())~'(Int,())) => x )
22:37:03 <lambdabot>  Defined.
22:37:18 <dataN> Cale: in the paste?
22:37:55 <Cale> In the definition of Test2
22:37:59 <dataN> (*,[*])
22:38:07 <Cale> I suppose x :: * and xs :: Maybe [*]
22:38:09 <Cale> ?
22:38:34 --- mode: glguy set +v dataN_
22:39:03 --- mode: glguy set -v dataN_
22:39:52 <dataN_>  x :: Bool, xs :: [*]
22:40:14 <Cale> No, that can't be
22:40:25 <dataN_> oh no, x :: *
22:40:29 <Cale> I think you want x :: * and xs :: Maybe [*]
22:40:36 <Cale> ah, this works:
22:40:39 <dataN_> oh yeah, thats right
22:40:41 <Cale> type T2 (f :: [*] -> *) = forall (x :: *) (xs :: Maybe [*]). '(x,xs) ~ (Get (Bool ': Int ': '[])) => f (Set '(x,xs))
22:41:38 <dataN_> wait whats f there?
22:41:38 <Cale> It seems unhappy to make a type synonym at kind [*]
22:41:54 <Cale> Just any type of kind [*] -> *, it's a parameter to the synonym
22:42:13 <dataN_> @let type A = '[Bool]
22:42:14 <lambdabot>  .L.hs:174:1: error:
22:42:14 <lambdabot>      Multiple declarations of ‘A’
22:42:14 <lambdabot>      Declared at: .L.hs:170:1
22:42:18 <dataN_> @let type C = '[Bool]
22:42:20 <lambdabot>  Defined.
22:43:07 <dataN_> :k C
22:43:09 <lambdabot> [*]
22:45:25 <Cale> ahh, it's not the synonym, it's as you said, the constraint application
22:45:38 <Cale> Weird that it doesn't deal with that
22:45:59 <dataN_> what its not strict?
22:46:21 <Cale> cxt => type  must have type at kind * it seems
22:48:03 <dataN_> @let type D = (forall x. () => '[x])
22:48:05 <lambdabot>  Defined.
22:48:06 <dataN_> :k D
22:48:07 <lambdabot> [k]
22:49:04 <dataN_> @let type E = (forall p x. (p x) => '[x])
22:49:06 <lambdabot>  .L.hs:178:33: error:
22:49:06 <lambdabot>      • Expected a type, but ‘'[x]’ has kind ‘[k0]’
22:49:06 <lambdabot>      • In the type ‘(forall p x. (p x) => '[x])’
22:50:59 <dataN_> whats up with that!?
22:52:18 <Cale> @let type family Head xs where Head (x ': xs) = x
22:52:19 <lambdabot>  Defined.
22:52:42 <Cale> > True :: Head ((Ord Integer) => '[Bool])
22:52:45 <lambdabot>  error:
22:52:45 <lambdabot>      • Expected kind ‘[*]’, but ‘'[Bool]’ has kind ‘*’
22:52:45 <lambdabot>      • In the first argument of ‘Head’, namely
22:52:52 <Cale> lol
22:53:04 <Cale> It actually gives two errors
22:53:11 <Cale> That one is the more confused of the two
22:53:49 <Cale>     • Expected a type, but ‘'[Bool]’ has kind ‘[*]’
22:53:49 <Cale>     • In the first argument of ‘Head’, namely ‘((Ord Bool) => '[Bool])’
22:54:00 <Cale> ^ the other one
22:54:36 <dataN_> @undefine
22:54:37 <lambdabot> Undefined.
22:54:42 <dataN_> @let type A = (forall (f :: [*] -> *) p x. (p x) => f '[x])
22:54:43 <lambdabot>  Defined.
22:54:54 <Cale> It's probably just whenever you give a nonempty context, the type must have kind * for some arbitrary reason
22:55:00 <dataN_> @let type B = (forall (f :: [*] -> a) p x. (p x) => f '[x])
22:55:01 <lambdabot>  .L.hs:160:49: error:
22:55:01 <lambdabot>      • Expected a type, but ‘f '[x]’ has kind ‘a’
22:55:01 <lambdabot>      • In the type ‘(forall (f :: [*] -> a) p x. (p x) => f '[x])’
22:56:19 <dataN_> @let type C = (forall (f :: [k] -> b) q p x. (q p) => f '[x])
22:56:20 <lambdabot>  .L.hs:160:51: error:
22:56:20 <lambdabot>      • Expected a type, but ‘f '[x]’ has kind ‘b’
22:56:20 <lambdabot>      • In the type ‘(forall (f :: [k] -> b) q p x. (q p) => f '[x])’
22:56:31 <dataN_> right, it doesnt matter if x is used in the context 
22:56:47 <Cale> I wouldn't expect any of this sort of thing to be especially robust or usable -- these are some fairly new and experimental extensions, and practically nobody *really* uses them.
22:57:31 <dataN_> what!? this error is crazy
22:58:29 <dataN_> maybe there is a workaround 
22:58:32 <Cale> Well, we've empirically discovered that it doesn't like things of the form cxt => ty when cxt is a nonempty context, and ty is a type of kind anything other than *
22:58:46 <dataN_> agreed 
22:59:02 <Cale> In that case, f '[x] :: b, where b is a rigid kind variable
22:59:13 <Cale> so it's unhappy to just unify it with *
22:59:34 <dataN_> why would it need to?
22:59:49 <Cale> Well, because it can't handle contexts applied to things which aren't types of kind *
22:59:53 <dataN_> it should be able to return any kind 
22:59:53 <Cale> apparently
23:00:11 <dataN_> ah, well when you put it like that...
23:00:22 <Cale> I'm not entirely sure why, but I can imagine it makes the collection of constraints more complicated
23:00:34 <Cale> and probably nobody has ever asked for it
23:00:39 <Cale> before now
23:00:40 <Cale> lol
23:01:15 <dataN_> using equality constraints to emulate let bindings in type synonyms for use with type families?
23:01:49 <Cale> I just mean the "applying constraints to types which have a kind which isn't *" bit
23:02:38 <dataN_> so call them kind synonyms?
23:02:40 <Cale> (and not in the way which one would normally think of when saying that -- it sounds like we mean something like Monad, but no...)
23:03:25 <dataN_> right, because normally a Monad would not be left partially applied...
23:03:41 <Cale> This is an interesting attempt. I was foiled in a plan the other day for want of a single type level lambda
23:04:11 <dataN_> using equality constraints?
23:04:36 <dminuoso> cocreature: ping
23:05:19 <cocreature> dminuoso: pong
23:05:51 <Cale> No equality constraints...
23:06:06 <Cale> Let me link you something for context
23:06:21 <dataN_> maybe using a proxy would work
23:06:21 <Cale> https://github.com/obsidiansystems/constraints-extras/blob/develop/src/Data/Constraint/Extras.hs
23:06:25 <dataN_> type X = (forall p q a x. (q a) => p '[x])
23:06:31 <dataN_> @let type X = (forall p q a x. (q a) => p '[x])
23:06:33 <lambdabot>  Defined.
23:07:36 <Cale> This is a class for GADTs whose indices can be finitely enumerated, so that if we want to know some fact (i.e. a type class constraint) about an arbitrary index, there's a way to translate that into a finite list of constraints on the individual possibilities
23:08:01 <Cale> So, we started off with this function argDict :: ConstraintsFor f c => f a -> Dict (c a)
23:09:09 <Cale> I wanted to generalise all these variants
23:11:10 <Cale> The idea is, for any type level function f I can apply to the indices, I ought to be able to apply first that function and then the type class to each of the indices, and then for any value of type f a, we'll be able to obtain Dict (c (f a))
23:11:16 <Cale> oops
23:11:17 <Cale> haha
23:11:26 <Cale> The idea is, for any type level function g I can apply to the indices, I ought to be able to apply first that function and then the type class to each of the indices, and then for any value of type f a, we'll be able to obtain Dict (c (g a))
23:11:46 <Cale> So you can see the primed versions already come somewhat close to that
23:11:58 <Cale> But they're not *quite* what we want
23:12:32 <Cale> Because we'd like to be able to get back the unprimed versions, so I need to be able to supply an honest type level identity function for that
23:12:45 <Cale> and then for the V versions, we'd need to supply flipped type application
23:13:51 <Cale> I'd like to be able to write something like:
23:13:56 <Cale> class Indexed f where
23:14:04 <Cale>   type Indices f :: [*]
23:14:12 <Cale>   argDict :: ...
23:15:05 <Cale> and hopefully with some magic, produce a version of argDict which actually handles all of the cases
23:15:24 <Cale> But there's no apparent way to write the type which actually works with generality
23:15:27 <dataN_> @let type family UnProxy (x :: p (a :: k)) :: k where UnProxy (x :: p a) = a
23:15:27 <lambdabot>  Parse failed: Parse error: ::
23:15:42 <Cale> This class is really really useful though
23:15:43 <dataN_> hmm that works in GHCi
23:16:07 <Cale> Who knows what version of GHC lambdabot is running :)
23:16:13 <MarcelineVQ> I have it on good authority that lambdabot is not ghci, but it's especially not your ghci :>
23:16:18 <Cale> Might be 8.0.1 or something.
23:17:23 <dataN_> type A = (UnProxy) (forall p q a x. (q a) => p '[x])
23:17:34 <dataN_> GHC doesn't yet support impredicative polymorphism
23:17:37 <Cale> I've recently been working on a somewhat type which we're going to use in our communication protocols between our application frontends and backends
23:17:42 <Cale> somewhat fancy type*
23:18:14 <dataN_> and no amount of kind annotations to UnProxy seems to work...
23:18:34 <Cale> It's a map-like datastructure whose keys are expected to be a GADT whose index tells the type of container that will be stored at that position
23:19:02 <Cale> but then additionally, all our types are parameterised over a choice of functor, and it distributes that choice to the containers that it holds
23:19:13 <Cale> So it has kind (((* -> *) -> *) -> *) -> (* -> *) -> *
23:19:45 <Cale> i.e. we're interested in things parameterised by a functor, i.e. containers of type (* -> *) -> *
23:20:08 <Cale> Its keys are indexed on such types, so its key type has kind ((* -> *) -> *) -> *
23:20:20 <Cale> and then it takes a functor parameter itself
23:20:27 <Cale> and produces an ordinary type
23:21:01 <dataN_> right, so you need to pass partially applied kinds?
23:21:10 <dataN_> types*
23:21:33 <Cale> Well, yes, but that's not so bad
23:21:43 <dataN_> isnt that ((* -> *) ~> *) -> *
23:21:58 <Cale> The part where this starts to get hairy is when you want to, e.g. obtain JSON instances for the whole thing
23:22:13 <Cale> What's that ~> ?
23:23:51 <dataN_> dunno, maybe it would be called a defunctionalisation arrow or something
23:23:54 <dataN_> see; https://gist.github.com/dataN-hs/93a90e281a4208e6c224bc967ca09600
23:23:56 <Cale> So, we need to have a way to say: for any possible value of type k v, we have a JSON instance for v g
23:24:20 <Cale> which is expressed using that library I linked, as HasV ToJSON k g
23:24:45 <dataN_> oh like a quantified constraint? 
23:24:47 <Cale> (or HasV FromJSON k g, as the case may be)
23:25:06 <Cale> It's a dependently quantified constraint
23:25:18 <dataN_> hmm?
23:25:35 <Cale> for any possible *value* of type k v
23:26:21 <Cale> This only works because k is going to be one of these finitely indexed GADTs, so we can enumerate all the possible indices it might take on
23:26:38 <Cale> This all works, amazingly
23:27:19 <Cale> e.g. if k is something like
23:27:54 <Cale> Well, let me introduce this first:
23:27:56 <Cale> newtype IdentityV (a :: *) (g :: * -> *) = IdentityV { unIdentityV :: g a }
23:28:06 <Cale> data MyKey v where
23:28:16 <dataN_> so its an alternative approach to defunctionalisation?
23:28:19 <Cale>   Foo :: MyKey (Identity Bool)
23:28:27 <Cale> oops
23:28:29 <Cale>   Foo :: MyKey (IdentityV Bool)
23:29:03 <Cale> I'm not sure how it's related to defunctionalisation
23:29:13 <dataN_> oh,no you just didnt want to have to use partially applied type families
23:29:39 <dataN_> "symbolic type-level application"
23:30:15 <Cale> If I was allowed partially applied type families, then I could unify these different sorts of Has/Has'/HasV things into one
23:30:42 <Cale> I suppose I could use symbolic type-level application...
23:30:58 <Cale> But I'm not sure that's really worth it :P
23:31:48 <Cale> Especially as there are only 3 cases to handle for now. If it proliferates any further, maybe I'll reconsider.
23:32:10 <Cale> But probably when Dependent Haskell comes along, it'll just get cleaned up without any need for such shenanigans
23:33:02 <Cale> I still need to talk to Stephanie Weirich or SPJ or someone about this finitely indexed GADTs thing... the compiler could do this much better than I could.
23:33:20 <Cale> (I have some TH which generates instances of ArgDict, but it's not especially clever)
23:38:16 <Cale> It's just really silly that all these argDict things all have identical implementations (pattern match on all constructors, produce Dict as the result), but at the type level, they're distinct in a way that's hard to abstract over.
23:45:11 <tdammers> all these problems will go away once Haskell is fully dependently typed! hah!
23:45:51 <MarcelineVQ> tdammers: The claim seemed to be about the particular task Cale was writing :>
23:47:55 <dataN_> Cale: so it lists explicitly all the Constraints for a particular type? and then recovers different Dicts of these depending on other parameters? 
23:51:42 --- mode: glguy set +v musey
23:52:47 <dataN_> oh, it uses the container to choose which constraints hold over its contents?
23:52:54 <Cale> tdammers: and I don't even really need dependent types, just honest type level lambda
23:53:08 <Cale> (on type level arguments)
23:53:27 <dataN_> where would you apply that?
23:54:06 <Cale> dataN_: For a simpler example than the one I was giving before, consider something like a GADT describing possible API requests, and its type index is the type of the response.
23:55:42 <Cale> You might like to know, given the request that was made, which JSON instance to apply to decode the response (or that there is a JSON instance at all)
23:56:05 <Cale> So, using the constraint Has FromJSON MyRequest
23:56:32 <Cale> we can write  has @FromJSON req (... decode the response in here ...)
23:57:07 <tdammers> Cale: the fact that type-level Haskell is a lot more limited than term-level Haskell, and has far clumsier syntax, has bothered me for quite a while now
23:58:31 <Cale> Has FromJSON MyRequest will turn into (ArgDict MyRequest, ConstraintsFor MyRequest FromJSON)
23:58:47 <Cale> and then (ConstraintsFor MyRequest c) will be something like (c Integer, c Bool, ...)
23:59:02 <Cale> enumerating all the possible indices of the GADT
