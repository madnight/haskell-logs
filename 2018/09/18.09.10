00:11:07 <koz_> Axman6: https://i.kym-cdn.com/entries/icons/original/000/001/332/roflbot-ZfY6_2_.jpg
00:11:21 <koz_> That pretty much summarizes my sentiments.
00:12:37 <MarcelineVQ> We may just hold different ideas than Axman6 about what the word nice should mean :>
00:13:13 <koz_> MarcelineVQ: 'Nice' is a better adjective choice than 'Azathoth-summoning'.
00:14:35 <MarcelineVQ> commendable pantheon choice for that snippet
00:14:48 <koz_> MarcelineVQ: I can't always use Nyarlathotep after all.
00:15:12 <koz_> But frankly, if I were to write a cosmic-horror summoning library, I'd want all the type safety I can get.
00:15:45 * koz_ imagines what kind of functions that would have.
00:16:33 <koz_> summon :: [Trappings] -> Maybe CosmicHorror
00:16:41 <koz_> (or perhaps 'IO CosmicHorror'?)
00:16:55 <koz_> s/[Trappings]/[Trapping]
00:18:06 <Axman6> btw, GHC wasn't able to derive that type so it had to be worked out by hand. Also I agree nice is subjective
00:18:22 <koz_> Axman6: Colour me _distinctly_ unsurprised.
00:19:43 <Axman6> I'm a little disappointed it couldn't d it
00:19:45 <MarcelineVQ> that's mauve with tan stripes
00:19:46 <Axman6> do*
00:20:07 <koz_> MarcelineVQ: Mauve with tan stripes is 'distinctly unsurprised'?
00:20:14 <MarcelineVQ> Yep
00:20:27 <Axman6> everyone knows that
00:20:28 <MarcelineVQ> well, _distinctly_
00:21:34 <MarcelineVQ> for regular distinctly unsurprised the stripes are matte orange, iirc
00:21:49 <MarcelineVQ> or they're diamonds instead of stripes, it's been a long time since it's come up
00:25:09 <koz_> Also, I think I just had a breakthrough in understanding monad transformers.
00:25:19 <koz_> It seems so obvious now, but it didn't before.
00:25:22 <MarcelineVQ> yw
00:25:34 <koz_> MarcelineVQ: Lol.
00:25:44 <Axman6> That's the power of colour therapy for ya
00:25:56 <koz_> Axman6: Oh, so _that's_ what it was!
00:26:07 * koz_ puts away salt circles, dead chickens and Necronomicon copy.
00:26:09 <koz_> Ahem.
00:26:30 <koz_> SO ANYWAY WHO WANTS A ROAST CHICKEN BOOK PARTY!
00:58:44 <fragamus> howdy
01:01:57 <fragamus> given two monoidal functions, and two operations which are known to be mutual inverses, is there a way to have equal numbers of them cancel out?  BTW these operations can be performed out of order
01:02:37 <koz_> fragamus: What do you mean by 'monoidal function' here?
01:03:37 <fragamus> it accepts a type and returns the same type
01:03:46 <dminuoso> fragamus: those are called endofunctions
01:04:31 <koz_> fragamus: So what you're saying is that you have two functions f :: a -> a and g :: a -> a such that f . g = id, right?
01:04:49 <fragamus> yes
01:05:04 <dminuoso> fragamus: Is the operation commutative?
01:05:11 <fragamus> yes
01:05:29 <koz_> Now, the 'equal numbers cancel out' thing - are you saying that you have something like a list [a -> a] and you wanna remove 'unnecessary' operations from it?
01:05:44 <koz_> (by 'cancelling out' fs with gs on a one-for-one basis?)
01:06:53 <fragamus> I guess I want to just apply them and have the thing count them and only perform the net effect rather than performing all of them
01:08:59 <koz_> fragamus: I think more context is needed - I'm not precisely sure why you'd wanna do that.
01:14:01 <fragamus> ok the type  a -> a where a is ([b],[b])    f (x:ls,rs) = (ls,x;rs)   
01:14:38 <fragamus> f (x:ls,rs) = (ls,x:rs)
01:15:56 <fragamus> g (ls,x:rs) = (x:ls,rs)
01:25:18 <delYsid> Hmm, is there a list-like datastructure with a current focus?  Something like NonEmptyList with a selected element?
01:27:03 <liste> delYsid: https://wiki.haskell.org/Zipper
01:27:07 <ventonegro> delYsid: Zipper
01:32:06 <fragamus> but f and g will be applied many many times
01:37:01 <delYsid> ah, right!
01:58:40 <merijn> I've got a testing question: How do I go about setting up tests that check whether something compiles/fails to compile, rather than the standard exti-code tests that compile and run something
02:07:44 <MarcelineVQ> merijn: maybe ghc-as-a-lib could inform your test, either in exit-code executable form or detailed form, https://www.haskell.org/cabal/users-guide/developing-packages.html#example-package-using-detailed-0-9-interface
02:08:57 <cocreature> merijn: https://hackage.haskell.org/package/should-not-typecheck
02:09:16 <merijn> MarcelineVQ: The detailted test interface has, to the best of my knowledge, not really been supported in the past decade
02:10:10 <merijn> cocreature: Would that work for TH produced errors, rather than just type check failures?
02:10:32 <merijn> Ah, looks like it depends on defer-type-errors, so probably not
02:10:57 <cocreature> not sure but I seem to recall that TH works with defer-type-errors
02:11:58 <MarcelineVQ> alrightly well, ghc-as-a-lib or process calling out to ghc could inform your test executable about compilation success I guess  https://wiki.haskell.org/GHC/As_a_library#A_Simple_Example
02:12:47 <MarcelineVQ> Dunno how reasonable that is in a project as opposed to single-source files :X
02:12:58 <MarcelineVQ> *single source-files
02:13:05 <merijn> MarcelineVQ: Maybe, but I was hoping for something...more robust and finished. As tying my tests to GHC the library seems 1) very brittle, 2) really annoying to do, and 3) make me manually handle package dependencies, which would also suck
02:13:31 <merijn> It just seems someone else should have solved this problem for me already >.>
02:16:23 <tdammers> personally, I'd just shell out to GHC itself
02:17:38 <merijn> tdammers: Yeah, but I was hoping someone would've already setup the boilerplate for that sorta thing so I don't have to write my own harness to run these sorts of tests on Travis
02:18:01 <tdammers> well, GHC kind of has all that in place, but the test framework is written in Python
02:18:34 <maerwald> you shouldn't care what language your tests are written in
02:19:56 <merijn> tdammers: Right, but I can't just trivially copy GHC's testing framework for my small package without lots of work either :)
02:19:58 <jose_zap> merijn I'm not sure I follow. You want to to test if something compiles correctly without actually compiling it?
02:22:04 <merijn> jose_zap: No, I want to test that something *fails* to compile
02:22:38 <merijn> But anyway, I'll try cocreature's should-not-typecheck first and cross my fingers it plays nicely with TH
02:22:39 <jose_zap> oh ok, I understand now
02:30:02 <tdammers> merijn: haha, no, and I wouldn't recommend it... in fact, we'd love to see someone rewrite it in Haskell
02:31:31 <MarcelineVQ> It does pretty good for a 16 year old
02:42:43 <Boomerang> Is there a GHC extension to do lazy pattern matches by default? i.e write (a, b) = ... instead of ~(a, b) = ...
02:43:18 <merijn> Boomerang: Not that I know off and dear god I hope that never exists
02:43:57 <Taneb> Boomerang: that'd interact poorly with sum types
02:44:01 <Boomerang> Well since `Strict` and `StrictData` extensions exist, I was wondering if the lazy version also existed
02:44:22 <Athas> When would that be useful?
02:44:39 <Boomerang> I can see how it would be problematic if used too much
02:45:01 <Boomerang> We have some laziness issue in Clash, where signals are not lazy enough
02:47:25 <Boomerang> The extension (if it existed) would only be used in some modules that deal with lots tuples in recursively defined circuits. But we can live without such extension :)
02:55:31 <dmwit> dminuoso: Right.
02:56:21 <dmwit> koz_: If all you need is to list the elements, there is an `instance (Universe a, Universe b) => Universe (a, b)`.
02:56:47 <merijn> hmm, so how do people here deal with updating/fixing bounds on their packages. Just JIT them by waiting for someone to complain they broke? :p
02:57:08 <dmwit> That's what I do, but I'm a terrible maintainer.
03:00:10 <merijn> dmwit: I was just curious if there was some smarter approach :p
03:01:59 <jose_zap> merijn I let stackage tell me when something needs changing
03:08:20 <ski> Boomerang : one could perhaps argue that tuple patterns (as opposed to patterns for algebraic data types) themselves shouldn't force anything in themselves (but if a sub-pattern forces, then obviously the whole tuple would also be forced). i think this would help ensure that tuple types (and probably then also record types, if we had real such) are actually categorical products (taking partial elements into account). e.g. i think probably we'd get eta / ext
03:09:01 <ski> (hm, probably cut off near "... e.g. i think probably we'd get eta / extensionality for tuples")
03:10:23 <Taneb> (cut off at "eta / ext")
03:11:29 <Boomerang> Would there be any downsides to have tuple patterns not force anything?
03:14:08 <ski> i'm not sure how large adverse effects on efficiency (or relearning how to efficiently handle tuple patterns) it would have. i imagine an experimental extension, or perhaps a separate prototype would help with finding out. but first someone (or someones) should probably try to think about it from a theoretical perspective
03:15:16 <ski> conceptually, there's a distiction between a pattern which can fail, and one which can't (even if it can result in bottom)
03:16:31 <ski> so, perhaps it's not that good for tuple (and record) types to conceptually be thought of as algebraic data types which happens to have one data constructor
03:16:44 <Boomerang> Right, but in the case of tuple, it can't really fail anyway right?
03:17:39 <ski> e.g., i'm not sure whether, with `MonadFail', a `do'-command like `(x,y) <- blah' would implicitly involve `fail' or not
03:18:22 <ski> (i'd like it to not expand to `fail', and not impose a `MonadFail' (nor a `MonadZero') constraint)
03:18:58 <ski> Boomerang : yea, which would then be a starting point for argument for handling them differently
03:18:59 <Boomerang> Ah interesting example, but would blah still typecheck if it could fail the pattern match?
03:21:09 <ski> iow, then a pattern `(x,y)' would be classified as "cannot fail", and would possibly be implemented as `~(x,y)' is currently, while otoh, `(Just x,(y,z))' would be classified as "could fail", and would possibly be implemented as `(Just x,~(y,z))' is now
03:21:59 <ski> Boomerang : the point there, from a type POV is whether such a command introduces a `MonadFail' (or perhaps `MonadZero') constraint, or not
03:23:02 <Boomerang> So we would need to propagate "could fail" through the pattern match to figure out which parts can be lazily matched
03:24:04 <Boomerang> Thanks for your ideas/explanation, it's a bit more clear for me now. :)
03:31:19 <ski> Boomerang : yes, at least i think that'd be the sane thing to do, if something like this was considered
03:32:00 <ski> (if you were referring to the `(Just x,(y,z))' example)
03:33:07 <ski> hm, this reminds me .. do we have a way currently to match lazily on a function result ?
03:33:12 * ski ponders
03:34:50 <Boomerang> f (g -> ~x) = ... :D
03:35:02 <ski> well, in `foo :: (A -> B) -> ...; foo ~(($ x) -> y) = ..y..', the call to the function argument passing `x' of type `A' wouldn't be forced before `y' is forced
03:35:42 <ski> in your case, i think the call would happen during the initial pattern-matching
03:36:13 <ski> i'm asking since there's an analogy between tuple types (and record types), and function types
03:37:31 <ski> the change in tuple pattern semantics i was considering would allow `_|_' and `(_|_,_|_)' to be indistinguishable
03:38:36 <ski> iow, two tuples are equal iff all their corresponding components are equal. an extensionality property analogous to two functions being equal iff they give equal outputs for all possible inputs
03:40:16 <ski> however, currently we do allow the distinction between `_|_', and `\_ -> _|_', and possibly there are good pragmatic (like efficiency) reasons for that, considering that we're not in a total-and-productive language
03:41:58 <ski> but, possibly, one could still make the change i was considering above, for tuple patterns, but still, when one really needs to, allow forcing a tuple without forcing at least one component, if this was deemed an important enough possibility
03:42:57 <ski> one would lose (or rather not gain) tuple eta / extensionality, but possibly there would still be pragmatic gains, like in the example Boomerang started with
03:44:35 <delYsid> PointedList, thats what I was looking for
03:44:56 <ski> (so one would need to weight situations in which there's a pain to sprinkle `~'s all over against situations (is there any ?) where one'd like to retain capability to (solely) force tuples, perhaps without too much of a syntactic annoyance)
03:45:22 <ski> Boomerang : that's a couple more thoughts ..
03:46:09 <Ariakenom> Interesting thoughts. I sort of want an answer now ...
03:47:42 <ahri[m]> I'm using a GHC_OPTIONS pragma to specify "-O2" (and want to keep it there) but when loading the script into GHCI it doesn't like that; can I omit the optimizations for GHCI in some way?
03:48:32 <Boomerang> I think having this behind an extension pragma would be enough. I understand why the lazy pattern match extension I first asked about doesn't exist. But one restricted to tuple/records, with proper propagation of "could fail" would be useful :)
03:55:01 <merijn> ahri[m]: Why are you specifying -O2 via pragma, rather than just using ghc-options in the cabal file?
04:09:00 <merijn> cocreature: Sadly, -fdefer-type-errors doesn't work with typed TH, which makes sense, I suppose
04:09:31 <merijn> cocreature: So I need to figure out something else then using should-not-typecheck :\
04:10:52 <merijn> bah
04:14:12 <merijn> Looks like I'll have to shell out to cabal and mess with manual flags or something for this :\
04:24:29 <jose_zap> merijn you could also use ghc-mod as a library, but that's definitly harder than just to shell out
04:24:47 <merijn> How would ghc-mod help at all?
04:27:17 <jose_zap> you can use it to compile things from inside your program and it will report the failure if it does
04:28:41 <ahri[m]> merijn: because I'm using an executable script via stack's 'runghc' - like https://github.com/ahri/random-game/blob/master/random-game.hs
04:29:46 <ahri[m]> I find this a useful format for cross-platform scripts I'd like to replace my more complex bash scripts with
04:30:42 <merijn> I think I have a solution, I forgot I could just abuse "runQ"
04:30:58 <merijn> Now I just need to figure out which exceptions TH can throw
04:32:12 <MarcelineVQ> ahri[m]: runghc?
04:34:17 <MarcelineVQ> oh I see it here in the docs
04:36:20 <merijn> Can I somehow print the type of an expression at runtime?
04:36:31 <merijn> Because I don't know which exception is being thrown...
04:38:42 <cocreature> merijn: Exception has a Typeable superclass constraint so you can use "typeOf"
04:39:39 <merijn> cocreature: Yeah, I just figured out TypeRep is Show-able
04:40:00 <merijn> Somewhat relatedly, anyone know if/how I can silence TH error reporting?
05:03:06 <merijn> dminuoso: I finally got around to making the examples of validated-literals actually buildable and turn them into actual tests, so if the tests actually pass on travis I'll put a new release on Hackage and then start worrying about revising the API to actually be somewhat more usable
05:03:23 <merijn> dminuoso: But then you can at least start depending on the hackage version :)
05:15:06 <merijn> ugh...I wish pipes' SafeT would just an MonadUnliftIO instance :\
05:17:36 <max3> how the heck do the eta reductions in haskell ide engine work?
05:18:44 <ahri[m]> can I use CPP ifdefs to detect GHCI?
05:21:17 <Boomerang> ahri[m]: You could start ghci with: ghci -DGHCI=1 and then use `GHCI` in your CPP
05:22:03 <ahri[m]> ah I see, I'll give that a try! thank you
05:29:08 <ahri[m]> Boomerang: that did work very nicely, but as it turns out 'runghc' counts as --interactive so I can't use -O2 anyway :(
05:30:29 <ahri[m]> https://www.reddit.com/r/haskell/comments/24fxv3/a_simple_alternative_to_runghc_which_compiles_the/ch6tktc --- hmmmm
05:31:25 <max3> is strict haskell a thing?
05:32:13 <merijn> max3: Depends on how you define "haskell" and "a thing"
05:32:21 <ahri[m]> according to https://www.systutorials.com/docs/linux/man/1-runghc/ "runghc is considered a non-interactive interpreter" - so why can't I use -O2?
05:32:33 <max3> by a "thing" i mean mature technology with large community :)
05:32:41 <max3> don't know about the other one
05:32:58 <merijn> ahri[m]: Because it uses the bytecode interpreter that ghci uses and -O2 doesn't work with the bytecode interpreter
05:33:22 <merijn> max3: Strict Haskell pretty directly contradicts the Haskell report, so in that sense wouldn't be a Haskell at all
05:33:34 <merijn> max3: There's the Strict and StrictData extensions, but they're pretty new
05:34:26 <max3> merijn, thanks
05:35:16 <mnoonan> purescript is kinda a strict haskell, if you squint hard enough
05:36:55 <max3> another question: is there really no way to enforce type class laws? is that undecidable or something like that?
05:37:45 <dmwit> It is undecidable in general. There are languages where the analog of type classes come along with proofs that the laws hold, and it is up to the instance writer to create those proofs.
05:38:37 <merijn> There's plenty of ways to enforce typeclass laws
05:38:42 <ahri[m]> merijn: that makes sense; I wonder why the manpage says it's non-interactive :\
05:38:58 <max3> dmwit, sorry and those proofs are verified by the compiler?
05:39:00 <merijn> Social ostracization is a very effective one
05:39:02 <dmwit> max3: yes
05:39:04 <max3> merijn, lol
05:39:07 <max3> dmwit, interesting
05:39:12 <merijn> ahri[m]: Because it's not interactive in the way ghci is
05:40:08 <dmwit> max3: But the compiler does not *create* the proofs in the first place -- that's the undecidable part, so it's left to humans who obviously (*snicker*) are better-equipped to solve undecidable problems.
05:40:32 <max3> sure
05:41:26 <NinjaTrappeur> Hey, how do you manage your import sections? Do you use a tool to order/align them? A home-baked s
05:41:28 <NinjaTrappeur> cript?
05:41:50 <dmwit> NinjaTrappeur: For ordering I use :!sort; for alignment I use Tabular.
05:42:29 <dmwit> NinjaTrappeur: Line 42 of https://gist.github.com/dmwit/88c2c9806191075b32b491864efaafc9 has the mapping I use.
05:42:45 <NinjaTrappeur> dmwit, which delimiter do you use for Tabular? 
05:42:50 <NinjaTrappeur> dmwit, thanks!
05:47:32 <cocreature> I use the thing built into haskell-mode
06:07:41 <NinjaTrappeur> I use vim :( Regarding the sort part, how do you deal with multiline imports? Do you just substitute \n to another delemiter, sort and substitute back or do you have another clever trick?
06:07:57 <NinjaTrappeur> thanks for the suggestion cocreature :)
06:10:33 <jose_zap> NinjaTrappeur you could also use stylish-haskell or hindent
06:12:57 <cocreature> hindent doesn’t support imports iirc
06:13:11 <jose_zap> it does
06:13:32 <jose_zap> it does not align them, though. As it does not align anything else
06:15:07 <jose_zap> and britanny aligns them, but does not sort them
06:17:36 <cocreature> /support/sort/ not sure how I managed to typo this bad :)
06:17:58 <cocreature> oh looks like hindent also sorts these days
06:21:35 <inkbottle> [feeling dumb] I put that in hello.hs: f 0 = 1\\ f n = n * f (n-1)\\ Then I do "M-x intero-repl-eval-region"; then `f 3`; and I get a "stack overflow" (ref: https://orgmode.org/manual/Code-block-specific-header-arguments.html)
06:23:04 <cocreature> inkbottle: I don’t know how intero-repl-eval-region works but I wonder if you might end up overwriting the first definition with the second instead of defining "f" by two equations
06:23:15 <cocreature> that would turn f 3 into an infinite loop
06:23:23 <inkbottle> Yes, sure
06:24:24 <inkbottle> What is also puzzling me, is how they manage to have the org-mode example from above url, working in the first place?
06:25:38 <inkbottle> I'm trying to get into literate programming, org-mode way, to organize my code: so far I've got real difficulties getting in it
06:27:39 <inkbottle> IMO, I should first stick to *tangle*; and leave interactive evaluation for later (after the example above, I don't know how, "intero" is dealing with it; and that itself could require some learning curve)
06:28:28 <inkbottle> cocreature: thanks for the feedback, that was my guess too, but I really was feeling stupid nevertheless
06:28:29 <NinjaTrappeur> jose_zap, just tried stylish-haskell, it's just what I was looking for. Great tool! Thanks!
06:30:14 <jose_zap> cool!
06:36:40 <oscarvarto> Hi! Is there any good way to execute Haskell code in a markup (e.g. Emacs Org Mode, markdown)?
06:37:04 <oscarvarto> (markup language)
06:37:50 <Taneb> oscarvarto: what would that look like?
06:38:31 <cocreature> oscarvarto: something like https://github.com/sol/markdown-unlit?
06:39:23 <oscarvarto> Taneb, I love the appearance of LaTeX http://daniel-diaz.github.io/projects/haskintex/
06:39:54 <oscarvarto> But I also find it somewhat hard/distracting to write
06:40:10 <oscarvarto> That's why I was thinking of a markup language
06:41:32 <barrucadu> oscarvarto: If you use org-mode, you could use its literate programming functionality
06:41:33 <oscarvarto> As a matter of fact, I've never tried Literate Haskell (Haskell beginner here)
06:42:01 <oscarvarto> Thanks everybody for responding and helping me.
06:42:19 <oscarvarto> Taneb, cocreature, barrucadu 
06:43:55 <oscarvarto> barrucadu, Is it possible to evaluate haskell blocks of code that depend on *others* in Org-Mode?
06:45:00 <barrucadu> I've no really used it, but if nothing else, you can use org-babel-tangle to extract all the Haskell into a single separate file
06:45:32 <oscarvarto> Oh!
06:45:50 <oscarvarto> emacs has a lot of functionality/power
06:46:00 <inkbottle> intero-repl-eval-region: https://lpaste.net/8193890684063711232, would there be other emacs repl working on that example?
06:47:37 <inkbottle> oscarvarto: is it emacs org-mode time ;) 
06:48:18 <inkbottle> How does the example I pasted above works for you?
06:48:38 <inkbottle> work*
06:49:37 <merijn> hmmm, should I stick with "old" sdist/haddocks for now? I was trying to upload a new-sdist tarball, but it's telling me the package is invalid
06:51:26 <oscarvarto> inkbottle, :) I like emacs. I have enjoyed spacemacs because it uses Vim "modes".
06:54:20 <inkbottle> I'm going to ask #haskell-stack, if they "do" intero ;)
06:56:17 <merijn> ah, forgot the --haddock-for-hackage flag
07:05:04 <atchoum> > foldl (\_ x -> x + 1) 0 [1..100000]
07:05:07 <lambdabot>  100001
07:05:15 <atchoum> > foldr (\_ x -> x + 1) 0 [1..100000]
07:05:17 <lambdabot>  100000
07:05:23 <atchoum> it's weird isn't it ?
07:05:47 <atchoum> also foldl is much more fast
07:05:54 <Solonarv_> not *that* weird
07:06:27 <Ariakenom> :t foldl
07:06:28 <atchoum> > foldl (\x _ -> x + 1) 0 [1..1000000]
07:06:29 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
07:06:30 <Ariakenom> :t foldr
07:06:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
07:06:32 <lambdabot>  1000000
07:06:32 <Solonarv_> in the foldl example, you're ignoring the accumulator, so the result is just (last xs + 1)
07:06:32 <atchoum> yes
07:06:37 <atchoum> i'm dumb
07:06:49 <Ariakenom> :p
07:06:52 <atchoum> didn't know the type signature was different
07:07:04 <Solonarv_> in the foldr example, you're ignoring the *element*, so you're just incrementing the accumulator 100000 times!
07:07:59 <Ariakenom> SolarAquarion: ... that seems correct though
07:08:30 <atchoum> actually, a hand written listLength is much slower than foldl/foldr
07:08:39 <atchoum> and length is much faster as well
07:09:01 <Ariakenom> atchoum: did you use foldl' ?
07:09:48 <EvanR> optimizations maybe have done the "'" automatically
07:12:24 <oscarvarto> inkbottle, I am trying the snippet you shared with me. But dealing with side issues right now. Thanks again!
07:12:53 <inkbottle> ;)
07:13:08 <inkbottle> tell me if you have it working
07:16:01 <oscarvarto> inkbottle, I think I am crazy. I am dealing with learning everything at the same time.
07:16:38 <oscarvarto> I have been using NixOS for a week. And still understanding and getting used to it
07:17:08 <oscarvarto> That's why it's taking much more for me to experiment.
07:21:44 <Ariakenom> You can do it oscarvarto !
07:25:07 <oscarvarto> Ariakenom, Thanks <3
07:25:22 <oscarvarto> I bet you are crazy too :)
07:26:59 <dmwit> NinjaTrappeur: Okay, I lied. For sorting I actually use dd and p, because my imports are very rarely far from sorted in the first place. =P
07:27:13 <dmwit> (And it is easy to adapt dd and p to multiline imports.)
07:38:29 <oscarvarto> inkbottle, I think I am hitting this on NixOS: https://github.com/NixOS/nixpkgs/issues/21495
07:42:18 <inkbottle> oscarvarto: Did you add a comment on that thread?
07:42:28 <merijn> dmwit: I just insertion sort my imports as I write code :p
07:42:45 <oscarvarto> nope
07:43:07 <oscarvarto> (not yet)
07:43:37 <dmwit> merijn: exactly =)
07:44:21 <dminuoso> dmwit: Ah then it makes perfect sense. Is there any de-facto reading material I should perhaps read first before diving further?
07:44:41 <merijn> dminuoso: Did you see my message earlier? :)
07:45:36 <dminuoso> merijn: Yes, was just about to get to that. Thanks! :)
07:46:30 <merijn> dminuoso: I'm think for a more "robust" future version I'm going to just require GHC >=8.0 so I can make Lift a superclass requirement for Validate and simplify things (since DeriveLift exists as of 8.0)
07:46:57 <merijn> dminuoso: Like https://github.com/merijn/validated-literals/tree/test
07:48:25 <merijn> That gets rids of the hackySpliceValid and should work properly for most/all cases. I just need to revisit the API to make polymorphic literals less obnoxious
07:48:52 <dminuoso> merijn: That might force orphan instances though
07:49:43 <merijn> dminuoso: I think it's not so bad, because mostly you'd want to use this with your own datatypes (else you have orphan Validate instances anyway)
07:50:24 <inkbottle> oscarvarto: They have a list, or group, somewhere (stack); they also have an irc channel here: #haskell-stack; beside that, I don't think they really have the manpower to deal with distro related bugs; stack and intero do work, there are flows, but; better see that with stack's team
07:50:41 <merijn> And you can StandaloneDerive those Lift instances anyway (for almost everything, anyway) ByteString needs a bit of hackery, but it's not so bad
07:50:58 <inkbottle> flaws*
07:52:03 <merijn> dminuoso: Anyway, for now I'm just going to leave it as-is while I let ideas for a more robust/production ready future version simmer in the back of my brain :)
07:52:31 <merijn> dminuoso: The advantage of requiring a Lift instance is that it guarantees the computation of the conversion is done at compile time too
07:53:56 <merijn> dminuoso: Lemme know how it works out/what annoyances you run into :)
08:00:59 <dmwit> dminuoso: TAPL, perhaps
08:01:01 <dmwit> ?where TaPL
08:01:01 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
08:01:52 <oscarvarto> inkbottle, thanks for the suggestion
08:20:00 <NinjaTrappeur> dmwit, :) fair enough. I've been testing out stylish-haskell for the last hour or so. Did not bite back, unlike lot of styling tools. Would recommand :)
08:30:01 <delYsid> How do I get reverse-dependencies from cabal?
08:31:53 <c_wraith> I don't think cabal does that.
08:32:17 <c_wraith> try https://packdeps.haskellers.com/reverse instead
08:32:28 <delYsid> nice, thanks.
08:34:46 <Boarders> In lens what is the idiomatic way to get the element at the ith place in some indexable structure?
08:35:01 <Boarders> at the moment I am using: singular (ix i)
08:36:05 <dminuoso> :t at
08:36:06 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
08:36:45 <Taneb> :t singular
08:36:46 <lambdabot> (Functor f, Conjoined p) => Traversing p f s t a a -> Over p f s t a a
08:37:17 <Taneb> Boarders: because we don't necessarily know that ix i will hit a target, there's not a lens provides for most instances of Ix
08:37:48 <Taneb> Some, notably Map, have an instance of At, which provides at as dminuoso showed, which gives a lens to "Maybe a", allowing you to delete and insert
08:38:08 <Taneb> Boarders: but if you know that there's an element there, singular (ix i) should be fine
08:38:44 <phadej> > [1,2,3] ^.. singular traverse
08:38:47 <lambdabot>  [1]
08:38:51 <phadej> > [1,2,3] ^? singular traverse
08:38:54 <lambdabot>  Just 1
08:38:56 <phadej> > [1,2,3] ^?  traverse
08:38:59 <lambdabot>  Just 1
08:39:01 <phadej> > [1,2,3] ^?  ix 2
08:39:04 <lambdabot>  Just 3
08:39:09 <Taneb> > [1,2,3] ^. singular traverse
08:39:12 <lambdabot>  1
08:39:35 <phadej> > [] ^. singular traverse
08:39:38 <lambdabot>  *Exception: singular: empty traversal
08:39:58 <Boarders> cook, that makes sense. Thanks!
08:40:10 <phadej> > [] ^? ix 1 
08:40:13 <lambdabot>  Nothing
08:40:21 <Boarders> cool*
08:40:27 <phadej> so... singular is like `fromJust`
08:40:41 <phadej> waiting for a foot to appear in focus
08:40:47 <delYsid> dmwit: You were right, switching away from a list and an index to Data.List.PointedList was what I needed.  PointedList even comes with a focus lens, which came very handy actually.
08:45:39 <kamatsu> @free (a -> a)
08:45:39 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
08:45:46 <kamatsu> @free id :: (a -> a)
08:45:46 <lambdabot> f . id = id . f
08:46:03 <kamatsu> @free filter :: (a -> Bool) -> [a] -> [a]
08:46:04 <lambdabot> $map f . filter (g . f) = filter g . $map f
08:46:50 <ChaiTRex> :t $map
08:46:51 <lambdabot> error:
08:46:52 <lambdabot>     parse error on input ‘$’
08:46:52 <lambdabot>     Perhaps you intended to use TemplateHaskell
08:48:49 <c50a326> How can I apply the MonadWriter constraint to this? https://lpaste.net/8203451916919767040
08:52:40 <cocreature> c50a326: change the type to MonadWriter [String] m => m Int
08:53:03 <ChaiTRex> Is there a way to get a write-only Handle that stores what's been written to it as a String?
08:53:52 <ChaiTRex> I'm trying to run a bunch of programs at the same time but not have their inputs writing to stdout and stderr at the same time.
08:57:58 <cocreature> ChaiTRex: the process package provides various facilities for capturing the output of processes that you spawn, e.g., readCreateProcess
08:59:20 <dminuoso> Okay I think its time to write a DHCPv6 server combinator framework.
08:59:36 <dminuoso> Beats writing stupid C++ hooks for Kea. :(
09:20:26 <ChaiTRex> cocreature: Thanks.
09:27:19 <c50a326> cocreature: that gives me:  Non type-variable argument
09:27:21 <c50a326>         in the constraint: MonadWriter [String] m
09:28:09 <c50a326> I've defined `newtype Writer w a = Writer { runWriter :: (a, w) }` myself in the code, rather than importing the package
09:28:35 <c50a326> import           Control.Monad.Writer.Lazy (tell, MonadWriter) -- done this though... ah I guess I need to write a err.. class thing...
09:30:19 <c50a326> yeah my bad
09:56:00 <cocreature> c50a326: the error message should also tell you that you can turn on FlexibleContexts to fix the error
10:19:12 <c50a326> what is the ~ in `writer ~(a, w) = (w, a)`
10:19:24 <c50a326> ah keyword
10:19:49 <c50a326> so new hoogle doesn't do keywords, old hoogle for that, ok
10:20:40 <cocreature> c50a326: it’s a lazy pattern match
10:27:26 <dyl> How have I never seen zip <*> tail before?
10:27:47 <dyl> > let pairs = zip <*> tail in pairs [0..10]
10:27:50 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
10:29:16 <Boarders> its the S combinator
10:30:58 <dyl> Boarders ?
10:31:45 <Boarders> there is a combinator in lambda caluclus called S, that is implemented by applicative for (->) Z
10:31:59 <Boarders> as described here: https://en.wikipedia.org/wiki/SKI_combinator_calculus
10:32:13 <dyl> I'm aware of SKI, just not the relationship to (->) Z
10:32:17 <Boarders> feel free to just ignore, it is an obnoxious comment tbh
10:32:44 <Boarders> S x y = x <*> y
10:32:45 <dyl> I'm more trying to work out zip <*> tail on paper currently.
10:33:13 <dyl> S x y z = (x <*> y) z is a little clearer to me haha.
10:34:43 <dyl> Rewriting out (->) hurts my head a bit.
10:35:03 <cocreature> dyl: if you remember that (->) e and Reader e have the same Applicative instance, it might get easier
10:35:37 <dyl> It's more just syntactically my brain doesn't want to rewrite ->.
10:36:01 <dyl> Even just substituting it in makes something twitch haha.
10:36:41 <nshepperd> zip'ap'tail is a fickle god. he reveals himself to those only in dire need
10:36:59 <nshepperd> sorry, zip`ap`tail
10:37:14 <dyl> You could make a religion out of this.
10:38:12 <dyl> Google provides many mentions of "zip`ap`tail, the Aztec god of consecutive numbers:".
10:38:28 <nshepperd> hah
10:38:43 <dyl> "The answer is not only compiler specific, but also depends on the options the compiler is given, and probably the phase of the moon and how pleased the god zip`ap`tail is at the moment of compilation."
10:39:10 <dyl> Surprisingly quite a few results.
10:40:01 <dyl> Boarders seeing it written out f <*> g = \x -> f x (g x) I see the S combinator now.
10:41:03 <dyl> i.e. x <*> y = \z -> x z (y z)
10:42:32 <dyl> I was also for some reason parsing ((->) r) as functions with domain r, rather than codomain.
10:45:47 <phadej> well,(-> r) is so close
10:46:07 <dyl> This is neet: https://lpaste.net/144465
10:46:09 <dyl> neat*
10:46:20 <dyl> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
10:46:23 <lambdabot>  "314159265358979323846264338327950288419716939937510582097494459230781640628...
10:46:25 <dyl> cute.
10:46:40 <dyl> edwardk has there been any progress since 2015 on golfing e/pi?
10:46:48 <dyl> > (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
10:46:51 <lambdabot>  "271828182845904523536028747135266249775724709369995957496696762772407663035...
11:01:16 <Zipheir> I'm attempting to prove the associative law for the list monad and seem to be stuck. Any hints? (This is personal homework) https://lpaste.net/1158761487603335168
11:03:48 <atchoum> demonstration of associativity is almost trivial
11:04:03 <atchoum> you have to show that x(yz) = (xy)z IIRC
11:04:30 <atchoum> it's mappend you are after ?
11:04:52 <atchoum> I mean associativity is defined for an operator
11:05:29 <nshepperd> Zipheir: aren't you almost there? it looks like the last lines are the same except for s being named in the RHS
11:06:10 <nshepperd> oh, no it's not
11:06:27 <atchoum> :t (>>)
11:06:28 <lambdabot> Monad m => m a -> m b -> m b
11:06:56 <Zipheir> nshepperd: It's a so-near-so-far sort of situation...
11:08:03 <atchoum> > (([1] >> [2]) >> [3]) == ([1] >> ([2] >> [3]))
11:08:05 <lambdabot>  True
11:09:00 <nshepperd> Zipheir: i think you need another map/concat identity to turn map s p into concat something?
11:09:03 <Zipheir> atchoum: It's not simple associativity with >>=, since p >>= (q >>= r) is a type error.
11:09:15 <atchoum> Zipheir: yes I see.
11:09:17 <atchoum> It seems complicated
11:09:49 <c_wraith> which is why it's sometimes nice to put that law in terms of (>=>) where it is just associativity.
11:09:50 <Zipheir> nshepperd: Yeah, that's what I've been looking for...
11:10:01 <atchoum> Zipheir: what I don't understand is why would you prove it specifically for lists only. IIANM, it could be the case for just any monad.
11:10:18 <atchoum> (IIANM) = (If I Am Not Mistaken)
11:10:29 <cocreature> atchoum: it holds for any Monad, so for each instance you have to prove that it holds for the instance to be valid
11:10:49 <atchoum> cocreature: you mean it's in the law :p
11:10:52 <cocreature> ofc if you assume that the instance is valid then there is nothing to prove
11:10:54 <Zipheir> atchoum: >>= expresses a specific computation, so there may be several possible ways to implement it for a given type.
11:10:56 <atchoum> but not in the compiler :p
11:11:05 <cocreature> sure
11:11:14 <atchoum> allright I get it. 
11:11:49 <atchoum> btw does the famous haskell test library is checking for validity of monadic instances ?
11:12:00 <atchoum> (I don't remember how it is called)
11:12:45 <cocreature> "checkers" has tests for associativity of Monad instances iirc
11:12:58 <nshepperd> Zipheir: you may need: concat . map concat = concat . concat
11:13:15 <Zipheir> nshepperd: Wait, is that a general identity?
11:13:20 <nshepperd> which you might need to prove, idk
11:13:48 <nshepperd> by case matching on :
11:14:00 <Zipheir> nshepperd: It seems intuitively clear, I'll give it a shot.
11:14:11 <Zipheir> nshepperd: Thanks!
11:16:28 <nshepperd> it's actually secretly one of the monad laws also: join . fmap join = join . join
11:17:16 <Zipheir> Ah, I knew it looked familiar.
11:27:02 <Zipheir> nshepperd: Some sources also call this the 'bookkeeping law' of fold.
11:32:21 <Zipheir> OK, that was indeed the missing piece. Thanks all for your help!
11:57:56 <edwardk> dyl: not that i know of
12:03:09 <dyl> edwardk I'm thinking it should be possible with Indexed*
12:03:25 <dyl> Just make a list of zippers to the underlying list's elements and then pair them up.
12:03:41 <dyl> Might be easier to just use Ref.
12:38:04 <ski> @quote aztec
12:38:04 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
12:38:06 <ski> dyl : "I was also for some reason parsing ((->) r) as functions with domain r, rather than codomain." -- the *domain* is specified to be `r'. `(->) r' (which we could write as `(r ->)' if we had type operator sections, to be distinguished from `(-> r)', which would be `r' as codomain) applied to a type `a', i.e. `(->) r) a' equals `r -> a'
12:53:14 <dyl> ski mixed up when I typed haha.
12:53:22 <dyl> That's what I meant.
12:53:59 <dyl> Generally speaking, how would one differentiate applicatives and monads from the perspective of what kinds of control flow are possible?
12:54:10 <dyl> Or rather, how would you describe the difference? 
12:55:52 <ski> dyl : "static sequencing" vs. "dynamic sequencing"
12:55:55 <Solonarv_> monads can use the "a" in "m a" to decide what to do next, applicatives can't
12:55:59 <ski> (my terms)
12:56:01 <dyl> ski yay, thank you
12:56:03 <stevenxl> Hi everyone. If I have the following expression: "combineThreeComputations = computationOne >>= computation2 >>= computation3", how does the compiler parenthesis the expression? 
12:56:06 <stevenxl> Does it "see": combineThreeComputations = (computationOne >>= computation2) >>= computation3
12:56:06 <dyl> those terms fit my intuition nicely.
12:56:21 <Solonarv_> % :i (>>=)
12:56:22 <yahb> Solonarv_: class Applicative m => Monad (m :: * -> *) where; (>>=) :: m a -> (a -> m b) -> m b; ...; -- Defined in `GHC.Base'; infixl 1 >>=
12:56:24 <dyl> ski, bearer of the euphonic terrminology!
12:56:30 <stevenxl> Or "combineThreeComputations = computationOne >>= (computation2 >>= computation3)"
12:56:51 <ski> dyl : also see "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.com/2014/07/applicative-vs-monadic-build-systems.html>
12:56:57 <dyl> More specifically it seems to me that monadic effects can be chosen depending on intermediate results, whereas applicative effects can't.
12:56:57 <Solonarv_> stevenl: >>= is infixl, so it associates to the left. The first option is correct.
12:57:09 <dyl> So it's sort of like a pipeline (static sequencing) vs a dynamic pipeline.
12:57:16 <dyl> dynamic "pipeline" (it's not now)
12:57:22 <stevenxl> Solonarv_: thank you. How do I check in ghci the fixity of an operator?
12:57:22 <dyl> (it's really more like a general program)
12:57:30 <geekosaur> :i or :info
12:57:34 <stevenxl> ah yes
12:57:39 <stevenxl> thanks geekosaur 
12:57:44 <Solonarv_> stevenxl: :i (*)
12:57:54 <Solonarv_> or whatever operator you want, instead of *
12:58:03 <ski> (or without the brackets)
12:58:04 <stevenxl> Solonarv_: thank you very much
12:58:10 <Solonarv_> :i is short for :info, it works on a lot of things
12:58:13 <Boarders> does anyone know if it is possible for hlint to suggest hints but only outside of a typeclass instance or how to turn off hints in a specific part of code (but not necessarily the whole module)
12:58:17 <Solonarv_> % :i Bool
12:58:17 <yahb> Solonarv_: data Bool = False | True -- Defined in `GHC.Types'; instance Eq Bool -- Defined in `GHC.Classes'; instance Ord Bool -- Defined in `GHC.Classes'; instance Show Bool -- Defined in `GHC.Show'; instance Read Bool -- Defined in `GHC.Read'; instance Enum Bool -- Defined in `GHC.Enum'; instance Bounded Bool -- Defined in `GHC.Enum'; instance Bits Bool -- Defined in `Data.Bits'; instance FiniteBits Bool -- Defin
12:58:28 * ski . o O ( `:info >>=' )
12:59:21 <ski> dyl : with idioms, aka applicatives, the "plumbing" is fixed / determined before the data starts flowing. with monads, not (in general)
12:59:57 <ski> (later "plumbing" can depend on intermediate values coming out from earlier "pipes")
13:00:57 * cocreature remembers the good old days of the “monad are pipes-war”
13:01:00 <ski> dyl : also, i'd argue that both idioms and monads are in a sense about sequencing (two somewhat different notions of sequencing, as noted), despite the fact that some monads are said to be "commutative"
13:01:01 <EvanR> could you say that this means you can't build a circuit that runs a particular monadic program
13:01:28 <EvanR> and for applicative you could
13:01:46 <geekosaur> diodes
13:02:01 <geekosaur> there are ways to make asymmetric circuits
13:03:09 <ski> dyl : the monad (and the idiom) *interface* expresses a kind of sequencing, just like a multiplication `X * Y * Z' expresses a sequencing. then it's another matter that the ordering doens't actually matter in all monads (nor idioms), just like `X * Y * Z = Y * Z * X' if `X',`Y',`Z' are say real numbers, but not (in general) if they're matrices
13:03:59 <kritzefitz> Does lens have something like a shorthand Getter like \d g -> to (maybe d $ view g)
13:04:21 <dyl> cocreature are you saying monads aren't just a monoid smart pipes!?
13:04:30 <kritzefitz> :t \d g -> to (maybe d)
13:04:31 <lambdabot> (Contravariant f, Profunctor p1) => b -> p2 -> Optic' p1 f (a -> b) (Maybe a -> b)
13:04:44 <dyl> (note to everyone else: they aren't)
13:04:48 <dyl> with*
13:05:28 <dyl> ski interesting exposition, thanks!
13:05:51 <ski> (dyl : i'm saying this since some have argued that thinking of monads (or idioms) as (partly) about sequencing is wrong/bad. i dispute that, while still arguing against a too simplistic (operational / low-level) idea of ordering. in the list monad, the sequencing corresponds to "loop nesting", e.g. .. and let's not mention the continuation monad)
13:06:02 <EvanR> if everything is a container, then everything can be pipes. which is a container missing two sides
13:06:55 <Ariakenom> wise words
13:09:21 * ski idly wants an internal language for group theory (and ditto for ring theory) where the trivial ("zero") subgroup (or ideal) is written as the empty set, singleton means the group generated from one element, union means the least subgroup containing both summands, &c.
13:09:57 <ski> (s/group generated/subgroup generated/)
13:11:29 <ski> (that was somehow apropos the current discussion, though i now have forgotten how)
13:15:04 <ski> (also, i want a relevant (substructural) logic, adapted to the problem of reasoning about multiplicity of roots of equations (like polynomial equations in ring theory). so the "set" of solutions is now a bag, since `elem(x,S) \/ elem(x,S)' is no longer equivalent to `elem(x,S)')
13:18:47 <dyl> EvanR I wrote a Javascript library that implements this idea. We also consider a container missing one side to be a "pipetainer".
13:18:54 <dyl> This seemed like the logical choice of terminology.
13:20:47 <EvanR> wouldnt that be a ... bottle
13:20:58 <[exa]> +1 for bottle
13:20:58 <Zipheir> EvanR: Hush.
13:21:20 <Boarders> I asked above but does anyone know how I can ignore a typeclass defintion with hlint e.g. if I want a suggestion for sum not to be used but to ignore it being defined for a Foldable instance
13:21:32 <Zipheir> 99 pipetainers of beer on the wall, 99 pipetainers of beer!
13:24:33 <geekosaur> gradualy converging on spacesuit?
13:26:16 <ab9rf> pipetainer
13:26:56 <ab9rf> a pipe should hve two missing sides
13:27:11 <ab9rf> a container has one missing side, so you can put things in or out, but not both
13:27:17 <ab9rf> a pipe has two missing sides
13:27:30 <ab9rf> :)
13:29:54 <tdammers> so... /dev/null?
13:30:20 <ab9rf> that's a black hole with a window
13:36:58 <EvanR> why not both?
13:46:37 <dyl> Other languages: "read the package documentation"
13:46:51 <dyl> Haskell: "watch a 2 hour ekmett talk" 
13:48:06 <dyl> ab9rf pipetainers are like latches
13:48:14 <dyl> When you put something in, the number of missing sides changes.
13:48:40 <dyl> This is formally backed by the pipetainerbinator calculus, which is Turing complete.
13:50:22 <Ariakenom> "pipetainers are like latches" The spawn of the devil here to lure our firstborns to IO and debauchery?
13:51:00 <cheater> when do i need to use masking?
13:51:31 <cheater> i used to know this, but this has enough edges that i think i need a good refresher
13:53:24 <[exa]> is difference list a pipetainer?
13:54:39 <cheater> sorry, what?
13:55:31 <cheater> the docs for base say that throwTo will suspend the computation in the target thread "until it is needed". how does one resume the computation?
13:55:51 <dyl> [exa] it's an *oriented* pipetainer.
13:56:04 <dyl> This is a stronger condition that supposes the existence of known "up and down" (or front and back)
13:56:18 <Ariakenom> !hoogle throwto
13:56:32 <Ariakenom> lol
13:57:17 <Ariakenom> cheater: I think it refers to evaluation
13:57:24 <[exa]> dyl: :]
13:57:50 <cheater> Ariakenom: hmm, i don't think that's what they mean.
13:58:15 <Ariakenom> You cannot resume the execution of the IO action
14:00:10 <ski> @hoogle throwTo
14:00:10 <lambdabot> Control.Concurrent throwTo :: Exception e => ThreadId -> e -> IO ()
14:00:10 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
14:00:10 <lambdabot> Control.Exception.Base throwTo :: Exception e => ThreadId -> e -> IO ()
14:01:15 <Ariakenom> " In GHC, an exception can only be raised when a thread reaches a safe point, where a safe point is where memory allocation occurs" Does fno-omit-yield fix this?
14:01:16 <geekosaur> my understanding of that is that a strict computation effectively becomes a lazy one — but it will generally produce bottom if evaluated?
14:01:20 <Ariakenom> https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Exception-Base.html#v:throwTo
14:02:04 <geekosaur> re masking, you use it if you are doing something that might lak a resource (memory, file descriptor, etc.) if interrupted at the wrong time, soyou mask untl that resource is recorded such that it can be cleaned up later
14:02:12 <geekosaur> *leak a resource
14:04:37 * ski . o O ( spinning tops )
14:05:08 <Ariakenom> indeed. the effects of masking is that you won't receive asynchronous exceptions
14:06:13 <nshepperd1> I take that to mean that a thread that receives an async exception while it's evaluating some value t won't cause t to become bottom
14:06:56 <nshepperd1> Instead t will stay unevaluated and you can try to evaluate it again later
14:08:36 <cheater> geekosaur: what about if i'm doing something i would like to finish so data on disk can stay in a clean state? no leak, but it would mess up the data
14:09:27 <ski> (sometimes it would be nice to have something a bit like a weak reference : you can force it, but you can also tell it (via `IO' probably) to revert back to its non-forced state (to conserve materialized space used by the forced value) .. or perhaps the GC could do that instead)
14:09:34 <geekosaur> cheater, do that some other way; masking interrupts has rather violent effects on the runtime and management of other threads, masking should be for as brief a time as possible
14:09:50 <geekosaur> ski, there's been some work n revertible CAFs iirc?
14:10:12 <ski> any link/reference handy ?
14:11:26 <cheater> ok
14:11:40 <cheater> thank you
14:12:34 <ski> (another somewhat related thing would be to have thunks which can have a succession of states. e.g. "improving intervals" used to represent computable real numbers. if you use an inequality to compare it with some other number, that forces it to change into a more refined interval, which can later be forced to an even smaller one)
14:12:49 * geekosaur looking
14:12:57 <geekosaur> ghc alrerady has a form of them, loks like
14:13:11 <ski> (or, you could have splay trees, or other stuff which can dynamically change representation)
14:13:29 <nshepperd1> With clone :: a -> a, you could do that
14:14:02 <ski> nshepperd1 ?
14:14:27 <nshepperd1> Store the unevaluated thing and its clone in a box, return the clone when you want to force it
14:14:58 <nshepperd1> Reverting the value would be throwing away the clone and making a new one
14:15:02 <dyl> CAF?
14:15:23 <nshepperd1> clone ~ a copy of a thunk
14:16:11 <ski> dyl : Constant Applicative Form, or somesuch, iirc
14:16:24 <ski> an implementation thing
14:19:10 <geekosaur> mrf, I don't knwo the right words to find it now :(
14:19:45 <ski> thanks for looking
14:20:04 <geekosaur> I'm still looking, it's just going to take a while.
14:22:15 <ski> if you find it, and remember to, you could perhaps use `@tell' or `MemoServ'
14:52:55 <exojelly> Is there "division" in ADTs? Square roots? Any meaningful interpretation of that?
14:53:13 <exojelly> rather, n-roots
14:57:24 <threewood> exojelly:  I don't understand your question, unless you're asking about the Floating type class
14:58:38 <geekosaur> they're talking about treating a type system as an algebra
14:58:55 <geekosaur> a tuple is a product (multplication)
14:59:06 <Rembane> Since there are Sum types and Product types, there should be Division types too.
14:59:12 <geekosaur> so they want to knwo what has been done wit the nverse
14:59:28 <stevenxl> https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types
14:59:56 <stevenxl> I don't see division.
15:00:00 <stevenxl> ;(
15:00:15 <geekosaur> I see mentions of it, btu this is an area of type theory I don't knwo much about
15:01:01 <exojelly> exactly what I'm talking about
15:17:08 <dmj`> sorting breaks streaming right
15:21:44 <jle`> for lazy linked list?
15:21:59 <jle`> yeah, you have to reach the nil before you can return the first item in the list
15:22:42 <jle`> exojelly: quotient types match nicely with the idea of division
15:23:08 <jle`> but they aren't really representable directly in a nice way using algebraic data types i think
15:27:53 <dmj`> jle`: yea, that's what I thought too
15:32:03 <abueide> when using ghcjs is there a network library that will work out of the box on web and ghc?
15:32:14 <exojelly> jle`, I'm having trouble imagining what a quotient type would be...
15:32:40 <exojelly> jle`, and how a type could have "one third of an inhabitant"
15:33:21 <geekosaur> suspctthat's right wheer ADTs don't represent them wel; its likely to be a more abstract notion
15:34:12 <phadej> exojelly: it's not type / type like "division"
15:34:25 <phadej> it's more like (Nat x Nat) / ??? = Rational
15:34:46 <phadej> sorry, (Integer x non-zero-Natural) /  ??? = Rational
15:34:48 <geekosaur> an example I'm looking at is modulus
15:34:51 <exojelly> Ah, I see
15:35:28 <dmj`> abueide: no :) 
15:35:40 <dmj`> abueide: what are you trying to accomplish
15:36:24 <phadej> geekosaur: indeed, modulus has better intuition
15:36:35 <abueide> a web app that works on ghc and ghcjs
15:36:50 <abueide> without me having to write different code depending on what platform its being compiled to
15:40:00 <dmj`> abueide: probably would require an abstraction over something like WebRTC and the haskell network library. AFAIK nothing like this exists. You can share types, but the nature of IO in both environments is very different, hard to cleanly abstract over both. 
15:40:17 <dmj`> abueide: what kind of application are you building?
15:41:01 <abueide> just a simple chat app that uses an http api
15:41:10 <abueide> that I wrote using servant
15:41:30 <infinisil> Hey, when I know a pattern will never occur, what's a good way to signal this to haskell?
15:41:41 <abueide> but i'm fine with rewriting the http api if there was a networking library that abstracted over both
15:41:47 <dmj`> abueide: I'd recommend websockets for a chat app
15:42:02 <infinisil> E.g. `foo [] = error "Will never occur"`
15:42:08 <infinisil> Or should I just not put the case at all
15:42:21 <infinisil> Or is there something better
15:42:40 <dmj`> abueide: miso has code for websockets that is pretty clean, would be good for a chat app
15:42:42 <dmj`> abueide: https://github.com/dmjio/miso/blob/master/examples/websocket/Main.hs#L38
15:42:57 <dmj`> infinisil: what is the signature of your function
15:43:53 <abueide> dmj`, so it would compile to ghcjs only, and I should probably just forget about compiling to ghc until a solution comes up
15:44:12 <infinisil> dmj`: Well I just used something like `foo :: [Int] -> Int` as an example here
15:44:32 <dmj`> infinisil: `foo :: [Int] -> Maybe Int` ?
15:44:43 <dmj`> abueide: well you'd need both. You can put directives in the cabal file for detecting which compiler you're using (ghc vs. ghcjs)
15:44:48 <infinisil> I know as a fact that this function should never ever be called with such an argument, the code around it will guarantee it
15:44:58 <infinisil> :t fromJust
15:44:59 <lambdabot> Maybe a -> a
15:45:04 <infinisil> Something like that ^
15:45:08 <dmj`> infinisil: fromJust is evil 
15:45:19 <dmj`> fromMaybe is better
15:45:26 <infinisil> I'm just asking if there's a way to signal that a case should never occur
15:45:34 <dyl> edwardk very funny typo in your lens talk's captioning https://imgur.com/Bkmy7u1
15:45:45 <dyl> "has become sport bab"
15:45:55 <dyl> > let sportBab = foldMap
15:45:57 <lambdabot>  <no location info>: error:
15:45:57 <lambdabot>      not an expression: ‘let sportBab = foldMap’
15:46:08 <dyl> @let sportBab = foldMap 
15:46:09 <lambdabot>  Defined.
15:46:38 <infinisil> Eh whatever, I'll use maybe then, even though my code guarantees it will never occur
15:46:46 <infinisil> Seems kinda pointless, but I guess if it makes haskell happy
15:47:13 <ChaiTRex> infinisil: You can use foo _ = error "This should never have happened. Please contact blah@blah.com" with a comment about why it will never occur.
15:47:17 <dmwit> infinisil: I prefer `foo [] = error "description of what went wrong"` to not having a `[]` case at all.
15:47:27 <ChaiTRex> infinisil: Then you can get error reports or something.
15:47:59 <infinisil> Alright, thanks
15:48:02 <ChaiTRex> infinisil: Plus the _ case has the benefit of being usable in non-list situations for unhandled cases.
15:48:17 <dyl> I'm pretty sure GHC can optimize unused pattern matches in some cases.
15:48:28 <dyl> Not that it really affects much of anything anyhow.
15:48:41 <dmwit> What does "optimize unused pattern matches" even mean?
15:48:59 <dyl> If it can be statically shown that a match is unreachable, it isn't in the Core output. 
15:50:05 <dmwit> How does that translate to a win (either on performance or memory usage) at the layer after Core?
15:50:42 <dmwit> (...or whatever metric it's a win on, I guess, if I forgot something.)
15:50:53 <ChaiTRex> There's no branch.
15:51:42 <ChaiTRex> Plus dead code elimination.
15:52:53 <dmwit> Dead code elimination sounds plausible. No branch I am still skeptical of.
15:54:27 <ChaiTRex> Well, not no branch at all necessarily, but no conditional jump to the dead code.
15:54:33 <dyl> https://haskell.godbolt.org/z/NlJxtj
15:55:00 <dyl> Notice that the error string isn't even in the resulting assembly.
15:55:20 <dyl> And head is 0) not branching, 1) inlined out.
15:55:31 <dyl> On the other hand, set foo l = head l...
15:55:35 <dyl> and you'll see the individual cases.
15:55:55 <dyl> as in here: https://haskell.godbolt.org/z/J78qBQ
15:56:52 <dyl> Or just export head, as then it can't optimize out that case.
15:59:11 <dyl> and here's a case where only one branch is optimized out, leaving two.
15:59:12 <dyl> https://haskell.godbolt.org/z/6PMKfq
16:03:03 <johnw_> Is there a way to increase verbosity of the GHC runtime linker is doing when it tries to load a module?
16:10:32 <lyxia> dyl: that's a pretty neat tool you got there
16:11:28 <lyxia> Isn't that optimization "just" inlining though
16:41:51 <EvanR> infinisil: in other languages, agda, idris, you can omit the case that will never occur
16:42:12 <infinisil> EvanR: Yeah, the "impossible" keyword in Idris
16:42:13 <EvanR> assuming the case would be a type error if it happened
16:43:04 <Solonarv_> can't you also omit case alternatives that would be type errors in haskell? (comes up when using GADTs)
16:43:52 <EvanR> in haskell, if the reason something is impossible is somewhere nearby in the code, so you can glance and verify the reason is still there whenever you want... then error. 
16:43:56 <EvanR> yeah Solonarv_ youre right
16:44:52 <EvanR> if this is a function used somewhere else, and the caller, whevever it is, never uses it incorrectly. i dont feel as comfortable with the error
16:45:40 <EvanR> its like quark physics, when the relevance code gets too far apart, bugs spontaneously form out of the quantum foam
16:45:45 <EvanR> relevant*
16:47:09 <slack1256> @where lpaste
16:47:10 <lambdabot> http://lpaste.net/
16:47:31 <EvanR> you can also require they pass a non empty list in a few waays
16:50:35 <EvanR> sometimes i would like a non-nothing Maybe, but I haven't seen a package for that one
16:51:05 <hpc> like Identity?
16:51:21 <EvanR> Definitely
16:51:35 <hpc> well have i got the type for you
16:52:00 <slack1256> https://lpaste.net/6936693111586291712
16:52:38 <slack1256> I got this .cabal file where if I don't build-depend on hmatrix{,-gsl} and gnuplot, the code doesn't compile.
16:52:52 <EvanR> newtype Definitely a = Definitely (Identity a)
16:53:06 <slack1256> But Main.hs is just importing RealMain from the library and running the realMain function defined there.
16:53:17 <slack1256> Should it fail when I remove those build-depends?
16:53:50 <dmwit> ?hackage OneTuple -- EvanR
16:53:50 <lambdabot> http://hackage.haskell.org/package/OneTuple -- EvanR
16:54:01 <dmwit> For when you want to make an unboxing video.
16:55:11 <dmwit> slack1256: No, it should not fail. What's in `Main.hs`?
16:55:23 <dmwit> slack1256: Oh, I bet I know what's going on.
16:55:42 <dmwit> slack1256: Move your `Main.hs` to a separate directory -- say, `bin` -- and update your `hs-source-dirs` to not include `src`.
16:55:52 <slack1256> main = realMain . Where realMain is defined on the module RealMain on the library stanza
16:55:57 <slack1256> Oh ok, let me see
16:56:05 <dmwit> slack1256: I suspect it is secretly recompiling `RealMain` instead of using the `RealMain` from your library.
16:58:15 <slack1256> dmwit: That was it.
16:58:46 <slack1256> Somehow declaring hs-source-dirs twice on the same stanza wreck havoc on the compilation.
16:58:52 <slack1256> Thanks dmwit.
17:30:37 <EvanR> dmwit: maybe there should be a class the unify all the 1-tuple isomorphic data structures
17:34:02 <jackdk> Coercible?
17:49:07 <infinisil> What's the easiest way to execute `x <- f; y <- g` in parallel in an IO monad?
17:49:28 <infinisil> One of the calculations is actually pure, but lifting to IO should be fine
17:49:39 <slack1256> forkIO ?
17:49:49 <slack1256> forkIO + MVars
17:49:55 <infinisil> Ohhh, STM, right
17:50:25 <slack1256> More rudimentary. Just forkIO and a MVar as shared memory location
17:51:54 <slack1256> do { box1 <- newMVar ; box2 <- newMvar ; forkIO ( do x <- f ; putMVar box1 x ) ; forkIO (do y <- g ; putMVar box2 y) ; value <- takeMVar box1 ; do stuff with bx1
17:52:00 <c_wraith> be careful that you actually do the evaluation of the pure value in the different thread.
17:52:21 <c_wraith> otherwise it will fork to create a thunk, doing basically nothing.
17:52:59 <infinisil> Hmm..
17:53:57 <infinisil> { box <- newMVar; forkIO $ do { x <- f; putMVar box x }; y <- pure g; x <- takeMVar box; <stuff with x and y> }
17:53:59 <infinisil> How about that?
17:54:45 <c_wraith> you can just do let y = g
17:54:54 <c_wraith> but yeah, that looks right.
17:55:29 <infinisil> Is there no way to force a pure value to be evaluated on the main thread while the other thing gets processed in the background?
17:55:31 <Axman6> infinisil: usew the async package
17:55:58 <c_wraith> infinisil, there's always evaluate
17:56:09 <Axman6> https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:concurrently
17:56:40 <c_wraith> Axman6, that doesn't help at all with the thunk issue
17:56:51 <xpoqp> Does anyone know why it is that my stack script cannot construct a build plan, "base-4.8.2.0 must match >= 4.3 && <4.8 (latest applicable is 4.7.0.2)", when I have explicitly added "--package base-4.7.0.2" to my script?
17:57:10 <c_wraith> you can't set a version of base. it's wired in to ghc
17:57:16 <Axman6> concurrently (f >>= evaluate) (g >>= evaluate)
17:57:25 <xpoqp> I see, thanks
17:57:33 <infinisil> c_wraith: Oh neat, didn't know about evaluate
17:58:25 <infinisil> Axman6: Oh that looks promising
17:58:42 <sm> xpoqp: effectively, base is set by the resolve you choose
17:58:47 <sm> resolver
17:58:57 <Axman6> the answer to "I need to do things concurrently in Haskell" is very often the async package
17:59:03 <xpoqp> I tried to change resolver, but I always get the same
17:59:12 <xpoqp> not quite sure which resolver I need though.
17:59:19 <sm> rather: the resolver sets the ghc version, which provides base. You probably have some other deps requiring a different base
17:59:28 <infinisil> Axman6: Wouldn't that create 2 other threads though?
18:00:54 <c_wraith> infinisil, it may, it may not. doesn't really matter.
18:00:55 <Axman6> yes, but threads in GHC are extremely cheap
18:01:44 <MarcelineVQ> xpoqp: quite an old one based on that constraint.  base <4.8 means ghc 7.8.*  https://wiki.haskell.org/Base_package   which is lts-2.22  https://www.stackage.org/
18:02:18 <infinisil> Alright, neat
18:02:26 <xpoqp> I see, thanks
18:03:04 <infinisil> Probably not worth doing what I do asynchronously, the pure operation of these 2 is extremely cheap
18:03:11 <infinisil> tbh
18:03:35 <infinisil> But nice to know, I'll consider using async when I need async stuff
18:04:04 <MarcelineVQ> infinisil: your bible:  https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
18:04:10 <Axman6> you can happily run tens of thousands of Haskell threads at once btw. they are extremely low overhead
18:05:15 <xpoqp> that's interesting though, these are dependencies on matlab library, simply wanted to import matlab format files into my program, but 2.22 is too old for my other needs so I suppose I'll have to write the matlab format loader myself
18:06:03 <MarcelineVQ> xpoqp: We're at the limit of what advice can be given without seeing the script
18:07:47 <infinisil> MarcelineVQ: Nice
18:08:25 <sm> xpoqp: this is normal if you're depending on some ancient hackage package that hasn't been updated for recent ghc, you can see if they have a newer unreleased version, or report a bug, or try to update its cabal bounds yourself
18:09:46 <MarcelineVQ> matlab isn't on stackage, that I can see, so using it in a stack script isn't too good of an idea already due to needing extra-deps. you should probably make a project for what you're doing
18:30:12 <xpoqp> is making a project going to help me?
21:21:23 <mniip> hmm
21:21:27 <mniip> is Hask small
21:26:47 <mniip> I suppose it's just the types that can be described by a finite program
21:33:01 <jle`> @tell exojelly for data types, quotient types are basically about redefining equality and what you can observe about a type. "dividing by three" would be reducing the number of distinguishable items by a factor of three
21:33:01 <lambdabot> Consider it noted.
21:37:58 <cosjelly> jle`, just came back actually. Thanks! Is there a way "how" quotient types reduce the number? In Sum Types, Product Types and Functions it's always clear to me how to construct the inhabitants.
21:38:31 <cosjelly> jle`, but if the only thing is "reduce the number", my first question would be... which inhabitants?
21:39:03 <jle`> essentially it collapses inhabitants into groups and erases details between items in the group
21:39:17 <cosjelly> ah...
21:39:22 <jle`> we're talking about abstract types here
21:39:28 <cosjelly> yeah
21:39:39 <jle`> for example we can essentially "quotient" Int by two, by doing (`div` 2)
21:39:55 <jle`> or well, (`div` 2) before any operation you can do with it
21:40:10 <jle`> essentially this reduces the observable elements to half of Int
21:40:40 <geekosaur> cosjelly, you mihthave missed it before, but one example is modular arithmetic
21:41:07 <cosjelly> jle`, ah... that makes sense
21:41:13 <cosjelly> geekosaur, oh, I think I did, indeed
21:44:12 <jle`> if you're familiar with lenses, i also like to think of lenses as representing quotient types too
21:44:39 <cosjelly> that's a good point actually. Am familiar with lenses, at least somewhat.
21:45:00 <jle`> a `Lens s a` means that 'a' is a quotient of 's' by some abstract/theoretical type
21:45:09 <jle`> for example _1 is a quotient of (a, b) by b
21:45:32 <jle`> it can be fun checking that the math works out
21:45:43 <jle`> we're considering that _1 :: Lens' (a, b) a
21:45:51 <jle`> * `Lens' s a`, from above
21:46:18 <jle`> all legal lenses arise from some abstract quotient
21:47:24 <jle`> i explore this a bit in https://blog.jle.im/entry/lenses-products-prisms-sums.html
21:48:11 <mniip> jle`, sounds like it's a bit stronger than just quotient
21:48:17 <mniip> almost like a covering space of some sort
21:48:39 <mniip> in the sense that it needs to actually "factor" into the quotient times something else
21:49:34 <jle`> ah yeah, indeed
21:49:47 <shachaf> Lens' s a = exists e. s <-> (e,a)
21:50:09 <shachaf> (And similarly for prisms and sums, and so on for some other things.)
21:50:58 <shachaf> Also if this perspective is credited to anyone it should probably be rwbarton, who figured out what prisms are?
21:51:56 <jle`> shachaf: ah, thanks for the attribution, that's been something i have been looking for for a while :)
21:52:02 <shachaf> https://lpaste.net/77766
21:52:13 <shachaf> Hmm, that paste doesn't have quite what I thought, but it's close anyway
21:58:05 <cosjelly> so, then... what about "root" types? (As in e.g. a square root)
21:58:15 <shachaf> Also writing profunctor optics as p a a -> p s s is a little silly
21:58:35 <shachaf> If you're not going to do type-changing you might as well use "[invariant] functor optics" instead.
21:58:40 <shachaf> forall a. p a -> p s
21:59:05 <shachaf> Oh, I guess it gets to it later.
21:59:43 <shachaf> I mean forall p.
22:00:33 <shachaf> I think it's more natural starting from the type-changing version but oh well, I'll probably never write my thing about that so I shouldn't complain.
22:13:06 <kamatsu> @free id :: a -> a
22:13:06 <lambdabot> f . id = id . f
22:13:24 <kamatsu> @free filter :: (a -> Bool) -> [a] -> [a]
22:13:24 <lambdabot> $map f . filter (g . f) = filter g . $map f
22:19:44 <dmwit> shachaf: The connection between lenses and product isomorphisms dates back to the 1980s.
22:20:13 <dmwit> Back then it was a database research question, and it was called "constant complement".
22:22:24 <dmwit> Not to say rwbarton didn't also notice it, but he wasn't the first to be sure.
22:23:26 <mniip> 1536641863 [07:57:43] <cosjelly> so, then... what about "root" types? (As in e.g. a square root)
22:23:31 <mniip> you mean logaritmic types?
22:23:56 <dmwit> I don't think they have anything specific in mind. They just discovered the algebra of types and are playing around in that sandbox.
22:24:30 <dmwit> And wondering whether sqrt is a sensible operation in that algebra and if so what it would correspond to.
22:24:55 <mniip> ok
22:43:54 <shachaf> dmwit: Well, sure. I was talking about prisms in that case.
