00:00:01 <MarcelineVQ> It's just something that could be checked fairly directly
00:02:02 <maerwald> MarcelineVQ: that's difficult to keep in sync, because I don't know what version of stack someone else is running and there is no easy way to sync that with the hpack version that is installed in the docker environment
00:02:15 <maerwald> it's really awful
00:02:36 <MarcelineVQ> Does it affect things though?
00:02:55 <maerwald> I don't know
00:02:57 <MarcelineVQ> I​ mean, does stack accept the cabal if it's made by the same hpack version
00:02:59 <MarcelineVQ> ok
00:04:05 * hackage dlist 0.8.0.5 - Difference lists  http://hackage.haskell.org/package/dlist-0.8.0.5 (SeanLeather)
00:04:06 <maerwald> I guess you just have to accept that stack is not an idiomatic unix tool
00:05:50 <dataN_> now it gives an unexpected error, why does the guard on Foldr1 not work? https://lpaste.net/8049189864312143872
00:05:54 <bartavelle> idiomatic unix tool, like systemd
00:06:01 <maerwald> ...
00:06:17 <maerwald> makes me wonder, should systemd bundle stack or vice versa?
00:06:33 <dataN_> it reaches XorSym1 'False : Foldr1 (TyCon2 (':) :.$$$ XorSym0) '[]
00:06:34 <bartavelle> systemd should obviously bundle npm first
00:06:38 <maerwald> "downloading GHC and systemd...."
00:06:54 <maerwald> "I noticed you don't have systemd installed, will do that for you, please run me as root"
00:07:20 <dataN_> jle: ^!
00:08:29 <maerwald> another possibility would be if I could tell stack to install hpack-$(stack --hpack-numeric-version) and pick whatever resolver satisfies this
00:08:36 <jle`> :t map (/=) [True, False]  -- dataN_
00:08:38 <lambdabot> [Bool -> Bool]
00:09:11 <jle`> oh, you're asking about foldr1
00:09:40 <jle`> hm, did the version with foldr already work?
00:09:45 <jle`> map f = foldr ((:) . f) []
00:09:53 <jle`> why are you using foldr1 here?
00:10:00 <jle`> but yeah, mapping xor gives you a list of functions
00:10:08 <jle`> @let xor = (/=)
00:10:08 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
00:10:19 <jle`> % let xor = (/=)
00:10:19 <yahb> jle`: 
00:10:32 <jle`> % :t map xor [True, False]
00:10:32 <yahb> jle`: [Bool -> Bool]
00:11:07 <jle`> you can map like `xor True` if you want a list of bools you can inspect nicely
00:12:29 <jle`> % map (xor True) [True, False]
00:12:29 <yahb> jle`: [False,True]
00:13:49 <MarcelineVQ> maerwald: There aren't any resolvers that satisfy hpack's dependencies for my stack <_<
00:14:06 <Hotkeys> this is essentially a cleaned up version of how i worked through the arcane powerset definition to grok it https://lpaste.net/7528033563338342400
00:14:10 <Hotkeys> featuring absurd whitespace alignment
00:14:46 <dataN_> Foldr1 is for Map
00:15:03 <MarcelineVQ> That is to say my stack uses an hpack with newer deps than any official snapshot provides
00:16:09 <dataN_> why does it not just return a list of functions then? this does not explain how it manages to try and apply Foldr1 to '[]
00:16:16 <maerwald> MarcelineVQ: haha
00:16:19 <MarcelineVQ> Mine's git though. I wonder how the versions line up for official bins.
00:16:30 <maerwald> MarcelineVQ: sounds like I have to write a whole wrapper :P
00:16:32 <dataN_> (guess Applicative is next...)
00:16:48 <dataN_> btw, is this not all does somewhere?
00:16:53 <dataN_> done*
00:19:33 <dataN_> jle': partially applying Xor with True gives; Eg :: [Bool] = 'False : 'True : Foldr1 (TyCon2 (':) :.$$$ XorSym1 'True) '[]
00:20:15 <jle`> dataN_: it does return a list of [Bool ~> Bool] yeah
00:20:16 <dataN_> the ' Foldr1 f (x ': '[]) = x' guard seems not to work...
00:20:22 <jle`> the FOldr1 is weird though. did it work with Foldr ?
00:20:31 <dataN_> how could it?
00:20:37 <jle`> how could it work with Foldr?
00:20:38 <dataN_> oh, not using Map...
00:21:10 <jle`> type family Map (f :: a ~> b) (xs :: [a]) :: [b] where
00:21:21 <jle`> oh you don't even need a type family
00:21:46 <jle`> type Map f xs = Foldr (TyCon2 '(:) :.$$$ f) '[] xs
00:21:50 <dataN_> it needs to guard against '[] which would upset Foldr1
00:22:20 <dataN_> :t ((:) . id)
00:22:21 <lambdabot> a -> [a] -> [a]
00:22:33 <dataN_> oh it hits a list at the end... doh
00:22:38 <dataN_> sorry
00:23:48 <jle`> i'm surprised your Foldr1 compiles, heh
00:24:16 <jle`> since foldr1 f (x:[]) = x is a clear type error
00:24:23 <jle`> as you have defined it
00:24:30 <jle`> "kind error"
00:24:39 <dataN_> no kind checker :-(
00:24:52 <jle`> ghc usually checks kinds doesn't it?
00:25:26 <dataN_> a /~ b
00:25:40 <dataN_> they have the same kind...
00:25:41 <jle`> hm but might be deferring the kind error
00:26:05 <jle`> dataN_: they have different kinds, since x has kind 'a' and the result is supposed to have kind 'b'
00:27:31 <dataN_> oh i mean its not a sort error.. maybe
00:27:48 <dataN_> nvm
00:29:44 <jle`> it might be a deferred error because of how kinds get passed to type families
00:32:19 <koz_> What do I need to import to get the kind 'Constraint' available?
00:34:34 <jackdk> GHC.Exts?
00:34:40 <koz_> jackdk: It is indeed - thank you!
00:34:47 <koz_> (not Data.Constraint or something)
00:35:05 <koz_> Also TIL that 'type' declarations can have kind sigs.
00:35:32 <koz_> Example: type ValueTypeIs (f :: * -> Constraint) t p a = (f (ValueType (Attribute t p a)))
00:35:34 <koz_> Totes compiles.
00:36:31 <dataN_> here is the complete example; https://gist.github.com/dataN-hs/93a90e281a4208e6c224bc967ca09600
00:43:13 <maerwald> is there a way to tell stack to look for a package version in all resolvers?
00:43:25 <maerwald> instead of just picking the latest resolver and then build it
00:47:13 <maerwald> and then fail
00:49:52 <koz_> jle`: Singletons are so useful!
00:50:09 <jle`> :O
00:50:29 <jle`> be careful if you mean if singletons are useful, or if being able to manipulate types as values is useful heh
00:50:35 <koz_> Lol.
00:50:46 <koz_> Thanks to that library, I can actually write things the way I wanted.
00:50:51 <koz_> Instead of having to do weird workaround hacks.
00:54:58 <koz_> jle`: Can you think of a way to make match less repetitive? https://lpaste.net/6508187952495984640
00:55:16 <koz_> I've tried to write a more general version of match_, but GHC gave me the textual equivalent of a middle finger.
00:55:37 <jle`> what's the repetitive part?
00:56:00 <koz_> case sng of SMandatory -> x `f` y SOptional -> maybe False (x `f`) y
00:56:13 <koz_> It's the same for each possible match_, just with different f.
01:08:04 * hackage aip 0.1.0 - Aeronautical Information Package (AIP)  http://hackage.haskell.org/package/aip-0.1.0 (qfpl)
01:12:26 <maerwald> also, there is a new stack release but no binaries yet?
01:14:23 <MarcelineVQ> kind of looks that way
01:14:28 <MarcelineVQ> https://github.com/commercialhaskell/stack/releases/tag/v1.9.0.1
01:16:29 <maerwald> guess what... they updated hpack
01:16:38 <maerwald> which is not even in the lts version stack is buildable with
01:17:00 <maerwald> (yeah, stack isn't buildable with its own latest lts)
01:19:07 <MarcelineVQ> *with just its own latest lts
01:35:59 <maerwald> https://github.com/commercialhaskell/stack/blob/98e50572f162ebc2ffb1c51a55f0c8504a93b992/subs/pantry/src/Pantry.hs#L413
01:43:03 <MarcelineVQ> so following the chain it's  https://hackage.haskell.org/package/hpack-0.31.0/docs/src/Hpack.html#mkStatus  that decides what's a 'new' cabal file
02:07:04 * hackage dense-int-set 0.1.5 - Dense int-set  http://hackage.haskell.org/package/dense-int-set-0.1.5 (NikitaVolkov)
02:08:34 * hackage indexation 0.6.0.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.6.0.1 (NikitaVolkov)
02:14:10 <sshine> let's say I have Just "foo?" and I want to know if it ends with a question-mark. I could (== Just '?') . join $ fmap lastMay $ (Just "foo?"), but I'm wondering if that could be expressed using other combinators.
02:15:28 <Boomerang> :t lastMay
02:15:30 <lambdabot> error: Variable not in scope: lastMay
02:15:33 <sshine> ("?" `isSuffixOf`) <$> Just "foo?" gives me Just True
02:15:44 <sshine> Boomerang, it's a safe version of last found in the safe package.
02:15:53 <Boomerang> @let lastMay [] = Nothing; lastMay xs = Just (last xs)
02:15:54 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
02:15:55 <sshine> lastMay :: [a] -> Maybe a
02:16:56 <Boomerang> How about: Just '?' == lastMay "foo?"
02:17:18 <sshine> Boomerang, I have Just "foo?", not "foo?"
02:17:43 <Boomerang> How about: Just '?' == (lastMay =<< Just "foo?")
02:17:58 <Boomerang> (which is what join . fmap is)
02:18:55 <sshine> yes, just like that. :)
02:18:59 <sshine> thanks!
02:19:01 <delYsid> > join $ lastMay <$> Just "foo?"
02:19:03 <lambdabot>  error:
02:19:04 <lambdabot>      Variable not in scope: lastMay :: [Char] -> Maybe a
02:20:03 <Boomerang> @let { lastMay [] = Nothing; lastMay xs = Just (last xs); }
02:20:04 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
02:21:14 <Boomerang> @let lastMay xs = case xs of [] -> Nothing; _ -> Just (last xs)
02:21:14 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
02:21:27 <MarcelineVQ> lambdabot's a little off atm
02:21:35 <Boomerang> :(
02:22:01 <jose_zap>  You are missing an "in" I think
02:22:10 <jose_zap> @let lastMay xs = case xs of [] -> Nothing; _ -> Just (last xs) in xs
02:22:10 <lambdabot>  Parse failed: Parse error: in
02:22:13 <Taneb> lastMay [] = Nothing; lastMay (x:xs) = fromMaybe x (lastMay xs)
02:22:16 <jose_zap> nope
02:23:36 <dminuoso> I seem to have an infinite loop in my test suite. How can I run my testsuite with `+RTC -xc`? Im using `new-test` by the way.
02:23:53 <cocreature> dminuoso: use new-run instead
02:23:59 <cocreature> and separate arguments with --
02:24:03 <Taneb> lastMay = cata $ \case {Nil -> Nothing; Cons a b -> fromMaybe a b}
02:24:47 <MarcelineVQ> :t fmap (last . uncurry (:)) . uncons
02:24:48 <lambdabot> [b] -> Maybe b
02:25:24 <dminuoso> cocreature: Does that mean I have to set up a separate executable target in my cabal file?
02:25:29 <dminuoso> Or can I `new-run` a test target?
02:26:03 <dminuoso> I mean I tried it, but it fails to resolve the imports from my test to my library.
02:26:06 <dminuoso> :)
02:27:29 <dminuoso> Mmm yeah imports kind of break.
02:28:35 <cocreature> dminuoso: you might need to change the directory before you call new-run
02:28:46 <cocreature> but new-run can definitely run test components
02:29:41 <dminuoso> cocreature: Okay it kind of helps to use `--enable-profiling` rather than sprinkiling `-prof` into ghc-options..
02:29:43 <dminuoso> =)
02:29:46 <dminuoso> Thanks!
02:35:09 <dminuoso> Unrelated question, what's with the `.ghc.environment.x86_64-darwin-8.4.2` file in my repository. Is this something I would put into git?
02:38:22 <hvr> dminuoso: no, it's a generated file by cabal
02:44:05 * hackage indexation 0.6.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.6.1 (NikitaVolkov)
03:09:27 <gentauro> when working with threads, is the `read-`,`take-` and `take-` `-Mvar` the way to go or is it better to aim for the usage of the mentioned before but prefixed with `try`? https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent-MVar.html
03:10:47 <fnurglewitz> anyone knows where can I find an example of L.hs file of lambdabot? (for mueval)
03:11:26 <jle`> gentauro: check out simon marlow's book, it has a chapter or so on principled usage of mvars
03:12:54 <gentauro> jle`: roger that
03:13:02 <dminuoso> hvr: Curious, why isn't it put into dist/dist-newstyle then?
03:16:33 <gentauro> jle`: well here, if you want `atomicity` he aims for the usage of `takeMVar` and then `putMVar` so I guess that answers my question with regard of the `try` functions -> https://mail.haskell.org/pipermail/haskell-cafe/2004-January/005749.html
03:17:06 <MarcelineVQ> gentauro: https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/pt02.html
03:17:17 <MarcelineVQ> There's a lot to consider and it's covered really nicely
03:18:18 <gentauro> btw, what is the # symbol?
03:18:23 <gentauro> first time I see that one :o
03:18:33 <gentauro> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.MVar.html#tryTakeMVar
03:19:01 <gentauro> `case tryTakeMVar# m s of` and `(# s', 0#, _ #) -> (# s', Nothing #)`
03:20:18 <lavalike> fnurglewitz: does the github repo not have it?
03:21:42 <MarcelineVQ> gentauro: in  tryTakeMVar#  it's just a letter, but it tends to be used to signify to the read that something is unboxed   in (# a, b, c #)  it's an unboxe tuple   https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-types-and-primitive-operations
03:21:46 <dminuoso> gentauro: The `#` can be part of a name, if you enable MagicHash
03:21:48 <MarcelineVQ> *to the reader
03:22:33 <gentauro> dminuoso: what is MagicHash?
03:22:47 <fnurglewitz> lavalike: maybe it's not named L.hs, I tried to find one with that name
03:22:48 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MagicHash
03:23:25 <MarcelineVQ> *signify to the read that something is unboxed or otherwise thought of as primitive
03:23:37 <nshepperd> > let f# = "microsoft" in f#
03:23:40 <lambdabot>  "microsoft"
03:23:40 <dminuoso> gentauro: Think of '#` as just something like '
03:23:46 <dminuoso> gentauro: foo' foo# foo_
03:25:12 <gentauro> dminuoso: but # has more to it. Readers will expect an unbox type
03:27:39 <dminuoso> gentauro: Or unlifted. Or internal primtive.
03:28:15 <nshepperd> primops are (usually?) suffixed with #
03:30:29 <lavalike> fnurglewitz: it's these Pristine files: https://github.com/lambdabot/lambdabot/tree/5eae342ba05fb3622535aca8ceddc98dda154744/lambdabot/State
03:30:59 <lavalike> fnurglewitz: if you look at lambdabot/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Eval.hs you'll see it searches for those and copies into L.hs
03:32:07 <fnurglewitz> lavalike: thank you!
03:43:05 <fnurglewitz> lavalike: I'm just wondering, if I write something like "> Sum 1 <> Sum 2" here to lambdabot he knows that I want the mappend from Data.Monoid
03:43:14 <fnurglewitz> mueval doesn't, I wonder why
03:44:42 <lavalike> fnurglewitz: what is mueval?
03:45:31 <electrocat> can anyone point me to nice state monad benchmarks?
03:46:04 <fnurglewitz> lavalike: in theory it's what lambdabot uses to evaluate expressions
03:46:11 <fnurglewitz> lavalike: http://hackage.haskell.org/package/mueval
03:48:36 <nshepperd> what does "mueval doesn't" mean? it might not have Data.Monoid imported by default
03:50:24 <danr> mueval is the program that runs lambdabot
03:57:26 <dyamon> Hi guys, I have a problem with transformers. I reduced my code a bit, and here it is http://ix.io/1mBW. GHC says that `local` in the `push` function is not in scope. But I thought deriving MonadRead would do that for me. Am I missing something obvious?
03:57:51 <dyamon> *MonadReader
03:58:12 <cocreature> dyamon: "import Control.Monad.Reader (MonadReader ())" only imports the typeclass
03:58:45 <cocreature> you probably want MonadReader (..) instead
04:00:01 <Taneb> Or "MonadReader (local)"
04:03:49 <dyamon> thanks, it works! But can you help me understand why? My understanding is that I'm using the `local` from the MonadReader instance. Why the compiler doesn't complain when it derives the instance?
04:05:21 <Taneb> It's possible to define a class method without the method itself being in scope, as long as the class is
04:09:06 <dyamon> Taneb: ok, so is my code trying to create an instance of MonadReader, without knowing the mandatory methods to implement?
04:09:39 <Taneb> It has the class, so it knows what the mandatory methods are. You can define them fine, just not use them
04:11:44 <fnurglewitz> nshepperd: I imported it in the loaded file
04:12:28 <fnurglewitz> but there's also (<>) from Text.PrettyPrint.HughesPJ
04:12:57 <fnurglewitz> i suppose that lambdabot has many of these cases but it's still working 
04:17:34 <dyamon> Taneb: I see, I still don't find it intuitive, but I can see the reason... thank you very much!
04:19:44 <Taneb> dyamon: it's something I've got wrong in the past, it's definitely a bit weird
04:23:23 <Boomerang> I think it's similar to importing a data constructor for a record but not its field accessor functions: data A = B {c :: Int, d :: Char} and then import Module (A(B)). I can see how that can be a bit weird though
04:24:55 <Boomerang> Mmmh no I'm wrong, if you do that you can't even refer to `c` or `d` in a pattern match
04:34:20 <fendor> when using monad-logger with stack, the output includes the files name that look something like that @(gitWrapper-0.1.0-F7OLt7xNjfk6uFjNWdzFfw:Cmd.Show library/Cmd/Show.hs:19:5). Can i remove this weird hash like thing from the output?
05:22:54 <maerwald> I wonder if it would make sense to provide a 'stack hpack' command just so you have a guarantee to run the right version of hpack (the internal one) and can use it like regular hpack 
05:31:39 <Boomerang> Would `stack exec -- hpack` work?
05:32:28 <Athas> No, that would run whichever hpack belongs to the current snapshot.
05:32:39 <Athas> I think stack's automatic .cabal generation uses an embedded hpack.
05:33:15 <MarcelineVQ> maerwald: it is at least an issue worth bringing up, not the additon of a feature neccesarily, but at least the fact that your outside hpack use it flagging your cabal file as not-generated
05:33:51 <maerwald> Athas: I know, that's what I meant with internal
05:34:55 <MarcelineVQ> If they're going to [strongly-suggest] people use hpack it might as well be painless
05:35:23 <maerwald> Yeah, I think the way forward is actually to remove hpack
05:35:54 <maerwald> I don't find it useful and it lacks behind cabal features 
05:36:04 <MarcelineVQ> Well given that package.yaml is the default new project that's probably not the likeliest outcome, but it's worth mentioning it in your issue report as a solution
05:36:25 <maerwald> I mean for my own project 
05:36:47 <maerwald> Just remove package.yaml and have one problem less
05:38:04 <gentauro> Boomerang: and Athas `~/.stack/global-project/stack.yaml` it's the default 
05:38:35 <gentauro> otherwise if another `stack.yaml` is present in current folder, that would be used instead
05:38:37 <Athas> I hope to soon ditch hpack and move back to pure .cabal files.
05:39:08 <maerwald> Next thing is someone writes a generator for package.yaml files and I have to use shake to generate it... 
05:39:12 <Athas> It's just annoying that the Cabal maintainers seem to have some puritanical ideas about which features are crucial.  But I mean, it's free software (in all senses of the word), so I don't feel like complaining.
05:39:13 <maerwald> More tools please 
05:39:18 <Athas> maerwald: Dhall!
05:39:48 <MarcelineVQ> Athas: which crucial feature would you want?
05:39:53 <gentauro> maerwald: well `stack.yaml` and `package.yaml` generate `xxx.cabal`
05:40:06 <gentauro> so you want `xxx.cabal` to generate `package.yaml`? :|
05:40:13 <cocreature> gentauro: stack.yaml doesn’t generate a cabal file
05:40:17 <maerwald> No. What? 
05:40:21 <MarcelineVQ> gentauro: no he's being hyperbolic about tools
05:40:25 <gentauro> cocreature: well it does on my setups :)
05:41:01 <cocreature> gentauro: I find that pretty hard to believe. stack.yaml is at the level of abstraction of cabal.project files not at the level of a single .cabal file
05:41:14 <maerwald> Wait
05:41:29 <gentauro> there is a reason my `build.bash` script has this as the last line -> `find . -name "*.cabal" -delete -print`
05:41:32 <gentauro> :)
05:41:44 <maerwald> If he is right then that would explain why hpack and stack generate different cabal files
05:42:11 <maerwald> But I looked at the code
05:42:19 <maerwald> Doesn't seem so imo
05:42:26 <cocreature> gentauro: I’m not saying you are not generating .cabal files, I’m saying you are generating them from your package.yaml not from your stack.yaml
05:42:37 <maerwald> https://github.com/commercialhaskell/stack/blob/98e50572f162ebc2ffb1c51a55f0c8504a93b992/subs/pantry/src/Pantry.hs#L413
05:42:42 <gentauro> cocreature: ahhh, roger that
05:43:03 <MarcelineVQ> maerwald: the hash at the top of the cabal file is the main thing that should affect anything
05:43:09 <gentauro> cocreature: but my stack.yaml files are statically linked to a LTS
05:43:17 <gentauro> therefore I'm correct
05:43:29 <gentauro> (LTS decide which GHC needs to be used as well as packages)
05:43:39 <cocreature> gentauro: eh what? your stack.yaml file doesn’t have any influence on the generated cabal file afaik
05:43:40 <gentauro> so my sentence is correct
05:43:46 <maerwald> Just confused why stack doesn't update my kernel
05:43:53 <Athas> MarcelineVQ: previously the lack of common stanzas (or whatever they are called); now the requirement to explicitly list all exposed modules.
05:44:50 <MarcelineVQ> Athas explicit modules is a good requirment, hpack itself has a bug that appears when you aren't explicit about other-modules
05:44:57 <gentauro> cocreature: you are right. .cabal doesn't have any info on which GHC to use
05:45:00 <gentauro> that was spooky
05:45:11 <Athas> MarcelineVQ: I disagree.
05:45:23 <gentauro> how does it decide which GHC and package versions to use?
05:45:45 <Athas> I haven't run into any issues.  My life would be simpler if cabal supported them.  But I'm not going to force anayone to implement or use them; I'm happy enough with hpack, all things considered.
05:46:07 <cocreature> gentauro: stack reads your stack.yaml and decides which ghc it uses based on that
05:46:18 <gentauro> cocreature: that thing I know
05:46:27 <Athas> But that is my only remaining .cabal issue.  I *might* go back and just re-use the script I wrote to generate those sections, but it makes me feel silly.
05:46:30 <gentauro> but I mean, how do people make projects only using cabal?
05:46:44 <Athas> gentauro: it's not that hard.
05:46:47 <gentauro> if there aren't any GHC specifications in the file?
05:46:54 <gentauro> is it just trail-and-error?
05:46:57 <cocreature> cabal-install defaults to the GHC in your PATH and you can pass an explicit path if that’s not what you want
05:47:04 <Athas> gentauro: You can pass '-w' to control the GHC IIRC.
05:47:13 <Athas> And I guess the cabal.project stuff allows you to freeze one.
05:47:31 <cocreature> and you can add version bounds to your dependencies to constraint things like "base" which are tied to the version of ghc
05:47:48 <Athas> But I guess Cabal/cabal-install was built in a world where it was assumed that compilers remained fairly stable, and specific versions were not important.
05:47:52 <gentauro> gosh, now I remeber why I couldn't be bothered to use cabal :|
05:47:55 <Athas> I mean, people who write C don't freeze the C compiler version.
05:47:55 <MarcelineVQ> gentauro, cocreature: it can be correct to say stack.yaml plays a part in cabal file generation, for the cases of such commands as  sdist  where you can generate versioning info for your deps in your cabal file which depends on your resolver and extra-deps in your stack.yaml  but I wouldn't extend that to say that stack.yaml plays a part in cabal file generation in the general case
05:47:59 <Athas> GHC is just too unstable.
05:48:13 * delYsid liked packages.yaml files a lot when he discovered the idea
05:48:25 <maerwald> Athas: they do in, C
05:48:33 <gentauro> Athas: that's why I would like to have LTS versions (inlcuding packages)
05:48:42 <gentauro> so I can reproduce a build at any given point
05:48:44 <maerwald> And have to go through an audit before using a new version 
05:48:55 <gentauro> cabal (alone) is just like walking on quicksand
05:48:56 <Athas> gentauro: Stackage provides those, although the "L" part is maybe a bit of a stretch.
05:49:07 <Athas> You can use 'cabal freeze' with pure Cabal.
05:49:22 <barrucadu> gentauro: Well, it's fairly similar to most other language ecosystems/build tools
05:49:26 <Athas> I definitely prefer Stack, but it's not like Cabal is impossible to use.  It's mostly the defaults that are not good (IMO).
05:49:28 <gentauro> Athas: I know, I <3 stack. It's just like working with any other `industry` build system
05:49:33 <cocreature> stackage sts
05:49:34 <gentauro> (but much better)
05:49:37 <MarcelineVQ> I lament cabal-install not working on my weird mutant distro, it'd be nice to pare-down to basics
05:51:30 <maerwald> stack was a bad idea, stackage was a good idea 
05:51:58 <maerwald> Releases are sensible 
05:52:52 <gentauro> btw, if you spawn a child thread and from that thread you spawn another child thread (only using `forkFinally`) will granchildren thread die if the child thread is terminated?
05:53:39 <MarcelineVQ> give it a try, make a grandkiddy that prints something
05:53:43 <gentauro> (terminated = exit loop)
05:53:57 <gentauro> MarcelineVQ: I have done that and two terminate while one keeps printing
05:54:47 <Athas> Does GHC keep track of threads in a tree?
05:54:48 <gentauro> the one that terminate, are the ones that read/write to a `socket` (I'm guessing they will get an exception and therefore crash)
05:55:20 <Ariakenom> Quite sure you have to organise them yourself. Like in Async.
05:55:24 <gentauro> Athas: that woul be my next question, do I need to save `TID` in a data structure to ensure termination?
05:55:38 <Ariakenom> gentauro: have you looked at Async?
05:55:40 <cocreature> not even immediate child threads die when their parent dies
05:55:56 <MarcelineVQ> Athas: not that I'm aware of, but Async's combinators combine in a tree-like fashion
05:55:56 <cocreature> +1 for async
05:56:15 <cocreature> coming up with your own buggy version of async is definitely not worth the trouble
05:56:27 <barrucadu> If you're just using Control.Concurrent, the only case in which threads get automatically killed is when the main thread terminates
05:56:31 <gentauro> Ariakenom: nope, I'm working with https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent.html
05:56:46 <MarcelineVQ> it is worth the trouble to rewrite it while following a good book though: https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/pt02.html
05:57:04 <gentauro> barrucadu: roger that. I just need to ensure to quit the loop if "global temrination" is called
05:57:08 <cocreature> barrucadu: and even if you just want to kill threads in that case, you probably want to use "async" so finalizers are run
05:57:10 <MarcelineVQ> I tell you, the exceptions chapter alone makes the book, and there's a lot more chapters than that.
05:57:34 * hackage bulletproofs 0.3.0 -   http://hackage.haskell.org/package/bulletproofs-0.3.0 (sdiehl)
05:57:39 <cocreature> MarcelineVQ: sure rewriting things for learning purposes is a different story :)
05:57:40 <gentauro> barrucadu: I say your name with regard of a blogpost about `Coco`
05:57:45 <Ariakenom> I too recommend Marlow's book
05:58:01 <Ariakenom> it's also freely availible online if you didn't notice gentauro 
05:58:28 <jose_zap> gentauro if you use the async package, that idiom is called `race`
05:58:45 <jose_zap> mainThread `race_` helperthread
05:59:02 <MarcelineVQ> holy shit, I can't follow a single word in that bulletproofs line, kinda cool
05:59:04 <jose_zap> both threads die if one of them does
05:59:05 <barrucadu> gentauro: Probably.  I implemented a tool called CoCo to find observational equivalence and refinement between concurrent program fragments - kind of like QuickSpec or Speculate
05:59:15 <MarcelineVQ> *bulletproofs link
05:59:19 <barrucadu> It works, but I'm fairly skeptical of it being useful I have to admit
06:01:09 <Ariakenom> The one exception to "not even immediate child threads die when their parent dies" is the main thread which will terminate the program
06:01:58 <Ariakenom> so you can say it's a tree with one parent and the rest children
06:02:28 <cocreature> Ariakenom: as I mentioned before, that’s still different from what the async lib will provide you in that case: finalizers are not run if your main thread dies
06:02:52 <Ariakenom> Are finalizer guaranteed to run?
06:02:55 <Ariakenom> otherwise
06:03:17 <Ariakenom> but yes async is better and should be used
06:03:59 <cocreature> finalizers aren’t guaranteed to run, you can also use a SIGKILL or whatever and they won’t be run
06:04:17 <cocreature> but it is pretty unintuitive that finalizers in other threads are not run if your main thread exits normally
06:04:31 <cocreature> so ime relying on that behavior is almost never desirable
06:07:32 <gentauro> a simple `tryReadMVar (isParentTerminated :: MVar Bool)` seems to be the solution (at least for my problem :)
06:36:34 * hackage tzdata 0.1.20180501.0 - Time zone database (as files and as a module)  http://hackage.haskell.org/package/tzdata-0.1.20180501.0 (MihalyBarasz)
07:34:04 * hackage hakyll 4.12.4.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.12.4.0 (JasperVanDerJeugt)
07:41:04 * hackage primitive-extras 0.7.1 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.7.1 (NikitaVolkov)
07:50:48 <jluttine> why does this consumes a lot of memory for large lists: dot xs = foldl' (+) 0 $ zipWith (*) xs xs
07:51:49 <mniip> zipWith f xs xs = map (join f)
07:52:38 <Taneb> jluttine: I don't know for certain, but I suspect zipWith isn't as good a list consumer as one would hope
07:56:02 <mniip> zipWith as a list consumer is biased on one side iirc
07:57:28 <ab9rf> the problem is foldl'
07:57:49 <ab9rf> i rather suspect
07:58:26 <ab9rf> dammit where is my coffee
07:59:06 <ab9rf> it's bad enough that i can't have proper coffee, but it also keeps disappearing on me
07:59:39 <maerwald> don't promote drugs!
07:59:45 <ab9rf> hee
08:00:03 <ab9rf> maerwald: at the moment, i'm very fond of toradol :)
08:00:55 <maerwald> I use haskell against depression, but sometimes it makes it worse, lol
08:01:28 <MarcelineVQ> how are you determining it's using a lot of memory?
08:01:29 <ab9rf> but toradol isn't exactly a drug people tend to abuse
08:05:37 <ab9rf> keep in mind that (+) is strict in both of its arguments for most implementations of Num
08:08:12 <maerwald> I want strictness in the type system or a strictness prover!
08:08:27 <maerwald> it's impossible to reason about strictness in large code bases
08:08:51 <Cale> I think it would be interesting to have any measure of laziness in the type system at all
08:09:17 <Cale> Currently all the type level evaluation is strict
08:09:23 <pgiarrusso> I thought I had seen a *tester* for strictness?
08:09:51 <Cale> What if I need infinite lists of types? :D
08:10:08 <maerwald> Cale: so just move everything to type-level computation if you want strictness? lol
08:10:09 <pgiarrusso> Or rather, for laziness... it was some paper testing that functions were lazy enough and fixing them
08:10:36 <jluttine> MarcelineVQ: with :set +s in ghci
08:10:53 <MarcelineVQ> ah, so you're looking at allocations?
08:12:49 <jluttine> MarcelineVQ: ah, true! so it allocates a lot of memory although it's not using that amount of memory at any time
08:13:02 <maerwald> MarcelineVQ: oh...running plain hpack doesn't generate the header with has *at all*
08:13:03 <MarcelineVQ> Yes that's not a measure of the maximum memory in use at once for your function but the memory allocated during its execution
08:13:11 <maerwald> s/with has/with hash/
08:13:39 <maerwald> which is literally the only difference
08:13:51 <maerwald> the rest of the file matches 1:1
08:13:57 <maerwald> gosh is stack annoying
08:14:12 <mniip> maerwald, (+') :: Num a => (# a #) -> (# a #) -> a
08:14:54 <mniip> no wait that's the opposite
08:17:56 <maerwald> MarcelineVQ: I'm having a naughty idea... I just insert the hash header manually, haha
08:19:13 <MarcelineVQ> maerwald, hpack generates the hash
08:19:40 <ab9rf> hash browns
08:19:50 <MarcelineVQ> Like, I'm not sure what you tried but I just installed hpack and delete my cabal, and running hpack made the hash header again
08:20:23 <MarcelineVQ> with a version difference, since stack install hpack is an older hpack than my stack has integrated
08:20:31 <maerwald> MarcelineVQ: it's not here!
08:22:03 <MarcelineVQ> I will note however that the hash changes between using hpack or stack
08:22:21 <MarcelineVQ> Most likely just due to the version difference
08:22:29 <ab9rf> it's a plot to maximize your power consumption
08:22:34 <ab9rf> blame the electric utility
08:22:42 <MarcelineVQ> You are full of beans today!
08:24:35 <ab9rf> MarcelineVQ: i'm stuck on a not-very-comfortable couch in a room that is cooler than i find comfortable, with only mediocre coffee to drink
08:25:12 <MarcelineVQ> If there's a single coffee that actually tastes as good as it smells I'll buy the company.
08:25:27 <MarcelineVQ> Man does coffee ever smell good
08:25:39 <MarcelineVQ> ^ statement
08:27:48 <monochrom> It is also made of beans. So it's full of beans too. Everyday.
08:29:49 <maerwald> coffee is dangerous
08:29:57 <MarcelineVQ> They're not even beans, it's a conspiracy at the highest echelons
08:34:38 <ab9rf> bean, bean, what is bean?
08:35:35 <juhp> is something wrong with Travis Haskell?
08:35:50 <juhp> It only found 7.10.3 for me today, no other versions
08:36:12 <Ariakenom_> It's just a proxy factory in the manager of decorator façades
08:36:13 <juhp> (It worked 4 days ago)
08:37:50 <maerwald> MarcelineVQ: hpack definitely doesn't create the header here
08:38:16 <maerwald> at least not if you tell it to print to stdout
08:38:21 <maerwald> instead of creating the file
08:39:51 <cocreature> juhp: can you show us the build log? and have you tried restarting the build? sometimes the apt-get part seems to be a bit flaky
08:40:27 <MarcelineVQ> maerwald: I just ran hpack
08:40:50 <maerwald> MarcelineVQ: you didn't print to stdout then
08:41:08 <MarcelineVQ> Correct. never even considered piping it somewhere, or that it would make sense to do so
08:41:12 <maerwald> not piping
08:41:14 <maerwald> stack exec hpack -- -
08:44:03 <MarcelineVQ> can confirm, whatever - is doing it doesn't display the comment header with the version and hash
08:44:27 <MarcelineVQ> dunno if it's supposed to though, would need to find hpack docs
08:45:11 <maerwald> https://github.com/sol/hpack/blob/master/src/Hpack.hs#L184
08:45:13 <MarcelineVQ> https://github.com/sol/hpack  "There is no user guide" rdr^2
08:45:55 <maerwald> https://github.com/sol/hpack/commit/5f19c465fdebc95aca641b7d10bd9451311c7dd9
08:45:57 <maerwald> no reasoning given
08:47:02 <maerwald> https://github.com/sol/hpack/issues/331
08:47:03 <MarcelineVQ> Well now you know to not use - since it's not for printing the actual result I guess :>
08:47:10 <maerwald> ?
08:47:40 <maerwald> I'll just fix it
08:48:04 * hackage simple-cmd 0.1.0.0 - Simple String-based process commands  http://hackage.haskell.org/package/simple-cmd-0.1.0.0 (JensPetersen)
08:49:07 <MarcelineVQ> note that you still need hpack versions to align between stack and the hpack you're using to generate, because it changes the hash
08:49:33 <maerwald> it didn't in my tests
08:49:43 <MarcelineVQ> ehe, it did in mine ^^;
08:51:27 <wroathe> So I'm working through the exercises in Programming in Haskell, and chapter 9 implements a program to solve the British "Countdown" show problem. The basic program only allows for addition/subtraction/multiplication and division and all of the types of the functions deal with Int values.
08:51:28 <MarcelineVQ> and continues to, at least beween versions  0.28.2 and  0.30.0
08:51:40 <wroathe> Question #6 of that chapter says to extend the program to allow for exponentiation
08:52:20 <wroathe> But the problem I'm running into with that is that you end up with expressions like: 10 ^ (25 * 50)
08:52:29 <maerwald> MarcelineVQ: in that case the warning of "someone touched .cabal file" is then in fact correct and useful
08:52:37 <maerwald> while with the missing hash, it's just wrong
08:53:21 <wroathe> Does anyone know if the intention of the author with this exercise was for me to upgrade the functions to deal with Integer values? Or is there something I'm missing here?
08:57:48 <c50a326> code from realworldhaskell monad transformers: https://ptpb.pw/QZAR/hs error: https://lpaste.net/1872536978629591040
09:00:44 <c50a326> line 25 (forM) and 34 (constrainedCount) are where the errors are highlighted by intero
09:01:01 <maerwald> MarcelineVQ: done, now just wait 2 years until it hits the next stackage hahaha
09:04:31 <hexagoxel> c50a326: you might want to change your imports to use `mtl` packages. Control.Monad.Reader and Control.Monad.State
09:07:04 * hackage servant-auth-token-api 0.5.3.0 - Servant based API for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-api-0.5.3.0 (NCrashed)
09:09:01 <c50a326> oh yeah
09:09:03 <c50a326> thanks
09:21:24 <AWizzArd> foo = \x -> map ($ x)  has the type :: a -> [a -> b] -> [b]          I want [a -> b] -> a -> [b]  though but at the same time see if I can get rid of the explicit lambda.
09:22:08 <ab9rf> @pl \x -> map ($ x)
09:22:09 <lambdabot> map . flip id
09:22:23 <Taneb> :t flip (map . flip id)
09:22:24 <lambdabot> [b1 -> b2] -> b1 -> [b2]
09:22:54 <maerwald> what's wrong with the lambda?
09:23:03 <AWizzArd> maerwald: nothing wrong, just curious
09:23:10 <maerwald> oh, golfing
09:23:23 <AWizzArd> Taneb: yeah, that would work
09:23:36 <cocreature> if you can’t easily figure out the pointfree version yourself, chances are that whoever reads your code also has a hard time figuring out what it does
09:23:48 <maerwald> unfortunately pl is not very good at golfing even
09:23:57 <maerwald> it's hard to make it smart
09:23:57 <ChaiTRex> @. pl unpl flip (map . flip id)
09:23:58 <lambdabot> flip (map . flip id)
09:24:00 <cocreature> (ofc for learning purposes it can still be fun to come up with a pointfree version)
09:26:01 <AWizzArd> cocreature: yes, just for fun. Obviously it’s totally unsuited in this case for company code.
09:26:31 <Taneb> AWizzArd: someone I used to work with disagreed, and had his own fork of "composition-extra"
09:26:39 <ab9rf> honestly, i find the lambda easier to understand than flip
09:28:28 <AWizzArd> Taneb: you mean he wanted pointfree at all costs?
09:28:41 <Taneb> For smaller things, yeah
09:28:43 <AWizzArd> ab9rf: totally.
09:29:41 <AWizzArd> In principle my foo game is just a specialized `sequence`.
09:31:09 <AWizzArd> As ((->) r) has a monad implementation.
09:32:11 <Ariakenom_> Why is there no dupTChanIO?
09:33:32 <EvanR> seems like you could ask that for every STM action, why theres no IO wrapper that just uses atomically
09:33:34 <cocreature> Ariakenom_: probably just not common enough.
09:34:17 <Ariakenom_> cocreature: actually I should have specified that I intented a semantic change. To be able to nest it using unsafePerformIO
09:36:36 <cocreature> Ariakenom_: hm, why do you need multiple duplicate top-level channel? that sounds weird
09:37:13 <Ariakenom_> cocreature: It's not top level it's for a Functor instance :)
09:37:28 <cocreature> Ariakenom_: I’m not following, can you provide an example?
09:38:42 <nshepperd1> Sounds dangerous. What if someone uses your fmap instance inside STM?
09:40:35 <Ariakenom_> It's a functor instance for a newtype TChan. Fmap makes a new channel. But I want it to be a duped broadcastchannel
09:40:39 <nshepperd1> I suppose that's why you want an IO version that's somehow safe for that
09:41:20 <Ariakenom_> nshepperd1: actually I know my use is safe. I made the channel right above
09:41:28 <Ariakenom_> but it errors out
09:41:34 <cocreature> “fmap makes a new channel” sounds like it probably violates fmap id = id
09:42:05 <Ariakenom_> cocreature: the channels will be extensionally equivalent
09:42:20 <Ariakenom_> I think those words mean what I intended them to
09:43:15 <cocreature> newTChanIO makes sense because it doesn’t interact with anything existing so you don’t need to care about atomicity. but for dupTChan it seems like it probably does matter
09:43:18 <Ariakenom_> There is no allow-nested-stm flag? I looked
09:45:07 <Ariakenom_> cocreature: Yes it may well matter. But not if I just made the channel? The thing is broadcastchan makes a write-only chan that you have to dup to read from. So I just want to make 2 endpoints
09:45:41 <nshepperd1> They wouldn't be equivalent though. readTChan (fmap id x) >> readTChan x will give a different result with fmap id -> id
09:46:12 <nshepperd1> Oh, nvm
09:46:47 <cocreature> Ariakenom_: can you show us the Functor instance that you would like to write? I’m having a hard time seeing how this is supposed to work
09:47:03 <cocreature> it seems like you need a -> b and b -> a to get from TChan a to TChan b
09:48:09 <cocreature> I’m also not sure why you can claim that “you just made the channel”. what stops anyone from calling fmap at a later point, multiple times, …
09:48:42 <Ariakenom_> cocreature: Oh you're right, I wanted a read only channel but that's not what I got
09:51:25 <cocreature> Ariakenom_: I am also not convinced they are extensionally equivalent. if I have chan' = fmap id chan and that creates a duplicate, then I can write to one of them and then read the item from both whereas for chan' = id chan = chan, I can only read the item once
09:51:27 <Ariakenom_> cocreature: https://gist.github.com/Ariakenom/b8198c4621734565259fdcbb3e1781ad beware that it's awful
09:52:44 <nshepperd1> . o O (Coyoneda TChan)
09:54:56 <cocreature> Ariakenom_: that definitely does not respect "fmap id = id". you are continually removing items from the chan in a new thread whereas "id" definitely does not do that
09:56:07 <dminuoso> 2k lines removed, 3k lines added. Type checks and voila: all tests pass and it just works. #ThisIsHaskell
09:56:09 <Ariakenom_> cocreature: Also true, that's a bug
09:56:43 <Ariakenom_> but for your previous comment the intended semantics of the newtype isn't chans but FRP Events
09:57:22 <Ariakenom_> I think trying non stm is the way forward
09:57:36 <cocreature> I think not abusing a Functor instance is the way forward :)
09:57:55 <Ariakenom_> don't be silly :p
09:58:36 <dmwit> I think what you should be taking from this is that you should think very carefully about whether your plan for FRP events is actually sensible.
09:58:49 <dmwit> (There is no need to think carefully about your plan for TChans: it is not sensible.)
09:58:57 <infinisil> Hey, when I have a function `foo :: MonadError String m => m ()`, and I'm defining function `bar :: MonadError (Either String String) m => m ()`
09:59:13 <nshepperd1> If you really want to do stuff `atomically` under unsafePerformIO you can ask another thread to do it for you in IO and block until it's done, which won't deadlock as long as you can actually ensure the action won't conflict with anything
09:59:15 <infinisil> I want to call bar from foo, and map the error I get from foo with `Left`
09:59:17 <Ariakenom_> dmwit: Not at all. The goal of learning was achieved.
09:59:38 <infinisil> Can I somehow lift these errors into the more general error monad?
09:59:41 <nshepperd1> (i don't actually condone this)
10:00:04 <Ariakenom_> nshepperd1: good point. your disgruntlement is noted too
10:00:05 <dmwit> infinisil: No.
10:00:20 <EvanR> says since accident involving unsafePerformIO
10:00:31 <EvanR> err, s/says/days/
10:00:40 <infinisil> dmwit: Aw why not? And what should I do instead?
10:01:25 <Ariakenom_> dmwit: I will continue headlong into my next awful idea
10:01:44 <nshepperd1> Maybe you really do want Coyoneda TChan?
10:01:49 <dmwit> infinisil: You could do `runExceptT foo >>= \x -> case x of Left err -> throw (Right err); Right val -> return val`. But think carefully about what this means about the type you are using `foo` at.
10:02:49 <nshepperd1> Or just an IO action
10:03:15 <Ariakenom_> nshepperd1: I'm gonna go with some old fashioned IO
10:03:20 <infinisil> dmwit: I just want to have an error hierarchy
10:03:21 <nshepperd1> Since the only thing you can do with a read-only TChan is try to read from it
10:03:23 <dmwit> infinisil: (Specifically: you are using it at type `MonadError (Either String String) m => ExceptT String m ()`, so it has *two* kinds of errors going. Maybe that semantics is okay for you and maybe it ain't. I can't think of a reason it would be bad offhand but these kinds of things can be very subtle.)
10:03:31 <nshepperd1> Why not just store that IO action
10:03:39 <nshepperd1> Instead of the TChan
10:03:48 <dmwit> nshepperd1: You are wrong.
10:04:06 <dmwit> nshepperd1: The whole point of STM is that you can try to read from it in a transaction with other STM stuff, and have that all either happen or not as a block.
10:04:16 <EvanR> so store the STM action
10:04:18 <dmwit> nshepperd1: The IO action that reads from the chan can't be used in that way.
10:04:30 <Ariakenom_> nshepperd1: I can also dup it
10:04:33 <nshepperd1> As EvanR says
10:05:03 * dmwit nods agreeably
10:05:15 <nshepperd1> Or store a record of the different things you can do with it
10:05:28 <nshepperd1> Point is, you don't need to store the chan itself
10:05:38 <EvanR> i noticed a possible pattern for an application, have literally everything be STM instead of IO, except for the peripheral drivers which execute output or provide input
10:05:39 <infinisil> dmwit: Why would it be multiple types of errors? If foo calls bar via exceptT, the error should be handled right there and never go into the type of foo
10:05:55 <nshepperd1> And if you don't need to do that, you don't need to make up a fake Functor instance for it
10:06:02 <EvanR> then you can always rollback anything
10:06:08 <Ariakenom_> Is there a broadcast channel in base?
10:06:12 <nshepperd1> You can just use the STM functor instance
10:06:21 <dmwit> infinisil: The type of `bar`'s `m` already has error-reporting capabilities in it, and then you are wrapping that `m` in `ExceptT`.
10:07:15 <dmwit> s/The type of//
10:07:15 <infinisil> But shouldn't the exceptT then "strip" the error monad of the matching type with an ExceptT?
10:07:27 <dmwit> Huh? No.
10:07:54 <dmwit> `ExceptT a (ExceptT b m) c` does not somehow magically become `ExceptT a m c`.
10:08:12 <cocreature> you don’t need to wrap it in ExceptT, you can instantiate the type of foo with Either String () and case on that
10:08:32 <dmwit> Oh, excellent point.
10:08:35 <nshepperd1> I don't think broadcast channels are the answer here
10:08:36 <dmwit> That plan is much better.
10:08:56 <infinisil> Oh, hmm..
10:09:24 <infinisil> Well m also has MonadIO
10:09:28 <infinisil> I left that out
10:10:19 <dmwit> You can still monomorph it to ExceptT String IO.
10:10:21 <infinisil> Oh and I mixed up bar and foo in my explanation
10:10:22 <Boarders>  I tried to write a dot product function that could do better than the one mentioned earlier namely: dotProd xs ys = foldl' (+) 0 $ zipwith (*) xs ys
10:10:27 <Boarders> I wrote this: https://lpaste.net/2960906224289185792 (which is probably stupid in various ways)
10:10:35 <Boarders> if I compile with O2 and compute dotProd [1..1000000] [1..1000000] and then time them the first version gives: user 0m0.016s, whilst the version I wrote by hand gives: user 0m0.019s
10:10:43 <Boarders> anyone know why that is?
10:11:01 <Boarders> is it to do with the magic in the implementation of foldl' for lists in base
10:11:32 <EvanR> those two results seem damn close
10:11:34 <MarcelineVQ> Did you average out many tests? at that margin it could be anything
10:11:54 <Boarders> I did not
10:12:04 <dmwit> Boarders: You're missing the [] case in `case ys of ...`. Nothing to do with the performance difference, but it is a bug. =)
10:12:12 <EvanR> compute mean and stddev of both :)
10:12:14 <MarcelineVQ> I'm surprised they're that close in that case
10:12:26 <dmwit> And yes, I suspect 0.016 vs 0.019 is just noise.
10:13:04 * hackage hriemann 0.3.3.2 - A Riemann Client for Haskell  http://hackage.haskell.org/package/hriemann-0.3.3.2 (shmish111)
10:13:30 <Boarders> dmwit: true, I vaguely justfied it as "the user should have supplied two of the same length list!"
10:13:33 <dmwit> I would bet the fold/zipWith version manages to fuse away the intermediate list, so probably the two implementations get compiled to damn near the same thing.
10:13:34 <nshepperd1> In FRP, an event e must have f e e = f e (fmap id e), which certainly isn't the case if each event can only be read once from e in the former case
10:13:57 <nshepperd1> If f is done kind of zip action, i can't see how you'll possibly get the same result
10:14:01 <Boarders> i'll try having a look at the core of the two
10:14:08 <Ariakenom_> nshepperd1: I'm open to suggestion. My goal is a dumb FRP thingie.
10:15:11 <MarcelineVQ> Ariakenom_: How dumb?  https://hackage.haskell.org/package/streamly
10:16:19 <MarcelineVQ> https://hackage.haskell.org/package/streamly-0.5.1/src/examples/AcidRain.hs
10:17:21 <dmwit> :t get >>= lift
10:17:22 <lambdabot> (Monad m, MonadTrans t, MonadState (m b) (t m)) => t m b
10:17:42 <Boarders> if I am writing a parser for a non-binary file format like some tree notation, should I expect using Text over String to make much of a difference?
10:17:49 <dmwit> :t get >>= lift . tails
10:17:50 <lambdabot> (MonadTrans t, MonadState [a] (t [])) => t [] [a]
10:17:59 <Ariakenom_> MarcelineVQ: That looks like x*10e3 loc, x>1
10:18:08 <Ariakenom_> 10e4 rather
10:18:17 <infinisil> Ah, I can use runExceptT
10:18:20 <infinisil> :t runExceptT
10:18:22 <lambdabot> ExceptT e m a -> m (Either e a)
10:18:33 <dmwit> :t liftIO . runExceptT
10:18:35 <lambdabot> MonadIO m => ExceptT e IO a -> m (Either e a)
10:19:24 <infinisil> Okay, but apparently there's no easy way to build up such errors
10:19:45 <Ariakenom_> MarcelineVQ: I was looking for dumb implementation too
10:19:47 <infinisil> Should I maybe declare my monad stack upfront instead of letting haskell infer it?
10:19:53 <nshepperd1> I don't have any suggestions :( I've never implemented any frp before
10:20:29 <infinisil> Then I could map it with mapExceptT I think
10:20:32 <infinisil> :t mapExceptT
10:20:34 <lambdabot> (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b
10:21:49 <dmwit> infinisil: That is certainly one popular choice. But you can still make it as polymorphic as you want, I think, without doing that.
10:22:18 <dmwit> :t \act -> do v <- liftIO (runExceptT act); case v of Left e -> throw (Right e); Right v -> return v
10:22:20 <lambdabot> (Exception (Either a b1), MonadIO m) => ExceptT b1 IO b2 -> m b2
10:22:32 <dmwit> :t \act -> do v <- liftIO (runExceptT act); case v of Left e -> throwError (Right e); Right v -> return v
10:22:33 <lambdabot> (MonadError (Either a b1) m, MonadIO m) => ExceptT b1 IO b2 -> m b2
10:22:46 <dmwit> infinisil: like that
10:23:00 <nshepperd1> Maybe if you never read from any channel without first duplicating it, then whether it was dup'd in fmap id is unobservable
10:23:20 <infinisil> Hmm yeah, why isn't such a function in mtl though?
10:23:25 <infinisil> Seems rather useful to have
10:23:37 <dmwit> err...
10:23:52 <dmwit> Seems... kind a niche to me, honestly.
10:24:17 <Ariakenom_> nshepperd1: I do believe I can get the fmap-duping to be unobservable yeah
10:24:32 <dmwit> It works okay of `foo :: (MonadError e m, MonadIO m) => m a`, but as soon as it's `foo :: (MonadError e m, MonadState s m, MonadIO m) => m a` you have to do something else.
10:24:32 <Ariakenom_> I need to dup before the read-loop as well
10:24:58 <dmwit> You wouldn't want to have something like this for all 2^n choices of monad classes.
10:25:42 <infinisil> Hmm yeah
10:26:17 <MarcelineVQ> "<Ariakenom_> 10e4 rather" I don't follow
10:26:42 <infinisil> I could maybe also just make the function be `MonadIO m => ExceptT e m a`
10:26:46 <Ariakenom_> MarcelineVQ: It looks like more code than what I had in mind. for the implementation
10:26:51 <infinisil> Then I can use mapExceptT just fine
10:26:58 <infinisil> A bit less polymorphic though
10:28:24 <MarcelineVQ> Oh, it's really not very long though. If you need a focus: there's only 2 important lines in the file to examine,  runStateT (runStream game) 60  and  event <- userAction `parallel` acidRain
10:30:42 <Ariakenom_> MarcelineVQ: I meant the implementation of streamly
10:30:54 <infinisil> Oh how about this:
10:31:13 <infinisil> I define a monad stack for my app, and only include the monads I know I'll always need
10:31:34 <infinisil> Any functions that need some additional constraints I'll add them adhoc with =>
10:32:04 <infinisil> Maybe
10:33:45 <MarcelineVQ> Ah, erm, it's just kit, you assemble it yourself. I​ mean, the implementation of MVar is also somewhat verbose, and the Chan's that sit upon it. Whatever floats your boat though, I'm interested to see what you end up making
10:39:04 * hackage hmatrix-svdlibc 0.5.0.1 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.5.0.1 (BenGamari)
10:40:34 * hackage servant-auth-token 0.5.4.0 - Servant based API and server for token based authorisation  http://hackage.haskell.org/package/servant-auth-token-0.5.4.0 (NCrashed)
10:41:34 * hackage servant-auth-token-persistent 0.7.0.0, servant-auth-token-leveldb 0.6.0.0 (NCrashed): https://qbin.io/errors-zu-nxy8
10:42:34 * hackage servant-auth-token-acid 0.5.4.0 - Acid-state backend for servant-auth-token server  http://hackage.haskell.org/package/servant-auth-token-acid-0.5.4.0 (NCrashed)
10:43:13 <Ariakenom_> MarcelineVQ: the point is to look at implementation of FRP. so using a ready made lib sense doesn't teach me much. looking at implementations would make sense though, but I won't for now.
10:44:27 <dmwit> select :: StateT [a] [] a; select = do x:xs <- lift . tails =<< get; put xs; return x -- pretty cute
10:46:57 <EvanR> Ariakenom_: probably before implementing you need an idea of what the implementation is supposed to be guaranteeing, sane FRP behavior usually doesn't result from implementation out of nowhere
10:47:12 <EvanR> i.e. what are you intended semantics
10:47:56 <EvanR> as i recall all the existing FRPs have wildly different semantics or none at all
10:48:59 <Ariakenom_> I think sanity is out of scope :p
10:49:31 <Ariakenom_> no but I tihnk an exploratory approach will work fine, I don't mind throwing it all out and saying "lessoned learned"
10:50:22 <EvanR> heh
10:55:09 <EvanR> after agreeing on laws, i went back and it changed everything about how i want to do "game loops" in C
10:55:30 <EvanR> no amount of implementation would have clued me in
10:55:49 <Ariakenom> interesting do you have details?
10:56:31 <EvanR> i can give you some interesting questions that classic game programming doesn't really have answers to
10:56:32 <Ariakenom> did implementation not help you agree on laws?
10:56:38 <EvanR> no it just confused me
10:57:22 <Ariakenom> give!
10:57:57 <EvanR> what if you are programming a soccer game, and the ball crosses the goal at the exact same time that the game time runs out. does the score count?
10:58:36 <EvanR> what if before programming you defined a special rule for this case, some special result occurs
10:59:46 <EvanR> what if you could block the ball by pressing a button, and you press the button exactly when the ball is crossing the goal line
11:01:57 <EvanR> should you implement it, then figure out the answer. or answer first then make sure the implementation does what you want
11:02:20 <EvanR> many times you dont even ask, then later its a subtle gameplay bug
11:02:44 <Ariakenom> quite true, thinking is good
11:03:32 <Ariakenom> in FRP I'd expect most of this to be down to a "leftmost listOfEvents" where the game developer chose some order
11:04:09 <Ariakenom> probably [endOfGame, goal] so no last moment goal
11:05:54 <EvanR> so what youre saying is, nothing ever happens at the same time as something else, its a stack of cards you go through one after the other
11:06:41 <Ariakenom> They do happen at the same time. "leftmost" takes the first currently occurring Event
11:06:50 <EvanR> an example where that doesnt work is in some fighting games, if both players attack at the same time, its a "cling" tie instead of one or the other getting hit. in your stack case, whoever happens to be first player or second player always wins ties
11:07:31 <EvanR> you might say, thats not exactly at the same time, theres a time interval where "cling" would result. but you cant get out of it that way, since a time interval has two boundaries where you then have to answer my original question
11:07:33 <Ariakenom> They're at the same time but prioritised differently yes. your result matches
11:07:53 <EvanR> a priority doesnt work when you want a special third outcome in case of "same time" or "tie"
11:08:13 <Ariakenom> You'd special case that by creating an event from those two with the third result
11:08:24 <EvanR> when many events occurs at the same time, but you only ever handle events separately, in a queue, then you cant program the simultaneous interactions of ties
11:08:52 <Ariakenom> and then using the third event with the others and not the first 2
11:09:13 <EvanR> simultaneous events is a natural aspect of the problem, not a special case with a big extra bit of machinery to do each time you want it
11:09:38 <EvanR> it comes out of thinking of events as happening somewhere in time
11:09:47 <EvanR> rather than in a sequence
11:10:58 <EvanR> this matters enough that sdl2 now timestamps all the events, so between frames (16ms apart) you can still get proper instrument playing times
11:11:14 <EvanR> 16ms resolution on drum hitting or guitar playing would sound awful
11:11:56 <EvanR> and yes, events in sdl2 can come in with equal timestamps
11:13:28 <EvanR> so whatever sequence you think there is, the event queue isnt it
11:14:45 <Ariakenom> this is good stuff. I was thinking about including an Int frame stamp.
11:17:01 <EvanR> one way to model this in an API is with a Monoid. merge :: Monoid a => E a -> E a -> E a
11:17:02 <Ariakenom> and the FRP combinator for simultaneous interactions would be "mergeWith :: Reflex t => (a -> a -> a) -> [Event t a] -> Event t a" (stolen from reflex ofc)
11:17:22 <EvanR> yeah
11:17:42 <EvanR> merges :: Monoid a => [E a] -> E a
11:17:47 <Ariakenom> indeed. was thinking monoid as soon as I saw it but went with the one I could reference
11:19:32 <EvanR> note that exposing the timestamp, if any, of events may be too much detail for the client
11:19:49 <EvanR> you can always attach timestamps if you have a time-valued behavior
11:20:19 <Ariakenom> yes I meant frame stamps for the implementation. not client
11:24:01 <delYsid> I am sure you all know Philip Wadlers "Propositions as types" talk (which is excellent, BTW).  I have a rather unconventional question about that talk.  When he requests a pointer, does he really receive a cane? I am guessing because of the comment afterwards, but as a blind guy, you never know :-)
11:24:32 <EvanR> heres another one, what happens if, given the same recorded set of input events, and initial game state, (and for the sake of argument you have no random elements), you run the game several times. is the result the same? 
11:25:13 <EvanR> or does it subtly depend on timing of the OS switching out your process or calling into your audio code
11:25:47 <EvanR> if you want the result to be the same, it sounds like your want semantics something like "function of time"
11:27:14 <EvanR> some games know they need that ahead of time and bake that into the implementation. but if you didnt, its unlikely your implementation would have this property
11:27:53 <EvanR> some source ports of DOOM broke this property, and hence the pre-game demos
11:32:20 <Ariakenom> worst case my process doesn't get scheduled? That's not the behavior I want each time
11:34:22 <EvanR> irl, your process gets scheduled at a random sampling of real time. So your timing code sees different "inputs" from the real time clock each time the game runs
11:34:40 <EvanR> without special consideration in an implementation, the simulation is likely to be different each time
11:35:06 <EvanR> with semantics to satisfy like "function of time", you'd be reminded that you need special considerations
11:35:25 <dataN> without kindclasses, type families serve almost like classes of only one function, except how can they be made into a constraint? 
11:36:40 <EvanR> and you'd likely know when what you're about to do "is wrong" because it violates some assumption of the semantics
11:39:42 <dataN> possibly with closed type families, all the instances being in one place, and checked in order, a catchall can be placed at the end and matched over with a type equality, to say something like "this function is defined over this type" as a constraint over the instances of the type family.
11:41:28 <dataN> which is not as good as being able to make instances of classes anywhere (an open type family would not allow a catchall to be used to detect that no matching instance is found)
11:42:00 <Ariakenom> Right. The question needed to be more concrete though. So we get precise time stamps and run often enough to complete our target frame rate?
11:42:15 <Ariakenom> correction: more precise
11:42:24 <dataN> is there a better way to make the typechecker detect when an instance of a type family is defined?
11:43:58 <dataN> i.e. "satisfy a constraint" 
11:47:14 <dataN> the only other obvious way would be if it were possible to use a test case, so that the absence of an instance would mean the test would not "compile/run" and then would not satisfy an equality on the result. but this cant work because such a test could not be defined over all the potential instances 
11:48:28 <dataN> if its not clear what this is getting at, maybe an alternative approach can be suggested, otherwise maybe there is some convention for this
11:50:17 <dataN> basically the idea is that being able to check to see if an open type family will match over some type would serve as a kindclass
12:01:49 <dataN> it would be good if there were a way to get a compile time error rather than a runtime error when a type family instance was missing
12:02:46 <lyxia> what are you doing that results in a runtime error with type families
12:05:08 <dataN> maybe something like Map over a list of types then not having the correct return type, which would then not match some other type family defined only on the correct return type
12:05:29 <dataN> Map as in; https://gist.github.com/dataN-hs/93a90e281a4208e6c224bc967ca09600
12:06:09 <dataN> maybe something like Fmap is possible...
12:12:19 <dmj`> anyone aware of a BNF for json path ?
12:34:15 <pbodev1> join
12:38:08 <Boarders> :t join
12:38:10 <lambdabot> Monad m => m (m a) -> m a
12:53:04 * hackage git-annex 6.20180913 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-6.20180913 (JoeyHess)
12:59:40 <fragamus> Hi can anyone point me to an example of derived instances for aeson for a GADT like Language.Haskell.Exts.Syntax.Literal
13:02:41 <Ganwell> (Haskell newbie) I use megaparsec and I created two Parses one is equivalent (via megaparsec magic) to Char and the other to String. If I return them directly (return [x] ++ y ++ [z]) haskell cannot resolve the types. If I use an intermediate data-type it works. How do you actually solve this? https://gist.github.com/ganwell/84030528fc857480522c9f1449029b3d
13:03:03 <glguy> Ganwell: return ([x] ++ y ++ [z])
13:03:24 <Ganwell> damn
13:06:40 <Ganwell> glguy: Thanks a lot. That was quite embarrassing.
13:07:25 <Cale> fragamus: I was going to point you at something, but then I realised that the last piece which actually contains the Template Haskell code isn't open source yet, but I can tell you what we've been doing generally
13:08:14 <Cale> fragamus: The main bit, which is open sourced, is this repo: https://github.com/obsidiansystems/constraints-extras/tree/develop/src/Data/Constraint
13:08:42 <Cale> Well, actually, depending on what you're doing, maybe you don't even need that.
13:09:00 <Cale> If you're just converting the GADT itself to JSON, and not things depending on its indices
13:09:44 <Cale> For that, I would recommend writing just a straightforward instance of ToJSON, but then the FromJSON instance should be in an existential wrapper
13:09:56 <Cale> (like Data.Some)
13:11:19 <Cale> But yeah, we've been doing a lot of stuff where we have GADTs whose index tells us the type of another piece of data, that we also need to know how to convert to JSON
13:11:36 <Cale> So the library I linked gives you the ability to say stuff like  Has ToJSON MyGADT
13:11:49 <Cale> (which is a constraint)
13:12:19 <Cale> and then if you have some k :: MyGADT a, and you want to know (ToJSON a)
13:12:31 <fragamus> Argh can you resend
13:12:32 <Cale> you can write  has @ToJSON k (... encode ...)
13:12:39 <Cale> ahh
13:13:08 <fragamus> I’m on mobile device
13:13:33 <Cale> I sent you a copy of the last couple minutes in PM
13:13:44 <Cale> (since you disconnected)
13:14:34 <Cale> https://github.com/obsidiansystems/constraints-extras/blob/develop/src/Data/Constraint/Extras.hs -- this is the module I've been talking about
13:14:40 <Cale> There's some TH to go along with it
13:14:58 <Cale> It might be handy depending on what you're doing with your GADTs
13:23:52 <fragamus> Thanks Cale
13:33:51 <Wyv3rn> how would you take every n-th element of a list in haskell?
13:35:06 <infinisil> Wyv3rn: Try to write the type of what you want
13:36:03 <Cale> > iterate (drop 5) [0..100]
13:36:06 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:36:20 <Cale> heh, right, not the most useful demonstration list
13:36:24 <Cale> > iterate (drop 3) [0..10]
13:36:27 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[6,7,8,9,10],[9,10],[],[],[],[]...
13:36:40 <Cale> > takeWhile (not . null) . iterate (drop 3) $ [0..10]
13:36:42 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[6,7,8,9,10],[9,10]]
13:36:48 <Cale> > map head . takeWhile (not . null) . iterate (drop 3) $ [0..10]
13:36:51 <lambdabot>  [0,3,6,9]
13:37:03 <EvanR> a great example of when head is not evil
13:38:56 <infinisil> > catMaybes . map listToMaybe . iterate (drop 3) $ [0..10]
13:39:02 <lambdabot>  mueval-core: Time limit exceeded
13:39:13 <infinisil> Darn
13:39:44 <infinisil> > catMaybes . takeWhile (/= Nothing) . map listToMaybe . iterate (drop 3) $ [0..10]
13:39:46 <lambdabot>  [0,3,6,9]
13:39:54 <EvanR> the detour through Maybe adds overhead
13:40:15 <infinisil> Yea
13:40:36 <MarcelineVQ> :t takeWhile (not . null)
13:40:38 <lambdabot> Foldable t => [t a] -> [t a]
13:40:39 <Cale> also, using the Eq instance for Maybe like that will require the elements of the list to have an Eq instance as well
13:40:46 <Cale> (but that's avoidable)
13:45:23 <lavalike> > takeWhile (not . null) . unfoldr (Just . splitAt 5) $ [1..20]
13:45:26 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
13:46:20 <c50a326> is the "todo list" an appropriate toy exercise for state monad practice?
13:47:07 <c50a326> constructed like `State [Todos] Todo`, maybe?
13:47:13 <[exa]> c50a326: yes, why not
13:47:46 <c50a326> couldn't find any results on google where anyone's done this, slightly surprised
13:47:51 <[exa]> c50a326: the other good exercise is reimplementation of State, if you didn't do that already
13:47:59 <EvanR> [6~[6~[6~wyv	sorry it seems noone has totally answered your question
13:50:12 <EvanR> oops
13:50:57 <infinisil> EvanR: (I'm trying to get them to be an active asker)
13:52:25 <EvanR> well, i eventually took the question literally... assuming you'd know haskell, how would you really do it
13:52:46 <EvanR> some package?
14:03:46 <infinisil> Oh right, I even misunderstood the question lol, I just thought Cale was doing some random stuff
14:04:41 <infinisil> > zipWith (!!) [1..100] [0,3..]
14:04:44 <lambdabot>  error:
14:04:45 <lambdabot>      • No instance for (Enum [()]) arising from a use of ‘e_1110003’
14:04:45 <lambdabot>      • In the expression: e_1110003
14:08:01 <EvanR> zip with bang bang could be a good band name
14:08:29 <olligobber> > (!! [0,3..]) <$> [1..100]
14:08:31 <lambdabot>  error:
14:08:31 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
14:08:31 <lambdabot>      • In the second argument of ‘(!!)’, namely ‘[0, 3 .. ]’
14:08:53 <olligobber> wait, what is !!?
14:09:19 <EvanR> :t (!!)
14:09:21 <lambdabot> [a] -> Int -> a
14:09:25 <lavalike> > "olligobber" !! 3
14:09:27 <lambdabot>  'i'
14:09:54 <infinisil> @let everynth arr n = (arr !!) <$> [0,n..length arr - 1]
14:09:54 <lambdabot>  /home/lambda/.lambdabot/State/L.hs:159:1:Parse error: virtual }
14:10:02 <infinisil> > everynth arr n = (arr !!) <$> [0,n..length arr - 1]
14:10:04 <lambdabot>  <hint>:1:16: error:
14:10:04 <lambdabot>      parse error on input ‘=’
14:10:04 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:10:10 <olligobber> oh, that's backwards from what I expected
14:10:12 <infinisil> Goddamnit somebody tell me how to define stuff
14:10:24 <MarcelineVQ> you did it, lambdabot's having a rough day.
14:10:25 <olligobber> > ([0,3..] !!) <$> [1..10]
14:10:28 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
14:10:28 <EvanR> i've been wondering what every 0 would do 
14:10:52 <EvanR> > [0,0..]
14:10:55 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:11:10 <Ariakenom> Expected.
14:11:14 <infinisil> > let everynth arr n = (arr !!) <$> [0,n..length arr - 1]; in everynth [1..100] 5
14:11:16 <lambdabot>  [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96]
14:11:30 <infinisil> That works
14:11:44 <EvanR> > [0,0..10]
14:11:46 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:11:52 <EvanR> rofl
14:12:05 <infinisil> [0,0..0
14:12:10 <infinisil> > [0,0..0]
14:12:11 <EvanR> when your finite lists become infinite
14:12:12 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:12:30 <infinisil> > [0,0..(-1)]
14:12:32 <lambdabot>  []
14:14:50 <infinisil> A question from me:
14:15:32 <infinisil> I'm writing a library that provides a state transition function for its type (along with an initial state), it needs IO to do this transition
14:15:55 <infinisil> And it might throw an error as a result of a transition
14:16:16 <infinisil> (hold a minute)
14:17:33 <infinisil> Now, how should I best do this?
14:17:34 * hackage x509 1.7.4 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.7.4 (VincentHanquez)
14:17:57 <infinisil> Should I write it with `MonadIO m, MonadState <mytype> m, MonadError <error type> m`?
14:18:06 <Ariakenom> > let x = undefined in ()
14:18:09 <lambdabot>  ()
14:18:13 <Ariakenom> > let x = undefined :: Void# in ()
14:18:14 <infinisil> That seems like the best option
14:18:15 <lambdabot>  error:
14:18:15 <lambdabot>      Not in scope: type constructor or class ‘Void#’
14:18:15 <lambdabot>      Perhaps you meant ‘Void’ (imported from Data.Void)
14:18:29 <ph88> how can i know if there is an stack-nightly with ghc that has newer than this commit ? https://git.haskell.org/ghc.git/commitdiff/76a233143f1ec940f342ce3ce3afaf306923b392 
14:19:19 <infinisil> Because I had trouble with MonadError, because you can't use mapExceptT with it
14:19:59 <infinisil> That makes me want to use ExceptT directly, so `MonadIO m, MonadState T m => ... -> ExceptT E m a`
14:20:45 <infinisil> I guess similarly I can't use mapStateT with MonadState :/
14:20:51 <infinisil> :t mapStateT
14:20:52 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
14:21:18 <infinisil> Well I *can* use it, but not as conveniently, it would need some rewrapping
14:21:46 <MarcelineVQ> ph88: you check the trac for it and see what ghc version it's going to end up in  https://ghc.haskell.org/trac/ghc/ticket/15529   then you can check the latest nightly and see if that's the same or higher at the top of the page https://www.stackage.org/nightly
14:21:55 <infinisil> So I'm thinking of just using `StateT T (ExceptT E IO a)` instead
14:22:08 <infinisil> But that won't be as flexible for the user of the library
14:23:21 <ph88> MarcelineVQ, should i look at the milestone version ?
14:23:30 <MarcelineVQ> milestone is the section that tells you what ghc it's going into, but it's also mentioned in a post if you read the trac
14:24:01 <ph88> ah ok i get it
14:24:20 <ph88> what would i need to do to get this version of ghc right now ?
14:24:31 <ph88> and not wait for stack to have 8.6.1
14:26:51 <MarcelineVQ> To get it you'd download the 8.6.1 branch of ghc it looks like and build it, or build from master branch, based on these tract posts. making stack use a ghc you built yourself is quite a bit of a hassle in my experience, especially so if it's new because the resolvers don't match up against it
14:27:35 <ph88> i think i've done it once before
14:27:43 <ph88> but compiling took hours
14:27:54 <ph88> and i forgot to write down how i did it -____-
14:28:09 <ph88> (i just remember this now - sorry bad memory)
14:28:24 <MarcelineVQ> https://ghc.haskell.org/trac/ghc/wiki/Building
14:29:34 <MarcelineVQ> compiling is the easy part, I would avoid optomizing it at all until you know whether you can get it to work with stack because it's much faster to build that way
14:32:15 <Wyv3rn> can someon give an example of how to filter a list using recursion? I'm having trouble understanding this 
14:32:38 <MarcelineVQ> ph88: The easiest way to use a custom ghc wth stack that I found was to build a bindist from the source code and specify a path to it via https://docs.haskellstack.org/en/stable/yaml_configuration/#setup-info  and  https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-variant
14:32:51 <Cale> Wyv3rn: You mean implementing filter itself?
14:32:56 <Wyv3rn> https://pastebin.com/LA8XJfB2
14:33:00 <Wyv3rn> correct
14:33:04 <ph88> MarcelineVQ, i looked in my zsh history and found some things
14:33:19 <MarcelineVQ> But I never put in the effort to solve using a snapshot with a new ghc, though it can be done  https://docs.haskellstack.org/en/stable/custom_snapshot/
14:33:21 <ph88> PATH=/home/ph88/haskell/ghc-8.2.2/inplace/bin:$PATH stack --system-ghc --allow-different-user build --install-ghc --profile ./base-4.10.1.0
14:33:40 <Cale> That code looks correct
14:34:17 <Cale> The first line following the type signature says that if we filter the empty list, we obtain an empty list as the result
14:34:45 <Cale> and then  filter pred (x:xs) -- here we're pattern matching against a nonempty list whose first element is x, and whose tail is xs
14:34:58 <Cale> and then we have a couple of guards
14:35:38 <Cale> So if  pred x  i.e. if the function we're given, pred, applied to the argument x, gives True -- that means we should keep the element in the result
14:35:46 <ph88> i'm not gonna try compiling ghc now because my laptop will get too hot, but tomorrow it's possible
14:36:17 <Cale> and so we have x : filter pred xs  as the result in that case -- i.e. x is the first element of the resulting list, and the remainder of the resulting list is obtained by filtering the remainder of the input
14:36:41 <Cale> otherwise, the predicate isn't true of x, and so it shouldn't be included in the result
14:37:07 <Cale> in that case, the result is simply the result of filtering the rest of the input
14:37:27 <Cale> > filter even [1,2,3,4,5,6]
14:37:29 <lambdabot>  [2,4,6]
14:38:56 <sshine> > sort "(╯°□°）╯︵ ┻━┻"
14:38:58 <lambdabot>  " (\176\176\9473\9531\9531\9583\9583\9633\65077\65289"
14:39:02 <sshine> I agree.
14:40:25 <ph88> when is ghc 8.6.1 coming out anyway ?
14:40:31 <aarvar> Wyv3rn: you could also write `filter p (x:xs) = (if p x then (x:) else id) (filter p xs)`
14:40:57 <hexagoxel> > text $ sort "(╯°□°）╯︵ ┻━┻"
14:40:59 <lambdabot>   (°°━┻┻╯╯□︵）
14:41:02 <aarvar> or `filter p = foldr (\x -> if p x then (x:) else id) []`
14:42:38 <koz_> hexagoxel: Wat.
14:46:00 <Wyv3rn> what's a quick way to test if a number's last digit is equal to another number?
14:46:26 <dataN> is there a version of Vector for Trees?
14:47:21 <dataN> where a Vector is a list of fixed length, how can the shape of a Tree be defined?
14:47:47 <hexagoxel> Wyv3rn: for positive numbers, (number `mod` base)
14:47:49 <koz_> dataN: There's several approaches you can take.
14:48:00 <koz_> You could promote some kind of 'tree skeleton' and parameterize over that.
14:48:08 <dataN> if the type passed to define the shape of a Vector is an Int, what type gives the shape of a Tree?
14:48:11 <ph88> this seems pretty serious https://ghc.haskell.org/trac/ghc/ticket/14251 
14:48:17 <koz_> dataN: You'd need your own.
14:48:20 <koz_> It'd be a tree itself.
14:48:29 <koz_> You can think of the type as defining an isomorphism class of Tree.
14:48:40 <koz_> Depending on what kind of tree you have, it's possible to do it more simply.
14:48:52 <koz_> (for example, complete binary trees can be defined as vectors)
14:49:01 <koz_> But absent further info, that's about as much as I can tell you.
14:49:05 <hexagoxel> koz_: don't you like sorti, the sorted caterpillar? :)
14:49:19 <koz_> hexagoxel: I do, it's just a bit weird to see like that. :P
14:49:43 <koz_> dataN: What manner of Tree are we dealing with here?
14:49:45 <koz_> Rose tree?
14:50:48 <dataN> koz_ how does this vector to give the shape of a binary tree work? is it using the fact its countable, i.e. a list of Bools for Leaf or Branch corresponding to the order of visitation f a traversal?
14:51:00 <koz_> dataN: For a complete binary tree?
14:51:08 <dataN> so that Rose Trees would be similar but with Ints...
14:51:08 <koz_> Enumerate it in breadth-first order.
14:51:31 <dataN> hmm, no, that would need the order of traversal to be defined, and that would depend on the shape itself
14:51:35 <koz_> You can parameterize the shape over a traversal.
14:51:43 <koz_> And for a Tree, there are several.
14:51:45 <koz_> What's your goal here?
14:51:58 <koz_> Like, what kind of information about the Tree's structure are you trying to lift to the type level?
14:52:05 <dataN> ah, wait one moment for that
14:53:18 <dataN> first, the Tree is like Free, or possibly Cofree? and then there are Lists like Cofree, and various other Free or Cofree structures, and these should all have some way to fix their shape by a type argument
14:53:33 <koz_> dataN: So you have arbitrary arity?
14:53:46 <koz_> (for the tree in question)
14:53:56 <koz_> And what do you mean by 'shape'?
14:54:14 <dataN> what, like a multi parameter Free? no, just one parameter for now 
14:54:23 <koz_> dataN: No, not what I meant.
14:54:26 <dataN> shape as in Int for Vector
14:54:32 <koz_> For a tree, 'arity' is 'number of children'.
14:54:39 <koz_> That's the thing - there isn't _one_ such thing for trees.
14:54:44 <koz_> Especially of arbitrary arity.
14:54:55 <dataN> thats just a Rose Tree though?
14:54:57 <koz_> Depending on how specific you wanna be or what you care about, there are _many_.
14:55:05 <dataN> which is Free []
14:55:16 <dataN> or Free Vector...
14:55:19 <koz_> You can, for example, parameterize over a tree's number of leaves. That would be a lifted Int.
14:55:30 <koz_> You can also parameterize over its arity - that'd also be a lifted Nat.
14:55:38 <koz_> Well, not lifted, just a Nat.
14:55:52 <koz_> However, you can parameterize over its shape, but that's a tree itself - with no data.
14:56:00 <koz_> Which means you'd be defining an isomorphism class at the typelevel.
14:56:08 <koz_> So it would say 'all trees that are isomorphic to this one'.
14:56:20 <koz_> You can also parameterize by height.
14:56:27 <koz_> I'm sure there's a bunch I'm not recalling.
14:56:40 <koz_> Trees are fundamentally more involved structures that any linear structure (which includes lists, vectors, etc).
14:56:45 <dataN> hmm, probably the most general would be specify the number of branches at every node
14:56:53 <koz_> So 'arity'.
14:57:26 <dataN> right, and then the other restrictions of this would be defined by some isomorphism
14:57:38 <koz_> Now, given a Tree t a, where t :: Nat, does this mean 'at most arity t', 'at least arity t' or 'exactly arity t'?
14:57:39 <dataN> so yes, just considering this most general type
14:58:15 <dataN> what where for binary trees t = 2?
14:58:17 <dataN> not like that
14:58:30 <koz_> All of these are meaningful.
14:58:30 <dataN> each branch can have different number of branches
14:58:36 <dataN> each node*
14:58:38 <koz_> OK, so 'at most arity t' then.
14:58:45 <koz_> (by the way, binary trees don't _have_ to have two internal nodes)
14:58:56 <dataN> no, exactly arity t at each node
14:58:58 <koz_> s/internal nodes/children/
14:59:16 <koz_> So you wanna say that 'Tree t a' is 'a tree of exactly arity t, storing as'.
14:59:19 <koz_> That's really easy.
14:59:36 <koz_> You just do a rose tree definition in the standard way, except the child list has a typelevel length.
14:59:39 <koz_> So something like
14:59:51 <dataN> Free Vector
14:59:56 <koz_> data Rose (t :: Nat) a = Leaf a | Rose (Vec t (Rose t a))
15:00:19 <koz_> (or Vector t (Rose t a) if you prefer - probably more efficient)
15:00:24 <dataN> nono, t should be different for each node
15:00:40 <koz_> OK, that's a bit trickier.
15:00:49 <koz_> Because then you want to have a _maximum_ of t.
15:00:49 <dataN> so it cant take just a Nat as a parameter, its "shape" would be a tree of Nats, right?
15:01:00 <koz_> No, you can still do it that way.
15:01:02 <koz_> Something like
15:01:16 <koz_> data Rose (t :: Nat) a = Leaf a | Rose (Vector t (Maybe (Rose t a)))
15:01:41 <koz_> But that obviously only says 'this has at most arity t' at the type level.
15:01:50 <koz_> If you want _each node_ to declare its own arity individually, that's trickier.
15:01:58 <koz_> Is that what you want?
15:02:16 <dataN> no
15:02:23 <dataN> you still have t :: Nat
15:02:35 <dataN> it should be t :: Rose Nat
15:02:41 <dataN> ok, so now consider the use case. and this is where it gets bad, because it seems to recurse to progresivly higer liftings not to a fixed point... ! ... 
15:02:55 <koz_> Oh, so you _do_ wanna define isomorphism classes at the type level.
15:02:59 <fragamus> can someone have a look at this: https://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-Some.html
15:03:01 <koz_> You should have just said that from the get-go.
15:03:11 <koz_> Since you really weren't clear on that point.
15:03:31 <dataN> so the use case is, consider list as this is not so complex, a vector where each type is different. 
15:03:44 <dataN> this must have a vector of types *of the same shape*
15:03:56 <koz_> dataN: Yeah, I understand that.
15:04:05 <c_wraith> fragamus, what of it?
15:04:14 <dataN> then for trees, this becomes infinite?
15:04:14 <koz_> fragamus: Yeah, likewise. Not sure what the deal is.
15:04:25 <fragamus> well I dont understand tag t
15:04:26 <koz_> dataN: OK, please _actually read what I wrote_.
15:04:30 <koz_> Let me say it again.
15:04:48 <fragamus> tag <--- is that a type
15:04:50 <koz_> A linear structure (list, vector, what-actual-ever) has _one_ definition of 'shape' - its length.
15:04:58 <koz_> _Trees_ have _several_.
15:05:12 <dstolfa> are people arguing over what a type is again?
15:05:16 <c_wraith> fragamus, tag is a type constructor of kind (k -> *) 
15:05:18 <dataN> they are all restricted versions of rose trees
15:05:21 <koz_> The one you _seem_ to want is 'isomorphism class', which is an exact copy of the tree structure at the type level.
15:05:26 <fragamus> ok
15:05:34 <koz_> Saying that 'for trees it's infinite' makes no actual sense.
15:05:42 <fragamus> and tag t?
15:05:42 <koz_> It depends what you wanna lift into the type level.
15:05:43 <c_wraith> fragamus, t is a type of kind k, for the same k
15:06:33 <c_wraith> fragamus, (tag t) is some type of kind *
15:06:40 <koz_> If that's your goal, then it most certainly is not 'infinite' by any means - what you'd be saying by this is 'this is the type of trees which are isomorphic to each other'.
15:06:56 <fragamus> ok I think I am starting to get it
15:06:56 <koz_> Now, this is totally fine and dandy, but it's not the only choice of 'shape' you can lift into the type level.
15:07:12 <koz_> I previously gave multiple alternatives.
15:07:31 <koz_> If this is your goal, then the thing you wanna lift to the type level is a tree with no data.
15:07:34 <c_wraith> fragamus, for instance, This Nothing :: Some Maybe
15:07:59 <dataN> value level vectors have a Nat parameter, and so does the type lists. but if a value level tree takes *the same shaped* tree of Nats as a parameter then this creates a recursion
15:08:09 <dataN> oh wait, maybe its a slightly smaller tree
15:08:13 <dataN> that would converge
15:08:26 <koz_> Yeah, because you have the Leaf option right?
15:08:36 <fragamus> nice
15:08:38 <koz_> That terminates the recursion, since Leaf t a can have whatever t you feel like.
15:08:43 <c_wraith> fragamus, or maybe more usefully:  This (Just ()) :: Some Maybe
15:09:07 <c_wraith> fragamus, where tag ~ Maybe and t ~ ()
15:09:17 <koz_> However, a definition like that would have to have _each_ internal node track its arity individually.
15:09:28 <koz_> _That_ is tricky, because that can vary basically however it feels like.
15:09:48 <koz_> You could have a node with three children, each of which has five children except the last, which is a leaf,for example.
15:10:01 <dataN> right, each shape would have a unique specification
15:10:15 <koz_> I'm still having some trouble grasping why you need to lift tree isomorphism classes to the type level.
15:10:49 <dataN> to get a tree where every type corresponds to a type level tree of types of the same shape
15:11:03 <koz_> Yeah, I get the _benefit_ of such a thing.
15:11:15 <dataN> these can be at the leaves if its Free like, or at all nodes if its Cofree like
15:11:38 <koz_> These have to be at _everything_ if you wanna encode tree isomorphism classes like that.
15:11:43 <dataN> ( the values of each respective type )
15:11:44 <hexagoxel> (funny how `Some` exposes just the shape of the contained structure - you did not intend to add to the other ongoing discussion, did you fragamus?)
15:11:47 <koz_> Since each internal node would need to know what shape its subtree has.
15:12:05 <fragamus> nope
15:12:20 <hexagoxel> Some Maybe ~ Bool, Some [] ~ Nat
15:12:20 <dataN> koz_: right, exactly
15:12:28 <hexagoxel> Some RoseTree ~ ?
15:12:31 <fragamus> I slipped on the right banana peel
15:12:43 <hexagoxel> :)
15:13:03 <koz_> dataN: So basically, again - you're lifting rose trees with no data.
15:14:00 <dataN> if its not a smaller tree, then the lifted version would need its own shape and it would just keep getting lifted endlessly 
15:14:13 <koz_> No, the lifted tree doesn't have its own shape.
15:14:19 <koz_> It's a _specific instance_ of the lift.
15:14:34 <koz_> The type 'Leaf is a specific instance of that lift.
15:14:52 <koz_> Just like the type 'Rose ['Leaf, 'Rose ['Leaf, 'Leaf]]
15:14:54 <koz_> Etc.
15:15:07 <koz_> They don't need their own structural info.
15:15:47 <koz_> The former defines 'all trees isomorphic to a single leaf node'.
15:15:47 <dataN> sure they do, just like the type level vector must have the same length as the value level one so that each value has exactly one type
15:16:12 <koz_> Yeah, but the idea is that the typelevel rose tree has the same shape as the value-level one too.
15:17:27 <koz_> foo :: Rose ('Rose ['Leaf, 'Rose ['Leaf, 'Leaf]]) Int = Tree 1 [Leaf 2, Tree [Leaf 3, Leaf 4]]
15:17:47 <koz_> foo :: Tree ('Rose ['Leaf, 'Rose ['Leaf, 'Leaf]]) Int = Tree 1 [Leaf 2, Tree [Leaf 3, Leaf 4]] -- bit clearer
15:18:29 <dataN> ok, you were forced to omit a "shape defining parameter" to write that
15:18:55 <koz_> To Tree? Yeah, but if you think about how it'd be constructed, you'd have
15:19:07 <koz_> mkLeaf :: a -> Tree 'Leaf a
15:19:11 <koz_> And
15:19:41 <koz_> mkInternal :: a -> Tree s a -> Tree t a -> Tree 'Rose [s, t] a
15:19:43 <koz_> Or so.
15:19:57 <koz_> (this example is binary, but you can define more functions as you need)
15:20:46 <koz_> Then, for example, if you wanna define an operation which only makes sense for internal nodes, you'd do
15:21:01 <koz_> someOp :: Tree ('Rose [s, t]) a -> b
15:21:09 <koz_> (my bracketing may be off)
15:21:13 <koz_> (but I'm not a compiler)
15:24:43 <michalrus> Hey, is there some standard `data FakeEq UUID a` wrapper defined for types that can’t have an `instance Eq a`?
15:24:58 <koz_> michalrus: What do you want exactly?
15:25:17 <michalrus> koz_: a Set of Network.WebSockets.Connection =)
15:25:31 <michalrus> And an ability to check whether n-th is the one I mean.
15:26:37 <michalrus> I mean, I can define that easily myself… but if there’s anything standard to counteract the fact that we can’t just test arbitrary references for equality… =)
15:26:42 <michalrus> I’d rather use that.
15:27:11 <dataN> foo :: Tree ('Rose ['Leaf Int, 'Rose ['Leaf Int, 'Leaf Int]]) = Tree [Leaf 1, Tree [Leaf 2, Leaf 3]] 
15:28:01 <dataN> argh, no, more like what you had
15:28:47 <Solonarv_> you could use a *Map UUID Connection ?
15:29:07 <Solonarv_> (where *Map is probably HashMap, but could be some other variant)
15:29:21 <michalrus> Solonarv_: i’m doing that, but it’s getting old fast =P
15:29:58 <dataN> foo = Vector (S Z) [1] :: Vector (S Z) (Int ': '[]) 
15:30:19 <Solonarv_> getting old how? you could always write a bunch of utility functions to abstract over the implementation of your connection pool
15:31:28 <michalrus> That set is just an example, in general I have places where I want to test two connections for equality.
15:31:40 <michalrus> And to keep UUIDs sort of… separate… is tiring.
15:32:00 <michalrus> I guess these utility functions could be instance Eq, instance Hashable etc.
15:32:17 <michalrus> Hmm. It should be relatively safe with smart constructors.
15:33:16 <Solonarv_> consider working in a ReaderT ConnectionPool RestOfTheStack, and writing wrappers that take an UUID and look up the connection in the environment rather than taking a Connection directly
15:33:24 <michalrus> Is it very wrong? :p It’s not top Haskell, for sure…
15:33:33 <michalrus> Hmmmm.
15:34:14 <michalrus> But then we’re introducing amortized O(1) everywhere, which are, ummm, O(log32(n))?
15:34:32 <michalrus> For HashMap lookups.
15:35:36 <Solonarv_> HashMap lookups are very cheap
15:36:10 <michalrus> +
15:36:20 <michalrus> I would need an STMContainers.Map, tho. ^.^ Should be cheap too.
15:43:46 <Solonarv_> I've implemented a resource pool system to handle asset loading and text rendering for my game; after abstracting it behind an mtl-style class it became quite easy to work with
15:52:48 <fresheyeball> is there a way to negate ~ in a constraint?
15:53:28 <geekosaur> no. think about it; open world
15:53:33 <fragamus> regarding my earlier question about Data.Some: the higher order function withSome takes a value and a function and the forall in the function's type signature is saying that I must define the function for all of the possibilities right 
15:55:34 <koz_> dataN: There's a further problem that this isn't really isomorphisms: 'Rose ['Leaf, 'Rose ['Leaf, 'Leaf]] is isomorphic to 'Rose ['Rose ['Leaf, 'Leaf], 'Leaf], but to your code, they're different.
15:56:07 <hexagoxel> fresheyeball: a == b ~ 'False, using http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Type-Equality.html#t:-61--61-
15:56:46 <hexagoxel> maybe needs to be (a == b) ~ 'False
15:59:38 <hexagoxel> fragamus: yes. The only thing you can `withSome` out of a `Some Maybe` is whether or not it is Nothing.
16:00:20 <fragamus> ok so it's not meant to extract data
16:00:49 <hexagoxel> it extracts shape and shape only
16:00:58 <fragamus> weird voodoo
16:01:14 <fresheyeball> hexagoxel: where is == defined?
16:01:18 <fresheyeball> for the type level like that
16:01:47 <fresheyeball> erp ignore me
16:03:35 <hexagoxel> (is it still called shape when the type argument is not of kind * ?)
16:04:41 <dataN> koz_: here is the version for Vector; https://lpaste.net/4625795668894547968
16:04:56 <hpc> hexagoxel: i would say even more so
16:05:32 <hpc> oh, the argument
16:05:39 <hpc> maybe
16:05:50 <hpc> i can see the type argument being the same in that instance, for some types
16:05:56 <hpc> er, being the shape
16:08:34 <dataN> can there be a class Shaped, with an associated type e.g. for Vector it would be Nat, and then it gives the TypedVector automatically?
16:08:48 <dmwit> hexagoxel: I'm not even convinced "shape" is a good name when the type argument *is* of kind *.
16:09:15 <dmwit> hexagoxel: With suitable GADT trickery, you can get everything about the value out (and we do this a lot in codebases I work on at work).
16:10:13 <dataN> dmwit: especially since its the same term being used to differentiate between different lengthed lists, where the length is the shape, or different shaped trees.
16:10:54 <dataN> but maybe if the curried list arity of types is used there is some validity 
16:11:25 <dataN> sorry thats just gibberish 
16:12:10 <dataN> but kinds that are not linear seem unwieldy 
16:13:13 <dataN> especially if they are cyclic graphs... 
16:14:33 <dataN> this seems as undefined as for functions of branched type
16:15:48 <dataN> hmm, but normally that would just mean that a value was constructed by applying a multi parameter function to cast the branches to *
16:16:15 <dataN> anyway, sorry, I have no idea what your typing about really
16:25:38 <koz_> dataN: Yeah, that's structural.
16:25:59 <koz_> I would go with a phantom for the shape personally - it's a lot less painful.
16:26:08 <koz_> (modulo the issue I raised just before)
16:26:21 <koz_> You _could_ do something like this maybe?
16:27:47 <koz_> No, never mind, that'd be rather hard to write.
16:27:49 <dibblego> why might cabal new-repl break with "cc1: fatal error: dist/build/autogen/cabal_macros.h: No such file or directory" after adding {-# LANGUAGE CPP #-} to a source file?
16:27:57 <koz_> The idea is that each node carries a Rose in it.
16:28:06 <koz_> Which describes its subtree.
16:28:10 <koz_> But that's incredibly annoying.
16:30:00 <dataN> thats not a clear description, as a Rose Tree has a Rose Tree at each node anyway
16:30:09 <koz_> Rose is the data-less one.
16:30:13 <koz_> Tree is the data-containing one.
16:33:15 <dataN> ok
16:33:28 <dataN> that sound about right then
16:35:31 <dataN> what about something like; data FreeN (n :: N) (ts :: FreeN (Pred n) k) (f :: k -> * -> *) a where
16:36:54 <dataN> just in the hope that this concept of the "data-less one" somehow correlates to this recursion terminating
16:37:37 <dataN> anyway, thats the clearest way to state the concern
16:37:50 <dataN> so far...
16:40:03 <dataN> e.g. if it has a TypedVector at each layer, then the overall argument is a Free Vector of types...
16:40:20 <koz_> dataN: I honestly don't understand Free and Cofree enough to say anything sensible.
16:40:26 <koz_> For all I know you're probably right.
16:40:47 <koz_> I stated it from the data structural point of view - and the isomorphism thing I mentioned before could still be an issue with this.
16:41:30 <dataN> right about what? that it might recurse lifting upwardly indefinitely? 
16:41:54 <koz_> dataN: There's a further problem that this isn't really isomorphisms: 'Rose ['Leaf, 'Rose ['Leaf, 'Leaf]] is isomorphic to 'Rose ['Rose ['Leaf, 'Leaf], 'Leaf], but to your code, they're different. <-- that
16:42:17 <dataN> right, those are different shapes
16:42:19 <koz_> Where 'your code' is the one _not_ based on Free.
16:42:23 <koz_> Yeah, but they're actually not.
16:42:27 <koz_> When you think about what data they contain.
16:42:39 <koz_> Or rather, when you think about what the trees look like absent data.
16:42:50 <dataN> seems like Rose === Tree ()
16:42:57 <ph88> 561 megabytes for ghc head ? o_O
16:43:02 <koz_> That... has been my point _quite literally_ for the last hour.
16:43:41 <dataN> my point is that in order to have the same shape, they must take the same parameter, so that Rose cannot then be this parameter without recursing
16:44:09 <koz_> Yeah, but 'Rose' by itself doesn't mean anything.
16:44:23 <koz_> 'Rose ['Leaf, 'Leaf, 'Leaf] would be one such parameter.
16:44:37 <koz_> Another would be 'Rose ['Rose ['Leaf, 'Leaf], 'Leaf]
16:45:08 <dataN> and they would probably be defined at top level, or using a type family to produce them allegorically 
16:45:19 <dataN> similar to N1 N2 .. for Nats
16:45:40 <ChaiTRex> Is there a non-IO nondeterministic results monad?
16:45:46 <koz_> ChaiTRex: []?
16:45:57 <koz_> List is nondeterminism as an effect.
16:45:59 <ChaiTRex> I mean one solution only that's nondeterministic for the inputs.
16:46:10 <koz_> ChaiTRex: I don't understand what you mean.
16:46:32 <ChaiTRex> Like if I'm multithreading something and I find a solution. There might be multiple solutions. I return the first one I find.
16:46:35 <koz_> dataN: I don't think so - you can define Rose as above, lift it into the type level with DataKinds, and then define it that way.
16:46:35 <dataN> algoritmically* 
16:46:45 <ChaiTRex> But that can change depending on which I happen to find first.
16:46:48 <koz_> ChaiTRex: What if there are none?
16:47:06 <ChaiTRex> koz_: I'd make it a Maybe result, but these problems are generally one or more solutions.
16:47:18 <koz_> ChaiTRex: Then just use [] then safeHead?
16:47:28 <koz_> (which if I remember correctly is typed [a] -> Maybe a)
16:47:38 <ChaiTRex> koz_: Is the nondeterminism in that a problem with the type?
16:47:50 <koz_> ChaiTRex: I don't understand your question.
16:47:50 <dataN> the point with Free is that the Rose layers should have set length
16:47:55 <ChaiTRex> koz_: The "head" would be different each time potentially.
16:48:00 <koz_> dataN: Which is an upper bound on the arity, yes.
16:48:15 <dataN> what!?
16:48:17 <ChaiTRex> koz_: Basically, I stop work on all threads once the solution is found, so there's only one solution produced.
16:48:31 <dataN> that sounds like whats needed, but how is it a smaller Tree?
16:48:45 <ChaiTRex> koz_: So it violates referential transparency.
16:48:50 <hexagoxel> dmwit: you are right with your "shape" remark.
16:48:57 <koz_> ChaiTRex: Hold on.
16:49:02 <ChaiTRex> koz_: OK.
16:49:13 <koz_> So you're saying you nondeterministically try a bunch of things, and you get some set of 'answers', and you wanna give back one.
16:49:28 <koz_> However, for _any specific computation_, you want to make sure that if you run _that specific computation_ twice, you get the _same_ answer?
16:49:37 <ChaiTRex> koz_: No, the threads talk to each other. Once one finds a solution, it tells the others it's done, and they stop.
16:50:02 <koz_> ChaiTRex: So you want something involving message passing where you farm out a task to multiple workers?
16:50:02 <ChaiTRex> koz_: But which thread gets to the answer first can change.
16:50:11 <ChaiTRex> koz_: Yes, that's right.
16:50:21 <koz_> That isn't an issue of non-determinism specifically.
16:50:32 <koz_> If you want that, there's several ways to do in Haskell. Let me look up which ones I know about.
16:50:42 <ChaiTRex> koz_: OK, thanks.
16:50:56 <koz_> dataN: 'Smaller' in the sense that its representation is different. Let me give an example.
16:51:13 <koz_> Let's consider 'Rose ['Leaf, 'Rose ['Leaf, 'Leaf]
16:51:26 <koz_> This says 'I'm an internal node with a leaf child and an internal node child.
16:51:31 <dataN> it would be good if the layers of the Rose tree had fixed length using Vectors, thats where the recursion seems to enter
16:51:46 <koz_> If we think about that second child, it would be 'Rose ['Leaf, 'Leaf], which is a 'smaller' representation.
16:51:51 <koz_> And we have to hit a 'Leaf _eventually.
16:51:57 <koz_> That's where you 'bottom out'.
16:52:21 <koz_> The thing is, 'fixed length' for child counts can mean one of two things:
16:52:25 <koz_> 1) At most n
16:52:27 <koz_> or
16:52:29 <koz_> 2) Exactly n
16:52:32 <koz_> 2) is much easier.
16:52:38 <dataN> 2) plz
16:52:40 <koz_> 1) is... not, unless you wanna have something like.
16:52:53 <koz_> Well, if it's _exactly_ n, and you know it at compile time, then it'd be like
16:53:10 <koz_> data Rose = Leaf | Internal Rose Rose ... Rose
16:53:17 <koz_> For however many Roses you need.
16:53:22 <dataN> nono
16:53:25 <dataN> variable
16:53:27 <dataN> and specified
16:53:42 <dataN> and via the requirement of that specification, another tree needs to be passed
16:53:49 <dataN> and its this that is hopefully smaller
16:54:06 <koz_> OK, so we can vary the arity _across_ trees, but not _within_ them?
16:54:37 <dataN> every node needs an Int, or is it a subtree... this is where it is confusing
16:55:55 <koz_> ChaiTRex: My best advice is that you read the entire Concurrent Haskell section in 'Parallel and Concurrent Programming in Haskell' by Simon Marlow.
16:56:03 <fragamus> Cale you here?
16:56:12 <dataN> this is the only way to ensure the tree of types has the exact same shape as the the tree of values
16:56:27 <dataN> which can be considered to be the specification
16:56:47 <koz_> ChaiTRex: https://web.archive.org/web/20180130024330/http://chimera.labs.oreilly.com:80/books/1230000000929/pt02.html
16:57:00 <dataN> the various different shaped Rose trees need to be distinguishable as Nats are at compile time
16:57:00 <ChaiTRex> koz_: OK, thanks.
16:57:12 <koz_> dataN: Basically, Rose needs to contain a _fixed-length_ list of children.
16:57:33 <koz_> So that means you actually want something like this:
16:58:08 <koz_> Tree (n :: Nat) a = Leaf n a | Internal (Vec n (Tree n a))
16:58:27 <koz_> The idea being that Leaf n a works for _any_ n, since leaves lack any children whatsoever.
16:58:53 <dataN> all the n need to be able to be different at different nodes!
16:59:03 <koz_> No, because that doesn't agree with what you said.
16:59:11 <koz_> You said specifically that the arity _within_ a tree is fixed.
16:59:17 <koz_> Quite specifically.
16:59:30 <fragamus> https://gist.github.com/fragamus/9e472a78922c58b420bc164d06fa7645
16:59:32 <dataN> specified, not the same
16:59:51 <koz_> dataN: Then you clearly didn't read what I said, because that is _not_ option 2.
16:59:54 <koz_> That's option 1.
17:00:18 <dataN> there is no less than or equal here
17:00:25 <koz_> But there is.
17:00:32 <koz_> There's an upper limit to the arity across the entire tree, no?
17:00:36 <dataN> the idea of  bounding the internal lengths is not relavent 
17:00:41 <dataN> no 
17:00:51 <koz_> Uhh, yeah, for any given tree there would be.
17:01:03 <dataN> ok, its finite, but specified exactly
17:01:12 <koz_> That doesn't make any difference here.
17:01:14 <dataN> by the Nat argument to the Vector of branches 
17:01:41 <dataN> now since each node needs its own Nat, then these need to be provided by a tree as a parameter
17:01:48 <koz_> But yeah, this just brings us back to 'you gotta lift something like Rose to the type level'.
17:01:59 <koz_> So you gotta have each node carry a 'skeleton' of its shape in its own type.
17:02:16 <koz_> (which I believe my original solution does just fine)
17:02:28 <koz_> It's not structural in the same way Vec is - it's more like how vector-sized works.
17:02:54 <dataN> yes thats the opposite
17:03:05 <koz_> But this is why I asked, in the first instance, what you need this for.
17:03:15 <koz_> Because honestly, I don't see why this would be any different.
17:03:29 <dataN> it motivates a free Free version of Vector
17:03:29 <koz_> (from the point of view of ensuring that operations take the skeleton of the tree into account)
17:04:06 <koz_> dataN: Well, as I said, I don't know about Free or Cofree, so I can't say either way. However, if your goal was to do for Tree what we can do for Vec or Vector, then my suggestion works just fine.
17:04:15 <koz_> Anyone who actually understands Free or Cofree plz chime in.
17:04:19 <fragamus> so how did people decode json to GADT before dependent-sum package existed? It (is || was) huge hole in our programming model
17:04:41 <koz_> fragamus: I _think_ aeson defines some kind of type class to decode any given thing.
17:04:48 <koz_> (but I could be wrong)
17:06:05 <fragamus> I don't know but whatever it is it seems to skate the idea of type safety
17:06:29 <fragamus> because it has to be very floppy with respect to type
17:06:35 <koz_> fragamus: How so?
17:07:28 <geekosaur> fragamus, ths is more or less what typclasses are for. or dyou similarly think Read and Show skirt type safety?
17:07:45 <fragamus> well when you put it that way
17:07:49 <geekosaur> (it's FromJSON and ToJSON respectively, for aeson)
17:08:19 <geekosaur> modulo capitalization
17:08:44 <geekosaur> the whole pont of tepclassesis to allowths while preserving typesafety
17:09:08 <geekosaur> ugh. hate this keyboard, type too fast and half of it ges lost or misordered
17:09:25 <geekosaur> (have watched it happen. someone's bad at realtime programming)
17:11:21 <Cale> By the way, I really dislike the EqTag/OrdTag/ShowTag classes in dependent-sum, and I have a plan for replacing them completely
17:11:51 <Cale> They can all be replaced with a single thing that is more general.
17:17:34 * hackage deriving-compat 0.5.2 - Backports of GHC deriving extensions  http://hackage.haskell.org/package/deriving-compat-0.5.2 (ryanglscott)
17:54:06 <ph88> when building ghc it tries to bootstrap with ghc 8.2.1 but i also have 8.4.* by stack .. what version of ghc is configure finding ?
17:54:45 <dataN> I cant write; data X (x :: SomeTypeFamily x) ...
17:55:29 <dataN> it gives; error: Not in scope: type variable `x'
17:56:33 <ph88> i use docker it should be 8.2.2  https://github.com/gregwebs/ghc-docker-dev/blob/master/Dockerfile#L46 
17:57:55 <geekosaur> ph88, whatever is on $PATH, which you;'ll have to check locally
17:57:55 <ph88> ah maybe because i already ran this docker container in the past and it needs updating ?
17:57:58 <geekosaur> it does nto amgically run stack to find its ghc
18:01:25 <spoke> haskell is such a poignant lang
18:01:28 <spoke> i really like it
18:04:33 <ph88> if i issue the command  "make" to build ghc will it use all cores automatically ?
18:09:36 <geekosaur> make usually reqires -j for that, soem versions also require a number of jobs to be specified
18:15:29 <koz_> dataN: I just realized there's another way of looking at your problem.
18:15:43 <koz_> The _closest_ analogy to a fixed-length vector is a tree with a fixed number of nodes.
18:16:24 <koz_> Now, if we have _that_, it's possible to rank all trees of that order: https://en.wikipedia.org/wiki/Cayley%27s_formula
18:16:52 <koz_> Cayley's formula is for _undirected_ trees, whereas the ones we tend to think about in computer science are implicitly directed, but that's ultimately a detail.
18:17:11 <koz_> One way to do such an enumeration is using Prufer sequences: https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence
18:17:29 <koz_> So it means your Tree would need _two_ parameters - one for its order bound, the other for its rank.
18:17:44 <koz_> However, that number grows at a frankly absurd rate, so I don't know how good an idea that is.
18:18:40 <dmwit> data Tree n a where Leaf :: a -> Tree 0 a; Branch :: Tree n a -> Tree n' a -> Tree (n+n') a -- ? why more than one (number) parameter is needed?
18:19:06 <koz_> dmwit: Because you need a bound on the order to make any kind of ranking sensible.
18:19:16 <koz_> Since dataN wants the _structure_ lifted to the type level as well.
18:19:17 <dmwit> What is a ranking and why do I want it to be sensible?
18:19:34 <koz_> dmwit: Ranking is converting some structure to a natural number. Unranking is the reverse.
18:19:44 <dmwit> Doesn't my definition above meet your criteria of "a tree with a fixed number of nodes"?
18:20:04 <koz_> dmwit: It does, but dataN was concerned about structure of tree, not just count of nodes. 
18:20:11 <koz_> I specified that this is one way you could achieve it.
18:20:37 <dmwit> (Oh, well, I guess it should be `Leaf :: a -> Tree 1 a`. But anyway... =P)
18:20:50 <koz_> dmwit: Yours counts internal nodes. :P
18:20:54 <dmwit> Oh, this is a dataN discussion. Never mind then, I can never understand what they want or why.
18:21:01 <koz_> dmwit: Lol.
18:21:11 <koz_> It just occurred to me when I was driving around just before.
18:21:16 <koz_> (yes, I think about things like this when I drive)
18:21:20 <koz_> (probably not the best idea)
18:21:58 <dmwit> Sure, me too. Today on my commute I tried to find any non-trivial lower bound on the number of triangles in a simple graph with 10 nodes and 26 edges and failed.
18:22:26 <jle`> same
18:22:30 <koz_> dmwit: That's... actually fairly tricky. Did you try an induction or something?
18:22:41 <dmwit> I tried a couple counting arguments.
18:22:41 <koz_> jle`: Are you referring to dataN confusion or trying to solve mathematical problems while driving?
18:23:05 <koz_> dmwit: Yeah, I guess a counting argument would work. I suspect there's a theorem named after Erdos which gives the answer to that one.
18:23:06 <jle`> i'm talking about dmwit's specific problem
18:23:07 <dmwit> I thought I was getting somewhere by considering all subsets of nodes of size four and how many edges would be in the resulting subgraphs.
18:23:13 <jle`> but it was a joke heh
18:23:37 <koz_> dmwit: Remind me of the definition of triangle in a graph?
18:23:39 <dmwit> But after realizing I had proven a lower bound that was more than the number of triangles in a 10-clique I backtracked and discovered my calculation error.
18:23:48 <dmwit> koz_: 3-clique
18:23:49 <geekosaur> there's something about driving and deriving in here...
18:23:52 <koz_> dmwit: Ah.
18:24:00 <koz_> geekosaur: Don't drink and derive? :P
18:24:30 <jle`>  :set -XStandaloneDriving
18:24:39 <jle`>  :set -XDriveFunctor
18:25:02 <Psybur> What was your blood applicative content? D:
18:25:05 <koz_> LOL
18:25:13 <koz_> Psybur: I have a blood monad content, thanks.
18:25:51 <koz_> jle`: You forgot the all-important -XDriveGeneric
18:26:20 <jle`> GenericNewtypeDriving
18:27:19 <Solonarv_> ah, but every monad is an applicative
18:27:30 <koz_> Solonarv_: You make a valid point there.
18:29:46 <koz_> dmwit: Your problem just made me find something by Tim Roughgarden and I couldn't be happier.
18:30:50 <koz_> dmwit: This might help: https://mathoverflow.net/questions/209869/how-many-triangles-can-a-connected-graph-with-n-vertices-and-m-edges-have
18:31:04 * hackage neat-interpolation 0.3.2.3 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.3.2.3 (NikitaVolkov)
18:31:12 <koz_> Although that's an _upper_ bound.
18:31:21 <koz_> Hold on, let me link properly.
18:31:30 <koz_> https://mathoverflow.net/a/210198
18:31:43 <dmwit> https://math.stackexchange.com/q/125416/139921 appears to be the exact question.
18:32:00 <koz_> So it's 5.
18:32:02 <nshepperd> I *think* I've drawn a graph with 10 nodes and 25 edges and no triangles
18:32:13 <dmwit> nshepperd: Yes, K_{5,5} has that property.
18:32:38 <dmwit> nshepperd: Adding any one edge gets you what I believe to be the minimal possible number of triangles (5). But I've been having a heck of a time proving it.
18:32:41 <koz_> dmwit: Why were you pondering that question out of interest?
18:32:59 <dmwit> koz_: I have a calendar with a math problem each day. Most of them are easy-cheesy, do it in your head in under a minute kind of stuff.
18:33:04 <koz_> Ah.
18:33:07 <dmwit> But once a month or so they throw in a doozy. =)
18:33:10 <koz_> Just for some practice?
18:33:16 <dmwit> s/practice/fun/
18:33:19 <dmwit> I'm that kind of nerd.
18:34:54 <koz_> dmwit: I understand.
18:35:10 <koz_> I think I am too - I get into these interesting side tracks just to figure out what the answer is.
18:36:24 <nshepperd> ah, in retrospect it's obvious that 10 nodes gives you 25 edges with no triangles. just make a bipartite graph
18:36:51 <koz_> Random aside: is there a typelevel max for two Nats?
18:37:02 <dmwit> nshepperd: ...yes, K_{5,5}. =)
18:37:17 * nshepperd doesn't know that syntax :p
18:37:32 <dmwit> K_{m,n} is the complete bipartite graph with m nodes in one part and n nodes in the other.
18:37:55 <dmwit> But you should have asked me the first time I said it!
18:43:02 <dataN> not sure flattening the tree to a list as counting its nodes correct
18:43:17 <koz_> dataN: Did you read _any_ of what I linked?
18:43:34 <koz_> Prufer sequences are a unique ranking provided we have a bound on the number of nodes in the tree to do the unranking.
18:45:25 <dataN> dude I can count
18:46:08 <dataN> so something like a hash for trees?
18:46:21 <koz_> dataN: A _bijective_ hash, to be exact.
18:47:56 <dataN> was just trying to use Cofree to store the length of each layer of Free Vector as it seemed to make it inductive
18:49:04 * hackage neat-interpolation 0.3.2.4 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.3.2.4 (NikitaVolkov)
18:50:51 <dataN> how would this bijective measure help?
18:51:56 <dataN> there are many isomorphic representations of the shape, why would changing to any other equivalent representation change anything? 
18:54:48 <dataN> dmwit: its so the Free TypedVector can be zipped over to make a comonad to allow the types at each layer to be interchanged and used in update functions
18:55:36 <dataN> TypedVector was here; https://lpaste.net/4625795668894547968
18:56:28 <dataN> its the vertical extension to a zipper over a TypedVector to do something similar
18:56:45 <dataN> basically, so each value can use the adjacent types
18:57:14 <dataN> there are some recursion schemes of this form
18:58:45 <dataN> *the type of each value can use the types adjacent to the corresponding possition in the type level list of types
18:59:34 <dataN> where the TypedVector just allowed each value to have the type of the element in exactly the same position of the corresponding type vector
18:59:51 <dataN> *type level vector of types
19:00:18 <koz_> > bool 1 2 True
19:00:20 <lambdabot>  2
19:00:25 * koz_ always forgets the order.
19:02:48 <geekosaur> same as for maybe and either
19:06:03 <koz_> geekosaur: What do you mean, sorry?
19:06:40 <geekosaur> False isomorphic with Nothing and Left _
19:07:52 <geekosaur> maybe <noting> <just> <val>, either <left> <rigth> val, bool <false> <true> <val>, all putting the "fail-y" case first
19:08:12 <koz_> geekosaur: That's a good way to remember it - thanks!
19:15:00 <fragamus> is there a way to have a function    (Some Maybe -> Maybe a)
19:15:15 <dmwit> no
19:16:25 <fragamus> dmwit: I am writing a FromJSON instance for a GADT
19:17:12 <dmwit> you can use another type than Maybe to store a value plus its TypeRep and then do a dynamic check to see if the caller's chosen return type and the existential's stored type match
19:17:30 <dmwit> this is what Dynamic does, basically
19:18:04 <dmwit> okay FromJSON for GADT. so what?
19:18:54 <shachaf> Is there a reason for Dynamic not to be defined as an existential?
19:19:25 <fragamus> ok the tag of the GADT is in the Json and then depending on which tag, other data follows
19:19:26 <dmwit> i think it is defined that way these days
19:19:55 <fragamus> I'm just trying to work out how to do it
19:20:07 <dmwit> fragamus: don't see why that's a problem, really
19:20:08 <shachaf> Oh, man, so it is.
19:20:19 <shachaf> But not as data Dynamic = forall a. Typeable a => Dynamic a
19:21:29 <dmwit> basically the same, though
19:21:48 <shachaf> Seems so.
19:23:16 <dmwit> fragamus: maybe a minimized example of just the hard part would be a good conversation starter
19:25:50 <dmwit> afk for a few hours, but many others can help
19:33:14 <droplet> i'm playing with recursion schemes - is there a more natural way to mimic a filter than using a prepro/postpro? Right now I have a prepro where the cata just reforms the structure but this feels redundant
20:07:18 <koz_> :t evalStateT
20:07:19 <lambdabot> Monad m => StateT s m a -> s -> m a
20:07:26 <koz_> :t execStateT
20:07:27 <lambdabot> Monad m => StateT s m a -> s -> m s
20:07:36 <koz_> :t execState
20:07:37 <lambdabot> State s a -> s -> s
20:08:39 <juhp> cocreature: for example https://travis-ci.org/juhp/simple-cmd/jobs/428223505
20:09:22 <juhp> Actually ghc installs but not found apparently... maybe a path issue?
20:15:40 <dataN> whats this? https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable
20:16:28 <blankhart> droplet, not sure what you exactly what you mean but you can write filter on a ListF just using cata
20:17:57 <dataN> and this; http://hackage.haskell.org/package/base-4.11.1.0/docs/Type-Reflection.html
20:18:08 <dataN> is that better than Data.Reflection?
20:25:31 <crestfallen> hi I'm studying gadt's . a binary tree turns out to be an numeric sequence called the catalan numbers. there's a way to derive this from Tree = a + Tree^2   called the Taylor series. Is this important for understanding gadt's ? 
20:26:00 <crestfallen> *a sequence with catalan numbers in the coefficient place
20:26:29 <shachaf> Probably not. That ADT isn't even G.
20:27:24 <crestfallen> general? OK, thanks, I thought that acronym was to distinguish it from abstract data types (ADT)
20:27:42 <shachaf> If your meaning of "understand" includes counting the number of values of a particular type, then it's probably important.
20:29:30 <crestfallen> thanks shachaf  well, for example there are 5 binary trees containing 4 leaves. So....   
20:30:47 <crestfallen> the number of binary trees with n + 1 leaves = the nth Catalan number
20:31:15 <crestfallen> btw is that a geometric sequence or an arithmetic one?
20:35:29 --- mode: ChanServ set +o Sigyn
20:40:09 <koz_> jle`: I'm having a bit of trouble writing an HVec. Explanation here: https://lpaste.net/1550252828990111744
20:43:55 <deidyomega> Hey can someone explain:
20:44:03 <lyxia> crestfallen: In Haskell, ADT more often means Algebraic Data Type, which is quite different.
20:44:11 <deidyomega> ["ACE"]!!0 -- Works
20:44:33 <deidyomega> but putStrLn ["Ace"]!!0 fails
20:44:40 <crestfallen> different from GADT you mean lyxia ?
20:44:54 <lyxia> crestfallen: different from abstract data type
20:45:07 <lyxia> crestfallen: btw the catalan sequence is neither geometric nor arithmetic
20:45:26 <crestfallen> yeah I read somewhere that GADT is used to differentiate the terms.. 
20:45:37 <crestfallen> GADT /= ADT
20:45:38 <lyxia> no it's not...
20:45:57 <blankhart> deidyomega, try putStrLn $ ["Ace"]!!0
20:46:04 <blankhart> operator precedence
20:46:51 <lyxia> There are three things: abstract data types (ADTs, in some contexts), algebraic data types (ADTs, in other contexts, more common than the previous ones when talking about Haskell and FP), generalized algebraic data types (GADTs, generalize the previous ones).
20:46:56 <deidyomega> What's the name of the symbol for haskell sake, so I can research what the money sign does in this context?
20:47:51 <crestfallen> thanks ok lyxia    so I'll right it out until I get it straight :)
20:48:56 <koz_> deidyomega: $ :: (a -> b) -> a -> b
20:49:00 <mniip> so I'm reading the article on F-aglebras on wikipedia: https://en.wikipedia.org/wiki/F-algebra
20:49:01 <koz_> f $ x = f x
20:49:30 <mniip> do I understand correctly that the functor representation of the model doesn't necessarily contain any of the laws
20:49:37 <blankhart> deidyomega, it is called the application operator
20:50:32 <blankhart> it is the same as what you had (no operator at all) but changes the precedence of function application
20:51:23 <blankhart> koz_ left out the important part of the definition (or was getting there), which was infixr 0
20:51:48 <koz_> blankhart: Yeah, you kinda ninja'd me a bit there.
20:52:04 <deidyomega> >_> Man... I've got a long way to go... 
20:52:32 <koz_> deidyomega: It also works if you do putStrLn (["Ace"] !! 0)
20:52:45 <koz_> (and is arguably easier to follow)
20:54:17 <blankhart> mniip, what do you mean by the functor representation of the model?
20:54:22 <deidyomega> Yeah... I see that, basically there are standard functions, but they operator, denotes order...  which is more used, just wrapping your functions with () or using $?  I'm a python dev, so I'd naturally go with (), but I want to follow what's normal in this community
20:54:38 <deidyomega> Yeah... I see that, basically there are standard functions, but that operator, denotes order...  which is more used, just wrapping your functions with () or using $?  I'm a python dev, so I'd naturally go with (), but I want to follow what's normal in this community
20:54:56 <koz_> deidyomega: Using $ can eliminate brackets (as in the example blankhart gave), but if you feel more comfortable bracketing, stick tot hat for now.
20:54:59 <crestfallen> so the primary reason for writing out a data type's algebraic notation is for counting inhabitants of a Type, I suppose.
20:58:27 <crestfallen> is that correct?
20:58:59 <mniip> blankhart, I mean, algebraic structure
20:59:19 <mniip> e.g for the group the signature consists of a () -> G, G -> G and a G x G -> G
21:04:11 <shachaf> mniip: Yes, F-algebras just give you operations, not laws
21:06:35 <droplet> blankhart: sure but that seems not in spirit of either a cata or a filter - you can do the same thing using an ana instead
21:07:15 <shachaf> hi droplet
21:07:21 <shachaf> Are you the one who asked about Nu?
21:07:28 <droplet> i generalised what i was thinking earlier to \x -> prepro x embed
21:07:38 <droplet> hi shachaf, no i don't think that was me
21:08:01 <shachaf> Someone on Stack Overflow did. I guess it's just a similar name.
21:08:51 <droplet> my stack name isn't related to this one so definitely not me :)
21:09:36 <droplet> Oh hold on, the comment was me - I thought you meant something else, sorry!
21:10:01 <droplet> I just saw your reply - that clears it up thanks
21:11:18 <shachaf> It's kind of an odd thing that ('x' :: exists a. a) and (True :: exists a. a) are considered equal.
21:15:33 <droplet> Can I thank you for that post by the way - it cleared things up more than most other resources I've seen
21:16:34 <shachaf> Something longer ought to be written up about these things.
21:17:55 <shachaf> For context the post is https://stackoverflow.com/q/45580858
21:19:29 <koz_> shachaf: That's one helluva post.
21:19:32 <koz_> Very nicely written.
21:24:34 <infinity0> is there a way to fmap a HList at the type-level
21:26:32 <infinity0> as in, i have a function storeData :: HList xs -> m () where xs is some type-level list of types
21:26:52 <infinity0> or rather function signature, in a class definition
21:27:23 <infinity0> then i want to require another function loadData :: HList xs' -> m () where xs' is something like [(a -> m x) for x in xs]
21:27:41 <infinity0> i'm not sure how to express that
21:29:35 <infinity0> e.g. https://repl.it/repls/LooseRoughConversion
21:34:11 <infinity0> i mean, i guess a work around would be to define a "type GetReferents a" and have all instances of that class perform the fmap manually, explicitly in the source code
21:39:45 <umbriel> are there any functors that wouldn't support the pure function from applicative? 
21:39:57 <umbriel> i'm just wondering why pure is a method of applicative and not functor
21:40:44 <shachaf> Sure, "data Void1 a"
21:41:33 <blankhart> using the websockets library, how do i handle the case where the connection is refused?
21:41:53 <shachaf> Even in the case of Applicative, the instance isn't canonical -- there are various options for pure.
21:41:57 <shachaf> On its own it's even worse.
21:42:11 <blankhart> i don't see anything about this in the API, and i can't seem to catch any exceptions
21:42:12 <shachaf> But Functor instances are unique.
21:42:13 <umbriel> i don't understand.
21:42:33 <shachaf> "data Void1 a" is a type that has no values.
21:43:09 <umbriel> i understood that much
21:43:27 <umbriel> how can that be a functor or applicative? 
21:43:43 <shachaf> It's not Applicative. But fmap is easy enough to write.
21:47:15 <umbriel> i can't think of how to do it
21:47:48 <koz_> umbriel: Ignore whatever the function does and give back another Void?
21:47:54 <umbriel> other than fmap = undefined
21:48:38 <umbriel> how do you give back a value of type Void when there are no values of that type
21:49:33 <koz_> :t fmap
21:49:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:49:46 <koz_> You _can_ give back a function of type Void1 a -> Void1 b
21:55:07 <umbriel> such a function couldn't return any value though
21:58:11 <Solonarv> yeah, but you can never call it, so that doesn't matter
21:58:32 <koz_> :t absurd
21:58:33 <lambdabot> Void -> a
21:59:36 <dminuoso> umbriel: Also you can't implement pure for `Const a` (unless you constrain `a` to also have an instance Monoid) 
22:00:36 <dminuoso> umbriel: Or ((,) a)
22:00:53 <Solonarv> umbriel: or Map k
22:02:58 <umbriel> is Const a different from ((,) a) ?
22:03:05 <koz_> @src Const
22:03:05 <lambdabot> Source not found. My brain just exploded
22:03:08 <koz_> :(
22:03:13 <jle`> koz_: what library are those modules in your paste from?
22:03:23 <koz_> jle`: My own. Don't worry, I figured out how to do this.
22:03:29 <koz_> Now I have a more 'fun' task ahead.
22:03:39 <dminuoso> umbriel: Yes very much so.
22:03:52 <Solonarv> yes: newtype Const a b = Const b; data (,) a b = (a, b)
22:03:58 <Solonarv> (paraphrased)
22:04:01 <koz_> Solonarv: You beat me to it.
22:04:18 <Solonarv> er, newtype Const a b = Const a
22:04:19 <jle`> koz_: o yea i meant HVec, HVecF
22:04:23 <Solonarv> (a, not b)
22:04:49 <jle`> umbriel: `Const a` is slightly different from (,) a, actually, but they have essentially the same Functor and Applicative instances so it can be useful to understand one in terms of the other
22:04:50 <koz_> jle`: fixed-vector-hetero
22:05:18 <jle`> umbriel: Const a is ((,) a) . Proxy, essentially
22:05:37 <dminuoso> umbriel: `Const a` is one of the more interesting functors.
22:05:45 <dminuoso> I'd argue that it's one of the most powerful ones in fact.
22:06:01 <jle`> umbriel: for `Const a b`, the b is phantom.  for (a, b), the b is not
22:07:25 <jle`> oh i missed the entire conversation leading up to this
22:08:09 <dminuoso> So is there any connection to SKI combinator calculus and the power of Identity/Const?
22:08:18 <dminuoso> s/to/between/
22:11:15 <dminuoso> umbriel: Another category of things are basically many comonads.
22:11:37 <dminuoso> Or.. perhaps not many. But you may be able to find some there. :)
22:18:45 <umbriel> i don't think any tutorial introduces Const
22:19:11 <koz_> umbriel: https://blog.jle.im/entry/const-applicative-and-monoids.html
22:21:23 <shachaf> dminuoso: Well, that's just "pure" not being unique.
22:21:35 <shachaf> The proposed Functor + pure doesn't really have any laws to speak of.
22:21:53 <shachaf> It can just pick whatever value it wants.
22:23:14 <umbriel> i originally asked because i was wondering whether pure belonged with the functor class
22:23:22 <umbriel> thank you koz_ 
22:23:37 <koz_> umbriel: Thank jle` for writing it.
22:23:54 <umbriel> !
22:27:17 <jle`> umbriel: check out the Apply typeclass too for examples of things you're looking at
22:27:19 <jle`> http://hackage.haskell.org/package/semigroupoids-5.3.1/docs/Data-Functor-Apply.html
22:27:28 <jle`> those are functors who can ap, but not pure
22:27:45 <jle`> essentially "semigroupy functors"
22:28:09 <jle`> umbriel: docs say that (Map k) and IntMap are examples of Apply but not Applicative
22:28:24 <jle`> so you can write fmap but not pure
22:34:29 <dminuoso> shachaf: Ah I see.
22:34:35 <dminuoso> umbriel: Also note that the interface of `pure` is captured by Pointed
22:37:44 <umbriel> ah thank you
22:57:47 <dataN> the paragraph titled "Constraint promotion" of "Promoting Functions to Type Families in Haskell" says that it has to dispense of superclasses because of a lack of "constrained type families". the paper "Constrained Type Families" here; https://arxiv.org/pdf/1706.09715.pdf can help?
22:58:34 <dataN> It seems to all be in some kind of bizare syntax. is there a haskell implementation found anywhere? 
22:59:40 <dataN> it could be called "System CFC"
23:00:15 <dataN> maybe there is a proposal or something pertaining to its implementation or availability?
23:14:20 <mniip> hmm, if for groups, F(G) = 1 + G + G x G
23:14:47 <mniip> then wouldn't  Fix F  be only inhabited by various encodings of the identity?
23:23:58 <mniip> unrelated: perhaps liftA# would make a more useful encoding than SK
23:27:25 <MarcelineVQ> at first in my head I saw that as some variant of liftA over unboxed anonymous sums. idk if that even makes sense as words that go togther though.
23:27:28 <mniip> Hyper = Y (LiftA4 LiftA3 (LiftA0 LiftA2) (LiftA0 (LiftA0 (->))) (LiftA4 LiftA3 (LiftA0 LiftA2) LiftA0 (LiftA0 (LiftA0 Id)) (LiftA0 LiftA0)) (LiftA0 (LiftA0 Id)))
23:27:42 <mniip> if you squint a little, you can kind of see it
23:28:15 <MarcelineVQ> I mean, what are you lifting when they're unboxed, so maybe just cut that word out
23:28:29 <MarcelineVQ> And then the rest of it.
23:28:35 <mniip> MarcelineVQ, I mean liftA0, liftA1, liftA2, liftA3...
23:28:42 <mniip> shortened to liftA# where # stands for a digit
23:30:10 <MarcelineVQ> Yep got that, but it wasn't the first thought that busted down the shoddy hinged and rust patinad portal of the mind vault
23:36:26 <mniip> hrmph
23:36:42 <mniip> LiftA# works great for unary functions
23:36:48 <mniip> perhaps...
23:37:19 <Ariakenom> Is there a list of things built with frp in some shape somewhere?
23:37:49 <mniip> :t liftA3 . liftA3
23:37:50 <lambdabot> (Applicative f2, Applicative f1) => (a -> b -> c -> d) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c) -> f1 (f2 d)
23:38:00 <dminuoso> Are there any Haskell freelancers in here?
23:38:28 <quarters> hello. I'm trying to use haskell mode on emacs but am getting a message on the bottom: "Could not find module 'Prelude' There are files missing in the base-4.11.1.0 package....' The thing is the code compiles just fine but I get this error in emacs
23:39:00 <dminuoso> Im interested in whether there's good work in the field, how easy it is to find contractors for Haskell in particular, etc. Well aware that this might depend on some factors, but how eager are shops to look for freelancers?
23:39:19 <mniip> lift_i,j = lift_j . lift_j . ... . lift_j  (i times)
23:39:27 <Ariakenom> dminuoso: what about consultants?
23:40:00 <Ariakenom> There are some haskell consultancies, right?
23:40:14 <dminuoso> Ariakenom: Sure
23:40:20 <mniip> those usually hire employees, not contractors
23:40:52 <infinity0> could someone help me with a basic type-level programming example https://repl.it/repls/ImpartialShockedDiscussions
23:40:58 <infinity0> not sure why this is "could not deduce"
23:41:22 <infinity0> "surely" the structure of how i defined FMap' means that FMap' hlist ~ '[] implies hlist ~ '[]
23:42:03 <mniip> infinity0, FMap' is not declared injective
23:42:17 <mniip> so the typechecker cannot derive such a conclusion
23:43:21 <infinity0> is it possible to do that?
23:43:39 <mniip> {-# LANGUAGE InjectiveTypeFamilies #-}
23:43:52 <mniip> type family FMap' (xs :: [*]) = (r :: [*]) | r -> xs where
23:45:02 <mniip> also what is the purpose of this type family if it's just identity
23:45:18 <infinity0> which version of GHC do i need ...
23:45:29 <infinity0> mniip: the "real example" was a real fmap, i was trying to reduce the example down
23:45:46 <mniip> a real fmap would not be injective
23:45:52 <mniip> unless
23:46:30 <mniip> well I guess  Fmap (f :: * -> *) (xs :: [*]) = (r :: [*]) | r -> xs
23:46:46 <mniip> but not r -> f
23:47:02 <mniip> Fmap f '[] ~ '[],  f ~ ?
23:47:08 <infinity0> i mean, i'm actually only doing two specific fmaps and they both are actually injective
23:47:10 <hololeap> is it true that defining a newtype with record syntax and using that function gives better performance than pattern matching on a newtype?
23:48:11 <mniip> hololeap, who told you that
23:48:17 <MarcelineVQ> Is that the entire claim or was there context?
23:48:31 <hololeap> i feel like i read it somewhere, but i couldn't find anything that said it when i just looked
23:48:59 <mniip> I suspect the two generate identical Core so it shouldn't make a differene
23:49:13 <hololeap> mniip: ok, thanks for confirming
23:49:51 <mniip> which unrelatedly makes me wonder, if we could extend RULES pragma syntax with coercions...
23:50:30 <mniip> map (|> co) xs = xs |> [co]
23:50:47 <infinity0> mniip: looks like it's TypeFamilyDependencies not InjectiveTypeFamilies, but it still doesn't work :( (i updated the code in that repl link)
23:53:50 <quarters> when I run "ghc-pkg check" I get a long wall of text starting w/this: here are problems in package HTTP-4000.3.12:
23:53:56 <quarters> I was wondering how to fix it
23:58:17 <mniip> infinity0, might be a GHC bug...
23:59:20 <mniip> maybe not...
