00:00:03 <cocreature> lortabac: pattern matching on Refl :: a :~: b brings the constraint a ~ b in scope. from that GHC deduces that VSucc a ~ VSucc b which lets you typecheck the "pure Refl" line
00:02:52 <lortabac> cocreature: ok right, I see. Thank you
00:26:44 <Digit> mm-MM-MMMH.  i love haskell.  ~  a gushing sentiment i get just re-reading definitions of monad, n thinking about it.  i just dont get this refreshing comforting clever cunning n clarity in attempts to learn other programming languages.  ~ it's more like (well organised) thought.  ~  not that i can no anything with Haskell worth a mention yet.  but i still love it.  n_n
00:41:31 --- mode: glguy set +v DrOid
00:46:07 <bahamas> in my project, I have `import qualified Data.Yaml.Include as Yaml` and I'm trying to use Yaml.decodeFileWithWarnings`, but I get this error: Not in scope: ‘Yaml.decodeFileWithWarnings’
00:46:11 <bahamas>     Module ‘Data.Yaml.Include’ does not export ‘decodeFileWithWarnings’.
00:46:38 <cocreature> bahamas: which version of the yaml package are you using?
00:46:45 <tdammers> aren't you supposed to just import Data.Yaml instead of Data.Yaml.Include?
00:47:09 <tdammers> also, are you sure the version of yaml you're using actually has that function?
00:47:34 <bahamas> how do I check the version? I just wrote `yaml` in my dependencies section
00:48:08 <cocreature> bahamas: stack or cabal?
00:48:10 <tdammers> which build tool are you using?
00:48:16 <bahamas> stack
00:48:32 <cocreature> bahamas: try "stack ls dependencies"
00:48:32 <bahamas> with a package.yaml file
00:49:00 <bahamas> this is what I get yaml 0.8.32
00:49:20 <cocreature> you need yaml >= 0.10
00:49:40 <cocreature> you can either bump your resolver to one that has that version or add the version to the extra-deps section in your stack.yaml
00:51:00 <bahamas> ok. I'll try the 12.9 resolver
00:53:14 <bahamas> btw, regarding cabal, has anyone considered adding a lock file to store all dependencies with specific versions? like npm.lock, cargo.lock and all the rest?
00:54:00 <bahamas> it looks like even with the 12.9 resolver, I get the same version of yaml: 0.8.32
00:54:45 <tdammers> there's cabal new-freeze which AFAIK does exactly that
00:55:03 <cocreature> bahamas: try a nightly resolver
00:55:34 <cocreature> lts resolvers don’t upgrade to new major versions so if 0.8 was the most recent when 12.x was first released, it won’t upgrade past 0.8.x
00:56:16 <Athas> bahamas: there is 'cabal freeze'.
00:56:47 <bahamas> that's great. I'll just cabal then
00:57:16 <bahamas> cocreature: I just added yaml-0.12.2.0 to extra-deps. thanks!
00:58:30 <maerwald> 12.10 is the latest resolver
01:02:10 <bahamas> maerwald: you're right. I don't know how I ended up to 12.9
01:39:20 <bahamas> how can I print the output of Yaml.decodeFileWithWarnings? the type of the return value is `Either Yaml.ParseException a`, but I don't know what `a` will be and where to put the annotation
01:42:37 <Cale> bahamas: You can't not know what a will be
01:42:56 <Cale> At least, ultimately.
01:43:56 <Cale> bahamas: You need to pick some type (which must have an instance of FromJSON) in order to be able to apply that function.
01:45:19 <Cale> Of course, you can write a function which is polymorphic in the choice of the type 'a', but then in order to print the output, you'll need to make some further assumptions about the type, like that it's also an instance of Show, perhaps?
01:46:38 <Cale> Note that you can pick the type 'Value' if you're not interested in decoding to anything more useful.
01:47:36 <Cale> (it's a type for representing arbitrary JSON values)
01:50:04 <bahamas> Cale: yeah, I wanted to use Value, but I didn't know how. adding IO (Either Yaml.ParseException Yaml.Value) as a type annotation to Yaml.decodeFileEither call made it work
01:50:33 <Cale> Just doing anything with the result which would imply that it should have type Value would also work
01:51:23 <bahamas> Cale: btw, my goal with all of this is to be able to edit the yaml file. I don't exactly know how I'll modify this Value thing. do you know what I can do?
01:51:47 <Cale> Well, what sort of edit are you making?
01:52:20 <bahamas> Cale: add or remove an entry from an array
01:55:13 <bahamas> this is what the decoded file looks like https://lpaste.net/1533540041794519040. it's the hpack format
02:04:22 <Cale> I was going to say you probably should just use hpack's library to decode the file format using its types, but then I had a look and discovered that it's... not so nice.
02:05:16 <bahamas> Cale: the decodeFile function offered by hpack returns the same format :)
02:05:22 <Cale> If you know what change you want to make, you can just write it as a function Value -> Value -- if you're familiar with lenses, then the lens-aeson package might be useful
02:05:37 <Cale> Yeah, but hpack uses it at a particular type
02:05:45 <Cale> which it doesn't properly define... it's a synonym
02:06:06 <Cale> That type determines how the file is decoded
02:06:50 <bahamas> Cale: I'm not familiar with lenses (I'm just starting out with Haskell), but I will look at lens-aeson
02:06:50 <Cale> (well, more properly, the FromJSON instance for it does)
02:08:05 <Cale> Mainly, it just defines a bunch of prisms and lenses for working with Value, which is convenient if you know how to use them already, because it'll let you dig through the structure and change the part you want.
02:08:50 <bahamas> I'll check it out. I have to go now. thanks for the pointers
02:11:18 <bbear> I just received my "Algebra: chapter 0" book
02:11:22 <bbear> seems really neat
02:37:09 <lieven> he should publish chapter 1 one of these days
02:50:59 <c50a326> what's the name for the feature that lets you declare "symbolic constructors" like data BinTree a = Leaf a | BinTree a :^: BinTree a
02:51:11 <cocreature> c50a326: that’s just regular Haskell
02:51:17 <c50a326> specifically the :^: thing though
02:51:26 <cocreature> sure but that’s still regular Haskell
02:51:30 <cocreature> no need for any extensions or whatever
02:52:16 <c50a326> yeah but where do I find the documentation on this ability?
02:52:52 <merijn> c50a326: Operator constructors are Haskell 98/2010. The rules are "must be all operator characters and must start with capital letter (like regular constructors)" where ":" was arbitrarily defined as the one and only capital operator character
02:53:03 <cocreature> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
02:53:11 <cocreature> see “infix conop”
03:14:02 --- mode: glguy set +v dataN
03:15:17 <dataN> @let f :: (Int -> Int) -> (Int -> Int); f = undefined
03:15:18 <lambdabot>  Defined.
03:15:29 <dataN> @let g :: Int -> Int; g = undefined
03:15:31 <lambdabot>  Defined.
03:15:37 <dataN> > g (f (1::Int) (2::Int))
03:15:39 <lambdabot>  error:
03:15:39 <lambdabot>      Ambiguous occurrence ‘g’
03:15:39 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.g’,
03:16:00 <dataN> * Couldn't match expected type `Int -> Int' with actual type `Int' 
03:16:19 <dataN> can something like that be done using (&) ?
03:17:38 <ski> > L.g (L.f (1::Int) (2::Int))
03:17:40 <lambdabot>  error:
03:17:40 <lambdabot>      • Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’
03:17:41 <lambdabot>      • In the first argument of ‘L.f’, namely ‘(1 :: Int)’
03:17:46 <ski>   > L.f L.g (1 :: Int)
03:17:55 <ski> > L.f L.g (1 :: Int)
03:17:57 <lambdabot>  *Exception: Prelude.undefined
03:18:09 <ski> not sure what you're after, passing two `Int's there ..
03:18:31 <dataN> well you cant write; f = 1 2
03:18:42 <dataN> and expect them to be passed in order to g
03:18:50 <Cale> huh?
03:19:01 <ski> `g' only takes a single `Int', so i'm still not following what you're attempting to do
03:20:37 * ski looks at dataN
03:21:59 <dataN> something like; mappend (something :: (x -> y) -> Int ? Int) (1::Int) (2 :: Int)) = 3
03:22:21 <dataN> oops, x = y = Int there
03:22:48 <dataN> is that not possible with (&) ?
03:24:42 <dataN> *frowns*
03:26:05 <AWizzArd> data Op = Equal Term Term | NotEqual Term Term     Now in  f :: Op -> Int   I pattern-match into vars:   f op t1 t2 = ...         In the body of f I would like to check if `op` is `Equal` or `NotEqual`. Is there a way to do this with `case`?
03:26:26 <dataN> @let type family A a :: * where A (a :: Int -> Int) = Int -> Int
03:26:27 <lambdabot>  .L.hs:168:1: error:
03:26:27 <lambdabot>      Multiple declarations of ‘A’
03:26:27 <lambdabot>      Declared at: .L.hs:158:1
03:26:37 <AWizzArd> case op of    Equal -> 200         This doesn’t work because Equal should have two arguments.
03:27:06 <dataN> ok, guessing thats *not* how (&) works and this is totally impossible 
03:27:45 <barrucadu> AWizzArd: case op of Equal _ _ -> ...; NotEqual _ _ -> ...
03:27:45 <ski> dataN : what value do you even want the result of that example to be ?
03:27:59 <Cale> dataN: What do you mean by (&)? Flipped application?
03:28:17 <dataN> Cale: yeah the normal definition 
03:28:37 <dataN> ski: some kind of argument supplying stream
03:28:49 <ski> AWizzArd : `f op = case op of Equal t0 t1 -> ..t0..t1..; NotEqual t0 t1 -> ..t0..t1..' ?
03:29:06 <AWizzArd> ski: yeah, I would have to reconstruct it again.
03:29:13 <AWizzArd> Thought I could possibly go around this step.
03:29:15 <ski> AWizzArd : which is the same thing as `f (   Equal t0 t1) = ..t0..t1..; f (NotEqual t0 t1) -> ..t0..t1..'
03:29:29 <ski> AWizzArd : why reconstruct ?
03:30:05 <ski> dataN : it would help if you could at least say what result you'd like computed for your particular illustrating example
03:30:10 <AWizzArd> I wanted to treat the constructor as data, as a value.
03:30:23 <dataN> ski: there is an =3
03:30:43 <ski> dataN : it would also help if you could give working (but perhaps not as nice) code that achives the same thing, but which you want to reformulate (for whatever reason), if possible
03:30:57 <dataN> it does not seem possible at all
03:31:35 <ski> i think our problem is that we don't know what your "it" in "it does not seem possible" even refers to
03:31:53 <ski> (not knowing what you want to achieve, it's hard to offer specific useful help)
03:32:36 <ski> AWizzArd : ah, ok, so when you wrote `f op t1 t2 = ...' you really meant to say `f (op t1 t2) = ...'
03:32:51 <tsaka_> I have a data struct of program run options which is read from command line and passed around. Is there any reason to use in a reader monad (Reader ProgOps) instead of just passing the struct around?
03:32:57 <AWizzArd> Yes, my example was wrong. I will post a better one somewhere.
03:33:31 <barrucadu> dataN: Do you want to be able to write `f (g (h (i (... arg1 arg2 arg3 arg4 arg5 ...))))`, where each function takes as many arguments as it needs, and the next function down gets the rest of the arguments?
03:33:34 <ski> AWizzArd : so, try `data Op = Relation Operator Term Term; data Relation = Equal NotEqual', and then `f (Relation op t0 t1) = case op of ...'
03:34:30 <ski> AWizzArd : conceptually, we've rephrased `Term*Term + Term*Term' (your original `Op' type), as `2*Term*Term' (my `Op' type, `2' corresponding to my new `Operator' type having two values)
03:34:31 <AWizzArd> ski: I have already pattern-matched against Op and then call a function inside a `where` to which I pass the constructor as a Function.
03:34:44 <dataN> barrucadu: no, they should supply the arguments to the next function down
03:35:06 <AWizzArd> ski: yeah, I would have to make the different operators real values.
03:35:27 <maerwald> is there a way to run a haskell script with dependencies without pre-compiling and without stack?
03:35:53 <ski> AWizzArd : (hm, i'm not sure i understand "I pass the constructor as a Function", but) ok
03:36:00 <AWizzArd> ski: my idea was to match against the constructor like this: https://lpaste.net/1167191984419373056
03:36:17 <AWizzArd> I am passing the constructor to the `go` function.
03:36:28 <ski> AWizzArd : did what i said help any at all (as in perhaps learning something new. or perhaps you had already seen what i was saying) ?
03:36:32 <AWizzArd> And in there I would like to check which one I passed.
03:36:49 <Cale> dataN: Did you just want something like g f = f 1 2 ?
03:36:52 <AWizzArd> ski: what you said makes sense.
03:37:30 <ski> AWizzArd : i suppose you could pass a `Bool' (if you don't want to define something like my `Operator') to `go', if you wanted to
03:37:49 <dataN> Cale: g :: (Int -> Int)
03:37:56 <Cale> Yeah, this is a different g
03:38:06 <AWizzArd> ski: yes, I will need values here, other than data constructors.
03:38:13 <AWizzArd> I see this now.
03:38:37 <Cale> My g :: (Num a) => (a -> a -> r) -> r
03:38:46 <ski> AWizzArd : i still suspect that what you want is something like my `Operator' ..
03:39:11 <Cale> dataN: It's a thing which applies an arbitrary function to the two arguments 1 and 2
03:39:32 * ski idly wonders whether dataN has seen type class constraints, yet
03:41:56 <dataN> f :: Int -> Int -> ? ; f x y = (x+1) ? (y+1); (+) (f 1 2) = 5
03:42:34 <Cale> There's no way that (+) anything = 5 unless 5 is a function
03:43:13 <dataN> not with any amount of continuations and flips? 
03:43:20 <Cale> :t (+)
03:43:21 <lambdabot> Num a => a -> a -> a
03:43:47 <Cale> If we apply (+) to one argument, it will have type (Num a) => a -> a (for some a, which is whatever type of argument we supplied)
03:43:55 <Cale> There's no way to prevent that from being a function
03:44:25 <dataN> (+) (? 1 2) = ?? 1 + 2 
03:44:58 --- mode: glguy set +v dataN_
03:45:08 --- mode: glguy set -v dataN_
03:45:27 <Cale> Unless 2 is a function, and (+) is addition of functions, that won't typecheck.
03:45:28 <dataN_> Cale: sure
03:45:42 <Cale> (on the right hand side)
03:45:45 <ski> > let f :: Int -> Int -> (Int,Int); f x y = (x+1) ? (y+1); (?) = (,) in uncurry (+) (f 1 2)
03:45:47 <lambdabot>  5
03:45:49 <ski> > let f :: Int -> Int -> (Int -> Int -> o) -> o; f x y = (x+1) ? (y+1); (x ? y) k = k x y in (+) & f 1 2
03:45:51 <lambdabot>  5
03:46:00 <dataN_> the idea is that it somehow takes the function to its left and passes it onto its rhs
03:46:09 <ski> dataN_ : looking for something like those ^ two ?
03:46:40 <Cale> Yeah, maybe you're just looking for the idea of pairs?
03:46:55 <ski> > let f :: Int -> Int -> (Int,Int); f x y = (x+1) ? (y+1); (?) = (,) in (+) `uncurry` f 1 2  -- variant notation for the first one
03:46:57 <lambdabot>  5
03:48:16 <dataN_> @Undefine
03:48:16 <lambdabot> Undefined.
03:48:25 <dataN_> @let type family A a :: * where A (a :: Int -> Int) = Int -> Int
03:48:26 <lambdabot>  Defined.
03:48:35 <dataN_> :kind! A (Int -> Int)
03:48:40 <dataN_> % :kind! A (Int -> Int)
03:48:41 <yahb> dataN_: ; <interactive>:1:1: error: Not in scope: type constructor or class `A'
03:48:53 <dataN_> % type family A a :: * where A (a :: Int -> Int) = Int -> Int
03:48:54 <yahb> dataN_: 
03:48:56 <dataN_> % :kind! A (Int -> Int)
03:48:56 <yahb> dataN_: ; <interactive>:1:4: error:; * Expected kind `Int -> Int', but `Int -> Int' has kind `*'; * In the first argument of `A', namely `(Int -> Int)'; In the type `A (Int -> Int)'
03:49:18 <dataN_> % :kind! A (forall a. a :: Int -> Int)
03:49:18 <yahb> dataN_: A (forall a. a :: Int -> Int) :: *; = Int -> Int
03:49:34 <ski> you have `A :: (Int -> Int) -> *', not `A :: * -> *'
03:49:39 <dataN_> % class B a b
03:49:40 <yahb> dataN_: 
03:50:13 <dataN_> % instance B (A (forall (a :: Int -> Int). a))
03:50:13 <yahb> dataN_: ; <interactive>:38:10: error:; * Expecting one more argument to `B (A (forall (a :: Int -> Int). a))'; Expected a constraint, but `B (A (forall (a :: Int -> Int). a))' has kind `k0 -> Constraint'; * In the instance declaration for `B (A (forall (a :: Int -> Int). a))'
03:50:23 <ski> % :kind! A (forall a. a :: IO String)
03:50:23 <yahb> ski: ; <interactive>:1:3: error:; * Expected kind `Int -> Int', but `(forall a. a :: IO String)' has kind `IO String'; * In the first argument of `A', namely `(forall a. a :: IO String)'; In the type `A (forall a. a :: IO String)'
03:51:47 <dataN_> so a multiprameter typeclass over the result of a type family can be defined if its all curried and flipped
03:53:39 <dataN_> no, because the (* -> * -> Constraint) cant have an instance over its curried version
03:54:00 <dataN_> so it needs to give the arguments one at a time
03:54:41 * ski is not following dataN_ at all here
03:54:49 * ski also needs to go, so ..
03:54:55 <Cale> Yeah, I don't get what's going on
03:55:11 <dataN_> well you would have A returning (Int,Int) not Int -> Int
03:55:12 <merijn> Idris in Haskell is going on :p
03:55:30 <dataN_> or Int ? Int
03:57:19 <maerwald> note to self: never invoke cabal from within a stack script. The ways stack manipulates and messes up the environment...
03:57:27 <maerwald> that's actually where the ghc panics came from
03:59:10 * merijn facepalms
03:59:46 <merijn> You ever spend a day debugging something super confusing only to realise you fucked up something completely obvious without noticing >.>
04:01:12 <dataN_> merijn: your not using a typechecker?
04:01:31 <merijn> I was using resource-pool to have, well, a resource pool. I refactored some code which meant I needed my own "withResource" version. And then I bollocksed it up by not releasing the resource on exception, which meant I just got stuck with a pool of broken resources >.>
04:02:52 <Ariakenom> super fast resource pool*
04:14:16 <merijn> \o/
04:14:25 <merijn> Stuff is no longer inexplicably broken!
04:24:32 <hpc> merijn: now it's explicably broken?
04:24:45 <merijn> hpc: Now it appears to actually work again :)
04:25:54 <`Guest00000> do NOT ation
04:29:57 <merijn> hpc: Of course that involved fixing this specific bug in addition to a bunch of other small and not so small bugs in my own libraries :p
04:38:19 <matheus21> Can somebody tag me in a message, so I can test my notifications? That would be great! :) (maybe even a PM?)
04:39:12 <c50a326> matheus21: #freenode or ##chat is probably good for that kind of thing, but ok :D
04:40:46 <matheus21> c50a326: thanks! Notifications don't work for me :( oh well. Yeah I tried #freenode, but nobody would answer :/
04:49:49 <tsaka_> say you want your program to continue calculating fibonacci numbers until you hit CTRL-C, then print the last calculated fib, how would you do it? can you separate keylistener-exit logic from fib-caller logic?
04:51:48 <Ariakenom> tsaka_: Sure. You need the fib calculation to save the latest value
04:52:21 <merijn> tsaka_: On unix?
04:52:32 <tsaka_> unix
04:52:34 <merijn> tsaka_: You can install a signal handler to handle SIGINT, yes
04:52:55 <Ariakenom> but the default behaviour of exception seems fine
04:53:03 <merijn> As for interrupting fibonacci computation, you'd have to move that into IO somehow so you could check when to exit
04:53:36 <merijn> Like, store the last computed number into an IORef/TVar every step, then read it out before exiting
04:53:53 <Ariakenom> I'd say modify the fib to save it to a Ref, catch the exception and print the Ref
04:59:10 --- mode: glguy set +v abhir00p[m]
04:59:27 <abhir00p[m]> Is there a way to mutate an unboxed vector in place at O(1)?
04:59:34 --- mode: glguy set +v hmmhiihoo322
05:00:33 <abhir00p[m]> The modify function (http://hackage.haskell.org/package/vector-0.12.0.1/docs/src/Data.Vector.Generic.html#modify) is seemingly creating a copy of the new vector
05:00:44 <merijn> abhir00p[m]: eh, Data.Vector.Unboxed.Mutable? ;)
05:01:48 <abhir00p[m]> ah didn't see notice that one thanks!
05:01:53 <merijn> abhir00p[m]: That's because Vector.Generic, as the name implies, is for Generic operations on any vector type :)
05:43:34 <hmmhiihoo322> what you guys editor setup for development with nix?
06:11:06 <awal> Hi. Can someone suggest an implementation of `hasBalancedParenthesis :: String -> bool` without using combinator libraries?
06:12:07 <dunnydann> anyone here use taskwarrior? I'm looking to increase the urgency coefficient based on tasks asigned to pro:work.specialproject and I can't figure out the syntax
06:12:37 <quicksilver> awal: is that a haskell question or an algorithms question?
06:12:40 <tsaka_> is it possible to ignore fields when pattern matching on a record ?
06:12:57 <quicksilver> I mean how would you do it as a human?
06:13:02 <quicksilver> tsaka_: absolutely
06:13:09 <quicksilver> tsaka_: that's one of the key advantages of it
06:13:54 <tsaka_> quicksilver: How. I tried "myFN myRecord {field1, field2, _}" but it gives me error on underscore
06:13:57 --- mode: glguy set +v Jetien
06:13:59 <`Guest00000> awal: balanced s = balanced s 0 where balanced "" 0 = True; balanced "" _ = False; balanced ('(':s) c = balanced s (c + 1); balanced (')':_) 0 = False; balanced (')':s) c = balanced s (c - 1); balanced (_:s) c = balanced s c
06:14:01 <Jetien> Hi! I'm learning conduit, and now I have this problem: I have a function ConduitT () a m () -> m r . How can I use this as a conduit?, ie turn this function to a ConduitT a () m r
06:14:37 <quicksilver> tsaka_: just leave it out.
06:14:40 <quicksilver> tsaka_: https://en.wikibooks.org/wiki/Haskell/Pattern_matching#Introduction_to_records
06:14:52 <merijn> Jetien: That...doesn't seem like something you can use as a conduit
06:14:55 <tsaka_> oh
06:16:31 <`Guest00000> may want to add forcing of second parameter to 'balanced' somewhere if there can be a lot of "(((((((((("
06:17:20 <Jetien> merijn: Hm... okay then I'm doing it wrong. I'm trying to build a conduit that takes a ByteString stream and then pipe this as stdin of an external program and returns the exit code. For the piping needs to happend in IO, because i'm using async. So in my question above a=ByteString, m=IO and r=ExitCode
06:18:08 <merijn> Jetien: Use conduit-extra? https://hackage.haskell.org/package/conduit-extra-1.3.0/docs/Data-Conduit-Process.html
06:19:51 <Jetien> merijn: I'm using that. I'm following the examples from https://github.com/snoyberg/conduit/blob/master/PROCESS.md . And it looks like you need to run in IO.
06:20:35 <Jante> Is there a function like `filter` but which _removes_ elements from a list?
06:20:56 <merijn> "ConduitT () a m () -> m r" is basically *already* a function that runs the conduit
06:21:15 <merijn> Jetien: So what you need to do is run the resulting "m r", how to do do that, depends on 'm'
06:21:25 <merijn> Which, in case of IO, just means "just execute it"
06:21:39 <merijn> Jante: filter, but compose the predicate with not? :p
06:21:51 <merijn> > filter even [0..10]
06:21:53 <lambdabot>  [0,2,4,6,8,10]
06:21:56 <merijn> > filter (not . even) [0..10]
06:21:59 <lambdabot>  [1,3,5,7,9]
06:22:07 <Jante> merijn: okay
06:22:30 <Jetien> merijn: ah okay, i think it get. thanks
06:23:15 <barrucadu> dunnydann: Try #taskwarrior: https://taskwarrior.org/docs/help.html
06:23:43 <dunnydann> barrucadu: I have, they are a quiet bunch. Thanks though!!!
06:34:36 <dmwit> dunnydann: I think what barrucadu was (gently) trying to tell you is that your question isn't really on-topic here. I'm sorry you didn't get help yet in the place where it is on-topic; but that doesn't make it more on-topic here.
06:37:48 <matheus23> awal: hasBalancedParens = (== 0) . foldl (\x c -> case c of '(' -> x + 1; ')' -> x - 1; _ -> x) 0
06:37:54 <matheus23> certainly not beautiful, but its a solution :D
06:38:16 <Ariakenom> ")("
06:38:24 <matheus23> aha
06:38:32 <awal> quicksilver: I'd do it in an imperative way by scanning over the string and keeping a count of open parens
06:39:09 <mniip> what you need is a monoid homomorphism
06:39:11 <awal> `Guest00000: Thanks, lemme check
06:39:11 <matheus23> awal: you can do something like this with foldl, its basically the same as "scanning over the string and storing X while doing it"
06:39:11 <dmwit> awal: Good idea! I think you should do that in Haskell, too.
06:39:29 <asheshambasta> Hi! For Megaparsec, is it possible to run the parser on a Text and get an Either result? The docs http://hackage.haskell.org/package/megaparsec-7.0.1/docs/Text-Megaparsec.html#g:3 only suggest a parseMaybe, which means I lose the error data.
06:40:05 <merijn> asheshambasta: eh..."parse"?
06:40:24 <greymalkin> Does anyone know of a good example of a Traversable non-Applicative?
06:40:29 <dmwit> asheshambasta: Perhaps you are confused by the existence of a String argument to `parse`, which is nevertheless not the input to parse.
06:40:38 <dmwit> asheshambasta: Read the docs for that function carefully. =)
06:40:39 <awal> Umm yeah that makes sense. I have no idea why I didn't think of doing the same with a foldl lol
06:40:44 <awal> Thanks guys!
06:42:08 <matheus23> awal: Mind that my "solution", as Ariakenom pointed out, is not correct
06:42:14 <asheshambasta> merijn, dmwit: I'm a little confused by "Name of source file" here
06:42:27 <dmwit> greymalkin: How about matrices?
06:42:27 <merijn> awal: "no idea why I didn't think of that" <- that's the difference between just starting and a few years of practice thinking about things recursively :)
06:42:42 <awal> matheus23: Right, I was talking about what dmwit said :P
06:42:47 <merijn> asheshambasta: Well, when parsing a file, you normally want to report "filename, line number and column"
06:43:01 <merijn> asheshambasta: The filename String is just "what to put in parse errors"
06:43:03 <awal> merijn: Preach!
06:43:34 <greymalkin> dmwit: Data.Matrix (at least) is Applicative
06:43:35 <Ariakenom> greymalkin: Set
06:43:55 <asheshambasta> merijn: I see, maybe its just me, but I don't find that piece of documentation intuitive at all.  I'd have gone with "Source of text to report in errors", or something similar.
06:44:32 <merijn> asheshambasta: runParser is slightly clearer about that
06:44:35 <dmwit> greymalkin: ...but the instance doesn't appear to be total.
06:44:50 <merijn> Incidentally, parse and runParser appear to be identical
06:45:16 <greymalkin> Ariakenom: I don't see an instance of Traversable in the documentation of Data.Set.
06:45:20 <dmwit> greymalkin: If the first matrix you pass to `(<*>)` contains functions which return matrices of different sizes, `(<*>)` can crash.
06:45:57 <Ariakenom> greymalkin: oh I misread Foldable
06:46:00 <dmwit> (Am I reading this wrong?)
06:46:17 <asheshambasta> merijn: yeah, I see, interesting. 
06:46:41 <dmwit> Ah, I am reading it wrong.
06:49:01 <`Guest00000> awal: note that using foldl requires you to walk through the whole string
06:49:02 <dmwit> greymalkin: Well, Map k appears to be Traversable but not Applicative.
06:49:20 <`Guest00000> there is probably a better solution using foldr
06:50:04 <`Guest00000> which stops right when you can already see that the string is unbalanced (like "()) xxxxxxx...")
06:51:34 <dminuoso> Where do fit Affine optics into the lens hierarchy/
06:52:15 <Younder> NVOptics  and that rtx does much of that for you.
06:52:59 <Younder> Also Nvidis has a ne system Edison espessially for robotics.
06:53:03 <Younder> new
06:53:21 <Younder> sorry, wrong channel
06:53:29 <lyxia> dminuoso: have you seen http://oleg.fi/gists/posts/2017-04-18-glassery.html
06:53:34 <tsaka_> how do you in general deal with namespacing structs? its very inconvenient that every field also becomes a function
06:53:44 <greymalkin> dmwit: Excellent, I'll ponder that a bit; it matches my use case well.
06:54:29 <dminuoso> lyxia: Ah that is great, thank you.
06:54:34 <tsaka_> do you prefix all fields with the struct name?
06:54:54 <tsaka_> I mean its very common to reuse struct field names, like "ID"
06:55:21 <Jante> What configuration do I need in Stack to enable {-# LANGUAGE RecordWildCards #-} project wide, so that I don’t have to activate this extension in every file?
06:56:09 <merijn> Jante: IMO, regardless if that's possible, you shouldn't.
06:56:20 <merijn> Project wide extensions are evil and should be avoided.
06:56:28 <Jante> merijn: why?
06:56:43 <merijn> Jante: Because now a file is no longer self-contained when someone is reading it
06:56:48 <Jante> There are many websites describing what they consider as safe extensions.
06:56:56 <merijn> Jante: Suddenly you need to remember which extensions are turned on elsewhere
06:57:17 <merijn> Jante: It's not about safety, it's about "if I open a random file, how easily can I figure out what's going on?"
06:57:18 <Jante> merijn: yeah though it's in version control and can always be verified and results in reproducible builds.
06:58:33 <noan> Is there a solid "newby friendly" editor setup for haskell that depends only on cabal/ghci instead of stack/intero?
06:59:03 <merijn> noan: ghcid works reasonbly well
06:59:17 <merijn> noan: But nothing really solid and integrated with most editors yet.
06:59:55 <merijn> I saw recently that ghc-mod is getting attention to support new-build, so if that's fixed we might have something more stable and newbie friendly again
06:59:56 <Younder> Seems to me most use emacs.
07:00:06 <merijn> Younder: That's probably a wrong impression
07:00:13 <dminuoso> lyxia: That's interesting, so a Lens composed with a Prism gives me an AffineTraversal, am I reading this right?
07:00:30 <merijn> Younder: My estimate from observing #haskell the past years is: 1/3 vim, 1/3 emacs, 1/3 misc editors du joure
07:01:16 <noan> Younder, I use emacs personally, but I want to prepare some sort of "getting started for new developers" guide for my work
07:01:43 <noan> I'm thinking adopting stack in the short term might be a necessary pill to swallow, to get the intero support and thus intellij plugins
07:01:50 <noan> since it's already an intellij shop
07:02:28 <Younder> Well I have tried Atom, but the integration doesn't work very well. At least on my machine.
07:03:31 <dmwit> mniip: https://lpaste.net/2772663391162990592
07:03:43 <Younder> VIM is fine, but like EMACS not newby friendly.
07:03:54 <dmwit> awal: (You might also like that link.)
07:04:12 <greymalkin> Thank you, dmwit, that was exactly what I was looking for.
07:04:17 <dmwit> ^_^
07:05:10 <dmwit> greymalkin: FWIW, you might like to look at TMap k (Maybe v); unlike Map k v, it is both Traversable and Applicative, and offers essentially the same operations.
07:05:12 <dstolfa> Younder: joe is minimal enough to get started, but gets lacking quickly
07:05:32 <dmwit> http://hackage.haskell.org/package/total-map
07:05:56 <greymalkin> dmwit: Actually, I was just looking for a way to define a Traversable that had other, non-defaultable information attached.
07:06:21 <hodapp> have never really found vim and emacs to be that much different in terms of "newby" friendliness
07:06:46 <greymalkin> Most implementations seem to be relative to Applicative, and I was having trouble getting past that to realize that the argument to `traverse` had to be applicative, so the datatype in question didn't need to be.
07:06:49 <dmwit> mniip: Oh, I'm sad I didn't think to write `foldMap summarize s == mempty` instead of what I did.
07:07:18 <hodapp> both of them involve learning keys that may not be already familiar
07:09:41 <jackhill> If you want intero functionality and emacs without stack, dante might be interesting, but doesn't solve the unfamiliar-with-emacs problem
07:11:59 <maerwald> hodapp: vim configuration is not that hard... emacs config is. Even enabling line numbers in a bug-free way requires to write entire modules
07:12:51 <maerwald> so there is a difference in newbie friendliness still... but once you try to do more with vimL, then it gets annoying
07:14:12 <Younder> I use Syntastic with vim. That makes it more friendly and useful. The default setup sucks.
07:14:48 <merijn> Younder: neomake is kinda nice, like syntastic, but if you have vim8+ (or neovim) you get async linting
07:14:48 <maerwald> syntastic is not async, unusable
07:14:57 <Younder> Supplying a setup file is an option.
07:15:07 <maerwald> ALE is the thing
07:15:29 <maerwald> but not so much for haskell
07:17:11 <dmwit> maerwald: vimL isn't *too* bad if you use Python for the language and only drop to vimL at the leaves for actually changing vim settings/variables/etc. IOW vimL isn't too bad if you don't use it. ;-)
07:17:48 <maerwald> I would rather do emacs lisp, but then I have to use emacs, haha
07:18:01 <maerwald> no luck, whatever you do
07:18:08 <`Guest00000> i think we all should learn 1000 languages and write i-th line of code in (i `mod` 1000)-th language
07:18:10 * dstolfa is waiting for someone to write a decent editor
07:18:28 <maerwald> all languages are the same
07:18:36 <`Guest00000> oh, but...
07:18:50 <`Guest00000> you cannot write haskell in bash...
07:18:54 <Ariakenom> `Guest00000: obviously I place Haskell first since it will solve the problem in one line
07:19:21 <merijn> `Guest00000: Have you seen mauke's Poly.poly?
07:19:32 <`Guest00000> (literally in bash the interpreter)
07:19:34 <merijn> `Guest00000: https://github.com/mauke/poly.poly
07:19:58 <merijn> THat's a file that's legal haskell (several extension mixes), shell, C, and a whole bunch of other stuff
07:21:04 <maerwald> looks like being smart about comments
07:21:29 <dstolfa> maerwald: it is, but it's also fun
07:21:38 <dstolfa> we need fun things in today's world
07:21:55 <maerwald> better delete all haskell code and join a dating app xD
07:22:28 <maerwald> no one will write code anymore, no bugs, no problems
07:22:59 <maerwald> but then the app will crash and no one will remember how to fix it
07:23:09 <maerwald> and everyone lives happily after
07:39:50 <zfnmxt> Am I just a idiot or is there no actual way to unzip an existing .zip using zip-archive? 
07:40:02 <zfnmxt> an* idiot (so yes, I am)
07:40:47 <tsaka_> If you need 1) A immutable object of program configuration, e.g. database port 2) to pass around a random generator, would have "State StdGen (Reader Opts a)" or the other way around with Reader of State?
07:42:08 <dmwit> zfnmxt: Does `toArchive` not do that?
07:42:28 --- mode: glguy set +v dataN
07:42:35 --- mode: glguy set -v dataN
07:42:41 <dataN> :t \f x y z -> f (x,y) z :: forall q x y z. (q y,q (x,y)) => (q y => y -> z) -> x -> y -> z
07:42:42 <lambdabot> error:
07:42:42 <lambdabot>     • Could not deduce: (q0 y, q0 (x, y))
07:42:42 <lambdabot>       from the context: (q y, q (x, y))
07:43:03 <zfnmxt> dmwit: I suppose I meant "from a FilePath". I guess that works, just annoying to use. Why wouldn't they have `toArchiveFromFilePath` or something?
07:43:13 <dataN> why cant it reconstrain the function?
07:43:15 <dmwit> tsaka_: Sounds reasonable. Reader and State commute, so either direction is fine.
07:43:31 <dmwit> zfnmxt: Because there is already `Data.ByteString.Lazy.readFile`?
07:44:22 <tsaka_> dmwit: but I have to use ReaderT or StateT in order to combine them and use both?
07:44:30 <dmwit> tsaka_: Yes.
07:45:32 <zfnmxt> dmwit: Still should've provided a :: FilePath -> Archive function imo :) 
07:46:50 * dmwit shrugs
07:50:59 <dataN> its not possible?
07:54:14 <dataN> if 'f' is the function of a class, then passing it as an argument fixes its constraint?
07:54:36 <dataN> there doesnt seem to be a way to get a new version of it...
07:57:15 <awal> tsaka_: Did you get an answer to your question?
07:58:03 <tsaka_> awal: Yes. does it ever matter which one comes first? ReaderT State .. or StateT Reader ..
07:58:28 <awal> tsaka_: I meant about namespacing struct fields
07:58:45 <tsaka_> awal: Oh, no. I just ended up prefixing them 
07:59:33 <awal> tsaka_: Okay
08:00:51 <shapr> Who's at ICFP this next week?
08:00:54 <shapr> dmwit: you showing up?
08:01:01 <shapr> I haven't seen you since HacPhi
08:04:00 <tsaka_> Can anyone show me how to generate a random number from the exponential distribution? Using any package. The (only) example on the random-fu github page (https://github.com/mokus0/random-fu/) does not execute.
08:17:18 <dstolfa> <- not there :(
08:18:06 <merijn> tsaka_: Have you looked at mwc-random?
08:18:27 <merijn> tsaka_: That has several distributions including exponential builtin
08:18:54 <merijn> tsaka_: And in what way does it not execute?
08:22:02 <tsaka_> @merijn perhaps mwc-random is easier. The example gives me "The type variable ‘m0’ is ambiguous" for (RandomSource                           m (m0 (System.Random.MWC.Gen                                  (primitive-0.6.3.0:Control.Monad.Primitive.PrimState m0))))
08:22:02 <lambdabot> Unknown command, try @list
08:22:32 <merijn> oh, just add a type annotation
08:22:38 <merijn> using m = IO
08:23:03 <tsaka_> have tried that
08:23:06 <tsaka_> can you write it out?
08:23:40 <tsaka_> There's 2 m's in there
08:24:07 <tsaka_> annotating the result as RVar Double does not work either (or IO Double if its supposed to be that
08:25:51 <dyamon> in typeclassopedia there is an exercise for applicative functors that says "(Tricky) One might imagine a variant of the interchange law that says something about applying a pure function to an effectful argument. Using the above laws, prove that"
08:26:02 <dyamon> pure f <*> x = pure (flip ($)) <*> x <*> pure
08:26:18 <dyamon> can you give me some hint on how to start?
08:27:33 <dataN> :t flip ($)
08:27:34 <lambdabot> a -> (a -> c) -> c
08:28:19 <dataN> :t pure (flip ($))
08:28:20 <lambdabot> Applicative f => f (a -> (a -> c) -> c)
08:28:29 <dataN> e.t.c.
08:35:01 <tsaka_> Is there a way to use MWC-random in a functional way? Ala "(randomNumber, nextState) = sample state"
08:38:01 <lyxia> that seems unlikely
08:39:19 <Fare> flipping haskellers!
08:40:57 <dyamon> dataN: yes but the fact is that I need to use applicative laws to solve the equation. type-wise it seems pretty obvious
08:42:47 <dyamon> Ill think about it a bit more and Ill come back! Bye!
08:48:21 <tsaka_> lyxia: What's the preferred way of dealing with random numbers then? Annotating all functions which use (derivatives of) random numbers with IO is no good
08:48:54 <tsaka_> Because it is not immediatly obvious what kind of IO that is used
08:49:23 <tsaka_> If you have a "State StdGen" then it is immediately clear
08:49:55 <geekosaur> if you mean MWC-random, it's doing evil "global" tricks
08:50:11 * geekosaur has been using it. it's conveient but a bit scary, haskell-wise
08:50:19 <tsaka_> yes, MWC-random
08:51:47 <lyxia> tsaka_: one alternative is rvar/random-fu
08:51:52 <geekosaur> I was a bit startled when I discovered that I didn't need to update the Gen I was carrying around in my program's state
09:00:47 <kuribas> geekosaur: can't you use unsafeInterleaveIO to make it pure? :-)))
09:01:23 <geekosaur> kuribas, other way around, it was doing things in the Gen IO without my telling it to
09:01:47 <tsaka_> lyxia: With randomfu, how to use sampleState to sample numbers functionally?
09:01:47 <kuribas> ah :)
09:01:53 <tsaka_> It can't figure out types: http://rextester.com/live/SVMUT9636
09:40:11 <mitchellsalad__> hello folks, anybody know a nice way of keeping extended example code written in haddock comments compiling & working?
09:40:28 <glguy> doctest
09:44:09 <mitchellsalad__> ah, does doctest work with examples detached from functions? (I'm thinking of dedicated example comments at the top/bottom of a module)
09:44:15 <glguy> yeah
09:44:44 <gobby> I'm trying to use the list monad inside of IO (i.e items <- MyListOfItems) is this allowed?
09:44:53 <mitchellsalad__> Nice. And does it allow me to just have a block of code with no explicit return value to check against?
09:45:20 <mitchellsalad__> i.e. to type-check only
09:45:22 <glguy> Yeah, it's all in the docs (which aren't too long)
09:45:58 <gobby> GHC is complaining that it expects IO [items] and that I've given it [items]
09:46:42 <geekosaur> gobby, not allowed in that fashion
09:46:44 <glguy> gobby: No, you can't mix different Monad instances directly like that
09:46:50 <geekosaur> :t (>>)
09:46:51 <lambdabot> Monad m => m a -> m b -> m b
09:46:53 <glguy> There's nothing to speicfy what it would mean
09:47:04 <geekosaur> same m throughout, you don't get to decide one should be []
09:47:13 <geekosaur> if other things fix it as IO
09:47:25 <gobby> fair enough, I guess the best option would be to abstract that part of my code into a different function
09:48:49 <cocreature> gobby: there are ways of getting something like that, e.g., using the ListT transformer from pipes https://hackage.haskell.org/package/pipes-4.3.9/docs/Pipes.html#t:ListT
09:49:04 <cocreature> (transformers also has a transformer of that name but you probably want to avoid it)
09:53:58 <mitchellsalad__> glguy: thanks :)
10:08:04 <gobby> cocreature: I think I'll just abstract it into a separate function. Thanks though!
10:08:38 <dminuoso> Are there techniques to implement IO without tying effects into evaluation?
10:38:24 --- mode: glguy set +v das
10:39:21 <maerwald> dminuoso: how are effects tied to evaluation?
10:40:59 <dminuoso> maerwald: In GHC IO is just mimicry to enforce sequentiality. unsafeDupableInterleaveIO essentially just strips that away.
10:44:06 <maerwald> not sure how that makes effects tied to evaluation in general
10:44:37 <dminuoso> maerwald: In GHC it just simply is already ties into evaluation (the STG application code is what triggers effects).
10:48:26 <dminuoso> % :i IO 
10:48:26 <yahb> dminuoso: newtype IO a = GHC.Types.IO (State# RealWorld -> (# State# RealWorld, a #)) -- Defined in `GHC.Types'; instance Alternative IO -- Defined in `GHC.Base'; instance Applicative IO -- Defined in `GHC.Base'; instance Functor IO -- Defined in `GHC.Base'; instance Monad IO -- Defined in `GHC.Base'; instance MonadPlus IO -- Defined in `GHC.Base'; instance Monoid a => Monoid (IO a) -- Defined in `GHC.Base'; inst
10:49:58 <dminuoso> All you have to do to evaluate an IO action is to find a `State# RealWorld`, stuff it in there and then force the evaluation of whatever `a` is.
10:50:17 <dminuoso> It's what accursedUnutterablePerformIO does. 
10:51:30 <shapr> I love that name
10:51:47 <das> that is a great name
10:55:16 <das> It reminds me of "split" package description: https://hackage.haskell.org/package/split-0.2.3.3
10:55:32 <dminuoso> The reason for that name is because if you carelessly do this, the compiler will be quite happy to reorder things and maybe do some CSE.. which is quite hilarious if two `malloc 4096` get CSE'd into a single malloc.
10:58:33 <das> haha malloc elimination
10:59:45 <dminuoso> das: Yeah. Suddenly your two code regions are now sharing the same mutable buffer! Sharing is caring.
11:06:00 <mniip> You gotta share, you gotta care, and there'll always be a way through
11:06:48 <geekosaur> or, when "shared" isn't just an odd typo for "shred"
11:15:00 --- mode: glguy set +v DrOid
11:17:40 <pavonia> Is there a function to split a list into n chunks such that all chunks vary only in length by 1? I can't find something like that in the split package
11:18:44 <pavonia> e.g. split [1..10] 4 = [[1,2,3], [4,5,6], [7,8], [9,10]]
11:20:20 <koala_man> pavonia: do you need them to be contiguous rather than round-robin?
11:21:33 <pavonia> Yes
11:22:04 <pavonia> Or rather I'm not sure what round-robin means here
11:22:33 <MarcelineVQ> presuably  [1,4] [2,5] [3,6]
11:24:22 <pavonia> Like chunksOf but with the number of chunks given, not the length of each chunk
11:25:18 --- mode: glguy set +v das
11:26:30 <dyl> pavonia it looks like you'd want to compute the split positions and then use splitPlaces.
11:26:59 <dyl> This would be a lot easier for finite lists.
11:27:11 <dyl> Well, it's not really possible for non-finite lists.
11:27:47 <MarcelineVQ> it's more easily possible, since you can always get chunks of some minimal size with an infinite list
11:27:58 <pavonia> The lists are finite
11:28:00 <dyl> But here the chunk size is a function of the list length.
11:28:16 <dyl> i.e. above the length is 10, we want 4 chunks, so each chunk can only be of length 3 or 2.
11:28:16 <MarcelineVQ> I suppose yeah ehe
11:28:41 <dyl> It looks like we want to greedily take lists of the larger size (3) until doing so would make it impossible to finish the split without violating the chunk size condition.
11:28:56 <dyl> ie.. 3, 3, "now we have to pick 2 because otherwise the last chunk would only have 1.
11:29:15 <dyl> One approach would be to iterate along the list greedily, checking the divisibility of the remaining length.
11:30:40 <dyl> The chunk sizes are floor and ceil or length xs `div` n 
11:31:29 <dyl> This feels related to the change-making problem, though a bit easier.
11:33:28 <dyl> My intuition is that you want to look at the number of remaining elements (m), and look at the divisibility of m - chunk_size_low and m - chunk_size_high. 
11:33:55 <dyl> i.e. in the case above, once you've already made 2 groups of 3, you have 4 elements left. 4 - 3 = 1 is not divisible by 3 or 2, but 4 - 2 = 2 is.
11:34:30 <dyl> Oh wait, there's a much easier way, haha.
11:34:59 <pavonia> I think the number of longer lists is equal to length xs `mod` n
11:35:19 <dyl> You just need to solve for a linear combination of the low and high pavonia 
11:35:33 <dyl> c1 * low + c2 * high = length xs
11:35:55 <dyl> and, c1 + c2 = n
11:36:00 <dyl> That's a soluble system. 
11:37:49 <pavonia> Yeah, thanks
11:39:15 <dmwit> It's possible for infinite lists.
11:39:40 <dmwit> Get the shape with `transpose . chunksOf n`, then zip with the original list to get the elements.
11:40:16 --- mode: glguy set -v dasli
11:40:58 --- mode: glguy set +v Boarders
11:41:12 --- mode: glguy set -v Boarders
11:41:29 <pavonia> dmwit: How would you know where the second list starts for infinite lists?
11:41:51 <dmwit> The second list doesn't start, for infinite lists.
11:42:27 <dyl> pavonia fore the above system, letting L = length xs and N be chunk size 
11:42:36 <dyl> er, sorry
11:42:37 <dyl> for this system
11:42:42 <dyl> c1 * h + c2 * l = L, c1 + c2 = N
11:43:10 <Boarders> does anyone know how using ivory (https://ivorylang.org/index.html ) compares to using ffi with C in terms of performance?
11:43:10 <dyl> You get c1 = (L - low N) / (h - l) and c2 = (high N - L) / (h - l)
11:43:14 <dyl> Of course, h - l is always 1 :)
11:43:17 <dmwit> ?let nChunks n xs = let shape = transpose (chunksOf n xs); go [] _ = []; go ([]:ss) xs = []:go ss xs; go ((_:s):ss) (x:xs) = let res:ress = go (s:ss) xs in (x:res):ress in go shape xs
11:43:18 <lambdabot>  Defined.
11:43:19 <Boarders> if anything general can be said on that front?
11:43:24 <dmwit> > nChunks 4 [1..10]
11:43:27 <lambdabot>  [[1,2,3],[4,5,6],[7,8],[9,10]]
11:43:31 <dmwit> > nChunks 4 [1..]
11:43:34 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:43:40 <dmwit> pavonia: ^
11:43:54 <dyl> So in other words the number of large chunks is (length xs - (small chunk size) * num_chunks) 
11:44:11 <dyl> and the number of small chunks is (large chunk size * num_chunks - length xs)
11:44:52 <dmwit> > nChunks 4 (1:2:3:4:undefined)
11:44:54 <lambdabot>  [[1*Exception: Prelude.undefined
11:45:04 <dmwit> suitably lazy
11:46:29 <pavonia> dmwit: What are the parameters of go?
11:47:01 <dmwit> The "shape" of the result -- where cons cells and list endings should go (elements are ignored) -- and the "elements" of the result -- values to stick in the holes left behind by cons cells (shape is ignored).
11:49:08 <pavonia> Hhm, that's over my head :p
11:49:22 <dmwit> pavonia: Okay, here's another way to think of it.
11:49:41 <dmwit> pavonia: Suppose we're splitting `xs` into 4 chunks.
11:49:56 <dmwit> pavonia: As soon as we see 4 `:`s, we know that each resulting chunk should have at least one element.
11:50:07 <dmwit> pavonia: So we can emit the head of `xs` as the first element of the first chunk.
11:50:20 <dmwit> Four more :s and we can emit the second element.
11:50:32 <dmwit> Four more and we can emit the third.
11:50:44 <dmwit> As soon as we see a [], we can then emit the remaining elements as the remaining chunks.
11:51:21 <dmwit> So for the first chunk, what we'll do is repeatedly drop 4 elements until we reach the end of the input list.
11:51:38 <dmwit> But then that leaves us with an awkward question: how many of the remaining lists should be of that size, and how many of the one-smaller size
11:51:41 <dmwit> ?
11:52:33 <dyl> pavonia here I have a simple finite version for you.
11:52:38 <dmwit> We can answer that by looking at the size of the last group of up to four that we dropped. If it's 1, only the first chunk should have an extra element; 2 means the first two chunks; etc.
11:52:56 <dyl> https://gist.github.com/DylanLukes/cbb85d30524c2e32b1643d5fa42b48d9
11:53:00 <dmwit> But this logic is already implemented in `transpose`, so we take advantage of that.
11:53:10 <dyl> This is less magical and doesn't handle laziness, but should be pretty easy to follow.
11:54:00 <dyl> Might be easier actually to do hi = len `div` n + 1 
11:54:04 <dyl> and lo = len `div` n
11:54:12 <dmwit> pavonia: Or here's yet another way to understand it. We take a lazy Peano nat representing the length of the input length, and compute `divMod 4`. This gives us the length of each chunk as a lazy nat, together with the number of chunks that should have one extra element.
11:54:32 <dmwit> pavonia: Then we just use that information to take the right number of elements from the source list, repeatedly.
11:55:08 <dmwit> pavonia: The final observation being that if you ignore the actual `a` values, an `[a]` is essentially a lazy Peano nat, and `transpose . chunksOf n` is `divMod n`.
11:56:21 <pavonia> dmwit: Okay, I think I got the idea, thanks for the explanation
11:56:55 <dmwit> ?let useShape [] xs = []; useShape ([]:ss) xs = [] : useShape ss xs; useShape ((_:s):ss) (x:xs) = let res:ress = useShape ss xs in (x:res):ress
11:56:56 <lambdabot>  Defined.
11:57:18 <dyl> :i transpose
11:57:31 <dmwit> > useShape ["abcd", "e", "fghijklmnopqrstuvwxyz"] [1..26] -- this is `go` from before, might help you understand what it's doing
11:57:33 <lambdabot>  [[1,2,3*Exception: /tmp/mueval17707-0.hs:172:9-35: Irrefutable pattern faile...
11:57:40 <dmwit> uh...
11:58:23 <dmwit> ah
11:58:40 <dmwit> ?let useShape [] xs = []; useShape ([]:ss) xs = [] : useShape ss xs; useShape ((_:s):ss) (x:xs) = let res:ress = useShape (s:ss) xs in (x:res):ress
11:58:41 <lambdabot>  .L.hs:173:1: warning: [-Woverlapping-patterns]
11:58:41 <lambdabot>      Pattern match is redundant
11:58:41 <lambdabot>      In an equation for ‘useShape’: useShape [] xs = ...
11:58:44 <dmwit> ?undefine
11:58:45 <lambdabot> Undefined.
11:58:46 <dmwit> ?let useShape [] xs = []; useShape ([]:ss) xs = [] : useShape ss xs; useShape ((_:s):ss) (x:xs) = let res:ress = useShape (s:ss) xs in (x:res):ress
11:58:47 <lambdabot>  Defined.
11:58:55 <dmwit> > useShape ["abcd", "e", "fghijklmnopqrstuvwxyz"] [1..26]
11:58:55 <dyl> Meanwhile, my solution works for finite lists with minimal fuss and is easy to understand :p.
11:58:57 <lambdabot>  [[1,2,3,4],[5],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]]
11:59:04 <pavonia> dyl: Thanks to you too :)
11:59:28 <dyl> pavonia doing a little pen and paper math or informal proof before you start writing is a very helpful practice.
11:59:39 <dyl> Sketch out some cases and try to formalize before typing it out.
12:00:13 <dyl> My solution can actually be simplified further with some more math.
12:00:24 <dmwit> My solution also works for finite lists with minimal fuss.
12:00:29 <dmwit> ...and I find it easy to understand. =P
12:01:55 <dyl> I'm not sure I follow the point of the transposition to producethe shape myself.
12:03:07 <dyl> Are you doing it just to get the final shape, that is, you dont care about the values inside??
12:03:09 <dyl> ?*
12:03:09 <lambdabot> Maybe you meant: v @ ? .
12:03:35 <dmwit> dyl: correct
12:03:56 <dyl> This seems like it involves a lot of unnecessary ephemeral lists.
12:04:07 <dyl> And the contents of those lists are just useless stuff you'll never use.
12:04:14 <dmwit> Oh, sure, you can obfuscate it for better performance.
12:04:27 <dmwit> The contents are no cost at all. You already have those contents in `xs` anyway.
12:04:40 <dyl> This looks like an optimization opportunity for Data.Boring! 
12:04:49 <dyl> (joking)
12:05:40 <dyl> That said, I don't think the case for streams is actually very useful.
12:07:25 <dmwit> Me neither. I just objected to "it's not really possible for non-finite lists" on principle. =)
12:07:45 <dyl> And so the fundamental theorem of internet forums is exemplified again:
12:08:02 <dyl> the easiest way to get an answer to a question is to suggest an incorrect answer and wait for someone to correct you :D
12:08:47 <dyl> > transpose (chunksOf 4 [1..])
12:08:49 <lambdabot>  [[1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
12:09:28 <dyl> I see now.
12:09:34 <dmwit> > map (take 3) $ transpose (chunksOf 4 [1..])
12:09:40 <lambdabot>  mueval-core: Time limit exceeded
12:09:54 <dmwit> uh
12:10:09 <dmwit> Oh.
12:10:16 <dmwit> > take 4 $ map (take 3) $ transpose (chunksOf 4 [1..])
12:10:18 <lambdabot>  [[1,5,9],[2,6,10],[3,7,11],[4,8,12]]
12:10:42 <dmwit> Interesting. Might be worth tacking that trick onto the `nChunks` implementation.
12:11:11 <dyl> Hm?
12:11:43 <dmwit> transpose doesn't know that all the elements in its argument have length at most 4, so it doesn't know to produce a [] after it produces 4 chunks.
12:12:08 <dyl> Ahh
12:12:51 <dyl> > take 4 $ map (take 3) $ transpose (chunksOf 4 (iterate id (fix error))
12:12:53 <lambdabot>  <hint>:1:71: error:
12:12:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:12:55 <dyl> > take 4 $ map (take 3) $ transpose (chunksOf 4 (iterate id (fix error)))
12:12:58 <lambdabot>  [["*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *...
12:13:52 <dmwit> https://lpaste.net/4753856806088867840
12:13:54 <dyl> > take 4 $ map (take 3) $ transpose (chunksOf 4 (fix error))
12:13:56 <lambdabot>  *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exc...
12:46:45 <bananagram> is a tuple with three values called a threeple?
12:47:26 <tommd> Still a tuple.  You can say a "3-tuple".
12:47:54 <tommd> But I think GHC is setup to format your current partition if you define a type alias of "Threeple".
12:48:57 <bananagram> dang
12:49:14 <dstolfa> if we have constructors for inductive types, do coinductive types have coconstructors, or nstructors if you will? :-)
12:51:36 <rntz> in all seriousness, coconstructors are record fields
12:54:08 <geekosaur> re threeples, only if you also have a Twople :p
12:54:42 <tsaka__> Any assistance on correcting this type signature? https://paste.ofcode.org/37hHSb5DPHGdHJ5fTQbAytR
13:03:14 <Boarders> coconstructor = destructor
13:03:59 <Boarders> constructor is an inference rule in order to make a value and coconstructor is an inference rule for how to use a value
13:11:41 <absence> can "sum . foldMap f" be written in a "better" way? i can think of "alaf Sum foldMap f", but it's arguably not better, heh
13:18:18 <shapr> @pl \f -> sum . foldMap f
13:18:19 <lambdabot> (sum .) . foldMap
13:20:51 <Ariakenom> shapr: what were you saying in .se?
13:21:18 <shapr> just wondering how your question turned out...
13:22:42 <Ariakenom> 1 response: nah
13:23:16 <Ariakenom> as expected
13:49:04 --- mode: glguy set +v renard-chase
13:50:59 <renard-chase> Can someone explain to me how the `on` operator works?
13:53:18 <crestfallen> Is the following a matter of precedence ? ..  :
13:53:38 <crestfallen> > foo = (<$>) (+9) (* 10) 66
13:53:40 <lambdabot>  <hint>:1:5: error:
13:53:40 <lambdabot>      parse error on input ‘=’
13:53:40 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:53:53 <crestfallen> @let foo = (<$>) (+9) (* 10) 66
13:53:54 <lambdabot>  Defined.
13:53:57 <crestfallen> foo
13:54:45 <Boarders> when I run with profiling what does: *** Exception (reporting due to +RTS -xc): (IND_STATIC), stack trace:    Data.Text.Internal.IO.readTextDevice, mean?
13:54:54 <crestfallen> @let fool = (+9) <$> (* 10) 66
13:54:55 <lambdabot>  Defined.
13:54:57 <monochrom> renard-chase: The source code may help a lot.
13:55:19 <renard-chase> monochrom: I saw it, but it doesn't really make sense to me
13:55:56 <monochrom> OK, does the doc have examples?
13:56:07 <crestfallen> > fool
13:56:09 <lambdabot>  error:
13:56:09 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M520860617365...
13:56:09 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
13:56:21 <renard-chase> monchrom: No
13:57:01 <renard-chase> I assume you mean the actual documents (and not the source)
13:57:36 <monochrom> Yes.
13:58:16 <monochrom> So maybe you just need an example.
13:59:33 <renard-chase> The source does have some examples and I 'kind of' get it, but I'd kind of like something a bit more clear so I can have a solid grasp on what its actually doing
14:00:51 <monochrom> Suppose I have a function "bigger :: Int -> Int -> Bool".  But then I say "ah but I want to use it on Char parameters rather than Int parameters".
14:01:37 <monochrom> And then you say "but Char is not Int" and I say "ah but I already have a converter from Char to Int, it's ord :: Char -> Int"
14:02:03 <monochrom> So I'll use "bigger `on` ord".
14:02:30 <monochrom> It converts bigger to accept Char parameters, using ord for the conversion.
14:12:02 <crestfallen> sorry I resolved that
14:22:23 <ChaiTRex> :t on
14:22:24 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:33:09 <Solonarv> @pf \ f k x y -> f (k x) (k y)
14:33:10 <lambdabot> Maybe you meant: pl bf
14:33:29 <Solonarv> @pl \ f k x y -> f (k x) (k y)
14:33:29 <lambdabot> join . ((flip . ((.) .)) .) . (.)
14:35:18 <orzo> Where is the Alternative (Either String) instance located?  I moved some code and I've no idea which of the many imports I need to also transplant
14:35:54 <glguy> http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Error.html#v:-36-fAlternativeEither
14:36:57 <orzo> i didn't directly import that
14:37:11 <glguy> That's the magic of instances
14:37:57 <orzo> im not sure if i indirectly imported it either.  It says deprecated, are you sure the instance isnt anywhere else?
14:45:53 <orzo> I'm just editting out Alternative
14:45:56 <orzo> heh
15:52:26 <la_mettrie> which book would you recommend for studying haskell? ...preferably one that is available in a paper form
15:56:29 <dmj`> la_mettrie: I’d print out the typeclassopedia, and the papers it links to
15:56:50 <dmj`> then descend into type level fantasy 
16:02:21 <greymalkin> Is there a way to have Arbitrary.generate selecting increasing values for a field over the course of a single call to `generate` ?
16:03:02 <hpc> that sounds more like Specific.generate
16:03:03 <hpc> ;)
16:03:29 <greymalkin> I'm trying to generate timestamps on fictitious incoming data, but it is guaranteed to be increasing, but using `growingElements` is selecting the same timestamp for each one.
16:04:58 <greymalkin> Nevermind, I'll just make a function `generateIncreasing` for this one type of data.
16:33:30 <ddellacosta> hmm looking at this: https://docs.google.com/spreadsheets/d/14MJEjiMVulTVzSU4Bg4cCYZVfkbgANCRlrOiRneNRv8/edit#gid=0
16:33:41 <ddellacosta> there is a column with the heading "Can rows be created during run-time that haven't been specified at compile time?"
16:34:17 <ddellacosta> and only Data.Map seems to allow this, but that doesn't make much sense to me
16:34:41 <ddellacosta> should this maybe say "new row _types_?"
16:35:33 <ddellacosta> I'm not even sure where is appropriate to bring this up
16:36:06 <hpc> if you're doing programming languages properly, everything that happens at runtime is at the value level
16:36:21 <glguy> ddellacosta: It's probably saying that Data.Map is one of the only ones where you can read a field name out of a file and start using that
16:37:03 <ddellacosta> huh, I thought you could do even that with e.g. labels
16:37:19 <ddellacosta> https://github.com/chrisdone/labels#readme
16:38:10 <glguy> And what would it look like in labels to do that?
16:38:44 <glguy> Just write an example that reads a new fieldname with getLine and a new String value with getLine and stores that in one of the records this package provides
16:40:41 <ddellacosta> (not ignoring you glguy, just poking around to see if I can actually put my money where my mouth is...)
16:41:05 <glguy> Don't worry; I'm not in any hurry. The answer is for you :)
16:41:23 <ddellacosta> glguy: I'm guessing you already know the answer is no for most every library on the list, haha
16:41:35 <ddellacosta> yeah I guess it's the field labels that had me
16:42:05 <ddellacosta> but still, even if it's saying what you suggested, should it not still be "row type" vs. "row?" Assuming we're talking about a row value
16:42:23 <glguy> The type isn't changing with you insert into a Map
16:42:31 <glguy> :t M.insert
16:42:33 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
16:42:50 <ddellacosta> oh right--I'm saying the same thing, like you can do that with a Map but everything else it requires redefining the type
16:43:01 <ddellacosta> but creating a new _row_ at runtime isn't the issue
16:43:11 <glguy> If your encoding of records puts the fields in the type, then of course you'd need to change the type to add new fields
16:43:38 <glguy> But Map doesn't put the field names in its type, so it's fine to add more fields dynamically
16:43:42 <ddellacosta> yeah, I guess that's what I'm saying, I'm not sure what "row" means in the sentence "Can rows be created during run-time that haven't been specified at compile time?"
16:44:08 <ddellacosta> sorry this is quibbling, I was just confused by that, but your explanation makes sense glguy
16:44:31 <glguy> Well, it's under the "Fields" heading; I'm not weighing in on if the actual wording used in the file makes sense
16:45:09 <ddellacosta> oh, I see, somehow I missed that bit. I guess that makes...more sense then
16:45:18 <ddellacosta> anyways, thanks for humoring me glguy
16:47:40 <ddellacosta> assuming the meaning you stated, I guess I'd find something like "new row values with previously unspecified field names can be specified at run-time"
16:47:44 <ddellacosta> more clear
16:48:01 <ddellacosta> specified -> crewated
16:48:06 <ddellacosta> *created
18:23:19 <koz_> cocreature: You asked, I deliver: https://www.twitch.tv/videos/313060971
18:57:38 <c_wraith> oh hey. ghc-heap-view comes with ghc 8.6.  nice.
19:51:43 <clever> how would i list all modules that a given module depends on, recursively
19:53:52 <c_wraith> ideally, you'd find a library that already does that.  It can be rather tough without source though - a module can inline definitions from another module and never have a reference to it in the compiled .o file
19:54:09 <c_wraith> Would you be satisfied with it only working with modules you have the source for?
19:54:32 <koz_> c_wraith: Does GHC provide that capability somehow?
19:55:06 <c_wraith> probably.  there's the flag to tell it to print imports
20:54:42 <vimto> has anyone used safe-money before? Cause I can't use any of the types without getting an error.
20:55:08 <glguy> vimto: Just ask about the actual error and if someone can help they will
20:55:22 <glguy> You probably don't need someone who has used the library before
20:57:18 <vimto> glguy: If I have a oneline error should I still put it into a gist?
20:57:47 <glguy> You shouldn't prune the error down yourself, you should put the whole error in a gist
20:58:03 <glguy> preferable with some code that generates it
20:58:09 <vimto> cool cool, thanks
20:59:01 <vimto> so whenever I try to create any of the given types in safe money I get this error https://gist.github.com/Abdiramen/e64373efcb2a108e4e485d59991ff9fc
20:59:19 <glguy> Turn on DataKinds
20:59:28 <glguy> {-# Language DataKinds #-}
21:03:20 <vimto> Thanks, you solved my problem <3
22:14:55 <jle`> woo hoo ghc 8.6
22:40:23 <dmj`> jle`: \o/
22:51:54 <monochrom> This compiles everything again.
23:31:03 <cocreature> koz_: beautiful! the fact that I’ve completely forgotten how we got to this point makes it even funnier :)
23:31:24 <koz_> cocreature: It was to do with me writing helper functions with singletons.
23:31:42 <koz_> Which involved definitions like: 'foo x = go sing'.
23:32:56 <cocreature> ah right
23:36:44 <koz_> cocreature: But it was surprisingly fun.
23:36:50 <koz_> (the Firejail issues right after weren't)
23:36:54 <koz_> (but then again, ehh)
23:38:15 <cocreature> koz_: you should just stop the gaming and only sing on your channel. then you don’t need to deal with firejail!
23:38:30 <koz_> cocreature: That's a hilarious idea.
23:38:57 <MarcelineVQ> You boys are completely mental.
23:39:09 <MarcelineVQ> Absolute nutters
23:39:16 <koz_> MarcelineVQ: This was under doubt since when?
23:39:23 <koz_> (for me, at least)
23:39:35 <MarcelineVQ> Imagine a walnut large enough to hide yourself in. That's you
23:40:06 <koz_> MarcelineVQ: Lol, that's a very large walnut.
23:40:16 <monochrom> Wait, that sounds like some kind of Russell paradox.
23:40:26 <koz_> monochrom: How so?
23:40:41 <MarcelineVQ> You were the walnut all along. And the real paradox was the friends we made along the way.
23:41:17 <monochrom> walnut = you ∈ walnut
23:41:43 <koz_> 'large enough to hide yourself in' is a statement about the size of the walnut, not its contents.
23:42:36 <cocreature> koz_: you missed the “that’s you” part
23:43:30 <koz_> cocreature: Yeah, but the way I parse that statement is that 'You are a walnut with a given size, which happens to be based on you as well'.
23:43:41 <koz_> The size of the walnut being based on me isn't an inclusion statement AFAICT.
23:44:03 <cocreature> koz_: right but the size is based on you fitting inside the walnut but then you’re the wallnut itself which doesn’t fit into itself
23:44:33 <koz_> Well, I guess it depends how you define 'fit'. Such a walnut would occupy the same amount of space as itself, right?
23:44:53 <koz_> But yeah, fair enough, it does kinda sound like a (very nut-oriented) Russel's Paradox-style statement.
23:45:18 <monochrom> We don't normally say "monochrom hides in monochrom" because, even just discussing sizes, if X can hide in Y then size(X) < size(Y), at least by convention.
23:46:00 <koz_> monochrom: OK, then you got me.
23:46:13 <cocreature> most walnuts that I have seen have a husk of non-zero thickness
23:48:21 <koz_> This is why I love this channel.
23:48:44 <pie_> i have no idea whats going on https://www.youtube.com/watch?v=nfdEdE96En0
23:50:05 <koz_> pie_: What the actual hell did I just (partially) watch?
23:51:12 <monochrom> I think you've got to read the description below first.
23:51:44 <pie_> monochrom, naahhhhh
23:52:18 <koz_> monochrom: Yeah, that makes more sense now.
23:53:00 <monochrom> This is why reading texts is still a better method for learning than watching videos.
23:53:12 <koz_> monochrom: Agreed 100%.
23:53:17 <koz_> (unless it's an Edward Kmett talk)
23:53:21 <koz_> (those are excellent)
23:53:33 <monochrom> And both are still better than high-frequency chatting.
23:54:03 <pie_> (i am now listening to this video while playing psychedelic music)
23:57:15 <maerwald> "a better method for learning" is so generic in terms of context, material and type of learner, that it's almost always wrong
