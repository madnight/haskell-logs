00:02:08 <dminuoso> johnw: Okay so essentially if the type variable was named `a`, then @(_a -> _a) means [a:=(_a -> _a)] without starting what exactly _a is?
00:02:24 <johnw> right
00:02:50 <johnw> it's using yet another new feature
00:02:53 <johnw> PartialTypeSignatures
00:02:59 <johnw> to avoid providing the types
00:03:20 <johnw> the actual types used (I believe they are still just type variables) are inferred from context
00:03:41 <pavonia> Ah, it refers to the first type variable of the forall?
00:03:55 <dminuoso> pavonia: Yes.
00:03:58 <johnw> _a is just naming the hole
00:04:03 <johnw> it could have been (_ -> _)
00:04:09 <pavonia> I see, thanks
00:04:28 <pavonia> Can you do that with two variables, too?
00:04:33 <dminuoso> pavonia: Yes.
00:04:48 <dminuoso> f @Int @Bool
00:05:06 <johnw> and if you only want to provide the second, you say: f @_ @Bool
00:06:06 <pavonia> Interesting, never heard of that extension before
00:06:27 <dminuoso> pavonia: Furthermore, if no forall are explicitly mentioned, then the foralls are in lexical order of type variables appearing. So `(Num b) => a -> b -> a` implies `∀b a. (Num b) => a -> b -> a`
00:06:31 <jle`> it's pretty useful for teaching
00:06:38 <jle`>  :t fmap @Maybe
00:06:45 <jle`>    :: (a -> b) -> Maybe a -> Maybe b
00:06:59 <jle`>  :t fold @[] @String
00:07:01 <dminuoso> jle`: I guess one could say: map = fmap @[]
00:07:12 <jle`>     :: [String] -> String
00:07:28 <jle`> it's not turned on in lambdabot though for some reason
00:08:16 <jle`> it's often more convenient than using type annotations
00:08:17 <boj> wow, that example helped make it click here jle`, thanks
00:08:25 <jle`> np
00:08:34 <metahumor> :t fmap `asAppliedTo` (pure () :: Maybe ())
00:08:35 <lambdabot> error:
00:08:35 <lambdabot>     • Couldn't match expected type ‘a -> b’ with actual type ‘Maybe ()’
00:08:35 <lambdabot>     • In the second argument of ‘asAppliedTo’, namely
00:08:55 <metahumor> % :t fmap @Maybe
00:08:55 <yahb> metahumor: (a -> b) -> Maybe a -> Maybe b
00:08:57 <dminuoso> jle`: I think I may start using it. I've become quite annoyed by having to specify long and complicated type signatures when my only intend was just specifying a single "a"
00:09:05 <metahumor> yahb has TypeApplications
00:09:07 <jle`> yeah i use it lots
00:09:09 <dminuoso> Are there negative consequences to this extension?
00:09:16 <jle`> in some situations it's actually required to use some functions
00:09:27 <jle`> people started writing functions requiring it once it got added to ghc
00:09:40 <metahumor> some think you should just break your functions up further where you shouldn't need it, as in, inference will work properly
00:09:41 <dminuoso> jle`: Im guessing things involving type families?
00:09:42 <jle`> dminuoso: well, one weird thing is that forall type re-ording becomes a breaking change
00:09:51 <dminuoso> Ahh
00:09:51 <jle`> dminuoso: no, just normal simple typeclasses
00:09:58 <metahumor> however, as jle` says, there are some functions which will require it. it also makes working with Proxy much easier
00:10:43 <metahumor> i've found it very useful in getting rid of certain type warnings when dealing with "fromIntegral" likes
00:10:58 <piark_> hello
00:11:00 <jle`> one annoying thing is that it doesn't work with literals atm (2 @Int)
00:11:07 <dminuoso> jle`: I suppose this is mainly the case when you dont specify forall, and start adding constraints.
00:11:14 <dminuoso> Then it's quite easy to change the order of type variables
00:11:32 <jle`> yeah but even re-ording your foralls will be a breaking API change which is kinda annoying
00:11:35 <jle`> piark_: hi!
00:11:41 <jle`> dminuoso: but yeah a simple example of a function that requires it would be like
00:11:47 <jle`> class ShowType a where
00:11:51 <jle`>   showType :: String
00:12:06 <dminuoso> Ohh.
00:12:07 <jle`> hm i wonder if i can yahb it
00:12:17 <jle`> % class ShowType a where showType :: String
00:12:26 <yahb> jle`: ; <interactive>:53:24: error:; * Could not deduce (ShowType a0); from the context: ShowType a; bound by the type signature for:; showType :: forall k (a :: k). ShowType a => String; at <interactive>:53:24-41; The type variable `a0' is ambiguous; * In the ambiguity check for `showType'; To defer the ambiguity check to use sites, enable AllowAmbigu
00:12:28 <sdrodge> That's a big split we just got there.
00:12:39 <jle`> % :set -XAllowAmbiguousTypes
00:12:39 <yahb> jle`:
00:12:41 <jle`> % class ShowType a where showType :: String
00:12:42 <yahb> jle`:
00:12:42 <dminuoso> jle`: That's pretty cool. Then you can simply say: showType @Float
00:12:45 <dminuoso> Without having to find an object
00:12:51 <jle`> % instance ShowType Int where showType = "Int"
00:12:52 <yahb> jle`:
00:13:00 <jle`> % instance ShowType Float where showType = "Float"
00:13:00 <yahb> jle`:
00:13:04 <jle`> % showType @Int
00:13:04 <yahb> jle`: "Int"
00:13:07 <jle`> % showType @Float
00:13:07 <yahb> jle`: "Float"
00:13:11 <johnw> or how about Storable's sizeOf
00:13:16 <jle`> ^ that wouldn't be possible with only type annotations
00:13:22 <johnw> I'd much rather say sizeOf @CInt than sizeOf (undefined :: CInt)
00:13:25 <pavonia> % :t showType
00:13:25 <yahb> pavonia: ; <interactive>:1:1: error:; Ambiguous type variable `a0' arising from a use of `showType'; prevents the constraint `(ShowType a0)' from being solved.; Probable fix: use a type annotation to specify what `k0', `a0' should be.; These potential instances exist:; instance [safe] ShowType Float -- Defined at <interactive>:57:10; instance [safe] ShowType Int -- Defined at <interact
00:13:28 <dminuoso> jle`: Though in this case, it does not seem advantageous over `showType :: Float`
00:13:33 <dminuoso> I mean its about the same characters typed
00:13:35 <jle`> dminuoso: that doesn't work
00:13:38 <jle`> showType :: String
00:13:40 <jle`> not Float
00:13:49 <dminuoso> jle`: Ohh.
00:13:53 <dminuoso> jle`: Yeah gotcha
00:13:59 <jle`> there isn't anywhere you can put a type annotation that will make it work
00:14:12 <dminuoso> jle`: So I guess `finiteBitSize` in Data.Word would be a candidate for this.
00:14:47 <jle`> yes that's a good example
00:15:11 <jle`> but the FiniteBits class was written before TypeApplications, so if it wasn't for some argument using 'b', it wouldn't be possible
00:15:27 <jle`> actually before TypeApplications we had a trick people started using
00:15:34 <jle`> finiteBitSize :: p b -> Int
00:15:45 <jle`> that way you wouldn't have to supply an actual 'b' if you didn't have one
00:16:07 <jle`> you could do, say, ([] :: [Word8]), so ghc would know b is Word8
00:16:38 <jle`> this trick wasn't popularized until after the FiniteBits class was written, apparently
00:17:21 <jle`> typeOf has this same problem in Data.Typeable
00:17:53 <jle`> but in base 4.7 they added the trendier typeRep :: p a -> TypeRep
00:18:19 <jle`> (trendier at the time, of course)
00:19:13 <jle`> but that's all absolute now that literal singletons for *-kinded types is in base
00:19:18 <jle`> s/absolute/obsolete
00:21:10 <sdrodge> jle`: There was someone in here the other day asking how best to fmap (*2) on their mutable vector. Myself and others told them to unsafeFreeze, map, then unsafeThaw. Did we lead them astray or do you agree?
00:21:25 <dminuoso> jle`: Ah I see. So tht ([] :: [Word8]) kind of looks like the Proxy pattern
00:21:53 <jle`> yeah you could do (Proxy :: Proxy Word8) too, it's just a little more verbose heh
00:22:23 <dminuoso> jle`: I see. So _this_ is what the Proxy pattern is about? Type application in absence of TypeApplications?
00:22:32 <dminuoso> :o
00:22:49 <jle`> yeah, we used to use Proxy's before type applications for a lot of things
00:23:25 <jle`> Proxy is useful to give to 'p a -> ...' functions, since it might be a bit more 'semantic'/readable than []
00:23:40 <jle`> also it's poly-kinded, so you can have (Proxy :: Proxy Monad), but not ([] :: [Monad])
00:24:00 <dminuoso> :k Proxy
00:24:02 <lambdabot> k -> *
00:24:11 <dminuoso> Cool. :)
00:24:19 <johnw> proxy doesn't even really need Proxy
00:27:03 <johnw> if your function takes 'proxy a' as an argument, you can pass in 'undefined :: proxy MyType', as an alternative to it taking 'Proxy a', and you passing 'Proxy :: Proxy MyType'
00:27:18 <johnw> though I do prefer the latter
00:27:43 <johnw> however, some libraries in base, like GHC.TypeLits, use the former pattern
00:28:43 <metahumor> has anyone done the data61 course here? in ListZipper, the examples give that (show' (traverse id IsNotZ) === "><")
00:28:57 <metahumor> but it would seem to me that it should be "Full ><"
00:29:21 <metahumor> since "traverse id (Nothing :: Maybe [Integer]) === [Nothing]"
00:29:24 <metahumor> > traverse id (Nothing :: Maybe [Int])
00:29:26 <lambdabot>  [Nothing]
00:29:45 <metahumor> eh, let me rephrase
00:29:50 <dminuoso> johnw: what does `undefined :: proxy MyTeam` mean? What is proxy in this?
00:29:59 <johnw> traversed id = sequenceA
00:30:20 <johnw> dminuoso: proxy isn't anything at all, just a type variable of kind * -> * acting as a carrier for the type you intend to convey
00:30:29 <dminuoso> johnw: Ahh right.
00:30:35 <johnw> you never need to provide it, since it's never used
00:30:53 <jle`> i use (Proxy @Monad) etc. now
00:31:00 <johnw> yeah, that's better
00:31:10 <johnw> I use type applications most with the freer-simple library
00:31:13 <johnw> there, they're indispensible
00:31:20 <johnw> send @IO $ do ...
00:31:25 <jle`> even though it's probably better to do the type application at the actual function itself, since it saves parentheses
00:31:27 <dminuoso> jle`: when you mentioned literal singeltons for *-kinded types, what was that about?
00:31:39 <jle`> Type.Reflection has singletons for types
00:31:49 <jle`> it actually has singletons for types of multiple kinds
00:31:55 <jle`> not just *, which is kinda crazy
00:32:11 <jle`> they're not as useful as the singletons from the singleton package though since you can't directly pattern match on them
00:33:14 * dminuoso seems to see SPJ and SW in every second type related core library or paper..
00:33:39 <jle`> simon warlow, simon marlow's evil dimension twin?
00:33:44 <dminuoso> Heh
00:33:52 <johnw> simon warlom
00:34:31 <jle`> dminuoso: yeah so the modern trendy way to use Typeable is not actually Data.Typeable, but Type.Reflection
00:35:11 <jle`> dminuoso: Type.Reflection's TypeRep includes the type itself in the type of the TypeRep
00:35:19 <jle`> so `TypeRep Int` is a TypeRep for Int
00:35:40 <jle`> instead of just Data.Typeable's boring 'TypeRep' (*-kinded) type rep
00:36:24 <jle`> singletons in my base :)
00:37:13 <dminuoso> jle`: Alright, I think this went outside my comfort zone. But this was very enlightening. All of this seems far less complicated, a while ago I feared that the depths of Haskell were unreachable.
00:38:16 <guest_> how to convert `CryptoFailable SecretKey` to `SecretKey`, i was trying this http://lpaste.net/362820 code in ghci
00:39:25 <dminuoso> guest_: Looks like you just pattern match
00:40:42 <dminuoso> guest_: Its no different from say Either
00:41:06 <dminuoso> guest_: Or you can use its Monad/Applicative interface
00:41:22 <dminuoso> Or Functor evenb
00:50:16 <batman_> what does this mean {-# LANGUAGE DeriveGeneric #-}
00:51:33 <vaibhavsagar> batman_: it allows you to put `deriving (Generic)` at the end of a datatype declaration
00:53:00 <vaibhavsagar> and Generic is a way to represent a data type in a generic way, with units, constants, sum, and product types
00:53:06 <vaibhavsagar> https://wiki.haskell.org/GHC.Generics
00:53:27 <batman_> vaibhavsagar : okay thank you
01:00:30 <guessWho> i have a function which returns Just (Person) where person is a custom type how can i extract Person from it
01:00:44 <cocreature> guessWho: pattern match on it
01:07:09 <AWizzArd> shapr: no, not porting. But coding in a dyn lang in day job.
01:13:57 <guessWho> cocreature : are Data.ByteString.Lazy.Internal.ByteString & Data.ByteString.Char & Data.ByteString same if a NEtwork.Socket.ByteString function accepts a type ByteString >?
01:14:52 <cocreature> guessWho: no, Data.ByteString.Char8 and Data.ByteString reexport the same strict ByteString type. Data.ByteString.Lazy exports a different lazy ByteString type
01:15:47 <cocreature> Network.Socket.ByteString operates on strict ByteStrings iirc
01:15:52 <guessWho> cocreature : how do i convert Data.ByteString.Lazy.Internal.ByteString to Data.ByteString
01:16:42 <cocreature> guessWho: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Lazy.html#v:toStrict
01:16:45 <guessWho> cocreature : so how do i make Data.ByteString.Lazy.Internal.ByteString work with Network.Socket.ByteString
01:17:14 <cocreature> I just told you?
01:17:18 <cocreature> use toStrict
01:17:28 <guessWho> cocreature : yeah i got it thanks
01:20:54 <guest_> \quit
01:29:07 <dminuoso> guessWho: Or you can use the Functor/Applicative/Monad interface.
01:32:40 <Bish> would it be bad design if someone wrote an application with haskell & let all database communication happen over database functions (pgpqsql)?
01:32:45 <Bish> it would be all function!
01:33:02 <Bish> functioning!
01:33:14 <dminuoso> Bish: plpgsql is still server side
01:33:36 <Bish> so?
01:34:39 <Bish> assuming they're on the same server, load-wise it wouldn't make a difference..except haskell is a bit faster? i don't know?
01:35:03 <Bish> i worked at siemens once in my life, and they did it that way (but not haskell)
01:35:04 <dminuoso> Bish: I dont think a question that general can be sensibly answer. Whether plpgsql is a good fit depends on your case.
01:35:25 <Bish> was an interesting choice, but i googled it that time and it was mostly considered an antipattenr
01:35:31 <dminuoso> But since you qualified it with "all", I'd say its a good bet that it's bad.
01:35:32 <Bish> but i loved working with it
01:36:40 <Bish> if you fly with lufthansa your packages will be handled that way, i guess
01:37:13 <dminuoso> Bish: Just because large non-tech oriented companies happen to do something a particular way, doesn't make it a good choice.
01:37:27 <Bish> didn't make that assumption!
01:37:51 <Bish> and siemens is non-tech?
01:39:12 <dminuoso> Siemens is good at building electrical parts. I wouldn't put them at the top of my list for "setting good examples"
01:39:20 <Bish> okay.. it wasn't really siemens
01:39:25 <Bish> it was a sub-company of them
01:39:31 <Bish> with a "it technologies" suffix
01:42:00 <dminuoso> Bish: To answer your original question better: _why_ do you pick plpgsql?
01:42:15 <dminuoso> What benefits do you hope to gain?
01:42:44 <Bish> you wouldn't have to fuck with relational algebra in haskell
01:42:57 <tdammers> routing all database interactions through stored procedures is fairly common in enterprisey operations
01:43:16 <Bish> and get the database features of (insert rds here)
01:43:19 <tdammers> the approach makes some sense, even
01:43:43 <Bish> you would call the function like they were haskell functions, sounds like clean design
01:43:50 <Bish> but weird when it comes to load & stuff
01:43:54 <tdammers> in that the database essentially becomes a service, and forcing all access through stored procedures effectively turns the SP's into an API
01:43:57 <dminuoso> Bish: There's just a flaw in your logic.
01:44:05 <tdammers> thus decoupling database schema from the "API"
01:44:13 <Bish> dminuoso: which is?
01:44:20 <dminuoso> Bish: The reason we have SQL, is because it happens to be an acceptable and good fit for describing relational algebra
01:44:38 <nullie> Plpqsql is pathetic
01:44:48 <Bish> dminuoso: yeah but you almost never transform relational algebra to a select
01:44:50 <Bish> you write it raw
01:44:52 <tdammers> this decoupling also aligns with organizational responsibilities (DBA vs. Operations vs. IT vs. Development)
01:44:54 <Bish> which i would never do
01:45:27 <Bish> tdammers: hows that? i mean DBA will certainly have more work
01:45:28 <tdammers> so for enterprises with lots of management layers and deep hierarchies, this is much easier to manage
01:46:03 <Bish> nullie: without arguments not worth anything
01:46:05 <tdammers> Bish: that's not a problem though, a large enterprise will just hire more DBA's; the important part is to decouple the development teams from the DBA's as much as possible
01:46:07 <dminuoso> Bish: SQL is a form of relational algebra.
01:46:13 <nullie> Bish: I know
01:46:29 <Bish> dminuoso: yeah but what does it give you, if you don't translate to it
01:46:35 <dminuoso> Bish: A simple example: SELECT * FROM A UNION SELECT * FROM B is equivalent to R U S
01:46:38 <dminuoso> *A U B
01:46:52 <dminuoso> Bish: It gives you a domain specific tool to describe how to obtain data
01:47:08 <Bish> and you can still use that
01:47:10 <Bish> in the functions
01:47:32 <dminuoso> Bish: What benefit do you gain from the sql statement residing in plpgsql instead of some function in Haskell?
01:47:33 <Bish> there is no difference if you have the sql commands stored in a string in haskell
01:47:40 <dminuoso> Bish: Specifically. What benefits?
01:47:47 <Bish> dminuoso: exactly that, no sql in strings
01:47:55 <Bish> (assuming you don't translate)
01:48:12 <dminuoso> Bish: Except you still have sql in strings. Stored in plpgsql.
01:48:16 <dminuoso> You have to write the queries either way.
01:48:29 <Bish> dminuoso: you sure those won't get compiled / optimized in some way?
01:48:46 <Bish> and i mean.. that language was designed to contain them.. so that's better?
01:49:05 <Bish> pgpsql is compiled afaik, as long as you don't use "EXECUTE" they won.t be strings
01:49:08 <Bish> might be wrong about that
01:49:25 <tdammers> the main thing you gain is decoupling
01:49:42 <Bish> tdammers: and code looks cleaner.. if you ask me, it still might be a stupid idea
01:50:08 <dminuoso> Bish: Write the sql parts in a separate file.
01:50:09 <tdammers> you can have a database team who know only postgres and pgpsql, and a dev team who know only haskell and enough sql to call SP's, and they will only have to share SP signatures, which can be managed progressively
01:50:14 <dminuoso> If tidiness is what you want.
01:50:20 <dminuoso> Bish: You seem to be wanting plpgsql for the wrong reasons.
01:50:52 <Bish> dminuoso: what would be reasons for plpgsql
01:50:54 <tdammers> the concerns are "big brush" ones; the nitty-gritty code is going to be less elegant, but the advantage is that is scales relatively well to large systems with lots of disjoint components
01:50:59 <dminuoso> Bish: tdammers is pointing them out to you.
01:51:22 <Bish> okay, thanks for the chat!
01:51:25 <Bish> as usual
01:51:29 <Bish> dminuoso: do you actually work, btw?
01:51:39 <tdammers> a more "modern" approach to systems design would be a service-oriented architecture
01:51:39 <dminuoso> Bish: This "code looks cleaner" is a wrong approach. If you dont want to see the SQL statement in the code that uses it, then write them in separate location/files/modules
01:52:18 <Bish> dminuoso: well one practical disadvantage would be that those selects would be send and received from the server
01:52:20 <tdammers> it's mostly the same, except that instead of exposing stored procedures and connecting clients to the DB server directly, you wrap the DB in a web service (or similar service technology), and have applications connect to *that*
01:52:23 <Bish> a function only returns the data
01:52:56 <Bish> tdammers: a project would need to be really big for that to payout
01:53:16 <tdammers> Bish: it's not so much about the code size as it is about the team size
01:53:48 <tdammers> development teams tend to not scale well beyond 2-3 programmers (plus some support roles)
01:54:03 <tdammers> so once you have to scale beyond that, you will have "sub-teams"
01:54:32 <merijn> tdammers++
01:54:55 <Bish> merijn: that's not very haskell-ish
01:54:58 <tdammers> if you're smart, you acknowledge this fact, embrace it, and put structures into place to make this explicit and support it
01:55:26 <tdammers> if you're not, it'll happen anyway, but you won't have a clear view of *how* it's happening, and it'll usually end up in disaster
01:55:29 <merijn> Lots of software engineering research is about "how do we make X scale to more developers?". My opinion is more: Scaling to more people is impossible, how can we decompose and empower developers so we don't need more to begin with
01:55:40 <merijn> Bish: lambdabot tracks karma :p
01:55:47 <tdammers> Bish: this has little, if anything, to do with Haskell, really; these systems design principles are the same regardless of programming languages involved
01:56:01 <Bish> i meant the x++ thing :>
01:56:05 <Bish> just a joke
01:56:06 <merijn> tdammers: I think his remark was a joke about ++
01:56:16 <tdammers> merijn: ah, right, yes, missed that :(
01:56:25 <Bish> yeah thanks for the chat
01:56:26 <Bish> !
01:56:55 <Bish> which PL/Haskell was a thing
01:56:58 <Bish> wish*
01:57:07 <tdammers> make it happen! patches welcome!
01:57:42 <Bish> i think there is a repo for that.. but the maintainer even died? if i recall correctly
01:58:58 <tdammers> I think the problem is that by now, the kind of people who use Haskell have moved to service-oriented architectures
01:59:37 <merijn> Bish: Dooooo it! For the rest of us! ;)
02:00:05 <merijn> Bish: GHC is already a library that you can embed, so...
02:02:18 <tdammers> .oO( compiling GHC on PSQL )
02:03:24 <merijn> I always advocate for people doing things I think are great ideas but I don't wanna do myself, so I can reap the benefit when I finally need it ;)
02:04:51 <Bish> merijn: i almost feel bad.. i wrote some stuff at work.. that might be super useful to people
02:05:05 <Bish> but i never submit them because they're no clean / require documentation / etc
02:05:10 <Bish> and i just don't have that time
02:07:09 <merijn> I'm personally more of a "dump potentially useful but undocumented code to the web anyway" kinda person
02:07:23 <boj> yeah, we never have time to contribute back. must be a manager problem...
02:07:32 <merijn> If it might be useful to someone, they can use it. If they want documentation "fuck you, pay me" :p
02:08:36 <kuribas> tdammers: you could create a service-oriented architecture in haskell
02:09:35 <Bish> i think he already said that most people might have done that
02:09:49 <Bish> boj: might be, i'd love to work for OS only but none is giving me money for that
02:09:53 <Bish> and i gotta eat :(
02:09:56 <Bish> maybe when im fired
02:09:58 <tdammers> kuribas: sure. SOA is independent of proglang. In fact, if you do it right, you can make it polyglot with little effort.
02:10:47 <kuribas> tdammers: I implemented the core business logic of the app from my previous company in haskell, and it was vastly easier (on more efficient).  It would be pretty easy to create a service oriented architecture around it.
02:10:52 <boj> Bish: sorry, no shots fired at you. i managed 8 full time haskell devs and encourage them to document what they can
02:11:12 <akfp> where is fold[rl]1 for NonEmpty?
02:11:13 <boj> blaming people like myself for not encouraging them to contribute
02:11:16 <Bish> boj: what company if i may ask?
02:11:27 <boj> alasconnect, out of alaska
02:11:39 <tdammers> kuribas: exactly.
02:11:50 <boj> ps we are hiring if you are willing to relocate :P
02:12:29 <kuribas> tdammers: in fact CQRS and event sourcing would be a perfect match, since for queries I can just pass the (immutable) state to a different thread.
02:12:32 <Bish> :D im not a haskell-dev yet, and scared of the US
02:12:36 <merijn> boj: To where and doing what? ;)
02:12:55 <merijn> Oh, wait US. Yeah, no
02:12:59 <Axman6> kuribas: see acid-state
02:13:19 <boj> merijn: alaska, very boring IT work for MSP/IT companies (IN HASKELL!)
02:13:35 <dminuoso> akfp: Which NonEmpty are you referring to? base? semigroups?
02:13:37 <Bish> that should be a slogan
02:13:46 <kuribas> Axman6: thanks, I didn't know that :)
02:14:01 <Bish> working for a very boring company, but i can do it in haskell, so i have that going for me
02:14:12 <merijn> Finding Haskell jobs isn't hard. I'm just incredibly picky xD
02:14:16 <dminuoso> akfp: Because these two at least have instances for Foldable
02:14:30 <Bish> i know this is a stupid question, what do you earn as a haskell dev?
02:14:42 <boj> i took the whole "make haskell work in your company" to heart and made it a 100% reality
02:14:53 <Bish> and would people care if you have education in that area?
02:14:56 <Bish> like official
02:15:06 <dminuoso> Bish: As with any software developer that depends on the place, the company, the kind of work, your experience, and your ability to bagain
02:15:09 <merijn> Bish: It depends a lot
02:15:10 <Bish> boj: so it's your company, co0l
02:15:11 <dminuoso> So you really cant say.
02:15:15 <boj> Bish: nothing. to be honest i hire people based on actual software engineering experience, not haskell
02:15:26 <Bish> thats why i said " i know it's a stupid question"
02:15:30 <Bish> just wanted a really stupid range
02:15:30 <boj> Bish: i run the dev department
02:15:32 <merijn> Bish: There's places hiring entry level Haskellers and places hiring, say, Simon Marlow and dons. Those two groups do not get the same kinda money ;)
02:15:33 <dminuoso> Bish: Then why not make it a good question?
02:15:56 <merijn> Or, at least, I hope to god they don't, because else Simon and dons are getting ripped off :p
02:15:58 <Bish> dminuoso: because.. questions about money are always stupid?
02:16:39 <dminuoso> Bish: If you asked "what can a Ruby developer with 5 years of experience earn in a web app gig in San Francisco" I might be able to answer.
02:16:52 <dminuoso> But if you asked "how much can a Ruby developer earn" it's a silly question
02:18:40 <dminuoso> Bish: Unless your question was meant as "what's the lowest and the highest possible salary any Haskell developer has ever seen". Then it's probably from nothing to whatever Simon and dons get =)
02:18:54 <Bish> okay, better question, avg_salary(haskeller) > avg_salary(ruby)?
02:19:03 <merijn> Bish: I think so
02:19:17 <merijn> Bish: Because I think there's more lower/entry level Ruby programmers
02:19:37 <Bish> what about c?
02:19:41 <tdammers> yeah, pretty sure about that
02:19:54 <merijn> The Haskell community is, on average, crazy knowledgable about programming/systems
02:20:28 <guessWho> in Data.aeson https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html package it says we need not to implement the instance and i have tried and it work that way but it also say when needed we can implement the instance so when exactly does it become crucial to implement those instances in case you custom data contains something else then primitive data types >>???
02:20:39 <tdammers> Haskell isn't a typical first programming language; most of us arrived here after a significant learning journey via several others
02:21:06 <merijn> tdammers: Yeah, but also lots of people here know a lot of crazy details about CPU design, operating systems, etc.
02:21:38 <tdammers> merijn: sure; whatever your historical learning path is though, it's going to be longer and deeper than that for Ruby and similar languages
02:22:03 <[exa]> Bish: about C: avg_salary(obsolete_weird_but_important_system_maintenance) > avg_salary(shiny_new_system_maintenance)
02:22:36 <boj> Bish: i can't give you a good answer, but 'd hire a good ruby deleoper with 5 years over a haskell dev with 1 (given a full timeline). it's not just about language experience, although understanding FP is great
02:22:57 <jchia_2> Is there a library that lets me do type-level map on on (type-level) [Symbol]?
02:23:06 <merijn> boj: Depends on how much experience the haskell guy has with non-haskell :p
02:23:34 <jchia_2> I found this, but it says 'deprecated': https://hackage.haskell.org/package/type-list
02:23:35 <guessWho> merijn : can you please look at my question ?
02:24:03 <tdammers> IMO the most important things to look for when hiring a programmer would be 1) programmer's mindset & general cognitive skills, 2) social skills, 3) general programming experience
02:24:24 <tdammers> experience in any particular software stack would be roughly 63) or so
02:24:52 <boj> merijn: sadly, yes.
02:25:08 <tdammers> most important thing is that you can think like a programmer, enjoy learning, can handle criticism constructively, express your thoughts, and cooperate
02:25:31 <tdammers> for most roles, even a very inexperienced candidate who meets these requirements will probably pay off soon enough
02:25:57 <tdammers> experience comes with time, expertise in any particular tech can be learned / taught on the job
02:32:01 <boj> tdammers: on one level i highly agree with you. however, i need someone who understands sql, automation, general programming concepts. that means not just someone with haskell exp (oh my please apply), but someone who understands software engineering in general. i.e. not a jr/intern. if i were hiring for an intern role then yeah, haskell enthusiasm to the max :)
02:32:30 <tdammers> boj: that's why I listed "general dev experience" as 3)
02:32:35 <Bish> tdammers: haskell would make a great first programming language
02:32:50 <boj> makes sense
02:33:08 <tdammers> Bish: maybe so, but the ecosystem is too thorny atm, there are not enough good learning materials, etc.
02:33:26 <merijn> tdammers: Haskell Book is ok, although still some rough parts even with that
02:33:29 <Bish> i always rage about the fact that local universities here all teach java
02:33:34 <boj> my "python will take over the world" jr guy is now so far into haskell that he couldn't imagine anything else
02:33:36 <Bish> java doesn't give you anything
02:33:42 <merijn> I think you really need IRC/someone who knows haskell to really get through Haskell Book
02:33:50 <Bish> boj: hilarious
02:36:40 <Bish> python took the world already more over than it should've
02:36:50 <Bish> like it's pretty common in big companies i feel
02:37:08 <Bish> and they all like to cripple themselves with 2.7⇔3
02:37:36 <tdammers> 2to3 has been an ongoing clusterfuck for about 10 years now IIRC
02:37:59 <Bish> i never got how that language made it
02:38:06 <tdammers> I do
02:38:18 <tdammers> python is heavily optimized for the first 2-3 weeks of learning
02:38:22 <merijn> I do
02:38:25 <tdammers> it is really really good at that
02:38:48 <merijn> Python is literally the result of: "Shit! We need a quick scripting language to automate stuff in our distributed operating systems! Guido, go hack something together!"
02:38:54 <tdammers> and once you've made it through those first 2-3 weeks, Python has the significant advantage of being familiar, so it can coast on that fact alone for another year or so
02:38:56 <boj> take what tdammers said and then consider that sysadmins picked it up for all kinds of tooling, especially the devops movement. not surprising
02:39:02 <cppxor2arr> is web scraping easier in python (requests, beautifulsoup) than haskell?
02:39:09 <batman_> in Data.aeson https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html package it says we need not to implement the instance and i have tried and it work that way but it also say when needed we can implement the instance so when exactly does it become crucial to implement those instances in case you custom data contains something else then primitive data types >>???
02:39:33 <boj> merijn: yeah, exactly
02:39:39 <merijn> cppxor2arr: I haven't really done webscraping in python, but I wrote a quick one in Haskell and it was pretty easy
02:39:47 <cppxor2arr> merijn: thank gosh
02:39:55 <tdammers> put simply, Python quickly reaches the point where the subjective cost/benefit ratio of learning something else is high
02:40:02 <cppxor2arr> merijn: what module did you use?
02:40:15 <merijn> cppxor2arr: It's a bit bitrotted due to async's Concurrently losing it's monad instance, but: https://gist.github.com/merijn/d8188ddd129718ffcfb0
02:40:31 <merijn> cppxor2arr: concurrent webscraper in 78 lines, mostly imports :p
02:40:55 <kuribas> tdammers: cost/benefit for the individual programmer, not the company
02:40:59 <merijn> cppxor2arr: async for concurrency, http-conduit for fetching URLs, html-conduit for scraping the html
02:41:06 <cppxor2arr> merijn: i haven't even learned most of haskell basics yet
02:41:12 <tdammers> kuribas: of course.
02:41:24 <cppxor2arr> i should start doing that after i finish this python weather script. then haskell forever
02:44:29 <kuribas> cppxor2arr: I'd say it's much easier in haskell (tagsoup, hxt, etc...), but it depends on your skills in both.
02:44:57 <kuribas> And the complexity of the project.
02:45:49 <cppxor2arr> kuribas: thanks for the info
02:46:23 <Bish> totally unrelated
02:46:27 <Bish> i just found the coolest thing ever
02:46:32 <Bish> https://github.com/Swordfish90/cool-retro-term
02:48:10 <tdammers> yeah, huge resource hog though, but great fun
02:48:17 <kuribas> pretty neat :)
02:49:37 <matzo> Hi everyone, I had a question about the "Functional Pearl: Implicit Configurations" paper by Kiselyov and Shan.
02:49:49 <matzo> On page four, they talk about the reader monad approach to solving the configurations problem, and say that 'its drawback is that any code that uses configuration data (even only indirectly [..]) must be sequenced into monadic style - even if it does not otherwise have to be'
02:50:26 <matzo> I understand that some people might find monadic notation a drawback, but is there another drawback?
02:51:01 <matzo> Specifically, am I right in thinking that ever since the applicative instance for Reader exists, (and even better: the applicative do extension), 'sequencing into monadic style' won't mean that the operations will be handled sequentially as opposed to parallel?
02:52:22 <boj> matzo: this may sound weird, but "what is the problem"?
02:52:42 <jdelouch> @hoogle [a] -> [a]
02:52:42 <lambdabot> Prelude tail :: [a] -> [a]
02:52:42 <lambdabot> Prelude init :: [a] -> [a]
02:52:42 <lambdabot> Prelude reverse :: [a] -> [a]
02:52:59 <jdelouch> @hoogle [a] -> Bool
02:52:59 <lambdabot> GHC.OldList null :: [a] -> Bool
02:52:59 <lambdabot> NumericPrelude.Base null :: [a] -> Bool
02:52:59 <lambdabot> Data.Edison.Seq.ListSeq null :: [a] -> Bool
02:53:23 <jdelouch> >null
02:53:40 <jdelouch> >null []
02:54:33 <Saizan> matzo: if you are only using the Reader monad than the execution doesn't have to be sequential even with the old do notation, i.e. it's all just functions taking an extra argument so laziness can kick in anytime
02:55:29 <Saizan> matzo: i think he's rather referring to how the code is written down
02:56:10 <dminuoso> matzo: The choice between Reader and argument boils down to: do you want clutter in code that doesn't use the config, or clutter in code that uses the config.
02:56:21 <dminuoso> matzo: You can think of it as a simple toss up
02:57:57 <matzo> boj: Do you mean "what's your question?". If so, I guess I understand that notation wise people might not like using the Reader monad, but reading the introduction made me feel like there was something more of a disadvantage that I just didn't grasp.
02:59:08 <batman_> can someone please help me with this erros http://lpaste.net/362825 here the code http://lpaste.net/362824
02:59:58 <dminuoso> matzo: Another factor is that Reader can easily translate into "suddenly you need a transformer stack" because you want another Monad as well.
03:00:14 <dminuoso> Which wouldn't happen if you simply pass the environment as an argument explicitly
03:00:53 <dminuoso> batman_: <> is from Data.Monoid
03:01:07 <dminuoso> Or Data.Semigroup actually to be exact
03:01:30 <dminuoso> batman_: The error message specifically says:
03:01:34 <dminuoso>     • Variable not in scope: (<>) :: t0 -> t1 -> Series
03:01:39 <dminuoso> So whatever (<>) is, its not defined.
03:01:47 <boj> matzo: i did mean "problem" - like, what problem aare you trying to actual solve?
03:01:58 <matzo> Saizan & dminuoso Thanks!
03:02:17 <yoho> boj: sounds like they're trying to clarify the author's point, not solve any particular problem
03:02:44 <boj> yoho: makes sense
03:02:46 <matzo> boj: Oh, I'm mostly just reading the paper because I saw it on reddit
03:03:16 <dminuoso> matzo: So the thing is.. I learned that Reader doesn't actually "solve" any problem. It just changes the way you express a given problem from "a function" into "a monad". In retrospect I dont think it's that useful.
03:04:09 <Putonlalla> It's only really useful as a special case of `ReaderT`, dminuoso.
03:04:35 <boj> matzo: yep, i understand. question vs. clarifcation
03:04:36 <matzo> boj: But it might actually tie in nicely with a project which grounds logical formulas
03:04:36 <dysfun> yeah, i always use ReaderT instead, just in case
03:05:28 <dminuoso> Though implementing Reader/ReaderT (and all the other transformers) was the best thing I could do to gain a better understanding of Monads
03:05:46 <dminuoso> Loved it from that perspective. ContT was my favourite transformer to write =)
03:06:10 <dysfun> i found it useful to just try a bunch of the monad-using functions on common monads list list and maybe and see what happened
03:07:23 <dminuoso> dysfun: Parser combinators was the final nail in the coffin for me. :)
03:07:41 <dminuoso> For that really warm "Oh that's pretty cool" feeling
03:07:44 <dysfun> hrm, i guess i understood monads before i understood parser combinators :)
03:09:26 <batman_> http://lpaste.net/362826 does this mean i have to write a toJSON instance for SockAddr ??
03:09:46 <tdammers> parser combinators are bafflingly simple
03:10:06 <dysfun> tdammers: *cough* trifecta
03:10:21 <tdammers> they're really just plain old recursive-descent parsers making clever use of currying
03:10:41 <dminuoso> tdammers: The thing that was really baffling, how every recombination produced a simple parser thing. It was like "wait, you can construct complex parsers while maintaining simple Parser things"
03:10:54 <tdammers> dminuoso: right, yes
03:11:25 <dminuoso> :t StateT
03:11:27 <lambdabot> (s -> m (a, s)) -> StateT s m a
03:11:33 <tdammers> dminuoso: for me, the eureka moment with p/c was when I realized how the perfectly straightforward recdesc approach, expressed in Haskell, led to an API whose syntax looks almost like BNF
03:11:41 <dminuoso> I guess a parser is just a: `StateT String []`
03:12:27 <dminuoso> tdammers: Oh yeah. I remember that moment when I suddenly produced a BNF looking parser.
03:13:24 <dysfun> (fwiw, i do like megaparsec, which i do find relatively easy to reason about)
03:14:26 <dminuoso> tdammers: Even things like backtracking are pretty cool to rig into parser combinator.
03:14:56 <tdammers> yeah
03:15:18 <tdammers> there's nothing special going on there, really, it just so happens that Haskell makes the obvious abstractions straightforward and concise
03:15:44 <tdammers> e.g., it makes total sense to have a way of taking a simple parser and applying it repeatedly
03:16:05 <tdammers> the only difference is that what is a language construct in most other languages is just another library function in Haskell
03:17:10 <tdammers> same for pretty much everything else that's a language construct in the usual suspects
03:17:16 <tdammers> error handling, for example
03:18:57 <dminuoso> tdammers: It's also pretty cool that you can simply forego a separate lexer if you want by constructing minimalistic token parsers
03:19:21 <dminuoso> My projects involving bison/yacc were kind of annoying, and it felt superweird.
03:23:02 <loginoob> Is learning advanced algorithms necessary to implement dynamic programming technique
03:24:10 <dysfun> no
03:24:20 <Lycurgus> by dynamic programming you could mean two quite different things
03:24:31 <dysfun> i think the answer is the same for either though
03:24:45 <Lycurgus> one isn't even a computer programming topic per se
03:25:09 <Lycurgus> creeps in interviews love this as a gotcha query
03:25:46 <loginoob> i meant the one where memoization is used
03:25:52 <Lycurgus> the mathematcal optimization technique vs dynamic typed langs
03:26:11 <dminuoso> Lycurgus: Any shop that implies dynamic programming had something to do with dynamic typing is not working at.
03:26:21 <loginoob> i just found out about dynamic programming so I have no clue about how to approach it
03:26:24 <Lycurgus> at the two main, then we get into further equivocation
03:27:08 <dminuoso> Dynamic programming is what you need when you want to implement game of life with a comonad, if you want to see anything beyond the 6th generation =)
03:27:13 <Lycurgus> it was a shithole name of bitcasa, a valley startup whose assets have no doubt flowed down the shitstream by now
03:27:57 <Lycurgus> the one that is based on calculus of variations and due to Richard Bellman is my fave
03:28:20 <Lycurgus> but i bet you could put together a list of maybe on the order of 5-10
03:29:02 <Lycurgus> *as the two
03:29:45 <Lycurgus> any two words central like that are gonna have a similar effect
03:29:50 <Lycurgus> in the right field
03:30:20 <dminuoso> Lycurgus: Also there's no such thing as dynamically typed languages! There's only singly typed and poly typed languages!
03:30:33 <dminuoso> =P
03:32:39 <Lycurgus> here the most likely distinction is between static hs and dynamic lisp
03:34:16 <Lycurgus> and yeah it's a shell game, whatever you answer to "what is dynamic programming?" the right answer will be the other thing
03:34:35 <Bish> that was actually a question in an exam of my girlfriend " what are types for"
03:35:07 <Bish> and i was like "that's a vague question"
03:35:52 <dminuoso> Bish: A way of avoiding Russels Paradox.
03:36:02 <dminuoso> *Russell even
03:36:07 <Putonlalla> A long time ago I remember taking an exam that asked "what are derivatives good for".
03:36:14 <Putonlalla> That was a good exam.
03:36:42 <Bish> dminuoso: ? i learnned that in uni by a different name
03:36:43 <dminuoso> Putonlalla: So it's just a test to see if the students remember why the professor likes them?
03:36:44 <dysfun> "confusing students"
03:38:04 <Putonlalla> It's secretly a test to see if you can hold back making a joke.
03:38:22 <Putonlalla> Only humorless people may pass.
03:39:00 <kuribas> dminuoso: the reader monad is nice for expression mathematical functions.  For example: (+) <$> sin <*> (+4)
03:39:43 <dminuoso> kuribas: How is this more elegant than say a lambda expression or a point free notatoin?
03:40:53 <kuribas> @pl \x -> sin x + (x + 4)
03:40:53 <lambdabot> liftM2 (+) sin (4 +)
03:41:10 <kuribas> dminuoso: even lambdabot agrees ;-)
03:41:32 <Putonlalla> Not a direct answer to your question, dminuoso, but...
03:41:32 <Putonlalla> @google function-level programming
03:41:33 <lambdabot> https://en.wikipedia.org/wiki/Function-level_programming
03:53:28 <Lycurgus> *worth working at
03:55:55 <Lycurgus> is there another hs app as successful as pandoc?
03:59:45 <merijn> Lycurgus: xmonad?
03:59:58 <yushyin> shellcheck
04:00:12 <Lycurgus> somehow didn think of xmonad
04:00:31 <Lycurgus> even though i use
04:00:48 <tdammers> git-annex is somewhat popular, too
04:01:01 <tdammers> and obviously ghc itself
04:01:04 <Lycurgus> because it works where crappy bloatware gnome and the like don't
04:01:44 <tdammers> oh, and also compilers for other languages: purescript, idris, and I think elm, too
04:02:50 <cocreature> if you count facebook’s spam filter as an app, then it’s also quite popular :)
04:02:57 <tsahyt> I've migrated my servant API to using JWT with servant-auth. using BasicAuth I was able to just define a newtype for admin users, with a special auth check. so this way I could have endpoints that encoded in types that they require admin privileges. How would I achieve this using servant-auth? The direct adaption would require a separate token to be granted
04:03:19 <tsahyt> pinging alp just in case
04:04:16 <tsahyt> my current approach includes a privilege field in the token, so I do the check on that field in the respective handlers, but that's not encoded in the types.
04:04:35 * Lycurgus guesses xmonad and pandoc are a class of two
04:05:02 <alp> tsahyt, I think I wrote down my thoughts on authorization with servant (may it be with servant-auth or the thing servant comes with)
04:05:07 <alp> let me find the link
04:05:49 <alp> tsahyt, https://github.com/haskell-servant/servant-auth/issues/73#issuecomment-349737003
04:06:12 <alp> much longer than what I'd dare writing here =)
04:07:01 <tsahyt> alp: is the minRole argument supposed to be phantom?
04:07:44 <alp> tsahyt, absolutely, it in fact should not be related in any way to some potential "role" field in your user data type
04:07:45 <tsahyt> I briefly played with making my User type into a GADT, but then safecopy's TH stuff started complaining and my laziness set in.
04:08:01 <alp> it's just there so that you can state in the API type what minimum role is needed to access an endpoint or a group of them, protected by auth
04:08:08 <tsahyt> so currently I have a data Privilege = ..., and a userPrivilege :: User -> Privilege
04:08:49 <tsahyt> alp: ah but so I'd need to write a custom AuthCheck I suppose?
04:09:36 <alp> tsahyt, yes, or at least augment the standard one, so that you get your user (or error out if the auth data isn't valid) and additionally check the role, comparing it to the one required
04:10:06 <plugin> Could anyone reccomend any "`bound` for dummies" materials?  I have two (non-mutually recursive) GADT "Exp t a" types in HOAS that I need to encode with bound.  I need to keep some of the stong-typing but I'm sort of lost with respect to the big picture of some of the code in the "strongly-typed" bound example.
04:10:37 <tsahyt> alp: hm, so to check the role without making User into a GADT, I'd probably have to use singletons or some related mechanism though, right? I somehow need to pull the phantom argument back down to the value level to do the comparison
04:10:50 <tsahyt> I suppose one could easily write a typeclass for that
04:12:07 <alp> yes, you can use the 'reflection' package or equivalently a one-shot typeclass for that
04:12:40 <tsahyt> I should finally look into reflection then, sounds like a decent excuse
04:12:44 <alp> class KnownPrivilege (p :: Privilege) where knownPrivilege :: Proxy p -> Privilege
04:13:13 <alp> this is pretty much like the class from 'reflection', only specialized to your use case
04:13:15 <tsahyt> attaching a type parameter to User requires minimal changes throughout the entire codebase anyhow. I wonder whether safecopy's TH stuff will accept it without complaining though
04:13:40 <tsahyt> alp: that's essentially the same as KnownNat and KnownSymbol too. I didn't know reflection generalized that
04:14:25 <lyxia> plugin: the bound library doesn't work with multiple types
04:15:50 <tsahyt> alp: thanks again for the help, I'll experiment with this approach then
04:15:58 <plugin> lyxia: You mean the type params in `Exp t a` or the fact that I have a `SubExp u a` that can occur in a constructor of `Exp t a`?
04:16:10 <tsahyt> I originally envisioned something much like the OP in that issue, i.e. a combinator
04:16:12 <lyxia> plugin: both
04:16:23 <tsahyt> but I too didn't know how to go at it
04:17:46 <alp> tsahyt, well again those are just my thoughts on the problem, they're only worth what they're worth really, I'm kind of waiting for someone to challenge them and tell a different story than mine :)
04:18:10 <alp> so... at least you know where to report your thoughts/ideas if you end up being that person =)
04:18:33 <lyxia> plugin: bound provides utilities to work with a single sort of syntax, otherwise it's simpler to roll your own
04:18:55 <tsahyt> alp: well I think a combinator solution would also require some kind of parameter on the User type anyhow. at least I don't see any other way to tie this together on the type level otherwise.
04:19:02 <lyxia> plugin: the core idea is not so difficult anyway http://lpaste.net/362830
04:19:51 <lyxia> plugin: that ^ is system F using (what I think is called) locally nameless representation
04:19:58 <alp> tsahyt, yes. another problem with the separate combinator is: what do you do if for a given endpoint (or group of them) there isn't an authentication combinator used, but only the authorization one? there's no user data to check.
04:20:38 <tsahyt> hm, couldn't you somehow require the auth combinator? i.e. throw a compile time error if it's not present.
04:20:49 <tsahyt> I suppose that doesn't work too well with how :> is processed
04:21:26 <plugin> lyxia: ok, I see.  My main case for using bound was that I would need to serialize the ast including lambdas and I would need to be able to perform substitution.
04:25:00 <alp> tsahyt, yes, absolutely, it doesn't. this whole traversal-through-typeclasses makes it really hard, especially if you don't want to force the two combinators to be next to one another (because there are many reasonable situations where that won't be the case)
04:25:38 <lyxia> plugin: yes that seems like a good use case
04:26:00 <tsahyt> ah right, for example you plop an Auth in front of everything, and then have separate Role combinators way down the tree
04:26:06 <tsahyt> that wouldn't be possible then
04:26:58 <tsahyt> alp: I guess it's possible to catch that, but you'd have to use a rather involved intermediate step at least, which would collect the used combinators. in any case it'd require a major change.
04:27:00 <alp> tsahyt, exactly!
04:27:16 <alp> yes, we'd have to pre-process the API type at the type level or something like that
04:27:20 <tsahyt> e.g. a Canonical typeclass
04:27:23 <tsahyt> type family rather
04:27:24 <alp> really not something I'm looking forward to =)
04:27:48 <alp> and yeah, also, I really don't think this belongs to the API type
04:28:07 <alp> the User (minRole :: Role) solution is a good compromise if you _really_ insist on having roles appear there, IMO.
04:28:45 <plugin> lyxia: So my `Exp` and `SubExp` types are basically just embedded constructors, the DSL should remain embedded.  In this sense, they're close to something like `HardTerm`, I think, in ermine: http://ermine-language.github.io/ermine/Ermine-Syntax-Term.html
04:29:00 <tsahyt> hm, I do like to have that implementation there because it's fundamental to how I use the API on both sides (client and server). when implementing the server I want to make very sure that I don't accidentally mess up authorization of course
04:29:13 <tsahyt> on the client side it's a bit less important I suppose
04:29:19 <tsahyt> in the worst case you get a 401
04:29:24 <plugin> lyxia:  Would it be reasonable to shoehorn them into a single "bound" `Exp` type?
04:29:51 <tsahyt> it really comes down to the server implementation for me, I don't trust myself to not make those mistakes
04:30:00 <tsahyt> so I'd like the compiler to help me with that
04:31:26 <alp> yeah I understand, I've used that approach on serious projects, it certainly has its merits. but I know that the dead-simple aspect of 'userAtLeast' seduced a few users
04:33:07 <plugin> lyxia: sorry, I don't know if you responded, my connection dropped.
04:34:42 <lyxia> plugin: my point was that it would be simpler to write your own than to work with bound and work around its limitations
04:37:13 <merijn> plugin: If you idle here long enough you can ask edwardk, he was helpful when I was writing my own AST with bound
04:38:23 <plugin> lyxia: I believe that's fair in general, I wonder about my own case in terms of "easier"
04:38:57 <plugin> merijn: maybe I'll try that, he should be waking up soon . . .
04:43:17 <dminuoso> kuribas: Oh! :o
04:43:40 <dminuoso> kuribas: Would you consider that idiomatic?
04:43:55 <kuribas> dminuoso: depends what you are doing
04:45:09 <dminuoso> kuribas: The thing that kind of surprises me, is that it gives an alternate way of thinking about this problem. Instead of talking about functional composition, it's... something else.
04:45:49 <kuribas> dminuoso: it's lifting operations on value to operations on functions.
04:45:59 <{AS}> Hi
04:46:08 <{AS}> What library should I use for type-level nats?
04:47:15 <cocreature> {AS}: I suppose the interface provided by GHC.TypeLits is not sufficient for your usecase?
04:47:29 <dminuoso> kuribas: I see. Perhaps it might be helpful to start thinking of it a bit similar to IO. IO produces a result given given some "effect", whereas a function produces a result given some "input".
04:47:38 <{AS}> cocreature: It may be yeah
04:47:47 <{AS}> but it has this "This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library" warning :)
04:47:48 <cocreature> {AS}: that should at least be your starting point
04:47:59 <{AS}> Thanks
04:48:43 <cocreature> {AS}: you probably want to use this together with https://hackage.haskell.org/package/ghc-typelits-natnormalise and https://hackage.haskell.org/package/ghc-typelits-knownnat if you are doing non-trivial calculations at the type-level
04:48:53 <kuribas> dminuoso: yes, you can lift pure functions to functions on IO values as well.
04:48:57 <{AS}> cocreature: Ah, thanks!
04:49:12 <kuribas> dminuoso: that's what the applicative instance of IO does.
04:49:41 <tsahyt> s/applicative/functor
04:49:46 <tsahyt> unless I am much mistaken
04:50:11 <{AS}> cocreature: I come from Idris, so finding the right Haskell libraries for dependent types is a bit harder :)
04:50:15 <tsahyt> :t fmap @IO
04:50:17 <lambdabot> error:
04:50:17 <lambdabot>     Pattern syntax in expression context: fmap@IO
04:50:17 <lambdabot>     Did you mean to enable TypeApplications?
04:50:19 <tsahyt> oh
04:50:29 <tsahyt> fmap @IO :: (a -> b) -> IO a -> IO b
04:50:42 <tsahyt> no applicative required
04:56:53 <cocreature> {AS}: note that the dependently typed features in Haskell are mostly bolted onto an existing languages so using them can be quite clumsy especially compared to languages like idris that have this builtin from the start. so in some cases the benefits don’t outweigh the costs of those features in Haskell
04:57:46 <kuribas>  tsahyt: yes, functor for a unary function, applicative for multi-ary
04:58:09 <ventonegro> cocreature: {AS} is Idris's maintainer :)
04:58:49 <cocreature> ventonegro: oh neat although that doesn’t really change my advice :)
04:59:10 <xpika> is there a shorter form of " callCC $ return . fix"
04:59:22 <{AS}> conal: ventonegro thanks for the comments :)
04:59:28 <{AS}> cocreature: *
04:59:44 <{AS}> sorry conal (wrong highlighting)
04:59:51 <kuribas> :t callCC $ return . fix
04:59:52 <lambdabot> MonadCont m => m (m b)
05:01:58 <kuribas> :t fix
05:01:59 <lambdabot> (a -> a) -> a
05:04:27 <kuribas> xpika: what does that do?  Call the current continuation repeatedly?
05:04:44 <xpika> yep
05:08:28 <kuribas> :t callCC $ \c -> return (let r = c r in r)
05:08:29 <lambdabot> MonadCont m => m (m b)
05:11:44 <Bish> i am confused, why can lambdas return
05:11:53 <Bish> i though you can only do that in do notation
05:12:03 <kuribas> Bish: return = pure
05:12:16 <kuribas> Bish: no you can use it everywhere
05:12:23 <Bish> hm, what does it do?
05:12:23 <kuribas> it's a function, not syntax
05:13:50 <kuribas> xpika: why not ContT fix?
05:13:56 <kuribas> :t ContT fix
05:13:58 <lambdabot> forall k (r :: k) (m :: k -> *). ContT r m (m r)
05:15:11 <kuribas> Bish: I am not sure...
05:17:44 <Bish> dminuoso: halp
05:18:26 <thebnq> :t (return :: a -> b -> a)
05:18:28 <lambdabot> a -> b -> a
05:18:41 <cocreature> Bish: `return` is an ordinary function like any other. it just happens to often be used in do blocks
05:18:46 <kuribas> > runCont (cont fix) (1:)
05:18:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:18:56 <Bish> cocreature: doesn't explain what is it good for
05:19:07 <Bish> right now i understood as "end function with value xyz"
05:19:29 <cocreature> Bish: what it does is defined by the Monad instance of the type you’re using it at
05:19:35 <cocreature> > return 1 :: [Int]
05:19:37 <lambdabot>  [1]
05:19:39 <cocreature> > return 1 :: Maybe Int
05:19:41 <lambdabot>  Just 1
05:19:42 <Bish> i see, so when not using it with any monad at all
05:19:44 <Bish> does what?
05:19:45 <cocreature> > return 1 :: Either () Int
05:19:47 <lambdabot>  Right 1
05:19:55 <cocreature> you can’t use it without any monad
05:19:57 <cocreature> :t return
05:19:58 <lambdabot> Monad m => a -> m a
05:20:12 <cocreature> the return type is always "m a" for some m that is an instance of Monad
05:20:35 <Bish> okay, hm, if i type
05:20:38 <Bish> x = return 1
05:20:42 <Bish> ing hci, and call x
05:20:59 <dminuoso> Bish: ghci is a bit special because you are basically inside an IO monad
05:21:09 <Bish> i see, that helps
05:21:10 <dminuoso> and then GHCi is still special
05:21:34 <Bish> yeah this explains alot already, i thought it does a whole other thing than i thought
05:21:39 <kuribas> > flip runCont id $ do  x <- cont fix; return (1:x)
05:21:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:22:38 <Bish> in my mind monad is someting that has bind & return
05:22:45 <Bish> and return does what the monads return is, doesn't it?
05:25:21 <kuribas> Bish: return is monad return
05:25:33 <kuribas> Bish: and applicative pure
05:25:46 <dminuoso> Or, if you an AMP proponent, you just use `pure` and forget about return
05:26:53 <jchia_2> Is there a library that embodies the type-level list functions in this blog, particularly, Map? https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html Data.Singletons.Prelude.List seems relevant but I don't understand the singletons library.
05:28:57 <Bish> dminuoso: i don't know what applicitive is , yet
05:29:33 <dminuoso> :t (<$>)
05:29:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:29:36 <dminuoso> :t (<*>)
05:29:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:29:40 <dminuoso> :t (=<<)
05:29:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:29:59 <Bish> doesn't help :( not clever enough
05:30:25 <phadej> jchia_2: that blog post lies
05:30:33 <dminuoso> Bish: Applicative and Monad are very similar. They just differ in one respect.
05:30:33 <phadej> > It is even possible to define type-level map function.
05:30:34 <Bish> what book exactly did i need to buy because LYAH is supposed to be stupid
05:30:35 <lambdabot>  <hint>:1:31: error: parse error on input ‘type’
05:30:37 <phadej> but when you try the example
05:30:44 <phadej> The type family ‘MakePair’ should have 1 argument, but has been given none
05:31:02 <dminuoso> Bish: (a -> m b) is a function that has the freedom to look at "a", and then _decide_ which monad/effect to do next.
05:31:04 <phadej> (maybe it works in GHCi for some reason)
05:31:10 <dminuoso> Bish: applicative has no "decision" ability.
05:31:28 <Bish> what means, decide?
05:31:31 <Bish> an example for thath
05:31:33 <dminuoso> Bish: Pick. As in
05:31:48 <dminuoso> \x -> if x > 2 then putStrLr "Nothing" else launchMissles
05:31:54 <dminuoso> This thing has the freedom to pick an effect.
05:32:09 <phadej> jchia_2: so most applications have to define partially applied `Map`
05:32:38 <Bish> dminuoso: and applicative can just apply to it?
05:32:45 <Bish> oh..
05:32:47 <Bish> i see.
05:32:52 <Bish> applicative.. apply..
05:33:05 <Bish> so it basicially wraps whatever you're doing
05:33:48 <dminuoso> Bish: Let's say you use the applicative interface of IO for the sake of argument
05:34:08 <Bish> but is how i understood it so far correct?
05:34:20 <Bish> it can only wrap something but can't really change what it is?
05:34:46 <sQVe> Has anyone gotten HIE to work with LanguageServer on Vim?
05:35:03 <kuribas> > flip runCont id $ do x <- ContT fix; return (1:runIdentity x)
05:35:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:35:11 <sQVe> I'm really struggling getting it to work properly. I worked a couple of days ago but now it is dead...
05:35:53 <dminuoso> Bish: Essentially Applicative can be understood best by
05:35:55 <dminuoso> :t liftA
05:35:56 <lambdabot> Applicative f => (a -> b) -> f a -> f b
05:35:57 <dminuoso> :t liftA2
05:35:58 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:36:13 <Bish> i didn't understand the process of lifting (really) either
05:36:17 <Bish> :>
05:36:21 <thebnq> > (+) <$> Just 1 <*> Just 2
05:36:23 <lambdabot>  Just 3
05:36:52 <dminuoso> Bish: The idea is.. take the notion of a functor where you can have values inside to the next level. Lets say you can have *functions* inside a functor.
05:36:55 <Bish> so it unpacks it. adds, and packs it again?
05:37:19 <Bish> what's the <*> for?
05:37:30 <Bish> :t <$>
05:37:32 <lambdabot> error: parse error on input ‘<$>’
05:37:39 <Bish> :t (<$>)
05:37:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:38:03 <Bish> :t (<*>)
05:38:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:38:13 <Bish> hm
05:38:42 <Bish> dminuoso: yeh functions inside a functor, eh?
05:38:43 <dminuoso> Bish: https://gist.github.com/anonymous/4cfd6d7a02f212a4b7fe8871cc7182d3
05:39:04 <dminuoso> Bish: Right, and applicatives all you to somehow "apply them" to applicatives with values
05:39:13 <dminuoso> so its function application with effects/context
05:39:18 <Bish> all = allow?
05:39:53 <Bish> can you give me an example, a simple one?
05:39:58 <Bish> just like the thing thebnq did
05:40:01 <dminuoso> Bish: Maybe.
05:40:02 <Bish> but cooler
05:40:09 <dminuoso> Bish: Lists.
05:40:13 <dminuoso> Bish: IO
05:40:16 <Bish> uhm, someting more verbose?
05:40:27 <dminuoso> Bish: Cont, Reader, State
05:40:41 <Bish> hm, something i can see, maybe?
05:40:53 <dminuoso> Bish: Maybe and [] are the fastest way to try them out
05:41:23 <Bish> well, i used both of them already
05:41:27 <dminuoso> Bish: The problem with the "boxing"/"unboxing" analogy is that it hides the main thing what applicatives are about. That "unboxing" is where the magic happens.
05:41:28 <thebnq> Either is also a simple one
05:41:48 <Bish> i used all of them, but i don't understand where the maigc happens
05:41:49 <jchia_2> phadej: Thanks. Now when I actually try to borrow the blog's code, I'm getting errors. How can I make it work? http://lpaste.net/362834
05:42:00 <Bish> so i might understand it intuivly but not really?
05:42:11 <dminuoso> Bish: the best way to understand them, is to implement them yourself.
05:42:19 <dminuoso> Bish: Just use the type signatures, and let the types guide you.
05:42:31 <dminuoso> There's basically no way to implement Functor/Applicative/Monad wrong for Maybe, Either and []
05:43:12 <Bish> lol, okay
05:43:14 <Bish> will try
05:43:16 <Bish> but basicially
05:43:24 <Bish> <$> <*> are the things i want to be working with
05:43:45 <dminuoso> Bish: for applicative it might as well be liftA/liftA2
05:44:03 <dminuoso> err *liftA2/liftA3
05:44:18 <dminuoso> Bish: But just implement the typeclasses yourself.
05:45:47 <merijn> dminuoso: Eh, yes there is :p
05:46:12 <merijn> dminuoso: "instance Applicative Maybe where pure _ = Nothing; _ <*> _ = Nothing"
05:46:14 <dminuoso> merijn: Well yeah. But it should be obvious. =)
05:46:17 <dminuoso> Oh yeah.
05:46:38 <merijn> But yeah, they're mostly obvious for Maybe and Either
05:46:55 <merijn> dminuoso: Actually, Applicative for [] is definitely not obvious as there are two lawful list applicatives
05:50:01 <Bish> oh i didn't get these either, yet
05:50:26 <Bish> can you give me an example for something a typeclass is easy?
05:50:37 <Bish> like an order-able enum?
05:50:42 <Bish> or....
05:52:07 <[exa]> Ord?
05:52:36 <Bish> ah.. so i can just use that?
05:52:38 <Bish> and that works..
05:52:46 <Bish> but i don't know then what implementing a typeclass means
05:54:11 * [exa] a bit confused from the scrollback
05:54:35 <dminuoso> Bish: Remember Ruby? When you want to include `Enumerable` into something, you have to define the method `each`
05:54:56 <dminuoso> Bish: This is the same exact thing. When you want something to have an instance of a typeclass, you have to supply implementations for the required methods
05:55:11 <Bish> but things don't have methods here
05:55:19 <dminuoso> Bish: actually things like `fmap` are called methods.
05:55:39 <dminuoso> or.. I thought they were. Why do I think they are
05:55:46 <ab9rf> dminuoso: they're called methods
05:55:54 <dminuoso> Ah indeed. =)
05:55:56 <Bish> really methods? i thought that's a oop thing
05:56:08 <ab9rf> it's the name used in the haskell report
05:56:34 <dminuoso> Bish: It's no different really. "Array is an Enumerable because two things happened. First you provided an implementation for #each, and then you declared that it is an Enumerable by "including""
05:56:37 <Bish> puremethod programming
05:56:52 <dminuoso> Bish: In Haskell you do the same thing by "declaring an instance" and supplying the method definitions.
05:58:58 <[exa]> Bish: also note that there's no 'this' or 'self' that is usual in OOP, only the method arguments (which may or may not include values of the type corresponding to the instance)
05:59:05 <dminuoso> Bish: And what Ruby calls Comparable is `Ord` in Haskell. Just like there you have to supply a `<=>` method, Ord requires `compare`
06:01:44 <Bish> dminuoso: yeah that's how i understood it, but i have no use case
06:01:55 <Bish> i never implemented enumerable either
06:02:09 <Bish> well, maybe i overloaded (whatever that is called in ruby) each
06:02:21 <hyperisco> was thinking… if you could reflect on types, you could implement LEM
06:02:40 <EvanR> what i wish i knew when learning ruby
06:03:00 <EvanR> hyperisco: highly skeptical
06:03:09 <hyperisco> a -> b is constructible iff b is, Either a b is constructible iff a or b is, (a, b) is constructible iff a and b is, () is constructible, Void is not constructible
06:03:20 <EvanR> but you can implement specializations of LEM, one where you get more than just "what to decide"
06:04:42 <hyperisco> I guess  a -> b is constructible iff b is given a
06:05:53 <hyperisco> so  Void -> Void  is constructible
06:06:56 <hyperisco> so in other words,  lem :: forall a. Either a (a -> Void)
06:07:06 <EvanR> what is the forall ranging over
06:07:12 <hyperisco> types
06:07:31 <EvanR> which only consists of the 5 above
06:07:53 <hyperisco> all other types can be implemented with those 5
06:08:01 <EvanR> nah
06:08:08 <hyperisco> okay, you need Fix too
06:08:15 <EvanR> o_O
06:08:42 <hyperisco> well otherwise all your types are finite
06:09:32 <Taneb> Is Fix (Either Void) constructible?
06:09:53 <dminuoso> EvanR: I actually rerigged include hooks to provide slightly safer mixins, so that things like Enumerable were not as brittle: https://eval.in/961904
06:10:12 <dminuoso> EvanR: Curiously I was met with much skepticism and laughter, why one would want to assert that the interface was properly provided.
06:10:29 <EvanR> i think your first idea was propositional logic
06:11:01 <hyperisco> Taneb, sort of
06:11:20 <Taneb> hyperisco: that's a useful answer when you're trying to do logic with types ;)
06:13:13 <hyperisco> Taneb, well if we're going to use examples of bottom then we might as well say  trivial :: forall a. a; trivial = trivial
06:13:47 <Taneb> hyperisco: Fix (Either Void) is constructible in lazy systems but not in strict systems
06:13:52 <EvanR> according to wikipedia  Logical systems such as propositional logic are decidable if membership in their set of logically valid formulas (or theorems) can be effectively determined
06:14:14 <EvanR> well i guess thats more of a definition of decidable
06:18:07 <hyperisco> I have to think more carefully about Fix
06:18:26 <hyperisco> but anyways, what is the real reason we don't want LEM?
06:18:48 <EvanR> you cant have LEM in predicate logic, or higher
06:19:25 <EvanR> for instance if you allow dependent pair and dependent function, to effectively get higher order logic
06:19:50 <hyperisco> why can you not have LEM in predicate logic?
06:19:50 <EvanR> having LEM in that case would be cool but impossible
06:20:05 <EvanR> https://en.wikipedia.org/wiki/Entscheidungsproblem
06:23:05 <EvanR> @djinn Void -> Void
06:23:05 <lambdabot> f a = a
06:23:15 <EvanR> @djinn (Void, Void)
06:23:16 <lambdabot> -- f cannot be realized.
06:23:18 <thevishy> in haskell usually is it considered good to exceed >79 chars?
06:23:36 <hyperisco> thevishy, on a single line? I use 72
06:23:37 <EvanR> cool, your algorithm for nondependent types exists :)
06:23:46 <thevishy> i mean I am just wondering if writing functional languages would usually lead to long lines
06:23:52 <thevishy> okay hyperisco
06:24:01 <[Leary]> I go to 80 all the time, but no further.
06:24:08 <thevishy> I am new to functional languages and I was checking the Yi editor
06:24:12 <[Leary]> Haskell is lenient on whitespace and linebreaks
06:24:14 <thevishy> probably not a good idea
06:24:40 <thevishy> but I just wanted to see if I can understand it
06:24:48 <EvanR> @djinn (Void, ()) -> Void
06:24:49 <lambdabot> f (a, _) = a
06:25:02 <thevishy> i prefer 79 usually and I don't like it when you exceed more than that
06:25:28 <EvanR> but... i need at least 2 columns for vim line number and a space after that :)
06:25:40 <thevishy> yes exactly
06:25:44 <thevishy> :-)
06:25:55 <thevishy> the splits is the main reason for 79
06:25:59 <hyperisco> EvanR, I don't understand the scope of the question
06:26:08 <EvanR> what question
06:26:51 <{AS}> Another question
06:27:00 <{AS}> How do I use a function at type-level? :)
06:27:10 <EvanR> theres type families
06:27:11 <hyperisco> EvanR, well what predicates and variables are they talking about? arbitrary?
06:27:12 <dminuoso> This might be a stupid question, but why doesn't Monad have {-# MINIMAL (>>=) | (=<<) | join #-} ?
06:27:16 <hyperisco> I don't know how you even quantify that
06:27:24 <{AS}> EvanR: so I can't use a Haskell function at type level?
06:27:37 <EvanR> no you cant use any values at type level
06:27:45 <{AS}> Oh :(
06:27:50 <{AS}> Thanks for the answer anyway :)
06:27:57 <EvanR> only special types that look like values, ala DataKinds
06:28:13 <{AS}> Ahh
06:28:54 <ventonegro> {AS}: http://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html
06:29:03 <{AS}> ventonegro: Thanks!
06:29:18 <ventonegro> {AS}: np
06:29:25 <hyperisco> EvanR, does that problem relate to a type system like Haskell's?
06:31:50 <mercury^> Hey. Is Duncan Coutts still around here sometimes?
06:34:23 <EvanR> hyperisco: i suspect yes, maybe if you just consider only haskells type level and not the values
06:36:25 <EvanR> because the value level is illogical already
06:37:29 <byorgey> mercury^: I don't think I've seen him here recently
06:37:54 <mercury^> byorgey: thanks.
06:38:57 <hyperisco> EvanR, maybe the problem slipped by me quietly at the beginning with a -> b
06:39:04 <jonge> hi there, what is the monadic equivalent of the applicative `<$` operator? i would guess there is a `<<` operator, but there does not seem to be.
06:39:22 <hyperisco> I said you can construct it iff you can construct b, which I then realised was wrong, so then said you can construct it iff you can construct b given a
06:39:27 <EvanR> this book says that in propositional logic, implication (->), is decidable
06:39:32 <hyperisco> but then I did not elaborate how you determine if you can construct b given a
06:39:41 <EvanR> and @djinn does that
06:39:44 <byorgey> jonge: the monadic equivalent of <$ is <$ .
06:39:45 <hyperisco> whereas all the other explanations were obvious
06:40:13 <EvanR> you can search backwards through the type building rules
06:40:26 <byorgey> jonge: because every Monad must also be Applicative.  The fact that some Applicative operators have different 'monadic equivalents' is a historical accident.
06:40:27 <hyperisco> jonge, <$ is a Functor operator, and that is all you need
06:40:28 <EvanR> keeping track of what you have in context
06:41:05 <EvanR> until you reach an "axiom" (no preconditions)
06:41:18 <byorgey> right, and <$ is not even specific to Applicative.  It is just  fmap . const
06:42:00 <EvanR> i bet the inclusion of Fix makes this process questionably terminating
06:42:04 <hyperisco> okay, even if I can take the antecedent apart to its fundamentals, is it so obvious how I can determine if something else is constructible from those pieces (plus whatever else I may have for free)?
06:42:05 <jonge> hyperisco: byorgey: what i am specifially looking for: imagine we have a function `f x = print x >> return x`. then i want to do `f 1 << f2` so i can see printed `1\n2` but the return value i get is `1`
06:42:31 <byorgey> jonge: in that case you want  <*
06:43:02 <EvanR> hyperisco: yes, for the 5 types you started with
06:43:25 <EvanR> each time you take apart the domain type, the problem gets smaller
06:43:37 <EvanR> because the whole type expression is finite
06:43:38 <jonge> byorgey:  wow yes that works. thanks! should have got this myself lol. hyperisco thanks to you too
06:43:46 <byorgey> jonge: glad to help =)
06:44:23 <hyperisco> that is bona fide Applicative operator
06:44:49 <roconnor> I'm confured as to why using (memoFix) isn't faster in my application than just suing (memo)
06:44:54 <jonge> hyperisco: bona fide? why
06:45:15 <hyperisco> because it has the Applicative constraint
06:46:13 <hyperisco> EvanR, with those 5 types, there is only one which is basically not constructible, and then inductively some others
06:46:24 <roconnor> is GHC smart enough for the memo trie to persist between invokations of foo where foo = memo bar?
06:46:37 <hyperisco> so really the only problem I run into with  a -> b  is whether b necessitates having a Void, and so whether  a  includes a Void
06:46:53 <EvanR> yes your search algorithm returns a set of ways to build x given some context, if you ever get empty, stop.
06:47:44 <EvanR> finally, takes the head if there is one, thats the answer
06:48:00 <EvanR> the only question is termination
06:48:28 <hyperisco> though  a  may be itself a function
06:48:35 <EvanR> yes
06:48:55 <EvanR> eventually its not though
06:49:05 <EvanR> unless you use Fix
06:49:28 <hyperisco> since all I have to hunt for is a Void, it is pretty clear that if in  x -> y  if y has a Void then I merely search for an x
06:49:37 <EvanR> thats not true
06:49:48 <EvanR> you may have a Void
06:50:29 <hyperisco> if the type I am trying to construct does not necessarily contain Void, I can construct it regardless of what I am given
06:50:31 <EvanR> the -> establishes the need for context management
06:50:52 <EvanR> ok sure that might be a shortcut
06:50:59 <hyperisco> so the only interesting case is when I am trying to construct something which necessarily has Void
06:51:07 <hyperisco> then I have to take into account what I am given
06:51:19 <EvanR> sure, so you use the real algorithm which works in any case if you see a Void
06:51:25 <EvanR> otherwise you can use the optimization
06:51:34 <hyperisco> if I am given an  x -> y  then it only helps me if y contains Void, and if it does, I must find an x, which I can only do if x does not contain Void
06:51:37 <EvanR> but the full algorithm follows directly from the rules of logic you made up
06:51:50 <roconnor> oh wow, GHC is smart enough! memo f x = untrie (trie f) x wouldn't persist the Trie, but memo f = untrie (trie f)
06:51:56 <roconnor> des
06:51:58 <roconnor> *does
06:52:10 <tsahyt> alp: to get a custom auth check, do I need my own type with an IsAuth instance?
06:52:14 <EvanR> hyperisco: yeah, but you can just solve the other problem and forget the optimization
06:52:24 <tsahyt> from reading the code it seems like the IsAuth instance for JWT locks me into the default function
06:52:27 <EvanR> solve the real problem first
06:52:30 <hyperisco> well that is the way in which it is obviously solvable, to me
06:52:46 <EvanR> you only said... if it contains void i have to solve the problem
06:52:54 <tsahyt> hm, or perhaps I can somehow leverage the FromJWT instance
06:53:03 <hyperisco> right… if it doesn't it is obvious
06:53:10 <EvanR> that doesnt prove anything o_O
06:53:13 <tsahyt> yes I think I can
06:53:33 <EvanR> addition is defined as x + 0 = x, otherwise...
06:54:03 <EvanR> x+0 is obvious, doesnt solve it
06:54:47 <EvanR> hyperisco: so begin with (x,y), for giggles. how does your algorithm work
06:55:04 <hyperisco> I don't really care, I was just trying to see whether it was possible
06:55:11 <EvanR> O_o
06:55:47 <EvanR> just use LEM to say, it is or is not possible, who cares which :)
06:56:03 <hyperisco> one reason you don't want this is because it violates parametricity
06:56:29 <EvanR> oh, youre trying to retroactively explain why you dont want LEM. right, that doesnt make sense
06:56:37 <alp> tsahyt, I think you can reuse some of the code yes, not as much as you'd like (unlike with the standard auth stuffs that come with the core servant packages), but still
06:57:01 <Mark___> any thoughts on whether to include stack.yaml in a github project vs having people do 'stack init' ?
06:57:17 <hyperisco> yes… it is brought up time to time that constructively, LEM is not provable
06:57:32 <EvanR> its not provable in classical logic either
06:57:38 <tsahyt> alp: I think I've got something that was relatively minimal in terms of effort, by just having separate FromJWT instances
06:57:43 <EvanR> the issue begin whether to allow it as a principle
06:57:45 <hyperisco> well, I was thinking this morning that it would be with reflection, at least for some type systems
06:57:47 <tsahyt> let's see if this works
06:58:28 <alp> tsahyt, yeah fortunately you don't need to do anything with the request to perform the privilege check, you can do that just with the User value
06:58:35 <alp> so that should work
06:59:29 <hyperisco> uh, well I guess you might consider it an axiom
06:59:51 <EvanR> hyperisco: as an exercise, encode collatz conjecture into haskells type level. if then you figure out how to decide inhabitation, you solved the collatz conjecture
06:59:53 <hyperisco> maybe I should implement it with TH and we'll see how life is
07:00:23 <EvanR> there might be a reward floating around for that
07:00:34 <hyperisco> wasn't it a million bucks?
07:00:46 <EvanR> thats riemann hypothesis
07:00:53 <hyperisco> ah well
07:01:37 <EvanR> and if you do all that, then yes entscheidungsproblem is relevant
07:01:44 <hyperisco> actually yeah, GADTs may muddy the waters… didn't give much thought to that
07:02:07 <hyperisco> was just thinking about ADTs and functions, not GADTs
07:02:30 <EvanR> if youre limited to that, i think thats where @djinn comes in
07:02:41 <Taneb> iirc the reward for solving the Collatz conjecture was $50
07:02:48 <EvanR> haha
07:02:58 <hyperisco> lmao… well I can order in a pizza to celebrate
07:03:22 <[Leary]> That's gotta be Erdos... No one else would offer so little.
07:03:30 <hyperisco> if it is only $50 then I will make myself a footnote right now and announce a $100 reward
07:03:44 <[Leary]> I think the real prize is getting his signature on a check.
07:05:06 <Taneb> Ah, it was $500, and it was Erdos
07:05:14 <byorgey> [Leary]: well, since he's dead, that would be an amazing prize.
07:06:09 <hyperisco> and $1000 is a bit dear to me, so the $500 will have to stand
07:06:29 <[Leary]> I guess if you add your own signature to it you can reduce your Erdos number too. >.>
07:06:34 <byorgey> Unlike the Riemann Hypothesis, no one actually thinks the Collatz Conjecture is important.  It's just one of those easy-to-state problems that turns out to be incredibly difficult.
07:07:23 <Taneb> It's one of my favourite unsolved problems in mathematics because I too am difficult and probably useless
07:07:26 <hyperisco> no, the difference is that we're so far from understanding the Collatz Conjecture we don't even know why it is important
07:07:40 <EvanR> since its easy to state, thats why it would be useful here as strong evidence the decidability algorithm for haskell wont be possible
07:08:06 <hyperisco> okay, with GADTs, I wouldn't think for a moment you could determine inhabitability
07:08:13 <EvanR> but why?
07:08:14 <byorgey> hyperisco: haha, good point
07:09:05 <EvanR> each data type you introduce adds more rules, you just need to check more cases in your search
07:09:10 <hyperisco> EvanR, because I know how to encode lots of problems with GADTs, though I do not know conclusively if it is undecidable
07:09:17 <EvanR> i think the main issue is going to be recursive types, Fix
07:09:27 <EvanR> not the G in GADTs
07:09:48 <hyperisco> the face of it is certainly more complicated than ADTs, so my intuition goes from "seems easy" to "probably not going to work"
07:09:50 <EvanR> i think Fix is the wrong word... its Mu
07:10:02 <tsahyt> alp: yes this seems to work just fine. I've got data Privilege = None | Admin, data Login (p :: Privilege) = Login UserID Privilege, and instance FromJWT (Login None), which uses the generic implementation, and then instance FromJWT (Login Admin) which first calls the unprivileged one and then does an additional check, possibly failing
07:10:08 <hyperisco> Μ
07:10:19 <tsahyt> everything else is pretty much unaltered, in particular no changes to the context were made
07:11:03 <tsahyt> and if a user was to mess with the token to cheat themselves to admin privileges, the JWT signature check would fail
07:11:20 <hyperisco> EvanR, but you do not necessarily have infinite descent or some other convenience like this
07:11:24 <EvanR> hyperisco: if there were no recursion, then you could search for proper rules by using unification
07:11:40 <EvanR> to solve the GADT parameters
07:11:58 <hyperisco> rather types can shrink or grow and even though you can enumerate all possibilities, there is not necessarily any way to tell when to stop searching
07:11:59 <EvanR> thats the only thing GADTs add
07:12:06 <tsahyt> now I just need to figure out why this is setting a cookie even though I haven't used the Cookie auth method
07:13:04 <EvanR> the search stops when you have decided the problem
07:13:16 <EvanR> not earlier
07:13:21 <hyperisco> if you have to reject as "not inhabited" that is the problem
07:13:39 <EvanR> the problem is "is it or is it not inhabited"
07:13:49 <EvanR> (i thought)
07:13:50 <hyperisco> or you're accepting that deciding non-inhabitability is nonterminating
07:13:56 <EvanR> no
07:14:23 <EvanR> without recursive types, the search is terminating
07:15:00 <hyperisco> maybe, will have to think about that later
07:17:57 <TMA> EvanR: unless I am mistaken, recursive types are inhabited iff there is some "base case" that is inhabited. [for standard models. nonstandard models (of the same ilk as nonstandard natural numbers) might pose a problem]
07:18:52 <hyperisco> what about coinduction
07:19:13 <hyperisco> that is what Taneb brought up earlier
07:19:48 <EvanR> TMA: well... what about recursive parameterized types
07:20:01 <EvanR> T a b c
07:20:35 <EvanR> hyperisco: thats not going to matter in the total logic of type level only haskell
07:21:41 <hyperisco> why only Haskell though?
07:23:34 <TMA> EvanR: codata are IMO more problematic; but even then: what about nonrecursive parametrized types? if Either Void Void is not inhabited and Either Int Int is, what does it say about Either a b?
07:24:50 <EvanR> according to me arbitrary concretization of hyperisco's problem, a and b will be filled in when they appear somewhere inside the type being analyzed
07:25:03 <EvanR> and also for other parameterized types in there
07:25:21 <EvanR> is a base case obvious
07:31:04 <nshepperd1> I think you can encode pretty much all of second order logic in GADTs so it's definitely undecidable
07:34:08 <SovietBear> how can i do this? class Newtype e { id :: Maybe Int | r } <= EditModel e where
07:34:15 <SovietBear> how to quantify `r`?
07:36:27 <nshepperd1> Put a GADT constructor for each rule and axiom of your logical system
07:39:46 <woodson> I am using wreq to execute http request, and I would like to write test for my code but I do not know how to make a response mock
07:40:06 <woodson> anyone have good tutorials that can show how?
07:40:32 <woodson> I found this tutorial https://making.pusher.com/unit-testing-io-in-haskell/ but there are so many missing pieces
07:40:39 <nshepperd1> Need to take care to avoid coinduction from giving spurious proofs though, maybe a descending "proof size" parameter would do the trick there
07:57:11 <EvanR> SovietBear: what language is that
07:57:21 <SovietBear> EvanR: purescript
08:05:00 <Welkin> SovietBear: haskell records are not extensible
08:05:13 <Welkin> I believe there is a library that allows this though
08:06:01 <SovietBear> Welkin: it's purescript
08:06:25 <Welkin> were you not asking how to do that in haskell?
08:07:01 <brynedwards> Have you tried the #purescript channel? I assume there is one
08:07:16 <Welkin> there is, but it dead
08:07:18 <Welkin> no one talks there
08:07:24 <Welkin> they have moved to slack, sadly
08:07:28 <EvanR> probably indicates... yeah
08:07:49 <Welkin> you can get answers pretty quickly on slack though
08:07:55 <Welkin> even if slack is terrible to use
08:08:48 <jdelouch> @pl getPredicate veryOdd <$> [0 .. 11]
08:08:49 <lambdabot> getPredicate veryOdd <$> [0..11]
08:09:19 <EvanR> @unpl getPredicate veryOdd <$> [0 .. 11]
08:09:20 <lambdabot> (getPredicate veryOdd <$> ([0 .. 11]))
09:24:48 <cppxor2arr> are most people here in the us or are the time zones diverse?
09:25:11 <brynedwards> I'm in Ireland so...
09:26:08 <Taneb> cppxor2arr: time zones are pretty diverse here
09:26:13 <cppxor2arr> good to know
10:09:29 <dminuoso> Maybe someone with terminal emulator knowledge has an idea. Im printing generations for my cellular automaton. If the frequency is too high, some lines get printed +1 row below where they should: https://gist.github.com/anonymous/68751d7055b8bd6f888aaf7f571575fc
10:10:37 <monochrom> Is it because some lines are exactly 80 characters long?
10:11:04 <dminuoso> monochrom: mmm no. they are all 40 characters wide and fit well inside the terminal
10:11:19 <monochrom> Hrm you already set cursor position.
10:11:27 <metahumor> are you printing '\r'?
10:11:51 <dminuoso> metahumor: Dunno, does putStrLn?
10:11:58 <metahumor> yeah putStrLn appends '\n' iirc
10:12:53 <metahumor> otherwise "traverse_ putStrLn" would have placed all of it on one line
10:13:20 <MarcelineVQ> psst, include bad and good output examples :>
10:13:39 <monochrom> putStrLn gives you a \n for free. Not \r though.  (Unless you're on Windows.  But even then, it is the RTS not putStrLn per se who adds \r)
10:14:11 <monochrom> (Actually "RTS" is a bit inaccurate too.  I mean whatever is lower-level than putStrLn)
10:14:35 <metahumor> you could try "print . intercalate "\n" . tranpose ..."
10:14:43 <metahumor> or something along those lines
10:16:12 <dminuoso> MarcelineVQ: Dunno how to do that, the "off by one frames" only stick around for a few milliseconds or so.
10:16:31 <metahumor> could be some weird output buffering too
10:16:31 <dminuoso> And they only occur if I reduce the delay between frames, so..
10:16:50 <MarcelineVQ> oh, is this graphical?
10:17:01 <metahumor> you could just increase the threadDelay
10:17:22 <MarcelineVQ> oh, no it's text
10:17:31 <metahumor> and there are also cli utilities that wrap other executables, messing with the internal clock measurement"
10:17:59 <dminuoso> metahumor: Haha. The point was to decrease it because I want to see my automaton evolve faster.
10:18:07 <dminuoso> I mean I could simply skip frames..
10:19:14 <eschnett> i have two constraints k1 and k2, with k1 ~ k2. now i need to prove to ghc that k1 a => k2 a. do you have any pointers?
10:19:31 <eschnett> i'm looking at Data.Constraints, but i don't see ~ mentioned there.
10:21:25 <metahumor> forall a?
10:22:14 <metahumor> (k1 ~ k2) yet (k1 a => k2 a) as opposed to (k1 a ~ k2 a)?
10:26:23 <c_wraith> eschnett, :~:  ?
10:26:47 <c_wraith> eschnett, oh, I see. that's not right.
10:26:58 <dminuoso> metahumor: Okay I gotta put this on hold. Just tried switching back to a non-profiling build by doing `stack clean; stack build; stack exec ...` the code seems to execute at perhaps 1/1000th the regular speed.
10:27:05 <dminuoso> This is so weird.
10:28:40 <eschnett> metahumor: actually, the problem is that k2 a cannot be inferred. i don't know what is actually missing.
10:28:56 <metahumor> "~>"?
10:29:23 <eschnett> metahumor: I don't see this operator in Data.Constraint?
10:30:27 <eschnett> i pasted the code into https://gist.github.com/eschnett/8fd15154296520439b652a6d12e4a589
10:31:43 <metahumor> iirc "type f ~> g = forall a . f a -> g a"
10:33:49 <eschnett> metahumor: found it by trial and error... opening the Dict for "k1 a" makes it work.
10:34:10 <eschnett> i wish there was a better tutorial than a Haddock page and two talks by Edward Kmett...
10:35:02 <metahumor> yeah...
10:35:09 <metahumor> now the onus is on you
10:39:55 <eschnett> metahumor: good idea. i was thinking of advertising the results of my attempts, but i should explain the respective haskell packages as well.
10:43:20 <dminuoso> metahumor: Still causes the issue.
10:45:26 <metahumor> what is going on
10:45:54 <sonOfRa> a netsplit. One (or more) servers dropped out of the network.
10:55:16 <metahumor> dminuoso: you could also try using "putStr" which doesn't append newlines
11:04:53 <piark_> re
11:11:57 <Habib> Hey, anyone familiar with giving talks on Haskell to an interested, but ignorant, audience?
11:12:19 <Habib> Specifically, demonstrating the value of Haskell's type system to Ruby (or similar) developers.
11:13:18 <EvanR> i can imagine that talk being very long
11:13:25 <EvanR> and i want to be there for it
11:13:38 <Habib> Hah. I'm thinking of recording it, actually.
11:14:05 <Habib> We do a biweekly dev forum at my company where we can give talks, but we've never recorded any yet.
11:14:29 <Habib> I'll see if I can get it done for you, EvanR.
11:14:58 <Habib> This months will be months in the making, though, as I hardly ever get time to actually plan out a proper talk, and I really want this one to be good.
11:15:02 <Habib> This talk*
11:15:20 <metahumor> Habib: find a common issue/problem/usecase and explore solutions around it in both languagues
11:15:45 <metahumor> since you are the one structuring the discussion, you can guide it towards patterns/ideas that are better expressed in haskell
11:15:54 <Habib> They're already slightly primed for ML-style, as I've talked about the semantics of Haskell/Elm a lot with them.
11:16:05 <metahumor> ruby programmers are already familiar with blocks, which is nice
11:16:16 <Habib> metahumor, that's exactly the approach I am taking. I've already got some examples, which I was going to get to :).
11:16:17 <metahumor> try to keep crazy operator syntax to a minimum
11:16:18 <EvanR> maybe submit your bullet points or a draft here and get feedback to temper it
11:16:21 <Habib> https://github.com/habibalamin/tests-vs-types
11:16:42 <Habib> (I know they're both necessary, but I couldn't think of another title)
11:17:16 <metahumor> off the get-go, string building is not the best example
11:17:25 <metahumor> because haskell doesn't do string interpolation nor multiline strings
11:17:26 <EvanR> tests vis a vis types
11:17:37 <metahumor> so it is definitely clunkier there than ruby
11:17:57 <akr> Hello, I have this piece of code that attempts to perform and catch all exceptions in server-side requests, but I think it's "leaking", in that sometimes it fails to catch errors if they happen too soon: http://lpaste.net/1651602130051530752
11:18:10 <akr> does anyone have any tips on how to fix/improve this?
11:18:14 <Habib> The string-building is incidental to the actual example. I expected my team to pick up on that, but didn't see anyone here commenting on that ;).
11:18:15 <EvanR> metahumor: ... however the string building TH libs
11:18:28 <jle`> Habib: hm, maybe try showing how types can make a huge set of unit tests redundant
11:18:34 <EvanR> or other value building TH libs, like binary numbers
11:18:47 <metahumor> Habib: also, type synonyms (type IncompleteQuery = String) won't prevent errors, since I can pass a value of type QueryParam for a value of type IncompleteQuery
11:18:59 <Habib> jle` that's exactly my plan. I've got two examples so far..
11:19:08 <Habib> metahumor that's not meant to prevent errors in this case.
11:19:14 <Habib> I don't want to overwhelm them.
11:19:16 <jle`> Habib: hm, maybe show how it can make a refactoring of a large codebase easy
11:19:20 <jle`> like making a field nullable/Maybe
11:19:29 <akr> ^^ I'm not sure if I should wrap the whole thing in a a handler, though maybe it would be for the best…
11:19:31 <jle`> and the compiler tells you everywher eyou have to change
11:19:34 <Habib> Each example will only focus on the exact type system safety features that I Want to demonstrate.
11:19:52 <jle`> Habib: oh, maybe also use typed holes to help guide your development of writing a simple function or procedure
11:19:54 <Habib> So the Maybe example will use type aliases instead of newtypes, just for simplicity.
11:20:03 <jle`> and how ghc tells you what sort of values go in holes
11:20:11 <jle`> with an API that has somewhat complex types
11:20:27 <jle`> i think that sort of dispells the counter-example that "types are there just for safety"
11:20:37 <jle`> when in fact types serve to help you write code faster
11:20:42 <Habib> jle` even I'm not that good yet. My goal is just to get them to see a hint of the power so that they are interested in learning more for themselves.
11:21:01 <metahumor> on the scope of refactoring wrt to Maybe, show how Maybe and Either Error would be interchangable?
11:21:10 <jle`> ah.  yeah, the 'point' is to show that types aren't just good for safety, but their main day-to-day benefit is helping you write code faster
11:21:18 <metahumor> Either ErrorMessage more exactly
11:21:20 <jle`> using typed holes to let ghc tell you what to put in what spot
11:21:28 <jle`> and so you can 'write programs without thinking'
11:21:28 <Habib> Yep, sounds like a good idea.
11:21:42 <Habib> jle` I've never used typed holes myself :).
11:21:51 <jle`> they're pretty amazing :O
11:21:55 <Habib> I'm still a beginner myself. I just want them to see the potential.
11:21:56 <jle`> they make writing code pretty automatic/a breeze
11:22:07 <Habib> I am aware of what they do, just never used them yet.
11:22:07 <jle`> it's the main reason why i can never code in python or ruby again
11:22:16 <jle`> "what value goes here?  compiler, can you tell me?"
11:22:19 <metahumor> if only this talk came out after 8.6, where you can "justdoit" everywhere
11:22:20 <jle`> compiler: ...
11:22:24 <Habib> lol
11:22:29 <EvanR> wait, many people write ruby code without thinking
11:22:30 <jle`> compiler: i play no role in helping you write your code
11:22:37 <EvanR> it supports that
11:23:17 <EvanR> no compiler errors really helps in that regard
11:23:27 <EvanR> doesnt interrupt the stream of consciousness
11:23:53 <jle`> catching errors at runtime instead of compiletime?
11:24:13 <jle`> Habib: it dispels two myths: (1) my programs are correct, so i don't need types (reality: types help with more than just correctness)
11:24:13 <EvanR> what im saying makes sense as long as you dont run the program
11:24:33 <ertes> is there a way to change the standard handles to a handle of my own?  like overriding stderr (ideally for the duration of a certain IO action) by something else
11:24:49 <jle`> (2) writing dynamic code is faster than writing statically typed code (reality: typed holes and static types help you write code faster than you could withd ynamic types)
11:24:58 <Habib> Haha, you guys are getting too excited. My only goal is to show them a ray of light.
11:25:13 <metahumor> Habib: a ray of light? you will shine as bright as the run
11:25:17 <metahumor> *sun
11:25:30 <jle`> yeah, those are just two arguments that i see people use to argue against static types, but they are pretty flawed
11:25:34 <ertes> (doesn't have to be portable…  i need it on linux during development)
11:26:09 <jle`> EvanR: ah yes, that's the best way to get rid of bugs :)
11:26:24 <Psybur> :t show _
11:26:25 <lambdabot> error:
11:26:25 <lambdabot>     • Found hole: _ :: ()
11:26:25 <lambdabot>     • In the first argument of ‘show’, namely ‘_’
11:26:38 <metahumor> ertes: https://hackage.haskell.org/package/system-posix-redirect-1.1.0.1/docs/System-Posix-Redirect.html
11:26:40 <jle`> Habib: undoubtedly those are two responses you might get from the audience
11:27:15 <Psybur> > show _
11:27:17 <lambdabot>  error:
11:27:17 <lambdabot>      • Found hole: _ :: ()
11:27:17 <lambdabot>      • In the first argument of ‘show’, namely ‘_’
11:27:36 <Psybur> How do you get it to show the expected type? :D
11:27:43 <Habib> I have raised that point about types making it faster to program and being your friend, not an obstacle. I've made the point that their experiences aren't with the best static type systems, so they shouldn't judge what static types can be based on their experience from Java, et al.
11:27:54 <ertes> metahumor: that's not quite what i'm looking for, but i found it already:  hDuplicateTo from GHC.IO.Handle
11:28:05 <ertes> metahumor: thanks!
11:28:31 <EvanR> :t show x
11:28:32 <lambdabot> String
11:28:42 <Psybur> > \x -> show _
11:28:44 <lambdabot>  error:
11:28:44 <lambdabot>      • Found hole: _ :: ()
11:28:44 <lambdabot>      • In the first argument of ‘show’, namely ‘_’
11:28:47 <Habib> I think asserting it is as far as I'll go for now. If I can get the gears turning in their head towards, “oh, that would have been really useful with that bug we had that one time” or “this would really help with this problem that keeps cropping up”.
11:29:10 <Habib> The first example is actually lifted mostly from a bug we actually had in production.
11:29:24 <Psybur> > f :: a -> a; f x = _
11:29:26 <lambdabot>  <hint>:1:12: error: parse error on input ‘;’
11:29:33 <EvanR> yeah i was expecting many specific examples
11:30:16 <metahumor> > :t let {f :: a -> a; f x = _} in f
11:30:18 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:30:18 <Habib> I still have some to go. If anyone has any examples of bugs they prevented (or could have prevented had they used the language) at work, please do share.
11:30:28 <Psybur> % f :: a -> a; f x = _
11:30:29 <yahb> Psybur: ; <interactive>:69:20: error:; * Found hole: _ :: a; Where: `a' is a rigid type variable bound by; the type signature for:; f :: forall a. a -> a; at <interactive>:69:1-11; * In the expression: _; In an equation for `f': f x = _; * Relevant bindings include; x :: a (bound at <interactive>:69:16); f :: a -> a (bound at <int
11:30:37 <metahumor> nice
11:32:06 <Habib> I wonder if the dirt cheap haskell consultancy would be good for this
11:33:12 <whoman> Habib: what where ? thats what i need to be doing, consulting
11:36:46 <akr> hmm, not sure if matrix ⇄ freenode bridge broken or EvanR having a monologue
11:36:59 <akr> anyway, I fixed my problem by just wrapping everything in a handler… if anybody can read this
11:37:21 <whoman> read[ed]\
11:38:04 <EvanR> akr: i am not sure what youre seeing but i think i have high lag right now
11:39:10 <akr> EvanR: I see lambdabot replying to no one… I guess that's not good
11:40:34 <MarcelineVQ> akr: there was a split, so relog if you suspect you're not on the same floor as everybody else
11:48:24 <ertes> not as simple as i hoped…  i can only duplicate duplex handles to duplex handles…  time to make rapid-term a bit more messy =/
11:50:14 <ertes> does `ghci -fexternal-interpreter` take much longer to boot for anyone else?
12:20:09 <msmorgan> I'm trying to build a package with profiling enabled, which depends on cheapskate
12:20:36 <msmorgan> however, `cheapskate.cabal` specifies invalid flags in ghc-prof-options
12:21:17 <msmorgan> Is there a way to override this?
12:36:28 <ancarda> Hi, Does anyone know how -Wsafe works? I tried building a small program with {-# language safe #-} but I only get "‘Main’ has been inferred as safe!". Could someone help me understand this warning?
12:38:34 <lts> I have a fxn defn as follows:
12:38:36 <lts>  take1 0 _ = []
12:38:38 <lts>  take1 _ [] = []
12:38:40 <lts>  bot = bot
12:38:42 <lts> I'm trying to figure out how pattern matching works - running `take1 0 bot` works as expected, it returns [] ; however, when I run `take bot []` it returns bot (i.e. doesn't terminate) ; shouldn't [] be returned in this case ?
12:40:06 <whoman> nah because bot is trying to eval
12:40:14 <whoman> which evals itself which evals itself which
12:40:37 <whoman> it looks like what you intend to do is better captured with types
12:40:43 <whoman> type constructor especially
12:41:08 <[Leary]> In order to determine whether or not it matches against the first line of the definition it needs to evaluate bot far enough to tell whether or not it's zero.
12:41:12 <whoman> as 'bot' is not an atom that we can use in the language as a literal object
12:41:46 <[Leary]> If you swapped the order of the lines it would terminate in the second case but not the first.
12:43:44 <lts> oh, right ; I guess i can now visualize what the prof is trying to say in the slides
12:44:44 <lts> [Leary]: so in the swapped version, it doesn't terminate in the first version because it tries to match bot with [], right ?
12:44:55 <[Leary]> right
12:45:04 <lts> I see, thanks
12:46:45 <lts> and in the original version (non-swapped), it again doesn't terminate because it tries to compare bot with _ ; cool
12:46:53 <bash0r> Is there a way to test for undefined other than catching the exception?
12:48:08 <dminuoso> I'd like some input. Ever since I rebuild my project with profiling flags, I cant produce a working binary anymore.
12:48:30 <dminuoso> The program runs awfully slow and seems to just "halt". Only profiling builds seem to function normally.
12:48:39 <dminuoso> Tried to `stack clean`, just dont know what else to do.
12:49:08 <dminuoso> `stack clean; stack build; stack exec my-program` produces a borked binary it seems.
12:49:29 <bash0r> dminuoso: rebuild your repository from remote might be an idea.
12:49:52 <dminuoso> bash0r: What do you mean?
12:50:35 <ertes> i have a solution, but you're not gonna like it =)
12:50:39 <bash0r> dminuoso: go to /tmp, make git (or whatever you use) download your project from remote again and then try to build it again.
12:51:13 <bash0r> ertes: it can't be worse than my suggestion.
12:51:58 <ertes> depends on how attached one is to their tools:  replace stack by new-build
12:52:26 <bash0r> ahh ^^ when reading about new-build I replaced stack immediately.
12:52:44 <dminuoso> ertes: Should I be bothered by the fact that it seems like nobody seems interested in Stack being unable to give me a working binary anymore?
12:53:14 <dminuoso> It almost sounds like "oh, nothing new"
12:53:15 <ertes> dminuoso: not too much…  but it is a solution
12:53:23 <dminuoso> ertes: Heh.
12:54:23 <ertes> but stack seems to be much much heavier on state than new-build…  one of the main goals of new-build is to be stateless the same way nix is
12:54:34 <ertes> if you give the same build options, you get the same result
12:55:46 <dminuoso> bash0r: Interesting, it's still broken.
12:56:36 <bash0r> dminuoso: that's interesting for sure. Looks like stack has a lot more state than it shows to the outer world. Wanna try new-build? :p
12:56:36 <cocreature> dminuoso: what exactly does “borked” mean in your case?
12:56:43 <lijero> ertes: what is new-build? never heard of it.
12:57:08 <ertes> lijero: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
12:57:12 <cocreature> ertes: I’d say the versions of all your packages are quite a lot of state :)
12:57:32 <dminuoso> cocreature: so putStr starts to print a few lines, visually coming to a halt in the middle. And that's it.
12:58:03 <cocreature> dminuoso: and then the binary hangs or crashes?
12:58:03 <dminuoso> The second I switch to `stack build --profile` and run it with `+RTS -p` it works like regular.
12:58:07 <dminuoso> cocreature: it just hangs
12:58:22 <bash0r> dminuoso: or try to clean your local stack cache. That might help, too.
12:58:55 <cocreature> dminuoso: are you building with optimizations?
12:59:14 <ertes> cocreature: that's not state, it's dependencies…  you wouldn't call the sine function stateful, because its result depends on its argument, would you?
12:59:59 <cocreature> ertes: the sine function doesn’t try to figure out its own input. cabal does try to figure out the version of the dependencies it uses
13:00:18 <ertes> cocreature: that amounts to implicit parameters, not state
13:00:31 <bash0r> ertes, cocreature: stack's cache is the state. Not the dependencies.
13:00:39 <dminuoso> cocreature: Nope. The thing is, it worked just fine - until I made the profiling build.
13:00:48 <dminuoso> From that moment on my non-profiling build was broken.
13:01:09 <dminuoso> Didn't change a thing to any part of the project.
13:01:12 <[Leary]> No lts, the nonterminating cases are where it tries to match bot against 0 or []. bot matches against _ without need for evaluation and without having a name bound to it, so it's this case precisely where it cannot have any effect.
13:01:20 <[Leary]> Ah, too late.
13:01:38 <dminuoso> bash0r: Alright some good options. Until I try them, Id like to keep it in this situation to facilitiate debugging if necessary.
13:02:15 <bash0r> dminuoso: I hope it helps. :)
13:02:16 <cocreature> ertes: that seems like a fairly arbitrary distinction.
13:02:47 <ertes> cocreature: it isn't…  nixpkgs does literally functions and implicit arguments, and new-build is modelled after it
13:03:41 <cheater> hi
13:03:48 <ertes> that's why you won't see the same kind of failure with new-build, unless you use unsafe hacks, or new-build has a bug
13:04:00 <cocreature> well the above sounds very much like a stack bug
13:04:17 <cheater> i heard people use the haskell type system to encode programs that should execute at compile time. why is that done, and how does that work?
13:04:18 <ertes> yeah, that's true
13:04:32 <cocreature> so I don’t think this is an example that demonstrates that stack is more stateful than cabal
13:04:47 <dminuoso> ertes: The description sounds.. intriguing. I like reproducible things.
13:04:50 <cocreature> anyway, this discussion is not particularly productive, so I’ll stop here
13:04:57 <dminuoso> ertes: In bugs and in software.
13:05:08 <bash0r> cheater: it's done to achieve safer code. For example, you can encode a list to carry its length in the type. You cannot do tail [] on such a list implementation.
13:05:14 <cocreature> dminuoso: if nothing else helps maybe try nuking the snapshot directory
13:05:27 <ertes> cocreature: sure…  please don't let me stop you from helping dminuoso though =)
13:05:41 <bash0r> cheater: What you are looking for is called dependent typing. It's basically lambda calculus / logic calculus.
13:05:52 <ertes> cheater: sometimes it's done to achieve static guarantees, sometimes it's done to attach run-time information to *types* rather than values
13:06:23 <bash0r> cheater: Think about types with parameters as "type functions". When you apply an Int to Maybe then you get "Maybe Int".
13:06:50 <cheater> bash0r: that's not what i'm talking about, not dependent typing, but more like, eg i saw people would create hash maps at type level? why would you do that?
13:07:04 <dminuoso> cheater: Are you thinking about type families/gadts perhaps?
13:07:13 <cheater> a use of them, yes
13:07:21 <ertes> cheater: an example of the latter kind is called implicit configurations…  for example the following code snippet uses a number field to compute the fibonacci formula: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
13:07:33 <amalloy> cheater: for a particularly silly example you might enjoy https://aphyr.com/posts/342-typing-the-technical-interview
13:07:40 <cheater> i know what gadts and tf's are, and how they're used, but i'm more concerned with why people would do very involved programs at the type level
13:07:53 <bash0r> cheater: a hash map at type level is dependent typing. Maybe they speed up lookups with it.
13:09:16 <cocreature> bash0r: no it’s not. dependent typing is types depending on values. just having a hashmap at the type-level doesn’t mean that the types depend on values.
13:09:30 <cheater> i mean like here
13:09:32 <cheater> https://ghc.haskell.org/trac/ghc/ticket/12506
13:09:54 <ertes> cheater: an example of the former kind uses types to prove that 'filter' only returns list elements that are proven to match the predicate (it's heavily commented): http://lpaste.net/109388
13:10:02 <cheater> https://github.com/deech/Trac12506
13:10:04 <cheater> this specifically
13:10:11 <hyperisco> I don't think file paths are a lattice… what is the join of /var/log and /var/www ?  / ≤ /var ≤ /var/log
13:10:21 <cheater> why would you use code like this? what practical use does it serve?
13:10:28 <cheater> i want to understand where i can apply this technique
13:10:38 <amalloy> cheater: mostly that isn't done. it's not impossible, but people who go nuts with compile-time programs usually do it because it's a novel challenge
13:11:16 <cheater> when you take away the novelty, there must be some form of utility for this
13:11:19 <hyperisco> cheater, it is the only thing that matters when programming, only people are used to keeping most of it in their head, or used to forgetting most of it
13:11:22 <cheater> i am trying to figure out what that is
13:11:41 <bash0r> cocreature: so you argue that the resulting hash map is not a type anymore just because it's a value lifted to type level?
13:11:56 <ertes> cheater: to be honest: if you don't know where to apply it, don't apply it…  you're going to learn this eventually…  but if you really want to drop yourself in that rabbit hole, your first search term is "curry-howard correspondence"
13:12:12 <hyperisco> but, file paths are a meet-semilattice for sure
13:12:16 <cheater> i'm not looking for reasons why this is a bad idea - or criticisms of the idea. i'm also not trying to force this idea into code i'll be writing in haskell. i am writing a toy programming language and want to see if i can let it do similar things.
13:12:18 <ertes> s/rabbit hole/rabbit hole immediately/
13:12:22 <cocreature> bash0r: no I argue that you can have arbitrary complex types and perform calculations on those at compile-time and it is not dependent typing until those types depend on values.
13:12:46 <bash0r> cocreature: okay, I'm misusing the term.
13:12:49 <cheater> ertes: that's not what i'm looking for. i am looking to find out why some people want this sort of thing, to play around with the idea and see if it's useful to me
13:12:59 <hyperisco> relative paths are, anyways
13:13:36 <cocreature> bash0r: I get where you’re coming from but dependent typing has a reasonably precise definition and I don’t think it’s helpful to call anything that is somewhat complex and involves types “dependent typing”
13:13:42 <ertes> cheater: one really simple use case is length-indexed lists:  lists, where the length is statically known…  the utility is that some functions that used to be partial are now total
13:13:46 <MarcelineVQ> cheater: it is pretty likely what your looking for. proving how your types behave proves how your values behave. having hashmaps entirely in the type system means your hashmap values are correct, otherwise they don't typecheck
13:14:06 <cheater> ertes: that's dependent typing. we've already established that this isn't what we are talking about.
13:14:21 <ertes> cheater: you can safely and totally use 'head' on such a list, if the length (that is known at compile-time now) is at least 1
13:14:25 <cheater> MarcelineVQ: can you expand on this a bit?
13:14:32 <ertes> cheater: you don't need dependent typing to do this
13:14:38 <ertes> you can do it in haskell
13:14:39 <MarcelineVQ> cheater: ertes is doing this currently :>
13:15:30 <cheater> ertes: yeah, by constructing natural numbers, but that's still a form of dependent typing i guess
13:15:40 <ertes> cheater: nope
13:15:42 <cheater> there must be more involved ideas than a fixed length list
13:16:00 <cheater> let's look at the code i posted - this is fairly involved - why is he doing this? https://github.com/deech/Trac12506/tree/master/src
13:16:17 <ertes> cheater: well, using singleton types a database API can demand a proof for access privileges, before it will return a document
13:16:22 <ertes> cheater: same technique
13:17:11 <hyperisco> cheater, 99.9 something percent of facts you know about your program are unchecked by the compiler, yet you depend on most of them for your program to work
13:17:28 <ertes> cheater: length-indexed lists are really just the simplest example to learn how it works, and then you can move on to use it in your application for many other things
13:17:38 <hyperisco> cheater, the question isn't what the use is… the question is how we manage to survive without it
13:18:52 <bash0r> cocreature: I get what you mean. :)
13:20:02 <dminuoso> cocreature: Let's assume that nuking my snapshots directory had no effect..
13:20:47 <dminuoso> This is getting bizarre..
13:21:18 <EvanR> ertes: unfortunately that example is usually where the examples stop
13:22:16 <ertes> well, i've linked two more examples, one for singletons, one for reflection =)
13:22:41 <EvanR> singletons is a means right, not an ends
13:23:08 <EvanR> you wouldnt want singletons if you had dependent types
13:25:04 <cheater> can someone tell me if i understood this code correctly? what he does here is he creates a hashmap of types (by nesting data types) and then has a way of searching for a specific type inside that hash map. is that correct? https://github.com/deech/Trac12506/blob/master/src/TypeFunctions.hs
13:25:50 <ertes> of course, singletons are really just a hack
13:25:56 <ertes> and a super-ugly one at that
13:26:09 <dminuoso> What else can I nuke? Stack is really.. persistent.
13:26:28 <ertes> dminuoso: stack =P
13:26:31 <ertes> SCNR =)
13:26:43 <bash0r> ertes: lol, didn't want to write it.
13:27:23 <dminuoso> This is so mega bizarre..
13:28:10 <ertes> dminuoso: i don't know where stack stores its state, but if i would have to guess, it would be somewhere in ~/.local
13:28:14 <Bowlslaw> got my copy of Rudin's "Principles"!
13:28:23 <Bowlslaw> love me some old school, rigorous math books
13:29:51 <lijero> ertes, dminuoso: ~/.stack
13:29:54 <MarcelineVQ> ertes: in the local project it's .stack-work/  otherwise there's  ~/.stack/snaptshots ~/.stack/programs ~/.stack/precompiled and other applicable ~/.stack/*
13:30:01 <MarcelineVQ> dminuoso: why are you nuking stack?
13:30:45 <dminuoso> MarcelineVQ: Ever since I produced a build with profiler enabled, the same project no longer functions properly without the profiling flags. The program crawls into a halt and stalls in the middle.
13:30:51 <dminuoso> When running with profiling enabled, all is good.
13:31:07 <ertes> dminuoso: i'd also look in /tmp, ~/.cache and ~/.local
13:31:11 <MarcelineVQ> ah, that's common, profiling cost centers cause different ammounts of evaluation iirc
13:31:14 <dminuoso> I've nuked the stack local .stack-work, moved to a new directory, nuked ~/.stack/snapshops
13:31:29 <MarcelineVQ> they can at least, common might be an incorrect thing to say
13:31:38 <dminuoso> MarcelineVQ: It's common that a _regular_ build stops working?
13:31:47 <MarcelineVQ> I thought you said that was with profiling off earlier though?
13:32:03 <MarcelineVQ> oh I see, I'm skipping words, pardon me hehe
13:32:24 <ertes> dminuoso: are you sure you're building the same code?  you haven't introduced a leak while profiling?
13:32:46 <dminuoso> ertes: Yes. The thing is, the second I rebuild with profiling flags the program works.
13:33:31 <bash0r> dminuoso: at this point I'd try to use new-build. If it works then you know that you will never ever use stack again.
13:33:38 <ertes> dminuoso: does it work with new-build?
13:33:53 <ertes> dminuoso: (just run 'cabal new-build' in your project dir)
13:36:19 <cheater> i have another question too if that's ok
13:37:28 <bash0r> cheater: just ask.
13:37:28 <ertes> cheater: just ask…  haskell-related questions are always ok
13:37:53 <cheater> when you write a normal program, it executes after compilation. what would be involved in making a language such that e.g. those type-level programs - that execute before compilation is done, essentially "compile time programs" - to be written in the same language as the "run time language"?
13:38:06 <cheater> it's not a haskell question, it's a general programming language question
13:38:06 <dminuoso> ertes: Okay that will take a moment. I think I have to install the haskell platform then
13:38:21 <ertes> cheater: dependent types
13:38:33 <bash0r> cheater: have a look at Idris or Coq.
13:38:39 <ertes> dminuoso: all you need is GHC and cabal-install
13:39:26 <ertes> cheater: the difference between haskell's type system and a dependent type system is that the type and value levels are collapsed into a single level
13:39:29 <dminuoso> ertes: Ah great, I can grab those from homebrw :)
13:39:56 <ertes> dminuoso: be sure to install cabal-install 2.0
13:40:10 <ertes> (or later)
13:40:11 <bash0r> cheater: Haskell's singletons package allows something similar - though it's not the same.
13:41:15 <ertes> cheater: haskell is at a point where there are only two levels: values and types…  in standard haskell you still have an infinite hierarchy (values, types, kinds, …), but if you enable the TypeInType extension, then all levels higher than values are collapsed into a single type level
13:41:35 <ertes> cheater: to make haskell dependent, we would have to collapse those remaining two levels into one
13:41:58 <ertes> and that involves getting rid of the separate type language
13:42:19 <bash0r> ertes: do you think that will ever happen?
13:42:41 <cheater> why are idris and coq good examples of this?
13:42:59 <bash0r> cheater: because they implement what you are asking for. ^^
13:43:05 <ertes> bash0r: not sure…  GHC development is clearly headed in that direction, but i don't know if it will ever be practical
13:43:14 <ertes> cheater: they are dependent
13:43:41 <cheater> ertes: why must that mean dependent types though?
13:43:52 <cheater> what we're really looking for is the ability to provide types from values
13:43:56 <ertes> cheater: because that's basically what dependent typing is =)
13:44:07 <bash0r> ertes: would be awesome to see dependent Haskell.
13:44:13 <cheater> values that are executed with types as parameters and as return values
13:44:30 <cheater> i.e. something like foo :: Type -> Type -> Type
13:44:36 <cheater> that's not dependent typing
13:44:52 <cheater> I don't need foo to interact with values
13:44:54 <ertes> bash0r: not sure about that either…  if we ever get dependent haskell, it will probably be really awkward to work with…  or it will be completely backwards-incompatible
13:45:27 <cheater> foo is a value, but in itself it does not, actually, make the world of types and world of values interact
13:45:39 <bash0r> cheater: in Idris and Coq there is no difference between values and types. You can apply your foo on value and type level.
13:45:39 <ertes> cheater: dependent typing = using the same language for types and values + enabling communication between the levels…  strictly speaking you need only the former
13:45:40 <cheater> it's just a computation that does something strictly in the world of types
13:45:59 <cheater> ertes: yes, only the former, not the latter
13:46:23 <MarcelineVQ> foo :: (x :: Type) -> Type -> Thing x Type
13:46:25 <bash0r> ertes: I don't have a problem with a break in backwards-compatibility.
13:46:45 <ertes> cheater: i'm not sure whether you can have the former without the latter though
13:47:04 <ertes> bash0r: you will have, once you realise that hackage is gone =)
13:47:08 <MarcelineVQ> hmm, I ​meant to have something more interesting for x,  foo :: (x :: Nat) -> Type -> Thing x Type
13:47:12 <ajuhasz> :q
13:48:02 <ertes> cheater: you certainly need both, if you want to prove anything
13:48:34 <bash0r> cheater: If you don't need values on type level then why not just data MyType a b c = ...?
13:49:24 <bash0r> cheater: or type MyType a b c = ... or with type families or whatever feature of Haskell you intend to use.
13:50:12 <ertes> same language would enable us to write:  MyType :: Type -> Type -> Type -> Type;  MyType a b c = …
13:50:18 <ertes> complete with pattern-matching, etc.
13:50:51 <ertes> in fact we would have to write it in lower-case =)
13:51:14 <dminuoso> ertes: There we go.
13:51:22 <dminuoso> Stack on its way to the moon.
13:51:41 <ertes> dminuoso: so it worked with new-build?
13:51:42 <ongy> Can I use ghc (the library) to compile Haskell at runtime, that I can call into from compile code/can call into my compiled code?
13:52:15 <dminuoso> ertes: Yes. In fact my weird console problem is gone too!
13:52:24 <tommd> ongy: Yes. See `hint` and `plugins`
13:52:37 <ertes> dminuoso: great…  consider reporting a stack bug though
13:52:50 <bash0r> ertes: the Hackage problem can be solved with a Haskell (current) => Haskell (future) transpiler. Problem solved.
13:52:50 <ertes> (or two as it sounds)
13:53:41 <dminuoso> ertes: the console thing is probably not stack related, its probably due to the different compiler
13:54:13 <ertes> bash0r: i wouldn't mind a backwards-incompatible language, as long as i can still access regular haskell libraries…  it would be a massive change though, and adoption would be very slow
13:54:39 <dminuoso> ertes: But boy. With 8.2.2 my automaton is _ridiculously_ fast.
13:54:44 <dminuoso> :o
13:54:56 <ertes> bash0r: in other words: be prepared to wait a couple of years before we even see this on the horizon
13:55:03 <ongy> tommd: thx
13:55:44 <bash0r> ertes: as you stated, if there's only a single level then names of functions and names of types are the same. So we need to work around the upper / lower case issue.
13:56:12 <ertes> dminuoso: yeah, i noticed minor speedups, too…  nothing massive though (most of my code isn't too CPU-heavy)
13:56:16 <bash0r> dminuoso: hehe, GHC 8.2.2 has some awesome optimizations enabled, yes.
13:57:24 <dminuoso> ertes: Well thats in comparison with 8.0.2
13:57:47 <ertes> i'm kinda excited to see if 8.2 has any concurrency-related optimisations =)
13:58:23 <dminuoso> If only my stack build was working, I could tell you the factor..
13:58:25 <dminuoso> heh
13:58:41 <tommd> ongy: I used hint to make a stand alone compiler for ivory (google site:github.com ivory hint) and make bots for the ninjas game (site:github.com ninjas hint)
13:59:05 <ertes> i believe new-build tracks the compiler as well, so just install 8.0 and run new-build again
13:59:06 <tommd> ongy: It's actually quite a fun way to make a stand-alone compiler or extension for a shallow dsl.
13:59:10 <ertes> dminuoso: ^
13:59:21 <ongy> he, that sounds pretty cool :)
14:00:01 <ongy> tommd: do you know if it works with new-build? :) On a first glance, I feel like I willh ave to wait for that to be supported
14:00:42 <tommd> ongy: I don't fully understand the question.  new-build is a cabal concept and hint is really a binding to the ghc api - totally unaware of cabal.
14:01:13 <ertes> ongy: as an alternative i prefer the "unix way": separate process + IPC (via sockets/pipes/sqlite, whatever is most appropriate)
14:01:32 <bash0r> tommd: when googling site:github.com ivory hint the first result is a PHP library.
14:01:47 <ongy> tommd: new-build has the fancy cache that works better than the ghc global one. And there should be some way to use that
14:02:20 <tommd> bash0r: https://github.com/GaloisInc/ivory/pull/38
14:02:58 <tommd> We never merged it because someone, who will remain nameless but not blameless, said they were going to make a stand-alone syntax/lexer/parser/compiler to avoid the tight haskell integration.
14:03:56 <bash0r> tommd: thank you very much.
14:03:57 <tommd> ongy: Yes, I'm aware and I also know it uses the .ghc*environment* files. Not sure how those are used (or if they are used) by the ghc-api and thus hint.
14:04:10 <dminuoso> ertes: How are ghc versions managed in this setup? Does cabal have the ability to pick different GHC versions like stack? Or is it my job to install the GHC version I want?
14:04:16 <bash0r> I think the GHC is an awesome compilation backend. Why struggle with code generation? I don't get it.
14:04:20 <dminuoso> And by pick I mean install.
14:04:38 <ongy> I think I will look deeper into it once new-install actually works for local packages. I can wait for now
14:04:51 <ertes> dminuoso: it's your job, but new-build tracks the compiler (it's kind of a package dependency), so you don't need to worry about mixed builds
14:05:39 <ertes> dminuoso: if you have an easy way to install multiple compilers, you can switch between them by writing a cabal.project file, i believe (or by using new-configure)
14:05:42 <ongy> ertes: I want to play around with loading arbitrary functions at runtime, that can then be used as keybinds with access to my state monad. Not exactly something I can do over IPC :( (unless I define waaaay more than I want to into the IPC protocol)
14:05:44 <bash0r> dminuoso: if you look into dist-newstyle then you will find a subdirectory with GHC version and your machine architecture.
14:06:16 <dminuoso> Ah I see, bash0r.
14:07:03 <ertes> ongy: if you would do it over IPC, it would be a form of RPC…  it's definitely more work than hint, but not too much, and i find it a bit more robust as a design
14:07:25 <ertes> ongy: (as a minor bonus, the coprogram doesn't have to be written in haskell)
14:07:45 <ertes> so you can get python fanpeople to use your program =P
14:08:38 <bash0r> The question stands if you want those people to use your program.
14:09:10 <ertes> ongy: BTW, RPC can be a matter of communicating lists of strings…  you don't need to implement a separate "RPC call" for each function you want to abstract over, but simply one call with a string holding the function name
14:09:30 <ongy> ertes: I doubt it's easy to define an RPC that can handle pointers from libraries FFI'd into without defining every single fucntion for the RPC. which would be a lot of hassle. And hardly extensible when there are new functions in the core
14:10:34 <ongy> that only works if my entry point on the server has every function in scope, or every function registers itself with it over some way, containing argument parsing
14:10:36 <ertes> ongy: yeah, as i said, it's more work
14:11:07 <ertes> it's a trade-off:  more work for a more flexible design
14:11:41 <ongy> more work for a less flexible design
14:12:14 <ertes> at the very least you would have to translate every possible function into a serialised form (doesn't have to be a string – it can directly correspond to the function pointer or a stable name)
14:13:10 <ertes> no, it's more flexible…  you can do everything you want to do (→ at least as flexible), plus there is no hard requirement for the plugin to be written in haskell (→ more flexible)
14:13:20 <ertes> but it's more work:  RPC + process supervision
14:14:36 <bash0r> Why does attoparsec return a continuation in Partial :: IResult? It could implement derivatives... I don't get it.
14:14:40 <ertes> oh, and the plugin doesn't have to be installed locally, which is a huge bonus, if you do anything with containers or virtual machines, or if you want to run multiple CPU-heavy plugins =)
14:15:13 <ertes> bash0r: derivatives?  as in zippers?
14:16:44 <bash0r> ertes: I don't know anything about zippers. I mean something similar to Parsing with derivatives by Matt Might
14:17:18 <ertes> ah, not familiar with that, but chances are that attoparsec simply predates it
14:17:49 <ertes> do you have a link?
14:20:27 <ongy> ertes: No. It forces me to list every function explicitly that's intended to be used that way. Which is already reason enough to not consider it viable
14:21:53 <bash0r> ertes: http://matt.might.net/articles/parsing-with-derivatives/
14:23:56 <bash0r> ertes: https://github.com/aka-bash0r/cps-derivatives proves at least that it's possible to create a derivative with a CPS transformed parser that works on chunks. I think I did not get semantics correct with (<|>), Though, I'm working on a reimplementation with ByteString's where semantics of (<|>) should be correct. Look at the paper-draft branch.
14:24:50 <dminuoso> ertes: I no longer understand whats happening. With cabal new-build and 8.0.2 it breaks again.
14:24:58 <ertes> ongy: sure…  you might find distributed-process interesting, because it solves that issue to some degree…  personally i prefer to write the list by hand right now (it's a 1:1 correspondence to an ADT anyway, and i could employ something like 'boomerang' to automate the translation)
14:25:12 <bash0r> dminuoso: maybe it's just 8.0.2 that's broken for your use case.
14:25:25 <ertes> dminuoso: so not a stack bug after all…  you're probably relying on an optimisation that doesn't exist in 8.0
14:25:40 <ertes> dminuoso: or perhaps some dependency is broken with 8.0
14:26:15 <ertes> bash0r: thanks
14:26:56 <bash0r> ertes: no problem :)
14:27:06 <ertes> bash0r: before i read further: is this limited to CFGs?
14:28:02 <bash0r> ertes: first-class derivatives are intended to support Haskell-/Python-like syntax. Stuff like Markdown is possible, too.
14:29:35 <ertes> bash0r: what's the advantage?
14:29:38 <bash0r> So it's far ahead of CFGs. Current research restricts itself to some subset due to performance implications of the non-deterministic nature of derivatives.
14:30:19 <bash0r> You can parse whitespace indentation directly without a separate lexer + preprocessor step which breaks composability.
14:30:49 <ertes> bash0r: so it supports better parsing APIs?
14:31:14 <bash0r> ertes: exactly
14:31:37 <ertes> bash0r: and how does that relate to attoparsec having a continuation in IResult?
14:31:44 <bash0r> ertes: try to implement a Markdown parser. I guess you will kill yourself before you finished.
14:32:17 <bash0r> ertes: If attoparsec returned a parser instead of the continuation than that parser would be the derivative.
14:33:07 <bash0r> ertes: https://github.com/aka-bash0r/cps-derivatives/blob/paper-draft/artifact/src/lib/Text/Coalgebraic.hs#L135
14:33:27 <ertes> bash0r: ah, i see…  well, it could do that…  i think the only real reason for a separately typed continuation is efficiency…  a parser is heavier than the continuation of an IResult
14:33:38 <bash0r> It's kinda ugly syntax, to be honest, due to lack of proper abstaction of the three continuations for success, partial and error.
14:35:02 <ertes> bash0r: attoparsec doesn't even use the most efficient design (see trifecta)…  church encoding supports having the same efficiency without a separate result type
14:35:22 <bash0r> ertes: the Parser type of every efficient parser combinator library I've seen is a newtype around a function which itself could be the continuation. So I guess it has to do with the types more than with performance.
14:35:30 <ertes> (note: trifecta is probably slower than attoparsec, but it does use a more efficient internal design)
14:36:12 <bash0r> ertes: I use a church encoded result type similar to attoparsec. But you need to use runParser to invoke the continuation.
14:36:26 <ertes> bash0r: no, i'm pretty sure it's performance…  IResult is the type of a kind of mini-parser that doesn't support composition
14:36:38 <ertes> bash0r: attoparsec is not church-encoded
14:36:54 <bash0r> ertes: yes, I meant that mine is church-encoded. :)
14:37:00 <ertes> ah, ok =)
14:37:03 <two> YO CHECK OUT EFNET NEWS - Jason Bandy - EFNet News - Episode 54 - RIP #/JOIN AND FUCK FREENODE - https://youtu.be/fTsDFt1Hk_o IN VIDEO NOW
14:38:07 <ertes> bash0r: anyway, i'll have a closer look at this, when i need another parser…  right now my brain is busy with concurrency/sqlite stuff =)
14:38:47 <bash0r> ertes: I'll let you know when I release a more efficient reimplementation. ;)
14:39:22 <xacktm> go away spammer
14:40:05 <dminuoso> ertes: the thing is.. I didnt change anything
14:40:10 <dminuoso> It was working with 8.0.2 before.
14:40:24 --- mode: ChanServ set +o glguy
14:40:24 --- mode: glguy set +b two!*@*
14:40:24 --- kick: two was kicked by glguy (offtopic)
14:40:47 --- mode: glguy set +b-b *!*@185.121.168.22 two!*@*
14:40:49 <dminuoso> ertes: Right now Im beginning to think there's something funky going on.
14:40:59 <ertes> bash0r: thanks…  although i rarely need to parse anything other than JSON or YAML, so i'm not really your target audience =)
14:41:36 <ertes> dminuoso: maybe you inadvertently changed something while profiling?
14:41:57 <bash0r> ertes: YAML is whitespace indented AFAIK. So you are my target audience. :p
14:42:09 <ertes> bash0r: no, the author of the 'yaml' library is =P
14:42:15 <dminuoso> ertes: not in the project itself, git agrees with me
14:42:26 <bash0r> ertes: okay, okay. You're right. ^^
14:42:47 <bash0r> dminuoso: some dependency on the system?
14:43:17 <ertes> bash0r: to be honest i'm so lazy i'd more likely just use some existing code to translate whatever format i don't want to write a parser for to a format that i already have a parser for =)
14:44:07 <dminuoso> bash0r: No.
14:44:36 <ertes> dminuoso: maybe the parameters changed?  some input file, some environment variable, …?
14:44:59 --- mode: glguy set -q unquiet!*@*
14:45:59 <bash0r> ertes: don't reinvent the wheel, of course. ^^
14:49:28 <bash0r> Gotta go. Have a nice day / evening!
14:51:28 <jle`> is there a package for generics-based diffing of adt's ?
14:51:53 <jle`> hm there's gdiff
14:52:53 <ertes> bash0r: i'm actually quite keen on reinventing wheels…  comes with my fierce rejection of golang and python
14:53:31 <jle`> i mean, we're in #haskell after all :)
14:56:35 --- mode: glguy set -o glguy
15:12:53 <gbw> I have a type family question: can someone take a look at this http://lpaste.net/7434715361494171648 and let me know what i am doing wrong
15:13:17 <gbw> i somehow need to make this work:  _rappend :: Rec Identity (ToOuts as) -> Rec Identity (ToOuts bs) -> Rec Identity (ToOuts (as ++ bs))
15:18:22 <fishythefish> _rappend begins with _, so GHC thinks it's a typed hole
15:21:57 <ertes> gbw: using identifiers beginning with '_' is fine, but if you use one that is not in scope (yours is commented out), then what fishythefish said
15:23:04 <gbw> that was on purpose to highlight the error: I have no idea what to put in there for _rappend
15:23:13 <gbw> sorry for the confusion
15:23:41 <fishythefish> oh, you asked about what you were doing wrong, so I assumed this was code you believed to be complete
15:23:53 <fishythefish> (the other obvious answer is that you have no definition for _rappend)
15:24:08 <gbw> further down it shows the error
15:25:05 <gbw> essentially i know that 'as' is ToOuts as is 'bs' but I cant figure how to let the compiler know that as++bs is also ToOuts
15:25:31 <gbw> i guess i need some sort of proof or coercion or something: anyway that's as far as i got
15:25:44 <EvanR> would as++bs be ToOutsToOuts
15:25:50 <EvanR> it not
15:26:46 <gbw> yes. it would be nested which is not what i want
15:27:47 <danilo2_> Hi guys! Thanks to data kinds we can use promoted constructors on type level. We've got `':` there, but its not
15:28:18 <danilo2_> Hi guys! Thanks to data kinds we can use promoted constructors on type level. We've got `':` there, but its not "constructor", its just operator. So we cannot use it not fully-applied. Is there also a constructor version of it?
15:28:54 <glguy> danilo2_:   '(:)
15:29:10 <danilo2_> glguy: nope
15:29:16 <danilo2_> or hmm
15:29:28 <danilo2_> oh!!!
15:29:39 <glguy> ' goes outside the ()
15:29:43 <danilo2_> glguy: thats so bizarre
15:29:46 <danilo2_> but it works
15:29:48 <danilo2_> thank you!
15:59:46 <buttbutter> I know this doesn't compile, but is there any way to do something similar to do this/make it not shit? http://lpaste.net/362844
16:03:03 <amalloy> buttbutter: it's tough without knowing what Moi is. it looks like the same thing as State?
16:03:35 <buttbutter> It is :)
16:03:39 <buttbutter> Just a silly exercise to define it myself
16:04:10 <amalloy> i think you need to remove the second where clause, and put its definitions into the first where clause
16:04:20 <olligobber> ^
16:04:23 <amalloy> as you've written it, s' and a are local to the definition of s''
16:05:11 <buttbutter> Can you bind variables from lambdas in where clauses?
16:06:06 <olligobber> you can do a = s where s = \x.b; b = 1
16:06:15 <olligobber> I mean \x->b
16:07:06 <EvanR> its not clear what binding variables from lambdas in a where clause means
16:10:38 <buttbutter> http://lpaste.net/362845
16:10:40 <buttbutter> That's what I came up with
16:11:02 <buttbutter> That compiled. But maybe there's a nicer way.
16:17:40 <EvanR> http://lpaste.net/362846
16:18:58 <buttbutter> EvanR: That is nicer :P
16:19:03 <EvanR> but all the fst and snd, you could save yourself the pain with more pattern matching... http://lpaste.net/362846
16:19:59 <EvanR> of course i had haskell job reject me because they dont like my style so your milage my vary
16:20:17 <buttbutter> Oh right, of course.
16:21:06 <buttbutter> Been writing python for the last week to the detriment of my haskell :(
16:21:33 <EvanR> i love it when haskell code collapses under the strain of extraneous code :)
16:23:05 <buttbutter> :D
16:23:05 <buttbutter> (although python supports pattern matching for tuples but let's not talk about that :P )
16:23:05 <EvanR> like, a destructing assignment?
16:23:05 <buttbutter> Yeah
16:23:05 <buttbutter> ..I think?
16:23:05 <buttbutter> I dunno. I barely know it. I hate python.
16:23:05 <buttbutter> Thanks for your help!
16:26:49 <Eduard_Munteanu> Speaking of jobs, is there a nice website for Haskell-related freelancing?
18:27:11 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
18:27:11 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
18:27:11 --- names: list (clog Guest71 dmwit kuttifunk uuplusu mekeor jmcarthur kadoban enterprisey eschnett PatrickRobotham coot acarrico pjan sword865 XorSwap philosaur pplorins cchalmers oisdk pangwa Tops21 MissingNoIOI HaskellLord69 Patternmaster zwarag__ xkapastel emilypi ericsagnes _ashbreeze_ conal rcdilorenzo ammazza ninedotnine thaumavorio safe sim590 SenasOzys alxgnon1 byt dolio buttbutter jimmyrcom ekrion cjwelborn SCHAPiE sqooq giraffe mkoenig lagothrix gbw AndreasK pera)
18:27:11 --- names: list (pavonia jorj Lowl3v3l hvr genericpseudonym shatriff hiratara prototrout okuu siiky leitec Deidde kerrhau avocado yiannis_t hegge albel727 Eliel davean saftsuse joeytwiddle ij ernst Paks pdxleif fergusnoble catern mitchty c_wraith Burnout641_ lyxia edran geal syamaoka tek0_ jackhill Squarism DwarfMaster deu lieven xxpor_ sns Novitsh so n3parikh karls henrytill joeyh absence Cheaterman monte stefan- cesardv Xnuk Yaiyan emmflo _cyril_ ahf_ xa0 kshannon dschoepe)
18:27:11 --- names: list (Willis michalrus adamCS gilbertw1 ccase bsmt ynyounuo navilan- Deewiant sunya7a ijp Eagle_Erwin tinco lpvb lassulus Hafydd Zemyla relrod paroxp cynick atomi wting janne- Fylwind- capisce gothos gsingh93 RevJohnnyHealey fiddlerwoaroof eagleflo nille HalfEatenPie jonge SuprDewd lugh akemot hackage tomaw mak` rom1504 Zoddo carc ggVGc nullie crooked fiatjaf electrocat aidecoe valkyr2e kipras deni ralu DDR Zowlyfon pyrtsa obiwahn huaw Ke cheshircat Nikotiini)
18:27:11 --- names: list (int0x27h mrd amuck dumptruckman MasseR bjobjo Flonk Jonno_FTW ichigo abra0 quicksilver wrengr_away japesinator beaky EvanR zekt sdrodge dh sqrt2 Jon integral zymurgy Forkk barrucadu solatis datajerk tabaqui1 Axman6 x-n2o dqd mt Meanirelli nek0 ps-auxw comboy jw358 stux|RC ftop greymalkin mjrosenb saurik ljhms jtcs implementation xintron_ Spritzgebaeck tctara Blkt Wesleysld keyking brent80_plow Warrigal vodkaInferno magicman ManiacTwister supki __name__ wz1000)
18:27:11 --- names: list (kmae keri ramatevish wagle hpc d3lxa m0ar tsahyt poga langkid1 jbalint cross Tharbakim benzrf alp epicallan toure|gone eddsteel linuxdaemon rotty lachenmayer niluje fall_ MitchW acro swflint timothyh Putonlalla divVerent pmade vin-ivar x1n4u ericmath1son eL_Bart0- alsoStevenXL_ cocreature ab9rf madknight freeside aminb Purlox PyroLagus SuperTux88 pikolinosimo michi7x7 newsham arw pierrot reptar_ webstrand alanz ikopico lukd ongy dpn` anhj zge Vq wraithm)
18:27:11 --- names: list (michalisko delYsid` kriztw ianp statusfa1led skeuchel nshepperd1 tomku nisstyre Guest17694 geekosaur scav sujeet brisbin earthy ekr SlashLife Solarion xpoqp oak- worch mlen dpepsilon Logio stux|RC-- diskie sdx23 marek lispy abbe nyuszika7h ventonegro GGMethos mk-fg azahi minad shapr ycheng_ exio4 Guest22057 bsima tolt MagneticDuck amx Morgawr xaimus jix ent urdh xplat etiago phadej garphy`aw Nik05 C-Keen tmciver Pilfers tdammers harmaahylje jdt nikivi liff ft)
18:27:11 --- names: list (cheater Tspoon_ mstruebing JSharp bgyss trig-ger marcel dsal stephe lumimies cdornan_ nak Chadtech sclv iphy oldsnakey edofic pchiusano mikedlr sdemos rjungemann rizary capicue hsiktas verlet64 fnurglewitz fadein hiptobecubic thebnq Robin_Jadoul shiona lukky513 XMunkki dpower PlasmaStar lambdabot Stratege nimbleark nekomune Deadhand Tallenz cdal grandy_____ brennie cschneid_ jdevlieghere scinawa Saizan Biohazard MindlessDrone falafel mingc hc avdi prizim)
18:27:11 --- names: list (AlainODea gluegadget metalrain_ zgrepc ericbmerritt_ kipd sp1 mbrock billstclair milessabin kyagrd monad_cat jmct typetetris ironChicken aurieeeh fluxit toppler noexcept srid ianconnolly mitchellsalad thoughtpolice dmj` mpickering gridaphobe lexi-lambda spinda peteretep heyj rann Reisen richi235 terrorjack niveus Wamanuz2 Soft nkaretnikov jml ocharles centril baamonde customminer PotatoGim OliPicard Randy tureba Geekingfrog shikhin glguy xnyhps solarus Drezil)
18:27:11 --- names: list (Magemanne bengt_ defanor vaibhavsagar rootnode TallerGhostWalt Taneb noxd Liskni_si Moyst platz Phyx- mendez kloeri tortal jzl averell a3f iliastsi simony jameshaydon hansihe tarcwynne__ binaryblade jzelinskie asjo tzaeru suzu sjl_ pharaun pikhq sea-gull PsyDebug greeny bwe ion phz_ casdr Firedancer a_t M2tias killtheliterate zerokarmaleft bjs jordanlewis chindy jameseb chrzyki CindyLinz nemesit|znc segin reu Profpatsch wladz_ benonsoftware c0dyr ectos alek)
18:27:11 --- names: list (oleks mattp_ Cathy [df]_ anoe raid nonzen gargawel zenzike froztbyte hongminhee twk- PHO cmaj9 treehaqr tg ByronJohnson yorick esssing __main__ amatecha strugglingming TabAtkins lukexi zpconn__________ runeks Guest32984 mkurkov_ zph wizonesolutions tjpeden S11001001 angular_mike_ edwardk spicydonuts bitonic reem cansis libbyk higherorder angerman TyOverby__ wavewave pagoda_5b a9rkzz Maxdamantus Xorlev prefork oh_lawd dukedave etrepum Scorchin si14)
18:27:11 --- names: list (incomprehensibly yaknyasn zmanian paf31 uwap gornikm codedmart dan64- ReinH fingerzam houli jerme_ ebutleriv Cir0X bradparker ranberry wtw Jello_Raptor @ChanServ ClaudiusMaximus dibblego sbrg rgrau elomatreb Strix ryanbooker jonrh dessmm fuziontech ggherdov carter mbrcknl_ jorendorff feepo darthThorik dstockwell rgrinberg lightandlight dpren gleber_ dgpratt thomashoneyman rodarmor rodlogic Charn runde nelll elvishjerricco parseval yukkuri johs changyj)
18:27:11 --- names: list (eacameron u-ou Ninja3047 bxc bafain tsani padre_angolano akkad idupree caa51h staafl_ tippenein infinisil reinh1 Sgeo Someguy123 peterhil otulp pranz3 reactormonk Frankablu gnusosa michaelw zebrah ixian insanitea petermw mstruebing1 crosleyt sonOfRa dbohdan Voldenet admin1 Akii sleblanc tv LeaChim martingale rootmos przembot mk_modrzew hcit kini Mon_Ouie bitemyapp peutri Madars jtz MalfaitRobin deba5e12 clever taktoa[c] mou alasi kaol yrid dogui_ Gabscap vqrs)
18:27:11 --- names: list (raatiniemi dminuoso mdarse CuriousErnestBro baweaver Gabemo bickle1_ int-e petercommand lokydor_ valdyn klugez `0660_ yoho tessier_ jdnavarro_ DoubleJ_ Guest3955 Princess17b29a anhduy AWizzArd numberten jgornick hodapp wamaral echoreply colescott Foritus sellout anishathalye statusbot [exa] Tourist llinguini loli Dykam dejanr nnplv d6e mniip yahb ahihi lionaneesh yushyin noctux hrnz kosmikus pta2002 bluepixel perrier-jouet alunduil ctag MarcelineVQ meck)
18:27:11 --- names: list (s4msung Philonous hsyl20 Bengi calloc atk mxf qzo survove ephemera__ Disavowed Tehnix3 ChongLi mountaingoat Forty-3 lopex niko quaestor phryk dxld mcallisterjp Tesseraction NinjaTrappeur orion trulsa SAL9000 Cale guios bind andrew_n_ jle` koala_man ghostyy crlane posco Lokathor ertes aananev Bish bbear meinside carbolymer SovietBear TC` llwu ck_y cods Athas Ankhers exferenceBot hexagoxel mceier x_o_r amiri kefin jluttine mgaare maerwald spoonm ambrosia)
18:27:11 --- names: list (ephemeron andreass jrslepak hjklhjklhjkl runawayfive peddie byte512_ whiteline__ OnkelTem alexbiehl koz_ piyush-kurur cyphase liste flux fredcy burp akermu JoelMcCracken mindtree dgonyeo bob_twinkles Jaxan yarou erikd guibou bshelden drewbarbs tokik croben jcjf rotaerk przemkovv m1dnight_ soncodi drdo thallada Lord_of_Life fryguybo1 RaptorJesus riatre jrabe lukeshu aweinstock dxld[work] gxt metts rbocquet sanitypassing qwertydvorak prg318 mmaruseacph2 bs)
18:27:11 --- names: list (bollu butterthebuddha domenkozar zyla cromachina kiltzman phasefx DrAwesomeClaws Tuplanolla Hijiri remix2000 jakutis swalladge Salek dutchie cnomad Natch bartavelle noplamodo lines Rembane ahf Guest94939 raibutera hive-mind dmead nibbling nwf hexo srk spion miklcct xinming mgttlinger Adluc jchia_2 nshepperd jchia bcoppens tromp nullifidian_ emongated ziyourenxiang kav bno2 hanna mauke_ chirpsalot armyriad agrif wayne_ nilOps RGamma_ veverak epta orzo_ cjay-)
18:27:11 --- names: list (heinrich5991 stailin mulk betawaffle cgfbee c-rog zachary12 schaeferpp monochrom pdgwien- dstolfa fairfiel- TommyC Igloo_ kubrat_ wto Kneiva_ duncan_ lavalike Desoxy_ FransWillem revprez__ cow-orke1 Ornedan_ jstolare1 owickstrom Fuuzetsu thoros bgamari- zomg abrar coeus fbauckho ircbrowse_ vjousse logcat micro pacak hanDerPe1er sarah_ canta1 DK22 detoxin Amadiro Jinixt cic1 mrBen2k2k2k thoradam NemesisD cgag bigs shans_ cjh` lynn joel135 nbouscal noobst)
18:27:11 --- names: list (jared-w bytesighs Adeon bbielsa kody^ kaychaks Clint iravid sveit CARAM___ micmus gareth__ darjeeling_ asm89 Digit alx741 matzo Chousuke m0rphism juri_ mrBen2k2k2k_ edmundnoble syq_ cpape megaTherion Wizek leah2 pita kwantam nesqi DTZUZU systemfault troydm ph88 typeVoid rflec028 cheers qdickon revprez_anz whoman Ranhir drewbert jaargon mjg dave_uy khisanth_ brynedwards mrus markus1189 zaquest banc nakal_ theDon vikram__________ Meow-J_ foolswood dedgrant jkup)
18:27:11 --- names: list (cpallares Moonside johnw JoshS Durbley Dodgy-Debaser Cheeky-Celery qmm Unhammer heath dustinm maqbool leat tengri chat_ bq tjbp S007 aib uptime justanotheruser sdhand jim__ thunderrd razzy esph sdothum niklasl acowley APic pfoetchen otto_s Guest58698 seanparsons ncl28 xplat|work k redcedar julmac Smeghead solidsnack swhalen marble_visions chriswk lpsmith stig banjiewen dredozubov salva cstrahan jokester danzimm ackthet opqdonut Niamkik mimi_vx gabiruh)
18:27:11 --- names: list (linduxed gopnikovitch max3raza strmpnk tumdedum fgaz Guest44215 Ewout scopedTV hydraz ec2-user EricZou thi_ DustyDingo Fubar^ peschkaj joncfoo m4lvin papapishu jophish cpup dxtr verement da-x Unode Benzi-Junior _flow_ Raptor8m3 mitch_ amosbird x0x0_ jcarpenter2 MikasiCoyote[m] Laney geodesic[m] unknownln equalunique[m] M-berdario freeman42x lysgaard[m] noteventime[m] ollieh Gratin[m] Guest94793 berton turt2live aspiwack[m] aer[m] davidar_ bennofs[m] wizek[m])
18:27:11 --- names: list (lierdakil[m] m4sk1n steshaw[m] HMPerson1 WilliamHamilton javjarfer[m] tester668[m] M-BostonEnginerd sn[m] albertsg[m] davidar JanPath[m] TylerCecil[m] reactormonk[m] hakan[m] jangsentry10032[ drasich[m] hendrik[m] angelbeats[m] maigel[m] jerin[m] mak81[m] M-krsiehl lightandlight1 goodboy[m] undu[m] tigerchops[m] rellen JCGrant[m] shivani_[m] Map- Zialus hucksy Sigyn infinity0 sgraf anomie[m]1 idnar[m] SuperW[m] uha[m] Mike[m]1 wzy8L-B2[m] skaillet[m] pcm77[m])
18:27:11 --- names: list (M-Chickee lycium[m] zineje[m] toma[w] sudoreboot[m] schplaf[m] aniketd[m] octalsrc[m] guest69[m] weareswarmcity[m riadvargas[m] Mcpurplemuffin[m trikl[m] geetam happyente[m] herzmeister[m] thekyriarchy sherushe[m] imbigbrother[m] bmjh strixy[m] porcow[m] Obscurity[m] grisotto[m] gpunk[m] moonrunes[m] puffnfresh anaxios foreseaz[m] aaronc[m] Masaomi[m] jgl[m] Matthew[m] wubbalubbadubdub zalipuha[m] stites[m] asenski[m] AntonLatukha[m] tibike_m[m] plll[m])
18:27:11 --- names: list (M-moyamo kumori[m] JackM[m] bgrayburn[m] phil_frontal[m] Half-Shot vitamin-q just_test1ng[m] Dev[m] charlag[m] angelvigo[m] sdvcxd[m] thejonny[m] seizo[m] nh2[m] naviknair7[m] motif[m] mossid[m] systemovich[m] jomari[m] toumi124[m] billsam[m] mith[m] abel-abel[m] sh4pe[m] jbarthelmes[m] lathebiosas[m] strangepowers[m] Dako300[m] georg3[m] M-whoops stigo[m] mad[m]1 clementd[m] FjordPrefect relyth[m] innaytool[m] monadic[m] drastan[m] jacobleach izahn[m])
18:27:11 --- names: list (Orbstheorem[m] towaii[m] ngross[m] chuzz[m] vise890[m] h_ndrik[m] puminya[m] deyg[m] levzhazeschi[m] absurd[m] palacex[m] dkellner[m] Kevin[m]3 vsts[m] iampigman[m] oats[m] M-rgh optimizationproc CryptoCalsius[m] Barnabas[m] ycy[m] metaxis[m] laaksoan[m] synopz[m] hiq[m] Flecheck[m] beemo[m] peel[m] M-ms ArchieT hdurer[m] ThousandLions[m] Akito[m] bb010g bbslclubbin[m] intheclouddan unlawfulmonad[m] honeymilktea[m] Frytka[m] ttk2[m] jbweston[m] martunis[m])
18:27:11 --- names: list (sophien[m] Naughtmare[m] henriquezanin[m] emme[m]1 william[m]1 michbad Heino[m] HoelKervadec[m] dima_grshk[m] noperope[m] braidn[m] superobserver[m] seif_madc[m] PifyZ[m] M-wamaral M-kitsune rizo[m] camael[m] unclechu AX3L[m] aaaaaaaaab[m] Overload[m] magnap chocowheel[m] ub[m] capncanuck[m] limonheiro[m] boathouse2112[m] WinterFox[m] Cadey[m] avatias0[m] moon[m] TimWolla[m] siddhanathan[m] thekyriarchy__ tobim[m] cipher1024[m] lkurusa fristonio[m] hpd_m)
18:27:11 --- names: list (SijmenSchoon[m] jvalleroy[m] M-x-matrix[m] ajtowns[m] test-guest[m] nkhodyunya softashell Nerka[m] snpriyanshu[m] artemismucaj[m] riaqn adziahel[m] testingriotnmatr badamson[m] Deleh[m] atopuzov[m] superpat[m] arthurfragoso[m] sburavtsov[m] minhnhdo[m] saltykawaiineko[ srenatus Scapin[m] grassator[m] iohidtbhfam[m] magog[m] dbramucci[m] djangoblockchain ArrayWindrunner[ Google[m] Shaunthesheep[m] Mougan[m] uchronian[m] Prince781[m] DavesTestingAcco)
18:27:11 --- names: list (testtt0x11[m] gelidae[m] Niboor[m] usedname[m] tuxitagnu[m] razvanc-r[m] pnrfne[m] mrdaak[m] chominist[m] kebertx[m] wannabeog[m] wilo[m] km42[m] addem[m] gridaphobe[m] tryptyx[m] c0ff33[m] sielicki Quoran[m] alldigital[m] Guest340521[m] kasbah[m] micond[m] anonguest[m] asthma[m] himmAllRight[m] fgaz[m] agraba[m] SansFr[m] g3lnana[m] shekel[m] srid[m] neechoo guyinjeans[m] virginiam[m] Elorm[m] Jikstra[m] sjdthree[m] KevinMGranger bustillo[m] M-HirmeS am2on)
18:27:11 --- names: list (mrhania[m] lixiang4u[m] foo123[m] PatrickM[m] bingen[m] cakecake[m] NikitaKuznetsov[ infty[m] maverickwoo[m] dezren39[m] kwaku[m] ElliotKiyomizu[m thebeast[m] stuebinm[m] vakili[m] anyu[m] seto[m] kmicklas[m] Litom[m] asonixdog[m] gelnana[m] jakubczaplicki[m howsiwei[m] oliverlsanz[m] scrypso[m] manko[m] asm[m]1 dumpster[m] leandro[m] Bimmie[m] slackman PierreM anderson akfp eldritch logotags catsup boj nurupo StoneToad grumble shoogz chrissl omilu)
18:27:11 --- names: list (freeman42x]NixOS {AS} ziocroc aplainzetakind Mark___ jfredett beerdrop andyo roconnor mnoonan jwynn6 aijony lijero Arcaelyx ninegrid avn urodna milli yaewa drewr obfusk gienah_ kuno hiredman cschneid Chobbes jao patrickdoc markhuge elfets tsaka__ t7 connrs fandi codesoup heurist`_ zariuq raynold slamtime akr dilinger arkeet BrAsS_mOnKeY Sose hamishmack amalloy bbaren whaletechno mikeplus64 infandum` bontaq` mbeidler alexknvl joedevivo dashed Argorok Youmu)
18:27:11 --- names: list (ghuntley sethetter feltnerm tharper_ fxrs_ zmt00 Tritlo Kamuela staffehn_ caw______ Bigcheese_ WhereIsMySpoon_ dpanth3r_ Gothmog_ dysfun net4all_ robogoat_ mt_caret1 TMA Kensan Ring0`` armlesshobo liurnd__ fresheye1 jlouis_ dtulig1 seliopou_ CodeKiwi sphalerite_ jrm _6a68 jinblack rjeli_ rembo10_ oberste1n malt3_ huonw_ prooftechnique_ Cthalupa- zeroed- Majiir bydo_ dersquisher felixonmars_ iross_ gareth_ tripty^ sha-2_ ecx86 AntiSpamMeta mcspud forell buhman)
18:27:11 --- names: list (zaphar_ps[m] exarkun dirb spacekitteh[m] andjjj23 kyru68bu Takumo rakete xffox[m] amidstbinary[m] shutdown_-h_now ego daoo[m] phittacus Makinit M-x[m] raphaelsquelbut[ Arguggi felipeac[m] discontent[m] saci[m] sudom0nk[m] Guest1573[m] chiwui[m] icen[m] M-herah reconmaster[m] marmalodak antismap fbreitwieser[m] jollyrogue[m] matheusrv[m] wchresta[m] teej huytd max-m TimWolla naudiz joehillen pikajude matchray tnks sm grayhatter SolarAquarion son0p toby1851)
18:27:11 --- names: list (Fairy cmsmcq swarm1321[m] xacktm CurryWurst carlomagno1 msmorgan Esoterisch Eduard_Munteanu osa1 wonko7 Klumben [Leary] aarvar smichel17 byorgey ancarda mek42 texasmynsted eliasr dddddd energizer fr33domlover unclechu-m[m] dmiles Noldorin sw1nn cyberlard vanvik[m] dcoutts)
18:52:08 <kenndel> So i made a stack in haskell (super noob) and a push command. I'm in ghci and i want to push to it. My push is push :: a -> Stack a -> Stack a -- push x (Stack xs) = Stack (x:xs), from reading that in GHCI i want to type `push a 5` to push 5 onto a previously created stack a?
18:52:46 <koz_> kenndel: What is the type of 'a'?
18:52:54 <koz_> (in the phrase 'push a 5')
18:53:00 <koz_> s/phrase/code line/
18:53:42 <kenndel> in GHCI i do `let a = push 5` => Stack [5]
18:54:15 <kenndel> so i have a stack and my implementation should, given an element and a stack, create a new stack.
18:54:28 <kenndel> I'm just confused on how to call "push" in ghci and how to pass it a stack and element
18:54:35 <kenndel> or how ghci knows which stack im talking about, etc
18:55:10 <kenndel> and the type of a is '   :t a // a :: Num a => Stack a -> Stack a
18:55:11 <kenndel> => Stack [5];
19:03:02 <EvanR> kenndel: push takes two arguments, how is "push 5" doing anything
19:03:36 <EvanR> the second argument is the stack to push onto
19:03:48 <EvanR> which seems to be missing, so i dont blame you for being confused
19:07:08 <kenndel> here is the code i have right now https://repl.it/repls/BigBrokenHertz
19:07:22 <kenndel> the push signature `push (Stack xs) x =...` is the given part
19:07:28 <kenndel> so i want to give push a stack then an element
19:07:36 <EvanR> it looks fine, but dont you need to start with an empty stack?
19:07:39 <kenndel> so if i do `let a = Stack`
19:07:49 <kenndel> then do `push 4 a` i get errors
19:08:25 <EvanR> a isn't a stack, its a function to build a stack from a list
19:09:09 <kenndel> Also do i need to put 'deriving Show' after my data Stack a = Stack [a] declaration?
19:09:09 <EvanR> if i were you, i would define an empty stack, and call it something creative like empty
19:09:32 <EvanR> if you want to
19:09:55 <kenndel> ok there is empty
19:10:08 <EvanR> i dont see any update
19:10:23 <EvanR> ah i do now
19:10:37 <EvanR> now you can push stuff onto the empty stack
19:10:39 <kenndel> can you see the output page too when i try commands? haven't used this before
19:10:56 <EvanR> no i see nothing
19:12:31 <kenndel> this is what i get when i try to run it as is https://pastebin.com/cNfv6RLB
19:13:27 <EvanR> well i see the problem, try to read the error and also see it
19:13:36 <kenndel> Do i need like `push :: Stack a -> a -> Stack a` to match the signature `push (Stack xs) x = Stack (x:xs)` ?
19:14:17 <EvanR> your equation has certainly got the stack argument and other argument backwards
19:15:37 <dmwit> kenndel: Your type signature says "I take a thing and a stack of things", but your implementation says "I take a stack of things and a thing".
19:16:09 <dmwit> One of them should change. My aesthetics says it should be the implementation, but it sounds like you may have constraints that prevent that choice from being the right one. =P
19:16:21 <kenndel> So when i try to create a stack and push it here is my output https://pastebin.com/Rc8MTXRR
19:16:38 <kenndel> dmwit, i had it working with Stack a -> Stack a -> Stack a, push x (Stack xs) lol
19:16:44 <kenndel> then i noticed it actually required the other way
19:16:44 <EvanR> you didnt create a stack there
19:16:47 <kenndel> which is throwing me off
19:16:53 <EvanR> put empty there instead of a
19:17:07 <EvanR> well, as soon as you fix the push function
19:17:36 <koala_man> is there a GHC_FLAGS type variable if I want to cabal install something with a certain optimization flag?
19:17:41 <kenndel> so its currently `push :: Stack a -> a -> Stack a, push (Stack xs) x = Stack (x:xs)'
19:18:05 <dmwit> kenndel: That looks reasonable.
19:18:18 <dmwit> kenndel: Now try, e.g., `push empty 5`.
19:18:22 <kenndel> if i do 'let empty = Stack' how do i reference it? does that mean i can only have one stack at a time?
19:18:39 <dmwit> Don't do `let empty = Stack` unless you want to confuse yourself.
19:18:50 <dmwit> You have already defined something named `empty` in the file you showed us.
19:18:59 <kenndel> thats why i was doing 'let a = Stack'
19:19:25 <dmwit> ...but you already have something named `empty`. Why don't you want to use that?
19:19:42 <dmwit> Like, you got the right answer, and now you're trying to answer a second time. Just use the right answer you already made. =P
19:19:42 <EvanR> let a = Stack is patently bad to do
19:19:46 <kenndel> aaaaaahhh
19:19:53 <kenndel> push empty 5 gives me [5]
19:19:58 <kenndel> ok ok ok
19:20:37 <EvanR> Stack there is some function, you are assigning a function to variable a, its not a stack
19:20:38 <kenndel> here is what happened when i tried to push more to it https://pastebin.com/b35LBSdy
19:20:54 <kenndel> oh so i want to do `let a = empty`
19:20:58 <kenndel> if i wanted to use a
19:20:59 <EvanR> sure
19:21:00 <kenndel> for instance
19:21:01 <kenndel> got it
19:21:11 <EvanR> and the results in your printout make complete sense to me :)
19:21:23 <kenndel> but i should be pushing a new element onto the stack
19:21:33 <EvanR> youre pushing new elements onto *empty*
19:21:37 <EvanR> right?!
19:21:38 <kenndel> so i should get 5, 6 after push 6?
19:21:58 <EvanR> like
19:22:03 <EvanR> 2+2 is 4
19:22:05 <EvanR> 2+3 is 5
19:22:07 <EvanR> not 9
19:22:13 <kenndel> ok
19:22:15 <kenndel> im following
19:22:25 <kenndel> but my goal is to return a new stack with the element added
19:22:27 <kenndel> im not trying to mutate it
19:22:45 <kenndel> so push a 6 should return a totally different stack with 5, 6
19:22:55 <EvanR> you do push empty 5, then forget it
19:23:01 <EvanR> use let to remember it
19:23:21 <dmwit> kenndel: Perhaps you are looking for `push 6 (push 5 empty)`.
19:23:33 <kenndel> legends!
19:23:37 <kenndel> im following now
19:23:53 <kenndel> i thought my definitions were going to be really sick and just do this
19:24:02 <dmwit> `empty` is always empty, even after you make a new unrelated stack with more stuff in it.
19:24:07 <kenndel> https://pastebin.com/ti8jX3WD
19:24:15 <kenndel> I'm a functional programmer now boys!
19:24:27 <kenndel> look at me now mom!
19:24:35 <EvanR> yeah, empty = Stack [], haskell takes equations seriously
19:25:11 <kenndel> no kidding it does
19:25:39 <kenndel> ok so now let me try to do the pop - thanks so much for the help guys i was really missing a few steps there!
19:25:43 <dmwit> I think it's time for a pop quiz.
19:25:54 <dmwit> *ba dum tshhhhhh*
19:25:55 <kenndel> send it
19:25:59 <kenndel> oh wait
19:26:01 <kenndel> i get it
19:26:02 <EvanR> once you pop you cant stop
19:26:08 <kenndel> haha
19:26:16 <kenndel> this is a pretty fun class its 'programming languages'
19:26:22 <kenndel> so just a survey of different paradigms
19:26:40 <kenndel> get me out of the c/c++ hellhole that is my institution
19:27:00 <EvanR> the quotient language of c by c++
19:27:13 <EvanR> dont want to know what that looks like
19:27:45 <kenndel> we making ring jokes in here now?
19:27:50 <kenndel> this chat is great
19:28:51 <dmwit> C++ is an equivalence relation?
19:29:30 <EvanR> in the habit of dropping half of stuff to sound smart "generalizing"... so its just a relation
19:30:04 <dmwit> I did not have relations with that language.
19:32:03 <kenndel> Interesting, if i remove 'deriving Show' from where i declare the stack type i can no longer do `let a = push empty 5, a` and see the stack. i get an error then
19:32:33 <EvanR> you removed the means by which stacks could be printed out
19:33:04 <EvanR> like, you put a bag over your head and realized you could no longer see
19:33:27 <EvanR> science!
19:33:46 <kenndel> i guess that makes sense
19:33:50 <kenndel> haskell is really literal huh
19:33:58 <EvanR> ... yes
19:34:46 <kenndel> hm ok to pop the last element off the stack i have `pop (Stack xs) = Stack xs`
19:34:52 <kenndel> but obviously that just returns the same element
19:35:22 <kenndel> So i need to find a haskell way to make xs = xs - the last element
19:35:32 <kenndel> this was way easier adding haha
19:35:59 <kenndel> so Stack tail xs ?
19:36:23 <dmwit> Hint: `pop (push x s) = s`. Now substitute in the definition of `push` and see where that gets you.
19:36:23 <EvanR> on ghci do this
19:36:32 <EvanR> tail [1,2,3,4]
19:37:18 <kenndel> oh shit tail is front
19:37:19 <kenndel> haha
19:37:37 <EvanR> on ghci do this
19:37:41 <EvanR> 1:[2,3,4]
19:37:55 <kenndel> k we add 1 to the front
19:38:00 <EvanR> the "front" is on the left, not the right
19:38:06 <sqooq> monad stacks be annoying af
19:38:16 <kenndel> so i want init
19:38:25 <kenndel> wtf tail is front and init is back?
19:38:28 <EvanR> what is the type of pop anyway
19:38:35 <dmwit> Or, well, for a slightly less confusing hint: `pop (push x (Stack xs)) = Stack xs` which is just a specialization of the above equation.
19:38:36 <kenndel> functional programming btw
19:39:18 <kenndel> I GOT IT
19:39:30 <kenndel> `pop (Stack xs) = Stack (init xs)`
19:39:41 <dmwit> (Sometimes I admit that I like somebody else's explanation/hint better than mine. This is not one of those times.)
19:39:50 <kenndel> b = Stack[6, 5], pop b Stack [6]
19:40:13 <dmwit> kenndel: I suspect that you either 1. have not written `push` correctly 2. have not written `pop` correctly or 3. have chosen a terrible name for your data structure.
19:40:14 <kenndel> haha dmwit i was looking at what you were doing but i had already started down this tail rabbit hole as i had a hint on it
19:40:31 <kenndel> dmwit, https://repl.it/repls/BigBrokenHertz
19:40:36 <kenndel> im compiling it on this
19:40:59 <dmwit> "Does it compile?" /= "Is it correct?"
19:41:10 <kenndel> i spent like 3 hours getting haskell going on my local but then a vim plugin gave me trouble and i just gave up on it and went online
19:41:19 <dmwit> Corollary: "Does it run?" /= "Is it correct?"
19:41:35 <kenndel> oh wait you are right
19:41:39 <kenndel> its going in first not last
19:41:42 <EvanR> if it compiles its good
19:42:04 <EvanR> doesnt mean its perfect
19:42:11 <kenndel> ya so i have a queue essentially
19:42:35 <dmwit> kenndel: I propose that you reread my hints now and see where they lead you. =)
19:42:37 <kenndel> it looks like in my push i have push (Stack xs) x = Stack (x:xs)` so im telling haskell to put the new element x up front
19:42:46 <dmwit> kenndel: Bonus: they will lead you down the righteous path of equational reasoning.
19:43:06 <kenndel> dmwit, i will take this journey now!
19:43:29 <EvanR> we should submit a proposal for syntactic sugar which lets us write [1,2,3,4] as 1:2:3:4:[]
19:43:41 <EvanR> to make it look like a stack
19:43:48 <dmwit> =P
19:43:53 <kenndel> so where you have `push x (Stack xs)`, that is one of my only requirements here. It needs to be `push (Stack xs) x`
19:44:14 <dmwit> kenndel: okay, okay: `pop (push (Stack xs) x) = Stack xs`.
19:45:43 <dmwit> kenndel: And for context: at the time I wrote this hint, you had defined `push` but not `pop`. So treat `push` as a thing where you can substitute in its definition, and `pop` as the value you are "solving for".
19:45:53 <kenndel> i got it working!
19:46:04 <kenndel> well, push
19:46:14 <kenndel> i changed it to = Stack(xs++[x])
19:46:18 <kenndel> now looking at my pop
19:46:37 <EvanR> whhaaaa
19:46:41 <dmwit> This is a dark path you have taken.
19:46:47 <kenndel> im just on the api mang
19:46:52 <dmwit> Semantically correct but spiritually bankrupt.
19:46:58 <kenndel> i was to understand reading the docs was a good thing
19:46:59 <kenndel> :D
19:47:15 <kenndel> show me the light! i want to see it!
19:47:34 <dmwit> Keep your original `push`. It was Good.
19:47:35 <kenndel> dmwit, so i think what your thing says is pop takes a function where i push something onto a stack then ignores it and just returns the stack?
19:47:37 <EvanR> next up, realizing how inefficient xs++[x] is, calling bullshit on haskell, and switching to python or perl or something
19:47:53 <kenndel> my push was appending to the front not the back though
19:47:56 <kenndel> so it was queue style
19:47:57 <dmwit> kenndel: Oh, no, `pop` doesn't take a function. It takes a stack, of course!
19:48:14 <kenndel> i needed to adjust push to get the element into the back, no?
19:48:24 <dmwit> No.
19:48:32 <dmwit> Your concept of "back" and "front" was just backwards. =)
19:48:33 <kenndel> im reading the "stack" left to right, no?
19:48:37 <kenndel> oh haha
19:48:38 <kenndel> got it
19:48:52 <EvanR> i am curious if you managed to implement a stack in any other language first
19:48:52 <dmwit> I mean, you are the programmer. You get to choose what the abstract symbols the machine prints mean.
19:49:17 <kenndel> ive implemented a stack in a few of em
19:49:32 <kenndel> java, c, c++
19:49:33 <EvanR> all backward? :)
19:49:42 <kenndel> im just under a lot of pressure ok :D
19:49:53 <kenndel> but it doesn't matter like dmwit said
19:49:58 <kenndel> if my implementation loads front or back
19:50:04 <kenndel> as long as it behaves like a stack
19:50:18 <ertes> is there or can there be any run-time cost to pattern-matching on ()?  specifically this pattern:  case () of …
19:50:22 <kenndel> and the backing data structure has o(1) insertion
19:50:28 <EvanR> your backward stack does have the added feature of allowing infinite stacks
19:50:37 <dmwit> Right. And your original `push` was very idiomatic and efficient (and your changed one was inefficient).
19:50:44 <kenndel> i switched back guys!
19:50:47 <kenndel> im trying to learn!
19:50:53 <ertes> more specifically this:  case () of _ | …
19:50:54 <dmwit> ertes: Yes, the cost of forcing `()`.
19:51:02 <kenndel> im not digging my heals in i want to convert from a python disciple
19:51:08 <dmwit> ertes: Oh, well, that's a different story...
19:51:22 <dmwit> kenndel: Okay, so `push (Stack xs) x = Stack (x:xs)`, right?
19:51:25 <kenndel> yup
19:51:26 <EvanR> forcing a literal () placed there?
19:51:27 <kenndel> back to 0
19:51:27 <ertes> > case (undefined :: ()) of _ -> ()
19:51:29 <lambdabot>  ()
19:51:37 <kenndel> dmwit, its here https://repl.it/repls/BigBrokenHertz
19:51:39 <dmwit> kenndel: And if we push and then immediately pop, we want to get back the original stack, right?
19:52:20 <ertes> reading core it is =/
19:52:35 <kenndel> dmwit, ya so i switched my pop from tail to init
19:52:38 <ertes> or i just use MultiWayIf
19:52:40 <dmwit> kenndel: Putting that last property in Haskell-ish syntax, we might write `pop (push (Stack xs) x) = Stack xs`. Does that seem reasonable?
19:52:55 <kenndel> https://pastebin.com/P5AcSvLz
19:53:00 <kenndel> so this seems like desired behavior?
19:53:27 <dmwit> kenndel: First let's establish what the desired behavior is. I've proposed one answer to that question; what do you think of it?
19:53:30 <kenndel> ok so currently my pop says give me a stack and ill give you back a stack with the last element removed
19:53:34 <kenndel> and if i do your thing
19:53:40 <kenndel> give me a stack and i give you back a stack
19:53:45 <kenndel> so the types seem right
19:53:51 <EvanR> dmwit's equation is like the ultimate unit test for stacks
19:53:59 <EvanR> only its not just a test, its a law
19:54:16 <kenndel> is that like an identity?
19:54:19 <EvanR> yes
19:54:19 <kenndel> x-> x
19:54:26 <EvanR> uh no
19:54:29 <kenndel> give me a stack and do whatever you want but i want the stack back
19:54:40 <dmwit> No, not whatever you want.
19:54:48 <dmwit> You only get to push one element, then pop one element.
19:54:50 <kenndel> im trying to infer the purpose of the push
19:54:56 <kenndel> what element is it?
19:55:02 <dmwit> Chef's choice.
19:55:05 <kenndel> if i only provide pop b for a stack b
19:55:13 <kenndel> what does the element x become?
19:55:41 <dmwit> Any well-typed value for `x` should validate the proposed equation.
19:55:44 <kenndel> i.e. pop b => pop ( push (b) x ) = b ?
19:55:49 <kenndel> or am i reading that wrong?
19:56:10 <dmwit> I could write this instead if you wanted to be explicit about quantifiers: `forall (x :: a) (xs :: [a]). pop (push (Stack xs) x) = Stack xs`.
19:56:31 <inkbottle> :t ((->) r)
19:56:33 <lambdabot> error: parse error on input ‘->’
19:56:36 <dmwit> kenndel: What does `=>` mean in that explanation?
19:56:47 <dmwit> s/that/your/
19:57:01 <kenndel> im just inferring what would be happening to a such stack b that i want to pop from
19:57:20 <kenndel> so => would mean 'does this imply' or something
19:57:26 <dmwit> You can't promise anything much about `pop b` without knowing something special about `b`.
19:58:25 <dmwit> I like the `pop (push b x) = b` part of your question, but the `pop b =>` bit (still) isn't clear to me.
19:58:59 <kenndel> im just trying to figure out the purpose of push and x in that equation
19:59:05 <kenndel> and how we land back on b
19:59:15 <kenndel> also the signature is required to be pop (Stack xs) = ...
19:59:22 <kenndel> but i am happy to be learning :)
19:59:43 <dmwit> kenndel: Okay, let's go back to the English description I proposed, to make sure you still agree with it. Maybe you answered too hastily before.
19:59:55 <kenndel> i think so
20:00:02 <dmwit> kenndel: If we push and then immediately pop, we want to get back the original stack, right?
20:00:39 <kenndel> Hint: `pop (push x s) = s`. Now substitute in the definition of `push` and see where that gets you.
20:00:42 <inkbottle> :k (->)
20:00:42 <kenndel> yes
20:00:43 <lambdabot> TYPE q -> TYPE r -> *
20:00:59 <inkbottle> :k []
20:01:00 <lambdabot> * -> *
20:01:02 <dmwit> More explicitly: if we have a stack named `s`, and we push an element named `x` onto it, and then pop an element off of that, we should get back `s` after the pop, right?
20:02:10 <inkbottle> Why does that say `TYPE q` instead of plain `*`? (in `:k (->)`)
20:02:39 <dmwit> inkbottle: You can read more about it by googling for "levity polymorphism". It's a bit much to explain in-line here on IRC.
20:03:09 <inkbottle> dmwit: thanks a lot, I'll do that
20:03:19 <dmwit> inkbottle: In short, there are lifted and unlifted types (those which can and cannot contain bottoms), and `(->)` works for both.
20:03:42 <dmwit> (...and produces a lifted type, even if its arguments are unlifted.)
20:05:30 <dmwit> kenndel: (Still thinking? Got bored?)
20:05:35 <kenndel> Sorry had to grab a beer
20:05:45 <kenndel> ya that makes sense to me
20:05:53 <kenndel> so does haskell interpret the x as some variable
20:06:15 <dmwit> Oh, this isn't really valid Haskell yet.
20:06:24 <kenndel> Oh got it haha
20:06:29 <dmwit> Well, certainly "we have a stack named `s`" isn't valid Haskell. It's clearly English!
20:06:30 <kenndel> i kept trying to implement that
20:06:52 <dmwit> But we'll make it closer and closer to Haskell as we go. Bear with me. It's not a complicated garden path, but it's a bit detailed, so I'm going to go one small step at a time.
20:07:08 <kenndel> ok sounds good! thank you :)
20:07:47 <dmwit> Okay, so now, rephrasing just slightly: if we have a stack named `s`, and we push an element named `x` onto it, that's `push s x` in more Haskell-y and less English-y syntax. Then if we pop an element of `push s x`, we want to get `s`. Still good?
20:08:37 <kenndel> ok ya
20:09:46 <dmwit> Cool. So if we have a stack `s` and an element `x`, popping something off of `push s x` is `pop (push s x)` in more Haskell-y and less English-y syntax. So we want `pop (push s x)` to be `s` -- no matter what stack `s` is and no matter what element `x` is.
20:10:22 <dmwit> And then the next step is: we have stack `s` and element `x`. Then we want `pop (push s x) = s`. Still good?
20:11:40 <kenndel> ok
20:12:23 <dmwit> Right. Now, for good reasons that I will explain later, I'm going to make a little leap. Since every stack `s` has the form `Stack xs`, I'm going to rewrite the above equation.
20:12:56 <dmwit> If we have element `x` and list `xs`, then we want `pop (push (Stack xs) x) = Stack xs`. This is the same equation, just with a more verbose form of each stack.
20:13:17 <kenndel> ok
20:13:32 <dmwit> Okay. We defined `push (Stack xs) x = Stack (x:xs)`.
20:14:19 <kenndel> yup
20:14:23 <dmwit> We can combine the two equations by replacing the call to `push` in our desired equation with the definition of `push`.
20:14:37 <dmwit> So then `pop (push (Stack xs) x) = pop (Stack (x:xs)) = Stack xs`.
20:15:13 <dmwit> ...and now we have sort of arrived, no? `pop (Stack (x:xs)) = Stack xs` is valid Haskell, and a by-equational-reasoning-correct definition of `pop`.
20:15:43 <kenndel> it works!
20:15:53 <kenndel> thats really cool actually
20:16:12 <kenndel> so i know this might have been obvious and in english it was but how does haskell untangle it?
20:16:29 <kenndel> haskell just knows what x and xs are so when i say "Stack xs" it knows to give that part back?
20:17:22 * EvanR does pop empty and rains on the parade
20:17:29 <dmwit> Well, Haskell has a fairly rich language for pattern matching, and that's part of what you're seeing here.
20:18:05 <dmwit> EvanR: Yes, it turns out that `empty` is not equal to `push s x` for any `s` and `x` and so our starting equation doesn't say anything about what `pop empty` should do. Dang!
20:18:23 <dmwit> kenndel: But to continue answering your question about how this definition works...
20:18:46 <EvanR> the force of pop applied to the empty stack causes the haskell machine to violently implode, worst case scenario
20:19:25 <kenndel> EvanR, pop (Stack []) = Stack [] is already defined my dude :D
20:19:35 <dmwit> kenndel: This one I have a bit of trouble articulating well. If I wrote `foo (Stack xs) = bar xs`, would you understand how that works?
20:19:40 <EvanR> how does that behavior stand up to the laws
20:20:22 <kenndel> dmwit, some function foo takes a stack and returns some function bar which takes xs ?
20:20:24 <dmwit> EvanR: Thanks for the feedback. I definitely should have made kenndel agree on a second law before we started the equational reasoning. =/
20:20:28 <dmwit> I will remember it for next time.
20:21:03 <dmwit> kenndel: It takes a stack, which is a fancy wrapped-up kind of list, and passes just the list part (not as a stack) to the function `bar`.
20:22:46 <dmwit> kenndel: In fact, behind the scenes, Haskell's evaluation engine does something more fancy: first, it checks that the stack actually uses the `Stack` constructor. In this case it's probably pretty clear that's going to be so, since it's the only constructor, but there are other types with more constructors.
20:23:41 <dmwit> kenndel: And in particular, lists have multiple constructors. So one might next ask if you understand how something like `bar [] = quux; bar (x:xs) = blargle x xs` works -- this shows off a pattern match where multiple constructors are possible.
20:24:45 <kenndel> oooohh so haskell is able to peel the layers on something back
20:25:37 <dmwit> Right, exactly.
20:26:04 <kenndel> thats really cool
20:26:08 <dmwit> So `pop (Stack (x:xs)) = ...` is just a little syntax sugar that peels two layers at once -- but in reality behind the scenes it gets translated to first peeling off the `Stack` layer, then peeling off the `(:)` layer.
20:27:24 <kenndel> awesome!
20:27:37 <EvanR> theres a second law? of stackodynamics?
20:28:04 <kenndel> ok thank you so much for breaking that down for me! i gotta try to grind a little more of that out but that was really helpful! thank you dmwit and you EvanR !
20:28:14 <dmwit> Now I promised to explain why I took the leap of replacing `s` with `Stack xs`, so I'll do that briefly. We had `pop (push s x) = s` as an equation. It's a perfectly good equation, but it's hard to use because it doesn't match the definition we gave for `push`. I noticed that the definition we gave and this form were "pretty close", and saw how to unify them. That's all.
20:28:47 <kenndel> that makes sense!
20:35:27 <EvanR> all these functional datastructures are based on the invariant that "you" are holding onto the root of a tree, you only have access to the root and must traverse to get anywhere
20:35:45 <EvanR> is there a fundamental reason you cant be holding onto two parts of the tree at once
20:35:57 <EvanR> guess yes i just dont know what it is
20:36:30 <mniip> what do you do with two parts?
20:36:37 <mniip> if you modify one another will not update
20:37:03 <EvanR> or if it did, it wouldnt be efficient
20:37:17 <EvanR> ok
20:42:17 <amalloy> mniip: finger trees are a counterexample to that argument, no?
20:46:31 <dmwit> In what sense do finger trees have two roots?
20:46:40 <EvanR> i am impressed that wikipedia on finger tree is all in haskell and is talking about zippers and stuff...
20:46:55 <EvanR> instead of a wall of java
20:50:33 <ab9rf> it's rare that wikipedia has well-written articles on anything related to computer science
20:50:45 <ab9rf> the articles are usually "correct" (to some level of correctness) but they're rarely well-written
21:15:21 <kenndel> OK I'm back!
21:15:31 <kenndel> Converting my stack to a class Collection c where
21:15:34 <kenndel> and adding a queue to it
21:15:51 <kenndel> here is what i have so far https://repl.it/repls/BigBrokenHertz
21:16:18 <kenndel> I think it isn't happy with line 7, but im not sure what proper input should be between instance and where in this case
21:23:44 <amalloy> kenndel: blocks, such as where clauses, need to be indented
21:24:09 <kenndel> amalloy, my hero
21:24:38 <kenndel> was so confused by those error messages i just hadn't seen blocks yet to think about that
21:25:13 <amalloy> you have some more errors, but i'll leave you to work them out
21:30:25 <kenndel> amalloy, from line 1->3 i dont have anything in my notes on this so im trying to infer from online sources
21:30:46 <kenndel> that makes sense, right? instead of hardcoding in Stack Int -> Int -> Stack Int for push
21:30:49 <kenndel> i want to use c
21:30:51 <kenndel> no?
21:31:20 <amalloy> kenndel: how many type parameters does Stack take?
21:31:42 <kenndel> So i'm converting a stack implementation into a collection and then adding a queue
21:31:57 <kenndel> so originally my stack was data Stack a = Stack [a]
21:32:09 <kenndel> and push/pop are my stack implementation with Stack replaced with 'c'
21:32:33 <kenndel> but in collection im just doing int, no longer type polymporphic
21:32:43 <kenndel> oh wait sorry the answer you wanted was just 1, int
21:33:21 <amalloy> kenndel: well, i was hoping for the correct answer
21:33:28 <amalloy> look at Stack's definition
21:34:13 <kenndel> are you referring to the line 5 `data Stack = Stack [Int] deriving Show`?
21:34:17 <kenndel> that part was given
21:34:47 <amalloy> yes, that's the definition of Stack. and its type has zero parameters, right? those would appear on the left of the =
21:35:06 <kenndel> ok ya 0 type parameters
21:35:37 <amalloy> and the Collection class uses Stack as c, giving it the type parameter Int
21:35:44 <amalloy> (by using c Int as a type)
21:38:12 <kenndel> i think im following what you are saying but im not arriving at a conclusion
21:38:23 <kenndel> my stack has 0 type parameters (as given so i need that line)
21:38:36 <amalloy> indeed
21:38:38 <kenndel> so do i need to remove the c from line 1-3?
21:38:48 <amalloy> wellll, you need c
21:38:51 <kenndel> but then i lose the information i gave it from before
21:38:52 <kenndel> ya haha
21:38:57 <amalloy> but you should give it the appropriate number of type parameters
21:38:58 <kenndel> im trying to square those two things
21:39:01 <kenndel> ive been playing with it
21:39:20 <kenndel> i should give stack the appropriate number?
21:39:51 <amalloy> you can't change Stack, you said
21:40:02 <kenndel> does c trickle down into my definitions?
21:40:06 <amalloy> so you must restrict yourself to changing the definition of Collection
21:40:10 <kenndel> do i replace Stack->c ?
21:40:14 <kenndel> or something like that?
21:41:39 <kenndel> so i'm given line 1 Class collection c where
21:41:48 <kenndel> then i have aded the c's to push/pop
21:42:03 <kenndel> which need to be there
21:42:09 <kenndel> so is my issue on line 7>
21:42:12 <amalloy> okay, so, try this. write the type signatures for push and pop using Stack, instead of c
21:42:18 <kenndel> where i say, `instance Collection Stack where`
21:42:39 <amalloy> lines 2 and 3 contain the errors we're working on now
21:43:10 <kenndel> ok got it, cause 9/11 the lhs are given aswell and contain `Stack` so i was confused
21:43:12 <amalloy> what would the type signature for push look like if you didn't use a typeclass at all?
21:43:46 <kenndel> Just Int -> Int -> Int ?
21:43:56 <kenndel> for push
21:44:08 <amalloy> that's a function taking two ints and returning an int
21:44:15 <amalloy> you need one that takes a Stack
21:45:02 <kenndel> so i swapped them app c-> Stack and have errors
21:45:33 <amalloy> yes, you will certainly have errors if you do that: it's an intermediate step to help you see the right solution, not the actual solution
21:45:35 <kenndel> expected kint `* -> *` but has kind `*`
21:45:40 <kenndel> oh haha
21:46:29 <kenndel> wait so do i not want the Int?
21:46:35 <kenndel> push :: c -> Int -> c?
21:47:05 <kenndel> it compiles!
21:47:05 <amalloy> quite right! remember, c specializes Stack here, and Stack takes no type parameters
21:47:09 <kenndel> famous last words!
21:47:13 <kenndel> ok that makes sense
21:47:21 <kenndel> man haskell has weird little hills to get over
21:47:27 <kenndel> but once you climb em it seems obvious
21:47:42 <kenndel> thank you!
21:47:46 <amalloy> the last error is on line 11, which puzzles me because you said that's a given
21:48:16 <kenndel> only the left hand side
21:48:24 <kenndel> push (Stack xs) = ______
21:48:39 <kenndel> push (Stack xs) x = ____ rather
21:49:31 <amalloy> ah. that explains it, then
21:49:49 <kenndel> so the right hand side is what i had in my previous stack implementation
21:50:17 <amalloy> line 9 looks good, but in 11 you're doing something odd
21:50:30 <kenndel> oh the pop not the push
21:50:41 <kenndel> ok so the implementation given has 3 blank lines
21:50:47 <kenndel> so im assuming it will have the | symbol
21:50:48 <amalloy> sounds about right
21:50:51 <kenndel> for 3 different things
21:51:39 <kenndel> im actually not sure why i would need 3 for pop?
21:51:53 <kenndel> isnt there only the case where the stack is empty or it has something then pop it?
21:52:24 <amalloy> kenndel: indeed, sounds right. how would you write those two cases?
21:52:49 <kenndel> Am i having issues with the indentation here on line 12?
21:53:46 <kenndel> its my first time using this multiline format thing
21:54:05 <amalloy> it's hard to say whether the indentation is right because the pop function is sadly all wrong
21:54:19 <kenndel> oh nooo haha
21:54:32 <kenndel> So on the regular stack implementation
21:55:41 <kenndel> pop (Stack xs) = Stack (tail xs)
21:55:49 <kenndel> because i was required to have pop (Stack xs) = ...
21:55:53 <pikajude> damn, new-build doesn't require fetching remote sources yet
21:55:57 <pikajude> that'll be so useful once it lands
21:56:04 <pikajude> support, not require. lol
21:56:39 <kenndel> though i worked with dmwit who showed me that `pop (Stack (x:xs)) = Stack xs` worked too
21:57:03 <amalloy> okay, so what's different this time?
21:57:09 <kenndel> but my left hand side was given so i had to work around it. Here, i'm only given `pop (Stack s) = ...` and three lines
21:57:32 <kenndel> well i also had a seperate line with `pop (Stack []) = Stack []`
21:57:42 <kenndel> which is what my current line 11 is supposed to represent
21:58:06 <amalloy> so, you used pattern matching before
21:58:23 <kenndel> ya
21:58:33 <amalloy> are there any other constructs in haskell that support pattern matching?
21:59:29 <kenndel> everything? i honestly dont know the answer i just really learned about it earlier tonight with dmwit
22:00:37 <amalloy> kenndel: it seems you are being encouraged to use a case-expression
22:01:20 <amalloy> if you don't know what that is, i suggest looking it up, online or in whatever book you're studying from
22:02:34 <kenndel> ya the | stuff
22:08:10 <kenndel> so im not sure what my case expressions would be
22:08:18 <kenndel> empty stack, stack with data, 3?
22:08:36 <amalloy> i think you don't actually know what a case expression is
22:08:53 <amalloy> i propose that you can write this with no | clauses
22:09:51 <kenndel> oh the | are where clauses
22:10:02 <kenndel> you are right i was thinking of a different syntax
22:10:46 <amalloy> they're guards
22:10:51 <amalloy> where clauses are another different thing
22:12:03 <ab9rf> definitely not the same thing
22:12:18 <ab9rf> i dislike guards for some reason
22:12:39 <ab9rf> they smell funny
22:12:43 <amalloy> guards are pretty cool sometimes
22:13:01 <ab9rf> i have a distrust of anything that creates boolean values
22:13:29 <kenndel> oh so the 3 lines
22:13:31 <kenndel> are really 2?
22:13:38 <kenndel> the first line would be `case x of`
22:13:41 <kenndel> or whatever for x?
22:14:06 <amalloy> case s of makes a lot of sense
22:14:42 <ab9rf> i've been known to move guards into the case variable :)
22:15:19 <kenndel> ok so im getting indentation errors now
22:15:31 <kenndel> should case be on one indentation over on the line below?
22:15:40 <kenndel> im sort of indenting based off where case is on line 11
22:20:14 <kenndel> ya it for sure doesnt like my indenting https://repl.it/repls/BigBrokenHertz
22:21:03 <mjrosenb> I'm confused.  for some reason, cabal-install doesn't want to install >bitset-1.1
22:21:05 <MarcelineVQ> it's not an indentation issue, you need to google the syntax for case
22:21:11 <mjrosenb> it says it conflicts with QuickCheck
22:21:17 <mjrosenb> but it doesn't have a dep on it
22:21:32 <mjrosenb> and QuickCheck doesn't have a dep on BitSet.
22:22:46 <mjrosenb> oh, I may be reading that wrong
22:22:56 <mjrosenb> it is the dep on base that is mucking things up.
22:23:15 <mjrosenb> last updated 2014... makes sense.
22:23:29 <MarcelineVQ> oh these repl pads don't share edits
22:25:34 <MarcelineVQ> case x of     examines the constructors used to make x using pattern matching.   in the case of list that's [] or :    given some list s you would say
22:25:41 <MarcelineVQ> case s of
22:25:47 <MarcelineVQ>   [] -> something
22:25:51 <MarcelineVQ>   (x:xs) -> somethingelse
22:26:28 <MarcelineVQ> so given the two forms list can take we have two different somethings to fill in
22:26:38 <kenndel> oh wait did i just get it?
22:26:55 <kenndel> case s of [] -> Stack [], s -> Stack (tail s)
22:26:59 <kenndel> compiles
22:27:10 <MarcelineVQ> yes but you can avoid that tail using the form of  :
22:27:43 <kenndel> just s: ?
22:27:46 <MarcelineVQ> since : already gives you head:tail    in that  x:xs  case above x is the list head and xs is the tail
22:31:15 <mjrosenb> igh
22:31:17 <mjrosenb> https://gist.github.com/anonymous/07ee6f00237077870b48aedd64405e90
22:32:38 <MarcelineVQ> kenndel: https://repl.it/repls/SeparateOffbeatAdware
22:35:07 <kenndel> oh i see
22:35:21 <kenndel> cause using pattern matching we know that s:ss -> ss indicates everything but the first elem?
22:35:25 <mjrosenb> aaand, int2Integer# appears to not be defined anywhere anymore
22:38:41 <MarcelineVQ> yes since a list is either the empty list   []   or some value and the rest of the list   value:therest
22:49:44 <mjrosenb> so, it looks like gmp used to have this function, but they stopped supporting it
22:49:58 <mjrosenb> but I cannot find any documentation on what exactly it did
22:50:07 <mjrosenb> so I cannot implement it myself in a slower manner
23:42:40 <qeyoa> why is `True > False`? Is this definition arbitrary?
23:43:37 <qeyoa> *`True > False == True`
23:44:07 <geekosaur> it just uses the order of the constructors. I don't know offhand if anything takes advantage of False having constructor slot 0 (which matches C, where 0 is false and nonzero true)
23:44:34 <dmwit> It is arbitrary, but consistent with some choices made by other languages.
23:44:43 <qeyoa> thanks
23:44:47 <geekosaur> it certainly would simplify unpacking a Bool to pass it directly to C
