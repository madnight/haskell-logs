00:00:13 <epta> phadej: yep, response's Show instance is not perfectly formatted, btw there is no information regarding original request
00:00:14 <kadoban> The actual haskell report is currently lagging behind quite a bit unfortunately.
00:07:03 <josef_> how do I get `[[[a]]] -> [[[b]]]' without nesting fmaps?
00:09:03 <dminuoso> josef_: (fmap . fmap . fmap)
00:09:21 <dminuoso> josef_: You rather compose them, not nest =)
00:09:27 <josef_> exactly :)
00:09:28 <josef_> thanks
00:16:31 <Deng_> Hi there, I'm a newbie in haskell. I found that a 6-tuple of monoids is not an instance of Monoid, while a 5-tuple is. I think this is really weird. Why is this the case?
00:18:08 <liste> Deng_: could be just laziness https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-301
00:18:23 <ab9rf> Deng_: because notmany people use six-tuples or larger, and so nobody declared the six-tuple instance
00:18:28 <geekosaur> large tuples are disrecommended in general except when you need to produce multiple values as a result, so most instances stop at 5. only the most basic ones go beyond, and even they chop off well before the largest tuple GHC supports
00:19:43 <geekosaur> (I think things like Eq go up to 15.)
00:20:03 <Deng_> Thanks a lot! I think I'm just going to live with this fact :)
00:22:50 <dminuoso> I wonder whether it'd be easy to get a PR in to extend this for longer tuples
00:23:25 <geekosaur> depends on the maintainer. large tuples *are* a bit of a PITA
00:23:57 <dminuoso> geekosaur: Well, that comment down near the bottom is abit.. interesting: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Tuple.html#%28%2C%29
00:24:24 <geekosaur> I was considering mentioning that, tbh
00:24:33 <geekosaur> nobody's been able to track down that bug
00:24:57 <geekosaur> then again, I would argue that if you need a tuple that large, you might want to reconsider your approach
00:25:19 <geekosaur> you're kinda approaching beating yourself in the head because it eels so good when you stop" territory
00:26:37 <kadoban> geekosaur: xD lol that's like still a bug? I just assumed that was historical/funny.
00:27:11 <geekosaur> unless someone accidentally fixed it as a side effect of something else, yes.
00:27:35 <dminuoso> geekosaur: Well if it was accidentally fixed, you could bisect the repo and find the fix.
00:27:46 <geekosaur> right. but nobody's been arsed to check
00:28:46 <kadoban> That would be one of the first things I'd look if I ever worked on ghc. "this segfaults and we have no idea why" is not something I can resist in a project.
00:32:49 <dminuoso> kadoban: I guess it's a valid approach. Seg faulting means some piece of code _really_ is not doing what it's intended to do. In a compiler that's not a good thing generally.
00:33:32 <dminuoso> otoh if it seems to be fine, there is probably really low motivation to fix something that just enables you to have 101+ sized tuples
00:35:03 <kadoban> Yeah, if that's the only time it comes up it's fairly useless. But it's sure tempting to think that there'd be at least *some* other case something similar might be happening.
00:39:32 <geekosaur> there are *very* few cases where ghc dumps core that haven't been tracked down. and this one is old enough that it's probably safe to conclude that it's no more general than that
00:41:18 <geekosaur> also note that this may well be a *very* special case: since tuples are wired-in types, the only reason those kind of 'data' declarations exist is to force generation of info tables for runtime
00:41:23 <phadej> epta: Response doesn't carry Request info, iirc
00:42:04 <geekosaur> and as wired-in types go, tuples are themselves highly special (check the GHC Commentary)
00:44:12 <dminuoso> geekosaur: Wow I am amazed. Just checked out the Commentary you named, and I'm baffled by the amount of documentation on GHC itself.
00:44:38 <dminuoso> Makes me so jealous.. over a year ago I was hacking inside GCC to understand codegen details relevant to writing my own kernel.
00:44:53 <dminuoso> It was mostly just digging through hundreds of thousands of lines of code, with basically no information and documentation..
00:45:14 <geekosaur> between the Commentary and embedded [Note]s, ghc is *very* well documented
01:27:53 <kuribas> emacs haskell-mode can be such a pain...
01:28:09 <nullie> Get intero
01:28:34 <kuribas> I mean, when it works it's fine, but when it doesn't, it just hangs, or doesn't give any error message.
01:28:47 <nullie> Yeah
01:29:17 <kuribas> it also seems fragile to changes in ghc version.
01:31:41 <nullie> It worked for 7.10.3 to 8.2.1
01:32:33 <kuribas> I'm on 8.2.2
01:33:13 <nullie> I wonder if I could add support
01:40:53 <kuribas> I reinstalled haskell-mode and restarted emacs, now it works.  Weird...
01:49:20 <geekosaur> maybe someone patched haskell-mode. 8.2.2 changed something that broke it; there has been quite a lot of screaming since
01:50:40 <geekosaur> (dropped the list of loaded modules emitted just before the first prompt, iirc. which haskell-mode was relying on.)
02:12:19 <kuribas> yeah, must be
02:12:31 <kuribas> something else: anyone know why I cannot install haskell-docs?  http://lpaste.net/362781
02:12:55 <kuribas> it install haddock, then says it cannot find it...
02:23:11 <kuribas> is haddock-2.18.1 too new for haskell-docs?
02:23:26 <kuribas> haskell-docs is from 2016
02:23:51 <merijn> kuribas: Is that in a sandbox?
02:23:56 <kuribas> no
02:24:47 <merijn> kuribas: Try running with -v3?
02:26:50 <guest_> hi guys, i am trying to use logBase function in haskelll for very large integer as  input  but it is giving output as Infinity,
02:28:59 <guest_> hi guys, i am trying to use logBase function in haskelll for very large integer as  input  but it is giving output as Infinity can any one tell why it is giving this output
02:29:20 <kuribas> merijn: http://lpaste.net/362781
02:29:54 <merijn> guest_: Because you're getting a Double result and overflowing the max value of Double
02:30:00 <geekosaur> because it's using floating point, not integer, and floating point has limits
02:30:03 <merijn> > 1/0 :: Double
02:30:05 <lambdabot>  Infinity
02:30:49 <guest_> <geekosaur> : any solution ?
02:31:11 <merijn> :t logBase
02:31:12 <lambdabot> Floating a => a -> a -> a
02:31:21 <geekosaur> some gaming libraries specifically implement integer logs
02:31:23 <guest_> <merijn> : any solution?
02:31:40 <merijn> CDouble, maybe?
02:31:59 <geekosaur> if you know a language where that works, you can probably look up how. most use IEEE FP and you're out of luck without custom libraries
02:32:10 <merijn> oh, wait CDouble is the wrong type, not what I thought
02:33:34 <guest_> <geekosaur> : which libray to use ?
02:33:37 <kuribas> guest_: must be a really huge number then...
02:33:56 <kuribas> guest_: is it a math problem?
02:34:27 <guest_> <kuribas>: yes it is very large no, but it works when hard coded but does not work on Integer return value  of function
02:36:17 <kuribas> > logBase 2 (fromIntegral 2738242074890274892074892074890274890278940278940728362673784207840278402784078916)
02:36:19 <lambdabot>  270.52942567988123
02:36:59 <kuribas> guest_: why do you need such a large number?
02:38:29 <guest_> <kuribas> : thanks that fromIntegral thing works :) I was working on some public key  stuff that is very large so that's why need very large integer
02:38:33 <guest_> :)
02:39:30 <kuribas> guest_: it shouldn't even work without fromIntegral, because logBase takes a Double
02:40:31 <kuribas> guest_: also using float for public key stuff isn't probably the right way.
02:40:44 <kuribas> because you are using approximations.
02:40:57 <guest_> <kuribas>  : you are right
02:41:02 <merijn> "probably isn't" <- sure as fucking hell isn't
02:43:16 <jdelouch> > take 5 [1..]
02:43:18 <lambdabot>  [1,2,3,4,5]
02:43:41 <jdelouch> @pl \xs n -> take n xs
02:43:41 <lambdabot> flip take
02:46:18 <jdelouch> @djinn (a, b) -> c -> (b, c)
02:46:18 <lambdabot> f (_, a) b = (a, b)
02:47:17 <jdelouch>  @unmtl StateT s IO a
02:48:58 <jdelouch>  @unmtl StateT s IO a
02:49:27 <jdelouch> @undo do { x <- getLine; print x }
02:49:27 <lambdabot> getLine >>= \ x -> print x
02:49:40 <guest_> \quit
02:50:00 <jdelouch> @hoogle [a] -> [a]
02:50:01 <lambdabot> Prelude tail :: [a] -> [a]
02:50:01 <lambdabot> Prelude init :: [a] -> [a]
02:50:01 <lambdabot> Prelude reverse :: [a] -> [a]
02:54:21 <batman_> how to convert a custom data Type to ByteString
02:54:48 <merijn> batman_: Have a look at the binary package
02:54:54 <merijn> @hackage binary
02:54:54 <lambdabot> http://hackage.haskell.org/package/binary
02:55:50 <raichoo> Ah merijn bet me to it. Damn you slow train-wifi ^^.
02:57:24 <merijn> raichoo: binary is one of those "I didn't appreciate how much this task sucked in other languages until I found this library" things :)
02:57:35 <merijn> Like parsing and pipes/conduit
02:58:42 <raichoo> merijn: yeah, anyway. I'm getting off the train soon. See you around :)
03:00:45 <batman_> merijin : can you point to more specific topic of the documentation , otherwise i'll never be sure of approach i'm taking also can't we use Data.ByteString.Char8 for that >> ?
03:01:52 <kuribas> merijn: apparently haskell-docs doesn't compile with 8.2.0
03:18:07 <batman_> merijin : can you please help with converting custom datatypes to ByteString
03:18:09 <kuribas> merijn: fixed: https://github.com/ivan-m/haskell-docs/pull/35
03:18:13 <ocharles> Does `data Two a = Two (a, a)` with `Functor`, `Applicative`, `Monad` exist anywhere obvious? Can I build it out of smaller pieces? It feels like Pair Identity Identity, but I'm not sure if it is
03:18:26 <ocharles> `Product Identity Identity`*
03:19:09 <ocharles> Oh, I think it is just that actually now
03:24:53 <Tudou> i posted a question about a possible regression, can someone have a look please:) https://www.reddit.com/r/haskellquestions/comments/7ze1ad/is_this_a_regression_in_ghc_821/
03:29:46 <dminuoso> Tudou: By the way the current README.md does not line up with the repository.
03:29:49 <dminuoso> Probably a non issue though.
03:33:06 <Tudou> oh, what doesn't line up?
03:34:38 <MacSlow> Which is the current/de-facto documentation regarding Haskell's multi-threading support?
03:35:55 <dminuoso> Tudou: there is no text\NotWorking.hs or iDontWork =)
03:36:22 <Tudou> yea it's in model/test/NotWorking.hs
03:36:47 <Tudou> the error message from ghc doesn't mention the package's dir is all
03:37:16 <dminuoso> Ohh, gotcha. :)
03:39:17 <dminuoso> Tudou: I cant reproduce it at all. Should it just be `stack build` ?
03:39:22 <brynedwards> Works for me with stack 1.6.3
03:39:56 <dminuoso> Also using 1.6.3
03:40:50 <Tudou> `stack test` as per the readme, otherwise the tests don't get built
03:41:15 <brynedwards> Ah yeah
03:45:26 <frerich> Hi all! I'm trying to solve a little programming puzzle which asks to define a function '[Int] -> Int' such that the function yields the largest sum of any of the subarrays (a subarray is a contiguous subsequence here) of the given list. I have various solutions for this, but unfortunately they are all too slow!
03:45:51 <frerich> My latest solution tries to be clever by using scanl to compute the sums of some subarrays on-the-fly:
03:45:53 <frerich>   maxSubAry = maximum . map (maximum . (\(a:as) -> scanl' (+) a as)) . init . tails
03:46:12 <frerich> Alas, this still seems to be too slow for the website to accept it as a solution. Does anyone have some ideas how to improve this?
03:46:54 <frerich> (the input list to this function holds between [1..10000] elements)
03:48:10 <frerich> For what it's worth, some more background information is available at https://www.hackerrank.com/challenges/maxsubarray/problem
03:48:10 <kuribas> frerich: it can be done in linear time
03:48:28 <kuribas> frerich: the trick is to keep track of both ends.
03:48:43 <frerich> Hmmm....
03:49:46 <kuribas> oh great, switch-to-haskell hangs again...
03:49:58 <frerich> For what it's worth, I read that there is apparently a well-known algorithm for this, but I'd like to not spoil the fun but rather come up with something myself :-)
03:51:32 <frerich> One idea I had was to do something like 'shifting windows', one for each length of subarrays. The idea being that I don't need to sum up every array from scratch, I could just subtract the first element and add the next element to get the next sum.
03:52:04 <TMA> frerich: go further with your idea
03:52:28 <TMA> frerich: look what you can make more general
03:53:21 <sepakorayl> hello everyone
03:54:03 <sepakorayl> does anyone have any problems with ghc-mod's GhhcModFuncCaseSplit ?
03:54:46 <sepakorayl> I get a Non Splittable Constructor error
03:55:07 <sepakorayl> ghcmod-vim's*
03:56:00 <joe9> is there a strict version of >>?
03:56:21 <joe9> I mean the bind operator.
04:01:03 <kuribas> frerich: just do it one element at a time.
04:01:31 <kuribas> frerich: so you have the total largest sum of the elements processed so far, and you have the largest sum of the list that end and that position.
04:03:41 <dminuoso> What would you call something like * -> * or * -> * -> *? Are those rank 1 types?
04:03:49 <frerich> kuribas: I guess that would work, yeah. Another idea I'm currently toying with: define the sums of the sub arrays in terms of the sums of shorter sub arrays. E.g. the sum of the first 5-element sub array will be the sum of the first 4-element sub array, plus the fifth element.
04:03:51 <dminuoso> Basically Im trying to find the correct terminology what typeclasses are for.
04:04:24 <dminuoso> Because you can not only have them for concrete types, but also type constructors. But that terminology feels imprecise, so Im wondering whether there's a universal "name" that covers Int, Either and StateT.
04:04:34 <guessWho> :t Int
04:04:36 <lambdabot> error:
04:04:36 <lambdabot>     • Data constructor not in scope: Int
04:04:36 <lambdabot>     • Perhaps you meant one of these:
04:04:54 <guessWho> :t f a b = a +b
04:04:55 <lambdabot> error:
04:04:55 <lambdabot>     parse error on input ‘=’
04:04:55 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
04:05:09 <dminuoso> guessWho: :t requires an expression.
04:05:14 <guessWho> print "Damnnnnnnnn"
04:05:30 <dminuoso> :t let f a b = a + b in f
04:05:31 <lambdabot> Num a => a -> a -> a
04:05:36 <kuribas> frerich: if it goes below 0, make it 0 (the sum of an empty list).
04:05:36 <merijn> dminuoso: Bzzt
04:05:48 <merijn> dminuoso: You can easily create typeclasses for non "concrete" types
04:05:51 <kuribas> frerich: that might work, but with worse complexity.
04:06:01 <dminuoso> merijn: My question is.. would you call "Maybe" a type too?
04:06:02 <merijn> dminuoso: Also, note that the term "concrete" type is ambiguous and should be avoided for that reason
04:06:13 <merijn> dminuoso: And yes, "Maybe" is a type too
04:06:27 <dminuoso> merijn: And it's inhabited by things like Maybe Int, Maybe Float, etc. ?
04:06:42 <merijn> dminuoso: The problem with "concrete" type is that no one can agree whether polymorphic types like "Maybe a" are concrete or not
04:07:08 <merijn> dminuoso: So I generally recommend explicitly talking about "type of kind *", "monomorphic type", etc.
04:07:10 <dminuoso> merijn: Or let me ask instead. If Maybe is a type, then what values inhabit it?
04:07:19 <merijn> dminuoso: Not all types are inhabited
04:07:32 <merijn> dminuoso: In fact, in Haskell only types of kind * can be and are inhabited
04:07:55 <merijn> dminuoso: So the most specific/correct way to refer to inhabited types is "type of kind *"
04:09:08 <dminuoso> merijn: Understood. So even something like StateT itself is a type
04:09:42 <merijn> dminuoso: Right
04:09:48 <dminuoso> merijn: Is this a bit akin to how functions are considered values?
04:09:59 <dminuoso> as in both `id` and `id 5` are values
04:10:13 <merijn> dminuoso: Yes
04:10:24 <dminuoso> merijn: Great, thank you. =)
04:10:34 <merijn> dminuoso: Well, in case of StateT/Maybe it's more like how data constructors are values too
04:14:47 <merijn> hmmm
04:15:15 <merijn> Is there a generic "any numeric type to Fractional" conversion function?
04:15:29 <Boarders> I was looking at some old document written about shake and came across a reference to a function capture
04:15:34 <Boarders> does anyone know where that is defined
04:15:55 <Boarders> is it a part of some version of shake or some other library?
04:16:20 <Bish> hello, why doesn't xs = [0..]; (x:xs) = xs work?
04:18:00 <Boarders> Bish: what are you trying to do?
04:18:11 <dminuoso> merijn: This is interesting. So this begins to make sense if I lose the notion that types _have_ to have values. And I should know this because we have Void.
04:19:41 <dminuoso> So a type is just some algebraic thing (where we can use (+), (*), (:.:) etc to do algebra) that have information attached to them (which values inhibit them).
04:20:44 <merijn> dminuoso: Void has value, though
04:20:50 <dminuoso> Well. Aside bottom =)
04:21:11 * dminuoso was doing fast and loose reasoning!
04:21:18 <merijn> dminuoso: Anyway, yes, from a type theory perspective you wanna let go of the idea that types always have values
04:21:54 <merijn> dminuoso: At which point things actually become simpler and more elegant, because the type level starts looking at lot like the value level
04:22:08 <Bish> Boarders: learning haskell
04:22:23 <Bish> or rather understanding haskell
04:22:32 <Boarders> no I just meant what do you expect that to do?
04:22:33 <Bish> there is no plan, playing around with lists
04:22:42 <merijn> dminuoso: Also, in case it hasn't been recommended yet, if you wanna dive into typing you probably want to get a copy of Types and Programming Languages by Benjamin Pierce
04:22:45 <Bish> x to be 0 and xs to be [1..]
04:22:49 <Bish> and when i do it again
04:22:53 <Bish> x to be 1 and xs to be [2..]
04:23:10 <Bish> OR an error, because you do that only once
04:23:14 <Bish> but it doe snone of that
04:23:36 <hpc> definitions in haskell are immutable
04:23:48 <Bish> so why do i not get an error?
04:24:02 <hpc> you've defined that xs = [0..], and then written a conflicting definition of xs in (x:xs) = xs
04:24:22 <Bish> okay, i understand that.. but something does happen, doesn't it?
04:24:28 <hpc> the second one is mutually recursive, so it'll never be able to compute either x or xs
04:24:41 <hpc> if you did this in ghci, then the second xs definition is shadowing the first one
04:25:10 <Bish> "shadowing"
04:25:10 <Bish> ?
04:25:24 <Boarders> > let a = 5
04:25:26 <lambdabot>  <no location info>: error: not an expression: ‘let a = 5’
04:25:29 <Boarders> > let a = 6
04:25:31 <lambdabot>  <no location info>: error: not an expression: ‘let a = 6’
04:25:32 <Boarders> > a
04:25:34 <Boarders> 6
04:25:34 <lambdabot>  a
04:25:39 <hpc> where you define a variable name in one scope that's the same as in an outer scope
04:25:52 <hpc> in the inner scope, you can use only the variable doing the shadowing
04:25:52 <Boarders> (whoops didn't mean to invoke lambdabot)
04:26:09 <hpc> in the outer scope, the shadowing definition is dropped and you can use the shadowed definition
04:26:35 <dminuoso> merijn: That book looks like it's within my reach. Thank you =)
04:26:49 <dminuoso> It seems some university is hosting a free copy of that. I wonder whether that's.. legal.
04:27:21 <hpc> dminuoso: universities usually have special arrangements for their students
04:27:32 <hpc> unlimited access to papers and such
04:27:35 <dminuoso> hpc: Ah, so I guess I just found a link that is not meant to be public.
04:27:37 <merijn> dminuoso: It's written to be a book that can be used for undergrad classes (at least the first halves or so) and it's *the* de facto standard intro to type theory
04:28:02 <merijn> dminuoso: Starts with untyped lambda calculus and works up to Hindley-Milner and beyond, including example implementations, etc.
04:28:23 <dminuoso> Sold.
04:28:34 <toby1851> and it's $95 ! :(
04:28:56 <dminuoso> toby1851: Deductible =)
04:29:00 <hpc> that's the downside of it being the de facto textbook
04:29:09 <hpc> textbook prices
04:29:44 <ventonegro> The Kindle's version of TAPL is surprisingly beautiful
04:31:22 <dminuoso> hpc: Regarding Bish's example - why doesn't `let (x:xs) = xs in x` halt though? I mean without any head element to build a spine from, what does this do?
04:31:46 <toby1851> i'll run it past my boss - i had a Go book on my last expenses claim (sorry) :)
04:31:51 <dminuoso> merijn: Yeah I mean I've dived into Hindley Milner before. I can read and understand the rules - but I dont understand why or how to implement it.
04:32:02 <hpc> ooh, amazon has it on sale
04:32:03 <dminuoso> So this book sounds like it's what I need to feel more comfortable.
04:32:16 <hpc> $63, and i still have a gift card balance
04:32:33 <merijn> dminuoso: Yes, this is *the* book for "huh, it'd be cool to implement a hindley-milner language myself!"
04:32:59 <merijn> dminuoso: Well, he never inspects the head until the pattern match finishes
04:34:00 * hpc bought himself a copy
04:35:31 <bortzmeyer> @hoogle String -> Int
04:35:31 <lambdabot> System.Console.ANSI cursorUpCode :: Int -> String
04:35:31 <lambdabot> System.Console.ANSI cursorDownCode :: Int -> String
04:35:32 <lambdabot> System.Console.ANSI cursorForwardCode :: Int -> String
04:35:44 <hpc> @cohoogle Int -> String
04:35:44 <lambdabot> System.Console.ANSI cursorUpCode :: Int -> String
04:35:44 <lambdabot> System.Console.ANSI cursorDownCode :: Int -> String
04:35:44 <lambdabot> System.Console.ANSI cursorForwardCode :: Int -> String
04:36:13 <geekosaur> :t read
04:36:14 <lambdabot> Read a => String -> a
04:36:32 <bortzmeyer> :t length
04:36:33 <lambdabot> Foldable t => t a -> Int
04:37:21 <bortzmeyer> @cohoogle String -> Int
04:37:22 <lambdabot> System.Console.ANSI cursorUpCode :: Int -> String
04:37:22 <lambdabot> System.Console.ANSI cursorDownCode :: Int -> String
04:37:22 <lambdabot> System.Console.ANSI cursorForwardCode :: Int -> String
04:37:48 <dminuoso> merijn: So it seems like its equivalent to an infinitely deep stack of head $ head $ head $ head - but it cant refute it until some list has been produced..
04:37:57 <hpc> (cohoogle is just hoogle, lambdabot autocorrects commands with levenstein distance)
04:38:13 <fendor> :t uncurry
04:38:14 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:38:51 <dminuoso> :t let h' f s = h' (f s) in f'
04:38:52 <lambdabot> error:
04:38:52 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t0 -> t
04:38:52 <lambdabot>       Expected type: t -> t1
04:39:16 <dminuoso> Shame, tried to fix that function.
04:41:06 <dminuoso> hpc: Shouldn't cohoogle take function names, and tell you their types? =)
04:41:31 <dminuoso> Just for category theory correctness sake.
04:41:51 <bortzmeyer> @hoohle length
04:41:52 <lambdabot> Prelude length :: Foldable t => t a -> Int
04:41:52 <lambdabot> Data.List length :: Foldable t => t a -> Int
04:41:52 <lambdabot> Data.Foldable length :: Foldable t => t a -> Int
04:42:00 <bortzmeyer> @hoogle length
04:42:00 <lambdabot> Prelude length :: Foldable t => t a -> Int
04:42:00 <lambdabot> Data.List length :: Foldable t => t a -> Int
04:42:00 <lambdabot> Data.Foldable length :: Foldable t => t a -> Int
04:49:44 <batman_> are Data.ByteString.Lazy.Internal.ByteString and ByteString same type >>?? more importantly can they be used interchangeably
04:50:01 <quchen> No and no
04:50:58 <quchen> There are strict and lazy variants of bytestrings, and they’re distinct. But you can convert between the two.
04:51:04 <Minichiello> Do you care of OSS destiny? Want freedom of choice? Don't want systemd to eat your privacy? Join #devuan
04:51:15 <Plancon> Do you care of OSS destiny? Want freedom of choice? Don't want systemd to eat your privacy? Join #devuan
04:51:19 <zoplcfimx> Do you care of OSS destiny? Want freedom of choice? Don't want systemd to eat your privacy? Join #devuan
04:51:21 <xjghehbeptcoark> Do you care of OSS destiny? Want freedom of choice? Don't want systemd to eat your privacy? Join #devuan
04:51:28 <Plancon> Disagree with systemd politics? Join #devuan
04:51:44 <zoplcfimx> Disagree with systemd politics? Join #devuan
04:51:46 <Plancon> do not spend your time with privacy-violating distros, join #devuan
04:51:57 <Plancon> Join #devuan NOW
04:53:26 <quchen> :t Data.ByteString.Lazy.fromStrict
04:53:28 <lambdabot> BSC.ByteString -> BSLC.ByteString
04:54:07 <quchen> BSC? Strange. Oh well, that’s what the function is called.
05:00:21 <mniip> I guess ghc tries to find any name under which it is imported
05:01:59 <mniip> :t Refl :: BS.ByteString :~: BSC.ByteString
05:02:01 <lambdabot> BSC.ByteString :~: BSC.ByteString
05:15:09 <geekosaur> guessing its because it's a re-export and ghc returns either the first or the last qualified name it finds for it. which is arguably bad, but also probably expensive to do in a more user-friendly way
05:19:15 <mniip> I don't think there's even a coherent way to do it more specifically
05:19:45 <geekosaur> yeh, was just thinking that myself. reexports + how the haskell standard specifies this = no good solution
05:19:55 <geekosaur> (how qualified names work, that is)
05:20:19 <geekosaur> maybe even ignoring the standard
05:30:42 <phadej> if you do import qualified Data.ByteString as BS1; import q... as BS2; ... as BS3; which name is the best? :)
05:30:58 <phadej> first one, last one? real one (i.e. internal module)?
06:06:09 <sepakorayl> is there any good solution for vim integration with case splitting etc?
06:11:18 <dminuoso> Is this an accurate depiction of how thunks are evaluated when evaluating `length [1,2,3]`? https://gist.github.com/dminuoso/10327213b236eb39ea1a70b791ca32c7
06:11:52 <phadej> yes
06:12:12 <phadej> for future, you could write e.g. _:_:_:[] where _ stands for thunk
06:12:18 <phadej> much more compact :)
06:12:35 <phadej> > length (undefined : undefined : undefined : [])
06:12:37 <lambdabot>  3
06:13:34 <dminuoso> phadej: I see. So I guess the word "spine" comes from the fact that (:) are kind of like vertebrae =)
06:13:46 <dminuoso> With stuff attached to it
06:14:02 <merijn> dminuoso: Correct
06:15:24 <EvanR> a long tree branch with fruit, or a bomb at each position
06:16:39 <bash0r> I read some time ago that it's good practice to list all functions / data types which you import from a module. Is this true?
06:17:27 <merijn> bash0r: Depends on the modules, but it does make it easier to figure out where specific functions are coming from
06:18:08 <merijn> bash0r: Imagine you from 2 years in the future trying to reread code and forgetting where reallyComplexFunctionName came from. If it's explicitly imported you can just look in the imports which module it comes from to find the docs
06:18:20 <bash0r> merijn: I don't mean something generic like Prelude or Control.Applicative.
06:18:29 <dminuoso> merijn: That particular bit could be considered an editor problem though.
06:18:42 <merijn> bash0r: Nowadays I even list Control.Applicative explicitly, tbh
06:18:42 <phadej> dminuoso: not really, there's practical benefit too
06:18:53 <phadej> https://wiki.haskell.org/Import_modules_properly
06:19:00 <quchen> Haskell editors are shitty so we sometimes hack our way around these things.
06:19:02 <bash0r> dminuoso: I agree with merijn in this point because I don't use much editor integration.
06:19:03 <phadej> by explicit lists or qualified imports you safe yourself from name clashes
06:19:14 <merijn> ^^
06:19:20 <dminuoso> phadej: Oh yeah. I was not trying to argue against his position, just wanted to point out that the reason to "see where it comes from" alone is not a good enough reason
06:19:49 <bash0r> Though, how to handle very long import lists? Just make it a qualified import?
06:19:59 <merijn> bash0r: Line wrap or qualify
06:20:25 <bash0r> Thanks everybody!
06:22:06 <quchen> Use stylish-haskell
06:22:21 <merijn> bash0r: Also, note that you can actually import multiple modules with the same qualification which can be nice sometimes
06:23:23 <merijn> bash0r: i.e. "import qualified Data.Foo as F; import qualified Data.Bar as F" which can be nice when importing 3 modules from the same library
06:25:35 <quchen> import qualified Data.Text as T; import qualified Data.Text.IO as T
06:26:00 <merijn> quchen: I have that one so many times >.>
06:26:05 <quchen> :-)
06:26:45 <quchen> import Data.Set (Set); import qualified Data.Set as S
06:26:51 <quchen> That one should also have a shortcut.
06:27:07 <merijn> quchen: It was proposed but died, I think
06:27:12 <merijn> But I agree, yeah
06:29:03 <phadej> what you want is be able to export qualified names
06:29:09 <bash0r> Ahh, that's good to know.
06:29:36 <bash0r> quchen: I have that one on Data.ByteString :p
06:29:41 <phadej> module MyPrelude (module Prelude, module qualified Data.Set as S, Set, ...) where
06:29:53 <merijn> phadej: That too
06:30:11 <bash0r> phadej: does that actually work or is it a proposal?
06:30:11 <phadej> but I don't know what that would break :)
06:30:25 <phadej> it's an idea tossed around
06:30:52 <bash0r> I though about something similar many times. I think it would reduce some boilerplate a lot.
06:33:33 <phadej> it's not trivial change to compiler :/
06:36:03 <cocreature> that’s true for qualified reexports but at least the shortened import syntax would be quite trivial and anthony even had a patch when he proposed it. it just died in endless bikeshedding discussions :(
06:36:40 <phadej> syntax-only changes have that problem
06:36:56 <cocreature> wadlers law :)
06:37:01 <bash0r> Discussion about syntax is a war of religions. ^^
06:37:56 <phadej> otoh I do understand the POV, "if the change only makes you save single line, but compiler maintainers have to keep that in mind for the rest of their life"
06:38:01 <phadej> that's not obvious trade-iff
06:38:03 <cocreature> I kind of want to try and revive it now that we have the ghc-proposal’s process but I worry too much that it ends the same as it ended last time
06:38:17 <oldbrad> in modula 2 qualified import is effectively enforced. where is the disadvantage?
06:39:05 <phadej> using Control.Lens qualified would be impossible :)
06:39:25 <bash0r> oldbrad: we like our short function names. Operators feel very clunky when they are qualified.
06:40:16 <bash0r> import qualified Prelude as P
06:40:21 <bash0r> 10 P.+ 20
06:40:30 <EvanR> concrete syntax :((
06:40:31 <bash0r> It just feels awkward even if it works.
06:41:07 <EvanR> its just ink
06:41:29 <phadej> (and personally I don't use LambdaCase nor will use BlockArguments)
06:42:31 <bash0r> phadej: I didn't know about BlockArguments yet. This feels kinda redundant to f $ do ...
06:43:14 <phadej> bash0r: but in foo >>= \x -> ... it doesn't when you write that
06:43:15 <EvanR> forM_ [0..n-1] $ \i -> do
06:43:35 <phadej> but that conversation is done, and blockarguments are the thing
06:43:39 <EvanR> this has been so ingrained by now, removing the $ would make my brain explode
06:43:48 <phadej> EvanR: indeed d:)
06:43:57 <phadej> except, `for_ ` :)
06:44:05 <EvanR> er, right
06:44:12 <phadej> but that's small thing
06:44:19 <EvanR> in Traversable we trust
06:44:21 <bash0r> phadej: in foo >>= \x -> ... the whole right of (>>=) is a single expression. I know some internals about parsing and grammars so it does not look awkward to me.
06:44:43 <ongy> When I have a line in core that's `case sc as wild of`, is that a case-of + an alias, without any matching on sc?
06:45:26 <bash0r> ongy: what kind of extension is it that allows that syntax? o.O
06:45:39 <geekosaur> it's core, not haskell
06:45:47 <bash0r> Ahh, nevermind.
06:46:12 <EvanR> i am jealous of that feature of core
06:46:39 <phadej> EmptyCase? I don't understand?
06:46:51 <hyperisco> > let sc _ _ = (); as = (); wild = (); in case sc as wild of _ -> "Haskell too!"
06:46:53 <lambdabot>  "Haskell too!"
06:47:10 <EvanR> :|
06:47:37 <EvanR> phadej: case e as e' of...
06:47:40 <bash0r> hyperisco: cheater detected.
06:47:53 <phadej> EvanR: ah I see
06:47:58 <ongy> I just wish the core I'm staring at had unique names, or at least unique names in their scope. And didn't rely on weird things
06:48:31 <EvanR> core is for hackers, you have to be able to read hacker
06:48:33 <oldbrad> bash0r: in that case import longwidget as w works fine. The real point of enforcing however is that one always knows at a glace where longwidgget is defined.
06:48:44 <phadej> bash0r: so is single expression on the right of $ in `foo $ do ... `
06:50:10 <phadej> but OTOH if omitting $ makes someone happy, and it's not big change to parser, than why noy.
06:50:55 <EvanR> hold on i might be swayed by this
06:51:10 <bash0r> Ohh, they do disambiguation by indentation again. Makes sense.
06:51:12 <EvanR> f
06:51:15 <EvanR>   do ...
06:51:17 <EvanR>   do ...
06:51:22 <EvanR> brilliant
06:51:26 <cocreature> ongy: huh? as long as you don’t omit uniques explicitely names should be unique iirc
06:51:36 <EvanR> no amount of $ will let you do that sanely
06:51:53 <bash0r> Extension enabled. :D
06:53:14 <hyperisco> so, file system paths … interesting beasts
06:53:51 <hyperisco> ignoring special directories, relative directory paths are a simple monoid
06:54:20 <hyperisco> absolute paths are a different structure you can only append on the right of
06:54:33 <hyperisco> relative file paths are a different structure you can only append on the left of
06:54:48 <hyperisco> absolute file paths have no append operation
06:55:04 <phadej> Path Abs|Rel Dir|File
06:55:16 <phadej> @package path
06:55:17 <lambdabot> http://hackage.haskell.org/package/path
06:55:21 <hyperisco> any idea what these left-only-append and right-only-append structures are?
06:55:34 <phadej> lists
06:55:44 <phadej> :)
06:55:45 <lyxia> monoid actions
06:55:49 <alp> well, left / right actions fit the bill
06:56:06 <hyperisco> lists would be an example
06:56:23 <hyperisco> worth noting that left vs right is really just flipping the operator
06:56:33 <hyperisco> it will have type  A -> B -> A  or  B -> A -> A  for some  A, B
06:56:55 <ongy> cocreature: I'm using core-dump package/compiler plugin to get an html dump, which mpickering suggested a few days ago. And it's really not the best at keeping names unique
06:56:59 <alp> https://en.wikipedia.org/wiki/Semigroup_action & same with monoid, group, depending on what you have at hand
06:57:12 <ongy> I have a line: let! ww as Seat ww ww ww ww ww ww ww ww = w in
06:57:17 <hyperisco> and there should be an identity  e :: B
06:57:26 <mpickering> but you can hover over them to see which one is which :)
06:57:40 <maerwald> is there a haskell playground?
06:57:42 <ongy> I know. That's how I'm dealing with it
06:57:51 <ongy> it's just annoying thatI can't just see it staring at text
06:58:06 <mpickering> I'm sure it would be easy to patch to add the uniques
06:58:10 <hyperisco> so  (⊕) :: A → B → A   x ⊕  e = x
06:58:33 <ongy> also, some of the inlining that's going on with -O2 is scary
06:58:37 <alp> right, you're describing t he action of a monoid on a set
06:58:38 <hyperisco> I will take a look lyxia, alp, thanks
06:58:50 <mpickering> The same inlining happens with -O and -O2
06:58:51 <alp> lyxia was spot on :)
06:59:04 <mpickering> -O2 only turns on "-fspec-constr" and "-fliberate-case"
07:00:13 <EvanR> hmm where do i go to learn about specific optimizations ghc does
07:00:46 <mpickering> The best reference is Santos' PhD thesis
07:01:09 <mpickering> I also gave a talk about some simple ones at the haskell exchange this year
07:01:24 <EvanR> erm santos' phd thesis... google hasnt heard of them
07:02:00 <mpickering> Compilation by Transformation in the Glasgow Haskell Compiler
07:02:06 <mpickering> Is an associated paper
07:02:48 <mpickering>  Compilation by transformation in non-strict functional languages
07:02:57 <mpickering> Is the title of the PhD thesis
07:03:15 <hyperisco> eh I don't know, because a semigroup action implies there is a semigroup, and I don't see what the semigroup is given, for example, absolute directory paths
07:03:49 <hyperisco> we really just have the action and not a semigroup
07:06:09 <cocreature> hyperisco: relative diretory paths form a semigroup under concatenation, no?
07:06:16 <cocreature> and then you can have them act on absolute directory paths
07:06:17 <hyperisco> yes
07:06:46 <hyperisco> oh maybe I read it backwards…
07:06:53 <hyperisco> so the monoid/semigroup is acting on the set?
07:07:22 <cocreature> yep
07:07:22 <hyperisco> yeah okay, gotcha… makes perfect sense now
07:07:36 <hyperisco> indeed a monoid action then! neato burrito
07:08:22 <EvanR> thanks
07:08:35 <hyperisco> so there is a theory for those things … then about the special directories … not sure about that yet
07:09:07 <mniip> it's a monoid
07:09:12 <mniip> "." is the identity
07:09:14 <hyperisco> well, '.' is equivalent to the empty directory, so that is fine
07:09:19 <EvanR> i totally thought you were going to bring up the issue with concrete rep of paths on different OS
07:09:29 <hyperisco> but then what is the explanation of '..' I am not so sure
07:09:54 <mniip> well it's not a free monoid
07:09:59 <hyperisco> EvanR, not really an issue as far as I can tell
07:10:10 <EvanR> if you include . and .., youre really talking about the concrete syntax of a small language which needs semantics, and abstract syntax for that matter. not "strings"
07:10:11 <mniip> rather is is the free monoid under quotient  x/.. = .
07:10:35 <EvanR> "strings" is heavy scare quotes
07:10:52 <hyperisco> so, a first guess is that .. is a sort of inverse, because  'foo' <> '..' = '.'  for example
07:10:52 <EvanR> as we all know from the FilePath debacle
07:10:58 <mniip> it's not an inverse
07:12:11 <hyperisco> EvanR, well I am trying to discover the semantics of '.' and '..' … seems '.' is merely the identity
07:12:20 <EvanR> its like this
07:12:50 <EvanR> foo / bar is interpreted as /path/to/cwd/foo/bar
07:12:55 <hyperisco> but there are system specific laws like  '/../' = '/'
07:13:00 <EvanR> .. / foo / bar is interpreted as /path/to/foo/bar
07:13:09 <EvanR> see you need an interpretation
07:13:19 <mniip> hyperisco, are you familiar with quotient monoids/semigroups/groups?
07:13:37 <hyperisco> mniip, quotient types yes, but not of those structures
07:14:01 <EvanR> and like Reader, the interpretation only makes sense if you include the cwd
07:14:04 <mniip> quotient types huh?
07:14:24 <EvanR> higher inductive inductive inductive ...
07:14:25 <EvanR> types
07:14:29 <metahumor> it also breaks if you have symlinks
07:14:32 <hyperisco> mniip, yeah, types divided by an equivalence relation
07:14:44 <mniip> right, I was wondering if it's something else
07:15:11 <hyperisco> EvanR, interpretation on an actual system is another story :)
07:15:27 <EvanR> types divided... or linked up with extra equivalences :)
07:15:31 <mniip> weird how you managed to figure out higher inductive types without coming across quotient groups and stuff
07:15:46 * hyperisco *shrugs*
07:16:08 <mniip> EvanR, how many 1-dimensional holes in a Bool?
07:16:35 <EvanR> Bool is pretty nuts
07:17:18 <EvanR> what is a 1 dimensional hole
07:17:28 <EvanR> or other dimensional hole
07:18:02 <jonge> hey there. i would like to implement a simple TCP server that waits for 1 client, serves it and as soon as the client disconnects - the server dies and exits the whole process. Data.Conduit.Network.runTCPServer does not seem to be the right thing becasue it serves "infinitely" many clients. what else? do i need to build the bind-accept stuff by hand?
07:18:16 <hyperisco> okay, so similar deal with semigroups, gotcha
07:18:27 <bash0r> jonge: use the network package.
07:18:41 <hyperisco> a ~ c and b ~ d implies ab ~ cd
07:20:18 <jonge> bash0r: that means i would do "listenOn 1234 >>= accept >>= (h, _, _) -> convertHandleToConduitSinkSource h $ ..." ?
07:20:43 <hyperisco> now you say  x/.. = .  which I am still trying to parse
07:21:31 <EvanR> jonge: yeah for that simple workflow i would write a basic top level IO action which listenOns, accepts, exits
07:21:33 <hyperisco> to me that would imply x is a semigroup and .. is an equivalence relation
07:21:41 <EvanR> you can use conduit after the accept succeeds
07:21:44 <hyperisco> and that . is a semigroup
07:21:52 <hyperisco> which sense makes not! =\
07:21:56 <jonge> EvanR: bash0r: thx. i will try it out. will take me a few minutes. :)
07:22:35 <bash0r> jonge: actually, I'm not very familiar with conduit. It does not suite my use case.
07:22:46 <alp> hyperisco, '/' as in "/home/foo", not quotienting. if you go to directory 'x/' in the current dir then go one dir up, you haven't moved (so you're in '.')
07:22:54 <hyperisco> I agree though that a property of our operator is that  x * '..' = e
07:23:29 <hyperisco> actually I disagree
07:23:39 <hyperisco> because that is not true for  '..' * '..'
07:23:51 <alp> couldn't you just say that relative paths act on absolute paths and call it a day? =)
07:24:25 <EvanR> agreed
07:24:31 <alp> sounds to me like there isn't a lot to be said about absolute paths, except that you can add things at the end
07:24:39 <alp> and the interesting bits all happen when manipulating relative paths
07:24:45 <hyperisco> alp, ignoring these special directories does leave you with something pleasantly simple, yes
07:25:18 <EvanR> what about ~
07:25:21 <hyperisco> at the same time, it is a bit of a fun question to think what "parent directory" should mean algebraically
07:25:27 <hyperisco> EvanR, haven't got there yet :P
07:25:34 <alp> well, . and .. could probably be defined as special relative paths. but the action of ".." might not always be defined... always
07:25:39 <dminuoso> http://lpaste.net/362790 - am I missing an extension here?
07:25:44 <barrucadu> Do you need a special interpretation for '..' and '.'?
07:25:45 <alp> -always
07:25:48 <barrucadu> They are just hardlinks
07:25:52 <EvanR> the action of .. ... on absolute paths
07:25:57 <barrucadu> Whereas '~' is a special thing the shell does
07:25:58 <dminuoso> Oh shoot! I should be shot! :)
07:25:59 <dminuoso> Nevermind.
07:26:10 <tsahyt> I'm looking at servant-auth, and I'm wondering why it pulls the AuthResult into the specific handlers, whereas the basic auth shipped with servant passes only a positive result to the handler.
07:26:21 <tsahyt> and is there some way to get the latter behaviour with servant-auth?
07:26:41 <batman_> how to create a variable with type word8
07:27:04 <EvanR> when i was a kid messing with DOS... i was really upset when .. worked and but ... and .... didnt
07:27:20 <EvanR> F-in bill gates
07:27:34 <Sose> what is ...? o.O
07:27:37 <Sose> ../.. ?
07:27:38 <EvanR> go up two
07:27:46 <alp> tsahyt, not at the moment, but they're roughly equivalent. with servant's auth stuffs, you can always say that the result of the auth check is not just an User, but an "AuthResult User" or something. similarly, you could define a helper function for the "servant-auth way" that'd error out whenever the auth check doesn't succeed, and you'd hand the user to the actual handler when it does succeed.
07:27:50 <dminuoso> batman_: The same way you create any variable.
07:28:13 <hyperisco> mniip, oh I see, you are saying the equivalence relation is characterised by  x * '..' = '.'
07:28:17 <tsahyt> alp: yeah I think I'll go with the helper function then, since all my handlers atm look something like User -> ..
07:28:24 <hyperisco> mniip, only like I said, that is not true
07:28:25 * frerich EvanR: Wasn't it a lot more upsetting that you would (could) use `cd..` to go up but `cd<SPACE>path` to go down? :-)
07:28:31 <mniip> how so
07:28:38 <alp> tsahyt, however, do feel free to open an issue to discuss the possibility of making that behaviour available out of the box
07:28:43 <hyperisco> mniip, because it is not true that  '..' * '..' = '.'
07:28:45 <EvanR> i did not know about cd..
07:28:48 <tsahyt> I suppose I need helper :: (User -> a) -> (AuthResult User -> a)
07:28:49 <mniip> well x != ..
07:28:51 <dminuoso> > let x = x :: Word8 in 1
07:28:51 <batman_> dminuoso : i create a int variable a = 10 :: Int so is it a = 10 :: Word8 ??
07:28:53 <lambdabot>  1
07:29:03 <tsahyt> alp: since they're equivalent it doesn't really matter that much I think. I just noticed that they behave differently
07:29:06 <dminuoso> batman_: For example, yes.
07:29:14 <alp> tsahyt, this is rather similar to the "modifiers" that phadej introduced in servant-0.13: https://github.com/haskell-servant/servant/blob/master/servant/CHANGELOG.md#013
07:29:17 <hyperisco> mniip, sure, yes
07:29:30 <alp> maybe we can make something similar work for auth :
07:29:31 <alp> :) *
07:29:38 <batman_> dminuoso : what are other ways >?
07:30:13 <hyperisco> mniip, the quotient does not introduce the object '..'
07:30:14 <EvanR> is it worth trying to retroactively formalize the behavior of .. directories when whoever invented it as an afterthought while eating breakfast grapefruit ...
07:30:16 <metahumor> in my zsh, i can do "..."
07:30:16 <batman_> dminuoso : and why don't some types have value constructor i mean is there a reason or its just arbitary ?
07:30:17 <tsahyt> alp: speaking of servant-auth though, having HasForeign instances would be tremendously useful I think
07:30:35 <metahumor> why look at path traversals as semigroups instead of a poset?
07:30:36 <mniip> hyperisco, huh?
07:30:41 <tsahyt> alp: earlier today I started dabbling with servant-purescript to generate client functions and noticed that HasForeign instances are missing even for servant's BasicAuth
07:30:48 <metahumor> where you have meet/join and terminal objects
07:31:06 <hyperisco> mniip, we start with a semigroup, say of relative directory paths, and then we want to add the '..' object
07:31:11 <dminuoso> batman_: The relevant part here is: instance Num Word8 -- Defined in ‘GHC.Word’
07:31:13 <alp> tsahyt, yes... :( someone needs to sit down and think about these things properly, but most people who need this don't have time
07:31:18 <mniip> no
07:31:22 <metahumor> " //.. --> /", that is, going (..) at root (/) stays at root
07:31:28 <tsahyt> alp: well, I'll get to think about it for the JWT case I suppose
07:31:33 <mniip> we start with a free semigroup of pathnames including ..
07:31:46 <dminuoso> batman_: Since 1 has the type `(Num a) => a`, you can simply pick `Word8`
07:31:57 <EvanR> action :: Abs -> Rel -> Abs, relcat : Rel -> Rel -> Rel, mempty = .
07:32:02 <dminuoso> batman_: Just like there is an instance: `instance Num Int`, which is the same reason you can pin 10 to Int.
07:32:04 <mniip> and then we add the symmetric transitive-reflexive relation with x / .. = .
07:32:18 <alp> tsahyt, as usual, feel free to drop by #servant or the issue tracker if you need companions for a brainstorming session
07:32:34 <tsahyt> alright, thanks for the invitation!
07:32:48 <hyperisco> mniip, hrm, okay
07:34:03 <EvanR> hyperisco: have you looked at any of these haskell shells to see what algebraic, or geometric, machinations they have distilled
07:34:14 <batman_> dminuoso : didn't really get it can u please elaborate or point to some resource(s)
07:34:17 <hyperisco> EvanR, no
07:34:48 <dminuoso> batman_: Word8 has an implicit data constructor through the Num instance.
07:34:48 <dminuoso> batman_: Num contains a "fromInteger" which has the type `(Num a) => Integer -> a`
07:34:48 <dminuoso> batman_: Which offers you to make any Num object out of an integer, including but not limited to Word8.
07:34:49 <dminuoso> batman_: Have you written any typeclass instances yet?
07:34:57 <alp> tsahyt, well, thank you for considering looking into that :) unfortunately we have nowhere near enough time to look into these things these days with phadej
07:35:45 <metahumor> > let x = 10 in x :: Word8
07:35:47 <EvanR> honestly i havent heard of discriminating absolute and relative paths before at the type level, it seems obvious now that "/usr" </> "/var" is totally bonkers and should not happen
07:35:47 <lambdabot>  10
07:36:04 <batman_> dminuoso : not really i have some idea of them but never written one, Can you also briefly explain or point resources on what functor is ?
07:36:18 <dminuoso> batman_: Start with Eq/Ord/Show =)
07:36:27 <hyperisco> EvanR, actually the path library I am using in PureScript does have that typing, but there are other aspects of the library I really dislike
07:37:03 <dminuoso> badamson[m]: I cant give you resources because I dont feel qualified to give advice on learning material.
07:37:03 <dminuoso> Sorry *batman_
07:37:18 <tsahyt> alp: helper :: MonadError ServantErr m => (t -> m a) -> AuthResult t -> m a seems to do the trick, I can just transform my existing handlers easily with this. it compiles at least, before testing it properly I'll have to implement the actual auth scheme.
07:37:18 <EvanR> kind of like how Day + Integer = Day, but Day + Day makes no sense
07:37:42 <hyperisco> EvanR, that is another good example… a monoid action on days!
07:37:49 <EvanR> its a group action in this case
07:37:59 <hyperisco> more powah
07:38:28 <alp> tsahyt, right this is _exactly_ what I had in mind with my suggestion.
07:38:29 <batman_> dminuoso : i have this function from cryptonite BA.pack :: BA.ByteArray a => [Word8] -> a but when i give it a [Word8] it throws this http://lpaste.net/362792
07:39:06 <batman_> dminuoso : and yeah i'm not using print anywhere & it's all in ghci
07:39:09 <hyperisco> an analogy to actions, in my mind, is delta i.e. change in X
07:39:29 <alp> tsahyt, you could even write something similar to enter/hoistServer for applying this function wholesale to all the auth-protected handlers, instead of having to apply it to all of them.
07:39:33 <EvanR> yes
07:39:38 <EvanR> Day - Day = Integer
07:39:55 <EvanR> but Abs - Abs ... not nec Rel
07:40:08 <alp> tsahyt, or you could use hoistServer directly I think
07:40:18 <tsahyt> alp: I see.. well in my case that's not quite as simple, since they're somewhat mixed through. I've grouped the type synoyms by functionality rather than by what is protected and what isn't
07:40:27 <hyperisco> EvanR, good point
07:40:29 <alp> (User ->) has the right shape
07:40:43 <alp> or ReaderT User
07:40:44 <whoman> 0.0.0.a(CCS.o): requires unsupported dynamic reloc 11; recompile with -fPIC
07:40:46 <whoman> /usr/bin/ld.gold: error: /usr/local/haskell/ghc-8.2.1-x86_64/lib/ghc-8.2.1/base-4.10.0.0/libHSbase-4.1
07:40:52 <hyperisco> EvanR, unless we are also equipped with ..
07:41:09 <EvanR> hmm yes
07:41:13 <barischrooneyj> hey, if anyone has a moment I would love an opinion on some code generating lenses for a Hpack data type called Section, original question here on reddit:  https://www.reddit.com/r/haskell/comments/7z5nf2/make_lens_for_field_sectiondata/ also made a minimal reproducible  here: https://github.com/barischrooneyj/example
07:41:19 <alp> tsahyt, anyway, you get the idea, you seem to be well on your way to making it work so I'll shut up and let you wrap this up
07:41:24 <alp> =)
07:41:26 <EvanR> the result could be ../../../../go/over/here/now/
07:41:33 <hyperisco> indeed :D
07:41:42 <EvanR> hilarious
07:41:57 <hyperisco> and with .. you have to start talking about normalisation
07:42:02 <EvanR> no i dont
07:42:21 <hyperisco> well you don't, but you have infinite ways to get from one place to another
07:42:26 <EvanR> thats fine
07:42:31 <ab9rf> which usually isn't a problem
07:42:39 <hyperisco> it is, but you can add normalisation
07:42:59 <EvanR> there are infinite ways to represent rational 5/16 using a Z and an N
07:43:00 <ab9rf> whether it's a problem or not depends on what you're trying to do
07:43:15 <hyperisco> it helps when computing equivalence, for example
07:43:20 <EvanR> there are infinite ways to represent sqrt 2 ... but no normalization
07:43:34 <ab9rf> it's a mistake in general to assume that for two things to be equal, they need to hve the same name
07:43:45 <hyperisco> what do you mean? Rational does this, at least for Eq
07:44:34 <hyperisco> or maybe it doesn't, could use multiplication
07:44:59 <hyperisco> anyways, by "have to" I really meant "could" :P
07:45:02 <EvanR> my limited brain tells me that normalization as an implementation technique to get something done is getting in the way of deeper relationships going on
07:45:06 <shapr> chessai and I disorganized a small Atlanta Haskell hackathon yesterday evening, if you want to show up in Norcross,GA this Saturday afternoon/evening, send me a message!
07:45:31 <EvanR> oh, haskell hackathon
07:45:34 <ab9rf> EvanR: it usually means that there's an incorrect assumption somewhere
07:45:37 * EvanR steals that idea
07:46:32 <EvanR> canonical representatives, axioms of choices... something
07:48:47 <shapr> Too bad I can't search Haskell coders by region
07:49:06 <shapr> Anyone know other Haskell coders in the Atlanta area?
07:49:20 <hyperisco> there is another concept for paths called sandboxing
07:49:41 <hyperisco> or faux roots, or some name like that, where you disallow .. to escape the faux root
07:50:04 <EvanR> .. cant escape the real root...
07:50:14 <EvanR> so whats the diff
07:50:16 <ab9rf> hyperisco: just be sure that you never cross the streams and let an unnomralized path name escape to the OS environment :)
07:50:49 <EvanR> ah
07:50:57 <hyperisco> algebraically,  . * .. = .
07:51:09 <ab9rf> that leads to security breaches
07:51:27 <EvanR> am i misunderstanding *
07:51:38 <EvanR> . / .. = ./..
07:51:41 <hyperisco> it is some operator
07:52:01 <bash0r> EvanR: when you interprete . / .. then you end on . again.
07:52:25 <EvanR> i just tried, no
07:52:26 <hyperisco> so, in a sense it is like naturals, where it is sensible to take away 5 from 5, but not 6 from 5
07:52:34 <tsahyt> alp: hm, actually it does not work that way, since my handlers aren't just User -> Server a, they take more arguments after User
07:52:52 <hyperisco> though here we can decide whether 6 from 5 is an error or just 0
07:52:54 <bash0r> Oh, you are right. ./.. = ..
07:53:35 <tsahyt> so while I can write the equation helper k (Authenticated u) = k u, I can't write the _ case and throw err401 there
07:53:54 <hyperisco> so, with this set with no negative values, we can then append whatever faux root we want on the front, and we know it will not be escaped
07:53:55 <tsahyt> since that introduces the MonadError ServantErr m => m a return type
07:54:01 <EvanR> hyperisco: well, its like monus. but then your associativity breaks down
07:54:26 <hyperisco> yeah, associativity is borked
07:54:35 <hyperisco> which isn't a good start lol
07:54:40 <EvanR> so clearly this is a magma action
07:55:08 * EvanR adjusts glasses
07:56:00 <hyperisco> did we just get caruso'd?
07:57:08 <hyperisco> maybe we can allow negatives but clamp to 0 when we append it to the faux root
07:57:17 <EvanR> thats what i just said
07:57:30 <hyperisco> well this way we keep associativity
07:57:41 <EvanR> that is what borks associativity
07:58:08 <hyperisco> that operator is an action
07:58:14 <hyperisco> so it never was associative
07:58:34 <EvanR> well i misunderstood what you were saying after all, ok
07:59:00 <EvanR> if action is on absolute path, then wtf is . doing being acted on
07:59:25 <hyperisco> it shouldn't have to be absolute
07:59:32 <EvanR> i beg to differ
07:59:45 <EvanR> where are you getting . / .. = .
08:00:02 <EvanR> i think youve gone mad with dynamic typing at this point
08:00:04 <alp> tsahyt, hmm I think I have something that might help you
08:00:05 <hyperisco> oh you guys are using / as a directory separator, not quotient… okay lol
08:00:16 <mjhoy> Is there a class simply defined as: `class Implies a b | a -> b` ?
08:00:56 <hyperisco> well w/e, there are too many pieces now and not enough names for them
08:01:05 <alp> tsahyt, I haven't released it anywhere yet, but you can easily use it: https://gist.github.com/alpmestan/3cfb9a05f41c08ba111a9bfadcd75ec1
08:01:40 <alp> tsahyt, I seem to remember that servant-auth-server provides something for this though, let me check
08:02:09 <metahumor> I still think that paths should be on a lattice with meet or join
08:02:25 <hyperisco> oh but normalisation got everyone up in arms!
08:02:37 <metahumor> then (/not..) can be your meet, and (/..) your join
08:02:38 <alp> tsahyt, https://github.com/haskell-servant/servant-auth/blob/master/servant-auth-server/src/Servant/Auth/Server/Internal/ThrowAll.hs#L12
08:04:25 <tsahyt> oh that's interesting
08:04:36 <alp> that should do the trick right?
08:04:43 <tsahyt> I'll try ThrowAll first
08:05:13 <alp> yeah my thing is a generalization of it, but ThrowAll addresses your problem so no need to reach for what's in the gist
08:06:19 <tsahyt> now I get this, which looks sufficiently general auth :: ThrowAll p => (t -> p) -> AuthResult t -> p
08:06:54 <metahumor> kinda looks like path traversal can be modeled as a https://en.wikipedia.org/wiki/Residuated_lattice
08:08:56 <tsahyt> alp: I've tested it with a few endpoints and it compiles. thanks!
08:09:01 <alp> tsahyt, looks just about right :)
08:09:16 <alp> no problem!
08:10:55 <hyperisco> metahumor, cool
08:11:24 <alp> tsahyt, in case you ever feel like writing down a simple program illustrating what you've just done, along with a few explanations, our recent cookbook effort could do with more content, especially the non-obvious kind like here. if you don't have the time or desire, no problem though of course :)
08:12:28 <tsahyt> alp: well so far I've just replaced type Protected = BasicAuth "protected" User with type Protected = Auth '[JWT] User, and then applied this auth function to all relevant handlers
08:13:01 <ghk> COBOL for ever as far as I am concerned
08:13:09 <alp> yeah, but this 'auth' function is what I think could be of interest to a lot more people than the two of us =)
08:13:24 <tsahyt> alp: but I suppose I could write a few words on refactoring from BasicAuth to servant-auth
08:13:58 <tsahyt> first I'll need to figure out how JWT actually works though :P
08:14:09 <tsahyt> I'm sorta winging this whole project
08:14:27 <tsahyt> but it's been going well so far, servant was a great choice (assuming that a REST API was a sane choice to start with for my case)
08:15:49 <ghk> Son, I winged an entire corporate dev job
08:15:59 <ghk> For 5 months
08:16:57 <alp> tsahyt, no rush btw for the cookbook, I just wanted to put the suggestion out there :)
08:17:49 <alp> re: REST apis, well servant can do good old web apps too, I wrote quite a few but somehow almost nobody else did
08:17:58 <alp> it is admittedly not very well documented...
08:19:15 <tsahyt> well it is a webapp, technically, it's just also a distributed system. but the frontend is a single page application so I just serve that part with a Raw endpoint
08:19:37 <tsahyt> though atm, most of it doesn't work yet of course, because I haven't written it yet
08:19:45 <bash0r> alp: isn't the trend going to a pure HTML / JS / CSS app that uses a REST endpoint, anyway?
08:20:14 <ghk> No
08:20:23 <ghk> The trend is going to graph ql
08:20:27 <ghk> Rest sucks
08:20:45 <ab9rf> i remember when someone told me about REST and i was "well, duh, why would you do it any other way?"
08:20:48 <alp> bash0r, you're assuming my skills include modern web frontend development here =P
08:21:00 <ab9rf> and my thought was "geez, people think this is innovative?"
08:21:12 <tsahyt> ab9rf: to be fair, rest is ancient
08:21:24 <ab9rf> tsahyt: so am i
08:21:43 <alp> I did write a SPA backed by a servant rest API too, once, but nothing really fancy, just wanted to compare it with just serving HTML templates instantiated with data returned by servant handlers
08:21:44 <bash0r> alp: I can't get a single page to be appear nice to the eye. So my approach would be to implement a backend and let somebody else do the frontend.
08:22:15 <ab9rf> it vaguely amazed me that there was a clever name for writing applications in the obvious manner
08:22:30 <alp> bash0r, when there's somebody else, absolutely! but consulting gigs don't always come with frontend people =)
08:23:05 <alp> anyway, this is what I wrote and used for most of the web apps I wrote with servant: https://hackage.haskell.org/package/servant-ede-0.5.1/docs/Servant-EDE.html (see example under the 'HTML' data type)
08:23:10 <bash0r> alp: Ahh I see.
08:23:14 <ab9rf> i should try to find the hard drive with that app on it and revive it
08:24:35 <tsahyt> alp: btw, what's with the servant-auth-server docs on hackage?
08:24:54 <bash0r> How does GraphQL differ from REST?
08:25:12 <ghk> It's better
08:25:47 <bash0r> Haha, I meant in implementation details. GraphQL looks like a single REST endpoint with a query language interface.
08:25:59 <alp> tsahyt, https://hackage.haskell.org/package/servant-auth-server-0.3.2.0/reports/3 there's an error there
08:26:05 <ghk> I have no fucking idea
08:26:11 <ghk> But I know it's but better
08:26:47 <dysfun> it's more hyped
08:26:55 <ghk> And it's better
08:27:04 <dysfun> debatable
08:27:16 <bash0r> That for sure. My application features only a few endpoints anyway with a query language backing each endpoint. Looks like it's a very similar approach.
08:27:17 <ghk> Thats debatable
08:27:24 <tsahyt> alp: well that is unfortunate, I'll resort to local docs then
08:27:43 <ghk> It's good for larger projects anyway not ur usual fucktard web application
08:27:44 <cocreature> alp: fwiw you can upload docs yourself :)
08:27:57 <alp> yeah, I just hadn't noticed before
08:28:30 <alp> I'll have to put my hands on the magical incantation for this
08:28:56 <cocreature> it’s far less magical these days, cabal has support builtin for this
08:29:07 <ghk> Cabal ?
08:29:11 <cocreature> "cabal upload -d path/to/docs.tar.gz"
08:29:15 <ghk> Cobol is where it's at Bro
08:29:36 <cocreature> ghk: can you please stop your boring trolling?
08:30:00 <ghk> 200 ok
08:30:41 <metahumor> gql is like, tell me all the information you want (that works w the schema), and i'll give you that back, with the backend fusing queries where possible
08:31:08 <ghk> ^^ smart man over there
08:31:09 <metahumor> gql also has advanced capabilities for pub/sub for updates for such queries
08:31:24 <metahumor> gql is overkill
08:31:35 <alp> cocreature, oh neat. how do I produce docs.tar.gz?
08:31:41 <ghk> Agreed
08:31:50 <alp> just tar the result of cabal [new-]haddock?
08:31:53 <cocreature> alp: cabal haddock --for-hackage
08:32:05 <alp> ok, great, thank you!
08:32:14 <cocreature> alp: for new-haddock you need cabal from the master branch
08:32:25 <bash0r> I need a query language. GraphQL doesn't fit my use case, though.
08:32:27 <alp> I'm using 2.1, should do
08:32:58 <ghk> SQL
08:33:17 <shapr> bash0r: what's your use case?
08:33:38 <cocreature> alp: in particular make sure you have https://github.com/haskell/cabal/pull/5143 and source links are properly being generated
08:34:31 <EvanR> common reaction to haskell, it has too many operators not interested. by my survey of the "standard" operators (included in Prelude), there are only 6 operators which you would probably see or care to use, that arent just funny looking versions of familiar operations from other languages. so that subverts the "too many" hypothesis
08:34:59 <EvanR> of those 6, <$> and <*> are likely to appear and require some non trivial explanation
08:35:17 <metahumor> i think "(:)" is also confusing
08:35:26 <EvanR> and the nature of <$> isnt even really its operatorness, its a cheap synonym for something else and something simple
08:35:27 <metahumor> so is "_" in matching
08:35:38 <EvanR> i forgot about :
08:36:14 <jle`> well, the problem is exacerbated by a trend in 00-era libraries of all introducing domain specific operaors
08:36:16 <metahumor> and guard syntax in general. why do guards use (otherwise,|, =) and case match uses just (_, ->)
08:36:21 <EvanR> anyway, based on my results, i think <$> (cheapo synonym for fmap) and <*> (no other real name and not as easily explained) deserve a blog post
08:36:35 <EvanR> and all of the above is ignoring lens
08:36:46 <hyperisco> developers were naughty in the noughties
08:37:00 <EvanR> metahumor: true, maybe "operators" is also referring to the non operator other syntax
08:37:03 <metahumor> i read <*> as ap
08:37:11 <jle`> "too many symbols", maybe
08:37:16 <metahumor> apTo maybe
08:37:22 <jle`> i get "are we writing perl" sometimes
08:37:23 <EvanR> which would be odd because ( [ { and ; in javascript dont get that heat
08:37:38 <hyperisco> may as well complain there are too many expressions
08:38:04 <hyperisco> I also heard the complaint of there being too many functions
08:38:08 <ab9rf> heh
08:38:26 <EvanR> my thesis has been, complaint A is a reactionary version of actual complaint B which could be distilled into a single blog post
08:38:27 <jle`> welp can't argue that
08:38:38 <ab9rf> hyperisco: that's partially because haskell doesn't overload the way many other languages do
08:38:44 <EvanR> its true, many languages cultures do not ... use functions
08:38:48 <EvanR> which is boggling
08:38:48 <jle`> EvanR: that's fair
08:39:17 <shapr> When I try to show Haskell to heavy Go coders, they say it looks like line noise.
08:39:32 <hyperisco> EvanR, you apply them sparingly like a spice
08:39:49 <metahumor> i think programmers are just trained to not pay attention to ([{
08:40:02 <metahumor> i wonder how perl programmers feel about haskell operators
08:40:05 <ab9rf> i've seen people complaining that haskell has both "pure" and "return" which do the same thing and thus should have the same name
08:40:15 <barrucadu> hyperisco: So are Haskell programmers like the spice-fiend who pours an entire tub of paprika into their food?
08:40:16 <metahumor> they're not wrong
08:40:21 <ab9rf> metahumor: as a perl programmer, i'm fine with them :)
08:40:39 <EvanR> im afraid of go, the only news i hear of it is antiintellectually themed
08:40:42 <ab9rf> barrucadu: that's just being hungarian.
08:40:50 <ab9rf> EvanR: i despise go
08:41:11 <shapr> I want to switch to pure and get rid of return, that word is confusing to those learning.
08:41:12 <ab9rf> EvanR: almost as much as i despise go evangelists. they're categorically worse even than php evangelists
08:41:15 <metahumor> i thought haskellers were more Polish
08:41:22 <tsahyt> alp: my application already holds an Ed25519 signing key, can I reuse that for JWT with servant-auth-server? or is this unadvisable to begin with?
08:41:38 <geekosaur> I thought being hungarian was encoding the type into the name >.>
08:41:56 <metahumor> (Polish) 3 4
08:42:03 <ghk> What's wrong with Hungarian brothers?
08:42:05 <shapr> Go has a bunch of good points, and I'd like to steal them all for Haskell!
08:42:13 <merijn> geekosaur: Queue explanation of systems vs apps Hungarian :p
08:42:30 <ab9rf> paprika is a main ingredient in a lot of hungarian food, or so i learned when my ex was a grad student in a math department that had a hungarian who liked to cook in it
08:42:36 <tsahyt> jose doesn't seem to provide any SecretKey -> JWK :/
08:43:17 <tsahyt> eh, whatever, I'll just generate a new key just for JWT, it's not like the world is short on entropy
08:43:38 <dminuoso> In which order do type variables appear if they are not explicitly specified?
08:44:13 <tsahyt> dminuoso: you mean for explicitly applying them?
08:44:16 <jle`> dminuoso: do you mean appear in the type signature?
08:44:20 <dminuoso> In order of appearance from left to right in the function signature?
08:44:21 <jle`> because it's kind of unambiguous
08:44:26 <dminuoso> tsahyt: Yes.
08:44:28 <jle`> if you rearrange the type signature then it's a different type signature
08:44:37 <tsahyt> dminuoso: afaik left to right as they appear
08:44:38 <shapr> Seems to me that anything a bunch of people enjoy using has good points worth considering.
08:44:57 <EvanR> shapr: i would like to hear these points about go
08:45:01 <tsahyt> ghci seems to agree
08:45:15 <jle`> there are some exceptions in ghc 8.2 that are being fixed in 8.4
08:45:24 <jle`> but that's going to lead to some breaking code unfortunately
08:45:58 <shapr> EvanR: easy to learn, small static binaries, gofmt means no coding style arguments, easy to cross compile
08:46:36 <EvanR> how small?
08:46:43 <alp> tsahyt, I haven't used jose in years so I'm afraid I can't help on that front
08:47:20 <shapr> EvanR: much smaller than Haskell binaries, I don't have a good way to describe the size difference
08:47:46 <EvanR> like, C ?
08:48:03 <shapr> but I would be thrilled if I could easily build static stripped Haskell binaries
08:48:12 <shapr> no, larger than C
08:48:55 <tsahyt> shapr: I'd be happy if I could easily -split-sections with stack already
08:48:59 <dminuoso> tsahyt: How can you inspect the order?
08:48:59 <dminuoso> tsahyt: My GHCi does not seem to list forall quantifiers.
08:49:12 <tsahyt> dminuoso: I just tried applying them with -XTypeApplications enabled
08:49:48 <dminuoso> tsahyt: Interesting, so even in `(Num a) => b -> a` a appears first.
08:49:58 <dminuoso> tsahyt: Yeah Im doing that as well now. :)
08:50:01 <tsahyt> ah, I didn't even consider adding contexts
08:50:15 <tsahyt> that does clear up some confusion that I had in the past
08:50:23 <shapr> Sounds like Go 2.0 will have generics, I wonder if Go will be harder to learn then?
08:51:01 <shapr> I could teach the entirety of the Python 1.5 language to someone in four hours, but 2.0 got way more complex.
08:51:12 <dminuoso> tsahyt: I guess ultimately if you have the control, you might as well specify them explicitly
08:51:13 <EvanR> maybe programming education should be, learn the easiest-possible language first
08:51:20 <shapr> So perhaps the reason Go is easy to learn is that it's still 1.x ?
08:51:22 <ab9rf> shapr: ooh only 25 yeras after everyone else got them!
08:51:27 <EvanR> and let people be frustrated with it
08:51:28 <dminuoso> tsahyt: ∀x y z. kind of makes it obvious that it takes 3 type parameters in that order =)
08:51:37 <tsahyt> dminuoso: tbh I use TypeApplications with Proxy almost exclusively
08:51:38 <EvanR> but then again, no one thinks HTML should have functions
08:51:48 <dminuoso> tsahyt: No idea what Proxy is. Still learning the basics here.
08:51:56 <shapr> ab9rf: yeah, I agree that generics are necessary to support the claim of having real type checking.
08:51:56 <ab9rf> EvanR: it annoyed me when HTML becaome turing-complete.
08:52:17 <shapr> Right now Go has to cast to the top type and back down when trying to make generic containers, type safety just goes away.
08:52:17 <dminuoso> ab9rf: Well HTML by itself is not
08:52:24 <EvanR> maybe everyone thought i was talking about letting HTML send email... but i wasnt even going for turing complete either
08:52:31 <ab9rf> EvanR: i could no longer maintain my insistence that HTML is not a "programming language"
08:52:31 <dminuoso> ab9rf: You need at least CSS3 along with it
08:52:49 <ab9rf> dminuoso: yes, but CSS is officially part of the language now, as i understand it
08:52:57 <EvanR> a good subset of HTML (no quirks) is a data structure, and so is a stupid programming language
08:53:23 <EvanR> i just saw the hack where css can read your password while you type it in
08:53:27 <EvanR> brilliant
08:53:33 <dminuoso> ab9rf: Not that Im aware of. CSS requires HTML however.
08:53:35 <EvanR> who designs this crap
08:54:07 <dminuoso> EvanR: Wait what? Id like to see that.
08:54:10 <EvanR> heh
08:54:24 <EvanR> https://github.com/maxchehab/CSS-Keylogging
08:54:42 <jle`> slightly misleading as it requires a javascript framework to be running on the website
08:54:46 <jle`> but it's still pretty clever
08:54:47 <shapr> At this particular moment, my top two nits in Haskell are "get rid of return and only use pure" and "replace foldl with foldl'"
08:55:09 <dminuoso> EvanR: I seriously hope that with the advent of webasm the paradigm will shift into robust isolated applications, instead of this open "let 10 people toss code at a browser that automatically runs when the user accidentally visits your side"
08:55:18 <hyperisco> EvanR, lmao
08:55:23 <bash0r> shapr: it's a crypto currency exchange model. I want to allow users to write their own routing algorithms which implies that they need to query on the available order books.
08:55:51 <dminuoso> EvanR: Haha. That is hilarious.
08:56:21 <hyperisco> so, this is an XSS attack done with CSS
08:56:24 <geekosaur> why am I not surprised?
08:56:39 <hyperisco> not even disabling JavaScript saves you D:
08:56:42 <EvanR> foldl = foldl' would be ok... but where do you put old foldl
08:56:48 <hyperisco> it is time to do text browsing only
08:56:58 <EvanR> hyperisco: its been that time since... a long time ago
08:56:59 <hyperisco> stupidFoldl = foldl
08:57:00 <dminuoso> tsahyt: I dont even have a need for TypeApplications - but it felt so obvious after someone has pointed out to me the nature of /\ in System F =)
08:57:18 <shapr> bash0r: insufficient info, sounds like sql or graphql would work, but I don't know your constraints and context.
08:57:27 <tsahyt> perhaps I should finally get around to learning System F
08:57:28 <metahumor> accursedUnutterableFoldl
08:57:34 <shapr> ha!
08:57:34 <EvanR> actually... foldl', while useful, doesnt really make sense to me as a left fold
08:57:55 <metahumor> foldlWithThunks
08:58:12 <shapr> metahumor: last week at the Haskell meetup chessai showed off a perfectly safe usage of accursedUnutterablePerformIO
08:58:16 <EvanR> youd have to explain why its a left fold, what that would mean, and why it doesnt mean that
08:58:26 <dminuoso> Are there actually cases where foldl trumps over foldl' ?
08:58:49 <EvanR> ive used it, to do stuff similar to reverse
08:58:58 <EvanR> but for other data structures
08:59:36 <EvanR> foldl' didnt seem appropriate at that point
08:59:39 <metahumor> shapr: what was it?
09:00:39 <metahumor> foldl' to me seems useful for dealing with lists you know to be finite, like rev = foldl' (:) []
09:00:57 <EvanR> that in particular doesnt gain you anything over foldl
09:01:13 <EvanR> but this has all been said a million times
09:01:35 <bash0r> shapr: I want to control what users can actually do with queries. So using an existing query model does not fit it. Think about a program that runs on the exchange servers and does margin trading. It's an infinite loop. But in other places I don't want users to run functions that never return as these would only burn my servers capacity and inevitably my money.
09:04:36 <Tops2> I encoded a SAT-problem using the minisat-solver package, but tranforming the expression to CNF allocates an absurd amount for slightly larger problem sizes.
09:04:36 <Tops2> I've seen that there are other packages like ersatz, yices-painless, toysolver,... but I am unsure which are considered outdated, mature, competitive to MiniSat or in some other way useless for larger problem sizes.
09:04:36 <Tops2> Is there any recommended package? Support for incremental solving would be a nice extra.
09:06:50 <glguy> ersatz uses minisat or whatever solver you tell it to
09:07:14 <glguy> yices-painless presumably using yices, which is quite good, too, but a different kind of solver to minisat
09:20:07 <woodson> Hi guys, I would like to find some project that a can contribute to. Are there any good beginner friendly project to contribute to?
09:20:22 <woodson> or project with potential beginner bugs?
09:21:02 <Psybur> You want to write some unit tests for a forex trading framework? :D
09:21:35 <cocreature> woodson: do you have any specific areas that you are interested in?
09:21:51 <woodson> Psybur: I will not say no, I dont mind any suggestion I will look at it
09:21:55 <bash0r> Psybur: do you mean me?
09:21:57 <woodson> if you can just give me the name
09:22:28 <Psybur> https://github.com/jrciii/money-machine
09:22:37 <woodson> cocreature: hmm right now, I am trying to build a library to interact with salesforce api. Thats about it
09:22:42 <woodson> but I would like to contribute
09:22:49 <woodson> so honestly not sure yet
09:22:59 <woodson> thats why I am willing to just look at any suggestion
09:23:01 <cocreature> woodson: contributing is a lot more fun if you care about the thing that you’re contributing to :)
09:23:24 <bash0r> Psybur: is that your project?
09:24:02 <cocreature> woodson: so I would suggest to first find a project that looks interesting to you and then either see if there is an issue or ask the authors. most are quite happy to point you at easy tasks
09:24:09 <Psybur> Yes
09:24:23 <bash0r> is it an exchange or a trading algorithm?
09:24:30 <woodson> concreature: I'm interested in reflex
09:24:35 <woodson> I looked at it but
09:24:46 <Psybur> Right now it has a backtesting framework and a live practice mode
09:24:52 <woodson> I dont think that their are beginner friendly
09:24:57 <Psybur> Dont know if the backtesting actually works, need to write tests :D
09:25:02 <woodson> I looked at few other projects..
09:25:16 <cocreature> woodson: just ask the authors, I’m sure they’ll find something that is suitable for your skillset!
09:25:33 <woodson> cocreature: Ah, I see what you mean
09:25:48 <woodson> directly contact then just assuming
09:25:54 <woodson> lol
09:25:56 <bash0r> Psybur: If you're interested in building an actual exchange let me know. I'm on this train right now.
09:26:17 <cocreature> yeah, send them an email, find them on irc, make a github issue, …
09:26:45 <woodson> cocreature: honestly, I'm already communicating with them lol
09:26:47 <Psybur> An exchange? Where people place orders?
09:26:50 <woodson> should have tried that first lol
09:26:54 <bash0r> Yup
09:27:04 <Psybur> You trying to be a market maker or something?
09:27:24 <bash0r> I prefer to be the exchange instead of anybody who has his money in the game. :p
09:27:28 <bash0r> Providing the platform.
09:28:14 <Psybur> Sounds like writing haskell is going to be the least of your worries :D?
09:28:48 <EvanR> earlier someone mentioned a ghc extension BlockArguments
09:28:54 <EvanR> is that the right name
09:29:16 <joe9> is there a >> (bind) that forces evaluation? I have a memory leak in an attoparsec parser and I cannot figure out how to use strict evaluation there? I have return $! from the parser. But, the memory leak seems to be building up in the >> .
09:29:23 <MarcelineVQ> EvanR: a language extension?
09:29:26 <bash0r> I'm familiar with syntax and semantics. The ecosystem of Haskell's libraries is a different story. I used Haskell most of the time for writing interpreters in the last few months, Psybur.
09:29:26 <cocreature> EvanR: afaik it is
09:29:26 <EvanR> yes
09:29:34 * EvanR continues looking for it
09:29:35 <woodson> Psybur: I dont see any issues yet
09:29:37 <bash0r> EvanR: ArgumentDo
09:29:42 <cocreature> EvanR: it was also called ArgumentDo at some point but BlockArguments is the new name afaik
09:29:46 <woodson> When are you planning on opening some?
09:29:50 <cocreature> EvanR: it won’t land before 8.6
09:29:57 <EvanR> joe9: you can use evaluate from Control.Exception
09:30:06 <EvanR> or make your own, >>!
09:30:21 <MarcelineVQ> oh the $ and do smoother
09:30:24 <cocreature> EvanR: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0010-block-arguments.rst
09:30:40 <Psybur> woodson, I can open a "needs testing" issue heh
09:31:05 <joe9> EvanR: ok, Thanks.
09:31:14 <cocreature> joe9: that sounds kind of weird, can you show us the code?
09:31:56 <EvanR> slick
09:32:03 <EvanR> we move this much closer to coffeescript
09:32:36 <bash0r> Psybur: I'd like users to run their trading algorithms on exchange users written in a DSL that forbids specific API (like IO which only supports pump'n'dump groups and useless endless loops). So maybe your projects fits into the scope of mine. Think about it.
09:32:47 <bash0r> on exchange servers *
09:33:09 <woodson> Psybur: lol
09:33:16 <heptahedron> without having any more than a minute of context, I must ask how you plan on forbidding pointless endless loops
09:33:37 <woodson> Psybur: Ok well, I will actually look into it!
09:34:01 <Psybur> https://github.com/jrciii/money-machine/issues/1
09:34:09 <cocreature> heptahedron: just forbid all loops, even terminating ones :)
09:34:25 <bash0r> heptahedron: the same way Idris, Coq, etc do.
09:34:36 <joe9> cocreature:  this is the .prof file: https://gist.github.com/0bd942e3e20f8c804faa8be84d75e5ff . the code is split out into many modules. this is the relevant code http://okturing.com/src/2300/body
09:34:58 <bash0r> Or the the way cocreature suggests. For everything else there is foldl and foldr.
09:35:08 <heptahedron> cocreature: what about all my unicyclic loops?!
09:35:54 <geekosaur> you'll have to ask shapr, I think >.>
09:35:58 <bash0r> The real question is if you need those loops when querying a set of order books to place your orders on the shards.
09:36:27 <joe9> cocreature: does that help?
09:36:30 <cocreature> joe9: iirc the attribution from GHC’s profiler is pretty weird for cps’d things like attoparsec’s parser
09:36:41 <heptahedron> well if you're just looking for a query language why not look to some hobbled form of SQL instead of going all-out and making a dependent type system like Idris or Coq
09:36:53 <cocreature> joe9: so I wouldn’t put too much trust that this is actually the problem
09:37:23 <EvanR> bash0r: its well hoped and well studied that getting stuff done with a DSL does not require generic looping mechanisms
09:37:25 <joe9> cocreature:  oh, no. How would you propose I debug this problem, please?
09:37:33 <bash0r> heptahedron: I meant the language to be total rather than the dependent typing thing.
09:37:43 <cocreature> joe9: what makes you think you have a spaceleak?
09:37:46 <joe9> cocreature: I am sure it has something to do with strictness as sometimes $! makes a difference.
09:38:00 <heptahedron> bash0r: so, like, something turing-incomplete, then?
09:38:04 <EvanR> bash0r: you just have to provide whatever "eliminators" people may need to process data
09:38:18 <joe9> from the .hp file, the memory keeps on growing and top shows the memory usage growing too.
09:38:23 <EvanR> however, as soon as they want to do something out of your box, even if its possible, it might be excruciating
09:38:32 <joe9> when I get the $! correct, the memory usage is negligent.
09:38:35 <bash0r> EvanR: What I meant in this regards is that you don't need the full power but you can use a somewhat specific solution for specific problems.
09:38:41 <EvanR> right
09:38:42 <joe9> cocreature: does that make sense?
09:39:08 <cocreature> joe9: yeah, but it sounds like you have already figured out how you need to place the $!? so what makes you think you have more spaceleaks?
09:39:21 <bash0r> heptahedron: It does not need to be turing complete / a full lambda calculus, yes.
09:39:23 <Psybur> woodson, do you know anything about forex trading?
09:39:30 <Psybur> Or any other kind of instruments trading
09:39:41 <Psybur> I suppose I could take that to a PM
09:40:08 <heptahedron> bash0r: Why not look into relational algebra/calculus?
09:40:21 <heptahedron> seems like a straightforward enough approach
09:40:35 <joe9> cocreature: the first time I sprinkled $!, it worked great. Now, after some other different changes to the code, the space leak has cropped up again.
09:40:39 <bash0r> heptahedron: because I did not know about this :D Thanks!
09:40:53 <heptahedron> bash0r: It's the foundation for SQL, in case you didn't know
09:40:56 <joe9> cocreature: adding Strict pragma actually made things worse.
09:41:27 <cocreature> joe9: you could try neil mitchell’s approach to finding space leaks https://neilmitchell.blogspot.de/2015/09/detecting-space-leaks.html
09:41:35 <heptahedron> can be very human-readable, e.g. "select amount from money_stuff where investment = good and know_what_im_doing = true"
09:41:48 <cocreature> joe9: also take look at the different memory profiles, e.g., cost centers, types, … sometimes one helps while the other doesn’t
09:41:49 <heptahedron> > "0 rows affected"
09:41:51 <lambdabot>  "0 rows affected"
09:41:54 <joe9> cocreature: Thanks, will do.
09:41:54 <bash0r> heptahedron: that's very good to know. I guess, some of the aspects of the DSL will escape what SQL provides (endless margin trading for example).
09:42:13 <cocreature> joe9: apart from that I sadly don’t have better advice than “stare at the code really hard” and “try things to see what happens”
09:42:16 <joe9> cocreature: if you do not mind me asking, how do I get to different memory profiles?
09:42:32 <cocreature> joe9: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-for-heap-profiling
09:42:36 <heptahedron> bash0r: we could talk about type systems or polyvariadic functions for days but endless margin trading just went over my head big time lol
09:43:00 <Psybur> bash0r, why not just expose a rest api that forbids the stuff you dont want? Instead of restricting people to use your DSL
09:43:29 <heptahedron> a rest api is pretty much functionally equivalent to a DSL for how underspecified "restful" is
09:44:03 <bash0r> heptahedron: margin trading is just the process of trading in the spread. Imagine an instant buy price and sell price of 0.12% difference. You can make money on this difference if you do it long enough.
09:45:51 <bash0r> Psybur: because users are then restricted to use a routing algorithm which I chose. It's impossible to let a single order on one machine handle all the traffic that hits, for example, binance on its peaks. You have to balance the load. It's kinda intransparent to not let users design their own strategy when placing an order.
09:46:04 <heptahedron> bash0r: Assuming you're restricting your users to making a sort of 'trigger' that is continuously evaluated on the state of the market, you wouldn't really have to allow for loops in your DSL
09:46:22 <bash0r> heptahedron: that's the idea.
09:46:58 <heptahedron> Is this like a side-project you're doing or what's the deal here
09:47:04 <heptahedron> just out of curiousity
09:47:07 <heptahedron> curiosity
09:49:46 <Cale_> You don't see a lot of recursively generated rest APIs though
09:49:53 <shapr> heptahedron: unicyclic is good stuff! Next time you're in Atlanta, I'll teach you to ride my unicycle!
09:50:22 <heptahedron> heptahedron: you will try!
09:50:32 <heptahedron> welp. that was not the intended recipient of that
09:50:51 <heptahedron> That's what I get for not sleeping last night
09:52:23 <bash0r> Speaking as a naive student, it's my future. ^^
09:53:13 <bash0r> I want to go serious with this project.
09:59:08 <enthropy> I have an expression (f @_ @"abc"), the @_ is short for @Symbol, the kind of the type variable that becomes "abc". Is there a way to leave out the @_ alltogether?
09:59:09 <enthropy> besides deciding on a kind in advance
09:59:44 <heptahedron> enthropy: you could reorder the type variables in the declaration maybe
10:01:19 <enthropy> I just have to leave out the kind variable in the type signature
10:01:46 <AWizzArd> Dynamic typing. Over 100 man hours already went into hunting a set of type errors. Some were fixed (one caused an infinite loop), but the main one that is segv-ing is still not found.
10:02:12 <bash0r> heptahedron: Just out of curiousity as I think I'm having issues with IRC right now, did you receive my answer? :p
10:02:19 <heptahedron> enthropy: are you saying you solved your problem?
10:02:53 <heptahedron> bash0r: the two messages, the latter of which was you saying you wanted to go serious with this project, were the last I received from you
10:03:11 <bash0r> heptahedron: Ahh okay, that's fine then.
10:03:12 <enthropy> I had:  f :: forall (x :: k)., with  f :: forall x. it works correctly
10:03:18 <enthropy> heptahedron, yep
10:03:22 <heptahedron> enthropy: nice!
10:03:33 <bash0r> I had another suspicion a few minutes ago.
10:03:49 <heptahedron> do tell
10:04:22 <bash0r> It just feels like IRC eats some of my messages sometimes.
10:10:22 <MarcelineVQ> bash0r: the only way to know is to label each of them
10:10:49 <bash0r> MarcelineVQ: I'm not very familiar with IRC. What does labeling mean in this context?
10:11:17 <codedmart> I am not really good at regular expressions but this seems to work when I test in online tools. I am trying to use regex-compat. https://gist.github.com/codedmart/74e24707edf36da7dbf6672ec9474a65
10:12:04 <geekosaur> bash0r, most of the time it's everyone missed it everything else going on (recalling that a significant proportion of that does not take place in IRC...)
10:12:08 <MarcelineVQ> bash0r: as in some consectve prefix to the messages you send, if the next message isn't consecutive one must have been 'eaten'. or you forgot to label correctly :>
10:12:33 <jle`> enthropy: be aware that that might not be possible with future ghc's typeintype variants
10:12:58 <geekosaur> codedmart, not your problem but \2 and \4 must be \\2 and \\4
10:13:04 <bash0r> geekosaur: ^^
10:13:06 <geekosaur> you told it to sunbstitute control-b and control-d
10:13:19 <heptahedron> jle`: could you elaborate on this? does the kind argument get pushed forward regardless or something?
10:13:27 <jle`> it might be required
10:13:33 <bash0r> MarcelineVQ: <= this thing you mean?
10:13:40 <codedmart> geekosaur: Oh ok thanks. Any idea on the error?
10:13:40 <heptahedron> ah yikes.
10:13:44 <jle`> well, it was more a cautionary tale about the instability
10:13:49 <jle`> not sure if that's the actual plan
10:14:01 <geekosaur> still looking
10:14:25 <geekosaur> you also dont need to escape the /s
10:14:29 <heptahedron> speaking of instability--what's the status with OverloadedLabels/RecordFields? I read the discussion on GitHub but the wiki page says the information therein will be overridden by what's in the discussion and I'm not really sure how to interpret it
10:14:32 <geekosaur> you need to do that wyen // is the delimiter
10:14:41 <geekosaur> here, being in a string is the "delimiter"
10:15:05 <heptahedron> I want to use them for this vinyl package but I'm afraid the API is unstable to the point of rendering it useless, but I don't know
10:15:07 <enthropy> jle`, I haven't used -XTypeInType, but maybe it's implied by the extensions I am using
10:15:19 <geekosaur> but that would just cause the pattern match to fail, this is suggesting there is an error
10:15:46 <MarcelineVQ> bash0r: I'm mostly kidding here, this is the first time this subject has come up on my time in irc reaclly, but if we run with it:    "1: bash0r: this message to you is labeled." "2: can anyone tell me about the TypeApplications extension? I'm looking at the manual" "4: But I'm not sure what that part means"
10:15:49 <metahumor> is there any roadmap for Backpack for parsers?
10:16:45 <bash0r> MarcelineVQ: Ahh, okay I see what you mean. ^^
10:17:06 <codedmart> geekosaur: Are you saying it should be this: `mkRegex "(/Volumes/(?:(cdev|cdev_assets)(-[^/]*)?)/(.*))"`
10:17:11 <geekosaur> oh, I see it
10:17:26 <geekosaur> you are using POSIX regexes
10:17:27 <MarcelineVQ> bash0r: there message 3 is missing, we can tell partly from the context and partly from the missing consecutive label
10:17:38 <geekosaur> (?: ... ) is PCRE, not POSIX
10:17:46 <ab9rf> heh
10:17:57 <ab9rf> extended regular expressions are a pox on humanity
10:18:00 <geekosaur> the error is the ? causes 'there is an open paren instead of a regex there'
10:18:09 <bash0r> MarcelineVQ: That inevitably showed off how few I know about IRC. :D
10:18:40 <codedmart> geekosaur: Oh, how do I fix it then?
10:18:50 <EvanR> extended regular expressions, yet no one wants functions in their html
10:19:09 <EvanR> what a world
10:19:18 <MarcelineVQ> bash0r: well that's just some random idea, it's not an irc thing, irc doesn't specify useful things hehe
10:20:06 <geekosaur> POSIX doesn't have non-capturing groups, so it will have to be ( ) instead of (?: ), and yoiu'll need to account for the extra capture (so \\3 and \\5)
10:20:18 <bash0r> MarcelineVQ: :)
10:20:23 <heptahedron> EvanR: even at this very moment, zalgo seeks to enshroud this entire irc server in a unicode plague for mentioning html and regex in the same conversation
10:20:33 <enthropy> heptahedron, I think a preprocessor (my http://hackage.haskell.org/package/HListPP for example) is a better idea for now
10:20:45 <geekosaur> MarcelineVQ, you forgot to call it IRC deBruijn indexing >.>
10:21:04 <monochrom> That's unicode heaven, not unicode plague.
10:21:22 <heptahedron> monochrom: The telegu bug is the unicode plague
10:21:27 <heptahedron> of the month
10:21:43 <EvanR> unicode... trigram for heaven? ☰
10:21:54 * geekosaur slaps zalgo with a unicod
10:22:17 <codedmart> geekosaur: Ah thanks!
10:22:53 <heptahedron> enthropy: hmm. That's still using GHC's IsLabel though, isn't it?
10:23:27 <enthropy> no it doesn't use IsLabel
10:24:19 <heptahedron> hm. well, I think I'll just stick to TypeApplications with Symbols for now. Maybe I'll add a module users can import to use labels if they want later
10:32:31 <jle`> enthropy, heptahedron: here's the discussion in question actually about forall's and kind variables https://github.com/ghc-proposals/ghc-proposals/pull/103
10:33:59 <jle`> simonpj is "strongly in favor"
10:40:34 <hyperisco> I don't think "binary string" is a particularly clear concept
10:41:31 <hyperisco> but in this context means… a string…
10:43:02 <jle`> in mathematics a binary string is presumably interpreted as [Bool]
10:56:19 <heptahedron> jle`: Thanks for the link!
11:00:01 <shapr> AWizzArd: are you porting something to Haskell from another language?
11:00:23 <Justas> Hello. Can somebody explain me how it works? myFunc :: (x -> y) -> (y -> z) -> c -> (a, x) -> (a, z)      myFunc xToY yToZ _ (a, x) = (a, (yToZ (xToY x)))
11:01:02 <Justas> How to decompose it step by step?
11:01:48 <bash0r> Justas: what part is unclear? What is your specific question?
11:01:51 <jle`> Justas: how familiar are you with functions in haskell?
11:02:01 <jle`> and tuples
11:02:13 <jle`> and pattern matching
11:05:37 <Justas> Just started to learn haskell from Christopher Allen's book "Haskell programming from first principles". This is snippet from 153 page. I do know what tuple. And pattern matching (at least I think so). But what is not clear to me is that last part: (a, (yToZ (xToY x)))
11:05:56 <Justas> How it solves to (a, z) ?
11:05:59 <koala_man> are you familiar with any other languages?
11:06:03 <fresheyeball> Justas: you are creating a new tuple
11:06:10 <fresheyeball> the left side of the tuple is `a`
11:06:21 <fresheyeball> the right side of the tuple is created by first
11:06:28 <fresheyeball> evaluating (xToY x)
11:06:39 <Justas> Yes. I work as full time programmer.
11:06:42 <fresheyeball> which will yield a `y`
11:06:50 <hyperisco> Apply (Apply (,) a) (Apply yToZ (Apply xToY x))  -- decompose it like that?
11:06:55 <fresheyeball> that why is then applied to the function `yToZ`
11:07:00 <EvanR> boggle
11:07:03 <fresheyeball> which will yield a `z`
11:07:08 <bash0r> hyperisco: too high level ^^
11:07:18 <jle`> Justas: so, what is the type of 'x' ?
11:07:45 <EvanR> wrong level, iac
11:07:56 <fresheyeball> x :: x
11:08:04 <fresheyeball> xToY x :: y
11:08:07 <jle`> heh, rather unfortunate
11:08:17 <fresheyeball> yToZ (xToY x) :: z
11:09:30 <EvanR> what x means is clear by context, saving us millions on other variable names
11:11:54 <koala_man> Justas: in long form in Java/C#, it would be   var a = tuple.first; var x = tuple.second; var y = xToY(x); var z = yToZ(y); return new Tuple(a, z);
11:12:54 <koala_man> or shorter    return new Tuple(tuple.first, yToZ(xToY( tuple.second ))
11:14:08 <koala_man> which is identical in structure to that haskell version
11:15:10 <Justas> Wow.. thanks for such quick and detailed help. It finally clicked!
11:18:07 <Justas> Have you struggled when you've started to learn Haskell? I found koala_man example very helpful (though it is hard to compare FP with OOP, but with such small example it works really well)
11:19:46 <bash0r> Justas: it's easier to start with FP without any programming knowledge than to migrate from an OO language to, say, Haskell. This is well known.
11:20:22 <EvanR> between C and haskell i had learned lisp, which has similar function apply syntax to haskell
11:20:25 <EvanR> so it made sense
11:21:02 <EvanR> but you would still have had to manually unpack the (a,x) before using its components
11:21:08 <EvanR> haskell makes it easy!
11:21:48 <koala_man> Justas: haha yes, it's really frustrating to be a professional programmer and suddenly not be able to write or understand simple functions. It's totally worth it though
11:21:59 <Justas> I try to stay without state as much as possible in Java/PHP/JavaScript, but still it is nothing close to Haskell.
11:22:44 <bash0r> Haskell forces you to write clean code. It's not like you're only trying it. :p
11:23:01 <koala_man> learning Haskell taught me more about writing Java/C# than working in those languages ever did
11:23:19 <ddellacosta> Justas: I've been studying Haskell for years now and it's been challenging the entire way. Sometimes things that seem trivial to experienced Haskell devs trip me up, and there are plenty of actually challenging concepts to wrap your head around as well as you learn more. But I've also never felt so rewarded by learning any other language (and I program Clojure in my day job, so some functional programming con
11:23:20 <ddellacosta> cepts are not entirely new to me)
11:23:23 <jle`> keep in mind, haskell isn't about programming without state
11:23:28 <jle`> it's about being explicit with what state you have
11:24:04 <jle`> it has been said that Haskell is the best imperative language :)
11:24:18 <bash0r> jle`: I agree heavily with that statement.
11:24:30 <amalloy> bash0r: you can write unclean code in any language
11:25:32 <bash0r> amalloy: think about { doSomething(x) \n; doSomething(y); \n doSomething(z)\n\n;} something like this is harder when you write in Haskell.
11:26:18 <bash0r> I know, it's not impossible. But it's a lot harder to achieve unclean code.
11:26:39 <jle`> it's pretty easy to write unclean code in haskell, unfortunately
11:26:42 <amalloy> you're saying haskell encourages clean code because it's harder to misplace semicolons?
11:26:44 <jle`> it's one of the common gripes people have
11:27:03 <heptahedron> bash0r: `traverse_ doSomething [x, y, z]`
11:27:08 <EvanR> haskell is the best dynamic language, and the best assemlby language... hmm well lets just keep going :)
11:27:15 <jle`> just look at the monstrosities people pull out of @pl every day
11:27:30 <EvanR> its the best OOP language
11:27:41 <EvanR> or is that OHaskell
11:27:47 <bash0r> amalloy: I'm not talking about semicolons but about better syntax to replace semicolons and braces.
11:27:48 <jle`> i um, don't know if i'd say haskell is good at OOP
11:28:03 <EvanR> i dont know if i say haskell is good at imperative :(
11:28:31 <jle`> i think a good chunk of the benefits of haskell and its type system also apply to imperative code
11:28:40 <EvanR> we still cant make a global variable without having an emergency management meeting about it
11:28:40 <kadoban> Haskell is a tab verbose to write imperative stuff in. But it makes up for it by having pretty good higher-level functions and stuff.
11:28:43 <amalloy> bash0r: you chose a very poor example, then, because the weirdly placed semicolons and newlines draw attention away from the structure
11:28:47 <jle`> apply to writing imperative algorithms, i mean
11:29:01 <kadoban> I wish there was something like lens that worked on like, mutable arrays in ST for instance
11:29:26 <heptahedron> kadoban: do lenses not?
11:29:28 <jle`> stating imperative algorithms in haskell is pretty nice
11:29:35 <jle`> and you get a lot of the benefits of the type system
11:29:37 <jle`> and maintainability
11:29:37 <bash0r> amalloy: I didn't find a better example on the fly.
11:29:41 <jle`> you also can be explicit about your state, as well
11:30:02 <EvanR> to get to the point where an imperative algorithm is nice, youll likely have to set up a framework to do it
11:30:03 <Justas> Even if I don't understand Haskell code it looks so beautiful. . And so difficult! RxJs and reactive programming in general seemed difficult at first too, but this is nothing to compare with Rx..
11:30:12 <kadoban> heptahedron: Not really. I haven't yet found a great shortcut for something as simple as: writeArray a b c   lensy stuff, the types don't seem to match ever because there's an extra m floating around somewhere
11:30:13 <jle`> > foldl' (+) 0 [1..10]
11:30:15 <lambdabot>  55
11:30:28 <jle`> an imperative summing algorithm :)
11:30:32 <EvanR> no
11:30:47 <bash0r> Justas: You'll get used to it. And you'll fall in love with eta reduction.
11:31:05 <jle`> still, even if imperative programming requires some scaffolding, you get a lot of the benefits of haskell and its type system for maintainability etc.
11:31:22 <hexagoxel> speaking of state management.. does `atomicallyModifyIORefasST :: IORef a -> (forall s . STRef s a -> ST s b) -> IO b` exist already somewhere?
11:31:26 <jle`> and, imperative frameworks are nice to build in haskell
11:31:32 <jle`> look at systems like shake
11:31:47 <EvanR> i dont like building them everytime i want to write one algorithm
11:32:00 <delta3>  /quit
11:32:04 <EvanR> and then two frameworks dont work together
11:32:38 <jle`> i don't think that's been my experience when writing imperative code in haskell
11:32:56 <EvanR> my caveat was, when you want that imperative algorithm to be/look nice
11:33:06 <bash0r> Recursive descent parsers, anybody?
11:33:07 <EvanR> thats when youll need this framework, otherwise you can do the whole thing in IO
11:33:08 <kadoban> My imperative code is mostly fairly self-contained algorithms. And it's fine, it's just ... ya slightly verbose.
11:33:23 <jle`> haskell is also great for writing IO-based code, since IO actions are first-class in haskell
11:33:42 <jle`> so they can be manipulated, passed, duplicated, removed...
11:33:54 <EvanR> yeah the IO stuff is great
11:33:56 <EvanR> with async
11:34:02 <EvanR> elixir eat your heart out
11:34:12 <jle`> haskell's IO story is my favorite out of all the programming languages i've written in
11:34:32 <EvanR> that sentiment needs to be more widespread
11:34:42 <EvanR> and not "haskell is great until you need IO"
11:34:44 <Justas> Do you think learning Category theory in parallel with Haskell helps to grasp all the concepts quicker? Is it worth time?
11:35:12 <bash0r> I learned Haskell without knowledge about category theory.
11:35:31 <heptahedron> Justas: Bartosz Milewski (sp? anyone?) has a great book called Category Theory for Programmers available for free online if you want to give it a shot
11:35:43 <EvanR> PhD in math is not a requirement for haskell, just a side effect
11:35:57 <heptahedron> EvanR: does that make learning haskell impure?
11:36:04 <MP2E> Where's PhD's monad instance? :P
11:36:06 <amalloy> Justas: it is really not worth trying to do it all at once unless you already know about other math fields related to category theory
11:36:36 <amalloy> in which case i imagine it could help a little
11:36:42 <Bowlslaw> EvanR: hahhahahah
11:36:43 <bash0r> MP2E: You mean the Monad instance for newtype Learning
11:36:59 <jle`> Justas: i don't think learning category theory in parallel with haskell helps in any meaningful way with learning haskell, as a beginner
11:37:18 <jle`> once you already are familiar with haskell, it might be nice to learn it recreationally to help appreciate some of the abstractions more
11:37:25 <Bowlslaw> ^
11:37:40 <jle`> but it won't really translate into practical programming for the most part
11:38:07 <EvanR> unless youre conal
11:38:23 <jle`> yeah, usually the people who benefit the most are the people who write the frameworks and abstractions
11:38:40 <hyperisco> it would be like studying aeroacoustics while learning how to fly
11:39:00 <bash0r> ^
11:39:14 <bash0r> made my day :D
11:39:44 <EvanR> these sorts of analogies may not seem like a deterence from doing it for some people
11:40:02 <jle`> hopefully it at least tempers expectations
11:40:25 <jle`> instead of people thinking "category theory is so hard/abstract, i'll never be able to learn haskell"
11:40:39 <EvanR> it would be like learning classical electrodynamics and material science while trying to learn electronics
11:40:59 <jle`> they'd realize that they're basically saying "group and field theory is so hard/abstract, i'll never be able to learn addition"
11:41:01 <bitemyapp> more than that, a lot of the people learning category theory don't anythign about what it was intended to abstract over
11:41:24 <bitemyapp> they'd be better off learning algebra, how to write proofs, develop mathematical maturity, but those are still mostly-orthogonal goals to learning Haskell
11:41:46 <EvanR> which was what, topology, universal algebra
11:42:24 <tsahyt> I've been writing haskell for years and still only know extremely basic category theory. it's really not required at all.
11:42:42 <tsahyt> the only reason why I know what I know about CT is because I wanted to look into it, not because I had to
11:42:53 <jle`> sometimes i try to imagine an alternate timeline where haskell never developed that stigma
11:44:05 <dogui_> Can I import a module M1 defining a class C into a module M2 and re-export it, so every module importing M2 gets C?
11:44:17 <dogui_> a.k.a. can I somehow export/import classes transitively?
11:44:41 <EvanR> yes
11:45:24 <jle`> importing and exporting classes is just like importing and exporting types
11:45:57 <dogui_> ah, thanks :)
11:46:08 <jle`> it's the instances that are magical
11:46:43 <dogui_> yup
11:48:11 <Justas> After 4 days of learning Haskell til late night after day job and still struggling to write simple code makes me doubt in myself. But you guys know how to motivate! Will definitely ask for help again soon :)
11:48:52 <qeyuoa> Justas is from Lithuania
11:50:04 <jonge> EvanR: bash0r: btw. got it to work some hours ago. it was basically `runTCPServerOnce f= listenOn 123 >>= accept >>= \(h, _, _) -> f (sinkHandle h, sourceHandle h)`
11:50:07 <jle`> Justas: just think back to when you were first learning how to program
11:50:08 <jonge> thx
11:50:13 <amalloy> Justas: remember when you were first learning to program. i bet you couldn't do much of anything after 4 days
11:50:22 <Akii> Justas after 4 days of learning I couldn't print stuff to a console lel
11:50:28 <jle`> you caught us, we just read from a pre-written script
11:51:31 <bash0r> jonge: Oh, lol. Just as I stated: I'm not familiar with conduit.
11:51:36 <Bowlslaw> Justas: I recommend cis194 and Programing in Haskell by Hutton
11:51:52 <Bowlslaw> they will both have you writing Haskell code that does useful stuff
11:52:08 <Bowlslaw> i'm new, too
11:53:29 <EvanR> jonge: looks about right though i would do it on multiple lines
11:53:37 <EvanR> with do
11:54:52 <ilken14> h
11:58:46 <Justas> Bowlslaw: thanks for suggestion. Will check it out now. Have you read Christopher Allen's book "Learning Haskell from first principles"?
12:01:58 <bash0r> Justas: Just in case, Hoogle is nice to discover function names from signatures. If you're looking for a function of which you don't know the name then just put the signature in the query and it shows some functions that may match what you are looking for.
12:02:11 <Bowlslaw> Justas: I started it, but didn't get far
12:02:23 <Bowlslaw> there is also Welkin's book
12:02:28 <Bowlslaw> but I can't remember the url
12:07:19 <EvanR> Welkin has a book?
12:11:50 <Lycurgus> he's making one
12:12:02 <Lycurgus> themed on game building in hs
12:12:30 <Lycurgus> also, realized pandoc is the darcs for today only better
12:12:43 <Lycurgus> s/for/og/
12:12:46 <Lycurgus> *of
12:16:35 <qeyuoa> Might be a stupid question, but is: `data Tree a = Leaf a | Node (Tree a) a (Tree a)` a hash table?
12:16:55 <whoman> nope, tree
12:21:11 <beemo[m]> Are vectors (from vector package) lazy or strict?
12:21:52 <EvanR> Data.Vector is lazy
12:22:40 <beemo[m]> Even the unboxed and primitive vectors?
12:22:46 <EvanR> no
12:23:07 <EvanR> things with unboxed contents cant be lazy
12:23:12 <ab9rf> obviously
12:23:21 <c_wraith> also, the precise way in which they're non-strict needs to be carefully specified
12:23:30 <beemo[m]> I thought so, thanks
12:23:41 <bash0r> Any idea why Network.Socket.connect never returns?
12:23:56 <c_wraith> if you force the evaluation of a Vector, the entire data structure gets initialized - it's just that all the entries get initialized to thunks
12:23:56 <EvanR> that can happen
12:23:59 <bash0r> I try to initialize a TCP connection.
12:24:06 <EvanR> System.Timeout can help there
12:24:08 <beemo[m]> Is fmap O(1) on data.vectors
12:24:11 <ab9rf> bash0r: it doesn't feel like it
12:24:12 <beemo[m]> Or is it spine strict
12:24:52 <hyperisco> how is O(1) mapping on a vector possible?
12:25:01 <bash0r> ab9rf: after a few seconds a timeout exception arises.
12:25:07 <c_wraith> beemo[m]: if you force the creation of the vector, it has to create the thunk for every element
12:25:15 <hyperisco> even if we destroyed the invalid universes, it takes O(n) time to determine which is the valid one
12:25:56 <EvanR> bash0r: welcome to sockets... connect may not return for a long time
12:25:56 <bash0r> I'm following chapter 27 of "Real World Haskell"
12:26:02 <beemo[m]> If you dont force any value the whole vector stays in a trunk i think
12:26:08 <ab9rf> forcing a fmap over a vector will force the entire vector
12:26:14 <EvanR> you should do it in another thread if you want responsiveness
12:26:52 <whoman> hmm, not sounding good for vectors
12:27:13 <EvanR> you can avoid thunks in a Vector pretty easily
12:27:25 <EvanR> evaluate each item that goes into the vector as part of the construction process
12:27:27 <bash0r> EvanR: at the moment I'm playing in the REPL to figure out how to set things up. I used to play with TCP connections a few years back in C#, though.
12:27:31 <EvanR> then you get a vector of actual values
12:27:59 <ab9rf> bash0r: a "few seconds"?
12:28:30 <ab9rf> bash0r: if you're getting a timeout exception it's because the underlying socket implementation timed out
12:28:49 <EvanR> yeah connect can take so long to work or fail that it will interfere with GUI responsiveness
12:29:23 <ab9rf> it's a given that connect will block for an arbitrarily long time
12:29:39 <EvanR> such is the sad truth
12:30:08 <ab9rf> i've never seen a POSIX-based socket implementation that offers nonbinding connect
12:30:14 <ab9rf> er, nonblocking connect
12:30:28 <EvanR> ive certainly seen people demanding that feature
12:30:37 <ab9rf> the UNIX and Linux syscalls do not offer any means to do that, iirc
12:30:58 <bash0r> EvanR, ab9rf: In application code I'll forkFinally it. But for now I need to get a grasp on how to use getAddrInfo.
12:31:23 <EvanR> ah you think youre giving it the wrong input
12:31:31 <bash0r> Yup
12:32:02 <bash0r> At the moment it is `getAddrInfo Nothing (Just "192.0.0.1") (Just "4000")`
12:32:16 * jle` tries to imagine how an O(1) fmap would work
12:32:45 <metahumor> amortized at access time
12:32:51 <jle`> heh
12:32:58 <cocreature> fmap = error "at least it’s O(1)"
12:33:02 <EvanR> where 1 is the size of the vector
12:33:19 <EvanR> or, where you have 1 processor for each item in the vector
12:33:37 <EvanR> or, the constant factor is googolplex
12:33:47 <metahumor> x = (fmap f v) !! 0 --> x = f (v !! 0) --> that's O(1), what's the problem
12:34:15 <jle`> is that how fmap behaves for vectors?
12:34:32 <metahumor> no its not
12:34:35 <EvanR> cool optimations
12:34:40 <metahumor> its me imagining the "amortized fmap"
12:34:43 <jle`> optimate me, captain
12:34:59 <ab9rf> bash0r: i would use "(Just defaultHints)" instead of Nothing
12:36:17 <ab9rf> be warned that getAddrInfo can also block indefinitely
12:36:31 <EvanR> i just assume all of the socket calls can
12:36:49 <ab9rf> EvanR: at least the ones that have IO-valued types
12:37:45 <ab9rf> i wrote a high-performance socket library for BSD 4.3 back in 1990, and got to become very familiar with all the fun ways that UNIX TCP/IP can go belgium
12:38:05 <ab9rf> it's only gotten worse with newer OSes
12:38:24 <bash0r> ab9rf: timeout, again.
12:39:30 <ab9rf> bash0r: try running under strace (linux) or procmon (windows) :)
12:40:15 * EvanR urbans "go belgium"
12:42:09 <metahumor> how does strace/ltrace work with thunks?
12:42:15 <jle`> EvanR: it means to literally make a connection to a server in belgium, spontaneously
12:42:24 <typedrat> I'm trying to parse what is _mostly_ binary data, but with small substrings of UTF-8 where I need to enforce full-codepoint-aware restrictions (must be alphanumeric _by Unicode standards_, not just ASCII)
12:42:32 <pdxleif> @hoogle Applicative m => (a, a) -> (a -> m b) -> (b -> b -> c) -> m c
12:42:32 <lambdabot> Agda.Utils.Tuple mapPairM :: (Applicative m) => (a -> m c) -> (b -> m d) -> (a, b) -> m (c, d)
12:42:33 <lambdabot> CLaSH.Util combineM :: (Applicative f) => (a -> f b) -> (c -> f d) -> (a, c) -> f (b, d)
12:42:33 <lambdabot> Data.EventList.Absolute.TimeBody traverse_ :: Applicative m => (time -> m ()) -> (body -> m ()) -> T time body -> m ()
12:42:41 <metahumor> typedrat: O_o
12:42:51 <metahumor> typedrat: written human language was a bad idea
12:42:56 <jle`> without knowing more details...attoparsec?
12:43:08 <jle`> or maybe 'binary'
12:43:28 <typedrat> I'm using Attoparsec, I'm trying to figure out the best way to write it, since I don't want to (and can't) decode most of it as Unicode, so I can't just use Text
12:43:35 <ab9rf> EvanR: it's a HHGttG reference
12:43:37 <piark_> hello
12:43:41 <jle`> pdxleif: looks like an applicative version of 'on'
12:43:47 <jle`> piark_: hi!
12:43:56 <typedrat> and I'm staring down the barrel of having to have a parser within my parser working on a different core datatype, which is icky
12:44:10 <jle`> typedrat: can you know 'where' the unicode part will end, without parsing it?
12:44:36 <jle`> if so, maybe you can read it as a bytestring and use the parsing functions from Data.Text.Encoding
12:44:36 <ab9rf> typedrat: so part of it is Byte and part of it is Bytes that you want to interpret as unicode?
12:44:54 <metahumor> you might also like https://hackage.haskell.org/package/text-conversions
12:45:07 <EvanR> typedrat: you can get the current input stream and attempt to parse its prefix as utf8
12:45:14 <EvanR> with a custom parser yes
12:45:18 <typedrat> I know the boundaries of where it starts and stops
12:45:20 <EvanR> then reset the input stream
12:45:30 <bash0r> ab9rf: how to read the debug log? lol
12:45:34 <jle`> oh, are you also going to be 'parsing' the text, as well?
12:45:43 <ab9rf> i'd probably do what evan suggests. i've done stuff like that in attoparsec when tryint to grab large chunks of data that need to be captured but not parsed
12:45:44 <qeyuoa> I keep reading about lazy evaluation in haskell and previously in clojure, but i still don't really understand what that is. I think that `take 10 (infiniteFunc)` is an example of lazy evaluation? Another one would be where a search in a binary tree returns an answer immediatly without needing to traverse the deeper nodes?  Are these good examples of that?
12:45:44 <jle`> into a data type?
12:45:58 <EvanR> really... you wouldnt need to leave the main parser to do this
12:46:00 <jle`> qeyuoa: take 10 (infinite list)
12:46:04 <parsnip> is making a calendar parsing library a good project?
12:46:07 <typedrat> It's full RFC 6531 compliant SMTP messages
12:46:10 <jle`> not take 10 (finite function)
12:46:15 <ab9rf> bash0r: you can use strace/procmon to see what syscall is is trying to make and what the syscall returns, which may help you to undertsand why it's failing
12:46:17 <parsnip> i think there's a few already that i could get ideas from.
12:46:21 <bash0r> qeyuoa: letting the main parser handle the sub sections is a very bad idea, imho.
12:46:30 <jle`> qeyuoa: if you're familiar with javascript, you might want to try tooking at lazy.js
12:46:40 <whoman> prolog unification
12:46:44 <jle`> there are simpler self-contained examples, though
12:46:46 <ab9rf> bash0r: but that assumes you're familiar with the network syscalls, which may be a misguded assumotion on my part :)
12:46:48 <parsnip> and i'd think haskell would be great for working that out.
12:46:54 <EvanR> laziness in clojure is different than haskell
12:47:03 <typedrat> I need to 'parse' the text to ensure that it only includes unicode alphanums in the internationalized portion of the mailbox and domain name elements
12:47:04 <EvanR> fwiw
12:47:06 <jle`> qeyuoa: in many languages you might also see control flow using && and ||
12:47:25 <bash0r> ab9rf: ahh, yes. I'm sorry but I'm not familiar with syscalls.
12:47:37 <jle`> qeyuoa: `foo() || bar()` in a lot of languages only 'executes' bar() if foo() is false
12:47:47 <ab9rf> bash0r: sorry :) i've been writing network code in C since 1988 :)
12:47:56 <pdxleif> @hoogle Applicative m => a -> a -> (a -> m b) -> (b -> b -> c) -> m c
12:47:56 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:47:57 <lambdabot> Diagrams.Prelude liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:47:57 <lambdabot> Streaming liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:47:57 <qeyuoa> jle`, so is this equivalent to lazy evaluation
12:48:00 <qeyuoa> ?
12:48:11 <jle`> this as in short-circuiting || and && ?
12:48:19 <qeyuoa> yes
12:48:29 <bash0r> ab9rf: don't worry. :P It's frustrating if you follow a book (Real World Haskell in my case) and the example code just does not work. ^^
12:48:29 <jle`> it's related, although the distinction between evaluation and execution is blurred in non-haskell languages
12:48:37 <ab9rf> the vast majority of programming languages are eager with specific exceptions
12:48:50 <jle`> but look at the definition of (||) in Haskell -- it's just a normal function
12:48:56 <jle`> @src (||)
12:48:57 <ab9rf> such as || shortcutting in C
12:48:57 <lambdabot> True  || _ = True
12:48:57 <lambdabot> False || x = x
12:49:24 <ab9rf> note that "or" in Pascal is eager and strict; you can't use "or" as a guard in pascal the way you can use || as one in C
12:49:25 <EvanR> also x ? y : z, you wouldnt want y and z to be evaluated along with x to compute this
12:49:33 <jle`> > True || (log (sum [0..100000000000000000]) > 100)
12:49:35 <lambdabot>  True
12:49:52 <EvanR> so you can think of evaluation of y and z being delayed
12:49:53 <jle`> note that it doesn't have to compute the obscenely intense log (sum [0.100000000000000000000]) > 100 to immediately return True
12:50:05 <jle`> > False || (log (sum [0..100000000000000000000])) > 100)
12:50:05 <pdxleif> jle`: Maybe? I haven't used 'on' before. Right now I'm just doing g <$> f "foo" <*> f "bar", and noticed I'm repeating f - there "foo" and "bar" are both strings.
12:50:07 <lambdabot>  <hint>:1:54: error: parse error on input ‘)’
12:50:07 <jle`> ^ this one does, however
12:50:19 <jle`> pdxleif: yes it's pretty much 'on'
12:50:22 <jle`> :t on
12:50:23 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:50:34 <jle`> except instead of (a -> b) yuo have (a -> m b)
12:50:38 <jle`> :t on . liftA2
12:50:39 <lambdabot> Applicative f => (a1 -> a1 -> c) -> (a2 -> f a1) -> a2 -> a2 -> f c
12:50:43 <jle`> there ya go :)
12:51:21 <pdxleif> like maybe I could do an uncurry g <$> fmap f ("foo", "bar") if there was a Functor instance for homogeneous tuples
12:51:24 <jle`> > False || (log (sum [0..100000000000000000000]) > 100)
12:51:32 <lambdabot>  mueval-core: Time limit exceeded
12:51:32 <lambdabot>  mueval: ExitFailure 1
12:51:38 <pdxleif> Ah, interesing
12:51:46 <jle`> ^ qeyuoa
12:51:49 <pdxleif> Nice, thanks!
12:51:50 <qeyuoa> hm
12:52:04 <jle`> for `False || ...` you *have* to know if ... is True or False to know the answer
12:52:10 <jle`> so you are forced to evaluate it to figure it out
12:52:20 <jle`> but for `True || ...`, you don't need to know if ... is True or False
12:52:24 <jle`> so you can just immediately return True
12:53:00 <jle`> one way you can think of it is that arguments to functions are only evaluated if the function decides it needs to
12:53:17 <qeyuoa> but the shortcircuit is already defined, while an infinate list is processed live?
12:53:34 <jle`> whereas in eager languages, arguments are evaluated before the function even sees them
12:53:39 <jle`> qeyuoa: the laziness comes from 'take 10'
12:53:55 <jle`> 'take 10 mylist' is lazy in how it treats mylist
12:54:04 <jle`> mylist is only evaluated as much as take 10 asks
12:54:22 <u-ou> and if a variable is _ it’s never evaluated?
12:54:27 <jle`> just like how 'True || x', x is only evaluated as much as || asks
12:54:42 <jle`> u-ou: yes, but not really because it's named _, but because it's never used
12:54:54 <u-ou> ok
12:54:55 <jle`> so it's more of a syntactic convenience than a semantic thing
12:54:57 <whoman> hey guys i've got a lot of "this library is unusable due to shadowed dependencies:" how do i fix this? it happens on ghc -v
12:55:08 <u-ou> but it’s a guarantee that it won’t be used
12:55:22 <bash0r> whoman: are you using cabal or stack?
12:55:35 <jle`> yes, one enforced by special syntax
12:55:39 <whoman> bash0r: cabal
12:55:51 <jle`> whoman: try adding the library to build-depends
12:55:57 <whoman> ghc 8.2.1 trying to compile 8.2.2
12:55:59 <jle`> if you're installing/building using cabal
12:56:03 <jle`> oh
12:56:04 <bash0r> whoman: try using a sandbox or cabal new-repl / cabal new-build
12:56:05 <whoman> jle`: what 'build-depends' ? im just typing ghc -v
12:56:20 <jle`> `ghc -v ?`
12:56:27 <whoman> ...yeah..
12:56:28 <jle`> on my computer it asks for input files
12:56:33 <cocreature> whoman: are you using the Haskell platform?
12:56:39 <jle`> you can't just type 'ghc -v' alone
12:56:45 <whoman> cocreature: nope, compiled 8.2.1 from debian 8.0.2
12:56:50 <qeyuoa> jle, so the acting function/caller is always the one that makes something lazy, but not the thing that is being called?
12:56:51 <ab9rf> well, you can
12:56:56 <ab9rf> it just doesn't do anything useful :)
12:57:01 <jle`> :)
12:57:02 <whoman> jle`: telling me what i cant do after i went and gone done did it? =P
12:57:16 <jle`> whoman: what is the full command yout ype?
12:57:20 <ab9rf> it's a very verbose error message :)
12:57:21 <jle`> 'ghc -v <enter>' ?
12:57:25 <whoman> is there a way i can clear out all packages and such, or should i rebuild all things ?
12:57:38 <whoman> ```"""""""">ghc -v<"""""""'''
12:57:41 <ab9rf> since '-v' means "be verbose" and so you've asked it to compile nothing very loudly
12:57:47 <jle`> ah
12:57:53 <jle`> yeah that's not really how you compile haskell projects
12:58:01 <jle`> that's...not how you compile anything, actually
12:58:05 <whoman> heh why are you guys trippin
12:58:10 <napping> It says possibly-useful things about package databases and stuff before it gets around to complaining that you have no input files
12:58:46 <whoman> https://ptpb.pw/fRjn
12:59:02 <jle`> qeyuoa: laziness comes from the behavior of the function with respect to its arguments
12:59:10 <cocreature> whoman: you are probably going to have to kill ~/.ghc
12:59:15 <whoman> yeah.. just a vanilla run of ghc. should not be erroring even more so than if i had special private dirs and files muddying the waters
12:59:21 <whoman> cocreature: kk, trying
12:59:37 <whoman> hmm same deal. hmmmmm.
12:59:55 <cocreature> whoman: huh? at least the error message should have changed
12:59:58 <jle`> qeyuoa: a function may chose to evaluate its arguments, or it may choose not to
13:00:09 <whoman> cocreature: nope -- none of those libs were found in ~/.ghc/* tho
13:00:24 <jle`> qeyuoa: in a 'strict language', the function has no such choice, the arguments are evaluated before it even gets it
13:00:31 <cocreature> whoman: the previous error message mentions ~/.ghc, I would be highly surprised if it still does that
13:00:44 <napping> whoman: the suggestion meant to `rm -rf ~/.ghc`
13:00:45 <pdxleif> On consideration, I'm thinking atan2 <$> getDimension "y" <*> getDimension "x" might be easier to read than (atan2 `onA` getDimension) "y" "x"
13:00:52 <jle`> indeed
13:01:20 <jle`> `on` is mostly used in partially evaluated mode
13:01:31 <pdxleif> I guess I could get rid of the infix and write onA atan2 getDimension "y" "x"
13:01:33 <jle`> but when the arguments are already in scope, directly writing out the application is usualyl more readable
13:01:34 <qeyuoa> jle`, thanks. I think i will try to read the wiki page to get a better understanding how that works out "under the hood"
13:01:46 <whoman> hehe yeah i know, cocreature , napping .
13:01:56 <jle`> qeyuoa: note that strictness vs non-strictness is not quite an issue of implementation/under-the-hoodness
13:02:01 <jle`> qeyuoa: it's actually a statement about semantics
13:02:12 <jle`> so looking at how it is implemented might obscure the big picture
13:02:28 <jle`> but then again, it might help you as a step along the way
13:03:01 <whoman> i guess i've got to be -verbose as well. here u go guys. https://ptpb.pw/5WAW
13:03:39 <whoman> hm did you guys thought i was trying to `kill ~/.ghc' ???
13:04:10 <cocreature> whoman: 1. don’t install packages in the global package db. that’s pretty much always a bad idea. 2. it looks like you managed to someone break your package db. maybe just try downloading a bindist?
13:04:26 <cocreature> why are you trying to compile ghc yourself in the first place?
13:04:33 <cocreature> and why 8.2.1 instead of 8.2.2
13:04:48 <napping> whoman: no, we though you managed to get some broken packages installed into .ghc, for which deleting .ghc and reinstalling packages is a simple solution
13:04:52 <ab9rf> it took me quite a few misadventures before i got the point of "do not install packages in the global database"
13:04:58 <whoman> the obvious part of the error message changed. but what i did type out and say myself, the libraries listed were not found in ~/.ghc in the first place~A
13:05:37 <napping> Yeah, you are in a weird sitution. I guess somehow broken stuff got installed under /usr/local/haskell
13:06:18 <cocreature> there is a known bug that causes this error message https://github.com/haskell/cabal/issues/4728
13:06:30 <cocreature> although I haven’t seen this issue with 8.2.2 only with 8.2.1
13:07:16 <miko__> @pl \x,y -> f 1 x 2 y
13:07:17 <lambdabot> uncurry (flip (f 1) 2)
13:07:29 <miko__> @pl \x,y,z -> f 1 x 2 y 3 z 4 5
13:07:30 <lambdabot> (line 1, column 6):
13:07:30 <lambdabot> unexpected "z"
13:07:30 <lambdabot> ambiguous use of a non associative operator
13:08:21 <miko__> @pl \x,y,z -> f $ 1 $ x $ 2 $ y$ 3$ z$ 4 $5
13:08:21 <lambdabot> (line 1, column 6):
13:08:21 <lambdabot> unexpected "z"
13:08:21 <lambdabot> ambiguous use of a non associative operator
13:08:41 <ab9rf> read the error message
13:08:52 <ab9rf> it's at column 6, not column 20-something
13:09:31 <whoman> oh my, compiling cabal eats right through swap, much more than ghc proper. should i be using slack or what
13:09:48 <MarcelineVQ> whoman: Cabal and cabal-install are pretty hefty first compiles yeah
13:10:49 <whoman> cocreature: 1. i havent installed any packages; 2. no one has been on my computer .........; 3. the bindist is 8.0.2 --- and since you are asking about latest version, not sure why you think i am compiling 8.2.1, considering above messages -- 8.0.2 is not installed
13:10:51 <miko__> @pl \x y z -> f $ 1 $ x $ 2 $ y$ 3$ z$ 4 $5
13:10:52 <lambdabot> (((f . 1) .) .) . (. ((2 .) . (. (3 . ($ 4 5))))) . (.)
13:11:19 * whoman listens to the HDD churn the oceans
13:11:54 <whoman> cocreature: 15:55:34         whoman | ghc 8.2.1 trying to compile 8.2.2
13:12:37 <cocreature> whoman: OpenGLRaw is not bundled with GHC so somehow you managed to install that
13:12:54 <cocreature> whoman: and https://www.haskell.org/ghc/download_ghc_8_2_2.html#distros has bindists for 8.2.2
13:13:05 <bash0r> Any idea what's wrong if Network.sendTo connects but Network.Socket.connect does not?
13:13:58 <jle`> miko__: by the way, f 1 x 2 y 3 z 4 5 is actually parsed as (((((f 1) x) 2) 3) z) 4) 5
13:14:06 <EvanR> the steps you took to get the argument to connect were wrong
13:14:22 <jle`> miko__: not f (1 (x (2 (... etc. ))) like you wrote it the second time
13:14:25 <EvanR> you can check the code for sendTo
13:14:31 <bash0r> I'll read the source code of sendTo -.-
13:14:36 <EvanR> wait, sendTo and connect to different things
13:15:18 <miko__> @pl \x y z -> f  1  x  2  y 3 z 4 5
13:15:18 <lambdabot> flip flip 5 . (flip .) . flip flip 4 . (flip .) . flip flip 3 . flip (f 1) 2
13:15:25 <EvanR> compare the behavior of connectTo and connect
13:15:28 <miko__> jle`, thanks
13:19:44 <EvanR> bash0r: are you trying each of the things coming back from getAddrInfo
13:19:59 <whoman> cocreature: /bin/bash: @WithGhc@: command not found  ........ bindists never seem to work
13:20:14 <bash0r> EvanR: ouh... Only the first one.
13:23:29 <EvanR> supposely a robust client will try all of them until one works
13:23:32 <whoman> i guess binary distributions also require a local thing of ghc anyway. i will just start over from 8.0.2 -- thanks anyways for your help guys. i hope  things improve in the future
13:23:42 <EvanR> but you could print out the first one to see if its bogus looking
13:24:10 <bash0r> For purpose of debugging the issue I'll try them by hand now.
13:24:32 <bash0r> If one of them works I'll implement my client code to try each of these addresses.
13:30:41 <bash0r> EvanR: I get 3 elements from getAddrInfo; with different socket types. Stream, Datagram and Raw. The first one is Stream which should obviously be the one to go.
13:32:55 <glguy> If you only wanted one of Stream, Datagram, or Raw you should put that in the hints parameter
13:33:37 <bash0r> glguy: connection fails anyway.
13:34:58 <cocreature> whoman: did you follow the instructions on how to install the bindist and have you picked the one for your distro?
13:34:59 <whoman> does the binary distribution not come with Cabal ?
13:34:59 <whoman> just trying to get into haskell over here
13:35:15 <metahumor> what does the double hash do here? "0x10FFFF##"?
13:35:40 <glguy> getAddrInfo can return multiple address and multiple address families. You have to try all of them until one works
13:36:49 <amalloy> metahumor: a lot of context is lacking from that question, but my best guess is they're intended to mean "fill in the blank"
13:36:57 <whoman> cocreature: Yes.
13:37:10 <metahumor> "0x10FFFF :: (Num a) => a; 0x10FFFF# :: Ghc.Prim.Int#; 0x10FFFF## :: Ghc.Prim.Word#"
13:37:45 <metahumor> "1.0 :: (Fractional a) => a; 1.0# :: Ghc.Prim.Float#; 1.0## :: Ghc.Prim.Double#"
13:37:49 <amalloy> well it sounds like it is marking it as a Word instead of an Int
13:38:14 <bash0r> amalloy: an unboxed one, to be specific.
13:38:16 <metahumor> i just didn't know that you could further-magic-hash on a Ghc.Prim.Int#
13:38:17 <MarcelineVQ> metahumor: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-magic-hash
13:38:17 <amalloy> sure
13:38:52 <metahumor> i was reading http://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Char.html#chr
13:40:17 <metahumor> thanks MarcelineVQ, exactly what i was looking for
13:40:28 <bash0r> What does the Service constructor from PortID do?
13:44:39 <glguy> Allows you to look up ports by name as configured in /etc/services
13:44:46 <bash0r> Ahh
13:45:13 <whoman> does anyone know how to get cabal working from binary distribution? or is that a manual and seperate install? this should be documented on the download page.
13:45:47 <whoman> no one here has any idea what to do? are we all using haskell platform ?
13:46:04 <amalloy> whoman: IRC does not have a one-minute response SLA
13:46:30 <napping> whoman: find the cabal-install bootstrap script
13:46:33 <whoman> its about 15
13:46:58 <whoman> just wanted to know if it was manual or not. thanks.
13:47:33 <pdxleif> @hoogle Monad m => Bool -> m a ->m (Maybe a)
13:47:34 <lambdabot> Control.Monad.Loops whileM_ :: Monad m => m Bool -> m a -> m ()
13:47:34 <lambdabot> Control.Monad.Loops untilM_ :: Monad m => m a -> m Bool -> m ()
13:47:34 <lambdabot> Control.Monad.Extra whenM :: Monad m => m Bool -> m () -> m ()
13:52:07 <pdxleif> @hoogle Bool -> a -> Maybe a
13:52:07 <lambdabot> Data.Maybe.HT toMaybe :: Bool -> a -> Maybe a
13:52:08 <lambdabot> Text.XML.HXT.DOM.Util toMaybe :: Bool -> a -> Maybe a
13:52:08 <lambdabot> Agda.Utils.Maybe boolToMaybe :: Bool -> a -> Maybe a
13:52:18 <whoman> hmm lots of waste. two copies of cabal source tree, built twice inside ghc-8.2.2 as a library, and built twice in Cabal as an executable. i wonder how many binary copies are floating around now.
13:52:45 <whoman> (cabal built itself twice, and is also not using builtin ghc cabal library....? hmmmmm. very messy)
14:01:29 <siiky> hey there Haskellers! can anyone tell me where can i find the implementation of the Ord class for String? cant find it online and dont really know where else to ask/look
14:01:48 <EvanR> because its piggybacking on the Ord instance for list
14:02:07 <EvanR> you actually cant make an instance for String because its a type synonym
14:02:10 <siiky> :| that makes sense
14:02:11 <bash0r> EvanR: I'm embarassed... I feel so stupid.
14:02:15 <EvanR> (unless you enable extensions)
14:02:34 <siiky> i didnt even think of that... thanks EvanR!
14:03:10 <EvanR> bash0r: in general, or did you figure out the socket thing
14:03:13 <jle`> no need to feel stupid! :)
14:03:27 <bash0r> EvanR: it's a clear sign of me being too tired for the past 3 hours... I changed the address to 127.0.0.1 and it works.
14:03:40 <bash0r> jle`: Oh, there is reason.
14:03:42 <Tuplanolla> There's a separate instance for `Text` though, siiky.
14:04:03 <EvanR> what were you trying, 192.0.0.1? i should have caught that
14:04:43 <bash0r> EvanR: I thought my laptop was 192.0.0.1 in the network. Obviously, it wasn't.
14:04:59 <EvanR> yeah that address looks generally bogus
14:05:20 <EvanR> it might be 192.168.0.1
14:05:37 <siiky> Tuplanolla: nah, i want String :)
14:05:38 <bash0r> I'm gonna get my overdue sleep now. Thanks for help everybody. I wish a nice day / evening.
14:05:38 <EvanR> this is hypothetically why we want hostnames and not "random numbers" for network addresses
14:05:46 <[exa]> can you call STG a "lazy evaluation engine"?
14:05:51 <[exa]> or is there a better fitting name
14:06:35 <siiky> stil cant find it though... i dont even know if im looking at the right place anymore... isnt this the right place? -> https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html
14:07:15 <bash0r> I failed to see that I can use localhost in place. So names didn't help me. :p
14:08:54 <Tuplanolla> % :i [] -- I wonder if this tells you where the instance is defined.
14:08:54 <yahb> Tuplanolla: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
14:09:07 <EvanR> siiky: well.. i see something here https://hackage.haskell.org/package/base-4.4.1.0/docs/src/GHC-Classes.html
14:09:16 <EvanR> instance (Ord a) => Ord [a] where
14:10:10 <EvanR> SPECIAL EYES SPECIALISE SPECIAL LICE
14:10:21 <siiky> ah! thats it! thank you EvanR ! i was about to download the repo from GH and grep it :P
14:10:26 <Tuplanolla> % :i Ord -- It's actually this that does.
14:10:26 <yahb> Tuplanolla: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
14:10:43 <Tuplanolla> Slap that into GHCi and see, siiky.
14:11:14 <lifter> So the type of `20` is `Num t => t`. Are there other literals or values that exhibit similar behavior (that is, they have the type of `A t => t` where `A` is some typeclass)?
14:11:24 <siiky> ah yes, it says its defined in GHC.Classes
14:11:43 <kadoban> lifter: string literals with the OverloadedStrings extension on
14:11:46 <siiky> thanks again EvanR Tuplanolla
14:11:55 <lifter> kadoban: Oh yeah!
14:12:18 <[exa]> lifter: you'll get Fractional from 2.2; and you can even have OverloadedLists etc.
14:12:30 <kadoban> I think there might be one kind of vaguely for lists or something too that nobody uses, or maybe it was/is experimental? I can't remember
14:13:42 <EvanR> lifter: also, OverloadedStrings
14:13:47 <phadej> An existential or GADT data constructor cannot be used inside a lazy (~) pattern :(
14:13:53 <EvanR> and you can make your own at will
14:14:00 <EvanR> also
14:14:08 <EvanR> :t mempty
14:14:10 <lambdabot> Monoid a => a
14:14:15 <lifter> Is it correct to say that type inference resolves the type of a literal to the "least specific/concrete type"?
14:14:33 <EvanR> type inference gets the most general polymorphic type
14:14:45 <lifter> OK, right.
14:14:50 <EvanR> :t (\x -> x)
14:14:51 <lambdabot> p -> p
14:15:30 <EvanR> :t (\x y -> x)
14:15:32 <lambdabot> p1 -> p2 -> p1
14:15:52 <EvanR> which is more general than p1 -> p1 -> p1
14:16:44 <lifter> Pretty cool how that works.
14:17:51 <whoman> hey cool, after installing Cabal, now i've just got two versions of the library, and no executable. umm....
14:18:01 <whoman> not to sound disappointed
14:19:10 <Tuplanolla> Yes, `Cabal` and `cabal-install` are different, whoman.
14:19:33 <EvanR> lifter: yeah even though we often put signatures at the top level... if you unlock that and just go nuts with defining combinators its fun to see what types it produces
14:19:49 <lifter> Indeed.
14:19:50 <Tuplanolla> You want the latter.
14:20:06 <whoman> geeez
14:20:30 <whoman> can't we just have a ghc flag to run cabal using the built in library? surely its not too much trouble or bloat, considering the library is just hanging around.
14:21:38 <EvanR> :t (\x -> x x) -- the type that never was... (should fail an occurs check)
14:21:39 <lambdabot> error:
14:21:39 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
14:21:39 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
14:22:30 <EvanR> which is a lie, it can construct it. it just doesn't want to
14:23:51 <whoman> ok i give up! https://ptpb.pw/F9-l
14:32:28 <napping> whoman: that's very wierd. I'd delete everything and start over
14:32:37 <napping> https://www.haskell.org/cabal/download.html
14:32:45 <napping> Here's how to get cabal-install if you don't have it
14:33:06 <Phyx-> whoman: delete what's in ~/.cabal/packages/hackage.haskell.org
14:33:09 <napping> The source download includes a shell script that just needs ghc and wget to build you a working cabal-install
14:33:17 <Phyx-> whoman: and do update again
14:33:32 <lifter> EvanR: Tell me more about this "\f -> f f".
14:33:41 <metahumor> :t []
14:33:42 <lambdabot> [a]
14:34:06 <whoman> napping: ...
14:34:41 <Phyx-> whoman: just clear the cache and update
14:36:09 <napping> removing the directory might work, but that's a very strange error
14:36:15 <dukedave> Newbie question: How do I use a pure function with `readFile`? I tried this in Hoogle and it isn't finding anything `(a -> IO b) -> ( b -> c) -> IO c`.
14:36:55 <whoman> Phyx-: yep cool, thank you! did not know about ~/.cabal
14:36:55 <lifter> :t readFile
14:36:56 <lambdabot> FilePath -> IO String
14:37:11 <metahumor> lifter: there's also OverloadedLabels
14:37:18 <whoman> glad to know it now after going the whole circle. thanks anyways napping , that would have helped probably as well
14:37:30 <[exa]> dukedave: I guess you have a piece of code that does not work, can you paste it to lpaste.net?
14:37:33 <dukedave> If I replace `IO` with `m` then I get some `Control.Parallel.Strategies` things, but I feel like thats no correct?
14:37:35 <metahumor> dukedave: f <$> readFile myfile
14:37:49 <metahumor> :t \f path -> f <$> readFile path
14:37:51 <Phyx-> no, it would have re-used the same cache, that's how cabal persists data across updates.
14:37:51 <lambdabot> (String -> b) -> FilePath -> IO b
14:38:07 <dukedave> Ooh. that's it metahumor !
14:38:08 <metahumor> :t readFile
14:38:09 <lambdabot> FilePath -> IO String
14:38:14 <metahumor> dukedave: also know as fmap
14:38:26 <metahumor> dukedave: because IO has an instance of Functor
14:38:38 <whoman> <$> is fmap ?
14:38:43 <lifter> Yeah.
14:38:53 <whoman> cool ty. waiting for my ghci
14:39:06 <metahumor> dukedave: in fact, you can do that (fmap f) thing for any Functor! like "(\x -> x + 1) <$> Just 0"
14:39:14 <metahumor> > (\x -> x + 1) <$> Just 0
14:39:16 <lambdabot>  Just 1
14:39:28 <metahumor> > even <$> Just 0
14:39:30 <lambdabot>  Just True
14:40:11 <metahumor> dukedave: but i have an inkling that you're going to still need to do something with your "IO c" value
14:40:23 <lifter> > let f = fmap . fmap in even `f` Just (Just 2)
14:40:26 <lambdabot>  Just (Just True)
14:41:04 <dukedave> metahumor: you're right! So here's the full line, now using fmap: `features >>= mapM (\f -> stepCount <$> readFile f) >>= print`
14:42:21 <metahumor> dukedave: there was also a way to convert your pure "f" into something that you could use with the monadic bind syntax
14:42:27 <metahumor> dukedave: can you think of what it is?
14:42:36 <statusbot> Maintenance update: restarting hackage now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a8f4720a965c7429a6c8b6f
14:43:07 <dukedave> I feel like a return?
14:43:11 <dukedave> Or `pure` ?
14:43:44 <metahumor> dukedave: if your function is of type "f :: (a -> b)", how do you make a "f' :: Applicative m => (a -> m b)"?
14:43:51 <metahumor> yeah there'll be a pure in there
14:44:14 <EvanR> by doing "f" ++ "'"
14:44:18 <metahumor> it's a monad law. "fmap f x === x >>= (pure . f)"
14:46:21 <dukedave> Argh, I feel like my brain is right there, give me a moment :)
14:46:37 <metahumor> because "f :: a -> b; pure :: Applicative m => b -> m b; (pure . f) :: (Applicative m) => a -> m b"
14:47:11 <metahumor> so (pure . f) is a valid thing to be on the RHS of ">>="
14:48:41 <dukedave> Hmm, GHC doesn't like this `main = features >>= mapM (readFile >>= (pure . stepCount)) >>= print`
14:48:41 <armlesshobo> :t pure
14:48:42 <lambdabot> Applicative f => a -> f a
14:48:51 <armlesshobo> > pure 1
14:48:53 <lambdabot>  error:
14:48:53 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M887558059834...
14:48:53 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
14:48:56 <EvanR> pure, Left, Right, Just, and things like (:[])... we have so many ways to inject values in ways that "do nothing". someone might say, hell why arent things implicitly promoted like in C
14:49:04 <armlesshobo> pure Nothing
14:49:04 <statusbot> Maintenance update: Hackage up and running again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a8f4720a965c7429a6c8b6f
14:49:08 <armlesshobo> > pure Nothing
14:49:10 <lambdabot>  error:
14:49:10 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M94252...
14:49:10 <lambdabot>        prevents the constraint ‘(Show (f0 (Maybe a0)))’ from being solved.
14:49:51 <metahumor> armlesshobo: there is no generic Show instance for (Applicative f) => f a
14:49:51 <EvanR> pure Nothing results in no value, not even a program. appropriate
14:50:06 <metahumor> armlesshobo: you have to tell it which Applicative f you mean
14:50:24 <metahumor> > pure Nothing :: [] (Maybe Int)
14:50:26 <lambdabot>  [Nothing]
14:50:37 <metahumor> > pure Nothing :: Maybe (Maybe Int)
14:50:39 <lambdabot>  Just Nothing
14:51:15 <armlesshobo> don't understand Applicative yet, so it's no surprise that it didn't work out
15:04:10 <mark721> Hi guys
15:04:15 <metahumor> hi
15:04:21 <mark721> i was looking at some haskell code and learning about type declarations
15:04:36 <mark721> e.g type Pos = (Int,Int)
15:04:48 <mark721> the next line said `origin :: Pos`
15:04:51 <mark721> but that gives an error?
15:05:13 <mark721> > type Pos = (Int,Int)
15:05:13 <fishythefish> gives an error when? are you typing it straight into ghci?
15:05:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
15:05:19 <mark721> fishythefish, yes
15:05:32 <mark721> do all type declarations need to be done in files?
15:05:40 <fishythefish> mark721: you need to provide a definition as well
15:06:03 <fishythefish> i'd recommend doing it in a file and loading the module, but you can use ';' or multiline input in ghci
15:06:13 <mark721> ooo let me try :P
15:07:10 <mark721> indeed u are right
15:07:22 <mark721> why? How come u cant do type declarations across different lines
15:07:49 <mark721> *in ghci ofc
15:08:00 <fishythefish> ghci has no way of knowing that more input is coming unless you do something to let it know
15:08:11 <mark721> hmm
15:08:17 <mark721> but like i can do let mark = 5
15:08:19 <mark721> and that works fine
15:08:27 <fishythefish> of course, a definition without a typesig is fine
15:08:31 <fishythefish> it'll do type inference
15:08:34 <mark721> no what i meant
15:08:35 <mark721> was
15:08:38 <fishythefish> but a typesig without a definition is not
15:08:46 <mark721> OH so the issue is no typesig
15:08:59 <fishythefish> no, the issue is no definition
15:08:59 <monochrom> "mark = 5" uses type defaulting
15:09:11 <fishythefish> `origin :: Pos` is a typesig
15:09:12 <mark721> *edit sorry yeah that's what i meant
15:09:14 <mark721> apologies :P
15:09:22 <mark721> thanks fishythefish :)
15:11:18 <fishythefish> armlesshobo: i'm late to the party, but are you familiar with Monoid?
15:34:49 <jle`> markus1199: `origin :: Pos; origin = (3,4)` is one "unit" of code, so it has to be entered all at once
15:34:58 <jle`> *mark721
15:35:07 <jle`> oh, they are gone
15:42:21 <mark721> hi guys
15:42:48 <mark721> (again) you will prob think im crazy (i am ) :) but is there a way for all type declarations to always be taken as `deriving (Show)`
15:43:05 <mark721> i.e tell ghci to always assume `deriving (Show)`
15:43:18 <hpc> nope
15:43:20 <mark721> :(
15:43:31 <mark721> thought so
15:43:32 <mark721> oh well
15:43:37 <hpc> check out standalone deriving
15:43:38 <EvanR> that wouldnt work anyway
15:43:49 <EvanR> since not everything can have Show derived
15:43:50 <mark721> i mean if there was like a ghci bash file or something lol
15:43:54 <mark721> EvanR, oh
15:44:03 <EvanR> a better idea would be if everything had a default debug dump
15:44:03 <hpc> it's not tremendously useful in real code, but you could use it if you forget to derive something?
15:44:12 <hpc> i forget if you can write that stuff in ghci
15:44:26 <mark721> idk what that is ?
15:44:35 <mark721> [ ik its coz im lazy and i love shorcuts :) hence me asking ]
15:45:03 <whoman> just put some code in that requires a type to derive from Show
15:47:14 <mark721> http://lpaste.net/679143645005217792 guys this is somewhat mind blowing
15:47:31 <mark721> Why can "Rect" be used within a definition?
15:48:00 <mark721> Like im sure u cant do Int 5 or something
15:48:33 <geekosaur> because Rect is both a type and a data constructor.
15:48:38 <geekosaur> data Rect ... = Rect ...
15:48:41 <whoman> square (Rect x ) = ...
15:49:11 <EvanR> you may find it less confusing if you name constructors different from the type, like MkRect for the ctor
15:49:11 <geekosaur> but a numeric literal doens;t need a constructor tag, nor does a String or Char because the quotes used do it
15:49:32 <whoman> can i limit how much memory is used by cabal/ghc runtime ? its locking up my system and eating all my swap
15:50:17 <sm> @quote FAQ memory
15:50:18 <lambdabot> FAQ says: To build/link on low memory machines: use -j1, +RTS -M500m -RTS, and/or build fewer dependencies at once. Avoid swapping, it's too slow.
15:51:09 <mark721> not gonna lie im still a tad confused
15:51:10 <mark721> eli5 pls
15:51:21 <sm> whoman: yes, though it may require a bit of fiddling eg rebuilding cabal/ghc with -rtsopts to enable +RTS
15:52:09 <sm> see if cabal +RTS --help, ghc +RTS --help work
15:54:25 <whoman> sm: ah, hmm. i will give it another shot
15:55:41 <geekosaur> also note that often it's actually the linker step that eats memory and RTS opts won't help because it's C
15:56:11 <whoman> hmm true. mostly building cabal and also `cabal list'
15:56:18 <geekosaur> (because its the system linker, and binutils ld is kinda stupid and memory-wasting. But gold has lots of bugs, for being faster and lower memory. Sigh.)
15:56:35 <geekosaur> cabal list shouldn't eat memory like that. sounds like something is wrong
15:58:33 <whoman> geekosaur: i did 'cabal list | grep GL' then it stopped at the end and churned and chugged (hard reset i got no patience today=)
15:59:00 <mark721> sorry guys could you explain this again pls http://lpaste.net/679143645005217792
15:59:06 <mark721> i dont feel i follow
15:59:52 <geekosaur> how would you expect to identify that you are producing a value of type Shape, which is a Rect?
15:59:52 <mark721> NEVERMIND sorry i had a eureka moment it makes total sense
15:59:57 <mark721> yeah
16:00:02 <mark721> i literally just realised that :)
16:00:11 <mark721> thats what caused the eureka :)
16:01:50 <sm> whoman: top, M will show what's using memory
16:02:17 <whoman> sm: system was too slow =) everything stops, mouse, kbd, etc. just listened to hdd until i pressed reset
16:02:33 <sm> watch that while you do challenging builds, so you can kill and try again when needed. Don't let it get into swap
16:03:00 <sm> (next time :)
16:03:28 <sm> it's kind of sad how easy it is to kill linux this way
16:04:37 <whoman> sm: hm true ~
16:14:32 <EvanR> install the infinite turing tape kernel module
16:14:47 <EvanR> very convenient solution
16:25:01 <fishythefish> the pager?
16:36:51 <EvanR> the one that lifts current absolute max virtual memory limits
16:37:15 <EvanR> then at least you can implement "block until intern buys more ram"
16:51:46 <sm> dangit.. why doesn't my gitlab clone work when propellor runs it
16:52:18 <aplainzetakind> I'm trying to parse (with parsec) a bunch of lines starting with '#', ignoring the '#' and returning a list of the lines. Using `(many $ char '#' *> manyTill anyChar (eof *> endOfLine)` tells me `unexpected end of input; expecting end of input or new-line`, which is a rather odd complaint. Anyone have any idea why this is happenning?
16:52:43 <Welkin> don't use $
16:52:55 <fishythefish> EvanR: indeed, I've heard of this "interning" before
16:53:06 <Welkin> it may be reading it as `(many (char '#' *> manyTill anyChar (eof *> endOfLine))`
16:53:24 <aplainzetakind> Welkin: ah, indeed.
16:53:37 <Welkin> $ can be dangerous
16:53:42 <Welkin> I avoid it these days for the most part
16:53:46 <aplainzetakind> Wait, that's my intention.
16:54:19 <aplainzetakind> I want do the entire thing an arbitrary number f times.
16:54:25 <Welkin> try doing it with explicit parentheses
16:54:49 <aplainzetakind> OK, same thing.
16:54:49 <Welkin> I am unsure how the precedence will work with the other operators
16:54:56 <Welkin> althouhg $ should have the lowest
16:55:40 <Welkin> aplainzetakind: one other thing to ask is if you are using megaparsec or regular parsec
16:55:53 <aplainzetakind> regular parsec
16:55:55 <Welkin> parsec is known to have bugs
16:55:57 <Welkin> use megaparsec
16:56:02 <Welkin> it's a fork
16:56:06 <aplainzetakind> hmm
16:56:52 <aplainzetakind> alright. thanks.
16:56:59 <Tuplanolla> Your actual problem is `eof *> endOfLine`, aplainzetakind.
16:57:08 <glsubri> Hi all, I'm learning haskell and I wanted your opinion on idiomatic haskell with this: https://paste.pound-python.org/show/AMQynT51MjLFNxKukaqz/
16:57:13 <Tuplanolla> It says the file ends and then there's a line break.
16:57:35 <Welkin> that make's sense
16:57:46 <Welkin> lol
16:58:35 <Welkin> are you sure you don't mean `endOfLine <|> eof`?
17:00:53 <glguy> glsubri: I'd drop the unneeded ()s to [ e | DbDate e <- db ], but otherwise that's the nicer of the two
17:01:23 <aplainzetakind> well, tried it, now it says unexpected '#', expecting end of input.
17:02:13 <glsubri> glguy: ok, good idea. I'm still a bit confused for when are the parenthesis necessary. Is this how you would do it in haskell, I mean does it look like regular haskell or a thing that works but isn't what you often see?
17:02:31 <glguy> list comprehensions are a standard occurrence
17:02:49 <glsubri> ok, thanks
17:03:08 <Welkin> except when you don't like them
17:03:17 <Tuplanolla> You really need `try endOfLine <|> eof`, aplainzetakind.
17:03:20 <glguy> Yeah, except if you're Welkin
17:03:32 <fishythefish> anyChar overlaps with anything, so as Tuplanolla said, you need to wrap the "end" condition in a `try`, aplainzetakind
17:07:55 <aplainzetakind> putting eof and endOfLine in an alternative gives a type error, eof returns () while the other Char.
17:08:14 <aplainzetakind> That's why I attempted *>
17:08:29 <Welkin> do you need to check for eof?
17:08:33 <Welkin> isn;t endOfLine good enough?
17:10:10 <aplainzetakind> On something like "#Line1\n#Line 2\n" it works, but without the final newline it fails.
17:10:25 <fishythefish> endOfLine looks for LF or CRLF
17:11:46 <Welkin> I see
17:14:33 <fishythefish> aplainzetakind: you can wrap endOfLine with void since you don't care about the parsed newline character(s)
17:15:10 <pavolzetor>         deriving (MonadState GeneratorState)
17:15:20 <pavolzetor> newtype Generator a = Generator { gen :: StateT GeneratorState Identity a }         deriving (MonadState GeneratorState)
17:15:25 <pavolzetor> why does this fail?
17:15:50 <aplainzetakind> fishythefish: yes that did it.
17:15:52 <aplainzetakind> thanks
17:16:42 <aplainzetakind> though it's still mysterious why it failed the other way.
17:17:07 <fishythefish> with (*>)? that's because you were telling it to look for EOF followed by EOL
17:17:14 <fishythefish> hopefully it's obvious why that doesn't work
17:18:20 <pavolzetor> I am using the newtype wrapper
17:18:32 <pavolzetor> actually, why not just use type X =
17:18:33 <pavolzetor> ?
17:20:52 <aplainzetakind> fishythefish: OK. I was confused about how things fail. I kind of expected the absence of EOF to be ignored without consuming anything, but that's not the case obviously.
17:23:58 <amalloy> aplainzetakind: foo *> bar means "foo followed by bar". if part of a parser fails, the whole parser fails, unless you have provided instructions about what else to try in the event of a failure (e.g., as suggested, endOfLine <|> eof meaning "parse endOfLine, and if that fails try parsing eof instead")
17:27:17 <ertes> is there an overview of GHC version to base version correspondences?
17:32:49 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
17:33:46 <u-ou> (off-topic) but are there any programming languages for writing mathematic proofs
17:39:37 <ertes> geekosaur: thanks…  also is there a way to tell cabal to generate the stuff in 'autogen', most importantly Paths_*.hs without building the project?
17:40:08 <ertes> u-ou: agda, coq, idris, lean, …
17:40:28 <u-ou> thanks, I’ll look at those
17:40:29 <geekosaur> I don't know of one
17:41:09 <ertes> geekosaur: sorry, i shouldn't have highlighted you with that question
17:41:55 <ertes> u-ou: if you want to learn type theory, check out agda…  if you're only really interested in writing proofs, check out coq
17:42:07 <ertes> u-ou: if you want to check out something more bleeding-edge, check out lean
17:43:55 <u-ou> ok
17:49:32 <amalloy> or for a truly general-purpose language for writing proofs in, LaTeX
17:53:22 <u-ou> I’m talking about something that will ‘compile and run’ your proof, so to speak.
18:22:04 <jle`> @tel pavolzetor deriving (MonadState)
18:22:04 <lambdabot> Consider it noted.
18:32:50 <edwardk> )
18:32:57 <edwardk> er wrong window
18:39:07 <dedgrant> whaaat.. this feels ... im-pure: fmap (const x) undefined
18:43:06 <lijero> dedgrant: you mean how the "undefined" is evaluated?
18:46:14 <dedgrant> I know it isn't necessarily evaluated, just that I think this is the first time I've stumbled on such code as a drop-in for pure.
18:47:39 <dmwit> It isn't a drop-in for pure.
18:47:51 <dmwit> It behaves differently for *most* Functors.
18:48:25 <dmwit> Probably Proxy is the only one where it "works".
18:48:37 <dmwit> > fmap (const 3) undefined :: Proxy Int
18:48:40 <lambdabot>  Proxy
18:48:50 <dmwit> > fmap (const 3) undefined :: [Int] -- works for almost nothing else
18:48:52 <lambdabot>  *Exception: Prelude.undefined
18:49:51 <[Leary]> > (const 3 <$> undefined :: Int -> Int) 2
18:49:53 <lambdabot>  3
18:51:44 <dedgrant> Yes that makes sense since in most cases the structure must be evaluated.
19:10:31 <jchia_2> vinyl question: What's the relationship between ElF/=:: listed in code blocks in Data.Vinyl.Tutorial.Overview and ElField/=: defined in Data.Vinyl.Derived? (http://hackage.haskell.org/package/vinyl-0.7.0/docs/Data-Vinyl-Tutorial-Overview.html & http://hackage.haskell.org/package/vinyl-0.7.0/docs/Data-Vinyl-Derived.html). When I use vinyl do I typically make my own ElF etc like in the tutorial or use ElField? ElF and ElField seem to serv
19:10:31 <jchia_2> e similar purpose but I don't understand why the tutorial is making its own ElF.
19:34:48 <pjk> dd
20:53:42 <batman_> how to convert custom type with 4 value constructor to a ByteString >>?
20:54:49 <boj> batman_: you may want to look at the "binary" package
20:56:18 <batman_> boj : something more specific in binary package you can point to >?
20:57:09 <boj> batman_: there's not much to it really. you use "get" and "put" to convert your data type between binary and itself
20:58:01 <boj> err, s/binary/bytestring
20:59:11 <batman_> boj : one more thing how do you write type definition for a function which takes three Chan (Control.Concurrent) as input
20:59:26 <batman_> boj : i meant function definition
21:00:03 <boj> batman_: probably something like
21:00:29 <boj> actually, what you do you mean?
21:00:57 <pacak> foo :: Chan Int -> Chan Bool -> Chan Blah -> ...
21:00:57 <boj> like: f :: Chan Int -> IO ()  ?
21:02:02 <batman_> boj : got it and how do you write output type if function is writing to chan in one case & printing in another case IO () ??
21:02:37 <boj> it depends, but IO () sounds likely
21:04:53 <batman_> boj : it says     Expected type: IO ()         Actual type: IO GHC.Conc.Sync.ThreadId
21:05:21 <batman_> boj : should i directly relace the type or it should be something else
21:05:37 <boj> you'll have to lpaste your code, not sure what it means without context
21:06:09 <calloc> Why does "fmap :: (b -> c) -> Maybe b -> Maybe c" work, but "fmap :: a -> Maybe b -> Maybe c" fail?
21:06:22 <metahumor> :t fmap
21:06:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:06:37 <metahumor> calloc: fmap has to take a function as the first argument
21:06:47 <calloc> Can't 'a' be assumed to be a function?
21:06:48 <batman_> http://lpaste.net/362814
21:07:16 <boj> calloc: no, a is a. a -> b is a function
21:07:44 <metahumor> no, because "a" would be polymorphic over all types, while we specifically need the type of a function where the (a) matches (Maybe a) and (b) matches (Maybe b)
21:08:15 <metahumor> like, the type of fmap is not "(a -> b) -> Maybe c -> Maybe d"...
21:09:30 <boj> batman_: your function assumes a ThreadId is returned. does the last function return one?
21:09:39 <calloc> Is there a way to constrain all the types, but the first arument?
21:09:51 <boj> batman_: probably not because it runs in a forever loop?
21:10:03 <calloc> fmap :: ? -> Maybe b -> Maybe c
21:10:22 <batman_> boj : no it's just a UDP send function
21:10:27 <pavonia> calloc: What are you trying to do?
21:10:39 <boj> batman_: you probably just want it to be IO () then
21:11:43 <calloc> I'm trying to figure out why this won't work: (\f p -> (f <$ string "foo" <*> p)) :: a -> Parser b -> Parser String
21:12:01 <boj> batman_: never mind, you are doing a forkIO. sorry
21:12:49 <calloc> I was hoping to sonstrain the known types and figure out what the remaining type looks like.
21:12:59 <boj> batman_: can you post the actual error in the lpaste?
21:13:04 <calloc> *constrain
21:14:44 <woodson> stack build keeps break because when I import a package it cant find it.. example "import Data.Text"
21:14:53 <woodson> but it is clearly in my cabal file
21:14:54 <batman_> boj : http://lpaste.net/362815
21:15:04 <jle`> calloc: what do you expect (f <$ string "foo" <*> p) to do
21:15:08 <woodson> anyone knows what else could cause this problem?
21:15:27 <jle`> woodson: what's the error?
21:15:39 <woodson>  Could not find module ‘Data.Text’
21:15:40 <woodson>     Use -v to see a list of the files searched for.
21:15:40 <woodson>   |
21:15:40 <woodson> 5 | import Data.Text
21:15:49 <jle`> also, are you using hpack/package.yaml ?
21:15:58 <woodson> jle: yes I am using it
21:16:05 <jle`> because that would overwrite your cabal file deps
21:16:14 <jle`> you would have to add it as a dep to your package.yaml
21:16:19 <calloc> jle`: parse foo, throw the result away, then use the result of the p Parser as the first argument of f.
21:16:40 <woodson> its actually in my package.yml
21:16:45 <jle`> calloc: is f a function then?
21:16:58 <calloc> jle`: yea
21:17:03 <jle`> so it can't be just 'a'
21:17:08 <jle`> it has to be some (??? -> ???)
21:17:31 <jle`> (b -> String) presumably
21:17:44 <metahumor> calloc: the operators are infixl
21:18:00 <jle`> also yes be sure you are doing (f <$ string "foo") <*> p
21:18:06 <jle`> and not f <$ (string "foo" <*> p)
21:18:16 <metahumor> so you want "f <$> string foo *> p"
21:18:38 <woodson> jle: if I run stack ghci I dont get an error
21:18:42 <woodson> just with stack build
21:19:05 <jle`> try stack install
21:19:38 <metahumor> woodson: you have "text" in your package.yaml under "lib"?
21:19:44 <calloc> Is there a way to show the parenthesized result in ghci?
21:19:50 <juri_> is anyone here using accelerate with a video card?
21:19:59 <jle`> woodson: can you paste your package.yaml?
21:20:40 <woodson> metahumor: under executable
21:20:41 <woodson> http://lpaste.net/272893533269000192
21:21:20 <metahumor> and where are you trying to "import Data.Text"?
21:21:38 <jle`> try adding it under lib, or under the global part
21:21:43 <jle`> (under line 23)
21:22:19 <metahumor> usually, most of your actually dependencies go in lib. app is usually more about dependencies of dealing with command line flags, etc
21:22:26 <metahumor> at least, that's how i do it
21:23:01 <woodson> jle: That was the issue
21:23:10 <jle`> thank metahumor :O
21:23:16 <woodson> thanks guys
21:23:21 <woodson> I was using nix for a bit
21:23:27 <woodson> then went back to stack
21:23:33 <woodson> and that package.yml file
21:23:36 <woodson> got me confused
21:23:54 <woodson> Thanks again!
21:23:58 <jle`> no problem!
21:24:04 <jle`> package.yaml is actually not necessarily a stack thing
21:24:39 <woodson> jle: not sure but when i did stack new it created that file for me
21:24:58 <jle`> yeah that's just because the default stack template uses hpack for some reason
21:25:13 <jle`> but you can use hpack with nix/.cabal with stack too
21:25:22 <metahumor> "new-template" defaults to using hpack
21:25:57 <woodson> ahh, i see
21:58:23 <calloc> metahumor jle` boj : Thanks for your help. I think I figured out the root of the problem. I was trying to write that function to accept what I thought would be subparsers. E.g. "f (p1 <*> p2)". I decided to skip writing that function rather than pass around tuples.
22:02:46 <metahumor> calloc: what's the larger problem you're trying to solve?
22:06:20 <batman_> i have some 300 loc in haskell and most of the functions output has type IO, IO ThreadID , IO by most i mean 90 % of functions, is that a bad practice and how to avoid it
22:07:07 <metahumor> if most of then are dealing with Chan, then you probably can't
22:07:10 <calloc> metahumor: I'm parsing a custom text database. I want to pass subparsers to a function.
22:07:57 <metahumor> calloc: well, "p1 *> p2" will be regular old "Parser a2"
22:08:15 <ab9rf> parsers are values that you can pass about pretty much arbitrarily
22:08:19 <metahumor> i mean, of that type, it'll be the type of p2
22:08:21 <MacSlow> How does one "convert" an IO [String] to [String}? I'm trying to read command-line arguments and this IO monad thing is giving my noob-brain much pain. Thanks in advance!
22:08:28 <ab9rf> MacSlow: you can't
22:08:38 <MacSlow> *sigh*
22:08:52 <metahumor> MacSlow: you don't. but you can utilize the mobit by working within IO
22:08:52 <ab9rf> MacSlow: what you can do, however, is push a function into an IO a to turn into into an IO b
22:09:38 <MacSlow> hm... then what example can you suggest to provide a basic overview how to read command-line arguments into some int-values?
22:10:13 <metahumor> "./calcLength hello" gives me back 5
22:11:16 <metahumor> "getArgs >>= (print . length)"
22:11:24 <metahumor> that's it
22:11:47 <metahumor> if "getArgs :: IO String" gives me back the arguments as one big string
22:11:57 <metahumor> :t print . length
22:11:58 <lambdabot> Foldable t => t a -> IO ()
22:12:07 <MacSlow> ab9rf, metahumor: I got that I can't convert it... but your hints of how to proceed I just don't understand (yet).
22:12:08 <ab9rf> metahumor: i seem to recall that it's a list of strings
22:12:15 <calloc> To pass the parsers, it looks like I would have to pass tuples of them "foo (p1, p2)". I had hoped that I could do something like Foo <$ (p1 <*> p2), but that doesn't seem to work.
22:12:40 * MacSlow keeps reading books
22:12:43 <metahumor> calloc: you want to do something with both parsers? why not just "foo p1 p2"?
22:12:57 <metahumor> MacSlow: how are you getting the args? what's the type of that function?
22:13:21 <ab9rf> i usually do something like do args <- getArgs; let arg1 = (read (args !! 0)) :: Integer in myFunc arg1
22:13:46 <calloc> metahumor: p1 :: Parser a
22:13:57 <ab9rf> although i've left several important things out of the equation here (lkike checking that args isn't empty)
22:14:01 <MacSlow> metahumor: getArgs from System.Environment
22:14:12 <ab9rf> in a real program i'd use one of the command line parsing libraries
22:14:32 <metahumor> MacSlow: if your "getArgs :: IO [String]", come up with a function "f :: String -> Int" that deals with an argument
22:14:32 <calloc> And foo needs to work with variable numbers of subparsers.
22:15:06 <metahumor> calloc: what will foo do? that answer will help me explain how to write it to use a variable number of subparsers
22:15:43 <metahumor> MacSlow: if you have such a function, or some number of such functions, we can then work together to bind them onto the result of your getArgs
22:15:51 <calloc> foo will throw away some initial strings, some end strings, and add error messages.
22:17:06 <metahumor> calloc: foo :: [InitialParser c] -> [EndParser b] -> [BodyParser a] -> Parser a"??
22:17:13 <calloc> foo f p = f <$> (string "prefix" *> p <* string "suffix") <?> "error"
22:17:59 <metahumor> looks great to me
22:18:02 <calloc> where p may be multiple arguments to f
22:18:20 <metahumor> calloc: you're using attoparsec?
22:18:43 <guest_> hi guys I am trying to use Crypto.PubKey.Ed25519 libray of haskell  (from https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html) how to use this library any examples?
22:18:53 <metahumor> calloc: how would you like to combine those "multiple argument" p's?
22:19:15 <calloc> foo Baz (p1 <*> p2)
22:19:37 <ab9rf> if they're alternatives, you can (probably) just fold them with (<|>)
22:20:06 <metahumor> are you sure you want to do (p1 <*> p2)? that would mean "p1 :: Parser (a -> b); p2 :: Parser a; (p1 <*> p2) :: Parser b"
22:20:25 <ab9rf> i think there's a standard combinator that's [Parser a] -> Parser a that does that, though
22:20:46 <calloc> I just realized what I can do.
22:21:03 <calloc> Baz doesn't have to be applied in foo.
22:21:10 <metahumor> calloc: i agree with ab9rf, sounds like you want "foo f ps = f <$> (string "prefix" *> choice ps <* string "suffix) <?> "error" "
22:21:21 <calloc> foo (Baz <$> p1 <*> p2)
22:21:28 <metahumor> ab9rf: "choice :: Alternative f => [f a] -> f a"
22:21:28 <ab9rf> metahumor: is that choice? it's been a few months since i used attoparsec for anything
22:21:50 <ab9rf> metahumor: oh, from Alternative
22:22:16 <calloc> p1 and p2 are not alternatives.
22:22:26 <ab9rf> calloc: how are they used, then?
22:22:31 <calloc> They are arguments to a data constructor.
22:22:41 <metahumor> calloc: you can also do "liftA2 Baz p1 p2"
22:22:49 <ab9rf> ah, so you need to caputre their values and push them into a constructor?
22:22:59 <calloc> indeed
22:23:06 <ab9rf> that's Constructor <$> p1 <*> p2, if i recall correctly
22:23:16 <metahumor> ab9rf: weirdly, "choice" isn't defined in Control.Applicative
22:23:27 <calloc> metahumor: liftA2 Baz <*> p1 <*> p2?
22:23:42 <metahumor> calloc: "liftA2 f a b === f <$> a <*> b"
22:24:09 <metahumor> in fact, that's how liftA2 is defined generally
22:24:41 <metahumor> to write an Applicative instance, you need to write pure and ((<*>) xor liftA2)
22:24:49 <ab9rf> i usually use "Constructor <$> field1 <*> field2 <*> ...."
22:25:04 <ab9rf> where each of the fieldn's is a parser of the appropraite type for the cosntructor
22:26:02 <guest_> hi guys I am trying to use Crypto.PubKey.Ed25519 libray of haskell  (from https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html) how to use this library any examples?
22:26:19 <calloc> It works! Exactly what I wanted. Thanks metahumor and ab9rf!
22:27:31 <xacktm> guest_: does the tutorial help or no? https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Tutorial.html
22:29:31 <guest_>  <xacktm>: no , I trying to use secreatKey function from  https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html
22:35:19 <guest_> I am trying to use secreatKey function from  https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html any example how to use it ?
22:36:18 <whoman> secrete ?
22:37:06 <guest_> <whoman> secretKey
22:38:07 <whoman> guest_: secretly what ?
22:38:55 <guest_> <whoman> secretKey is a function from  https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html this library
22:41:08 <pavonia> guest_: You just pass a String/ByteString/whatever of the proper size to that function and it tries to make SecretKey out of it
22:45:19 <guest_> <pavonia>: this is my code http://lpaste.net/362816
22:45:52 <guest_>  <pavonia> : but does not work
22:46:29 <pavonia> Define "does not work"
22:46:43 <whoman> pavonia: see error message
22:46:50 <whoman> 'Redundant do, line 8:8"
22:47:14 <pavonia> You can ignore this, that's not an actual error
22:48:05 <guest_>  <pavonia>  :  this is error http://lpaste.net/362817
22:49:02 <pavonia> secretKey returns a value of type "CryptoFailable SecretKey", it's not an IO action
22:50:02 <pavonia> So you could do something like "case secretKey s of { CryptoPassed key -> ... do something with key ...; ... handle error case otherwise ... }"
23:12:49 <guest_> \quit
23:19:46 <piyush-kurur> cborg library for cbor, has any one used it
23:20:16 <piyush-kurur> the people involved seem like haskell overloads but I do not hear much about this library
23:21:50 <piyush-kurur> as opposed to something like Aeson I mean
23:24:23 <vaibhavsagar> piyush-kurur: the reverse dependencies listing is inconclusive: https://packdeps.haskellers.com/reverse/cborg
23:25:13 <piyush-kurur> vaibhavsagar: yeah that is why I asked
23:25:15 <vaibhavsagar> I'm inclined trust the well-typed people though
23:25:19 <vaibhavsagar> *to trust
23:26:06 <batman_> how is protocol buffer's haskell implementation if not good what is the best alternative for haskell ??
23:26:13 <piyush-kurur> yes with people like ekmett, hvr, dcoutts invovled
23:26:59 <piyush-kurur> it is difficult to distrust
23:27:49 <vaibhavsagar> batman_: http://hackage.haskell.org/package/protocol-buffers looks good and was recently updated
23:28:45 <srk> also https://github.com/cauterize-tools/cauterize
23:29:11 <batman_> vaibhavsagar : let's assume it's not good enough what would be a better alternative ??
23:30:14 <vaibhavsagar> batman_: not good enough how?
23:30:52 <piyush-kurur> vaibhavsagar: is there a way to have serialisation instances derived like in say aeson
23:30:53 <piyush-kurur> ?
23:31:26 <piyush-kurur> I mean for the protocol-buffer
23:32:40 <vaibhavsagar> piyush-kurur: I've never worked with protocol buffers, but this looks like it's provided by a different library: https://hackage.haskell.org/package/protobuf
23:33:10 <vaibhavsagar> unfortunately protobuf doesn't look as well-maintained
23:33:49 <piyush-kurur> vaibhavsagar: that is the problem I had whenever I tried looking at protobuf
23:33:59 <piyush-kurur> in contrast Aeson is a delight to use
23:35:39 <vaibhavsagar> there is also https://github.com/google/proto-lens
23:36:21 <vaibhavsagar> and https://github.com/awakesecurity/proto3-suite
23:36:42 <vaibhavsagar> I'm a huge fan of anything that Awake Security do
23:38:34 <metahumor> funnily, i can't find a good capnproto lib
23:38:37 <metahumor> in haskell
23:53:55 <dminuoso> Given this example from the wiki `f xs = reverse @ (_a -> _a) xs
23:54:05 <dminuoso> What's the point of naming the wildcard here?
23:54:18 <metahumor> why not
23:54:51 <dminuoso> metahumor: Well it seems to have no purpose. Im beginning to think the example is not very illustrative for what this is for
23:56:38 <pavonia> What does the @ do in the example?
23:56:44 <dminuoso> opqdonut: Type application
23:56:45 <johnw> it's a type application
23:56:55 <johnw> :t reverse
23:56:56 <lambdabot> [a] -> [a]
23:57:02 <johnw> it's providing the meaning of "a" here
23:57:19 <johnw> thus, reverse specialized to [(_a -> _a)] -> [(_a -> _a)]
23:58:02 <dminuoso> johnw: So implying that this is an array of id functions.
23:58:29 <dminuoso> johnw: I understand thanks.
23:59:00 <pavonia> I'm not sure I understand. To what exactly is the part after @ referring?
23:59:13 <johnw> forall a. [a] -> [a]
23:59:23 <johnw> you can see this as two arguments really, a type argument and a list argument over that type
23:59:24 <dminuoso> pavonia: If you write: f :: a -> a -> a, it implicitly means: f :: forall a. -> a -> a -> a
23:59:35 <johnw> @ lets you provide the type argument
