00:00:14 <danilo2_> Hmmm ok there is some name aliasing but hmm I believe GHC resolves it right. I typed the kinds explicitly in the first code with the same error
00:01:23 <cocreature> danilo2_: the problem is that you want "'Map ('(k,v) ': _)" to have kind "Map k v" but it has kind "Map k0 v0" where "k :: k0" and "v :: v0"
00:09:22 <Cheery> I have plenty of types that consist of functions, but I would still like to see what is going on in them.
00:10:39 <Cheery> Is there any way to implement 'Show' such that it checks up stuff from a name table?
00:11:19 <dminuoso> @tell dmwit Regarding #14782 That turned out quite surprising. I mean the MR bit I get, but it's still a bit weird that an implementation detail of dictionary passing effectively rendered seq'ing useless for polymorphic variables.
00:11:19 <lambdabot> Consider it noted.
00:11:47 <cocreature> Cheery: how should that work if a function is dynamically constructed?
00:12:39 <Cheery> cocreature: it could label it, and if I then want to print the label, maybe print out the internal representation of the function?
00:12:41 <cocreature> Cheery: the answer to your actual question is: no there is no way to get a useful Show instance for functions. you can ofc use a dummy instance and show the rest of your type
00:14:55 <dminuoso> cocreature: I guess there is
00:14:56 <dminuoso> :t typeRep
00:14:58 <lambdabot> forall k (a :: k) (proxy :: k -> *). Typeable a => proxy a -> TypeRep
00:15:18 <dminuoso> That's what I use when I need to dump things I dont know how to dump otherwise.
00:15:54 <cocreature> dminuoso: that doesn’t seem particularly useful in a Show instance. you already know the type of the field in that case
00:17:24 <cocreature> and it requires that you carry the Typeable constraint around
00:18:51 <Cale> Cheery: That would typically break referential transparency, if I understand what you're describing.
00:19:46 <parsnip> at this exercise in exercism.io http://lpaste.net/362385
00:20:13 <parsnip> having a little trouble, not sure what to do with Vector, and implementing Matrix.
00:20:46 <parsnip> i tried `data Matrix a = [[a]]` and `data Matrix a = [Vector a]`
00:20:54 <dminuoso> parsnip: Dont use [] at all.
00:21:08 <parsnip> Vector (Vector a)) ?
00:21:16 <dminuoso> parsnip: For example, yes.
00:23:16 <shramana> i'm reading the zip list section from the "Learn You a Haskell", and it says ZipList's <*> is implemented like this:
00:23:22 <shramana> ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
00:23:27 <shramana> but when i checked the source it's actually implemented like this:
00:23:30 <shramana> ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
00:23:36 <shramana> does this mean (\f x -> f x) is equivalent to (\x -> x)?
00:24:51 <parsnip> :t id
00:24:52 <lambdabot> a -> a
00:25:30 <Cheery> Cale: I suppose it would break something, I still would like to see what's going on when I am using function types in structures.
00:25:33 <Cale> shramana: Yes of course
00:25:57 <parsnip> :t (\x -> x)
00:25:58 <lambdabot> p -> p
00:26:06 <parsnip> :t (\f x -> f x)
00:26:07 <lambdabot> (t1 -> t2) -> t1 -> t2
00:26:17 <parsnip> looks a little different to me
00:26:22 <Cale> Cheery: A possible solution is to pair up your functions with some sort of description of what the function is.
00:26:26 <geekosaur> which is the same as (t1 -> t2) -> (t1 -> t2)
00:26:35 <geekosaur> now take a ~ (t1 -> t2)
00:26:56 <parsnip> so it's okay because partial functions?
00:27:10 <parsnip> any x could be a function?
00:27:14 <geekosaur> no, it;s because a type 'a' can unify with any type, including a function type
00:27:23 <geekosaur> functions are not special
00:28:08 <parsnip> but... the arrow in the type is different than the arrow in the lambda, so i'm having a tricky time keeping it straight.
00:28:14 <Cheery> Cale: well.. yeah. In my case it might be sensible to do an interpreter of some sort, that has printable function representations.
00:28:20 <dminuoso> shramana: Think about it. what is \f x -> f x  really?
00:28:22 <shramana> geekosaur: oh i kinda see it
00:28:22 <Cheery> Cale: going afk
00:28:31 <dminuoso> shramana: And more to the point, how do you use it?
00:28:46 <shramana> so it's like the id function can take anything including the function
00:28:57 <geekosaur> :t id `asTypeOf` ($)
00:28:58 <shramana> and just return the same thing
00:28:59 <lambdabot> (a -> b) -> a -> b
00:29:03 <geekosaur> @src ($)
00:29:03 <lambdabot> f $ x = f x
00:29:18 <parsnip> ZipList fs <*> ZipList xs = ZipList (zipWith (\x -> x) fs xs) ?
00:29:19 <dminuoso> shramana: my point is: \f x -> f x itself curries.
00:30:04 <geekosaur> parsnip, when you write it there, you need to specify both parameters since you use both parameters. but its *type* can be one thing, that is a function type.
00:30:15 <geekosaur> the -> there is indeed different from the one in a type
00:30:35 <dminuoso> shramana: now: since `id x = x`, then it follows that `id x y = x y`
00:30:55 <parsnip> 00:23 <shramana> does this mean (\f x -> f x) is equivalent to (\x -> x)?
00:30:57 <parsnip> 00:25 <Cale> shramana: Yes of course
00:33:20 <dminuoso> parsnip: Btw, the reason you want to avoid [] is simple: Tell me the time complexity of random access in []
00:33:50 <kuribas> id is more general
00:35:15 <parsnip> dminuoso: random access? O(n)? i wasn't as worried about speed, sometimes i just try to get a working solution first.
00:36:30 <dminuoso> parsnip: Then use it as practice to get used to Vector then :P
00:36:39 <kuribas> parsnip: a O(n^2) solution is not a working solution
00:37:04 <parsnip> well, i mentioned [Vector a]
00:37:15 <dminuoso> parsnip: You already have Vector. Why mix it with list?
00:37:19 <parsnip> kuribas: not working because tests will eventually fail?
00:37:29 <kuribas> parsnip: because it will not scale
00:37:52 <parsnip> dminuoso: i'm new to vector, didn't know if it was idiomatic to have vector of vector.
00:37:59 <kuribas> parsnip: and because in the majority of cases there is an easy solution which isn't O(n^2)
00:38:54 <kuribas> parseval: though there are exceptions.
00:38:57 <dminuoso> parsnip: Well a linked list of vectors to represent a matrix is certainly not more idiomatic. ;-)
00:39:35 <kuribas> is hackage only down for me?
00:39:46 <kuribas> parsnip: there's a matrix package
00:40:00 <dminuoso> kuribas: I think part of the excercise is to write the implementation himself.
00:40:02 <dminuoso> ;-)
00:40:04 <parsnip> hackage is working here
00:40:07 <kuribas> oh, right :)
00:40:38 <dminuoso> parsnip: I wish I had started earlier with Vectors honestly. ;)
00:41:12 <kuribas> parsnip: you know you can make a vector of vectors?
00:41:24 <parsnip> no, i'm into it, just, i cannot stop doing these, and when i try to open one up as midnight passes, and it's a pretty new topic...
00:41:56 <parsnip> yes, since you guys insist that it's reasonable, i'm okay with it.
00:41:57 <dminuoso> Not exactly sure why Haskell seems to shove linked lists down everyones throat at the beginning.
00:42:05 <dminuoso> Is it just that they are more elegant algebraically?
00:42:21 <kuribas> dminuoso: yeah
00:42:31 <parsnip> well, haskell tends to wrap things with quite a bit of magic
00:43:08 <parsnip> for example, Hackage reports most Vector operations as O(1), but we all know that's not exactly true.
00:43:19 <dminuoso> parsnip: Why is that not exactly true?
00:43:22 <parsnip> isn't it a tree or something?
00:43:40 <parsnip> isn't it basically O(1) only because some big unit thing?
00:43:56 <parsnip> like Word16 or whatever?
00:43:58 <kuribas> parsnip: no, vector is an array basicly
00:44:11 <kuribas> parsnip: you may think of scala's vector?
00:44:43 <parsnip> "basically"?
00:45:13 <kuribas> parsnip: vector is an array with a lot of magic to make some operations more efficient.
00:45:27 <dminuoso> parsnip: The only "special" thing is that in a Boxed vector its actually a vector of pointers
00:45:36 <dminuoso> but they are still stored consecutively and can be accessed at O(1)
00:45:54 <dminuoso> (So with a boxed vector you still dont get locality of reference)
00:45:58 <kuribas> well, it also uses type families to give more compact representations.
00:46:12 <kuribas> So you get zip and unzip in constant time.
00:46:15 <parsnip> Tell me, what do you do with witches?
00:46:35 <parsnip> so you admit, magic!
00:46:52 <kuribas> parsnip: it's not really magic, just advanced haskell type hackery :)
00:47:00 <kuribas> and fusion rules etc...
00:48:17 <kuribas> though fusion can be somewhat unpredictable
00:48:55 <kuribas> parsnip: for example, it can elliminate intermediate vectors.
00:49:02 <kuribas> Or turn it into a loop...
00:49:05 <ertes-w> hllo
00:50:18 <kuribas> hi
00:50:40 <epicallan> Hi everyone, I am kindly looking for some code review & feedback for one of my first real world use case haskell projects https://github.com/epicallan/crypto-bot-hs
00:50:50 <ertes-w> parsnip: one advantage of always using the right data structure for the job is that the right data structure usually also comes with the right API for the job =)
00:51:02 <nshepperd1> It's only the unboxed vector type that gets zip/unzip i thought
00:51:06 <ertes-w> parsnip: so you get both speed and nicer code at the same time =)
00:52:22 <parsnip> hmm, was it Map that is tree but effectively O(1)?
00:52:36 <parsnip> i'd guess they have multiple implementations anyways.
00:53:02 <parsnip> like javas listarray, hasharray, etc.
00:53:12 <nshepperd1> IntMap is a radix tree sort of thing
00:53:33 <parsnip> aahhh, i've had the benefit of reading about some of those now.
00:53:49 <parsnip> took about a year detour messing with python and then clrs.
00:54:21 <parsnip> got about a solid month of clrs studying
00:54:36 <nshepperd1> It's effectively O(1) because Ints are only 64 bits
00:57:03 <kuribas> O(log(n)) is effectively O(1) for n being any physical quantity.
00:57:11 <typetetris> Is it normal that there are cases where `cabal build` takes forever and a lot of ram, while `ghc --make -idir1:dir2 -o blub dir1/Main.hs` runs in like no time and no ram?
00:58:39 <geekosaur> typetetris, -j1 may help
00:58:54 <geekosaur> cabal can try to build in parallel; this is not a good idea on low memory systems
01:04:41 <typetetris> called cabal -j1 build, still it eats all memory (8GiBi) and takes long.
01:06:15 <poapoa> Hi there, do you have an idea by chance how to express `\x -> foo x >>= bar >>= baz` using the binds only (no lambda)? Feels like it should be possible, but can't think of a way..
01:06:38 <phadej> :t (>=>)
01:06:39 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:07:03 <poapoa> phadej: Nice! Thanks!
01:08:42 <sbrg> i'm using beam with postgres, and it looks like that when inserting rows into the database which contain text which contains some unicode characters, they get mangled. does anyone have any idea if whether this could be a problem with beam/postgres-simple, or whether it could just be something that is incorrectly configured?
01:10:02 <typetetris> Is there a chance that it is more work for ghc or the linker to produce the library in the packages? (ghc --make will only make the executable of course.) And if it is so, why?
01:11:23 <Cale> sbrg: Just any higher unicode characters, or is it certain things in particular? I can't say much about beam specifically, but I've used postgresql-simple with unicode and had it work fine.
01:13:12 <sbrg> Cale: it seems basically anything not within standard ascii.
01:13:43 <sbrg> i guess i'll have to go to beam's issue tracker then
01:13:56 <Cale> Yeah, in that case, I've used postgresql-simple (and groundhog) with unicode (e.g. Japanese characters) successfully.
01:14:12 <Cale> Are you using Text?
01:14:15 <sbrg> yep
01:15:26 <ankitsiam> i have defined an algebric data type called person with {age :: Int,name :: String} when i try to serialize it using Kademlia DHT package i get following error  "No instance for (Read Person) arising from a use of ‘reads’"
01:15:45 <ankitsiam> this line is giving me trouble case (reads :: ReadS Person) . C.unpack $ bs of
01:15:49 <ankitsiam> please help guys
01:16:22 <Cale> ankitsiam: Sounds like you didn't derive Read?
01:18:07 <parsnip> Couldn't match expected type ‘Vector (Vector a)’ with actual type ‘Matrix a’
01:18:15 <parsnip> oh nm
01:18:26 <parsnip> hmm
01:18:38 <ankitsiam> Cale : dude thank you so much :)
01:19:04 <ankitsiam> one last error remains Couldn't match expected type ‘Maybe (a1, K.Node KademliaID)’                   with actual type ‘(a0, b0)’
01:19:07 <Cale> ankitsiam: haha, no problem
01:19:20 <a0> Hmm
01:19:35 <a0> So many highlights on this channel
01:19:58 <Cale> sbrg: Oh, does beam not use postgresql-simple underneath? It looks like it does its own query generation
01:20:26 <tdammers> a0: would it be offensive to say that you're asking for it?
01:20:35 <a0> tdammers, certainly not
01:20:45 <tdammers> phew
01:21:43 <Cale> Oh nevermind, it does use it...
01:22:43 <ankitsiam> <cale> can you please look at this "Couldn't match expected type ‘Maybe (a1, K.Node KademliaID)’                   with actual type ‘(a0, b0)’"
01:22:46 <sbrg> Cale: yeah it does its own query generation, but it uses postgres-simple's connection stuff i believe
01:23:26 <parsnip> http://lpaste.net/362386
01:24:15 <Cale> sbrg: Well, of course it does some of that, but postgresql-simple also handles some interpolation. I'm not 100% sure either way whether it takes advantage of that -- it might not, and in that case, it may get it wrong
01:24:44 <Cale> ankitsiam: Seems self-explanatory. I can't really tell you how to change your code if I can't see it.
01:24:46 <sbrg> yeah, it seems like it. i'm whipping up a reproducible example for the issue tracker.
01:25:00 <sbrg> i really don't want to go back to persistent ---
01:25:15 <merijn> sbrg: Join the club :p
01:25:26 <merijn> Although, I suppose I technically didn't leave yet...
01:25:32 <merijn> sbrg: What are you using now?
01:26:16 <sbrg> beam
01:26:19 <sbrg> or I'm trying
01:26:31 <ankitsiam> cale : here is the part throwing error "let exampleValue = Person 25 "Alan Turing"             K.store secondInstance (KademliaID . C.pack $ "raxqT") exampleValue              -- Look up the value and it's source             (value, source) <- K.lookup firstInstance . KademliaID . C.pack $ "raxqT"
01:27:33 <merijn> sbrg: I keep hearing about beam, but haven't looked at it yet. Have you looked at Selda and/or Opaleye?
01:27:34 <Cale> ankitsiam: Presumably K.lookup is producing a Maybe result. Rather than pattern matching a pair, you could case on it.
01:28:30 <sbrg> merijn: selda I haven't, nope, but I've taken a glance at opaleye. the reason we really want to use beam is because it supports almost all of most of the sql standards
01:28:36 <sbrg> and nice things like window queries for postgres
01:29:05 <sbrg> but it seems that beam is mangling the unicode data when it's constructing the queries
01:29:10 <sbrg> since i can get it to dump the sql
01:29:11 <sbrg> <.<
01:29:47 <tdammers> IME the whole "I need to persist my data structures" problem is notorious in that it's fairly straightforward to do it for one specific project where you have all sorts of constraints and conventions in place, but generalizing it into a library usually ends up being a higher-order mess
01:30:36 <tdammers> so far, I've had the best results just writing the required code (and meta-code) myself, with the specifics of the project at hand in mind
01:30:58 <merijn> I just wish most of these abstractions were piercable. With my soon to be upstream patch to persistent-sqlite I can get access to the raw SQLite pointer, but sadly not to a raw statement, which means my binds are limited to what persistent supports
01:31:20 <tdammers> exactly
01:31:27 <tdammers> I'm also a huge fan of hard-coded queries
01:31:30 <merijn> tdammers: Yeah, I plan to drop persistent in favour of sqlite-simple, direct-sqlite Real Soon Now
01:31:38 <merijn> tdammers: But I can't invest that time right now
01:31:49 <merijn> Hard-coded queries are kinda limiting
01:32:04 <merijn> I'm actually doing quite a bit of text manipulation to construct queries
01:32:21 <Cale> We've been using groundhog (which is similar to persistent, but relaxes a few of its limitations), and postgresql-simple, and that's been kind of okay. I wrote some quasiquoters to make it a little nicer after getting sick of trying to count the ?'s to figure out where my new parameter needs inserting in the tuple
01:32:43 <sbrg> beam seems to bypass some of this stuff quite elegantly. but to be honest, I'm not very experienced when it comes to rdbms, nor the libraries that haskell provides for talking to them. i have some experience with persistent, but we were hoping to avoid the linear compile time growth via template haskell, and we were also hoping to use some of the more advanced features of postgres, and beam seems to be able
01:32:44 <sbrg> to do that
01:33:22 <sbrg> but so far the experience hasn't been great. beam-migrate is very alpha still, lots of missing instances and whatnot, and apparently beam-core mangles unicode.. if I can't get that fixed soon-ish it's gonna be a dealbreaker unfortunately
01:33:29 <merijn> sbrg: The Haskell libraries aren't quite great at DB interaction
01:33:48 <Cale> http://lpaste.net/362387
01:34:07 <tdammers> depends how you structure things, but yes, mild degrees of query construction are usually inevitable
01:35:18 <merijn> If I wasn't stuck with this persistent interface I could trivially solve like half my issues (i.e. sharing the result of an SQL function across each row in a query) by just manually binding the result
01:38:21 <Cale> merijn: You mean, while avoiding a roundtrip to the database?
01:39:18 <merijn> Cale: The only way I can think of doing this is introducing a temporary table, which wouldn't be thread-safe if shared across queries
01:39:32 <merijn> Cale: AFAIK there's no way to do what I want/need, no matter how inefficient
01:39:35 <Cale> You mean across multiple transactions?
01:40:02 <Cale> I was thinking you just do one query for the value you want, and then do another in the same transaction which uses the result.
01:40:44 <merijn> Cale: That doesn't work when the datatype returned isn't supported by persistent
01:42:47 <ankitsiam> cale : how exactly can i extract value from a maybe tuple using case >?
01:43:18 <YungMoon> how can i conditionally append a Maybe element to a list?
01:43:50 <jle`> YungMoon: under what condition?
01:43:58 <YungMoon> jle`: if it's `Just x`
01:44:02 <Cale> case result of
01:44:05 <Cale>   Nothing -> ...
01:44:09 <YungMoon> Cale: in one line
01:44:10 <Cale>   Just (u,v) -> ...
01:44:15 <jle`> YungMoon: one line is a bad thing
01:44:19 <YungMoon> jle`: no
01:44:24 <YungMoon> i want to know the most concise way
01:44:27 <Cale> Sorry, that was an answer to ankitsiam's question
01:44:36 <jle`> the most concise way is 90% of the time the worst way
01:44:47 <YungMoon> jle`: but not in this case
01:44:55 <jle`> you don't want the most concise way
01:44:57 <jle`> you want the most readable way
01:45:00 <YungMoon> no
01:45:02 <Cale> :t maybe id (:)
01:45:03 <YungMoon> i want the most concise way
01:45:03 <lambdabot> Maybe a -> [a] -> [a]
01:45:10 <jle`> is this for a code golfing competition?
01:45:13 <YungMoon> Cale: thanks
01:45:15 <jle`> or are you writing readable code
01:45:25 <jle`> you can probably use 'maybeToList' too, which is in base
01:45:27 <jle`> :t maybeToList
01:45:28 <lambdabot> Maybe a -> [a]
01:45:40 <jle`> > [1,2,3] ++ maybeToList (Just 10)
01:45:41 <lambdabot>  [1,2,3,10]
01:45:44 <jle`> > [1,2,3] ++ maybeToList Nothing
01:45:46 <lambdabot>  [1,2,3]
01:46:09 <Cale> > maybe id (:) (Just 5) [1,2,3]
01:46:10 <lambdabot>  [5,1,2,3]
01:47:56 <Cale> I usually hesitate to make use of 'maybe' even though it's often cute. I just have found that I eventually end up replacing a lot of them with case expressions anyway. If the code you're writing is unlikely to ever change though, it's probably fine.
01:47:57 <YungMoon> jle`: thanks to you too :)
01:48:15 <YungMoon> Cale: i already use `maybe` a lot in my current code
01:48:41 <Cale> If it encodes the whims of some "business logic", then better just to stick to case ;)
01:49:07 <jle`> yeah, case should definitely be preferred if you ever intend to read your code in the future
01:49:28 <jle`> or debug it
01:49:55 <Cale> Though maybe is not nearly such a bad sign as explicit uses of >>= which aren't followed immediately by \case :)
01:50:03 <ankitsiam> cale : but how to do exactly collect those values so that i can use them. (Sorry for silly questions it's been just a week since i'have started using haskell so..)
01:50:56 <Cale> ankitsiam: So something like   result <- K.lookup firstInstance . ... -- what you had before
01:51:08 <Cale> ankitsiam: and then on the next line, you can  case result of ...
01:51:30 <Cale> ankitsiam: and then you have to decide what happens in the Nothing case, as well as the case where you successfully get a pair
01:51:30 <typetetris> Ahh it was the optimisation settings ...
01:51:47 <Cale> at least, if I intuited the types of things correctly -- I'm not entirely sure that I did :)
01:52:40 <YungMoon> jle`: Cale: how can this be written in a point-free style (eliminating the `setVarString` and `submit` args)? http://pastebin.centos.org/545181/18429130/
01:52:48 <YungMoon> (that's purescript)
01:53:04 <Cale> That is the worst syntax highlighting I've ever seen
01:53:10 <YungMoon> yea
01:53:28 <YungMoon> no love for haskell syntax..
01:53:36 <merijn> wow...
01:53:39 <merijn> YungMoon: Use lpaste.net
01:54:14 <merijn> heh...CString is not defined in Foreign.C.Types?
01:54:20 <Cale> @pl \u v -> x <#> (\f -> f u v)
01:54:20 <lambdabot> ((x <#>) .) . flip . flip id
01:54:25 <Cale> ^^ you basically don't
01:54:45 <Cale> as in, it's possible, but the result is pretty much unreadable
01:55:20 <ankitsiam> cale : now i'm getting this error "Couldn't match expected type ‘IO (K.Node KademliaID)’                   with actual type ‘()’"
01:55:46 <Cale> okay, so you have an empty tuple where an IO action was expected
01:56:21 <YungMoon> Cale: thanks. what was the first step going from the original to what you came up with? (i know what flip and . are)
01:56:53 <Cale> YungMoon: You mean where I replaced the list with x, and used u and v instead of setVarString and submit?
01:57:41 <YungMoon> Cale: no the first pointfree reduction step
01:57:46 <sbrg> > let condAppend m xs = maybe xs (\x -> xs ++ [x]) m in condAppend (Just "foo") ["bar"]
01:57:48 <lambdabot>  ["bar","foo"]
01:57:50 <sbrg> oops
01:57:57 <Cale> Oh, I dunno, you'd have to look at the source for the @pl plugin
01:57:58 <sbrg> wasn't scrolled <.<
01:58:11 <Cale> I don't think it has a way of showing its steps
01:58:23 <YungMoon> Cale: i mean, don't you know the steps?
01:58:25 <ankitsiam> cale : can you take a look at this code here : https://hackage.haskell.org/package/kademlia-1.1.0.0/docs/Network-Kademlia.html
01:58:56 <ankitsiam> cale : block below this is giving me troubles "-- Make sure the joining was successful"
02:00:33 <Cale> https://hackage.haskell.org/package/pointfree-1.1.1.3/docs/src/Plugin-Pl-Transform.html
02:02:12 <Cale> @unpl flip . flip id
02:02:12 <lambdabot> (\ x x0 y -> y x x0)
02:02:19 <akegalj> I am trying to figure out how to write a function which would take some constructor (from a sum datatype that derives a Generic) and return a String - name of a constructor. For example `data SomeSumDatatype = A Int | B Int Int deriving Generic` . How to use Generic and get somethime like `constructorName :: SomeSumDatatype -> String` - for example `constructorName $ A 1 == "A"` . I am trying to see how
02:02:25 <akegalj> to get this via https://hackage.haskell.org/package/generics-sop-0.3.2.0/docs/Generics-SOP.html#v:constructorName
02:02:26 <Cale> YungMoon: ^^ figuring that out is really most of it
02:02:33 <ankitsiam> cale : was that link for me ?
02:02:43 <merijn> akegalj: Why are you trying to do that?
02:02:45 <Cale> But that isn't really the sort of thing I would usually attempt
02:03:23 <Cale> ankitsiam: Why don't you paste your actual source code on lpaste.net along with the error?
02:03:25 <akegalj> merijn: to autogenerate some stuff in swagger documentation in our project (ie, list of error types)
02:04:03 <Cale> ankitsiam: It looks like the type of lookup changed since that example was written
02:04:21 <Cale> (but thanks for the link to the documentation anyway, since it tells me the types of the things you're using)
02:05:16 <ankitsiam> cale : http://lpaste.net/8583398283135680512
02:05:51 <ankitsiam> cale : error http://lpaste.net/362390
02:06:10 <akegalj> merijn: we have a working function that takes a Proxy a (a datatype) and produces list of constructor names [Text] from a sum datatype (ie, error datatype `data OurError = ErrorA | ErrorB |....`). But I wonder how to do it via providing constructor, not datatype
02:06:29 <Cale> ankitsiam: That was the old error
02:07:05 <ankitsiam> <cale> actually i couldn't properly follow steps you suggested so i gave you the original code
02:07:07 <Cale> ankitsiam: So where you currently have  (value, src) <- ...  make that  result <- ...
02:07:33 <Cale> ankitsiam: and then on the next line, well, whatever, you could just  print result  if you want
02:07:51 <Cale> But if you wanted to be analogous to the original code, you'd have to handle the case where the lookup failed and you get Nothing
02:07:55 <Cale> So you'd have something like
02:07:58 <Cale> case result of
02:08:09 <Cale>   Nothing -> putStrLn "Sorry, couldn't find it!"
02:08:18 <Cale>   Just (value, src) -> print value
02:09:47 <freeman42x[NixOS> any ideas why using backspace during getLine would print ^? instead of deleting previous character?
02:10:02 <Cale> Because you don't have line buffering on
02:10:05 <freeman42x[NixOS> up arrow prints ^[[A
02:10:41 <Cale> Try doing  hGetBuffering stdin  and see what the result is.
02:10:56 <Cale> (those things are in System.IO)
02:11:24 <freeman42x[NixOS> yeah: NoBuffering
02:11:37 <Cale> If you do  hSetBuffering stdin LineBuffering
02:11:47 <ankitsiam> cale : now it throws more errors http://lpaste.net/5752327124908244992
02:12:09 <Cale> it'll enable backspace to work, because the characters won't get sent to the program until the user actually commits the line
02:14:05 <Cale> ankitsiam: add  deriving (Eq, Ord) to the definition of the KademliaID type, and add Eq to the list of classes we're deriving for Person
02:14:12 <freeman42x[NixOS> Cale, yeah, that fixed it for backspace
02:14:24 <freeman42x[NixOS> Cale, but if I press up arrow it still prints ^[[A is that normal?
02:14:35 <Cale> yes, that's normal
02:14:58 <Cale> If you want fancy shell-like line editing, there are libraries for that...
02:15:01 <focu5> hello
02:15:23 <focu5> can somebody help me with Tasty withResource and smallcheck
02:15:35 <focu5> I can't seem to play the type teris
02:15:52 <Cale> perhaps https://hackage.haskell.org/package/haskeline
02:16:06 <focu5> for reference (code is at the bottom) http://lpaste.net/7690978545169858560
02:16:34 <focu5> I dont quite understand how to pass in my resource into a smallcheck property
02:16:38 <Cale> What's the error?
02:16:41 <jle`> fwiw haskeline is the library that ghc uses for ghci
02:17:55 <ankitsiam> cale : one more http://lpaste.net/362392
02:18:15 <jle`> akegalj: so you mean (constructorName (A 1)) == "A"
02:18:17 <jle`> * do
02:18:34 <focu5> well it's broken really hard in all forms i tried
02:18:38 <freeman42x[NixOS> Cale, so basically I can only delete the previous character, no way to use left arrow or right arrow to tweak specific parts? this is because of getLine behaviour?
02:18:58 <focu5> I specifically wanted to ask how to pass in an IO a resource into a smallcheck test
02:19:04 <jle`> freeman42x[NixOS: getLine is not really meant to be an interactive input kind of system
02:19:10 <jle`> freeman42x[NixOS: it's mean to pull things in from stdin
02:19:27 <jle`> *meant
02:19:44 <freeman42x[NixOS> Cale, jle` ok, thank you. Didn't know it worked that way
02:19:59 <jle`> a "featureful" input environment is more than just pulling in from stdin :)
02:20:10 <jle`> it's basically an entire large application's worth of stuff
02:20:30 <freeman42x[NixOS> jle`, I assumed that left and right arrows is so hard to do
02:20:35 <freeman42x[NixOS> isn't
02:20:50 <akegalj> jle`: exactly. I know I can accomplish that with a something hackish like `head . words . show` , but I wonder how to do this properly with Generic
02:20:56 <jle`> freeman42x[NixOS: it isn't, but that's a basic feature of an interactive input environment
02:21:21 <jle`> well, it might actually be tricky, depending on how robust you need to be
02:21:33 <jle`> it's a feature of some sort of application that presents the user with an interactive input environment
02:21:46 <jle`> getLine is not that kind of thing
02:21:50 <jle`> it just pulls from stdin
02:22:15 <dminuoso> ertes: Hey by the way I was bored and implemented Store and the respective Comonad instance. Things are becoming so clear now.
02:22:19 <jle`> if you've ever used an application on the command line like vim or nano, etc., that provide interactive text editing, it's the same sort of deal
02:22:41 <jle`> getLine doesn't create an interactive application, it just pulls from stdin :)
02:22:47 <Cale> ankitsiam: oh, what's your current code?
02:22:48 <dminuoso> ertes: https://gist.github.com/dminuoso/97a62e425f899bb438910d7af2749734 time to do the automaton now =)
02:23:24 <ankitsiam> cale : http://lpaste.net/362393
02:23:37 <Cale> ankitsiam: ahhh...
02:23:38 <jle`> freeman42x[NixOS: the behavior you are seeing right now is actually your terminal emulator getting its stdin from you, the interactive user
02:23:43 <Cale> ankitsiam: Yes, that explains it :)
02:24:00 <ankitsiam> cale : i want to know too :)
02:24:05 <Cale> ankitsiam: putStrLn wants a String, and so we must have read a String from firstInstance in that case
02:24:22 <jle`> freeman42x[NixOS: ghc/haskell asks for stdin, and your terminal responds by asking you for it interactively, so it's pretty rudimentary
02:24:35 <Cale> ankitsiam: and that's only possible if String is an instance of the K.Serialize class, which oddly enough, it isn't (because the library author didn't provide one)
02:24:45 <Cale> But we probably didn't want to read a String anyway
02:25:00 <Cale> We probably wanted a Person
02:25:26 <Cale> So, if you do something like  print (value :: Person)  instead of  putStrLn value
02:25:42 <freeman42x[NixOS> jle`, it is just weird for me, I would assume minimal functionality of text editing: backspace, delete, left arrow, right arrow, home, end, etc.
02:25:50 <Cale> that should help it figure out what we're trying to read, and Person is an instance of Serialize, so that problem will go away
02:26:10 <jle`> freeman42x[NixOS: getLine just asks for stdin
02:26:22 <jle`> freeman42x[NixOS: and your terminal is what fulfils that request, in this situation
02:26:31 <jle`> freeman42x[NixOS: not haskell/ghc
02:26:52 <freeman42x[NixOS> jle`, in terminal I can do those things though
02:26:54 <jle`> freeman42x[NixOS: getLine is just "pull from stdin", which is basically a text stream
02:27:04 <jle`> freeman42x[NixOS: do you mean bash?
02:27:09 <jle`> or whatever shell program you are using?
02:27:12 <freeman42x[NixOS> yeah
02:27:18 <jle`> because bash/etc. implements its own interactive editing environment
02:27:44 <jle`> it's the application that you configure with your ~/.bashrc, etc.
02:27:46 <ankitsiam> <cale> : thank you so much man.. it's working now.
02:28:14 <jle`> freeman42x[NixOS: 'haskeline' is a nice haskell library that implements an editing environment that is pretty robust and featureful
02:28:28 <jle`> freeman42x[NixOS: so if you want featureful input, like how bash implements it, you could use that
02:28:37 <jle`> freeman42x[NixOS: but that's a completely different thing than just "pull from stdin"
02:28:48 <Cale> ankitsiam: no problem
02:28:55 <merijn> jle`: Unfortunately it's requirement of a MonadException is a PITA, since no one bothered to describe how you're supposed to implement that class >.<
02:29:21 <jle`> i just use IO, heh
02:30:21 <jle`> freeman42x[NixOS: consider using a haskell program non-interactively
02:30:31 <jle`> freeman42x[NixOS: if you pipe in data or feed in stdin in some other way
02:30:39 <merijn> jle`: I need to query the database, so I'm stuck with that underneath InputT
02:30:40 <jle`> cat myfile.txt | ./my_haskell_app
02:30:50 <Putonlalla> You could also use `rlwrap`.
02:30:58 <jle`> freeman42x[NixOS: in that case, 'getLine' is just a way to access what is piped in through stdin
02:31:02 <jle`> that's "all" it is
02:31:12 <jle`> it was never meant to be an interactive editing environment
02:31:26 <freeman42x[NixOS> jle`, got it, thank you :)
02:31:31 <jle`> it just accesses stdin, like in cat myfile.txt | ./my_haskell_app
02:32:09 <jle`> that's why when you do backspace, etc. normally, you actually send in control characters through stdin
02:32:37 <jle`> ghc asks for stdin, the terminal pipes in your input directly, you send a control character, getLine receives that
02:32:50 <jle`> (depending on how your terminal treats it)
02:33:48 <Cale> merijn: Presumably only by deriving ;)
02:34:00 <jle`> getLine does not create an interactive editing environment; if it did, then cat myfile.txt | ./my_haskell_app would drop into an editing environment ... just to pull from myfile.txt ?  doesn't quite make sense
02:34:07 <Cale> merijn: and hope that you only have ReaderT to deal with
02:34:45 <merijn> Cale: There are readert compatible things, but they obviously don't implement MonadException
02:35:16 <merijn> Cale: I have MonadUnliftIO available, which close enough, yet different enough that trying to figure out how to piece them together keeps screwing with my brain
02:35:20 <Cale> I mean, you derive MonadException for the things which are defined using ReaderT... all the way up
02:35:42 <Cale> Unless you don't control some of that code, and then you pull your hair out
02:35:50 <jle`> interleaving interactive input with database queries feels kinda suspect in the first place though
02:35:55 <merijn> Cale: Not for things that are not defined using ReaderT but as similar newtypes
02:36:12 <merijn> jle`: Why?
02:36:12 <Cale> merijn: Newtypes of ReaderT? :)
02:36:17 <merijn> Cale: Sadly, no
02:36:21 <Cale> ah
02:36:27 <jle`> wouldn't you want to know exactly what it is you are querying before you make the query?
02:36:54 <focu5> can anybody explain how to create a smallcheck property from IO a (IO a -> Property ...) or even more broadly create a tasty TestTree
02:36:57 <jle`> or do things in separate distinct steps?
02:36:57 <merijn> jle`: I don't see how that's related?
02:37:25 <focu5> i cant figure out how to pass in the IO a resource from tasty's withResource into a smallcheck property
02:37:25 <merijn> jle`: No, because the commandline is for inserting things into the database, plus I wanna do auto-completion based on what's already in the database
02:37:27 <jle`> merijn: you could use haskeline to generate the information for your query, and parameterize your request on that info
02:37:40 <Cale> https://hackage.haskell.org/package/haskeline-0.7.4.2/docs/src/System-Console-Haskeline-MonadException.html#controlIO -- there are some examples here of how to write it, in helpfully-incomprehensible points free style
02:37:56 <merijn> Cale: I know, I've been staring at if for like 2 hours
02:37:58 <Cale> haha
02:38:02 <jle`> ah i see what you mean
02:38:15 <Cale> @unpl fmap (ReaderT . const) . run . flip runReaderT r
02:38:15 <lambdabot> (\ x -> fmap (\ x0 -> (ReaderT) (\ _ -> x0)) (run (runReaderT x r)))
02:38:36 <oo_miguel> I can not see how "ap" is equivalent to "liftM2 id". Is this true? And can somebody help me to understand this?
02:38:50 <merijn> Cale: For something like LoggingT it's trivial to reimplement it by copying ReaderT, but ResourceT is another story
02:38:56 <jle`> oo_miguel: does it help if you write it as `liftM2 ($)`
02:38:58 <Cale> oo_miguel: It is true, and first you might want to see that ($) is a special case of id
02:39:05 <oo_miguel> jle`: This one I underestand
02:39:15 <jle`> oo_miguel: then, do you see that:
02:39:20 <jle`> ($) :: (a -> b) -> (a -> b)
02:39:24 <jle`> ($) = id
02:39:28 <jle`> is the definition of ($) ?
02:39:31 <Cale> liftM2 f x y = do u <- x; v <- y; f x y
02:39:32 <Cale> so
02:39:38 <Cale> liftM2 id x y = do u <- x; v <- y; id x y
02:39:41 <jle`> oo_miguel: and haskell evaluation says that you can replace any value with its definition
02:39:50 <Cale> oops
02:39:53 <Cale> lol, variables
02:40:00 <Cale> liftM2 f x y = do u <- x; v <- y; f u v
02:40:03 <jle`> oo_miguel: so if ($) is defined as 'id', then 'liftM2 ($)' is 'liftM2 id'
02:40:23 <Cale> liftM2 id x y = do u <- x; v <- y; id u v = do u <- x; v <- y; u v
02:40:40 <Cale> and that's exactly how ap is defined
02:41:06 <oo_miguel> ah ok wait
02:42:04 <Cale> merijn: Snoyman'd
02:43:02 <merijn> Cale: Like I said, I'm pretty sure MonadUnliftIO is powerful enough to do what I need, since it's supposed to capture "unlifting ReaderT style monads to IO" and ResourceT is MonadUnliftIO
02:43:32 <Cale> yes, you're probably right about that
02:43:40 <Cale> it's practically the same shenanigans
02:44:13 <Cale> The UnliftIO type is identical to RunIO
02:44:59 <merijn> Cale: controlIO wants "IO (m a)" instead of "IO a", which is the main issue. I figured "I can just "fmap return", but all the RankN stuff gets GHC and me really confused
02:45:14 <Cale> and withRunInIO is the same as controlIO, except where the definition of UnliftIO/RunIO has been inlined (the newtype has been removed)
02:45:20 <Cale> oh, hmm
02:45:49 <merijn> I tried just using withRunInIO and fmap'ing, but GHC started throwing rigid skolem escapes at me, etc.
02:46:43 <ankitsiam> cale : hey buddy now i'm getting run time errors
02:46:45 <ankitsiam> cale : kdht2.hs: Network.Socket.sendTo: invalid argument (Invalid argument)
02:46:54 <ankitsiam> cale : kdht2.hs: threadWait: invalid argument (Bad file descriptor)
02:47:41 <Cale> ankitsiam: This library you're trying to use, it looks a bit half-baked to begin with... I'm not sure how complete or correct it is.
02:48:06 <Cale> merijn: Perhaps I'll give it a try
02:48:17 <ankitsiam> cale : even i think so but do you see any problem here which can be solved for now
02:48:59 <focu5> i got my code down to the one error i cant figure out
02:49:05 <oo_miguel> Cale: jle`: oooook I finally see that "id f"  is equivalent to "($) f"..  Thank you for helping
02:49:06 <focu5> http://lpaste.net/7690978545169858560 (at the bottom)
02:49:22 <jle`> no problem!
02:49:39 <focu5> i dont understand how IO a can be unwrapped as im pretty sure it cannot be
02:50:06 <focu5> so it has to integrate with the output monad somehow which in this case is smallchecks Testable m a
02:50:14 <focu5> but i cant figure out the type tetris
02:51:05 <kosmikus> akegalj: is https://github.com/kosmikus/sop-haskellx-bytes-2017/blob/master/SOP.hs#L160-L168 the function you were originally asking for?
02:51:35 <focu5> based on the updated tasty docs/blog it's really similar to testCase "name" $ getResource >>= testFoo
02:51:42 <focu5> but that's for HUnit
02:55:28 <AWizzArd> https://hackage.haskell.org/package/mono-traversable-1.0.2/docs/src/Data-Sequences.html#line-1488   – what is  (c ~ Char)   within   instance (c ~ Char) => Textual [c] where   ?
02:59:26 <jle`> it is a constraint that 'c' has to be Char
02:59:54 <jle`> @let negate' :: (a ~ Bool) => a -> a; negate' True = False; negate' False = True
02:59:55 <lambdabot>  Defined.
02:59:57 <jle`> :t negate'
02:59:58 <lambdabot> Bool -> Bool
03:00:02 <jle`> aw man
03:00:11 <jle`> :t negate' :: (a ~ Bool) => a -> a
03:00:13 <lambdabot> Bool -> Bool
03:00:47 <jle`> i'm certain that that shows up differently in ghci
03:04:05 <AWizzArd> jle`: I activated  {-# LANGUAGE TypeFamilies #-}  and tried your example.
03:04:16 <AWizzArd> It showed me   negate' :: Bool -> Bool
03:04:48 <AWizzArd> I wonder though why one wouldn’t want to say    negate' :: Bool -> Bool    instead of using this constraint syntax.
03:05:13 <jle`> in the case of negate there sin't a real reason
03:05:21 <jle`> but for typeclass instances it's pretty useful
03:05:25 <statusbot> Maintenance update: restarting hackage now -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a8171fae5102804daf8f21a
03:10:22 <ankitsiam> a program i was working on compiled succesfully but on runtime it's giving some errors "Network.Socket.sendTo: invalid argument (Invalid argument)"
03:10:33 <ankitsiam> "Network.Socket.recvFrom: invalid argument (Bad file descriptor)"
03:11:21 <statusbot> Maintenance update: Hackage is up & operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a8171fae5102804daf8f21a
03:15:58 <ertes-w> what's the default default-language?  do i still have to specify it for h2010?
03:17:09 <hvr> ertes-w: yes... we could however define a default starting w/ cabal-version:3.0
03:17:38 <hvr> ertes-w: the trouble is that also need a way to "unset" the default-language
03:17:42 <hvr> which we don't have yet
03:18:08 <hvr> i.e. to deliberately request e.g. GHC's default "language" setting, which is neither Haskell2010 nor Haskell98
03:18:29 <hvr> but some slightly deviating GHC dialect
03:18:42 <ertes-w> really?  what's the difference to h2010?
03:20:17 <hvr> ertes-w: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#divergence-from-haskell-98-and-haskell-2010
03:21:31 <hvr> ertes-w: it's subtle differences, but it's generally a not-welldefined state which can change w/ every GHC version; and most importantly not portable; hence why .cabal warns if you don't set an explicit default-language
03:21:55 <Cale> merijn: got it
03:22:01 <Cale> merijn: Still here? :)
03:23:25 <ankitsiam> can someone help me with these runtime errors : "Network.Socket.sendTo: invalid argument (Invalid argument)"
03:23:44 <ankitsiam> Network.Socket.recvFrom: invalid argument (Bad file descriptor)
03:23:47 <Cale> @tell merijn http://lpaste.net/362394
03:23:47 <lambdabot> Consider it noted.
03:24:29 <Cale> ankitsiam: Perhaps you're trying to reuse a socket that was already closed or something?
03:25:17 <Cale> merijn: I ran into the same difficulties, until I thought to use withUnliftIO instead of withRunInIO
03:26:03 <Cale> I honestly don't really understand why my solution using withRunInIO didn't work, and I think it might even be a regression in the typechecker, though I'm not certain.
03:27:03 <Cale> (I did annotate enough of the types that I think it should have been able to do what I wanted, and the current solution is entirely equivalent except for newtype wrappers taking the place of explicitly-polytyped things
03:28:22 <Cale> merijn: Also, we're lucky that we don't need to go the other way, because I suspect it's impossible :)
03:30:50 <Cale> Special thanks goes to nix-shell -p 'haskellPackages.ghcWithPackages (pkgs: with pkgs; [resourcet unliftio-core])' for letting me work on that puzzle without having to permanently install anything.
03:35:50 <ankitsiam> cale : i don't think so, what else could be the problem
03:36:53 <Putonlalla> Search the man page for `recvfrom` for `EINVAL`, ankitsiam.
03:37:24 <Putonlalla> That's where the error message originates from.
03:38:43 <ankitsiam> putonlalla : didn't really get you can you please elaborate >?
03:40:02 <Putonlalla> Open a terminal and run the command `man recvfrom`.
03:41:35 <merijn> Cale: I was gone for lunch, but yeah, still here
03:43:49 <ankitsiam> putonlalla: i'm using kademlia package from hackage https://hackage.haskell.org/package/kademlia-1.1.0.0/docs/Network-Kademlia.html
03:44:00 <ankitsiam> putonlalla : is there any solution you have in mind
03:44:00 <Jaxan> Hi, I have a question about performance. I am using memoization on a recursive function (this works fine). But this function has a generic return type, like so: http://lpaste.net/362396 . Now when I define `fib` in the same module, the function is fast. But when `fib` is defined outside, it's super slow. What is happening?
03:44:26 <Putonlalla> No idea then, ankitsiam.
03:44:33 <merijn> Jaxan: 10 dollars says: fib is getting inlined and then specialised
03:44:47 <Jaxan> merijn: and this cannot happen cross module boundaries?
03:44:48 <Putonlalla> You'll have to look inside the package yourself.
03:45:04 <akegalj> kosmikus: looks like it could be - let me try that <3
03:45:08 <merijn> Jaxan: What optimisations are you compiling with?
03:45:09 <ankitsiam> putonlalla : ok, thank you anyway :)
03:45:15 <Jaxan> merijn: just -O2
03:45:54 <merijn> Jaxan: It can happen across module boundaries, but you're basically at the mercy of the optimiser seeing what you're doing
03:46:00 <cocreature> Jaxan: try adding an INLINABLE pragma. that will force GHC to expose the unfolding of the definition which means it can be specialized in other modules
03:46:22 <cocreature> GHC does that on its own for some definitions but not always
03:47:17 <Jaxan> cocreature: yes that works
03:47:51 <Jaxan> So what is the "right" way to deal with this? Just put INLINABLE at those functions?
03:47:57 <cocreature> yep
03:48:51 <Jaxan> thanks, will do that :)
03:49:19 <Rahmat> Hello everybody
03:51:31 <Cale> merijn: Did you see my paste?
03:52:03 <merijn> Cale: Yeah, gonna try it out in a bit, but it seems sensible enough to me :)
03:57:35 <ertes-w> hvr: thanks
04:01:22 <plugin> I’ve forked a package on github and incremented its version.  I have the git repo as an extra dep in `stack.yaml` and the package listed in `build-depends` in my `cabal` file. But stack can’t satisfy the the package requirements, it keeps citing the hackage version as the last available and failing to build.  What gives?
04:04:34 <Cale> plugin: Why would your package depend on itself? Perhaps I don't understand something about this.
04:04:52 <spoonm> quick question: can I have where clauses inside where clauses?
04:04:57 <merijn> spoonm: Sure
04:05:02 <spoonm> thanks merijn
04:05:12 <merijn> spoonm: Where clauses can attach to any declaration, including those inside where/let
04:05:12 <spoonm> about to create a frankenstein that will hopefully work
04:05:39 <plugin> Cale:  It's an upstream package; I need the current master from my fork on github, not the current Hackage version
04:06:02 <Cale> plugin: oh, I see
04:06:17 <merijn> spoonm: Perfectly sensible in many situations. See for example https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/ExportModel.hs#L146-L169 (ignore the surrounding horrific code)
04:06:47 <merijn> spoonm: 3 levels of where nesting right there :p
04:08:31 <cocreature> plugin: you’ll have to show us your stack.yaml file, the build-depends section in your cabal file and the full error message
04:08:52 <ankitsiam> cale : can you see why i'm getting these runtime errors http://lpaste.net/362397
04:10:08 <spoonm> merijn: I'll show you my horrible code if I can manage to finish it :)
04:10:12 <Cale> ankitsiam: no, not without reading the source code of that Kademlia library, and your own code. It's probably that somehow your program is using a stale socket.
04:10:43 <Cale> ankitsiam: It could just be due to a bug in the library, or it could be that you're closing a connection and then trying to reuse it.
04:11:39 <delYsid`> I have a Double, and want to show it without decimal points.  Whats the correct way to do this?
04:11:55 <Cale> delYsid`: round it?
04:11:57 <merijn> delYsid`: round/floor/ceil?
04:12:11 <Cale> It's not entirely clear what "show it without decimal points" means :)
04:12:30 <opqdonut> 3.1415926 -> 31415926?
04:12:43 <delYsid`> merijn: Oh, perfect, thanks!
04:13:06 <merijn> Note that round does banker's rounding, not "grade school" rounding (unlike some other languages)
04:15:30 <plugin> cocreture: I figured it out. It looks like my error was listening to the output of `stack solver`.  If I just build it works.
04:40:08 <spoonm> merijn: http://ix.io/GmJ
04:40:11 <spoonm> judge me
04:41:33 <merijn> spoonm: I'd ditch the if/then/else in favour of a guard on leOutput
04:41:56 <spoonm> I forgot to rename leOutput, wow
04:42:09 <spoonm> how would you do a guard on that, tho?
04:42:16 <merijn> spoonm: Same for all the local definitions with if/then/else
04:42:29 <spoonm> hm...
04:43:13 <spoonm> the problem with the guard on leOutput is the fact that after the if/then/else, I do a hPutStrLn
04:43:24 <spoonm> should I still turn it into guards?
04:43:50 <merijn> spoonm: Well, you can push the if/then/else out
04:44:04 <spoonm> into the where clause?
04:45:13 <merijn> spoonm: like http://lpaste.net/362398
04:45:46 <spoonm> I see
04:45:58 <merijn> I think you can probably refactor it a bit anyway
04:46:04 <spoonm> yeah, I'm working on that
04:46:07 <spoonm> thanks, man
04:46:26 <merijn> spoonm: You repeatedly use an extra "init" when minimizedWindowsExist is true
04:46:54 <spoonm> that's intentional?
04:47:12 <merijn> spoonm: So why not have "foo | minimizedWindowsExist = init; | otherwise = id"
04:47:28 <merijn> spoonm: Then you no longer need to special case all the cases where you add an "init"
04:47:39 <merijn> You can just replace said init with "foo" (although, use a better name)
04:47:51 <spoonm> I think that'd make it a little confusing, but I see how it'd make for brevity
04:48:18 <merijn> spoonm: How confusing it is, depends on how good a name you can come up with :p And it does reduce a lot of code duplication in all of the if/then/else
04:48:46 <spoonm> btw took me hours of trying different things, failing, seeing X11 crash because of something stupid I did, and then get to a working result only to find it ugly and comment out everything
04:49:15 <spoonm> at least I had fun
04:51:39 <akegalj> kosmikus: works like a charm. Ty <3 (if you will be in Zg, Croatia - I owe you a beer)
04:56:12 <delYsid`> Hehe, units-defs is cool!
04:56:42 <spoonm> merijn: how about this? http://ix.io/Gn1
04:57:06 <spoonm> does it look sexy yet?
05:04:07 <merijn> spoonm: Looks better, yeah
05:04:51 <spoonm> how to pick a better name than leOutput
05:04:53 <spoonm> any suggestions?
05:04:57 <spoonm> s/how/now/
05:05:39 <hpc> "dasOutput" :P
05:06:13 <tdammers> if it's short for "little-endian output", then I don't see a problem
05:06:33 <TMA> spoonm: o
05:06:35 <spoonm> it's not lol
05:06:41 <tdammers> yeah, figured
05:06:46 <spoonm> I just didn't have a better name for the ppOutput function
05:06:47 <tdammers> but this seems to be an xmonad config
05:06:50 <spoonm> yup
05:07:15 <tdammers> there's this unwritten law that says xmonad config files and IRC bots have to be as messy as humanly possible
05:07:23 <spoonm> oh
05:07:28 <spoonm> should I go back to what I had before, then?
05:07:35 <spoonm> maybe add some useless ifs for unreachable code too?
05:07:47 <TMA> spoonm: you can make it point-free so that you'll avoid the need for naming it
05:07:48 <tdammers> nah, not *that* kind of messy
05:07:52 <tdammers> "Chaotic Good"
05:08:08 <spoonm> TMA: point-free?
05:08:37 <tdammers> spoonm: remove named variables ("points")
05:08:47 <spoonm> can I even, in this case?
05:09:00 <TMA> spoonm: you can in every case
05:09:01 <tdammers> spoonm: f x = x + 1 becomes f = (+ 1) in point-free style
05:09:02 <merijn> spoonm: You always *can*, the question is whether you *should* :p
05:09:27 <spoonm> panic
05:11:51 <quchen> Naming things is free. You don’t get a bonus for unreadable code.
05:12:28 <merijn> quchen: Naming things definitely is *not* free
05:12:36 <tdammers> indeed
05:12:39 <spoonm> before I actually do this, how would I avoid the need to name it if I made it point-free?
05:12:40 <merijn> It often costs me hours to come up with good names
05:12:46 <tdammers> names often pull their mental weight, but not always
05:12:47 <spoonm> the way I see it, it'd still have to be baptized
05:13:02 <danilo2_> cocreature: I'm sorry I had some trouble with my phone and then I had to attend a meeting. I was talkign with you about the kind - map problem: http://lpaste.net/362382
05:13:09 <merijn> Avoiding inventing names with point-free code saves me considerable time
05:13:10 <danilo2_> cocreature: I really don't see it
05:13:21 <quchen> merijn: Even bad names are better than no names though.
05:13:27 <TMA> spoonm: first, it is not used recursively, you can make it anonymous and pass it at the top
05:13:30 <cocreature> danilo2_: did you see my last message?
05:13:39 <danilo2_> cocreature: regardking k :: k0 ?
05:13:42 <danilo2_> if so then yes
05:13:42 <cocreature> yeah
05:13:45 <cocreature> ah you’ve changed it
05:13:46 <TMA> spoonm: you don't even need point-free for that
05:13:52 <danilo2_> cocreature: no, I havent
05:14:01 <quchen> Even the shittiest names make sharing explicit, for example.
05:14:04 <spoonm> TMA: good point, but with it being point-free, how exactly do you avoid naming it? :/
05:14:14 <merijn> quchen: If I name everything x/foo, it doesn't really help
05:14:25 <danilo2_> cocreature: `'Map ('(k,v) ': _)` is the type, it's kind is some `Map k0 v0`
05:14:30 <quchen> Better than no naming.
05:14:55 <danilo2_> cocreature: and looking at the definition of `type family Get (key :: KeyKind a) (obj :: a) :: ValKind a` , the `a ~ Map k0 v0`
05:15:02 <danilo2_> so everything should play nicely
05:15:08 <quchen> I’ve named many things »x« and it was good. :-þ
05:15:21 <danilo2_> cocreature: but maybe im just blind here and dont understand something very basic
05:15:44 <tdammers> let's just say that point-free style, applied tastefully, can make code more readable
05:16:39 <TMA> spoonm: the whole becomes just a glob of incomprehensible (. $) mumble with no need to name anything
05:16:50 <nomemory> hello, I am trying to write a method that shuffles an (IO [a]) . The code can be found here: http://lpaste.net/362399
05:17:16 <nomemory> I think I am missing something because my method returns the initial value without doing any shuffle work
05:17:18 <nomemory> any ideas ?
05:18:11 <danilo2_> cocreature: we can even confirm that by changing the line to `type instance Get (k :: kx) (('Map ('(k,v) ': _)) :: Map kx vx) = (v :: vx)` and then the error is `Occurs check: cannot construct the infinite kind:         kx ~ KeyKind (Map kx vx)"
05:18:51 <lyxia> nomemory: you're writing valj to index i
05:19:00 <lyxia> which is the index that you're discarding at every step
05:19:07 <nomemory> damn
05:19:22 <lyxia> ah no...
05:19:30 <nomemory> no
05:19:37 <lyxia> How did I misread that, sorry.
05:19:40 <nomemory> it's correctly written that part
05:20:23 <nomemory> i am keeping valJ and discarding the index
05:21:49 <lyxia> nomemory: ["abcde"]
05:21:53 <lyxia> this is a list of one element
05:22:14 <danilo2_> cocreature: what
05:22:16 <lyxia> there's only one way to shuffle one element
05:22:17 <danilo2_> cocreature: I solved it
05:22:31 <danilo2_> cocreature: Im 99% sure its GHC bug now
05:22:57 <danilo2_> cocreature: its funny, if you move the line `data Map (k :: Type) (v :: Type) = Map [(k,v)]` to be the first line, it compiles fine ...
05:23:13 <cocreature> danilo2_: oO
05:23:16 <danilo2_> yeah
05:23:17 <cocreature> danilo2_: that does indeed seem like a bug
05:23:23 <danilo2_> I'm creating ticket for it
05:23:28 <nomemory> lyxia: that moment ... when you've lost 30 minutes looking at a code that has a simple isssue. Thank you for the observation.
05:23:33 <cocreature> happens even with 8.4 alpha
05:23:35 <cocreature> *3
05:23:42 <danilo2_> cocreature: thank you so much for your help and time!
05:23:58 <cocreature> danilo2_: np, sorry I couldn’t be more helpful. I ended up confusing myself along the way :)
05:24:01 <danilo2_> cocreature: im happy thought that it didnt appear that Im blind or I dont knwo what im trying to do :D
05:27:21 <CritJongUn> hey peeps im having some trouble with the monad challenges again
05:27:37 <CritJongUn> currently at this exercise https://mightybyte.github.io/monad-challenges/pages/ex4-2.html
05:27:49 <CritJongUn> i have this code so far http://lpaste.net/362400
05:28:03 <CritJongUn> and now i need to remove the intermediate steps in general b
05:28:19 <CritJongUn> but i'm not being able to get the types right
05:28:32 <CritJongUn> and if anyone could look at it and give me some pointer
05:33:59 <danilo2_> cocreature: https://ghc.haskell.org/trac/ghc/ticket/14668#comment:4
05:35:41 <sQVe> Is anyone using VSCode for writing Haskell here? I'm having some problems getting any of the Haskell specific extensions to work.
05:35:41 <cocreature> danilo2_: thanks!
05:35:48 <danilo2_> my pleasure!
05:35:53 <sQVe> HIE seems very buggish.
05:37:44 <CritJongUn> sQVe: what extension are you using
05:38:20 <sQVe> CritJongUn: I mainly have tried getting https://github.com/alanz/vscode-hie-server to work. But it hangs pretty much all the time.
05:38:32 <cocreature> sQVe: hie is still quite new so it is a bit rough around the edges
05:39:28 <sQVe> Yeah. I noted that. There doesn't seem to be a very good alternative on VSCode though - which is a bit disappointing.
05:40:06 <cocreature> relying on ghci rather than tooling built into your editor tends to be significantly more robust atm
05:40:18 <cocreature> https://github.com/ndmitchell/ghcid is also helpful and quite robust
05:41:23 <sQVe> cocreature: Allright, I'll look into that then. <3
05:41:48 <sQVe> Is stack the recommended way of handling packages etc?
05:41:58 <merijn> sQVe: Depends who you ask
05:42:14 <sQVe> merijn: Ha. That's always the case.
05:42:41 <merijn> sQVe: The two main competitors are cabal-install and stack, with a bunch of fringe Nix groupies coming a distant 3rd :p
05:42:44 <cocreature> sQVe: that said hie is being actively developed, so maybe take a look at the issue tracker or hop in the #haskell-ide-engine channel. it definitely shouldn’t always hang and in the limited experience I have with it (I’m not an active user of vscode) it didn’t
05:43:59 <alanz> sQVe, does the project build from the command line?
05:47:20 <sQVe> alanz: Yes. I was running simple template projects from Stack.
05:48:03 <sQVe> Maybe once or twice there were building issues due to dependencies. But that shouldnt make a difference really.
05:48:08 <alanz> ok, then it is most likely that the compiler called for in the stack.yaml for the project does not match the one being used by hie
05:48:10 <sQVe> Seems very flacky.
05:48:26 <alanz> did you install hie from master, using make?
05:48:34 <sQVe> alanz: Yep
05:48:36 <alanz> It is flaky, still early days.
05:49:10 <sm> alanz: thanks for your work on hie. Any idea how IDEA setup should go (https://github.com/haskell/haskell-ide-engine/issues/469) ?
05:49:24 <alanz> Sounds odd, if it is publicly visible source, perhaps make an issue saying how to get the code, I can take a look some time
05:49:43 <alanz> no idea. Sorry for the weak pun
05:49:51 <sm> ow :)
05:49:59 <sQVe> Yeah I get that alanz
05:50:11 <alanz> you will need someone who has used it in that environment to document it
05:59:44 <metahumor> @tell CritJongUn what is the type of "f x" when "f :: a -> b -> c" and "x :: a"? that might help you write generalB2
05:59:44 <lambdabot> Consider it noted.
06:03:36 <merijn> bleh...vector doesn't have index monadic maps?
06:05:08 <dminuoso> ertes-w: By the way, it looks as if my comonad implementation was indeed correct. =) Just followed types, and then thought about what the code meant.
06:05:17 <dminuoso> ertes-w: Also I began to realize that there's a close relationship between Lens and Store :)
06:05:46 <ertes-w> dminuoso: yeah, there is
06:06:25 <dminuoso> And in my head I began to think of Store as a stateful Reader.
06:06:37 <ertes-w> type Lens a b = a -> (b -> a, b)
06:06:41 <dminuoso> Ahh.
06:07:08 <ertes-w> that's one of the possible formulations of lenses…  but it's awkward and far less flexible than van laarhoven lenses
06:13:35 <Smeghead> Holy moly it looks like the answer to my issue yesterday was just a slight scroll away
06:13:46 <Smeghead> If you have a system with position independent executables by default ... change this setting
06:13:48 <danilo2_> Hi guys! Is there any way to explicitly provide type variables in type families? I want to write `type family Get' (key :: KeyKind obj) (obj :: a) :: ValKind obj` , but GHC tells me that `obj` must be declared before `key`, because type variables are not in the right order ...
06:13:49 <Smeghead> haha
06:14:47 <quchen> danilo2_: Explicit forall?
06:15:19 <danilo2_> quchen: yeah, Im asking exactly about it. Is there any synta for explicit forall in type families ?
06:16:32 <quchen> Dunno, try it out :-)
06:17:07 <danilo2_> quchen: I tried already all possible forms, all rejected, Thats why I asked the question here if there as any way to provide explicit forall
06:17:13 * akegalj
06:19:15 <ertes-w> Smeghead: glad you solved it =)
06:20:33 <Smeghead> Don't know how I missed it, literally at the bottom of the haskell-platform page!
06:20:59 <merijn> The traversal order of Map/IntMap/etc. isn't really defined, is it?
06:21:03 <danilo2_> Ok, so is there any forall sytnax in TypeFamilies in haskell ?
06:22:08 <phadej> merijn: it is, in order
06:22:18 <merijn> phadej: Not documented anywhere, afaict?
06:22:19 <phadej> at least a lot of stuff relies on it
06:22:35 <phadej> merijn: open a ticket on containers issue, I'm sure it's just an oversight
06:23:09 <merijn> phadej: That's what I figured
06:23:34 <quchen> danilo2_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-kind-quantification
06:23:58 <quchen> So try type in type :-)
06:24:00 * sm makes some progress on IDEA+HIE, help welcome: https://github.com/haskell/haskell-ide-engine/issues/469
06:24:59 <danilo2_>  quchen but that are nto type families :( I was tring to type it in every "space" here: `type family Get (key :: KeyKind obj) (obj :: a) :: ValKind obj`
06:36:10 <ankitsiam> can someone help me with this runtime error "Network.Socket.recvFrom: invalid argument (Bad file descriptor)"
06:36:24 <mniip> sounds like you tried to read after closing
07:10:26 <bmk3000> hello
07:12:12 <metahumor> hi
07:13:52 <kosmikus> AWizzArd: https://stackoverflow.com/questions/11553705/haskell-equality-constraint-in-instance
07:14:25 <kosmikus> AWizzArd: (sorry if this has long been answered; I was just reading the backlog)
07:14:36 <bmk3000> Hello, World!
07:19:57 <ankitsiam> cal someone take a look at these errors : http://lpaste.net/362405
07:20:01 <ankitsiam> can*
07:23:35 <ab9rf> those are definitely errors
07:24:14 <dminuoso> ankitsiam: The first error likely means you applied one too few arguments.
07:24:21 <dminuoso> ab9rf: Check:
07:24:26 <dminuoso> Couldn't match expected type ‘IO (K.KademliaInstance KademliaID Person)’
07:24:33 <dminuoso> with actual type ‘i0 -> IO (K.KademliaInstance i0 a0)’
07:24:38 <ab9rf> dminuoso: i'm not the person of interest here
07:25:05 <dminuoso> ab9rf: Sorry. I somehow expected weechat to pick up me completing ankitsiam to mean the next a<tab> would do the "right thing"
07:26:12 <ankitsiam> dminuoso can you please take a look at code : http://lpaste.net/3331678725044436992
07:26:51 <ab9rf> i agree with the first conclusion: something wants another argument
07:28:09 <ankitsiam> dminuoso : i think KademliaID is creating problem otherwise how can data type be passed as arugment ??
07:28:14 <ankitsiam> argument*
07:28:44 <ankitsiam> dminuoso : if that is the problem then how can i pass an intance of KadmliaID to the function ??
07:30:49 <ab9rf> i prefer not to think of arguments as being passed to functions
07:30:54 <ab9rf> but rather as functions being applied to arguments
07:31:14 <ab9rf> you have X and you want Y, how do you transform an X into a Y
07:31:50 <ankitsiam> ab9rf : i hear you man, it's just that i'm new to haskell & functional programming :)
07:42:16 <Peaker> does anyone manage to use IHaskell in the console as advertised? I want it far more than the notebook which I also don't understand how to use
07:44:05 <mnoonan> Peaker: if you just want to avoid the web interface, there are other Jupyter clients
07:44:11 <mnoonan> (e.g. ein-mode for emacs)
07:44:35 <Peaker> I just want the nice REPL, like IPython, but for Haskell
07:44:46 <Peaker> I see screenshots for it - but none with any explanation of how to get there
07:44:59 <Peaker> seems like it's a well hidden secret :)
07:45:27 <ab9rf> the best secrets are always well-hidden :)
07:46:14 <Peaker> I give up after wasting way too much time trying to figure it out, oh well, back to plain ghci :-(
07:46:39 <mnoonan> you may be able to use ipython to connect to an ihaskell kernel, I'm not sure
07:48:50 <Boarders> I'm trying to find a library for haskell bindings to S3 and wonder if anyone has any recommendations?
07:49:19 <mnoonan> Peaker: maybe try "jupyter console", actually
07:49:42 <Peaker> mnoonan, it opens up a Python REPL, not a Haskell one
07:50:09 <mnoonan> Peaker: jupyter is language agnostic, so you just need to tell it to use the IHaskell kernel
07:50:42 <metahumor> does anyone have any suggestions for fixing this RankNTypes error? http://lpaste.net/362406
07:51:12 <Peaker> mnoonan, I have no idea how to do that
07:51:36 <mnoonan> Peaker: me neither, so I ran "jupyter console --help" :)
07:51:42 <metahumor> i understand why it's happening, i can't use the (forall body . Response body -> Text) in the "converter <$> req" since I'd expose the "body" in the "IO (Response body)"
07:51:51 <metahumor> that's what the error says
07:51:54 <mnoonan> it looks like "jupyter console --kernel haskell" should do the trick (unless your haskell kernel has a different name)
07:52:00 <metahumor> I feel like i'm hitting some sort of antipattern
07:52:15 <Peaker> mnoonan, oh, seems to work, thanks! :)  Quirky REPL behavior, but kinda works
07:53:41 <c_wraith> metahumor: need to see a type signature on catchResponseHeader
07:54:48 <metahumor> c_wraith: updated lpaste with "
07:54:49 <metahumor> catchResponseHeader :: (a -> Text) -> IO a -> IO Text"
07:55:04 <c_wraith> metahumor: well, that's exactly what the error message is telling you.
07:55:19 <c_wraith> metahumor: those types aren't compatible
07:56:32 <c_wraith> metahumor: the first argument to catchResponseHeader is monomorphic, with the type parameter chosen by the caller.
07:57:09 <c_wraith> metahumor: isStatusCodeExceptionResponseHandler requires its first argument to be polymorphic - the caller doesn't get to choose what type it's used at.  Those just aren't compatible.
07:57:51 <metahumor> okay, I think i'll just not write "catchResponseHandler", and just pass a "converter <$> req" to catchJust locally
07:58:51 <Smeghead> am I write in thinking that dupChan will only work for readChan?
07:59:02 <Smeghead> So only a sinlge chan can be used for writing?
07:59:48 <metahumor> unfortunately, that won't work either because "converter <$> req" is what throws the Exception...
08:01:43 <AWizzArd> kosmikus: thx for the link – and null problemo, I am used that irc is a very delayed high-latency anync process (-:
08:05:45 <metahumor> c_wraith: what if I am trying to pass "decodeUtf8 . view (responseHeader "Location") :: MonadReader (Response body) m => m Text" as converter?
08:06:59 <metahumor> how does "function application" work with that? i've updated the lpaste with the error
08:23:21 <ReinH> Smeghead: did you read the docs?
08:31:06 <Fourroot> hi
08:31:08 <Fourroot> damn
08:37:22 <metahumor> hi
08:51:11 <bbear> hi
08:51:14 <bbear> what is lts ?
08:51:28 <oo_miguel> long term support ?
08:55:30 <hvr> ...for arbitrary definitions of "long" and "support"
08:57:35 <tdammers> :x
08:58:08 <tdammers> "support", here, probably just means "when questioned, we will not deny that it has existed at some point"
09:01:35 <Mad_> hello, trying web developpement on haskell with Spock. This line : \code : spockCfg <- defaultSpockCfg EmptySession PCNoDatabase (DummyAppState ref)
09:01:55 <ankitsiam_> can someone please help me with this error http://lpaste.net/362413
09:01:58 <Mad_> generate a parse error :  error: parse error on input ‘spockCfg’
09:03:15 <glguy> ankitsiam_: What's the type of K.create?
09:04:16 <ankitsiam_> glguy : create :: (Serialize i, Ord i, Serialize a, Eq a, Eq i) => Int -> i -> IO (KademliaInstance i a)
09:06:09 <petrus> Does "new-run" of cabal (2.0.0) suppose to do something or is it just a dummy currently?
09:06:13 <wz1000> is it possible to write the ackerman function as a hylomorphism?
09:13:20 <bmk3000> Hello, World!
09:23:23 <sm> Mad_: perhaps you need \(code : spockCfg)
09:23:51 <sm> but I think that's wrong
09:24:20 <sm> as defaultSpockCfg does not return a list
09:25:32 <Mad_> @sm sorry, there is no code: spockcfg
09:25:32 * lambdabot pulls sorry, there is no code: spockcfg through the Evil Mangler
09:25:49 <Mad_> just spockCfg <- defaultSpockCfg EmptySession PCNoDatabase (DummyAppState ref)
09:26:23 <sm> Mad_: ah. You should probably paste the code eg on hastebin.com
09:26:34 <Mad_> oki
09:26:39 <Welkin> hastebin?
09:26:40 <Welkin> not lpaste?
09:26:52 <Mad_> it comes from this documentation: https://www.spock.li/tutorials/getting-started
09:27:22 <sm> Welkin: doesn't matter, but lpaste has been unreliable/slow IME while hastebin is speedy
09:27:28 <Welkin> I see
09:27:46 <Mad_> https://hastebin.com/iroyohevol.hs
09:28:19 <sm> Mad_: you can see there's an indentation problem.. perhaps some spaces/tabs getting mixed up
09:28:25 <Welkin> I haven't used spock before, but I have taken a look at it. I am still not sure where it falls. It seems like it is between scotty and yesod in terms of what comes in the box and how it is meant to be used. I think it jhas been moving closer to something like yesod lately though
09:28:28 <sm> line 17 eg
09:28:42 <ankitsiam> can someone please help me with this error http://lpaste.net/362413
09:28:53 <ankitsiam> create :: (Serialize i, Ord i, Serialize a, Eq a, Eq i) => Int -> i -> IO (KademliaInstance i a)
09:29:51 <Welkin> ankitsiam: on line 5 it tells you exactly where the problem is
09:30:36 <ankitsiam> welkin : didn't get it can u please elaborate
09:31:07 <Welkin> ankitsiam: did you read the error message at all?
09:31:23 <Welkin> I can;t help you because I don't have your source code and don't know anything about it
09:31:45 <Welkin> work out the type for that line of code that the compiler mentioned in the error message
09:32:11 <Welkin> it looks like you have a missing parameter, possibly
09:32:20 <ankitsiam> welking : http://lpaste.net/362414
09:32:24 <MarcelineVQ> looks like the same problem it was earlier   <dminuoso> ankitsiam: The first error likely means you applied one too few arguments.    <ab9rf> i agree with the first conclusion: something wants another argument
09:33:22 <ankitsiam> MarcelineVQ : here's the source code provided by library itself : http://lpaste.net/362414
09:33:46 <ankitsiam> MarcelineVQ : it's the same code which is giving these errors
09:34:31 <Mad_> ok sm, thanks i am looking at the indentation
09:35:02 <Welkin> ankitsiam: do you understand the types of all of the functions and values used in that line of code?
09:35:09 <Welkin> take a closer look
09:35:34 <Welkin> also, don't use point-free
09:35:44 <Welkin> convert those all to not use point-free with composition
09:35:51 <Welkin> it will only make the problem worse
09:36:15 <ankitsiam> welkin : can you simplify a bit i have been using haskell for 4 odd days so
09:36:16 <Welkin> trying to be clever in haskell will always bite you
09:36:25 <sm> not so!
09:36:27 <Welkin> I mean
09:36:32 * sm feels clever 
09:36:38 <Welkin> don't use function composition like that unless you really know what you are doing
09:36:44 <Welkin> start by making everything explicity
09:36:51 <sm> I would say you can get away with being clever more often in Haskell than elsewhere
09:37:16 <Welkin> sm: not for someone who has been using it for 4 days
09:37:23 <sm> in fact sometimes I feel Haskell making me clever, whether I want to be or not
09:37:28 <sm> oh indeed
09:37:38 <glguy> ankitsiam: The code you pasted as typos in it, did you actually type it out manually? edit it?
09:37:39 <sm> +1
09:37:47 <glguy> once the typos are corrected the code loads fine
09:38:42 <ankitsiam> glguy : i don't see any typos & as i said it's the code provided by library sort of starting up tut
09:38:54 <Welkin> so you copied and pasted it
09:38:54 <glguy> No, the documentation didn't have the spelling typos
09:39:08 <glguy> and the code in the documentation loads without type error
09:39:08 <Welkin> without understanding any of it?
09:39:24 <glguy> what version of the library are you using locally?   ghc-pkg list kaemlia
09:39:28 <glguy> what version of the library are you using locally?   ghc-pkg list kademlia
09:40:02 <Welkin> also, wtf is kademlia?
09:40:23 <glguy> Other than that the library itself misspells Success between the documentation example and the code itself
09:40:41 <Welkin> that library has not been updated for 2.5 years
09:40:45 <glguy> This is a package that was uploaded in 2015 and hasn't seen any attention since
09:40:49 <Welkin> lol
09:41:05 <ankitsiam> glguy : this code is working fine if i'm using by installing the kademlia package but then it is giving run time errors
09:41:07 <Welkin> it looks like you not of to a good start ankitsiam
09:41:27 <Welkin> this is a bad way to start haskell, using an abandoned library with poor code, not understanding it
09:41:35 <MarcelineVQ> Welkin: try to be constructive
09:42:05 <Welkin> ankitsiam: are you using any other resources to learn haskell?
09:42:57 <ankitsiam> welkin : i got it, do you think i don't know that but the thing is it's the only Kademlia DHT implementation in haskell out there so i don't have any other option unless you think implementing DHT with my 4 days of experience in haskell is a good idea
09:43:21 <Welkin> why do you need to do this specific thing in haskell, right now, today?
09:43:23 <cheater> haskeline has a bit of a bug https://github.com/judah/haskeline/issues/77
09:43:26 <Welkin> in a language you don't know
09:43:41 <Welkin> it seems counter productive
09:43:52 <Welkin> if you need this kademlia thing, perhaps use another language that has a library for it
09:44:03 <ankitsiam> welkin : i'm using 'learn you a haskell' & 'real life haskell' if you have any other good resources(s) please refer
09:44:21 <cheater> lyah is pretty good
09:44:25 <cheater> continue with it until the end
09:44:27 <ankitsiam> welkin : i can't i'm asked to do this in haskell
09:44:30 <cheater> then try writing a few simple things
09:44:33 <Welkin> cheater: it's not very good, but okay
09:44:44 <cheater> i think it's very good because i helped with it so there
09:44:47 <cheater> :p
09:44:58 <cheater> but i only helped with it after i used it myself
09:45:01 <cheater> :)
09:45:24 <Welkin> in terms of free resources, those two books are about it for right now
09:45:34 <ankitsiam> welkin : do suggest resources you think are good, i mean it's good learning from multiple resources
09:45:40 <cheater> nah, there's huge amounts of resources
09:45:40 <Welkin> there are several books you can purchase that are decent as well, including Graham Hutton's Programming Haskell
09:45:46 <cheater> but for starters, lyah is pretty good
09:46:09 <cheater> yeah graham's book is pretty cool
09:46:14 <dysfun> there are some excellent videos on youtube too
09:46:21 <Welkin> cheater: there are few resources that cover the basics of haskell sufficiently. and LYAH and RWH are both poor in that area, but they are all we have at the moment
09:46:22 <cheater> yeah
09:46:28 <cheater> i wonder if there's a discord for haskell
09:46:31 <dysfun> particularly once you've got enough haskell knowledge to bootstrap to advanced stuff
09:46:34 <cheater> and fp
09:46:39 <cheater> i would join / make one
09:46:41 <cheater> it would be fun
09:46:47 <metahumor> cheater: I can't repro your Alt-f error on my machine
09:47:09 <cheater> metahumor: how long have you held it pressed?
09:47:13 <metahumor> 30 sec
09:47:16 <cheater> wow
09:47:18 <ankitsiam> wilkin : so do you think Graham Hutton's Programming Haskell is good ?
09:47:20 <cheater> what cpu?
09:47:27 <MarcelineVQ> cheater: there is
09:47:31 <Welkin> ankitsiam: yes, and very concise
09:47:35 <cheater> MarcelineVQ: where
09:48:21 <metahumor> cheater: Xeon E5-1650 @ 3.5 GHz
09:48:21 <ankitsiam> welkin : while we are at it , do you guys (haskellers ) recommend stack ?
09:48:44 <Welkin> ankitsiam: it depends
09:48:48 <MarcelineVQ> not sure, I don't use discord, search for fp programming discord and see what you get
09:48:50 <Welkin> in general I do not anymore
09:48:59 <Welkin> for some commercial use cases, perhaps
09:49:04 <Welkin> for beginners, no
09:49:06 <cheater> metahumor: try doing something computationally intensive on all cores, and test again
09:49:08 <MarcelineVQ> cheater: I've used it before but don't recall the exact link
09:49:15 <cheater> ok
09:49:37 <ankitsiam> welkin : how about for professional haskell developers ?
09:49:47 <Welkin> ankitsiam: many use nix instead
09:49:49 <cheater> ankitsiam: i don't care about cabal/stack as long as they get out of the way, and i already have all cabal commands memorized, and it works for me, so i stick with that
09:49:56 <metahumor> cheater: 8 cores x2 threading, going to be hard =)
09:49:58 <cheater> ankitsiam: i'm a pro haskell developer
09:50:17 <cheater> metahumor: try compiling lens in 16 separate cabal sandboxes
09:51:46 <ankitsiam> cheater : while you are here please share some useful libraries for a pro haskell programmer which i can dive into once i'm done scratching the surface
09:52:22 <cheater> ankitsiam: no. be done scratching the surface first, then come up with a real world problem (eg "create a blog"), and then come here for recommendations
09:52:47 <ankitsiam> cheater : alright :)
09:53:10 <cheater> ankitsiam: haskell has a huge amount of very good libraries, none of them are things you must know to work with haskell, and learning them proactively will waste a lot of time and effort. it's much better to find ones that solve a problem you already do have :)
09:53:59 <Welkin> the two libraries you will use all the time are base and containers
09:54:08 <Welkin> those are the "standard library"
09:54:24 <ankitsiam> cheater : so as i told u i was able to compile the code when i used stack build package to install that lib but then i got these runtime error
09:54:28 <ankitsiam> Cheater : kdht2: Network.Socket.sendTo: invalid argument (Invalid argument) kdht2: Network.Socket.recvFrom: invalid argument (Bad file descriptor)
09:56:10 <cheater> what code are you talking about?
09:56:46 <ankitsiam> cheater : this one http://lpaste.net/362414
10:07:33 <cocreature> ankitsiam: a first step would be to recompile with profiling and run the executable with "+RTS -xc". that will give you a backtrace for the exception which can help locate the problem
10:08:41 <ankitsiam> cocreature : how can i compile with profiling using stack
10:09:10 <cocreature> ankitsiam: stack build --profile
10:10:50 <ankitsiam> cocreature : it it's a single file then stack ghc file.hs --profile ??
10:11:50 <cocreature> ankitsiam: no the ghc flags are "-fprof -fprof-auto" but that requires that you built your dependencies with profiling support as well
10:12:23 <cocreature> but if you’re getting to the point where you need to enable profiling you might want to make a proper cabal project
10:13:31 <ankitsiam> cocreature : i did that but then project won't build
10:13:39 <ankitsiam> and give these errors
10:14:19 <ankitsiam> http://lpaste.net/362413
10:15:03 <Welkin> ankitsiam: you just posted those exact errors an hour ago
10:15:31 <kadoban> ankitsiam: Well, I mean that looks like a code error, not a build system error. Unless you're ending up using the wrong version of a dependency and the types changed or something?
10:15:40 <Welkin> the library is extremely old
10:15:47 <kadoban> Oh
10:16:02 <ankitsiam> welkin : yeah it is
10:16:02 <Welkin> also, glguy pointed out they have spelling errors
10:16:17 <Welkin> and that code is copy-pasted form some quickstart guide to the 2.5 year old library
10:16:34 <Welkin> like I said, this is a terrible way to start with haskell, 4 days in
10:17:00 <ankitsiam> welik : the same code was forked by cardano so it must have some credibility
10:17:08 <Welkin> who is cardano?
10:17:50 <ankitsiam> welking : seems like you are not interested in crypto space
10:17:54 <Welkin> no
10:18:08 <cocreature> ankitsiam: you’ll have to show us the code producing that error as well
10:18:52 <ankitsiam> cocreature : http://lpaste.net/362416
10:20:23 <ab9rf> whether code is "credible" or not is irrelevant to whether it's a good learning experience
10:22:02 <ankitsiam> ab9rf : it's not for learning, it's sort of an assignment & i strongly believe breaking things is a great way to learn irrespective of the experience
10:22:36 <cocreature> ankitsiam: that code definitely does not produce the error you are showing us. it contains two typos
10:22:46 <cocreature> ankitsiam: we’ll have to see the actual code producing that error
10:24:26 <ankitsiam> cocreature : see i'll tell you firstly i used stack build package to install the Kademlia lib and then i created i single .hs file and pasted that code from documentation and after debugging i was able to compile it but i got runtime errors
10:24:56 <cocreature> ankitsiam: wait now you are getting runtime errors? you just showed us compile errors
10:26:15 <ankitsiam> cocreature : that was before, later i what i did is i downloaded the lib and and in app folder i created a Main.hs importing lib from src folder which is giving those compilation errors
10:26:35 <ab9rf> ankitsiam: i am starting to suspect that the way you're going about this lacks sufficient discipline for you to learn much from it
10:27:55 <ankitsiam> ab9rf : i told you it's not about learning it's an assignment so time contsrained & yes i still believe learning this was is effective
10:28:22 <cocreature> ankitsiam: what exactly do you mean by “you downloaded the lib”? you should just add it to the build-depends section in your cabal file and stack should take care of the rest
10:28:28 <mnoonan> wait, is this an iohk test? it seems like you probably shouldn't need to ask for help, if so
10:29:25 <ab9rf> mnoonan: it's not a real test if you can't cheat on it
10:29:34 <mnoonan> or serokell, i guess
10:29:41 <ankitsiam> cocreature : i did that
10:30:16 <mnoonan> ab9rf: heh
10:30:18 <cocreature> ankitsiam: then please show us the cabal file
10:30:26 <cocreature> ankitsiam: and the stack.yaml file as well
10:31:42 <consus> Hi folks
10:32:41 <ankitsiam_> cocreature : here you go http://lpaste.net/8170329232212230144
10:33:57 <consus> Can someone advise me the best way to create a multiplatform IPC between haskell processes? For unix I'd go with socketpair, but windows does no fully support it, so...
10:34:08 <cocreature> ankitsiam_: you shouldn’t add all of the modules from the original lib as a library in your own project.
10:34:30 <cocreature> ankitsiam_: create a new project using "stack new <yourprojectname> simple"
10:34:40 <phadej> consus: that's not really haskell question :)
10:34:51 <consus> Perhaps
10:35:07 <cocreature> ankitsiam_: then modify the cabal file and add kademlia to your build-depends section
10:35:10 <consus> But maybe someone already created a module that solves this
10:35:30 <ankitsiam_> cocreature : done
10:35:58 <cocreature> ankitsiam_: now you can write your code in Main.hs and run "stack build" to build it
10:42:04 <ankitsiam> cocreature : what about dependencies, should i add em to my .cabal file ?
10:44:43 <cocreature> ankitsiam: add the names of the dependencies to the build-depends section in your cabal file
10:59:32 <Peaker> Is there any way to explicitly opt-out of the warn-uni-pattern on a case by case basis? I'd expect where ~(Foo x) = ...   to *not* warn about partiality because of the explicit ~
11:00:21 <Tuplanolla> You can toggle warnings at module level, Peaker.
11:00:36 <Peaker> I want all my partial pattern matches to be explicitly partial with ~
11:00:45 <Peaker> so I was hoping warn-uni-patterns would do that
11:05:16 <Peaker> I see I held this opinion 3 years ago too :) https://www.reddit.com/r/haskell/comments/219rbi/question_beginner_is_haskell_type_system_as/cgaz0n1/
11:16:50 <maerwald> reminds me of that blog post where someone claims haskell is a dynamically typed language by showing off GHC extensions xD fail
11:18:16 <mnoonan> maerwald: https://aphyr.com/posts/342-typing-the-technical-interview perhaps?
11:18:27 <mnoonan> though this is really a thing of beauty in and of itself
11:29:43 <kadoban> mnoonan: O.o I don't even know what 1/2 of that does. That's brilliant.
11:31:33 <jle`> @tell Peaker I would like that too
11:31:33 <lambdabot> Consider it noted.
11:31:36 <kadoban> “No,” you inform him, matter-of-factly. “No, that doesn’t sound right.” xD this is great
11:33:36 <[exa]> oh, the tech interview
11:34:34 <[exa]> btw there's a paper that it's based on, iirc it's the "Faking dependent types"
11:37:20 <dysfun> "faking it: simulating dependent types in haskell" ?
11:37:53 <dysfun> (note that searching for "faking dependent types" turns up some amusing results, including someone claiming to do it in c++)
11:39:02 <Peaker> dysfun, I saw someone claiming that in C++, giving a templated function and having it instantiated at different types depending on the value given is "faking DTs".
11:39:32 <dysfun> well, bless them, but C++ programmers have many odd ideas
11:42:28 <mnoonan> kadoban: I know, so much gold.. 'You smile kindly. “Haskell is a dynamically-typed, interpreted language.”'
11:43:20 <yahdeepan> I need to change my result in my coll server. Or else my dad will kill me. Kindly help on it
11:45:32 <kadoban> I think I 1/2way get what it's doing now, but ... hmm. Not sure I could do it myself. I'm never all that clear how typeclasses resolution stuff works in the weird cases.
11:45:57 <kadoban> Especially with those extensions, haha.
11:56:51 <Peaker> why does -fno-code rebuild all TH files and not incrementally do nothing with -fno-code?
11:57:00 <Peaker> (with -fwrite-interface, I meant)
12:07:13 <fourroot> hi
12:07:22 <fourroot> im a pythoner, want to learn haskell
12:07:28 <fourroot> can you guys suggest me a good ide for it ?
12:07:38 <metahumor> what do you usually use?
12:07:44 <fourroot> pycharm
12:07:47 <fourroot> for python
12:07:48 <metahumor> vscode then
12:07:57 <fourroot> downloading it, thanks
12:08:06 <fourroot> and which youtuber should i follow ?
12:08:17 <fourroot> can you suggest me some videos ?
12:08:35 <cocreature> Peaker: no idea about your specific issue but in general fno-code and TH really don’t like each other, see https://ghc.haskell.org/trac/ghc/ticket/8025
12:10:26 <fourroot> hows the future of haskell
12:10:38 <fourroot> and why are other big  companies not supporting it ?
12:10:51 <fourroot> like google has launched its tensorflow library for c++ and python
12:10:56 <fourroot> but not HASKELl
12:11:00 <fourroot> why is it so ?
12:11:10 <cocreature> fourroot: https://github.com/tensorflow/haskell
12:12:02 <fourroot> okk, cocreature thanks. didn't know that
12:12:23 <fourroot> but still , it is not as popular as python among new programmers, why ?
12:12:51 <jd823592> Hello, since fail is being moved from monad I uncovered that I have a partial pattern match in my do block "(a : as) <- get", well not really, since I know the list is infinite, ghc warns me that my code will be treated as error, which I absolutely support! However what are my options? I would like to replace the list with a stream but do not know what package is considered the standard provider of
12:12:57 <jd823592> stream data type.
12:14:39 <metahumor> fourroot: i think it is not as popular among new programmers because there are more people teaching python to new programmers
12:15:40 <metahumor> which leads to, why are there more people teaching python than haskell? i think python syntax/program structure is more similar to the languages the teachers might already know
12:16:01 <metahumor> python is also interpreted, so the tooling around playing around with code/incremental development might seem easier with python
12:17:06 <metahumor> python also has a lot of canonical "batteries-included" libraries like numpy, matplotlib, keras, etc, while it is a little more difficult to determine what is a "canonical" library for haskell. that is an issue of the library ecosystem and not the language
12:17:09 <lyxia> jd823592: I don't know of a standard stream implementation. Two options may be to define a custom one (infinite streams are not that common), or to derive it "free"-ly.
12:17:53 <badzergling> an easily overlooked didactic attribute where python wins is the speed at which learners are rewarded for experimenting.  A small, obvious change in a python program is likely to work; an equally small change in a haskell program is likely to break.
12:17:54 <lyxia> jd823592: the advantage of defining structures freely is that you get operations, well, for free.
12:18:01 <amalloy> cocreature: fwiw that readme is marked "This is not an official Google product."
12:18:24 <cocreature> amalloy: sure I never claimed that it was
12:18:28 <metahumor> amalloy: "use at your own risk"
12:18:29 <jd823592> lyxia: i have considered doing both, i am always hesitant to implement standard stuff from scratch (but I don't know why)
12:18:56 <jd823592> lyxia: free-ly you mean as a fixpoint of pair?
12:19:29 <lyxia> That's one of the ways. You could also obtain it via a free monad or free comonad.
12:20:24 <fourroot> that is right metahumor
12:20:35 <fourroot> so again same question
12:20:44 <fourroot> why are all big companies not backing it ?
12:21:20 <Tuplanolla> Perhaps the companies themselves could provide a better answer.
12:21:24 <kadoban> Why would they?
12:21:31 <amalloy> so i was a little surprised that there's no newtype for treating (a, a) as an Applicative. i went and implemented it to prove to myself it was possible, which made me realize: wait, this is a lot like ZipList a? so i guess my question is: is that why there's no Applicative instance for mono-typed tuples? because you could use ZipList instead?
12:22:05 <fourroot> kadoban, i meant the libraries.. Google has made TF library py and java but haskell
12:22:31 <badzergling> Large companies like to have large hiring pools.  It is a frequent complaint of haskell employers that it's hard to find people to work in haskell.  Common or easy to teach languages have an advantage to the least common denominator.
12:22:37 <kadoban> Again, why would they? They target the most popular languages only most likely.
12:22:39 <fourroot> every famous website, application have given their api wrappers in python
12:22:48 <fourroot> kadoban, to help developers ?
12:22:58 <dstolfa> i mean, AFAIK Facebook uses Haskell
12:22:59 <kadoban> Companies aren't in the habit of helping people
12:23:27 <epta> what is the proper way of dump/read some state to/from filesystem? just Show instance and writeFile / readFile?
12:24:14 <metahumor> fourroot: Facebook and Microsoft definitely hire Haskellers
12:24:16 <lyxia> epta: serialize it as JSON or binary
12:24:18 <amalloy> epta: i imagine that depends on how reliable you want it to be, in the face of things like file io errors, or new versions of your program reading old data
12:24:39 <mnoonan> fourroot: Google does too (well, X does anyway)
12:24:42 <metahumor> fourroot: so do large defense contractors for the US govt, as well as many banks (especially around London)
12:24:57 <Tuplanolla> @hackage binary -- This is one option, epta.
12:24:58 <lambdabot> http://hackage.haskell.org/package/binary -- This is one option, epta.
12:25:04 <fourroot> okay metahumor thank you
12:25:28 <metahumor> fourroot: what made you interested in haskell?
12:25:30 <epta> Tuplanolla: lyxia: thank you, I'll take a look
12:25:36 <fourroot> is haskell a better choice for AI ?
12:25:52 <fourroot> im a pythoner, but the problem is its too slow
12:26:04 <fourroot> and writing python is like writing english
12:26:11 <metahumor> fourroot: it could be, haskell is great for making expressive code and abstraction
12:26:16 <fourroot> i dont even feel like im programming something
12:26:22 <fourroot> like c++, php
12:26:29 <metahumor> well I think that writing English is good because any code should be comprehensible and not arcane
12:26:32 <mnoonan> that doesn't seem like such a bad thing
12:26:33 <amalloy> fourroot: that's just a matter of practice
12:26:40 <metahumor> fourroot: if you want incomprehensible code, just write perl5
12:26:57 <dstolfa> metahumor: C works too, but yes. perl is the clear winner there
12:27:18 <Tuplanolla> We're around Java on the performance-for-effort spectrum, fourroot.
12:27:23 <metahumor> fourroot: haskell might seem even more like english because you can structure your programs very similar to how you might think about your data transformations
12:27:50 <fourroot> cool.. Please suggest me a book/pdf for haskell or any website
12:28:10 <metahumor> fourroot: some code I am currently working on looks like "action <- lookup n challenges; newPassword <- action; writePassword (n + 1) newPassword"
12:28:24 <metahumor> @where HPFFP
12:28:24 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
12:28:31 <fourroot> okay
12:29:05 <fourroot> metahumor, how long does it take to learn haskell ?
12:29:10 <huy> Haskell is like writing in English the very very very formal way
12:29:40 <fourroot> my hands are good with c++, php, python, bash
12:29:43 <metahumor> Haskell is like Othello: "A Minute TO Learn... A Lifetime to Master" =P
12:29:50 <fourroot> lol got it
12:30:15 <jd823592> lyxia: thanks :)
12:30:27 <metahumor> fourroot: the language itself helps you because the compiler we use gives us great errors if we get types wrong
12:30:42 <metahumor> fourroot: unlike python, where errors rarely indicate how one might fix a problem
12:31:27 <metahumor> if I write "relpicate" in my REPL, I get back "    • Perhaps you meant one of these:        ‘replicate’ (imported from Prelude),        ‘T.replicate’ (imported from Data.Text),        ‘replicated’ (imported from Control.Lens)
12:31:48 <Jacoby6000[w]> Haskell errors were intimidating at first, because I wasn't used to being given such useful information :p
12:31:54 <Gurkenglas> metahumor, that's because you wrote neither of those three suggestions
12:32:26 <Gurkenglas> Oh wait, that wasn't an object-level question
12:32:44 <metahumor> Gurkenglas: yup, i'm showing that the tooling (ghci in this case) is helpful, more so than ipython for example
12:32:56 <fourroot> thank you so much metahumor for helping me to get started
12:33:04 <fourroot> are you in #haskell-beginners too ?
12:33:10 <metahumor> a lot of us are
12:33:11 <fourroot> i'll ask my questions there
12:33:14 <fourroot> thank you
12:33:24 <fourroot> i'll be back tomorrow with a lot of questions
12:40:44 <Tuplanolla> Am I crazy for wanting to build a prelude around universal algebra?
12:41:18 <metahumor> Tuplanolla: numhask?
12:41:47 <Tuplanolla> What's that, metahumor?
12:42:26 <metahumor> a prelude substitute with an algebraic numerical tower
12:42:29 <metahumor> https://hackage.haskell.org/package/numhask
12:43:24 <Tuplanolla> There's certainly algebra in it, but it's not universal.
12:48:41 <Tuplanolla> It also seems to feature a lot of unnecessary code duplication.
12:49:04 <Tuplanolla> (Comparing `Additive` and `Multiplicative` for example.)
12:49:13 <metahumor> can algebraists really be choosers?
12:49:34 <metahumor> well yeah that's on purpose
12:50:12 <metahumor> the README describes how they're built in parallel yet independent, because both are valid groups on Integers
12:50:36 <Tuplanolla> That could still be avoided with `newtype` in the vein of `Sum` and `Product`.
12:51:17 <cement> are multigraphs really hard to implement?
12:52:00 <metahumor> Tuplanolla: how would you express Rings using those two newtypes on top of some type?
12:52:47 <Tuplanolla> Like `class (Abelian (Sum a), Monoid (Sum a), Unital (Product a), Semigroup (Product a)) => Ring a where ...`.
12:55:03 <metahumor> sure, i don't remember tonyday's reasoning why he went with separate typeclasses
12:56:19 <danilo2_> Hi guys! I try to write such code `type family Get (key :: KeyKind obj) (obj :: a) :: ValKind obj` but GHC tells me that ` Variable ‘obj’ used as a kind variable before being bound     as a type variable. Perhaps reorder your variables?` .
12:56:41 <danilo2_> I dont want to reaoder these arguments (It would be accepted then). I want just to use some kind of explicit forall
12:56:46 <danilo2_> can I do it using type families?
13:00:43 <lyxia> I don't think so.
13:01:33 <lyxia> I guess (proxyobj :: Proxy obj) is not an option?
13:01:35 <danilo2_> lyxia: so the only way to have what I want would be to re-order the arguments in this type family? :O
13:02:09 <danilo2_> lyxia: nope, these are workig n typelevel ony. No data bindigs are availalbe. Its part of typelvel map implementation
13:02:20 <lyxia> Indeed, kinds are bound in order
13:02:54 <lyxia> but why does obj need to appear in the kind of Get
13:02:57 <danilo2_> lyxia: but ... but ... but ... (crying), cannot I jsut tell, hey let me habve my own order of arguments? I know they are bind in order but we normally can define the order and here...
13:03:20 <danilo2_> lyxia: because based on obj I want to infer the kind of key and the kind of value
13:03:55 <danilo2_> I cannot infer it from the kind of obj because I want to have 2 map implementations - one with kind `Map k v` and one with kind `*`
13:04:06 <lyxia> Type families must be fully applied anyway, so for most of us it doesn't really matter I guess.
13:04:08 <danilo2_> So I can infer the kind of key and value only form obj
13:04:44 <danilo2_> lyxia: it matters how you use it. If you see `Get x y` you think in terms `get x from y`, not `get y from x`
13:04:49 <lyxia> Furthermore, inference of binding sites doesn't seem like a good idea.
13:04:59 <danilo2_> lyxia: why?
13:08:15 <lyxia> Hmm, I don't have a good argument, it only seems so ad-hoc.
13:09:06 <danilo2_> lyxia: basically if you are using typelevel map with key / value of kind not * then you want sometihng like that. Otherwise you would have to wite kinds everywhere by handbecause ghc will not unify them
13:10:53 --- mode: wolfe.freenode.net set +o ChanServ
13:11:11 <lyxia> How about an infix type family,   obj ! key
13:11:52 <lyxia> I don't find Get key obj more intuitive than Get obj key.
13:12:09 <lyxia> It's not like anyone can get it wrong either way.
13:12:18 <danilo2_> lyxia: oh, infix type fmaily is perfect here !
13:12:21 <lyxia> and anyone can easily pull up the docs
13:12:24 <danilo2_> lyxia: oh, thank you!
13:12:28 <lyxia> yw
13:13:02 <danilo2_> lyxia: but! Get x y - in all the pure api means always get x from y. In all monadic api it could be other way around. But I want to stay with the convention :)
13:13:25 <danilo2_> I know the convention is derived from the ability to not fully apply types, but if its everywhere, we should nto break it
13:14:16 <lyxia> I think the convention is derived from the fact that it's easier to not implement binding-site inference
13:15:24 <danilo2_> thats also seem to be true! This or that way - this is a convention we should not break in pure api imo
13:15:32 <danilo2_> lyxia: thanks again for chatting! :)
13:16:53 <lyxia> :)
13:46:28 <pdxleif> Is there a default instance for Integral?
13:46:35 <pdxleif> > fromIntegral $ read "4"
13:46:37 <lambdabot>  4
13:47:03 <pdxleif> That is, what does the Integral constraint resolve to in the above, or is there a way of finding out?
13:47:21 <pdxleif> (I was hoping to force it to Int to have more constrained parse errors)
13:47:59 <MarcelineVQ> let's see if it'll tell us
13:47:59 <glguy> pdxleif: It resolves to Integer
13:48:01 <MarcelineVQ> :t +d (5 :: Integral a => a)
13:48:02 <lambdabot> Integer
13:48:19 <MarcelineVQ> neato
13:50:49 <pdxleif> Well, now I have an excuse to use the new TypeApplication feature. :/
13:52:00 <glguy> What's the excuse?
13:52:34 <pdxleif> I just wanted read to use "Int" in the above expression.
13:52:44 <pdxleif> > fromIntegral $ read @Int "4"
13:52:45 <lambdabot>  error:
13:52:46 <lambdabot>      Pattern syntax in expression context: read@Int
13:52:46 <lambdabot>      Did you mean to enable TypeApplications?
13:52:47 <glguy> fromIntegral (read "4" :: Int)
13:53:12 <jle`> fromIntegral @Int (read "4")
13:54:01 <pdxleif> I already have the Read constraint in an IO action, and I'd rather write foo @Int than (foo :: IO Int)
13:54:24 <pdxleif> Or maybe it's a bigger stack than IO
13:54:58 <pdxleif> Anyways, getting to use new language extensions seems fun.
13:56:16 <morchella> I've been trying to configure emacs for haskell and I keep running into problems, intero sort of works but then flycheck causes a bug with exceeding max depth, some sort of infinite loop i guess
13:56:17 <metahumor> do downstream consumers not know that it will be an Int?
13:57:01 <morchella> anyone have advice on what to use, ghc-mod, company-ghc, darwin?
13:57:19 <morchella> and do any of them work with the latest GHC
14:00:51 <MarcelineVQ> morchella: no idea but in case it's helpful: I use ghcid when I need quick feedback, though it's not really the same kind of thing. if I used emacs I'd probably use dante, so have a look at that if you've not seen it before
14:04:58 <morchella> yeah i guess i'll just try dante again
14:05:58 <morchella> i get by all right with just a repl and basic haskell-mode but it would be nice to have a more integrated workflow
14:06:48 <morchella> might just wait for the backends to catch up, since i want to mess around with cool new stuff in GHC
14:30:02 <pdxleif> MarcelineVQ: You know what the "+d" there does?
14:31:10 <MarcelineVQ> picks defaults according to -XExtendedDefaulRules    https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:type%20+d
14:34:17 <sssilver> "Come write in Go" they said. "It's pragmatic. Haskell is for academia" they said. And here I am, hating my life, missing Haskell, for very pragmatic damn reasons. What gives??
14:35:25 <sssilver> What's unpragmatic about sum types and optionality?
14:35:38 <sm> indeed
14:36:00 <c_wraith> sssilver, usually when someone calls their language "pragmatic" they mean "we ignored the hard problems"
14:36:31 <sssilver> c_wraith: omg so true. Often find myself thinking that the only thing Go made easier is the life of compiler engineers.
14:37:30 <glguy> Sure, but just keep in mind how much easier things were for them while you're working in the language and you'll feed better abou the experience
14:37:54 <Tuplanolla> I find it difficult to get anything else done when I have the opportunity to solve hard problems.
14:38:42 <davean> The nice think about go is that accomplishing anything hard is so monumental a task, you never try. So you do a lot of simple things and look productive.
14:39:07 <Tuplanolla> Exactly that.
14:39:50 <sssilver> this makes me laugh and cry at the same time. You guys are gold.
14:41:06 <sm> well now.. some things are easier in go, too
14:41:24 <sm> shipping binaries that just work, eg
14:41:29 <davean> sm: such as, writing a go complier in go?
14:41:39 <davean> sm: I've never had an issue with that in almost any language
14:41:48 <davean> sm: I mean, all go does to "make that easier" is static linking
14:41:56 <morchella> just have to write a haskell to go compiler, best of both worlds
14:42:00 <davean> sm: and I mean, I don't know of any compiled language I can't ask to staticly link stuff
14:42:16 <davean> sm: and never mind that actually makes maintaing them far harder
14:42:35 <sssilver> morchella: might as well skip the intermediate go step
14:42:47 <sssilver> why not go straight to the binary
14:43:07 <sm> davean: I don't know the details, but I suspect go's "static linking" is a lot more thorough than ghc's
14:43:18 <sm> or simpler, or something
14:43:26 <davean> sm: nope
14:43:33 <sm> compiling things fast. Also easier in go. I hear
14:43:35 <davean> sm: the details are JUST that it staticly links
14:43:54 <sssilver> sm: yeah compiling things fast coz compilation time checks are not worth anything and runtime errors are all over the place
14:43:57 <davean> and, actually on linux thats a lie - you can't staticly link fully on linux, but its as close as you can get
14:44:11 <sm> davean: do you have experience shipping haskell binaries that just work ?
14:44:15 <davean> sm: yes?
14:44:19 <davean> its really trivial
14:44:24 <maerwald> sm: yes, it has a global build cache now too
14:44:32 <maerwald> so far quicker than in ghc
14:44:35 <sm> ..on windows ? freebsd ? ancient linux distros.. ?
14:44:57 <davean> well, not on windows, I never touch windows. I haven't seen windows in ages really.
14:45:07 <davean> Just Linux/FreeBSD/Mac, the things people acctually use
14:45:16 <sm> old linux ?
14:45:16 <maerwald> lol
14:45:21 <sm> I think it's harder than you think
14:45:25 <davean> sm: its not
14:45:28 <davean> really, it isn't
14:45:59 <davean> sm: The closest to "hard" you get is GHC SOMETIMES uses a few syscalls that are newer
14:46:09 <davean> so ... you just don't have it use them
14:46:14 <sm> I really think it is, until you've tried to support users of you executables on diverse real-world platforms
14:46:22 <sm> if you've done that, then I stand corrected
14:46:28 <davean> Fine, I haven't shipped anything to earlier then 2.2
14:46:43 <davean> If you're talking about pre linux 2.2, I lack experience
14:46:46 <sssilver> sm: most code today gets run on platforms that are picked by the same company that writes the code
14:47:07 <sssilver> including the Golang code that my company ships
14:47:22 <maerwald> well, and then you hit incompatibilities in kubernetes :P
14:47:23 <davean> And that only thing wasn't "just staticly link it" was GHC uses epoll in one configuration
14:47:25 <sssilver> especially with golang, I'd say.. nobody ships go code for desktops/etc
14:47:41 <sm> ssilver: well that depends. In many fields that's true
14:47:43 <davean> sm: really, what you're talking about is the basis of the idea of POSIX
14:47:45 <jwillia3> Am I missing something? Does ghci not accept top-level definitions? I try f x = 1 and it responds that there's a "parse error on input '='"
14:47:48 <davean> sm: its a solved problem
14:47:49 <davean> its NOT hard
14:47:57 <davean> sm: its not even hard adjacent
14:48:06 <sm> anyway, just pointing out one or two things that arguably are easier in go. I won't argue further :)
14:48:09 <ongy> glguy: I'm trying to have a list of options (I know the possible options at compile time, but for convinience, I want a list) each with a value in config-value. Do I need to use TH for that? I'm stuck at a point where the compiler tells me SectionSpecs is not Monad
14:48:29 <maerwald> sm: and rightly so, because there are no other points that are easier over here xD
14:49:05 <sssilver> sm: it's definitely easier to get a runtime error in Go than in Haskell
14:49:43 <maerwald> not sure about that
14:50:13 <glguy> ongy: Could you give me some examples of what you mean ?
14:50:48 <sm> jwillia3: put "let " in front of that. Might not be needed with newer GHC
14:51:54 <geekosaur> jwillia3, basically what sm said. if you have ghc 8.x then it would work as is, but older versions require 'let'
14:51:56 <jwillia3> sm, does that work in the compiler as well?
14:52:00 <geekosaur> no
14:52:07 <ongy> glguy: https://github.com/Ongy/waymonad/blob/config_schema_fail/src/Config/Input.hs#L24 LI.libinputOptions is a list of possible options. Each of them has a name. So I'm trying to create a list of possible options (the name as section name, associated with the option) and then have all of those be Text, so I can associate a text with the proper option
14:52:15 <geekosaur> ghci doesn;t make much of an attempt to behave like a file
14:52:17 <jwillia3> Ah, yes, I'm on 7.10.3. Thanks
14:52:24 <geekosaur> it's more an interactive calculator
14:53:30 <geekosaur> there are *lots* of differences from how code in a file would behave. even beyond the syntactic ones (you can't split definitions over multiple lines unless you switch to multiline mode or use :{ :} grouping, for example), it does type inference differently because it can't know what you will type later
14:53:45 <geekosaur> whreas for code in a file, it at least knows that there *is* a later
14:54:21 <glguy> ongy: Is the Monad constraint coming from forM?
14:54:30 <glguy> would Data.Traversable.for be better
14:55:35 <ongy> ahh, good to know. Yea, looks like the better option. Why is forM contrained on monad? o.0
14:55:48 <geekosaur> historical (what did you think the M meant?)
14:55:58 <c_wraith> it predates Applicative being a superclass of Monad
14:57:10 <glguy> forM is implemented in terms of mapM, and mapM is allowed access to the Monad instance which could actually result in different performance characteristics when implemented using >>=
14:57:23 <glguy> by default it doesn't do anything fancy like that, though
14:57:54 <ongy> oh right, I think for MaybeT it would make a difference
15:03:56 <ongy> hmm, I had to result to manually map things and not use the do notation. I guess ApplicativeDo messed up in some way. And yea, for is better here than forM. Thx
15:05:28 <glguy> ongy: Something like this? http://lpaste.net/362423
15:07:11 <geekosaur> the more I look at what ApplicativeDo is doing, the more I think it's a whole bunch of bugs looking for an excuse to bite people
15:07:39 <glguy> ongy: >>> fmap (loadValue listOfOptions) (parse "[ {option1: \"abc\"}, {option2: \"def\"} ]")
15:07:41 <glguy> Right (Right [Option1 "abc",Option2 "def"])
15:09:24 <ongy> yea, it looks similar in concept
15:12:06 <ongy> https://github.com/Ongy/waymonad/blob/config_schema_fail/src/Config/Input.hs#L24 looks like this now, this compiles. the nested do didn't want to compile
15:13:41 <glguy> Ah, I see. This way you can have exactly zero or one of each option in an association list
15:14:34 <ongy> and I expect the generated syntax description to list the possible options. Let's see
15:16:11 <glguy> It might be worth having the "options" section be optional so that if it's omitted it's the same as setting it to an empty map
15:16:24 <glguy> if that's going to be a common case
15:19:19 <ongy> right, I had that in mind and then forget when I started writing the spec for it
15:59:53 <crestfallen> hi it must be mismatched brackets.. why do I get False here ? https://ptpb.pw/XSpy
16:01:46 <glguy> not mismatched brackets, your numbers are just out of order
16:02:26 <jle`> n_blownapart: your function expects your tree to have its leaves in ascending order
16:02:38 <jle`> but 22 seems to come before 19
16:03:57 <jle`> btw, compare x y == EQ is just x == y
16:04:22 <n_blownapart> jle`: thanks one moment please
16:04:48 <Axman6> n_blownapart: you might find using the Data.Tree module useful - not to replace your structure but to take advantage of its pretty printing code so you can inspect the tree
16:06:39 <ongy> glguy: I just love config-schema :) It's so nice to use (when ApplicateDo doesn't mess with you :)
16:07:09 <n_blownapart> Axman6: thanks, digesting
16:11:08 <CritJongUn> metahumor: you're there?
16:13:12 <n_blownapart> jle`: I'm not sure why they need to be in ascending order..
16:32:23 <Axman6> nshepperd1: if they're not, then you don't have a binary search tree
16:32:36 <Axman6> bleh, they left >_<
16:32:45 <Axman6> sorry nshepperd1
17:36:35 <ClaudiusMaximus> is it possible to use stack under wine on linux?  my attempts so far have led to null pointer dereferences in msys2 exes...
17:38:18 <huytd> I think stack does supported linux, why do you run it under wine?
17:38:29 <ClaudiusMaximus> so i can compile binaries that run on windows
17:39:43 <huytd> interesting
17:40:06 <ClaudiusMaximus> well that's my goal.  so far i have failures
17:40:06 <kadoban> ClaudiusMaximus: A VM seems like a better idea to me
17:40:13 <ClaudiusMaximus> i don't have windows
17:43:18 <EvanR> one does not simply develop for windows without windows
17:44:43 <ClaudiusMaximus> EvanR: i have a C and C++ workflow for it, why not haskell too?
17:45:10 <EvanR> how sure are you that it works
17:45:27 <ClaudiusMaximus> users feed me bug reports
17:45:52 <EvanR> and then you change something randomly rerelease and wait?
17:46:08 <ClaudiusMaximus> i can run windows programs with wine
17:46:15 <ClaudiusMaximus> well, a subset of them
17:47:11 <EvanR> something about the easy way and the hard way
17:47:50 <EvanR> haskell tooling has had some bumpy relationship with windows for a while, and then throw wine on it
17:48:00 <ClaudiusMaximus> but maybe the real issue is with the msys2 version that stack downloads not working with the ancient wine version on debian stable
17:48:24 <ClaudiusMaximus> coupled with me having set up a separate user for this stuff and running it through ssh -X
17:48:50 <EvanR> ancient wine... yeah ive always built the latest branch of wine
17:56:38 <woodson> Hi guys, im just how is (<*>) "ap" is defined? I am looking at the source code and it seems like its using liftA2 https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#liftA2
17:56:40 <lijero> ClaudiusMaximus: there's always wine-development and/or using apt pins to use the one in testing
17:56:50 <woodson> however liftA2 is also using (<*>)
17:56:54 <lijero> better than compiling it yourself
17:56:58 <simplegauss> are there heuristics for deciding, in Haskell, whether "something" should be modeled as a type or a piece of data? although this seems meaningless from the point of view of no-extensions Haskell, as i am trying to learn about the dependently typed parts of the language i have this dilemma more and more when thinking of examples
17:57:24 <woodson> I would just like to know how to lift a function to a structure using monad function and functor function
17:57:31 <woodson> :t fmap
17:57:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:57:38 <woodson> :t (<*>)
17:57:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:58:14 <ClaudiusMaximus> lijero: yeah i tried wine-development too, with similar results (either hang with 0%CPU usage, or crash with null pointer dereference in msys sh.exe while running stack setup in cmd.exe)
18:04:16 <sm> ClaudiusMaximus: I used to build with cabal in wine, at least
18:05:21 <sm> ..I'm fairly sure
18:07:15 <ClaudiusMaximus> sm: ok, i'll try with cabal install, though it may become painful with foreign library dependencies...
18:07:26 <sm> oh, that's a whole other kettle of worms
18:07:46 <sm> get it working with an easy builds-on-windows package first
18:09:00 <sm> appveyor is another option
18:15:18 <simplegauss> woodson: do you mean in terms of bind and fmap?
18:25:30 <jle`> woodson: <*> is a typeclass method
18:25:40 <jle`> woodson: so all instances of it get to write their own implementation
18:25:47 <jle`> are you familiar with typeclasses in haskell?
18:26:43 <jle`> typeclasses get to provide a default implementation, as well, in terms of other methods
18:26:58 <jle`> for example, class Eq a where x == y = not (x /= y); x /= y = not (x == y)
18:27:24 <jle`> it is expected that someone who writes an instance of Eq will define either (==) or (/=) for their type, and the other one would be an automatic default definition
18:29:32 <focu5> hello
18:29:56 <focu5> id like to ask/seek advice on smart constructors
18:30:09 <focu5> should they error or return a Maybe/Either
18:30:55 <focu5> on one hand i feel like Maybe/Either is the more idiomatic haskell but on the other hand error seems easier and less in the way
18:31:10 <focu5> is there any substantial argument for one way or the other?
18:34:34 <Axman6> focu5: if something can fail, then you should keep that error at the value level, exceptions should be for truly exceptional circumstances.
18:35:05 <Axman6> Maybe is generally a good option unless there's many ways construction can fail, then a custom error type _may_ make sense, but may also now
18:35:07 <Axman6> not*
18:35:33 <focu5> that makes sense
18:35:39 <focu5> ive just seen a lot of examples use error
18:35:51 <focu5> and nobody really explained why
18:36:39 <jle`> there isn't really a good way to handle 'error' exceptions for non-IO smart constructors
18:36:58 <jle`> so it only makes sense to use them if you know that you're going to succeed
18:37:06 <jle`> cause if you don't, your program is completely broken
18:37:15 <focu5> that makes sense
18:37:43 <focu5> in my case i have newtyped Register and Immediate values that are bounded odly (0-7, 0-55)
18:37:57 <jle`> it's against the haskell philosophy a bit, since usually we try to let the compiler assure for us that our code isn't broken
18:38:09 <jle`> but using 'error' etc. means that we take it into our own hands to ensure this
18:38:17 <focu5> putting in maybe seems like a lot of effort to handle something that if it happens basically means my code is broken
18:38:41 <jle`> it depends on the context in which you are getting your smart constructor inputs from
18:38:56 <jle`> if you're typing them in as literals, then it probably isn't too bad to just fromJust/use error there
18:39:07 <jle`> 'myRange 2', typing in 2 literally
18:39:18 <jle`> since you can see with your eyes that 2 is in the range
18:39:27 <focu5> well i have assembly parsers and they handle the error checking
18:39:27 <jle`> and if any failure happens, it's going to happen immediately
18:39:42 <jle`> what error checking?
18:39:45 <focu5> however when i construct the values i more or less expect myself to put in valid numbers
18:40:04 <focu5> that the assembly source has r0-7 and immediates are of a certain range
18:40:07 <jle`> if your parsers only return numbers in your valid range, then they should be returning the proper tYpe
18:40:08 <focu5> etc
18:40:22 <focu5> yes that's what im doing
18:40:24 <jle`> yes, your parers should then be returning the properly typed range
18:40:36 <focu5> im just trying to make it harder for myself to just put in a invalid value
18:40:51 <jle`> you mean in your parser input?
18:40:53 <jle`> or in haskell code?
18:41:01 <jle`> in your parser input, an invalid range should just be a failed parse
18:41:15 <focu5> in haskell code such as testing (creating the types by hand vs from a parser)
18:41:17 <jle`> your parser should just fail there, which is something you can trigger immediately by case-matching on Maybe
18:41:41 <jle`> ah yeah, if you literally type in your values, it probably isn't too bad to use an unsafe constructor
18:41:50 <focu5> yes
18:41:51 <jle`> since the value is the same every time
18:41:56 <jle`> it's always 2, always 3, etc.
18:42:11 <jle`> and so you won't have the situation where errors come up only in edge cases or in certain situations at runtime
18:42:13 <focu5> since if i dont type the right value it's basically broken anyway
18:42:38 <jle`> well, it's cause you can verify by just looking at your screen that it's the right range, since you're typing in a literal with your keyboard
18:42:54 <jle`> but if you're getting a value from runtime, you should be using a smart constructor where you can handle errors in a meaningful way
18:43:23 <focu5> i see
18:43:33 <jle`> the thing with literals in source code is that they'll crash right away if they are bad, there's no situation where the input might trigger bad errors in some cases and not others
18:43:40 <focu5> that clears up the difference when to use one way or the other
18:43:55 <jle`> but if you're getting a value from the environment then you probably would want to be able to handle the case where it's bad input
18:44:20 <jle`> > -1 :: Natural
18:44:22 <lambdabot>  *Exception: Natural: (-)
18:44:26 <focu5> my parser already handles bad values and the only other way i get those values is by typing the litterals
18:44:31 <jle`> > (5 :: Natural)
18:44:32 <lambdabot>  5
18:44:46 <jle`> (5 :: Natural), the literal expression, is always going to be 'ok'
18:44:53 <focu5> ok
18:45:03 <jle`> but if you get a number from the outside world, and you want to convert to Natural, you should take care
18:45:16 <focu5> makes sense
18:45:45 <focu5> ill use the error version since it's on me to type my literals correctly and the parser handles user input errors
18:45:51 <focu5> thanks for explaining
18:46:19 <jle`> no problem :)  this isn't a hard-and-fast rule, but it's something i've found to be practical
18:56:08 <woodson> jle: Thanks for your reply, I get that its a typeclass function but did they produce
18:56:14 <woodson> :t (<*>)
18:56:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:56:45 <woodson> in the source code they are using liftA2 which in turn uses (<*>)
18:57:33 <woodson> i want to see how does one lifts (a -> b) to f( a -> b) using the bind and fmap method
18:57:59 <woodson> thats why I am trying to find the implementation of (<*>)
19:01:47 <simplegauss> woodson: you just have (<*>) = flip (.) (flip fmap) . (>>=)
19:03:13 <simplegauss> or less obscurely f <*> o = f >>= flip fmap o
19:28:01 <simpson> Hi! Is this the right channel for Pandoc questions?
19:42:10 <jle`> should have just asked their question :'(
19:42:29 <jle`> woodson: that's what i mean when i say that there is no such thing as the 'implementation of <*>'
19:42:50 <jle`> woodson: no such thing exists in Haskell, except as a potential default def
19:43:26 <jle`> that's like asking for 'the implementation of (==)', or 'the implementation of (+)'
19:43:38 <jle`> but 'ap' might be what you are looking for -- http://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#ap
19:49:07 <woodson> simplegauss: Oh my god thanks, man I dont know why it didnt seem obvious too me
19:52:19 <woodson> jle: I see, what you mean
19:53:28 <woodson> I was looking for (<*>) implementation to have a sense on how to lift a function in a structure
19:53:50 <woodson> which I kinda knew but I dont know why It didnt come intuitively
19:54:00 <woodson> (sigh...)
19:54:04 <jle`> yeah, you are looking for something you will never find in haskell :'(
19:54:09 <jle`> since such a thing does not exist
19:54:22 <jle`> but the do notation version i think reads pretty nicely
19:54:41 <jle`> ff `ap` xx = do { f <- ff; x <- xx; return (f x) }
19:56:05 <woodson> jle: Well I am following the haskell programming book's exercise and one of the exercise requires me "Write the following functions using the methods provided
19:56:05 <woodson> by Monad and Functor"
19:58:19 <jle`> yes, 'ap' is the thing that does that in the base library
19:58:31 <jle`> not <*>
19:58:48 <centril> Looking at the https://github.com/haskell/rfcs repository... I have to ask; what is the point of a Haskell report at all? Why should GHC just not steamroll over everything and say that GHC == Haskell?
19:59:16 <centril> then you can start merging language pragmas in to Haskell prime quickly
19:59:44 <woodson> jle: Thanks!
20:00:04 <ab9rf> not everyone agrees that ghc's decisions are the right ones
20:00:39 <centril> ab9rf: is there another industrial compiler that a lot of people use?
20:01:18 <ab9rf> centril: a lot? not that i know of. but there are other haskell compilers that are used by some number of people somewhere
20:01:30 <jle`> centril: there's a point to having a language spec
20:01:43 <jle`> all languages should have a specification
20:01:49 <purelazy> Isn't GHC the best, for most purposes
20:02:07 <ab9rf> that too
20:02:26 <centril> jle`: sure; I'm just saying that the developers of GHC should define and refine the spec as they see fit
20:02:37 <ab9rf> is uhc still around?
20:02:49 <jle`> centril: yes, that is a different question indeed
20:03:35 <ab9rf> centril: for the most part, they do, but there's a lot of community consulation in that process
20:03:46 <centril> The haskell community could learn a lot from Rust here
20:03:56 <ab9rf> centril: i'm not sure that they could
20:04:07 <centril> ab9rf: there hasn't been a new spec since 2010
20:04:16 <ab9rf> ghc's user community is full of lots of very strong-minded individuals
20:04:42 <ab9rf> it's hard to get consensus in the community
20:05:22 <centril> ab9rf: I'm sure that is also the case in the Rust community; you need people who reach decisions and then stick with it, whatever a vocal minority might say
20:05:37 <ab9rf> centril: that's explicitly not what a "consensus" is
20:06:19 <centril> ab9rf: consensus must have limits - you can't let say 5% hold up what 95% of people want
20:06:41 <ab9rf> centril: sure, that's exactly what it means
20:06:50 <ab9rf> centril: you've never worked on a standards committee, i take it
20:07:23 <centril> ab9rf: What is the value standardization brings to the Haskell community atm?
20:10:26 <centril> For C++, it is important that there be a standard, since interop between compilers is important, but for Haskell it seems that GHC is the only viable choice (assuming you want the extensions that I would never be OK without...)
20:12:06 <centril> (no, I've never worked on a standards committee, like most developers)
20:14:43 <Axman6> GHC's role is somewhat as the playground for what should become the next Haskell standard - extensions are added to GHC to see if they work and make sense - there have been cases in the past where they're had some really awful unforseen consequences which needed fixing to make the extension safe.
20:17:28 <centril> Axman6: to be clear, I'm not advocating cavalierly adding extensions left and right to the spec - but there are extensions which have been around for a long long time and are purely syntactic - take LambdaCase for example
20:19:40 <Axman6> I feel that many people felt that the Haskell2010 process ended up being pretty ineffective, with far less being dne than really should have been. Hopefully future standards won't be as conservative, but who knows
20:21:03 <geekosaur> the committee fell apart shortly thereafter, presumably for reasons
20:21:41 <centril> Axman6: That would be nice; I think also that use of extensions are so pervasive now that people's code depend on them... I think you should decide on language extensions within a year or so of addition... either you add it to the spec or you remove it entirely imo
20:22:00 <centril> but having extensions in limbo with a lot of people depending on them is bad
20:22:36 <geekosaur> there are also some things that have needed to be done for a long time, but need outside action. like, some of us are hoping for a type families-based mtl3 in the future... which will make it possible to get MPTC in
20:23:39 <geekosaur> (fundeps have lots of problems, not the least of which is that you're suddenly using an ad hoc subset of Prolog available in only one small part of your type system)
20:23:47 <ab9rf> heh
20:24:14 <ab9rf> from whati've seen part of the issue is that there is fairly deep disagreement over the "best way" to go beyond the current standard, at least in certain areas.
20:24:29 <u-ou> fork Haskell!
20:24:49 <u-ou> actually no, we don’t need dialects :p
20:24:52 <centril> geekosaur: so... let's get rid of fun-deps if it has had problems for so long?
20:25:24 <geekosaur> eventually yes. but since mtl is pretty much a core part of the ecosystem and is fundeps-based... we need that mtl3 I mentioned
20:25:26 <centril> u-ou: we already have dialects... that is what extensions effectively constitute
20:26:02 <geekosaur> and deployment to demonstrate that indeed, the reasons type families were skipped for mtl2 are all resolved now (really, they have been for some years)
20:26:21 <geekosaur> but language committees like to see proof in the form of wide deployment
20:26:21 <ab9rf> i think it's pretty much decided that fundeps will go, but that process is not going to be quick or painless
20:26:28 <geekosaur> that too
20:27:16 <monochrom> Oh sob sob fundep was so nice.
20:27:45 <centril> Let's have yearly standardization, so Haskell 2018, 19, 20, .. , mkay?
20:28:03 <geekosaur> that was what the last standards committee wanted to do
20:28:05 <monochrom> But I thought it was "you're suddenly using ER diagrams in only one small part of your type system" :D
20:28:07 <ab9rf> forced release dates result in inferior quality releases
20:28:07 <geekosaur> you can see how well that worked out
20:28:08 <jackdk> Is there a document anywhere describing the problems with fundeps?
20:28:42 <centril> monochrom: haha @ ER diagrams
20:28:52 <ab9rf> you rush to release the least stinky turd you can come up with by the release date
20:29:02 <ab9rf> but all you've done is gild a turd. it's still a turd.
20:29:18 <centril> ab9rf: I'm fine with saying "for haskell19 we standardized nothing"
20:29:32 <ab9rf> centril: and how is that useful?
20:30:11 <centril> ab9rf: at least you have continuity and the community knows that things are being chugged at and decisions will be made eventually - it won't be in limbo
20:31:31 <jackdk> To pull an example from another domain: a lot of people in the card game worlds like the idea of a fixed cadence of updates, even if some are null. It means you know when to start worrying about the banlist changing and can plan your time better in the run-up to big tournaments
20:34:59 <centril> ab9rf: but I standardizing nothing each year sounds unlikely with a good process where a dedicated team can evaluate and make decisions
20:35:41 <llinguini> So I have a list  S :: [Int] and I want to get a list of all posible pairs of individual elements in the list. [(x, y) | x <- S, y <- S, x /= y] doesn't work because if S = [8, 8], I still want [(8, 8)], but if S = [1, 2], I don't want (1, 1) and (2, 2)
20:36:39 <llinguini> in fact if S = [1, 2] I only want [(1, 2)], (2, 1) is redundant
20:37:53 <monochrom> I think what you're saying is you're sensitive to indexes not content.
20:38:00 <llinguini> yes
20:38:15 <llinguini> That's a better way to put it
20:38:36 <llinguini> All unique combinations of 2 of a set that can contain duplicates
20:38:50 <monochrom> [ (x,y) | (x,i) <- zip s [0..], (y, j) <- zip s [0..], i /= j ]
20:39:22 <centril> imo, it should work like this: you make a GHC-proposal, people discuss it for a while, a lang-team announces their disposition to merge or close a PR; in 2 weeks after that whatever the lang-team has decided happens... the proposal then gets implemented... the feature is tested in the wild, bugs are found, soundness issues are stomped out or not - and then the lang-team decides to stabilize the language
20:39:24 <centril> feature into Haskell prime and updates the spec, at this point you don't have to use a language pragma for it. If the lang-team does not think this will end up preserving soundness after some time, the feature is removed from the language.
20:39:29 <monochrom> I should put this on my midterm.
20:39:38 <jackdk> schwarzian transform
20:39:52 <llinguini> monochrom: That still doesn't work if you have input list [1, 2]
20:40:04 <llinguini> in that case you'll get [(1, 2), (2, 1)]
20:40:15 <monochrom> i < j ?
20:40:23 <llinguini> yeah was going to just add that
20:40:35 <llinguini> but monochrom: thanks
20:40:53 <ab9rf> requires that the underlying type be ordered, but that might not be a problem
20:41:10 <centril> But a GHC-proposal being merged should already count as the intent to eventually standardize assuming the implementation pans out and no soundness holes were found
20:41:28 <monochrom> The underlying type is from [0..]
20:42:20 <ab9rf> monochrom: bah, stop being so obvious :)
20:46:08 <llinguini> What's an underlying typeform?
20:47:04 <monochrom> Oh ab9rf saw me writing "i < j" and reminded that this requires the type of i to be ordered.
20:47:15 <monochrom> But then i and j come from [0..] so we're done.
20:47:43 <ab9rf> i was already extending this other sets
20:48:03 <ab9rf> not sure that it makes sense to do so, but i had the idea anyhow
20:49:16 <ab9rf> if you replaced [0..] with an aribtrary list, the use of < would require that list to be Ord k => [k]
20:52:52 <llinguini> I see
20:53:03 <llinguini> another question, how do you model a Set functionally?
20:53:27 <ab9rf> what do you mean by a "Set"?
20:53:50 <llinguini> Just a mathematical set that contains unique elements
20:54:06 <monochrom> At this point functionally or imperatively doesn't matter.  You're running into the limitation of computing at all.
20:54:22 <ab9rf> unique elements of... what?
20:54:32 <llinguini> anything
20:54:44 <ab9rf> paging bertrand russell
20:54:54 <monochrom> For example if you want to model the set of the real numbers, you have to give up one thing or another.
20:55:06 <monochrom> And yeah Russell.
20:55:14 <mud> BST-based sets work well in haskell if that's what you're asking. There's also things like IntSet, which are kind of patricia trees
20:55:43 <ab9rf> there are a number of implementations of "set-like" datatypes in haskell, each with its own limitations and features
20:56:07 <ab9rf> almost all of them require that all of their elements be of the same datatype, though
20:56:10 <mud> And then on top of the same idea as IntSet you can do hash based things if you want
20:56:22 <monochrom> BST would limit you to finite sets.  Furthermore restrictions on elements, e.g., you won't have much luck with "it's a set of 5 arbitrary computable functions"
20:56:49 <ab9rf> there are many ways to (imperfectly) model abstract sets; which one you choose depends on which imperfections serve your needs
20:57:03 <mud> Maybe I'm missing part of this conversation or something *backs away*
20:57:14 <monochrom> So yeah write down your API.  Don't say "you know what I mean".
20:57:27 <ab9rf> determine your API and your laws
20:57:36 <llinguini> Okay fine something like a generic set from C++
20:57:37 <monochrom> ELIDKWYM = explain like I don't know what you mean.
20:57:46 <llinguini> for example
20:57:55 <monochrom> That's BST. Even in C++.
20:58:04 <ab9rf> i confess to being almos completely ignorant of C++ container types :)
20:58:18 <ab9rf> i have no idea what the C++ STL "set" API is
20:58:22 <mud> llinguini: Data.Set and std::set are fairly similar in implementation, at least the broad strokes.
20:58:35 <monochrom> So the difference is just mutable BST vs immutable BST, but this is basically tiny difference.
20:58:50 <llinguini> I see
20:59:56 <monochrom> And C++ can't do "mathematical set" if you haven't noticed.
21:00:41 <monochrom> Always consult Russell, Cantor, Gödel, and Turing before you think something is computable.
21:01:23 <monochrom> And when they approve, consult Church for how to do it functionally.
21:02:12 <monochrom> OK Church doesn't know Haskell, so maybe Wadler instead.
21:08:09 <u-ou> is the haskellbook.com ebook for > 1 devices?
21:08:50 <parsnip> i think it's just for 1 person, it already gives you multiple formats
21:09:14 <u-ou> yeah, 1 person but multiple devices
21:24:55 <ggVGc> how would I compoe (not . f), (not . g) and (&&) to get a function equivalent to (\x -> (not . f) x && (not . g) x)
21:25:00 <ggVGc> compose*
21:29:31 <[Leary]> > (liftA2 (&&) `on` not) null null []
21:29:33 <lambdabot>  error:
21:29:33 <lambdabot>      • Couldn't match type ‘Bool’ with ‘[a2] -> Bool’
21:29:33 <lambdabot>        Expected type: Bool -> [a2] -> Bool
21:29:41 <[Leary]> > (liftA2 (&&) `on` (.) not) null null []
21:29:43 <lambdabot>  False
21:31:27 <ggVGc> thanks!
21:31:42 <blankhart> i am experimenting with quasiquotes and needed to derive Data and Typeable for a type signature that included a phantom type (just a wrapper around a Double). i created a manual Data instance with everything undefined and derived Typeable.  is there a better way?
21:37:11 <blankhart> (i.e., created a fake Data instance for the phantom type)
21:45:10 <pierrot> ggVGc : maybe `h = ((&&) <*> (not . g)) . (not . f)` would work too and it's a bit more simple
21:49:37 <ClaudiusMaximus> got a syntax error with c2hs and fltkhs using ghc-8.2.2 on windows (via appveyor), any ideas anyone? http://lpaste.net/362436
21:51:12 <[Leary]> If you wont to write it in terms of <*> then imo the classic pattern of (&&) <$> not . g <*> not . f is much prettier, and somewhat clearer. liftA2 and on can seem a bit mystical, but they're patterns well worth being familiar with.
21:56:01 <amalloy> [Leary]: not . liftA2 (||) g f
21:56:34 <amalloy> oh i guess ggVGc was asking
22:01:02 <[Leary]> That's a good way too; some basic logic and the on is, of course, unnecessary. Though I like the way liftA2 ((&&) `on` not) is point-free in g and f.
22:03:06 <[Leary]> > ((.).(.).(.)) not (liftA2 (||)) null null [] -- huhuhu
22:03:08 <lambdabot>  False
22:04:33 <danilo2_> Hi guys! Can I assume when using TemplateHaskell, that reifyInstances will always (no matter what order GHC would choose for file compilation) return the same set of visible insstances in a given place? I mean - do reifyInstances could report me different instances if no isntance was added / subtracted however some sources were changed and the project was recompiled ?
22:07:54 <heptahedron> Could anyone link me to/show me a basic example of using a lens with a `FieldRec` from Vinyl?
22:10:10 <mjrosenb> quick sanity check: I can use a binding from a where statement in a guard for a top level function, yes?
22:12:19 <cocreature> mjrosenb: yep
22:14:51 <mjrosenb> sweeeeet.
22:57:54 <ankitsiam> can some one please explain this error to me & how to fix it
22:57:55 <ankitsiam>  • Couldn't match expected type ‘IO a1’                   with actual type ‘i0 -> IO (K.KademliaInstance i0 a0)’
22:58:21 <ab9rf> you need another argument
22:59:13 <ab9rf> that type indicates an incompletely applied function
23:00:55 <ab9rf> c 8ut5
23:01:23 <ab9rf> sorry, dropped my phone on my keyboard
23:01:41 <opqdonut> nice try, that's your password ;)
23:02:25 <ab9rf> yeah, sure
23:07:34 <mjrosenb> Could not find module ‘Data.Map’
23:07:39 <mjrosenb> that seems... bad
23:07:52 <cocreature> mjrosenb: you need to add containers to the build-depends section in your cabal file
23:08:06 <mjrosenb> ahh, that isn't in base?
23:08:09 <mjrosenb> well...
23:08:13 <mjrosenb> obviously not.
23:08:35 <cocreature> mjrosenb: hoogle can be useful for figuring out which package a module comes from http://hoogle.haskell.org/?hoogle=Data.Map%20is%3Amodule
23:14:40 <dminuoso> Foldable f => (a -> Maybe b) -> a -> b
23:14:46 <dminuoso> Foldable f => f (a -> Maybe b) -> a -> b
23:15:06 <dminuoso> Is there something along those lines? I basically want to pick the first function that doesn't produce Nothing.
23:15:38 <EvanR> thatd be a foldr right
23:15:56 <dminuoso> EvanR: I want to avoid some explicit if then else in my fold.
23:16:08 <dminuoso> or rather pattern matching with case I guess
23:16:35 <EvanR> well, you could hide that using the First wrapper for Maybe
23:16:45 <EvanR> @src First
23:16:45 <lambdabot> newtype First a = First { getFirst :: Maybe a }
23:17:07 <EvanR> and then foldMap
23:17:24 <cocreature> "asum" might also be handy
23:17:44 <cocreature> eh actually it won’t, nvm
23:18:16 <cocreature> well if you combine it with fromJust it will be and I guess that also shows the problem with your type signature :)
23:18:45 <EvanR> ah
23:19:00 <cocreature> > asum [Nothing, Nothing, Just 3, Nothing]
23:19:02 <lambdabot>  Just 3
23:19:16 <EvanR> :t asum
23:19:17 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
23:19:37 <EvanR> wicked
23:20:18 <dminuoso> EvanR: Mmm, okay. So I can trivially build some `f (a -> Maybe b) -> a -> a -> b` I guess
23:20:21 <dminuoso> Err cocreature. :)
23:20:29 <dminuoso> Thank you.
23:20:57 <EvanR> f (a -> Maybe b) -> a -> Maybe b
23:21:01 <EvanR> f (a -> Maybe b) -> a -> b -> b
23:21:55 <dminuoso> cocreature: I mean ultimately I have a default rule - so I know my construction will be total. So I dont need the Maybe.
23:57:43 <olligobber> so, doing `let f n = f (n+1) in f 0 :: Int` uses all my memory, I suspect due to excessive lazy evaluation
23:58:36 <EvanR> > let f n = f (n+1) in f 0 :: Int
23:58:42 <lambdabot>  mueval-core: Time limit exceeded
23:58:46 <EvanR> no
23:59:16 <EvanR> its recursion
23:59:30 <EvanR> f computes by first calling itself
23:59:31 <EvanR> and so on
