00:21:45 <piark_> hello
00:24:45 <akr> qeyoa: it makes sense from the poin of view of the theory of boolean algebras, if you want some arbitrary, not-necessarily-meaningful justification :)
00:25:13 <akr> you should be able to show that Bool (together with the regular operations) is a boolean algebra is what I'm saying
00:26:33 <akr> (to be fair, it would also be a boolean algebra if the order was inverted, but you would have to swap some operations as well then, like `and` and `or`)
00:32:33 <zbs> hello
00:33:22 <clever> lets say i have an data record in the form of `data Foo = Foo { field1 :: Int }`, and i passed field1 to a function, so it has type `Foo -> Int`, can i use that to update field1 within an existing record?
00:33:45 <cocreature> clever: no
00:34:05 <clever> would i need a lens to do such a thing?
00:34:14 <dibblego> a lens would be appropriate yes
00:34:15 <cocreature> yeah that’s probably the best solution
00:34:23 <dibblego> all you do is change (->) to Lens
00:35:05 <clever> so i pass it a `Foo Lens Int` and make lenses over Foo?
00:35:23 <cocreature> Lens' Foo Int
00:35:28 <dibblego> Foo `Lens` Int, and yeah, or you can have them automatically generated
00:39:12 <clever>     • Illegal polymorphic type: Lens' CounterHacks Int
00:39:32 <dibblego> show code please
00:40:14 <clever> dibblego: https://gist.github.com/cleverca22/e7ce2feb6dc49437c899a257e21f47b5
00:40:53 <cocreature> clever: the error message probably tells you to turn RankNTypes right? just do that
00:41:36 <clever> ok, now ive got a heap of new errors, checking them...
00:41:40 <cocreature> clever: note that you can’t just use a lens like you would use a function "CounterHacks -> Int". you have to use "view"
00:42:27 <clever> yeah, just added view to those spots
00:42:45 <clever> now i need to find the actual name of the lenses, they dont match the record fields
00:43:20 <cocreature> lenses don’t magically exist. you have to either define them manually or use something like makeLenses
00:43:40 <clever> i am doing makeLenses
00:43:48 <clever> but the foo name was occupied by the old accessor
00:43:58 <clever> i renamed it to _foo, and then makeLenses made a foo lens
00:44:09 <cocreature> yeah that’s what most people end up doing
00:45:47 <clever> well, it type-checks!
00:45:56 <cocreature> ship it!
00:46:05 <clever> shipping...
00:49:57 <clever> cocreature: yep, seems to be working
00:57:37 <clever> and now ive gone over the whole thing with -Weverything
00:58:40 <pikajude> how do I get cabal new-haddock to install haddocks for the dependencies as well?
00:58:43 <pikajude> it's not too useful without that
00:59:20 <cocreature> pikajude: you need a very recent version of cabal that contains https://github.com/haskell/cabal/pull/5143
00:59:48 <pikajude> oh, lovely
01:00:17 <pikajude> i guess i should stop complaining about nonfunctional stuff in basically alpha level software
01:01:44 <cocreature> there is a reason that new-build is not yet the default :)
01:04:44 <parsnip> trying to write to fifo, but nothing happens. works with just command line `echo`.
01:04:50 <parsnip> main = writeFile "/Users/iam/.weechat/weechat_fifo" "core.weechat */print hello"
01:05:19 <parsnip> and it works if i just write to a file
01:20:21 <pikajude> hmm, how annoying
01:20:30 <pikajude> it doesn't reinstall existing packages with documentation
01:41:46 <ongy> parsnip: does it work if you try to print to a regular file?
01:41:57 <parsnip> yes
01:42:24 <ongy> do you get any error? Or does it return properly and just nothing happens?
01:43:04 <dminuoso> Is there a standard way to get access to POSIX atexit? Specifically I need to send some escape sequences to unscrew my terminal.
01:43:06 <ongy> ah, I see a difference :) add a '\n' to the endo of the string. echo does that by default (unless you pass -n). If weechat relies on the newline to do anything, it will not do so from the writeFile
01:44:02 <parsnip> aaaahhhh
01:44:05 <parsnip> thank you.
01:46:58 <ongy> usually I just ignore typos, but in this channel I stare at that 'endo' and wonder if someone could explain the meaning of an "endo of the string"...
02:04:45 <lseactuary> hi i am trying to make a picture of a bee journey and have made some code. it gives syntax issues when i try to compile can someone help me?
02:05:02 <qeyoa> exit
02:05:15 <lseactuary> http://lpaste.net/2480067511467376640
02:07:36 <cocreature> lseactuary: what’s the error?
02:07:52 <lseactuary> move1 (E (||) W) x:+y
02:08:02 <lseactuary> Failed, no modules loaded.
02:08:32 <cocreature> please show us the full error message
02:09:09 <lseactuary> added to http://lpaste.net/2480067511467376640
02:10:00 <cocreature> lseactuary: what is (||) supposed to be?
02:10:01 <dminuoso> lseactuary: What is (||) supposed to be in there?
02:10:03 <dminuoso> Heh
02:10:10 <lseactuary> its or no?
02:10:24 <dminuoso> lseactuary: Its not a data constructor.
02:10:28 <lseactuary> oh
02:10:56 <lseactuary> so i need to do a case then right
02:11:24 <cocreature> I’m also not sure what you expect to happen when you pattern match on ||. what should happen if the result is False?
02:11:47 <lseactuary> the bee must be facing one of the 4 directions right
02:11:57 <cocreature> a guard or an if statement would probably be more appropriate but you could also use a "case"
02:12:06 <lseactuary> guard is | right?
02:12:14 <cocreature> yep
02:12:19 <lseactuary> sorry i was tryign to be clever :P
02:12:26 <lseactuary> i made the guard way originally :P
02:12:26 <cocreature> oh now I get it
02:12:33 <cocreature> you want to pattern match on either E or W, right?
02:12:37 <lseactuary> yeah
02:12:46 <lseactuary> because N/S take the same path
02:12:52 <lseactuary> W/E take the same path
02:12:54 <cocreature> || is boolean or, you can’t use it on things that are not of type Bool
02:12:58 <lseactuary> ah
02:13:20 <cocreature> (also if you use operators in infix form you need to remove the parenthesis)
02:13:36 <lseactuary> ah ye i had just || then that threw an error so was messing about
02:13:37 <dminuoso> lseactuary: You could also write multiple lines. Once for E, once for W.
02:13:49 <cocreature> yeah a case statement might be the best option here. then you can define the shared code in a where/let clause
02:13:52 <lseactuary> dminuoso yeah but wanted to be elegant :P
02:14:00 <lseactuary> ah ok i will try it now
02:14:23 <dminuoso> On a different note. Do you folks find it elegant to encode recursion with fix, rather than explicitly?
02:14:36 <lseactuary> yeah
02:14:42 <lseactuary> i have an example i can upload if you want
02:14:50 <cocreature> dminuoso: usually not
02:15:17 <dminuoso> cocreature: So fix exists to please the mathematicians in here?
02:15:54 <cocreature> dminuoso: in some cases it can be helpful like if you need to use recursion in a lambda and are too lazy to move it to a where/let clause
02:16:05 <cocreature> but ime moving it to a where/let clause is usually more readable
02:17:35 <dminuoso> cocreature: ah that makes sense
02:19:20 <lseactuary> i think i solved it :)
02:20:14 <lseactuary> http://lpaste.net/2480067511467376640
02:20:21 <lseactuary> can someone explain to me the Left1, Right1 thing
02:20:29 <ertes> anyone, who has had the opportunity to try selda in a non-toy setting and would like to share their experience?
02:20:29 <lseactuary> i need to write 2 seperate functions?
02:20:34 <lseactuary> i have never seen thi syntax before
02:22:04 <lseactuary> or i need to define in terms of the other?
02:24:12 <ertes> lseactuary: move1 p x :+ y = (move1 p x) :+ y
02:24:24 <Philonous> Is there a difference between data »Foo a b :: * where <...>« and »data Foo :: * -> * -> * where <...>«  ?
02:24:32 <ertes> lseactuary: that's a syntax error
02:24:38 <cheater> hi
02:24:46 <cheater> what's a good way to add tuples pointwise?
02:24:59 <lseactuary> ertes - the function you provided above, is for (a)?
02:25:03 <ertes> Philonous: no
02:25:08 <cheater> (u, v) + (x, y) = (u+x, v+y)
02:25:12 <cocreature> ertes: not even with PolyKinds enabled?
02:25:38 <ertes> oh, right…  i forgot about that
02:25:50 <ertes> Philonous: no (unless PolyKinds is enabled)
02:25:58 <Philonous> cocreature, Would the first one default to Foo :: k -> k -> *  with -XPolyKinds? I thought that only worked if you explicitly annotated it
02:26:09 <cocreature> Philonous: k1 -> k2 -> * iirc
02:26:14 <Philonous> Well, I can check
02:26:32 <Philonous> Right, no reason to assume the kind parameters are equal
02:26:42 <dminuoso> cheater: biliftA2 ?
02:27:03 <ertes> lseactuary: it's the function from the paste
02:27:21 <ertes> lseactuary: it needs to be written like this:  move1 p (x :+ y) = …
02:27:28 <lseactuary> ah
02:27:35 <Philonous> Nope, you're right, it's kind polymorphic by default
02:27:39 <lseactuary> you are right
02:28:24 <lseactuary> but (b) i am confused. am i supposed to write 2 functions, one as a function of the other? i made 2 attempts is it possible to clarify what the syntax means and the ni can try?
02:28:32 <ertes> lseactuary: if you encounter weird type errors, keep in mind that function application has higher precedence than any infix operator
02:28:41 <lseactuary> ah
02:28:52 <lseactuary> good to know i think i know what my previous errors were now :P
02:29:40 <ertes> lseactuary: Left1 and Right1 can't be defined as regular functions, because capitalised names are reserved for constructors
02:30:14 <lseactuary> *lseactuary googles for an example*
02:31:01 <ertes> lseactuary: example:  data Bool = False | True  -- all the capitalised words are constructors
02:31:31 <ertes> lseactuary: example:  not False = True; not True = False  -- non-capitalised words can be used as function names (such as 'not')
02:31:50 <dminuoso> cheater: Then it would be `biliftA2 (+) (+) a b` I think. there ought to be a simpler approach though :o
02:32:19 <lseactuary> ertes - sorry - i compiled the old file
02:32:25 <lseactuary> i just updated what it should be
02:33:05 <ertes> lseactuary: the way to write goLeft1 is to use pattern-matching…  you can see how it works in my 'not' example just now
02:33:29 <lseactuary> ertes - using guard again?
02:33:31 <ertes> lseactuary: (instead of semicolons you can just write those cases on multiple lines)
02:34:06 <ertes> lseactuary: guards are conditions you can add to patterns ("f x | condition = …"), but you don't need them here
02:34:10 <lseactuary> what i was confused is do i made one for goLeft and one for goRight
02:34:33 <lseactuary> ah
02:34:39 <lseactuary> i think i knowwhat you mean
02:34:40 <lseactuary> trying
02:35:24 <ertes> lseactuary: when you write a function, you can pattern-match on the value directly in most cases, so instead of writing "not x = if x then False else True" you can write "not False = True; not True = False"
02:35:33 <lseactuary> yup
02:36:03 <lseactuary> but here we have 4 cases i.e. if they are facing North then something, facing West then something etc
02:36:13 <lseactuary> well 8 cases - 4 for goLeft, 4 for goRight
02:36:21 <ertes> lseactuary: yes, just write those four cases on separate lines
02:36:30 <lseactuary> oki trying
02:40:33 <lseactuary> ertes it throws the same sytnax error as before :/
02:40:55 <ertes> lseactuary: paste your code
02:41:20 <lseactuary> http://lpaste.net/2480067511467376640
02:41:31 <lseactuary> (i tried with one = also)
02:42:27 <ertes> lseactuary: "f x == y" is an expression, not a function definition
02:43:03 <lseactuary> ye i tried with = first but had the eror :(
02:43:31 <ertes> lseactuary: does that paste include the full source code?
02:43:39 <ertes> of the module you're writing
02:43:55 <lseactuary> ah let me add
02:44:16 <lseactuary> now it does
02:44:35 <ertes> lseactuary: is this *exactly* the module you're compiling?
02:44:39 <lseactuary> yup
02:45:23 <ertes> lseactuary: then where do the types like CompassPoint come from?
02:46:51 <lseactuary> line 12 :)
02:47:12 <dminuoso> cheater: What you _could_ do is write: instance (Num a, Num b) => Num (a,b)
02:47:59 <lseactuary> oh
02:48:02 <lseactuary> i realise the issue
02:48:03 <lseactuary> 2 min
02:50:35 <lseactuary> ertes - maybe i dont :/ i thought it was the caps but that is fine
02:52:55 <lseactuary> just tried this code and same error (updated)
02:56:47 <ertes> lseactuary: there is still nothing that defines CompassPoint
02:56:57 <ahihi> lseactuary: you have a syntax error on line 26
02:57:02 <ertes> lseactuary: this is a literate haskell file, so line 12 is a comment
02:57:18 <ertes> lseactuary: that's why my conclusion is that you're not pasting the whole thing
02:57:59 <lseactuary> ahihi what is the error? that part compiles :/
02:58:06 <ahihi> there's no =
02:58:08 <lseactuary> ertes line 12 no?\
02:58:29 <ertes> lseactuary: only lines beginning with ">" are read by GHC
02:58:32 <lseactuary> ahihi do we need =?
02:58:50 <ahihi> yes, like on the two preceding lines...
02:58:50 <lseactuary> ah
02:59:04 <ahihi> but the definition does not make a lot of sense anyway
02:59:09 <ahihi> why is there an otherwise case at all?
02:59:29 <ertes> move1 is one massive type error
02:59:39 <ahihi> i would consider defining move1 using four separate equations, like goLeft1 and goRight1
02:59:44 <lseactuary> ahihi maybe the user types some wrong direction like Z?
02:59:47 <ertes> p == E || W  -- type error
03:00:07 <ahihi> lseactuary: Z is not a constructor of CompassPoint
03:00:09 <ertes> lseactuary: the user can'T type Z
03:00:13 <lseactuary> ok
03:00:26 <ertes> (they can, but there is no way to pass "Z" to move1)
03:00:43 <lseactuary> ic
03:01:13 <ertes> lseactuary: please do the following:  create a new paste, then in your editor select everything from top to bottom and paste it
03:01:17 <lseactuary> oki
03:01:40 <ertes> lseactuary: use your editor's "select everything" feature (usually ctrl-A)
03:02:06 <lseactuary> omg
03:02:09 <lseactuary> i think i know the issue
03:02:10 <lseactuary> 2 min
03:02:25 <lseactuary> in my editor i had kept gaps between those initial lines i made >
03:02:29 <lseactuary> in my editor i had kept gaps between those initial lines i made > ;p
03:02:44 <ertes> those shouldn't matter
03:02:46 <lseactuary> 2 min pasting
03:04:20 <lseactuary> ok now i see the same errors as you guys
03:04:49 <lseactuary> so in (a) i need 4 guards right and cant use or
03:04:56 <ertes> at this point all i see is an incomplete file
03:05:13 <ahihi> lseactuary: you don't need guards at all
03:05:38 <lseactuary> hmm
03:05:44 <gingitsune> Hello, can somone please take a look for whats wrong? http://lpaste.net/362850
03:05:45 <ahihi> just do four equations, e.g. move1 N (x:+y) = ...
03:06:18 <ertes> gingitsune: DayOfweek or DayOfWeek?
03:06:21 <lseactuary> ah
03:06:35 <lseactuary> in 4 lines basically?
03:06:43 <lseactuary> line how to seperate the equations
03:06:47 <ertes> gingitsune: you have to pick one and go with it =)
03:07:21 <ahihi> lseactuary: yes, like you've done in b)
03:07:23 <gingitsune> oboy
03:07:29 <lseactuary> oki 2 mins
03:07:33 <lseactuary> i clean up this code
03:08:07 <gingitsune> ertes: Thanks! :)
03:10:00 <ertes> gingitsune: no worries…  migrants between US-english and british-english find themselves in your situation all the time =)
03:10:27 <lseactuary> 2 mins its compiling now :)
03:13:29 <lseactuary> i am fixing c as its wrong
03:13:32 <lseactuary> then will upload 2 min
03:30:40 <lseactuary> updated
03:30:44 <lseactuary> i think im super close
03:30:48 <lseactuary> cant crack the type issue
03:30:51 <lseactuary> added the bug also
03:32:21 <ahihi> lseactuary: move1 takes two parameters, but on line 39 you've only given it one
03:32:45 <lseactuary> ah
03:32:47 <lseactuary> missing p
03:32:48 <lseactuary> :P
03:32:49 <lseactuary> nice
03:33:39 <lseactuary> ahihi i am writing it properly now right/
03:33:43 <lseactuary> this is correct stnyax?
03:33:58 <lseactuary> i just guess it looked 'long' to me so wasnt sure it was right or if there was a shorter syntax
03:36:06 <ahihi> lseactuary: the logic in c) looks about right, but the type names you're using don't match the ones you've defined earlier
03:36:33 <ahihi> or rather type and constructor names
03:37:03 <lseactuary> ah yes
03:37:05 <lseactuary> sorry edited
03:37:12 <ahihi> lseactuary: also, i don't think move1 is doing the right thing for W and S :P
03:37:21 <lseactuary> aha!
03:37:25 <lseactuary> lemme see :P
03:38:18 <lseactuary> oh its -1 for W/S?
03:38:41 <lseactuary> yes
03:38:42 <ahihi> yeah
03:38:44 <lseactuary> makes sense
03:39:04 <lseactuary> for (d) i just need to do run1 [Forward1] (p,cp) = blah right
03:39:10 <lseactuary> and the other cases
03:39:39 <lseactuary> should basiclly end up with a list of pairs of (p,cp)
03:39:59 <lseactuary> but then cant i do run1 _ (p,cp) =
03:41:03 <ahihi> if you want to write it recursively, i'd start with run1 [] (p,cp) = ... and then run1 (GoForward1:cmds) (p,cp) = ... etc
03:41:23 <ahihi> but you could also use foldl here
03:42:08 <ahihi> actually wait
03:42:30 <ahihi> you don't need to consider the different kinds of commands in run1, since you can use step1 which already does that
03:42:36 <lseactuary> yeah
03:42:50 <lseactuary> run1 [] (p,cp) = ... should work right
03:43:02 <ahihi> for the base case, yeah
03:43:19 <lseactuary> and then run1 _ (p,cp) = ...
03:43:38 <ahihi> for the recursive case you'll want something like run1 (cmd:cmds) (p,cp) = ...
03:44:17 <lseactuary> ah cmd being the data type
03:44:37 <lseactuary> ok trying
03:44:50 <ahihi> cmd is just the name that will be given to the first element of the list
03:44:59 <lseactuary> yup
03:49:07 <lseactuary> ahihi little stuck
03:49:08 <lseactuary> run1 (cmd:cmds) (p,cp) = [step1 cmd] ++ run1 (cmd:cmds) (p,cp)
03:49:15 <lseactuary> the last bit of the recursion is wrong
03:50:50 <ahihi> lseactuary: you're recursing over the same list you started with, which results in infinite recursion
03:51:20 <ahihi> since you've already processed cmd, you'll want to recurse over the tail of the list
03:51:26 <lseactuary> oohh
03:51:37 <ahihi> (also step1 needs another argument)
03:53:00 <lseactuary> run 1 cmds or tail(cmd:cmds)?
03:53:06 <lseactuary> *run1
03:53:17 <lseactuary> ah ye i forgot the (p,cp) in the first part added now
03:54:21 <ahihi> the pattern (cmd:cmds) on the left hand side of the equals sign destructures the list parameter into the head (cmd :: Command1) and tail (cmds :: [Command1])
03:54:27 <ahihi> so you already have the tail of the list in cmds
03:54:42 <lseactuary> hmm but when i applied it to just cmds
03:54:45 <lseactuary> it gives an error
03:54:46 <lseactuary> 2 min
03:55:05 <ahihi> remember that run1 also takes two parameters
03:55:06 <lseactuary> oh
03:55:08 <lseactuary> bracket issue :P
03:55:13 <lseactuary> it compiles :)
03:55:18 <lseactuary> now i can make the pretty picture :P
03:55:22 <ahihi> yay!
03:55:28 <lseactuary>  run1 (cmd:cmds) (p,cp) = [step1 cmd (p,cp)] ++ run1 cmds (p,cp)
03:55:33 <lseactuary> thats what i did
03:55:51 <lseactuary> but i had (cdms) instead
03:55:58 <dminuoso> lseactuary: `[a] ++ b` is an anti pattern
03:56:04 <ahihi> instead of [a] ++ b you can write a:b
03:56:11 <lseactuary> hmm
03:56:16 <lseactuary> how come it didnt throw up an error?
03:56:25 <dminuoso> lseactuary: It's extensionally equivalent.
03:56:33 <dminuoso> lseactuary: But less expressive.
03:56:36 <lseactuary> ah
03:56:50 <dminuoso> lseactuary: A list should not be thought of as a "sequence of things", but rather as a recursive structure.
03:57:06 <dminuoso> A list is "an element appended to a list" | an empty list
03:57:12 <whoman> cons all the way down
03:57:12 <dminuoso> or rather *prepended
03:57:41 <lseactuary> hmm
03:57:50 <lseactuary> like this?
03:57:51 <lseactuary> run1 (cmd:cmds) (p,cp) = [step1 cmd (p,cp)] : run1 cmds (p,cp)
03:57:59 <dminuoso> No.
03:58:01 <lseactuary> or run1 (cmd:cmds) (p,cp) = [step1 cmd (p,cp)] : [run1 cmds (p,cp)]
03:58:02 <whoman> =/
03:58:05 <dminuoso> No.
03:58:07 <dminuoso> :t (:s)
03:58:08 <lambdabot> error:
03:58:09 <lambdabot>     • Couldn't match expected type ‘[a]’ with actual type ‘Expr’
03:58:09 <lambdabot>     • In the second argument of ‘(:)’, namely ‘s’
03:58:09 <dminuoso> :t (:)
03:58:11 <lambdabot> a -> [a] -> [a]
03:58:15 <dminuoso> lseactuary: look at the signature.
03:58:28 <dminuoso> It's basically equivalent to: data List a = Cons a (List a) | Empty
03:58:36 <whoman> at least replace (p,cp) with pcp in all cases, too
03:58:44 <lseactuary> i am confused
03:58:54 <lseactuary> we are making the base case and the recursion in one line
03:58:55 <lseactuary> or
03:59:06 <dminuoso> lseactuary: | means or =)
03:59:06 <lseactuary> we are trying to get rid of ==
03:59:09 <lseactuary> *++
03:59:10 <dminuoso> lseactuary: My point is
03:59:43 <dminuoso> lseactuary: prepending to a list is just (:)
03:59:54 <dminuoso> lseactuary: your pattern matching visualizes this even.
03:59:55 <dminuoso> x:xs
04:00:01 <dminuoso> means "x prepended to xs"
04:00:03 <lseactuary> yes
04:00:37 <dminuoso> lseactuary: maybe its easier if you quickly implemented
04:00:40 <dminuoso> :t amp
04:00:41 <lambdabot> error:
04:00:42 <lambdabot>     • Variable not in scope: amp
04:00:42 <lambdabot>     • Perhaps you meant one of these:
04:00:42 <dminuoso> :t map
04:00:43 <lambdabot> (a -> b) -> [a] -> [b]
04:01:20 <lseactuary> sorry im still not catching something here
04:01:25 <lseactuary> are we discussing the recursion ++
04:01:32 <lseactuary> or are we discussing the base case and the recursio
04:01:35 <whoman> people like to go the extra mile
04:02:02 <lseactuary> or are we discussing cmd:cmds
04:02:03 <dminuoso> lseactuary: What you are trying to implement is just `map`
04:02:09 <dminuoso> lseactuary: so lets reduce the problem.
04:02:20 <lseactuary> before we reduce - what are we discussing?
04:02:24 <lseactuary> run1 function?
04:02:30 <whoman> =/ why do we have to take the guy for a whole tour lol
04:02:35 <dminuoso> lseactuary: Yes.
04:02:40 <lseactuary> ok cool with you now
04:02:41 <dminuoso> lseactuary: Just implement this function:
04:02:48 <dminuoso> map :: (a -> b) -> [a] -> [b]
04:03:19 <lseactuary> ok
04:03:29 <dminuoso> lseactuary: It does exactly what you are trying to do, but with less baggage.
04:03:32 <ahihi> actually, run1 is not supposed to be just map
04:03:53 <dminuoso> ahihi: Well it's map applied to some function.
04:04:04 <dminuoso> so map is the more general case.
04:04:26 <ahihi> no, it's more of a fold
04:04:34 <ahihi> the updated state is supposed to be propagated in the recursion
04:05:03 <lseactuary> so the ++ is correct? i was confused by the : comment. i updated the code btw that compiles.
04:06:11 <dminuoso> ahihi: `run1 (cmd:cmds) (p,cp) = [step1 cmd (p,cp)] ++ run1 cmds (p,cp)` how is that not `fmap (($c) . step1)` assuming `c` represented whatever you passed into (p,cp) ?
04:06:14 <ahihi> lseactuary: try e.g. run1 [GoForward1, GoForward1] (0:+0, N)
04:06:33 <ahihi> dminuoso: the starting implementation is not correct
04:07:40 <lseactuary> *Main> run1 [GoForward1, GoForward1] (0:+0, N) [(0.0 :+ 1.0,N),(0.0 :+ 1.0,N)]
04:08:00 <dminuoso> ahihi: Oh. Well my point was just that the concrete function he supplied was just an application of fmap.
04:08:08 <dminuoso> Didnt relaize he was trying to do something else entirely
04:08:25 <ahihi> lseactuary: you'll notice that the two states are identical, whereas the second one should be (0:+2, N)
04:08:33 <lseactuary> right
04:09:22 <dminuoso> lseactuary: [1,2,3] is just sugar for 1:(2:(3:([]))). So the way to "prepend" something, say `a` to a list called `l` is just a:l. That's what the remark was all about.
04:09:24 <ahihi> so instead of passing (p,cp) to the recursive call, you'll want to pass the new state produced by step1
04:09:39 <lseactuary> aha
04:10:57 <lseactuary> updated
04:11:00 <lseactuary> and cross checked
04:11:33 <lseactuary> :)
04:11:51 <ahihi> the result should be correct now, but you're needlessly calling step1 with the same arguments twice
04:13:05 <ahihi> consider using a "where" clause to give a name to the result of calling step1, and using that in the function body
04:13:57 <lseactuary> oki
04:15:32 <lseactuary> nice
04:15:34 <lseactuary> updated
04:16:03 <pjan> Does anybody know about a project scaffolding alternative similar to what "stack new" is?
04:16:23 <ahihi> lseactuary: and then finally you can change "[x] ++" to "x :" :)
04:16:27 <lseactuary> :P
04:16:45 <cocreature> pjan: why don’t you just use stack new?
04:17:00 <lyxia> "cp"
04:17:46 <lseactuary> many thanks for the help!
04:17:51 <pjan> because I don't use stack
04:18:07 <lseactuary> lunchtime then picture time :)
04:19:41 <cocreature> pjan: there is https://github.com/fujimura/hi
04:22:48 <dminuoso> cocreature: By the way, I have not been able to figure out what breaks my program. On every compiler before 8.2 it creeps down into halting. Im wondering whether this could be some strictness analyzer bug
04:23:18 <dminuoso> Im gonna make a repo soon, because my program is too trivial to be likely to trigger compiler bugs.
04:23:28 <cocreature> dminuoso: did you manage to figure out why it worked before you enabled profiling?
04:23:50 <dminuoso> cocreature: No. At this point I suspect I _did_ make a change that I cant remember.
04:23:58 <dminuoso> But it's still odd as heck that with profiling enabled it still runs on every compiler.
04:24:07 <dminuoso> Even tried a reboot because.. macOS.
04:24:24 <cocreature> dminuoso: have you tried compiling without optimizations?
04:24:44 <dminuoso> cocreature: Ive been using default flags. Should I specify some O0 ?
04:24:56 <cocreature> dminuoso: iirc stack defaults to O1
04:25:03 <cocreature> and cabal does as well
04:25:12 <dminuoso> Let me see if I can make stack verbose to see what its built with
04:25:21 <pjan> cocreature: yeah, I knew about that one, but would love to have a stack-like alternative where you can have self-defined template variables.
04:25:43 <cocreature> "stack build --fast" uses -O0 but iirc you need to "stack clean" before since changing the optimization level doesn’t trigger a rebuild
04:25:43 <hask_bee_3> After upgrading to Nix 2, "stack build" on my Nix-enabled Haskell/Stack project fails:
04:25:43 <hask_bee_3> dyld: Library not loaded: /nix/store/6a9fr14xc9yr4xwlkyaf4zzqmbh3xngy-gmp-6.1.2/lib/libgmp.10.dylib
04:25:44 <hask_bee_3> Referenced from: /Users/haskbee3/.stack/setup-exe-cache/x86_64-osx-nix/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2
04:25:44 <hask_bee_3> Reason: image not found
04:25:46 <hask_bee_3> Ideas?
04:28:09 <pjan> (why not stack: I use nix/cabal for dev & release work. Having stack only for the stack new feature of it would be fine if it only wouldn't create that stack.yaml file, which interact with developer tools)
04:29:06 <cocreature> pjan: tbh since creating new projects is usually not something you do particularly often, `stack new` followed by an `rm stack.yaml` might be the best solution
04:29:19 <pjan> hask_bee_3 any particular reason why you still use stack when you already use nix, and not just nix+cabal?
04:29:20 <cocreature> wrap it up in a bashscript or whatever if you don’t want to type two commands
04:30:03 <pjan> cocreature: yeah, that's probably what I'll resort to if nothing else
04:31:07 <hask_bee_3> pjan here are some thoughts on that (not mine): https://www.tweag.io/posts/2015-12-09-stack-nix.html
04:31:15 <hask_bee_3> it looks like it simplifies things
04:31:25 <hask_bee_3> (it = using stack)
04:39:10 <pjan> hask_bee_3 the author of that article worked on the stack nix feature, so definitely not unbiased I would say
04:39:58 <dminuoso> What does the `=>` mean in this? instance (ListConcat as bs cs) => ListConcat (Cons a as) bs (Cons a cs)
04:41:24 <pjan> hask_bee_3 just using nix + cabal gives you all benefits of nix (global cache of dependencies, so if you put a lot of the haskell dependencies (up to date) in your local nix cache, you can do your dev work completely offline (including adding new dependencies to your project, and still continue)
04:41:57 <cocreature> dminuoso: it’s a “precondition” for the instance. so in the implementation of the instance "ListConcat (Cons a as) bs (Cons a cs)" you can make use of the instance "ListConcat as bs cs"
04:43:37 <dminuoso> cocreature: Ohh. It's just a regular constraint I see.
04:43:48 <dminuoso> cocreature: I got carried away by the deep humor of this article.
04:44:23 <dminuoso> :k Num
04:44:24 <lambdabot> * -> Constraint
04:46:23 <dminuoso> cocreature: Ah we're getting somewhere. With optimizations turned off it runs just fine. :)
04:46:37 <cocreature> dminuoso: do you have the code online somewhere?
04:47:01 <cocreature> dminuoso: I mean it could just be a bug in your code that only gets triggered in some cases :)
04:49:40 <hask_bee_3> pjan Isn't stack just built on top of cabal anyway, and your point is that since cabal + nix gives us all the benefits of stack, we might as well cut out stack?
04:50:12 <cocreature> hask_bee_3: stack is built on top of Cabal the library not on top of cabal-install (which provides the cabal binary)
04:53:51 <pjan> hask_bee_3 more or less. nix will put all the required haskell dependencies on the path of your nix-shell, and cabal can do all the building etc stack does
04:58:15 <dminuoso> cocreature: Voila! I found it.
04:58:15 <hask_bee_3> pjan does nix provide a curated, known to be conflict-free, set of haskell packages in a similar way that stack does?
04:58:30 <dminuoso> cocreature: And it seems to have been a strictness analyzer bug indeed.
04:58:57 <dminuoso> cocreature: Ill share the code regardless if you are still interested.
04:59:06 <cocreature> dminuoso: sure
04:59:14 <hask_bee_3> pjan (a benefit is that you don't have to specify haskell package version in your cabal file. it'll just take what's in the stack resolver)
05:00:20 <cheater> dminuoso: thanks
05:01:28 <cheater> EvanR: can you tell me more about the term structure of your language? what is it?
05:02:29 <cheater> Eduard_Munteanu: i'm fine with making the language total. in fact primitive recursive.
05:02:29 <dminuoso> cocreature: https://github.com/dminuoso/game-of-life  -- The latest commit was the flaw.
05:02:40 <dminuoso> cocreature: Or rather it fixed it. :)
05:03:21 <cheater> EvanR: what does this mean? EvanR > ah without pi, you still have A -> Type families
05:03:46 <cheater> Eduard_Munteanu: what does f n = Int -> f n mean?
05:04:09 <cocreature> dminuoso: that doesn’t look like a strictness analyzer bug? more like a missed opportunity where it might have had the possibility to make something strict but didn’t
05:04:50 <dminuoso> cocreature: Mmm. Well in O0 it worked just fine.
05:05:34 <cocreature> dminuoso: sure there might be a bug, but I don’t think the strictness analyzer is the one to blame here or at least I don’t see why that should be more likely than anything else
05:05:51 <dminuoso> cocreature: Fair enough.
05:08:04 <cocreature> dminuoso: also for me it doesn’t hang completely. it’s just really slow
05:10:34 <dminuoso> cocreature: Like I said, it becomes slower into effectively halting.
05:11:01 <dminuoso> cocreature: Lets assume for a second I didnt know where the problem was, how could I debug this?
05:11:11 <dminuoso> I mean with the profiler it didnt trigger
05:12:04 <cocreature> dminuoso: hard to say, if you build with DWARF debug info (requires a special GHC build) then you can send SIGUSR2 to the process to get a stacktrace
05:12:51 <cocreature> dminuoso: for a code sample of this size, looking at the core is also reasonable but that tends to scale fairly badly
05:13:16 <cocreature> dminuoso: enabling and disabling optimizations (first -O levels and then individual optimizations) for specific modules can help narrow things down
06:09:56 <cppxor2arr> Made an offline version of "Learn You a Haskell for Great Good": http://s000.tinyupload.com/index.php?file_id=02072341883744790357
06:10:11 <cppxor2arr> "chapters" is the first page
06:16:46 <concaveirc> Hey all, I am following this tutorial: https://wiki.haskell.org/Implement_a_chat_server
06:17:15 <concaveirc> and am wondering why in section 3 a handler (I am not entirely sure what that is) is used.
06:17:50 <concaveirc> Looking at the haddock documentation for Network.Socket.ByteString, recv requires a number for a buffer size.
06:18:09 <concaveirc> How does using a handler avoid needing to specify a buffer size?
06:23:00 <EvanR> concaveirc: a handle?
06:24:01 <concaveirc> EvanR I do not know what a handle is either. Would that be the buffer size in this case?
06:24:25 <EvanR> just trying to understand what youre asking, also i dont understand section 3 either
06:25:07 <EvanR> concaveirc: recv takes the number of bytes to receive
06:25:54 <EvanR> its not a buffer size
06:25:56 <concaveirc> Basically, section 3 says to use handlers to 'keep things simple', and later at the end of section 5 it uses a handler to get a line that is recieved.
06:26:05 <EvanR> i dont see where it says that
06:26:15 <EvanR> thats why i am asking you for clarification
06:26:27 <Lycurgus> by ancient OS practice (unix) a handle is a unique integer binding a system process, e.g. a fs to a process
06:26:27 <bash0r> Has anybody ever had an issue with GHC 8.2.2 stating that the compiled program is unable to commit 1048576 bytes of memory?
06:26:28 <concaveirc> I got my terms messed up then.
06:26:39 <EvanR> it doesnt say handler anywhere
06:27:08 <concaveirc> However, how does using a handler allow me to not need to specify the amount of bytes received?
06:27:17 <dminuoso> concaveirc: a handle is just some descriptor for a resource. You can think of it as a rich pointer if you want.
06:27:52 <EvanR> concaveirc: the section is not using receive... its using send (putStrLn)
06:27:56 <concaveirc> Well, I guess that is another term I got wrong. hdl is for handle, not Handler.
06:28:35 <initiumdoeslinux> Hey, I was wondering how I can catch the decoding error that readFile throws when I try to read binary files. Here's a snippet from the source: http://lpaste.net/362859
06:28:42 <EvanR> it uses the length of the string to determined how much to send
06:28:58 <concaveirc> EvanR: What does hGetLine hdl do, then?
06:29:03 <EvanR> if you were receiving, you would have to specify a number of bytes
06:29:21 <EvanR> concaveirc: what section are you reading ?
06:29:23 <concaveirc> dminuoso: Alright.
06:29:39 <concaveirc> EvanR: I am looking at the end of section 5.
06:29:46 <dminuoso> concaveirc: For example if you `openFile` you get an IO Handle back. If you want to somehow interact with that file, you do it through that handle.
06:29:51 <EvanR> hGetLine reads until it finds a newline
06:30:01 <dminuoso> concaveirc: https://hackage.haskell.org/package/base-4.10.1.0/docs/System-IO.html#t:Handle
06:30:03 <EvanR> which could be never, so then youd run out of memory
06:30:38 <dminuoso> concaveirc: So it's something "file like" if you want.
06:30:55 <dminuoso> File, pipe, socket..
06:30:57 <concaveirc> EvanR: So if I could do this with recv, should I? and if yes, can fetching until a newline be done easily using recv?
06:31:06 <EvanR> no it cant
06:31:19 <EvanR> you would need to keep your own buffer and look for newlines
06:31:27 <EvanR> then remember the rest for later
06:31:44 <concaveirc> EvanR: I guess the line about keeping things simple was a practical suggestion then. Alright.
06:31:46 <EvanR> sorry im just trying to answer your actual questions, rather than explain IO stuff at random
06:33:01 <concaveirc> EvanR: You did answer my question though, or at least I think so. I am just not good at asking concise questions yet.
06:33:53 <EvanR> Handle is the usual way you deal with files, IO streams, sockets
06:34:23 <EvanR> it just happens that you get Socket from Network.Socket first, though youll see that you get Handle from Network
06:35:23 <concaveirc> EvanR: Good, I was looking into recv and send because I was suspicious that 'keep things simple' was tutorial speak for 'there is a better way, but we do not want to overload you with information'. Handle it is.
06:35:30 <EvanR> they act much the same, but Socket gives you access to network related metadata
06:36:16 <concaveirc> EvanR: So to get the IP and channel of a sender, I would use Socket?
06:36:23 <EvanR> well, yeah this is the simple way but not the best way
06:36:48 <EvanR> for a connected socket, you get the IP when they connect
06:36:56 <EvanR> theres no channel
06:36:57 <concaveirc> Would the best way be to make my own buffer of a limited size and then find a newline?
06:37:20 <concaveirc> I mispoke again. I meant port.
06:37:25 <EvanR> something like that, but with an abstraction of some sort
06:37:54 <concaveirc> EvanR: Does that abstraction already exist in some standard manner?
06:37:57 <EvanR> and thats possibly where the tutorial doesnt want to go
06:38:07 <EvanR> yeah
06:38:35 <EvanR> pipes and conduit are popular for dealing with this IO streaming stuff
06:38:53 <EvanR> and there are otherss
06:39:54 <concaveirc> EvanR: Thanks. I think I will get back to actually trying to implement a chat server/client now.
06:45:05 <mjrosenb> Is there a function in Map that will take a predicate over values, and split the map into a single (k,v) pair, and the rest of the map?
06:45:59 <EvanR> what happens if it finds more than one v, or none
06:46:37 <mjrosenb> presumably, it returns a Maybe ((k,v), Map k v)?
06:47:01 <mjrosenb> if it finds more than one, I don't care which one it chooses, as long as it chooses one.
06:47:24 <lyxia> How do I submit a patch to base? Is this guide still up to date https://wiki.haskell.org/Library_submissions#Guide_to_proposers
06:49:01 <EvanR> it looks like Data.Map has no way to search backwards at all, youll have to traverse it with one of the traverse functions
06:49:42 <mjrosenb> but then I basically have to reconstruct the structure of the map afterwards, which will be (relatively) slow.
06:49:59 <mjrosenb> I guess I'll use find and remove.
06:50:20 <EvanR> find on the toList ?
06:50:24 <initiumdoeslinux> How do I handle hGetContents: invalid argument (invalid byte sequence)?
06:50:46 <initiumdoeslinux> I want to gracefully skip files where that is the case
06:50:48 <mjrosenb> I could probably also partition it, then remove the one that I care about from the correct partition, then union the two maps
06:51:06 <mjrosenb> but I suspect that will be slower than just removing it.
06:52:25 <EvanR> sure, just delete it when you find it. i was just looking for a slick way to do the find
06:52:52 <EvanR> a right fold, yeah thats the ticket
06:56:15 <EvanR> :t foldrWithKey
06:56:16 <lambdabot> error:
06:56:16 <lambdabot>     • Variable not in scope: foldrWithKey
06:56:16 <lambdabot>     • Perhaps you meant one of these:
06:57:36 <EvanR> foldrWithKey (\k v z -> if p v then Just (k,v) else z) Nothing
06:58:19 <initiumdoeslinux> Man I really don't understand Haskell exceptions
06:58:38 <Wizek> Hello. Is it possible perhaps with lens to have a function that is able to `[(a,b,c)] -> ([a],[b],[c])`?
07:00:46 <Tuplanolla> :t unzip3 -- Why lens, Wizek?
07:00:47 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
07:01:44 <EvanR> what if it was [record with three fields]
07:02:27 <Wizek> Tuplanolla: because I'd like if it was able to process arbitrary n-tuples and perhaps even arbitrary lists of records as well, and was guessing for that kind of polymorphism I'll need to reach as far as lens.
07:02:49 <Tuplanolla> Well, in that case...
07:03:39 <EvanR> naperian functors
07:04:01 <EvanR> AOL keyword
07:10:44 <Wizek> Tuplanolla: Have you begun type-golfing with lens? :)
07:11:02 <Tuplanolla> I do it sometimes.
07:11:32 <Wizek> Tuplanolla: I mean since you typed "Well, in that case..."
07:12:00 <Tuplanolla> I spent a few minutes thinking about it, but nothing came out of it.
07:12:19 <Wizek> Yeah, I'm also unsure how to go about it.
07:14:31 <Wizek> In a naiive attempt, I've tried sequenceA, but there seem to be some weird instances at play for tuples for that. I have a hunch that maybe if I reach even further to Generics then I would be able to treat the type inside the list as a generic pruduct type, and maybe that way it could be possible.
07:15:39 <Tuplanolla> There's `sequenceOf` that could be useful.
07:17:10 <Wizek> checking
07:19:40 <EvanR> transpose :: (Naperian f , Naperian g) => f (g a) -> g (f a)
07:19:41 <EvanR> heh
07:20:21 <EvanR> but theres different payload types involved
07:22:46 <mdim> Hi everyone. If I have an ADT that derives Read, how would I handle invalid inputs provided to the read function (or similar)?
07:23:21 <cocreature> :t readMaybe
07:23:22 <lambdabot> error: Variable not in scope: readMaybe
07:23:35 <cocreature> mdim: https://hackage.haskell.org/package/base-4.10.1.0/docs/Text-Read.html#v:readMaybe
07:24:14 <cocreature> mdim: although for anything non-trivial you usually want to build a proper parser using something like megaparsec so you can get decent error messages
07:24:51 <mdim> I'm barely learning Haskell myself and I'm also teaching it to teenagers so something simple is preferred here
07:24:58 <mdim> ... if not simplistic
07:25:33 <Wizek> EvanR: Oh, you mean that as a response to me? I'm looking into that now
07:26:11 <EvanR> yeah i just noticed its not general enough for contains that have different types in different layers
07:26:15 <EvanR> containers
07:26:39 <Wizek> EvanR: looks like it
07:27:11 <mdim> thanks, cocreature. That's what I was looking for.
07:27:24 * EvanR tries to invent an extension
07:28:21 <mdim> cocreature: for some reason this function didn't show up on the first page of search results on Hoogle when searching for: Read a => String -> Maybe a
07:29:11 <EvanR> i found it on hayoo
07:31:23 <cocreature> mdim: http://hoogle.haskell.org/?hoogle=Read%20a%20%3D%3E%20String%20-%3E%20Maybe%20a
07:32:09 <mdim> cocreature: hm, I was searching here: https://www.haskell.org/hoogle/?hoogle=Read+a+%3D%3E+String+-%3E+Maybe+a
07:32:48 <mdim> why do we get different results for the same query?
07:32:58 <cocreature> mdim: haskell.org/hoogle is hoogle 4, hoogle.haskell.org is hoogle 5
07:33:31 <cocreature> the latter has worse typesearch in some cases but it indexes vastly more packages and is regularly updated
07:35:13 <mdim> I see. Thanks for this
07:45:43 <Wizek> Next question, somewhat similar: Anyone knows of a polymorphic function that can do `(a -> b, a -> c) -> a -> (b, c)` and `(a -> b, a -> c, a -> d) -> a -> (b, c, d)`?
07:47:18 <Wizek> I know I can do `((,,) <$> foo <*> bar <*> qux) baz`, wondering if I could do `(foo, bar, qux) `fn` baz`
07:50:49 <metahumor> you mean work both on 2-ple and 3-ple?
07:52:37 <Wizek> metahumor: yes, and hopefully also `do { n <- [4..]; return $ show n <> "-tuple" }`s too.
07:53:08 <metahumor> not to my knowledge. someone would probably suggest using lists instead
07:53:49 <metahumor> you want "n-ary Functor"
07:53:50 <Wizek> metahumor: need to be able to have different types for the items
07:53:59 <cocreature> hlist :)
07:54:38 <Tuplanolla> Man reinvents Scheme.
07:55:05 <Lycurgus> CACM has an article this month that amounts to that
07:55:29 <Lycurgus> (3/2018)
07:56:25 <Wizek> cocreature: perhaps that could be a way.
07:56:31 <Wizek> Lycurgus: CACM?
07:56:58 <cocreature> Wizek: you can’t really do anything that’s generic in the size of the tuple since tuples are not inductively defined
07:57:51 <Lycurgus> Wizek, communication of the ACM; 'programmable programming languages' which when I saw the title i though that's lisp
07:58:08 <Wizek> cocreature: tell that to the lens `over each`
07:58:27 <Wizek> > over each (+22) (1,2,3,4)
07:58:29 <lambdabot>  (23,24,25,26)
07:58:35 <kuribas> Wizek: they have to have the same type
07:58:49 <cocreature> Wizek: well that’s just a typeclass with instances for a few hardcoded tuple sizes
07:59:07 <metahumor> > over each ($ 2) (\x -> x + 1, \x -> "hello")
07:59:10 <lambdabot>  error:
07:59:10 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘2’
07:59:10 <lambdabot>      • In the second argument of ‘($)’, namely ‘2’
07:59:16 <kuribas> Wizek: also, they just have an instance for many sized tuples, it's not inductively defined.
07:59:25 <metahumor> > over each ($ 'c') (\x -> ord x, \x -> "hello")
07:59:27 <lambdabot>  error:
07:59:28 <lambdabot>      • Couldn't match type ‘Int’ with ‘[Char]’
07:59:28 <lambdabot>          arising from a use of ‘each’
07:59:41 <metahumor> see, can't do it for different types
07:59:53 <Wizek> cocreature: I think I can live with that if that's hidden under the hood in a library/module that I import
08:00:19 <metahumor> Wizek: you can use bimap from Bifunctor for (,)
08:00:39 <metahumor> and write a trimap
08:01:26 <kuribas> Wizek: what would the benefit be over <$> and <*> ?
08:02:27 <Wizek> kuribas: succinctness, easier to see at a glance what I am trying to do without clutter. A need for such a function pops up for me every now and again.
08:03:22 <kuribas> Wizek: you can't be more succint than liftA<n>
08:04:54 <kuribas> As to 2), you get used to it.
08:05:56 <concaveirc> Working through the official Pipes tutorial, is it normal for it to remind me of FRP, specifically Reactive Banana?
08:06:00 <Wizek> kuribas: I'm not quite sure about your first point. Maybe I'll try to implement something. But at least the answers here tell me that there isn't a widely used such function that I just haven't heard of yet.
08:06:28 <concaveirc> It seems like runEffect is similar to reactimate, and things like yield are sort of like a Behavior or Event.
08:07:15 <PeterEU> Hi all! Is anyone familiar with SBV/Z3 in Haskell?
08:07:16 <Wizek> kuribas: about (2), sure, I've been getting used to it for years now, and it's not horrible, I just want to see if I could simplify it further.
08:07:19 <concaveirc> Which makes sense, because both deal with streams. Now I am half-jokingly wondering if Pipes can be used as an FRP library.
08:07:43 <cocreature> PeterEU: you’re going to get better answers if you just ask your actual question :)
08:08:01 <PeterEU> I would like to define constraints on Pairs of Ints.
08:08:15 <kuribas> Wizek: it's so much more elegant when compared to scala.
08:08:22 <PeterEU> I know how I can do constraints on Ints
08:08:43 <kuribas> Wizek: where you haved to use some complicated opaque builder to get the same result.
08:10:05 <Wizek> kuribas: I wouldn't know about that. Scala seemed inelegant enough from a distance when I was deciding between learning about Hs vs Scala that I didn't quite find out how inelegant it can get :)
08:10:31 <kuribas> Wizek: really inelegant, trust me :)
08:10:35 <PeterEU> Is there a "Symbolic" pair in the haskell SBV package? Like "(Int, Int) -> Symbolic (Int, Int)
08:11:35 <Lycurgus> sounds scabrous don't it? dumb java bitches
08:11:44 <PeterEU> I just found that there are Symbolic Lists (either I find a Pair or I use a list of two elements for a pair...)
08:13:34 <cocreature> PeterEU: can’t you just use the Provable instance for regular Haskell tuples?
08:13:55 <cocreature> PeterEU: e.g. "sat (\(a,b) -> a .< (b :: SInteger))" works just fine
08:19:38 <PeterEU> cocreature: Thank you for this pointer!
08:19:49 <EvanR> concaveirc: i would take issue with the idea of FRP being about streams
08:20:02 <EvanR> but that ship probably sailed
08:20:21 <PeterEU> cocreature: Can I define a smaller relation on points (= Pair of Ints)?
08:21:39 <PeterEU> cocreature: do I have to treat "x" and "y" of every point as two seperatre variables
08:22:23 <PeterEU> (I think I need more into this.)
08:22:54 <cocreature> PeterEU: I’m not quite sure what you are asking (I’m not super familiar with sbv), could you give an example of what you are trying to do?
08:23:21 <PeterEU> I think I might need " (SymWord a, SymWord b, Provable p) => Provable ((SBV a, SBV b) -> p)"
08:23:58 <PeterEU> I am defining layouts in a GUI via constraints. I boils down to rectangles (Pair of Points) and Points (Pair of Ints)
08:24:34 <PeterEU> I need to define a constraint (simplfied case): This rectangle (= ((Int, Int), (Int,Int) of corners) is within
08:24:44 <PeterEU> the bounds of some other rectangle
08:24:59 <PeterEU> and define a constraint for this, that gives back "yes" or "no"
08:25:20 <concaveirc> EvanR: Would the issue involve Events?
08:25:31 <cocreature> PeterEU: so what’s the problem with the approach I just showed you?
08:28:34 <EvanR> concaveirc: a stream has the structure, you can breakdown any stream into the head, one item, and the rest of the stream
08:29:07 <EvanR> a behavior is a time varying value, you at least need time somewhere
08:29:36 <EvanR> and if an event is some sort of stream, you at least need the time of the occurrences somewhere
08:30:24 <PeterEU> cocreature: I didn't fully get it. Can I define my own "structures" like Pairs or so in SBV?
08:30:37 <PeterEU> The example you gave is a constraint on Integers only.
08:30:49 <concaveirc> EvanR: In other words, a stream means that I would need some notion of a log of values, which is potentially expensive, and a Behavior does not require a log, but simply a time and value?
08:30:57 <EvanR> no
08:31:06 <PeterEU> It's a function from pairs to Integer-Constraints
08:31:27 <EvanR> my characterization of streams had nothing to do with particular implementation details
08:31:36 <PeterEU> It does work probably
08:32:03 <EvanR> heres one, cycle [1,2,3]
08:32:50 <EvanR> thats missing any notion of time
08:33:19 <concaveirc> EvanR: Ok.
08:33:34 <PeterEU> cocreature: I guess the problem is that I would like to use Variables in SBV
08:33:54 <PeterEU> that also correspond to the structure that I use (which is points/rectangles)
08:34:19 <concaveirc> EvanR: However, does time need to be explicit? Can things be done in terms of when other things happen, such as if 3 was yielded ten seconds after 2, and all dependent values updated, would that be FRP?
08:34:23 <cocreature> PeterEU: you can just define your predicate as a function, e.g. http://lpaste.net/362861 and then use "sat (\point1 point2 -> pairLt point1 point2)"
08:34:58 <cocreature> PeterEU: or if you have your own type, just provide the necessary instances. they’ll probably be quite similar to the ones for tuples
08:36:01 <conal> concaveirc: the two founding properties of FRP (precise denotation and continuous time): https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525
08:37:38 <PeterEU> cocreature: Thank you so much for this! This solves all my problems...
08:37:59 <concaveirc> Ok, the part about continuous time is clear now. Thanks.
08:38:14 <cocreature> PeterEU: great :)
08:38:37 <concaveirc> Or clear enough to convince myself to do more reading before
08:38:58 <concaveirc> getting an actually clear picture.
08:40:39 <PeterEU> Regarding FRP, make sure to also perhaps checkout this paper:
08:40:40 <PeterEU> http://types2017.elte.hu/proc.pdf#page=47
08:45:48 <romildo> How would the following function be defined without an explicit pattern matching?
08:45:49 <romildo>   f Nothing = g Nothing
08:45:49 <romildo>   f (Just x) = liftL (\k -> g (Just k)) x
08:47:42 <cocreature> romildo: what’s liftL?
08:49:27 <EvanR> any function from a Maybe can be defined using the Maybe eliminator... maybe
08:49:29 <EvanR> :t maybe
08:49:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:50:03 <EvanR> as a last resort
08:50:32 <romildo> cocreature, liftL is defined at http://hackage.haskell.org/package/HaTeX-3.18.0.0/docs/Text-LaTeX-Base-Class.html
08:52:44 <cocreature> I don’t think there is really a nice way to avoid a pattern match here (`maybe` is not really any different from a pattern match)
08:53:22 <[Leary]> You can atleast remove the lambda though.
08:53:25 <EvanR> yeah if f Nothing were Nothing, you could at least use fmap but its not
08:54:11 <romildo> But   f Nothing   is    g Nothing
08:54:43 <EvanR> maybe (g Nothing) (liftL (g . Just))
09:03:16 * [exa] discovers HaTeX
09:03:38 * [exa] rejoices
09:05:25 <Lycurgus> don't count ur chickens
09:10:25 <whoman> ehe
09:13:23 <lijero> how did I not know about HaTeX until just now?
09:20:51 <EvanR> bpd21144
09:20:56 <EvanR> uhg
09:24:30 <Adluc> [exa]: w00t, LaTeX written non-retardly
09:25:09 <Tuplanolla> Can you really escape the trouble that easily, Adluc?
09:26:10 <Tuplanolla> I doubt that more than flat Earth.
09:26:41 <Adluc> Tuplanolla: I quite like it :D https://github.com/Daniel-Diaz/HaTeX/blob/master/Examples/simple.hs , generated stuff, last time I was generating latex by concatenating strings
09:26:43 <tsahyt> is there an empty functor in a library somewhere? data Empty a = Empty should have a trivial Functor instance I think
09:26:58 <EvanR> thats Const a
09:27:32 <EvanR> @src Const
09:27:33 <lambdabot> Source not found. Where did you learn to type?
09:27:51 <EvanR> maybe not
09:28:02 <kril> test
09:28:08 <tsahyt> EvanR: but Const looks different, that'd be data Const a b = Const a
09:28:18 <EvanR> yes im dumb
09:28:39 <kril> hey, do we also have a haskell discord?
09:28:51 <hpc> EvanR: the @src database isn't complete or accurate ;)
09:29:08 <lyxia> tsahyt: GHC.Generics.U1
09:29:42 <tsahyt> that looks good, thanks
09:29:55 <tsahyt> perhaps not the most intuitive name, but that's okay
09:30:20 <Tuplanolla> That's `Proxy`, no?
09:30:36 <tsahyt> oh right, Proxy has a functor instance
09:31:03 <lyxia> aha
09:31:13 <cheers> https://u.teknik.io/ZEk7Y.jpeg
09:31:19 <cheers> tsahyt: oh hello
09:31:26 <tsahyt> oh hi cheers
09:33:07 <tsahyt> just in case I'm embarking on something stupid, my use case here is that I need two versions of a record, one with some fields "disabled", so I thought I'd parameterize it with a functor, instantiate that with Identity in one case and with Proxy in the other.
09:33:28 <tsahyt> alternatively I could of course just spell out the record definition twice, but that seems like a bit of a waste
09:35:47 <kuribas> tsahyt: https://hackage.haskell.org/package/rank2classes
09:37:31 <tathougies> is there any way to make lenses for an associated data type?
09:38:19 <kuribas> tathougies: what's an associated data type?
09:38:23 <tsahyt> kuribas: hm, interesting. what would be the use case for this package?
09:38:43 <tathougies> `class MyClass a where { data T a :: * }`
09:39:04 <kuribas> tsahyt: myStruct f = {field1 :: f Int; field2 f String}, then you can map over f
09:39:16 <tathougies> Then `instance MyClass Int where { data T Int = IntCon { _field1 :: Field, _field2 :: Field } }`
09:40:28 <kuribas> tathougies: you mean with TH?
09:40:33 <kuribas> tathougies: or in general?
09:40:51 <tsahyt> kuribas: oh that's quite nifty
09:40:58 <tsahyt> I might even need this here
09:41:05 <hexagoxel> tsahyt: also, somewhat related: https://hackage.haskell.org/package/czipwith-1.0.0.0/docs/Data-CZipWith.html
09:41:52 <kuribas> tsahyt: I believe generic doesn't work with rank2, that's why there's TH included.
09:42:00 <hexagoxel> which has a different rank2 distributive
09:42:21 <tathougies> kuribas: I would like to use TH… I can already write them by han
09:42:24 <tathougies> by hand*
09:42:43 <tathougies> I just have a lot of them, and thought it would be useful to save myself some time
09:43:13 <lyxia> I'm sure Generics do work with Rank2
09:43:17 <kuribas> tathougies: I don't know then... Doesn't makeLenses ''T Int work?
09:43:23 <tathougies> No
09:43:47 <glguy> To make lenses for a data family instance use the name of one of the data constructors
09:44:01 <tathougies> tsahyt lyxia: generics absolutely work for Rank2, for some definition of 'works'.
09:44:18 <tathougies> I use it quite extensively in https://github.com/tathougies/beam
09:45:45 <tathougies> glguy: okay that works for lenses… now what about prisms ;D
09:51:00 <Eduard_Munteanu> That might not work well with an open type like data families.
09:54:48 <kuribas> tathougies: would it be possible to derive rank2 Functor, etc.. with generics?
09:55:36 <humanoyd> what is the difference between a prism and an affine traversal?
09:56:18 <tathougies> kuribas: what do you mean by rank-2 functor?
09:57:33 <kuribas> tathougies: Functor with map :: (f a -> g a) -> s f -> s g
09:58:03 <tathougies> you mean Funtor with map :: (forall a. f a -> g a) -> s f -> s g
09:58:13 <kuribas> yeah :)
09:58:15 <tathougies> yeah… I do that in beam (https://github.com/tathougies/beam/blob/master/beam-core/Database/Beam/Schema/Tables.hs)
09:58:22 <tathougies> https://github.com/tathougies/beam/blob/master/beam-core/Database/Beam/Schema/Tables.hs#L521
09:58:35 <tathougies> There's also a hackage package by a different author: https://hackage.haskell.org/package/flay-0.2
09:58:56 <tathougies> Although beam's are strictly more general than the ones in that package
10:00:00 <tathougies> The trick here is that if you use generics to implement a default method on a class, then ghc will actually figure out how to existentially quantify over f and g. Otherwise, you have to provide explicit type instantiations… If that makes any sense
10:07:07 <zbs> hello everyone. quick question about hoogle. is the cli supposed to provide function descriptions in the search results?
10:07:15 <zbs> it only shows function signatures as far as i can tell
10:10:46 <zbs> hello?
10:13:43 <reactormonk> Try --help, there's a few more switched IIRC
10:34:55 * zbs is testing
10:37:36 <t7> is there a stack check command like cargo check
10:37:46 <t7> (just typecheck the code as quick as possible)
10:40:10 <yushyin> maybe ghc’s -fno-code?
10:52:58 <jimmmy> hey guys, I'm currently writing a preorder, postorder and inorder traversal for a binary tree
10:53:10 <jimmmy> using the type Traversal (Tree a) (Tree b) a b
10:53:30 <jimmmy> I've written the inorder traversal in applicative style
10:54:07 <jimmmy> but I'm really lost as how to go about the preorder or postorder traversal. In particular how to rebuild the tree
10:54:51 <jimmmy> I can share a pastebin if anybody is willing to point me in the right direction
10:58:14 <cocreature> jimmmy: showing the code definitely makes it more likely for someone to try and help you :)
10:59:44 <ReinH> I’d say that showing your work is a prerequisite for getting help. :)
10:59:55 <jimmmy> https://pastebin.com/v85mYg8P
10:59:58 <jimmmy> hahah apologies guys
11:00:47 <zbs_> quick question about hoogle. is there any way to get it to show descriptions of functions instead of just function signatures?
11:01:26 <ReinH> ApplicativeDo would make this easy.
11:01:56 <jimmmy> ReinH: I was thinking of that.
11:02:15 <sm> zbs_: that requires comments in a special format (haddock) added to the code
11:02:25 <ReinH> Otherwise you can use a helper combinator that swaps things around.
11:02:33 <cocreature> jimmmy: what is LeftT supposed to be?
11:02:59 <cocreature> should that be a lowercase leftT?
11:03:04 <cocreature> and same for RightT
11:03:14 <jimmmy> cocreature: supposed to represent the remaining left tree
11:03:19 <ReinH> iiuc the main issue here is getting the applicative actions sequenced in the right order?
11:03:26 <jimmmy> yes, apologies guys
11:03:31 <jimmmy> meant to be lowercase :(
11:03:45 <jimmmy> its not a constructor
11:04:08 <zbs_> sm_: but for standard functions (e.g. nub), it doesn't show a comment in the cli. whereas if i search for it on the hoogle web interface, it shows comments.
11:04:25 <sm> zbs_: ah, cli, I see what you mean
11:04:55 <sm> I suspect it doesn't have that feature
11:05:02 <cocreature> jimmmy: write a function of type "a -> Tree a -> Tree a -> Tree a" and then use liftA3
11:05:05 <jimmmy> ReinH: Where can I find a tutorial about helper combinators. Are you talking about for example the go helper function in foldr?
11:06:28 <zbs_> ah, bummer
11:06:31 <bor0> if in theory intuitionistic logic and calculus of constructions are the systems that Coq is based on, what systems is Idris based on?
11:07:44 <ReinH> :t liftA2 (flip (,)) — something like this, but for trees
11:07:45 <lambdabot> error: parse error on input ‘,’
11:07:59 <ReinH> Ugh thanks autocorrect
11:08:14 <jimmmy> cocreature: for preorder or postorder?
11:08:38 <zbs_> :t nub
11:08:39 <cocreature> jimmmy: preorder but for postorder you can use the same idea
11:08:40 <lambdabot> Eq a => [a] -> [a]
11:08:57 <zbs_> whoa! lambdabot is cool
11:09:12 <cocreature> jimmmy: basically you just need a helper function that provides the arguments to the Node constructor in a different order and then you can use liftA3
11:09:29 <ReinH> What cocreature said. Typing on a phone is hard.
11:10:48 <ReinH> let pre a t1 t2 = Tree t1 a t2 in liftA3 pre
11:12:59 <jimmmy> ReinH: but doesn't that still evaluate in the same order as inorder traversal?
11:13:31 <ReinH> Does it?
11:13:36 <ReinH> You tell me.
11:14:54 <cocreature> jimmmy: be careful what order you are referring to here. what matters is the order of the applicative effects. that order depends on how the arguments are passed to the function on which you called liftA3 and is completely independent of what that function actually does.
11:16:09 <jimmmy> ReinH: Looks like I need to read up on let
11:16:29 <jimmmy> cocreature & ReinH, thank you
11:16:49 <ReinH> What is confusing you about let?
11:17:06 <ReinH> jimmmy: btw you might also be interested in http://blog.moertel.com/posts/2012-01-26-the-inner-beauty-of-tree-traversals.html
11:18:35 <cocreature> finding out that you need to learn more about let while writing lens traversals sounds like you have picked a really weird order in which to learn Haskell topics :)
11:18:58 <jimmmy> well how I see it is like this, in my inorder function, inorder func leftT is evaluated first
11:19:21 <jimmmy> then Node is fmapped into whatever context is generated
11:20:03 <ReinH> Effect order is determined by the order of arguments to liftA*
11:20:05 <jimmmy> then that is applied (<*>) into the context of whatever inorder func rightT evaluates to
11:20:33 <cocreature> jimmmy: you really don’t care about the order of evaluation here, what matters is the order of applicative effects
11:20:40 <ReinH> liftA* is sugar for <$> and <*>
11:21:43 <ReinH> rearranging the results of the applicative action doesn’t change the order of effects.
11:22:42 <jimmmy> cocreature: agreed
11:23:09 <jimmmy> i don't undertand how let pre a t1 t2 = Tree t1 a t2 in liftA3 pre, changes the order of the applicative effects
11:23:52 <ReinH> Because it changes the order in which arguments are given to liftA3
11:24:02 <ReinH> Which is what determines the order of effects.
11:24:14 <cocreature> jimmmy: the whole code is going to look like "let pre a t1 t2 = Tree t1 a t2 in liftA3 pre (func value) (preorder func leftT) (preorder func rightT)"
11:24:34 <cocreature> jimmmy: pre exists so you can have "func value" be the first argument to "liftA3 pre"
11:24:36 <EvanR> the order of evaluation of arguments, ignoring crashing and freezing, shouldnt have any effect on the answer!
11:24:46 <EvanR> important
11:25:36 <jimmmy> EvanR: In this case this is true because I am reconstructing the tree.
11:25:57 <EvanR> what i said is necessarily true because haskell
11:26:34 <jimmmy> EvanR: if you were flattening to a list you would get different answers
11:26:40 <EvanR> no you wouldnt
11:26:49 <EvanR> maybe we misunderstand each other
11:27:35 <EvanR> if you did something like, flatten left ++ middle ++ flatten right, it doesnt matter which order you evaluate those three in
11:27:49 <jimmmy> cocreature: I'll implement what you've written and work it out
11:28:46 <jimmmy> EvanR: I agree.
11:29:30 <EvanR> thats the case for any multi arg operators
11:29:33 <jimmmy> thought you were saying inorder result (flatten left ++ middle ++ flatten right) = preorder result (middle ++ flatten left ++ flatten right)
11:30:03 <EvanR> that doesnt seem like a change in evaluation order
11:30:40 <EvanR> clearly different traversal orders get different results
11:32:00 <jimmmy> so what are you saying? I;m a newbie dumb it down for me
11:34:00 <EvanR> i was reacting to literal comments like, if things evaluate in a different order, you get different results
11:34:07 <EvanR> i guess we were talking about traversal order
11:34:58 <cocreature> jimmmy: take `liftA2 f (putStrLn "foo") (putStrLn "bar")`. The order in which the strings are printed will always be "foo" followed by "bar", completely independent of f
11:35:25 <cocreature> jimmmy: the same holds in your example, "func value" is the first argument so its effects will be executed before the effects of "preorder func leftT"
11:36:01 <cocreature> jimmmy: all the function passed to liftA3 can do is do something with the results after all actions have been executed
11:36:40 <monochrom> What is Traversal doing here?
11:37:09 <cocreature> monochrom: it’s lens’ Traversal type
11:37:21 <monochrom> I am sorry but I am unable to reconcile "I'm a newbie" and Control.Lens.Traversal.
11:38:05 <jimmmy> monochrom: lol
11:38:43 <cocreature> heh, monochrom does have a point. you’ll have a better learning experience if you start with some simpler stuff
11:40:04 <monochrom> You can write your inorder function to return a list.
11:40:44 <jimmmy> cocreature: unfortunately I'm at the end of a intense haskell bootcamp
11:41:24 <cocreature> jimmmy: the one from iohk or are there more haskell bootcamps?
11:41:39 <jimmmy> cocreature: Yep, IOHK
11:42:44 <jimmmy> `liftA2 f (putStrLn "foo") (putStrLn "bar")` so therefore f will execute first then putStrLn
11:42:59 <cocreature> no!
11:43:18 <monochrom> You can't observe "f executes" at all anyway.
11:43:20 <cocreature> you are conflating two orthogonal concepts: evaluation and execution
11:44:16 <EvanR> i am half boggling with the putStrLn example for applicative effect ordering
11:44:37 * EvanR wonders if theres a better example that sorts out all these orthogonal notions
11:45:14 <monochrom> print (repeat True)
11:45:32 <monochrom> No one is going to finish building that infinite list before starting to print.
11:46:15 <jimmmy> monochrom: understood
11:46:27 <monochrom> let n = repeat True in print 0  -- No one is going to even bother.
11:46:47 <jimmmy> I understand the solution now
11:47:49 <jimmmy> the helper function lets you to rearrange the arguments for liftA3 and therefore lets you execute the effects in the desired order
11:49:15 <EvanR> it lets you interpret results of executing the effects in the desired order?
11:49:16 <jimmmy> thanks guys, appreciate it.
12:56:14 <pikajude> is there a way to generate my own hackage package set from a different hackage index?
13:08:44 <pikajude> whoops
13:08:46 <pikajude> this was in the wrong channel
13:35:03 <dmj`> pikajude: yes
13:44:26 <Guest58661> nick arnold
14:02:55 <Unode> When working with "IO FilePath", and manipulating FilePath is there a more concise operator to write 'fmap (</> "file") path' where 'path = IO FilePath' and that also reads more naturally (i.e. path </> "file")
14:10:00 <metahumor> Unode: "let (<//>) path file = ((</>) file) <$> path in (<//>)
14:10:09 <metahumor> or <$/> or </$>
14:13:13 <Unode> I like the two <$/> </$> in that they convey a clear meaning of what's happening.
14:14:25 <Unode> not entirely sure why "in (<//>)" is necessary though.
14:14:28 <Unode> thanks metahumor
14:15:11 <metahumor> i was just showing a way to define it
14:15:27 <metahumor> and i wrote in such a way that you run ":t let ... in (<//>)"
14:15:47 <metahumor> i like </$> the most out of all of those
14:18:56 <Unode> agreed, that's what is being used in this case. I see <$/> useful in the (IO FilePath) <$/> (FilePath) vs (FilePath) </$> (IO FilePath) although the meaning is kinda lost if not using the infix form.
14:20:16 <Unode> metahumor: still not quite sure about the ":t let ... in (<//>)". Was this simply to have an 'annonymous function name) in the :t call
14:20:17 <Unode> ?
14:20:22 <metahumor> yeah
14:20:27 <Unode> ah ok
14:20:35 <Unode> not familiar with this construct
14:20:43 <Unode> I mean, for this particular goal
14:20:45 <mark721> hi guys, i have somewhat a broadly "relevant" question maybe you guys could help with. Firstly, I'm not looking for an answer just some directions how to each an answer.
14:20:50 <mark721> *reach
14:21:05 <metahumor> i was just playing around with the type of the function, so i had to write it that way in my ghci to define it scoped
14:21:10 <metahumor> mark721: shoot!
14:21:13 <mark721> i have a research task of looking at the advantages and disadvantages of functional programming compared with with imperative programming.
14:21:42 <mark721> the questions is a tad odd since you're not really comparing characteristics but advantages and disadvantages of two quite different things.
14:22:02 <mark721> so far i have only found two somewhat "relevant" yet not totally amazing sources https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/functional-programming-vs-imperative-programming#advantages-of-pure-functions
14:22:14 <Unode> mark721: I've recently been following some nice lectures (available on youtube) about category theory. Along the way it mentions some advantages.
14:22:18 <mark721> and also https://www.journaldev.com/8693/functional-imperative-object-oriented-programming-comparison (this one is better than the one above)
14:22:27 <mark721> Unode, could you link me please :D
14:22:45 <mark721> also any reading/articles/books im open to
14:22:55 <Unode> mark721: https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
14:23:04 <metahumor> mark721: there are lots of very different imperative languages
14:23:24 <metahumor> C, FORTRAN, Perl, FORTH, Go
14:23:26 <mark721> the issue is im looking for advantages and disadvantages there are a lot of general things like hey its done like this in imperative and like this in functional but thats irrelevant for my question.
14:23:49 <metahumor> x86 assembly, other assembly
14:23:51 <mark721> Unode, checking it out now :D
14:24:14 <metahumor> one thing i'm thinking about is direct low-level memory management is almost entirely an "imperative" topic
14:24:50 <Unode> mark721: my naive understanding: functional programming allows for certain kinds of abstraction that are unique to the functional paradigm. imperative might be a bad term of comparison because a language can be both functional and imperative.
14:25:11 <mark721> Unode, I KNOW i agree so much this why im here LOL
14:25:17 <mark721> :(
14:25:36 <mark721> metahumor, you pick up on something that i never realised :O
14:26:12 <amalloy> how did you arrive at this research topic? if you think it is fundamentally bizarre, can you research something else?
14:26:33 <parsnip> mark721: i like this overview of what one might mean by "functional" https://en.wikipedia.org/wiki/Functional_programming#Concepts
14:26:51 <metahumor> imperative languages might be structured much closely to how the CPU actually executes -- but almost never actually true because of how important compilers and optimizations and crazy CPU instructions are
14:27:10 <parsnip> distance is reduce, perhaps
14:27:14 <parsnip> *reduced
14:27:29 <Unode> mark721: my point being, perhaps trying to set the comparison in terms of "functional" vs "imperative" is a bad way to go at it. Comparing "functional" and say "object-oriented" might be a more reasonable comparison. Otherwise it's like comparing "assembly lines (functional)" with "your boss (imperative)"
14:28:13 <parsnip> i don't know, line by line state in imperative, seems comparable to functional
14:28:22 <amalloy> that's easy. assembly lines are way better at making cars
14:28:44 <Unode> parsnip: do you mean comparing "imperative" with "lazy"?
14:28:49 <parsnip> one way i look at difference, to me, imperative is more vertical, functional is more horizontal.
14:28:50 <mark721> amalloy, it's set by my lecturer :(
14:29:00 <parsnip> Unode: no
14:29:02 <metahumor> C is a very imperative language, but i can also be functional because you can pass around "*func" pointers!
14:29:31 <parsnip> something happens, you go to next line, etc
14:29:45 <Unode> parsnip: my point exactly.
14:29:45 <parsnip> whereas in functional, it's more about the horizontal call
14:30:12 <metahumor> to me, functional === functions as first-class values
14:30:31 <metahumor> functional languages often have other things associated with them that we call functional out of synecdoche
14:30:47 <parsnip> that's one aspect. the lack of state enforces a lot of the shape though
14:31:12 <mark721> just a quick question everyone agrees this question is crap righjt
14:31:24 <parsnip> i guess first class _allows_ the shape
14:31:26 <Unode> maybe I interpret a different thing from those words. To me, imperative == sequential, whereas functional isn't really in the same semantic scope of those two terms. That's why to me it feels a little like comparing apples and oranges.
14:31:48 <mark721> lol if it was explain the characteristics and thus the differences. it would be much more appropriate.
14:32:23 <parsnip> i think it's a more sensitive topic, but not useless.
14:32:45 <Unode> mark721: perhaps you might want to do exactly that, conclusion being that those are two terms that are not really meant to be compared in such a way. They are not mutually exclusive.
14:32:51 <parsnip> OOP and functional style are friendlier to the programmer in different ways.
14:33:12 <parsnip> exclusivity aside
14:33:16 <Unode> parsnip: OOP != imperative, semantically speaking.
14:33:32 <mark721> Unode, although i agree, i have a feeling that what the lecturer wrote is not what he meant
14:33:41 <mark721> that said, maybe I should ask him what he meant...
14:33:55 <parsnip> mark721: present to him some prototypes
14:34:17 <parsnip> mark721: like, "do you mean advantages/disadvantages like this? or comparisons like this?"
14:34:25 <Unode> mark721: if clarifying is an option I agree. Otherwise he might be surprised by the works alumni will present :)
14:35:46 <Unode> metahumor: had to look up "synecdoche" first time seeing the word :)
14:36:00 <mark721> parsnip, good shout
14:36:46 <parsnip> i mean, can't we be inflammatory and make up an advantage/disadvantage, and agree to not argue about it for now
14:37:11 <parsnip> like, imperative is better for people that already know imperative.
14:37:19 <parsnip> boom, advantage.
14:37:28 <mark721> inflammatory
14:37:35 <mark721> thats an odd use for the word lol ?
14:37:50 <t7> anyone use a haskell code formatter?
14:37:51 <mark721> oh no mybad....
14:37:57 <mark721> turns out it has two definitions TIL
14:38:00 <parsnip> incendiary fits too
14:38:06 <t7> and/or do you guys keep your haskell less than 80 cols?
14:38:20 <parsnip> mostly less, not absolutely always maybe
14:38:33 <parsnip> that's a general code thing i think
14:38:51 <parsnip> no formatter here, too lazy
14:38:52 <Unode> t7: it's on the list of tools but beginner here so not yet.
14:38:55 <metahumor> t7: hlint
14:39:03 <metahumor> t7: and stylish-haskell
14:39:05 <Welkin> I do my own linting with my eyes
14:39:23 <Welkin> and never let line run over 80 characters
14:39:31 <parsnip> my pockets make me all the linting i need
14:39:49 <Unode> :) nice ones
14:39:55 <Welkin> it's called linting because the first tool created to do the task was called "lint"
14:40:16 <Welkin> I don't like having a bunch of extra crap to slow down my process
14:40:36 <Welkin> I keep it simple with just my text editor and basic syntax highlighting/indentation
14:40:46 <t7> i have a line inside a do notation block like this:   let x = a ++ b ++ c  (... etc)
14:40:48 <Welkin> no autocomplete or anything fancy either
14:41:25 <Unode> t7: linting might come in handy if you have a shared project. Helps keeping code style somewhat consistent.
14:41:29 <Welkin> t7: I usually split it after the binary operator
14:41:38 <parsnip> t7: can you show it in a paste site, like http://lpaste.net
14:41:47 <t7> http://lpaste.net/362868
14:42:32 <Welkin> I would never use a linter except for a project in a workplace environment with lots of people who could possibly have different styles
14:42:44 <Welkin> using someone else's linter for your own project just feels dirty
14:42:59 <Welkin> like the linter used on lpaste that is annoying and confuses beginners
14:43:06 <hexagoxel> t7: you can try how the "brittany" formatter would format it at https://hexagoxel.de/brittany/
14:43:15 <metahumor> i feel the opposite way, i want to just write exactly what i think and have a linter take care of typesetting it for me
14:44:33 <t7> hexagoxel, i like the formatting that gives
14:44:46 <mark721> parsnip, i forgot the options lol
14:44:59 <mark721> im writing the email but like i dont actually see what "prototypes" to give him
14:45:47 <mark721> literally like in my head the only things that are relevant to this question are very limited. I.e an advantage of FP is that pure FP don't allow side effects although they are allowed in Imperative languages so they may cause bugs.
14:46:47 <parsnip> mark721: maybe you'll understand your question to him after considering the differences further?
14:47:01 <mark721> what do u mean
14:47:10 <Welkin> it does allow for effects
14:47:15 <hexagoxel> t7: see https://github.com/lspitzner/brittany/ for how to install locally
14:47:21 <Welkin> the difference is that in haskell effects are controlled and known
14:47:28 <parsnip> exception makes the rule
14:47:34 <Welkin> in other languages the effects are uncontrolled and unknown
14:47:50 <parsnip> why say, "well, but c allows for functional, because..."
14:48:05 <Welkin> they are tracked by the type system and handled safely
14:48:29 <parsnip> but sure, speaking more precisely is fine, just don't let it stop you from getting a broad outline first?
14:48:47 <Welkin> that is the opposite of what you do to write an essay on a topic
14:49:00 <Welkin> you start with the smallest detail you can and expand from there
14:49:16 <parsnip> okay
14:49:17 <Welkin> it's a writing technique, at least, that I find useful
14:50:15 <parsnip> mark721: i guess what i mean is, start making notes on what you _have_ noticed, and think about why that doesn't match his question, how it could, and what's wrong with trying to make it match.
14:51:33 <Tuplanolla> Have there already been 700 programming languages since The Next 700 Programming Languages by the way?
14:51:50 <hpc> probably
14:52:31 <hpc> if you count every half-baked lisp, dsl, and teaching language, 700 goes by really fast
14:54:46 <Unode> https://en.wikipedia.org/wiki/List_of_programming_languages some 200 there
14:55:00 <Unode> or more
14:55:07 <Welkin> you forgot all of the javascript derivitives
14:55:46 <Unode> And I guess "Brainf*ck" doesn't qualify as "notable programming language"
14:55:50 <hpc> Welkin: if you double-check your language history, you will find that javascript is in fact, a half-baked lisp
14:56:15 <Welkin> hpc: and the other half is crap
14:57:50 <Unode> Welkin: CrapScript is still available, no language with such name :)
14:57:51 <hpc> yeah
14:58:35 <hpc> javascript was originally going to be based on scheme, but it turns out a lot of programmers were uncomfortable using a language that good^H^H^H^Hdifferent
14:58:47 <hpc> so to grab developers they aped C's syntax
14:58:58 <hpc> removed a bunch of "errors" if you made mistakes typing it
14:59:06 <mark721> parsnip, btw he did tell say to read this • http://en.wikipedia.org/wiki/Programming_paradigm
14:59:13 <mark721> which i did. and found it utterly useless
14:59:20 <hpc> and then gave it a name that implied familiarity that wasn't there (with "java" in the name)
14:59:39 <parsnip> mark721: did you read my link?
14:59:45 <mark721> yes
14:59:46 <mark721> why
14:59:52 <parsnip> useless?
15:00:00 <mark721> no
15:00:03 <mark721> my lecturer
15:00:11 <mark721> he told us to read • http://en.wikipedia.org/wiki/Programming_paradigm
15:00:40 <Welkin> paradigms are made up anyway
15:00:45 <parsnip> i'm not sure how i can help
15:00:53 <Welkin> ask anyone what functional programming is and you will get a different answer every time
15:01:09 <parsnip> why is that surprising, the link i gave clarifies that
15:01:12 <mark721> parsnip, what i meant was maybe there was something in there that made it clear what his question was but i read it and nothing
15:01:14 <Welkin> you can't put everything in a neat little box
15:01:40 <parsnip> mark721: i think you just start researching and describing.
15:02:00 <parsnip> i wouldn't think that link is useless, it can give you a place to start
15:02:22 <parsnip> like, "oh, well, before reading this, i had no idea what imperative meant"
15:02:42 <mark721> with respect to the question, its useless to me lol
15:02:47 <mark721> i mean it didn't really help.
15:02:53 <parsnip> i don't think you read that link and necessarily go, "oh! that's what my professor mean!"
15:03:00 <parsnip> how did it not help?
15:03:07 <parsnip> oh, the article
15:03:09 <mark721> yeah
15:03:09 <mark721> this is really good https://www.journaldev.com/8693/functional-imperative-object-oriented-programming-comparison
15:03:20 <mark721> thats good but idk how "real" or good of a source that is.
15:03:43 <mark721> it directly covers advantages and disadvantages
15:03:51 <parsnip> i think it's fine, if the professor is going to link to a single webpage, why not that one?
15:04:24 <parsnip> i think you are doing research, so you're on the right path
15:05:16 <mark721> i guess i will type stuff and hope for the best
15:05:17 <mark721> ty guys
15:05:26 <mark721> have a nice evening/day depending on ur location :P
15:07:30 <parsnip> i'd provide links to resources you found as well
15:11:21 <opsman> Why doesn't this work in GHCi?
15:11:38 <opsman> fromMaybe $ find (>7) [1..10]
15:11:47 <metahumor> :t fromMaybe
15:11:49 <lambdabot> a -> Maybe a -> a
15:11:56 <metahumor> you need to provide a default value
15:12:11 <opsman> fromMaybe takes Maybe a
15:12:15 <metahumor> > fromMaybe (-1) (find (>7) [1..10])
15:12:17 <lambdabot>  8
15:12:31 <metahumor> opsman: no, fromMaybe takes an "a" first, then "Maybe a" second
15:12:40 <opsman> ahh
15:12:42 <metahumor> > fromMaybe (-1) (find (>11) [1..10])
15:12:44 <lambdabot>  -1
15:13:01 <parsnip> :t fromJust
15:13:02 <lambdabot> Maybe a -> a
15:13:09 <metahumor> you probably don't want to use "fromJust"
15:13:10 <Welkin> parsnip: no, bad
15:13:10 <mroutis> woaaah that lambdabot...
15:13:49 <opsman> fromJust gives error
15:13:56 <Welkin> of course
15:14:00 <Welkin> it only works on Just
15:14:03 <metahumor> yeah, because your "Maybe a" is a Nothing
15:14:03 <Welkin> so if you get Nothing
15:14:06 <parsnip> Welkin: note, "probably", versus, "no, bad"
15:14:09 <Welkin> it will throw an exception
15:14:23 <Welkin> that is why you should not use it
15:14:26 <Welkin> it is an unsafe function
15:14:32 <metahumor> opsman: how are you generating the "Maybe a"? what do you want to do with it?
15:14:37 <parsnip> it's Just fine in some cases
15:14:47 <Welkin> parsnip: not for beginners
15:14:59 <parsnip> Welkin: you deal in absolutes
15:15:10 <opsman> λ>fromJust $ find (>7) [1..10]
15:15:10 <opsman> <interactive>:5:12: error:
15:15:10 <opsman>     Variable not in scope:
15:15:10 <opsman>       find :: (Integer -> Bool) -> [Integer] -> Maybe a
15:15:10 <opsman> (0.05 secs,)
15:15:25 <metahumor> oh, opsman, "import Data.List (find)"
15:15:58 <Welkin> parsnip: it is helpful to do so when teaching something, even if it is not completely true
15:16:25 <parsnip> sometimes
15:16:42 <opsman> ok thanks metahumor. how do I know when to specify...
15:16:58 <opsman> I was loading Data.List....
15:17:06 <opsman> thought find would be loaded
15:17:18 <Welkin> it should be
15:17:20 <metahumor> it should have been
15:17:53 <parsnip> > fromJust $ find (>7) [0..7]
15:17:55 <lambdabot>  *Exception: Maybe.fromJust: Nothing
15:18:03 <parsnip> > fromMaybe (-1) $ find (>7) [0..7]
15:18:03 <opsman> so using :m Data.List didnt work in ghci...but :import Data.List find - solved problem
15:18:05 <lambdabot>  -1
15:18:31 <metahumor> :m + Data.List
15:19:25 <parsnip> Welkin: fromMaybe may itself not be correct here either, so fromJust could just as well be a quick patch while the rest of the code is considered, even, the exception may help in coming up with correct fix.
15:19:34 <opsman> ah...so the + means to load all functions
15:20:01 <Welkin> parsnip: or just forget about fancy predefined functions and use case expressions
15:20:21 <Welkin> because from what I have found, people who try to use fromMaybe or fromJust don't even understand pattern matching
15:20:26 <opsman> I'm a beginner running through LYAHFGG...just playing around in ghci and hit a snag with that one liner
15:20:41 <Welkin> opsman: have you learned pattern matching yet?
15:20:51 <metahumor> opsman: and ":m - Data.List" should unload them iirc
15:21:06 <parsnip> well, fancy isn't bad, but yeah, while i'm figuring things out, i might have used case expressions or pattern matching to help while refactoring.
15:21:08 <opsman> yes...but I'm having difficulty with multi-line expressions in ghci
15:21:24 <parsnip> opsman: oh, you should edit haskell mostly in a file
15:21:30 <geekosaur> opsman, no. ":m module" means switch the current module to the already loaded module. it doesn;t load anything, but symbols in that module can be used unqiualified
15:21:32 <opsman> if I create a module in Vim and load it works fine.
15:21:53 <geekosaur> ":m + module" means load that module and make it the current module
15:22:02 <geekosaur> (this can also be "import module")
15:22:06 <Welkin> the endless problems with LYAH
15:23:06 <geekosaur> (and yes, there is also ":m - module" to unload a module)
15:23:45 <opsman> so :m + Data.List Data.Maybe --would load both modules for the session?
15:23:53 <geekosaur> yes
15:26:59 <geekosaur> (more precisely, you can;t actually "unload" a module but you can remove it from the current scope, which is what ":m -" does. all modules in the prompt are in scope, one is current. for ":l" modules there is an additional comlication in that if it finds a compiled version it will load that and only expoirted symbols will be in scope; prepending * to the filename forces loading and interpreting, so that unexported symbols will be in scope)
15:28:14 <dmwit> `:m + Module` is "put whatever `Module` exports in scope". `:m * Module` is "put everything in `Module` in scope, even if it's not exported". `:m - Module` is "stop putting whatever `Module` exports in scope" (but it may still be in scope from other modules).
15:28:18 <parsnip> status =default
15:29:38 <opsman> I've tried the multi-line functionality for ghci suggested on stack-overflow...However, none of the suggestions seem to work.
15:29:45 <dmwit> `:l Module` is "interpret `Module`, then do `:m * Module`".
15:30:01 <dmwit> opsman: Give us a paste showing your session.
15:30:02 <dmwit> ?paste
15:30:02 <lambdabot> Haskell pastebin: http://lpaste.net/
15:30:47 <opsman> ?paste
15:30:48 <lambdabot> Haskell pastebin: http://lpaste.net/
15:31:06 <opsman> I dont understand
15:31:11 <metahumor> @where lpase
15:31:11 <lambdabot> I know nothing about lpase.
15:31:13 <metahumor> @where lpaste
15:31:13 <lambdabot> http://lpaste.net/
15:32:08 <dmwit> opsman: Long pastes are annoying on IRC. So normal protocol is to paste long things on a website and put a link to it in IRC. lpaste.net is one such site.
15:32:11 <metahumor> opsman: ":set +m" followed by ":{<ENTER>mycodehereincludingEnters<ENTER>}:"
15:32:16 <dmwit> (The preferred one for this channel.)
15:32:32 <dmwit> :set +m is not needed for :{/:}
15:34:09 <dmwit> Hm.
15:34:11 <dmwit> % :{
15:34:12 <yahb> dmwit:
15:34:15 <dmwit> oh dear
15:34:20 <dmwit> % x True = 3
15:34:20 <yahb> dmwit:
15:34:23 <dmwit> % x False = 4
15:34:23 <yahb> dmwit:
15:34:25 <dmwit> % :}
15:34:25 <yahb> dmwit:
15:34:37 <dmwit> % (x True, x False)
15:34:38 <yahb> dmwit: (3,4)
15:35:28 <dmwit> Is that ghci session shared across channels and the like? Somebody is going to confuse things terribly one day by doing % :{ with no matching % :} in PM. =P
15:35:47 <metahumor> i hope not
15:35:53 <metahumor> but i think it is
15:36:00 <metahumor> because i can @let in PM and have it work here
15:36:10 <metahumor> it'll be obvious if someone does that to yahb
15:37:50 <opsman> I dont have an active session any longer. I closed it after using :m + Data.List find solved my problem.
15:38:33 <dmwit> Okay. We can't help you fix your multiline problems if you can't show us what you tried and what went wrong.
15:39:11 <opsman> I'm going to study the ghci manual again..evidently I need some more practice using it to correctly load the required modules
15:40:38 <Bish> primes = [x| x <- [2..]::[Int], null $ filter (\y -> rem x y == 0) ([2..(ceiling.sqrt.fromIntegral $ x)]) ]
15:40:41 <Bish> what's bad about this?
15:40:57 <Bish> i mean, it's my first effort @ lists and naive, i know that
15:41:06 <Bish> but a naive implementation in C is way quicker
15:42:43 <opsman> ok, how about this..
15:42:47 <opsman> λ>{:
15:42:47 <opsman> Prelude| let maxnum = max 5 8
15:42:47 <opsman> Prelude| print maxnum
15:42:47 <opsman> Prelude| :}
15:42:47 <opsman> <interactive>:2:2: error: parse error on input ‘:’
15:42:49 <opsman> (0.00 secs,)
15:42:52 <opsman> λ>
15:42:58 <dmwit> opsman: Don't paste in here.
15:43:00 <metahumor> :{
15:43:30 <opsman> Ok, I figured it was short so NP..apologies.
15:43:32 <dmwit> opsman: But yes, as metahumor said: it's :{, not {:.
15:43:44 <dmwit> opsman: Anything more than one line should go to lpaste.net or similar.
15:43:47 <metahumor> Bish, well first of all, i'd use [2,3,5.. ceiling(...)]
15:44:42 <metahumor> and why not just use "takeWhile (< ceiling(...)) primes" for that instead
15:45:01 <metahumor> that's something you won't be able to do in C... =)
15:45:10 <opsman> Ok, I figured it was short so NP..apologies.
15:45:27 <Bish> metahumor: because i didn't know takeWhile :o
15:45:44 <metahumor> opsman: if you do multiline pastes in here, you'll get kicked/muted by bots -- we don't want that
15:46:44 <woodson> hey guys, i was suggested to use wreq to make http request. However I have been having a hard time especially because I am not familiar with Lens.. I am trying to figure out how to handle request error
15:46:56 <woodson> I am following this tutorial
15:46:58 <woodson> http://www.serpentine.com/wreq/tutorial.html
15:47:03 <woodson> which is very minimal
15:47:08 <woodson> and I am getting an error
15:47:11 <opsman> ok dmwit: what is the closing bracket :} or }:
15:47:33 <dmwit> opsman: :}
15:47:39 <dmwit> All ghci directives begin with :.
15:47:49 <woodson> with the same code thats on the site that I had to adjust
15:47:50 <woodson> http://lpaste.net/362869
15:48:17 <woodson> can anyone tell me what is wrong?
15:48:20 <opsman> trying that then gives "parse error (possibly incorrect indentation or mismatched brackets)
15:49:21 <opsman> but my prompt change after entering :{ I beleive is causing that error because the closing bracket is mismatched - technically
15:50:58 <Bish> metahumor: but it didn't make it any faster :(
15:52:50 <opsman> ok here we go --- http://lpaste.net/362870
15:53:43 <metahumor> woodson: sorry I had to reconnect
15:53:57 <metahumor> you need to do "^. responseStatus . statusCode"
15:55:05 <metahumor> woodson: why not just use https with authopts as the default?
15:55:46 <dmwit> Bish: How much quicker is "much quicker" in "naive implementation in C is way quicker"?
15:56:45 <Bish> 6s vs 0.079s
15:56:54 <metahumor> Bish: are you trying this inside ghci?
15:57:01 <Bish> no, runhaskell
15:57:08 <dmwit> Could not reproduce. http://lpaste.net/362871
15:57:21 <dmwit> For me Haskell is only 3x slower.
15:57:34 <dmwit> Bish: Compile. It makes a huge difference.
15:58:19 <metahumor> look at all those pagefaults
15:58:33 <Bish> okay, it does make a difference
15:58:33 <metahumor> runhaskell is "interpreted" like ghci?
15:58:52 <dmwit> metahumor: yes
15:59:06 <monochrom> runhaskell -> runghc
15:59:09 <Bish> always figured it compiles
15:59:17 <Bish> because it saves stuff to stmp
15:59:21 <Bish> ./tmp*
15:59:29 <dmwit> ...ish? I think it uses the ghci bytecode. But I think it works with stuff ghci doesn't, like strict tuples and some FFI stuff.
15:59:44 <dmwit> not 100% on that
16:00:27 <Bish> but it's still 6 times slower for me
16:00:47 <dmwit> Are you using the same algorithm in C as you are in Haskell?
16:01:35 <Bish> our codes are scarily identical
16:03:46 <Bish> maybe rem is slow as fuck?
16:04:10 <dmwit> It is slow. But not particularly slow compared to other languages.
16:04:17 <monochrom> C is using int, Haskell is using Integer.
16:04:20 <dmwit> If you want to blame something, blame lists. Do a loop instead.
16:04:27 <metahumor> what's faster, div or rem?
16:04:31 <dmwit> monochrom: no, Bish was careful about that
16:04:36 <dmwit> metahumor: rem
16:04:37 <monochrom> Oh you already make it [Int].
16:04:42 <hpc> divMod is slower than quotRem
16:04:56 <hpc> (on x86)
16:05:13 <monochrom> I may blame it on linked list and cache misses.
16:05:18 <metahumor> division was a bad idea
16:05:41 <monochrom> But before that, I am really skeptic about "same algorithm in C".
16:05:53 <dmwit> Two votes for blaming lists.
16:06:11 <monochrom> But even after that, there are a few more cards I can play.
16:06:29 <Bish> https://paste.pound-python.org/show/00ztfLnwpUojpIEJWXn0/
16:07:18 <metahumor> can you test how fast "take n Data.Numbers.Primes.primes" is on your machine?
16:07:19 <monochrom> If you write like "a loop that counts from 0 to n".  GHC faithfully generates asm code that counts from 0 to n.  Lean mean code but it still counts from 0 to n stupidly.
16:07:32 <monochrom> GCC simply replaces the whole loop by "final value = n".
16:08:01 <dmwit> -fllvm fixes that problem
16:08:34 <Bish> and compiles quicker :o
16:08:38 <metahumor> okay, now you have to GHC->LLVM too
16:08:43 <dmwit> I inspected the code for `sum [1..100000]` or something like that once; with -fllvm it is "just print the answer".
16:09:23 <monochrom> Where is the list in the C version? I don't even see an array.
16:10:27 <Bish> i never said i used the same techniques.. jsut the right tricks
16:10:36 <Bish> i think they're pretty equal when it comes to being naive
16:10:45 <Bish> i wouldn't even know how to write it that way in haskel
16:10:55 <Bish> orther than expressed with lists
16:11:03 <dmwit> Just recursion is fine.
16:11:53 <metahumor> Bish, you might like https://www.willamette.edu/~fruehr/haskell/evolution.html
16:12:31 <dmwit> Bish: Look ma, no lists! `nthPrime n p = case (n, isPrime p) of (0, True) -> p; (_, False) -> nthPrime n (p+1); (_, True) -> nthPrime (n-1) (p+1)`
16:12:45 <dmwit> Bish: Similar trick for `isPrime`: just use recursion.
16:12:55 <dmwit> count up without a list.
16:13:05 <dmwit> It will make a difference.
16:13:47 <shapr> Atlanta Haskathon! https://twitter.com/shapr/status/967548493253529600
16:14:18 <shapr> Really good attendance since it got organized yesterday!
16:14:28 <Bish> only 2 of those use lists.
16:15:44 <Bish> but i like list encoding stuff :(
16:18:00 <Bish> okay, thanks folks
16:18:11 <Bish> good night!
16:25:32 <buttbutter> I'm thinking about writing a GameBoy emulator in Haskell to learn the language better. But I think that the project might be a bit too big for a first attempt: does anyone have any ideas for a smaller/simpler emulation project to get me started?
16:27:53 <dmwit> Brainfuck is pretty small.
16:28:10 <dmwit> That's a single-night or maybe 2-3 nights hack.
16:28:13 <dmwit> How small do you want to go?
16:30:06 <buttbutter> dmwit: i.e. an interpreter for brainfuck?
16:30:44 <dmwit> I mean, if you want to make a compiler for it instead be my guest.
16:30:58 <buttbutter> Haha. That's actually a good idea. Maybe I'll do that. :)
16:31:11 <buttbutter> I'm just afraid of making noob mistakes early and having to do tons of rewrites.
16:31:11 <dmwit> There's actually a ton of fun stuff you can learn about peephole optimizations and the like to do a good job of it.
16:31:43 <buttbutter> I was also thinking about doing the tiger compiler book in Haskell (it's supposed to be done in SML).
16:56:20 <monochrom> Bish: I used your Haskell list as "main = print (primes !! (25000-1))" and it seems 2.5x of the C version.  0.122s vs 0.048s.
17:22:09 <fr33domlover> Hello
17:22:15 <metahumor> hi
17:23:21 <fr33domlover> I'm running `stack build` and it fails with HsOpenSSL not finding native deps 'ssl' and 'crypto' libs, indeed looks like it requires OpenSSL 1.1 and Debian 8 doesn't have that version in stable
17:23:36 <fr33domlover> So I got OpenSSL 1.1 installed from Guix
17:24:00 <fr33domlover> And pointing to it using stack install options --extra-lib-dirs and --extra-include-dirs
17:24:08 <fr33domlover> But it still gives the same error
17:24:18 <metahumor> fr33domlover: i just did "apt-get install libssl-dev"
17:24:18 <fr33domlover> I'm desperate for any advice :P
17:24:37 <fr33domlover> metahumor, yeah me too but it seems the version isn't recent enough
17:24:37 <metahumor> that should be enough to "stack build HsOpenSSL"
17:24:52 <metahumor> which lts are you using?
17:25:21 <fr33domlover> metahumor, 6.5 at the moment but I get the same error on 10.7
17:25:26 <fr33domlover> I mean 10.4
17:25:42 <fr33domlover> metahumor, it used to work just fine for 6.5
17:25:53 <fr33domlover> idk why now it doesn't tbh
17:27:01 <metahumor> i've had no issue with it in 8.24. idk, try deleting ~/.stack-work?
17:28:19 <fr33domlover> metahumor, it's a fresh build
17:28:28 <fr33domlover> i deleted .stack-work before it
17:28:53 <fr33domlover> I used to build on Trisquel 7 and had no issue
17:29:12 <fr33domlover> The only difference is that I'm on Devuan Jessie now
17:58:44 <monochrom> dmwit: I measured your no-list implementation (supplied my no-list isPrime).  It is not faster than the listful version.
17:59:17 <dmwit> Huh! I admit I'm a bit surprised.
17:59:19 <monochrom> Furthermore, to test the blame on the tuples you have, I eliminated those tuples too.  Same time.
17:59:41 <monochrom> Furthermore, I installed llvm 3.9 and gave -fllvm a try.  Same time.
17:59:43 <fr33domlover> I deleted ~/.stack and tried to build again, still same error :'-(
17:59:56 <dmwit> Does strictness help?
17:59:56 <monochrom> Now I'm completely unable to explain these observations!
18:00:39 <monochrom> I read the core code.  It's all direct Int# rem# etc at that level.
18:00:51 <dmwit> Nice job, GHC!
18:02:24 <MarcelineVQ> I encourage people to check out https://softwarefoundations.cis.upenn.edu/ it's available in multiple (programming) languages and really quite fun for people interested in programming with types
18:04:34 <monochrom> Neato
18:24:08 <R0b0t1`> If I have data Scan = Scan [Int] [Int] how do I get the first or second list
18:24:46 <metahumor> you'll have to pattern match
18:24:48 <parsnip> R0b0t1`: myFunction (Scan xs ys) = xs
18:25:12 <parsnip> or better, myFunction (Scan xs _) = xs
18:26:34 <R0b0t1`> So I tried case s of Scan r _ -> length r
18:26:36 <R0b0t1`> Ok
18:26:39 <R0b0t1`> Sorry that does work
18:26:45 <R0b0t1`> I tried to name the lists, but that did not work
18:27:08 <R0b0t1`> Ah lowercase
18:27:11 <R0b0t1`> Nevermind
18:34:13 <R0b0t1`> So I have a list which represents column select and a list which represents row select
18:34:28 <R0b0t1`> The places are numbered left->right top->down starting with 0
18:34:41 <R0b0t1`> How do I turn [1, 0, 0] [1, 0, 0] into 0, etc
18:34:49 <blankhar1> MarcelineVQ, what do you mean when you say it is available in multiple programming languages? it oriented solely to Coq?
18:35:44 <metahumor> R0b0t1`: can you come up with a function "twoDtoZ x y" that takes a col-pos and a row-pos and calculates which number it references?
18:39:50 <R0b0t1`> metahumor: index c r = c + r * (length r)
18:40:12 <R0b0t1`> Well not literally that
18:40:30 <metahumor> yeah, because you have (length r)
18:40:43 <metahumor> R0b0t1`: take a look at this function
18:40:45 <metahumor> :t zipWith
18:40:47 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
18:42:44 <R0b0t1`> Ah
18:45:27 <R0b0t1`> metahumor: zipWith index (columns ...) (rows ...)?
18:46:21 <metahumor> exactly
18:54:01 <dmwit> I suspect you'll get better mileage out of `data Position = Position Int Int; type Scan = [Position]`.
18:54:01 <R0b0t1`> metahumor: I'm not sure it works
18:54:43 <metahumor> @which lpaste
18:54:43 <lambdabot> Unknown command, try @list
18:54:48 <metahumor> @where lpaste
18:54:49 <lambdabot> http://lpaste.net/
18:54:57 <metahumor> R0b0t1`: try sharing your code with us using lpaste
18:55:33 <R0b0t1`> https://bpaste.net/show/ca7f7f12cf12
18:56:12 <R0b0t1`> The last print statement returns 5 4
18:56:16 <R0b0t1`> sorry I tried changing index
18:56:32 <R0b0t1`> c + r * 4
18:56:57 <R0b0t1`> I may have messed up index, and it looks like this is 1-based
18:57:38 <R0b0t1`> Err
18:58:00 <R0b0t1`> Yes ts5 should result in [0, 1]
18:59:11 <dmwit> I don't yet understand the problem statement.
18:59:33 <R0b0t1`> A keyboard's state is read as a string of row and column data
18:59:46 <R0b0t1`> Er, two lists of column and row data
18:59:48 <metahumor> "toVals (Scan cs rs) = let withIndex = zip [0..] in [index ixc ixr | (ixc, c) <- withIndex cs, (ixr, r) <- withIndex rs, c /= 0, r /= 0]"
18:59:55 <R0b0t1`> When the positions are coincident when overlaid with a grid the key is depressed
19:00:26 <metahumor> @let toVals cs rs = let withIndex = zip [0..] in [index ixc ixr | (ixc, c) <- withIndex cs, (ixr, r) <- withIndex rs, c /= 0, r /= 0]"
19:00:26 <lambdabot>  Parse failed: Improperly terminated string
19:00:28 <metahumor> @let toVals cs rs = let withIndex = zip [0..] in [index ixc ixr | (ixc, c) <- withIndex cs, (ixr, r) <- withIndex rs, c /= 0, r /= 0]
19:00:30 <lambdabot>  .L.hs:162:36: error:
19:00:30 <lambdabot>      • Could not deduce (Enum (Integer, Integer))
19:00:30 <lambdabot>          arising from a use of ‘withIndex’
19:00:54 <dmwit> R0b0t1`: Why is zipWith the right thing to use? It seems patently unuseful for what you're describing.
19:01:48 * R0b0t1` points incriminatingly at metahumor
19:01:53 <dmwit> R0b0t1`: Seems like you would rather first have a preprocessing pass that converts what is essentially a list of booleans to a list of the indices that are true.
19:02:12 <R0b0t1`> However, I did think it would work - if I take the position in the list of rows and the position in the list of columns I should be able to get a list of positions
19:02:17 <R0b0t1`> Seeing as 1 is a flag this should work
19:02:50 <ab9rf> ew, a list of booleans
19:03:21 <dmwit> R0b0t1`: ...but you are not taking the position in the list of rows or the position in the list of columns.
19:04:25 <dmwit> R0b0t1`: You are taking a single number telling whether the n'th row is lit up, and a single number telling whether the n'th column is lit up (N.B. n'th row, n'th column, same n!).
19:04:45 <dmwit> So you only ever look at "the diagonal" of the keyboard.
19:04:47 <ab9rf> zip won't do what you want here, you need a cartesian product
19:04:58 <ab9rf> or something that has a similar effect
19:05:07 <metahumor> :t \f cs rs -> let withIndex = zip [0..] in let f x y = x + y * 4 in [f ixc ixr | (ixc, c) <- withIndex cs, (ixr, r) <- withIndex rs, c /= 0, r /= 0]
19:05:08 <lambdabot> (Num a3, Num a2, Num a1, Eq a3, Eq a2, Enum a1) => p -> [a2] -> [a3] -> [a1]
19:05:22 <metahumor> @let toVals cs rs = let withIndex = zip [0..] in let f x y = x + y * 4 in [f ixc ixr | (ixc, c) <- withIndex cs, (ixr, r) <- withIndex rs, c /= 0, r /= 0]
19:05:24 <lambdabot>  Defined.
19:05:34 <dmwit> metahumor: `findIndices (1==)`
19:05:42 <dmwit> metahumor: or `findIndices (0/=)` if you prefer
19:05:57 <metahumor> > toVals [1,1,0,0] [1,0,0,0,0,0,0]
19:05:59 <lambdabot>  [0,1]
19:06:08 <metahumor> yeah...
19:07:24 <dmwit> > (\cs rs -> [c + r*4 | c <- findIndices (0/=) cs, r <- findIndices (0/=) rs]) [1,1,0,0] [1,0,0,0,0,0,0,0,0,0]
19:07:27 <lambdabot>  [0,1]
19:08:17 <R0b0t1`> I'm trying to understand metahumor's solution because it seems like it will use less memory
19:08:34 <metahumor> use dmwit's. also don't worry about memory
19:08:45 <metahumor> @unlet
19:08:45 <lambdabot>  Define what?
19:08:47 <metahumor> @undef
19:08:48 <lambdabot> Undefined.
19:10:36 <dmwit> Mine will do less allocation. No tuples. It will also be faster because it hoists the `c /= 0` condition higher. Otherwise the two are essentially identical in concept.
19:11:03 <R0b0t1`> Hmm
19:11:32 <dmwit> s/higher/into the outer loop/ might be a clearer explanation.
19:13:52 <dmwit> Also I think you should delete `None`. `Key []` is a perfectly good replacement.
19:14:04 <dmwit> I mean `Report []`.
19:14:12 <R0b0t1`> Yeah
19:15:49 <R0b0t1`> So now
19:15:54 <R0b0t1`> How do I find faults
19:16:27 <buttaseckasa> What do you guys think about Elixir? Does its pros outweigh the con (for most of you, I assume) of it being dynamically typed, particularly in regard to (high) concurrency?
19:16:30 <R0b0t1`> Maybe detect the case where nothing is pressed, mark the returned [] as OK
19:16:35 <dmwit> If you get `Report []` otherwise, and have `any (1==) (columns scan ++ rows scan)`.
19:17:05 <dmwit> or `any (0/=) (...)` if you prefer
19:21:11 <MarcelineVQ> blankhar1: there's at least coq and idris versions and I wouldn't be surprised to see an agda one around somwhere
19:23:04 <blankhar1> ah awesome thanks!
19:25:05 <MarcelineVQ> I'm doing the idris one currently but might use coq afterwards to compare   https://idris-hackers.github.io/software-foundations/pdf/sf-idris-2016.pdf
19:26:14 <buttaseckasa> What do you guys think about Elixir? Does its pros outweigh the con (for most of you, I assume) of it being dynamically typed, particularly in regard to (high) concurrency?
19:26:26 <R0b0t1`> It's fine, there are companies using it
19:26:47 <R0b0t1`> dmwit: metahumor: thanks, https://bpaste.net/show/39970a097058
19:28:11 <dmwit> R0b0t1`: Cheers.
19:28:21 <dmwit> R0b0t1`: Do you expect to ever have something other than 0 or 1 in your lists?
19:28:24 <cheers> cheers
19:28:31 <dmwit> If not, consider `Bool` instead of `Int`.
19:28:54 <dmwit> cheers: Oh. Well, you picked that name, you have only yourself to blame for the spurious highlights. =P
19:29:21 <cheers> dmwit: i like them!
19:29:29 <cheers> makes me feel important
19:29:39 <dmwit> cheers: Well, you picked that name, you have only yourself to praise... !
19:29:52 <dmwit> cheers++
19:29:55 <cheers> lol
19:31:35 <monochrom> Too bad "thank" and "thanks" are taken.
19:32:23 <metahumor> surprised no one has the "lazy" nick
19:33:49 <blankhar1> or the "nick" nick
19:34:26 <blankhar1> (some metahumor)
19:34:32 <blankhar1> oh wait...
19:34:39 <monochrom> haha
19:42:43 <R0b0t1`> dmwit: No, it may be possible to use booleans
19:43:29 <dmwit> In such a case, there is `or` as a replacement for `any id`.
20:17:47 <metahumor> when looking up how a package works, do yall just google the hackage docs?
20:18:33 <Eduard_Munteanu> metahumor, usually, yes
20:18:43 <dmwit> I usually go straight to the Hackage page without stopping at Google first. But yes.
20:24:16 <metahumor> has anyone run into "fatal erro: config.h: No such file or directory" when building unix-time?
20:45:39 <plakband> What should I use if I want to lazily parse and stream large binary files? conduit + binary?
20:47:38 <Eduard_Munteanu> plakband, that, or conduit + attoparsec
20:50:27 <Eduard_Munteanu> Though with attoparsec you have to be careful to avoid consuming too much input, it isn't suitable for lazy parsing itself.
20:51:36 <plakband> So would binary be the better choice in this case? My main concern is constant memory usage, the files are several gb in size
20:57:43 <Eduard_Munteanu> plakband, possibly... there's also conduit-combinators, which may replace some parsec-y stuff
21:02:06 <plakband> Eduard_Munteanu: are you referring to chunked streams?
21:02:28 <Eduard_Munteanu> plakband, yeah, that kind of thing
21:03:37 <plakband> I'll check that out, thanks for your time
21:07:41 <ertes> plakband: you would use conduit *or* binary for the most part
21:08:25 <ertes> plakband: but they do solve different problems…  using something like conduit, machines or pipes together with a parser combinator library like attoparsec is another common option
21:15:13 <plakband> ertes: I need to fairly complex parsing, buffering of about 10 MB of data, and processing on that buffer. It's not really clear to me which of those would be able to do all of that efficiently looking at the docs
21:17:36 <plakband> ertes: What would you recommend in such a case?
21:30:44 <ertes> plakband: if you use a parser combinator library, the buffering will be implicit
21:31:02 <ertes> (or explicit, if you just give values names)
21:31:57 <ertes> plakband: there are two kinds of "buffering" that can happen: either part of the input is kept for backtracking purposes, or you create values from the input
21:32:45 <ertes> however, if your grammar is heavy on backtracking, you may want to use something other than attoparsec, because it doesn't give you control over it the way most other libraries do
21:33:27 <ertes> the only other alternative that i know is trifecta
21:34:07 <ertes> trifecta is usually used for "human" languages (source code, etc.), but it does parse raw bytestrings, so you should be able to use it in this case
21:36:13 <plakband> ertes: it's just obnoxiously formatted data luckily, I think attoparsec will suffice
21:36:39 <ertes> plakband: as for the streaming library, any of the three i mentioned will work…  conduit is the well established one (lots of support libraries, lots of built-in features), pipes is the clean, elegant one (fewer support libraries, but very simple and easy to use), and machines is the edwardk one =)
21:37:44 <plakband> is the benefit of a streaming library in this case the interleaving of IO?
21:38:10 <ertes> "the edwardk one" meaning that it's more powerful, has a clean design while at the same time providing all the features that pipes lacks, but it's more difficult to understand and lacks support libraries for *basic* things…  however, it does have some rather magical support libraries like concurrent-machines
21:39:21 <ertes> the benefit of streaming libraries is separation of concerns (produces, transducers, consumers all completely separate), while providing full control over effects
21:39:49 <ertes> you'll know exactly when and how much from a file is read, what happens when an error occurs, etc.
21:39:54 <ertes> s/know/control/
21:40:19 <ertes> in other words: it provides all the benefits of lazy I/O while avoiding all of its drawbacks =)
21:41:15 <metahumor> is there any way to "cabal install ghc-mod" if i am using Cabal and cabal-install >=2.0?
21:41:35 <metahumor> as in, any way to get cabal-install to use Cabal <2.0 just for that particular install?
21:43:36 <metahumor> should i just switch to nix? i'm lost...
21:43:54 <ertes> metahumor: anything wrong with just installing it?
21:45:28 <plakband> ertes: What I don't understand is how conduit exposes that control over reading a file. sourceFile produces a raw ByteString, with seemingly no further control. How is it different from readFile if it just produces a single value?
21:46:23 <ertes> metahumor: ah, it actually requires GHC 8.0…  i don't see any indication that the cabal/cabal-install version would matter
21:46:26 <dmwit> It doesn't produce a raw ByteString, it produces a ConduitT i ByteString m ().
21:47:52 <metahumor> it freaks outs when it inspects files with some kind-mismatch
21:48:20 <metahumor> which issues on github have indicated to be because of some cabal-helper problems
21:48:33 <woodson> what I'm doing wrong here? http://lpaste.net/5561496286223400960
21:48:40 <metahumor> i'm now trying a hidden ghc-mod-5.9.0.0 candidate that's linked in a single issue comment
21:48:52 <woodson> try to catch exception and return a new another data type but ..
21:49:32 <ertes> metahumor: if you're using GHC 8.2, yes, nix would be an option…  if you have nix installed, you can just do this:  nix-env -iA nixos.haskell.packages.ghc802.ghc-mod
21:51:00 <plakband> dmwit: does that not mean that it produces ByteString values?
21:52:14 <ertes> plakband: a (ConduitT i ByteString m ()) is a producer of ByteString…  if you compose it with a consumer using (.|) that consumer receives those ByteStrings
21:52:52 <ertes> plakband: example: runConduit (producer .| forever (await >>= liftIO . print))
21:53:47 <asimov_w1sp> Is SICP available in haskell varient?
21:55:44 <ertes> plakband: in this case 'await' returns a (Maybe ByteString), where Nothing indicates that the upstream producer has finished producing
21:57:46 <asimov_w1sp> Anyone?
22:00:12 <ertes> woodson: hard to tell given an incomplete paste
22:01:03 <plakband> ertes: does sourceFile yield more than one bytestring?
22:01:59 <metahumor> woodson: Right doesn't extract
22:02:59 <metahumor> woodson: you want to do "Right r <- asJson =<< post ... `E.catches` ..." i think
22:04:33 <ertes> plakband: it can yield as many as it wants, including none or one or infinitely many
22:04:34 <woodson> metahumor: I dont think thats it
22:04:45 <woodson> because I am fmapping in the next function
22:04:46 <woodson> below
22:05:07 <metahumor> woodson: the error you have is on the line that I am dealing with
22:05:41 <ertes> plakband: try this example:  runConduit ((yield 1 >> yield 2) .| replicateM_ 3 (await >>= liftIO . print))
22:05:45 <metahumor> "post :: ... -> IO (Response ByteString)"
22:06:19 <ertes> plakband: the producer produces two numbers using 'yield', the consumer uses 'await' three times, the third of which will return Nothing
22:07:27 <woodson> having such a hard time just doing and http request and trying to deal with the exception that it might throw..
22:08:18 <ertes> woodson: BTW, you can use 'tryJust'
22:08:19 <woodson> metahumor: i got type Resp = Either HFClientError (Response HFClient)
22:08:21 <ertes> :t tryJust
22:08:22 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
22:09:01 <woodson> I am just confused to why I should deconstruct Right
22:09:30 <ertes> woodson: what's the type of asJSON?
22:09:37 <woodson> Resp
22:09:50 <woodson> ertes: type Resp = Either HFClientError (Response HFClient)
22:10:08 <ertes> that's not even a function
22:10:29 <ertes> but i suspect that (=<<) is wrong
22:10:40 <woodson> asJSON is from wreq
22:10:54 <woodson> https://hackage.haskell.org/package/wreq-0.5.2.0/docs/Network-Wreq.html#v:asJSON
22:11:13 <ertes> ah, (=<<) is fine then, but (.) is wrong
22:11:57 <ertes> (Right . asJSON) receives an Either JSONError (Response _)
22:12:11 <ertes> i assume that _ is Value or some FromJSON type
22:12:20 <metahumor> sorry got dc'd
22:12:39 <woodson> ertes: thaats why I got the where handleJSON = \(JSONError x) ->  return $ Left HFClientError
22:12:40 <ertes> ah, no, it's probably (Response ByteString)
22:12:42 <woodson> function
22:12:57 <woodson> so it may return Either HFClientError
22:13:02 <metahumor> woodson: you might need parens like "  (Right . asJson =<< post ...) `E.catches` [...]  "
22:13:10 <ertes> woodson: you probably need to fmap your Right
22:13:18 <ertes> fmap Right . asJSON
22:13:19 <metahumor> or not even include "Right" there
22:13:32 <ertes> *if* you want the result to be Either-wrapped
22:13:48 <ertes> (and you clearly do, given Resp)
22:14:41 <woodson> but logically this part of the code will return asJSON =<< post "http://localhost:8080/salesforce" (toJSON hfcred)
22:14:47 <woodson> (Response HFClient)
22:15:01 <woodson> then I want to wrap it in a Right
22:15:05 <ertes> asJSON :: Response ByteString -> IO (Response HFClient)
22:15:09 <woodson> to satisfy Either
22:15:25 <ertes> if you precompose asJSON, then it must be a function of type (IO (Response HFClient) -> Y)
22:15:41 <plakband> I g2g, thanks for your help all
22:16:05 <ertes> fmap lifts Right to work on IO actions
22:16:21 <metahumor> yesss! i finally got ghc-mod to work, it was freaking out additionally because i was executing it using vim, and it tried to be too smart about finding libs
22:16:42 <ertes> fmap Right . asJSON :: Response ByteString -> Either e (Response HFClient)
22:16:47 <ertes> err
22:16:50 <ertes> fmap Right . asJSON :: Response ByteString -> IO (Either e (Response HFClient))
22:16:52 <woodson> ertes: ahh, didnt pay attention to that IO (Response HFClient) return from asJSON
22:17:26 <woodson> ertes: LOL!
22:17:32 <woodson> that all i was missing
22:17:36 <woodson> that fmap ertes...
22:17:37 <woodson> omg
22:17:50 <ertes> woodson: in the future please include at least your imports…  that makes it much easier to help you =)
22:18:12 <woodson> I thought that asJSON was just return the conversion (Response HFClient)
22:18:42 <woodson> ertes: Ya I know, but some times I feel like if there is too much code in the lpaste that scares people away
22:18:43 <woodson> lol
22:19:00 <ertes> woodson: if that were the case (it could be, if you chose (m = Maybe)), then (=<<) would be wrong
22:19:50 <ertes> woodson: the optimal paste contains the problematic code + enough context to see why it fails
22:20:04 <ertes> so yes, there is too much code, but there is also too little =)
22:21:08 <woodson> ertes: aaahhh soo many rules lol
22:21:17 <woodson> alright, ill try better next time
22:21:41 <woodson> metahumor, ertes thanks a lot seriously
22:25:14 <ertes> woodson: and again, you can just use tryJust
22:25:42 <woodson> :t tryJust
22:25:44 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
22:26:04 <woodson> will check it out.
22:26:04 <ertes> tryJust (\ex@(JSONError _) -> Just ex)
22:26:22 <woodson> ertes: honestly just started using exceptions in haskell
22:26:41 <woodson> so I'm still not comfortable with it
22:26:53 <woodson> ahh I see
22:26:57 <ertes> woodson: in fact you can even just use 'try'
22:27:09 <woodson> it just turns my maybe value to either
22:27:13 <metahumor> woodson: how important is it for you to handle the exceptions here?
22:27:13 <ertes> since you're only filtering exceptions by type
22:27:44 <metahumor> why not just let the exception happen?
22:27:48 <woodson> well the thing is that I am trying to build a small library that interacts with salesforce api
22:27:55 <woodson> and I know that it will return
22:28:05 <woodson> {error: "", error_description: ""}
22:28:10 <ertes> (the *Just catching functions enable you to filter not only based on the type, but also on a predicate…  for example you can catch only HTTP timeout errors, but not the other HTTPException errors)
22:28:11 <woodson> on bad request (400)
22:28:27 <metahumor> and what would you need to do with that json?
22:29:03 <woodson> Well since I am making the library specific I would like to return HFClientError data type
22:29:09 <woodson> instead of throw Exception
22:29:13 <ertes> woodson: if i were to design that API i wouldn't catch the exception…  if the user of 'login' wants to catch it, they can just use 'try'
22:30:07 <woodson> ertes: Thats another thing that I am facing design decision.. sooo hard
22:30:14 <ertes> woodson: if you do it for them, you might make it more awkward to work with, and there are also some safety issues due to asynchronous exceptions (you should always think twice before converting exceptions to Either)
22:30:16 <metahumor> i think dealing with exceptions should come later tbh
22:30:27 <metahumor> there are so many ways that web requests can fail
22:30:46 <woodson> well i just wanted to catch the status 400
22:31:11 <woodson> because that means there are a making a bad request and i can tell them what is actually wrong
22:31:23 <ertes> i think you should always program with exceptions in mind…  so your intentions were good, but in haskell exceptions are more complicated than in other languages due to concurrency and async exceptions
22:31:41 <ertes> woodson: if they are making a bad request, they should get an exception
22:31:43 <woodson> and also catch the jsonError in case salesforce change their api and the aeson cant do the conversion
22:32:26 <ertes> woodson: the way i would use your 'login' action is almost always like this:  login >>= either throwIO pure
22:32:38 <woodson> ertes: so its better to let them deal with that?
22:33:36 <ertes> woodson: try to answer that yourself: can you think of any reason why a user might want your API to return Either?
22:33:40 <metahumor> woodson: one of the opinions i like the most is that "websites being scraped may change"
22:33:46 <ertes> woodson: remember: they can always just use 'try'
22:34:06 <metahumor> woodson: "Rule 2: Do not be robust to design changes, do not even consider the possibility when writing the code"
22:34:38 <metahumor> this is from tagsoup's documentation, use cases are a little different, but still relevant
22:36:47 <woodson> ertes: yea.. and it would also means that I would have to return a Left for every possible exception to be true to the Either type
22:36:49 <MarcelineVQ> robust is a wierd word there
22:38:03 <ertes> woodson: there is no "true to the Either type"…  you're just doing some very specific error handling with no clear purpose
22:38:51 <ertes> woodson: imagine that 'putStrLn' would return a Bool that indicates whether the write failed due to filesystem corruption
22:39:25 <metahumor> woodson: wreq also throws exceptions with informative messages, you might not want to suppress that information
22:40:00 <ertes> woodson: if i wanted to handle that specific case, i would use 'catchJust'…  i wouldn't want to branch on a Bool, and there are two reasons for that
22:40:09 <woodson> metahumor: I was going to surpress i was going to use throwIO to throw the rest
22:40:24 <ertes> reason 1: it's inconvenient…  i have to branch every single time, because otherwise filesystem corruption might go unnoticed
22:40:48 <ertes> reason 2: it's actually unsafe…  the way to handle "error returns" in haskell is surprisingly complicated and involves 'mask'
22:41:41 <woodson> ertes: ya I did read and watch a bit about the async exception
22:41:58 <ertes> so right now the way i can use your function *safely* while handling some errors looks like this:  mask_ (login >>= either throwIO pure) `catch` …
22:42:05 <woodson> then what is consider a good reason to not let the app crash?
22:42:28 <ertes> woodson: the app doesn't crash, if the user chooses not to let it crash
22:43:15 <ab9rf> apps, ideally, will never crash
22:44:07 <metahumor> it's probably cheap to retry the request (even by the user) on crash
22:44:12 <metahumor> "fail fast"
22:44:20 <ab9rf> an app can fail, but it should never crash
22:44:42 <ertes> 'login' has no implementation-specific reason to handle the failure…  turning exceptions to Either to help the user is well-intentioned, but misguided…  in general don't do it
22:44:49 <ab9rf> i'm willing to tolerate an app crash for the extremely rare case of main memory corruption due to hardware failure
22:45:19 <ab9rf> beyond that, apps should detect and manage their own exceptions
22:46:26 <ertes> woodson: let me give you an example: i like to write applications that do what i *want* them to do:  if i'm fetching a bunch of files via an HTTP API, and there is a timeout, i don't want it to fail, because that will just drive me insane when i leave for lunch and come back just to stare at a stupid error message, just because there was a two-second network outage
22:46:51 <ertes> woodson: libraries should help me do that by throwing exceptions that i can handle in a meaningful way
22:47:14 <ertes> http-conduit throws exceptions like that, so i can simply use 'catchJust' or 'catches'
22:47:20 <ab9rf> i don't mind if libraries throw exceptions as long as they throw _useful_ exceptions
22:47:55 <metahumor> ab9rf: to a reasonable extent, i don't wantn apps to do weird things to SIGTERM, SIGINT, etc
22:48:14 <ertes> woodson: your 'login' action surpresses an exception in a misguided attempt to help me, but in reality it just gets in my way…  i now have to write *more* code in every possible case
22:48:39 <ertes> woodson: if i want to handle exceptions, i need to turn your Either back into IO exceptions…  if i don't want to handle them, i need to unpack
22:49:43 <ertes> woodson: you're also interfering with my option to control the density of exception handling…  perhaps i want to do this:  (do login; blah; blubb) `catch` …
22:50:06 <ertes> woodson: in every scenario i can think of i will use your 'login' action like this:  login >>= either throwIO pure
22:51:03 <woodson> ertes: I see. I got another question related to design. The first step is to send the login credentials which will then return an access token that must be present in every query request
22:51:39 <woodson> I was thinking that the user should handle this and pass me the token in every request of my api as well
22:52:10 <woodson> Like so, Haskforce.query Account client
22:52:24 <ertes> woodson: yeah, that's a common design
22:52:56 <metahumor> wreq also has support for Sessions
22:53:13 <woodson> Is it better for me to simply use Http types or actually create modules and function for the user?
22:53:46 <woodson> metahumor: Ya, I was also looking at it!
22:54:12 <ertes> woodson: you can wrap the token in a newtype
22:54:28 <ertes> newtype Access = Access { fromAccess :: … }
22:55:29 <ertes> woodson: a common design is to have an *.Internal module that defines stuff like Access and exports it in full, while the higher-level modules expose a "safe" API
22:55:40 <woodson> ertes: can you elaborate more on this ? Right now I am thinking transformers for some reason
22:56:39 <ertes> woodson: these are two questions: 1. how do i represent the token?  2. how do i pass it around?
22:56:47 <cocreature> just don’t forget to expose your *.Internal module or I will get angry if I try to use your lib :)
22:57:25 <ertes> woodson: you can use transformers for passing it around, although unless there is a much stronger reason to use a special monad i prefer IO functions
22:58:10 <ertes> for example sqlite-simple exposes this:  execute_ :: Connection -> Query -> IO ()
22:58:28 <ertes> it could do this:  Query -> SqliteT IO ()
22:58:32 <ertes> but i wouldn't appreciate that
23:00:39 <woodson> ertes: I see
23:00:53 <ertes> and yeah, definitely expose the *.Internal module =)
23:01:12 <woodson> I think that maybe I should look a bit at the structure of other haskell libraries
23:01:21 <woodson> because I am still not familiar
23:03:14 <ertes> woodson: sqlite-simple is a great example =)
23:03:29 <woodson> ertes: just looking at it
23:03:40 <woodson> I'm surprised that its that small
23:03:45 <woodson> I was expecting something huge
23:04:01 <ertes> woodson: it depends on direct-sqlite
23:04:06 <ertes> that's the huge one =)
23:04:28 <metahumor> similar to how wreq is on top of the HTTPBlah libs
23:04:33 <woodson> ertes: So i noticed that their Internal https://hackage.haskell.org/package/sqlite-simple-0.4.14.0/docs/Database-SQLite-Simple-Internal.html
23:04:44 <woodson> only contains types and data types
23:04:46 <cocreature> https://www.schoolofhaskell.com/user/meiersi/the-service-pattern might be worth a look as well
23:04:53 <ertes> yeah, wreq's workhorses are http-client and http-client-tls
23:05:08 <metahumor> woodson: because you often don't want to export the actual constructors
23:05:24 <ertes> woodson: the main point of that module is to expose the constructors of those types
23:05:51 <metahumor> woodson: have you done the data61 course? their follow up is exactly building a web app where you explore these design decisions
23:06:11 <woodson> cocreature: thanks
23:06:29 <ertes> woodson: it's a convention to communicate that, say, Connection is generally supposed to be an opaque type, but some users might want to access its internals in order to achieve something the high-level API doesn't support (example: direct-sqlite's blob streaming API)
23:06:48 <woodson> metahumor: no, so far just done a bunch of little project, read a lot wiki, real world haskell and the haskellbook
23:07:11 <woodson> still not done the haskell book stopped after the monad transformers
23:07:26 <ertes> the "contract" is that the internals may be unsafe and/or subject to change
23:18:11 <numberten> I have a value `A` that can be tagged one of two ways. I guess equivalent to Either A A or (A, Bool). But i want to put them in lists together such that you can only ever group things tagged the same way together
23:19:39 <numberten> i ended up using phantom types to represent the tag on a type level, which makes it easy to express the constraint that you can't have lists of separate tags
23:20:18 <ertes> numberten: ([A], Bool)
23:20:26 <numberten> but now i'm in a weird place where I want a map where values are those lists
23:20:28 <ertes> or Either [A] [A]
23:20:47 <numberten> and you couldn't have Map k (A a)
23:20:55 <numberten> where different values might have different `a`
23:21:23 <ertes> numberten: get rid of the type-level tag, otherwise you'll have to use ExistentialQuantification
23:21:44 <ertes> Map k ([A], Bool)
23:22:35 <ertes> the only difference is that your tag pertains to lists instead of individual elements
23:22:41 <numberten> i thought it might be cleaner to annotate the individual A with the tag, instead of the list
23:22:46 <numberten> but it's clunky in this case
23:22:53 <numberten> maybe also two maps could be nice too
23:22:54 <ertes> there is no real reason to express that on the type level
23:23:54 <ertes> if you do it on the type level, then for all intents and purposes (A X) and (A Y) are different types, so you have to deal with them as such
23:23:58 <numberten> other than to limit the possibility of making an error in the code between creating the A and adding it to the list
23:24:09 <numberten> yeah
23:24:30 <numberten> not ideal really, since they have the same semantics
23:24:31 <ertes> numberten: if you want that guarantee, then you can use two maps or existentials
23:24:56 <numberten> alright thanks
23:25:01 <ertes> the latter is equivalent to just using a Bool though
23:25:18 <ertes> nothing gained, nothing lost (except it's much more awkward to work with)
23:26:32 <numberten> it's been a long time since I used existentials, will probably use two maps here, if only because I know the number of tags will never expand beyond two
23:26:46 <numberten> but who knows.. maybe I'll find two maps annoying to juggle too!
23:26:54 <numberten> thanks again
23:48:27 <Digit> if "lisp is the maxwell's equations of programming", what's haskell?
23:51:06 <metahumor> navier-stokes?
