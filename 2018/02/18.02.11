00:38:56 <[exa]> hm guys is there a paper where monadic lifting is defined?
00:40:42 <[exa]> (not that it would be anything complicated to define by myself but I'm getting squeezed by page limit)
00:42:12 <johnw> [exa]: you could use "Monad Transformers and Modular Interpreters" by Liang, Hudak and Jones (1996)
00:42:36 <johnw> although that paper mention Moggi's work as being prior art on monadic lift
00:53:28 <[exa]> johnw: thanks :]
02:38:59 <anohigisavay> hello!
02:39:13 <anohigisavay> i did some printing in a test case. The output is a mess
02:39:54 <anohigisavay> it mixed with the result of other test cases
02:40:19 <anohigisavay> tasty + hunit
03:11:09 <cocreature> anohigisavay: you can always write the output to a file if you donâ€™t want it to be interleaved with test results
03:15:08 <Chtouca> I have Haskell Platform 8.2.2 64 installed and cabal install hsdev gives the following error: https://pastebin.com/8jcV643s
03:15:21 <Chtouca> How can I instal hsdev?
03:18:38 <Chtouca> I found https://github.com/haskell/old-time/issues/5
03:18:52 <Chtouca> MinGW + MSYS is installed
03:25:56 <asheshambasta> noob advice needed: I'm writing an application that has a `Conf` module that reads application configuration and creates a record containing the configs of the components of the application: things like the port number to start an http server on, the host:port of a rabbitmq backend, etc. and now I'd like this Conf record to be shared across each of the components that actually do this task. For example, I have modules that establish a
03:25:56 <asheshambasta> abbitmq connection, another one starts an http server, and each of them can add additional information along with a configuration: eg. a connection handle for rabbitmq that can be used by the http server  to send events to the MQ based on some http requests. Whats the best pattern for this kind of system?
03:31:37 <merijn> asheshambasta: Generally te pattern for this is "pass an argument to a function", although some people use ReaderT, which, in the end is basically the same thing
03:32:46 <merijn> Chtouca: Try running with -v3 to get more in depth errors?
03:35:08 <asheshambasta> merijn: okay
03:38:09 <Chtouca> merijn, it seems the problem is: Cannot find sh on the path
03:38:36 <boxscape> Say I want to write a function that converts a String into an Int, but only if the Chars are valid hex digits, and I want to return an `Either <someType> Int'. What would be the typical recommended type for someType? Text? Or some custom Exception?
03:39:41 <Chtouca> sh is in C:\MinGW\msys\1.0\bin
03:39:49 <Chtouca> perhaps including this in PATH
03:40:35 <merijn> boxscape: FYI, that function already exists :)
03:40:55 <boxscape> merijn: I know, just a toy example
03:41:12 <merijn> boxscape: I'd probably just go with Text in toy examples
03:41:30 <merijn> boxscape: Custom exception types are only useful if you plan to distinguish them
03:41:42 <boxscape> okay, that makes sense
03:42:56 <boxscape> If I *were* to use a custom exception, would it make sense to do that with the Control.Exeption module? Or is that mostly just for IO exceptions?
03:47:09 <merijn> boxscape: I'm not sure what you mean? Exceptions are always in IO, because you can't sanely throw or catch them otherwise
03:49:03 <boxscape> merijn: I really haven't looked much into Exception handling in haskell, so I may be misunderstanding things. But Control.Monad.Except for example has throwError and catchError for example, which would seem to work well with pure code
03:51:09 <boxscape> (pure as in "No IO", I suppose it might not fit some definitions of pure given that it's monadic)
03:52:38 <merijn> boxscape: Yeah, I consider that a misnomer
03:52:51 <boxscape> which part?
03:52:57 <merijn> boxscape: ExceptT is basically the transformer variant of Either. But I wouldn't call Either or Maybe exceptions
03:53:03 <boxscape> Ah, ok
03:53:13 <boxscape> fair enough
03:54:06 <merijn> With exceptions I would just refer to those from Control.Exception, which are basically just unchecked exceptions equivalent to what you have in C++, python, etc.
03:54:19 <boxscape> ok, I see
04:03:31 <phadej> someone do call Either/ExceptT *checked exceptions*
04:04:22 <merijn> phadej: I don't, because I'm trying to hack together actualy checked exceptions in System F_omega in a prototype (you know, when I have a weekend free once every half year) :p
04:04:53 <phadej> and how your checked exceptions differ from Either?
04:06:24 <merijn> phadej: You have to deal with either at every case instead of being able to bubble up easily
04:07:11 <merijn> phadej: The nice thing about exceptions is "I don't have to deal with them at a point where I don't care", the downside is "there's no way to check if I'm accidentally forgetting any"
04:07:20 <merijn> phadej: I want best of both worlds.
04:07:25 <phadej> merijn: that's what `do` notation is, isn't ?
04:07:54 <merijn> phadej: No, because now all layers above the Either need to incorporate Either too
04:08:14 <merijn> phadej: You basically can't use it with any existing code that wasn't written to accomodate either
04:08:23 <phadej> do they? if you think about (->) as forall m. Kleisli m
04:08:45 <phadej> merijn: exactly, you want to have convinient handling of "effects"
04:09:08 <merijn> phadej: Example, Either will never be a sane way to deal with division by 0
04:09:16 <phadej> merijn: See: http://benl.ouroborus.net/talks/2016-HIW-Escape.pdf
04:09:23 <merijn> phadej: Because basically 0 existing numeric code deals with "Either Error Int"
04:10:43 <merijn> phadej: That's part of the inspiration I had, yeah
04:11:08 <merijn> phadej: There was a talk on indexed extensible effects by some guy from MSR at OPLSS in 2014
04:11:37 <merijn> phadej: Sadly no one wants to pay me to hack on PLs :p
04:12:00 <phadej> yes, because in haskell we don't write `forall m. Monad m=> Kleisli m` functions. We *could*, but in Haskell it's not convinient. I'm not 100% sold that implicit combinations of them is the thing. In some domain: probably; in general: i doubt.
04:13:06 <phadej> but you still have "Either" there as an effect, if you desugar everything. It's just well hidden from the surface.
04:14:01 <merijn> phadej: Well, more generally the thing that I think is the problem in Haskell is that we keep mixing "functional" and "non-functional" properties in a *single* type, which is madness
04:14:22 <phadej> non-functional properties?
04:14:29 <merijn> phadej: non-functional being stuff like, allocation domain/policy, strictness, etc.
04:15:03 <merijn> phadej: i.e. operational details that don't describe evaluation behaviour
04:16:29 <phadej> we don't have e.g. strictness stuff in the types? do we?
04:16:56 <merijn> phadej: For example, I had a discussion with people about shared GC in haskell (which is a major bottleneck due to stop-the-world) vs erlang's per thread heaps and GC (which requires all values be shared by copying), so someone proposes "well, what if we just index by an allocation domain and ensure all thread communication explicitly copies or shares an allocation domain?"
04:17:03 <merijn> phadej: No, but it'd be nice to have
04:17:13 <merijn> phadej: You could write strictness polymorphic code if we did
04:17:54 <merijn> phadej: There's lots of things like that that'd be NICE to track, but you don't want them in our current type signatures, since they're mostly inferrable or just not that interesting 90% of the time
04:18:44 <merijn> phadej: So part of the stuff I wanted to try out in my prototype is keeping all these things separate and just have multiple typing regimes at the same time, so you could more easily add these sorts of things to track in types, without them becoming complicated messes like that "kleisli index everything"
04:18:48 <phadej> I see, still, back to topic: don't confuse beginners with saying "Either" is not "checked exceptions". It's as close to checked exceptions as we can get in *Haskell*.
04:18:53 <phadej> today.
04:22:17 <cheater> hi
04:22:39 <cheater> how long has microsoft been funding haskell research or hiring people who did research on it or languages that led up to it?
04:23:46 <EvanR> is microsoft research even funded by microsoft
04:23:48 <Rembane> At least since 1995.
04:24:15 <Rembane> Sorry, got it wrong.
04:24:28 <cheater> i know spj got hired by msr in 1998
04:30:18 <EvanR> looks like yes
04:59:30 <kendrick> I'm currently trying to use the `network` package for sockets programming, however everytime I try to bind a socket i get the error: `Network.Socket.bind, no such file or directory`, any ideas? (I'm just using the example code for sockets, running Ubuntu 16)
05:09:28 <EvanR> kendrick: provide example code on lpaste
05:10:46 <kendrick> EvanR: http://lpaste.net/362349
05:11:39 <EvanR> ah unix domain socket
05:12:05 <EvanR> no such file or directory sounds about right, have to checked that the path you specified goes somewhere
05:17:48 <kendrick> EvanR: Duh~ Thank you very much, that fixed my issue
05:30:18 <merijn> Any optparse-applicative users? Is there an easy way I can have global flags repeated for subcommands?
05:34:39 <lavalike> merijn: I wonder if Parser is a Monoid
05:37:00 <lavalike> merijn: or maybe just globalOpts <|> localOpts will do the trick
05:42:01 <merijn> lavalike: But then you'd add 2 conflicting options?
05:42:39 <merijn> lavalike: It already allows you to use global flags for sub commands, the problem is that they don't get listed in the help for them
05:42:51 <merijn> Which I just see I didn't actually write in my question :p
05:43:45 <lavalike> oh I see that it parses commands too, didn't get far enough into the docs (:
05:46:27 <lavalike> I guess that them not showing the global options in a command's help is a design decision not too easy to work around
06:03:44 <nickrandom> How can i reproduce a for in haskell?
06:04:21 <dstolfa> nickrandom: recursive function?
06:04:58 <nickrandom> Yep but
06:05:05 <nickrandom> Let me explain what i want to do
06:05:51 <dstolfa> nickrandom: well, go ahead :). it's good to ask a detailed question rather than a generic one right away
06:07:32 <EvanR> theres a multitude of things a "for" is for in other languages, which one
06:07:41 <nickrandom> http://dpaste.com/2FQ7CP8
06:07:54 <nickrandom> It is the python code for what i want to do
06:08:12 <dstolfa> nickrandom: this looks like homework
06:08:44 <dstolfa> but the answer still holds: a recursive function
06:08:50 <nickrandom> http://dpaste.com/0YEP9ES <- this works, the other one no XD
06:08:51 <EvanR> do you want to check if there is any disagreement between pairs of elements of a list?
06:09:35 <EvanR> if so, that reformulation of the question is a better starting point than "how to do a for loop", from the stand point of functional programming practice
06:09:40 <nickrandom> dstolfa, but how can I join the results? I think i could recursivelly check all the char but i don't know how to return the output
06:10:53 <EvanR> you might know about zipping to get the pair of chars from two lists
06:11:00 <EvanR> > zip "hello" "world"
06:11:02 <lambdabot>  [('h','w'),('e','o'),('l','r'),('l','l'),('o','d')]
06:11:10 <nickrandom> and then?
06:11:15 <EvanR> but in haskell you usually want to do this instead
06:11:30 <EvanR> > zipWith (/=) "hello" "world"
06:11:31 <lambdabot>  [True,True,True,False,True]
06:11:42 <EvanR> then you have
06:11:45 <EvanR> :t any
06:11:46 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:11:56 <EvanR> :t all
06:11:57 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:12:54 <EvanR> theres also this ...
06:12:56 <EvanR> :t find
06:12:58 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
06:13:36 <EvanR> and then, against the spirit of the homework entirely theres
06:13:44 <EvanR> > "hello" == "world"
06:13:46 <lambdabot>  False
06:13:54 <EvanR> eqString = (==)
06:14:25 <EvanR> (i have avoided giving then actual answer as a one liner)
06:16:08 <EvanR> especially in lazy FP its usually a better idea to figure out how to process your data with a chain of simpler intermediate steps, and not an imperative algorithm
06:16:21 <Tuplanolla> You have also neglected to explain why `zip` is useless for this problem.
06:16:56 <yorick> I'm building documentation with stack build ---haddock --no-haddock-deps as part of a CI. what's the easiest way to find the documentation after it's been built?
06:17:44 <EvanR> if i knew python i might jump to zip, then filter with inequality, then check for empty
06:18:40 <MarcelineVQ> yorick: it tells you where it puts it :>
06:18:58 <MarcelineVQ> at least, I thought it did, lemme doublecheck that :X
06:19:00 <yorick> MarcelineVQ: I know, but I'm not really feeling like grepping the output in my build script
06:19:07 <lyxia> yorick: stack haddock --open
06:19:11 <lyxia> opens in the browser
06:19:43 <yorick> I just want the location so I can cp -R ./stack-work/install/magic/doc ./my-location
06:19:57 <lyxia> ah, I missed "as part of a CI"...
06:20:20 <yorick> I mean, I could replace xdg-open with something that does what I want and call stack haddock --open
06:21:04 <MarcelineVQ> yorick: stack path --local-doc-root
06:21:14 <yorick> MarcelineVQ: thanks!
06:22:16 <yorick> that's exactly what I wanted :)
06:26:31 <nickrandom> startswith a b = all (==True) (zipWith (==) a b)
06:26:52 <nickrandom> EvanR, what do you think about this ^?
06:27:37 <EvanR> oh i see what i was missing
06:28:20 <EvanR> (==True) is the same as id
06:28:24 <EvanR> btw
06:28:45 <nickrandom> id?
06:28:52 <EvanR> @src id
06:28:52 <lambdabot> id x = x
06:30:02 <EvanR> > (==True) True
06:30:03 <lambdabot>  True
06:30:06 <EvanR> > (==True) False
06:30:08 <lambdabot>  False
06:30:11 <EvanR> > (==True) undefined
06:30:13 <lambdabot>  *Exception: Prelude.undefined
06:30:22 <EvanR> bwahaha
06:30:37 <hpc> @check \x -> (id x) == ((==True) x)
06:30:39 <lambdabot>  +++ OK, passed 100 tests.
06:30:46 <EvanR> > (==True) (let x = x in x)
06:30:49 <lambdabot>  *Exception: <<loop>>
06:31:11 <EvanR> (does quickcheck check bottoms?)
06:32:46 <hpc> not sure
06:52:30 <CritJongUn> hello
06:52:48 <CritJongUn> i'm having doubts about an exercise on Monad Challengses
06:53:02 <CritJongUn> my solution is here http://lpaste.net/5424104190844600320
06:53:08 <CritJongUn> my question is
06:53:57 <CritJongUn> why should tailMax :: Ord a => [a] -> Maybe (Maybe a) and not
06:53:58 <CritJongUn> tailMax :: Ord a => [a] -> Maybe (Maybe a)
06:54:14 <CritJongUn> ups * tailMax :: Ord a => [a] -> Maybe a
06:55:41 <merijn> CritJongUn: I don't see where it says that type?
06:56:23 <CritJongUn> merijn encoded in the second hex string
06:56:36 <merijn> ah, I can't be arsed to decode that, tbh
06:57:34 <MarcelineVQ> what's the type of combine
06:57:54 <EvanR> they dont even have the decency to give hints in rot13
07:00:12 <cocreature> CritJongUn: you havenâ€™t really followed the instructions: you are supposed to implement transMaybe and use that to implement tailMax and tailMin
07:00:15 <CritJongUn> merijn: i wrote it
07:00:23 <CritJongUn> tailMax :: Ord a => [a] -> Maybe (Maybe a)
07:01:38 <CritJongUn> cocreature: transMaybe :: (a -> b) -> Maybe a -> Maybe b
07:01:54 <CritJongUn> cocreature: maybeMap :: (a -> b) -> Maybe a -> Maybe b
07:07:09 <cocreature> CritJongUn: you are supposed to use "transMaybe" (or maybeMap assuming that does the same thing) and "maximumMay" from one of the previous exercises. then youâ€™ll end up with the type signature in the exercise
07:09:03 <merijn> ugh...<$> and $ don't play nice together :\
07:09:25 <EvanR> more $ more problems
07:09:50 <adamCS> EvanR: :)
07:09:56 <merijn> Sadly less $ also more problems :p
07:10:28 <hpc> mo $ mo problems
07:10:32 <Rembane> There's an optimal amount of $.
07:10:45 <Rembane> But you can never have too many parentheses.
07:10:57 <merijn> Rembane: Eh, yes you can :p
07:11:03 <merijn> Rembane: ever read Lisp? :p
07:11:14 <Rembane> merijn: And I survived! :D
07:11:32 <EvanR> ) soup
07:12:29 <Rembane> Tasty soup
07:12:32 * EvanR goes back in time and changes history to either convince lisp people to use [ and ] or swap the keyboard positions of [ ] and ( )
07:13:21 * MarcelineVQ goes back just after EvanR and convinces them to use \ /
07:13:26 <EvanR> seriously holding shift for 96% of the source code?
07:13:38 <EvanR> this is like mario kart
07:13:44 <amalloy> EvanR: i swapped my 1234567890 row with !@#$%^&*()
07:13:52 <EvanR> hahahaha
07:14:01 <amalloy> tbh it's great. who types numbers?
07:14:41 <EvanR> thats crazy enough to work
07:15:13 * EvanR yanks out and turns each of those keys 180 deg
08:14:06 <Digit> EvanR: i cant help but think of the lisp machine in https://www.youtube.com/watch?v=uk3A41U0iO4 where mentions the emacs keys and bindings, i would not be surprised how much lisp took from that machine too.
08:26:02 <parsnip> M-x/27
08:31:20 <nickrandom> Can i change the value of an array in haskell?
08:31:53 <nickrandom> For example, if i have: let a = [1, 2, 3] can i change the 2nd value of a (2) with another number?
08:32:20 <maerwald> that doesn't look like an array
08:32:30 <nickrandom> Something like a[1] = 42
08:32:43 <nickrandom> maerwald, it isn't?
08:33:13 <maerwald> it's a list
08:33:18 <amalloy> you can't change the value of anything
08:33:24 <nickrandom> What's the difference?
08:33:28 <maerwald> there are mutable arrays though
08:33:38 <maerwald> but it seems to me you are confused about the basics
08:33:38 <merijn> amalloy: Sure you can
08:33:42 <maerwald> are you following a tutorial?
08:33:47 <merijn> amalloy: You just have to be in STM, IO, or ST
08:33:53 <nickrandom> Not really
08:33:59 <merijn> amalloy: Haskell has perfectly sensible mutable arrays
08:34:03 <maerwald> yep
08:35:07 <amalloy> merijn: sure, but that's not helpful stuff to say to someone who doesn't know an array from a list and wants to know if you can mutate it
08:35:09 <maerwald> nickrandom: are you trying to learn haskell?
08:36:01 <maerwald> I don't see how it's helpful to say something that is wrong?
08:36:11 <nickrandom> i am
08:36:31 <maerwald> @where cis
08:36:32 <lambdabot> I know nothing about cis.
08:36:36 <maerwald> how did that work again
08:36:58 <Tuplanolla> @where cis194
08:36:59 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
08:37:04 <maerwald> nickrandom: ^
08:47:14 <concaveirc> Anyone know why casting an out-of-bounds Int as a Word8 wrapps the value around instead of throwing an exception?
08:48:12 <concaveirc> Or, more concretely, why (-1 :: Pixel8), where Pixel8 is JuicyPixel's alias for Word8, just gives 65535 rather than exception?
08:49:03 <mmaruseacph2> because 0xffff (what will be the representation of -1 in a signed datatype) is 0xfff (what will be the representation of 65535 on an unsinged datatype)
08:49:11 <Tuplanolla> Don't you at least get a warning, concaveirc?
08:49:19 <mmaruseacph2> *0xffff in both cases
08:49:21 <monochrom> No, no warning.
08:49:32 <concaveirc> Tuplanolla: I get a warning
08:49:34 <monochrom> Also, 65536 would be 16 bits, Word16.
08:49:50 <merijn> concaveirc: Because that's how fromIntegral is defined to behave
08:50:03 <concaveirc> Woops, I was mixing up cases, as in actuality I am working with Word16 too.
08:50:05 <merijn> concaveirc: Also, you can't reliably catch the exception if it was thrown anyway
08:50:33 <concaveirc> A guess. Its just that I am property testing functions which I would prefer not to wrap values.
08:50:33 <monochrom> Ah but division by zero throws an exception
08:50:38 <merijn> monochrom: There's a warning know, I think?
08:50:42 <merijn> s/know/now
08:50:53 <concaveirc> And if an exception occurred I could at least check that property.
08:50:55 <monochrom> I'm outdated on the warning part.
08:51:20 <merijn> monochrom: I recall a warning for out-of-bounds integers being added at least for some types, anyway
08:51:22 <Tuplanolla> In general, the more sour people grow over integer overflows, the better.
08:51:25 <concaveirc> I could just break up the function into two parts, one which returns an Int and the other which casts it, though that seems like too much work.
08:52:11 <merijn> monochrom: -Woverflowed-literals
08:52:13 <concaveirc> Tuplanolia: People are sour over integer overflows? I know that I am, as it seems against my understanding of Haskell, but I am sure it is welcome in other languages.
08:53:07 <Tuplanolla> I've yet to find a programming language that handles it appropriately.
08:53:10 <merijn> concaveirc: Also, for a proof-of-concept solution to this sorta problem, see http://hackage.haskell.org/package/validated-literals
08:53:27 <merijn> I plan on revisiting that package and making it production ready Real Soon Now (TM)
08:53:50 <[Leary]> Using WordN to naturally represent the Integers mod 2^N seems pretty Haskell to me.
08:53:50 <kuribas> haskell int isn't a mathematical integer
08:54:03 <kuribas> though Integer is
08:54:14 <qeyoa> In tidal cycles library i'm using the '#' symbol to apply effects to sounds: `d1 $ sound "bd" # cutoff 100`
08:54:14 <qeyoa> I wanted to see if the `#` was part of the haskell language and found this:
08:54:14 <qeyoa> "The language extension -XMagicHash allows "#" as a postfix modifier to identifiers. Thus, "x#" is a valid variable, and "T#" is a valid type constructor or data constructor."
08:54:14 <qeyoa> Am i looking at the same thing here, or is the `#` symbol construct of the tidal cycles library and not a native symbol in the haskell language?
08:54:59 <concaveirc> merijn: That would also be a property test, though at the moment I am using Hedgehog for this. However, it seems your solution tests via proof rather than counterexample, which is nice.
08:54:59 <concaveirc>  
08:55:15 <merijn> concaveirc: My solution doesn't test at all
08:55:34 <concaveirc> merijn: No, but it enforces via type system, right?
08:55:36 <merijn> concaveirc: It performs the conversion at compile time, then fails the compilation if the conversion fails
08:56:03 <lyxia> qeyoa: this is something different.
08:56:03 <merijn> qeyoa: # is just a regular operator
08:56:08 <concaveirc> merign: Got it.
08:56:26 <merijn> qeyoa: MagicHash is something different related to allowing # in alphanumeric names to indicate builtin primitives
08:56:34 <qeyoa> thanks
08:57:07 <merijn> > let (#) = (+) in 3 # 4 -- qeyoa
08:57:09 <lambdabot>  <hint>:1:7: error: parse error on input â€˜)â€™
08:57:13 <merijn> heh
08:57:21 <merijn> Does lambdabot have magichash enabled?
08:57:31 <merijn> That'd be annoying
08:57:48 <MarcelineVQ> > let foo# = 3 in foo#
08:57:50 <lambdabot>  3
08:58:01 <hpc> > 3 :: Int#
08:58:03 <lambdabot>  error:
08:58:03 <lambdabot>      Not in scope: type constructor or class â€˜Int#â€™
08:58:03 <lambdabot>      Perhaps you meant one of these:
08:58:08 <MarcelineVQ> looks like it
08:58:44 <hpc> i wonder why, if it's not going to have anything in scope that uses it
08:59:09 <merijn> hpc: You can add imports, no?
08:59:20 <merijn> hpc: And GHC.Exts is not unsafe, so
08:59:37 <EvanR> not unsafe, i feel safer already
08:59:55 <hpc> i feel not unsafer already
09:03:00 <hpc> @let import GHC.Exts
09:03:01 <lambdabot>  .L.hs:134:1: error:
09:03:01 <lambdabot>      GHC.Exts: Can't be safely imported! The module itself isn't safe.
09:03:02 <lambdabot>      |
09:03:12 <hpc> lol
09:04:07 <EvanR> it can be unsafely imported?
09:04:57 <EvanR> safety and double negation are such killjoys
09:05:59 <hpc> you have to negate both sides
09:06:04 <hpc> it can be unsafely unimported
09:06:20 <kuribas> anyone has experience with reading audio files (WAV)?  What's a good library?
09:06:37 <hpc> safety isn't itself the module :P
09:07:25 <hpc> kuribas: do you just want to play it, or do manipulations with its data as well?
09:07:56 <kuribas> hpc: just some interactive testing on the wave data
09:08:04 <hpc> hmm, no clue then
09:08:41 <kuribas> hpc: Fourier transform etc...  I'd like to try out the algorithm so I can then implement in on a atmega Âµcontroller
09:09:09 <EvanR> kuribas: hmm... wavy has a blog post explaining how awesome it is
09:09:53 <hpc> https://hackage.haskell.org/package/HCodecs maybe
09:10:08 <hpc> although it's pretty old
09:11:27 <EvanR> https://bitbucket.org/robertmassaioli/wavy
09:11:54 <kuribas> hm, there doesn't seem to be much difference between these.
09:13:38 <hpc> there's another one called "wave", but i couldn't tell how to get the actual audio data out of it
09:15:11 <kuribas> hpc: it seems waveDataOffset is an offset into the actual wave data
09:16:44 <adamch> Hello! I'm using Stack for the first time, and I'm getting a build error because Stack can't find Data.Map :|
09:16:58 <adamch> Does anyone have any ideas why?
09:17:47 <cocreature> adamch: have you added the containers package to build-depends?
09:18:23 <adamch> I haven't! I thought Data.Map was just part of the stdlib.
09:18:37 <adamch> That works, thank you :)
09:18:40 <MarcelineVQ> https://docs.haskellstack.org/en/stable/GUIDE/
09:18:49 <cocreature> adamch: hoogle can be quite handy for figuring out which package a module comes from http://hoogle.haskell.org/?hoogle=Data.Map%20is%3Amodule
10:08:46 <srid> with haddock running, cpu usage is full and memory up to ~10G. so, haddock doesn't take advantage of multiple cores.
10:11:44 <ertes> dammitâ€¦  i always forget to update the changelog before release
10:13:05 <kj_> l
10:13:08 <kj_> hi
10:14:45 <lambdabot> Hello.
10:14:58 <nickrandom> thanks maerwald <3
10:15:31 <boxscape> lambdabot can say hello?
10:16:07 <monochrom> The waterfall model solves this problem by requiring you to update your changelog first and then you code and test to the specification in the changelog. :)
10:19:08 <boxscape> That justs shifts the problem from having to remember updating the changelog to having to remember coding and testing ;)
10:19:30 <ertes> monochrom: i'd probably just end up not coding at all in that model
10:19:39 <hpc> boxscape: not writing the code is an optimization
10:19:44 <hpc> you get the feature, without any performance cost
10:19:59 <boxscape> hm, I'd say that might count as one of those dreaded premature optimizations
10:20:07 <merijn> ertes: You'd probably be happier that way too :p
10:20:29 <hpc> boxscape: in this way i have written a remarkable database, even more performant than /dev/null :D
10:20:46 <ertes> "yeah, you have to write that feature firstâ€¦  i just wrote the changelog entry for your in advance"
10:21:24 <ertes> merijn: nah, despite my grumping i actually enjoy coding a lot =P
10:22:32 <lambdabot> Hello.
10:22:51 <lavalike> Hi.
10:23:11 <shapr> hi?
10:23:17 <shapr> WASSUP MAH HASKELL PEOPLE?
10:23:21 * shapr hops excitedly
10:23:24 <shapr> I think the coffee is working.
10:23:28 <lavalike> boing boing boing boing
10:23:33 <shapr> wheeee!
10:24:07 <shapr> I'm preparing to code Haskell, I redid my emacs config last night and now I'm re-fixing interactive-haskell-mode so it's happy with cabal new-repl
10:24:35 <shapr> lavalike: are you coding something neat?
10:26:58 <lavalike> shapr: not at this moment!
10:28:29 <boxscape> is there a nice way to find the Keys associated with a value (rather than the value associated with a key) of a Data.Map.Map?
10:29:09 <kj_> what's a fast method to keep only the first half of an Array i e?
10:29:41 <fr33domlover> boxscape, afaik either walk the whole map for that, or maintain an extra map for that if it matters for performance etc.
10:29:50 <boxscape> ok, thanks
10:30:44 <fr33domlover> i.e. Map k v and an additional Map v (Set k) or something like that for these "reverse" lookups
10:30:52 <ertes> there are spectres in lambdabot's shell
10:31:42 <ertes> what was the question?
10:32:31 <boxscape> fr33domlover: yeah I don't think I'll need to do that, there's less than a hundred elements in the Map anyway
10:32:33 <shapr> isn't there a bidirectional map?
10:32:41 <ertes> there is ixset
10:32:47 <lavalike> kj_: maybe runST . freeze . take n . thaw
10:32:59 <ertes> alternatively there are in-memory sqlite databases
10:33:05 <Adluc> boxscape: https://hackage.haskell.org/package/bimap-0.3.3/docs/Data-Bimap.html
10:33:07 <ertes> (just open a connection to ":memory:")
10:33:11 <boxscape> thanks, I'll look into that
10:33:16 <Adluc> isnt this the thing for bidiretional stuff?
10:33:38 <lavalike> kj_: now that I think about it take is actually generic enough to work on any vector
10:33:57 <ertes> Bimap doesn't seem to be the answer, because it maintains a 1:1 relationship
10:34:07 <ertes> ixset can do 1:n or m:n relationships
10:34:11 <boxscape> yeah I don't actually have a bijection
10:34:16 <boxscape> I suppose I'll take a look at ixset
10:35:07 <kj_> lavalike, thanks, let me give it a try
10:35:32 <hexagoxel> Ambiguous occurrence â€˜<>â€™ raah, thanks ghc-8.4.
10:36:27 <ertes> boxscape: there is also ixset-typed, but i don't know if it involves additional boilerplateâ€¦  ixset is really simple to use
10:36:37 <hexagoxel> I am a bit curious if there is a solution without CPP that works across 7.0 - 8.4 here..
10:36:54 <merijn> hexagoxel: why the hell are you still supporting 7.0?!
10:37:24 <boxscape> ertes: ok, thanks
10:38:18 <kj_> also, is there something like `maximumBy` function for Array that can find me the index and the maximum value?
10:39:07 <ertes> kj_: are you using 'array' or 'vector'?
10:39:29 <lavalike> kj_: https://www.stackage.org/haddock/lts-10.5/vector-0.12.0.1/Data-Vector-Generic.html check in the generic module
10:39:30 <kj_> ertes, Array.
10:39:54 <lavalike> oh.
10:39:55 <ertes> kj_: you should probably switch to 'vector' then, which has lots of list-like and some non-list-like functions predefined
10:39:58 <starlord_> I just ported my Parsec application to Megaparsec but I can't figure out how to ignore block comments (I only want line comments in my language).
10:40:17 <starlord_> I'm doing something like sc = L.space space1 lineCmnt failure
10:40:41 <starlord_> But failure is obviously not defined
10:41:54 <kj_> ertes, thanks. i'm using an audio processing library (pulse-simple) which uses Array so i kinda built everything upon it
10:43:44 <kj_> lavalike, thanks. i'll turn to Vector instead
10:45:02 <kj_> i must be dreaming. it's not using Array at all but [Float]
10:48:01 <ertes> kj_: ah, well, that may be a reason to stick with 'array' then
10:49:23 <ertes> kj_: the API of 'array' is rather sparse though, so another option would be to push for pulse-simple to switch to 'vector' =)
10:50:27 <ertes> (or convert back and forth between the two, which you can do at no/constant run-time cost with some trickery)
10:51:54 <kj_> ertes, thanks. I was dreaming. it is using list. not sure why i remember it wrong. but i can switch to vectory painlessly now
10:52:12 <kj_> *vector
10:54:33 <lyxia> starlord_: failure = empty
10:55:15 <lyxia> starlord_: in the documentation it says "If you don't want to allow a kind of comment, simply pass empty"
11:01:17 <starlord_> lyxia: Thanks! I checked the docs but must have missed that
11:02:49 <parsnip> what's name for opposite of fold
11:03:23 <dstolfa> parsnip: i guess unfold?
11:03:39 <parsnip> was going to say. yeah i'll go with that, unfoldDigits
11:04:13 <newbie1> Newbie here trying out guards for the first time and running into some errors, looking for some guidance http://lpaste.net/362359
11:05:25 <merijn> newbie1: What errors?
11:07:10 <merijn> Actually, that type makes no sense
11:07:41 <geekosaur> the type is confused, yes
11:08:09 <newbie1> should I some how make it more clear?
11:08:11 <geekosaur> charlist and intlist are parameters. the signature is trying to reuse those names... btu that means osmething different at type level
11:08:17 <geekosaur> [Char] and [Int]
11:08:38 <geekosaur> and [x] makes no sense at all: since "x" is used nowhere else, it means any type at all
11:08:42 <geekosaur> which I doubt is what you intended
11:09:06 <newbie1> From my understanding [x] specifies a list return type
11:09:07 <geekosaur> (because there is no concrete value that inhabits all types; only nontermination does so)
11:09:13 <geekosaur> a list of *what*?
11:09:25 <geekosaur> "x" by itself, used nowhere else, means "completely unknown"
11:09:46 <geekosaur> "list" is not a sufficiently specified type to have values
11:09:55 <newbie1> I'm pretty dang lost here, let me do some reading
11:10:08 <ertes> which is not the name "x" specifically, but any lower-case name you're not using anywhere else:  [y] would be the same as [x] here
11:11:12 <newbie1> So does [Char] (since its capital C) means a list of chars specifically
11:11:32 <geekosaur> yes. Char is a specific type
11:11:37 <geekosaur> Int is a specific type
11:11:47 <geekosaur> charlist is an undefined name... which at type level could be anything
11:12:14 <geekosaur> the fact that it has meaning at *value* levle, as a parameter, does not affect tis meaning at the level of *types*
11:12:20 <geekosaur> *its meaning
11:12:41 <ReinH> Might be useful to mention that the charlist used in the definition and the charlist used in the type declaration are unrelated
11:12:49 <ReinH> even though they are spelled the same
11:13:18 <geekosaur> isn't that what I just said? and, uh, the second thing I said on this [11 19:07:49] <geekosaur> charlist and intlist are parameters. the signature is trying to reuse those names... btu that means osmething different at type level
11:13:31 <ReinH> geekosaur: Ok, I didn't read everything apparently
11:13:48 <geekosaur> I can also have a *value* called Int; it would not be related to the *type* Int
11:13:49 <newbie1> Whats the keyword for a tuple ?
11:13:57 <newbie1> [Tuple]?
11:14:15 <geekosaur> you specify it by its shape. (Int,Char) or whatever
11:14:21 <ReinH> Tuples are constructed with braces and commas, like (1,2)
11:14:24 <geekosaur> with the parentheses
11:14:25 <newbie1> I tried doing :t in terminal is there a way to get something like [1,2] is a [Int]
11:14:35 <ReinH> [1,2] is not a tuple
11:14:57 <merijn> johnw: ping? :)
11:15:00 <geekosaur> :t [1,2] -- this will not resolve to Int because, without other context, numeric literals can reflect any numeric type
11:15:01 <lambdabot> Num a => [a]
11:15:06 <newbie1> I understand but I'm trying to figure out what to put in the braces for tuple as a specific list param
11:15:08 <ReinH> The type for a list of Int is spelled [Int]
11:15:10 <geekosaur> which is what the "Num a =>" means
11:15:19 <geekosaur> :t [1::Int,2,3]
11:15:20 <lambdabot> [Int]
11:15:35 <ReinH> The type of a list of Char is spelled [Char]. The type for a list of (Int,Char) is spelled [(Int,Char)]
11:16:29 <geekosaur> "given some type 'a' which has an instance of the typeclass 'Num', ..." (beware: typeclasses are not OOP classes)
11:16:41 <ertes> here is a tuple of booleans:
11:16:45 <ertes> :t (True, False)
11:16:46 <lambdabot> (Bool, Bool)
11:16:51 <ertes> here is a list of booleans:
11:16:55 <ReinH> It looks like the type signature you want is pairs :: [Char] -> [Int] -> [(Char,Int])
11:16:57 <ertes> :t [False, True, True]
11:16:58 <lambdabot> [Bool]
11:17:05 <ertes> here is a list of tuples of booleans:
11:17:12 <ReinH> I'll also note that you don't need to use '#' or -1 to represent a missing thing. That is what Maybe is for.
11:17:13 <ertes> :t [(True, False), (False, True)]
11:17:14 <lambdabot> [(Bool, Bool)]
11:17:24 <ertes> newbie1: ^ these examples might be helpful
11:17:45 <ReinH> And that you shouldn't use length to check if a list is empty, you should use pattern matching
11:17:48 <newbie1> SO what I want as my sig is pairs :: [Char] -> [Int] -> [(Char,Int)] is what I'm getting from all this info
11:18:26 <merijn> newbie1: That certainly looks like a far more reasonable type, yes :)
11:18:27 <ertes> newbie1: if 'pairs' is supposed to do what it sounds like, then yeah =)
11:20:15 <newbie1> :D That was so satisfying! THANKS GUYS
11:20:39 <newbie1> or any other pronoun*
11:22:42 <ReinH> Hmm, it would be nice if lambdabot had Data.Align in scope
11:22:59 <geekosaur> @let import Data.Align
11:22:59 <lambdabot>  .L.hs:65:1: error:
11:22:59 <lambdabot>      Could not find module â€˜Data.Alignâ€™
11:23:00 <lambdabot>      Perhaps you meant Data.Aeson (from aeson-1.2.3.0)
11:23:02 <geekosaur> aw
11:25:17 <ReinH> > let { pairs (x:xs) (y:ys) = (Just x, Just y) : pairs xs ys; pairs (x:xs) [] = (Just x, Nothing) : pairs xs []; pairs [] (y:ys) = (Nothing, Just y) : pairs [] ys; pairs [] [] = []; } in pairs "foo" [1,2]
11:25:18 <lambdabot>  [(Just 'f',Just 1),(Just 'o',Just 2),(Just 'o',Nothing)]
11:27:39 <ertes> :t foldr (\x go ys' -> case ys' of y:ys -> (Just x, Just y) : go ys; [] -> (Just x, Nothing) : go []) (map (\y -> (Nothing, Just y)))
11:27:40 <lambdabot> Foldable t => t a1 -> [a2] -> [(Maybe a1, Maybe a2)]
11:27:51 <ertes> > foldr (\x go ys' -> case ys' of y:ys -> (Just x, Just y) : go ys; [] -> (Just x, Nothing) : go []) (map (\y -> (Nothing, Just y))) "foo" [1,2]
11:27:52 <lambdabot>  [(Just 'f',Just 1),(Just 'o',Just 2),(Just 'o',Nothing)]
11:29:06 <ReinH> > align "foo" [1,2]
11:29:06 <ReinH> [These 'f' 1,These 'o' 2,This 'o']
11:29:08 <lambdabot>  error:
11:29:08 <lambdabot>      Variable not in scope: align :: [Char] -> [Integer] -> t
11:29:18 <ReinH> oh sorry lambdabot that's my bad
11:29:21 <ReinH> @botsnack
11:29:21 <lambdabot> :)
11:29:39 <MarcelineVQ> https://hackage.haskell.org/package/these   https://hackage.haskell.org/package/align  if you're wonder what this madman is up to
11:29:50 <ReinH> align is in these
11:29:55 <ertes> lambdabot: see?  if you're not acting like a dick, you can get snacks!
11:30:08 <ReinH> the align package is something else
11:30:45 <ReinH> ertes: :)
11:30:50 <MarcelineVQ> my mistake
11:30:56 <ReinH> MarcelineVQ: np
11:31:14 <ReinH> The align package looks cool though
11:31:32 <ertes> the semigroupoids package is also very useful
11:32:30 <ReinH> ertes: In general or related to the discussion?
11:32:53 <ertes> related
11:33:09 <ertes> most Aligns are also Pluses and Applys
11:33:14 <ertes> and vice versa
11:33:22 <ReinH> Ah
11:33:38 <ertes> and some Applys are also Binds =)
11:33:39 <shapr> are there cases where foldl is a better option than foldl' ? I'm guessing if I have to ask, I'm not at the point where I should use foldl
11:34:09 <ertes> shapr: if you're constructing a structure that doesn't benefit from evaluation
11:34:37 <ertes> > foldl (flip (:)) [] "abc"  -- this doesn't benefit from foldl'
11:34:39 <lambdabot>  "cba"
11:34:49 <ReinH> shapr: I've only seen contrived cases where foldl is strictly better
11:34:51 <shapr> coworker snagged on foldl during advent of code, and got a bunch of frustration
11:35:07 <ReinH> but foldl' might not force enough so foldl might not be worse
11:35:16 <shapr> then coworker asked if use of foldl could fire a deprecation warning that said "use foldl' unless you REALLY know what you're doing"
11:35:28 <ReinH> I think the most common one is folding over a tuple
11:35:37 <ertes> shapr: here is an easy rule of thumb is:  if you're building data spines or (most) functions, foldl is better
11:35:52 <kj_> ertes, sorry. what's the trick that you mentioned that can convert Array to Vector in constant time?
11:36:19 <ertes> kj_: i'm assuming we're talking about mutable arrays?
11:36:32 <ReinH> The other case is when the folding function is non-strict in its first argument
11:36:51 <shapr> hmm
11:37:03 <kj_> ertes, yes sure we can.
11:37:21 <ReinH> > let _ ? 0 = 0; x ? y = x * y in foldl (?) 1 [2,3, undefined, 4]
11:37:22 <lambdabot>  *Exception: Prelude.undefined
11:37:32 <ReinH> wait what
11:38:03 <ertes> kj_: https://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array-Unsafe.html#v:unsafeForeignPtrToStorableArray
11:38:49 <ReinH> oh oops
11:38:52 <ReinH> > let _ ? 0 = 0; x ? y = x * y in foldl (?) 1 [2,3, undefined, 0]
11:38:54 <lambdabot>  0
11:39:01 <ReinH> > let _ ? 0 = 0; x ? y = x * y in foldl' (?) 1 [2,3, undefined, 0]
11:39:03 <lambdabot>  *Exception: Prelude.undefined
11:39:16 <ReinH> shapr: This is the sort of contrived thing I was talking about.
11:39:22 <ReinH> I've never needed to use this property in real life
11:39:32 <ertes> ReinH: and that one is still better implemented in terms of foldl' =)
11:39:37 <ReinH> (That example is from https://wiki.haskell.org/Foldr_Foldl_Foldl'#Foldl)
11:39:40 <ReinH> ertes: how so?
11:39:45 <shapr> and I guess we can't just slip foldl' into the place of foldl in the Prelude?
11:40:02 <kj_> ertes, wow, that's quite beyond my knowledge
11:40:04 <ertes> oh, wait, your 0 comes *after* undefined
11:40:07 <ReinH> They are not denotationally equivalent, so it would be a breaking change
11:40:08 <ReinH> ertes: yes
11:40:20 <ReinH> which is why it needs to be a left fold, but not a foldl'
11:40:47 <ertes> kj_: then don't bother with itâ€¦  if you must convert, convert by copyingâ€¦  you can always replace copying by this later, once you understand it =)
11:41:25 <RyanGlScott> So I'm baffled by an apparent inconsistency in the way rank-n types work, and I'm hoping someone can explain what is going on.
11:41:39 <RyanGlScott> The oddness is in here: http://lpaste.net/362361
11:41:53 <RyanGlScott> All of those definitions typecheck except for the last one (idExists3)
11:42:06 <RyanGlScott> Does anyone know why it wouldn't typecheck?
11:42:35 <kj_> ertes, thanks :)
11:43:03 <ertes> RyanGlScott: my first guess would be that it's not related to RankNTypes itself, but to *pattern-matching* on a higher-rank field
11:43:46 <ertes> @let data Exists f = Exists { fromExists :: forall a. f a }
11:43:47 <lambdabot>  Defined.
11:43:49 <RyanGlScott> Perhaps so. I titled that snippet "bug" because that's the first thought that came to mind, but perhaps this is expected behavior.
11:44:17 <RyanGlScott> I'm not enough of a rank-n type practitioner to say definitively.
11:44:40 <ertes> @let f :: Exists Identity -> Exists Identity; f (Exists (Identity x)) = _
11:44:41 <lambdabot>  .L.hs:188:27: error:
11:44:41 <lambdabot>      â€¢ Found hole: _ :: Exists Identity
11:44:42 <lambdabot>      â€¢ In the expression: _
11:44:45 <ertes> meh
11:47:15 <ertes> RyanGlScott: i don't know if it's expected, but i would assume that the moment you pattern-match on Identity you make a choice for 'a', and GHC thinks that this choice is more specific than the type required for Exists
11:47:34 <ertes> this is probably just an unhandled case in GHC
11:47:46 <ReinH> shapr: Ok, the one non-contrived foldl example that relies on laziness that I can think of is
11:47:56 <ReinH> > let last = foldl (\_ x -> x) (error "tail: empty list") in last [1,2,3]
11:47:57 <lambdabot>  3
11:48:36 <shapr> if it took that much work to find an example, can GHC fire a warning when foldl is used instead of foldl' ?
11:49:44 <lyxia> RyanGlScott: If you consider a different Exists with a class constraint,  Exists (forall a. Num a => f a)  it makes sense to have a monomorphic value when pattern matching, maybe that's related?
11:50:05 <RyanGlScott> ertes: It still baffles me though, since you make a similar "choice" when invoking the record selector
11:50:28 <RyanGlScott> Also, you can write this:
11:50:38 <RyanGlScott> `blah :: Exists f -> f a; blah (Exists f) = f`
11:51:00 <RyanGlScott> GHC only seems to get cranky when you instantiate `f` with something
11:51:01 <ertes> RyanGlScott: that's not surprising thoughâ€¦  you could even make a specific choice for 'a' there
11:51:41 <ertes> f :: Exists Identity -> Int; f (Exists (Identity x)) = x
11:51:42 <ertes> works
11:52:48 <RyanGlScott> Even `f :: Exists Identity -> a`, as it turns out...
11:53:04 <RyanGlScott> Bah, this is hella confusing
11:53:07 <dmj`> RyanGlScott: what happens if you try to provide an explicit type signature for x in id3, (x::forall a. a)
11:53:22 <ertes> yes, this problem only occurs when you're passing the 'x' to a function that expects a *polymorphic* value
11:53:56 <RyanGlScott> Adding a pattern signature makes no difference
11:54:26 <shapr> SharpGAF: some people think I have the first part of your name
11:54:27 <Gurkenglas_> If I have Int -> a and an Int and keep applying one to the other or adding to my Int, can I store that as Int -> a which I keep applying 0 to or precomposing
11:54:34 <ertes> the Exists constructor is one of those
11:54:41 <ertes> Exists :: (forall a. f a) -> Exists f
11:55:09 <ertes> i assume this happens when *reifying* polymorphism
11:55:17 <Gurkenglas_> Addition to without running into the problem where I have to do linear work each time I apply to 0?
11:55:59 <RyanGlScott> Right. My confusion is: why would (runIdentity i) suffice for a constructor expecting a polymorphic value, but not the field of Identity itself?
11:57:28 <RyanGlScott> Hah, this works
11:57:36 <RyanGlScott> `idExists3 (Exists (Identity (x :: forall a. a))) = Exists (Identity x)`
11:57:44 <RyanGlScott> If you turn on ImpredicativeTypes
11:58:23 <merijn> RyanGlScott: That's...risky anyway
11:58:30 <RyanGlScott> merijn: Believe me, I know ;)
11:58:42 <Gurkenglas_> Perhaps I can cheat in an Int storage by seeing it as ((Int -> a) -> r) -> r?
11:58:50 <ReinH> shapr: I'm not arguing against GHC firing a warning.
11:58:57 <merijn> Maybe I should propose to add warnings/deprecation for impredicativetypes *again* >.<
11:59:33 <RyanGlScott> merijn: I'd heartily support such a proposal, under the condition that we still allow things like coerce @(forall a. [a]) @(forall a. MyList a)
12:00:05 <newbie1> Alright I'm a bit confused again. Trying to make a polymorphic function http://lpaste.net/362364 and am just lost on the paramaters again.
12:00:18 <merijn> I've proposed it a few times before, followed by a bunch of people responding: "What if anyone uses it?!" to which my response is "How could anyone use it if no one knows if it even works?!" >.>
12:00:35 <ReinH> newbie1: If you start with an 'a', how do you end up with a 'b'?
12:00:44 <merijn> newbie1: Well, how do the a's in your input magically turn into b's? :)
12:00:45 <RyanGlScott> Moreover, there's ample evidence to suggest it _doesn't_ work
12:00:53 <ReinH> newbie1: Also you should be using pattern matching, not head and tail
12:01:29 <merijn> RyanGlScott: Well, afaict from my discussion with SPJ there's no actual theoretical model for it, so you can't even say "it doesn't work", because no one has defined what "works" even means
12:01:30 <newbie1> Sorry my original header is this flatten :: [[]] -> []
14:04:01 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
14:04:01 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
14:04:22 <phadej> and groups are introduced from the "smallest" axiom set
14:05:51 <fresheyeball> Anyone out there use the quickspec library?
14:06:17 <fresheyeball> I can't tell wether it sucks horribly or that I can't see how it works
14:06:22 <fresheyeball> I assume the later
14:06:37 <phadej> nice book in every other aspect though
14:06:43 <n_blownapart> maybe a different question: what advantage does the program have, by switching off the evaluations like that? http://lpaste.net/362373
14:09:00 <Cale> fresheyeball: What are you trying it on, and what equations are you hoping to discover?
14:09:36 <fresheyeball> Cale: well to start with I am trying it on known things
14:09:41 <fresheyeball> and it's not finding much
14:10:27 <fresheyeball> http://lpaste.net/362375
14:10:47 <fresheyeball> Cale: that only find one equation
14:10:49 <fresheyeball> id a == a
14:11:48 <fresheyeball> I expected it to find more
14:12:02 <fresheyeball> If I use `Int` in place of A and B
14:12:08 <fresheyeball> It finds one more law
14:12:23 <fresheyeball> `fmap id as == as`
14:12:26 <fresheyeball> but that's it
14:12:55 <fresheyeball> Disappointment :(
14:14:27 <n_blownapart> Cale would you mind looking at this abstract machine example and help me understand what the pedagogical emphasis is on?  thanks  http://lpaste.net/362373
14:14:29 <fresheyeball> I mean those terms should be sufficent to find functor composition
14:14:51 <fresheyeball> fmap (f (g as)) == fmap f (fmap g as)
14:15:21 <Cale> Your left hand side there doesn't typecheck
14:15:33 <Cale> and you didn't include function composition in your signature
14:16:21 <Cale> You presumably wanted to find  fmap (f . g) as = fmap f (fmap g as)
14:16:27 <Cale> But you need (.) for that :)
14:16:43 <Cale> n_blownapart: I'm not sure I understand the question
14:18:16 <n_blownapart> what is this program showing us and why its cool enough to be in a book
14:18:56 <Cale> Maybe let the book tell you why it's showing you this code?
14:19:37 <Cale> It's just a little evaluator with a stack for the continuation.
14:21:04 <n_blownapart> I need to quit programming. I don't get it. that program is confusing sorry
14:21:58 <n_blownapart> people lost interest in my plight, understandably
14:23:16 <Cale> n_blownapart: It's more that I don't understand what your plight is
14:23:29 <Cale> n_blownapart: Is there a more specific question you want to ask about the program?
14:25:35 <n_blownapart> thanks, my lament was directed to you at all. well, what would be an application of this that was common but more interesting than addition, Cale ?
14:25:43 <n_blownapart> not* directed
14:29:28 <cheater> does this encode the behavior of scala's try-finally properly? http://lpaste.net/362376
14:29:45 <n_blownapart> the book goes through the program in the text, not as a chapter exercise. Then it just moves on. its terse as hell
14:30:43 <cheater> hi Cale
14:36:58 <MarcelineVQ> :t +d concat -- <ReinH> :t concat :: [[a]] -> [a]
14:36:59 <lambdabot> [[a]] -> [a]
14:37:16 <ReinH> +d?
14:37:26 <MarcelineVQ> yes, for default type variables
14:37:33 <ReinH> Huh
14:37:39 <cheater> :t concat
14:37:40 <lambdabot> Foldable t => t [a] -> [a]
14:37:49 <cheater> what's a default type variable?
14:40:14 <n_blownapart> Cale kind thanks anyway -- I need to go.
14:41:16 <MarcelineVQ> many type variables, usually related to classes, have default types that ghc can choose if you don't specify a type explicilty. most commonly you'd see this for some literal like 5 becoming Integer if you've not told ghc otherwise. 5 is really Num a => a, but the default for Num a => a is Integer. I think anyway, defaults are something I've not had to deal with much
14:41:34 <MarcelineVQ> :t 5
14:41:35 <lambdabot> Num p => p
14:41:36 <MarcelineVQ> :t +d 5
14:41:37 <lambdabot> Integer
14:42:35 <MarcelineVQ> defaults should be mentioned in the haskell 201 language report if you'd like to learn more
14:42:47 <MarcelineVQ> at lest I hope they are, I don't recall offhand
14:43:52 <MarcelineVQ> yep they are, at least for numerics
14:44:25 <MarcelineVQ> here's the info for +d specifically https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:type%20+d
14:44:39 <Cale> @tell n_blownapart Eventually you can extend this style of interpreter to interpreting arbitrary programming languages, such as Haskell itself, by adding enough things beyond simple addition and integers.
14:44:39 <lambdabot> Consider it noted.
14:56:28 <dmwit> How does hsc2hs decide which template-hsc.h to include?
14:56:35 <dmwit> It seems to be making the wrong choice and I'd like to fix it.
14:57:46 <dmwit> Specifically: I'm using GHC 8.2.1, but the .c file made by hsc2hs has as its first line #include "/usr/local/lib/ghc-7.8.4/template-hsc.h"
14:58:15 <ertes> edwardk: ping
15:00:36 <MarcelineVQ> dmwit: could it be a path issue, is ghc-7.8.4 somehow on the path
15:01:02 <MarcelineVQ> or do you even have that dir? hehe
15:01:39 <dmwit> ghc --version gives 8.2.1. The file being included does exist, but isn't new enough to have hsc_alignment, which is used elsewhere in the hsc.
15:03:00 <dmwit> As a workaround, I can `--hsc2hs-options '-t /usr/local/lib/ghc-8.2.1/template-hsc.h'`, but it doesn't really seem to be a proper fix.
15:03:52 <MarcelineVQ> dmwit: what's your file look like? I'd like to see what paths it uses on my end, if it's a shareable thing, dunno anything about hsc2hs
15:04:26 <dmwit> This is while building basement-0.0.6, so you can reproduce that way if you like.
15:04:57 <dmwit> It builds a temporary file named Size_hsc_make.c that has the offending line at the top during the build.
15:06:11 <geekosaur> I would suspect this means there is a hidden dependency on the ghc version used to build hsc2hs, i.e. make sure your hsc2hs came from the same place as your ghc
15:06:48 <dmwit> uh
15:06:54 <geekosaur> ...yep
15:06:57 <geekosaur> hsc2hs ships with ghc
15:07:12 <dmwit> ...but there are not versioned executable names as there are with all the other GHC tools?
15:07:13 <dmwit> =(
15:07:41 <geekosaur> iirc not
15:07:48 <dmwit> boo
15:07:50 <geekosaur> tripped over that one when version-izing ghc locally
15:08:07 <geekosaur> and, come to think of it, when I made the depot package for CMU
15:09:36 <dmwit> This significantly complicates my ghc-version-switching script. =P
15:10:01 <geekosaur> yes
15:10:10 <geekosaur> also mine, although the way I implemnted it, less so
15:10:14 <dmwit> How did this ever work right? e.g. cabal can select particular GHC versions when there's more than one installed...
15:10:21 <ertes> anyone else here, who can speak to some authority over the kan-extensions package?
15:10:22 <geekosaur> USEGHC=8.0.2 ... hsc2hs ...
15:10:46 <lyxia> what kind of authority
15:11:12 <dmwit> geekosaur: Wait, does that work? USEGHC is not mentioned anywhere in the hsc2hs docs.
15:11:16 <dmwit> ...that I could see.
15:11:21 <geekosaur> that's my wrapper script
15:11:31 <geekosaur> https://github.com/geekosaur/ghc-wrapper
15:12:15 <geekosaur> the ctual ghcs it is using come out of hvr's builds (the version of the script currently on github knows this; has comments about generalizing it)
15:12:19 <dmwit> Oh, so you do the stow thing and have a completely separate directory for each version?
15:12:23 <geekosaur> yes
15:12:24 <ertes> lyxia: i've talked to edwardk a few months ago about merging some additional Codensity functionality regarding exceptions, and in response i'm currently working on the patchesâ€¦  my question is whether i should stick with base exceptions or generalise to the 'exceptions' package, which would come as an additional dependency
15:12:28 <dmwit> yeah, okay
15:12:39 <geekosaur> hypothetically it could be taught the other; I just haven't needed it
15:12:50 <dmwit> That's a good solution. Hard to implement retroactively, though.
15:13:06 <dmwit> Well, thanks for commiserating with me.
15:13:42 <geekosaur> but as long as hsc2hs etc. don;t come versioned by default, it's kinda hard to do the other setuo
15:13:45 <geekosaur> setup
15:13:58 <geekosaur> so we're right back to the start again...
15:14:29 * dmwit nods
15:16:43 <dmwit> geekosaur: Do you know off-hand of other non-versioned things that should be versioned?
15:17:13 <geekosaur> hp2ps, hpc
15:17:24 <geekosaur> dunno if thoise care as much but the potential exists
15:17:46 <dmwit> I'll mention them. I'm filing a trac ticket (in case I can't find one that already exists).
15:18:53 <dmwit> Who knows if GHCHQ will be friendly to the suggestion, but perhaps it was just an oversight.
15:19:25 <geekosaur> (also it installs non-versioned symlink runhaskell to runghc-8.2.2)
15:20:14 <dmwit> What makes you say that's non-versioned?
15:20:22 <geekosaur> ...but I think that is a deprecated holdover from the hugs days, where it was kinda the lazy-ass version of the debian alternatives system
15:20:22 <dmwit> It's no less versioned than ghc linking to ghc-8.2.2.
15:20:35 <geekosaur> becauser ther is no corresponding runhaskell-<ver>
15:20:58 <geekosaur> which complicates deployment systems that can otherwise rely on $x -> $x-$ver
15:21:37 <dmwit> That's not reliable. e.g. haddock -> haddock-$compiler-$ver
15:21:49 <dmwit> So that doesn't bother me as much.
15:22:05 <geekosaur> yeh. haddock has its own historical gotches
15:22:06 <dmwit> It is at least possible in principle to get the right executable.
15:22:44 <dmwit> Whereas for hsc2hs, hp2ps, and hpc it is not even possible in principle to get the right executable if you installed multiple GHCs into the same PREFIX.
15:26:58 <geekosaur> right. (I'm basically a sysadmin. I'm *grumpy* about this, but have bigger fish to fry)
15:31:57 <danilo2_> Hi guys! I've got a conceptual problem with using data families. Basically I want to use them instead of using normal data families and simulating their behavior with type families jsut to have nicer compilation errors for end users. The problem I've got however is that if I use data families, there is a very big probability
15:32:29 <danilo2_> that users of my library wouldnt be able to use them in TH utils. Lets cosider lens - you cannot do `makeLenses ''nameOfDataFamilyInstance`
15:32:50 <danilo2_> of course lenses provide special splice syntax for it, but not all libraries users of my library will use provide it
15:33:07 <danilo2_> thus when using data families I just close them way to use existing TH utils
15:33:21 <lyxia> you can do makeLenses ''nameOfDataFamilyCONSTRUCTOR
15:33:25 * Digit ponders writing "question everything", questioning itself, for the entirety (both words in this default case), for each word, for each character, with each question, then questioning each part in context to the others, then wrapping around the same process on the questions just asked.  then Digit just stares like a mesmerised kitten who ate the kaleidoscope dmt catnip
15:35:49 <danilo2_> lyxia: Ok, again, lens are really well designed and support just everything. However if somebody created a TH splice that needs name of data type then it will fail unless this splice is designed to also accept one constructor, which is even greater problem when thinkign aobut TH functions with multiconsturctor support
15:37:17 <danilo2_> lyxia: The problem I've got is only to allow users of my library to use everything they want without thinking about some "strange" stuff. So what I would liek to see is ability to just use the same TH like `data family Foo a; data instance Foo Int; myTH ''(Foo Int)` I knwo this sytntax does not make sense atm, but I hope it shows what im tlaking about
15:38:05 <danilo2_> Is that only me or anybody else here also dont like this "inconsistence" ?
15:39:10 <monochrom> Digit: laser pointers seem to be an excellent way to de-petrify kittens :)
15:40:53 <lyxia> danilo2_: I agree it's somewhat annoying. You could try to write a "myTH" that accepts quoted types like this: [t|Foo Int|]
15:41:40 <lyxia> There may be a way to access the data instance declaration like that, I'm not sure.
15:42:29 <danilo2_> lyxia: I know I can. I know you can. Anybody who knows haskell can. But If Im releasing my library I want it to be used basically by everybody including people who dont know what splice is. And They also want to use TH from other libraries. Requiring them to know how to re-design third-party TH snippets to use with data families is just no-go if we want to build Haskell community
15:43:12 <dmwit> geekosaur: https://ghc.haskell.org/trac/ghc/ticket/14793 Perhaps somebody will fry some fish for us.
15:43:20 <EvanR> i question the widespread for grantedness of having to use TH at all in the role of building a haskell community
15:44:31 <danilo2_> lyxia: I have problem with haskell in general. I truly love this language. This is the best language I've seen in my life. However the problem with it is that it is not widely used. And it is not widely used because its so hard to step in. The hard part is not a syntax. Its all the extensions and roughness around every edge. You have to think  about this and that etc. Thats why I always desing everything with simplicity as the most 
15:45:04 <lyxia> danilo2_: My point was that you could provide these functions so users don't need to write them. Maybe I misunderstood something.
15:45:36 <danilo2_> lyxia: the problem is that these TH funcitons could not be mine! These could be just a third-party functions
15:46:01 <EvanR> higher order TH?
15:46:02 <lyxia> but... you're writing a library
15:46:10 <danilo2_> lyxia: unless I provide a general re-wrapping TH function which takes arbitrary TH supposed to work on type name and converts it automatically to work on constructor name
15:47:00 <dmwit> I don't think that's possible in full generality.
15:47:14 <danilo2_> lyxia: look, I'm wriitng a library named "A". This library gives you some data families. User of these libraries might want to use th snippets from library "B" (not mine) to add some instances to my data families. However the th snippets in B were desinged to accept data type name only. And here weve got the problem
15:48:11 <dmwit> If all you're looking for is confirmation: yes, it's a problem, and there isn't a super great solution at the moment.
15:48:21 <EvanR> also generics dont work with GADTs
15:48:41 <EvanR> theres a lot of borderland pairs that dont go together
15:48:46 <dmwit> So if you are very worried about it, do less type-level hacking and skip the data families.
15:49:28 <EvanR> if there are n big extensions, then ghc engineers need to make sure n^2 things are well defined
15:49:49 <danilo2_> dmwit: yes I was looking exactly for this. I was looking for confirmation if the problem exist only in my head or its jsut a problem. And there is another question involved - do we plan to do anything with it? Are there any proposals?
15:50:17 <danilo2_> EvanR: wait, dont generics work well with data families too ?
15:50:25 <lyxia> danilo2_: are some of these instances GADTs?
15:50:29 <lyxia> no they work fine
15:50:45 <danilo2_> no no, I'm not using gadts as instances
15:51:01 <danilo2_> i use normal data / newtype instances. I was afraid that maybe generics inherit some problems here as well
15:51:04 <danilo2_> that would be terrific
15:51:54 <geekosaur> danilo2_, I think you;re dancing around things that are still so experimental and poorly characterized that nobody can even say how they;d work together in general
15:52:07 <geekosaur> this is the price of dancing on the edge of the knife
15:52:51 <EvanR> https://wiki.haskell.org/Use_of_language_extensions
15:52:55 <danilo2_> geekosaur: interesting. I was sure that data families are well established funcitonality already
15:53:04 <geekosaur> in particular, TH is a rather useful horrid hack. but making a truly general and useful replacement... is likely to be several Ph.D projects
15:53:42 <lyxia> I have a rough time picturing the kind of user you're targetting. They're going to be using various pieces of the Haskell ecosystem, but they don't want to bother with learning the language?
15:54:58 <danilo2_> lyxia: I want my users to be anybody - with any haskell knowledge enough to make things and use it. However even if that are advanced users I just don't want them to create additional boilerplate. I just want to keep it simple
15:55:18 <danilo2_> lyxia: so basically , yeah, users will know haskell.. I just want the library to be instantly useful
15:55:44 <danilo2_> this doesnt mean that they need to know how to write TH, but could use TH functions form third party libraries (which is very often case)
15:55:58 <danilo2_> I know tons of people using TH splices and who never wrote any TH by themselves
15:57:38 <parsnip> i guess i made this hard to read:
15:57:40 <parsnip> digits b v = [ reverse $ unfoldr (\v -> [ swap (v `divMod` b) | v > 0 ]) v | b >= 2 ]
15:57:47 <parsnip> digits :: Integral a => a -> a -> Maybe [a]
15:58:31 <parsnip> a little better?
15:58:32 <parsnip> digits b = (guard (b >= 2) >>) . (pure . reverse . unfoldr (\v -> [ swap (v `divMod` b) | v > 0 ]))
16:00:29 <lyxia> danilo2_: there's lots of functionality you can derive with Generics instead of TH, does that alleviate the problem much?
16:02:37 <danilo2_> lyxia: not at all. Telling my users "If you've got problem with using some TH splices you've got there, look for any alternative with Generics" is as wrong as talking to them "Try to re-write these TH splices youve got there"
16:03:14 <danilo2_> lyxia: I think Ill just stay with ordinar datatypes and type families instead
16:03:29 <danilo2_> it solves my problem completely but it will jsut show not so nice type errors
16:24:09 <lyxia> danilo2_: is that project (going to be) open source?
16:30:07 <ab9rf> i have yet to make any sense at all of TH
16:30:17 <ab9rf> but i can barely write haskell code
16:33:44 <danilo2_> lyxia: yes, it's already is. Check out http://luna-lang.org
16:39:46 <lyxia> oh that's cool!
16:41:49 <danilo2_> lyxia: <3
16:52:41 <sm> +1
17:01:11 <entropicone> anyone have any advice or resources on optimizing the RTS flags on applications? I've been working on improving build times for an Elm app at work, and I found that recompiling the elm compiler (written in Haskell) with the rtsopts -A128M -n4m it cut build times in half.  I know from profling it much of the time was spent in the GC (around 50%), with the additional rtsopts it drops to around
17:01:11 <entropicone> 20% of its time in the GC
17:01:34 <entropicone> I just know next to nothing about haskell!
17:07:09 <Axman6> entropicone: you might be able to use this: https://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/ =)
17:09:17 <entropicone> awesome, thank you Axman6!
17:09:52 <Axman6> maybe not the most efficient option... but takes the thinking out of it, just run  avocea overnight and get the best flags in the morning!
17:11:53 <entropicone> I actually started building a crappier version of this, so that is perfect, haha
17:51:04 <EvanR> so you could define a big dependent record parameterized by a type N containing proofs of all peano axioms, to justify that your type acts like natural numbers
17:51:16 <EvanR> and implement it all the usual way
17:51:26 <EvanR> and prove any two are isomorphic
17:51:57 <EvanR> and give GMP naturals as a possible implementation, with no hope of proving the axioms for real
17:52:25 <EvanR> for some thing, GMP will be limited by the computer... but so is anything implemented directly in the type theory HEAD EXPLODE
17:52:29 <EvanR> for one thing*
17:52:50 <EvanR> is the whole endeavor futile
17:53:13 <MarcelineVQ> nah
17:53:52 <ertes> danilo2_: that looks really cool!
17:54:15 <danilo2_> ertes: thank you! I'm happy that you like it! :)
17:55:08 <danilo2_> By the way, we are working on making many improvements to Luna, like easy Haskell FFI. If anyone wants to help us, we'd love to collaborate :)
17:55:19 <ertes> EvanR: i think it's fine to take the peano axioms as, you know, *axioms*
17:55:49 <ertes> assume that GMP satisfies them, build everything else on that
17:55:49 <EvanR> this narrative comes from the perspective of modeling
17:56:27 <EvanR> the fact that you cant really prove anything about GMP makes me question how you can prove anything
17:56:33 <EvanR> about anything
17:56:43 <ertes> EvanR: there are much crazier assumptions used in practice like that GMP's primality tests are primality *proofs*, which is not true
17:58:52 <ertes> EvanR: unless you actually construct the concept within type theory you can only really work with postulates like thatâ€¦  every theorem you write on top of those comes under the premise that GMP has no bugs
17:59:28 <Cale> If you were suitably crazy, you probably could try to prove that GMP satisfies the axioms when compiled with CompCert :)
17:59:57 <ertes> if you're uncomfortable with implicit premises like this, you can make them explicit, but this gets unwieldy very quickly =)
18:00:20 <EvanR> sure
18:00:31 <EvanR> that doesnt make me more comfortable though
18:01:32 <ertes> well, you can't really eliminate all assumptions
18:01:48 <monochrom> It makes me more comfortable.
18:02:28 <ertes> even if you prove everything on the software level you're still assuming that the CPU works to the spec
18:04:03 <monochrom> More precisely, "this large system is well-organized into modules, and I know which module has been verified, which module hasn't" makes me more confortable than "this large system hinges on Knuth's talent"
18:05:27 <monochrom> And you look at how Knuth disorganizes TeX and you know what kind of macro-expanding spaghetti I'm talking about in the later.
18:05:30 <monochrom> err latter
18:06:00 <monochrom> in which you still have confidence but it's only because Knuth is smart, not because everyone should build software this way.
18:06:05 <EvanR> tactic knuth
18:06:32 <Smeghead> Hey guys I can't compile stuff with ghc I get like a fuck tonne of errors saying to use -fPIC
18:06:42 <Smeghead> Any suggestions what I do? I'm on Fedora 27
18:06:58 <Smeghead> No wait I'm on Debina 9.3
18:07:18 <Welkin> no wait, you are on windows ME
18:07:34 <Smeghead> :S I get confused sometimes
18:07:45 <ertes> i've seen that -fPIC problem beforeâ€¦  is that a stack thing?
18:07:53 <monochrom> No wait, Windows ME is just being the host of the virtual machine that runs Debian and ghc.
18:08:19 <Smeghead> Something about stack came up on google but I'm just using plain ghc on debian
18:08:39 <Smeghead> ghc 8.0.1
18:08:40 <Welkin> Smeghead: how did you install ghc?
18:08:56 <Smeghead> Welkin: apt
18:09:13 <Welkin> you can: 1) install using haskell platform, 2) install from the binary distribution, 3) use nix
18:09:28 <Welkin> I would recommend not using the one from your package manager
18:09:33 <Welkin> I only see people have problems with them
18:09:35 <Smeghead> Ah okay thanks
18:10:20 <ertes> Smeghead: you should probably just get a binary distribution of GHC 8.2â€¦  while 8.0 is not as ridiculously outdated as i'm used to from debian, it might just solve your problem
18:10:38 <parsnip> no stack suggestion?
18:11:23 <Welkin> Smeghead: https://www.haskell.org/downloads/linux
18:11:25 <ertes> Smeghead: be sure to get cabal-install 2.0 along the way, too
18:11:29 <Welkin> look under "Manual Install"
18:12:03 <Welkin> you could also just get haskell platform https://www.haskell.org/downloads
18:12:04 <Smeghead> Thanks
18:12:12 <ertes> parsnip: the stack fanpeople seem to be sleeping =)
18:12:12 <Smeghead> yeah looking into haskell platform now
18:12:51 <ertes> Smeghead: if you're going to use the platform, be sure to use the minimal one
18:13:42 <parsnip> i think we need a standard
18:13:53 <ertes> for what?
18:13:55 <Welkin> parsnip: you are beating a dead horse
18:13:57 <Welkin> don't even start
18:14:04 <Smeghead> ertes: already installing the full one :/ worth uninstalling?
18:14:34 <ertes> Smeghead: if it comes with cabal-install 2.0, you'll be fine
18:14:41 <ertes> Smeghead: check 'cabal --version' after installation
18:15:24 <Smeghead> 2.0.0.1
18:15:35 <ertes> Smeghead: you're fine =)
18:15:41 <Smeghead> hmmm still not working, is it possible the ghc installed doesn't support PIE?
18:16:26 <Smeghead> Suspiciously like something selinux would mess with
18:17:51 <ertes> Smeghead: so you've written a source file, you're trying to compile it and get that error?
18:18:30 <Smeghead> ertes: yeah
18:18:56 <ertes> Smeghead: could you paste your source file together with the command line you used to compile it and the full compiler output?
18:18:57 <ertes> @paste
18:18:57 <lambdabot> Haskell pastebin: http://lpaste.net/
18:19:46 <Smeghead> https://gist.github.com/wolfmankurd/5399ed184514df779857cefa96ca951f
18:20:54 <Smeghead> let me upload the output
18:21:30 <Smeghead> Output is there but it is huge
18:23:39 <ertes> Smeghead: i mean the compiler messages, not any produced files
18:24:19 <Smeghead> the middle file was produced with ghc wihd.hs 2> output
18:24:25 <Smeghead> is that not what you wanted?
18:24:33 <ertes> yeah, exactly
18:24:52 <ertes> i'm trying to find information on the error
18:26:29 <ertes> Smeghead: what happens if you put CFLAGS="-O2 -fno-PIE -fno-stack-protector -fPIC" in front of the ghc command?
18:26:48 <ertes> CFLAGS="-O2 -fno-PIE -fno-stack-protector -fPIC" ghc -O -o wind wind.hs
18:27:36 <Smeghead> output looks the same to me
18:28:05 <ertes> i'm using the information from this post: https://stackoverflow.com/questions/47932033/linking-error-when-trying-stack-install-yesod-bin
18:28:16 <ertes> so perhaps you need to define LDFLAGS as well
18:28:45 <ertes> CFLAGS="-O2 -fno-PIE -fno-stack-protector -fPIC" LDFLAGS="-no-pie -fuse-ld=gold" ghc -O -o wind wind.hs
18:29:23 <Smeghead> Same,
18:29:32 <Smeghead> I'll try and edit that file they mention
18:29:44 <Smeghead> oh but I don't use stack
18:29:55 <ertes> yeah, the post is stack-specific
18:30:39 <Smeghead> Does ghc still use gcc? not clang/llvm or something now?
18:30:40 <ertes> actually i'm not sure if GHC uses CFLAGSâ€¦  you may have to pass those flags using GHC flags, but i'll throw the ball to someone else now, because i'm really just guessing at this point
18:30:53 <Smeghead> Ah thanks anyways
18:31:29 <ertes> Smeghead: it has a native code generator for *haskell* code, but there is still some C code involved like the RTS and some libraries have optimised C code
18:31:32 <geekosaur> ghc does not
18:31:44 <geekosaur> (use CFLAGS)
18:32:03 <geekosaur> there is -optc... and -optl...
18:33:10 <Welkin> I believe it does require gcc for something
18:33:39 <Welkin> I had to compile gcc on macos before for haskell
18:33:42 <danilo2_> Hi! Is there any syntax in haskell that allows me to pattern match on fields in order without writing the constructor name if data type is single constructor and we know its type ? something like {x,y} = z ; Im looking for general solution without boilerplate (no viepatterns)
18:33:49 <danilo2_> I suspect there isnt
18:33:58 <danilo2_> but its better to aks than assume wrongly :D
18:34:12 <Welkin> danilo2_: you need to include the constructor, otherwise there is no way to do a match
18:34:19 <ertes> danilo2_: you're right, there isn't
18:34:27 <metahumor> danilo2_: especially if the constructor is not exported
18:34:27 <danilo2_> cool, thank you guys
18:34:39 <danilo2_> metahumor: good point
18:34:42 <ertes> danilo2_: however, you can pick a short name and just use accessors
18:34:54 <ertes> f x = field1 x
18:35:45 <ertes> danilo2_: alternatively, since there is only one constructor, you move the pattern-match into a 'where'
18:36:01 <ertes> f x = â€¦  where MyRecord { field1, field2 } = x
18:36:41 <ertes> (i'm using NamedFieldPuns there)
18:36:47 <geekosaur> Welkin, I did not say it doesn;t use gcc. what it uses gcc for is (a) CPP extension (clang's cpp has issues); (b) foreign import "ccall" and foreign export stubs
18:36:52 <geekosaur> (c) hsc2hs
18:37:07 <danilo2_> ertes: yeah yeah I knoiw. I was rather looking ofr something very fancy
18:37:09 <danilo2_> thank you :)
18:37:53 <ertes> danilo2_: and of course there is RecordWildCards, which can save a lot of space at the expense of polluting the namespace with lots of shadows =)
18:37:58 <ertes> f MyRecord{..} = â€¦
18:38:41 <Welkin> I find that RecordWildCards seems like a good idea
18:38:51 <Welkin> then you use it, and confuse yourself over what the code is doing
18:39:02 <Welkin> sometimes you use the field names as variable, other times you try to use them as functions
18:39:07 <danilo2_> ertes: oh, to be honest, I forgot that they exist!
18:39:08 <Welkin> I don't use it any more
18:39:18 <danilo2_> ertes: they are really fancy sometimes! thank you for the reminder
18:39:37 <danilo2_> Welkin: good point as well
18:39:39 <metahumor> you might like NamedFieldPuns
18:39:49 <ertes> RecordWildCards is one of my favourite guilty-pleasure extensions
18:40:14 <ertes> along with NamedFieldPuns and ApplicativeDo
18:40:47 <Cale> Why do you like ApplicativeDo?
18:41:36 <Cale> In almost any situation I can think of, ApplicativeDo is either pointless or infuriatingly confusing.
18:41:40 <ertes> Cale: because it makes populating a record using out-of-order actions, particularly in combination with RecordWildCards
18:41:54 <ertes> you can use RecordWildCards for *defining* records as well as pattern-matching on them
18:42:28 <ertes> do field3 <- c3; field1 <- c1 field3; field2 <- c2; pure MyRecord{..}
18:42:39 <Cale> Why does that need ApplicativeDo?
18:42:47 <ertes> err
18:42:51 <ertes> do field3 <- c3; field1 <- c1; field2 <- c2; pure MyRecord{..}
18:42:56 <Welkin> Cale: some people just want do-blocks for everything o.o
18:43:03 <Welkin> like monad comprehensions
18:43:14 <ertes> Cale: ^ i've used it for some proper applicatives
18:43:22 <Cale> I don't mind the do-syntax...
18:44:04 <ertes> Cale: example use case: optparse-applicative
18:44:30 <ertes> do option1 <- strOption â€¦; option2 <- flag â€¦; pure Options{..}
18:44:50 <Cale> I guess
18:45:26 <Cale> I really don't like ApplicativeDo in general.
18:45:48 <ertes> that's why i call it a guilty-pleasure extension =)
18:46:06 <monochrom> ertes: Wait, what?! (I mean the RecordWildCards part.)  Let me check GHC user's guide real quick...
18:46:32 <ertes> monochrom: or just try it out in GHCi
18:47:02 <Cale> You can certainly do that kind of thing with RWC, I've done it before when programming in a sort of "OO" style, where most of my record fields were functions that I wanted to specify in a where clause.
18:47:25 <monochrom> Oh hahaha was blind, but now, I see.  "Allow the use of wildcards in record construction"...
18:47:25 <ertes> data X = X { xI :: Int; xS :: String } deriving (Show)
18:47:40 <ertes> let xI = 5; xS = "blah" in X{..}
18:48:04 <Cale> However, RWC is really annoying for anything that wants to manipulate Haskell source code, since it's hard to determine how things are bound (you need to actually know all the definitions of the types)
18:48:22 <amalloy> how is ApplicativeDo confusing? i haven't used it, but i thought it just desugared do-notation into applicative-compatible code when possible
18:48:34 <Cale> amalloy: Exactly how does it do that?
18:48:38 <metahumor> "when possible" is ill-formed
18:48:55 <Cale> amalloy: The problem is that it's ambiguous, and the algorithm for determining the best way of doing it is O(n^3)
18:49:21 <Cale> (as such, the optimal algorithm is switched off by default, and you get a heuristic one)
18:50:03 <Cale> So it just makes the meaning of your do-blocks pretty much impossible to discern without reading the resulting core :P
18:50:06 <ertes> if you've worked with arrows for long enough, you kinda get blind to those things =)
18:50:27 <Cale> I have worked with arrows for a long while... and worked on custom preprocessors for proc/do syntax :P
18:50:46 <Cale> I'd rather not have to deal with that kind of situation if I don't have to
18:50:54 <Cale> and I just don't see the need, usually
18:51:29 <ertes> with arrows you either engage in masochism like Cale, or you just accept the fact that the generated code is far from optimal =)
18:51:47 <Cale> Like, either ap and <*> are equal or they're not. If they're not, then you ought to care about the precise way in which you're using the applicative operations. If they are, then you're making things harder to understand for no reason.
18:53:21 <ertes> well, i don't really use it where that matternsâ€¦  in fact i don't think i've ever used it for anything other than parsing command line options or a JSON configuration file
18:53:26 <ertes> *matters
18:53:31 <Cale> There are a few edge cases where you want to define things which are Applicative-polymorphic but using the do-syntax... still, the fact that you can't really tell what you're getting, or that your definitions will actually typecheck ought to be concerning there.
18:53:56 <Cale> Or yeah, if you're trying to be super cute with RecordWildCards, fine :P
18:53:58 <Cale> lol
18:54:36 <Cale> I can still imagine getting pissed off with that kind of thing eventually, though immediately, I can't complain too much :)
18:55:20 <Cale> The other extension that other people like a lot more than I do is TypeApplications
18:55:52 <Welkin> Cale: you mean jle`?
18:56:01 <ertes> that one i agree withâ€¦  i kinda work under the assumption that the order of type arguments doesn't matter
18:56:04 <metahumor> as in, your code be written in a way so that TypeApplications isn't needed
18:56:08 <Cale> I don't know about jle` in particular
18:56:10 <ertes> and that doesn't play well with TypeApplications
18:56:21 <Cale> The fact that TypeApplications exists means that you now have to be careful if you're a library maintainer and you suddenly want to use ScopedTypeVariables
18:56:37 <Cale> You have to be careful about the order of the type variables in your foralls.
18:56:45 <Cale> Just because your users might be using TypeApplications
18:57:20 <Cale> It would be more okay if TypeApplications only ever worked on type variables that were explicitly forall'ed to begin with
18:57:22 <ertes> usually type signatures aren't really much longer, and if they are, then PartialTypeSignatures can help with that
18:57:24 <Welkin> Cale: it was a joke. He loves it
18:59:25 <ertes> also there is this little obscure function that is easy to forget aboutâ€¦
18:59:29 <ertes> :t asTypeOf
18:59:30 <lambdabot> a -> a -> a
19:00:21 <Cale> Yeah, there are also a lot of old-fashioned tricks for writing dead code that unifies type variables just so. That gets a bit ugly though, I'll admit.
19:00:39 <Cale> Personally I don't mind using Proxy when it really matters.
19:01:18 <ertes> or Proxy# if you really want to make 100% sure GHC optimises it away
19:27:34 <Axman6> :t asTypeOf `asTypeOf` asTypeOf
19:27:35 <lambdabot> a -> a -> a
19:38:18 <Dynasty> Does anyone here have any experience with writing a typechecker that supports type class predicates? I have a solver that works right now using an explicit constraint method (not Algorithm W). I think I should be able to just union together predicate lists, but where this union occurs is unclear to me right now.
19:42:53 <Gurkenglas> If a "State (Int, Int -> a) b" can be seen as "State (Int -> a) b" where all changes to Int are just precomposed to the Int -> a, you run into the problem that the changes are recomputed every time one looks up an a. Can one get around that?
19:47:09 <bash0r> Is there some kind on tutorial or guide on how to use hOpenPGP library?
19:53:07 <parsnip> do { i <- [0..3]; pure $ do { j <- [0..2]; pure (i, j) } }
19:53:15 <parsnip> > do { i <- [0..3]; pure $ do { j <- [0..2]; pure (i, j) } }
19:53:17 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)],[(3,0),(3,1),(3...
19:53:32 <parsnip> > do { i <- "abc"; pure $ do { j <- "01"; pure $ (i, j) } }
19:53:34 <lambdabot>  [[('a','0'),('a','1')],[('b','0'),('b','1')],[('c','0'),('c','1')]]
19:53:37 <parsnip> ugh
19:53:48 <parsnip> > do { i <- "abc"; pure $ do { j <- "01"; pure $ i:j:[] } }
19:53:50 <lambdabot>  [["a0","a1"],["b0","b1"],["c0","c1"]]
19:54:03 <Welkin> @undo do { i <- [0..3]; pure $ do { j <- [0..2]; pure (i, j) } }
19:54:03 <lambdabot> [0 .. 3] >>= \ i -> pure $ [0 .. 2] >>= \ j -> pure (i, j)
19:54:05 <parsnip> is this the idiomatic way to do nested loops in do monad?
19:54:06 <Welkin> :D
19:54:13 <Welkin> what? nested loops?
19:54:30 <parsnip> er, nested comprehensions
19:54:35 <jle`> what is 'do monad' ?
19:54:38 <Welkin> it depends on what you are doing
19:54:42 <parsnip> oh geez, my bad
19:54:58 <parsnip> is this the idiomatic way to do nested lists in monadic do sugar?
19:55:00 <Welkin> you can simulate nested for-loops using two `forM`
19:55:29 <jle`> the idiomatic way to make nested lists with do sugar for lists?
19:55:59 <jle`> it depends on what you want to do
19:56:07 <jle`> but <- with pure is just fmap
19:56:31 <jle`> > fmap (\i -> fmap (i,) [0..2]) [0..3]
19:56:33 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)],[(3,0),(3,1),(3...
19:57:07 <jle`> no need for Applicative or Monad
19:57:26 <jle`> if you want to collapse it all into one list you can do liftA2/Applicative
19:57:33 <jle`> > (,) <$> [0..3] <*> [0..2]
19:57:35 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2)]
19:57:43 <jle`> but this isn't anything that has to do with monads
19:57:45 <jle`> it's just lists
19:58:24 <EvanR> and if you want to combine the two components for each... use something besides (,)
20:46:30 <Dynasty> In Haskell, why aren't the record problems fixed by using typeclasses? For instance if you have a record with a field "foo", then can't we just generate a "HasFoo" typeclass?
20:46:51 <metahumor> some think that all typeclasses should have laws
20:47:25 <Dynasty> is there a technical reason it can't be done?
20:49:00 <spietz> The lens library can already do that
20:49:21 <geekosaur> it's in progress. see DuplicateRecordFields and the upcoming OverloadedRecordFields extension
20:49:44 <geekosaur> although it went with type level strings instead of separate HasXXX typeclasses
20:50:40 <Dynasty> oh I didn't know type level strings were a thing. I only knew about the nats
20:51:29 <chrisbarrett> pleb here: would there be a general performance penalty in using typeclasses to encode record selectors, by having vtables all over the place?
20:52:10 <chrisbarrett> I feel like those would be hard to optimise away, because type inference would often select maximally general constraints
20:52:11 <Dynasty> the calls to an overloaded function are almost always monomorphized, so there is no runtime overhead
20:52:50 <chrisbarrett> cool, thanks
20:53:12 <Dynasty> chrisbarrett: see the section on macros here: http://okmij.org/ftp/Computation/typeclass.html There are only a couple rare situations in which the dictionary passing must be used
20:53:33 <geekosaur> right, most of the time the dictionary only makes it to generated code if there is polymorphic recursion involved. record selectors are unlikely to be recursive, much less polymorphically so
20:54:04 <chrisbarrett> Dynasty: thanks, that looks like a great page!
20:55:08 <spietz> you can use this ttps://hackage.haskell.org/package/lens-4.16/docs/Control-Lens-TH.html#v:makeFields
21:36:47 <EvanR> tryhaskell.org ...
21:36:58 <EvanR>  > readFile "/welcome"
21:37:18 <EvanR> "Welcome to your mini filesystem! Try playing with this function: getDirectoryContents" :: IO String
21:37:23 <EvanR> o_O
21:38:19 <monochrom> haha
21:38:30 <Welkin> what a lie
21:38:58 <monochrom> Someone please change that to "minix filesystem" for the kick of it. :)
21:39:42 <Welkin> pull an intel?
22:09:23 <heptahedron> Is there any way to not have to include the `SingI a` constraint in a type declaration when the only possible arguments all have the implementation? I keep running into this issue using singletons where I'll have something like a GADT type parameter whose kind is restricted to one for which all the inhabitants have a `SingI` implementation but I have to add the annotation anyway and it's keeping me from b
22:09:23 <heptahedron> o use them in existentially-quantified places where the type parameter isn't known
22:13:29 <parsnip> oh lame, \Delta is an uppercase, so it's for contructors, not values :(
22:14:15 <heptahedron> Okay I see now that if I pattern match on the constructors of the GADT, it is able to infer that there must be a `SingI` instance, I guess because by then the type parameter is added to the current inference context and it can find the implementation on its own. Still though, is there not a better way around this?
22:46:58 <shramana> hi i'm fairly new to haskell and i'm wondering why i'm getting no parse exception when i do something like this in ghci prompt:
22:47:02 <shramana> read <$> getLine
22:47:23 <heptahedron> shramana: Why would you expect to get one?
22:47:40 <shramana> get what?
22:47:53 <heptahedron> er, a "parse exception"
22:48:04 <heptahedron> OH
22:48:21 <shramana> oh sorry the expression was this:
22:48:26 <shramana> (show . read) <$> getLine
22:48:51 <shramana> i'm just experimenting with ghci and i just wondered
22:48:55 <heptahedron> shramana: answer me this
22:49:14 <heptahedron> shramana: what is the type of thing that will be read by `read` and subsequently shown by `show`?
22:49:16 <geekosaur> because (show . read) doesn;t give ghci any idea of what type you are 'read'ing, so it uses ghci's defaulting and gets ()
22:49:35 <geekosaur> (a compiled Haskell program will use normal defaulting and get Integer)
22:51:23 <geekosaur> do keep in mind that read cannot determine a type by what it parsed; it instead selects a parser based by the type requested for it. in this case, no type is specified or can be inferred, so it has to use defaulting
22:52:26 <geekosaur> Haskell is statically typed, so it can't pick a result type dynamically, it has to determine one at compile time
22:52:44 <shramana> aha
22:53:39 <geekosaur> and the only valid value of type () is ()
22:53:50 <shramana> so the only 'legal' String would be "()" when i (show . read) <$> getLine
22:54:08 <geekosaur> > (show . read) "()"
22:54:10 <lambdabot>  "()"
22:54:15 <geekosaur> > (show . read) "0"
22:54:17 <lambdabot>  "*Exception: Prelude.read: no parse
22:54:39 <shramana> okay i think i get it. thanks a lot
22:56:29 <zg> what's going on w/ this: concatMap (take n . repeat) xs
22:56:36 <zg> specifically the "take n . repeat" part
22:56:57 <zg> sorry, allow me to give context:
22:57:01 <zg> repli :: [a] -> Int -> [a]
22:57:08 <zg> repli xs n = concatMap (take n . repeat) xs
22:57:21 <zg> e.g. repli "abc" 3 outputs "aaabbbccc"
22:57:38 <cocreature> zg: whatâ€™s confusing you about it?
22:57:55 <zg> i'm trying to understand how to read "take n . repeat"
22:58:28 <heptahedron> zg: the composition operator `(.)` can be read as "after", so `f . g` is like doing `f` after `g` to some argument.
22:59:05 <cocreature> @src (.)
22:59:05 <lambdabot> (f . g) x = f (g x)
22:59:31 <cocreature> so itâ€™s equivalent to (\x -> take n (repeat x))
23:00:04 <zg> ah, that equivalence clears my eyes
23:00:13 <heptahedron> zg: What `(.)` does is return a new function that is the composition of its arguments, so in this case, `repeat` takes an argument and returns an infinite list of that argument. `take n` takes a list as an argument and returns at most `n` elements from the front of it. So the composition of these two will give you a list `n` long of whatever you pass to repeat.
23:01:04 <cocreature> zg: fwiw there is also a "replicate" function which combines take and repeat
23:01:13 <cocreature> > replicate 5 'a'
23:01:15 <lambdabot>  "aaaaa"
23:02:03 <zg> cocreature: that was also mentioned as a solution: https://wiki.haskell.org/99_questions/Solutions/15
23:02:30 <zg> usually when i get stumped on a challenge, i work backwards from the answer
23:11:33 <danilo2_> Hi guys! Coudl anybody tell me why GHC rejects this code? It seems ok for me, hmmm http://lpaste.net/362382
23:13:13 <danilo2_> In fact the GHC error doesnt make much sense to me becasue this constraint is actually solved and its true
23:18:08 <danilo2_> I annotated this code with another code , maybe cleaner which shows the same problem : http://lpaste.net/362382
23:22:45 <heptahedron> Does anyone know offhand why haskell doesn't have disjunctive case pattern matches, like is it being deliberately avoided? It seems like it would be relatively straightforward syntactic sugar
23:25:27 <kadoban> heptahedron: Is that the thing where they share a right-hand-side for several patterns?
23:27:49 <danilo2_> hmm, I dont get it. GHC tells me there is infinite kind somewhere, but even the error suggest that this is just kind transfomration on single level
23:41:29 <cocreature> danilo2_: afaict GHC just canâ€™t resolve the type family since there is no instance for "'Map â€¦"
23:42:21 <cocreature> danilo2_: there is an instance for "Map k v" but thatâ€™s not what youâ€™re using here
23:44:58 <cocreature> the error message is kind of confusing
23:47:48 <danilo2__> cocreature: I believe the instance is correct. This is instance for kind not type
23:48:11 <cocreature> danilo2__: oh good point, I missed that
23:48:24 <danilo2__> cocreature: Iâ€™m walking my dog now so sorry if I cannot provide any code atm
23:48:51 <danilo2__> cocreature but the point there is that I need to tell ghc how to infer kinds
23:50:09 <danilo2__> And the error is errr strange. Because it does not construct infinite kind in my opinion
23:50:28 <dminuoso> Can someone point out to me what kind of situation Control.Comonad.experiment is for?
23:50:31 <dminuoso> experiment :: Functor f => (s -> f s) -> Store s a -> f a
23:52:26 <dminuoso> It almost feels as if this becomes useful when you pick [] as a Functor in order to peek into multiple spots
23:53:42 <dminuoso> Maybe its just the name that is a bit weird.
23:56:34 <danilo2_> cocreature btw do you have any ideas?
23:57:50 <cocreature> danilo2_: afaict the "k" in '(k,v) should be something of kind k not k itself
23:58:51 <cocreature> and similarly for the "v"
