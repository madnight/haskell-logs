00:00:19 <[exa]> sdrodge: thanks, I didn't know about improve. But it's still an imperative DSL
00:00:49 <qeyoa> is "pair" same as "tuple" in this context
00:00:59 <qeyoa> ?
00:01:11 <cocreature> qeyoa: “pair” usually referes to 2-element tuples
00:01:26 <qeyoa> thanks
00:22:22 <quchen> How do you compose Lambdabot commands again? I thought it was like this,
00:22:36 <quchen> ?. ?djinn ?type curry
00:22:36 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "?djinn")
00:22:41 <quchen> :-(
00:23:10 <[exa]> maybe without the ?
00:23:25 <quchen> ?. djinn type curry
00:23:27 <lambdabot> f a b c = a (b, c)
00:23:34 <quchen> Ooooh.
00:23:39 <quchen> Thanks :-)
00:23:53 <[exa]> whew, cool
00:24:30 <quchen> ?. djinn type fromMaybe
00:24:31 <lambdabot> f a b =
00:24:31 <lambdabot>     case b of
00:24:31 <lambdabot>     Nothing -> a
00:24:31 <lambdabot>     Just c -> c
00:24:41 <quchen> Still the most impressive one :-)
00:25:17 <quchen> Not sure why it doesn’t give me \n _ -> n
00:26:41 <[exa]> cases can be decompiled to patterns, but I doubt it's of interest for the underlying theorem prover
00:27:16 <liste> ?. djinn type const
00:27:17 <lambdabot> f a _ = a
00:27:49 <liste> what's the difference between djinn and exference?
00:29:39 <ertes-w> dminuoso: no, there is no mutability involved
00:30:17 <ertes-w> dminuoso: the purpose of 'realise' is to turn an arbitrary store into one with backing memory
00:30:57 <ertes-w> dminuoso: it doesn't change the store's semantics, it just makes it faster
00:31:06 <ertes-w> dminuoso: very similar to memoisation
00:31:43 <ertes-w> dminuoso: (well, it does have to change the semantics, because you can only realise a finite portion of the store)
00:32:30 <dminuoso> ertes-w: I dont understand the purpose of that first argument then. Or is that just supposed to be the lower right corner up until which you want to realize the Store?
00:32:48 <guest_> @
00:32:55 <guest_> @lsit
00:32:56 <lambdabot> Maybe you meant: quit list let leet l33t gsite
00:32:58 <guest_> @list
00:32:58 <ertes-w> dminuoso: yeah, or the upper right or …
00:32:59 <lambdabot> What module?  Try @listmodules for some ideas.
00:33:27 <liste> guest_: what do you want to do? you can PM lambdabot if you want to know more
00:33:41 <dminuoso> ertes-w: Ahh, so basically kind of like my draw :: Store Pos Bool -> Pos -> B.ByteString, except I dont produce a string but.. again a Store. Gotcha.
00:33:53 <dminuoso> ertes-w: I was just super confused because you said "it returned the same store untouched" :)
00:34:13 <dminuoso> That should be easy
00:35:09 <ertes-w> dminuoso: well, (copy :: ByteString -> ByteString) also returns the same ByteString =)
00:35:23 <ertes-w> dminuoso: if sameness is a semantical term
00:35:40 <ertes-w> this is basically 'copy' for stores
00:35:55 <ertes-w> except i don't like the name =P
00:36:21 <dminuoso> ertes-w: Right, except like you said - it shrinks. :)
00:36:49 <ertes-w> computeS and computeP from repa would be more appropriate names (in fact you could even do the parallelisation deal…  you could even just use repa)
00:37:04 <qeyoa> have i implemented the function 'curry' correctly: http://lpaste.net/362545
00:37:17 <dminuoso> :t curry
00:37:18 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:37:23 <cocreature> qeyoa: yep
00:37:33 <dminuoso> qeyoa: There's no way you could implement it wrong in fact.
00:37:43 <qeyoa> well, this was much more simple than i thought
00:37:44 <dminuoso> (Unless you somehow produced a bottom)
00:39:01 <quchen> qeyoa: :-)
00:39:55 <quchen> qeyoa: The nice thing is that there is only one solution that typechecks, so you can’t get it wrong
00:40:48 * dminuoso . o O ( `myCurry = myCurry` )
00:41:00 <qeyoa> i for some reason imagined the currying as being some process that would redefine the function instead of constructing arguments for it
00:41:17 <qeyoa> so i was scratching my head for half an hour
00:41:40 <dminuoso> qeyoa: Currying is just the fact that if you dont apply "all" arguments, you get a function back that takes the remaining ones. Thats all :)
00:41:59 <dminuoso> A better way of formulating is: every function takes exactly one argument.
00:42:04 <qeyoa> yes, i'm reading the wiki page about it
00:42:26 <dminuoso> so that (\a b c -> magic) actually means (\a -> \b -> \c -> magic)
00:42:36 <dminuoso> In truth there are subtle differences though.
00:42:56 <ertes-w> oh shit
00:42:59 <ertes-w> hllo
00:43:11 <qeyoa> i'm still not completely sure what the symbol '\' means
00:43:19 <qeyoa> so \a
00:43:34 <qeyoa> does this notate lambda function start
00:43:36 <qeyoa> ?
00:43:42 <quchen> \ is an ASCII approximation to λ.
00:43:43 <dminuoso> qeyoa: Yes. \ was picked because it looked closest to λ
00:44:16 <quchen> double = \x -> x * 2
00:44:18 <ertes-w> it's a lambda with a missing leg
00:44:33 <dminuoso> qeyoa: λa.b  is written \a -> b
00:44:52 <liste> if they had picked . instead of -> it'd look even more like λC
00:45:33 <ertes-w> i wonder why they didn't
00:45:59 <opqdonut> could've used ,\ instead of \ too
00:46:19 <quchen> Or »«
00:46:20 <qeyoa> so was the main idea (or at least one of the main ones) behind haskell to get as close to functional mathematical notation as possible?
00:46:26 <ertes-w> or λ
00:46:30 <quchen> id = x -> x
00:46:46 <TMA> ertes-w: to be able to have the butthole (.) for composition
00:47:02 <qeyoa> :D
00:47:05 <liste> qeyoa: not just notation, Haskell's pretty much extending lambda calculus into an usable programming language
00:47:32 <dminuoso> qeyoa: Well yeah. There's a lot of influences. The . operator for composition for example looks fairly close to ∘ which does the same thing in Mathematics.
00:48:14 <ertes-w> qeyoa: another reason why we prefer "\x -> y" over "anonymous function for the variable x that returns y" is that haskell is one of the few languages that realised the merits of *quiet syntax*
00:48:29 <dminuoso> Like `h = f ∘ g` would be written `h = f . g` in Haskell. :)
00:48:42 <ertes-w> qeyoa: haskell code remains very readable in functional style, while most other languages get messy very quickly
00:48:52 <quchen> ertes-w: Have you seen SPJ’s code style? :>
00:49:17 <ertes-w> quchen: no, but i've heard that he has a rather C++y style =)
00:49:17 <liste> does spj use curly braces and semicolons?
00:49:35 <quchen> Yes, loads of it
00:49:47 <ertes-w> quchen: but it doesn't matter to me…  *i* can use the quiet and layouty syntax
00:50:43 <dminuoso> ertes-w: Yesterday I scratched my head when Ruby failed to parse `[value, m heads]` I didn't even bother to think that it might not accept it.
00:50:50 <dminuoso> Was a very sad panda.
00:50:54 <quchen> ertes-w: https://github.com/ghc/ghc/blob/4364f1e7543b6803cfaef321105d253e0bdf08a4/compiler/typecheck/TcRnDriver.hs#L1417
00:50:58 <quchen> }}}}}
00:51:12 <ertes-w> dminuoso: i don't know what that's supposed to mean
00:51:23 <ertes-w> no ruby experience here
00:51:49 <dminuoso> ertes-w: Well the same thing in Haskell, where `value` and `heads` are some variables, and `m` is some function..
00:52:08 <dminuoso> ertes-w: My mistake is just that methoc call parens for m(heads) are _sometimes_ optional.
00:52:17 <dminuoso> in that spot they are not.
00:52:32 <quchen> Riiiight. urgh
00:52:54 <ertes-w> quchen: oh, that hurts to read, not so much because of the braces, but because he doesn't use layout
00:53:11 <ertes-w> dminuoso: ah
00:53:54 <ertes-w> quchen: it's really difficult to make out the structure in that code…  line 1444 is just bad style in my view
00:54:31 <ertes-w> (i get why he's doing it, but there are better ways to do it than hiding layout)
00:54:41 <quchen> Yeah it definitely takes some getting used to
00:55:26 <quchen> Early returns via {{{{{;;;;;;;;}}}}}}}}}}
00:55:59 <quchen> It’s like Lisp, but with more parentheses
00:56:14 <ertes-w> transformers is a boot library and it has MaybeT and ExceptT…  perhaps he should consider just using those
00:56:31 <ertes-w> no, most lisp code exposes the structure through layout
00:57:48 <ertes-w> ContT may be an even better way to do it
00:58:17 <quchen> Nooooooooo
00:58:21 <quchen> Nonononononono. No!
00:58:39 <ertes-w> @let abort = ContT . const . pure
00:58:40 <lambdabot>  Defined.
00:58:51 <ertes-w> :t abort
00:58:53 <lambdabot> Applicative m => r -> ContT r m a
00:59:39 <quchen> …or callCC.
00:59:57 <quchen> 5-times nested callCC ;-)
01:00:16 <ertes-w> or just 5 times nested ContT with 'abort' =)
01:00:31 <ertes-w> less code and probably slightly more efficient
01:16:30 <kuribas> :t (to ((+) <$> view _1 <*> view _2)) -- is there an easier way to write this?
01:16:31 <lambdabot> (Field2 s s a a, Field1 s s a a, Num a, Contravariant f, Profunctor p) => Optic' p f s a
01:17:32 <kuribas> you can also  use foldr for early return
01:20:34 <ertes-w> kuribas: liftA2 (+) fst snd
01:20:49 <ertes-w> or even just:  (\(x, y) -> x + y)
01:20:54 <kuribas> ertes-w: what if I only have a lens?
01:21:13 <ertes-w> kuribas: liftA2 (+) (view l1) (view l2)
01:21:29 <kuribas> there's also a "to"...
01:21:48 <ertes-w> kuribas: yes, that's my point:  'to' use rather useless
01:22:01 <ertes-w> you can always use it spontaneously…  no need to write actual getters
01:22:25 <kuribas> you mean like views?
01:22:55 <kuribas> > liftA2 (+) fst snd (1, 2, 3)
01:22:57 <lambdabot>  error:
01:22:57 <lambdabot>      • Couldn't match type ‘(t, t)’ with ‘(Integer, Integer, Integer)’
01:22:57 <lambdabot>        Expected type: (Integer, Integer, Integer) -> t
01:23:07 <ertes-w> i mean like:  t1 . t2 . to f
01:23:26 <kuribas> > ((+) <$> view _1 <*> view _2) (1, 2, 3)
01:23:27 <ertes-w> > liftA2 (+) (view _1) (view _2) (1,2,3)
01:23:28 <lambdabot>  3
01:23:29 <lambdabot>  3
01:25:00 <kuribas> > view (traverse . to (liftA2 (+) (view _1) (view _2))) [(1, 2, 3), (4, 5, 6)]
01:25:03 <lambdabot>  error:
01:25:03 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M302747159854...
01:25:03 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:25:25 <ertes-w> if you have a choice between a plain function and a getter you should almost always prefer plain functions, because 'to' can turn every function into a getter ad hoc if necessary
01:28:42 <kuribas> > toListOf (traverse . to (liftA2 (+) (view _1) (view _2))) [(1, 2, 3), (4, 5, 6)]
01:28:43 <lambdabot>  [3,9]
01:30:24 <kuribas> can this be simplified?
01:31:22 <athan> Are there degrees of interuptability for async exceptions? Or maskability? Maybe something typed perhaps?
01:41:21 <mniip> hmm
01:41:35 <mniip> :t \f -> liftA2 f id id
01:41:36 <lambdabot> (a -> a -> c) -> a -> c
01:50:25 <ertes-w> > map (liftA2 (+) (view _1) (view _2)) [(1,2,3), (4,5,6)]
01:50:28 <lambdabot>  [3,9]
01:50:31 <ertes-w> kuribas: ^
01:51:22 <ertes-w> or if you insist on using traversals…
01:51:42 <ertes-w> > (traverse %~ liftA2 (+) (view _1) (view _2)) [(1,2,3), (4,5,6)]
01:51:44 <lambdabot>  [3,9]
01:53:36 <kuribas> ertes-w: I try to avoid line-noise operators ;-)
01:54:22 <ertes-w> then 'map' =)
01:54:53 <ertes-w> kuribas: also it's probably statically known that you have 3-tuples, so a list comprehension might actually be best
01:55:11 <ertes-w> > [ x + y | (x, y, _) <- [(1,2,3), (4,5,6)] ]
01:55:13 <lambdabot>  [3,9]
01:55:39 <kuribas> ertes-w: in my real code I am using a sequence though
01:55:54 <ertes-w> kuribas: for sequences you can take 2, then sum
01:56:13 <ertes-w> :t map (sum . Seq.take 2)
01:56:14 <lambdabot> Num b => [Seq.Seq b] -> [b]
01:56:24 <kuribas> ertes-w: the outer list...
01:56:39 <ertes-w> ah, then use fmap instead of map
01:57:12 <kuribas> > [x + y | (x, y, _) <- Seq.fromList [(1, 2, 3), (4, 5, 6)]]
01:57:14 <lambdabot>  error:
01:57:14 <lambdabot>      • Couldn't match expected type ‘[(a, a, c0)]’
01:57:14 <lambdabot>                    with actual type ‘Seq.Seq (Integer, Integer, Integer)’
01:58:14 <nullie> You need tolist for comprehension
01:58:55 <kuribas> ertes-w: I suppose I could also do "addFstPair (a, b, _) = a+b", then use that with the lenses/map/traverse
01:59:06 <kuribas> seems cleaner for non golf code :)
02:00:14 <ertes-w> Seq is a monad, isn't it?
02:00:29 <ertes-w> > do (x, y, _) <- Seq.fromList [(1,2,3), (4,5,6)]; pure (x + y)
02:00:31 <lambdabot>  fromList [3,9]
02:01:07 <ertes-w> but still…  this is just fmap =)
02:01:47 <ertes-w> just gives you the option of using MonadComprehensions
02:01:57 <ertes-w> so you get the nice comprehension syntax for this
02:01:59 <kuribas> fmap will not work with nested sequences
02:02:02 <kuribas> (which I have)
02:02:54 <nullie> fmap (fmap f)
02:04:04 <dminuoso> (fmap . fmap) f
02:04:09 <nullie> No
02:04:14 <nullie> That's different
02:04:44 <nullie> @pl fmap (fmap f) xs
02:04:44 <lambdabot> fmap (fmap f) xs
02:05:21 <dminuoso> nullie: Weird. I kind of thought that was the definition of (.)
02:05:40 <nullie> dminuoso: fmap has two arguments
02:05:48 <dminuoso> nullie: so?
02:06:04 <nullie> . doesn't work for this case
02:06:19 <nullie> @src (.)
02:06:19 <lambdabot> (f . g) x = f (g x)
02:06:35 <dminuoso> nullie: I've done that exact transformation...
02:06:37 <nullie> Hmm
02:06:52 <nullie> Maybe I'm wrong then
02:08:00 <dminuoso> nullie: the @pl bit was a bit silly because it already was point free. I just rewrote, because I personally find that `(fmap . fmap) f` is clearer and shows better whats going on
02:08:07 <nullie> Yeah
02:08:40 <dminuoso> for maximum effort one could also do `fmap fmap fmap f` I guess
02:08:59 <dminuoso> but that has the opposite effect
02:09:37 <nullie> > (fmap . fmap) (+3) [[1,2], [4,5]]
02:09:39 <lambdabot>  [[4,5],[7,8]]
02:10:44 * nullie посыпает голову пеплом
02:12:12 <dminuoso> nullie: Things like that are also amazing for zipWith.
02:12:47 <dminuoso> > (zipWith . zipWith) (+) [[1,2], [3,4]] [[10,20] [30,40]]
02:12:49 <lambdabot>  error:
02:12:50 <lambdabot>      • Couldn't match expected type ‘[Integer] -> [c]’
02:12:50 <lambdabot>                    with actual type ‘[Integer]’
02:12:54 <dminuoso> > (zipWith . zipWith) (+) [[1,2], [3,4]] [[10,20], [30,40]]
02:12:56 <lambdabot>  [[11,22],[33,44]]
02:13:18 <ertes-w> nullie: fmap is curried
02:13:32 <ertes-w> (fmap . fmap) f xs = fmap (fmap f) xs
02:13:36 <nullie> Yeah, I've realized my mistake
02:18:34 <kuribas> it's more like (getSeq1 . traverse . getSeq2 . traverse)
02:19:19 <dminuoso> kuribas: semantic editor combinators they are called I think?
02:19:34 <kuribas> dminuoso: optics
02:20:03 <dminuoso> kuribas: mmm?
02:20:32 <kuribas> dminuoso: getSeq1 and getSeq2 are lenses
02:20:56 <dminuoso> Ahh
02:21:24 <dminuoso> kuribas: Different conversation, nevermind.
02:21:36 <kuribas> np
02:22:28 <dminuoso> So here's a question Ive been wondering about. How do I generate coordinates such as [(x, y) | x <- [1..5], y <- [10..20]] but in such a way, that I get a nested array
02:22:37 <dminuoso> Basically I want the list comprehension but without `join`
02:23:32 <ClaudiusMaximus> nested list comprehensions, like this? [ [ (x, y) | y <- [10..20] ] | x <- [1..5] ]
02:24:17 <dminuoso> ClaudiusMaximus: Ah, did not think that you could nest them. That works nicely thanks
02:31:53 <kuribas> dminuoso: of course, a list comprehension is just an expression
02:34:46 <martinr_> guys
02:34:51 <martinr_> you know stuart little? the film?
02:35:01 <martinr_> the screenplay was written by m. night shyamalan
02:38:38 <mimi_vx> :D in haskell ?
02:39:53 <brynedwards> lol
03:20:32 <dminuoso> Whats the point of placing a non-required functions into a typeclass?
03:20:49 <dminuoso> Is it to allow overriding them in case that given some type there may be a more efficient way?
03:21:28 <dminuoso> Or are there other considerations?
03:21:36 <opqdonut> yeah
03:21:38 <opqdonut> that's the usual reason
03:21:46 <Axman6> often they can be derived from other functions in the class, but putting them in the class allows for efficient implementations
03:22:16 <Axman6> like mconcat in Monoid, some types perform better if you associate mappend to the right other to the left
03:22:45 <dminuoso> Ah that makes sense. I was trying to think of some example where that might be the case.
03:22:51 <Rembane> And you might want to untangle some things before you mappend them.
03:22:55 <Axman6> so for lists, mconcat would be foldr (++) [] but for Sum it would probably be foldl
03:27:24 <Boomerang> dminuoso: Some typeclasses have default implementation for all their function in terms of one another so you can override the one that's most convenient. For example Eq has `==` defined as not `/=` and `/=` defined as not `==`.
03:34:23 <dminuoso> Boomerang: Ahh right. I remember this from Monad - though Ive made it a habit of implementing _all_ of them separately for practice. :)
03:35:14 <danilo2_> Hi guys! I've seen a strange thing. I create newtype like `newtype MyState s m a = MyState (State s m a) deriving (MonadIO)` where `State` is from mtl. My question is why my state works MUCH time slower than mtl state IF and ONLY IF the file is compiled with -XStrict ?
03:39:11 <Rembane> danilo2_: This is just a hunch, but are you using the strict or lazy State?
03:44:49 <danilo2_> Rembane: strict one of course!
03:46:23 <mahe2> Hi, is there an obvious way to avoid the first runConduitRes call:
03:46:29 <mahe2>   replaceFiles rootFilePath predicate lineMapper =
03:46:29 <mahe2>     let singleFileSink fp = when (predicate fp)
03:46:29 <mahe2>           $ C.sourceFile fp
03:46:29 <mahe2>          .| C.decodeUtf8
03:46:29 <mahe2>          .| C.map Text.lines
03:46:31 <mahe2>          .| C.mapE lineMapper
03:46:34 <mahe2>          .| C.map Text.unlines
03:49:36 <ongy> ghc really doesn't like getting swapped, does it?
03:54:56 <kuribas> is there preview with default, or should I use fromMaybe?
03:56:56 <ertes-w> kuribas: you can fold instead
03:57:26 <kuribas> > review _Just (Just 2)
03:57:27 <lambdabot>  Just (Just 2)
03:57:37 <ertes-w> > foldrOf traverse const 0 [1,2,3]
03:57:39 <lambdabot>  1
03:57:42 <ertes-w> > foldrOf traverse const 0 []
03:57:44 <lambdabot>  0
03:57:51 <quchen> ಠ_ಠ
03:58:07 <ongy> quchen: !
03:58:22 <quchen> Oops
03:58:32 <ongy> it's almost weekend. Again!
03:58:32 <kuribas> > foldrOf _Just const 0 (Just 2)
03:58:34 <lambdabot>  2
03:58:40 <quchen> ongy: Mid March is the plan
03:58:47 <ongy> ahh
03:59:00 <ongy> good to know :)
03:59:02 <arpl> Hello, have the need to output as webpages. Currently looking at blaze for HTML, clay for CSS and ghcjs for JavaScript. Something wrong with those picks? Any other favorites?
03:59:44 <[exa]> ghcjs might be a bit of overkill for just producing javascript
04:00:00 <ertes-w> arpl: they are fine…  lucid probably has a slightly more streamlined interface than blaze-html
04:00:04 <kuribas> ertes-w: that's more verbose as fromMaybe
04:00:19 <kuribas> > fromMaybe 0 $ review _Just (Just 2)
04:00:21 <lambdabot>  error:
04:00:21 <lambdabot>      • No instance for (Num (Maybe Integer))
04:00:21 <lambdabot>          arising from a use of ‘e_102’
04:00:25 <kuribas> > fromMaybe 0 $ preview _Just (Just 2)
04:00:27 <lambdabot>  2
04:00:35 <ertes-w> kuribas: there may be a more special-purpose fold…  i'm just pointing out that folding is the answer =)
04:00:47 <ertes-w> kuribas: (review is really just a special fold)
04:00:56 <ertes-w> *preview
04:01:15 <ertes-w> > foldrOf traverse (const . Just) Nothing [1..]
04:01:17 <lambdabot>  Just 1
04:01:18 <ertes-w> > foldrOf traverse (const . Just) Nothing []
04:01:20 <lambdabot>  Nothing
04:01:29 <quchen> ongy: Franz and me are on another conference later this month, so we need some more time to prepare talks
04:02:02 <ertes-w> kuribas: as for keeping code short there is (^?)
04:02:15 <ertes-w> > [1..] ^? traverse
04:02:17 <lambdabot>  Just 1
04:04:25 <Axman6> arpl: you might also find something like purescript is a better option for JS, yes it's not Haskell but it's close enough, and there's plenty of projects for getting good interoperability between the two
04:04:39 <kuribas> ertes-w: I suppose I'll have to embrace the line noise :-/
04:05:43 <kuribas> > fromMaybe 0 $ Just 2 ^? _Just
04:05:45 <lambdabot>  2
04:06:15 <Axman6> @hoogle a -> Fold b a
04:06:15 <lambdabot> Control.Foldl lastDef :: a -> Fold a a
04:06:15 <lambdabot> Control.Lens.Fold replicated :: Int -> Fold a a
04:06:15 <lambdabot> Control.Foldl.Statistics skewness :: Double -> Fold Double Double
04:06:35 <arpl> [exa], ertes-w: Thank you. Always difficult to pick libraries for new fields/domains. Lucid was the 2nd one on my list to look at.      ghcjs because in the future there might be more ´heavy duty´ clientside scripting.         Best is of course to play with them.
04:06:35 <arpl> Axman6: Thank you too. PureScript initially discarded because of that, but can´t hurt to still look at. : )
04:06:37 <ertes-w> kuribas: personally i would just fold, because going through Maybe seems like a needless indirection to me
04:06:38 <Axman6> woah, that last one's mine! didn't expect that
04:07:01 <ertes-w> kuribas: it's something i commonly do for lists, too:  foldr (\x _ -> print x) (putStrLn "Got nothin'.")
04:07:43 <kuribas> ertes-w: I already use maybe (because of at)
04:07:51 <Axman6> :t const . print
04:07:52 <lambdabot> Show a => a -> b -> IO ()
04:08:06 <ertes-w> arpl: personally i'd just go with GHCJS
04:08:11 <Axman6> :t for
04:08:12 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
04:10:00 <ertes-w> arpl: caveat: it produces massive JS files, which you should minify using closure-compiler…  that brings them down to a couple hundred KiBs, which you can usually cut by half by enabling compression on your webserver
04:10:39 <Axman6> yeah GHCJS JS is pretty gnarly
04:11:23 <ertes-w> there is just too much benefit in reusing code on both sides of the wire
04:11:34 <merijn> Clearly the solution is to use Ur/Web ;)
04:12:48 <freeman42x]NixOS> A question about how <$> works when it appears there is no Functor instance for what it applies to: http://lpaste.net/6407821314182086656
04:13:20 <merijn> freeman42x]NixOS: You're not applying <$> to Identity
04:13:24 <Axman6> that <$> is Gen's fmap, not Identity's
04:13:24 <ertes-w> also i really dislike anything bower =)
04:13:34 <merijn> freeman42x]NixOS: You're applying it to "arbitrary" which is "Gen a"
04:13:39 <Axman6> or whatever Arbitrary's thing is
04:14:06 <Axman6> freeman42x]NixOS: Identity there is the function with type a -> Identity a
04:14:21 <Axman6> which is applied to something of type Gen a to give Gen (Identity a)
04:14:45 <Axman6> (Identity <$>) :: Functor f => f a -> f (Identity a)
04:15:04 <freeman42x]NixOS> got it, thank you! not used to <$> yet
04:15:49 <Axman6> just remember the thing on the left is a normal function from a -> b which you're lifting into some functor context to give you back f a -> f b
04:19:16 <arpl> Thank you all. Minify noted. Enough to read and play with ... which I will start now. : )
04:22:00 <kuribas> is there a better way to say "someLenses . at key . _Just . to refineValue" ?
04:23:19 <Axman6> :t at
04:23:20 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
04:23:56 <Axman6> :t mapped show
04:23:57 <lambdabot> error:
04:23:57 <lambdabot>     • Could not deduce (Settable []) arising from a use of ‘mapped’
04:23:57 <lambdabot>       from the context: (Show a, Functor f)
04:24:08 <Axman6> :t mapped
04:24:09 <lambdabot> (Functor f2, Settable f1) => (a -> f1 b) -> f2 a -> f1 (f2 b)
04:28:28 <Gurkenglas> kuribas, at key . _Just = ix key
04:28:43 <kuribas> Gurkenglas: thanks!
04:29:04 <Gurkenglas> kuribas, view (l . to f) = views l f
04:29:10 <ertes-w> merijn: is ur/web still alive/used?
04:31:41 <EvanR> i predict ur/web will become wildly popular
04:32:05 <Gurkenglas> Is hayoo slowed to darn for others too?
04:32:47 <Gurkenglas> (fast again, still something to inquire about)
04:35:43 <merijn> ertes-w: It was last I checked
04:43:49 <freeman42x]NixOS> is there a better(TM) solution to this? http://lpaste.net/4806352447591153664 took a lot to figure out
04:44:17 <bash0r> Can a queue of a Control.Concurrent.Chan overflow?
04:44:39 <[exa]> freeman42x]NixOS: liftA2?
04:44:55 <hpc> bash0r: you can run out of memory on your machine
04:45:06 <hpc> but it doesn't have a fixed size
04:45:23 <[exa]> freeman42x]NixOS: oh it's more complicated :]
04:45:25 <bash0r> hpc: is there a way to control the logback?
04:45:36 <EvanR> use a bounded chan
04:47:21 <freeman42x]NixOS> [exa], you mean it would not work with liftA2? was expecting that there is some function that can fmap? over more than 1 thing
04:47:37 <tabaqui> @djinn a -> b
04:47:37 <lambdabot> -- f cannot be realized.
04:47:39 <lyxia> freeman42x]NixOS: https://hackage.haskell.org/package/QuickCheck-2.11.3/docs/Test-QuickCheck.html#v:applyArbitrary2
04:47:41 <tabaqui> @djinn a -> a
04:47:41 <lambdabot> f a = a
04:47:54 <tabaqui> @djinn a -> Int
04:47:54 <lambdabot> Error: Undefined type Int
04:48:50 <bash0r> EvanR: looks a lot better fitting my needs. Do you have an idea how to implement rejection of messages?
04:49:14 <EvanR> you mean, ignoring messages you dont like?
04:49:39 <lyxia> freeman42x]NixOS: genericArbitrarySingle, using generic-random, though it's somewhat overkill for just two fields. https://hackage.haskell.org/package/generic-random-1.1.0.2/docs/Generic-Random.html
04:50:00 <lyxia> freeman42x]NixOS: your solution is probably the most straightforward one
04:50:13 <EvanR> pair a bounded chan with a discriminating function that writers must go through before inserting
04:50:24 <EvanR> hide it behind an ADT
04:50:36 <bash0r> EvanR: it's more like thouands or millions of message can enter the machine over a network connection.
04:50:56 <EvanR> so
04:51:24 <bash0r> EvanR: ouh... That's a nice solution. If the discriminating function rejects due to high load... That's genius, thanks!
04:51:46 <EvanR> ok i was talking about by content
04:52:28 <bash0r> But it doesn't change the strategy, right?
04:52:39 <EvanR> for a bounded chan you should be able to simply drop if the chan is full
04:53:03 <bash0r> Docs say it will block the write until the channel gets free slots.
04:53:15 <EvanR> dont use that one then
04:53:29 <EvanR> tryWrite or something
04:54:54 <bash0r> Though, no way to tell how much is in the queue.
04:55:58 <bash0r> I think I'll go with the discriminating function for load balancing.
04:56:02 <bash0r> Thank you very much.
04:58:23 <freeman42x]NixOS> lyxia, I thought it would work with applyArbitrary2 , but for some reason I can not import it: Variable not in scope: applyArbitrary2 even though I imported Test.QuickCheck.Arbitrary
05:01:30 <freeman42x]NixOS> lyxia, it does not appear under :browse Test.QuickCheck.Arbitrary but it is exported from the module: https://hackage.haskell.org/package/QuickCheck-2.11.3/docs/src/Test-QuickCheck-Arbitrary.html#applyArbitrary2
05:03:24 <lyxia> freeman42x]NixOS: it's a very new addition to QC
05:03:57 <merijn> hmmm
05:04:21 <lyxia> freeman42x]NixOS: Can you check your version of QuickCheck?
05:04:29 <freeman42x]NixOS> lyxia, oh, I see, and I am on LTS-9.20 GHC 8.0.2
05:04:30 <merijn> I have a weird issue where I constraint a typeclass instance but am somehow unable to use that constraint in the body of said instance?
05:05:35 <merijn> http://lpaste.net/1441677168143761408
05:05:46 <merijn> How could it fail there?
05:06:01 <merijn> The instance constraint requires that instance exists...
05:08:04 <merijn> It's also demanding I enable UndecidableInstances, which also seems wrong, tbh
05:08:09 <freeman42x]NixOS> lyxia, no idea how to check the package version since I haven't specified it in the cabal file
05:08:39 <freeman42x]NixOS> but I can't use anything newer than LTS-9.20 anyway because it would break GHC-MOD
05:08:40 <lyxia> merijn: I guess the deriving clause of the data instance gets desugared into a toplevel instance that doesn't have the same context in scope.
05:09:05 <merijn> lyxia: ah...you might be right
05:09:15 <merijn> That's some god awful BS...
05:09:41 <merijn> Anyone have any suggestions how to fix that?
05:10:18 <lyxia> I don't see one other than standalone deriving
05:10:50 <merijn> But I don't think standalone deriving would work either, would it?
05:11:20 <freeman42x]NixOS> lyxia, QuickCheck 2.9.2 so that must be it
05:13:49 <lyxia> merijn: why not?   deriving instance Show (BackendKey b) => Show (BackendKey (RawSqlite b))
05:14:02 <lyxia> freeman42x]NixOS: stack exec ghc-pkg -- list
05:14:03 <freeman42x]NixOS> yup the function is missing from that version: https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/src/Test-QuickCheck-Arbitrary.html#applyArbitrary2
05:14:07 <lyxia> freeman42x]NixOS: or go to stackage.org
05:14:35 <merijn> Will StandaloneDeriving behave the same as GeneralisedNewtypeDeriving?
05:14:38 <lyxia> freeman42x]NixOS: you can also look at the changelog for the latest version to see where each thing comes from
05:14:47 <lyxia> merijn: yes it will!
05:15:18 <lyxia> Although Show might be an exception...
05:15:32 <merijn> lyxia: That sounds like "no it won't", then
05:15:41 <merijn> That sounds like it's just doing regular deriving
05:16:04 <merijn> I suppose this is what DerivingStrategies are for, but don't think I can push those upstream
05:17:52 <lyxia> I mean deriving Show remains unaffected by GND, regardless of StandaloneDeriving
05:21:51 <phadej> you can `deriving newtype (Show)` with DerivingStrategies though
05:22:13 <phadej> ah, that was mentioned, by bad
05:22:16 <merijn> phadej: Right, see last message :p
05:26:26 <freeman42x]NixOS> lyxia, cheers, updated to QuickCheck 2.11.3 and now I can use arbitrary = applyArbitrary2 Two quite elegant :D
05:36:34 <lyxia> freeman42x]NixOS: yw
05:42:10 <danilo2_> Hi guys! I've got very strange problem. I've got this code: `primitive ~a = lift (primitive a)` If I compile it with -XStrict it works much slower than without -XStrict. What I dont get is why it is even affected. Code in context (4 lines) : http://lpaste.net/362556
05:42:40 <danilo2_> If I understand correctly -XStrict should not touch this code, because I use explicite tilde there
05:56:45 <cocreature> danilo2_: is that the only thing in the module or could it be that you are misinterpreting what is actually getting slower here?
05:57:31 <danilo2_> cocreature: im 100% sure it is this. If I move these lines to module without -XStrict and import it it runs fast
05:57:48 <merijn> danilo2_: Do you get the same core in both cases?
05:57:52 <danilo2_> cocreature: good question btw. The majority of such things appear elsewhere
05:57:57 <merijn> danilo2_: i.e. is it getting inlined when in the same module?
05:57:59 <cocreature> danilo2_: that sounds like it could also be inlining
05:58:03 <lyxia> I get the same core from this.
05:58:15 <merijn> Whoo! I have good intuition for guessing :p
05:58:28 <danilo2_> merijn: I didnt inspect core. Making small use case out of it would require much more time and inspecting core of bigger project is ismply impossible (unless for me)
05:58:45 <danilo2_> cocreature: how inlining could affect it ?
05:58:54 <danilo2_> how -XStrict affects inlining ?
05:59:03 <merijn> danilo2_: No, but being in the same module might
05:59:04 <cocreature> danilo2_: moving things to a different module affects inlining
05:59:08 <cocreature> or can affect it
05:59:21 <danilo2_> it isnt this. If I enable -XStrict in this second module it gets slow again
05:59:34 <danilo2_> 100% sure, just tested it again
05:59:35 <lyxia> maybe there are differences in some annotations, that I usually hide
06:00:24 <lyxia> The lazy version generates more INLINE annotations
06:00:53 <danilo2_> lyxia: What do you mean? What INLINE annotations the lazy verison generates more? thats very interesting
06:01:11 <danilo2_> lyxia: basically ythe lazy versions sohuld be inlind the same way strict one. I put explicite inline pragma there
06:01:37 <danilo2_> cocreature: btw how moving things dto toher module affects inlining fof thigs with explicite INLINE pragma ?
06:02:16 <[exa]> danilo2_: isn't the inner 'primitive' strict?
06:02:40 <danilo2_> [exa]: what do you mean exactly ?
06:04:05 <cocreature> danilo2_: good point, I hadn’t seen the INLINE pragma when I said that
06:04:16 <lyxia> danilo2_: https://gist.github.com/Lysxia/34684c9ca9fe4772ea38a5065414f542 The source I compiled and corresponding simplifier outputs with and without Strict
06:05:01 <lyxia> The lazy version has some things that look like "[InlPrag=INLINE (sat-args=0)]" on toplevel identifiers, that the strict version doesn't have
06:05:20 <lyxia> and some more related differences
06:05:30 <danilo2_> lyxia: oh, thank you for looking at it so deeply!
06:05:40 <infandum> Is there an HCL color space for Data.Colour?
06:06:20 <danilo2_> lyxia: I'll file a bug in GHC bugtracker and if you dont mind I'd love to attach your link there, can I ?
06:06:25 <lyxia> sure
06:06:46 <danilo2_> lyxia: thank you once again for looking at it and finding out these differences. I'll post a link here in a minute!
06:10:17 <lyxia> danilo2_: If you can, also supply some code to observe the difference at runtime.
06:10:30 <danilo2_> lyxia: https://ghc.haskell.org/trac/ghc/ticket/14815#ticket
06:11:10 <danilo2_> lyxia: thank you once again!
06:56:22 <Gurkenglas> infandum, googling site:https://hackage.haskell.org/package/colour/docs/src hue finds https://hackage.haskell.org/package/colour-2.3.4/docs/src/Data-Colour-RGBSpace-HSL.html
06:59:04 <Gurkenglas> Though I guess you already found that one seeing as it's indexed in colour's main page...
07:02:15 <Gurkenglas> https://packdeps.haskellers.com/reverse/colour might find you something
07:40:08 <zacknite> Hi. I am interested in learning Haskell, coming from a Python, Racket, and C background. I was wondering how strong Haskell's library support is, and whether is follows a "batteries" included philosophy like Python and Racket
07:41:11 <merijn> zacknite: There's a decent library ecosystem, but it doesn't ship with the compiler (like python's stdlib ships with CPython)
07:41:25 <merijn> zacknite: So "base" (what ships with compiler is kinda barebones)
07:43:23 <EvanR> batteries sold separately
07:43:29 <EvanR> but theyre free
07:47:01 <merijn> EvanR: So, more like, "batteries freely available" :p
07:49:02 <benjwadams> Can enums in other languages be considered sum types?
07:49:08 <EvanR> what is batteries included again? everything is installed already, like haskell platform?
07:49:20 <merijn> EvanR: Something like that, I think
07:49:26 <merijn> benjwadams: Depends on the language
07:49:28 <benjwadams> they're union types, correct?  but they're all of the same data type
07:49:42 <EvanR> union and sum should really be distinguished
07:49:44 <benjwadams> merijn, say Python, C, or Java
07:49:50 <merijn> Definitely not in C
07:49:59 <merijn> python doesn't have enums at all (to my own frustration)
07:50:03 <merijn> I don't know about Java
07:51:14 <clarkenciel[m]> python 3.4 should have enums ya? https://www.python.org/dev/peps/pep-0435/
07:51:54 <EvanR> benjwadams: enums are a special kind of sum type, not the other way around
07:52:27 <EvanR> or equivalent to
08:10:11 <hempvoll> I'm getting the issue described at https://github.com/commercialhaskell/stack/issues/3848, but not on Arch. Is anyone else having this problem?
08:11:59 <theseb> beginner question.....language expert told me Haskell was better than Lisp because it came later and they learned some things since Lisp was invented...How is Haskell better?
08:12:43 <theseb> My fear is Haskell *will* be better but it won't the have the same brainless simplicity of syntax that Lisp does....Possible to have it both ways?
08:13:52 <EvanR> haskell has pretty simple syntax, whereas lisp has no syntax
08:13:56 <Bowlslaw> hahhahah
08:14:09 <EvanR> also PHP came later than haskell so it must be even better
08:14:19 <Bowlslaw> It seems like Lisp syntax is great for computers, but difficult for people
08:14:19 <theseb> EvanR: i can handle simple syntax
08:14:49 <EvanR> in fact you can transport a lot of syntax directly from lisp
08:14:58 <EvanR> (((f x) y) z) works
08:15:14 <EvanR> but you will eventually want to reduce parens as much as possible
08:15:36 <theseb> EvanR: parens are a double edged sword....they simplify syntax but are a nightmare to read
08:16:04 <EvanR> yes, they are the profound surrendering of implementing syntax, you just dont
08:16:14 <theseb> EvanR: i'm glad you said Haskell had simple syntax...i had the impression it was complex
08:16:19 <Bowlslaw> the paren syntax and its consequential evaluation are one reason why everyone learns about compilers and interpreters by writing a Lisp one
08:16:39 <EvanR> yes lisp is undoubtedly easier to implement
08:16:41 <kuribas> theseb: there have been projects to bring lisp syntax to haskell, but they didn't go anywhere
08:17:12 <EvanR> but we dont do things because they are easy... we do them because they are hard or something
08:17:24 <kuribas> theseb: the major advantage I think is the expressive type system.
08:18:03 <kuribas> theseb: which no lisp has AFAIK
08:18:07 <Bowlslaw> EvanR: in that regard, I think Lisp functions well as an "educational" language
08:18:14 <EvanR> "the" major advantage is pattern matching methods of definition
08:18:33 <kuribas> EvanR: you can have pattern matching in lisp/scheme
08:18:40 <EvanR> the major advantage is an efficient and sophisticated concurrent runtime
08:19:00 <EvanR> yeah i use the match macro in clojure, but its not the norm
08:19:49 <Bowlslaw> I first learned about FP from reading SICP, then I went to Scala, now I'm at Haskell
08:19:59 <Bowlslaw> which is certainly the most intriguing and apparentally useful
08:20:57 <theseb> Bowlslaw: is that because Lisp and Scala are gentler beginner languages for newcomers but it takes some extra time to get comfy with Haskell?
08:21:00 <EvanR> SICP is great, i wish it had more from haskell in it
08:21:16 <theseb> O
08:21:36 <Bowlslaw> theseb: SICP Is an intro to functional programming using Lisp, and so it is beginner friendly, but it is rigorous and more math oriented
08:21:46 <Bowlslaw> Scala is not even remotely beginner friendly
08:21:46 <theseb> I am aware of at least one major project where CEO said..."Haskell would be better but it is easier to find Scala devs"
08:21:46 <EvanR> its like SICP ended right before haskell and everything it entails was invented
08:22:51 <Bowlslaw> theseb: from my perspective, I know more about FP fundamentals, have practical use for learning it, and so Haskell is intriguing
08:23:20 <Bowlslaw> and I certaintly prefer its syntax and way to writing code, but I wouldn't discount Lisp as a great learning tool
08:23:37 <EvanR> all the good parts of SICP/lisp lore can be found in the basis of haskell, plus more
08:23:40 <Bowlslaw> Scala is...I dunno, it's too bloated,
08:24:28 <Bowlslaw> If I need object orientation for a project, I will use Kotlin or Perl/Moose. If I need to make a functional project, something more geared towards pure FP is more useful
08:24:48 <Bowlslaw> plus there is no binary compatability between minor Scala version and it takes forever to compile even the simplest scripts
08:25:38 <Bowlslaw> One thing Scala does have going for it is Spark. You can do some very cool and useful analysis and visualization of massive data sets
08:28:27 * MarcelineVQ surreptitiously leaves a packet of meat on the countertop http://www.luna-lang.org/
08:30:22 <guessWho> i want to use XOR metric which will work on binary numbers which module should i use to represent 32 byte string in binary
08:31:44 <cocreature> guessWho: a strict bytestring
08:32:13 <cocreature> maybe make a newtype if you want to make sure you don’t end up accidentally using bytestrings of a different length
08:34:41 <shapr> Wednesday night Haskell meetup with cement and chessai was really fun, now we're talking about an Atlanta unconference
08:35:17 <guessWho> cocreature : can then apply boolean operators on it .?
08:35:59 <cocreature> :t \f xs ys -> ByteString.pack (ByteString.zipWith f xs ys)
08:36:00 <lambdabot> error:
08:36:01 <lambdabot>     Not in scope: ‘ByteString.pack’
08:36:01 <lambdabot>     No module named ‘ByteString’ is imported.
08:36:12 <cocreature> :t \f xs ys -> Data.ByteString.pack (Data.ByteString.zipWith f xs ys)
08:36:13 <lambdabot> (Word8 -> Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
08:36:16 <cocreature> ^ guessWho
08:36:23 <sepakorayl> hello everyone, what's the best way to write something isomorphic to a product type of maybes with all maybes as nothing being invalid ?
08:38:02 <guessWho> cocreature : didn't get that can you please elaborate or point me to some reference or resourc
08:38:14 <guessWho> resources*
08:39:02 <cocreature> guessWho: pass a binary operator of "Word8 -> Word8 -> Word8" (e.g. xor) to that expression and you’ll get an expression that performs this binary operator on two ByteStrings
08:45:19 <sepakorayl> basically a type that is the product of a non empty subset of a set of types
08:50:40 <kuribas> sepakorayl: you want dependend types?
08:51:37 <kuribas> sepakorayl: maybe these: https://hackage.haskell.org/package/these-0.7.4/docs/Data-These.html
08:58:08 <ongy> compiling on a machine with low ram is interesting. It does actually help to Ctrl+C the build from time to time, to free up ram and start compiling again. So it doesn't swap as much.
08:58:54 <merijn> ongy: Tell it to use less parallel processes?
08:59:20 <ongy> mhh, I could do that. That may cut the processes in half. Only got 2 cores :D
09:00:50 <Bowlslaw> guys lazy eval and list comprehensiosn are blowing my mind right now
09:01:02 <ongy> in a good way, I hope
09:01:13 <APic> No Idea.
09:01:18 <Bowlslaw> you mean I can do `let s = [x*2 | x <- [1..]]` to have a list with the set of all even natural numbers?
09:01:43 <ski> @quote is.the.solution
09:01:43 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
09:01:54 <ongy> > [x*2 | x < [1..]]
09:01:56 <lambdabot>  error:
09:01:56 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
09:01:56 <lambdabot>      • In the second argument of ‘(<)’, namely ‘[1 .. ]’
09:02:03 <ongy> > [x*2 | x <- [1..]]
09:02:06 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
09:02:11 <ongy> Bowlslaw: looks like it
09:02:23 <Bowlslaw> and it's an "infinite list" ?
09:02:28 <Bowlslaw> so I can just select what I need at my leisure?
09:02:33 <Bowlslaw> as large as my hardware allows?
09:02:40 <merijn> Bowlslaw: Potentially larger
09:02:42 <SecretNINJA> > [2,4..]
09:02:44 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
09:02:53 <merijn> Bowlslaw: Because the start of the list can get GCed if it's no longer necessary
09:03:00 <Bowlslaw> coming from a primarily systems programming background with C, this is absolutely awesome
09:03:33 <merijn> Bowlslaw: Consider "mapM_ myFun [1..]" the start of the list can start getting GCed after it's been used, so it can keep going indefinitely
09:03:45 <Bowlslaw> GCed?
09:03:53 <merijn> Bowlslaw: (I mean, you'll run out of memory eventually, due to the numbers becoming larger and larger)
09:03:58 <merijn> Bowlslaw: Garbage Collected
09:04:02 <Bowlslaw> ah yes
09:05:36 <Bowlslaw> guys, I have a question about some Haskell resources: I just finished the first chapter of "LYAH" and I enjoyed it. But, I also have "Beginning Haskell: A project-based Approach" and "Haskell Programming From First Principles". Anyoe have experience with these?
09:06:14 <Bowlslaw> I also went through "roll your own IRC bot" to get a feel for a small application in Haskell, but sending commands to the bot didn't work
09:06:51 <merijn> Bowlslaw: LYAH is mostly obsoleted nowadays, IMO
09:07:25 <Bowlslaw> alright, then what about https://en.wikibooks.org/wiki/Yet_Another_Haskell_Tutorial/Getting_started ?
09:07:42 <Bowlslaw> Is it true that I should prefer Haskell resources after 2010?
09:07:46 <merijn> I don't know "Beginning Haskell", Haskell Programming From First Principles isn't how I'd organise things, but it's thorough and in-depth, so I'd probably recommend following that
09:10:31 <ski>   Prelude> [y | x <- [0 ..],let y = 2^x,then takeWhile by y < 1000]
09:10:32 <ski>   [1,2,4,8,16,32,64,128,256,512]
09:11:34 <Bowlslaw> haha, awesome
09:11:40 <Bowlslaw> cool bot
09:11:52 <Bowlslaw> is it able to save sessions on a per-user basis?
09:12:01 <ski> no
09:12:09 <Bowlslaw> WORTHLESS!
09:12:14 <Bowlslaw> jk of course >_>
09:13:21 <Bowlslaw> merijn: Why do you think LYAH is outdated?
09:14:17 <merijn> Bowlslaw: Not so much outdated as obsoleted. It's not very thorough, it skips over many important details, and generally just isn't up to snuff pedagogically. THe main reason it is famous is that when it came out there was nothing better and it looks very friendly and welcoming to beginners
09:14:40 <merijn> Bowlslaw: So while LYAH works fine as a sort of "look how cool this is", you haven't actually *learned* very much by the end of it
09:15:42 <Bowlslaw> I see.
09:15:56 <Bowlslaw> I did notice that it just shows stuff and explains pretty much nothing
09:16:06 <ski> (and no exercises)
09:16:21 * ski assumes Bowlslaw is aware of CIS194
09:16:23 <Bowlslaw> perhaps it's good for people who only need to learn Haskell syntax?
09:16:31 <Bowlslaw> ski what's that
09:16:32 <merijn> I think LYAH is important, historically, just not very good now
09:16:36 <ski> @where CIS194
09:16:36 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
09:16:49 <merijn> Bowlslaw: For those we have the tutorial, which assumes you have done typed FP like SML/Ocaml before
09:16:52 <Bowlslaw> :O
09:17:02 <Bowlslaw> I have gone through SICP
09:17:40 * ski doesn't recall whether SICP includes a pattern-matching macro
09:17:49 <ski> there's also
09:17:54 <ski> @where NICTA
09:17:54 <lambdabot> https://github.com/nicta/course
09:17:59 <ski> this is more advanced
09:18:27 <Bowlslaw> ski: it doesn't
09:18:45 <Bowlslaw> awesome
09:19:00 <Bowlslaw> you guys are a lot like the Perl community
09:19:01 <ski> Prolog and Erlang has pattern-matching, even if no static types
09:27:29 <smichel17> I'm new to the haskell ecosystem. Is this a reasonable place to ask about tooling (cabal, stack, etc)?
09:28:16 <brynedwards> smichel17: yep
09:31:04 <ski> > take 9 [?y | x <- [0 ..],let ?y = (3 ^ x - 1) `div` 2,odd ?y]
09:31:06 <lambdabot>  [1,13,121,1093,9841,88573,797161,7174453,64570081]
09:31:15 <ski> > take 9 [?y | ?x <- [0 ..],let ?y = (3 ^ ?x - 1) `div` 2,odd ?y]
09:31:16 <lambdabot>  <hint>:1:14: error:
09:31:16 <lambdabot>      Parse error in pattern: ?x
09:31:17 <lambdabot>      Possibly caused by a missing 'do'?
09:33:03 <ski> @type let f :: ((?x :: a) => b) -> a -> b; f y ?x = y in f
09:33:04 <lambdabot> error: Parse error in pattern: ?x
09:33:07 <ski> @type let f :: ((?x :: a) => b) -> a -> b; f y = \ ?x -> y in f
09:33:09 <lambdabot> error: Parse error in pattern: ?x
09:33:12 <ski> @type let f :: ((?x :: a) => b) -> a -> b; f y x = let ?x = x in y in f
09:33:13 <lambdabot> ((?x::a) => b) -> a -> b
09:33:18 <smichel17> I'm trying to install hulk (irc server). So far the projects I've played around with use stack to build, so I figure I'd stick with that for now, but I'm not quite sure how to do the equivalent of `cabal install hulk` with stack.
09:33:38 <SecretNINJA> stack install hulk ?
09:33:51 <smichel17> side note: I'm not really interested in a cabal vs stack discussion, which I understand is kind of like vim vs emacs in this community, just how to do it :P
09:34:22 <merijn> smichel17: Is hulk available on Stackage?
09:34:54 <smichel17> yeah, https://www.stackage.org/package/hulk
09:35:05 <merijn> Then presumably "stack install"?
09:35:06 <smichel17> I tried that, gets an error like: fastirc must match -any, but the stack configuration has no specified version (latest matching version is 0.2.0)
09:37:28 <MarcelineVQ> "This package is not currently in any snapshots. "
09:38:20 <MarcelineVQ> when you want a binary that isn't in a snapshot you'll need to do something  stack unpack hulk   then cd into the hulk dir it makes and  try  stack init --solver   and stack intall if that works
09:38:45 <smichel17> okay, thank you; I'll try that…
09:39:32 <MarcelineVQ> stack doesn't do the same job cabal does which is why there's these extra hoops
09:40:57 <smichel17> okay. I should really read more up on the differences between the tools
09:41:06 <MarcelineVQ> https://docs.haskellstack.org/en/stable/GUIDE/#what-makes-stack-special  https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
09:47:31 <humanoyd> Is there a way to tell `stack repl` to automatically enable all extensions that are used in the source files?
09:53:50 <dmwit> humanoyd: You can put those extensions in your cabal file. I don't know enough about stack to know whether it would use that, but it should.
09:54:05 <dmwit> And if it doesn't, I'm confident it has a way to stuff them in stack.yaml.
09:54:58 <merijn> dmwit: That's not the problem
09:55:12 <merijn> dmwit: The issue is that ghci has a different set of extensions for loaded code and interactive use
09:55:39 <merijn> I'm guessing the problem humanoyd is having is that he wants them enabled interactively
09:55:42 <dmwit> merijn: Right. And cabal at least tells the ghci instances it starts to use whatever's in the default-extensions field. Stack could (should?) do the same.
09:56:08 <merijn> dmwit: Does cabal enable default-extensions? That doesn't sound right, tbh
09:56:22 <merijn> I don't think it should enable interactive extensions unless told
09:56:42 <merijn> Then again, I don't think default-extensions should be used either, so what do I know :)
09:57:17 <dmwit> merijn: Yes, it does. I just tested to be double sure.
09:57:29 <dmwit> It seems like the right behavior to me.
09:57:39 <Bowlslaw> does anyone use http://leksah.org/ ? I've just been using vim with :terminal to open a repl below
09:57:54 <merijn> Bowlslaw: Not a significant number of people
09:58:24 <merijn> Bowlslaw: I'd say this channel is pretty much: 1/3rd vim, 1/3rd emacs, 1/3rd random misc (Atom, VS Code, InteliJ, whatever)
09:58:41 <Bowlslaw> coo
09:58:42 <Bowlslaw> l
09:59:33 <humanoyd> dmwit: merijn Thanks, I will try that
10:11:12 <fourroot> https://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
10:11:15 <fourroot> any thoughts ?
10:12:31 <SecretNINJA> I suppose all the extra noise in your brain can sometime get in the way of "getting shit done" :D
10:12:37 <Rembane> fourroot: You should definitely learn Haskell.
10:13:16 <fourroot> okay
10:13:31 <fourroot> which is the best IDE for it
10:14:15 <SecretNINJA> I use intellij + haskforce
10:14:23 <Rembane> The IDE of your choice + the Haskell plugin
10:14:56 <Bowlslaw> I'm tempted to call the guy who wrote that article an idiot...
10:15:09 <Bowlslaw> seriously, demotivation?
10:15:17 <fourroot> is there haskell plugin for pycharm
10:15:24 <Bowlslaw> that's a personal problem, not the general thing he tries to make it seem
10:15:50 <SecretNINJA> You realize the article is joke right
10:15:56 <Bowlslaw> no
10:16:40 <Bowlslaw> glad to know it's a joke
10:16:40 <fourroot> Why compiled language programmers hate python and haskell
10:16:57 <Bowlslaw> fourroot: what?
10:17:02 <fourroot> i meant
10:17:10 <fourroot> most c , c++ devs hate py and haskell
10:17:31 <Bowlslaw> I'm prmarily a C programmer and I love learning Haskell
10:17:53 <Bowlslaw> my job is Perl and I dislike Python for three personal reasons
10:17:58 <Rembane> Bowlslaw: It's when you go back to C and realize you can't use all the nice things from Haskell that you become demotivated.
10:18:28 <Bowlslaw> Rembane: That doesn't make sense to me as C and Haskell are useful for compeltely different things
10:18:35 <slamtime> Bowlslaw: as a python evangelist I'd be curious to know your 3 reasons
10:18:57 <slamtime> fear of sneks?
10:19:00 <SecretNINJA> Im primarily using Scala+ scalaz which if I understood scala better I could basically be writing code like in haskell
10:19:03 <SecretNINJA> :D
10:19:34 <fourroot> what are 3 reasons bwlslaw
10:19:38 <fourroot> bowlslaw
10:19:56 <Bowlslaw> 1) I dislike Python's whitespace rules as I think they are ridiculous 2) I favor languages which encourage programmer freedom ala TMTOWTDI 3) i see no personal reason for me to learn python because I can do anything I want with Perl at this point
10:20:18 <Rembane> Bowlslaw: They are indeed. But maybe you want a Reader monad or to limit side effects in C and that is very hard to do.
10:21:10 <Bowlslaw> that being said, there are a lot of good applications written in Python, like Binary Ninja
10:22:18 <slamtime> Bowlslaw: your first and second arguments are both just that you don't like following an established style
10:22:40 <slamtime> which makes it much easier to work in teams and on unfamiliar code
10:23:14 <fourroot> i like py only because the community is huge
10:23:17 <slamtime> "There should be one-- and preferably only one --obvious way to do it.
10:23:17 <slamtime> Although that way may not be obvious at first unless you're Dutch." - Zen of Python
10:23:37 <fourroot> there are modules available for every type of task
10:23:42 <fourroot> only for that reason
10:23:46 <TMA> python seems too straitjackety to me too
10:23:55 <fourroot> plus google and other companies are backing it
10:24:14 <Bowlslaw> slamtime: that's not true, it's important to establish conventions. I work with huge code bases
10:24:28 <Bowlslaw> I just don't want some moron imposing his ideas on me
10:24:37 <slamtime> :p
10:24:41 <slamtime> fair I suppose
10:24:50 <Bowlslaw> they are largely personal reasons for me
10:25:04 <slamtime> I happen to agree with most of the PEP-8 style decisions
10:25:09 <Bowlslaw> fourroot: Perl has CPAN
10:25:22 <slamtime> I think python is quite pleasurable to work with because of them
10:26:27 <SecretNINJA> python has scikit learn, numpy and pandas :P
10:26:37 <Bowlslaw> lol
10:26:51 <SecretNINJA> Only reasons to use the language :D
10:27:08 <SecretNINJA> Quick and dirty machine learning D:
10:27:51 * ski . o O ( machine learning in machine language )
10:28:03 <Bowlslaw> that sounds like a nightmare
10:28:18 <hyperisco> which language do you think will be used to learn the AI that destroys us all?
10:28:29 <SecretNINJA> R
10:28:36 <TMA> SecretNINJA: so the main selling point for python is that it is a frontend for non-python libraries?
10:28:40 <madVillan> how to conver [Word8] to string
10:29:07 <cocreature> madVillan: how are characters encoded?
10:29:09 <ystael> SecretNINJA: R destroys people, that's for damn sure. Mostly the people who have to read it
10:29:17 <Bowlslaw> hey, computer, convert word8 to string!
10:29:17 <hyperisco> the main selling point for Python is the actual pythons advocates will sic on you if you don't comply
10:34:58 <madVillan> how to convert word8 TO STRING
10:35:38 <cocreature> madVillan: how are the characters encoded?
10:35:53 <madVillan> utf -8 ?
10:36:19 <cocreature> for utf-8 you can use https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Codec-Binary-UTF8-String.html#v:decode
10:36:26 <APic> madVillan: Please do not shout.
10:37:01 <madVillan> madVillan : Woah. when did i shout >?
10:37:42 <fourroot> oh god
10:37:47 <fourroot> suggest me a good ide please
10:37:48 <hellcast> hi
10:37:48 <hellcast> no one?
10:37:48 <hellcast> hi
10:37:52 <Bowlslaw> fourroot: vim
10:37:53 <fourroot> i wanna start learning haskell asap
10:37:58 <fourroot> no ide is cool
10:38:08 <hellcast> hmmmm
10:38:19 <cocreature> hellcast: hey :)
10:38:35 <hellcast> where is everyone?
10:38:43 <cocreature> hellcast: people usually only react to questions
10:38:52 <madVillan> cocreature : i have to apply xor operator on 64 byte strings how to do that ?
10:38:57 <hellcast> oh i see
10:39:01 <slamtime> is there a haskell debugger I can use to step through code and see what things are in scope?
10:39:05 <slamtime> or is that nonsense
10:39:18 <slamtime> and I should just get used to calling :t on things in the repl
10:39:56 <cocreature> madVillan: didn’t I tell you this about an hour ago?
10:39:59 <c_wraith> ghci has a debugger, but I've never used it.
10:40:38 <madVillan> cocreature : that's giving me a [Word8]
10:41:05 <c_wraith> I usually end up using Debug.Trace in the few cases where I failed to write code simple enough for me to understand
10:41:08 <dmwit> :t zipWith xor
10:41:09 <lambdabot> Bits c => [c] -> [c] -> [c]
10:41:21 <dmwit> (Word8 is an instance of Bits.)
10:41:25 <cocreature> madVillan: take a closer look at what I wrote, it has a "ByteString.pack" around it
10:42:00 <madVillan> maybe i made a mistake
10:42:15 <madVillan> can you please give me that again
10:42:23 <cocreature> :t \f xs ys -> Data.ByteString.pack (Data.ByteString.zipWith f xs ys)
10:42:24 <lambdabot> (Word8 -> Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
10:43:09 <cocreature> if you show us your code and the error message, we might be able to tell you what you need to change
10:43:53 <dmwit> That's kind of a bummer. Maybe it would be nice if ByteString offered a function with that type that did something a bit smarter about allocation.
10:45:28 <cocreature> dmwit: yeah it’s a weird choice to make that polymorphic in the return type.
10:45:40 <madVillan> cocreature, lambdabot : yup it's giving me "\NUL\NUL\NUL\NUL\NUL" for same xor operands while i'm expecting 0
10:46:08 <cocreature> madVillan: \NUL is just an escape code for a zero byte
10:46:29 <dmwit> > BS.pack [0,0,0,0,0]
10:46:31 <lambdabot>  "\NUL\NUL\NUL\NUL\NUL"
10:46:34 <madVillan> cocreature, lambdabot : i know that but i want 0
10:46:43 <dmwit> You *have* 0.
10:47:01 <dmwit> Or, perhaps a better question: what type do you want that 0 to be?
10:47:04 <madVillan> dmwit : wow how did you figure that out ?
10:47:23 <madVillan> dmwit : String
10:47:36 <dmwit> 0 cannot have type String with the standard instances.
10:48:07 <dmwit> So you will have to either say what String should represent 0, or pick a different type.
10:50:01 <madVillan> haskell is good for nothing
10:50:59 <cocreature> you’re not going to find a lot of people here who agree with you :)
10:51:20 <koala_man> madVillan: maybe you want 48 instead? that's the ascii code for the digit zero
10:51:31 <glguy> :t Nothing
10:51:32 <lambdabot> Maybe a
10:51:38 <glguy> Our nothing is quite good
10:52:29 <koala_man> > BS.pack [48,48,55]
10:52:31 <lambdabot>  "007"
10:52:47 <dmwit> madVillan: Personally, my interpretation is that your thoughts are imprecise, and causing you to mistakenly believe incorrect things about Haskell.
10:53:41 <quchen> Void is even nothinger, and you can make all sorts of things out of it!
10:53:49 <madVillan> hey guys no disrespect but haskell is not the best programming language in the word and functional programming is not the best paradigm in the world it's not superior to imperative or OOps
10:54:19 <madVillan> dmwit : Nope, i think it's good enough language but not the best & definitely not the best paradigm
10:54:51 <Bowlslaw> what the hell are you talking about
10:55:08 <madVillan> glguy : our void is even better :p
10:55:24 <Bowlslaw> languages and paradigms are tools
10:55:30 <Bowlslaw> you do understand this correct
10:55:35 <SecretNINJA> I personally enjoy being able to know exactly whats going on in every block of code im in D:
10:55:51 <quchen> Stop feeding the troll maybe
10:55:53 <dmwit> Perhaps we can skip the language wars for now.
10:56:24 <bontaq> slow friday at work for y'all?
10:56:26 <madVillan> Bowlslaw : all i'm saying is haskellers (at least here) think they and haskell are superior to everyone else while reality far from it
10:56:30 <SecretNINJA> madVillan just likes being able to fire the missiles at all times
10:56:42 <Bowlslaw> madVillan: really then show me where someone said that
10:56:45 <SecretNINJA> madVillan, name one person in here who thinks that xD
10:56:54 <Bowlslaw> oh wait they didn't they are just trying to help you but you're too retarded to accept it
10:57:23 <dmwit> Bowlslaw: That is not acceptable behavior.
10:57:28 <glguy> OK, move along everyone. Let's get back on topic. No need to correct all the "wrong" people on the Internet
10:57:35 <madVillan> Bowlslaw : and proove to me you cannot say something without actually literally saying things
10:57:59 <Bowlslaw> dmwit: sorry, won't happen again
10:58:27 <dmwit> madVillan: If you have further Haskell questions, they're welcome here. Other speculation on people's personal beliefs belongs elsewhere.
10:58:46 <madVillan> SecretNINJA : i don't remember but yeterday someone was trolling me for thinking as if i'm programming in c, although i asked humbly saying i have been into haskell for a week
10:59:17 --- mode: ChanServ set +o glguy
10:59:17 --- mode: glguy set +q *!*@gateway/web/freenode/ip.42.111.164.213
10:59:39 <glguy> OK, now we can all cool off for a bit
10:59:48 <quchen> We can encode an existential type with two universals, »∃ x. P x ==> ∀ y. ( ∀ x. x -> P x -> y) -> y« – why can’t we go the other way (or can we)?
11:00:26 <quchen> Suppose we had only ∃, could we write universals?
11:00:33 <newsham> madVillan: nothing wrong with programming in a C style, but you might find it less effective than programming in an idiomatic style when programming in another language.
11:14:00 <cocreature> is there a clever way to generate a list of non-duplicate elements using quickcheck?
11:14:53 <cocreature> actually nvm, I can do something better :)
11:16:02 --- mode: glguy set -qo *!*@gateway/web/freenode/ip.42.111.164.213 glguy
11:20:54 <lambdabot> Hello.
11:30:35 <Bowlslaw> привет
11:31:00 <dmwit> cocreature: There is an `Arbitrary a => Arbitrary (Set a)` instance.
11:31:07 <dmwit> You may have to shuffle them afterwards, though.
11:31:31 <dmwit> cocreature: Or you can `ordNub <$> arbitrary`. ;-)
11:32:41 <infandum> Gurkenglas: That is hsv, not hcl.
11:38:38 <astralemp> > the idea with `[Showable]', which conceptually means `[exists a. Show a *> a]' <-- what's the difference between that and `[forall a. Show a => a]'?
11:38:40 <lambdabot>  <hint>:1:16: error: parse error on input ‘[’
11:38:49 <cocreature> dmwit: since my set of elements is finite and small, I just ended up going through all of them and “tossing a coin” whether it should be included in the list or not.
11:38:59 <cocreature> dmwit: but good point, I hadn’t thought of the Set instance
11:39:56 <astralemp> ski: ^ wrt to our conversation yesterday
11:41:35 <metahumor> astralemp: the "exists", if that syntax was possible, means that we can choose a type which has a Show instance, and have a list of values of such a type; the "forall", on the other hand, is out of our control, we have no way of supplying all possible "a"s that have an instance for Show
11:41:46 <metahumor> astralemp: that's my possibly wrong hand-wavy explanation that might not be relevant
11:44:17 <astralemp> metahumor: but your explanation of the "exists" case would mean that the list has to be all of the same type, correct?
11:44:58 <metahumor> astralemp: if we consider how Haskell lists work regularly, then yes
11:45:01 <Bowlslaw> do any of you guys use Haskell professionally?
11:45:02 <metahumor> :t [1, 2, 3]
11:45:04 <lambdabot> Num a => [a]
11:45:27 <metahumor> astralemp: notice that that type is "Num a => [a]", not [Num a => a, Num b => b, Num c => c]
11:45:31 <Bowlslaw> > 1+1
11:45:33 <lambdabot>  2
11:45:42 <astralemp> metahumor: okay, so then what's the correspondence between that an [Showable]?
11:46:00 <Bowlslaw> > [x^2 | x <- [1..10]]
11:46:02 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
11:46:08 <merijn> Bowlslaw: Depends on your definition of professionally :p
11:46:15 <Bowlslaw> get paid for it lol
11:46:18 <metahumor> astralemp: i don't have the full context on your conversation with ski yesterday, but i bet he was discussing why or why not [Showable] is possible
11:46:40 <Bowlslaw> > [2^x | x <- [1..10]]
11:46:42 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
11:46:58 <quchen> I think »[exists a. Show a]« would be more accurate, no?
11:47:01 <Bowlslaw> man that's cool
11:47:03 <merijn> Bowlslaw: Pretty sure plenty of people here are, including me :p
11:47:31 <Bowlslaw> how did you get your Haskell job
11:47:38 <Bowlslaw> well
11:47:41 <Bowlslaw> what do you do?
11:47:44 <Bowlslaw> why is Haskell useful?
11:48:00 <merijn> I didn't. I got a research job which means I'm the only one involved in making technology choices :p
11:48:04 <metahumor> quchen: [exists a . Show a] is ~ [Constraint], no?
11:48:09 <SecretNINJA> If I use haskell to prototype a non haskell app, does that count as using haskell professionally? :D
11:48:13 <merijn> So I just use whatever I want, which happens to be haskell :p
11:48:20 <quchen> ?quote abstract.research
11:48:20 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
11:48:20 <lambdabot> s, phone apps, and web services.
11:48:27 <fragamus> http://lpaste.net/362563
11:48:36 <merijn> quchen: Should be updated to include blockchain :p
11:48:53 <cocreature> fragamus: did you mean to post that in #nixos? :)
11:49:02 <ski> astralemp : a value of type `[forall a. Show a => a]' would be a list, all of whose values have *all* showable types, simultaneously. barring bottom values, the only list of this type would be the empty list
11:49:04 <fragamus> oops no
11:49:06 <Bowlslaw> lol
11:49:11 <fragamus> I should be in haskell
11:49:16 <fragamus> I suck
11:49:40 <fragamus> oops I meant to post it here   i dont know where im supposed to do it
11:50:02 <cocreature> fragamus: well it looks like a nixos question so #nixos is probably a better place for it
11:50:09 <fragamus> ok
11:50:11 <ski> astralemp : "the "exists" case would mean that the list has to be all of the same type, correct?" .. no, with `[exists a. Show a *> a]', for each element there must exists a showable type `a', such that the element has type `a'. doesn't need to be the same type `a' for different elements
11:50:26 <Cale> SecretNINJA: "We built this prototype skyscraper out of steel and concrete and it seems to work okay. Now to rebuild it for real out of mud bricks."
11:50:30 <ski> astralemp : otoh, for `exists a. Show a *> [a]', it would have to be the same type for all elements
11:50:53 <Bowlslaw> Cale:  lol
11:51:14 <ski> quchen : `exists a. Show a' doesn't work, the body of a quantification must have kind `*', not `Constraint'
11:51:16 <Bowlslaw> Haskell is used in embedded??
11:51:27 <Bowlslaw> You'd have a hard time convincing me it was worth using over C
11:51:43 <merijn> Bowlslaw: You don't run Haskell directly, you use it as DSL for generating C
11:51:52 <TMA> Cale: well, yes, that is usually the case, because of mud bricks being the industry standard
11:51:55 <merijn> Bowlslaw: Hell, Haskell is used for hardware directly
11:51:56 <Bowlslaw> OOOOOOOOOOOOOOOOOOOOOOOOOO
11:52:02 <Cale> Bowlslaw: There are some applications which use Haskell as a metalanguage to emit realtime C code which sidesteps the need for an RTOS
11:52:07 <Adluc> Bowlslaw: http://48.io/~rmarko/book/
11:52:14 <astralemp> ski: okay, thanks for the clarification :)
11:52:18 <Bowlslaw> that is extremely cool
11:52:20 <marekw2143> hi
11:52:31 <quchen> ski: Hmmm. What’s meant with *> in the original post then?
11:52:42 <quchen> [exists a. Show a *> a]
11:52:44 <marekw2143> do you think that having many data constructors is not good thing ?
11:52:54 <merijn> marekw2143: It Depends (TM)
11:53:19 <ski> astralemp : consider `[exists a. Show a *> a]' again. consider the list `[False,"True"]'. `False' has type `Bool', which has a `Show' instance. therefore `False' also has type `exists a. Show a *> a'. similarly `String' also has that type. so all the elements of the list have the same type, `exists a. Show a *> a'. that doesn't mean that the `a' is hiding the same type
11:53:44 <marekw2143> merijn: well, I guess it gives more confidence of program correctness, am I right ?
11:54:49 <ski> quchen : the consumer/caller of a value of type `Cxt => ...' must provide evidence for `Cxt', before being able to use it as a value of type `...'. the producer/callee of a value of type `Cxt => ...' may assume that `Cxt' holds (evidence will be provided by the consumer), when constructing the value of type `...'
11:55:43 <ski> quchen : the producer/callee of a value of type `Cxt *> ...' must provide evidence for `Cxt', as well as a value of type `...'. the consumer/caller of a value of type `Cxt *> ...' may assume that `Cxt' holds (evidence will be provided by the producer), as well as consuming the value of type `...'
11:55:49 <Bowlslaw> Adluc: The stars align... that is a cool project, thanks
11:55:57 <Adluc> srk wrote that
11:56:43 <ski> quchen : `*>' is to `=>' as `(,)' is to `(->)'. `*>' typically goes together with `exists', just as `=>' typically goes together with `forall'
11:57:06 <Bowlslaw> what is an example of a useful application of that?
11:57:19 <Adluc> dont have video/pics, but BLDC motor driver
11:57:29 <Adluc> for odrive, wait a moment
11:57:30 <ski> quchen : so, the difference between `*>' and `=>' is in who is expected to provide evidence for the constraint
11:57:39 <Adluc> https://github.com/distrap/lambdadrive
11:57:42 <quchen> I see.
11:58:24 <Adluc> Bowlslaw: for example this is how you define your platform: https://github.com/distrap/lambdadrive/blob/master/src/LDrive/Platforms.hs
11:58:32 <ski> a value of type `exists a. Show a => ..a..', otoh, would require the *consumer* to somehow magically conjure up evidence for `Show a', while having no idea what type `a' is, because it's been hidden by the producer
11:58:57 <Bowlslaw> i think i love you
11:58:58 <nshepperd1> (c *> a) ~= (Dict c, a)?
11:58:59 <Adluc> Bowlslaw: you can define registers (bitfields): https://github.com/distrap/lambdadrive/blob/master/src/LDrive/DRV8301/Regs.hs
11:59:13 <ski> similarly, `forall a. Show a *> ..a..' doesn't make much sense. only the roles are reversed. the problem is the same
11:59:20 <Bowlslaw> omg i really can use Haskell for embedded
11:59:31 <nshepperd1> Except with a strict (,) i guess
11:59:34 <merijn> Bowlslaw: Are you into FPGA kinda stuff?
11:59:46 <Bowlslaw> yeah
11:59:50 <merijn> @where clash
11:59:51 <lambdabot> I know nothing about clash.
11:59:55 <merijn> ah...really?
11:59:58 <Bowlslaw> a friend and I designed our own CPU and are currently writing an emulator for it
12:00:07 <merijn> Bowlslaw: Have a look at http://www.clash-lang.org/
12:00:08 <ski> nshepperd1 : yep. `data cxt *> a = cxt => Provide a', with `Provide :: forall (cxt :: Constraint) a. cxt => a -> (cxt *> a)', if you must define it
12:00:08 <Adluc> Bowlslaw: what arch?
12:00:16 <merijn> Bowlslaw: For compiling Haskell to FPGA directly :)
12:00:17 <Bowlslaw> custom :)
12:01:11 <merijn> Bowlslaw: Clash is getting picked up by some big companies, but since it's not on their side, I'm not sure if I'm supposed to throw around which online :)
12:01:13 <Bowlslaw> https://github.com/tacodrake95/SIMP-8
12:01:16 <ski> however, i use `Cxt *> a' when a value of type `a' has *implicitly* been coupled with evidence for `Cxt'. just as a value of type `Cxt => a', when used, will have the evidence for `Cxt' be *implicitly* supplied (and also implicitly received when producing such a value)
12:02:35 <Adluc> Bowlslaw: https://www.cs.indiana.edu/~lepike/pubs/pike-acsd17.pdf , third page, right top figure
12:02:43 <cocreature> merijn: don’t worry, we won’t tell anyone we got that info from you! ;)
12:03:55 <quchen> ?tell christiaan Mind sharing a couple of Cλash-using companies? People are wondering! :-D
12:03:55 <lambdabot> Consider it noted.
12:04:02 <quchen> There you go.
12:04:45 <Bowlslaw> :(
12:04:53 <Bowlslaw> :D
12:05:29 <Bowlslaw> functions always have one return type?
12:05:31 <marekw2143> is there a takeWhile which includes also element which does not satisfy condition ?
12:05:41 <Bowlslaw> so it's always the last type in the functin def
12:05:44 <merijn> Bowlslaw: Define "one return type"?
12:05:57 <merijn> Bowlslaw: i.e. do you consider a polymorphic return type to be one type?
12:06:00 <ski> Bowlslaw : yep, and functions always takes exactly one argument, so also one argument type
12:06:22 <Bowlslaw> oh yeah...
12:06:51 <ski> marekw2143 : hmm .. perhaps you could use `span' and take the next element if any as well (there might not be, the list might have ended)
12:07:08 <Bowlslaw> merijn: Hm, well... I don't know
12:07:13 <ski> > span even [4,2,8,5,7,1]
12:07:15 <lambdabot>  ([4,2,8],[5,7,1])
12:08:03 <ski> > (uncurry (++) . fmap ((: []) . head) . span even) [4,2,8,5,7,1]
12:08:05 <marekw2143> ski: yyy, yes, nice idea
12:08:05 <lambdabot>  [4,2,8,5]
12:08:21 <marekw2143> > span (>10) [1..20]
12:08:23 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
12:08:38 <marekw2143> > span (`>`10) [1..20]
12:08:40 <lambdabot>  <hint>:1:8: error: parse error on input ‘>’
12:08:42 <ski> > break (> 10) [1 .. 20]
12:08:44 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
12:08:54 <marekw2143> yes :)
12:08:57 <Bowlslaw> merijn: oh yeeeah, covariance...
12:09:01 <reptar_> anyone here who is a student and wants to go to Lambda days in Krakow next week? I have a ticket I don't need
12:09:12 <Bowlslaw> Krakow
12:09:17 <Bowlslaw> hmm that's not too far from the US
12:09:29 * Bowlslaw abandons all responsiblities
12:09:40 <marekw2143> reptar_: you're from Krakow ? :)
12:09:42 * Bowlslaw becomes Haskell beatnik
12:10:01 * ski considers `length' to be one value
12:10:12 <reptar_> marekw2143: no, I'm norwegian
12:10:26 <reptar_> But I'm going to krakow
12:10:42 <reptar_> I just don't need my ticket cuz I'm a volunteer
12:10:58 <marekw2143> wow, maybe you will be a speaker ?
12:11:12 <Adluc> will there be any stream btw? cannot find anything about it
12:11:31 <reptar_> Not yet, maybe one day, marekw2143
12:12:03 <marekw2143> hehe. Anyway, you do haskell programming comercially
12:12:05 <marekw2143> ?
12:12:07 <reptar_> Adluc: I don't know, but they have a yt channel
12:12:35 <reptar_> marekw2143: also not yet, I'm a student
12:12:40 <reptar_> I will tho
12:18:14 <marekw2143> sorry, just a simple question :I have some type, like "data NewPosition = NewPosition FieldCoordinates CanGoType deriving Show
12:18:15 <marekw2143> "
12:18:23 <Adluc> Bowlslaw: consider joining the dark side :D we dont have C (at least as a by-product not visibly seen)
12:18:23 <marekw2143> and would like to extract only FieldCOordinates
12:18:46 <titusg> hi can anyone help with a happstack problem?
12:19:29 <Bowlslaw> but I like coding with C
12:21:14 <Adluc> This is not about writing C, but about writing monitors, channels (queues) for passing data and event handling on channels, having data flow in graph, where each node does its logic, on top of FreeRTOS transparently compiled
12:21:24 <MarcelineVQ> marekw2143: the NewPosition on the right side of your = there is called a value consructor, value constructors are what you used in pattern matching, so to get your FieldCoordinates it'd look something like this      extractField (NewPosition field cangotype) = field
12:21:57 <Bowlslaw> man that sounds really cool
12:22:48 <marekw2143> MarcelineVQ: thanks
12:22:59 <Bowlslaw> I want to contribute to a cool project
12:23:39 <srk> https://wiki.distrap.org/Main_Page :D
12:24:13 <Bowlslaw> WTF
12:24:23 <Bowlslaw> that almost perfectly aligns with my interests...
12:24:27 <srk> :))
12:24:31 <srk> cool
12:24:41 <Adluc> Bowlslaw: http://91.148.0.109/storage/channelflow.png
12:24:48 <Adluc> this was my first attempt in ivory/tower :)
12:24:53 <Bowlslaw> omg you guys are blowing my mind
12:24:55 <Adluc> this is generator dot/graphviz
12:25:12 <Bowlslaw> i've only been learning Haskell for a few hours and im already at this
12:25:47 <hyperisco> Adluc, you got that stuff running? oO grats
12:26:20 <Adluc> hyperisco: srk has running 1kW BLDC motor
12:26:28 <titusg> In a little happstack app with web-routes I need to do some IO in one of the handler functions (a db query). liftIO doesn't work, how is it done? Is there an example somewhere?
12:27:26 <titusg> http://lpaste.net/362459058977898496
12:29:16 <Bowlslaw> what about computer vision?
12:30:03 <Adluc> Bowlslaw: not at all, so far it has all perfiperials you need, SPI/I2C/CAN/UART on STM32F4/F7/F0/F3, also CANOpen
12:30:09 <Adluc> but you can simply include any C functions
12:30:53 <Adluc> Bowlslaw: https://ivorylang.org/ivory-fib.html https://github.com/GaloisInc/smaccmpilot-experiencereport/blob/master/embedded-experience.pdf
12:31:32 <cocreature> titusg: I would recommend that you start by adding explicit type signatures to all top-level functions. that makes it easier to figure out what’s going on and will also give you better error messages
12:31:48 <Bowlslaw> ahh
12:31:54 <Bowlslaw> I want to work doing stuff like that
12:32:08 <Bowlslaw> I write business logic now which is singularly boring and uninspiring
12:33:04 <Adluc> Bowlslaw: can you explain your use-cases? Current topic for me is IoT (LoRaWAN, ultrasonic water meteric, non-invasive electricity metering and other hypes)
12:33:12 <hyperisco> Adluc, I gave up after learning I would have to add support for the architecture I am targeting, which is whatever ESP8266 uses… Espressif's whatever
12:34:09 <Adluc> hyperisco: I dont have yet enough knowledge to abstract tower over any architecture, I have plenty of time, but first things first
12:34:22 <Adluc> so far building on existing platform
12:34:29 <Adluc> STM32L4 in my case
12:34:44 <hyperisco> well, it was hinted to me it would not be difficult, but I know better than to expect easy… and haven't had to make anything complicated enough to care yet
12:35:42 <hyperisco> though I am highly displeased with this "bit banging" thing done to read sensors… what an awful use of a CPU
12:35:52 <Adluc> idea of having logic literally written in petri nets is too tempting to fallback to C/Lua/whatever :D so port for anything can come later without changing app
12:36:11 <Adluc> hyperisco: what for example?
12:36:39 <hyperisco> Adluc, decoding serial comms with the CPU
12:37:49 <hyperisco> I was then reading there are hardware interfaces which help (like SPI), so you can use interrupts
12:38:04 <merijn> Foreign.C.String doesn't seem to have a way to specify encoding to use?
12:38:11 <Bowlslaw> Adluc: I'm really interesting in computer vision and also I am interesting in IoT like drone technology and using it for safely getting metrics
12:38:21 <merijn> It says it detects encoding from the locale, but what if I *know* the encoding?
12:38:37 <Bowlslaw> I also think that something like google glass is really cool where it calculates things for you like distance, angle, etc
12:38:53 <Adluc> Bowlslaw: https://smaccmpilot.org/ this is written on top of ivory/tower
12:38:53 <cocreature> merijn: encode to a ByteString and then use the foreign stuff provided by that
12:39:07 <hyperisco> which is better, but methinks FPGAs make more sense
12:39:08 <Bowlslaw> so you can be driving and it continuously calculates the recommended safe stopping distance from the ar in front of you, for example
12:39:15 <merijn> cocreature: No, I'm reading a String *in*
12:39:23 <hyperisco> in fact the more I learn the more ugly digital seems to be as a concept
12:39:28 <merijn> cocreature: i.e. I'm trying to get something out of a CString
12:39:49 <cocreature> merijn: well same idea but the other way around: read it to a bytestring and decode that
12:40:04 <Adluc> hyperisco: I also like fpgas. ideally having an ivory-tower clash backend would be win-win
12:40:20 <merijn> ah, packCString
12:40:34 <Adluc> hyperisco: had no time to play with clash yet, only experience with VHDL
12:41:07 <hyperisco> and I haven't programmed an FPGA ever, but the concept makes way more sense
12:41:19 <hyperisco> would be better yet if it were reconfigurable analog, but it is a start
12:41:37 <Adluc> hyperisco: until we have MCUs with FPGAs, we can only wish :D but looing forward to Intels with FPGA
12:41:50 * hyperisco *shrugs*
12:42:02 <Bowlslaw> Adluc: you are getting me really excited
12:42:21 <hyperisco> why the MCU?
12:42:45 <Adluc> because its segment of "market", which is rotten in 90s
12:43:00 <hyperisco> here is the thing… from my software land perspective I don't give a damn how the program executes, as long as the semantics hold
12:43:02 <Adluc> Rust is keeping pace with generated C afaik
12:43:20 <Bowlslaw> Rust is interesting
12:43:22 <hyperisco> and I also don't care if I have to program with different semantics to get better execution
12:43:53 <hyperisco> so, to me the software is completely malleable, and now I am looking at the hardware and wondering why the eff it is like this
12:44:02 <titusg> cocreature: I've added the types: http://lpaste.net/362459058977898496
12:44:31 <hyperisco> can I just compile my program to run on a pick-and-place machine? :P
12:44:49 <cocreature> titusg: so which errors are you getting now?
12:44:53 <titusg> Same
12:45:07 <merijn> also, argh
12:45:10 <cocreature> I’m pretty sure they’re not the exact same
12:45:14 <merijn> Why is "when" not in prelude?
12:45:17 <Adluc> hyperisco: written in python or something similar? you with? :D
12:45:28 <Adluc> PnP is problem by itself with vision
12:45:57 <cocreature> titusg: e.g. at least the one in line 64 should have changed
12:46:05 <hyperisco> make a language that compiles to run on a pick-and-place machine which plops the components on a breadboard, then it plugs it in and you get your output
12:49:10 <ab9rf> heh
12:50:01 <titusg> cocreature: you're right actually, there's less of it. Main problem seems to be Couldn't match type ‘IO’ with ‘RouteT Sitemap (ServerPartT IO)’
12:50:16 <cocreature> titusg: you are going to have to show us the exact error :)
12:50:45 <hyperisco> as far as analog programming goes… we already program with error… we call them floats
12:51:31 <Bowlslaw> Adluc: is there anything to which I can learn about and contribute ?
12:51:53 <titusg> I annotated http://lpaste.net/362459058977898496 with the error
12:52:09 <hyperisco> and electronically speaking digital just means certain to a very high probability
12:52:15 <ab9rf> hyperisco: analog programming is a different beast entirely.
12:52:37 <hyperisco> I don't think it has to be really at all
12:52:39 <ab9rf> hyperisco: it's possible to get very fast solutions to problems that are digitally intractable using analog methods, mainly certain PDE systems
12:53:03 <ab9rf> they'll be numerical approximations, of course, but they'll be accurate and very quick
12:53:23 <hyperisco> okay but here is my point…
12:53:25 <Adluc> Bowlslaw: more simple use-cases needs to be done, you can try https://git.48.io/ivory-tower-helloworld
12:53:51 <cocreature> titusg: the type signature is the problem: "liftIO … :: IO …" forces this expression to have type "IO …". what you want here is "liftIO (… :: IO _)"
12:53:57 <hyperisco> first, in digital software we use floats, which is a digital reapproximation of something analog
12:54:08 <ab9rf> i wouldn't say that
12:54:29 <Adluc> also, we are (srk, and two other guys), working on some drivers: https://github.com/distrap/ivory-tower-drivers/tree/master/src/Ivory/Tower/Drivers
12:54:44 <Adluc> Bowlslaw: and there is already a lot of work done: https://github.com/GaloisInc/smaccmpilot-stm32f4/tree/master/src/ivory-px4-hw/SMACCMPilot/Hardware
12:55:27 <hyperisco> and secondly, anything we consider digital is merely analog, the only addition being a high probability of being in a range of states
12:55:55 <ab9rf> neither of those statements is particularly useful :)
12:56:14 <hyperisco> maybe not to you
12:56:46 <titusg> cocreature: hey that works! Thanks
12:57:00 <ab9rf> i haven't seen anyone give any serious attention to analog computing in at least 30-40 years now
12:57:16 <ab9rf> NASA used to make extensive use of analog computing, but that was in the 1950s and 1960s
12:57:22 <hyperisco> but to me, it seems rather obvious you can lift values to distributions
12:57:53 <hyperisco> and so any digital computation just naturally lifts, and now you have an analog world to play with
13:00:13 <hyperisco> I am assuming that noise is an integral part of analog
13:02:20 <hyperisco> I relate to float because the error margin of floats can then be realised as noise
13:03:53 <hyperisco> and it is the same concept we are already used to
13:05:09 <nouv> I hope you don't mind me asking but I've been trying to figure this out for over an hour: I'm trying to turn a string like "aaa bbb ccc = xxx yyy zzz" into (["aaa", "bbb", "ccc"], "xxx yyy zzz") where there can be any number of space delimited arguments on the left size and any length string on the right
13:05:17 <nouv> I don't know where to even start implementing this in haskell
13:05:18 <nouv> recursion?
13:05:43 <hyperisco> nouv, you shouldn't have to use recursion, just readily available library functions
13:05:50 <merijn> nouv: Like, how to implement yourself? Or is just using some split function good enough?
13:05:51 <Rembane> nouv: words is a good start
13:06:05 <merijn> Rembane: I'd say you wanna split on = first, then use words
13:06:31 <nouv> hyperisco: such as?
13:06:40 <nouv> merijn: And yes myself, or without using any extra packages that I'd have to download
13:06:51 <hyperisco> nouv, look at  split  and  words
13:06:55 <Rembane> merijn: Or words, and break.
13:07:12 <hyperisco> break is probably better
13:07:30 <nouv> How do I look at the source for those?
13:07:45 <hyperisco> don't bother, just read the docs for them, on Hoogle, or Hayoo, or Hackage
13:08:20 <nouv> Ahh
13:08:22 <nouv> I think I see
13:09:17 <merijn> There's no generic exception type in base, is there? I keep reimplementing "newtype Error = Error Text; instance Exception Error"
13:11:09 <Bowlslaw> to convert positive integers into a list:
13:11:19 <Bowlslaw> toDigits :: Integer -> [Integer]
13:11:43 <hyperisco> would  Integer -> String  make more sense?
13:11:49 <jle`> i'm a little late, but happy new years #haskell :)
13:12:11 <hyperisco> jle`, welcome to 2018
13:12:15 <Bowlslaw> toDigits n
13:12:15 <Bowlslaw>   | n <= 0 = []
13:12:15 <Bowlslaw>   | n : -- ok i'm blanking here
13:13:03 <hyperisco> well, do it on paper first, then make the program
13:13:17 <Rembane> Bowlslaw: Is the modulo function your friend?
13:13:37 <Bowlslaw> modulo is my friend
13:13:38 <hyperisco> just, uh, remember to separate your syntax from semantics
13:15:20 <Bowlslaw> that first expression returns an empty list if n is less than or equal to 0, right?
13:16:27 <hyperisco> yup
13:17:08 <hyperisco> might be strange to have a number with no digits
13:20:58 <athan> Is there a good way to measure how "consistently" [tm] a process is being processed, from within that process? :|
13:21:11 <merijn> athan: eh...what?
13:21:41 <athan> like, how continuous the processing of a processes actually is
13:21:56 <athan> either historically, or through a scheduling expectation maybe? Idk
13:22:03 <athan> well, actually definitely historically
13:24:09 <hexagoxel> athan: what would make a process non-consistent? gc? blocking system calls? inaccurate timers?
13:25:19 <athan> hexagoxel: tons of stuff, suspended by the system itself without signaling, etc
13:26:03 <athan> like I'm just wondering if there's a way to read a timeline or something in a fairly sparse way, or even better - to be notified by the OS when the process hasn't been scheduled in a certain amount of time, or something
13:26:29 <athan> basically, I'm trying to know when a prcoess should perform a sanity, check, simply because it's been offline for a minute or something
13:26:52 <athan> but, it can't know that it's actually been stopped or halted
13:27:21 <nouv> Say I have a string "aa bb cc dd", how would I be able to split that based on the first space delimiter?  For example into ("aa", "bb cc dd")
13:28:35 <geekosaur> :t break
13:28:36 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:29:39 <nouv> ahhh, thank you
13:34:28 <athan> Why is unliftio preferred to monad-control? I don't see how monad-unlift adds anything more novel, even performance-wise
13:35:05 <athan> that's according to https://hackage.haskell.org/package/rio - 4th bullet under Monads
13:39:52 <merijn> athan: It doesn't
13:40:00 <lyxia> athan: the docs for unliftio seem to have some comparisons
13:40:05 <lyxia> https://hackage.haskell.org/package/unliftio
13:40:15 <merijn> athan: monad-unliftio is basically "monad-control is way to fucking complicated"
13:40:32 <merijn> athan: Which it is
13:41:26 <freeman42x]NixOS> the Combine function here: newtype Combine a b = Combine { unCombine :: a -> b } takes only 1 value of type (a -> b) to construct because of the unCombine record or how does this work? The way it looks it is like it can be constructed with 0 arguments, just Combine
13:41:47 <merijn> athan: Snoyberg had most of the Yesod and conduit ecosystem using monad-control, but realised recently "wow, this is 1) way to complicated and 2) more than we actually need". So MonadUnliftIO is "the simplest bare minimum needed to lift stuff" so conduit and yesod can use that
13:44:01 <metahumor> freeman42x]NixOS: that's record syntax for newtypes, Combine expects a value of type (a -> b) which can then be accessed using "unCombine" if you don't want to pattern match
13:45:10 <freeman42x]NixOS> metahumor, and the reason it expects a value of a -> b is because of unCombine record member?
13:48:19 <metahumor> freeman42x]NixOS: yeah, compare with "newtype Combine a b = Combine (a -> b)"
13:48:36 <metahumor> "unCombine (Combine f) = f"
13:50:50 <freeman42x]NixOS> metahumor, thank you, I get it but it seems a bit weird - although it makes sense
13:52:38 <metahumor> freeman42x]NixOS: what part of it seems weird?
13:53:41 <freeman42x]NixOS> metahumor, the convention that the only record member is the way to construct it, it makes sense, but it is awkward
13:54:52 <metahumor> i guess, it makes a lot more sense in "data Complicated ... = Complicated { va :: a, vb :: b, ...}" instead of defining a pattern matching function for each position in the constructor
13:56:47 <fishythefish> freeman42x]NixOS: well, the constructor is the way to construct it. think of the record as an pattern-matching accessor that gets automagically generated for you
13:58:41 <pikajude> what's the best way to get a random sublist of size N from a list?
13:58:49 <fishythefish> if you have an f :: a -> b, then Combine f :: Combine a b, no mention of unCombine. however, if you have foo :: Combine a b and you want to extract the underlying function, then you can use unCombine foo rather than pattern matching on (Combine f)
13:58:53 <metahumor> random by what criterion?
13:59:09 <pikajude> i don't know how to answer that question
13:59:18 <pikajude> StdGen?
13:59:31 <fishythefish> if you're looking for an algorithm, consider reservoir sampling: https://en.wikipedia.org/wiki/Reservoir_sampling
13:59:35 <metahumor> pikajude: like, finite list? sampled with or without replacement?
13:59:41 <pikajude> finite list, no replacement
13:59:44 <pikajude> more like a random subset
13:59:58 <pikajude> i was just wondering if there was a library for it already
14:00:29 <metahumor> "randomSubset n = take n" =P
14:00:34 <pikajude> ok thanks
14:00:42 <metahumor> guaranteed to be random iff your input is random
14:00:55 <pikajude> cool, just what i needed
14:01:40 <pikajude> oh, quickcheck can do this
14:01:53 <pikajude> randomSubset n = fmap (take n) . shuffle
14:01:56 <pikajude> perfect
14:01:57 <metahumor> pikajude: i like fishythefish's suggestion of reservoir sampling, lends itself well to online fold-like expression
14:01:59 <pikajude> easy as that
14:02:07 <pikajude> yeah
14:02:08 <metahumor> pikajude: oh did that actually work?
14:02:10 <pikajude> if there's a library for it
14:02:15 <pikajude> i don't have a massive dataset
14:02:25 <pikajude> it's like, ~12k elements
14:02:35 <pikajude> and i want to run a test function with ~500 of them, randomly chosen
14:02:38 <pikajude> reproducibly
14:02:45 <pikajude> which is good because quickcheck lets you specify the seed value
14:02:49 <fishythefish> quick google didn't show a lib for it, but it's easy to implement and highly scalable
14:03:07 <pikajude> actually if I implement it in Gen it'll probably work fine
14:03:12 <fishythefish> plus, as metahumor mentioned, it's a fold-like streaming algorithm
14:03:12 <metahumor> https://hackage.haskell.org/package/random-shuffle-0.0.4
14:03:20 <merijn> pikajude: You want a partial Fisher-Yates shuffle
14:03:24 <pikajude> how nice
14:03:36 <pikajude> oh
14:03:41 <merijn> It's the most efficient way to draw N random elements from a collection of M elements
14:04:00 <pikajude> the wiki even mentions that by name
14:04:09 <merijn> Although you'll want a mutable vector/array to implement that efficiently
14:04:18 <pikajude> right
14:04:26 <pikajude> i've literally never used vector
14:04:31 <pikajude> that's why i was hoping for a library
14:04:43 <metahumor> reservoir works even with infinite lists, if you can introspect the generated subsample and ask to terminate at some point
14:04:45 <merijn> pikajude: If you've used arrays in C, you pretty much know how to use vector :p
14:04:58 <pikajude> let me dredge up long suppressed memories then
14:05:12 <merijn> metahumor: It depends on how important proper randomness is for your sample
14:05:16 <bash0r> In the docs for Control.Concurrent (modifyMVar) is stated that modifyMVar is only atomic if no other producer for this MVar exist. What does producer mean in this context? modifyMVar?
14:05:23 <pikajude> not very
14:05:24 <merijn> metahumor: Fisher-Yates is properly uniform random
14:05:31 <pikajude> it doesn't need to be cryptographically secure shuffling
14:05:47 <merijn> bash0r: basically "only atomic if there's never another thread doing putMVar"
14:05:54 <fishythefish> incidentally, algorithm R (the most common reservoir sampling technique) is a specialized Fisher-Yates
14:06:44 <merijn> bash0r: So, it's basically just doing "takeMVar mvar >>= yourFun >>= putMVar mvar"
14:06:55 <metahumor> merijn: yup. i also love the Bertrand paradox re random sampling
14:06:58 <merijn> bash0r: But if another thread does putMVar after the take you get blocked
14:07:39 <fishythefish> metahumor: it comes with nice pictures :)
14:08:28 <bash0r> merijn: I use modifyMVar from two or more threads. Is it still safe to assume atomic operations?
14:08:54 <bash0r> merijn: modifyMVar exclusively. No plane putMVar.
14:08:59 <merijn> bash0r: Yes, because modifyMVar always takes before putting
14:09:08 <freeman42x]NixOS> fishythefish, metahumor had another look at how records work and in relation to pattern matching, makes sense now. Cheers
14:09:20 <merijn> bash0r: So any other thread doing modifyMVar will block on the take until the running thread finishes and puts
14:09:43 <bash0r> e
14:09:56 <bash0r> merijn: thanks for clarification. Exactly the behavior I need.
14:19:04 <athan> ahhhh okay, thanks merijn & lyxia
14:20:03 <Bowlslaw> ah yes mod of course
14:47:09 <ghfjewikk> I'm trying to make an instance of something and defining (+) for it, but how do I it so it is different depending on the parameters? For example, if I want 2+x = 2
14:47:25 <ghfjewikk> and x+2 = 2. I can do the first one, but the second one doesn't work
14:48:13 <EvanR> what
14:48:25 <EvanR> how are those different
14:48:28 <metahumor> "let {2 + _ = 2; _ + 2 = 2; x + y = x + y}
14:48:35 <metahumor> won't work but you know what i mean
14:48:56 <EvanR> also +2 results in a constant 2 or
14:49:03 <EvanR> so confused
14:49:45 <ghfjewikk> I mean I when I definite (+), I want to make it so that 2 + any value is 2. So if I do x + 2 = 2, and 2 + x = 2, and then run 5 + 2, I get 2. But if I run 2 + 5, I get an exception
14:49:50 <ghfjewikk> define, not definite
14:50:18 <c_wraith> are you defining this in ghci?
14:50:21 <glguy> ghfjewikk: Are you trying to do this one line at a time in GHCi?
14:50:23 <ghfjewikk> No
14:50:50 <glguy> http://lpaste.net
14:50:53 <c_wraith> it really sounds like a syntax problem
14:51:02 <ghfjewikk> I have a new data type that is an integer, and then make an instance of Num
14:52:10 <EvanR> if x==2 || y==2 then 2 else ...
14:52:13 <c_wraith> ghfjewikk, please use lpaste (linked above) and copy and paste the code.
14:52:26 <ghfjewikk> http://lpaste.net/152848346942275584
14:53:13 <c_wraith> well, OK. you didn't implement fromInteger
14:53:26 <c_wraith> so the literal 2 crashes
14:53:58 <c_wraith> also, your data definition isn't what you want.
14:54:09 <c_wraith> you want data A = A Integer
14:54:45 <fishythefish> (data A = Integer defines a singleton type A whose sole value is `Integer`)
14:55:03 <ghfjewikk> Sorry, what do you mean by crashes? When I do 5 + 2 it works fine
14:55:49 <c_wraith> then there is other code involved than what you have provided
14:55:52 <fishythefish> in what context are you writing `5 + 2`? do you know that it's using your datatype?
14:58:30 <Adluc> Bowlslaw: anyway, here is updated ivory tower helloworld: https://github.com/distrap/ivory-tower-helloworld
14:59:34 <Bowlslaw> :O
15:00:42 <Adluc> Bowlslaw: also, to kick-start: https://github.com/distrap/ivory-tower-helloworld/blob/master/src/Hello/Tests/SimpleBlink.hs
15:01:20 <Bowlslaw> i gotta get me one of those boards haha
15:01:37 <Adluc> Bowlslaw: and again, here is the definition of periph: https://github.com/distrap/ivory-tower-helloworld/blob/master/src/Hello/Tests/Platforms.hs
15:01:46 <Adluc> yeah, disco board, F4
15:02:19 <c_wraith> ghfjewikk, try the version in my annotation:   http://lpaste.net/152848346942275584#a362566
15:12:12 <Bowlslaw> really cool stuff Adluc
15:21:14 <tefa> hello... can someone could help me here? im getting 2 types of erros... here its the git with the code and explanation..
15:21:14 <tefa> https://gist.github.com/tefanga/e33eb29d09b5b772813e92a7bd7bab6c
15:22:14 <fishythefish> tefa: what do you expect the syntax `x.func` to do?
15:25:02 <tefa> sorry.. i was thinking on ruby on that moment.. xd
15:25:08 <tefa> i fix it, still getting the error
15:25:24 <fishythefish> you say "fix it", but can you provide an lpaste with your updated code?
15:25:26 <fishythefish> @lpaste
15:25:26 <lambdabot> Haskell pastebin: http://lpaste.net/
15:25:43 <tefa> yes second
15:27:37 <fishythefish> (just the code is fine, no inline explanation required)
15:28:40 <bash0r> Is it necessary to compile a library with -threaded ghc-option in order to utilise it or is it sufficient to pass the flag for an executable utilizing the library?
15:28:59 <tefa> i update it https://gist.github.com/tefanga/e33eb29d09b5b772813e92a7bd7bab6c
15:29:51 <fishythefish> tefa: okay, now the same question in a different form: what do you expect `double.(func x)` to do?
15:30:55 <ab9rf> ah
15:31:39 <tefa> im in a virtual class room.. and teached me that using "." its a composition.. i have to use composition, can resolve it in other way...so thats what i did.. maybe im pretty wrong xd
15:31:42 <fishythefish> bash0r: i believe that flag needs to be made available at link time
15:31:58 <tefa> cant*
15:32:04 <bash0r> fishythefish: so adding it to the executable section in cabal should be sufficient?
15:32:15 <fishythefish> tefa: you have to use composition because the assignment tells you to or because you don't know how to do it another way?
15:33:00 <fishythefish> bash0r: specifying in ghc-options is sufficient, yes
15:33:07 <bash0r> fishythefish: thank you
15:34:03 <tefa> because the assignment tells me to
15:34:13 <fishythefish> tefa: I think you're misunderstanding function composition. For example, (+ 3) . (* 2) is a function that first doubles its input, then adds three
15:34:30 <fishythefish> tefa: however, you want to apply `double` to `func x`, not compose them
15:34:34 <tefa> on the gist, i updated it.. at the end of the lines there is how i spect composition works... thats why i did what i did
15:35:01 <fishythefish> tefa: if you want to use function composition, then note that `double (func x)` is the same as `(double . func) x`
15:35:02 <tefa> (maybe im using it wrong... cant assume that what i did its pretty well... im learning.. )
15:36:19 <tefa> actually i would do it something like... 2 * (func x) and thats all.. but im obligated to use composition.. dont know how to apply it correctly
15:36:24 <fishythefish> (once you fix the code, we'll need to either delete or fix the type signature)
15:37:40 <bash0r> tefa: (2 *) . func $ x
15:38:11 <bash0r> tefa: you can use parentheses to make a binary operator a unary function.
15:38:36 <fishythefish> (see line 2 of the gist)
15:38:37 <bash0r> tefa: and $ :: (a -> b) -> a -> b is just function application as operator.
15:39:20 <fishythefish> i'd avoid $ here since precedence is already a point of confusion
15:40:32 <bash0r> Mhh... Then nevermind the $, tefa.
15:41:20 <tefa> talking about type signature... i read like 3 or 4 manuals.. cant understand it.. i mean.. i do but dont know exactly when apply some of (Eq, Show, etc) i do know when Bool and Num for example.. but difficult with the others.. i actually read guides about Eq and Show etc.. i do understand what they are for, but cant apply them in the type signature thing.. and talking about composition.. i
15:41:20 <tefa> read guides too.. but what i understood was that it works on the result of other function... (those are my easy words... )
15:41:45 <bash0r> tefa: how familiar are you with mathematics?
15:41:49 <fishythefish> i can step you through deriving the type signature once the code is fixed (or ghc can just spit it out if you ask)
15:43:56 <bash0r> tefa: not critics. It's just easier to write Haskell if you understood basic principles of mathematics.
15:43:59 <tefa> bash0r ... dont know hwo to answer that question... very well.. i learned algebra too.. so i do not know my level
15:44:52 <fishythefish> tefa: so you're familiar with the function composition operator in math?
15:45:26 <fishythefish> . in haskell is the same as ∘ in math
15:46:06 <tefa> its like talking about fog(x) and gof(x) etc ?
15:46:16 <bash0r> tefa: think about type classes as definition sections of your proof. A (Eq a) => ... just means that there needs to be a definition for type a on your structure Eq. Eq is somewhat similar to what you know as field, group, magma, etc. It's just the declaration of the structure. No proof or anything required.
15:46:31 <fishythefish> yes, but remember that parentheses matter: you usually want (f ∘ g)(x), not f ∘ g(x)
15:47:03 <tefa> i understand now what do you mean
15:47:44 <tefa> bash0r i understand that.. dont know very weell the concepts.. thats maybe the problem
15:47:50 <fishythefish> tefa: so can you write a working definition of your function now?
15:48:00 <tefa> and.. fishythefish.. i got ot go now.. thanks for the help.. i will check it when im come back
15:48:20 <bash0r> tefa: just keep going. Don't give up. Haskell is worth the headache.
15:49:00 <tefa> i wont, thx for help
15:49:01 <tefa> cya
15:50:24 <fishythefish> comparing Eq to an algebraic structure may be too vague, inaccurate, and intimidating to help a beginner
15:50:34 <fishythefish> Eq is an interface implemented by types which support equality comparisons
15:50:52 <fishythefish> the constraint (Eq a) just states that `a` varies over types implementing Eq
15:51:01 <bash0r> fishythefish: I know. But if you look at what these algebraic structures are then they are codata.
15:51:51 <fishythefish> bash0r: that statement requires its own defense, and now we're needlessly introducing the concept of codata
15:51:52 <bash0r> fishythefish: to me it helped understanding what algebraic structures are doing when going Haskell -> mathematics.
15:52:42 <bash0r> fishythefish: a type class is a codata definition.
15:53:00 <bash0r> It was introduced before just by noticing type classes, IMHO.
15:53:14 <dgpratt> I kinda cringe when I hear folks making associations between Haskell and math -- it's not at all wrong, but I think it intimidates or turns off a lot of people who would otherwise take an interest
15:54:04 <fishythefish> dgpratt: agreed. the connections may be worthwhile to look at later on, but presenting them as prerequisites for using the language contributes heavily to haskell's reputation, and not in a good way
15:54:19 <fishythefish> bash0r: what's your definition of "codata"?
15:54:26 <bash0r> sorry :(
15:55:38 <fishythefish> my definition is "values of coinductively defined types", so perhaps our vocabulary is misaligned
15:55:42 <bash0r> fishythefish: just to be sure... Are you a prof?
15:55:48 <fishythefish> no
15:56:11 <dgpratt> bash0r: I don't think you need to be sorry, just sharing my perspective
15:57:37 <bash0r> A codata defines a set of values by a set of functions that can transform a value from the respective set.
15:58:23 <bash0r> E.g. something similar to a Java interface
15:59:05 <bash0r> fishythefish: I might be wrong with my definition of codata.
15:59:36 <dgpratt> somewhere along the way I got the idea that "co" suggests the opposite or inverse of whatever it prefixes -- but from that perspective, it's pretty hard for me to make sense of "codata"
16:00:10 <bash0r> dgpratt: the "co" is because data and codata are dual.
16:00:16 <fishythefish> it sounds like you started with a "blog-post" kind of definition of codata and tried to solidify it into a more rigorous definition
16:00:49 <bash0r> I did not read any paper on codata, to be honest. It's more what I could grasp when professors at uni were talking about it.
16:00:50 <hpc> dgpratt: look at OOP classes as "set of functions that transforms itself"
16:01:32 <fishythefish> certainly a codata definition is closely tied to functions which operate on and break down this codata (see "corecursion")
16:01:33 <hpc> they're not precisely the same, but it helps you to imagine it
16:01:40 <bash0r> dgpratt: with functions that mutate itself (in fact functions returning void) being something like MyClass -> MyClass instead of void.
16:01:41 <fishythefish> but it's a bit of a stretch to directly equate any interface with codata
16:02:20 <dgpratt> that is an interesting perspective
16:02:30 <bash0r> Of course I'm stretching definition.
16:02:53 <bash0r> Stupid student trying to get a grasp of what's going. :)
16:04:02 <fishythefish> bash0r: trying to compare data vs. codata in haskell is kinda tricky - due to its evaluation semantics, least and greatest fixed points of functors coincide, so there's no real distinction
16:04:11 <fishythefish> you might want to play with a language like coq to get a better grasp on it
16:04:46 <fishythefish> alternatively, read up on functor algebras and how inductive types (the usual "data") can be defined as least fixed points of functors
16:04:50 <fishythefish> then just reverse the arrows :)
16:04:59 <bash0r> fishythefish: Actually, I played with Coq for a while. I like the language. But there's a different project that needs attention right now where the performance of Coq is not acceptable.
16:05:20 <fishythefish> bash0r: oh, I don't necessarily mean for a project, just as a playground
16:06:33 <dgpratt> I feel like I've come across mentions of "codata" in relation to dependently-typed, total programming languages; I guess I'll fully understand "codata" when I figure out how OOP relates to Idris :P
16:07:46 <fishythefish> ymmv, but i've never found the oop analogies that helpful personally
16:07:52 <bash0r> dgpratt: I don't even mind anymore to fully understand the issue. Just enough to approximately understand what I'm doing. >.<
16:08:11 <bash0r> fishythefish: I'll read on functor algebras then, thanks!
16:08:18 <ski> Haskell doesn't distinguish between `data' or `codata'. or if you want, it only has `codata'. e.g. lists don't have to be finite
16:08:48 <fishythefish> ^
16:08:56 <bash0r> ski: Oh really? Just due to thunks?
16:08:56 <fishythefish> (well, ignoring some hacks you can do with bangpatterns)
16:10:02 <ski> `data [a] = [] | a : [a]' can be seen as an equation `[a] = 1 + a * [a]'. there can be multiple solutions to such an equation. `data' would refer to the least solution (so only including (all) finite lists), aka inductive data types. `codata', aka coinductive data types, would be the greatest solution, includes all the infinite lists as well
16:10:18 <EvanR> the copatterns paper has another sort of look at codata, as objects defined through their observations rather than constructors
16:10:32 <ski> yea, that's a separate aspect
16:10:52 <EvanR> which includes functions, records, objects
16:11:01 <ski> often, when using lists or other data types, we pretend that they are inductive, even in Haskell, only considering the values of "finite depth"
16:11:51 <bash0r> When using it as a design pattern then it seems te be sufficient, don't you think, ski?
16:11:59 <ski> `data' in Haskell allows one to define multiple constructors into a type. iow a sum type, aka a variant type. when we use recursion, that's when `data' vs. `codata' can matter
16:12:03 <dgpratt> this thread of conversation has inspired me to track this down and re-read it http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html -- it's been a while, I bet I'll actually understand most of it this time
16:12:33 <ski> however, one could instead use record types, aka product types, which are defined in terms of destructors, projections
16:12:40 <ski> so, one could imagine something like
16:12:54 <ski>   codata Stream a = Head :: a
16:13:06 <ski>                   & Tail :: Stream a
16:13:18 <ski> which is supposed to give destructors/deconstructors
16:13:22 <ski>   Head :: Stream a -> a
16:13:29 <ski>   Tail :: Stream a -> Stream a
16:13:40 <EvanR> with copatterns...
16:13:42 <ski> a `Stream a' here is an (always) infinite list
16:13:44 <EvanR> head (x:xs) = x
16:13:49 <EvanR> tail (x:xs) = xs
16:14:19 <ski> so, using "message-dispatching syntax" (cf. pattern-matching syntax), aka "copatterns", one could imagine defining
16:14:24 <ski>   repeat :: a -> Stream a
16:14:30 <ski>   repeat a = this
16:14:31 <ski>     where
16:14:38 <ski>     Head this = a
16:14:44 <ski>     Tail this = this
16:14:46 <ski> and
16:15:08 <ski>   from :: Enum a => a -> Stream a
16:15:17 <ski>   Head (from a) = a
16:15:25 <ski>   Tail (from a) = from (succ a)
16:15:35 <EvanR> yeah im wrong
16:16:00 <numberten> @hoogle Map k (a,b) -> (Map k a, Map k b)
16:16:01 <lambdabot> Agda.Utils.Map unzip :: Map k (a, b) -> (Map k a, Map k b)
16:16:01 <lambdabot> Data.EventList.Relative.TimeBody unzip :: T time (body0, body1) -> (T time body0, T time body1)
16:16:01 <lambdabot> Data.EventList.Relative.TimeTime unzip :: T time (body0, body1) -> (T time body0, T time body1)
16:16:14 <ski> so, just like when we do `f x = x*x + 1', we're defining `f' *indirectly*, by defining the result of applying `f' to an arbitrary input `x'
16:16:23 <bash0r> thanks for clarifying, everybody.
16:16:45 <ski> here we're defining `repeat a' and `from a', *indirectly*, by defining what happens when we apply the deconstructors `Head' and `Tail' to them
16:17:40 <dgpratt> funky
16:17:41 <fishythefish> bash0r: related to ski's comment about solving the equation corresponding to the data definition, this comment thread has a discussion on the various ways of solving the equation which you might find interesting: https://www.reddit.com/r/haskell/comments/yunln/polarity_in_type_theory/c5zqmnk/
16:18:04 <ski> (otoh, with current Haskell syntax, one'd have to write `data Stream a = MkStream {head :: a,tail :: Stream a}', and then say `this = MkStream {head = a,tail = this}' respectively `from a = MkStream {head = a,tail = from (succ a)}')
16:19:27 <ski> imho, something like the above "message-dispatching syntax" could often be nicer than the current record construction syntax
16:19:32 <bash0r> fishythefish: everytime I try to get something done, I find myself reading some theoretic stuff on programming languages. How comes that? :D Thanks!
16:19:47 <EvanR> i just read through mcbride's thesis, where they advocate for a more robust language of eliminators
16:19:55 <ski> (also see the "copatterns" paper by Andreas Abel,et al. .. and also see the first two papers by Erik Poll)
16:19:58 <ski> @where ErikPoll
16:19:58 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
16:19:58 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
16:19:59 <lambdabot> pdf>
16:20:12 <fishythefish> bash0r: i used to fall into the same trap, but then i just expanded my definition of "getting something done" to include reading such theory
16:20:13 <EvanR> about to read "a view from the left"
16:20:16 <bash0r> ski: I agree with the improved syntax. But any way to get Simon accept a patch for specified syntax?
16:20:42 <ski> btw, here's yet another example of using this syntax
16:20:55 <ski>   RunState (return a) s = (a,s)
16:20:56 * fishythefish muses, "Start by writing the patch..."
16:21:08 <ski>   RunState (ma >>= amb) s0 = (b,s2)
16:21:11 <ski>     where
16:21:32 <ski>     (a,s1) = RunState   ma    s0
16:21:45 <bash0r> fishythefish: might be a good thing to do this.
16:21:46 <ski>     (b,s2) = RunState (amb a) s0
16:22:12 <fishythefish> bash0r: actually, I rescind my previous statement. I expanded my definition to include understanding such theory
16:22:16 <ski> imho, several applicative and monadic definitions would read more nicely, using syntax like this
16:23:21 <metahumor> why does data61 not like stack?
16:23:28 <robertkennedy> > [3.0,2,1,0,-1] >>= \x -> map (/x) [1..5] >>= return . take 10
16:23:30 <lambdabot>  error:
16:23:30 <lambdabot>      • No instance for (Enum [()]) arising from a use of ‘e_13021011510’
16:23:30 <lambdabot>      • In the expression: e_13021011510
16:23:57 <bash0r> I'll finish my current work, then write the patch for GHC and let you guys know when it's finished.
16:24:05 <robertkennedy> > take 10 $ [3.0,2,1,0,-1] >>= \x -> map (/x) [1..5] >>= return
16:24:07 <lambdabot>  [0.3333333333333333,0.6666666666666666,1.0,1.3333333333333333,1.666666666666...
16:24:11 <bash0r> Gotta go now, though. Became kinda late. Thanks for discussion!
16:24:18 <bash0r> (and thanks for more lecture)
16:24:39 <ski> dgpratt : anyway, if we want a total programming language (dependently-typed or not), we want to distinguish between `data' and `codata'
16:25:10 <ski> for `data', we want termination (related to catamorphisms), but for `codata', we want productivity (related to anamorphisms)
16:25:46 <ski> `codata' would be used to do a server that can run indefinitely (until told to shut down), but which is expected to be responsive, productive
16:25:54 <ski> @where Charity
16:25:55 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
16:26:15 <ski> is a language (not dependently-typed) that distinguishes `data' from `codata'
16:26:47 <dgpratt> makes sense
16:28:11 <ski> (Charity bases these two kinds of data type definitions on left and right adjunctions from category theory)
16:29:34 <ski> dgpratt : hopefully the relation of "message-dispatching syntax"/"copatterns" to OO should also be clear
16:30:16 <ski> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> might also be interesting
16:31:07 <ski> (that one is sortof a follow-up to some parts of "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>)
16:34:51 <ski> (<https://github.com/mietek/charity-language> might have some more info on Charity, not sure)
16:41:36 <metahumor> for cis194, should i follow spring13 or fall16?
16:41:52 <metahumor> also, is it worth doing the cis194 or should i move on directly to nicta?
16:42:48 <fishythefish> iirc spring13 has remained the recommended version
16:43:09 <fishythefish> depending on your current level of knowledge and desired pace, neither, either, or both may be appropriate
16:44:06 <fishythefish> cis194 is what i'd expect from a class - assigned reading, "real" projects to work on, a slower pace
16:44:13 <fishythefish> nicta felt more like a race through the typeclassopedia
16:45:01 <dibblego> the nicta course spends very little time on the typeclassopedia
16:46:27 <dibblego> metahumor: CIS194 covers a little less material, at a less deep level, and at a much slower pace. When the NICTA (now DAta61) course is run, CIS194 is recommended afterward for independent study, so that the slower pace can assist in concreting in some of the ideas.
16:47:11 <fishythefish> i don't literally mean going through the typeclassopedia, but several of the units are merely "follow the types and implement this typeclass"
16:47:23 <fishythefish> others are "here's a handful of fairly simple combinators; implement them all with little context"
16:47:46 <dibblego> the context is provided in-person, the goal of the exercise is to understand the practical reasons for doing so
16:48:07 <dibblego> for example, after completing those exercises, every student is able to then tell me why the first 10 search results on monads are completely wrong
16:48:46 <dibblego> if not, we spend time on making sure that it is so — in practice, only a small portion of the course time is spent on this, because it is relatively easy
16:49:05 <fishythefish> true, i was assuming metahumor was wondering about following the repo and self-teaching rather than doing the in-person course, but that may be a faulty assumption
16:49:23 <fishythefish> (i didn't do either as a live course)
16:50:13 <dibblego> CIS194 is recommended for self-study, or NICTA/fp-course with personalised help. The personalised help is in the following forms: It was recently run over three days in Melbourne, Sydney and Brisbane. It will be run in Perth and Canberra (over 3 days) in the 3 months. There is the #qfpl channel where there are people doing it independently, with guidance from a team of people.
16:50:27 <dibblego> *in the next 3 months
16:51:41 <dibblego> an example of what occurs in NICTA/fp-course is one of the first exercises is headOr :: a -> List a -> a, well after that exercise is completed, we then implement it using foldr/foldRight, and gain a deep understanding of why it is so (headOr = foldRight const)
16:51:52 <metahumor> yeah, selfstudy using the repo(s). i feel pretty comfortable with haskell i think, just want to shore up my knowledge by implementing (>>=) for State, for example
16:52:27 <dibblego> we generally do not cover state in the first 3 days (that is actually a lie, since we do a Parser, which is StateT specialised, but we don't actually call it state)
16:52:53 <dibblego> https://github.com/data61/fp-course/blob/master/src/Course/Parser.hs this is completed on the third day
17:05:04 <Dynasty> Cale sgraf lyxia : I improved on my tagged type class instance system that I was talking about last night: https://gist.github.com/calebh/d474ab9ef80ce907665c8bf3634a2af6
17:05:12 <Dynasty> Also see my comments here: https://www.reddit.com/r/ProgrammingLanguages/comments/7xwgtq/exploring_multiple_type_class_instances_per_type/
17:05:50 <Bowlslaw> pattern matching is cool holy cow
17:06:05 <metahumor> no more boolean blindness for Bowlslaw
17:06:55 <Dynasty> I wonder how much inference could be recovered if the selectors are treated as "special" by the type inference engine
17:06:57 <Bowlslaw> never heard of that
17:07:17 <Dynasty> Because presently there are a ton of annoying @s everywhere, of which only a few seem strictly necessary
17:09:28 <Bowlslaw> stack or cabal? I've been using cabal
17:09:37 <dibblego> Correct.
17:10:48 <Bowlslaw> i just want to know why one would choose one over the other
17:10:56 <Bowlslaw> i like hearing about people's preferences
17:12:07 <dibblego> stack causes all sorts of problems when teaching
17:12:27 <MarcelineVQ> this is the fundamental difference https://docs.haskellstack.org/en/stable/GUIDE/#what-makes-stack-special
17:16:22 <dibblego> Bowlslaw: if you are interested in doing builds well, uses nix
17:27:01 <Bowlslaw> what is the idiomatic way to reverse a list before filtering it?
17:31:04 <ski> Bowlslaw : how about `reverse' ?
17:31:26 <Bowlslaw> well...
17:31:35 <Bowlslaw> i was pretty vague with that i'll be more specific
17:32:03 <Bowlslaw> i'm working on cis194 and on exercise 2
17:32:23 <lyxia> Dynasty: how does that tagged system differ from explicit dictionary passing
17:33:30 <lyxia> hm, I guess there's the thing about coherence
17:33:57 <Bowlslaw> http://lpaste.net/362573
17:33:58 <parsnip> Bowlslaw: probably the linked list way
17:34:13 <Bowlslaw> the last line of that function doubles every other element in the list
17:34:27 <Bowlslaw> but it's suppose to start from the back of the list and go forward
17:34:42 <Bowlslaw> so I want to reverse it, apply the filter, then reverse it again
17:34:57 <ski> `(x:[])' there could just be `[x]'
17:35:03 <Dynasty> lyxia: The inference still works for cases where you have only a single instance. So for example in the last line of the gist, the system was able to function without any explicit type annotations. There's actually a mistake in the gist right now that I'm correcting - you need to be able to select how you compare the left side and how you compare the right side for the pair example
17:35:23 <parsnip> Bowlslaw: i think you just want to implement reverse separately
17:35:35 <ski> Bowlslaw : sound like it would work
17:35:36 <fishythefish> Bowlslaw: you've just described reverse . doubleEveryOther . reverse, which is pretty idiomatic. if you're asking about efficiency, that's another question
17:35:46 <Bowlslaw> hmmmmm
17:35:57 <Dynasty> Also I think a good portion of the inference could be recovered if the compiler treats selectors specially
17:36:27 <Dynasty> I was also questioning the coherence issue, so I threw together the quicksort example
17:37:13 <lyxia> Dynasty: BTW in this style the semiring functions need not be methods
17:37:48 <lyxia> couldn't you have an empty class and just regular toplevel functions
17:39:07 <Dynasty> Hmmm maybe. I'll have to think about it
17:39:34 <lyxia> Same comment with IntegerSemiring
17:41:44 <lyxia> the last line works because mul for Integer doesn't constrain s, and constrains m1 and m2 to be SumMonoid and ProdMonoid...
17:41:58 <lyxia> I'm not sure what to make of that...
17:43:14 <dgpratt> ski: thanks for passing along "On Understanding Data Abstraction, Revisited"; even as a lay-person, I found it pretty readable, though I must admit I really didn't absorb section 4.2 (too many Greek letters and subscripts tends to make my brain check out)
17:43:51 <lyxia> Dynasty: did you see the short discussion about this kind of stuff a while ago on Haskell-Cafe
17:44:22 <Dynasty> I'm not subscribed to that mailing list. Do you have a link to the discussion?
17:44:56 <woodson> Not sure if it went to because I got disconnect but I will just paste my question again..
17:45:04 <woodson> Can anyone explain to me why sum [1, 2, 3] = 6
17:45:11 <woodson> but fmap sum [Just 1, Just 2, Just 3] results to [1,2,3]
17:45:16 <woodson> I would expect sum to receive Just x has an argument
17:45:41 <metahumor> woodson: what is the type of sum in your second example?
17:46:10 <woodson> :t fmap sum
17:46:11 <lambdabot> (Num b, Foldable t, Functor f) => f (t b) -> f b
17:46:27 <metahumor> woodson: right, but what about the "sum" itself?
17:46:29 <woodson> :t fmap sum [Just 1, Just 2, Just 3]
17:46:30 <lambdabot> Num b => [b]
17:46:41 <woodson> :t sum
17:46:42 <lambdabot> (Num a, Foldable t) => t a -> a
17:46:52 <metahumor> woodson: what about specialized to this particular case?
17:47:10 <fishythefish> woodson: fmap sum [Just 1, Just 2, Just 3] == map sum [Just 1, Just 2, Just 3] == [sum (Just 1), sum (Just 2), sum (Just 3)]
17:47:12 <Dynasty> lyxia I just pushed an update to the gist so now for lists of pairs of arbitrary depths, you can control exactly how the comparisons are made
17:47:26 <fishythefish> the Foldable in question here isn't [a], it's Maybe a
17:47:30 <woodson> what do you mean by "about sppecialized"?
17:47:34 <Dynasty> Automating the entire process might be tricky but it seems possible
17:47:42 <fishythefish> > sum (Just 5)
17:47:44 <lambdabot>  5
17:48:02 <metahumor> woodson: in what fishythefish just showed, "sum :: Maybe Int -> Int"
17:48:05 <woodson> fishythefish: so you are saying that the foldable definition for Maybe is just returning the value?
17:48:13 <metahumor> > sum (Nothing :: Maybe Int)
17:48:15 <lambdabot>  0
18:26:09 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
18:26:09 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
18:26:09 --- names: list (clog jimmyrcom laurenthuberdeau ertes mizu_no_oto_work twandy _sebbot hjdskes thallada jfredett codesoup carlomagno dan_f ntrh Tuplanolla emilypi ziyourenxiang tefa2 MoarSpaceFi fragamus fkurkowski lambdaman woodson Khisanth okuu YungMoonHodler harfangk wei2912 SenasOzys_ eschnett bmgxc9 ddellacosta exarkun fishythefish LKoen augur Tops21 sjdthree[m] figurehe4d justanotheruser pfurla Dynasty Patternmaster hiratara drewbarbs eliaslfox rbo kapil___ erikd min)
18:26:09 --- names: list (cpow nicknight bmeynell jao zariuq mrus Xal alasi bleedChain mud nyberg klntsky dcoutts hexfive floryst alx741 _ashbreeze_ Ubercow Guest22058 huytd kerrhau MP2E whiteline hamishmack raingloom conal heurist`_ mek42 dmiles titusg athan_ oisdk astralemp shatriff energizer Arcaelyx ninedotnine ec2-user fr33domlover nesqi Destol DTZUZU cemerick t7 Snircle joachifm llinguini x_o_r kotrcka caryoscelus ziocroc mou butterthebuddha genericpseudonym Cthalupa aarvar)
18:26:09 --- names: list (CurryWurst giraffe cjwelborn taktoa[c] taktoa gienah maqbool dutchie Laney raynold qdickon tsaka_ ekrion son0p urodna hempvoll zero_byte metts danthemyth al-damiri k lijero vimto machinedgod rcdilorenzo pavonia mt_caret_ drewr korans infandum HaskellLord69 clever eightb remix2000 jdnavarro dddddd gabiruh xkapastel jeltsch Ring0` deba5e12 duncan^ acowley fizbin logotags slomo infinity0 aplainzetakind locallycompact govg cpape loli sms MalfaitRobin sdothum)
18:26:09 --- names: list (slackman unlambda[m] Lowl3v3l dustinm jtz Qommand0r otto_s_ nuncanada Madars theDon lagothri1 nakal banc hucksy_ markus1199 albertid__ kuttifunk whaletechno monochrom Unhammer brynedwards Foritus brkc[m] nnplv peutri thunderrd llwu maerwald Adluc srk fionnan Fairy linduxed revprez_atlanta revprez_anz revprez_ bitemyapp mkoenig_ kumori[m] zaquest texasmynsted Mon_Ouie fryguybob wonko7 kini boathouse2112[m] fxrs tabaqui m0rphism1 ahihi dedgrant leat pacak)
18:26:09 --- names: list (prg318 hcit orion mk_modrzew zekriad nshepperd OnkelTem seanparsons jluttine ctag beerdrop sphalerite_ petercommand tjbp przembot [Leary] rootmos jud raphaelsquelbut[ felixonmars cyphase masquerade bq keep_learning martingale koz_ x0x0_ coeus LeaChim jkup dolio duckqlz Prince781[m] dave_uy parsnip aananev RGamma echoreply chat_ ericsagnes Ranhir kav tv Nudist69-M Durbley Philonous max3raza sleblanc Akii Enigmagic DigitalKiwi kuno admin1 ninegrid Voldenet)
18:26:09 --- names: list (dbohdan SAL9000 sun777 sonOfRa crosleyt mstruebing1 petermw Sigyn insanitea przemkovv Sose phryk Unode jakutis_ schaeferpp ixian tromp Salek mceier zebrah michaelw capncanuck[m] alexbiehl nullifidian_ xinming hanna gnusosa niklasl swalladge croben Frankablu verement jcarpenter2 reactormonk pranz3 StoneToad otulp peterhil Someguy123 Sgeo reinh1 amidstbinary[m] infinisil andjjj23 tippenein huonw william DrAwesomeClaws billsam[m] mcspud staafl_ caa51h hvr)
18:26:09 --- names: list (jan-sipr idupree akkad padre_angolano tsani bafain teej bxc Cale Ninja3047 u-ou eacameron mgttlinger cgag changyj johs yukkuri iravid net4all gareth__ parseval elvishjerricco kaychaks nahra mindtree nelll jgornick edmundnoble runde Charn vaibhavsagar_ jshjsh Lokathor__ rodlogic rodarmor thomashoneyman dgpratt gleber_ dpren isaac__ thi_ rgrinberg dstockwell darthThorik feepo jorendorff mbrcknl_ carter ggherdov chriswk fuziontech dessmm jonrh ryanbooker)
18:26:09 --- names: list (jakubczaplicki[m Strix weareswarmcity[m jchia sw1nn FjordPrefect qzo joehillen bluepixel ackthet dredozubov elomatreb dpanth3r rgrau dysfun Gothmog_ cjay- Adeon avn sbrg dibblego ClaudiusMaximus tripty @ChanServ happyente[m] Jello_Raptor noplamodo wtw kefin alvinsj ranberry systemfault bradparker pjan Cir0X ebutleriv jerme_ noobst houli fingerzam Wizek ReinH dan64- CuriousErnestBro micmus peschkaj dgonyeo codedmart gornikm Youmu shivani_[m] uwap paf31)
18:26:09 --- names: list (banjiewen zmanian yaknyasn nbouscal osa1 incomprehensibly si14 strmpnk trulsa tharper_ Scorchin etrepum dukedave oh_lawd prefork Xorlev husky1 Maxdamantus a9rkzz athan pagoda_5b alexknvl mbeidler wavewave TyOverby__ angerman higherorder libbyk lynn thoradam cansis reem bigs vikram__________ bitonic spicydonuts shans_ edwardk angular_mike_ S11001001 tjpeden wizonesolutions zph mkurkov_ Guest32984 runeks zpconn__________ posco lukexi TabAtkins strugglingming)
18:26:09 --- names: list (amatecha sa1 bytesighs __main__ mmaruseacph2 troydm ego owickstrom bydo iampigman[m] atk gelnana[m] Zialus g3lnana[m] perrier-jouet sophien[m] esssing yorick EricZou AntiSpamMeta rotaerk catsup ByronJohnson pikajude Forty-Bot sim590 zmt00 yahb mniip Igloo asm[m]1 leandro[m] oliverlsanz[m] Guest1573[m] Bimmie[m] himmAllRight[m] asonixdog[m] scrypso[m] seto[m] kmicklas[m] Litom[m] dumpster[m] anyu[m] vakili[m] chiwui[m] dezren39[m] kwaku[m] maverickwoo[m])
18:26:09 --- names: list (thebeast[m] ElliotKiyomizu[m PatrickM[m] infty[m] KevinMGranger bustillo[m] bingen[m] M-HirmeS lixiang4u[m] discontent[m] pnrfne[m] foo123[m] anonguest[m] guyinjeans[m] srid[m] Elorm[m] am2on neechoo reconmaster[m] virginiam[m] fgaz[m] alldigital[m] Guest340521[m] Quoran[m] wchresta[m] shekel[m] fbreitwieser[m] testtt0x11[m] wannabeog[m] matheusrv[m] kebertx[m] c0ff33[m] sielicki tryptyx[m] h_ndrik[m] Barnabas[m] systemovich[m] usedname[m] gridaphobe[m])
18:26:09 --- names: list (SijmenSchoon[m] km42[m] mrdaak[m] wilo[m] anaxios sburavtsov[m] Scapin[m] bmjh djangoblockchain DavesTestingAcco dirb sudom0nk[m] tuxitagnu[m] dbramucci[m] ArrayWindrunner[ camael[m] gelidae[m] guest69[m] Kevin[m]3 razvanc-r[m] M-rgh Niboor[m] uchronian[m] Mougan[m] Google[m] howsiwei[m] adziahel[m] oats[m] magog[m] Shaunthesheep[m] testingriotnmatr test-guest[m] srenatus magnap artemismucaj[m] minhnhdo[m] saltykawaiineko[ iohidtbhfam[m] riaqn)
18:26:09 --- names: list (arthurfragoso[m] atopuzov[m] badamson[m] superpat[m] felipeac[m] grassator[m] nkhodyunya snpriyanshu[m] jvalleroy[m] abel-abel[m] ajtowns[m] saci[m] hpd_m fristonio[m] lkurusa TimWolla[m] cipher1024[m] stuebinm[m] tobim[m] Cadey[m] agraba[m] Makinit thekyriarchy__ avatias0[m] WinterFox[m] ub[m] siddhanathan[m] M-x[m] limonheiro[m] M-wamaral icen[m] Overload[m] M-ms aaaaaaaaab[m] asthma[m] dima_grshk[m] jollyrogue[m] M-kitsune just_test1ng[m] unclechu)
18:26:09 --- names: list (Heino[m] seif_madc[m] william[m]1 martunis[m] jbweston[m] rizo[m] noperope[m] peel[m] superobserver[m] michbad henriquezanin[m] HoelKervadec[m] braidn[m] Naughtmare[m] emme[m] bbslclubbin[m] honeymilktea[m] Frytka[m] PifyZ[m] chominist[m] xffox[m] bb010g intheclouddan sudoreboot[m] Akito[m] CryptoCalsius[m] Flecheck[m] ThousandLions[m] metaxis[m] hdurer[m] unlawfulmonad[m] ArchieT mrhania[m] beemo[m] optimizationproc izahn[m] synopz[m] SansFr[m] M-herah)
18:26:09 --- names: list (ngross[m] monadic[m] Deleh[m] vsts[m] hiq[m] laaksoan[m] dkellner[m] levzhazeschi[m] AX3L[m] deyg[m] puminya[m] vise890[m] absurd[m] chuzz[m] kasbah[m] daoo[m] drastan[m] chocowheel[m] towaii[m] mossid[m] rakete aman5319[m] relyth[m] georg3[m] Dako300[m] sdvcxd[m] innaytool[m] mad[m]1 Nerka[m] zineje[m] thejonny[m] strangepowers[m] softashell clementd[m] ttk2[m] stigo[m] toumi124[m] naviknair7[m] nh2[m] sh4pe[m] lathebiosas[m] jomari[m] mith[m] seizo[m])
18:26:09 --- names: list (motif[m] angelvigo[m] JackM[m] palacex[m] vitamin-q Dev[m] charlag[m] Jikstra[m] Half-Shot phittacus phil_frontal[m] bgrayburn[m] plll[m] tibike_m[m] asenski[m] M-moyamo jacobleach wubbalubbadubdub ycy[m] zalipuha[m] stites[m] Matthew[m] AntonLatukha[m] aaronc[m] foreseaz[m] porcow[m] puffnfresh moonrunes[m] Masaomi[m] Obscurity[m] gpunk[m] thekyriarchy grisotto[m] herzmeister[m] imbigbrother[m] sherushe[m] strixy[m] riadvargas[m] M-whoops trikl[m] geetam)
18:26:09 --- names: list (Mcpurplemuffin[m schplaf[m] octalsrc[m] aniketd[m] toma[w] pcm77[m] skaillet[m] Orbstheorem[m] M-Chickee lycium[m] M-x-matrix[m] wzy8L-B2[m] SuperW[m] Mike[m]1 anomie[m]1 uha[m] idnar[m] utumno JCGrant[m] tigerchops[m] goodboy[m] undu[m] mak81[m] hakan[m] hendrik[m] drasich[m] zaphar_ps[m] JanPath[m] TylerCecil[m] M-krsiehl angelbeats[m] jerin[m] sn[m] maigel[m] lightandlight rellen WilliamHamilton tester668[m] davidar wizek[m] m4sk1n albertsg[m] davidar_)
18:26:09 --- names: list (steshaw[m] bennofs[m] lierdakil[m] aer[m] turt2live Gratin[m] berton aspiwack[m] Guest50734 spacekitteh[m] ollieh HMPerson1 M-berdario M-BostonEnginerd freeman42x equalunique[m] lysgaard[m] javjarfer[m] noteventime[m] unknownln reactormonk[m] MikasiCoyote[m] geodesic[m] leah2 bs tg julmac treehaqr cmaj9 nurupo miklcct PHO StianL twk- hongminhee anderson peddie froztbyte zenzike abrar gargawel nonzen soncodi raid anoe [df]_ Cathy mattp_ Skarn oleks alek ectos)
18:26:09 --- names: list (c0dyr benonsoftware mathu wladz_ Profpatsch reu segin nemesit|znc CindyLinz hrnz chrzyki jameseb chindy jordanlewis bartavelle bjs zerokarmaleft killtheliterate M2tias a_t Firedancer casdr pta2002 bcoppens phz_ ion bwe greeny PsyDebug sea-gull pikhq jchia_1 zeroed pharaun sjl_ suzu obfusk kwantam tzaeru asjo kebolio ghuntley jzelinskie binaryblade tarcwynne__ hansihe jameshaydon solidsnack simony iliastsi a3f averell jzl tortal kloeri mendez Phyx- kosmikus)
18:26:09 --- names: list (platz Moyst Liskni_si noxd niko Taneb TallerGhostWalt rootnode max-m vaibhavsagar defanor bengt_ Magemanne Drezil heath srhb solarus xnyhps glguy shikhin Geekingfrog tureba Randy OliPicard PotatoGim customminer baamonde centril ocharles jml nkaretnikov sbauman Soft dxld gopnikovitch SCHAPiE Wamanuz2 niveus terrorjack richi235 lukeshu juri_ Reisen stig redcedar Argorok rann entheogen heyj peteretep spinda xplat|work joel135 lexi-lambda gridaphobe mpickering)
18:26:09 --- names: list (dmj` thoughtpolice Tritlo dashed mitchellsalad ianconnolly srid saemcro noexcept toppler bollu gspia fluxit aurieeeh mokus ironChicken typetetris feltnerm jmct monad_cat Kamuela kyagrd milessabin billstclair mbrock sp1 kipd ericbmerritt_ zgrepc cstrahan metalrain_ CARAM___ andrew_n_ shadowfax AlainODea prizim Smeghead avdi dmead hc mingc darjeeling_ squisher piyush-kurur falafel JoelMcCracken MindlessDrone Biohazard Saizan scinawa jdevlieghere cschneid_)
18:26:09 --- names: list (antismap brennie Desoxy m1dnight_ Mad_ Tehnix byorgey lopex dxtr grandy_____ cdal Tallenz Deadhand sssilver nekomune nimbleark Stratege lambdabot arkeet PlasmaStar hive-mind robogoat dpower Frans-Willem XMunkki cic jwynn6 guen marmalodak lukky513 karahobny shiona Robin_Jadoul thebnq hiptobecubic bbear fadein fnurglewitz verlet64 tnks hsiktas capicue rizary rjungemann sdemos mikedlr pchiusano edofic oldsnakey bbielsa Bengi Meow-J_ caw___ iphy sclv Chadtech)
18:26:09 --- names: list (MarcelineVQ nak cdornan_ NemesisD lumimies stephe dsal marcel trig-ger bgyss ck_y JSharp mstruebing Tspoon_ albel727 colescott cheater bind qwertydvorak ft AWizzArd liff anishathalye kiltzman xacktm nikivi lokydor jdt harmaahylje tdammers amiri Pilfers tmciver C-Keen Nik05 garphy`aw tessier phadej etiago xplat urdh ent jrslepak jix xaimus jrabe Morgawr johnw amx jle` Takumo MagneticDuck TimWolla tolt bsima Guest22057 exio4 hjklhjklhjkl ycheng_ shapr minad)
18:26:09 --- names: list (azahi mk-fg GGMethos yarou ventonegro aatxe nyuszika7h abbe lispy_ marek Quintasan mgaare_ sdx23 liste diskie stux|RC-- Gabemo Logio kfish zv klugez mdarse guios dpepsilon mlen worch oak- Benzi-Junior xpoqp chrissl survove andyo Solarion dogui SlashLife ekr amosbird earthy Majiir brisbin foolswood sujeet mountaingoat dtulig leothrix mrBen2k2k2k_ buhman kody^ mrBen2k2k2k scav rbocquet Klumben mitch_ Lord_of_Life geekosaur Guest17694 Athas oberstein drdo)
18:26:09 --- names: list (Raptor8m3 edwtjo nisstyre tomku nshepperd1 skeuchel statusfa1led NextHendrix jrm ianp kriztw delYsid` sveit_ NinjaTrappeur esph megaTherion michalisko wraithm liurnd_ ephemeron Vq zge wto yezariaely nwf anhj ephemera_ dpn` bbaren syq riatre cromachina_ ongy lukd ikopico jaargon Fubar^ byte512 malt3 alanz webstrand shutdown_-h_now cpup reptar_ cgfbee gchristensen omilu WhereIsMySpoon_ Bigcheese mimi_vx pierrot Neo nibbling arw RaptorJesus tumdedum newsham)
18:26:09 --- names: list (rembo10 michi7x7 ski ambrosia pikolinosimo SuperTux88 PyroLagus Purlox aminb freeside madknight m4lvin ab9rf cocreature alsoStevenXL_ eL_Bart0- ericmath1son Cheeky-Celery x1n4u vin-ivar pmade scopedTV divVerent sha-2 mcallisterjp Putonlalla yiannis_t timothyh swflint tokik TMA dysfigured acro dstolfa dilinger cpallares MitchW fall_ niluje lachenmayer iross rotty linuxdaemon eddsteel _6a68 thaumavorio toure epicallan alp Kneiva boj benzrf Tharbakim cross)
18:26:09 --- names: list (Disavowed Guest80763 jbalint nopf seliopou joncfoo fgaz langkid1 bshelden DustyDingo electrostat poga tsahyt m0ar d3lxa Ewout papapishu hpc mikeplus64 naudiz wagle ecx86 fbauckho ramatevish dcoutts__ keri Dykam jorj sanitypassing DoubleJ gxt kmae wz1000 Rembane Ornedan __name__ supki lines danzimm ManiacTwister hydraz aib magicman vodkaInferno jared-w aijony hiredman Warrigal brent80_plow fugyk keyking orzo jokester Natch pasukon Wesleysld Jaxan sdhand)
18:26:09 --- names: list (kensan Blkt avocado mulk bickle1 meck micro sm tctara _flow_ Spritzgebaeck xintron_ implementation ChongLi hegge jtcs S007 baweaver chirpsalot DK21 ljhms jlouis canta saurik mjrosenb [exa] vjousse dexterfoo greymalkin ftop yushyin stux|RC dminuoso raibutera Niamkik paraseba hexagoxel exferenceBot jinblack flux jw358 comboy akermu rjeli_ logcat opqdonut ps-auxw nek0 Meanirelli cyberlard spoonm mt dqd SolarAquarion anhduy bob_twinkles hodapp x-n2o swhalen)
18:26:09 --- names: list (aweinstock qmm burp_ Axman6 hanDerPeder tabaqui1 datajerk solatis SegFaultAX barrucadu da-x Forkk zymurgy integral Jon ahf cjh` lionaneesh epta fredcy sqrt2 dh agrif sdrodge Guest88515 zekt yoho139 EvanR marble_visions beaky runawayfive japesinator salva WarzoneCommand wrengr_away Chobbes quicksilver abra0 ichigo `0660 Jonno_FTW koala_man milli Flonk bjobjo MasseR raatiniemi matchray philosaur dumptruckman zomg amuck grumble grayhatter Clint mrd c-rog)
18:26:09 --- names: list (int0x27h int-e Nikotiini wedify Princess17b29a cheshircat prooftechnique Chousuke s4msung Gabscap Ke zachary12 noctux huaw obiwahn pyrtsa Zowlyfon DDR ralu deni kipras`away valkyr2e bgamari aidecoe electrocat cods fiatjaf Jinxit crooked nullie ggVGc carc staffehn numberten mauke quaestor Zoddo ircbrowse rom1504 mak` tomaw hackage akemot sellout heinrich5991 d6e lugh SuprDewd jonge HalfEatenPie jstolarek nille eagleflo pita fiddlerwoaroof RevJohnnyHealey)
18:26:09 --- names: list (gsingh93 gothos pfoetche1 lpsmith capisce Fylwind- TommyC janne- Dodgy-Debaser_ valdyn wting atomi cynick paroxp cow-orker pdgwien relrod detoxin Zemyla ncl28 Hafydd bno1 lassulus asm89 lpvb tinco lavalike Eagle_Erwin ijp APic sunya7a Deewiant navilan- statusbot ynyounuo bsmt ccase theorbtwo gilbertw1 cnomad jswe adamCS kubrat michalrus vqrs Willis fairfieldt dschoepe Fuuzetsu kshannon xa0 luigy nilOps betawaffle crlane wayne ahf_ surtn wamaral _cyril_)
18:26:09 --- names: list (emmflo Yaiyan Xnuk cesardv Sornaensis stefan- monte Cheaterman daft absence Xandaros joeyh Eliel davean saftsuse joeytwiddle ij ernst Paks pdxleif fergusnoble catern Hijiri mitchty c_wraith Burnout641_ lyxia edran geal syamaoka markhuge spion tek0_ jackhill armlesshobo Squarism DwarfMaster deu lieven xxpor_ sns Novitsh so n3parikh karls henrytill)
18:26:32 <Cale> Dynasty: It makes sense right up until you run into a situation where two such instance selections overlap in scope, and you have to wonder which one wins
18:27:03 <Cale> They do that kind of thing in Scala and you end up in situations where you want to rip all your hair out
18:27:07 <Dynasty> I'm not sure what you mean. If the instances overlap, they are bucketed into the same set and you have to choose a name
18:27:31 <Dynasty> The Scala problem is different I think. That has more to do with orphan definitions
18:27:34 <Cale> I mean where you obtain an instance by way of two different routes
18:27:51 <Cale> i.e. you know that there's an instance of Monoid a in scope for two different reasons
18:27:56 <Cale> (or more)
18:29:09 <Cale> If you end up needing to write the name of the instance everywhere you use it, then you're in just the same situation as having a record type.
18:29:56 <Cale> (at least in terms of how annoying it is to write the terms)
18:31:11 <Dynasty> So there are two possible ways to declare a typeclass instance. You can put the instances in the same module as the type class definition or in the same module as the type. For the case where there are overlapping instances in the same module as the typeclass, everybody finds out about the overlap when they import that module. In the case where the instances are defined with the type, then everyone finds out about the overlap when they try to import the
18:31:11 <Dynasty> type.
18:31:13 <Cale> In Haskell, if I obtain an instance of Ord a from, say, unpacking it from a GADT constructor, and then a second one from a constraint on my function
18:31:19 <Cale> then I know they must be the same instance
18:31:34 <Cale> and I don't need to worry about which Ord I'm using when I write (<=)
18:32:08 <Dynasty> Sure, I agree that there are similarities with the explicit record passing
18:32:14 <Cale> Moreover, this conventional stability is super important when it comes to the construction of data structures like Set and Map
18:33:34 <Cale> If I accidentally started using a different ordering, all my Sets and Maps will have invalid internal structures, and I'll end up getting garbage results or exceptions from the failed invariants.
18:34:24 <Dynasty> Okay, this sounds more like an unsoundness argument, which I am a lot more interested in
18:36:28 <Cale> Similarly for hashing, serialisation libraries, and many other things where it makes sense to stick to a convention (usually subject to some laws) for whatever reason.
18:38:50 <astralemp> what's the cheapest / easiest way to host a yesod app?
18:39:34 <Cale> Dynasty: this talk is relevant https://www.youtube.com/watch?v=hIZxTQP1ifo
18:39:45 <parsnip> you can get small VPS for about $5.00/month
18:39:56 <Dynasty> Cale so let's use the pair example from my gist. I have defined two different ways to order a pair, either by left side first or by right side first. If you use the first ordering to create the set, but use the second ordering when performing the member operation, you'll get garbage results
18:40:07 <Cale> correct
18:40:10 <parsnip> but you can't really build haskell programs on those, just run them.
18:40:28 <Cale> because your binary balanced tree structure all of a sudden doesn't maintain the ordering invariant
18:40:31 <astralemp> parsnip: is there anyway for it to be as simple as uploading the executable through some web interface?
18:40:42 <Cale> that all the things on the left are less than the thing at the root
18:40:46 <Cale> etc. etc.
18:40:47 <Dynasty> Okay, that makes sense. I'm guessing that the solution to all of these problems is ML modules...
18:41:01 <Cale> Well, ML modules and type classes are roughly isomorphic
18:41:18 <parsnip> astralemp: from your development machine? i'd think it's easier at that point to use a deployment script.
18:41:24 <Cale> They serve somewhat different roles in practice, but they're kind of formally the same thing
18:42:27 <Dynasty> I wonder if there is a way to enhance the newtype wrappers so that we can have the best of both worlds. Perhaps you can add a tag to a type instead of just wrapping it. So you could have multiple tags per type, and the order of these tags wouldn't matter.
18:42:39 <Cale> I'm really serious about that talk btw, it's really great and gets into a lot of the decisions you're thinking about :)
18:42:49 <Dynasty> okay
18:43:11 <astralemp> parsnip: what actually need to be deployed? would the script just copy then execute the executable?
18:44:36 <astralemp> I wondered if I could do it without needing to ssh into the machine at all, but then, they don't generally come with ghc preinstalled ...
18:45:30 <parsnip> astralemp: to set up a webserver, i'd think you're going to have to do some work. at least to set it up the first time.
18:45:57 <astralemp> yeah
18:46:03 <Dynasty> I think the main issue with the selectors that I developed is that the selectors don't stick around on the type level. You have to choose the selector(s) every time you invoke a function
18:46:48 <Cale> Dynasty: Yeah, and if you *do* make them stick around on the type level, it starts looking more and more like the newtypes :)
18:47:11 <Cale> (or the records)
18:47:45 <Dynasty> I will have to look at the wrapper solution in the context of the type class Monoid -> Semiring hierarchy. Maybe there is a solution there that I didn't think of when I was looking at the problem this morning
18:52:18 <Dynasty> Cale yes it is looking like the newtype solution is the best we're going to get then :(. I think my earlier problems with the Monoid -> Semiring hierarchy were caused by trying to generalize stuff to the Num type class. But I can completely throw out Num if I'm going to be basing the hierarchy on algebraic structures instead.
18:52:56 <Dynasty> And then things like integer literals will be of type int32 instead of Num a => a
18:55:41 <Dynasty> Cale were you talking about Data.Coerce before?
19:21:53 <Cale> Dynasty: yeah, that's a solution to the problem of needing to apply wrappers that don't do anything at runtime, but need to be applied to collections.
19:22:17 <Cale> It's not an amazingly beautiful solution, but it does the job
19:27:27 <heptahedron> Where might one put kind signatures in a typeclass instance?
19:33:59 <lyxia> heptahedron: instance Class (T :: K) (U (V :: K))   ?
19:34:21 <heptahedron> lyxia: I actually just found out why it was inferring weird kinds--but thanks for the help!
21:02:46 <metahumor> woodson made solutions at http://lpaste.net/362574
21:03:04 <woodson> metahumor: lol
21:03:09 <woodson> hope its ok
21:03:11 <metahumor> woodson: what if I had asked you to make sumMaybes to return Nothing if one of the elements was Nothing
21:03:16 <metahumor> yeah they're great
21:03:42 <metahumor> woodson: perhaps you could have expressed one in terms of the other
21:04:19 <metahumor> woodson: given that you're filtering (=/ Nothing), that's the same as setting them to 0, so in your solution, "sumMaybes = Just . sumFromMaybes"
21:05:26 <metahumor> I don't think you need an "Eq a" in the sumMaybes
21:05:27 <woodson> Ya, they are kinda interchangeable
21:05:49 <woodson> the Eq a is because the compiler was crying about it
21:06:04 <metahumor> i guess to get the "Eq (Maybe a)" instance
21:06:19 <metahumor> woodson: there are also the "isNothing" functions, and the "catMaybes"
21:06:23 <metahumor> :t catMaybes
21:06:24 <lambdabot> [Maybe a] -> [a]
21:06:39 <metahumor> "sumMaybes = sum . catMaybes"
21:06:57 <metahumor> whoops, "sumFromMaybes = sum . catMaybes"
21:07:34 <woodson> ya
21:07:48 <metahumor> woodson: you'd have to make the choice how you deal with Nothing. often, we want to propagate the Nothing to the folded result
21:07:52 <woodson> but you said to only use sum sequence and fmap
21:08:02 <metahumor> yup
21:08:13 <woodson> I thought that since we would consider nothing as 0
21:08:20 <woodson> filtering it would be a good option
21:10:03 <metahumor> i guess, but then you don't need to sequence, and can just do the "Just . ..." thing I wrote above
21:10:04 <woodson> and as to answer your first question i could maybe have a sub function that just check if there are any Nothing
21:10:40 <woodson> ya
21:10:41 <metahumor> yup, these are all important design decisions that have to do with your downstream
21:11:12 <woodson> the best way would be to reuse sumFromMaybe the code is shorter
21:11:35 <woodson> I always forget that Just constructor is an actual function
21:11:51 <woodson> :t Just
21:11:52 <lambdabot> a -> Maybe a
21:12:09 <metahumor> i'd expect that if I was given both "sumMaybes" and "sumFromMaybes" with those types in a library
21:12:27 <metahumor> that "sumMaybes" can return a Nothing -- otherwise, why return a "Maybe a"?
21:12:44 <metahumor> if it is just "Just . sumFromMaybes", why export both?
21:13:04 <woodson> lol
21:13:08 <woodson> True
21:13:26 <woodson> I was thinking only about solving it without paying attention to that
21:13:28 <woodson> good point
21:13:53 <metahumor> "principle of least surprise"
21:18:51 <woodson> metahumor: http://lpaste.net/362574, edited
21:18:56 <woodson> with another version
21:20:35 <metahumor> woodson: that is even more suprising to me
21:20:51 <metahumor> because you are saying that "sumMaybes [Just 0] = Nothing"
21:22:04 <woodson> I thought that we wanted to represent 0 as Nothing
21:22:19 <metahumor> other way around possibly
21:22:44 <metahumor> so "sumFromMaybes = sum . fmap sum" as before, "sumMaybes = fmap sum . sequenceA"
21:25:08 <woodson> oh I see you want Nothing to govern over the whole sequence if there is any
21:27:47 <woodson> but what if you have a list of effect values and even if you get Nothing from one them you still want to continue the summing everything
21:27:52 <woodson> that wouldnt help
21:28:08 <metahumor> oh you mean deal with Nothing as a no-op?
21:28:21 <woodson> yes
21:29:18 <woodson> so i guess for no-op its better to avoid Maybe and create our own no-op type?
21:29:34 <metahumor> "sequence . catMaybes" would be my first guess
21:31:03 <woodson> ahhh, wow..
21:31:27 <woodson> i've used haskell for small project and other things
21:31:40 <woodson> but I am just now noticing the power of the Maybe
21:31:55 <woodson> I never really used catMaybes
21:32:08 <woodson> or isNothing
21:32:26 <woodson> I am happy that I am going through the haskell book
21:33:01 <metahumor> i'm not a fan of "isNothing" and "isJust", "isConstructor" is useful for more complicated sum types, but not so much for Maybe, where the Applicative/Monad instances are straightforward and catMaybes exists
21:35:33 <woodson> Well I've finished the Applicative/Monad chapter
21:35:51 <woodson> cant wait to get to Writer, State and Monad Transformers
21:37:19 <woodson> Anyhow, you've open my eyes about one thing for sure... Don't use types that are not truly doing what they mean..
21:37:20 <woodson> haha
21:37:33 <metahumor> it's up to you to decide what Maybe means
21:37:45 <olligobber> Maybe :: * -> *
21:38:13 <woodson> well if its just going to return Just is it really necessary?
21:38:23 <metahumor> you decided that Nothing is 0, which could be fine, for example, if "LengthOfMessage ~ Maybe Int", and you got Nothing for when you don't have a message
21:38:55 <woodson> oh ya for the second version
21:39:08 <woodson> however, my initial version didnt consider nothing
21:39:15 <metahumor> "sumMaybes [] = Nothing; sumMaybes = ..."
21:39:23 <metahumor> that could have been an option too
21:42:59 <woodson> metahumor: Ya, there is that option too.
21:43:10 <woodson> anyway thanks for the exercise
21:44:30 <gestone> hey all! i'm getting this error when i'm trying to make an instance of ReaderT: http://lpaste.net/362576
21:44:47 <gestone> i'm having difficulty parsing exactly what the... error means?
21:46:08 <boj> gestone: you are telling it the Reader environment to pull is some random "backend", which has no Reader instance itself (ConnectionPool specifically)
21:46:48 <gestone> ohh it's an issue with the "backend"
21:47:08 <metahumor> woodson: sorry i got disconnected
21:47:12 <metahumor> so, boolean blindness
21:47:46 <metahumor> there is also "maybe blindness", which we hit here, since it is unclear what "Maybe a" really means
21:47:58 <gestone> updated the lpaste, if i remove the type signature i get another error
21:48:27 <metahumor> woodson: https://github.com/quchen/articles/blob/master/algebraic-blindness.md#algebraic-blindness-1
21:49:05 <boj> gestone: how are you calling "personReader"?
21:50:04 <gestone> boj: calling it with like: 'runSqlPool personReader'
21:50:09 <gestone> https://hackage.haskell.org/package/persistent-2.8.1/docs/Database-Persist-Sql.html
21:50:42 <gestone> i'll update the code snippet again
21:52:45 <boj> gestone: i think the key here is that it doesn't understand that "backend" is actually "ConnectionPool"
21:53:15 <gestone> ohh
21:53:25 <gestone> should i just try to explicitly type it as such?
21:53:45 <boj> give it a shot
21:55:09 <monochrom> If you declare your type to be "ReaderT backend Foo". Then I, the user, will be legal to use it as "ReaderT Int Foo".  Will that be consistent with your actual code though?
21:55:24 <gestone> boj: posted new error, i'm really not sure what's up
21:55:39 <gestone> monochrom: ahhh yeah it wouldn't be, i'll explicitly declare the type
21:55:40 <suzu> anybody know how to make the C FFI callback mechanism reentrant?
21:56:06 <suzu> that is: if a thread x calls a C function, that calls a haskell function that throws an exception, x should be able to catch it
21:56:42 <suzu> instead i'm seeing that exception go uncaught and it melting my program
22:07:13 <gestone> gah i figured out the error
22:07:37 <gestone> had to declare personReader as ReaderT Connection IO [PhoenixR.User]
22:07:49 <gestone> Connection is an instance of IsSqlBackend
22:07:54 <gestone> and it's taken from the ConnectionPool
22:08:06 <gestone> agh so frustrating
22:08:17 <boj> glad you were able to solve it :)
22:08:30 <gestone> yeah thanks for taking a look :D
23:04:37 <cocreature> suzu: afaik that’s not possible
23:34:48 <pacak> Anybody familiar with servant-client? How do I go about transmitting a certan parameter with every request without actually placing it all over the place? I want to be able to add "&foo=bar" at the end of every request
23:44:19 <cocreature> pacak: I’ve never tried something like this so take it with a grain of salt but maybe the following works: make a new combinator, wrap it around all requests that you want to have that parameter and then in HasClient instance you can add things to requestQueryString https://hackage.haskell.org/package/servant-client-core-0.13/docs/Servant-Client-Core-Internal-Request.html#t:RequestF
23:48:01 <pacak> cocreature: Yea, that might work. Will try.
23:48:04 <pacak> thanks!
