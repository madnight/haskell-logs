00:20:09 <figurehe4d> Do you need to be an experienced programmer to efficiently learn haskell?
00:23:35 <quchen> No.
00:23:44 <amalloy> you probably should be an experienced programmer to "efficiently" learn anything
00:26:28 <figurehe4d> will being an expereced programmer help me efficiently learn to snowboard?
00:26:33 <figurehe4d> -__-
00:27:14 <amalloy> can't hurt
00:28:07 <batman_> cale : how to create a var or const with word32 datatype
00:28:34 <amalloy> > let x = 5 :: Word32
00:28:36 <lambdabot>  <no location info>: error: not an expression: ‘let x = 5 :: Word32’
00:28:40 <amalloy> > @let x = 5 :: Word32
00:28:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
00:28:48 <amalloy> i have no idea how to use this dang thing
00:29:15 <MarcelineVQ> > 5 :: Word32
00:29:17 <lambdabot>  5
00:29:26 <raichoo> figurehe4d: You can pick up Haskell as your first language and be fine.
00:30:42 <MarcelineVQ> @let wod = 5 :: Word32 -- amalloy: you might be after this notation
00:30:44 <lambdabot>  Defined.
00:35:04 <batman_> i can get a word32 using x :: Word32 but what if i want to represent an ip of the form 127.0.0.1 in word32
00:36:10 <cocreature> batman_: one option would be to use https://hackage.haskell.org/package/ip-1.1.2/docs/Net-IPv4.html#v:decode and then pattern match on the newtype
00:37:23 <batman_> cocreature : i want a HostAdress type value : http://hackage.haskell.org/package/network-2.6.3.3/docs/Network-Socket-Internal.html#t:HostAddress can you please check it maybe i'm missing something from documentation
00:38:12 <cocreature> batman_: just use https://hackage.haskell.org/package/network-2.6.3.3/docs/Network-Socket.html#v:tupleToHostAddress
00:38:30 <cocreature> i.e. tupleToHostAddress (127, 0, 0, 1)
00:39:21 <batman_> cocreature : thank you
00:44:28 <dminuoso> Let's say I want to whitebox test a module with hspec without exporting the internals - is there a way to pry a module open, gaining access to top level bindings that are not explicitly exported?
00:45:56 <[exa]> afaik not necessarily, internals may get inlined and definitions erased as dead code
00:46:05 <cocreature> dminuoso: you can add it as a source file in your test suite. a better solution is to use cabal’s internal library feature https://cabal.readthedocs.io/en/latest/developing-packages.html#library
00:46:44 <Boarders> I saw this cool little trick on stackoverflow for defining variadic functions in haskell: http://lpaste.net/362726
00:47:04 <Boarders> I'm just wondering when you are in ghci and do: > sumOf 1 2 3 4
00:47:05 <Boarders> 10
00:47:21 <dminuoso> cocreature: Ahh I see. That would work nicely thanks.
00:47:28 <[exa]> Boarders: +1 cool
00:47:29 <Boarders> then why does ghci know to use the Integer instance when it tries to print
00:48:02 <Boarders> does it just look which instances have show to determine or something like that?
00:48:05 <cocreature> Boarders: it’s called “type defaulting”, take a look at https://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html
00:48:07 <dminuoso> Boarders: Type defaulting I guess?
00:48:07 <[exa]> Boarders: probably from defaulting
00:48:20 <Boarders> thanks
01:15:30 <hc> Hi all
01:15:39 <hc> I'm currently writing an app with servant and servant-swagger...
01:16:38 <hc> When defining json datatypes, i like to use the fieldLabelModifier when defining ToJSON instances... However, this fieldLabelModifier is not recognized when generating swagger documentation. I was wondering if there is a less boilerplate-prone alternative to having to explicitly specify the fieldlabelmodifier for both ToJSON,FromJSON and ToSchema instances?
01:34:48 <kuribas> > '\235'
01:34:50 <lambdabot>  '\235'
01:34:59 <kuribas> why doesn't that show ë ?
01:35:15 <kuribas> http://www.codetable.net/decimal/235
01:35:51 <Maxdamantus> > text '\235'
01:35:53 <lambdabot>  error:
01:35:53 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
01:35:53 <lambdabot>        Expected type: String
01:36:01 <Maxdamantus> > text ['\235']
01:36:03 <lambdabot>  ë
01:36:26 <cocreature> kuribas: because the show instance is not defined like that
01:37:01 <kuribas> show "\n"
01:37:04 <kuribas> > show "\n"
01:37:06 <lambdabot>  "\"\\n\""
01:37:54 <Maxdamantus> kuribas: as far as Haskell is concerned, Char is just an enumeration of values. You can make use of the `Ord Char` instance to extract information from them and you can use that information for whatever purpose you want.
01:38:20 <Maxdamantus> as cocreature said, that just happens to be how `Show Char` behaves.
01:39:47 <kuribas> show "97\108\108\32\121\111\117\114\32\98\97\115\101\32\97\114\101\32\98\101\108\111\110\103\32\116\111\32\117\115"
01:39:52 <Maxdamantus> er, meant to say `Enum Char`, not `Ord Char`
01:39:54 <kuribas> > show "97\108\108\32\121\111\117\114\32\98\97\115\101\32\97\114\101\32\98\101\108\111\110\103\32\116\111\32\117\115"
01:39:57 <lambdabot>  "\"97ll your base are belong to us\""
01:40:36 <cocreature> you don’t need an explicit show, ghci (and lambdabot as well) will already call show
01:40:55 <kuribas> > "\65\108\108\32\121\111\117\114\32\98\97\115\101\32\97\114\101\32\98\101\108\111\110\103\32\116\111\32\117\115"
01:40:57 <lambdabot>  "All your base are belong to us"
01:41:25 <kuribas> okay, thanks
02:05:46 <shiona> I'm finally trying to learn using stack, but I can't even get my first dependency to work. I get
02:05:50 <shiona> hscurses must match >=1.4.2.0, but the stack configuration has no specified version (latest matching version is 1.4.2.0) needed since elevator is a build target.
02:06:59 <cocreature> shiona: you need to add hscurses-1.4.2.0 to the extra-deps section in your stack.yaml
02:09:19 <shiona> Ok, thanks
02:21:25 <batman_> i have a list ["127","0","0","1"] how can i convert it into (127,0,0,1)
02:23:04 <quchen> batman_: You’ll have to do this by hand.
02:23:22 <quchen> There is no shortcut.
02:24:07 <bbear> hey
02:24:17 <bbear> I thought of something about the Maybe monad.
02:24:33 <batman_> quchen : atleast is there a way to map read :: int on each element ?
02:24:34 <bbear> How is that different than doing in eg Python
02:24:43 <bbear> x = op1()
02:24:44 <[exa]> batman_: you wrote it :]
02:25:00 <nullie> > case map (read :: String -> Int) ["127","0","0","1"] of [a,b,c,d] -> (a,b,c,d)
02:25:02 <lambdabot>  (127,0,0,1)
02:25:03 <bbear> y = x and op(2); z = y and op(3)
02:25:20 <quchen> Use traverse readMaybe to get free error handling.
02:26:23 <quchen> > traverse readMaybe ["127", "world"] :: Maybe [Int]
02:26:25 <lambdabot>  error:
02:26:25 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
02:26:37 <[exa]> bbear: pretty much the same idea, except with Maybe the "x and ..." part wraps the whole rest of the code
02:26:38 <quchen> > traverse Text.Read.readMaybe ["127", "world"] :: Maybe [Int]
02:26:40 <lambdabot>  error:
02:26:40 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
02:26:40 <lambdabot>      No module named ‘Text.Read’ is imported.
02:26:44 <quchen> ಠ_ಠ
02:26:57 <phadej> i see unicode
02:27:08 <phadej> but i don't see what it is :/
02:27:15 <merijn> phadej: Look of disapproval
02:27:24 <merijn> @hackage acme-LookOfDisapproval
02:27:25 <lambdabot> http://hackage.haskell.org/package/acme-LookOfDisapproval
02:27:29 * [exa] sees square eyes, also very disapproving
02:27:45 <merijn> oh, wrong case
02:27:56 <merijn> @hackage acme-lookofdisapproval
02:27:56 <lambdabot> http://hackage.haskell.org/package/acme-lookofdisapproval
02:28:25 <merijn> Fun fact, the fact that GHC compiles that package is (technically) a violation of the Haskell Report due to a silly unicode oversight in the report!
02:28:26 <quchen> > ಠ_ಠ "Does Lambdabot have it loaded?"
02:28:28 <lambdabot>  error: Variable not in scope: ಠ_ಠ :: [Char] -> t
02:28:36 <quchen> ಠ_ಠ
02:28:48 <quchen> merijn: ??
02:28:54 <batman_> nullie : Neat, thanks !
02:29:11 <nullie> batman_: no, it's not neat
02:29:21 <merijn> quchen: The Report is written as-if lowercase is "all characters `S.difference` uppercase"
02:29:48 <merijn> quchen: So constructors start with uppercase and the other characters allowed are uppercase+lowercase
02:29:54 <nullie> quchen: how does the report define operators?
02:30:08 <merijn> quchen: ಠ however is from the Kannada alphabet, which doesn't have case
02:30:20 <merijn> So it's neither upper nor lower case and thus not a valid identifier character
02:30:37 <quchen> Great!
02:30:50 <merijn> nullie: The ASCII versions are explicitly listed and unicode operator characters are all those in the Symbol category
02:30:59 <quchen> TIL something new about the Report. Wooo
02:31:06 <merijn> > generalCategory '☃'
02:31:09 <lambdabot>  OtherSymbol
02:31:21 <nullie> > generalCategory 'ಠ'
02:31:21 <merijn> nullie: So unicode snowman is a legal Haskell operator character
02:31:22 <batman_> nullie : it might not be but to me it is. Anyway why it's no neat >?
02:31:23 <lambdabot>  OtherLetter
02:31:45 <nullie> batman_: it's a hack which can fail in many ways
02:34:37 <rewaant> <
02:35:30 <batman_> nullie : then what's the proper way , writing a dedicated function using pattern matching or recursion ??
02:36:00 <nullie> batman_: well, case bit is not bad if you handle _ case, but you should use readMaybe for read part
02:36:25 <batman_> nullie : okay
02:37:55 <phadej> note that GHC may use older Unicode standard that you are reading
02:38:12 <phadej> categories change etc.
02:38:30 <phadej> also what is considerd `isUpper` etc.
02:39:38 <phadej> not something you'll face if you are using common scripts (say cyrillic, greek) but something to be aware off if you overuse emojis in your code ;)
02:40:53 <batman_> nullie : is it possible to get Word8 4-tuple instead of Int 4-tuple ?
02:41:17 <nullie> > read "256" :: Word8
02:41:19 <lambdabot>  0
02:41:23 <nullie> > read "255" :: Word8
02:41:25 <lambdabot>  255
02:41:34 <phadej> > read "-1" :: Word8
02:41:36 <lambdabot>  255
02:41:54 <nullie> batman_: just change the type in the signature
02:42:01 <phadej> `read` isn't the best option if you want be precise in what you accept :)
02:53:29 <batman_> nullie : how can i extend this function to accept [String] as input and produce [SockAddr] as output
02:55:01 <nullie> batman_: you need to find functions here https://www.stackage.org/haddock/lts-10.6/network-2.6.3.3/Network-Socket.html
02:58:39 <batman_> <nullie> : i have the function i need to extend it, and i'm pretty sure they don't have a function for that
02:59:07 <nullie> batman_: they have functions to produce SockAddr
03:16:00 <apostolis> Hello.
03:17:17 <Guest27> whatsup
03:17:59 <batman_>     Expected type: [[Char]] -> SockAddr       Actual type: [[Char]] -> m0 [SockAddr]
03:21:18 <apostolis> If a function of mine returns (), will it be erased? I have unsafePerformIO inside it, so I do not want it to.
03:22:30 <apostolis> How can I tell haskell not to erase a function that returns (). ex fun : String -> ().
03:22:36 <Taneb> apostolis: a) are you absolutely sure you know what you are doing, and b) you can add a {-# NOINLINE #-} pragma
03:22:49 <apostolis> a) Yes.
03:22:55 <Taneb> No, not NOINLINE...
03:22:59 <cocreature> apostolis: also you need to make sure you are actually evaluating the result using `seq` or something like that
03:23:06 <Taneb> I'm sure there is a pragma that fits though
03:23:24 <batman_> nullie :     Expected type: [[Char]] -> SockAddr       Actual type: [[Char]] -> m0 [SockAddr] what does m0 mean here ?
03:23:47 <apostolis> I will use Noinline indeed but I need to evaluate the result. How can I evaluate ()?
03:24:22 <cocreature> apostolis: I just told you: use `seq` :)
03:24:35 <cocreature> apostolis: or just use `case`
03:24:36 <apostolis> ok, let me see the definition. :0
03:24:52 <cocreature> seq is a compiler builtin
03:26:15 <dminuoso> cocreature: Will `seq` forcibly re-execute if some other expression uses it?
03:26:34 <dminuoso> I mean if the thunk has been forcibly evaluated, there's no reason to redo it, right?
03:26:53 <cocreature> dminuoso: no it won’t reevaluate it. sharing still applies
03:27:13 <dminuoso> cocreature: Is there a way to prevent sharing explicitly?
03:27:42 <dminuoso> Though I guess NOLINE will help with that
03:27:46 <dminuoso> NOINLINE even
03:28:54 <apostolis> thanks all.
03:29:06 <cocreature> dminuoso: not really sadly, take a look at https://ghc.haskell.org/trac/ghc/ticket/12620
03:29:32 <cocreature> dminuoso: if you disable full-laziness then wrapping things in functions works at least most of the time
03:30:05 <batman_> can someone please help me with this error Expected type: [[Char]] -> [SockAddr] Actual type: [[Char]] -> [m0 [SockAddr]]
03:30:13 <batman_> sorry for posting it twice
03:30:51 <cocreature> batman_: you are going to have to show us the code that produces the error if you want help
03:31:41 <batman_> cocreature : http://lpaste.net/362733
03:33:04 <cocreature> batman_: please add the full error message to the paste
03:33:41 <batman_> cocreature : http://lpaste.net/362734
03:34:19 <cocreature> batman_: what type do you want `convertToSockAddr` to have? try adding an explicit type signature
03:35:28 <batman_> cocreature : convertToSockAddr :: [String] -> [SockAddr]
03:35:40 <batman_> cocreature : but then how do i handle [] case
03:35:55 <cocreature> batman_: try first writing a function `String -> SockAddr`
03:36:13 <cocreature> batman_: once you have managed to do that you can just use `map` to get the function that operates on lists of strings
03:36:59 <cocreature> batman_: the type error you have comes from the "return". [] already has type [SockAddr]. `return [SockAddr]` has type `Monad m => m [SockAddr]`
03:37:15 <cocreature> same goes for the return in line 14
03:37:32 <batman_> coreature : i can infact i did and its working with a single type but i wanted to see how recursion can be used to process a list
03:37:50 <cocreature> batman_: if you want to learn recursion then try implementing `map` yourself.
03:38:44 <cocreature> batman_: generally separating your code into smaller, standalone functions both makes it significantly easier to understand as well as allowing you to reuse code
03:39:43 <kuribas> is haskell platform still the recommended way to install haskell on windows/mac?
03:40:02 <merijn> kuribas: Well, I'd say definitely not on Mac
03:40:08 <cppxor2arr> what about linux?
03:40:08 <merijn> kuribas: I always just install bindists there
03:40:12 <olligobber> personally, I recommend overwriting windows/mac with linux and installing haskell on that
03:40:21 <kuribas> cppxor2arr: I use the PPA
03:40:31 <kuribas> cppxor2arr: https://launchpad.net/~hvr/+archive/ubuntu/ghc
03:40:40 <kuribas> olligobber: +1
03:40:53 <merijn> kuribas: https://www.haskell.org/ghc/download_ghc_8_2_2.html
03:40:59 <cppxor2arr> kuribas: what about fedora?
03:41:17 <kuribas> cppxor2arr: sorry, I don't own a fedora ...
03:41:26 <merijn> kuribas: I just do "./configure --prefix=$HOME/ghcXX && make install" on OSX (and linux, and really anywhere but windows, tbh)
03:41:26 <cppxor2arr> ok i just did "dnf install haskell-platform"
03:41:56 <merijn> kuribas: Then either build cabal-install using the source script or (via the apparently now available) bindists
03:42:03 <kuribas> merijn: apt install is faster...
03:42:20 <kuribas> merijn: and I had a lot of troubles with conflicting versions before...
03:43:12 <batman_> cocreature : i tried that with map convertToSockAddr ["127.0.0.1:7000","127.0.0.1:800"] but it throws http://lpaste.net/362735
03:43:29 <batman_> cocreature : i have added explicit type declaration for the function
03:44:00 <merijn> kuribas: huh? how'd you manage that? GHC uses a per-version package db, so it's always Just Worked for me
03:44:13 <cocreature> batman_: what do you think the `return` on the last line does?
03:44:32 <batman_> cocreature : return the value
03:44:53 <batman_> coreature : and its doing just that with only one value i mean without map
03:44:54 <cocreature> batman_: `return` in Haskell has a completely different meaning than `return` in languages like C, Java, …
03:45:32 <batman_> cocreature : what it mean in haskell
03:45:37 <cocreature> :t return
03:45:38 <lambdabot> Monad m => a -> m a
03:45:49 <cocreature> it’s a function from `a` to `m a`
03:46:11 <cocreature> in your case a is SockAddr so m a is the m0 SockAddr you see in the error message
03:46:18 <cocreature> just remove the return
03:46:36 <cocreature> also you shouldn’t be using a do block here
03:46:44 <kuribas> merijn: Idk, I'm just good at messing up I suppose
03:47:28 <kuribas> return should be obsoleted
03:50:23 <Athas> What's the reasoning behind that name, anyway?
03:50:50 <Athas> Was it just chosen to make monadic code look more C-ish (with functions ending in "return")?
03:52:58 <kuribas> That seems likely
03:55:14 <shiona> should it be possible to use forkIO and hscurses together and get something to update?
03:55:46 <merijn> Athas: The reasoning was "it's often used where you'd use return in imperative languages, so that'll be easy to beginners"
03:56:01 <merijn> Athas: So, yes
03:57:47 <ian5v_> hi all, i'm getting tripped up by some nested wheres
03:57:48 <Athas> That falls apart under the lightest scrutiny.  Oh well, all languages have that awkward early phase.
03:57:54 <ian5v_> https://hastebin.com/somemotepu.bash
03:58:23 <Athas> shiona: the cardinal rule of pretty much all GUI programming is to keep all GUI operations in a single thread.
03:59:02 <ian5v_> or, simpler example:
03:59:04 <ian5v_> https://hastebin.com/vexetepuge.bash
03:59:13 <shiona> Athas: check
03:59:18 <ian5v_> are nested wheres not a thing?
03:59:51 <ian5v_> based on some SO googling it looks like they should be
03:59:52 <Taneb> Nested wheres are a thing!
04:00:23 <ian5v_> oh i just need more indentation
04:00:26 <ian5v_> odd
04:00:27 <Taneb> ian5v_: I think the tripping point is they need to be indented more than you think
04:00:51 <Taneb> To just past the start of the level above, which is the binding, not the "where" keyword
04:01:28 <ian5v_> i see. funky. thanks!
04:02:01 <Taneb> (I normally put the bindings on a different line to the "where" for this reason)
04:04:37 <ian5v_> super proud of this code
04:05:24 <ian5v_> much, /much/ cleaner than my first pass
04:15:21 <Boarders> say I have a project with a folder that contains some data I want to look at
04:15:52 <Boarders> is there any way to easily specify the filepath to that stuff so that it is relative?
04:20:34 <Boarders> oh nevermind seems to work as is, I was just being dumb
04:33:57 <Boarders> I am trying to do a basic example in servant (which I don't really understand atm) and have the following: http://lpaste.net/362739
04:34:26 <Boarders> but I get file not found when I run it
04:35:11 <alp> Boarders, are you following the tutorial?
04:35:37 <Boarders> I was atm I am just trying to cobble together the simplest working example
04:36:16 <cocreature> Boarders: how are you running your app?
04:36:16 <alp> Boarders, I'm asking because the tutorial explains file serving and likely contains a sentence or two that'll help you solve this issue :) https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#serving-static-files
04:36:43 <alp> in particular: "This server will match any request whose path starts with /static and will look for a file at the path described by the rest of the request path, inside the static-files/ directory of the path you run the program from."
04:38:45 <Boarders> alp: thanks
04:39:03 <Boarders> cocreature: I am just running main if that is what you mean?
04:39:39 <cocreature> Boarders: I was more referring to the directory you are running it from but alp phrased it better than I did :)
04:46:31 <merijn> Damn timezones...I hate it when technical decisions that take 30 minutes drag out for days due to people insisting on living in the US >.>
04:48:06 <hpc> yes, how dare they
05:18:51 <merijn> So...opinion poll time: 1) Release libraries early/often with no regard for backwards compat until you settle on an API you like, or 2) Wait until API has stabilised before releasing to hackage then sticking to it?
05:19:46 <sonOfRa> Do what you like, but stick to a versioning scheme that signals api changes, like semver
05:19:56 <fishythefish> +1
05:20:17 <merijn> sonOfRa: PVP is preferred over SemVer in Haskell circles, because it's less underspecified
05:21:08 <sonOfRa> sounds generally similar to semver, except more rigid. I'd go with that.
05:21:20 <phadej> FWIW, PVP is older than semver
05:21:38 <sonOfRa> A common approach for new libraries in semverland is to release 0.x.y until you think you have something that's at least *somewhat* stable
05:22:00 <sonOfRa> And letting the leading zero signal that this is still not really a complete library
05:22:18 <phadej> that's written in semver contract: 0.x.y means "everything can change"
05:22:45 <phadej> where PVP has same rules for 0.x.y.z and n.x.y.z where n /= 0
05:23:48 <phadej> merijn: 3) release libraries when you think it will be useful to someone in current shape
05:25:43 <phadej> also 3b) it's not necessary to have a release after each merge/commit
05:27:06 <phadej> in fact finding good release cycle for actively developed libraries is difficult. You want to release often, but not too often (as upgrading is a cost, also if downstream want to support multiple versions etc.)
05:27:25 <merijn> phadej: Yeah, I know
05:28:35 <merijn> phadej: Right now I have my stuff embedded as subrepository in my code, so updating the Hackage version gets rid of that clutter. Plus, it's taking longer than expected for me to finally settle on a bunch of details, hence I'm thinking of just releasing stuff now for people to use as-is
05:30:39 <phadej> merijn: I think releasing to hackage to help own development burden is not very good motivation.
05:31:14 <merijn> phadej: Well the main library is already on hackage and the current version is much more useful/usable
05:31:27 <merijn> phadej: And the additional libraries are useful enough as-is
05:32:54 <phadej> but OTOH I'm perfectionist. Making release itself is a burden, updating changelog, going through docs, etc. So I just postpone many before there's some external motivation (e.g. GHC or some other dependency updates, somebody asks for release etc.)
05:33:21 <merijn> phadej: Relatedly, can I delete candidate uploads?
05:34:02 <phadej> good question
05:34:54 <merijn> I know I can overwrite them, but so far I've been uploading 1.0 in the assumption I'd finish 1.0 Real Soon Now
05:35:36 <phadej> I think (not sure) 1.0 will be gone from candidates when you upload 1.0 to the proper index
05:35:48 <emongated> what's a better replacement for "forM_ [1..length xs - 1]"
05:35:56 <merijn> phadej: Yeah, but I plan to release it as 0.2 instead :p
05:36:17 <quchen> phadej: As we all have learned, making sure the release is tagged right is a good thing to do ;-)
05:36:17 <merijn> emongated: replicateM?
05:36:19 <emongated> yes the problem is stupid (bubble sort) but i'm only doing it for fun
05:36:26 <ljvm> Hi I would also like to ask a question about types etc. :)
05:36:36 <phadej> ljvm: go ahead
05:36:47 <dmwit> emongated: `forM_ xs` or `forM_ (zip [1..] xs)` if you need the index too.
05:37:28 <dmwit> emongated: Or maybe `forM_ (drop 1 xs)`? Tough to tell exactly what you wanted to do.
05:37:39 <emongated> i'll lpaste what i've got rn
05:37:54 <quchen> for_ (zipWith const [1..] xs)
05:39:05 <phadej> merijn: you can
05:39:14 <phadej> go to http://hackage.haskell.org/package/pkg-name-1.2.3/candidate/maintain
05:39:42 <phadej> there's a link "edit package information" on the candidate package page
05:39:44 <emongated> i'm working on mvectors, not lists
05:40:15 <ljvm> So I am answering some exercises from the Haskell book, and I was given a function f with type "f :: (Ord a, Num b) => a -> b -> a". When asked for the type of "f 1 2", it shows (Num a, Ord a => a), can't seem to understand why. Why is it not Num a => a?
05:40:36 <emongated> http://lpaste.net/2804671755195514880
05:41:39 <merijn> phadej: Ah, success!
05:41:46 <lyxia> ljvm: it should be (Num a, Ord a) => a
05:42:19 <emongated> ljvm: because a needs to implement ord as well anyway perhaps
05:43:20 <emongated> and its not erased because it hasn't been evaluated yet
05:43:48 <lyxia> ljvm: (Num a, Ord a => a) looks like a pair of (Num a) and (Ord a => a). Both Num and Ord are the constraints required by f.
05:44:33 <ljvm> Okkkk I see I see, wait let me digest it for a while :)
05:47:23 <ljvm> Ok, so it means that a must fill the "type constraint" that it should be Num and Ord?
05:48:41 <lyxia> I don't understand what you just wrote.
05:49:01 <emongated> ljvm: yes
05:49:14 <emongated> a needs to be an instance of Num and Ord
05:49:25 <EvanR> you can think of (Num a, Ord a) => a as a function that takes two implementations for those classes regarding a, and returns an a
05:49:26 <ljvm> lyxia: So "a" must be both types of Num and Ord (?) Yes I think emongated got me
05:49:40 <EvanR> and you can rewrite it as Num a => Ord a => a to be more haskell life
05:49:42 <EvanR> like
05:49:44 <emongated> i think its safe to assume that a concrete value with a typeclass constraint implements them anyway
05:50:11 <emongated> as in not a fn
05:50:37 <EvanR> => is a lot like a function arrow, only it takes constraints instead of values on the left
05:51:21 <ljvm> I see I see, I guess it's becoming clearer now. Is it possible for you guys to provide me an example instance of Num and Ord?
05:51:37 <EvanR> the type Int implements both those
05:51:46 <EvanR> you can also do :i Num and :i Ord on the ghci
05:53:44 <ljvm> The type Ord covers everything that can be ordered right?
05:54:01 <EvanR> its a type class
05:54:08 <ventonegro> ljvm: not a type
05:54:15 <EvanR> with methods like
05:54:20 <EvanR> :t compare
05:54:21 <lambdabot> Ord a => a -> a -> Ordering
05:59:33 <ljvm> Ok, not yet in the typeclasses chapter so I read parts of it earlier. Perhaps back to my earlier question, (Num a, Ord a) => a, means that it "implements/an instance of/has type(?)" (really sorry I don't know the proper term) the two typeclasses Num and Ord?
06:00:00 <emongated> ljvm: do you know any rust, go, java?
06:00:18 <ljvm> No just python :(
06:00:24 <emongated> ok
06:00:35 <emongated> it means implements
06:00:36 <quchen> ljvm: Yup. It’s like interfaces, but unlike in Java they’re not broken.
06:01:48 <emongated> the compiler will only accept passing it values of types that implement and are instances of that class
06:02:04 <EvanR> ljvm: the type (Num a, Ord a) => a is the answer to something, but you havent learned about typeclasses yet?
06:02:20 <EvanR> now you know you need to backtrack
06:02:23 <quchen> ljvm: Things before the => constrain the types you can use the value with. (Num a, Ord a) => a means »this works for all types »a«, as long as they’re numeric and ordered
06:02:43 <emongated> if i have f :: Num a => a -> b and i give it a String, then the compiler rejects it because String is not an instance of Num
06:03:05 <EvanR> quchen: erm...
06:03:20 <emongated> that is, there is no "instance Num String" and there is no instance of (+), (-), etc for that type
06:03:26 <quchen> EvanR: «
06:03:41 <EvanR> forall a . Num a => a "means", given a type a, given an implementation of Num for a, you get an a
06:04:10 <EvanR> rather than... "works" something something
06:04:18 <dmwit> ljvm: The `Ord a` constraint is there because `f` demands it. The `Num a` constraint is there because `1` demands it.
06:04:33 <ljvm> Not yet :( Hmmm, I'm just following the Haskell book intermission exercise in chapter 5 and I just had some misconception. I see I see
06:05:32 <emongated> a tad OT but i think knowing rust's traits and generics is a good stepping stone for understanding type classes
06:05:50 <emongated> because they are the same idea but work around object methods instead of fns
06:06:02 <dmwit> emongated: Unrelated to your question, but you probably want `b <- readSTRef r` and `when b bsort'` to be part of the outer do block, not the inner one.
06:06:03 <EvanR> that sounds confusing
06:06:37 <emongated> dmwit: thanks
06:07:46 <dmwit> Well. The middle do block. =P
06:08:24 <emongated> EvanR: it's the same concept as typeclasses but in an imperative OO context
06:09:28 <EvanR> java interfaces are a lot more analogous
06:09:33 <emongated> lets say we have a trait Num { fn add(&self, x: Self) -> Self, fn sub(&self, x: Self) -> Self }
06:10:06 <emongated> thats like class Num a where add :: a -> a -> a and sub :: a -> a -> a
06:10:17 <EvanR> and generics?
06:10:31 <emongated> well they call them generics
06:10:43 <EvanR> :(
06:10:49 <emongated> afaik you can't compose java interfaces whereas you can in rust
06:11:04 <EvanR> what is the composition of a traits
06:11:12 <emongated> fn f<T: This + That>(x: T)
06:11:37 <emongated> -> Option(T)
06:11:48 <EvanR> is that supposed to be on one line
06:11:50 <emongated> yes
06:12:09 <emongated> it's analogous to f :: (This a, That a) => a -> Maybe a
06:12:16 <ljvm> Thank you everyone, I think I understood dmwit's explanation as well in terms of f demanding the Ord and 1 demanding the Num...
06:12:17 <EvanR> so generics in this case is a word for polymorphic function
06:12:20 <emongated> yeah
06:12:54 <emongated> polymorphism instead of generics really. but the rust people have to speak in terms that c++ people get
06:12:57 <EvanR> yeah java has that
06:13:00 <emongated> oh ok
06:13:05 <quchen> Well in Java you can combine interfaces too, it’s just very cumbersome since you have to write a new interface inheriting from all of its constituents.
06:13:11 <emongated> right
06:13:23 <EvanR> actually there is something exactly like what emongated wrote
06:13:26 <quchen> But technically that’s a simple detail that could easily be added to the compiler automatically.
06:13:26 <EvanR> added later
06:14:09 <EvanR> called generics
06:14:33 <quchen> All of these terms are heavily overloaded. Especially »polymorphism«.
06:15:41 <EvanR> you can try to make sense of it by discriminating between parametric polymorphism (like the type of map), and so called "ad hoc" polymorphism, which is type classes
06:16:04 <EvanR> one generic algorithm that works with anything, vs many implementations that only work with one thing
06:16:25 <quchen> And subtyping and stringly typing and faith-based typing
06:17:38 <quchen> And Unicode third-party-generated code polymorphism
06:17:58 <ljvm> @dmwit, so why does ":t f (1 :: Integer) 2" give me "Integer"? Now I am expecting (Integer a, Ord a) => a. Maybe is it because Integer "covers" both Num and Ord? Hope it makes sense. Thank you everyone for being patient with me :)
06:17:59 <lambdabot> Unknown command, try @list
06:18:34 <quchen> ljvm: What is f’s type?
06:18:45 <cocreature> ljvm: do you mean "(Integral a, Ord a) => a"? Integer is a type not a typeclass
06:18:49 <ljvm> (Ord a, Num b) => a -> b -> a
06:19:07 <EvanR> why did you substitute Integer for Ord
06:19:15 <EvanR> er
06:19:25 <ljvm> Okkk yess sorry I think Integral is the term...
06:19:50 <EvanR> when you specified Integer, you chose the 'a'
06:19:57 <EvanR> to be Integer
06:20:32 <EvanR> then the type checker provided both the Ord Integer and Num Integer implicitly, then applied the two arguments
06:24:08 <manek> Hi! Is it possible in TemplateHaskell to reify the type of passed argument ?
06:30:08 <ljvm> I think I'm starting to understand but I will still read a bit. Thanks a lot!
06:30:09 <Boomerang> Yes with typed template haskell slices
06:30:16 <Boomerang> $$(...)
06:30:40 <Boomerang> s/slices/splices
06:31:09 <Boomerang> Or maybe I missunderstood the question
06:34:31 <manek> oh, Ive never hear of typed th slices
06:34:37 <manek> I have to read about them
06:37:55 <Boarders> I am still confused about this basic servant example
06:38:04 <Boarders> I have something like this: http://lpaste.net/362743
06:38:20 <Boarders> and just get "This site can't be reached"
06:38:31 <Boarders> I don't know if I have the wrong end of the stick with what I should expect or not
06:39:42 <manek> Boomerang: thanks!
06:40:44 <Boarders> oh no I was being dumb actually
06:40:46 <Boarders> nvmd
06:41:01 <alp> wrong port? :)
06:42:59 <merijn> manek: They're amazing!
06:43:15 <dmwit> ljvm: There is a distinction between constraints -- for example, `Ord a`, `Num a`, `Integral a` -- and types -- for example, `Bool`, `Integer`, `String`. They're separate classes of things. A constraint describes a collection of types.
06:43:29 <manek> merijn: <3
06:43:38 <merijn> manek: I hacked together a really neat prototype library with them (that I will properly update to be a usable production library Any Day Now (TM))
06:43:41 <merijn> manek: http://hackage.haskell.org/package/validated-literals
06:44:29 <manek> merijn: this lib is amazing, thanks for sharing!
06:44:40 <merijn> manek: It uses a Typed TH splice to figure out what type a polymorphic literal (e.g. 0.2, 3, "foo" (if you have -XOverloadedStrings)) should be, then performs the partial conversion at compile time and fails if it's incorrect
06:45:38 <merijn> manek: They idea being that you could have a "newtype URL = URL { getURL :: String }" (or whatever) with "String -> Maybe URL", but that's really obnoxious with literals you write directly in code (you end up doign fromJust or whatever)
06:45:50 <merijn> manek: It's not very polished atm, but it works :)
06:48:25 <hyperisco> good use of TH… I did the same for regex strings
06:48:39 <hyperisco> and I sorely miss this sort of capability in other languages
06:49:19 <hyperisco> worse about fromJust is there is no static check it is valid
06:50:24 <Taneb> merijn: that's a really neat idea :)
06:50:27 <cocreature> it would be neat if OverloadedStrings/Lists allowed compile time checks
06:50:37 <cocreature> via some kind of TH mechanism
06:51:36 <merijn> cocreature: I proposed that for GHC, got shot down that usefulness should be proved via some TH based library first and then implemented that lib as proof-of-concept
06:52:20 <hyperisco> funny because that should be really easy to accomplish
06:54:04 <hyperisco> though I think fromString for IsString types should be total
06:54:19 <nullie> Is there a concise way to write x = a / b if a and b are Maybe a?
06:54:31 <merijn> hyperisco: Well, the entire point for me was to allow non-total fromString instances in a reasonable way
06:54:47 <hyperisco> but a different class, call it  KindaString  maybe :P
06:54:48 <cocreature> merijn: heh :)
06:54:49 <byorgey> nullie: x = liftA2 (/) a b
06:54:59 <byorgey> or  (/) <$> a <*> b
06:55:01 <merijn> cocreature: Also, I do have support for OverloadedList/OverloadedString in there :p
06:56:41 <cocreature> merijn: my point was that I want literals to go through the TH validation without having to wrap things in TH splices :)
06:56:56 <hyperisco> oh, no splices, hrm
06:56:59 <merijn> cocreature: Well, yes
06:57:20 <merijn> cocreature: But as I said, I was told to prove there was demand for that before adding it as feature request for GHC
06:57:30 <merijn> cocreature: So clearly you should help increase adoption!
06:58:00 * cocreature makes PRs to add validated-literals as a dependency to every package
06:58:42 <hyperisco> how do you make typing sensible without the splice though
06:59:16 <hyperisco> I guess you're saying you're going to allow  fromString  to throw with error
06:59:54 <hyperisco> then you've got a sort of weirdness where behaviour changes depending on whether you have the extension enabled or not
07:00:48 <merijn> In other news, linewrapping big SQL queries is hard
07:00:58 <exarkun> how so
07:01:13 <merijn> exarkun: I don't know how to do it in a way that looks nice :p
07:01:16 <cocreature> hyperisco: I’m totally fine with the implementation of fromString to look like you would implement it using a splice. I just don’t want to have to wrap literals in spices when I use them. e.g. with merijn’s lib you have to use $$(validList [1,2,3,4]) (which is the only option today so don’t blame merijn)
07:01:17 <hyperisco> I would have thought to introduce a shorter syntax for checked literals, than qqs that is
07:01:59 <cocreature> I don’t think those instances are common enough that we need to worry about making them particularly simple and short
07:02:25 <exarkun> merijn: before each new clause
07:02:42 <hyperisco> my point is that  "foo"  is going to behave differently depending on whether this extension is enabled or not
07:02:50 <merijn> cocreature: Anyway, I plan to update that library Soon-ish, because we can now derive (finally) Lift instances
07:03:07 <hyperisco> if it is enabled, lets say that is a compile error, but if it is not enabled that is either a runtime error or not depending on whether it is evaluated
07:03:08 <merijn> exarkun: Doesn't work for cases where, for example, your select list is very long
07:03:42 <hyperisco> and there is zero warning if you intended to check literals but forgot to turn on the extension
07:04:37 <hyperisco> whereas if you had an explicit syntax for checked literals, now it is a syntax error without the extension enabled
07:04:50 <hyperisco> and furthermore, you can distinguish between checked and unchecked literals in the same file
07:05:40 <cocreature> hyperisco: one easy option would be to just add an additional class and have two mutually exclusive extensions, like OverloadedStrings and ValidatedOverloadedStrings or whatever
07:06:39 <hyperisco> that could work
07:06:57 <hyperisco> then there is another question… does it inline the evaluation of  fromString x
07:07:31 <hyperisco> in the case of regex strings, I really did want those inlined, but it isn't clear that you always would
07:08:08 <cocreature> you can just leave it up to the TH validation code to decide that
07:08:33 <hyperisco> another one size fits all approach eh? :P
07:23:49 <Putonlalla> Does Nikita Volkov hang around here?
07:23:58 <cocreature> Putonlalla: I don’t think so
07:25:00 <cocreature> Putonlalla: his email is on his website
07:25:07 <cocreature> or on his github
07:25:37 <Putonlalla> I need to bother him about an issue that was supposed to be resolved "tomorrow" two years ago.
07:25:48 <cocreature> hasql?
07:26:02 <Putonlalla> No, `base-prelude`.
07:26:07 <cocreature> ah
07:26:14 <cocreature> just comment on the issue?
07:26:28 <Putonlalla> I guess that works too.
07:33:56 <merijn> hmm, so any suggestions how to make pattern matching 6 or so list elements at the same time "not ugly"?
07:36:21 <byorgey> merijn: don't do it?
07:36:38 <merijn> byorgey: I wouldn't if I had any choice
07:36:40 <w1n5t0n> hey, has anyone here used hsndfile to read/write audio files?
07:37:13 <merijn> byorgey: SQL query results are returned as list results per row
07:37:43 <byorgey> merijn: include some inline images of some mountains overlooking a lake.  Then no one will notice the pattern match
07:37:49 <merijn> >.>
07:42:26 <merijn> byorgey: Ah, my code's so pretty and relaxing! http://lpaste.net/4782666016486326272
07:43:46 <merijn> If anyone has clues to make that less likely to cause eyebleading, I'm all ears >.>
07:43:51 <nullie> merijn: make it vertical?
07:43:54 <merijn> s/eyebleading/eye-bleeding
07:44:18 <cocreature> pattern PTS bs = PersistByteString bs
07:45:18 <parsnip> i'm a newb, with no pen and paper, but do records help here?
07:48:08 <hyperisco> parsnip, do records help with what?
07:48:23 <parsnip> ugly pattern matching
07:48:33 <parsnip> *in that particular case
07:49:05 <merijn> parsnip: Only if I could somehow get it to return a record instead of that list, which I sadly can't >.>
07:50:11 <byorgey> merijn: lovely!
07:51:47 <maximp> !lista
07:51:56 <maximp> !ciao
07:52:02 <maximp> !ciao
07:52:06 <byorgey> merijn: how's that? http://lpaste.net/4782666016486326272
07:52:30 <lyxia> also add a view pattern to the pattern synonym
07:52:31 <cocreature> byorgey: impressive ascii art skills!
07:52:31 <merijn> byorgey: For a second I was hopeful that was going to be useful >.>
07:53:04 <byorgey> cocreature: thanks!
07:53:56 <maximp> !lista
07:54:05 <cocreature> maximp: what exactly are you trying to do?
07:54:50 <hyperisco> with lens, how can I get two different fields at once?
07:55:02 <hyperisco> I am reading that is not possible, but it seems kind of absurd
07:56:25 <lyxia> hyperisco: one problem is to prevent accessing the same field twice and setting it to two different values
07:56:30 <cocreature> hyperisco: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Unsound.hs#L61 but I don’t think it’s in a released version
07:56:40 <c_wraith> (1, 2) ^.. _1 <> _2
07:56:47 <c_wraith> err
07:56:56 <c_wraith> > (1, 2) ^.. _1 <> _2
07:56:58 <lambdabot>  error:
07:56:59 <lambdabot>      • Couldn't match expected type ‘[a]’
07:56:59 <lambdabot>                    with actual type ‘(a0 -> f0 b0) -> s0 -> f0 t0’
07:57:07 <c_wraith> ah, drat
07:57:09 <hyperisco> I am deep in a structure and I want to work on two different fields
07:57:14 <hyperisco> I get the setting problem, but I am not setting
07:57:29 <c_wraith> anyway, you can use <> with folds
07:57:51 <Taneb> :t magnify
07:57:53 <lambdabot> Magnify m n b a => LensLike' (Magnified m c) a b -> m c -> n c
07:57:54 <c_wraith> as long as you don't set, it works fine.
07:58:17 <Taneb> :t magnify _1 ((,) <$> view _1 <*> view _2)
07:58:18 <lambdabot> (Functor (Magnified m (a1, a2)), Field2 b b a2 a2, Field1 b b a1 a1, Field1 s s b b, Magnify m n b s) => n (a1, a2)
07:58:32 <Taneb> > magnify _1 ((,) <$> view _1 <*> view _2) (('a', 'b'), 5)
07:58:34 <lambdabot>  ('a','b')
07:59:11 <Taneb> hyperisco: you can use magnify to get a reader monad for deep into the structure
07:59:12 <c_wraith> > (1, 2) ^.. (_1 <> _2)
07:59:14 <lambdabot>  [1,2]
07:59:18 <c_wraith> there.
07:59:32 <c_wraith> it was just a precedence error!
07:59:42 <hyperisco> Taneb, thanks
07:59:46 <hyperisco> c_wraith, I will look at that too
08:00:41 <Boomerang> merijn: Did I just overwrite your lpaste? I thought edit would add another version... Regardless there is my sugestion for going vertical in your pattern matching
08:00:56 <Boomerang> http://lpaste.net/4782666016486326272
08:01:06 <c_wraith> Boomerang, it's "annotate" that adds another version
08:01:16 <hyperisco> though I am using profunctor lenses… have to figure out how that translates
08:01:18 <Boomerang> Ah sorry about that :/
08:01:23 <c_wraith> edit leaves history at least, so the original can still be found
08:01:30 <Boomerang> I assumed it was imutable
08:02:48 <siwica> Is there some sort of a documentation for the checkers library by Conal Elliott other than the stuff on hackage?
08:03:21 <c_wraith> hyperisco, oh. well, the <> version depends on the monoid instance for functions. to work with profunctor optics, it would need similar monoid instances for every concrete profunctor used.
08:04:24 <c_wraith> siwica, have you checked his blog? that's where Conal puts most of his in-depth thoughts on his libraries
08:04:53 <c_wraith> siwica, also, he tends to hand out in here. heh. speak of the devil.
08:05:15 <c_wraith> conal, siwica was asking about documentation for checkers
08:05:42 <ventonegro> If you say "conal" three times...
08:08:11 <siwica> c_wraith: Ok, I will dig into his blog :)
08:08:44 <hyperisco> :t _1
08:08:45 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
08:09:02 <srid> Where can I find the up-to-date PDF version of Typeclassopedia?
08:09:07 <srid> Is this up-to-date? https://wiki.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
08:09:23 <hyperisco> :t zoom
08:09:24 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
08:09:28 <merijn> srid: I don't expect it to have changed much in, say, a decade, so...
08:09:43 <merijn> srid: I wouldn't worry too much about "up-to-date"
08:10:00 <Taneb> hyperisco: magnify : Reader :: zoom : State
08:10:20 <Taneb> merijn: well, AMP hit relatively recently
08:10:35 <hyperisco> Taneb, I apparently don't have a magnify D:
08:10:39 <merijn> Taneb: But typeclassopedia discussed the theoretical hierarchy anyway
08:10:48 <Taneb> merijn: true
08:10:52 <srid> merijn: Hmm, just in last year there were some significant changes (including addition of MonadFail): https://wiki.haskell.org/index.php?title=Typeclassopedia&diff=62193&oldid=61602
08:10:59 <merijn> Taneb: So at worst it'll say "applicative isn't a superclass in Haskell, despite theoretically being one"
08:11:21 <Taneb> hyperisco: which lens library are you using?
08:11:48 <hyperisco> Taneb, the one from Purescript
08:12:09 <merijn> srid: MonadFail is a horrible atrocity that doesn't really map to any nice theoretical part of the hierarchy anyway
08:12:15 <Taneb> hyperisco: ah, I'm afraid I'm not familiar with that library or Purescript at all
08:12:19 <hyperisco> they have the Zoom module but no magnify in there
08:12:45 <Taneb> hyperisco: it may be worth contacting the author(s)
08:13:01 <merijn> srid: A lot of the changes there are fairly boring and don't really affect most of the theory discussed in Typeclassopedia
08:13:29 <merijn> srid: So, unless you're particularly to find a method suddenly part of a class while it wasn't before I wouldn't really worry about it too much
08:16:48 <byorgey> srid: there is no up-to-date PDF version.  The wiki version is the canonical one.
08:16:56 <byorgey> if someone wants to make a PDF out of it, be my guest.
08:17:21 <srid> byorgey: There is https://github.com/ehamberg/typeclassopedia-md - last updated a few months ago.
08:18:32 <byorgey> srid: and I disagree with merijn somewhat.  It's true that a lot of the high-level ideas are the same but quite a few details have changed.  If you read an outdated version you are going to be struggling to try out examples and such because of changes to the standard libraries
08:19:22 <byorgey> srid: cool, so you could easily e.g. use pandoc to convert that to LaTeX and then compile to a PDF.
08:21:14 <srid> Ya, that repo has a makefile to do just that! F
08:21:25 <byorgey> great =)
08:21:32 <byorgey> hmm, I really ought to add Bifunctor
08:23:46 <siwica> c_wraith: Hm, unfortunately I was not able to find anything on his blog. The term "checkers" even didn't give a single result. Hm, maybe he answers here.
08:27:32 <AWizzArd> At http://degoes.net/articles/kill-data I am seeing this line:  (find (\m -> m.id == e.managerId) es)    <= what is this dot in `m.id`?
08:28:43 <Rembane> AWizzArd: It looks like Purescript, then the dot is for getting a record field from a record.
08:28:49 <c_wraith> AWizzArd: based on the other code samples in that article, the code isn't haskell
08:29:30 <metahumor> looking forward to the haskell library that defines the "ego" and "superego" functions
08:29:54 <c_wraith> metahumor: check the acme- section of hackage.  might already be there.
08:30:20 <c_wraith> AWizzArd: actually, the code in that article appears to switch between haskell, purescript, and scala with no indication on any particular code block
08:30:53 <AWizzArd> Rembane and c_wraith: oki thank you. That explains it then. Haven’t studied PureScript yet so I couldn’t parse this.
08:31:16 <Taneb> @quote superego
08:31:17 <lambdabot> Dzlk says: you can make the Id monad somewhat better behaved by wrapping it in SuperegoT.
08:31:20 <Taneb> @quote superego
08:31:21 <lambdabot> Taneb says: <Taneb> @let ego x y z = x z $ y z <Taneb> @let superego x y = x
08:31:38 <Taneb> metahumor: I knew that joke felt familiar ;)
08:31:44 <Akii> :D
08:35:36 <c_wraith> Taneb: I'm not sure what to make of the fact that you can construct the id from only the ego and superego in your system.  What does that say about humanity?
08:36:33 <Taneb> c_wraith: honestly, given those names I think the one that best fits "\x -> x" is ego
08:36:53 <Taneb> I'd rather have id x y = x, these days
08:37:22 <c_wraith> let's just make that change in base.  I'm sure nothing bad could come of it.
08:49:07 <Bowlslaw> Yay, Haskell!
08:50:22 <Putonlalla> Why are you excited? Stop being excited. There's no reason to be excited. Only bad things result from being excited.
08:50:35 <dstolfa> Putonlalla: yeah, like javascript, C and unix
08:50:54 <metahumor> failure at all costs
08:51:57 <batman_> i want to map writeChan chanName (element from list X, element from list Y)
08:52:00 <Bowlslaw> Putonlalla, yay, pessimism!
08:52:15 <dstolfa> Bowlslaw: no! stop with the contradictions
08:52:17 * dstolfa fails to compute
08:52:21 <batman_> how can i do this because i only know how to use map with functions having single argument
08:52:21 <merijn> :t mapM_ -- batman_
08:52:23 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
08:52:34 <Bowlslaw> dstolfa computer confirmed
08:52:40 <merijn> oh, you mean the partially applied function
08:52:51 <merijn> batman_: You can just do "map (writeChan chanName)"
08:53:00 <merijn> batman_: Although you'll probably want mapM
08:54:10 <batman_> merijn : i did go through function definitions of mapM & mapM_ but i couldn't understand can you please explain a bit
08:54:51 <merijn> batman_: writeChan is a function "Chan a -> a -> IO ()" mapping that with 'map' will give you a list [IO ()] and not actually write anything to the Chan yet
08:55:32 <metahumor> "sequence_ (zipWith (writeChan chanName) xs ys)"?
08:56:14 <batman_> merijn : oh okay, so what's the right way to do it
08:56:39 <merijn> batman_: mapM_ or using sequence_ after the map :)
08:56:42 <metahumor> "mapM_ (writeChan chanName) (zip xs ys)" if writeChan chanName expects a tuple (x,y)
08:56:47 <merijn> :t sequence_
08:56:49 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
08:57:10 <merijn> :t sequence_ `asAppliedTo` ([] :: [IO ()])
08:57:11 <lambdabot> [IO ()] -> IO ()
09:00:35 <batman_> merijn,metahumor : thank you so much guys ! :)
09:22:47 <AWizzArd> Hmm hmm. Again about the post at  http://degoes.net/articles/kill-data    – he brings the example (left "Could not find manager of " <> show e)
09:23:07 <AWizzArd> But would that not be like  ((left "Could not find manager of ") <> (show e)) ?
09:23:31 <AWizzArd> I would say he wanted  (left $ "Could not find manager of " <> show e)
09:24:23 <[exa]> Hm. Monadic lifting of a function of type (a->a->(a,a)) on argument 1 produces a function with type (IO a -> a -> IO (a,a)). If IO would only be required to compute one argument, it would be better to produce a function of type (IO a -> a -> (a,IO a)). The first method is more digestible and captured by liftM2 and similar functions. Is there some name for the second thing?
09:24:48 <[exa]> (ignoring the fact that it can't be an actual function)
09:31:03 <batman_> like python is it possible in haskell a = [0] * 5 which gives [0,0,0,0,0]
09:31:27 <dminuoso> :t replicate
09:31:28 <lambdabot> Int -> a -> [a]
09:33:16 <dminuoso> batman_: And if you want to do that with a list rather than a non-list, then it's: join . replicate n
09:44:25 <batman_> thanks all
09:46:52 <dmwit> > [1..5] >> [0,1]
09:46:54 <lambdabot>  [0,1,0,1,0,1,0,1,0,1]
09:47:40 <Tuplanolla> Is there a package for parsing TeX math and extracting some meaning out of the mess? There's obviously a lot of arbitrariness left for interpretation.
09:51:12 <Anormal_guy> hello, am new to haskell have installed ghci and played a little with the syntax , I have tried to google to see if there is any IDE that can be used to increase productivity and save sometime my efforts are futile, can someone recommend something pls.
09:53:47 <w1n5t0n> Anormal_guy: I recently started using Emacs with a package called intero and I'm super happy with it, Emacs is not the easiest editor to start using but if you plan on learning one thing then I'd go for Emacs :)
09:54:19 <Tuplanolla> I use Vim without any plugins and it's not suffering, Anormal_guy.
09:54:56 <mizu_no_oto> Anormal_guy: from my experience, most Haskellers use vim or emacs along with e.g. ghc-mod and ctags to get some of the nice IDE-like features
09:55:52 <calloc> How do I contrain only the ultimate return value of a function. E.g. foo :: x, such that x can be any function that eventually returns y.
09:56:14 <Cale> calloc: What do you mean by "eventually"?
09:56:18 <Tuplanolla> Check how `printf` is implemented, calloc.
09:56:45 <calloc> Cale: (a -> y) or (a -> b -> y)
09:56:51 <Tuplanolla> You basically need type class instances for both `a` and `a -> a` (modulo some constraints).
09:56:52 <calloc> Tuplanolla: Will do.
09:56:56 <w1n5t0n> Anormal_guy: if you're just starting programming and don't have a strong preference for editors, I'd start with Atom which also has a haskell package that offers a lot of ide-like features
09:58:00 <Cale> calloc: Hmm, could you give more of an idea of what you're trying to achieve? It's hard to actually use such a function, if you don't know what its parameters' types are, then you can't supply parameters.
09:58:10 <njay> how o do reverse of a list?
09:58:20 <Cale> njay: reverse
09:58:24 <Cale> > reverse [1,2,3]
09:58:26 <lambdabot>  [3,2,1]
09:58:51 <Cale> You can't supply arguments, rather :)
09:58:52 <njay> by amkign your own function
09:58:54 <calloc> Cale: I'm just trying to restrict the use of a function a little more.
09:59:21 <njay> by making your own fuction
09:59:28 <mizu_no_oto> Anormal_guy: I've never used it, but there's also Leksah.
09:59:47 <Cale> @src reverse
09:59:47 <lambdabot> reverse = foldl (flip (:)) []
10:00:00 <Cale> that's the cute version, you could also do it recursively
10:00:27 <njay> http://lpaste.net/362756 help me with this string reversal code
10:01:10 <mizu_no_oto> FPComplete had a web-based Haskell IDE, but it seems they discontinued it.
10:01:33 <Anormal_guy> I use Vim,as a text editor,ans am good with it and haskell is my third language after JS & Py,I was curious if there is an IDE just like the Jetbrains Pycharm to help develop codes faster
10:01:38 <Cale> njay: f (x:al) xs
10:01:49 <njay> thanks
10:02:34 <mizu_no_oto> Anormal_guy: I'd honestly recommend getting vim set up nicely for Haskell, then.
10:02:45 <Cale> Anormal_guy: One thing which is pretty useful is ghcid, which is a thing that will load up a file and display any warnings or errors, and reload every time you save.
10:02:46 <Athas> mizu_no_oto: that must have been painful.  It looked like they had put a lot of work into it.
10:02:57 <calloc> Tuplanolla: I looked at printf. I'm not trying to support variable arguments. Just trying to constrain the type of a single argument.
10:03:17 <mizu_no_oto> Athas: I'm sure.
10:03:19 <Cale> Anormal_guy: I usually also use hasktags to get jump-to-identifier working in vim or other editors (lately I've been using Sublime Text)
10:03:47 <Tuplanolla> I have doubts about your use case for this, calloc.
10:04:01 <Cale> calloc: Perhaps just write the code and see what type actually gets inferred
10:04:36 <Cale> calloc: My guess is that either something doesn't make sense, or the function you're trying to write is actually more polymorphic because it doesn't need to ever apply the function in question.
10:04:54 <Cale> (and so it needn't be a function at all)
10:05:01 <njay> @cale : can you explain me the code
10:05:01 <lambdabot> Sorry, look up one word at a time please.
10:05:14 <Cale> njay: So imagine trying to reverse a stack of pancakes
10:05:17 <hyperisco> are Setters supposed to be composed with <<< ? so  over _1 . over traversed . f   for example ?
10:05:31 <hyperisco> :t (over _1 . over traversed .)
10:05:33 <lambdabot> error:
10:05:33 <lambdabot>     The operator ‘.’ [infixr 9] of a section
10:05:33 <lambdabot>         must have lower precedence than that of the operand,
10:05:47 <hyperisco> :t \f -> over _1 . over traversed . f
10:05:49 <lambdabot> (Traversable f, Field1 s t (f a1) (f b)) => (a2 -> a1 -> b) -> a2 -> s -> t
10:06:05 <Cale> njay: One obvious thing you might do is to take the pancake that's on top, and move it to a new pile, and keep moving pancakes to the new pile until you've emptied the original stack
10:06:09 <hyperisco> :t (over _1 . over traversed)
10:06:10 <lambdabot> (Traversable f, Field1 s t (f a) (f b)) => (a -> b) -> s -> t
10:06:29 <calloc> Tuplanolla, Cale: I have left them general and it works out, but I was hoping that restricting the types more would help simplify error messages.
10:06:34 <hyperisco> but isn't there some funky operator for this?
10:06:40 <Anormal_guy> I really appreciate your feed back guys, thank you alot
10:06:44 <njay> cale: how line 2 and line 3 is working?
10:06:54 <Cale> njay: That's basically what this is doing. We're saying that rev xs = f [] xs, where f has as its arguments the contents of the new pile (initially empty), and the contents of what's left of the original list
10:07:33 <Cale> njay: If what's left of the original list is empty, we produce the new (reversed) list as our result
10:08:11 <calloc> Here's what I tried originally: func :: (a -> Foo) -> Parser a -> Parser Foo
10:08:11 <njay> cale: thank you brother
10:08:54 <hyperisco> > over traversed (+1) [1,2,3]
10:08:57 <lambdabot>  [2,3,4]
10:09:13 <calloc> Thinking that 'a' might accept 'b' or 'b -> c'.
10:09:24 <Cale> calloc: well, it will :)
10:09:26 <hyperisco> > (over traversed . over _1) (+1) [(1,2),(3,4),(5,6)]
10:09:29 <lambdabot>  [(2,2),(4,4),(6,6)]
10:09:45 <hyperisco> am I doing it right?
10:09:47 <Cale> calloc: you'll get  func :: ((b -> c) -> Foo) -> Parser (b -> c) -> Parser Foo
10:09:52 <njay> cale: can you helpme withthis code too ?
10:09:54 <njay> http://lpaste.net/362757
10:10:07 <Cale> calloc: but (b -> c) -> Foo isn't the same as b -> c -> Foo, which means b -> (c -> Foo)
10:10:28 <dminuoso> Wow. I hate my life, I spend 2 days tracing my automaton bug constantly producing garbage data into an off-one-one bit error in the one place that I considered too annoying to test, after all it was simple bit arithmetic - nothing you could do wrong there.
10:10:53 <dminuoso> off-by-one striking once again.
10:10:54 <w1n5t0n> how come trig functions like sin aren't defined for Rationals?
10:11:03 <koala_man> haha
10:11:45 <Cale> njay: You're probably going to want to pattern match on l
10:11:52 <Cale> njay: You can do it with a case expression
10:12:00 <dminuoso> w1n5t0n: Because rational is a bad fit? I suspect most implementations use the Taylor series
10:12:19 <Cale> njay: oh, I guess the first guard has already checked if l is null, so it would be safe to use tail
10:12:49 <Cale> njay: (though that's a bit bad style if we don't absolutely need to use tail -- it would be better to pattern match)
10:13:09 <dminuoso> w1n5t0n: Basically no matter how you try, approximating sine is more than just multiplying and dividing.
10:14:45 <w1n5t0n> dminuoso: so would the best workaround be to use fromRational, apply sin, and back toRational?
10:16:20 <njay> cale: what is the code
10:16:24 <njay> explain me with code
10:16:28 <calloc> Cale: data Foo = Foo Int Int; baz :: (a -> Foo) -> Int; baz x = 3; :t baz Foo
10:18:28 <calloc> Tuplanolla: Cale: Noob error. Thanks for your help.
10:18:41 <hyperisco> > over (traversed . _1) (+1) [(1,2),(3,4),(5,6)]
10:18:43 <lambdabot>  [(2,2),(4,4),(6,6)]
10:20:01 <hyperisco> okay so I make the "paths" with function composition
10:20:14 <metahumor> w1n5t0n: trig functions on radians or edegrees?
10:20:35 <metahumor> w1n5t0n: Rational does not include all algebraic numbers. i wish there was an Algebraic
10:21:40 <metahumor> hyperisco: why traversed as opposed to mapped?
10:22:03 <hyperisco> metahumor, I do not know
10:22:28 <dmwit> w1n5t0n: Because there are many rationals whose sin is irrational.
10:23:19 <w1n5t0n> metahumor: on radians preferably, I want(ed) to use Rationals to represent Time in a function of the form "Time -> Double" but not being able to use sine of time is a bit of a dealbreaker
10:23:41 <dmwit> w1n5t0n, metahumor: You might like cyclotomic.
10:23:59 <hyperisco> :t mapped
10:24:00 <lambdabot> (Functor f2, Settable f1) => (a -> f1 b) -> f2 a -> f1 (f2 b)
10:24:12 <dmwit> "The cyclotomic numbers contain the sine and cosine of all rational multiples of pi."
10:24:31 <metahumor> dmwit: wow this takes care of my Algebraic desiratum
10:24:40 <hyperisco> metahumor, what's the difference
10:24:47 <metahumor> :t over mapped -- hyperisco
10:24:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:24:52 <metahumor> :t over traversed
10:24:53 <lambdabot> Traversable f => (a -> b) -> f a -> f b
10:25:36 <metahumor> :t mapped
10:25:37 <lambdabot> (Functor f2, Settable f1) => (a -> f1 b) -> f2 a -> f1 (f2 b)
10:25:38 <metahumor> :t traversed
10:25:40 <lambdabot> (Applicative f2, Traversable f1, Indexable Int p) => p a (f2 b) -> f1 a -> f2 (f1 b)
10:25:53 <hyperisco> so… the type?
10:27:42 <metahumor> hyperisco: "mapped is a setter for everything contained in a functor. You can use it to map over lists, Maybe, or even IO (which is something you can't do with traversed or each)."
10:28:23 <batman_> how can i return sock getSock xChan = do sock <- readChan xChan without using return cause it messes everything up
10:28:26 <hyperisco> so this is like map why not fmap
10:28:32 <metahumor> :t over mapped (+1) `asAppliedTo` (pure 0 :: IO Int)
10:28:33 <lambdabot> IO Int -> IO Int
10:28:34 <metahumor> :t over traversed (+1) `asAppliedTo` (pure 0 :: IO Int)
10:28:35 <lambdabot> error:
10:28:35 <lambdabot>     • No instance for (Traversable IO)
10:28:35 <lambdabot>         arising from a use of ‘traversed’
10:28:53 <metahumor> batman_: what is the type signature you want?
10:29:39 <batman_> sockAddr
10:30:15 <metahumor> i mean of the "getSock" functino
10:30:53 <batman_> Chan -> SockAddr
10:31:00 <EvanR> question, is it possible for ghc to optimize away the fromInteger and fromRational that results from desugaring numeric literals
10:32:48 <metahumor> batman_: is "readChan :: Chan -> IO SockAddr"?
10:41:02 <napping> EvanR: yes, try something like -ddump-rule-firings on a very small file
10:41:06 <hyperisco> hrm, can you filter with lens?
10:41:47 <Tuplanolla> Last time I tried the answer was "yes, but not lawfully", hyperisco.
10:41:50 <metahumor> > [1..10]^..folded.filtered even
10:41:52 <lambdabot>  [2,4,6,8,10]
10:42:11 <dminuoso> dmead: the choice of monad seems a bit extreme
10:42:28 <dminuoso> Oh they left.
10:42:30 <hyperisco> what about using a prism though?
10:42:48 <dminuoso> > [1..5] *> "foo"
10:42:50 <lambdabot>  "foofoofoofoofoo"
10:43:08 <metahumor> hyperisco: what do you mean?
10:43:25 <Tuplanolla> The same answer applies.
10:43:27 <napping> hyperisco: the lens library includes things for filtering.
10:43:28 <hyperisco> discard elements which do not match the prism
10:44:08 <hyperisco> catMaybes = f _Just    where f is the missing magic
10:44:18 <hyperisco> maybe  f _Just id
10:44:49 <metahumor> > [0,3,2,1,5,4,3,2,1] ^.. traversed . ifiltered (\i a -> i <= a)
10:44:52 <lambdabot>  [0,3,2,5]
10:45:13 <napping> but it's not quite correct to make a "lens" that allows you to modify the things targeted by your filter
10:45:26 <hyperisco> okay but that is a boolean predicate again
10:45:28 <napping> (at least if you can modify them so they no longer pass the filter)
10:46:18 <dminuoso> Wow. So "foo" and ['f', 'o', 'o'] are actually different things internally o.o
10:47:36 <metahumor> ???
10:47:44 <hyperisco> I guess that doesn't make sense with the type of a prism
10:49:15 <metahumor> hyperisco: you might be able to using something like "re" although i'm not great with prisms
10:49:54 <hyperisco> seems much of what I want to do doesn't relate to lens
10:53:05 <amalloy> dminuoso: how did you come to that conclusion?
10:54:01 <hyperisco> the optic type would be something like  Optic p (f s) (f b) a b
10:54:21 <hyperisco> so  p a b -> p (f s) (f b)
10:54:35 <hyperisco> take the a's out of s, and replace with b
10:55:35 <hyperisco> f needs to be something like Foldable Alternative
10:56:30 <hyperisco> or Filterable, if that is a class
10:56:53 <dminuoso> amalloy: I played around with `-ddump-simpl -ddump-ds`
10:57:26 <dminuoso> amalloy: I didn't fully understand the details, but it seems like "foo" internally ends up as some CString type
10:58:10 <hyperisco> but I don't think a prism is going to work with that… frustrating
10:58:31 <phadej> I try to read backlog but I don't really understand what you are trying to do
10:58:43 <phadej> [Just 1, Just 2] ^.. traverse . _Just
10:58:46 <phadej> > [Just 1, Just 2] ^.. traverse . _Just
10:58:48 <lambdabot>  [1,2]
10:58:53 <phadej> > [Just 1, Nothing, Just 2] ^.. traverse . _Just
10:58:55 <lambdabot>  [1,2]
10:59:02 <phadej> Am I close?
10:59:03 <hyperisco> okay, well I am trying to do that
10:59:24 <hyperisco> so is the magic this ^.. operator?
10:59:44 <dminuoso> hyperisco: flipped toListOf
10:59:55 * shapr hops cheerfully
11:00:05 <hyperisco> yeah but I haven't a clue what that is
11:00:15 <hyperisco> don't know anything about Fold yet
11:00:25 <dminuoso> > (1,2) ^.. both
11:00:27 <Tuplanolla> One of the most essential parts of `lens`, hyperisco.
11:00:27 <lambdabot>  [1,2]
11:00:52 <hyperisco> :t (^..)
11:00:53 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
11:00:58 <hyperisco> hm, that is specific to lists though
11:01:10 <dminuoso> hyperisco: hence the "toListOf" name
11:02:46 <hyperisco> okay
11:06:27 <hyperisco> think I am just going to abandon lens here…
11:07:41 <dfeuer> phadej: still struggling with that whole Conjoined business in my holesOf reimplementation.
11:08:05 <hyperisco> so then what if I have  [(1, Just "foo"), (2, Just "bar"), (2, Nothing)]  and I want to get  [["foo"],["bar","bar"]]
11:08:34 <dfeuer> How do I capture the indices (if there are indices)? How do I recover them (if they're there)? This is very confusing.
11:08:47 <hyperisco> f (n, Just s) = replicate n s
11:09:14 <shapr> I like language-c, is there a language-cpp ?
11:09:19 <hyperisco> the problem here being, how do I remember the first element of the 2-tuple as I prism on the second element?
11:09:29 <hyperisco> while doing this toListOf thing?
11:09:36 <amalloy> dminuoso: i don't agree with your conclusion that "foo" and ['f','o','o'] are different internally. the compiler may go through different processes to create them, but by the time your program sees the values they are the same thing
11:09:50 <shapr> perhaps language-c works for cpp just as well and I'm confused?
11:10:18 <dfeuer> amalloy: RULES can make them different.
11:10:49 <amalloy> dfeuer: i don't know enough about RULES to understand what you're talking about
11:11:16 <phadej> hyperisco: what you want isn't really a job for lens anymore
11:11:28 <phadej> or "lens alone", if you really want to use lens anyway :)
11:11:46 <hyperisco> I am just used to writing explicit recursion to dig through data in this way
11:12:02 <hyperisco> and so now I am trying to use lens in these spots…
11:12:16 <amalloy> though maybe i can find out by reading https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/src/GHC.CString.html
11:12:22 <phadej> you can plug "manual" things with
11:12:24 <phadej> : to
11:12:28 <phadej> :t to
11:12:29 <lambdabot> (Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
11:12:47 <phadej> hyperisco: a sec
11:13:05 <dfeuer> amalloy: string literals are compiled to something vaguely like   fromByteArray <the_actual_string>, although the function isn't actually called that. Rewrite rules can recognize that and get the actual byte array, preventing it from ever being realized as a string.
11:13:15 <dminuoso> amalloy: Fair enough, I was just looking at this: https://gist.github.com/dminuoso/e374b0e1dde689fd8df73c390de083bd
11:13:21 <dminuoso> Which looked kind of different..
11:13:38 <phadej> hyperisco: e.g.
11:13:39 <phadej> > [(1, Just "foo"), (2, Just "bar"), (2, Nothing)] ^.. folded . to (\(n, mx) -> maybe [] (replicate n) mx) . folded
11:13:42 <lambdabot>  ["foo","bar","bar"]
11:13:47 <dfeuer> phadej, dminuoso, can either of you spare a few minutes to help me with my holesOf thing?
11:14:01 <amalloy> dminuoso: right, that's what i looked at too. notice that it's not saying that "foo" is a CString, but that "foo" is the result of calling unpackCString on a CString
11:14:02 <dminuoso> dfeuer: I think you are really asking the wrong person. :)
11:14:04 <phadej> which does different thing than what you want, but that's how I use lens
11:14:13 <dfeuer> I have stared at this stuff for quite a while without making any real progress.
11:14:18 <amalloy> dminuoso: dfeuer is explaining, not asking
11:14:30 <amalloy> oh
11:14:31 <dfeuer> amalloy: I'm explaining one thing and asking about another!
11:14:32 <amalloy> i missed that
11:14:58 <dfeuer> amalloy: if you know stuff about lens implementation, your help would be appreciated as well/alternatively.
11:15:02 <amalloy> my client colors your nickname poorly when you're not addressing me, so i missed it :P
11:15:14 <amalloy> dfeuer: no, not a thing. i barely know how to use lens
11:15:37 <metahumor> > (concat . catMaybes) (over traversed (\(n,s) -> replicate n <$> s) hxs)
11:15:38 <hyperisco> phadej, I feel like something with ReaderT could work… maybe that magnify stuff
11:15:39 <lambdabot>  ["foo","bar","bar"]
11:16:01 <metahumor> "over traversed" is just "map" here
11:16:06 <phadej> dfeuer: right now is a bad moment, could you post some examples to the issue, where one a) does what you want for (->), i.e. non-indexed case, b) example where trivial approach isn't lazy enough and c) something else
11:16:20 <dfeuer> amalloy: I know almost nothing about *using* it. Implementing basic lenses is usually a pretty simple matter of following types, but this indexed stuff is pretty complicated.
11:16:42 <phadej> dfeuer: when I saw that issue, my first reaction was "dfeuer tries to nerd-snip someone"
11:16:45 <dminuoso> amalloy: Well the underlying representation is still a CString, that's what I was trying to get at.
11:16:51 <phadej> dfeuer: you have succeed
11:17:25 <dfeuer> phadej: laziness isn't the issue for the holesOf implementation. I've solved that. I just need to know how to deal with the indexed case. I can paste the code that handles the non-indexed, but it doesn't chhange much from what I've already pasted.
11:17:28 <amalloy> dminuoso: what do you mean, the underlying representation? once the unpack call has occurred, the original CString is nowhere to be found (unless, as dfeuer points out, a rewrite rule can prevent it from happening at all)
11:17:37 <napping> dminuoso: that's more like the implementation in code. If you use it as String, the upackCString thing will build a linked list in memory just like ['f','o','o']
11:17:41 <hyperisco> yeah I just can't do it… have to spend a weekend learning more about lens
11:17:45 <dfeuer> For the "shapely holesOf", I'm very far from any real implementation of even a non-indexed version.
11:18:05 <hyperisco> which is really hard to come by nowadays D:
11:18:22 <phadej> dfeuer: but you have to reaturn [Pretext p a a t] and now you have [Context a a t], am I right?
11:18:55 <amalloy> man, reading ghc internals is weird. there are so many different rules and all this magic hash stuff
11:18:59 <dfeuer> phadej: yes, but I have written the code to fix that in the non-indexed case. It's not actually too hard, it turns out. But I have no clue about the indexed case.
11:19:15 <Tuplanolla> Luckily programmatic lenses are still easier than physical lenses.
11:19:30 <napping> dminuoso: the advantage is with RULES, if you have some other "foo :: String -> Foo" and an optimized "unsafeFooOfCString :: CString -> Foo", you can have a rule for "foo (unpackCString a)"
11:20:15 <phadej> dfeuer: ok, so now I understand what's the problem. So we need to make Grump profunctor aware in https://github.com/ekmett/lens/issues/788
11:20:50 <phadej> dfeuer: I'd still like to see an example which requires the laziness, so we don't break it later
11:20:53 <metahumor> Tuplanolla: has anyone written a Fresnel type?
11:21:17 <Tuplanolla> What would it embody?
11:21:35 <johnw> is that a lens joke?
11:21:42 <Tuplanolla> Yes.
11:22:33 <dfeuer> phadej: the extra laziness is really all about list-like things. A good example is  holesOf traverse ([1..10]++undefined), where we want to get 10 Pretexts, each of which can deliver the first ten elements of a modified list.
11:24:11 <metahumor> a highly focusing prism, like turn [Either a a] into [Either () a] --- [Left 1, Right 2] --> [Right 1, Right 2]
11:25:38 <phadej> dfeuer: I see, thanks
11:26:22 <napping> dminuoso: I'm not sure how Fractional stuff works, you can get a literal like 1.1 to show up either as an unboxed float 1.1# or as some rational value in the code, and switch between them by wrapping an expression in another function that's optimized by rules
11:26:26 <napping> I suspect it's built in
11:29:22 <hyperisco> in about 3 minutes I write the whole thing leveraging the list monad
11:29:56 <monochrom> Yes list monad is cool. (Equivalently list comprehension.)
11:30:22 <gjngih> What up my homies
11:48:51 <Franciman> Hi
11:49:33 <gjngih> What's happening
11:51:00 <Franciman> I have a function that downloads some files from internet and puts the files in a given directory D. Now the user can concurrently change the directory D and I want that after the directory is changed, all the files downloaded are moved to a new location
11:51:09 <Franciman> what's the best way to do this, in your opinion?
11:51:35 <Franciman> I was trying to acquire an MVar containing the directory and release it when a single file is saved
11:51:40 <sQVe> What's the "best" plugins for Haskell on Vim?
11:52:13 <Franciman> so that I can be sure that when I move the files to a new location none is left because it was saved while I was moving stuff
11:52:32 <sQVe> Semi intelligent autocomplete would be great for instance.
11:52:53 <Franciman> sQVe, I think for that you could try haskell-ide-engine which uses language server protocol
11:52:59 <Franciman> so install a language server protocol plugin for vim
11:53:03 <EvanR> Franciman: they are changing the dir by directly manipulating the file system?
11:53:17 <EvanR> while your poor program is running
11:53:21 <Franciman> yes
11:53:23 <Franciman> :P
11:53:28 <Franciman> ah no
11:53:28 <EvanR> lordy
11:53:35 <Franciman> sorry I misinterpreted
11:53:42 <Franciman> just change the path where to save data
11:53:48 <kadoban> sQVe: intero seems popular. I'm not exactly sure what its capabilities are though.
11:53:49 <Franciman> for example first I say: save everything here:
11:53:58 <Franciman> /home/stuyff
11:54:02 <kadoban> Oh, only neovim though AFAIK
11:54:04 <EvanR> delay the update of the path until downloads are done?
11:54:17 <EvanR> not very responsive i guess
11:54:33 <gjngih> Offtopic but why should I switch to neovim
11:54:36 <Franciman> one idea could also be to save all files in a tmp dir and then move them in the selected location
11:54:48 <EvanR> that sounds about right
11:54:54 <sQVe> Franciman: Allright, so HIE is the way to go?
11:55:07 <EvanR> a lot of downloader libs do that
11:55:23 <EvanR> the temp dir it uses is none of your business
11:55:29 <EvanR> then you can move to the dest later
11:55:32 <Franciman> yes
11:55:37 <Franciman> and take an mvar
11:55:51 <Franciman> so that everything happens atomically with respect to user changing dir
11:56:00 <Franciman> also mv is quite fast
11:56:03 <Franciman> so it's also responsive
11:56:20 <Franciman> sQVe, to be honest I didn't try it
11:56:24 <Franciman> but looks cool
11:56:35 <Franciman> ASAP kakoune has it's LSP client I'll definitely try it
11:56:35 <sQVe> Franciman: Epic advice :D
11:56:40 <Franciman> ahah
11:56:42 <Franciman> sorry
11:56:46 <Franciman> I just read docs
11:56:50 <sQVe> ^^ It's fine.
11:57:14 <sQVe> I've been using HIE on VSCode happily. It's been a bit flaky at times but other than that good.
11:57:30 <Franciman> I don't know of better alternatives
11:57:32 <sQVe> Just wanted to probe a bit if there are better options on Vim
11:57:34 <Franciman> intero may be one
11:57:42 <sQVe> as I made the transition just a couple of days ago
11:57:45 <Franciman> but is there any version for vim?
11:57:57 <sQVe> For intero?
11:57:59 <Franciman> yes
11:58:04 <sQVe> Yeah there is.
11:58:05 <Franciman> a vim script to interface with intero
11:58:11 <Franciman> ah you could also try it, I guess
11:58:16 <systemfault> I've used HIE on neovim, works okay
11:58:24 <sQVe> :thumbs-up:
11:58:27 <amalloy> i found https://github.com/parsonsmatt/intero-neovim but i don't know the difference between vim and neovim
11:58:40 <sQVe> I'll start off with HIE.
11:58:45 <sQVe> amalloy: I'm using neovim
11:58:50 <Franciman> EvanR, thanks for your help
11:59:12 <sQVe> The only real difference is how neovim handles things async, or atleast has the possibility to do so
11:59:33 <nickrandom> Hi guys! Do you have a guide to learn haskell?
11:59:47 <leshow> Whenever I use Text, I invariably end up with a lot of 'pack' calls... I know it's O(n), but I'm wondering about allocation. Am I paying the cost of allocating the initial string as well as the cost of allocating Text and converting? Every time I use a string?
12:00:18 <napping> Are the arguments to pack literals?
12:00:25 <EvanR> lazily generated Strings are generated lazily
12:00:27 <napping> 'pack "abcd"' gets optimized
12:01:01 <EvanR> so you wouldnt pay for the total memory at once, and maybe you can fuse each char away
12:01:29 <leshow> napping: but if it's something received at runtime, then I'm definitely paying all those costs?
12:01:58 <EvanR> received how
12:02:01 <leshow> EvanR: That's what I was curious about, I know Vector does fusion if you chain combinators together, I'm wondering if the runtime is able to skip intermediate steps
12:02:43 <leshow> EvanR: Say from user input or something
12:02:47 <EvanR> a runtime, in IO, shouldnt you really be receiving ByteString
12:02:56 <EvanR> small input?
12:03:07 <leshow> I'm just talking hypothetically, I don't have an example.
12:03:31 <EvanR> someone typing a command at the rate of 1/50 Hz ...
12:03:37 <EvanR> not a performance issue
12:04:29 <leshow> I'm not saying I have performance issues, I just wanted to know what was going on under the hood
12:04:57 <EvanR> when you get a list from IO, and you didnt go with lazy IO, you will have to materialize the whole list in memory first
12:05:07 <EvanR> before continuing
12:05:32 <EvanR> and String is a list
12:06:10 <leshow> So unless the literal is compiled into the binary, there isn't really a mechanism for it to skip the String step I guess?
12:06:26 <EvanR> i dont agree with that
12:06:39 <EvanR> lists can be gotten other ways besides IO and being baked in
12:07:19 <EvanR> if you have a String generation algorithm, you can convert it to lazy Text, lazily
12:08:26 <EvanR> would be prudent for a lot of text, you could also generate the lazy text chunks directly
12:09:31 <EvanR> leshow: also... ByteString and Text both have input IO actions, mirroring the getLine :: IO String
12:09:31 <leshow> I've always just picked the Strict varieties of data structures without evaluating too much
12:09:51 <leshow> Oh yeah, good point
12:11:16 <EvanR> going to guess the strict ByteString one is fastest
12:19:31 <nxnxjxjx> What programming language mainframes are coded in?
12:20:17 <EvanR> does anybody have a reference to the SPJ quote something like "haskell was discovered, not invented"
12:20:46 <danilo2_> Hi guys! I want to make a magic datatype, which will provide type-level list of available constructors (something like `MagicData '[X,Y,Z]) and then you should be able to pattern match on 3 associated constructors (they can be defined using GADTs / Type families / whatever). Is there any way to define it in Haskell? I was trying to find a way, but I dont see any. Its important to me to utilize the pattern match mechanism to discov
12:22:37 <jle`> does it have to be magic?
12:22:43 <suzu> why can't i do this?
12:22:44 <suzu> http://lpaste.net/7510572421041094656
12:22:45 <danilo2_> of course not!
12:22:57 <jle`> danilo2_: also i think freenode might have cut off the end of your message
12:22:57 <suzu> Could not deduce (Exception e0), like why does GHC care?
12:23:10 <lyxia> danilo2_: this was posted today and seems relevant http://www.hsyl20.fr/home/posts/2018-02-21-heterogeneous-collections.html
12:23:13 <jle`> suzu: that's how typeclasses work
12:23:21 <danilo2_> jle`: oh, the end was: "Is there any way to define it in Haskell? I was trying to find a way, but I dont see any. Its important to me to utilize the pattern match mechanism to discover non covered pattern matches"
12:23:22 <jle`> suzu: GHC has to know which method to "compile"
12:23:48 <jle`> suzu: every typeclass instance has a distinct implementation of its methods
12:23:50 <suzu> it needs to know which Exception to get the typeclass-dict for it and pass it to throwTo?
12:24:07 <suzu> (under the hood)
12:24:40 <Athas> nxnxjxjx: everything.
12:24:41 <jle`> danilo2_: there's types like Sum in type-combinators http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Sum.html
12:25:17 <jle`> suzu: not sure what is going on under the hood exactly, but i think it just has to pick what implementations of the Exception methods to use/compile
12:25:23 <jle`> otherwise what is it even going to compile
12:25:25 <glittershark> Hey all - I know TypeInType ostensibly lets you define kind-classes now - has anyone successfully defined a functor on kinds? I tried at http://lpaste.net/362764 but couldn't get it to compile
12:25:35 <pdxleif> Is there such a thing as a "real-keyed map", where the keys can be a range of reals? Basically I just want to divide the range negative 180 degrees through positive 180 degrees into four quadrants, for purposes of checking the current orientation of my laptop from the accelerometers and placing it in that quadrant.
12:25:42 <suzu> hmm, i see. so how can i get this to work?
12:25:44 <glittershark> I feel like I'm mostly just mixing up the syntax of indexed data families
12:25:49 <pdxleif> Or do I just chain a bunch of if-statements to check the range?
12:26:01 <danilo2_> lyxia, jle` Thanks, Ill look int othe links and Ill write back!
12:26:33 <jle`> suzu: you can pick what sort of exceptions you want to catch and throw
12:26:38 <jle`> and use a type annotation
12:26:49 <suzu> i can't catch them all?
12:26:50 <jle`> glittershark: what is the compile error?
12:27:00 <jle`> suzu: you can catch all exceptions using SomeException
12:27:11 <jle`> but that's generally considered a "Bad Idea"
12:27:28 <pdxleif> I guess there's Data.Ix.inRange
12:27:30 <glittershark> jle`: expected kind `k`, but `k` has kind `*`
12:27:33 <suzu> i'm doing something a bit.. exceptional here
12:27:36 <EvanR> pdxleif: so uh, an interval map
12:27:43 <glittershark> in the `l :: f k` in the data family declaration
12:27:44 <jle`> glittershark: on what line
12:27:50 <jle`> ah
12:27:52 <glittershark> line 12 col 38
12:27:52 <suzu> thread A is running a C function that runs a haskell function B. i want B's exceptions to be thrown back to thread A
12:27:53 <glittershark> 39
12:28:35 <glittershark> the specific GADT for FmapMaybe works just fine
12:28:38 <pdxleif> EvanR: Oh neat - thanks!
12:28:41 <jle`> suzu: what sort of exceptions would it make sense to throw back?
12:28:44 <glittershark> but I can't get the data family working
12:28:58 <danilo2_> ok, lyxia , your solution will not work, look, the implementation of Variant is `data Variant (l :: [*]) = Variant {-# UNPACK #-} !Word Any` which means that when pattern matching GHC will not wanr if I dont cover all cases
12:29:04 <glittershark> believe it or not, this is for production code lol
12:29:05 <suzu> all of them
12:29:14 <suzu> i would like to catch both sync and async exceptions and throw them back
12:29:21 <suzu> sorry, not catch.
12:29:21 <danilo2_> lyxia: and this is crutial for me (I can create different hetero-containers by myself, but I watn this pattern match checking)
12:29:30 <suzu> i want to cleanup after both and throw them upwards
12:29:33 <suzu> no catching
12:29:47 <EvanR> then use bracket or finally or onException
12:29:54 <suzu> right. i am using onException
12:29:55 <jle`> suzu: the typical reply is "probably not actually all of them", but it's definitely one of those things were if you do it, you're expected to know all the things that could go wrong
12:30:25 <EvanR> yeah that is for both sync and async exceptions
12:30:38 <jle`> glittershark: hm, does it work with PolyKinds enabled?
12:30:45 <jle`> though i think TypeInType implies polykinds
12:31:00 <glittershark> yeah it does
12:31:02 <glittershark> and no it doesn't
12:31:03 <glittershark> ie
12:31:05 <glittershark> sorry
12:31:13 <glittershark> it doesn't work, but TIT does imply PKs
12:31:18 <jle`> heh
12:31:48 <jle`> and i'm guessing it still has an error with lines 14-17 taken out?
12:31:54 <danilo2_> jle`: The sum type will actually do the trick but its not applicable here. It will require me t pattern match on something like `InR(InR(InR(InL ...)))` instead of just a constructor. I do not want to remember the inner layout of that. In fact I should mention that in my question. We can create GADTs that woudl allow us to pattern match using something like that, but I really want just to allow users to just patter nmatch on somet
12:31:57 <suzu> realistically the biggest thing i care about here is an IOException
12:32:06 <EvanR> what is the problem?
12:32:10 <suzu> but i'd like to throw them all ust for now but i can't glue these together
12:32:15 <jle`> danilo2_: oh yeah no that's weird
12:32:26 <jle`> suzu: sure at this point it's up to you
12:32:34 <jle`> you can specify what you want using a type annotation
12:32:34 <suzu> i don't understand why this won't work still
12:32:41 <jle`> which might be more convenient with ScopedTypeVariables
12:32:47 <suzu> both sides are existentialized with Exception e =>
12:32:47 <jle`> \(e :: IOException) -> ...
12:32:58 <danilo2_> jle`, lyxia : so unfortunatelly neither of these solutions solve this :(
12:33:02 <suzu> so they.. should.. match
12:33:10 <lyxia> danilo2_: vinyl's CoRec is like Sum but comes with extra combinators to simulate a more natural pattern-matching style https://hackage.haskell.org/package/vinyl-0.7.0/docs/Data-Vinyl-CoRec.html
12:33:12 <jle`> neither side is existentialized
12:33:19 <EvanR> so you are trying to catch after all
12:33:25 <lyxia> danilo2_: (see "match")
12:33:34 <jle`> it's actually the oppposite of existentialized, heh
12:33:38 <jle`> anti-existentialized
12:33:41 <suzu> oh what
12:33:48 <jle`> they are universally qualified
12:33:50 <EvanR> suzu: you do want to catch... or cleanup and rethrow
12:33:52 <glittershark> co-existential?
12:33:59 <lyxia> danilo2_: but if you absolutely need to use the "case" construct, I'm not sure there's an extensible solution.
12:34:05 <glittershark> ...is universal the dual of existential? probably
12:34:14 <EvanR> yep
12:34:28 <glittershark> I mean like
12:34:29 <jle`> *quantified (?)
12:34:31 <glittershark> categorically speaking
12:34:41 <danilo2_> lyxia: I know we can simulate match. The whole point here for me is to use the GHC built-in checking if all matches are covered
12:34:54 <jle`> suzu: think of it as the same situation as 'show . read'
12:34:54 <glittershark> hooo boy match totality
12:34:59 <danilo2_> lyxia: unfortunately any function that is not case will not provide it
12:35:16 <jle`> show and read are both universally quantified over a Show a type
12:35:22 <jle`> but the final type is String -> String
12:35:27 <jle`> how is GHC supposed to know what type goes in between?
12:35:45 <suzu> ahh i see
12:35:56 <EvanR> glittershark: i would tell you, but my brain exploded up reading the relevant page on nlab
12:35:58 <jle`> when you use 'read', you have to tell GHC what type you want to read into
12:36:00 <EvanR> upon
12:36:05 <glittershark> EvanR: haha
12:36:22 <glittershark> I feel like I just want ekmett to work some ekmett magic on this
12:36:24 <jle`> that tells GHC which instance of read it will compile
12:36:33 <jle`> same for withException
12:36:35 <jle`> :t withException
12:36:36 <metahumor> EvanR: have you seen "mLab">
12:36:37 <lambdabot> error:
12:36:37 <lambdabot>     • Variable not in scope: withException
12:36:37 <lambdabot>     • Perhaps you meant one of these:
12:36:42 <metahumor> EvanR: https://cemulate.github.io/the-mlab/
12:36:43 <jle`> @let import Control.Exception
12:36:43 <cugj> EvanR should be the leader of this channel
12:36:44 <lambdabot>  Defined.
12:36:45 <jle`> :t withException
12:36:47 <lambdabot> error:
12:36:47 <lambdabot>     • Variable not in scope: withException
12:36:47 <lambdabot>     • Perhaps you meant one of these:
12:36:57 <jle`> :(
12:37:13 <jle`> but yeah, it is universally quantified, so you have to pick with instance of Exception you want to use, same as 'read'
12:37:29 <jle`> in fact...the analogy is actually kind of pretty strong with read/show
12:37:33 <EvanR> i beg to differ
12:37:39 <eschnett> i want to install stack/ghc on a raspberry pi. it seems i have to bootstrap from an older stack binary (version 1.3 or so). this can't handle the flag name "bytestring--lt-0_10_4". is there an intermediate version i need to install to make things work? which one?
12:37:48 <EvanR> metahumor: hahahahah
12:37:56 <jle`> in withException and in read, the constrained type (Show/Exception) is in the positive position -- it's a value that the function is "giving"
12:38:00 <metahumor> eschnett: upgrade your stack
12:38:11 <jle`> and in throwTo/show, the constrained type is in the negative position -- it's a value that the function is "taking"
12:38:20 <jle`> so the problem is actually exactly the same as for 'show . read'
12:38:45 <eschnett> metahumor: that's the one that fails, "stack install stack" doesn't work.
12:38:54 <jle`> 'read' doesn't know what type of value it's supposed to give, and 'show' doesn't know what type of value it is supposed to take
12:39:00 <jle`> eschnett: 'stack upgrade'
12:39:04 <metahumor> "stack upgrade"
12:39:40 <lyxia> danilo2_: I find those requirements quite superficial
12:39:46 <cugj> Stack upgrade is perfectly fine
12:39:49 <danilo2_> lyxia: oh, why ?
12:40:29 <danilo2_> lyxia: look, If you create for example system PAth manipulation toolkit, you want to provide function to "expand" env vars and you want to encode on type level that now you dont need to pattern match on "EnvVar" constructor anymore!
12:40:30 <lyxia> danilo2_: I really don't see the problem with encoding "case" with "match" to make it more expressive
12:40:46 <eschnett> metahumor: that fails as well -- "Could not parse '/tmp/stack-upgrade16595/stack-1.6.5/stack.yaml'"
12:41:07 <Tuplanolla> Is the metadata block in Hakyll in YAML format or what?
12:41:11 <danilo2_> lyxia: another exammple is waht we use in our compiler right now - we encode on type level how much the AST is computed (if we use `Term Val` on type level we know that this is actual fully computed value and we dont need to pattern match on other consturctors)
12:41:40 <jle`> glittershark: oh, maybe you need to turn on ScopedTypeVariables
12:41:43 <danilo2_> lyxia: the problem with using `match` is that GHC doesnt check if you covered all the cases you should - and this is a problem in production code
12:42:04 <lyxia> danilo2_: match does give coverage checking
12:42:08 <glittershark> jle`: if that's it I'm gonna be so sad
12:42:34 <lyxia> danilo2_: It's actually a type error if you don't apply it to the correct number and type of handlers
12:42:36 <Welkin> Tuplanolla: yes, I believe so
12:42:48 <metahumor> eschnett: can you reinstall stack?
12:42:50 <Welkin> it is in a format pandoc can understand
12:42:56 <Welkin> since hakyll is a wrapper over pandoc
12:43:02 <jle`> nvm, just downloaded it to try it
12:43:08 <metahumor> purge "~/.stack-work", rerun the "curl ... | sh" script?
12:43:11 <danilo2_> lyxia: oh, does it? Hmmmmm, ok, that would actually make sense because we can use typeclasses to simulate the error there
12:43:29 <danilo2_> lyxia: oh, oh, oh, I can do it this way. It owuldn to be a warning, but error is good enough here
12:43:41 <danilo2_> lyxia: thannks so much! I have to try it out!
12:43:54 <jle`> glittershark: okay, looking closer, you might have to clarify what you want
12:43:59 <jle`> (l :: f k)
12:44:08 <jle`> this k is a different thing than the k in (f :: k -> k)
12:44:09 <eschnett> metahumor: it's a binary i just downloaded. yes, i can reinstall it.
12:44:20 <glittershark> hmm
12:44:22 <jle`> f takes types of kind k
12:44:25 <jle`> not k
12:44:35 <jle`> so that'd be like saying 'succ Int' instead of 'succ 0'
12:44:41 <glittershark> right
12:44:42 <eschnett> metahumor: the "curl..." script doesn't work, as the respective stack binary doesn't exist any more. i found a blog post pointing to an older binary.
12:45:11 <eschnett> metahumor: (this is a raspberry pi with arm architecture)
12:45:22 <glittershark> yeah ok ScopedTypeVariables doesn't seem to work
12:45:35 <glittershark> primarily because I can't seem to bring the k in scope
12:45:43 <jle`> glittershark: i'm not exactly sure what you are trying to do
12:45:51 <glittershark> uh
12:45:56 <eschnett> metahumor: could be this problem: <https://github.com/dmjio/miso/issues/267>
12:46:19 <glittershark> I'm trying to kind-level fmap a type constructor over a type of *kind* 'Maybe a'
12:46:27 <glittershark> using Maybe as a promoted kind constructor with DataKinds
12:47:24 <jle`> so how would you fmap a type constructor like 'Foo'
12:47:42 <glittershark> so if `Foo :: k -> *`
12:48:07 <glittershark> I'd be constructing terms of type `KFmap Foo (x :: Maybe k)`
12:48:42 <glittershark> ie either `KJust (x :: Foo k)` or `KNothing`
12:49:20 <EvanR> metahumor: i have to close this page, because i cant tell which tab i am in without looking at the url bar, mlab or nlab
12:49:35 <glittershark> this is how it looks specialized to Maybe: http://lpaste.net/362765
12:49:39 <EvanR> which is causing an existential crisis
12:49:42 <glittershark> that example works just fine, fwiw
12:49:47 <suzu> jle`: i get it now, thanks
12:49:56 <metahumor> EvanR: if it could make sense, its probably mLab
12:50:28 <glittershark> unfortunately you're gonna have to take my word for it that this is useful :)
12:51:13 <joe9> my haskell program is maxing out the cpu and the output is stalled. Any suggestions on how to go about debugging this, please?
12:51:34 <Welkin> joe9: compile with profiling
12:52:02 <Welkin> you could have an inifinite loop somewhere, perhaps
12:52:22 <joe9> ok, Thanks.
12:52:25 <glittershark> +RTS -s -RTS
12:52:50 <Bowlslaw> hahahha
12:53:09 <EvanR> is that flag sequence unitary
12:53:14 <jle`> glittershark: ok, i think an issue is that you don't want l to have the kind 'f k'
12:53:17 <metahumor> joe9: check that you're not trying to reach the end of an infinite list
12:53:17 <jle`> you want l to *be* 'f k'
12:53:19 <Bowlslaw> I tried to call a method as a function, and it somehow got through QA to live, which caused a report to crash.
12:53:24 * Bowlslaw blames QA
12:53:30 <jle`> glittershark: er, not 'f k'
12:53:34 <jle`> but 'f x' , x :: k
12:53:39 <glittershark> yeah
12:53:43 <Welkin> EvanR: episcopalian
12:53:46 <glittershark> that particular iteration throws a syntax error though
12:53:58 <metahumor> eschnett: i dont know rpi arch, i've heard that GHC on ARM is hard.
12:54:00 <EvanR> Bowlslaw: whats the diff between method call and function call ?
12:54:08 <Welkin> Bowlslaw: methods are functions... what?
12:54:26 <Welkin> there are not truly "methods" in haskell
12:54:36 <EvanR> no true method
12:54:37 <amalloy> i think Bowlslaw is talking about a program written in a non-haskell language
12:54:38 <Welkin> a typeclass "method" (or member) is just like any other function
12:54:54 <Bowlslaw> er, yes, this is in Perl, not Haskell, sorry guys lol
12:55:02 <glittershark> Unexpected type (f k) in the data family declaration for Fmap; a data family declaration should have form data family Fmap a b
12:55:09 <jle`> in haskell, we actually have methods that aren't even functions
12:55:11 <jle`> so that's nice too
12:55:21 <Welkin> jle`: sure, typeclass members?
12:55:30 <glittershark> yay -XTypeApplications
12:55:32 <jle`> i think they're called methods?
12:55:47 <eschnett> metahumor: thanks...
12:56:13 <lyxia> glittershark: is that supposed to represent a functor in the categorical sense
12:56:22 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
12:56:41 <glittershark> lyxia: yep
12:56:54 <Bowlslaw> I learned how to construct ADTs in Haskell a few mintues ago
12:56:57 <Bowlslaw> sokewl
12:56:58 <phadej> i read that onelinereports :/
12:56:59 <Welkin> I have heard them called methods and members
12:57:18 <glittershark> it's an endofunctor in the category of kinds rather than the more conventional endofunctor in the category of (haskell) types
12:57:24 <Welkin> Bowlslaw: you have been in here for days already, how is that possible then?
12:57:35 <jle`> that's not canon
12:57:40 <Bowlslaw> Welkin: well I'm most often logged in at work
12:58:00 <EvanR> haskell retcon
12:58:10 <Bowlslaw> so i can't learn Haskell that quickly
12:58:12 <jle`> re: calling methods members i mean
12:58:17 <Welkin> good to know
12:58:25 <lyxia> glittershark: but Fmap's signature does not resemble fmap's...  (a -> Type) -> f a -> Type
12:58:57 <joe9> metahumor: glittershark : Thanks.
12:59:40 <glittershark> lyxia: all GADTs implicitly return terms in Type
12:59:54 <Tuplanolla> It's not YAML, Welkin.
13:00:03 <Bowlslaw> Welkin: i'm on the exercises of Chapter 4 of Hutton's book, and I just started the second lecture of cis194, where they teach ADTs
13:00:10 <jle`> btw in the next GHC it is possible to have data families not return Type
13:00:35 <Welkin> Bowlslaw: I cover ADTs in chapter 1, because I think it is the first thing to learn
13:00:37 <glittershark> so the `data Fmap (a -> Type) -> f a where..` makes Fmap a type constructor of kind `(a -> Type) -> f a -> f Type`
13:00:55 <glittershark> or really `Fmap (f Type)` at the end there
13:01:10 <Bowlslaw> Welkin: o rly
13:01:12 <glittershark> but since it's an endofunctor `Fmap (f Type)` is actually just in `Type`
13:01:26 <glittershark> ooh jle` that's cool
13:01:35 <Bowlslaw> There are just so many resources I had to pick one or two
13:01:43 <joe9> anyone still using 8.0.2? I see 8.2.2 but am not sure if it is still too early to upgrade.
13:02:03 <Welkin> joe9: either is fine
13:02:20 <Welkin> I generally skip x.x.0 releases
13:02:26 <jle`> Stackage LTS recently moved to 8.2, if that means anything
13:02:28 <Welkin> but by x.x.1 or x.x.2 it should be fine
13:03:01 <jle`> LTS lags about 6 months behind the most recent ghc releases for stability, proportedly
13:03:14 <jle`> so I usually use that as a sign to switch
13:03:30 <jle`> purportedly ?
13:03:38 <lyxia> glittershark: it being an endofunctor doesn't necessarily mean that f Type = Type
13:04:05 <kadoban> LTS switched to 8.2.2 like couple months back, yeah
13:04:19 <Bowlslaw> I found some really cool plugins for Vim, btw: ctrlSpace, fugitive, and airline
13:04:21 <glittershark> lyxia: sure I mean I'm not actually a category theoretician
13:04:26 <ongy> apparently `cabal new-build` doesn't deal with sources (including the .cabal file) updating under it because some idiot issues a `git pull` during the build. Good to know :)
13:04:36 <jle`> oh yeah, December 19th
13:04:38 <ongy> ctrl-p is also pretty cool
13:04:50 <Bowlslaw> ongy: ctrlSpace comes with a fuzzy file searcher
13:05:00 <Bowlslaw> which I think may be ctrl-p...
13:05:08 <dminuoso> ertes: After a sneaky off by one error I rewrote it slightly. Is this more readable? https://gist.github.com/dminuoso/9e17c70b7311a6b9b9722799443137be
13:05:08 <glittershark> if you say it's not actually a functor I'm fine with that, but either way it's still useful :)
13:05:18 <jle`> ongy: i'll file that under 'note to self'
13:05:28 <EvanR> metahumor: i wonder if discussion language of higher category theory, could have a type system applied to it
13:05:28 <jle`> "don't git pull during a build"
13:05:30 <lyxia> glittershark: okay it's not a functor, so what is it
13:05:44 <EvanR> which would reject this random nonsense, and accept "real" discussion (and reject "real" nonsense)
13:05:56 <metahumor> Bowlslaw: you might also like ALE, vim-surround, undotree
13:05:59 <glittershark> lyxia: idk, I have a type of kind (Maybe k) and a type constructor of kind (k -> Type) and I want a Type out of it
13:06:08 <metahumor> EvanR: isn't that what HoTT is about? I just started reading the book
13:06:42 <EvanR> most of the hott book is the informal language similar to nlab, only more readable because its starting from somewhere
13:07:04 <Bowlslaw> metahumor: perhaps, I want to keep vim as light as possible, though
13:07:08 <Welkin> metahumor: your name reminds me of that flambouyant game show robot that dances in Undertale
13:07:24 <metahumor> not familiar with that
13:16:13 <lyxia> glittershark: http://lpaste.net/362767
13:19:05 <glittershark> niiiiice
13:19:07 <lyxia> It looks functorial but it's not obvious to me in what way
13:19:18 <glittershark> lyxia: real MVP, thanks a bunch
13:19:36 <lyxia> also I ran into a GHC panic on the way...
13:19:42 <glittershark> yeah I hear what you're saying about the return kind not quite feeling like it's properly in the codomain of the functor
13:19:45 <glittershark> lol
13:20:07 <Tuplanolla> I keep running out of memory when linking programs using Hakyll and adding `-dynamic` to `ghc-options` doesn't work. What can I do about this?
13:21:26 <cocreature> Tuplanolla: maybe try gold or lld?
13:21:35 <Tuplanolla> They don't help, cocreature.
13:22:12 <cocreature> not sure then apart from “buy more memory” :)
13:22:26 <Welkin> Tuplanolla: are you doing anything that would use up a lot of memory?
13:22:35 <Welkin> or is it just a typical hakyll setup?
13:22:44 <Tuplanolla> It's the default template, Welkin.
13:22:49 <Welkin> then that should not happen
13:22:54 <Welkin> how much memory do you have available?
13:23:03 <Tuplanolla> About 2 GB for this process.
13:23:12 <Welkin> that should be fine
13:23:32 <lyxia> glittershark: that panic I just mentioned seems to be fixed on the latest GHC. You might want to try that if you run into that kind of issue
13:23:43 <glittershark> mm, ok
13:23:46 <glittershark> by latest you mean master?
13:23:53 <Tuplanolla> It's clearly not fine.
13:24:02 <Welkin> Tuplanolla: how did you install it?
13:24:03 <lyxia> glittershark: yeah, the one being worked on
13:24:05 <metahumor> does anyone have pointers on how to go about learning how simplicial homotopy theory works? let's say i did some abstract algebra and point-set topology a long time ago...
13:24:12 <glittershark> oof, ok
13:24:16 <Welkin> and what ghc version
13:24:19 <glittershark> I guess this is what I get for going bleeding-edge.
13:24:34 <lyxia> glittershark: TypeInType is a minefield
13:24:37 <Tuplanolla> With `stack new` and `stack build`, Welkin. It's what comes with the latest LTS.
13:24:39 <glittershark> yeah wow
13:24:57 <glittershark> here I am planning on putting this into production...
13:25:01 <glittershark> we'll see how that works out
13:25:19 <Welkin> Tuplanolla: I am using hakyll with 8.2.2 on stack and it works without issue
13:25:25 <Welkin> perhaps try cleaning it out and reinstalling
13:25:55 <Welkin> wait
13:25:59 <Welkin> are you running this on a vps?
13:26:11 <Tuplanolla> No.
13:26:14 <joe9> just want to check if this points to a memory leak http://okturing.com/src/2294/body
13:26:30 <kadoban> Tuplanolla: You're sure it's actually during the linking phase you're having trouble? 2GB sounds low for actually building pandoc and assorted other hakyll stuff, but that should come up earlier.
13:26:44 <Tuplanolla> I'm watching it in `top`, kadoban.
13:26:59 <Tuplanolla> It's just the `site.hs`.
13:27:40 <kadoban> 2GB is the amount of memory you see it use, or that's the limit it has available or something? Not really following.
13:27:45 <dminuoso> In Haskell terminology, does the "Rep" suffix mean Boxed?
13:28:16 <Welkin> dminuoso: everything is boxed unless you explicitly unbox it using pragmas
13:28:47 <Tuplanolla> It's the amount the process can take before it dies, kadoban.
13:28:50 <dminuoso> Welkin: What I mean.. GHC.Exts lists constructors like LiftedRep, UnliftedRep, etc. It's suggested (but not clearly defined as far as my taste goes) that Rep implies its a boxed type.
13:28:58 <dminuoso> Just wanted to confirm this.
13:29:01 <arora> Hey, I am starting on functional programming and would like to start out with Haskell, I am fluent in C, what are some good books on Haskell? And is there any like K&R kind?
13:29:13 <Welkin> I don't know about that module
13:29:34 <dminuoso> arora: Books that are frequently mentioned include Haskell Book, Learn You a Haskell, Real World Haskell
13:29:49 <glittershark> arora: May want to pop into #haskell-beginners as well
13:29:50 <kadoban> Tuplanolla: Well, I wouldn't be surprised if 2GB isn't enough for it to build pandoc and a couple others that it needs to as deps. Maybe try with -j 1 ?
13:29:58 <Welkin> arora: https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229
13:30:04 <Tuplanolla> No. I'm not building anything like that, kadoban. Just `site.hs`.
13:30:31 <Welkin> arora: there is also http://learnyouahaskell.com/
13:30:38 <kadoban> Tuplanolla: Okay, but it uses the hakyll library, right? And that uses pandoc and a bunch of other stuff that it'll build.
13:30:54 <Tuplanolla> It doesn't rebuild them every time.
13:31:20 <dminuoso> arora: Just know that especially coming from C basically none of your knowledge will be transferrable at first. You'll need to unlearn some things. =)
13:31:30 <Welkin> arora: I am also writing my own (freely available) book at haskellroguelike.com which is a work in progress
13:32:21 <arora> dminuoso Does functional program changes the way of thinking for programming?
13:32:28 <Welkin> arora: yes
13:32:28 <dminuoso> arora: Yes.
13:32:39 <maerwald> any paradigm does
13:32:41 <arora> Welkin Thanks for the free book.
13:32:48 <dminuoso> arora: Especially when it's pure functional programming, with lazy evaluation and an advanced type system.
13:33:31 <maerwald> *add your favorite featueres* lol
13:34:04 <arora> Does it make one more efficient in terms of writing code?
13:34:10 <maerwald> no
13:34:14 <Welkin> arora: I believe so
13:34:26 <maerwald> it makes you less efficient
13:34:29 <Welkin> there is a learning curve at first, but eventually yes
13:34:34 <maerwald> because you think about more levels of programming than before
13:34:40 <dminuoso> arora: Yes. Pure functional languages enjoy a property called equational reasoning.
13:35:04 <Welkin> it makes you more disciplined in your approach
13:35:10 <maerwald> he said *efficient*, not "easier to reason" or "high quality" :)
13:35:11 <Welkin> you have to be more rigorous
13:35:25 <Welkin> the compiler will keep you honest
13:35:28 <dminuoso> maerwald: Ability to reason translates in efficiency.
13:35:30 <arora> and do they involve more mathematical approach?
13:35:35 <maerwald> dminuoso: no
13:35:58 <dminuoso> arora: Only very slightly.
13:36:03 <Welkin> no math required, but you have to think about what you are writing rather than just writing down whatever comes to mind and running it
13:36:12 <dminuoso> arora: There's no mathematics beyond basic high school mathematics required to be competent at the language.
13:36:14 <Welkin> the compiler will tell you "Hey, I see you made some mistakes. Go fix them"
13:36:23 <arora> Some of the program I had looked involved a fair bit of lambda calculas and such.
13:36:34 <dminuoso> arora: Some people like to live their dreams.
13:36:38 <dminuoso> arora: You dont have to.
13:37:00 <sQVe> Having troubles getting HIE setup in Vim. Anyone have a conf for this that works?
13:37:01 <Welkin> arora: one of my favorite illustrations (ane jokes) of haskell is this page http://www.willamette.edu/~fruehr/haskell/evolution.html
13:37:23 <dminuoso> arora: Haskell has a rich ecosystem of mathematically inspired features, extensions and libraries. But they are completely optional and mostly serve to help those that can leverage them.
13:38:06 <arora> Welkin C also requires a similar approach of making a design before actually writing it. It's a good way to plan before execution.
13:38:46 <arora> dminuoso What are some projects made in haskell?
13:38:50 <maerwald> yes, that's nothing that haskell is special in, but it introduced a new layer of thinking about your program
13:39:20 <maerwald> in C, you care very little about pure functions, although C has them, kinda
13:39:58 <Welkin> arora: you will have to think very carefully about side effects in haskell
13:39:59 <maerwald> after doing a lot of haskell you will notice that careful thinking about effects carries over to other languages
13:40:00 <arora> Also the haskell website was very welcoming with giving out a tour of the language, which I was interested in instantly.
13:40:04 <dminuoso> arora: Well GHC itself is made in Haskell for starters. =)
13:40:30 <maerwald> Welkin: side effects?
13:40:51 <jle`> s/side//
13:40:55 <Welkin> maerwald: what are known as side effects in other languages, like mutation and IO
13:41:05 <dminuoso> arora: Our wiki has multiple pages listing usages of Haskell in projects and the industry.
13:41:34 <arora> dminuoso Isnt that bootstrapping?
13:41:52 <arora> Making compiler from the same language.
13:42:15 <metahumor> arora: if you understand how function pointers can be used in C, then you're well on your way to functional programming
13:42:32 <Welkin> arora: yes it is
13:42:48 <Franciman> can haskell be compiled on ARM?
13:42:52 <Welkin> yes
13:42:55 <cheers> Franciman: yep
13:42:59 <napping> more specifically, bootstrapping would be getting a compiler to compile itself
13:43:00 <Franciman> cool
13:43:06 <Franciman> ty
13:43:26 <napping> I forget the details, but the history is interesting - GHC wasn't the first compiler, and was written in Haskell from the beginning
13:43:58 <Welkin> ghc used to compile to C instead of machine code as well, right?
13:44:05 <Franciman> ye
13:44:07 <Franciman> yes
13:44:12 <maerwald> arora: on the other hand, while haskell introduces new layers of reasoning, it also removes some, e.g. memory (it's generally hard and you don't program memory like you can in C)
13:44:37 <metahumor> Welkin: http://www.scs.stanford.edu/11au-cs240h/notes/pipeline.png
13:44:39 <ZelteHonor> I would like to use a package in my project, but it's not compiling. I took it from Hackage. The last version know to compile is ghc 7.6 The compiling error seem related to Applicative. Is there any guide on how to change it to compile.
13:44:45 <arora> Oh, so is there no concept of pointers, and what about memory management?
13:44:48 <napping> arora: Ah, the "Haskell B Compiler" HBC was written in lazy ml
13:44:54 <dminuoso> arora: memory is fully managed
13:44:58 <ZelteHonor> Also how do I get a local version of the package to modify and depend on?
13:45:04 <Welkin> metahumor: I know what it looks like today, I was asking about historically
13:45:06 <napping> and I think lazy ml was implemented in lisp
13:45:08 <metahumor> ZelteHonor: which package?
13:45:13 <Welkin> I recall reading somewhere that it was the case
13:45:14 <leshow> Welkin: It still sort of compiles to C, I think it get's compiled to C-- at some stage in the pipeline
13:45:15 <ZelteHonor> monadiccp.
13:45:33 <kadoban> ZelteHonor: What build tool are you using? 'stack unpack' will work in stack, and then you need to change your thing to depend on your local version.
13:45:54 <metahumor> arora: haskell can have pointers like C. but doesn't mean you should use them.
13:45:56 <dminuoso> leshow: Yeah. From the diagrams that I read C-- can then alternatively pushed into LLVM IR, C or directly into asm through NGC.
13:46:10 <dminuoso> But my diagrams might be outdated.
13:46:19 <napping> arora: GHC has been able to compile itself since long ago, but it was bootstrapped with another Haskell compiler, rather than something more annoying
13:46:23 <ZelteHonor> I do use stack. What is unpack doing?
13:46:27 <leshow> dminuoso: if it says llvm it can't be too old
13:46:36 <arora> metahumor are pointers generally used or are they avoided?
13:46:39 <leshow> brb
13:46:43 <kadoban> ZelteHonor: Downloads the package and throws it in a directory.
13:46:49 <EvanR> wait, there was a haskell compiler before GHC ?
13:46:50 <Welkin> arora: you can only use pointers with the C FFI
13:46:54 <Welkin> it is not normal haskell
13:47:08 <ZelteHonor> So it would be 'stack unpack monadiccp'?
13:47:11 <metahumor> arora: avoided.
13:47:22 <kadoban> As for how to fix it, you probably need an Applicative instance for something that doesn't have one. Maybe, you'd have to say what the actual error is.
13:47:26 <kadoban> ZelteHonor: Yep
13:47:32 <metahumor> arora: haskell has some CRAZY ideas about evaluation and execution which make it very unlike most languages
13:47:50 <metahumor> arora: like, things are not executed until they need to be (for the most part)
13:47:54 <maerwald> haskell only has evaluation, afair?
13:47:55 <kadoban> Then you can go into the directory and get it to build, 'stack build', that's a good start.
13:48:10 <metahumor> arora: and types don't exist at run time (for the most part)
13:48:22 <maerwald> I don't think the spec says anything about execution, RTS or something else
13:48:37 <metahumor> s/executed/evaluated/g
13:48:49 <nshepperd> IO is in the spec
13:48:57 <dminuoso> By evaluation you mean reduction right? :P
13:49:04 <arora> Oh so it's like learning a completely new language, what is the difference between executed and evaluated?
13:49:07 <maerwald> nshepperd: that doesn't mean execution is specified
13:49:19 <nshepperd> IO is what is executed
13:49:30 <maerwald> that sounds very thin
13:49:31 <dminuoso> arora: execution has the notion of commands. Haskell is very non-imperative. ;-)
13:50:01 <dminuoso> arora: In essense evaluating an expression amounts to simply "replacing something with its result"
13:50:09 <Tuplanolla> I guess there's no way around this linker issue.
13:50:35 <Tuplanolla> I just find it completely unreasonable for a single process to be able to take several gigabytes of memory.
13:50:52 <exarkun> switch back to 32 bit
13:50:53 <bitemyapp> Tuplanolla: can you use gold or lld?
13:51:05 <Tuplanolla> I tried all three with similar results, bitemyapp.
13:51:10 <bitemyapp> really? wow. ouch.
13:51:22 <bitemyapp> I was planning to move a project or two over to gold and see if it helped.
13:51:26 <Tuplanolla> There's too much library for a man to link.
13:51:27 <metahumor> arora: in haskell, i can write an expression "x = [1..]" which means "x" stands for the infinite singly-linked-list of integers "[1,2,3,...]"
13:51:39 <bitemyapp> Tuplanolla: can't be worse than the runtime linker issues in macOS ;)
13:51:51 <maerwald> metahumor: maybe just link him to a proper tutorial
13:51:52 <bitemyapp> more than 32kb of rpath and it curses god and dies
13:52:08 <EvanR> evaluation, 2+2 => 4. execution, an email gets sent into the internet
13:52:33 <Welkin> a web scale calculator
13:52:35 <EvanR> in haskell you can evaluate something and get "send such and such email", but it hasnt actually happened
13:52:38 <Welkin> a calculator as a service
13:52:54 <arora> dminuoso I think I saw it on the website, is it something like for x = 4 in x*x
13:52:54 <EvanR> commands such as that can be manipulated like any other value
13:53:04 <amalloy> imo the best example of a side effect to explain "execution" is beheading someone
13:53:18 <EvanR> haha
13:53:33 <metahumor> arora: i can also write an expression "y = x !! 4" which stands for "y is the 5th element (because 0-indexing) of x".
13:53:46 <maerwald> what's the side effect? people screaming?
13:53:53 <amalloy> maerwald: or we could just inline an entire tutorial into #haskell one line at a time
13:53:56 <manek> Hi ! Is it possible to use "local pragmas" to disable / enable some workings in some PARTS of module, nod the whole module ?
13:54:21 <Tuplanolla> Is not, manek.
13:54:22 <EvanR> the lazy haskell tutorial
13:54:32 <metahumor> arora: if I execute "print y", that is evaluated to "print (x !! 4)" --> "print ([1..] !! 4)" --> "print ([1,2,3,4,5..]) !! 4" --> "print 5"
13:54:35 <bitemyapp> unsafeInterleaveAdhocTutorial
13:54:48 <maerwald> amalloy: I find "interactive" tutorials not very helpful, they are hard to follow and hardly replicate what is already well-written somewhere else.
13:55:02 <amalloy> yes, my suggestion is clearly a strawman
13:55:07 <EvanR> do we have a well written tutorial somewhere
13:55:07 <napping> manek: you can probably extract stuff to a separate module, unless you would get cyclic dependencies
13:55:21 <maerwald> @where cis194
13:55:21 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
13:55:28 <EvanR> thats... not a tutorial
13:55:31 <dminuoso> arora: Basically evaluation happens in a very mathematical way: You plug values into a function, and then you just "calculate the result". And it doesn't matter how many times you evaluate sin(1).
13:55:32 <maerwald> I consider that a tutorial
13:55:32 <metahumor> arora: I suggest reading the Haskell book for more
13:55:44 <metahumor> @where PHFFP
13:55:44 <lambdabot> I know nothing about phffp.
13:55:49 <metahumor> @where HPFFP
13:55:50 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
13:55:50 <EvanR> well, yeah we can redirect to an encyclopedic volume
13:55:55 <manek> Tuplanolla, napping thanks!
13:55:55 <maerwald> metahumor: that is not free
13:56:07 <Tuplanolla> @where pfft
13:56:07 <lambdabot> Pfft!
13:56:09 <dminuoso> arora: In that sense evaluation - and Im treading on thin ice here - means "plugging in values and evaluating in a mathematical fashion"
13:56:25 <metahumor> maerwald: someone shared lyah earlier
13:56:29 <Welkin> if you really want to know about how evaulation in haskell works, read the fish book
13:56:30 <maerwald> which was worse, yes
13:56:32 <Welkin> @where parconc
13:56:32 <lambdabot> https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
13:56:38 <arora> All this is so new and interesting, I will hopefully stay on the track and try to get over the curve.
13:56:39 <EvanR> dminuoso: since, evaluation is characterized recursively
13:57:08 <dminuoso> EvanR: Gotta prepare them for `fix` and `Fix` from the beginning!
13:57:21 <EvanR> i meant to type, "nice,"
13:57:53 <dminuoso> EvanR: But yeah. That was a mistake, I intended to write "calculate" in that second half.
13:57:59 <Welkin> arora: don't let anyone overwhelm you. There is a ton to learn about haskell that you don't *need* to know. There is very little that you need to get started.
13:58:56 <maerwald> I've seen a course where they did TH in the 6th week or something? lol. horrible.
13:59:01 <Welkin> I feel too many fall into this trap of trying to impress newcomers by telling them all of the most advanced things up front (typical example: free monads)
13:59:10 <joe9> does stack build --profile, add -fprof-auto?
13:59:21 <EvanR> beheading someone, cool, so this is meant to evoke fear or caution because there are consequences, its irreversible. but wait... evaluation also cant be reversed
13:59:36 * EvanR goes into a cave and dwells on it
13:59:38 <dminuoso> Welkin: We should talk more about `Day`
13:59:49 <bitemyapp> Welkin: super common problem
13:59:52 <dminuoso> Im not 100% on what `Day` actually does. So!
13:59:52 <bitemyapp> doesn't help anyone 'neither.
14:00:10 <arora> Welkin Is there a list of basic essentials that I should focus on first and then proceed to niche concepts?
14:00:23 <dminuoso> arora: We have given you a plethora of books to consider.
14:00:28 <dminuoso> Most of the should give you a good entry.
14:00:39 <maerwald> lyah is terrible, haskell book is non-free
14:00:44 <maerwald> just try the cis course
14:01:00 <bitemyapp> Haskell Book is heavily discounted or free if you're poor or a student or in a developing country
14:01:10 <maerwald> so basically not free
14:01:10 <napping> arora: you may want to hang onto a link to the language standard https://www.haskell.org/onlinereport/haskell2010/
14:01:14 <EvanR> is there something thats not LYAH, not a large book, and not CIS194 ?
14:01:15 <bitemyapp> http://haskellbook.com/support.html email us, I'll get you a copy.
14:01:37 <Welkin> arora: the first book I linked is the most concise intro to the language at around 250 pages
14:01:47 <bitemyapp> There's Simon Thompson's book. https://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201882957
14:01:49 <EvanR> :S
14:01:52 <bitemyapp> I wouldn't be intimidated by the page count though.
14:02:09 <bitemyapp> the page count in my book is bloated by copious code examples and REPL examples
14:02:15 <dminuoso> Book recommendation time going crazy. I think about every book thats worth while recommending has been recommended, and then recommended against by someone else now.
14:02:16 <Welkin> which is https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229
14:02:19 <bitemyapp> there's not that much prose, it's mostly exercises.
14:02:31 <bitemyapp> Welkin: I found Thompson's book more effective than Hutton's for most people.
14:02:44 <bitemyapp> in terms of time expenditure re: mostly exercises.
14:02:47 <Welkin> I have not seen thompson
14:02:51 <bitemyapp> and you can't learn the language and not-do exercises
14:03:06 <EvanR> oh, check this one out https://www.haskell.org/tutorial/
14:03:19 <napping> Ah, a classic
14:03:23 <bitemyapp> I reviewed the books here: http://bitemyapp.com/posts/2014-12-31-functional-education.html
14:03:29 <bitemyapp> and some courses
14:03:35 <dminuoso> EvanR: Heh. I started out with it - it was anything but gentle, but I loved the care for detail.
14:03:35 <maerwald> even if I had the haskell book, I'd be scared to share, paste or discuss any of it, since I might be sued
14:03:38 <dminuoso> It was just a bit short.
14:03:42 <Welkin> Hutton's new edition came out in 2016
14:03:49 <napping> The "Gentle Instroduction" should get you up to speed quickly if you have prior experience with Miranda(tm) or Lazy ML
14:03:59 <bitemyapp> maerwald: are you serious? Fair use applies.
14:04:09 <maerwald> fair use is up to interpretation
14:04:10 <bitemyapp> I don't appreciate the implication that I am litigious.
14:04:21 <EvanR> dminuoso: as i recall, that was part of the strength for me. because it didnt derail into a treasise on comonads or something, it only talked about basics, first
14:04:57 <dminuoso> EvanR: And it does it with a really high amount of precision when it comes to terminology and details. It's none of this "you can think of this as ..."
14:05:06 <EvanR> so the "hard" parts i was struggling with, kind of evaporated for a minute
14:05:22 <napping> maerwald: do note that bitemyapp is one of the authors
14:05:23 <arora> bitemyapp Can I email you by tomorrow?
14:05:27 <maerwald> if the book doesn't have a clear license that tells me I can share, modify and discuss any of it, being sued is a practical possibility to consider. And "fair use" depends on country
14:05:34 <bitemyapp> arora: whenever you like, we process emails like a ticket queue.
14:05:38 <amalloy> bitemyapp: it doesn't really matter whether you're litigious, and i don't think what maerwald said implies that you are. it's reasonable to be cautious about what you can share from something non-free
14:05:56 <bitemyapp> maerwald: if you're in the US then US fair use applies. If you're not in the US it doesn't matter as I can't do anything regardless.
14:06:22 <napping> bitemyapp: there is plenty you *could* do
14:06:36 <EvanR> oh lord
14:06:52 <maerwald> well, that is a problem for teaching material not having a proper license
14:06:55 <dminuoso> EvanR: Just the mutual recursion example with client/server was a bit.. well. It was fairly off spt.
14:06:58 <Welkin> EvanR: ahem. *my* lord
14:07:10 <boj> oh hey #haskell, sounds like you should all go to the offtopic room
14:07:11 <EvanR> off spt ?
14:07:39 <dminuoso> boj: Yesterday -ot had more active Haskell discussions than #haskell for a while.
14:07:43 <Tuplanolla> Laws are on topic, boj. Most of our type classes have them.
14:07:54 <boj> XD
14:09:35 <joe9> EvanR: wondering if you have any suggestions, please? I have a haskell program that is hanging (no output). but, the cpu  and memory usage is very heavy. I assume that it went into some kind of recursive loop or such. I am trying to debug it.
14:09:52 <EvanR> right thats what it sounds like
14:09:59 <joe9> EvanR: When I run the profiling report, there is a function (cost centre)that is taking 84.5% alloc
14:10:02 <Welkin> joe9: did you include [1..]?
14:10:15 <Welkin> fold over*
14:10:21 <EvanR> the absolute fallback is going to be, insert Debug.Trace.trace's around your code and move them until you see output
14:10:40 <joe9> Welkin: not that I know (remember) of. It has become a big program and I have not touched it in the last year.
14:10:40 <EvanR> then at least you know where to start checking the code
14:10:51 <metahumor> joe9: care to share your code with us? like a minimal working (hanging) example?
14:11:09 <Welkin> a brachiating example?
14:11:29 <metahumor> ah -- back to classic old "printf" debugging then, with Debug.Trace.trace
14:11:39 <EvanR> thats the absolute fallback, imo
14:11:51 <EvanR> if you have any idea of what your code is doing you oughtta have a better place to start than that
14:12:09 <EvanR> is there a function that is defined with a wily general recursion
14:12:13 <joe9> EvanR: Welkin, metahumor: this is the .prof https://gist.github.com/0eb9876b92b6e88df65cacb63dc108eb
14:12:22 <EvanR> that youre using
14:12:46 <EvanR> non trivial recursion is akin to "goto" and could easily hang
14:13:02 <joe9> I am not sure how to show the .pdf file.
14:13:20 <joe9> I recently ugraded the stack lts package. I am not sure if that broke some module
14:13:32 <joe9> It was working fine before that.
14:13:48 <metahumor> joe9: just by seeing that you're using Attoparsec, my first (and likely wrong) assumption is that you have a recursive parse defined somewhere, likely with a "many"
14:14:13 <arora> It's 020
14:14:18 <arora> Sorry
14:14:21 <metahumor> or that "many" parse accepts an empty input, so you are generating an infinite list nothing
14:14:44 <joe9> metahumor: Is there any way to figure out which function from the .prof file, please?
14:15:05 <arora> It's 02:14 am here, thanks everyone for welcoming me in the group, good night.
14:15:09 <joe9> I am sure it could be the data that is causing it and the data files runs into a couple of hundred MB's.
14:15:19 <metahumor> joe9: well, it's definitely in "pipeLoop"
14:15:57 <metahumor> which calls pipeLoop again, lines 4061 and 4079
14:16:09 <metahumor> do you have a minimal test data file that isn't so large?
14:16:10 <EvanR> if that loop is in IO, you could also putStrLn debug it
14:17:11 <Hijiri> is it possible to have ghc warn if I import Debug.Trace
14:17:18 <Hijiri> to avoid leaving it in on accident after I'm done debugging
14:17:36 <Hijiri> I guess it could be a problem if I turn on -Werror though
14:18:01 <kadoban> There's a pragma that causes a warning manually, isn't there? *looks*
14:18:13 <metahumor> LANGUAGE Safe
14:18:21 <metahumor> LANGUAGE Trustworthy works too
14:18:35 <joe9> metahumor: good point, I need to isolate the data that is causing the issue.
14:18:46 <Hijiri> safe and trustworthy wouldn't warn on other modules?
14:19:29 <metahumor> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/safe-haskell.html
14:19:59 <metahumor> "XSafe — Enables the safe language dialect, asking GHC to guarantee trust. The safe language dialect requires that all imports be trusted or a compilation error will occur."
14:20:00 <EvanR> parser combinator many is a good point, i hadnt realized how tricky it is to write terminating code with parsers
14:20:15 <EvanR> each combinator has caveats to read carefully
14:20:26 <metahumor> greediness hurts
14:21:34 <joe9> EvanR: metahumor: ok, Thanks. The ghc profiling man page does not seem to have any more details other than using the .hp and .prof file. The .pdf file from the .hp file just has a graph. not any more details.
14:22:20 <EvanR> the profile which blames particular constructors has helped me in the past, though not necessarily with looping
14:22:41 <EvanR> just gc performance
14:23:05 <dminuoso> Given this profiler output, can someone guide to me what things to look at to make my program go faster™ ? https://gist.github.com/dminuoso/8e42cc0650e7cc27af73e03b73879aa6
14:23:09 <dminuoso> Memory is not an issue.
14:24:05 <ZelteHonor> So I fixed multiple compilation error. But I am stuck on this one since the RULES seem fine to me: http://lpaste.net/362768
14:24:16 <ZelteHonor> What's wrong with it?
14:27:40 <cheers> how fast is haskell, compared to something like java or C#?
14:27:45 <cheers> about the same? slower?
14:28:13 <jle`> typically people say it is comparable to something between java and c, but it definitely depends on what you are writing
14:28:28 <pikajude> is there a name for this? Monad m => ((a -> b) -> c) -> ((a -> m b) -> m c)
14:28:33 <cheers> ah, thanks
14:28:34 <pikajude> something lifty
14:28:35 <jle`> 'how fast is a language' is not a really well-defined question anyway
14:29:15 <dminuoso> Like, specifically I dont understand what exactly is taking so much time in testCell
14:29:34 <Welkin> jle`: time flies like a banana
14:30:28 <pikajude> do they? i've never seen a time fly
14:31:00 <pikajude> ok hoogle says there's no name for this operation
14:31:05 <amalloy> pikajude: does a function with that type exist? i'm having a hard time seeing how to combine the (a -> b) with the (a -> m b)
14:31:23 <dminuoso> amalloy: `fmap pure` I guess
14:31:24 <EvanR> haskell can be highly relativistic, 0.5 to 0.9 C
14:31:37 <amalloy> :t fmap pure
14:31:39 <lambdabot> (Functor f2, Applicative f1) => f2 a -> f2 (f1 a)
14:32:11 <pikajude> amalloy: well you need a `run` function really
14:32:48 <pikajude> :t \ f g -> ask >>= \env -> pure $ f $ \fn -> runReader (g fn) env
14:32:50 <lambdabot> MonadReader r m => ((t -> a) -> b) -> (t -> Reader r a) -> m b
14:33:06 <amalloy> pikajude: if you need an extract function (m a -> a) it's not really correct to label it with just Monad m, since not all monads have that
14:33:07 <pikajude> so it can't be generalized to Monad because there's no "unMonad" in the typeclass
14:33:11 <pikajude> yeah
14:33:14 <pikajude> see now i'm realizing that
14:33:17 <pikajude> as i type in irc
14:33:24 <dminuoso> :t let f = undefined :: a -> b in fmap pure f
14:33:26 <lambdabot> Applicative f => a1 -> f a2
14:34:42 <amalloy> perhaps it exists for Comonad? since (extract :: w a -> a) is a thing there
14:35:23 <pikajude> i don't think you can define Comonad Reader though
14:35:26 <pikajude> yeah, this question is silly
14:35:40 <jle`> Comonad Reader is possible with Monoid r
14:35:48 <pikajude> sure
14:36:01 <amalloy> :i Comonad
14:36:07 <jle`> no :i in lambdabot
14:36:17 <pikajude> but the question is silly for the same reason there's no way to define a generalized "bind"
14:38:04 <jle`> are not all questions silly in some way
14:38:05 <joe9> metahumor: EvanR; I have tried with a few different data files and the same behaviour is continuing. So, I guess it is not data related. Some space leak in my program, I assume.
14:38:23 <pikajude> no, there's at least one question that isn't
14:38:26 <pikajude> hell if i know what it is though
14:38:27 <EvanR> printf to the rescue
14:38:37 <pikajude> i've tried to find it by process of elimination over the past 3 years, no luck yet
14:38:45 <EvanR> have to tried to provide the bare minimum input data
14:38:50 <EvanR> to see if it ever terminates
14:39:12 <joe9> EvanR: good point, will try it. Thanks.
14:39:57 <pikajude> ohh, actually, i think MonadBase(Control)? resembles this pattern a bit
14:40:49 <EvanR> all your monadbase are control
14:42:04 <Rembane> All your monadbase are belong to us.
14:42:44 <pikajude> yeah, it's kinda like liftBaseWith
14:44:54 <pikajude> except rather than ReaderT IO b -> IO b it'd be ReaderT Identity b -> b
15:15:35 <fresheyeball> hamishmack: hey there
15:16:00 <fresheyeball> Can you tell me how to go from an ArrayBuffer in jsaddle to a ByteString?
15:17:03 <fresheyeball> There are some fancy tricks going on here and it's not clear to me
15:17:05 <gemishhood> Hey!
15:17:25 <fresheyeball> I see I can cast it too a BinaryData, but that is also just a JSVal newtype
15:17:31 <fresheyeball> gemishhood: howdy!
15:18:11 <gemishhood> How's it going? How is programming in haskell?
15:18:35 <fresheyeball> gemishhood: it's going well, Haskell is the best I have been able to use profesionally thus far
15:19:10 <gemishhood> Nice, I am planning to start learning FP
15:19:32 <gemishhood> I'm planning to either use haskell or erlang/elixir
15:20:00 <fresheyeball> gemishhood: you should use haskell
15:21:22 <pdxleif> > Data.Constants.Mechanics.gravity_G
15:21:24 <lambdabot>  error:
15:21:24 <lambdabot>      Not in scope: ‘Data.Constants.Mechanics.gravity_G’
15:21:24 <lambdabot>      No module named ‘Data.Constants.Mechanics’ is imported.
15:21:32 <gemishhood> fresheyeball: I sure as hell am going to learn haskell at some point, it is so interesting. My only doubt is that I don't see any real world uses for it. You have any input on that?
15:22:04 <fresheyeball> gemishhood: you are talking to a person who writes haskell full time
15:22:15 <Welkin> gemishhood: that is typical given the myths around the language
15:22:19 <Welkin> I thought that too when I started
15:22:28 <Welkin> I never intended to use it for anything other than learning
15:22:31 <bitemyapp> gemishhood: I've used Haskell in my day to day work for 3 years and a month now.
15:22:32 <gemishhood> Welkin: Hmm, so what have you used it for
15:22:36 <Welkin> but now I use it for all of my web development
15:22:58 <gemishhood> bitemyapp: Wow, that is pretty cool
15:23:19 <Welkin> I use it because I enjoy it and it is fun to use
15:23:42 <gemishhood> Yeah, it does seems really fun to program in
15:23:45 <Welkin> even though it has features that give you a lot of advantages, those don't even matter so much to me
15:23:51 <gemishhood> Haha
15:24:21 <Welkin> it also means development is easier, with less screaming at the computer
15:24:25 <gemishhood> What else can you use it for?
15:24:42 <jle`> i've used haskell for everything for a few years now too :)
15:24:44 <dgpratt> in something like μG.1 + F ⋆ G how should I interpret μG.1 ? I think 1 suggests "unit"; context is here http://oleg.fi/gists/posts/2018-02-21-single-free.html
15:24:52 <Welkin> top uses for haskell include: 1) compilers and parsers, 2) web development
15:25:01 <Welkin> I don't know any others that I would say specifically
15:25:04 <gemishhood> Nice
15:25:37 <jle`> dgpratt: the parenthesization is a bit off
15:25:45 <gemishhood> Also, is there a good REPL for haskell, I'm not a fan of Prelude
15:25:54 <Welkin> you can use it for anything since it is general purpose and has a large ecosystem of libraries
15:25:54 <aztex> Are there any possible applications of dependent types in parallel programming
15:25:56 <jle`> dgpratt: it's μ G. (1 + F * g)
15:26:02 <jle`> er, s/g/G
15:26:09 <amalloy> gemishhood: prelude is the name of the standard library, not the repl. the repl is ghci
15:26:16 <jle`> dgpratt: the notation is saying that it's the fixed point of (1 + F*G)
15:26:16 <dgpratt> ah, ok
15:26:19 <gemishhood> Ohh, sorry
15:26:20 <Welkin> gemishhood: ah yes, i forgot about parallel and concurrent programming, which haskell makes almost trivial
15:26:27 <jle`> "mu" as in fixed-point
15:26:39 <Welkin> @where parconc -- gemishhood
15:26:40 <lambdabot> https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
15:26:41 <dgpratt> oh, fixpoint, aka the thing that breaks mah brain :D
15:26:49 <jle`> dgpratt: fixed point of the function G = (1 + F * G)
15:26:58 <jle`> dgpratt: heh, you can just think of it as infinite recursion
15:27:05 <bitemyapp> gemishhood: yeah it just makes my work a lot nicer, easier, I can tackle harder problems if I want.
15:27:17 <jle`> dgpratt: as in, think of it as 1 + F * (1 + F * (1 + F * ...))), etc.
15:27:27 <gemishhood> bitemyapp: Nice, nice
15:27:40 <dgpratt> I'll ponder that, thanks jle`
15:27:44 <jle`> dgpratt: the mathematical notation is hiding the fact that it's kind of 'simple' in normal haskell
15:27:47 <gemishhood> bitemyapp: What about machine learning? Any good libs?
15:28:10 <Welkin> there are some scientific libraries, but that is a weak point for haskell libraries right now
15:28:20 <Welkin> it won't compete with the ecosystem to get with numpy/scipy
15:28:39 <jle`> dgpratt: data FreeA f a = X a | Y (Star (f a) (FreeA f a))
15:28:40 <Hijiri> grenade exists
15:28:45 <Hijiri> but notably it doesn't support gpu computation
15:28:55 <Hijiri> gemishhood: ^
15:29:04 <jle`> gemishhood: stop by http://www.datahaskell.org/ for more info on that neck of the woods :)
15:29:14 <gemishhood> Gotcha
15:29:15 <gemishhood> Thanks
15:29:16 <jle`> dgpratt: where Star is the star operator they are using there, um
15:29:28 <jle`> dgpratt: data FreeA f a = X a | Y (f a ** FreeA f a)
15:29:37 <jle`> dgpratt: fixed-point there is just used to say that the data type itself is recursively used
15:29:43 <dgpratt> ohhh, wait a sec...this definition looks a bit like lambda notation,  now that I think of it
15:29:57 <Welkin> I didn't know about that site
15:29:57 <pdxleif> Haskell is a general-purpose statically-typed garbage-collected language, so - it's good for everything except maybe writing device drivers. Limited perhaps by available libraries for a given domain.
15:29:58 <Hijiri> also grenade's Dropout layer silently does nothing
15:30:00 <dgpratt> except it's "mu"
15:30:13 <jle`> yeah, 'syntactically' it's similar
15:30:24 <Hijiri> device drivers and also embedded application maybe
15:30:29 <pdxleif> I use it mostly for writing command-line programs (e.g. parse some CSV and convert it to .avro, yadda yadda)
15:30:31 <jle`> admittedly a space after the dot would make it a bit easier to parse
15:30:39 <jle`> but the space was probably eaten by latex
15:30:39 <pdxleif> or window manager widgets
15:30:40 <Hijiri> Does "application" in embedded applications usually mean "use" or "program"?
15:31:17 <glittershark> Is there a syntax for getting a type parameter in-scope out of an existential, or do I have to re-apply it to a universally quantified function
15:31:20 <glittershark> ?
15:31:32 <Welkin> except this line at the bottom of the datahaskell.org page "Ready to revolutionize data science?" makes me cringe so hard I might fall over
15:31:34 <Hijiri> I'm currently using haskell (with luminance) as the OpenGL client in my graphics assignments
15:31:45 <jle`> dgpratt: if you write the math notation in haskell, the final ah ha moment might be more clear
15:31:52 <dgpratt> so does "mu" give us the clue that this is a fixpoint? or maybe it suggests that this is at the type-level? or something else entirely?
15:32:07 <glittershark> ie if I have `data E = forall a. C a => E a` and I destructure an `E`, can I get `a` in scope for type-applications, proxies, etc?
15:32:07 <jle`> data FreeA f a = X a | Y (Day (f a) (FreeA f a))
15:32:19 <Welkin> Hijiri: luminance?
15:32:21 <jle`> er oops
15:32:24 <pdxleif> Wasn't cartazio or someone doing something for matrix algebra in GHC, perhaps?
15:32:28 <jle`> data FreeA f a = X a | Y (Day f (FreeA f))
15:32:34 <Hijiri> Welkin: luminance, phaazon's graphics library
15:32:37 <jle`> data FreeM f a = X a | Y (Comp f (FreeM f))
15:32:45 <Hijiri> https://hackage.haskell.org/package/luminance
15:32:46 <jle`> and then you're supposed to go "oh it's just the same data type, except with Comp instead of Day"
15:32:53 <Hijiri> I was complaining about it in here a couple weeks ago
15:32:59 <jle`> and then you go "why not just paraterize it then"
15:33:00 <Hijiri> and I never made the PRs I promised to make
15:33:07 <dgpratt> that almost makes sense, thanks jle`
15:33:18 <jle`> data FreeT t f a = X a | Y (t f (FreeT t f))
15:33:25 <carter>  pdxleif yeah.  Got busy with other stuff. But did a bunch of foundational work
15:33:28 <jle`> and type FreeA = FreeT Day, type FreM = FreeT Comp
15:33:29 <dgpratt> I'm sure it'll make all kinds of sense once I absorb it completely :)
15:33:40 <jle`> dgpratt: mu is just notation for fix-point
15:33:49 <dgpratt> ah, ok
15:33:57 <jle`> so it's not quite a clue as in, that's what it's directly saying :)
15:34:38 <dminuoso> glittershark: Just to remove my confusion, where is the existential there?
15:34:50 <glittershark> the foall is on the right of the =
15:34:52 <glittershark> forall
15:34:57 <jle`> glittershark: usually you'd use scoped type variables
15:35:04 <glittershark> yeah jle` that's what I'm using
15:35:16 <jle`> case x of E (y :: a) -> ...
15:35:18 <glittershark> I'm just wondering how, when destructuring the data type, I get the type variable *in scope*
15:35:35 <jle`> then 'a' is in scope for the rest of the case statement body
15:35:44 <glittershark> oh, nice
15:35:44 <glittershark> ok
15:35:46 <glittershark> that works
15:35:48 <jle`> the ability to (y :: a) there is ScopedTypeVariables
15:35:49 <glittershark> ty! :)
15:35:53 <jle`> np!
15:35:57 <glittershark> yep, we have that in default-extensions
15:36:06 <bitemyapp> gemishhood: ML ain't my bag. I make ordinary networked services and workers that talk to databases like everyone else.
15:36:16 <dminuoso> glittershark: Ah my brain completely skipped that. :)
15:36:35 <jle`> glittershark: on a slightly unrelated note, be careful about having ScopedTypeVariables enabled by default in ghci
15:36:44 <glittershark> aww, TypeApplications doesn't work with poly-kinds :'(
15:36:49 <glittershark> hmm, why's that?
15:36:55 <jle`> since that can break code if ghci tries to load it
15:37:06 <jle`> in files not expecting scopedtypevariables
15:37:08 <jle`> idk it's probably a bug
15:37:10 <glittershark> ah
15:37:17 <gemishhood> bitemyapp: Nice, I think haskell has great potential for ML, and cant wait to work with it
15:37:30 <glittershark> yeah, imo ScopedTypeVariables is one of those language extensions that it's weird is not on by default
15:37:37 <glittershark> something something haskell90
15:37:38 <jle`> definitely
15:37:39 <glittershark> 98
15:38:29 <aztex> hi are there any applications of dependent types in parallel programming?
15:38:36 <glittershark> Data.Proxy?! what year is this, 2016??? :0
15:38:38 <pdxleif> carter: I saw a talk by conal on compiling via CCC's to FPGAs or GPUs or some biz.
15:38:59 <jle`> aztex: some people use phantom types to specify parallel vs sequential computations
15:39:02 <jle`> s/people/libraries
15:39:05 <jle`> like repa/massiv
15:39:34 <carter> That stuff is cool
15:39:36 <jle`> while not dependent types, usage of such phantoms could be made more powerful with dependently typed tools
15:39:48 <carter> Jle how’re you ?
15:39:54 <jle`> not too bad, and you?
15:39:55 <Welkin> Hijiri: it looks like there is a rust version as well
15:39:56 <jle`> last year of my phd :)
15:40:09 <carter> What focus ?
15:40:12 <jle`> (hopefully)
15:40:15 <Hijiri> Welkin: I saw that, but I don't know Rust yet
15:40:26 <Hijiri> I also saw that the haskell one is not as actively developed anymore
15:40:39 <carter> Repa isn’t bad.  But it and massive and friends aren’t quite the right thing.  Assume flatness
15:40:40 <jle`> it's a computational science program, thesis is on application to weather/climate modeling
15:40:46 <aztex> jle`: has their been any cases where say the size of the matrix etc things have been used to aid in data partitioning and bound checks for parallel computations?
15:41:26 <jle`> that's interesting because you might be able to do compile-time partitioning decisions i suppose
15:41:33 <jle`> i don't know about any libraries that do that currently
15:41:40 <jle`> i'm not sure if it's worth doing, though
15:41:44 <Welkin> Hijiri: from what I have seen so far, it should be easy to pick up if you know haskell
15:41:53 <jle`> picking partition sizes is tricky to do even for humans
15:42:03 <pdxleif> Would DPH still be the thing to use for other-shaped collections?
15:42:16 <glittershark> Rust was hard for me even as a Haskeller mostly because mutability happens sometimes
15:42:20 <glittershark> and also no HKTs
15:42:27 <Hijiri> Welkin: I'm not sure if I want to put in the effort to port what I have so far to Rust
15:42:37 <Welkin> I'm not saying you should
15:42:43 <Hijiri> I don't think I would really mind learning Rust, but I haven't tried much yet
15:42:44 <Welkin> just making a comment about rust
15:42:47 <Hijiri> ah, ok
15:43:09 <Hijiri> If I knew when I started this course then I might have tried the Rust version
15:43:15 <Welkin> glittershark: it's not different than ST
15:43:21 <Hijiri> then I would get additional meme points for Rust being more well known as a meme language
15:43:27 <jle`> it's kinda weird that pandoc uses strings to enumerate/identify its readers and writers instead of some ADT
15:43:30 <Welkin> why has development slowed down on the haskell version?
15:43:37 <aztex> well data partitioning was just an example off the top of my head. Things like data locality is very important in high performance computing and maybe dependent types can be used to predict the locality of the computation or something around that line
15:43:44 <Welkin> maybe the author is taking some time off to finish the rust port
15:43:51 <Hijiri> Welkin: I think phaazon said that he is focusing on Rust as the main implementation
15:44:05 <Hijiri> implementation: nice nick
15:44:14 <carter> bitemyapp: btw the designer anecdote was supposed to be in confidence rather than used in public flame wars.   Especially since it was 2nd / 3rd hand.  I later asked her directly and found it to no be true.  But also not cool.
15:44:17 <Welkin> that seems to make sense, given that graphics (and games) are resource intensive and often require explicit control over memory
15:44:25 <carter> Rust port of what ?
15:44:29 <Hijiri> luminance
15:44:30 <aztex> in supercomputers where the address space spawns across multiple machines maybe dependent types can help with data locality
15:45:43 <carter> aztex: what I think is more interesting is good memory locality and fancy layouts made easy. My focus hasband will be again , that
15:45:55 <carter> jle`: merry focus and stuff
15:46:05 <jle`> thanks :)
15:49:55 <mamay> Hi
15:50:08 <Hijiri> one letter away from maymay
15:50:17 <mamay> :)
15:50:41 <carter> glittershark: I’ve some memory locality stuff in Haskell that needs hkt and friend to be sane to engineer.
15:50:45 <mamay> That is the way my little brother pronounce my name
15:51:02 <carter> Rust lacks em so not worth it for my perf engineering tricks
15:51:10 <jle`> mamay died today. or yesterday maybe, i don't know.
15:51:40 <glittershark> yeah
15:51:52 <glittershark> compact regions etc make haskell more and more appealing for stuff like that
15:52:05 <glittershark> it's why we're using it :)
15:53:50 <mamay> what is a haskell package that offer deep learning with wide support? Thanks
15:53:57 <glittershark> TensorFlow?
15:55:05 <Hijiri> I didn't know there were tensorflow bindings
15:55:14 <glittershark> yep! maintained by Google even
15:55:37 <Hijiri> neat
15:55:38 <glittershark> https://github.com/tensorflow/haskell
15:55:58 <glittershark> it$ all very `IO` bound
15:55:59 <Welkin> "This is not an official Google product."
15:56:11 <alp> there's also https://github.com/GU-CLASP/TypedFlow
15:56:33 <glittershark> Welkin: that just means they don't support it as a business, it was written by Google engineers though
15:56:51 <alp> https://github.com/HuwCampbell/grenade too
15:57:02 <mamay> looks promising will have a look
15:57:19 <Hijiri> note grenade doesn't support GPU execution though
15:57:40 <Hijiri> also the dropout layer doesn't actually do anything
15:58:04 <Welkin> deep learning and machine learning in haskell seems to be changing rapidly
15:58:13 <Welkin> I don't work with that domain so I haven't noticed
15:58:15 <metahumor> and the new backprop library by jle`, but its low-level than "high-abstraction deep learning"
15:58:16 <Welkin> it's good to know though
15:58:26 <bitemyapp> carter: I was actually referring to a second anecdote that I had more direct knowledge of.
15:58:34 <bitemyapp> carter: not your story
15:59:19 <carter> Huh.  Sounded like the same story.  Anyways merry Wednesday.
16:01:47 <bitemyapp> carter: it's almost identical yes
16:30:37 <bash0r> Is there some function to read just a single byte at once from a file handle? Data.ByteString.hGet handle 1 seems to be a very inefficient solution to the issue.
16:31:17 <hpc> it's going to be inefficient regardless, even if you wrote it in C or something
16:31:42 <hpc> what problem are you trying to solve with this?
16:32:24 <bash0r> A small REPL that lets me edit code snippets from before. A very, very primitive editor if you want to name it like that.
16:33:31 <EvanR> yeah use hGet h 1
16:33:58 <hpc> yeah
16:34:10 <bash0r> >.< Thanks for confirmation.
16:34:12 <hpc> i think for that sort of use case i would try it anyway
16:34:30 <bash0r> Have a nice evening everybody!
16:34:34 <hpc> if it ends up actually being slow, your problem isn't going to be overhead from hGet or haskell function calls or anything like that
16:34:38 <hpc> but just the sheer number of syscalls
16:34:44 <EvanR> it will muck with the internal buffer, just like getc in C does
16:34:49 <hpc> and IO round-trips
16:34:55 <hpc> (disk latency and such)
16:35:17 <hpc> EvanR: ah, maybe it'd be fine then?
16:35:27 <bash0r> For sure. I just did not want to stress the GC with too much garbage allocation.
16:35:48 <hpc> ghc does better with lots of young garbage, so don't worry about that too much
16:35:52 <EvanR> as long as you consume it promptly itll be collected promptly
16:36:01 <bash0r> Anyway, gotta go. Thanks again!
16:36:34 <EvanR> hpc: i cant imagine an "efficient" byte by byte api... or what that would mean even
16:36:52 <EvanR> were not on a PIC micro...
16:37:43 <hpc> EvanR: yeah, i forgot about stuff like getc
17:30:14 <pavolzetor> how does recursive do extension work with stateT?
17:31:19 <EvanR> it doesnt seem to work at all
17:31:37 <EvanR> State and StateT arent listed as instances of MonadFix
17:32:20 <pavolzetor> hmm, so basically I have to runStateT, use mdo, and then unwrap
17:33:29 <EvanR> what are you trying to do
17:34:29 <pavolzetor> use the IRBuilder with local variables
17:35:01 <pavolzetor> It needs the recursive do for block contruction (if you have control flow)
17:36:17 <EvanR> whats the StateT suppose to do
17:36:31 <pavolzetor> you basically need to refer to future block so that's why they use recursive do
17:36:45 <pavolzetor> Hold environment
17:37:12 <pavolzetor> I think I will just unwrap state, run the recursive do and wrap state back
17:37:56 <pavolzetor> but I see a problem that you can declare new variable  in a block and the if/else blocks need to see it
17:39:04 <pavolzetor> not sure if you can do it with the recursive do if you are building environment as you converting to the IR
17:41:27 <EvanR> you... could pass in a read only environment to each of your recursive actions
17:42:34 <pikajude> is anyone here familiar with haskell-ci?
17:43:00 <pavolzetor> EvanR, but the current block may insert new symbols into the environment
17:44:15 <pavolzetor> for example, void main(void) { int x = 0; if (x == 0) x = 1; else x = -1; return x; }
17:44:28 <pavolzetor> you would have 4 basic blocks
17:44:44 <pavolzetor> entry -> (if branch | else branch) -> exit
17:45:21 <pavolzetor> and entry block creates new variable, but you can't close it as you do not have if and else blocks labels
17:46:20 <pavolzetor> I tried to generate names and create terminator manually, but the IRBuilder gives me an error (because of design; I have my own builder for my own IR and I do not have the problem there)
17:46:31 <EvanR> :(
17:46:52 <EvanR> why do these IR builders need recursive do?
17:46:54 <pavolzetor> one way to solve it is to have sort of change active block function
17:47:22 <pavolzetor> because they want to refer to future blocks when you add conditional break (terminator) when you close a basic block
17:47:55 <pavolzetor> I guess nobody actually used the IRBuilder for in a compiler
17:48:41 <EvanR> and by also having access to the future environment, and add to it, you create an infinite environment
17:48:59 <EvanR> like a time paradox
17:49:13 <metahumor> sounds like Tardis
17:49:15 <pavolzetor> you can't back reference variables in C
17:49:17 <pavolzetor> :)
17:49:27 <metahumor> pavolzetor: https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html
17:49:47 <EvanR> not that tardis saves you from time paradoxes :)
17:51:31 <pavolzetor> tardis is pretty cool
17:53:05 <pavolzetor> https://www.stackage.org/haddock/nightly-2018-02-17/llvm-hs-pure-5.1.2/LLVM-IRBuilder-Monad.html
17:53:25 <pavolzetor> Look at the API, I can't figure out how to do the if/else control flow
17:53:45 <EvanR> deriving MonadFix...
17:54:11 <EvanR> IRBuilderT is implemented as a StateT
17:54:28 <EvanR> over my head
17:57:22 <pavolzetor> same here, I asked for example in a github issue, so I may need to wait; I really wonder if simpler API with explicit switching between partial basic blocks would not be simpler to use; using non-beginner features just keeps me from using the library
18:05:57 <pavolzetor> actually, should I ask these questions at haskell-beginners?
18:06:05 <pavolzetor> I am not sure what is the right channel
18:06:19 <metahumor> i think if anyone knew (that was online atm) they'd answer here
18:07:01 <pavolzetor> metahumor, I see, but in general, I do not want to spam at wrong place
18:07:31 <metahumor> i think you're in the right place
18:07:54 <pavolzetor> ok
18:35:12 <ZelteHonor> I got monadiccp to compile. Took only 4 hours.
18:35:31 <ZelteHonor> Now, is it still working as before? That I don't know.
18:35:59 <metahumor> nice!! did you have to put in Applicative instances?
18:37:58 <ZelteHonor> All over the place. But that was the easy part.
18:38:23 <ZelteHonor> The library made extensive use of Overlapping Instance and some Incoherent Instance.
18:39:00 <ZelteHonor> I hope I got the OVERLAPS and INCOHERENT pragma right so that it chose the right instance.
18:49:02 <metahumor> yeah that sounds tough
18:51:40 <metahumor> i'm going through the data61 course -- it's so satisfying to get the various instances to typecheck and work properly
18:51:53 <metahumor> i just did instance Extend ListZipper =)
19:13:27 <EvanR> is json supposed to round trip a -0 ...
19:16:48 <metahumor> ??
19:17:20 <EvanR> indeed
19:18:02 <ZelteHonor> Nobody knows what JSON supposed to do.
19:18:20 <EvanR> ok thats comforting
19:35:55 <blankhart> json supposed to die getting the golden fleece & not round trip
19:36:03 <metahumor> +1
19:36:25 <blankhart> hera helped him tho
19:37:26 <EvanR> hah
19:51:23 <x0x0_> Hi, I come from clojure background and is very much interested in haskell, reading learn u a Haskell and have started with stack and cabal. Any on being more productive in haskell
19:53:23 <kadoban> x0x0_: Was there a word or two left out of the last sentence? I can't tell what you meant. Or mabye it got cut off?
19:54:07 <metahumor> if you
19:54:17 <metahumor> if you're willing to spend some money, The Haskell Book is great
19:54:23 <metahumor> @where hpffp
19:54:23 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
19:55:39 <pavolzetor> I am perplexed why this hangs, http://lpaste.net/362770
19:55:54 <pavolzetor> How would I debug it? Is there some sort of call trace feature?
19:56:00 <cheers> HPFFP++
19:57:03 <Axman6> pavolzetor: should you be using state or state' in bind?
19:57:18 <byorgey> pavolzetor: you define state' but you never use it.
19:57:24 <kadoban> pavolzetor: I would imagine you meant state' on line 10
19:57:56 <Cale> Also, I take it you eventually define an instance of Monad somewhere?
19:57:59 <pavolzetor> I use state', I forgot to copy last character, sorry
19:58:04 <metahumor> lol i was about to say the smae thing
19:58:22 <metahumor> we all perked our ears up
19:59:03 <pavolzetor> I updated the lpaste
19:59:40 <Cale> Clearly there's a bunch of code that you're not showing us, because that doesn't compile, let alone hang ;)
19:59:54 <metahumor> we're missing "emit"
20:00:01 <Cale> yeah, that too
20:00:03 <pavolzetor> Ahh, it is a larger project, let me add those
20:00:25 <metahumor> "do sequence" looks weird to me there
20:00:43 <Cale> It's weird, but fine
20:00:49 <Cale> do x = x
20:02:03 <pavolzetor> Missing code should be in
20:02:22 <pavolzetor> Cale, I copied it from larger piece
20:04:05 <Cale> It doesn't hang
20:04:42 <Cale> *Main> (gen ((do sequence [emit ("movq ")]) :: Generator [()])) ("", 0)
20:04:42 <Cale> ([()],("        movq \n",0))
20:06:20 <pavolzetor> that's odd
20:06:49 <pavolzetor> here it runs out of memory and crashes
20:06:57 <pavolzetor> (and hangs while it swaps)
20:07:17 <kadoban> On literally that code only, or is there more?
20:07:36 <pavolzetor> no, I test that code only
20:08:01 <pavolzetor> Originally it was bigger piece but I figure out which part it is
20:08:09 <pavolzetor>  (gen ((Control.Monad.sequence [emit ("movq ")]) :: Generator [()])) ("", 0)
20:08:21 <pavolzetor> this just hangs, runs out of memory, and crashes
20:08:31 <Cale> Oh, oops, sorry, I didn't copy the new code exactly. It doesn't hang, it complains about the fact that you didn't define (<*>)
20:08:55 <Cale> *Main> (gen ((do sequence [emit ("movq ")]) :: Generator [()])) ("", 0)
20:08:55 <Cale> *** Exception: foo.hs:20:10-30: No instance nor default method for class operation <*>
20:09:12 <pavolzetor> hmm, why do I not get any exception?
20:09:18 <pavolzetor> really odd
20:09:18 <Cale> (I'd put the instances in myself earlier, and only copied over the definition of emit)
20:09:35 <mjrosenb> I need some help running cabal repl.
20:09:39 <Cale> Does defining (<*>) = ap  make it not die for you?
20:10:14 <Cale> I'm still quite suspicious about this :)
20:10:24 <mjrosenb> I get this error:
20:10:25 <mjrosenb>     Could not find module ‘System.Random’
20:10:26 <mjrosenb>     Use -v to see a list of the files searched for.
20:10:40 <mjrosenb> which doesn't make a whole lot of sense-- isn't that from base?
20:10:48 <Cale> No, it's from random
20:11:01 <pavolzetor> that solved it
20:11:06 <mjrosenb> or not
20:11:07 <mjrosenb> All the requested packages are already installed:
20:11:08 <mjrosenb> random-1.1
20:11:30 <pavolzetor> what the heck, I get warning about missing method in ghci
20:11:50 <pavolzetor> but I thought it is warning, not error; what is ghc doing when there is no <*>?
20:12:04 <Cale> pavolzetor: Which version of GHC? Perhaps there's a default method implementation for (<*>) in the Applicative class.
20:12:08 <pavolzetor> thanks Cale, you saved me ton of time
20:12:39 <Cale> mjrosenb: hm, but is random a dependency of your project? I think cabal repl only exposes the packages which are deps.
20:13:16 <pavolzetor> 8.2.2
20:13:39 <pavolzetor> I really want to understand what function does ghci put there when <*> was missing
20:13:56 <mjrosenb> Cale: derp, that's it.
20:14:06 <Cale> pavolzetor: this will explain it for you: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.1.0/src/GHC-Base.html#Applicative
20:14:39 <Cale> pavolzetor: There are default implementations of (<*>) and liftA2 in terms of each other now, so that you can define one and the other will be defined in terms of it
20:14:55 <Cale> pavolzetor: But leave them both out, and the recursion doesn't get anywhere.
20:15:18 <pavolzetor> I see, that should be a compile error :)
20:16:22 <pavolzetor> so when you do not request the result it would never execute that path
20:16:25 <Cale> There is a MINIMAL declaration
20:17:26 <Cale> So if you have the appropriate warning turned on it should tell you
20:17:36 <Cale> (and you can turn that into an error with -Werror)
20:17:43 <pavolzetor> It told me, but I ignore warnings out of principle
20:18:09 <kadoban> That's not a terribly good idea in haskell
20:18:49 <pavolzetor> I will use -Werror from now on; I think warnings should not be optional
20:19:20 <kadoban> There are a decent number of things in haskell/ghc that I really wish were errors. But alas
20:20:17 <Cale> It should also be an error to not fully initialise a record
20:33:38 <jp_rider> Is there a way to add an if to my cabal file that depends on a dependency's version? Something like: if (http-conduit >= 2.3.0)
20:34:08 <Axman6> I believe you can, have you checked the cabal manual?
20:34:15 <ertes> dminuoso: yeah, much better
20:34:27 <kadoban> Not sure you can, you could have two different ranges depending on a flag I guess
20:36:43 <jp_rider> Where in the manual does it describe cabal file syntax? I haven't been able to find good documentation for this.
20:37:47 <jp_rider> FYI, I only want to add unliftio-core as a dependency when http-conduit is 2.3.0 to maintain backwards compatibility
20:45:55 <geekosaur> you typically do this with a flag, and a conditional on that flag. one leg specifies dep on 2.3.0 and unliftio-core; other leg is dep on != 2.3.0
20:46:58 <MarcelineVQ> ^ conditional docs https://cabal.readthedocs.io/en/latest/developing-packages.html#conditional-blocks
20:48:14 <geekosaur> thanks (I was still digging for it. local network is being a bit slow)
20:51:12 <jp_rider> geekosaur: This means the user has to manually specify the flag though if they're running the old version of http-conduit, right?
20:51:38 <geekosaur> no; it will determine the leg to use by the version available, and set the flag accordingly
20:51:49 <geekosaur> seems backwards, but think of it as laziness
20:52:10 <geekosaur> or maybe the list monad
20:52:16 <jp_rider> MarcelineVQ: Thanks!
20:53:00 <geekosaur> you can still find packages which have a "small-base" flag and use it this way, for compatibility with back when a bunch of packages were split out of base and had to be added as separate dependencies
20:53:38 <geekosaur> (perusing cabal files on hackage can be quite instructive)
20:53:54 <pikajude> couldn't you always list unliftio-core as a dependency?
20:54:11 <pikajude> unless i'm misunderstanding what the dependency situation is
20:54:45 <pikajude> because apparently 2.3.0 requires unliftio-core, so if your package also requires unliftio-core you can just list it regardless
20:54:58 <jp_rider> geekosaur: so I can add an additional flag and set manual to false? Then customize my build-depends for each case?
20:55:12 <geekosaur> "manual: False" is the default
20:55:37 <jp_rider> Ok cool, I'll try that.
20:56:32 <jp_rider> pikajude: It might compile, but I'd prefer not to include an unused dependency
20:57:15 <pikajude> what do you need unliftio-core for, other than as a http-conduit dependency?
20:58:22 <jp_rider> That's all it's need for (>= http-conduit 2.3.0)
20:59:49 <pikajude> but http-conduit-2.3.0 lists it as a dependency
21:00:00 <pikajude> so it would get installed anyway
21:00:10 <pikajude> if your package depends on http-conduit
21:01:33 <jp_rider> unliftio-core isn't necessary if the user links a lower version of http-conduit
21:02:08 <pikajude> but why is unliftio-core your concern at all
21:02:20 <pikajude> isn't this what dependency resolution is for
21:03:28 <jp_rider> My types slightly change to depend on unliftio-core when http-conduit >= 2.3.0
21:03:45 <jp_rider> So I need it in my cabal file
21:03:45 <pikajude> oh. lol
21:03:56 <jp_rider> yea :(
21:04:00 <pikajude> so that's actually what you need it for
21:04:08 <pikajude> then the flag solution given is the best one
21:04:41 <pikajude> as far as I understand it, though, you can't write a type signature that refers to a name in a module that isn't listed in your cabal file
21:04:44 <pikajude> because you can't import that module
21:04:50 <pikajude> how do the types change exactly?
21:05:30 <jp_rider> I'll push a commit soon, but I use CPP
21:05:41 <pikajude> sure
21:05:45 <pikajude> so can't you wrap the imports in CPP as well?
21:05:53 <pikajude> oh, wait, nvm
21:05:55 <pikajude> that doesn't make any sense
21:05:58 <pikajude> lol
21:06:03 <pikajude> ok, yeah, the flag solution is the best one
21:08:00 <woodson> anyone knows how to fix a git ref?
21:08:21 <woodson> I know its not the right place.. though I'd ask
21:09:36 <amalloy> "fix a git ref" isn't really a meaningful question anyway. better to try #git
21:10:07 <jp_rider> The flag solution doesn't seem to be working. It seems like the default flag value is being used. I get the following: http-conduit-2.3.0 from stack configuration does not match <2.3.0 (latest matching version is 2.2.4)
21:10:22 <jp_rider> I pushed my attempt here: https://github.com/jprider63/docker-hs/commit/527cb52fb534b3cb808f23c83c07ab2054479a46
21:12:07 <mjrosenb> hrmm, is this a good place to ask questions about haskell-mode in emacs (and if not, /where/ is?)
21:12:31 <jp_rider> You can change "extra-deps: [http-conduit-2.3.0]" in the stack.yaml to get the error
21:13:56 <kadoban> jp_rider: Easy way is just to change the default, or if you have to allow different stack resolvers, set the flag manually in the stack.yaml to match.
21:14:07 <kadoban> I don't think stack even does the whole nondeterministic flag resolution thing.
21:14:11 <kadoban> (could be wrong though)
21:17:19 <pikajude> lol, wait a second, so http-conduit exposes decls with types that refer to names you can't import?
21:17:42 <pikajude> that seems in poor taste
21:19:13 <jp_rider> kadoban: Then won't every end user need to manually specify the flag (if they're using http-conduit <= 2.3.0)? That sort of defeats the purpose. If this is a stack problem, I can create an issue there
21:19:48 <pikajude> well, you certainly can't have dynamic behavior in a cabal file based on the resolved versions of dependencies
21:20:36 <kadoban> jp_rider: This is an executable, right? If they're building it, they should be using the stack.yaml to do so anyway I'd think
21:21:01 <kadoban> That's kind of what it's for. Or if it's in a resolver, I'd just make the flag default match what it should be.
21:21:02 <jp_rider> No, it's a library
21:21:11 <jp_rider> http://hackage.haskell.org/package/docker
21:22:53 <kadoban> Not sure then
21:28:51 <jp_rider> geekosaur: Are you sure cabal automatically determines which flag to use based on versions available? HStringTemplate has a small-base flag, but cabal fails due to dependencies
21:28:55 <jp_rider> cabal: Encountered missing dependencies:
21:28:55 <jp_rider> base <3, old-locale -any, old-time -any, parsec -any
21:29:42 <Axman6> <3 base
21:30:13 <geekosaur> check your version. I just pulled up the latest and it has neither the flag nor base < 3 support
21:30:37 <geekosaur>   build-depends:   syb, base >= 4, base < 5,(...)
21:30:53 <jp_rider> I downloaded HStringTemplate-0.3
21:31:00 <jp_rider> https://hackage.haskell.org/package/HStringTemplate-0.3
21:31:15 <jp_rider> The old cabal file should still work, right?
21:31:44 <jp_rider> The docs do say it should backtrack… https://www.haskell.org/cabal/users-guide/developing-packages.html#resolution-of-conditions-and-flags
21:32:31 <kadoban> jp_rider: Maybe the other forks failed as well and then it just gives a random dependency error from any of them.
21:32:39 <kadoban> (guessing)
21:33:07 <geekosaur> I would expect it to. But yes, sometimes dependency resolution in these cases gets ... hairy. Not to say scary.
21:33:17 <geekosaur> cabal -v3 is sometimes needed to decipher wtf is going on
21:34:25 <geekosaur> (this is especially fun when a confused set of dependencies causes it to emit a failed dependency like (foo < X && foo > X+1))
21:34:44 <jp_rider> kadoban: I don't think that's the issue. If I change the flag default, it compiles fine
21:34:51 <jp_rider> I'll try -v3
21:50:03 <jp_rider> I have the -v3 output for HStringTemplate-0.3, but maybe this isn't meaningful since I can't get either flag value to compile. I'll try to get my package to compile with cabal
22:01:58 <mightybyte> Does base have a function for generating a temporary file name?
22:02:05 <mightybyte> For some reason I'm not finding it.
22:02:31 <Axman6> @hoogle temp
22:02:31 <lambdabot> module System.Posix.Temp
22:02:31 <lambdabot> module System.IO.Temp
22:02:31 <lambdabot> module System.PosixCompat.Temp
22:02:46 <Axman6> @hoogle tempFile
22:02:46 <lambdabot> System.Console.Concurrent.Internal tempFile :: OutputBufferedActivity -> FilePath
22:02:46 <lambdabot> Data.Conduit.Shell.PATH tempfile :: ProcessType r => r
22:02:46 <lambdabot> Util.System tempfile :: String -> IO (FilePath, Handle)
22:02:56 <mightybyte> System.IO.Temp doesn't seem to be in base
22:03:06 <cocreature> mightybyte: base doesn’t have one afaik
22:03:14 <mightybyte> cocreature: Ok, thanks.
22:03:18 <cocreature> there is one in `unix` and there is the `temporary` package
22:04:40 <mightybyte> The one in unix opens the file, which is not what I want.
22:30:56 <batman_> any reason why i'm getting this error "Main: src/Node.hs:(44,5)-(52,65): Non-exhaustive patterns in case" i don't see passing any pattern which is not already dealt with
22:31:19 <kadoban> batman_: We'd have to see the code most likely
22:33:30 <batman_> kadoban : this is the block its mentioning
22:33:36 <batman_> kadoban : http://lpaste.net/362775
22:34:25 <metahumor> batman_: it thinks, "what about when I get back something that doesn't contain "PING" or "FIND_NODE" "?
22:34:38 <kadoban> batman_: There's like an infinite number of cases that doesn't handle, anything where the first element of the tuples isn't "PING" or "FIND_NODE"
22:35:11 <metahumor> batman_: you should probably use a sum type for that first item in the tuple like "data MessageType = Ping | Pong | FindNode" which is fully enumerated
22:35:30 <metahumor> and then you can just case match on those instead of having "stringly-typed" things
22:36:45 <batman_> kadoban : but i'm giving it PING and it is giving me response corresponding to PING i.e PONG but after that its giving error
22:37:09 <kadoban> batman_: Probably some other call of it
22:37:25 <metahumor> are you getting an error when you're running it, or a warning when compiling it, or both?
22:38:10 <dminuoso> So I have a function like this: neighbours p = [p `mappend` V2 x y | x <- [-1..1], y <- [-1..1], (x,y) /= (0,0)]
22:38:41 <dminuoso> That I want to memoize. I cant wrap my head around the wiki examples how to make this thing go fast. Is it wrong to just throw an IORef at it?
22:39:47 <metahumor> you could just throw them in a Map
22:40:14 <dminuoso> metahumor: Where do I keep that map? I mean the recursion happens a few levels above, and I kind of dont want to fiddle that map throguh
22:40:35 <dminuoso> Though I just realized IORef wont help me because Im not in the IO monad
22:40:41 <batman_> metahumor : yeah when i'm running it apparently i added a otherwise and it is getting exicuted that means it getting called with two defined cases
22:41:00 <metahumor> batman_: "otherwise" doesn't work inside a case match
22:41:05 <kadoban> There are memoization libraries (or you can write it yourself of course) to do this kind of thing. I am ... somewhat skeptical how much it'll help though.
22:41:06 <metahumor> batman_: "otherwise" just means "True"
22:41:18 <dminuoso> :t otherwise
22:41:19 <lambdabot> Bool
22:41:26 <dminuoso> @src otherwise
22:41:26 <lambdabot> otherwise = True
22:41:35 <cocreature> I’d like to see the code where memoizing neighbours is actually an improvement
22:41:43 <metahumor> batman_: if you want to have a "catch-all", the syntax is "case blah of {"PING" -> "PONG"; _ -> doDefault}"
22:41:47 <cocreature> I highly doubt that is the bottleneck
22:41:50 <dminuoso> cocreature: It's neighboring coordinates. It's poorly phrased.
22:41:56 <metahumor> batman_: i.e. that underscore thing
22:41:57 <[Leary]> It really does work as a catch-all in a case match, just not in the intended fashion.
22:42:02 <dminuoso> cocreature: About 15% of my programs time is spent in that right now.
22:42:10 <cocreature> huh interesting
22:42:56 <kadoban> dminuoso: How big of a range does 'p' traverse?
22:42:57 <cocreature> dminuoso: maybe try writing the list of offsets explicitely instead of relying on list comprehensions?
22:43:27 <metahumor> i was reading a nice blog post recently about how to use continuations to model dynamic programming algos such that you don't have to deal with the dependency graph
22:43:36 <metahumor> trying to find it
22:43:49 <kadoban> If it's a moderate to small range, you could just make an array of the values and look up in the array, that could be an effective memoization strategy.
22:44:05 <cocreature> there are also packages like MemoTrie
22:44:50 <kadoban> My fear with the general ones would be that you might spend as much time looking up the correct location in the memoization data structure as you would just recomputing. Depending what they do exactly.
22:45:32 <metahumor> http://jelv.is/blog/Lazy-Dynamic-Programming/
22:47:25 <kadoban> metahumor: Yeah, that kind of stuff is pretty cool. You can go even fancier and abstract away the whole memoization part, like what MemoTrie is doing there. So you write your code almost completely naturally as just a recursive function, then just say "hey, memoize this!" and it's magically dynamic programming.
22:47:32 <kadoban> The constants go to hell though.
22:48:00 <metahumor> yeah, there are also MemoCombinators with "memo2" and "memo3"
22:48:41 <kadoban> I wrote a quick little "library" for that in my competitive programming nonsense, and it's pretty fun. I usually don't get to use it though, or only for exploration that I then have to reimplement a more performant way.
22:48:42 <metahumor> but for simple flood-fill-like algos, writing out the array code isn't too bad, especially because it's structured so similar to trad dynamic programming algos
22:50:02 <metahumor> "magic" -- perhaps it should be a "Memoized" Applicative/Monad
22:50:18 <metahumor> or maybe Comonad
22:50:19 <metahumor> idk
22:56:29 <dminuoso> And that's with an explicit list of offsets.
22:59:24 <batman_> metahumor : but why is it even giving me that error i have checked the entire program nothing else is getting written to that chan which doesn't match the listed cases
23:00:05 <metahumor> i'd switch to the "data MessageType = Ping | ..." sumtype first
23:00:22 <metahumor> then you'll see where some types are not being dealt with
23:00:49 <metahumor> my guess is that somewhere, you're sending the empty list [] which is a valid String ""
23:53:19 <epta> how to get a nicely formatted string of wreq's Request and Response? just for logging purpose
23:53:44 <phadej> `show` them
23:54:06 <phadej> or was it wai-request/response which are formatted. hmm
23:56:22 <dminuoso> Mmm, so the Haskell 2010 report does not list Applicative. Is this formally a GHC extension then?
23:59:20 <phadej> dminuoso: yes, it's a incompatible extension to Prelude in GHC
