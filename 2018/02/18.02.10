00:00:00 <cocreature> `Guest00000: geekosaur already told you the solution: use exitFailure
00:00:19 <cocreature> or "exitWith" if you want a specific exit code
00:01:18 <geekosaur> "die" is by definition not normal program completion. which is part of why it's not done as a return code. (the rest has to do with the conceptual meaning of IO. you are not returning an exit status, but a program for an impure evaluator to run)
00:02:48 <`Guest00000> i'm content with die now
00:02:58 <`Guest00000> it's quite elegant here
00:04:26 <geekosaur> and yes, it;'s fairly easy to write. or other variants; I have some code that defines (...) as a stub that prints a useful message and exits instead of "Exception: undefined" or whatever
02:05:11 <Barry_> hi guys, I am prepping for my exam in 5 days
02:05:51 <Barry_> for that I am looking at exams from the past. One of the tasks is to eval "map (\(x,y) -> x+y)$ zip [0,1..] [1..4]"
02:06:24 <Barry_> my question is, is the zip [0,1..] [1..4] evaluated fully or only evaluated as soon as values are needed?
02:06:52 <Taneb> Barry_, the latter
02:06:59 <dminuoso> Barry_: If values are needed, and only as many values are needed.
02:07:04 <Barry_> thanks
02:09:10 <dminuoso> Barry_: Think about it differently. What does it mean to fully evaluate zipping two infinite lists?
02:09:20 <dminuoso> That would take an awful long time, and a lot of memory. =)
02:09:40 <Barry_> yeah but its not infinite
02:09:44 <Barry_> one of them is fiinite
02:09:50 <Barry_> that is why I wasnt sure
02:10:09 <Barry_> but it makes sense that due to the lazyness it would get to the map
02:10:25 <Barry_> and there eval the head of the zipped list
02:10:29 <Barry_> every iteration
02:10:49 <ski> Barry_ : so, it depends on how the result of that `map' call will be used. if you're going to e.g. print the whole resulting list, then that will in turn cause all the recursive calls of `zip'. it will just omit evaluating more elements of `[0,1..]' at some point. but if you're only demanding say the head of the `map' result, then only the initial call to `zip' will be performed, not any recursive calls
02:11:43 <ski> s/evaluating/producing/
02:12:03 <Barry_> thanks!
02:12:34 <ski> since `[1..4]' has four elements, and `zip' matches corresponding elements of the two lists, you know that at most four elements of `[0,1,..]' will be produced
02:13:59 <ski> (and `[0,1..]' is syntactic sugar for `enumFromThen 0 1', so we're really talking about how many recursive calls this will cause)
02:14:59 <Barry_> So here a question about kinds
02:15:13 <Barry_> The kind of Either [Int] is *->*
02:15:27 <Barry_> So my issue here is
02:16:10 <Barry_> that how I understood is that this describes the datatype you got. In this case it takes one param and transforms it to a type
02:16:15 <Barry_> hence *->*
02:16:21 <Barry_> but Either is defined as
02:16:27 <Barry_> data Either a b = Left a | Right b
02:16:51 <Barry_> so the Constructor is Left a or Right b
02:17:00 <dminuoso> Barry_: you are conflating type and data constructors.
02:17:01 <Barry_> how is Either *->*->*
02:17:03 <robstr> right, Either is the type constructor
02:17:21 <Barry_> ohhh
02:17:25 <dminuoso> Barry_: kinds is to types what types are to values.
02:17:30 <ski> `Either [Int]' takes one *type* and "computes" a type
02:17:42 <Barry_> I see
02:17:43 <Barry_> got it
02:17:54 <ski> `Left' takes a *value* of type `a', and "computes" a value of type `Either a b'
02:17:56 <dminuoso> Barry_: And you can have higher kinded magic too!
02:18:02 <dminuoso> :t StoreT
02:18:03 <lambdabot> error:
02:18:03 <lambdabot>     • Data constructor not in scope: StoreT
02:18:03 <lambdabot>     • Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
02:18:04 <dminuoso> :k StoreT
02:18:05 <lambdabot> error:
02:18:05 <lambdabot>     Not in scope: type constructor or class ‘StoreT’
02:18:05 <lambdabot>     Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
02:18:12 <dminuoso> err.
02:18:15 <dminuoso> :k StateT
02:18:16 <lambdabot> * -> (* -> *) -> * -> *
02:18:18 <dminuoso> That =)
02:18:21 <ski> (i quote "computes", because in this case there isn't much computation going on, it's more like "storing" or "stuff away")
02:18:42 <dminuoso> ski: I guess it's in the sense that with type families you can do fancier things?
02:18:58 <ski> yep, type families compute, in a nontrivial sense
02:19:18 <Barry_> Its a rly powerfull thing haskell got here but GODDAMIT is it annoying
02:19:20 <Barry_> and confusing
02:20:07 <ski> (if you compare with Prolog, we often say that it has no functions. what we mean by that is that it has no (nontrivially) *computing* function. you do have "functors" which are like data constructors, they just store data. in most cases, to do any interesting computation, you need to resort to predicates/relations, not just functors)
02:20:29 <ski> Barry_ : hm, what strikes you as annoying, here ?
02:20:32 <dminuoso> When you say functor, do you mean function?
02:21:00 <dminuoso> But I guess every function also happens to be a functor. :D
02:21:01 <ski> the technical term in Prolog is "functor". it correspond closest to "data constructor" in Haskell
02:21:07 <dminuoso> AH
02:21:44 <Barry_> nothing specific about what we talking here, but the consequenses about what is all possible if you look at it in a Mathematical sense
02:22:17 <ski> (some data constructors in Haskell are not functions, like `Nothing' and `False'. but some are, like `Just',`Left'. similarly some functors in Prolog are just "constants", and some are, strictly speaking, functions. it's just that they never do any nontrivial interesting computation, they just store data, like a data constructor function like `Right')
02:24:33 <ski> Barry_ : well, it is an interesting perspective on things, i believe. and sometimes one that may be hard to get to grips with, initially. however, worthwhile to gain the perspective, even for your programming in other languages that don't tend to emphasize it like this, or see it from this POV
02:25:35 <dminuoso> ski: Even in my Ruby code Ive started to write so much pure code. Makes refactoring a so much more fun.
02:25:52 <dminuoso> Equational reasoning is priceless.
02:26:05 * ski nods
02:26:17 <Barry_> yeah I know what benefits it hast, but to be honest you can code compicated stuff in other languages (like java) without really knowing how types and stuff like that is being resolved in the background
02:26:48 <Barry_> If you roughly know what is happening, it will be enough to make it all clean and nice
02:27:01 <ski> part of the point of declarative programming (including functional programming, like Haskell, and logic programming, like Prolog), in general, is to enable more powerful means of reasoning and refactoring about code
02:27:09 <Barry_> at least thats what I think, but then again...we were thaught that haskell is for much more complicated tasks
02:27:20 <Barry_> yeah
02:28:17 <ski> it's a problem that we, as programmers, don't talk enough about "reasonability" of languages, libraries and systems, in the sense of how easy they are to reason about. and often talk too much about the expressivity of them, how easy it is to express complicated things (which is not the same as reasoning about them)
02:29:06 <ski> there is usuall a trade-off here, where increasing one of "reasonability" and expressivity, typically lowers the other one (cf. "Rule of least power")
02:29:54 <ski> sometimes, people manage to find the "right abstraction" for something, that simultaneously simplifies both side, both enabling more effective reasoning, *and* more expressivity
02:30:24 <ski> but that doesn't happen that often, unfortunately. so one should be aware of this trade-off
02:31:14 <Barry_> I feel like thats nothing that can be tought. Thats where you need to work and collect experience (let it be chosing the wrong enviroment for a certain problem)
02:32:53 <ski> .. e.g., some people in the wider community are starting to realize that mutable state is in fact often a large inhibitor of reasonability, and producer of bugs. however, this is often not that explicitly understood. one consciously doesn't tend to grasp that well the connection between the cause (mutable state) and the effect (hard to reason about and refactor code)
02:34:00 <Barry_> ehm quick question :D. Why cant i make this deriving : "data D a b = C b (a Int) b"
02:34:15 <ski> (and i don't want it to come off as functional programmersm, or modern static typing proponents, having all the answers. i'd be very surprised if there weren't important lessons that we could learn from other subcommunities)
02:35:23 <ski> Barry_ : that looks like an ok data type definition. what exactly doesn't work ? is there an error message ?
02:36:15 <Barry_> here a question about your oppinion: What do you think about integrating languages into each other, like scala code can be written into java or Kotlin ...and C++ (?) code can use the garbage collector of haskell
02:36:25 <Barry_>  • Could not deduce (Show (a Int))         arising from the second field of ‘C’ (type ‘a Int’)       from the context: Show b         bound by the deriving clause for ‘Show (D a b)’
02:37:04 <ski> oh, so you *are* talking about *deriving* some type class(es), here `Show'
02:37:21 <ski> (that wasn't completely evident from your question, though i was suspecting it)
02:37:22 <int-e> Barry_: try StandaloneDeriving and  deriving instance (Show (a Int), b) => Show (D a b)?
02:37:47 <Barry_> I dont want to do it explicitly
02:37:56 <Barry_> I just wonder why I cant use the simple solution
02:38:13 <Barry_> which was supposed to just print the components
02:39:21 <int-e> At a guess, only "simple" Show restrictions (Show <variable>, but not Show (a Int)) for instances are handled automatically, but I don't actually know what the precise limitations are.
02:39:37 <kudomarkos> hello
02:39:54 <kudomarkos> Can i make some questions?
02:40:09 <int-e> Barry_: While with standalone deriving, you can provide your own constraints.
02:40:16 <kudomarkos> i need to make a function superior order
02:40:18 <ski> hm it seems that merely enabling `FlexibleContexts' doesn't work here
02:41:08 <kudomarkos> but the question is... what TYPE is a symbol??? I mean de 'plus' simbol + or de multiplicative *
02:41:23 <Barry_> what does (a Int) mean
02:41:41 <kudomarkos> something:: symbol->Int->Int
02:41:41 <Barry_> I thought its a function "a" which computes an Int to sth else
02:41:46 <int-e> Barry_: C b (a Int) b <-- it refers to the second argument of C here
02:41:50 <ski> Barry_ : `b' could be `Bool', and `a' could be `Either [Int]', e.g.
02:42:00 <kudomarkos> Barry_: i will try with a
02:42:27 <ski> so, with D (Either [Int]) Bool', `Show (a Int)' would become `Show (Either [Int] Int)'
02:43:05 <ski> kudomarkos : i think Barry_ was talking about something else
02:43:43 <ski> kudomarkos : if that's what you mean, you can ask about the type of addition in the interactor like `:type (+)'. with lambdabot in this channel, one'd write
02:43:46 <ski> @type (+)
02:43:47 <lambdabot> Num a => a -> a -> a
02:44:11 <kudomarkos> uhm Thank you ski
02:44:18 <ski> kudomarkos : .. or am i misunderstanding what you're wondering about ?
02:44:21 <int-e> Barry_: in any case, this is what I had in mind: http://lpaste.net/362330 ... and I'd still much prefer that to writing my own Show instance.
02:44:29 <kudomarkos> but i can understand what lambdabot answered me
02:44:31 <kudomarkos> hahaha
02:45:17 <kudomarkos> but again the famous 'a'
02:45:34 <ski> `a' there is a type variable
02:45:51 <int-e> . o O ( it's "a" type? (scnr) )
02:46:57 <ski> `(+) :: Num a => a -> a -> a', means that `(+)' is a function that accepts two arguments, both of (the same) type `a' (a type variable, so not fixed/specific), and returns a result of the same type `a', *provided* that the actual type we use in place of `a' is "an instance of `Num'", meaning that it supports some basic numeric/arithmetic operations
02:47:40 <ski> e.g., `a' could be `Int', since `Int' is an instance of `Num', and then we get `(+) :: Int -> Int -> Int' as a specific example of how `(+)' could be used
02:47:59 <ski> or `a' could be `Double', and then we'd get `(+) :: Double -> Double -> Double'
02:48:27 <kudomarkos> Ok
02:48:32 <Barry_> oh thats what you meant
02:48:37 <int-e> ski: and a flame ware about all the laws that instance violates.
02:48:38 <kudomarkos> so i can't write:
02:48:56 <kudomarkos> something::a->Int->Int
02:49:04 <kudomarkos> I should use:
02:49:29 <Barry_> Ski: thanks, we never actually learned about that paradigma (?). I though you meant creating an instance of Show
02:49:36 <kudomarkos> something::(a->a->a)->Int->Int
02:49:43 <ski> when we use addition `(+)' with values of a specific types, then a *single* type will be used in place of `a'. so we will never have things like `(+) :: Double -> Int -> Double' for a particular use of addition
02:50:30 <kudomarkos> ski, I understand now. Thanks
02:50:40 <kudomarkos> I am not going to mix types
02:50:53 <ski> Barry_ : hm, i'm not quite sure what you're responding about now. my last remarks about `a' weren't about your example data type `D a b', but connected to what kudomarkos was asking about, regarding addition and multiplication
02:50:56 <kudomarkos> i only want to doing calls like
02:51:05 <kudomarkos> something + 3
02:51:06 <kudomarkos> or
02:51:10 <kudomarkos> something * 3
02:51:17 <ski> kudomarkos : i don't know what your `something' is
02:51:22 <kudomarkos> a function
02:51:39 <merijn> kudomarkos: Note that numerical literals like 3 are polymorphic
02:51:45 <merijn> > 3 :: Double
02:51:47 <lambdabot>  3.0
02:51:56 <Barry_> was answering to your link that showed what you meant by standalone show
02:52:03 <ski> yeah, but since i don't know how it's defined, or how it's going to be used (what it should do), i can't determine whether any of the type signatures you gave for `something' would be allowed or not
02:52:42 <kudomarkos> ski https://pastebin.com/TV4d0Z5a
02:53:26 <kudomarkos> factorialN and sumaN (both functions) are very similar... I need to create algoN function, superior order
02:53:45 <ski> kudomarkos : oh, i see what you're doing
02:54:02 <ski> (btw, i think you should inspect your base case for `algoN' again)
02:55:08 <ski> kudomarkos : note that `a1 + sumaN (a1-1)' (your extra brackets were redundant there) is the same thing as `(+) a0 (sumaN (a1-1))'. we're only switching from infix operator notation, to the usual prefix notation of function calls
02:56:37 <kudomarkos> so the + is written BEFORE, instead of 'betwee'
02:56:44 <kudomarkos> ok, thanks a lot ski
02:56:44 <kudomarkos> :D
02:57:09 <ski> kudomarkos : so, if you wrote `simbolo numero (...)' (or even `fonction numero (...)', or however "function" is spelled in your language) instead of `numero simbolo (...)', then if you call `algoN (+) 5', you can see `simbolo' (or `fonction') being replaced by `(+)', resulting in `(+) 5 (...)' being used, as you wanted
02:58:20 <ski> kudomarkos : an alternative would be to replace `simbolo' with a symbolic *operator*, iow write `algoN (<+>) numero = ...', say. then instead of `(<+>) numero (...)' you could go back to the infix `numero <+> ...'
02:59:09 <ski> here `(<+>)' would be a "variable operator", standing in for whatever you want to pass, should it be `(+)' or `(*)' or something else (like e.g. `max')
03:00:20 <kudomarkos> so instead of 'a' i use '(<+>)'
03:00:42 <kudomarkos> hehehehe, sorry, my english is terrible and very slow
03:00:50 <kudomarkos> Thanks so so so ski
03:00:51 <kudomarkos> :D
03:00:55 <ski> Barry_ : ok, though i think int-e actually did more for showing that
03:01:40 <ski> kudomarkos : well, you will need to adapt the `a' part of the type signature of `algoN', yes (and not by writing `(<+>)' in the type signature)
03:21:41 <kudomarkos> ski, i got, finally!!! Thanks SOOOOOO much baby :D I am really happy
03:43:14 <merijn> ugh...I wish I hadn't broken type querying in my editor :\
05:39:32 <seanparsons> Is there a way to get a locally run hoogle server to only include packages/versions that are part of your project?
06:52:02 <dminuoso> What exactly is Control.Comonad.duplicate for Store?
06:52:19 <dminuoso> I have implemented everything, but Im not 100% sure whether my duplicate implementation is correct, or what it exactly means: https://gist.github.com/dminuoso/a331ff0ee8f661cbc2895b421e46658d
06:52:44 <dminuoso> My monad intuition says that it maps each position to a Store has seek'ed to that position
07:01:43 <ixxie> how would I import a data type like data Bot = Bot { socket :: Handle } ?
07:01:47 <dminuoso> Ohh. Yes indeed.
07:01:51 <dminuoso> extend cf = fmap cf . duplicate
07:02:23 <ixxie> I tried doing a simple import ModuleName ( Bot ) but then the socket is not found
07:05:15 <dminuoso> ixxie: Mmm, isn't that just syntax sugar for defining some function `socket :: Bot -> Handle; socket (Bot s) = s` ?
07:07:00 <ixxie> dminuoso: honestly I have no idea, I just followed https://wiki.haskell.org/Roll_your_own_IRC_bot and I am trying to make it my own
07:07:38 <dminuoso> ixxie: I wonder whether Bot(..) would give you its field accessors too.
07:08:09 <dminuoso> ixxie: Yeah it seems so. :)
07:08:26 <dminuoso> Or if you prefer it explicitly: Bot(socket)
07:08:41 <lyxia> Bot(Bot(socket))
07:09:00 <ixxie> so wait
07:09:11 <lyxia> The outer Bot is the type, the inner Bot is the constructor.
07:09:22 <ixxie> if I import Bot, I access socket by writing Bot(socket)
07:09:24 <dminuoso> lyxia: that fails to even parse
07:09:36 <dminuoso> Oh
07:10:07 <dminuoso> Anyway. Comonads are fun ?)
07:10:39 <lyxia> ah my bad...
07:11:00 <lyxia> I thought the accessor would be part of the constructor but indeed that doesn't parse...
07:11:21 <lyxia> Nevermind!
07:11:35 <dminuoso> ixxie: No you import Bot(socket)
07:11:43 <dminuoso> lyxia: But it would be cool to import Bot _and_ all its field accessors
07:11:46 <dminuoso> But not data constructors.
07:12:03 <ixxie> dminuoso: so I need to export it like that too
07:12:25 <dminuoso> ixxie: Yeah, or you can use (..) if you want to export/import data constructor and all fields.
07:25:43 <ixxie> dminuoso: I tried this https://github.com/ixxie/fluxbot/blob/master/fluxbot.hs but I get Data constructor not in scope: Bot :: Handle -> Bot
07:28:41 <dminuoso> What does ~> denote? Specifically I saw someone talking about a transformation `Co (State s) ~> Warp s`
07:28:56 <dminuoso> Is that meant in the sense of a morphism?
07:29:34 <lyxia> dminuoso: it's a common name for   type f ~> g = forall a. f a -> g a
07:29:53 <lyxia> it correponds to a natural transformation between functors f and g
07:30:55 <lyxia> ixxie: In Fluxbot.Bot you only export the Bot type, not the constructor.
07:31:20 <dminuoso> lyxia: Ah I see.
07:31:52 <ixxie> lyxia: hence I need to do Bot(Bot(socket)) like you said
07:32:36 <ixxie> ?
07:32:59 <Welkin> I have to mention this, after years of using haskell
07:33:23 <Welkin> I *still* get mixed up about the order of the accumulator and next element in the accumulating function for foldr vs foldl
07:33:26 <Welkin> it happend just now
07:33:31 <Welkin> and it is so stupid and frustrating
07:33:46 <Welkin> I always need to stop and think hard about which order the parameters go in?
07:33:58 <Welkin> so, whose bright idea was it to swap the order in foldr vs foldl?
07:34:20 <Welkin> why no just keep it the same?
07:36:06 <[exa]> Welkin: in foldl, the accumulator comes from left, right?
07:36:13 <Welkin> yes
07:36:18 <Welkin> but I always get them mixed up
07:36:26 <Welkin> see, even you don't know for sure
07:36:30 <Welkin> you *always* need to check
07:36:36 <Welkin> or use some stupid mnemonic device to remember it
07:36:41 <Welkin> and even then, you second guess yourself
07:36:47 <Welkin> what a terrible design decision
07:36:52 <[exa]> I had that issue as well, just always remember that left is about direction of where accumulator comes from
07:37:08 <lyxia> > foldl (+) [b,c,d] a
07:37:10 <lambdabot>  error:
07:37:10 <lambdabot>      • Couldn't match expected type ‘[[Expr]]’ with actual type ‘Expr’
07:37:10 <lambdabot>      • In the third argument of ‘foldl’, namely ‘a’
07:37:17 <lyxia> > foldl (+) a [b,c,d]
07:37:19 <lambdabot>  a + b + c + d
07:37:55 <Welkin> lyxia: that only works if both the accumulator value and the next element are the same type
07:38:00 <Welkin> usualy mine are not
07:38:15 <[exa]> btw imho it's a good decision, it prevents the people from easily switching between foldl' and foldr
07:38:18 <ski> Welkin : i suppose one mnemonic would be to consider whether the "accumulator" is threaded from the right to the left, or from the left to the right
07:38:26 <[exa]> because they do something _completely_ different
07:38:27 <MarcelineVQ> if someone told me the difference between the two was the direction the assumultor came from I'd be awfully confused
07:38:36 <lyxia> Welkin: the point is how the infix expression get associated.
07:38:58 <Welkin> :t foldr
07:39:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
07:39:00 <Welkin> :t foldl
07:39:01 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
07:39:10 <ski> for `foldl', we so to speak start with the state to the left, and smash it together with each element in turn, from left to right. therefore the callback has the state accumulator as first argument, and the current element as the second
07:39:10 <Welkin> they are identical except for the accumulator function
07:39:21 <ski> while it's the other way around for `foldr'
07:39:27 <Welkin> if you really wanted to make them different, then the `b` and `t a` should also be swapped
07:39:30 <Welkin> but they are not
07:39:38 <ski> Welkin : otoh, fwiw, in SML, `foldl' and `foldr' have exactly the same types
07:40:17 <ski> and in OCaml, the type of `fold_left' is  ('a -> 'r -> 'r) -> 'a list -> 'r -> 'r
07:40:37 <Welkin> ski: yes, I have gone through those exercises many times a long time ago, and I built up the same mnemonic device. But after not having used them much for a while, I still get confused when I use them, like just now.
07:40:47 <ski> that way, you can chain it like `foldl_left (fold_left f))' or `(foldl_left o foldl_left) f', to process a list of lists
07:40:57 <[exa]> Welkin: btw in your opinion, would it be better to unify both types to the type of foldr or foldl?
07:41:07 <Welkin> my point is that the design decision is a poor one and doesn't make any sense
07:41:20 <Welkin> it would only make sense if the `b` and `t a` were also swapped
07:41:22 <Welkin> otherwise it does not
07:41:27 <ski> so, one might say that Haskell has settled for an uncomfortable compromise between what SML does, and what OCaml does
07:42:03 <ski> SML going to consistency in the form of having the same type for both operations (which btw, can be chained like above)
07:42:38 <ski> while OCaml uses the "state is successively combined with elements" idea, so gets different types, but still enables chaining
07:43:27 <ski> ... and Haskell tries to use that state threading idea, but doesn't follow it consistently
07:43:34 <Welkin> [exa]: there is no changing it now without breaking every codebase ever written
07:44:02 <[exa]> Welkin: oh don't worry about codebases, just which one would be better theoretically
07:44:30 <Welkin> foldl seems the most natural to me
07:44:47 <Welkin> it matches the order of the 2nd and 3rd parameters
07:44:49 <ski> @type foldr . foldr
07:44:50 <lambdabot> (Foldable t2, Foldable t1) => (a -> t2 a -> t2 a) -> t2 a -> t1 (t2 a) -> t2 a
07:44:54 <ski> @type foldl . foldl
07:44:55 <lambdabot> (Foldable t2, Foldable t1) => (b -> a -> b) -> b -> t1 (t2 a) -> b
07:45:27 <ski> Welkin : *nod*
07:46:08 <ski> (i was confused for a little bit which of them would exhibit the problem here, i think)
07:47:30 <ski> anyway, this leads us to the distinction between "folds" as in `Foldable' and `foldl',`foldr',`foldMap',&c. on the one hand
07:47:50 <ski> and, on the other hand, "folds", as in catamorphisms, as in `foldr',`cata'
07:48:44 <Welkin> what is the significance of the distinction?
07:48:45 <ski> in the latter view, `foldr' must take the arguments to replace the data constructors by, separately from the list itself, they should not be interleaved
07:49:37 <phadej> Foldable isn't that far from cata, it replaces constructors with carefully picked applications of mempty and mappend
07:49:57 <ski> while, the `foldr' vs. `foldl' analogy you're talking about here would insist that `foldr' would take the list argument before the state argument (or else the argument order of the callback should be flipped)
07:49:59 <phadej> `Foldable.fold = foldr mappend mempty` after all. And foldr is `cata` for lists
07:50:14 <phadej> "it's more special"
07:51:12 <ski> we have `cata :: Functor f => (f r -> r) -> Fix f -> r'. one could also consider the flipped version `Fix f -> (f r -> r) -> r' (from one POV, this is better to consider). but there is no "interleaving" possible at this level of abstraction
07:52:03 <ski> Welkin : "what is the significance of the distinction?" -- they are different things. the catamorphism `foldr' happens to coincide with the "fold right" notion of `foldr', for lists
07:54:06 <ski> sure, `Foldable' (specifically `fold' and `foldMap') is like catamorphisms for the free monoid (which is an archic data type, as opposed to `[a]' in Haskell, which is anarchic)
07:55:06 <ski> so, `Foldable []' conceives of the type of Haskell lists, as if it were that archic free monoid type
07:55:52 <ski> while `foldr' (as a special case of `cata') conceives of `[]' as the right-biased/associated anarchich linked-list data type
07:56:34 <ski> Welkin : i'm not sure how much sense this explanation attempt is making, or if i need to try to elaborate more on what i mean here ..
07:57:07 <Welkin> I don't understand some of the terms you are using, such as archic and anarchic
07:57:16 <Welkin> and I don't know what a free monoid is
07:57:31 <ski> those are just fancy terms for "having laws" and "not having laws", that i picked up from somewhere
07:57:33 <Welkin> but I think I get your point
07:57:56 <Welkin> actual haskell code vs theoretical "code"
07:58:11 <ski> i believe in Miranda, one could actually declare archic/lawful data types
07:58:15 <ski> something like
07:58:32 <ski>   data List a = Nil | Singleton a | Append (List a) (List a)
07:58:33 <ski>     where
07:58:42 <ski>     Append Nil ys = ys
07:58:47 <ski>     Append xs Nil = xs
07:59:02 <ski>     Append (Append xs ys) zs = Append xs (Append ys zs)
07:59:48 <ski> (i don't recall how this actually worked, operationally, if it tried to use these laws as left-to-right rewrite rules, or just took them into account when checking equality .. there's stuff to consider here, certainly)
08:00:21 <ski> anyway the notion of `List a' i just wrote down *is* "the free monoid over the type `a'"
08:00:45 <ski> what this means is that we start with a type `a', and we want to construct a monoid (in this case) from it
08:01:08 <ski> so, first we "add" or "include" all the elements of `a' as elements of `List a', making `a' a subset of `List a'
08:01:49 <ski> well, Haskell has no subtyping, so instead of actually including the elements `x' of `a' itself, we're wrapping them as `Singleton x', when "including" them in `List a'
08:02:51 <ski> then, we also add all elements that we need to add, in order to definitely make this into a monoid (regardless of what type `a' was, if we already had some monoid structure we're considering on `a', we're forgetting all about that, just considering the plain set/type `a')
08:03:59 <ski> we add all elements that we need to add, with as *few* restrictions on how these related to existing elements, as possible, subject to the laws (the monoid laws here)
08:04:25 <ski> so, a monoid has to have a neutral element. and, there's nothing requiring the neutral element to already be one of these `Singleton a' elements that we start off with
08:04:50 <ski> therefore, we add a *new* element, `Nil', as a neutral element, which is *not* equal to `Singleton x', for any `x' in `a'
08:05:29 <ski> (also note that in the special case that `a' is `Void', there is no `x' elements in `a'/`Void'. but there should still be a neutral element in `List a', which always exists, namely `Nil')
08:05:58 <ski> similarly, for any two elements `a0' and `a1' that we have already added to `List a', we also add their monoidal combination, `Append a0 a1'
08:06:41 <ski> however, we have laws saying that if `a0' is `Nil', then this new element `Append Nil a1' isn't actually a new element, since it must be considered equal to the already existing element `a1'
08:07:03 <ski> and similarly if `a1' is `Nil', `Append a0 Nil' will not be new, but equal to the existing `a0'
08:07:36 <ski> finally, `Append (Append a0 a1) a2' is claimed to be treated as equal to `Append a0 (Append a1 a2)'
08:08:12 <ski> there's to two basic ways in which we could consider implementing such "treated as equal to" conditions
08:08:59 <ski> perhaps the most obvious one is to, whenever we see `Append Nil ys', we simplify it to `ys', and similarly for the other three laws above, replacing the left-hand side with the right-hand side, whenever we encounter it
08:09:03 <Welkin> how come there is no case where you handle Singleton?
08:09:26 <Welkin> Append (Singleton a) (Singleton b), for example
08:09:36 <ski> this then means that if we pattern-match, we'll never actually see `Append Nil zs' or `Append (Append xs ys) zs'
08:09:51 <ski> well, we simply have no law involving `Singleton'
08:10:02 <ski> so, there's no rewrite rules involving it
08:11:19 <ski> taken together, this means that every inhabitant of `List a' will be rewritten into the form `Append (Singleton x0) (Append (Singleton x1) (Append (Singleton x2) (..(Singleton x_{n-1})..)))'
08:12:17 <ski> actually, if we turn around the law `Append xs Nil = xs' into `xs = Append xs Nil', we could imagine it so that every `List a' inhabitant be rewritten into the form `Append (Singleton x0) (Append (Singleton x1) (Append (Singleton x2) (..(Singleton x_{n-1})..)))'
08:12:43 <ski> (which now looks, structurally speaking, very similar to `x0 : (x1 : (x2 : (..(x_{n-1} : [])..)))')
08:13:36 <ski> anyway .. this "reduction through laws, to a canonical form", doesn't work generally
08:13:51 <ski> in general, there is no guarantee that such a rewrite process would terminate
08:16:06 <ski> (btw, every list must reduce to the form `Nil' or `Append (Singleton x) xs', or possibly `Singleton x' (if you don't turn around the law like i indicated). because if you had `Append' with another `Append' as first argument, you'd rewrite ("rotate", in terms of trees) that, until the first argument of `Append' would be a `Singleton')
08:16:47 <ski> anyway, the other operational implementation would be to just leave the data constructors `Nil',`Singleton',`Append' in place. so a `List a' now really is represented as an arbitrary tree (rather than a right-, or a left-, if you prefer, biased one)
08:17:11 <ski> it's only that here you make sure that noone can tell the difference between `Append Nil ys' and `ys', and so on for the other laws
08:17:23 <ski> however, that's easier said than done :)
08:18:07 <ski> (fwiw, i could mention that what we're considering here is the notion of a "quotient type", a type with a user-defined equality (which must be an equivalence relation))
08:18:23 <ski> so, if we define a function via pattern-matching
08:18:37 <ski>   foo :: List Int -> Blah
08:18:41 <ski>   foo Nil = ...
08:18:48 <ski>   foo (Singleton n) = ..n..
08:18:58 <ski>   foo (Append ns0 ns1) = ..ns0..ns1..
08:19:45 <ski> then, in order to not be able to tell a difference between `ns' and `Append Nil ns', we must ensure here that `foo ns' and `foo (Append Nil ns)' can't be distinguished
08:20:58 <ski> so `ns' and `..(...)..ns..' (plugging the right-hand-side of the first defining equation into the `ns0' hold in the last defining equation) must then be ensured to be equal
08:21:25 <concaveirc> Is there a ready-to-use implementation of a binary tree somewhere?
08:21:39 <ski> so, we'd either need some kind of theorem proving (by system or programmer) .. or simply trust that the programmer know what they're doing, that they have an informal proof of this
08:22:49 <ski> if you look at the implementation of `Rational' (or `Ratio a' in general), they do the reduction, they reduce `2 % 6' to `1 % 3'
08:22:55 <ski> > 2 % 6
08:22:57 <lambdabot>  1 % 3
08:23:34 <Welkin> ski: I have lost the thread of this
08:23:40 <ski> internally, that is stored as `1 :% 3', where `(:%)' is the real data constructor, and `(%)' is a "smart constructor" that does the reduction/simplification first, before storing with `(:%)'
08:23:41 <Welkin> what were you originally trying to explain?
08:23:53 <ski> hm, ok
08:24:06 <ski> i can go back to free monoids
08:24:27 <Welkin> I think I got your point about what a free monoid is
08:24:31 <ski> the `List a' example was an attempt to explain what i mean by an "archic (lawabiding) data type"
08:24:52 <ski> where we have imposed extra laws relating the data constructors to each other
08:25:32 <ski> and which are interpreted either by reduction, or by at least saying which internal representations differences must not be allowed to be observable
08:25:46 <boxscape> So I read the other day that there's a lot more in haskell to learn than in other languages, and to some extent, that's been my impression as well - but maybe that's just because I try to learn more in haskell. What do you guys think? Is haskell 'deeper' than, say, Java, C++ or Python
08:25:48 <ski> (we have the same thing with `Set' and `Map', which, conceptually speaking, are quotient types)
08:26:17 <ski> so, an "anarchic (lawless) data type" is just the ordinary (algebraic) data types that we have in Haskell
08:27:05 <ski> we *simulate* archic data types (conceptually subtypes, or quotient types, or a combination), through information hiding, *abstract* data types, not giving external access to the internal representation
08:27:30 <Welkin> boxscape: haskell is a simple language, syntactically. All of the complexity is in the libraries and higher level concepts you use to write your programs. You can make it as complex as you want it to be, or as simple.
08:28:16 <boxscape> that makes sense, although I suppose there are periodic additions of GHC extensions that add syntax layers as well
08:28:21 <Welkin> boxscape: in terms of depth, it has more depth than any other language I have ever used. You will probably never fully understand everything, especially since it is always evolving and getting new features/extensions
08:28:32 <ski> Welkin : going back to "free". a monoid has two operations, "neutral element" and "combining two elements", subject to three laws. therefore the "free monoid over `a'" gets one inclusion from `a' (`Singleton' here), and two extra data constructors corresponding to those operations. but subject to the monoid laws
08:28:39 <Welkin> yes, there are extensions that add new syntax, but it is just syntactic sugar most of the time
08:28:44 <boxscape> right
08:29:00 <ski> if we were talking about free groups, then we'd add another data constructor `Inverse :: Group a -> Group a', and two more laws
08:30:01 <ski> conceptually, "the free monoid over `a'" is the type of finite sequences of `a's .. where we haven't taken a stance on how we should "nest", it ought not to matter !
08:31:57 <ski> `([x0] ++ [x1]) ++ [x2]' (or `Append (Append (Singleton x0) (Singleton x1)) (Singleton x2))') ought to be the same as `[x0] ++ ([x1] ++ [x2])', so we prefer to think of this as `[x0] ++ [x1] ++ [x2]', or using shorter notation `[x0,x1,x2]', regardless of how we actually decide to represent this
08:32:20 <ski> (which in actual Haskell is `x0 : (x1 : (x2 : []))')
08:33:15 <ski> whenever you hear "the free Y over X", it means that we take an `X', and then "add" the things needed to turn it into an `Y', in the "least restrictive way possible"
08:33:59 <Welkin> using ADT definitions
08:34:22 <ski> here, `X' was set/type, and `Y' as monoid. the things we needed to add were the monoid operations (neutral element `mempty', and binary combination `mappend'), subject to the three monoid laws
08:35:06 <ski> (it's important to say not only `Y', where you're going, but also `X', what you're starting from)
08:35:40 <ski> the free monoid over the *monoid* of natural numbers (with zero,addition), `Nat', is just `Nat'
08:36:07 <ski> while the free monoid over the *set/type* of natural numbers `Nat', is `List Nat'/`[Nat]'
08:36:10 <ski> completely different
08:36:26 <ski> in the first case, we are already starting with a monoid, so nothing needs to be added
08:36:54 <Welkin> a free monoid over a monoid is just a monoid then, right?
08:37:04 <ski> in the second case, we start with `Nat', which *has* a monoid structure (in fact several to choose from), but we're disregarding that, only considering the plain elements of `Nat'
08:37:17 <ski> Welkin : it's just the *same* monoid, yes
08:37:44 <ski> (the free monoid over anything (if it exists at all) is always a monoid. the question is which monoid it is, if it exists)
08:38:25 <ski> consider the free monoid over (the type) `Bool', for a moment
08:38:41 <ski> this consists of all, *finite*, sequences/lists of `Bool' elements
08:40:01 <ski> (if we have added `x' and `y', we also need to add `Append x y', and then we also need to add `Append (Append x y) x', &c., but there's nothing requiring us here to add "infinite elements", and so we should not do so. remember "add .. in the least restrictive way")
08:40:06 <ski> anyway
08:40:13 <ski> some monoid are commutative
08:40:28 <ski> meaning that the order of arguments to `mappend' doesn't matter
08:40:41 <ski> so, we have a .. category .. of all monoids
08:41:06 <ski> and then we carve out from that, the subcategory of all *commutative* monoids
08:41:16 <ski> the monoids that are actually commutative
08:42:13 <ski> before, we had `Nat', which indeed had one monoid structure (in fact several), but we *forgot* about that, and only considered `Nat' as a set/type, to then form the free monoid on that, `[Nat]'/`List Nat'
08:42:51 <ski> so, before, we had an example that was a monoid, but we could forget about the monoid structure, only retaining its set/type of elements
08:43:33 <ski> this time, if we have a *commutative* monoid, we can forget that its commutative, and treat it "just like a plain monoid, not necessarily commutative" (though it in fact happens to be commutative in this case)
08:44:37 <ski> now, if i take *any* monoid, i can form the free *commutative* monoid, over that monoid. in this case, what is "added" is the law of commutativity
08:45:20 <ski> the general theme here is that, we have a way to *forget* some information. e.g. given a monoid, we forget that it's a monoid, only retaining a set/type
08:45:45 <ski> and then, the *free* thing goes in the opposite direction as forgetting, it *reconstructs* what forgetting forgets
08:46:39 <ski> so, corresponding to forgetting that a monoid is a monoid, remembering only a set/type, we have the process of, from any given set/type, form the free monoid on that set/type, by "adding monoidness" to it, in the "least restrictive way possible"
08:46:57 <ski> ok, so going back to the commutative monoid vs. monoid case now
08:47:18 <ski> there, forgetting amounts to forget that a monoid is commutative, only remembering that it is a monoid
08:48:08 <ski> therefore, the corresponding "reverse" process of constructing a "free" thing, is forming "the free commutative monoid" (whatever that is) out of a monoid
08:48:15 <ski> from a monoid, we construct a commutative monoid
08:48:37 <ski> so, take the monoid `[Bool]' (with empty list,concatenation)
08:48:42 <ski> what is the free commutative monoid on this ?
08:49:19 <ski> well,  [False] `mappend` [True]  should, *now*, be considered the same as  [True] `mappend` [False]
08:49:54 <ski> so, instead of having something like `[False,False,True,False,True]', we can now gather all the `False's together, and all the `True's together
08:50:22 <ski> so, instead of storing some kind of list/tree, it suffices to store a *count* of how many times `False', and `True', occurs
08:50:53 <ski> so, we can say that the free commutative monoid on the monoid `[Bool]' is `(Nat,Nat)', or `Bool -> Nat' if we prefer
08:52:13 <ski> in general, the free commutative monoid on the monoid `[a]' (which is the free monoid on the type `a'), can be represented as `a -> Nat', where, in the general case (including infinite types `a') we only include functions from `a' to `Nat' that map all but finitely many inputs to `0'
08:53:04 <ski> (the last condition is called "having finite support", and is a bit of a technical condition, but is what one gets, if one follows the "add ... in least restrictive way" seriously)
08:53:37 <ski> i'm not sure how much of this make sense, how much makes half-sense ..
08:53:40 <texasmynsted> ctags for Haskell?
08:53:51 <Welkin> your point on forgetting confused me
08:54:03 <texasmynsted> there seems to be a number of them, and I can recall which one is the one to use
08:54:07 <ski> yea .. it's not something which is that easily grasped, unfortunately
08:54:19 <ski> "forgetting that a monoid is commutative" sounds strange, to begin with
08:54:42 <ski> "if it is commutative, then it is commutative, what's the deal ?" -- one may think
08:55:04 <ski> but, here, it matters in which *context* one considers it
08:55:08 <texasmynsted> wow, sooooo very much scroll-back in here
08:55:22 <ski> do we consider our commutative monoid only in the context of other commutative monoids (that's one category)
08:55:45 <ski> or do we consider our commutative monoid also in the wider context of not necessarily commutative monoids (that's the larger category)
08:55:58 <ski> in the latter case, we're "forgetting commutativity"
08:56:31 <texasmynsted> heh --> https://wiki.haskell.org/Tags
08:57:12 <ski> btw, i could add that "forgetting" here is one functor, and "free" is a functor in the opposite direction. and that these two functors form an "adjunction"
08:57:40 <ski> that's just some terminology, to say that this topic is related to whatever "adjunctions" are about
08:58:11 <ski> Welkin : and, with that, i think i should probably stop, as you're probably confused enough
08:58:41 <Welkin> ski: thanks for the explanation though
08:58:46 <Welkin> I did learn something
08:58:52 <ski> i hope at least some of it made sense
09:02:50 <texasmynsted> somebody please write this free monoid discussion into a blog post
09:03:54 <Welkin> texasmynsted: you can grab the log and post it online most likely
09:04:02 <Welkin> on lpaste or something
09:04:11 <texasmynsted> I meant somebody else heh
09:04:38 <Welkin> there are a lot of good discussions (and lectures) that take place in this channel that are lost in the logs
09:04:48 <texasmynsted> yeah
09:04:55 <Welkin> saving it somewhere is a good idea
09:05:09 <monochrom> Sure.  <html> <header><title>Free monoid discussion</title></header> <body><p><a href="http://tunes.org/~nef/logs/haskell/18.02.10">Free monoid discussion</a></body> </html>
09:05:25 <texasmynsted> I think if it is not automated, it will not happen
09:05:44 <nickrandom> Hi guys, how do i write an hello world in haskell?
09:05:48 <nickrandom> In a file i mean
09:05:56 <monochrom> main = putStrLn "hello world"
09:06:47 <texasmynsted> monochrom: +1 Wow!  I had no idea.
09:07:00 <texasmynsted> oh and I see it in the channel header now, lol
09:07:09 * texasmynsted facepalm
09:08:07 <nickrandom> monochrom,     Could not find module ‘Prelude’
09:08:31 <monochrom> I can't reproduce that error. How should I reproduce it?
09:08:46 <nickrandom> I just run ghc helloworld.hs
09:09:35 <nickrandom> https://pastebin.com/sLZPpsrw
09:10:26 <sm> damn. :)
09:10:52 <sm> corrupt installation ? maybe you removed some files ?
09:11:42 <nickrandom> community/haskell-base-prelude 1.2.0.1-5
09:11:56 <nickrandom> should i install this?
09:12:47 <nickrandom> Mmm
09:12:52 <nickrandom> No, it doesn't works
09:13:16 <monochrom> Still can't reproduce.
09:13:37 <nickrandom> $ ghc -dynamic hellworld.hs
09:13:37 <nickrandom> [1 of 1] Compiling Main             ( hellworld.hs, hellworld.o )
09:13:37 <nickrandom> Linking hellworld ...
09:13:45 <nickrandom> with -dynamic it works
09:13:55 <sm> let me guess.. Arch ?
09:13:55 <monochrom> Oh OK so you're a victim of Archlinux.
09:13:59 <Welkin> hahaha
09:14:06 <Welkin> put that in the topic
09:14:16 <Welkin> "Warning: Don't use arch"
09:14:32 <nickrandom> sm yep
09:14:37 <nickrandom> just read it https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
09:14:38 <nickrandom> gh
09:15:03 <monochrom> Oh, they have it up in their wiki. I should bookmark it.
09:15:25 <Welkin> how is it still broken?
09:15:33 <Welkin> didn't someone break it over 6 months ago?
09:15:36 <Welkin> or was it longer?
09:15:44 <monochrom> Um --disable-library-vanilla is finally supported?! >:)
09:16:10 <monochrom> I don't think the arch people consider it broken. I think they consider it a feature.
09:16:44 <monochrom> There is no limit to how much an ideology can corrupt rationality.
09:17:07 <monochrom> Even a simple ideology like "let's purge static linking".
09:17:48 <hpc> scroll down, they have three different ghcs packaged
09:17:53 <hpc> specifically to work around this
09:18:06 <nickrandom> community/ghc-static 8.2.2-1
09:18:06 <nickrandom>     The Glasgow Haskell Compiler - Static Libraries and Documentation
09:18:14 <nickrandom> Maybe this works fine?
09:18:24 <Welkin> I think the real solution is to not use arch, and use something sinseible like ubuntu (or others)
09:18:30 <Welkin> sensible*
09:18:33 <monochrom> I think so. IANAAU though.
09:22:27 <Welkin> I also never install anything related to haskell from a package manager
09:23:22 <monochrom> That's the wise choice.  But most people are still brainwashed by the false dichotomy of "either from my linux distro or build from source".
09:23:23 <nickrandom> monochrom, with ghi-static everywhing works well
09:38:25 <nickrandom> main = sum [x | x <- [1..1000], x `mod` 3 == 0 , x `mod` 5 == 0]
09:38:30 <nickrandom> what's wrong here?
09:39:00 <hpc> what's the type of main?
09:39:00 <ski>   main = print (sum [...])
09:40:17 <metahumor> main is always IO (), right?
09:40:45 <nickrandom> Oh, wow
09:40:45 <nickrandom> cool
09:41:11 <nickrandom> I'm loving it
09:41:25 <metahumor> nickrandom: you wrote an declaration, equating main with sum. in regular haskell files, main has to be an action
09:42:00 <nickrandom> I understand
09:42:06 <nickrandom> and main is IO()type
09:42:27 <nickrandom> so i have to eqate main with another io type
09:42:34 <nickrandom> Like what print returns
09:43:01 <metahumor> :t print
09:43:02 <lambdabot> Show a => a -> IO ()
09:58:38 <jd823592> how can i unload prelude in ghci?
09:58:48 <jd823592> :m -Prelude does not work
09:59:04 <hpc> try ghci -XNoImplicitPrelude
10:00:14 <jd823592> hpc: doesn't seem to have worked
10:00:53 <metahumor> in ghci: ":set -XNoImplicitPrelude"
10:01:43 <jd823592> metahumor: i am really confident, this did not help
10:03:01 <jd823592> i still get "ambiguous occurence `not` ... Prelude.not"
10:04:23 <jd823592> metahumor: ghci has to be started with the flag (not set from the interactive prompt) in order for it to work :/
10:05:08 <erisco> a recurring event on the first Monday of each month is not periodic in seconds… in fact, an event occurring the first day of each year is not periodic in seconds because of leap seconds =\
10:05:21 <erisco> and leap years
10:05:25 <erisco> leap days*
10:05:39 <erisco> no... they call them leap years... yeah that's right
10:06:22 <erisco> it isn't obvious to me how you would reconcile these two different time measurements
10:07:38 <Tuplanolla> What's the problem, erisco? You have exact atomic time and inexact political time.
10:08:21 <Tuplanolla> Pretending that they're somehow compatible or can be reasonably inferred from context is heresy.
10:09:17 <erisco> what I am calling a broken interval (an interval with contained intervals subtracted from it) can be stored efficiently if it is periodic
10:09:23 <cocreature> jd823592: I’m not sure if you can set it from within ghci, but if you start ghci using "ghci -XNoImplicitPrelude" it works
10:10:05 <erisco> if our scale is seconds, then I could say an event endures for 100 seconds every 1000 seconds
10:10:12 <monochrom> Ah, but an aperiodic broken interval can be mapped to a periodic broken interval by a suitable bijection.
10:10:52 <Welkin> what's your new hare-brained scheme erisco ?
10:11:27 <erisco> but in practice, the broken intervals are specified in more obscure ways such as "the first Monday of every month"
10:11:43 <erisco> if you rendered this on a scale of seconds, the broken interval would not be periodic
10:11:48 <Welkin> that is how peopl do meetups around here
10:11:57 <Welkin> "the last monday of the month"
10:12:05 <Welkin> or "the third thursday"
10:12:28 <Welkin> a month is not a constant value
10:12:37 <erisco> if you rendered it on a scale of days I am not sure it would be periodic, because of leap years … your period is going to be very long at least (400 years afaik)
10:12:44 <monochrom> "the first Monday of every month" has very efficient storage.
10:13:02 <monochrom> > length "the first Monday of every month"
10:13:03 <lambdabot>  31
10:13:06 <Tuplanolla> Since the interpretation of that phrase can change every day (changing time zones, introduction of leap seconds, shifting calendars, ...), you have no choice but to reinterpret it every day, erisco.
10:13:21 <monochrom> The Kolmogorov complexity of it is clearly less than 31 bytes.
10:14:53 <erisco> Tuplanolla, even ignoring locality and just assuming a standard Gregorian calendar, zulu time, etc
10:15:15 <monochrom> The algorithm to map it to the Gregorian calendar is a bit ugly, sure.  But it is also a reusable algorithm.  Write once, now it's good for 7 cases.
10:15:29 <Tuplanolla> Any optimization worth its weight would also be wrong.
10:16:32 <monochrom> And actually I don't think anyone even needs this algorithm written.  They tend to just mark their calendars by hand for this.
10:19:33 <erisco> I am just saying I do not see the scale or methodology to make these varying ways to specify schedules periodic, though we lazily think of them as such
10:20:17 <Welkin> lexi-lambda: your blog post is on hacker news https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/
10:20:30 <monochrom> OK, but perhaps you should cut people some slack on natural language wording.
10:20:35 <erisco> and for what I was thinking of doing it would be necessary to reduce unbounded broken intervals to periodic
10:20:41 <lexi-lambda> they do seem to end up there, invariably…
10:20:45 <Welkin> I bet the first comment will be something about how you must be leaving because haskell isn't practical
10:20:49 <monochrom> Most people, especially the non-math ones, don't even know the math definition of "periodic".
10:20:53 <lexi-lambda> sounds about right.
10:21:17 <erisco> what for terminating computation :P
10:21:44 <lexi-lambda> someone ought to make HN Haskell bingo.
10:21:56 <lexi-lambda> the free space is “didn’t read the article”.
10:22:18 <Welkin> lexi-lambda: I skimmed your blog post and it looks good
10:22:24 <nkaretnikov> puffnfresh: https://github.com/puffnfresh/osxmonad does it work on high sierra? how exactly does it work? is it just a bunch of shortcuts allowing to manipulate native macos windows? would the default shortcuts work alongside it?
10:22:59 <erisco> the birds eye problem being that there are many competing schedules (specified as broken intervals), and there is a policy to grant time contingent on what the last activity was
10:23:43 <erisco> and I need to be able to jump to an arbitrary point in time and know what the activity is without playing from zero
10:24:08 <erisco> if everything reduced to periods then this is possible
10:24:53 <Tuplanolla> Are you saying you're trying to trisect an angle?
10:24:55 <monochrom> Oh, "stack haddock --open" is pretty neat. I may have to raise my opinion on stack. :)
10:24:56 <erisco> I trivially compute the time offset into the period, then at worst play from the start of the period
10:25:14 <Welkin> lexi-lambda: what id you work on while you were employed to write haskell?
10:26:15 <lexi-lambda> nothing super exciting. mostly some deployment tooling and an authentication system. most of the system was not haskell.
10:26:43 <lexi-lambda> but I got to be on a team that was writing haskell, so I was happy. :)
10:27:16 <cocreature> lexi-lambda: what are you doing now?
10:27:45 <lexi-lambda> I’m not sure I can say just yet, but I should be able to in a month or two.
10:27:52 <cocreature> fair enough :)
10:28:24 <Welkin> writing haskell for yourself is so much more satisfying than writing it for a client or employer
10:28:39 <Welkin> where it tends to be tedious work anyway
10:29:01 <monochrom> Dear lexi-lambda: Good article.
10:29:29 <Welkin> I still have not used many of those ghc extensions that you mention in your essay
10:29:47 <monochrom> Oh you're the Hackett guy too!  Heresy!  Stone you to death!  >:)
10:30:15 <lexi-lambda> Hackett gal. but yes, I’m the witch. burn me at the stake. :)
10:30:22 <monochrom> Oops.
10:31:20 <Welkin> lexi-lambda: your name is gender neutral
10:31:27 <Dynasty> Is it possible to have a "kind function" in type constructors in Haskell? Something like * -> (* -> *) -> *
10:31:37 <Dynasty> I was thinking that the kinds would always be like (((* -> *) -> *) -> *)
10:32:10 <cocreature> :k Compose
10:32:12 <lambdabot> error:
10:32:12 <lambdabot>     Not in scope: type constructor or class ‘Compose’
10:32:17 <hask_bee_3> Is there a way to benchmark the total CPU/memory an *already-compiled* program (compiled normally, without the special RTS GHC flags)? (Not really a Haskell question, sorry.)
10:32:18 <hask_bee_3> I wonder if this is even possible to do reliably in the first place - being why we often use those special GHC flags in the first place.
10:32:18 <cocreature> :k Data.Functor.Compose.Compose
10:32:19 <hask_bee_3> Your thoughts?
10:32:20 <lambdabot> (k -> *) -> (k1 -> k) -> k1 -> *
10:32:23 <cocreature> ^ Dynasty
10:33:12 <monochrom> I don't understand your question.  But ReaderT has kind * -> (* -> *) -> (* -> *)
10:34:14 <monochrom> (((* -> *) -> *) -> *) would sound like a tour-de-force case of continuation passing style at the type level.
10:35:08 <ski> @kind ReaderT
10:35:10 <lambdabot> * -> (k -> *) -> k -> *
10:35:19 <Dynasty> monochrom isn't that how type constructors like Either are defined? Did I get the associativity right?
10:35:27 <cocreature> hask_bee_3: for cpu profiling you can use "perf" but to get useful info out of that you are going to need to compile with dwarf debugging info. contrary to ghc’s builtin profiling facilities debug info won’t change the runtime behavior
10:35:42 <monochrom> @kind Either
10:35:43 <lambdabot> * -> * -> *
10:35:54 <monochrom> which is * -> (* -> *)
10:36:56 <Dynasty> I'm pretty sure you have the associativity wrong
10:37:13 <cocreature> Dynasty: nope, you’re the one that has it wrong :)
10:37:24 <monochrom> @kind Either Int
10:37:25 <lambdabot> * -> *
10:37:36 <hask_bee_3> cocreature Thank you. What about memory use?
10:37:47 <ski> the associativity of application is opposite that of `->'
10:38:04 <cocreature> hask_bee_3: I don’t know of anything for that
10:38:33 <monochrom> I wonder if lambdabot accepts kind annotations.
10:38:58 <monochrom> > Left 4 :: ((Either :: * -> (* -> *)) Int ())
10:39:00 <lambdabot>  Left 4
10:39:04 <monochrom> Oh good!
10:39:12 <monochrom> > Left 4 :: ((Either :: (* -> *) -> )) Int ())
10:39:14 <lambdabot>  <hint>:1:35: error: parse error on input ‘)’
10:39:16 <monochrom> err typo
10:39:19 <monochrom> > Left 4 :: ((Either :: (* -> *) -> *)) Int ())
10:39:21 <lambdabot>  <hint>:1:45: error: parse error on input ‘)’
10:39:59 <ski> > Left 4 :: ((Either :: (* -> *) -> *) Int ())
10:40:01 <lambdabot>  error:
10:40:01 <lambdabot>      • Expecting one fewer arguments to ‘Either Int’
10:40:01 <lambdabot>        Expected kind ‘* -> *’, but ‘Either Int’ has kind ‘*’
10:40:08 <monochrom> Thanks.
10:40:34 <monochrom> Anyway, now you have to argue with the computer.
10:41:01 <Dynasty> Could you elaborate on why the kind associativity is different than function application?
10:41:15 <Dynasty> Or rather function types
10:41:29 <cocreature> associativity in function types and kinds is the same
10:41:40 <monochrom> They are actually not different.  They are consistent with each other.
10:42:22 <Tuplanolla> You could add `BinaryLiterals`, `NegativeLiterals`, `NumDecimals`, `PostfixOperators`, `MonadComprehensions` and `EmptyDataDecls` to your list of trivial extensions, lexi-lambda.
10:42:23 <monochrom> "(f x) y" and "f :: T -> (T -> T)" go hand in hand.  They are logically equivalent.
10:42:47 <lexi-lambda> EmptyDataDecls is in Haskell 2010.
10:42:48 <Dynasty> Oh okay I got it now
10:43:09 <Dynasty> It makes sense when thinking in the context of currying
10:43:18 <ski> `take 2 [False,True,False]' means `(take 2) [False,True,False]', while `take :: Int -> [Bool] -> [Bool]' means `take :: Int -> ([Bool] -> [Bool])'
10:44:25 <Dynasty> It's a little confusing because when you apply to functions or apply types to type constructors the associativity is the other way
10:44:39 <monochrom> Is it?
10:44:58 <monochrom> > Left 4 :: ((((Either Int)))) Bool
10:45:00 <lambdabot>  Left 4
10:46:02 <hpc> :: brb, adding (((([((([(Foo)])))])))) to all my code
10:46:06 <hpc> er
10:46:11 <hpc> that "::" goes before the type
10:47:11 <monochrom> See also "instance Functor (Either x) where"
10:48:01 <monochrom> hpc: Consider also writing like ((((( [] Int )))))  >:)
10:48:40 <hpc> :t "s" :: {String}
10:48:41 <lambdabot> error: parse error on input ‘String’
10:48:50 <hpc> huh
10:48:59 <monochrom> curry braces?
10:49:03 <runeks> I'm getting an error "InternalException (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))))" when trying to fetch some JSON from api.binance.com. Anyone know what the cause of this is?
10:49:13 <hpc> i wonder what it thought '{' was going to be the start of
10:49:22 <hpc> because it says it didn't expect "String"
10:49:50 <cocreature> runeks: looks like the tls cert of that website isn’t signed by a CA that your computer trusts
10:50:01 <int-e> :t 1 :: {}
10:50:02 <lambdabot> error: Record syntax is illegal here: {}
10:50:13 <runeks> cocreature: It works in Chrome though, which is odd.
10:50:17 <runeks> Full error: http://lpaste.net/362339
10:50:18 <monochrom> Secret code for secret project on real record types like { cx::Int, cy::Bool }  :)
10:50:25 <Welkin> lambdabot: then change the laws!
10:50:35 <hpc> monochrom: seriously?
10:50:46 <cocreature> runeks: iirc chrome has its own certificate store and doesn’t use the one provided by the OS
10:51:17 <runeks> cocreature: It also works in Safari
10:51:26 <monochrom> No! Just kidding!
10:51:29 <cocreature> runeks: how are you making the request?
10:51:55 <hpc> monochrom: look, if ImplicitParameters can be accepted into ghc, i don't know where the line is
10:51:58 <hpc> :P
10:52:12 <runeks> cocreature: Using servant-client
10:52:19 <qeyoa> what does `[ a -> a ] ` mean in function declaration
10:52:32 <monochrom> The line is between "someone bothered to code it up" and "someone just talked about it".
10:52:43 <hpc> qeyoa: the type of lists of functions from a type to itself
10:52:44 <Welkin> qeyoa: List (a -> a)
10:52:48 <monochrom> qeyoa: Could you show more complete code?
10:52:48 <runeks> cocreature:  Here's the code in case you want to try to reproduce: https://github.com/runeksvendsen/crypto-venues
10:53:04 <qeyoa> compose :: [a -> a] -> (a -> a)
10:53:05 <qeyoa> compose = foldr (.) id
10:53:25 <monochrom> Then yeah, the first parameter is a list full of functions.
10:53:32 <runeks> cocreature: The failing URL is https://api.binance.com/api/v1/exchangeInfo
10:53:33 <nickrandom> what's [x | x <- [1..n]] ?
10:53:38 <qeyoa> ok, thanks
10:53:42 <nickrandom> List comphrension?
10:53:43 <hpc> that's a list comprehension
10:53:48 <monochrom> > [x | x <- [1..10]]
10:53:48 <Welkin> nickrandom: a no good list comprehension
10:53:49 <hpc> > [x | x <- [1..10]]
10:53:50 <ski> nickrandom : a more complicated way to write `[1 .. n]'
10:53:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:53:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:53:51 <hpc> lol
10:53:54 <runeks> cocreature: The test suite does the fetch, and fails because of the TLS error
10:54:06 <monochrom> Yeah, [1..10] would suffice.
10:54:07 <nickrandom> ski, i know, i just wanted to know how it's called :P
10:54:30 <nickrandom> and there's a way to change the value of a variabile inside it?
10:54:53 <Welkin> it is syntactic sugar for a recursive function
10:55:11 <Welkin> so the `x` at each step is a new `x`
10:55:17 <ski> hpc : you must admit `ImplicitParameters' is fun
10:55:23 <int-e> > [23 | True] ++ [42 | True]
10:55:26 <lambdabot>  [23,42]
10:55:33 <hpc> nickrandom: depends on your perspective - there's no actual mutation going on but the name 'x' there ends up being multiple values
10:55:44 <int-e> > [23 | False] ++ [42 | True]
10:55:45 <lambdabot>  [42]
10:55:46 <hpc> since it ultimately desugars to a function argument
10:55:52 <nickrandom> Can i do something like [x + y, x = y,  y = x+y | _ <- [1..n], let x = 0, let y = 1]
10:56:10 <nickrandom> (yeah, i'm trying to reproduce the fibonacci sequence)
10:56:12 <Welkin> I would advise against it
10:56:24 <Welkin> write it out explicitly using recursive functions
10:56:35 <hpc> ^
10:56:46 <ski> > let n = 10 in [x + y | _ <- [1..n], let x = 0, let y = 1,x == y,y == x+y]
10:56:48 <lambdabot>  []
10:57:07 <Welkin> there are many ways to generate a fibonacci sequence, some of which are my favorite in all of haskell (and very terse)
10:57:31 <runeks> Anyone willing to run the test suite for the following package in order to see if the "unknown CA"-error I get is specific to my machine? https://github.com/runeksvendsen/crypto-venues
10:57:38 <Welkin> > fix ((0:) . scanl (+) 1)
10:57:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:57:52 <Welkin> or in a more readable form
10:58:14 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1
10:58:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:58:17 <ski> > let fibs = [0,1] ++ [x + y | x <- fibs | y <- tail fibs] in fibs
10:58:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:58:40 <ski> > let fibs = [0,1] ++ [x + y | x:y:_ <- tails fibs] in fibs
10:58:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:59:08 <hpc> > fix $ \fibs -> [0,1] ++ [x + y | x:y:_ <- tails fibs]
10:59:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:59:34 <hpc> (that makes it a bit more obvious what fix is doing)
11:00:07 <Welkin> `fix` is something you won't learn about for quite a while though if you are just starting haskell
11:00:50 <Welkin> my favorite is the second one I wrote: let fib a b = a : fib b (a + b) in fib 0 1
11:01:11 <Welkin> nickrandom: does that make sense to you?
11:01:15 <ski> now do the matrix exponentiation one
11:01:27 <Welkin> ski: no idea what that is
11:01:47 <hpc> the prime golf series in lambdabot's where database is pretty good too
11:01:57 <hpc> @where primes
11:01:57 <lambdabot> let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
11:02:02 <nickrandom> Welkin, it does
11:02:04 <hpc> (they only get shorter from there)
11:02:26 <ski> take a matrix `[[0,1],[1,1]]', raise it to the power of `n', then multiply it with the vector `[1,0]'
11:02:28 <Welkin> nickrandom: notice that you can't do this in a strict language (not easily). This only works because haskell is lazy
11:02:44 <Welkin> so you can build an infinite fibonacci sequence in linear time
11:02:50 <ski> also note that raising to the power of `n' can be done more efficiently than `n-1' matrix multiplications
11:03:23 <ski> > a ^ 10 :: Expr
11:03:25 <lambdabot>  a * a * (a * a) * (a * a * (a * a)) * (a * a)
11:03:42 <ski> the five `a * a's here are actually the same, are shared
11:03:51 <ski> and the two `a * a * (a * a)'s are also the same
11:04:12 <hpc> huh
11:04:25 <ski> so there's actually only four multiplications there, not nine
11:04:51 <nickrandom> Welkin, fib x y =  if y > 4000000 then x else fib y (x+y)
11:04:58 <ski> let a2 = a * a; a4 = a2 * a2; a8 = a4 * a4 in a8 * a2
11:05:01 <nickrandom> What's wrong here?
11:05:07 <nickrandom> (everything XD)
11:05:29 <Welkin> nickrandom: what are you trying to do?
11:05:30 <Tuplanolla> How does this lead to matrix exponentiation, ski?
11:05:34 <nickrandom> Welkin, euler 2
11:05:50 <ski> Tuplanolla : let `a' be the matrix `[[0,1],[1,1]]'
11:05:53 <nickrandom> https://projecteuler.net/problem=2
11:05:58 <cocreature> runeks: works for me™
11:06:15 <Welkin> nickrandom: I don't know which exercise that is, but you can use `takeWhile` on the resulting fibonacci sequence to check the value and `takeWhile (< 4000000)`
11:06:26 <runeks> cocreature: I see. Thanks
11:06:47 <ski> try squaring, and cubing, that matrix
11:07:30 <Tuplanolla> Ah, I see now.
11:07:31 <Welkin> > let fib a b = a : fib b (a + b) in takeWhile (< 4000000) (fib 0 1)
11:07:31 <nickrandom> I should learn haskell in a better way :\
11:07:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:07:41 <Welkin> eh, he still cuts it off
11:07:48 <Welkin> should be [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578]
11:08:02 <Welkin> nickrandom: how are you learning it now?
11:08:11 <Welkin> project euler is a terrible way to learn haskell
11:08:13 <Welkin> I tried it
11:08:24 <nickrandom> trying to solving/rewriting project euler solutions gh
11:08:28 <ski> it turns out that `a^n' will be the matrix `[[fib n,fib (n+1)],[fib (n+1),fib (n+2)]]'
11:08:39 <runeks> cocreature: What OS are you on?
11:08:44 <Welkin> nickrandom: start a small project instead
11:08:57 <nickrandom> What kind of project?
11:08:59 <Welkin> project euler is not meant for programming anyway
11:09:00 <ski> Tuplanolla : so, this is more efficient that doing it sequentially, iterating `n-2' times
11:09:12 <Welkin> most of the problems are easier solved using math, not brute force programming
11:09:16 <nickrandom> I usually start to learn programming languages making a irc bot
11:09:17 <Welkin> many are unsolvable with brute force
11:09:28 <Welkin> nickrandom: I did that too, and it is easy in haskell
11:09:28 <nickrandom> Pretty easy, but not for haskell maybe
11:09:33 <nickrandom> Oh really?
11:09:38 <Welkin> let me find you a short guide that shows how to make an irc bot in less than 100 lines
11:09:43 <Tuplanolla> I was confused at first since matrix exponentiation usually refers to the matrix being in the exponent, ski.
11:09:47 <nickrandom> :O
11:09:52 <Welkin> https://wiki.haskell.org/Roll_your_own_IRC_bot
11:09:58 <nickrandom> Thanks Welkin! :D
11:10:01 <Welkin> I used that one when I was getting started
11:10:32 <Welkin> although it uses the Printf library o.o
11:10:36 <Welkin> you don't need to
11:10:49 <cocreature> runeks: archlinux, the relevant file for you should be https://github.com/vincenthz/hs-certificate/blob/master/x509-system/System/X509/MacOS.hs
11:11:28 <runeks> cocreature: Great. And thanks again for trying it out
11:12:57 <nickrandom> Welkin, why server = "irc.freenode.org" ?
11:13:00 <nickrandom> without let?
11:13:11 <Welkin> nickrandom: for another resource, here is the basic irc bot I wrote 3 years ago (~150 lines) https://github.com/ericnething/plasmonbot/blob/master/Main.hs
11:13:27 <Welkin> nickrandom: that is a top-level definition
11:13:36 <Welkin> he just didn't include the type declaration above it
11:13:52 <Welkin> which would be `server :: String`
11:14:10 <Welkin> and `port :: Int`
11:14:25 <Welkin> you can define values at the top level like you can with functions
11:14:45 <Welkin> these, of course, are constants
11:15:23 <nickrandom> so when should i use let?
11:15:45 <Welkin> in an expression
11:17:21 <Welkin> one thing that may be an issue is that this tutorial uses ReaderT, so if you don't know monad transformers yet (or monads) it might be a challenge
11:17:39 <Welkin> it really is quite simple, but if you have never seen it, you may be baffled at what is going on
11:18:35 <newbofnewbs> Anyone want to help a complete newb try to approach a problem?
11:18:50 <Welkin> ask your question and we shall see
11:19:18 <newbofnewbs> I'm trying to figure out how to return the 3rd element of a list in haskell and am completly lost on how to approach the problem.
11:19:31 <Welkin> do you know how lists work?
11:19:56 <newbofnewbs> Yes. Just not use to functional programming
11:20:02 <Welkin> I mean in haskell
11:20:14 <Welkin> how do you construct a list?
11:20:34 <newbofnewbs> [] , del
11:20:45 <monochrom> I don't think there is "del".
11:20:49 <Welkin> what is the comma and the `del`?
11:20:58 <newbofnewbs> [1,2,3,4]
11:21:05 <Welkin> okay, that is syntactic sugar
11:21:09 <newbofnewbs> :(
11:21:16 <Welkin> are you familiar with the definition for a list?
11:21:21 <newbofnewbs> can't you use ::?
11:21:30 <Welkin> yes, `:` is a list constructor
11:21:32 <Welkin> one of them
11:21:33 <newbofnewbs> isn't a  list just 1::2::3::[]
11:21:34 <int-e> :t (:)
11:21:35 <lambdabot> a -> [a] -> [a]
11:21:37 <newbofnewbs> oh one my bad
11:21:52 <Welkin> data List a = Nil | Cons a (List a)
11:21:59 <Welkin> this is the canonical definition for a list
11:22:06 <Welkin> where Cons is (:) and Nil is []
11:22:27 <Welkin> so you can see that is a recursive data structure chained together with Cons (:)
11:22:30 <monochrom> Next you will need "pattern matching"
11:22:41 <newbofnewbs> so somehow I need to construct a function that recursively gets third item and uses : to construct said list?
11:22:52 <Welkin> so, you example you gave above of [1,2,3,4] is actually 1 : 2 : 3 : 4 : []
11:24:03 <Welkin> you could write a recursive function that traverses the list, grabbing the first element on each step and incrementing a counter, until you get to 3
11:24:09 <Welkin> however, there is an easier way
11:24:22 <Welkin> you can pattern match as deep as you wish
11:25:12 <Welkin> meaning that you can match on first : second : third : rest
11:25:18 <newbofnewbs> I havn't learned to much about patterns, can't you point me to what you mean? I've been following learn you some haskell
11:25:24 <newbofnewbs> can*
11:25:27 <Welkin> where rest is the rest of the list
11:26:04 <Welkin> read the chapter on pattern matching to get a basic idea of how it works
11:26:19 <Welkin> you can play around in ghci as well
11:26:30 <newbofnewbs> Mmk, thanks for the guidance.
11:26:34 <Welkin> > let first : rest = [1,2]
11:26:36 <lambdabot>  <no location info>: error:
11:26:36 <lambdabot>      not an expression: ‘let first : rest = [1,2]’
11:26:45 <Welkin> > let first : rest = [1,2] in (first, rest)
11:26:46 <lambdabot>  (1,[2])
11:26:56 <Welkin> first is 1, rest is [2]
11:27:02 <Welkin> > let first : rest = [1,2,3,4] in (first, rest)
11:27:03 <lambdabot>  (1,[2,3,4])
11:27:18 <Welkin> > let first : second : rest = [1,2,3,4] in (first, second, rest)
11:27:20 <lambdabot>  (1,2,[3,4])
11:28:20 <Welkin> it's too bad my chapter on lists isn't done yet!
11:28:25 <Welkin> I have to finish writing it
11:28:30 <ski> Tuplanolla, ok
11:28:31 <Welkin> I could have pointed you to that
11:29:50 <newbofnewbs> Yeah this stuff is hard for me to understand comming from only imperative. I think it helps to talk to someone about it.
11:31:13 <ski> newbofnewbs : it also helps to realize that learning a new programming paradigm will feel a bit like learning to program from scratch, all over again
11:31:30 <ggVGc> that's the great part :)
11:31:40 <ski> (there is much to unlearn, specifically, which is hard to do)
11:31:40 <ggVGc> I want to learn quantum computing
11:31:42 <ggVGc> bet it's the same thing
11:32:01 <newbofnewbs> idk scary seems to fit in better than great for me
11:32:05 <monochrom> As quantum mechanics? Yeah.
11:32:21 <ski> ggVGc : have you tried logic programming, or constraint logic programming, already ?
11:32:28 <Welkin> newbofnewbs: I cover basic pattern matching in this first chapter. Chapter 3 covers lists, but that is not online yet. http://haskellroguelike.com/lessons/1/
11:32:50 <ggVGc> ski: hm, not really. Pascal is logic programming right?
11:32:53 <monochrom> Actually even easier because finite-dimensional vectors rather than whole bloody wave functions.
11:33:01 <ggVGc> wait, fortran I meant
11:33:13 <ggVGc> pascal is just imperative eh :)
11:33:31 <monochrom> But as far as imperative goes, Pascal is pretty good.
11:33:33 <ggVGc> hm, maybe fortran isn't logical
11:33:40 <Welkin> newbofnewbs: I wrote it specifically for people new to haskell and functional programming. I'd love your feedback if you try it out
11:33:43 <ski> Prolog is logic programming
11:33:44 <ggVGc> wonder what language I'm thinking of
11:33:47 <ggVGc> ah, prolog
11:33:48 <ski> as is Oz and Mercury
11:33:49 <ggVGc> that's what I meant
11:33:50 <ggVGc> fuck
11:33:51 <monochrom> But Fortran made its important contribution.
11:34:06 <ski> @where CTM
11:34:06 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
11:34:08 <ski> uses Oz
11:34:13 <ggVGc> I've actually been meaning to look at prolog many times
11:34:17 <ggVGc> also, been fairly interested in APL
11:34:40 <ggVGc> are you saying quantum computing is logic programming?
11:34:45 <ggVGc> I saw MS has made a quantum computing SDK
11:35:07 <gestone> could someone explain to me the applicative instance of functions? i'm struggling to see how:
11:35:10 <gestone>   primaryKey t = TblKey (tblField1 t) (tblField2 t)
11:35:12 <gestone> is equal to:
11:35:12 <gestone>   primaryKey = TblKey <$> tblField1 <*> tblField2
11:35:33 <monochrom> Quantum computing is going to be a lot of linear algebra.
11:35:42 <ski> Mercury is like a more modern Prolog, with a module system, statically checked types (with algebraic data types, parametric polymorphism, existentials, type classes (not of higher kinds, though)), statically checked modes, insts and determinism
11:35:57 <ski> oh, Mercury is also pure declarative, no side-effects
11:35:57 <monochrom> It will not be like learning to program from scratch.
11:36:23 <ski> Prolog is old, has side-effects, is "dynamically typed"
11:36:36 <monochrom> It will be like learning "what's a computer" from scratch.  And regret of flunking linear algebra 2 decades ago.
11:36:52 <Welkin> gestone: TblKey is a function from some a -> b -> c, it is being mapped over tblField1 :: f a, and that is then mapped over tblField2 :: f b to give you some :: f c
11:37:07 <ski> however, it may be easier to learn Prolog, anyway, since most of the literature is for Prolog
11:37:46 <Welkin> ah, I forgot on thing there
11:37:54 <ski> also consider "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html>
11:38:10 <ski> (which can be interesting to read, imho, even if one doesn't plan to learn either)
11:38:26 <Welkin> tblField1 and tblField2 both are functions from some d
11:39:05 <Welkin> gestone: this can take some time to explain. I tried too quickly.
11:39:13 <ski> gestone : do you know about the `Applicative' instance for `Reader rho' ?
11:39:22 <Welkin> but fmap (or <$> as shown in your example) is `compose` for functions
11:39:34 <gestone> Welkin: yep i understand that much
11:39:53 <gestone> ski: it's been a while, i remember reading about it once in haskellbook
11:40:06 <Welkin> I'll let ski take over
11:40:07 <aerkenemesis> Hey! I'm super new to haskell (I'm a C++ professional that suddenly aquired a liking for functional languages). As an exercise I'm designing my own language using Parsec for parsing. Now I got to the point where I have a prototype of my parser that works, I did this using resources all around the internet for inspiration. I can't seem to find any info of how to start on the conversion from parse tree to AST, or how to design an 
11:40:15 <aerkenemesis> Where are some good resources for this?
11:40:31 <gestone> so i understand that something like (+1) <$> (+2) == ((+1) . (+2))
11:41:01 <ski> Welkin : hey, i wouldn't want to deprive you of the learning experience :)
11:41:47 <ski> aerkenemesis : cut off near ".., or how to design an"
11:42:24 <gestone> but i'm failing to see where the `t` variable goes in the example above, how does it fed into both the functions?
11:42:47 <aerkenemesis> ski: what do you mean?
11:43:19 <metahumor> gestone: it doesn't, you will do "(TblKey <$> tblField <*> tblField) t"
11:43:27 <MarcelineVQ> he means that webclients have silent character limits :(
11:43:32 <aerkenemesis> oh crap
11:43:37 <metahumor> gestone: if you notice, the second defn of "primaryKey" does not have "t" on the LHS
11:43:40 <mmaruseacph2> aerkenemesis: your text was too long
11:43:50 <ski> aerkenemesis : there is a message length limit in IRC. if you overstep it, your message gets cut off. i pointed out that your message looked truncated past the indicated point
11:43:58 <gestone> metahumor: ahh yeah it's point free style
11:44:12 <aerkenemesis> short version: I made a parser for my own language using resources all around the web. I can't find any info on how to convert parse tree to AST, or how to do type checking and interpretation
11:44:20 <ski> (not webclients per se. IRC per se. some clients try to work around this by guessing the limit, though)
11:44:20 <aerkenemesis> Are there any recommended resources?
11:44:23 <Welkin> point-free is a common source of confusion for everyone
11:44:40 <Welkin> it still confuses me often
11:44:46 <Welkin> especially when I try to be too clever
11:44:52 <Welkin> so I have stopped trying to be clever
11:45:00 <[exa]> bad decision indeed
11:45:07 <Welkin> precedence and point-free are not a good mix
11:45:10 <[exa]> pointfree is like parens in lisp
11:45:11 <amalloy> aerkenemesis: do you have an AST data type in mind already? if not, you should design one; if so, you will probably want a recursive function that consumes a parse tree and produces an AST
11:45:12 <quchen> And it’s not even beneficial to performance to save naming variables.
11:45:25 <[exa]> when you get it, the hidden variables reappear
11:45:47 <aerkenemesis> amalloy: I don't, I basically don't know what I'm doing. All I have so far is a parser
11:45:52 <aerkenemesis> Which I wrote with Parsec
11:46:26 <ski> aerkenemesis : it's common to make the parser directly construct an AST, skipping the explicit parse tree. sometimes one needs to adjust it a little bit afterwards, e.g. to take operator precedence into account
11:46:29 <amalloy> aerkenemesis: a perhaps-simpler first step you could do would be to write an interpreter for your parse tree directly
11:46:42 <quchen> aerkenemesis: Have you seen »write yourself a lisp«? It’s a great intro
11:46:51 * ski . o O ( wholemeal programming )
11:46:54 <quchen> s/lisp/scheme
11:46:57 <quchen>  /
11:46:58 <aerkenemesis> quchen: I did bookmark that at some point
11:47:09 <aerkenemesis> Any recommended books?
11:47:22 <sm> aerkenemesis: I would read megaparsec's tutorials
11:47:30 <sm> there's probably something similar there
11:47:35 <quchen> It also features an interpreter, in addition to the parser
11:47:42 <aerkenemesis> sm: thank you, I'll look in to that. Is megaparsec a different library than parsec?
11:47:52 <sm> yes, it's a modern fork of parsec
11:48:09 <aerkenemesis> sm: would it be wise to port my parsec code to megaparsec?
11:48:14 <sm> yup
11:48:18 <quchen> Parsec is old and unmaintained, megaparsec is a modern fork
11:48:30 <[exa]> +1 for megaparsec, just for the error messages
11:48:32 <aerkenemesis> Its only about 180 lines so it shouldn't be that rough
11:48:39 <ski> aerkenemesis : perhaps EOPL, or the Dragon book, would be interesting to take a look at. or "Modern Compiler Implementation in ML/C/Java" by Andrew Appel
11:48:41 <[exa]> btw the porting isn't anywhere near complicated
11:48:49 <quchen> They’re mostly compatible
11:49:04 <[exa]> chances are that you rewrite the imports and it just works
11:49:11 <aerkenemesis> that is super cool
11:49:19 <aerkenemesis> ski: ty
11:49:19 <quchen> Dragon Book is 50% parsing :-/
11:49:23 <[exa]> plusminus some type aliases etc.
11:49:48 <Welkin> I used write yourself a scheme and didn't understand what I was doing half the time
11:49:52 <Welkin> but I still got a working scheme
11:49:55 <[exa]> quchen: we have the printed dragon book in a glass box so that no one can read it anymore
11:50:09 <ski> i heard "Let's Build a Compiler" by Jack Crenshaw at <https://compilers.iecc.com/crenshaw/> being suggested by someone .. it's probably simpler, but doesn't cover as much, as deeply
11:50:12 <Welkin> quchen: really?
11:50:13 <ski> aerkenemesis : you could try it, i suppose
11:50:22 <ski> @where EOPL
11:50:22 <lambdabot> I know nothing about eopl.
11:50:37 <Welkin> I never studied compilers, but I have heard that courses focus way too much on parsing and don't get to the interesting parts like rewriting and optimizations
11:50:47 <Welkin> and the infamous dragon book
11:50:49 <aerkenemesis> I think I'll start with write yourself a scheme and see how it applies to my langauge, it's very different though
11:50:54 <ski> EOPL <https://www.cs.indiana.edu/eip/eopl.html>
11:51:40 <ski> Dragon book <https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools>
11:52:04 <aerkenemesis> The one I'm designing is a functional shell scripting variant. I'm actually hoping it'll be useful at some point but we'll see, haha
11:52:35 <Welkin> aerkenemesis: just use haskell as your shell scripting language
11:52:38 <Welkin> lots of people already do
11:52:51 <Welkin> https://hackage.haskell.org/package/turtle
11:52:53 <ski> "Modern Compiler Implementation" <https://www.cs.princeton.edu/~appel/modern/>
11:53:00 <aerkenemesis> Welkin: I want something simple that I don't have to compile though
11:53:13 * ski liked the latter book (the ML version)
11:53:28 <hpc> the dragon book is a classic, but it's pretty dated
11:53:38 <Tuplanolla> @where+ eopl Essentials of Programming Languages by Friedman, Wand and Haynes in 2001 <https://www.cs.indiana.edu/eopl/>
11:53:38 <lambdabot> Good to know.
11:53:42 <hpc> and definitely when you're using parsec, you'll want more recent information
11:55:27 <Welkin> Friedman is the guy who wrote the scheme books
11:55:27 <ski> for parser combinators, you may perhaps want to check out the functional pearl paper on parsing
11:55:32 <Welkin> The Little Schemer
11:55:54 <ski> <http://www.ccs.neu.edu/home/matthias/BTLS/>
11:57:32 <ski> "Functional Pearl - Monadic Parsing in Haskell" by Graham Hutton,Erik Meijer in 1998 at <http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf>
11:57:38 <quchen> Welkin: Yes, really.
11:58:15 <quchen> [exa]: Related, http://existentialcomics.com/comic/62
11:58:26 <ski> aerkenemesis : are you aware of Scsh ?
11:58:36 * ski forgets another functional shell
11:59:20 <Welkin> quchen: is that John Cleese?
11:59:29 <ski> (then there's also a shell with ideas borrowed from logic programming : F[i]-shell <http://fishell.sf.net>)
11:59:51 <quchen> Welkin: »The other guy is drawn after John Cleese, as an homage to Monty Python.« – my guess is yes
12:01:03 <quchen> Cheese shop sketch etc :-)
12:01:12 <Welkin> haha
12:01:19 <quchen> And dead parrots
12:01:21 <aerkenemesis> ski: what is scsh?
12:01:31 <aerkenemesis> Is it useful?
12:01:37 <aerkenemesis> aah its scheme shell
12:01:56 <Welkin> ski: there is also fish!
12:02:06 <aerkenemesis> yes I am aware of it but I need a project to get started with haskell, so I write my own :P
12:02:37 <ski> aerkenemesis : Scheme Shell <https://scsh.net/docu/html/man.html>
12:03:02 <ski> Welkin : yea, but that isn't logic, or functional, programming inspired, is it ?
12:03:22 <[exa]> quchen: still waiting for the kan't pun though
12:03:34 <Welkin> ski: nope
12:03:39 <quchen> Not gonna happen ;-)
12:04:04 <[exa]> I hope he's just waiting for the zarathustra number
12:06:56 <ski>   "The story of jhc  When I first started to learn Haskell in 1999, I decided I needed a project. Haskell was my first (modern) functional language and I was seduced by its robust strong type system and efficiency gains. After writing a toy ray-tracer (my usual first project in a new language) it was clear I needed to try something somewhat more challenging and jhc was born. .."
12:07:10 <ski>   ".. My reasoning was simple, by writing a Haskell compiler in Haskell I will double my language learning speed since I will not only have to learn how to program in it by forcing myself to complete a non-trivial project, but also its subtle semantics and dark corners since I actually needed to implement it correctly. Writing a compiler is also doubly efficient to begin with, .."
12:07:18 <ski>   ".. since if you self-compile improvements not only give you a better optimizer, but also speed up your self-compiled compiler. All in all I figure I was making very good use of my time. For some reason, when I explain my reasoning to other people they look at me like I am crazy, but I can detect no flaw in my logic."
12:07:44 <ski> aerkenemesis : i suppose you *could* try that ^ route, if you feel up for it ..
12:10:09 <[exa]> well, from purely technical reasons of self-reference that is also the most intelligent way to go
12:10:44 <aerkenemesis> This is how MASH looks like http://codepad.org/q79rxgxi
12:16:07 <aerkenemesis> ski: I think writing a haskell compiler is slightly above my level of ambition :S I can't even use haskell at work, it's either C++, python or bash
12:17:05 <nickrandom> Welkin, i have a question about the bot
12:17:18 <aerkenemesis> My boss was concerned because people were complaining that I wrote a script in Ruby, I can only imagine if I start writing production code in Haskell
12:17:33 <ski> ok
12:17:36 <nullie> Yeah, I wrote JavaScript to Python compiler, improved my JavaScript knowledge dramatically
12:17:36 <Welkin> nickrandom: go ahead
12:18:25 <nickrandom> connectTo returns an IO and an Handle according to doc https://hackage.haskell.org/package/network-2.6.3.3/docs/Network.html#g:4
12:18:58 <nickrandom> I tried to write it reading the doc and i wrote
12:19:00 <nickrandom>     hPutStr h "NICK haskellpi\n"
12:19:00 <nickrandom>     hPutStr h "USER haskellpi * * :*\n"
12:19:13 <nickrandom> Using the handle
12:19:41 <nickrandom> Now i read what the page you linked do
12:19:56 <nickrandom> It uses write instead of hPutStr, is it the same thing?
12:20:13 <nickrandom> Are there differences between hPutStr and write?
12:22:03 <nickrandom> Oh, write is a declared function
12:22:14 <nickrandom> that uses hPrintf
12:25:27 <aerkenemesis> sm: you said megaparsec is a modern fork of parsec. What is the difference between modern and old haskell?
12:27:27 <Welkin> aerkenemesis: it's not about modern vs old haskell
12:27:30 <sm> aerkenemesis: megaparsec documents its differences from parsec
12:27:31 <Welkin> haskell is always changing
12:27:54 <Welkin> parsec itself has been around a long time and is a bit outdated and not maintined these days
12:27:54 <davean> aerkenemesis: *megaparsec* is modern
12:28:12 <davean> aerkenemesis: in that its made things people consider improvements
12:29:00 <parsnip> why am i suddenly getting exception index out of range when i tried to go from list comprehension to do syntax?
12:29:03 <parsnip> http://lpaste.net/362341
12:29:57 <quchen> return strs !! i == [strs] !! i
12:30:33 <quchen> parsnip: ^
12:30:49 <geekosaur> more precisely, it's (return strs) !! i
12:30:58 <geekosaur> and "return will be in the list monad, so [strs]
12:31:57 <parsnip> yep. shame on me for not just looking for ways to find my error. i wanted to get up from this table soon, thank you.
12:32:46 <parsnip> i could have done some exception catching, or worked from a minimal _working_ example, or i guess do some pencil work to consider types.
12:33:06 <parsnip> the last would have been tricky to anticipate, but maybe a lesson that i should be fluent with that.
12:33:27 <parsnip> just like in a perfect world i'd be fluent with proving loop/recursion invariants.
12:33:43 <quchen> Perfect worlds sound inconsistent
12:37:12 <subfactorial___> speaking of megaparsec, if anyone considers themselves an expert there I'd appreciate a look at https://stackoverflow.com/questions/48725002/megaparsec-reports-incorrect-location-on-parse-error as I'm out of ideas
12:37:13 <aerkenemesis> sm: yeah that GenLanguageDef made my eyes hurt when I saw it, I'm glad to find out megaparsec fixed that
12:41:52 <Welkin> akkad [akkad@166.84.6.60] has quit [Excess Flood]
12:42:03 <Welkin> I can't help but see that as a joke about the city of Akkad
12:50:41 <boxscape> so, IntMap has a lot of functions that are in O(min(n,<,
12:50:46 <boxscape> oops, let me finish that
12:51:26 <boxscape> O(min(n,W)), where W is the number of bits in Int. Just to make sure, am I understanding this correctly that this means the functions take the same amount of time, regardless of n, if you have more than 64 elements?
12:51:44 <boxscape> (I'm trying to find a data structure that's reasonably fast to update without having to use mutable vectors)
12:52:22 <boxscape> (which could have up to a million elements or so)
12:57:46 <nshepperd> basically
12:57:57 <nshepperd> it's kind of an abuse of big-O notation
12:59:03 <lyxia> how is it abusing the notation
13:00:23 <nshepperd> i mean, it's equivalent to O(1). or O(W) i suppose if you care about how it varies with different architectures up to infinite bits per word
13:11:50 <`Guest00000> how do you call the function :: Either a a -> a  ?
13:14:43 <Tuplanolla> That would be `untag`, `Guest00000.
13:25:56 <carbolymer> is it possible to pattern match a datatype constructor without explicit list of arguments (even without wildcards)?
13:27:19 <kadoban> carbolymer: You can use record syntax,  Blah {}
13:32:29 <carbolymer> kadoban, works, thanks!
13:33:39 <kadoban> Anytime
13:35:34 <carbolymer> lexi-lambda, "An opinionated guide to Haskell in 2018" - really nice article!
13:42:03 <jle`> `Guest00000: do you mean either id id ?
13:42:38 --- mode: card.freenode.net set +o ChanServ
13:45:32 <Dynasty> Does anyone know under what circumstances typeclass functions can be monomorphized and under what circumstances dictionary passing must be used? I'm interested in the underlying details. http://okmij.org/ftp/Computation/typeclass.html
13:49:22 <lexi-lambda> Dynasty: all Haskell 98/Haskell 2010 uses of typeclasses can be compiled via specialization. existential quantification/GADTs can require dictionary passing.
13:53:35 <Dynasty> lexi-lambda: Thanks for the answer! I'm working on a compiler that does not allow generalization on local let bindings. I assume this will not be a problem for typeclass monomorphization?
13:55:09 <metahumor> lexi-lambda: i'm looking at text-conversions after reading you blog post, i really like your reasoning, thank you for putting all of that in the same place!
13:55:50 <lyxia> Uh, don't polymorphic recursion and higher-rank functions get in the way of monomorphization?
13:56:02 <danilo2_> Hi guys! I've got problem with how my HAskell code look like. I'ts ugly when I constantly write {-# UNPACK #-} everywhere. I know I can use the flag to unpack strict fields but then I dont see if I make mistake nad something cannot be unpacked. I want to be notified about it. Is there any other option imn not aware of ?
13:56:39 <danilo2_> like "unpack all strict fields in this module and tell throw warning whenever its not possible, or throw warning if there is no NOUNPACK pragma" ?
13:57:00 <lyxia> danilo2_: put the types you want to unpack in an .Unpack module
13:57:41 <danilo2_> lyxia: hmmm, I dont think it solves my issue unless Unpack modules is some magic GHC module I didnt know about
13:57:51 <lyxia> You don't get warnings but you have to be very distracted to add a type you don't want to unpack there
13:58:24 <danilo2_> lyxia: Nope, I want warnings :( The code will be not maintained only by me. warnings are the only option here
13:59:16 <lyxia> Ah I see I misunderstood what you want.
13:59:20 <danilo2_> lyxia: I prefer to write this ugly UNPACK everywhere than create some special module for it :(
13:59:45 <Dynasty> lyxia: I looked up polymorphic recursion and higher-rank functions. Does vanilla Haskell even support these features?
13:59:59 <danilo2_> lyxia: I just want to have behavior like - automatically put unpack everywhere (unless I explitly tell NOUNPACK and warn me if unpack was not possible)
14:00:26 <lexi-lambda> lyxia is right, polymorphic recursion is Haskell 98 that causes trouble with monomorphization. higher-rank types are in GHC but not Haskell 98 or Haskell 2010, though.
14:03:42 <pikajude> is it possible to build a hoogle database of packages from multiple different GHC versions?
14:04:52 <Dynasty> I think that I should be able to outlaw polymorphic recursion by validating the type definitions
14:08:25 <lyxia> > let polyShow :: Show a => Int -> a -> String ; polyShow 0 a = show a ; polyShow n a = polyShow (n-1) [a] in polyShow 3 ()
14:08:27 <lambdabot>  "[[[()]]]"
14:08:35 <lyxia> Dynasty: How do you outlaw that ^
14:15:54 <ddellacosta> not explicitly Haskell-related but: does anyone know if there is obvious precedent for the syntax used in the "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" paper? Not just the bananas mentioned in the title but for example the sword-like thing (sorry I don't know its name) used for bifunctors, or the triangle used for combinators, etc.
14:16:35 <ddellacosta> triangles I should say, since there are a bunch of variations
14:19:52 <hask_bee_3> Anyone here using Stack's Nix integration?
14:23:39 <infinisil> hask_bee_3: have used it
14:23:54 <hask_bee_3> Ok check this out: https://docs.haskellstack.org/en/stable/nix_integration/
14:24:25 <hask_bee_3> In these lines, how does it determine which *version* of those packages to use?
14:24:27 <hask_bee_3> nix:
14:24:27 <hask_bee_3>   enable: true
14:24:28 <hask_bee_3>   packages: [glpk, pcre]
14:24:57 <infinisil> hask_bee_3: most likely the ones from your nixpkgs version
14:25:52 <infinisil> hask_bee_3: if you need to have more control, you can https://docs.haskellstack.org/en/stable/nix_integration/#using-a-custom-shellnix-file
14:27:45 <hask_bee_3> Thanks, that makes sense
14:28:16 <hask_bee_3> infinisil Although I'm not sure yet what "your nixpkgs version" means. Is it similar to stack "resolver" concept?
14:28:29 <Dynasty> lyxia okay I was just looking back at some of the type inference rules that I've used in the past. In the system that I'm looking at, the generalization step for a top level recursive function binding doesn't occur until after the function itself is type checked. I'm not sure if type classes will change anything. Here's two relevant rules that I'm looking at (the first is for a top level recursive function, the second is
14:28:29 <Dynasty> for a local let-rec binding): https://i.imgur.com/IikOy4w.png
14:28:52 <infinisil> hask_bee_3: it uses the `libfoo` from `(import <nixpkgs> {}).libfoo`
14:29:14 <infinisil> hask_bee_3: which is the same as the one you'd install with `nix-env -i libfoo`
14:31:41 <hask_bee_3> I gotta read the nix manual now :)
14:34:24 <infinisil> hask_bee_3: Alright, I'm here and in #nixos too
14:34:32 <hask_bee_3> cool, thanks :)
14:40:08 <concaveirc> I am casting numbers to Word16 using (a :: Pixel16) (JuicyPixels).
14:40:15 <jannesan> hey guys, is anyone here using nvim with neco-ghc for autocompletion? i can't get neco-ghc to work, so looking for someone who got it working and can point me in the right direction.
14:40:32 <concaveirc> However, when the int gets out of bounds, the number wraps around instead of throwing an exception.
14:40:47 <concaveirc> Is there a GHC option to throw an exception instead of wrapping Word16s?
14:42:32 <Dynasty> lyxia if you have some reference to type rules for a Hindley-Milner system that has type classes, that would be great. Most of the resources on the internet are for plain Hindley-Milner. The crucial thing that needs to be determined is where function definitions are generalized.
14:46:35 <metahumor> jannesan: I use neco-ghc, you have to have ghc-mod available on path. or you can edit the plugin to use "stack exec -- ghc-mod" instead
14:50:49 <Dynasty> > polyShow 0 a = show a ; polyShow n a = polyShow (n-1) [a] in polyShow 3 ()
14:50:52 <lambdabot>  <hint>:1:14: error:
14:50:52 <lambdabot>      parse error on input ‘=’
14:50:52 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:55:28 <Dynasty> > let polyShow 0 a = show a ; polyShow n a = polyShow (n-1) [a] in polyShow 3 ()
14:55:30 <lambdabot>  error:
14:55:31 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
14:55:31 <lambdabot>        Expected type: t -> [a] -> String
14:55:44 <Dynasty> Aha
14:56:32 <Dynasty> lyxia it seems that the type rules are different in the presence of a type annotation
14:57:28 <lyxia> Indeed
14:58:46 <lyxia> Okay if you rule that out, I'm not sure what's left that could cause problems
14:58:57 <Dynasty> I guess for my language then, I can just use one type rule even in the presence of an annotation
14:59:27 <lyxia> right
14:59:34 <nshepperd1> Ghc can't infer constrained polymorphic recursion
15:00:53 <mniip> Dynasty, the problem is not typeclasses
15:01:01 <mniip> it's polymorphic recursion
15:01:13 <mniip> original HM didn't have letrec, especially not a polymorphic one
15:01:22 <mniip> and fix :: (a -> a) -> a  is a monomorphic recursion
15:01:24 <lyxia> concaveirc: use another type with a custom Num instance
15:02:30 <Dynasty> How much is expressiveness is lost by not supporting polymorphic recursion?
15:03:22 <lyxia> not much
15:07:16 <Dynasty> Right, I think I understand why the restriction is not just for value constructors. The value constructor issue can be viewed as a more general problem which is called polymorphic recursion. The value constructors can just be viewed as ordinary functions. I think in my language the win for not having to pass around dictionaries is more than what is gained from supporting polymorphic recursion.
15:08:24 <Dynasty> okay I have to go. Thanks for the help lyxia :)
15:09:26 <quchen> Original HM also doesn’t have type annotations
15:09:56 <quchen> Even given polymorphic recursion, GHC sometimes rejects valid programs
15:10:16 <quchen> :t let f [] = (); f (_:xs) = f (zip xs xs) in f
15:10:17 <lambdabot> error:
15:10:17 <lambdabot>     • Occurs check: cannot construct the infinite type: b1 ~ (b1, b1)
15:10:17 <lambdabot>       Expected type: [(b1, b1)] -> ()
15:10:25 <quchen> :t let f :: [a] -> (); f [] = (); f (_:xs) = f (zip xs xs) in f
15:10:26 <lambdabot> [a] -> ()
15:16:48 <mniip> quchen, this is an insoluble set of constraints
15:17:06 <quchen> How do you mean?
15:22:09 <hpc> quchen: it doesn't disolve in water, obviously
15:22:39 <quchen> But it does, if you shine some light on it!
15:23:18 <hpc> heh
15:24:05 <hpc> i can see how it has trouble infering that bit of polymorphic recursion
15:24:20 <quchen> I can only see *that* it has trouble.
15:25:15 <hpc> it naively builds a set of constraints and then tries to solve them
15:25:28 <hpc> and one of the constraints it comes up with is that one that results in an infinite type
15:25:59 <hpc> when you give it a type signature, it just makes sure everything individually lines up with what you said instead of against each other
15:26:10 <quchen> I don’t see it. Where specifically does that constraint come from? It looks to me that the type variable is instantiated too early.
15:26:36 <quchen> f [] = () -- ok, f :: [a] -> ()
15:27:10 <quchen> f (_:xs) = stuff -- ok umm let’s look at the RHS, but we know that f :: [a] -> something
15:27:57 <quchen> …and now I’m confused how to continue to get that error.
15:28:27 <quchen> I forgot most of what implementing HM taught me again :-(
15:33:26 <geekosaur> start from the second instead of the first? now you get f :: [a] -> b, f :: [(c,c)] -> d, b ~ d, (c,c) ~ a, and from zip :: [a'] -> [b'] -> [(a',b')] get a' ~ a, b' ~ a, and therefore (c,c) ~ (a,a) which reduces to c ~ a, which conflicts? (because it won't infer polymorphism, i.e. that f is instantiated *differently* the second time)
15:34:03 <geekosaur> ...if I am following this right, which I might not be...
15:34:30 <quchen> I trust your judgement. :-)
15:34:58 <quchen> Manual type inference is something I can only do in Java, and that certainly helps nobody here.
15:35:03 <boxscape> hm, has it always been the case in ghci that you can use arbitrary non-imported functions if you qualify them, for example that I can just load up ghci and type "Data.Set.fromList [1..5]"?
15:35:08 <geekosaur> but once you specify the type of f, this is not a problem because both uses unify with it and there is no need to try to unify the two uses
15:35:11 <geekosaur> boxscape, yes
15:35:16 <boxscape> ok, thanks
15:36:11 <geekosaur> and there is an extension you can enable to get that behavior generally, iirc
15:36:12 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-import-qualified
15:36:21 <geekosaur> it's a -f instead of an -X though
15:36:32 <geekosaur> defaults on in ghci, ghc -e, and runghc
15:37:25 <geekosaur> oh, hm, that might not be it
15:37:59 <boxscape> anyone know if there's a function in ClassyPrelude to generate an empty sequence or container? I can't seem to find one (apart from using "fromList []")
15:39:27 <boxscape> geekosaur: oh, you mean enable it in regular code, rather than ghci? that's interesting
15:39:36 <boxscape> or no wait
15:39:40 <boxscape> that's still ghci isn't it
15:40:02 <boxscape> or no, you did mean ghc :D sorry
15:40:08 <geekosaur> runghc, which interprets instead of compiling a program, also has it enabled
15:40:28 <geekosaur> it's not the greatest idea to enablke it for compiled code --- it gives ghc a bit too much rope --- but it's possible
15:40:28 <boxscape> okay
15:40:52 <boxscape> for the most part I find it more confusing than useful
15:40:54 <geekosaur> (you can;t know or control what package it imports from)
15:42:10 <geekosaur> oh, yes, I was misinterpreting what that page I pointed to said, that is the behavior in question
15:42:58 <geekosaur> and yes, it can be confusing. and worse than confusing. it's kinda deliberately evoking the mess cabal sandboxes/new-build and stack exist to prevent :)
15:44:00 <boxscape> right
15:55:07 <jle`> is there a tool that finds minimum bounds for your haskell project deps?
15:59:11 <danilo2_> Hi guys! Is there any GHC magic which will allow me to share cosntructor names between data family instances? I just want to create data family `data Foo (a :: Nat)` and `data instance Foo 0 = A Int` and `data instance Foo 1 = A String` and just ask Haskell to understand it based on the inferred type ?
15:59:15 <nisstyre> jle`: maybe stack solver?
15:59:26 <nisstyre> https://hackage.haskell.org/package/stack-1.6.3/docs/Stack-Solver.html
16:02:35 <lyxia> danilo2_: nope.
16:03:47 <jle`> hm, i don't think it's a stack thing
16:03:59 <jle`> i mean, the minimum versions of the deps where your package will build
16:04:12 <jle`> so it'll try decreasing versions until there's a build failure
16:04:32 <danilo2_> lyxia: I hoped that maybe it was introduced alongside the DuplicateRecordFields or something :(
16:04:37 <danilo2_> lyxia: thanks
16:05:00 <jle`> danilo2_: closest thing is probably just having them in different modules
16:05:10 <jle`> since essentially you're defining two distinct constructors with the same name, anyway
16:05:37 <jle`> it's basically like asking to be able to define two types whose constructors have the same name
16:06:16 <geekosaur> danilo2_, that's "type-directed name resolution" and it has some fairly significant problems in a language like Haskell
16:06:31 <geekosaur> there's an overview of it and the problems that come along with it in the haskell wii, iirc
16:06:33 <geekosaur> wiki
16:06:51 <ab9rf> for a moment i was trying to envision writing games for the wii using haskell
16:06:54 <danilo2_> geekosaur: oh cool, thanks for giving me the name I was looking for
16:07:17 <danilo2_> geekosaur, jle` I completely understand waht problems could it involve, however it could be implemented as "resolve when possible"
16:07:47 <geekosaur> https://wiki.haskell.org/TypeDirectedNameResolution which also has other links
16:08:18 <jle`> danilo2_: yeah, the point of my comment was that the problem doesn't have anything to do with data families
16:08:32 <jle`> it's an issue with data constructors in general, not just data family ones
16:08:50 <jle`> asking about data families might obscure the issue :)
16:08:59 <jle`> *might have been what obscured the issue
16:09:26 <danilo2_> jle`: of course! I used data families as an example here, just to show some basic use case.
16:09:46 <danilo2_> jle`: maybe right. I should have asked using just data types
16:10:07 <jle`> data TrigFuncs = Sin | Cos | Tan
16:10:09 <geekosaur> (the original discussion did get bikeshedded on syntax, but just type direction causes problems because it kills type inference in general. it more or less extends the multiple parameter type classes issue to arbitrary functions
16:10:18 <jle`> data Morality = Sin | Virtue
16:11:07 <jle`> imo tdnr is basically the thing that typeclasses were invented to avoid
16:11:25 <geekosaur> (where (non-TDNR) type families or functional dependencies end up being used to resolve it in the MPTC case; or with ghc8, in the worst case type applications have to be used)
16:12:10 <jle`> TDNR: "Making ad-hoc polymorphism more ad-hoc"
16:14:57 <VitorC> Hello friends, I have a question. I was wondering if there's a function in some library that does something similar to this: https://pastebin.com/4R1KzTD1
16:15:05 <VitorC> I looked very hard but didn't find anything. :(
16:16:13 <danilo2_> jle`, geekosaur hmmm, am I able to use some of the new Pattern Synonyms tooling to define pattern which will pattern match on the right constructor of a datatype based on some type inference? Thisis my real use case in fact. I want to have `data A = A_Foo; data B = B_Foo` and be able to patternpmatch on something like `Foo` which will be resolved to `A_Foo` or `B_Foo`.
16:16:25 <danilo2_> jle`, geekosaur : I only need pattern amtching, not constructing
16:17:41 <geekosaur> not pattern synonyms, no; they have fixed types. this sounds vaguely GADT-ish though
16:19:50 <danilo2_> geekosaur: basicall ywhat I've got here is `data Core a = A | B | C | D` . a is phantom type. Basicall yfrom high perspective I want users to have `Core ['A,'B]` and be able to pattern match on A and B only with non-exhaustive pattern match working properly. I jsut want to control the visibility of data fields from type level
16:20:27 <danilo2_> geekosaur: so the approach I've got right now is to create separate datatype for each possible visibility level (there are few predefined) but I want people to be able to pattern match on constructors easily
16:24:12 <danilo2_> geekosaur: using other words - I've got a multi-constructor data type. In some part of the program Im usre that only some construtors can appear there. It is important because the algorithm ddesign bases on it and its super-type safe. I jsut want to be able to tell that using types while keeping GHCs checker for non exhausitve patterns
16:25:38 <Tuplanolla> :t \ p f -> findM (pure . p) <=< sequenceA . fmap f -- This should do, VitorC.
16:25:39 <lambdabot> Monad m => (a1 -> Bool) -> (a2 -> m a1) -> [a2] -> m (Maybe a1)
16:27:32 <danilo2_> so if anyone has idea how I could achieve something liek that, any help would be highly appreciated
16:29:01 <Tuplanolla> :t \ p f -> findM (pure . p) <=< traverse f -- This is even simpler.
16:29:02 <lambdabot> Monad m => (a1 -> Bool) -> (a2 -> m a1) -> [a2] -> m (Maybe a1)
16:30:29 <Tuplanolla> One day I will learn to think in terms of `traverse` first.
16:32:25 <ski> Tuplanolla : those are not the same thing. your versions run all the effects, not just upto the selected element
16:35:17 <VitorC> I just realized I named the function something that already exists, oops.
16:35:26 <VitorC> But yes, what ski said.
16:39:22 <Tuplanolla> Indeed.
16:39:46 <ski> @type \p f -> (fmap . fmap . fmap) snd . findM (fmap (p . snd)) . map (\a -> fmap (a,) (f a))  -- this isn't quite it, either, the result is the action, not the value
16:39:47 <lambdabot> Monad f => (b -> Bool) -> (a -> f b) -> [a] -> f (Maybe (f b))
16:40:19 <manWithNoName> greetings to all programs!
16:41:03 <ski> hrm, actually that is overcomplicated anyway. there is no point in introducing pairs there, that's keeping the wrong thing around anyway
16:43:06 <ski> @type \p f -> findM (fmap p) . map f  -- i suppose this is what i had in mind, which still is not right
16:43:07 <lambdabot> Monad m => (a1 -> Bool) -> (a2 -> m a1) -> [a2] -> m (Maybe (m a1))
16:44:01 <Tuplanolla> This problem feels vaguely familiar.
16:44:38 <ski> there's some Mealy vs. Moore feeling to this, perhaps
16:45:56 <danilo2_> By the way, we are able now to emit custom errors with type classes. Are we able to emit custom warnings too ?
16:46:27 <pikajude> how do I get my own haddock to produce nice highlighting and JS like this? https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#fmap
16:46:44 <VitorC> It's alright, guys (or gals), I didn't expect this to be this difficult. I'll just stick to the initial dumb definition, I guess.
16:46:47 <VitorC> Thanks for the help.
16:47:09 <ski> VitorC : fwiw, i'd possibly invert the `Bool'
16:47:19 <ski> so that it terminates on `True', rather than `False'
16:47:36 <ski> that would be more consistent with `find' and `findM', e.g.
16:47:52 <VitorC> I see. I was trying to emulate a "while" (like in C).
16:47:58 <VitorC> But that makes more sense.
16:47:59 <ski> oic
16:48:08 <ski> @type until
16:48:09 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
16:48:24 <ski> i suppose it depends on what you call it, then
16:49:04 <ski> @hoogle untilM
16:49:05 <lambdabot> Control.Monad.HT untilM :: (Monad m) => (a -> Bool) -> m a -> m a
16:49:05 <lambdabot> Control.Monad.Loops untilM :: Monad m => m a -> m Bool -> m [a]
16:49:05 <lambdabot> Control.Monad.IfElse untilM :: Monad m => m Bool -> m () -> m ()
16:49:07 <ski> hrm
16:50:23 <ski> (there's apparently also some `whileM's)
17:59:22 <ZelteHonor> Hello there.
18:00:04 <ZelteHonor> I started doing the cute challenge there: https://mightybyte.github.io/monad-challenges/
18:00:24 <ZelteHonor> And I am stuck in an exercise. Could you help me?
18:03:20 <glguy> ZelteHonor: For someone to help you'll have to ask a question
18:04:09 <ZelteHonor> Oh yeah. Sure.
18:04:54 <ZelteHonor> So, the way that challenge work is to get a feel for monad by exposing you to the pain of working without them.
18:05:13 <ZelteHonor> There is a challenge that made us generate random letter with a seed
18:05:58 <ZelteHonor> Let me just past the relevent code.
18:08:09 <ZelteHonor> So here is the code: http://lpaste.net/362344
18:08:35 <ZelteHonor> I have randString3 that generate "lrf" wich is the right anwser.
18:08:51 <ZelteHonor> But they want us to create the generalB function wich compose multiple generator.
18:09:11 <ZelteHonor> My generalB function is working, but the list it return are in the reverse order.
18:09:26 <ZelteHonor> This
18:09:27 <ZelteHonor> repRandom (replicate 3 randLetter) (mkSeed 1)
18:09:35 <ZelteHonor> Return me "frl"
18:10:36 <ZelteHonor> How should I change the repRandom function so that the final list is in the right order.
18:10:52 <ZelteHonor> I could just try to call reverse on the return, but I think this would be a workaround the real problem.
18:11:02 <ZelteHonor> Any idea what I am doing wrong?
18:11:38 <ZelteHonor> Oops. Forget about generalB. The function I am trying to make work is repRandom.
18:12:30 <ski> call `g' and `repRandom gs' in the reverse order ?
18:12:59 <ZelteHonor> Yeah. I think I am threading the seed in reverse.
18:13:41 <ski> (also, you didn't say the type of `rand', though i'm guessing it's `Gen Integer' or something like that)
18:13:58 <ZelteHonor> Yes sorry.
18:14:03 <ZelteHonor> It is Gen Integer
18:14:11 <ski> (what happens if the `Integer' is out of range ? or does that not happen with `toLetter' ?)
18:14:48 <ZelteHonor> toLetter and rand are function from the costum prelude the challenge gives you.
18:15:16 <ZelteHonor> So I guess it does not happen.
18:18:39 <ski> did you manage to fix `repRandom' ?
18:22:57 <ZelteHonor> I am looking into changing how I thread the seed. No good yet.
18:24:15 <ZelteHonor> I'll scrap the repRandom function and try again. I am confused about how to change it now.
18:35:18 <ZelteHonor> I did it!
18:35:42 <ZelteHonor> I just changed the second match of repRandom
18:35:49 <ZelteHonor> repRandom (g:gs) = (\ s -> (\ (v,ss) -> let (vs,sss) = repRandom gs $ ss in (v:vs,sss) ) . g $ s )
18:36:34 <ZelteHonor> This way, the first value I put in the list is really the one from the first seed.
18:36:34 <ski> good, now you could eta-contract
18:36:45 <ski> right
18:37:44 <ZelteHonor> It ends with this: repRandom (g:gs) = (\ (v,ss) -> let (vs,sss) = repRandom gs $ ss in (v:vs,sss) ) . g
18:38:10 <ski> that's what you get if you eta-contract, yep
18:38:15 <ski> also, that `$' is redundant
18:38:15 <ZelteHonor> Do you see any other simplification I could use?
18:38:37 <ski> an alternative to the eta-contraction is to use `let' instead of the inner lambda
18:39:09 <ZelteHonor> Indeed. The $ is redundant. I used it because of the function hidden in the Gen.
18:39:31 * ski rarely uses `$', thinks it looks ugly
18:40:06 <ZelteHonor> I use it to get something like : f4 . f3 . f2 . f1 $ v
18:40:24 <ski> yea, i often type `(f4 . f3 . f2 . f1) v' instead
18:40:26 <ZelteHonor> but in that case it was useless.
18:40:43 <ZelteHonor> Thanks for the help.
18:40:56 <ski> what do you think of the extra `let' ?
18:41:35 <ZelteHonor> I am looking into that.
18:41:58 <ZelteHonor> How would I add it?
18:43:07 <ZelteHonor> I have a hard time seeing how I would use it, since I don't have the value to bind in the let.
18:43:17 <ski> well, you have `(\(v,ss) -> ...) . g $ s'. so you could instead do `let (v,ss) = g s in ...'
18:44:13 <ZelteHonor> repRandom (g:gs) = (\ (v,ss) -> let (vs,sss) = repRandom gs ss in (v:vs,sss) ) . g
18:44:22 <ZelteHonor> The thing is, I don't have that s.
18:44:32 <ski> <ski> an alternative to the eta-contraction is to use `let' instead of the inner lambda
18:44:35 <ski> note "alternative"
18:44:51 <ZelteHonor> Ah! I see what you mean.
18:45:54 <ZelteHonor> That?
18:45:55 <ZelteHonor> repRandom (g:gs) = (\ s -> let (v,ss) = g s in let (vs,sss) = repRandom gs $ ss in (v:vs,sss) )
18:46:48 <ski> yes. now you could merge the two `let's
18:47:11 * ski . o O ( `$' )
18:48:18 <ZelteHonor> Can I really? Because the inner let use something that I bind using the outer let.
18:48:27 <ski> doesn't matter
18:49:16 <ZelteHonor> What is the Haskell syntax for that? I just used the let for that, because I usually go for where.
18:49:28 <ski> either you use indentation, like
18:49:35 <ski>   let (v,ss) = ...
18:49:43 <ski>       (vs,sss) = ...
18:49:46 <ski>   in ...
18:50:02 <ski> or you separate the two defining equations by a `;'
18:50:37 <ZelteHonor> Ah yes. It's ;. I tried m.
18:50:38 <ZelteHonor> ,
18:50:41 <ZelteHonor> So it gives: repRandom (g:gs) = (\ s -> let (v,ss) = g s ; (vs,sss) = repRandom gs $ ss in (v:vs,sss) )
18:50:46 <ski> yep
18:50:53 <ZelteHonor> Oh yeah. Still a useless $.
18:50:59 <ski> now the brackets surrounding the lambda are also redundant
18:51:23 <ZelteHonor> Final is this?
18:51:24 <ZelteHonor> \ s -> let (v,ss) = g s ; (vs,sss) = repRandom gs ss in (v:vs,sss)
18:51:28 <ZelteHonor> Looks good to me.
18:51:31 <ski> nope, one final step
18:51:42 <ski>   addFive x = 5 + x
18:51:44 <ski> is the same as
18:51:50 <ski>   addFive = \x -> 5 + x
18:52:04 <ski> (well, two steps, possibly)
18:52:15 <ski> iow, you can move that `s' to the left of the `='
18:52:31 <ski> (as long as you do it for both defining equations of `repRandom')
18:52:51 <ZelteHonor> I know that. The reason I use a Lambda and not just put the s in parameter is, because since it return a Gen [a] and that Gen a is defined as a function, I like the right side of the function being a lambda.
18:53:06 <ZelteHonor> You see what I mean?
18:53:07 <ski> the final step then is that you could replace the `let' by a `where'
18:53:28 <ski> yeah, sure
18:53:57 <ski> i'm just showing a couple of alternate forms. directions in which you *could* massage the definition in
18:54:07 <ski> it's up to you to decide which you prefer the most
18:54:23 <ZelteHonor> Thanks a lot. I want to develop intuition. That's why I am doing those exercice.
18:54:50 <ski> i'm just interested in making you see the possibilities, to make such small refactorings more automatic for you, so that you can more immediately see the potential for them, and decide whether you want to try or not
18:56:58 <ZelteHonor> I think I'll stop at the last one I post.
18:57:11 <ZelteHonor> I don't like the where in this specific case.
18:57:23 * ski nods
19:15:12 <Squarism> I havent used "newtype" alot and now i stumbled upon a syntax ive never seen before : https://github.com/jb55/elm-export-persistent
19:15:29 <Squarism> newtype Ent (field :: Symbol) a = Ent (Entity a) deriving (Generic)
19:15:53 <Squarism> not sure what is expressed there
19:16:27 <ski> that's a kind ascription on `field', explicitly giving its kind, `Symbol'
19:18:28 <Squarism> ok, so if i have an "Entity User" and want know "Ent (Entity User)" has ToJSON instance (that implements toJSON function). How do i call toJSON
19:18:52 <Squarism> have an = have a value of type "Entity User"
19:19:03 <ski> type constructor `Ent' takes two arguments
19:20:05 * ski doesn't know what the type of `toJSON' is
19:20:42 <Squarism> ski, https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html
19:23:34 <ski> i suppose you need an instance of the class
19:31:07 <fresheyeball> HEY
19:31:11 <fresheyeball> PEOPLES!
19:31:21 <fresheyeball> so... I saw this library on twitter
19:31:31 <fresheyeball> that like generates properties for you based on some function
19:31:37 <fresheyeball> yall know what it's called?
19:41:00 <lyxia> quickcheck?
20:03:36 <jle`> quickcheck sounds like the opposite thing
20:03:42 <jle`> it generates functions for you based on some properties
20:04:29 <jle`> maybe you're thinking about finding free theorems?
20:05:18 <jle`> @free const :: a -> b -> a
20:05:18 <lambdabot> f . const x = const (f x) . g
20:06:26 <jle`> @help free
20:06:26 <lambdabot> free <ident>. Generate theorems for free
20:22:20 <ReinH> jle`: coquickckeck?
20:24:18 <jle`> ReinH: sounds about right :)
20:39:22 <pacak> Is there a way to tell stack not to rely on anything outside of the project folder and install all the things inside .stack-work? If I ask it to install specific version from hackage directly and don't nuke ~/.stack it tries to use installed packages and this leads to different libraries using different versions of text package for example. With removed ~/.stack it works as expected.
20:42:14 <metahumor> use "stack build", not "stack install"
20:44:02 <pacak> Hmm... Could be. I did used stack install once and switched to stack build later.
20:44:12 <pacak> metahumor: thanks!
21:22:01 <danilo2_> Hi guys! Is there any trick in Haskell to unpack polymorphic fields? Even when I've got them fully specified like `data A a = A {-# UNPACKWHENPOSSIBLE #-} !a; data B = B {-# UNPACK #- } !(A Int)`
21:22:24 <danilo2_> I think there isnt, but I hope there is
21:41:13 <danilo2_> btw is there any way to reify data instance in TH?
21:41:27 <danilo2_> I havent found any so far
21:46:20 <danilo2_> oh, regardind reification of data families we are able to reify data family by ists name and get all the instances in list. Im wondering if we can ijust reify a single instance
22:08:52 <glguy> danilo2_: Try reifying one of the data constructors from the instance
22:11:03 <danilo2_> glguy: thanks! Im wondering if it will work, hmm
22:59:26 <dmj`> jle`: o/
23:07:39 <jle`> dmj`: \o
23:40:57 <Forty-Bot> I want to print the value of `a i j = i^j / factorial j` (where factorial is from https://hackage.haskell.org/package/exact-combinatorics-0.2.0.8/docs/Math-Combinatorics-Exact-Factorial.html)
23:41:11 <Forty-Bot> I can't figure out the type annotation
23:43:12 <Forty-Bot> I tried using "Ratio Int"
23:43:20 <Forty-Bot> which seems like it would work
23:43:23 <Forty-Bot> but no such luck
23:47:18 <cocreature> Forty-Bot: if you take a look at the type signature, it states that "a" must be an instance of "Integral" and an instance of "Bits". Ratio is not an instance of Integral
23:47:35 <Forty-Bot> right
23:47:50 <cocreature> Forty-Bot: "Int" would work, "Integer" would work as well
23:48:07 <Forty-Bot> Int and Integer do not work
23:48:30 <Forty-Bot> I get `No instance for (Fractional Int) arising from a use of ‘a’`
23:48:30 <ab9rf> no, it won't
23:48:40 <ab9rf> :t (/)
23:48:41 <cocreature> Int and Integer work for the result of "factorial"
23:48:41 <lambdabot> Fractional a => a -> a -> a
23:48:56 <cocreature> if you want to process it further you can use "fromIntegral" to convert from "Int" to "Ratio Int"
23:49:12 <ab9rf> you can't divide integrals with /
23:49:25 <Forty-Bot> yeah, but I don't want another integral out
23:49:30 <Forty-Bot> I want some sort of ratio
23:49:42 <ab9rf> yes, but the arguments to / must both be Fractionals
23:49:43 <Forty-Bot> otherwise this function will be either 1 or 0
23:49:46 <cocreature> try "a i j = i ^ j / fromIntegral (factorial j)"
23:50:21 <ab9rf> you'll need fromIntegral on (i*j) too, iirc
23:50:32 <ab9rf> er, i^j, i can't type apparently
23:50:34 <cocreature> it’s i ^ j not i * j
23:50:37 <cocreature> :t (^)
23:50:38 <lambdabot> (Num a, Integral b) => a -> b -> a
23:50:48 <cocreature> that should work just fine
23:51:01 <ab9rf> depends on the type of i, but that's free in this equation so ok
23:52:12 <Forty-Bot> ok, thanks that works
23:54:52 <ab9rf> haskell numeric types can be infuriating
23:57:27 <Forty-Bot> ...yeah
23:58:34 <Forty-Bot> https://wiki.haskell.org/Numeric_Prelude makes the most sense to me
23:58:52 <Forty-Bot> because at least it's based on a more coherent heiarchy
