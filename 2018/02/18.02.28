00:00:35 <centril> is Ulf Norell around here? =P
00:09:15 <dminuoso> ski: By the way.. so interesting. While I was sitting in the train I realized that this "Peano" likeness of lists had an interesting transformation: length
00:09:16 <dminuoso> ski: I played with that thought and then opened your pdf. My mind was totally blown when that idea was named in the abstract..
00:09:54 <dminuoso> Cons a1 (Cons a2 (Cons a3 Nil)) -> Succ (Succ (Succ Zero))
00:10:36 <enterprisey> side note
00:10:48 <enterprisey> there's a better way to spell (f .) . (g .) . h, right
00:11:27 <MarcelineVQ> yeah
00:11:33 <MarcelineVQ> @unpl (f .) . (g .) . h
00:11:33 <lambdabot> (\ x x0 -> f (g (h x x0)))
00:12:03 <enterprisey> the pointfree.io version is absolutely terrible
00:12:26 <cocreature> well donâ€™t make it pointfree, problem solved
00:12:37 <centril> cocreature: blasphemy!
00:12:40 <enterprisey> ^
00:12:46 <dminuoso> But.. tacit programming!
00:12:49 <enterprisey> but even I think `(. ((.) . (.))) . (.) . (.) . (.)` is gross
00:12:53 <enterprisey> (which is what I got)
00:13:09 <cocreature> I honestly donâ€™t get the obsession with trying to make things pointfree
00:13:12 <dminuoso> @unpl (. ((.) . (.))) . (.) . (.) . (.)
00:13:12 <lambdabot> (\ x x0 x1 x2 x3 -> x (x2 (x1 x2 x3)))
00:13:20 <bontaq``> good god
00:13:28 <enterprisey> @pl z x x0 = f (g (h x x0))
00:13:28 <lambdabot> z = ((f . g) .) . h
00:13:29 <centril> @unpl (((.) . (.)) .)
00:13:29 <lambdabot> (\ g x g0 x0 x1 -> g x (g0 x0 x1))
00:13:29 <dminuoso> @pl (\ x x0 x1 x2 x3 -> x (x2 (x1 x2 x3)))
00:13:30 <lambdabot> const . (. ap (.)) . (.) . (.)
00:13:36 <enterprisey> lots of botting going on
00:14:02 <dminuoso> enterprisey: (f . g . (h x)) x0
00:14:03 <MarcelineVQ> epanded eta, expanded mind
00:14:05 <enterprisey> I'm not sure why lambdabot's results are so much better than the pointfree.io edition, of course
00:14:15 <centril> cocreature: haskell programmers be lazy, they hates naming shit, ye?
00:14:32 <enterprisey> dminuoso: *memes a bit about how it ain't pointfree* yeah it's more readable
00:14:54 <cocreature> centril: well shitty variable names are still better than what @pl comes up with most of the time
00:15:13 * centril 's nick on reddit is etareduce
00:15:13 <dminuoso> enterprisey: I focus on expressing what my programs mean.
00:15:36 <centril> cocreature: =P
00:16:14 <centril> Personally, I have a rule: `flip`ing is morally wrong.
00:16:29 <enterprisey> centril: you might not want to look at my codebase
00:16:30 <[exa]> unless your program should flip.
00:16:37 <enterprisey> I have like three flips in one line
00:16:47 <enterprisey> and it's combined with Data.Aviary.Birds
00:17:03 <bontaq``> :'D
00:17:12 <MarcelineVQ> centril: how do you feel about operator sections?
00:17:15 <enterprisey> quote, one of the people I'm working with on this, when I brought up that library: "I sure hope you're meming again"
00:17:15 <centril> enterprisey: you could flip flop
00:17:20 <enterprisey> wait, operator sections are A+
00:17:20 <centril> MarcelineVQ: they are magnificent!
00:17:25 <enterprisey> I missed them in OCaml so much
00:17:52 <enterprisey> I also missed a function composition operator, but let's not get into it too much
00:18:21 <centril> enterprisey: wait what... no (.)? /sadface
00:18:34 <enterprisey> centril: at the top of each file you have to roll your own
00:18:41 <enterprisey> and of course you can't use (.) because that's a parse error
00:18:48 <centril> gawd
00:19:00 <enterprisey> you also can't specify precedences
00:19:06 <enterprisey> you encode it through the beginning of the operator
00:19:07 <[exa]> what?
00:19:19 <dminuoso> centril: Sometimes `flip` is the best way though. `store = flip Store` =P
00:19:54 <enterprisey> [exa]: in OCaml, operators beginning with * beat those with @, which beat ^, which beat !
00:20:04 <centril> I'm very fond of  (.:) = (.) . (.)    -- it gives you magical pointfreeing powers
00:20:13 <dminuoso> centril: Do you also have (.::) and (.:::) ?
00:20:56 <centril> dminuoso: those are clearly ill-named... you should have three and four vertical dots
00:21:09 <enterprisey> oh my god, classic Haskell community: on my recent stackoverflow question, someone just recommended profunctors and semigroupoids
00:21:17 <enterprisey> I mean, it wouldn't kill our project that much
00:21:19 <[exa]> enterprisey: ...but why?
00:21:21 <enterprisey> we already use cofree and comonads
00:21:28 <centril> [exa]: why not..?
00:21:56 <enterprisey> [exa]: also half of those are left-associative and the other half are right, but of course I forgot which hal
00:21:58 <enterprisey> *hafl
00:21:59 <enterprisey> *half
00:22:05 <[exa]> we should have a name for terrible nongeneric design decisions
00:22:12 <[exa]> a funny one
00:22:13 <centril> dminuoso: this is gold:  http://hackage.haskell.org/package/pointless-fun-1.1.0.5/docs/Data-Function-Pointless.html
00:22:57 <centril> btw... can you use emojis as operator idents?
00:23:42 <[exa]> centril: iirc they need to be recognized as punctuation by some unicode library
00:23:47 <dminuoso> > let x ðŸ˜‚ y = x + y in 1 ðŸ˜‚ 2
00:23:49 <lambdabot>  3
00:23:59 <[exa]> or maybe "not alphanum" is enough
00:24:06 <centril> =P
00:24:09 <[exa]> wow :]
00:24:52 <enterprisey> I was just reading through the profunctor docs... they mention "costrength" and "coYoneda"... I'm leaving
00:25:34 <dminuoso> enterprisey: The co-Yoneda lemma for a covariant Functor f states that Coyoneda f is naturally isomorphic to f.
00:25:35 <dminuoso> It's so clear.
00:25:48 <enterprisey> they have earned the distinction of being the first Haskell documentation to be saved to my "memes" bookmarks folder instead of the "haskell" one
00:25:52 <enterprisey> oh yeah
00:25:59 <enterprisey> do you need cohaskell and a mputer for that?
00:26:17 <centril> enterprisey: that is clearly wrong - it should say  coYoda
00:26:18 <ertes-w> ello
00:26:37 <quchen> Yoneda and coyoneda are simple, but the docs are, pardon my French, unhelpful wankery.
00:26:51 <enterprisey> sorta reads like it
00:27:26 <enterprisey> nice
00:27:31 <enterprisey> I was also reading the source in the docs
00:27:37 <enterprisey> third line in: unsafeCoerce everywhere
00:27:46 <enterprisey> excellent
00:27:54 <ski> centril : hm, i don't so (typed holes paper)
00:27:59 <enterprisey> writing f :: a -> b has never had more mathematical backing
00:28:01 <ski> cocreature,sdrodge : hm, i think Cayenne may have had typed holes ? i know Agda1 / Alfa had for sure
00:28:03 <centril> ski: :(
00:28:05 <ski> dminuoso : yea :)
00:28:06 <ski> centril : one can use right sections instead of `flip', like :  (`runState` initialState) $ do ...
00:28:19 <centril> ski: yea I know
00:28:38 <ski> @quote yoneda.lemma
00:28:38 <lambdabot> saml says: explain yoneda lemma in terms of corn flakes
00:28:38 <centril> very neat
00:28:59 <ski> @quote enterprise.industry
00:28:59 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
00:28:59 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
00:29:40 <quchen> The idea is very simple: fmap is not fused, so Â»fmap f . fmap gÂ« means fmapping twice, possibly traversing the structure twice. Yonedaâ€™s fmap is just a dummy operation that does not actually fmap over the structure, but simply aggregates the mapping functions, so that you recover the Â»fmap f . fmap g ---> fmap (f.g)Â« behavior.
00:29:47 <ertes-w> enterprisey: try not to be bothered by the *names* so muchâ€¦  look at the definitions, and most of them are really not that crazy
00:30:02 <enterprisey> ertes-w: the ones that don't unsafeCoerce, of course :
00:30:04 <ertes-w> enterprisey: for example Coyoneda is a lovely little tool to add a Functor interface to stuff like IORef =)
00:30:05 <enterprisey> * :)
00:30:15 * ski . o O ( let's make an internal language for the category whose morphisms are (right) Kan extensions )
00:30:39 <ertes-w> enterprisey: and Codensity is one of my favourite tools for resource managementâ€¦  i literally use it everywhere =)
00:30:53 <enterprisey> well, time to learn some more haskell
00:31:04 <enterprisey> but another day, of course, because it's 3:30 am and I still have other subjects
00:31:09 <ertes-w> enterprisey: it may not jump at you how Codensity helps, but compare the type of the Codensity constructor to the type of 'withFile' =)
00:31:30 * centril needs to learn more  intellectual terrorism / abstract nonsense
00:31:58 <enterprisey> lol
00:32:29 <enterprisey> wait
00:32:32 <enterprisey> there's an error somewhere
00:32:32 <ski> @quote abstract.nonsense
00:32:32 <lambdabot> sorear says: I find it very amusing how Church's abstract nonsense turned out to make for better programming than Turing's real-world metaphors.
00:32:37 <enterprisey> you need a nstructor for those
00:32:41 <enterprisey> not a constructor
00:32:50 * enterprisey declares the joke tired and stops making it
00:33:10 <centril> enterprisey: coconut
00:33:24 <ertes-w> import Ntrol.Ncurrent
00:33:57 * ski . o O ( `confib 12' )
00:34:03 <ertes-w> :t confusing
00:34:04 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
00:35:09 <centril> > let ðŸ§  = "blown" in ðŸ§ 
00:35:12 <lambdabot>  <hint>:1:5: error: lexical error at character '\129504'
00:35:15 <centril> :(
00:35:52 <dminuoso> quchen: fmap is generally not fused? why is that?
00:36:09 <dminuoso> quchen: Or do you mean that it's up to the implementation to hopefully fuse?
00:36:18 <ertes-w> dminuoso: it's up to the implementation
00:36:26 <ski> @quote getting.a.stab
00:36:26 <lambdabot> byorgey says: <edwardk> @type (^.) <lambdabot> s -> Getting a s t a b -> a <byorgey> I would not like to be getting a stab, thank you
00:36:30 <dminuoso> Ah alright. So Yoneda's fmap guarantees a fuse?
00:36:54 <ski> yes
00:36:58 <ertes-w> dminuoso: one could write a general fusion rule for fmap, but that might interfere with more specialised fusion rules of specific functors
00:37:28 <ski> and both `Yoneda f' and `Coyoneda f' are functors, regardless of whether `f' is or not
00:38:03 <centril> This could be solved by specialization?
00:40:27 <nshepperd> it could be solved by adding rewrite rules but co/yoneda is more reliable
00:42:03 <centril> nshepperd: well, not GHC rewrite rules... specialization as done in Rust
00:47:41 <ertes-w> Yoneda und Coyoneda basically implement fusionâ€¦  in fact most wrappers from kan-extensions do
00:48:22 <ertes-w> Codensity also implements a form of fusion: (Codensity IO) only ever relies on IO's (>>=) when you lift
00:48:28 <nshepperd> centril: i don't know rust specialization. isn't that just type class inlining? how would it turn fmap f . fmap g into fmap (f.g)?
00:48:46 <ertes-w> Codensity's own (>>=) does not rely on the underlying monad's (>>=), which is why the instance doesn't even depend on it being a monad
00:49:11 <ertes-w> similar to how (Coyoneda f) doesn't require f to be a functor
00:49:59 <ertes-w> so Codensity literally makes composition "denser" =)
00:50:44 <centril> nshepperd: it wouldn't work in Haskell... In Rust, Iterator returns  Map<I, F>,  and:  Map<Map<I, F>, G>  can be specialized by giving a more specific instance
00:51:17 <centril> but LLVM would probably always fuse this in any case
00:52:49 <nshepperd> ah, so that relies on statically knowing that the result is mapped immediately and not passing it through a function parameter or something first
00:53:38 <centril> nshepperd: yes
00:54:02 <ertes-w> what's Map?
00:54:26 <centril> ertes-w: fmap for lazy sequences in Rust,  https://doc.rust-lang.org/nightly/std/iter/struct.Map.html
00:54:37 <centril> possibly-lazy*
00:54:54 <ertes-w> thatâ€¦  didn't really help
00:54:58 <ertes-w> but nevermind
00:55:09 <centril> ertes-w: ok =)
00:56:09 <nshepperd> the type of that 'confusing' function actually makes a lot of sense to me these days
00:56:32 <nshepperd> basically Applicative f => LensLike (Curried' (Yoneda f)) s t a b -> LensLike f s t a b
00:56:54 <ertes-w> to me too, but i still love the irony =)
00:57:25 <nshepperd> not really familiar with Curried but it looks like it's a sort of free applicative in this usage
00:58:06 <ertes-w> the haskell community has a healthy sense of self-deprecation
00:58:40 <centril> bit more readable when instantiated at:  Applicative f => LensLike' (Curried' (Yoneda f)) s a -> LensLike' f s a
00:58:44 <nshepperd> so, stuff everything into yoneda to make fmapping fast, stuff that into Curried to make <*> fast, do all that internally to make a lens fuse
01:00:02 <quchen> ertes-w: fmap is not fused because it would be wrong to do it, since law obedience is merely a suggestion
01:00:26 <centril> quchen: is it?
01:00:34 <ertes-w> quchen: not sure i agree about that
01:00:49 <ertes-w> quchen: i understand your point though
01:01:04 <quchen> It is. The report is fairly careful not to require any laws.
01:01:34 <quchen> Â»Instances of Functor should satisfy the following laws: [â€¦] All instances of Functor defined in the Prelude satisfy these laws.Â«
01:01:59 <quchen> Many laws donâ€™t hold in the presence of âŠ¥ anyway, so it would be very bad if the compiler applied them
01:02:05 <quchen> âŠ¥ >>= return  =  \r -> return (âŠ¥ r) r  =  \r -> const (âŠ¥ r) r  =  \r -> âŠ¥ r  =  \_ -> âŠ¥  â‰   âŠ¥
01:02:07 <ertes-w> i'd not write that rule for a more practical reason: i'd consider it an anti-pattern
01:02:26 <ertes-w> and in the specific case of Functor also for the existence of Coyoneda
01:02:40 <dminuoso> Shouldn't we use the word "copattern" instead of antipattern?
01:02:51 <quchen> No, copatterns exist and are something different.
01:02:58 <ski> `seq :: forall a b. a -> b -> b' is a party killer
01:03:05 <guest_> \quit
01:03:10 <dminuoso> quchen: Oh wow. I did not know that. :o
01:03:11 <ertes-w> dminuoso: co- doesn't turn something good into something bad, just into something different, related
01:03:39 <ski> @google Andreas Abel Copatterns
01:03:39 <lambdabot> http://www.cse.chalmers.se/~abela/
01:03:40 <lambdabot> Title: Andreas Abel
01:04:17 <quchen> Speaking of Co things, I still donâ€™t get Codensity vs. Cont. ertes-w?
01:04:38 <ski> (aka "message-dispatching" .. according to me, at least :)
01:05:15 <ertes-w> quchen: ContT insists that you encode the final result type and gives you more effects in returnâ€¦  Codensity is more conservative and therefore easier to reason about
01:05:31 <MacSlow> Greetings folks!
01:05:46 <ertes-w> in particular with Codensity you can only encode "real" CPS functions
01:05:49 <ski>   CoDensity Identity a = forall o. Cont o a
01:06:00 <nshepperd> I certainly wouldn't like haskell to go down the road of certain C compilers where you are worried that the compiler is going to jump out from behind a bush and say "aha! you didn't obey the laws! i'm going to break your program"
01:06:02 <ski>   CoDensity m a = forall o. Cont (m o) a
01:06:38 <mrm> I personally have never seen gcc hiding behind a bush for any reason.
01:06:45 <ertes-w> quchen: example: you can implement stuff like 'goto' with ContT, but not with Codensity
01:07:22 <ski> `Cont' and `ContT' allows you to do naughty stuff with the final answer type. `Codensity' only allows that for the "monad" portion of it, keeping the monadic result polymorphic
01:07:31 <ski> (also `forall o. Cont o a = a')
01:08:16 <ski> (yea, `Cont' and `ContT' allows nqCPS)
01:08:24 <quchen> Naughty stuff?
01:08:29 <ertes-w> anything that "goes back" is impossible with Codensity, because the type effectively prevents you from keeping old continuations around
01:08:47 <ertes-w> however, anything that does something to "the future" is allowed, including running it twice
01:08:49 <quchen> I mean I get the forall and everyhing, I just donâ€™t understand that the effect of having an existential return value
01:08:53 <ertes-w> @let import Control.Monad.Codensity
01:08:55 <lambdabot>  Defined.
01:08:58 <ski> not actually using CPS, because you're not abstract in the final result type
01:09:15 <ertes-w> @let twice = Codensity (\k -> k () *> k ())
01:09:18 <lambdabot>  Defined.
01:09:20 <ertes-w> :t twice
01:09:22 <lambdabot> Applicative m => Codensity m ()
01:09:40 <ertes-w> from 'twice' forward everything will be run twice (non-interleaved)
01:10:24 <ertes-w> quchen: anything that is possible with callCC is "naughty stuff"
01:10:47 <ertes-w> going back in time, returning continuations from the overall ContT, etc.
01:10:53 <quchen> Why canâ€™t we create callCC with codensity?
01:11:02 <ertes-w> because you can't make it type-check
01:11:34 <quchen> Why not? Does callCC craft a specialized instantiation of that result type variable?
01:14:05 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
01:14:07 <tabaqui> How does Arrow-rec syntax work exactly? I found how mdo translates using 'mfix', but don't see formal definition for Arrow-rec.
01:14:07 <lambdabot>  Defined.
01:14:13 <ski> @let forAll,forAny :: [a] -> Cont Bool a; forAll = cont . flip all; forAny = cont . flip any
01:14:15 <lambdabot>  Defined.
01:14:19 <ski> > evalCont $ do m <- forAll [2,3,5,7]; n <- forAny [3,5,7]; return (m <= n && n <= 2*m)
01:14:21 <ertes-w> quchen: there is no way to return the continuationâ€¦  the type of Codensity makes sure that you can't use a continuation that you got from somewhere else
01:14:21 <lambdabot>  error:
01:14:22 <lambdabot>      Ambiguous occurrence â€˜forAllâ€™
01:14:22 <lambdabot>      It could refer to either â€˜Lambdabot.Plugin.Haskell.Eval.Trusted.forAllâ€™,
01:14:30 <ertes-w> quchen: you have to use the continuation you're given
01:14:36 <ski> > evalCont $ do m <- L.forAll [2,3,5,7]; n <- forAny [3,5,7]; return (m <= n && n <= 2*m)
01:14:39 <lambdabot>  True
01:14:50 <tabaqui> :i Lambdabot.Plugin.Haskell.Eval.Trusted
01:14:52 <ski> > evalCont $ do n <- forAny [3,5,7]; m <- L.forAll [2,3,5,7]; return (m <= n && n <= 2*m)
01:14:55 <lambdabot>  False
01:14:56 <ertes-w> quchen: using existentials you could return the continuation from a Codensity action, but you couldn't do anything with it
01:15:08 <ski> ^ that's doing "naught" stuff
01:15:23 <ertes-w> quchen: therefore you couldn't make the function that you need to pass to the argument of callCC type-check
01:15:31 <ertes-w> because that has to be a function that ignores its own continuation
01:16:35 <quchen> Ah right, you canâ€™t have a Â»Codensity (Codensity â€¦) m aÂ« because that parameter is hidden
01:16:50 <quchen> And goto :: Cont (Cont r m a) m a or something like that
01:16:53 <ertes-w> Codensity m (Codensity m ())
01:16:55 <ski> quchen : "Why canâ€™t we create callCC with codensity?", because `Codensity f a' contains a polymorphic thing, that has to work for all answer types
01:16:57 <ertes-w> you can't have that
01:17:29 <ertes-w> (well, you can, but it wouldn't be the current continuation)
01:17:46 <ski> this is not that different from not being able to leak references to mutable state out of `runST'
01:18:27 <ertes-w> yeah, you can't unify the answer type with anything else, including an answer type you've received from another action
01:19:37 <ertes-w> @let data K m a = forall r. K (a -> m r)
01:19:40 <lambdabot>  Defined.
01:19:53 <ertes-w> @let label = Codensity (\k -> k (K k))
01:19:55 <lambdabot>  .L.hs:196:30: error:
01:19:55 <lambdabot>      â€¢ Occurs check: cannot construct the infinite type: a ~ K m a
01:19:55 <lambdabot>      â€¢ In the first argument of â€˜kâ€™, namely â€˜(K k)â€™
01:20:01 <ski> also "the effect of having an existential return value" is wrong, it's not an existential
01:21:46 <nshepperd> the actual type error you get when you try to write callCC in Codensity is "Couldn't match type â€˜b1â€™ with â€˜b2â€™"
01:22:50 <quchen> ski: Right, itâ€™s in positive position, nevermind
01:23:00 <quchen> The âˆ€, that is
01:23:18 <nshepperd> where b1 and b2 are rigid type variables bound by trying to create a value of type forall b1. (a -> m b1) -> m b1 and within that a value of type forall b2. (b -> m b2) -> m b2
01:24:32 <ski> @quote mount.massive
01:24:32 <lambdabot> byorgey says: Escaped skolem!  Authorities mount massive search.  News at 11.
01:25:10 <ertes-w> @let data Label m a = forall r. Label ((a, Label m a) -> m r)
01:25:12 <lambdabot>  Defined.
01:25:19 <ertes-w> @let label x0 = Codensity (\k -> k (x0, Label k))
01:25:21 <lambdabot>  Defined.
01:25:31 <ski> @type label
01:25:33 <lambdabot> error:
01:25:33 <lambdabot>     Ambiguous occurrence â€˜labelâ€™
01:25:33 <lambdabot>     It could refer to either â€˜Lambdabot.Plugin.Haskell.Eval.Trusted.labelâ€™,
01:25:35 <ertes-w> quchen: ^ you can get this far, but not furtherâ€¦  you can't implement 'goto'
01:25:36 <ski> @type L.label
01:25:37 <lambdabot> p -> Codensity m (p, Label m p)
01:26:14 <ertes-w> and this is basically callCC
01:26:31 <ertes-w> (or it would be, if you could write 'goto')
01:27:34 <quchen> Iâ€™m having trouble reading those type definitions. The Cont knotâ„¢ strikes again
01:27:49 <reactormonk> I'll need a connection pool for my postgreSQL connections. Any recommendations?
01:28:10 <quchen> I think Iâ€™ll just accept it before my head hurts
01:28:32 <ski> `Label m a' is negatively recursive
01:28:58 <quchen> â€¦okay, so what?
01:29:08 <ski> Agda wouldn't accept it
01:29:25 <ski> can lead to impredicativity, iirc
01:29:35 <quchen> Ah, I remember reading about this umm somewhere.
01:29:42 <quchen> HoTT? Norellâ€™s book?
01:30:22 <centril> lower :: Comonad w => Cofree w a -> w a    hihihi
01:30:46 <quchen> :t confusing
01:30:47 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
01:44:29 <marmistrz> Hi! Any leksah users here?
01:46:01 <reactormonk> I have ((a -> IO a) -> IO b) - how do I conver that to ((m a -> IO a) -> IO b)?
01:46:54 <sdrodge> Out of curiosity, why does Djinn know about Monad but not Functor or Applicative?
01:47:40 <sdrodge> (in lambdabot in this channel, that is)
01:48:55 <ski> @type let foo :: Monad m => ((a -> IO a) -> IO b) -> ((m a -> IO a) -> IO b); foo f = f . (. return) in foo
01:48:56 <lambdabot> Monad m => ((a -> IO a) -> IO b) -> (m a -> IO a) -> IO b
01:49:24 <ski> @djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
01:49:26 <reactormonk> ski, thanks!
01:51:23 <sdrodge> @djinn (Functor f, Functor g) => (a -> b) -> g (f a) -> g (f b)
01:51:23 <lambdabot> -- f cannot be realized.
01:51:39 <sdrodge> Is this beyond djinn's capabilities?
01:51:45 <sdrodge> Or is the configuration wrong?
01:51:51 <ertes-w> reactormonk: https://hackage.haskell.org/package/resource-pool
01:52:05 <reactormonk> ertes-w, yeah, picked that one. Zero competition around.
01:52:29 <ertes-w> reactormonk: this is not a particularly competetive area anyway =)
01:53:50 <ski> @djinn Functor m => m a -> (a -> b) -> m b
01:53:50 <lambdabot> f a b = fmap b a
01:53:50 <puregreen> I have a big project and GHC is keeping two versions of each module (static and dynamic) â€“ e.g. for each .hi file I have a corresponding .dyn_hi file. Can I somehow tell GHC not to create the static versions at all? They don't take that much space (like 10% of my .stack-work folder) but there's a lot of them and that slows down caching on CI
01:54:22 <puregreen> I tried passing -dynamic to GHC but it kept creating the static ones anyway
01:54:37 <ski> sdrodge : djinn doesn't understand higher-rank, and so doesn't understand polymorphic methods, like `fmap',`(>>=)',`return'. stuff like `(==)' is fine, though
01:54:53 <sdrodge> ski: gotcha
02:11:13 <reactormonk> Is there a way to use inline type signatures with type variables which refer to the outer type variables?
02:11:58 <sagax> hi all!
02:12:22 <Taneb> reactormonk: you'll need to use the ScopedTypeVariables extension
02:12:31 <Taneb> BUt with that turned on it should Just Work
02:12:33 <sagax> what actually haskell relise?
02:12:38 <sagax> i have 8.0.2
02:13:01 <Taneb> sagax: I don't understand what you are asking, I'm afraid
02:13:55 <cordawyn> sagax: do you mean what is the current Haskell version?
02:14:00 <sagax> yes
02:14:07 <sagax> cordawyn: yes
02:14:24 <sagax> Taneb: sorry, english not native language for me
02:14:32 <cordawyn> 8.2.2, I think
02:14:44 <cordawyn> https://www.haskell.org/ghc/
02:15:13 <sagax> thanks
02:16:29 <reactormonk> Trying to get this to compile: https://gist.github.com/reactormonk/9a4001ff53ccda466bd37742d7ad536b
02:16:53 <ertes-w> reactormonk: turn on ScopedTypeVariables and use explicit quantification:  f :: forall a. â€¦; f x = â€¦ (â€¦ :: a) â€¦
02:17:11 <reactormonk> I don't know why the signature for applied is (a -> IO a) -> IO a instead of (a -> IO b) -> IO b
02:18:55 <reactormonk> ertes-w, where does it go with constraints?
02:19:28 <ski> reactormonk : np
02:19:57 <ertes-w> reactormonk: f :: forall a. (Ctx a) => â€¦;  f â€¦ = â€¦ (â€¦ :: a) â€¦
02:22:56 <merijn> cordawyn: Well, 8.4 release candidate was just released, but I'm a big advocate of lagging GHC releases by like a year :p
02:24:23 <cordawyn> merijn: I'm slowly moving towards Idris, so I'm already lagging by a year or two :)
02:24:35 <reactormonk> Oh, I mistread the type signature. I'd actually need ((a -> IO b) -> IO b) -> (m a -> IO a) -> IO b - not sure if that makes sense at all.
02:26:08 <ski> reactormonk : hm, not without `mfix', i think
02:26:35 <reactormonk> ski, I'm trying to stuff (a -> IO b) -> IO b into MonadUnliftIO
02:26:39 <ski> (you don't mean `((a -> IO b) -> IO b) -> ((m a -> IO b) -> IO b)', then ?)
02:27:04 * ski can't recall whether they've looked at `MonadUnliftIO'
02:27:08 <reactormonk> somehow the type signature of that is ((forall a. m a -> IO a) -> IO b) -> m b
02:27:46 <ski> looks fun, rank-3
02:28:31 <reactormonk> Dunno what happens to the a though
02:29:16 <John882> hello guys I am trying to understand yesod, but I can not make this https://github.com/yogsototh/yosog/blob/master/Handler/Blog.hs code work
02:29:45 <John882> The code is not mine, but I am actually testing (http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/) <- these examples
02:30:48 <John882> I have tried using overloadedstrings and template haskell but it is not working
02:31:12 <ski> reactormonk> :t liftContra
02:31:58 <reactormonk> ski, ehh, RTFM. copypastaing the example in the readme works.
02:32:35 <sepakorayl> hello everyone
02:33:42 <sepakorayl> does anyone know how to derive Decidable Equality instances for datatypes using the parameterization trick in order to use Nats with singletons? (see here https://stackoverflow.com/a/36562893)
02:37:02 <reactormonk> ertes-w, do you happen to have some good numbers as defaults for said resource pool?
02:37:21 <ertes-w> reactormonk: no, sorry
02:38:31 <ertes-w> reactormonk: in general just choose a largish number smaller than the maximum number of allowed connectionsâ€¦  resource-pool only opens on demand
02:38:44 <ertes-w> reactormonk: like if PG allows 512, perhaps choose 32
02:39:00 <ertes-w> and the stripe thingâ€¦  honestly i don't even understand what that is
02:40:24 <ertes-w> reactormonk: if you want to fine-tune, watch the number of concurrent transactions you make and tune to that value
02:42:38 <w1n5t0n> hi all, I have a function defined as "s :: String -> (a -> b) -> IO Int" which seems to be fine, but when I do (s "test" $ \t -> sin t) later in the same file I get the error "Parse error: module header, import declaration or top-level declaration expected". Am I missing something obvious?"
02:43:07 <merijn> w1n5t0n: You can write random expressions at the top level
02:43:17 <merijn> w1n5t0n: Files can only have module headers, imports or declarations
02:44:17 <reactormonk> How do I make a second of NominalDiffTime?
02:44:36 <w1n5t0n> merijn: and what exactly is the top level? is ghci top level for example?
02:44:46 <merijn> reactormonk: nominalDiffTimeToSeconds ? ;)
02:45:00 <merijn> w1n5t0n: GHCI is weird and fundamentally different from files
02:45:04 <ertes-w> reactormonk: (1 :: NominalDiffTime)
02:45:18 <merijn> ertes-w: No, he wanted to go the opposite way, I'm pretty sure
02:45:29 <reactormonk> merijn, where did you find that one?
02:45:48 <merijn> reactormonk: Went to the time package on hackage, clicked index for letter N and saw it in the list ;)
02:45:51 <ertes-w> making "a second of NominalDiffTime" really sounds like (1 :: NominalDiffTime) =)
02:45:58 <merijn> reactormonk: Data.Time.Clock apparently
02:46:01 <reactormonk> ertes-w, yeah, you're right
02:46:29 <reactormonk> merijn, didn't see in there...
02:46:45 <reactormonk> ertes-w, gotta try the obvious before asking. Sorry.
02:46:59 <merijn> reactormonk: The index link on hackage is your friend, shows you alphabetical index of a package, ignoring modules
02:47:19 <kuribas> w1n5t0n: btw, that's (s "test" sin)
02:48:02 <reactormonk> merijn, beautiful, never used it. Thanks!
02:48:27 <ertes-w> reactormonk: fromInteger and fromRational for NominalDiffTime are in seconds
02:48:39 <ertes-w> reactormonk: so 1.5 is 1.5 seconds
02:49:08 <ertes-w> toRational is in seconds, too
02:49:26 <ertes-w> so you can use rounding or realToFrac to go from NominalDiffTime to a Double value in seconds
02:49:36 <ertes-w> *Integer or Double
02:49:50 <ertes-w> reactormonk: so for the most part you don't need any special conversion functions
03:05:22 <nee`> Is there any way I can use `useAsCString` with multiple ByteStrings in one computation without manually copying the CString? Ref: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#g:25
03:08:16 <merijn> nee`: You can just nested multipe useAsCString calls? :)
03:09:22 <merijn> nee`: http://lpaste.net/4040213076069318656
03:11:47 <nee`> merijn: Ah right thanks, I was for some reason trying to do it with currying and missed the obvious once again.
03:23:42 <chisui> Is there a way of expressing a Constraint simillar to this "forall a. Monad (m a)"?
03:24:22 <phadej> chisui: today only hacky ones
03:24:32 <phadej> http://hackage.haskell.org/package/constraints-0.10/docs/Data-Constraint-Forall.html
03:25:05 <phadej> you have explicitly open up `Dict`s
03:25:26 <chisui> phadej: urgh, Ok. I think I will rethink my architecture then. Thanks
03:27:47 <thedotre> would you be interested on the srcy programming language? https://drive.google.com/drive/folders/1ROir4bfmSOdV0vQrSMHKcyjnenYGjfnX
03:31:35 <phadej> chisui: http://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf might be interesting for you
03:33:57 <phadej> there is related work which has some examples how you can work with that
03:34:08 <phadej> ... limitation, i.e work around it
03:35:17 <phadej> I have some classes with Dict (something) explicit type-class dictionaries. I guess you need them in some plumbing, so you can hide them quite well
03:35:30 <chisui> phadej: I simply moved the Constraint to the function level for now. I just wanted to get rid of some redundancies. The paper looks interesting but seems to be overkill in my case.
04:01:00 <michalrus> Is it safe to assume that a ThreadId wonâ€™t be reusedâ€¦ for a reasonable time?
04:02:49 <opqdonut> michalrus: I guess you have to assume that .... otherwise you can't do anything with ThreadIds
04:03:30 <michalrus> Mhmmmm.
04:03:59 <opqdonut> but the docs don't directly say it
04:04:13 <opqdonut> they say that in ghc it's a pointer to a thread, which surely can get reused
04:15:37 <Putonlalla> As long as you have a reference to a thread, it cannot be garbage collected and reused, opqdonut.
04:16:24 <w1n5t0n> is there a function to return only the fractional part of a number? something like "fract 3.14 = 0.14"
04:16:59 <Putonlalla> > properFraction 42.13
04:17:01 <lambdabot>  (42,0.13000000000000256)
04:17:17 <Axman6> so, not really
04:17:39 <opqdonut> Putonlalla: riiight, yeah, that protects ThreadIds
04:17:45 <opqdonut> michalrus: did you get that?
04:18:09 <michalrus> Yes! Cool. :) Thank you, both. Clear now!
04:25:14 <mowbraysrevenge> hi
04:25:28 <mowbraysrevenge> anyone here bychance knows java
04:26:12 <cppxor2arr> why didn't you join #java or ##java?
04:27:46 <statusfa1led> mowbraysrevenge: do you have something you can do in Java, but aren't sure how to do in Haskell?
04:29:12 <mowbraysrevenge> i'm stuck with an app which won't compile https://github.com/radamar/AdAway/blob/master/AdAway/src/main/java/org/adaway/provider/AdAwayDatabase.java
04:29:25 <opqdonut> yeah you're in the wrong channel for that
04:29:31 <cocreature> mowbraysrevenge: this channel is about the Haskell programming language
04:29:49 <mowbraysrevenge> sorry
04:35:34 <w1n5t0n> is there a way to overload "floor" for a type so that it has a type signature of "floor :: RealFrac a => a -> a"?
04:36:16 <cocreature> :t fromInteger . floor :: RealFrac a => a -> a -- w1n5t0n
04:36:18 <lambdabot> RealFrac a => a -> a
04:40:25 <w1n5t0n> cocreature: thanks, can this be a valid instance of RealFrac though?
04:41:49 <cocreature> w1n5t0n: are you asking if you can provide a function of type "a -> a" rather than "Integral b => a -> b" when implementing "floor" in the RealFrac instance of "a"?
04:45:30 <w1n5t0n> cocreature: yes, exactly. I have a fractional type on which I want to be able to use floor but get back a RealFrac instead of an Integer
04:45:45 <cocreature> w1n5t0n: thatâ€™s not possible
04:46:22 <reactormonk> I've got a -> IO a, I would like MonadUnliftIO m => a -> m a, I've tried fun a = withRunInIO $ \run -> run $ aToAFun a, doesn't compile
04:46:29 <cocreature> w1n5t0n: just define a function with a different name that has the type you want
04:47:01 <cocreature> reactormonk: itâ€™s way simpler, just compose the function with "liftIO"
04:47:27 <cocreature> reactormonk: MonadUnliftIO becomes useful when you have things that take IO as an argument not when that is the return type
04:48:01 <cocreature> reactormonk: and MonadIO is a superclass of MonadUnliftIO, so the type signature you get is just more general
04:48:41 <reactormonk> cocreature, well, I'll have to pass (a -> m a) to another function
04:48:58 <reactormonk> ... bracket, in this case
04:49:30 <reactormonk> ... ah yeah, works. being fancy
04:49:49 <w1n5t0n> cocreature: can I use the name floor again if I give it an explicit type signature for my type, or will this break stuff? for example "floor :: (RealFrac a) => MyType a -> MyType a"
04:50:32 <cocreature> w1n5t0n: youâ€™ll have to explicitely import prelude and hide "floor" which is a bit annoying and confusing since everyone expects floor to be the function exported from the Prelude
04:50:59 <cocreature> w1n5t0n: so I would probably choose a different name
04:51:12 <cocreature> w1n5t0n: alternatively tell your users to import the module that you define your floor function in qualified
04:54:33 <kuribas> is it safe to raise again inside a catch?
04:54:50 <lyxia> yes
04:55:10 <kuribas> is there a version of bracket without resource acquisition?
04:55:38 <cocreature> kuribas: bracket_?
04:56:22 <kuribas> hm, bracket pure () might work...
04:56:28 <kuribas> :t bracket $ pure ()
04:56:30 <lambdabot> (() -> IO b) -> (() -> IO c) -> IO c
04:56:38 <kuribas> :t bracket_ $ pure ()
04:56:40 <lambdabot> IO b -> IO c -> IO c
04:56:41 <cocreature> are you looking for "finally"?
04:56:58 <kuribas> ah, yes ...
04:57:21 <aaronstone> how to convert type PublicKey to String https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html#t:PublicKey
04:57:22 * kuribas should read the docs better...
04:57:27 <cocreature> yep you should :)
04:57:32 <cocreature> they are listed directly below bracket ;)
04:58:34 <cocreature> aaronstone: PublicKey is a sequence of bytes, String is a sequence of unicode characters. how do you want to represent arbitrary bytes as unicode characters?
04:58:39 <cocreature> â€¦
05:05:36 <kuribas> hm open-haddock doesn't work on the latest ghc...
05:06:42 <kuribas> looks pretty useful
05:22:31 <tabaqui> I'm not sure, but I've seen somewhere extension for Arrow syntax that allows to use variables in arrow instances like so:
05:22:37 <tabaqui> proc _ ->
05:22:46 <tabaqui>   x <- func -< ()
05:22:53 <tabaqui>   y <- func2 x -< ()
05:23:05 <tabaqui> normal Arrow syntax doesn't allow "func2 x" here
05:23:59 <tabaqui> it looks like ArrowApply is needed here
05:27:26 <dminuoso> What's the exact point of arrows? Is it to generalize compositionality of things like (.) as well as (>=>)?
05:28:04 <manek> Hi guys! Is there any Either-like structure, which would allow me to capture multiple errors encoded in left-monoid? I want in particular something like  (<*>) :: (Either [e] (a -> b)) -> Either [e] a -> Either [e] b  which would mappend lefts if both are left
05:28:12 <tabaqui> AFRP is much simplier than classic FRP
05:28:26 <cocreature> manek: yep itâ€™s usually called Validation
05:28:41 <cocreature> manek: e.g. https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html#t:Validation
05:31:43 <manek> cocreature: hmm, is there any reason why Validation monoid drops one of the right values ?
05:31:54 <manek> `Success a1 `mappend` Success _  = Success a1`
05:32:34 <tabaqui> beacuse it is monoid over left values
05:32:42 <tabaqui> *because
05:33:08 <cocreature> tabaqui: it could still have Success a <> Success b = Success (a <> b)
05:33:24 <cocreature> manek: I donâ€™t know of a good reason
05:33:42 <manek> cocreature: hmm, thanks. For me its a little contr-intuitive to behave this way
05:33:49 <manek> even very contr intuitive :(
05:34:50 <cocreature> manek: I suppose it might be to stay somewhat close to Either
05:35:15 <tabaqui> cocreature: indeed, it looks like "Validation a b" isomorpic with "(b, a)"
05:35:42 <tabaqui> is isomorphic to
05:35:52 <cocreature> tabaqui: huh? how is a sum of a and b isomorphic to a product of a and b?
05:36:19 <tabaqui> isn't 2-tuple a monoid over it's second element?
05:36:37 <manek> cocreature: actually monoid instance of either mappends rightvlaues
05:36:45 <cocreature> > Right 1 <> Right 2
05:36:48 <lambdabot>  error:
05:36:48 <lambdabot>      â€¢ No instance for (Monoid (Either () Integer))
05:36:48 <lambdabot>          arising from a use of â€˜e_112â€™
05:37:01 <cocreature> huh didnâ€™t remember that
05:37:36 <tabaqui> okay, it didn't
05:37:43 <reactormonk> Is it possible to write a MonadUnliftIO instance for PropertyT?
05:37:52 <tabaqui> > ([1],[2]) <> ([3],[4])
05:37:55 <lambdabot>  ([1,3],[2,4])
05:38:08 <cocreature> tabaqui: if type A is isomorphic to type B, you need to be able to define a function A -> B and a function B -> A that are inverses of each other and you definitely canâ€™t do that for Validation a b and (b, a)
05:38:47 <tabaqui> cocreature: with respect of morphisms, I know :)
05:38:55 <reactormonk> ... there isn't even a MonadBaseControl for PropertyT, so things might get interesting.
05:40:07 <dminuoso> tabaqui: a tuple just a product of two types. if what yous said was true, the type of (,) would be (,) :: (Monoid b) => a -> b -> (a, b)
05:40:25 <tabaqui> I thought that 2-tuple has some major instance like Monad over second element
05:40:39 <dminuoso> tabaqui: The tuple you are talking about is Writer
05:41:17 <tabaqui> Functor, right
05:41:24 <tabaqui> > fmap succ (1,2)
05:41:26 <lambdabot>  (1,3)
05:41:31 <cocreature> tabaqui: the Functor instance (and thereby also Applicative/Monad) only target the second element but that doesnâ€™t mean itâ€™s isomorphic
05:42:55 <dminuoso> tabaqui: e.g. Monoid w => MonadWriter w ((,) w)
05:43:14 <tabaqui> we need to specify morphisms that will be saved after (a, b) -> Validation b a, yes
05:43:40 <tabaqui> no
05:43:44 <tabaqui> okay, I see :)
05:44:01 <tabaqui> (,) is bigger than Validation
05:44:14 <cocreature> not really, itâ€™s just different
05:44:48 <cocreature> (Void, ()) is uninhabited (ignoring bottom) Validation Void () has one (non-bottom) value
05:44:50 <dminuoso> tabaqui: (,) is a product type, either is a sum type
05:45:31 <dminuoso> tabaqui: try make a (Int, Bool) out of a `Left 1` without using bottom.
05:46:38 <cocreature> dminuoso: easy, (1, True) :)
05:46:41 <dminuoso> Heh.
05:47:16 <tabaqui> at least Validation can be mapped into (,)
05:47:24 <dminuoso> tabaqui: That's the point - it cant!
05:47:32 <dminuoso> tabaqui: You cant make up values out of nothing.
05:48:02 <chisui> Is there a way of defining Constraints via typefamilies? I know that you can create a class with a single instance that has the typefamily as a constraint with a `~` but is there a more concise way?
05:48:04 <dminuoso> tabaqui: You could if the Validation was in the Right case, because then you have mempty to pick for the left side.
05:48:26 <tabaqui> Failure a -> (_|_, a); Success b -> (b; _|_)
05:49:01 <dminuoso> tabaqui: With that argument you can implement any function.
05:49:03 <dminuoso> Just use bottom.
05:49:05 <chisui> Ideally I would like to write something like "type family F a :: Constraint where ..."
05:49:17 <tabaqui> dminuoso: why not?
05:50:08 <tabaqui> btw, can we test a datum for a bottom value?
05:50:25 <tabaqui> in Haskell, I mean, not in Math
05:50:40 <dminuoso> tabaqui: Force evaluation. You just have the problem that you dont know if it ever returns.
05:51:16 <tabaqui> the halting problem?
05:54:12 <dminuoso> tabaqui: Yes
05:54:38 <dminuoso> tabaqui: Basically if you want to reason about things, you have to forget about bottom.
05:55:03 <dminuoso> Otherwise you admit being able to use this
05:55:05 <dminuoso> :t absurd
05:55:06 <lambdabot> Void -> a
05:55:13 <quchen> Itâ€™s simple, really: every value in Haskell can be bottom.
05:55:31 <quchen> GHC has some values that canâ€™t be bottom, namely values of kind # (unboxed stuff).
05:55:37 <mnoonan> I wonder if there is a way to catch <<loop>> though..
05:55:47 <Taneb> tabaqui: if you feel OK with doing evil things that don't always work, see http://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html
05:55:59 <cocreature> mnoonan: sure if youâ€™re in IO or willing to use unsafeCoerce
05:56:06 <quchen> <<loop>> should be uncatchable because itâ€™s categorically a programming error.
05:56:08 <cocreature> eh unsafePerformIO
05:56:27 <mnoonan> cocreature, I'm willing to do all kinds of things for #haskell :)
05:57:43 <cocreature> mnoonan: I think that counts as doing something against not for #haskell
05:57:49 <mnoonan> heh
05:57:52 <dminuoso> quchen: Im curious, is there a reason you call # unboxed instead of unlifted?
05:58:07 <dminuoso> quchen: I mean specifically I have recently learned about ByteArray which is boxed but unlifted.
05:58:13 <dminuoso> *ByteArray#
05:58:38 <quchen> No reason. Maybe it was wrong.
05:58:47 <quchen> I donâ€™t know the difference between the two.
05:59:17 <quchen> Iâ€™ve got a +1 on misusing words by not misusing the word Â»combinatorÂ« all the time, and I choose to spend it on unboxed vs. unlifted.
05:59:19 <quchen> ;-)
05:59:52 <dminuoso> quchen: unlifted just means cant contain bottom, boxed means it can be a thunk/suspended computation
06:00:07 <dminuoso> Afaik unboxed implies unlifted, but ByteArray# seems to be an example of the converse
06:02:46 <quchen> Hmm that sounds right.
06:02:53 <quchen> But I still donâ€™t see where the difference comes from.
06:03:18 <dminuoso> quchen: ByteArray# can be lazy but not bottom? Dunno really
06:03:34 <quchen> I mean like Â»holomorphicÂ« and Â»analyticÂ« are two different properties in complex analysis, and then thereâ€™s a theorem that says theyâ€™re equivalent.
06:03:41 <cocreature> Array# is heap allocated so itâ€™s boxed but it is still unlifted but it canâ€™t be bottom
06:03:58 <cocreature> eh the last "but" should be a "because"
06:04:58 <quchen> Alright, then I donâ€™t know what the heap stores anymore exactly :-/
06:05:00 <quchen> Or what a thunk is
06:05:27 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-types has a short description but Iâ€™m quite fuzzy on the terminology myself
06:05:29 <quchen> Are there STG closures that canâ€™t contain unevaluated things? That sounds very strange
06:08:53 <cocreature> I kind of doubt the pointers in an Array# count as STG closures but tbh Iâ€™m not sure what the precise definition of an STG closure is so *shrug* :)
06:32:09 <toby1851> suppose i have a value 'mx :: Maybe a' value and i want to hand it to a function 'f :: a -> IO b', is there anything clearer (or more idiomatic) than 'my <- maybe (pure Nothing) f mx' ?
06:34:17 <cocreature> :t traverse :: (a -> IO b) -> Maybe a -> Maybe (IO b) -- toby1851
06:34:18 <lambdabot> error:
06:34:18 <lambdabot>     â€¢ Couldn't match type â€˜Maybeâ€™ with â€˜IOâ€™
06:34:18 <lambdabot>       Expected type: (a1 -> IO b1) -> Maybe a1 -> Maybe (IO b1)
06:34:24 <cocreature> eh
06:34:24 <ski> with that call, `f' must have type `a -> IO (Maybe b)'
06:34:25 <cppxor2arr> uptime: nice to see you in here
06:34:29 <cocreature> :t traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b) -- toby1851
06:34:31 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
06:40:13 <toby1851> yes, ski is right, i'm actually interested in 'f :: a -> IO (Maybe b)'
06:42:40 <ski> @type \f mx -> runMaybeT (MaybeT . f =<< maybe mzero return mx)
06:42:41 <lambdabot> Monad m => (a1 -> m (Maybe a2)) -> Maybe a1 -> m (Maybe a2)
06:44:44 <ski> @type \f mx -> runMaybeT (MaybeT . f =<< MaybeT (return mx))  -- or, i suppose
06:44:46 <lambdabot> Monad m => (a1 -> m (Maybe a2)) -> Maybe a1 -> m (Maybe a2)
06:45:12 * ski looks at toby1851
06:46:28 <ski> if you use `IO (Maybe Blah)' much, you might want to use `MaybeT IO Blah' instead, for a while
06:46:48 <ski> it's short-circuit, aborting as soon as you get a `Nothing'
06:46:50 <toby1851> hang on, i'm still working on traverse... i've got to 'my <- join <$> traverse f mx'  which works, but i'm not convinced is an improvement
06:47:27 <ski> (if you have a sequence of operations and want to get the first that's `Just', you can still use `MaybeT', but then with `(<|>)'/`mplus')
06:48:58 <ski> yea .. that's how you'd do it with `traverse'
06:49:49 <ski> i suggest trying `MaybeT', and see if you can spot more opportunities nearby to use it, so that you don't have to place `runMaybeT' so near where you write `MaybeT'
06:50:20 <ski> (you could, of course, also paste/show your code)
06:50:32 <ski> @paste
06:50:33 <lambdabot> Haskell pastebin: http://lpaste.net/
06:52:20 <toby1851> http://lpaste.net/362988 <= if you insist :)
06:52:56 <toby1851> i'm happy enough with what i've got there
06:53:01 <sepakorayl> guys is there any good vim support for case splitting? I am dealing with a lot of GADTs and case splitting would be very helpful
06:53:11 <sepakorayl> I am open to other editor options as well
06:53:28 <toby1851> i was wondering if there was something fmap-like for my case, and there is - traverse - only my case wasn't quite what i thought it was :)
06:55:23 <shapr> sepakorayl: I know idris does that in emacs, I wish that were available for Haskell
06:55:46 <sepakorayl> yea idris has great vim support as well
06:55:57 <sepakorayl> I was looking for something similar for haskell
06:58:17 <sgraf> quchen: Unboxed <-> Boxed and Lifted <-> Unlifted are basically independent.
06:58:22 <sgraf> quchen: Boxed means 'represented as a pointer to some heap object'. This allows to abstract over the actual memory representation on the heap, so e.g. `const` can be polymorphic without needing to be specialised for a particular representation of the types it's instantiated to: All possible types are just pointers to their representation (c.f. erasure of Java generics to `Object`.
06:59:37 <dminuoso> sgraf: So you could have an Unboxed Lifted type?
07:00:19 <sgraf> quchen: Unboxed means 'has a special representation, possibly other than a machine word' which amounts to passing integers in registers, or structs by value in a language like C. Note that we can't use `const` any longer on e.g. a `Double#`, because on 32-bit doubles are too big to fit.
07:00:34 <sgraf> dminuoso: Just a second :D
07:00:42 <dminuoso> :)
07:00:44 <quchen> sgraf: Ah, interesting.
07:01:43 <sgraf> quchen: Lifted types are, as pointed out by dminuoso, types that may include bottom. Unlifted types specifically do not, so functions which take these as parameters are always strict in them.
07:04:11 <sgraf> quchen: dminuoso: GHC implements lifted types (e.g. the additional bottom) by an indirection, these are the thunks. In order for this to be possible, we have to somehow associate with that thing a piece of code, which implies we need a pointer to somewhere. So, all lifted types are boxed for this reason
07:05:23 <dminuoso> sgraf: Ah that's good to know. This indirection that you speak of, is that an additional indirection from the `tagless` object representation from STG, os is that it?
07:05:41 <quchen> sgraf: I have to leave now, but Iâ€™ll copy that to a text file and read it later. Sounds like a good explanation though, thanks!
07:07:37 <tinco> eh was there a nice little prelude function I could use to reverse application order?
07:07:44 <shapr> :t flip
07:07:45 <lambdabot> (a -> b -> c) -> b -> a -> c
07:08:03 <Psybur> shapr, thats an interesting article. So do you know of any functional programming tutorials that have the correct problem-solution ordering? :D
07:08:13 <sgraf> dminuoso: My STG foo is not so strong. But I believe that GHC will look at the tag (I hope that's the proper terminology) of the heap object it finds. There are tags for Thunks and some for regular data cons (values). If it finds a thunk, it tries to evaluate it if it isn't already (another indirection) and writes the pointer to the value into the thunk object. Then the GC will clean up the evaluated Thunk indirection
07:08:39 <shapr> Psybur: sigfpe's "you could have invented monads"
07:08:58 <tinco> hm shapr I think that isn't what I wanted.. at least it didn't compile :P
07:09:19 <dminuoso> shapr: Heh that's becoming a meme.. I've already seen "you could have invented comonads", "you could have invented fix" ...
07:09:26 <sgraf> quchen: dimnuoso: I guess GHC could make use of some free bits in the representation of `Int#` to index into some table that contains all currently relevant thunk computation recipes (probably not statically bound, but w/e) and spare the indirection. That would be lifted and unboxed
07:09:30 <shapr> tinco: if you have hoogle installed, you can ask it for the type of what you want
07:09:38 <dminuoso> shapr: Next up is some "you could have invented Profunctor optics" probably
07:09:43 <tinco> yeah I'm trying to come up with the type :D
07:09:48 <shapr> Psybur: do you know of any articles that have the correct problem solution ordering?
07:10:00 <sgraf> quchen: dimnuoso: But in practice, unboxed implies unlifted
07:10:02 <shapr> tinco: you can put in a type hole
07:10:09 <shapr> code code _ code code
07:10:27 <shapr> then GHC will say you put in a hole of a particular type.
07:10:30 <tinco> so.. I think flippy :: a -> (a -> b) -> b
07:10:41 <Psybur> shapr, cant say that I do :D
07:10:49 <tinco> right? that takes an argument, and then the argument, and returns the result
07:11:05 <shapr> @hoogle a -> (a -> b) ->b
07:11:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:11:06 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:11:06 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:11:23 <syssiphus> Is ghc-mod deprecated? Trying to install it with stack fails because it needs really old modules.
07:11:24 <dminuoso> tinco: `flip id`
07:11:47 <tinco> so it would be the reverse of ($)
07:11:54 <dminuoso> :t flip id
07:11:55 <lambdabot> b -> (b -> c) -> c
07:11:57 <dminuoso> :t ($)
07:11:59 <lambdabot> (a -> b) -> a -> b
07:12:20 <tinco> dminuoso ah ok.. I'll have to figure out how that works
07:12:45 <tinco> great it worked :D
07:12:48 <dminuoso> tinco: The quick way is to just stare at ($) for a moment, and realize it's a slightly specialized `id`
07:13:03 <tinco> :t id
07:13:05 <lambdabot> a -> a
07:13:30 <tinco> I don't see it :D
07:13:33 <dminuoso> tinco: it's a function that returns what you pass in. ($) is exactly that `(a -> b) -> a -> b`
07:13:42 <tinco> oh like that
07:14:22 <oo_miguel> The functional deps I can put on typeclass declarations simplify calling functions on members of these typeclesses, but I can achieve the same effect by specifying the type I want with '::', right?
07:14:50 <dminuoso> tinco: The way type inference works, `flip` forces that same specialization of `id` - and because it curries you can flip.
07:15:15 * ski annotated "No title" by Toby Goodwin at <http://lpaste.net/362988#a362989>
07:15:18 <ski> toby1851 ^
07:16:47 <dminuoso> tinco: anyway, the usual way is to juse ($) but as a section.
07:17:10 <tinco> dminuoso: as a section?
07:17:18 <toby1851> ski: well i certainly owe you a beer / cup of tea! thank you
07:17:23 <dminuoso> tinco: (+3) is a section, (4/) is a section. ($5) is a section.
07:17:38 <tinco> hm
07:17:44 <dminuoso> tinco: So ($5) is a function that applies 5 to something.
07:17:58 <Putonlalla> :t (&) -- Don't forget our friend.
07:18:00 <lambdabot> a -> (a -> b) -> b
07:18:07 <ski> toby1851 : perhaps it's not worth it to use `MaybeT' here .. but i wanted to show you the idea of it (and `ExceptT' is similar, except that it corresponds to `Either' instead of `Maybe')
07:18:15 <dutchie> is ($5) not a function that applies something to 5?
07:18:22 <phadej> :t ($5)
07:18:23 <lambdabot> Num a => (a -> b) -> b
07:18:35 <dutchie> I guess it depends on your point of view
07:18:44 <dminuoso> dutchie: No you are right. My terminology was off.
07:18:49 <ski> toby1851 : .. also, the code is (of course) not type-checked, so i might have made some error in there, even though i tried not to
07:18:55 <dminuoso> In Haskell you apply functions to values, not the other way around =)
07:18:59 <tinco> Putonlalla: wait what
07:19:27 <Putonlalla> > 42 & numberwang
07:19:29 <lambdabot>  True
07:20:29 <dminuoso> > (+1) & ($3)
07:20:32 <lambdabot>  4
07:20:53 <tinco> ah, so then I still have to make it a section
07:21:04 <dminuoso> tinco: An example of where you might use this..
07:21:17 <tinco> yeah so my thing was that the function is this huge 30 line parser implementation
07:21:24 <tinco> and I didn't want to put parentheses around it
07:22:25 <dminuoso> > fmap ($3) [(==4), (==3), (==2)]
07:22:28 <lambdabot>  [False,True,False]
07:23:49 <tinco> so I changed my flip id to just (&), but it fails saying variable not found (&)
07:23:49 <dminuoso> > [(==4), (==3), (==2)] <*> pure 3
07:23:54 <lambdabot>  [False,True,False]
07:24:07 <w1n5t0n> hey, has anyone used hosc before? I can't figure out how to use it or find any documentation for it
07:24:52 <toby1851> ski - really appreciate your time and trouble, i still find transformers a bit baffling, so those examples will be very useful
07:24:59 <tinco> making the application a section did work though dminuoso, that's nice
07:25:03 <ski> toby1851 : ok, i already noticed the `\case' is a bit off. can be fixed by replacing `>>= \case' by `>>= return . \case' (or add a `return' to both branches) .. one could also use `fmap'/`(<$>)' instead of `(>>=)', but then one'd need to flip the argument order
07:25:26 <tinco> the line is now super weird though :D
07:25:31 <tinco> liftM MGR $ ($v) $ AE.withObject "Repo" $ \o -> -- etc...
07:25:49 <ski> toby1851 : actually, let me go and edit it
07:25:54 <byorgey> liftM MGR . ($v) . AE.withObject "Repo" $ \o -> ...
07:25:56 <dminuoso> tinco: chains of $ can indicate you should use (.) to compose instead
07:26:01 <tinco> I think I overuse $ in my haskell style, but I 'm so bad at using .
07:26:15 <byorgey> tinco: that's a great reason to practice =)
07:26:48 <tinco> well I'm doing this whole project as practice, so I guess here I go again :P
07:27:48 * ski edited the annotation "some variations" at <http://lpaste.net/362988#a362989>
07:28:33 <ski> toby1851 : i also noticed i had forgotten a `liftM' (or equivalently `fmap'/`(<$>)'/`liftA') around a `maybe' call ..
07:29:01 <ski> toby1851 : so, reload the page
07:29:05 <ski> toby1851 : hope this helps ..
07:29:13 <cordawyn> n
07:29:41 <toby1851> ski: it really does, thank you so much
07:30:18 <Wizek> hello
07:30:42 <tinco> I feel the only time I know to use . is when it's in a section, I'd never come up with that line byorgey just made because I don't get the precedence rule I guess
07:31:00 <tinco> hi Wizek :)
07:33:20 <ski> toby1851 : if the `fetchGeoIPCountry' call didn't need to access `ip', i could easily avoid the `return (country,ip)'/`return (ip,country)' nonsense, probably using `runMaybeT (liftM2 (,) (MaybeT clientIP) (liftIO (...)))' .. but that doesn't work in your case
07:34:51 <toby1851> tinco: dunno if this is any help: http://tobold.org/book/dollar
07:35:39 <toby1851> byorgey's line works because $ does the same grouping to the stuff on its left
07:36:13 <tinco> ah thanks, I'll check that out
07:37:18 <toby1851> in fact, chapter 3 specifically talks about ($) and (.) - i'd forgotten that bit
07:37:43 <MacSlow> How do I "match" an IO Int from System.Random.randomRIO with the !! operator, e.g. someListOfThings !! randomIndex
07:39:15 <ski> MacSlow : have you seen `do'-notation ?
07:41:36 <MacSlow> ski: yes, but I was not able to make it work with that... that being said I'm a two-week haskell-greenhorn
07:42:51 <toby1851> MacSlow, since i seem to be pushing my own tutorials this afternoon, you might find this helpful - http://tobold.org/book/doio
07:42:56 <w1n5t0n> I have a stack project and I've added a module dependency in my .cabal file, but when I try to import it I get  "Error: could not find module". The module is this, which I import as "Sound.OSC" http://hackage.haskell.org/package/hosc
07:42:56 <ski> MacSlow : use `randomIndex <- randomRIO ...'
07:43:21 <ski> @wiki Introduction to IO
07:43:21 <lambdabot> https://wiki.haskell.org/Introduction_to_IO
07:43:24 <ski> might be useful
07:44:53 <MacSlow> toby1851: thx for the pointer
07:44:57 <MacSlow> ski: trying...
07:45:56 * MacSlow wants to mention that the book from G. Hutton is failing in some parts to be a introduction to Haskell
07:46:06 <ski> `randomRIO ...' will have type `IO Int', is an action that is not performed/executed yet. using `<-' here will execute it, naming the result `randomIndex', which will then have the type `Int', which you wanted to the right of `!!'
07:47:49 <sepakorayl> is there a convenient way to use MonadErrors e1 m1 in MonadError e2 m2 given an error transformation function?
07:49:24 <MacSlow> ski: looks like I can't do this in a where statement of a function
07:50:00 <ski> right, `<-' has to be inside the `do'-block of commands
07:50:17 <sepakorayl> mtl-2-2-2 has a liftEither :: MonadError e m -> Either e m a -> m a. so I guess I have to use a transformer stack with a first f . liftEither at the end ?
07:50:55 * ski didn't understand sepakorayl's question ..
07:51:33 <MacSlow> ski: I can't apparently write... where result = do randomIndex <- randomRIO (0, 10) \n someListOfThings !! randomIndex
07:52:19 <ski> you probably want `return (someListOfThings !! randomIndex)'
07:53:01 <ski> and note that `result' will not be a list element, but an I/O action that, when executed/performed, will produce a list element
07:53:20 <ski> (you can't "escape" `IO')
07:53:38 <sepakorayl> say I have f :: MonadError e1 m => Int -> m (Int) and g :: MonadError e2 m => Int -> m (Int). How can I use f in g's body assuming a function h :: (e1 -> e2) ?
07:54:05 <MacSlow> ski: yeah... but that's still unusual to me and I'm not very fluent with getting along with that
07:54:36 <cppxor2arr> foldr now if only scanl joined
07:54:53 <ski> (also, if you're familiar with any programming language in which `return' is a keyword that causes the current function/procedure to return, note that this is not what `return' does in Haskell. `return' is just an ordinary function that wraps a value in an "action", "trivially" (a do-nothing action, a no-op))
07:55:17 <foldr> Are there known GHC bugs where a non-clean build affects the reduction of type families, resulting in attempts to unify types with redexes? It seemed to have happened but I find it very hard to reproduce; "stack clean" fixed it.
07:55:21 <EvanR> main = do{ x <- pickRandomItem; print x} where pickRandomItem = do { i <- randomRIO (0,3); return (['a','b','c','d'] !! i) }
07:55:21 <ski> MacSlow : what, more precisely, is unusual to you ?
07:55:56 <ski> (and what does "that" refer to, specifically, in "I'm not very fluent with getting along with that" ?)
07:56:06 <MacSlow> ski: how to deal with IO a when I just need the a to proceed with my computation
07:56:43 <MacSlow> ski: "that" being monadic types
07:56:58 <ski> one can think of it as Haskell enforcing separation of user interface code (I/O), and the "internal computational machinery"
07:57:04 <EvanR> if youre writing IO code, then you will always be "dealing" with IO, and the only way to proceed with the computation is to use >>= or do notation (or <*>)
07:57:19 <EvanR> (>>=) :: IO a -> (a -> IO b) -> IO b
07:57:43 <EvanR> to proceed you need to append a handler like this and compute a new IO action, and so on
07:57:50 <ski> you don't get to do arbitrary I/O inside a function, unless you declare that in the interface (the type signature) of it .. and then you usually also have to rewrite the definition a bit, e.g. using `do'
07:58:11 <MacSlow> ski: I understand the reasons behind it, but handling it isn't obvious when one is  new to the language and has a C++-wired brain
07:58:56 <ski> `do'-notation is syntactic sugar, that desugars to calls to `(>>=)'. at some point you should get comfortable with how this desugaring works, and how to use the "raw" `(>>=)' "action combinator"
07:58:59 <MacSlow> untangling thought-patterns is always an additional obstancle in the learning process... at least for me
07:59:07 <EvanR> you can think of everything in C++ being IO something
07:59:26 <ski> MacSlow : indeed, unlearning stuff, making a distinction that one hasn't made before, is hard
07:59:38 <ski> (but, we think it's worth it, here)
08:00:11 <ski> @quote best.imperative
08:00:12 <lambdabot> ndm says: weitzman, i agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
08:00:23 <ski> actually, i wanted the SPJ quote :)
08:00:25 <MacSlow> ski: I know about some syntatic-sugar in Haskell, but for working through that book from G. Hutton I'll stick to what's written there
08:00:54 <ski> @quote world's.best.imperative
08:00:54 <lambdabot> SPJ says: Haskell is the world's best imperative language.
08:00:56 <ski> (that one)
08:01:21 <mnoonan> MacSlow: this isn't exactly on target, but I have a blog post that does some stuff in both C++ and in Haskell, so you can compare side-by-side: http://storm-country.com/blog/gof-strategy
08:01:30 <ski> (it probably shouldn't be overstated, but there is something to it)
08:01:52 <MacSlow> ski: it's like one would not ask a C++-beginner do grasp template meta-programming or the full scope of type-deduction... although those are just some crude analogies
08:02:26 <EvanR> that is why many beginning haskell stuff has you defining "pure" functions, managing lists, traversing trees
08:02:48 <EvanR> not doing multithreaded programm, STM, etc
08:03:03 <MacSlow> mnoonan: I do as an exercise some of the project eurler tasks in C++ and Haskell to force myself (away from the book) to verify what I already understand and where the gaps in understanding are
08:03:23 <mnoonan> seems reasonable
08:03:45 <MacSlow> mnoonan: but link is bmarked as is toby1851's url
08:04:25 <MacSlow> EvanR: one also does not start with that in a good C++-introductory book :)
08:04:47 <MacSlow> EvanR: fib and prime and hello-world all the way ;)
08:05:52 <EvanR> IO can be introduced as if it was a special section of the language specifically designed for I/O without going into monads and do desugaring
08:06:00 <ski> MacSlow : since you're coming from C++, perhaps you'd appreciate listening to Bartosz Milewski <https://www.youtube.com/user/DrBartosz> regarding Haskell, and Haskell-inspired C++, at some point (and also about category theory, if you decide you want to care about that)
08:06:03 <EvanR> but it usually isnt, for better or worse
08:06:58 <EvanR> but it would only make sense after accepting the idea of purely functional programming
08:07:23 <MacSlow> ski: I came across that name and some videos already... seemed like a good resource... glad to heaer my impression wasn't off
08:08:09 <cocreature> EvanR: I like monochromeâ€™s tutorial in that regard https://www.vex.net/~trebla/haskell/IO.xhtml
08:08:28 <MacSlow> EvanR: ha... interesting... I was wondering now the usual design patterns might apply to something like haskell... is it a 1:1 mapping, do some things need to be adjusted... or do some patterns not make sense at all
08:09:24 <EvanR> cocreature: it does dwell a lot on desugaring here
08:10:02 <EvanR> MacSlow: a lot of classic design patterns in OOP kind of melt away because of (possibly lazy) functional programming
08:10:22 <EvanR> would be interesting to review them all and revisit them thinking in terms of haskell
08:10:34 * mnoonan is working on it, starting from that previous blog post :)
08:10:42 <cocreature> EvanR: yeah I was referring to the â€œnot going into monadsâ€ parts, not the do desugaring
08:10:48 <mnoonan> ezyang, too
08:10:49 <EvanR> yeah isee that
08:10:51 <cocreature> not sure omitting do desugaring is really helpful
08:11:21 <EvanR> i think it would "get you started" at least
08:11:45 <EvanR> like a physics class kind of "lie to children"
08:12:19 <jchia_> What's Proxy#? When is it used instead of Proxy?
08:13:09 <MacSlow> EvanR: off the top of my head I would say the visitor-pattern goes out the window
08:13:14 <EvanR> sure
08:13:26 <cocreature> EvanR: my problem wich omitting do desugaring is that it makes seem IO more magic than it is and at least for me feeling that certain things are â€œmagicâ€ hinders my understanding
08:13:36 <cocreature> obviously other people might feel differently
08:14:01 <EvanR> yes treating IO as magic was my subject... which yeah might not be good
08:15:01 <EvanR> personally i like the idea of introducing it as a DSL data structure with >>= as a linking constructor
08:15:04 <MacSlow> as odd and difficult as is, getting to know Haskell is really exciting... even more than learning about C++11 years ago
08:15:09 <EvanR> which i know is another one of monochrom's tutorials
08:15:52 * MacSlow even forgives Haskell for it's GC-nature :)
08:15:55 <EvanR> but some people give that approach flak because its not how its really implemented
08:16:20 <Taneb> EvanR: the implementation of IO feels like a second, more subtle magic
08:16:23 <EvanR> depending on teh workload, i have noticed the gc being really fast
08:16:47 <kuttifunk> hi all, anybody can point me to some working examples how persistent is used with MySQL backend? I went through all documentation i found but i am not able to get something up and running (wrong backend type, etc.). Thanks in advance!
08:16:52 <Taneb> Or at least, I don't understand it after ~7 years of programming mostly in Haskell
08:17:00 <EvanR> i cant stand that magic
08:17:12 <Taneb> (I've never actually had to deal with the implementation of IO, though)
08:18:27 <cocreature> I donâ€™t think knowing how IO is implemented is really helpful for anything
08:18:51 <cocreature> as soon as you start thinking about concurrency any intuition you might have gained that way breaks completely
08:18:58 <roconnor> Different implementations of Haskell implement IO in different ways.
08:19:21 <Taneb> roconnor: that's also a good point, I'm falling a bit into the Haskell = GHC trap here
08:19:22 <cocreature> well there is only one relevant implementation of Haskell so I donâ€™t really buy that argument
08:19:26 <tdammers> "different implementations of haskell"? what kind of heresy is that?
08:19:46 <EvanR> haskell monotheism
08:19:53 <roconnor> Surely everyone uses Hugs.
08:20:05 <EvanR> the old gods are false
08:20:06 <Taneb> I have in fact used Hugs... once...
08:20:07 <maerwald> frege
08:20:22 <tdammers> eta, ghcjs, jhc, uhc, ...
08:20:30 <EvanR> frege is really merely haskell-like
08:20:40 <maerwald> but it's usable
08:20:51 <tdammers> I thought the frege folks were working on making it at least haskell98 compliant
08:21:26 <TMA> I have used hugs, iirc. back in 2001 or 2002
08:21:31 <roconnor> Yesterday I was torn between making orphan instances or making recursive modules.  The thing is that orphan instances is not legal Haskell while recursive modules are; however GHC supports oprhan instances but doesn't support recursive modules ...
08:21:35 <ski> HBC
08:21:43 <roconnor> In the end I chose to go with recursive modules. :D
08:21:57 <ski> hm, can't recall seeing augustss/lennart for some time
08:22:34 <roconnor> augustss made some reddit comments not too long ago.
08:22:46 <ski> ok, good to hear
08:22:51 <roconnor> @seen augustss
08:22:51 <lambdabot> 4uGu5T$5
08:24:05 <roconnor> Actually, in the end I chose to go with GADTs.
08:24:59 <cocreature> roconnor: so GHC and not Haskell2010 after all :)
08:29:07 <w1n5t0n> anyone have any idea why intero can't find a module, even though it's included as a dependency in the package.yaml file?
08:33:51 <roconnor> cocreature: GADTs are just too good.
08:37:32 <metahumor> w1n5t0n: is it installed on the machine? is it registered in ghc-pkg? have you restarted your emacs after doing those first two things?
08:42:41 <w1n5t0n> metahumor: restarting emacs fixed it, the more I learn programming the more I am inclined to believe that restarting things is equivalent to magic. Thanks!
08:43:28 <EvanR> "try turning it off and on again"
08:43:35 <statusfa1led> least satisfying solution ever
08:43:42 <statusfa1led> also most common
08:44:58 <metahumor> here, it's very satisfying, you've updated the intero pkg cache
08:45:40 <metahumor> there's only 2 problems in programming: naming things, cache invalidation, and off-by-one errors
08:45:52 <statusfailed> heh :D
08:46:00 <metahumor> i also love this koan about my former boss
08:46:24 <metahumor> A novice was trying to fix a broken Lisp machine by turning the power off and on.
08:46:28 <metahumor> Knight, seeing what the student was doing, spoke sternly: â€œYou cannot fix a machine by just power-cycling it with no understanding of what is going wrong.â€
08:46:31 <metahumor> Knight turned the machine off and on.
08:46:34 <metahumor> The machine worked.
08:47:39 <statusfailed> hahaha
08:54:17 <ski> @remember metahumor there's only 2 problems in programming: naming things, cache invalidation, and off-by-one errors
08:54:18 <lambdabot> It is stored.
08:55:22 <shapr> metahumor: tom knight was your former boss?
08:55:56 <Taneb> shapr: might have been the novice
08:56:53 <shapr> good point
08:57:00 <EvanR> metahumor wrote that on?
08:57:15 <Taneb> EvanR: he wrote it just now in IRC
08:57:34 <Taneb> Although it's certainly earlier than that (I quoted a variant of it a few hours ago)
08:58:28 <metahumor> shapr: yes
08:58:51 <metahumor> Taneb: ah, missed your quote of it
08:59:08 <Taneb> metahumor: well, that was around the lunch table in my office, not on IRC
08:59:46 <Taneb> metahumor: so it's unlikely you would have noticed ;P
09:04:56 <metahumor> ski: just for reference, that aphorism is attributed to Tim Bray + folklore
09:07:04 <batman_> why i get "Not in scope: data constructor â€˜PublicKeyâ€™ " when module clearly exports it ??
09:07:50 <cocreature> batman_: I suspect the module is exporting a type called PublicKey and not a data constructor
09:08:31 <batman_> cocreature : my bad you're right
09:12:09 <batman_> cocreature : i'm having trouble understanding this "data Bytes = Bytes (MutableByteArray# RealWorld)" can you please explain, i have neever seen such data type declaration before
09:12:32 <batman_> data Bytes = Bytes (MutableByteArray# RealWorld)   deriving (Typeable)
09:12:56 <cocreature> batman_: whatâ€™s confusing you about it?
09:14:43 <batman_> cocreature : (MutableByteArray# RealWorld)
09:14:59 <batman_> and that hashtag (#)
09:15:01 <cocreature> batman_: MutableByteArray# is a type that takes one parameter which in this case is RealWorld
09:15:11 <cocreature> types that end in # are GHC primitives
09:15:41 <cocreature> you need to enable the MagicHash extension to be able to use them but itâ€™s just a syntactic restriction
09:18:57 <batman_> cocreature : is there any other way to assign a value of type for which there is no data constructor other than (a = value :: type)
09:19:07 <armlesshobo> :k Monad ( (->) Int )
09:19:09 <lambdabot> Constraint
09:19:14 <armlesshobo> interesting
09:20:53 <batman_> cocreature : (a = value :: type) in this case does value assignment (i mean the value that can be assigned this type) depends on the classes, type derives ??
09:21:14 <cocreature> batman_: what is "value" supposed to be here?
09:21:31 <cocreature> how you can construct values of a given type depends on the type. thatâ€™s not something that can be answered in general
09:21:40 <cocreature> if the constructors are not exposed there are probably some other interfaces
09:22:36 <batman_> ocreature : for example say (a = 10 :: Word8)
09:22:48 <dminuoso> batman_: That happens through the Num instance for Word8
09:23:05 <dminuoso> :t 10
09:23:07 <lambdabot> Num p => p
09:23:26 <cocreature> batman_: in that case the interface that is provided is the Num instance of Word8
09:23:27 <batman_> dminuoso : that exactly was doubt.
09:24:15 <EvanR> :t fromInteger
09:24:16 <lambdabot> Num a => Integer -> a
09:24:36 <EvanR> thats the relevant method that takes 10 (Integer) to a Word8
09:24:41 <cocreature> batman_: do you have some underlying problem that youâ€™re trying to solve? I feel like we might have an xy problem here
09:24:51 <dminuoso> batman_: The idea is that when you type 20, it's not interpreted as Integer, but instead it's some polymorphic yet-to-be-determined type that can be made from an Integer.
09:29:13 <batman_> cocreature : yeah i'm facing a problem, here you go i have explained my problem in comments http://lpaste.net/362993
09:30:02 <cocreature> batman_: what do you want to convert PublicKey to?
09:30:58 <glguy> batman_: You should include how you imported PublicKey in your paste
09:31:03 <cocreature> batman_: if you take a look at the instances of PublicKey https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Curve25519.html#t:PublicKey you can see it is an instance of ByteArrayAccess
09:31:10 <batman_> cocreature : eventually to a string
09:31:35 <glguy> batman_: As you can see from cocreature's link to the documentation, the PublicKey data constructor is not exported, so you can't import it
09:31:37 <cocreature> batman_: if you follow that link to https://hackage.haskell.org/package/memory-0.14.14/docs/Data-ByteArray.html#t:ByteArrayAccess you are given quite a few functions which allow you to process instances of ByteArrayAccess and thereby also PublicKey
09:31:42 <batman_> glguy : i just imported the module exporting it
09:32:12 <Taneb> batman_: what does "show" do to a PublicKey?
09:32:13 <cocreature> batman_: in particular https://hackage.haskell.org/package/memory-0.14.14/docs/Data-ByteArray.html#v:convert (which Iâ€™ve linked to you before) which allows you to convert a PublicKey to an arbitrary instance of ByteArray
09:32:38 <cocreature> batman_: among other things ByteString and Bytes are instances of ByteArray so you can use "convert" to convert to one of those types
09:32:48 <dminuoso> So this is a weird question because it seems almost obvious, but why are strings not polymorphic out of the box? Is that an oversight, or are there good reasons?
09:33:17 <EvanR> OverloadedStrings does sometimes add complications to code, it fails to typecheck due to ambiguities
09:33:34 <EvanR> code containing string literals with no indication of which type you want
09:33:36 <majkrzak> Hi I'm trying to parse yaml file with haskel. What I want to do is to traverse it like a tree and return some data accoriding to node types. I'm reading Data.Yaml but I'm not sure if it is what i want
09:33:51 <dminuoso> EvanR: Mmm. Wouldn't type defaulting cover ambiguities?
09:34:00 <ertes-w> dminuoso: history
09:34:25 <EvanR> defaulting doesnt mean it will necessarily type check suddenly
09:34:27 <ertes-w> dminuoso: defaulting fixes most issues, but not allâ€¦  it's pretty much the same as for integers
09:34:33 <EvanR> and if it does, might not default to what you wanted
09:34:44 <cocreature> majkrzak: you could use Data.Yaml to parse the yaml into a "Value" and then traverse that
09:35:18 <EvanR> dminuoso: the question is... when does it make sense to overload strings? text right, the fact that Text is not string is the real issue
09:35:39 <EvanR> otherwise, it makes as much sense as overloading lists
09:36:16 <EvanR> overloaded strings is kind of an attempt at convenience due to at least 3 kinds of string
09:36:20 <majkrzak> cocreature: but it looks like it something is wrong with that type: "A JSON value represented as a Haskell value."
09:36:27 <majkrzak> not all types are represended
09:36:54 <batman__> glguy : but here it is exported https://hackage.haskell.org/package/cryptonite-0.25/docs/src/Crypto-PubKey-Ed25519.html#PublicKey
09:37:11 <glguy> batman__: No, it's not exported there
09:37:11 <dminuoso> EvanR: Interesting, that actually is the only place where I seem to use OverloadedStrings.
09:37:20 <majkrzak> it looks better in text.libyaml
09:37:43 <dminuoso> EvanR: I mean realistically its a non issue because I can just turn it on and be happy.
09:37:45 <batman__> glguy : what's this then module Crypto.PubKey.Ed25519     ( SecretKey     , PublicKey
09:37:50 <cocreature> majkrzak: right, Data.Yaml is limited to the subset of yaml that can be converted to json. if you need more or need to differentiate between the different ways that you can write something in yaml then youâ€™ll have to use another lib
09:38:10 <glguy> batman__: That's the data constructor not being exported, only the type
09:38:11 <EvanR> dminuoso: yeah i use it too, but it does cause issues sometimes
09:38:13 <ertes-w> dminuoso: OverloadedStrings is useful in a lot of cases, including most SQL libraries, most templating libraries, some parser libraries, etc.
09:38:35 <dminuoso> ertes-w: Fair enough, I guess Ill get to those soon =)
09:39:03 <batman__> glguy : so suppose i have a similar type so how do i export the data constructor ?
09:39:12 <glguy> PublicKey(PublicKey)
09:39:13 <majkrzak> cocreature: basicly int/float is not distinguised :(
09:39:45 <EvanR> int and float are not distinguished in json
09:40:05 <EvanR> actually its neither, its a decimal exponential number
09:40:36 <EvanR> hence Scientific by default
09:40:37 <metahumor> ertes-w: how do you feel about OverloadedStrings in megaparsec, which lets you do `"mymatch"` instead of `string "mymatch"`?
09:40:57 <majkrzak> EvanR: but in yaml they are
09:41:23 <EvanR> i thought we were talking about JSON
09:43:07 <EvanR> that is odd, Data.Yaml beggins by explaining JSON
09:43:12 <Psybur> How do you guys pronounce JSON? jay-sun (correct) or jay sawn (incorrect)? :D
09:44:27 <Taneb> Psybur: I suspect this may be a loaded question
09:44:27 <EvanR> who pronounces things?! dont we all access computers from within a sealed room alone...
09:44:48 <metahumor> jizz-on
09:45:20 <Psybur> metahumor, I see we have a new correct pronunciation
09:45:34 <metahumor> "javascript object notation"
09:45:50 <Psybur> JavaScript? Oh no!
09:46:28 <metahumor> json was a mistake. you can never be sure you parsed a valid json or subportion until you parse the entire file
09:46:33 <handyc> https://www.reddit.com/r/javascript/comments/2mapkc/how_to_pronounce_json/
09:46:36 <EvanR> majkrzak: maybe... http://hackage.haskell.org/package/yaml-light-0.1.4/docs/Data-Yaml-YamlLight.html
09:48:38 <EvanR> but that one doesnt have numbers at all...
09:49:48 <majkrzak> I was wondering to deel with https://hackage.haskell.org/package/yaml-0.8.28/docs/Text-Libyaml.html
09:51:04 <EvanR> looks like there are many kinds of scalars
09:51:24 <acowley> You can use http://hackage.haskell.org/package/yaml-light-lens-0.3.3.4/docs/Data-Yaml-YamlLight-Lens.html#v:_Yaml
09:51:33 <acowley> If you want numbers
09:51:47 <EvanR> "The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters."
09:52:15 <EvanR> cool
09:52:20 <batman__> is there a function to convert [Word8] to hex
09:53:27 <glguy> > printf "%02x" =<< [1,7..255 :: Word8] :: String
09:53:29 <lambdabot>  "01070d13191f252b31373d43494f555b61676d73797f858b91979da3a9afb5bbc1c7cdd3d9d...
09:53:39 <metahumor> batman__: you mean hex representation of a value, like (256 :: Word8) -> ("FF" :: String)?
09:54:06 <batman__> metahumor : yep
09:54:07 <metahumor> *255 sorry
09:55:33 <batman__> metahumor : so is there a function >?
09:55:38 <majkrzak> EvanR, cocreature: https://hackage.haskell.org/package/yaml-0.8.28/docs/Text-Libyaml.html may be good chose but i dont kwno how to deal with it.
09:56:51 <sm> batman__: https://hoogle.haskell.org/?hoogle=hex&scope=set%3Astackage&=
09:57:21 <glguy> batman__: I just showed you how
09:58:03 <Psybur> > printf "%02x" =<< [255]
09:58:05 <lambdabot>  error:
09:58:05 <lambdabot>      â€¢ Ambiguous type variable â€˜b0â€™ arising from a use of â€˜show_M511728272831...
09:58:05 <lambdabot>        prevents the constraint â€˜(Show b0)â€™ from being solved.
09:58:14 <Psybur> > printf "%02x" =<< [255 :: Word8]
09:58:16 <lambdabot>  error:
09:58:17 <lambdabot>      â€¢ Ambiguous type variable â€˜b0â€™ arising from a use of â€˜show_M179964378255...
09:58:17 <lambdabot>        prevents the constraint â€˜(Show b0)â€™ from being solved.
09:58:20 <Psybur> > printf "%02x" =<< [255 :: Word8] :: String
09:58:23 <lambdabot>  "ff"
09:58:49 <Psybur> :t printf
09:58:51 <lambdabot> PrintfType r => String -> r
09:58:56 <batman__> glguy : sorry i didn't see it bt nw that i did i doesn't make much sense to me :P
09:59:52 <Psybur> :t PrintfType
09:59:54 <lambdabot> error: Data constructor not in scope: PrintfType
10:00:27 <Psybur> Yeah that ones throwing me off too haha
10:00:35 <Psybur> :t printf "%02x"
10:00:37 <lambdabot> PrintfType r => r
10:01:02 <Psybur> :t (=<<)
10:01:03 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:01:32 <Psybur> How is PrintfType satisfying (a -> m b)
10:01:45 <EvanR> > printf "%02x" (255 :: Word8) :: String
10:01:47 <lambdabot>  "ff"
10:02:08 <EvanR> the originaly questino should have been, is there a function to convert a Word8 to a 2-hex string
10:02:41 <EvanR> because you can just map it
10:04:59 <Psybur> Im baffled by this printf function. It takes a sting an returns a printftype. Im not seeing how youre able to apply "PrintfType r" to a Word8 heh
10:05:18 <ski> @forget metahumor there's only 2 problems in programming: naming things, cache invalidation, and off-by-one errors
10:05:18 <lambdabot> Done.
10:05:24 <metahumor> ski: ha
10:05:25 <ski> @remember metahumor (Tim Bray + folklore) there's only 2 problems in programming: naming things, cache invalidation, and off-by-one errors
10:05:26 <lambdabot> I will never forget.
10:06:27 <Psybur> > printf "%02x" (255 :: Word8) :: IsChar
10:06:29 <lambdabot>  error:
10:06:29 <lambdabot>      â€¢ Expecting one more argument to â€˜IsCharâ€™
10:06:29 <lambdabot>        Expected a type, but â€˜IsCharâ€™ has kind â€˜* -> Constraintâ€™
10:08:24 <Psybur> Anybody able to explain that? :D
10:10:48 <cocreature> Psybur: it doesnâ€™t return a "PrintfType r". it returns an "r" which is an instance of PrintfType
10:11:11 <cocreature> Psybur: among other things "a -> r" is an instance of PrintfType if a is an instance of printfArg
10:11:15 <cocreature> *PrintfArg
10:11:53 <Psybur> Ah, that instance wasnt clicking for me when I was peepin the hackage :D
10:11:56 <Psybur> Thanks
10:13:38 <Psybur> Thats interesting. You dont need to unwrap the (a -> r) out of the PrintfType first before applying it?
10:13:56 <cocreature> again, PrintfType is not a type, itâ€™s just a typeclass
10:14:06 <cocreature> like Eq or Ord
10:14:09 <cocreature> you donâ€™t unwrap those either
10:14:50 <michalrus> Hm, hmmm. If I `throwTo MyException` and then `handleAsync (\e :: MyException -> â€¦)`, itâ€™s not being caught. :o But with `handleAsync (\e :: SomeAsyncException -> â€¦)` it is being caught. Hmmm.
10:15:00 <michalrus> These functions are from safe-exceptions.
10:15:40 <michalrus> Shouldnâ€™t handleAsync and throwTo work with that same type?
10:21:13 <cocreature> michalrus: throwTo from safe-exceptions wraps the exception in SomeAsyncException before calling the throwTo primitive provided by GHC
10:21:51 <michalrus> Soâ€¦ how can I catch an async exception of a known type? I donâ€™t want to catch all of them.
10:22:25 <michalrus> catchAsync â†’ fromException . toException  == MyException â†’ rethrow if not? :o
10:22:35 <michalrus> That feels a bit clunkyâ€¦
10:22:39 <cocreature> if your exception is only intended to be used asynchronously you could do the unwrapping in the Exception instance of MyException
10:23:01 <michalrus> Or maybe just use Unsafe.throwTo from base? Hmmm.
10:23:05 <michalrus> Okay! Thanks. :)
10:23:09 <cocreature> yeah or that
10:23:55 <cocreature> if youâ€™re catching async exceptions you are already doing what safe-exceptions was designed to avoid :)
10:24:36 <michalrus> Yes, and thatâ€™s bad. :/ But Iâ€™m working around the API of https://hackage.haskell.org/package/websockets
10:25:12 <michalrus> There seems to be no way to do application-level ping timeout without such hacks. :( https://github.com/jaspervdj/websockets/issues/159
10:25:58 <cocreature> oh Iâ€™m not saying thereâ€™s anything wrong with what youâ€™re doing. what Iâ€™m trying to say is that at that point, using "throwTo" from safe-exceptions doesnâ€™t provide much value
10:28:04 * michalrus nods =)
10:31:52 <Guest4282> application level ping timeout?
10:33:06 <michalrus> Guest4282: in current websockets implemenation, the application is not notified in any way. I tested by dropping the packaets on iptables and leaving it for 10+ minutes.
10:33:36 <Guest4282> of what, not getting a ping?
10:33:44 <michalrus> Kind ofâ€¦ yes.
10:33:47 <michalrus> *pong
10:33:57 <Guest4282> odd
10:34:05 <michalrus> Some WAI timeout should be triggered, too, IIRC, but itâ€™s not, either.
10:34:13 <michalrus> And I needed to get it done. #deadlines
10:38:39 <EvanR> "Composition with an Iso is index- and measure- preserving." can anybody explain what is index and measure preserving
10:39:24 <metahumor> order and number of items remains the same?
10:42:35 <EvanR> erm
10:46:33 <majkrzak> Hi, was trying to traverse yaml file using https://hackage.haskell.org/package/yaml-0.8.28/docs/Text-Libyaml.html using decode but i can not get how to deel with Conduit
10:53:53 <piark_> hello
10:56:50 <metahumor> hi
10:58:59 <iphy> hi, I'm trying to build foundation and basement, and I see this in foundation: https://github.com/haskell-foundation/foundation/blob/master/Foundation/Time/Types.hs#L24
10:59:11 <iphy> instance PrimType NanoSeconds where .. some functions ..
11:00:07 <iphy> but PrimType requires a PrimSize: https://github.com/haskell-foundation/foundation/blob/master/basement/Basement/PrimType.hs#L166
11:00:24 <iphy> how does this work?
11:02:48 <cocreature> iphy: looks like itâ€™s just an incomplete instance
11:03:14 <iphy> cocreature: which is a bug or a language feature I don't know about?
11:03:33 <iphy> I'm trying to compile this package and failing
11:03:35 <cocreature> iphy: GHC warns about it but itâ€™s not an error
11:03:40 <iphy> oh
11:03:50 <iphy> oh yeah, you're right, it's a warning
11:03:59 <cocreature> (unless you compile with -Werror)
11:04:41 <cocreature> iphy: seems quite easy to provide those definitions so Iâ€™m sure theyâ€™d be happy to get a PR
11:27:30 <EvanR> is index-preserving a thing in lens speak?
11:52:58 <shapr> metahumor: well that's super cool
11:53:18 <shapr> metahumor: were you the novice power cycling the lisp machine?
11:55:16 <majkrzak> damn text.libyaml is not hwat i want :(
11:58:03 <MacSlow> just wondering... what is the correct way to provide a program-return to the system-environment? I have not found anything in System.Environement
11:58:38 <MacSlow> a main = return someValue works in the repl, but not as a compiled program
11:59:01 <MacSlow> in the compiled version the program's return value is always 0
11:59:04 <EvanR> main = return () does work when compiled
11:59:06 <lyxia> MacSlow: see System.Exit
11:59:07 <EvanR> ah
11:59:21 <MacSlow> ah... System.Exit.... looking
12:00:05 <majkrzak> So there is no working YAML library for haskel?
12:00:21 <EvanR> i saw several while researching your question
12:00:57 <lyxia> majkrzak: what's the problem with yaml
12:01:05 <MacSlow> lyxia: thx
12:01:18 <EvanR> it interprets everything as a aeson Value
12:01:40 <majkrzak> exacly
12:01:54 <lyxia> The module you linked to doesn't.
12:02:13 <majkrzak> I've tryied to parse it with Text.libyaml, but then type info is lost
12:03:36 <majkrzak> lyxia: only explicit tagse (!!str) are provided in events
12:03:59 <EvanR> aiui that is all yaml specifies
12:04:30 <EvanR> text + tag for scalars
12:04:56 <metahumor> shapr: nope, that's way before my time. tom knight and i worked more trying to get cells to turn off and on
12:05:33 <shapr> sounds pretty cool, have you seen acowley's work on cell sized robots?
12:05:37 <pikajude> whoa, i didn't even know haddock supported inline latex!
12:05:40 <pikajude> that's amazing
12:06:28 <cocreature> pikajude: idontgetoutmuchâ€™s kalman filter lib is a very nice demonstration of that feature https://hackage.haskell.org/package/kalman-1.0.0.2/docs/Numeric-Kalman.html
12:06:58 <pikajude> it's beautiful!
12:07:12 <pikajude> I just found this out because i was trying to write an un-formatter for haddock
12:07:30 <metahumor> shapr: i have not -- link?
12:07:58 <EvanR> wow
12:08:18 <shapr> metahumor: I think it's the 2013 stuff: http://www.seas.upenn.edu/~acowley/ last I asked, I got a link to a video
12:08:28 <shapr> acowley: are your cell sized robot papers available?
12:09:26 <shapr> but I figure that's what led to https://github.com/acowley/roshask
12:09:35 <majkrzak> lyxia: oh, so i have to deel wit it by myself
12:10:27 <shapr> My gf is doing a predictive analysis course (in R) for her master's degree right now, I'd really like to dive into https://github.com/acowley/Frames
12:10:38 <shapr> acowley builds cool code
12:13:17 <majkrzak> Gota one more question: Is there some way to pass string fetched from conduit `stdin` to `decode :: MonadResource m => ByteString -> ConduitM i Event m () ` caouse .| operator is not what I'm need
12:14:28 <cocreature> majkrzak: you are probably going to have to convert it to a ByteString first. the underlying C lib probably doesnâ€™t support streaming input
12:16:13 <majkrzak> cocreature: that is how I'm doing it ringht now, but was wondiering if it is possible like `runConduitRes $ stdin .| magic decode` ...
12:16:42 <suzu> i'm having trouble trying to make an induction for this typeclass
12:16:44 <cocreature> majkrzak: that would require the yaml lib to provide an interface that accepts streaming input which it doesnâ€™t
12:16:44 <suzu> http://lpaste.net/8567455957238415360
12:16:54 <suzu> is it even possible?
12:19:40 <suzu> essentially i'm trying to make variadic arguments. i guess. except not actually variadic but determined from another type
12:20:35 <cocreature> how can I explicitely import (:) from the Prelude?
12:21:04 <cocreature> ah nvm looks like that exists even with NoImplicitPrelude
12:22:46 <amalloy> suzu: most obvious thing that stands out as wrong to me is that Funcify has no parameters but you're usnig it as though it had one
12:23:27 <amalloy> you also have overlapping instances: GHC doesn't really like to be told "this instance applies, unless this other instance applies"
12:23:31 <dminuoso> GHC.Types contains: `data [] a = [] | a : [a]`
12:23:48 <suzu> oh oops, i meant `data Funcify a = Funcify a`
12:23:48 <dminuoso> Is this the actual implementation lists, or is this just some fake definition for some reasons?
12:24:14 <suzu> these instances do not overlap
12:24:22 <EvanR> [] is the actual  type ctor...
12:24:23 <suzu> afaict, at least
12:24:26 <suzu> ghc makes no complaint
12:24:44 <amalloy> sure they do. (r -> a) unifies with a, and you have instances for each
12:24:55 <EvanR> [a] is sugar for [] a
12:25:16 <EvanR> and : is a valid infix ctor, since it starast with :, so it looks good!
12:25:27 <suzu> it doesn't unify because of the type constraint, so it is separate. no?
12:25:37 <suzu> `Test a => `
12:25:52 <dminuoso> EvanR: My question is rather.. is [] and (:) implemented as an internal primitive? Or does [] and (:) use that actual definition?
12:26:22 <dminuoso> I mean [1,2,3] is obviously syntax.
12:26:36 <roconnor> I can tell which modules are untested because they are compiled after Main when building the testsuite. :D
12:27:10 <amalloy> suzu: you have declared that, for all types a, without any exceptions whatsoeever, magic _ _ = (). then you have further declared that for some types, magic _ r = ...
12:27:20 <amalloy> "everything" overlaps with "something"
12:27:41 <suzu> oh hm :/
12:27:52 <suzu> what can i do about that?
12:28:24 <EvanR> dminuoso: if you try to use [] as a ctor yourself, it fails to compile
12:28:38 <amalloy> i'm not really an expert at this stuff, i'm afraid
12:28:41 <EvanR> so that definition is fishy
12:28:43 <suzu> ah. okay
12:29:10 <EvanR> but [] Nothing and () are all implemented the same way at runtime
12:29:25 <amalloy> what you're trying to do looks pretty silly to me, but perhaps there is a legitimate reason. you can probably do it with some GHC extensions
12:30:03 <dminuoso> EvanR: I guess what Im trying to get a feeling for.. if I used `data List a = Cons a (List a) | Nil`, instead - does that too have the same runtime representation and performance behavior?
12:30:13 <suzu> i have a handle to a function, and i know the type of that function
12:30:21 <EvanR> yes, except for RULES
12:30:26 <suzu> i want to "unpack" that handle in a real function that will call that function
12:30:31 <suzu> into a real function *
12:31:35 <suzu> so i want to say `Handle (Int -> Int) -> Int -> Int -> IO ()`
12:32:16 <suzu> or more generally `Handle (r -> a) -> r -> IO a` or something like this
12:32:42 <amalloy> okay, so far it is very easy: you pattern-match on the Handle object and retrieve the function. what is the typeclass for?
12:33:11 <suzu> the handle object does not contain the haskell function
12:33:27 <dminuoso> EvanR: I see. So I could just copy the RULES, and then I'd have the same exact thing?
12:33:35 <suzu> suppose that it contains nothing, actually. it is isomorphic to Proxy
12:33:47 <suzu> so i need to make the function from the type of the handle
12:34:10 <EvanR> dminuoso: yes, as i understand it
12:34:23 <suzu> those arguments will be collected and then some work will be done in IO to get a result
12:34:29 <dminuoso> EvanR: That.. is quite impressive then.
12:34:30 <EvanR> i mean, except for library support
12:34:33 <dminuoso> EvanR: Oh yeah.
12:34:56 <EvanR> the list data structure isnt really different from other DTs
12:35:01 <EvanR> in terms of runtime objects
12:35:13 <amalloy> so for some cases of Handle t, you have code somewhere that knows about that specific t and how to handle it
12:35:27 <EvanR> ADTs
12:35:57 <amalloy> sounds more like a type family than a typeclass
12:36:10 <amalloy> (but i am also not an expert in type families)
12:36:20 <suzu> a type family is a function over types
12:36:42 <suzu> i need to produce an actual function that will collect the arguments that Handle wants.. so i dont think a type family is correct here
12:38:44 <woodson> Hey guys question, i am building a small library that interacts with salesforce api and im facing a design obstacle. So, when making a rest api request there are some optional field that can be added
12:39:16 <dminuoso> @let data List' a = Nil' | Cons' a (List' a)
12:39:17 <lambdabot>  Defined.
12:39:40 <dminuoso> > unsafeCoerce (Cons' (1 :: Int) (Cons' 2 (Cons' 3 Nil'))) :: [Int]
12:39:43 <lambdabot>  error:
12:39:44 <lambdabot>      Variable not in scope: unsafeCoerce :: List' Int -> [Int]
12:39:49 <woodson> And these fields have optional values as well. Is it better to create data types for them or just allow user to send a Map text text and let them define the option and value
12:39:55 <woodson> ?
12:39:57 <EvanR> lol
12:40:03 <dminuoso> EvanR: Ah well. In GHCi this works! Im baffled.
12:40:14 <dminuoso> This is pretty cool. :)
12:40:21 <dminuoso> @undef
12:40:21 <lambdabot> Undefined.
12:40:35 <EvanR> it idid? relaly
12:40:38 <dminuoso> EvanR: Yes.
12:41:13 <dminuoso> % :t unsafeCoerce
12:41:14 <yahb> dminuoso: a -> b
12:41:23 <EvanR> i love it when haskell "has nothing up its sleeves"
12:41:45 <dminuoso> % data List' a = Nil' | Cons' a (List' a)
12:41:45 <yahb> dminuoso:
12:41:52 <dminuoso> % unsafeCoerce (Cons' (1 :: Int) (Cons' 2 (Cons' 3 Nil'))) :: [Int]
12:41:52 <yahb> dminuoso: [1,2,3]
12:42:42 <EvanR> that move is kind of like, launching a rocket into space that then comes back and lands right side up
12:43:03 <fishythe_> oh cool, spacex is using haskell?
12:43:16 <metahumor> what if you had a "data ExtraList a = Nil | AlsoNil | Cons a (ExtraList a)"?
12:43:28 <dminuoso> metahumor: tias? :D
12:43:44 <metahumor> tias?
12:43:57 <qeyoa> i'm trying to figure out what do the colon in `(EVAL y : c)`, or `(ADD n : c)` do in this example: http://lpaste.net/362996?
12:44:02 <qeyoa> is this pattern matching?
12:44:06 <dminuoso> metahumor: Try it and see. ;p
12:44:53 <amalloy> qeyoa: well, (EVAL y : c) occurs twice. the first time, on line 9, it is constructing a list; the second time, on line 13, it is pattern-matching against a list
12:44:54 <dminuoso> qeyoa: Yes. And you always pattern match using data constructors. So (:) must be a data constructor.
12:45:04 <dminuoso> qeyoa: (:) is the data constructor for lists.
12:45:09 <dminuoso> :t (:)
12:45:10 <lambdabot> a -> [a] -> [a]
12:45:51 <lyxia> suzu: http://lpaste.net/8567455957238415360#a362998 ?
12:46:51 <metahumor> dminuoso: i crashed yahb
12:46:56 <metahumor> with a sigsegv
12:46:57 <dminuoso> metahumor: Heh.
12:47:02 <metahumor> so, there ya go
12:47:24 <dminuoso> metahumor: I specifically mimiced the definition from GHC.Types in every way. :D
12:47:44 <dminuoso> Even the order of the data constructors, in case that was relevant.
12:48:14 <EvanR> somehow i am not confident in that tricks reliability
12:48:39 <dminuoso> EvanR: Just sneak it into the source code of GHC itself. If people start complaining, it wasn't reliable.
12:48:51 <EvanR> like, if this week ghc represents the ctors with numbers going one way, next week it changes it mind
12:48:57 <qeyoa> hm, but how is (EVAL y : c) working on a list, if the datatype is not a list: `data Op = EVAL Expr | ADD Int` and `data Expr = Val Int | Add Expr Expr`. Expr is not a list?
12:49:10 <dminuoso> qeyoa: you are pattern matching using two data constructors at the same time.
12:49:12 <suzu> lyxia: how does this work?
12:49:15 <dminuoso> qeyoa: let me rewrite slightly:
12:49:29 <suzu> what do `a` and `r` represent on the typeclass?
12:49:35 <dminuoso> qeyoa: exec ((EVAL y) : ys) n = ...
12:50:03 <lyxia> suzu: well in your expected results, magic (Funcify Int) :: Int -> ()
12:50:17 <lyxia> a = Int,  r = Int -> ()
12:50:41 <lyxia> in magic (Funcify (Int -> Int)) :: Int -> Int -> (),   a = Int -> Int,  r = Int -> Int -> ()
12:51:31 <lyxia> suzu: so you decompose that into two cases by "pattern-matching" on a
12:52:06 <lyxia> suzu: either a is a function type, (a = b -> a'), that's the second instance, or it's not a function type, that's the first instance.
12:52:16 <dminuoso> qeyoa: Specifically check the line 11. What's the type of the first argument?
12:52:22 <suzu> oh i think i understand!
12:52:23 <suzu> thank you so much
12:52:37 <suzu> so i needed a second typeclass param
12:52:43 <lyxia> suzu: the instances are allowed to overlap by the OVERLAPPABLE pragma, and it's guaranteed that if a is a function type the first instance will not be picked.
12:53:07 <lyxia> suzu: there are a few other ways to do that depending on your precise requirements
12:54:14 <lyxia> I can think of at least one with a single parameter class where "r" is instead defined as an associated type
12:54:20 <suzu> an associated type?
12:54:23 <suzu> you mean, with a typeclass?
12:54:47 <suzu> err type family
12:54:49 <suzu> *
12:55:32 <lyxia> yes
12:56:07 <qeyoa> dminuoso, so the 'c' in (EVAL y : c) might also be an `EVAL y`, or `ADD y`, it's just not being specifically patterned matched as that, so it's left as just `c`?
12:57:09 <suzu> something like `type RetType a = a -> ()` and then perhaps `magic :: Funcify a -> RetType a`
12:57:12 <suzu> ?
12:57:15 <lyxia> suzu: actually, it will probably have to be a closed type family (which is a different kind of type family than associated types)
12:57:23 <lyxia> yes something like that
12:57:50 <dminuoso> qeyoa: No.
12:57:55 <suzu> ah okay i think i have an idea of how to solve the rest
12:57:59 <suzu> thanks a lot for your help
12:58:11 <dminuoso> qeyoa: c definitely does not have the type Op.
12:58:21 <dminuoso> :t (:)
12:58:23 <lambdabot> a -> [a] -> [a]
12:58:56 <dminuoso> qeyoa: look at this type signature. If you ever see something of the shape `a : b`, then it means whatever the type of the LHS is, the RHS is a list of it.
13:00:04 <qeyoa> but `EVAL y` is type op
13:00:17 <qeyoa> how can c be not of the same type
13:00:19 <dminuoso> qeyoa: Now unify that knowledge with what I just said.
13:00:31 <dminuoso> (EVAL y) : c
13:02:09 <quchen> dminuoso: Noooo donâ€™t do it. Itâ€™s a terrible idea.
13:02:44 <dminuoso> quchen: What is?
13:02:58 <qeyoa> `exec :: CONT -> Int -> Int` takes a CONT type, which is a list of Op types, which can only be `EVAL x`, or `ADD x`?
13:03:24 * dminuoso silently crawls back
13:03:44 <quchen> UnsafeCoercing between things that do not necessarily have the same representation.
13:04:11 <quchen> null = unsafeCoerce :: [a] -> Bool
13:04:14 <quchen> Ummm no.
13:04:16 <dminuoso> quchen: You got it the wrong way around.
13:04:29 <dminuoso> quchen: I was using unsafeCoerce to see whether they had the same representation.
13:04:33 <qeyoa> so is my brain just not functioning tonight?
13:04:39 <dminuoso> It was serving no specific purpose other than curiosity.
13:04:46 <quchen> â€¦and then catch the segfault or what?
13:04:54 <qeyoa> i will try to stare at that code, maybe that will scare it into making me understand it
13:05:01 <qeyoa> :)
13:05:05 <dminuoso> 21:58        dminuoso | qeyoa: look at this type signature. If you ever see something of the shape `a : b`, then it means whatever the type of the LHS is, the RHS is a list of it.
13:05:10 <dminuoso> :t (:)
13:05:11 <quchen> GHC may assign arbitrary tags to data fields, I donâ€™t think there is a reason to maintain the order they had in the code
13:05:12 <lambdabot> a -> [a] -> [a]
13:05:51 <qeyoa> aaaaa
13:05:52 <qeyoa> ues
13:06:05 <dminuoso> qeyoa: `f x:xs = undefined` -- if x has type some arbitrary type `_a1`, then xs has [_a1]
13:06:12 <qeyoa> o remember, you cannot do 3 : 3, only 3 : [2,3]
13:06:16 <dminuoso> qeyoa: Right.
13:06:27 <qeyoa> thanks
13:06:58 <Tuplanolla> > [] : [] -- You can do this, though.
13:07:01 <lambdabot>  [[]]
13:08:05 <dminuoso> qeyoa: A more complete way of looking at [1,2,3] is: 1 : (2 : (3 : []))
13:08:10 <qeyoa> these `data` types mess my brain up, i'm not used to seeing something besides the x and xs
13:08:45 <dminuoso> qeyoa: Which shows this recursive nested structure that you can so neatly use for recursion. :)
13:09:30 <dminuoso> quchen: What is a "tag" ?
13:10:21 <quchen> dminuoso: Each constructor is distinguished by an integer tag during runtime.
13:10:34 <quchen> So in data Bool = True | False, True might get the tag 1, False the tag 2.
13:10:49 <quchen> And then GHC works with these tags, instead of matching e.g. on the constructor names.
13:10:54 <merijn> quchen: actually, GHC doesn't necessarily compile to tags at all iirc
13:11:20 <merijn> quchen: i.e. it might just replace the pattern match altogether and replace it with a CPS approach in some obscure corner cases, iirc
13:11:21 <quchen> merijn: It does not? It uses pointer tagging to hide the tags if you donâ€™t have many constructors, but I havenâ€™t heard of it not having them at all
13:11:58 <merijn> quchen: *most* cases will probably compile using tags, but that's DEFINITELY not guaranteed by Haskell, and afaik not even guaranteed by GHC itself
13:12:01 <quchen> GHC.Prim has functions to give you the tag of data even
13:12:09 <quchen> Sure, Haskell does not have any notion of a tag
13:12:24 <Tuplanolla> I once put identical data type definitions into two files, compiled each of them with different optimization options and coerced one into the other.
13:12:30 <Tuplanolla> The program promptly crashed.
13:13:13 <quchen> Yeah I once tried unsafeCoercing my way into the representation of a Data.Map to mess around, did not go well either
13:16:30 <pikajude> unsafeCoerce sounds like it could be pretty risky to use
13:18:45 <dminuoso> pikajude: and inlinePerformIO sounds fast!
13:18:47 <merijn> pikajude: Could be worse!
13:19:09 <merijn> pikajude: There's also names like "reallyUnsafePtrEquality"
13:19:54 <dminuoso> Or the magical accursedUnutterablePerformIO
13:20:15 <merijn> dminuoso: That's the old name of inlinePerformIO :p
13:20:37 <dminuoso> merijn: Ah! Heh.
13:20:57 <dminuoso> merijn: Well, the other way around based on the source code actually.
13:21:00 <merijn> "Haskell's so safe!" *proceeds to randomly coerce stuff at runtime*
13:21:53 <dminuoso> merijn: I remember during my first weeks I came in here, asked about: how to tell the type checker "shut up and trust me".
13:22:01 <dminuoso> 30 seconds later I was seg faulting GHCi.
13:22:34 * dminuoso felt so right
13:25:38 <wz1000> you pretty much need unsafeCoerce if you want to work with type level nats from GHC.TypeLits without a typechecker plugin
13:26:15 <suzu> i work with type level nats and don't use unsafeCoerce
13:26:47 <wz1000> you use a typechecker plugin?
13:35:55 <hololeap> trying to build conway's GoL with the Store comonad and UArray. working well, but i wonder if i have to include both the current array and the current (x,y) position in the Store, or if there's a way to implement it with just the array
13:37:19 <hololeap> my function that gets used by extend is: alive :: Store (UArray (Int,Int) Bool, (Int,Int)) (Maybe Bool) -> Bool
13:45:48 <EvanR> Store takes 1 type argument right
13:46:05 <EvanR> ah no nvm
13:51:38 <dminuoso> hololeap: The point of Store is to hide all that crap away.
13:52:12 <dminuoso> hololeap: So it would be `Store (Int, Int) Bool`
13:52:49 <hololeap> dminuoso: ah, ok. that's where my investigation was heading
13:55:01 <dminuoso> hololeap: Fundamentally the idea is: A Store is the most abstract notion of a "container", in that from the outside you just specify a position, and you get a value back
13:55:33 <dminuoso> hololeap: This gives you the freedom to pick different internal representations, switch them, materialize them
13:56:55 <hololeap> dminuoso: makes sense
14:18:12 <roconnor> ugh, I'm using UndecidableInstances.  I never should have touched the mtl.
14:20:02 <benzrf> :]
15:18:01 <jle`> wz1000: you do'nt necessarily need it directly if you use libraries that give you the proofs you need
15:18:07 <jle`> using it direclty is kind of a bad thing anyway
15:29:33 <parsnip0> > print "<IO ()>"
15:29:35 <lambdabot>  <IO ()>
15:29:45 <parsnip0> tests passed
15:31:03 <jle`> any nice way to represent a function that return a (Either b (String -> b))
15:31:19 <jle`> a 'b' that *may* need some input string or may not, and the function chooses which
15:35:06 <jle`> context: the string comes from IO and i don't want to involve lazy IO
15:36:35 <glguy> jle`: What's wrong with your solution using either that you have there?
15:37:41 <jle`> nothing particularly wrong, and i think any solution would be algebraically isomorphic to it.  it's what i'm using for now
15:37:59 <jle`> just wondering if there are any known abstractions that already deal with such things
15:38:43 <glguy> stream processors like machines pipes etc deal with the more general case of computation that might need Strings and might produce bs
15:42:43 <jle`> hm, thanks
15:46:06 <typedrat> I don't understand how a type *synonym* can be impredicative.
15:46:24 <typedrat> You could instantiate it in an impredicative way, of course
15:46:44 <typedrat> but to not let you define a synonym that could potentially become an impredicative type is a bit... overkill, IMO.
15:58:02 <hpc> i was about to say type synonyms don't even have kinds, but i guess they do
15:58:06 <hpc> even if you can't partially apply them
16:07:55 <EvanR> :k Iso
16:07:57 <lambdabot> * -> * -> * -> * -> *
17:27:48 <bobajett> hello, I have an embarrasingly basic question about function composition:
17:28:09 <bobajett> http://lpaste.net/363001
17:32:03 <jle`> bobajett: you could just define a value using guards
17:32:44 <jle`> i'm not really sure what functions you are 'composing' in that example
17:33:01 <jle`> oh i see, you're doing successive mutations
17:33:33 <jle`> in this case you can use 'all' maybe, to filter for items matching all given predicates
17:35:23 <jle`> :t \ps -> filter (\x -> all ($ x) ps)
17:35:25 <lambdabot> Foldable t => t (a -> Bool) -> [a] -> [a]
17:35:37 <bobajett> I guess my question is both about successive mutation and how to invoke functions conditionally. In other words,
17:35:38 <jle`> replaces ps with your list of predicates
17:35:53 <jle`> 'invoke functions conditionally' is just 'defining functions'
17:35:57 <jle`> since functions are first-class in haskell
17:36:14 <jle`> you can just return a function depending on certain conditions
17:36:27 <jle`> one way is to just define a filter function, (Employee -> Bool)
17:36:37 <jle`> and then in the end you just filter your list with that (Employee -> Bool) function
17:36:41 <bobajett> if I was always given those criteria, I could just do (f1 . f2. f3). But based on the criteria, I sometimes only want to do (f1 . f3) or (f2 . f3)?
17:36:55 <jle`> bobajett: if x then (f1 . f3) else (f2 . f3)
17:37:03 <jle`> where x is some bool
17:37:40 <jle`> > (if True then (negate . (*2)) else (negate . (/2))) 10
17:37:42 <lambdabot>  -20.0
17:37:46 <jle`> > (if False then (negate . (*2)) else (negate . (/2))) 10
17:37:48 <lambdabot>  -5.0
17:37:56 <jle`> functions are just values
17:38:35 <bobajett> but how do I do this generally, so how would I do it if I have a list of 10 such filter criteria?
17:38:49 <jle`> you could build a list of the functions you want to combine
17:38:58 <jle`> and then use concat or all on that list
17:39:08 <bobajett> ah ok, that makes sense.
17:39:24 <jle`> that list building, you'd only add the functions you'd want to combine, maybe
17:39:39 <jle`> there's actually some nice syntax for that using list comprehensions
17:40:10 <jle`> :t [ negate | True ] ++ [ (*2) | False ] ++ [ (/2) | True ]
17:40:12 <lambdabot> Fractional a => [a -> a]
17:40:39 <jle`> :t concat [ [ negate | True ], [ (*2) | False ], [ (/2) | True] ]
17:40:40 <lambdabot> Fractional a => [a -> a]
17:41:01 <bobajett> so the problem basically breaks down into: given n different criteria, filter your list of predicate functions and then just simply compose that filtered list of functions?
17:41:35 <jle`> yeah, but in this case you might want to just use all
17:41:37 <jle`> instead of composition
17:41:50 <bobajett> how do I use all?
17:41:58 <jle`> and, not really filter your list of predicate functions, but generate your list of predicate functions conditionally
17:42:06 <jle`> :t all
17:42:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:42:31 <jle`> :t \x -> all ($x) [(< 5), (== 0), (> 2)]
17:42:32 <lambdabot> (Num a, Ord a) => a -> Bool
17:42:59 <jle`> all returns True if some function is True for every item in the list
17:43:31 <jle`> so if you have some list of predicates ps, (\x -> all ($x) ps) will be a function that returns True if an item 'x' matches every predicate
17:44:09 <bobajett> cool, thank jle` I think that helped me get over my mental block. I'll try this out.
17:44:22 <jle`> no problem :)
18:06:18 <suzu> lyxia: what is the use of the `r ~ (b -> r')` on your annotation?
18:06:25 <suzu> http://lpaste.net/8567455957238415360
18:06:55 <suzu> why does `(Test a r') => Test (b -> a) r'` not work?
18:07:17 <suzu> err sorry
18:07:29 <suzu> `(Test a r') => Test (b -> a) (b -> r')`
18:11:46 <suzu> (or if anybody else might know why that's needed)
18:12:54 <MarcelineVQ> possibly suzu: https://chrisdone.com/posts/haskell-constraint-trick
18:13:53 <pikajude> the haddock parser is fucked, isn't it
18:14:08 <pikajude> if a code block line starts with ">", html entities won't be decoded
18:16:46 <c_wraith> suzu, because it's awkward to ask ghc to prove two type variables are the same thing before a pattern can match. it's much easier to tell it to enforce that after the fact.
18:18:03 <c_wraith> suzu, that means it can put off that check until it actually had enough information, instead of trying to resolve it eagerly (and often coming to the wrong conclusion due to lack of information)
18:19:41 <shapr> Will the value of the GHCRTS environment variable be used by GHC inside cabal new-build?
18:25:40 <hisoka> Does anyone know how one could compute ALL the possible subgraphs from a graph? I have all the edges [(a,b) .. ] and vertices  [1.. n] set up already but can't figure out how I could do this..
18:26:32 <shapr> hisoka: are you using FGL or what?
18:26:35 <suzu> oh hmm i see
18:27:14 <hisoka> I am implementing my own version of graphs using Maps and Lists..
18:27:27 <shapr> hisoka: whatever you're using, wouldn't it be the powerset of the graph, minus the actual graph?
18:28:15 <mud> hisoka: Pick all possible subsets of the verticies. Then for each of those, pick all possible subsets of the edges (that only involve chosen verticies). All-possible-subsets you can either do recursively "well I can pick X or not pick X, for each choice I recurse on a smaller problem of the same type" or you can come up with a binary number of length N for a set of length N, and just increment it. Each bit stands for one element of the original set. If it'
18:28:17 <mud> s a 1, you include it, if it's a 0, you don't.
18:29:17 <shapr> mud: ok, that's a much better answer
18:29:50 <shapr> mud: why the nick change?
18:30:37 <mud> I kind of switch back and forth, heh. Got this one a while back, I use this elsewhere but never could get it here.
18:35:07 <shapr> Is there something less verbose than HSpec that handles both unit tests and property based quickcheck/hedgehog tests?
18:49:17 <suzu> ok i'm stumped :/
18:49:22 <suzu> is this even possible to design?
18:49:23 <suzu> http://lpaste.net/7658369929392947200
18:51:34 <suzu> oh! yeah i think i thought of a way
20:23:30 <sqooq_> I'm trying to have in the types somehow the sampling rate of signals, that way incompatible signals are type errors, but I'd also like to be able to recover the sampling rate and use it.
20:24:04 <sqooq_> so I've been trying to do this phantom type nonsense, which I got working once using Proxy, but I can't remember how and I can't seem to replicate it
20:24:07 <sqooq_> can anyone help me.
20:32:44 <jackdk> sounds like you need singletons for that, to give you a value-level witness for the phantom type?
20:33:10 <sqooq> perhaps
20:33:30 <sqooq> https://hackage.haskell.org/package/singletons
20:33:32 <sqooq> ???
20:33:45 <jackdk> yeah
20:33:47 <sqooq> >dependently typed
20:33:51 <sqooq> should I just switch to idris
20:33:52 <jackdk> have a look at https://blog.jle.im/entry/introduction-to-singletons-1.html
20:33:57 <jackdk> I don't know idris
20:34:25 <jackdk> and https://blog.jle.im/entry/introduction-to-singletons-2.html
20:35:31 <sqooq> ugh stupid weechat
20:35:43 <sqooq> can't click on link
20:35:50 <sqooq> can't figure out how to select text
20:36:15 <Welkin> sqooq: haskell has dependent types using singletons
20:36:22 <Welkin> and will have full dependent types soon
20:36:35 <sqooq> how soon
20:36:56 <sqooq> thanks y'all btw
20:36:59 <sqooq> i'll read up on it
20:37:08 <sqooq> right now
20:37:12 <Welkin> nothing is set
20:37:20 <Welkin> I'd imagine within 2 more releases
20:37:47 <sqooq> will their be major changes in order to support that
20:37:51 <sqooq> there*
20:37:51 <Welkin> https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
20:38:00 <Welkin> "The short answer: GHC 8.4 (2018) at the very earliest. More likely 8.6 or 8.8 (2019-20)."
20:38:06 <sqooq> i hate weechat
20:38:28 <jchia> I have some complicated types in my project involving things like type-level lists of Symbol that I suspect are really slowing down the compilation. Are there general tips on how to reduce compilation time? Right now, ghc has run for 10 minutes and has 19GB resident.
20:41:28 <suzu> more modules?
20:43:12 <jchia> suzu: How does using more modules help? Less attempts by ghc to do whole-program optimization?
20:43:38 <jchia> I mean clean build time, not incremental build time after some small change.
20:44:40 <suzu> i believe GHC can then do more parallel compilation
20:45:11 <jchia> OK
20:54:46 <jchia> Are there ways to make stack check the code (especially for type errors) only instead of actually building?
20:55:39 <jchia> I'm hoping to reduce my edit-build cycle time because every build takes forever.
20:56:06 <jchia> So my development becomes very slow.
20:59:34 <ab9rf> use smaller compliation units
21:00:08 <ab9rf> and more processors
21:00:27 <jchia> ab9rf: compilation unit =?= module?
21:00:45 <jchia> package?
21:00:54 <inkbottle> Could not find module â€˜System.Processâ€™: How do I quickly find the package to install? Command line hoogle doesn't seem to answer that sort of question.
21:01:24 <ab9rf> the compilation unit in haskell is "file" and i'm fairly certain there's a one to one relationship between modules and files
21:01:37 <ab9rf> well, in ghc at least
21:02:26 <ab9rf> if you ahve a really large module, split it into multiple modules and import
21:04:56 <jchia> ab9rf: A module can be small but complicated and hence take a long time to compile, right?
21:05:52 <EvanR> complicated?
21:06:17 <jchia> EvanR: E.g. having complicated type-level stuff and hence time-consuming to compile
21:06:47 <jchia> 'small' as in LOC vs complexity from language features
21:07:13 <EvanR> if you want it to take even longer, use TH and Generics
21:10:01 <suzu> is there a way to force a type argument to be monomorphic
21:10:48 <suzu> seems like KnownNat only works if the proxy is monomorphic
21:12:55 <suzu> and that makes this not work :(
21:12:57 <suzu> numArgs :: (KnownNat (Arity a)) => JSCallback a -> Integer
21:12:59 <suzu> numArgs _ = natVal (Proxy :: Proxy (Arity a))
21:16:53 <inkbottle> I have my answer, got to do `hoogle --info System.Cmd` to get the package name.
21:23:13 <jchia> suzu: This seems to type-check for me: http://lpaste.net/363002
21:24:19 <jchia> inkbottle: --info gives detailed info on the first match. When I get multiple matches, I don't know how to query in such a way that the result I want becomes the first match.
21:24:28 <jchia> So I usually use the web hoogle
21:24:42 <inkbottle> OK
21:25:08 <jchia> suzu: Not sure what your Arity and JSCallback look like, so I'm not sure what problem you're talking about.
21:25:24 <suzu> hmm i see you've got an explicit forall
21:25:31 <inkbottle> so I got lucky this time
21:25:32 <suzu> does your code typecheck without that?
21:25:56 <jchia> No
21:26:11 <jchia> suzu: There's some complicated story about how ScopedTypeVariables interacts with the need for forall
21:26:14 <jchia> I forgot the details.
21:26:16 <EvanR> suzu: if you're using ScopedTypeVariables, they are only brought into scope using forall
21:26:31 <EvanR> otherwise, type a in the body is a different a as the signature
21:27:01 <suzu> oh im an idiot
21:27:13 <suzu> i forgot about that. adding the forall solved the problem
21:27:15 <suzu> thanks a lot
21:27:27 <EvanR> and the error will be something super understandable like "can't match 'a' and 'a1'"
21:27:42 <suzu> that is the error i had and i did not understand what was going on
21:28:03 <jchia> EvanR: Sometimes when I write Haskell code, I seem to be relying on intuition, I wonder if it's too much. I just put a forall intuitively without even thinking about why. I wonder if it's a good thing.
21:28:16 <suzu> i had thought scopedtypevars would be unifying it and so i figured something was up with typelits
21:28:21 <suzu> arrgh
21:28:26 <EvanR> jchia: i understand your concern
21:28:59 <EvanR> its like driving with a blindfold on through a familiar road... you can get there but somethings not right :)
21:29:04 <jchia> EvanR: I just had an urge to put that forall. I didn't think about the reason you stated.
21:29:26 <suzu> outer-level foralls don't do anything except bring vars into scope
21:29:32 <suzu> so.. i never write them
21:29:48 <EvanR> thats the only time you need them
21:29:49 <suzu> only if i'm working with rankntypes will i have something like that :/
21:31:59 <suzu> man, how is GHC so good
21:41:25 <boj> f :: (MonadReader n, Monad m) => ReaderT Context n a -> m a -- if i runReaaderT inside f my constraints don't work. what am i looking for here?
21:41:53 <boj> is this where one uses hoist from mmorph?
22:01:58 <boj> ah, disregard. i was on the wrong tracl
22:18:30 <guest>  I am using https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html this library for Public Key generation, the toPublic Function returns PublicKey for given SecretKey, something like this (PublicKey "\134M\130F\142\CAN\190\v,\228\190\232v\171\243]5\CAN\t\211\151\DC1]\188\t\206\233k\190\237\218>"  what is format of string "\134M\130F\142\CAN\190\v,\228\190\232v\171\243]5\CAN\t\211\151\DC1]\188\t\206\233k\1
22:18:33 <guest> else
22:18:36 <guest> ?
22:19:26 <EvanR> \134 is unprintable character number 134
22:19:46 <EvanR> each one is less than 256, its a string of bytes
22:20:21 <EvanR> probably ByteString
22:22:20 <guest> EvanR: can i convert this to  hex and back to this from hex?
22:22:38 <EvanR> sure
22:23:12 <EvanR> though there is no ready made built in function for it
22:24:16 <EvanR> > concatMap (printf "%02x") ("hello world" :: ByteString) :: String
22:24:18 <lambdabot>  error:
22:24:18 <lambdabot>      Not in scope: type constructor or class â€˜ByteStringâ€™
22:24:18 <lambdabot>      Perhaps you meant one of these:
22:27:58 <guest> EvanR : any idea how to do that ?
22:28:49 <EvanR> begin by writing the type of the function you want
22:59:10 <jle`> all of the generics-based/th-based diffing libraries no longer build with modern ghcs
22:59:25 <jle`> rather than try to patch them i have a desire to write my own
22:59:31 <jle`> i need to re-evaluate my priorities
22:59:45 <cocreature> jle`: have you seen phadejâ€™s tree-diff lib?
23:00:01 <jle`> tree-diff is great but i also have to apply diffs
23:00:12 <jle`> i was just going to write a version based on tree-diff but with diff application
23:00:18 <cocreature> ah yeah then it wonâ€™t help
23:00:38 <jle`> i don't know if there is anything fundamentally preventing this
23:01:00 <jle`> it might not just have been a priority of tree-diff
23:01:28 <jle`> actually i wonder if it wouldn't be too hard to just extend tree-diff to give patch application
23:06:47 <jle`> hm, it actually might not be
23:07:12 <jle`> but would i rather try to understand someone else's library enough to make a significan change and help the ecosystem, or would i rather disrupt the ecosystem by writing one from scratch?
23:08:03 <cocreature> obviously the latter! helping the ecosystem? boring!
23:08:46 <jle`> move fast and break things!
23:08:48 <[exa]> wow, tree-diff usage seems like wdiff on steroids
23:10:15 <cocreature> if you donâ€™t need diffing, tree-diff is amazing
23:10:41 <cocreature> eh s/diffing/patching/
23:10:44 <[exa]> lol
23:10:58 <cocreature> itâ€™s still early here!
23:11:15 <[exa]> jle`: btw what's your use case for patching?
23:11:36 <jle`> i uh want to merge changes to pandoc documents
23:12:17 <jle`> for the past year i've been using a rudimentary hobbled-together haskell project to sync pandoc documents of different formats
23:12:37 <jle`> since i want to use markdown to write my papers and my advisor will only edit MS word documents
23:13:22 <jle`> the only solution was to build a whole sync system i guess
23:13:40 <jle`> before it has just been destroying files if there are conflicts but i wanted to make it more robust and try to merge changes
23:15:56 <[exa]> can you losslessly convert markdown->word->markdown ?
23:16:14 <jle`> not losslessly
23:16:19 <jle`> but it's usable if you understand the limits
23:16:31 <jle`> oh sorry, actually, yes more or less losslessly
23:16:50 <jle`> or actually no, not losslessly
23:16:51 <[exa]> except for msword mess, ofc :]
23:16:59 <jle`> you do lose things like anchor names
23:17:13 <jle`> footnotes might be obliterated
23:17:22 <jle`> but yeah, usable if you understand the limits, heh
23:18:02 <nshepperd> that sounds... pretty scary!
23:18:04 <[exa]> so you'll convert markdown->word->markdown then markdown->word->advisor->markdown and run the diff on the result?
23:18:57 <[exa]> (and try to backport it to original markdown)
23:19:13 <jle`> well how things actually worked was that the system kept track of a canonical Pandoc document (the universal AST the library parses documents into)
23:19:34 <jle`> and if any of the files were updated, it would overwrite the older files with the contents of the new pandoc document
23:19:46 <jle`> and it would try to preserve formatting in cases like ms word documents, which is possible with the library
23:20:19 <[exa]> scary.
23:20:21 <jle`> so the library actually managed a canonical pandoc document that all manifestations would be translated through
23:20:32 <jle`> the only thing i'm using diffing here now is for conflict resolution
23:21:26 <jle`> day-to-day it hasn't been too bad :)  i actually ended up using it for many other things too after making it
23:21:33 <[exa]> can't you make him to edit it in e.g. some online markdown tool?
23:22:10 <jle`> never fix with a social solution what can be fixed with a technological solution
23:22:17 <jle`> um i think that's how the saying goes
23:22:52 <[exa]> depends on whether 'nuking all ms word instances from orbit' is technical
23:24:15 <[exa]> ok back to the original problem; tree-diff is only working with AST so the patches would need to be AST-level, probably not very directly portable to the haskell environment
23:24:31 <jle`> but anyway i actually saw that there's an open issue in the pandoc issue tracker from people who want to be able to diff pandoc documents, so maybe writing a library for pandoc diffing would be helpful to many parties
23:24:52 <[exa]> yeah that would be better, you wouldn't need to be generic over all types, just over pandoc
23:24:58 <jle`> gross
23:25:01 <jle`> that is not the Haskell Way
23:25:39 <jle`> all joking aside though the pandoc ast is pretty complex and i don't really envy any efforts to do such a thing by hand
23:26:02 <[exa]> not very complicated imho, just a terrible amount of cases for all the syntax elements
23:26:11 <jle`> so writing a generic version and applying it to pandoc ast is probably faster
23:26:20 <jle`> not complicated from a conceptual standpoint
23:26:29 <jle`> but from yes, many constructors
23:26:37 <jle`> and many enumerable data types
23:26:51 * [exa] afraid that generic version will require lots of lenses or TH
23:26:56 <[exa]> hm lenses.
23:27:43 <jle`> well generics would be used for the purpose of avoiding TH
23:27:51 <pavonia> On Windows, is hLookAhead supposed to do newline conversion in non-binary mode, i.e. return '\n' when the next chars are "\r\n"?
23:28:19 <jle`> i don't think lenses would make things too much easier; but it'll probably involve some amount of type-level programming, if the implementation of gdiff is any indication
23:28:29 <[exa]> jle`: can you take apart a _generic_ type?
23:28:42 <jle`> yes, that's the point of GHC.Generics :)
23:29:08 <jle`> to be able to work with any ADT as if it was just made up of a couple of known constructors from GHC.Generics
23:29:34 <jle`> be able to treat any ADT as just a simple normal-haskell either's and tuple's, essentially
23:29:53 <ekr_> greetings, is it possible to have a main function with a different name? I can't seem to find any resources to tell me how to do that.
23:30:21 <jle`> ekr_: do you mean have a different IO action run when compiled as an executable?
23:30:29 <[exa]> jle`: oic that would probably work
23:30:49 <ekr_> exactly, i can't seem to understand how xmonad does it.
23:30:50 <jle`> ekr_: 'main' is not a function btw
23:31:05 <[exa]> and there won't be type problems because you will be diffing same types
23:31:14 <ekr_> i know
23:31:37 <cocreature> ekr_: afaik thatâ€™s not possible
23:32:18 <jle`> you might be able to use some TH or something to generate a defintiion 'main = someOtherIOAction'
23:32:18 <cocreature> ekr_: xmonad still requires that you define a "main" function iirc
23:34:06 <ekr_> cocreature: you're right, thanks
23:37:13 <yushyin> http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--main-is%20%E2%9F%A8thing%E2%9F%A9 ?
23:37:42 <jle`> yushyin: they left :o
23:37:47 <yushyin> oh
23:38:07 <yushyin> too bad
23:38:21 <[exa]> jle`: do Generics support list-like generic stuff?
23:38:57 <jle`> hm, how do you mean?
23:39:35 <jle`> one of the basic constructors is a recursive one
23:40:11 <[exa]> there are lists of blocks, lists of inlines and when doing a diff you want to run some kind of diff algorithm on those (levenshtein or something)
23:40:27 <[exa]> so you'll need to be able to detect list-like stuff among generics
23:40:50 <[exa]> (I'm reading Generics for the first time so maybe it's trivial)
23:41:01 <jle`> hm tree-diff handles it nicely
23:41:40 <cocreature> if you want to use generics I highly recommend taking a look at generics-sop instead of trying to figure out GHC.Generics
23:48:42 <cocreature> [exa]: tree-diff works by converting types to Expr first https://hackage.haskell.org/package/tree-diff-0.0.1/docs/Data-TreeDiff-Expr.html#t:Expr using the ToExpr class. the instance for [a] takes care of converting to "Lst" but you can ofc define similar instances for other list-like types
23:53:16 <[exa]> good
23:53:37 <[exa]> btw thanks for generics-sop, going to use it for another thing here
23:56:28 <jle`> [exa]: generics-eot is also another easily digestable high-level API for GHC.Generics
23:56:44 <jle`> one nice advantage is that it actually uses Either and tuples instead of type-level lists
23:57:13 <jle`> er, heterogenous lists
23:58:07 <cocreature> the hlists are whatâ€™s great about generics-sop :)
