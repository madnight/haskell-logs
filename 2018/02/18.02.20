00:00:47 <^Jamssi^> aaah, so the [Field] it was pointing to was "record", and it was pointing to "records" which is [Record]. I was assuming that the error was more about the signature of [Record] -> [Field]
00:01:28 <^Jamssi^> thanks a lot cocreature
00:36:35 <aebooth> I'm new to IRC--how do I get to the right discussion or ask a question?
00:36:59 <cocreature> aebooth: do you have a Haskell question?
00:37:05 <aebooth> yes
00:37:13 <cocreature> then just ask here and stick around for a bit
00:37:20 <aebooth> thanks!
00:37:26 <arne_> if i have something like isPrime n = length $ filter (\x -> (rem n x) == 0) [1..n-1]
00:37:30 <arne_> how would i add == 0
00:37:37 <arne_> without adding parent
00:37:39 <arne_> hs
00:38:39 <arne_> or easier example: rem 5 3 == 0
00:38:46 <arne_> how do i stop == to binding to "3" without ()
00:38:49 <cocreature> isPrime n = (0==) . length $ filter (\x -> rem n x == 0) [1..n-1]
00:39:02 <cocreature> == doesn’t bind to 3
00:39:06 <arne_> cocreature: well okay, i understand this one, is there a better way?
00:39:19 <cocreature> not sure what you’re looking for
00:39:26 <arne_> way to write code without ()
00:39:31 <cocreature> avoiding parenthesis is also not a useful goal in itself
00:39:32 <arne_> your version makes it lkess readable
00:39:38 <aebooth> I'm wanting to make a basic haskell app that's not just a prime number solver or like towers of hanoi
00:39:40 <arne_> cocreature: i know, but it might be
00:39:48 <aebooth> Where is the best place to start?
00:39:49 <cocreature> avoiding parenthesis often does make code less readable
00:39:50 <arne_> aebooth: go ahead then?
00:39:54 <dminuoso> Oi arne_ o/
00:39:56 <arne_> cocreature: in some cases
00:39:58 <arne_> dminuoso: hi!
00:40:06 <arne_> trying to learn haskell again, because work sucks
00:40:14 <dminuoso> arne_: Yet another refugee from #ruby :)
00:40:21 <arne_> you know me already from another nick :)
00:40:32 <Bish> well, i don't know if you remember
00:40:39 <Bish> but you might
00:40:52 <Bish> dminuoso: haskell is great, but i can't quite get my hand around it
00:40:54 <dminuoso> Bish: Of course. Nothing escapes me.
00:41:21 <Bish> wanted to skip learning haskell, then i saw it's possible to do something like
00:41:37 <kuribas> Bish: you need a bigger hand...
00:41:44 <Bish> [x | x <- [0..], y <- [0..x], somethingWith y]
00:42:00 <Bish> kuribas: there are benefits, some bodyparts look bigger
00:42:34 <kuribas> Bish: it's normal, learning haskell takes time.
00:42:46 <kuribas> Bish: in fact, you never stop learning :)
00:43:04 <Bish> when it comes to languages or programming itself.. my motivation is endless, but haskell takes alot of effort for me
00:43:09 <kuribas> In the good way, like there is alway more awesome stuff.
00:43:13 <dminuoso> A programming language that broadens your horizon is worth learning.
00:44:39 <kuribas> Bish: have you ever tried prolog?
00:44:46 <Bish> kuribas: in university, yes
00:45:19 <kuribas> you don't just learn a new language, but also new concepts.
00:45:46 <kuribas> The challenge is learning to think in a new way.
00:46:06 <kuribas> And after you, do it becomes natural and obvious.
00:46:16 <kuribas> So obvious you wonder how you could ever program differently....
00:48:25 <Bish> primes = [x | x <- [1..], length (filter (\a -> (rem x a) == 0) [2..x-1]) == 0]
00:48:28 <Bish> having this code
00:48:31 <dminuoso> kuribas: The main issue for me is that when I learned Haskell, I started to begin to realize the shortcomings of languages that lack truly powerful type systems.
00:48:38 <Bish> does haskell always evaluate everything of the lambdah
00:48:54 <Bish> or can it optimize that out (unlikely)
00:48:59 <Bish> lambduh'
00:49:15 <kuribas> dminuoso: exactly
00:49:42 <kuribas> Bish: haskell is lazy...
00:50:09 <Bish> yeah, still, to know if the list is empty, it might not stop after it knows that
00:50:14 <kuribas> Bish: don't use length l == 0, use null instead
00:50:22 <kuribas> Bish: or better, pattern match
00:50:34 <Bish> kuribas: how would my example look?
00:50:45 <cppxor2arr> Bish: you could do "null list" instead of "length list == 0"
00:50:51 <Bish> :t null
00:50:52 <kuribas> Bish: quadratic...
00:50:53 <lambdabot> Foldable t => t a -> Bool
00:52:07 <dminuoso> Bish: Normally haskell does not fully evaluate either, instead it keeps expressions in weak head normal form
00:52:22 <dminuoso> Which is why you can work with infinite lists
00:52:42 <Bish> but something like "(length infiniteList) == 0"
00:52:52 <Bish> won't stop searching after the first, does it?
00:52:52 <dminuoso> >> take 10 (zipWith (+) [1..] [10..])
00:52:58 <dminuoso> > take 10 (zipWith (+) [1..] [10..])
00:53:00 <lambdabot>  [11,13,15,17,19,21,23,25,27,29]
00:53:16 <cppxor2arr> from the front page of haskell:
00:53:18 <cppxor2arr> primes = filter_prime [2..]
00:53:19 <cppxor2arr>     where filter_prime (p:xs) = p : filter_prime [x | x <- xs, x `mod` p /= 0]
00:54:35 <dminuoso> Are there places in Haskell where evaluation takes place beyond WHNF?
00:55:06 <Bish> dminuoso: is there are way to inspect haskell "variables"
00:55:12 <Bish> while being in a "loop"
00:55:25 <cppxor2arr> loops in haskell?
00:55:34 <Bish> cppxor2arr: i know man, that what the quotes are for
00:56:20 <Bish> dminuoso: in ruby i would just add a (p x) before it to inspect
00:56:30 <dminuoso> :t trace
00:56:32 <lambdabot> error: Variable not in scope: trace
00:57:01 <dminuoso> Bish: Ah well. You can use Debug.Trace - but you should understand the basic execution model. It's entirely possible that the code will never be run. Or run multiple times.
00:57:38 <Bish> Could not find module ‘Debug’
00:57:39 <Bish> :(
00:58:06 <dminuoso> Bish: You have to import Debug.Trace first
00:58:12 <dminuoso> https://hackage.haskell.org/package/base-4.10.1.0/docs/Debug-Trace.html
00:58:18 <Bish> that's where i got that message from
00:59:36 <quchen> dminuoso: Beyond WHNF? Depends on the context. At the core level, all evaluation is triggered by »case«, and case does only WHNF.
01:00:05 <Bish> Debug.Trace is great, thanks
01:00:33 <Bish> but i can't let it print nothing, conditionally
01:00:46 <dminuoso> Bish: Yes you can.
01:01:03 <Bish> but outside of it i guess
01:01:33 <quchen> cppxor2arr: Sure, Haskell has loops. main = fix (\loop -> putStrLn "Hello World" >> loop)
01:01:33 <dminuoso> :t when
01:01:34 <lambdabot> Applicative f => Bool -> f () -> f ()
01:02:08 <Bish> yeah i remember when
01:02:10 <dminuoso> Bish: ^- this combinator is what you could use, or just manual `if (...) then (...) else pure ()`
01:02:26 <Bish> okay, thanks! cool
01:02:40 <quchen> cppxor2arr: Recursion is strictly more powerful than iteration, so we can (easily, even) implement it.
01:02:59 <cppxor2arr> quchen: huh interesting
01:03:06 <Bish> but turns out, haskell is not clever to fix my bad code
01:03:38 <Bish> it walks to the end of the list to check if it's empty
01:04:27 <Bish> even with null
01:06:13 <amalloy> Bish: null does not force any more than one element of a list
01:06:34 <quchen> > null [1..]
01:06:36 <lambdabot>  False
01:07:11 <quchen> > null [error "oops"]
01:07:13 <lambdabot>  False
01:07:16 <Bish> oh, oh wow, it does
01:07:18 <Bish> sick
01:07:29 <Bish> that's crazy
01:07:40 <Bish> it might even fix code you didn't know it was stupid
01:07:43 <Bish> lazy eval ftw
01:10:32 <quchen> Well, if you want to see whether the cookie jar is empty, you don’t need to inspect all the cookies. You can stop as soon as you see one.
01:10:51 <Bish> yeah i got that, i mean i wondered if haskell does
01:11:29 <AspiringPotato> Hi guys, so lately I found myself writing a particulary ugly piece of code and I was wondering whether someone could point me to a nicer way of writing it. It's just 8 lines of code http://lpaste.net/4645738623684050944
01:11:55 <Bish> but it seems even to work with == 0
01:13:20 <dminuoso> quchen: What about IO's >>=? Doesn't that necessarily force evaluation as well?
01:14:15 <mniip> only of the actions
01:14:19 <mniip> not the returned results
01:14:30 <mniip> % return undefined >> return ()
01:14:30 <yahb> mniip:
01:14:55 <quchen> AspiringPotato: Step 1, give things names longer than one letter.
01:14:56 <quchen> http://lpaste.net/362684
01:15:22 <quchen> dminuoso: Sure, because it’s broken down to case.
01:15:40 <Bish> can ghci also show me the definition of a funcion, not only type?
01:15:45 <quchen> dminuoso: Core does not have IO, just a very small functional language with a handful of primitive values.
01:15:52 <quchen> Bish: Nope.
01:16:01 <Bish> :( that's sad
01:16:10 <cppxor2arr> there's hoogle
01:16:16 <quchen> Lambdabot has a static DB for function definitions though.
01:16:18 <quchen> ?src filter
01:16:18 <Bish> well, what if im offline
01:16:18 <lambdabot> filter _ []     = []
01:16:19 <lambdabot> filter p (x:xs)
01:16:19 <lambdabot>     | p x       = x : filter p xs
01:16:19 <lambdabot>     | otherwise = filter p xs
01:16:37 <Bish> ?src $
01:16:38 <lambdabot> f $ x = f x
01:16:41 <Bish> ?src .
01:16:42 <lambdabot> (f . g) x = f (g x)
01:16:45 <cppxor2arr> ?src head
01:16:46 <lambdabot> head (x:_) = x
01:16:46 <lambdabot> head []    = error "Prelude.head: empty list"
01:17:17 <cppxor2arr> ok i'll be playing around a bit with lambdabot (src) in pm
01:19:21 <raduom> Hi everyone. There is this function I wrote that looks really bad and I am constantly failing to refactor. Can someone give me a helping hand with it?
01:21:22 <Akii> raduom just post that function on lpaste.net or smth
01:21:41 <raduom> https://github.com/raduom/reagan/blob/master/app/Main.hs // singleTest
01:26:41 <raduom> The problem as I see it, is that I should use something that makes the pattern matching go away. But when I try to use anything (like fmap, or MaybeT) the code ends up looking fairly bad. I am pretty sure there has to be a simpler way of writing it, but my imperative brain won't let me see it.
01:29:01 <Boarders> if I stack install something then should I be able to just import it in a ghci session?
01:30:26 <ventonegro> Boarders: `stack install` does not install packages, it copies executables to `~/.local/bin`
01:30:38 <Boarders> oh ok, so I should cabal install if I want to do that
01:30:47 <barrucadu> raduom: The case expression on lines 79 to 81 can be rewritten as `return (compiledProgram, maybeExecution)`, as you're pattern matching on `maybeExecution` and then immediately reconstructing it
01:30:59 <Boarders> what is the point of stack install exactly? Does it just mean that any project I build will not have to re-download the package?
01:31:04 <ventonegro> Boarders: Or you can run `stack ghci` in the context of your project
01:31:49 <raduom> barrucadu: yes I noticed that, what about the previous things?
01:31:52 <ventonegro> Boarders: I use `stack install` for things like pandoc. hakyll, idris, steeloverseer i.e. programs I run
01:32:00 <vaibhavsagar> Boarders: I find it's only useful when a package has an executable
01:33:50 <Boarders> ok cool, I was using it to install Shake
01:35:29 <kuribas> raduom: "case x of Nothing -> return Nothing; Just x -> Just $ f x" -> "traverse f x", or "for x $ f"
01:36:03 <kuribas> raduom: Maybe is traversable
01:36:08 <Boarders> is there any way to start a new stack project within an existing directory?
01:36:24 <raduom> kuribas: thanks. that is what I am looking for. I think. I'll check :)
01:36:48 <raduom> kuribas: that is the code part that looks really bad to me.
01:36:58 <sm> https://docs.haskellstack.org/en/stable/GUIDE/#stack-init
01:37:47 <raduom> kuribas: is there a bias against using for in Haskell?
01:37:52 <kuribas> raduom: for maybeGeneratedProgram $ \generatedProgram -> do ...
01:37:55 <kuribas> raduom: no
01:38:04 <kuribas> not that I know of...
01:38:50 <kuribas> :t for (undefined :: Maybe a)
01:38:52 <lambdabot> Applicative f => (a -> f b) -> f (Maybe b)
01:40:09 <merijn> :t for
01:40:11 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
01:40:54 <merijn> oh, so that's just forM
01:41:05 <Boarders> with something like shake where I am just building a makefile and not using lots of different packages do people just use cabal install so you can do global import or what?
01:42:55 <kuribas> :t forM
01:42:56 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
01:42:59 <merijn> Boarders: I generally just use cabal-install for building anything haskell, yes
01:43:05 <kuribas> merijn: yeah, but more general
01:45:33 <juhp> shouldn't ghc warn me about unused an let binding?
01:45:37 <merijn> Boarders: Especially with new-build meaning I no longer have to worry about sandboxing, etc. it's just so much easier to have cabal take care of building stuff
01:45:44 <merijn> juhp: It should with -Wall
01:46:01 <juhp> okay I thought i told .cabal to use -Wall, hmm
01:46:26 <merijn> juhp: Did you do the following? Build with cabal, add a -Wall flags, build again?
01:46:46 <merijn> juhp: Because, if so, I think cabal might have cached your build results and not done anything, hence no warning
01:47:15 <juhp> basically yes, my project .cabal file has "GHC-options:        -Wall"
01:47:22 <juhp> ah
01:47:32 <juhp> I mean I had it all along
01:47:50 <merijn> juhp: Can you lpaste your cabal file?
01:48:15 <juhp> and ghc doesn't seem to care
01:48:18 <juhp> merijn: https://hackage.haskell.org/package/cabal-rpm-0.12/cabal-rpm.cabal
01:48:33 <juhp> maybe it needs to be refreshed?
01:49:11 <merijn> juhp: Try doing "cabal clean" and then building again?
01:49:24 <juhp> okay thanks good suggestion
01:50:06 <kuribas> with optparse-applicative, how can I make an option with different flags?
01:50:48 <kuribas> for example: data OutputType = Html | Pdf,  --html gives  Html, --pdf gives Pdf, nothing gives Html
01:51:20 <merijn> kuribas: Just use flag and combine two flags with <|>
01:51:34 <kuribas> merijn: flag' then?
01:51:38 <merijn> kuribas: i.e. htmlParser <|> pdfParser <|> pure Html
01:51:59 <kuribas> this?  (flag' Html (long "html")) <|> (flag' Pdf (long "pdf")) <|> pure Html
01:52:09 <merijn> kuribas: flag' never fails
01:52:19 <merijn> oh, wait, yes it does
01:52:21 <merijn> Yeah, that's the way
01:52:31 <merijn> I was mixing up flag and flag'
01:52:31 <juhp> merijn: ah sorry it is in the log file....  then is there a way to get the log file to show when I run cabal?
01:52:47 <juhp> Guess I am not used to newer cabal yet
01:52:51 <merijn> juhp: heh, how are you running cabal? Because I always see the output
01:52:56 <juhp> ah
01:53:06 <kuribas> merijn: :)  ok, thanks!
01:53:32 <merijn> kuribas: alternatively you could do flag' Pdf (long "pdf") and use the never failing flag as final case
01:54:32 <merijn> (so you don't have to list Html twice)
01:54:36 <raduom> kuribas: ok. updated the code. now is there a way to get read of the maybe* variables?
01:55:08 <kuribas> raduom: show the updated code?
01:55:14 <merijn> juhp: Just doing "cabal build" or "cabal new-build" should report warnings to stdout (or stderr?) not the a logfile
01:55:38 <juhp> merijn: ah I am doing cabal install... maybe that's why
01:55:39 <raduom> kuribas: https://github.com/raduom/reagan/blob/master/app/Main.hs
01:55:51 <juhp> let me try
01:56:04 <merijn> juhp: oh, yeah cabal install behaves differently
01:56:11 <juhp> okay
01:56:18 <juhp> anyway to revert that?
01:56:21 <juhp> any way *
01:57:22 <merijn> juhp: Ghetto solution (assuming *nix): --build-log=/dev/stdout
01:57:42 <juhp> okay thanks
01:58:04 <kuribas> raduom: generateProgram cfg >>= traverse ( \generatedProgram -> ...)
01:58:25 <raduom> kuribas: thanks.
01:59:38 <kuribas> not sure that's clearer though...
01:59:41 <Boarders> I have done stack install shake and then have a file called Build.hs, is there anyway to use something like runHaskell whilst telling it where to find the package stack has installed?
01:59:50 <juhp> merijn: hm I am on fedora
01:59:52 <Boarders> or is there some other thing I should be doing with stack?
02:00:42 <juhp> merijn: rather it gives me an error (I read that as nixos)
02:01:01 <juhp> ah well I will just have to use cabal build I suppose :(
02:01:06 <juhp> but I actually want to install
02:01:09 <Boarders> runhaskell only seems to have options for path to ghc but not where to search for libraries
02:01:51 <merijn> juhp: I'm not quite sure I understand the problem: If you're just installing, why do you care about warnings being shown? If you're developing you should probably use build anyway
02:01:51 <juhp> maybe I should just use ghcid
02:02:03 <juhp> I am developing :)
02:02:09 <juhp> and using (testing)
02:02:26 <merijn> juhp: Then you should probably be using "cabal build" anyway, tbh
02:02:30 <juhp> okay
02:02:54 <merijn> juhp: Lemme guess, the issue is making sure you can run the executable to test?
02:03:20 <juhp> merijn: ah hmm I don't have any tests blush
02:03:21 <merijn> juhp: If so, have you had a look at "cabal run"?
02:03:30 <juhp> not really
02:03:42 <merijn> juhp: That lets you run the program from the current package without installing first
02:04:04 <juhp> okay I could just link my bin to the dist...
02:04:11 <juhp> okay
02:04:11 <Boarders> basically my above question is: is there a command for stack that does: stack ghci and then loads the the filename you pass to it?
02:04:18 <merijn> juhp: And somewhat relatedly, if you're using cabal 2.x you probably want to use the new-X versions of commands (i.e., new-build, new-run, etc.)
02:04:26 <Boarders> ...and executes main
02:04:29 <juhp> okay
02:04:37 <juhp> I am not yet
02:04:43 <juhp> merijn: thanks a lot
02:05:09 <merijn> juhp: With older cabal the executable is always located in dist/build/$exename/$exename anyway
02:05:21 <juhp> okay right
02:05:29 <juhp> that changes too?  hmm okay
02:06:26 <merijn> juhp: Well, it doesn't change if you use "cabal build", but it does with "cabal new-build", because it's more consistent about tracking build options like optimisation, profiling, etc.
02:06:40 <juhp> I see thanks
02:06:59 <juhp> when well new become default?
02:07:02 <juhp> will
02:07:05 <brynedwards> Boarders: You can do `stack runhaskell -- Build.hs`. See more here https://haskell-lang.org/tutorial/stack-script
02:07:11 <merijn> juhp: It'll be awhile, I think
02:07:12 <raduom> I find myself writing a lot of >>= (\l -> ...). Is there a way to avoid the `()`?
02:07:25 <merijn> raduom: do notation :p
02:08:57 <reactormonk> Can I write S (forall a. S a -> Handler a), given Handler is at the bottom of my transformer stack S?
02:09:32 <juhp> merijn: though maybe you are right...
02:10:00 <Boarders> brynedwards: cool, thank you!
02:10:11 <merijn> juhp: There's still too many rough edges around new-build to replace build atm, but it's much nicer to use
02:11:36 <Boarders> brynedwards: your link doesn't seem to mention runhaskell though
02:12:48 <brynedwards> Boarders: runghc and runhaskell are identical
02:13:19 <Boarders> ah I see
02:13:28 <Boarders> the man page for runhaskell does go to runghc so that makes sense
02:18:15 <juhp> merijn: okay I see
02:26:33 <dminuoso> ertes: By the way! My automaton is happily running in the background. Must be around the 120000th generation now.
02:26:36 <dminuoso> Its surprisingly slow though.
02:26:49 <dminuoso> Generating some 5000 generations takes a few seconds.
02:26:59 <dminuoso> For a small 10x10 grid
02:29:19 <Bish> how would i cleverly change the operands of a function
02:29:30 <Bish> just create a function that does it the other way around?
02:29:37 <spoonm> I'm trying to use Data.Sequence for a deque, but I don't see how I can take an element out from either and of a Seq a
02:29:39 <brynedwards> :t flip
02:29:40 <lambdabot> (a -> b -> c) -> b -> a -> c
02:29:48 <Bish> eh, funny
02:30:16 <dminuoso> Bish: Implement it.
02:31:29 <kuribas> spoonm: viewl and viewr
02:31:31 <kuribas> :t viewl
02:31:32 <lambdabot> error:
02:31:32 <lambdabot>     • Variable not in scope: viewl
02:31:32 <lambdabot>     • Perhaps you meant one of these:
02:35:13 <remix2000> Someone has read http://haskellbook.com/? Would you recommend it for beginners?
02:35:28 <merijn> remix2000: It's probably the most complete and in-depth books, yes
02:36:28 <remix2000> merijn, how does it compare with LYAH?
02:36:52 <merijn> remix2000: LYAH is, imo completely obsoleted and has been for years
02:37:17 <Bish> merijn: hows that
02:37:28 <merijn> remix2000: LYAH is famous, because when it came out there wasn't much in terms of accessible Haskell introduction. But LYAH is in no way a reasonable book for starting to learn now
02:37:45 <dysfun> "in no way" -- citation needed
02:37:57 <Bish> merijn: what's "wrong" about it
02:37:59 <Bish> since i read it
02:38:01 <merijn> remix2000: It has no exercises, is not up to date with the current ecosystem, glosses over many subtle pitfalls, generally doesn't take a pedagogically sound approach to explaining
02:38:16 <dysfun> "it doesn't fit my learning style"
02:38:28 <merijn> dysfun: I learned from LYAH and before LYAH existed
02:38:40 <sbrg> merijn: i don't think it's too bad for someone who doesn't have much experience. it's kind of "hand-holdy" with its language, but i always tell anyone who's serious about learning haskell to not use it as a sole resource
02:38:53 <Bish> does it use ecosystem at all?
02:38:53 <sbrg> but there's nothing wrong with using multiple resources, if only for the different perspectives/explanations
02:38:58 <Bish> dysfun: agree
02:39:23 <merijn> dysfun: I've also TAed the functional languages class at my university for 4 years. It's objectively not a good book for teaching. Can you learn using it? Sure. But that says more about you and your skill in solving problems and understanding that the quality of LYAH
02:39:59 <Taneb> LYAH to me felt more of an extended introduction to the language than a textbook
02:40:03 <Bish> lol @ objectively not good and you're stupid
02:40:06 <merijn> dysfun: So if you learned using LYAH. Good on you, be proud. You're good enough to get through it without much handholding
02:40:26 <dysfun> i didn't, but i don't think anything you've said can be taken as objective
02:41:04 <Taneb> I think nowadays I'd recommend the wikibook and Graham Hutton's book
02:41:07 <merijn> dysfun: Pretty much everyone I know who has taught either Haskell or functional languages that I've spoken to agrees on this.
02:41:11 <ongy> I feel like adding a `newtype Invalidated a = Invalidated a` to express in a type signature, that an IO action invalidates the Argument. Is there a shinier method to do this?
02:41:21 <Bish> i wouldn' except such arguments from a haskell programmer
02:41:30 <dysfun> merijn: i'm taking objection to the absolutism of your statements
02:41:35 <sbrg> ongy: perhaps DataKinds?
02:41:42 <sbrg> if you want to represent this invalidation at the type level
02:41:44 <Bish> pretty much everyone i talked to on the net says haskell is a esoteric language and not good for production
02:41:47 <Bish> yet you're all here
02:41:55 <Bish> s/except/expect
02:41:55 <dysfun> fwiw, i learned out of "the haskell school of expression"
02:41:56 <brynedwards> they're right
02:41:57 <Taneb> Bish: I'm sat here using Haskell in production ;)
02:42:04 <Bish> Taneb: doesn't make it good
02:42:07 <brynedwards> we like the challenge
02:42:29 <dysfun> Bish: haskell is perfectly fine for production and you should just ignore the trolls
02:42:37 <Bish> im trying to make a point there
02:42:42 <Bish> it's not my opinion
02:42:53 <Bish> his argument was "most people say therefore it's the way i say"
02:43:11 <merijn> dysfun: Ok, let's rephrase and say that LYAH is not pareto optimal. That is, for any metric you can name there are books that are better than LYAH in that specific metro while not being worse in any of the other metrics
02:43:16 <Bish> i really wouldn't expect that kind of argument ina mathematicially -themed channel
02:43:22 <Bish> just like " objectively better"
02:43:39 <sbrg> in my experience, there seems to be general agreement in the community that LYAH is not the best resource out there. I also agree with merijn on this, and I have also taught haskell for 3 years
02:43:39 <brynedwards> "merijn: remix2000: LYAH is, imo completely obsoleted and has been for years"
02:43:48 <dysfun> merijn: better, but i think still a bit extreme. some people really gain from that book and since we haven't got any studies...
02:43:52 <Bish> if i think about the term " objectively better" 3 mathematicians will run in my direction and say im wrong
02:43:54 <brynedwards> what do you think "imo" means? how did this get so out of hand?
02:44:08 <merijn> If you want completeness and in-depth, Haskell Book is better, if you want elegance, go Hutton's book, if you want operational CIS194
02:44:24 <Bish> if you want to be totally stupid go for LYAH :D
02:44:57 <remix2000> merijn, So it's worth spending $60 (~200 zlotys; it's a lot of money for a student :,( )?
02:45:00 <geekosaur> it's not great by itself, but if you have an external source of exercises then it can work
02:45:13 <ongy> sbrg: The problem is, that some actions will take an object of this type and work on it RO or copy it before anything is modified. so I don't exaclty want it to be easy to slap on/get off
02:45:15 <geekosaur> or if you're sufficiently self-motivated to supply your own
02:45:33 <merijn> remix2000: If you're really low on money, mail the author (or talk to him here on IRC, his name is bitemyapp)
02:45:53 <merijn> remix2000: AFAIK he's willing to do discounts to students and people from poorer countries
02:45:58 <dysfun> i don't think people should try and learn haskell from only one resource at a time, personally
02:47:43 <Bish> [x| x <- [0..], even x] = filter even [0..]
02:47:52 <Bish> is one of those quicker than the other?
02:48:00 <sbrg> nope
02:48:02 <merijn> Bish: Doubt it
02:48:05 <Bish> i see
02:48:29 <dysfun> without looking, i'd guess they compile to the same code
02:48:47 <sbrg> hopefully yeah
02:48:53 <merijn> Anyone remember what the URL for candidate uploads to Hackage was?
02:48:57 * sbrg waits for someone to look at the core
02:49:42 <cocreature> merijn: for uploading candidates or for viewing an uploaded candidate?
02:49:57 <merijn> cocreature: Viewing
02:50:03 <cocreature> merijn: just append /candidate
02:50:07 <merijn> cocreature: cabal-install can do the uploading for me
02:50:18 <cocreature> merijn: cabal-install will also tell you the url :)
02:50:20 <merijn> cocreature: Turns out /candidate requires a specific version name
02:50:32 <merijn> you need package/candidates to view them >.>
02:50:32 <cocreature> yeah you can have multiple candidates I think
02:51:06 <merijn> cocreature: ah, yeah packages show the url, but uploading docs does not, apparently
02:52:47 <merijn> Anyone know who develops the Chrome Hackage-Fu extension?
02:53:14 <merijn> Because it, apparently thinks that version 1.0.0.0 is newer than 2.0 >.>
02:53:37 <cocreature> google brings up https://github.com/statusfailed/hackage-fu
02:54:38 <merijn> Ah, no just stale data, apparently
03:06:26 <Bish> oh, the "array" literal notation is picky, you can do stuff like
03:06:35 <Bish> [0..(ceiling . sqrt $ 12)]
03:06:41 <Bish> or am i doing something wrong
03:07:41 <fishythe_> you're calling it picky, but then showing how permissive it is, so i'm not sure what you're asking
03:07:53 <fishythe_> but anything that enumFromTo accepts will work
03:07:56 <Bish> that does not work. that's why im writing it
03:08:07 <fishythefish> that does work
03:08:09 <Bish> oh, it does work.. weird
03:08:31 <int-e> :t ceiling
03:08:32 <lambdabot> (Integral b, RealFrac a) => a -> b
03:10:42 <int-e> Bish: (since the syntax looks fine, you may have a problem with types instead)
03:10:55 <Bish> primes = [x | x <- [2..], null (filter (\a -> rem x a == 0) [2..((ceiling . sqrt) x)]) ]
03:10:58 <Bish> this doesn't work though
03:10:59 <fishythefish> > [0..(ceiling $ sqrt 12)]
03:11:01 <lambdabot>  [0,1,2,3,4]
03:11:07 <Bish> and if i replace the stuff with x it works
03:11:08 <fishythefish> there's no issue with types or otherwise
03:11:20 <int-e> Bish: x is an integer, sqrt wants some instance of Real
03:11:28 <Bish> i see
03:11:42 <int-e> Bish: so you need  ceiling . sqrt . fromIntegral
03:11:48 <Bish> those errormessages ARE hard to read.
03:12:07 <Bish> wee, this is way quicker
03:12:09 <Bish> sick
03:13:06 <int-e> Yes. It takes some time to get used to them. But it's not too hard and *very* useful to distinguish type errors from syntax errors. Also, sprinkling your code with type signatures (like  primes :: [Int])  often helps with getting better type errors.
03:13:29 <fishythefish> Bish: assuming your initial error message was something about ambiguous type variables, add `:: [Int]` after that whole mess to get something more helpful
03:28:55 <david210218> hi I'm trying to make a Summable type which has a subset of the operations of Num then make every instance of Num a Summable. Is it considered poor form to achieve this using Undecidable instances when releasing a library?
03:30:50 <ongy> how can I disable the Orphan instance warning for a single instance declaration? (Provided I don't want to newtype it)
03:38:41 <Maxdamantus> david210218: I don't think you need undecidable instances.
03:39:01 <Maxdamantus> instance Num a => Summable a where ..
03:41:11 <Maxdamantus> Ah, actually, it does require more than standard Haskell instances.
03:52:12 <merijn> ongy: You can't at the moment, I proposed adding and ADOPT pragma a while ago, but I haven't had time to try and implement it
03:53:01 <merijn> I don't think it'd even be that hard to do, I just don't have the time
03:53:51 <merijn> hmm, hackagebot no longer announces releases?
03:56:37 <david210218> Maxdamantus: yea when I write that code it insists I use undecideable instances, I can't even just use overlapping. Are Overlapping instances going to cause too many problems?
03:57:42 <merijn> david210218: Overlapping is generally a bad sign, yes
03:58:28 <merijn> Undecidable instances is fine, because IF undecidable instances fails, it will do so at compile time
03:58:42 <merijn> So UndecidableInstances can never cause code to subtly fail at runtime
03:59:22 <david210218> merijn: OK, is there a nicer way to do it? Or am I stuck with either writing new Summable instances for a bunch of types or forcing excess methods on anyone else wanting to write an instance?
03:59:35 <david210218> merijn: yea it's just compile time loops I've got to worry about right?
03:59:45 <merijn> david210218: Right
03:59:53 <merijn> david210218: Well, you actually have a better 3rd alternative
04:01:10 <merijn> david210218: You can can use the DefaultSignatures extension to provide a default implementation for typeclass instances with a different type than the actual function. So you could use that to ensure that people only have to do "instance Summable Foo" if Foo is a Num instance
04:03:26 <merijn> david210218: Like so: http://lpaste.net/362686
04:03:54 <merijn> david210218: That avoids having to explicitly write instance implementations while also avoiding overlap
04:04:47 <merijn> david210218: Because Int is a Num instance the instance declaration for Int just uses the default implementation without needing you to write code
04:11:42 <merijn> On a completely unrelated note, I don't suppose anyone here is an SQL expert?
04:12:58 <yoda___> Hello?
04:13:11 <Taneb> Hi yoda___
04:13:12 <yoda___> Is anybody online rn?
04:13:15 <yoda___> Oh wow
04:13:17 <hpc> merijn: sort of
04:13:26 <yoda___> This is my first time on an irc chat lel idk
04:13:33 <yoda___> I found this through HN
04:13:50 <david210218> merijn: thanks a lot man! Also I know a fair bit of SQL, what's up?
04:14:00 <merijn> hpc: I find myself wanting my result rows to be labelled 0 through N (or 1 through N), but I can't for the life of me get a reasonable query for that :\
04:14:30 <yoda___> SELECT * FROM table WHERE id <= N @merihn ?
04:14:33 <merijn> This seems like a really obvious, common, and easy to implement thing, but apparently it's not
04:14:53 <merijn> yoda___: No, because I'm only selecting some rows so the numbering is not equivalent to the id
04:14:54 <yoda___> Well do you have a field that holds the numerical id?
04:15:00 <hpc> oh
04:15:01 <hpc> uh
04:15:11 <yoda___> I think it's possible to run loops in sql
04:15:29 <yoda___> I'm no sql expert lel
04:15:48 <hpc> merijn: does https://stackoverflow.com/questions/16555454/how-to-generate-auto-increment-field-in-select-query#16555527 help?
04:15:50 <geekosaur> depending on SQL dialect, there may be a special name available
04:15:53 <Akii> https://stackoverflow.com/a/1895127 ?
04:16:12 <merijn> geekosaur: I haven't found one for SQLite yet
04:16:43 * geekosaur recalls starting out sometime in the late 80s with one that used ROWID... and then switching to Oracle 4
04:17:05 <geekosaur> where ROWID got you an internal identifier that was very definitely not a sequence numbert
04:17:21 <yoda___> https://stackoverflow.com/questions/7370761/sqlite-loop-statements
04:17:32 <yoda___> That's for sqlite in particular
04:17:46 <merijn> geekosaur: ROWID just maps to a hidden primary key, it's not query specific
04:18:35 <yoda___> Well you'd need some identifiable field to iterate through
04:18:39 <geekosaur> these days, I think it was watcom / sybase sql-anywhere that defined ROWID that way
04:18:46 <david210218> meijn: like this? https://stackoverflow.com/a/16849640
04:18:48 <geekosaur> er, change that first , to a .
04:18:49 <yoda___> In which case you only need a "WHERE < >" to iterate through them
04:19:07 <geekosaur> SQL was far from reliably standardized back then
04:19:09 <merijn> david210218: I found that before, yes. But that query is retardedly inefficient
04:19:17 <Bish> in postgres stuff like that is not even an excersise
04:19:28 <yoda___> Why even do this in SQL
04:19:38 <Bish> postgres has a datetype for that
04:19:41 <yoda___> Why not simply iterate in another language and make calls to the sql table
04:19:43 <merijn> yoda___: Because the query is used as a join in another query where I need the result
04:19:44 <Bish> and you simply select it with ::nextval()
04:20:01 <yoda___> #exit
04:20:03 <yoda___> :exit
04:20:04 <yoda___> ::exit
04:20:28 <hpc> merijn: try creating a new temporary table, select-inserting to that, then selecting back?
04:20:30 <merijn> Bish: Lots of things are easy in postgres, but postgres is not a reasonable solution in this case
04:20:35 <hpc> (and deleting the table when you're done)
04:20:44 <Bish> merijn: what is the case?
04:20:48 <Bish> sorry, i just came back
04:21:29 <merijn> hpc: I would really prefer not too, though. As 1 makes the query less composable and I'd also prefer not materialising a 5 million row temp table
04:22:03 <hpc> oh, ouch
04:22:30 <merijn> Bish: Because 1) the SQLite database currently double as transfer file format, 2) I'd have to build postgres from source, configure it, and maintain it and lose the ability to easily migrate my data between machines
04:23:27 <Bish> merijn: 1) dat design 2) docker would help with that
04:23:35 <Bish> both of these problem would be fixed with a proper serialization :D
04:23:36 <merijn> Bish: i.e. I'm storing benchmark and measurement results of experiments on different clusters and the ability to have all of them as a single file and easily to migrate between machines so I can, e.g., analyse results on my laptop without connection to the cluster
04:23:38 <Bish> i know, i don't help
04:23:43 <Bish> sorry.
04:23:47 <merijn> Bish: SQLite *is* proper serialisation
04:23:57 <Bish> uhm.. like the .db files?
04:23:58 <merijn> Bish: Like...that's literally one of it's design goals
04:24:03 <merijn> Bish: Yes
04:24:16 <Bish> without checking i would guess that different sql versions are incompatible from each other
04:24:34 <liste> many programs use .db files for serialization
04:24:37 <merijn> Bish: https://www.sqlite.org/whentouse.html
04:24:39 <liste> firefox, for example
04:24:50 <merijn> Bish: Like, it's literally the 2nd listed recommend usecase on their website
04:25:17 <merijn> Also, they're ridiculously careful to preserve backwards compat
04:26:36 <merijn> Bish: "docker would help with that" just converts my problem into a "I need to build and install docker from source" problem >.>
04:27:40 <reactormonk> Anyone got some katip documentation? The readme is quite sparse
04:28:42 <fishythefish> merijn: off the top of my head, something ilke this? select foo, bar, (select count(*) from mytable b where a.id >= b.id) as rownum from mytable a
04:28:57 <fishythefish> TSQL has ROW_NUMBER but i don't think sqlite supports that
04:31:10 <hpc> fishythefish: that's n^2
04:31:14 <merijn> fishythefish: That works, but with a million+ results you end up running the count query once for each row, that hurts
04:31:20 <fishythefish> yup :(
04:31:32 <merijn> hpc: Well, you might be lucky with the query optimiser
04:31:51 <hpc> i wouldn't trust the optimizer with sqlite
04:31:56 <hpc> mysql sometimes, postgres a bit more often
04:31:59 <hpc> never sqlite
04:32:31 <merijn> hpc: honestly sqlite's query optimiser is quite good
04:32:44 <merijn> hpc: Most people I've talked to think it's considerably better than mysql
04:33:13 <Bish> liste: what do you mean by saying serialization, that people use the .db files for infomration exchange?
04:33:18 <merijn> My original (downright stupidly inefficient queries) someone became O(n), but I prefer not relying on optimiser whims
04:33:37 <merijn> Bish: SQLite is the file format Firefox uses for nearly all it's config storage
04:33:44 <merijn> Bish: Including bookmarks, history, etc.
04:33:57 <Bish> well for storage it's fine, but i understood it
04:33:58 <Bish> like
04:34:04 <Bish> you share these files betrween computers
04:34:24 <merijn> Bish: What's wrong with that?
04:34:32 <merijn> Why wouldn't you share them between computers?
04:34:43 <Bish> nothing.. but when you say " many people use sqlite for serialization"
04:34:56 <Bish> you certianly don't mean " a database file gets send back and forth"
04:35:07 <merijn> Bish: Sure you do
04:35:27 <merijn> I mean, they're not CALLED database files. Instead you call them AutoCAD files or whatever
04:35:41 <merijn> But just because they're not called SQLite databases, doesn't mean they aren't
04:35:50 <Bish> well, yah i never use autocad :D
04:35:56 <Bish> i don't know a program that does that
04:36:27 <Bish> or i never seen one
04:37:06 <cppxor2arr> are there any bots on freenode written in haskell?
04:37:14 <dminuoso> cppxor2arr: lambdabot
04:37:15 <Bish> cppxor2arr: for sure
04:37:16 <dminuoso> cppxor2arr: geordi
04:37:34 <cppxor2arr> oh i would really like to see the source code for lambda bot
04:37:41 <hpc> @hackage lambdabot
04:37:41 <lambdabot> http://hackage.haskell.org/package/lambdabot
04:37:43 <Bish> im sure dminuoso is an ai training languages
04:37:47 <cppxor2arr> thanks
04:37:57 <dminuoso> cppxor2arr: https://github.com/Eelis/geordi
04:38:56 <fishythefish> merijn: how come you need the row numbers available in the sql result itself?
04:39:49 <merijn> fishythefish: I'm building vectors and need to assign unique indices to results to do so cheaply
04:39:57 <fishythefish> (as opposed to just counting up in whatever code processes the results later)
04:40:08 <cppxor2arr> many github projects i just take a look and am overwhelmed. but these... i love haskell
04:41:05 <merijn> fishythefish: The query I want numbered never gets returned. It gets inner joined and in the inner join I need a dense set of indices to assign values to vector indices
04:42:05 <merijn> fishythefish: I can't simply append to the end of the vector, because then I need to guarantee the order in which I see records inside a GROUP BY, which you can't
06:22:07 <hyperisco> I am thinking of using a (pipes) Producer to let the user insert additional operations such as logging into an IO action. A producer may only yield one type, but I have to account for state changes (i.e. the yield type should change). I am thinking of using a Producer of Producers to accomplish this, but looking for other thoughts.
06:22:49 <hyperisco> a Producer of Producers it is more complicated to consume
06:23:07 <Psybur> What is a pack of producers called?
06:47:58 <giaocmo901010> hello
06:48:03 <giaocmo901010> !list
08:02:19 <dminuoso> What's the canonical library for simply generating some simple XML? Ive been going through some of them on hackage, but they all seem like crazy complicated QuasiQuote magical stuff
08:03:28 <Tuplanolla> I think your problem is assuming that XML can be simple.
08:03:47 <dminuoso> Tuplanolla: I just need to generate some non complicated KML stuff. I dont intend to use any of the crazy features.
08:07:25 <sr10> hey i need help with us problem https://stackoverflow.com/questions/48880063/joins-of-data-in-haskell
08:07:41 <sr10> im not sure if m doing it correctly
08:08:52 <dminuoso> o.i
08:09:03 <Akii> that screams lens somehow
08:09:16 <dminuoso> That made me scream.
08:09:32 <Akii> xD
08:10:15 <w1n5t0n> I want to sample a function "f" of time over its whole duration, given a duration "dur::Double" in seconds and a sampling rate "sr::Int". My first instinct was to do "listOfResults = map f domain, where step = 1/(dur * fromIntegral sr); domain = [0, 0+step .. 1]]" but I'm sure there are better ways to do it. Any thoughts?
08:10:50 <brynedwards> dminuoso: this looks straightforward to me https://hackage.haskell.org/package/xmlgen
08:11:15 <dminuoso> brynedwards: I was a bit turned away after seeing the last commit being 4 years old.
08:11:16 <w1n5t0n> (the domain will be a list from 0 to 1 in numFrames step, where numFrames is dur * sr)
08:13:52 <dminuoso> sr10: At the very least you can clean up your code a bit by turning down redundant parens and using [id | a == b] instead of those if/then/else constructs
08:15:12 <dminuoso> sr10: And you probably should use smaller functions using `where` to decompose a bit more. It's kind of tough to follow what this code does.
08:15:34 <cocreature> w1n5t0n: looks like a pretty reasonable solution, what are you hoping to improve?
08:15:36 <dminuoso> sr10: Also the level of inconsistency wrt to indentation and space usage hampers the reading flow
08:16:50 <sr10> dminuoso: okay i'll try. I'm just a beginner. Sorry. I'm not sure how to use this [id | a == b]
08:17:10 <dminuoso> sr10: That's a list comprehension
08:17:37 <pja> XML died years ago anyway, all that remains are ossified fragments, so a four year old library is fine. (I exaggerate for effect, probably.)
08:18:00 <sr10> dminuoso: okay will go through it
08:18:04 <w1n5t0n> cocreature: I don't think this guarantees that the last element of the domain will always be 1, does it?
08:19:28 <dminuoso> sr10: Basically Im simply using the fact that you can use a list comprehension without <- drawing from lists. [id | a == b] produces either [id] or [] depending on whether a == b
08:20:04 <cocreature> w1n5t0n: right although if your input is a Double then it seems like you are already accepting rounding errors. if you care about exact results, there are fixed precision types or even something like Rational
08:20:24 <sr10> dminuoso: got it thanks
08:22:23 <merijn> bleh
08:22:38 <merijn> Why does ResourceT only allow registering IO cleanup? >.<
08:24:10 <dminuoso> sr10: Note that this is without any structural transformations: https://gist.github.com/anonymous/6a74bc679397d59cc2ce049a0a3f4c34
08:24:13 <merijn> If I just use bracket_ somehow my finalizer/cleanup ends up running too soon
08:24:19 <dminuoso> That's the last of your functions made a bit more readable.
08:26:25 <dminuoso> sr10: Next that filter (not . null) is completely redundant.
08:27:01 <dminuoso> sr10: https://gist.github.com/anonymous/bd7e46d57c843d0250db525151a63155 Im sure you can golf this even further but Im too tired.
08:27:13 <dminuoso> oh well actually.
08:27:19 <dminuoso> userList >>= g where ...
08:27:58 <dminuoso> sr10: https://gist.github.com/anonymous/f73a494edc604ad8df3f7e25ae55d47e =)
08:30:01 <sr10> thank u. will go through this
08:32:16 <Boarders> in the servant tutorial they have something like: type UserAPI = "users" :> QueryParam "sortby" SortBy :> Get '[JSON] [User]
08:32:31 <Boarders> what does this ":>" symbol do?
08:33:10 <hyperisco> Boarders, it is a type constructor
08:33:39 <metahumor> Boarders: "data (path :: k) :> (a :: *)"
08:34:02 <metahumor> Boarders: I found that by going to the servant hackage docs, looking at the index: https://hackage.haskell.org/package/servant-0.13/docs/Servant-API-Sub.html#t::-62-
08:34:20 <Boarders> cool
08:34:25 <metahumor> more detailed: "The contained API (second argument) can be found under ("/" ++ path) (path being the first argument)."
08:34:46 <Boarders> is it a phantom type thing?
08:34:59 <metahumor> where would the phantom type be?
08:35:31 <Boarders> type role (:>) phantom phantom data (:>) (path :: k) (a :: k1)   	-- Defined in ‘Servant.API.Sub’
08:35:35 <Boarders> is what :i gives me
08:36:31 <merijn> Boarders: :> is just an operator type constructors
08:36:53 <merijn> @let type a :+: b = Either a b
08:36:54 <lambdabot>  Defined.
08:37:04 <merijn> > Left True :: Bool :+: Int
08:37:06 <lambdabot>  Left True
08:37:41 <metahumor> Boarders: try ":k (:>)"
08:38:44 <Welkin> are you talking about the type operator from servant?
08:38:49 <Boarders> yes
08:39:20 <metahumor> it builds a route/path to some API, such that "(:>) path api"; and it can be chained like "(:>) path ((:>) path api)"
08:40:00 <Boarders> cool
08:40:02 <Boarders> thanks
08:40:20 <Boarders> scared of what datakinds trickery is going on underneath that
08:40:30 <Welkin> Boarders: are you in a boarding school? Or did you board your dogs?
08:41:11 <Boarders> i am in boarding school
08:41:43 <Boarders> we are only allowed to use imperative languages to instil discipline in us :(
08:42:42 <Welkin> how will that discipline you?
08:42:47 <Welkin> it's the other way around
08:42:52 <Welkin> functional languages discipline you
08:42:58 <metahumor> Boarders: there is very little trickery in the definition of (:>)
08:43:02 <Welkin> imperative languages let you shoot your leg off
08:43:03 <dstolfa> Welkin: it's the same type of discipline when they make you fix your bed over and over
08:43:17 <dstolfa> it's pointless and very rude of them
08:43:18 <dstolfa> :>
08:43:48 <metahumor> it's not even that tricky how "Get" is defined
08:44:09 <humanoyd> Boarders: https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/
08:44:40 <Boarders> cool, i'll have a look
08:44:53 <Welkin> thanks for the link humanoyd
08:45:20 <Denommus> hey
08:45:39 <Denommus> what is the current recommended library for cross-platform GUIs?
08:45:50 <Welkin> cross platform?
08:45:52 <Welkin> which platform?
08:45:57 <Denommus> Linux and Windows
08:46:04 <Welkin> not sure
08:46:07 <Welkin> gtk should work though
08:46:10 <dstolfa> Qt generally works on both
08:46:15 <dstolfa> and there are decent haskell bindings IIRC
08:46:36 <Welkin> you can use reflex to build your gui
08:46:43 <Welkin> and then render in a browser or webkit-gtk
08:47:02 <dstolfa> or you can transpile to JS
08:47:03 * dstolfa hides
08:47:18 <Welkin> dstolfa: what I mentioned involves ghcjs already
08:47:19 <Denommus> dstolfa: do you know about a specific Qt binding?
08:47:39 <dstolfa> Welkin: not necessarily, you can do wasm (eventhough wasm is shit, but not as shit as js)
08:47:40 <Denommus> I didn't want to use ghcjs, otherwise I'd just use ReasonML
08:48:00 <dstolfa> Denommus: let me look real quick
08:48:44 <batman_> can we convert maybe [a] to [a] & vice verse & lastly if yes then is it a good practice ?
08:48:59 <Welkin> Denommus: those are not comparable
08:49:54 <dminuoso> sr10: Okay I think this can be cleaned up even much much much further.
08:49:57 <Welkin> Reasonml is ocaml in a new skin
08:50:06 <dstolfa> Denommus: https://hackage.haskell.org/package/qt -> this might be useful?
08:50:27 <Denommus> Welkin: I know exactly what Reason is, I contributed to it in the earlier days
08:50:53 <Denommus> and if I want a language to generate JS, that would be my language of choice
08:51:31 <yoho> batman_: you're looking for functions with signatures of Maybe a -> a and a -> Maybe a - you should be able to find those on Hoogle
08:51:40 <yoho> as for whether it's good practice, generally no
08:51:42 <Denommus> dstolfa: that might be what I need
08:51:50 <cocreature> Denommus: https://hackage.haskell.org/package/hsqml is probably also worth a look
08:51:55 <Denommus> I asked here instead of just googling because there are some options like hsqml
08:52:01 <Denommus> cocreature: quickfingers
08:52:43 <batman_> yoho : so what's the way around
08:53:23 <Boarders> when you write '[JSON] what does the ' prefix mean?
08:53:24 <metahumor> batman_: why do you need to convert Maybe [a] into [a]?
08:53:31 <Welkin> Boarders: a type-level list
08:53:33 <metahumor> Boarders: " '[] " is a type level list
08:53:36 <Boarders> oh ok
08:53:51 <metahumor> Boarders: "data Verb (method :: k1) (statusCode :: Nat) (contentTypes :: [*]) (a :: *)"
08:54:01 <metahumor> Boarders: "type Get = Verb GET 200"
08:54:44 <AWizzArd> Omg. 6 hours debug time to find a bad type error (in a dynamically typed language). Dayum. Haskell pls!
08:55:00 <metahumor> Boarders: so ":k Get -- (contentTypes :: [*]) -> (a :: *) -> *"
08:55:04 <Welkin> AWizzArd: you mean a language without types
08:55:23 <dminuoso> Can I alias a type while typing it? Something along the lines of: t@(a, b, c) -> t -> t ?
08:55:38 <Welkin> AWizzArd: that is why I quit python, and python almost made me quit programming, until I found haskell
08:55:38 <AWizzArd> Welkin: or we can call it singly-typed language.
08:55:42 <dminuoso> Or create local type aliases somehow?
08:55:50 <Boarders> thanks metahumor, makes sense
08:55:53 <batman_> metahumor : coz i have a Maybe [a] while i'm interested in [a]
08:56:20 <metahumor> batman_: how do you tell "Nothing" apart from "Just []"?
08:56:22 <AWizzArd> With Haskell I would have not come far making this error. Even while typing it Emacs would have told me about my wrong assumption.
08:56:29 <Welkin> :t fromMaybe -- batman_
08:56:31 <lambdabot> a -> Maybe a -> a
08:57:34 <Welkin> batman_: you can write your own function, using pattern matching, that does this same thing
08:57:45 <Welkin> implement `fromMaybe` given this type signature
08:58:07 <dminuoso> Welkin: every time I've used fromMaybe so far, it seemed it was misplaced
08:58:17 <dminuoso> Pattern matching or lenses seemed more elegant every time
08:58:19 <Welkin> batman_: the first `a` parameter is the "default" value, in case the `Maybe a` you are matching on is `Nothing`
08:58:33 <Welkin> dminuoso: this is just for illustration
08:58:46 <Welkin> fromMaybe can be useful though
08:58:49 <Welkin> along with `maybe`
08:59:02 <batman_> welkin : but if i have to supply a in a -> Maybe a -> a what's the use of the function & isn't that silly i mean you supply output to input to get the exact same output. This might just be silly for me coz i'm new to haskell
08:59:27 <Welkin> batman_: no, the first paramter is the default value in case the Maybe you are matching on is empty (Nothing)
09:00:09 <batman_> welkin : okay that make sense
09:00:15 <Bowlslaw> Welkin: Hutton's book is fantastic man
09:00:23 <Bowlslaw> and the exercises are great
09:00:42 <Welkin> Bowlslaw: except that one chapter on list comprehensions that we discovered last night
09:00:50 <Bowlslaw> eh?
09:00:59 <Bowlslaw> i'm almost on that chapter
09:01:05 <Welkin> it has very strange exercises
09:01:07 <batman_> welkin : now someone was saying its not a good practice why is that ?
09:01:17 <Welkin> batman_: what is not a good practice?
09:05:14 <dminuoso> What's the lens equivalent of if/then/else ?
09:05:43 <Gurkenglas> dminuoso, perhaps you mean failing
09:07:23 <batman_> welkin : someone said converting Maybe [a] -> [a] is not a good practice
09:10:26 <dminuoso> Gurkenglas: Not sure whether it fits. Let's say I have something like: if t ^. l then t ^. o else t ^. b
09:10:35 <dminuoso> Is there a way to fuse l/o/b together?
09:10:57 <Welkin> batman_: you have to do that when you pattern match on Maybe
09:11:39 <Welkin> :t fromJust
09:11:40 <lambdabot> Maybe a -> a
09:11:42 <Welkin> that fuction is unsafe
09:11:51 <Welkin> because it only checks for the `Just` constructor
09:11:57 <dminuoso> That means its your job to prove that it cant possibly be Nothing. =)
09:12:03 <Welkin> however, `fromMaybe` and `maybe` are fine
09:12:13 <Welkin> because you always provide a default value
09:13:49 <kuribas> dminuoso: what's wrong with that?
09:14:01 <dminuoso> kuribas: You mean the lenses?
09:14:10 <kuribas> the if expression
09:14:30 <kuribas> t ^. l then t ^. o else t ^. b is perfectly fine
09:14:45 <dminuoso> kuribas: Not saying there's anything wrong, Im just exploring options.
09:17:34 <Bowlslaw> has anyone made a web crawler with Haskell
09:18:09 <Welkin> Bowlslaw: not that I know of, but someone probably has
09:18:15 <Welkin> all kinds of things have been made with haskell
09:18:29 <Welkin> I build lots of web apps with it
09:18:57 <Welkin> web dev is one of haskell's strengths
09:19:20 <Bowlslaw> i'm sure it has, I was wondering if anyone had personal experience
09:19:27 <Bowlslaw> i'm glad web dev is strong
09:19:40 <Bowlslaw> i want to crawl the web for some data and then make it all pretty-like
09:19:43 <dminuoso> sr10: Also Im not entirely sure about your choice of [].
09:19:52 <dminuoso> sr10: The way you test for equality suggests you actually want Maybe.
09:19:59 <Bowlslaw> like, say, statistics on overall violent crime
09:20:13 <jle`> i know some people who have built web crawlers
09:20:19 <jle`> Bowlslaw: what you are talking about sounds more like scraping though
09:20:25 <Welkin> Bowlslaw: there are plenty of http clients that you could use to set up a crawler
09:20:26 <jle`> or both, i suppose
09:20:35 <Bowlslaw> what's the difference between crawling and scraping?
09:20:45 <sr10> dminuoso: yes working on that
09:20:46 <jle`> crawling is following links
09:20:50 <MarcelineVQ> crawling discovers paths, scraping sifts data
09:20:52 <Bowlslaw> crawling = links scarping = data?
09:20:54 <jle`> scraping is getting useful information from raw HTTP data
09:20:57 <Bowlslaw> ah ok
09:21:06 <dminuoso> Bowlslaw: crawling is what google does, scraping is what petty users do.
09:21:10 <Bowlslaw> it shall be named...the Web Scrawler
09:21:11 <ertes> dminuoso: make sure your realiser is of the following shape:  realise (StoreT f' x0) = StoreT f x0 where vec = …
09:21:23 <ertes> dminuoso: where 'vec' is an array-like structure
09:21:37 <jle`> in practice, scrawling is more about managing a queue of websites to visit, traversing efficiently, etc.
09:21:41 <bitemyapp> remix2000: yep, email us.
09:21:43 <jle`> scraping is more of a parsing problem
09:22:11 <ertes> dminuoso: 10x10 should easily run at hundreds of thousands of FPS
09:22:17 <ertes> if not millions
09:22:19 <Bowlslaw> I just want to use, say, FBI website as a base, collect crime stats, and follow any links provided by the FBI site relevant to more stats
09:22:29 <dminuoso> ertes: Hey ertes. https://gist.github.com/dminuoso/dfe3231a12b4c3477a6bf87cea38f6f9
09:22:42 <dminuoso> This is (an incomplete excerpt) of what Im doing.
09:22:46 <MarcelineVQ> I wouldn't start wih a government site to practise web techniques on :>
09:22:51 <jle`> Bowlslaw: in that case, yeah, the crawling isn't the hard part
09:23:02 <jle`> it's writing parsers to get useful data from the raw http
09:23:08 <ertes> dminuoso: oh…
09:23:13 <ertes> you're using a list of lists =)
09:23:24 <ertes> yeah, then i'm not surprised at all about the bad performance =)
09:23:26 <jle`> luckily though parsers are often considered haskell's killer app
09:23:28 <dminuoso> ertes: I didn't think too much of it since I didnt do random access.
09:23:28 <Bowlslaw> jle`: i'm sooo tempted to use perl for that
09:23:50 <Bowlslaw> but if it's something in which Haskell excels, I may as well use Haskell
09:23:56 <ertes> dminuoso: you should really use a flat vector
09:24:05 <dminuoso> ertes: You mean for things like `points` ?
09:24:13 <jle`> yeah, haskell makes parsing pretty enjoyable/simple
09:24:15 <Bowlslaw> maybe use perl's regex support to format the data in a file and then process it with Haskell or something
09:24:23 <ertes> dminuoso: yeah
09:24:29 <batman_> welkin : Ambiguous type variable ‘k0’ arising from a use of ‘Map.insert’ , can you please tell me what it mean
09:24:52 <ertes> dminuoso: oh, wait
09:24:57 <ertes> dminuoso: i read your function wrong
09:25:11 <jle`> batman_: `insert :: k -> Map k a -> Map k a`; the error is probably that haskell can't infer what 'k' is supposed to be
09:25:13 <Bowlslaw> I shall name my bot, "David Haskellhoff"
09:25:37 <ertes> dminuoso: you're using a ByteString as the backing store…  that ByteString must have a name
09:25:39 <jle`> also there is a user named k in this channel and it is throwing off my highlighting v.v
09:25:56 <dminuoso> ertes: Im not?
09:26:02 <jle`> @whois k
09:26:02 <lambdabot> Unknown command, try @list
09:26:14 <dminuoso> ertes: It's an unboxed vector of Word64
09:26:29 <dminuoso> ertes: https://gist.github.com/dminuoso/dfe3231a12b4c3477a6bf87cea38f6f9#file-foo-hs-L21 is where it appears
09:26:42 <dminuoso> And the line below is what forces it to be Word64
09:27:02 <ertes> dminuoso: this is really confusingly written, reusing names from the ByteString API, etc…  in any case the vector must have a name
09:27:09 <ertes> dminuoso: the vector itself
09:27:40 <dminuoso> ertes: its called "internal" :P
09:27:56 <ertes> realize (V2 mx my) (Store x0 f) = Store x0 …  where vec = pack …
09:28:26 <ertes> dminuoso: whatever is your backing store must have a name within 'realize' for sharing to take effect
09:29:03 <dminuoso> o.o
09:29:04 <batman_> jle` : it goes off when i specifically say (a :: Int) any solution to avoid this ?
09:29:42 <ertes> dminuoso: f x y = x^5000 + y  -- x^5000 is recomputed for every y
09:30:20 <ertes> dminuoso: f' x = \y -> x5000 + y  where x5000 = x^5000  -- x^5000 is computed once and belongs to (f' x)
09:30:21 <jle`> batman_: hard to say without seeing any code
09:30:40 <jle`> batman_: but usually if you use the value anywhere else, haskell can use type inference to figure out the type
09:30:53 <dminuoso> ertes: Oh..
09:31:54 <ertes> dminuoso: in fact right now i wouldn't just expect it to be slow, but getting even slower with every frame
09:31:59 <Welkin> batman_: make sure you write a type signature for all top-level definitions
09:35:54 <dminuoso> ertes: Alright. It's still getting progressively slower, but Ill just use this as an excuse to do some profiling =)
09:36:09 <dminuoso> ertes: At any rate, it was a fun excercise, Ill try and clean it up to remove any confusion wrt to ByteString later
09:38:06 <Bowlslaw> wow I didn't realize topology was a generalized form of geometry...
09:41:44 <numberten> @hoogle Either (Maybe a,Maybe a) (Maybe a, Maybe a) -> (Maybe (Either a a), Maybe (Either a a))
09:41:44 <lambdabot> Control.Wire.Core WPure :: (s -> Either e a -> (Either e b, Wire s e m a b)) -> Wire s e m a b
09:41:44 <lambdabot> Control.Wire.Core WGen :: (s -> Either e a -> m (Either e b, Wire s e m a b)) -> Wire s e m a b
09:41:44 <lambdabot> Numeric.LinearAlgebra.Devel unzipVectorWith :: (Storable (a, b), Storable c, Storable d) => ((a, b) -> (c, d)) -> Vector (a, b) -> (Vector c, Vector d)
09:59:49 <ixxie> Can anybody recommend a *practical* introduction to Haskell focused on unlearning imperative patterns? I find myself unable to conceive of design patterns for solving simple problems
10:04:27 <Tuplanolla> You could start by solving problems you haven't solved before, ixxie.
10:04:29 <Akii> hmm I remember reading something about this behaviour some time ago.. is there a simple explanation? http://lpaste.net/362698
10:05:20 <Akii> (call as in execute, evaluate; sorry)
10:05:31 <Tuplanolla> That should make it easier to approach familiar problems without preconceptions.
10:05:44 <cocreature> Akii: do you know how <$> and <*> are implemented for Maybe?
10:06:11 <Akii> cocreature  fmap yes, ap not so much
10:06:22 <Akii> (that thing <*> is called ap, right?)
10:06:50 <ixxie> Tuplanolla: I am not sure I understand
10:06:56 <cocreature> Akii: take a look at the implementation https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-716
10:06:58 <dminuoso> Akii: For historical reasons (<*>) and `ap` are two different functions, but by law they are required to behave the same.
10:07:12 <dminuoso> The first comes from Applicative, the second from Monad.
10:07:23 <cocreature> Akii: you can see that it shortcircuitus if the first argument is Nothing
10:07:58 <ertes> dminuoso: also you should probably just use the 'comonad' library from this point on =)
10:08:04 <cocreature> eh actually nvm I haven’t read your lpaste close enough, sorry
10:08:09 <Tuplanolla> Can't unlearn things you never learned in the first place, ixxie.
10:09:07 <Akii> cocreature I really thought those two expressions were equivalent for some reason
10:09:12 <ertes> ixxie: you should just start working on a practical project
10:09:20 <Akii> I blame me still not getting Applicatives
10:09:21 <cocreature> Akii: so which part is confusing you? the fact that it’s not being executed in the second case or the fact that it is being executed in the first case?
10:09:47 <Akii> I'm confused that it's executed in the first case
10:10:15 <Akii> let me quickly try with liftA2
10:10:22 <cocreature> Akii: you are using the Functor/Applicative instance of STM here, not Maybe
10:10:34 <cocreature> so there is no shortcircuiting involved
10:10:40 <numberten> is there a best practice for deciding when to represent a value as Either a a or (a, Bool) ?
10:11:45 <ertes> numberten: decide based on whether the Either interface or the tuple interface provides the functions you need
10:11:53 <cocreature> Akii: you are calling "fromMaybe" on the result of executing appendAddress and checkWorkLog. not on the actions themselves
10:12:02 <ertes> numberten: i.e.: "which one will work better, if i'm not allowed to pattern-match"
10:12:44 <Akii> cocreature  gotcha.. Applicatives.. riiiiighh
10:12:46 <Akii> t
10:12:53 <amalloy> ixxie: alternatively, ask a question about a specific algorithm you can implement imperatively but can't imagine a functional approach for. many things have a broadly similar "design pattern": use folds and recursion instead of loops
10:13:13 <cocreature> Akii: if you rewrite the first case in do notation it becomes `atomically $ do x <- appendAddress; y <- checkWorkLog; pure (fromMaybe x y)`
10:13:14 <Akii> I still not know _why_ exactly but they're both evaluated.. makes sense; thank you!
10:13:17 <ertes> numberten: for example Either lets you branch via 'either', but has no nice way to extract the 'a', whereas you can easily extract the 'a' from a tuple, but branching on the Bool is a bit more awkward
10:13:27 <numberten> yeah
10:13:41 <numberten> i end up doing both and things that were painpoints got better when i switched to either
10:13:48 <numberten> but now i find myself needing to pattern match occasionally on either
10:14:27 <Akii> cocreature fwiw I tried to create a function like `whenM` or tried to somehow lift `fromMaybe` into that somehow
10:15:13 <ertes> numberten: in principle the tuple is better, because it gives you direct access to the left component, so you don't *have to* branch…  but it comes down to the API
10:15:20 <batman_> how to solve couldn't match IO Bool with Bool
10:15:47 <qeyoa> i'm a bit hazy today, but is there any equivalent thing to this in, say, java?: `data Shape = Circle Float | Rect Float Float` I'm trying to understand what is this...  Is it possible to define an Int in this way? data Int = 1 + Int n | 2 + Int n....
10:15:55 <ertes> numberten: also these types are isomorphic (up to bottoms), so you can always just convert between them
10:16:17 <cocreature> Akii: if you really want to use fromMaybe you could use `atomically $ do inWork <- checkWorkLog; fromMaybe appendAddress (fmap pure inWork)`
10:16:36 <cocreature> Akii: but I wouldn’t call that an improvement over just using a regular case
10:16:42 <Akii> cocreature  at that point I just make it explicit with the case analysis
10:16:45 <ertes> :t iso (either (, False) (, True)) (\ ~(x, b) -> if b then Right x else Left x)
10:16:46 <Akii> ++
10:16:46 <lambdabot> (Functor f, Profunctor p) => p (t, Bool) (f (a, Bool)) -> p (Either t t) (f (Either a a))
10:16:56 <Akii> thank you!
10:17:24 <jle`> qeyoa: the closest thing to data Shape = Circle Float | Rect Float Float in Java is probably via subclasses
10:17:33 <jle`> even though it doesn't quite translate exactly
10:17:37 <kadoban> qeyoa: It's not really possible in haskell itself, but you could think of it like  data Int = 1 | 2 | 3 | 4 | ...
10:17:50 <batman_> if (isEmptyChan kbChan) == True  is giving me Couldn't match expected type ‘IO Bool’ with actual type ‘Bool’
10:18:20 <jle`> batman_: look at the type of (==)
10:18:25 <qeyoa> why would a data type literal need arguments ?
10:18:26 <jle`> batman_: it requires that both sides have to have the same type
10:18:30 <qeyoa> Rect n n
10:18:42 <jle`> qeyoa: those are the "fields" of the value
10:18:53 <jle`> qeyoa: kind of like the values of a struct
10:18:59 <qeyoa> ah
10:19:08 <jle`> qeyoa: so a value of type 'Shape' can take on one of two forms:
10:19:15 <jle`> it can be 'Circle 1.3', or some other Float
10:19:20 <jle`> or it can be 'Rect 2.4 1.5', or some other Floats
10:19:43 <batman_> jle` : it is expecting IO Bool so what's IO Bool equivalent of True
10:19:43 <jle`> those might be called "properties" in OOP-speak
10:19:43 <Akii> cocreature  or that lel `var <- atomically (checkWorkLog >>= maybe appendAddress return)`
10:19:53 <Akii> but yeah
10:20:02 <qeyoa> thanks jle
10:20:05 <jle`> batman_: note that 'if' only takes bools, not IO Bools
10:20:30 <jle`> qeyoa: no problem
10:20:54 <batman_> jlee` : can it be solved with guards >?
10:21:07 <jle`> batman_: what are you trying to do?
10:21:35 <amalloy> qeyoa: if you're familiar with the visitor pattern, there's an interesting correspondence between that and ADTs like your example
10:21:49 <batman_> jle` : i'm trying to check if a channel is empty or not and act accordingly
10:22:05 <jle`> if you're in a do block, you can bind the result of isEmptyChan kbChan
10:22:13 <jle`> em <- isEmptyChan kbChan
10:22:16 <jle`> if em then ... else ...
10:22:43 <dminuoso> batman_: Imagine someone did: `g = getLine >>= \x -> pure (x == "Hi")` and passed you the `g`
10:22:45 <amalloy> i haven't read all of http://eng.wealthfront.com/2015/02/11/pattern-matching-in-java-with-visitor/ but it seems like a decent article on the topic if you're interested
10:22:46 <qeyoa> amalloy, no but i'm going to read about it right now :)
10:23:01 <dminuoso> batman_: There's absolutely no way of knowing what whether that will produce True or False until you actually run it.
10:24:22 <numberten> ertes: alright thanks.
10:27:06 <EvanR> batman_: the IO equivalent of True... return True ?
10:28:57 <dminuoso> Just out of curiosity - is there a way of determining whether an IO object will produce side effects?
10:31:24 <amalloy> dminuoso: probably the first step is to solve the halting problem
10:31:51 <dminuoso> amalloy: Well I mean - it might be possible Haskell attaches some information into IO objects _if_ they are constructed with pure/return
10:32:08 <amalloy> dminuoso: even if it did you couldn't be sure
10:32:26 <ertes> numberten: on a slight tangent you may want to learn the basics of type algebra
10:32:26 <amalloy> pure 5 >>= (\x -> if x == 3 then return () else launchMissiles)
10:33:06 * dminuoso is wondering why every argument about IO and side effects involves IO launching missiles
10:33:08 <ertes> numberten: algebraic types form a semiring under isomorphism, where Either is (+) and (,) is (*)
10:33:19 <amalloy> you could, at best, partition into "definitely no side effects" (value produced via return/pure and nothing else) and "maybe side effects" (produced any other way)
10:33:31 <numberten> ertes: I'm aware
10:33:37 <dminuoso> amalloy: Mmm. I guess that's not very interesting, I get your point.
10:35:42 <ertes> numberten: sorry, didn't mean to imply you weren't =)
10:35:44 <numberten> ertes: and the derivative of a regular type gives you its one-hole context
10:35:50 <numberten> and other interesting odities
10:35:53 <metahumor> dminuoso: that's why some consider "MonadIO is harmful": http://chrispenner.ca/posts/monadio-considered-harmful
10:36:17 <ertes> numberten: well, i don't consider that to be part of type *algebra*
10:36:24 <metahumor> dminuoso: as in, if we have a MonadIO m constrain, that is way too general and we can't be sure what IO capabilities will be used
10:36:25 <jle`> dminuoso: if you use 'Lift' from transformers, then you can inspect a 'Lift IO' action to see if it was only made using returns and pures
10:36:37 <numberten> fair
10:36:51 <dminuoso> Boy even that article mentions nuclear missiles. This must be a running gag..
10:37:10 <jle`> @let import Control.Applicative.Lift
10:37:11 <lambdabot>  Defined.
10:37:21 <metahumor> dminuoso: https://hackage.haskell.org/package/acme-missiles
10:37:32 <numberten> i think (for myself at least) it's just a matter of building an intuition for when to apply equational laws, wrt types
10:37:34 <ertes> dminuoso: https://hackage.haskell.org/package/acme-missiles
10:37:54 <jle`> although Lift only has Applicative instance
10:38:26 <numberten> your answer of "when one side is works better for what you need" works, but still something I think I could build a better intuition for
10:38:27 <ertes> numberten: i sometimes use it to optimise types…  a nice example of that is this:  data Lens a b = Lens { get :: a -> b, set :: b -> a -> a }
10:38:36 <jle`> > let x = pure "hello" *> Other (putStrLn "hi") in case x of Pure _ -> "no effects"; _ -> "probably effects"
10:38:38 <lambdabot>  "probably effects"
10:38:44 <numberten> found myself rewriting lots of types and following your suggestion of trying to avoid explicit pattern matches
10:38:48 <jle`> > let x = pure "hello" *> Pure "hi" in case x of Pure _ -> "no effects"; _ -> "probably effects"
10:38:49 <lambdabot>  error:
10:38:49 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘x’
10:38:50 <lambdabot>        prevents the constraint ‘(Applicative f0)’ from being solved.
10:38:53 <ertes> numberten: using algebra you can optimise it to:  newtype Lens a b = Lens { runLens :: a -> (b, b -> a) }
10:39:02 <amalloy> jle`: it occurrs to me, what if you worked in Free IO a instead of IO a? then could you inspect the value to see if it has binds?
10:39:08 <jle`> > let x :: Lift IO String; x = pure "hello" *> pure "hi" in case x of Pure _ -> "no effects"; _ -> "probably effects"
10:39:10 <lambdabot>  "no effects"
10:39:54 <jle`> amalloy: yes, you can pattern match
10:40:16 <ertes> numberten: you can only really build the intuition with experience, because it's really a matter of knowing all the different APIs you can use with Eithers and tuples
10:40:30 <dminuoso> jle`: Wow that's interesting.
10:40:59 <jle`> yeah, i suppose if you always use 'Free IO a', the Functor/Applicative instances are smart enough to ensure that Pure stays Pure
10:41:10 <numberten> fair. just difficult when writing code to be read by those with equal or worse intuition then my current self
10:42:12 <ertes> numberten: readers can always look up the APIs you've been using, or they can ask here…  keep your code readable, not beginner-friendly
10:43:16 <numberten> yeah I like that
10:43:20 <ertes> numberten: (unless you're specifically writing for a haskell tutorial, of course)
10:50:29 <metahumor> is there a clear reasoning as to why certain monad-transformers only need an Applicative constraint while some need Monad on the wrapped m?
10:50:41 <metahumor> as seen here: https://stackoverflow.com/questions/25799124/applicative-transformer-classes
10:51:34 <ertes> metahumor: ContT doesn't even require Applicative
10:52:40 <metahumor> more specifically, I wrote the Applicative instance for StateT for an exercise, and used the Monad constraint, while the Functor instance only needs a Functor constraint. Was I too strict? Can one write Applicative f => Applicative (StateT s f a)?
10:53:18 <ertes> metahumor: no, you need (Monad m) to implement (Applicative (StateT s m))
10:54:29 <jayjay_> f 0 = 1 f n = g n n  g n 0 = 1 g n i = g n (i-1) + h n (i-1)  h n 0 = 1 h n i = h n (i-1) + h (n-1) (i-1)
10:56:17 <jle`> metahumor: it depends on each individual case
10:56:28 <jle`> metahumor: but there's one 'trick', i suppose
10:56:43 <jle`> metahumor: if a monad transformer can be expressed as a composition of monads, then it should only require Applicative
10:56:54 <pikajude> is there a good way to test that my cabal package builds after it has been sdist'd and unzipped?
10:56:58 <jle`> that's because there is always Applicative f => Applicative (Compose Foo f)
10:57:00 <ertes> metahumor: think of it this way: monad transformers (functions that take a monad and return a monad) are about as "natural" as functions that take an integer and return an integer
10:57:04 <pikajude> or, in general, a good way to check that I'm not missing extra-source-files?
10:57:11 <jle`> * (Applicative f, Applicative g) => Applicative (Compose f g)
10:57:17 <ertes> metahumor: there is not much inherent structure to the *concept* of a monad transformer
10:57:30 <jle`> but StateT in particular cannot be expressed as a composition of monads
10:57:38 <jayjay_> 1 2 3 4 5 6 7 8 f 0 = 1 f n = g n n  g n 0 = 1 g n i = g n (i-1) + h n (i-1)  h n 0 = 1 h n i = h n (i-1) + h (n-1) (i-1)
10:58:03 <ertes> metahumor: (other than the monad morphism laws)
10:59:13 <jayjay_> i want to understand a code
10:59:17 <jayjay_> i can i share it
10:59:18 <jayjay_> ?
10:59:50 <Welkin> yes
10:59:54 <amalloy> jayjay_: multiline code snippets to http://lpaste.net/ or something
11:00:19 <metahumor> ertes: i appreciate the parallel to functions of Int -> Int. we can speak about those though, with derivatives as a form of describing structure
11:02:44 <metahumor> jle`: where can i find how "ReaderT" for example can be expressed as a "Compose f g"?
11:03:16 <ertes> metahumor: not sure what you mean with derivatives
11:03:37 <dminuoso> ertes: By the way - when I was deleting my Store I just stared at the signature of "experiment" and realized... this is very lensey type signature.
11:04:09 <dminuoso> experiment :: Functor f => (s -> f s) -> Store s a -> f a
11:04:12 <metahumor> ertes: i was being too abstract, sorry
11:04:23 <dminuoso> ertes: This is going to be fun! =)
11:04:32 <jle`> @src ReaderT
11:04:32 <lambdabot> Source not found. Maybe you made a typo?
11:04:37 <jle`> @unmtl ReaderT r m a
11:04:38 <lambdabot> r -> m a
11:04:54 <jle`> metahumor: if you rewrite it as ((->) r) (m a)
11:05:02 <jle`> metahumor: then that's just Compose ((->) r) m
11:05:23 <jle`> f (g x) is (f . g) x, or (Compose f g) x
11:05:35 <jle`> i like (:.:) instead of Compose
11:05:49 <jle`> (f :.: g) a, or ((->) r :.: m) a
11:05:50 <ertes> metahumor: i meant it this way: consider monoid morphisms (or arrows in the category of monoids), which are simply functions with a bunch of laws…  you may need to use the underlying operations of the source monoid to define the function, but it may also be completely unrelated to the source monoid other than using the same carrier set, and it just happens to satisfy the laws
11:07:05 <jle`> metahumor: note that even if something can be expressed as Compose f, there might be more than one Applicative instance, and the "canonical" Applicative instance might be different than the one derived using Compose
11:07:15 <ertes> metahumor: extreme example: the morphism from an arbitrary monoid into a singleton monoid: it's just a constant function, and therefore it can live on its own without the source set begin part of a monoid
11:07:16 <metahumor> and that statement, interpreted with jle`'s info about Compose, suggests that "using the underlying operations" is what determines the Monad constraint, and i don't need to, i can retain just the Applicative constraint
11:07:38 <ertes> metahumor: monad transformers are the same way
11:08:17 <ertes> dminuoso: not sure if it satisfies the lens laws, but yeah, it definitely has a lensy shape =)
11:08:29 <metahumor> @unmtl StateT s m a
11:08:29 <lambdabot> s -> m (a, s)
11:08:47 <metahumor> because the s is both on the LHS and RHS, that is why it can't be the product of a Compose?
11:08:55 <jle`> StateT cannot be expressed as a composition of some functor with 'm'
11:09:02 <jle`> it just doesn't fit the shape
11:09:37 <jle`> (->) s (m ((,) s a))    (with some rearranging)
11:09:47 <jle`> i guess it's ((->) s :.: m :.: (,) s)
11:10:18 <ertes> metahumor: BTW, there is a monad morphism that is very similar to monoid morphisms into a singleton monoid
11:10:43 <ertes> metahumor: data Unit a = Unit
11:10:47 <ertes> err
11:10:51 <ertes> metahumor: data Unit m a = Unit
11:10:59 <jle`> actually since all of ((->) s :.: m :.: (,) s) are Applicative with Monoid s, you can write an instance with only Applicative and Monoid s for StateT s m
11:11:07 <jle`> but that'd be different than the canonical Applicative instance for StateT s m
11:11:17 <jle`> which doesn't use Monoid s
11:11:30 <phadej> that would be combination of reader and writer
11:11:34 <phadej> which would do differnet thing
11:11:59 <metahumor> jle`: sketchily, f <*> a = StateT (s <> s') m (f' <*> a')?
11:12:02 <phadej> more of RW a = RW (r -> (a, s))
11:12:14 <phadej> RW r w a = ...
11:12:30 <jle`> metahumor: it'd still be Blah (s -> m (a, s))
11:12:34 <metahumor> i mean, with this noncanonical instance
11:12:44 <jle`> it'd still be a function
11:13:09 <jle`> but yeah, it's essentially (Reader s :.: m :.: Writer s)
11:13:54 <metahumor> jle`: f <*> a = StateT \s -> (exec f s <> exec a s) m (eval f s <*> eval a s)?
11:13:56 <jle`> i'm guessing that the behavior is that all sequenced actions use the same original 's'
11:14:08 <jle`> and the resulting (a, s) is the mappend of all resulting s's
11:14:13 <metahumor> remove the m in there
11:14:29 <metahumor> i wrote it in the typesig order, but you see what i mean
11:16:19 <jle`> i can't quite read what you wrote but i'm going to give you the benefit of the doubt
11:18:15 <batman_> jle` : couldn't print inside a do block
11:18:47 <jle`> same
11:19:12 <batman_> jle` : ??
11:20:10 <metahumor> jle`: f <*> a = StateT $ \s -> (evalStateT f s <*> evalStateT a s, execStateT f s <> execStateT f s)
11:20:19 <jle`> batman_: i'm expressing my emphathy
11:21:23 <jle`> metahumor: i see what you mean
11:21:35 <jle`> (and what you wrote almost typechecks)
11:21:38 <metahumor> i guess that doesn't work because the tuple is not inside the "m"
11:22:13 <dminuoso> batman_: It's not the "do block" that enables IO.
11:22:19 <dminuoso> batman_: do-notation is just syntax sugar.
11:23:18 <jle`> batman_: did you have a question?
11:23:24 <batman_> dminuoso : i didn't say it does i said i have some code inside multiple do blocks and i couldn't print even hard coded string
11:23:46 <jle`> can you show some code?
11:23:56 <metahumor> :t \f a -> StateT $ \s -> let f' = runStateT f s in let a' = runStateT a s in (\(f'', fs) (a'', as) -> (f'' a'', fs <> as)) <$> f' <*> a'
11:23:57 <lambdabot> (Monoid b, Applicative m) => StateT b m (t -> a) -> StateT b m t -> StateT b m a
11:24:12 <metahumor> that typechecks and has the signature you said it would
11:24:20 <jle`> yeah that looks right to me
11:24:27 <batman_> jle` : http://lpaste.net/362707
11:24:38 <jle`> but yeah, that's exactly the instance you'd get with (Reader s :.: m :.: Writer s)
11:25:01 <jle`> batman_: what's the error?
11:25:35 <batman_> jle` : there is no error but its not printing what i'm asking it to
11:25:42 <jle`> what does it print instead?
11:25:51 <batman_> jre` : nothing
11:26:18 <jle`> maybe the chan is empty?
11:26:30 <jle`> or maybe the map doesn't contain (snd msg) ?
11:26:42 <jle`> are you sure it's going down that branch??
11:26:59 <batman_> jle` : even when i'm trying to print say print "hello world.." it won't print
11:27:12 <jle`> where are you putting print "hello world"
11:27:30 <jle`> it might be that the code doesn't reach whatever branch the print is happening in
11:27:49 <jle`> for example: if (4 < 2) then print "hi" else return ()
11:27:51 <jle`> will never print "hi"
11:28:02 <jle`> since 4 will never be less than 2
11:28:06 <batman_> jle` : i doubt it could be the case let me check
11:28:45 <metahumor> batman_: in your "else do" branch, "temp" is Nothing, you can just write "temp3 = [fst msg, fst msg]"
11:31:40 <batman_> metahumor,jle` : i have put a print "hello" at all the 3 branches but still it won't print anything
11:32:10 <jle`> batman_: maybe readChan is blocking
11:32:15 <metahumor> iirc readChan is blocking until it receives something
11:32:27 <jle`> put a print statement right before line 5
11:32:30 <jle`> see if it ever gets there
11:33:38 <batman_> jle` : again nothing
11:33:44 <jle`> ah yes
11:33:56 <jle`> so peerChan or kbChan are still waiting for input
11:34:10 <jle`> control won't proceed until they get input
11:34:17 <jle`> until there are contents in the chan
11:34:59 <batman_> jle` : which input are you talking abt
11:35:11 <jle`> peerChan and kbChan are waiting for items in the Chan
11:35:24 <jle`> er, readChan peerChan and reacChan kbChan
11:35:34 <jle`> they are waiting for items to be put into the Chan
11:35:47 <jle`> before they give you msg/kb
11:35:48 <batman_> jle` : okay
11:36:04 <jle`> so it won't proceed until there are items in the Chan
11:36:25 <batman_> jle` : alright, Thanks Man. !
11:36:30 <jle`> no problem
11:46:04 <okuu> Does Haskell's standard library have anything like “product”, but which short-circuits when the accumulator is zero?
11:46:16 <okuu> (Of course, I expect it to have an Eq constraint in the type.)
11:47:20 <cocreature> okuu: no
11:48:07 <okuu> Okay, then how do I define a strict recursive function?
11:48:25 <cocreature> use `seq` or bang patterns
11:48:26 <davean> okuu: checking the equality often would be slower then doing the operation I'll warn you
11:48:45 <cocreature> well it depends on the lists you expect as input
11:49:04 <cocreature> if you have very long lists and expect zeros early in those lists then it can definitely pay off
11:49:04 <davean> Right, "often"
11:49:14 <cocreature> oh I missed that :)
11:49:21 <okuu> davean: Not when I'm multiplying sorted lists of primes modulo 10^9.
11:49:41 <cocreature> okuu: primes are not 0?
11:49:50 <okuu> Errr...
11:49:54 <kadoban> mod 10^9 they can be
11:50:05 <cocreature> kadoban: fair enough but you can easily check for the few that are :)
11:50:15 <okuu> I mean, lists of [primes in Z] modulo 10^9, of course.
11:50:27 <kadoban> Ya
11:50:34 <metahumor> wouldn't anything ~ 0 mod 10^n be divisible by 10?
11:50:35 <Tuplanolla> Of course primes are not zero modulo anything, but their products can be.
11:50:41 <metahumor> oh their products okay
11:50:45 <kadoban> Right
11:51:11 <kadoban> I knew something sounded off there, haha.
11:51:13 <davean> okuu: depends, if you're using a primative type for the CPU ... Conditionals are expensive for CPUs
11:51:46 <davean> But I don't you're coding it that tightly, yes
11:53:00 <metahumor> okuu: when you're saying "multiplying lists", is it like an outer product or what?
11:53:38 <okuu> metahumor: I mean, multiplying the contents of lists of primes.
11:53:46 <amalloy> metahumor: we're just looking for a version of: product [n1, n2, n3] `mod` 10^9 that can short circuit
11:54:29 <kadoban> You could make an instance of Num that would, if GHC was nice to you, right? Or ... hmmm.
11:55:14 <metahumor> lift multiplication into Maybe, have a newtype a la First that terminates on 0
11:57:05 <cocreature> or just write the boring loop
11:58:23 <pikajude> ugh, wtf is wrong with hackage
11:58:45 <pikajude> To use multiple 'library' sections or a named library section the package needs to specify at least 'cabal-version >= 1.23'.
11:58:48 <pikajude> but i am
11:58:50 <pikajude> why does it say this
12:00:15 <cocreature> pikajude: can you show us the cabal file?
12:00:37 <MarcelineVQ> and whether you're using stack and what version :>
12:01:02 <cocreature> I don’t see how stack has anything to do with an error message thrown by hackage
12:01:23 <MarcelineVQ> boop, skipped over the hackage line, hehe
12:01:52 <merijn> Wut? Cabal supports multiple library sections now?
12:02:00 <hyperisco> is there a package with rings?
12:02:06 <cocreature> merijn: internal libs only
12:02:11 <merijn> cocreature: Still!
12:02:29 <merijn> cocreature: My current code qualifies :p
12:02:51 <merijn> cocreature: Because that'd mean I can separate the ugly TH stuff from the rest of my lib and improve recompile times!
12:03:06 <pikajude> you sure can!
12:03:08 <pikajude> cocreature: one second
12:03:29 <pikajude> let me make sure this package does still actually build
12:04:43 <hyperisco> because if you have a ring, then  0 * x = 0  and hence it must short-circuit
12:05:21 <dminuoso> ertes: Well. Im up to 10k generations per second. I think this is acceptable =)
12:06:39 <MarcelineVQ> dminuoso: now you can think about multithreading :>
12:06:39 <hj> ['d'..'a'] == [4..1] what is the answer for this?
12:06:55 <MarcelineVQ> False
12:06:58 <glguy> probably a type error
12:07:01 <hj> why
12:07:10 <cocreature> because Char is not an instance of Num
12:07:18 <glguy> But if it was then it would be true
12:07:21 <glguy> because [] == []
12:07:28 <hj> so both lists cannot be compared?
12:07:32 <hj> that is why
12:07:43 <cocreature> you can only compare lists of the same type
12:07:48 <glguy> :t (==)
12:07:49 <hj> thnks
12:07:50 <lambdabot> Eq a => a -> a -> Bool
12:07:53 <glguy> > ['d' .. 'a']
12:07:55 <hj> its a type error
12:07:55 <lambdabot>  ""
12:08:17 <hyperisco> the answer is in another castle
12:09:36 <qeyoa> what, or how would i need to input into this function: http://lpaste.net/362711 to get `Nothing` out of it. Anything other than int returns an error to me when evaluating in a repl
12:10:01 <jle`> qeyoa: something where the second input is 0
12:10:06 <jle`> safediv 100 0
12:10:12 <glguy> qeyoa: Don't type that definition one line at a time into the repl
12:10:15 <glguy> the repl isn't a file
12:10:21 <qeyoa> ah right
12:10:27 <glguy> line 3 is overwriting line 2 altogether
12:10:43 <qeyoa> no, the definition is in emacs file
12:10:44 <qeyoa> glguy
12:10:49 <qeyoa> emacs has a repl open
12:10:54 <qeyoa> which has the definition
12:10:59 <qeyoa> loaded with a shortcut
12:11:09 <glguy> OK, then what jle` said
12:11:29 <qeyoa> yep
12:11:30 <qeyoa> works
12:14:25 <Akii> I just checked Hackage to hope to find the implementation of Alternative STM but there was no link to the source. Why is there no link to sources sometimes?
12:15:31 <Akii> in the hope to*
12:15:33 <Akii> :D
12:16:38 <cocreature> Akii: there is a source link in https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Conc.html#t:STM
12:16:47 <pikajude> whoops, almost forgot
12:16:52 <cocreature> Akii: iirc haddock doesn’t generate source links to instances for reexported types
12:17:17 <pikajude> cocreature: https://github.com/pikajude/stylish-cabal/blob/master/stylish-cabal.cabal
12:17:42 <Akii> ha, at least my guess what it was doing was right :D
12:18:09 <Akii> first fromMaybe, now <|> -- it's a pattern now
12:18:34 <cocreature> pikajude: hm I don’t see anything obvious. maybe try asking in #hackage
12:18:38 <Akii> was trying to `STM (Maybe a) <|> STM (Maybe a)`
12:18:48 <pikajude> i probably should have just thought of that bh
12:18:49 <pikajude> tbh
12:21:14 <vapula> hi, anybody managed to build barrelfish?
12:23:44 <ertes> dminuoso: i'm going to write an implementation of my own for fun…  maybe you can use it to learn =)
12:24:09 <Denommus> where can I get help for haskell-ide-engine?
12:24:33 <Denommus> I get a timeout for everything I try to do, plus "Error from the Language Server: IdeError {ideCode = PluginError, ideMessage = "getSymbolAtPoint: \"module not loaded\"", ideInfo = Null} (Internal Error)"
12:24:34 <woodson> Hi guys, whats the difference between http client and http conduit?
12:25:34 <Akii> woodson  one difference is that http-conduit exposes Network.HTTP.Simple which offers a really simplified HTTP client
12:26:32 <Bowlslaw> trying to understand Cons() with Scala somehow didn't click. But with haskell(Hutton) it's so much better, and I don't know if it's because I had a first exposure, or Haskell and Hutton's explanations are that much better than Odersky's
12:26:36 <woodson> Akii: So it just offers a more simple API?
12:26:43 <cocreature> Denommus: try #haskell-ide-engine
12:27:14 <Akii> woodson  I'd assume it also offers conduit integration but never checked that out
12:27:34 <Denommus> cocreature: thanks
12:27:48 <woodson> Akii: I want a build a small library that allows interaction with salesforce's platform so thats why I am looking into it
12:29:06 <Akii> woodson  so it's about library coupling and interfaces? If so, maybe a good way would be to rely on http-types instead?
12:29:39 <Akii> that would make your lib say "do a http request with following method, headers, payload" instad of saying: I'm gonna use this lib to do it
12:30:14 <Akii> (probably http-client is a sane default implementation though)
12:34:05 <Akii> this already looks strange xD http://lpaste.net/362713
12:34:30 <Akii> but hey, that's a pattern, right? Gotta have a name
12:37:15 <shadoko> Hi. Sorry if this is the wrong place to ask. Please point me to a better place if there is such. I have managed to completely blow up my Haskell installation on Arch Linux. This doesn't look healthy: https://paste.gnome.org/pes5yiawx I guess I'd better start from scratch, but I find myself unable to totally uninstall everything.
12:37:24 <shadoko> I have tried to -Rns and -Rcs ghc but the base package doesn't seem to come back afterwards.
12:52:01 <lyxia> shadoko: It's probably not your fault, Haskell on ArchLinux is notoriously broken.
12:52:33 <lyxia> https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
13:04:11 <woodson> Akii, sorry got interrupted. I looks a lot like servant lol
13:08:38 <Akii> woodson  what looks like servant?
13:09:33 <woodson> the lpaste that you showed me
13:10:21 <woodson> http-type uses types to represent the action that needs to be performed?
13:10:45 <Akii> ah sorry, that lpaste was unrelated to your question
13:10:57 <Akii> http-types just are.. types
13:11:32 <woodson> so I would need to couple it with http-client or http-conduit?
13:11:50 <metahumor> these "filtering" exercises in the data61 course are great
13:11:54 <woodson> there isnt much doc...
13:12:01 <dminuoso> metahumor: The funny thing is, there's more haskell talk in -ot than in here.
13:12:05 <metahumor> why is "filtering" not exported by any base or related library
13:12:13 <metahumor> dminuoso: trying to rectify that
13:12:37 <Akii> woodson the idea would be to describe what the user of your library has to do, in http types
13:13:14 <Akii> woodson  but just use http-client if that is unclear; I really think that's a decent default (anyone correct me on this)
13:13:18 <metahumor> oh, "filtering" == "filterM"
13:31:56 <tangled_z> Hey, how could I define a type which has a constrained parameter? ie type NumericList :: (Num a) => List a
13:32:20 <tangled_z> is that a thing in Haskell, or do you need dependent types for that?
13:33:02 <phadej> type NumericList :: forall a. Num a => [a]
13:33:51 <hj> http://lpaste.net/362716 can someone help me with this code
13:33:58 <hj> reversing of the string
13:34:10 <Akii> well or `type NumericList a :: (Num a) => [a]` with RankNTypes
13:34:12 <glguy> That syntax isn't quite right, should :: be a =? Also that won't really do what the question aske
13:34:42 <glguy> tangled_z: The types don't get constraints, value definitions using the types do
13:35:13 <jle`> tangled_z: yeah, that's not really a 'thing'; usually the constraints would go on the functions or values that use NumericList
13:35:27 <tangled_z> glguy: value definitions? you mean data constructors?
13:35:29 <glguy> Using the ExistentialQuantification extension you can make a type whose values carry around constraints, but it's probably not going to help with whatever it is you're trying to do
13:35:35 <glguy> tangled_z: no
13:36:13 <tangled_z> glguy: I'd like to build a type that's constrained by a functor
13:36:27 <metahumor> hj: have you tried anything at all, or is this the beginning of your problem?
13:36:48 <glguy> tangled_z: What's the type?
13:36:50 <hj> i m not geetting the last missing part
13:36:55 <hj> for reversing the string
13:38:08 <tangled_z> glguy: something like.... type L a b = Functor a => L a b
13:38:35 <jle`> tangled_z: that's actually a recrusive type synonym
13:38:40 <glguy> tangled_z: The Functor part will come up later when you try to use your type
13:38:54 <glguy> thing_using_l :: Functor a => L a b -> Int -> Bool
13:39:21 <metahumor> hj: you have "rev l = f [] l" and are trying to write an "f". you already have "f al [] = al". what does "rev" do to the "l"?
13:39:24 <tangled_z> glguy: ah yeah, that makes sense
13:39:43 <tangled_z> jle': ah, sorry, it wasn't meant to be recursive
13:39:55 <tangled_z> jle': data L a b = Functor a => L a b
13:40:13 <jle`> ah.  yeah, in that case, you'd constrain 'a' wherever you use it
13:40:27 <jle`> a common example of this principle is in 'containers', in its Data.Map api
13:40:40 <jle`> a Map can only use instances of Ord as keys
13:40:50 <jle`> but rather than constraining this in the type itself, it has the constraint in functions on that type
13:41:08 <jle`> insert :: Ord k => k -> a -> Map k a -> Map k a
13:41:46 <hj> <metahumor> rev reverses l
13:42:22 <tangled_z> jle`: ah yes, that makes sense as a way of doing it
13:42:32 <jle`> or Set, as well -- fromList :: Ord a => [a] -> Set a
13:43:08 <jle`> one interesting consequence is that it also tells the user what aspects of that type a function wil use
13:43:44 <tangled_z> oh? so if your type has two constraints, a function on it could only have one of those constraints?
13:43:58 <metahumor> hj: okay, rev reverses l. how do we access elements of l?
13:44:02 <jle`> well, ther's fmap :: (a -> b) -> Map k a -> Map k b
13:44:13 <jle`> the lack of an Ord constraint tells you that the Map doesn't rearrange its structure
13:44:29 <jle`> size :: Map k a -> Int
13:44:40 <jle`> the lack of an Ord constraint tels you that it doesn't look at the keys in any way
13:44:50 <tangled_z> ohhh i see, that's pretty neat
13:46:08 <metahumor> could another explanation of the type thing be, if the constraint was on the type, then we'd have "insert :: k -> a -> (Ord k' => Map k' a) -> (Ord k'' => Map k'' a)" where there is no way to link k - k' - k''?
13:46:31 <tangled_z> i suppose the downside is that you don't discover the constraints on the type until you look at the functions using that constraint
13:46:43 <hj>  metahumor: so we directly write function f ?
13:48:13 <metahumor> hj: writing the body of "f" is the problem here. my hint to you is, you have to consider when "l" is of the form "(x:xs)". where are you going to put the "x"? what will you do with the rest of the "xs"?
13:50:10 <hj> metahumor f al xs :x ??
13:50:14 <hj> is this correct?
13:50:38 <jle`> metahumor: you can still use a type signature to constrain that the first and second and third and fourth k's are the same
13:51:18 <jle`> but also even if you could do it, then you wouild either have to require an Ord constraint on insert anyway (to let the user know), or not require an Ord constraint (and have the constraint be invisible and not realized until a compile error)
13:51:23 <jle`> so there's really no benefit
13:51:57 <metahumor> hj: can you write your version of f as an expression "f al (x:xs) = ..."?
13:52:16 <metahumor> jle`: yeah, that "require an Ord constrain on insert anyway" is kinda what i was getting at
13:52:29 <metahumor> it factors out into a constrain on the entire function
13:52:35 <jle`> sorry for all the pings user k
13:52:46 <k> no problem
13:53:05 <metahumor> users "lens" and "implementation" get so many pings
13:54:32 <phadej> the _rare_ false positives are weird
13:54:50 <phadej> you know, when you are pinged once in a week, and then it's not really for you
13:55:18 <jle`> i get false positives all the time on #assembly
13:55:20 <phadej> yet, so far it's been mostly good things to read, so I don't mind
13:55:46 <[Leary]> so must get the most
13:55:52 <yoda___> Hello world!
13:56:01 <jle`> cause i am jump-if-less-than-or-equal-to
13:56:06 <dr_gois> Hello everyone. Do anyone know whether it is a good idea to use Haskel instead of MATLAB or Python(Numpy/SciPy) or Julia to perform time-series analysis and other heavy statistics; such as deep learning algorithms, ODE simulations, so on and so forth? :) Thanks!
13:56:12 <jle`> sorry for explaining the joke
13:56:28 <yoda___> lmao he left
13:56:56 <yoda___> And he came back
13:56:58 <metahumor> dr_gois: it is a good idea!
13:57:12 <yoda___> Do you all use Haskell or are you just in the channel to chat?
13:57:34 <jle`> dr_gois: check out some of the info on http://datahaskell.org/docs
13:57:42 <jle`> and https://gitter.im/dataHaskell/Lobby
13:58:30 <jle`> my personal take (and i've been doing this for many years now, for my own phd research) is that the ecosystem isn't quite at the same place, but there are a lot of benefits
13:58:34 <Muffin> Listen to the lecture hoe
13:58:36 <jle`> chiefly in maintainability
13:58:52 <yoda___> What is haskell used for nowadays?
13:58:53 <jle`> and long-term projects
13:58:56 <yoda___> Aside from research
13:59:06 <mrmorais> Hello, everyone!
13:59:10 <yoda___> Hello mrmorais
13:59:20 <jle`> yoda___: most things that you'd use other general-purpose programming languages for, actually
13:59:33 <jle`> yoda___: web, finance, data analytics, crypto, etc.
13:59:49 <jle`> front and back ends, games
14:00:15 <yoda___> Really jle?
14:00:30 <jle`> yes really
14:00:31 <yoda___> Haskells seems like a dead old language atm
14:00:44 <jle`> hm, where are you getting that impression from?
14:00:51 <jle`> haskell drives facebook's spam engine
14:00:58 <yoda___> Oh shiet really?
14:01:14 <jle`> yeah, and some big financial instuitutions are using it
14:01:20 <yoda___> I spend more time floating around java idk :\
14:01:29 <tangled_z> Oh, that reminds me where ive seen your name before, jle`. you're the guy that made Auto, right?
14:01:34 <jle`> it might just be the company you keep
14:01:37 <jle`> tangled_z: yeah that's me :o
14:01:53 <jle`> yoda___: do you think python is a dead old language?
14:02:20 <tangled_z> ahah that's great :D i enjoyed the library. hadn't had a chance to use it for anything real world yet but i have hopes
14:02:27 <tangled_z> are you still actively working on it?
14:02:29 <jle`> thanks! :)
14:02:37 <yoda___> Python is brought up everywhere in ml and nlp etc (sorry, don't know how to tag welp)
14:02:58 <jle`> and no i am not :o  it's been a while heh, and a lot of times auto is a bit too specialized for the stuff i'm doing now
14:03:33 <tangled_z> Oh that's a shame.
14:03:44 <tangled_z> Too specialised? ie the primitives are not expressive enough to capture your new domain? (physics?)
14:03:45 <mrmorais> i'm starting now with that functional thing and I'm wondering about how functional programming languages in general are compiled...
14:04:10 <jle`> tangled_z: i mean, the model/semantics aren't always applicable/best in some situations
14:05:07 <tangled_z> jle`: uhm, makes sense. do you find that the alternative is a different kind of FRP system, or something that's not-FRP at all?
14:05:28 <mrmorais> i mean, the compiler has to make a low level code ya? so.. are not these low level languages (such as Assembler) imperatives?
14:05:49 <shapr> mrmorais: there's a really large answer, and a bunch of smaller answers
14:05:52 <jle`> tangled_z: i'm just in places these days that don't benefit much from FRP :)
14:06:07 <jle`> mrmorais: compilers often target imperative algorithms yes
14:06:13 <shapr> I'd say, GHC rewrites the source into an intermediate language called Core, and that is turned into executable code.
14:06:22 <dr_gois> thank you <jle`>; do you know if there is any fancy IDE such Jupyter Notebook for Haskell?
14:06:23 <jle`> mrmorais: but compare this to the act of rendering a vector image
14:06:38 <jle`> mrmorais: all vector images are eventually rasterized into pixels
14:06:38 <tangled_z> jle`: eheh i see :)
14:06:44 <shapr> dr_gois: there's IHaskell, which is Haskell inside Jupyter
14:07:11 <shapr> I think JupyterLab supports Haskell, but I haven't tried that myself, only IHaskell
14:07:25 <dr_gois> Great, so I can put haskell along side of my ipython notebook installation? I will go deep into that.
14:07:37 <jle`> i tink one of the main maintaners for that is in this channel
14:08:31 <dr_gois> Nice, I have just entered into Computer Science Bachelor in the university and a professor of mine just told me about functional programming and Haskell...
14:08:50 <mrmorais> jle shapr i got it...
14:09:02 <dr_gois> I am planning what project I'd like to implement with it.
14:09:18 <jle`> dr_gois: overall i've been giving the same answer i have about haskell for numeric computation for a while: the ecosystem is "getting there"
14:09:21 <jle`> heh
14:09:23 <sm> mrmorais: I like that question. The compiler presents and uses functional models as long as it can, and ultimately yes it translates it all into imperative instructions that run on our current von neumann style processors
14:10:03 <jle`> i wouldn't recommend it for your first haskell project, or your first data anyltics/statistics programming experience, necessarily
14:10:18 <dr_gois> Thanks for your attention, last question before I go dive into reading the web...
14:10:19 <jle`> other languages wher ethe ecosystem is established would be a smoother ride
14:10:31 <dr_gois> What about if I want to become a fullstack web development?
14:10:39 <jle`> but if you are familiar already with haskell or with data analytics (at least oen of the two)), ther eare some nice concrete benefits to be gained from using haskell
14:10:45 <dr_gois> With IPFS altogether
14:11:11 <jle`> i mean, people are doing "full stack" in haskell today
14:11:23 <jle`> you'll find some supportive communities
14:11:45 <jle`> it's still not the most frictionless option, but there are lots of concrete benefits from using haskell over other languages too
14:11:52 <mrmorais> (sm) nice. so it is a kind of hardware implications that is necessarily imperative
14:12:09 <metahumor> bring back lisp machines
14:12:46 <jle`> mrmorais: you can think of it this way -- writing in haskell is about *describing* a program in a functional/pure way
14:12:55 <sm> metahumor: how did those work.. were they non-von-neumann ?
14:12:55 <dr_gois> Thank you jle` and shapr! :) I hope to come again with good news.
14:12:57 <jle`> mrmorais: the compiler's job is to interpret the thing you described, and realize it
14:13:05 <dr_gois> cya.
14:13:08 <shapr> dr_gois: how does IPFS fit in?
14:13:30 <jle`> mrmorais: just like how an artist can listen to your "declarative" description, and then go and paint it
14:13:34 <jle`> dr_gois: happy haskelling!
14:13:58 <jle`> mrmorais: if i tell someone to draw a specific scene, i won't describe the step-by-step of how to paint that scene; i'll tell them the features i want
14:14:13 <tangled_z> that's pretty poetic.
14:14:14 <jle`> mrmorais: and then that person translates the features that i want to an i"imperative algorithm"
14:14:23 <jle`> an imperative process of generating that painting
14:14:46 <metahumor> sm: von-neumann but with hardware backed type checking, for example
14:14:56 <mrmorais> jle`: goood. i got it
14:15:02 <mrmorais> ( jle` shapr sm ) thank you, guys. it was clarifier
14:15:48 <wrengr> does anyone have an idea how safe/reliable GHC.Base.getTag is?
14:16:15 <wrengr> i.e., is it on par with GHC.Prim.isTrue# ?
14:16:44 <wrengr> or is it more in the ballpark of reallyUnsafePointerEquality?
14:16:56 <tangled_z> oh, jle`: did you investigate using lenses with auto/frp? is that straightforward?
14:17:18 <jle`> hm, i'm not sure exactly what the question was about it in the beginning
14:17:36 <jle`> i am probably today much more in a position to answer those questions though than i was three/four years ago
14:17:52 <jle`> it's been a while :)
14:18:47 <jle`> oh hey, almost three years ago
14:19:18 <tangled_z> no way xD you have logs going back that long?
14:20:12 <freeman42x]NixOS> is it possible to configure stack repl prompt? it is not picking the ~/.ghci settings
14:22:14 <tangled_z> oof, time flies. i'm not sure what the question was at the time either, but I am curious about the general approach.
14:22:20 <dr_gois> shapr: I am planning to make my private data sharing
14:22:45 <tangled_z> i am surprised you still remember that xD
14:22:57 <dr_gois> shapr: So IPFS would will be used as the protocol of stocking the data, I am still a student - still planning the project.
14:35:02 <freeman42x]NixOS> https://stackoverflow.com/q/48895340/750216
14:38:07 <hpc> so what's the threshold for being reallyUnsafe as opposed to merely unsafe?
14:39:15 <Guest59636> Hello, is it possible to makeLenses for a parameterized type like "Section a" ? or even for the concrete type "Section Library"
14:40:53 <glguy> Yeah: makeLenses ''Section
14:40:57 <nood> hi all, I'm a bit confused with number types. I have a Signal type and and want to write a function that can take a signal, a number, and return a signal whose input of time has been scaled (multiplied) by the number. Code here: https://pastebin.com/7t1epACB, I know why it doesn't work but I don't know what I can do to fix it
14:42:44 <dr_gois> Did anyone userd Yesod Web Framework? Do anyone have any cons? Other suggestions?
14:44:00 <amalloy> nood: sounds like you shouldn't take a Signal b, but a Signal Time
14:45:30 <nood> amalloy: what if I have a Signal Double and want to use it to modulate another signal's rate?
14:46:00 <amalloy> arithmetic operations require that the two operands be of the same type, so you will need to convert at some point
14:58:29 <dkremer_> Hi
14:59:57 <srk> heh, finding longest common asceding sequences in a list is quite challenging :D
15:00:22 <srk> I have allConts = filter continuos . concatMap tails . inits
15:00:34 <kadoban> Is that like a mix of longest-increasing-sequence and longest common subsequence?
15:00:36 <srk> but how to get only the unique longest ones
15:00:44 <srk> possibly
15:01:49 <srk> like I have a set of missing indices that I need to group if the subsequence is increasing
15:02:17 <srk> [1,2,5,6,7] to [(1, 2), (5,3)]
15:03:01 <kadoban> Oh, it's like ... grouping runs with no missing numbers or something?
15:03:31 <srk> yeah
15:04:46 <srk> lol, just realized I need to do the reverse as well, that should be easier
15:05:11 <kadoban> Hm, I can't think of a great way to do that in terms of lower level stuff efficiently. I guess I'd just write a recursive thing
15:08:04 <dkremer_> srk: it looks like strings pattern matching problem
15:08:56 <dkremer_> O(n) solution exists if I understood your problem correctly
15:09:34 <srk> it should but not strictly needed
15:10:11 <srk> filter continuos . concatMap tails . inits is already O(n**3) or something :D
15:10:24 <dkremer_> clearly your algo is not  O(n). use an accumulator and go over the list
15:11:00 <srk> will try
15:11:19 <dkremer_> typically a single for loop do the trick.
15:11:49 <dminuoso> srk: srk where does that "3" come from in your result?
15:12:02 <srk> dminuoso: the length of the second sequence
15:12:11 <dminuoso> srk: ah
15:13:08 <srk> think I can do takeWhile continuos (inits x)
15:13:38 <srk> repeatedly, grouping the continuos sequences one by one
15:14:35 <bash0r> Let's say I append an element to a list with something similar to ys = xs ++ [x]. After that I pattern match on ys but I all I care about is the head of the list. Does xs ++ [x] compute as a whole or does Haskell thunk the computation of the tail of ys?
15:15:10 <srk> it does
15:16:14 <bash0r> I hope for the thunk. Please tell me it's the thunk.
15:16:18 <dminuoso> bash0r: Haskell represents lists through cons.
15:16:55 <bash0r> dminuoso: I know how Haskell's lists work. Though, I'm not so sure about it's thunking mechanism.
15:17:00 <dminuoso> bash0r: Oh wrong perspective. Haskell is lazy and only evalutates up to WHNF.
15:17:05 <jle`> bash0r: what is ys?
15:17:15 <jle`> oh i see
15:17:22 <jle`> bash0r: yes, look at the definition of (++)
15:17:30 <bash0r> Thanks for clarification everybody.
15:17:36 <jle`> haskell won't evaluate (xs ++ [x]) until it has to
15:17:53 <bash0r> Then I could get away with my plans. :D
15:17:55 <jle`> and when it does, it looks at the defnition of (++)
15:18:05 <jle`> and the definition of (++) involves traversing all of xs
15:18:33 <jle`> it doesn't force the contents of xs, but it forces the spine, and re-allocates all of xs
15:18:50 <jle`> oh wait, sorry, i misread
15:18:54 <jle`> @src (++)
15:18:54 <lambdabot> []     ++ ys = ys
15:18:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:18:54 <lambdabot> -- OR
15:18:55 <lambdabot> xs ++ ys = foldr (:) ys xs
15:19:03 <jle`> yup, it'll get the head right away
15:19:26 <bash0r> and (tail xs ++ [x]) is getting thunked if I read that correctly.
15:19:41 <jle`> yes, on the other side of the :
15:19:52 <jle`> (x:xs) ++ [y] ==>  x : (xs ++ [y])
15:19:52 <bash0r> So asking for head (tail ys) will compute the second element.
15:20:04 <jle`> yes
15:20:05 <Bowlslaw> shoes and ships and sealing wax, and cabbages and kings
15:20:17 <jle`> the simplest way to answer these is to just get a pen and paper
15:20:24 <jle`> and start stepping out the evaluation of functions like (++)
15:20:28 <bash0r> That's awesome. Thanks!
15:20:48 <bash0r> I just wanted some confirmation of my thinkings. :)
15:21:06 <jle`> also maybe some ghci work can help
15:21:19 <jle`> > head ((1 : undefined) ++ [4])
15:21:21 <lambdabot>  1
15:21:47 <bash0r> Ohh, using bottom to see if something gets actually evaluated is eval. :p
15:21:57 <bash0r> evil *
15:22:32 <jle`> yeah it can be a nice trick :)
15:22:43 <bash0r> I'll try to remember that one.
15:22:44 <jle`> like having ghc ply minesweeper
15:23:08 <bash0r> Haha, go GHC. One more step... Boom. ^^
15:23:08 <jle`> *play
15:23:19 <jle`> or i suppose it's us playing mine sweeper
15:23:40 <jle`> > let xs = undefined : 1 : sum [0..] : 3 : undefined in (xs !! 1, xs !! 3)
15:23:40 <bash0r> A nice game, anyway!
15:23:42 <lambdabot>  (1,3)
15:23:46 <jle`> > let xs = undefined : 1 : sum [0..] : 3 : undefined in (xs !! 1, xs !! 2)
15:23:47 <jle`> ^ oops
15:23:52 <lambdabot>  mueval-core: Time limit exceeded
15:24:59 <bash0r> It took me quite some time to spot the difference. ^^
15:25:07 <bash0r> I'm definitely too tired.
15:25:19 <bash0r> Have a nice day / evening everybody!
15:25:22 <jle`> you too!
15:39:12 <astralemp> I'm running ghci in a nix-shell and it's failing to load my modules. how do I diagnose this problem?
15:47:46 <Digit> heard a good one, had to /j #haskell to share (you've probably all heard it before): "Haskell isn't side-effect-free after all; the effects are all just concentrated in this one computer in missouri that non one's checked on in a while."  XD
15:48:03 <jackdk> astralemp are you using a pure shell?
15:48:06 <Axman6> that's from the latest XKCD
15:48:36 <metahumor> that xkcd also had a joke about an upcoming CVE for haskell too
15:48:44 <kadoban> Not bad. Portrait of Dorian Haskell kind of vibe
15:49:20 <Digit> ah, thnx.  i just saw it in a partial scrot with just that line.  the font should have been my clue.
15:49:58 <kadoban> I wonder if xkcd made/uses a font for those, or if he really draws those
15:50:18 <kadoban> They *look* nonuniform, but I guess that's not really definitive
15:50:36 <metahumor> i think he draws them
15:51:01 <kadoban> https://xkcd.com/ some of those are not bad
15:51:53 <astralemp> jackdk the shell is loading from three separate projects, and each of their external dependencies seem to be loading fine. it's just my modules that aren't getting loaded, from any of them.
15:52:13 <astralemp> jackdk https://github.com/ElvishJerricco/reflex-project-skeleton <-- I'm using this structure
15:53:44 <astralemp> `nix-shell -A shells.ghc' followed by `ghcid "--command=ghci path/to/FrontendMain.hs"'
15:59:50 <jackdk> I don't really know the reflex scaffolding stuff, sorry :S
16:01:32 <HairyDude> Is there a TH library function that foldr's a bunch of types together with (->)? infixT doesn't seem to work
16:08:25 <jle`> kadoban: he draws them, i think i remember reading something he wrote about properly lettering comics too
16:08:33 <jle`> and the best practices/techniques
16:08:51 <jle`> er, i think it was for lettering engineering drawings maybe
16:09:05 <kadoban> Nice. I do find it kind of hilariously impressive that he manages to make his lines look nice.
16:09:06 <jle`> kadoban: anyway, randall munroe is actually known to drop by or idle in #haskell too, so maybe one day we can ask him ourselves :)
16:09:14 <kadoban> Every time I write anything, it looks like total balls
16:09:17 <kadoban> Oh really? That's funny
16:09:41 <jle`> yeah, i think one of his previous interactive comics from several years back was programmed in haskell
16:09:41 <lyxia> HairyDude: use appT and arrowT
16:09:49 <jle`> so he was here asking questions
16:10:02 <kadoban> Hah, I didn't know that, that's pretty cool
16:10:08 <jle`> that's why haskell pops up every once in a while as a joke :)
16:10:18 <jle`> it comes from personal pain lol
16:12:21 <kadoban> lol
16:22:59 <HairyDude> lyxia: yeah, that's what I've ended up doing. Seems like an obvious omission
16:24:19 <HairyDude> lyxia: well actually I used a quasiquote, but it amounts to the same thing
16:45:13 <metahumor> let's say i'm writing the instance for (Applicative f) => Applicative (MaybeT f)
16:45:32 <metahumor> what's better to write? "pure = MaybeT . pure . pure" or "pure = MaybeT . pure . Just"?
16:51:15 <amalloy> metahumor: i don't think either one is way more readable than the other. i suppose i'd choose Just, simply because it's a reminder about what order things are stacked in
16:51:38 <johnw> yeah, when the generality isn't needed, the specificity can aid comprehension
16:51:59 <johnw> unless it doesn't matter what the types are, and only that it's Applicative
16:52:21 <[Leary]> pure . pure is cute though
16:52:35 <bontaq> :3
16:57:56 <jle`> metahumor: how about pure x = MaybeT (pure (Just x))
16:59:11 <metahumor> i think you have a point
16:59:20 <jle`> ;)
17:20:48 <rizraz> ls
17:21:17 <APic> [5.3.1]apic@Zarniwoop:~> ls
17:21:17 <APic> a  c     chr  Feuerzeug  k      m     News  p   t  w
17:21:17 <APic> b  CHAT  e    g          Leech  MusE  o     rc  v
17:21:19 <APic> ;=PPP
17:21:25 <APic> Hi Bowlslaw
17:21:33 <Bowlslaw> Hi APic
17:21:41 <APic> Heya
18:53:59 <aidan> Why can I not use Data.Vector.Vector in a list comprehension?  eg: [x | x<- my_vector]  ?  I can see that Data.Vector doesn't export a <- operator, but why?
18:56:25 <pavonia> There's no <- operator, it's built-in sytnax, AFAIK
18:56:30 <heptahedron> aidan: https://www.haskell.org/onlinereport/exps.html#sect3.11
18:56:39 <heptahedron> aidan: List comprehensions just only work with lists, really
18:57:13 <heptahedron> aidan: I'm sure there's some `toList` function in `Data.Vector.Vector` that would let you do something like `[x | x <- toList myVector]` though
18:58:36 <heptahedron> Does anyone here have experience writing polyvariadic functions? I'm losing my mind here trying to figure out the typeclasses necessary to make what is essentially a convenience method for constructing a heterogenous list
19:02:11 <pavonia> heptahedron: What about using Data.Dynamic?
19:04:40 <heptahedron> pavonia: I'd really rather not if at all possible
19:05:04 <heptahedron> and I'm almost sure it's possible because of https://hackage.haskell.org/package/HList-0.4.0.0/docs/Data-HList-HList.html#t:HBuild-39-
19:05:23 <parsnip> pavonia: the last time i had that urge, i think i used V.enumFromTo
19:05:37 <parsnip> thought, i've used Vector like twice in my life
19:06:37 <parsnip> oh, second time in a row i know i didn't really read the question carefully
19:07:12 <pavonia> heptahedron: Packing up the values is easy, the tricky part is to use them after unpacking
19:07:32 <pavonia> Maybe you want to show what you have so far
19:09:28 <juhp> `let a = blah; b = some blah; c = other blah`  <-- any easy way to hide a ?  I must be missing something obvious
19:10:08 <juhp> ugh wrong example doh
19:10:28 <juhp> I mean `blah = a`
19:10:38 <heptahedron> pavonia: I don't have much of anything at the moment--I've changed it several times now because each attempt seemed to be headed in the wrong direction. I'm about to change it again due to the brevity of what I see in https://hackage.haskell.org/package/HList-0.4.0.0/docs/src/Data-HList-HList.html#HBuild%27
19:10:39 <juhp> and hide blah
19:10:52 <heptahedron> juhp: "hide"?
19:11:20 <juhp> sorry I mean limit the scope of blah
19:11:58 <heptahedron> pavonia: this is what we're looking at though: https://github.com/heptahedron/vinyl-json/blob/49f4bb0c4d367938815cad10c1ccb081cb6dafaa/src/Data/Vinyl/Json.hs#L157
19:12:48 <heptahedron> Ideally, I'd be able to export a function for users that could be called as `mkJRec @rs arg1 arg2 ...`
19:13:07 <heptahedron> though I'm willing to compromise if this isn't possible
19:13:32 <heptahedron> Really, anything to make record construction less verbose without use of TH or other such sins
19:14:07 <heptahedron> juhp: Limit its scope how? What are you trying to achieve, exactly
19:16:39 <juhp> heptahedron: sorry for being terse: I have let statement like above and I want to limit the scope of blah to the let... - (for now I renamed `blah` in my code to distinguish it more from c (blah'))
19:18:44 <heptahedron> juhp: best guess is something like `let (a, b, c) = let blah = whatBlahIs in (makeA blah, makeB blah, makeC blah) in stuffUsingABAndC`
19:19:44 <juhp> heptahedron: ah right, thanks
19:20:32 <pavonia> heptahedron: Uh, I'm not used to this '(..) syntax, so I probably can't help here, sorry
19:23:16 <juhp> it would be nice if there was something like let .... where ....
19:23:52 <heptahedron> pavonia: I appreciate the thought regardless haha. It's a type-level tuple--it's not like other types e.g. `Int` that are inhabited, there are no inhabitants of the type `'(someType, someOtherType)`, but you can use type families/classes to manipulate the type-level tuples like one would their value-level cousins
19:25:11 <juhp> heptahedron: unfortuntately it is `let a = e; b = f a; c = g a b`
19:25:36 <heptahedron> juhp: I'm curious as to why it's so essential for `blah` to not be in scope there
19:25:51 <juhp> anyway it's okay - I suspect it can't be done easily in do let
19:26:47 <juhp> heptahedron: well it's not - I just wanted to prevent accidentally using `a` later instead of `c` in the code
19:27:00 <juhp> now i renamed anyway so it should be okay
19:27:48 <juhp> I think it is a common idiom:  let files = ...; files' = blah files
19:31:53 <heptahedron> juhp: found this on the subject https://stackoverflow.com/questions/31816937/is-there-any-syntax-for-non-recursive-binding-in-haskell-just-like-the-differen
19:33:33 <juhp> heptahedron: aha
19:49:50 <dfeuer> Ping edwardk
19:52:32 <lifter> We say that the type variable "a" is parametrically polymorphic if it has no typeclass constraints. Can we apply the term "parametrically polymorphic" to a _function_ and, for example, say that "map" (the function) is parametrically polymorphic because there are no typeclass constraints on any of its type variables?
19:54:08 <dmwit> Seems reasonable.
19:54:24 <heptahedron> I'd say yeah
19:54:33 <ddellacosta> lifter: as far as I understand functions are first and foremost what we are talking about when we are talking about parametric polymorphism. The wikipedia article mentions data types as well
19:55:50 <lifter> Thanks.
19:57:28 <ddellacosta> and my understanding has always been that, as opposed to ad-hoc (typeclass-based) polymorphism, parametric polymorphism is implementation specific, such that a function will operate on multiple types based on it's implementation
20:00:46 <ddellacosta> so it's not that a function is parametric polymorphic _because_ it doesn't have typeclass constraints, but because its implementation is general enough that it can be applied to a class of types, vs. ad-hoc polymorphism, where there may be an implementation for a given function specific to each type
20:03:21 <ddellacosta> but, maybe I'm missing something more subtle you were trying to express...
20:05:45 <amalloy> ddellacosta: i don't really understand what you're getting at. i think it's pretty normal to say that a function is parametrically polymorphic if it has no typeclass constraints: it is polymorphic across all types for all of its parameters, rather than some being restricted
20:05:48 <lifter> No, I wasn't really thinking of any subtleties per se, just wanted to make sure the term can be applied to a function. :)
20:06:47 <ddellacosta> amalloy: sorry, I was responding to the point (I thought) lifter was making that "(the function) is parametrically polymorphic because there are no typeclass constraints..."
20:07:11 <ddellacosta> now, maybe that is actually valid in some sense that I'm missing, but it's not how I thought parametric polymorphism was defined
20:07:34 <ddellacosta> especially because parametric polymorphism doesn't depend on the existence of typeclasses/ad-hoc polymorphism in particular
20:09:36 <amalloy> so, map :: (a -> b) -> [a] -> [b]. it is polymorphic because it has two type variables, and specifically it is parametrically polymorphic because none of those have typeclass constraints. compare to, say, elem :: Eq a => a -> [a] -> Bool, which is not parametric in a because there are types a that elem deems "unacceptable" (they lack the Eq constraint)
20:10:07 <amalloy> which i think is all lifter was saying
20:10:42 <dmwit> It is parametrically polymorphic because it can take on any values of the type parameters. Moreover, in Haskell's type system, the way you express that fact is by having no typeclass constraints. So it's not parametrically polymorphic *because* it has no typeclass constraints, per se, but it's super tightly related.
20:10:54 <ddellacosta> amalloy: I guess the distinction is that I'm talking about parametric polymorphism in the most general sense as opposed to ad-hoc polymorphism--that is, not Haskell-specific
20:11:14 <ddellacosta> dmwit: thanks, exactly my pointer, better made
20:11:18 <ddellacosta> point*
20:11:38 <lifter> I get it.
20:11:41 <lifter> +1
20:27:05 <hatds> If I've got a mutable vector from Data.Vector, what function lets me map over it?  Let's say I have a vector of doubles, and I want to do \x -> 2*x, modifying every element in place
20:27:14 <metahumor> :t fmap
20:27:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:27:51 <hatds> I don't think every vector in Data.Vector is a functor, no?
20:27:59 <hatds> like storables and such
20:28:32 <metahumor> :t map
20:28:33 <lambdabot> (a -> b) -> [a] -> [b]
20:28:39 <metahumor> :t Data.Vector.map
20:28:40 <lambdabot> (a -> b) -> Data.Vector.Vector a -> Data.Vector.Vector b
20:29:52 <hatds> But how is that type signature correct?  If I am modifying in place, shouldn't this "mapping" function return a monadic result?
20:31:31 <metahumor> :t Data.Vector.mapM
20:31:32 <lambdabot> Monad m => (a -> m b) -> Data.Vector.Vector a -> m (Data.Vector.Vector b)
20:32:38 <hatds> are you just guessing?
20:32:49 <metahumor> https://www.schoolofhaskell.com/user/commercial/content/vector
20:33:19 <metahumor> they have examples
20:33:23 <boj> no guessing involved there
20:33:43 <boj> also, i am impressed that metahumor answered each of your questions with type signatures :)
20:35:25 <metahumor> hatds: if you're in a do-block, you would be able to do something like "do {vec <- getMutable; pure (map (*2) vec)}"
20:35:49 <metahumor> hatds: otherwise, "getMutable >>= mapM (*2)"
20:36:16 <metahumor> ehh i guess that's wrong
20:38:51 <hatds> :t Data.Vector.Generic.Mutable.modify
20:38:52 <lambdabot> (Data.Vector.Generic.Mutable.Base.MVector v a, Control.Monad.Primitive.PrimMonad m) => v (Control.Monad.Primitive.PrimState m) a -> (a -> a) -> Int -> m ()
20:39:45 <hatds> this type sig makes sense, I'm just looking for one that does it for every element (I assume a library provided version would be more efficient than doing it myself with modify on every element)
20:43:46 <metahumor> :t \f v -> for_ [0 .. Data.Vector.Mutable.length v - 1] (Data.Vector.Mutable.modify v f)
20:43:47 <lambdabot> Control.Monad.Primitive.PrimMonad f => (a -> a) -> Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState f) a -> f ()
20:44:13 <metahumor> but as the stackoverflow answer from which i cribbed that says,
20:44:46 <metahumor> "constantly modifying all elements in a vector sounds like you may be better off using immutable vectors and mapping over them using the regular fmap"
20:45:00 <metahumor> "if that code ends up fusing properly, the intermediate vectors will never even be materialized"
20:45:36 <metahumor> there's no fusion possible when you do inplace modifying, it has no way of knowing you're not also doing other side effects
20:45:36 <hatds> this is like the point of bothering with the hassle of mutable vectors: you know you aren't creating copies
20:47:40 <hatds> It seems like there should have been a convenience function for mutable vectors that does a "map" where you modify every element in place.  Again, I'm assuming the  "for_ [0.. len-1] " loop has got to be worse than what the library authors can do internally.
20:48:21 <hatds> (worse performance wise I mean)
20:49:14 <metahumor> :t \v -> Data.Vector.unsafeFreeze v >>= pure .  Data.Vector.map (*2) >>= Data.Vector.unsafeThaw
20:49:15 <lambdabot> (Num a, Control.Monad.Primitive.PrimMonad m) => Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> m (Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a)
20:50:32 <sdrodge> I wonder if that fuses properly. Seems like it should?
20:51:11 <hatds> again: mutable vectors are supposed to be the thing you do when you care enough to not create copies
20:51:41 <metahumor> and the unsafe versions don't make copies
20:51:46 <sdrodge> I think normal vectors will fuse properly pretty much all the time too, but I hear ya.
20:53:04 <sdrodge> I'm guessing the library authors didn't provide a map because if you change the type, it can't be done in place in general anyway.
20:53:07 <hatds> it's not the freezing and thawing that I care about, metahumor.  You've still got a map there
20:53:21 <sdrodge> But it does seem like a map that takes an (a -> a) would be nice.
20:53:49 <hatds> sdrodge then when provide modify?  It does a->a, but for a single index
20:53:51 <sdrodge> of course, you don't need a mutable vector if all you're doing is maps.
20:53:56 <hatds> *when->why
20:58:18 <hatds> sdrodge: I'm not sure I understand.  I'm asking about maps because that's the piece I can't find, I want to do other in-place stuff, but also a map in the middle of this as well
21:03:57 <sdrodge> hatds: I think you just use the appropriate map, and rely on fusion.
21:05:25 <sdrodge> like, if you're using Data.Vector.Unboxed.Mutable, use the map from Data.Vector.Unboxed.
21:06:01 <sdrodge> yes, your code will "look" like you've made a copy, but it shouldn't.
21:09:39 <sdrodge> You can use the stuff from Data.Vector.Generic too.
21:13:14 <sdrodge> hatds: Out of curiosity, is there a particular reason you're worried fusion won't work?
21:16:01 <hatds> sdrodge: I was seeing it the other way around.  I was willing to use mutable vectors for this calculation (i.e., put up with a little more of a hassle) in order to know there weren't any copies
21:20:52 <woodson> is there any library then magically parse my data structure to a FormUlrEncoded?
21:21:00 <woodson> like ToJSON
21:21:01 <metahumor> wreq
21:21:07 <woodson> wreq?
21:21:08 <metahumor> wreq + aeson
21:22:01 <metahumor> woodson: "Uploading data via POST" and related parts in http://www.serpentine.com/wreq/tutorial.html
21:23:40 <sdrodge> hatds: Gotcha. Well, I'm certainly not an expert on stream fusion, but my understanding is that you can more or less rely on it when you're using basic maps/folds.
21:24:20 <sdrodge> hatds: If you end up with code that doesn't fuse properly, I'm pretty sure the GHC guys want to hear about it.
21:25:49 <woodson> metahumor: Whats the difference between wreq and http-conduit?
21:27:03 <metahumor> i would say that wreq is more fully-loaded, but they're pretty similar
21:27:18 <metahumor> what are you trying to do?
21:27:46 <woodson> I am trying to write a small library to interact with salesforce rest api
21:28:07 <woodson> and just realize that it doesnt accept json for authentication but form urlencoded -.-
21:31:31 <metahumor> did you look at the wreq "Uploading data via POST"?
21:32:05 <metahumor> r <- post "http://httpbin.org/post" [partText "button" "o hai"]
21:32:11 <woodson> yea I see that I can use [fieldName := value]
21:32:24 <woodson> how can I just lets say pass
21:32:33 <metahumor> wreq suggests using "partText" instead of the "(:=)" tycon
21:32:36 <woodson> ClientAuth data structure instead
21:32:37 <boxscape> if I want to make sure two values are equal at compile time, do I have to resort to using a library like liquid haskell, or is there an easier way? Don't necessarily want to add a dependency.
21:33:07 <metahumor> boxscape: if you can express the equality in a regular haskell val, you can "lift" it into TH
21:33:24 <boxscape> that's template haskell?
21:33:48 <metahumor> yeah. it'll allow you to compile-time-compute things
21:33:56 <boxscape> I see, thanks, I'll look into it
21:33:57 <metahumor> woodson: do you mean pass login information?
21:35:39 <woodson> metahumor: I have to get an session token, so I create a data type called ClientAuth that will hold all the login info
21:35:52 <woodson> and thats what needs to be in my request body
21:36:11 <woodson> but I already made the ToJson instance for it
21:36:29 <woodson> so I was wondering if there was a ToFormUrlEncoded instance
21:36:36 <woodson> that I could maybe use
21:37:40 <metahumor> woodson: how is the token sent usually?
21:37:44 <woodson> that would return [(ByteString, ByteString)] instead of having me implement it
21:38:21 <woodson> you send a post request with the login info
21:38:29 <woodson> and it will return a json object with the token
21:38:36 <woodson> if your authenticated
21:38:59 <woodson> cant send json, however, i received json -.-
21:39:48 <metahumor> i'm a little confused, can you show in an lpaste what you tried?
21:40:11 <woodson> oh sorry its a curl by the way
21:40:16 <woodson> i can show you the steps
21:44:18 <metahumor> sure
21:45:25 <pikajude> so
21:45:46 <pikajude> is ImplicitParams useful for faking a Reader environment when i don't want to make a bunch of pure functions monadic
21:45:48 <pikajude> or is that a terrible hack
21:46:23 <woodson> metahumor: http://lpaste.net/8042582220336005120
21:46:36 <woodson> here is what i got
21:47:14 <unsiva> does haskell have something like pandas library of python to process csv so esily
21:47:22 <metahumor> cassava
21:47:30 <metahumor> but it's not like pandas
21:47:56 <metahumor> you might also like "frames"
21:48:28 <unsiva> https://hackage.haskell.org/package/cassava ?
21:48:42 <unsiva> ok
21:51:49 <batman_> is there a way to get all the keys from a hash Map ?? in Data.Map.Strict
21:52:59 <metahumor> :t Data.Map.keys
21:53:00 <lambdabot> M.Map k a -> [k]
21:53:25 <Hafydd> Data.Map isn't a hash map.
21:54:34 <batman_> Hafydd : any other way then >?
21:54:46 <metahumor> batman_: I just showed you how
21:54:47 <Hafydd> batman_: what type does your hash map have?
21:55:44 <metahumor> woodson: use wreq, it'll be much simpler
21:56:00 <batman_> metahumor : i'm trying to find it on hackage
21:56:10 <metahumor> batman_: find what?
21:56:18 <woodson> metahumor: What part exactly?
21:56:31 <batman_> metahumor : Data.Map.keys
21:57:33 <metahumor> woodson: "resp <- post "https://login.salesforce.com/services/oauth2/token" [partText "grant_type" "password", partText "client_id" "myclientid" ...]
21:58:08 <metahumor> "rest ^. responseBody"
21:58:22 <metahumor> batman_: keys is a function in the Data.Map module
21:59:10 <metahumor> batman_: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html#v:keys
22:00:04 <batman_> metahumor : got it thanks
22:11:24 <pikajude> :t Data.Map.keys
22:11:25 <lambdabot> M.Map k a -> [k]
22:17:36 <metahumor> i'm working on the data61 course
22:17:38 <metahumor> hi, i'm having some issues with "distinctG" in "StateT.hs". it's coming out very ugly
22:17:47 <metahumor> i think i'm misunderstanding how to combine pure and log1
22:17:57 <metahumor> do i just basically write my own "lift" version for log like "liftlog str = StateT (\s -> OptionalT (log1 str (Full ((), s))))"?
22:19:03 <dibblego> metahumor: you want to use StateT (Set a) Optional (List a)
22:19:11 <metahumor> yeah, i had a
22:19:22 <metahumor> "golog x y = if odd x then pure y else StateT (\s -> (OptionalT (log1 ("even number: " ++ show' x) (Full (y, s)))))"
22:19:59 <dibblego> correction, StateT (Set a) (OptionalT Logger) (List a)
22:20:55 <metahumor> that i use inside a "go x = ... | getT >>= (\s -> putT (x `S.insert` s) >> golog x () >> pure (not (x `S.member` s)))"
22:21:52 <metahumor> "distinctG xs = runOptionalT (evalT (filtering go xs) S.empty)"
22:22:38 <metahumor> dibblego: just trying to understand whether i've missed some point about how to properly use "pure" and "(>>=)" for this monad stack
22:22:39 <dibblego> I don'tr think you will be using >>= inside go
22:23:15 <dibblego> or >>
22:23:51 <[Leary]> Minus type signatures and a lone where, my version is 12 lines. I don't think it's supposed to be trivial, but maybe I missed something too.
22:24:53 <metahumor> for reference, i have "distinct' xs = eval' (filtering go xs) S.empty where go x = getT >>= (\s -> putT (x `S.insert` s) >> pure (not (x `S.member` s)))"
22:25:05 <dibblego> yeah, you can write it using get/put and >>=
22:25:20 <metahumor> i know that filtering has a Applicative f instance, not sure how this typechecks (but it does)
22:25:24 <dibblego> or just use the StateT constructor
22:25:27 <metahumor> *Applicative f constraint
22:25:35 <dibblego> yes, use filtering is correct
22:26:29 <metahumor> sorry, i meant, I'm using (>>=) even though I'd think that'd require a Monad f constraint, not just simply an Applicative f constraint
22:27:21 <dibblego> you're using it on StateT (Set a) (OptionalT Logger) which has a Monad instance
22:27:56 <metahumor> :t filterM
22:27:57 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
22:28:44 <metahumor> oh because in the body of "filtering" we only use "liftA3", gotcha
23:30:01 <batman_> how to convert a string into word32
23:30:58 <metahumor> what are you going to do with Word32?
23:31:24 <metahumor> @hoogle [Char] -> [Word32]
23:31:25 <lambdabot> Data.Hash.CRC32.GZip update_crc_list :: Word32 -> [Char] -> Word32
23:31:25 <lambdabot> Text.XML.Light.Lexer cref_to_char :: [Char] -> Maybe Char
23:31:26 <lambdabot> Hledger.Cli.Add wordLetterPairs :: String -> [[Char]]
23:32:07 <batman_> metahumor : using this type HostAddress = Word32
23:32:25 <metahumor> a single Word32?
23:33:13 <batman_> metahumor : i think so, also couldn't find anything on hoogle
23:33:45 <metahumor> can you give some more context on where you're getting the String from?
23:34:30 <batman_> metahumor : i'm just playing with socket programming so its just going to be hard coded for now
23:36:51 <amalloy> metahumor: we seem to be trying to do DNS
23:37:23 <metahumor> lol good luck then
23:38:23 <metahumor> a very quick hoogle search gave me
23:38:43 <amalloy> or who knows, maybe they just meant f "127.0.0.1" = 0x7f000001
23:39:13 <metahumor> @hoogle IO (Either DNSError [IPv4])
23:39:13 <lambdabot> Foundation.Network.IPv4 ipv4Parser :: (ParserSource input, Element input ~ Char, Sequential (Chunk input), Element input ~ Element (Chunk input)) => Parser input IPv4
23:39:13 <lambdabot> Darcs.Repository.Internal seekRepo :: IO (Maybe (Either String ()))
23:39:13 <lambdabot> Codec.Xlsx.Parser.Internal defaultReadFailure :: Either String (a, Text)
23:39:20 <metahumor> ehhh
23:39:27 <metahumor> https://hackage.haskell.org/package/dns-3.0.1/docs/Network-DNS-Lookup.html#v:lookupA
23:39:43 <metahumor> batman_: take a look at that i guess
23:40:38 <s3mi0_> \leave
23:40:49 <metahumor> okay bye then
