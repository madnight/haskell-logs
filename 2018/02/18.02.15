00:05:04 <dminuoso> EvanR: Why doesn't it work with `Proxy` though?
00:06:26 <enterprisey> so I'm currently trying to make that typeclass instance (@ cocreature ) and the Lex type doesn't internally store where each lexeme ends
00:06:48 <enterprisey> However, I need to know the start of the next lexeme for advance1
00:07:48 <enterprisey> Should I just add it?
00:08:19 <cocreature> if you want proper source locations in your errors, you’ll have to add the locations to the Lex type
00:08:33 <mniip> ok, so Free is an embedding e : X -> Free X, such that for any monad Z any natural transformation f : X -> Z decomposes into monad homomorphism m : Free X -> Z,  f = m . e
00:08:34 <cocreature> otherwise you could just advance the column by one for each lexeme or something like that
00:08:42 <EvanR> dminuoso: the sig wants an a, not Proxy a
00:09:20 <enterprisey> cocreature: so I'm a bit confused by the docs. Each Lex knows where it starts, but not where it ends
00:09:37 <enterprisey> I am wondering whether I need to advance to the next line myself
00:09:46 <enterprisey> The default implementation for strings, etc does do this
00:10:00 <enterprisey> but the docs say that I can return "the position right after the token, or the position where the token ends"
00:10:15 <enterprisey> so this could mean that they're supposed to be be the same thing
00:10:43 <enterprisey> either way, I'm wondering if for the last token on a line, we can just add the length of the token to the current source position
00:14:36 <cocreature> should be fine
00:20:54 <Kristjan12345> hi
00:31:36 <ertes-w> helo
00:35:07 <mniip> but what does that mean
00:35:18 <guesswho> how do i fix this http://lpaste.net/362524 without editing my global stack.yaml
00:35:39 <guesswho> would it break other packages if i did edit my stack.yaml
00:39:33 <cocreature> guesswho: editing your global stack.yaml will only affect projects that don’t have a local stack.yaml
00:40:17 <guesswho> cocreature : what are your thoughts about  configurator as compared to Data.Conf
00:40:34 <cocreature> I’ve used neither so I don’t have any comments
00:52:55 <Boarders> does anyone know the state of the art for calling python from Haskell?
00:53:57 <ertes-w> rewrite the python code in haskell =)
00:54:16 <Boarders> lol
00:54:39 <ertes-w> Boarders: just invoke it using System.Process i guess?
00:54:59 <ertes-w> or if it's a long-running process, use whatever run-time API it provides
00:55:24 <Boarders> I had in mind something like this: https://john-millikin.com/software/haskell-cpython
00:55:38 <Boarders> but I was just wondering if there is a standard that is used
00:57:00 <ertes-w> that looks surprisingly reasonable
00:59:12 <guesswho> Couldn't match type ‘[Char]’ with ‘Data.Text.Internal.Text’
00:59:34 <Boarders> ~~~never leave haskell~~~
01:00:25 <Boarders> guesswho: try using the language extension OverloadedStrings which allows you to input different string formats using the usual "blah blah blah" type of syntax
01:00:44 <kuribas> is it possible to create a traversal from two traversals (in parallel)?
01:01:30 <ertes-w> kuribas: i think it should be possible with a special monad transformer
01:01:31 <phadej> kuribas: in parallel? how they would arrange effects?
01:01:45 <kuribas> phadej: first one, then the other?
01:01:50 <ertes-w> kuribas: a coroutine monad like FreeT could do it
01:01:57 <guesswho> <Boarders> : can you elaborate, i'm new to haskell
01:01:57 <phadej> kuribas: that's in serial :)
01:02:06 <kuribas> phadej: ah, right :)
01:02:37 <phadej> kuribas: https://github.com/ekmett/lens/pull/778
01:02:49 <Boarders> guesswho: String in haskell is represented by a list of characters but that is inconvenient as a text format so there are some alternatives that are often used one of which is Text
01:03:23 <EvanR> String is inconvenient as an efficient text format
01:03:25 <kuribas> ah, so not lawful?
01:03:42 <EvanR> depending on what operation youre trying to do
01:03:44 <Boarders> if you put {-# LANGUAGE OverloadedStrings #-} at the top of your file then you can do things like:
01:03:57 <kuribas> String is convenient, but not performant
01:04:16 <Boarders> example :: Text
01:04:21 <Boarders> example = "blah"
01:04:37 <Boarders> and it will be automatically converted from the string you have entered to text
01:05:19 <Boarders> yes, inconvenient is the wrong word
01:07:16 <guesswho> Boarders : do i need to import some module to user example :: Text
01:07:19 <ertes-w> String performance is often misunderstood/misrepresented
01:07:28 <ertes-w> for example (putStrLn "blah") is totally fine
01:07:43 <Boarders> guesswho: yes you need to import the text module that you want to use
01:08:11 <Boarders> so something like import Data.Text.Internal
01:08:19 <Boarders> though you may want to do a qualified import
01:08:19 <dminuoso> Boarders: Hah. Im constantly wondering about the other way. Looking for ways to integrate Haskell into the Ruby world. =)
01:08:28 <Boarders> :)
01:08:31 <dminuoso> Mostly because we have an existing Ruby infrastructure.
01:08:51 <ertes-w> guesswho: do you know how integer literals are polymorphic?
01:09:08 <bartavelle> dminuoso: obligatory self promotion, you can embed a ruby interpreter in a haskell program (with caveats) with the hruby package
01:10:25 <ertes-w> dminuoso: we have one ruby program in our infrastructure (sensu)…  the way i integrate haskell with it is to just execute haskell programs =)
01:10:49 <kuribas> dminuoso: should be possible with the FFI
01:11:07 <ertes-w> (i'd much prefer not to have ruby as the main program here, but then i don't really want to bother the RabbitMQ protocol that sensu uses)
01:11:40 <kuribas> dminuoso: or IPC, sockets, pipes, message passing...
01:11:41 <ertes-w> *bother learning
01:12:13 <kuribas> dminuoso: you could use event sourcing :-)
01:19:41 <guest_> hi guys I have a string in json format which has type 'String', I am  trying to encode it using deeode function of aeson library  `decode jsonString :: May be myDataType`, but it is giving runtime error  Couldn't match type ‘[Char]’ with ‘BL.ByteString’
01:20:09 <kuribas> runtime error?
01:20:11 <bartavelle> doesn't look like a runtime error
01:20:37 <bartavelle> anyway, you have to convert your string to something the aeson library can handle
01:20:44 <guest_> @<kuribas> then what it means?
01:20:44 <lambdabot> Unknown command, try @list
01:20:55 <dminuoso> ertes-w: The "execute Haskell programs" just has that annoying bit of being forced to somehow transport data through FFI or very unrobust or anoying ways. Every time I look at it, it seems easier to just rewrite portions of the Ruby program in Haskell and interact with the databases directly.
01:21:07 <bartavelle> guest_: this is a compile time error
01:21:14 <guest_> @<bartavelle> how to convert?
01:21:14 <lambdabot> Unknown command, try @list
01:21:34 <bartavelle> guest_: http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Lazy-Char8.html#v:pack
01:21:44 <bartavelle> [Char] = String
01:22:19 <bartavelle> guest_: alternatively, where do you get that String from?
01:22:22 <kuribas> dminuoso: you'll always have to go through some binary interface
01:22:24 <ertes-w> dminuoso: with sensu it's JSON for everything, which is nice
01:22:38 <ertes-w> configuration is in JSON, communication is in JSON, etc.
01:22:42 <kuribas> dminuoso: well, with the FFI
01:23:43 <guest_> @<bartavelle> it is random generated json format String
01:23:43 <lambdabot> Unknown command, try @list
01:23:49 <kuribas> json is unsafe too...
01:24:21 <ertes-w> and since i can't be bothered to implement the whole aeson FromJSON/ToJSON deal i really appreciate the existence of lens-aeson =)
01:25:04 <kuribas> ertes-w: not even with generics?
01:25:09 <guest_> @<bartavelle> thanks it works ( http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Lazy-Char8.html#v:pack) :)
01:25:09 <lambdabot> Unknown command, try @list
01:25:27 <ertes-w> kuribas: i'm only interested in a very small fraction of the information i receive
01:26:14 <ertes-w> so it's pointless to spell out the whole potential type for all of it, and to use generics effectively i'd also have to name my fields according to the JSON, which i really don't want to do
01:26:42 <EvanR> endlessly pushing fields around by name :(
01:26:45 <kuribas> dminuoso: how do you get to write haskell at work?  I got fired for even suggesting their architecture (Python) might not be up the task...
01:27:26 <bartavelle> kuribas: that sounds like quite the suggestion for warranting a firing ...
01:27:42 <kuribas> bartavelle: it wasn't up to the task...
01:27:45 <kuribas> well isn't
01:28:16 <EvanR> you're just not a team player
01:28:30 <kuribas> perhaps not
01:28:59 <bartavelle> anyway I also use haskell at work, and my problem is hiring a second developer without getting hassled by my big company
01:29:13 <bartavelle> I do not even know how to advertise the fact that we have this position available
01:29:30 <kuribas> but no way their solution is going to work.  They just think throwing more people at it and writing more code will solve their problems.
01:29:40 <kuribas> bartavelle: where?
01:29:42 <EvanR> bartavelle: where
01:29:55 <bartavelle> it is in marseille, france, no remote work
01:29:57 <dminuoso> kuribas: My boss does not care about tech. He cares about solutions. =)
01:30:07 <kuribas> dminuoso: I like your boss :)
01:30:12 <bartavelle> you also have to speak fluent french and be employable here
01:30:24 <kuribas> bartavelle: I speak decently french
01:31:32 <ertes-w> honestly i think it has become very easy to get haskell into a company that doesn't already use it
01:32:18 <dminuoso> kuribas: In a way it's also a problem, because the "solution focused" approach frequently leads to "dont implement it well, just implement it quickly"
01:32:18 <bartavelle> kuribas: if you can work here (I suppose that means EU resident, as I work for *big administrative company* that can't do anything different) and have no problem with civil nuclear power, and also like computer security, send me a cv
01:32:49 <kuribas> bartavelle: right, thanks :)
01:34:00 <kuribas> bartavelle: I do have a problem with nuclear power, but I think at the moment it's one of the better solutions.
01:34:10 <kuribas> but offtopic...
01:37:18 <kuribas> bartavelle: it took them a year and a half to find a (really complicated) solution to add a few financial numbers.  I am doing it in haskell for experimentation, and I am sure my 2 day solution will outperform what they have.
01:39:45 <bartavelle> kuribas: I think the main advantage of haskell over something like python is that you can salvage your code if you did not see some big architecture challenge coming (which will certainly happen at one time), but it does not help if all the other devs are not on the same boat
01:40:38 <bartavelle> well, I haveseen placed where I thought I could do better on my own that the whole team that was in place, but that was certainly some cognitive bias
01:40:40 <ZeuPiark> hello
01:41:22 <kuribas> bartavelle: sadly I think this is the case.  Though I don't really want to spend three months creating a solution to satisfy my ego :)
01:41:41 <ZeuPiark> can i ask you for talking about feedback of haskell in entreprise please ?
01:42:21 <liste> ZeuPiark: sure, go ahead
01:43:30 <ZeuPiark> liste: thanks, first, in what type of development you have seen haskell used ?
01:44:34 <liste> ZeuPiark: me personally, I've only read about Haskell being used in the finance industry, but others here may have more comprehensive knowledge
01:45:24 <kuribas> bartavelle: the teamleader took any criticism on the whole code (not only his) as a personal insult, which made working pretty hard.  I had to take some really dodgy python code out (quadratic code, doing the same observer calls in every iteration).  Then I got critized for changing "working" code...
01:45:35 <ZeuPiark> liste: you think there is a lang more easy to use in cases of high amount of business rules for example ?
01:45:56 <dminuoso> kuribas: How long have you been at the place?
01:46:10 <kuribas> dminuoso: 5 months
01:46:25 <dminuoso> kuribas: Was there reasons for you to refactor that code? Did requirements change?
01:46:29 <liste> ZeuPiark: I think Haskell works very well with a high number of business rules
01:46:48 <bartavelle> ZeuPiark: depend on what kind of business rules, but I think that generally with sum types + pattern matching you can be very expressive and concise with expressing such rules
01:46:56 <kuribas> dminuoso: well, it was import code, and I wanted to make it generic for xml and json.
01:47:00 <ZeuPiark> in security for example ?
01:47:14 <dminuoso> kuribas: You said you fixed code that was considered "working".
01:47:24 <kuribas> dminuoso: by him, not me...
01:47:28 <bartavelle> ZeuPiark: that is where I work yes
01:48:04 <bartavelle> however it is a bit like saying you work in computers , that is a wide field
01:49:22 <EvanR> you work *IN* computers
01:49:32 <EvanR> shrink rays and such
01:49:37 <bartavelle> we have large computers here
01:49:42 <kuribas> dminuoso: they rarely refactored code, for the report generation they used an obsolute html to pdf library with their own needs hacked in...
01:52:02 <ZeuPiark> i looking to learn haskell to change my experience road (sorry i dont know what english expression will be used for explain this)
01:54:20 <EvanR> haskell will definitely do that
01:54:23 <ZeuPiark> so, the question is, am i interested only for learning a new functionnal langage (is newer for me), or if it's requested by companies, it will be help me to decide what langage i need to learn.
01:55:03 <liste> ZeuPiark: Haskell is currently not very widely used in the industry, but hopefully that will change
01:55:07 <kuribas> ZeuPiark: well, scala is more popular, but haskell is much more clean and elegant.
01:55:14 <ZeuPiark> EvanR: i do not have too many doubts
01:55:32 <bartavelle> ZeuPiark: would you be French (with "Zeu"?)
01:55:34 <ZeuPiark> kuribas: scala is a functionnal langage ?
01:55:42 <kuribas> ZeuPiark: multi paradigm
01:55:46 <EvanR> debatable
01:56:27 <ZeuPiark> bartavelle: yes but i cannot understand why "zeu" makes you say i'im french :)
01:56:27 <kuribas> ZeuPiark: clojure is also a bit more popular, but you miss on the interesting static type theory :)
01:56:45 <bartavelle> ZeuPiark: join #haskell-fr, you will find people with industry experience
01:56:50 <tdammers> "functional language" is ambiguous
01:57:05 <tdammers> by the strictest definition, even Haskell doesn't qualify
01:57:12 <ZeuPiark> kuribas: but learning haskell can be a good thing to learn scala for example after ?
01:57:16 <tdammers> and by the least strict definition, almost every language qualifies
01:57:34 <kuribas> ZeuPiark: well, if you learn scala after it, you probably won't like scala so much...
01:57:55 <ZeuPiark> kuribas: or, learn scala (i'm c/java developper) is a good way to learn haskell before
01:58:20 <kuribas> ZeuPiark: a lot of scala programmers secretly want to be haskell programmers :)
01:58:26 <tdammers> ZeuPiark: if you're interested in scala, learn scala. if you're interested in haskell, learn haskell.
01:58:52 <EvanR> and never the other way around
02:00:55 <ZeuPiark> kuribas: i dont know if i would like to learn scala, my idea is to change my working context, and talking about this with a colleague, he told me, learn scala its opens the mind, and potentially this is used in security area (world?)
02:01:05 <ZeuPiark> kuribas: lol
02:01:24 <kuribas> ZeuPiark: it has more jobs, yes
02:02:01 <kuribas> ZeuPiark: and it's better than Java :)
02:02:05 <ZeuPiark> tdammers: i dont know exactly whar language i will learn, i'm looking for
02:02:25 <ZeuPiark> kuribas: i think, some languages is better than java :)
02:03:07 <liste> scala is going a bit downhill now though, people are fed up with the complexity, compile times, and sbt
02:03:14 <ZeuPiark> i learned java because the bank i worked for thaught me
02:03:42 <ZeuPiark> but basically i was doing c and c++ for my programms
02:04:00 <ertes-w> ZeuPiark: we use haskell for infrastructure-related tasks:  monitoring, coordinating backups, etc.
02:04:13 <kuribas> liste: what are scala people looking for then?
02:05:12 <liste> kuribas: probably some of them are looking for Kotlin, some are looking for Haskell
02:05:29 <tdammers> most likely many are also going back to java
02:05:39 <kuribas> liste: so I should look around in the scala world, see if I can promote haskell?
02:05:39 <liste> scala tries to mix those 2 up
02:05:50 <ertes-w> ZeuPiark: i don't know how it came to be this way, but there is a very common misconception that scala is similar to haskell…  that's wrong, they are very different
02:05:50 <liste> kuribas: I'd be delighted
02:05:52 <ZeuPiark> bartavelle: many thanks :) i think lot of people here will be appreciate that i stop killing englisn :)
02:05:56 <ZeuPiark> -n+h
02:06:06 <liste> kuribas: the biggest barrier I see now is IDE support
02:06:29 <liste> kuribas: I'd totally make my team use Haskell if the IDE support was good
02:06:32 <ZeuPiark> liste: there is verry a big difficulty ?
02:06:34 <kuribas> liste: yeah.  That sucks a bit in haskell.
02:07:04 <liste> ZeuPiark: difficulty in what?
02:07:13 <ertes-w> liste: do you think it's important that everybody in the team works with the same editor/IDE?
02:07:18 <ZeuPiark> liste: the ide
02:07:29 <liste> ZeuPiark: there's no good IDEs for Haskell
02:07:42 <ZeuPiark> liste: yes, but this is a problem ?
02:07:50 <liste> ertes-w: no, I think everyone should use the one they're most comfortable with
02:08:14 <liste> ZeuPiark: Java people are attached to IDEs, and for a reason
02:08:19 <tdammers> ertes-w: I would even say that if your operation relies on everyone using the exact same tools, something is very wrong
02:08:28 <liste> Haskell would benefit a ton from IDEs too
02:08:42 <EvanR> tdammers: hmm...
02:08:46 <bartavelle> there is some stuff, but it all seems so brittle
02:08:50 <kuribas> liste: emacs is good (but not great)
02:09:16 <ertes-w> i think emacs with haskell-mode is actually great, not just good
02:09:44 <ertes-w> there is little missing towards the "visual studio" or "eclipse" kind of experience
02:09:45 <liste> because of Haskell's regular syntax, lack of dynamic features, and simple layout, it would be the perfect match for IDEs
02:09:59 <tdammers> if your code only runs in a specific controlled environment, then that's a big risk, because you may have to change that environment at some point
02:10:10 <kuribas> anyone tried leksah?
02:10:21 <ZeuPiark> liste:  i understand for java and c/c++, because it's easy to find symbols and functions names, in a large amount of librairies and classes not writing by you, but in haskell, it's also annoying ?
02:10:39 <tdammers> liste: yes, but unlike Java, IDE support isn't crucial to getting things done in Haskell, and the language is a much faster moving target, so keeping up is harder for IDE makers
02:11:08 <bartavelle> ZeuPiark: having types appearing in a tooltip when you mouseover is awesome
02:11:25 <bartavelle> (IMO)
02:11:39 <liste> hmm, maybe I should give haskell-mode a new try
02:11:44 <ertes-w> also shameless self-promotion:  the 'rapid' library gets you even closer…  it's a rapid prototyping framework…  i've spent a lot of time reducing the development cycle of haskell, and i'm now at a point where it's pretty much instant, only limited by the time GHCi takes to live-reload part of the code
02:11:45 <liste> does it have refactoring tools?
02:12:03 <liste> @hackage rapid -- ertes-w this?
02:12:03 <lambdabot> http://hackage.haskell.org/package/rapid -- ertes-w this?
02:12:08 <ertes-w> yeah
02:12:11 <ertes-w> rapid also integrates with haskell-mode…  no configuration required
02:12:21 <ertes-w> (but you can use it with raw GHCi, too)
02:13:33 <kuribas> liste: I use haskell-mode with flycheck.  There is also
02:13:45 <ZeuPiark> many thanks for answering my questions
02:14:02 <kuribas> liste: intero
02:14:13 <jstsmthrgk> How do I compute something for x = 0, output it, then wait some time, compute it for x = 1 and so on? (I know how to do the compute and output steps)
02:14:15 <ertes-w> you can cut the reloading time even further by using -fobject-code (because that makes GHCi write reusable object files), but i tend not to do that, because it comes with some really annoying caveats
02:14:40 <ertes-w> jstsmthrgk: the simplest solution would be:  use 'threadDelay' from Control.Concurrent
02:15:44 <liste> doesn't look like haskell-mode has refactoring, navigation, or syntax checking (though flycheck does that) ?
02:17:07 <jstsmthrgk> and is there a possibility to do the x -> x+1 in a loop?
02:17:16 <jstsmthrgk> or do I have to use recursion?
02:17:52 <opqdonut> there are no loops
02:18:03 <opqdonut> all loop-like constructs are implemented with recursion
02:18:29 <jstsmthrgk> I knwo but I want it to look like a loop in main
02:18:44 <jstsmthrgk> is there a easy way?
02:18:50 <opqdonut> well you can use something like while or forever
02:18:52 <opqdonut> :t while
02:18:53 <lambdabot> error: Variable not in scope: while
02:18:55 <opqdonut> :t forever
02:18:57 <lambdabot> Applicative f => f a -> f b
02:19:10 <opqdonut> :t whileM
02:19:12 <lambdabot> error: Variable not in scope: whileM
02:19:15 <opqdonut> @hoogle while
02:19:15 <lambdabot> Data.Array.Accelerate while :: Elt e => (Exp e -> Exp Bool) -> (Exp e -> Exp e) -> Exp e -> Exp e
02:19:16 <lambdabot> Language.Javascript.JMacro.Util while :: ToJExpr a => a -> JStat -> JStat
02:19:16 <lambdabot> Language.ECMAScript3.Syntax.CodeGen while :: Default a => Expression a -> Statement a -> Statement a
02:19:25 <opqdonut> I was sure something like that existed
02:19:30 <opqdonut> at least here: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
02:19:39 <jstsmthrgk> thank you!
02:19:56 <quchen> main = for [1..] (\n -> print n >> threadDelay 1000000)
02:20:12 <opqdonut> you mean forM?
02:20:20 <ertes-w> liste: haskell-mode comes with haskell-interactive-mode, which uses an embedded GHCi for the things you mentioned
02:20:32 <opqdonut> oh Data.Traversable.for
02:20:33 <opqdonut> nice
02:20:35 <ertes-w> liste: except refactoring
02:20:36 <quchen> :-)
02:20:40 <opqdonut> I'm stuck in the past
02:20:45 <ertes-w> liste: haskell-mode doesn't really have support for that
02:22:08 <jstsmthrgk> I guess forever is the one I need, but how do I get an incrementing index with that?
02:22:34 <ertes-w> jstsmthrgk: traverse_ (\x -> print (f x) >> threadDelay 1000000) [1..]
02:22:44 <jstsmthrgk> I need the IO monad
02:23:04 <ertes-w> alternatively: for_ [1..] $ \x -> print (f x) >> threadDelay 1000000
02:23:08 <EvanR> you can also youre your own recursive action that holds the counter
02:23:16 <quchen> You need the IO Applicative only.
02:23:22 <liste> jstsmthrgk: traverse_ works with IO too
02:23:26 <EvanR> eruh, write your own
02:23:41 <ertes-w> also don't use 'for' here
02:23:44 <liste> jstsmthrgk: IO is a type which is both Monad and Applicative
02:23:47 <ertes-w> use 'for_' or 'traverse_'
02:23:51 <jstsmthrgk> okay, i'll try it out in ghci and look what is the perfect one for what I need
02:23:52 <ertes-w> (from Data.Foldable)
02:26:39 <solidus-river> hey all, for those that use stack, i'm on windows for the first time, stack build lcaims no such executable git, does stack assume i have git in my path, does it assume anything else?
02:27:39 <jstsmthrgk> I'll just use forM_, because I got it working ;)
02:27:53 <ertes-w> jstsmthrgk: use 'for_' instead of 'forM_'
02:28:19 <solidus-river> what does the underscore represent?
02:28:29 <ertes-w> jstsmthrgk: it's the non-historical-mistake version of forM_ =)
02:28:53 <ertes-w> solidus-river: "i don't care about the results, so don't keep them in memory"
02:28:57 <ertes-w> :t for
02:28:58 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
02:28:59 <ertes-w> :t for_
02:29:00 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
02:29:46 <solidus-river> thanks!
02:29:56 <ertes-w> if you do (traverse print [1..3]) you get an actual result list:  [(), (), ()]
02:30:10 <jstsmthrgk> in which Package is for_?
02:30:21 <ertes-w> jstsmthrgk: it's in the Data.Foldable *module*
02:30:29 <ertes-w> (in the base package)
02:47:07 <EvanR> writing a function of type String -> T, which fails badly when the format is bad
02:47:28 <EvanR> cool, i can use read, and error, and all kinds of stuff
02:47:45 <EvanR> if you pretend haskell is like any other language, the code can get really compact
02:47:46 <liste> EvanR is in the danger zone
02:48:28 <phz_> String -> Either FormatError T
02:48:29 <phz_> please
02:48:30 <phz_> :D
02:48:49 <EvanR> too much code bloat
02:49:15 <EvanR> proof that archived strings are correct, in your head, take up way less space
02:50:31 <EvanR> haw haw! http://lpaste.net/362526
02:51:31 <phz_> EvanR: I don’t mind boilerplate
02:51:43 <phz_> I’m for correctness over comfort
02:51:54 <EvanR> but my wrists
02:52:38 <EvanR> haskell might be the best dynamic language
02:52:55 <phz_> EvanR: :)
02:55:07 <liste> unsafeCoerce all the way
02:59:36 <tdammers> well, building dynamic languages as Haskell EDSLs isn't half bad
02:59:50 <solidus-river> how do you solve missing build deps on windows, od i install them in msys?
03:08:00 <EvanR> tdammers: irony this dsl is crippingly dependently typed
03:11:53 <ertes-w> tdammers: until people start using them
03:12:16 <ertes-w> PHP was an amazing language…  a perfect language…  but then people started using it
03:12:34 <ertes-w> i wouldn't mind PHP one bit; no, i would praise it…  if nobody used it
03:13:25 <Rembane> PHP was really good back in version 3 or 4 or something.
03:13:57 <Rembane> That was of course before it was as widespread as it is today, so this doesn't contradict your statement.
03:16:31 <ertes-w> no, at versions 3/4 people were already using it, so at that point it was already too late
03:16:52 <Rembane> Ach
03:18:15 <ertes-w> same as with python…  the language was absolutely, breathtakingly amazing, but then they decided to make it publicly available
03:18:35 <ertes-w> i can't even express how much i would love python, if nobody was using it
03:19:00 <EvanR> quick make haskell unpopular again
03:19:40 <EvanR> it tends to delete your source in response to type errors! its terrible!
03:20:41 <ertes-w> no, it's the other way around with haskell…  it was dreadful language…  it pains me to even talk about how awful it was…  but then people started using it
03:22:14 <solidus-river> how do i the haskell in windows!?
03:22:26 <solidus-river> sorry for dumbing down the conversation, i've done a lot of work in gentoo / unix type environments
03:22:36 <dstolfa> ertes-w: python was a language to support a distributed OS retrofitted to be general purpose
03:22:41 <dstolfa> ertes-w: that's where the problems arise
03:22:45 <solidus-river> but this is my first time trying to use stack or ghc on windows, i'm getting compiler errors, I'm not a stranger to compilation or cross compilations
03:23:11 <solidus-river> but i'm confused as to whether stack is attempting to build using mingw that was packaged with it or if it expects headers to be available on my windows install / how it searches for them
03:23:35 <solidus-river> if it is the mingw it was shipped with i'm fairly new to mingw, would vulkan libs linked from there every work on my win10 env :?
03:23:37 <ertes-w> solidus-river: (no worries, your question is more important than my language bashing) =)
03:24:50 <solidus-river> still off topic for this room maybe, i should wait till guys in haskell-stack are around :X
03:25:15 <ertes-w> solidus-river: are you trying to build stack/GHC themselves?
03:25:47 <solidus-river> whats the latest / greatest frp lib, last time I touched it was just "wires"
03:26:04 <solidus-river> I'm trying to run stack build against an example of the vulkan library, which in turn tries to compile the vulkan lib
03:26:09 <solidus-river> er, vulkan package
03:26:13 <ertes-w> solidus-river: "wires" might fit the "fastest" requirement, but not the "greatest"
03:26:27 <ertes-w> solidus-river: my default answer is: reflex
03:27:30 <ertes-w> oh, you wrote "latest"
03:27:34 <solidus-river> interesting, reflex wasn't around last time i tried
03:27:51 <Rembane> ertes-w: Is this true for every ... no doesn't seem so. :D
03:28:11 <solidus-river> i'm trying to adapt a fps game / engine to it, so speed is important, i *think* when i left off i had gotten a prototype in netwire working and was porting it to wires when i came across sodium and thought that might bee more efficient
03:28:53 <ertes-w> solidus-river: no, reflex will likely beat reactive-banana and sodium in terms of speed
03:29:42 <ertes-w> the only reason why you might want to go with wires over reflex is speed – and *control* over speed, i.e. predictability
03:30:38 <ertes-w> but keep in mind that reflex is most likely efficient and predictable enough
03:31:19 <Cale> If you're on windows, it seems like some people have managed to get reflex-platform working under the Windows subsystem for Linux
03:31:45 <Cale> (https://github.com/reflex-frp/reflex-platform/issues/177) ...after some initial difficulties with compile performance
03:32:29 <Cale> Well, specifically Wizek has :)
03:34:58 <Cale> It would be really cool to have some more people pushing forward on using reflex for games. There's likely a bunch of paths through the jungle you'll have to cut for yourself at the moment, but I think the end result will be really nice someday.
03:35:44 <EvanR> what components do you think would be nice to work on in the short term, in that respect
03:38:14 <EvanR> graphics, resource management...
03:38:26 <EvanR> hookups to other systems
03:39:49 <Cale> Yeah, exactly that sort of thing.
03:41:09 <Cale> There are some beginnings on reflex bindings for SDL
03:42:48 <Cale> also https://github.com/deepfire/reflex-glfw looks cool
03:45:30 <Wizek> Cale: I have indeed. Since then I have been using on windows a reflex-dom app I am working on. Though I've put aside building binaries with webkit1 or webkit2 bundled because I've run into some issues. So I am using jsaddle-warp currently, which gives a quite nice native feel to the UI rendered in a 'chromeless' Chrome window even though it's a linux server running in WSL.
03:51:26 <Cale> EvanR: But yeah, this stuff is in pretty early stages -- I'm sure that if you actually start to use it, probably a good amount of work can be done to flesh it out still.
03:59:35 <Wizek> EvanR: if you are interested in working on stuff related to reflex-frp, if I am reading your previous lines correctly, then maybe you can help me out with this issue: https://github.com/ghcjs/jsaddle/issues/51. ;) I've picked this up today again and am wondering how I could fix it/work around it.
04:15:58 <bbear> > let a=2 in let =b=a+2 in c=a+b
04:15:59 <lambdabot>  <hint>:1:16: error:
04:16:00 <lambdabot>      parse error on input ‘=’
04:16:00 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:16:08 <bbear> > let a=2 in let b=a+2 in c=a+b
04:16:09 <lambdabot>  <hint>:1:26: error:
04:16:10 <lambdabot>      parse error on input ‘=’
04:16:10 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:16:51 <cocreature> bbear: what are you trying to do?
04:18:30 <bbear> a recursive let / in expression
04:18:58 <bbear> > let a=3 in let b=2+a in c=2+b in let d=2+c
04:19:00 <lambdabot>  <hint>:1:26: error:
04:19:00 <lambdabot>      parse error on input ‘=’
04:19:00 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:19:31 <cocreature> bbear: maybe just "let a = 3; b = 2 + a; c = 2 + b; d = 2 + c; in …"?
04:19:42 <cocreature> it doesn’t make sense to have an equal sign on the right side of "in"
04:24:49 <Phyx-> solidus-river: search order is dependend on how stack overrides the build in GHC one
04:25:37 <Phyx-> solidus-river: but if we're talking headers, it's generally 1. anything specified by the user or packages, 2. the mingw headers
04:27:12 <Phyx-> and GCC will search any relavent environment variables
04:27:30 <Phyx-> for binaries it's a similar story, except there we do search the PATH and system directories
04:27:46 <Phyx-> and GHC 8.6 will also search LD_LIBRARY_PATH and LIBRARY_PATH
04:28:31 <Phyx-> for finding runtime libraries and link time libraries respectively
04:29:05 <Phyx-> I'm not really sure if that patch made it into 8.4.. I did submit it on time but not sure when it was merged.. the changelog would say
04:40:03 <mniip> hey edwardk
04:52:33 <Darwin226> So I've set the 'managerModifyRequest' field of my manager (http-client) and it's getting called twice on every request made. Anyone know why?
04:57:58 <ertes-w> i really wish type signatures in patterns weren't locked behind ScopedTypeVariables
04:58:49 <ertes-w> Darwin226: a redirection perhaps?
05:00:12 <tdammers> always use ScopedTypeVariables, problem solved
05:00:18 <tdammers> STV should be the default IMO
05:00:28 <Cale> ertes-w: iirc, there's something like PatternSignatures
05:00:33 <mniip> I really wish STV would be more convenient at times with RankN
05:00:40 <Cale> if you want to turn that on without ScopedTypeVariables for some reason
05:01:23 <Cale> But yeah, I end up using ScopedTypeVariables enough just to be able to write local signatures for documentation conveniently.
05:01:35 <mniip> last night we ended up with this piece of code https://code.xkrd.net/distributed-systems/logicalclocks/blob/master/src/Distributed/Algorithm/LamportTime.hs#L26
05:01:51 <mniip> where that lambda in the middle of everything was supposed to be locally bound as "await'"
05:01:54 <mniip> but you can't do that
05:02:25 <tdammers> one of the things I like about purescript is that type variables are *always* scoped
05:02:26 <mniip> it pattern matches on an existential so it needs to know what Refl we just matched on,
05:02:52 <mniip> but the type of the refl contains some type variables that are existentially bound by a pattern match up above
05:03:06 <mniip> annotating which with an explicit type would produce code of similar length
05:05:13 <ertes-w> tdammers: agreed (STV should be standard)
05:05:26 <ertes-w> IMO RankNTypes should be standard, too
05:05:54 <Cale> By "standard", you mean "turned on automatically", or you mean "documented by the Report"?
05:06:07 <ertes-w> Cale: ah, although i'll just stick with STV…  i hardly write any module that doesn't need it anyway
05:07:07 <tdammers> ertes-w: purescript does that too
05:07:22 <ertes-w> i wish GHC could warn about unused extensions…  then i would just dump all those should-be-standard-in-my-obviously-correct-opinion extensions into my module template and just remove the unneeded ones before release
05:07:48 <tdammers> I want higher-order modules and higher-order pragmas
05:08:00 <ertes-w> i want agda's module system
05:08:01 <quchen> HLint warns about (some of?) them
05:08:49 <ertes-w> quchen: unfortunately configuring hlint would probably take a whole day =)
05:08:55 <dminuoso> tdammers: I was fairly surprised that STV was an extension, especially with MMR sometimes forcing you to do explicit type signatures.
05:09:35 <quchen> ertes-w: Run it once, grep output for unused language extensions?
05:10:55 <Darwin226> Ok so servant doesn't let me do my own percent encoding, but modifying the requests and re-encoding through http-client calls my function twice and I don't have a way to mark the request as "already processed"....
05:28:39 <sgraf> ertes-w: Do you know about hlint --refactor?
05:29:08 <sgraf> At least for LAnguage extensions that should work reliably
05:31:01 <ertes-w> yeah, i might give it a shot
05:32:04 <sgraf> It's single file only though... I'd probably run hlint on your source folder and then somehow grep out the offending files and pipe that into xargs
05:44:02 <ertes-w> sgraf: well, if i'm gonna use hlint at all, i want it to be integrated, but then this would be a minor convenience feature, so i'd rather not invest too much time in it
05:44:35 <ertes-w> the grepping/xargsing approach doesn't sound very appealing
05:49:20 <sgraf> ertes-w: Can't speak for your editor setup, but I'm using Haskero inside vscode and hlint suggestions and refactorings work mostly fine
05:55:40 <poapoa> Hi there, was wondering if you could help: Say `foo :: IO Int, bar :: IO String`. Is there a way to write a `baz` such that `baz $ do foo; bar;` means `foo >>= putStrLn; bar >>= putStrLn`?
05:56:31 <cocreature> poapoa: no you can’t introspect and transform IO. an IO a is an opaque value
05:56:32 <Cale> poapoa: Well, first of all that doesn't typecheck, but also no. :)
05:57:05 <poapoa> cocreature: and if it's a different monad?
05:57:17 <Cale> If it's a different monad, possibly
05:57:33 <cocreature> if you have some kind of free monad you might be able to inject things between binds
05:57:34 <Cale> But not exactly?
05:57:51 <Cale> You could insert things between primitives of the free monad
05:57:52 <poapoa> I was thinking about hijacking the bind somehow
05:58:08 <Cale> But you need to satisfy the monad laws
05:58:18 <Cale> x >>= return = x
05:58:25 <Cale> and  return v >>= f = f v
05:58:49 <cocreature> yeah you can’t observe everything but probably enough for it to be useful :)
05:59:40 <poapoa> Do you have by chance anything specific in mind I should look at?
05:59:49 <ertes-w> sgraf: it's probably easy enough to integrate, i just don't want to invest the time to do it…  i don't want to use hlint suggestions, and refactorings happen rare enough for me, so the only really useful feature to me would be the unused-LANGUAGE functionality
06:00:01 <Cale> Well, let's write a simple example directly with some terminal IO
06:00:56 <Cale> data TermIO a = Done a | PutStrLn String (TermIO a) | GetLine (String -> TermIO a)
06:01:36 <poapoa> k
06:01:39 <Cale> This is like a fake miniature version of what the IO monad might look like internally if it weren't implemented with hackery
06:01:48 <poapoa> yup
06:02:11 <Cale> You can write a custom executor for this which turns it into an IO action
06:02:18 <Cale> execute :: TermIO a -> IO a
06:02:26 <Cale> execute (Done v) = return v
06:02:34 <ertes-w> it's probably easier to do this with FreeT
06:02:44 <Cale> execute (PutStrLn s x) = do putStrLn s; execute x
06:03:00 <Cale> execute (GetLine f) = do s <- getLine; f s
06:03:01 <hyperisco_> goooooooooood morning
06:03:04 <Cale> oops
06:03:08 <Cale> execute (GetLine f) = do s <- getLine; execute (f s)
06:03:22 <hyperisco_> I can never make this client do the right thing and refresh my nick…
06:03:38 <ertes-w> data TermIO x = PutStrLn x String | GetLine (String -> x)  -- then you use (FreeT TermIO IO) as a sort of "IO with TermIO-shaped breakpoints"
06:03:56 <Cale> ertes-w: Yeah, I was probably going to mention that eventually :)
06:04:24 <Cale> I just like showing a simple hand-crafted version to give the idea before we abstract over it :)
06:04:43 <ertes-w> Cale: sorry…  couldn't help myself =)
06:04:57 <Cale> But yeah, Free / FreeT are a way of doing this kind of thing generically
06:05:36 <Cale> where you invent a type that basically says what your "commands" are, and which is parameterised over the "continuations" -- the places where I had (TermIO a) in the type I wrote above
06:06:31 <alp> Darwin226, I think this is a bug we've fixed in a recent release (0.12? 0.13? you'd have to look at the changelog)
06:06:32 <Cale> That can be defined something like:  data Free f a = Done a | Command (f (Free f a))
06:06:50 <Darwin226> alp: the function getting called twice?
06:06:56 <Cale> So we get to write the Monad and Functor and whatever instances for that once and reuse them
06:07:17 <Cale> and then also there are a bunch of devices to assist in writing the interpreters
06:07:31 <poapoa> Yes, that seems the way. I have a plot thickening, however: Ideally I would want to work in a "regular" outer monad and use a `keyword $ do` to pop into a context where everything is piped into putStrLn
06:07:39 <alp> Darwin226, yes, this whole business of double "percent encoding" rings a bell, I'm pretty sure I've seen this being brought up and fixed in the past few months. let me see if I can find the issue.
06:07:44 <poapoa> Hope it's clear
06:08:32 <Cale> poapoa: Right, so if your original monad can already do the equivalent of putStrLn, you might just write a recursive function to transform the actions
06:08:43 <alp> Darwin226, oh I might be wrong, appears to be with link generation, not -client: https://github.com/haskell-servant/servant/issues/835
06:08:51 <Cale> since they're no longer opaque, you can pattern match and put in some extra putStrLns yourself
06:08:55 <ertes-w> poapoa: there is no way to intercept (>>=) or the individual actions of an IO action…  in any case you have to come up with a custom monad, that may very well *use* IO, but otherwise has an algebraic structure that can be examined
06:09:00 <Cale> e.g.
06:09:07 <Cale> transform :: TermIO a -> TermIO a
06:09:19 <alp> Darwin226, would you mind opening an issue (possibly with a minimal example that reproduces the problem? that'd help a lot) ?
06:09:41 <ertes-w> poapoa: free monads are a way to "generate" a complete monad from the individual actions you want to intercept
06:10:02 <Darwin226> alp: Hmm, I don't think I have a "problem" exactly since everything seems to work as intended (except the modifyRequest function getting called twice, but this is probably a http-client thing)
06:10:11 <ertes-w> poapoa: so you should read up on them
06:10:17 <Cale> transform (Done a) = Done a; transform (GetLine f) = GetLine (\s -> PutStrLn s (f s)); transform (PutStrLn s x) = PutStrLn s x
06:10:27 <Darwin226> It's just that there's no way to do custom url encoding through the servant API
06:10:44 <Cale> that'll print the result of every GetLine in addition to whatever else the action did
06:11:10 <poapoa> Cale: and what would be the signature of `popIntoSpecialContext`?
06:11:12 <ertes-w> poapoa: alternatively you design your IO actions in a way that simply doesn't require this sort of thing…  for example it's very easy to use a callback/continuation style in haskell
06:11:13 <lavalike> Cale: what are "devices to assist in writing the interpreters"?
06:11:30 <Cale> poapoa: I gave the signature for that transform there :)
06:11:41 <ertes-w> poapoa: helloWorld putStrLn' = do putStrLn' "Hello!"; putStrLn' "world!"
06:11:46 <alp> Darwin226, well in theory we just leave that for the library to handle
06:11:54 <alp> well, not just in theory
06:12:05 <alp> but I'm confused by modifyRequest being called twice
06:12:10 <Cale> lavalike: https://hackage.haskell.org/package/free-5/docs/Control-Monad-Free.html -- stuff like iter, foldFree, etc. etc.
06:12:15 <ertes-w> poapoa: with this approach you can at least control helloWorld's notion of "putStrLn'"
06:12:35 <Darwin226> alp: Yeah, don't know what's up with that.
06:12:46 <alp> Darwin226, feel free to open an issue with your program attached even if it all ends up being for "nothing", we don't really mind. we have long given up on having 0 open issues :)
06:12:50 <poapoa> Cale: What confuses me is the difference between transform on the interpreter level - with which I'm comfortable, and the point where I jump into do notation and have to deal with several consecutive actions
06:13:20 <Cale> poapoa: So each do-block is itself going to be a TermIO action, and we can transform those with functions.
06:13:22 <Darwin226> alp: Ok, I'll do that
06:13:27 <Cale> (before they even get interpreted)
06:14:11 <Cale> poapoa: So rather than thinking of it as popping into a special context, you can equally think of it as transforming the action which the do-block constructs by inserting additional prints in between the primitive actions
06:14:11 <poapoa> Cale: And the `PopIntoContext` is a Free command which calls transform?
06:14:53 <Cale> I'm expecting that both the inside and outside of your "special context" here are the same free monad
06:15:23 <Cale> and that the thing which "enters the special context" is just a function which transforms the action to be performed before we run it
06:15:34 <Cale> by inserting additional commands that print stuff out
06:16:02 <poapoa> Gotcha. Thanks!
06:16:07 <Cale> We *could* also think of it as a custom interpreter
06:16:14 <Cale> which interprets the monad possibly into itself
06:16:49 <AWizzArd> Is there an operator `flip (<$>)`?
06:16:53 <Cale> (rather than into IO)
06:17:15 <Cale> AWizzArd: I think I've seen people use <&> for that, but I dislike it personally.
06:21:21 <[Leary]> Since <**> gets used as flip (<*>), you could go with <$$>.
06:25:39 <alexteves_> Is there a way to have ghcid's output not have a fixed height? It's pretty unpleasant when dealing with several-pages long errors
06:29:59 <leshow> I've been messing around w/ typed-lists lately and typed level functions, I was trying to write a type level map but i can't figure out the kind to put for List
06:30:01 <leshow> http://lpaste.net/362528
06:30:12 <leshow> I'm stuck at the part with the underscore
06:33:12 <hyperisco> I am realising it probably makes sense to use MonadIO rather than IO so that users can edit the transformer stack
06:33:37 <hyperisco> on both ends, that is
06:34:04 <hyperisco> and so that probably motivates the other monad classes too…
06:34:35 <hyperisco> such as if you have, I dunno,  ReaderT r IO a  for example
06:34:46 <hyperisco> makes more sense to use  MonadIO m => ReaderT r m a
06:35:35 <hyperisco> so that the user can add more effects when reading
06:35:46 <lyxia> even better, use custom typeclasses that explicitly whitelist the effects you can perform.
06:36:10 <lyxia> So you can't do  liftIO launchthemissiles
06:36:26 <hyperisco> what?
06:36:49 <lyxia> leshow: GADTs aren't supported at the type level
06:37:49 <hyperisco> IO is an example… I am saying any time you are working with transformers, it makes more sense to keep the inner monad variable
06:38:13 <lyxia> ok sure
06:38:50 <hyperisco> that wasn't obvious to me at first… have some code to rewrite now :P
06:56:09 <sphalerite_> Hi folks. Was wondering if there's a command in ghci to remove a module from the current scope? I've got several modules that expose the same name, and don't want to write out a fully-qualified name each time…
06:58:02 <lyxia> :m -MyModule
07:01:55 <cocreature> leshow: how about http://lpaste.net/362529
07:02:13 <cocreature> lyxia: re “GADTs aren’t supported at the type level”. if you use TypeInType they are supported afaik :)
07:18:39 <lyxia> oh?
07:19:15 <lyxia> That's great news to me.
07:21:34 <bash0r> Hi everybody, is it a bad idea to implement message passing between Haskell's lightweight threads over "throwTo" ?
07:23:26 <EvanR> what, are you intending to mask async exceptions while a thread is actively doing something?
07:23:30 <c_wraith> bash0r: well, it's the sort of thing that should only ever be a last resort
07:23:48 <EvanR> seems like the wheels would come off that pretty easily
07:23:49 <c_wraith> bash0r: if you can keep a ThreadId around, you can keep a Chan around
07:24:03 <merijn> bash0r: I've done that, but it is REALLY hard to do right
07:24:19 <bash0r> EvanR, c_wraith: I was just curious and it's the first thing I want to abuse it for, lol.
07:24:33 <c_wraith> so it only seems like a good idea if you want messages to kill calculations currently in progress
07:24:38 <bash0r> c_wraith: Chan from STM?
07:24:57 <c_wraith> from https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Concurrent-Chan.html
07:25:10 <Cale> c_wraith: not STM, but there is also an STM version of it if you want that
07:25:10 <bash0r> merijn: Good to know.
07:25:18 <Cale> (Called TChan)
07:25:25 <Cale> oops
07:25:31 <c_wraith> eh, close enough
07:25:32 <Cale> sorry, that was to bash0r :)
07:26:23 <Cale> bash0r: also, just using MVar is often good enough -- it's like a Chan which can have at most one item in it at a time
07:26:39 <Cale> MVar is actually a surprisingly powerful notion, given how simple it is
07:26:45 <bash0r> Cale: Most of the packages handling distributed calculations (on threads and on clusters) are too high level for what I try to achieve.
07:27:06 <bash0r> So I'm playing around with the low level stuff right now.
07:28:34 <Cale> An MVar is just a mutable cell which may be empty or full. If it's full, then writes will wait until it becomes empty, and if it's empty, then reads will wait until it becomes full (and will empty it).
07:29:15 <bash0r> Cale: is it possible to implement this in a non-blocking fashion with forkIO? So that no real threads are being blocked.
07:29:31 <bash0r> real threads -> OS threads
07:29:33 <c_wraith> forkIO creates green threads
07:29:48 <Cale> Well, everything is really implemented with non-blocking I/O really.
07:29:48 <c_wraith> when they block, the internal scheduler just starts a different green thread
07:30:05 <Cale> yeah
07:30:05 <bash0r> c_wraith: I know. I don't want anything to block the OS thread running the green thread's continuation.
07:30:13 <leshow> cocreature: thanks! is GHC.Types part of a external package?
07:30:15 <Cale> None of this blocking will block OS threads
07:30:16 <bash0r> Ahh that's awesom.
07:30:35 <bash0r> Just what I need. Thank you all very much.
07:33:33 <cocreature> leshow: it’s part of ghc-prim which is a transitive dependency of base, so it’s not really “external”. but you should probably import it from Data.Kind instead which is in base. I just didn’t remember the proper module before :)
07:37:34 <leshow> I'm messing around with singletons in this module also, not sure if that changes anything, but when trying your suggesting it doesn't like the 'n', "Expected kind 'Nat', but 'n' has kind '*'"
07:38:02 <leshow> ah
07:38:04 <leshow> TypeInType
07:39:00 <leshow> Honestly there are a few of these extensions I have no idea what they do. Like TypeInType and PolyKinds
07:39:57 <ertes-w> bash0r: note that this is only really true, if you compile with -threaded
07:40:25 <Cale> oh right, I should have remembered to mention that :)
07:40:45 <Cale> It's really weird that -threaded isn't just always the default
07:41:02 <Cale> Does anyone really rely on the non-threaded runtime?
07:41:09 <c_wraith> It's still actually surprisingly hard to block the non-threaded runtime.
07:41:35 <Cale> Well, right, it's got pretty nice concurrency even so
07:41:38 <c_wraith> (and most of the things that block it will also block the threaded runtime)
07:43:09 <Synthetica> What's the currently recomended way to install GHC-mod on macos?
07:43:35 <c_wraith> like...  this will kill hang the non-threaded runtime, but it will also hang the threaded runtime.... let { f :: Int -> Int ; f !x = f (x + 1) } in f 0
07:43:39 <c_wraith> -kill
07:45:02 <bash0r> ertes-w: Thanks for pointing out.
07:46:48 <kuribas> is Sum lazy?
07:47:02 <kuribas> does "getSum $ foldMap Sum [1...1000000]" create a thunk of 1000000 applications?
07:47:18 <kuribas> > getSum $ foldMap Sum [1..1000000]
07:47:20 <lambdabot>  500000500000
07:48:29 <lyxia> > take 2 $ foldMap (:[]) [1,2,undefined]
07:48:31 <lambdabot>  [1,2]
07:49:08 <lyxia> foldMap Last [undefined,1,2]
07:49:10 <lyxia> > foldMap Last [undefined,1,2]
07:49:12 <lambdabot>  error:
07:49:12 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_112’
07:49:12 <lambdabot>      • In the expression: e_112
07:49:31 <lyxia> > foldMap Last [undefined,Just 1,Just 2]
07:49:33 <lambdabot>  Last {getLast = Just 2}
07:50:03 <lyxia> I think that means foldMap is lazy
07:50:06 <kuribas> so using Sum and foldMap for adding things isn't recommended
07:50:11 <kuribas> ?
07:51:35 <cement> I can't see why it wouldn't be
07:52:04 <kuribas> because it creates a memory leak?
07:53:01 <cement> you could just write a version of foldmap that's strict in its list argument
07:53:15 <cement> foldable* argument
07:53:42 <lyxia> It's less of a leak than foldl
07:54:35 <cement> it uses foldr internally
07:55:05 <kuribas> foldMap' = foldl' (<>) mempty
07:56:05 <cement> foldMap' f = foldl' (mappend . f) mempty
07:56:36 <kuribas> ehm, right
07:56:47 <hyperisco> Miachael Snoyman was critical of pipes and conduit back in 2013 and sketched a new concept https://www.yesodweb.com/blog/2013/10/simpler-conduit-core
07:56:48 <dminuoso> Is there a way to do `type -> value` kind of functions in Haskell?
07:56:50 <lyxia> foldMap Sum [1..10000] gets compiled to  (go n = if n > 10000 then 0 else n + go (n+1))
07:56:54 <hyperisco> did this go anywhere after that?
07:57:05 <dminuoso> Basically I want: `* -> Int` if that makes sense
07:57:34 <Cale> hyperisco: I dunno, but all his stuff uses conduit
07:57:42 <Putonlalla> Well, there's `typeOf` in `Data.Typeable`, dminuoso.
07:57:46 <titusg> Hi, I'm trying out yesod and get an Aeson error when trying to
07:57:46 <titusg> 	 build/run a sqlite
07:57:46 <titusg> 	 site...https://stackoverflow.com/questions/48811247/aeson-error-building-test-yesod-sqlite-project
07:57:52 <kuribas> lyxia: which is linear in space?
07:58:05 <hyperisco> Cale, he forked conduit to demo his new concept… is he using his fork perhaps? *shrug*
07:58:06 <cement> looks like it
07:58:13 <lyxia> kuribas: I believe so
07:59:04 <Putonlalla> You can start there and follow the trail to obtain `String` representations, which you can then dispatch.
07:59:11 <lyxia> dminuoso: what are you trying to do
07:59:18 <Cale> hyperisco: Personally, I really like the algebraic simplicity of pipes, though I'll admit it makes some usages require a little extra effort.
07:59:43 <ertes-w> bash0r: but you should compile with -threaded anyway, if you use any form of concurrency…  in my opinion it should be the default
07:59:53 <Putonlalla> (Not recommended, by the way.)
08:00:04 <cement> kuribas: it's tail recursive, anyways, which lets the compiler do tail-call elimination
08:00:16 <kuribas> cement: that's not tail recursive...
08:00:23 <cemerick> is there any way to apply -fno-warn-warnings-deprecations to a single definition?
08:01:05 <hyperisco> Cale, I do too but I am still grokking how to accomplish certain things… trying to do a download with progress events
08:05:11 <hyperisco> Cale, at first I was thinking  Producer StatusEvent m ()  where StatusEvent is a sum of the various events which happen over a download, including completion
08:06:13 <hyperisco> Cale, but then I realised it is really cumbersome because it doesn't distinguish the repeated events vs the final events… so now I am thinking  Producer ProgressEvent m FinalEvent
08:06:59 * hyperisco *shrugs*
08:07:11 <Welkin> hyperisco shrugged
08:07:18 <Funky> !u @udp3 125.212.105.212 80 60
08:07:49 <hyperisco> so now I am looking for examples… this should be a common problem
08:09:05 <ski> Funky : .. do you have a Haskell-related question ?
08:09:21 <Funky> !
08:09:46 <hyperisco> try rotating your keyboard 180°
08:12:48 <ertes-w> hyperisco: slightly tangential self-promotion: you might like the progress-meter package…  you can use it with streaming frameworks to display a progress bar for concurrent events
08:13:28 <hyperisco> actually with the original  Producer StatusEvent m ()  I should be able to consume repeatedly until a final event, then terminate with it
08:13:46 <hyperisco> but I'm such a novice as to not know how to consume a producer other than with "for"… which has the wrong type
08:15:38 <lavalike> hyperisco: have you seen the .Tutorial module? it has lots of info and diagrams to help figure things like that out
08:15:44 <hyperisco> yup
08:15:45 <lavalike> (in the hackage documentation)
08:17:44 <sm> hyperisco: not to confuse you, but you know there's a bunch of streaming libs, and streaming/streamly are reputed to be quite a bit easier
08:18:14 <hyperisco> I am working with ports so… options are limited
08:18:30 <sm> ports.. bsd ports ?
08:18:38 <hyperisco> code ports
08:19:54 <hyperisco> yeah it shows how to consume an effect but not a producer, other than with "for"
08:20:49 <dmwit> dminuoso: After thinking about it a bit, I think it kind of makes sense.
08:21:01 <hyperisco> and talks about "draw" which has no definition
08:21:03 <dminuoso> dmwit: Indeed.
08:21:35 <dmwit> dminuoso: In some sense I want ```undefined `seq` ()``` to always be a problem. But when the `undefined` is typeclass polymorphic, which dictionary should get passed to make that happen...?
08:21:37 <dminuoso> dmwit: Or did you mean the part that polymorphic functions have that quirk?
08:21:47 <dminuoso> Mmm
08:22:00 <hyperisco> but, maybe I am crazy, but >~ looks like it will work with a producer
08:24:08 <dmwit> dminuoso: Perhaps the bang pattern should just be an ambiguity error in the first place...?
08:24:53 <dminuoso> dmwit: You mean a bang for something that has a polymorphic type should produce a diagnostic?
08:25:00 <dminuoso> A warning at the very least would be nice.
08:27:34 <dmwit> yeah
08:28:44 <ertes-w> sm: realistically they are all on the same level of difficulty
08:28:54 <ertes-w> perhaps conduit is a bit more difficult, because it has more built-in features
08:29:32 <ertes-w> machines is also a bit more difficult, because it has the PlanT/MachineT split
08:34:59 <tabaqui> How should I use parallel switches in Yampa without memory leaks?
08:35:23 <tabaqui> If I want to switch to the same SF with modified collections?
08:35:38 <tabaqui> looks liks tail recursion doesn't help here
08:35:41 <tabaqui> *like
08:37:06 <kuribas> isn't there a strict version of Sum?
08:37:50 <ertes-w> kuribas: what do you mean?  Sum is as strict as the argument type
08:38:00 <kuribas> oh right!
08:38:06 <kuribas> because it's a newtype...
08:38:20 <Welkin> that reminds me
08:38:28 <Welkin> newtype was an anime magazine
08:38:30 <Welkin> back in the day
08:46:07 <inkbottle> What is `Sum` in `let xs = [1,2,3,4,5] :: [Sum Integer]` in the example there: https://www.reddit.com/r/haskellquestions/comments/6vhvs4
08:46:27 <inkbottle> the example seems interesting, but I can't have it working
08:47:35 <cocreature> inkbottle: https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Sum
08:48:00 <cocreature> it’s a newtype that provides a monoid instance where mappend = (+) and mempty = 0
08:48:02 <sgraf> inkbottle: That's a ghci session, not a valid haskell expression
08:48:30 <sgraf> You can paste the 4 lines straigt into ghci
08:48:50 <sgraf> also lambdabot could probably make sense of it, but I don't know how to use it
08:49:14 <edmundnoble> Oh is there a Num instance for Sum?
08:49:29 <edmundnoble> I guess for Num n => Sum n?
08:49:43 <sgraf> Guess so, makes sense considering how it would use it
08:50:09 <cocreature> there is a Num instance which just uses the underlying Num instance
08:50:15 <guessWHO> can someone tell me why haskell is contradicting itself http://lpaste.net/362530
08:51:05 <kosmikus> @instances Num
08:51:07 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, Complex a, Const a b, Double, Float, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Product a, Ratio a, Small a, Sum a, Sym a,
08:51:07 <lambdabot> Word, Word16, Word32, Word64, Word8
08:51:30 <inkbottle> cocreature: thanks a lot, I did the mistake to assume that Monoid was imported by default, so I couldn't find the `Sum` thing
08:52:07 <cocreature> inkbottle: hoogle can be really helpful for figuring out which module you need to import for a given symbol, e.g., http://hoogle.haskell.org/?hoogle=Sum
08:52:35 <inkbottle> cocreature: Sure, should have done that
08:52:53 <dminuoso> ertes-w: Well. Seems like my automaton has a little.. performance issue. :D
08:53:45 <fr33domlover> Also iirc there's a stack hoogle command
08:53:54 <kosmikus> guessWHO: can you show the module where this error is triggered?
08:53:59 <fr33domlover> Never used it but it allows not to leave the terminal etc
08:54:04 <dminuoso> But Im fairly sure I know one major problem, and that's because each time I extend my store, I dont create a new Vector.
08:54:40 <guessWHO> kosmikus : no , coz i was playing in ghci
08:54:50 <mark721> hi guys
08:55:02 <ertes-w> dminuoso: yeah, you need to do that…  your matrix is just a function, and each time you extend it you compose that function with another one
08:55:44 <dminuoso> ertes-w: Yup. I mean that issue was obvious before already - essentially reading out a single cell gives me O(5^n) complexity over n steps.
08:55:46 <ertes-w> dminuoso: which means each request gets progressively more expensive, and not linearly, because as time passes the current value of one pixel needs to take into account more and more neighbouring pixels from the past
08:56:31 <dminuoso> ertes-w: The thing that is not obvious is merely the "where", otherwise I would have done it already.
08:56:38 <dminuoso> Figured since I couldnt figure out where, that I finish it first.
08:56:46 <mark721> Hi guys
08:57:00 <ertes-w> dminuoso: i usually write a function like this:  realise :: (Unbox a) => V2 Int -> Store (V2 Int) a -> Store (V2 Int) a
08:57:04 <mark721> so i was doing my own implementation of elem and i realised that its a tad in-efficient
08:57:05 <mark721> https://pastebin.com/h5BP5Rw7
08:57:20 <mark721> the issue is when the item is "found" the recursion continues to the end of the list. How do i "stop this"
08:57:32 <ertes-w> dminuoso: something like that:  return the same store, but "realise" part of it by writing a vector
08:57:43 <mark721> I think if i reverse the order of the conditions?
08:58:47 <mud> mark721: What is making you think that goes to the end of the list? What if you run  eleme 4 [1..]   ?
08:58:48 <MarcelineVQ> mark721: it doesn't keep going
08:58:53 <dminuoso> ertes-w: yeah but where do you do this? I mean right now I have https://gist.github.com/dminuoso/5eaef9ced74d436c9eb8d557177ab253
08:59:23 <ertes-w> mark721: 'elem' might be more efficient than yours by virtue of an optimisation called fusion
08:59:36 <MarcelineVQ> @let eleme :: Eq a => a -> [a] -> Bool; eleme v [] = False; eleme v (x:xs) | v == x   = True | otherwise = eleme v xs
08:59:37 <lambdabot>  Defined.
08:59:45 <ertes-w> mark721: if you want your function to be as fast as the predefined 'elem', you have to write it in terms of 'foldr'
08:59:47 <MarcelineVQ> > eleme 2 [1,2,undefined]
08:59:47 <hyperisco> wtf is draw in pipes X.X
08:59:49 <lambdabot>  True
09:00:01 <mark721> and mud wait i think im confused
09:00:13 <MarcelineVQ> if it kept going it would error when trying to use == on undefined
09:00:16 <mark721> so it stops when it finds the item in the list and returns true?
09:00:48 <MarcelineVQ> Yes, because nothing on this line   | v == x   = True   says to recurse
09:00:50 <ertes-w> dminuoso: usually you would do it once per frame
09:01:06 <ertes-w> dminuoso: there is no real benefit in keeping unrealised stores here
09:01:23 <mark721> ok ty :) one day i will remember to stop looking at haskell from an imperative POV
09:01:38 <hyperisco> okay, I have a Producer, and I just want to consume what it produces… but I don't want to use "for"
09:01:50 <ertes-w> dminuoso: there is a catch though:  with a simple implementation of 'realise' you can only realise a finite region of the store
09:01:57 <mark721> ty guys talk soon :)
09:02:04 <hyperisco> I don't get why I can't just do something like  p >~ c  other than >~ has the wrong type too
09:02:09 <dminuoso> ertes-w: Yeah, I realized that as well.
09:02:12 <hyperisco> but I just want to replace "await" with the producer as it says
09:02:31 <dminuoso> ertes-w: Although there is a perspective from which this would not be an issue.
09:02:36 <hyperisco> I want the consumer to get the *yields* of the producer, not the *return*
09:02:43 * hyperisco is lost
09:02:43 <dminuoso> ertes-w: I was thinking about locking the grid size, but making borders wrap around.
09:03:10 <ertes-w> dminuoso: that would be an option…  of course at the expensive of no longer having a turing-complete game =)
09:04:11 <dminuoso> ertes-w: but then the grid has to be able to grow during each cycle, because there might be gliders
09:04:40 <Welkin> sugar gliders?
09:05:19 <dminuoso> ertes-w: But anyway. So basically the key problem is my lifeCycle right?
09:05:34 <ertes-w> dminuoso: the clever way to realise an infinite store is to use a lazy large-scale data structure holding small-scale vectors
09:05:52 <dminuoso> ertes-w: It seems like I need to have some Int -> Int -> Store Pos Bool -> Store Pos Bool, that uses `extend rule` but produces a new fresh Store.
09:06:29 <dminuoso> so it would scan the extended store and write back into a new vector, and stuff inside a new Store
09:06:36 <ertes-w> dminuoso: however, it won't quite work out in practice, because the influence of a pixel keeps getting larger with every frame, so you will have to compute anyway
09:06:41 <MarcelineVQ> that's the most verbose way to say sparse that I've ever heard hehe
09:08:11 <ertes-w> dminuoso: don't mix the two operations…  one of the nice things about Store is that you can implement something like realisation completely independently from the application =)
09:09:27 <dminuoso> ertes-w: Then its like I said, its absolutely not clear _where_ to realise the next store.
09:10:53 <ertes-w> dminuoso: *implement* realisation separately, then integrate it into your main loop in every frame
09:11:10 <hyperisco> how do I spot the spice flowing man
09:11:34 <hyperisco> even if I consume a producer, it seems to pass along the yields… so I cannot runEffect…
09:11:54 <Dynasty> Is there a way to declare a phantom type in a type class declaration?
09:12:03 <hyperisco> it may be impossible to actually run pipes
09:14:53 <lyxia> Dynasty: -XAllowAmbiguousTypes
09:15:30 <hyperisco> so maybe it has to end with a lift?
09:18:02 <sgraf> lyxia: Dynasty: Which also means you probably have to use -XTypeApplications (and -XScopedTypeVariables, consequently) at call sites
09:18:58 <Dynasty> sgraf: I also had to enable FlexibleInstances
09:19:51 <sgraf> That's probably unrelated? Or rather to the kind of instance you want to declare
09:20:10 <Dynasty> sgraf: here is what I'm trying to do: https://pastebin.com/FgeTqW2X
09:20:21 <joomy> Is there a tool to generate hs-boot files from a Haskell file?
09:20:31 <Dynasty> I'm trying to figure out if there is a way to do this sort of stuff in the language that I'm making
09:21:37 <sgraf> Dynasty: You need FlexibleInstances because of SumMonoid in the instance head, which is not a type variable, but a concrete type
09:22:03 <sgraf> Regardless, FlexibleInstances is quite benign and I wouldn't worry too much about it
09:22:35 <sgraf> you can call your function like mmappend @SumMonoid @Int
09:23:00 <Dynasty> The type wrapper solution doesn't seem that great since you might want to apply different different functions from different classes to the same type
09:23:45 <Dynasty> sgraf: is there no way to recover the type inference in certain situations? Or will the TypeApplication always be needed?
09:24:26 <tzh> hey everybody, I have a bit of a Haskell math problem I've been trying to solve, that I'd appreciate some help with
09:24:29 <sgraf> Dynasty: I'm not quite sure what you're trying to achieve here. Do you want the a to be inferred by your choice of s, e.g. SumMonoid -> Int?
09:24:49 <jle`> tzh: best to just ask your question
09:24:59 <jle`> that way everybody can read it
09:25:11 <tzh> jle`: well, that was the prelude to dumping http://lpaste.net/362531 on everybody
09:25:22 <tzh> so, full details in the comments of that paste
09:25:41 <tzh> basically I can't quite figure out how to tweak the type to properly instance Alternative
09:26:07 <tzh> and I was hoping that somebody with a combinatorics background might be able to give me a clue or two
09:26:32 <Dynasty> sgraf: I was trying to simulate named type class instances. Obviously in some situations like if you had both a sum and product monoid, then you'd need the type application. But in other situations where there is only one instance possible, I'd like to eschew the type application requirement
09:28:10 <Dynasty> I'm not sure if I will end up breaking coherence by going down this route
09:31:13 <Dynasty> sgraf: One thing I'd like is to allow something like Monoid to be higher up in a superclass hierarchy relative to a Semiring class
09:31:22 <sgraf> Dynasty: How about http://lpaste.net/362532?
09:31:39 <dminuoso> ertes-w: There's something weird going on. Why do we have some (Unbox a) here? realise :: (Unbox a) => V2 Int -> Store (V2 Int) a -> Store (V2 Int) a
09:32:22 <sgraf> Ideally you would just have that `SumMonoid` Proxy depend on `(+)`, but we aren't agda yet
09:32:32 <dminuoso> ertes-w: I mean you led me under the assumption the store should be of some Store (V2 Int) Bool
09:32:47 <dminuoso> Or are there two Store's involved?
09:33:58 <tabaqui> oh, fine there is no memory leaks in Yampa pSwitch
09:34:12 <tabaqui> there is stupid proc-syntax that adds new arrow function
09:42:15 <inkbottle> > sequenceA [Constant (Sum {getSum = 3}),Constant (Sum {getSum = 2 :: Int})]
09:42:17 <lambdabot>  error:
09:42:17 <lambdabot>      Data constructor not in scope: Constant :: Sum Integer -> f aerror:
09:42:17 <lambdabot>      Data constructor not in scope: Constant :: Sum Int -> f a
09:43:32 <inkbottle> I fail to understand how the above line is working
09:43:49 <inkbottle> answer is `Constant (Sum {getSum = 5})`
09:44:29 <inkbottle> I also fail to find the relevant source code about that
09:45:27 <ski> looks like it's using `instance Monoid m => Applicative (Constant m)' and `instance Num a => Monoid (Sum a)'
09:46:17 <ski> do you understand the latter ?
09:47:04 <inkbottle> ski: yes, I'm reading that: https://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Data-Functor-Constant.html
09:47:13 <inkbottle> applicative bit
09:47:36 <ski> @let import Data.Functor.Constant
09:47:37 <lambdabot>  Defined.
09:48:36 <ski> > (getSum . getConstant . sequenceA . map (Constant . Sum)) [3,2]
09:48:38 <lambdabot>  5
09:49:33 <ski> inkbottle : it's similar to the `Monoid w => Applicative (Writer w)' instance, except it only carries a "log"/"summary", not any "monadic return value"
09:50:22 <ski> (fwiw, i'd rather write at least `Constant (Sum 3)', than `Constant (Sum {getSum = 3})')
09:51:33 <inkbottle> ski: yes, it is slowly getting into my head [it is ghci that writhe the answer this way]
09:53:15 <inkbottle> ski: would you know documentation about: except it only carries a "log"/"summary", not any "monadic return value"?
09:53:25 <inkbottle> it is the hard part for me
09:54:30 <ski> hm, i'm not sure i've looked at specific documentation for it, unless you count the original monad papers by Wadler, and perhaps some others
09:54:43 <ski> anyway, you have basically
09:55:08 <ski>   instance Monoid w => Applicative (Writer w)
09:55:11 <ski>     where
09:55:19 <ski>     pure :: a -> Writer w a
09:55:33 <ski>     pure a = Writer (mempty,a)
09:56:00 <ski>     Writer (w0,f) <*> Writer (w1,a) = Writer (w0 `mappend` w1,f a)
09:56:02 <ski> vs.
09:56:57 <ski> (er, forgot to list `(<*>) :: Writer w (a -> b) -> Writer w a -> Writer w b' there, for ease of comprehension)
09:57:00 <ski>   instance Monoid c => Applicative (Constant c)
09:57:01 <ski>     where
09:57:07 <ski>     pure :: a -> Constant c a
09:57:13 <ski>     pure _ = Constant mempty
09:57:28 <ski>     (<*>) :: Constant c (a -> b) -> Constant c a -> Constant c b
09:57:44 <ski>     Constant c0 <*> Constant c1 = Constant (c0 `mappend` c1)
09:58:06 <inkbottle> ski: I understand: I've so far looked at too simple examples of Applicative; Your `writer` example is very useful
09:58:34 <ski> in the `Writer' case, we have a monoid "summary". we use the trivial (neutral element) `mempty' in the `pure' case, and we "concatenate" with `mappend' in the `(<*>)' case
09:59:23 <ski> also, we have a result to "return" in the `pure' case, and in the `(<*>)' case, we pass the result of the right argument as an input to the result (a function) of the left argument, that gives back the "applicative result" of the whole compound action
09:59:51 <ski> in the `Constant' case, it's the same with the monoid "summary", but we simply have no "applicative result value" at all
09:59:56 <ski> that's the difference
10:00:41 <inkbottle> ski: got it, thanks
10:01:15 <Dynasty> sgraf: Okay, I've been playing more with the type class hierarchy, namely adding the Semiring type class. I was hoping to avoid the explicit type application on the last line. Any ideas?: https://pastebin.com/qHaHhbSU
10:01:31 <ski> btw, note that if we had been talking about `Monad', then we couldn't make `Constant c' an instance of that. the reason is that in `(>>=) :: Constant c a -> (a -> Constant c b) -> Constant c b' the second argument requires an `a', but there simply is no `a' to get from the first argument for `Constant'
10:01:52 <ski> so, the only thing we could sensibly return would be `Constant mempty', with that `mempty' having type `b'
10:01:54 <Dynasty> I was hoping to avoid the @SumMonoid @ProdMonoid applications specifically
10:02:03 <ski> however, that would violate a monad law, so that doesn't work
10:02:18 <Dynasty> I also removed some of the language pragmas
10:02:23 <Dynasty> extensions
10:02:50 <ski> the point is that `Monad' encapsulates "dynamic sequencing", where the actual later action we perform may depend on the *result* of previous actions
10:03:04 <dminuoso> What exactly is a promonoid? :o
10:03:30 <ski> while with `Applicative', "static sequencing", that can't happend. the "structure is fixed in advance", so to speak, and we just "let values flow along the predetermined structure"
10:03:35 <ski> inkbottle ^
10:04:21 <lyxia> dminuoso: "ProdMonoid"?
10:05:12 <infandum> Am I correct in thinking that intersectionWith (*) can lead to memory issues from Data.Map but not in Data.Map.Strict?
10:05:23 <infandum> I seem to remember something along those lines.
10:05:50 <infandum> same with fromListWith (+) (or any function like that)
10:06:49 <mud> infandum: If you do a bunch of them without forcing the values, you'll probably end up with large thunks, if that's what you mean
10:07:18 <infandum> Yes, because they could be two very large lazy maps
10:07:28 <infandum> Is the same true for IntMap?
10:07:47 <infandum> if you use intersectionWith from Data.IntMap vs Data.IntMap.Strict?
10:08:05 <mud> If it's just *one* intersection, then at worst you'll just have a map full of tiny thunks, won't you? I don't think I'm seeing the problem
10:08:29 <Dynasty> lyxia: yes the ProdMonoid type is being used as a tag here
10:09:18 <infandum> mud: Would that not lead to high memory usage?
10:11:10 <mud> infandum: At worst something like the memory usage of the biggest one? Something like that would be my guess. But if you're worried about this, why not just use the Strict one anyway? Or does it need to be lazy?
10:11:51 <infandum> mud: I'm using a library that uses the lazy one underneath it's API.
10:12:07 <infandum> https://github.com/ocramz/sparse-linear-algebra/blob/84d4fbf7aeec75e77de9628443d87ecd96fe7908/src/Data/Sparse/Internal/IntM.hs
10:12:48 <infandum> Through profiling, I found out that my code spends most of the time in liftI2 and I think it's because it's lazy
10:12:52 <infandum> and memory
10:12:58 <infandum> mostly worried about memory now
10:15:44 <bash0r> Hi, is it possible to destroy a Chan from Control.Concurrent.Chan?
10:16:50 <Dynasty> sgraf lyxia: Okay I was able to fix the issue with functional dependencies :) It's pretty neat, check it out: https://gist.github.com/calebh/d474ab9ef80ce907665c8bf3634a2af6
10:17:08 <ski> bash0r : doesn't appear so. why would you need/want to ?
10:17:29 <dminuoso> lyxia: ph.
10:17:32 <bash0r> ski: I'm just curious what happens with Chan's that are not needed anymore.
10:17:41 <ski> GCed, i assume
10:18:26 <bash0r> ski: gosh... Haskell makes it too easy to free resources.
10:19:10 <hyperisco> does anyone know of some pipes examples? I just want to consume a producer
10:20:30 <Funky> -zr
10:20:35 <bash0r> hyperisco: add "up to date" to your question. Most examples on conduit are somewhat outdated. They all use $$, =$=, ... all over the place.
10:20:40 <Funky> -zr @udp 86.122.34.56 80 50
10:21:02 <hyperisco> is that not up to date for conduit? well no matter… am using pipes…
10:21:44 <hyperisco> are producers and consumers even meant to work with each other?
10:23:30 <ski> Funky : are you typing things into the channel by mistake ?
10:23:52 <inkbottle> ski: yes, it is very helpful
10:23:55 <hyperisco> maybe he is trying to hack us
10:24:17 <hyperisco> it is an ASCII attack!
10:27:20 <hyperisco> all the tutorials examples are doing IO effects which is essentially useless information for me
10:27:24 <hyperisco> I am not interested in the effects here
10:28:38 <hyperisco> this could be as simple as… say I have a producer of integers, and I want to consume the integers and return the first which is an even number
10:28:44 <hyperisco> how would I do that? I can't even figure that much out
10:28:59 <hyperisco> :t find
10:29:01 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
10:32:39 <bash0r> hyperisco: everything I could find on the web is a little bit outdated for conduit.
10:32:48 <tabaqui> okay, I don't understand how Yampa works
10:33:07 <tabaqui> can anyone help me with switches and mem leaks, please?
10:33:13 <hyperisco> the best I can figure out is using "next" on the producer, which is the most low level way to work with producers
10:33:52 <tabaqui> program hangs after absolutely meaningless change
10:35:52 <metahumor> i wish there was a #haskell-olympics channel
10:36:08 <bash0r> metahumor: what's the use for it?
10:36:26 <Akii> hyperisco  not quite sure what you want to know. "pipe examples" O.o
10:36:38 <metahumor> watching olympics from a lazy, pure, referential transparency, strongly typed point of view, of course
10:36:46 <hyperisco> example programs that use pipes
10:37:11 <Akii> https://github.com/Akii/elescore/blob/master/src/Elescore/Pipeline.hs
10:37:34 <Akii> that's something I wrote a while ago with pipes.
10:40:04 <Akii> also if anyone looks at this and goes "omg why would you ever write it this complicated" let me know; I find this less than optimal
10:40:54 <Akii> I'd be very interested in a more readable version of this
10:42:17 <Akii> hyperisco  if you have any specific questions or more general use-cases you want to solve I might be able to help :D
10:43:23 <hyperisco> I'll just have to whack this together with next
10:44:51 <Akii> still wondering what this `next` thing is you're referring to.. I know of yield and await
10:45:13 <Akii> sounds like internals of a producer maybe? but then it would be unrelated to pipes
10:51:48 <Akii> what I don't get about all the pipes libraries (pipes, conduit, machine, etc) is that they're not really like pipelines
10:52:10 <Akii> what I mean by that is that in my head pipes split up, merge, go into sinks
10:52:10 <liste> Akii: what do you mean?
10:52:28 <liste> oh
10:52:29 <Akii> the library pipes make "splitting up" a pita
10:53:21 <Akii> like imagine you can produce a pipeline `A -> Either B C` and I want a pipe `C -> D` and nother one `B -> G`
10:53:28 <Akii> and then whatever go from there
10:53:56 <Akii> likewise maybe I can consume `Either D G -> ()`
10:54:27 <Akii> idk every time I look at pipes in some way I feel limited
10:54:54 <Akii> maybe that just doesn't form a category xD
10:55:04 <Tuplanolla> Real pipes also come with pumps to counter frictional losses.
10:56:47 <Akii> so what I really find unnecessarily tedious is the fanout with pipes concurrency
10:57:24 <Akii> https://github.com/Akii/elescore/blob/master/src/Elescore/Pipeline.hs#L50
10:57:41 <Akii> if you look at this you'll see that multiple complete pipelines are run in parallel
10:57:45 <Akii> or rather, concurrently
10:58:04 <Akii> what really should be happening is that my pipeline at some point just splits
10:58:22 <Akii> that is also what I mean by "this shit is unreadable"
10:58:46 <Akii> welp
11:00:22 <cemerick> is there any ghci directive (or something) that makes it so that I have access to a given module's unexported symbols?
11:02:39 <bash0r> cemerick: AFAIK, GHCi ignores exports to some extent when running commands from the REPL. If you take a look at GHC as a library then you can see that you can manipulate it. Though, it's only possible for the current projects source files IIRC.
11:02:40 <cemerick> ah, :l does this, nvm
11:02:59 <bash0r> cemerick: Nevermind. :D
11:03:00 <cemerick> bash0r: yeah, that's my current context
11:19:47 <dmwit> cemerick: :l interprets a file, then makes all its internals available. If you need the internals of multiple modules available at one time, you can :l them each, then use :m * to put them all in scope.
11:20:14 <cemerick> dmwit: thank you re: :m
11:20:51 <cemerick> just found https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html, so I guess I'll rtfm later ;-P
11:35:25 <cheater> is there a good short name for "useful programming methods not rooted in formal logic"?
11:37:21 <metahumor> patterns?
11:37:39 <fragamus> copumpkin
11:37:41 <cheater> if you're thinking of design patterns, then they're rooted in formal logic
11:38:06 <cheater> i'm thinking of practices like code review, code metrics, anything coming from psychology or sociology
11:40:43 <Dynasty> heuristic
11:41:01 <ianp> code review/metrics aren't "programming methods" are they
11:41:20 <ianp> i think i see what you're asking though
11:41:50 <cheater> a heuristic doesn't fit i think
11:43:45 <cheater> further things that should fit under the same umbrella: systems engineering (designing for failure), deliberate practice, anthropologic studies of behaviors of programmers
11:44:50 <acowley> Is there a way to explicitly write the type parameters of a class definition with forall?
11:45:52 <barrucadu> cheater: I think that sort of thing is what the "engineering" in "software engineering" is trying to convey.
11:46:02 <cheater> i'm not sure
11:46:13 <cheater> is "deliberate practice" part of engineering?
11:46:20 <cheater> you can deliberately practice juggling
11:47:20 <amalloy> acowley: are you looking for the InstanceSigs extension?
11:48:05 <acowley> amalloy: Not exactly. With visible type application on a class method, I wan to have a very visible ordering of class parameters as well as type variables in the method signature.
11:48:07 <amalloy> your question is sorta vaguely worded and i'm not sure that's what you mean
11:48:19 <amalloy> what is an example of something you wish you could write?
11:48:47 <acowley> Suppose you have this: class Foo a b where foo :: Int
11:49:01 <acowley> Now you want to use visible type application to chose the right instance at a call sight of `foo`
11:49:10 <acowley> You'd say, `foo @Bool @Int`, for example
11:50:07 <acowley> The ordering of those parameters is unfortunately up to the implicit ordering GHC determines from the class definition. It's written down in the manual how this ordering is determined, but I'd be happier if I could write it down as I do with ScopedTypeVariables for other situations where I intend to use visible type applications.
11:50:33 <acowley> But the syntax `class forall b a. Foo a b`, for example, is invalid
11:50:59 <jle`> maybe you can forall the methods?
11:51:07 <jle`> or does that interfere with scoped type variables
11:51:14 <acowley> jle`: It interferes
11:51:21 <acowley> You can forall the methods for variables they introduce
11:51:47 <acowley> But that inconsistency is mildly unfortunate
11:54:12 <acowley> I really like the idea of visible type applications over using Proxy values since it seems more explicit about expected phases, but the surface language support isn't 100% there yet.
11:55:08 <implementation> I'm a little confused about ghci and Show instances ... if I type [] in ghci, it prints []. But if I ":t []" I get "[] :: [t]", so exactly can ghci print [] if there is no Show constraint for t?
11:55:39 <metahumor> does it just default to [()]?
11:55:54 <jle`> it does default to [()]
11:55:57 <geekosaur> it's ExtendedDefaultRules, yes
11:56:14 <jle`> it's a cute trick
11:56:38 <geekosaur> defaulting adds () as a final default, so it can resolve [] as type [()] in the absence of other type information
11:57:13 <implementation> ok, thanks
11:57:31 <geekosaur> (but this can also get you surprises: if you do that with, say, QuickCheck, you may find that you tested a list of [()] when you wanted something with more values)
11:59:47 <geekosaur> also one that comes up in here from time to time: (show . read) only accepts "()" as input, for the same reason
12:00:24 <SecretNINJA> :t show . read
12:00:25 <lambdabot> String -> String
12:00:49 <SecretNINJA> > show . read $ ":D"
12:00:51 <lambdabot>  "*Exception: Prelude.read: no parse
12:00:54 <SecretNINJA> > show . read $ "()"
12:00:54 <geekosaur> you haven't specified the type in between, so it uses defualting and gets ()
12:00:55 <lambdabot>  "()"
12:01:50 <metahumor> > show . read $ "0"
12:01:52 <lambdabot>  "*Exception: Prelude.read: no parse
12:02:30 <geekosaur> ...but every haskell reference out there will tell you it wants Integer in the middle, because that's what *normal* defaulting gets you
12:03:00 <geekosaur> and what you will get in a compiled program
12:03:09 <ongy> where did quchen disapear to? o.0
12:08:18 <jle`> > show . (*1) . read $ "0"
12:08:20 <lambdabot>  "0"
12:08:41 <mark721> hi guys, how would i define a method using a map and a lambda, that replaces all elements in a list with the number 1 i.e mymap [1,2,3] gives [1,1,1]
12:08:49 <mark721> btw this is not hw what im actually doing is
12:08:54 <jle`> mark721: what part are you having trouble with?
12:08:54 <metahumor> :t const
12:08:56 <lambdabot> a -> b -> a
12:09:16 <jle`> just trying to figure out the best way to help; do you know what map does? how lambdas work?
12:09:32 <mark721> so i understand how map works
12:09:43 <mark721> i say i understand "how to use a lambda" but not properly
12:09:54 <jle`> so you want to map a function over every item in [1,2,3]
12:09:56 <jle`> to get [1,1,1]
12:10:00 <mark721> yes
12:10:00 <jle`> what should this function return?
12:10:11 <jle`> to get [1,1,1] ?
12:10:14 <mark721> [Int]
12:10:18 <jle`> i mean, what value
12:10:22 <jle`> the mapping function
12:10:36 <jle`> you can try the general template of mapping with a lamboda
12:10:38 <mark721> i think Int right
12:10:44 <jle`> map (\x -> ????) [1,2,3]
12:10:50 <jle`> Int is a type, i'm asking what value you watn to return
12:10:58 <jle`> what should go in the ???? ?
12:11:05 <jle`> > map (\x -> x * 2) [1,2,3]
12:11:06 <lambdabot>  [2,4,6]
12:11:09 <jle`> that doubles every item
12:11:17 <jle`> but what should go in the blank in (\x -> ????) to set every item to 1 ?
12:11:18 <mark721> that's what's confusing me
12:11:20 <mark721> idk
12:11:20 <mark721> lol
12:11:29 <jle`> well, what do you want the result of that function to be?
12:11:37 <jle`> what do you watn to "put" in each slot in the list?
12:11:45 <mark721> an Int
12:11:50 <jle`> yes, but which one?
12:11:52 <jle`> there are a lot of ints
12:11:53 <mark721> 1
12:11:57 <jle`> sounds good
12:12:00 <jle`> there's youre answer
12:12:02 <jle`> *your
12:12:18 <mark721> < map (\x -> 1) [1,2,3]
12:12:21 <mark721> < map (\x -> 1) [1,2,3]
12:12:24 <mark721> > map (\x -> 1) [1,2,3]
12:12:26 <lambdabot>  [1,1,1]
12:12:30 <mark721> :)
12:12:39 <jle`> you might have been overthinking it :)
12:12:43 <mark721> i'm not sure tbh
12:12:52 <mark721> i have never seen lambda been used as \x -> 1
12:13:03 <mark721> so like the one lambda expression i always remember is
12:13:10 <mark721> so if we did add x y = x + y
12:13:12 <jle`> well, lambda expressions can really return anything
12:13:20 <mark721> then you can do add x = \y -> x+y
12:13:21 <jle`> `\x -> ???`, anything can go in the ??? (any expression)
12:13:31 <jle`> > (\x -> "hello") True
12:13:33 <lambdabot>  "hello"
12:13:37 <jle`> it's up to you to pick what goes there
12:13:47 <mark721> then add = \x -> y -> x + y
12:13:54 <mark721> yeah i'd say i don't fully "grasp"
12:13:56 <mark721> lambdas...
12:14:25 <jle`> (\x -> body) is a function that takes a value, and returns 'body'
12:14:42 <mark721> jle`, lol i now realise it maybe been easier to ask my original question
12:14:43 <jle`> in 'body' , you are able to use 'x' to refer to the input to the function
12:14:43 <mark721> so basically
12:15:03 <jle`> for example, (\x -> "hello") is a function that takes a value and returns "hello"
12:15:23 <jle`> kind of like 'foo x = "hello"`, except it's an anonymous function that you don't explicitly give a name
12:15:46 <mark721> length = foldr (\) n -> 1+n) 0
12:15:51 <mark721> im struggling to understand that...
12:16:01 <jle`> hm, i don't think that is valid haskell
12:16:05 <mark721> so basically thats how to do define the length function using foldr.
12:16:15 <mark721> wait typo
12:16:31 <mark721> length = foldr (\_ n -> 1+n) 0
12:16:47 <jle`> do you know the definition of foldr ?
12:16:51 <jle`> (for lists, at least)
12:16:58 <mark721> yeah
12:17:00 <mark721> i get that
12:17:05 <jle`> so, just expand it out
12:17:09 <mark721> e.g u can do sum by doing foldr (+) 0
12:17:10 <jle`> that's how evaluation in haskell works
12:17:21 <jle`> i mean, the actual haskell definition
12:17:23 <jle`> @src foldr
12:17:23 <lambdabot> foldr f z []     = z
12:17:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:17:38 <mark721> tbh that made me very confused lol
12:17:47 <hololeap> :t foldr
12:17:48 <jle`> do you understand how pattern matching works, for lists?
12:17:48 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:17:56 <mark721> jle`, yes :) i get pattern matching
12:17:59 <jle`> mark721: that is, a list like [1,2,3] is just 1:2:3:[]
12:18:08 <jle`> so, what is foldr (\_ n -> 1 + n) 0 [1,2,3]   ?
12:18:19 <jle`> that's just `foldr (\_ n -> 1 + n) 0 (1:2:3:[])`
12:18:28 <jle`> so, which pattern does that match?
12:18:34 <hololeap> it's ignoring 'a' (hence the underscore), and it's just passing the accumulator in and adding one. 'a' is the next item in the list and it's getting ignored
12:18:40 <jle`> does that match the `foldr f z []` pattern, or the `foldr f z (x:xs)` pattern ?
12:18:48 <mark721> the latter
12:18:51 <jle`> alright
12:19:01 <jle`> if it does, what are 'f', 'z', 'x', and 'xs' ?
12:19:17 <jle`> what do those variables match with?
12:19:26 <mark721> so f is (\_ n -> 1 + n)
12:19:37 <mark721> z is 0
12:19:54 <mark721> x is the head aka 1 and xs is the tail so [2,3]
12:19:59 <jle`> mhm
12:20:10 <jle`> and the definition of foldr says that foldr f z (x:xs) = f x (foldr f z xs)
12:20:15 <jle`> so, plug those into f x (foldr f z xs)
12:20:31 <jle`> and what do you get?
12:21:25 <mark721> so we get (\_ n -> 1 + n ) 1 (foldr (\_ n -> 1 + n ) 0 [2,3])
12:21:39 <jle`> exactly
12:21:50 <jle`> i guess now is the part where you have to understand how lambdas work
12:22:05 <jle`> (\_ n -> 1 + n) is a function that takes two arguments, names the second one 'n', and returns 1 + n
12:22:24 <jle`> so in this case, n is (foldr (\_ n -> 1 + n) 0 [2,3]), so that whole thing evaluates to:
12:22:32 <mark721> wait slowly pls
12:22:39 <mark721> coz lambdas is my weakspot.
12:22:47 <jle`> here are some example results
12:22:49 <mark721> * give me a sec to re-read :P
12:22:51 <hololeap> just read it slowly :p
12:22:55 <jle`> > (\_ n -> 1 + n) "hello" 10
12:22:57 <lambdabot>  11
12:23:04 <jle`> > (\_ n -> 1 + n) False 8
12:23:06 <lambdabot>  9
12:23:51 <jle`> (\_ n -> 1 + n) 1 (foldr .. 0 [2,3])  ==   ...?
12:24:13 <jle`> > (\_ n -> 1 + n) 'c' x      -- hint
12:24:15 <lambdabot>  1 + x
12:25:07 <mark721> (thinking... give me a sec lol)
12:25:43 <hololeap> a lambda is a just a function without a name. you could rewrite it as: plusOneIgnoreFirst x n = n + 1
12:26:18 <mark721> jle`, (\_ n -> 1 + n ) 'anything can go here' theValueOfN
12:27:05 <hololeap> or: plusOneIgnoreFirst _ n = n + 1
12:27:16 <jle`> yeah, so, use that knowledge to evaluate (\_ n -> 1 + n) 1 (foldr .. 0 [2,3])
12:27:23 <hololeap> the underscore just lets you know that the argument isn't used
12:27:30 <jle`> or at least take it one step further
12:27:54 <mark721> (\_ n -> 1 + n) 1 (foldr .. 0 [2,3]) === (\_ n -> 1 + (foldr .. 0 [2,3]))
12:28:48 <jle`> not quite
12:28:48 <hololeap> (i think the underscore throws a lot of people off, like it's something specific to lambdas)
12:28:56 <jle`> but close
12:29:07 <jle`> (\_ n -> 1 + n) 4 5 turns into 1 + 5
12:29:16 <jle`> not (\_ n > 1 + 5)
12:29:24 <mark721> OH
12:29:24 <jle`> * (\_ n -> 1 + 5)
12:29:30 <jle`> do you see the difference ?
12:29:33 <mark721> yeah
12:29:36 <mark721> but in my head
12:29:38 <mark721> they are the same
12:29:41 <mark721> hence why i said it...
12:29:43 <mark721> lol
12:29:54 <mark721> but i get u.
12:29:56 <jle`> is `1 + 5` the same as (\_ n -> 1 + 5) ?
12:29:59 <mark721> its what i meant in terms of evaluation.
12:30:05 <jle`> one evaluates to 6
12:30:08 <jle`> and is 6
12:30:15 <jle`> the other is a function that takes two inputs and returns 6
12:30:23 <mark721> OH
12:30:26 <mark721> ok now i get u :)
12:30:50 <jle`> so now we see that that whole thing evaluates to `1 + foldr (\_ n -> n + 1) 0 [2,3]`
12:31:08 <jle`> now, what do you think `foldr (\_ n -> n + 1) 0 [2,3]` evaluates tp?
12:31:19 <jle`> if you find that out, the total answer is just 1 + whatever that is
12:31:46 <mark721> so for that, its [2,3] + 1?
12:31:50 <mark721> which doesn't make sense?
12:31:59 <jle`> no, it's 1  + foldr (\_ n -> n + 1) 0 [2,3]`
12:32:06 <jle`> so, let's go back to the definition of foldr
12:32:10 <jle`> @src foldr
12:32:10 <lambdabot> foldr f z []     = z
12:32:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:32:19 <jle`> foldr (\_ n -> n + 1) 0 (2:3:[])
12:32:24 <jle`> which pattern does that match with
12:32:31 <mark721> latter
12:32:33 <jle`> the first one, foldr f z [], or the second one, foldr f z (x:xs) ?
12:32:38 <jle`> yes, and so what are f, z, x, and xs ?
12:33:15 <mark721> f = (\_ n -> n + 1), z = 0, x=2, xs = [3]
12:33:19 <jle`>  mhm
12:33:26 <jle`> and so that evaluates to f x (foldr f z xs)
12:33:47 <jle`> which is (\_ n -> n + 1) 2 (foldr .. 0 [3])
12:33:52 <jle`> which is ...?
12:34:07 <mark721> > :t foldr
12:34:08 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:34:25 <mark721> > :type foldr
12:34:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:34:48 <mark721> jle`,  one sec,
12:35:02 <jle`> hint -- you solved a very similar thing just a moment ago
12:35:10 <mark721> ik (im slow im sry)
12:35:18 <jle`> you found out what (\_ n -> n + 1) 1 (foldr ... 0 [2,3]) was
12:35:31 <jle`> now, we ask what (\_ n -> n + 1) 2 (foldr ... 0 [3]) is
12:36:36 <mark721> we didnt find out what (\_ n -> n + 1) 1 (foldr ... 0 [2,3]) is.
12:36:44 <jle`> yea we did, it was 1 + foldr ... 0 [2,3]
12:36:45 <mark721> i said the wrong answer then u gave me an example?
12:37:02 <mark721> ok one sec..
12:38:09 <mark721> acc this may take longer i need to re-read i feel you lost me (let me re-read..)
12:47:42 <mark721> (\_ n -> n + 1) 2 (foldr .. 0 [3]) goes to 1 + (foldr .. 0 [3])
12:47:49 <mark721> but building on what we had before
12:48:10 <mark721> 1 + foldr ... 0 [2,3] + 1 + foldr ... 0 [3]
12:48:52 <mark721> so we then go on to the next
12:49:32 <mark721> (\_ n -> n + 1) 1 (foldr (\_ n -> n + 1) 0 [])
12:50:08 <jle`> foldr .. 0 (1:2:3:[])
12:50:16 <jle`> = 1 + foldr .. 0 (2:3:[])
12:50:27 <jle`> = 1 + (1 + foldr .. 0 (3:[]))
12:50:46 <jle`> = 1 + (1 + (1 + foldr ... 0 []))
12:50:52 <jle`> at that point is where things start beocmcing different
12:51:11 <jle`> and you have to match on a different pattern for foldr :)
12:52:00 <jle`> tbh foldr is not the fold i'd use for length, it's a bit more complex in the end than foldl
12:52:06 <mark721> 1 + (1 + (1 + foldr ... 0 [])) gives 1 + (1 + (1 + foldr ... 0 0))
12:52:29 <jle`> foldr .. 0 [] is not foldr .. 0 0
12:52:33 <jle`> check the definition :)
12:52:35 <jle`> @src foldr
12:52:35 <lambdabot> foldr f z []     = z
12:52:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:53:08 <mark721> i thought z is 0?
12:53:42 <jle`> ýe
12:53:44 <jle`> *yes
12:53:46 <mark721> OOOOOOOOOOOOOOOOOOOOOOOOOOOOO
12:53:49 <jle`> but 0 is different than foldr .. 0 0
12:54:03 <mark721>  1 + (1 + (1 + foldr ... 0 []) gives  1 + (1 + (1 + 0)
12:54:06 <jle`> mhm
12:54:23 <jle`> honestly yeah, length is a bit of an awkward function to use with foldr
12:54:32 <jle`> length unfolds itself much more naturally with foldl
12:54:41 <jle`> but if you can tackle this in foldr, you can tackle anything
12:54:48 <mark721> i nearly died LOL
12:54:54 <mark721> and that was while u were assisting me
12:55:04 <fraser> Hey! I've just started contributing to an open source project and am adding a phantom variable to a type. They are defining an instance for FromField on that type and using returnError within it. ReturnError needs to have the result be typeable. But it seems to be struggling to have that happen. I'm getting "No instance for (Typeable a) arising from a use of ‘returnError’"
12:55:07 <ski> > foldr (\_ n -> 1 + n) 0 [1,2,3]  :: Expr
12:55:09 <lambdabot>  1 + (1 + (1 + 0))
12:55:39 <jle`> fraser: hard to say without eeing code
12:55:50 <jle`> eeing, and also seeing
12:56:22 <dmwit> fraser: Perhaps you can just add `Typeable a` to the instance context and be done.
12:56:26 <fraser> Here's the file. https://github.com/adjoint-io/uplink/blob/master/src/Address.hs
12:56:55 <mark721> ?src foldr
12:56:55 <lambdabot> foldr f z []     = z
12:56:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:57:19 <fraser> I'm trying to add a phantom type to Address and it fails on line 265
12:57:24 <dmwit> fraser: If you want help with an error, you have to show the code that causes the error...
12:57:50 <dmwit> fraser: Anyway my blind guess stands.
12:57:53 <fraser> Fair enough. Give me a sec.
12:58:42 <fraser> So do you mean just doing this? instance Typeable a => FromField (Address a) where
12:58:50 <dmwit> yes
12:58:54 <implementation> ski: wait what? where's that Expr type from?
12:59:13 <dmwit> ?hackage simple-reflect -- implementation, from here
12:59:13 <lambdabot> http://hackage.haskell.org/package/simple-reflect -- implementation, from here
12:59:25 <implementation> thanks O_O
12:59:47 <dmwit> It's simultaneously cooler than you might think and more disappointing than you might think.
13:00:08 <jle`> that's a good way to put it :)
13:00:12 <fraser> I then get "Could not deduce (Typeable k) arising from a use of ‘returnError’". Let me get the code up so it can be viewed easily.
13:00:16 <dmwit> You might kind of wish it stored an actual AST describing the computation done. But it doesn't. It's barely more than a glorified String.
13:00:56 <jle`> instance Num String where xs + ys = xs ++ " + " ys
13:03:06 <mark721> jle`, thank you i saved the chat for future reference :)
13:03:18 <mark721> byeee
13:03:29 <jle`> no problem!
13:03:57 <fraser> Okay I pushed my code here. https://github.com/frasermince/uplink/blob/address-phantom-types/src/Address.hs
13:06:30 <ski>  /wg 21
13:06:40 <jle`> remind me again what the type of returnError is ?
13:07:29 <fraser> https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple-FromField.html#v:returnError
13:08:22 <Tuplanolla> Are you trying to switch buffers or tell us about C++, ski?
13:08:39 <CritJongUn> good night people
13:08:46 <qeyoa> Is foldr an often used function? I struggle to imagine paths to solutions using it.
13:08:47 <ski> hm, the former, i believe
13:08:53 <CritJongUn> can someone explain me the relation between functors and monads?
13:09:03 <ski> `foldr' is not that uncommon to use
13:09:11 <jle`> fraser: does Address have a typeable instance?
13:09:18 <ski> CritJongUn : all monads are functors
13:09:20 <jle`> fraser: foldr is pretty common
13:09:25 <qeyoa> ok
13:09:36 <jle`> CritJongUn: a monad is a functor with some extra operations defined on it
13:09:40 <CritJongUn> ski: so monads can be seen as a subset of a functor?
13:09:41 <qeyoa> then i will have to try harder :)
13:09:54 <CritJongUn> ah so the reverse
13:09:56 <CritJongUn> (?)
13:09:58 <fraser> They are not deriving it. But the code compiled before this change. I'm not sure how. I've tried deriving it now and it doesn't fix it.
13:10:04 <ski> CritJongUn : s/a functor/functors/ -- then yes
13:10:11 <ski> not the reverse
13:10:30 <jle`> CritJongUn: yes, the title of monad is more "restrictive" than functors
13:10:54 <implementation> dmwit: okay this is really disappointing :D https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Vars.html
13:11:08 <ski> CritJongUn : it's similar to saying that all prime numbers are integers, but not all integers are prime numbers
13:11:11 <jle`> saying something is a monad assumes more about its structure/features
13:11:14 <CritJongUn> jle`: im currently implementing the liftM2, do i need fmap to do it?
13:11:16 <dmwit> implementation: can't say I didn't warn you =)
13:11:29 <jle`> CritJongUn: oh, so do you mean Monad and Functor
13:11:34 <jle`> as in, the typeclasses?
13:11:42 <CritJongUn> also
13:11:44 <CritJongUn> yeah
13:11:51 <jle`> CritJongUn: you don't necessarily need it if you have bind and return
13:11:58 <CritJongUn> i know the monad has those two
13:12:05 <jle`> the commonly given implementation does not involve fmap
13:12:06 <jle`> but it could
13:12:10 <ski> you mean you know `Monad' has those two
13:12:27 <CritJongUn> ah ok
13:12:34 <ski> `Monad' is a particular incarnation of the monad concept, in Haskell
13:12:47 <ski> (a relatively restricted version of it, fwiw)
13:13:05 <jle`> i like to compare it to Set and sets
13:13:05 <ski> (and ditto for `Functor' and the functor concept)
13:13:29 <jle`> like the mathematical idea of a set is pretty general
13:13:42 <jle`> but haskell Set data type is one restricted realization that is practical as a real-world data structure
13:13:44 <CritJongUn> you're making the distinction of the implementation and the concept
13:13:45 <CritJongUn> right?
13:14:01 <jle`> the concept of the implementation vs. the concept that inspired it
13:14:17 <ski> (the mathematical conception of set also typically mixes up different aspects, imho)
13:14:34 <mniip> hmm
13:14:46 <mniip> is exference in presence of RankN undecidable?
13:15:23 <ski> we sometimes say that instances of `Functor' are functors from the category `Hask' to the category `Hask'. in general, functors (even in Haskell), doesn't need to go between these two categories
13:15:45 <dmwit> mniip: It would kind of surprise me if it were decidable. Proof search is... hard.
13:15:59 <mniip> is there at least some hope
13:16:22 <Tuplanolla> Why would anything nice ever happen?
13:16:37 <dmwit> mniip: But then maybe when you say "exference" you mean something more specific than proof search...?
13:16:37 <fraser> Any idea what's going on?
13:16:44 <ski> i suppose you're asking whether "second order propositional logic" is decidable
13:16:58 <jle`> fraser: it compiles before this change?  same version of all libs/ghc ?
13:17:10 <jle`> fraser: can you check in ghci if Address has a typeable instance?
13:17:13 <mniip> hmm
13:17:17 <fraser> jle`: Yeah it compiles beforehand
13:17:49 <fraser> jle`: Let me check.
13:18:11 <jle`> it might be standalone derive'd
13:18:47 <ski> (one doesn't need to know what a category is, to be able to grasp that there is more variety (even in Haskell) to functors, than what is captured by the type class `Functor')
13:19:03 <ski> (and ditto for `Monad' and monads)
13:19:29 <fraser> jle`: I did a :i on Address and typeable isn't listed there.
13:20:23 <mniip> hmm
13:20:54 <mniip> once again, why do we use  s -> m (a, s) instead of m (s -> (a, s))
13:21:24 <jle`> s -> m (a, s) represents an effectful state transformer
13:21:28 <mniip> the latter could be an applicative functor functor
13:21:31 <EvanR> fraser: did you import Data.Typeable
13:21:40 <jle`> m (s -> (a, s)) is...an effectful way of generating a pure state transformer
13:21:45 <dmwit> mniip: You can get the latter via Compose m (State s)
13:21:47 <jle`> the latter is the Compose instance
13:21:48 <ski> because we want the action to perform to possibly depend on the current state ?
13:21:50 <mniip> hmm
13:21:51 <mniip> indeed
13:22:13 <fraser> EvanR: I didn't but before my addition of a phantom type the code worked just fine without the import
13:22:19 <dmwit> And yes, the reason the former is better is what ski said.
13:22:55 * ski sequences actions, dynamically
13:23:20 <EvanR> fraser: seems to me Typeable is derived automatically for everything, and not listed in :i for anything
13:24:00 <fraser> EvanR: So perhaps for some reason in the case of a phantom type it's not derived?
13:24:23 <ski> (not even `:i Typeable' lists any instances)
13:26:18 <mniip> hmm
13:26:19 <EvanR> fraser: there used to be some limitations for typeable for polymorphic types, not sure
13:26:23 <EvanR> what the latest on that is
13:26:35 <mniip> hmm
13:26:42 <mniip> if  newtype S s m a = S { runS :: forall r. s -> (s -> a -> r) -> m r }
13:26:50 <mniip> and  	S fh <*> S xh = S $ \s g -> join $ fh s $ \s f -> xh s $ \s x -> g s (f x)
13:26:59 <mniip> can that be rewritten in terms of >>= instead of join
13:27:10 <mniip> (in a non-synthetic way)
13:27:18 <EvanR> > typeOf "fruit"
13:27:20 <lambdabot>  [Char]
13:27:23 <EvanR> > typeOf []
13:27:25 <lambdabot>  error:
13:27:25 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
13:27:25 <lambdabot>      • In the expression: typeOf []
13:27:40 <dmwit> :t \fh s g -> join (fh s g)
13:27:41 <lambdabot> Monad m => (t1 -> t2 -> m (m a)) -> t1 -> t2 -> m a
13:29:52 <dmwit> fraser: Could not reproduce. `stack build` exits with code 0 for me, and produces an executable named `uplink`.
13:30:41 <fraser> Try `stack image pull` first
13:30:53 <dmwit> fraser: Uh. Never mind. I thought cloning your repo would get me your changes, but it didn't because I wasn't paying close enough attention. =P
13:31:12 <fraser> Oh yeah. I'm on a branch haha.
13:32:44 <ski> @type \(S fh) (S xh) -> S (\s g -> fh s (,) >>= \(s,f) -> xh s (,) >>= \(s,x) -> return (g s (f x)))  -- mniip, is this ok ?
13:32:46 <lambdabot> Monad m => S s m (a1 -> a2) -> S s m a1 -> S s m a2
13:35:12 <dmwit> Yep, I can reproduce it once I get the right branch.
13:35:50 <fraser> Well there's a start!
13:36:02 <mniip> hmm
13:36:12 <mniip> avoiding (,) is what was the idea in first place
13:36:41 <ski> @unmtl StateT s (ContT o m) a
13:36:42 <lambdabot> s -> (a -> s -> m o) -> m o
13:36:49 <ski> ok
13:37:21 <ski> i suppose you've already considered `ContT'
13:37:46 <ski> (or `Codensity', rather)
13:45:46 <dmwit> fraser: Got it.
13:45:54 <dmwit> fraser: `newtype Address (a :: *) = ...`.
13:46:22 <fraser> Really! I wonder why that fixes it?
13:46:37 <dmwit> You've got PolyKinds turned on.
13:47:19 <fraser> Gotcha. I don't even really know what that is yet. I'm mostly at intermediate level with this kind of stuff but there's a bunch of extensions I don't know about yet.
13:47:21 <dmwit> ...I don't know what the next sentence of the explanation is.
13:47:42 <Bowlslaw> Hello, everyone. I started learning Haskell yesterday and I'd like to get a simple IRC bot up and running, and so I found this (https://wiki.haskell.org/Roll_your_own_IRC_bot). I made a nick for my bot but when I try to connect via command line in ubuntu it says "<chosen nick> :Nickname is already in use. :You have not registered.
13:47:54 <Bowlslaw> what is the code to have my bot register the nick?
13:47:59 <Bowlslaw> i created it using Pidgin
13:48:09 <Bowlslaw> and if I don't have a chosen name, it says I must connect through SASL
13:48:27 <fraser> Thank you so much everyone!
14:03:25 <qeyoa> I'm trying to implement a `filter` function with `foldr`. So far no luck, but i am trying to figure out the scope of what i can and cannot do. Am i supposed to use helper function, or am i supposed to do this with only the default `map` declaration arguments?
14:05:30 <Tuplanolla> Can you implement `id` with `foldr`, qeyoa?
14:05:34 <int-e> qeyoa: I'd say you can have helper functions, as long as they aren't recursive.
14:06:08 <Tuplanolla> That would be a good starting point.
14:06:18 <qeyoa> ok
14:06:27 <qeyoa> the definition of id
14:06:32 <qeyoa> is what exactly ?
14:06:38 <Cale> id x = x
14:06:43 <qeyoa> ok, thanks
14:06:48 <qeyoa> will try this
14:07:02 <c_wraith> but remember that you're doing the list-specific version of it.
14:07:41 <c_wraith> it might help to think of it as id [] =[] ; id (x:xs) = x:xs
14:09:43 <c_wraith> or even changing that last one to id (x:xs) = x : id xs
14:10:00 <c_wraith> which gives you the closest analogue to how foldr works
14:17:13 <qeyoa> http://lpaste.net/362538
14:17:25 <qeyoa> should the id list version look like this
14:17:26 <qeyoa> ?
14:17:47 <Tuplanolla> Yes. Now you can modify it a bit to add filtering.
14:18:45 <Tuplanolla> (The message at the end of the page is just telling you `foldr (:) []` is shorter.)
14:23:51 <qeyoa> should i start thinking from the start to the right or from the base case of empty list to the left
14:23:52 <qeyoa> ?
14:24:57 <qeyoa> although i guess i'm asking too many questions here, there should be a way for me to figure this out without any more hints
14:27:26 <EvanR> come at it from multiple angles
14:28:15 <Bowlslaw> do you guys know why it says "You need to idtendify via SASL to use this server" when I use the code from https://wiki.haskell.org/Roll_your_own_IRC_bot ?
14:29:14 <mark721> jle`, u still here?
14:29:51 <mark721> guys I need some guidance pls
14:29:57 <mark721> 5. Redefine map f and filter p using foldr
14:30:14 <mark721> and so i was trying to do for `map f`
14:30:29 <mark721> so we know the definition of foldr is
14:30:33 <mark721> ?src foldr
14:30:33 <lambdabot> foldr f z []     = z
14:30:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:30:34 <parsnip> mark721: i might consider redefining them with recursion first, as a warmup.
14:30:47 <mark721> parsnip, ooo good tip brb then :P
14:30:52 <parsnip> :)
14:31:21 <parsnip> then it becomes practice rewriting recursive functions to foldr.
14:31:54 <parsnip> it's a habit i forget sometimes. i'll try to get something working sometimes first with recursion, then i try to remember to look for the write abstraction to clean it up, whether it's fold, or otherwise.
14:32:24 <mark721> map f [] = []; map f (x:xs) = f x : map xs
14:32:29 <mark721> hows that?
14:32:46 <mark721> wait i should've just tested it lol one sec.
14:32:50 <parsnip> :)
14:33:03 <parsnip> another skill is to write a proof.
14:33:30 <parsnip> i forget what properties we want map to have. i think respect order is one of them.
14:33:42 <parsnip> like, map id = id
14:33:50 <parsnip> of map id xs = xs
14:33:52 <parsnip> *or
14:34:01 <mark721> mapy f [] = []; #mapy f (x:xs) = f x : mapy f xs
14:34:05 <mark721> ignore the hash.
14:34:17 <parsnip> map' might be more conventional than mapy
14:34:32 <mark721> soz first thing that popped to mind :P
14:36:05 <qeyoa> ok, this is my attempt at implementing `filter` with `foldr`, it seems to work with a few cases i tried, but looks very clumsy:
14:36:07 <qeyoa> http://lpaste.net/362539
14:36:34 <qeyoa> is this very far off from what needs to be done
14:36:35 <qeyoa> ?
14:36:47 <mark721> lol tbh i wanted to focus on map first...
14:37:13 <parsnip> same class?
14:37:15 <mark721> but assuming u tested it and it works it seems fine.
14:37:29 <mark721> parsnip, me or qeyoa ?
14:37:40 <parsnip> o.O
14:37:46 <qeyoa> what is going on here
14:37:47 <qeyoa> :D
14:37:57 <qeyoa> are we doing the same exercises mark721?
14:38:08 <mark721> LOL confused ...
14:38:12 <mark721> it seems so
14:38:48 <koala_man> qeyoa: []++xs == xs, of course
14:39:24 <qeyoa> a, ok
14:39:34 <qeyoa> so anything else
14:39:43 <qeyoa> wrong in there?
14:40:06 <mark721> qeyoa. odd question what country u in?
14:40:45 <qeyoa> mark we may be doing the same exercise, but we are not from the same country if your name is mark
14:40:46 <qeyoa> :D
14:41:00 <mark721> LOL
14:41:28 <mark721> no it just seems really odd we just had a class on this today so i was just wondering :P
14:42:15 <qeyoa> i'm too old for those
14:42:27 <mark721> never too old :P
14:43:05 <mark721> parsnip, where were we
14:44:45 <parsnip> not in the same country?
14:45:14 <mark721> i mean according to qeyoa.
14:45:17 <mark721> not same country.
14:45:37 <mark721> so what's my next step
14:46:06 <mark721> f [] = v; f (x:xs) = x someBINARYOPERATOR f xs
14:46:28 <mark721> so thats the structure for converting something from recursive to foldr
14:51:04 <mark721> map' f [] = []; map' f xs = foldr f [] xs
14:51:10 <mark721> i thought that but its not working :?
14:51:32 <qeyoa> ok, thanks everyone for all the help as usual, good night (don't stay up too late mark721 :) )
14:51:48 <mark721> hey how do u know its night :P
14:52:39 <mark721> ok well anyone else got any ideas?
14:53:24 <MarcelineVQ> if it's homework it's your ideas that matter :> keep at it!
14:54:01 <mark721> its not hw
14:54:30 <koala_man> mark721: you can't pass the same function directly because map only converts an object, while foldr would need to also add it to the list
14:55:48 <mark721> koala_man, could you elaborate?
14:55:58 <mark721> or link me to some good documentation or something
14:57:04 <koala_man> mark721: map takes an (a -> b)  while your foldr needs a (a -> [b] -> [b])
14:58:20 <mark721> riiight...
14:59:53 <mark721> acc im not sure i agree or maybe its just that i dont understand
15:00:34 <mark721> ?src map
15:00:34 <lambdabot> map _ []     = []
15:00:34 <lambdabot> map f (x:xs) = f x : map f xs
15:00:41 <mark721> :t map
15:00:41 <lambdabot> (a -> b) -> [a] -> [b]
15:00:56 <mark721> :t foldr
15:00:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:02:25 <mark721> i have no idea.
15:03:27 <koala_man> myMap f = foldr (\currentElement previousList -> ???) []
15:04:00 <mark721> koala_man, where is f being used?
15:04:12 <ski> presumably in `???' ?
15:04:17 <mark721> oh
15:04:35 * ski also doesn't think `previousList' is a good naming choice
15:05:10 <koala_man> nextList?
15:05:13 <ski> > foldr g z [a,b,c,d]
15:05:14 <lambdabot>  g a (g b (g c (g d z)))
15:05:19 <Bowlslaw> so it looks like freendoe requires you to use SASL which is why my roll your own irc bot isn't working...
15:05:42 <ski> can you invent a `g' (possibly involving our `f'), such that that result will turn into `[f a,f b,f c,f d]' ?
15:05:57 <parsnip> Bowlslaw: put znc in between?
15:06:11 <Bowlslaw> What's that? i don't understand
15:06:18 <glguy> Bowlslaw: It doesn't require SASL to connect except via tor
15:06:50 <parsnip> Bowlslaw: it's a bouncer, you could have znc do the SASL authentication, and bot could connect to znc via localhost or something.
15:06:53 <Cale> Bowlslaw: It doesn't require SASL, but certain IRC channels do.
15:07:14 <parsnip> at times, i've had to use SASL when connecting from a VPS
15:07:16 <Cale> (I have SASL turned off in my IRC client right now...)
15:07:18 <glguy> Certain IRC channels require authentication to nickserv before joining, but not sasl
15:07:28 <mark721> ski, um f x : f xs?
15:07:45 <glguy> parsnip: Ah, that could be it
15:07:48 <mark721> ski, um f x : mymap f xs?
15:07:49 <ski> `f xs' doesn't make sense. `xs' is presumably a list, but `f' takes an element
15:07:57 <ski> try it ?
15:08:39 <astralemp> so, I've been reading about the existential type class antipattern, and I'm confused as to why the problem can't just be solved using type overloading. e.g., `Show a => [a]` rather than `[Showable a]`.
15:09:16 <Cale> Oh, sorry, I'm confused, I thought SASL was the TLS-for-IRC thing, rather than the connect-time-identification thing.
15:09:19 <ski> astralemp : that's not at all the same thing
15:10:04 <mniip> how did this happen...
15:10:06 <ski> (i'm assuming that by the first, you mean the type `[a]', where you happen to know that `Show a'. that's not the same as what you said, fwiw)
15:10:10 <astralemp> ski: how come? don't you have access to the typeclass method in both cases?
15:10:24 <mniip> we just made a monad where  local f k = local f (return ()) >> k
15:11:00 <ski> astralemp : the idea with `[Showable]', which conceptually means `[exists a. Show a *> a]', is that you'll be able to mix elements of different type in the list, as long as all of them have types which are instances of `Show'
15:11:03 <mniip> questioning the legality of that
15:11:20 <ski> astralemp : while with `[a]', all the elements in a list of that type must have the *same* type
15:11:33 <astralemp> ski: ahh, I see
15:11:40 <aplainzetakind> is anyone familiar with scalpel?
15:11:45 <ski> astralemp : "don't you have access to the typeclass method in both cases?" -- the difference is in where those come from
15:13:37 <astralemp> ski: the first case is still bound to only one type, so it's going to be the same instance of the typeclass method(s) for each entry in the list, whereas in the second, it can actually be different
15:13:38 <mark721> ski, idk
15:13:56 <astralemp> ski: is that correct?
15:15:57 <ski> astralemp : consider `foo :: Show a => [a] -> IO ()' (btw note that this signature does *not* contain the type `Show a => [a]', which you mentioned. hence me guessing that you didn't really mean that)
15:16:20 <mniip> something is off
15:16:27 <ski> here the caller of `foo' will provide the evidence for `Show a' (for a single `a', for each call to `foo')
15:17:46 <ski> astralemp : now, consider `bar :: [Showable] -> IO ()'. now the caller (or whoever constructs each element of the list) will pack each element with some `Show' instance
15:18:32 <ski> astralemp : finally, consider `baz :: Blah -> [Showable]'. now `baz' will select the `Show' instances to use for the elements produced (unless that is delegated to whoever constructed `Blah')
15:19:22 <ski> (btw, if you consider `quux :: Show a => Blah -> ..a.. -> [a]', then it would still be the caller who provided the instance)
15:22:15 <astralemp> gotcha
15:25:09 <ski> (note that for `Show a => [a]', it's the consumer/caller who has to provide evidence for `Show a', in order to use the list of `a's; but, otoh, for `Show a *> [a]', it's the producer/callee who will (/must) produce evidence for `Show a', together with the produced list of `a's)
15:25:49 <ski> (generally, `forall' will go together with `=>', as in `forall a. Show a => ..a..', while `exists' will go together with `*>', as in `exists a. Show a *> ..a..')
15:25:52 <ski> astralemp ^
15:29:15 <astralemp> why does haskell support `forall' but not `exists'?
15:29:40 <hpc> decidability
15:29:42 <hpc> iirc
15:30:02 <ski> i think it's not that clear how to make a nice system with `exists', that plays along with type classes
15:30:26 <ski> also, encoding existentials via data types is a smaller extension to the language
15:31:26 <astralemp> it would be a more elegant solution to the problem, however. and it seems odd to have one without the other. less rules is generally better, but in this case, it violates symmetry.
15:32:28 <ski> when i try to explain existentials to people, i prefer first explaining the `exists' (and `*>') concept, before going on to explain how that is currently being encoded in Haskell (in two different ways)
15:32:57 <mniip> a forall is just a profunctor end :P
15:33:01 <mniip> what's the problem
15:34:38 <mark721> Could someone explain y works in `map' f (x:xs)  = foldr (\y ys -> (f y):ys) [] xs`
15:34:42 <mark721> *y and ys
15:34:56 <mniip> that doesn't seem correct
15:35:16 <mniip> that drops the first element
15:35:28 * ski . o O ( "This is the END for you, you gutter crawling cur!" )
15:36:19 * ski would probably rename `ys' to `zs'
15:37:14 <mark721> what about y? would that go to z?
15:37:23 <rschmukler> Hey all. I'm currently playing with the streaming package and looking to implement a unique function which returns maintains a state (of a Set a) and yields only the items which have not been seen before.
15:37:40 <ski> nope
15:37:42 <ski> that's the point
15:38:04 <mark721> `map' f (x:xs)  = foldr (\y zs -> (f y):zs) [] xs`
15:38:04 <ski> `y' should not be compared to the elements of `zs'
15:38:19 <rschmukler> Ideally I would be able to run this filterM with the State monad but return a stream which runs its own monadic actions inside the original monad. I'd also like to not make the outer monad aware of the State restriction. Is this possible?
15:38:37 <mark721> ski, eli5 pls
15:39:19 <ski> "eli5" ?
15:39:21 <rschmukler> ie. `uniqueItems :: (Monad m, Eq a, Ord a) -> Stream (Of a) m r -> Stream (Of a) m r `
15:39:28 <rschmukler> @ski "Explain like I'm 5"
15:39:28 <mark721> ski, explain like i'm five :)
15:39:28 <lambdabot> Maybe you meant: wiki src ask
15:40:15 <ski> well, did you consider mniip's advice, yet ?
15:40:22 <mark721> OH
15:40:27 <mark721> i didnt know he was speaking to me
15:40:31 <mark721> it wasn't clear,
15:47:07 <mark721> good night all.
15:51:14 <fragamus> whats the secret to getting stack working on nixos
15:51:53 <astralemp> ski: my question now is in what cases is the existential type the preferred encoding, and in which cases is it better to replace the typeclass with a record type?
15:54:04 <astralemp> I don't like the latter because it's basically reifying the typeclass to a type
15:54:14 <ski> astralemp : from my POV, that's a backwards perspective. the existential type is not the encoding, it's what you (currently) have to encode, i.e. `exists a. C a *> ..a..' (with or without `C a *>' part)
15:55:00 <ski> .. or were you thinking of encoding something else in terms of an existential type (which is then again encoded in one way or another) ? what in that case ?
15:56:36 <ski> consider `exists q. (q,a -> q -> q,q -> Maybe (q,a))'. this can serve as an implementation of a queue, giving queue operations (empty,enqueue,dequeue) over elements of type `a'
15:56:39 <astralemp> I was thinking of the existential type as an encoding of existential quantification
15:57:13 <ski> so, you can now pass several of these around, several distinct implementations of queues, even for the same `a'
15:57:53 <ski> if you instead use `exists q. Queue q a *> ()', then you're tying yourself to a single queue implementation, for a given element type `a'
15:59:27 <mniip> is there an agreement on MonadReader laws?
16:01:37 <ski>   reader f = fmap f ask  -- i think should be uncontroversial
16:02:23 <mniip> what about
16:02:28 <mniip> local f (lift k) = lift (local f k)
16:02:29 <ski>   liftA2 (,) ask ask = fmap (\x -> (x,x)) ask  -- and this
16:03:17 <astralemp> ski I wasn't thinking of anything that complicated. more just, what has to be done to compensate for the lack of existential quantification in the language, and how best to do so.
16:03:25 <ski> hm, that's an interaction between `MonadReader' and `MonadTrans'
16:03:46 <astralemp> ski the queue example is interesting though
16:03:55 <mniip> the MonadReader for PlanT
16:03:57 <mniip> is interesting
16:04:07 <ski> mniip : well, consider `ReaderT String (ReaderT String m)'
16:04:14 <ski> hmm
16:04:29 <ski> i suppose `local' doesn't like this, actually
16:04:53 <mniip> makes me think it's unlawful - but there aren't any laws
16:05:47 <ski> astralemp : well, your question sounded more like type classes vs. record types (however in the context of an existential), than about existentials per se
16:06:31 <ski> mniip : strictly speaking, i'd not expect any law like that, except for a common subclass of these two classes
16:07:09 <ski> perhaps, using parametricity, one could still derive some interaction result. i'm not sure
16:08:09 <mniip> PlanT (Const Void) Void  which should work a bit like MaybeT
16:08:23 <mniip> but if applied to (Reader e)
16:08:34 <mniip> it has the curious property that 'local' acts like 'modify'
16:08:42 <mniip> and the whole thing acts like State
16:11:02 <astralemp> ski: yeah, that's what I meant. and admittedly, the only situation I was thinking about was where you use existentials to create a heterogenous structure of elements. so basically, in what cases it's better to use type classes vs record types for that.
16:12:22 <ski> astralemp : type classes tie you to a single implementation per type
16:14:17 <astralemp> *nods*
16:19:33 <astralemp> typeclasses are more composable in that you can constrain the existential type to multiple classes. there isn't really anything equivalent with records, although row polymorphism would certainly help.
16:23:07 <ski> you *could* just stuff multiple records in there ..
16:24:18 <astralemp> true
16:26:00 <astralemp> I'm biased towards typeclasses because the whole idea of putting functions in records bothers me, it feels like a reification of typeclasses. maybe not in all cases but definitely in this one.
16:26:31 <mud> astralemp: I think of it as essentially OO in the C-family style
16:26:42 <mud> Which is fine sometimes
16:27:16 <ski> btw, the queue example i mentioned was not of an OO vein, but rather an ADT (Abstract Data Type) vein
16:27:37 <ski> (it's also possible to use existentials in an OO vein. but that has a different feel)
16:28:42 <ski> (the basic difference is that with the OO approach, you include the current "object state" inside the existential, and every time you return a new object, constructed from an old, you rewrap the methods around the new state)
16:29:37 <ski> (while in the ADT approach, you don't include the "object state" inside the existential. instead you open the existential *once*, at the beginning (like importing a module with an ADT), then pass around your object states, unadorned)
16:30:43 <ski> (and, a practical difference is that in the ADT approach you can have a "merge"-like operation, that can peek inside both "objects", knowing they're represented the same way (or sorted using the same order, &c.). while in the OO approach, that doesn't work)
16:34:50 <davean> astralemp: It has a further weakness - there isn't uniqueness. So you get weird effects transitioning between datastructures and such as your sense of order changes
16:36:37 <ski> davean : iiuc what you mean, you can handle that with the ADT usage mode of existentials
16:41:20 <davean> ski: I was talking about the "data type of functions" approach to faking your own type classes
16:43:30 <ski> davean : yeah, but what in particular dod you mean by "weird effects transitioning between datastructures and such as your sense of order changes" ?
16:44:46 <davean> ski: I mean you don't have enforced consistency
16:45:01 <ski> example ?
16:50:54 <buhr> davean: I lost the thread, too.  Are you referring to the fact that, for example, "Ord" provides a single unique concept of "ordering" for all types with Ord instances, in a way that a bunch of "data Ord = Ord { compare :: a -> a -> Ordering, ... }" records wouldn't?  Or are you referring to some other consistency?
16:53:21 <davean> buhr: yes, that
16:54:22 <ski> well, i'm claiming that you can avoid this trouble, with the ADT usage of existentials, without type classes
16:58:04 <buhr> I'm sure I remember SPJ talking about this issue of type class uniqueness, maybe somewhere in the "Adventures with Types" lectures.  It doesn't seem like a big deal "in the small", but I think it has probably been very influential in terms of how Haskell has developed and how Haskell programmers think.  I think we have Applicatives and Monads that we actually *use* in part because typeclass uniqueness (and automatic derivation which
16:58:05 <buhr> kind of relies on this uniqueness) gives us this big library of reliable, reusable, and (usually) self-consistent implementations of these interfaces.
16:58:37 <MarcelineVQ> is it that, or that the classes have laws?
16:58:50 <buhr> It comes at a cost, though, and there are instances where the "implementation" existentials would make a lot of sense.
17:00:03 <buhr> The laws help...
17:09:14 <hpc> MarcelineVQ: uniqueness lets you use instances implicitly
17:09:28 <hpc> i would agree the laws are more important, they make type classes really work in the first place
17:09:34 <hpc> the rest makes them easy
17:14:52 <Cale> It's really important and useful that you know which instance you're getting and don't have to worry about where you're getting that instance from
17:15:03 <Cale> Especially because they're passed around implicitly
17:16:26 <Dynasty> Does anyone have any ideas on how I can go about forcing Haskell's instance selection to choose a specific instance based on a constraint? I believe that the type checker will select check if the constraint is satisfied AFTER selecting an instance. I need this to happen before, specifically checking if one of the type variables is a member of the Num class. Here's the instance for reference: https://pastebin.com/jCi6EvJx
17:17:07 <Dynasty> I need "a" to be a number when the selection is happening
17:17:24 <Cale> It can only select instances based on the structure of the types, not on which classes they're instances of.
17:18:03 <Dynasty> Yes I know. I'm looking for hacks here
17:18:14 <enterprisey> In a "where" clause, how can I use semicolons to put multiple assignments on the same line?
17:18:34 <Cale> There's an important reason for this: there might be future modules (either in the sense of not having been compiled yet, or in the sense of not having been written yet) which define instances.
17:18:38 <enterprisey> i.e. (line 1) where f 0 = 1 (line 2) f 1 = 2
17:18:44 <Cale> So you can never rely on instances being absent.
17:19:01 <ski> enterprisey : just do it ?
17:19:10 <Cale> So you can only assume they're present when deciding which instance applies, and then complain if you can't find it in time to actually compile the module.
17:19:18 <ski> (also they are not assignments. they are definitions, defining equations)
17:19:20 <enterprisey> ski: that works? I thought there were curly braces or something involved
17:19:50 <ski> enterprisey : that can be added, but wouldn't be needed in your case
17:19:54 <enterprisey> thanks!
17:19:59 <olligobber> > f 0 + f 1 where f 0 = 1; f 1 = 2
17:20:01 <lambdabot>  <hint>:1:11: error: parse error on input ‘where’
17:20:14 <ski> > let x = f 0 + f 1 where f 0 = 1; f 1 = 2 in x
17:20:16 <lambdabot>  3
17:20:29 <Cale> Dynasty: Probably it would be better to make a newtype to aid instance selection here, rather than trying to write an over-general instance, if the overlap is going to cause problems.
17:20:48 <Dynasty> The whole point of this exercise is to avoid newtype wrappers
17:21:02 <ski> (`where' doesn't form an expression. `let' does. `where' attaches to a defining equation)
17:21:54 <Cale> Dynasty: Well, there's a reason we use them
17:30:13 <Dynasty> Cale: it looks like there are some tricks available: https://wiki.haskell.org/GHC/AdvancedOverlap
17:31:12 <Cale> Messing around with OverlappingInstances isn't worth the trouble
17:31:23 <jle`> can confirm
17:31:44 <jle`> overlapping instances -- just say no
17:32:59 <jle`> i built a library using it and it was so bad that the library is now deprecated
17:33:09 <jle`> well it was deprecated for a different reason
17:33:13 <jle`> but i'm glad i don't have to maintain it anymore :)
17:33:38 <Cale> There are very few circumstances where Overlapping and Undecidable instances are a good idea, and they tend to be very self-contained -- if you don't export the type class from the module it's in, then it can be okay.
17:34:07 <Cale> But basically that only comes up in circumstances where you're doing some type level computation shenanigans.
17:57:16 <mjrosenb> @src lines
17:57:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:57:21 <mjrosenb> @src words
17:57:22 <lambdabot> words s = case dropWhile isSpace s of
17:57:22 <lambdabot>     "" -> []
17:57:22 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:57:33 <mjrosenb> ahh, break!
17:57:45 <jle`> can 'where' really be used like that?
17:58:12 <mjrosenb> you mean in terms of whitespace?
17:58:13 <ski> yes
17:58:39 <ski> it attaches to `case' branches as well as to defining equations
17:59:34 <mjrosenb> I kind of wish there was something that would do words, but allow me to supply my own a -> Bool
18:01:28 <ski> @type unfoldr ((\s -> guard (not (null s)) >> Just (break isSpace s)) . dropWhile isSpace)
18:01:29 <lambdabot> [Char] -> [[Char]]
18:12:38 <monochrom> (Pressed the wrong button.)
20:02:29 <LaurentHuberdeau> Is this channel always so quiet?
20:02:39 <LaurentHuberdeau> And do people ask questions here?
20:04:44 <Bowlslaw> if I'm running ghci at the same time as I'm editing my Haskell file, and I add an import, is there a way to refresh ghci without just exiting it and restarting it?
20:04:45 <davean> I mean, you just did
20:05:01 <blankhart> HERE IS A QUESTION!!!!
20:05:06 <blankhart> i am learning about comonads
20:05:24 <blankhart> there was an interesting discussion about modeling IO as a comonad rather than a monad
20:05:45 <blankhart> it seems to me you could do one but not both right?  since otherwise you could write an identity function that launches the missiles?
20:06:35 <LaurentHuberdeau> Hmmm. I'm looking at the definition and it appears that you could do that...
20:07:41 <LaurentHuberdeau> Can you tell me how they would model IO as a comonad?
20:08:47 <mud> Bowlslaw: :r
20:09:09 <Bowlslaw> mud: Yes, but it doesn't seem to refresh the added import
20:09:29 <Bowlslaw> for example, if I add 'import Network', and then :r, it doesn't recognize it
20:09:42 <LaurentHuberdeau> You can always do import Import Network directly in GHCI
20:09:55 <mud> Bowlslaw: Are you doing the import in the file?
20:09:59 <LaurentHuberdeau> do 'import Network'*
20:10:00 <mud> Or in the repl?
20:10:08 <LaurentHuberdeau> It works directly in the REPL
20:10:16 <Bowlslaw> oo
20:10:37 <mud> It's really better to not do it in the repl, IMO. I do everything in a file and load it in. The repl is just for actually querying the result of different stuff, or types, etc.
20:10:44 <Bowlslaw> I have my file opened in vim and then I did :terminal ghci to open up the repl
20:10:44 <blankhart> LaurentHuberdeau: https://www.cas.mcmaster.ca/~carette/CAS706/F2006/presentations/comonads.pdf, slide 20
20:11:20 <mud> Bowlslaw: I don't think that loads a file in ghci, does it?
20:11:26 <LaurentHuberdeau> Thank you! Love the title of the document!
20:12:07 <sayola> is there a case where Data.Typeable.typeRepArgs returns a list of other than a length of 0 or 2 ?
20:14:21 <Bowlslaw> mud: I have to load ghci after i open it
20:14:34 <Bowlslaw> i like to use that setup because I have my file on top and the repl below
20:18:24 <buhr> sayola:  Sure.  `typeRepArgs (typeOf (Just 5))` returns a list of size one: `[Integer]`.  Is that what you meant?
20:18:34 <blankhart> LaurentHuberdeau: if it's of interest i just found the underlying source which actually makes that point
20:18:40 <blankhart> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.5169&rep=rep1&type=pdf
20:19:43 <sayola> buhr: yes, thank you! sadly, i got me even more confused about how this function ticks. o.O
20:20:06 <LaurentHuberdeau> I'm looking at it.
20:22:07 <LaurentHuberdeau> At slide #16, the table seems to confirm what you said: you cannot do both as the 2 classes are opposed and you could define id = extract . return
20:24:14 <buhr> sayola: In general, for a type like `data Foo a b c = Foo`, it's intended to return the type-level "values" of `a`, `b`, and `c`.  So, `typeRepArgs (typeOf (Foo :: Foo Int String Double))` would be `[Int,[Char],Double]`, and so on.
20:26:08 <sayola> buhr: oh okay. i was just looking for a function representation, so i guess i can just filter for (->) constructors, right?
20:28:25 <blankhart> LaurentHuberdeau: that doesn't seem necessarily problematic in the general case (outside the IO context)
20:28:35 <blankhart> e.g., a nonempty list
20:29:01 <LaurentHuberdeau> I agree
20:29:23 <LaurentHuberdeau> But the discussion was about making IO a comonad?
20:30:05 <Bowlslaw> doesn't IO break the functional paradigm? why doesn't IO break it when using an IO monad?
20:30:35 <blankhart> the next paper i found discussed the "OI comonad" for output-input operations
20:31:47 <buhr> sayola: Right, a function type will be the special case where the type constructor (from `typeRepTyCon`) is `(->)` and the two type arguments (from `typeRepArgs`) are its argument and result type.
20:32:19 <blankhart> Bowlslaw: fair enough. i suppose the concern is just that the side-effecting nature is not reflected in the type signature (which is the way the other paper phrased it)
20:32:39 <Axman6> Bowlslaw: no, IO is pure
20:32:47 <sayola> buhr: thanks :)
20:33:02 <Axman6> execution of IO can have side effects, but ti meets all the requirements for purity
20:33:16 <Bowlslaw> Axman6: really?
20:33:30 <Bowlslaw> I thought IO had to have side effects and that side effects broke the paradigm
20:33:32 <systemfault> Axman6: Is there an article or something about thatÉ
20:33:33 <Axman6> if you have f getLine getLine is the same as let x = getLine in f x x
20:33:33 <systemfault> ?
20:33:53 <Axman6> hmm, I'm englishing bad today
20:34:08 <systemfault> At last, you're not ending your sentences with french characters.
20:34:41 <ski> (`IO' explicitly expresses effects, no "side-" part)
20:34:51 <Axman6> I mean, technically I did
20:38:56 <ReinH> The only IO action that has an effect is main.
20:39:13 <ReinH> (Ignoring unsafePerformIO)
20:40:33 <Axman6> well, importantly IO is a description of a program which is imterpreted by something else, which _may_ perform side effects. the GHC run time system happens to perform side effects, but in tthere's no reason you couldn't also have a mock IO system which was deterministic and didn't actually read from files or print outputs anywhere
20:41:08 <Axman6> interpreted*
20:41:25 <ReinH> The thing that has an effect is executing main.
20:41:46 <Axman6> something which executed main may have effects* ;)
20:41:51 <Axman6> executes*
20:42:05 <Axman6> *
20:42:43 <blankhart> actually isn't unsafePerformIO basically an 'extract' function for an OI comonad?  (IO a -> a) i guess it's right there in the name
20:45:03 <ReinH> No.
20:47:08 <blankhart> say more i am an empty vessel
20:48:14 <blankhart> (i am new to haskell and have not actually encountered that function or comonads before this evening)
20:49:01 <ReinH> IO and a putative OI comonad would work differently.
20:49:04 <Axman6> unsafePerformIO  is something that gets far more press than it deserves and is a hack, but _extremely rarely_ a necessary one. you should ignore it
20:51:36 <ski> (please forget about "OI comonad", it was a mistake, at least in the presense of unrestricted reuse of values)
20:51:46 <blankhart> oh ok agree.  i just meant they had the same type signature. looking back at the kieburtz paper it looks like the OI comonad uses unsafePerformIO all over the place so i just thought.
21:01:02 <blankhart> ski: thank you - the value you cannot unrestrictedly reuse being the original wa (in wa -> a)?
21:03:39 <pavonia> When implementing a quasi-quoter, how do you handle parse errors? E.g the expression quoter has to return Q Exp. But what should the result be if the parse failed?
21:06:42 <glguy> pavonia: You can "fail" in Q
21:06:43 <ski> blankhart : presumably
21:06:56 * ski isn't sure it would work out
21:08:29 <pavonia> glguy: So I would use "report" to display an error message and then fail?
21:10:59 <pavonia> Ah, report doesn't seem to be necessary
21:11:15 <Bowlslaw> man i am really loving Haskell you guys
21:11:45 <Bowlslaw> I started learning about FP with SICP and Scheme, and then I went to FP with Scala, but Scala is so meh...nothing is like Haskell
21:12:57 <gestone> for those have used yesod, is the HandlerT monad sort of like ReaderT?
21:13:44 <gestone> i want to put a ConnectionPool in my App instance and from the examples it seems like i should be able to read those values out
21:14:50 <blankhart> i am also really loving Haskell.  also i heard that if you use Monad "fail" you come down with the German measles but most people have already had them
21:15:45 <jle`> monad fail is ok to use for specific types
21:15:55 <jle`> *Monad fail
21:16:06 <jle`> just using it polymorphically for all Monad is the bad thing :)
21:16:15 <blankhart> a lot of APIs seem to be built around it
21:16:36 <jle`> yes, for specific types presumably
21:16:55 <Axman6> MonadFail fail*
21:16:57 <Axman6> >_>
21:16:59 <blankhart> i haven't thought deeply about it but it seemed to me to be basically a shortcut to wrapping in an ExceptT
21:17:12 <blankhart> without actually doing so?
21:17:15 <jle`> it makes sense for specific types that have a sensible implementation
21:17:29 <jle`> but it doesn't make sense to use it for code that is meant to be polymorphic for all Monads
21:17:39 <jle`> blankhart: every type gets to implement 'fail' in its own way
21:17:51 <jle`> so the behavior is different for every type
21:17:59 <jle`> some types it might be ExceptT-like, some types it might not
21:18:01 <Axman6> > runWriter $ fail "hmm"
21:18:03 <lambdabot>  *Exception: hmm
21:18:06 <Axman6> :|
21:19:03 <blankhart> guess so far i have only seen it used in quasiquoters and megaparsec
21:19:46 <jle`> indeed it is tempting to generalize thing you see in specific instances to be true for all instances
21:19:49 <blankhart> is there a good use that is not ExceptT-like
21:21:13 <jle`> Identity
21:21:17 <jle`> oh sorry, you said good use
21:23:14 <Axman6> > fail "" hmm" :: Identity Bool
21:23:16 <lambdabot>  <hint>:1:30: error:
21:23:16 <lambdabot>      lexical error in string/character literal at end of input
21:23:26 <Axman6> > fail "hmm" :: Identity Bool
21:23:28 <lambdabot>  Identity *Exception: hmm
21:26:05 <EvanR> fail...
21:26:47 <c_wraith> It's an exceptional identity
21:27:36 <Axman6> hence the push for MonadFail and removal of fail form Monad... anyone know what the timeline for that is?
21:28:52 <EvanR> factoring out MonadFail makes sense and will happen, but now i am wondering if they will also go ahead and eliminate the stuff like the Identity instance for MonadFail, and other monads for which fail makes no sense
21:30:22 <EvanR> so we can stop the sideshow
21:30:47 <blankhart> when would you want MonadFail as opposed to MonadError?
21:31:02 <EvanR> maybe if you could expect it to do something besides bottom?
21:31:15 <EvanR> MonadError really o_O
21:31:32 <jle`> the ironic thing is that fail and MonadFail used to be distinct from Monad
21:31:41 <jle`> but people cried out to absorb it into Monad
21:31:59 <jle`> and now we've come full circle
21:32:27 <Axman6> it's there because you can pattern match with Just x <- ... and they needed a way to handle failure right?
21:33:22 <jle`> yeah that's what 'fail' was/is used for
21:33:49 <blankhart> could you spell that out a bit more?
21:33:51 <jle`> but parser combinator libraries have started using it as a part of their naked API
21:34:01 <jle`> which was pretty creative
21:34:20 <gestone> could someone please help me piece together how exactly i'm supposed to use this method? https://hackage.haskell.org/package/persistent-postgresql-2.8.1.1/docs/Database-Persist-Postgresql.html#v:withPostgresqlPool
21:34:22 <blankhart> oh i see within do notation you can pattern match Just x <- ?
21:34:23 <jle`> blankhart: do Just t <- foo; ...; desugars to a >>=/case pattern match + fail
21:34:37 <EvanR> > do Right x <- Left ":("; return ":)" :: Either String String
21:34:39 <lambdabot>  Left ":("
21:34:43 <EvanR> oh cool
21:35:01 <blankhart> the inner mysteries, i had no idea
21:35:05 <gestone> i'm trying to call this in main, but it seems like i need to run this method in some context?
21:35:07 <jle`> `Just t <- foo; blahblah` desugars to foo >>= \case Just t -> blahblah; Nothing -> fail "pattern match fail sorry yall"
21:35:17 <jle`> @undo Just t <- foo; blahblah
21:35:17 <lambdabot> <unknown>.hs:1:8:Parse error: <-
21:35:22 <jle`> @undo do Just t <- foo; blahblah
21:35:22 <lambdabot> foo >>= \ a -> case a of { Just t -> blahblah; _ -> fail ""}
21:35:49 <EvanR> @undo do Right x <- Left ":("; return ":)" :: Either String String
21:35:49 <lambdabot> Left ":(" >>= \ a -> case a of { Right x -> return ":)" :: Either String String; _ -> fail ""}
21:36:31 <jle`> EvanR: `Right x <- Left ":("` is doing something not-obvious
21:36:39 <jle`> `Right x <- Right (Left ":(") would trigger fail
21:36:41 <EvanR> tell me about it
21:36:51 <jle`> since you're doing Either Either
21:37:05 <EvanR> > do Right x <- Right (Left ":("); return ":)" :: Either String String
21:37:05 <buhr> blankhart: Consider `let lefts es = do { Left x <- es; return x } in lefts [Left 1, Right 2, Left 3]`.  This runs in the list monad and for each element of `es` that *doesn't* match `Left x`, it `fail`s.  Of course, failure in the list monad just ignores the failure message and returns an empty list, which is exactly what you want.
21:37:07 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:4-10
21:37:11 <EvanR> o_O
21:37:15 <Axman6> Either Either? well which one is it!
21:37:17 <Axman6> :P
21:37:27 <EvanR> pointless
21:37:45 <jle`> > do Right x <- return (Left ":("); Right ()
21:37:47 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:4-10
21:37:55 <jle`> maybe this would be less confusing
21:37:57 <EvanR> see i could have used that today, if it did something sane
21:38:06 <jle`> > do [x] <- return [1,2,3]; Right ()
21:38:08 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:4-6
21:38:22 <Axman6> > do {Right x <- Nothing; pure x}
21:38:24 <lambdabot>  Nothing
21:38:50 <jle`> Nothing :: Maybe (Either e a)
21:38:53 <EvanR> > fail ":(" :: Either String Int
21:38:55 <lambdabot>  *Exception: :(
21:39:22 <jle`> there isn't really any sane way to make Either String's fail use the string
21:39:33 <EvanR> bollocks
21:39:56 <blankhart> buhr: thanks for the example.  that is not an of-course kind of thing for me because i hadn't considered the behavior of failure in the List monad or trying to pattern match within do notation, and this seems to me a layer of behavioral complexity that do notation doesn't really need
21:40:07 <Axman6> only allow instalce Monad (Either String)!
21:40:36 <Axman6> blankhart: it's pretty handy in the right contexts
21:41:10 <blankhart> yeah i can already think of use cases though hitherto my impression was that ergonomics was not a haskell problem
21:41:17 <Axman6> > do {Just x <- [Just 1, Just 2, Nothing, Just 4]; pure x}
21:41:19 <lambdabot>  [1,2,4]
21:41:38 <EvanR> > fail ":(" :: [Int]
21:41:40 <lambdabot>  []
21:41:42 <EvanR> k...
21:42:07 <EvanR> the string seems mildly useless most of the time
21:42:23 <EvanR> you can have bottoms, or no explanation
21:42:33 <Axman6> it's basically so the compiler can say fail "Pattern match failure at..."
21:42:45 <EvanR> such inelegance
21:42:54 <jle`> so uncivilized
21:43:00 <Axman6> yah
21:43:38 <blankhart> wouldn't it be easier if there were simple syntax for converting pattern matches into boolean values, so you could filter
21:43:56 <EvanR> oh god
21:44:23 <EvanR> i dont think bool is the answer
21:44:53 <EvanR> that feels like stona age
21:45:36 <blankhart> uncivilized?
21:46:28 <EvanR> yes pattern matching has helped eliminate pages and pages of if statements and isFoo functions
21:46:57 <EvanR> and its strictly harder to keep bool code right, since true and false can easily get mixed up
21:47:46 <EvanR> at this point, i am starting to forget whether filter keeps or rejects trues or falses
21:47:59 <ski> @where boolean-blindness
21:47:59 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
21:50:36 <nisstyre> EvanR: the one thing I like about ruby is the name "reject"
22:12:38 <blankhart> my thought was that it would be useful to be able to say concisely something like filter (::= Foo{}) xs, so that you can use a pattern match instead of creating a boolean or ad hoc isFoo functions
22:17:31 <blankhart> but while i'm at it, down with expressive types! long live mutable state! it's after 1am here so i am out for the night.  thank you all for your help and wisdom
22:24:10 <parsnip> > filter (const True) [()]
22:24:12 <lambdabot>  [()]
22:25:20 <Axman6> > filter (\case Just{} -> True; _ -> False) [Just 1, Just 2, Nothing, Just 4]
22:25:22 <lambdabot>  [Just 1,Just 2,Just 4]
22:27:31 <dminuoso> Is it sane to think of `const True` as a left identity for filter?
22:28:20 <parsnip> for traversables?
22:28:23 <parsnip> oh
22:28:43 <EvanR> > (filter (const True) [1,2,undefined,4]) !! 3
22:28:45 <lambdabot>  4
22:28:45 <parsnip> wait, filter is for lists
22:29:10 <Axman6> well, filter (const True) == id :: [a] -> [a], so I guess?
22:29:17 <EvanR> yeah, Traversable cant handle filtering
22:29:41 <parsnip> > id [1, 2, undefined, 4]
22:29:43 <lambdabot>  [1,2,*Exception: Prelude.undefined
22:30:15 <Axman6> do we have a generic concept for things which can be filtered?
22:30:25 <EvanR> ..... Witherable ?
22:30:38 <parsnip> > (id [1, 2, undefined, 4]) !! 3
22:30:40 <lambdabot>  4
22:30:52 <olligobber> > filter (/= Nothing) [Just 1, Just 2, Nothing, Just 4]
22:30:54 <lambdabot>  [Just 1,Just 2,Just 4]
22:31:16 <EvanR> id whatever should be observationally equivalent to whatever
22:31:20 <olligobber> that would only work for lists of type Eq a => [Maybe a]
22:31:40 <olligobber> @type filter
22:31:42 <lambdabot> (a -> Bool) -> [a] -> [a]
22:32:03 <olligobber> I guess you could make a filter for Foldable
22:32:13 <EvanR> which just gives you a list
22:32:30 <EvanR> not a filtered version of the struture
22:32:41 <olligobber> true
22:33:05 <parsnip> you can't filter a tree and get a tree?
22:33:19 <sdrodge> I know this is a topic that's been covered in many places around the web, but I still feel like I've got a poor understanding of what people do in practice about it: how do you deal with strings in Haskell?
22:33:21 <EvanR> sure
22:33:52 <dminuoso> olligobber: What if you had a binary tree, but your filter decided to disregard one child of a node, but not the other?
22:33:52 <sdrodge> Are people using the String type for anything in production? Or is everything Text and ByteString?
22:33:54 <cocreature> sdrodge: I use Text and the convenience helpers provided by protolude
22:33:56 <Axman6> sdrodge: there is no one answer to that question
22:34:18 <EvanR> conversely that question keeps getting asked verbatim
22:34:21 <dminuoso> sdrodge: String is perfectly valid in some cases.
22:34:22 <EvanR> many times
22:34:45 <Axman6> String is often still used, not so much for data but for things like error messages - this  is mostly because of Show
22:35:41 <olligobber> dminuoso, that's the example I thought of too
22:35:45 <Axman6> but good practice is to not use Strings for errors, in many cases a custom error type is better because your program has a chance of being able to do something with the information provided by the error type
22:36:19 <EvanR> use numeric error codes! :)
22:36:26 <Axman6> -1
22:36:31 <EvanR> fatal error 6
22:36:32 <cocreature> EvanR: C programmer detected
22:36:44 <EvanR> contact vendor
22:37:09 <olligobber> or do what I do when there's an error, Left Nothing
22:37:35 <EvanR> leave nothing left standing
22:37:46 <sdrodge> ><
22:37:58 <Axman6> forall e. Either (Maybe e) a because we're supposed to use Either and Maybe for error handling
22:38:00 <dminuoso> Oh that reminds me of fun times when I had a stack smashing bug that rewrote a word that was used in a return code..
22:38:34 <Axman6> sdrodge: if you have a specific problem you want to solve we can help, but your question is like asking "how do people deal with numbers?"
22:38:59 <sdrodge> Yeah, I know the question is a bad one. I'm trying to figure out how to ask it better.
22:39:04 <olligobber> Line 125 is a parse error, so it yields Left Nothing: https://github.com/olligobber/LambdaCalc/blob/master/ParseLambda.hs
22:40:13 <Axman6> sdrodge: some rules of thumb: Start with Data.Text if you know it's text. if you don't, you want Data.ByteString and then to parse that (into Text, or some other format like a JSON Value). String should only really be used if some other library requires it
22:40:45 <Axman6> IMO Data.Text.Lazy is a bit of a code smell, if you need lazy text, you should be using a streaming library like pipes, conduit or streaming
22:40:53 <sdrodge> I guess my question is whether there's a well-described set of best practices enunciated clearly anywhere.
22:40:55 <Axman6> (same is true for bytestrings)
22:41:26 <JohnTheBotanist> whats up
22:41:45 <olligobber> > Left Nothing
22:41:47 <lambdabot>  Left Nothing
22:42:03 <sdrodge> ah, speaking of streaming, that library kind of sparked this question for me because it seemed to use the String type in a lot of places where I might expect a more general or "modern" approach.
22:42:06 <EvanR> lazy text or bs (or string) makes sense if the producer is a self contained algorithm
22:42:42 <Axman6> that's true, it's a code smell if it's produced lazily with IO
22:44:31 <blankhart> nvm just figured out you can pattern match within list comprehensions, like [x | x@Foo{} <- xs]. disregard bomb throwing, haskell is the best. nite
22:44:58 <olligobber> sdrodge, which library?
22:45:31 <Axman6> sdrodge: do you have an example?
22:46:01 <Axman6> streaming has specific types for ByteStrings (and Texts?)
22:46:31 <sdrodge> I'm just talking about the streaming package on hackage.
22:47:03 <sdrodge> Is the idea that you would go use streaming-bytestring for anything "serious?"
22:47:12 <Axman6> yes
22:50:48 <Axman6> or, more realistically, you would use some library which internally uses streaming-bytestring for whatever domain you're working in
22:54:48 <sdrodge> Am I unreasonable for wishing it was easier to determine best practices and the current "best" libraries to use in Haskell?
22:55:35 <dminuoso> ertes-w: Ive been trying to wrap my head around this approach, but it's fairly unclear how `V2 Int -> Store (V2 Int) Bool -> Store (V2 Int) Bool would function. If it returns the same store like you said, then this thing simply has no effect.
22:56:11 <sdrodge> It feels going through the process of choosing a web framework for almost everything.
22:56:31 <dminuoso> I mean the one thing I think I do know, is that I my underlying vector needs to be Mutable. Do you have an example I could take a look at?
22:56:31 <sdrodge> Am I missing something that makes it easier? Or am I deluded to think it should be easier?
22:56:56 <cocreature> sdrodge: I don’t think it’s unreasonable. I’m just not sure how we get to a point where it becomes easier
22:57:58 <cocreature> ofc someone can write some opinionated guide that recommends specific libraries but is relying on the judgment of a single person really an improvement?
22:58:21 <sdrodge> That's a very good point. I wonder why it feels easier in other languages.
22:58:38 <sdrodge> Maybe it isn't and I'm just misperceiving the situation.
22:58:41 <cocreature> sdrodge: tbh ime it’s not really any easier in other languages. try choosing a javascript framework ;)
22:58:48 <qeyoa> don't the best libraries win out the attention of community over time?
22:59:04 <cocreature> what I would like is some kind of crowdsourced comparison of libraries
22:59:11 <sdrodge> That would be very nice.
22:59:22 <cocreature> maybe I should try starting that
22:59:42 <sdrodge> Imagine if some prominent community members published best practice guidelines every 6 months?
22:59:58 <sdrodge> or perhaps even a best practices wiki would work.
22:59:59 <EvanR> i have seen plenty of best practices libs and frameworks in other languages be dreadful
23:00:07 <sdrodge> That's a fair point.
23:00:18 <sdrodge> That said, choice paralysis is a pretty large barrier to entry.
23:00:19 <EvanR> the saving grace being there are many people sinking on the ship with you
23:01:05 <sdrodge> :D
23:01:13 <cocreature> I think an honest comparison is more useful than picking out one specific library and recommending it as best practise
23:01:45 <sdrodge> Fair enough. That would be hugely helpful if there were a centralized resource for that kind of thing though.
23:01:54 <sdrodge> Oh, I need to do some streaming IO, what should I pick?
23:02:02 <sdrodge> wiki article comparing the libraries!
23:02:31 <cocreature> maybe I should just make a github repo for this and try to gain some traction
23:02:45 <dminuoso> qeyoa: No. If that was the case, Ruby on Rails would have never made it on anyones map.
23:02:48 <sdrodge> cocreature: <3
23:02:51 <EvanR> this channel and the blogosphere seems to be the main source of haskell wisdom
23:03:29 <dminuoso> qeyoa: In fact over my time, Ive come to realize the majority of "popular libraries" in other languages are frequently bad or shitty, or both.
23:03:42 <qeyoa> how does that happen?
23:03:59 <EvanR> marketing
23:04:06 <dminuoso> qeyoa: Languages like JavaScript or Rails are infested with tons of bad developers. And marketing.
23:04:22 <EvanR> cake PHP
23:04:32 <ab9rf> popularity is a poor measure of quality
23:04:41 <EvanR> was a best practice
23:04:43 <TMA> the simplest theory is that people are dumb on average, the bigger crowd the bigger chance of dumbness
23:05:07 <ab9rf> EvanR: i don't understand how "best practice" and "php" can be used in the same sentence, but....
23:05:37 <[exa]> ab9rf: in an extreme educative counterexample case...
23:05:43 <qeyoa> var a; a += 'crap'
23:05:56 <guest_> Hi guys , how to convert the DIgest Blake2 type to ByteString?
23:05:59 <liste> I think it's more about the things in a library appealing to developers not being the quality - developers tend to get interested about tech that oversimplifies things at correctness' expense
23:06:06 <TMA> "best practice" usually means just "I probably won't be fired for"
23:06:15 <ab9rf> TMA: that too
23:06:58 <ab9rf> trendy is also a big thing in some of the "less technical" areas of the software industry
23:07:10 <ab9rf> which covers virtually all web dev frameworks
23:07:19 <dminuoso> liste: It's not just oversimplification. In Rails what I notice is that there's lots of people coming that dont know Ruby. So they see Rails as a magic DSL, expecting DSL to solve any programatic problem.
23:07:31 <guest_> Hi guys , how to convert the DIgest Blake2 type to ByteString?
23:07:34 <dminuoso> And if Rails does not have some "magic" to "add two numbers together", then surely there must be a gem to do it.
23:08:38 <dminuoso> A lot of it is related to "not knowing that programming involves writing code to solve problems"
23:13:01 <EvanR> dminuoso: i brought that up at some point with the team manager, i said, uh we arent writing (enough) code here
23:13:45 <EvanR> just trying to get bad plugins and gems to work
23:14:09 <EvanR> for one thing, team members arent going to learn to actually code that way
23:14:34 <EvanR> i guess i was making no sense at the time
23:15:53 <ab9rf> how dare anyone expect a developer to, you know, actually write code
23:15:59 <qeyoa> but how do you leverage writing more code instead of using libraries between tight deadlines
23:16:30 <dminuoso> qeyoa: You usually spend more time fixing the horrible and bad gem code and adapting it to your needs, than just writing a small solution yourself.
23:17:05 <dminuoso> qeyoa: Granted, if you are never used to writing actual code - then yeah writing code is slow and hard. But the underlying problem is not that you're not picking libraries to solve problems for you/
23:17:13 <EvanR> you download the plugin or enter the magic macro that supposedly does the entire task for you, then the future time keeping all that working begins to build up
23:17:23 <EvanR> and the whole time youre not writing any actual code to do it
23:17:27 <EvanR> what are you
23:17:42 <dminuoso> I guess its the modern form of a system administrator.
23:17:53 <dminuoso> Which makes sense, since devops have stolen that job from them.
23:17:58 <cocreature> guest_: you can use https://hackage.haskell.org/package/memory-0.14.14/docs/Data-ByteArray.html#v:convert
23:17:59 <ab9rf> i've been told that these days the code writes itself
23:18:39 <ab9rf> dminuoso: my wife just finished a six month devops job that wasn't really that distinguishable from what she did as a tier 3 application analyst
23:21:27 <sdrodge> Are y'all suggesting that expecting to be able to easily pick libraries for common tasks is a pipe dream and/or undesirable in some way?
23:21:44 <[exa]> guest_: what type does the digest have?
23:22:40 <ab9rf> sdrodge: in most cases, when there's two or more "competing" libraries, it's because none of the available libraries is "clearly better"
23:22:57 <ab9rf> which means picking the "right one" wil depend on your spsecific use case
23:23:03 <guest_> digest is output of crptonite hash function
23:24:02 <guest_> @[exa] digest is output of crptonite hash function
23:24:03 <lambdabot> Unknown command, try @list
23:24:34 <[exa]> guest_: the code from here doesn't work? https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Tutorial.html
23:25:21 <sdrodge> ab9rf: True, but wouldn't it save a lot of man-hours and avert a lot of bad decisions if there was more reliable summary information available with which to make that choice?
23:28:11 <ab9rf> sdrodge: sure. are you volunteering to produce those summaries?
23:30:43 <EvanR> do you have a specific request for information, rather than a meta request for meta information
23:31:06 <dminuoso> ab9rf: Most recent case someone asked about "how to round a number to the nearest multiple of 2". This is clearly a one line solution, but they picked a gem over my function. =)
23:31:10 <EvanR> whats the best streaming library... for what
23:31:25 <dminuoso> Which I think is a bit overkill, but hey. If you suck badly at math..
23:31:55 <EvanR> if you suck at math... how can you feel confident in the process of selecting installing and utilizing a gem :(
23:32:05 <ab9rf> dminuoso: but gems are sparkly!
23:32:45 <EvanR> you suck at math, and programming, and life... so you are good at finding and employing libraries properly
23:32:55 <EvanR> got it
23:33:29 <ab9rf> i read an article a few months ago about how programming will soon be obsolete because computers will program themselves
23:33:58 <ab9rf> i really want to know where whoever wrote that article is getting their drugs
23:34:02 <sdrodge> ab9rf: no, and I don't think anyone owes it to me, but ♬ wouldn't it be nice ♬
23:34:08 <EvanR> can we have computers do better at finding their programmers
23:34:19 <EvanR> would be a good first step
23:34:30 <dminuoso> ab9rf: Well pop science has been a thing for a long time.
23:34:40 <dminuoso> ab9rf: Usually pop science goes hand in hand with "crazy fiction"
23:36:16 <dminuoso> EvanR: Actually that already happens.
23:36:35 <qeyoa> is there any self generating code that's somewhat useful/used?
23:37:18 <EvanR> TH? computing induction principles for dependent types? compilers?
23:37:38 <EvanR> api generators
23:38:07 <ab9rf> qeyoa: all they're talking about are tools that can translate problem specifications in less unnatural languages
23:38:41 <sdrodge> baby steps!
23:39:07 <ab9rf> which is a process that's been in development since the 1950s
23:39:20 <ab9rf> and gets incrementally a bit better with each passing year
23:39:30 <dminuoso> Guess JIT is also a kind of "self generating code"
23:39:35 <dminuoso> Which is a bit more adaptive
23:40:06 <[exa]> guys guys guys
23:40:12 <ab9rf> but is nowhere close to the point where you can go "Computer! If I have three hens, how many eggs will they lay before next Wednesday?"
23:40:30 <dminuoso> ab9rf: Sadly Im not at home, otherwise I would have interrogated my Google Home.
23:40:30 <[exa]> let's say I'd like Haskell working on a really tiny microcontroller, like one with 1M ram and so
23:40:39 <[exa]> what are the best possibilities to do that today?
23:41:00 <ab9rf> [exa]: you want to run code compiled from haskell source, or actually run a haskell build environment?
23:41:30 <dminuoso> [exa]: Mmm. is hOp still in development?
23:41:38 <EvanR> 1M ram haha
23:41:43 <[exa]> ab9rf: programs compiled from hs source. No idea how I'd even fit ghc in that
23:41:44 <EvanR> not 1k ?
23:41:53 <[exa]> EvanR: I didn't want to be really harsh
23:42:01 <dminuoso> [exa]: Oh you want to run a haskell compiler on that?
23:42:04 <qeyoa> EvanR, what does TH stand for?
23:42:07 <dminuoso> Not haskell generated binaries?
23:42:08 <EvanR> template haskell
23:42:20 <[exa]> dminuoso: no, just haskell 'binaries'
23:42:34 <[exa]> I know there's ivory, atom, copilot etc, but these are just DSLs
23:42:35 <dminuoso> [exa]: Well there used to be hOp for Haskell on bare metal
23:42:45 <dminuoso> House was developed using it
23:42:48 <[exa]> will check that out, thanks!
23:42:54 <EvanR> haskell programs need a lot of memory, really
23:43:00 <ab9rf> most do, at least
23:43:05 <EvanR> its not designed for like 1k ram
23:43:14 <ab9rf> i've occasionally managed to write ones that run in relatively little memory
23:43:30 <EvanR> but a slightly different language would be compilable to tiny micros, i believe
23:44:03 <sdrodge> How big is the runtime system?
23:44:09 <[exa]> EvanR: ofcourse I can't start abusing garbage collection in that environment, but I hope something simple would work
23:44:21 <[exa]> sdrodge: pretty big, that's probably the greatest problem
23:44:25 <EvanR> gc is a really integral part of haskells runtime model
23:44:49 <EvanR> and the more memory you have the better that works
23:45:02 <[exa]> hm, hOp is "ghc booting from grub" which is close but doesn't fit
23:45:49 <[exa]> I can't find anything about House though
23:46:11 <guest_> help
23:46:17 <guest_> @help
23:46:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:46:29 <guest_> @list
23:46:30 <lambdabot> What module?  Try @listmodules for some ideas.
23:46:52 <guest_> @quit
23:46:52 <lambdabot> Not enough privileges
23:47:01 <guest_> @exit
23:47:01 <lambdabot> Maybe you meant: quit elite
23:47:11 <guest_> @quit elite
23:47:11 <lambdabot> Not enough privileges
23:47:18 <ab9rf> do you mind?
23:47:19 <cocreature> guest_: you can talk to lambdabot in a private query
23:47:34 <guest_> how
23:47:38 <guest_> ?
23:47:47 <cocreature> depends on your irc client
23:48:04 <cocreature> "/query lambdabot" often works
23:48:15 <guest_> <cocreature>  : am using freenode
23:48:27 <cocreature> that’s not an irc client, that’s the irc network
23:48:53 <guest_> <cocreature> : ok
23:50:02 <sdrodge> [exa]: google searches turned up: http://hackage.haskell.org/package/atom and https://github.com/tomahawkins/improve
23:56:14 <qeyoa> I'm doing an exercise that asks me to "Without looking at the definitions from the standard prelude, define the higher-order library function curry that converts a function on pairs into a curried function". I'm not exactly sure if i understand the task correctly, but i wrote a declaration for it: `myCurry :: (a -> a -> a) -> (a -> a)`. Am i heading in the right direction?
23:56:52 <cocreature> qeyoa: not quite, curry should have type "curry :: ((a, b) -> c) -> a -> b -> c"
23:57:15 <qeyoa> hm, ok, thanks
