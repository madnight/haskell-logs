00:04:03 <piark__> hello
00:12:48 <Krisostoomus> hello cockgangsters
00:15:08 <Krisostoomus> hey, lets fuck some chicks
00:45:05 <dysfun> hey, let's not call ourselves cockgangsters and talk about haskell instead?
00:48:30 <akr> how about typejunkies?
00:52:04 <mcspud> I wonder if #cockgangsters is a thing
00:53:23 <Disavowed> mcspud: it is
00:53:32 <mcspud> It is now
00:56:05 <Disavowed> Let's ban any talk in it that isn't type theory or catamorphisms. It'll be like a #haskell spin off!
01:01:34 <akr> you're just talking about ##dependent :)
01:02:03 <kuribas> I wonder how long people are going to add features from haskell to their language, until they decide just to use haskell :-)
01:03:54 <mcspud> kuribas - I wonder how long people will add features of LISP to Haskell, until they just decide to use LISP
01:04:30 <kuribas> mcspud: haskell has features of lisp?
01:04:41 <mcspud> everything has features of LISP
01:04:48 <mcspud> It is the one true truth
01:35:02 <akr> hey so I have this recursive (inductive, really), pure function and I want to wrap all the recursive calls in some sort of a memoization... do I have to rewrite the whole function in a state monad or something, or is there a better way?
01:35:39 <akr> I guess I could make a memoization library in template haskell, any other options?
01:39:09 <dysfun> akr: https://stackoverflow.com/questions/3208258/memoization-in-haskell#3209189 ?
01:40:40 <akr> hmm SO is giving me an error
01:41:33 <akr> ok the link works if you erase the #* part
01:41:40 <dysfun> yay SO
01:43:26 <akr> that's pretty cool, hadn't thought of that
01:43:33 <akr> thanks, dysfun, I'll use that :)
01:43:45 <dysfun> yw
02:11:51 <rookie> after months I somehow completed LYAH feeling so happy now I know some haskell
02:12:41 <Rembane> rookie: Congratulations!
02:14:03 <rookie> what next  I should do some good project in Haskell
02:14:24 <slacker2014> Noob question -  can I build an executable containing only pure functions?
02:14:44 <Rembane> slacker2014: Almost. You need one not-pure. The main-function.
02:14:54 <slacker2014> my understanding is that main is the entry point but it needs to be IO related?
02:15:05 <Rembane> rookie: Do you have something in mind? What do you want to build?
02:15:25 <akshayn> @rookie: Yeah, even I've been looking around for a project that's not 'Write yourself a Scheme'
02:15:25 <lambdabot> Unknown command, try @list
02:15:26 <Rembane> slacker2014: It does. Because it needs to connect the surrounding world with your program.
02:15:41 <slacker2014> Rembane: so I get add a getLine and call some entry point en the do block?
02:15:50 <rookie> Rembane:  no
02:15:52 <Rembane> slacker2014: Yes.
02:16:10 <slacker2014> Rembane: Thank you!
02:16:16 <Rembane> slacker2014: No worries.
02:18:58 <Rembane> rookie: If you want to make a big jump in difficulty, build a web app in Haskell.
02:19:32 <rookie> web app of ?
02:19:38 <rookie> likw simple blog ?
02:19:51 <Rembane> rookie: Sure, or something you actually need. :)
02:20:53 <Rembane> rookie: I like doing "shell scripting" in Haskell
02:22:05 <rookie> Rembane:  but its not helpful to world, is it ?
02:22:14 <Rembane> rookie: Does it need to be?
02:23:02 <rookie> yeah, I think so but depends
02:23:48 <dysfun> i don't think it's unhelpful to the world to use haskell
02:24:25 <dysfun> presumably this line of argument would stop anyone from deploying anything new and we would be stuck on C
02:24:43 <[exa]> (or java)
02:24:45 <Rembane> Nah, an assembler per architecture. :)
02:24:55 <dysfun> [exa]: but how would java have gotten developed?
02:25:02 <Rembane> Or what was the language used in MULTICS?
02:25:07 <[exa]> PL/1
02:25:17 <[exa]> dysfun: it was not a 'forward' way of development tbh
02:25:29 <dysfun> it had its charms
02:25:35 <Rembane> It looks a lot like Fortran. https://en.wikipedia.org/wiki/PL/I
02:26:27 <Rembane> Or COBOL.
02:27:07 <rookie> why there is no alternative to javascript ?
02:27:24 <Rembane> rookie: Checkout GHCJS or Purescript: http://www.purescript.org/
02:27:34 <dysfun> i really like purescript
02:27:59 <[exa]> rookie: about your problem-- I'm often telling students that can't decide on their project topics to take a piece of paper and a pencil with them to write down a first software that pisses them off
02:28:07 <Rembane> :D
02:28:13 <Rembane> [exa]: +1
02:28:15 <[exa]> rookie: which solves the problem quite nicely
02:28:35 <dysfun> yes, but within an hour they've got a list of a hundred softwares to choose from
02:28:52 <[exa]> even better, one student feeds a whole class with topics!
02:28:57 <dysfun> hah
02:29:10 <dysfun> after a couple of hours, they'll be asking for another notebook
02:29:35 <rookie> [exa]:  are you professor
02:29:57 <[exa]> rookie: btw there could be an alternative to javascript that is safe and actually _compiles_ to something tiny
02:30:10 <[exa]> not like the js JITs
02:30:21 <rookie> purescript and ghcjs ?
02:30:31 <dysfun> ghcjs does not compile to something tiny *at all*
02:30:38 <dysfun> purescript isn't so bad
02:30:38 <[exa]> rookie: phd student, we've got to teach stuff
02:30:41 <rookie> ok dont know
02:30:56 <rookie> awesome
02:31:02 <[exa]> both compile to javascript... what's the status of asm.js btw?
02:31:03 <dysfun> purescript's footprint is sane enough i'm using it
02:31:27 <dysfun> asm.js is still accelerated in common browsers, but focus is shifting to webasm
02:32:07 <rookie> Can we develop awesome UI without js any example website do you have ?
02:32:22 <dysfun> you can develop old school websites
02:32:52 <[exa]> webasm is still run using a VM?
02:33:09 <dysfun> yes
02:33:17 <[exa]> VMs are a plague.
02:33:21 <dysfun> and it's still under development, but the basic formats have been approved
02:33:26 <akshayn> Hi folks!
02:33:47 <[exa]> rookie: it's not straightforward
02:33:55 <akshayn> Been a while since I learn Haskell, but haven't done any projects yet. I'm more interested in Haskell implementation. Any suggestions to get started?
02:33:58 <Rembane> [exa]: What makes VMs a plague?
02:34:26 <[exa]> Rembane: VMs are not 'abstractions without regrets'
02:34:53 <[exa]> akshayn: haskell implementation like writing haskell-like languages?
02:35:06 <Rembane> [exa]: Indeed. But maybe they are worth it?
02:35:20 <[exa]> Rembane: I'm strongly opinionated against that idea. :]
02:35:44 <sr10> http://lpaste.net/362883 im not getting the user if he got two roles for displayUITable1. how should i handle that case
02:35:58 <Rembane> [exa]: We might have to meet in the sunset, pick your weapon! :)=
02:36:16 <[exa]> Rembane: I pick Haskell DSLs!
02:36:29 <Rembane> [exa]: I pick the Java JVM!
02:36:46 <akshayn> [exa]: Yes, something like that. I'm currently doing a course in school; we're using Simon Jone's "The Implementation of Functional Programming Languages" as text.
02:37:11 <[exa]> Rembane: aaaaaaaaaarhghhh
02:37:40 <akshayn> [exa]: But the course is theoretical in flavour and I'd like to see how some of the things are done in practice.
02:38:05 <[exa]> akshayn: well that's probably a good way forward
02:39:56 <[exa]> rookie: anyways, I've always had the idea of somehow abstracting out the concept of the most used UI elements so that the browser only loads the UI specification that's separated from the animations etc.
02:40:16 <Rembane> [exa]: I have a better example though, I think the BEAM does have some really nifty features, it is quite lightweight too.
02:40:33 <[exa]> rookie: also, the same specification could be used for ncurses UI, cmdline UI, opengl UI, etc.
02:41:16 <[exa]> rookie: and well, connect that to the API on the backend directly
02:42:16 <rookie> hmm [exa]  you do phd on programming languages
02:42:21 <[exa]> Rembane: beam is the erlang one iirc? that is a good one
02:42:35 <Rembane> [exa]: Indeed.
02:43:02 <[exa]> Rembane: the question of VMS is 'can you JIT it to assembly-like source without having to use costly abstractions'
02:43:16 <[exa]> Rembane: afaik BEAM was pretty close (unlike JVM)
02:43:58 <[exa]> I should read the spec again sometime
02:44:04 <[exa]> rookie: yes, kindof
02:44:34 <Rembane> [exa]: Yeah. And then it soon turns into a program without a VM but with a fat runtime.
02:44:50 <[exa]> sounds like GHC, doesn't it. :]
02:45:50 <Rembane> Indeed. :)
02:45:56 <dysfun> Rembane: i like the BEAM
02:46:13 <Rembane> dysfun: Sweet! :)
02:46:25 <dysfun> my current stack is actually purescript on frontend and elixir on backend
02:46:37 <Rembane> dysfun: How's elixir?
02:46:59 <dysfun> it's like erlang, but with crap syntax, better macros and more libraries
02:47:18 <Rembane> Cool. Seems like a legit trade off.
02:47:21 <[exa]> s/crap syntax/ML-like syntax/
02:47:34 <dysfun> [exa]: ruby-like
02:47:39 <[exa]> oh even worse
02:47:49 <nullie> Heh
02:48:00 <Rembane> I like Erlang's syntax but this owrks out: https://elixir-lang.org/
02:48:02 <dysfun> yeah, the biggest downside to elixir is the syntax and the people who like it
02:48:31 <Rembane> All them Ruby and Javascript developers? :)
02:48:36 <dysfun> they've also just added a code formatter to core which is annoying
02:48:41 <dysfun> many of them former rails users
02:49:02 <dysfun> the biggest elixir project by far is phoenix, a rails-inspired web framework that doesn't suck nearly as hard as rails
02:49:31 <Rembane> NIce!
02:49:41 <dysfun> (a lot of what sucked about it was state, and it's all immutable data on the BEAM)
02:50:39 <dysfun> there is also a strange type checker tool called dialyzer which employs something called 'success typing', which a bunch of haskell people worked on
02:51:00 <Rembane> That one's built for Erlang.
02:51:13 <dysfun> yeah, the elixir one is called dialyxir
02:53:00 <Rembane> I would prefer a static and rich type system, but I can see why you can't have one in Erlang.
02:53:28 <dysfun> well, yes and no. there's a language called alpaca (formerly ML flavoured erlang) which does a reasonable job
02:54:06 <Rembane> I need to look that up. Thank you.
02:54:08 <dysfun> and the dialyzer is surprisingly effective at rooting out bugs if you can learn to understand what it says
02:54:23 <Rembane> Sounds like the Haskell type errors. :D
02:54:29 <dysfun> yes, doesn't it? :)
02:54:46 <dysfun> actually i'm going mad with a purescript type error this morning
02:54:54 <rookie> elm any opinion ?
02:55:08 <dysfun> it doesn't qualify the types when they're printed, so i get 'Query' doesn't match 'Query'
02:55:16 <Rembane> ^___^
02:55:25 <dysfun> elm is alright for the basics. if you have to do any js interop it's a nightmare
02:55:56 <dysfun> elm is quite a limiting language compared to e.g. haskell, purescript
02:57:12 <dysfun> the major annoyance for me apart from ffi is lack of typeclasses
02:58:53 <[exa]> quite related to the lack of FFI... this is a good read about C: https://www.cl.cam.ac.uk/~srk31/research/papers/kell17some-preprint.pdf
02:59:10 <Rembane> [exa]: Lovely subtitle!
02:59:14 <dysfun> it doesn't *lack* ffi, it's just really really painful
03:01:39 <[exa]> Rembane: it's in fact the best unix-targeted read that I've seen after ESR's Art thereof
03:03:41 <maerwald> dysfun: no one uses purescript though :>
03:03:49 <maerwald> and they break stuff far too often
03:04:03 <dysfun> plenty of people use purescript
03:04:09 <maerwald> I don't think so
03:04:15 <maerwald> not talking about toy projects, but industry
03:04:16 <dysfun> and while they do break stuff too often, it's less broken than it used to be
03:04:40 <dysfun> *shrug* i've found libraries for everything i've needed, some people must be using it
03:04:54 <maerwald> there are libraries for Idris too
03:04:58 <maerwald> no one uses it though :>
03:05:07 <dysfun> there really aren't that many idris libraries
03:05:32 <dysfun> it's really difficult to build a useful application in idris because the libraries just aren't there
03:05:47 <dysfun> (well, that and it being idris...)
03:05:49 <Rembane> [exa]: Nice!
03:05:53 <maerwald> haha
03:06:26 <dysfun> my usual learning style is to pick a thing i want to build, find some libraires and build it
03:06:40 <dysfun> and that's why i've never managed to learn idris satisfactorily
03:07:15 <maerwald> write the libraries!
03:07:27 <dysfun> in fact, when the libraries situation started to get easier in haskell, that's when i figured we'd made it
03:07:42 <maerwald> we have libraries?
03:07:46 <dysfun> we do
03:07:48 <maerwald> you mean DSLs
03:07:48 <maerwald> xD
03:08:00 <dysfun> yes, but in libraries
03:08:00 <maerwald> look at xml
03:08:15 <maerwald> you have to basically learn another language to do xml in haskell
03:08:15 <dysfun> i try not to :)
03:08:37 <dysfun> yes, some libraries are a bit crazy, i won't deny that
03:08:45 <maerwald> the majorit
03:08:59 <dysfun> no, i used to think that was true, but i wouldn't say that anymore
03:09:27 <dysfun> but if i can't understand the example code, i skip on to the next one
03:09:32 <maerwald> well, show me how to do distributed backend in haskell
03:09:41 <dysfun> cloud haskell!
03:09:43 <maerwald> exactly
03:09:45 <maerwald> a DSL
03:10:01 <maerwald> I can't expect anyone to get into that
03:10:13 <dysfun> most of the functions aren't even symbolically named
03:10:18 <dysfun> call that a dsl?
03:10:24 <maerwald> not technically
03:10:28 <maerwald> that wasn't the point
03:11:10 <maerwald> but it's not what a library is in most other languages. Lots of over-engineering and type complexity you have to understand before you can finally call a function and do something
03:11:30 <maerwald> so your decisions on what libraries to rely on are really non-trivial
03:12:04 <dysfun> well if you wanted a proper distributed system today, you should probably just use erlang :)
03:12:21 <maerwald> because it's not so much "here have some useful functions to plug into the rest of your code", it's more like "here, use this framework and hope you will never find anything missing"
03:12:26 <dysfun> but one day, cloud haskell will be great i think
03:12:36 <maerwald> erlang or go, yeah
03:12:46 <dysfun> no to go
03:12:51 <[exa]> lol go
03:13:18 <dysfun> i did one paid golang job and it was awful
03:13:29 <maerwald> at least they know how to write libraries :>
03:13:33 <[exa]> btw is there 0mq or rabbitMQ binding/alternative for haskell?
03:13:37 <maerwald> despite the language just being very annoying
03:13:46 <dysfun> [exa]: nanomsg is a 0mq alternative
03:13:50 <[exa]> oh cool
03:14:13 <[exa]> oh it's not haskell?
03:14:29 <dysfun> there are haskell bindings
03:14:57 <[exa]> which look a bit better than 0mq bindings I see
03:15:02 <[exa]> great
03:15:03 <[exa]> thanks :]
03:15:10 <dysfun> well, nanomsg is a lot simpler than 0mq
03:57:04 <dminuoso> In what particular sense does fix produce a fixed point in this?
03:57:11 <dminuoso> > fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 10
03:57:13 <lambdabot>  3628800
03:58:57 <dminuoso> Oh.
03:58:58 <dminuoso>  > let f = (\rec n -> if n == 0 then 1 else n * rec (n-1)) in (f (fix f)) 10
03:59:02 <dminuoso> Brilliant. =)
04:11:28 <kuribas> maerwald: if you call a combinator library a dsl, you'd better program something else...
04:12:25 <kuribas> maerwald: though other languages are worse, for example lisp macros, xpath (python), linq,etc, etc...
04:12:44 <maerwald> lol
04:12:46 <kuribas> maerwald: haskell combinators are still haskell
04:13:04 <kuribas> not some stringly typed language on top of another one.
04:13:14 <kuribas> okay, disregarding TH :)
04:13:45 <maerwald> I think a lot of people should better program something else instead of haskell, because they make it look like Java ;)
04:13:56 <x0x0_> I am getting `error stack configuration has no specified version of the package  `  when trying to build a project that depends on the heroku package, any idea ?
04:14:23 <kuribas> maerwald: where?
04:14:36 <maerwald> Yesod?
04:14:56 <kuribas> maerwald: also, let them?
04:15:02 <Rembane> maerwald: How?
04:15:04 <maerwald> sure, you started that silly angle ;)
04:15:19 <kuribas> yesod is more concise than java
04:15:28 <kuribas> I don't know it so well though...
04:17:06 <kuribas> maerwald: also, having typed message in cloud haskell looks pretty cool.
04:17:47 <qeyoa> why is `(A ^ B) => A (conjunction of A and B Implies B)` always true?
04:17:49 <x0x0_> What is cloud Haskell?
04:17:58 <maerwald> I don't like over-engineered stuff. In Java people over-engineer in the name of decoupling or other things. In haskell it's in the name of "abstraction", but you often end up with a similar mess
04:17:59 <kuribas> x0x0_: distributed haskell
04:18:04 <qeyoa> why is `(A ^ B) => A (conjunction of A and B Implies A)` always true?*
04:18:50 <kuribas> maerwald: I find that haskell libraries are much easier to compose than other language libraries.
04:18:57 <maerwald> I completely disagree on that
04:19:06 <maerwald> but we seem to agree on what we *want* though
04:19:35 <cocreature> qeyoa: are you asking about a formal argument or an informal explanation?
04:19:39 <qeyoa> i thought that conjunction means overlapping items in a list
04:19:52 <qeyoa> and if nothing is overlapping then it should be an empty list?
04:19:55 <qeyoa> not A
04:20:01 <cocreature> huh what do lists have to do with anything?
04:20:09 <qeyoa> set*
04:20:27 <cocreature> the conjunction of a and b holds if a and b hold
04:20:38 <kuribas> maerwald: my experience with haskell libraries is mostly positive.  Not so with python libraries.
04:20:59 <qeyoa> corecreature, is that what that statement says?
04:21:10 <kuribas> maerwald: ranging from mostly positive to absolutely awesome :)
04:21:38 <cocreature> qeyoa: I don’t really understand your reasoning. where do sets come into play here?
04:21:39 <dysfun> there are some really good python libraries though
04:22:07 <qeyoa> i have no idea, the book started an example of propositions (Graham book )
04:22:12 <kuribas> dysfun: I don't want to touch sqlalchemy ever again...
04:22:18 <qeyoa> i'm trying to figure out what is going on
04:22:19 <qeyoa> :)
04:22:30 <dysfun> kuribas: could be worse, could be the django orm :)
04:22:31 <maerwald> kuribas: easy comparison there. click in python is a bliss for creating cli programs. Doing the same in haskell would either involve huge TH mess or whatever
04:22:33 <kuribas> dysfun: to much *magick*, stuff going on around your back.
04:22:54 <qeyoa> i thought that conjunction is used for sets
04:22:58 <kuribas> maerwald: erm, do you know of optparse-applicative?
04:23:05 <qeyoa> so items in two sets that overlap?
04:23:06 <cocreature> qeyoa: I think you might be confusing conjunction and intersection?
04:23:11 <qeyoa> a
04:23:11 <maerwald> kuribas: how does that compare to click?
04:23:34 <kuribas> maerwald: idk, I don't know click
04:23:36 <cocreature> they are related in some sense but talking about sets when you’re interested in logical formulas at least requires some explanation
04:23:39 <maerwald> kuribas: check it out
04:23:55 <maerwald> optparse-applicative is nothing like it
04:24:41 <kuribas> maerwald: looks like a typicall bloated python mess.
04:24:58 <maerwald> *shrug*, it really isn't
04:25:06 <maerwald> it's well-designed abstraction
04:25:21 <qeyoa> corecreature, is there a quick read that i could hover my eyes over to understand what is going on here: http://lpaste.net/362887?
04:25:23 <kuribas> maerwald: optparse-applicative doesn't intend to be a kitchen sink
04:25:32 <maerwald> no idea what that means
04:25:34 <kuribas> maerwald: it does one thing well, parsing command line parameters.
04:25:46 <maerwald> good for it ;)
04:26:05 <maerwald> I wasn't comparing anything to optparse-applicative
04:26:47 <kuribas> maerwald: anyway, if you like python + click, by all means :)
04:27:06 <maerwald> I do, for prototyping or simple cli programs, for anything else the language is awful
04:27:24 <maerwald> mypy is not reliable enough
04:27:50 <qeyoa> oh, sorry, i mistyped your nickname cocreature*
04:28:03 <kuribas> maerwald: use wathever makes you happy
04:28:14 <qeyoa> for some reason i read your nickname as corecreature
04:28:24 <comerijn> qeyoa: Means you haven't read enough math
04:28:57 <qeyoa> ok, what should i read?
04:29:07 <maerwald> kuribas: sure
04:29:12 <comerijn> qeyoa: That was mostly a joke :p
04:29:19 <qeyoa> ah
04:29:29 <maerwald> I was just commenting on your experience with python, which I do not share
04:29:31 <comerijn> qeyoa: My 1 line summary is that "co-X" is math speak for "opposite world-X" ;)
04:29:43 <maerwald> not to the same extent, at least
04:30:17 <cocreature> qeyoa: something about propositional logic but I don’t really know any good resource
04:30:46 <qeyoa> well, i will try to figure this out, thanks
04:30:54 <cocreature> qeyoa: basically And is just the boolean and operator that you find in about every programming language, not is boolean negation and imply is implication
04:31:48 <comerijn> qeyoa: ah, I missed your original question. It seems that my joke about you misreading cocreature's name might've got misunderstood as relating to the question instead :)
04:32:19 <maerwald> kuribas: I think there is a trade-off between language and ecosystem... very often
04:32:20 <qeyoa> is implication something like this: if a = -2 and b = a, a being negative implies that b is also negative?
04:32:27 <lseactuary__> i am trying to create images but i am confused on the following: http://lpaste.net/285725662893834240
04:32:48 <lseactuary__> can someone kindly explain this a little (the structure) as im not really getting it
04:32:52 <lseactuary__> then i can write the functions
04:32:53 <cocreature> qeyoa: "a → b" is equivalent to "¬a ∨ b"
04:33:14 <kuribas> maerwald: it has to do with $$$$ (or €€€€).  haskell simply doesn't have the amount of $$$ pumped into it as java.
04:33:49 <maerwald> kuribas: maybe, but it's also about mindset I guess
04:34:10 <maerwald> how much people experiment, what their view on stability, consistency or practicality is etc
04:34:23 <maerwald> how often do they break API
04:34:26 <maerwald> a lot of things
04:34:38 <kuribas> maerwald: possibly, but there's only so much a few people can do...
04:35:12 <maerwald> maybe Google should hype haskell and see what happens
04:35:17 <maerwald> they are good at hyping stuff
04:37:46 <kuribas> their own stuff
04:38:15 <kuribas> there's facebook and micro$oft
04:39:04 <merijn> woah...did I just get teleported to the web in the 90s?
04:39:18 <maerwald> facebook doesn't commit large-scale to haskell, they have hundreds of languages in use and constantly build their own custom ones and whatnot
04:39:32 <maerwald> maybe not hundreds xD
04:59:18 <sr10> http://lpaste.net/362883 im not getting the user if he got two roles for displayUITable1. how should i handle that case
05:08:38 <qeyoa> I think i remember something about this conjunction and implication stuff. In `(A ^ B) => A` i take the value of A and B and look at the `(A ^ B)`. If, say, A is True and B is False, i look at the logical conjunction table and it gives me False. So now i have `False => A`, or `False => True`. Now i look at the implication table and see that this gives me `True`. So from what i understand/remember, this
05:08:44 <qeyoa> logic algebra magic makes it easier to reason about complicated truth computations?
05:14:32 <cocreature> I’m not sure what exactly “logic algebra magic” is supposed to be but your reasosing sounds correct :)
05:15:42 <Tuplanolla> If you're talking about line 27, that's a nice corollary you get from the ordering of truth values, qeyoa.
05:17:43 <Tuplanolla> If `False < True`, then "p implies q" has the same truth table as "p is less than or equal to q".
05:21:38 <qeyoa> Tuplanolla, do you mean line 27 from the lpaste.net link i posted?
05:21:46 <Tuplanolla> Yes.
05:25:36 <[Leary]> Sounds like an abuse of an Ord instance to me...
05:27:14 <Tuplanolla> It's not any different from using their equality to implement "p xor q" as "p not equal to q", [Leary].
05:31:01 <akr> dysfun: so I realized that I can't use the memoization technique you linked directly, because my memoization is monadic (but the function I want to be memoizing is pure)
05:31:07 <akr> any thoughts on that?
05:31:20 <[Leary]> The difference is that the Eq instance for Bool isn't arbitrary.
05:31:46 <merijn> [Leary]: IN what sense is the Ord instance "arbitrary"?
05:32:27 <[Leary]> I don't see any reason why we should have False < True.
05:32:34 <[Leary]> Or the opposite.
05:32:50 <akr> because lattice theory, basically
05:33:17 <akr> which is more of a guiding link that real reason though, arguable
05:33:20 <akr> arguably
05:35:40 <[Leary]> Or rather, I can see how having one or the other can make some sense within the Haskell ecosystem, but I don't think either of the two (arbitary) choices makes more sense than the other.
05:35:53 <akr> in other words, we want (Bool, and, or, not, True, False) to form a boolean algebra, because they have nice properties and are fairly well understood
05:35:59 <qeyoa> are there logical implication operators like `<=` in haskell, in other more mainstream languages like c++, java etc..?
05:36:13 <akr> but when you're programming you don't really need to need the details of this, you can just use your intuition
05:36:13 <merijn> [Leary]: I do, because the current one follows the logic of every mainstream programming language
05:36:55 <akr> qeyoa: a ⇒ b  is just  ¬a ∨ b
05:37:12 <akr> (in any boolean algebra, not in a heyting one :P)
05:39:54 <mcspud> [2018/02/25 -:- 11:21:50 pm] kuribas:	dysfun: I don't want to touch sqlalchemy ever again...
05:40:02 <mcspud> [2018/02/25 -:- 11:22:11 pm] kuribas:	dysfun: to much *magick*, stuff going on around your back.
05:40:07 <mcspud> Not really
05:40:48 <mcspud> For a tool to be useful it has to provide some level of generalised, default, (dare I say it) batteries-included functionality
05:40:49 <kuribas> mcspud: I am talking things like lazy attribute reads causing data to be flushed to the database.
05:41:18 <kuribas> mcspud: and I prefer libraries that do one thing, and do them well.
05:41:24 <mcspud> Thats just a property of its design (the colloquial Fowler "data-mapper" design
05:41:25 <kuribas> mcspud: for example beam
05:41:38 <mcspud> As in Erlang BEAM?
05:41:53 <kuribas> mcspud: https://hackage.haskell.org/package/beam
05:41:58 <mcspud> Because that is a particularly magical piece of software to me >_>
05:42:00 <mcspud> oh right
05:42:14 <qeyoa> akr, so a => b is a NOR b, NOR as in "joint denial"
05:42:58 <akr> I don't know what joind denial is
05:43:14 <mcspud> kuribas - I think SQLAlchemy is a pretty great ORM honestly, but like all complex, generalised tools there is always that trade off learning its features or just hand-crafting your solution manually
05:43:18 <qeyoa> the Wiki says that NOR operator is joint denial
05:43:36 <mcspud> kuribas - that trade-off being time :)
05:43:37 <kuribas> mcspud: it might be ok for a small website or something
05:43:37 <[Leary]> merijn: so we're following a convention that consists of an arbitrary choice, rather than making that choice ourselves. I don't find the difference relevant.
05:44:04 <akr> qeyoa: I see, no
05:44:33 <mcspud> kuribas - meh, if you say so.  The django ORM, which IMO is a flawed design compared to SQLAlchemy, was processing 1.5 billion requests/day for instagram
05:44:51 <akr> qeyoa: joint denial is  ¬a ∧ ¬b
05:44:55 <qeyoa> ok
05:45:00 <mcspud> And something like 8billion/month for Discord
05:45:13 <kuribas> mcspud: on how many computers?
05:45:33 <mcspud> I don't know, but thats not really the point is it
05:45:41 <qeyoa> is this valid  ¬(a ∨ b) == ¬a ∨ ¬b
05:45:42 <qeyoa> ?
05:45:50 <mcspud> You can't honestly say that they aren't "industrial strength"
05:45:52 <kuribas> mcspud: err, yes it is?
05:46:15 <kuribas> mcspud: if it does that on a single computer, yes, that's impressive.
05:46:17 <mcspud> kuribas - I probably missed the rest of your text, I just saw the SQLAlchemy bit :)
05:46:19 <akr> qeyoa: no, ¬(a ∨ b)  is equivalent to  ¬a ∧ ¬b
05:46:30 <qeyoa> yes, that is what i'm asking
05:46:32 <qeyoa> :)
05:46:40 <kuribas> mcspud: I just had bad experience with it.
05:46:46 <akr> qeyoa: no, your second formula was different
05:46:58 <mcspud> Then again, I'm not aware of any Haskell-anything doing that sort of work for any project, anywhere, ever.
05:47:15 <qeyoa> akr, i was branching off to a different question
05:47:27 <qeyoa> just wanted to know if ¬(a ∨ b) == ¬a ∨ ¬b
05:47:30 <qeyoa> was valid
05:47:34 <akr> and I said no :)
05:47:38 <mcspud> The closest I can think of is Ocaml running Cisco's RemoteDesktop or whatever its called, but it is a different type of problem
05:47:46 <kuribas> mcspud: well, I did try to implement the core logic of our app in haskell, it took me 1 week what my previous team took 1.5 year.
05:47:46 <akr> and provided the correct identity for ¬(a ∨ b)
05:47:48 <qeyoa> ah, i see
05:47:59 <mcspud> kuribas - there is that :)
05:48:01 <kuribas> mcspud: without any orm (just sqlite-simple)
05:48:22 <kuribas> mcspud: I don't want to say it's never useful though...
05:48:23 <mcspud> kuribas - I'm not arguing for any OO language at all, I've seen the light, I'm "just saying" is all :)
05:49:05 <merijn> kuribas: I keep getting into the sqlite-simple and "higher-level" database libraries and this weekend I finally realised a core reason why I would like a higher level library
05:49:16 <merijn> kuribas: SQL is awfully uncomposable
05:49:25 <mcspud> kuribas - yeah, sure.  I understand.  Isn't SQLAlchemy used behind the scenes for Youtube?  I don't think you can say thats a small-site, but again I'm not clear here
05:50:14 <qeyoa> i somehow have to start reading words more carefully, my terrbile reading habits intepret the first half of the word and go to the next one, so i often miss that  ¬(a ∨ b)  is equivalent to  ¬a ∧ ¬b
05:50:29 <qeyoa> are not both v, but rather v and upside down v
05:50:33 <qeyoa> :)
05:50:35 <kuribas> mcspud: sure, I cannot work with it, but others undoubtedly can :)
05:51:02 <kuribas> merijn: yeah, I just loaded whole tables into haskell, and use dictionaries to construct my datatype :)
05:51:05 <akr> qeyoa: no worries, it's just practice
05:51:26 <mcspud> kuribas - you can apply that statement to anything in the FP world
05:51:31 <merijn> kuribas: See, it's not the projection bit that's the issue for me, I'm okay with handwriting that
05:51:33 <mcspud> :P
05:51:55 <merijn> kuribas: But the fact that I can't easily extract/reuse subqueries
05:52:12 <kuribas> hmm, can't you?
05:52:32 <merijn> kuribas: Well, enlighten me how, unless I just string concat queries together
05:52:37 <kuribas> merijn: couldn't you save the subquery as a table?
05:52:58 <merijn> kuribas: When subqueries can be millions of entries I don't *want* to save them as a table
05:53:14 <kuribas> merijn: well, in sqlalchemy you can :)
05:55:26 <kuribas> merijn: hmm, at first view, beam queries seem composable: https://hackage.haskell.org/package/beam-core-0.6.0.0/docs/Database-Beam-Query.html#g:1
05:56:09 <merijn> kuribas: Yeah, but the usual discussion is ertes and some other arguing in favour for sqlite-simple/postgres-simple/etc. over something like Beam
05:56:21 <kuribas> oh, right.
05:57:12 <kuribas> merijn: the reason I used sqlite-simple was because I wanted something quickly, and ran into an issue with Beam (which is solved now).
05:57:19 <ertes> i was checking out selda and beam just today
05:57:35 <kuribas> merijn: but personally I'd prefer statically checked queries.
05:57:48 <merijn> I think Selda needs a bunch of work to be useful, but it's easier to fix than reviving opaleye-sqlite
05:58:58 <ertes> yeah, i was too worried about having to deal with selda's limitations, and beam didn't appeal to me, so for now i'm back to sqlite-simple
05:59:33 <kuribas> mcspud: lazy loads are like lazy IO, they seemed like a good idea, but can create a world of pain ...  They can be ok if used carefully.
05:59:53 <kuribas> ertes: what don't you like about beam?
06:00:14 <mcspud> kuribas - Honestly I haven't had a problem with them, so I'm going to have to defer to your experience here
06:00:21 <mcspud> Some lessons you need to learn the hard way :)
06:00:57 <merijn> ertes: My main objection is that, currently, Selda doesn't seem to have easily accessible escape-hatches
06:01:03 <metahumor> has anyone had issues with building "unix-time"? i'm hitting "fatal error: config.h: No such file or directory"
06:02:15 <qeyoa> why is `<=` keyword not in https://wiki.haskell.org/Keywords?
06:02:16 <ertes> kuribas: MonadBeam, the fact that i need to use wrappers everywhere, etc.
06:02:45 <cocreature> qeyoa: because it’s not a keyword. it’s just the name of a function defined in the standard library
06:02:52 <qeyoa> thanks
06:03:23 <merijn> ertes: At least with persistent I can just punch it to give me a raw sqlite binding
06:03:36 <ertes> kuribas: it reminded me too much of the kind of magic i experienced in persistent:  too many layers of abstraction and "convenience"
06:03:56 <ertes> merijn: yeah…  even if it were possible to get a raw handle, it defeats the purpose
06:04:16 <ertes> why should i define selda types, if i'm not going to use them?
06:05:04 <merijn> ertes: Because if you only need this 1 query to use low-level sqlite, but not the remaining 90% of your queries?
06:05:53 <ertes> merijn: unfortunately 90% of my queries do need streaming =)
06:06:05 <merijn> ertes: oh, yeah, the lack of streaming is an issue
06:06:08 <plugin> I need to increment and decrement an already existing `Unique`. (The reason involves keys `HKey s t` in an `HMap`; I need to be able to obtain the last and subsequent keys made in the HMap but I can’t keep them in a normal map since the types vary in `t`). Is this possible?
06:06:38 <ertes> plugin: it's wrong to assume that Uniques follow any particular sequence
06:06:43 <merijn> ertes: But that's probably the most trivial to solve issue
06:07:13 <plugin> ertes: they have an ord constraint and under the hood they're just `Integers`
06:07:16 <x0x0_> I am a little bit confused about difference between library and executable. These fields are there in  cabal file.
06:07:37 <ertes> merijn: well, if someone solves it for me, i'll certainly give it a short…  right now learning the internals to fix selda myself is more work than just writing those ugly SQL strings =)
06:07:41 <merijn> x0x0_: Well, one defines a library and one defines an executable? :p
06:07:44 <ertes> *shot
06:07:50 <x0x0_> According to my understanding ,library is code and exec is binary ?
06:07:57 <ertes> plugin: that doesn't imply that you get them in a certain order
06:09:11 <plugin> ertes: fair enough, I suppose there could be a number of reasons for that.  I'll change my question.
06:09:50 <x0x0_> @merijin I mean what the benefits of using library or the executable field in cabal file
06:09:50 <lambdabot> Unknown command, try @list
06:10:49 <quchen> x0x0_: The library can be used by other libraries/executables outside of the package defining it
06:11:22 <quchen> x0x0_: For example, Cabal is a library and an executable; the Cabal library is used by many other projects to e.g. deal with Hackage, while the executable is exclusively used to deal with installing packages in userland
06:11:33 <plugin> New question:  I need a Map of Int (HKey s t) where t is heterogeneous and not statically known.  Can anyone recommend a good way of getting this?
06:11:56 <x0x0_> Cool
06:12:12 <ertes> plugin: you could use existentials
06:12:15 <kuribas> ertes: so you'd need something like "beam-pipes".
06:12:26 <quchen> Most Haskell programs are actually libraries with very small executable wrappers around them, for example GHC :-)
06:12:26 <ertes> kuribas: selda-machines
06:12:53 <ertes> kuribas: but really all i need is a streaming interface…  i can write the machines wrapper myself
06:12:54 <plugin> ertes: how do you mean?  How would I recover the 't'?
06:13:07 <ertes> plugin: by pattern-matching
06:13:20 <merijn> kuribas: tbh, Beam looks like it has entirely too many typeclasses to me
06:13:45 <plugin> ertes: could you point me to an example, I seem to not understand this basic concept
06:13:51 <ertes> i haven't looked too deeply into it, but beam looks massively overengineered
06:14:55 <kuribas> merijn: to make it generic over different backends?
06:14:58 <merijn> ertes++
06:15:04 <merijn> kuribas: Don't need typeclasses for that
06:15:22 <merijn> kuribas: Could just use a record of operations, like Selda
06:15:37 <kuribas> hmm, true
06:15:45 <ertes> plugin: https://wiki.haskell.org/Existential_type
06:17:48 <ertes> kuribas: i think selda relates to beam in the same way scotty relates to yesod
06:20:36 <metahumor> anyone with experience into how to "cabal new-build" and place the built packages as available to cabal for other packages?
06:21:05 <metahumor> i'm running into a build issue i can fix if i clone the repo and mess with it a little -- how do i inject that as the target
06:21:59 <dmwit> metahumor: clone the repo and list the repo as a package in your cabal.project
06:22:38 <metahumor> no way to do that globally? unix-time-0.37 is a dep for a lot of things
06:22:59 <dmwit> No, cabal new-install does not yet exist.
06:23:49 <dmwit> But if you have a lot of things that all fail in the same way, perhaps they really should be part of the same project...?
06:24:07 <merijn> dmwit: I think there's something like it in HEAD
06:24:33 <dmwit> As far as I know there is only new-install for nonlocal executables.
06:24:34 <merijn> metahumor: What are you trying to do? I don't understand your question
06:24:37 <dmwit> Won't help for libraries.
06:24:43 <metahumor> alright. when building, unix-time gets pulled in as a dep, and building of it fails because somehow the "config.h" that is generated is not visible to cabal again
06:25:22 <metahumor> i got cabal to build the repo for unix-time-0.37 by copying the generated config.h back into cbits...
06:25:57 <merijn> metahumor: Ok, what you can try (no clue if this'll work) is add your local version of time as a package and then allow newer
06:26:06 <kuribas> ertes: beam does seem rather heavy on advanced type extensions, which may scare new haskell programmers...
06:26:26 <metahumor> but i can't do the same for a general cabal new-build because it deletes the build directory in ~/.cabal/store/ghc-8.0.2 upon failure
06:26:28 <merijn> metahumor: i.e. add "packages: ../path/to/time" and "allow-newer: time" to cabal.project
06:27:10 <merijn> kuribas: I wouldn't consider myself a new Haskell programmer and they're scary to me too, because my Yesod/persistent experience is that they're fucking bitch to debug due to all the ridiculous polymorphism in the types
06:27:26 <kuribas> true
06:45:20 <ggVGc> wonder when I can consider myself a haskell programmer
06:45:55 <akr> when you program in Haskell, presumably
06:46:01 <hpc> you have to be named simon
06:46:09 <hpc> or since ghc 6.10, edward
06:46:32 <Rembane> ggVGc: When you say that you are.
06:47:01 <hpc> i would set the bar at if you can think in the language
06:47:35 <ggVGc> yeah I guess I am then.. I use haskell as my goto-language since about a year, but I stay at the very simple levels of it
06:47:47 <ggVGc> I barely abstract, and barely implement any instances of type classes
06:47:57 <ggVGc> only when I feel the need
06:48:00 <hpc> yeah, i would call that being a haskell programmer
06:48:04 <ggVGc> which is surprisingly seldom
06:48:10 <hpc> some of my best functions are monomorphic
06:48:12 <akr> it's better to have those instances generated by the compiler, anyway :)
06:48:19 <exarkun> ggVGc: the less you do to accomplish your goals, the better
06:48:42 <ggVGc> akr: yeah, but I mean, even if I see something is probably a Monoid, I mostly don't implement it, until I have the need to use it as a monoid
06:48:47 <ggVGc> exarkun: yep
06:49:09 <Rembane> ggVGc: Really simple Haskell is good stuff imo
06:49:28 <hpc> imo haskell is best at the really simple stuff
06:49:46 <hpc> forget even GADTs, first-class IO is where it's at
06:49:55 <ggVGc> :)
06:50:04 <ggVGc> I've never used a GADT for real..
06:50:04 <hpc> being able to pass an IO action to a function and not have to do () -> IO whatever
06:50:09 <Rembane> Really simple Haskell: https://github.com/Rembane/Mute/blob/master/app/Main.hs :D
06:50:12 <ggVGc> I think I tried a few times, but it turned out not to be what I wanted
06:50:31 <hpc> hah, nice
06:51:22 <hpc> i think my favorite haskell i've written is https://github.com/headprogrammingczar/http-bench/blob/master/Main.hs
06:51:31 <ggVGc> I think one of my my main takaways of haskell is that I can hack whatever up as crappy as I want it, becuase I can always aggressively refactor it when I feel it works, and have the compiler shout at me
06:51:38 <Rembane> +1
06:51:52 <ggVGc> I can do refactoring fairly mindlessly
06:51:59 <ggVGc> whihc has never been the case for me anywhere else
06:52:01 <Rembane> hpc: Nice!
06:52:14 <hpc> Rembane: :D
06:52:40 <hpc> i wrote that in about 2 hours, and was really happy with how compact the concurrency code ended up being, for what it did
06:53:12 * ggVGc ports it to APL
06:54:13 <ggVGc> :( my hands feel uncomfortable because I started a new project and added 12 dependencies and am doing the first compile now...
06:54:19 <ggVGc> poor laptop
06:54:45 <hpc> heh
06:54:50 <Tuplanolla> I've found myself leaning on more complicated type systems whenever I have problems that I don't understand, which is almost always.
06:55:13 <ggVGc> I'm still waiting to understand a single programming thing
06:55:30 <ggVGc> well, or understand a single thing for that matter
06:55:41 <ggVGc> my grandfather always said, we never understand anything, we just get used to things
06:55:55 <ggVGc> always echoes in my head
06:56:40 <hpc> it has layers, i think
06:57:25 <Rembane> Turtles?
06:57:31 <ggVGc> I'd like to finally understand free monads
06:57:33 <EvanR> magnets
06:57:36 <hpc> Rembane: ogres ;)
06:57:40 <Rembane> hpc: I see!
06:57:53 <Rembane> I'm 100% fine with not understanding free monads. I just use them now and then.
06:57:57 <ggVGc> oh, now I see why this is taking so long.. Lens was in the deps list
06:58:35 <hpc> Rembane: i used free monads once and they were only almost the correct solution for the problem at hand
06:59:10 <hpc> i had a similar sort of thing happen for ContT
06:59:33 <ggVGc> I kind of need to use ContT for this project, since I'm dealing with a fair bit of IO callbacks that are quite messy
06:59:44 <ggVGc> but I haven't had the eneregy to dig into it
06:59:52 <ggVGc> or time
07:00:14 <hpc> a tip that might save you some time, ContT is the most primitive abstraction over continuation passing
07:00:17 <ggVGc> also, in the end it's gonna be callbacks anyway, so not sure how much it'll help
07:00:25 <ggVGc> hpc: yep, I know
07:00:26 <hpc> and if you understand it well, you can write something more suitable
07:00:48 <hpc> like the type for parsec parsers, it has four continuations
07:01:45 <hpc> the problem i was trying to solve with ContT, i ended up solving with State (SomeRecordType, IO SomeOtherRecordType) ()
07:02:41 <hpc> i wanted to short-circuit computation if the intermediate results already existed on disk, which required something "backwards" from how ContT arranges computations
07:03:16 <EvanR> you mean, skip ahead in the computation
07:03:24 <EvanR> rather than abort
07:03:26 <hpc> er, yeah
07:05:23 <hpc> specifically it was for image manipulation
07:05:40 <hpc> everything else about that project was absolutely horrid, but the underlying computation type was pretty solid
07:23:39 <ggVGc> I haven't really found a nice way of dealing with IO callbacks in haskell
07:23:44 <ggVGc> so I think I have a lot to learn there
07:23:52 <ggVGc> my haskell in this area is just barely better than javascript
07:24:02 <Welkin> callbacks?
07:24:09 <kuribas> ggVGc: ContT?
07:24:31 <Boomerang> Hello! I had some ideas for a couple of GHC proposals and I thought I should probably discuss them here before writing the proposal documents. This way I could get some idea if they have been discussed before or if they would even interest any other haskellers. :-)
07:24:33 <hpc> i would start with just passing functions to functions
07:24:36 <ggVGc> kuribas: yeah that's what we were talking about :)
07:24:41 <hpc> and see what simplifies your code after you've written a bit
07:24:44 <ggVGc> hpc: yeah, right, that's what I'm doing
07:24:49 <ggVGc> isn't that literally what callbacks are?
07:24:53 <hpc> yeah
07:25:04 <ggVGc> that's why I said it's just barely better than JS :)
07:25:10 <hpc> ;)
07:26:16 <ggVGc> hpc: basically this is what I'm doing now, which is kind of okay, but not great, https://gist.github.com/738117d989a7a4007cadad4d2d75f563
07:26:56 <Boomerang> A first idea that I discussed with a few colleagues is to have scoped data declarations. In a where or a let clause you could have data/type/newtype declarations along with instances or class definitions. This would be useful in cases where you could benefit from more type safety without poluting the top level with many declarations that will only be used once.
07:27:02 <kuribas> ggVGc: ContT isn't that difficult... Think of it as a callback monad.
07:28:02 <ggVGc> kuribas: only reason I've stayed away so far is because I'm not comfortable with monad transformers in general
07:28:12 <ggVGc> or rather, I find it annoying to deal with them
07:28:14 <Boomerang> An example could be to have a state data type for a mealy machine or other where the state doesn't need to be an input or output to the function using it internally.
07:28:15 <ggVGc> and would rather not
07:28:42 <bash0r> Hi, when using Network.Socket, what's the recommended way to cleanup on a server socket (e.g. listening on port 3000)? Is Network.Socket.close enough?
07:28:57 <Boomerang> An other example would be to create a custom newtype along with a custom Monoid instance to use in a fold.
07:29:23 <kuribas> ggVGc: so instead of: withCallback $ \res -> handle_result, you write: res <- ContT withCallback; handle_result
07:29:43 <ggVGc> kuribas: yeah, but is that really giving me much?
07:29:48 <ggVGc> other than do notation
07:29:53 <ggVGc> which I don't care that much for anyway
07:29:54 <kuribas> ggVGc: not really.  Just nice syntax
07:30:02 <ggVGc> right, so that's why I haven't gone there
07:30:04 <Fuuzetsu> bash0r: open + close with bracket should do it
07:30:25 <kuribas> ggVGc: it looks sequential, that may be easier to understand than chaining callbacks.
07:31:12 <bash0r> Fuuzetsu: That's what I did. Though, when killing the server application (CTRL+C) the server fails to bind on the very same port for a few seconds. But it could be my OS-setup.
07:31:34 <Fuuzetsu> right, it's up to OS when it makes the port available again
07:31:59 <bash0r> Fuuzetsu: ahh, that explains a lot. Thank you very much.
07:32:49 <Fuuzetsu> https://stackoverflow.com/questions/22549044/why-is-port-not-immediately-released-after-the-socket-closes I think this is it in this case
07:33:22 <kuribas> ggVGc: something like reactive-banana may also be helpful to simplify complex interactions.
07:33:46 <Fuuzetsu> notably see SO_REUSEADDR, might want to do that if it works for your usecase
07:33:56 <Boomerang> Another idea for a proposal, which may be simpler to implement, is to have scoped imports. In a where/let clause you could import some other modules (qualified or explicit list as usual) that would only be accessible in the given scope. A use cases would be when you have to convert back and forth between lazy and strict module for ByteString, Text, Vector...
07:34:15 <barrucadu> Boomerang: I've occasionally wished for locally-scoped data types which are checked to not escape from their function
07:34:20 <Boomerang> Would either of these idea be of interest you you? :-)
07:34:39 <bash0r> Fuuzetsu: from the accepted answer I can see that this behavior is actually what I want.
07:35:00 <Fuuzetsu> great
07:35:16 <Boomerang> Both of these ideas would help with making it easier to manage accessible data structures/functions without the use of separate modules
07:35:26 <bash0r> I just was not aware of this behavior. ^^ Thank you very much for explaining.
07:35:44 <Boomerang> barrucadu: Do you have some examples of use cases where it would have been helpful for you?
07:35:50 <typetetris> Can somebody who used that stuff https://wiki.haskell.org/Scrap_your_boilerplate in projects comment on it a little bit? Maybe the style apps are written change and don't necessitate something like that any more?
07:36:20 <Fuuzetsu> Boomerang: any time you define a data structure for use with a fold that you only use in that one function is a pretty easy example
07:36:41 <barrucadu> Boomerang: I'll try to find something
07:37:04 <Fuuzetsu> the canonical one is ‘data P = P {-# UNPACK #-} !Int {-# UNPACK #-} !Double’ where you accumulate length and sum to ensure single traversal
07:37:53 <barrucadu> Boomerang: But the general pattern is I have some function with a recursive helper function in a `where`, which either has a lot of parameters or some complex return type which is immediately destructured.  So in the first case I just have a lot of parameters, in the second I end up with a big tuple
07:37:54 <Fuuzetsu> either that or you have to import something like the fold package
07:39:38 <Boomerang> We already have many Haskell extensions that go completely unused, so maybe the gains here wouldn't be enough to justify the efforts. Any example where it would be useful is helpful! :-)
07:39:56 <Boomerang> Yeah barrucadu that's the kind of example I had in mind
07:40:23 <Boomerang> With Clash, I use mealy machines all over the place and I wish I didn't have to expose my State to the rest of the module
07:40:34 <Fuuzetsu> Agda has these things and it's really helpful there, you can just define the exact types you need for that function instead of ‘error "impossible!"’; I think it's more of a "who's going to implement this"
07:41:51 <Boomerang> I've never touched GHC but wouldn't mind learning if I can get some help. Maybe the scoped import would be an easier first step, even if less useful
07:43:02 <Boomerang> With these two proposal ideas we're getting closer to nested modules.
07:43:19 <Boomerang> I'm not sure people would want that though
07:43:28 <Fuuzetsu> At this rate we'll have a real module system, god forbid
07:44:34 <Boomerang> Have there been discussion on forums/mailing list I could have a look at about this kind of discussion? Nested modules, scoped imports, data definitions?
07:45:02 <EvanR> backpack?
07:45:32 <Fuuzetsu> that's a different thing all together
07:46:55 <Boomerang> It wouldn't hurt for me to look more into backpack. I'm sure this kind of idea would have been discussed when creating backpack
07:49:15 <Boomerang> Thanks for your help! If you have any more ideas of use cases/difficulties I might have implementing this or making it work with other extensions please PM me about it or ping me here! :-)
07:50:44 <Fuuzetsu> I suspect step 1 would be to formulate what is it you're going to try to implement then write a proposal for it to get feedback and general approval
07:53:23 <Boomerang> I am reading the README for ghc-proposals on github. It seems like a pretty good process. How active is that repo usually?
07:55:26 <Fuuzetsu> It's active. There are some proposals that are stale usually because no real agreement was reached or the original proposer didn't follow up or the proposal has actually been implemented but discussion wasn't closed (backpack). I think they are planning to close inactive proposals.
07:55:36 <Fuuzetsu> You should have no problem if you submit one.
07:56:28 <ertes> kuribas: i'm not too worried about new haskell programmers
07:56:31 <Boomerang> Alright, I'll look at the examples and try to write up something convincing! Thanks :)
08:18:58 <bash0r> Is there something like `flip finally`?
08:19:22 <Rembane> :t flip finally
08:19:23 <lambdabot> IO b -> IO a -> IO a
08:19:32 <Fuuzetsu> usually you use finally infix
08:20:13 <bash0r> Using finally infix does not apply to my use case. That's why I'm asking for a more concise name rather than using `flip finally`.
08:20:16 <EvanR> finally' cleanUp $ do
08:20:40 <EvanR> or with block arguments
08:20:47 <EvanR> finally
08:20:49 <EvanR>   do ...
08:20:50 <EvanR>   do ...
08:21:19 <bash0r> Thanks!
08:21:23 <EvanR> haha
08:21:39 <EvanR> *feature may not yet exist
08:22:55 <bash0r> From what I've read ArgumentDo comes with GHC 8.6.1.
08:22:56 <Tuplanolla> That should parse with `ArgumentDo`.
08:23:08 <bash0r> For now I'll use flip finally. :/
08:23:41 <Boomerang> Would it work with '$' ?
08:23:44 <Boomerang> finally
08:23:46 <Boomerang>   $ do ...
08:23:49 <Fuuzetsu> you can do something similar without ArgumentDo
08:23:49 <Boomerang>   $ do ...
08:24:04 <Fuuzetsu> I forgot what exactly though
08:24:08 <cocreature> Boomerang: no that’s equivalent to finally (do … (do …))
08:24:09 <bash0r> Boomerang: ArgumentDo is intended to replace $.
08:24:31 <Boomerang> Oh yeah fair enough
08:25:00 <bash0r> Boomerang: I need the finally handler be the first argument as it's just Socket.close and the do-block is multi-line. :)
08:25:05 <asheshambasta> Hey guys, I've been considering Spock for the backend of a home security project I'm doing, but I get completely thrown off by the template-Haskell stuff: https://www.spock.li/tutorials/rest-api (see the Adding a Database section). Being new to Haskell, I'm inclined to ask –– can template-haskell be avoided at all?
08:25:58 <Fuuzetsu> it can always be avoided by writing the results of it in your module
08:26:10 <bash0r> asheshambasta: I'm not aware of the specific design of Spock. But in most cases you can avoid it entirely. It's a lot of boilerplate to get things running then.
08:27:04 <Fuuzetsu> I recommend you figure out how to use it, you'll likely want to sooner or later
08:27:08 <bash0r> asheshambasta: what exactly scares you about TH? Maybe we can clarify things so that you can avoid the boilerplate instead of TH. :)
08:28:16 <asheshambasta> to a beginner like me, who almost _wants_ to write code in understandable Haskell, it looks a bit like too much magic.
08:30:20 <Boomerang> I am guessing `flip finally` behaves differently to `(>>)`. This wouldn't work if an exception was raised, right?
08:30:37 <Fuuzetsu> they do different things
08:31:21 <Fuuzetsu> you should check the doc, no guesswork needed!
08:31:42 <bash0r> Boomerang: exactly. If there's a network exception of some kind or user interrupt then you are out of luck with (>>).
08:31:54 <Welkin> asheshambasta: template haskell isn't the best thing for a beginner to start with, but you can use it without understanding how it works
08:32:11 <Welkin> asheshambasta: I recommend not using any template-haskell libraries when starting out
08:32:23 <Welkin> instead, use something like postgresql-simple for your database queries
08:33:06 <bash0r> asheshambasta: I agree with Welkin in this point. In my first 6 months all I did in Haskell was reimplementing standard library functions to get a grasp of what the internals of Haskell are.
08:33:15 <asheshambasta> Welkin: I'm also instinctively inclined to avoid TH, it seems a bit like relinquishing control
08:33:15 <Fuuzetsu> he's going to have a harder time trying to use that with Spock than following the tutorial that tells you what TH to type in
08:33:43 <Welkin> Fuuzetsu: that is not the point
08:33:48 <Welkin> understanding is the point
08:33:58 <Welkin> copying and pasting is not understanding
08:34:06 <Welkin> I had a hell of a time because I started with yesod
08:34:10 <Welkin> I do not recommend it to anyone
08:34:26 <Welkin> avoid my mistake of using TH as a beginner
08:35:00 <kuribas> TH is good for avoiding builerplate
08:35:05 <Welkin> spock is also not the best web library to start with
08:35:08 <Welkin> I recommend scotty
08:35:21 <Welkin> you will learn a lot more about how it works
08:35:30 * jmcarthur wishes servant was a bit more beginner friendly
08:36:01 <asheshambasta> yeah, seeing TH in examples as a beginner isn't the most welcoming thing
08:36:26 <asheshambasta> you're asked to use a bunch of language extensions — and thats already a bit strange and magical
08:36:41 <Welkin> asheshambasta: https://hackage.haskell.org/package/scotty
08:36:48 <Fuuzetsu> at some point you have to stop writing things for beginners and write useful stuff :)
08:37:00 <Welkin> Fuuzetsu: you can't write anything advanced if you don't understand the basics
08:37:02 <jmcarthur> Well, you'll learn not to fear most language extensions eventually. I still prefer to avoid TH, specifically, when I can, though.
08:37:15 <asheshambasta> — and there are so many of these language extensions that its one of those things that distract you from not reading more about Haskell and learning, but learning about the workarounds
08:37:17 <jmcarthur> So in this case your inclination against it seems agreeable to me.
08:37:20 <Fuuzetsu> I was referring to the servant remark
08:37:38 <Welkin> I view it as a ladder that you climb
08:38:01 <Welkin> in regard to web libraries, it goes: wai/warp -> scotty -> servant
08:38:03 <Welkin> something like that
08:38:03 <jmcarthur> Fuuzetsu: Yeah. It's just kind of telling that I don't feel comfortable telling beginners to immediately start looking at the cool stuff.
08:38:27 <asheshambasta> yeah I did one project with Scotty already and that was a pleasant experience
08:39:10 <Fuuzetsu> incidentally the project I'm on where clients are complete Haskell beginners is using Spock because that's what the clients looked like and looked the easiest to them
08:39:18 <Welkin> try adding a databse layer and an auth layer to your scotty project
08:39:34 <Welkin> and try using lucid and clay
08:39:38 * Fuuzetsu wanted to use Warp and was told it's too low level for beginners
08:40:12 <Welkin> I prefer to start at the lowest level of abstraction
08:40:19 <Welkin> start with raw http and work your way up
08:40:52 <jmcarthur> Fuuzetsu: Huh. Warp seems about on par with plain CGI in terms of difficulty level, to me.
08:41:10 <asheshambasta> the thing I kind of struggled with Scotty was that I needed to pass around a lot of stuff — things like a rabbitmq connection, a db connection etc.
08:41:11 <bash0r> jmcarthur: servant uses too much type magic for beginners and that's the whole point of the library.
08:41:21 <jmcarthur> bash0r: Yes. That was my point.
08:41:30 <Fuuzetsu> dunno, I like it and didn't want to argue for no reason so we just used spock *shrug*
08:41:31 <Welkin> asheshambasta: did you not use ReaderT?
08:41:39 <asheshambasta> Welkin: no
08:41:40 <Fuuzetsu> s/and/but/
08:41:42 <bash0r> jmcarthur: ahh then nevermind. :)
08:41:44 <Welkin> asheshambasta: then that is the next step :)
08:41:53 <Welkin> ReaderT can store your configuration information
08:41:57 <Welkin> no need to pass it around anymore
08:42:09 <asheshambasta> I see
08:42:30 <asheshambasta> + reading list
08:42:32 <Fuuzetsu> but that quickly leads us to those scary monad transformer things
08:42:55 <asheshambasta> Fuuzetsu: monad transformers are ok-ish for me
08:43:05 <asheshambasta> (I'm coming from a Scala background)
08:43:23 <bash0r> asheshambasta: Does Scala actually use monad transformers?
08:43:25 <Fuuzetsu> I don't know scala so I can't comment on how well that translates
08:43:48 <asheshambasta> bash0r: not Scala's core libraries, but you do have suites like Cats and Scalaz
08:43:50 <Fuuzetsu> I'm surprised that you'd know about monad transformers and not ReaderT; maybe it's just called something else in scala
08:44:10 <Welkin> ReaderT is my most used transformer in web development
08:44:17 <bash0r> asheshambasta: Ahh, I never used those libraries in Scala. Most of the time it was simpler to roll things on my own.
08:44:17 <Welkin> I use it in every application
08:44:23 <asheshambasta> Fuuzetsu: well, I do know ReaderT — just haven't used it in Haskell yet
08:44:30 <Fuuzetsu> ah, alright
08:44:56 <asheshambasta> I've been bit by the Haskell bug
08:45:11 <asheshambasta> and now I want to convert all our production services to Haskell
08:45:18 <calloc> GHCi seems to be sensitive to declaration order when loading with :l. I haven't noticed this before, is this the case for anyone else?
08:45:56 <kuribas> asheshambasta: +1
08:46:00 <kuribas> asheshambasta: from which language?
08:46:09 <asheshambasta> kuribas: Scala
08:46:14 <bash0r> calloc: I never tried it. But it makes sense, IMHO.
08:46:25 <asheshambasta> (we use Scala for all our backend services at centralapp.com)
08:46:43 <bash0r> calloc: Maybe using cabal new-repl solves your issues.
08:46:49 <kuribas> asheshambasta: not such a big transition then :)
08:46:59 <Welkin> kuribas: don't be so sure
08:47:09 <Welkin> most people seem to use scala as a "fancy java"
08:47:15 <Welkin> and it is nothing like you would write in haskell
08:47:23 <kuribas> asheshambasta: you're in Belgium?
08:47:34 <asheshambasta> kuribas: yeah
08:47:43 <kuribas> asheshambasta: you don't need haskell programmers?
08:48:02 <asheshambasta> Welkin: well, that was the case with our services in the beginning, now they're written quite unlike in the Java style
08:48:08 <bash0r> asheshambasta: I'm up to apply for a position, too. :D
08:48:09 <calloc> bash0r: Haven't heard of it before. I'll check it out.
08:48:16 <asheshambasta> kuribas: are you in Belgium too?
08:48:23 <kuribas> asheshambasta: yeah :)
08:48:24 <bash0r> calloc: then look for "cabal new-build".
08:48:35 <cheers> what do y'all use for your haskell dev environments? i'm just getting into haskell, and i'm currently looking at nvim + ghc-mod + neco-ghc + neomake
08:48:44 <asheshambasta> We're planning to hire more backend engineers somewhere this year, actually
08:48:53 <kuribas> asheshambasta: Antwerp
08:49:01 <asheshambasta> kuribas: where in BE? Lets meet up for a beer?
08:49:02 <calloc> bash0r: Thanks!
08:49:05 <Fuuzetsu> I'm just using haskell-mode for syntax highlighting, nothing else really
08:49:09 <kuribas> asheshambasta: Antwerpen
08:49:13 <Fuuzetsu> recently added hlint into my setup
08:49:18 <kuribas> asheshambasta: sure :)
08:49:31 <bash0r> cheers: looks fine to me. I myself prefer a more tedious workflow using GHCi to lookup definitions and stuff. So it's emacs with syntax highlighting and multiple terminals with GHCi.
08:49:36 <asheshambasta> bash0r: you in BE too?
08:49:50 <cheers> ah, nice. thanks bash0r, Fuuzetsu
08:49:58 <bash0r> asheshambasta: no, germany. But I don't mind a relocation.
08:50:02 <Welkin> cheers: I use emacs with haskell-mode
08:50:04 <Welkin> nothing fancy
08:50:42 <cheers> neat, thanks (:
08:52:07 <Welkin> cheers: you could also look at emacs with evil-mode if you want emacs bindings, or even spacemacs
08:52:16 <Welkin> er
08:52:19 <Welkin> if you want vim bindings
08:53:03 <Welkin> bash0r: you just want to get away from angela merkel?
08:53:36 <bash0r> Welkin: and AfD and all the other stupid people in Germany. It gets worse every day.
08:54:46 <bash0r> Welkin: the biggest plus would be programming in Haskell, anyway. My last position in a Java shop where I wasn't even allowed to use CPS with lambdas for flow control was... I guess you get the point.
08:55:19 <EvanR> i agree with that
08:55:30 <EvanR> dont use CPS with lambdas for flow control in java
08:55:35 <Welkin> is the pay for engineers poor all over europe?
08:55:39 <Welkin> or just in the UK?
08:55:43 <bash0r> EvanR: why?
08:55:45 <Fuuzetsu> define poor
08:55:53 <EvanR> because thats crazy
08:56:00 <Fuuzetsu> and in UK it depends if you mean London or not-London
08:56:08 <Welkin> meaning less than half of equivalent engineer's income in the US
08:56:10 <Digit> yeah, cost of living n such
08:56:17 <Welkin> adjusted for cost of living even
08:56:44 <Fuuzetsu> dunno, I know bunch of Haskell people on like 100k USD a year
08:56:48 <Fuuzetsu> in UK
08:56:55 <Welkin> in london?
08:57:00 <Guest14885> is there a reverse pattern syntax so you can wrap a pattern?
08:57:01 <Fuuzetsu> yeah
08:57:02 <bash0r> It wasn't crazy in that point. The imperative solution of the company was crazy. Forget to tell selenium to go back from where you came and the whole test case crashed. You were looking for the error like halve an hour... Every time...
08:57:20 <cocreature> Guest14885: I’m not sure I understand your question but maybe you’re looking for PatternSynonyms?
08:57:44 <bash0r> Fuuzetsu: at Berkleyes for sure.
08:57:52 <Fuuzetsu> nope
08:58:00 <Welkin> oh, at an investment bank it should be $250k minimum
08:58:00 <Fuuzetsu> there aren't many Haskell people left there at all
08:58:35 <bash0r> Haha and our universities train people to program in Java. Well done, industry.
08:58:56 <Fuuzetsu> Most universities do because that's where the biggest market still is
08:59:05 <Guest14885> cocreature: i mean, so you can wrap a function argument in say a list; like a pattern syntax that allows you to build upon a paramter
08:59:19 <EvanR> money oriented programming
08:59:24 <Fuuzetsu> if anything you're probably more likely to get well-paid Java job than well-paid Haskell job
08:59:55 <Guest14885> first time i've seen people talking about money in here, has #haskell changed?
08:59:57 <bash0r> I guess that will never change. OO languages are prone of "we model the world as objects. Object instances somewhat resemble an object from the real world, blah blah."
09:00:09 <cocreature> Guest14885: sry I still don’t get it, can you provide an example?
09:00:11 <Welkin> Guest14885: it's about career opportunities, not money
09:00:27 <bash0r> I wouldn't say it's money oriented. It makes people more likely to be replaceable.
09:00:41 <EvanR> that is the OO narrative, and when it doesnt really apply (a lot of times) we learn to ignore it
09:00:54 <EvanR> it was just a intuitive model anyway
09:01:04 <bash0r> ClosureManagerFactoryManagerFactory
09:01:41 <bash0r> ExceptionHandlerFactoryManager
09:02:36 <maerwald> you can write bad haskell code too
09:02:41 <Welkin> sure
09:02:43 <Guest14885> cocreature: (\((+1) a) -> a) :: Int -> Int     sorry it's not clear, i may be imaginig it but I thought there was a way to maniupate a function paramter
09:02:46 <Welkin> I have seen a lot of it on rosetta code
09:02:51 <Welkin> direct translations from c++
09:03:03 <cocreature> Guest14885: oh I think you are looking for ViewPatterns
09:03:21 <Fuuzetsu> direct translation doesn't necessarily mean bad if there's the One Obvious Fast Way To Do It
09:03:25 <cocreature> > let f ((+1) -> a) = a in f 1
09:03:27 <lambdabot>  2
09:03:28 <maerwald> bash0r: and not every OO people have that understanding of OO
09:03:31 <cocreature> ^ Guest14885
09:03:38 <Welkin> Guest14885: that is just a syntactic sugar for case expressions
09:03:42 <maerwald> some are actually pro immutability (after object creation)
09:03:45 <cocreature> Guest14885: although PatternSynonyms are definitely worth a look as well
09:04:08 <Welkin> I find ViewPatterns useful with Data.Sequence
09:04:16 <Welkin> I haven't used it anywhere else though
09:04:38 <cocreature> iirc Data.Sequence also provides pattern synonyms in newer versions
09:06:15 <cocreature> which among other advantages such as nicer syntax also give you exhaustiveness checking
09:08:48 <Boomerang> Oh lambdabot has ViewPatterns enabled? They're pretty cool but it starts looking really weird if you mix it with other extensions like PatternGuards (I believe that's in GHC by default now, no).
09:08:58 <Boomerang> > case () of () | (id -> ()) <- () -> 2
09:09:00 <lambdabot>  2
09:09:17 <bash0r> maerwald: of course you can write bad code in Haskell, too. But Java proposes a lot of bad patterns due to incompetence of most Java developers. Look at the most snippets flying around in the web. If you learn from those snippets you are prone to write bad code yourself.
09:09:43 <maerwald> bash0r: http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html as an example
09:09:44 <maerwald> there are more
09:10:00 <Welkin> bash0r: they are called "design patterns" and they are the gospel
09:10:02 <maerwald> I'm not convinced the number of bad developers in java is higher, it's just more developers overall
09:10:08 <maerwald> so you obviously see more "bad code"
09:12:35 <bash0r> maerwald: I don't say that every Java programmer is bad. In past I've seen many good code snippets. But vast majority will always stay on a level where they don't understand what they're actually doing.
09:12:51 <maerwald> I think that is true for pretty much all languages
09:13:01 <bash0r> Welkin: I'm not against design patterns if you don't abuse them.
09:13:28 <Welkin> bash0r: It was a joke
09:13:30 <Guest14885> cocreature: thanks!
09:13:40 <bash0r> Welkin: oh gosh and I didn't get it. >.>
09:14:13 <bash0r> maerwald: But some languages make it harder for people that don't understand what they're doing to get something running.
09:14:27 <maerwald> bash0r: how so?
09:14:33 <maerwald> this has nothing to do with type safety
09:16:03 <maerwald> type FilePath = String -- <- someone clearly did not understand what a filepath is when that was written :> and we still suffer from the consequences. The language didn't help there
09:16:20 <bash0r> It has to do with type safety. When passing a number to a function that accepts a function it just runs fine in JavaScript as long as this specific code branch is not hit. Your app seems to run fine. In Haskell it complains.
09:16:24 <maerwald> no
09:16:29 <maerwald> Java is typesafe
09:16:33 <maerwald> and see the example above
09:16:41 <Fuuzetsu> maerwald: String -- <- same thing ;^)
09:16:45 <bash0r> Letting a FilePath be a String looks like dynamically typed FilePath to me.
09:16:50 <glguy> maerwald: They fixed the type unsafety published about last year?
09:17:01 <glguy> it stems from the ? types
09:17:14 <maerwald> bash0r: what?
09:17:52 <maerwald> you cannot remove bad design or someone not understanding low-level details just by type safety
09:18:10 <maerwald> the language is orthogonal to that problem
09:18:18 <maerwald> that problem is about education in general
09:18:33 <glguy> maerwald: did you know about: http://io.livecode.ch/learn/namin/unsound ?
09:19:38 <bash0r> maerwald: okay, I get your point.
09:19:49 <maerwald> glguy: no, but looks like that blog post that proves haskell (GHC) is dynamically typed
09:19:57 <maerwald> let me get the link
09:20:16 <glguy> maerwald: No, this one shows how Java's treatment of the ? in generics is unsound
09:20:31 <glguy> It's not like that one about how you could make your own instance of Typeable
09:20:44 <tsahyt> does anyone know what the status of -XLinearTypes is? iirc they wanted it in GHC by either 8.4 or 8.6
09:21:05 <tsahyt> the reason I'm asking is because I stumbled across the idea of session types and linearity would help greatly with that
09:21:21 <Fuuzetsu> tsahyt: I would ask the main author but he just went on week long holiday on Friday :)
09:21:55 <cocreature> tsahyt: there is an open ghc-proposal that has not yet been accepted so at best we’re going to get it in 8.6
09:22:17 <tsahyt> ah, okay. I'll just put that idea on standby until then
09:22:44 <maerwald> glguy: I mean this https://aphyr.com/posts/342-typing-the-technical-interview
09:23:42 <glguy> maerwald: No, this paper isn't like that, this shows the unsoundness that comes from asumptions that ? is always inhabited that can be exploited depending on different Java compiler implementations and the nondeterimistic choices their generics solvers use
09:24:17 <maerwald> I still only see very little connection to the discussion
09:24:32 <glguy> You said Java was typesafe
09:24:42 <glguy> that's the only connection :)
09:24:58 <maerwald> I'll send that to my coworker who is a Scala fanboy xD
09:25:04 * maerwald is evil
09:36:26 <bash0r> glguy: awesome read!
09:44:00 <Welkin> lol that blog post
09:48:53 <bash0r> Looks somewhat similar to what I did at the Java shop. :D
09:51:06 <bontaq``> <3 that blog post.  he has really good articles on tearing apart DBs as well
09:59:56 <MacSlow> greetings folks
10:00:06 <Fuuzetsu> salutations
10:00:39 <MacSlow> What am I missing in line 11 syntax-wise here https://paste.ubuntu.com/p/w8wjHtSZxy/
10:01:27 <MacSlow> I've tried everything I can think of, but nothing I tried was accepted by GHCi
10:01:37 <Fuuzetsu> perhaps it doesn't like that you're naming the variable in both patterns ‘x’
10:02:25 <Tuplanolla> Is there a function of type `Rational -> Maybe String` that produces a decimal expansion only if it is terminating?
10:02:25 <MacSlow> sure... but how else would I cover the case of Just' a == Just' b = True ?
10:02:26 <glguy> MacSlow: When you don't understand an error message you should include it in your paste
10:02:54 <MacSlow> glguy: yeah... my bad... was lazy *cough* :)
10:03:05 <Fuuzetsu> MacSlow: https://paste.ubuntu.com/p/KSx5FJSntP/
10:03:48 <Fuuzetsu> MacSlow: ‘Just' a == Just' b = a == b’
10:04:52 <Fuuzetsu> You already have a case for both Just' though. Just becauase you gave the elements different names doesn't mean they are not the same. ‘Just' x == Just' y = False’ seems incorrect :)
10:04:59 * MacSlow goes in the corner and hits himself with a pointy stick
10:05:40 <MacSlow> pretend I never asked...
10:05:47 <MacSlow> ... *sigh*
10:06:26 <Fuuzetsu> Better to ask than to waste 30 minutes
10:07:29 <MacSlow> Fuuzetsu: well yes and no ... one has at least try to come up with a solution
10:08:11 <Fuuzetsu> Sure. I meant that it's pointless to stare at syntax error for a long time when you just can't see it
10:08:27 <Fuuzetsu> anyway the error message should have tipped you off
10:08:28 <MacSlow> but atm I still feel struggling with the difference of Haskell's syntax ... years of C++ vs days of Haskell
10:09:05 <MacSlow> some bits I pick up easily... others not so much
10:11:06 <monochrom> Actually years of C++ trains you to become petrified at error messages.
10:11:46 <MacSlow> monochrom: hm... clang++ does a good jobs mostof the time
10:11:48 <monochrom> (Well, unless it's years of C++ before templates came into being.)
10:12:46 <MacSlow> anyway thanks sofar
10:12:53 <Fuuzetsu> just write it right the first time, what's the problem ;^)
10:13:08 <Fuuzetsu> no problem
10:13:13 <MacSlow> Fuuzetsu: +1
10:24:53 <MacSlow> is it possible to "unload" definitions from the prelude within GCHi?
10:25:28 <MacSlow> say I don't want the one from GHC.Classes to be available
10:25:29 <Fuuzetsu> try :m - Prelude
10:25:54 <Fuuzetsu> perhaps you want -XNoImplicitPrelude extension
10:26:25 <alexteves> I'm getting a weird error from runghc in a nix-shell under os x (it works in nixos).
10:26:26 <alexteves> $ runghc Main.hs
10:26:27 <alexteves> runghc: ramework-path/nix/store/ws9cfrjf7nry1hy1p7612qvdqi87qjwb-apple-framework-PCSC/Library/Frameworks: executeFile: does not exist (No such file or directory)
10:26:27 <alexteves> "runghc —help" works as expected
10:26:29 <alexteves> I’m guessing the -framework-path option somewhere is being processed wrong (maybe it’s parsed as -f ramework-path). Any ideas?
10:26:56 <MacSlow> Fuuzetsu: as parameter when starting GCHi?!
10:27:12 <Fuuzetsu> alexteves: you may have better luck in nix channels, #nixos on #nix-darwin (or whatever that OSX one was)
10:27:36 <Fuuzetsu> MacSlow: you could put it in your module as a LANGUAGE pragma. I think you can pass it on command line too though.
10:27:50 <alexteves> Yeah, though I'd ask here in case it was some known runghc issue even outside of nix
10:28:11 <Fuuzetsu> ‘ghci -XNoImplicitPrelude’ works
10:28:13 <alexteves> *thought*
10:29:06 <MacSlow> Fuuzetsu: already tried on the command line... that a bit too drastic in effect :)
10:29:19 <MacSlow> Fuuzetsu: I'll try it in the source-file
10:29:57 <Fuuzetsu> you can still import things from Prelude explicitly when you use it
10:30:33 <Fuuzetsu> ‘import Prelude hiding (Eq(..))’
10:35:25 <MacSlow> Fuuzetsu: that hiding addition removes the whole Eq... could I just hide a single instance of Eq with that directive too?
10:35:55 <Fuuzetsu> you can't hide instances
10:36:07 <Fuuzetsu> use a newtype to wrap the type you're interested it and give it your own instance
11:01:50 <erisco> in natural deduction, how do variables bind across antecedents? say you want to write the rule to introduce a pair of same-typed elements
11:13:36 <EvanR> x,y : A ...
11:13:49 <EvanR> x:A y:A ...
11:14:27 <donotturnoff> Is Learn You A Haskell for Greater Good the best guide for a beginner?
11:14:53 <[exa]> donotturnoff: certainly not if you're a beginning programmer, but very nice if you already know some programming
11:14:59 <Fuuzetsu> Don't know about the best but it's _a_ guide
11:15:16 <Fuuzetsu> I think it's a bit out of date these days
11:15:29 * EvanR tells donotturnoff about "A gentle introduction to Haskell"
11:15:39 <donotturnoff> I'm pretty experienced in other languages, but I've never done anything functional really
11:15:49 <donotturnoff> Thanks, I'll have a look
11:17:55 <erisco> EvanR, okay but the pair is to be polymorphic, so where does A come from? from context I would think
11:19:21 <EvanR> you can say
11:19:24 <erisco> EvanR, so I think to say  Γ, a : Type ⊢ x : a   Γ, a : Type ⊢ y : a   ---   Γ, a:Type ⊢ Pair x y : Pair a
11:19:27 <EvanR> A:Type x:A y:A
11:19:47 <erisco> but then, that also looks wrong because these are different a's, potentially, on top
11:19:59 <EvanR> it is wrong
11:20:21 <erisco> yeah so I don't get how to scope the same type across two values
11:20:25 <EvanR> your gammas here arent doing anything because youre not changing anything
11:20:40 <EvanR> like i just said
11:21:13 <erisco> EvanR, probably half the inference rules I read use Γ ⊢ explicitly whether context changes or not
11:21:52 <EvanR> for this case, you can just put one gamma at the beginning
11:22:11 <erisco> Γ ⊢ A : Type   Γ ⊢ x : A   Γ ⊢ y : A   ---   Γ ⊢ Pair x y : Pair A   ?
11:22:39 <EvanR> given some context (which doesnt really matter or do anything), if A is a type, x is an A, and y is an A, then (x,y) is a Pair A
11:22:43 <parsnip> donotturnoff: i think of LYAH as a fun book to skim through, and a good first book, to get a general sense of the language, but for example, it lacks exercises.
11:23:10 <EvanR> in that context
11:23:31 <EvanR> Pair x y : Pair A is odd because its two different "Pair"
11:23:35 <EvanR> but the same symbol
11:23:39 <erisco> ---   Γ, A : Type, x : A, y : A ⊢ Pair x y : Pair A   ?
11:23:56 <EvanR> , is adding to a context
11:24:19 <donotturnoff> Ok, I'll have a look around a bit more for other things then, thanks
11:24:41 <donotturnoff> I'd seen it mentioned quite a lot so I wondered how good it was
11:24:47 <erisco> EvanR, I guess? I thought of it as destructuring the context
11:25:00 <erisco> EvanR, so Γ just stands for "the rest"
11:25:04 <EvanR> but theres no reason to do that
11:25:19 <erisco> okay, you write out the inference rule
11:25:35 <EvanR> for this...
11:26:05 <EvanR> A:Type  x:A   y:A   |   (x,y) : Pair A
11:27:24 <erisco> it seems weird for  A  to be in scope for  x:A  and  y:A
11:27:29 <EvanR> its not weird
11:27:41 <EvanR> you introduced it earlier, left to right
11:27:50 <EvanR> if youre worried about recursion
11:27:51 <erisco> order shouldn't matter should it
11:28:04 <erisco> those are three separate derivations
11:28:13 <EvanR> unless youre trying to do recursion, you cant refer to stuff that hasnt been introduced yet
11:28:38 <EvanR> even then, its tricky, so dont
11:28:51 <Tuplanolla> Also note that Γ, A : Type and A : Type, Γ are different, erisco.
11:28:51 <EvanR> called predicativity
11:29:12 <erisco> Tuplanolla, really? when does context order matter?
11:29:38 <erisco> this is probably made more confusing for me because I see examples using the same notation across different theories
11:29:54 <Tuplanolla> The type of Type is in Γ and has to come first.
11:30:24 <erisco> I guess it depends on how contexts are constructed… theory dependent…
11:30:31 <EvanR> order definitely matters a priori
11:30:40 <EvanR> later you can come up with rules to make order not matter
11:31:05 <EvanR> with swap rules
11:31:10 <erisco> I think there is a hair to split on that one but nah
11:31:19 <EvanR> which are often not shown because they are so tedious
11:31:41 <EvanR> just like (x,y) and (y,x) are different, until they arent
11:32:08 <erisco> I have not seen antecedent construction rules before though, afaik, and never heard of their order mattering
11:32:32 <EvanR> you have surely seen them refer to each other
11:32:37 <EvanR> within the same top half
11:32:40 <erisco> all I know is that they should be independent derivations… hence also my intuition going haywire at having variables cross them
11:32:51 * erisco *shrugs*
11:32:52 <erisco> examples welcomed
11:33:24 <Tuplanolla> What are you reading?
11:33:38 <erisco> to have variables go across them would seem like a meta-inference
11:34:20 <EvanR> https://i.imgur.com/NgxBCgi.png
11:34:37 <EvanR> variables exist so you can use them for reference
11:34:45 <erisco> Tuplanolla, nothing in particular right now… just having to think precisely about something and trying to draw on misrememberings of stuff I read months ago
11:35:36 <erisco> hrm… okay… so I guess to me that looks like a meta inference rule
11:35:50 <EvanR> what makes it meta
11:35:56 <EvanR> more so than normal
11:36:51 <Tuplanolla> In the hott book they explain why the metatheory admits decidable propositions, equality and contextual ordering.
11:36:59 <erisco> maybe it doesn't have to be
11:37:33 <Tuplanolla> The metatheory referring to the way you wrangle the symbols in your rules.
11:37:43 <erisco> yeah I guess you don't have to go a level higher to make this work
11:38:22 <akshayn> J
11:38:36 <erisco> well I was seeing the context like a binder, right, so the question is where these variables are bound which are not in a context
11:39:14 <EvanR> theres seems to be two kinds of variables
11:39:27 <erisco> but you don't have to add another meta layer to just say that variables not bound in a context are instead bound by the inference rule
11:39:27 <EvanR> the ones in the context and the metavariables
11:39:36 <erisco> it is just two different kinds of variables as you say
11:40:54 <erisco> thanks for the help
11:40:57 <EvanR> so in x:A y:A | (x,y):A    x and y could be anything that has type A
11:41:18 <erisco> why are you adamant about not mentioning Γ ⊢ though EvanR? just for brevity?
11:41:53 <EvanR> laziness i guess
11:42:00 <erisco> supposing our theory actually has holes
11:43:01 <EvanR> and A is anything that is a type, but x y and A maybe not actually be in the context
11:43:06 <EvanR> literally
11:43:16 <EvanR> called x y and A
11:43:33 <EvanR> so its metavariables
11:43:42 <erisco> yes that is right
11:44:05 <erisco> I am saying the context is Γ i.e. "anything" for everything here
11:46:35 <EvanR> "anything that is judged such and such (has such a type) using Γ"
11:46:49 <EvanR> "and other rules"
11:48:19 <EvanR> i saw a paper recently that called all this "proof rules", which felt a bit like fresh air. since a lot of background terminology is usually skipped
11:48:43 <EvanR> inference rules sounds like... youre going to be doing inference
11:48:56 <EvanR> and deduction sounds like youre going to be deducing
11:49:18 <EvanR> whereas a pile of rules as-applied is really a derivation
11:49:31 <erisco> proof rules sounds like you're going to be proofing?
11:49:43 <EvanR> proving, yes which we will be!
11:51:00 <EvanR> inference and deduction sounds kind like, this is sherlock holmes and half way through the process we kind of dont know whats going on
11:52:19 <EvanR> but formalizing your proof, you are really gold plating a completed proof or verifying that all your steps are formally valid, the discovery process is really over with
12:00:07 <silverjam> Anyone else have issues with Emacs (spacemacs) with haskell-mode/intero randomly freezing?
12:08:05 <Squarism> anyone know of some library that does deep nested datastructure comparisons that results in some list of "paths" to non equal subtrees?
12:09:41 <Fuuzetsu> https://hackage.haskell.org/package/tree-diff , scroll down for example usage in test-suites
12:09:44 <dmwit> tree-diff, gdiff
12:11:17 <Squarism> Fuuzetsu, dmwit - thanks!
12:22:46 <Tuplanolla> Given `f = runParser (scientific <* unit) "<interactive>"`, running `f "42.13cm"` produces the expected result, but `f "42.13em"` fails due to `scientific` not restoring backtracking state after attempting to read `"42.13e+0"`.
12:22:54 <Tuplanolla> Is this my fault or a bug `scientific`?
12:24:20 <EvanR> wow thats tricky
12:24:57 <hpc> what unit is em?
12:25:02 <metahumor> i'd called that undefined behavior
12:25:11 <Tuplanolla> Typographic m-width, hpc.
12:25:15 <hpc> ah
12:25:40 <jmcarthur> I'm looking for recommendations for libraries for defining/using message-passing/rpc network protocols, something that helps with defining clients and servers without making me worry too much about what's actually sent on the wire.
12:26:24 <maerwald> there is a gRPC library actually https://github.com/awakesecurity/gRPC-haskell
12:27:28 <jmcarthur> To be honest, I don't know what grpc is. Looking at it now.
12:27:33 <maerwald> :o
12:36:29 <plakband> I had a discussion here yesterday about parsing and streaming a large (many times RAM capacity) dataset using constant memory. Someone recommended conduit + attoparsec, which mostly seems to do what I need, but I encountered the following warning in the docs:
12:36:47 <plakband> Note: incremental input does not imply that attoparsec will release portions of its internal state for garbage collection as it proceeds. Its internal representation is equivalent to a single ByteString: if you feed incremental input to a parser, it will require memory proportional to the amount of input you supply. (This is necessary to support arbitrary backtracking.)
12:36:47 <m1n> today I leared the hard way not to index an infinite list that contains computations with a very, very large number, as haskell will tie up all of the resources—so much so that you won't even be able to move your mouse
12:37:03 <plakband> Does this not exclude attoparsec from my use case?
12:37:12 <[exa]> m1n: you can setup your OOM killer to act quicker
12:37:35 <[exa]> m1n: btw that is sadly a very common OOM response of most unixes
12:37:42 <EvanR> plakband: sort of. you cant process it all in one attoparsec pass because of that warning
12:38:02 <EvanR> but you can use it to parse a chunk, end parsing, and begin where the previous pass left off
12:38:11 <m1n> [exa]: OOM … OOK … iiinteresting
12:38:31 <EvanR> this also has the advantage of letting you potentially skip a section that is malformed, if you can detect where to begin parsing again
12:39:32 <EvanR> but this pattern doesnt have direct support from the lib
12:42:11 <metahumor> m1n: are you using "iterate"?
12:42:13 <Fuuzetsu> various streaming libs (streaming, conduit) let you do this easily
12:42:41 <plakband> EvanR: That's precisely the sort of thing that I need to do, is there a more idiomatic way in your opinion?
12:42:50 <EvanR> not that i know of
12:42:53 <m1n> metahumor: nope just addition.
12:42:54 <Fuuzetsu> https://hackage.haskell.org/package/streaming-utils-0.1.4.7/docs/Data-Attoparsec-ByteString-Streaming.html &c.
12:43:17 <m1n> metahumor: fib = 1 : 1 : [a + b | (a, b) <- zip fib(tail fib)]   …   fib !! 9999999
12:43:22 <m1n> ^ do NOT do pls
12:43:23 <metahumor> m1n: make sure you're strict where you need to be
12:44:59 <parsnip> is it common to have many Text modules imported? like Data.Text, Data.Text.Internal.Lazy, Data.Text.Lazy.IO
12:45:03 <monochrom> I don't think it's as simple as "don't do this".
12:45:15 <siiky> hey everyone! does Data.Set save the elements or does it use hashing? if i dont need to know what the elements are (only if they exist or not) is this the best option?
12:45:27 <Fuuzetsu> parsnip: yes if you need them, there's nothing wrong with it
12:45:44 <siiky> im asking because im workig with Strings and i dont really need them
12:45:45 <metahumor> > let fibs = 0 : 1 : scanl1 (+) fibs in length (show (fibs !! 99999))
12:45:46 <EvanR> Data.Set saves the elements
12:45:48 <lambdabot>  20898
12:46:04 <EvanR> to make a set of Strings, use HashMap instead
12:46:04 <plakband> EvanR: alright, thanks, I'll give that a shot then
12:46:12 <parsnip> okay. so other imports are using these different Text, and i just have to orchestrate and know best way to combine.
12:46:15 <EvanR> or HashSet
12:46:28 <metahumor> parsnip: you can even mask them under the same qualified name
12:46:39 <Fuuzetsu> HashSet also saves elements
12:46:41 <parsnip> ???
12:46:45 <EvanR> no
12:46:46 <Fuuzetsu> it just indexes them by hash
12:46:51 <EvanR> er
12:47:07 <monochrom> parsnip: This: http://www.vex.net/~trebla/haskell/module.xhtml#import-as
12:47:07 <parsnip> metahumor: couldn't that create conflicts in names
12:47:29 <EvanR> ... what is HashSet even doing in HashMap's package
12:47:54 <EvanR> wait, what happened to the hashmapped vector tries implementation of HashMap
12:48:16 <m1n> monochrom: I mean … if you want to go for it; what I am saying, naturally, is that you should not do that unless you want all of the resources on your computer tied up
12:48:17 <parsnip> metahumor: i guess i'd just have to check first if i'm using a name defined in each import.
12:48:52 <metahumor> parsnip: it wouldn't until you used a name that is conflicting
12:49:08 <parsnip> interesting, thanks!
12:49:31 <monochrom> m1n, I have resource in mind, too.
12:49:34 <siiky> EvanR: Fuuzetsu: thanks! to make it clear, since HashSet indexes by hash, its faster than Set and HashMap right?
12:49:44 <EvanR> if the hash is easy to compute
12:49:45 <Fuuzetsu> Not necessarily
12:49:57 <EvanR> like Int
12:49:57 <Fuuzetsu> for your usecase I would just use ‘IntSet’ and insert the hashes myself
12:50:02 <amalloy> EvanR: const 0 is easy to compute
12:50:15 <monochrom> This uses log space only: print (let fib = 1 : 1 : [a + b | (a, b) <- zip fib(tail fib)] in fib).  Try it.
12:50:21 <EvanR> in which case its id, which is even faster than const 0 !
12:51:00 <amalloy> id is a decent hash function, though. my point was that "easy to compute" is not a sufficient condition for being a good hash function
12:51:06 * siiky is looking at IntSet
12:51:59 <EvanR> fair
12:54:11 <Fuuzetsu> EvanR: ‘const 0’ is probably faster, what if your Int is expensive to compute
12:54:29 <Fuuzetsu> you even get rid of retainer!
12:54:38 <EvanR> what if 0 is expensive to compute
12:54:45 <monochrom> I think in most applications the Int has to be computed whether you hash it or not.
12:54:45 <Fuuzetsu> it's free
12:55:10 <hpc> EvanR: just use an integer cache
12:55:21 <hpc> all the cool languages are doing it
12:55:29 <EvanR> good idea
12:55:50 <monochrom> Does the integer cache use a hash table?
12:57:48 <hpc> speculative integers
13:01:39 <EvanR> fork the computation into 2^64 possible answers
13:06:37 <sim590> I want to trim all trailing white spaces of a file. For this I have tried http://paste.debian.net/1011963/, but indeed I feed functions in the wrong order or wrong syntax... I don't understand how to do it.
13:08:24 <monochrom> unlines . map trimTrailing . lines
13:08:38 <Fuuzetsu> sim590: GHC tells what's wrong:  ‘unlines’ is applied to too many arguments
13:08:43 <Fuuzetsu> tells you*
13:09:09 <sim590> The thing is that it's not clear what the arguments are.
13:09:54 <monochrom> You have f (g . h), but the right thing to do here is f . g . h
13:14:28 <sim590> Let's say I go in ghci and do 'let f = ["some string with trailing spaces     "]' and that I do unlines . map trimTrailing . f, it gives me an error...
13:15:32 <Fuuzetsu> and why would it not? you're trying to compose ‘map trimTrailing’ with ‘f’, your types don't line up
13:15:51 <Fuuzetsu> you want to apply it to f, not compose it
13:16:13 <EvanR> maybe less confusing to not call it f
13:16:22 <EvanR> since its not a function
13:17:05 <sim590> it's a file
13:17:08 <sim590> That's what I meant.
13:17:11 <EvanR> its a list
13:17:24 <EvanR> in any case, . takes two functions
13:36:36 <parsnip> so these are idiomatic imports? http://lpaste.net/362895
13:37:51 <metahumor> i think your Text types will collide
13:38:49 <metahumor> nm, you'll only access them using T.Text and TL.Text
13:39:02 <Fuuzetsu> those look fine
13:39:24 <metahumor> i've seen people doing "import Data.Text (Text); import qualified Data.Text as T; ..."
13:39:31 <Fuuzetsu> minus the questionable stylish haskell indentation
13:39:48 <Fuuzetsu> that's useful if you use the type a lot in the module
13:39:50 <Tuplanolla> I really don't like single-letter imports.
13:40:03 <Fuuzetsu> beats typing Text.Text everywhere
13:41:12 <Fuuzetsu> you could do the other extreme and define everything as ‘T’, one per module and import qualified then use Module.T
13:41:16 <parsnip> i'm new to all these `Text`s, so explicit is helpful.
13:41:58 <parsnip> Fuuzetsu: oh, the very long name?
13:42:16 <parsnip> like, Data.Text.Internal.Lazy.Text ?
13:42:30 <Fuuzetsu> no, just the last bit usually; but ignore that, that was aimed at Tuplanolla
13:42:36 <Fuuzetsu> it's not really a thing many people do
13:42:51 <kadoban> I would imagine that that Text is also exported by a non- Internal module
13:43:13 <Fuuzetsu> Data.Text.Lazy
13:43:15 <parsnip> yep, tried it, still compiles
13:43:45 <Fuuzetsu> in general .Internal modules are no-guarantees-I-know-what-I'm-doing
13:45:40 <`Guest00000> -- TODO: can madly optimize this
13:46:26 <Fuuzetsu> a comment on ‘main’ surely
13:49:07 <`Guest00000> meaning: this is madly inefficient, can optimize
13:59:24 <`Guest00000> -- TODO: don't optimize this
14:00:46 <`Guest00000> well, that isn't todo
14:00:54 <`Guest00000> s/TODO: //
14:01:11 <Fuuzetsu> TODONE
14:01:41 <metahumor> is there any way to combine record-access syntax of
14:02:03 <metahumor> "Newtype {field1 = 0, field2 = "str"}" with applicatives?
14:02:24 <metahumor> or do i just have to do <$> <*> ... in the order of the fields
14:02:47 <Fuuzetsu> You could use ApplicativeDo extension I think
14:02:59 <Fuuzetsu> then write it as if it was monadic
14:05:21 <`Guest00000> metahumor: try lambdas, like (\field1 field2 -> Newtype { field1 = field1, field2 = field2 }) <$> 0 <*> "str"
14:06:03 <metahumor> eh that comes out to be the same in the end, because the lamdba args have to be in the right order
14:06:13 <Fuuzetsu> Seems you can't use ApplicativeDo if you don't have Monad even if you use it applicative-ly
14:06:18 <Fuuzetsu> we need banana brackets
14:06:30 <`Guest00000> but they're local to the application
14:07:30 <`Guest00000> application of arguments stays closer to where the order is defined, that's better to oversee
14:08:03 <`Guest00000> as opposed to field order in the constructor, which can just centrally change, requiring rewrites everywhere
14:10:02 <lyxia> metahumor: do field1 <- pure 0 ; field2 <- pure "str" ; return Newtype{..}  --  ApplicativeDo+RecordWildCards
14:10:32 <metahumor> much ado about nothing
14:10:36 <metahumor> =)))
14:11:11 <Fuuzetsu> lyxia: doesn't work without Monad
14:11:16 <Fuuzetsu> at least that I tried just now
14:11:29 <`Guest00000> Fuuzetsu: :set -XApplicativeDo
14:11:32 <MarcelineVQ> it's specifically for working without Monad
14:11:33 <nordmeister> can someone help me with this situation? https://pastebin.com/nyVErZ6c
14:11:47 <Fuuzetsu> I did
14:12:24 <Fuuzetsu> http://lpaste.net/362896
14:12:41 <Fuuzetsu> oh nvm I think I'm dumb
14:13:03 <MarcelineVQ> it has specific syntax https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#applicative-do-notation
14:13:18 <MarcelineVQ> importantly at the line "Note: the final statement must match one of these patterns exactly:"
14:13:20 <Fuuzetsu> or maybe not
14:13:26 * Fuuzetsu looks
14:14:15 <lyxia> Fuuzetsu: return T{ ... }
14:15:14 <Fuuzetsu> the types don't line up if you do that because then you have m (T …), not T …
14:16:17 <lyxia> then I don't understand what you're trying to do...
14:16:32 <Fuuzetsu> Nothing, just igngore me
14:29:02 <`Guest00000> in the situation:  f i = something i k where k = 2 ^ 10000;  does k evaluate on every invocation of f?
14:33:45 <int-e> `Guest00000: The compiler may "float out" the k from f, since it doesn't depend on i, and then it will be evaluated only once (if f is a toplevel function). So, it depends.
14:46:16 <parsnip> there seems to be an even split between cmdargs and optparse-applicative
14:46:26 <parsnip> in terms of downloads, etc.
14:48:37 <parsnip> i'll start in with the latter
14:58:25 <t7> You have a problem and you decide to use Haskell to solve it. Now you have a morphism in the category of problems.
15:00:09 <parsnip> now one of my problems is figuring what a morphism looks like in the category of problems.
15:00:14 <EvanR> endomorphism to be precise (otherwise you need two problems in general)
15:00:52 <t7> the category of problems is large
15:02:24 <t7> ah wait i mean the dots, not the arrows
15:05:22 <parsnip> objects, i guess
15:05:38 <parsnip> er, no nm, "arrows" matches "dots" for me.
15:05:55 <parsnip> as morphisms are to objects.
15:08:07 <t7> my category theory knowledge doesn't extend much beyond jokes
15:14:16 <metahumor> "no instance for (FromRow Text)" when trying to write a query_ with sqlite-simple, what am I doing wrong
15:14:43 <EvanR> maybe you need FromRow (Only Text) if its 1 column
15:14:54 <EvanR> Only being a 1-tuple type
15:15:25 <EvanR> try to decode into an Only Text
15:16:49 <metahumor> "topics <- Sql.query_ conn "SELECT DISTINCT topic FROM comments" :: IO [Text]"
15:17:06 <metahumor> is what throws the error
15:17:13 <EvanR> IO [Only Text]... just guessing
15:17:33 <EvanR> then you can unwrap them
15:17:59 <metahumor> ah
15:18:02 <metahumor> wonderful, thank you
15:45:16 <metahumor> i'm totally blanking, "(join . f) <$> x" is what?
15:45:46 <jle`> i don't think that's a thing
15:46:04 <jle`> join (f <$> x) is f =<< x, though
15:46:30 <jle`> but (join . f) <$> x is just applying (join . f) to the items in x
15:46:45 <jle`> > join . Just <$> [Just 10, Nothing, Just 3]
15:46:46 <lambdabot>  [Just 10,Nothing,Just 3]
15:47:04 <jle`> > (join . Just) (Just 10)
15:47:06 <lambdabot>  Just 10
15:47:30 <metahumor> i'm trying to swallow sqlite-simple errors into a larger Error type
15:49:04 <metahumor> and wow, once i got the right implementation for the wrapping, refactoring to make my db-actions now take care of errors is so ez
15:49:22 <metahumor> from "do {...}" to "wrapAction $ do {...}"
15:51:32 <chessandgo> im implementing a simple MUD game server in haskell, and was wondering whats the best way to handle all the threads im spawning
15:52:07 <chessandgo> would it be smart to have the main gameloop keep reading a TChannel, where each thread that gets spawned writes its ThreadID to the channel
15:52:22 <jle`> what do you want to do with these ThradIDs ?
15:52:35 <jle`> what do you mean by 'handle'?
15:52:51 <chessandgo> catching exceptions, getting input, sending output (via mvars)
15:53:30 <chessandgo> each thread spawned is someone connecting to the server. So I need to be able to check the status of them, and clean them up when they disconnect
16:40:05 <numberten> @hoogle (a,b) -> (a -> Maybe c) -> Maybe (c,b)
16:40:06 <lambdabot> Data.Text.Internal firstf :: (a -> c) -> Maybe (a, b) -> Maybe (c, b)
16:40:06 <lambdabot> Darcs.Patch.Repair mapMaybeSnd :: (a -> b) -> Maybe (c, a) -> Maybe (c, b)
16:40:06 <lambdabot> Data.Map.Internal mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
16:43:45 <jle`> numberten: see bitraverse
16:44:23 <jle`> unfortunately there's no traversefirst or traversesecond
16:44:38 <MarcelineVQ> pure isn't too long to type hehe
16:45:36 <TommyC> But it's the full word. We can't have variable names with the full word.
16:45:42 <TommyC> I vote we say "pr" instead. :3
16:48:20 <jle`> i didn't realize that there was an entire Bifoldable thing
16:48:35 <Gurkenglas> :t _1 :: (a -> Maybe c) -> (a, b) -> Maybe (c, b) -- numberten
16:48:36 <lambdabot> (a -> Maybe c) -> (a, b) -> Maybe (c, b)
16:48:54 <Gurkenglas> :t forOf _1 :: (a, b) -> (a -> Maybe c) -> Maybe (c, b) -- numberten
16:48:55 <lambdabot> (a, b) -> (a -> Maybe c) -> Maybe (c, b)
16:52:09 <numberten> jle`: wow cool thanks
16:53:59 <numberten> bitraversefirst/second would just be the second or first argument replaced with `pure` it seems
16:54:33 <MarcelineVQ> correct
16:54:51 <numberten> oh missed that
16:55:47 <MarcelineVQ> you can even be a sneaky sneaky and skip the import   \f -> (\(x,y) -> (,y) <$> f x)   :>
16:56:22 <numberten> yeah that's more or less what I have currently
16:56:26 <numberten> specialized to Maybe even
16:56:38 <numberten> but I have the import already, so I like this
16:57:18 <numberten> Gurkenglas: thanks, but no lens dep as of now
17:02:58 <jle`> microlens also has _1 fwiw
18:02:46 <fragamus> ok im trying to install https://github.com/NixOS/nixpkgs/tree/master/pkgs/development/compilers/swift but im a nixos newb and i need something really basic i think
18:08:05 <MarcelineVQ> #nixos is pretty helpful with things like that
18:09:49 <fragamus> nix-env -iA nixos.swift
18:10:48 <fragamus> $ /nix/store/pymp4cq49z4whxzjzys4by7dij0axdb0-gcc-6.4.0/include/c++/6.4.0/cstdlib:75:15: fatal error: 'stdlib.h' file not found
18:11:16 <fragamus> I guess it is marked as broken for a reason
18:18:08 <pikajude> okay, i am not sure if it's cabal or hunit that's hiding my test output
18:24:39 <pikajude> well
18:36:41 <fr33domlover> Hello
18:37:28 <fr33domlover> If I have "class A x => B x where"
18:37:43 <fr33domlover> What exactly does the constraint, the "A x" mean to the compiler?
18:37:56 <fr33domlover> When should I add such things
18:43:12 <pikajude> just means if you try to define a B instance for something it must already have an A instance
18:43:19 <pikajude> also you can use methods from A in your default implementations for B
18:45:09 <dmj`> fr33domlover:  class Eq a => Ord a, is a good example
18:46:09 <pikajude> would be impossible to define a class expressing total ordering if you had no concept of eqquality
18:46:19 <pikajude> a rogue extra Q has appeared
18:46:40 <metahumor> the Q in Q Exp reminds me of Q from Star Trek TNG
18:46:47 <metahumor> all powerful and tricksy
18:46:57 <fr33domlover> pikajude, dmj` and if I don't need such methods, is there still any use for this? can I still use that and GHC will complain if some type has a B instance without an A instance?
18:47:26 <pikajude> if you don't need them, why would you add the constraint
18:47:43 <fr33domlover> idk i just want to understand the uses ^_^
18:47:53 <pikajude> oh
18:47:57 <pikajude> yeah
18:47:59 <pikajude> GHC will still complain
18:48:21 <monochrom> Sometimes it saves user typing.  class Monad m => MonadIO m is an example.
18:48:56 <monochrom> No user wants to write "f :: (Monad m, MonadIO m) => m (); m = liftIO (putStrLn "hello") "
18:49:14 <fr33domlover> I see :)
18:49:17 <monochrom> Everyone wants to just write "f :: MonadIO m => m ()"
18:50:04 <pikajude> that's a good point, you really don't need Monad for MonadIO
18:50:15 <pikajude> it really could be called LiftIO
18:50:21 <jollygood2> what libraries are recommended these days in haskell for webscraping? I used htx a while ago and i want to try something else for my new project
18:50:51 <metahumor> wreq + tagsoup i what i've used
18:58:59 <jollygood2> metahumor checking it out. anything else?
18:59:17 <fr33domlover> Hmm the requirement doesn't apply to associated types?
18:59:38 <metahumor> you might also want to look at http-conduit
18:59:41 <fr33domlover> I mean, if I use methods of A then GHC will complain I'm missing the constraint A x =>
19:00:10 <fr33domlover> But if I use an associated type from A then no complaint
19:01:26 <fr33domlover> e.g. "class A a where data D a" and then "class B b where f :: Int -> D b"
19:01:54 <fr33domlover> there is no D without an instance of A, but GHC doesn't complain it seems
19:04:56 <glguy> You can use the associated type without its constraint, as well
19:05:24 <glguy> much less the super-class constraint
19:05:47 <ab9rf> i don't understand what you meant by "there is no D without an instance of A"
19:09:00 <fr33domlover> ab9rf, I mean can you define data D SomeType without making SomeType an instance of A?
19:15:26 <ab9rf> something here isn't making sense to me but i'm too tired to understand what
19:17:09 <m1n> sorry to ask for help on such a silly problem that has no application; I cannot figure out why this does not work: https://hastebin.com/lakazelero.hs  I get "Couldn't match expected type ‘Float’"
19:18:30 <metahumor> m1n: you aren't properly using do and return
19:19:41 <m1n> how do you return something? All the "do"s I have seen don't return anything. frustrated
19:20:18 <metahumor> > let frac n m = let (q,r) = divMod n m in fromIntegral q + fromIntegral r in frac 13 25
19:20:20 <lambdabot>  13
19:20:23 <m1n> this includes the do for xmonad, the do's for tuts I have seen. All the dos in the whol world >:|
19:20:45 <metahumor> m1n: you have nice pure functions/expressions
19:21:24 <m1n> metahumor: I guess I will take that as a compliment. This my first haskell "program" ever. Thanks for the help..
19:21:31 <metahumor> :t \f x -> do {y <- x; return (f y)}
19:21:32 <lambdabot> Monad m => (t -> b) -> m t -> m b
19:22:17 <metahumor> basically, if you have "do" and "pure", you are working with some mobits, which are more complicated than the simpler math-like expressions you have
19:22:21 <metahumor> :t divMod
19:22:22 <lambdabot> Integral a => a -> a -> (a, a)
19:22:25 <metahumor> :t fromIntegral
19:22:26 <lambdabot> (Num b, Integral a) => a -> b
19:22:38 <metahumor> see, no "m a" or "m t" or "m b" there
19:22:58 <m1n> what the sh is m a, m t and m b
19:22:59 <metahumor> m1n: read about "let ... in ..." and "where ..." expressions
19:23:06 <metahumor> m1n: not important right now
19:23:22 <m1n> let is used in do's though I know now when to use <- and let
19:23:59 <m1n> ah .. is 'm' maybe?
19:24:15 <metahumor> you don't have to use let in do
19:24:22 <metahumor> you can do it like i did above
19:25:15 <metahumor> m1n: https://hastebin.com/pahaboquku.hs
19:25:37 <metahumor> or "frac n m = let (q,r) = divMod n m in q + r"
19:25:54 <metahumor> did you mean to divide inside of add!
19:25:56 <metahumor> ?
19:30:39 <m1n> no, I was just trying to mimic division via      let (q,r) = divMod n m in (fromIntegral q + (fromIntegral r) / (fromIntegral m))  *shrug* just a random thing I was trying
19:30:55 <m1n> and just couldn't even get it to work as expected. thanks again
19:32:07 <metahumor> m1n: does it make sense now?
19:33:38 <m1n> nope. the `in` makes no sense. let's just put a random in-post-fix and it magically solves all the problems. cool. I'm sure it's fine, but to me it makes no sense. You don't need to explain why it's called in. I'm sure I'll read about it shortly. But to answer your question: no.
19:33:56 <metahumor> m1n: take a look at http://lpaste.net/362898
19:34:39 <m1n> that makes more sense
19:34:40 <metahumor> syntactically i find the "where" stuff simpler because its just helper expressions below our main expression
19:35:14 <metahumor> think of "let ... in ..." the same way you might think of "if ... then ... else ..." : you have to have all the pieces
19:36:51 <m1n> does this 'in' word have any root in mathematics? Why the <happy words; happy words> would someone use "in"?!
19:38:20 <m1n> and can I put this "in …" on a newline? ghc yells at me
19:39:07 <parsnip> 2010 report might clarify that somewhat.
19:39:28 <metahumor> you can put it on a new line: http://lpaste.net/362899
19:39:31 <parsnip> at least it should show brackets so you can just get it working.
19:39:37 <ab9rf> you can put the 'in' on a separate line as long as it's indented in further than the 'let'
19:39:57 <parsnip> i feel like i usually see it at same indentation
19:40:03 <m1n> ohhh thanks ab9rf
19:40:05 <parsnip> or do you mean, "at least"?
19:40:14 <ab9rf> parsnip: that might work. i never do that.
19:40:26 <ab9rf> parsnip: come to think of it, it should
19:40:31 <parsnip> i just do whatever the easy to install haskell-mode does
19:40:40 <m1n> and I don't need the do metahumor eh?
19:40:43 <metahumor> m1n: in math, sentences are often structured in the form of "let Q be the set of rationals in the ..."
19:41:01 <ab9rf> m1n: let and do are unrelated
19:41:19 <m1n> gotcha. I still don't need the do here since "one line"
19:41:21 <m1n> mm?
19:41:35 <ab9rf> "do" has nothing to do with lines
19:41:40 <parsnip> though, if it's like `main = let f = id\n  in putStrLn (f "hello")`
19:41:45 <ab9rf> do is about sequencing
19:41:47 <metahumor> m1n: "do" syntax is completely separate
19:41:57 <parsnip> m1n: do is for monads
19:42:14 <m1n> oí ve. ok. apparently I'm a monad >:(
19:42:20 <m1n> I'll keep reading
19:42:35 <ab9rf> do is a bunch of syntactic sugar that makes writing >>= expressions "easier"
19:42:37 <kenndel> What does it mean when a data type has 'Lit' ?
19:42:39 <metahumor> that's the first time i've seen that phrase transcribed that way =)
19:42:50 <metahumor> kenndel: are you looking at AST representations?
19:43:26 <kenndel> im making a simple arithmetic calculator
19:43:50 <kenndel> and i have example :: Expr, example = minus (plus (Lit 2) (Lit 2)) (Lit 3)
19:44:02 <kenndel> and all of this makes sense to me except what Lit means
19:44:12 <kenndel> and im having trouble googling anything because the slang Lit keeps showing up haha
19:44:12 <ab9rf> kenndel: ir dosn't "mean" anything speific
19:44:22 <metahumor> kenndel: "data Expr = Lit Int | Add Expr Expr | Mul Expr Expr" allows you to write your "eval :: Expr -> Int"
19:44:33 <ab9rf> you could replace "Lit" with "Kumquat" (everywhere) and it would still work
19:44:38 <metahumor> "eval (Add x y) = eval x + eval y"...
19:45:04 <metahumor> kenndel: can you now write the "eval (Mul x y)" and "eval (Lit x)" definitions?
19:45:06 <kenndel> oh so its the same as putting like 'a' in there?
19:45:30 <kenndel> oh wait i think i see
19:45:38 <kenndel> instead of doing a bunch of these
19:45:48 <kenndel> just one line it
19:46:49 <metahumor> kenndel: what do you mean? having the Lit constructor gives us the simplest-wrapped value
19:51:08 <fourroot> why is this 0.000002 + 0.000003 == 0.000005 not true when evaluated by a machine?
19:51:57 <metahumor> fourroot: because many floating point decimals (IEEE 754) don't have exact representation
19:52:31 <metahumor> fourroot: that might be true when evaluated by a machine that is using fixed point arithmetic, or high precision floating point, or many other cases
19:53:15 <metahumor> fourroot: but comparing floating point numbers (usually Double in Haskell) is kinda clunky/not-as-expected
19:53:38 <ab9rf> haskell does not hve the "apprxoimate-equal" mechanisms that are in some other languages
19:54:01 <ab9rf> two IEEE 754 values are equal only if they are precisely equal
19:54:26 <metahumor> (with the caveat of an important IEEE 754 value that isn't equal to anything, even itself)
19:55:19 <metahumor> someone should edit that "trust nobody, not even yourself" to make it about NaN
19:55:23 <fourroot> Thank you so much guys
19:55:41 <ab9rf> you can use decodeFloat to get some clue here
19:56:04 <ab9rf> > map decodeFloat [0.000002, 0.000003, 0.000005]
19:56:06 <lambdabot>  [(4722366482869645,-71),(7083549724304468,-71),(5902958103587057,-70)]
19:56:50 <ab9rf> you can tell from those decoded values that there's going to be a half bit discrepancy in the sum because the last digits add to 13
19:58:05 <ab9rf> so when 0.000002 + 0.000003 is renormalized, the result is rounded down
20:02:06 <ab9rf> metahumor: i so hate IEEE 754 semantics
20:03:24 <metahumor> ab9rf: what specifically? there's so much to hate?
20:03:54 <ab9rf> metahumor: at this point it's become a fairly generalized, nonspecific miasma of hatred
20:04:12 <metahumor> is it the signed zeros? or uneven precision in different ranges of |R? or the hardware-specific epsilons?
20:04:50 <ab9rf> metahumor: i think for me it started with the signed zeros
20:05:16 <ab9rf> it was "why do you have them when they are useful for nothing and do not behave in a manner that anyone would find useful?"
20:10:34 <geekosaur> they are useful as soon as you delve into numerical methods / series
20:13:11 <carter> geekosaur: yeah.  A lot of modelling / measurement issues would still happen even with Magic exact reals.  Floats just make it obvious from the out set :)
20:18:55 <metahumor> It'd be nice if a Numerical Value Error datatype existed with proper handling of compounding of errors
20:19:32 <carter> Which errors?
20:19:40 <carter> Accuracy or bad math ?
20:20:10 <metahumor> precision
20:22:21 <carter> Interval math and stuff is tricky.  You now have two problems : solving your original problem and correctly estimating your error ;)
20:22:34 <metahumor> yeah but that second problem was always there!
20:22:53 <metahumor> it's like the side-effects we're always talking about
20:24:20 <carter> It’s different. Like ... you can’t even decide equality of computable real numbers.
20:24:25 <carter> Floats ...
20:24:32 <carter> Represent intervals
20:26:59 <ab9rf> i admit that i've never done any hard-core numerical methods work. i knoew some people who were doing so, and they seemed like weird people :)
21:00:59 <Axman6> we need more unums
21:01:45 <enterprisey> ok, lens question: I have a type representing an expression in an AST with an annotation, Expression a
21:02:18 <enterprisey> I need a function Expression Pos -> Expression (), because an earlier bit of code annotates the expressions with positions
21:03:03 <enterprisey> I have a lens that gets an annotation already: for example, I can grab the position with the expression `view annotation`
21:03:07 <Axman6> do you have a Travesal (Expression a) (Expression b) a b?
21:03:21 <Axman6> Traversal*
21:03:28 <enterprisey> I will check
21:03:54 <enterprisey> what should I be looking for here? I'm a bit of a lens novice
21:04:00 <enterprisey> the code I see has a bunch of calls to makeFields
21:04:01 <Axman6> (ie, have you defined Traversable for your type)
21:04:15 <enterprisey> makeFields ''Expression is one of the lines
21:04:31 <Axman6> if you define Traversable (or derive it) traverse will be exactly that Traversal
21:04:41 <enterprisey> okay
21:05:00 * enterprisey goes off and reads the Traversal docs
21:06:05 <Axman6> actually, you can do that with just a functor instance
21:06:38 <Axman6> assuming you're just turning all Pos' into ()'s
21:06:47 <enterprisey> yup, that's what I'm doing
21:06:52 <Axman6> do... data Expression a = ... deriving (..., Functor) should be enough
21:07:16 <enterprisey> I'm in luck, it already derives that
21:07:38 <enterprisey> can I have a starting point for writing the function?
21:08:09 <enterprisey> also the annotation isn't the only thing in the expression ofc - there are a bunch of constructors
21:08:22 <Axman6> can you write a function from Pos -> ()?
21:08:22 <enterprisey> I'm not sure if that means I can still use the functor instance
21:08:32 <enterprisey> yeah, const ()
21:08:36 <ab9rf> heh
21:08:52 <Axman6> so can you write a function from Expression Pos -> Expression ()?
21:08:55 <ab9rf> can you write a function from Pos -> () that _isn't_ const ()? :)
21:09:08 <enterprisey> `\_ -> ()`?
21:09:15 <ab9rf> enterprisey: that's const ()
21:09:19 <enterprisey> this is true
21:09:33 <Axman6> enterprisey: what do you know about Functor? (hint, there is exactly one thing to know)
21:09:39 <enterprisey> I need to fmap const over it?
21:10:51 <Axman6> fmap :: (a -> b) -> (f a -> f b)
21:11:01 <Axman6> yeah?what happens if you have f = Expression?
21:11:08 <Axman6> and a = Pos and b = ()
21:11:12 <enterprisey> oh wow it worked
21:11:19 <enterprisey> tyty, Ax and ab
21:11:33 <enterprisey> honestly I shouldn't be that surprised haha
21:11:38 <ab9rf> axman did all the work
21:11:38 <Axman6> remember this pattern, it occurs _everywhere_
21:11:49 <ab9rf> i just threw a few peanuts
21:11:55 * Axman6 puts that on his resume
21:12:04 <ab9rf> jej
21:12:04 <enterprisey> I have been the victim of the well-known XY problem
21:13:19 <ab9rf> i get a lot of those
21:13:26 <ab9rf> but i do end-user support a lot
21:27:28 <hololeap> is there a good way to take a fanout of multi-parameter functions and apply them to succesive tuples of values, sort of like what can be done with Applicative?
21:28:04 <hololeap> for instance, adding two tuples of Ints, would start with ((+) *** (+))
21:29:51 <hololeap> in other words, is there a way to apply a tuple of functions to a tuple of values, like an applicative version of bifunctor?
21:32:11 <hololeap> oh, wait... there's a Data.Biapplicative in the bifunctor library
21:32:11 <MarcelineVQ> there's a Biapplicative is in bifunctors package
21:32:13 <MarcelineVQ> > ((+1),(*2)) BA.<<*>> (9,7)
21:32:15 <lambdabot>  (10,14)
21:32:22 <hololeap> lol
21:33:34 <woodson> Guy I wanna build a small library to work with Salesforce api.. how should I handle data that can return a lot of fields?
21:33:46 <woodson> should I use Map?
21:33:58 <MarcelineVQ> how much is a lot?
21:34:06 <woodson> or create some kind of abstraction that requires user to define the fields
21:34:13 <woodson> it could be 100's
21:34:16 <woodson> or more
21:34:17 <woodson> or less
21:34:37 <Axman6> you have lots of options, from Map Text Text  through to a datatype qwhich exactly represents the values which will be returned
21:35:49 <Axman6> if they have an OpenAPI description (which it looks like they do) you can use the OpenAPI playground to automatically create the Servant client for the API for you
21:35:55 <woodson> Axman6: then I would have to create some kind of function setFields in the library that pretty much uses Map functions?
21:36:39 <woodson> Servant Client?
21:36:55 <woodson> I was thiking about using wreq
21:37:08 <woodson> is it not enough?
21:38:25 <Axman6> depends how well typed you want to make it :)
21:39:30 <Axman6> but if you can find their Open API api description, 90% of the work can be done for you automatically
21:41:14 <woodson> Axman6: I did find their rest api page
21:42:43 <woodson> Ive used servant before but not servant client
22:15:14 <fourroot> Hey
22:15:19 <fourroot> why does index starts from zero
22:19:23 <ab9rf> https://superuser.com/questions/578292/why-do-computers-count-from-zero
22:19:25 <akshayn> fourroot: You mean list indices and such?
22:19:49 <ab9rf> it's also because mathematicians usually index sequences starting at zero
22:23:52 <akshayn> The convention is also partly due to how arrays and pointers work on the machine, isn't it? Where you have a base pointer to the first element and the index provides the offset to the element you want.
22:24:44 <ab9rf> akshayn: that's likely a large part of why most programming languages use zero-based indexes
22:32:15 <Axman6> you should be able to choose arbitrary indixes, both the types and starting indices, like Ada lets you (and haskell's Array types does)
22:37:28 <hololeap> it makes sense to start from 0 since it's the empty element of the addition monoid over integers. it implies default position/hasn't moved
23:06:56 <dminuoso> hololeap: And yet paragraphs in papers start at 1. =)
23:11:35 <mjrosenb> Is there a class that extends Enum for finite types that allows me to enumerate every possible value without being supplied a minimal or maximal element?
23:14:30 <ab9rf> how would you do that/
23:15:49 <mjrosenb> class BoundedEnum v where {smallest :: a; largest :: a}
23:16:10 <anohigisavay> hello! is it possible to an entire stack build plan for use in offline environment?
23:16:20 <anohigisavay> hello! is it possible to download an entire stack build plan for use in offline environment?
23:16:21 <mjrosenb> which is what I'm going to do if one doesn't already exist
23:17:51 <MarcelineVQ> Bounded is a standard class, providing minBound and maxBound like your smallest/largest
23:18:06 <MarcelineVQ> :t [minBound .. maxBound]
23:18:06 <mjrosenb> MarcelineVQ: EEEEEXXXXXCEELENT
23:18:07 <lambdabot> (Enum a, Bounded a) => [a]
23:18:33 * mjrosenb taps fingers together
