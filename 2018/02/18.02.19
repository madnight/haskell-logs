00:33:17 <fourroot1> https://www.wired.com/2012/07/b16b00b5/
00:37:38 <reptar_> anyone want a free ticket to lambda days?
00:37:41 <reptar_> anyone want a free ticket to lambda days?
00:44:41 <dminuoso> Mmm, is `trace str` equivalent to (unsafePerformIO $ putStrLn str) `seq` expr?
00:44:50 <dminuoso> `trace str expr` that is.
00:45:08 <dminuoso> Oh nevermind. I can just read the source.
00:45:10 <dminuoso> Heh.
02:02:42 <kuribas> @hoogle Monad m -> m (Maybe a) -> Maybe (m a)
02:02:43 <lambdabot> Network.AWS.Prelude (.!
02:02:43 <lambdabot> Yi.Keymap.Vim.StateUtils maybeMult :: Num a => Maybe a -> Maybe a -> Maybe a
02:02:43 <lambdabot> Control.FromSum fromMaybeM :: Applicative m => m a -> Maybe a -> m a
02:04:10 <cocreature> kuribas: if "m" is also Traversable you can use "sequence"
02:04:30 <kuribas> it's Html
02:05:03 <cocreature> that doesn’t tell me much, there are quite a few types called Html
02:05:32 <kuribas> Text.Blaze.Markup
02:07:32 <merijn> Is there a zip that gives me an error if both lists aren't actually the same length?
02:08:11 <Taneb> I don't know of one, why do you need it?
02:08:25 <kuribas> merijn: error as Maybe, Either, or exception?
02:08:30 <merijn> Taneb: ...to ensure nothing fucks up and both lists are actually the same?
02:08:35 <merijn> kuribas: Any of those
02:09:00 <merijn> kuribas: As long as I can log a screaming "dear god, shit's fucked!" kinda crash :p
02:10:36 <kuribas> :t let strictZip l m = guard (length l == length m) >> return $ zip l m in strictZip
02:10:37 <lambdabot> (Alternative ((->) [(a, b)]), Monad m) => [a] -> [b] -> m [(a, b)]
02:11:05 <Philonous> kuribas, Uh, don't use length
02:11:13 <kuribas> why?
02:11:24 <kuribas> it's O(n) either way
02:11:37 <kuribas> ah, because lazyness...
02:11:38 <merijn> kuribas: The length approach has a worse asymptotic behaviour, though
02:11:41 <Philonous> Because it forces the spine of the list prematurely
02:11:44 <kuribas> yeah
02:11:54 <dminuoso> Philonous: What's the "spine" of the list?
02:12:00 <canaryianaa> How much does a variable declaration in haskell slow down the engine?
02:12:04 <merijn> dminuoso: the bits that are not the elements
02:12:05 <canaryianaa> In ms
02:12:18 <dminuoso> canaryianaa: I dont think you can think of a variable declaration as an actual operation.
02:12:29 <canaryianaa> How about an assignment then?
02:12:46 <Philonous> dminuoso, The set of (:) constructors
02:12:53 <geekosaur> same story. an assignment isn't a modification, it's a name that lives inside the compiler
02:13:24 <canaryianaa> Buy surely it takes some cpu cycles?
02:13:29 <merijn> canaryianaa: Why?
02:13:38 <geekosaur> this is why we say 'binding' instead of 'variable'. no guarantee it ever makes it out of the compiler's memory because of referential transparency
02:13:40 <canaryianaa> I'm just wondering
02:13:46 <kuribas> canaryianaa: it depends on if it's a global or local variablse.
02:13:55 <dminuoso> geekosaur: The Haskell standard uses the word "variable" though.
02:14:14 <merijn> kuribas: Not really
02:14:19 <kuribas> canaryianaa: however you cannot reason about it because it goes through a lot of transformations in the compiler.
02:14:21 <merijn> kuribas: Because it's still impossible to say
02:14:35 <[exa]> still funny that haskell variables lack the basic property of variables
02:14:45 <merijn> [exa]: They don't
02:14:54 <kuribas> they aren't variable :)
02:14:58 <merijn> [exa]: Unless you use the weird, new definition of variables invented by programming languages
02:15:01 <dminuoso> kuribas: They are.
02:15:13 <dminuoso> kuribas: when you write `f x`, so that code its irrelevant what actual value `x` is
02:15:14 <merijn> [exa]: Haskell variables behave exactly like variables in math
02:15:21 <[exa]> merijn: it wasn't supposed to be true, just partially funny :]
02:15:32 <dminuoso> kuribas: they are in that sense variable, as you dont talk about specific values, but things that are variable in their value.
02:15:47 <dminuoso> kuribas: because you could write x = 1, x = 2, x = 3..
02:15:52 <[exa]> but yeah they are variable outside definition-scope
02:16:05 <dminuoso> variable does not mean mutable
02:16:56 <geekosaur> math-"variable" vs. common programming "variable" is why I said "_we_ say". terminological differences are annoying
02:17:37 <dminuoso> geekosaur: math-"function" vs common programming "function" is an even weirder one.
02:17:45 <geekosaur> true
02:18:05 <kuribas> also using '=' for assignment is a big mistake
02:18:12 <parsnip> x^2 = 2
02:18:22 <kuribas> I mean in imperative languages
02:18:31 <merijn> ok, on a completely unrelated note. I have a variable 'foo :: Integer' any suggestions on how I can make GHC stop complaining about type defaulting in an expression like "round (fromIntegral foo * 0.6)" because explicitly adding types in there becomes real ugly, but I also don't want to disable -Wtype-defaults
02:18:54 <kuribas> merijn: type applications?
02:19:03 <parsnip> top level function?
02:19:18 <geekosaur> I'd likely make a binding for the 0.6 with an explicit type
02:19:30 <geekosaur> but it depends onw hether it gets reused
02:19:52 <sphalerite_> Is there a reason that there isn't anything like Traversable which doesn't guarantee ordering?
02:20:33 <merijn> geekosaur: Not really. Although I suppose it'll go away later when I get around to replacing 0.6 with a value read by optparse-applicative, because then I can just properly type it there
02:20:35 <sphalerite_> it's a bit fiddly using toList on sets before I can use mapM
02:20:44 <merijn> sphalerite_: What sort of ordering would it guarantee
02:21:00 <merijn> sphalerite_: Also, containers does guarantee ordering, but needs a patch to reflect it in the docs
02:21:22 <merijn> sphalerite_: See my issue from last week: https://github.com/haskell/containers/issues/535
02:21:49 <kuribas> >  let foo = 2; foo :: Integer in round @Double (fromIntegral foo * 0.6) -- merijn
02:21:51 <lambdabot>  error:
02:21:51 <lambdabot>      Pattern syntax in expression context: round@Double
02:21:51 <lambdabot>      Did you mean to enable TypeApplications?
02:22:38 <merijn> sphalerite_: Traversable can't guarantee ordering, because not all Traversables have a sensible notion of ordering
02:23:08 <kuribas> merijn: I don't feel comfortable with ghc implicitly guessing types for me...
02:24:00 <merijn> kuribas: Me neither, but then I also don't feel comfortable with TypeApplications, because it means type variable order changes break code :p
02:24:36 <merijn> But I just realised this problem will disappear once I rebase by optparse-applicative code on top of this change, since then the type will be inferred from my commandline parser
02:26:33 <sphalerite_> merijn: then why isn't Set Traversable?
02:26:49 <merijn> sphalerite_: Oh, Set isn't Traversable because it requires elements to be Ord
02:26:56 <kuribas> hm, I realised the type "Monad m => m (Maybe a) -> Maybe (m a)" is impossible
02:26:59 <merijn> sphalerite_: Which isn't possible with Traversable
02:27:11 <sphalerite_> merijn: aaah ok
02:30:00 <kuribas> :t sequence . mapMaybe
02:30:01 <lambdabot> Traversable ((->) [a1]) => (a1 -> Maybe a2) -> [[a1] -> a2]
02:30:09 <Philonous> @type const Nothing :: Monad m => m (Maybe a) -> Maybe (m a)
02:30:10 <lambdabot> Monad m => m (Maybe a) -> Maybe (m a)
02:30:21 <ivano> ciao
02:30:35 <ivano> lens distortions
02:30:46 <kuribas> Philonous: yeah :)  not very useful though
02:36:36 <Gurkenglas> Is there a class for commutative applicatives?
02:38:27 <Gurkenglas> Which would be... distributive functors, and writer using a commutative monoid?
02:38:33 <Gurkenglas> What else?
03:03:57 <merijn> GHC's new pretty printer for errors is...not graceful in it's failure sometimes
03:04:26 <merijn> It's trying to pretty print a linewrapped expression for an error and blows it up to 200 lines >.>
03:07:54 <kuribas> anyone know how I can change the ghci prompt in emacs?  Setting .ghci doesn't seem to work in emacs.
03:11:16 <cocreature> kuribas: how about haskell-interactive-prompt and haskell-interactive-prompt2?
03:13:07 <kuribas> cocreature: that seems to work with interactive-haskell, but not Inf-Haskell
03:13:32 <cocreature> I thought inf-haskell was deprecated anyway
03:13:52 <kuribas> can I make run-haskell run inf-haskell?
03:13:59 <kuribas> erm interactive-haskell
03:14:11 <cocreature> no idea
03:20:47 <mniip> merijn, reminds me of that one time I had multi-page inferred constraints
03:21:30 <kuribas> cocreature: (defalias 'run-haskell 'haskell-interactive-switch) did the trick :-)
03:33:00 <kuribas> cocreature: sadly it only shows the prompt literally, and doesn't allow for special commands.
03:43:26 <sphalerite_> any reason there isn't something like mapRight :: Either a b -> (b -> c) -> Either a c  in Data.Either?
03:43:30 <sphalerite_> (and a corresponding mapLeft)
03:43:40 <[exa]> Gurkenglas: the typeclass is somewhere but I can't remember where (maybe it's in coq). Its name was Ap or similar
03:43:58 <Tuplanolla> Isn't that `second`, sphalerite_?
03:44:09 <Philonous> sphalerite_, mapRight is just fmap
03:44:13 <[exa]> sphalerite_: <$>
03:44:43 <sphalerite_> oh :D
03:45:10 <kuribas> :t over _Left
03:45:12 <lambdabot> (a -> b) -> Either a c -> Either b c
03:45:17 <cocreature> :t first
03:45:18 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
03:45:23 <cocreature> ahrg
03:45:28 <cocreature> :t Data.Bifunctor.first
03:45:29 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
03:45:32 <cocreature> that’s the one
03:45:32 <kuribas> sphalerite_: prisms are your friend :-)
03:45:55 <sphalerite_> prisms are scary and I don't know things about them :p
03:45:55 <kuribas> and bifunctors :)
03:46:14 <sphalerite_> or `either id` :p
03:46:22 <kuribas> sphalerite_: do you know what traverse does?
03:47:05 <kuribas> sphalerite_: a prism does the same, but only over the specified constructor.
03:48:44 <kuribas> well, that's how I understood them...
03:49:24 <cocreature> that’s more the description of a Traversal than a Prism (prisms are traversals so it still holds, it’s just not a very precise characterization)
03:49:56 <kuribas> yeah, my understanding of them is quite limited...
03:50:12 <cocreature> Prism also gives you "review"
03:50:25 <kuribas> :t review
03:50:26 <lambdabot> MonadReader b m => AReview t b -> m t
03:50:44 <cocreature> > review _Left 42
03:50:45 <kuribas> :t review _Left
03:50:46 <lambdabot>  Left 42
03:50:47 <lambdabot> MonadReader a m => m (Either a c)
03:52:54 <kuribas> review just recreates the constructor?
03:53:53 <cocreature> yeah
03:55:12 <kuribas> uncurried for multi-ary constructors?
04:02:25 <cocreature> yep
04:08:38 <merijn> mniip: The actual expression is like 6 lines, just somehow gets "prettyprinted" to 200 or so unreadable ones
04:11:17 <merijn> man, I really wish bimap had "both f = bimap f f" >.<
04:11:26 <merijn> s/bimap/Bifunctor
04:13:27 <kuribas> oh cool, I can get types of subexpressions in emacs :-)
04:13:36 <nullie> How is it pronounced, bye or bee,
04:13:57 <[exa]> nullie: depends on how latin you want it
04:14:01 <merijn> nullie: I say bye
04:14:39 <cocreature> merijn: just take the “add dependency on lens”-pill and be happy :)
04:14:53 <nullie> Was Latin pronunciation really conserved?
04:14:56 <merijn> cocreature: But lens is scary and confusing :(
04:15:00 <nullie> Over all those ears
04:15:07 <merijn> nullie: No, but it was reconstructed
04:15:20 <cocreature> merijn: but it has "both"? :)
04:15:30 <cocreature> -?
04:15:53 <kuribas> merijn: why scary and confusing?
04:16:11 <merijn> kuribas: I was exaggerating for comedic effect
04:16:17 <kuribas> ah
04:16:41 <kuribas> yeah, it's rather newbe unfriendly
04:16:47 <merijn> kuribas: But yes, the types of lens are ridiculously complex and there's millions of operators
04:17:25 <merijn> kuribas: And I generally just don't have that much use for lens and it's rather heavy-weight in terms of complexity for mere incidental usage
04:17:32 <kuribas> there is a logic in the operators though, and a lot of functions are just lens versions of base.
04:17:52 <cocreature> I love the 3-letter operators that are just "id"
04:17:53 <kuribas> true, it mostly makes sense for deeply nested structures.
04:18:13 <kuribas> so foldrOf, anyOf, ...
04:18:31 <merijn> kuribas: Sure, I know there's logic to it. But I'm just saying that learning/remembering the logic is, for me, more work than it buys me in terms of return
04:19:07 <phadej> merijn: join bimap ? :)
04:19:25 <merijn> phadej: Yeah, but that's not very pretty compared to "bimap f f"
04:19:49 <phadej> depends, if yo need point-free variant
04:19:51 <merijn> phadej: I just need "both" frequently enough that'd make a lot of stuff just that tiny nice bit nicer to read
04:20:12 <kuribas> merijn: ^. -> get one element ^? -> get one element Maybe ^.. get more elements.  For the rest, thinking of optics as generalised traverses gets you far.
04:20:36 <phadej> merijn: note that there's also bitraverse, which could be also used for "both"
04:20:55 <phadej> (and that's what lens-both is)
04:21:38 <kuribas> merijn: with deeply nested structures, the alternative is much more cumbersome.
04:21:51 <merijn> kuribas: Sure, but I don't really work with those a lot atm :p
04:22:24 <kuribas> it's like a type safe version of xpath :)
04:22:34 <kuribas> and much more
04:24:21 <Tuplanolla> I started with `microlens` and didn't touch any of the operators.
04:25:22 <Tuplanolla> The learning curve was not steep at all.
04:26:04 <nullie> After the first read of the lens tutorial it doesn't look scary
04:26:36 <merijn> I like how everyone tries to reassure me lens isn't scary, despite having played with lenses since before 'lens' was a thing that existed :p
04:26:59 <nullie> Hehe
04:27:09 <cocreature> merijn: did you know that Haskell is a pretty cool language? you might want to give it a try sometime!
04:27:15 <merijn> cocreature: Word!
04:30:17 <bash0r> Is there some library that lets me get command line arguments as ByteString?
04:30:32 <bash0r> Or do I need to do conversion on my own?
04:31:02 <cocreature> bash0r: http://hoogle.haskell.org/?hoogle=getargs%20%3A%3A%20IO%20%5BByteString%5D
04:31:15 <merijn> bash0r: on *nix you have System.Posix.Env.ByteString from the unix package
04:33:07 <bash0r> cocreature: how could I forget about the mighty hoogle?
04:33:23 <bash0r> merijn, cocreature: thanks to both of you.
04:44:54 <sphalerite_> is there something :: Either a (Either b c) -> Either (Either a b) c  in the standard library?
04:45:27 <sphalerite_> or alternatively: is there a better way to represent multiple levels of errors?
04:46:45 <cocreature> just make a new datatype with meaningful constructor names
04:47:19 <cocreature> e.g. data Error = FileNotFound … | DBConnectionFailed … and then use Either Error a
04:52:33 <sphalerite_> cocreature: I already have those those but they're more granular and I don't want to lump type errors together with parse errors
04:52:45 <sphalerite_> so in my case a is TypeError and b is ParseError
04:56:17 <merijn> ugh
04:56:47 <merijn> It's once again "god, I wish GHC actually followed the report and supported recursive imports"-o' clock again
05:00:08 <kuribas> @hoogle [a] -> Int -> ([a], [a])
05:00:08 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
05:00:09 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
05:00:09 <lambdabot> GHC.OldList splitAt :: Int -> [a] -> ([a], [a])
05:09:07 <Guest8383> how to implement a 2d array in haskell without following this pattern ?? http://lpaste.net/362652
05:10:47 <Guest8383> cale : how to implement a 2d array in haskell without following this pattern ?? http://lpaste.net/362652
05:11:18 <Guest8383> cocreature : how to implement a 2d array in haskell without following this pattern ?? http://lpaste.net/362652
05:12:02 <kuribas> Guest8383: https://en.wikibooks.org/wiki/Haskell/Libraries/Arrays
05:12:09 <cocreature> how about you start by not asking the same question 3 times while pinging people without there being a good reason for doing so?
05:12:32 <Guest8383> cocreature : noted
05:13:23 <bash0r> Guest8383: You can encode a 2D array in a normal array.
05:13:31 <cocreature> I’m also not sure what you mean by “this pattern”. your code snippet doesn’t look like valid Haskell
05:13:52 <Guest8383> cocreature : it does to me
05:14:02 <cocreature> what is "array2d"?
05:14:15 <Guest8383> and its inspired by standard Data.Map API
05:15:08 <Guest8383> cocreature : & its just a pattern i.e psudeocode
05:15:23 <cocreature> so it’s pseudocode not valid Haskell :)
05:15:41 <quchen> hvr: ping
05:15:46 <cocreature> but I still don’t get what the pattern is that you don’t want to follow
05:15:51 <quchen> hvr: /msg?
05:19:03 <kuribas> merijn: I have "data AccountTotal = AccountTotal !Value !Value !Value !Value" and "data Value = NoValue | Value !Int", and "accountValues :: Traversal' AccountTotal Value" To test if it has any Value, I use "anyOf accountValues $ has _Value".  It's rather elegant compared to the alternative, wouldn't you think?
05:19:48 <cocreature> kuribas: why are you still trying to convince merijn that lens can be helpful? he never claimed anything else :)
05:20:00 <kuribas> cocreature: erm, okay
05:20:53 <kuribas> I like how "anyOf accountValues $ has _Value" reads like english.  Take that OO :-)
05:21:30 <kuribas> someone (english speaking) with no programming experience whatsoever would know what that means :)
05:21:32 <kuribas> sortof...
05:22:09 <TMA> kuribas: you would *love* COBOL
05:22:43 <merijn> kuribas: I merely claimed lens wasn't useful *to me*
05:22:56 <kuribas> merijn: ah ok, that makes sense
05:23:18 <merijn> Or specifically, that's it's usefulness, to me, isn't proportional to the upfront buy-in required
05:23:36 <kuribas> it's fair enough.  It has a specific usecase.
05:24:20 <quchen> kuribas: You haven’t met many people who don’t know about programming yet – your line means »woah there is a standalone dollar sign there and the capitalization is weird, is this the matrix?«
05:25:23 <kuribas> quchen: yeah, I meant in sort of a vague sense.
05:27:32 <bash0r> kuribas: "and why the underscore? That's kinda confusing to me", spoke the newby.
05:27:46 <merijn> Why do i inevitably end up creating a module named Utils in every project? >.>
05:27:48 <kuribas> bash0r: newbee being you?
05:28:11 <bash0r> kuribas: I know why it's there. :p
05:28:15 <Tuplanolla> It's a sign of incomplete libraries, merijn.
05:29:29 <TMA> kuribas: COBOL was designed to be intellegible to non-programmers. It is generally thought that this design choice contributes to everything that feels wrong with COBOL.
05:29:31 <nood> can someone explain to me the reader monad in one sentence?
05:30:12 <liste> nood: a function with a parameter in disguise
05:30:13 <kuribas> TMA: at least do it with style: http://shakespearelang.sourceforge.net/report/shakespeare/
05:30:30 <liste> Reader a b ~ a -> b
05:31:19 <kuribas> or with megalomania: https://github.com/samshadwell/TrumpScript
05:31:38 <nood> liste: and what makes it different from every other function from a to b? what practical benefits do we get by disguising the parameter?
05:33:04 <liste> nood: you can stack it easily with writer, state etc. and use do notation
05:33:04 <oo_miguel> is there a trivial way to cut a list into small lists of given length and put them into a list of lists?
05:33:19 <liste> nood: and "lift"
05:33:37 <dmwit> > chunksOf 3 [1..10] -- oo_miguel
05:33:39 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
05:34:15 <dmwit> oo_miguel: There are also facilities in that same package if you need the chunks to be of different sizes.
05:34:41 <kuribas> :i chunksOf
05:34:50 <kuribas> @hoogle chunksOf
05:34:50 <lambdabot> Data.Sequence chunksOf :: Int -> Seq a -> Seq (Seq a)
05:34:50 <lambdabot> Data.Sequence.Internal chunksOf :: Int -> Seq a -> Seq (Seq a)
05:34:50 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
05:35:15 <oo_miguel> dmwit: ooh perfect... I was searching for [a]->[[a]] via hoogle so I missed this one
05:35:22 <oo_miguel> but it perferctly suits my needs
05:35:24 <oo_miguel> thankyou
05:35:24 <nood> liste: makes sense, thanks!
05:35:39 <kuribas> oo_miguel: wouldn't that be Int -> [a] -> [[a]] ?
05:35:53 <dmwit> :t chunksOf
05:35:54 <lambdabot> Int -> [e] -> [[e]]
05:36:05 <oo_miguel> kuribas: ah right, right
05:36:20 <dmwit> ?. hoogle type chunksOf
05:36:22 <lambdabot> Data.List.Split chunksOf :: Int -> [e] -> [[e]]
05:36:22 <lambdabot> Data.List.Split.Internals chunksOf :: Int -> [e] -> [[e]]
05:36:22 <lambdabot> Data.List.HT sliceHorizontal :: Int -> [a] -> [[a]]
05:44:47 <kuribas> what's the goto lib for command line arguments?  optparse-applicative?
05:45:49 <merijn> kuribas: Pretty much
05:45:56 <merijn> kuribas: Or rather, depends how fancy you wanna go
05:46:07 <merijn> optparse-applicative is probably the most flexible/featurefull
05:46:10 * kuribas fancy is great
05:46:57 <merijn> kuribas: I really like it due to the absence of TH magic and other "magic" for inferring flag names, etc.
05:48:01 <cocreature> optparse-generic might also be useful if you just want to do something quick 'n diryt
06:06:44 <halogenandtoast> Anyone experiencing "AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
06:06:52 <halogenandtoast> When trying to start a new stack project?
06:07:11 <Tuplanolla> Yeah, upgrade your Stack, halogenandtoast.
06:07:13 <halogenandtoast> Ran stack update && stack new Foo simple
06:07:13 <bash0r> halogenandtoast: I had the same issue. Try updating stack.
06:07:23 <bash0r> halogenandtoast: then check your path.
06:07:57 <halogenandtoast> Oh, it seems that stack update and stack upgrade might be different things
06:09:31 <halogenandtoast> Yeah works now, thanks!
06:52:52 <Bowlslaw> learning Haskell has reignited my passion for mathematics
06:53:00 <Bowlslaw> maybe I'll go through Spivak again...
06:53:35 <quchen> Calculus?
06:53:42 <Bowlslaw> yes
06:54:09 <Bowlslaw> I got bored with it once I started getting to the more abstract maths like topolog which, at the time, i didn't see a use for
06:54:12 <Psybur> When I do haskell I think more category/discrete math than calculus :D
06:54:15 <quchen> That sounds unrelated to Haskell.
06:54:20 <Bowlslaw> yes but I love calculus haha
06:54:32 <Bowlslaw> when I think math I think calculus
06:54:38 <Bowlslaw> you are correct though they are unrelated
06:54:57 <Psybur> When I think math I think math :D
06:55:30 <quchen> Well, topology and type theory do have some connection, but calc 1 doesn’t talk about that I think.
06:56:51 <Bowlslaw> haha
06:57:15 <Bowlslaw> i've purchased some mathematics books yesterday
06:57:23 <Bowlslaw> stuff that I've never taken
06:57:32 <phadej> fwiw I first heard word "category" on diff.geometry course
06:57:57 <phadej> (and you can get there thru calculus, seems spivak has books on that too :)
06:58:42 <phadej> otoh it's probably the twin tower of type-theory ivory tower
06:58:55 <phadej> so pick one you want to climb into
07:00:04 * quchen recommends the type theory tower. It’s very good.
07:02:11 <ventonegro> quchen: What to read after TAPL?
07:03:35 <phadej> after that you are hopefully ready to read thru ever growing list of conference and journal papers
07:04:00 <ventonegro> phadej: Is Pierce's Advanced TAPL any good?
07:06:31 <phadej> ventonegro: I haven't even read TAPL myself (only some stuff here and there)
07:06:44 <ventonegro> phadej: Ah, I see :)
07:07:10 <phadej> (have you tried to apply stuff, e.g. making own toy languages?)
07:07:19 <ventonegro> I've postponed it for a while but now I'm going through it
07:07:32 <canaryianaa> Why should I learn haskell?
07:07:33 <electrocat> ventonegro: yes it's good
07:07:43 <ventonegro> phadej: That's the goal, yes :)
07:07:54 <bartavelle> canaryianaa: because you feel like learning it?
07:08:01 <Tuplanolla> It would help you use Haskell, canaryianaa.
07:08:06 <canaryianaa> Coming from js
07:08:13 <electrocat> ventonegro: it's a very nice introduction to type system theory
07:08:30 <ventonegro> electrocat: I'll check it out afterwards then, thanks!
07:08:51 <ventonegro> canaryianaa: https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
07:09:56 <electrocat> honestly, learning haskell will make you despise anything else, especially js :p
07:10:30 <Bowlslaw> lol
07:11:21 <ljvm> Hi everyone, just getting started with Haskell, I just have some question
07:11:36 <electrocat> ljvm: ask away
07:12:48 <ljvm> When I type :t (+) in GHCi, I obtain something like this: "Num a => a -> a -> a" I kind of grok what "a -> a-> a" means but still can't understand what "Num a => a" actually means. Thank you in advance!
07:13:41 <ventonegro> ljvm: It means the `a` type must implement the Num type class
07:13:50 <electrocat> ljvm: it means for any 'a' given that 'a' is a type of 'Num'
07:13:54 <exarkun> You have an extra `a` there.  "Num a => a" and "a -> a -> a" when the signature is only "Num a => a -> a -> a"
07:14:18 <exarkun> The "Num a" applies to the whole declaration following "=>"
07:14:54 <ljvm> I see I see, wow that clears things up! Thank you thank you!
07:15:30 <TMA> just curious: is it possible to write it as (=>) (Num a) (a -> a -> a)?
07:15:51 <electrocat> i doubt it
07:15:58 <exarkun> It's not an expression and `=>` isn't a function
07:16:07 <TMA> pity
07:16:09 <parsnip> :t sum
07:16:10 <lambdabot> (Num a, Foldable t) => t a -> a
07:16:59 <TMA> > foo :: (=>) (Num a, Foldable t) (t a -> a) ; foo = sum
07:17:01 <lambdabot>  <hint>:1:9: error: parse error on input ‘=>’
07:17:18 <jmcarthur> > type c ==> a = c => a
07:17:20 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
07:17:28 <jmcarthur> ah
07:18:02 <jmcarthur> Well, with enough extensions that can work in ghci, and then the prefix syntax works for (==>)
07:26:13 <Bowlslaw> er
07:26:15 <Bowlslaw> i missed that
07:26:26 <Bowlslaw> what would you recommend for math books related to Haskell and FP in general?
07:31:54 <bbear> I would be interested to know.
07:32:53 <bbear> Actually I would be really interested to know more about best practices regarding FP and real world problem solving.
07:33:10 <bbear> Basic architecture of backends for example.
07:33:32 <Psybur> Bowlslaw, Ive heard categories for the working mathematician is good
07:33:58 <Tuplanolla> Only if you're actually a working mathematician, Psybur.
07:34:03 <Tuplanolla> It's quite impenetrable otherwise.
07:34:04 <Bowlslaw> lol
07:34:27 <Psybur> Ive heard otherwise. Did you try to read it and it wasnt good?
07:34:41 <Psybur> I havent read it so I cant say
07:34:41 <Bowlslaw> what about "an intro to FP though lambda calc(dover) ?
07:37:17 <Tuplanolla> It begins with "we construct other familiar large categories, as follows" and then goes on to list familiar things like commutative rings and topological spaces.
07:40:51 <merijn> bbear: Why do you think those are very different from the architecture you'd use in any other language?
07:41:21 <bbear> basically I thought the software architecture could be very different in a dynamic vs static language
07:42:03 <Welkin> bbear: all dynamic languages are static languages with a single type
07:42:10 <Welkin> there is no such thing as "dynamic types"
07:42:34 <bbear> ha you mean in theory. I thought that it would be different in practice.
07:43:08 <Tuplanolla> There are some differences, but they are generally not too important, bbear.
07:44:45 <bash0r> Welkin: thank you for the blog post yesterday. That was an awesome read. Especially the follow up blog post defending Java from some guy in the comments was hilarious.
07:45:49 <Welkin>  no need to thanks me. I didn't write any of it, just posted a link
07:46:02 <bash0r> I would have never found it on my own. ;)
07:46:28 <parsnip> oh, where is this defense of java at?
07:46:34 <Welkin> wait, what was the first blog post?
07:47:01 <Welkin> I remember posting "verbs in the kingdom of nouns"
07:47:11 <Welkin> https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
07:47:27 * parsnip rewrites projecteuler 43 with backtracking, now runs 100 times faster
07:47:38 <bash0r> Yes that one. In the comments there's a link to a blog from a guy who defends Java.
07:48:24 <bash0r> This one: http://bpfurtado.livejournal.com/2006/10/21/
07:50:07 <sr10> hey im just stucked on this problem on how to get the permissions and individual permission http://lpaste.net/362656 .
07:50:09 <Welkin> I liked the link to an email by alan kay http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html
07:50:26 <sr10> im bit confused myself
07:57:29 <Welkin> good news!
07:58:27 <Welkin> Simon Marlow said he will get Parallal and Concurrent Haskell back online at some point, but it was taken down by O'Reilly for technical reasons (they shut down a platform, perhaps chimera labs?)
07:58:40 <Welkin> and the book is licensed under Creative Commons (which I did not know)
07:58:43 <Welkin> but very good news indeed
07:59:55 <mud> That's cool
08:01:08 <Welkin> for now you can access it on the web archives
08:01:18 <Welkin> I should store that somewhere on lambdabot
08:01:49 <Welkin> ?where parconc
08:01:49 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
08:01:54 <Welkin> that won't work anymore
08:02:12 <Welkin> how can I redefine this definition?
08:02:35 <Welkin> @quote parconc
08:02:35 <lambdabot> No quotes match. My pet ferret can type better than you!
08:02:38 <Welkin> hm
08:02:44 <Welkin> @help
08:02:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:02:53 <Welkin> @help where
08:02:54 <lambdabot> where <key>. Return element associated with key
08:02:54 <mud> Welkin: I like how the title of that is "Offline for Maintenance" too
08:02:56 <merijn> Welkin: You need @where+ to update/overwrite
08:03:07 <Welkin> @where+ parconc https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
08:03:07 <lambdabot> It is forever etched in my memory.
08:03:13 <merijn> @where parconc
08:03:13 <lambdabot> https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
08:03:13 <Welkin> ?where parconc
08:03:13 <lambdabot> https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
08:03:19 <merijn> There you go :)
08:13:18 <bash0r> Welkin: another nice link from you. I wanted to read it a few days back and stumbled over the same issue.
09:11:36 <Guest68424> cale : take a look at this : http://lpaste.net/362657, is it possible to come up with a function which can insert value into this map with just key value
09:12:02 <Welkin> sure
09:12:10 <Welkin> if you have a function to convert a key into a value
09:12:21 <Welkin> I believe there is a function that already does it
09:13:07 <Welkin> hm, maybe that is only for array
09:16:35 <Dynasty> Guest68424 are you looking for something like this?: http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Map-Lazy.html#v:fromSet
09:30:17 <astralemp> {-# LANGUAGE ExistentialQuantification #-} <-- why isn't it called UniversalQuantification, given that it uses `forall' rather than `exists'?
09:31:10 <Welkin> because it is an existential quantifier
09:31:15 <Welkin> there is no "exists" in haskell
09:31:57 <astralemp> what makes it existential rather than universal?
09:32:03 <monochrom> It also exploits the fact that "(exists x. P x) -> Q" equals "forall x. P x -> Q".
09:33:08 <Tuplanolla> When you see `forall` in a record, you have to remember that it's in negative position, astralemp.
09:35:54 <astralemp> negative position?
09:36:02 <remix2000> Do you think that Haskell is significantly harder to learn than OCaml?
09:36:47 <athan> remix2000: maybe, haskell has a lot more kit and flexability
09:36:52 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#existentially-quantified-data-constructors
09:36:57 <athan> but ocaml might be a good start, or even elm
09:37:00 <Welkin> I haven't used it and have a vague understanding myself
09:37:12 <Welkin> athan: no elm!
09:37:15 <Welkin> bad athan
09:37:19 <athan> :D
09:37:43 <Welkin> remix2000: I think that haskell is a much more elegant language, and it has a proper type system
09:37:46 <Welkin> ocaml does not
09:38:37 <dysfun> athan: purescript!
09:38:47 <Bowlslaw> what's so special about ocaml?
09:38:57 <Welkin> astralemp: it is how ST works though
09:39:04 <astralemp> Welkin: I understand how they're used. I just don't understand why they'd name it that if it's implemented in terms of `forall' rather than `exists'.
09:39:10 <Welkin> so look at ST as an example
09:39:26 <dysfun> Bowlslaw: module functors?
09:39:42 <LKoen> Bowlslaw: ocaml is taught as part of the curriculum in french scientific prep schools
09:40:08 <Bowlslaw> hm
09:42:23 <remix2000> Welkin: Well, the huge amount of specialized functionalities in Haskell that do similiar things with minor differences (I'm talking about e.g. specialized monads) might be frightening for beginners.
09:42:51 <Bowlslaw> meh timid beginners...
09:43:16 <Bowlslaw> do you mean total beginners to the subject?
09:43:20 <Bowlslaw> or just people new to Haskell?
09:43:25 <remix2000> the second
09:44:01 <Welkin> remix2000: from all evidence I have seen and heard, people who have never programmed before find haskell pretty easy to pick up compared to those who have been programming in C++ or Java for years
09:44:07 <Bowlslaw> I know my experience is not universal, but I've been programming professionally for about a year and taught myself everything I know about CS, and I find Haskell utterly fascinating
09:44:37 <Bowlslaw> I started learning about FP with Scala and, well...blargh. Then I went to SICP and it was much better
09:44:58 <dysfun> yes, scala and blargh definitely go together
09:45:03 <Bowlslaw> lol
09:45:29 <[exa]> scala is the best language for expressing blargh!
09:45:30 <Psybur> Bowlslaw, happen to stumble upon scalaz? :D
09:45:38 <Bowlslaw> nope
09:45:39 <dysfun> scala is a DSL for blargh
09:45:47 <Psybur> Thats blarghz! :D
09:45:52 <remix2000> What's wrong with Scala?
09:46:08 <dysfun> well, it tries to be haskell and fails?
09:46:09 <[exa]> nothing, the resulting blargh is optimal.
09:46:33 <Bowlslaw> 1) the syntax is confusing 2) you have to type too much to do anything 3) not binary compatible between minor versions 4) takes forever to compile
09:46:43 <dysfun> (you can have haskell on the jvm these days, see eta)
09:46:59 <Psybur> Eta needs to get its ffi generator working :D
09:47:06 <[exa]> but yes, there are certain (extremely non-unixy) environments where scala or F# are best choices today
09:47:22 <Bowlslaw> I like f#
09:47:24 <dysfun> no, just no.
09:47:29 <astralemp> Tuplanolla: what do you mean by negative position?
09:47:39 <Bowlslaw> i like the little i've learned about f# anyway
09:47:44 <Bowlslaw> i know way more about Haskell at this point
09:47:57 <remix2000> Bowlslaw: From what I've heard f# is just renamed OCaml marketed by micro$oft :D
09:48:05 <parsnip> i should learn lens before continuations before fix?
09:48:10 <dysfun> f# is "inspired by ocaml"
09:48:14 <Tuplanolla> @google positive and negative position in type theory
09:48:15 <lambdabot> https://cs.stackexchange.com/questions/42150/meaning-of-positive-position-and-negative-position-in-type-theory
09:48:34 <parsnip> and by "learn lens", i mean superficially (no pun intended, lol)
09:48:56 <dysfun> is there a profunctor lens library in haskell yet?
09:49:54 <Welkin> dysfun: yes
09:50:18 <dysfun> cool. it seems much more natural than the van laarhoven presentation
09:50:28 <Bowlslaw> Guys I am looking over a few books to begin my type theory journey, any recommendations? "Practical Foundations for Prog Langs" - Haper | "Type Theory and Formal Proof: An Intro" - Nederpelt, Herman, Geuvers | "Types and Programming Languages (MIT Press)"
09:50:37 <Bowlslaw> Harper*
09:51:13 <dminuoso> Bowlslaw: The HoTT book has been suggested to me multiple times. :o
09:51:21 <Welkin> Bowlslaw: I have Types and Programming Languages, which is often recommended
09:51:27 <Welkin> I didn't read past chapter 1 yet though
09:51:43 <Welkin> it is not a beginner text
09:52:03 <Bowlslaw> well I have a decent foundation in CS and mathematis
09:52:26 <Welkin> I found reading the proofs to be the most difficult part
09:52:41 <Welkin> but then I don't have much experience in proofs or reading/writing formal logic
09:52:51 <Welkin> I just need to learn how to read all the symbols
09:53:09 <Bowlslaw> dminuoso: HoTT ?
09:53:27 <Welkin> Homotopy Type Theory?
09:53:32 <dminuoso> Bowlslaw: https://homotopytypetheory.org/book/
09:53:49 <Welkin> https://homotopytypetheory.org/book/
09:53:52 <Welkin> yeah
09:55:02 <parsnip> i only read books with cool cover art https://www.math.cornell.edu/~hatcher/AT/AT-toc.pdf
09:55:02 <Bowlslaw> $22 FOR HARDCOVER
09:55:33 <Bowlslaw> haha
09:55:42 <Bowlslaw> how are topology and haskell related?
09:55:44 <Welkin> I think it is print on demand
09:55:52 <pavolzetor> I spent day trying to call a function in an LLVM, does anybody here know how to call a function? LLVMIR.call (operand) (fmap (\x -> (x, [])) args') gives me *** Exception: EncodeException "The serialized GlobalReference has type PointerType {pointerReferent = FunctionType {resultType = FloatingPointType {floatingPointType = DoubleFP}, argumentTypes = [FloatingPointType {floatingPointType = DoubleFP}], isVarArg = False}, pointerA
09:55:59 <Welkin> topology and type theory
09:56:26 <dminuoso> Bowlslaw: Things like homology groups
09:56:28 <Bowlslaw> so I should read through topology before I start on type theroy
09:56:31 <pavolzetor> I looked at the examples in llvm-hs-example, but when I convert the function to ptr I get malformed ast error
09:56:34 <parsnip> Bowlslaw: homotopy and homology are kin
09:56:45 <parsnip> Bowlslaw: no, just code, no math
09:56:50 <cocreature> pavolzetor: can you show us the code or at least the relevant parts?
09:56:55 <pavolzetor> Yep
09:56:55 <parsnip> shoot the math
09:57:03 <Bowlslaw> but i leiks teh math
09:57:06 <cocreature> pavolzetor: oh are you using the IRBuilder stuff?
09:57:07 <parsnip> okay fine
09:57:18 <parsnip> i can't speak on order or study
09:57:20 <parsnip> *of
09:57:57 <parsnip> Bowlslaw: topology is a very fun text, the one, i forget the name.
09:57:57 <pavolzetor> http://lpaste.net/362663
09:58:16 <Tuplanolla> How do you expect topology to help you with type theory, Bowlslaw?
09:58:29 <pavolzetor> I am trying :), I got function emitting working, but I got stuck at making the call
09:58:34 <cocreature> pavolzetor: this should be fixed by https://github.com/llvm-hs/llvm-hs/commit/c2acbf8c5a75fc7cdb810aea1ad118742ca7999c.
09:58:41 <parsnip> Bowlslaw: by Munkres
09:58:46 <cocreature> pavolzetor: so try building directly from the llvm-5 branch
09:59:08 <parsnip> i enjoyed that for undergraduate topology course, around 2008.
09:59:25 <Bowlslaw> I don't know, I'm just asking
09:59:32 <pavolzetor> thanks, let me try it
09:59:36 <parsnip> not sure if there's some new better shiny book for undergraduates now, wouldn't surprise me, education can improve.
09:59:38 <Bowlslaw> the furthest I've gone in math was everything I could learn about diff eqs
09:59:57 <Bowlslaw> but now I am interested more abstract topics
10:00:01 <pavolzetor> I want to release the kaleidoscope code as simple example of using IRBuilder; the current examples are extremely unhelpful
10:00:01 <Bowlslaw> such as topology
10:00:20 <parsnip> Bowlslaw: if you want a nice terse step into junior level math major studies, i can recommend Gerald Folland's Advanced Calculus.
10:00:42 <cocreature> parsnip: we’re happy to accept PRs to add more examples to the repo!
10:01:03 <cocreature> eh ^ pavolzetor
10:01:05 <Tuplanolla> I wouldn't recommend topology to anyone.
10:01:19 <parsnip> ah
10:01:22 <parsnip> ha
10:01:26 <parsnip> Tuplanolla: why?
10:01:34 <pavolzetor> I would recommend discrete morse theory and algebraic topology
10:02:03 <pavolzetor> there is great user guide by forman
10:02:07 <parsnip> Tuplanolla: i only did so because he seemed to express general interest in math, i didn't say he should study some math subject before some type theory, that i can't speak on.
10:02:26 <Tuplanolla> In my experience it focuses too much on theorems about point sets and how to prove them by contradiction or by using choice, parsnip.
10:02:50 <pavolzetor> cocreature, can it be multiple files pull request?
10:02:54 <parsnip> i think Munkres has many chapters without much about points
10:03:06 <dminuoso> Bowlslaw: Well luckily you can grab the book for free, and then get it as hard cover if you like it. :)
10:03:11 <parsnip> but definitely lots of set style proofs
10:03:13 <Bowlslaw> yesss
10:03:40 <parsnip> oh, i was interpreting your mention of sets as like metric spaces
10:03:46 <parsnip> *mention of points
10:03:57 <ixxie> I am working on an IRC bot, and so I made a data Msg = Msg { cmd :: String, from :: Maybe String, args :: Maybe [ String ], body :: Maybe String }
10:04:11 <ixxie> now I wanna make a function read :: String -> Msg
10:04:15 <woodson> Hey question guys, in the haskellbook they say that " Newtypes
10:04:15 <woodson> must have the same underlying representation as the
10:04:15 <woodson> type they wrap, as the newtype wrapper disappears at compile
10:04:15 <woodson> time."
10:04:27 <woodson> how exactly does it lose its wrapper?
10:04:35 <woodson> cant seem to picture it
10:04:48 <Tuplanolla> I spent half a year on it and learned nothing of use outside classical analysis.
10:05:11 <lyxia> woodson: newtype T = T Int   now every time you see a T that's an Int
10:05:26 <parsnip> at my uni, it lead into differential geometry, so yeah.
10:06:01 <parsnip> took the first year graduate sequence as well, it basically did the same thing, first general topology, then smooth topology.
10:06:16 <parsnip> Jack Lee's books
10:06:35 <pavolzetor> cocreature, how do I install it from source? I am using stack so I am bit lost
10:06:36 <woodson> lyxia: isnt that simply aliasing?
10:06:42 <ixxie> since sender is optional and led by a colon, I was thinking of something read s = Msg { from = if head s == ":" then takeWhile (/= " ") s ...
10:06:46 <woodson> could we just user type T = Int?
10:06:52 <woodson> use**
10:07:04 <ixxie> but I was hoping to elegantly capture the remainder for the other arguments of the constructor
10:08:24 <cocreature> pavolzetor: take a look at https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos
10:08:38 <lyxia> woodson: the point is for there to be a syntactic barrier between T and Int
10:08:47 <cocreature> pavolzetor: multifile PRs are fine, if you want to keep it separate a PR that just links to your repo is also nice
10:08:58 <parsnip> Tuplanolla: sometimes earlier texts are used to develop mathematical maturity before stepping into more advanced texts.
10:09:33 <fresheyeball> Can anyone out there recommend a library for doing ML?
10:09:46 <lyxia> woodson: while T can be represented as just an Int, it being a newtype means that you can hide that definition from other users
10:09:51 <fresheyeball> I was trying to learn tensor flow, but hate python
10:10:19 <Psybur_> fresheyeball, youre screwed :D
10:10:36 <fresheyeball> Psybur_: oh no!
10:10:41 <fresheyeball> That's not ideal
10:10:44 <woodson> lyxia: So what about Sum a = {getSum a}, what does this translate to?
10:10:49 <lyxia> woodson: so you can enforce invariants and prevent mistakes like adding a time value with a length value
10:11:12 <jonh> fresheyeball: i thought there are haskell bindings
10:11:21 <lyxia> woodson: newtype Sum a = Sum { getSum :: a }  translates to just an "a"
10:11:34 <pavolzetor> thanks, that seems to be working; I noted it and I will submit PR when I have done the tutorial
10:11:43 <mud> I believe there are (unofficial) tensorflow bindings, yeah. I haven't looked at them though
10:11:46 <fresheyeball> jonh: there are haskell bindings for tensorflow
10:11:46 <jonh> fresheyeball: https://github.com/tensorflow/haskell
10:11:51 <jonh> oh ok
10:12:36 <fresheyeball> but I was hoping there is a nicer haskell thing for this. Something that exploits algebraic properties to make a nice api.
10:13:40 <woodson> lyxia: and I guess the invariant that you speak of in terms of Sum are the two functions that we get?
10:13:47 <woodson> lyxia: Sum and getSum?
10:14:26 <lyxia> woodson: Sum isn't meant to maintain invariants
10:15:45 <lyxia> Sum is a wrapper to define another Monoid instance for a type that already has one
10:16:10 <monochrom> or doesn't have one and no one wants to have one
10:16:22 <lyxia> right
10:18:23 <pavolzetor> cocreature, it asks for LLVM 6, is there a way with having the fix but build with LLVM 5?
10:18:35 <pavolzetor> (I would like to avoid compiling llvm again)
10:19:28 <fresheyeball> jonh: https://github.com/mikeizbicki/HLearn
10:19:34 <fresheyeball> this looks good, but dead
10:25:57 <ixxie> whats the difference between a tuple and a list in Haskell
10:25:59 <ixxie> ?
10:26:20 <hpc> a tuple is a fixed number of things of potentially different types
10:26:27 <fresheyeball> ixxie: lists are homogenious collections with an unfix number of elements
10:26:27 <hpc> a list is a variable number of things of the same type
10:26:37 <hpc> :t ("string", 5)
10:26:39 <lambdabot> Num b => ([Char], b)
10:26:43 <hpc> :t [1, 2, 3]
10:26:44 <lambdabot> Num a => [a]
10:26:50 <fresheyeball> ixxie: tuples are hetrogenious collections with a fix number of elements documented in it's type
10:26:51 <hpc> :t [5 .. 100]
10:26:52 <lambdabot> (Enum a, Num a) => [a]
10:28:01 <hpc> tuples go up to size... either 62 or 64, i forget which
10:28:39 <hpc> but if you use more than 3 elements you're one of maybe 0.1% of haskell users
10:29:09 <hpc> lists can even be infinite in size
10:29:27 <hpc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
10:29:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:30:43 <Welkin> hpc: 63
10:31:13 <cocreature> pavolzetor: you need to build the llvm-5 branch as I mentioned above
10:31:43 <hpc> ah right, it's 62 different tuple sizes, starting from 2
10:31:48 <Welkin> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:31:49 <lambdabot> error:
10:31:49 <lambdabot>     A 63-tuple is too large for GHC
10:31:49 <lambdabot>       (max size is 62)
10:31:53 <Welkin> oh, lol
10:31:56 <hpc> lol
10:31:57 <pavolzetor> I have llvm 5
10:31:59 <Welkin> 63 is the point at which it is too large
10:32:07 <Bowlslaw> haha
10:32:09 <Bowlslaw> that's a big tuple
10:32:31 <pavolzetor> I see, sorry
10:32:43 <hpc> the only people who ever have to care about that are the maintainers of that particular module in base
10:32:51 <Welkin> generally I never go beyond a 3-tuple
10:32:53 <pavolzetor> I cloned wrong branch
10:33:01 <Welkin> normally it's only a 2-tuple
10:33:05 <Welkin> which is a key-value pair
10:33:21 <Welkin> n-tuples can be useful when pattern matching on many things at once though
10:33:27 <Welkin> such as in a case expression
10:33:29 * parsnip blushes
10:33:30 <hpc> personally if i was writing that module, i wouldn't go beyond 4
10:33:36 <pavolzetor> How many versions back do you backport fixes?
10:33:42 <hpc> Welkin: oh, good point
10:34:05 <hpc> actually yeah, there's some process spawning packages that return a big tuple
10:34:18 <hpc> something like (pid, process handle, stdin, stdout, stderr)
10:37:30 <cocreature> pavolzetor: usually we only maintain the newest version. it’s just too much work otherwise.
10:38:38 <cocreature> pavolzetor: but so far we also didn’t have anyone asking for backports to older versions so we never had to actually make that decision
10:40:54 <ixxie> thanks hpc
10:40:55 <pavolzetor> is the newest version llvm 5 or 6?
10:43:18 <cocreature> pavolzetor: the newest released version is llvm-hs 5.x but LLVM 6.0 will be released in one or two weeks so all active development is already focused on llvm-hs 6.x which will be released directly after the LLVM release
10:49:18 <gfhduifda> If I have a propositional formula (say x or -y or z) in the form [[Unnegated "x", Negated "y", Unnegated "z"]], how can I get a list like [("x", true), ("y", false), ("z", true)] of truth value assignments that would make the disjunction true?
10:50:16 <parsnip> gfhduifda: make a pattern match function and map over it?
10:50:30 <cocreature> gfhduifda: is the input a formula in cnf?
10:51:21 <gfhduifda> cocreature: No the input is a disjunction like [Unnegated "x", Negated "y", Unnegated "z"].
10:51:34 <gfhduifda> for (x or -y or z)
10:51:52 <cocreature> gfhduifda: but you showed us a nested list, what is the outer list for?
10:52:26 <gfhduifda> It was just a typo
10:53:55 <cocreature> if you only have a disjunction of (negated) literals then just write af function `Literal -> (String, Bool)` (assuming `Unnegated "x"` has type literal) and use `map` to apply it to all elements in the list
10:54:08 <metahumor> gfhduifda: matching. but what are you going to use "True" and "False" for? why can't you just use "Unnegated" or "Negated" downstream?
10:54:36 <cocreature> if you have more complex formulae use a SAT solver
10:54:51 <gfhduifda> parsnip: I'm not sure how the pattern match function would work. Like f (x:xs) = (variable, true) if unnegated or (variable, false) if negated?
10:56:07 <cocreature> f :: Literal -> (String, Bool); f (Unnegated n) = (n, True); f (Negated n) = (n, False)
11:04:03 <gfhduifda> Thanks, got it working. Another thing. Say that function outputs [("x",True),("y",False),("z",True)]. I want to write a function that takes in one of those truth value assignments like ("x", True) and and an expression in 2-CNF like [[Unnegated "x", Negated "y", Unnegated "z"], [Negated "x", Negated "y"]] and reduces it to [[Negated "y"]]
11:05:17 <gfhduifda> I know I use filter for ones that have "x" unnegated, and map over the others filtering out ones with "x" negated
11:07:46 <cocreature> that looks like 3-cnf not 2-cnf
11:08:53 <cocreature> but yeah a filter followed by a map or alternatively a mapMaybe should work just fine
11:09:20 <Welkin> what is cnf?
11:09:28 <gfhduifda> I didn't mean to put that 2 there, don't have any restrictions on the number of variables in a disjunct, although I don't think it makes a difference in the code
11:09:38 <cocreature> Welkin: conjunctive normal form
11:10:13 <qeyoa> what does this mean exactly: `type Pair a = (a,a)` Does this say that a pair is a tuple with with values of the same type?
11:10:33 <cocreature> qeyoa: yep
11:10:48 <qeyoa> i'm trying to figure out how to use this, some thing like:
11:10:50 <qeyoa> things :: Pair
11:10:50 <qeyoa> things = ("foo", "kin")
11:10:52 <Welkin> `type` is the keyword used to declare a type synonym
11:10:53 <qeyoa> does not work
11:11:05 <Welkin> you forgot the a
11:11:09 <hpc> qeyoa: what is things a pair of?
11:11:11 <Welkin> Pair String
11:11:33 <qeyoa> ah
11:11:37 <qeyoa> thanks, now it's clear
11:11:48 <Welkin> generally, avoid type synonyms
11:12:05 <qeyoa> why?
11:12:10 <Welkin> they don't actually make your program any easier to understand (in fact, the often make it harder to understand) and do not give you any extra type safety
11:12:17 <Bowlslaw> hmmm
11:12:23 <Bowlslaw> thanks Welkin
11:12:31 <Bowlslaw> I haven't noticed it is quite different compared to C
11:12:36 <Bowlslaw> where I use typedefs a lot
11:12:42 <qeyoa> where would they be used?
11:12:43 <Bowlslaw> i have*
11:12:58 <bash0r> Bowlslaw: In C it's the same story.
11:13:03 <Welkin> sometimes I find them useful, like when declaring a synonym for some large monad transformer stack
11:13:08 <Bowlslaw> I dunno, it helps me a lot in C
11:13:09 <Welkin> but tohers will disagree and say never use it
11:13:16 <qeyoa> ok
11:13:43 <Welkin> if you want to create a new name for an existing type, use newtype
11:13:53 <bash0r> Why can't people just use the struct's name instead of typedef'ing it?
11:17:11 <Bowlslaw> typedef struct list { item_type item; struct list *next; } list;
11:17:18 <Bowlslaw> makes it easier for me to throw around list
11:17:31 <kuribas> (a -> Const r a) -> s -> Const r s is better than Getting r s a ?
11:18:20 <dminuoso> kuribas: That is the definition of Getting
11:18:39 <dminuoso> since Getting is just a `type` for that, it really doesnt matter
11:19:00 <kuribas> it's a type synonym
11:19:16 <dminuoso> Ohh I misunderstood your question for a question.
11:19:23 <dminuoso> :D
11:19:26 <bash0r> Bowlslaw: AFAIK, the struct keyword in `struct list *next;` is redundant when considering modern C. So it actually doesn't buy you anything to do the redundant `typedef struct` construct.
11:19:39 <dminuoso> bash0r: Its not redundant.
11:20:05 <bash0r> dminuoso: just out of curiosity, what's the difference?
11:20:48 <dminuoso> bash0r: if you create some struct s in C, you cant refer to it as "s", but only as "struct s" - basically because.. C is weird.
11:21:07 <kuribas> historical artifact probably
11:21:32 <bash0r> dminuoso: Didn't they change something in C11?
11:22:03 <dminuoso> bash0r: Not really.
11:22:21 <qeyoa> there were changes in c that recently
11:22:21 <qeyoa> ?
11:22:22 <dminuoso> bash0r: They just allowed anonymous structs to directly typedef them.
11:22:55 <dminuoso> I think? Idk.
11:23:36 <bash0r> oh gosh... That redundancy in syntax is as necessary declaring a functions parameter with an inline struct.
11:24:23 <mniip> you're confusing with C++
11:24:44 <mniip> in C++ 'struct s x;' and 's x;' is equivalent
11:24:55 <bash0r> mniip: very well possible.
11:28:59 <ixxie> can someone point me to a simple example of how to use if/else statements in conjustion with let in or where statements
11:29:33 <cocreature> > let x = 1 in if x > 1 then True else False
11:29:35 <lambdabot>  False
11:29:59 <ixxie> so the if then must always be on the right side of the assignment
11:30:14 <Bowlslaw> oooh
11:30:18 <ixxie> I was trying to do multiple assignments inside a single if
11:30:27 <Bowlslaw> on to the chapter in Hutton about lambdas, i'm excited
11:30:29 * ixxie is a total n00b
11:30:30 <cocreature> ixxie: you can assign to tuples
11:30:30 <bash0r> ixxie: for where declarations you need to indent the function body a little bit more
11:30:42 <hpc> ixxie: let-in syntax is "let <variable bindings> in <expression>"
11:30:58 <cocreature> > let (x,y) = if True then (1,1) else (2,2) in x + y
11:30:58 <hpc> ixxie: and "if <expression> then <expression> else <expression>" is an expression
11:31:00 <lambdabot>  2
11:31:06 <cocreature> > let (x,y) = if False then (1,1) else (2,2) in x + y
11:31:08 <lambdabot>  4
11:31:16 <hpc> (let-in syntax is also an expression)
11:31:23 <Bowlslaw> (i know you've specifically asked about ifs, so i don't wanna be that guy, but I have found pattern matching to be easier and clearer with Haskell)
11:31:24 <metahumor> ixxie: "if predicate then let x = 0 in x else x = 1 in x"
11:31:33 <metahumor> Bowlslaw: do you know about guards?
11:31:36 <Bowlslaw> yes
11:31:52 <metahumor> Bowlslaw: sometimes a one liner if-then-else is more straightforward imo
11:31:54 <Bowlslaw> ah they are guarded ifs?
11:32:05 <Bowlslaw> are they considered if/then/else ?
11:32:30 <Welkin> if-then-else is just a case expression that has two branchs: True and False
11:32:40 <Welkin> it's syntactic sugar
11:33:07 <metahumor> there's also "ifThenElse"
11:33:20 <dminuoso> I think its generally preferred if you can float it into a guard at the top level of the function.
11:33:38 <Bowlslaw> hmm
11:33:40 <Welkin> all of these constructs are syntactic sugar
11:33:47 <Welkin> everything is turned into case expressions with pattern matching
11:34:04 <Welkin> but they can be helpful to reduce noise in your program
11:34:07 <metahumor> i just write everything in case expressions over RealWorld
11:34:11 <Welkin> lol
11:34:13 <dminuoso> Haha
11:34:39 <Tuplanolla> Everything is turned into machine code
11:34:49 <Tuplanolla> and everything you love will eventually turn into ash.
11:34:53 <dminuoso> You mean everything is turned into STG code! :D
11:34:57 <Bowlslaw> lol
11:35:20 <Bowlslaw> and then
11:35:25 <Bowlslaw> it's turned into electrical signals
11:35:27 <Bowlslaw> and then
11:35:29 <Bowlslaw> the atoms and
11:35:32 <Bowlslaw> and
11:35:38 * Bowlslaw dies
11:35:42 <metahumor> no atoms
11:35:45 <Welkin> those are the same thing
11:35:48 <metahumor> its all electrons and holes
11:36:17 <Bowlslaw> the the probability function and
11:36:21 <Bowlslaw> wait i'm alive wtf
11:36:25 <gfhduifda> cocreature: Quick question on how to use filter in that problem. If I have reduce :: CNF -> TruthAssignment -> Maybe CNF, and reduce x:xs y = filter (condition) xs, how do I set the condition to see if any elements have the variable negated/unnegated depending on the TruthAssignment?
11:42:03 <Bowlslaw> what is the difference between lambda expressions and anonymous functions?
11:42:22 <hpc> nothing
11:42:42 <Bowlslaw> :O
11:42:50 <bash0r> Bowlslaw: lambda sounds better
11:43:10 <mud> You could say that  (blah . foo) is an anonymous function, but it's not a lambda expression I guess?
11:43:35 <bash0r> mud: I'd say that's function composition.
11:44:08 <hpc> it depends on which hair you decide to split ;)
11:45:27 <hpc> as far as learning to be useful in haskell goes, there's no useful distinction
11:46:07 <hpc> and if you go and do math with it, you'll use the terminology of whatever you're working with
11:46:19 <hpc> which would be different for SK calculus, lambda calculus, pi calculus, etc
11:47:19 <hpc> and then maybe the distinctions are useful as contextual hints, but eh
11:48:59 <cocreature> gfhduifda: `elem` is probably going to come in handy https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:elem
11:51:08 <gfhduifda> cocreature: I'm trying reduce x as = filter (\y -> (any ((Negated (fst as))==) y)) x where x is the CNF list, as is like ("x", True), to get the elements which don't have unnegated x
11:52:53 <cocreature> gfhduifda: I’m not sure I understand your question. it would be great if you could post your complete code snippet on lpaste and provide an example of what you are having trouble with
11:55:11 <gfhduifda> cocreature: I want to do reduce [[Unnegated "x", Negated "y", Unnegated "z"], [Negated "x", Negated "y"]] ("x", True) and get [[Negated "y"]]
11:55:16 <gfhduifda> Or reduce [[Unnegated "x", Negated "y", Unnegated "z"], [Negated "x", Negated "y"]] ("x", False) and get [[Negated "y", Unnegated "z"]]
11:55:56 <cocreature> gfhduifda: alright, start by writing something that reduces it to [[Negated "x", Negated "y"]]
11:56:13 <cocreature> (for the first example)
11:59:33 <gfhduifda> cocreature: I have that: reduce x as = filter (\y -> (any ((Negated (fst as))==) y)) x
12:00:04 <gfhduifda> But I'm confused on how to remove the negated x from that, and handling the case with ("x", False)
12:00:16 <cocreature> gfhduifda: alright, now write a function that turns [Negated "x", Negated y"] into [Negated "y"]
12:00:40 <cocreature> then you can use "map" to apply that function to all lists resulting from your existing filter operation
12:03:29 <dminuoso> Interesting, so if functions generalize containers - then also from that perspective it makes sense that `fmap` acts on the "result" since the Codomain is effectively the values of the abstract container.
12:10:44 <metahumor> what's the proper way to use a specific GHC version with a cabal sandbox?
12:11:38 <maerwald> use it
12:11:54 <maerwald> build ghc locally, set the prefix and install it in the prefix
12:12:08 <maerwald> then adjust PATH, done
12:12:10 <maerwald> no stack needed
12:12:28 <pavolzetor> cocreature, the new llvm worked, thanks for saving me ton of time
12:12:29 <Welkin> I think there is an easier way with cabal new-*
12:12:49 <cocreature> metahumor: pass "-w /path/to/ghc" to cabal configure
12:13:45 <gfhduifda> cocreature: I have it working: http://lpaste.net/4203747254399401984  But how do I handle the case with ("x", false)?
12:14:25 <cocreature> gfhduifda: pattern match on the second element of the "as" tuple and change the filters appropriately
12:23:05 <tinco> hey! weird question, is there a sort of inverse of the Maybe monad, where the monad returns the first time something is (Just a) instead of the first time something is Nothing?
12:23:39 <metahumor> tinco: "Last"?
12:24:07 <tinco> what's that?
12:24:10 <cocreature> "asum" can also often be used for that
12:24:17 <cocreature> > asum [Nothing, Nothing, Just 3, Nothing]
12:24:19 <lambdabot>  Just 3
12:24:29 <metahumor> tinco: I meant, "First" from Data.Monoid
12:25:30 <tinco> > asum [Nothing, Nothing, Just 3, Just 2]
12:25:33 <lambdabot>  Just 3
12:25:51 <tinco> hmm that might work
12:26:35 <sm> g'day all. Where should I report an issue with http://hoogle.haskell.org ?
12:26:38 <tinco> metahumor: how do I use the First monoid? that also looks like it wuold work
12:26:59 <cocreature> sm: https://github.com/ndmitchell/hoogle
12:27:01 <Welkin> asum is <|> applied between every element of the list/foldable
12:27:11 <sm> cocreature: thanks!
12:27:22 <Psybur_> > Nothing <|> Just 1
12:27:24 <lambdabot>  Just 1
12:27:32 <Psybur_> > Just 2 <|> Just 1
12:27:34 <lambdabot>  Just 2
12:27:48 <metahumor> tinco: > getFirst (mconcat (fmap First [Nothing, Nothing, Just 3, Just 2]))
12:27:50 <tinco> oh so I do getFirst $ return (Just x) and it'll return x it seems
12:27:58 <tinco> cool thanks
12:28:02 <metahumor> > getFirst (mconcat (fmap First [Nothing, Nothing, Just 3, Just 2]))
12:28:04 <lambdabot>  Just 3
12:28:57 <gfhduifda> cocreature: Got it working. The last thing that I think I should do is return Nothing if it isn't solvable, like if I have [[Unnegated "y"]] and ("y", False), then it reduces to [[]].
12:29:14 <tinco> is Data.Monoid the sort of library that'd go great in prelude? looks pretty fun
12:29:17 <gfhduifda> Searched online but don't see how I can check after the map
12:29:40 <cocreature> gfhduifda: just pattern match on the result using "case"
12:29:55 <Welkin> tinco: Data.Monoid is used all the time
12:29:58 <Welkin> justi mport Data.Monoid
12:30:27 <Welkin> the Prelude doesn't mean anything
12:30:34 <Welkin> it's kind of a random assortment of re-exports
12:30:44 <Welkin> many of them are nice to have
12:30:57 <Welkin> but you will find yourself importing directly from the specific modules you need
12:31:17 <gfhduifda> cocreature: Sorry, but how do I pattern match to check for an empty list in a nested list?
12:31:39 <ski> gfhduifda : just use `[]' in the position where you expect to see an empty list
12:31:44 <cocreature> > case [[]] of [[]] -> Nothing; e -> Just e
12:31:46 <lambdabot>  Nothing
12:31:50 <cocreature> > case [[1]] of [[]] -> Nothing; e -> Just e
12:31:52 <lambdabot>  Just [[1]]
12:31:55 <ski> do you have any particular offending code that you'd like use to take a look at ?
12:35:11 <bontaq`> I am very heckin confused by Alternative (https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#Alternative) -- it's the same code for some & many isn't it?  It works as expected though with some throwing an error for no matches...
12:35:46 <lyxia> bontaq`: the "where" clauses are the same
12:36:33 <lyxia> but they pick different functions at the toplevel (many = many_v;  some = some_v)
12:36:42 <gfhduifda> Works great, thanks everyone
12:38:58 <parsnip> :t until
12:38:59 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
12:40:58 <bontaq`> oh I think I see now, thanks lyxia.  spooky
12:42:48 <ski> hmm .. i wonder whether the compiler shares the implementation of those two
12:44:42 <ski> or, if they were defined using a `local'-`in'-`end' construction (like in SML. it's like a `let', except that the whole construction, and what's after the `in' is a declaration (or sequence of declarations)), whether that would be more likely to share the code (while not being needlessly inefficient)
12:45:50 <armlesshobo> :t while
12:45:51 <lambdabot> error: Variable not in scope: while
12:46:09 <armlesshobo> :t many
12:46:10 <lambdabot> Alternative f => f a -> f [a]
12:46:28 <ski> (one could either consider `local someAndMany v = (some_v,many_v) where some_v = ...; many_v = ... in some v = fst (someAndMany v); many v = snd (someAndMany v) end', where hopefully the pair construction and deconstruction would be elided in the code the compiler generate ..)
12:49:11 <ski> (or, an alternative could be `local some_v = ... where v = ?v; many_v = ... where v = ?v in some v = let ?v = v in some_v; many v = let ?v = v in many_v end' .. hopefully here the mutual calls wouldn't keep passing `?v' around in the generated code -- is there a better alternative than these two ?)
12:49:42 <lyxia> why not put someAndMany at the toplevel?
12:50:30 <tinco> ugh.. I feel like xzibit building these monads.. there's some monads inside my monad so I can monad while I monad
12:51:32 <ski> hm, that might work if `someAndMany' is not exported. if it's exported, then perhaps that would hinder the type of elision optimization that we're interested in here ?
12:51:36 <gfhduifda> cocreature: Have it working, just one last thing, do you think there's some way to simplify this or avoid repeating myself? http://lpaste.net/4203747254399401984
12:52:03 <ski> i also just realized that if one overrides e.g. `some', but not `many', then that won't override the definition of `some' that `many' uses
12:52:11 <ski> so in that sense, we don't have open recursion here
12:52:25 <ski> i wonder whether this was intended, or whether it was an oversight
12:52:59 * ski . o O ( `(some v,many v) = (...,...)' )
12:53:43 <lyxia> I don't think GHC would be able to optimize away the parameter passing
12:54:02 <ski> mhm
12:58:17 <ski> hm , it's a bit interesting that default method definitions give us open recursion, actually. that's something that the obvious related record construction doesn't give you, you have to work extra to get it
13:14:07 <tinco> hmm I had a weird error saying something like: Expected projects to be "Map.Map (Maybe (Maybe String)) Github.Repo" and actual was "Map.Map String Github.Repo"
13:14:18 <tinco> in my maybe monad, and then I did "let projects = projects"
13:14:22 <tinco> on a hunch.. and it compiled
13:14:36 <tinco> I don't get why that let binding is required though..
13:15:02 <tinco> do let bindings do some magic to make them special values inside monads?
13:15:23 <metahumor> tinco: that let binding is almost definitely not what you want
13:15:24 <tinco> (eh with inside monads, I mean inside do-notations)
13:15:42 <tinco> eh oh no
13:15:45 <cocreature> gfhduifda: for reduce it might be better to use a where clause in which you define what needs to be filtered and then just use that instead of duplicating everything else
13:15:47 <tinco> it's a recursive definition isn't it :(
13:15:55 <metahumor> tinco: the Maybe (Maybe ...) also seems like you might have something unexpected
13:16:46 <tinco> yeah I wonder how that happens.. let me see if I can get a nice lpaste of this
13:18:32 <tinco> ahh metahumor the Maybe (Maybe ...) is my get first result.. I'll see if I can fix that.. I probably am returning things I need to leave bare
13:19:16 <Maxdamantus> `let foo = foo` just happens to be something that will always type.
13:20:04 <tinco> ok so yes, I was doing: return $ extractGithubName myField, extract returns a maybe, and I'm trying to convert that to a First I guess
13:20:09 <Maxdamantus> :t let foo = foo in foo
13:20:11 <lambdabot> t
13:20:36 <reptar_> anyone living in or near krakow?
13:20:36 <Maxdamantus> Satisfies any type you want, because it doesn't have to produce an actual value.
13:20:41 <tinco> Maxdamantus: yeah that was silly of me, I walked into that before a long time ago and I forgot about it
13:20:49 <tinco> so I made the same mistake again :P
13:21:44 <tinco> so.. how do I get my Maybe to be a First?
13:23:21 <phadej> :t First
13:23:22 <lambdabot> Maybe a -> First a
13:23:36 <phadej> > First (Just 'x')
13:23:38 <lambdabot>  First {getFirst = Just 'x'}
13:25:02 <tinco> ah
13:27:27 <tinco> does this make sense? http://lpaste.net/362666
13:28:05 <tinco> findGithubName is still returning Maybe (Maybe String) instead of just Maybe String
13:28:36 <dminuoso> tinco: Aside from the quirky comment that ought to be a type annotation :P
13:28:37 <phadej> > join (Just (Just x))
13:28:39 <lambdabot>  Just x
13:28:40 <metahumor> tinco: the line that starts with "First $ extract...." -- you're not doing anything with that
13:29:11 <tinco> dminuoso: that's me explaining the context :P
13:30:20 <metahumor> tinco: what about "(getFirst . mconcat . fmap First) repoLocations
13:30:41 <tinco> metahumor: hm so the idea I had was that I'd have a do block, and every line of the do block has a result, and if that result is Just x, the monad would stop and return that
13:31:05 <pavolzetor> how does one convert foundation string to shortbytestring?
13:31:11 <metahumor> tinco: nope, do block won't "early terminate" like that
13:31:22 <tinco> ok, so it really has to be a list
13:31:44 <metahumor> tinco: do you want to first try "homepage package", and if that fails, try the "repoLocations"?
13:31:50 <tinco> yes exactly
13:32:38 <metahumor> why not "(getFirst . mconcat . fmap First) ((extractGithubRepo (homepage package)) : repoLocations)
13:33:03 <metahumor> as in, prepend the first thing you are going to try to "repoLocations", if you're going to use First anyway
13:33:32 <tinco> yeah that makes sense, though my hope was going to be that I'd have a clean line for each possibility, since I might add more than just homepage and repoLocations
13:33:32 <pavolzetor> fromString . toList
13:35:07 <pavolzetor> cocreature, how do you deal with recursive function? Currently I do extern first, but the label associated to function is different
13:35:12 <CritJongUn> hey there guys
13:35:25 <CritJongUn> how can i use liftM with "fromInteger"
13:35:27 <pavolzetor> define is f.1, declare is f
13:35:37 <CritJongUn> because of the polymorphic signature
13:35:41 <phadej> metahumor: getFirst . foldMap First
13:35:50 <pavolzetor> it resolves internally to the right name, but I am curious what is going on
13:35:52 <dminuoso> CritJongUn: dont use `liftM` its an anti pattern. Just use fmap :)
13:36:04 <metahumor> phadej: perfect.
13:36:28 <metahumor> phadej: does "mconcat . fmap f" not get fused?
13:36:35 <CritJongUn> dminuoso: im doing the monad challenges so i dont have fmap available
13:36:54 <phadej> metahumor: it should, it just looks weird
13:36:56 <dminuoso> CritJongUn: Functor is a superclass of Monad, so you have fmap available if you have liftM available
13:37:07 <phadej> foldMap works for all foldables
13:37:09 <phadej> also
13:37:11 <phadej> :t alaf First foldMap
13:37:13 <lambdabot> Foldable t => (a -> Maybe b) -> t a -> Maybe b
13:37:16 <reptar_> anyone here live in or near krakow?
13:37:36 <CritJongUn> dminuoso: i do not have the libs available, they're all implemented by me
13:38:23 <CritJongUn> dminuoso: and if you dont mind explaining how fmap differs from liftM i'd be appreciated
13:38:41 <dminuoso> CritJongUn: They dont. liftM = fmap
13:39:18 <CritJongUn> dminuoso: then how is liftM an antipattern
13:39:21 <metahumor> they do differ. liftM has a (Monad m) constraint
13:39:25 <dminuoso> ^- well that.
13:39:29 <metahumor> its more constraint than necessary
13:39:38 <mniip> liftM = fmap  follows from the laws
13:39:44 <glguy> liftM needs that Monad contraint since it's defined in terms of Monad methods
13:39:45 <mniip> but it's defined differently
13:40:22 <cocreature> pavolzetor: sorry I have to go, if you can’t figure it out open an issue
13:40:23 <dminuoso> CritJongUn: but anyway, what particular problem do you have with liftM and fromInteger:
13:40:27 <mniip> :t (=<<) . (return .)
13:40:27 <metahumor> are there any canonical cases where the "monadic" definition for some fmap instance is more performant than just Functor?
13:40:28 <lambdabot> Monad m => (a -> b) -> m a -> m b
13:40:32 <mniip> that's liftM
13:40:45 <CritJongUn> metahumor: glad to see you again buddy, what does the Monad vs Functor do in this case
13:41:04 <dminuoso> CritJongUn: Monad is unnecessarily more restrictive than Functor.
13:41:06 <glguy> metahumor: liftM is used as a potentially implementation of fmap
13:41:16 <dminuoso> CritJongUn: since every Monad is a Functor `fmap` is simply less restrictive.
13:41:36 <mniip> every Monad being a Functor is a fairly recent addition
13:41:37 <CritJongUn> how is fmap more performant then?
13:41:52 <metahumor> forget my "performant" question, i am confused
13:41:52 <dminuoso> mniip: Mind my asking, how recent?
13:42:04 <mniip> 2-3 years I think?
13:42:09 <cocreature> 8.0 iirc
13:42:30 <mniip> 7.10
13:42:40 <cocreature> oh wow time passes fast
13:42:48 <Welkin> time flies like a banana
13:42:54 <Welkin> lambdabot: time
13:42:58 <CritJongUn> dminuoso: the problem is, i want to do liftM fromInteger *int variable* and i want to get a Double
13:43:21 <metahumor> CritJongUn: why not just "fromInteger myvar"
13:43:23 <monochrom> int variable? Integer variable?
13:43:39 <CritJongUn> metahumor: i have Maybe var
13:43:40 <mniip> Num int => int
13:43:45 <metahumor> or do you actually want "fromIntegral"?
13:43:54 <dminuoso> CritJongUn: You cant simply extract something from a Maybe.
13:44:08 <CritJongUn> metahumor: integer or integral are interchangeable in this case no?
13:44:12 <dminuoso> CritJongUn: No.
13:44:12 <monochrom> NO.
13:44:20 <dminuoso> :k Integral
13:44:22 <lambdabot> * -> Constraint
13:44:24 <dminuoso> :k Integer
13:44:25 <lambdabot> *
13:44:27 <Welkin> it's that guy from north korea again
13:44:34 <monochrom> "Integral" is not even a type.  class ≠ type
13:45:07 <CritJongUn> Welkin: sup
13:45:08 <monochrom> Yes now all of your foundamental assumptions are melting away.
13:46:02 <dminuoso> CritJongUn: Here's the tip I gave my colleague today: Write down the type signatures you have, and let the types guide you ♫
13:46:35 <pavolzetor> cocreature, will do, thanks for help
13:47:07 <dminuoso> CritJongUn: and by "you have" I mean "you need"
13:47:20 <Welkin> write your program on paper by writing all the types first
13:47:22 <Welkin> it worked for me
13:47:47 <dminuoso> CritJongUn: Most of my "how do I..." questions are solved by simply playing type fitting. =)
13:47:47 <monochrom> This assumes that they won't mix up various types, and they won't mix up types with classes.
13:47:48 <Welkin> then I typed my program into the computer and it worked on the first try
13:47:56 <Welkin> it was a game of pong
13:48:19 <CritJongUn> dminuoso: but i dont want to "play" with type fitting
13:48:23 <Welkin> try doing that in a language that isn't haskell
13:48:33 <CritJongUn> dminuoso: i want to learn how to write the signature
13:49:00 <CritJongUn> :t liftM
13:49:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
13:49:09 <CritJongUn> :t fromIntegral
13:49:10 <lambdabot> (Num b, Integral a) => a -> b
13:49:20 <CritJongUn> the problem is when mixing
13:49:25 <Welkin> mixing what?
13:49:27 <CritJongUn> :t liftM fromIntegral
13:49:29 <lambdabot> (Num r, Integral a, Monad m) => m a -> m r
13:49:34 <monochrom> But overall, "liftM ___ v" is almost there already.  You will want to change liftM to fmap, but it's a minor issue.
13:49:51 <CritJongUn> how do i say now that i want the r to be a double
13:49:58 <dminuoso> CritJongUn: Then say exactly that.
13:50:14 <dminuoso> CritJongUn: Replace `r` with `Double` (and remove the constraint Num r), and that's it
13:50:20 <CritJongUn> monochrom:  im doing the monad challenges
13:51:17 <CritJongUn> dminuoso: dude i dont have a small function with this, nor i really want to write a one use function apart when it problem is the type
13:51:50 <monochrom> You can always try "liftM fromIntegral v :: Maybe Double"
13:52:06 <monochrom> But I'm going to dude you back.
13:52:10 <Welkin> the compiler will figure it out based on the context in which you use that function
13:52:29 <Welkin> if you are just using it alone without anything else, then you need to tell it what type you want
13:52:37 <monochrom> Dude if you have a large piece of code then show the real thing rather than show an inaccurate mock-up and then blame us for it.
13:55:24 <dminuoso> TypeInType question: When GHC says that "kinds and types are the same", what exactly is meant by that?
13:55:45 <monochrom> It means * :: *
13:56:49 <Welkin> what does that mean?
13:56:57 <Welkin> sounds recursive
13:57:03 <monochrom> Yes, it is.
13:57:21 <dminuoso> monochrom: I have gathered that much, but not the point behind this, or why this is a good thing
13:58:37 <pikajude> Is there a way to exclude specific top-level decls from a haddock?
13:59:32 <Welkin> I still have yet to do anything with TypeInType or DataKinds or type families
13:59:43 <Welkin> I should learn how to use them
13:59:46 <monochrom> I can't think of an example of how to use it (and how to use it to cause more infinite loops).  But GHC implementation has always been doing * :: *.  It just doesn't let you use it normally.
14:00:56 <dminuoso> Mm, I guess the finer details are hidden here http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf
14:01:13 <Welkin> fck kind? haha
14:01:23 <monochrom> In other words GHC has never stratified Type_0 ≠ Type_1 ≠ Type_2 ≠ ...
14:01:51 <Welkin> nice paper
14:01:53 <Welkin> thanks dminuoso
14:01:59 <cement> I call "type fitting" "type putting practice"
14:02:07 <Welkin> yet another paper to add to my collection
14:02:20 <Welkin> I should have all of these printed and bound into a book at some point
14:04:19 <Welkin> what was the other name for it?
14:04:34 <Welkin> I can't think of it, but I have talked about it a lot already O.o
14:05:20 <Welkin> type unification!
14:05:22 <Welkin> that was it
14:05:45 <monochrom> Unification is exponential time for computers, so nevermind humans.
14:06:27 <Welkin> but humans are extremely good at finding patterns
14:06:30 <Welkin> computers are not
14:06:47 <dminuoso> Welkin: I dont know, neural networks seem to become exceedingly good at it.
14:06:58 <monochrom> No no.  You are extremely good.  My students are extremely poor.
14:07:08 <metahumor> dminuoso: confirmation bias, only NNs that people designed and published
14:07:18 <metahumor> so easy to make a useless NN
14:07:37 <metahumor> i borked my cabal somehow...
14:07:44 <monochrom> Do not mistake "smart humans" for "humans".
14:08:00 <Welkin> computers are good at one thing only: raw computational power
14:08:46 <lavalike> they are pretty decent entertainment too
14:08:46 <johnw> i preferred smoked computational power
14:08:54 <hpc> heh
14:09:00 <dminuoso> Furthermore humans beat computers in terms of brute force too. Ever seen one of those cage fights between a wrestler and a Commodore 64?
14:09:37 <Welkin> dminuoso: lucha libre?
14:10:03 <hpc> back then it would have been lucha OO.o
14:10:16 <dminuoso> Welkin: run/stop keys flying everywhere.
14:10:28 <monochrom> I taught them algebraic data types with an example "data MyType = Nada | Duplet Double String | Uno Integer", explained a bit.  I also showed a binary search tree example "data BST = Empty | Node BST Integer BST" and walked through code for the BST insert algorithm.
14:11:05 <monochrom> Then on the assignment I had like "data Atom = Pos String | Neg String".  And they asked "where is Pos declared? I can't find it on Google".
14:11:17 <monochrom> So you try to tell me these humans are good at patterns.
14:11:28 <dminuoso> monochrom: What is your profession?
14:11:33 <monochrom> Or you try to tell me they don't qualify for humans.
14:11:42 <monochrom> I'm teaching these students.
14:11:44 <Welkin> headmistress at an orphanage?
14:12:21 <Welkin> "please sir, may I have s'more porridge?"
14:12:37 <Welkin> "Define `fix` first!"
14:12:46 <metahumor> how am I supposed to use "cabal test" after a "cabal new-build"? I'm getting "missing packaged" for HUnit, for example
14:13:15 <metahumor> i had a "cabal new-configure -w ghc-8.0.2 --enable-tests"
14:13:31 <hpc> monochrom: i saw that a lot going through hs/college, where people wouldn't realize what was important to remember
14:13:39 <MarcelineVQ> as I understand it, but could bew rong, new-* are used with new-*  if there's not a new-test you're probably out of luck currently
14:13:57 <hpc> so they would memorize and forget and move on, and kind of go through the semester in a haze of call-and-response conditioning
14:14:25 <Welkin> yes, rote memorization without understanding is common, but it depends on the culture they come from, too
14:14:30 <metahumor> MarcelineVQ: I ended up doing "cabal install --only-dependencies --enable-tests", which made it work, but i think i'm doing some weird combination of old-build and new-build
14:14:39 <Phyx-> metahumor: I believe there's a cabal new-test
14:14:45 <monochrom> Oh they suck at rote memorization too.
14:14:47 <hpc> and since that kind of mistake is understandable when you're first learning ADT syntax, it would make sense for it to be a repeat mistake
14:14:56 <metahumor> "new-test" is listed as unsupported
14:15:11 <hpc> GADT syntax doesn't have that issue, though it has its own barriers to understanding
14:15:29 <dminuoso> hpc: Honestly it's a bit confusing with a type constructor on the one side, data constructor name on the other side, and then some more types.
14:15:32 <dminuoso> Kinds flying everywhere.
14:15:36 <Welkin> it is
14:15:38 <hpc> dminuoso: yeah
14:15:41 <Welkin> I was confused when I first learned too
14:15:51 <Welkin> I tried to make the distinction clear in the first chapter of my book
14:15:53 <hpc> what's a type, what's a value, and what's being defined vs used is all over the place
14:16:00 <Welkin> I should probably also add a diagram to explain it better
14:16:32 <hpc> data DefinedType parameterType = DefinedValue UsedType parameterType | ...
14:17:00 <MarcelineVQ> data Typename Kind where Constructors hehe
14:17:06 <dminuoso> And for maximum confusion make sure you use the same name for the type and data constructor.
14:17:34 <hpc> GADT syntax matches up nicely with class/instance syntax
14:17:54 <hpc> keyword Weird Stuff Here where <top-level definitions, but indented>
14:17:56 <dminuoso> hpc: I suppose learning `GADTs` straight off the bat might be easier than learning that..
14:18:08 <dminuoso> I mean there's really nothing scary about GADTs.
14:18:12 <hpc> agreed
14:18:23 <hpc> i wouldn't complain if they were suddenly on by default
14:18:23 <monochrom> Just can't use "deriving (Show, Eq)"
14:18:27 <Welkin> but then you have to tell them to add a language pragma to the file
14:18:34 <Welkin> and explain what that magic incantation is for
14:19:06 <hpc> @let data Foo where Foo :: Foo deriving (Show)
14:19:07 <lambdabot>  .L.hs:171:9: error:
14:19:07 <lambdabot>      Multiple declarations of ‘Foo’
14:19:07 <lambdabot>      Declared at: .L.hs:158:31
14:19:15 <hpc> @let data FooBar where FooBar :: FooBar deriving (Show)
14:19:16 <lambdabot>  Defined.
14:19:23 <hpc> @undefine
14:19:23 <lambdabot> Undefined.
14:19:57 <MarcelineVQ> I like that about idris, how data Foo = MkFoo Int  and data Foo : Type where Foo : Int -> Foo  are both available all the time and get introduced together in learning material
14:20:17 <MarcelineVQ> *where MkFoo
14:20:23 <dminuoso> MarcelineVQ: Is Idris : equivalent to Haskell's :: ?
14:20:27 <MarcelineVQ> yes
14:20:30 <dcoutts_> metahumor: in the current git version the new-test command and I think works but currently it only builds the tests and does not yet run them, but you can run the executables that it builds manually
14:20:50 <hpc> dminuoso: haskell is actually the odd one out, most MLs use (defn : type) and (element :: list)
14:20:59 <metahumor> dcoutts_: thanks for the info, i might try it
14:21:06 <MarcelineVQ> hpc: all dem lists :D
14:21:33 <Welkin> many languages use : for types
14:21:36 <dminuoso> hpc: Mmm, doesn't HM use : to mean "has type" ?
14:21:38 <Welkin> imperative ones too
14:21:42 <dminuoso> Or is it even older?
14:21:45 <Welkin> : is from math
14:21:46 <hpc> rust uses :
14:21:51 <Welkin> it means has type
14:22:14 <hpc> does anyone know why haskell switched syntaxes?
14:22:17 <Welkin> yes
14:22:17 <MarcelineVQ> lists :D
14:22:28 <Welkin> they thought lists would be written more often than type signatures
14:22:32 <monochrom> Huffman code.  Frequently used symbols shorter.
14:22:38 <hpc> weird
14:22:38 <Welkin> it doesn't bother me at all
14:22:44 <MarcelineVQ> haskell is crazy about lists, and inferred is very good,  so : is less typing than :L:
14:22:46 <MarcelineVQ> *::
14:22:56 <metahumor> "Haskell : Lists :: Lisp : SExprs"
14:22:57 <hpc> yeah, the funny thing is i like :: for has-type because it's bigger
14:23:17 <MarcelineVQ> gosh, my typing today, basically since types can be specified less often : becomes better list notation
14:23:36 <parsnip> i miss liking `f : X -> Y`
14:23:37 <hpc> it's a great big double-width "this is a type signature!" seared into the pattern-recognizing center of your brain
14:23:55 <parsnip> `x \mapsto y = f(x)`
14:24:00 <Welkin> when I see pattern like `a :: b :: c :: []` it just looks wrong
14:24:10 <Welkin> in, for example, idris
14:24:31 <hpc> i think analyzing it by what's typed more frequently is a mistake
14:24:38 <dminuoso> Welkin: well dont you have [,] sugar?
14:24:42 <Welkin> :: reminds me too much of how it is used in c++ or other languages
14:24:55 <hpc> it's the kind of thing that riddles a language with udword_t and such
14:25:03 <Welkin> or from this rust book: use std::io::Write;
14:25:21 <hpc> the size of syntax should be analyzed by what should stand out most to the reader
14:25:46 <hpc> and since types are more important than cons cells, type signature syntax should be larger
14:25:56 <Welkin> and unicode?
14:26:22 <monochrom> You're right. Huffman code is also why = doesn't mean equal.
14:26:28 <hpc> i think using unicode has an accessibility cost
14:26:37 <Welkin> it does
14:26:38 <hpc> which is usually paid back in "i can use my native language now" benefits
14:26:48 <Welkin> but there are ways to view your code with unicode characters without actually using them
14:26:51 <hpc> but not when you're using fancy ":" vs ascii ":"
14:26:58 <Welkin> I'd like to find that emacs extension
14:27:01 <MarcelineVQ> it's payd back in, now I have more operator symbols to choose from. woe be to the reader.
14:27:02 <hpc> or combining "::" into a single width
14:27:28 <MarcelineVQ> adga papers are rife with unicde operators I couldn't even begin to type without precarious lookups
14:27:36 <hpc> i want my (->) to be huge, so the shape-seeing part of my brain recognizes functions
14:27:43 <Welkin> agda is not meant to be run
14:27:44 <hpc> it's way more efficient than actually scanning the characters
14:28:36 <parsnip> i think that's why we like `.` over `$`, i think it's easier to see
14:28:45 <MarcelineVQ> hpc: ru-ro raggy :> is  Foo a  a function?
14:29:14 <parsnip> haskell. where $ has the lowest precedence.
14:29:15 <dminuoso> hpc: There have been plenty studies that suggest olfactoric impressions can trigger strong memories. How would you like to _smell_ your types?
14:29:26 <pja> Welkin: emacs + the right font works OK.
14:29:32 <MarcelineVQ> dminuoso: real code smell?
14:29:40 <monochrom> haha
14:29:53 <Welkin> I hate that term "code smell"
14:29:56 <Welkin> it's so cliche
14:30:03 <Welkin> obnoxious
14:30:03 <MarcelineVQ> do you like things Welkin?
14:30:04 <monochrom> Me too.
14:30:05 <Welkin> and it sounds gross
14:30:07 <metahumor> code fragrance
14:30:10 <metahumor> code stink
14:30:18 <metahumor> code flavor
14:30:24 <Welkin> how about "poor programming practice"
14:30:26 <monochrom> Also, calling things "it's an anti-pattern" is an anti-pattern.
14:30:37 * ski smiles
14:31:09 <Welkin> MarcelineVQ: I don't like jargon
14:31:12 <Welkin> if that's what you mean
14:31:25 <Welkin> it only confuses
14:32:32 <metahumor> jargon is just Huffman encoding over words
14:32:35 <parsnip> which is why you hate haskell?
14:32:47 <monochrom> hehehe
14:32:49 * ski thinks jargon can be useful, in particular restricted audiences
14:32:51 <parsnip> "omg, he's such a monad"
14:33:04 <parsnip> "what a functor"
14:33:06 <Welkin> monad is the creator of the universe
14:33:06 <ski> @where haskel
14:33:06 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
14:33:09 <Welkin> monad is god
14:33:13 <Welkin> according to philosophers
14:33:15 <Welkin> it is the singularity
14:33:27 <metahumor> i would think comonad is more godlike
14:33:28 <parsnip> [citation needed]
14:33:32 <MarcelineVQ> like that famous story The Monad in God's Eye
14:33:40 <Welkin> https://en.wikipedia.org/wiki/Monad_(philosophy)
14:33:42 <ski> (actually wasn't it the other way around, god would be a particular monad ?)
14:33:55 <Cale> Welkin: etymologically different one :)
14:34:33 * ski thinks it was said somewhere that category terrorists likes to steal terminology
14:35:02 <metahumor> "abstract guerrila nonsense"
14:35:36 * ski . o O ( "nom nom de guerre" )
14:36:06 <Cale> I heard it suggested somewhere that "monad" is a portmanteau of "monoid" and "triad"
14:36:55 <Welkin> the holy trinity?
14:37:07 <Cale> Until people came up with this name, monads were referred to as "triples" or "triads" or "the standard construction"
14:37:09 <ski> it wouldn't surprise me if that's a backronym
14:37:09 <Welkin> functor-applicative-monad?
14:37:24 <metahumor> why aren't we using the word "mobit" as much as was suggested?
14:37:38 <Cale> i.e. the "triple" refers to (T,η,μ)
14:38:33 <Cale> But of course, being monoid objects in a category of endofunctors gives you the other side of that
14:38:46 <Welkin> monad the father, functor the son, and applicative the holy ghost
14:39:15 <Welkin> Cale: I can't think of anything but that meme when anyone says that phrase
14:39:31 <ski> Welkin : <https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/>,<https://prezi.com/fnz-4wzsygiq/computational-trinitarianism/>
14:39:59 <Cale> Welkin: which meme?
14:40:20 <parsnip> i hope you all know, i take the cool links and simply retoot them on mastodon
14:40:56 <metahumor> mastodon?
14:41:15 <parsnip> twitter for the people
14:41:39 <parsnip> seems to be doing better than for example diaspora
14:41:56 <ski> (Welkin : also see <https://existentialtype.wordpress.com/2011/03/16/languages-and-machines/>)
14:42:25 <metahumor> at my previous work, we named all our machines after extinct animals -- now when i see "mastodon" i can only think about a mediocre laser printer
14:43:13 <Welkin> Cale: what's the problem?
14:43:42 <Cale> okay, so just the thing itself ;)
14:45:46 * ski . o O ( "Das Ding an sich")
14:47:37 <Welkin> Leci n'est pas une pipe. :D
14:48:21 <Welkin> Ceci n'est pas une pipe. :D
14:48:22 <Welkin> o.o
14:51:02 <Welkin> I wonder if it is possible to write a program that can correctly analyze Jean-Paul Sartre
14:51:33 <parsnip> Cale: was it you who made the Data.List diagrams?
14:51:42 <Welkin> the foldr/foldl ones?
14:51:50 <parsnip> yes, and scan and mapAccum
14:52:09 <Welkin> I think so
14:52:15 <Welkin> I don't remember where I found it
14:52:18 <Welkin> but I saved the image
14:52:42 <byorgey> yes, it was Cale IIRC
14:53:08 <Welkin> where is it posted?
14:53:11 <Cale> byorgey: yep
14:53:16 <parsnip> does this need more complete attribution? those should not be lost. https://bradyt.com/haskell/someones-data-list-diagrams/
14:55:31 <Cale> Well, if you want to say they're due to me (Cale Gibbard), I wouldn't mind :)
14:56:16 <parsnip> yes sir, thank you again for sharing them, they are very nice!
14:56:34 <Cale> The idea of making such diagrams isn't mine, but I'm the one who actually drew those ones.
14:56:54 <Cale> People have been thinking of code as graphs in that way for a long time
14:58:59 <ski> @where folds
14:59:00 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
14:59:44 <ski> (used to have a `cale.yi.org' domain, iirc)
15:01:57 <Cale> I should be able to get that back up on cale.hn.org
15:02:11 <Cale> (though hn.org goes down half the time now too...)
15:02:25 <parsnip> heh. "Hi."
15:02:56 <Welkin> why not just host on S3?
15:03:00 <Welkin> or a similar service
15:03:21 <Cale> hn.org is just a subdomain provider
15:03:23 <Welkin> it's $0.51 a month for my static sites (plus a few pennies for bandwidth/storage)
15:03:27 <Welkin> I know
15:04:10 <Cale> I just host things on my desktop machine usually.
15:06:13 <Cale> and I need the DNS regardless (since e.g. I often end up needing to test our mobile apps against a backend running on my desktop)
15:06:35 <Cale> but sure
15:12:40 <parsnip> @hoogle (a -> b -> c -> d) -> ((a, b, c) -> d)
15:12:40 <lambdabot> Data.Tuple.HT uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
15:12:41 <lambdabot> Data.Tuple.Lazy uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
15:12:41 <lambdabot> Data.Tuple.Strict uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
15:17:35 <Cale> parsnip: I'd typically just pattern match the triple somewhere.
15:24:56 <parsnip> well, a lambda seemed brief enough, but i'm like a kid in a toy store.
15:25:37 <parsnip> just `(\(d, k, n) -> test d k n)`
15:27:40 <catern> hmm, how can I achieve a typed interface for providing a Unix program's arguments? i.e. a structured interface that crosses the Unix process boundary, but just for startup; in general this is the problem of IPC/RPC, but all I care about is startup. does anyone know of such a thing?
15:32:06 <lyxia> Is there a package for Generic deriving of classes in base? (generic-deriving doesn't do that, it has its own copies of those classes)
15:32:13 <Cale> catern: Well, you can come up with a type which is isomorphic to the valid sequences of arguments to the program in question
15:33:27 <ski> (hm, sometimes some options imply other options. or two options are incompatible with each other. it'd be nice to be able to express such things, perhaps in some notation inspired by logic programming)
15:34:26 <metahumor> lyxia: have you seen jle`'s generic-lift and one-liner-instances?
15:34:39 <ski> (abstractly inspired, i.e. .. not necessarily reusing the concrete syntax)
15:35:56 <catern> Cale: sure, I mean in a more low-level sense though... like, how do I distribute a typed interface along with the program
15:36:29 <Cale> catern: Oh, well, typically you don't? I suppose you could distribute a Haskell library which runs your program correctly :)
15:37:05 <lyxia> metahumor: Thanks, I knew about one-liner-instances, but not generic-lift. Unfortunately I also need a generic Show, that these don't offer.
15:37:07 <Cale> (or if it's written in Haskell, you could make it into a library itself)
15:37:26 <catern> yeah, except if I have a Haskell library then I lose the benefit of running in a separate process: I can use different library versions or a different language entirely
15:38:06 <metahumor> lyxia: generic-deriving has GShow, no?
15:38:17 <Cale> Unix certainly doesn't know about types at the level of program arguments
15:38:35 <Cale> We can imagine an OS which did
15:38:54 <catern> sure, sure, so you'd have a typechecking layer on top
15:39:21 <Cale> It would be really pretty interesting to have an extensible system of types at the level of the OS and filesystem
15:39:24 <catern> I think if I have some kind of typed interface for my program and I typecheck against that at build time, that seems pretty typed to me
15:40:17 <Cale> catern: You can always write a separate main' which takes Haskell-typed arguments
15:40:34 <Cale> and then have main just do the argument parsing
15:40:43 <catern> that's what I do currently anyway :)
15:40:55 <lyxia> metahumor: generic-deriving is a parallel world, GShow is a copy of Show, but they don't interact.
15:46:21 <metahumor> lyxia: thanks for clearing that up for me
15:46:39 <lyxia> :)
15:47:06 <metahumor> I'm currently going through the data61 course, currently solving "flatMap"... makes me think, how does ghc do fusion/building in regular concatMap?
15:47:29 <metahumor> i've looked at some sourcecode from base, saw "_FB" functions, but I don't understand what they do
15:47:47 <parsnip> i guess foldr can't stop at a point? but with scanr and takeWhile, i can stop?
15:47:50 <lyxia> It seems like I could just fork generic-deriving, but I want to make sure it doesn't already exists.
15:49:47 <lyxia> metahumor: did you see the "concatMap" rewrite rule in GHC.List
15:50:24 <metahumor> similarly to the question above, "Safe" defines "lastMay". but is that actually "safe", given that it won't terminate on infinite lists? does this bring me into the whole "codata" discussion?
15:50:27 <metahumor> i'll take a look now
15:51:17 <Axman6> metahumor: anything which is defined using foldr should automatically benefit from foldr/build fusion
15:52:06 <Axman6> but also, if you're only just started learnig haskell with the Data61 course, it may be a bit too soon to be thinking about these problems
15:53:05 <metahumor> haven't just started, just decided to do the exercises on a whim
15:53:18 <metahumor> to get the proverbial juices flowing
16:02:05 <gestone> is there a nice way to serialize a data type into request params? say if i have some type of Foo {a :: Text, b :: Text} and i want Foo to transform into a string like "baseurl.com/auth?a=valueofa&b=valueofb"
16:04:06 <metahumor> gestone: have you used Wreq at all?
16:04:25 <gestone> metahumor: never have
16:04:47 <metahumor> https://hackage.haskell.org/package/wreq-0.5.2.0/docs/Network-Wreq.html#v:getWith
16:04:47 <gestone> i'll look into it
16:04:48 <metahumor> for example
16:04:58 <metahumor> its a batteries-included requests library
16:05:30 <gestone> oh my it has lenses too
16:05:36 <metahumor> gestone: i didn't really answer your question, i went past it
16:06:25 <metahumor> gestone: more low-level: https://hackage.haskell.org/package/http-types-0.12.1/docs/Network-HTTP-Types-URI.html#t:Query
16:06:49 <metahumor> specifically, "QueryText" and associated methods
16:07:26 <gestone> ohh neat
16:09:23 <gestone> metahumor: do you have a preference over what lib to use?
16:09:49 <metahumor> i've used wreq to play with online wargames
16:10:03 <metahumor> wreq wraps a lot of HTTPTypes and related libs for you
16:10:11 <gestone> ahh
16:10:13 <metahumor> but it can get lens heavy.
16:10:27 <metahumor> and i don't know if you want to deal with cookies / auth
16:10:30 <gestone> should i learn how to use lenses before attempting to use it?
16:10:52 <metahumor> it's still worth it because you won't have to write your own StatusCode handling for example
16:11:06 <metahumor> gestone: i think the tutorial for wreq is pretty straightforward where you don't need lens
16:11:18 <metahumor> or a deep understanding, i mean
16:11:24 <metahumor> serpentine.com/wreq/tutorial.html
16:11:28 <gestone> got it
16:11:32 <gestone> yeah on that page right now
16:11:59 <gestone> hm lenses look like... the dot notation from OOP like langs?
16:12:07 <metahumor> partially
16:12:10 <gestone> probably more complicated than that
16:12:33 <metahumor> the type errors with Lenses can get very confusing unfortunately, even for "simple" usage
16:12:53 <gestone> oh :(
16:13:09 <metahumor> gestone: what are you trying to do?
16:13:45 <gestone> oh i'm just trying to work with OAUTH with the linkedin API
16:15:23 <dminuoso> metahumor: Tell me about it. A few days ago I tried to understand why I couldnt compose this
16:15:26 <dminuoso> > ['a', 'b'] ^? ix 0 . non 'c'
16:15:28 <lambdabot>  error:
16:15:28 <lambdabot>      • Couldn't match type ‘Maybe Char’ with ‘Char’
16:15:28 <lambdabot>        Expected type: (Maybe Char -> Const (First Char) (Maybe Char))
16:15:39 <dminuoso> I still dont understand how to read the documentation to _know_ this is not possible
16:15:53 <Axman6> :t ix 0
16:15:54 <lambdabot> (Applicative f, Num (Index m), Ixed m) => (IxValue m -> f (IxValue m)) -> m -> f m
16:16:04 <Axman6> :t non
16:16:05 <lambdabot> (Functor f, Profunctor p, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
16:16:06 <dminuoso> Axman6: yeah you were there and explained it :)
16:16:11 <dminuoso> But I still didnt fully grok it
16:16:16 * Axman6 for the win
16:16:18 <dminuoso> Heh
16:16:43 <Axman6> annoyingly :type doesn't give you the type aliased type, which would be clearer
16:17:07 <Axman6> :info does in GHCi I believe (but can't be used for whole expressions)
16:17:15 <Axman6> :t ix 0 . non 'c'
16:17:16 <lambdabot> (IxValue m ~ Maybe Char, Applicative f, Num (Index m), Ixed m) => (Char -> f Char) -> m -> f m
16:17:52 <dminuoso>   :: (IxValue m ~ Maybe Char, Applicative f, Num (Index m),Ixed m) =>(Char -> f Char) -> m -> f m
16:18:13 <metahumor> yeah that won't work
16:18:39 <metahumor> > fmap Just ['1', '2'] ^? ix 0 . non 'c'
16:18:40 <Axman6> metahumor: how're you finding doing the course without going to a course? There's alot that isn't written down which Tony says when we present the course
16:18:42 <lambdabot>  Just '1'
16:18:57 <Axman6> :t re _Just
16:18:58 <lambdabot> (Functor f, Contravariant f) => (Maybe a -> f (Maybe a)) -> a -> f a
16:19:31 <metahumor> Axman6: i feel okay, i'm at a level of familiarity with the various functions, how they're used, and i've seen the sourcecode for their "canonical" equivalents that I get the flow
16:19:36 <dminuoso> The curious thing is, I know what all those constraints say - just those lens types are really.. opaque.
16:20:02 <metahumor> Axman6: it wasn't great when I wrote "headOr = foldLeft (flip const)" and had to reboot my computer because it hung on the tasty tests
16:20:21 <metahumor> "I don't even see the symbols anymore, I just see the lens in the red dress"
16:20:47 <metahumor> Axman6: but other than, it's cool. i'm trying to use cabal new-build with it, not the most straightforward experience
16:21:00 <metahumor> Axman6: were there particular difficulties you were thinking of?
16:22:06 <metahumor> Axman6: as an aside, you might want to include "--test-option=--color=always" for the "cabal test tasty" example, it wasn't obvious how to pass the color flag to test/tasty
16:22:27 <Axman6> metahumor: feel free to file a bug :)
16:22:50 <Axman6> I don't do much directly on the repo
16:23:03 <n_blownapart> welp, at least I can read and understand other people's solutions to book exercises.
16:23:43 <MarcelineVQ> naughty people, posting solution
16:24:02 <Axman6> dminuoso: are you familliar with how van laarhoven lenses work? once you get used to the pattern they become very easy to read
16:24:52 <n_blownapart> oh lordy, MarcelineVQ I just couldn't come up with solutions. My crowning achievement is writing pascal's triangle in scheme without help
16:25:38 <Axman6> type Lens s t a b = Functor f => (a -> f b) -> (s -> f t) is the general pattern, a function which when given a function can produce  result in any functor on the focus type can product a function which can produce a result in any functor of the larger type
16:25:54 <gestone> sort of a random question, but is there a reason why the underlying implementation of the String type is with a linked list and not an array?
16:26:15 <metahumor> whenever i read var Laarhoven, i think about Verhoeven's movies
16:26:35 <Axman6> because lists are extremely easy to deal with and are fundamental when learning Haskell
16:26:51 <metahumor> gestone: because haskell lists are the more "basic" type. not a great choice. Text is pinned against some better representation iiuc
16:27:13 <hpc> Text is a UTF-16 encoded bytestring
16:27:21 <hpc> or something like that
16:27:37 <pavolzetor> in the IRBuilder, is there a simple way to switch blocks?
16:27:40 <Axman6> not a bytestring but yes
16:27:55 <Axman6> pavolzetor: gonna need some more context to that question
16:28:02 <gestone> so is it mainly for academic and learning purposes that String is implemented as a linked list?
16:28:23 <dminuoso> Axman6: Okay let me digest that. :D
16:28:30 <Axman6> it is implemented that way because it is simple and understandable
16:29:01 <dminuoso> gestone: Also the way its implemented with pattern matching very naturally forces you to implement elegant algorithms (with horrible runtime complexity)
16:29:19 <pavolzetor> Axman6, llvm-hs-pure, IRBuilder.Monad, it seem that the state can keep track of only one partial block
16:29:30 <gestone> ahh
16:30:01 <pavolzetor> I want to add simple branching, so I tried to generate the names first and do the blocks in order, but that gives me runtime error that the forward blocks do not exist
16:30:40 <pavolzetor> So I guess I have to generate the merge block first, then if and else blocks, and at the end the conditional test block
16:31:53 <dminuoso> Axman6: Oh I think Im getting it. So the classic monomorphic (simple) case is when a ~ b and s ~ t
16:32:21 <Axman6> yep
16:32:33 <dminuoso> Axman6: So I guess I cant freely pick s/t/a/b ..
16:33:51 <metahumor> just don't freely stab
16:34:25 <pavolzetor> I think I sort of need 3 partial blocks
16:34:59 <pavolzetor> but I have no idea how to use the builder API to actually do it in a sane way, llvm-hs-examples have no branching exampl
16:35:00 <pavolzetor> e
16:35:32 <pavolzetor> curious if anybody used it
16:37:07 <Axman6> dminuoso: yes, though they will usually be related, for example, Traversal [a] [b] a b makes sense, but Traversal [a] [b] c d doesn't
16:37:53 <Axman6> pavolzetor: you might want to make an issue on the repo to ask for better examples, I don't know of anyone else who's using the library here
16:38:33 <pavolzetor> I see, it could be nobody uses that library yet as it may be new
16:38:51 <pavolzetor> I will report the issue, thanks
16:39:01 <Axman6> well, I'm pretty sure Stephen Diehl does
16:39:21 <Axman6> see also http://www.stephendiehl.com/llvm/
16:39:45 <pavolzetor> He does not use IRBuilder API
16:40:09 <pavolzetor> just roll his own (which I should have done too)
16:41:07 <pavolzetor> the problem is trivial, I am just confused about how to effectively use the API; for now I may just build partial blocks and change the active block by modifying the state directly
16:41:35 <Axman6> I would still recommend making a ticket to see if you're missing something
16:41:46 <Axman6> I mean, branching is pretty fundamental
16:41:55 <pavolzetor> There is one issue about more examples, so I will ask there
16:42:34 <pavolzetor> Yep, and it is easy, in my compiler for C, I generate control flow graph myself and it is trivial
16:42:47 <Axman6> gestone: btw, there are some big advantages to using String, it handles unicode extremely well
16:42:49 <pavolzetor> They have example of branching (function call :))
16:43:48 <Cale> Well, String handles unicode extremely okayish
16:44:07 <Cale> It doesn't handle toLower quite right
16:44:18 <Axman6> yeah that's true
16:44:19 <Cale> (because you have to do it on a Char by Char basis)
16:44:42 <kadoban> It doesn't really do normalization or anything either, right? But that usually doesn't come up *too* much
16:44:47 <gestone> Axman6: do other string representations not like Text?
16:45:26 <Axman6> There are issues with both. unicode is _hard_
16:45:33 <Axman6> (ask Apple)
16:45:50 * Axman6 he types from his MacBook Pro
16:45:52 <kadoban> Ya, getting everything *exactly* correct in all cases is kind of ridiculously impossible
16:46:24 <gestone> o_o how so?
16:47:33 <bitemyapp> unicode is extremely complicated
16:48:01 <bitemyapp> for one thing, not every code point can be construed to be a whole character, number, or rune
16:48:17 <parsnip> full-width or half-width?
16:49:03 <metahumor> written human language was a bad idea
16:49:05 <kadoban> gestone: There's a bunch of really complicated parts. Combining characters come to mind, as well as normalization. Just trying to see if two unicode strings "mean" the same thing is ... involved. And then you can get into ordering them
16:49:52 <c_wraith> fun with Unicode abuse: http://www.eeemo.net/
16:50:06 <c_wraith> it was never meant to do that - but it does that.
16:50:14 <gestone> ohh hm. so it's not as easy as ASCII that can be represented in one byte
16:51:06 <kadoban> Not really, no. Even if you expand to "well, they're not bytes, but let's just look one character at a time", you still miss a lot of corner cases. But you can get a lot farther that way anyway
16:51:24 <gestone> c_wraith: what... is this
16:52:27 <c_wraith> gestone, it abuses diacratics and combining characters to prove Unicode isn't meant to be understood by humans.
16:52:30 <metahumor> accursedUnutterableIO... it comes
16:52:34 <MarcelineVQ> gestone: an old meme but a good one
16:52:56 <metahumor> what's much scarier are confusables in web URIs
16:53:04 <gestone> holy...
16:54:23 <gestone> wow so we can't just take a look at bytes of the unicode characters, but there's a whole spec written about how to compare them
16:54:27 <gestone> http://unicode.org/reports/tr15/
16:54:33 <gestone> well tIL
16:54:34 <gestone> TIL
17:09:55 <kadoban> Yep :-/ it's fairly annoying. You can mostly get by in a lot of circumstances without worrying about it much though, thankfully. At least it's better than just assuming ASCII
17:11:35 <Naergon> a few question about haskell and lisp - how close are they? it seems they share some common features. What is their main difference? And some main stuff about haskell - is it compile(like c)/vm like (like java or lisp)/interpreter(like python)?
17:11:51 <Cale> Naergon: Pretty far
17:12:15 <monochrom> We have GHC which is both compiler and interpreter.
17:12:36 <kadoban> Naergon: They are extremely different. They share some basic, abstract ideas.
17:13:16 <metahumor> Naergon: by question: haskell is compiled and strongly typed (unlike lisp). they are both functional. it compiles into machine code (like c), but has some other variants that work on the JVM. you can do REPL-like interpreting using ghc as well
17:13:38 <monochrom> Although, these days "interpreter" simply means bytecode and VM but not exposed to you.
17:14:11 <metahumor> there is no JIT for haskell afaik
17:14:22 <Cale> Different lisps qualify to different extents at being functional languages. Common lisp actually kind of fights you if you try too hard to program in a functional style
17:14:48 <Naergon> thank you, repl is what i was interested about (ability to compile in milliseconds)
17:14:49 <Cale> Scheme is better at it
17:15:22 <monochrom> Although I am disappointed that Scheme functions are not curried by default.
17:15:57 <monochrom> I wrote (define (f x y) ...)  and then "what?! (map (f 5) '()) is an error?!"
17:16:23 <monochrom> Completely disenchanted.
17:17:30 <monochrom> So basically I can't tell my students "(map f) = (foldr (lambda (x r) (cons (f x) r)) '())"
17:19:19 <monochrom> I don't mean to be painfully pointfree.  But I can't even say "let g = (map f), so I can talk about (map f lst) as (g lst)"
17:20:01 <monochrom> Outside Scheme, "let g = map f" is actually a thing.
17:24:29 <gestone> monochrom: yeah, that's one of the qualms that i had about scheme when i was learning it. though explicitly declaring the lambdas in scheme made it easier to understand what currying actually is
17:27:24 <fresheyeball> Can anyone give me an example of a bijective function in Haskell that is not reversable?
17:27:56 <metahumor> a lossy function?
17:28:14 <fresheyeball> metahumor: idk what you mean
17:28:20 <monochrom> Add "not reversible in polynomial time" and you have cryptographical examples.
17:28:21 <metahumor> Data.ByteString.Char8.pack
17:28:45 <Cale> metahumor: lossy functions usually are not bijective
17:29:01 <fresheyeball> metahumor: Data.ByteString.Char8.unpack ?
17:29:26 <fresheyeball> I thought pack was reversible with unpack
17:30:10 <metahumor> only for values that fit in 8 bits
17:30:26 <Cale> fresheyeball: Hmm, what do you mean by "bijective"? You mean that it's some computable function that ZFC set theory can prove is bijective, but we can't compute the inverse?
17:30:47 <fresheyeball> Cale: yes
17:31:18 <fresheyeball> bijective as in a function where each element of the functions domain maps to a unique element of the codomain, such that every element of the codomain corrosponds to an element in the domain.
17:31:25 <Cale> Let's just think about functions Nat -> Nat for a moment. If we have a computable bijective function of that type, then its inverse has to be computable, just by enumerating values of the function until we find the one we're looking for.
17:31:26 <fresheyeball> but in this case, we can't reverse it
17:31:58 <monochrom> Clearly, a computable bijection's inverse is computable.
17:32:01 <fresheyeball> right now it seems to me that every bijective function in haskell is part of an isomorphism
17:32:43 <metahumor> what about a function that takes a composite of two large primes (pq) :-> the result of prepending the digits of p to q
17:32:52 <fresheyeball> is it more broadly the case that every bijective function can be reversed?
17:33:05 <Cale> i.e. you can do something like  g n = fromJust (find (\x -> f x == n) [0..]) -- and you know that the fromJust will succeed because f is assumed to be bijective (and so is surjective)
17:33:52 <Cale> But that's for an enumerable domain
17:34:32 <Cale> monochrom: What if our computable bijective function has a type like (Nat -> Nat) -> (Nat -> Nat)
17:35:10 <fresheyeball> :t ((+ (1::Nat) . )
17:35:11 <lambdabot> error: parse error on input ‘)’
17:35:20 <fresheyeball> :t ((+ (1::Nat)) . )
17:35:21 <lambdabot> error:
17:35:21 <lambdabot>     Not in scope: type constructor or class ‘Nat’
17:35:27 <fresheyeball> :t ((+ (1::Int)) . )
17:35:28 <lambdabot> (a -> Int) -> a -> Int
17:35:37 <monochrom> Since Nat->Nat is countable, let e be a bijection from it and Nat...
17:35:59 <Cale> Nat -> Nat isn't countable though
17:36:13 <monochrom> Haskell's -> is computable function.
17:36:36 <Cale> Well, haha, we have to clarify what's meant by countable too :)
17:37:35 <Cale> If this were something like Agda, I could explain what I mean better -- even though the collection of Agda-definable functions Nat -> Nat is countable, you can't prove that type is countable using Agda
17:37:47 <Cale> i.e. you can't produce a bijection Nat -> (Nat -> Nat)
17:39:11 <monochrom> I am exploiting the fact that we are working at the meta level when inverting a fixed bijection, rather than asking to write an algorithm that computes inverses in general.
17:39:39 <Cale> We still don't expect there to be a bijective function Nat -> (Nat -> Nat) in Haskell, but you can produce a bijection out in mathematics between a set model for Nat and a set model for Nat -> Nat consisting of only the Haskell-definable functions.
17:40:07 <monochrom> I.e., if you give me a particular f :: (Nat -> Nat) -> (Nat -> Nat) and ask me to invert f, I can study the source code of f, and I can think up an idea that's only good for f.
17:40:12 <Cale> (i.e. enumerate the Haskell closed terms of type Nat -> Nat)
17:42:13 <monochrom> And as a last resort I can conjure an enumeration of Nat->Nat that helps me invert f but probably not helpful inverting something else.
17:43:21 <monochrom> And as a last last resort I can enumerate AST's and use the GHC API (if I'm too lazy to implement Haskell in Haskell)
17:47:23 <Cale> You do end up with the problem that equality of Nat -> Nat isn't computable
17:47:49 <Cale> Even if you're satisfied with enumerating all the closed terms of type Nat -> Nat
17:48:48 <fresheyeball> hmm
17:50:49 <monochrom> Yeah. Overall I think I can exploit the fact that f is as clueless as me about the Nat->Nat space, so I just have to study f and outsmart it.
17:51:30 <Cale> If it were (Nat -> Bool) the answer might actually be different, amusingly
17:51:41 <monochrom> Yeah I heard that one.
17:52:20 <Cale> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ -- for anyone who hasn't seen it
17:52:23 <monochrom> Although, every mathematical technique f enjoys, I enjoy too; every impossibility I suffer, f suffers too.
17:52:59 <monochrom> "I am smart as f"  >.>
17:56:13 <EvanR> Cale: erm... can you not enumerate N -> N agda code, like godel numberings
17:56:37 <EvanR> esp since we have types and totality restrictions to guide the algorithm
17:57:09 <monochrom> Yes, but function extensional equality will be a problem.
17:57:22 <EvanR> who ordered that!
17:57:38 <monochrom> Naive brute-force inversion algorithm did.
17:58:48 <Cale> Yeah the original question is whether there are computable functions (Nat -> Nat) -> (Nat -> Nat) whose inverse is not computable
17:58:49 <monochrom> bruteForceInvert f y = head [ x | x <- space, f x == y ]
18:00:35 <EvanR> well, ones which have no inverse,
18:00:44 <EvanR> and i probably missed to much to catch up
18:03:01 <pacak> https://www.reddit.com/r/haskell/comments/7ysa87/tsuru_is_hiring/
18:06:44 <pavolzetor> why does sequence . fmap terminate, but mapM does not?
18:08:12 <parsnip> :t mapM
18:08:13 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
18:08:19 <parsnip> :t sequence . fmap
18:08:20 <lambdabot> (Monad m, Traversable ((->) (m a1))) => (a1 -> a2) -> m (m a1 -> a2)
18:09:11 <parsnip> pavolzetor: those don't really look the same. how are you trying to use them? can you share your code?
18:09:18 <pavolzetor> :t sequence . fmap id
18:09:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:09:40 <parsnip> :t traverse
18:09:41 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:09:41 <metahumor> pavolzetor: what is the type of "fmap" there?
18:10:07 <metahumor> pavolzetor: that'll help you see why they're not the same
18:10:37 <pavolzetor> fmap returns a monad
18:10:44 <metahumor> pavolzetor: write it out
18:11:20 <pavolzetor> fmap generateMir :: Functor f => f MIR.MIR -> f (Generator ())
18:11:47 <metahumor> :t \f -> sequence . fmap f
18:11:49 <lambdabot> (Monad m, Traversable t) => (a1 -> m a2) -> t a1 -> m (t a2)
18:13:02 <metahumor> that's what you want -- otherwise you'll be sequencing over the Monad instance for (->) e
18:13:30 <pavolzetor> I am confused; sequence . fmap generateMir   :: Data.Traversable.Traversable t => t MIR.MIR -> Generator (t ())
18:13:37 <pavolzetor> mapM generateMir   :: Data.Traversable.Traversable t => t MIR.MIR -> Generator (t ())
18:14:19 <metahumor> :t let (.:) = (.) . (.) in sequence .: fmap
18:14:20 <lambdabot> (Monad m, Traversable t) => (a1 -> m a2) -> t a1 -> m (t a2)
18:14:57 <metahumor> fmap "takes 2 arguments" (wrong, but bear with me). sequence "takes 1 argument".
18:15:14 <metahumor> that's why "mapM /= (sequence . fmap)
18:17:31 <metahumor> "mapM == \f -> mapM f"; "sequence . fmap == \f -> sequence (fmap f)"
18:17:58 <pavolzetor> I still do not get it, at least for the use in my code, their type is identical
18:19:21 <metahumor> :t negate . (+)
18:19:22 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
18:19:22 <parsnip> huh? i thought we saw above their type is not the same.
18:19:35 <metahumor> exactly. they're not the same
18:19:50 <metahumor> "sequence (fmap f)" doesn't make sense for your use case
18:22:23 <metahumor> parsnip: what confused you?
18:22:44 <parsnip> why the claim, "their type is identical"
18:23:44 <pavolzetor> ok, I think I got to the root of the issue, sequence hangs, sequence_ does not
18:24:10 <metahumor> i think pavolzetor was comparing his "mapM generateMir" and "sequence . fmap generateMir", which have the same types, so he tried to factor out "generateMir"
18:24:20 <fresheyeball> anyone want to give me feedback on this dumb thing I just authored?
18:24:23 <fresheyeball> https://gitlab.com/fresheyeball/control-iso/blob/master/src/Control/Isomorphic.hs
18:24:25 <pavolzetor> yep
18:24:50 <pavolzetor> do you have any clue why it hangs?
18:25:13 <metahumor> are you using the results of any of the generateMirs?
18:25:22 <metahumor> what happens when you run "traverse generateMir"
18:25:41 <pavolzetor> nope, they just modify internals of the monad
18:26:37 <pavolzetor> hangs
18:27:51 <pavolzetor> I am perplexed as the emit function I call is very simple
18:28:08 <pavolzetor> just concatenate text and returns ()
18:28:15 <pavolzetor> emit code = Generator $ \(str, nextLabel) -> ((), (str <> indent <> code <> "\n", nextLabel)
18:30:01 <pavolzetor> http://lpaste.net/362674
18:30:17 <pavolzetor> line 106
18:36:24 <pavolzetor> I added a trace to print something and indeed it loops forever on emit
18:36:36 <pavolzetor> how is that even possible
18:36:37 <pavolzetor> ?
18:37:48 <fourroot> im trying to code tic tac toe game in python.. i need a hint. how many functions do i have to write ? 1. welcome 2. draw board 3. input move and rest ?
18:37:57 <fourroot> haskell*
18:37:59 <fourroot> not python
18:40:59 <pacak> Can be one, can be 100...
18:41:16 <fourroot> if you were me, how many would you have wrote
18:41:40 <fourroot> i meant, if you were coding your own, what would be the rest of the functionS?
18:42:21 <pacak> I'd separate IO from the actual game logic - that will add some functions.
18:43:07 <pacak> In haskell functions are cheap to define and compiler is smart so no reasons not to do have more of them if it helps readability
18:43:43 <kadoban> fourroot: Probably best to just try it and see what looks good, then ask for a review
18:43:57 <pacak> http://chrispenner.ca/posts/type-tac-toe - an advanced version
18:45:03 <metahumor> or this post re tictactoe in haskell: https://ocharles.org.uk/blog/posts/2013-12-10-24-days-of-hackage-gloss.html
18:59:23 <pikajude> what's the point of Show1 vs Show?
19:00:53 <lavalike> pikajude: I think it's there to help you be more explicit
19:01:06 <pikajude> hm, ok
19:01:13 <pikajude> explicit with regards to what
19:02:07 <pacak> pikajude: https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Classes.html - some motivation at the very top.
19:02:32 <pikajude> why not instance (Eq1 f a) => Eq (T f a)?
19:02:35 <pikajude> err
19:02:36 <pikajude> Eq (f a)
19:02:38 <pikajude> wow, I really messed that up
19:02:57 <metahumor> different kinds, no?
19:03:00 <pikajude> instance Eq (f a) => Eq (T f a)
19:03:04 <metahumor> :t Eq
19:03:05 <lambdabot> error:
19:03:05 <lambdabot>     • Data constructor not in scope: Eq
19:03:05 <lambdabot>     • Perhaps you meant one of these:
19:03:08 <pikajude> yeah
19:03:19 <pikajude> well, of course you couldn't use "Eq f" there
19:03:27 <pikajude> but why is it needed at all?
19:03:34 <metahumor> lambdabot doesn't do ":k"
19:03:34 <pikajude> what's the difference between Eq (f a) and Eq1 f?
19:03:57 <pikajude> *using* Eq1 still requires Eq a
19:04:03 <pikajude> it looks like a pointless diversion
19:04:22 <metahumor> pointfree on kinds?
19:04:32 <pikajude> hmm ok
19:04:40 <pikajude> ok, i could believe that
19:04:57 <pikajude> though pointfree still seems like a luxury rather than a necessity
19:14:46 <glguy> pikajude: Eq (f a) only works for that particular a
19:15:01 <pikajude> yeah but it's just a type variable
19:15:06 <pikajude> it can represent anything
19:15:09 <glguy> anyone one thing
19:15:17 <glguy> not all things
19:15:43 <pikajude> got it
19:16:34 <metahumor> glguy: so Eq1 promises that (Eq1 f) => forall a . Eq (f a)?
19:17:25 <pikajude> I think it promises that if Eq1 f and Eq a, Eq (f a)
19:17:32 <glguy> eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool
19:17:45 <glguy> But the primitive operation is a little more flexible: liftEq :: (a -> b -> Bool) -> f a -> f b -> Bool
19:18:02 <pikajude> is there an example of this in practice?
19:18:14 <pikajude> i'm sort of seeing a resemblance to uh
19:18:17 <pikajude> ExistentialQuantification?
19:18:33 <glguy> No particular connection to that extension
19:18:39 <pikajude> that's not the one i'm thinking of then
19:19:04 <pikajude> sorry, i have absolutely zero academic background regarding this stuff
19:20:57 <pikajude> like, if you define a function that internally uses `catch` or `bracket` or something, and you need to pass it a handler, it has to be of the form (forall a. IO a -> IO a)
19:21:13 <pikajude> because without the `forall` that argument is bound to one particular type
19:21:28 <glguy> That's RankNTypes
19:21:39 <pikajude> okay. that's better
19:21:46 <pikajude> i knew it was an extension
19:21:50 <pikajude> that's about as far as i got
19:34:03 <blankhart> using ConstraintKinds, say I have defined type InformativeContext info monad = (HasInformation info, MonadReader info monad)
19:34:16 <blankhart> if i then say type InformativeContext2 monad = forall info monad . (HasInformation info, MonadReader info monad)
19:34:45 <blankhart> i get the error "A constraint must be a monotype."  What does that mean?
19:38:17 <blankhart> the GHC users guide on type families refers to a "monotype" as a type without foralls, but my understanding was that the first example above had implicit foralls
19:43:43 <blankhart> withdrawn. i think the problem is explicit quantification.
19:51:11 <MacSlow> As a haskell-novice I'm wondering how a single list-comprehension, such as [(x, y) | x <- [1,2], y <- [3,4]], could be re-written as a nested list-comprehension using a single generator in each list-comprehension. The sole purpose is to understand how a nested list-comprehension works. Thanks in advance!
19:51:26 <Welkin> what?
19:51:44 <parsnip> @hoogle [[a]] -> [a]
19:51:45 <lambdabot> Data.List subsequences :: [a] -> [[a]]
19:51:45 <lambdabot> Data.List permutations :: [a] -> [[a]]
19:51:45 <lambdabot> Data.List inits :: [a] -> [[a]]
19:51:51 <Welkin> a list comprehension is syntactic sugar
19:52:00 <Welkin> I would say learn how lists work first
19:52:07 <Welkin> and write it using normal functions
19:52:12 <Welkin> or even do notation
19:52:25 <parsnip> i think they want like [[1, 2], [3, 4]] -> [1, 2, 3, 4]
19:52:44 <MacSlow> that would work with concat afaik
19:52:55 <Welkin> > do { x <- [1,2]; y <- [3,4]; return (x,y) }
19:52:57 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
19:53:02 <Welkin> @undo do { x <- [1,2]; y <- [3,4]; return (x,y) }
19:53:03 <lambdabot> [1, 2] >>= \ x -> [3, 4] >>= \ y -> return (x, y)
19:53:13 <Welkin> that is what your list comprehension is actually doing
19:53:31 * MacSlow tries in ghci...
19:53:46 <parsnip> [[ (i, j) | i <- [0, 1]] | j <- [2, 3]]
19:53:46 <Welkin> do you know about Monad yet?
19:53:49 <parsnip> > [[ (i, j) | i <- [0, 1]] | j <- [2, 3]]
19:53:51 <lambdabot>  [[(0,2),(1,2)],[(0,3),(1,3)]]
19:53:57 <parsnip> > concat [[ (i, j) | i <- [0, 1]] | j <- [2, 3]]
19:53:57 <Welkin> this uses the List instance for Monad
19:53:59 <lambdabot>  [(0,2),(1,2),(0,3),(1,3)]
19:54:17 <MacSlow> oh gee... folks... *sigh* not at monads or do-notation yet :)
19:54:20 <glguy> MacSlow: No, you can't rewrite that using a nested list comprehension using a single generator
19:54:25 <Welkin> okay
19:54:31 <Welkin> ignore list comprehensions
19:54:45 <Welkin> I wish people would stop being introduced to haskell with list comprehensions
19:54:51 <Welkin> they are the worst
19:55:02 <MacSlow> glguy: no no... one generator per list-comprehension.
19:55:06 <Axman6> MacSlow: list comprehensions are essentially alternative syntax for the list monad. Congrats, you understand the list monad!
19:55:18 <parsnip> MacSlow: i made a nested list comprehension, no?
19:55:28 <MacSlow> so instead of two generators "at the same level" one in each, but then nested
19:56:03 <glguy> parsnip: No, you used the parallel list comprehension extension which is something else
19:56:04 <MacSlow> parsnip:oh... haven't seen that... one sec
19:56:59 <glguy> MacSlow: No, you can't rewrite your example using one generator per comprehension
19:57:45 <parsnip> i don't think they're insisting _that_ list be rewritten as nested, but an example of one.
19:58:15 <parsnip> glguy: i'm not sure i understand the distinction from what i did and a nested list comprehension.
19:58:53 <glguy> parsnip: I misparsed your example originally and didn't see the ] making it a "nested" list comprehension
19:59:08 <glguy> but what you wrote doesn't help answer the question of rewriting what MacSlow wrote as specified
19:59:20 <parsnip> i don't think they're insisting as such
20:00:01 <parsnip> i can imagine asking, "what's an example of a nested list comprehension?", and asking exactly as they did.
20:00:14 <glguy> Check the question again
20:00:20 <parsnip> MacSlow: is my nested list missing the point of your question?
20:00:24 <parsnip> glguy: "such as"
20:00:28 <glguy> it was how to rewrite some specific code not to use two generators in one comprehension
20:00:38 <parsnip> oh, fine
20:01:09 <blankhart> > (\x -> (, x)) <$> [2, 3] <*> [0,1]
20:01:11 <lambdabot>  [(0,2),(1,2),(0,3),(1,3)]
20:01:25 <parsnip> > [(x, y) | x <- [1,2], y <- [3,4]]
20:01:27 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
20:01:39 <MacSlow> parsnip: I'm not sure...
20:01:56 <glguy> MacSlow's request would amount to "How do I write join using only map"
20:02:06 <MacSlow> ... since I don't know what the exercise is really asking
20:02:26 <Welkin> MacSlow: this is an exercise someone else wrote for you?
20:02:31 <Welkin> god, that is even worse
20:02:51 <monochrom> What is the verbatim text of the exercise?
20:02:52 <MacSlow> I'm following the book from Graham Hutton on Haskell
20:02:56 <Welkin> haha
20:03:02 <Welkin> 1st or 2nd edition?
20:03:04 <Welkin> which page?
20:03:05 <MacSlow> 2nd
20:03:08 <monochrom> Oh, that. I'm about to buy it anyway.
20:03:14 <MacSlow> one sec...
20:03:23 <Welkin> I have it on my desk
20:03:36 <glguy> I lent out my copy, that's the book to buy on the subject
20:03:50 <Welkin> I know he uses list comprehensions, which I don't like or agree with, but other than that I like the book from what I have read
20:03:55 <MacSlow> page 57, exercise 7
20:04:06 <parsnip> glguy: meaning it's very good?
20:04:25 <glguy> I liked it
20:04:36 <blankhart> are you able to use applicatives?
20:04:51 <Welkin> blankhart: no
20:04:55 <Welkin> it says to use concat
20:05:00 <MacSlow> that particular exercise aside... sofar I got along well with the book... and see now how recent additions to C++ are influenced by functional programming
20:05:25 <Welkin> I find that exercise more confusing than helpful
20:05:29 <Welkin> what does that even teach?
20:05:30 <MacSlow> yeah but concat "flattens" everything
20:05:55 <glguy> > concat   [ [  [1,2], [3,4] ] , [ [5,6] , [7,8] ] ]
20:05:56 <lambdabot>  [[1,2],[3,4],[5,6],[7,8]]
20:05:58 <Welkin> oh, it's an entire chapter on list comprehensions
20:05:59 <MacSlow> maybe I just skip that one exercise
20:06:00 <Welkin> o.o
20:06:00 <glguy> :t concat
20:06:01 <lambdabot> Foldable t => t [a] -> [a]
20:06:05 <Welkin> wtf
20:06:06 <monochrom> But nested list comprehension nests everything, so you need concat to undo that.
20:06:55 <Welkin> *why* would you have a whole chapter on list comprehensions?
20:07:12 <monochrom> Because then the chapter on Monad will be super easy.
20:07:36 <Welkin> doubtful
20:08:00 <monochrom> OK of course this is my guess, I don't know what Hutton thinks.
20:08:00 <parsnip> what is so bad about list comprehensions?
20:08:24 <Welkin> parsnip: they are "magic" to someone new to the language
20:08:27 <Welkin> and I never use them
20:08:37 <parsnip> > [ [ (x, y) | y <- [3, 4] ] | x <- [1, 2] ]
20:08:39 <lambdabot>  [[(1,3),(1,4)],[(2,3),(2,4)]]
20:08:43 <monochrom> But since everyone knows python therefore everyone knows list comprehension, why not exploit it.
20:08:52 <parsnip> > [(x, y) | x <- [1,2], y <- [3,4]]
20:08:54 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
20:09:00 <Welkin> sure, I learned about "list comprehensions" from python before I knew any haskell
20:09:04 <Welkin> and I thought they were cool
20:09:07 <parsnip> there, done.
20:09:22 <Welkin> but then I realized how bad python is
20:09:22 <parsnip> i learned about list comprehensions from math
20:09:27 <MacSlow> So far I have to say, in terms of code-density Haskell is ace ... compared to C++ :)
20:09:29 <parsnip> python is great
20:10:29 <Welkin> MacSlow: that's any easy competition for any language that isn't c++ though
20:10:48 <monochrom> I don't even think de-magic-fy is a good idea.
20:11:05 <MacSlow> Welkin: it's gotten better with C++-11/14/17
20:11:14 <danilo2> Hi! Could anybody explain to me why GHC is not able to optimize this code or what I'm doing wrong here? Basically this code runs slower if we provide longer tuple. Basically it runs 20 times slower than when providing tuple of len 2  http://lpaste.net/362675  I annotated the code with core, if anyone is interested
20:11:27 <Welkin> I personally hate unnecessary abstractions and anything "magic" that I can't recreate using basic language constructs
20:11:39 <Welkin> when I am learning something new
20:11:45 <Welkin> it only frustrates me
20:11:49 <monochrom> The CFGness of every language is magic to every beginner, too.  Are you going to de-magic-fy that, too?  By going through the EBNF grammar first?  Right on day one?
20:11:52 <parsnip> uh, haskell is lots of magic, hardly machine language
20:12:02 <parsnip> oh, list comprehensions
20:12:16 <parsnip> i see what you're saying, but i don't strongly agree with you in this case.
20:12:39 <parsnip> i generally agree with the sentiment, quite.
20:12:46 <MacSlow> Having seen quicksort "sold" me on Haskell... to start to learn it
20:12:47 <Welkin> you haev to decide what the basic constructs in the language are
20:12:57 <Welkin> a list comprehension is not
20:13:05 <Welkin> MacSlow: you mean tree sort?
20:13:32 <MacSlow> welkin: well the pivot-less quicksort that is
20:13:32 <parsnip> Welkin: then you must hate MonadComprehensions
20:13:37 <Welkin> parsnip: never used it
20:13:40 <monochrom> Anyway my take is I make a case-by-case judgment on each language construct.  All of them are magic, but some of them are super-guessable and actually super-dork if you formalize them early.
20:13:42 <glguy> Worrying about people who haven't learned what list comprehensions yet is my least concern when writing code
20:13:50 <parsnip> Welkin: it's awesome, so terse
20:14:06 <glguy> They can be quite useful at providing a clear definition of some list-oriented value
20:14:14 <Welkin> glguy: writing code is not the same as teaching it or learning it
20:14:45 <glguy> If you're teaching someone to be able to read and write Haskell code you haven't done that if they haven't been taught list comprehensions
20:14:50 <parsnip> i bet you're a vertical coder
20:15:56 <monochrom> parsnip: https://mail.haskell.org/pipermail/haskell-cafe/2018-February/128607.html  >:)
20:16:56 <parsnip> in math, it's not so strange to drop the x \in R, bit
20:17:19 <danilo2> Even if I use unboxed strict ints in an explicite strucutre, the performance of just updating one tuple-like field in loop is much bigger for long tuples. I'm wondering why it happens. HS dont have to copy this object constantly - it only needs to update a single int: http://lpaste.net/362677
20:18:00 <Welkin> unboxed and strict doesn't mean mutable
20:19:13 <blankhart> is there a haskell hlist that would work as a linked list in lieu of tuples with different update semantics?
20:19:15 <parsnip> Welkin: is this publicly viewable?
20:19:18 <parsnip> http://exercism.io/submissions/1b63632053804d2783ee1023d63dddcc
20:19:37 <danilo2> Welkin: I know it does not. Im wondering why GHC cannot update this single field without copying the whole structure. Its very hard to get predictive perfromance in Haskell and I'm just wondering why GHC does not optimize it
20:19:58 <Welkin> parsnip: yes
20:20:42 <danilo2> Welkin: I really dont understand your response that strict doesn't mean mutable. Basically a code like this should be optimized by GHC. If I update a signle field in a loop, I rather dont want my struct to be copied every time I update it. For me this is a major performance problem
20:20:48 <parsnip> sweet. i asked for ideas on i think converting between Maybe and Bool here a few days ago, someone pointed out Monad Comprehensions, and i had a little fun with them.
20:20:50 <monochrom> All your monad are belong to base.
20:21:31 <parsnip> or here's an lpaste if you prefer http://lpaste.net/362678
20:22:23 <Welkin> danilo2: https://hackage.haskell.org/package/HList
20:22:32 <parsnip> i think in math, you read the "|" as "such that", so it works.
20:22:46 <parsnip> though, they write ":"
20:23:19 <Welkin> danilo2: strict means that it is not a thunk
20:23:20 <metahumor> "{ x | x <- R}"
20:23:32 <Welkin> if a value is strict, its evaluation is forced immediately
20:23:34 <metahumor> `|` is fo sho used in set notation
20:23:42 <Welkin> mutatable values are a different concept entirely
20:25:06 <Welkin> you could use ST to safely mutate your tuple
20:25:13 <parsnip> : was more common where i saw it
20:25:20 <Welkin> https://wiki.haskell.org/Monad/ST
20:25:28 <parsnip> though i _have_ seen |, just like, almost never.
20:25:52 <ertes> i rarely see ':' for set notation
20:26:55 <ertes> danilo2: the only way not to copy is to factor out the less frequently changing part
20:27:05 <parsnip> aha, there we go, weechat.el
20:27:06 <danilo2> Welkin: my question was why GHC does not optimize the code when I'm setting a single value to a structure. Copying the whole structure every time I update a single field is a bug for me
20:27:17 <Axman6> IIRC it seems to be fairly popular in programming language papers to say x is in some set A
20:27:20 <danilo2> ertes: why GHC cannot do it automatically ?
20:27:39 <danilo2> ertes: GHC sees that "nobody else" modifies it
20:27:43 <danilo2> ertes: so why it has to copy it constantly ?
20:27:43 <Welkin> danilo2: it does not copy the whole structure for linked structures
20:27:49 <jle`> list comprehensions to me are in the same syntactic category as guards
20:27:51 <ertes> danilo2: there might be optimisations for short-term data, but i wouldn't count on it
20:27:51 <Welkin> and that is what makes it efficient
20:28:13 <Welkin> when talking about non-linked structures, sure, it can be less efficient
20:28:19 <Welkin> but then you have to be the one to fix it
20:28:24 <Welkin> using ST or some other method
20:28:36 <danilo2> Welkin: I know it ... But why it copies the strict structures? You use strict normally to get higher performance. Moreover, if I use lazy tuples there the performance is even much much worse
20:28:52 <Welkin> strict and mutatable are not the same thing
20:28:56 <parsnip> { x : x ∈ ℝ }
20:29:19 <danilo2> Welkin: strict, mutability and compiler optimizations are not the same thing
20:29:20 <Welkin> strict means it is not an unevaluated piece of memory--- it has been fully evaulated as soon as it is created
20:29:40 <ertes> danilo2: strictness is unrelated to in-place mutation…  if anything non-strict fields are *easier* to mutate in-place
20:29:41 <danilo2> Welkin: I know. My T20 structure has a constant layout in memory without intermediate thunks
20:30:30 <danilo2> ertes: I'm asking not about explicit API but about GHC optimizations. If GHC sees strict structure in a memory chnk and sees that we mutate one field and no one is using it in other "branch" it can just mutate the memory as optimization
20:30:34 <Welkin> danilo2: use ST and see how it does
20:30:45 <ghostyy> hi, i have a question about circular/mutually recursive modules - how do i do them in ghc?
20:30:57 <danilo2> ertes: and its rather common optimization in immutable languages
20:30:57 <jle`> boot files
20:30:59 <Welkin> GHC is not heavily optimized for efficiency like that
20:31:11 <Welkin> not yet at least
20:31:16 <jle`> ghostyy: in practice they aren't worth the trouble
20:31:17 <ertes> danilo2: absolutely, but as far as i'm aware that optimisation doesn't happen
20:31:29 <ghostyy> jle`, where can i find some information on them? the link on the wiki is dead
20:31:41 <ertes> danilo2: i might be wrong though…  it's totally thinkable that it does happen for short-term data
20:31:43 <danilo2> Welkin: I know ST. I knwo I can use it. I can also use raw poinetrs here or anytheing else. My question is not what to use in case GHC don't apply optimizations. My question is why it does not apply it under the hood
20:31:52 <Welkin> ghostyy: move all of your common imports to a 3rd module so they are not recursively importing each other
20:32:07 <Welkin> danilo2: I don't know. Go ask in #ghc
20:32:11 <jle`> ghostyy: https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/separate-compilation.html
20:32:12 <Welkin> we are not compiler developers
20:32:20 <jle`> oops, old link
20:32:20 <ghostyy> jle`, im writing a scheme interpreter so eg eval has to talk to the parser, interpreter, and stdlib, and the parser needs to do eval to do macros, and etc...
20:32:23 <danilo2> ertes: And that is exactly my question. Why does it not happen and what are the rules when it happens. Knowing them I could work on performance important parts musch easier
20:32:41 <jle`> ghostyy: usually there is a way to move things to a module to avoid circular imports
20:32:46 <danilo2> Welkin: then this question is not for you. I know here are GHC devs though
20:32:49 <jle`> and it's usually a lot nicer than boot files
20:32:54 <ghostyy> i see
20:32:56 <ertes> danilo2: if it doesn't happen, the most likely answer is: "because nobody has implemented it yet" =)
20:33:28 <danilo2> ertes: Im pretty usre it was avaialable in GHC. I m dead sure I was reading about it somewhere
20:33:34 <Welkin> danilo2: no one will be willing to helo you with that attitude
20:33:37 <Welkin> help*
20:34:10 <geekosaur> Welkin, I'm seeing attitude so far only from you
20:35:30 <danilo2> Welkin: I am very thankful for any help here always. I am also really thankful for your time. I was only to tell you several times that my question is specifically about GHC optimizations and I do not want to use explicite mutable memory. It is really hard to do when the only reply I get from you is "mutability is not strictness", which I know and I explained earlier too. I found this attitude to really though on conversations :(
20:36:00 <ertes> danilo2: i'd be very pleased to learn that it does =)
20:36:35 <danilo2> ertes: me too. Moreover, unless Im not completely wrong it should be easy to implement if we know so many information a GHC does
20:37:09 <Welkin> the language barrier is not helping at all
20:37:43 <ertes> danilo2: it would require strictness analysis, but that is already happening anyway
20:37:58 <danilo2> You are right, it does not help at all. Sorry for some typos above. Were my sentences hard to understand or misguiding for you ?
20:38:07 <danilo2> ertes: exactly
20:39:15 <ertes> danilo2: actually now that i think about it it's not as simple as it sounds…  it needs…  let's call it origin analysis
20:41:09 <ertes> danilo2: the compiler needs to ensure uniqueness
20:41:36 <ertes> danilo2: in a related note linear types are coming, so you will be able to encode this explicitly =)
20:41:46 <danilo2> ertes: which does not make sense anymore, becase function arguments should not be copied, or should they ?
20:42:05 <danilo2> ertes: oh, how linear types could help here ?
20:42:10 <ertes> danilo2: you can only mutate if there are no other references
20:42:32 <parsnip> what will linear types mean to the beginner?
20:42:37 <ertes> linear types guarantee statically that there is only one reference
20:42:38 <danilo2> ertes: ok, right! Hmm, when they will be available in GHC? are there any plans
20:42:50 <ertes> parsnip: nothing…  it's an extension
20:43:02 <Welkin> parsnip: learn rust
20:43:11 <parsnip> okay!
20:43:39 <parsnip> Welkin: do you mean it's like checking out a variable for writing?
20:44:07 <Welkin> parsnip: I don't know much about linear types yet, but rust uses a linear type system
20:44:22 <Welkin> https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems
20:44:45 <Welkin> and I am learning rust, which keeps track of data using a borrowing system
20:44:55 <Welkin> so it knows who has access to the data
20:44:57 <danilo2_> ertes: hmm, regarding ghc wiki they will not improve performance, only safety guarantees when working on data, and it makes sense
20:44:59 <Welkin> and at what time
20:45:16 <Welkin> there are several different type systems like this listed on that page
20:45:38 <Welkin> "Linear type systems (allow exchange, not weakening or contraction): Every variable is used exactly once."
20:46:01 <parsnip> but haskell already has immutable variables?
20:46:11 <ertes> danilo2_: the paper i read also talks about in-place update of arrays
20:46:20 <Welkin> this is about memory management
20:46:28 <Welkin> haskell has a garbage collector
20:46:30 <boj> parsnip: the problem is memory balloons out without linear types
20:46:34 <Welkin> rust doesn't need one because it uses linear types
20:46:39 <ertes> danilo2_: but yeah, you could call this "safely updating in-place" =)
20:46:39 <blankhart> i used rust for some project euler problems, but gave up on it for bigger hobby projects due to the ergonomics.
20:47:10 <blankhart> linear haskell https://arxiv.org/pdf/1710.09756.pdf
20:48:16 <Welkin> there are all kinds of experiments happening with haskell's type system (particularly with dependent types), but I wonder how many of these will ever make it into the language standard, or even become commonly used
20:49:35 <jle`> that's the nice part about 'avoid success at all costs', i think
20:49:48 <jle`> 'avoid "success at all costs"'
20:50:09 <jle`> experimentation is a core haskell principle
20:50:13 <Welkin> yes
20:50:14 <jle`> at the heart of the culture
20:50:19 <Welkin> I agree
20:50:20 <parsnip> :(
20:50:35 <Welkin> but onluy so much can make it into the standard before it becomes a frankenstein mess
20:50:41 <Welkin> look at c++
20:51:04 <Welkin> or scala o.o
20:51:13 <blankhart> as a haskell beginner, the differences between haskell 98, haskell 2010, and the prospects for haskell prime are pretty much meaningless
20:51:23 <Welkin> I don't know how compatible all of these different type system concepts are
20:51:26 <blankhart> there is the language and the extensions and that's about it
20:51:30 <Welkin> so I can't say any more than that
20:52:17 <Welkin> Racket is very interesting in this regard
20:52:20 <blankhart> but more experienced people qualify their praise of haskell by saying that "it's not just one language anymore..."
20:52:22 <Welkin> there are so many variants of racket
20:52:25 <Welkin> but they are all racket
20:52:50 <lifter> Is there a term to describe a function `f` such that `f (f x) == x` for all `x`? For example, `reverse`.
20:53:48 <Welkin> lifter: a caeser cipher
20:53:49 <Welkin> :P
20:54:02 <Welkin> caesar*
20:54:05 <lifter> I thought "idempotent" but that's not right, idempotent is `f (f x) == f x`, for example, `abs`.
20:54:06 <parsnip> it's its own inverse
20:54:25 <lyxia> involutive
20:54:26 <lifter> Thanks parsnip
20:54:28 <jle`> lyxia: involution?
20:54:38 <parsnip> yep
20:54:40 <lifter> woah
20:54:42 <parsnip> just found it
20:55:18 <parsnip> Welkin: you mean rot13?
20:55:19 <lifter> cool, thanks!
20:55:24 <Welkin> yes
20:55:27 <jle`> rotN
20:55:32 <Welkin> no
20:55:37 <Welkin> rot13 specifically
20:55:41 <Welkin> that is the caesar cipher
20:55:47 <Axman6> lifter: http://hackage.haskell.org/package/lens-4.16/docs/Control-Lens-Iso.html#v:involuted "Lens did it" is the haskell version of "Simpsons did it"
20:56:02 <jle`> only n=13 gives you an involution i think
20:56:10 <lifter> Ha! Of course.
20:56:19 <metahumor> in english of course
20:57:06 <boxscape> I keep being surprised how often I run into situations where dependent types might be useful. I should probably look up how you actually use them in haskell...
20:57:19 <boxscape> is there any good intro?
20:57:29 <Welkin> well... rot12
20:57:37 <Welkin> because the latin alphabet has 14 letters
20:57:44 <Welkin> 24 letters*
20:57:47 <Axman6> jle`'s posts on the singltons library do a good job of one technique for doing that
20:58:19 <Axman6> but also you should be clear what you mean by dependent types, sometimes you need something less powerful like simple type families
20:59:41 <boxscape> right, I'm not entirely sure what the difference between dependent types and related concepts is, something I'm hoping to learn as well (I've just used dependent types in Idris)
21:00:14 <boxscape> I'll see if I can find those posts though, thanks
21:01:32 <Welkin> oh no
21:01:35 <Welkin> it has 13 letters
21:01:40 <Welkin> 23 letters*
21:01:49 <Welkin> I keep typing that 1
21:04:03 <parsnip> love it, "Yes, join should be one option for a minimal complete definition, because, math."
21:04:19 <parsnip> then, no involution for you!
21:04:42 <parsnip> the order of the element must divide the order of the group!
21:05:42 <parsnip> i love quchen's icon, \int_{\partial M} \alpha
21:05:52 <parsnip> or whatever that M is, i would have just done M
21:06:18 <parsnip> https://avatars1.githubusercontent.com/u/3020161?s=400&v=4
21:48:39 <dfeuer> Is there a (somewhat?) well-known version of the "Grump" type I defined in https://github.com/ekmett/lens/issues/788 ?
21:48:48 <dfeuer> edwardk: Ping
21:49:26 <jle`> dfeuer: looks like Day ?
21:49:33 <jle`> oh, nvm
21:50:11 <dfeuer> It seems like the sort of thing *someone* must have invented already....
21:51:24 <jle`> honestly i've ran into a bunch of throwaway newtypes for applicative/functors like this that i've given up on trying to generalize/re-use
21:51:48 <dfeuer> *nod*
21:52:00 <jle`> but it's definitely worth asking
21:53:08 <dfeuer> jle`: do you have any idea what would be involved in generalizing the holesOf version I give there to the type it currently has in lens?
22:15:46 <metahumor> does the "(<*>) = ap" law mean that in the Applicative instance for State, the "f" in "(<*>) f m" gets to update the state first?
22:47:35 <Gurkenglas> metahumor, as opposed to what? m getting to update the state before f does?
22:47:43 <metahumor> :t yeah
22:47:45 <lambdabot> error: Variable not in scope: yeah
22:47:54 <metahumor> yeah :: Answer
22:47:58 <Gurkenglas> correct
22:48:36 <Gurkenglas> except for the 'does the "(<*>) = ap" law mean that' part, I don't get that
22:48:48 <Gurkenglas> *I don't get how that's supposed to imply that
22:50:15 <Gurkenglas> > execState ((modify (*2) >> return undefined) <*> (modify (+1) >> return undefined)) 2 -- but this part's right.
22:50:17 <lambdabot>  5
22:51:00 <metahumor> "(<*>) f m = State $ \s -> let (f', s') = runState f s in ..." as opposed to "\s -> let (m', s') runState m s in ..."
22:51:43 <metahumor> given "m >>= f = State $ \s -> let (m', s') = runState m s in runState (f m') s'"
22:52:59 <metahumor> i was verifying whether the inherent ordering of the (f', s') ==> (m', s'') in the defn of (<*>) is a law
22:53:34 <amalloy> metahumor: no, i believe that is not a law. the opposite would be perfectly legal
22:54:35 <metahumor> so it's just a convention of definition, similar to how Right is what gets fmapped over?
22:55:12 <amalloy> metahumor: Right is the only thing you could fmap over given the type Either a b
22:55:56 <amalloy> instance Functor (Either a) where {fmap :: (a -> c) -> Either a b -> Either c b} doesn't typecheck
22:56:09 <dminuoso> Good morning haskellers. Im currently reading https://www.schoolofhaskell.com/user/bartosz/lenses-stores-and-yoneda and it says that a representation for a lens looks like `forall g . Functor g => (a -> g a) -> g b
22:56:50 <dminuoso> Given the context, how does this function relate to anything?
22:59:05 <amalloy> metahumor: regarding your first question i'm not sure though. i remember reading that there's no law that the "effects" of f have to come before the effects of x, but i can see how ap == (<*>) kinda does force that
22:59:31 <amalloy> since with ap you have no choice but to sequence f first
23:00:48 <amalloy> so maybe it's more like, if there were no monad instance then either would be a fine applicative instance
23:21:15 <quchen> amalloy: ap can run its second argument first just fine
23:21:49 <amalloy> quchen: but it doesn't. it's defined in the standard library and runs its first argument first
23:22:44 <quchen> Oh, for a specific type? I missed the beginning of the conversation
23:24:40 <amalloy> quchen: well, we were talking about State, but ap is not a class method. it is defined for all types, and sequences its first argument first
23:36:44 <quchen> amalloy: I wonder how reverse state plays into this.
23:37:03 <quchen> When Proxy is not a good counterexample to things, reverse state usually is.
23:38:14 <quchen> mfix looks like it could run the second <- of a do-block first.
23:38:36 <archbung> exit
23:38:53 <quchen> …conceptually, at least. I guess this becomes relevant when having a transformer stack with reverse state in it.
23:41:11 <sdrodge> Does anybody use monatron or other mtl alternatives in production code?
23:48:01 <sdrodge> nvm, I think the number of hits on Google has answered my question.
23:48:05 <sdrodge> :)
23:48:47 <^Jamssi^> I'm having some problems with types inside ghci. I have a CSV loaded in as "records = [Record]" and I type ":t map (\record -> genericIndex record 4) records" it returns type "[Field]". This is as expected. But when I create it in a .hs file and try to create a function "elements :: [Record] -> [Field]" with the same method I get a type error: "Expected type: [Field] Actual type: [Record]" I'm totally confused
23:49:06 <cocreature> sdrodge: the fact that it was last updated in 2010 also hints at how actively used it is :)
23:49:27 <cocreature> ^Jamssi^: can you show us the code and the full error message?
23:53:17 <^Jamssi^> elements :: [Record] -> [Field]
23:53:18 <^Jamssi^> elements records = map (\record -> genericIndex records 4) records
23:53:29 <^Jamssi^> LearningDataAnalysis02.hs:22:49:
23:53:29 <^Jamssi^>     Couldn't match type '[Char]' with 'Char'
23:53:29 <^Jamssi^>     Expected type: [Field]
23:53:29 <^Jamssi^>       Actual type: [Record]
23:53:29 <^Jamssi^>     In the first argument of 'genericIndex', name 'records'
23:53:29 <^Jamssi^>     In the expression: genericIndex records 4
23:53:29 <^Jamssi^> Failed, modules loaded: None
23:53:37 <cocreature> please use lpaste.net next time
23:53:49 <^Jamssi^> ok then :D
23:53:55 <cocreature> you have a typo: it should be `genericIndex record 4` not `genericIndex records 4`
23:54:05 <cppxor2arr> how is the haskell interpreter invoked here?
23:54:13 <cocreature> > 1 + 1
23:54:15 <lambdabot>  2
23:54:19 <cppxor2arr> wow neat
23:55:18 <dminuoso> Interesting, I just gained new insights into id. After revisiting type unification of `flip id` I realized that `id` can be used as infix.
23:55:26 <[exa]> ^Jamssi^: a prime example of why pointfree code can help :]
23:55:34 <dminuoso> > (+5) `id` 4
23:55:37 <lambdabot>  9
23:55:39 <^Jamssi^> would like to say some naughty words but thanks man, I feel like a moron :D Wasted like two days wondering the intrigue specialities of Haskell
23:55:55 <[exa]> dminuoso: why not $ ?
23:56:17 <[exa]> (it's id by definition)
23:56:21 <cocreature> ^Jamssi^: note that if you tak a look at the error message, it points you explicitely at the first argument to genericIndex
23:56:26 <dminuoso> [exa]: Oh I was merely wondering _why_ (and Im talking beyond mere type unification rules) it worked like this.
23:56:36 <cocreature> ^Jamssi^: even if you can’t make sense of the type error, the source location is usually very helpful
23:57:03 <[exa]> dminuoso: yep, wanted to point out that it's just $ :]
23:57:07 <dminuoso> [exa]: Oh yeah. :)
23:57:25 <dminuoso> modulo infixr
23:58:04 <[exa]> I wonder if (.) can be defined from flip&id
23:58:50 <dminuoso> [exa]: So once I thought about what `id` meant in that position, (flip id) became even more clear than it already was.
23:59:22 <cppxor2arr> > let n = 0 : scanl (+) 1 n in take 10 n
23:59:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
23:59:30 <dminuoso> [exa]: But interestingly I just had a line that read: ($) = id :: (a -> b) -> a -> b
23:59:32 <dminuoso> :P
