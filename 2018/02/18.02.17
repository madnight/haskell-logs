01:04:15 <notCrocodile> .
01:04:56 <notCrocodile> @2+2
01:04:56 <lambdabot> Unknown command, try @list
01:41:46 <qeyoa> I'm currently doing an exercise that says i have to implement `iterate` with the `unfold` function: http://lpaste.net/362581 . I don't see how this should be done, as i need to write a predicate ( == 'something') that returns true for any input and then the return list should include the first element unchanged, when the unfold function changes the very first input.
01:42:35 <dibblego> I don't think you want (==) in there at all.
01:42:41 <qeyoa> yes i know
01:42:48 <qeyoa> i just put it there
01:42:54 <qeyoa> because i don't know what to put there
01:42:56 <qeyoa> :)
01:43:12 <dibblego> put undefined when you are not sure
01:43:20 <merijn> No, put _ when you are not sure
01:43:24 <qeyoa> what is undefined?
01:43:26 <dibblego> no, put undefined
01:43:31 <dibblego> then put _name
01:44:10 <dibblego> @type undefined
01:44:11 <lambdabot> a
01:44:16 <merijn> qeyoa: Anyhoo, (==) takes two arguments, while the predicate expects only one, so that won't work
01:44:28 <dibblego> ahem, all functions take one argument, always
01:45:32 <dibblego> once you've put undefined there, then compile (check it compiles), then put _name there, recompile and see the type of the value that belongs there
01:45:36 <qeyoa> i tried to put undefined instead of a function
01:45:46 <qeyoa> but it throws an error
01:46:15 <dibblego> put iterate' f = unfold undefined undefined undefined
01:47:19 <dibblego> get it compiling, then start add one value that starts with _ then recompile and see the type of the value that belongs there
01:47:47 <qeyoa> i don't know how to compile yet :D, i've only been working in the ghci in emacs
01:47:53 <dibblego> :reload
01:48:51 <dibblego> where did you get this definition of unfold from?
01:49:17 <qeyoa> Graham Hutton book
01:50:13 <qeyoa> it says i have to redefine chop8, map f and iterate f
01:50:14 <qeyoa> with it
01:50:26 <qeyoa> the first two i already did
01:50:30 <dibblego> I would suggest giving it a type, to get startesd
01:50:38 <qeyoa> i already did that
01:50:46 <qeyoa> but iterate is a typeless
01:50:53 <qeyoa> function, is it not?
01:50:54 <dibblego> unfold :: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
01:50:59 <dibblego> no, it has a type, but it is inferred
01:51:10 <dibblego> all functions have a type, I mean explicitly writing the type
01:52:19 <qeyoa> hm
01:52:32 <qeyoa> i don't think i'm supposed to change the definition of unfold in that exercise
01:52:43 <dibblego> this won't change it, just give an explicit type
01:52:49 <dibblego> currently, it is inferred
01:53:01 <dibblego> it will help you solve the problems
01:53:15 <dibblego> you can always delete it later if you really want, but it doesn't change anything
01:56:56 <qeyoa> i'm still not sure how that would help
01:56:59 <qeyoa> with the predicate
01:58:23 <cocreature> qeyoa: can you explain what the purpose of the predicate passed to "unfold" is?
01:59:08 <qeyoa> to stop execution and return the generated list
01:59:14 <qeyoa> but iterate should not stop
01:59:26 <qeyoa> from what i understand
01:59:29 <cocreature> exactly!
01:59:46 <kosmikus> the purpose of the predicate is to *decide* whether to stop or not
01:59:51 <cocreature> so which value does the predicate need to return to indicate that it should not stop?
01:59:56 <kosmikus> if iterate doesn't stop, then that decision is actually easy ...
02:00:15 <qeyoa> i thought of a == id a
02:00:20 <qeyoa> but i cannot do that
02:00:25 <qeyoa> with the curried function
02:01:23 <merijn> qeyoa: That'd only work for elements that have an Eq instance, though
02:01:38 <merijn> qeyoa: Have you tried writing a function that just always returns True, regardless of input?
02:01:52 <cocreature> it should always return False not True
02:02:01 <merijn> eh
02:02:03 <merijn> sure
02:02:20 <qeyoa> something like
02:02:26 <qeyoa> (\x -> True)
02:02:27 <qeyoa> ?
02:02:48 <merijn> qeyoa: Well, cocreature just pointed out you should always return False, but yeah, like that
02:03:02 <cocreature> take another look at the definition of "unfold" and check what happens if the predicate returns True
02:03:18 <qeyoa> i missworded
02:03:23 <qeyoa> yes, false
02:04:01 <qeyoa> and there is the second problem, that iterate always returns the first value unchanged
02:04:27 <cocreature> you can just prepend that value to the result you get from "unfold"
02:04:37 <qeyoa> but with unfold, if i add the first value with  a : unfold ...
02:04:53 <qeyoa> it returns more values when i use, for example: take 2
02:05:04 <qeyoa> then with the normal iterate
02:05:28 <cocreature> huh? do you have an example of that?
02:05:47 <cocreature> maybe I’m misunderstanding where you make the change and where you place the "take"
02:06:56 <qeyoa> i don't, it's just iterate is mostly used with take ?
02:07:15 <qeyoa> so: take 10 (iterate (*2) 2)
02:07:41 <qeyoa> i will look into this, maybe i did something wrong
02:08:26 <cocreature> if you show us the code we might be able to help but it’s hard to guess what might have gone wrong :)
02:11:45 <qeyoa> trying to figure out why prepending does not work now, i somehow managed to do that before
02:12:31 <qeyoa> http://lpaste.net/362582
02:12:58 <qeyoa> is it possible to prepend the x without writing it out?
02:13:51 <qeyoa> ok, seems like i added a few other errors here
02:14:51 <qeyoa> now it works
02:15:07 <qeyoa> http://lpaste.net/362582
02:15:09 <qeyoa> i think
02:15:49 <qeyoa> thanks for the help
02:15:59 <qeyoa> was really stuck on this one
02:16:13 <ski> that works, but does some needless recomputation
02:16:53 <qeyoa> there is a better way to define it with that particular unfold implementation?
02:17:03 <ski> yes
02:17:22 <qeyoa> hm
02:17:50 <cocreature> qeyoa: in particular think about other choices for the "h" parameter to unfold
02:27:25 <qeyoa> http://lpaste.net/362582
02:27:50 <qeyoa> my brain is scrambled up a bit, but i think this should do it?
02:28:06 <cocreature> qeyoa: exactly!
02:28:30 <qeyoa> Thanks, i was having tunnel vision
02:28:31 <qeyoa> there
02:28:33 <merijn> If your brain isn't scrambled, you're not learning :p
02:28:49 <qeyoa> did not notice the duplication
02:28:57 <cocreature> qeyoa: a small style suggestion: if you don’t use a parameter that you’re pattern matching on, you can use _ to make that explicit. so in your example use (\_ -> False)
02:29:18 <qeyoa> ok
02:29:40 <kuribas> what kind of optic is (a -> f a) -> (b -> f b) ?
02:30:00 <kuribas> I though Fold b a , but that doesn't work...
02:30:19 <manek> Hi guys! Is there any benefit of usig MonadIO instead of PrimMonad ? I just find MonadIO obsolete because its just more limited
02:30:22 <lseactuary> is there another function better than iterate that applies a function a number of times
02:30:37 <cocreature> kuribas: with no constraint on f?
02:31:58 <kuribas> oh, I see
02:32:31 <kuribas> theres a (Monoid (f a)) which doesn't look right
02:38:03 <ClawOfLight> /close
02:39:09 <kuribas> cocreature: the whole type is: (Contravariant f, Monoid (f a), Applicative f) => (b -> f b) -> (a -> f a)
02:41:18 <kuribas> (as inferred by ghc)
02:43:31 <kuribas> cocreature: it works with toListOf
02:45:50 <kuribas> but perhaps it doesn't do what I think it does...
02:46:09 <cocreature> kuribas: yeah you can use it as a "Getting r b a"
02:47:12 <kuribas> I get, "No instance for (Monoid r) arising from a use of `<>'"
02:47:27 <cocreature> for what?
02:47:54 <cocreature> ah sorry, "Monoid r => Getting r b a" should work
02:47:59 <kuribas> Getting r b a
02:48:22 <kuribas> :t toListOf
02:48:23 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
02:48:27 <kuribas> cocreature: ok, thanks :)
02:49:44 <kuribas> Getting (Endo [a]) b a also works
02:50:09 <cocreature> sure, "Endo [a]" is an instance of Monoid :)
02:50:43 <kuribas> is it better to specialize it?
02:50:51 <kuribas> or doesn't ghc care?
02:51:10 <cocreature> depends™
02:51:30 <kuribas> it's a subexpression
02:51:39 <kuribas> used in only one place
02:51:48 <kuribas> I suppose ghc will specialize it
02:52:18 <cocreature> if you define it in the same module, it should be specialized. otherwise you might need to add an INLINABLE pragma to make sure the unfolding is exposed
02:53:03 <kuribas> ok, thanks
02:53:40 <kuribas> I use it as a depth first search of a datatype.
02:54:27 <kuribas> like this bfs = _Leaf <> _Branches . folded . bfs
02:54:47 <asheshambasta> I have a question:
02:54:49 <asheshambasta> λ> toRational <$> getPOSIXTime
02:54:49 <asheshambasta> 1518864692170301 % 1000000
02:54:52 <asheshambasta> which looks ok
02:55:08 <asheshambasta> however;
02:55:09 <asheshambasta> λ> numerator . toRational <$> getPOSIXTime
02:55:10 <asheshambasta> 94929045558419
02:56:31 <asheshambasta> actually, never mind I see the problem
02:56:36 <asheshambasta> I'm stupid
02:56:59 <cocreature> time changes :)
02:57:00 <asheshambasta> toRational is factoring the num & denom
02:57:06 <cocreature> yep
02:57:34 <kuribas> cocreature: does it mean it uses (++) to do the fold?
02:57:41 <kuribas> so that may be inefficient...
02:58:17 <cocreature> kuribas: it uses Endo [a] which is a dlist
02:59:43 <kuribas> Endo [a] = [a] -> [a] ?
02:59:58 <lseactuary> can someone help me real quick im pulling my hair out on this simple haskell code
03:00:14 <lseactuary> hello :: Int -> (a->a) -> (a->a)
03:00:20 <kuribas> cocreature: so it's linear over the tree?
03:00:25 <lseactuary> hello x y z = toEnum x ++ (!! (iterate y z) y)
03:00:29 <lseactuary> the types are wrong
03:00:39 <lseactuary> but i cant find anything to convert the stuff before the ++ and after
03:00:53 <kuribas> lseactuary: hello :: Int -> (a->a) -> (a->a) -> List ?
03:01:07 <lseactuary> nope
03:01:20 <lseactuary> e.g. hello 3 (4x) 10 = 3400
03:01:47 <lseactuary> hello 3 (4+) 9 = 313
03:01:49 <lseactuary> et
03:01:50 <lseactuary> etc
03:02:17 <kuribas> lseactuary: ++ works on lists
03:02:31 <cocreature> kuribas: yeah dlists make sure the associativity is like you want it to be
03:03:32 <lseactuary> kuribas yeah i cant find anything that will just merge the numbers together
03:03:44 <lseactuary> can you suggest something?
03:04:27 <kuribas> lseactuary: not sure what semantics you are expecting...
03:04:33 <kuribas> lseactuary: do you want to work on digits?
03:04:43 <lseactuary> could be characters also
03:04:55 <lseactuary> so hello A (4x) B = ABBBB
03:05:17 <kuribas> lseactuary: homework?
03:05:29 <lseactuary> oh i just read its int
03:05:33 <lseactuary> so cant be A
03:05:34 <lseactuary> naa
03:05:45 <lseactuary> learning haskell and its an exercise (without answers)
03:06:17 <lseactuary> oh wait i am correct
03:06:21 <kuribas> lseactuary: the types all wrong
03:06:27 <lseactuary> in the example before they only have a number
03:06:36 <lseactuary> so hello A (4x) B = ABBBB is accurate
03:06:40 <lseactuary> yeah types are wrong
03:06:59 <lseactuary> iterate y z is a []. !! will make the [] -> a
03:07:05 <lseactuary> but the x is screwed up
03:07:07 <kuribas> maybe you want: hello :: a -> (a -> [a]) -> a -> [a]
03:07:28 <kuribas> :t hello x y z = [x
03:07:29 <lambdabot> error:
03:07:29 <lambdabot>     parse error on input ‘=’
03:07:30 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
03:07:53 <kuribas> :t \x y z = [x] ++ y z
03:07:54 <lambdabot> error:
03:07:54 <lambdabot>     parse error on input ‘=’
03:07:54 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
03:08:07 <lseactuary> i think i have done the ordering wrong
03:08:08 <kuribas> :t \x y z -> [x] ++ y z
03:08:09 <lambdabot> a -> (t -> [a]) -> t -> [a]
03:08:10 <lseactuary> 2 min
03:09:34 <kuribas> lseactuary: also note that 4x isn't valid haskell.  Well, it is, but it's not what you expect.
03:09:58 <kuribas> :t replicate 4
03:09:59 <lambdabot> a -> [a]
03:11:31 <lseactuary> kuribas - the '4' is the int that is passed in first i think i messed up the ordering hence my logic broke
03:11:35 <lseactuary> fixing
03:12:07 <lseactuary> hmm no
03:12:14 <lseactuary> 4* or 4+ or whatever is a function
03:12:27 <lseactuary> so i did it right before
03:12:31 <lseactuary> just the types are wrong
03:13:13 <lseactuary> i think i need to get everything into a list
03:13:16 <lseactuary> then drop the list
03:14:36 <kuribas> lseactuary: I still don't get the semantics
03:15:16 <lseactuary> me either actually this book is kinda unclear
03:15:42 <lseactuary> Int -> (a-> a) -> (a->a) i think means the inputs are an integer + function
03:15:47 <kuribas> lseactuary: well, it would help to know the semantics before doing the exercise :-)
03:15:47 <lseactuary> but then the example given makes little sense
03:16:00 <lseactuary> hello 3 (4x) 5 = 320
03:16:08 <kuribas> lseactuary: that function has two arguments, your one has three
03:16:15 <lseactuary> so its basically keeping the 3 (which I assume is the int)
03:16:28 <lseactuary> and then doing the multiplication and joining that
03:16:34 <lseactuary> oh
03:16:55 <kuribas> lseactuary: erm, no, never mind
03:17:16 <lseactuary> so i think my setup is correct but the types are a little screwed
03:17:30 <lseactuary> but I can't convert Int -> a
03:18:05 <kuribas> lseactuary: there's no list, so you don't need (++)
03:18:17 <lseactuary> ye
03:18:37 <kuribas> you don't need toEnum either.
03:18:59 <kuribas> :t iterate
03:19:00 <lambdabot> (a -> a) -> a -> [a]
03:19:26 <lseactuary> wont this just work
03:19:32 <lseactuary> hello x fy z = x (!! (iterate fy z) x)
03:20:01 <kuribas> !! is infix
03:20:13 <lseactuary> (!!) :: [a] -> Int -> a
03:20:14 <lseactuary> no?
03:20:30 <kuribas> lseactuary: (!!) is prefix !! is infix
03:20:38 <lseactuary> ooh you have to keep the brackets
03:20:43 <lseactuary> sorry i thought it was just book notation
03:20:56 <kuribas> lseactuary: you can choose (a !! b) or ((!!) a b)
03:21:09 <kuribas> lseactuary: the first is a bit cleaner
03:21:10 <lseactuary> for x fy z = x ((!!) (iterate fy z) x)
03:21:14 <lseactuary> ah
03:21:31 <lseactuary> for x fy z = x ((iterate fy z) !! x)
03:21:35 <lseactuary> this should work no?
03:22:21 <ski> (inner brackets redundant. looks like you still have a type error)
03:23:17 <kuribas> lseactuary: x is an Int right?  So you cannot apply it.
03:23:24 <lseactuary> yeah its an int
03:23:41 <lseactuary> > for x fy z = x (iterate fy z !! fy)
03:23:43 <lambdabot>  <hint>:1:12: error:
03:23:43 <lambdabot>      parse error on input ‘=’
03:23:43 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:24:08 <lseactuary> wait thats wrong also
03:24:14 <kuribas> > let for x fy z = x (iterate fy z !! fy) in fox 3 (+4) 2
03:24:15 <lambdabot>  error:
03:24:15 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘t1 -> t1’
03:24:15 <lambdabot>      • Probable cause: ‘fy’ is applied to too few arguments
03:24:50 <kuribas> lseactuary: anyway, you are apply x to a value, but you cannot do that with an Int, only with a function.
03:24:58 <lseactuary> aha
03:25:19 <lseactuary> but (!!) :: [a] -> Int -> a
03:25:27 <ski> fy
03:25:34 <ski> `fy' is not an `Int'
03:25:42 <lseactuary> hm
03:26:21 <lseactuary> maybe i just use reverse head
03:26:23 <kuribas> lseactuary: x blah, means apply x to blah.  x needs to be a function
03:26:51 <lseactuary> we are taking about the x before the bracket ?
03:26:55 <kuribas> lseactuary: yeah
03:26:56 <ski> well, `x' doesn't need to be. but if you write `foo bar', then `foo' should be a function
03:27:01 <lseactuary> ah
03:27:11 <lseactuary> ye this is that part i am stuck
03:27:14 <lseactuary> as x is int
03:27:27 <ski> what are you trying to do, at that point ?
03:27:37 <kuribas> lseactuary: the question is, why are you doing it anyway?
03:27:51 <lseactuary> as the output i want appends the 3
03:28:13 <ski> `3' is not a list, you can't append it to anything
03:28:26 <lseactuary> ye
03:28:30 <ski> (`x' is not a list)
03:28:41 <ski> you can add an extra element in front of a list, using `:'
03:28:51 <ski> > 3 : [5,7,11,13]
03:28:53 <lambdabot>  [3,5,7,11,13]
03:29:02 <ski> > [3] ++ [5,7,11,13]  -- also works
03:29:03 <lambdabot>  [3,5,7,11,13]
03:29:04 <lseactuary> but (iterate fy z !! fy) isnt a list either
03:29:17 <lseactuary> its type a
03:29:32 <kuribas> lseactuary: yes, so it matches the type you gave earlier
03:29:36 <ski> well .. i don't know what `for' is supposed to do
03:29:53 <lseactuary> but we dont want the whole list remember just the value of 4*5
03:30:03 <ski> i'm just saying what you should do, if you want to add an element in front of a list ..
03:30:16 <kuribas> ski: I think he wants to perform the function y x times.
03:30:22 <lseactuary> i think i should use head reverse
03:30:26 <lseactuary> then i can do what ski said
03:30:54 <lseactuary> for x fy z = x : head(reverse(iterate fy z))
03:31:04 <ski> kuribas : i'm guessing that, yes. but i haven't seen lseactuary stating that (though i didn't follow from the beginning, either)
03:31:05 <kuribas> ski: like for 3 (1:) [] = [1, 1, 1
03:31:25 <kuribas> he seems rather confused about the semantics though
03:31:33 <lseactuary> trying to learn sorry :/
03:32:04 <ski> lseactuary : `iterate fy z' will be an infinite list. reversing it will not work
03:32:34 <lseactuary> you are right
03:32:37 <ski> > iterate (3 *) 1
03:32:38 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
03:33:14 <lseactuary> how to apply a function to an element
03:33:38 <ski> function application is written like `functionExpression argumentExpression'
03:33:50 <ski> > even 5
03:33:51 <lambdabot>  False
03:34:03 <kuribas> lseactuary: no problem.  Just make sure you know what you are implementing before you do it.
03:34:14 <ski> > (not . even) (4 + 1)
03:34:16 <lambdabot>  True
03:34:26 <lseactuary> yeah i thought i did :/
03:34:28 <lseactuary> for x fy z = x : fy z
03:34:33 <lseactuary> wont that work then?
03:34:56 <ski> i think `fy' is expected to convert an element into an element, not into a list of elements ?
03:34:57 <lseactuary> problem is the latter part is an infinite list again
03:35:03 <lseactuary> ski correct
03:35:14 <lseactuary> but how do i do this
03:35:23 <lseactuary> i cant seem to find anything in the docs for this
03:35:27 <ski> then `x : fy z' won't work, since `fy z' will probably not be a list
03:35:33 <lseactuary> right
03:35:49 <ski> it seemed like you wanted to use `iterate'
03:36:15 <lseactuary> yeah
03:36:17 <ski> perhaps if you could get working code, that does something remotely close to what you want, you could work from there
03:36:21 <lseactuary> iterate :: (a -> a) -> a -> [a]
03:36:42 <ski> or else, as kuribas suggested, first try to plan what you want to do, then try to formulate how to do it, in Haskell
03:36:44 <lseactuary> at the moment none of my attempts are compiling
03:37:23 <kuribas> want I think you want is: helper 3 (4+) 5 => 17
03:37:29 <ski> .. or you could try to randonly change things, in the hope of getting it to work -- i think chances are that this will be unlikely, though. and even if it works, you won't know why
03:37:33 <lseactuary> i want to define a function that takes an Int and (a->a) to (a->a) for example hello 3 (4x) 5 = 320
03:37:38 <kuribas> helper 3 (1:) [] => [1, 1, 1]
03:38:07 <kuribas> lseactuary: shouldn't that be 17
03:38:22 <lseactuary> in math sure
03:38:28 <lseactuary> but that is not the structure i need
03:38:38 <kuribas> > 4 * 4 * 4 * 5
03:38:40 <lambdabot>  320
03:38:59 <lseactuary> hmm
03:39:08 <kuribas> right :)
03:39:34 * ski isn't sure where kuribas is going with `helper'
03:39:34 <lseactuary> this is weird
03:39:39 <lseactuary> :P
03:39:41 <kuribas> > 4 + 4 + 4 + 5
03:39:43 <lambdabot>  17
03:39:53 <kuribas> lseactuary: sorry, I switched (+) with (*)
03:40:05 <lseactuary> thats cool
03:40:11 <lseactuary> it basically applies a function a given number of times
03:40:19 <lseactuary>  in the example it applies it 4 times
03:40:30 <lseactuary> and im assuming to 5 to get 20
03:41:05 <lseactuary> then just adding the '3' first
03:41:08 <kuribas> ski: apply the second argument n times, n being the first argument
03:41:23 <kuribas> yeah
03:41:41 <lseactuary> so the iterate and !! will give you the 20
03:41:49 <lseactuary> but the 3 and 20 are different types
03:41:51 <lseactuary> hence the issue
03:42:03 <remix2000> What exactly happens in this function? https://github.com/ChrisPenner/SitePipe/blob/dfbb116356105a7dc4dedd0852a2e06900e5e5fb/src/SitePipe/Utilities.hs#L34
03:42:21 <kuribas> > 1 : 1 : 1 : [] -- lseactuary
03:42:23 <lambdabot>  [1,1,1]
03:43:10 <lseactuary> the output is not a list though it is (a->a) hence im sure its 3->20 (bad notation but you see where i am going with this)
03:43:54 <lseactuary> i dont think we need lists here
03:44:01 <lseactuary> there should be a simple way to apply a function on an element no
03:44:09 <lseactuary> maybe i have missed something
03:44:17 * ski has no idea what lseactuary means by "but the 3 and 20 are different types"
03:44:27 <lseactuary> 3 is an int, 20 is of type a
03:44:30 <ski> where is `20' coming from ?
03:44:37 <lseactuary> 4 x 5 no?
03:44:43 <kuribas> ski: he means that 20 is a specialization from a more general type.
03:44:57 <kuribas> I think...
03:45:03 <ski> i saw no multiplication in your earlier attempts at defining `for'
03:45:30 <lseactuary> ski - iterate gives you a list where the multiplcation happens (i.e. the function is applied)
03:45:38 <ski> (and where is `4' and `5' coming from, then ?)
03:45:48 <lseactuary> ski = hello 3 (4x) 5 = 320
03:45:52 <lseactuary> that is what we want
03:45:56 <lseactuary> 3 = Int
03:46:08 <lseactuary> 4x and 5 is the a->a
03:46:17 <cocreature> remix2000: what specifically are you asking about? the function seems to have a relatively detailed comment explaining what it does
03:46:17 <lseactuary> as 4x is being applied to the 5
03:46:37 <lseactuary> wait
03:46:43 <lseactuary> isnt the first element of that list 20 anyway
03:46:52 <lseactuary> [4x5, 4x4x5, ...]
03:47:02 <ski> do you want to multiply `5', `3' times, with `4' ?
03:47:16 <ski> > iterate f x
03:47:18 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
03:47:18 <lseactuary> i want to multiple '5' '4' times and stick a 3 in the front of it
03:47:57 <ski> multiply `5', `4' times, with what ?
03:48:07 <lseactuary> the function is 4x
03:48:12 <lseactuary> when applied to 5 it gives 20
03:48:25 <ski> when applied one time, yes
03:48:29 <lseactuary> yes
03:48:30 <remix2000> lseactuary: i'm asking about those functions from lenses library used in there
03:48:31 <ski> how many times do you want to apply it ?
03:48:37 <lseactuary> once
03:48:45 <lseactuary> as we just want the 20
03:48:55 <ski> so are you saying you want
03:49:04 <[Leary]> I rather think you're misinterpreting where 320 comes from, lseactuary. As kuribas noted, 320 = 4 * 4 * 4 * 5. The 3 isn't supposed to be the Int somehow appended despite type inconsistencies.
03:49:07 <ski>   for x fy z = fy z
03:49:07 <ski> ?
03:49:19 <ski> (so `x' is ignored)
03:49:27 <kuribas> > take 10 $ iterate (4*) 5
03:49:29 <lambdabot>  [5,20,80,320,1280,5120,20480,81920,327680,1310720]
03:49:31 <lseactuary> [Leary] interesting
03:49:39 <lseactuary> i think actually your interpretation is correct
03:49:42 <kuribas> remix2000: what's the question?
03:50:15 <lseactuary> apply the function 4* 3 times to 5
03:50:18 <lseactuary> ye
03:50:20 <lseactuary> i think that is correct
03:50:26 <lseactuary> meaning i have done this wrong
03:50:29 <ski> lseactuary : ok, that's what i was asking about earlier
03:50:30 <cocreature> remix2000: "post ^.. key "tags" . values . _String . to T.unpack" will look for a key called "tags", extract all string values in the array at that key and then convert them from Text to String using T.unpack
03:50:34 <lseactuary> sorry :(
03:50:39 <lseactuary> bit slow
03:50:43 <lseactuary> ok lemme try
03:50:44 <ski> no worry
03:50:48 <lseactuary> then show
03:51:09 <cocreature> remix2000: so it takes something like {"tags": ["abc", "def", 1]} and gives you back ["abc", "def"]
03:53:07 <lseactuary>  for x fy z = iterate fy z !! x
03:53:09 <lseactuary> is it correct?
03:53:35 <ski> > let for x fy z = iterate fy z !! x in for 3 (4 *) 5
03:53:37 <lambdabot>  320
03:53:45 <lseactuary> :)
03:53:45 <ski> > let for x fy z = iterate fy z !! x in for 0 (4 *) 5
03:53:47 <lambdabot>  5
03:53:48 <remix2000> cocreature: So _String just retrieves list of strings?
03:53:50 <ski> > let for x fy z = iterate fy z !! x in for 1 (4 *) 5
03:53:52 <lambdabot>  20
03:53:57 <lseactuary> ski - how did you check
03:53:57 <ski> > let for x fy z = iterate fy z !! x in for 2 (4 *) 5
03:53:59 <lambdabot>  80
03:54:04 <lseactuary> you typed this directly into ghci
03:54:04 <lseactuary> ?
03:54:19 <ski> i didn't type anything into GHCi
03:54:45 <lseactuary> how did you do this?
03:54:49 <ski> do what ?
03:54:52 <lseactuary> these cases
03:55:13 <cocreature> remix2000: no _String is a Prism that checks if the json value is a Sting and if so gives you back the string value or fails if the value is not a string. that’s what’s causing the "1" to be dropped in my example above
03:55:23 <ski> i merely asked lambdabot to try out a few variants of your query, using your latest definition of `for'
03:55:27 <lseactuary> ah
03:55:34 <lseactuary> where is lamdabot
03:55:38 <lseactuary> can i install it also
03:55:44 <ski> you go decide whether it's correct or not
03:55:48 <lseactuary> would be useful for me so i can see what i am doing wrong
03:55:52 <ski> @where lambdabot
03:55:52 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
03:56:18 <ski> however, i don't really see how it would be better than GHCi here. i assume you already have GHCi
03:56:20 <kuribas> :t (#.)
03:56:21 <lambdabot> error: parse error on input ‘)’
03:56:36 <lseactuary> yeah im using ghci
03:56:39 <lseactuary> but didnt know how to test
03:56:50 <kuribas> what does #. from the lens source do?
03:57:01 <lseactuary> i will try some more questions now that i am slowly getting this :)
03:57:27 <lseactuary> many thanks for the help
03:57:46 <kuribas> foldrOf l f z = flip appEndo z . foldMapOf l (Endo #. f)
03:57:57 <kuribas> I understand anything except #.
03:58:18 <kuribas> a special kind of composition?
03:58:19 <ski> lseactuary : you can use `let ... in ...' to test
03:59:01 <ski> lseactuary : you can also use `let ...' in GHCi, to make a quick definition, that you can then test. but if it's a longer definition, it's probably nicer to write it in a source file, and load that into the interactor (GHCi, in your case)
04:00:44 <kuribas> lens turned a haskell weakness into a unique feature.
04:00:53 <kuribas> I don't know of anything comparable in other languages.
04:00:56 <remix2000> cocreature: Can you recommend some resources about prisms/lenses?
04:01:22 <kuribas> remix2000: https://artyom.me/#lens-over-tea
04:02:23 <cocreature> remix2000: https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html is nice for Lens and Traversal but it doesn’t cover prism
04:04:11 <remix2000> Thank you kuribas and cocreature!
04:10:17 <kuribas> anyone know where #. in lens comes from?
04:11:53 <cocreature> kuribas: are you too lazy to grep the source code yourself? ;) https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Prism.hs#L47
04:12:33 <kuribas> cocreature: thanks, sorry :)
04:50:28 <remix2000> What "Num (a -> c)" means in type signature?
04:51:23 <ski> it means that you're attempting to use a number, as if it were a function, or vice versa
04:52:39 <ski> technically, it's saying that you need a `Num' instance (with definitions of addition, subtraction, multiplication (but not division), and a couple of more operations) for *functions*, in order to make your code typecheck
04:53:12 <ski> *usually*, this means that you have a mistake in your code, since usually, you don't want to treat functions as numbers
04:54:02 <remix2000> > :t ((*3) . (-3))
04:54:04 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
04:54:22 <yoho139> :t ((*3) . (-3))
04:54:22 <ski> try using `subtract 3' instead of `(-3)' ?
04:54:23 <lambdabot> (Num (a -> c), Num c) => a -> c
04:55:54 <quchen> remix2000: See https://github.com/quchen/articles/blob/master/fbut.md#--4-is-not-x---x---4 for an explanation
04:56:15 <ski> `(-3)' is not the section "subtract three". it's "negative three", a number. this is a special case in the syntax
04:58:31 <remix2000> that makes sense..
04:59:52 <ski> the actually sensible `Num' instance for functions, that occasionally is useful, is
04:59:56 <ski> @let instance Num a => Num (rho -> a) where (f + g) r = f r + g r; (f - g) r = f r - g r; (f * g) r = f r * g r; negate f r = negate (f r); abs f r = abs (f r); signum f r = signum (f r); fromInteger n r = fromInteger n
04:59:57 <lambdabot>  Defined.
05:00:10 <yoho139> > let sub3 = ((-)3) in sub3 5 -- and it wouldn't do quite what you wanted anyway, probably
05:00:12 <lambdabot>  -2
05:00:42 <ski> using this, you can write e.g. `cos^2 + sin^2' instead of `\x -> cos x ^ 2 + sin x ^ 2' (this should always be constantly `1', that's a trigonometric law)
05:01:25 <ski> > map (cos^2 + sin^2) [0,pi/6,pi/4,pi/3,pi/2,pi]
05:01:27 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0]
05:01:59 <ski> yoho139 : `sub3' is `(3 -)', try `flip (-) 3'
05:02:10 <yoho139> yeah, I know
05:02:23 <mniip> > (\x -> cos x ^ 2 + sin x ^ 2) 1e20 -- not so fast
05:02:25 <lambdabot>  0.9999999999999999
05:02:46 <ski> > map (id^2 + id + 1) [0,1,2,3,4]  -- polynomial evaluation
05:02:48 <lambdabot>  [1,3,7,13,21]
05:03:44 <ski> > map (fst^2 + fst*snd + snd^2) [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]  -- polynomial in two variables
05:03:46 <lambdabot>  [3,7,13,12,19,27]
05:04:15 <mniip> hmm, just the other day I was thinking
05:04:35 <mniip> if we rewrote all 'f x' as 'f <*> x'
05:04:45 <mniip> and all literal/constant 'x' as 'pure x'
05:05:44 <mniip> that would be a lambda function builder of sorts
05:05:53 <mniip> with 'id' serving as the bound variable
05:06:16 <ski> see SKI combinators
05:06:22 <mniip> I mean that's pretty obvious as that's what the Reader applicative is all about
05:06:27 <mniip> but when you say it out loud
05:07:04 <ski> `(<*>)' is `S',`pure' is `K',`id' is `I'
05:08:08 <mniip> right
05:08:54 <ski> (also cf. idiom brackets)
05:18:03 <kuribas> <*>pureid
05:18:17 <kuribas> :t ap
05:18:18 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:18:30 <kuribas> appureid calculus
05:18:36 <mniip> :t pure <*> id
05:18:37 <lambdabot> b -> b
05:20:09 <ski> @type pure <*> (pure :: c -> a -> c)
05:20:10 <lambdabot> b -> b
05:21:24 <kuribas> :t \x -> ((x :: a->b) <*>)
05:21:25 <lambdabot> error:
05:21:25 <lambdabot>     • Couldn't match expected type ‘a2 -> b1’ with actual type ‘p’
05:21:25 <lambdabot>         because type variables ‘a2’, ‘b1’ would escape their scope
05:22:23 <ski> @type (<*>) `asAppliedTo` const undefined
05:22:24 <lambdabot> (b1 -> a -> b2) -> (b1 -> a) -> b1 -> b2
05:22:49 <ski> @type \x -> ((\y -> x y) <*>)
05:22:50 <lambdabot> (t -> a -> b) -> (t -> a) -> t -> b
05:24:38 <remix2000> What does this signature mean? `traverse :: Traversable t => Traversal' (t a) a`
05:25:29 <remix2000> (what's `(t a) a` in there?)
05:25:55 <merijn> remix2000: Those are two types that are arguments to Traversal'
05:25:57 <ski> that's two separate (type) arguments given to the type synonym there
05:27:27 <remix2000> Ah, now I see… sorry :)
05:31:29 <Lycanos> Hello everyone. I'm having some trouble with reading three integers from a single line on stdin, then passing those to an existing function. Can anyone help me?
05:32:24 <ski> what have you got, so far ?
05:32:27 <ski> @paste
05:32:27 <lambdabot> Haskell pastebin: http://lpaste.net/
05:33:43 <Lycanos> I have this so far: http://lpaste.net/362587
05:33:52 <Lycanos> Edited a bit for brevity
05:34:11 <Lycanos> It's based on an approach we used to read single number inputs before
05:34:16 <ski> ok, that won't work
05:34:29 <ski> `read input' will be the same result, in all three cases
05:34:44 <ski> you could use `reads' instead
05:35:09 <cocreature> or split the string using "words" first
05:35:32 <merijn> Or parser combinators
05:36:27 <ski> > [(x,y) | let s0 = "23 , 8",(x,s1) <- (reads :: ReadS Integer) s0,(",",s2) <- lex s1,(y,s3) <- (reads :: ReadS Integer) s2,("","") <- lex s3]
05:36:28 <lambdabot>  [(23,8)]
05:36:54 <Lycanos> I tried using a combination of splitting the string into words, then reading them. I got a list of type 'IO [Integer]', which could not be used in my existing functions
05:37:21 <ski> this will give an empty list, in case of parse error, and a list with a single result, in case of parse success. if you ever get multiple (top-level) results, then that's normally also an error
05:38:02 <ski> `lex' can be used to scoop up some punctuation or keywords, like the comma above. it can also be used to check that there's no garbage (apart from whitespace) at the end, as i showed
05:38:44 <cocreature> > let [a,b,c] = words "5 23 42" in (read a, read b, read c) :: (Int, Int, Int)
05:38:46 <lambdabot>  (5,23,42)
05:38:54 <ski> Lycanos : that sounds like a beginner `IO' confusion. you should probably use `<-' to name the intermediate result
05:38:55 <cocreature> ^ Lycanos does that help?
05:39:19 <Lycanos> I'll take a look at these suggestions, thanks
05:39:23 <ski> Lycanos : or `(>>=)'/`(=<<)', at your option
05:39:38 <ski> (`<-' is for use inside `do'-notation. i'm not sure whether you've seen that yet)
05:39:51 <dgpratt> Lycanos: you may understand this, but a value with type "IO [Integer]" is not a list. It is a value that represents an IO action that *when performed* will produce a list of Integer values.
05:40:40 <ski> cocreature's version will abort the program, in case there's a parse error. using `reads', on can avoid that. perhaps you don't care about what happens in such a situation
05:40:56 <Lycanos> I've seen the do-notation, but we never used it during my haskell course in uni
05:41:12 <ski> using `(>>=)' or `(=<<)' will also be ok
05:41:36 <ski> use whatever you're most comfortable with, for the moment ?
05:41:51 <ski> (at some point, you should become comfortable with both, of course)
05:42:06 <Lycanos> Yeah, I plan to :)
05:43:18 <ski> Lycanos : can you show what you tried, which caused "I got a list of type 'IO [Integer]', which could not be used in my existing functions" ?
05:43:34 <Lycanos> let me see if I still have that cod
05:45:40 <Lycanos> http://lpaste.net/362588 this is that try
05:46:21 <ski> fwiw, next time you can use the "Annotate" button to update a paste with related pastes. that way the updates will appear on the same page
05:46:28 <Lycanos> O, thanks
05:47:53 <ski> (the "Edit" button is for changing a paste. older versions will still be visible for people who want to see them, but it's more awkward. if you think people may way to view both the old and the new at the same time (apart from looking for differences), i suggest using "Annotate". and of course if you want to paste something unrelated, you make a new, fresh paste)
05:49:08 <ski> Lycanos : ok, it looks like that is missing a call to `fmap'/`(<$>)'
05:49:28 <Lycanos> what does that mean?
05:49:53 <ski> `getLine' has type `IO String'. it's not a string, but instructions for how to do Input/Output interaction with the Operating System, in order to obtain a string
05:50:06 <merijn> @quote /bin/ls
05:50:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
05:50:30 <ski> `map read.words' (which i'd prefer to write as `map read . words') take a `String' and turns it into a triple of `Integer's
05:51:18 <ski> `fmap (map read.words)' then will take an action (a "list of instructions") of type `IO String', and attach the `map read.words' function to be done at the end, after the `String' has been obtained
05:51:33 <ski> so therefore `fmap (map read.words)' has type `IO (Integer,Integer,Integer)'
05:51:38 <ski> Lycanos : makes sense ?
05:51:58 <ski> er, `fmap (map read.words) getLine' has type `IO (Integer,Integer,Integer)', rather
05:52:14 <Lycanos> okay, let me try that
05:52:18 <Lycanos> I think I get it
05:52:33 <ski> well, so far i have not suggested anything new, only explained what parts of your code does
05:52:46 <ski> perhaps this was enough to give you an idea of what you could try, though
05:53:44 <Lycanos> O yeah..., thought you meant I forgot the fmap call
05:54:14 <ski> anyway, the trouble then in your code is that you attempt to pass this resulting action of type `IO (Integer,Integer,Integer)', to your `myFunction'
05:54:32 <Lycanos> yes
05:54:33 <ski> but `myFunction' doesn't want an I/O action as input, it wants a triple of `Integer's
05:55:00 <ski> however, if you have been paying attention, you should be able to figure out how to resolve this impasse
05:55:35 <ski> do you see it ?
05:55:39 <Lycanos> I should use fmap to map myFunction to the IO (Integer, Integer, Integer)?
05:55:47 <ski> that would work, yes
05:56:05 <ski> `fmap' for `IO' works by attaching a "pure function" to the end of the "list of instructions"
05:56:41 <ski> so that whenever the resulting action is later executed/performed, it will first do the original action, then call your "postprocessing function" on the result of that, at the end
05:58:21 <noethics> https://pastebin.com/raw/d0YWGhCY
05:58:24 <ski> Lycanos : ok ?
05:58:34 <Lycanos> yes, I think I understand
05:58:37 <Lycanos> thanks for your help!
05:59:23 <dgpratt> am I taking crazy pills or are we setting Lycanos up for another type conflict between e.g. "[Integer]" and "(Integer, Integer, Integer)"?
05:59:37 <Lycanos> that's my own fault
05:59:43 <ski> Lycanos : could you annotate the paste with your current code ?
05:59:45 <Lycanos> I edited the function
05:59:47 <Lycanos> sorry
05:59:53 <dgpratt> oh, ok
05:59:57 <Lycanos> I can, brb
06:00:38 <ski> dgpratt : i figured they'd notice that themselves, and hopefully figure it out :)
06:01:15 <dgpratt> fair enough -- was starting to wonder if my brain was implanted with some device similar to Stentrode
06:01:16 <Lycanos> I annotated what I currently have
06:01:26 <ski> Lycanos : ok. next there is a law that says that `fmap f (fmap g act)' is the same as `fmap (f . g) act'
06:01:41 <ski> (one can also state the law as saying that `fmap f . fmap g' is the same as `fmap (f . g)')
06:02:02 <merijn> dgpratt: Part of learning is setting people up to fail. The hard part is you have to ensure they fail in ways they understand and can analyse :)
06:02:02 <Lycanos> so compose the functions myFunction . read . words, I guess?
06:02:03 <ski> (where `f' and `g' are any functions, and `act' is any action)
06:02:39 <ski> Lycanos : after a while, you should be able to notice such refactorings immediately by yourself
06:02:58 <Lycanos> yeah, now that you mention it I remember this law from the uni course as well
06:03:27 <ski> it's good to practice putting it to work. connecting theory to praxis
06:03:53 <ski> Lycanos : does it typecheck ?
06:05:04 <qeyoa> if i have `type Bit = Int`, how do i cast an Int variable to a Bit? Would [Bit] ++ [Int] = [Bit]?
06:05:09 <Lycanos> It does, after I changed the type of readIntegers from 'IO [Integer]' to 'IO Integer'
06:05:42 <concaveirc> Hi all, I am trying to scrape some data with the github api. What is the best way to get JSON responses? I am thinking Network.Curl, but do tell if there is a better track.
06:06:19 <ski> Lycanos : then, i'd suggest you try moving `getLine' back into `main', as you had it in an earlier paste (which may in fact have been written later than the second paste you made here, but whatever). you'll need to adapt the type of `readIntegers' accordingly, perhaps renaming it again
06:07:02 <Lycanos> I'll try that, thanks
06:07:03 <ski> qeyoa : `Bit' already *is* the same type as `Int'. `type' introduces type *synonyms*. no "cast" needed (and none possible, either)
06:07:15 <nisstyre> concaveirc: wreq
06:07:18 <qeyoa> ok
06:07:25 <ski> Lycanos : such moving around of things is good refactoring practice, btw
06:07:34 <nisstyre> https://hackage.haskell.org/package/wreq
06:09:57 <concaveirc> nisstyre: Thanks
06:15:15 <Lycanos> ski : I moved the getLine back to main, but now it won't compile anymore. It seems the getLine is now not of type 'IO String' anymore, but just normal 'String'. Can you give me another hint about what's happening here? http://lpaste.net/362588
06:16:03 <ski> well, now `input' is not an action, so passing it to `fmap' is inappropriate
06:16:20 <freeman42x]NixOS> what even is this? haha https://i.imgur.com/EWU56ch.png WAT
06:17:04 <ski> `getLine' is still of type `IO String'. however, `readIntegers =<< getLine' won't pass `getLine' (the action itself) to `readIntegers', but rather it will pass the actual read `String' (which `readIntegers' then calls `input')
06:17:17 <Lycanos> aaaah
06:17:43 <merijn> freeman42x]NixOS: It computes the difference between the first and second element and uses that as increment
06:18:25 <ski> > (\x -> [x, 1..3]) -2
06:18:27 <lambdabot>  error:
06:18:27 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_1132’
06:18:27 <lambdabot>      • In the expression: e_1132
06:18:35 <ski> > (\x -> [x,1..3]) (-2)
06:18:37 <lambdabot>  [-2,1]
06:22:33 <freeman42x]NixOS> merijn, ski makes sense now, wasn't sure what I was looking at
06:23:53 <merijn> freeman42x]NixOS: [x..], [x,y..], [x..y], and [x,y..z] are just sugar for enumFrom, enumFromThen, enumFromTo, and enumFromThenTo respectively
06:23:57 <LHSnoobsauce> hiya, how do I run ghci from a specific place in the directory so that it recognizes other modules i've saved in the same place in the directory?
06:24:22 <Lycanos> ski : Thanks for all the help, it finally works!
06:24:47 <ski> Lycanos : annotate ?
06:25:19 <lyxia> LHSnoobsauce: -ipath/to/new/root
06:26:06 <Lycanos> http://lpaste.net/362588 here it is
06:26:55 <LHSnoobsauce> lyxia: not sure I understand? (really really new to this)
06:28:38 <ski> Lycanos : actually the type signature of `readIntegers' doesn't work
06:28:46 <Lycanos> yeah, I just noticed
06:28:53 <Lycanos> I changed it to regular Integer
06:29:45 <ski> note that we refactored the code so that `readIntegers' doesn't deal with I/O any longer
06:30:15 <ski> an alternative way to define `main' would be
06:30:23 <ski>   main = print =<< fmap readIntegers =<< getLine
06:31:06 <ski> er, actually that's not right
06:31:16 <ski> i wanted
06:31:27 <ski>   main = print =<< return . readIntegers =<< getLine
06:32:06 <ski> however, and i was probably confusing it with this in my mind, one could also do
06:32:13 <ski>   main = print =<< fmap readIntegers getLine
06:32:27 <ski> Lycanos : do you understand those two alternative versions ?
06:32:51 <merijn> Yay...multithreading triggers all sorts of weird and irreproducible errors in persistent
06:33:26 <ski> Lycanos : you should also make sure you understand the suggestions that HLint made below some of your pastes
06:33:35 <Lycanos> yes, I think I do
06:34:17 <Lycanos> Do you mean the red and yellow suggestions on the paste page?
06:34:35 <lyxia> LHSnoobsauce: "ghci -iPATH" runs ghci making available the modules under PATH
06:35:05 <lyxia> LHSnoobsauce: if you also want to hide the current directory you can run "ghci -i -iPATH" instead
06:35:11 * ski has no idea about whether they're shown in color, viewed the pastes in a terminal-based browser, with custom colors (white on black)
06:35:33 <LHSnoobsauce> lyxia: thanks a lot! tat works!
06:35:46 <lyxia> LHSnoobsauce: yw
06:36:13 <Lycanos> Ok, well in chrome there are some suggestions which I assume are automated, they are shown in the mentioned colours
06:36:18 <ski> Lycanos : anyway, you'll see that it suggested merging the two `fmap' calls. i don't always agree with the suggestions HLint makes, but it's useful to consider them
06:36:29 <Lycanos> yeah, I applied that one
06:36:47 <lyxia> Does GHC Haskell have a memory model? Am I allowed to race with vectors or arrays?
06:37:01 <ski> Lycanos : the only noteworthy thing i didn't mention was the eta reduction (actually that's function extensionality, but they're closely related to each other, so ..)
06:37:29 <merijn> lyxia: Why do you wanna race vectors? That doesn't sound like a great idea
06:37:57 <ski> eta reduction is something that you may or may not want to apply (for readability, or for efficiency). but you should know about it, and consider it, when relevant
06:38:26 <ski> (and ditto for function extensionality)
06:38:35 <Lycanos> yeah, I understand what it does, but I usually do it after I finish writing something so I can understand it more easily
06:38:38 <Lycanos> Anyway, I'm gonna log off soon. Gonna try and troubleshoot the actual homework part of the program, which is not fast enough yet... Thanks again for the help!
06:38:54 <ski> (function extensionality says that if `f x' and `g x' are equal for all inputs `x' (iow `f' and `g' behave the same), then they *are* equal)
06:39:22 <ski> (eta conversion says that `f' is the same as `\x -> f x' (expansion is the forward direction, reduction the backward direction))
06:39:50 <ski> Lycanos : *nod*, np. have fun !
06:40:04 <Lycanos> Bye!
06:43:38 <lyxia> merijn: I think I'm still confused about what guarantees I'm looking for actually. I'm trying to implement a concurrent data structure (parallel functional arrays) for fun and learning, there's a compare-and-swap for synchronization, but I'm unsure that guarantees anything about vectors.
07:07:26 <bontaq> if anyone's bored, I've been trying to see how fast I can get this in haskell: https://seb.wilzba.ch/b/2018/02/the-expressive-c17-coding-challenge-in-d/
07:07:44 <bontaq> it's fun & simple, pretty much replace a column in a big csv
07:08:33 <bontaq> so far my best is 40s for the big 10,000,000 line csv
07:14:48 <thewinterkid> @bontaq can you share your code? i'm a newbie. would be really interesting to see how this is done in haskell
07:14:48 <lambdabot> Unknown command, try @list
07:17:46 <bontaq> sure, I'm a nub too :)
07:24:27 <bontaq> thewinterkid: http://lpaste.net/362594
07:39:41 <mishugana> Hello, folks - newbie here learning Haskell from Graham Hutton's "Programming in Haskell book", have a couple of questions at this stage!
07:40:14 <mishugana> Working through the chapter on "Functors, Applicatives, and Monads", I get the idea of Functor very well, and the Monad part is also quite clear as per the text
07:40:17 <c_wraith> mishugana, feel free to ask. someone will help you out
07:40:41 <mishugana> but Applicatives is kind of where I am a bit confused - I get the concept, but I am finding it hard to relate to it
07:41:14 <mishugana> Also, do we really need to know the various laws - the functor, applicative laws and monad laws? As in , would it be useful enough to learn them now
07:41:28 <mishugana> or can that be safely picked up if needed in the future?
07:42:00 <mishugana> About applicatives - Professor Hutton mentions that they are useful to applying pure functions to effectful arguments and gives an example where it fails
07:42:38 <c_wraith> as far as the laws go - they roughly add up to "nothing funny is going on"
07:43:07 <mishugana> and then he says that monads can solve that example better because of >>=, and I can work the types and figure that using <*> would indeed not work for that example, but his implication seems to be that monads can be applied to effectful functions to begin with
07:43:28 <mishugana> (the given example uses Int -> Int -> Maybe Int as the type which works with monads, but not with applicatives)
07:43:50 <mishugana> Basically, I am trying to understand what the whole business is about - and when what should be used!
07:44:01 <c_wraith> you can put off worry about the laws until you are creating new instances
07:44:10 <mishugana> c_wraith ah, thanks... so I can probably just skim over them for now, right?
07:44:15 <mishugana> Excellent... thanks!
07:44:37 <kuribas> mishugana: every monad is an applicative, but the inverse is not true.
07:45:15 <mishugana> kuribas yeah... that leads me to the other question - can we always rely on return = pure? As in, are the circumstances when we would override that?
07:45:35 <kuribas> mishugana: you shouldn't override it
07:45:45 <ski> mishugana : the laws are useful to know, at least on an informal level. they're used when refactoring, all the time (whether one realizes it or not)
07:46:09 <mishugana> Hmmm.... okay, that makes sense, ski
07:46:31 <mishugana> kuribas: thanks... so basically they differ only in terms of <*> vs >>= ?
07:46:57 <c_wraith> I mean, I agree with ski. and I take it even further. the laws essentially say "the obvious refactoring is correct". :)
07:47:14 <kuribas> mishugana: every monad has (<*>), but bind (>>=) may not be possible for an applicative.
07:47:46 <mishugana> c_wraith I get what you mean! :-) ... the book is great, but the laws are not explained in detail... :D
07:47:59 <ski> mishugana : one might say that idioms (aka applicative functors) enable one to express (only) "static sequencing", while monads (also) allow one to express "dynamic sequencing"
07:48:18 <mishugana> ski what do you mean by static vs dynamic in this context?
07:48:25 <ski> mishugana : did they give the monad laws, in terms of `do'-notation ?
07:49:10 <mishugana> ski haven't reached monad laws yet, but for applicative, something like pure id <*> x = x etc
07:49:18 <ski> ok
07:49:40 <mishugana> Okay, just checked... one sample law is return x >>= f= f x
07:50:02 <mishugana> so that makes sense, but I don't have any idea where that might be useful (apart from what c_wraith mentioned in terms of ensuring things are fine)
07:50:11 <ski> monads allow determining *which* later action to perform, based on the *result* of an earlier action. idioms don't allow that
07:51:00 <mishugana> ski could you elaborate, please? maybe a simple example?
07:51:01 <ski> so, if you're parsing e.g., with a monadic parser, you can first read a count, and then read that many items/lines/bytes, e.g.
07:51:15 <mishugana> aha
07:51:29 <ski> with an applicative parser, you can't do that. the "structure is fixed/static", and then "values flow along that preexisting structure"
07:51:47 <mishugana> Ah, okay... now I get what you mean
07:52:02 <ski> with a monadic parser, you can yourself decide how later parts of the parser wiring should look, based on what you parsed earlier
07:52:04 <benzrf> to be clear - the behavior of applicatives can be influenced by what came before them
07:52:34 <mishugana> So, I know that this is premature, but considering that there appears to be so many various styles - applicative, monadic etc., will reading real world code entail knowing all these different idioms inside out?
07:52:40 <benzrf> just not the "return value"
07:52:45 <benzrf> yes, it william
07:52:47 <benzrf> *will
07:53:06 <ski> mishugana : "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> also talks about this distinction
07:53:16 <mishugana> benzrf hmmm.... okay, that is a good challenge then! :-) ... I thought I was done when I mastered fold... haha!
07:53:25 <kuribas> mishugana: yes, but you get used to it quickly
07:53:40 <mishugana> ski: thanks for the link! will check it out! :-)
07:53:50 <mishugana> kuribas I hope so, man! ;-)
07:54:10 <ski> mishugana : anyway, because idioms/applicatives are more restricted, that also means that one could potentially optimize them more. consider e.g. preanalyzing the parser, before actually running it
07:54:25 <mishugana> ski Hmmm
07:54:58 <ski> (<https://en.wikipedia.org/wiki/Rule_of_least_power>)
07:55:32 * ski nods to benzrf
07:56:33 <mishugana> Thanks ski, benzrf, c_wraith, kuribas! That helps set my mind at ease and push on! This book is deceptively small! :D
07:57:00 <ski> mishugana : do you know `do'-notation ?
07:57:15 <c_wraith> mishugana: I'm trying to track down a blog post by jle that I really liked that might give you a nice perspective on how Functor/Applicative/Monad all fit together
07:57:16 <mishugana> ski yup... at least the basics! :-)
07:57:33 <mishugana> c_wraith that would be really helpful, thanks!
07:57:37 <c_wraith> mishugana: https://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad.html
07:58:29 <mishugana> c_wraith thanks, wraith! Yeah, I believe this the is the hardest part of the whole book, so that should help me get over the hump! :D
07:58:38 <benzrf> which book :o
07:59:02 <mishugana> I'm using Graham Hutton's Programming in Haskell (2nd edition) to start with
07:59:19 <mishugana> couldn't find any decent book tbh - the haskell book is too elaborate and big for me :(
07:59:49 <mishugana> after getting through this book, I plan to start doing simple projects and learn topics through that instead of only pure theory!
08:00:21 <ski> mishugana : well, i'll state the monad laws for you, in terms of `do'-notation, ok ?
08:00:33 <mishugana> I have checked the wiki, and found some good project ideas... can anybody comment on "Scheme in 48 hours"? That looks very interesting...
08:00:44 <mishugana> ski okay, sure. Thanks!
08:00:57 <ski> ok
08:01:07 <mishugana> Even if I don't maybe get it all, I'll save them for review! :-)
08:01:33 <ski> first there are two "neutral element" laws, one "left" and one "right" law
08:01:43 <ski>      do y <- return x
08:01:49 <ski>         ..y..
08:01:57 <ski>   =  do ..x..
08:01:59 <ski> and
08:02:12 <ski>      do x <- ...
08:02:18 <ski>         return x
08:02:23 <ski>   =  do ...
08:02:36 <ski> then there's the "associative" law
08:03:01 <ski>      do y <- do x <- ...
08:03:09 <ski>                 ..x..
08:03:16 <ski>         ..y..
08:03:27 <ski>   =  do x <- ...
08:03:34 <ski>         do y <- ..x..
08:03:50 <ski>            ..y..
08:04:28 <mishugana> ski okay, got that
08:04:31 <ski> in fact, the last, "right-nested" `do'-block here is actually the same thing as
08:04:36 <ski>      do x <- ...
08:04:43 <ski>         y <- ..x..
08:04:45 <ski>         ..y..
08:05:07 <ski> (this can be seen as syntactic sugar for the second form in the associative law)
08:05:13 <mishugana> okay
08:05:30 <mishugana> and there's one more law, right?
08:05:37 <ski> anyway, these laws say that `return' and sequencing in `do'-notation behaves in "the obvious/expected" way
08:06:00 <ski> no, there's three laws relating `return' to `(>>=)' (which is what `do'-notation desugars to)
08:06:08 <mishugana> ski okay, cool! I've copied those over in my notes! :-)
08:06:12 <mishugana> Thanks!
08:06:53 <ski> if one wants to, one could also formulate laws relating these to `fmap', and to `pure' and `(<*>)' -- in fact, those laws are commonly used as default implementations of the latter !
08:07:45 <mishugana> ski yeah, my mind was kind of blown when the book mentioned something like "fmap g x = pure g <*> x" and then I realised that makes sense given the types! :D .. it can be kind of overwhelming though... haha!
08:08:12 <ski> mishugana : the last law above, associativity, says that it doesn't matter how we group/bracket a sequence of actions. whenever you pull out ( / fold) a subsequence of commands in `do'-notation into a separate definition (or the opposite, inline/unfold a call, flattening the sequence of commands in `do'-notation), you're using this law
08:09:06 <mishugana> ski okay, that makes my brain hurt... let me read it again! :-)
08:09:22 <mishugana> Ah, okay... I think I get it
08:09:24 <ski> mishugana : the first law (or sometimes equivalently the second law) is used when you inline/unfold a definition whose sequence of commands in `do'-notation ends with a `return'
08:09:46 <mishugana> ski Hmmm....
08:11:17 <mishugana> ski okay, I think I'm getting some of it (not all though)... still it helps, and I can refer back to these notes once I have learnt more! Thank you so much for the help, ski!
08:11:55 <mishugana> So, just curious... can anything that can be done with a Functor be done by an Applicative and likewise from Applicative to Monad?
08:12:16 <c_wraith> yes
08:12:26 <mishugana> I mean, is it simply a matter of increasing abstraction, or are there hard use cases when one would definitely be chosen over the other (assuming all three are applicable)
08:12:38 <mishugana> Ah, okay!
08:12:38 <c_wraith> You can use Applicative to construct the operations in Functor.  You can use Monad to construct the operations in Applicative
08:13:00 <ski> so if you have `foo = do x <- blah; return (bleh x)' and you want to inline it into `do ...; y <- foo; ..y..', you go to `do ...; y <- do {x <- blah; return (blah x)}; ..y..', then you flatten (associativity) that to `do ...; x <- blah; y <- return (bleh x); ..y..'
08:13:01 <mishugana> Hmmm... is there any downside to it in terms of performance?
08:13:04 <ski> and then you use the first neutral element law to either go to `do ...; x <- blah; ..(bleh x)..', or to `do ...; x <- blah; let {y = bleh x}; ..y..', depending on whether `y' is mentioned more than once, and whether you want to keep the name or not
08:13:05 <banjamine> Is haskell better than javascript
08:13:12 <ski> mishugana ^
08:13:15 <metahumor> mu
08:13:20 <benzrf> µ
08:13:26 <kuribas> banjamine: as a language, yes.
08:13:34 <benzrf> a bold claim
08:13:44 <benzrf> are we in the business of making value judgments?
08:13:49 <benzrf> or only typing judgments?
08:13:55 <banjamine> Should I bother learning it
08:13:58 <benzrf> yes
08:14:02 <banjamine> To increase my coding skill
08:14:05 <c_wraith> mishugana: yes, it is potentially more efficient in some cases to use the less-powerful class.  It can vary by specific types, of course
08:14:11 <mishugana> ski: okay, I get it better now with that explanation... associativity that is!
08:14:12 <kuribas> mishugana: ghc is good in removing layers of abstraction.
08:14:30 <benzrf> ghc is a truly impressive feat of engineering tbh
08:14:39 <ski> mishugana : there can be cases where using idiomatic/applicative operations may enable preoptimizations (as i indicated with the parser example above), and therefore be more efficient than the monadic ones
08:14:43 <mishugana> c_wraith okay, that makes sense. thanks!
08:15:34 <mishugana> ski okay, that meshes well with what c_wraith mentioned as well!
08:15:36 <ski> mishugana : the left neutral law is needed to remove the remaining `y <- return (bleh x)' command. a `return'/`pure' command is always trivial, doesn't add any real effects, can be removed like this
08:16:09 <ski> mishugana : and of course, if one's folding a piece of code out to a new definition, one may need to conversely introduce a `return' in the same way
08:16:12 <mishugana> kuribas I just found out that godbolt.org now supports Haskell! Planning to check out the generated machine code once I get these concepts under my belt! :-)
08:16:25 <benzrf> what's goldbolt?
08:17:02 <mishugana> benzrf https://haskell.godbolt.org/
08:17:23 <benzrf> oh, nifty
08:17:24 <mishugana> it's a code decompiler (online)... used to support only C++, now it supports a bunch of languages!
08:17:26 <Tuplanolla> It's not the most readable machine code you will see, mishugana.
08:17:28 <benzrf> @g stg kung fu
08:17:28 <lambdabot> Maybe you meant: gazetteer get-shapr get-topic ghc girl19 google googleit gsite gwiki v @ ? .
08:17:32 <benzrf> @google stg kung fu
08:17:32 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
08:17:38 <benzrf> check this out first ^
08:17:51 <kuribas> banjamine: it's hard to answer, but I'd say give it a shot, and see if you like it.
08:17:56 <mishugana> Tuplanolla yeah, I suppose so... still interesting to see how two snippets in different idioms might map out! :-)
08:18:14 <Tuplanolla> I'll get back to you once you've actually tried it.
08:18:58 <mishugana> Tuplanolla I haven't tried with Haskell yet, but it works quite nicely with Rust and C++... I mean confirming in some cases that the generated code is identical when using different abstractions
08:19:04 <mishugana> but yeah, should be interesting
08:19:20 <ski> mishugana : anyway, if you define `(amb >=> bmc) a = amb a >>= bmc', then you can formulate the three laws very nicely and succinctly like
08:19:33 <ski>   return >=> amb  =  amb
08:19:39 <ski>   amb >=> return  =  amb
08:19:59 <lyxia> I have two threads sharing an unsynchronized vector v and an IORef r. Thread 1 does a compare-and-swap on r, then writes to the vector if that succeeds. Thread 2 reads from the vector then checks the reference r (via readIORef). If Thread 2 does not see the CAS, is it guaranteed to not see the subsequent vector write?
08:20:04 <ski>   (amb >=> bmc) >=> cmd  =  amb >=> (bmc >=> cmd)
08:20:07 <lyxia> http://lpaste.net/362595 for example
08:20:41 <mishugana> ski: ah yes, that's how the book displays them...
08:20:57 <kuribas> mishugana: if you like to know how you can rewrite code using laws, I'd give "Pearls of Functional algorithmic design" a shot.
08:21:03 <mishugana> but it's helpful knowing the `do` part as well (which is not covered in the book, for the laws I mean)!
08:21:03 <ski> these look very much like the arithmetic laws `0 + x = x',`x + 0 = x',`(x + y) + z = x + (y + z)', and `1 * x = x',`x * 1 = x',`(x * y) * z = x * (y * z)'
08:21:26 <ski> if you write the laws in terms of `(>>=)', then they don't look quite as pretty
08:21:43 <mishugana> kuribas: By Richard Bird, right? Thanks, will check that book out! :-)
08:21:44 <ski>   return a >>= amb  =  amb a
08:21:49 <ski>   ma >>= return  =  ma
08:21:54 <lyxia> I have the same question with STM  http://lpaste.net/362596
08:22:07 <ski>   (ma >>= amb) >>= bmc  =  ma >>= (\a -> amb a >>= bmc)
08:22:30 <kuribas> mishugana: yeah
08:22:36 <ski> it is also possible to formulate the laws instead in terms of `return',`join', and additionally using `fmap' from `Functor'
08:22:53 <benzrf> join 4 life
08:23:02 <mishugana> ski: been copying all your explanations on my emacs buffer! :-) ... it will need a thorough going through... thanks for all the effort, man! That helps a lot
08:23:04 <ski>   join . fmap return  =  id
08:23:11 <ski>   join . return  =  id
08:23:18 <qeyoa> is often using guards and `where` expressions considered lazy coding in haskell?
08:23:26 <ski>   join . fmap join  =  join . join
08:23:41 <benzrf> everyone yelling abuot monoids in categories of endofunctors n then not even defining theyre monads in terms of the monoid operation smdh
08:24:08 <kuribas> qeyoa: no, why?  I use them all the time.
08:24:38 <mishugana> ski I'll be damned... everything is circular then, eh? :D ... just curious - how long did it take you to internalise all these combinations?!?
08:24:41 <kuribas> qeyoa: most of my functions look like myFun = someExpr where {... }
08:24:51 <qeyoa> the native functions have such short definitions that i feel like i'm cheating when i use longer blocks of code
08:24:57 <ski> this last formulation can be seen as going from the type `m a' to `m (m a)' (either by introducing a "trivial" inner `m' by `return', or the outer `m') and then to `m a' .. both these are noops (`id')
08:25:10 <qeyoa> implementations*
08:25:20 <merijn> qeyoa: I can make you feel better with some 50+ or longer line of code atrocities :p
08:25:29 <metahumor> qeyoa: no one needs to read the source code for the native functions; you do need to read your own source code. better to be clear and expressive
08:25:54 <merijn> qeyoa: 50 line function, here you go: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/ExportModel.hs#L51-L101 :p
08:26:02 <benzrf> lov this code https://i.imgur.com/P90hFCD.png
08:26:03 <ski> while the associative law says that if you start with `m (m (m a))', you can either start by "smashing together" the two inner `m's, and then the remaining two ones; or by smashing together the two outer `m's, and then the two remaining ones -- and these two ways lead to the same result
08:26:07 <merijn> oh, my bad, it's 70 lines
08:26:12 <merijn> I missed some where parts
08:26:25 <merijn> benzrf: That's god awful
08:26:30 <benzrf> thank u, thank u very much
08:26:42 <merijn> benzrf: Like...in a bad way >.<
08:26:43 <qeyoa> shouldn't a function be no more than 20~ lines
08:26:46 <qeyoa> or something like that
08:26:53 <qeyoa> so to be considered clean code
08:27:09 <merijn> A function should be as short as it can be
08:27:15 <merijn> Some things just can't be short
08:27:22 <ski> so one could say that, on the type level, this is about the how "smasging the monad composition" `m . (m . m)' (not actual Haskell syntax) being the same as smashing the composition `(m . m) . m'
08:27:43 <kuribas> it can be useful to keep subexpressions, to avoid passing to much stuff.
08:28:06 <benzrf> i know
08:28:06 <benzrf> i was trying to get something working as fast as possible >w>
08:28:16 <merijn> benzrf: Start refactoring!
08:28:17 <mishugana> ski: hahaha, okay, most of it going way over my head, but I'm saving them all for careful study! :-)
08:28:25 <benzrf> i was gonna but then i didnt want to touch it again
08:28:26 <ski> mishugana : hmm .. i've been at it for some time. explaining it to people on IRC helps making it stick better :)
08:28:27 <benzrf> ^3^
08:28:35 <ski> (or to other people as well, of course)
08:28:52 <mishugana> ski: Haha, I suppose so! :-) ... still, very impressive!
08:29:22 <mishugana> Thank you so much for the effort, man...!
08:29:44 <benzrf> good things to know: half or more of the point of monads and applicatives is that they allow writing code that is generic over monads and applicatives
08:29:58 <benzrf> so you get functions like:
08:30:05 <benzrf> :t sequenceA
08:30:06 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
08:30:16 <ski> mishugana : from a direct practical perspective, the formulation in terms of `do' is probably most helpful. but one should also know laws like `return . f =<< ma  =  fmap f ma' by heart (this can be used as a default implementation of `fmap' in terms of `return' and `(>>=)')
08:30:40 <benzrf> this lets you go from, e.g., [Maybe a] to Maybe [a]
08:30:49 <benzrf> or [IO a] to IO [a]
08:30:55 <ski> mishugana : however, i think it helps to also see it from the `return',`join' perspective. sometimes it's easier to grasp what `join' does for a monad, rather than `(>>=)'
08:31:00 <benzrf> or Map k (Either a b) to Either a (Map k b)
08:31:08 <mishugana> ski: That makes sense... I suppose having good foundations is better than rushing onto projects then
08:31:28 <benzrf> what's more, this is a method of the Traversable class - Traversable instances are written to be generic over applicatives
08:31:48 <benzrf> :t traverse -- this combines sequence with map
08:31:48 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:32:06 <mishugana> benzrf: I think that is an excellent point - most of the code in the book also uses them to create generic functions more than anything else!
08:32:40 <benzrf> @let checkNonNeg = traverse (\x -> if x < 0 then Left "negative given!" else Right x)
08:32:41 <lambdabot>  Defined.
08:32:45 <benzrf> > checkNonNeg [1, 2, 3]
08:32:47 <lambdabot>  Right [1,2,3]
08:32:48 <benzrf> > checkNonNeg [1, -2, 3]
08:32:50 <lambdabot>  Left "negative given!"
08:32:56 <ski> mishugana : well, i suppose i'm not saying you should learn as much theoretical knowledge upfront as possible. however, if you find it intrigues you, by all means learn more. i've also attempted to show that it does inform the practical day-to-day matters, to lesser or greater extent (sometimes without one realizing it)
08:33:26 <ski> mishugana : .. having fun is an important ingredient to learning
08:34:25 <mishugana> ski: Absolutely agreed! One reason why I like this book by Professor Hutton is that he started off by presenting the language as mathematics... that kind of clicked in my head, and seeing all these laws mesh with one another is... fascinating
08:34:49 <ski> `Either e' and `ExceptT e m' can sometimes be used, when `e' is really the interesting result of the computation
08:34:54 <mishugana> I am itching to do projects, of course, but I'd rather have a strong foundation even if I start hands-on a bit late, I suppose! :_)
08:34:54 <benzrf> it
08:35:23 <benzrf> it's like how, say, if you pass a comparison function to a sort method in some other language, you'll get weird and unspecified behavior if it's random
08:35:50 <mishugana> ski especially considering that code in OS projects would most likely contain all these concepts that I would need to know anyway! :D
08:35:56 <benzrf> similarly, if you define a weird monad instance, you'll get confusing and changing behavior from generic monad code
08:36:13 <benzrf> it's just that in haskell we're smart enough to write down exactly what counts as sufficiently weird
08:36:16 <benzrf> i.e., breaking the monad laws
08:37:38 <mishugana> benzrf Ah!
08:38:57 <ski> s/weird/unlawful/ :)
08:39:40 <mishugana> Wow, this place is really helpful! I feel like I've learnt a lot more in 30 minutes here than spending half a day trying to figure thing out by myself (don't get me wrong - I enjoy it, but I found that a lot of my confusion was misplaced and erroneous)
08:39:46 <benzrf> :)
08:39:52 <benzrf> we strive to be a good resource
08:39:55 <mishugana> Thank you for the help, guys! Appreciate it! :-)
08:40:11 <ski> mishugana : fwiw, the idiomatic/applicative laws also follow the general pattern of "left and right neutral law, associative law". but since that's about "static sequencing", it's in some sense "at a different level"
08:41:23 <mishugana> ski duly copied and noted! :-) ... yeah, I will have to spend some time on your explanations to do them full justice!
08:42:19 <mishugana> I will be back with more questions no doubt, but for now, cheers, all! Thanks again to all you guys! :-)
08:42:32 <ski> yw, have fun
09:20:24 <Bowlslaw> i should have learned Haskell years ago
09:22:14 <banjamine> Where is haskell most widely used?
09:22:21 <banjamine> In what industry
09:22:34 <Lycurgus> or then what?
09:22:58 <hpc> banjamine: all sorts of places
09:23:13 <hpc> it's used in some financial stuff, facebook uses it for a couple of things
09:23:20 <hpc> the original perl6 interpreter was written in haskell
09:23:26 <banjamine> But it's such an old language
09:23:29 <hpc> iirc some small piece of the eve online backend was haskell
09:23:37 <MarcelineVQ> it's eternally new
09:23:41 <hpc> it's only old because it's been around a long time ;)
09:24:22 <hpc> it's similar to the lisp family, where there's always something new being added
09:24:26 <Bowlslaw> banjamine: oldness doesn't bother me too much if the language is useful, like C
09:24:30 <hpc> compared to something like go which was old before it was even created
09:25:01 <Bowlslaw> hpc: bahahhahaha
09:25:59 <monochrom> But that's human nature.  To brag about "I'm learning a new language" without spending the effort.
09:26:24 <Bowlslaw> that's not what i'm doing :(
09:26:47 <monochrom> Yeah I'm referring to people who learn Go and then brag about being up-to-date
09:27:00 <Bowlslaw> oh
09:27:09 <Lycurgus> and eternally shy of adoption in apps of note
09:28:11 <Lycurgus> but at least when asked now
09:28:17 <Lycurgus> nobody says darcs
09:28:19 <hpc> banjamine: haskell's niche is problems that would be way too hard to write correctly otherwise
09:28:53 <hpc> (and research)
09:29:13 <monochrom> In fact Go is so regressive as to drop parametric polymorphism that anyone who writes on their CV both "career goal: personal growth" and "recent achievement: Go" is a scammer.
09:29:40 <hpc> does go even have void*?
09:29:42 <Bowlslaw> It seems to me that functional programming, in general, is best for parallel programming and mathematical modeling
09:29:50 <Lycurgus> (entering line was addressed to Bowlslaw)
09:30:22 <monochrom> https://twitter.com/mosheroperandi/status/856946180810354688
09:30:40 <hpc> Bowlslaw: i would more attribute those to purity
09:31:28 <monochrom> I do mathematical modeling to every computational problem.
09:31:38 <hpc> an impure functional language is going to have largely the same issues as imperative languages with those tasks
09:31:43 <hpc> just hidden behind higher-order functions
09:33:19 <Bowlslaw> hpc: I can point to Kotlin as an example of that
09:43:02 <qeyoa> is it possible to have something like a debugger functionality for haskell in emacs?
09:47:32 <parsnip> is it possible to have something like a debugger functionality for haskell?
09:47:44 <metahumor> depends on what your defn of debugging is
09:48:53 <qeyoa> a peak at the stack trace, i'm not sure actually
09:50:00 <Bowlslaw> doesn't ghci have a debugger?
09:50:09 <metahumor> can you give an example of a situation where you would've wanted a debugger
09:51:04 <qeyoa> well i'm not sure how to check values in the middle of a function like f . g . h . c
09:51:49 <metahumor> why not break it up into intermediate calculations and lets say, Debug.Trace.trace on them?
09:52:24 <qeyoa> ah, so there is one
09:52:25 <metahumor> ghc might fuse "f . g . h . c" in such a way that certain intermediate structures never even exist
09:52:45 <hpc> metahumor has the right answer here
09:52:50 <metahumor> and "debugging" as you're describing might force thunks prematurely
09:53:14 <qeyoa> i'm not in a need of one yet
09:53:17 <qeyoa> just curious
09:53:41 <qeyoa> since i often use the debbuger functionality in java ide's
09:53:45 <metahumor> hopefully the functions you are composing have compatible types (so it compiles) AND are written in such a way that they have reasonable outputs
09:54:45 <metahumor> the "debugging" probably needs to happen only in one of the functions you are composing
09:56:04 <qeyoa> so as far as haskell is concerned i should forget about that word and concentrate on really writing code which has separate pieces that are easily verified?
09:56:14 <metahumor> exactly
09:56:19 <qeyoa> ok, got it
09:56:30 <metahumor> there still is a need for "debugging" in haskell
09:56:43 <metahumor> to investigate why or when certain things are/aren't evaluated
09:56:47 <Bowlslaw> is it wrong for me to use tabs instead of spaces in my source files?
09:56:50 <metahumor> to pin down why memory leaks might happen
09:56:52 <parsnip> lol
09:56:53 <Bowlslaw> is it truly a big deal?
09:57:07 <metahumor> Bowlslaw: i think haskell community is totally unified against tabs
09:57:10 <parsnip> why would you use tabs?
09:57:12 <Bowlslaw> hmm
09:57:34 <Bowlslaw> i've just always used tabs
09:57:41 <qeyoa> aren't tabs defined differently in different editors
09:57:53 <Bowlslaw> you can change tab length
09:58:08 <parsnip> no. but each _viewer_ can change the width of _each tab_
09:58:19 <parsnip> but a tab is always one tab.
09:58:47 <sedeki> tabs are really spaces in some editors
09:58:53 <parsnip> no
09:59:07 <sedeki> pressing tab => spaces in some editors
09:59:10 <Bowlslaw> in order to do that you have to set an option which converts stabs to spaces
09:59:20 <Bowlslaw> in vim anyway
09:59:22 <parsnip> sedeki: that's the tab key, different from tab character
09:59:29 <metahumor> inserting "Tab" in certain editors might display "tab" but write spaces on save
09:59:47 <parsnip> you can have the tab key do _anything_
09:59:58 <parsnip> it could phone home
10:00:34 <parsnip> you could write a phd thesis on the tab key in emacs
10:00:36 <metahumor> my Tab key goes to matching paren or paren-like. its great
10:01:17 <parsnip> sedeki: and most editors should let you choose if tab key inserts tabs or spaces.
10:01:39 <parsnip> SOMETIMES IT EVEN COMPLETES!!1!
10:02:04 <parsnip> (setq tab-always-indent 'complete)
10:04:15 <monochrom> I guess you could also have the phone-home button on your phone to insert tab.
10:05:23 <Bowlslaw> lol
10:07:37 <parsnip> ugh, i really don't feel like updating my haskell+euler workflow, haven't touched it for almost 3 years.
10:07:49 <metahumor> why would you need to?
10:08:44 <athan_> Does anyone here know how to sleuth-out which exception type was originally thrown, before being cast into a SomeException?
10:09:03 <metahumor> you have to pattern match on the constructor iirc
10:09:22 <cocreature> pattern match on the constructor and use typeOf
10:09:29 <monochrom> http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#supertyping
10:09:40 <athan_> cocreature: Oh hm, but typeOf won't return with SomeException?
10:09:56 <athan_> thanks everyone
10:10:24 <cocreature> athan_: that’s why you first need to unwrap it by pattern matching
10:14:39 <Bowlslaw> i love list comprehensions
10:14:46 <Bowlslaw> and lazy eval
10:14:50 <Bowlslaw> omfg my mind
10:18:47 <bash0r> Is it better to work with Data.ByteString or Data.ByteString.Char8 when working with raw UTF-8 input?
10:19:08 <metahumor> bash0r: https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
10:19:42 <cocreature> bash0r: neither, use Data.Text
10:19:53 <bash0r> metahumor: thanks
10:19:55 <metahumor> just use "Data.Text.Encoding.decodeUTF8"
10:20:23 <bash0r> cocreature: I need to work on the bytes. I know that I need to handle the UTF-8 encoding myself in this case, though.
10:21:16 <merijn> bash0r: ByteString is bytes, "UTF-8" input sounds like text
10:22:08 <cocreature> bash0r: if you really need to work on bytes then the Char8 module is not going to be particularly useful.
10:22:09 <bash0r> merijn: The input data is UTF-8 encoded. But I need to work on byte level.
10:22:23 <cocreature> the only valid usecase for the Char8 module is ascii text
10:25:00 <bash0r> I guess, I'll need to read more about Data.Text. Thanks!
10:25:41 <cocreature> bash0r: what kind of operations are you trying to perform that require working at the byte level?
10:25:55 <merijn> bash0r: Data.Text is the type for manipulating, well, text (unicode text to be precise)
10:26:19 <merijn> Yeah, byte level manipulation of utf-8 encoded unicode sounds like a red herring
10:27:21 <bash0r> cocreature: parsing of low-level network instructions that can contain UTF-8 encoded text. But most of the stuff is still just plain bytes.
10:27:51 <metahumor> then you don't really care what encoding it is it seems
10:28:03 <cocreature> bash0r: sounds like you should take your input as a ByteString and then decode the parts that are utf-8 text to Text
10:28:05 <merijn> bash0r: So use something like attoparsec to grab the utf8 encoded parts of the ByteString then decode those to Text
10:28:16 <merijn> cocreature++
10:28:26 <merijn> Alternatively, use binary instead of attoparsec
10:29:02 <bash0r> metahumor: yup. The text encoding is not that much of a trouble. All I need is extracting some segments of the input.
10:29:13 <bash0r> cocreature: That's what I intend to do.
10:30:32 <bash0r> merijn: I'll implement my own parser combinator library as I try to implement some experimental features that should be possible with attoparsec but I don't want to break open the API of attoparsec.
10:30:46 <merijn> bash0r: What sorta features?
10:31:10 <bash0r> merijn: parsing with derivatives encoded in closures.
10:32:56 <bash0r> The UTF-8 encoded fragments (identifiers) can be just passed through. The rest of the syntax will be ASCII anyways.
10:33:10 <qeyoa> I've implemented a function `checkParityBits` which throws an error on faulty input and it works until i put it in another function: http://lpaste.net/362598 . The same code is used in both examples, the only difference being that one piece is wrapped in a function in the second example. I've looked through the code and can't see any errors, seems to be the same code, maybe i'm just not seeing something obvious?
10:34:06 <metahumor> decode vs decode'?
10:34:32 <qeyoa> yes
10:34:34 <qeyoa> just noticed
10:34:34 <qeyoa> it
10:34:41 <qeyoa> i'm blind
10:34:56 <metahumor> rubber duck debugging, not in emacs but in irc instead
10:35:40 <Bowlslaw> hahahaha
10:36:08 <qeyoa> yeah, half of my posts in reddit end up being canceled
10:36:19 <qeyoa> since i get to the answer while writing the question
10:37:24 <hpc> i wonder if there's a /r/rubberduckdebugger where you can post but not comment
10:38:05 <metahumor> but you could upvote, it'd be cool
10:38:10 <metahumor> perfect place to nerdsnipe
10:39:36 <Bowlslaw> my cousin is working on his CS degree and had some difficulty with Java homework. He was emailing me and texting me in a panic because his assignments were late and starting to pile up. His last text to me was, "Well, talking it through like this actually helped me figure it all out now" I didn't do anything lol
10:39:57 <merijn> I had the opposite in the past
10:41:11 <Bowlslaw> how do I work from "right to left" on a list without using reverse?
10:41:20 <merijn> Struggling to fix some shitty python for hours, staring at the screen in frustration. Brother comes downstairs with a 41 degree fever, borderline hallucinating. I bitch at him that this code is unfixable. He walks in, stares at the screen for half a second, points somewhere in the middle and goes "there" and leaves. After 2 hours of further study he was fucking right too...no clue how he managed...
10:41:39 <Bowlslaw> lol
10:41:40 <Welkin> Bowlslaw: using foldr
10:41:41 <hpc> merijn: lol
10:41:50 <Bowlslaw> Welkin: foldr? thank you I will look into it
10:42:05 <Welkin> > foldr (:) [] [1..10]
10:42:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:42:37 <Welkin> the real answer is to use recursion
10:42:42 <Welkin> just the same way you would to walk a list
10:42:44 <Rembane> merijn: Drunken master, but with illness instead of alcohol.
10:42:53 <metahumor> > foldr (-) [a, b, c, d]
10:42:54 <lambdabot>  error:
10:42:54 <lambdabot>      • Could not deduce (Num [Expr]) arising from a use of ‘-’
10:42:54 <lambdabot>        from the context: Foldable t
10:43:10 <metahumor> > foldr (-) [1, 2, 3, 4] :: Expr
10:43:12 <lambdabot>  error:
10:43:12 <lambdabot>      • Couldn't match expected type ‘Expr’
10:43:12 <lambdabot>                    with actual type ‘[[Integer]] -> [Integer]’
10:43:30 <metahumor> > foldr (-) 0 [1, 2, 3, 4] :: Expr
10:43:32 <lambdabot>  1 - (2 - (3 - (4 - 0)))
10:43:38 <metahumor> > foldl (-) 0 [1, 2, 3, 4] :: Expr
10:43:40 <lambdabot>  0 - 1 - 2 - 3 - 4
10:43:56 <metahumor> Bowlslaw: do you see the difference?
10:44:28 <Bowlslaw> hm
10:45:59 <metahumor> > foldr f x [a, b, c, d] :: Expr
10:46:01 <lambdabot>  f a (f b (f c (f d x)))
10:46:06 <metahumor> > foldl f x [a, b, c, d] :: Expr
10:46:07 <lambdabot>  f (f (f (f x a) b) c) d
10:46:21 <Bowlslaw> ah
10:46:22 <Bowlslaw> now I see
10:46:28 <metahumor> Bowlslaw: do you see how "foldl" builds a deep expression of "f (f .." first?
10:46:36 <Bowlslaw> very cool
10:46:39 <Welkin> Bowlslaw: implement foldr yourself as a recursive function
10:46:45 <Welkin> it will help you understand it better
10:46:48 <Welkin> same with foldl
10:46:51 <Bowlslaw> ok
10:46:59 <Bowlslaw> I'm working on cis194 right now
10:47:26 <Bowlslaw> I have my doubleEveryOther function which works perfectly except that it only works left-to-right
10:47:29 <Welkin> although implement it specifically for lists
10:47:52 <Welkin> it's completely valid to reverse the list as well for that use case
10:47:56 <Welkin> do whatever works
10:47:58 <Welkin> there is no wrong way
10:48:07 <Bowlslaw> yeah my naive solution is to reverse -> apply -> reverse
10:48:08 <Welkin> but foldr will show up again and again and is helpful to know
10:48:19 <Bowlslaw> yes
10:48:42 <Bowlslaw> my issue is a syntax one
10:49:11 <Bowlslaw> I can store a list as a variable in my function and operate on it right?
10:49:27 <Welkin> you can bind an input to a variable name, yes
10:49:33 <Welkin> it is not stored
10:50:16 <metahumor> Bowlslaw: you can also "pattern match"
10:50:37 <Welkin> actually, I have chapter 3 of my book almost done, and it talks all about lists
10:50:57 <Welkin> Bowlslaw: http://haskellroguelike.com/lessons/3/
10:51:05 <Welkin> you may want to read the previous 2 chapters as well, though
10:51:16 <Welkin> it is not the finished version, but it is mostly all there
10:51:22 <Welkin> I'm publishing as I go
10:51:37 <Bowlslaw> http://lpaste.net/362602
10:51:46 <Bowlslaw> "using a list literal"
10:51:51 <Welkin> It talks about lists and recursion in detail
10:51:53 <Bowlslaw> i think i see where this is going
10:51:56 <Bowlslaw> thanks
10:52:11 <Welkin> you can ignore those warnings
10:52:12 <Bowlslaw> storing it as a literal means I can't apply reverse to it i think
10:52:18 <Welkin> especially on lpaste
10:52:29 <Welkin> those are not true warnings
10:52:31 <metahumor> Bowlslaw: yes, you could have written it that way
10:52:39 <metahumor> Bowlslaw: doubleEveryOther [x] = [x]
10:52:40 <Welkin> that website uses a style guideline that the owner likes, not something standardized
10:52:55 <Bowlslaw> oh I see
10:53:00 <Bowlslaw> wel, that's REALLY good to know lol
10:53:03 <Welkin> it is just a syntactic sugar
10:53:16 <Welkin> I cover this in that chapter I just linked
10:53:17 <metahumor> Bowlslaw: but will it work on "[8,7,6,5]" as the book wants?
10:53:27 <Bowlslaw> metahumor: nope
10:53:32 <metahumor> Bowlslaw: =)
10:55:36 <Welkin> Bowlslaw: if you do read any of it, let me know what you think (I know it needs some editing)
10:55:57 <Bowlslaw> i'm reading it now
10:57:16 <monochrom> merijn: I think sometimes it's "think outside the box" and "the bystander is more objective"
10:58:12 <marekw2143> hi, how to transform [Maybe] into Maybe [] ?  :)
10:58:27 <marekw2143> I remember it is related to some topic around monads ;)
10:58:29 <Welkin> marekw2143: look at sequence
10:58:29 <metahumor> marekw2143: do you mean [Maybe a] to Maybe [a]?
10:58:31 <monochrom> Consider "traverse".
10:58:43 <marekw2143> metahumor: yes
10:58:44 <Welkin> or traverse, almost the same thing
10:58:44 <monochrom> And it just needs Applicative.
10:59:00 <metahumor> ^^ sequenceA
10:59:16 <marekw2143> thanks!
11:01:34 <marekw2143> I see sequenceA is generic, i.e. it not only traverses Monad containing list, but any other applicative container
11:01:43 <metahumor> :t sequenceA
11:01:44 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:01:51 <merijn> monochrom: THe thing is, he literally didn't look long enough to read a line of code before pointing
11:02:06 <merijn> monochrom: And the bug was subtle enough to not directly see from reading
11:03:57 <ski> Welkin : "procudes"
11:04:24 <Welkin> ski: ?
11:04:32 <ski> in lesson 3
11:05:50 <Welkin> ski: thanks! fixed
11:06:50 <Welkin> ski: also found another spelling error a few words later
11:06:51 <Welkin> o.o
11:06:57 <Welkin> this keyboard is not serving me well
11:07:16 <Welkin> (missed letters)
11:07:20 <ski> while i'm nitpicking, i automatically want to change `([])' to `[]'. and perhaps also consider saying that `[x]' works as fine as a pattern as does `x : []'
11:08:06 <ski> (and i wonder how much help, if any, it is to include the `append xs []' case)
11:08:10 <Welkin> ski: I considered doing that, but I want to avoid mixing syntactic sugar in while I explain lists for the firs time. I might add that in at the end
11:08:25 * ski nods
11:08:37 <ski> that's fair. just as long as you consider it
11:09:03 <Welkin> ah, you are right about the append xs []
11:09:19 <Welkin> I suppose it is not necessary, just me doing some on-the-fly optimization without realizing
11:09:45 <ski> a definition like that is what a newbie could well write
11:10:45 <ski> but if you want to emphasize the common pattern of only doing structural recursion on a single list argument, by considering empty vs. non-empty, this doesn't help much with that
11:11:51 <Welkin> I think I will remove that line
11:11:57 <ski> (also consider the related cases when newbies define the case for the singleton list separately, or perhaps even forgets about the empty case, when an empty vs. non-empty would have works just as well, and often more simply)
11:13:45 <ski> (of course, it's good to emphasize that not all list recursions fit nicely into this pattern. e.g. `zip' or checking that a list is ordered/sorted)
11:15:17 <ski> (fwiw, if one wanted to check whether the second list was empty, i suppose one'd either only do that in a wrapper function, to avoid having to recheck it. or perhaps GHC is smart enough to figure out that transformation on its own ..)
11:24:16 <Welkin> ski: I updated it. Still needs more work, thought. Thanks for the feedback
11:27:43 <bash0r> Is there some library to encode Word64 to [Word8] as binary data?
11:28:24 <merijn> bash0r: binary
11:28:49 <merijn> bash0r: Rather, that encodes to ByteString, but you can unpack to [Word8] if you really need it
11:29:39 <bash0r> merijn: ahh, had no time to look that library up. My parents dogs are kinda stressing right now.
11:30:03 <Welkin> bash0r: are they dish licking dogs?
11:30:14 <merijn> bash0r: Specifically Data.Binary.Put if you wanna control the specific resulting binary data
11:30:16 <bash0r> Welkin: lol kinda.
11:31:32 <bash0r> merijn: thank you very much!
11:47:27 <Zemyla> So would stToSTM :: (forall s. ST s a) -> STM a be a viable and useful method?
11:47:41 <fresheyeball> Is there a Nick Smallbone in here today?
11:48:04 <fresheyeball> Calling Nick! I could use some help using the quickspec library.
11:48:56 <quchen> bash0r: There are lots of primitives in here too, https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Prim.html
11:49:08 <quchen> bash0r: Search for »pack«
11:50:11 <bash0r> quchen: cool, thanks!
11:50:17 <quchen> bash0r: Be careful about endianness though, no idea how that’s handled
11:51:23 <lyxia> Zemyla: I don't see how that's useful, runST is much more powerful.
11:51:30 <bash0r> quchen: I don't think that endianess will be a problem in this case as it's for a server cluster running every machine with the same setup.
11:52:49 <quchen> stToStm = pure . runST :-)
11:54:08 <ski> @type let stToSTM :: (forall s. ST s a) -> Control.Concurrent.STM.STM a; stToSTM act = return (runST act) in stToSTM
11:54:09 <lambdabot> (forall s. ST s a) -> GHC.Conc.Sync.STM a
11:55:53 <Zemyla> Well, given current representations, it'd actually be implemented as stToSTM = coerce.
11:57:02 <barrucadu> What would the semantics of stToSTM be?
11:57:25 <Zemyla> Basically, that the ST calculation completes before returning.
11:58:37 <Zemyla> @type let stToSTM :: (forall s. ST s a) -> Control.Concurrent.STM.STM a; stToSTM act = runST (fmap return act) in stToSTM
11:58:38 <lambdabot> (forall s. ST s a) -> GHC.Conc.Sync.STM a
11:58:44 <Zemyla> You could also do that, I suppose.
12:02:14 <fresheyeball> anyone know an alternative to QuickSpec?
12:02:25 <fresheyeball> something that automates the finding of laws?
12:02:37 <fresheyeball> I am finding the task of finding laws very tedious
12:02:41 <barrucadu> fresheyeball: There's also Speculate
12:03:36 <fresheyeball> barrucadu: NICE!
12:04:11 <fresheyeball> barrucadu: way more recent too!
12:06:44 <barrucadu> Also, QuickSpec is significantly more updated on github
12:09:29 <ski> Zemyla : hm, i suppose that's equivalent by a free theorem on `runST'
12:11:19 <parsnip> i've logged in and watching it, but is there a non-login version i can toot about? https://jaspervdj.be/posts/2017-12-07-getting-things-done-in-haskell.html
12:11:31 <parsnip> (skills matter login)
12:16:01 <akr> Hello, I was just wondering if someone can tell me what would be the best way to format the following one-liner :) It doesn't look too readable this way:
12:16:02 <akr> reachableWith f acc x = foldl (\a s → if s `elem` a then a else reachableWith f (s:a) s) acc (f x)
12:17:36 <parsnip> akr: i've seen `go` used quite a bit
12:18:02 <parsnip> so like, `foldl go acc (f x) where go a s = ...`
12:18:06 <Bowlslaw> lol, I just went with the simple way and made a "helper" function for doubleEveryOther
12:18:20 <akr> what's go? sorry, not familiar
12:18:25 <akr> oh you mean call the lambda go in a where block?
12:18:32 <parsnip> sort of
12:18:53 <parsnip> i guess just go like, a common keyword used for local functions?
12:19:09 <cocreature> go is what you call your functions if you already have one named "f" ;)
12:19:30 <parsnip> you could just do `g` of `h` or whatever, or if you prefer a more suggestive name, that seems good to me.
12:19:45 <akr> what about g? :P
12:19:52 <parsnip> seems fine
12:20:25 <parsnip> i think cocreature 's wink suggests there was some humor implied.
12:20:53 <parsnip> but then maybe :P means you got it :D
12:21:09 <akr> if I do that though, I can't brag that I implemented depth-first search in one line anymore :|
12:21:28 <cocreature> on a slightly more serious note, "go" is commonly used for the kind of tail-recursive definitions that you would implement using loops in an imperative language
12:21:29 <akr> indeed xD
12:21:48 <cocreature> but it’s just an arbitrary convention that most people don’t strictly adhear to
12:22:48 <akr> sounds fair enough
12:22:48 <qeyoa> I'm doing an exercise, but not quite sure what "in turn about order" means : "Define a function altMap :: (a -> b) -> (a -> b) -> [a] -> [b] that alternately applies its two argument functions to successive elements in a list, in turn about order". I've implemented the function as: http://lpaste.net/362605  but my implementation returns different results based on the length of array. I'm not sure if the author is asking for implementati
12:22:48 <qeyoa> on that always starts in a predefined manner irrespective to the list size? Also, is `length` costly computationally?
12:22:50 <akr> alright thanks guys :)
12:24:32 <parsnip> akr: `bool` might save you a few characters :)
12:24:36 <parsnip> @hoogle bool
12:24:37 <lambdabot> Data.Bool bool :: a -> a -> Bool -> a
12:24:37 <lambdabot> Data.Aeson.Encoding bool :: Bool -> Encoding
12:24:37 <lambdabot> Data.Aeson.Encoding.Internal bool :: Bool -> Encoding
12:24:47 <ski> qeyoa : are you sure `f' shouldn't be applied to even-indexed elements, and `g' to odd-indexed elements ?
12:25:11 <ski> qeyoa : also, please use pattern-matching rather than `head' and `tail'
12:25:14 <[exa]> qeyoa: I kindof think you should not measure the length of every tail of the list
12:25:42 <[exa]> qeyoa: it's much better to recurse using 'altMap g f' instead of 'altMap f g'
12:25:55 <ski> qeyoa : and yes, rechecking `length' at each recursive step is needlessly inefficient. if you want to use the length, at least compute it only once
12:26:34 <qeyoa> hm, the author gave the declaration of the function
12:26:50 <qeyoa> i don't think i can pass another argument
12:27:08 <parsnip> qeyoa: author of which text?
12:27:18 <qeyoa> of the exercise
12:27:28 <[exa]> qeyoa: If I got it correctly, it should take [a,b,c,d] and return [f a, g b, f c, g d] ?
12:27:43 <ski> qeyoa : if you define a local (recursive) worker function, that the wrapper `altMap' calls, i don't see how that would be a problem
12:27:47 <qeyoa> "-- 9. Define a function altMap :: (a -> b) -> (a -> b) -> [a] -> [b] that alternately applies its two argument functions to successive elements in a list, in turn about order. For example:
12:27:47 <qeyoa> -- > altMap (+10) (+100) [0,1,2,3,4]
12:27:47 <qeyoa> --[10,101,12,103,14]"
12:28:06 <ski> qeyoa : how about a list with even number of elements ?
12:28:27 <parsnip> qeyoa: i was wondering what text this is, as sometimes there's a sense where the author means for you to freely change types.
12:28:42 <qeyoa> do you mean book?
12:28:48 <parsnip> yes, if it's a book
12:28:58 <qeyoa> graham hutton
12:29:03 <ski> (or, alternatively, one could have mutual recursion)
12:29:05 <qeyoa> programming in haskell
12:33:07 <parsnip> i'd think you can always just look near front of list.
12:33:32 <parsnip> since haskell's lists are linked lists, this should be more efficient. but computing length once is fine too.
12:33:57 <qeyoa> what do you mean by "near front list"
12:33:58 <qeyoa> ?
12:34:32 <parsnip> as in, first element is very near the front.
12:34:45 <parsnip> second element is sort near, etc.
12:34:48 <parsnip> *sort of near
12:35:15 <parsnip> but going to end of list every time is "inefficient".
12:35:27 <parsnip> big oh notation, blah blah
12:36:03 <qeyoa> so lists don't have size information in them
12:36:07 <parsnip> if you take two steps in, n times, that's only 2*n, which we consider same as n.
12:36:09 <parsnip> right
12:36:29 <parsnip> but pointed out earlier, you can compute it once inside your function, and that's fine.
12:36:40 <qeyoa> but i cannot pass it
12:36:45 <qeyoa> with the current declaration
12:37:09 <parsnip> qeyoa: well, there's local, but let's make it simpler.
12:37:31 <parsnip> qeyoa: define a second top level function with any type you want, and have the exercises function call that one.
12:37:50 <qeyoa> ah, ok, but isn't that cheating
12:37:52 <parsnip> i often do that first, then make it local once i've worked it out.
12:37:56 <parsnip> no
12:37:58 <bash0r> qeyoa: nope it's not cheating.
12:38:24 <parsnip> it's more like, breaking your problem down into digestible parts.
12:38:35 <parsnip> haskell is great for that.
12:38:38 <[exa]> qeyoa: in fact its a better programming practice
12:39:17 <fresheyeball> barrucadu: so I gave speculate a shot
12:39:30 <bash0r> qeyoa: there's a principle called "divide and conquer". That's divide and conquer applied. If the outer world does not need to see this internal detail of your algorithm then why show it? It only causes confusion. Divide your problems and conquer them afterwards.
12:39:36 <fresheyeball> it's much nicer than quickspec
12:39:44 <fresheyeball> but it still didn't find functor composition
12:39:59 <fresheyeball> fmap g . fmap f = fmap (g . f)
12:41:00 <parsnip> qeyoa: code golf is fun, making things terse, but writing things out very plainful, or a good ratio of terseness to verbose, is better for sharing.
12:41:07 <parsnip> *plainly
12:43:28 <lseactuary> i have defined some types and using those types defined a function of types. is it possible to see the structure of the inputs / outputs expected in haskell?
12:43:46 <ski> qeyoa : this is often called "worker-wrapper"
12:44:11 <fresheyeball> anyone know of a a property finder that really works? (finds all the laws)
12:44:20 <parsnip> can't decide how to organize my haskell euler solutions as i revisit them. making them each self contained scripts seems tedious, making them each libraries seems a little tedious but at least "organized"...
12:48:57 <[Leary]> lseactuary: maybe you're looking for kinds?
12:49:01 <[Leary]> :k Maybe
12:49:02 <lambdabot> * -> *
12:49:05 <[Leary]> :k Either
12:49:06 <lambdabot> * -> * -> *
12:49:08 <qeyoa> well, i gave it a shot: http://lpaste.net/362608
12:49:51 <qeyoa> is that what you guys meant?
12:50:24 <[Leary]> That's the same function twice, BTW.
12:50:27 <[exa]> qeyoa: the last cosmetic thing -- if you look at both definitions they are completely the same right?
12:50:51 <qeyoa> yes
12:51:48 <[exa]> a single definition should be just enough then.
12:52:02 <qeyoa> by definition you mean declaration
12:52:05 <parsnip> cool!
12:52:07 <qeyoa> the first line in the function ?
12:52:22 <parsnip> a single function
12:52:39 <[Leary]> I'm guessing they wanted the other one to apply the second function to the first element.
12:52:57 <[exa]> qeyoa: to see it, let's swap all 'f' and 'g' in altMapG
12:53:07 <parsnip> qeyoa: they are the same. so eliminate the redundancy.
12:54:06 <parsnip> unfoldr would be a slick solution?
12:55:44 <ski> <ski> qeyoa : also, please use pattern-matching rather than `head' and `tail'
12:56:09 <heptahedron> Is there a good way to go about taking a package name on hackage that is currently unmaintained and out-of-date?
12:56:17 <qeyoa> ok, once i figure out the single function solution
12:58:43 <Bowlslaw> i can give you an example of whwere I used that helper function thing
12:58:47 <Bowlslaw> i learned it from SICP
12:58:57 <Bowlslaw> i'm working through cis194 right now
12:59:03 <Bowlslaw> is programming in haskell good?
12:59:06 <ski> SICP has many nice lessons
12:59:12 <fragamus> does anyone have a good .spacemacs file for haskell development
12:59:17 <Bowlslaw> i have so many resources resource overloads
12:59:20 <ski> Bowlslaw : i think so
13:07:57 <lseactuary> ski if i define types and then a rule like hello :: type -> type is there a way to understand what data types hello should have in Haskell?
13:10:26 <heptahedron> lseactuary: what are you trying to do?
13:10:38 <Bowlslaw> do you mean how do you check the types? If so, you can use ghci to get the types: `:t hello`
13:10:58 <lseactuary> heptahedron i am trying to do some exercises and if i can understand the expected types then i can figure out a function.
13:11:05 <Bowlslaw> > :t "chars"
13:11:06 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:11:52 <Welkin> lambdabot isn't ghci though
13:12:10 <Welkin> it has a special trigger in here, which is just `:type` or `:t`
13:12:38 <Bowlslaw> :t "chars"
13:12:39 <lambdabot> [Char]
13:12:42 <Bowlslaw> cool
13:14:05 <parsnip> if my executable uses a neighboring file, i need to put that file in "exposed-modules:"?
13:14:55 <parsnip> and i guess i need to do that for P001.hs, P002.hs, ...
13:15:16 <Welkin> parsnip: why would you neam your modules poo with a number?
13:15:17 <lseactuary> the problem is that i need to write the function with the :: data types but if i dont understand what they are then im unsure how to write the function
13:15:20 <Welkin> name*
13:15:23 <lseactuary> is there a way haskell can help me
13:15:49 <parsnip> Welkin: not sure if trolling.
13:16:21 <parsnip> Welkin: problem 1, problem 2, ...
13:16:30 <parsnip> Welkin: your font? that's a zero.
13:16:36 <Welkin> parsnip: I know
13:16:42 <parsnip> you know what?
13:16:53 <Welkin> that they are zeroes
13:16:57 <Bowlslaw> wow programming in Haskell 2nd ed came out in 2016...that's a strong argument for me to use it
13:17:00 <parsnip> oh, you wrote poo
13:17:09 <Welkin> parsnip: I did
13:17:21 <Welkin> Bowlslaw: I have that book and think it is pretty good
13:17:25 <Welkin> I have only skimmed it though
13:17:35 <Welkin> it is often recommended
13:17:38 <parsnip> i forgot to laugh
13:17:43 <Welkin> it is much better than LYAH or RWH
13:18:30 <Welkin> it looks like it covers everything you need to get started, sans monad transformers
13:19:37 <Welkin> parsnip: it's never too late
13:19:40 <Bowlslaw> so these are the resources I have: Haskell Wiki, CIS194, Real World Haskell, Beginning Haskell, and Haskell Programming from First Principles
13:19:41 <merijn> argh...
13:20:24 <merijn> Apparently my code is failing because damn conduit is swallowing one of my data items somewhere
13:20:27 <Bowlslaw> oooh programming in Haskell is only like 300 pages?
13:20:37 <Welkin> Bowlslaw: 250
13:20:40 <Bowlslaw> OOOOH
13:20:42 <Welkin> with 50 pages of appendices
13:20:49 <Welkin> that is one reason I like it
13:20:49 <Bowlslaw> in the tradition of K&R C, I see
13:21:03 <Welkin> I am trying to make my book just as concise
13:21:46 <lseactuary> anyone have any advice please? i am trying to learn this but not being able to write the functions because idk the data types makes things hard.
13:22:06 <Bowlslaw> lseactuary: you can check the data types with :t
13:22:26 <lseactuary> but the .lhs file doesnt compile with just the types - i need to pass a function
13:22:30 <Bowlslaw> :t "what type is this?"
13:22:30 <lambdabot> [Char]
13:23:20 <Welkin> lseactuary: the types exist to make programming easy
13:23:32 <Welkin> they aren't what make it hard
13:23:42 <davean> I think there is some language barrier happening here
13:23:48 <Welkin> if they ar hard, you are not using them at all
13:23:52 <quchen> lseactuary: You could show us the error message and the code and maybe we can help.
13:23:58 <quchen> ?where paste
13:23:58 <lambdabot> Haskell pastebin: http://lpaste.net/
13:24:29 <lseactuary> hmm i basically have some questions i am trying to answer - they give me the type and a name_of_function :: type -> type etc
13:24:47 <lseactuary> i am trying to understand what "type -> type" means in (a-> [a]) etc notation
13:24:55 <lseactuary> so i can use hoogle and try to figure out a function
13:25:07 <lseactuary> am i making sense?
13:25:10 <Welkin> don't use hoogle
13:25:17 <Welkin> write the function yourself
13:25:25 <lseactuary> but i dont know how i am learning this
13:25:43 <heptahedron> lseactuary: `a -> b` means a function taking an argument of some type `a` and returning a value of some type `b`
13:25:46 <lseactuary> yes
13:25:53 <Bowlslaw> for a function func :: a -> [a], 'func' is a function which accepts type a, and returns type [a]
13:25:58 <lseactuary> yup
13:26:39 <Welkin> `type -> type` is the same as `a -> a`
13:26:39 <heptahedron> lseactuary: Hm. Are you able to elaborate on where you begin to misunderstand things
13:26:50 <lseactuary> let me upload one example
13:28:29 <Bowlslaw> https://digitalbookstream.com/product/programming-in-haskell-ebook/ not sure if worth...
13:28:53 <Welkin> Bowlslaw: I paid $40 for my copy
13:28:57 <Welkin> $10 is a steal
13:28:57 <Bowlslaw> ebook?
13:29:01 <Welkin> physical book
13:29:10 <heptahedron> Bowlslaw: not sure about that one, but have you seen https://haskellbook.com/ ?
13:29:13 <Bowlslaw> well yes, I know that $10 is a good price, but I'm uncertain of that vendors quality
13:29:26 <Bowlslaw> they just say "ebook", in what format? pdf??
13:29:27 <hpc> is the humble bundle still going?
13:29:27 <Welkin> heptahedron: he already has that
13:29:30 <heptahedron> whoops apparently it's not http
13:29:36 <heptahedron> Welkin: oh double whoops
13:29:38 <Welkin> and the book he linked, Programming in Haskell is extremely reputable
13:29:54 <Welkin> written by a professor who has been with haskell since near the beginning
13:30:02 <heptahedron> looks like I'm full of mistakes today!
13:30:32 <Bowlslaw> ah it says format: converted-pdf
13:30:47 <Welkin> I prefer physical books, always
13:30:54 <merijn> So, I don't suppose anyone here has a clue why "runConduit $ mySource .| C.mapM_ (liftIO . print)" prints 10 lines, but "runConduit $ mySource .| C.length" and "runConduit $ mySource .| C.foldl (\n _ -> n + 1) 0" return 9?
13:31:03 <lseactuary> https://pastebin.com/YAruS3BG
13:31:06 <merijn> This is driving me insane
13:31:06 <lseactuary> i am trying to write those functions
13:31:07 <Welkin> but at that price go ahead and get it if you won't be buying a hard copy
13:31:15 <Welkin> merijn: ask snoyberg?
13:31:36 <dgpratt> hpc: I had seen that humble bundle and wondered if it was worth it, have you an opinion?
13:31:41 <lseactuary> i want to try and test but i don't understand how to convert the stuff after :: to make it make sense to me in order to find functions to apply
13:31:51 <Welkin> the "functional programming" o'reilly bundle?
13:31:55 <Welkin> it is awful
13:32:02 <Welkin> most of the languages are not even functional
13:32:06 <hpc> if you're aiming to learn haskell, $8 isn't worth it, maybe the $15 one is
13:32:08 <Bowlslaw> haha Welkin my instinct was similar
13:32:09 <Welkin> the 2 haskell books they have are available online free
13:32:11 <heptahedron> Welkin: aww, I was going to look into that
13:32:24 <Welkin> many o'reilly books are terrible
13:32:25 <heptahedron> Welkin: even the scala book's bad? I don't particularly like it but I thought it might be useful to hoard
13:32:30 <dgpratt> hpc: I'd consider myself an intermediate/casual Haskeller
13:32:32 <merijn> Welkin: Not particularly helpful feedback
13:32:37 <Welkin> I don't know about the quality of every book
13:32:44 <heptahedron> lseactuary: Why have you written finite beside `[c]`?
13:32:45 <hpc> personally i wouldn't bother, because they're ebooks
13:33:00 <Welkin> merijn: it's the only feedback I have since I don't use conduit. But I know that snoyberg wrote it, and you can email him
13:33:44 <heptahedron> lseactuary: Also, the type of `maybeLookup` seems to be going against its name--there's no `Maybe` involved in the type whatsoever
13:33:49 <Bowlslaw> I typically prefer physical copies(I have a veritable library), but programming books in pdf form are nice for me so I can open them beside my editor
13:34:08 <lseactuary> heptahedron as a word is defined before as a finite sequence of characters
13:34:16 <Welkin> I thought about it for the rust book (even though rust is not functional)
13:34:36 <Bowlslaw> i absolutely need physical copies for math books like (https://www.amazon.com/Introduction-Functional-Programming-Calculus-Mathematics/dp/0486478831/ref=sr_1_1?s=books&ie=UTF8&qid=1518903130&sr=1-1&keywords=lambda+calculus&dpID=41Gg4xwsV7L&preST=_SY291_BO1,204,203,200_QL40_&dpSrc=srch) though
13:34:47 <heptahedron> lseactuary: That's how we think of words, I agree, but there's nothing about the type "list of `c`" (written `[c]`) that suggests that list is finite
13:34:59 <hpc> Welkin: i prefer the one on the rust website
13:35:00 <Welkin> but the real test is asking yourself "would I buy this at full price?"
13:35:01 <lseactuary> ah ok
13:35:06 <Welkin> if yes, then get it. If no, then don't
13:35:09 <Bowlslaw> Welkin: absolutely I would
13:35:15 <Welkin> otherwise you are just wasting money on something you won't actually use
13:35:19 <qeyoa> ok, after banging my head against the wall, i think i might have a solution to the altMap problem: http://lpaste.net/362610
13:35:29 <Bowlslaw> it has a great reputation and reading the samples chapters has me as execited as a schoolgirl
13:35:34 <heptahedron> let me see if I can use lambdabot without looking back at how you're supposed to invoke it lol
13:35:39 <heptahedron> lambdabot: take 10 [1..]
13:35:44 <heptahedron> negative
13:35:45 <Welkin> Bowlslaw: which book?
13:35:50 <glguy> qeyoa: That works, but someone showed you earlier how to do it with only two cases instead of 3
13:35:52 <Bowlslaw> SUtton's
13:35:56 <Welkin> ah, yes
13:36:05 <lseactuary> heptahedron i should just use Data.Word for these then?
13:36:12 <Welkin> it is worth the full price
13:36:23 <heptahedron> lseactuary: nooooonono, that's not what you think it means, that's a number
13:36:32 <lseactuary> my issue is line 9 - how to i convert that into something like line 6
13:36:35 <lseactuary> hmm
13:36:49 <lseactuary> k and v are numbers?
13:36:52 <merijn> I feel like I'm taking crazy pills...
13:36:56 <lseactuary> or which line did you mean
13:36:56 <heptahedron> lseactuary: Hold on a second
13:37:00 <lseactuary> ok
13:37:09 <Bowlslaw> Welkin: SICP was so good that I want to shell out for a quality hardback copy
13:37:30 <Welkin> merijn: I have historically found it almost impossible to get support for any of snoyberg's libraries except by random people who happen to be around
13:37:36 <Welkin> the documentation is terrible for all of them
13:37:38 <qeyoa> glguy, what do you mean? They told me to do it with a single function and i went straight to the code, maybe i missed something?
13:37:45 <heptahedron> lseactuary: Your type, `Word c`, is fine. That's a very sane definition of a word. I was just saying that, from the type `[c]`, one cannot (in /general/) infer that `[c]` has a /finite/ number of elements--I just wanted to make that clear
13:37:46 <Welkin> I eneded up reading a *lot* of yesod source code
13:37:50 <glguy> I guess you missed it then :)
13:38:02 <qeyoa> well ok
13:38:04 <lseactuary> heptahedron yup makes sense
13:38:07 <qeyoa> i will try to think of that too
13:38:12 <heptahedron> lseactuary: Before we continue, what do you mean when you say you're trying to "convert" between these types
13:38:15 <glguy> qeyoa: 12:25        [exa]: qeyoa: it's much better to recurse using 'altMap g f' instead of 'altMap f g'
13:38:31 <merijn> Welkin: In my experience Snoyberg is rather responsive, but lots of people use conduit
13:38:34 <Bowlslaw> hm I am getting untrustworthy reviews for digitalbookstream
13:38:50 <lseactuary> heptahedron how do i make line 9 look more like line 9 so i understand the structure, and therefore can see what functions to apply
13:38:50 <merijn> It seems baffling that it's just randomly skipping a single element for no discernible reason
13:38:55 <lseactuary> *line 9 -> line 6
13:39:05 <davean> I'm wondering if lseactuary's issue is they've used unicode in their types and haven't enabled unicode support
13:39:32 <lseactuary> davean - this is in a notes / printed book :/ so maybe
13:39:33 <qeyoa> glguy, how so,  aren't those just functions
13:39:33 <heptahedron> davean: wow, I totally missed that, nice catch lol
13:39:50 <heptahedron> lseactuary: rewrite the funky arrows first so the fat one's `=>` and the skinny one's `->`
13:39:52 <glguy> qeyoa: I don't know what you're asking? Are you asking if f and g are "just functions"?
13:40:03 <qeyoa> well if i switch the f g around
13:40:10 <qeyoa> nothing changes, except the ordering
13:40:11 <qeyoa> ?
13:40:21 <lseactuary> heptahedron yeah
13:40:24 <Welkin> what is altMap here?
13:40:26 <glguy> yeah, and when you have two different functions ordering matters
13:40:37 <Welkin> fmap?
13:40:39 <lseactuary> heptahedron sorry i did this i think it didn't paste very well
13:41:14 <qeyoa> but the order is the same as in the book example
13:41:16 <dgpratt> lseactuary: just fyi, I think folks around here would prefer if you used lpaste
13:41:17 <heptahedron> lseactuary: Okay, am I right in guessing that what you mean by "convert" now is to break down the type of `rewrite` so it doesn't contain these type synonyms you've defined, that are obscuring what kind of values you're working with to you?
13:41:27 <lseactuary> but basically Grammer s -> (Word s, Word s) is [a, [a]] -> ([a] -> [a])?
13:41:31 <lseactuary> yes
13:41:37 <heptahedron> lseactuary: Okay, good
13:41:38 <dgpratt> ?where paste
13:41:39 <lambdabot> Haskell pastebin: http://lpaste.net/
13:41:40 <glguy> qeyoa: The order when you define altMap and the order when you call it recursively can be different and this is meaningful
13:41:49 <lseactuary> so that then i can try to figure out the function :)
13:42:03 <lseactuary> dgpratt oki will use from now
13:42:07 <heptahedron> lseactuary: Also let me just point out that your type `Rule c` is not a pair of characters and a word!
13:42:26 <lseactuary> oh
13:42:33 <heptahedron> lseactuary: take another look at it and tell me if you can't figure out what it actually is
13:42:44 <qeyoa> glguy, i will try to look at the code again, but i'm not quite sure where the difference might be
13:43:04 <Bowlslaw> Welkin: i'm so disappointed that they don't even offer textbooks as hardbacks anymore...
13:43:06 <lseactuary> its a symbol and a word right like (A, APPLE)
13:43:11 <glguy> qeyoa: Hopefully it will be a useful "ah ha" sort of moment
13:43:12 <heptahedron> lseactuary: correct.
13:43:15 <lseactuary> ye
13:43:18 <lseactuary> good :)
13:43:20 <davean> Its a paired characture and word might be another way to say it
13:43:29 <lseactuary> yup
13:43:40 <Welkin> Bowlslaw: paperbacks are easier to read in bed and hold in your hand
13:43:43 <heptahedron> lseactuary: Which tells me, just guessing by the types of your other functions, that what you've defined as a `Rule` may not be what's desired here
13:44:13 <lseactuary> hmm
13:44:15 <heptahedron> lseactuary: Tell me how you'd read the type of `rewrite` aloud--don't worry about breaking down the type synonyms
13:44:44 <Bowlslaw> Welkin: I actually think the opposite lol
13:45:09 <lseactuary> rewrites a word according to a grammer, substituting each character in parallel. If any character in the word matches no rule in the grammar, it should remain unchanged
13:46:24 <heptahedron> lseactuary: well, that's good to know, but I meant just what you could read from the type `Eq s => Grammar s -> Word s -> Word s`. But that's fine, you don't have to
13:46:36 <glguy> > let example x y = x : example y x in take 10 (example 1 2) -- qeyoa
13:46:38 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
13:46:52 <lseactuary> ah so the input is Grammer s and Word s to produce Word s
13:47:04 <lseactuary> that bracket threw me off
13:47:53 <heptahedron> lseactuary: Perfect, yeah. But just fyi, the type including the parentheses, `Eq s => Grammar s -> (Word s -> Word s)` is actually identical to `Eq s => Grammar s -> Word s -> Word s`
13:48:01 <lseactuary> ooh
13:48:08 <lseactuary> sorry i thought the () mattered
13:48:13 <lseactuary> as in the next question they have this
13:48:17 <heptahedron> lseactuary: They do--just not in this specific case
13:48:20 <lseactuary> ah
13:48:29 <heptahedron> lseactuary: Have you learned about currying yet?
13:48:33 <lseactuary> yeah
13:48:37 <glguy> -> is "right associative, so   a -> b -> c   is   a -> (b -> c)
13:48:43 <lseactuary> oh yeah
13:49:22 <lseactuary> so now i just need to understand Grammer as a [a] type
13:49:27 <lseactuary> then I can try to write the functions
13:49:38 <hask_bee_3> Is anyone here currently using Stack with Docker enabled on macOS?
13:49:51 <lseactuary> so Word = [a] just a string as a list?
13:49:58 <heptahedron> lseactuary: whoa there
13:50:03 <heptahedron> lseactuary: no, haha
13:50:06 <lseactuary> oh
13:50:18 <lseactuary> why do they have [] then?
13:50:25 <heptahedron> lseactuary: `Word`, as you've defined it, /has to take a type argument/, which is called `c` in this case
13:50:41 <lseactuary> we are looking at types now?
13:50:55 <lseactuary> type Word s = [s]
13:51:53 <heptahedron> lseactuary: All those places you've written `type Something = SomethingElse` are defining a new type synonym. So any place you use that type synonym, you just replace the left-hand side (e.g. `Word c`) with the right-hand side (`[c]`)
13:52:39 <lseactuary> where [c] is a string of characters right?
13:53:06 <qeyoa> glguy, so like this: http://lpaste.net/362610
13:53:24 <heptahedron> lseactuary: `c` doesn't mean anything on its own, it's just a variable, like how in term-level functions `f x = x + 2`, `x` is just a variable whose value we have to supply
13:53:50 <lseactuary> so Rule c = [c,Wordc] = [c,[c]]?
13:54:15 <heptahedron> lseactuary: There is a difference between parentheses and brackets here but you're on the right track
13:54:38 <lseactuary> Rule c = (c,Wordc) = (c,[c])
13:54:43 <heptahedron> brilliant! yes
13:54:55 <lseactuary> grammer then is just [c,[c]]
13:55:05 <heptahedron> lseactuary: ah, careful there
13:55:05 <glguy> qeyoa: yeah
13:55:10 <qeyoa> facepalm
13:55:18 <heptahedron> lseactuary: Don't forget the parentheses around `Rule c`
13:55:24 <heptahedron> lseactuary: are you familiar with Python?
13:55:30 <lseactuary> yeah i use python
13:55:39 <qeyoa> i thought of something like this at first and then went around the block doing every iteration
13:55:49 <lseactuary> oh
13:55:49 <heptahedron> lseactuary: So then you know the difference between `[2,3]` and `[(2, 3)]` in Python?
13:55:58 <lseactuary> Rule and S are 2 functions
13:56:01 <lseactuary> S is not a value
13:56:04 <lseactuary> I'm stupid :P
13:56:05 <qeyoa> oh well, at least i got my brain some exercise out of that
13:56:07 <qeyoa> :D
13:56:18 <lseactuary> yeah (2,3) is a tuple
13:56:33 <lseactuary> *pair tuple
13:56:54 <heptahedron> lseactuary: `(c, Word c)` is the type of a tuple where the first element of the tuple is a `c` and the second is a `Word c`
13:57:06 <comerijn> wow...
13:57:08 <lseactuary> yes
13:57:18 <comerijn> holy shit, someone at conduit committed a MAJOR fuckup
13:57:31 <heptahedron> lseactuary: So where you said "grammer then is just [c,[c]]", that's a bit incorrect
13:57:36 <lseactuary> yes
13:57:46 <lseactuary>  Grammar s = [(s,Word s)] = [(s,[s])]
13:57:47 <lseactuary> right?
13:57:51 <heptahedron> lseactuary: poifect
13:57:51 <qeyoa> thanks glguy
13:58:08 <heptahedron> which is to say, perfect
13:58:27 <comerijn> Looks like a bunch of the combinators silently swallow the first element...
13:58:33 <lseactuary> heptahedron so for rewrite i need to take [(s,[s])] and [s] and make [s]
13:58:43 <comerijn> For extra debugging fun, adding a print statement causes them to work again...
13:58:49 <comerijn> because FML
13:58:50 <Welkin> comerijn: there are bugs in every library
13:58:59 <Welkin> I found a bug in Wai that must have been there for years
13:59:05 <Welkin> I keep forgetting to submit a bug report though
13:59:06 <heptahedron> lseactuary: yes, precisely
13:59:07 <comerijn> Welkin: Yes, but this is like SUPER obvious
13:59:15 <ski> qeyoa : now, start again from <http://lpaste.net/362608>, rename `altMap' to `altMapF', and make them local definitions inside a `where' attached to an outer `altMap'
13:59:15 <lseactuary> oooh this is making much more sense now
13:59:20 <lseactuary> that was my main issue
13:59:25 <comerijn> Welkin: As in, literally 80% of obvious usecases are broken
13:59:34 <comerijn> This is not some weird edge condition
13:59:52 <heptahedron> lseactuary: Now, it's actually incredibly easy to satisfy that type without actually considering that description of what you wanted the function to do earlier--all you have to do is give the second argument back and the type-checker will be happy
14:00:04 <heptahedron> lseactuary: You could even completely ignore the second argument and just return an empty list every time
14:00:19 <lseactuary> yeah
14:00:26 <davean> Welkin: Bugs in WAI? I've had plenty of bugs in Warp, but I'm curious what bugs you've seen in Wai given its thinness
14:01:00 <Welkin> davean: there is one bug I ran into late in 2016 when parsing the headers
14:01:00 <lseactuary> heptahedron on the maybeLookup one how do i figure out k -> v
14:01:05 <lseactuary> these are just 2 functions?
14:01:14 <Welkin> davean: I should put together a formal bug report for it
14:01:15 <lseactuary> i wrote code for this but its not correct i think
14:01:30 <heptahedron> lseactuary: Are you sure `maybeLookup` has the correct type?
14:01:32 <lseactuary> because i was thinking in terms of maybe
14:01:42 <davean> Welkin: I'm just curious in an academic way, so you're probably better off going and writing that then explaining. I've given up on using them both
14:01:44 <Welkin> davean: but it naively splits the header string on ';'
14:01:55 <lseactuary> lemme show
14:01:59 <Welkin> davean: what do you use instead of wai/warp?
14:02:11 <davean> Welkin: That doesn't sound like Wai - that sounds like Warp?
14:02:15 <qeyoa> ski: you guys are ruthless :D, my index finger hurts from all the emacsing, will try to write with one hand
14:02:39 <lseactuary> http://lpaste.net/3173346387764969472
14:02:45 <ski> qeyoa : well, i had another lesson in mind :) you don't have to, if you don't feel like it
14:02:51 <davean> Welkin: some internal custom stuff ATM
14:03:10 <Welkin> davean: at a company? Or your own project?
14:03:16 <davean> Welkin: company
14:03:21 <heptahedron> lseactuary: Are these exercises you're doing for school?
14:03:30 <Welkin> that's cool
14:03:31 <lseactuary> nope i dont go to school :)
14:03:43 <davean> Welkin: eh
14:03:43 <Welkin> warp is pretty fast, but openresty still blows it away
14:03:46 <Bowlslaw> lseactuary: bwahahhaha autodidact master race
14:03:54 <Welkin> too bad openresty is only lua
14:04:00 <heptahedron> lseactuary: ah, okay. Did whatever material you're reading specifically instruct you that `maybeLookup` should have that exact type?
14:04:01 <qeyoa> i feel like it! my finger does not and it's pretty late. i will give a quick shot at this and ask you tomorrow for the other one if you will be here
14:04:06 <lseactuary> i am learning some haskell for a work project so doing exercises to learn this notation
14:04:08 <Welkin> well, nginx with a thin api to run lua on top
14:04:15 <lseactuary> heptahedron yes hence my code is wrong
14:04:23 <Bowlslaw> there's your problem, qeyoa. use vim instead of emacs. *runs away after sparking flame war*
14:04:55 <qeyoa> evil mode?
14:04:57 <Welkin> davean: what issues did you find with warp?
14:05:03 <Welkin> it would be nice to get all of them fixed
14:05:17 <heptahedron> lseactuary: tbh, that typing for a function called `maybeLookup` seems pretty weird to me, but if I had to guess, I would understand it as
14:06:13 <heptahedron> lseactuary: "maybeLookup is a function, which for any type `k`, accepts a function having type `k -> v`, a list of `(k, v)` pairs, and a `k`, returning a `v`"
14:06:27 <lseactuary> http://lpaste.net/3173346387764969472
14:06:34 <lseactuary> added the definition from the book if helpful
14:06:50 <lseactuary> yeah i think you are right
14:07:15 <heptahedron> lseactuary: that was, I managed to infer that the first arg was a default `v`-generator just a second ago lol
14:07:23 <lseactuary> :P
14:07:55 <heptahedron> lseactuary: I can tell you're still fairly used to imperative-style programming from the way you've written this haha
14:08:04 <lseactuary> haha
14:08:11 <lseactuary> yeah
14:08:16 <heptahedron> lseactuary: Not criticising, it looks like it'd still work, but there's an easier way
14:08:43 <heptahedron> lseactuary: You've seen pattern matching by now, yeah?
14:08:51 <lseactuary> yeah once i got to lookup k dict i was basically just fudging
14:08:54 <lseactuary> yup
14:09:17 <lseactuary> fudging to try to figure out how to convert types etc :)
14:09:18 <heptahedron> lseactuary: remove the guards (`|`) and do `case lookup k dict of ...`
14:09:29 <lseactuary> ah
14:10:37 <lseactuary> hmm
14:10:49 <lseactuary> but lookup k dict etc gives you a maybe type
14:10:52 <heptahedron> lseactuary: yep!
14:11:02 <heptahedron> lseactuary: What are the two values that `Maybe a` can have
14:11:10 <lseactuary> Nothing or Just a
14:11:24 <heptahedron> lseactuary: So pattern match on those.
14:11:31 <comerijn> @(&%(&#%(&#
14:11:31 <lambdabot> Unknown command, try @list
14:11:35 <lseactuary> ooh
14:11:41 <comerijn> How does commenting out unrelated code break this...
14:11:44 <lseactuary> i have not seen this case notation
14:11:55 <heptahedron> lseactuary: It's pretty essential haha
14:11:57 <lseactuary> can you show me an example (like .... where i need to pattern match)
14:12:03 <lseactuary> then i can try
14:12:07 <lseactuary> i only saw the guards
14:12:11 <lseactuary> and 'when ...;
14:13:06 <heptahedron> lseactuary: Sure. `case lookup k dict of { Just a -> <stuff>; Nothing -> <stuff> }`. Lookup haskell pattern match syntax for an example that doesn't use the brackets and semicolons, I was just keeping it on one line
14:13:24 <lseactuary> ah
14:13:31 <lseactuary> yup will check this :)
14:13:32 <heptahedron> lseactuary: the if-then-else construct in Haskell is, iirc, actually just syntactic sugar for pattern-matching ilke this on a `Bool`, in fact
14:13:39 <lseactuary> interesting
14:13:44 <lseactuary> ye i remember seeing the Bool case
14:15:24 <quchen> heptahedron: That’s right.
14:16:04 <quchen> heptahedron: And pattern matching of all kinds becomes a »case« in the compiler.
14:16:10 <lseactuary> heptahedron interesting i am reading it
14:16:11 <heptahedron> quchen: thanks for confirming, wasn't sure if there was any ghc-optimization-magic that went into it making it different somehow
14:16:15 <lseactuary> before i try the questions one last one
14:16:53 <heptahedron> quchen: and these cases are subsequently transformed into continuations, right?
14:17:15 <lseactuary>  for :: Int -> (a->a) -> (a->a)    and for x fy z = iterate fy z !! x -- this works e.g. 3 (4*) 5 except when '5' is negative
14:17:22 <quchen> GHC is faily (totally?) agnostic when it comes to the »usual« data types
14:18:17 <lseactuary> is there another function i can use instead of !! as i couldnt find anything
14:18:40 <heptahedron> lseactuary: You could recur using `for`!
14:19:33 <heptahedron> lseactuary: what's the simplest case for the argument `x` for that function?
14:20:07 <lseactuary> hmm
14:20:09 <quchen> heptahedron: Not sure what you mean with continuations here. Case is evaluated by pushing a return frame onto the stack (containing the different branches – one could call this a bunch of continuations), and then evaluating the scrutinee of the case (case <scrutinee> of …)
14:20:29 <lseactuary> that is tough as we could have 3 (4+) -4
14:20:33 <heptahedron> quchen: ah, that's sort of what I meant, yeah. Cool!
14:20:41 <lseactuary> which is basically -4 + 4 + 4 + 4
14:20:42 <heptahedron> lseactuary: Nah, just for `x` alone. Don't consider the other inputs
14:21:01 <comerijn> Can I somehow disable rules when compiling?
14:21:09 <lseactuary> x is int so [-2^29 .. 2^29-1]
14:21:43 <lseactuary> wait
14:21:53 <lseactuary> applying a function - times wont make sense
14:21:58 <quchen> heptahedron: The return frame is popped once the scrutinee is evaluated to a constructor, and the appropriate branch is taken.
14:22:04 <lseactuary> so 0 is the simplest case
14:22:13 <lseactuary> i.e. dont apply the function just output z basically
14:22:20 <heptahedron> lseactuary: that's what I was trying to get you to, haha. YES excellent
14:22:24 <lseactuary> :)
14:23:12 <lseactuary> so i need to specify maybe minBound = 0 somewhere
14:23:25 <quchen> comerijn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--fenable-rewrite-rules
14:23:31 <heptahedron> lseactuary: I wouldn't--
14:24:02 <lseactuary> but say x = 0 and y is whatever say 5* then z can still be negative no?
14:24:09 <heptahedron> lseactuary: Just say `for 0 _ z = z`
14:24:58 <lseactuary> hmm
14:25:04 <heptahedron> lseactuary: I don't think this function particularly cares about what `z` is, or `fy`, so long as `fy` is a function that takes a value of `z` as an argument
14:25:06 <comerijn> quchen: I don't suppose you know whether disabling that flag in my package stops rules from another package from firing in my code?
14:25:12 <Welkin> lseactuary: london school and economics actuary?
14:25:19 <Welkin> lseactuary: london school of economics actuary?*
14:25:29 <lseactuary> Welkin - back in the day ye
14:25:37 <lseactuary> but not actuary quite :P
14:25:40 <lseactuary> studied statistics
14:25:50 <lseactuary> heptahedron ah ok
14:26:18 <quchen> comerijn: I would think that this is module-specific, like all GHC flags. But I don’t *know*.
14:26:27 <lseactuary> heptahedron many thanks for the help. will fix the other two and now be able to continue with the other questions as this makes more sense :)
14:26:44 <comerijn> quchen: :\
14:26:46 <heptahedron> lseactuary: You should be able to write this function in two lines--one for that simplest case, 0, and another for literally every other case
14:26:52 <comerijn> quchen: ugh...this is hell to debug :(
14:27:04 <lseactuary> heptahedron which function?
14:27:06 <heptahedron> lseactuary: No problem! Also for fun see if you can write that `maybeLookup` function using the `maybe` function defined in the Prelude
14:27:14 <quchen> comerijn: What did you get yourself into?
14:27:17 <heptahedron> lseactuary: the one we were just talking about, `for`
14:27:19 <nuthouse> when defining instance, should i add the type variable? ex. instance Ord (MyData a) or instance Ord MyData
14:27:20 <lseactuary> ah
14:27:32 <heptahedron> nuthouse: The former
14:27:46 <comerijn> quchen: I was refactoring some code, noticed some of it was broken. Set out to fix it, only to discover the correct code doesn't/can't work due to conduit misbehaving
14:27:47 <nuthouse> heptahedron: but I've seen the second
14:27:49 <lseactuary> using case i presume ;)
14:27:58 <nuthouse> heptahedron: that's why im confused
14:28:20 <bash0r> nuthouse: depends on if MyData :: * or MyData :: * -> * applies
14:28:31 <comerijn> quchen: i.e. with *some* (but not all) compilations of my code my persistent query ends up dropping the first result for *some* conduit sinks
14:28:58 <quchen> Eww that sounds nasty to debug indeed
14:28:59 <lseactuary> heptahedron i will try it :)
14:29:02 <heptahedron> nuthouse: Yes, you've probably seen `Ord Int` or something similar, but that's because `Int` doesn't take an argument. `Int` is of /kind/ `*`--if you're not familiar with this notion yet, "kind" is to "type" as "type" is to "value". So `Int` doesn't take any arguments
14:29:05 <comerijn> quchen: So, presumably *somewhere* in conduit a rewrite rule is fucking up with a specific inlining
14:29:10 <dgpratt> lseactuary: haven't been keeping up, but I wondered if you knew that in a definition like "for x fy z = iterate...", "x" "fy" and "z" are actually patterns?
14:29:32 <lseactuary> yeah
14:29:44 <nuthouse> heptahedron: so why instance has to take * instead of *->* ?
14:31:01 <comerijn> quchen: Because 'rawQuery "SELECT..." [] .| C.length' reports 9 lines being returned and replacing C.length with "C.mapM_ print" prints 10 lines to stdout. The sinks using C.mapM/C.mapM_ and print seem to consistently work. But C.map, C.foldl, and C.length seem to only work *sometimes*
14:31:07 <lseactuary> g2g ttyl
14:31:08 <dgpratt> lseactuary: so when heptahedron writes "for 0 _ z = z" he is handling the case when the first input is "0", no need to explicitly use the "case" keyword
14:31:09 <heptahedron> nuthouse: That's how that particular class is defined. Now, a class like `Functor` wants an argument of kind `(* -> *)`, because it /supplies/ the type arguments for functor in its definition--we have to be able to map `f a -> f b`, so that means we expect the `f` to be of kind `* -> *` since it can take a type argument
14:31:26 <lseactuary> dgpratt ah okay!
14:31:42 <lseactuary> so that is the full version also?
14:31:49 <dgpratt> you can write multiple definitions this way that get combined into one function
14:31:52 <lseactuary> what happens when x is not 0
14:32:00 <lseactuary> dont i need _
14:32:02 <heptahedron> lseactuary: You have to write out that pattern as well :)
14:32:07 <lseactuary> aha
14:32:08 <dgpratt> you write a separate definition to handle that case
14:32:12 <lseactuary> aha
14:32:25 <heptahedron> lseactuary: You only use `_` if you don't care about that input--otherwise a variable name works as a catchall as well
14:32:25 <nuthouse> heptahedron: thank you
14:32:42 <lseactuary> what is the notation for this e.g. for 0 _ z = z or for x _ y etc
14:32:45 <lseactuary> like how do i continue
14:32:55 <heptahedron> nuthouse: Does that make more sense? Do you see how it wouldn't make sense for `Ord` to accept something like `Maybe`?
14:33:09 <lseactuary> i thought for ... could only take 1 on the LHS
14:33:43 <heptahedron> lseactuary: You can write functions like `myFunc True = 3 \n myFunc False = 4`
14:33:59 <dgpratt> lseactuary: the next case you want to handle after "for 0 _ z = z" would begin on the next line "for <input_patterns> = <expression_for_this_case>"
14:33:59 <heptahedron> where \n should have the obvious meaning
14:34:13 <nuthouse> heptahedron: yes i got it
14:34:23 <heptahedron> nuthouse: Awesome!
14:34:31 <Welkin> what a nuthouse
14:34:41 <heptahedron> boo
14:34:48 <lseactuary> ah
14:34:51 <lseactuary> i remember this
14:34:53 <lseactuary> :)
14:35:04 <lseactuary> lines and unlines stuff :P
14:36:16 <heptahedron> lseactuary: how would you write the case for `for 1 fy z` such that it used the base case `for 0 fy z`?
14:37:52 <dgpratt> so the installation instructions for haskero/intero sensibly have you "installing" intero inside your stack environment -- I wonder if a similar consideration would or could apply to HIE?
14:38:00 <lseactuary> for 0 fy z = z \n for 1 fy z = iterate fy z
14:38:39 <ski> the `1' case isn't using the `0' case
14:38:55 <ski> (also, that's a type error)
14:38:57 <dgpratt> lseactuary: fyi, whenever you apply a function, the cases will be evaluated in the order you defined them
14:39:21 <lseactuary> i see
14:39:38 <ski> s/evaluated/matched/
14:39:46 <dgpratt> that
14:39:50 <heptahedron> ski is right, try to actually include a call to the base case `for 0 fy something` in your second line there
14:40:51 * ski thinks it might perhaps help if lseactuary imagined a particular example, like `for 1 (2*) 10'
14:41:26 * heptahedron points with both hands at that
14:41:43 <lseactuary> for 0 fy z = z \n for 1 fy z = iterate fy (0 fy z)
14:41:56 <heptahedron> lseactuary: you're banned from using iterate! no mas!
14:42:06 <lseactuary> ah
14:42:30 <heptahedron> lseactuary: you are stranded on a desert island with ONLY your `for` function and `(subtract 1)`
14:42:38 <ski> `iterate fy z', as well as `iterate fy (0 fy z)', can only have a list type. `for n fy z' isn't supposed to evaluate to a list
14:42:42 <heptahedron> (and the arguments to your `for` function)
14:42:54 <Rembane> :t iterate
14:42:55 <lambdabot> (a -> a) -> a -> [a]
14:42:57 <Rembane> :t fix
14:42:58 <lambdabot> (a -> a) -> a
14:43:02 <Rembane> Interesting
14:43:18 <Rembane> :t scanl
14:43:19 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:43:45 <lseactuary> 1 fy z = fy (0 fy z)
14:43:47 <lseactuary> ?
14:44:21 <heptahedron> lseactuary: can you add the function name (`for`) in the appropriate places?
14:44:33 <heptahedron> lseactuary: you're tantalizingly close
14:44:40 <ski> `0 fy z' doesn't make much sense. presumably `0' isn't supposed to be a function
14:44:50 <lseactuary> for 0 fy z = z \n for 1 fy z = fy (fy z)
14:45:15 <ski> lseactuary : what would that definition have `for 1 (2*) 10' evaluate to ?
14:45:26 <lseactuary> 20
14:45:32 <z0rx> https://www.g2a.com/r/csgo-discount-7
14:45:35 <ski> nope
14:45:54 <ski> (also, what *should* that expression evaluate to ?)
14:46:11 <lseactuary> 2* function is applied once to 10
14:46:15 <ski> > let for 0 fy z = z; for 1 fy z = fy (fy z) in for 1 (2*) 10
14:46:17 <lambdabot>  40
14:46:24 <ski> `40' is not equal to `20'
14:46:27 <heptahedron> lseactuary: to be clear ski was pointing out that the way you wrote it, your case for `for 1` evaluated `fy` twice
14:46:32 <lseactuary> ah
14:46:37 <heptahedron> he lambdabot'd before I could finish typing lol
14:46:39 <ski> > let for 0 fy z = z; for 1 fy z = fy (fy z) in for 1 (2*) 10 :: Expr
14:46:41 <lambdabot>  2 * (2 * 10)
14:47:01 <lseactuary> ah
14:47:09 <z0rx> 1 * (2 * 10) ?
14:47:16 <ski> z0rx : hehe
14:47:19 <z0rx> lol
14:47:23 <lseactuary> it should have just been fy z
14:47:26 <lseactuary> not fy (fy z)
14:47:30 <heptahedron> lambdabot: and remember, we're requiring tht you make a call to `for 0 fy something` in your case for `for 1 fy z`
14:47:57 <heptahedron> oops, I just messaged lambdabot lmao
14:48:25 * ski idly wonders whether heptahedron will have lseactuary next define the case `for 2 fy z'
14:48:34 <amalloy> someone's gotta train lambdabot to recognize freeform instructions
14:48:43 <lseactuary> ski that will be fy (fy z) right
14:49:25 <lseactuary> means the generic case is fy^(n-1) z
14:49:28 <heptahedron> lseactuary: think of it this way--if I ask you to apply a function `fy` to some value `z`, `x` times, unless `x` is 0, you're going to apply that function to `x` once, then what are you going to do
14:50:28 <lseactuary> apply fy^(x-1) times to z right
14:50:48 <heptahedron> lseactuary: yes--now, what function do you happen to have at your disposal on this desert island that lets you do that
14:50:57 * lambdabot ...
14:51:15 <heptahedron> is lambdabot being passive aggressive?
14:51:37 <lseactuary> for x fy z = fy^(x-1) z?
14:51:56 <maerwald> yes, sue him
14:52:06 <lseactuary> oh
14:52:11 <lseactuary> i need to subtract from x
14:52:27 <heptahedron> lseactuary: tell me what `for` does
14:52:51 <heptahedron> ELI22
14:52:53 <lseactuary> its the definition no?
14:52:54 <lseactuary> for 0 _ z = z \n for x fy z = fy^(x-1) z
14:53:07 <heptahedron> lseactuary: you're banned from using the `(^)` operator
14:53:11 <lseactuary> ok
14:53:16 <Bowlslaw> how do you get lambdabot to respond to commands I tried using 'eval' as shown in the "Roll your own IRC Bot" Haskell tutorial but it didn't work
14:53:39 <heptahedron> lseactuary: tell me what `for x fy z` does in a sentence
14:53:49 <monochrom> Look for how other people did it, then mimic?
14:54:03 <Bowlslaw> i suppose i could check out lambdabot's source
14:54:17 <lseactuary> applying function fy on z, x many times, where x is >= 0
14:54:47 <heptahedron> lseactuary: exactly
14:54:56 <lseactuary> oh
14:54:59 <heptahedron> lseactuary: now what was that operator you were just banned from using supposed to do
14:55:00 <lseactuary> its not ^ its *
14:55:02 <pikajude> which flag do I use to disable the "module X does not export Y" warning?
14:55:06 <ski> @type ((2*)^1) 10
14:55:07 <lambdabot> Num a => a
14:55:17 <pikajude> ghc isn't telling me for some reason
14:55:58 <pikajude> oh, dodgy-imports
14:56:00 <pikajude> nice
14:56:21 <heptahedron> lseactuary: if `x` is greater than 0, that means we have to apply `fy` to `z` at least once, but then what do we do with that
14:56:56 <Bowlslaw> can you compute definite and indefinite integrals with Haskell?
14:57:05 <lseactuary> apply it x many times
14:57:10 <Tuplanolla> Not symbolically, Bowlslaw.
14:57:11 <heptahedron> Bowlslaw: no that's against the license
14:57:16 <Bowlslaw> lol
14:57:17 <lseactuary> sorry x-1 many times
14:57:37 <heptahedron> lseactuary: okay. what function do you have, on this desert island, that lets you apply a function to some value a given number of times
14:58:04 <lseactuary> ooh
14:58:06 <lseactuary> for
14:58:11 <lseactuary> sorry i also called this for
14:58:14 <lseactuary> i think i was confused
14:58:17 <lseactuary> i should call this something else
14:58:20 <lseactuary> as for is a function
14:58:23 <heptahedron> lseactuary: No, you shouldn't
14:58:25 * ski drags themselves up from a swamp, by pulling up bootstraps
14:58:28 <heptahedron> lseactuary: It's supposed to be a function
14:58:35 <lseactuary> oh
14:58:40 <lseactuary> this is a recurison
14:58:42 <lseactuary> ?
14:58:52 <ski> yep
14:58:54 <heptahedron> If only IRC had a /ding command
14:59:31 <monochrom> You can call it something else. Call it bar.  Just make sure you also define bar=for later.
14:59:48 <ski> reducing a problem to a simpler problem belonging to the same general class of problems, eventually hitting a problem so simple that you can solve it without further reduction
15:00:14 <lseactuary>  for 0 fy z = z \n for x fy z = fy z * for x fy z
15:00:19 <lseactuary> is it right?
15:00:24 <lseactuary> or still not correcT?
15:00:29 <monochrom> Where is x-1 ?
15:00:34 <heptahedron> lseactuary: I'm not familiar with this `(*)` operator, where'd it come from
15:00:51 <heptahedron> all I know is `for`, `fy`, and subtracting 1
15:01:05 <ski> > let for 0 fy z = z; for x fy z = fy z * for x fy z in for 1 (2*) 10
15:01:12 <lambdabot>  mueval-core: Time limit exceeded
15:01:15 <ski> doesn't seem to work
15:02:12 <lseactuary> im honestly not sure
15:02:29 <heptahedron> lseactuary: Another hint--`for 0 fy z = z \n for x fy z = for _ fy _`
15:02:32 <heptahedron> fill in the blanks
15:02:39 <ski> what should the type of `foo' be ?
15:03:00 <ski> heptahedron : more than one way to skin it ..
15:03:06 <lseactuary> for 0 fy z = z \n for x fy z = for (x-1) fy z
15:03:09 <heptahedron> ski: I think this is the most illustrative
15:03:20 <heptahedron> lseactuary: 50% right
15:03:29 <ski> > let for 0 fy z = z; for x fy z = for (x-1) fy z in for 1 (2*) 10
15:03:31 <lambdabot>  10
15:03:38 <ski> is that the correct answer ?
15:04:10 <heptahedron> lseactuary: you're on the verge of an epiphany here
15:04:18 <lseactuary> i bet ;)
15:04:56 <lseactuary> im not sure
15:05:00 <lseactuary> i get it in numbers
15:05:04 <lseactuary> but without * im stuck
15:05:08 <lseactuary> oh
15:05:16 <lseactuary> fy (for....)
15:05:19 <lseactuary> no?
15:05:26 <ski> be explicit
15:05:33 <heptahedron> lseactuary: consider what was wrong with your last attempt--you didn't actually do anything to `z`, you just said "okay, apply it `(x - 1)` more times--but did you apply `fy` to `z`?
15:05:49 <lseactuary>  for 0 fy z = z \n for x fy z = for (x-1) (fy z)
15:05:50 <heptahedron> lseactuary: that way would also work!
15:05:59 <heptahedron> lseactuary: ooooh, let's see
15:06:07 <ski> lseactuary : that has a type error
15:06:10 <lseactuary> or  for 0 fy z = z \n for x fy z = fy(for (x-1) fy z)
15:06:31 <ski> > let for 0 fy z = z; for x fy z = fy(for (x-1) fy z) in for 1 (2*) 10
15:06:32 <lambdabot>  20
15:06:34 <ski> is that the correct answer ?
15:06:37 <lseactuary> ye
15:06:41 <ski> > let for 0 fy z = z; for x fy z = fy(for (x-1) fy z) in for 2 (2*) 10
15:06:41 * heptahedron curses ski's comparative typing speed
15:06:43 <lambdabot>  40
15:06:45 <ski> > let for 0 fy z = z; for x fy z = fy(for (x-1) fy z) in for 3 (2*) 10
15:06:47 <lambdabot>  80
15:06:56 <ski> how about those, are those correct ?
15:07:30 <lseactuary> yup
15:07:31 <ski> > let for 0 fy z = z; for x fy z = fy(for (x-1) fy z) in for 3 (2*) 10 :: Expr
15:07:33 <lambdabot>  2 * (2 * (2 * 10))
15:08:06 * ski waits for heptahedron to deliver some kind of coup de grace
15:08:57 <lseactuary> much better solution :)
15:09:07 <heptahedron> ski: I'm afraid they might already be over the precipice here, haha. The best I can do is see if lambdabot expressively writes tail recursion
15:09:28 <heptahedron> > let for 0 fy z = z; for x fy z = for (x - 1) fy (fy z) in for 3 (2*) 10 :: Expr
15:09:30 <lambdabot>  2 * (2 * (2 * 10))
15:09:44 <ski> well, perhaps i'll try to show something, then
15:09:45 <heptahedron> fair!
15:09:58 <lseactuary> i will finish up this set of questions now :)
15:10:03 <lseactuary> many thanks for all the help!
15:10:03 <ski> lseactuary : consider the following evaluation/reduction "trace" :
15:10:14 <ski>      for 3 (2 *) 10
15:10:27 <ski>   =  2 * for (3 - 1) (2 *) 10
15:10:35 <ski>   =  2 * for 2 (2 *) 10
15:10:46 <ski>   =  2 * (2 * for (2 - 1) (2 *) 10)
15:10:51 <ski>   =  2 * (2 * for 1 (2 *) 10)
15:11:03 <ski>   =  2 * (2 * (2 * for (1 - 1) (2 *) 10))
15:11:09 <ski>   =  2 * (2 * (2 * for 0 (2 *) 10))
15:11:13 <ski>   =  2 * (2 * (2 * 10))
15:11:18 <ski>   =  2 * (2 * 20)
15:11:25 <ski>   =  2 * 40
15:11:27 <ski>   =  80
15:11:45 <ski> lseactuary : make sure you understand why each step here happens
15:11:51 <lseactuary> yes
15:11:55 <lseactuary> i copied/pasted this just now
15:12:01 <lseactuary> will read with a fresh pair of eyes :)
15:12:21 <lseactuary> g2g for now but will be back tomorrow
15:12:22 <ski> for comparision, consider the following trace, based on heptahedron's alternative definition just above
15:12:25 <lseactuary> many thanks!!
15:12:28 <ski>      for 3 (2 *) 10
15:12:32 <heptahedron> ski: they're trying to escape! quickly!
15:12:36 <ski>   =  for 3 (2 *) (2 * 10)
15:12:51 <ski> er, i'm sorry, that should be
15:12:58 <ski>   =  for (3 - 1) (2 *) (2 * 10)
15:13:08 * ski blames heptahedron stressing them ;)
15:13:22 <ski>   =  for 2 (2 *) (2 * 10)
15:13:28 <ski>   =  for 2 (2 *) 20
15:13:38 <ski>   =  for (2 - 1) (2 *) (2 * 20)
15:13:42 <ski>   =  for 1 (2 *) (2 * 20)
15:13:46 <ski>   =  for 1 (2 *) 40
15:13:56 <ski>   =  for (1 - 1) (2 *) (2 * 40)
15:14:03 <ski>   =  for 0 (2 *) (2 * 40)
15:14:07 <ski>   =  for 0 (2 *) 80
15:14:11 <ski>   =  80
15:14:26 <lseactuary> how did you make these out of interest?
15:14:41 <ski> note that here, the top function is `foo' all the time, until we reach the base case
15:15:11 <heptahedron> s/foo/for
15:15:19 <Welkin> o.o
15:15:22 <lseactuary> interesting
15:15:30 <Welkin> what happened to using a paste site?
15:15:33 <ski> (yea, sorry, i suppose i type "foo" more often than "for" :)
15:15:50 <lseactuary> ok g2g bk tomorrow - many thanks again and sorry for being slow :/
15:15:54 <monochrom> far, bar, qar
15:15:57 <lseactuary> cu
15:16:02 <heptahedron> farewell
15:16:39 <heptahedron> I used to use IRC for programming help all the time when I was like 12, it's great to be able to come back now that I'm older and help other people
15:16:56 <kadoban> heptahedron: Nice
15:20:01 <Welkin> heptahedron: I wish I did that
15:20:17 <Welkin> I only used irc for downloading comics and making jokes
15:20:31 <Welkin> I did learn basic programming to make irc bots though
15:20:38 <Welkin> to run games and scripts in the channel
15:20:52 <heptahedron> Welkin: At the time, I thought IRC was basically entirely used by programmers lol
15:20:55 <Welkin> I wasn't on freenode back then, though
15:21:11 <Welkin> heptahedron: take a look at OFTC as well
15:21:13 <Welkin> it's like freenode
15:21:16 * heptahedron wonders about the distribution of users among channels of different topics on freenode
15:21:19 <Welkin> it has a lot of programming channels
15:23:08 <dciug> suppose i have a custom datatype: data S = A | B | C deriving (Enum) Why does [A..C] give an error but not [A .. C]? But [1..10] doesn't care
15:23:23 <parsnip> try enumFromTo
15:24:05 <comerijn> dciug: Because A.foo would be a qualified import of foo from A
15:24:15 <comerijn> dciug: So "A..B" is ambiguous
15:24:22 <comerijn> dciug: Therefore not allowed
15:24:39 <pikajude> even though a "doubly qualified" name isn't something that exists
15:25:11 <parsnip> til
15:25:13 <comerijn> pikajude: A.. is a legal name for an operator
15:25:28 <pikajude> it really is, isn't it
15:25:30 <pikajude> i completely forgot
15:25:38 <Bowlslaw> so a Monad is an actual type...cool
15:25:45 <Bowlslaw> i thought it was a design pattern
15:25:45 <monochrom> > (id Prelude.. id) 5
15:25:46 <pikajude> it's a type constructor
15:25:47 <lambdabot>  5
15:25:49 <comerijn> :t (Prelude..)
15:25:50 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:26:08 <pikajude> we need an Enum instance for functions
15:26:15 <monochrom> What?
15:26:16 <pikajude> :t [Prelude.. .. .]
15:26:17 <lambdabot> error: parse error on input ‘..’
15:26:20 <pikajude> oh no
15:26:37 <heptahedron> I have to echo monochrom's sentiment on that one
15:28:44 <heptahedron> I guess /theoretically/ it makes sense, but at what cost
15:29:24 <monochrom> Theoretically every set is well-ordered, too.  Doesn't mean useful.
15:29:29 <Bowlslaw> lol
15:29:50 <heptahedron> monochrom: that's AoC-based, right
15:29:55 <monochrom> Yes.
15:30:11 <heptahedron> monochrom: sweet, that philosophy of mathematics class didn't entirely go over my head
15:32:33 <Welkin> AoC?
15:32:35 <Welkin> Age of Condors?
15:32:36 <lavalike> I popped in and I thought oh cool, what is based on Advent of Code, then read the context.
15:32:45 <lavalike> Axiom of Choice!
15:32:59 <Welkin> this is why we can't have acronyms
15:33:20 <Welkin> the "enterprise" world is littered with them
15:33:47 <monochrom> Oh, theoretically, Advent of Code implies that every computable set is well-ordered, too. :)
15:33:57 <lavalike> (:
15:34:06 <heptahedron> Welkin: it's the new trend for AaaS, please keep up
15:34:26 <monochrom> How to do it: If you have a computable set you want well-ordered, just assign it as an Advent of Code problem.
15:34:33 <Bowlslaw> lol
15:34:41 <heptahedron> that's acronyms-as-a-service, but only on weekends
15:34:57 <comerijn> quchen: Looks like I solved my problem. Someone apparently decided "hey, let's add a function that's fundamentally impossible to use safely to the persistent API!"
15:34:59 <Welkin> heptahedron: not a long "a" in ass?
15:35:13 <lavalike> Proof by Mechanical Turk
15:35:27 <quchen> comerijn: Oops – bug report?
15:35:37 <comerijn> quchen: I'm still not sure *why* it's impossible to use safely, but dropping it with one of it's safer variations seems to work without issue
15:35:57 <Welkin> * New employee comes into the office and overhears their colleagues: "Check out this new AaaS! What a sweet AaaS!"
15:36:24 <Bowlslaw> lol
15:36:44 <parsnip> hmm, this person did not list all problems under `other-modules:`, i guess they will get warnings? https://github.com/guillaume-nargeot/project-euler-haskell/blob/master/project-euler.cabal
15:36:45 <Bowlslaw> this AaaS is blowing my mind
15:37:28 <parsnip> then they have long list of imports in Main.hs, overall is this approach reasonable? i'm loosely following this layout.
15:55:01 <parsnip> wonder how badly this might come to bite me, ghc-options:         -Wno-missing-home-modules
16:11:19 <dgpratt> oof; every time I think "today is the day I will set up the ideal  nix-based Haskell dev environment!", I get worn down by all the googling, the choose-your-own-adventure instructions, the arcane commands, the inscrutable configuration files, the interminably long build/install steps, the out of memory errors...
16:11:42 <heptahedron> Would I be wrong to assume that typeclass instances written with explicit types would generally perform better/be inlined more easily by GHC than those that used singleton values from polymorphic types
16:12:01 <Rembane> dgpratt: What about setting up a slightly less crappy one every time instead?
16:12:15 <Rembane> heptahedron: Yes. :)
16:12:25 <Rembane> heptahedron: They are the same afaik
16:13:07 <Welkin> dgpratt: just use reflex-platform https://github.com/reflex-frp/reflex-platform
16:13:21 <lyxia> polymorphic recursion with singletons won't inline.
16:13:43 <dgpratt> oh, I meant to check that out, thanks for the reminder Welkin
16:14:17 <heptahedron> lyxia: hm. So if I don't make a recursive call to any of the class methods then they'll be the same, effectively?
16:14:37 <heptahedron> it's literally only 4 different instances I'd have to write out but I Just Don't Wanna
16:20:11 <lyxia> heptahedron: I guess so
16:31:14 <heptahedron> What's the best way to go about testing the lenses I've made for this project using microlens without actually including microlens as a dependency (with stack)?
16:31:24 <heptahedron> I just want to toy with them in ghci
16:31:28 <Welkin> wear them and go outside
16:31:43 <heptahedron> Welkin: done, now what
16:31:59 <MarcelineVQ> stack ghci --package microlens
16:32:10 <heptahedron> MarcelineVQ: thanks!!
16:32:40 <d34df00d> Hi!
16:33:11 <d34df00d> Are there any clang bindings except libclang (which seems to be unmaintained) and clang-pure (whose purity is achieved by unsafePerformIO all over the place)?
16:35:25 <MarcelineVQ> dunno much about that but there's llvm bindings if you can't find anything for clang in specific
16:36:29 <Bowlslaw> that feel when the second exercise takes you 4 hours of research but all the others are easy cheese
16:37:51 <Bowlslaw> huh, so hlint actually does provide me useful things
16:38:12 <d34df00d> MarcelineVQ: ah, sadly I'd like to just parse some C++ and provide some code insights for it.
16:38:13 <Welkin> never used it
16:38:22 <d34df00d> llvm would rather be useful if I wanted to generate some code.
16:38:40 <Bowlslaw> sumDigits xs = foldr (+) 0 xs
16:39:39 <Welkin> that is just `sum`
16:40:53 <Welkin> bajrjr: can you guess the definition for `product`?
16:41:13 <Welkin> er
16:41:20 <Welkin> Bowlslaw ^
16:41:53 <parsnip> > foldr (*) 0 [1..]
16:42:00 <lambdabot>  mueval-core: Time limit exceeded
16:42:00 <lambdabot>  mueval: ExitFailure 1
16:42:17 <Welkin> o.o
16:42:21 <Welkin> bad parsnip
16:42:22 <Bowlslaw> Welkin: yes i see LOL
16:42:24 <Welkin> that is wrong too
16:43:47 <Welkin> although I believe sum and product use foldl instead
16:43:56 <Welkin> the strict version
16:44:05 <Welkin> or was that never fixed?
16:44:09 <Welkin> maybe it gets optimized anyway
16:44:37 <Welkin> > product [1..10000]
16:44:39 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
16:44:43 <Welkin> > product [1..10000000]
16:44:50 <lambdabot>  mueval-core: Time limit exceeded
16:44:50 <lambdabot>  mueval: ExitFailure 1
16:44:58 <Welkin> > foldl' (*) 1 [1..10000000]
16:45:04 <lambdabot>  mueval-core: Time limit exceeded
16:45:06 <Welkin> > foldl' (*) 1 [1..1000000]
16:45:12 <lambdabot>  mueval-core: Time limit exceeded
16:45:14 <Bowlslaw> ur exploding da memoryyy
16:45:17 <Welkin> > foldl' (*) 1 [1..100000]
16:45:21 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
16:45:29 <Welkin> > product [1..100000]
16:45:35 <lambdabot>  mueval-core: Time limit exceeded
16:45:38 <Welkin> see?
16:45:46 <Bowlslaw> woah
16:46:11 <Bowlslaw> whooaooo
16:46:22 <Welkin> > foldl (*) 1 [1..100000]
16:46:28 <lambdabot>  mueval-core: Time limit exceeded
16:46:29 <Welkin> > foldl' (*) 1 [1..100000]
16:46:36 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
16:46:49 <Bowlslaw> ??????????
16:46:54 <Welkin> foldl is lazy
16:46:57 <Welkin> foldl' is strict
16:47:01 <Bowlslaw> wtf
16:47:04 <Bowlslaw> there is a differene?
16:47:07 <Welkin> you can learn more about this in Parallel and Concurrent Haskell
16:47:19 <Welkin> I don't recommend that until you finish learning the basics though
16:47:19 <Bowlslaw> i mean foldl and foldl'
16:47:22 <Welkin> it is very cool
16:47:23 <MarcelineVQ> Welkin: you can but oriely put it behind a paywall
16:47:28 <Welkin> MarcelineVQ: wtf?
16:47:30 <Welkin> when?
16:47:33 <Bowlslaw> Welkin: yes that book is on my list
16:47:37 <Welkin> are you serious?
16:47:48 <Bowlslaw> I just found a freely offered pdf
16:47:50 <Welkin> oh fuck off
16:47:55 <Welkin> fucking o'reilly
16:48:02 <Welkin> has anyone contacted simon marlow?
16:48:11 <Welkin> I thought he had as part of his publishing deal that it is free online!!
16:48:28 <Welkin> jesus
16:48:33 <Welkin> this is fucked up
16:48:39 <Welkin> now we lost one of the best haskell resources
16:49:30 <MarcelineVQ> It is pretty important. If you feel that strongly you could contact simon, he's a friendly guy :>
16:49:33 <Bowlslaw> all you have to do is search for the title pdf and there you go
16:49:37 <geekosaur> Welkin, ORA screwed *everyone* over
16:50:09 <Welkin> eat shit o'reilly
16:50:10 <Welkin> https://web.archive.org/web/20170115081935/http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
16:50:13 <Welkin> mother fuckers
16:50:22 <Welkin> web archive ++100000
16:51:24 <Welkin> I think that the fish book is the most important haskell learning resource after a basic intro
16:51:40 <Bowlslaw> o rly
16:53:48 <Welkin> I may buy the humble bundle after all, and give o'reilly ZERO cents
16:53:58 <Welkin> I'll give it all to the charity and humble bundle
16:54:12 <Welkin> at least then I will have a pdf and epub of the fish book I can easily send to people
16:55:20 <Bowlslaw> it's in humble?
16:55:29 <kadoban> Ya, one of the higher tiers
16:55:33 <Welkin> yes
16:55:40 <Welkin> that book bundle we were talking about eralier
16:55:42 <Welkin> earlier*
16:55:45 <Bowlslaw> hmph
16:56:02 <u-ou> didn’t know about the fp humble bundle!
16:56:03 <u-ou> thanks
16:56:06 <Welkin> if you end up buying, don't give o'reilly a god damn penny
16:56:19 <Welkin> you can adjust where your money goes
16:56:58 <u-ou> eh, doesn’t look that good
16:57:02 <u-ou> a lot of clojure and scala
16:57:11 <Welkin> yes
16:57:11 <kadoban> I dunno, I mean a whole bunch of books aren't actually made free online. Them going from free online annoys me, but I can't tell if it should.
16:57:13 <Welkin> it is crap
16:57:19 <Welkin> the onluy good book is the haskell fish book
16:57:26 <u-ou> and maybe the rust one
16:57:44 <Welkin> kadoban: the book I am writing for haskell newcomers is completely free and will always be
16:58:35 <kadoban> Welkin: That is cool of you. But not everybody can do that, or would want to.
17:41:20 <Bowlslaw> are there times where it's better to use (x:xs) over tail and head?
17:42:48 <sm> Bowlslaw: sometimes it's more convenient. But all of these are partial (can fail with an empty list)
17:46:00 <Bowlslaw> sm: isn't that a matter of ensuring your base case?
17:46:47 <kadoban> Bowlslaw: I would say it's usually better to use pattern matching (x:xs)
17:48:03 <Bowlslaw> pattern matching in Haskell seems practically ubiquitous
17:50:30 <m> Bowlslaw, most of the times
17:50:38 <ahihi> that's one of the reasons haskell is so nice
17:50:40 <ahihi> :3
17:51:00 <m> No instance Num [a]
17:51:05 <Bowlslaw> LOL
17:55:40 <numberten> is there a function for Either a a -> (a -> b) -> Either b b
17:56:03 <numberten> for when you're using Either a a as an alternative to (a, Boolean) ?
17:56:43 <m> :t join either
17:56:44 <lambdabot> (b -> c) -> Either b b -> c
17:56:47 <Bowlslaw> alright I've nailed down how i'm gonna learn Haskell: do cis194 while also reading Programming in Haskell(which I just purchased because holy moly the sample is good), and then go on to parallel and concurrent programming in haskell
17:56:54 <m> hrmm not exactly
17:57:03 <m> :t join bimap
17:57:04 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
17:57:09 <m> numberten, ^
17:57:37 <pavolzetor> hello, I am bit confused what are the advantages of using monad transformers vs creating a custom monad instance that merges them
17:57:57 <m> pavolzetor, you get instances for free
17:58:03 <m> and functions for free
17:58:22 <pavolzetor> I was more thinking that it is better because it documents the intent
17:58:58 <pavolzetor> How would you though decide? When is your stack n levels deep? what n?
17:58:59 <m> these days it's fairly hard to write a type whose monad instance wouldn't be apparent
17:59:22 <m> wait
17:59:38 <m> maybe I'm not understanding the question correctly?
17:59:57 <pavolzetor> Basically, I want to merge either, state, irbuilder
18:00:49 <pavolzetor> People here pointed me to monad transformers so I got the haskell book, and read online too; but I still do not know what is good taste
18:01:39 <pavolzetor> So my question is, what is the clear way to solve the problem
18:02:03 <pavolzetor> currently I can think of 2, have my own monad instance, or build stack of already present monads
18:04:21 <numberten> m: sweet thanks
18:05:16 <Bowlslaw> pavolzetor: which Haskell book? the first principles one?
18:06:05 <pavolzetor> Yes, also real world haskell and wikibook
18:06:24 <dmwit> m: You can lift all the `Num` operations to any `Applicative`, and `[]` is an `Applicative`, so there's a somewhat sensible `Num [a]` instance.
18:07:00 <dmwit> pavolzetor: I think if you can get all the features you want out of a monad transformer stack, that's preferable to rolling it yourself. There are fewer places to insert bugs that way.
18:07:37 <m> dmwit, that was a pun
18:07:40 <m> on :3
18:07:56 <dmwit> ...ah. =D
18:10:45 <pavolzetor> thanks, I will try it that way and see; last thing, do you abstract lift x into separate functions? How do you decide on the order of the things in the stack? Currently I am going with State inside Either
18:11:20 <m> most of the time it doesn't matter
18:11:39 <dmwit> With `State` and `Either` in particular it matters.
18:11:46 <m> indeed
18:11:50 <dmwit> You pick the one that does the thing you want, which depends a lot on context.
18:11:59 <dmwit> ?unmtl StateT s (Either e) a
18:11:59 <lambdabot> s -> Either e (a, s)
18:12:10 <dmwit> ?unmtl ErrorT e (State s) a
18:12:10 <lambdabot> s -> (Either e a, s)
18:13:06 <dmwit> I'm not sure I understand the "do you abstract lift x into separate functions?" question.
18:13:26 <dmwit> But I suspect the answer is "no, I use the typeclass-polymorphic functions and leave them polymorphic".
18:13:41 <m> StateT ReaderT WriterT all commute though
18:14:05 <Bowlslaw> how come foldr/foldl are not used in imperative languages?
18:14:12 <dmwit> e.g. don't write `foo :: MyMonadTransformerStack Int`, write `foo :: (MonadState Blargle m, MonadReader Configuration m) => m Int`.
18:14:25 <dmwit> Bowlslaw: They are.
18:14:32 <dmwit> Bowlslaw: e.g. reduce in Python is foldl'
18:14:32 <m> Bowlslaw, you mean the left/right distinction?
18:14:50 <Bowlslaw> er, yes more specfically that is what i was thinking of
18:15:06 <Bowlslaw> i had never seen those before i started learning about FP
18:15:15 <Bowlslaw> I come from the C and systems programming world
18:15:44 <dmwit> Oh. foldr isn't really useful in strict languages (for essentially the same reason foldl isn't useful in Haskell), so most imperative languages (which are by coincidence also strict) offer only foldl' if they offer any fold at all.
18:15:45 <pavolzetor> dmwit, I meant to avoid doing lift put
18:16:00 <dmwit> pavolzetor: Right. Instead of `lift put`, just use `put`.
18:16:22 <dmwit> pavolzetor: That's kind of the whole point of the `MonadState` class, is to let you not have to `lift put`.
18:16:55 <pavolzetor> even if the state is lower down the stack?
18:17:00 <Bowlslaw> dmwit: interesting
18:17:03 <dmwit> pavolzetor: yes
18:17:06 <pavolzetor> how does it passes through the toplevel monad?
18:17:27 <dmwit> The `MonadState` instance for the upper levels of the stack tell it how.
18:17:27 <pavolzetor> my guess is somebody wrote all those instances
18:17:32 <dmwit> yes
18:18:03 <pavolzetor> I see, that seems quite tedious, isn't it n^2 to code up?
18:18:28 <dmwit> > let foo :: ReaderT Int (State Bool) (); foo = put True in runState (runReaderT foo 3) False
18:18:29 <lambdabot>  ((),True)
18:18:37 <dmwit> ^ for example
18:19:02 <dmwit> Yes, if you have n kinds of effects, there are n^2 liftings.
18:19:39 <dmwit> Luckily, in most situations, you can get away with *just* reusing the existing monad transformers, so somebody else has already done the n^2 part for you.
18:20:18 <pavolzetor> I think that answers my initial question :)
18:20:55 <dmwit> Also luckily: most of the n^2 code is quite mindless indeed. `instance MonadState s m => MonadState s (ReaderT r m) where get = lift get; put = lift . put; modify = lift . modify`
18:21:10 <Eduard_Munteanu> If you're writing FooT, you need to write 'n' instances for the most common monads.
18:21:53 <dmwit> Most of the other n^2 instances look similar: just `lift` and "recurse".
18:24:57 <pavolzetor> I think I will have to implement my own monad transformers to understand them fully, especially  if I nest them, does it go through the code and evaluates all outer code and then evaluete inner code?
18:25:27 <pavolzetor> when you had that example of Reader (State)
18:26:12 <pavolzetor> first it run the reader, but how does it work? does it just set up thunks?
18:26:54 <Eduard_Munteanu> Most code doesn't (shouldn't) really care about the order of transformers.
18:26:58 <dmwit> ?src ReaderT
18:26:58 <lambdabot> Source not found. Sorry.
18:27:27 <dmwit> pavolzetor: Well. I think you have the right idea: implement it yourself, or read the implementation.
18:27:44 <Eduard_Munteanu> data ReaderT r m a = ReaderT { runReaderT :: r -> m a }
18:28:24 <Eduard_Munteanu> So... runReaderT :: ReaderT r m a -> r -> m a
18:29:21 <ElectroStatik> Glad to see Haskell is getting so popular
18:29:22 <dmwit> Eduard_Munteanu: (As mentioned early in the discussion: StateT is a case where it's especially common for transformer order to matter, though, and pavolzetor has said he wants to mix State and Either.)
18:29:38 <m> ElectroStatik, avoid success at all costs
18:29:46 <pavolzetor> dmwit: will do, it seems quite interesting
18:29:56 <ElectroStatik> I know five programming languages. Already did
18:30:00 <ElectroStatik> haha
18:30:10 <dmwit> pavolzetor: By the way, I liked All About Monads for a tour through the common monad transformers.
18:30:12 <dmwit> ?where aam
18:30:12 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
18:30:53 <ElectroStatik> So a monad is a stack of heterogeneous functions mapped over a collection?
18:31:04 <m> ElectroStatik, five that's rookie numbers
18:31:20 <Eduard_Munteanu> Yeah, though a lot of code is written using constraints instead of actual transformers, so it's order-agnostic everywhere except the runner function. That seems fairly common.
18:31:40 <m> ElectroStatik, what
18:32:20 <pavolzetor> thanks
18:32:26 <ElectroStatik> I can read any programming language generally. I just picked five to avoid the cognitive overload
18:32:53 <ElectroStatik> What scripting languages do you guys like for hacking? I'm using zshell now in a kali distro
18:33:02 <pavolzetor> C
18:33:18 <ElectroStatik> cshell. Worth it right?
18:33:33 * Eduard_Munteanu facepalms
18:33:36 <m> ElectroStatik, admire this brainfuck program then http://tcpst.net/d_bf.txt
18:34:14 <ElectroStatik> Dang. What language is that?
18:34:18 <m> brainfuck
18:34:27 <ElectroStatik> ah okay that explains it
18:34:29 <ElectroStatik> lol
18:34:49 <gem> Hey!
18:35:02 <m> I generated it with some pretty cool monadic haskell code
18:35:22 <Eduard_Munteanu> gem, hi
18:39:30 <ElectroStatik> Good night fellas. Good luck with your dreams. SPT is a brave soul
18:39:38 <ElectroStatik> *SPJ
18:48:29 <Bowlslaw> I feel like I'm doing something wrong if I use an if/then/else in Haskell lol
18:48:51 <m> that's a good feeling
18:48:56 <m> boolean blindness is a thing
18:49:28 <ski> @where boolean-blindness
18:49:28 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
18:53:47 <Bowlslaw> interesting
18:58:59 <parsnip> @src bool
18:58:59 <lambdabot> bool f _ False = f
18:58:59 <lambdabot> bool _ t True  = t
19:00:08 <Bowlslaw> cool!
19:00:16 <Bowlslaw> i did it with guards
19:00:38 <Bowlslaw> just finished the homework for cis194
19:05:28 <Bowlslaw> ahh how satisfying
19:08:33 <Bowlslaw> reverse func, or reverse . func
19:08:39 <Bowlslaw> what is the difference?
19:09:06 <ski> a dot
19:09:31 <Bowlslaw> why does the composition operator exist then?
19:09:48 <ski> to compose functions ?
19:09:59 <parsnip> Bowlslaw: it was a joke response
19:10:00 * ski isn't sure what Bowlslaw is after
19:10:10 <Bowlslaw> yeah i know
19:10:16 <dmwit> :t \func -> reverse func
19:10:17 <lambdabot> [a] -> [a]
19:10:20 <dmwit> :t \func -> reverse . func
19:10:21 <lambdabot> (a1 -> [a2]) -> a1 -> [a2]
19:10:23 <parsnip> these inside jokes, so many layers
19:10:31 <dmwit> func has completely different types in the two expressions
19:10:35 <Bowlslaw> hmm
19:10:43 <dmwit> (and is indeed not a function in one of them, so very badly named)
19:10:57 <Bowlslaw> O_o
19:16:10 <mniip> 1518923322 [06:08:42] <ski> a dot
19:16:13 <mniip> that's the point
19:23:06 <Bowlslaw> :t f x
19:23:07 <lambdabot> FromExpr t => t
19:23:13 <Bowlslaw> :t \f x
19:23:14 <lambdabot> error:
19:23:14 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:23:25 <metahumor> :t \f x -> f x
19:23:27 <lambdabot> (t1 -> t2) -> t1 -> t2
19:23:43 <Bowlslaw> :t \f x -> f x
19:23:44 <lambdabot> (t1 -> t2) -> t1 -> t2
19:23:45 <metahumor> Bowlslaw: a lambda has to be well formed -- it needs the arrow and a RHS
19:24:02 <Bowlslaw> :t \f x y -> f x * f y
19:24:03 <lambdabot> Num a => (t -> a) -> t -> t -> a
19:24:07 <Bowlslaw> kewl
19:24:37 <Bowlslaw> :t \f g x -> f(g(x))
19:24:38 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
19:24:53 <Bowlslaw> :t \f g x -> f . g x
19:24:54 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
19:25:36 <metahumor> do you mean "\f g x -> (f . g) x?
19:27:03 <Bowlslaw> ooooy
19:27:08 <Bowlslaw> yes
19:27:35 <Bowlslaw> :t \f g x -> (f . g) x
19:27:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:27:54 <Bowlslaw> hmm
19:28:11 <Bowlslaw> how come it's t1, t2 etc in the first one and a,b etc in the second?
19:28:33 <dmwit> implementation detail
19:28:37 <dmwit> Type variable names don't matter.
19:28:42 <dmwit> (To a first approximation.)
19:28:54 <olligobber> Bowlslaw, you know you can direct message the bot or just use ghci for that, right?
19:28:59 <mniip> what matters is only when they are the same vs when they are not
19:29:02 <dmwit> BUT to be nice to programmers, GHC tries to preserve type variable names given in type signatures by the programmer if it can.
19:29:11 <dmwit> And (.) happens to have a type signature with `a`s, `b`s, and `c`s.
19:29:12 <Bowlslaw> olligobber: yes but I'm trying to get some feedback
19:29:28 <Bowlslaw> dmwit: cool
19:29:44 <olligobber> :t (.)
19:29:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:30:29 <mniip> @let data Pineapple (pizza :: *) = Foo
19:30:30 <lambdabot>  Defined.
19:30:32 <mniip> :t Foo
19:30:33 <lambdabot> Pineapple pizza
19:30:38 <Parziva1> Hello there!
19:30:54 <Bowlslaw> LOL
19:31:00 <metahumor> hi Parziva1
19:31:28 <Parziva1> how do you do?
19:32:15 <Parziva1> why is my name gray?
19:32:26 <Parziva1> **grey
19:32:55 <dmwit> It is not universal. IRC doesn't specify nick coloring, that's up to clients.
19:33:26 <Parziva1> yeah, why is it grey here? everyone else looks blue?
19:33:50 <Parziva1> why is mine different then yours?
19:34:47 <ski> Parziva1 : you can probably configure the nick colors in X-Chat differently
19:34:48 <dmwit> Completely unanswerable with the information given.
19:35:06 <dmwit> You'd have to ask the folks who wrote your client.
19:35:19 <dmwit> (Or know how it works, anyway. They don't *have* to be authors. ;-)
19:35:21 <mniip> xchat should use red by default I think?
19:35:24 <metahumor> Parziva1: in the client you are using, it might be that you (as in, you since you are the one logged in) are displayed separately
19:35:39 <Parziva1> ah, that could make sense. thanks
19:41:32 <addem[m]> Is this thing working?
19:41:47 <metahumor> it workd
19:41:50 <Parziva1> as far as I can tell
19:42:50 <addem[m]> Cool, hadn't seen any messages on any of the rooms I'd joined.  Hi!
19:43:25 <Parziva1> hello, how do you do?
19:44:03 <addem[m]> Pretty good, trying to put together a little mini lesson plan on Abstract Algebra.  You?
19:44:32 <Parziva1> messing about. watching some youtube.
19:50:27 <Parziva1> what is this chat room about btw?
19:51:18 <addem[m]> Looks like the programming language Haskell.
19:51:20 <metahumor> about haskell the language
19:51:21 <ski> the programming language Haskell, and related topics
19:51:26 <addem[m]> Although this is my first time here and I'm still kind of playing around with Matrix.
19:52:22 <ski> (also, it's traditionally called a "channel", on IRC, not a "chat room")
19:52:42 <Parziva1> ok, sorry
19:52:48 <ski> no worry
19:52:56 <parsnip> then why does it make a creaking door closing noise when people part?
19:53:12 <addem[m]> Ah, I accessed this through Matrix rather than IRC and there they call it a room.
19:53:26 <ski> i see
19:57:09 <ab9rf> this is information i did not particularly need :)
19:58:14 <Parziva1> I know nothing about hackell
19:58:29 <ski> would you like to learn ?
19:58:36 <addem[m]> It's a functional programming language.
19:58:51 <Parziva1> what is its strong points? what makes it useful?
19:59:09 <addem[m]> It seems to be designed with a strong intention to be interesting for mathematicians.
19:59:24 <ab9rf> well, more that it was designed by mathematicians :)
19:59:28 <Bowlslaw> it was designed by them lol
19:59:29 <addem[m]> It theoretically mirrors the lambda calculus, which is a conceptual model for computation.
19:59:42 <addem[m]> And it behaves a lot like actual mathematical functions do.  No side effects, just input and output.
19:59:58 <Parziva1> cool.
20:00:08 <Parziva1> may look at the website.
20:00:10 <addem[m]> Ah yeah, that would explain it. :)
20:00:15 <ski> it has a strong, expressive, static type system that catches many bugs. absence of side-effects (such as assignment) also help with correctness
20:00:38 <Bowlslaw> i don't understand monads, nor how IO doesn't break purity
20:00:46 <Bowlslaw> then again I haven't really read much about monads
20:00:50 <Parziva1> so it is kind of like wolfram?
20:00:51 <Bowlslaw> so much to learn euughhh
20:00:54 <addem[m]> There is also a fairly entertaining book (as entertaining as CompSci books get) called Learn You a Haskell.
20:01:16 <ab9rf> Bowlslaw: have a burrito. everything is easier with a burrito.
20:01:32 <addem[m]> A lot less user-friendly than Wolfram.
20:01:45 <addem[m]> I can't recall what monads are.
20:01:46 <ski> it has non-strict evaluation, meaning that it will only evaluate things when they are actually demanded. this e.g. means that lists (or trees, for that matter) can be infinite. only as much as you actually look at will be evaluated
20:01:47 <ab9rf> but less narcissistically named
20:01:50 <addem[m]> I just had a very nummy burrito, as I recently moved into the barrio.
20:01:56 <addem[m]> There is very loud Mexican music blaring at 11pm.  It'll probably die down around 4am.
20:02:00 <parsnip> Bowlslaw: monad is just a fancy typeclass
20:02:06 <parsnip> Bowlslaw: learn typeclass first
20:02:25 <Bowlslaw> ok
20:02:38 <addem[m]> Is non-strict the same as lazy?
20:02:48 <ab9rf> addem[m]: not exactly
20:03:00 <Bowlslaw> i thought non-strict was the technical term for lazy
20:03:19 <ski> monad is a name for a particular interface (cf. priority queue, or finite map), or a particular design pattern, if you will
20:03:20 <ab9rf> https://wiki.haskell.org/Lazy_vs._non-strict
20:03:32 <ski> lazy is a particular implementation of non-strict
20:03:50 <Bowlslaw> ab9rf: why do you mention burritos
20:04:03 <parsnip> it's a joke about, "monads are burritos"
20:04:11 <addem[m]> INNERESTIN
20:04:19 <ski> non-strict talks about *what* answers you get (or don't get). laziness tells you how and when they're computed (and what isn't recomputed)
20:04:20 <parsnip> which makes fun of all the ways people try to explain monads
20:04:26 <Bowlslaw> hahahaa
20:04:40 <ski> @where burrito
20:04:40 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
20:04:42 <ab9rf> Bowlslaw: somebody once tried to explain monads using a burrito metaphor. it's not a very good metaphor, and it's become something of a joke
20:04:58 <ab9rf> it was likely a joke in the first place
20:05:05 <metahumor> Bowlslaw: one approach to thinking about some types that are instances of Monad is that they "wrap" values. this is useful for some types, not all types that are instance of Monad
20:05:16 <ski> ab9rf : rather explaining them using burritos was already a mockery of other analogies
20:05:31 <ab9rf> people often cast about wildly for metaphors to explain burritos, er, i mean monads, and rarely do a good job of it
20:05:31 <parsnip> but functor and applicative "wrap" too
20:05:44 <metahumor> kinda like how Big Bang was originally a sharply critical / insulting term
20:05:46 <parsnip> that's just being a typeclass for types of unary kind.
20:05:55 <Bowlslaw> hm, interesting. i'll get to them soon enough. i'm going through cis194 while reading Hutton's programming in Haskell
20:06:14 <Bowlslaw> which I quite enjoy due to its brevity, reminds me of K&R C
20:06:22 * ski wraps cakes in recipes
20:06:34 * ab9rf wraps cake in MORE CAKE!
20:06:46 <ab9rf> maybe this is why i'm gaining weight
20:06:53 * parsnip joins cake and eats it!
20:06:56 * ski joins ab9rf's face to the cake
20:07:15 * parsnip spits out an error
20:07:27 <metahumor> "a monad in X is just a burrito in the category of sandwiches, with cold cuts replaced by beans and rice and bread replaced by tortillas"
20:07:38 <ab9rf> i think people spend too much trying to find something that "monads are like" instead of just using them
20:07:51 <u-ou> how are arrows defined in a burrito
20:08:01 <metahumor> ab9rf: did you see the ridiculous "monads are pipes" twitter thing yesterday??
20:08:10 <addem[m]> Possibly not an appropriate question for the group but here goes: I'm making a demo about group theory using Python's SymPy module.  It's very fairly basic stuff about normal subgroups and the first isomorphism theorem--any suggestions about what to include in the demo?  So far I'm using S5 and its subgroups.
20:08:26 * ski idly wonders how many denizens of the channel has read the gentle tutorial
20:08:30 <ab9rf> metahumor: no, my twitter doesn't usually get much haskell-related content on it
20:09:10 <ab9rf> metahumor: my twitter is 90% politics and has been in "insane mode" since november 2016
20:09:27 <ab9rf> i rarely ever see anything tech related anymore
20:09:37 <Bowlslaw> oh joy a bunch of irrational fools who have no idea what they're talking about....sounds fun
20:10:04 <ab9rf> there's an article from 2001 about "unix pipes sa io monads" on the Google machine though
20:12:02 <ski> "Burritos for the Hungry Mathematician" by Ed Morehouse in 2015-04-01 at <http://emorehouse.web.wesleyan.edu/silliness/burrito_monads.pdf>
20:12:02 <addem[m]> Recently tried looking for a good online politics room but found only people trying to act like asses.
20:12:13 <ski> "Mustard Watches" by Yann-Joachim Ringard in 1990-10 at <http://girard.perso.math.cnrs.fr/mustard/article.html>
20:12:46 <addem[m]> LOL
20:13:35 <Parziva1> this seems like a cool channel.
20:14:26 <ab9rf> wow
20:14:47 <ab9rf> reading the twitter "discussion" on monadic pipery
20:14:57 <ab9rf> lots of verbiage, nothing actually said
20:15:20 <MarcelineVQ> the same could be said of any twitter conversation
20:15:30 <ski> "Locus Solum : From the rules of logic to the logic of rules" by Jean-Yves Girard in 2000 at <http://girard.perso.math.cnrs.fr/0.pdf>
20:16:15 <ab9rf> true enough
20:16:33 <ab9rf> i did learn another person on twitter to ignore, though :)
20:17:01 <ski> (oh, the full title of the middle paper is "Mustard Watches : An integrated approach to time and food")
20:18:24 <ab9rf> i would have thought that kaminsky would be less stupid
20:19:54 <ski> addem[m] : i dunno .. perhaps being able to generate a subgroup, from given elements of a (e.g. finite) group
20:22:06 <ski> or computing the center or the commutator subgroup
20:23:02 <Parziva1> do you guys know about #DontJoinItsATrap on Rizon?
20:23:35 * ski doesn't
20:24:18 <Bowlslaw> Parziva1: it is a cool channel. I've only been here for two days(since I started learning Haskell) and it's different than any other language-themed channel i've been to
20:27:10 <Parziva1> yeah, it is not just about the language.
20:27:18 <Parziva1> its also just fun to chill here.
20:27:26 <Parziva1> from what I can tell
20:27:42 <Bowlslaw> the language and how it's best used is different
20:27:55 <Bowlslaw> so you have interesting conversations with fancy-pants terminology
20:28:00 <Bowlslaw> hahahhahaha
20:31:39 <Bowlslaw> f :: A ->, e :: B, then f e :: b
20:31:48 <Bowlslaw> f :: A -> B
20:31:50 <Bowlslaw> oops
20:32:11 <Parziva1> what?
20:32:43 <addem[m]> Trying to recall my Haskell.
20:32:58 <addem[m]> Function maps type A to type B.
20:33:05 <Bowlslaw> if f is a function that maps type A to type B, and e is of type B, then f of e is of type B
20:33:09 <addem[m]> I guess e is type ... B? That doesn't make sense.
20:33:31 <addem[m]> Shouldn't it be that if e is of type A then f e is type B?
20:33:34 <dmwit> This isn't right. Perhaps you meant `e :: A`?
20:33:42 <Bowlslaw> oh yes type A
20:33:42 <Bowlslaw> LOL
20:34:10 <addem[m]> Okay, then I'm not crazy.
20:34:14 <addem[m]> Or we're all under the same mass delusion but at least I'm not the weird one then.
20:34:28 <Bowlslaw> "not crazy" I wouldn't go that far, addem[m]...
20:36:24 * ski . o O ( "1900-1930, the time of illusions : Naive foundational programs, like Hilbert's, refuted by Gödel's theorem." )
20:36:29 <addem[m]> That's what the Deep State would have you think.
20:36:43 * ski . o O ( "1930-1970, the time of codings : Consistency proofs, monstrous ordinal notations, /ad hoc/ codings, a sort of voluntary bureauccratic self-punishment." )
20:36:58 * ski . o O ( "1970-2000, the time of categories : From the mid sixties the renewal of natural deduction, the Curry-Howard isomorphism, denotational semantics, system 𝔽 ... promoted (with the decisive input of computer science) an approach in which the objects looked natural and reasonably free from foundational anguish." )
20:37:28 <addem[m]> The time of categories has passed and I still haven't learned Category Theory.
20:38:10 <lavalike> ski: keep going
20:39:07 <dmwit> "voluntary bureaucratic self-punishment" is a fantastic description
20:39:22 <dmwit> ski: What are you quoting from?
20:39:28 <ski> Locus Solum
20:41:39 <ski> (now i recall someone saying they couldn't decide whether it was brilliant, or an elaborate hoax)
20:42:40 <ski> (or was it "prank" ? i don't remember)
21:50:49 <woodson> Hi guys, I'm following an exercise in the haskell book and I am require to write a traversable instance for a data type http://lpaste.net/
21:51:19 <woodson> Now, I remembered the book clearly stating "We’re not supposed to touch anything in the 𝑓
21:51:19 <woodson> referenced in the type of fmap, so we can’t apply the function
21:51:19 <woodson> (named 𝑓 in our fmap definition) to the 𝑎 because the 𝑎 is now
21:51:19 <woodson> untouchable."
21:51:55 <woodson> does that mean that the definition of the Functor Instance for this type is just return itself?
21:52:17 <woodson> data S n a = S (n a) a deriving (Eq, Show)
21:59:45 <parsnip> that f and a are very tiny in my font
22:00:15 <parsnip> woodson: you linked to lpaste.net
22:00:36 <parsnip> iow, there's no code there
22:01:22 <woodson> jeez
22:01:37 <woodson> I copied the link before it generated the url
22:01:40 <woodson> sorry holdon
22:01:56 <woodson> http://lpaste.net/362616
22:02:06 <sdrodge> woodson: Try following the types as you implement fmap.
22:02:36 <sdrodge> You'll find that there's pretty much only one possibility.
22:02:52 <sdrodge> ignore the "not touching" stuff for now
22:02:55 <woodson> sdroge: I found it, but
22:03:12 <woodson> because it said not to touch the type within the structure
22:03:21 <woodson> fmap f (S n a) = S (fmap f n) (f a)
22:03:48 <woodson> The previous statement is now getting me all confused
22:04:34 <sdrodge> I would need more context about the book quote to answer your question.
22:05:17 <woodson> Well, it says that if I define instance Functor (S n) where
22:05:32 <woodson> I should not modify the n because it is part of the definition
22:09:03 <sdrodge> I would guess the book is saying that the type n need not be modified, you only need to make a become b?
22:09:28 <sdrodge> Just to check, do you know what the type of n is in the fmap definition that you just pasted in channel?
22:11:55 <sdrodge> Also, you understand why the one in the lpaste is wrong?
22:12:50 <woodson> sdrodge, well I know that needs to modify something fmap (a)
22:12:56 <woodson> (a -> b)
22:13:05 <woodson> which will return f b
22:13:06 <ski> ("the type n need not be modified, you only need to make a become b?" -- yes)
22:14:33 <woodson> ski, so they meant that if I have S (Maybe Int) Int I can modify the Int within the Maybe structure but not change the Maybe structure?
22:15:25 <sdrodge> I think you're conflating value level and type level terms a bit.
22:16:11 <sdrodge> But yes, the result of applying fmap will never change Maybe in the type, but it may change Int to something else.
22:20:40 <woodson> sdrodge: Well I mean that how thats how it was presented
22:20:41 <woodson> http://lpaste.net/362617
22:20:56 <woodson> here is exactly the portion from the book
22:21:27 <woodson> I don't understand how else I was supposed to take it
22:21:52 <sdrodge> yes
22:23:22 <sdrodge> but look at the definition of the fmap you gave in the channel
22:23:47 <sdrodge> the n in the function argument is not the same n that is in the data declaration
22:24:17 <sdrodge> you _have_ to apply fmap f to it to get the right result, but doing that doesn't touch the n in the type.
22:24:27 <sdrodge> Which you can't do, as the books correctly says.
22:24:50 <woodson> sdrodge: lol , ya now I get but lol
22:25:01 <sdrodge> It's real late over here, I might be doing an awful job explaining. Maybe someone else should step in.
22:25:16 <woodson> after a statement like that I would have not figure out that they were referring only to type and not the structure
22:25:36 <sdrodge> well, you're not modifying the "structure" either, are you?
22:25:37 <woodson> no worries I get it thanks for your help
22:25:47 <woodson> no I am not
22:26:31 <woodson> but I that because of that statement I couldnt wrap my head around it earlier
22:26:45 <woodson> I did not read the fine lines i guess
22:27:51 <sdrodge> gotcha.
22:28:01 <sdrodge> Well, glad I could help despite clumsy explanations :)
22:28:50 <woodson> sdrodge: thanks! I manage to write the foldable
22:28:56 <sdrodge> Nice!
22:28:59 <woodson> now lets see if I can get the traversable
22:29:01 <woodson> lol
22:29:12 <sdrodge> o// \\o you can do it!
22:29:31 <woodson> i'm not gonna lie its a bit tricky
