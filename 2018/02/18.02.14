00:03:04 <pikajude> which version of haddock supports the "deriving stock ..." syntax?
00:03:07 <pikajude> is that not on hackage yet?
00:05:25 <pikajude> oh, nvm, i have misunderstood an error message
00:05:58 <YungMoon> c_wraith: why am i getting this error? http://lpaste.net/5976877326632222720
00:07:51 <Cooler> is this the maybe monad they are talking about? https://screenshots.firefox.com/9YXXFpN0JR0Woqb2/www.cs.cornell.edu
00:14:17 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
00:14:17 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
00:14:17 --- names: list (clog tjriles lortabac Cooler steshaw SenasOzys howdoi phenoble sdothum alex`` Ariakenom forgottenone poapoa agander slomo oish jfredett heurist`_` Salek harfangk_ harfangk mceier alowaniak malorie zebrah michaelw fragamus nickolay_ hjdskes ninjawithaneedle coot lucajul chele quchen ThomasLocke caryoscelus ninedotnine MoarSpaceFi Barry_ Guest23881 capncanuck[m] KeyJoo alexbiehl sz0 vlatkoB alx741_ lambdaman Gohla1 nullifidian_ Lowl3v3l mrkgnao revprez_atlanta)
00:14:17 --- names: list (revprez revprez_anz Guest85277 brynedwards jimmyrcom_ xinming csweir tumdum jimmyrcom hanna cmsmcq aarvar gienah eliaslfox jedws okuu SAL9000_ gnusosa Contessa crobbins_ x_o_r govg lagothri1 sayola nakal_ banc slackman _ashbreeze_ theDon fryguybob hucksy_ maerwald markus1189 albertid__ niklasl swalladge croben parsnip Frankablu verement kuttifunk eschnett carlomagno Destol ertes Gurkenglas woodson suspicious_frog enterprisey acarrico Tycho duckqlz XorSwap)
00:14:17 --- names: list (keep_learning jcarpenter2 nighty- infinity0 maqbool MP2E chocopuff jdnavarro reactormonk pranz3 tjbp StoneToad otulp OnkelTem wonko7 nyberg peterhil Someguy123 Sgeo reinh1 amidstbinary[m] infinisil barcabuona hiratara andjjj23 tippenein huonw BrAsS_mOnKeY DrAwesomeClaws billsam[m] erikd mcspud raingloom staafl_ jkup cchalmers caa51h [Leary] hvr zero_byte fr33domlover fishythefish danza jan-sipr idupree fionnan akkad Guest53392 energizer padre_angolano mkoenig)
00:14:17 --- names: list (pfurla tsani bafain teej leat Boarders ahihi bxc raynold zzq ericsagnes llinguini Cale locallycompact Ninja3047 u-ou eacameron mgttlinger cgag changyj johs Unhammer yukkuri iravid net4all gareth__ parseval elvishjerricco kaychaks nahra mindtree nelll blankhart jgornick edmundnoble runde Charn vaibhavsagar_ jshjsh Lokathor__ whaletechno rodlogic rodarmor thomashoneyman dgpratt stevejb_ gleber_ dpren isaac__ thi_ hampusw rgrinberg dstockwell darthThorik feepo)
00:14:17 --- names: list (jorendorff mbrcknl_ carter ggherdov chriswk fuziontech dessmm jonrh ryanbooker jakubczaplicki[m martinga_ Strix_ Sigyn AndreasK mek42 mou weareswarmcity[m seanparsons nshepperd taktoa jchia armyriad DTZUZU aananev nesqi sw1nn zaquest FjordPrefect anohigisavay qzo joehillen bluepixel ackthet justanotheruser dredozubov elomatreb dpanth3r rgrau dysfun Gothmog_ cjay- Adeon mandeep Fairy avn rbo llwu duncan^ sbrg Tourist dibblego ClaudiusMaximus tripty @ChanServ)
00:14:17 --- names: list (happyente[m] Jello_Raptor noplamodo nnplv wtw bontaq` kefin bendo CurryWurst metts khisanth_ alvinsj ranberry systemfault bradparker pjan Cir0X ebutleriv jerme_ noobst houli fingerzam Wizek ReinH dan64- CuriousErnestBro micmus peschkaj dgonyeo codedmart gornikm Youmu shivani_[m] uwap alexteves mstruebing1 paf31 banjiewen mnoonan zmanian thunderrd yaknyasn nbouscal osa1 incomprehensibly si14 strmpnk trulsa tharper_ Scorchin etrepum dukedave oh_lawd prefork)
00:14:17 --- names: list (Xorlev husky1 korans HaskellLord69 Maxdamantus a9rkzz athan cpape Tuplanolla pagoda_5b alexknvl mbeidler wavewave TyOverby__ angerman higherorder libbyk lynn thoradam cansis reem bigs vikram__________ bitonic spicydonuts shans_ edwardk angular_mike_ ninegrid S11001001 tjpeden wizonesolutions zph mkurkov_ Guest32984 runeks zpconn__________ posco lukexi TabAtkins dkremer_ strugglingming amatecha sa1 sgraf przemkovv bytesighs ertes-w __main__ mmaruseacph2 jonh)
00:14:17 --- names: list (troydm ego owickstrom bydo iampigman[m] atk bravespear|2 gelnana[m] Zialus g3lnana[m] perrier-jouet sophien[m] esssing yorick peutri sun777 EricZou AntiSpamMeta rotaerk catsup jakutis ByronJohnson pikajude Forty-Bot sim590 zmt00 yahb mniip prg318 Igloo asm[m]1 leandro[m] oliverlsanz[m] Guest1573[m] Bimmie[m] himmAllRight[m] asonixdog[m] scrypso[m] seto[m] kmicklas[m] Litom[m] dumpster[m] anyu[m] vakili[m] chiwui[m] dezren39[m] kwaku[m] maverickwoo[m])
00:14:17 --- names: list (thebeast[m] ElliotKiyomizu[m PatrickM[m] infty[m] KevinMGranger bustillo[m] bingen[m] M-HirmeS lixiang4u[m] discontent[m] pnrfne[m] foo123[m] anonguest[m] guyinjeans[m] srid[m] Elorm[m] am2on neechoo reconmaster[m] virginiam[m] fgaz[m] alldigital[m] Guest340521[m] Quoran[m] wchresta[m] shekel[m] fbreitwieser[m] testtt0x11[m] wannabeog[m] matheusrv[m] kebertx[m] c0ff33[m] sielicki tryptyx[m] h_ndrik[m] Barnabas[m] systemovich[m] usedname[m] gridaphobe[m])
00:14:17 --- names: list (SijmenSchoon[m] km42[m] mrdaak[m] wilo[m] anaxios sburavtsov[m] Scapin[m] bmjh djangoblockchain DavesTestingAcco dirb sudom0nk[m] tuxitagnu[m] dbramucci[m] ArrayWindrunner[ camael[m] gelidae[m] guest69[m] Kevin[m]3 razvanc-r[m] M-rgh Niboor[m] uchronian[m] Mougan[m] Google[m] howsiwei[m] adziahel[m] oats[m] magog[m] Shaunthesheep[m] testingriotnmatr test-guest[m] srenatus magnap artemismucaj[m] minhnhdo[m] saltykawaiineko[ iohidtbhfam[m] riaqn arthurfragoso[m])
00:14:17 --- names: list (atopuzov[m] badamson[m] superpat[m] felipeac[m] grassator[m] nkhodyunya snpriyanshu[m] jvalleroy[m] abel-abel[m] ajtowns[m] saci[m] hpd_m fristonio[m] lkurusa TimWolla[m] cipher1024[m] stuebinm[m] tobim[m] Cadey[m] agraba[m] Makinit thekyriarchy__ avatias0[m] WinterFox[m] ub[m] siddhanathan[m] M-x[m] limonheiro[m] M-wamaral icen[m] Overload[m] M-ms aaaaaaaaab[m] asthma[m] dima_grshk[m] jollyrogue[m] M-kitsune just_test1ng[m] unclechu Heino[m] seif_madc[m])
00:14:17 --- names: list (william[m]1 martunis[m] jbweston[m] rizo[m] noperope[m] peel[m] superobserver[m] michbad henriquezanin[m] HoelKervadec[m] braidn[m] Naughtmare[m] emme[m] bbslclubbin[m] honeymilktea[m] Frytka[m] PifyZ[m] chominist[m] xffox[m] bb010g intheclouddan sudoreboot[m] Akito[m] CryptoCalsius[m] Flecheck[m] ThousandLions[m] metaxis[m] hdurer[m] unlawfulmonad[m] ArchieT mrhania[m] beemo[m] optimizationproc izahn[m] synopz[m] SansFr[m] M-herah ngross[m] monadic[m])
00:14:17 --- names: list (Deleh[m] vsts[m] hiq[m] laaksoan[m] dkellner[m] levzhazeschi[m] AX3L[m] deyg[m] puminya[m] vise890[m] absurd[m] chuzz[m] kasbah[m] daoo[m] drastan[m] chocowheel[m] towaii[m] mossid[m] rakete aman5319[m] relyth[m] georg3[m] Dako300[m] sdvcxd[m] innaytool[m] mad[m]1 Nerka[m] zineje[m] thejonny[m] strangepowers[m] softashell clementd[m] ttk2[m] stigo[m] toumi124[m] naviknair7[m] nh2[m] sh4pe[m] lathebiosas[m] jomari[m] mith[m] seizo[m] motif[m] angelvigo[m])
00:14:17 --- names: list (JackM[m] palacex[m] vitamin-q Dev[m] charlag[m] Jikstra[m] Half-Shot phittacus phil_frontal[m] bgrayburn[m] plll[m] tibike_m[m] asenski[m] M-moyamo jacobleach wubbalubbadubdub ycy[m] zalipuha[m] stites[m] Matthew[m] AntonLatukha[m] aaronc[m] foreseaz[m] porcow[m] puffnfresh moonrunes[m] Masaomi[m] Obscurity[m] gpunk[m] thekyriarchy grisotto[m] herzmeister[m] imbigbrother[m] sherushe[m] strixy[m] riadvargas[m] M-whoops trikl[m] geetam Mcpurplemuffin[m)
00:14:17 --- names: list (schplaf[m] octalsrc[m] aniketd[m] toma[w] pcm77[m] skaillet[m] Orbstheorem[m] M-Chickee lycium[m] M-x-matrix[m] wzy8L-B2[m] SuperW[m] Mike[m]1 anomie[m]1 uha[m] idnar[m] utumno JCGrant[m] tigerchops[m] goodboy[m] undu[m] mak81[m] hakan[m] hendrik[m] drasich[m] zaphar_ps[m] JanPath[m] TylerCecil[m] M-krsiehl angelbeats[m] jerin[m] sn[m] maigel[m] lightandlight rellen WilliamHamilton tester668[m] davidar wizek[m] m4sk1n albertsg[m] davidar_ steshaw[m] bennofs[m])
00:14:17 --- names: list (lierdakil[m] aer[m] turt2live Gratin[m] berton aspiwack[m] Guest50734 spacekitteh[m] ollieh HMPerson1 M-berdario M-BostonEnginerd freeman42x equalunique[m] lysgaard[m] javjarfer[m] noteventime[m] unknownln reactormonk[m] MikasiCoyote[m] geodesic[m] leah2 vimto Xal bs tg julmac treehaqr cmaj9 nurupo miklcct PHO StianL twk- hongminhee anderson peddie froztbyte zenzike abrar gargawel nonzen soncodi raid anoe [df]_ Cathy mattp_ Skarn oleks eikke alek ectos c0dyr)
00:14:17 --- names: list (benonsoftware mathu wladz_ Profpatsch reu segin nemesit|znc CindyLinz hrnz chrzyki jameseb chindy jordanlewis bartavelle bjs bitemyapp zerokarmaleft killtheliterate M2tias a_t Firedancer mk_modrzew casdr pta2002 bcoppens phz_ ion bwe greeny PsyDebug sea-gull pikhq jchia_1 zeroed pharaun sjl_ suzu obfusk kwantam tv dolio tzaeru xmarcoied asjo kebolio insanitea cyphase ghuntley jzelinskie binaryblade tarcwynne__ hansihe jameshaydon solidsnack simony eightb)
00:14:17 --- names: list (iliastsi a3f kini averell jzl tortal kloeri mendez deba5e12 Phyx- kosmikus platz Moyst Liskni_si noxd niko Taneb TallerGhostWalt rootnode max-m jtz vaibhavsagar defanor bengt_ Magemanne Drezil heath srhb solarus dutchie xnyhps glguy shikhin Geekingfrog tureba Randy OliPicard PotatoGim customminer baamonde centril RGamma ocharles jml nkaretnikov sbauman Soft koz_ dxld psychicist__ gopnikovitch SCHAPiE Qommand0r Wamanuz2 felixonmars niveus terrorjack richi235)
00:14:17 --- names: list (lukeshu crosleyt juri_ Reisen stig redcedar Argorok rann entheogen heyj peteretep drewr spinda xplat|work joel135 lexi-lambda gridaphobe mpickering dmj` thoughtpolice Tritlo dashed mitchellsalad ianconnolly srid saemcro noexcept toppler bollu gspia loli fluxit aurieeeh mokus ironChicken typetetris feltnerm cjwelborn giraffe jmct monad_cat Kamuela kyagrd milessabin billstclair mbrock sp1 kipd ericbmerritt_ zgrepc cstrahan metalrain_ CARAM___ andrew_n_ shadowfax)
00:14:17 --- names: list (AlainODea prizim Smeghead avdi beerdrop dmead hc mingc darjeeling_ squisher piyush-kurur falafel YungMoon JoelMcCracken MindlessDrone Biohazard whiteline__ Saizan scinawa jdevlieghere cschneid_ sleblanc Unode antismap brennie Desoxy m1dnight_ Mad_ Tehnix byorgey lopex dxtr grandy_____ cdal Tallenz Deadhand sssilver nekomune jluttine_ nimbleark Stratege lambdabot arkeet PlasmaStar hive-mind robogoat dpower sonOfRa Frans-Willem XMunkki seveg tabaqui cic Cthalupa)
00:14:17 --- names: list (jwynn6 guen marmalodak lukky513 karahobny shiona Robin_Jadoul thebnq hiptobecubic bbear fadein fnurglewitz verlet64 tnks hsiktas capicue rizary rjungemann sdemos mikedlr sunra pchiusano edofic oldsnakey bbielsa Bengi Meow-J_ caw___ iphy sclv Chadtech phryk MarcelineVQ nak cdornan_ NemesisD lumimies stephe dsal marcel trig-ger bgyss ck_y JSharp mstruebing Tspoon_ albel727 colescott cheater bind qwertydvorak My_Hearing linduxed ft AWizzArd dustinm ekrion liff)
00:14:17 --- names: list (anishathalye kiltzman xacktm nikivi lokydor m0rphism jdt harmaahylje tdammers amiri Pilfers tmciver C-Keen Nik05 garphy tessier phadej etiago xplat urdh ent jrslepak jix drewbarbs xaimus jrabe Morgawr bq johnw amx jle` Takumo MagneticDuck TimWolla tolt bsima Guest22057 exio4 hjklhjklhjkl ycheng_ shapr minad azahi mk-fg GGMethos yarou ventonegro aatxe nyuszika7h kav_ abbe lispy_ marek Quintasan mgaare_ sdx23 liste diskie stux|RC-- Gabemo Logio kfish zv klugez)
00:14:17 --- names: list (mdarse guios dpepsilon mlen worch oak- Benzi-Junior xpoqp chrissl survove andyo Solarion dogui SlashLife ekr amosbird earthy Majiir brisbin foolswood przembot sujeet mountaingoat dtulig leothrix k mrBen2k2k2k_ buhman kody^ mrBen2k2k2k scav rbocquet Klumben mitch_ Foritus Lord_of_Life geekosaur Guest17694 Athas oberstein drdo Raptor8m3 edwtjo nisstyre tomku nshepperd1 skeuchel statusfa1led NextHendrix jrm ianp kriztw delYsid` sveit_ NinjaTrappeur esph)
00:14:17 --- names: list (megaTherion michalisko wraithm liurnd_ ephemeron Vq orion zge wto yezariaely nwf anhj ephemera_ dpn` bbaren syq riatre cromachina_ ongy lukd ikopico jaargon Fubar^ byte512 malt3 alanz webstrand shutdown_-h_now cpup reptar_ cgfbee gchristensen omilu WhereIsMySpoon_ Bigcheese mimi_vx pierrot Neo nibbling arw RaptorJesus tumdedum newsham rembo10 michi7x7 echoreply ski ambrosia pikolinosimo SuperTux88 PyroLagus Adluc Purlox aminb freeside madknight m4lvin ab9rf)
00:14:17 --- names: list (cocreature alsoStevenXL_ Voldenet eL_Bart0- ericmath1son Cheeky-Celery x1n4u vin-ivar pmade dcoutts scopedTV divVerent sha-2 mcallisterjp Putonlalla yiannis_t timothyh swflint tokik TMA dysfigured acro dstolfa dilinger cpallares MitchW fall_ niluje lachenmayer monochrom iross rotty linuxdaemon eddsteel _6a68 thaumavorio toure epicallan alp pacak Kneiva boj trosa benzrf Tharbakim amalloy cross Disavowed Guest80763 jbalint nopf seliopou joncfoo fgaz langkid1)
00:14:17 --- names: list (bshelden DustyDingo electrostat Madars poga tsahyt m0ar d3lxa jud Ewout papapishu hpc mikeplus64 naudiz wagle ecx86 fbauckho ramatevish dcoutts__ keri Dykam jorj sanitypassing DoubleJ gxt kmae wz1000 Rembane Ornedan coeus __name__ supki lines danzimm ManiacTwister hydraz aib magicman vodkaInferno jared-w aijony hiredman Warrigal brent80_plow fugyk keyking orzo jokester Natch pasukon acowley Wesleysld Jaxan sdhand qdickon kensan Blkt avocado mulk bickle1 meck)
00:14:17 --- names: list (micro sm tctara _flow_ Spritzgebaeck xintron_ implementation ChongLi hegge jtcs S007 baweaver chirpsalot DK21 ljhms jlouis canta saurik mjrosenb [exa] vjousse dexterfoo greymalkin ftop yushyin stux|RC dminuoso raibutera Niamkik paraseba hexagoxel kaol exferenceBot jinblack flux jw358 comboy akermu Laney rjeli_ logcat Tesseraction_j opqdonut ps-auxw nek0 Meanirelli cyberlard spoonm mt dqd SolarAquarion anhduy bob_twinkles hodapp srk x-n2o swhalen aweinstock qmm)
00:14:17 --- names: list (burp_ Axman6 hanDerPeder tabaqui1 datajerk Amadiro solatis SegFaultAX barrucadu da-x Forkk zymurgy integral Jon ahf cjh` lionaneesh epta fredcy sqrt2 dh agrif sdrodge Guest88515 zekt yoho LeaChim EvanR marble_visions beaky runawayfive japesinator salva WarzoneCommand wrengr_away Chobbes quicksilver abra0 ichigo `0660 Jonno_FTW Akii koala_man milli Flonk bjobjo MasseR raatiniemi matchray philosaur dumptruckman zomg amuck grumble grayhatter Clint mrd c-rog)
00:14:17 --- names: list (int0x27h int-e Nikotiini wedify Princess17b29a cheshircat prooftechnique Chousuke s4msung Gabscap Ke zachary12 noctux huaw obiwahn pyrtsa Zowlyfon DDR ralu deni kipras`away valkyr2e Philonous bgamari aidecoe electrocat cods fiatjaf Jinxit crooked nullie ggVGc carc staffehn numberten mauke quaestor Zoddo ircbrowse rom1504 mak` tomaw hackage akemot sellout heinrich5991 d6e lugh SuprDewd jonge HalfEatenPie jstolarek nille eagleflo pita fiddlerwoaroof)
00:14:17 --- names: list (RevJohnnyHealey brixen_ gsingh93 gothos pfoetche1 lpsmith capisce Fylwind- TommyC janne- Dodgy-Debaser_ valdyn wting atomi cynick paroxp cow-orker pdgwien MalfaitRobin_ relrod detoxin Zemyla ncl28 carbolymer Hafydd bno1 lassulus asm89 lpvb tinco lavalike Eagle_Erwin ijp APic sunya7a Deewiant navilan- statusbot butterthebuddha ynyounuo bsmt ccase theorbtwo gilbertw1 cnomad jswe adamCS kubrat michalrus vqrs Willis fairfieldt dschoepe Fuuzetsu kshannon xa0 luigy)
00:14:17 --- names: list (nilOps betawaffle crlane wayne ahf_ ec2-user_ bus000 surtn wamaral _cyril_ emmflo Yaiyan Xnuk cesardv Sornaensis stefan- monte Cheaterman daft absence Xandaros joeyh henrytill karls n3parikh Eliel davean saftsuse joeytwiddle ij ernst Paks pdxleif fergusnoble catern Hijiri mitchty c_wraith Burnout641_ lyxia edran geal syamaoka markhuge spion tek0_ jackhill armlesshobo Squarism DwarfMaster deu lieven xxpor_ sns Novitsh so)
00:17:44 <Barry_> when do I have to use "`" during infix notation?
00:17:56 <Barry_> only for functions right?
00:17:56 <YungMoon> Barry_: when it's a function name
00:18:02 <Barry_> perfect thanks
00:18:57 <quchen> Barry_: There are two kinds of names, one made of letters and one made of special characters.
00:19:21 <quchen> To use a letter-name infix, put it in ``.
00:19:34 <aochagavia> Hi there, I have a question about stack
00:19:40 <aochagavia> I would like to add a dependency to a library that is not published anywhere, just on a different directory. How can I specify such a dependency in package.yaml?
00:19:42 <Cooler> helpppppppp
00:19:56 <quchen> To use a special-name in prefix, put it in ().
00:20:13 <quchen> > let (*) = "hello" in (*)
00:20:14 <dminuoso> YungMoon: Strictly speaking since they asked about "infix", he's already talking about functions.
00:20:15 <lambdabot>  "hello"
00:20:33 <dminuoso> aochagavia: Those are packages
00:21:01 <YungMoon> dminuoso: operators can be infix too
00:21:04 <dminuoso> aochagavia: Just add them to your "packages" in your stack.yaml
00:21:10 <dminuoso> YungMoon: And operators are not functions?
00:21:24 <Barry_> quchen: couldnt you use a single letter to define Operators?
00:21:25 <quchen> aochagavia: The default stack.yaml gives examples for that
00:21:31 <YungMoon> dminuoso: that's why i said "function name"
00:21:35 <Barry_> or special chars to define functions?
00:21:40 <aochagavia> dminuso, quchen: great, thanks
00:22:10 <Barry_> thanks!
00:22:17 <quchen> They’re completely interchangeable, you can do whatever you want
00:22:30 <ertes-w> hell
00:22:35 <Barry_> I love this. Is this something you do in your free time or is it a job?
00:22:52 <quchen> > let plus = (+) in 1 `plus` 2
00:22:54 <lambdabot>  3
00:28:27 <dminuoso> aochagavia: Also note that dependencies have to be specified in your package.yaml regardless. Stack will then check your resolver, "extra-deps" and "packages" to resolve your dependencies.
00:28:42 <dminuoso> In that order I think.
00:28:51 <aochagavia> dminuoso: I assumed that, seems to work :)
00:34:56 <saurabhnanda> hi there. New to docker, so please point me to a link if there is a known solution for the following problem -- how does one use docker for *development* in Haskell? Does spacemacs need to be installed in the docker container itself? will spacemacs' GUI work if started from within the container?
00:37:53 <lortabac> saurabhnanda: you can mount your project directory into the docker container
00:38:24 <lortabac> so you can still work as usual
00:38:29 <saurabhnanda> lortabac: that part is done. but assuming that host is mac osx and conntainer is ubuntu, where do I start the IDE from?
00:39:00 <lortabac> in mac osx
00:41:39 <saurabhnanda> how will spacemacs/intero work then? the compiled artefacts will be of ubuntu, whereas spacemacs/intero would expect them to be of mac osx
00:42:34 <dminuoso> saurabhnanda: Normally you dont directly touch the docker container itself. You rather just have a simple directory as usual.
00:44:30 <dminuoso> saurabhnanda: It's the build itself that happens itself, not the editing of files.
00:44:35 <dminuoso> *that happens inside
00:45:45 <saurabhnanda> hmm
00:46:19 <saurabhnanda> so, is there a recommended workflow for docker in development? or is it not worth the effort?
00:46:53 <lortabac> saurabhnanda: personally I run intero on mac osx, and use docker for full compilation when I want to test the whole application
00:47:16 <lortabac> I don't know how to achieve what you are trying to do
00:47:50 <saurabhnanda> original problem statement => how do we get our app setup on new developer machine's without any hitches. Many components and dependencies; and right now devs spend 2-3 days stumbling across one roadblock after the other.
00:50:23 <EvanR> i mentioned your critique of elm for not having typeclasses to someone who has ben dabbling in elm
00:50:44 <EvanR> since they have no idea what typeclasses are, doesnt seem to be much of a bummer
00:50:56 <lortabac> saurabhnanda: I am a docker beginner too, but I can tell you what my workflow is
00:51:52 <lortabac> build a docker image for each of your components, and then compose them with docker-compose to setup all the needed dependencies
00:53:02 <Cooler> is this the maybe monad they are talking about? https://screenshots.firefox.com/9YXXFpN0JR0Woqb2/www.cs.cornell.edu
00:53:38 <lortabac> then leave out the component on which you are currently working, for faster development
00:53:44 <nomemory> hello, doing a solution for the collatz conjecture: http://lpaste.net/362485 - but getting some problems with number conversions. Any suggestions ?
00:55:00 <EvanR> you can't use logBase with Integer
00:55:08 <EvanR> you need to find or write an integer log
00:55:37 <EvanR> unless you want to roll the dice and convert the Integer to Double first
00:55:44 <EvanR> in which case use fromInteger
00:55:46 <EvanR> :t fromInteger
00:55:47 <lambdabot> Num a => Integer -> a
00:56:01 <cocreature> https://hackage.haskell.org/package/integer-logarithms-1.0.2/docs/Math-NumberTheory-Logarithms.html#v:intLog2 is probably a better solution
00:56:34 <nomemory> i see
00:56:47 <cocreature> or if you don’t want a dependency, "logBase2 x = finiteBitSize x - 1 - countLeadingZeros x"
00:57:01 <nomemory> but if I do in ghci: :t toInteger . truncate $ logBase 2 2
00:57:04 <nomemory> it works
00:57:14 <EvanR> :t 2
00:57:15 <lambdabot> Num p => p
00:57:22 <lortabac> saurabhnanda: this workflow works very well for me, except some docker issues on mac osx
00:57:34 <cocreature> nomemory: try adding explicit type annotations for the literals
00:57:34 <nomemory> :t toInteger . truncate $ logBase 2 2
00:57:35 <EvanR> 2 can be a float, but not if you also used it like an Integer
00:57:35 <lambdabot> Integer
00:57:56 <nomemory> so I need to convert the 'x' to a Float ?
00:58:07 <EvanR> that would be the gross and possibly wrong way
00:58:12 <saurabhnanda> lortabac: what's your container os and what's your host os? when using docker for development, after mounting the source-code dir into the container, where/how do you start your editor? which editor do you use?
00:58:19 <EvanR> see the integer-logarithms package
00:58:26 <ertes-w> saurabhnanda: you get your dev setup onto someone else's workstation by writing a cabal file
00:58:36 <ertes-w> i don't see how docker does anything for you here
00:58:50 <saurabhnanda> ertes-w: db setup, elastic-search setup, redis setup, etc
00:59:27 <dminuoso> ertes-w: Before I approach this any further, does this look fine to you? https://gist.github.com/dminuoso/de8c7b7cd3115777c449024b42aa360a
01:00:04 <dminuoso> Oh and updated gist to include my own Store.hs
01:01:31 <lortabac> saurabhnanda: I have a docker image for the db, a docker image for elastic etc.
01:01:43 <lortabac> then a docker-compose with all the dependencies
01:02:10 <lortabac> *without* the current project
01:02:49 <lortabac> so I develop with vim, intero etc. on mac osx
01:03:26 <dminuoso> EvanR: I guess that might be part of the reasoning for lack of any abstractions in Go too. If people dont understand features, they surely cant miss them.
01:03:41 <lortabac> and then run the full docker-compose (Haskell code included) when I want to test the whole application from A to Z
01:03:46 <EvanR> i was just thinking of go when i said that
01:03:57 <dminuoso> Heh.
01:08:47 <dminuoso> EvanR: The surprising bit is just, I remember when I started - writing typeclass instances felt so natural and obvious, that no explanation was required. In fact later someone here had to explain to me that "HKTs is really simple and useful. You have been using it for a while now"
01:09:35 <EvanR> i didnt get it for a long time
01:10:14 <dminuoso> EvanR: To me it clicked when I was shown this
01:10:16 <dminuoso> :k Functor
01:10:17 <lambdabot> (* -> *) -> Constraint
01:10:33 <dminuoso> EvanR: And was then told to think of it like higher order functions.
01:11:05 <dminuoso> Except acting on types, rather than values.
01:11:22 <EvanR> stuff like Functor Maybe, Maybe Int, and Just 99 didnt click for me because, they didnt reduce to anything, it was like what
01:11:53 <EvanR> and since it wasnt traditional application sytnax f(x) i wasnt even sure if it was supposed to be application
01:12:21 <dminuoso> EvanR: By reduce you mean that `Functor Maybe` looked like a composition, rather than a type family kind of "application" ?
01:12:21 <EvanR> function calls are suppsed to return something !
01:12:27 <dminuoso> Ah right.
01:12:43 <EvanR> if Just is a function... then what does Just 99 return
01:12:48 <EvanR> mind blown
01:13:47 <bq> Is Just 99, Just 99?
01:13:57 <dminuoso> That's Just Right.
01:14:01 <EvanR> depends on the what is is
01:14:05 <bq> heh, fair
01:15:04 <bq> I should get back into Haskell. Was never taught monads properly, but I was always fine with everything up to and including high-order stuff
01:15:30 <EvanR> since there really are multiple things Just 99 could be talking about, it is a bit of lisp-like equivocation to use the same rendering for all of them... only the trick is that it seems to not matter in practice
01:15:33 <bq> From my reading on Monads so far, they are something I think I will have to use to appreciate
01:15:43 <dminuoso> EvanR: So I guess the conclusion is that when you specify constraints, you actually have something of the shape (Constraint, Constraint, ...) - and typeclasses give you kind of non-total compile-time "type functions" to produce constraints right?
01:15:51 <dminuoso> EvanR: Or are there ways go create adhoc constraints?
01:16:10 <EvanR> well uh
01:16:12 <EvanR> :k (~)
01:16:14 <lambdabot> k -> k -> Constraint
01:16:35 <dminuoso> Interesting, so there are other type functions producing constraints too.
01:16:39 <tsahyt> is there some pragma that I can use that emits a compile time warning? just wondering, because I might use that to tag temporary undefined values so I don't forget about them
01:16:44 <dminuoso> Im guessing ~ is "type equals" ?
01:16:50 <EvanR> yes
01:17:18 <tdammers> bq: http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
01:17:39 <dminuoso> EvanR: That's pretty cool. How is this generally used? With type families so you do some `F a ~ G b` ?
01:17:48 <bq> tdammers, Thanks, this will be the nth paper on Monads I have read
01:18:18 <bq> (Which will never be harmful)
01:18:32 <dminuoso> Though it begs the question of "what actually a Constraint is"
01:19:04 <EvanR> dminuoso: ime, sometimes you have a constraint written some which way, but you also want to refer to it by name. since there is no "let" in that syntax, you can introduce a type variable on the left of => and also that it is equal to something
01:19:12 <tdammers> bq: no, it's not really a paper, actually, and it explicitly *doesn't* explain monads in a lot of words. Just read it.
01:19:21 * bq eyes down
01:19:38 <Boarders> just to check I am not mad if I have some lens l :: Lens' Datatype Field and I have d :: Datatype and f :: Field then if I do d (&) l .~ f then I get back d with the field changed to f?
01:19:42 <dminuoso> EvanR: Ahh I see.
01:20:04 <Boarders> that & should have no brackets, sorry
01:20:04 <tdammers> bq: also, I suggest ignoring monads until you have a good understanding of at least Functor and Applicative, ideally also Semigroup and Monoid
01:20:32 <bq> I have a novice's grasp of Fucntor, Applicative, and Monoids
01:20:54 <bq> I was reading through Category Theory for Programmers or something of a similar title at one point, I found that interesting
01:20:56 <[exa]> how do you call something that takes type-level value and returns a term-level value?
01:20:57 <dminuoso> bq: Like many others I fell into the trap of trying to tackle Monads from the Category Theory. While highly enlightening, it was a pointless excecise because after I understood it, I still had no clue what a monad in Haskell was for.
01:21:07 <bq> Oh interesting
01:21:12 <[exa]> (not sure if that would be a function)
01:21:15 <EvanR> dminuoso: the LHS of => really is some sort of borderlands logic language embedded inside haskell
01:22:24 <tdammers> bq: IME, the Category Theory stuff doesn't really help much until you're very deep into the whole matter, because the connection between CT monads and the Monad typeclass is on a very abstract theoretical level, so understanding CT monads won't necessarily have much practical use with Haskell monads, even though they are "the same" on some level
01:22:38 <dminuoso> [exa]: an adhoc polymorphic constant function?
01:22:44 <dminuoso> :<
01:22:46 <bq> I found it interesting, but not too helpful immediately, yeah tdammers
01:23:01 <dminuoso> Or I guess it could be a value directly
01:23:14 <kneedler> Hi all, new to the channel
01:23:20 <kneedler> Is this the right place to ask questions?
01:23:21 <tdammers> bq: the most important thing about Haskell's Monad typeclass is that there is absolutely nothing special about it, it's hardly more complicated than Functor or Applicative, really
01:23:27 <tdammers> kneedler: yes, just ask
01:23:37 <bq> tdammers, I have noticed that
01:23:49 <sphinxo> How can I staticly link libpq.so into my binary that uses postgres-simple?
01:23:49 <dminuoso> tdammers: I found that actually it's applicative that is a bit more special - because its not immediately obvious that something might be an Applicative but not a Monad.
01:24:44 <tdammers> dminuoso: agree. Similar to how Semigroup is a less obvious concept than Monoid.
01:24:59 <sphinxo> instead of relying on it being installed in the system
01:25:35 <kneedler> @help
01:25:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:25:46 <kneedler> @list
01:25:46 <lambdabot> What module?  Try @listmodules for some ideas.
01:25:55 <dminuoso> kneedler: You can interrogate lambdabot in a PM by the way. =)
01:26:13 <kneedler> dminuoso, Ah thanks :)
01:27:11 <dminuoso> tdammers: Dunno. You can trivially turn any Semigroup into a Monoid, but you cant trivially turn any Applicative into a Monad.
01:27:52 <ertes-w> dminuoso: Store itself looks good, as far as i can tell without testing
01:28:56 <ertes-w> @let data V2 a = V2 !a !a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
01:28:57 <lambdabot>  Defined.
01:29:27 <ertes-w> > sequenceA (pure [-1..1]) :: [V2 Int]
01:29:29 <lambdabot>  error:
01:29:29 <lambdabot>      • No instance for (Applicative V2) arising from a use of ‘pure’
01:29:29 <lambdabot>      • In the first argument of ‘sequenceA’, namely ‘(pure [- 1 .. 1])’
01:29:33 <tdammers> dminuoso: Non-empty lists? What's the trivial Monoid over those?
01:30:04 <ertes-w> @let instance Applicative V2 where pure = join V2; V2 f1 f2 <*> V2 x1 x2 = V2 (f1 x1) (f2 x2)
01:30:06 <lambdabot>  Defined.
01:30:08 <ertes-w> > sequenceA (pure [-1..1]) :: [V2 Int]
01:30:10 <lambdabot>  [V2 (-1) (-1),V2 (-1) 0,V2 (-1) 1,V2 0 (-1),V2 0 0,V2 0 1,V2 1 (-1),V2 1 0,V...
01:30:30 <dminuoso> tdammers: You add an empty list?
01:30:47 <dminuoso> tdammers: My point is you can trivially just make up the identit element out of thin air.
01:31:09 <tdammers> dminuoso: oh, like that. I see what you mean.
01:31:38 <ertes-w> dminuoso: i don't like using Word8 as Cell…  i would have used Bool
01:31:52 <dminuoso> ertes-w: The idea was to make it trivial to directly convert it into ByteString.
01:31:57 <dminuoso> (And back again)
01:32:14 <ertes-w> dminuoso: it's trivial to convert Bool into Word8 and back =)
01:32:21 <dminuoso> ertes-w: I guess there's that =)
01:32:51 <ertes-w> dminuoso: however, using Bool gives you the opportunity to use a better internal representation if you need it
01:32:54 <EvanR> you know, better would be if it was always a ByteString, and the matrix was an image of it sharing the monolithic ByteString in the back
01:33:23 <ertes-w> dminuoso: right now you use one byte for every bit of information, so you waste 7/8 of the memory
01:33:42 <EvanR> newtype over a bytestring with phantom params for the dimensions, access with typeclasses
01:34:39 <ertes-w> dminuoso: however, the main point is that Store is meant to abstract away that internal representation…  for example i would use a vector of Word64 and a compact representation, but my *interface* (which is Store) would give Bool
01:35:04 <ertes-w> BTW, this is something ByteString is surprisingly terrible at
01:35:52 <ertes-w> you can only ever work with, you know, bytes, which is needlessly inefficient, and also the memory is always pinned…  an unboxed vector gives GC a much easier time
01:37:51 <dminuoso> ertes-w: That would mean writing my own Prim instance though, doesn't it?
01:38:00 <kuribas> @hoogle Applicative m => m a -> m b -> m a
01:38:01 <lambdabot> Prelude (*>) :: Applicative f => f a -> f b -> f b
01:38:01 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
01:38:01 <lambdabot> Diagrams.Prelude (*>) :: Applicative f => f a -> f b -> f b
01:38:46 <ertes-w> dminuoso: the vector library has its own Unbox class for unboxed vectors (note: unboxed vectors ≠ primitive vectors)
01:38:58 <ertes-w> dminuoso: and most important types already have an Unbox instance
01:40:01 <ertes-w> dminuoso: Unbox is pretty much the same idea as Prim…  it's a legacy from before vector used the 'primitive' library, but it's also slightly higher-level…  for example you get Unbox instances for tuples
01:41:10 <dminuoso> ertes-w: I see. So I might use some `Data.Vector.Unboxed.Vector Word64` (which seems to have an instance), and hide the access pattern in my Store - and only present an abstract Pos -> Bool interface
01:41:14 <ertes-w> dminuoso: the only reason i'd go with Word64 and manual bit twiddling is that the Unbox instance for Bool surprisingly isn't actually compact
01:41:40 <ertes-w> it uses one byte for each bit, much like you do right now
01:41:50 <dminuoso> Ah
01:42:10 <dminuoso> ertes-w: Even on x86?
01:42:14 <ertes-w> yeah
01:42:16 <dminuoso> That's a bit shameful.
01:42:24 <ertes-w> i thought of submitting a patch to fix it, but it's a lot of work actually
01:42:58 <ertes-w> it needs to support the whole vector interface, which includes being able to do something like (drop 1)
01:47:47 <ankitsiam> any suggestion for queues implementations in haskell,i mean any efficient module or something >?
01:48:02 <Athas> Does anyone have experience writing Homebrew Formula for Haskell packages that use Stack?
01:48:10 <ertes-w> ankitsiam: for basic queues?  Data.Sequence
01:48:33 <ankitsiam> ertes-w : for advacne ?
01:48:39 <ankitsiam> advance* ?
01:48:49 <ertes-w> ankitsiam: in that case define advanced =)
01:48:51 <ertes-w> what do you need?
01:49:00 <Athas> The ones I can find all use Cabal, which is fine I guess, but fragile.
01:50:38 <ertes-w> Athas: i don't have any experience with stack, but that last statement confuses me, and i'm not sure if i'm supposed to be irritated by it or not =)
01:51:01 <kuribas> data Queue a = Queue [a] [a] ?  amortized O(1)
01:51:22 <ertes-w> kuribas: or as i like to call it:  BS(1) =)
01:51:49 <EvanR> the immutable queue, its like FP-ers lightsaber
01:51:58 <EvanR> very implausble and very impressive
01:52:17 <Athas> ertes-w: Homebrew does not checkpoint/snapshot the state of Hackage, so I will have to freeze all my dependencies, or risk that my "formula" will break in the future due to Hackage changes.
01:52:22 <kuribas> yeah, can be inefficient if you get the same value twice from the same queue.
01:53:09 <kuribas> can't it be improved with lazyness?
01:53:47 <ertes-w> Athas: cabal does dependency resolution, and especially with new-build it will just use the newest versions that match your bounds without interfering with anything else
01:54:14 <ertes-w> or in short:  if homebrew uses cabal correctly, cabal-install new-build will just do The Right Thing
01:54:54 <kuribas> ertes-w: can be still appropriate in some cases, and faster than Sequence.
01:55:29 <ertes-w> kuribas: i buy the "can be faster than Seq" part, but only in very small cases by a very small constant factor
01:56:15 <kuribas> factor of at least two I'd think...
01:56:35 <kuribas> since no balancing needs to be done etc...
01:57:02 <kuribas> should benchmark it...
01:57:09 <ertes-w> kuribas: cons/snoc and uncons/unsnoc is O(1) with finger trees (Seq)
01:57:14 <ertes-w> actual O(1), not BS(1) =)
01:57:53 <EvanR> with a heavy constant factor
01:57:56 <cocreature> amortized runtimes are definitely not BS, you just need to be aware of the guarantees they provide
01:58:03 <EvanR> so another form of BS
01:58:33 <EvanR> some O(1) have bigger Os than others
01:59:25 <ertes-w> cocreature: sure, don't take me too seriously on the "BS" part…  but in the case of dual- or even triple-list queues it's kind of BS, because you're not actually saving any computing time, you're just delaying it
01:59:44 <ongy> can I get ghc to dump the result of strictness analysis and tell me which functions it considered strict in which argument? So I can evaluate if I want to unpack a few constructor fields
02:00:33 <kuribas> ertes-w: I'd think simply reversing a list is much faster than doing bookkeeping on finger trees.  But I haven't benchmarked it, so...
02:01:24 <cocreature> ongy: iirc you can see the results in core
02:01:32 <ertes-w> kuribas: finger trees have heavier constant factors than something like binary trees…  the trade-off is that they support O(1) operations at the ends and very efficient append
02:01:42 <ertes-w> kuribas: that's why they work so great for queues
02:02:17 <ongy> Not the biggest fan of digging into core. Maybe it's a skill I should learn :/
02:02:34 <cocreature> ongy: http://fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html has some examples
02:03:21 <cocreature> ongy: actually it looks like ddump-stranal might give you Haskell code instead of core or sebastian has just converted it manually for presentational purposes
02:03:49 <kuribas> ertes-w: yeah, they're great
02:04:53 <Wizek> hello
02:05:00 <Wizek> Anyone around who've used Chart?
02:05:22 <Wizek> And knows how I can move the default axis from being on the left to being on the right?
02:05:46 <ertes-w> kuribas: they can also be great as the underlying structure of "ropes" (text chunks arranged in a length-tracking tree)…  you can't use Seq for that, but there is the more generic 'fingertree' package…  it doesn't have too many other uses though, as far as i can tell
02:06:59 <kuribas> ertes-w: what if I want a quick way to serialize xml into a bytestring?
02:07:25 <ertes-w> kuribas: what's the question?
02:08:39 <kuribas> ertes-w: the most efficient way to do [Text] -> Strict.ByteString
02:08:44 <sgraf> ongy: cocreature: Yeah, it outputs Core (notice how operators aren't infix) and I simplified it to the point it's readable. Depending on what you need, I'd start with `-dsuppress-all` or `-dsuppress-<whatever>` to get a grasp for stuff
02:09:36 <cocreature> sgraf: ah thanks, I would have been quite surprised if the output was Haskell :)
02:09:37 <ertes-w> kuribas: ideally don't do it in the first place =)
02:10:21 <kuribas> ertes-w: for example, I want to serialize a haskell ADT into xml, then serialize it into a DB table.
02:10:22 <ertes-w> kuribas: for output best use lazy ByteStrings, and given an encoding a [Text] converts naturally into a lazy ByteString
02:10:45 <sgraf> Dreaming of a pretty-printer/semantic editor for Core
02:10:56 <ertes-w> kuribas: if you can ensure that all your appends are right-associative just append chunks of lazy ByteString, otherwise use Data.ByteString.Lazy.Builder
02:11:32 <sgraf> I mean, there's https://hackage.haskell.org/package/ghc-core but I'm pretty certain it doesn't work anymore
02:11:33 <ertes-w> kuribas: if you're not sure, just use Builder as a safe default
02:12:43 <ankitsiam> ertes-w : i checked Data.Sequence but how do you enque an element into the que without declaring a new variable
02:13:05 <ertes-w> kuribas: alternatively use Data.Text.Lazy.Builder and just use text's I/O facilities together with hSetBinaryMode and hSetEncoding
02:13:38 <ertes-w> ankitsiam: use (|>) to enqueue, use 'viewl' to dequeue
02:14:03 <ertes-w> ankitsiam: (or (<|) to enqueue and 'viewr' to dequeue)
02:14:37 <kuribas> ertes-w: yeah.  Perhaps using renderTags of fast-tagsoup will be enough...
02:14:46 <sgraf> I think mpickering presented something like a viewer for Core at Haskell Symposium last year
02:14:54 <ertes-w> kuribas: you could also just use blaze-markup
02:15:09 <ertes-w> (if it's XML)
02:15:34 <kuribas> yeah, xml, though not html
02:15:45 <ongy> sgraf: ah, sounds more reasonable than usual core. thx
02:16:12 <ankitsiam> ertes-w : but that gives a new seq it doesn't change the one i defined
02:16:53 <ertes-w> ankitsiam: Seq is an immutable data structure…  you don't "change" it, you create a new, updated version
02:17:37 <ankitsiam> ertes-w : then how do i get a global que which different functions can read or write from ?
02:18:01 <ertes-w> ankitsiam: i think at this point you should explain the application
02:18:03 <EvanR> a Chan, or TChan, or unagi-chan
02:18:35 <ankitsiam> ertes-w : i want a global que which i want to enque & deque from a different function
02:19:06 <mpickering> ongy: I currently use dump-core
02:19:07 <ertes-w> ankitsiam: yes, but for what
02:19:10 <ertes-w> ?
02:19:22 <mpickering> Which is very effective but a bit broken
02:19:49 <mpickering> I wrote a better tool imo but there is still work to do to release it
02:20:00 <ertes-w> ankitsiam: reason i'm asking is that haskell uses a very different paradigm…  "global queue" sounds like you're trying to program C in haskell
02:20:50 <ertes-w> ankitsiam: if you explain your application, we can help you finding a better approach that fits the paradigm haskell uses =)
02:22:18 <ankitsiam> iertes-w : there are two threads one enques it and second process it and deques it (those messages which first thread enqued)
02:22:22 <ongy> mpickering: My ghc neither knows -ddump-core nor -dump-core, which is interesting
02:22:48 <mpickering> It's a package :p
02:22:59 <ij> Is there a splitBy :: ByteString -> ByteString -> [ByteString]?
02:23:03 <Wizek> I've found it: `layout_right_axis_visibility .= def`, nice.
02:23:17 <ij> Or rather how can it not exist? :(
02:23:44 <ongy> ahh
02:24:13 <ankitsiam> ertes-w : there are two threads one enques it and second process it and deques it (those messages which first thread enqued)
02:24:17 <merijn> ij: What are you trying to do, because that seems a rather odd operaiton to me, tbh
02:24:36 <mpickering> My core pretty printer required a patched ghc which is why I stopped working on it
02:24:38 <sgraf> mpickering: Cool, thanks for the pointer! There's also a more recent ghc-dump-core by bgamari, so I suspect that's the thing to choose?
02:24:42 <merijn> ankitsiam: Why do you need a global queue for that? You can just pass the queue to the individual threads/
02:24:46 <EvanR> that operation  is bread and butter on javascript, among others
02:24:52 <phz_> any idea how I can make a ping to a database (PG) with persistent?
02:24:59 <phz_> looks like selectFirst [] [] won’t work, right?
02:25:03 <dminuoso> ertes-w: Oh by the way.. My mind was totally blown when I learned that Store is actually Costate =)
02:25:09 <merijn> phz_: What does "ping to a database" mean?
02:25:15 <phz_> merijn: SELECT 1;
02:25:24 <phz_> just witness the database is up, answer correctly, etc.
02:25:40 <merijn> phz_: Use rawQuery?
02:25:41 <ertes-w> ankitsiam: now that's a very different story…  you should probably use Chan =)
02:25:43 <dminuoso> ertes-w: I think Im at a position where I need to learn about what an adjunction/adjoint functors are. It feels like Im about to tap into a well of deep meaning. :)
02:25:44 <ankitsiam> merijn : because processing might take time so it won't block the thread if i store the requests and process them one after another
02:25:48 <phz_> merijn: hm, I’m looking for that function
02:25:54 <mpickering> sgraf: I use yav's version
02:26:00 <phz_> oh, found it
02:26:03 <merijn> ankitsiam: That...is not related to what I said at all?
02:26:05 <phz_> merijn: puuurfect, thanks!
02:26:09 <mpickering> Not sure what Ben's does exactly
02:26:12 <ij> merijn, Maybe I don't need it after all, I can just split by char in this case.
02:26:28 <ertes-w> ankitsiam: however, you shouldn't use a *global* Chan…  just create one in the main thread and pass it to the two threads that use it
02:26:33 <merijn> ij: Yeah, but what's the high level usecase? Because I suspect there's far easier libraries for that
02:26:37 <phz_> I guess rawQueryRes is better to me
02:26:43 <phz_> it runs in the right monad
02:26:44 <ij> merijn, Parsing IRC logs.
02:26:44 <phz_> not ConduitM
02:27:10 <merijn> ij: So, why not use attoparsec?
02:27:12 <phz_> nevermind, it’s rawExecute.
02:27:22 <ij> merijn, Because the format's way too simple.
02:27:37 <merijn> That...seems like a weird reason not to use attoparsec?
02:27:56 <locallycompact> is there a way to catch errors from libraries that are designed to immediately exit the program?
02:28:18 <merijn> locallycompact: Depends how they exit
02:28:26 <locallycompact>  https://gitlab.com/locallycompact/FullMetalHaskell/blob/master/Shakefile.hs#L101
02:28:37 <phz_> merijn: if it fails, it… generates an exception?
02:28:48 <merijn> phz_: No clue, tbh
02:28:53 <phz_> damn
02:28:58 <phz_> I’ll just test it then
02:28:59 <locallycompact> that "errors" on fail but I can't seem to catch it and continue the iteration
02:29:10 <ongy> mpickering: oh that looks "readable" :D thx, I'll try to get comfortable with it :)
02:29:22 <dminuoso> Here's a question. Why is State `a -> (b, a)` and not `a -> (a, b)`?
02:29:29 <ertes-w> dminuoso: to be honest i don't think of Store as state-anything…  i think of it as "functions with a current argument"
02:29:51 <mpickering>  I use it everydat ppp
02:30:02 <mpickering> wooops, I use it everyday*
02:30:08 <ertes-w> dminuoso: they might be "costate" in the categorical sense, but i wouldn't know that =)
02:30:47 <ertes-w> dminuoso: history (about (s -> (a, s)))
02:31:26 <ij> merijn, FINE! I will use attoparsec.
02:31:38 <merijn> dminuoso: honestly, might just be historical accident?
02:33:28 <ongy> or they considered some implementations to be easier if the state can use Functor instance of tuples
02:33:35 <dminuoso> ertes-w: From what I understand the principle idea is that monads arise from composing adjoint functors one way, and comonads from composing them the other way. In this case the adjoint functors are (a -> b) and (a, b). But this is some very lose and potentially wrong understanding.
02:35:25 <ertes-w> there was a time when it was hip to write monad transformer libraries…  stuff like monads-tf and monadLib popped up…  in fact i wrote my own HIGHLY UNDERAPPRECIATED transformer library that everybody should have used, but nobody did
02:35:28 <locallycompact> shouldn't it be possible to tell from the types whether its possible to catch errors from a shake 'cmd' call
02:35:55 <locallycompact> its very confusing
02:36:04 <tdammers> seems to me that the functor instance for tuples would be enough of an argument to put them this way
02:36:13 <ertes-w> some of them tried to swap the tuple of StateT, but ultimately mtl/transformers survived all of that, so we have (s -> (a, s)) =)
02:36:39 <dminuoso> tdammers: You have a Functor instance either way, but the focus is just different?
02:37:07 <dminuoso> tdammers: but I guess with (b, a) it'd be over the same type as the Store at least.
02:37:27 <dminuoso> ertes-w: Ah, I see.
02:38:18 <tdammers> dminuoso: right, yes, that's what I mean
02:38:48 <ertes-w> dminuoso: you could ask a similar, or should i say *dual*, question: why is Store (p -> a, p) and not (p, p -> a), but in this case there is even less of a technical incentive to prefer one over the other
02:38:57 <ertes-w> one makes some functions nicer, the other makes others nicer
02:39:23 <lseactuary> anyone know a good IDE or similar for coding in Haskell instead of using a text editor and running in ghci?
02:40:01 <ertes-w> lseactuary: there is emacs with haskell-mode, which is pretty much an "IDE"
02:40:15 <lseactuary> nice
02:40:16 <lseactuary> will download
02:40:19 <EvanR> its missing a play button
02:40:26 <EvanR> so not technically an IDE
02:40:45 <lseactuary> ye just using atom and running in the terminal
02:40:47 <lseactuary> seems long
02:40:48 <ertes-w> EvanR: well, it has a play keyboard shortcut =)
02:40:58 <lseactuary> just was wondering if there was an easier way
02:41:03 <lseactuary> also autocomplete on functions
02:41:14 <lseactuary> and to insert brackets and stuff itself
02:42:11 <ertes-w> EvanR: in fact i wrote the 'rapid' library to make that "play" shortcut even more integrated =)
02:42:23 <ongy> mpickering: is it normal to see a couple of read instructions in -O2 core that seemingly are never used? Or can I likely improve code somewhere to get rid of those?
02:42:42 <ertes-w> e.g. reload individual running components during development
02:43:14 <mpickering> ongy: Depends so much on the program.. if you can publish the core dump I could look
02:44:57 <mpickering> I'm not even sure what a "read instruction" is
02:46:17 <dminuoso> ertes-w: The more Im reading about monad construction, the more it seems like a -> (b, a) is the clean way, and its actually (p -> a, p) that is the non-categorically-intuitive way.
02:47:12 <dminuoso> ertes-w: The reason has to do, that if you assume F b a ~ (b, a) and G b a ~ (b -> a), and assume that there's a Functor instance for both `F b` and `G b`, then State and Costate arise from (F b) . (G b) and (G b) . (F b) respectively
02:47:28 <ongy> mpickering: I was wondering about renderChildren here https://ongy.net/waymonad-core/Waymonad.Shells.XWayland.html (oh yea, doing a lot of IO, simply by the domain of the application, so yea readWord160ffAddr#
02:48:33 <mpickering> so you are looking at $wrenderChildren I guess?
02:48:55 <dminuoso> For the reason that you cant have some `Functor (,b)` instance (if that weird notation makes sense)
02:48:57 <ongy> of course thats 16OffAddr, not 160ffAddr. Thanks brain :D (187) $w$renderChidrlen
02:49:38 <mpickering> Which reads are not used?
02:49:38 <mpickering> it looks reasonable from a glance
02:50:39 <ongy> unless I get the syntax wrong, the last 2 (ipv4 _ and ipv6 _) only use the State# RealWorld from the return value, and never use the actually read Word16
02:51:18 <ertes-w> dminuoso: thanks, you might just have helped make adjuctions click for me =)
02:52:07 <dminuoso> ertes-w: It's the least I can in return for you helping me so frequently. :-)
02:52:27 <mpickering> ongy: Right but these are IO actions so that makes sense?
02:52:47 <mpickering> If you hover over ipv4 and ipv6 then you see they are used
02:53:13 <ertes-w> dminuoso: regarding your statement keep in mind that it's not always the best idea to stick to categorical definitions/outcomes strictly, but in an up-to-isomorphism fashion…  consider even Monad itself, which is defined in terms of (>>=) instead of 'join'
02:53:28 <ongy> they are IO actions, they could make sense. But it's a read. So unless this is some lookAhead optimisation (which I don't see any indication for) I don't see how it makes sense
02:54:12 <ertes-w> dminuoso: in other words: whether (s -> (a, s)) or (s -> (s, a)) is better is really a practical concern, because they are isomorphic anyway
02:54:22 <dminuoso> ertes-w: Ah yeah I guess so.
02:54:35 <mpickering> ongy: ok. As far as I understand, how these behave is specified in primops.txt.pp
02:55:34 <mpickering> And you can see the definition for "readWord16OffAddr#"
02:55:48 <EvanR> :r
02:55:59 <mpickering> https://www.irccloud.com/pastebin/Rj6E9DaP/
02:56:11 <ertes-w> dminuoso: we could totally define Monad in terms of 'join', but practically speaking how often would you actually use 'join' without doing an 'fmap' first?
02:56:31 <ertes-w> dminuoso: that's why for haskell it makes more sense to use (>>=)
02:56:43 <EvanR> sometimes join makes more sense during implementation
02:56:48 <dminuoso> ertes-w: Ah right. I mean using `join` happens somewhat frequently when interacting with lists on my side at least.
02:56:50 <mpickering> ongy: Now I don't know why "readWord16OffAddr#" has a side effect but now you have to search GHC trac, look at git history and maybe make a ticket if you want to find out why
02:56:57 <EvanR> so, you could make join be in the class with mutual default defs
02:57:23 <dminuoso> @let type family Flip x y
02:57:24 <lambdabot>  Defined.
02:57:26 <ongy> ok, thx. I'll go and look into that. But that explains why they aren't optimised away
02:57:26 <dminuoso> @let type instance Flip x y = (y, x)
02:57:27 <lambdabot>  Defined.
02:57:30 <dminuoso> @let instance Functor (Flip a) where fmap = undefined
02:57:31 <lambdabot>  .L.hs:162:10: error:
02:57:31 <lambdabot>      • The type family ‘Flip’ should have 2 arguments, but has been given 1
02:57:31 <lambdabot>      • In the instance declaration for ‘Functor (Flip a)’
02:57:45 <dminuoso> Mmm. I expected this to work. :(
02:58:08 <ertes-w> dminuoso: well, you do have 'join'…  it's just that (>>=) is the better *primitive* =)
02:58:51 <ertes-w> dminuoso: in fact you can probably replace many 'concat's by 'concatMap's =)
03:00:52 <reygoch> Does anyone have experience working with selda db library?
03:01:18 <reygoch> I'm havig some trouble defining more generic functions for common read / write operations.
03:01:48 <reygoch> I don't quite understand how to set up type constraints so that compiler stops nagging.
03:02:10 <reygoch> I've oppened an issue here : https://github.com/valderman/selda/issues/65
03:02:30 <reygoch> Last comment is what is currently bugging me
03:24:41 <phz_> QueryError {qeMessage = "execute resulted in Col 1-column result", qeQuery = "SELECT 'persist ping'"}
03:24:52 <phz_> the more I use persistent, the less I want to recommend it
03:30:59 <ongy> mpickering: for reference: https://ghc.haskell.org/trac/ghc/ticket/3207 seems to be the reason.
03:32:52 <mpickering> ongy: Does that satisfy you?
03:34:29 <ongy> it explains how it happens, even if I'm not the biggest fan of how this is done. And I can see in the code where the reads come from. So yea, pretty fine with this.
03:37:31 <dminuoso> Mmm. Why cant I use type families like I tried above?
03:41:23 <Boomerang> dminuoso: Do you need it to be a type family? Why not just a newtype? https://hackage.haskell.org/package/bifunctors-5.5.2/docs/Data-Bifunctor-Flip.html#t:Flip
03:43:00 <dminuoso> Boomerang: Well Im playing around with type families, so! :-)
03:45:07 <Guest85076> hi I am trying to implement blake2 using haskells cryptonite library , not able to get how to use it any documention or examples?
03:50:12 <guest_>  I am trying to implement blake2 using haskells cryptonite library , not able to get how to use it any documention or examples?
03:55:11 <cocreature> guest_: take a look at https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Tutorial.html#g:2 if you replace SHA256 by one of the blake versions in https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-Hash-Algorithms.html#t:Blake2b you should get what you want
03:56:43 <cocreature> guest_: if you want a longer introduction, take a look at https://www.fpcomplete.com/blog/2017/09/cryptographic-hashing-haskell
04:06:50 <mbrock> I can't figure out how to get the "Unspaced" or "Unlined" things ("parser transformers") in the `parsers` library to have any effect...
04:07:33 <mbrock> putting `runUnspaced (Unspaced x)` around the terms in my expression parser, I can still parse "1 + 2", but I only want to allow "1+2"
04:07:54 <AWizzArd> Do we have anyone from Tweag here? Or someone who knows https://github.com/tweag/sparkle ?   I wonder why it still is marked as tech preview, not ready for production.
04:08:23 <AWizzArd> They applied hundreds of patches and worked on it for over two years. And we’re talking Haskell here. So I am just curious why it is not ready yet.
04:12:00 <quchen> Hmmm I don’t know any Tweag folks here. Matthieu is on Reddit though.
04:12:23 <quchen> mboes, I believe.
04:12:31 <Boarders> what does it mean when I have a type like text-1.2.2.2:Data.Text.Internal.Text in ghci?
04:12:40 <cocreature> I suspect they just forgot to remove the preview disclaimer
04:13:40 <quchen> Boarders: It’s from a transitive dependency, not from one directly mentioned in your .cabal file
04:14:07 <Boarders> ok makes sense, thanks
04:32:09 <lyxia> mbrock: your parser should be polymorphic enough so you can write "runUnspaced myExprParser"
04:33:15 <lyxia> mbrock: http://lpaste.net/362493
04:36:03 <EvanR> in linear haskell-like linear types, where the multiplicity is on the function arrow, you must "consume" the argument exactly once... but im having trouble predicting what counts as consuming and what doesnt. for instance, what if i write the bound variable once in an inner lambda, like the argument to map
04:36:08 <EvanR> is that consuming
04:36:14 <EvanR> if so, once?
04:36:50 <cocreature> EvanR: have you seen the proposal? it defines what that part means
04:36:57 <EvanR> i am rereading it now
04:37:16 <EvanR> but it doesnt say anything about closuring
04:37:26 <cocreature> “Consuming a value of a data type exactly once means evaluating it to head normal form exactly once, then consuming its fields exactly once”
04:37:39 <cocreature> “Consuming a function exactly once means applying it and consuming its result exactly once”
04:37:55 <heptahedron> linear types come up again?
04:38:24 <dminuoso> ertes-w: Earlier you said that a ByteString "pins" the underlying memory. What exactly does that mean?
04:38:27 <EvanR> well, with lazy evaluation, using it inside a mapped lambda could evaluate it exactly once (talking about like, an Int here)
04:38:40 <EvanR> even though the function is then applied many times
04:38:42 <cocreature> EvanR: can you give some concrete example? I’m not entirely sure I’m following what you’re saying
04:38:55 <EvanR> let this outer lambda be a linear function
04:39:09 <EvanR> (\x -> map (\y -> y + x) [1,2,3,4])
04:39:25 <EvanR> would that check
04:39:52 <heptahedron> If I have a type-level tuple of the kind `(a, b)`, is there a way using a type family and constraint kinds to write something that will accept some `f :: (b -> Constraint)` and give me a `g :: (a, b) -> Constraint`?
04:40:11 <cocreature> EvanR: ah I see what you’re getting at, let me think about it :)
04:40:27 <Boarders> if I am using a library with some newtype is there any way I can automatically generate unwrappers if the library itself doesn't have them?
04:40:38 <EvanR> theres a regular and linear map... so not sure if that has to factor in
04:40:50 <ertes-w> dminuoso: one of the purposes of ByteString is to communicate safely with foreign code, which means that a ByteString needs to have a consistent address
04:41:39 <ertes-w> dminuoso: in haskell values can and do move around in memory, so there is no notion of "the memory address of x"
04:42:02 <EvanR> there can be a notion of "stable name" but even that is tricky
04:42:27 <ertes-w> dminuoso: (in GHC haskell that is)
04:42:44 <EvanR> i havent had my coffee yet so i dont remember if names and addresses are different
04:42:56 <dminuoso> ertes-w: Ah. So you're referring to the fact that a ByteString has an underlying ForeignPtr?
04:43:16 <ertes-w> dminuoso: yeah
04:44:19 <ertes-w> dminuoso: (that's a bit inaccurate, but you get the idea)
04:44:43 <Boarders> is the above something that the newtypes library does?
04:45:45 <EvanR> cocreature: i am trying to trivially add linear types to my core language, and i was wondering if i could simply just count the number of occurrences of the free variable in the body >:D
04:45:49 <EvanR> and make sure its 1
04:45:58 <EvanR> er bound variable
04:46:23 <heptahedron> EvanR: wouldn't that trivially fail for something like `if True then a else a`?
04:46:34 <EvanR> yes
04:46:36 <dminuoso> ertes-w: Ahh. It happens to be mentioned in https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Short.html
04:46:44 <EvanR> aiui that should fail
04:46:47 <cocreature> EvanR: hm I’m honestly not sure if that would typecheck. I’d say no but it might be worth asking on the proposal
04:47:04 <heptahedron> Oh, I don't have the firmest notion of linear types
04:47:15 <EvanR> me neither
04:47:28 <EvanR> but i got a taste so now im hooked
04:47:58 <heptahedron> I'm currently playing around with vinyl and having a great time. I can't remember who recommended it to me on here but thanks
04:48:14 <heptahedron> Actually it was probably cocreature
04:48:35 * cocreature hides and looks innocent
04:49:02 * ertes-w always knew that cocreature is evil
04:49:31 <heptahedron> No really, it's super useful, I was able to write some newtype wrappers so I could have autogenerated to/fromjson instances for the absurd api of Discord
04:50:26 <heptahedron> Buuuuut now I understand that some of the fields might not only be null, but simply gone, which begat (?) another datatype and the accompanying implementation of instances
04:50:40 <EvanR> so wait, "consuming" is defined inductively right, and the base case is... for stuff like Int, its consumed when its evaluated
04:51:20 <EvanR> so uh... because of lazy evaluation cant you just write the variable everywhere you want? itll be (fully) evaluated at most once...
04:51:52 <EvanR> i just realized i dont get how this interacts with haskell
04:53:11 <EvanR> heptahedron: in the future, API autogenerators will themselves be autogenerated, and well be out of a job
04:54:20 <cocreature> EvanR: “linear variables are removed from the environment when they are evaluated” seems like it might relate to your question
04:55:03 <heptahedron> EvanR: I sincerely wish Discord had autogenerated this api, then the documentation might be the slightest bit coherent
04:56:10 <EvanR> ok
04:56:42 <cocreature> I really need to stop procrastinating by thinking about linear types
04:56:43 <EvanR> so whenever it is evaluated, whenever that is, if there is some other location in the code that logically has it... that would be broken
04:57:00 <EvanR> and should be disallowed
04:57:05 <heptahedron> EvanR: I know one of the often-touted use-cases for linear types is in network protocols, where the textbook example is binding a socket
04:57:17 <EvanR> i saw that example
04:57:31 <EvanR> basically a language to talk about terrible low level APIs
04:58:01 <heptahedron> So if the variable were able to be "consumed" in any two different places, it's possible that a socket that had already been bound would be accidentally misinterpreted as still free
04:58:40 <heptahedron> I didn't have anywhere specific I was going with that but I hope the conflict there helps guide your intuition as to what would(n't) be allowed by a linear type system
04:59:15 <EvanR> so during type checking, or at some stage, youd look at a variable and conclude it doesnt even exist (because it was already considered in some way earlier in the process)
04:59:28 <EvanR> but counting the occurrences seems "too simple to be right"
05:00:11 <heptahedron> EvanR: something tells me it might be more readily apparent if the program was converted to CPS prior to making this analysis
05:00:39 <EvanR> i guess
05:00:52 <EvanR> because then things happen one at a time
05:01:40 <heptahedron> I also suspect that the `if True then a else a` case /wouldn't/ be disallowed by linear types, but I'd need someone more knowledgeable to confirm that
05:02:50 <heptahedron> Because, relying upon that socket example, if both branches of that expression consumed the free socket once and yielded a bound socket, the whole expression would yield a bound socket and the argument wouldn't be inadvertently consumed more than once
05:03:12 <EvanR> oh, thats basically a two branch case
05:03:25 <EvanR> consuming it in each branch is ok (required)
05:04:04 <heptahedron> which is what led me to believe that CPS would make it easier to analyze this, because that's two different suspended computations
05:04:47 <heptahedron> both of which would contain exactly one reference to the linear expression under consideration
05:05:17 <EvanR> according to the paper though it seems to downplay the "number of references" reasoning angle
05:05:41 <EvanR> if your linear function recieves a value, you cant assume this is the only reference to it
05:06:21 <cocreature> that would be uniqueness types
05:06:28 <heptahedron> I should probably just stop speculating about these things I'm so unfamiliar with lol
05:06:39 <mbrock> lyxia: thanks :) I got it working
05:08:58 <EvanR> uniqueness/ownership is like, dual to linear types
05:08:59 <EvanR> somehow
05:10:44 <heptahedron> that's interesting
05:10:52 <jeee> test
05:11:55 <CritJongUn> can someone explain me "newtype" in comparison to "type" and "data"? The learn you a haskell isn't cutting it
05:12:59 <heptahedron> CritJongUn: `newtype` allows you to wrap a type opaquely such that the compiler doesn't know anything about the type "beneath" it
05:13:42 <CritJongUn> heptahedron: but what is the advantage? is it so that i have two "different" types?
05:14:03 <ongy> Can I do something (stupid) to figure out if the specialised version of my function, or the overloaded one is actually used in my code? The problem is, the call is accross modules, not properly inlined and going over a typeclass, so I'd like to see if the attached rule is actually used, or if it defaults to the generic one
05:14:14 <heptahedron> CritJongUn: Have you covered Monoids yet? If not, it's fine, but there's an example there if you have
05:14:30 <cocreature> CritJongUn: in terms of syntax newtype can only have a single constructor with a single field. in terms of semantics newtype has the exact same runtime representation as the underlying type, whereas "data" has a level of indirection. in particular that means that evaluating the constructor doesn’t necessarily evaluate the underlying value while for newtype it always will
05:14:58 <tdammers> ongy: Debug.Trace?
05:15:09 <CritJongUn> heptahedron: i started doing the monad challenges because i couldn't get on with anything related with Monads, Monoids and Functors, so I'm not really sure if I covered them
05:15:21 <ongy> tdammers: oh, it's not my explicit rule, it's a {-# SPECIALIZE #-} pragma
05:16:06 <heptahedron> CritJongUn: Monoids are pretty easy--they're basically just any type that can be glued to other instances of itself and for which there's some term that, when glued to any other term, just gives you back that other term
05:16:14 <ongy> I can see in the core that the proper functions are generated, but the call is with MonadIOIO into the typeclass. And in the other module I have 2 functions, one spezialised one not. And I don't see how exactly it would determine which to use
05:16:42 <CritJongUn> heptahedron: can you give a more concrete example?
05:17:13 <heptahedron> CritJongUn: Think strings. You can concatenate strings together like `("foo " ++ "bar")` (gluing together). There's also an empty string, and if you glue that to either side of any other string, you'll always get the other string back. `("foo" ++ "") == ("" ++ "foo") == "foo"`
05:17:20 <tdammers> ongy: you can still put a `trace` in the specialized code, can't you?
05:17:37 <heptahedron> yikes I abused notation there but you get the point I hope
05:17:52 <ongy> I don't have any explicit code that's spealised. Unless I can inject that into the function in core. Both are generated from the same haskell code
05:18:19 <CritJongUn> heptahedron: so numbers in general count as Monoids? since you can glue them together by sum and 1+0 == 0+1 == 1
05:18:20 <CritJongUn> ?
05:18:26 <heptahedron> CritJongUn: brilliant, yes
05:18:38 <heptahedron> CritJongUn: but is that the only way you can think of gluing them together?
05:18:53 <kuribas> can you turn a traverse into a fold?
05:19:00 <CritJongUn> heptahedron: you can multiply, does that count as glue?
05:19:05 <kuribas> > Sum 1 <> Sum 2
05:19:06 <lambdabot>  Sum {getSum = 3}
05:19:09 <CritJongUn> heptahedron: and so on
05:19:29 <cocreature> heptahedron: tbf you could also get the different instances by wrapping things in "data" so I’m not sure that’s particularly helpful for explaining the difference
05:19:40 <heptahedron> CritJongUn: It does, yes
05:19:45 <heptahedron> cocreature: ah you have a point
05:20:18 <CritJongUn> heptahedron: so gluing with be any function that takes the one type and returns that type?
05:21:04 <CritJongUn> meanwhile, back on the newtype. i have this: type Gen a = Seed -> (a, Seed)
05:21:08 <cocreature> the difference is really the fact that there is zero runtime overhead which implies that the constructor (which doesn’t even exist at runtime) is strict
05:21:12 <heptahedron> CritJongUn: aaaaaaah, no. But close. It probably aligns pretty closely with what you think of with the term "gluing"--there are some laws by which all Monoids have to abide, but they're not tough
05:21:27 <CritJongUn> and i need to create a newtype
05:21:46 <CritJongUn> and from what i read so far, even from a solution i should do
05:21:51 <CritJongUn> newtype Gen a = Gen { runGen :: Seed -> (a, Seed) }
05:22:01 <CritJongUn> but i'm not quite getting the point of it
05:22:14 <heptahedron> CritJongUn: You can imagine that you might want to use either the Sum monoid for numbers or the Product monoid at different times, but it would be pretty lame if you incurred a performance penalty just for telling the type system you wanted addition or multiplication to be the behavior of your `mappend` operation
05:22:42 <CritJongUn> and looking at the challenge now they dont quite say why
05:24:40 <CritJongUn> heptahedron: looking and the Prelude docs, i see what a mappend is but not the mempty
05:25:26 <CritJongUn> heptahedron: since the association is the rule, i'm guessing theres no Subtraction or Division monoid?
05:26:04 <ongy> CritJongUn: mempty is from Data.Monoid
05:26:13 <heptahedron> CritJongUn: `mempty` is just like the empty string, or 0 for addition, or 1 for multiplication. It's essentially an identity element, some inhabitant of the type for which, for any `a`, `mempty <> a == a` and `a <> mempty == a`
05:27:16 <EvanR> CritJongUn: the point of that Gen a thing to me seems to be, so you wouldnt have to keep saying (Seed -> (a,Seed)) everywhere
05:27:17 <CritJongUn> ongy: oh sorry, thought prelude would be the std lib in full
05:27:18 <heptahedron> CritJongUn: You are correct in your guesses, but although a Division monoid could not exist because of the associativity law, as you noted, the problem with a theoretical Subtraction monoid would be that it would either break left or right identity
05:27:37 <CritJongUn> EvanR: I understand the point of the type but not of the newtype
05:27:48 <EvanR> with the newtype you can attach instances
05:28:02 <kuribas> > foldlOf traverse (+) 0 [1, 2, 5, 4]
05:28:04 <lambdabot>  12
05:28:11 <EvanR> if it was a type youd have to attach instances to -> instead, which is odd
05:28:11 <ongy> CritJongUn: Prelude is commonly used things, that will be pulled into your scope by default. It's by far not everything in base. And I wouldn't even call base the comprehensive standard libs :)
05:28:24 <CritJongUn> EvanR: AH! i kinda understand now
05:28:37 <EvanR> yeah
05:28:44 <heptahedron> nice!
05:28:59 <EvanR> it adds a runtime cost-free abstraction layer
05:29:37 <CritJongUn> alright! i think i get it now just one detail left
05:29:47 <CritJongUn> the function in the record
05:29:57 <CritJongUn> newtype Gen a = Gen { runGen :: Seed -> (a, Seed) } : the runGen
05:30:10 <CritJongUn> what is it supposed to do/represent
05:30:17 <EvanR> its the field accessor
05:30:18 <heptahedron> CritJongUn: That's what gets you the original type from the newtype
05:30:23 <ongy> 1.4M compile log to sieve through for rules? well, someone got a diving equipment for me? :)
05:30:33 <CritJongUn> heptahedron: the "a"?
05:30:40 <heptahedron> so if you have some `Gen a`, `runGen` will get you the `Seed -> (a, Seed)`
05:30:41 <EvanR> runGen :: Gen a -> Seed -> (a, Seed)
05:30:54 <heptahedron> CritJongUn: It's a function that has the type following the double colon
05:31:00 <EvanR> and you can use it in update syntax myGen { runGen = foo }
05:31:07 <heptahedron> oh god really?
05:31:14 <CritJongUn> heptahedron: that bit i got xD
05:31:27 <EvanR> heptahedron: almost...
05:31:37 <EvanR> @src Sum
05:31:37 <dminuoso> CritJongUn: the `a` comes from the type constructor of the life side.
05:31:37 <lambdabot> newtype Sum a = Sum { getSum :: a }
05:31:39 <EvanR> :t getSum
05:31:40 <lambdabot> Sum a -> a
05:31:42 <dminuoso> CritJongUn: It's for some `Gen a`
05:32:01 <CritJongUn> i get that guys but what i dont understand is
05:32:10 <heptahedron> CritJongUn: Note that it's not critical to include that accessor function--if you wanted, you could always get the inner type by pattern matching against the newtype
05:32:32 <CritJongUn> compared to Sum the runGen needs to receive something, it's a function while the getSum is a "variable"
05:32:50 <EvanR> no getSum is a function too
05:32:59 <CritJongUn> also, for such type why don't i need to implement it
05:33:03 <EvanR> the input is not mentioned in the record syntax
05:33:36 <CritJongUn> so the Gen a -> Seed -> (a, Seed) you mentioned is the actual type
05:33:38 <CritJongUn> of runGen
05:33:40 <EvanR> yep
05:34:05 <EvanR> its a field projector
05:34:10 <heptahedron> oh I might have confused you with my poor wording earlier, sorry about that
05:34:18 <CritJongUn> ah, because Gen a == Seed -> (Seed, a)
05:34:31 <EvanR> well, because of that, its also an unwrapper
05:34:32 <CritJongUn> runGen applies the second arg to the first
05:34:38 <EvanR> but for bigger records that gets you one of the fields
05:34:40 <CritJongUn> to get the (Seed, a)
05:34:55 <EvanR> no runGen just gets the Seed -> (a, Seed) out
05:35:05 <CritJongUn> heptahedron: what leads you to think that
05:35:05 <EvanR> but you can chain the arguments, runGen myGen seed
05:35:18 <EvanR> thats the same as (runGen myGen) seed
05:35:40 <EvanR> or to be cutesy, myGen `runGen` seed
05:35:57 <heptahedron> CritJongUn: I said "It's a function that has the type following the double colon", but that's the return type. So, as EvanR said, the actual type of the function `runGen` is `Gen a -> (Seed -> Seed, a)`
05:36:08 <CritJongUn> i'm a bit confused, i'll think about the subject
05:36:17 <EvanR> Gen a -> (Seed -> (Seed, a))
05:36:19 <CritJongUn> heptahedron: ah, no problem i got it
05:36:21 <heptahedron> Thanks EvanR
05:36:28 <heptahedron> didn't notice the mistype lol
05:36:59 <heptahedron> CritJongUn: I put some parentheses there to maybe help you disambiguate what's going on, but by convention we typically omit the ones that are on the far right of the function signature like that, because it's no different
05:37:21 <CritJongUn> i just didnt get what "get the type out" is supposed to mean for Gen since get itself represents somekind of function
05:37:24 <EvanR> haskell signed the parentheses conservation agreement
05:37:32 <heptahedron> lol
05:37:52 <EvanR> CritJongUn: well, a function is just another value
05:37:54 <EvanR> (tm)
05:38:13 <EvanR> that fact gets a lot of mileage, i am still not sure i know how much
05:39:00 <dminuoso> CritJongUn: The idiom `data Q = Q { runQ :: ... }` is relatively common. Though strictly speaking you can also use pattern matching to deconstruct a Q, though `runQ` is also a function (and thus can be used in combinators/functional composition.
05:39:05 <EvanR> a record full of functions is a passable way to do object oriented programming (of sorts) in haskell
05:39:11 <CritJongUn> well, thank you guys for your endless patience, if it werent for you i don't know if i would be still learning haskell
05:39:37 <CritJongUn> i'm going to think about it thank you
05:40:23 <heptahedron> go bother your friends about it until they too come into the light of a real type system
05:40:47 <heptahedron> or tire of your daily rants
05:40:51 <Darwin226> I need a function to URL encode a bytestring that's ASCII encoded text. Anyone know where I could find something like that? Seems like all the url encoders assume UTF-8 bytestrings
05:41:04 <tdammers> EvanR: almost, yes. Records of functions cover "bundle state with behavior", but you need some additional tricks to get "call methods on yourself" in a convenient way
05:41:19 <EvanR> yeah that part is a biotch
05:41:21 <heptahedron> Darwin226: ASCII is a subset of UTF-8, unless I'm mistaken
05:41:28 <tdammers> heptahedron: yes, it is
05:41:35 <EvanR> a url encoder that assumes utf8 will work on ascii
05:41:41 <tdammers> *BUT*
05:41:44 <Darwin226> Not really
05:41:53 <Darwin226> not 7bit ascii
05:41:59 <Clint> ASCII is 7-bit ASCII
05:42:05 <EvanR> thats... what ascii is
05:42:21 <Darwin226> Ok then, sorry about using the wrong terminology
05:42:32 <heptahedron> Darwin226: Do you mean like ISO-8859-1 or something maybe?
05:42:36 <Darwin226> the BS is encoded in a particular codepage
05:42:38 <Darwin226> yeah
05:42:39 <tdammers> when people say "ASCII", they sometimes mean "an unspecified 8-bit superset of ASCII"
05:42:45 <heptahedron> ah there's the problem
05:42:46 <EvanR> oh gross
05:42:48 <Clint> they should stop meaning that
05:42:55 <Darwin226> third-party API...
05:42:58 <tdammers> they definitely should
05:43:04 <EvanR> determine the encoding, then undo it
05:43:23 <tdammers> but anyway, if that's what you're getting, then the encoding should be specified somewhere, typically as part of the Content-Type header
05:43:46 <tdammers> so decode the bytestring according to that encoding, which will give you a String or Text, and then URL-encode that
05:44:04 <Boomerang> Sometime people actually mean Extended ASCII which is 8 bit but not a subset of UTF8 as far as I can remember
05:44:23 <Clint> i hope it's VISCII
05:44:28 <tdammers> Boomerang: that's just another incorrect name for 8-bit codepages
05:44:36 <heptahedron> where is the love for EBCDIC
05:44:46 <tdammers> heptahedron: which one of them
05:44:57 <heptahedron> tdammers: reader's choice
05:45:00 <Darwin226> tdammers: That doesn't work with this API
05:45:25 <Darwin226> It expects Windows-1250 and doesn't care about the content-type
05:45:35 <heptahedron> Darwin226: my condolences
05:45:49 <Darwin226> You don't know the half of it...
05:46:01 * EvanR looks at the iconv library for haskell
05:46:04 <tdammers> Darwin226: *expects*? you said you wanted to URL-encode from a bytestring, but this would be the other way around?
05:46:16 <Boomerang> tdammers: I thought there was an official definition for extended ASCII. Looks like I was wrong :o
05:46:28 <tdammers> Boomerang: there is. It's called Unicode. :x
05:46:43 <EvanR> extended ascii, its officially the one that looks like dwarf fortress
05:46:44 <Boomerang> Right, for the 8 bit extended ascii
05:46:45 <EvanR> use that one
05:47:14 <EvanR> music note, square root, smiley face
05:47:45 <Darwin226> tdammers: I have a BS that I want to URL encode (into an ASCII string, probably of type Text) and then I need to send that string to the third-party API
05:47:52 <EvanR> iconv looks promising for dealing with legacy encodings
05:48:46 <Clint> Darwin226: so why do you need to convert the character encoding at all?
05:49:07 <Darwin226> Clint: I don't understand the question.
05:49:08 <tdammers> Darwin226: you can't do that. URL-encoding, by definition, produces 7-bit ASCII
05:49:31 <Darwin226> Concretely, I need č to encode into a sincle %something instead of %something%somethingelse
05:49:36 <Darwin226> single*
05:49:43 <heptahedron> Clint: I believe they're trying to leverage existing url-encoding libs by way of first encoding to something they accept
05:49:59 <Clint> so your bytestring is already in utf-8 and you want to convert it to windows-1250
05:50:05 <tdammers> Darwin226: ah, so your percent encodings need to be based on windows-1250
05:50:11 <Darwin226> Yeah
05:50:35 <Darwin226> for example, https://docs.oracle.com/javase/1.5.0/docs/api/java/net/URLEncoder.html
05:51:04 <Darwin226> They have a function that url encodes strings, but it also asks you in which text encoding you want them
05:51:26 <tdammers> yes, that's because it URL-encodes string, not bytestrings
05:51:48 <tdammers> a string doesn't have any specific encoding (it has one under the hood, but this is transparent)
05:51:55 <Darwin226> I guess I just brought in more confusion by mentioning bytestrings at all
05:52:00 <Darwin226> I though it would simply the question
05:52:05 <tdammers> no no, that's quite alright
05:52:12 <Darwin226> simplify*
05:52:14 <tdammers> you just need to be clear about things
05:52:34 <tdammers> particularly, the fact that bytestrings are sequences of bytes, while strings / texts are sequences of code points ("characters")
05:52:54 <tdammers> so a string is just a string, it doesn't have any particular encoding
05:52:59 <tdammers> it's just a sequence of codepoints
05:53:33 <Darwin226> There are plenty of url encoding functions out there that do ByteString -> whatevertheurltypeis
05:53:47 <tdammers> yes
05:53:48 <Darwin226> and they all assume the BS is UTF8 encoded as far as I can tell
05:53:51 <phadej> (disclaimer: someone you want text to be sequence of graphemes, which is more in align with that "character" is understood as)
05:53:52 <tdammers> no
05:53:54 <Darwin226> hmmmm
05:53:57 <Darwin226> riiiiight
05:54:03 <tdammers> they ignore the encoding completely
05:54:15 <Darwin226> Wow
05:54:17 <tdammers> that's because percent-encoding is a bytewise thing
05:54:22 <tdammers> it's super simple
05:54:27 <Darwin226> I can't believe I didn't see that
05:54:27 <EvanR> dont you mean grapheme clusters lol
05:54:50 <phadej> EvanR: I don't know, its so complicated I stay away from it
05:54:53 <EvanR> haha
05:54:57 <Darwin226> Yeah, it makes sense now. I should be able to use any of those functions then
05:55:02 <tdammers> anything that's in the "whitelist" is kept as-is, any other byte is converted into a percent sequence
05:56:07 <tdammers> so you need two functions: Text -> ByteString, and ByteString -> URL
05:56:22 <tdammers> the first one also needs to take the desired encoding into account
05:56:43 <tdammers> but the second one, the actual URL-encoding, doesn't
05:57:03 <Darwin226> Yeah, for some reason I was under the impression that those BS -> URL functions were just convenience functions that UTF decode the BS into Text and then do something on a char-by-char basis
05:57:25 <Darwin226> When in fact url encoding works on bytes
05:57:29 <tdammers> indeed
05:57:44 <Darwin226> Cool
05:57:45 <Darwin226> Thanks
05:58:36 <tdammers> fwiw, I think the fact that Haskell has separate types for strings and bytestrings is pretty useful
05:58:59 <phadej> tdammers: better to talk for text and bytestrings :)
05:59:18 <phadej> and in lowercase ;)
05:59:34 <phadej> texts*
06:00:00 <opqdonut> it would be so nice if ByteString was called Bytes
06:00:14 <phadej> that ship have sailed :/
06:01:04 <ventonegro> ABunchOfBytes
06:01:48 <kuribas> opqdonut: or bytebuffer
06:02:08 <danza> opqdonut, i agree Bytes would be cool :)
06:02:19 <kuribas> lazy = bytestream
06:02:55 <opqdonut> yeah Bytes & ByteStream would be pretty nice
06:03:01 <Darwin226> Damn, seems that ToHttpApiData doesn't actually let me to my own encoding...
06:03:54 <phadej> there s toEncodedUrlPiece
06:04:07 <phadej> if you want to encode url fragment in own way
06:04:15 <Darwin226> Yeah, but it's supposed to be used for faster implementations
06:04:28 <Darwin226> not for semantically different ones
06:04:46 <Darwin226> I mean, it will probably still work...
06:05:51 <phadej> depends on the downstream of http-api-data
06:06:26 <phadej> servant-client probably uses toEncodedUrlPiece, but I'm not sure
06:06:47 <phadej> (that it doesn't use toUrlPiece anywhere)
06:06:56 <Boarders> I'm trying to use something which takes a filePath and getting:
06:07:09 <Boarders> "*** Exception: ~/testDir/example.txt: openBinaryFile: does not exist (No such file or directory)"
06:07:25 <Cale> Boarders: It's the ~
06:07:36 <tdammers> agree, the "String" part in "ByteString" is misleading
06:07:55 <Boarders> Cale: oh do I need like \~ or something?
06:08:01 <Cale> Boarders: That's not a real filepath -- usually your shell replaces that with the value of $HOME, but programs need to do that themselves.
06:08:04 <phadej> Boarders: ~ is shell thing
06:08:14 <Boarders> oh ok thanks
06:08:15 <quchen> Disagree, the »string« in »string« is misleading
06:08:29 <kuribas> is foldlOf black magic that should be avoided?
06:08:31 <Boarders> how would I refer to my home directory?
06:08:38 <phadej> quchen: i sympathize
06:08:42 <quchen> »CharString« would be much better.
06:08:51 <Boarders> do I just have to give an absolute path to it?
06:08:52 <EvanR> quchen: well, string in math is like ... a vector
06:09:03 <phadej> EvanR: :D
06:09:04 <EvanR> of whatever
06:09:22 <quchen> I’ve never heard of math strings
06:09:35 <phadej> vector is luckily so overloaded word that many checks what it means in the language
06:09:37 <EvanR> i saw a lot of bit strings
06:09:41 <Cale> Boarders: You have to give an absolute path. You can get it from the environment using something like getEnv/lookupEnv
06:09:48 <Cale> (from System.Environment)
06:09:53 <Boarders> cool thanks
06:09:56 <tdammers> and a vector in math is like a tuple :P
06:09:59 <EvanR> yeah if you call something vector you have a high chance of being accepted
06:10:14 <phadej> getHomeDirectory
06:10:23 <phadej> https://hackage.haskell.org/package/directory-1.3.2.0/docs/System-Directory.html#v:getHomeDirectory
06:10:26 <Cale> Oh, does that exist? Nice.
06:10:38 <phadej> yes, there also documents and xdg and stuff
06:10:41 <phadej> use them, please.
06:10:45 <Cale> That's probably much better, yes.
06:10:46 <quchen> A vector in math is much more than tuples
06:10:50 <tdammers> heh, TIL - I've been using getEnv "HOME" so far, but obviously that isn't cross-platform
06:11:57 <quchen> e^(-x²) isn’t much of a tuple, but it’s a vector
06:12:43 <quchen> Bytestring is spot on if you ask me – a string of bytes
06:13:09 <EvanR> what it says on the tin
06:13:27 <quchen> (And vectors are forall a.a strings) ;-)
06:14:05 <EvanR> TIL a passable definition of bottom is forall a . a
06:14:25 <EvanR> er, of an empty type
06:14:28 <phadej> for Void
06:14:30 <phadej> yes
06:14:33 <quchen> That sentence wasn’t very formal ;-)
06:14:57 <phadej> `newtype Void = Void Void` is nice too.
06:15:13 <phadej> but luckily we have EmptyDecls
06:15:25 <quchen> \o/
06:16:01 <phadej> :t let x = x in x
06:16:02 <lambdabot> t
06:16:10 <phadej> (i.e. forall t. t)
06:18:39 <dminuoso> What is the reason I cant do this?
06:18:40 <dminuoso> @let type family Flip x y
06:18:41 <lambdabot>  .L.hs:162:1: error:
06:18:41 <lambdabot>      Multiple declarations of ‘Flip’
06:18:41 <lambdabot>      Declared at: .L.hs:158:1
06:18:42 <dminuoso> @let type instance Flip x y = (y, x)
06:18:43 <lambdabot>  Defined.
06:18:46 <dminuoso> @undef
06:18:46 <lambdabot> Undefined.
06:18:48 <dminuoso> @let type family Flip x y
06:18:49 <lambdabot>  Defined.
06:18:50 <dminuoso> @let type instance Flip x y = (y, x)
06:18:51 <lambdabot>  Defined.
06:18:53 <dminuoso> @let instance Functor (Flip a) where fmap = undefined
06:18:54 <lambdabot>  .L.hs:162:10: error:
06:18:54 <lambdabot>      • The type family ‘Flip’ should have 2 arguments, but has been given 1
06:18:54 <lambdabot>      • In the instance declaration for ‘Functor (Flip a)’
06:19:14 <quchen> Paste it and use ?letlpaste.
06:19:20 <Cale> Well, for exactly the reason given
06:19:22 <byorgey> dminuoso: type families must always be fully applied.
06:19:34 <dminuoso> quchen: Ah I was not aware, thank you.
06:20:20 <Cale> If it was a data family, you could sidestep that restriction
06:20:34 <Cale> @undefine
06:20:34 <lambdabot> Undefined.
06:20:42 <byorgey> dminuoso: the reason for the requirement that they always be fully applied is that otherwise a lot of type inference goes out the window.  If you know   f a ~ g b,  then you can conclude  f ~ g  and  a ~ b.  But if type families could be partially applied, that is no longer true.
06:20:56 <Cale> @let data family Flip x y
06:20:58 <lambdabot>  Defined.
06:21:21 <Cale> @let data instance Flip x y = F y x
06:21:22 <lambdabot>  Defined.
06:21:38 <ij> If "data D = X { a :: B } | Y { b :: B }", could I collect all `b's from Ys of [D] with lens somehow, given that I've madeLenses?
06:21:57 <Cale> @let instance Functor (Flip a) where fmap f (F y x) = F (f y) x
06:21:58 <lambdabot>  Defined.
06:22:24 <phadej> ij: yes, toListOf (traverse . _Y) ds
06:22:26 <Gurkenglas> ij, listofds ^.. each . _Y
06:22:53 <Cale> (of course, this is a silly data family, given that we just wrote an instance that applies to every pair of arguments)
06:30:54 <Guest24452> hi. Is it correct to assume a Set is also a monoid under mempty and (\\)  ?
06:30:59 <tabaqui> what a heck is going here: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-176?
06:31:11 <tabaqui> and why "data [] a = MkNil"?
06:32:56 <Taneb> tabaqui: deep magic, those definitions are replaced by ones backed into the compiler
06:34:22 <tabaqui> actually, I was looking for List definition
06:34:48 <tabaqui> there are implemented deep in GHC with C, right?
06:34:55 <Cale> Not with C
06:34:58 <mud> tabaqui: IIUC it doesn't have a definition in haskell code that you can look at. It's too magical for that
06:35:43 <Cale> There's very little of GHC which is implemented in C, basically just the runtime system that's linked in (there's not much reason that's written in C apart from the fact that there's not much point in rewriting it)
06:35:44 <tabaqui> mud: IIUC?
06:35:57 <Taneb> tabaqui: "If I Understand Correctly"
06:36:10 <tabaqui> oh, thx :)
06:36:44 <Cale> There isn't much of a real reason that the definition isn't an ordinary data declaration apart from the fact that it uses special syntax.
06:37:27 <tabaqui> hm, okay then
06:38:01 <tabaqui> but isn't List the fastest structure for "cons" and "mapM_" operations?
06:38:59 <tabaqui> I'm trying to test some FRP framework to memory leaks
06:39:24 <c_wraith> depends on whether the list is being produced by a good producer
06:39:37 <tabaqui> and want to create huge collection and find O(n) memory consumption
06:40:03 <c_wraith> realizing every (:) constructor at runtime is a lot of allocation, compared to not doing so
06:40:52 <ij> Given the same [D] (defined 18 minutes ago here), how could I create [A] and [B] from [D] and (with the intention of folding them into a set afterwards)?
06:40:58 <Cale> tabaqui: There are a bunch of RULES pragmas that exist to eliminate intermediate lists created in various combinations of operations (primarily if the consumer is defined using foldr and the producer is defined using build)
06:41:13 <Cale> But other than that, there's not much which is magical about lists
06:41:22 <Cale> at runtime
06:41:43 <tabaqui> c_wraith: how should I prepend elements into a list?
06:41:54 <Cale> tabaqui: There's no way other than (:)
06:42:05 <tabaqui> brilliant
06:42:08 <c_wraith> be careful about that, though.  several list operations have rewrites to foldr or build only at specific stages of optimization
06:42:14 <tabaqui> maybe Data.Sequence is better?
06:42:18 <Cale> tabaqui: The thing is just that you might in some cases avoid building the list altogether
06:42:19 <ij> I could unpack them manually without lens, but I would like to see a lensful solution.
06:42:45 <Cale> Data.Sequence has (much) more overhead in exchange for much better asymptotics on splitting and concatenation
06:42:48 <c_wraith> So you can look up the definition and see "this doesn't use foldr/build", but not notice a rewrite rule that substitutes in a different definition during one optimization phase only.
06:43:55 <Cale> tabaqui: For example, consider, say, if you have something like  foldr f z (map g xs)
06:44:26 <Cale> tabaqui: It's possible to avoid constructing the intermediate list produced by map, and effectively transform that code into  foldr (f . g) z xs
06:45:02 <Cale> tabaqui: and that's what the RULES pragmas in GHC's implementation of the list library do
06:46:04 <tabaqui> foldR has the meaning here, right?
06:46:07 <tabaqui> not foldL
06:46:22 <c_wraith> foldl is written in terms of foldr
06:46:25 <Cale> Well, foldl would have a different rule, but you could obtain a similar result there
06:46:29 <Cale> yeah
06:46:50 <tabaqui> but you can avoid second list with foldl
06:47:00 <c_wraith> that's because it is written in terms of foldr
06:47:06 <tabaqui> because you can evaluate first element without the others
06:47:16 <tabaqui> in lazy haskell, I mean
06:47:28 <tabaqui> oh, sorry
06:47:29 <c_wraith> Err.  I think I've lost your meaning.
06:47:43 <ertes-w> is there an in-GHCi way to print the output of a TH action?  use case: instead of dropping 'makeLenses' into my code, i want to dump TH-generated lenses, so i can document them
06:47:52 <tabaqui> yeah, dunno what I was thinking :)
06:47:53 <Cale> foldl is more problematic under lazy evaluation generally, but you can still avoid the intermediate list produced by map
06:48:15 <tabaqui> hm, no, stop
06:48:26 <tabaqui> you do can evaluate foldl without second list in haskell
06:48:57 <Cale> foldl f z . map g = foldl (\acc x -> f acc (g x)) z
06:48:59 <tabaqui> *foldr
06:49:03 <tabaqui> right
06:49:16 <Cale> foldr f z . map g = foldr (f . g) z
06:49:18 <bbaren> ertes-w: :set -ddump-splices?
06:49:28 <tabaqui> and you don't need to write any specific functions for lists
06:49:36 <tabaqui> just use laziness
06:49:41 <Cale> I don't understand
06:49:47 <Cale> What do you mean?
06:50:15 <ertes-w> tabaqui: memory leaks in FRP frameworks are usually not that simple…  most are rather subtle and build up over time, often in a tension/release fashion
06:50:23 <tabaqui> oh, I try, but execuse me for my English
06:50:33 <Cale> There's just some particular rewrite rules which the compiler uses to simplify expressions involving functions on lists. They're part of the list library itself.
06:50:40 <ertes-w> bbaren: thanks…  i was hoping for something more direct, but it's good enough
06:50:44 <MarcelineVQ> ertes-w: there is a -ddump-splices  though I've not used it
06:51:08 <quchen> ertes-w: Not sure, but an easier solution is defining your own synonyms and only exporting those. Benefit: you get to both auto-generate the code and document it. »''makeLensesWithPrefix "generatedLensFoo"; foo = generatedLensFoo«
06:51:10 <tabaqui> when you reduce foldr-expression to WNF, you can evaluate elements one by one
06:51:31 <tabaqui> and you have no reason to reduce map-expression first
06:51:32 <MarcelineVQ> ertes-w: but they're probably in simpl form still you'd probably have ot translate
06:51:38 <tabaqui> just do it simultaneously
06:51:42 <quchen> FSVO makeLensesWithPrefix
06:52:29 <MarcelineVQ> bbaren: didn't see you had mentioned that hehe
06:52:40 <ertes-w> i guess i'll just keep writing my lenses by hand…  it's more or less the same effort, and it keeps my brain in eager evaluation mode =)
06:53:07 <tabaqui> ertes-w: but heaven thanks, any FRP network can be tested for leaks with 30 strings
06:53:26 <ertes-w> (a minor reason i like to avoid TH is that it splits my code)
06:53:51 <ertes-w> i don't like having to think where in the module to place the 'makeLenses'
06:55:28 <tabaqui> Cale, c_wraith: okay, looks like empirical approach is the last solution
06:55:32 <tabaqui> thanks
06:56:11 <c_wraith> I really don't like how long TH takes to launch just to create a couple lenses, especially given how easy they are to write by hand..
06:56:44 <EvanR> make some sed scripts instead :D
06:56:46 <c_wraith> take the time to write them by hand once, don't pay the TH load time
06:57:11 <EvanR> alternaively, cache the output of TH as regular code ?
06:57:22 <EvanR> like static site generators
06:57:44 <Cale> tabaqui: Well, yeah, laziness saves you *space* there, but the time spent on allocation is still a concern
06:57:59 <Cale> tabaqui: and so those rules exist to eliminate that
06:59:05 <ertes-w> i really wish we had anti-quotation syntax for strings
06:59:34 <Cale> What would that look like?
07:00:27 <Cale> also, this is pretty tangental, but have you seen my memey category-printf library? :)
07:01:16 <ertes-w> not sure…  just take inspiration from shells i guess:  "Database path (default: $(dataDir </> "db"))"
07:02:01 <Cale> Shells are not something I'd care to take inspiration from when it comes to syntax of anything, especially strings ;)
07:02:12 <ertes-w> i love the introduction
07:02:16 <ertes-w> "We use the co-Kleisli category for the comonad of functions out of a fixed monoid to implement a generic combinator library for type-safe format specifications."
07:02:17 <ertes-w> =)
07:02:33 <Cale> Ryan replaced some double quotes in a shell script with single quotes and it deleted his home directory
07:02:44 <ertes-w> ouch
07:02:48 <EvanR> classi
07:02:49 <EvanR> c
07:03:22 <ertes-w> yeah, i know what you mean…  i wouldn't take too much inspiration from shells either, but anti-quotation (if locked behind a LANGUAGE pragma) should be fairly safe
07:03:24 <Cale> (thankfully on a machine that didn't matter, but still...)
07:03:59 <ertes-w> perhaps even use a different string syntax for those
07:04:10 <Cale> I've done some simpler stuff along those lines with quasiquoters
07:04:28 <Cale> If you only want to substitute in variables, it's easy
07:05:08 <Cale> I made a few quasiquoters for use with postgresql-simple because I got tired of matching up the tuple of parameters and the ?'s in the query string
07:05:25 <ertes-w> Cale: any reason you're using Cokleisli as opposed to basic comonadic composition?
07:06:11 <ertes-w> Cale: sqlite-simple supports named placeholders…  maybe postgresql-simple supports something like that, too
07:06:25 <ertes-w> SELECT … WHERE blah = :blubb
07:06:52 <Cale> ertes: Well, it's just so that you can use (.) to compose the string formatters, I suppose.
07:07:51 <ertes-w> Cale: there is (=<=) for comonads
07:08:06 <ertes-w> i know it's not quite as sexy as (.)
07:09:11 <Cale> ertes-w: Well, sure.
07:09:16 <Cale> It'd amount to the same thing
07:09:45 <c_wraith> if you've already imported Control.Category, you might as well use it!
07:09:47 <Cale> But also, it really makes sense to think about the formatters as arrows
07:10:02 <dminuoso> byorgey: Ah I see. Thank you for the explanation.
07:10:03 <Cale> because the domain and codomain explain how the type of printf is changing
07:11:10 <ertes-w> Cale: yeah, you're one arrow away from boomerang =)
07:16:03 <sr10> http://lpaste.net/362496 i did. and now i wanted to implement it using maybe but i'm stucked at the start only n idk how to go about. I wanted to use maybe in validateMarksSubjects ::(b->  (StudentName,Bool,Maybe [(Subject,Marks,Bool,String)]) -> b ) ->b -> InputScore -> b                            using case of i was trying
07:16:43 <Cale> ertes: It was in fact inspired by a talk about continuation-style parsing of routes like that (which had some very unfortunate technical problems -- I think I was the only one in the room who followed it)
07:22:50 <Cale> ertes-w: There was an explanation of doing composition of formatters where Dan Patterson had something on his slide like (%) :: (String -> b -> c) -> (String -> a -> b) -> (String -> a -> c), and I thought "I bet that already exists as an instance of Category somewhere" and just had to figure out which
07:31:32 <ertes-w> Cale: well:  String -> a -> b ~ a -> String -> b ~ Kleisli (Reader String) a b
07:33:53 * ski was more thinking of `CoKleisli (String,)'
07:34:21 <kuribas> is there a strict version of foldlOf?
07:34:23 <kuribas> :t foldlOf
07:34:24 <lambdabot> Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
07:34:26 * ertes-w is not familiar with the functionality of (%)
07:34:32 <ertes-w> :t foldlOf'
07:34:33 <lambdabot> Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
07:34:44 <Cale> ertes-w: Yeah, you need to be aware also that it involves concatenation of the strings
07:34:47 <kuribas> ertes-w: ah, thanks!
07:35:10 <ertes-w> Cale: yeah, then Cokleisli makes more sense
07:35:19 <ski> Cale : really ?
07:35:43 <ertes-w> Cale: BTW, is there any advantage of doing this as opposed to simple concatenation?
07:35:54 <Cale> lol, no
07:36:08 <Cale> Well, it turns into a sort of cute stack-like language
07:39:51 <Cale> >>> printfLn (dup . s . " plus " . swap . dup . s . " equals " . apply2 (+) . s) 4 6
07:39:51 <Cale> 4 plus 6 equals 10
07:39:55 <Cale> ertes-w: ^^
07:40:06 <EvanR> you can program forth in any language
07:40:11 <EvanR> as long as its haskell
07:40:42 <Putonlalla> @hackage inline-everything
07:40:42 <lambdabot> http://hackage.haskell.org/package/inline-everything
07:40:44 <Cale> It's really remarkable how many ways forth pops up randomly in Haskell.
07:40:51 <Putonlalla> One day...
07:42:57 <ertes-w> Cale: yeah, it's cute, but not as short and readable as i would hope =)
07:43:18 <ertes-w> i guess i can extract educational value from it
07:44:02 <Cale> It's more something to laugh about than to use seriously. However, it is sort of nice that you can use this with Dynamic t Text and it all works the same
07:44:24 <Cale> printfWith dynText  ;)
07:44:28 <ski> Cale : is that basically `dup :: (a -> a -> r) -> (a -> r); dup x k = k x x', with some extra spice ?
07:44:45 <Cale> dup = arr (\k x -> k x x)
07:44:51 * ski nods
07:45:15 <ski> (ah, so continuation-first)
07:46:13 <ski> so something like `C (a -> a -> r) a r' ?
07:46:41 <Putonlalla> Looks like Hakyll fails to compile with `undefined reference to 'pthread_create'`. Any clues what might be to blame here?
07:46:49 <Cale> Well, our type is  Cokleisli ((->) m)  (for some monoid m)
07:47:24 <Cale> data Cokleisli w a b = Cokleisli (w a -> b)
07:47:29 <ski> how does that work for `apply2 :: (a -> b -> c) -> ((c -> r) -> (a -> b -> r)); apply2 f k a b = k (f a b)' ?
07:47:39 <Cale> also, I fucked up before, there were missing parens
07:48:13 <Cale> It would have to have been  (%) :: ((String -> b) -> c) -> ((String -> a) -> b) -> ((String -> b) -> c)
07:48:20 <Cale> oops
07:48:24 <ski> oh, that's more interesting, then :)
07:48:25 <Cale> (%) :: ((String -> b) -> c) -> ((String -> a) -> b) -> ((String -> a) -> c)
07:48:52 <Cale> and that's effectively (.) here
07:48:56 <shapr> Putonlalla: sounds like you're missing -pthread somewhere, though I don't know how that gets passed to GHC
07:48:58 <ski> (now i see what you meant about concatenation, since the `String's now changed polarity)
07:49:04 <Cale> ahh, yeah
07:49:05 <Cale> sorry about that
07:49:08 <ski> nw
07:50:45 <ski> i'm still not sure how the curried continuations i was thinking about would fit into this `CoKleisli (m ->)' business
07:50:53 <ski> (if indeed it fits in at all)
07:51:29 <ski> (e.g., how would `apply2' be defined ?)
07:51:53 <Cale> You mean how is it defined at the moment, or how would it be defined in another thing?
07:52:18 <ski> well, even seeing its type, in terms of `Cokleisli (m ->)' would probably helo
07:52:23 <ski> s/helo/help/
07:52:33 <Cale> apply2 :: Monoid m => (u -> v -> w) -> Format m (w -> a) (u -> v -> a)
07:52:33 <Cale> apply2 f = arr (\k x y -> k (f x y))
07:52:45 <Cale> type Format m = Cokleisli ((->) m)
07:53:07 <ski> hm, ok. so your curried continuation types are the object ends of the morphisms
07:53:35 <Cale> yeah, basically the domain and codomain of the arrow tell you how the type of printf is going to change
07:53:48 * ski nods
07:54:27 <ski> (but, hm, i suppose it's probably nqCPS, since we don't use the same "answer" type (minimal logic) all the time, but rather rely on being polymorphic in it)
07:54:28 <Cale> apply2 will take a situation where you would have needed to supply (at least one) argument of type w, and turn it into one where you'll need to supply arguments of types u and v
07:54:59 <Cale> and yeah, the fact that we get to be polymorphic is pretty important
07:55:18 <ski> aye. conceptually, we're being polymorphic in the "rest of the stack"
07:55:56 <Cale> as well as the result type, which makes this work equally well if you're ending up with an IO action or just a String
07:56:00 * ski remembers playing with this `dup k x = k x x' idea, years ago
07:56:21 <ski> *nod*
08:04:18 <codedmart> How would I represent a heterogeneous javascript array in haskell? I mean in the sense that in javascript I can say `MD5([ [ 'abc' ], 'abc', 123, 123 ])` to get an MD5 hash? I need to try and replicate some legacy code which uses javascript MD5?
08:04:56 <c_wraith> codedmart: use a sum type that represents javascript values
08:05:02 <codedmart> If I pass a ByteString `"[ [ 'abc' ], 'abc', 123, 123 ]"` the MD5's don't line up unless I pass the same string in the JS MD5.
08:05:43 <c_wraith> oh, for that specific case?  Um.  You'd have to find out what the JS MD5 function *does*
08:05:47 <EvanR> thats really gross
08:05:47 <mud> codedmart: At a guess, it's probably supposed to be in JSON or a list of JSON values or ... something
08:06:00 <jstsmthrgk> Hello, i have got a problem with cabal-install: when I run 'cabal install <whatever>', it always fails because it can't find any modules, not even Prelude
08:06:04 <c_wraith> because those arguments are nonsense for the MD5 algorithm, which works on sequences of bytes.
08:06:14 <c_wraith> passing it a list or a number is pretty meaningless
08:06:32 <c_wraith> but javascript pretends it means something, and now you get to reverse engineer it!
08:06:46 <EvanR> i bet it uses the default stringification of arrays
08:06:46 <codedmart> Yeah
08:06:58 <EvanR> which then uses utf16
08:07:02 <brynedwards> jstsmthrgk: Which OS?
08:07:21 <jstsmthrgk> brynedwards: Arch Linux
08:07:22 <mud> jstsmthrgk: What's the actual error messages?
08:07:46 <codedmart> EvanR: What is the default stringification of arrays?
08:07:51 <EvanR> god knows
08:07:52 <c_wraith> anyway, I bet EvanR is right and just uses JS default stringization of every argument, and you'll have do duplicate that.
08:08:22 <Putonlalla> I found the commit it's fixed in, so I guess I'll just have to wait for LTS 10.6 now, shapr.
08:08:56 <brynedwards> jstsmthrgk: Try installing ghc-static or build a static cabal-install as described here https://wiki.archlinux.org/index.php/Haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
08:09:10 <EvanR> String([[1,2,"3"],4,5]) => String([[1,2,"3"],4,5])
08:09:29 <EvanR> String([[1,2,"3"],4,5]) => "1,2,3,4,5"
08:09:39 <jstsmthrgk> this was it, I'll try ghc-static https://pastebin.com/WCgLGKGr
08:09:59 <EvanR> glwt
08:10:09 <mnoonan> EvanR: omg :|
08:10:32 * ski . o O ( not even injective )
08:15:58 <ongy> so I was playing around with core, and I've seen that my 4 field product type gets completly unpacked with optimisations at some point. Now I have found a case where it is not unpacked and the only thing that happens with it in the body, is that it gets split into the 4 fields, which are then used individually. Is there a maximum number of arguments that are useful? This function has 8 arguments right now, would be 11 if unboxed
08:16:41 <phadej> if things to be passed in registers than less is definitely better
08:17:28 <ongy> I guess registers have calling conventions similar to C? Some are caller, some callee saved? How many registers are caller saved?
08:17:28 <jstsmthrgk> brynedwards: It works, thank you!
08:17:40 <ongy> and where do I read about that? STG?
08:18:25 <phadej> unpacking decisions happen already in core-to-core passes, but I don't know what heuristics there are in place
08:18:32 <akr> Hello, I was wondering if there is a GHC extension which would allow writing `\x -> fun x a` as `fun - a` or something like that. Is there?
08:18:46 <phadej> akr: (`fun` a)
08:19:06 <phadej> doesn't need any extensions
08:19:54 <Taneb> akr: there's not anything precisely matching what you suggest, but as phadej suggests you may be able to use sections similarly
08:19:54 <akr> oh, right, I should've realized
08:21:12 <akr> yeah I guess this only scales up to binary functions
08:23:13 <ski> (the general solution is lambda expressions)
08:23:47 <phadej> or to rearrange arguments so partial application works for common cases :)
08:24:28 <phadej> which is kind of in reverse what you might been used from other languages (where you put "optional" arguments last)
08:24:42 <mnoonan> yeah, once you start trying to generalize a bit to "oh, what if I want to plumb the same thing into two places" or "what if I want more than one hole", it's hard to beat a plain old lambda
08:24:46 <akr> yes unfortunately that still leaves us with the uncommon cases :P
08:25:05 <phadej> akr: uncommon are uncommon
08:26:11 <ski> "less commonly varying" arguments should be earlier
08:26:59 <Putonlalla> The opposite is usually true for operators.
08:27:20 <akr> I wonder if something like `fun _₂ 5 _₁` would be a good idea
08:28:27 <ski> e.g. `zipWith f xs ys'. it's more common to pick a particular `f', and want to perform this for a selection of different `xs'&`ys'-pairs (or even to pick a particular `f' and `xs', and then want to perform this for a selection of `ys'); than to pick an `xs'&`ys'-pair, and then to perform the operation for a selection of differing `f's
08:28:34 <ski> akr : i don't think so
08:29:24 <ski> (arguably, i think the argument ordering of e.g. `elem', and `lookup', is wrong)
08:29:25 <akr> for reasons other than the usage of non-ascii characters?
08:29:31 <ski> yes
08:29:42 <phadej> scala has lambdas made with _ and it has own problems.
08:29:51 <phadej> e.g iwhat is (foo (bar _))
08:30:02 <phadej> (\x -> foo (bar x)) or foo (\x -> bar x)  ?
08:30:09 <ski> `fun _₂ 5 _₁' would normally be the same as `((fun _₂) 5) _₁' -- should this still work, with explicit bracketting like this ?
08:30:29 <EvanR> (-> x x + 1) heh
08:30:32 <ski> how about `fun (\x -> f _₂ x) 5 _₁' ?
08:30:44 <akr> hmm yeah that's a problem
08:30:55 <ski> where is the delimiter, which says upto which surrounding expression the wildcards should "match" ?
08:31:05 <ski> akr : you know, this idea had come up several times in the past ..
08:31:11 <ski> s/had/has/
08:31:27 <phadej> maybe there should be a directory of ghc-reject-proposals
08:31:31 <phadej> rejected-*
08:31:39 <akr> heh well glad I'm not the only one with questionable ideas :P
08:31:49 <Putonlalla> If only mathematicians realized how stupid the idea is.
08:32:13 <ski> well, it's good to understand what people consider to be problematic aspects of such ideas, and why they would be seen as problematic
08:32:23 <ski> Putonlalla : *grin*
08:33:43 <ski> when you have a syntactic expression which is indivisible, one can consider things like sections
08:34:23 <ski> e.g., instead of `\x -> if b then x else e', iiuc in Agda one can write `if b then_else e'
08:35:27 <ski> (in Haskell, this applies to infix operator sections, and to tuple sections (extension))
08:38:05 <akr> oh I was meaning to check out what this tuple sections extension was
08:38:42 <akr> hmm yeah that's cool
08:41:18 <ski> @type (False,,"True")
08:41:19 <lambdabot> t -> (Bool, t, [Char])
08:42:04 <akr> yeah I got it from https://prime.haskell.org/wiki/TupleSections :P
08:44:57 <Putonlalla> You can turn this into an arbitrary argument section by implementing a dependent uncurrying function with a TH splice.
08:45:46 <akr> I was with you until TH splice :)
08:45:59 <akr> oh I see nvm
08:46:00 <EvanR> its interesting how well typeclasses work to clear up issues with mixing of stuff like + and < of different types in the same code
08:46:11 <ongy> since I'm having fun poking at low-level optimizing stuff: How hard would it be, to use SSE in Haskell?
08:46:26 <EvanR> while all the things called the same in String, Text, ByteString still collide
08:46:35 <EvanR> and need namespaces
08:46:48 <EvanR> what went wrong
08:46:50 <Putonlalla> That is, `$(uncurrySplice ('a',, 'c',))` would become `\ x y -> f 'a' b 'c' d`.
08:47:03 <Putonlalla> Good job naming the arguments.
08:47:14 <Putonlalla> I meant `\ b d -> f 'a' b 'c' d`.
08:47:30 <Cale> ongy: maybe ask edwardk about that
08:48:25 <Cale> ongy: I recall he was looking into (and getting frustrated with) trying to use some particular extension instructions. I forget which ones though.
08:48:41 <cocreature> ongy: https://www.reddit.com/r/haskell/comments/7wsb54/state_of_simd_support_for_ghc/ might be interesting
08:48:50 <ongy> https://ghc.haskell.org/trac/ghc/wiki/SIMD hm, lkooks liek there's a branch
08:49:23 <byorgey> EvanR: I think what went wrong is that the committee didn't forsee the need to abstract over different kinds of string-like things.
08:49:26 <cocreature> that branch is dead afaik
08:49:42 <cocreature> or rather some parts are merged and the rest is abandoned
08:50:19 <byorgey> And even if they did I doubt they would have gotten it right.  Which is not to say anything bad about the committee, but just that picking the right abstractions is hard without a lot of experience
08:51:33 <byorgey> In other words, I don't think anything actually went wrong.  This is just business as usual: us humans bumbling around trying to figure out how to even computer.
08:52:52 <akr> oh cool I didn't know Intel made a Haskell compiler, how bad is it?
08:53:13 <akr> I mean, since it's a research compiler, it's probably not close to GHC?
08:53:31 <ongy> GHC is not a research compiler?
08:53:32 <MarcelineVQ> ghc is a research compiler :>
08:54:38 <akr> doesn't stop people from running code compiled by it in production environment, so it can't be that much of a research compiler?
08:54:38 <cocreature> akr: it’s not being actively developed
08:54:42 <byorgey> akr: every compiler is bad.  The correct question is how good is it.
08:55:13 <akr> cocreature: so I guess it wasn't very promising?
08:55:40 <akr> byorgey: alright then, what are the good thing about it? Compared to GHC
08:55:58 <cocreature> akr: I think the performance results were at quite good but apparently they weren’t interested in developing it further
08:56:06 <cocreature> akr: they have open sourced it very recently though
08:56:11 <byorgey> akr: oh, I don't know anything about the compiler itself.  Just making a (half-serious) general point. =)
08:56:21 <mnoonan> iirc they only changed the code generation, and it uses the ghc front end
08:57:28 <cocreature> yeah they were only interested in generating fast code on intel cpus (who would have thought)
08:57:54 <akr> yeah, the github repo says so
08:58:08 <EvanR> those bucket o bolts
08:58:15 <akr> heh
08:58:18 <akr> (ugh this lag on matrix is pretty bad)
09:00:50 <albeit> If I have "foo :: a -> IO (Either e a)", how can perform "Either e a -> IO (Either e a) -> IO (Either e a)" so that Left fed to "foo" returns the same Left?
09:02:09 <Cale> albeit: Why is your thing taking an IO action?
09:03:03 <jle`> albeit: traverse ?
09:03:03 <ertes-w> well, GHC is bad in the sense of badass
09:03:12 <jle`> hm
09:03:17 <albeit> The function calling foo is IO, and foo performs IO.
09:03:22 <jle`> (traverse . traverse)
09:03:35 <jle`> oh sorry i didn't see the entire second type signature
09:04:00 <ski> it's not clear what `bar :: Either e a -> IO (Either e a) -> IO (Either e a)' has to do with your `foo'. do you want to combine `foo' and `bar' (how ?) ? is `bar' to be defined in terms of `foo' ? something else ?
09:04:21 <Cale> albeit: Well, you can run the IO action produced by foo in order to get an Either e a first, and then combine that with your other Either e a using, say, the Monad instance for Either e.
09:05:26 <albeit> The second definition is bad I think. Basically I have an Either, and I want to pass it to foo without unwrapping the Either.
09:05:52 <ski> where is this `Either' thing coming from ? argument of `bar' ?
09:06:24 <albeit> Its computed earlier, it is just a raw(?) Either.
09:06:46 <ski> and the other argument of `bar', the `IO' action, which Cale asked about -- is it relevant here ?
09:06:49 <jle`> albeit: can it be implemented with pattern matching?
09:06:54 <jle`> on Left/Right?
09:06:57 <jle`> and bind on IO ?
09:07:02 * ski isn't sure what albeit want `bar' to do
09:07:20 <jle`> albeit: if you show how you would write it with pattern matching and do notation, it would be helpful
09:07:21 <albeit> I completely mistyped that second IO action, sorry. The second IO action is just foo.
09:07:24 <jle`> so we know what it is you really want
09:07:30 <albeit> @jle`: Shall do
09:07:31 <lambdabot> Unknown command, try @list
09:07:34 <albeit> jle`: Shall do
09:07:42 <jle`> and who knows, if it looks nice, why not use just that?
09:08:15 <Taneb> (a -> IO (Either e a)) -> Either e a -> IO (Either e a)
09:08:28 <Taneb> Is what I think albeit wants
09:08:47 <albeit> Taneb: Yes!
09:08:50 <ski> i think we're all suspecting that, but let's not bee too hasty, ok ?
09:09:43 <jle`> \f -> \case Left e -> return (Left e); Right x -> f x
09:09:51 <ski> albeit : ok, and that `Either e a' argument, it is also computed as a result of an `IO'-action ?
09:11:18 <jle`> what i wrote doesn't use 'foo' though
09:11:36 <jle`> is the answer supposed to involve foo?
09:11:42 <albeit> http://lpaste.net/362504
09:11:45 <ski> (possibly `f' is `foo' ?)
09:11:54 <jle`> f is different from foo, right?
09:12:03 <jle`> albeit has foo :: a -> IO (Either e a)
09:12:04 <albeit> That is how I would it manually unwrapping the Either
09:12:13 <jle`> and whats to write an (a -> IO (Either e a) -> Either e a -> IO (Either e a)
09:12:14 <ski> albeit : what about my question ?
09:12:15 <jle`> using foo
09:12:25 <albeit> @ski: No, it is not from an IO
09:12:25 <lambdabot> Unknown command, try @list
09:12:31 <albeit> ski: No, it is not from an IO
09:12:55 <jle`> oh i see, you don't want an (a -> IO (Either e a)) -> Either e a -> IO (Either e a)
09:13:01 <jle`> you just want an Either e a -> IO (Either e a)
09:13:27 <albeit> jle`: Yes
09:14:11 <ski> hm .. i suppose what i'm (and jle` and ... are) thinking of could perhaps still be relevant, using `liftIO', then
09:14:28 <ski> albeit : i.e., we're thinking of using the `ExceptT e IO' monad, where `(=<<) :: (a -> ExceptT e IO b) -> ExceptT e IO a -> ExceptT e IO b' amounts to `(a -> IO (Either e b)) -> IO (Either e a) -> IO (Either e b)'
09:14:45 <jle`> i like 'either (return . Left) foo'
09:15:09 <jle`> problem with ExceptT is that there's no easy way to hoist Either
09:15:15 <ski> hm, no, not `liftIO', actually
09:15:42 <albeit> jle`: That works, thanks!
09:15:49 <albeit> ski: I have never used ExcepT, I will check it out
09:15:58 <ski> albeit : in your case, since you don't have `IO (Either e a)' (or `ExceptT e IO a') to begin with, you could convert from your `Either e a' to `ExceptT e IO a', and then use `(=<<)'/`(>>=)'/`do'-notation
09:17:04 <ski> albeit : when you have a "sequence of `IO' (or whatever monad) operations to perform, and want to abort as soon as you get a `Left' result", that's when `ExceptT' applies. `MaybeT' is similar, except that you have `Maybe' internally, instead of `Either e'
09:17:24 <jle`> :t \f -> fmap join . traverse f
09:17:25 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
09:17:41 <ski> @type ExceptT . return
09:17:41 <jle`> (don't do that)
09:17:42 <lambdabot> Monad m => Either e a -> ExceptT e m a
09:17:53 <jle`> oh hey that's not too bad of a way to hoist Either
09:18:14 <jle`> yeah, if you do several of these, best to jump into ExceptT
09:18:26 <ski> @type either throwError return
09:18:28 <lambdabot> MonadError e m => Either e a -> m a
09:18:44 <albeit> I do indeed have a sequence of IOs that I want to abort on a Left, so ExceptT sounds great
09:18:53 <ski> great !
09:19:37 <ski> when you want to intersperse a plain `IO'-operation, which doesn't yield an `Either'-result, that's when you use `liftIO'
09:20:07 <albeit> Okay. Thanks all!
09:27:35 <albeit> FPComplete says wrapping ExceptT around IO is an anti-pattern (https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell). Is that only when ExceptT is used for actual exceptions, in the sense of anomalous errors as opposed to expected, manageable errors?
09:29:57 <hyperisco> what is ExceptT?
09:30:12 <hyperisco> grr, once again Hoogle failing me…
09:31:02 <mud> hyperisco: Use the stackage one or hayoo ?
09:31:10 <hyperisco> albeit, that article section is opinionated
09:31:33 <cocreature> hyperisco: http://hoogle.haskell.org/?hoogle=ExceptT :)
09:31:34 <c_wraith> fpcomplete is very opinionated and sometimes gives what I consider to be very bad advice
09:31:35 <jle`> albeit: that's about using ExceptT + IO as exception handling
09:31:45 <jle`> albeit: in any case we're just using ExceptT as a newtype wrapper
09:31:47 <hyperisco> cocreature, if it isn't a DDG bang pattern it doesn't exist
09:31:48 <sgraf> albeit: Personally, I'd be OK with using `ExceptT` in isolated places, in a way like I would use `MaybeT IO`, but not really to handle application-wide exception handling that way
09:31:54 <jle`> to give our value the right Monad instance
09:32:06 <jle`> we're just basically using a newtype hack to make >>= do the thing we want
09:32:14 <jle`> it's basically like using Sum/Product to pick the Monoid instance for numbers
09:32:17 <jle`> > foldMap Sum
09:32:18 <lambdabot>  <[Integer] -> Sum Integer>
09:32:30 <jle`> > foldMap Product [1..10]
09:32:32 <lambdabot>  Product {getProduct = 3628800}
09:32:37 <jle`> > foldSum Product [1..10]
09:32:37 <albeit> Got it, so don't use to try to handle actual IO exceptions, but for my "own" exceptions its okay
09:32:39 <lambdabot>  error:
09:32:39 <lambdabot>      Variable not in scope:
09:32:39 <lambdabot>        foldSum :: (a0 -> Product a0) -> [Integer] -> t
09:32:54 <jle`> well, that's what the article is saying, at least
09:33:02 <jle`> it's not talking bout using it as a newtype hack
09:33:13 <jle`> (like we're using it here)
09:33:25 <glguy> albeit: Using ExceptT is less flexible and less efficient than using IO for your exceptions if you're already in IO
09:33:31 <hyperisco> no the article says don't use it at all, regardless of exception type, which is opinionated
09:33:33 <sgraf> I interpret the article as saying that it's useless to define your own, app-wide exceptions in terms of ExceptT because you end up doing exception handling twice that way
09:33:49 <jle`> the article is talking about using `ExceptT e IO` as the interface of your application
09:34:00 <jle`> here we're just using it as a newtype hack
09:34:23 <sgraf> I mean using ExceptT in your Application stack suggests there aren't any other exceptions to be aware of and that's not true
09:34:46 <hyperisco> well stop being so suggestible
09:34:56 <sgraf> Using it locally within a function or module seems ok though
09:35:28 <c_wraith> sometimes I want non-exceptional short circuiting. ExceptT is still bad for that because of its name.
09:35:58 <sgraf> Then use `MaybeT`, or use `ExceptT` anyway if you need to know why you short-circuited
09:36:12 * ski thinks "exceptions are only for exceptional situations" is silly, anyway
09:36:27 <c_wraith> it really is good for regions of "here are a bunch of things that might fail with a Left"
09:36:28 <hyperisco> we program with clowns and jokers, and we're going to quibble over possible misinterpretations of "ExceptT"?
09:36:46 <humanoyd> with DataKinds, why does ":kind 'True" work but ":kind '5" does not (unless I remove the quote)
09:37:11 <jle`> they forgot
09:37:32 <hyperisco> humanoyd, I dunno, but I am going to guess because 5 is not a constructor
09:37:45 <jle`> non-constructor things can be used with ' too
09:37:54 * hyperisco shrugs
09:37:55 <jle`> :k '[1,2,3]
09:37:56 <lambdabot> [GHC.Types.Nat]
09:38:10 <hyperisco> but… that's just sugar for a bunch of constructors
09:38:19 <c_wraith> hmm. but is there any example of that which isn't on list sugar?
09:38:19 <jle`> yes
09:38:23 <jle`> we're talking about expressions here
09:38:31 <jle`> constructors and list sugar are different expressions
09:38:42 <c_wraith> because you certainly can't lift an arbitrary expression
09:38:43 <hyperisco> okay
09:38:55 <jle`> we're talking about syntactic constructs, not semantic ones
09:39:04 <michi7x7> what does ' do?
09:39:14 <hyperisco> I was thinking semantically :P
09:39:31 <c_wraith> :k [1..3]
09:39:32 <lambdabot> error: parse error on input ‘..’
09:40:02 <glguy> michi7x7: In the context of DataKinds and TemplateHaskell it's a hint that you're referring to the constructor from the value namespace
09:40:23 <ski> @kind '[False]
09:40:25 <lambdabot> [Bool]
09:40:25 <ski> @kind '(:) 'False '[]
09:40:27 <lambdabot> [Bool]
09:40:40 <hyperisco> imagine you have  data X = X  then how does one distinguish  X :: *  from  X :: X
09:40:43 <jle`> it also works with '(,), which is syntactically not a constructor
09:40:59 * ski . o O ( "don't do that" )
09:41:02 <jle`> > '(,) 1 2
09:41:04 <lambdabot>  error:
09:41:04 <lambdabot>      • Syntax error on '(,)
09:41:04 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
09:41:06 <jle`> :k '(,) 1 2
09:41:07 <lambdabot> (GHC.Types.Nat, GHC.Types.Nat)
09:41:10 <hyperisco> ski, well that is what you use the tick for right?
09:41:26 <jle`> any argument that calls for '[1,2,3] and '(,) should probably include '5
09:41:30 <ski> i think so, yes
09:41:33 <jle`> i think it was just an oversight
09:42:01 <glguy> [Int] and '[Int] need to be disambiguated
09:42:06 <glguy> 5 doesn't
09:42:09 <jle`> semantically 5 is considered a "constructor" in patterns
09:42:13 <c_wraith> though really, the tick was added as a way to distinguish two namespace, and 5 doesn't exist in one of them.
09:42:19 <jle`> just like [x,y,z] and (x,y) are
09:42:27 <c_wraith> so there's no ambiguity to work around.
09:42:55 <glguy> :k [Int]
09:42:56 <lambdabot> *
09:42:57 <glguy> :k '[Int]
09:42:58 <lambdabot> [*]
09:46:56 <albeit> Is this correct use of short-circuting with ExceptT? http://lpaste.net/362505 Fairly contrive, but this should return Left "Bad2" and short circuit?
09:48:17 <lyxia> yes
09:49:05 <jle`> i know you're just demonstrating, but (liftIO . return) is just 'return'
09:49:08 <jle`> it's one of the monad morphism laws
09:52:05 <albeit> Yep, I would sub in an IO function there
09:52:08 <albeit> http://lpaste.net/new/haskell
09:52:34 <albeit> In foo2, is the isGood2 action every evaluated if isGood1 is false? Is the foo style prefereable to foo2?
09:53:21 <humanoyd> jle` glguy c_wraith hyperisco Thanks a lot!
09:53:47 <nullie> albeit: you've copied wrong link
09:54:09 <albeit> Whoops sorry, http://lpaste.net/362506
09:54:52 <ski> albeit : `isGood1' and `isGood2' are not actions, but `Bool'eans
09:55:55 <ski> if we ignore that `return True' and `return False' are trivial actions, and assume there there were some actions there that could "raise exceptions", then the second of these wouldn't be performed in case the first "raised an exception", right
09:56:59 <albeit> ski: I should have put generic ":: IO Bool" functions in there
09:57:06 <ski> (but it looks like you wanted to use those `Bool'eans to determine whether to throw an exception .. so from that perspective, i don't think `bar2' would be a useful approach to what you seem to want to express)
09:57:30 <nullie> maybe return True is a mock here, instead of IO action
09:58:30 <ski> anyway, typically, you'd let the actions that you call themselves decide when to raise an exception, and when you call them in `ExceptT e IO', you're just focusing on the non-exceptional results, not mentioning throwing any exception
09:58:50 <nkaretnikov> what's the proper way to write this in ghci? :i (a,a)? i get a parse error on a
09:59:02 <ski> (unless you discover a new situation here and now which you'd like to raise an exception for, of course .. but i gather that's not what you're asking about)
09:59:13 <ski> nkaretnikov : what do you want to achieve ?
09:59:26 <nkaretnikov> look at the instances of a tuple
09:59:46 <ski> use `:info (,)' or `:i (,)'
10:00:19 <ski> the type `(X,Y)' is syntactic sugar for the usual prefix (type) application form `(,) X Y'
10:00:38 <nkaretnikov> ah, right
10:00:38 <ski> (similarly to how the type `[X]' is syntactic sugar for `[] X', and `X -> Y' for `(->) X Y')
10:00:39 <nkaretnikov> thanks
10:01:23 <ski> `:info' doesn't accept an expression, only a single identifier
10:01:33 <ski> (in this case, a type constructor)
10:02:34 <ski> (it actually accepts both infix and non-infix identifiers, including ("full") sections and "infixing" a regular identifier)
10:12:47 <albeit> For the top-level of a program that has to do IO, is it "okay" to use a "RSST r w s IO" stack? Where RSST is the stateWriter version of RWST (because the RWST writer space leaks apparently)
10:15:49 <mud> RSST seems a little odd because IO can kind of implicitly do all of those things, but yeah it might make sense, especially the Reader part (which it's least able to do without passing around a bunch of stuff in each call)
10:16:29 <cocreature> ime State on top of IO is often inferior to just using an IORef or an MVar since at some point you end up wanting to access the state from multiple threads
10:17:24 <albeit> cocreature: Ah, so in that case the State or Reader would contain the IORefs/MVars?
10:17:40 <cocreature> I’m also not really sure why you would want a writer for the top-level of your program. usually that tends to be more useful for accumulating results in a small subpart of your program
10:17:58 <cocreature> albeit: yeah either put the IORef in a Reader or just pass it around manually
10:18:19 <albeit> I was thinking I could use the writer for all logging, debug and otherwise
10:18:45 <cocreature> usually you want to write out log messages immediately not accumulate them
10:19:20 <mud> albeit: Debug tends to go in Debug.Trace anyway
10:19:34 <albeit> If the program isnt wrapped around IO, how would I print out logs then?
10:20:12 <fragamus> copumpkin where can i find the best way to build a haskell-nixos-ec2 machine like the cool kids use
10:20:17 <cocreature> if you only care about doing something quick and dirty for debugging then Debug.Trace
10:20:36 <cocreature> if you want proper logging then accumulating them using Writer might be ok
10:20:49 <cocreature> or make some mtl-style MonadLogger class and use that
10:21:01 <cocreature> but you said you want to use it for the top-level that has to do IO
10:21:37 <qeyoa> The book i'm reading had an example with a function for removing duplicate values. Before looking at it, i tried to write it myself:
10:21:37 <qeyoa> rmdups :: Eq a => [a] -> [a]
10:21:37 <qeyoa> rmdups [] = []
10:21:37 <qeyoa> rmdups (x:xs) = x : rmdups (filter (/= x) xs)
10:21:37 <qeyoa> It seems to work, however looking at the declaration in the book, it is a bit different:
10:21:37 <cocreature> albeit: http://www.haskellforall.com/2014/02/streaming-logging.html might also be helpful
10:21:37 <qeyoa> rmdups :: Eq a => [a] -> [a]
10:21:37 <qeyoa> rmdups [] = []
10:21:38 <qeyoa> rmdups (x:xs) = x : filter (/= x) (rmdups xs)
10:21:38 <qeyoa> Would the version in the book be more efficient since it filters values starting from an empty list (instead of doing it on the spot like i did), or is there no difference?
10:21:44 <albeit> Okay. Regarding IORef's, if the program doesnt wrap IO but uses IORefs in the stat/reader, how can it every access/modify them?
10:22:18 <cocreature> qeyoa: please use some kind of pastebin (e.g. lpaste) instead of pasting multi-line definitions here
10:22:22 <cocreature> albeit: modifyIORef?
10:22:28 <qeyoa> ok
10:22:34 <qeyoa> i thought it was short enough
10:22:40 <qeyoa> to paste whole
10:23:26 <Cale> albeit: It doesn't. IORefs can only be modified and accessed by IO actions.
10:23:44 <cocreature> oh I didn’t read the question properly, sry
10:23:48 <Cale> albeit: So if IO is not part of the construction of the monad in some way, then you can't work with them
10:24:14 <Cale> albeit: However, as a general point, I would say you should usually try to avoid your first monad transformer as long as possible
10:24:31 <Cale> There's a lot of convenience you give up by transforming IO
10:25:08 <Cale> because IO has a lot of higher order primitives which are hard to make sense of once things are transformed, like bracket, exception handling, forkIO/async etc. etc.
10:26:15 <albeit> Okay... so if I have a program that does network read/write, and read/write to an local database, is their a general way to structure the program to avoid transformers?
10:26:28 <Cale> Sure, all that stuff is doable from IO
10:26:39 <shapr> Are there multiple good options for a "Haskell Playground" along the lines of the rust and go playgrounds?
10:26:52 <shapr> that is, web based eval of code that's viewable by multiple people?
10:27:03 <ski> qeyoa : your version might be more efficient, since it doesn't consider again any other occurance of `x'
10:27:47 <glguy> shapr: Google says that there is https://repl.it
10:28:06 <qeyoa> Thanks ski
10:28:08 <shapr> Yeah, that looks good, heard of anything else? I know of tryhaskell
10:28:38 <qeyoa> how many lines of code can i paste without triggering the bot in this channel?
10:28:46 <glguy> qeyoa: Use a pastebin
10:28:52 <Cale> qeyoa: you shouldn't have to, use lpaste.net
10:29:09 <qeyoa> ok
10:29:17 <qeyoa> will paste all the code in lpaste.net from now on
10:33:18 <cocreature> ski, qeyoa: that’s not always true, is it? the former version will be better if x is in the list but if x is not in the list the call to filter in the second version will (potentially) have to filter fewer elements
10:35:11 <ski> cocreature : in the latter version, the `filter' will remove at most one `x', which seems a bit wasteful to use a full `filter' for, then
10:35:33 <albeit> If I want to get started on a streaming library, what would you recommend between pipes and conduit?
10:35:46 <cocreature> ski: good point
10:36:21 <ab9rf> albeit: yes.
10:36:33 <ski> hm, i wonder how the total number of comparisions would compare, for the two versions
10:36:45 <ab9rf> albeit: i personally prefer conduit for most purposes, but there are times where the pipe abstraction is better
10:36:53 <ski> also, if we modify the latter version to instead use an operation that only removes the first (if any) occurance
10:36:55 <cocreature> ski: I thought about working that out but then decided I’m too lazy for it :)
10:37:02 * ski can never recall what this list operation is called
10:37:09 <ab9rf> i forget what the difference is exactly, but there's some things that pipes do better and some that conduits do better
10:37:35 <mud> ski: 'delete' ?
10:37:52 <ski> probably, yes
10:37:58 <albeit> ab9rf: Okay. Is one particularily easier to learn?
10:38:16 <ab9rf> albeit: they're about the same
10:38:18 <cement> pipes has some pretty excellent documentation
10:38:20 <ski> (i remember there's a `delete', but i can't recall its exact semantics off the top of my head)
10:38:24 <cement> idk about conduit though
10:38:39 <ab9rf> learning one will learn most of what you need for the other
10:38:42 <ab9rf> the differences are not very large
10:39:25 <cocreature> pipes is in some sense simpler but requires additional libs (in particular pipes-parse and pipes-group) which are more complex once you fall out of the things the standard interface provides
10:39:27 <ab9rf> iirc, pipes came first, and conduit is in some places defined by "pipes, except for..."
10:40:34 <ab9rf> for the things i tend to do conduit is easier, but that may simply be an artifact of the things i've tried to do
10:40:37 <ab9rf> your experience may vary
10:41:32 <albeit> Okay, thanks
10:41:48 <cocreature> there is also a relatively new library called "streaming" that a lot of people seem to like
10:42:00 <cocreature> although I haven’t really used it myself so I can’t give detailed comments on it
10:42:29 <cocreature> but really it doesn’t matter very much. learn one and you’ll be able to pick up the others fairly easily
10:48:37 <lyxia> At the end of the day, pipes, conduit, and streaming are all just free monads.
10:50:08 <ski> @quote not.a.church
10:50:08 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
10:51:00 <lyxia> But then the challenge is to understand how to work with free monads of course
10:51:46 <cocreature> the fact that they’re all free monads also doesn’t tell you a lot about how they differ :)
10:53:37 <Unicorn437> I'm trying to write a function that takes a list and returns a list of local maxima using a list generator, but I'm struggling to find a way to fetch the previous and next element. How can I do that?
10:54:00 <amalloy> Unicorn437: i assume by "list generator" you mean a list comprehension?
10:54:05 <Unicorn437> Yes
10:55:10 <amalloy> so, within a list comprehension (or map, or filter, or similar) over a list xs, you can only ever look at one element of xs at a time. each element is considered independently
10:55:11 <ski> list comprehensions don't do that, in and of themselves
10:55:28 <Unicorn437> so its impossible?
10:55:33 <amalloy> this is not to say that what you want is impossible: you can write a list comprehension over some list *other* than your list of inputs, for example a list of triples in the input
10:56:01 <hyperisco> > (zip3 <$> id <*> drop 1 <*> drop 2) [1..10]
10:56:02 <Tuplanolla> > (\ xs -> zip3 xs (tail xs) ((tail . tail) xs) ['a' .. 'f'] -- This might be of use, Unicorn437.
10:56:03 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8),(7,8,9),(8,9,10)]
10:56:04 <lambdabot>  <hint>:1:96: error:
10:56:04 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:56:36 <Tuplanolla> The same idea on the same second.
10:56:38 <hyperisco> however, now you have to cope with less-than-three element lists
10:56:56 <ski> > let xs = [0,1,2,3,2,1,2,3,4,5,4,3,2] in [y | (x,y,z) <- zip3 xs (drop 1 xs) (drop 2 xs),x <= y,y >= z]
10:56:58 <lambdabot>  [3,5]
10:57:48 <glguy> > let xs = [0,1,2,3,2,1,2,3,4,5,4,3,2] in [ (x,y,z) | x:y:z:_ <- tails xs, x <= y, y >= z ]
10:57:50 <Unicorn437> so I need to use triples and zip3, thanks
10:57:50 <lambdabot>  [(2,3,2),(4,5,4)]
10:58:08 <hyperisco> or ZipList
10:58:17 <ski> or `tails'
10:58:36 <Unicorn437> what does tails return?
10:58:42 <hyperisco> TIAS
10:58:45 <glguy> There's no way to know
10:59:19 <hyperisco> I'm sorry but he went down with the plane… tails isn't coming back
11:01:02 <Unicorn437> so [(x,y,z)| x:y:z_<-tails xs ]would give me a list of all the triples of a given list?
11:01:20 <ski> triples of three contiguous elements, yes
11:01:31 <ski> (you're missing a `:', btw)
11:03:11 <ski> > [[x,y,z] | x:ys <- tails "abcde",y:zs <- tails ys,z <- zs]  -- this is something else
11:03:13 <lambdabot>  ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
11:04:55 <Unicorn437> since tails isn't in prelude zip3 will do, ty for the quick responses!
11:06:32 <mud> It's in the 'base' package though, it's just in the Data.List module. Lots of stuff in there you shouldn't be afraid to use.
11:08:19 <[exa]> With dependent types, what is the common name of the thing that takes a type-level value (i.e. the length of vector) and makes it available at the term-level?
11:08:36 <[exa]> (I've asked yesterday but probably missed the answer, sorry for reposting)
11:10:07 <Lycurgus> there's logs you can check
11:10:43 <Lycurgus> http://tunes.org/~nef/logs/haskell/
11:12:01 <[exa]> wow, nice
11:17:09 <byorgey> [exa]: perhaps the word you're looking for is 'singleton'?
11:18:08 <[exa]> I'm really looking for just the name of the concept. It would be the name of what e.g. natVal or symbolVal from TypeLits do
11:18:22 <MarcelineVQ> a witness?
11:18:32 <[exa]> yeah, getting there
11:18:57 <[exa]> the other direction is called 'promote' ?
11:19:30 <MarcelineVQ> reifiy?
11:20:13 <sQVe> What's the difference with running `stack build hoogle` or `stack install hoogle`?
11:20:27 <[exa]> MarcelineVQ: that's probably the best word for it, thanks!
11:20:32 <lyxia> which way are reify and reflect?
11:20:49 <MarcelineVQ> sQVe: the latter copies any bins install makes to ~/.local/bin
11:20:55 <mud> sQVe: stack install builds it and then copies any executables into ~/.local/bin
11:21:24 <sQVe> MarcelineVQ, mud: Ah. But other than that they do the same thing pretty much?
11:21:32 <MarcelineVQ> if you type  stack intall --help  it'll tell you about that, including that  stack intall is a synonym for  stack build --copy-bins
11:21:41 <mud> sQVe: Other than that they do exactly the same thing, yeah.
11:22:00 <sQVe> MarcelineVQ, mud: :bow: :bow: :bow: Thank you.
11:22:23 * sQVe holding my fingers that I get HIE installed correctly now.
11:25:43 <sQVe> Hmm. It's crashing with `hie: The Hoogle file /home/sqve/code/test/.stack-work/hoogle/x86_64-linux-tinfo6-nopie/lts-9.21/8.0.2/database.hoo is the wrong version or format.` :(
11:26:56 <sQVe> Any ideas?
11:27:01 <freeman42x]NixOS> does anyone have any example of using QuickCheck under HSpec with (custom) generators?
11:29:27 <cocreature> freeman42x]NixOS: you mean generators that are not supplied via an Arbitrary instance?
11:31:05 <apostolis> What is the simplest network library in Haskell? Something like connect , wait , receive , close connection. (msg passing)
11:31:42 <freeman42x]NixOS> cocreature, not sure, I need to create a custom generator probably that uses the NonNegative generator
11:32:13 <freeman42x]NixOS> I'm following the Haskell Book, this is for testing associativity of ^ operator
11:32:25 <cocreature> freeman42x]NixOS: why do you need a custom generator? NonNegative already has an Arbitrary instance so you can just use that
11:32:37 <freeman42x]NixOS> the book shows a lot of examples of custom generators but not how to use them under HSpec
11:32:59 <cocreature> hspec shouldn’t really change anything here
11:33:07 <freeman42x]NixOS> cocreature, as I said "probably"
11:33:11 <cocreature> do you have some concrete example that you’re having trouble integrating into hspec?
11:34:47 <freeman42x]NixOS> cocreature, "testing associativity of ^ operator"
11:35:16 <cocreature> freeman42x]NixOS: I was more thinking of actual code that works with quickcheck itself but not hspec
11:35:22 <freeman42x]NixOS> the 3 arguments can not be completely random, the 2nd and 3rd need to be NonNegative
11:35:45 <cocreature> usually all you need to integrate a quickcheck property into hspec is to use https://hackage.haskell.org/package/hspec-2.4.8/docs/Test-Hspec-QuickCheck.html#v:prop
11:35:49 <freeman42x]NixOS> cocreature, nope, I am just following the book streaming here: https://www.twitch.tv/freeman42x
11:36:23 <freeman42x]NixOS> cocreature, until now I just needed to use property which generated without any constraints
11:37:19 <ahri_> hi, quick question: what does `cabal --ghcjs configure` do vs. `cabal --ghc configure`? it seems like some state is being written as it affects subsequent `cabal repl` calls, but I can't see where
11:37:21 <huytd> wow, didn't know that there's somebody streaming book on twitch
11:37:27 <cocreature> freeman42x]NixOS: something like `prop "^ is associative" (\x (NonNegative e1) (NonNegative e2) -> (x ^ e1) ^ e2 == x ^ (e1 * e2))`
11:37:50 <cocreature> ahri_: somewhere in dist/* afaik
11:37:54 <maerwald> huytd: there's also a bob ross channel on twitch, but I'm not sure how that related to haskell xD
11:38:07 <huytd> hello twitch! i'm on the livestream!
11:38:37 <ahri_> cocreature: huh, ok, thanks. I'll poke around in there :)
11:39:54 <MarcelineVQ> if you turned off the user and channel list you'd have room to put the chat and editor side-by-side :>
11:40:36 <freeman42x]NixOS> cocreature, thank you, that works
11:41:15 <cocreature> freeman42x]NixOS: although I wouldn’t call that associativity
11:41:40 <freeman42x]NixOS> cocreature, what do you mean?
11:43:31 <cocreature> associativity is usually "(a + b) + c = a + (b + c)" for some arbitrary operator +, your example involves two operators one of which does not have type a -> a -> a
11:43:42 <MarcelineVQ> does it?
11:44:16 <woodson> Hi everyone, can anyone help me with this http://lpaste.net/362510 ? I am trying to understand how sequence work under the hood by implementing my own but I am having trouble
11:44:24 <woodson> can anyone guide me?
11:44:47 <apostolis> Is Network.Socket the only option? Is there something of higher level?
11:46:38 <MarcelineVQ> cocreature: freeman42x]NixOS's is using ^, at least in this stream of his, its yours that uses ^ and *
11:46:51 <cocreature> MarcelineVQ: well I’m not watching the stream :)
11:47:03 <MarcelineVQ> I'm just wondering where the * is coming from hehe
11:47:16 <freeman42x]NixOS> cocreature, "property" is forall? I think I need any or something like that for this test
11:47:44 <freeman42x]NixOS> since there are obviously cases when the results match and it appears to be associative
11:48:03 <huytd> I'm trying to understand the different between Modules and Class in Haskell, so, Modules is a group of similar functionalities, Class is an Interface (set of behaviour that you want to share with other types), am I right?
11:48:49 <MarcelineVQ> the smallest case for the property will falsify, since ^ and 0 have fun together
11:48:56 <MarcelineVQ> @check \x y z -> x ^ (y ^ z) == (x ^ y) ^ z
11:48:58 <lambdabot>  *** Failed! Falsifiable (after 1 test):
11:48:58 <lambdabot>  0 0 0
11:49:06 <davean> huytd: a Module is a collection of code, a Class is a collection of (mostly) functions (but possibly data types too) thats instances of it provide.
11:50:19 <huytd> I see, thank you so much davean, and the point of class is so that you can deriving it later, am I right?
11:50:46 <davean> Many classes cant
11:50:51 <davean> be derived
11:50:55 <davean> you have to write the instance
11:51:36 <huytd> got it, thank you so much! davean
11:52:06 <c_wraith> and it's worth being very clear: the point of classes is so that you can write code that works with any instance of the class.
11:52:43 <c_wraith> if your class doesn't make that work, it probably shouldn't be a class.
11:53:17 <huytd> :+1: c_wraith I didn't understand this part yet, but I'll take a note :D
11:54:43 <davean> Classes say what you know about a thing, even though you don't know what the thing is
11:54:50 <davean> they're definitionally an abstraction
11:55:27 <freeman42x]NixOS> MarcelineVQ, I am not sure how to express that ^ is non-associative, exactly because of those exceptions. Proving addition was associative was easy because for all values it held. In this case the property doesn't always hold
11:56:25 <c_wraith> I've seen cases where someone tries to make a class such that they can share names between two instances that are never interchangeable, like making persistent and mutable versions of a data structure implement some shared class.
11:57:35 <c_wraith> there's no gain from using a class for that. just put them in different modules, don't shoehorn them into implementing a seriously crazy class.
11:59:21 <cocreature> freeman42x]NixOS: well what do you want to express? are you sure that you don’t want something like the property that I’ve written above?
12:00:03 <freeman42x]NixOS> cocreature, what you wrote above is what I needed, how to use NonNegative
12:00:40 <freeman42x]NixOS> my issue right now is that I can't use `property` which seems to mean `forAll` I need something like `exists`
12:00:44 <cocreature> freeman42x]NixOS: take a closer look, the property I specified is also different from the one MarcelineVQ used above (and supposedly you use yourself)
12:00:55 <freeman42x]NixOS> eg. if exists 1 example in which it is not associative then it is not associative
12:01:38 <qeyoa> What is the prevailing naming scheme in Haskell? In java i try to write methods and variables with longer names (the shorter the method, the more descriptive the name), however in Haskell i see (from my very limited experience with it) that everything is very succinct, often ending up being a single letter or word. Do the names get longer in actual projects where there is much more code to go around?
12:02:01 <davean> Not really
12:02:08 <MarcelineVQ> freeman42x]NixOS: expectFailure might be appropriate
12:02:18 <davean> Most of what you write into those function names are shown by the types and guarrented, not "maybe it means that"
12:02:23 <mnoonan> quyoa: more generic / polymorphic values -> more generic names, generally
12:03:08 <qeyoa> ah, thanks
12:03:13 <freeman42x]NixOS> MarcelineVQ, it would work with forAll and expectFailure, but isn't there some function for existential quantification?
12:03:26 <ski> qeyoa : also, the greater the scope of the name, the more disambiguating/descriptive name it requires
12:03:37 <cocreature> freeman42x]NixOS: that doesn’t make sense. quickcheck only checks a few random values so your test would randomly fail if you get unlucky
12:03:43 <freeman42x]NixOS> like: if there is at least 1 case in which the property holds then the test should pass
12:04:06 <mnoonan> freeman42x]NixOS: that's not really where random property testing would be appropriate imo
12:04:10 <cocreature> if you don’t want universally quantified properties, just write a regular unittest
12:04:14 <MarcelineVQ> hmm, I'm not sure what you're asking about
12:04:19 <freeman42x]NixOS> cocreature, but random failing is always the case...
12:04:21 <ski> if it's just a local parameter of a function (especially if it's a polymorphic function), then it's common to use a short, like a one- or two- letter name
12:04:52 <freeman42x]NixOS> mnoonan, tell that to the guy who wrote the Haskell Book :p
12:05:21 <cocreature> freeman42x]NixOS: no if your test is correct, then quickcheck will always pass. if it’s not correct then you are right that it won’t always fail but in that case the test needs to be fixed once you figured out why it fails
12:05:41 <cocreature> permanently relying on tests that fail half of the time is not a good idea
12:08:49 <MarcelineVQ> freeman42x]NixOS: I don't see powerAssociative in the book though, what section is this work from?
12:09:43 <freeman42x]NixOS> MarcelineVQ, Chapter 14, Testing exercises, page 879 on the PDF version with small padding
12:10:12 <MarcelineVQ> ah I see they didn't name it
12:10:13 <freeman42x]NixOS> MarcelineVQ, search for: <<Is (^) associative? Is it commutative? Use QuickCheck to see
12:10:13 <freeman42x]NixOS> if the computer can contradict such an assertion.>>
12:10:35 * ski . o O ( <https://en.wikipedia.org/wiki/Moufang_loop>,<https://en.wikipedia.org/wiki/Power_associative> )
12:11:14 <freeman42x]NixOS> cocreature, I think I got your point about existance quantifier, it would depend a lot on probabilities and would be flaky
12:11:37 <davean> freeman42x]NixOS: extremely - to the point of virtually never working
12:11:53 <cocreature> freeman42x]NixOS: there is also just no value provided by property testing over regular unit testing. if there is a counterexample, just write a regular unit test for that counter example
12:12:10 <davean> freeman42x]NixOS: I mean take a UUID generator and "will eventually produce ____ value"
12:12:14 <cocreature> you can always use quickcheck initially to find that counterexample but once you have it, quickcheck has served it’s purpose
12:12:23 <freeman42x]NixOS> cocreature, so proper solution would be: http://lpaste.net/7111538056225619968
12:12:43 <cocreature> no that will only fail if you get lucky
12:12:45 <davean> freeman42x]NixOS: or a has "There exists a string that hashes to ____"
12:12:51 <freeman42x]NixOS> cocreature, <<if there is a counterexample, just write a regular unit test for that counter example>> the author really really insisted to use QuickCheck :)
12:13:11 <davean> freeman42x]NixOS: Yah, they did - so?
12:13:22 <davean> Doesn't make them right
12:13:49 <cocreature> freeman42x]NixOS: they insisted that you use quickcheck for _checking_ if the operator is associative. you did that and figured out that it’s not associative. they didn’t say you should add permanently add a quickcheck test to your test suite to check it every time
12:13:55 <freeman42x]NixOS> didn't say it did make them right :p
12:14:46 <freeman42x]NixOS> cocreature, no, actually I think the author knew that I know that it is not associative so he didn't want me to waste any time writing code for something I know already
12:15:11 <cocreature> well speculating about what the author might have thought that you knew is not particularly productive :)
12:16:54 <dgpratt> @check False
12:16:56 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:17:40 <cocreature> dgpratt: who would have thought that this fails!
12:17:47 <davean> freeman42x]NixOS: I'm too lazy to write the tests myself: https://hackage.haskell.org/package/props-0.1.2/docs/Test-Properties.html
12:18:36 <dgpratt> right?
12:24:03 <dgpratt> any reason why e.g. "expectFailure (1 ^ 2 == 2 ^ 1)" would not be an ideal QuickCheck test/property?
12:24:57 <davean> dgpratt: I mean, its a test ... why are you using quickcheck?
12:25:20 <dgpratt> because maybe you want to stick with using QuickCheck?
12:26:10 <maerwald> it's a really quick check, that's for sure
12:26:17 <dgpratt> :)
12:31:17 <mud> dgpratt: I think it's generally more common to use some wrapper that allows both QuickCheck and other test forms, so in that sense it could probably be something else usually. But that's not universal by any means, if like all of your other tests are QC and you just want that one, I don't see a problem with it. Other than the part where I don't see it being a good test in general, I'm not sure what's actually being tested there. Mathematics itself? GHC's
12:31:19 <mud> implementation of (^) and (==) ? Tests that kind of ... can't ever fail aren't super useful.
12:34:30 <ski> "can't ever fail, assuming the behaviour of the operation is correct", i think was the idea ?
12:35:02 <ski> (while we'd like at least one of the properties to have a possibility of failing, in case the behaviour is incorrect)
12:35:11 <dgpratt> mud: regarding the pointlessness of that particular test, definitely; I was just trying to express a way to include a particular counter-example as a QC test/property (in reference to the line of questioning from freeman42x]NixOS
12:35:50 <mud> dgpratt: Okay, yeah. Just making sure :)
12:38:39 <kuribas> can you combine folds and traversals?
12:38:54 <kuribas> or folds and lenses?
12:40:34 <kuribas> :t foldl . foldl
12:40:35 <lambdabot> (Foldable t2, Foldable t1) => (b -> a -> b) -> b -> t1 (t2 a) -> b
12:41:13 <kuribas> :t foldl . _1 . foldl
12:41:14 <lambdabot> (Foldable t2, Foldable t1, Field1 b1 b1 b2 b2) => (b2 -> a -> b2) -> b1 -> t1 (t2 a) -> b1
12:43:12 <kuribas> > (foldl . foldl) (+) 0  [[1, 2],  [4, 3]]
12:43:14 <lambdabot>  10
12:45:02 <kuribas> > (foldl . _1 . foldl) (+) 0 [([1, 2], "first"), ([4, 3], "second")]
12:45:04 <lambdabot>  error:
12:45:04 <lambdabot>      • Could not deduce (Num [Char]) arising from a use of ‘+’
12:45:04 <lambdabot>        from the context: (Num b, Field1 b b [Char] [Char])
12:51:21 <lyxia> "foldl" is not a Fold in the optic sense (as opposed to Lens, Traversal, Prism)
12:52:07 <kuribas> so I need to use folded?
12:53:21 <lyxia> yes
12:54:15 <kuribas> :t (folded . _1 . folded)
12:54:16 <lambdabot> (Applicative f1, Foldable f2, Foldable f3, Indexable Int p, Field1 a1 a1 (f2 a2) (f2 a2), Contravariant f1) => p a2 (f1 a2) -> f3 a1 -> f1 (f3 a1)
12:57:13 <kuribas> > foldlOf' (folded . _1 . folded) (+) 0 [([1, 2], "first"), ([4, 3], "second")]
12:57:14 <lambdabot>  10
12:57:22 <kuribas> hurray :)
12:58:56 <kuribas> how if this different from (traverse . _1 . traverse) ?
13:00:09 <kuribas> is it more performant?
13:04:12 <glguy> > sumOf (folded . _1 . folded) [([1, 2], "first"), ([4, 3], "second")]
13:04:14 <lambdabot>  10
13:04:41 <freeman42x]NixOS> can `property` generate random functions also? http://lpaste.net/2477557652838678528
13:04:43 <kuribas> glguy: I actually need to create a hashmap
13:04:46 <lyxia> I think folded is only more general
13:05:05 <lyxia> freeman42x]NixOS: yes
13:05:25 <lyxia> ah wait, not like that, you need to use Fun
13:05:41 <kuribas> glguy: using HashMap.insertWith mappend
13:06:26 <lyxia> freeman42x]NixOS: property $ \(Fn f) (Fn g) x -> appComp (f :: Int -> Int) (g :: Int -> Int) x
13:06:51 <vyorkin> can somebody explain why the following code works? http://lpaste.net/362512, I don't get it, because `error "err" :: a`, but `catch` needs `IO a`
13:07:02 <vyorkin> sorry if thats a stupid question)
13:07:30 <Cale> vyorkin: Well, if it can be any type, it can certainly be IO a
13:08:02 <vyorkin> oh, right
13:08:07 <vyorkin> lol, thanks)
13:08:15 <Cale> However, in general, it's not all that of a good practice to rely on catching errors thrown by error
13:08:25 <Cale> use throwIO whenever you can
13:09:04 <Cale> (and don't throw exceptions from pure code that you intend for anyone to ever catch)
13:12:34 <vyorkin> got it, thank you, I'm just getting myself familiar with exception handling in haskell for the first time actually
13:14:01 <pikajude> yeah, StrictCheck is turning out to be incredibly useful
13:14:16 <lyxia> pikajude: <3
13:14:16 <pikajude> how nice
13:14:19 <pikajude> thanks lyxia
13:14:39 <pikajude> i've never before seen a visual representation of a certain mode of evaluation
13:21:47 <marekw2143> hello
13:22:13 <marekw2143> in F#, when developing in Visual Studio, IDE gives some hints about specified types which I find very usefull
13:22:21 <marekw2143> is there any equivalent of IDE in haskell ?
13:25:05 <Jacoby6000[w]> marekw2143: depending on your editor, there should be a way to show the type under the cursor
13:25:40 <marekw2143> Jacoby6000[w]: yes, but is there any editor which does it out of the box ? :)
13:26:20 <Jacoby6000[w]> I dunno. I've only ever used spacemacs and vim.  spacemacs haskell mode did it, vim has plugins
13:27:50 <sm> marekw2143: I think only haskellformac, all others require that you build the box
13:27:50 <freeman42x> lyxia: from which module is `Fn` ?
13:28:49 <marekw2143> yyy, but haskellformac is only for mac ?
13:28:53 <sm> yup
13:29:52 <glguy> also only for Haskell
13:32:02 <freeman42x> lyxia: got it, it was from Test.QuickCheck.Function , it works, thank you
13:32:49 <sm> marekw2143: you might want to try vscode + haskell-ide-engine
13:35:11 <marekw2143> ehh :)
13:35:32 <marekw2143> thanks for pointing this editor, but I guess I'll just continue without that functionality ;)
13:35:46 <sm> then, you might like at least ghcid
13:35:54 <sm> good for seeing compile errors
13:36:14 <blankhart> atom also has haskell packages using ghc-mod (requires ghc 8.0.2)
13:36:22 <sm> (not what you asked for, I know)
13:36:44 <marekw2143> wow, I'll check it !
13:37:20 <snOwryyy> Is there a way I can map print to a list containing multiple lists of numbers that has a type of (Num b, Enum b) => [[b]]?
13:37:27 <sm> are you really asking for a haskell addon that works in Visual Studio ?
13:37:54 <sm> because there seem to be a bunch of them
13:38:27 <marekw2143> nono, just wanted to describe functionality of F#
13:38:39 <marekw2143> I use haskell on Linux, so no VS there
13:38:55 <sm> showing type of expression on hover, right ?
13:39:35 <sm> oh.
13:39:50 <sm> clearly my support-sense is failing :)
13:40:11 <blankhart> https://code.visualstudio.com/docs/setup/linux
13:40:18 <marekw2143> sm: true
13:40:20 <blankhart> i haven't tried it but it looked like there was VS code for linux
13:40:32 <marekw2143> yes, there's VS Code and I have it
13:40:46 <marekw2143> but I assume it's different that Visual Studio for Windows :)
13:41:10 <marekw2143> but yeah, sm, "showing type of expr on hover" that's what I'm looking for
13:42:28 <sm> so: nothing out of the box on linux. Addons for all the major editors/ides that will work for at least simple projects, after more or less hair pulling
13:42:39 <marekw2143> hehe
13:42:59 <sm> choose your path wisely, and good luck!
13:43:31 <marekw2143> thanks
14:07:51 <kuribas> If I have myFun x = case x of {Case1 -> "case1"; Case2 -> "case2"; Case3 -> "case3" ... }
14:07:58 <kuribas> Why doesn't ghc generate a lookup table?
14:08:13 <kuribas> it just seems to check each case.
14:08:49 <lyxia> How are you determining that
14:08:56 <kuribas> lyxia: the assembler output
14:08:58 <amalloy> kuribas: ghc knows how to create a lookup table for case expressions
14:09:23 <amalloy> if it isn't doing that, perhaps it has determined that that's not the most efficient solution for this case. alternatively, make sure you're compiling with -O2
14:09:24 <kuribas> unless I read it wrong...
14:10:22 <amalloy> or, well, i shouldn't speak so confidently. i *think* ghc knows how to create lookup tables, but i may be misremembering
14:12:31 <kuribas> it doesn't look like it...
14:12:36 <kuribas> And I have 25 cases...
14:12:49 <lyxia> yes it knows how to, at least for integers.
14:13:55 <kuribas> lyxia: I use constructors, not integers...
14:18:23 <kuribas> I could use enum at the cost of readability and correctness...
14:18:59 <MarcelineVQ> at the gain of?
14:19:21 <kuribas> speed?
14:21:11 <lyxia> kuribas: http://lpaste.net/362514 this at the end looks like a jump table
14:22:02 <lyxia> It's even smart enough to merge common cases
14:23:00 * lyxia gives a cookie to GHC.
14:25:32 <kuribas> lyxia: hm, indeed
14:28:00 <hyperisco> how can I run a producer ignoring everything it produces?
14:28:22 <hyperisco> other than the roundabout way through for
14:33:25 <freeman42x]NixOS> is there any way to auto-derive a Random instance from a data type? QuickCheck complains when using `chooose` with: <<No instance for (random-1.1:System.Random.Random Fool) arising from a use of `choose'>>
14:34:05 <kuribas> lyxia: right, I found the lookuptable :)
14:37:07 <lyxia> freeman42x]NixOS: what is Foo and why are you using choose with it?
14:38:28 <freeman42x]NixOS> lyxia, http://lpaste.net/3258631244123996160
14:40:07 <freeman42x]NixOS> lyxia, https://hackage.haskell.org/package/QuickCheck-2.11.3/docs/Test-QuickCheck.html#v:choose
14:40:23 <MarcelineVQ> frue is now my word of the month
14:40:28 <lyxia> I think Random is mostly used for primitive types
14:41:04 <lyxia> Just write a Gen Fool
14:41:31 <lyxia> with some of the QuickCheck combinators
14:42:19 <lyxia> elements [Fulse, Frue]
14:44:53 <freeman42x]NixOS> lyxia, yeah, elements is much better, thank you
14:51:23 <SrPx> Is there any way to represent this Idris program on Haskell? `the (x : Type ** x) (Int ** 7)`
14:52:01 <SrPx> Specifically, I'd like to be able to have a terminal constructor on a tree-like data structure that allows it to store elements of any type
14:53:38 <SrPx> So, a simpler example would be heterogeneous lists with pairs of (Type,Value), ex: ((Int, 7) : (Bool, True) : ([Int], [1,2]) : []) :: [(x : Type ** x)]
14:59:34 <SrPx> (leaving Irc, question on SO: https://stackoverflow.com/questions/48797644/is-it-possible-to-represent-t-type-t-on-haskell-i-e-the-type-of-typ)
14:59:45 <SrPx> goodbye
15:26:27 <SegFaultAX> I'm dealing with an annoying log format, trying to use parsec to parse it. The structure is `label[content]` where label is something like "timestamp" and content is the value for that field. Eg `timestamp[2018-02-14T00:00:00]`
15:27:19 <SegFaultAX> One of these fields embeds a json object, eg `foo[{...json object...}]` and I'm trying to figure out an elegant way to parse that without writing a parser just for the internal json value
15:28:33 <SegFaultAX> What's a good way to parse the matching braces around an opaque string that may contain [] without backtracking?
15:29:18 <albeit> If I want to run a computation that performs steps in IO but doesn't explicitly return anything but can still short-circuit, should I use "MaybeT IO a"?
15:29:29 <albeit> Sorry, meant "MaybeT IO ()"
15:29:35 <mud> Is there escaping? Arbitrary nesting, or just two levels? Are they matched if they exist?
15:30:21 <SegFaultAX> mud: Is that to me? If so, then there's no escaping. It's just the json blob inlined between the [] delimiters.
15:30:54 <SegFaultAX> mud: I can provide a real example if it would help.
15:31:12 <Tuplanolla> I can provide one too, SegFaultAX.
15:31:18 <mud> SegFaultAX: Can't hurt
15:32:10 <Tuplanolla> Let's start with `json[{"bad" : "oh\"}]no"}]`.
15:33:32 <SegFaultAX> https://gist.github.com/SegFaultAX/743916a007bb6e9d11c9cf27580a5b07
15:33:40 <SegFaultAX> The source field is the field in question, at the end of the sample
15:33:55 <amalloy> SegFaultAX: there must be someone else in this universe who's already written a parsec parser for json objects
15:34:16 <amalloy> so you can just reuse that, and throw away the parsed object if you don't need it
15:34:18 <SegFaultAX> amalloy: First of all, howdy! Second, I don't actually care to process the blob as json (right now)
15:34:35 <SegFaultAX> I guess I'm leaning towards "just parse the json, idiot"
15:35:56 <amalloy> yeah, that seems simpler than writing something which knows how to handle the various kinds of escaping/nesting of [] without understanding the real json structure
15:36:13 <SegFaultAX> The elasticsearch slow query log format is annoying to parse. :)
15:36:22 <amalloy> as a bonus, if a json object is malformed, you'll find out about it instead of blindly trusting it and having a totally messed up context for the rest of the file
15:37:02 <SegFaultAX> amalloy: I don't actually care if it's well formed (at least in this stage of the pipeline)
15:37:07 <SegFaultAX> But I take your broader point.
15:37:35 <amalloy> what i mean is, a malformed json object could ruin your parsing heuristic so that you don't succeed in parsing anything at all
15:37:54 <amalloy> eg, the "json object" consisting of a single [ character will make you think the whole rest of the file is one object
15:38:20 <SegFaultAX> This particular process happens to work line-wise, so at least that particular case isn't an issue.
15:39:33 <amalloy> if you already have a newline as your final delimiter, and you don't care about the json object, why not just consume everything up to EOL, and verify that the last character before the EOL is a ]?
15:47:18 <grokkingStuff> hey there.
15:47:23 <grokkingStuff> how's everyone doing?
16:02:34 <Patrol02> Hi
16:02:45 <Patrol02> does anyone know if there is a way to stream a file from S3 using Amazonka into a lazy bytestring? So download would happen as I read the BS and not "load the whole BS into memory before you can access it"?
16:15:06 <bash0r> Hi guys, is there a reason why conduit-extra on Data.Conduit.Network does not reexport constructors of HostPreference?
16:16:27 <Cale> Patrol02: There are ways to make that kind of thing happen, but in general they're regarded as a bit of a bad idea in real applications, because you basically lose the ability to deal with things like the connection going away, and if you're opening many connections, the ability to control the number of sockets you have open.
16:16:52 <Axman6> Patrol02: you can use my amazonka-s3-streaming package if you like
16:17:25 <Cale> Yeah, using conduits or pipes or something would make a lot more sense for this.
16:17:32 <Axman6> actually, no, that only does uploads
16:17:37 <Patrol02> I am fine with my service die when the connection goes away etc.
16:17:52 <Patrol02> @Axman6 yes, I saw that :)
16:17:52 <lambdabot> Unknown command, try @list
16:19:25 <Patrol02> Cale: could you please point me to these ways you mentioned?
16:19:52 <Axman6> so it should be possible to turn the RsBody from a GetObjectResponse into a lazy bytestring, but it would be much better to actually use conduit explicitly
16:20:03 <Axman6> Patrol02: what do you need to do with the response?
16:21:22 <Cale> Well, how are you already getting the file? Is it just an http/https connection?
16:22:13 <Axman6> I would assume that if Patrol02 is using amazonka then this should work for non web enables S3 buckets
16:22:17 <pavolzetor> how do I emit constant with llvm IRBuilder?
16:22:22 <pavolzetor> there are no examples
16:22:23 <Patrol02> Axman6: I am looking at this right now. It is a bit weird because I do need conduits downstream, but I need Source, not just Conduit. Also looking if there is a way to make it not requiring Source, but it is not my lib code :)
16:22:44 <Cale> Ah, there's some odd protocol they have?
16:22:56 <Axman6> well, it's the AWS api
16:23:01 <Cale> right
16:23:12 <Axman6> which is also http based, but there's lots of detauls around auth and signing etc
16:23:21 <pavolzetor> and the Operand is not an instance of MonadIRBuilder
16:23:27 <Cale> So you'll probably end up using unsafeInterleaveIO directly
16:23:44 <Axman6> pavolzetor: do you have a link to the docs?
16:25:25 <Cale> Patrol02: Source is just a special case of Conduit, where two of the type parameters happen to be ()
16:25:34 <pavolzetor> https://hackage.haskell.org/package/llvm-hs-pure-5.1.2/docs/LLVM-IRBuilder-Constant.html
16:31:33 <pavolzetor> I basically want to pull it out applicative and move to the builder monad
16:31:50 <pavolzetor> I could probably use the non IR stuff to get the constantoperand
16:31:59 <Axman6> that's fine, if your particular f is also a Monad, then you can use it as a
16:32:00 <Axman6> monad
16:32:13 <Axman6> and MonadIRBuilder I assume enforces that m is a Monad
16:32:39 <pavolzetor> yep
16:32:56 <pavolzetor> I am not sure how to use it though
16:33:32 <Axman6> so you'd do: do {byt <- byte 0xAF; byt2 <- byte 0xFF; res <- or byt byt2 return res}
16:33:41 <pavolzetor> https://hackage.haskell.org/package/llvm-hs-pure-5.1.2/docs/LLVM-IRBuilder-Instruction.html
16:33:58 <Axman6> (assuming byte is a thing, which it isn't :| my bad)
16:34:14 <ab9rf> hehe
16:34:17 <Axman6> s/byte/int32
16:35:07 <pavolzetor> I added Operand constraint to function signature and now it works
16:35:17 <Axman6> hooray
16:35:37 <Axman6> I should try playing with the some of the llvm libraries
16:35:44 <pavolzetor> not really
16:36:03 <Cale> Patrol02: The RsBody that you get from the GetObjectResponse contains a ResumableSource, which you can take apart to get a Source
16:36:17 <Cale> (using unwrapResumable)
16:36:30 <pavolzetor> this should not be hard, I can code up the stuff myself, but I thought I could use that IRBuilder to save time; I would probably be done by now ;)
16:36:50 <Axman6> heh, but now you've learned a new thing!
16:36:54 <pavolzetor> (given the error messages are super crappy)
16:37:42 <pavolzetor> I am not sure, I think it is unnecessary overcomplicated; basically the IR builder is piece of state which hold bunch of blocks
16:37:57 <pavolzetor> you have current block to which you append
16:38:20 <pavolzetor> it is just a f :: State -> (Operand, State)
16:38:49 <Patrol02> Cale: thanks, trying it now! Looking for ResumableSource -> Source
16:39:14 <pavolzetor> but since using 'let' with chaining the updates is tedious, you have to use the 'do' notation, which forces you to implement bunch of instances
16:39:59 <Cale> Patrol02: http://hackage.haskell.org/package/conduit-1.2.12.1/docs/Data-Conduit.html#v:unwrapResumable
16:40:17 <Cale> Patrol02: You'll also get an action that you need to run at some point after you're done with the Source
16:42:19 <Cale> I'm not entirely sure I understand why the finalizer is needed... it seems like a lot of operations which result in ResumableSources just set it to return ()
16:42:24 <Cale> but something must actually use it
16:42:43 <Patrol02> Cale: thanks! And do you have any hints on how do I convert ResumableSource (ResourceT IO) a into (MonadResource m, MonadAWS m) => ResumableSource m a?
16:42:56 <catern> maaaan
16:43:03 <catern> why don't people know programming language theory properly?
16:43:15 <catern> (is there a type theory/PLT channel on freenode?)
16:43:18 <Cale> Patrol02: Well, the latter type is more general
16:43:30 <Cale> catern: ##typetheory
16:43:45 <Patrol02> Yes, then I should be able to lift into it somehow
16:43:45 <Cale> catern: But usually it also works to ask here.
16:43:48 <pavolzetor> actually, how is it possible that given the operand is required to be only Applicative it can automatically become MonadIRBuilder?
16:43:55 <Cale> catern: Depending on the question.
16:44:52 <Axman6> pavolzetor: Applicative f => says that f only needs to be applicative, it's not an upp[er bound, it's a lower bound
16:46:00 <pavolzetor> So the MonadIRBuilder instance is somewhere defined?
16:46:53 <pavolzetor> Hmm, I am not sure how I should know that I can use it then with MonadIRBuilder (or Monad)?
16:47:11 <Axman6> https://hackage.haskell.org/package/llvm-hs-pure-5.1.2/docs/LLVM-IRBuilder-Monad.html#t:MonadIRBuilder says that all things which are MonadIRBuilder ar also Monad, and all whings which are Monad at Applicative
16:48:00 <pavolzetor> I see, so basically, that Operand needs only part of the requirements down the chain
16:48:17 <Axman6> ie, to be a MonadIRBuilder, something must first be a Monad (Monad m => MonadIRBuilder m), and to be a Monad, something must first be an Applicative (Applicative m => Monad m)
16:49:30 <Axman6> so if your f is an instance of MonadIRBuilder, then you know it is laos a Monad so you can use all that that gives you, and you know f is also an applicative, so you can use what that gives you, which includes the ability to use things like in the Constant module
16:49:50 <Axman6> basically, you can probably assume it's just using pure somewhere internally
16:50:24 <Axman6> int64 :: Applicative f => Integer -> f Operand
16:50:26 <Axman6> int64 = pure . ConstantOperand . Int 64
16:50:55 <Axman6> if pure was replaced with return, then the constraint would be Monad, but that's more constrained than it needs to be
16:55:39 <pavolzetor> how does it then cast to IRBuilder Operand?
16:56:45 <pavolzetor> I have f Operand becoming IRBuilder Operand
16:57:01 <Axman6> there's no cast. _you_ get to pick what f is, the type signature int64 :: Applicative f => Integer -> f Operand says that all that you need to know is that f is an Applicative, and IRBuilder is an Applicative (as well as a Monad and MonadIRBuilder)
16:57:47 <Axman6> you could also make f Maybe, and get back a Maybe Operand, or [] and get back a [Operand]
16:58:05 <pavolzetor> I understand it now
16:59:51 <pavolzetor> Thanks, I am not convinced this approach is good idea; it is impossible to know what is going on without reading documentation with the typeclass instances
17:00:14 <Axman6> understanding what these things mean comes with experience
17:01:04 <dave_uy> Can GHCi tell me what version of a module I have imported?
17:01:11 <pavolzetor> Probably; I just want to look at the code and know what roughly is going on
17:01:33 <Axman6> luckily the haddocks will tell you all the classes a type instanciates - if you look at the definiition of IRBuilderT (which is basically IRBuilder), you'll see it is instances of lots of classes - you should read those: https://hackage.haskell.org/package/llvm-hs-pure-5.1.2/docs/LLVM-IRBuilder-Monad.html#t:IRBuilderT
17:01:43 <pavolzetor> (that's why have my own parser combinators library)
17:01:53 <Axman6> dave_uy: what does :info (some type in the module) say?
17:02:58 <pavolzetor> I see, that helps, why is type IRBuilder = IRBuilderT Identity
17:02:59 <Axman6> there's also :browse... not sure what that shows you
17:02:59 <pavolzetor> ?
17:03:34 <Axman6> pavolzetor: IRBuilderT is a monad transformer, so you might want to have m = IO if you need to read other files while making a compiler, for example
17:03:42 <dave_uy> error: Not in scope: ‘Data.Time.Clock.POSIX’
17:04:07 <Axman6> dave_uy: you'll need to have imported the module. also, that looks like a module name, not a type
17:04:58 <dave_uy> :browse works for me.
17:05:13 <Axman6> great
17:05:22 <pavolzetor> I will read about those. Is it something like merged monads?
17:06:40 <pavolzetor> I am just thinking that in python, I would just have two inputs, builder and file pointer
17:07:08 <pavolzetor> why can't you just pass two monads in?
17:07:20 <pavolzetor> IO -> IRBuilder -> (IO, IRBuilder)
17:08:01 <davean> Because what is that?
17:08:06 <ab9rf> i'm not even sure what that would be
17:08:07 <davean> Its two Monads
17:08:24 <ab9rf> how do you evaluate that?
17:08:34 <davean> fst, snd?
17:10:27 <pavolzetor> let x' = runIO x
17:11:03 <pavolzetor> or something like that, just access then in long let statement with variables
17:11:46 <Axman6> ok, looks like you're in need of a haskell tutorial, you're missing some fundamentals :)
17:12:11 <pavolzetor> I went through LYAH and most of the School of Expression ;)
17:12:23 <pavolzetor> the second is actually a good book
17:12:45 <Axman6> so, what you've described is basically what monad transformers give you
17:13:11 <pavolzetor> I found chapter in real world haskell
17:13:24 <ab9rf> i'm at a loss to explain why (M1 a, M2 b) is not a solution for a stacked monad
17:13:28 <ab9rf> but i do know that it's not a solution :)
17:14:14 <Axman6> IRBuilderT IO is a monad which can perform IO, and also use perform MonadIRBuilder actions
17:14:39 <Axman6> ab9rf: because they can't interact with each other, basically
17:15:37 <pavolzetor> but that is just convenience so you can use do notation right?
17:15:55 <pavolzetor> I could just have a let statement and do it easily
17:16:20 <pavolzetor> even that IR builder does not have to be a monad
17:16:42 <pavolzetor> I could do let ir' = addBlock ir; ir'' = addBlock ir' in ir''
17:18:29 <pavolzetor> and that is actually not that bad, I sometimes do it but I number the variables
17:19:16 <ab9rf> Axman6: yeah, i just don't know how to explain why that is
17:20:27 <pavolzetor> I can see the use of monad if some action can fail, as I would have to wrap the ir variable in something
17:20:30 <ab9rf> Axman6: i know that it's because the monadic value represents a sequence of computation, and if you somehow distribute that over two unconnected monadic values, you can't somehow evaluate some, but not all, of that sequentialized computation
17:21:54 <ab9rf> but i am terrible at explaining this even if i understood it, which i don't really
17:24:14 <pavolzetor> You have to create chain right? so the lazy evaluation kicks in when you request the result
17:24:32 <davean> I mean, you can evalute IRBuilder before or after the IO action, and you can return an IO value, but you can't change the internal IO computation
17:25:17 <pavolzetor> yes, running IO is just like calling function
17:27:13 <ab9rf> well.... not "just like"
17:27:33 <pavolzetor> it has outside state
17:27:52 <pavolzetor> i think of function as something deterministic
17:28:06 <pavolzetor> procedure is one which touches outside world
17:29:31 <pavolzetor> anyhow, my point in general was that this is more complicated that it needs to be and thus making it hard to learn
17:30:03 <pavolzetor> If they just used MonadIRBuilder constrait maybe it would still work, even if it is "less general"
17:30:05 <ab9rf> it is complicated, but it is not "more complicated than it needs to be:"
17:30:11 <ab9rf> it is EXACTLY as complicated as it needs to be
17:31:14 <davean> what ab9rf said, and actually it should make it easier to learn. It stops you from doing it wrong.
17:31:36 <ab9rf> i didn't find understandig monad transformers difficult
17:31:58 <davean> Monad transformers are just "I have a monad m, and I also want it to provide these other things"
17:32:01 <davean> done
17:32:57 <pavolzetor> I have to read about them; I do not agree, Haskell is easy to learn, but hard to use as you have to learn many things to do simple things
17:33:16 <pavolzetor> python let's you make mistakes and you then improve to not make them
17:33:36 <davean> pavolzetor: On the contrary I see "expert" python programmers never learn to stop making those mistakes
17:33:36 <ab9rf> i will say that python was "easier" to learn than haskell
17:33:42 <ab9rf> it took me a week to learn python
17:33:43 <pavolzetor> making mistakes -> understanding the problem
17:33:49 <ab9rf> haskell took me at least six months
17:34:34 <ab9rf> python lets you do flatly idiotic things and not even complain about them
17:34:42 <ab9rf> it just generates nonsense results
17:34:54 <ab9rf> or errors at runtime
17:35:01 <ab9rf> is that really useful?
17:35:04 <pavolzetor> Python is good for some things, not big codebases where you need to refactor
17:35:16 <metahumor> or it blows up in terms of memory when it doesn't need to, eg __dict__ vs __slots__
17:35:36 <davean> pavolzetor: or, in terms of what is above, python can't even comprehend of doing what one is talking about there
17:35:37 <ab9rf> the first is a generic problemt hat virtually all dynamic languages have
17:35:38 <davean> so theres no analogy
17:35:42 <ab9rf> the latter is an implementation detail
17:35:55 <davean> Theres nothing analogous
17:36:03 <ab9rf> haskell is not a dynamic language (it's about as much not one as you can be and still be a programming language)
17:36:11 <davean> If you wanted to do it like you do it in python, you'd only ever have IO
17:36:49 <ab9rf> yeah, all imperative languages are always in a sequential-computation IO
17:37:01 <ab9rf> er sequential-computation monad like IO
17:37:07 <pavolzetor> in think you are missing general point, that is, it was easier for me to implement subset of Parsec I needed than to learn how to use the library
17:37:16 <pavolzetor> Haskell is good language
17:37:32 <davean> pavolzetor: but Parsec *isn't designed to provide the subset you need*
17:37:41 <ab9rf> really? i found parsec exceptionally easy to understand
17:38:04 <davean> and also, that probably just suggests you haven't learnt how to read Haskell yet
17:38:06 <pavolzetor> ab9rf, most programs are sequential
17:38:11 <ab9rf> pavolzetor: really?
17:38:14 <pavolzetor> (at least compiler I am working on)
17:38:17 <davean> pavolzetor: you missed the point
17:38:21 <ab9rf> pavolzetor: that hasn't been my experience at all!
17:38:32 <davean> pavolzetor: It isn't about sequential, Monad Transformers are about semantics
17:39:17 <pavolzetor> ab9rf, did you try to add some nice error messages to parsec?
17:39:30 <ab9rf> pavolzetor: that's fairly straightforward, as i recall
17:39:55 <davean> pavolzetor: Alternative
17:39:56 <koala_man> oooh, there's a new llvm ir library?
17:40:05 <davean> pavolzetor: you just provide an alternative for the failed parse
17:40:13 <koala_man> thanks cocreature!
17:40:13 <ab9rf> koala_man: yeah, i'm thinking i need to look at that when i can find a time
17:40:24 <ab9rf> davean: that's what i would have expected
17:40:52 <ab9rf> i haven't used parsec in about a year, i guess, so my recollection is a bit furry
17:40:58 <davean> ab9rf: I mean, I didn't even have to look to know that.
17:41:23 <davean> It comes straight from principals
17:41:37 <ab9rf> davean: there's a parsec internal that allows you to give a production a "pretty name" or something that i can't recall the name of, which alters the default error messages
17:41:37 <davean> They'd have to work hard for that NOT to be how you'd do it (and in fact it is how you do it)
17:41:44 <davean> ab9rf: sure
17:41:49 <davean> ab9rf: I didn't say its the only way
17:42:32 <davean> But because of these law-full designs, I don't even have to look at the docs to know how to use parsec
17:42:44 <davean> pavolzetor: and thats something to note - I can know how to use something without the docs
17:42:51 <sm> [obligatory mention of megaparsec - modernised parsec, better error messages etc..]
17:43:03 <ab9rf> yeah, i only have to look at the docs to remember the nbames of the predefined parsers
17:43:24 <davean> so, I don't *have* to learn parsec to use it - I inherantly know how to use it because its a lawfully designed Haskell library
17:43:38 <davean> pavolzetor: and I think you should take careful note of that
17:44:02 <pavolzetor> makeTokenParser
17:44:05 <pavolzetor> what does it do?
17:44:13 <pavolzetor> does it use Pratt parser?
17:45:44 <mniip> [obligatory mention of free monad transformers - bootstrap a parser combinator library in 3 lines of code
17:45:46 <mniip> ]
17:45:51 <ab9rf> hehe
17:46:58 <pavolzetor> it is probably my inexperience, but I really hard to read any libraries to understand what they do
17:47:44 <davean> pavolzetor: it sounds like you're worrying more about how they do something then that they do it
17:48:22 <ab9rf> ding
17:48:27 <pavolzetor> if I want to extend them or understand the bottlenecks I have to know them
17:48:31 <sm> pavolzetor: sounds like partly inexperience, but also keep in mind lots of current haskell libs have suboptimal "human factors", it will improve over time
17:48:42 <davean> pavolzetor: you need NONE of that to use them - and rarely to extend them
17:48:58 <ab9rf> i still don't understand how parsec/megaparsec works internally
17:49:01 <Lycurgus> rly, the stuff in hackage is mostly organized by common end function, not specific to haskell
17:49:02 <pavolzetor> I had issue like that with linear package, I just wanted to use SOA layout for my ray tracer
17:49:06 <davean> pavolzetor: you're bring in assumptions
17:49:07 <ab9rf> but i have written lots and lots of parsers
17:49:10 <Lycurgus> *rly?
17:49:42 <davean> pavolzetor: and of course it doesn't match your assumptions - someone specificly went and tried to fix the deficiencies with those options - it has to be different.
17:50:03 <davean> pavolzetor: bring your existing approach to it won't get you very far
17:50:14 <pavolzetor> but SOA is better for ray tracing
17:50:20 <pavolzetor> you can do streaming and SIMD
17:50:36 <pavolzetor> that is current state-of-the-art
17:50:54 <pavolzetor> I just wanted to transpose the vector from AOS to SOA
17:51:16 <davean> and if you just used Vector, you'd get that
17:51:32 <davean> well, unboxed
17:51:39 <mniip> where does '<*>' come from?
17:51:48 <mniip> the name
17:52:00 <mniip> it seems to have been in widespread use even before the applicative functional pearl paper
17:52:26 <rza> Hello, does anyone know how you could extract a specific "portion" of a declared data type within a function? (ie: data Graph v = Graph (Map.map v [v]) -- Just want the 'v' part
17:53:03 <Cale> rza: there is no 'v' part
17:53:18 <mniip> rza, that's not a "part"
17:53:19 <Cale> rza: v is a parameter to Map there
17:53:48 <rza> I might be asking this completely wrong (Sorry..)
17:53:55 <davean> pavolzetor: again Haskell works at a high level - SOA and AOS look the same in the code other then where you do that part
17:54:05 <davean> pavolzetor: don't try to make it look like you expect it to
17:54:27 <pavolzetor> can you explain? pavolzetor: and of course it doesn't match your assumptions - someone specificly went and tried to fix the deficiencies with those options - it has to be differ
17:54:39 <rza> The issue I am having is that I have a function that returns 'Graph v' ... and I can't seem to chain it with another function because it can only take 'v' and not 'Graph v'
17:54:59 <ab9rf> rza: you have a Graph v and yuou want a v?
17:55:04 <rza> Yes!
17:55:13 <ab9rf> rza: but a Graph v contains many v's. which one do you want?
17:55:15 <Cale> rza: ... sure. A Graph whose vertices have type v is not a value of type v
17:55:32 <ab9rf> rza: do you want to iterate over the graph's vertices?
17:55:44 <Cale> It might even be the empty Graph
17:55:51 <davean> pavolzetor: Haskell tries to do something different then procedural languages - in doing so it avoids the issues of procedural languages but by the same messure it is interacted with differently. Its supposed to be abstract
17:55:55 <rza> Essentially I want to extract the "(Map.map v [v])" part and chain it to the function
17:56:04 <ab9rf> do what?
17:56:09 <pavolzetor> hmm, I just read some libraries (like the IR builder) and scratch my head why such trivial thing must be so obfuscated
17:56:11 <rza> Not the entire "Graph (Map.map v [v])"
17:56:15 <Cale> rza: What do you mean by "chain it to"?
17:56:37 <Cale> rza: Also, I'm pretty sure you mean Map.Map
17:56:42 <davean> pavolzetor: because its litterly removing the parts you *don't have to deal with* and you're looking to see them
17:56:48 <davean> But they're not there
17:56:53 <davean> if you stop looking it'll make more sense
17:57:06 <Cale> (though it might be nicer to "import Data.Map (Map)" so you don't have to qualify the name of the type)
17:57:10 <davean> pavolzetor: you'll never find what doesn't exist
17:57:19 <davean> pavolzetor: and as long as you keep looking you'll remain confused
17:57:49 <pavolzetor> but if most of your code is procedural (anything that does error handling) then what benefit you get by imposing the extra complexity?
17:57:54 <Cale> rza: If your function wants an argument of type v, it still isn't entirely obvious what you're going to do with the Map v [v]
17:58:26 <davean> pavolzetor: You think you need to do error handling the way you have before
17:58:39 <ab9rf> Cale: well, you could iterate over the keys of the map, or over the lists in the values of the map.....
17:58:40 <davean> pavolzetor: you can make a Monad or Transformer that does the error handling for you without you worrying about it for exampel
17:58:42 <Cale> rza: You have a whole bunch of values of type v (the keys of the map, which are the vertices of your graph), and each of them is associated with a list of values of type v, which are presumably the arcs of your graph
17:58:51 <davean> pavolzetor: the fastest code to write is the code you don't have to write
17:58:53 <Cale> (i.e. the neighbours of each vertex)
17:59:00 <Cale> ab9rf: sure...
17:59:05 <davean> pavolzetor: so pick an error handling monad with the semantics you want to handle your errors with
17:59:14 <Cale> rza: Can you describe what you want the program to do in English?
17:59:18 <mniip> ooh huh
17:59:26 <pavolzetor> monad is an imperative code
17:59:26 <mniip> this paper declares parsers backwards
17:59:32 <mniip> pavolzetor, what no
17:59:34 <davean> pavolzetor: Maybe, maybe not
17:59:37 <ab9rf> pavolzetor: no. monads are not "imperative code"
17:59:40 <davean> pavolzetor: but whats your point?
17:59:50 <davean> Monads can look like imperative code at times
17:59:50 <mniip> davean, is that a pun
17:59:55 <ab9rf> pavolzetor: one *possible* use of monads is to simulate imperative-style computation
17:59:57 <davean> mniip: yes
18:00:02 <rza> Say I have a function 'addVertex' that returns "Graph v". I want to "chain" it in the sense that I want to use it in the function addEdge who essentially does Graph (Map.insert a [b] v)
18:00:23 <rza> The thing is that I can't do addVertex inside because it returns "Graph v" and not just "v"
18:00:25 <davean> mniip: I've somewhat given up on what I'm saying getting through and started to have fun with it ... maybe I should leave ;)
18:00:56 <Cale> Wait, what?
18:01:14 <rza> haha :(
18:01:17 <Cale> rza: I'm confused about what your problem is.
18:01:22 <pavolzetor> interesting, can you give example where monad is not imperative?
18:01:25 <Cale> What are you trying to write?
18:01:31 <rza> Ok. Ok.
18:01:34 <rza> Let me start over
18:01:55 <ab9rf> pavolzetor: parser combinator monads are not imperative.
18:01:55 <pavolzetor> davean, my point is, when I see code, I want to know what it is doing
18:02:20 <pavolzetor> I do not follow, can you please elaborate, sorry
18:02:21 <davean> pavolzetor: then don't program Haskell - the point is that you can change that around
18:02:35 <davean> pavolzetor: parser combinators don't say how its parsed
18:02:40 <pavolzetor> I like haskell language, I dislike basically almost all libraries :)
18:02:56 <rza> In designing graphs, I have different functions such as addVertex or addEdges.. Now when the user wants to add a specific edge between two vertices, the function needs to create those vertices first if they dont exist
18:03:09 <mniip> pavolzetor, what's imperative about the "Maybe" monad?
18:03:12 <Cale> okay
18:03:16 <mniip> or the "Reader" monad
18:03:41 <Cale> So, you can write (addVertex a (addVertex b g)) and then do some more stuff to that graph
18:03:45 <pavolzetor> mniip, it is a sequence of steps
18:03:52 <mniip> no it isn't?
18:03:57 <ab9rf> or the List monad
18:04:01 <davean> pavolzetor: In no way is it a sequence of steps
18:04:03 <ab9rf> [a] is a monad
18:04:08 <parsnip> define imperative?
18:04:15 <mniip> List is noncommutative so it has a direction of sorts
18:04:21 <parsnip> else, "everything is imperative"
18:04:45 <ab9rf> mniip: fair enough
18:04:46 <pavolzetor> Just x >> Just y >> Nothing >> Just z
18:05:03 <mniip> 3 + 5 + 2
18:05:04 <parsnip> commutative?
18:05:04 <pavolzetor> that is take step x, then y, then Nothing -> return out
18:05:07 <mniip> I don't see a difference
18:05:19 <davean> pavolzetor: thats what you think it does, ok
18:05:26 <mniip> well, sorry, a better analogoue would be
18:05:29 <parsnip> 3 * 5 * 0 * 9
18:05:29 <mniip> 3 * 5 * 0 * 2
18:05:36 <parsnip> any 0, it is 0. imperative?
18:05:45 <mniip> haha
18:05:48 <parsnip> haha
18:06:01 <ab9rf> it's just math
18:06:03 <parsnip> 9 wins!
18:06:09 * parsnip takes pot
18:06:16 <ab9rf> GIMME MY POT BACK
18:06:17 <davean> pavolzetor: How do you know it doesn't look at Just and then at Nothing?
18:06:30 * parsnip flips table
18:07:01 * mniip flips id
18:07:19 <davean> mniip: I'd like it if you had more points
18:08:06 <pavolzetor> Because the way it is chained
18:08:11 <pavolzetor> with >>=
18:08:22 <parsnip> it's just parens
18:08:41 <davean> pavolzetor: some monads run backwards, some run in both directions
18:08:53 <davean> pavolzetor: how do you know how THAT one runs?
18:09:01 <davean> prove it runs forward
18:09:04 * u-ou flips no-n
18:09:10 <mniip> the monad with the most obvious direction,
18:09:12 <mniip> State
18:09:19 <mniip> actually runs backwards
18:09:19 <pavolzetor> hmm, can you point me to backwards monad, i did not know about it
18:09:22 <ab9rf> hehe
18:09:30 <davean> pavolzetor: State?
18:09:32 <ab9rf> i was wondering when someone would mention that :)
18:09:47 <davean> pavolzetor: The point is that the Monad obays the laws
18:09:47 <mniip> > (`execState` 123) $ do { undefined; put 5 }
18:09:49 <lambdabot>  5
18:09:55 <mniip> puts 5 before executing undefined
18:10:03 <parsnip> https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
18:10:03 <ab9rf> yeah, it doesn't have to evaluate past the _last_ put
18:10:27 <davean> pavolzetor: See, by just having the laws, we got something more efficient
18:10:28 <parsnip> oh, cuz lazy?
18:10:32 <ab9rf> yup
18:10:39 <parsnip> nice
18:10:41 <parsnip> til
18:10:51 <davean> pavolzetor: So, all I can really say is you're being very silly
18:10:59 <davean> pavolzetor: and you should try to have a more open mind
18:11:13 <ab9rf> davean: eh, it's the usual "monads are how you do imperative" misunderstanding
18:11:15 <davean> pavolzetor: you can't learn when you assume the answer
18:11:25 <parsnip> but, it's reasonable for us to _think_ about state in forward direction
18:11:33 <mniip> hmm, what other cool monads are there
18:11:34 <mniip> Select!
18:11:41 <parsnip> and to be honest, until today, i was thinking about Maybe in forward direction.
18:12:14 <ab9rf> parsnip: a lot of monads end up being effectively backwards like that
18:12:23 <parsnip> i like when i join #haskell and someone asks a question that helps me.
18:12:35 <mniip> ab9rf, here's a mindfuck
18:12:39 <mniip> if you've heard of yoctoparsec
18:12:51 <mniip> due to laziness, it's not actually recursive descent,
18:12:57 <ab9rf> mniip: that's funny
18:13:02 <mniip> it's brzozowski language derivative
18:13:25 <parsnip> i hate how obvious haskell makes it that y'all are _waaaay_ smarter than me. but i'll keep liking it anyways.
18:13:54 <ab9rf> mniip: oh wow
18:13:59 <ab9rf> mniip: that's cool as fuck
18:15:38 <pavolzetor> davean, is everything desugared from do notation going backwards?
18:15:44 <mniip> no
18:15:45 <davean> No
18:15:53 <davean> Many Monads run forward BTW
18:15:54 <mniip> IO goes forwards
18:16:08 <davean> You just can't know from the outside
18:16:10 <pavolzetor> so how do you flip the direction?
18:16:13 <davean> Because it can't matter
18:16:17 <davean> *unless you do unsafe things*
18:16:17 <mniip> some monads don't "execute" until evaluated completely
18:16:31 <davean> Some monads never "Execute"
18:16:38 <mniip> ha
18:16:38 <pavolzetor> is it sort of like foldl vs foldr?)
18:16:49 <mniip> Proxy is love Proxy is life
18:17:21 <mniip> pavolzetor, oh yeah btw
18:17:35 <mniip> how does the Cont monad align with your "execution direction" ideas
18:17:56 <davean> mniip: perpendicularly.
18:18:17 <pavolzetor> It is first time I hear about it
18:18:20 <mniip> well
18:18:22 <pavolzetor> so I do not know
18:18:31 <mniip> it is "the" monad for manipulating the execution direction
18:19:38 <pavolzetor> I will read about it tonight, thanks
18:20:11 <mniip> check this out
18:20:13 <mniip> @let puncture' = fmap snd . (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
18:20:14 <lambdabot>  Defined.
18:20:17 <mniip> :t puncture'
18:20:18 <lambdabot> Traversable f => f a -> f (a -> f a)
18:20:52 <mniip> this replaces every element in the structure with a function, applying which yields a structure with that element replaced
18:21:07 <mniip> > fmap ($ 0) $ puncture' [1, 2, 3, 4]
18:21:09 <lambdabot>  [[0,2,3,4],[1,0,3,4],[1,2,0,4],[1,2,3,0]]
18:21:20 <mniip> all orchrestrated by Cont
18:22:08 <pavolzetor> davean, pavolzetor: So, all I can really say is you're being very silly; you are actually right, I am ordering the haskell book; thanks for getting me upset ;)
18:22:09 <mniip> effectively we "yield" the thread of execution mid-traverse, but we can "resume" back into it if we apply the function
18:22:36 <davean> pavolzetor: Its ok, assumptions are how we get through the day without going insane :)
18:22:48 <tolt>  says the insane guy
18:23:27 <davean> Productively insane.
18:23:42 <mniip> I prefer additive insanity
18:23:44 <pavolzetor> mniip, I have no idea, I think I have to read more first
18:23:47 <davean> Well, I'd be productively insane if I could figure out this PlanT transformer
18:24:01 <mniip> what kind of transformer is it
18:24:24 <mniip> (cue kind puns)
18:24:55 <davean> mniip: I'm trying to make a PlanT have access to lamport time
18:25:09 <pavolzetor> davean, I meant it in good way, I know when I get upset that my state of mind was challenged and I learn
18:25:09 <davean> which means sticking a StateT inside it, and wrapping/unwrapping its messages
18:25:59 <mniip> hmm
18:26:10 <mniip> are we talking real threads
18:26:14 <davean> mniip: I'd happily talk to you about it off channel
18:27:32 <mniip> I'm not sure if I'm qualified enough for wasting your time on explaining it to me personally as opposed to letting other folk in the channel join the discussion at will :P
18:30:12 <x0x0_> Hi everyone, i am reading `learn u haskell for greater good` and is on monad's chapter. Aside from reading i would also like to apply my knowledge. Help wanted in that context
18:34:37 <Axman6> x0x0_: that's quite a vague request, monads are very fundamental, so it's hard to tell you how you should apply the concept, because there are literally an infinite number of monads, that each do widly different things
18:35:41 <Axman6> Other may disagree, wut I feel this post does a jgood job of showing the intuition for what monads are, they're things which you can write an andThen function for:  :t puncture'
18:35:59 <Axman6> uh, didn't copy the link... https://codon.com/refactoring-ruby-with-monads
18:36:11 <x0x0_> Axman6: Yup i understand, i will try to contribute through github repos .
18:38:34 <ab9rf> x0x0_: you just missed a discussion of some of the weirder things you can do with a monad, in fact :)
18:46:27 <u-ou> mniip: do you know any good reading or books on lambda calculi (typed and untyped)?
18:50:46 <hololeap> x0x0_, read this and the next blog post in the series: https://bartoszmilewski.com/2016/11/21/monads-programmers-definition/
18:50:59 <Gurkenglas> Axman6, are you sure monads can't be completely classified like groups were?
18:52:02 <Gurkenglas> *finite simple groups
18:52:28 <mniip> u-ou, TaPL?
18:52:44 <mniip> it smells of ML though
18:52:55 <u-ou> ok
18:53:02 <u-ou> someone else suggested that too
18:53:47 <Gurkenglas> What was the name of that alternative to lambda calculus where you have strings in 2D space and reduce them with local rules?
18:53:49 <u-ou> it looks like a good book
18:54:13 <mniip> Gurkenglas, knitting?
18:54:57 <Gurkenglas> That keyword is surprisingly unhelpful for my googling ._.
18:55:30 <Gurkenglas> Wait, you mean literal knitting?
18:56:00 <Gurkenglas> That's in 3D
18:56:40 <u-ou> :O
18:57:09 <monochrom> Knitting in Flatland.
18:59:24 <davean> You can't knit very interesting things in Flatland
19:04:44 <Axman6> Gurkenglas: I have no idea, but I would guess that it's possible to find an infinitely large number of monad instances
19:06:11 <Gurkenglas> Sure, you can take the list monad with concatMap discarding all but the first n elements
19:06:51 <Gurkenglas> (And the data type itself also only allowing up to that many elements, I guess)
19:17:35 <mniip> Gurkenglas, not sure that's a monad
19:17:52 <Gurkenglas> That's what Maybe is for n=1
19:19:46 <mniip> mfilter (either even even) (k >>= \x -> pure (Left x) <|> pure (Right x))
19:20:19 <mniip> mfilter even k >>= \x -> pure (Left x) <|> pure (Right x)
19:20:28 <mniip> I'm getting a feel that the two should be equal
19:26:07 <blankhart> it would help me if someone could give a little color on the explicit forall syntax
19:26:31 <blankhart> why do numeric literals have the type forall a. Num a => a
19:27:00 <blankhart> i am reading https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
19:27:17 <geekosaur> it's not existentially qualified, it's just explciitly showing the implicit top level forall
19:27:39 <geekosaur> foo :: a -> a       is the same as      foo :: forall a. a -> a
19:29:45 <blankhart> i understand the last bit i think, but am not positive i can connect that to the piece about numeric literals
19:29:51 <geekosaur> what's "special" there is the Num a =>
19:30:50 <blankhart> hmm still not getting it.  maybe we can come at it this way - a String literal does not have type forall a. Show a => a
19:30:54 <blankhart> what is the difference
19:30:54 <geekosaur> because a numeric literal is compiled as if it were fromInteger (1 :: Integer)
19:31:26 <geekosaur> and if you turn on OverloadeStrings extension, a string literal is compiled as if it were fromString ("whatever" :: String)
19:31:35 <geekosaur> and has the type IsString a => a
19:31:37 <blankhart> i see, ok
19:31:48 <geekosaur> *OverloadedStrings
19:32:33 <blankhart> that is the bit i was missing, perfect, thank you
19:32:50 <geekosaur> actually...
19:32:52 <geekosaur> :t 1.1
19:32:53 <lambdabot> Fractional p => p
19:33:19 <geekosaur> which is compiled as if it were fromRational (11 % 10)
19:33:38 <geekosaur> (note that yiu have to import Data.Ratio to get (%)
19:38:19 <blankhart> why is the language extension referred to as existential quantification when it involves a universal quantifier?
19:40:49 <geekosaur> because it's normally used in a more restrictive scope, where it limits the name to that scope. existential/universal are related by something related to de Morgan's rule
19:41:26 <geekosaur> and iirc it is harder to implement 'exists' compared to restricted-scope 'forall'
19:43:08 <blankhart> thank you
19:43:41 <geekosaur> iirc uhc (utrecht haskell compiler, pretty much only used by utrecht courses) supports 'exists' as well as 'forall'
19:52:44 <patrickdoc> hi, I'm working on some Criterion internals, and I've run into something I don't quite understand. Here's a pretty small reproduction of it: http://lpaste.net/362516
19:53:41 <patrickdoc> Every so often, an extra ~4k bytes (one page?) is allocated, which throws off the allocation measurements. Is it possible to avoid this?
21:56:17 <mniip> where did the <*> notation originate?
21:58:01 * EvanR begins reviewing http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
21:58:47 <mniip> nope
21:59:06 <mniip> I see it in Fokker, Functional Parsers (1995)
22:00:13 <mniip> but surprisingly not Wadler (1985) How to replace failure with a list of successes
22:00:35 * EvanR begins reviewing https://rkrishnan.org/files/wadler-1985.pdf
22:01:06 <mniip> wadler calls it "app"
22:01:25 <EvanR> somewhere i read that applicative was highly folkloric
22:01:40 <Axman6> you've reminded of this Guy Steel talk, which was far more interesting than I would have expected if I were told what it's about: https://www.youtube.com/watch?v=dCuZkaaou0Q
22:01:47 <mniip> page 11
22:01:49 <Axman6> Steele*
22:02:24 * duckqlz waves thanks to Axman6 for the link
22:02:29 <mniip> EvanR, yeah I notice the uniquitous usage of the same <*> <$> <* *> names with appropriate-but-not-quite-as-general types
22:02:41 <mniip> even as early as 1995
22:03:52 <mniip> hmm
22:04:10 <EvanR> it was probably invented by al gore
22:04:26 <Axman6> mother flippin Al Gore
22:04:50 <mniip> Hutton (1992) Higher-order functions for parsing  uses miranda instead of gofer and so no fancy symbols
22:10:56 <mniip> just trying to evaluate the landscape of the current research in language theory in functional programming
22:11:51 <mniip> looks like String -> [(String, a)] dates back to Wadler in 1985
22:13:12 <mniip> oddly enough, it is manipulated by monomorphic pure/ap
22:13:28 <mniip> whereas in his monads paper it's return/bind only with no mention of pure/ap
22:16:21 <parsnip> "Imagine if Lisp used overlines rather than parentheses...﻿"
22:19:17 <mniip> boxes
22:19:23 <Axman6> what a world it would be
22:23:42 <guesswho> i have to process a text file barely 1.5 mb which api should i use to process it >?
22:23:59 <Axman6> what sort of processing?
22:24:15 <Axman6> I mean, conventional wisdon is use Data.Text unless you have a good reason not to
22:24:59 <EvanR> Text piped through pipes or conduit maybe
22:25:11 <EvanR> if you dont want to load it all into memory at once
22:25:40 <Axman6> but it really does depend on the sort of processing
22:26:13 <cocreature> for 1.5mb just loading it in ram should be fine
22:26:33 <guesswho> Axman6 : i have to extract a tuple from each line & each line have (String,String)
22:27:27 <EvanR> load it all, split into lines, reads each one into a Maybe (String,String)
22:27:38 <Axman6> yep
22:28:18 <guesswho> Axman6 : so data Data.Text ?? what about Data.ByteString >?
22:28:26 <EvanR> > reads "(\"hello\",\"world\")" "" :: [((String,String),String)]
22:28:28 <lambdabot>  error:
22:28:28 <lambdabot>      • Couldn't match expected type ‘[Char]
22:28:28 <lambdabot>                                      -> [((String, String), String)]’
22:28:51 <Axman6> ByteStrings are for strings of bytes. if you know this is text and you want to treat it as text, use Data.Text
22:29:01 <EvanR> > reads "(\"hello\",\"world\")" :: [((String,String),String)]
22:29:03 <lambdabot>  [(("hello","world"),"")]
22:29:18 <EvanR> > reads "(\"hello\",\"wor" :: [((String,String),String)]
22:29:19 <lambdabot>  []
22:30:04 <EvanR> to do this you can unpack each Text line
22:30:08 <u-ou> when are strings of bytes not text (non-rhetorical question)
22:30:28 <EvanR> when its "binary" for instance
22:30:34 <Axman6> when it's TCP packets from the network
22:30:38 <Axman6> when it's compressed data
22:30:50 <Axman6> when it's a NetCDF file
22:31:15 <enterprisey> I'm trying to use megaparsec to parse a stream of lexemes
22:31:21 <enterprisey> for reasons beyond my control, the input stream is not Text, but is [Lex], a list of lexemes
22:31:37 <enterprisey> so I'm trying to use "tokens" to parse a single symbol, but it wants me to give it Tokens [Lex], not [Lex]
22:31:48 <enterprisey> and I have no clue how to make Tokens
22:35:12 <cocreature> enterprisey: you need to provide a Stream instance for [Lex]
22:35:22 <enterprisey> cocreature: I suspected as much
22:35:32 <cocreature> enterprisey: https://github.com/mrkkrp/megaparsec/blob/master/tests/Text/MegaparsecSpec.hs#L1843 might be a helpful example
22:35:46 <enterprisey> !!!
22:35:48 <enterprisey> thank you very much
22:35:57 <cocreature> among other things that instance defines Tokens, so you can just set "type Tokens [Lex] = [Lex]"
22:38:26 <xacktm> Hi, I'm parsing a Maybe Text into a record with a FromJSON instance, where the JSON can be null.  Is it redundant to say `field <- o .: "field" .!= Nothing` or will `field <- o .: "field"` handle the null as well?
22:39:01 <heptahedron> xacktm: try `(.:!)`
22:39:14 <heptahedron> er, `(.:?)` I think
22:39:48 <heptahedron> one of those
22:40:28 <cocreature> xacktm: https://hackage.haskell.org/package/aeson-1.2.4.0/docs/src/Data-Aeson-Types-FromJSON.html#line-1166
22:40:50 <cocreature> eh actually that was stupid, ignore me
22:40:55 <xacktm> yup looking atm
22:41:04 <xacktm> well at the haddocks
22:41:10 <xacktm> not the source heh
22:41:59 <cocreature> iirc (.:) will give you back Nothing if the value is null but it will fail if the key is not present
22:42:11 <cocreature> (:.?) will give you back Nothing in both cases
22:42:34 <cocreature> and (.:!) will only give you back Nothing if the key is not present
22:42:52 <gestone> so i'm trying to make an app with yesod that connects with a DB. what's the recommended approach for how to structure the project? my hunch is that the business logic should belong in a separate module which should compose of mainly pure functions so they're simple to test but then comes the issue of what if i want to connect to the DB
22:43:03 <cocreature> note that this changed 1-2 years ago so make sure you are using a reasonably new version of aeson
22:43:38 <gestone> is it... bad practice to have impure functions in the modules with business logic since they're harder to test?
22:43:41 <xacktm> ok thansk guys I think I want (.:?), and yep I'm using aeson from nix
22:44:06 <EvanR> IO specifically is harder to test
22:44:23 <EvanR> but why cant it be in the module
22:45:01 <gestone> just thinking about testing
22:45:33 <gestone> it could be in the module, but i was just wondering how *much* is it to test a function that returns an IO?
22:45:42 <gestone> *much harder
22:45:59 <cocreature> depends on the kind of IO that the function does
22:46:33 <EvanR> if it contacts a live API using live keys you need what, to set up a fake internet
22:46:35 <cocreature> if it accesses the DB you need to connect to a test DB but that’s not particularly hard
22:47:45 <gestone> yeah, i was thinking about how to test the functions in isolation without connecting to a db
22:48:19 <gestone> i know in langs like java there are libs like mockito so it's easy to mock repositories
22:48:42 <gestone> i was just wondering if there's any equivalent in haskell
22:49:19 <enterprisey> cocreature: so everything I use in an input stream for a parser must have a Stream instance?
22:49:26 <cocreature> enterprisey: yep
22:49:30 <EvanR> if you want to test it in isolation, then dont use IO
22:49:34 <enterprisey> alright, good to know!
22:49:42 <EvanR> separate out the testable part
22:50:01 <gestone> got it
22:51:19 <gestone> EvanR: so do you think that it'd be bad to have those pure functions to take in functions as arguments that return IO?
22:51:28 <gestone> that was another solution i was thinking of
22:51:51 <cocreature> gestone: one solution is to have something like http://lpaste.net/362521 and then let your function take this as an argument
22:51:56 <gestone> so something like f g = ... where g has type of let's say Int -> IO Int
22:52:06 <gestone> and then it's easy to mock g
22:52:10 <gestone> in the tests
22:52:30 <gestone> since we could just package an Int in IO with return right?
22:52:56 <gestone> cocreature: ohh
22:53:07 <gestone> cocreature: so in the tests, m could just be the Identity monad then?
22:53:46 <cocreature> depends on what you want to test, you could also use some kind of writer and log all db queries or whatever
22:53:55 <EvanR> if youre rewriting all your code to work with any monad... now sure what these tests gain
22:54:55 <cocreature> however, ime for most code that accesses a DB the thing you want to test is if it works with the DB so there is not much point in mocking the DB
22:55:48 <gestone> cocreature: yeah i was thinking about just the surrounding business logic around that code independent of the DB call
22:56:31 <cocreature> gestone: I would just separate the business logic in a pure function that takes the data you want from the DB as input instead of accessing the DB itself
22:56:40 <gestone> i feel like i'm so used to interleaving functions that execute side effects and the actual business logic from java
22:56:58 <dminuoso> :t unfoldr
22:57:00 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:57:07 <dminuoso> Is there a way for unfoldr to make sense without that Maybe?
22:57:16 <enterprisey> cocreature: I'm getting funny errors trying to make [Lex] an instance. I can't do it with [a], right?
22:57:41 <dminuoso> That Maybe just looks to be in the way when flipping arrows around. :(
22:57:45 <gestone> cocreature: fair enough, i feel like that's the better solution
22:57:46 <enterprisey> Specifically, "Illegal family instance for ‘Tokens’" for type Token [Lex] = Lex
22:58:13 <cocreature> enterprisey: can you show us the full code and the full error?
22:58:25 <enterprisey> sure
22:59:21 <enterprisey> cocreature: http://lpaste.net/362522
22:59:40 <cocreature> enterprisey: just listen to the error message: you need to enable TypeFamilies :)
22:59:47 <enterprisey> I heard that was bad
22:59:58 <cocreature> where did you hear that
23:00:06 <EvanR> type families are boss awesome
23:00:09 <enterprisey> well, less bad than a bit confusing
23:00:33 <enterprisey> is there an easy explanation of why I need to enable that?
23:00:38 <cocreature> TypeFamilies are among the GHC extensions that are not particularly controversial
23:00:54 <enterprisey> okay
23:00:56 <cocreature> well you are defining a type family so you need to enable TypeFamilies
23:01:19 <enterprisey> I thought I was just providing a typeclass instance
23:01:42 <cocreature> right, but typeclasses can have associated type families, in this case Token and Tokens
23:01:47 <enterprisey> I see
23:05:51 <dminuoso> Is there a way to reflect on a type size? Specifically I want some way to obtain Word64 -> 64
23:06:10 <dminuoso> (And that way to work with any type representing numbers)
23:07:02 <dminuoso> Ohh. Nevermind, finally found it =)
23:07:05 <dminuoso> :t finiteBitSize
23:07:06 <EvanR> you can use type classes, and note that Storable has a method like this
23:07:06 <lambdabot> FiniteBits b => b -> Int
23:07:23 <EvanR> > finiteBitSize Word64
23:07:25 <lambdabot>  error: Data constructor not in scope: Word64
23:07:37 <EvanR> > finiteBitSize (Proxy :: Word64)
23:07:39 <lambdabot>  error:
23:07:39 <lambdabot>      • Couldn't match expected type ‘Word64’ with actual type ‘Proxy t0’
23:07:39 <lambdabot>      • In the first argument of ‘finiteBitSize’, namely
23:07:51 * EvanR explodes
23:08:08 <dminuoso> >  finiteBitSize (undefined :: Word64)
23:08:10 <lambdabot>  64
23:08:23 <EvanR> :t proxy
23:08:24 <lambdabot> error:
23:08:25 <lambdabot>     • Variable not in scope: proxy
23:08:25 <lambdabot>     • Perhaps you meant data constructor ‘Proxy’ (imported from Data.Typeable)
23:08:33 <mniip> what are ekmett's free monads, categorically?
23:08:37 <EvanR> the undefined hack is annoying
23:08:43 <mniip> left adjoint to the forgetful Mnd(C) -> End(C) functor?
23:09:11 <dminuoso> mniip: https://stackoverflow.com/a/13352580 from edward himself =)
23:10:00 <dminuoso> EvanR: Well you could probably just pass a 0 into there.
23:10:15 <dminuoso> > finiteBitSize (0 :: Word64)
23:10:16 <lambdabot>  64
23:10:33 <EvanR> also annoying
23:10:46 <dminuoso> Because you dont want to be talking about a value at all?
23:11:02 <EvanR> in the case of 0 i dont want to be dealing with a value at runtime
23:11:21 <EvanR> in the case of undefined, its too long and indicate something else
23:11:32 <EvanR> proxy is better
23:13:47 <woodson> can anyone tell me why this function getAll . foldMap (const (All False)) []
23:13:50 <woodson> returns True?
23:14:00 <woodson> isnt it supposed to be False
23:14:11 <woodson> because of it will always be return All False?
23:14:46 <opqdonut> True is the mzero of All
23:15:11 <opqdonut> and you're basically doing a `mconcat []` which is `mzero`
23:15:12 <cocreature> more like the mempty :)
23:15:17 <opqdonut> sorry
23:15:20 <opqdonut> always mix those up :(
23:15:22 <opqdonut> yeah, mempty
23:15:28 <opqdonut> neutral element
23:20:16 <woodson> opqdonut, hmm I get that based on the definition of foldable it will return mempty so you are saying
23:20:35 <woodson> that the foldable is return an mempty :: [All] ??
23:20:48 <parsnip> > Nothing <> Just "3"
23:20:49 <lambdabot>  Just "3"
23:20:53 <parsnip> > Nothing >> Just "3"
23:20:54 <lambdabot>  Nothing
23:22:54 <cocreature> woodson: no mempty :: All
23:23:55 <woodson> cocreature: Ya, messed that up. been playing with list for soo long now
23:24:06 <woodson> but ya thats what I meant
23:24:37 <woodson> thanks
23:30:42 <enterprisey> I'm getting this megaparsec error: http://lpaste.net/362523
23:30:58 <enterprisey> Not sure what the "forall" business is about
23:32:49 <enterprisey> Nevermind, fixed it
23:32:59 <EvanR> :r
23:33:02 <EvanR> dangit
23:33:58 <enterprisey> never fear, I have another dumb question
23:34:02 <mniip> ok so
23:34:17 <enterprisey> can someone explain (<$)?
23:34:30 <cocreature> enterprisey: do you know fmap?
23:34:34 <enterprisey> yeah
23:34:51 <cocreature> a <$ b = fmap (const a) b
23:35:01 <cocreature> or if you’re not familiar with const: fmap (\_ -> a) b
23:36:21 <mniip> then what is a free monad transformer
23:36:23 <EvanR> overwrite each "location" in b with a
23:37:12 <EvanR> > 'z' <$ [1,2,3,4]
23:37:13 <lambdabot>  "zzzz"
23:37:16 <mniip> left adjoint to forgetful functor from monad transformers to...?
23:37:21 <EvanR> > 'z' <$ Just 99
23:37:22 <lambdabot>  Just 'z'
23:37:49 <enterprisey> hmm
23:37:57 <heptahedron> I just put the start of my first haskell lib on github! https://github.com/heptahedron/vinyl-json
23:38:02 <enterprisey> I'd have thought it's more intuitive for the angle bracket to point the other way
23:38:06 <enterprisey> towards the structure we're modifying
23:38:08 <EvanR> me too actually
23:38:17 <enterprisey> such is life
23:38:31 <dminuoso> enterprisey: The forall business is about this: Whenever you declare a polymorphic function such as : [a] -> [[a]], the problem is what exactly is `a` ?
23:38:35 <mniip> it takes the value from where the angle bracket is pointing
23:38:38 <mniip> cf <* *>
23:38:45 <enterprisey> mniip: ah, thanks
23:38:48 <EvanR> backwards arrow phenomenon
23:38:57 <EvanR> its a contravariant arrow
23:39:06 <enterprisey> category theory strikes again
23:39:07 <EvanR> from <- to
23:39:16 <dminuoso> enterprisey: So if you write `f :: [a] -> [[a]]` it actually means: `f :: forall a. [a] -> [[a]]`, so "for every type a" =)
23:39:20 <EvanR> hunter gatherers everywhere cringe
23:39:33 <enterprisey> dminuoso: thanks for the explanation!
23:40:03 <dminuoso> enterprisey: If you are familiar with first order logic, you could also write it as: f :: ∀a. [a] -> [[a]]
23:40:14 <enterprisey> ugh, curry-howard
23:40:21 <enterprisey> (well, sort of :p)
23:40:34 <dminuoso> enterprisey: Note that if you wanted to write them explicitly you first need to enable at least the extension ExplicitForAll, and for the second also UnicodeSyntax.
23:41:12 <heptahedron> could anyone experienced with vinyl/handy with type magic help me figure out how to convert the `JsonField` type in https://github.com/heptahedron/vinyl-json/blob/master/src/Data/Vinyl/Json.hs to a `V.ElField`
23:41:35 <guesswho> any suggestions fro conf package
23:41:48 <guesswho> cale : any suggestion for conf package
23:53:27 <mniip> aha
23:55:08 <dminuoso> enterprisey: You can also create higher rank types (requiring an additional extension) with this. For example: foo :: (forall a. [a] -> [a]) -> (String,[Integer])
23:58:28 <mniip> hmmmm
