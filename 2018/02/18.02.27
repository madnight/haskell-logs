00:04:04 <dcoutts> jle`, batman_: yes the cborg and serialise packages are quite good IMHO. We're using them in all sorts of commercial applications.
00:05:36 <dcoutts> because we're using them in these applications the two libs are getting a fair bit of scrutiny, which has turned up some issues but those are getting fixed
00:14:12 <kuribas> If I run more threads than the system can handle (memory full for example), will it simply delay those threads, or crash them?
00:22:55 <sayola> hello, i want to generalize RandT for MonadRandom in: RandT StdGen Maybe (Id,[App])
00:22:55 <sayola> Maybe needs to stay of type Maybe. i dont know how to rewrite it, so that it works. hints?
00:24:14 <cocreature> sayola: does it really need to stay Maybe or do you just need the behavior of Maybe, i.e., short circuiting?
00:25:14 <sayola> if i dont want to rewrite an entire codebase, it has to stay Maybe. :|
00:26:17 <cocreature> you could do something like "MonadRandom (t Maybe) => t Maybe (Id, [App])"
00:27:12 <cocreature> although I would generally go for "MonadError () m, MonadRandom m => m (Id, [App])" and then write a "MonadError () m => Maybe a -> m a" function that lifts your existing code that operates on Maybe
00:27:46 <sayola> wow yes it works
00:29:14 <sayola> yeah maybe i should rewrite the codebase. thank you. :D
00:33:47 <ertes-w> helo
00:35:43 <ertes-w> sayola: you can avoid that kind of refactoring by not specialising
00:36:08 <ertes-w> sayola: turn (Maybe X) into (Alternative f => f X)
00:37:31 <sayola> things confuse me quickly when generalizations pile up. especially the ghc messages can get too cryptic for my taste.
00:37:55 <ertes-w> @let isqrt x = foldr (\(r, s) rs -> case compare s x of EQ -> pure r; GT -> empty; LT -> rs) undefined (iterate (\(r, s) -> (r + 1, s + 2*r + 1)) (0, 0))
00:37:57 <lambdabot>  Defined.
00:38:00 <ertes-w> :t isqrt
00:38:01 <lambdabot> (Ord a, Alternative f, Num a) => a -> f a
00:38:02 <batman_> batman
00:38:21 <ertes-w> > map isqrt [0..]
00:38:23 <lambdabot>  error:
00:38:23 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M871610326133...
00:38:23 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
00:38:32 <ertes-w> > map isqrt [0..] :: [Maybe Integer]
00:38:34 <lambdabot>  [Just 0,Just 1,Nothing,Nothing,Just 2,Nothing,Nothing,Nothing,Nothing,Just 3...
00:38:51 <ertes-w> sayola: ^ example…  notice that i used 'pure' instead of Just and 'empty' instead of Nothing
00:39:09 <ertes-w> otherwise the type would be:  isqrt :: (Ord a, Num a) => a -> Maybe a
00:39:14 <sayola> i also use some function from Data.Maybe. :o
00:39:25 <sayola> *functions
00:42:04 <karuppiah7890> Hello everyone
00:42:06 <karuppiah7890> :)
00:44:05 <karuppiah7890> So me and my friends are learning haskell. And a friend had this question. He was learning about ranges. He did this : [3, 3 .. 30]
00:44:58 <karuppiah7890> It started throwing an infinite 3s like "[3, 3, 3, 3" and so on
00:45:03 <merijn> karuppiah7890: I computes the increment by subtracting the second number from the first
00:45:09 <karuppiah7890> yes
00:45:19 <merijn> karuppiah7890: [3,3...] computes an increment of 0, so it repeats infinitely
00:45:54 <karuppiah7890> but isn't that weird ? isn't haskell supposed to stop at some point and tell it's infinite and give some warning or error
00:45:55 <anohigisavay> hi
00:46:22 <anohigisavay> so i did this in ghci: chan <- newChan
00:46:41 <merijn> karuppiah7890: why?
00:46:42 <anohigisavay> and :t chan gives `chan :: Chan GHC.Types.Any`
00:47:17 <anohigisavay> why is it not `chan :: Chan a` or something?
00:47:28 <merijn> > let ones = 1 : ones in ones
00:47:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:47:39 <merijn> karuppiah7890: Having infinite lists is perfectly fine in Haskell
00:47:46 <karuppiah7890> okay
00:47:55 <karuppiah7890> Didn't know that
00:48:18 <karuppiah7890> thanks merijn :)
00:48:27 <opqdonut> anohigisavay: ghci does defaulting
00:48:56 <karuppiah7890> btw, what freenode client can we use other than the web client ? I am using Mac
00:50:25 <opqdonut> anohigisavay: for example, "mempty :: Monoid a => a", but if you run "mempty" in ghci you get "()"
00:50:32 <kuribas> how can you ensure not to spawn threads that will use more than the available amount of resources?
00:50:41 <batman_> how to derive a class for a data type which is declared in another module or file or lib ???
00:50:58 <kuribas> batman_: you mean instance?
00:51:24 <batman_> for example i have a data type from Network.Socket and i have to derive Generic instance for that data type how do i do that ?
00:51:27 <merijn> kuribas: There's not really a way, but also, threads are way cheap, so that seems an unlikely scenario in the first place
00:51:48 <kuribas> merijn: not if each thread allocates memory?
00:52:01 <kuribas> merijn: by doing useful work?
00:52:10 <anohigisavay> opqdonut, if i run `let x = mempty` and check its type it's `x :: Monoid a => a`
00:52:10 <ertes-w> sayola: which ones?
00:52:49 <merijn> kuribas: What, exactly, are you doing that this is an issue?
00:53:30 <kuribas> merijn: I was just thinking about how to implement caching for a multiuser web application.
00:53:33 <sayola> ertes-w: checked, actually just listToMaybe and catMaybes. guess i could find or write replacements for them.
00:54:04 <kuribas> merijn: setting an arbitrary limit on the number of cached values seems a bit crude.
00:54:05 <batman_> anyone familiar with serialise library ??
00:54:09 <opqdonut> anohigisavay: hmm now that I rethink, this is probably because you use <-
00:54:29 <ertes-w> sayola: yes, definitely…  'listToMaybe' can easily be generalised to Alternative and written in terms of foldr to even get rid of lists
00:54:47 <ertes-w> :t foldr (const . pure) empty
00:54:48 <lambdabot> (Alternative f, Foldable t) => t a -> f a
00:54:52 <merijn> kuribas: Anything more advanced is going to be super annoying and complicated to implement, tbh
00:55:06 <opqdonut> anohigisavay: if the type was `Chan a`, you could `writeChan chan True` and then `readChan (chan :: Chan Int)`
00:55:06 <kuribas> merijn: more advanced than an arbitrary limit you mean?
00:55:23 <ertes-w> sayola: in fact this function even covers both directions =)
00:55:31 <anohigisavay> opqdonut, yes i think you're correct
00:55:45 <opqdonut> anohigisavay: this isn't possible in normal code since >>= doesn't have a rank-2 type
00:55:47 <ertes-w> sayola: listToMaybe = maybeToList = foldr (const . pure) empty
00:56:04 <opqdonut> anohigisavay: so ghci does defaulting to keep you safe, or something
00:56:08 <sayola> impressive :o
00:56:25 <merijn> kuribas: yeah
00:56:25 <kuribas> merijn: I had the idea that load balancers would monitor memory usage, but then again I don't know so much about them...
00:56:29 <dminuoso> karuppiah7890: How would Haskell know whether a list is infinite or not?
00:56:48 <dminuoso> karuppiah7890: It can't possibly do that generally without solving the halting problem.
00:57:13 <MacSlow> Does one get better compile time and/or resulting code if compiling ghc with -O2 vs default -O ?
00:57:31 <ertes-w> :t concatMap toList
00:57:33 <lambdabot> error:
00:57:33 <lambdabot>     Ambiguous occurrence ‘toList’
00:57:33 <lambdabot>     It could refer to either ‘F.toList’,
00:57:35 <karuppiah7890> dminuoso: may be by finding the step and checking the last element and seeing if it can possibly be infinite. not sure though
00:57:36 <ertes-w> :t concatMap F.toList
00:57:38 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 b) -> [b]
00:57:49 <dminuoso> karuppiah7890: Let me show you what a list looks like.
00:57:56 <ertes-w> sayola: ^ and this is catMaybes
00:58:00 <anohigisavay> opqdonut, cool thanks :)
00:58:18 <dminuoso> karuppiah7890: Evaluating the spine works like this: https://gist.github.com/dminuoso/10327213b236eb39ea1a70b791ca32c7
00:58:30 <ertes-w> sayola: and concat as well
00:58:34 <dminuoso> karuppiah7890: At each step you just see a thunk in front of you. You have absolutely no way of knowing whats inside the thunk except by evaluating it.
00:58:39 <opqdonut> anohigisavay: btw this is also the reason you shouldn't do "chan :: Chan a; chan = unsafePerformIO newChan"
00:59:02 <dminuoso> karuppiah7890: So an infinite list is one that endlessly generates more (:) with thunks on the rhs.
00:59:03 <pplorins> Hi all ,  I don't understand the meaning of (>>) in monad definition :
00:59:09 <merijn> MacSlow: Depends on the code
00:59:19 <pplorins> x >> y = x >>= \_ -> y
00:59:20 <ertes-w> sayola: because for lists (toList = id), so (concatMap toList = concatMap id = concat)  -- i'll leave it to you as an exercise to figure out while the latter follows from the monad laws =)
00:59:35 <dminuoso> pplorins: >> simply doesn't feed the result into the next, but sequences them still.
00:59:35 <ertes-w> s/while/why/
01:00:01 <dminuoso> pplorins: for example: `getLine >> putStrLn "hi"` will first require user input, throw the result away and then print.
01:00:44 <karuppiah7890> dminuoso: woah, okay. I gotta read more upon that. Thanks! :)
01:01:00 <anohigisavay> opqdonut, i did that in GHCi and when i ran readChan i got everything in type Any
01:01:22 <opqdonut> anohigisavay: yeah ghci does it differently, but if you do that in a .hs file
01:01:23 <anohigisavay> opqdonut, it didn't crash though
01:01:31 <opqdonut> anohigisavay: you can use read/write to do unsafeCoerce
01:01:42 <MacSlow> merijn: being a beginner still, I don't have any code that would benefit from it, but I like to get to know the platform as I move along and was wondering, while getting ghc 8.2.2 for my machines
01:02:35 <pplorins> @dminuoso , but if we don't wanna feed the result into the next , we can just don't write it , like directly write puStrLn "hi" in your example. Why we still need >> ?
01:02:36 <lambdabot> Unknown command, try @list
01:02:55 <sayola> ertes-w: i need moar tea now. the head smokes.
01:03:01 <dminuoso> pplorins: Lets talk about IO specifically for a moment.
01:03:08 <dminuoso> pplorins: Each IO action generates a result. _each_
01:03:10 <dminuoso> Even putStrLn
01:03:25 <dminuoso> pplorins: How do you sequence two `putStr "Hi"` actions?
01:03:57 <batman_> what is the difference between type & newtype ??
01:04:17 <dminuoso> batman_: they have different representations at compile time.
01:04:28 <dminuoso> batman_: a newtype acts as a wrapper, while type is just a synonym
01:04:35 <dminuoso> At runtime they are the same however.
01:04:43 <MacSlow> batman_: afaik type is just an alias for an existing type-name... on src-level
01:05:05 <dminuoso> batman_: So if you declare some `type A = Int`, you can pass an Int even if it asks for an A.
01:05:15 <kuribas> dminuoso: haskell doesn't care if a list is finite or infinite.
01:05:16 <ertes-w> sayola: consider that Maybe is similar to a bounded list type, so if you think of [Maybe A] as [[A]], then it should be obvious why catMaybes is really just a form of 'concat', and why it's reasonable to expect that there exists a function that covers both
01:05:28 <dminuoso> kuribas: > karuppiah7890
01:05:37 <batman_> dminuoso : got it
01:05:39 <pplorins> @dminuoso  Oh , so you mean >> just provide a way for us when we just want sequence something and don't care about whethere they are needed to be sequenecd or not ?
01:05:39 <lambdabot> Unknown command, try @list
01:05:44 <kuribas> dminuoso: right
01:06:00 <batman_> dminuoso : is it part of prelude ??
01:06:14 <dminuoso> batman_: It's part of the language itself actually.
01:06:47 <kuribas> pplorins: a >> f is the same as a >>= \_ -> f.  It discards its argument.
01:07:01 <kuribas> @src (>>)
01:07:02 <lambdabot> m >> k = m >>= \_ -> k
01:07:15 <ertes-w> sayola: that also explains how the function (concatMap toList) works:  concatMap toList = concat . map toList  -- first convert each inner Maybe to a list, then concatenate the resulting list of lists
01:07:24 <pplorins> @kuribas , Yes I know . But why not just write f.
01:07:25 <lambdabot> Unknown command, try @list
01:07:33 <sayola> ertes-w: i was thinking about using list monad in the first place, as i had an issue fit for it. but then everything got confusing and things didnt work and i just sticked to Maybe.
01:07:41 <dminuoso> pplorins: Because then you have to specify a lambda.
01:07:51 <dminuoso> pplorins: >>= specifically wants something of the shape (a -> m b)
01:08:01 <kuribas> pplorins: f instead of \_ -> f ?
01:08:04 <sayola> and maps in maps.
01:08:10 <pplorins> @kuribas Yes.
01:08:10 <lambdabot> Unknown command, try @list
01:08:12 <kuribas> pplorins: they're not the same
01:08:14 <dminuoso> pplorins: But what if your action does not depend on an argument? What if you just want `putStr "HI"` without caring what the previous actions result is.
01:08:49 <ertes-w> sayola: well, the list monad is basically the concatMap monad…  so the more you learn to utilise concatMap the more natural the list *monad* will become to you
01:09:10 <dminuoso> pplorins: In do-notation each line corresponds to a monad, in this case an IO action. Each time you use <- it's desugared into >>=. If you don't use any <-, it's desugared into >>
01:09:37 <kuribas> pplorins: for example: 1 is not the same as (\_ -> 1)
01:09:44 <sayola> ertes-w: i used to write prolog, which is a bit like list monad.
01:10:09 <ertes-w> sayola: let me give you a little exercise:  write 'filter' using the following template:  myFilter p = concatMap _  -- fill in the _
01:10:13 <kuribas> sayola: https://hackage.haskell.org/package/logict
01:10:28 <pplorins> @dminuoso , Thanks I think I understand better now .
01:10:28 <lambdabot> Unknown command, try @list
01:12:09 <batman_> http://lpaste.net/362939 , can somebody explain me the last line i.e comment in this
01:13:00 <batman_> where it says num instance does it mena a = 7000 :: PortNumber ???
01:13:10 <batman_> mean*
01:13:14 <sayola> kuribas: i did try to understand logict years ago. i didn't try again yet.
01:13:33 <vaibhavsagar> batman_: yes, I think so
01:13:38 <dminuoso> batman_: Check the documentation at https://hackage.haskell.org/package/network-2.6.3.3/docs/Network.html
01:13:40 <dminuoso> It lists examples.
01:13:55 <ertes-w> sayola: focus on understanding the list monad first…  logict will make a lot more sense once you do
01:13:56 <kuribas> sayola: there is also the curry language, which is basicly a mix of haskell and prolog
01:13:57 <dminuoso> batman_: Or the documentation above in the code.
01:14:31 <dminuoso> ertes-w: Oh goodie! A new monad for me to create.
01:14:34 <dminuoso> :t Logic
01:14:35 <lambdabot> error: Data constructor not in scope: Logic
01:14:57 <dminuoso> logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a
01:15:00 <batman_> dminuoso : but when i use constructor PortNumber it says it doesn't exist but a :: PortNumber works
01:15:11 <ertes-w> dminuoso: there, you basically already defined it =)
01:15:33 <ertes-w> in fact LogicT is little more than that
01:15:39 <sayola> ertes-w: i do understand list monad well. its just that some problems are too complicated to touch them with also complicated generalizations first imho.
01:15:47 <vaibhavsagar> batman_: the constructor doesn't exist but the type does
01:16:15 <geekosaur> batman_, what this basically means is that if you use an integer literal in a context that requires a value of type PortNumber, it will be interpreted as such
01:16:20 <geekosaur> which is what a Num instance does
01:16:23 <ertes-w> sayola: it takes a while to get used to it, if you've only ever written specialised code before, but the payoff is massive
01:16:33 <batman_> vaibhavsagar : but i need constructor to write a serialise instance of it
01:16:40 <dminuoso> sayola: How many other monads do you understand?
01:17:06 <dminuoso> sayola: I didn't grasp monads until I rolled 5 completely different ones or so, because you dont see the abstraction if you just look at a single monad.
01:17:40 <sayola> ertes-w: i usually try to use generalizations first. but when problems show up, i break them down to better understand the issue. and then i build up the generalizations afterwards.
01:17:41 <geekosaur> I would hope that you can serialize as an Integer and deserialize with fromInteger
01:17:57 <geekosaur> there are machine dependencies in the internal representation of a PortNumber
01:18:09 <ertes-w> sayola: two of the key benefits of polymorphic code is safety (it may sound paradoxical, but reasoning about polymorphic code is *much* easier than about specialised code) and easier refactoring/reusability
01:18:15 <geekosaur> so serializing one literally is not portable; you want to go through an Integer
01:18:23 <dminuoso> ertes-w: Woah! `Logic a -> a` - could I roll a Comonad instance for this?
01:18:47 <ertes-w> dminuoso: (Logic a -> a) doesn't really make sense
01:19:03 <dminuoso> ertes-w: And yet `observe :: Logic a -> a`
01:19:14 <ertes-w> dminuoso: that's a partial function
01:19:15 <batman_> i get this : http://lpaste.net/362940 when i try to user PortNum
01:19:21 <ertes-w> dminuoso: it's basically 'head'
01:19:35 <dminuoso> ertes-w: Ah. Well I guess Ill just write down the instances. :)
01:19:48 <ertes-w> dminuoso: to answer your question, no Logic is not a Comonad =)
01:19:58 <geekosaur> ok, you still insist on direct serializatrion. Any way we can convince you that serializing an inherently mahcine dependent value does not work?
01:20:00 <ertes-w> err
01:20:04 <ertes-w> dminuoso: to answer your question, no, Logic is not a Comonad =)
01:20:12 * ertes-w . o (what difference a comma can make…)
01:20:46 <geekosaur> (and no, PortNum is a bad idea there. you will run into that machine dependent representation, it expects the machine dependent internal value)
01:21:07 <geekosaur> serialize it as Integer, deserialize it with fromInteger
01:21:34 <ertes-w> dminuoso: however, NonEmpty is a comonad, so:  newtype Truth a = Truth { runTruth :: forall r. (a -> r -> r) -> (a -> r) -> r }
01:21:34 <geekosaur> or it is liable to use the wrong port when you go tyo use it
01:21:40 <ertes-w> dminuoso: Truth is a comonad
01:21:51 <ertes-w> dminuoso: (it's a terrible name, but i couldn't think of a better one)
01:22:06 <dminuoso> ertes-w: Yeah, I figured that NonEmpty had to be a Comonad, since the partiality of `head` seemed to be the one thing preventing it to be.
01:22:50 <ertes-w> dminuoso: comonads also have laws, so it's not quite right to conclude that all you need is non-emptiness…  but yeah, in this case it works out
01:23:00 <dminuoso> Without knowing there was a type NonEmpty. In my mind it was [a] \ {[]
01:23:04 <dminuoso> \{[]}
01:23:25 <dminuoso> ertes-w: Yeah. I've worked out the laws before so, it was just just about having access to `w a -> a`
01:23:29 <dminuoso> *was not
01:23:43 <dminuoso> ertes-w: Btw, is it possible that Edward picked `w` to mean a flipped around `m` ?
01:23:53 <dminuoso> Ive been wondering about the particular choice of the type variable for a while now.
01:24:06 <dminuoso> :t extract
01:24:07 <lambdabot> error: Variable not in scope: extract
01:24:14 <ertes-w> dminuoso: it comes down to being able to duplicate the layer in a "reconstructible" way…  in a sense
01:24:18 <sayola> ertes-w: btw. i'm terrible. heh. > myFilter p = concatMap (\x -> if p x then [x] else [])
01:24:23 <ertes-w> dminuoso: and yeah, it's an upside down m =)
01:24:26 <AWizzArd> Is there a Haskell data type that is like lists in dynamically typed languages, such as Python or Lisp?  So that I can have lists that include numbers or sublists?  [10, 20, [[30, 40], 50], 60]
01:24:36 <phz_> hey
01:24:46 <sayola> there is certainly a formfitting function for it. just about finding it.
01:24:51 <phz_> imagine I have a lens that gives me a value of a given type
01:25:05 <phz_> I’d like to get a few of its record and store them in a tuple
01:25:09 <phz_> is that hard to do with lens?
01:25:49 <ertes-w> sayola: that's correct…  do you see how to generalise its type to (myFilter :: (Monad m, Alternative m) => (a -> Bool) -> m a -> m a)?
01:26:04 <geekosaur> AWizzArd, not really. there's HList but... well, go look at it. I don;t recommend it unless you *really* need that. A custom ADT wrapping lists is probably better (or the quick and dirty version: Either a [a])
01:26:06 <ertes-w> sayola: right now it has the same type as 'filter'
01:26:26 <vaibhavsagar> AWizzArd: it looks like you might want a rose tree type instead
01:26:40 <geekosaur> AWizzArd, of recognize that what you actually have there is a tree, and use an appropriate tree type
01:26:45 <geekosaur> *or recognie
01:26:49 <geekosaur> gleh
01:27:05 <AWizzArd> I redid a simple tree search in Haskell and rolled my own tree type. A puzzle that I solved with a pythoniast friend.
01:27:35 <ertes-w> AWizzArd: rose trees are predefined in containers/Data.Tree
01:27:41 <AWizzArd> Of course the Haskell code is full of boilerplate code because Python ships with such lists while Haskell doesn’t. So I thought I may be able to shrink some code by reusing an already existing type.
01:28:01 <vaibhavsagar> heh, boilerplate
01:28:25 <kuribas> AWizzArd: I'd like to see that code.  In my experience, haskell is much more concise.
01:29:17 <kuribas> AWizzArd: "such lists", means what exactly?
01:29:29 <vaibhavsagar> kuribas: heterogenous lists
01:29:36 <kuribas> oh...
01:29:39 <AWizzArd> kuribas:  http://lpaste.net/1991261325073842176
01:30:16 <AWizzArd> kuribas: of course, the core functionality in Haskell is as short as the Python version. But in Haskell I also need to create the data structure first. The Python code is in essence 2 lines.
01:30:28 <dminuoso> AWizzArd: You forgot to hide the hundreds of lines of tests that validate the correctness of your code.
01:30:44 <AWizzArd> The helper removes a level of nesting (and is thus inefficient).
01:30:57 <kuribas> AWizzArd: Data.Tree is part of containers.
01:31:01 <ertes-w> @let import Data.Tree
01:31:02 <lambdabot>  Defined.
01:31:06 <AWizzArd> dminuoso: sure, we are aware of this. But for this two line program it’s really fine to use scripting as well.
01:31:06 <kuribas> AWizzArd: which is pretty much standard.
01:31:21 <ertes-w> oh, wait…  Data.Tree doesn't quite work
01:31:24 <ertes-w> @undef
01:31:24 <lambdabot> Undefined.
01:31:56 <ertes-w> @let data Tree a = Branch [Tree a] | Leaf a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
01:31:57 <lambdabot>  .L.hs:158:23: error:
01:31:58 <lambdabot>      Ambiguous occurrence ‘Tree’
01:31:58 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
01:32:08 <ertes-w> @let data Tree' a = Branch [Tree' a] | Leaf a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
01:32:10 <lambdabot>  Defined.
01:32:45 <ertes-w> @let myTree = Branch [Leaf 10, Leaf 20, Branch [Branch [Leaf 30, Leaf 40], Leaf 50], Leaf 60]
01:32:47 <lambdabot>  Defined.
01:32:53 <ertes-w> > myTree !! 2
01:32:55 <lambdabot>  error:
01:32:55 <lambdabot>      • Couldn't match expected type ‘[a]’
01:32:55 <lambdabot>                    with actual type ‘Tree' Integer’
01:33:03 <ertes-w> > F.toList myTree !! 2
01:33:05 <lambdabot>  30
01:33:30 <kuribas> AWizzArd:  getNthElement t n = subForest t !! n
01:33:31 <ertes-w> AWizzArd: ^ haskell version
01:33:53 <ertes-w> (why is (!!) even list-specific?)
01:34:49 <AWizzArd> I shall try that.
01:34:56 <dminuoso> ertes-w: Is there even an Indexable class?
01:35:02 <dminuoso> And I mean outside Control.Lens.Indexed
01:35:09 <ertes-w> dminuoso: all you need is Foldable
01:35:12 <merijn> ertes-w: Same reason as 80% of Haskell's flaws, hysterical raisins
01:35:22 <merijn> dminuoso: There's Ix, which is not quite the same
01:35:28 <dminuoso> ertes-w: Ohh! Dont tell. I should know this =)
01:36:01 <ertes-w> @let myIndex = foldr (\x go i -> if i == 0 then x else go (i - 1)) (const (error "Index out of bounds"))
01:36:01 <kuribas> AWizzArd: that's shorter even with import.  Not that being shorter is a good metric.
01:36:03 <lambdabot>  Defined.
01:36:09 <ertes-w> > myIndex "abcde" 2
01:36:11 <lambdabot>  'c'
01:36:27 <kuribas> :t ix
01:36:29 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
01:37:05 <sayola> ertes-w: about the alternative/monad filter. i would usually write a do block with a guard for p. but as i said, i dont know the functions of alternative well to write a one-liner.
01:37:29 * ski thinks `type(tree[0]) is int' is nonsense
01:38:35 <Boarders> if I just do "stack install libEx" vs creating a sandbox and adding libEx as a dependency what does it do?
01:38:46 <dminuoso> ski: Because you suddenly dont admit trees of strings or anything else?
01:38:50 <Boarders> and how do I practically use a library after I have done stack install
01:39:16 <merijn> Boarders: FYI with new-build you no longer have to create sandboxes
01:39:19 <vaibhavsagar> Boarders: AFAIK it installs it to your global-project
01:39:38 <vaibhavsagar> Boarders: use with `stack ghci --package libEx`
01:39:40 <ski> dminuoso : or trees of trees
01:39:49 <dminuoso> Boarders: Inside a stack project you simply edit your project.yaml to specify your dependencies. You must make sure that your stack.yaml somehow provides this (either through the resolver, or through extra-deps/packages)
01:40:11 <dminuoso> Boarders: *package.yaml rather than project.yaml.
01:41:06 <Boarders> right, so if I do stack install blah and then I just have a hs file and I run stack build then it will be able to build my project?
01:41:11 <dminuoso> Boarders: You dont.
01:41:34 <dminuoso> Boarders: You just specify the dependencies as described, and then run `stack build` as usual
01:41:46 <dminuoso> It will automatically fetch and install into a sandbox.
01:41:53 <Boarders> I'm just wondering what the point of stack install is
01:42:03 <dminuoso> Boarders: It's for the global-project
01:43:52 <ertes-w> sayola: the only function from Alternative you need is 'empty'
01:44:06 <ertes-w> sayola: 'pure' constructs singleton lists, 'empty' constructs the empty list
01:44:52 <ertes-w> sayola: so this is a matter of generalising these two aspects and then a third one: concatMap itself
01:45:15 <Boarders> I guess I am still confused, I see the global-project is ~/.stack/global-project but how do you make use of that?
01:45:52 <dminuoso> Boarders: Say you invoke `stack ghci` in the wild.
01:46:42 <dminuoso> Boarders: Or `stack ghc` even
01:47:21 <Boarders> ah ok so I can write my project which only depends on some globally installed libraries and then do stack runghc -- myProject.hs I can run it
01:48:49 <ertes-w> sayola: BTW, if you would like some semi-light reading on the merits of generalising far beyond the actual problem and how it can *simplify* a problem, i highly recommend this article (don't worry, it's not very technical): https://classes.golem.ph.utexas.edu/category/2010/03/a_perspective_on_higher_catego.html
01:49:16 <Boarders> thank you for the explanations dminuoso
01:49:53 <Boarders> merijn: how do I use new-build? (or do you know where I can read about it?)
01:50:35 <merijn> Boarders: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:50:53 <merijn> Boarders: It has some rough edges still, but MUCH nicer than sandboxes
01:56:34 <merijn> Boarders: Think of it as cabal automagically sandboxing every project you build AND sharing compatible shared dependencies across every project
01:56:46 <sayola> ertes-w: thank you. i'll put it in my bookmarks for now.
02:00:14 <Boarders> v cool
02:00:24 <Boarders> i need to get on the nix train
02:03:16 <merijn> Boarders: You don't need Nix for new-build
02:03:33 <Boarders> yeah, but still
02:03:40 <merijn> Boarders: new-build is just inspired by the Nix approach to dependencies
02:14:07 <kahlil29> if I have a 4-tuple, can I pattern match in a let expression to get each of the 4 values assigned to a separate variable Name (without using lenses if possible)
02:14:10 <dminuoso> merijn: By the way - is it possible you used to hang out in the ##c++ channels here?
02:14:18 <dminuoso> I've been pondering where I remember your nickname from.
02:14:30 <dminuoso> kahlil29: Yes.
02:14:31 <kahlil29> was thinking of something like `let (x1, x2, x3, x4) = (9,2,3,4) `    is this allowed?
02:14:35 <merijn> dminuoso: I occasionally hang out in ##C++ when asking obscure questions, yes
02:14:36 <dminuoso> kahlil29: Try it and see?
02:15:10 <merijn> kahlil29: Not only is that allowed, you can even do it at the top level :)
02:15:46 <merijn> kahlil29: i.e. having "x, y, z :: Int; [x,y,z] = [1,2,3]" at the top level in a module is perfectly legal and allowed
02:16:33 <kahlil29> wow alright. thanks a lot dminuoso and merijn. It gives a whole lot of warnings but I think annotating and explicitly specifying the types would solve that?
02:16:44 <dminuoso> kahlil29: That would depend on the warnings, wouldn't it?
02:16:46 <merijn> kahlil29: Depends on the warnings :p
02:17:08 <merijn> Probably defaulting warnings if you're not using x1-4 yet
02:17:26 <dminuoso> Why do we have type defaulting anyway?
02:18:11 <dminuoso> Or is it just a poor mans solution to awkward ambiguities when you dont have TypeApplications?
02:18:11 <merijn> dminuoso: Because else writing something like 2^3 would never compile without annotations
02:18:29 <dminuoso> merijn: Ah.
02:19:03 <merijn> dminuoso: You could use type aplications in the case of ^, but that'd be as horrifically ugly as annotations
02:19:17 <dminuoso> :t (^)
02:19:18 <lambdabot> (Num a, Integral b) => a -> b -> a
02:19:19 <merijn> And defaulting (outside of ghci) is only applied to a very small number of cases
02:19:23 <dminuoso> (^) @Int @Int 2 3
02:19:26 <dminuoso> Looks fine by me!
02:19:40 <merijn> i.e. Integral gets defaulted to Integer and Fractional gets defaulted to Double
02:19:52 <merijn> Which is almost always the sane thing to do
02:20:18 <kuribas> is there a guide to memory management in ghc?  Like test how much memory a data structure uses?
02:20:36 <merijn> kuribas: How much memory they use is unpredictable cause they might contain thunks
02:20:55 <kuribas> merijn: and if I deepseq them first?
02:21:47 <merijn> Then you can reason about it a bit if you dive into GHCs implementation details
02:21:52 <merijn> Not sure if there's a guide, though
02:22:15 <merijn> doubt it, tbh as it's at the whim of ghc's implementation
02:25:28 <dminuoso> merijn: Does (^) need it because `∀a b. a -> b -> a`, with `b` not appearing on the RHS? The way I read the Haskell report this is why it's ambiguous.
02:25:44 <dminuoso> Bwell
02:25:54 <dminuoso> ∀a b. (Num a, Integral b) => a -> b -> a
02:26:10 <merijn> dminuoso: Yes, it can't infer the type of the 2nd argument from the first or result
02:26:31 <merijn> i.e. "map (^2)" does not let you decide the type of 2, because it doesn't match any of the others
02:28:04 <kuribas> merijn: you may prefere Int over Integer if you know they are small, and care more about performance.
02:29:03 <merijn> kuribas: Right, but then you can always explicitly fix defaulting
02:29:18 <kuribas> yeah, Integer is more sane as default.
02:44:13 <dminuoso> % :t (^) @ _ @Int 2 3
02:44:14 <yahb> dminuoso: Num w => w
02:44:42 <dminuoso> % :t (^) 2 3
02:44:42 <yahb> dminuoso: Num a => a
02:44:56 <dminuoso> merijn: Interesting, so it only defaults the arguments it cant infer?
02:46:18 <dminuoso> Does Haskell try this generally on ambiguities?
02:46:38 <merijn> dminuoso: It only defaults on ambiguous types and only SOME ambiguous types
02:47:06 <dminuoso> merijn: Well I'd guess it only defaults on all ambiguous types that have default declarations right?
02:47:14 <merijn> dminuoso: i.e. Show/Read only get defaulted in ghci because of extended defaulting. In compiled code GHC only defaults numerics (and Strings if you enable OverloadedStrings)
02:47:15 <dminuoso> Or is it constrained more than that?
02:47:30 <merijn> dminuoso: Well yes, anything with default declarations, but the Report only has those for numeric types
02:47:35 <dminuoso> Gotcha
02:48:12 <dminuoso> So all that "extended defaulting is", is extra default declarations?
02:48:17 <merijn> yes
02:48:33 <geekosaur> and some extra rules allowing defaulting through a larger class of typeclasses than just the Report0defined ones
02:49:43 <geekosaur> (but still heavily restricted)
03:12:14 <batman__> what does this meab  Couldn't match expected type ‘a0 -> Message’                   with actual type ‘Message’
03:12:27 <batman__> the a0 -> Message part ???
03:12:35 <dminuoso> batman__: a0 is a type variable
03:13:20 <dminuoso> batman__: So it inferred a type expectation `forall a. (a -> Message)`, but what you gave it is a `Message`
03:13:22 <ski> batman__ : possibly you're missing an argument, or perhaps supplying an unwanted argument
03:14:18 <ski> dminuoso : please don't generalize it like that on the spot
03:14:24 <bq> inb4 "why doesn't it tell me that then"
03:14:27 <dminuoso> ski: Okay.
03:15:58 <ski> dminuoso : what i mean is, i don't see (and don't think) there's reason to believe there should be an implicit `forall' at that particular spot. more likely is that `a0' is just a tyvar that is bound somewhere further out .. or not instantiated yet, if you speak logic programming
03:16:41 <ski> batman__ : if you show the actual offending code, we might be able to give more detailed help, rather than just attempting to guess from the type error (fragment)
03:16:44 <dminuoso> ski: Yeah you are absolutely correct.
03:17:00 <dminuoso> ski: Next time I shall do the right thing and ask for the entire error message. :)
03:17:45 <ski> well, initial guesses and hunches can be useful as well, i'm not saying that you should stop doing that
03:18:47 <dminuoso> ski: Recently I've been training myself to still ask for error messages - My reasoning is that assumptions is the reasons why bugs exist in the first place.
03:19:06 * ski nods
03:19:50 <ski> sometimes (a sufficiently advanced/refined/informed) hunch/guess can be enough to lead the OP on the right track
03:20:38 * ski looks at batman__
03:21:07 * cppxor2arr holds their breath
03:21:56 * ski stands at attention, with oxygen tube ready
03:22:27 * cppxor2arr is disappointed in batman__
03:25:43 <aisqwe> is it true in a mathematical sense that a function always reduce the size of its domain?
03:27:12 <Putonlalla> Yes, aisqwe.
03:27:23 <ski> aisqwe : hm, i'm not sure what you mean by that
03:27:52 <batman__> ski : here you go √
03:27:55 <batman__> ski : here you go http://lpaste.net/362943
03:28:24 <dminuoso> batman__: And the error message?
03:28:42 <Putonlalla> Furthermore, the minimal and maximal reductions correspond to `id` and `const c` respectively.
03:28:44 <aisqwe> is it true the image of a function cant have more elements in it than the domain of the function
03:29:03 <dminuoso> aisqwe: Construct a surjective function mapping {1} onto {0,1}
03:29:08 <dminuoso> I challenge you.
03:29:13 <batman__> dminuoso : http://lpaste.net/362944
03:29:26 <kuribas> is there a library that can convert a unicode Text to Text with html entities?
03:29:37 <aisqwe> but wouldnt {0,1} be just one element in the image?
03:30:23 <ski> batman__ : `PING <$> decode' and `PONG <$> decode' are clearly at fault .. i'm not seeing yet what you wanted to express there, though
03:30:55 <aisqwe> dminuoso: did you mean map 1 --> (0,1) or a maping that map 1 to 0 OR 1?
03:31:06 <batman__> ski : i know they are at fault because they are giving me error but i'm not sure why
03:31:08 <cocreature> kuribas: how about https://hackage.haskell.org/package/html-entities
03:31:27 <batman__> ski : it's working with types data Message = Ping String
03:31:55 <ski> batman__ : it looks like `encodeMessage' has endless recursion / infinite loop ?
03:31:58 <kuribas> cocreature: oh, that might work!  thanks
03:32:35 <batman__> ski : yeah it's lib function , i know that because i was playing it with and it went into infinite recursion
03:32:57 <dminuoso> aisqwe: A function broadly speaking is just a mapping (a,b) for points a from the domain and points b in the codomain, such that for each pair (a, b) there is only one pair for every a.
03:33:12 <dminuoso> aisqwe: The image can be thought of the set of all these pairs.
03:33:25 <ski> batman__ : also, your `case' looks suspicious, both branches have identical patterns
03:33:33 <dminuoso> aisqwe: Or rather the set of all `b` for which you have a mapping (a,b)
03:33:41 <ski> batman__ : did you mean to say `(2,1)' in one of them, or something ?
03:34:29 <batman__> ski : there is nothing wrong with case i had commented the other one so while giving you the code i pasted the same thing twice
03:34:40 <batman__> ski : this is the example provided by lib http://lpaste.net/362945
03:35:28 <aisqwe> dminuoso: so if you prune the image so that no dangling elements reamains this means that the "size" of the image must be less than or equal to the domain
03:35:40 <dminuoso> aisqwe: Exactly.
03:35:49 <dminuoso> aisqwe: If its the same size, then its called an injective function.
03:36:08 <dminuoso> aisqwe: since it "injects/embeds" the domain in the codomain in a sense.
03:36:15 <ski> batman__ : that example looks more sensible, yea .. now what were you attempting to express with <http://lpaste.net/362943> ?
03:36:43 <dminuoso> aisqwe: And if the image and the codomain are the same, its called surjective
03:37:10 <ski> batman__ : did you just want a `Serialize' instance for that particular `Message' type consisting only of the alternatives `PING' and `PONG' ?
03:37:24 <batman__> ski : yep
03:37:47 <ski> batman__ : in such case, try using `encodeListLen 1', and skip the ending `encode' part. so just a len and a tag
03:38:21 <ski> batman__ : then, instead of `PING <$> decode', which doesn't make sense, since `PING' is not a function, simply use `return PING' there
03:38:36 <ski> batman__ : does that seem to make sense to you ?
03:38:59 <ski> batman__ : if so, try it out, and show what you get
03:40:40 <ski> batman__ : the difference between your `Message' and `Animal' is that the latter has components inside the alternatives, but your `Message' hsan't
03:41:23 <`Guest00000> =
03:41:24 <dminuoso> aisqwe: There's a book called "Category Theory for Computing Science" that - ignoring the general scope of the book - has in its beginning a very clean and concise definition of functions.
03:41:27 <Lycurgus> hsan't
03:41:46 * ski smiles
03:41:52 <batman__> ski : now i can serialise it but when i try to deserialise it , it gives error *** Exception: DeserialiseFailure 1 "end of input"
03:41:53 <dminuoso> (It's the best book I can come up with at a moments notice)
03:42:16 <ski> batman__ : well, you need to fix `decodeAnimal' accordingly
03:42:34 <ski> batman__ : if you have no clue how to do that, show your current code (as i already said :)
03:42:36 <cppxor2arr> dminuoso: mind quoting it?
03:42:51 <ski> er, not `decodeAnimal', `decodeMessage', i mean
03:43:04 <dstolfa> dminuoso: float f(int x, int y) { return ((float)x/2.3 * (float)y); } do i win a cookie?
03:43:40 <dminuoso> cppxor2arr: http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf up until 1.2.12 you get a category theory focused definition.
03:44:18 <cppxor2arr> thanks
03:44:40 <batman__> ski : i did show you my code
03:45:06 <batman__> ski : it has a custom type which i want to serialize like in example
03:45:07 <ski> i mean your most recent code, after fixing `encodeMessage', and possibly after attempting to also fix `decodeMessage'
03:45:10 <kuribas> cocreature: heh, I solved it with a simple <meta charset="utf-8"> declaration :)
03:46:07 <dminuoso> And I say category theory focused, because most fields of mathematics don't distinguish between `x -> x + x : R -> R` and `x -> x + x : R -> R+`
03:46:18 <dminuoso> While in category theory and programming the distinction becomes important.
03:46:27 <ski> batman__ : .. also, for next time, when you want to post updates, and related stuff (like error messages), please use the "Annotate" button on the paste, rather than making a fresh paste. that way, your updates will end up on the same page as the original paste, and so it's easier to compare
03:46:55 * ski . o O ( s//|/ )
03:48:25 <dminuoso> ski: Okay so to get back to the original topic where you chastized me - so I guess the lesson to be learned is that `a0` could be anything, such as a scoped type variable from an outer context right?
03:48:54 <cocreature> kuribas: welcome to the glorious future where browsers support utf-8
03:49:01 <kuribas> cocreature: don't they?
03:49:09 <ski> dminuoso : yes. or, it could even be something concrete, like `Int', except the type checker hadn't realized that by the time it noticed the type inconsistency
03:49:34 <cocreature> kuribas: they have for quite some time :)
03:49:43 <kuribas> cocreature: ah, great
03:50:48 <merijn> kuribas: The bad news is, detecting which encode source files use is still a clusterfuck, so shit still randomly breaks across the web
03:51:00 <ski> dminuoso : unfortunately people sometimes say stuff like "`[a] -> [a]' really means `forall a. [a] -> [a]'", which if taken at face value could be interpreted to mean that `([a] -> [a]) -> Bool' really means `(forall a. [a] -> [a]) -> Bool', which is nonsense
03:51:15 <kuribas> merijn: that's why I have <meta charset="utf-8"> :-)
03:52:26 <ski> dminuoso : what one should say there is that `blah :: [a] -> [a]' *usually* (with some exceptions) is short `blah :: forall a. [a] -> [a]', with the `forall' being inserted directly after `::'
03:52:36 * ski looks at batman__
03:53:37 <ski> (dminuoso : i'm not accusing you of saying such things, fwiw. just noting that this is a related confusion, though possibly of a more simplistic sort)
03:54:20 <cppxor2arr> batman__ feels uncomfortable being stared at
03:55:09 <Myrl-saki> What should I name a type with `None | Some x | Any`?
03:55:24 <ski> how do you intend to use it ?
03:55:26 <[exa]> Myrl-saki: sounds like glob pattern
03:55:32 <Myrl-saki> ski: It's for matrix "division"
03:55:49 <Myrl-saki> ski: Basically reversing a cross product given the lhs.
03:55:55 <WinterFox[m]> If I have a `Maybe ( Maybe Text )` do I use join to convert it to `Maybe Text`?
03:55:59 <ski> for expressing zero, one, or infinitely many solutions ?
03:56:03 <Myrl-saki> ski: yeah.
03:56:50 <merijn> WinterFox[m]: yeah
03:57:40 <ski> WinterFox[m] : depending on the surrounding code, there might be a more straightforward way
03:58:14 <WinterFox[m]> The exact code is `join $ maybeName <$> json`
03:58:35 <merijn> WinterFox[m]: What's the type of json and maybeName?
03:58:36 <ski> WinterFox[m]> :t maybeName
03:58:37 <cocreature> WinterFox[m]: how about "maybeName =<< json"?
03:58:58 <merijn> WinterFox[m]: ^^ was about to suggest that if the types work out
03:58:59 <WinterFox[m]> merijn: Both are Maybe Text
03:59:17 <ski> `maybeName' better be a function
03:59:20 <merijn> :t (>>=) `asAppliedTo` (Nothing :: Maybe Text)
03:59:22 <lambdabot> error:
03:59:22 <lambdabot>     Not in scope: type constructor or class ‘Text’
03:59:29 <merijn> really? >.<
03:59:33 <merijn> :t (>>=) `asAppliedTo` (Nothing :: Maybe Data.Text.Text)
03:59:35 <lambdabot> Maybe Data.Text.Internal.Text -> (Data.Text.Internal.Text -> Maybe b) -> Maybe b
03:59:54 <WinterFox[m]> maybeName :: Text -> Maybe Name
04:00:06 <WinterFox[m]> Oh wait
04:00:08 <WinterFox[m]> Thats not maybe text
04:00:43 <ski> doesn't matter, as long as `json :: Maybe Text' here
04:01:01 <Myrl-saki> I could also technically return `:: Num a => Maybe (Vec3 (Maybe a))` is that a good idea?
04:01:30 <WinterFox[m]> json is Maybe Text
04:01:33 <ski> if you prefer, you could also go `do txt <- json; maybeName txt', which is the same as `do txt <- json; nm <- maybeName txt; return nm'
04:01:48 <WinterFox[m]> What is wrong with join?
04:02:09 <ski> `(=<<)' is more to the point
04:02:20 <Myrl-saki> :t lift
04:02:21 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
04:02:25 <Myrl-saki> :t liftA2
04:02:26 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:02:28 <ski> Myrl-saki : i don't think so
04:03:00 <Myrl-saki> ski: The rationale is that it's equivalent, in the sense that it's equivalent when you run it through `sequence`.
04:03:03 <ski> Myrl-saki : do you really intend to allow the components to individually decide whether they're `Nothing' or not ?
04:03:13 <cocreature> WinterFox[m]: nothing is wrong with join but combining fmap and join is exactly what "=<<" is made for
04:03:24 <Myrl-saki> ski: The "Nothing" in the individual components are actually "Anything"
04:03:54 <WinterFox[m]> cocreature: I was not aware. I'll have to look in to that
04:03:56 <ski> Myrl-saki : and one of them can be `Any' without the other ones also being `Any' ?
04:04:15 <Myrl-saki> ski: Basically, what I'm saying is that `Num a => Vec3 (TriState a)` was a bad idea for the specific reason that you stated -- an individual component could be `Nothing`.
04:04:37 <Myrl-saki> ski: If any individual component is Nothing, then there's no solution at all.
04:04:42 * ski nods
04:05:12 <Myrl-saki> ski: Maybe I should just choose another `x + 1` type, but shows the programmer intent?
04:05:37 <ski> Myrl-saki : i suspect that you'll want to allow any affine subspace as a solution space ?
04:05:54 <Myrl-saki> ski: :: (any ~ (), Num a) => Maybe (Vec3 (Either a any))
04:06:20 <ski> iow, zero-dimensional (a point), one-dimensional (a line), two-dimensional (a plane), three-dimensional (the whole 3-space itself, all points, no restriction)
04:06:27 <ski> in addition to the no solution case
04:06:58 <Myrl-saki> ski: I think I get what you're trying to say?
04:07:10 * ski is just guessing at what Myrl-saki is doing
04:07:28 <Myrl-saki> ski: If all Vec3 is a number, then it's a point? If one is `Any`, then it's a line parallel to one of the axes? etc.
04:07:45 <Myrl-saki> If all elements of the Vec3
04:08:16 <Myrl-saki> ski: I'm thinking I could use BLAS bindings or something, but this is just to solve my homework.
04:08:44 <Myrl-saki> s/BLAS/Lapack?
04:08:46 <ski> if you have `Just (V3 Nothing (Just y) (Just z))' (or however it's written), then that seems to be to be a line that's parallel to the abscissa, while i'm suspecting that perhaps you'll also want to allow other lines as solution spaces ?
04:08:59 <Myrl-saki> ski: Yeah, true.
04:09:25 <Myrl-saki> ski: I'm actually not sure.
04:09:36 <Myrl-saki> ski: I actually didn't consider that.
04:09:44 <Myrl-saki> ski: I think I should just find a library to do this for me?
04:09:58 <ski> just attempting to poke some holes in my imagination of what you're wanting to do
04:10:16 <Myrl-saki> ski: I guess I could actually say my use-case rather than what I want to do.
04:10:28 <ski> (it not being immediately obvious to me what the appropriate way to go about this would be)
04:10:51 <Myrl-saki> ski: Basically, one of our physics classes require me to do cross product and/or getting one of the `factors` of the cross product given the result and the other `fuctor`
04:10:53 <Myrl-saki> factor*
04:11:18 <Myrl-saki> ski: This is magnetic force given the magnetic field and a charged particle.
04:11:31 * ski is weak on physics
04:11:53 <reactormonk> Does anyone have an equivalent to askLoggerIO for katip at hand?
04:12:33 <Myrl-saki> ski: Ah. :P
04:12:40 <Myrl-saki> I'll take a look at LAPACK, I guess?
04:12:56 <ski> cross product is a linear map from the tensor, iirc. hm, i wonder what the possible solution spaces for the associated division would be
04:14:05 <ski> perhaps you could ask ##math about the possible shapes of solution spaces (in general, or in your particular case)
04:14:12 <Myrl-saki> Thanks.
04:14:33 <cppxor2arr> https://wikimedia.org/api/rest_v1/media/math/render/svg/1e92a0f159110f20468853e88e0d76d8c0b04f5a
04:14:47 <cocreature> Myrl-saki: I haven’t read all of the backlog so sorry if you’re already aware of that but the "linear" library might be worth a look
04:14:49 <ski> Myrl-saki : hm, do you have an example where there's no solution at all, here ?
04:14:56 <Myrl-saki> cocreature: Thanks, checking!
04:15:07 <locallycompact> where is the repository containing stack snapshot manifests, I want to submit a MR
04:15:09 <cppxor2arr> does anyone see a face in that link ^
04:15:55 <Myrl-saki> ski: I'm guessing that there should be no solution if you increase the length of one of the resulting axes, without changing anything else.
04:15:58 <cocreature> locallycompact: https://github.com/fpco/stackage but usually you should only add your own packages there
04:16:28 <locallycompact> well there's a bug in the lts versions that's been annoying me
04:16:33 <locallycompact> hakyll-4.10 doesn't build
04:16:35 <Myrl-saki> ski: BUT
04:16:35 <locallycompact> needs to be 4.11
04:16:43 <Myrl-saki> ski: I don't know anything about matrices at all.
04:16:53 <cocreature> locallycompact: lts doesn’t upgrade to new major versions, that’s the whole point of lts
04:17:05 * ski isn't sure matrices are that relevant, here
04:17:06 <locallycompact> but it's failing to build
04:17:16 <locallycompact> that's not very lts either
04:17:28 <cocreature> what’s the build error?
04:17:36 <locallycompact> one sec I'm rerunning it
04:17:46 <ertes-w> i'd really love to have per-do-statement 'where' blocks
04:17:58 <ertes-w> do query db q p  where q = …
04:18:18 <Myrl-saki> cocreature: I don't think what I have is there. IIRC, cross product is only defined for V3s, and the `inverse` isn't specified.
04:18:29 <Myrl-saki> Err
04:18:45 <ski> well, iirc, cross product is also defined in 0-, 1-, and 7- dimensional space
04:19:11 <Myrl-saki> cocreature: I don't think what i want* is there, and there's no `inverse` function under it. ski True. Thanks.
04:19:18 <ski> (though that probably doesn't make much of a difference to you here)
04:19:31 <Myrl-saki> ski: Is V1 just simple multiplicatoin?
04:19:38 <ski> yep
04:20:44 <Myrl-saki> Well
04:20:50 <Myrl-saki> I guess I'll change my scope for now.
04:21:11 * Myrl-saki is AFK
04:21:32 <Myrl-saki> Er, back.
04:22:20 <Myrl-saki> Is there any equation solver, preferably with a Num instance? By that, I mean I could do `x + y = z` and I can specify the values of x and z, which allows me to get y?
04:23:41 <Myrl-saki> Or is Haskell the wrong tool for this?
04:24:20 <cppxor2arr> i wonder if there is a sympy equivalent for haskell
04:24:33 <cppxor2arr> https://stackoverflow.com/questions/3295345/haskell-library-like-sympy
04:24:57 <Putonlalla> Is not, cppxor2arr.
04:25:38 <Putonlalla> We have symbolic algebra packages for certain domains (such as Clifford algebra), but no general-purpose equivalent.
04:26:09 <Myrl-saki> https://hackage.haskell.org/package/linearEqSolver-2.0/docs/Math-LinearEquationSolver.html
04:26:13 <Myrl-saki> I guess I could do that?
04:26:25 <Myrl-saki> But the result vector is not a [[Integer]]
04:26:38 <Myrl-saki> Oh wait.
04:26:40 <ski> Myrl-saki : perhaps you could look into Constraint (Logic) Programming, hmm
04:26:49 <Myrl-saki> ski: Yeah, that's also what I was thinking.
04:26:52 <Myrl-saki> ski: I was about to fire up Prolog.
04:27:10 <Myrl-saki> Not so sure if Prolog works well with arithmetic though?
04:27:36 <ski> there is CLP(R)
04:28:28 <Myrl-saki> ski: Thanks.
04:36:26 <kuribas> Myrl-saki: I wrote a solver like metafont: https://hackage.haskell.org/package/mfsolve
04:36:44 <kuribas> Myrl-saki: it only solves linear equations and angles though...
04:37:00 <kuribas> Myrl-saki: but it will also evaluate non-linear expressions.
04:48:21 <locallycompact> cocreature, here's the error (using lts-10.6) https://pastebin.com/sLRvqUf9
04:48:50 <locallycompact> it's fine in nightly with 4.11
04:54:53 <dminuoso> ski: I think I get what you are saying. This might make more sense if you dont think of a type variable as universal quantification.
04:55:09 <dminuoso> And by "you" I mean "me"
05:00:27 <dminuoso> ski: Im gonna do some reading on a textbook that has been recommended to me, hopefully the finer details of HM inference will become clear to me. :)
05:01:38 <ski> yea .. when explaining polymorphism lately, i try to emphasize the it's not the presence of a type variable in the type that indicates polymorphism, but rather the (often implicit) `forall'
05:02:09 <dminuoso> ski: I was gonna write that assumption, but didn't want to simply make a statement based on my intuition.
05:02:23 <dminuoso> But I'm glad that it was right.
05:03:16 <dminuoso> ski: Would it be fair to say that "polymorphism" means that your value that you are holding is stuffed inside a /\ abstraction (i.e. not enough types applied yet)
05:03:46 <ski> depends on what you mean by "enough types applied yet"
05:04:11 <ski> consider `Either String'. this is incomplete, missing being applied to a type
05:05:28 <ski> otoh, consider `id : forall a. a -> a; id = /\a. \(x : a). x' in System F. `id' is polymorphic, but `id [Bool]' (if we use that syntax for polymorphic specialization) is not
05:05:29 <dminuoso> ski: I rather meant if you had some `/\x y. ...` but only applied @Int
05:05:40 <dminuoso> ski: i.e. I would expect /\ to curry
05:06:33 <ski> *nod*, i suspected so, but your "not enough types applied yet" looked close enough to the "incomplete type" thing to possibly cause confusion (if not by you, then by a bystander)
05:06:51 <ski> dminuoso : right
05:07:09 <ski> a value is polymorphic iff it has a type of the shape `forall a. ..a..'
05:07:26 <ski> a value is a function iff it has a type of the shape `... -> ...'
05:07:37 <ski> a value is a list iff it has a type of the shape `[...]'
05:08:17 <cocreature> locallycompact: which os are you using?
05:08:42 <ski> so, strictly speaking, `reverse', of type `forall a. [a] -> [a]', is not a function, but a polymorphic value. we can say it's a polymorphic function, which we then often abbreviate to just "function", because there's no explicit syntax for polymorphic specialization/instantiation in Haskell (unlike in System F)
05:09:03 <ski> (well, disregarding the `@Int' extension, which is still optional syntax)
05:09:13 <dminuoso> ski: And I guess for completeness sake, a `type` is polymorphic, if it has a kind of the shape `forall k. ..k..` ?
05:09:19 <ski> exactly
05:09:52 <ski> e.g. `Maybe' is not polymorphic (unfortunately it seems several introductory texts use this, imho, inaccurate, and ultimately confusing, terminology)
05:10:18 <dminuoso> ski: Flip however does. :)
05:10:22 <dminuoso> Or *is
05:10:26 * ski nods
05:10:46 <ski> also, the type `forall a. [a] -> [a]' is not polymorphic either. i tend to call such types `forall'-types, or universal types
05:11:22 <dminuoso> So generally polymorphism means abstracted over it's type (where Im using the word "type" losely. But with TypeInType that is literally true I guess)
05:11:28 <ski> (that's a related inaccurate terminology)
05:11:39 <ski> yep
05:11:58 <ski> literally it means "many shapes", which we can interpret as "many types"
05:12:00 <ski> so, we have
05:12:09 <ski>   take :: Int -> [Int] -> [Int]
05:12:19 <ski>   take :: Int -> String -> String
05:12:44 <ski> &c., all following the general schema `Int -> [a] -> [a]', for *every* (concrete) type `a'
05:12:46 <cocreature> locallycompact: looks like you’re hitting https://github.com/jaspervdj/hakyll/pull/601. anyway as I mentioned lts won’t upgrade to new major versions, you are just going to have to use nightly or add it to the extra-deps section
05:13:59 <ski> and we summarize/generalize this as `take :: forall a. Int -> [a] -> [a]', writing the same `take', because there is no explicit polymorphic generalization & specialization syntax in Haskell
05:16:13 <dminuoso> ski: It seems as if /\ is lambda calculus inside lambda calculus. I mean if you considered `Λa.λx^a.x`, then it's just simple application in the sense of λx^a.x[a:=Int] for example
05:16:47 <dminuoso> ski: Mmm.
05:17:10 <dminuoso> ski: Well at least that gives a very quick and easy mindmodel to test whether a given _value_ is polymoprhic.
05:17:22 <dminuoso> If TypeApplications allows me to throw some `@Int` at it, its polymorphic.
05:17:51 <dminuoso> % :t (id :: Int -> Int) @Float
05:17:52 <yahb> dminuoso: ; <interactive>:1:1: error:; * Cannot apply expression of type `Int -> Int'; to a visible type argument `Float'; * In the expression: (id :: Int -> Int) @Float
05:18:08 <dminuoso> % :t (id :: forall a. a -> a) @Float
05:18:08 <yahb> dminuoso: Float -> Float
05:18:59 <ski> well, in a dependent language, `/\' and `\' becomes the same thing, yes, and so does the two corresponding notions of application
05:20:01 <dminuoso> ski: That makes testing polymorphic values easier. If you have to supply a type its polymorphic (before you apply it) :)
05:20:18 <dminuoso> ski: Is there an equivalent test for polymorphic types however?
05:21:24 <ski> not sure whether `TypeApplications' and `TypeInType' would allow you to say `Flip @*'
05:23:04 <dminuoso> ski: Doesn't the latter make * just a type synoym for Type?
05:23:11 <dminuoso> I thought I saw some `type * = Type` around
05:23:58 <ski> probably
05:25:46 <dminuoso> ski: Mmm, no matter what I try this just produces parse errors. Is it possible type applications are only allowed on values?
05:28:42 <dminuoso> Ah actually it's: type Type = *; type * = *; data Constraint :: *
05:29:32 <Jackneill> hey
05:29:39 <dminuoso> % :t id @(*)
05:29:39 <yahb> dminuoso: * -> *
05:30:01 <dminuoso> ski: I suppose you could proxy it into Flip
05:30:09 <Jackneill> is there a nice haskell tutorial/book that the community agreed on being good for someone who has no previous func prog exp?
05:30:29 <dminuoso> Jackneill: From my past experience: No. There's plenty books however.
05:30:29 <cppxor2arr> learn you a haskell for great good?
05:30:51 <dminuoso> Jackneill: (Point being not that they are bad, just that there's definitely no consensus from what I have observed)
05:31:11 <ski> cppxor2arr : that has been likened to a four-hour long trailer
05:31:22 <cppxor2arr> i can relate now
05:31:27 <nullie> Jackneill: the Haskell Book
05:31:36 <Jackneill> i see, can you point me to some? also i'd like to ask about haskell code perf? is it an interrpreter or compiled?
05:31:48 <Jackneill> nullie, thanks
05:31:49 <cppxor2arr> ski: do you mean it's long or that it doesn't teach you much?
05:32:27 <ski> cppxor2arr : long, considering that it only gives a shallow overview, and no exercises
05:32:31 <Putonlalla> It assumes you learn things by simply reading a brief description of them, cppxor2arr.
05:32:54 <cppxor2arr> ok
05:32:55 <ski> @where CIS194
05:32:55 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
05:33:00 <Putonlalla> (Sometimes true.)
05:33:04 <ski> Jackneill : you could try ^ for exercises
05:33:10 <Jackneill> thank
05:33:16 <Jackneill> thanks*
05:33:38 * ski learned from "Haskell: The Craft of Functional Programming", by Simon Thompson
05:33:55 <ski> nowadays, it seems many people like
05:33:56 <ski> @where HPFFP
05:33:56 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
05:34:20 <ski> but also Hutton's book, and others, have been liked
05:34:52 <ski> "Programming in Haskell" by Graham Hutton
05:35:11 <ski> "The Haskell School of Expression" by Paul Hudak
05:35:16 <merijn> ski: I like Hutton's book as an elegant introduction to Haskell, but bitemyapp's book is more complete in-depth
05:35:24 <Jackneill> is there a style guide (official) like gofmt auto formatter
05:35:26 <Jackneill> ?
05:36:58 <merijn> Jackneill: No, there's no standard style and code in the wild uses a number of different styles
05:37:09 <ski> i don't think so. there are some style guides floating around. <https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md> isn't that bad
05:37:12 <Jackneill> terrible
05:37:13 <Jackneill> :)
05:37:27 <Jackneill> ski: thanks
05:38:09 <ski> (i don't agree with everything in it, but it does give (imho) good suggestions for many things)
05:39:00 <dminuoso> 14:21            ski | not sure whether `TypeApplications' and `TypeInType' would allow you to say `Flip @*'
05:39:09 <dminuoso> Here's a stupid question but, why not simply `Flip *` ?
05:39:29 <ski> personally, i do try to use `$' sparingly, more often prefering good old brackets
05:40:13 <ski> (e.g. i'd rather write `addCycles (instructionCycles instruction)' than `addCycles $ instructionCycles instruction')
05:40:49 <dminuoso> Expected kind ‘k0 -> * -> *’, but ‘*’ has kind ‘*’, In the first argument of ‘Flip’, namely ‘*’, In the type ‘Flip * *’
05:40:52 <dminuoso> Heh
05:41:40 <dminuoso> I guess that makes sense
05:41:49 <ski> dminuoso : with `TypeInType', what would be the type of `Proxy *' ?, should it be `* -> *', or `*' ? recall `Proxy :: forall k. k -> *'
05:44:41 <dminuoso> ski: Ah. In this case it would definitely be *
05:44:52 <dminuoso> So I see what you are on about.
05:45:55 <phadej> dminuoso: not @* but @Type
05:46:12 <dminuoso> phadej: On types themselves? Interestingly @(*) is valid
05:46:16 <dminuoso> For values I mean
05:46:27 <phadej> yes, because * is very special and overloaded
05:46:35 <ski> ty
05:46:42 <phadej> TypeInType have to restrict that to keep everyone more sane
05:47:11 <phadej> For example it's also a type family (*) (x :: Nat) (x :: Nat) :: Nat
05:47:13 <dminuoso> phadej: Do you have an example of how @Type would be used?
05:47:56 <phadej> I'm not sure if it can (iirc there was a KindApplication or so proposal in ghc-proposals repository)
05:48:27 <dminuoso> phadej: Ah indeed. It's like in the TypeApplications article: https://ghc.haskell.org/trac/ghc/ticket/12045
05:48:30 <dminuoso> *linked
05:50:51 <nate712> hey, I have a testing problem.
05:50:55 <nate712> https://pastebin.com/dfddgzhM
05:51:07 <nate712> this fails, with type constraint issues.... when I run:
05:51:51 <nate712> https://pastebin.com/knbFCUWF
05:52:43 <dminuoso> nate712: Use a paste service that is either syntax friendly, or supports Haskell directly. Also include your error message. Check the topic for a website that supports Haskell
05:52:56 <nate712> and honestly I'm lost. Having run the 'guilty' function, it runs fine.
05:53:28 <nate712> yep one second
05:55:44 <dminuoso> nate712: But just looking at your pastie.. declaring something of the shape `f a = ...` while giving it a non-function type... is Parser a type family?
05:56:15 <quchen> type Parser s a = s -> [(a,s)]
05:56:44 <dminuoso> quchen: Ah. I guess there's that.
05:57:07 <dminuoso> Kind of forgot about `type` =)
05:57:12 * ski . o O ( "Dr. Seuss on Parser Monads" <http://www.willamette.edu/~fruehr/haskell/seuss.html> )
05:57:44 <dminuoso> ski: Hehe. I've done so much with parsers the past few days, but I conciously newtype wrapped them - so my mind really didn't think straight.
05:58:02 <nate712> http://lpaste.net/362949
05:58:14 <nate712> here's the better paste then
05:58:33 <nate712> and yeah quchen pretty much has the type of Parser
05:58:49 <dminuoso> nate712: I wonder, is the polymorphic nature of [] a problem?
05:58:54 <dminuoso> :t []
05:58:55 <lambdabot> [a]
05:59:15 <ski>   (fail' :: Parser String Integer) "a" `shouldBe` []
05:59:26 <nate712> I have another test for a different function that checks against [] and it works fine. that's what is leading to my confusion
06:00:02 <ski> probably in that other case, the context determines the `a' part of `Parser s a'
06:00:35 <nate712> and then this doesn't match to it, so it fails? could be
06:00:38 <dminuoso> ski: Oh my! Tests are a wonderful use case of TypeApplications!
06:00:39 <quchen> Try compiling with -Wall, nate712
06:01:34 <ski> nate712 : yep, in your case, it doesn't know what the type `a' should be, and it wants to know, to be able to show the actual result (presumably), in case the test fails
06:02:04 <ski> dminuoso : yea, i suppose :)
06:03:15 <nate712> ok, i'm using a stack project... how can I attach -Wall ?
06:03:48 <nate712> never mind figured it out
06:05:41 <nate712> yeah no -Wall doesn't really show anything relevant, but i'll try adding the Type to the test
06:09:59 <nate712> ok thank you that got the test running - though it does make me concerned that the test might be too specific
06:19:38 <reactormonk> Is there something similar to optparse-applicative for environment variables?
06:20:14 <merijn> reactormonk: You could just use one of the regular parsers on whatever result you get from an environment variable?
06:20:33 <dminuoso> nate712: How would you implement: `show [] :: [(String,a)]` ?
06:20:44 <reactormonk> merijn, yeah, but all the useful meta information about env variables. I can always handcraft my own with readEnv
06:21:03 <merijn> reactormonk: What meta information?
06:21:13 <dminuoso> nate712: I think the only way to be as general as possible is to constrain it with `Show a`
06:21:18 <reactormonk> merijn, similar to --help in optparse-applicative
06:21:55 <merijn> reactormonk: I don't think that exists, no
06:22:08 <merijn> reactormonk: You could add custom help text to optparse-applicative, though
06:39:22 <hyperisco> looking for a function like  Exception e => m Bool -> e -> m ()
06:41:46 <hyperisco> eh, never mind
06:43:47 <hyperisco> Shelly is awesome btw
07:24:38 <hyperisco> what is a simplistic package to download a web page as Text? I don't need any sophisticated progress or error handling
07:24:56 <hyperisco> preferably not just a wget or curl wrapper
07:25:25 <ventonegro> hyperisco: wreq
07:26:00 <hyperisco> ByteString… well can't be too assuming of encoding I suppose :P
07:26:17 <hyperisco> but it would be nice if it did the work to parse the HTTP header to figure the encoding, then give me Text
07:26:26 <dminuoso> Can I think of [a] as just the cartesian product between Nat and `a` ?
07:26:43 <dminuoso> The reason Im asking is because the list construction looks a lot like Peano numbers, except for that second constructor argument.
07:27:31 <hyperisco> dminuoso, say  a  is Bool, then where is [True,False] in the product?
07:27:54 <hyperisco> seems to me like you'd only have n-Falses and n-Trues
07:28:41 <hyperisco> > [(n,b) | n <- [0..3], b <- [True,False]]
07:28:43 <lambdabot>  [(0,True),(0,False),(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
07:28:58 <SrPx> Hey guys
07:29:23 <brynedwards> hi
07:29:40 <SrPx> We have some open positions for working with Haskell, Idris and similar here on Ethereum. What is the best place to post it?
07:29:48 <Mark___> hey
07:29:51 <hyperisco> dminuoso, however, you can think of it like an exponent!
07:30:00 <hyperisco> dminuoso, Nat^a
07:30:55 <dminuoso> hyperisco: Ah yes. That seems to fit, great.
07:32:20 <terminalcommand> @SrPx You could post it on HN's monthly Who is hiring? thread.
07:32:20 <lambdabot> Unknown command, try @list
07:32:29 <metahumor> dminuoso: cardinality of (A -> B) is B^A
07:32:44 <SrPx> Good idea, terminalcommand. Thanks!
07:32:50 <metahumor> dminuoso: so since cardinality of (a -> [a]) is Nat...
07:33:06 <metahumor> i mean, cardinality of [()] is Nat
07:34:05 <ski> dyske : `[a]' is `exists n : |N. a^n' is `(n :) |N * a^n'
07:34:17 <ski> (`|N' is just another notation for `Nat')
07:34:27 <ski> er
07:34:29 <ski> dminuoso ^
07:34:39 <hyperisco> > [(n,b) | n <- [0..3], b <- replicateM n [True,False]]
07:34:41 <lambdabot>  [(0,[]),(1,[True]),(1,[False]),(2,[True,True]),(2,[True,False]),(2,[False,Tr...
07:35:11 <ski> if you consider only infinite lists/streams, `Stream a', then that is `|N -> a' is `a^|N'
07:35:36 <hyperisco> % [(n,b) | n <- [0..3], b <- replicateM n [True,False]]
07:35:36 <yahb> hyperisco: [(0,[]),(1,[True]),(1,[False]),(2,[True,True]),(2,[True,False]),(2,[False,True]),(2,[False,False]),(3,[True,True,True]),(3,[True,True,False]),(3,[True,False,True]),(3,[True,False,False]),(3,[False,True,True]),(3,[False,True,False]),(3,[False,False,True]),(3,[False,False,False])]
07:36:03 <kuribas> SrPx: reddit?
07:36:07 * ski isn't sure what hyperisco was after with `Nat^a'
07:36:23 <hyperisco> I wasn't relating to a type
07:36:31 <SrPx> kuribas /r/haskell? Sounds abusive
07:36:50 <kuribas> SrPx: there have been a few lately, no complaints...
07:36:53 <hyperisco> I was relating a Nat n to how many unique n-length sequences there are of  a
07:36:57 <kuribas> SrPx: but perhaps you're right...
07:37:02 <AWizzArd> When calling  Data.Foldable.toList – is that then lazy? If I have a big complex tree and just want the 4th element out of 3 million. Will it just traverse my tree until the third one and then shortcircuit?
07:37:06 <hyperisco> and above enumerates that
07:37:10 <SrPx> Hmm, I didn't know that
07:37:16 <kuribas> SrPx: where are you located?
07:37:32 <ventonegro> SrPx: Hmmm, Idris...
07:37:44 <SrPx> I'm in Rio but almost gave up of finding someone near. Those are remote jobs anyway
07:38:05 <hyperisco> so we started with a simple product of nats and bools, and that didn't work, but if we exponentiate the bools by the nat, it does
07:38:07 <ski> i followed the enumeration, but still didn't follow "you can think of it like an exponent","Nat^a"
07:38:30 <kuribas> SrPx: cool I didn't know there are idris jobs...
07:38:46 <ski> hyperisco : yea, so i wondered why you had `Nat' in the base, then ..
07:38:50 <ab9rf> kuribas: rule 34? :)
07:39:23 <nibbling> What's the preferred way of installing ghci and ghc globally for macOS? Looking at a few Haskell projects it seems Stack is quite popular now, but it seems more focused on per-project environments. Should I just grab the latest haskell-latform?
07:39:33 <cppxor2arr> do lambdabot and yahb do different things
07:39:36 <hyperisco> ski, isn't it clear from the enumeration?
07:39:39 <ski> fwiw, there's some paper (McBride ?) about ornaments, which i think has an example of how lists are ornamented naturals
07:40:02 <ski> hyperisco : sorry, no. i don't see how the two relates to each other at all
07:40:28 <hyperisco> I think you're adding in some extra assumptions
07:40:40 <hyperisco> because I know you're not that oblivious to the pattern :P
07:40:50 <ski> i'm reading `Nat^a' as a type/set, but perhaps that's an incorrect interpretation
07:41:08 <ski> (which would then be the same as `a -> Nat')
07:41:11 <hyperisco> I said I did not mean it as a type
07:42:00 <SrPx> kuribas well there is now
07:42:01 <ski> ok, sorry, i didn't know that your "I wasn't relating to a type" comment was about "Nat^a"
07:42:54 <ventonegro> SrPx: Please also post to /r/idris then
07:43:06 <metahumor> can we not say that cardinality of (a -> [a]) is "Nat ^ |a|" where "|a|" is the cardinality of a?
07:43:13 <hyperisco> ski, simple view is cartesian product multiples the size of the types, so lets say |Nat|*|a| … not telling you anything new here
07:44:05 <hyperisco> well I suppose Nat is infinite so this isn't quite the line of thinking I wanted :P
07:44:25 <hyperisco> lets say for two finite types A and B, there are |A|*|B| elements in the product
07:44:57 <hyperisco> but this is not all the elements for what was being asked
07:45:20 * ski follows the (binary) cartesian product case
07:45:40 <hyperisco> |A|^|B| on the other hand is enough elements
07:45:52 <ski> enough for what ?
07:46:15 <ryantrinkle> what does it mean if "Live bytes" (per +RTS -S) is (very) different from what heap profling (+RTS -hc) shows?
07:46:47 <ryantrinkle> i have an appw here "Live bytes" is increasing linearly with time, but -hc shows a flat line
07:48:14 <hyperisco> ski, maybe you're thinking about coming up with any bijection, but I am not, I am trying to enumerate the inhabitants
07:50:01 <hyperisco> if you take the product of naturals and some other type A, you are not enumerating the inhabitants of [A] (even after fixing the product enumeration strategy for infinite lists)
07:50:02 <ski> i'm honestly not seeing how `Nat^a' (however you want to think about that, which i still don't follow), and `|Nat|*|a|' for that matter, is related to `[a]', perhaps in some way thinking of it as a cartesian product.
07:50:32 <ski> (perhaps `|Nat|*|a|' weren't meant to be related to that, only being an example of a (binary) cartesian product)
07:51:03 <hyperisco> ski, because for all  n :: Nat  there are  n^|a|  n-length sequences of a's
07:52:02 <ski> hm, i'd say there are `|a|^n', `n'-length sequences of `a's
07:52:25 <hyperisco> yeah I would too
07:52:33 <hyperisco> did I write that wrong every time? lol
07:53:19 <ski> ok. how about `|Nat|*|a|' then ?
07:53:21 <hyperisco> anyways, I don't know how it relates to exponential types or cardinalities, but I wasn't thinking about that
07:53:32 <ski> ok
07:53:36 <hyperisco> I was just seeing that if you enumerate the product you are missing inhabitants
07:53:47 <sqooq> can I have a data structure that's basically a list but that it ends in an endless stream of zeros
07:53:51 <ski> enumerate which product ?
07:53:59 <hyperisco> of Nat and a
07:54:16 <hyperisco> > [(n, b) | n <- [0..3], b <- [True,False]]
07:54:16 <ski> sqooq : perhaps use a pair of a list, and a final, non-zero, element ?
07:54:18 <lambdabot>  [(0,True),(0,False),(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
07:54:21 <ski> (or `Maybe' that)
07:54:39 <hyperisco> or to see it more clearly
07:54:45 <hyperisco> > [(n, replicate n b) | n <- [0..3], b <- [True,False]]
07:54:47 <lambdabot>  [(0,[]),(0,[]),(1,[True]),(1,[False]),(2,[True,True]),(2,[False,False]),(3,[...
07:55:04 <hyperisco> versus
07:55:07 <ski> hyperisco : ok, i think you're talking about needing diagonalization to enumerate product where one of the factors are infinite
07:55:15 <hyperisco> ski, not at all, no
07:55:24 <ski> oh, ok
07:55:32 <hyperisco> compare to the other enumerate I offered
07:55:36 <sqooq> ski: I could also redefine functions to treat the empty list as such
07:55:49 <hyperisco> % [(n, b) | n <- [0..3], b <- replicateM n [True, False]]
07:55:49 <yahb> hyperisco: [(0,[]),(1,[True]),(1,[False]),(2,[True,True]),(2,[True,False]),(2,[False,True]),(2,[False,False]),(3,[True,True,True]),(3,[True,True,False]),(3,[True,False,True]),(3,[True,False,False]),(3,[False,True,True]),(3,[False,True,False]),(3,[False,False,True]),(3,[False,False,False])]
07:55:52 <hyperisco> see the difference?
07:56:35 <ski> hm, sure
07:56:51 <hyperisco> I am limiting n to 3 because, yes, default product enumeration strategy is stupid, but the point is the same
07:57:31 <metahumor> sqooq: "mylist ++ repeat 0"?
07:57:39 <ski> i suppose i'm still not getting what your point is. perhaps i'm just a bit dense at the moment
07:57:58 <sqooq> metahumor: yea but if all my lists are like that, I don't want to be doing that everytime
07:58:02 <sqooq> idk
07:58:06 <sqooq> i got myself into a pickle
07:58:10 <ski> metahumor : presumably sqooq wants to be able to decide when we hit the repeat ?
07:58:25 <sqooq> like this may not even be what I want to do
07:58:37 * ski suspects sqooq is doing something polynomial-like
07:58:50 <sqooq> it's just that my last idea fell flat hard
07:58:56 <sqooq> now i'm in stasis
07:59:28 <hyperisco> ski, replicateM n [True, False]  is like exponentiating Bool by n  …  though I kept saying it backwards
07:59:47 * ski nods
08:02:21 <metahumor> sqooq: data ExtendedList a = Exl [a] a deriving ...; exappend (Exl xs rx) (Exl ys ry) = Exl (xs ++ ys) rx"
08:02:21 <hyperisco> though I have to think how you'd generalise this past Nat
08:02:39 <metahumor> sqooq: or some combination of "rx" and "ry" as you choose
08:02:53 <metahumor> "toList (Exl xs rx) = xs ++ repeat rx"
08:02:56 <hyperisco> maybe the question loses meaning though
08:03:05 <metahumor> sqooq: and you call toList at the last possible moment after all the Exl ops
08:03:49 <sqooq> hmm
08:03:52 <sqooq> thanks
08:03:56 <ski> metahumor : i think `exappend :: [a] -> ExtendedList a -> ExtendedList a' is more sensible ?
08:04:24 <ski> sqooq : a variation is `data ExtendedList a = Repeat a | Cons a (ExtendedList a)'
08:04:43 <sqooq> ski: I like that
08:04:48 <metahumor> ski: possibly. i'm imagining sqooq is combining signals so he'll have several Exls he'd like to layer
08:04:59 <sqooq> metahumor: you would be right lol
08:05:21 <ski> metahumor : `exzipWith' would be a different matter, of course
08:05:44 <sqooq> I want to signals that are short, and signals that are longer, and when zipped they combine as you would expect, whereas right now they're truncated to the smaller list I'm prettys ure
08:06:02 <ski> yep, if you use `zip'/`zipWith'
08:06:17 <hyperisco> hrm, actually these enumerations are easily done applicatively
08:06:34 <metahumor> ski: "exappend :: Exl a -> [a] -> Exl a" and my definition above are equivalent because of the "repeat rx === (repeat rx ++ repeat ry)"
08:06:34 * ski has called this `zipWithDefault :: a -> b -> (a -> b -> c) -> [a] -> [b] -> [c]'
08:07:11 <hyperisco> xs = (:) <$> a <*> xs <|> pure []
08:07:24 <hyperisco> then generalises trivially to any ADT
08:07:27 <ski> metahumor : yea, but i think it may help conceptually to distinguish lists which are to be finite, and ones that conceptually go on indefinitely (although eventually repeating)
08:07:55 <ski>   xs = liftA2 (:) a xs <|> pure []
08:08:07 <sqooq> well what I would want is that even lists that appear finite are really infinite with just zeros at the end
08:08:09 <hyperisco> I am more of a <$> and <*> guy than a lift guy
08:08:15 * ski smiles
08:08:16 <sqooq> so everything is an infinite list
08:08:44 <metahumor> sqooq: can you have empty signals?
08:08:52 <ski> sqooq : well, if you want to append two such lists, then don't you also want to provide a cut-off index for the first of them, then ?
08:08:57 <sqooq> it would just be a stream of zeros, metahumor
08:09:00 <hyperisco> I guess my intuition of the problem went here, because I've studied this before
08:09:34 <ski> > take 4 [0,2 ..] ++ [1,3 ..]
08:09:37 <lambdabot>  [0,2,4,6,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,...
08:09:57 <hyperisco> and if you want a beautiful enumeration of this, imo, use my package called data-list-zigzag :)
08:10:18 <ski> > take 4 ([2,1] ++ repeat 0) ++ ([4,3,2,1] ++ repeat 0)
08:10:20 <lambdabot>  [2,1,0,0,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
08:10:46 <sqooq> ski: hmm, sure, but would it not be more "correct" to think of the take function as cutting the signal (making zeros) after some point
08:10:49 <sqooq> so a new take function
08:10:54 <sqooq> `cut` or otherwise
08:10:54 <hyperisco> ugh, do I have to bump base version on that again
08:11:11 <great_gig> Hey hi, can anyone help me with the Optional data type?
08:11:17 * hyperisco *groans*
08:11:26 <ski> sqooq : well, iiuc, you want to consider `[2,1]' as the same as `[2,1,0]' as the same as `[2,1,0,0]', &c. no ?
08:11:34 <great_gig> I don't think I completely understand it :(
08:11:35 <sqooq> sure
08:11:40 <hyperisco> I started putting <= 9223372036854775807 on all my packages
08:12:24 <metahumor> " data Exl a = Exl [a] a; instance (Show a) => Show (Exl a) where show (Exl xs rx) = show xs ++ " [" ++ show rx ++ ",...(])"   "
08:12:26 <cocreature> great_gig: which type are you referring to? there is no type type called Optional in the base libraries
08:12:27 <sqooq> ski: I'm not sure this would be better, but your previous example would be more like `cut 4 [0,2 ..] + [1,3 ..]`
08:12:33 <ski> so, if you're appending, either you must specify a cut-off for the first, or must assume some default one, such as zero, or infinity, or *the* point at which you get only zeros
08:12:38 <metahumor> great_gig: what's got you caught up?
08:12:39 <sqooq> where (+) zips them together
08:12:54 <sqooq> so really zipWith (+)
08:12:55 <ski> well `zip' is another matter
08:12:59 <ski> i was talking about appending
08:13:18 <sqooq> yes I'm showing that appending is the same as "adding" two signals where one is cut
08:13:42 <sqooq> O wait
08:13:43 <ski> metahumor : i'd rather have `show' output a call to `repeat' there
08:13:45 <sqooq> no i'm wrong
08:14:00 <sqooq> appending implies that one starts at a certain point
08:14:09 <ski> metahumor : and fwiw, i doubt "can we not say that cardinality of (a -> [a]) is "Nat ^ |a|" where "|a|" is the cardinality of a?"
08:14:29 <sqooq> my example would result in [1,5,9,15,11,13,15,17,...]
08:14:36 <sqooq> hmm
08:14:42 <sqooq> so maybe there is use in finite lists
08:15:41 <hyperisco> so is there a simple http client library that handles encoding?
08:15:59 <hyperisco> I really have no interest in parsing HTTP headers myself to discern how to decode a bytestring…
08:17:04 <sqooq> wait, ski, so what are you suggesting again?
08:17:30 <mnoonan> I don't know the context, but the cardinality of [a] should probably be 1 / (1 - |a|)
08:17:40 <metahumor> hyperisco: you mean have it give you back Text instead of ByteString?
08:17:46 <hyperisco> yes
08:17:57 <mnoonan> "cardinality"
08:18:35 <cocreature> hyperisco: how is that supposed to work? you can send binary data over http
08:19:30 <ski> sqooq : i was suggesting that `exappend :: ExtendedList a -> ExtendedList a -> ExtendedList a' (as opposed to `exzip') doesn't seem natural to me
08:19:45 <ski> sqooq : though perhaps i'm misunderstanding your problem domain
08:20:39 <hyperisco> cocreature, what do you think the web is magic? ;) look at HTTP responses and you will see the encoding in the Content-Type header
08:21:03 <ski> you seemed to be talking about "eventually constantly zero" sequences, aka "sequences with finite support"
08:21:07 <Welkin> http is all base64 encoded strings
08:21:11 <hyperisco> from http://www.google.ca  Content-Type: text/html; charset=ISO-8859-1
08:21:33 <Welkin> http is all about that base64
08:22:01 <hyperisco> you can also look into the HTML header for a meta tag which says the encoding, though you obviously have to make some encoding assumption to get there
08:22:03 <cocreature> hyperisco: you will see an encoding for text/html, for image/png you won’t see an encoding :)
08:22:26 <hyperisco> cocreature, you don't need a text encoding for image/png…
08:22:45 <cocreature> hyperisco: right so you can’t convert it to Text which is what I was trying to say :r
08:22:47 <cocreature> *:)
08:23:08 <dminuoso> ski: Im guessing |N is just an ascii approximation for ℕ ?
08:23:10 <hyperisco> okay let me rephrase the question then
08:23:19 <ski> yep
08:23:50 <hyperisco> is there a package which makes downloading text/html content as Text easy
08:24:08 <dminuoso> ski: Wow. It feels so cool to have had this revelation all on my own, while I was getting coffee from the coffee maker.
08:24:12 <Welkin> hyperisco: it already is text o.o
08:24:16 <Welkin> that's all http is
08:24:18 <hyperisco> because I have no interest in investigating HTTP headers myself to determine content encoding
08:24:30 <hyperisco> noooooooo it isn't
08:25:00 <dminuoso> ski: Your denotation is a bit cryptic though
08:25:02 <Welkin> you mean you just want the body, already decoded?
08:25:11 <Welkin> I would imagine any http client library does that
08:25:23 <sqooq> ski: no I think you're right
08:25:47 <dminuoso> `exists n : ℕ . a^n' is `(n :) ℕ * a^n'
08:25:49 <ski> dminuoso : well, i did mention "(`|N' is just another notation for `Nat')", just in case it wasn't clear what i meant by `|N' ..
08:25:59 <hyperisco> Welkin, well, feel free to suggest one
08:26:01 <sqooq> ski: I think maybe I don't have to define a type at all, I just work with lists and create a convenience function `trailZeros` that takes a list and `++ repeat 0` to it
08:26:13 <sqooq> then use zipWith
08:26:13 <Welkin> hyperisco: would servant-client not work?
08:26:17 <ski> sqooq : that could be one path, yes
08:26:25 <hyperisco> apparently wreq does decompression, so that is good
08:26:28 <dminuoso> ski: No that was clear. The thing Im just confused about is the exponential, mostly because I have not learned the type/set theory of doing an exponential.
08:26:38 <sqooq> though, if my functions are more complex, I'll have pretty nasty nested zipWith's
08:26:40 <ski> sqooq : though i'd prefer to only add as little extra padding as needed, when actually needed
08:26:40 <dminuoso> ski: Is this from Idris/Agda?
08:26:53 <sqooq> it would be nice to redefine applicative to basically be zipWith
08:27:08 <dminuoso> ski: Or just some pseudo notation?
08:27:11 <ski> dminuoso : not exactly, but it's some kind of (dependent) type theory notation, sure
08:27:43 <cloudhead> hey is there a way to stop ghci from showing fully qualified module names in type signatures? such as: binary-0.8.5.1:Data.Binary.Class.Binary v
08:27:48 <hyperisco> actually will you look at that… the page I actually want to scrape does not say its encoding :P
08:27:54 <hyperisco> the web is such a nasty place…
08:28:07 <ski> dminuoso : `B^A' is the same thing as `A -> B'. e.g. `B^2' is `2 -> B' is `Bool -> B' is `B * B' (`(B,B)' in Haskell pair type notation)
08:28:29 <hyperisco> when in doubt assume… UTF-8, I guess?
08:29:19 <sqooq> can I do that? Can I redefine applicative for lists for my own usecase. I guess I could make a newtype wrapper but then I'll always have to unwrap, I mean maybe that's not so bad
08:29:31 <dminuoso> ski: That `2` is just the cardinality then?
08:29:32 <sqooq> it would cool if I could like import lists without the applicative instance, then make my own
08:29:43 <ski> dminuoso : a value of type `exists n : ℕ . a^n' / `(n :) ℕ * a^n' is a pair of the form `(n,xs)', where `n' is a `ℕ', and `xs' is an `a^n' (an `n' -sequence / -tuple of `a's)
08:29:59 <ski> dminuoso : `2' there is `1 + 1', `Either () ()' in Haskell
08:30:08 <dminuoso> ski: Ah gotcha.
08:30:11 <ski> which is `Bool'
08:30:14 <cocreature> hyperisco: I’ve mostly just been using html-conduit which accepts a bytestring and so far hasn’t screwed me over when it comes to encoding :)
08:30:23 <dminuoso> Well isomorphic to it, but I understand what you mean
08:30:56 <ski> in math, one thinks of a set/type `2' as being `{0,1}' (where those elements would not be sets/types, unless one's doing ZF or the like ..)
08:30:58 <hyperisco> well I think most encodings are compatible with ASCII, so you're only going to get weirdness if characters outside that are used
08:31:25 <dminuoso> ski: well since you said "set", I presumed that we are not talking about classes :)
08:31:44 <ski> iow, for each natural number `n', we have a corresponding (standard/canonical/default) type having exactly `n' element, thought of as the natural numbers that are less than `n'
08:32:20 <ski> this type would often also be written as just `n'. if you want a different, explicit, notation, you could say `Fin n' or `|N_{< n}' or something
08:33:04 <ski> (well, when i said "set", i wasn't really thinking of it in the sense of "ZF set theory", though i suppose you can, if you insist)
08:33:45 <cocreature> hyperisco: I wonder how much browsers actually care about the charset header or if they try to guess the encoding even if it is present
08:34:29 <hyperisco> probably all of the above modulo browser
08:34:33 <dminuoso> ski: Interesting, I suppose `Fin n` or `ℕ_{<n}` kind of makes sense if you consider Peano construction.
08:34:43 <ski> (in Agda one can define `data Fin : Nat -> Set where FZero : {n : Nat} -> Fin (Succ n); FSucc : {n : Nat} -> Fin n -> Fin (Succ n)', so the inhabitants of `Fin (Succ (Succ Zero))' are then `FZero' and `FSucc FZero')
08:34:45 <dminuoso> It's... natural. Pun intended.
08:35:12 <dminuoso> ski: Ah cool. :)
08:35:30 <dminuoso> I think at some point I might try out Agda (or Idris dunno)
08:35:59 <ski> (then one can go on to define `index : {a : Set} -> {n : Nat} -> Fin n -> Vec a n -> a', a total function)
08:37:03 <ski> (where `Vec a n' is `a^n'. `data Vec (a : Set) : Nat -> Set where Nil : Vec a Zero; Cons : {n : Nat} -> a -> Vec a n -> Vec a (Succ n)')
08:37:42 <ski> dminuoso : fwiw, could you elaborate on what you had in mind with "kind of makes sense if you consider Peano construction" ?
08:48:46 <Jackneill> hey
08:48:54 <Jackneill> i have read that where creates bindings
08:49:12 <Jackneill> by binding does it mean that of i bind x to y + 5, when y changes x changes too?
08:49:25 <hyperisco> nope, because stuff aint mutable in Haskell
08:49:25 <Jackneill> in other words it really binds, and not just assigns
08:49:28 <jle`> what do you mean by 'when y changes' ?
08:49:37 <jle`> the value of 'x' will depend on 'y', yes
08:49:41 <jle`> if y is 4, x will be 9
08:50:01 <jle`> if y is 3, x will be 8
08:50:03 <Jackneill> and its evaulated once, at compile time?
08:50:17 <hyperisco> maybe
08:50:17 <jle`> most likely not a compiletime
08:50:30 <Jackneill> so its not a constexpr
08:50:33 <jle`> consider:
08:50:39 <jle`> foo y = x * 2 where x = y+5
08:50:51 <jle`> @let myFunc y = x * 2      where x = y+5
08:50:53 <lambdabot>  Defined.
08:50:57 <jle`> > myFunc 9
08:51:00 <lambdabot>  28
08:51:01 <jle`> > myFunc 11
08:51:03 <lambdabot>  32
08:51:12 <Jackneill> i see, thank you
08:51:13 <jle`> when you pass in a different value of 'y', it will affect what 'x' is
08:51:38 <jle`> Jackneill: but if 'y' is a defined constant (not a variable), then y + 5 will also be a constant
08:51:48 <Jackneill> right
08:52:45 <jle`> Jackneill: haskell doesn't have native assignment
08:52:51 <hyperisco> I suspect that had a 20% chance of landing right
08:52:52 <jle`> it's not supported at the language level
08:53:02 <ski> Jackneill : in math (like calculus), you sometimes say something like `y = x^2 + 3', and then later if you consider `x = 2', then under that assumption `y' is then `7', while if you further down consider `x = 3', then `y' "becomes" `12' -- here `y' is said to be a dependent variable, and `x' an independent variable. in programming this corresponds to "dynamic scope" (as opposed to "static scope"). Haskell uses the latter
08:54:10 <jle`> Jackneill: if you see '=' in haskell, it is never assignment, so that's a good rule of thumb
08:54:24 <Jackneill> i see
08:54:31 <ski> (Haskell doesn't have variable assignment. it does support mutable containers, though, but not as a side-effect ..)
08:55:02 <jle`> haskell just doesn't have variable assignment/mutable containers at the syntax level
08:55:16 <jle`> it's all done using library api's
08:55:28 <ski> in the `myFunc' example above, each time that function is called, conceptually a distinct `y' variable (and also a distinct `x' variable) is created
08:56:25 <ski> each variable is initialized, and never reassigned. the actual computation of the initializing expression might not happen immediately, though, because Haskell is non-strict
08:57:02 <Putonlalla> > runIdentity $ do {x <- pure 42; x <- x + 1; x <- 2 * x; pure x} -- This may look like assignment, but it's actually not.
08:57:05 <lambdabot>  86
08:58:03 <ski> > let  myList = [0,1,2] ++ myList  in  myList  -- this is a recursive definition of an (infinite) list
08:58:06 <lambdabot>  [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1...
08:58:23 <ski> > let x = x + 1 in x  -- this is a recursive definition of a number, it doesn't terminate
08:58:26 <lambdabot>  *Exception: <<loop>>
08:59:06 <ski> (well, it so happens that GHC can sometimes detect certain simple kinds of infinite loops, and then raises an exception, which is what happened above)
09:14:38 <bbear> what is an algorithm to find if all elements in a list are the same ?
09:14:59 <jle`> maybe check if all of the items in the tail are equal to the head
09:15:21 <ski> you could compare adjacent elements
09:15:58 <jle`> @let allSame (x:xs) = all (== x) xs; allSame [] = True -- ????
09:16:00 <lambdabot>  Defined.
09:16:24 <Welkin> it's still quadratic though
09:16:38 <jle`> quadratic?
09:16:43 <nullie> How is it quadratic
09:16:48 <cppxor2arr> > allSame [1,1,1,1,1,1,1,1,1,4,1,1,1,1]
09:16:51 <lambdabot>  False
09:17:03 <jle`> > allSame (1:repeat 4)
09:17:06 <lambdabot>  False
09:17:10 <Welkin> you make elements^2 comparisons
09:17:32 <Welkin> oh
09:17:37 <Welkin> never mind
09:17:41 <cppxor2arr> yeah i was wondering what you were talking about
09:17:43 <Welkin> I was thinking of nub
09:17:51 <Welkin> checking for all unique elements
09:18:18 <nullie> I think you can use set for n log n
09:18:19 <jle`> :t all (uncurry (==)) . (zip`ap`tail)
09:18:20 <lambdabot> Eq a => [a] -> Bool
09:18:45 <jle`> ^ ski's suggestion
09:20:08 <jle`> both have the same asymptotics (O(n)), just differ by a constant factor
09:25:54 <armlesshobo> just curious: is there a way to write a recursive function that induces poor optimization?
09:26:52 <[exa]> armlesshobo: simulate the stack and closures by hand, using e.g. a list.
09:28:13 <[exa]> armlesshobo: also, there's a common argument about too much laziness that hurts (compare e.g. foldl and foldl')
09:29:45 <hyperisco> what about downloading HTTP binary content to a file
09:30:05 <hyperisco> can use Wreq to make a ByteString but that seems pretty damn clumsy
09:30:50 <Welkin> you mean converting the base64 string to binary?
09:31:02 <Welkin> I don't see how that is clumsy
09:32:05 <hyperisco> it isn't base64
09:32:41 <hyperisco> the clumsy thing is loading several hundred MBs into memory, plus w/e overhead, then writing to file
09:34:02 <Welkin> hyperisco: use pipes to stream it
09:34:17 <hyperisco> no no no
09:34:20 <Welkin> it's receiving the data in chunks anyway
09:34:42 <Welkin> how is it hundreds of Mb?
09:34:48 <hyperisco> because it is
09:34:59 <Welkin> o.o
09:35:01 <Welkin> just use wget
09:35:02 <Welkin> or curl
09:35:12 <hyperisco> those don't come with Windows
09:35:20 <Welkin> don't use windows
09:35:32 <Welkin> you can get wget/curl with cygwin I think
09:35:38 <hyperisco> well here in the real world I have constraints
09:35:40 <Welkin> or use the linux subsystems thing
09:38:56 <armlesshobo> [exa]: ok
09:39:52 <armlesshobo> [exa]: but, it's not like it's hard to discover where the problem lies right?
09:40:50 <armlesshobo> this guy is making it sound like using functional languages will hide problems, and it's so hard to figure out what the problem is, and how to fix it.
09:40:59 <armlesshobo> I have yet to ever write anything that was like that.
09:41:11 <armlesshobo> so I'm trying to deduce whether this guy is full of it or not.
09:41:43 <hyperisco> I don't think it is any more obscured than usual
09:42:11 <armlesshobo> that's how I feel
09:43:17 <hyperisco> I don't think the FP debugging tools are nearly as helpful, but I also find it uncommon to have to start up a debugger
09:43:18 <Welkin> armlesshobo: it will be far easier to identify problems, because (at least in haskell) your code will not even compile if you made some stupid mistakes
09:43:41 <Welkin> the only thing I can think of that can cause ap otential issue is the lazy evaluation, but you get used to it
09:43:57 <Welkin> just read the fish book and you'll be fine
09:44:02 <Welkin> @where parconc
09:44:02 <lambdabot> https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
09:44:29 <hyperisco> starting up a debugger is an admission of insufficient a priori knowledge of your program
09:44:31 <Welkin> lazy evaluation also gives you a lot of benefits by default
09:44:50 <hyperisco> which is something that having a more reasonable language can improve
09:44:57 <armlesshobo> we're not even talking about lazy/eager code
09:45:11 <armlesshobo> this guy painted a large stroke over recursive functions
09:45:12 <Welkin> the functional programming style, and in particular a language with a rich type system like haskell, forces you to become more disciplined
09:45:25 <Welkin> programming is no longer a haphazard activity of copy-paste-debug
09:45:26 <hyperisco> did he start talking about stack traces?
09:45:31 <armlesshobo> no
09:45:44 <hyperisco> we had a discussion yesterday about stack traces
09:46:31 <armlesshobo> just a coworker who used Scala, professionally, once
09:46:37 <Welkin> armlesshobo: people who have never used a functional language seem to fear recursion
09:47:10 <armlesshobo> he made it sound like you had to be oh-so careful with how you wrote recursive functions
09:47:22 <Welkin> you can write infinite loops sometimes
09:47:23 <Welkin> sure
09:47:29 <Welkin> but that is not common
09:47:38 <Welkin> sometimes you want an infinite loop in haskell
09:47:40 <armlesshobo> otherwise optimization will work against you
09:47:41 <Welkin> because it is lazy
09:47:44 <armlesshobo> which I don't understand that
09:48:09 <Welkin> armlesshobo: just learn the language and you will understand
09:48:23 <Welkin> there is nothing to fear, but a lot to discover
09:48:38 <armlesshobo> I have no problem with Haskell or functional languages in general
09:48:49 <armlesshobo> I've already spent my year learning Haskell, so I'm familiar with it
09:48:58 <armlesshobo> but, I'm also poor at arguing with people
09:49:06 <Welkin> don't argue with people
09:49:12 <Welkin> it is a waste of your own precious time
09:49:23 <Welkin> unless you have something significant to gain from it
09:49:27 <armlesshobo> in this case, the dude was arguing against using functional programming
09:49:36 <armlesshobo> and spreading misinformation
09:49:37 <Welkin> let him live in the dark
09:49:39 <armlesshobo> so I had to
09:50:25 <hyperisco> here we go https://hackage.haskell.org/package/simple-download-0.0.2/docs/Network-HTTP-Client-Conduit-Download.html
09:50:36 <hyperisco> see, simple
09:50:42 <Welkin> change takes time, but the trend points more and more toward functional and typed languages like haskell
09:50:50 <hyperisco> (it is in the name!)
09:51:03 <Welkin> people will eventually come around
09:51:34 <Welkin> there are always people who will be set in their old ways and refuse to change
09:52:21 <Welkin> some people even think that C is the epitome of programming languages
09:53:29 <armlesshobo> https://hackage.haskell.org/package/conduit-1.2.6.6/docs/Data-Conduit.html
09:53:38 <armlesshobo> the link on that doc page is dead
09:54:09 <Welkin> that tends to happen
09:54:20 <Welkin> only the author can fix that
09:57:00 <hisoka> Anyone knows if there is a neat way to find out if a set a coordinates are cyclic? Ex: [(1,2),(2,3),(3,1)]
09:58:54 <EvanR> attempt to build the spanning tree of the supposed directed graph
10:04:22 <kuribas> armlesshobo: 1) ghc is great at compiling functional code to efficient machine code.  2) debugging tools kinda suck in haskell, but fortunately you don't need them as often as in other languages.
10:04:35 <kuribas> armlesshobo: and testing is easier.
10:06:08 <kuribas> armlesshobo: he seems like someone who formed an opinion without spending much effort to learn about it.
10:07:44 <kuribas> makes his opinion fairly uninteresting to me
10:18:24 <kuribas> I wish the ghci debugger was less imperative...
10:31:13 <suzu> re there known gotchas with threading inside C-FFI land?
10:31:23 <suzu> seems like i can't throw exceptions to other threads..?
10:32:58 <suzu> re *
10:33:01 <suzu> are *
10:37:20 <suzu> oh i see you need to mark it as 'interruptible'..?
10:37:23 <suzu> the foreign call, that is
10:38:04 <metahumor> hyperisco: been afk, how about http-conduit
10:59:10 <manek> Hi! Could anybody explain to me what magic is used in this Control.Exception example from its haddoc docs? https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Exception.html#t:Exception    How on earth am I able to use `fromException` to these 3 types and it will not work on other types? How does it work ?
10:59:35 <manek> Does this `cast` function introduce some magic ?
11:00:18 <ab9rf> isn't all programming a form of magic?
11:02:10 <manek> I'm just wondering how GHC keeps information that I can cast the exception to some types, while I cannot to others
11:02:29 <manek> ab9rf: yeah, programming is just controling a lighting that some man put into a stone
11:02:33 <manek> so its magic
11:04:04 <jle`> manek: as far as api goes, it's pretty vanilla haskell
11:04:07 <ab9rf> manek: look at Data.Typeable and the definition of cast
11:04:12 <jle`> it's similar to 'read'
11:04:14 <jle`> :t read
11:04:16 <lambdabot> Read a => String -> a
11:04:26 <jle`> or maybe readMaybe
11:04:29 <jle`> :t readMaybe
11:04:30 <lambdabot> error: Variable not in scope: readMaybe
11:04:36 <jle`> @let import Text.Read
11:04:39 <lambdabot>  Defined.
11:04:40 <jle`> :t readMaybe
11:04:41 <lambdabot> Read a => String -> Maybe a
11:04:53 <jle`> replace 'Read' with 'Exception', 'String' with 'SomeException'
11:05:00 <jle`> and it's pretty much the same 'magic' as read
11:05:18 <jle`> > readMaybe "3" :: Maybe Int
11:05:18 <manek> jle`: ok, maybe my concerns are not clear enough, look:
11:05:20 <lambdabot>  Just 3
11:05:23 <jle`> > readMaybe "3" :: Maybe Bool
11:05:27 <lambdabot>  Nothing
11:05:37 <jle`> "3"-the-string can be "cast" into Int, but not Bool
11:05:43 <manek> jle`: you define there : data SomeCompilerException = forall e . Exception e => SomeCompilerException e   AND  data SomeFrontendException = forall e . Exception e => SomeFrontendException e
11:06:06 <manek> jle`: then you create one of those, convert it to SomeException and then you could cast it to EITHER of these
11:06:08 <ab9rf> it does rely on GHC's internal type fingerprinting
11:06:40 <ab9rf> a can be cast onto b if a and b have equivalent internal type fingerprints
11:06:49 <jle`> that's like saying you can define Double and Float, and "3.0" can be cast to EITHER of those types
11:06:53 <jle`> > read "3.0" :: Maybe Double
11:06:55 <cocreature> jle`: I’m not sure it’s fair to say that Typeable is not magic
11:06:56 <lambdabot>  *Exception: Prelude.read: no parse
11:07:15 <jle`> > readMaybe "3.0" :: Maybe Double
11:07:18 <lambdabot>  Just 3.0
11:07:23 <jle`> > readMaybe "3.0" :: Maybe Float
11:07:26 <lambdabot>  Just 3.0
11:07:54 <ab9rf> type fingerprints are starting to dig into compiler internals
11:07:58 <jle`> the magic is type inference
11:08:11 <ab9rf> and it does use unsafeCoerce
11:08:13 <manek> ab9rf, jle` I get it that we can csast types if they have the same internal representation. What I dont get here is that when we are following this example, then we are throwing MismatchedParentheses and following the rabbit hole, it means that we are constructing:
11:08:46 <manek> ab9rf, jle` : SomeCompilerException (SomeFrontendException MismatchedParentheses)
11:08:48 <manek> right ?
11:08:58 <jle`> i'm not talking about the same internal representation; i'm talking about 'parsing' some type out of some blobby can-represent-multiple-things type, and using type inference to pick which typeclass instance you watn to parse
11:09:16 <ab9rf> jle`: well, yeah, but i'm not sure that's analogous
11:09:30 <manek> ab9rf, jle` : then, whats interesting, we can catch EITHER of them, but as docs states , no other. So GHC have to remember that we can cast back to EITHER (even in other  order) but not other, which could have the same internal repr
11:09:42 <jle`> you're basically parsing a SomeException into a value of type 'e'
11:09:44 <ab9rf> manek: i've lost the polot here
11:09:46 <ab9rf> er, plot
11:09:49 <jle`> where each instance of 'e' gets to define its own parser
11:10:03 <jle`> same as how Read lets you parse a String into a value of type 'a', where each instance of Read gets to define its own parser
11:10:08 <jle`> *each instance of Exception, earlier
11:10:36 <manek> jle`: Hmm, ok, assuming I really understand how Read and typeclasses work, I really dont get how this works, because we are not defining such instances here
11:10:40 <jle`> the magic is actually the 'throwing', which taps into the runtime system
11:10:51 <cocreature> no the magic is the Typeable existential constraint
11:11:16 <manek> cocreature: I was suspecting this, could you elaborate more ?
11:11:16 <cocreature> which allows you to check how the SomeException was constructed
11:11:19 <jle`> i feel like it could be implemented without Typeable, Typeable just makes it convenient
11:11:25 <manek> cocreature: exactly!
11:11:33 <manek> cocreature: how it works? are there any docs on it ?
11:12:22 <jle`> manek: you *do* define such instances
11:12:28 <jle`> that's what the Exception class is
11:12:37 <piark_> hello
11:12:43 <cocreature> manek: are you familiar with ExistentialQuantification?
11:12:49 <manek> cocreature: yes
11:13:00 <manek> jle`: if you look at this examole there are soem intances missing like
11:13:47 <cocreature> manek: Typeable basically defines a unique identifier for each type. generating that identifier is builtin compiler magic. if you use "cast" GHC checks if these identifiers to see if the cast is possible
11:13:55 <manek> jle`: or err. Look, Im creating SomeException out of `SomeCompilerException (SomeFrontendException MismatchedParentheses)` but I can catch it as `SomeFrontendException MismatchedParentheses` - this is magic
11:14:26 <jle`> that's not magic
11:14:34 <jle`> that's the SomeFrontendException instance of Exception
11:14:38 <manek> cocreature: Oh, so when you define multiple existential types on top of each other and you cast back then GHC checks if either of these identifiers matches ?
11:14:48 <jle`> SomeFrontendException has an Exception instance that lets you parse SomeException as that
11:15:20 <manek> jle`: no, because SomeFrontendException instance of Exception clearly states that it needs `SomeFrontendException` and we've provided `SomeFrontendException` instead, but it still works
11:15:24 <cocreature> manek: no that’s part of the Exception typeclass, I recommend that you take a look at https://simonmar.github.io/bib/papers/ext-exceptions.pdf
11:18:06 <MacSlow> Greetings folks!
11:18:08 <manek> cocreature: Thanks I will look at it now, hwoever, would you be so nice and just tell me really coarse grained (if its possible) how GHC tracks the information that type `X(Y(Z))` I can cast to `X(Y(Z))` AND to `Y(Z)` and to `Z` but not to `W` (even if the internal repr is the same) ? Because if GHC doesnt keep the set of possible IDS then I just dont get how it culd be done
11:18:56 <shapr> hi MacSlow! How's code?
11:19:19 <shapr> I taught "parsing in haskell" today at lunch to coworkers, went really well!
11:19:23 <suzu> !!!
11:19:26 <cocreature> manek: if you take a look at the implementation of fromException for MismatchedParentheses you can see that it itself calls fromException again, that’s how you get multiple levels of unwrapping
11:19:44 <cocreature> manek: but I really recommend the paper. it’s quite easy to read and has a lot of examples
11:20:34 <shapr> The people who came to my class can now write excellent attoparsec parsers, and have never heard of applicative, etc
11:20:56 <MacSlow> shapr: nothing much... still learning the language... half way through G. Hutton's book "Programming in Haskell".
11:21:05 <shapr> oh cool! What do you think?
11:21:12 <shapr> I read most of the 1st edition, but haven't read the 2nd edition yet
11:22:12 <MacSlow> hm... I think it's solid and I get along well, but I still have to rewire my brain from C++ here and there
11:22:46 <MacSlow> I guess Haskell is easier to pick up as a first language, for people who never coded before
11:23:39 <MacSlow> for algorithms it superb... but the whole I/O and monad story is... weird :)
11:23:54 <MacSlow> hope it gets better with time
11:24:08 <cocreature> MacSlow: interestingly most Haskellers will tell you that IO is where Haskell shines :)
11:24:21 <shapr> I'm trying to pick up C++ now, and my brain is hurting.
11:24:46 <manek> cocreature, jle`, ab9rf : After considering it again its clear and ugh, jle` 's explanation about the "read" is completely valid. I'm really sorry - I was thinking that we are not unwraping this in order
11:24:55 <MacSlow> also interesting to see where C++ got much of its inspiration from for the extension of the language and STL
11:25:00 <shapr> In C++ I can't make a vector of char array because ... it's assignment? what?
11:25:20 <manek> but we are. If we are unwrapping these things in order there is no magic needed. Strangely I was not seeing this properly at all
11:25:33 <shapr> Feels to me like that Haskell is more consistent than C++
11:25:39 <MacSlow> std::vector<std::array<char, n>>
11:25:51 <MacSlow> a bit weird to do that :)
11:25:53 <shapr> ah, but I need to hold char[64] and that's right out
11:26:01 <manek> cocreature, jle`, ab9rf : thanks so much for the help and once again sorry for the confusion
11:26:17 <shapr> MacSlow: what got you started with Haskell?
11:26:53 <MacSlow> shapr: but an unordered_map (think hash-table) might be more what you want
11:27:34 <MacSlow> shapr: the clean syntax and prospect of effortless parallelism
11:28:02 <shapr> For my C++ code, I'm wrapping a C SDK created in the 1980s. It's just old and creaky and won't get any better.
11:28:15 <shapr> oh yeah! those are good reasons!
11:28:51 <MacSlow> I'm still not such a big fan of giving up memory-control and bit-twisting... I don't trust GC, but that might be because of JavaScript and the headache it can give you
11:29:24 <shapr> In my first attempt at effortless parallelism, I spawned off several hundred OS threads with parMap and my program immediately ate 84GB of ram, so I learned about parBuffer
11:29:39 <MacSlow> shapr: oh... I feel for you... are you writing a haskell binding to a C API?
11:30:28 <shapr> I wish, I'm using a C++ SDK that wraps 1980s AT&T code
11:30:48 <[Leary]> I don't understand it fully myself MacSlow, but if you look into the GHC Commentary on GC you'll see the way it's done is pretty clever and sensible. Managing memory in Haskell usually comes down to knowing which functions or data types want strict fields.
11:30:54 <shapr> Speaking of which, I wonder if language-c parses C++ code as well as plain C?
11:31:13 <shapr> MacSlow: I'm not smart enough to manage my own memory.
11:31:49 <shapr> Along the same lines, I'm having to relearn posix threads, I got so used to software transactional memory I just forgot how to do threads, mutexes, etc
11:31:49 <Bowlslaw> is Haskell really a pure language?
11:31:54 <MacSlow> shapr: well in the ANSI-C world one needs tons of discipline... in the C++-world we have RAII for that
11:31:54 <shapr> Bowlslaw: yup!
11:32:04 <Bowlslaw> well what about IO ?
11:32:09 <shapr> Bowlslaw: yup!
11:32:18 <Bowlslaw> i don't understand
11:32:29 <bontaq``> shoot how'd everyone forget about IO
11:32:37 <Bowlslaw> IO isn't pure but Haskell has IO
11:32:39 <Bowlslaw> so...
11:32:42 <shapr> MacSlow: seems to me Haskell pushes the required discipline into the language, and then I don't have to think about it.
11:32:52 <Psybur> I thought IO was pure? :D
11:33:09 <shapr> Bowlslaw: have you seen how Haskell code passes around state?
11:33:18 <MacSlow> shapr: sure... as a garbage-collected language you have to trust the compiler
11:33:22 <Bowlslaw> a little bit
11:33:28 <jedai> Bowlslaw: it may be easier to see a Haskell program as a pure program that evaluates to an impure IO programs that gets executed by the runtime
11:33:53 <jedai> Bowlslaw: that's actually an useful way to see it too
11:33:59 <shapr> MacSlow: same thing with doing 'threading' with STM, I know I can trust everything to be thread safe
11:34:12 <shapr> also, compositional!
11:34:29 <MacSlow> but from my beginner point-of-view the way the language "guides" one is very nice... once I get my head around it... some exercises in the book are easy... other not so much... especially IO
11:34:49 <shapr> If you mix two C/C++ codebases that use threads, you need to verify thread safety all over again, but STM programs will just work.
11:35:00 <shapr> yeah, that's a brain twister, I agree
11:35:19 <davean> Bowlslaw: Haskell didn't have IO until people figured out how to provide it purely
11:35:23 <MacSlow> Haskell's currying and the . are really very cool
11:35:51 <shapr> MacSlow: also seems to me that generic datatypes are easier than STL
11:35:59 <jedai> Bowlslaw: for instance main = readFile "origin" >>= writeFile "copy"
11:36:26 <Bowlslaw> hmm
11:36:56 <jedai> main isn't impure, it's just a IO value, it always evaluates to the same IO value, the composite IO value that reads a file "origin" and write its content to a file "copy"
11:36:59 <MacSlow> shapr: yeah C++'s templates can get entangled... I don't do/like deep-dive template meta-programming
11:37:09 <Psybur> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
11:37:38 <shapr> yeah, when I tried to push_back a char[64] into a vector<char[64]> the error was quite scary
11:37:42 <jedai> Bowlslaw: the impurity only appears when you actually _execute_ this IO value and starts doing Input/Output in earnest
11:38:00 <davean> You can talk about the IO yopu want to do all day long
11:38:18 <shapr> On the other hand, when you become a type astronaut, you can get equally terrifying errors out of Haskell.
11:38:28 <davean> shapr: wibble?
11:38:36 <johnw> a typstronaut?
11:38:41 <davean> shapr: Its really more of a sad error then a terrifying one
11:38:44 <shapr> davean: are you channeling Igloo_ today?
11:38:52 <shapr> Igloo_: how's the wibble?
11:38:59 <MacSlow> shapr: for (modern) C++ general rule of thumb is... try to use std::array... if that to unflexible got for std::vector ... and only then (if planets align) consider std::list
11:39:01 <davean> shapr: Thats the error you get when you go type astronauting
11:39:14 <shapr> oh, that's what it's called? must have originated with Igloo_
11:39:29 <MacSlow> I use std::vector as much as possible
11:39:40 <shapr> MacSlow: I'm slowly learning that kind of thing, I've done my best to skip C++ up to this point
11:39:59 <shapr> exarkun: hi!
11:40:21 <MacSlow> shapr: C++ starting with the C++11 standard is really good, if you avoid the "legacy" stuff
11:40:40 <shapr> yeah, that's what we're doing, but it's confusing some of my common tools
11:41:00 <davean> MacSlow: I wasn't happy with the lambdas ...
11:41:19 <shapr> MacSlow: have you done parsing in Haskell yet?
11:41:48 <shapr> I taught a parsing lesson at lunch today! look at this cool code! https://github.com/shapr/sandsieve/blob/master/Main.hs
11:41:57 <MacSlow> shapr: and also _use_ the STL whenever possible, especially algorithms
11:41:59 <hyperisco> dammit shelly why are you appending .exe onto things
11:42:04 <hyperisco> now it can't find the command I need to run -.-
11:42:37 <davean> Also the way function pointers were defined was very ... C
11:42:52 <MacSlow> davean: no... not really into these kind of things, but if I ever would be "forced" to write a parser, I would certainly do that in Haskell
11:43:00 <hyperisco> even though I am staring at the source… is there a way to have it not do this
11:43:13 <hyperisco> please don't make me rip out of the one thing that underpins my entire program
11:43:50 <MacSlow> davean: as part of G. Hutton's book, I've done a basic math-term analyser (don't really want to call it parser) and it was semantically super dense code and really easy to follow and extend
11:44:16 <MacSlow> davean: I would have taken me some days to do that in C++ I bet
11:44:18 <davean> MacSlow: why are you directing this to me?
11:44:41 <MacSlow> davean: ups... was meant for shapr sorry :)
11:44:51 <Psybur> shapr, are parseBits and parsedThings used in that code?
11:44:57 <MacSlow> nick-name completion got the better of me
11:44:59 <hyperisco> if I wanted .exe I would type in .exe dammit
11:45:17 <MacSlow> shapr: as part of G. Hutton's book, I've done a basic math-term analyser (don't really want to call it parser) and it was semantically super dense code and really easy to follow and extend
11:45:40 <Psybur> Seems like they are defined but not used?
11:47:28 <davean> hyperisco: the shelly source code looks pretty damning at first glance
11:47:51 <davean> it requires *some* extension to not add exe it looks like ...
11:47:56 <hyperisco> yup
11:48:14 <hyperisco> thankfully there happens to be a .cmd which defers to the extensionless exe
11:48:29 <hyperisco> mindboggling
11:48:36 <MacSlow> shapr: btw regarding C++, the best book to get a clean (undistracted) view of modern C++ is the book "A Tour of C++" from B. Stroustrup.
11:49:16 <hyperisco> it is true that cmd.exe will look for .exe stuff without you writing in the extension, but that's not the same logic shelly has here
11:49:29 <MacSlow> shapr: it's thin, less than 170 pages
11:50:15 <hyperisco> lol amazing… decided to type in bower to hackage on the off chance someone has already parsed bower.json
11:50:23 <hyperisco> aaaand… yup! thanks to Harry Garrood
11:50:32 <davean> hyperisco: Thank you for saving m eever considering shelly
11:50:45 <hyperisco> davean, well it otherwise has been very helpful
11:51:16 <hyperisco> davean, it is like you are writing a shell script, except shell scripting is horrendous, so this is better
11:51:23 <hyperisco> but still makes some weird decisions it seems
11:51:31 <hyperisco> anyways, it is meant to be quick and dirty
11:51:39 <Ariakenom> Is assert used often in hs code?
11:51:48 <hyperisco> no
11:51:55 <ggVGc> yes... in tests
11:52:05 * ski . o O ( "Effective Modern C++" )
11:52:13 <Ariakenom> as in Control.Exceptions.Base's assert
11:52:18 <ggVGc> Ariakenom: we kind of don't like our code crashing so much
11:52:30 <ggVGc> rather, at all
11:52:34 <davean> I've litterly never seen that used in code
11:52:46 <davean> I can't immagine anyone uses it
11:53:01 <[Leary]> I could see it being good for debugging.
11:53:06 <ggVGc> assert :: a -> Maybe a ?
11:53:09 <ggVGc> ho ho
11:53:24 <ggVGc> sorry, assert :: IO a -> IO (Maybe a)
11:53:47 <Psybur> :t assert
11:53:48 <lambdabot> Bool -> a -> a
11:53:53 <Ariakenom> I was thinking about the function f lo hi = min hi . max lo
11:54:05 <Ariakenom> don't remember what the name of f should be
11:54:24 <metahumor> Ariakenom: setBound>
11:54:28 <metahumor> Ariakenom: setBound?
11:54:37 <Ariakenom> no. clip? clasp? there's some common name
11:54:47 <amalloy> clamp
11:54:58 <Ariakenom> oh yeah thanks
11:55:00 <metahumor> crab?
11:55:22 <ggVGc> cringe?
11:55:48 <Ariakenom> Because it probably could use assert clamp lo hi = assert (lo <= hi) . min hi . max lo
11:58:03 <Ariakenom> But I've never seen assert in hs code either so I had to air my thoughts. Also it has the same (stupid) behaviour as python of disabling it with -O flags on.
11:59:03 <davean> Ariakenom: I can think of some numerical structures where that assert isn't entirely sensible
11:59:37 <Ariakenom> Less existential more constructive pl0x.
12:00:26 <davean> ?
12:00:34 <Ariakenom> Could I have an example?
12:00:54 <davean> I'm more tempted to give a proof by contradiction given your reply ...
12:00:59 <davean> but any modular structure at all
12:01:55 <Ariakenom> Right, but should it have Ord. Then the definition is also sensible?
12:02:18 <davean> The definition of clamp is sensible, the assert is not
12:02:43 <davean> The assert mearly makes it not work for many cases it would otherwise be correct for
12:03:31 <Ariakenom> Would it? Because without the asssert the order of min and max matters? While it should be equivalent either way?
12:04:06 <davean> It gives different results in the other order
12:04:32 <davean> It depends on what you want the fucntion to mean I guess
12:05:19 <davean> what properties are you asserting that function has?
12:05:43 <consus> Hi folks
12:05:51 <shapr> Psybur: I used those for demonstrating how to call the parsing code
12:06:17 <Eduard_Munteanu> Hi.
12:06:19 <davean> Ariakenom: remember, which range you're talking about can be defined by the order you list them in
12:06:38 <davean> modular structures lead to that directly
12:06:39 <hyperisco> also when writing these "shell scripts" I like using a lot of $
12:06:44 <Ariakenom> No. I have an Ord instance. That's the order.
12:06:50 <davean> Yes, that is the order
12:06:53 <consus> Say, I have a record that has f1 f2 f3 (functions that take different number of arguments). Is it somehow possible to write a function that takes a record field, and partially it applies to newly constructed record?
12:06:53 <davean> Thats great
12:07:02 <shapr> Psybur: that let me show how Either is used for success with content, and failure with content
12:07:04 <davean> The order can wrap though, for example
12:07:28 <davean> Ariakenom: consider a circle
12:08:19 <EvanR> erm... Ord on a circle seems to be breaking some laws
12:08:32 <EvanR> youd need a cyclic order which takes 3 params
12:08:37 <davean> EvanR: thats why I said mod
12:08:54 * EvanR commands Fs for mod
12:09:10 <EvanR> yeah i still think its broken
12:09:19 <EvanR> transitivity doesnt hold
12:10:02 <davean> EvanR: then its broken on Word
12:10:34 <mnoonan> davean: no, Ord isn't expected to respect Num instances
12:10:46 <mnoonan> but it *is* supposed to be a total order
12:10:48 <davean> mnoonan: hum?
12:11:27 <EvanR> i was thrown off thinking you meant Word formed some sort of circle
12:11:30 <mnoonan> davean: there isn't anything (informally, in haskell) that requires "x < x + 1", for example
12:11:32 <EvanR> its a linear order
12:11:39 <davean> EvanR: yes, and its modular
12:11:48 <davean> mnoonan: of course not
12:12:13 <EvanR> this is a bad way to characterize the numbers mod n
12:12:15 <mnoonan> well that's the only sense in which Word is a circle :|
12:12:17 <EvanR> its not a circle
12:12:28 <shapr> oh well, I was going to tell Psybur that I chose that approach due to https://mkremins.github.io/blog/doors-headaches-intellectual-need/
12:12:31 <davean> EvanR: I didn't say it was, I was trying an analogy
12:12:47 <shapr> @tell Psybur I chose to show parsing without teaching Applicative, etc due to https://mkremins.github.io/blog/doors-headaches-intellectual-need/
12:12:48 <lambdabot> Consider it noted.
12:13:06 <davean> my point was the function has a perfectly sensible meaning when lo < hi
12:13:20 <davean> and it performs in many ways the same function then, for a number of Ord instances
12:13:22 <Ariakenom> hi < lo?
12:13:26 <davean> er, yes
12:13:54 <Ariakenom> I don't think I've received an explanaition yet though?
12:14:04 <amalloy> consus: it's not really clear what you're asking for. you have (f, g, h) :: (a -> x, a -> y, a -> z), and you wish to apply them all to a single a, yielding (x, y, z)?
12:14:23 <amalloy> of course they're not really in a tuple, they're record functions, but same idea
12:14:38 <consus> Nah
12:14:39 <EvanR> you can do that with vinyl
12:15:31 <consus> E.g. I do have this record: https://paste.pound-python.org/show/rsRpQPfLRC2jtSqHBN7B/
12:15:31 <cheater> hi
12:15:37 <consus> Generated via servant-client
12:15:43 <cheater> can someone suggest a book on semiotics in programming languages?
12:17:01 <consus> I want to be able to somehow do the following: `runAPI getClient id` where runAPI asks record value from a monad applies getClient and id to it and runs the computation. If it fails it regenerates record using another JWT token
12:17:56 <hyperisco> half my work is moving between String and Text
12:18:04 <consus> Unfortunately, servaut-auth-client generates functions with already applied JWT token. So instead of passing parameters I have to generate new record =/
12:18:05 <ski> > let x :: Int8; x = 127 in x < x + 1
12:18:08 <lambdabot>  False
12:18:33 <EvanR> hyperisco: where is String coming up?
12:18:50 <hyperisco> lets call them legacy APIs
12:18:54 <hyperisco> if you consider String legacy
12:19:09 <EvanR> who is in charge of those APIs ?
12:19:13 <EvanR> you?
12:19:31 <cheater> the consumers
12:19:34 <cheater> hahaha
12:19:59 <EvanR> if not, you can make wrappers for the API
12:20:08 <EvanR> then you dont unpack at every call site
12:20:46 <EvanR> i was actually curious where String is coming up
12:20:57 <Ariakenom> davean: What sensible definition do you prospose exactly?
12:23:15 <shapr> I've switched my code to Text wherever possible.
12:23:46 <EvanR> e.g. i know fail from Monad requires String... but that doesnt come up much
12:23:56 * ski thinks `lo <= clamp lo hi x && clamp lo hi x <= hi = True' sounds pretty reasonable ..
12:24:03 <asheshambasta> hey guys, I'm looking at the documentation for AES enc/dec here: https://hackage.haskell.org/package/AES-0.2.9/docs/Codec-Crypto-AES.html
12:24:24 <EvanR> custom exceptions use the Show instance...
12:24:44 <asheshambasta> am I right to think that crypt and crypt' functions will throw exceptions when the input cannot be decrypted?
12:25:08 <amalloy> Ariakenom: suppose we are working mod 10. then the closed interval [5, 8] is a "reasonable" place to clamp things (permit only the numbers [5,6,7,8]), but so is the closed interval [8, 5] (permit any number except 6 or 7). i think this may be what davean is thinking of, but i'm not sure it's a good counterexample since your implementation of clamp doesn't work for that case anyway
12:25:17 <Ariakenom> ski: For a law yes. Although I would omit  =True.
12:25:57 <ski> why ?
12:26:32 <ski> amalloy : ah .. hmm
12:26:44 <Ariakenom> amalloy: That's for clamp
12:26:46 <Ariakenom> sry
12:27:06 <Ariakenom> amalloy: Taht's for clamp :: Ord a => a -> a -> Maybe a
12:27:20 <consus_> amalloy: Any ideas?
12:27:21 <Ariakenom> But what do you clamp to in a circle?
12:27:49 <amalloy> consus_: no, i now feel i understand your problem even less well and hope someone else can help you
12:27:57 <consus_> :D
12:28:07 <Ariakenom> (I want clamp :: Ord a => a -> a -> a)
12:28:19 <chessai> what is the problem?
12:29:44 <Ariakenom> ski: I suppose I just considered <= statements rather than operators. And didn't distinguish == and =. A law is True. (A law is True) is True ...
12:30:27 <Ariakenom> A law. A law is True. "A law is True" is True ...
12:30:46 <consus_> chessai: Mine?
12:31:20 <chessai> consus_: yours or Ariakenom's
12:31:35 <consus_> chessai: oh, I want a strange thing
12:31:39 <shapr> howdy chessai !
12:31:55 <chessai> shapr: hi
12:32:00 <EvanR> Ariakenom: if you have Ord, then according to Ord, you do not have a circle
12:32:00 <chessai> consus_: what is it
12:32:07 <EvanR> so you dont have to consider it
12:32:12 <consus_> chessai: consider the following code https://paste.pound-python.org/show/dLZvi32qbMNn1F9y0UwR/
12:32:23 <EvanR> Ord can comprehend circles
12:32:24 <EvanR> cannot*
12:32:27 <chessai> consus_: considering
12:32:59 <consus_> chessai: I want to somehow be able to write a function that takes a HttpAPI's field + arguments and apply it to a generated record
12:33:11 <consus_> chessai: I'm thinking of template haskell
12:33:16 <EvanR> if you have Ord a, then a is organized into a "line"
12:34:01 <EvanR> so clamp seems easy to state
12:34:23 <Ariakenom> Evanr: Yes. Do you like `clamp lo hi = assert (lo <=  hi) . max lo . min hi` then?
12:34:40 <EvanR> not really
12:34:54 <Ariakenom> Exciting.
12:35:22 <ski> Ariakenom : yea, `(==)' is a function you can call. `=' forms a proposition out of two expressions
12:35:54 <chessai> consus_: elaborate
12:36:43 <ski> e.g. one could require as laws on `Eq' : `forall x y. x == y = True => x = y' and `forall x y. x == y = False => x =/= y'
12:36:44 <Ariakenom> ski: Or a law is True :: Bool? sry :p
12:37:28 <ski> if `(==)' terminates with `True', then the values'd better be operationally/observationally indistinguishable
12:37:44 <ski> it it terminates with `False', then they'd better be distinguishable
12:37:52 <consus_> chessai: Hmm... So I want to query HTTP API using servant-client. It takes a type (API) a token (jwt in mkHttpAPI) and generates a bunch of client functions (HttpAPI). The problem is that jwt token has a very short lifespan.
12:38:00 <ski> if it doesn't terminate (like `[0 ..] == [0 ..]', e.g.), then all bets are off
12:38:16 <consus_> chessai: And I want to automatically refresh it on 401 error.
12:38:46 <EvanR> [0..] and [0..] are not unequal
12:38:47 <consus_> chessai: So either I check for exception at every call site or I somehow wrap it inside a monad
12:39:01 <Ariakenom> EvanR: Do you have a `clamp = ...` suggestion?
12:39:17 <ski> EvanR : exactly
12:39:27 <consus_> chessai: Another problem is that I have to generate new HttpAPI instance after I acquire new jwt token
12:39:56 <consus_> chessai: Because it's not a parameter, it's essentially IN the generate function
12:40:04 <ski> now consider using `(==)' on two elements of a finitely presented group (cue the word problem)
12:42:37 <davean> amalloy: That is what I was getting at
12:42:57 <chessai> consus_: that sounds interesting, but i'm not sure what the best approach is
12:43:06 <Ariakenom> ski: I was just viewing a law as something that ideally evaluates to True. With ideally distinguishing from Haskellishly. Because that how I tend to view it. Is it wrong?
12:43:10 <consus_> chessai: Me too
12:43:36 <consus_> chessai: It feels like it would be easier to actually ask this JWT token because ClientM is a monad anyway
12:43:50 <consus_> chessai: And it already has a state
12:43:54 <EvanR> ideally true, cool modality
12:44:29 <chessai> Ariakenom: A law can almost be seen as a predicate on values (x1,x2,x3,...,xN) of Type A, such that for all x_i, the predicate is satisfied
12:44:36 <marmistrz> Hi! I have trouble compiling packages with Cabal. I've already set the configuration options in ~/.cabal/config as described here [1], but they seem not to be picked up by cabal
12:44:43 <marmistrz> I'm running Arch Linux so I need to link dynamically
12:44:48 <EvanR> ideally, I have $100 in my hand
12:45:12 <marmistrz> If I do `cabal install haskell-gi --enable-shared --enable-executable-dynamic --disable-library-vanilla`, everything compiles fine
12:45:46 <marmistrz> But if I modify ~/.cabal/config instead, as described in [1], I still get the errors about prelude not being detected
12:45:48 <marmistrz> [1] https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
12:45:57 <consus_> chessai: But it was done another way... So I thought about generating a real function using TH and using another monad to hold the jwt token state (MVar or something)
12:45:59 <marmistrz> do you have an idea why cabal is not picking up those options?
12:46:10 <chessai> Ariakenom: For example, 'Ord' as a typeclass has three laws: antisymmetry, transitivity, and totality
12:46:46 <marmistrz> (I'm trying to compile leksah under Arch Linux with cabal)
12:47:25 <chessai> Ariakenom: For a type A, there is a total ordering on A if, forall (a : A), (b : A), (c : A),
12:47:25 <chessai> if (a <= b) && (b <= a) then a == b (antisymmetry)
12:47:25 <chessai> if (a <= b) && (b <= c) then (a <= c) (transitivity)
12:47:25 <chessai> (a <= b) || (b <= a) == True (totality)
12:48:07 <EvanR> what about <
12:48:22 <chessai> EvanR: what about it
12:48:31 <EvanR> seems like you could state some laws there
12:48:56 <karim_antoun[m]> Liquid fax
12:50:23 <Ariakenom> chessai: So, in conclusion, yes?
12:50:25 <metahumor> just a reminder that equality and comparison laws are broken in nasty ways for daily-use-numerical-types
12:50:59 <EvanR> isnt that why laws were made?
12:51:25 <chessai> Ariakenom: sort of, the predicate just needs to be satisfied, doesn't necessarily need to be "True"
12:51:33 <chessai> Ariakenom: could be false
12:51:47 <EvanR> (== True) is a bit redundant to state
12:52:15 <chessai> EvanR: I was trying to be clear by making the visual formatting similar to the previous statements
12:52:47 <chessai> EvanR: though i can see that in this context, given Ariakenom's previous questions how it could potentially be misleading
12:53:18 <Ariakenom> `(==True) = id` indeed
12:53:44 <chessai> Technically, the definition I gave is not strong enough, since it assumes that values of A are reflexive, ie
12:53:44 <chessai> (a <= a) <--- this is just Eq
12:54:18 <chessai> not quite Eq, but the idea is there
12:54:44 <chessai> Ariakenom: do you understand laws now
12:55:54 <oo_miguel> Can I imagine that the the ghci prompt runs all my commands inside one big "do block" or is this completely false. I can not understand how else for instance getStdGen returns different values without any paramaters supplied by me.
12:56:01 <ski> Ariakenom : it's not bad. i just tend to more sharply distinguish between the Haskell value `True', which can be the result of evaluating an expression of type `Bool', and the meta-language notion of "true", which would be what a proposition (not a Haskell expression) might "evaluate" to)
12:57:32 <consus_> chessai: I'm stupid, I should just use a lambda
12:58:36 <consus_> chessai: cased closed
12:58:40 <consus_> *case closed
12:59:02 <amalloy> oo_miguel: yes, that is a reasonable working understanding
12:59:21 <oo_miguel> amalloy: ok glad to hear that, thank you!
12:59:22 <EvanR> it was, at least until they allowed x = 2 syntax
12:59:28 <EvanR> and data declarations, and other things
13:00:14 <chessai> oo_miguel: https://github.com/ghc/ghc/blob/master/ghc/Main.hs
13:00:34 <EvanR> haha evaluating a proposition to get true or false, like entscheidungsproblem
13:00:46 <chessai> oo_miguel: wrong link
13:03:25 <ski> yea, there's a reason i put that in scare quotes
13:11:10 <Sorabji> I can't get cabal to run on my machine, are there any alternatives to grabbing packages so that I don't have to enter dependency hell?
13:11:50 <mizu_no_oto> Sorabji: What's the issue you're having with cabal?
13:12:18 <Sorabji> mizu_no_oto: I'll get the error message, bear with.
13:12:27 <Sorabji> me.
13:20:01 <Sorabji> mizu_no_oto: The procedure entry point _wsplitpath_s could not be located in the dynamic link library msvcrt.dll
13:21:32 <hdon> hi all :) haskell newb here. System.Environment.getArgs's return type is IO [String] -- and so i can't seem to do something i thought would be simple like "head getArgs". any tips would be appreciated :)
13:22:31 <mizu_no_oto> Sorabji: How are you trying to install cabal, out of curiosity?
13:22:34 <glguy> hdon: You can bind the result of executing getArgs and then you can apply head to that result: do args <- getArgs; print (head args)
13:23:21 <mizu_no_oto> :t fmap head getArgs
13:23:22 <lambdabot> error: Variable not in scope: getArgs :: f [b]
13:23:33 <mizu_no_oto> :t fmap head Sytem.Environment.getArgs
13:23:35 <lambdabot> error:
13:23:35 <lambdabot>     Not in scope: ‘Sytem.Environment.getArgs’
13:23:35 <lambdabot>     No module named ‘Sytem.Environment’ is imported.
13:23:50 <mizu_no_oto> :t fmap head System.Environment.getArgs
13:23:50 <hdon> glguy: ahhh thanks :) is "<-" different from "=" in that it deals with impure functions? and am i right in guessing that "IO" signifies impurity/side-effects in haskell?
13:23:51 <lambdabot> IO String
13:24:07 <Sorabji> Sorabji, I've tried the executable along with the Haskell package advertised on the Haskell website.
13:24:36 <Sorabji> Both output the same error, though I've managed to get a standalone release of Haskell working.
13:25:12 <mizu_no_oto> hdon: Kinda
13:25:14 <glguy> hdon: functions are something else, <- is part of do-notation, = is for naming a value
13:25:48 <mizu_no_oto> Sorabji: Have you tried installing the Haskell Platform? https://www.haskell.org/platform/
13:26:00 <hdon> hmm... i can see i am still missing some critical understanding :) thanks guys
13:26:05 <Sorabji> Yes, same error...
13:26:31 <Sorabji> This is the last time I use Windows for anything.
13:27:19 <davean> Sorabji: What version of windows are you using?
13:27:29 <Sorabji> davean: Windows xp.
13:27:36 <oo_miguel> wow
13:27:39 <MacSlow> XP?!
13:27:44 <MacSlow> you kidding, right? :)
13:28:01 <oo_miguel> did not support end a few years ago?
13:28:13 <davean> oo_miguel: I think not for the military?
13:28:16 <chessai> MacSlow: I was going to suggest switching to Nix but holy crap.
13:28:28 <chessai> Sorabji: ^
13:28:44 <Sorabji> I can't get a nix system running on this machine haha.
13:28:45 <MacSlow> what military/army?
13:28:48 <oo_miguel> As of May 2017, around 60% of the 220,000 ATMs in India still run Windows XP
13:28:58 <MacSlow> oh dear
13:28:59 <davean> Support for XP ended in 2014
13:29:24 <MarcelineVQ> every dentist office you walk into is using xp :>
13:29:43 <MarcelineVQ> luckily tooth cavity data isn't expecially sensitive, unlike the tooth
13:29:44 <mizu_no_oto> hdon: do args <- getArgs; print (head args) is syntactic sugar for "getArgs >>= (\args -> print (head args))"
13:29:55 <Tuplanolla> My Windows development machine still has XP as well.
13:30:00 <Sorabji> It's still used in physics apparently so that the code base doesn't break.
13:30:04 <Tuplanolla> I haven't booted it in a few years though.
13:30:20 <MacSlow> XP in a VM would be acceptable... but for real... poor souls :)
13:31:37 <davean> Sorabji: You could grab an old release and bootstrap it forward
13:32:19 <Sorabji> davean: I've tried that also...
13:32:23 <metahumor> hdon: do you know how (>>=) works?
13:32:27 <davean> Sorabji: ?
13:32:36 <[Leary]> I think I still have XP on my laptop, though I haven't booted into it forever. Apart from security updates I'm not sure why Windows 10 should be preferred.
13:32:45 <oo_miguel> Sorabji: maybe you can try cygwin
13:33:18 <MacSlow> there are other OS than Windows... just saying
13:33:26 <oo_miguel> [Leary]: security updates are a sufficient reason
13:33:47 <oo_miguel> unless you never go online
13:34:11 <mizu_no_oto> Sorabji: Can you install virtualbox, and program in a linux vm?
13:34:31 <oo_miguel> you can use cygwin 2.5.2 at least
13:35:16 <Sorabji> oo_miguel: It's 64bit only haha, I reckon if hell exists, all of the machines will run xp. Last resort is a virtual machine though it's going to be some work to host a virtual midi channel between two machines...
13:35:23 <hdon> metahumor: no
13:35:30 <Sorabji> oo_miguel: What about sound and the likewise, is it supported?
13:35:31 <hdon> i've only read Haskell Liftoff
13:36:34 <mizu_no_oto> Sorabji: Alternatively, you might consider using GParted to resize the windows partition and dual boot linux
13:36:37 <Ariakenom> EvanR: So, eh, flashback. Whatcha want for clamp?
13:37:19 <oo_miguel> Sorabji: not sure, I only used it for terminal/text io.
13:38:10 <oo_miguel> Sorabji: a 32bit version is available as well
13:38:11 <hdon> metahumor: what is the >>= operator called?
13:38:24 <oo_miguel> >>= operator
13:38:26 <oo_miguel> :P
13:38:30 <mizu_no_oto> hdon: 'bind', usually
13:38:31 <oo_miguel> joking
13:38:35 <hdon> ah :)
13:38:42 <EvanR> it isn't usually pronounced
13:38:46 <EvanR> like <*>
13:39:19 <mizu_no_oto> :t (>>=)
13:39:20 <Sorabji> Thanks for the input everyone. Is it possible to install a linux partition straight from windows?
13:39:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:40:45 <mizu_no_oto> Sorabji: I'm not sure.  I've always booted into a livecd or liveusb; I think that's the standard way to do it, particularly since you probably want to shrink your ntfs partition instead of deleting it and that requires it being unmounted.
13:41:39 <Sorabji> Ah, okay thanks. Any operating system other than windows when booted, crashes during installation.
13:41:55 <mniip> define "crashes"
13:42:11 <Sorabji> Freezes.
13:42:51 <Sorabji> Systems that did work had issues with networking also.
13:43:20 <oo_miguel> probably they lacked drivers for your hardware
13:44:13 <fizbin> Has anyone ever seen the message "cabal: Could not resolve dependencies:" with nothing else after it?
13:44:14 <Sorabji> Of course, I think the issue could be the drives on this system too, it puts out shady voltages.
13:44:24 <metahumor> hdon: (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:45:01 <fizbin> (as in, the only two lines output from a cabal-install command are "Resolving dependencies..." and "cabal: Could not resolve dependencies:")
13:45:16 <oo_miguel> Sorabji: what kind of hardware are you using?
13:45:17 <mizu_no_oto> hdon: In this case, (>>=) :: IO a -> (a -> IO b) -> IO b
13:45:29 <fizbin> (I'm using an old version of cabal because of old Ubuntu dependencies)
13:45:35 <metahumor> hdon: (>>=) takes a mobit "m a", some way of converting a value "b" to a mobit "m b", and binds the original "m a" to become an "m b"
13:46:11 <metahumor> hdon: so we have "getArgs :: IO [String]" and "head :: [String] -> String" and "print :: Show a => a -> IO ()"
13:46:20 <mizu_no_oto> mobit?  I don't think I've heard that term before.
13:46:34 <chessai> :k (IO)
13:46:35 <lambdabot> * -> *
13:46:49 <armlesshobo> :t return
13:46:50 <lambdabot> Monad m => a -> m a
13:46:54 <chessai> i've not used lambdabot before, cool
13:46:55 <metahumor> hdon: so "\xs -> print (head xs) :: [String] -> IO ()"
13:47:17 <armlesshobo> Just 3 >>= return . (+1)
13:47:22 <hdon> what does the backslash mean?
13:47:27 <metahumor> hdon: great! we have our "getArgs :: IO [String]", which is our "m a"
13:47:48 <armlesshobo> > Just 3 >>= return . (+1)
13:47:51 <lambdabot>  Just 4
13:47:51 <metahumor> hdon: oh, that is lambda syntax, an anonymous function that takes "xs" and does, in this case, "print (head xs)" with it
13:48:11 <armlesshobo> :t >>
13:48:11 <hdon> ahhhh gotcha
13:48:13 <lambdabot> error: parse error on input ‘>>’
13:48:14 <armlesshobo> :t (>>)
13:48:16 <lambdabot> Monad m => m a -> m b -> m b
13:48:21 <metahumor> hdon: and we have our "\xs -> print (head xs) :: [String] -> IO ()" which is our "a -> m b"
13:48:22 <armlesshobo> Just 3 >> Just 4
13:48:27 <armlesshobo> > Just 3 >> Just 4
13:48:30 <lambdabot>  Just 4
13:48:39 <Sorabji> oo_miguel: This is going to warent further laughs, hold on.
13:48:57 <metahumor> hdon: put together, "(>>=) getArgs (\xs -> print (head xs)) :: IO ()", our final "m b"
13:49:16 <metahumor> hdon: we usually write (>>=) infix, that is, "getArgs >>= \xs -> print (head xs)"
13:50:01 <metahumor> hdon: you can think of this as "using the recipe of getArgs which would give us some xs, make a recipe that would print the head of xs"
13:50:29 <metahumor> there's a simpler recipe we could have made that prints all the arguments we got
13:51:08 <metahumor> ehh never mind about that last thought
13:51:22 <metahumor> hdon: there is also "getLine :: IO String"
13:51:34 <metahumor> hdon: and "putStrLn :: String -> IO ()"
13:51:41 * hdon nods
13:51:44 <metahumor> hdon: can you use those to print the line that i give you?
13:51:51 <metahumor> *that the user gives you?
13:52:32 <hdon> well my first intuition is just "putStrLen getLine", but putStrLn only accepts String not IO String.
13:53:08 <metahumor> right. but we ahve a "(>>=) :: Monad m => m a -> (a -> m b) -> m b"
13:54:37 <metahumor> hdon: if "getLine :: IO String" is like our "m a", and "putStrLn :: String -> IO ()", then...
13:54:53 <suzu> anybody know much about interrupting foreign calls?
13:55:07 <Fuuzetsu> Probably.
13:55:10 <Fuuzetsu> What's the question?
13:55:19 <suzu> i simply can't seem to make interrupts work
13:55:25 <glguy> In general you don't
13:55:48 <suzu> http://lpaste.net/
13:55:51 <suzu> err im dumb
13:55:55 <suzu> http://lpaste.net/3271392893335502848
13:55:57 <suzu> this test does not work
13:56:17 <suzu> (i've modified inline-c to make all foreign imports 'interruptible' instead of 'safe')
13:56:27 <Phyx-> Sorabji: GHC officially dropped Windows XP support 3 major releases ago
13:56:47 <hdon> metahumor: oh.. getLine >>= putStrLn
13:56:53 <Phyx-> and we did so because it doesn't support quite a few new APIs
13:57:01 <Fuuzetsu> suzu: please include full source with imports otherwise we have to guess precisely things like "did you forget to import from interruptible" &c.
13:57:02 <Phyx-> which would require lots of workaround and hacks in the runtime
13:57:28 <Phyx-> so if you want to use xp, you'll have to use a 7.10.x branch compiler
13:57:45 <suzu> ok. let me extract it into a module and doulbe check that the issue is in there. then ill lpaste
13:57:53 <suzu> before i do that: would i encounter any problems testing this from ghci?
13:58:00 <suzu> as that is what im doing. this is a library i'm writing
13:58:30 <Fuuzetsu> I think you should be OK. Worth checking compiled though
13:58:36 <metahumor> hdon: that's right
13:59:13 <metahumor> hdon: (>>=) gives you a way to work with stuff that is of type "IO a", given you know how to provide a transformation "a -> IO b"
13:59:52 <metahumor> hdon: and that will look often like "actionIO >>= \result -> workupIO result"
14:00:17 <metahumor> hdon: "getLine >>= \str -> putStrLn str"
14:00:37 <metahumor> hdon: of course "\str -> putStrLn str" is just "putStrLn"
14:00:58 * hdon nods
14:01:12 <hdon> ok thanks metahumor
14:01:25 <metahumor> but here's where the do syntax comes in... writing "act >>= \x -> actagain x >>= \y -> actthrice y >>= \z -> print z" is annoying
14:01:30 <hdon> wow i can't believe how dumb haskell is making me feel. i thought it would come more quickly for me.
14:02:04 <metahumor> hdon: so we can "do" instead: " do {x <- act; y <- actagain x; z <- actthrice z; print z} "
14:02:33 <chessai> hdon: we use haskell because we are dumb humans, who need help keeping track of stuff
14:02:36 <metahumor> hdon: we've just "flipped" all our ">>= \x ->" into "<-" looking like arrows. but the meaning and what gets interpreted is exactly the same
14:03:05 <metahumor> so in your original case, that is why " do {args <- getArgs; print (head args)} " works
14:03:34 <mizu_no_oto> hdon: That's a pretty common sentiment when people learn Haskell
14:03:59 <metahumor> it might look like we're setting a variable "args"... really, we're binding the result of the getArgs to the "args" name which we have to use inside this "do block"
14:04:25 <metahumor> that is, "args" can't be used outside the do block, nor does it have any meaning outside of it either
14:04:36 <EvanR> show me the programming language for which learning it makes you feel smart
14:04:40 <suzu> Fuuzetsu: http://lpaste.net/310002415778660352
14:05:06 <Ariakenom> EvanR: So, eh, flashback. Whatcha want for clamp that isn't `clamp lo hi = max lo . min hi . assert (lo <= hi)`?
14:05:07 <suzu> full module and with splices
14:05:17 * Fuuzetsu goes to run
14:05:34 <suzu> i modified inline-c to make "interruptible" instead of "safe"
14:05:54 <suzu> shown in the splice
14:07:10 <glguy> suzu: your code isn't blocked in a system call, so InterruptibleFFI isn't going to help as it works by default
14:07:27 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#interruptible-foreign-calls
14:08:08 <suzu> it needs to be a system call?
14:08:10 <Fuuzetsu> suzu: you never throw the exception to main thread
14:08:14 <Fuuzetsu> easily verified with a print
14:08:42 <suzu> i don't?
14:08:55 <Fuuzetsu> add a print before throwTo
14:10:01 <suzu> i added a print. i can see it print
14:10:32 <Fuuzetsu> can you? I can't. the ‘hi’ doesn't print either
14:10:33 <suzu>   async $ threadDelay 3000000 >> print "hi" >> throwString "hi" `catchAny` \(e :: SomeException) -> print "throwing" >> throwTo me e
14:10:33 <glguy> Fuuzetsu: the code does through the exception, it's behaving as expected for an FFI call that doesn't do anything interesting
14:10:41 <suzu> this prints both strings
14:10:43 <glguy> Fuuzetsu: make sure you're compiling with threaded
14:10:47 <Fuuzetsu> oops
14:11:08 <Fuuzetsu> too used to having that in cabal or whatever file
14:11:32 <EvanR> -threaded is still not default?
14:11:58 <suzu> glguy: im confused as to what's going on here then
14:12:09 <suzu> only syscalls can be interrupted and so.. nothing happens?
14:12:15 <glguy> suzu: He's something that works: http://lpaste.net/2587464981180055552
14:12:55 <Fuuzetsu> you're not importing .Interruptible from inline-c either so it's marked as safe call even if it was to work
14:13:39 <suzu> whoops i didnt see that theres a .Interruptible. gues i didnt have to patch inline-c
14:13:47 <suzu> <_<
14:15:22 <glguy> InterruptFFI doesn't forcibly halt execution of the foreign call, it attempts to invoke the foreign call's own interruptible behavior by raising a signal in that thread
14:15:23 <suzu> glguy: why does that work and this doesn't?
14:15:55 <glguy> So it works because my C code reacts to that signal being raised because that's how sleep(3) works, while your loop doesn't
14:16:21 <suzu> oh i understand lol
14:17:23 <raghukul_> Hey
14:17:27 <suzu> so, ghc still can't just kill an ffi call. we need that ffi call to stop itself
14:18:20 <glguy> If you need something isolated enough that it's safe to kill it outright you could use a separate process
14:19:56 <suzu> hmm
14:21:41 <suzu> so the funny thing here is im trying to write a fatal error handler for a C library i want to use
14:21:52 <suzu> it needs a function to invoke if a fatal exception occurs
14:22:16 <suzu> i am trying to write that function in haskell. i want that fatal function to nuke the C call if that C call raises a fatal error
14:22:39 <suzu> which would unblock the haskell function running that C call
14:23:35 <suzu> it seems that this is impossible because only C can truly terminate an FFI call
14:23:39 <suzu> is that correct?
14:24:52 <psfk> Hi! Is there any standard libary allowing me to join nested Either's and concatenate the lefts ?
14:27:38 <Welkin> :t join
14:27:40 <lambdabot> Monad m => m (m a) -> m a
14:27:48 <Welkin> > Left (Left 4)
14:27:50 <lambdabot>  Left (Left 4)
14:27:57 <amalloy> concatenate the lefts?
14:27:59 <Welkin> > join (Left (Left 4))
14:28:01 <lambdabot>  Left (Left 4)
14:28:04 <suzu> glguy: ?
14:28:06 <Welkin> hm
14:28:14 <Welkin> > join (Right (Right 4))
14:28:17 <lambdabot>  Right 4
14:28:20 <rblaze> I think monad is (Either a), not Either. Join would work with Rights
14:28:24 <Welkin> it's only defined to work on Right
14:28:29 <Welkin> ah yes
14:29:42 <psfk> Oh I ment mappend two eithers with left concatenated
14:29:42 <psfk> im sorry
14:29:57 <amalloy> i think we'd also need to know what "nested Eithers" means. psfk: what is the type signature of the function you wish you had?
14:30:01 <rblaze> psfk: what do you expect to do it, if one is Right?
14:30:09 <Welkin> > Left "a" <> Left "b"
14:30:11 <lambdabot>  error:
14:30:12 <lambdabot>      • No instance for (Monoid (Either [Char] ()))
14:30:12 <lambdabot>          arising from a use of ‘e_1’
14:30:24 <Welkin> > Right "a" <> Right "b"
14:30:27 <lambdabot>  error:
14:30:27 <lambdabot>      • No instance for (Monoid (Either () [Char]))
14:30:27 <lambdabot>          arising from a use of ‘e_1’
14:30:38 <rblaze> or both are Right, for that matter
14:31:00 <Tuplanolla> > liftA2 mappend (Right "a") (Right "b")
14:31:03 <lambdabot>  Right "ab"
14:31:09 <Tuplanolla> > liftA2 mappend (Left "a") (Left "b")
14:31:12 <lambdabot>  Left "a"
14:31:25 <Tuplanolla> Is this what you want?
14:31:50 <rblaze> not concatenated
14:32:27 <amalloy> i feel like guessing at function implementations should come after figuring out the requirements
14:34:28 <parsnip> i'm guessing we'd think outside the Either box
14:34:45 <parsnip> what is something monoidal in both positions?
14:35:06 <rblaze> I remember seeing data type (with Applicative instance), which was used to collect multiple errors, or success. But can't remember the name.
14:35:28 <Welkin> rblaze: WriterT with a list
14:35:44 <rblaze> Welkin: that's monad :)
14:36:24 <rblaze> https://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html
14:36:40 <Tuplanolla> That also sounds like `These`, rblaze.
14:36:54 <Welkin> what is These?
14:37:02 <rblaze> No, not that.
14:37:06 <Welkin> a type of creature from Dr. Seuess?
14:37:47 <Tuplanolla> @let data These a b = This a | That b | These a b
14:37:49 <lambdabot>  Defined.
14:38:00 <Welkin> https://hackage.haskell.org/package/these
14:38:01 <Welkin> ?
14:38:09 <Welkin> okay
14:38:21 <psfk> amalloy, rblaze : I just want to have Left being Monoid and I think ive found what I was looking for: https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html
14:38:24 <Welkin> it must have some influence from Dr Seuss
14:40:55 <shapr> hoogle doesn't work nearly as well for C++ code
14:41:20 <Welkin> shapr: what?
14:42:13 <shapr> https://stackoverflow.com/questions/26737814/signature-based-search-for-c
14:42:38 <shapr> In short, hoogle is awesome, but does not seem to exist for C++
14:43:39 <Axman6> at least cdecl exists to explain to you what a crazy C(++?) type actually means. The spiral of understanding (because C types are best read in a spiral starting in the centre)!
14:50:15 <hdon> if i have a list [1,2,3] how can i apply these as arguments to (\a b c -> a+b+c) ?
14:51:20 <amalloy> hdon: you will have to pattern-match on the list, and have a plan for what to do if there are not exactly three elements
14:51:38 <hdon> amalloy: ahh, thanks. and are there list accessors other than head and tail?
14:51:43 <hdon> sorry i'm complete newb
14:51:58 <[Leary]> > foldr (+) 0 [1..10] -- Maybe a fold is what you want instead, hdon?
14:52:00 <lambdabot>  55
14:52:35 <hdon> [Leary]: do i understand correctly that foldr is like reduce in other languages?
14:52:46 <amalloy> > let {f a b c = a + b + c; xs = [1,2,3]} in case xs of {[x, y, z] -> f x y z; _ -> error "not three things"}
14:52:49 <lambdabot>  6
14:52:53 <[Leary]> Yeah, I gather.
14:52:57 <shapr> Axman6: didn't know about cdecl, thanks
14:53:38 <hdon> [Leary]: well that's definitely useful to know, thanks :) but my a+b+c example was too specific
14:54:10 <amalloy> hdon: head and tail are functions you should shy away from using, in favor of pattern matching (as i demonstrated) or folds (as [Leary] suggests)
14:54:17 <amalloy> > head []
14:54:20 <lambdabot>  *Exception: Prelude.head: empty list
14:54:38 <amalloy> because they explode on empty lists, and don't give you a good way to express what you'd prefer to do rather than explode
14:54:42 <hdon> thanks amalloy
14:54:57 <hdon> in my case, i want to take arguments from the command-line
14:56:18 <amalloy> so, assuming you are in `do` for IO already, you want: args <- getArgs; case args of ...
14:56:28 <hdon> getArgs() gives me a list, so i wanted to know if there was an expressive and succinct means of feeding them as individual arguments rather than the list as a single argument
14:56:58 <parsnip> cmdargs and optparse-applicative seem popular.
14:57:16 <hdon> in python we have the * qualifier in a call expression. in es6 or so we have "..." qualifier.
14:57:53 <amalloy> hdon: there's no such thing in haskell as python's * operator or lisp's apply. it doesn't really work well with homogenous lists and fixed-arity functions
14:58:00 <sm> hdon: eg, let (a:b:c:_) = l in f a b c
14:58:05 <hdon> e.g. >>> (lambda a,b,c:a+b+c)(*[1,2,3])
14:58:05 <hdon>  # yields 6 in python
14:58:40 <dibblego> amalloy: one of two things are true, you know there are three elements, in which case you should not be using list (list means there are 0 or many elements), or you need to have an answer to what if there are not exactly three elements?
14:58:41 <hdon> sm: is this destructuring assignment? i dont' understand :(
14:59:03 <amalloy> hdon: pattern matching, which is more powerful/general than destructuring
14:59:16 <amalloy> dibblego: i know that, which is why i already said it. you want to be teaching hdon
14:59:18 <sm> hdon: l is the list, the let pattern assigns the first three items to a b c, which you then pass to your three-parameter function f
14:59:30 <hdon> :)
14:59:46 <dibblego> amalloy: ah sorry
15:00:00 <hdon> sm: hmm.. ok. thank you
15:00:06 <sm> and the _ is a wildcard to ignore any additional items
15:00:40 <sm> if the function really should take a varying number of parameters, it should be changed to take a list
15:03:42 <sm> hdon: how did you find those tutorials yesterday ?
15:04:17 <donatell0> Hi. I have a question about lenses - how can I make a value of type StringOrURI from https://www.stackage.org/haddock/lts-10.6/jose-0.6.0.3/Crypto-JWT.html#t:StringOrURI ?
15:05:32 <hdon> sm: i checked out Haskell Liftoff but i'm afraid not the others. I don't feel like Liftoff helped me very much, but it did introduce some important concepts. the use of terms like "expression" and "statement" and "function" didn't seem to line up with my experiences in other languages.
15:05:40 * hdon scrolls up and looks for other tutorials
15:06:12 <hdon> they are lost to the ages
15:07:15 <sm> I think the links we gave were when you asked about monads specifically. But you might find https://leanpub.com/haskell-cookbook/read useful from the beginning
15:07:41 <sm> if not, I'd be glad to know
15:08:21 <Welkin> what is Haskell Liftoff?
15:09:18 <pikajude> hmm, new cabal uses an immense amount of memory on macos
15:09:23 <pikajude> when running the solver, presumably
15:09:33 <pikajude> has anyone run into this issue other than me
15:11:41 <Welkin> id this it? https://mmhaskell.com/liftoff/
15:11:46 <sm> Welkin: yes
15:11:46 <Welkin> I've never heard of it before
15:11:51 <hololeap> i'm writing conway's GOL just as an exercise and i am looking for the simplest way to get a GUI up and running on linux. it doesn't have to be complicated at all. i don't even care if it has any start/stop interaction
15:11:52 <Welkin> and there is no information about who runs that site
15:11:53 <Welkin> o.o
15:12:17 <Welkin> hololeap: are you okay with a terminal/text interface?
15:12:29 <hololeap> Welkin: you mean like ncurses?
15:12:32 <Welkin> if so, try vty, if not try gloss
15:12:41 <Welkin> vty is pretty damn easy
15:12:47 <sm> isn't gloss easier even than vty/brick ?
15:12:54 <Welkin> that depends
15:13:10 <Welkin> I think vty is easier than any gui library I have used, conceptually
15:13:31 <Eduard_Munteanu> SDL?
15:13:32 <Welkin> you just compose layers of "images" on top of each other
15:13:36 <Welkin> lol Eduard_Munteanu
15:13:37 <Welkin> no
15:13:53 <hololeap> Welkin: does vty allow for a "fixed" view, like ncurses does? right now it's just printing out each generation to the terminal
15:14:04 <Welkin> hololeap: yes, of course
15:14:10 <hololeap> ok, just making sure
15:14:23 <hololeap> i'll check them both out
15:14:33 <Eduard_Munteanu> I remember it being fairly straightforward to just get an window and draw into it with SDL.
15:14:59 <hololeap> Eduard_Munteanu: i will check that out as well
15:15:02 <sm> Eduard_Munteanu: yes, except you'll have to have the C sdl libs installed just right..
15:15:14 <Welkin> SDL is by no means lightweight or easy
15:15:25 <Welkin> it is very powerful, but not easy to set up unless you have done it before
15:15:42 <hololeap> yeah. when i simple, i really mean intuitive
15:16:02 * sm puts money on gloss
15:16:12 <Welkin> plus you have to use either the crappy SDL rendering api or use opengl directly
15:16:16 <Welkin> neither of which is a good idea
15:16:54 <Welkin> I still think vty is the simplest
15:17:07 <sm> come on then, show me yr money Welkin !
15:17:14 <Welkin> you get to control your own rendering loop
15:17:26 <hololeap> Welkin: is it vty or vty-ui that i want?
15:17:44 <Welkin> vty
15:19:40 <Welkin> http://lpaste.net/4394038129795792896
15:20:03 <Welkin> here is a sample of using vty with layers to render a dungeon with some players in it (for a game I am writing)
15:20:37 <sm> ha. I give you https://github.com/benl23x5/gloss/blob/master/gloss-examples/picture/Hello/Main.hs
15:21:26 <Welkin> most of that code is just my own functions for converting my data to something renderable
15:21:27 <chessai> it would be cool to have lambdabot able to send/receive SMS
15:21:37 <Welkin> it is really just that `render` function I wrote that does everything
15:22:25 <Welkin> you compose Images into a Picture (:: [Image])
15:22:37 <Welkin> left-most ones overly the rightmost ones
15:22:40 <Welkin> overlay*
15:23:51 <Welkin> sm: that is simpler than I thought it would be for gloss
15:24:04 <sm> course if we count console text as "GUI", the simplest is really putStr <ansi clear screen code>, map putStrLn rows
15:24:22 <Welkin> but how does it handle input? I thought it used a callback, not letting you define your own update-render loop
15:24:46 <sm> Welkin: I believe there are several different main loops provided
15:25:01 <Welkin> I like to define my own
15:26:46 <hololeap> can you make a multi-dimensional Data.Vector.Unboxed?
15:27:00 <sm> wow, check out this one: https://github.com/benl23x5/gloss/blob/master/gloss-examples/picture/Easy/Main.hs
15:27:06 <sm> two lines
15:27:54 <hololeap> No instance for (V.Unbox (Vector Bool))
15:28:21 <hololeap> emptyBoard cols rows = V.replicate rows $ V.replicate cols False
15:30:08 <sm> import Graphics.Gloss
15:30:34 <sm> oops. Thank you erc
15:44:04 <cheater> is there a way to use latex syntax with haskell?
15:44:25 <cheater> something like $latex-here$ = bar baz 2
15:44:40 <Welkin> what does that even mean?
15:44:46 <cheater> exactly what i said?
15:44:53 <sm> cheater: say more things
15:45:07 <Tuplanolla> I can answer what you said, but not what you meant, cheater.
15:45:08 <cheater> like f = bar baz 2 but you'd have some latex instead of f
15:45:23 <Welkin> no idea what you are talking about
15:45:28 <cheater> and anywhere else you use the same latex string it's the same identifier
15:45:28 <Welkin> latex is latex
15:45:36 <sm> latex snippets inside haskell source code, right ?
15:45:37 <Welkin> uh...
15:45:42 <cheater> sm: yeah
15:45:45 <Welkin> you just define f = whatever
15:45:56 <cheater> i just want some nice latex instead of f
15:46:00 <sm> how would you translate a latex snippet to valid haskell code ?
15:46:00 <Welkin> o.o
15:46:01 <Welkin> wtf
15:46:06 <cheater> i wouldn't sm
15:46:08 <cheater> i don't need to
15:46:09 <Welkin> latex is terrible
15:46:13 <Tuplanolla> You could define a TH quasiquoter and say `[tex| \alpha + \beta ]`.
15:46:24 <sm> what would you expect to happen when you run the program then ?
15:46:38 <Welkin> I am using my own markup language I wrote with racket that is similar to latex, but doesn't suck
15:46:38 <cheater> sm: the same thing as when i use f instead of $latex-here$
15:46:45 <cheater> sm: this is just purely for typography
15:46:51 <sm> do you mean latex inside haddock docs ?
15:46:52 <Welkin> if you mean that you want to do literate programming
15:47:06 <cheater> so instead of f = bar baz 2 i could have eg $\mathbb{F}_inf$ = bar baz 2
15:47:11 <Tuplanolla> That's how `inline-c` works, for example.
15:47:13 <cheater> and then i could render to pdf and i'd have nice output
15:47:24 <cheater> for the source
15:47:26 <Welkin> wtf does that even mean?
15:47:36 <koala_man> cheater: purely as an identifier?
15:47:36 <sm> or do you mean, mixing latex markup and haskell code examples in documentation ?
15:47:36 <Eduard_Munteanu> cheater, you can use unicode
15:47:41 <cheater> koala_man: yeah
15:47:48 <cheater> Eduard_Munteanu: i know, but that's not the same :(
15:48:02 <Tuplanolla> The other option is to define typographic rewrite rules and run them through `lhs2TeX`.
15:48:22 <cheater> Tuplanolla: hmm, yeah..
15:48:34 <Welkin> enough of this, movie time
15:48:52 <sm> bah Welkin what about our bet
15:48:52 <Tuplanolla> That's how I produced this, for instance: http://tuplanolla.no-ip.org/tmp/vmc.pdf
15:48:55 <epta> in Graphics.Vty.Input.Events, why there is 'KBackTab', but no just Tab?
15:49:31 <Tuplanolla> (It's a Haskell source file.)
15:49:37 <cheater> epta: try ctrl-i
15:50:06 <sm> epta: don't know, but maybe it's KChar '\t'
15:50:26 <epta> sm: oh, good point
15:50:52 <glguy> epta: You can use the vty-demo executable to see what values particular keyboard events correspond to
17:14:18 <albatross_> http://lpaste.net/362962 hey guys, i'm not sure what's wrong with this do block
17:15:52 <lyxia> albatross_: is this at the toplevel
17:16:07 <albatross_> yes lyxia
17:16:15 <albatross_> lyxia it is at the top level
17:16:56 <lyxia> albatross_: can you paste the whole file
17:17:03 <dfeuer> albatross_: are you saying that line 18 is the *first* one you show?
17:17:13 <lyxia> I don't get a parse error other than a missing quote at the end
17:17:21 <albatross_> yes dfeuer, that is what i'm saying
17:17:37 <dfeuer> I'm betting your main problem is somewhere before that, although lyxia has a point too.
17:18:22 <albatross_> lyxia I just fixed the quote, and it is still giving me the same error
17:18:45 <cppxor2arr> those nested if statements though
17:19:09 <cppxor2arr> * ifs
17:19:09 <[Leary]> Yeah, could really do with MultiWayIf.
17:19:40 <albatross_> guys, i'm working on a problem from wiki book
17:19:49 <albatross_> that is what they asked for, don't judge...
17:19:51 <lyxia> albatross_: I copy paste that in a new file and it compiles except for the missing main.
17:19:58 <albatross_> interesting
17:20:15 <albatross_> lyxia, i have another do block within this module
17:20:20 <albatross_> let me delet that and see
17:34:08 <s2mitrov> "Yes, generics are a (simple) kind of parametric polymorphism." <- can someone explain this? i always thought they both referred to the same thing, generics just kinda being an informal name for it due to lots of people being exposed to it in java originally
17:46:45 <ski> s2mitrov : .. no idea what the context of that is, what that is from
17:46:46 <nibbling> Novice Haskeller here: I'm trying to write a function that maps over a [[Char]] and prints each item to stdout. I thought this would be as easy as `printLns = mapM putStrLn`, giving me a curried function back, but I'm getting an error about not being able to resolve the type of t0
17:47:08 <ski> perhaps you wanted `mapM_' ?
17:47:21 <ski> `mapM' is for when you want to collect a list of results
17:50:07 <sm> nibbling: writing a type signature for printLns will help
17:53:19 <nibbling> ah, I see. printLns :: [[Char]] -> IO () works
17:54:06 <nibbling> is String just a type alias for [Char]?
17:55:10 <mud> nibbling: Yep
17:56:05 <nibbling> nifty.
17:56:12 <nibbling> thanks for the help ski, sm, mud
17:59:25 <lyxia> s2mitrov: "generics" can mean many things
18:07:16 <c_wraith> was there some addition to QuasiQuoters in the last several years that had the effect of deprecating leaving most of the fields undefined?
18:07:34 <c_wraith> I seem to recall some discussion of that, but I can't find anything in the docs.
19:01:21 <jchia> If I have a type-level [Mapping Symbol *] (Mapping in the sense of Data.Type.Map from type-level-sets), e.g. '["a" :-> Int , "b" :-> Bool, "c" :-> Char], how do I get a corresponding tuple type (Int, Bool, Char)? Are there libraries to help with this sort of compile-time computation?
19:02:43 <jchia> Is the singletons library something that can deal with this sort of thing? I tried to understand it but due to lack of examples, even after reading the paper, I couldn't figure out a lot of it.
19:09:52 <s2mitrov> ski, lyxia: the context was this tweet https://twitter.com/jdegoes/status/968615432235057152
19:11:11 <pikajude> if a new version of a package requires a newer Cabal version, is that a major version bump or a minor version bump?
19:11:28 <pikajude> unclear on the PVP here
19:15:41 <ski> s2mitrov : hm, i'm not quite sure what he means more specifically by those four parts "monomorphic code, generalize, parameterize, refactor" here .. nor "generics are a (simple) kind of parametric polymorphism"
19:16:01 <ski> "do devs really question its utility?" -- i think Go doesn't have generics ?
19:16:54 <ski> "simple" *might* refer to only quantifying over concrete kinds .. maybe
19:17:22 <s2mitrov> yea, i'm really not sure; i was always under the impression generics was just another, more informal name for the same idea
19:18:19 <ryantrinkle> ski, s2mitrov: i'm not sure it'd count as parametric in situations where you're allowed to ask questions about the values
19:18:39 <ryantrinkle> e.g.: in C++ you can do compile-time tests on template parameters that have been passed to you
19:18:50 <s2mitrov> ah, so like reification?
19:18:55 <ryantrinkle> right
19:18:56 <ski> in Java, there is no replication of code corresponding to instantiation. however in C++, template instantiation does amount to replicating code, which is then specialized
19:18:59 <ryantrinkle> that'd be non-parametric, i believe
19:19:05 <s2mitrov> that makes sense
19:19:15 <ski> however, iirc, the term "generics" is also used in Ada, while it uses replication
19:19:29 <ryantrinkle> yeah, and in Java you always have an implicit 'Typeable' everywhere
19:19:38 <ryantrinkle> which puts a bit of a damper on the parametricity
19:19:50 <ski> ryantrinkle : that's two separate issues, i think
19:20:01 <ryantrinkle> one of the really useful things you can do with parametricity is to reason about what a function can or can't do
19:20:35 <ryantrinkle> e.g.: if you have (forall a. a -> (String, a)) you know the String can't really depend on the a
19:20:37 <ski> yea, generics in Java doesn't enjoy parametricity
19:20:50 <ryantrinkle> but in java, the String could be the name of a's class
19:21:03 <ryantrinkle> you could do the same thing in haskell with forall a. Typeable a => a -> (String, a)
19:21:37 <ski> yea, a constraint `C a' is an explicit license to depend on the `C' methods for `a'
19:22:01 <ryantrinkle> a lot of times, people will talk about how languages have "functional features"
19:22:14 <ryantrinkle> e.g., that Scala is sometimes considered Java + functional programming
19:22:44 <ski> as you say, you can match on the types in C++, at compile-time .. and then using that info, you can access the corresponding values at run-time
19:22:46 <ryantrinkle> but i often finds the things that functional programming *removes* far more beneficial than the things it adds
19:23:12 <ryantrinkle> e.g.: removing mutation, or removing this implicit Typeable everywhere
19:23:14 <ski> while in Java, you can access the value right away, using `instanceof' say (or "reflection"). i don't think you can do that in C++ ?
19:23:34 <s2mitrov> to be fair, Scala is about as functional as an ML, in that it's as functional as you want it to be
19:23:51 <ryantrinkle> s2mitrov: yup, and i'm sure i'd prefer it over Java
19:24:00 <s2mitrov> generally "functional features" for most people tends to be "hey my language has map, fold, and filter" which is.. disappointing to say the lasty
19:24:09 <ryantrinkle> right
19:24:12 <s2mitrov> least*
19:24:25 <ryantrinkle> and consider just how much more powerful map is when you can assume purity
19:24:42 <ski> ryantrinkle : that is because reducing expressivity often increases "reasonability", the ability to reason about properties of code, and code equivalences (refactoring)
19:24:52 <ryantrinkle> exactly :)
19:24:55 <s2mitrov> yep
19:25:03 <ski> i think that people focus too much on expressivity and too little on reasonability
19:25:13 <ski> it's generally a trade-off
19:25:50 <ryantrinkle> true, although i'd also question to some extent the concept that, e.g., having implicit IO everywhere increases "expressivity", for example
19:26:08 <ryantrinkle> it's useful to be able to express "this thing does no IO"
19:26:14 <ryantrinkle> which has no expression in most languages
19:26:14 <ski> *sometimes*, though, one can manage to find just the right abstraction that keeps useful reasonability, while also being reasonably expressive
19:26:26 <s2mitrov> people will meme on me when i mention haskell, like they'll laugh at single letter identifiers and stuff but they really don't understand just how much you can get away with "oh, this type signature is what i'm looking for" and sorta lego-ing together things based on types alone when you have a solid type system and enforced purity
19:26:31 <ryantrinkle> yep, that's the trick :)
19:26:44 <ski> "this thing does no IO" is reasonability, not expressivity, i'd say
19:27:09 <ski> <https://en.wikipedia.org/wiki/Rule_of_least_power>
19:27:19 <ryantrinkle> ski: there may be some (inverse?) relationship between expressivity at the type level and at the value level
19:27:48 <ski> i'm not really following what you mean there
19:28:15 <ryantrinkle> well, a value that can't do IO is clearly less expressive than one that can, all else being equal
19:28:31 <ski> "consider just how much more powerful map is when you can assume purity" -- yea, purity, as well as parametricity, is really useful for polymorphic HOFs
19:28:59 <ryantrinkle> but a type system that can only describe values which are allowed to do IO is clearly less expressive than a type system that can describe both values that can and values that cannot do IO
19:29:12 <metahumor> re reasonability, why does hayoo fail to find anything for "FilePath -> IO ByteString"?
19:29:31 <ski> ryantrinkle : hm, ok
19:29:41 <s2mitrov> hayoo in my experience has been strictly worse than hoogle
19:29:42 <ryantrinkle> metahumor: not sure, but you probably want this? https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Lazy.html#v:readFile
19:30:11 <metahumor> and why does haskell.org/hoogle, when i query with the same typesig, ask, 'Did you mean: ...' with the same exact input?
19:30:24 <mroutis> ski: can you explain a little bit more the difference between expressivity and reasonability? I mainly code ruby stuff, so its expressiveness is like writting english and reasonability is as far as the method/function names are readable, you can reason about what's inside
19:30:25 <ski> @quote be.preserved
19:30:25 <lambdabot> ErrettBishop says: Meaningful distinctions deserve to be preserved
19:30:31 <s2mitrov> metahumor: I don't get that
19:30:36 <metahumor> ryantrinkle: thanks, i had found it already, was just comparing hoogle and hayoo
19:30:49 <ryantrinkle> metahumor: ah yeah
19:31:10 <metahumor> oh... i had FIlePath
19:31:18 <metahumor> and hayoo is case sensitive it seems
19:31:22 <metahumor> :duck:
19:32:41 <ski> mroutis : expressivity is about how much you can achieve in code, in a local way (iow, without having to rewrite every higher-order library call that you call out to). if you have mutable state, you don't have to thread your state values through library HOFs in order to access that state in your callbacks. so state side-effects is more expressive
19:33:11 <ski> mroutis : reasonability is about the ease at which you can reason about, predict behaviour of, and refactor code
19:33:16 <jmcarthur> It's "expressive" as in your face.
19:33:19 <metahumor> how idiomatic is it to make "instance Exception MyError" when I have a "data MyError = MyError" so I can do "try :: a -> IO MyError a"?
19:33:56 <ski> mroutis : having pervasive state side-effects is a net decrease there (which pieces of mutable state does this lib call depend on, or silently change ?)
19:34:45 <mroutis> ski: okok
19:35:05 <ski> also, "does it matter in which order i call these two lib calls ?"
19:35:32 <jmcarthur> metahumor: Defining your own exception type is not crazy, but the try function is not very common in my code (I think I've never used it).
19:36:24 <ski> i think monochrom has called "expressivity", "cavalier power"
19:36:37 <ski> i forget what "reasonability" would be then
19:36:45 <jmcarthur> metahumor: I tend to use bracket and finally the most, and to actually handle the exception is usually catch or handle, although I try to avoid having to handle exceptions at all if I can help it.
19:36:49 <Welkin> is this Jean-Paul Sartre night?
19:38:27 <Welkin> invent your own extremely oconfusing vocabulary and go on and on about it in long, never-ending run-on sentences that last for pages, and don't end where you think they will, but continue for far too long, forcing you to attempt to keep track of what has been said so far in your mind so you don't lose the thread of the discussion
19:39:00 <metahumor> he's actually not that bad
19:39:12 <metahumor> but at his peak, he was writing 27 pgs a day
19:39:31 <Welkin> I do enjoy Sartre
19:39:44 <Welkin> it's like learning a new language to understand him though
19:40:39 <monochrom> ski: Predictive power and cavalier power.
19:40:42 <ski> ty
19:40:56 <Welkin> cavalry power?
19:40:57 <mroutis> ski: ruby achieves expressivity by cluttering objects with a lot of methods (really... `Object.methods.count` outputs 111), how this "expressivity" is achieved in haskell?
19:41:02 <Welkin> what have horses got to do with it
19:41:33 <Welkin> mroutis: I would not call that expressivity. I would call it madness, just like all of the other imperative languages are filled with madness
19:42:14 <Welkin> the word I would use to describe haskell is: discipline
19:42:26 <monochrom> If you assume that I have a typo or spelling mistake, you will never understand.
19:42:34 <Welkin> like in the way you use the word to describe zen, or perfecting an art
19:42:54 * Welkin winks at monochrom 
19:47:16 <slacker2014> Noob question:  I get a warning of non exhaustive patterns with this snippet.  I don't know what I'm missing.
19:48:14 <slacker2014> find :: Integer -> [Integer]-> Stringfind _ [] = "Not Found"find  x (f : fs )
19:48:24 <metahumor> @where lpaste
19:48:24 <lambdabot> http://lpaste.net/
19:48:32 <metahumor> slacker2014: best if you paste it there and share the link
19:48:47 <slacker2014> metahumor: Okay
19:50:00 <slacker2014> http://lpaste.net/362965
19:50:19 <ski> replace `x < f' by `otherwise'
19:50:37 <ski> or better, use `case compare x f of GT -> ...; EQ -> ...; LT -> ...'
19:50:54 <metahumor> ^^
19:51:15 <metahumor> that does only one comparion
19:51:17 <ski> GHC isn't smart enough to realize that your guards are exhaustive
19:51:19 <metahumor> comparison
19:52:04 <slacker2014> ski: got it!  I thought pattern matching only applied to the patterns.
19:52:26 <ski> well, it does
19:52:49 <ski> but guards, if present, are also involved in selecting the appropriate defining equation, and the guard branch, if any
19:53:36 <slacker2014> ski: why is case better though?  ghc understands it better?
19:53:41 <ski> (of course, instead of `;', you'd normally use layout/indentation)
19:53:53 <ski> `case' is pattern-matching
19:54:17 <ski> GHC knows that `GT',`EQ',`LT' exhausts the possible results that you can get back from `compare'
19:55:00 <slacker2014> ski: Got it. Thanks!
19:55:18 <ski> np
19:55:25 * ski nods to monochrom
19:55:34 <ski> er, to metahumor, rather :)
19:57:07 <slacker2014> I've been studying haskell for around a week and I understand the basics.  What would be the best way to get practical experience?  I thought I'll build some of the things I build today with C++ in haskell.  But most packages seem to use a lot of custom syntax.
19:57:29 <metahumor> if i have several "Either Error MonoidalValue", what's the best way to get the total "Either Error MonoidalValue"?
19:58:52 <jackdk> do you mean a list, or like a :: Either Error MonoidVal, b :: Either Error MonoidVal, c :: Either Error MonoidVal?
19:59:48 <metahumor> the latter
20:00:57 <ski> metahumor : `mconcat <$> sequence myEitherList' could work ..
20:01:00 <ab9rf> what do you mean by "custom syntax"?
20:01:20 <ski> (if you're fine with getting the first `Error'. if you also want to merge them, then maybe you `Validation' ?)
20:02:01 * ski suspects slacker2014 might mean custom infix operators
20:02:22 <ab9rf> ski: i must confess that i don't think of infix operators as "custom syntax"
20:02:24 <jackdk> yeah, what ski says: pack 'em into a list, then sequenceA them and mconcat the result
20:02:34 <ski> ab9rf : aye
20:02:42 <Welkin> slacker2014: build a video game, or a web server+client application
20:02:45 <ab9rf> they're just functions with a vaguely curious name
20:03:15 <ab9rf> now, TH, that confuses me :)
20:03:37 <Welkin> TH is quite confusing
20:04:04 <Welkin> I have been learning and using racket for the last few days and have found that metaprogramming is more understandable in it
20:04:14 <Welkin> quasiquote, quote, unquote, unquote-splicing
20:04:24 <Welkin> it all makes a lot more sense if you learn it in lisp I think
20:04:34 <s2mitrov> a cute exercise could be writing your own mini/simplfiied implementation of Parsec
20:04:37 <jackdk> I wish more languages were built around sexps. so nice to work with
20:04:48 <Welkin> the parentheses are dirving me mad though
20:04:55 <Welkin> I have to constantly check to make sure I didn't miss one
20:04:58 <s2mitrov> what editor do you use?
20:05:01 <Welkin> emacs
20:05:03 <ab9rf> i've spent enough time balancing insipid parentheses
20:05:22 <ab9rf> Welkin: yeah, that'll do it :)
20:05:24 <s2mitrov> there's a mode for that iirc, where you basically *cant* delete parens accidentally, and they're always inserted im pairs
20:05:28 <ab9rf> i used to write entire apps in emacs lisp
20:05:51 <s2mitrov> i don't thin it's paredit
20:05:55 <monochrom> My trick is to feel free to erase a whole bunch of closing parentheses and write them anew.
20:06:19 <ab9rf> i rather dislike editors that force me to keep parens matched
20:06:21 <s2mitrov> smartparens? might be what im thinking of
20:06:32 <ski> Welkin : also don't forget to learn about hygienic macros
20:06:42 <ab9rf> that was especially frustrating when i was using perl, which has variables named $( and $)
20:06:45 <slacker2014> Welkin: I was considering building a web server as well.  Hapstack would be the right choice to base it on?
20:07:08 <s2mitrov> ab9rf: paredit isn't universal, though
20:07:09 <Welkin> ski: haven't gotten there yet. I only know very little. Only enough to use some library I am using
20:07:19 <s2mitrov> you'd just write a mode hook like anything else
20:07:23 <Welkin> slacker2014: no, go with warp most likely
20:07:34 <ab9rf> i still don't like it
20:07:43 <ab9rf> and i've written a gobton of lisp code
20:07:49 <ab9rf> over the past 30 years
20:07:56 <Welkin> slacker2014: depending on what you want, could be warp (server), or scotty (lightweight library that uses warp), or even servant (web apis)
20:08:01 <s2mitrov> odd, but personal preferences are personal preferences i guess
20:08:07 <ski> Welkin : .. and later, you could check out MetaML/MetaOCaml
20:08:31 <metahumor> slacker2014: you might like the qfpl/applied-fp-course, which guides you through writing a web app using Wai
20:08:32 <slacker2014> Welkin: alright.  My usecase would be a http server supporting REST endpoints.
20:08:33 <Welkin> I am surprised at how much I can do with racket knowing so little however
20:08:45 <Welkin> and am using quasiquotes like crazy in this project
20:08:49 <s2mitrov> i mean the core language is tiny
20:08:53 <ab9rf> i looked at racket a bit, but i have to admit that it being sexp truned me off
20:09:01 <Welkin> racket is amazing
20:09:04 <slacker2014> metahumor:  Will look it up, thank you.
20:09:05 <s2mitrov> ^
20:09:06 <metahumor> slacker2014: if you find some things unfamiliar, they also have a fp-course for filling in on some topics
20:09:11 <Welkin> I have previously found lisps very difficult to get into
20:09:19 <Welkin> racket feels different though
20:09:20 <s2mitrov> i fucking love lisps
20:09:42 <Welkin> racket is the "write your own language" scheme
20:09:44 <s2mitrov> i don't know why, but i feel so cozy when writing racket
20:10:08 <s2mitrov> i'd love to work a clojure/scheme/cl job at some point
20:10:14 <Welkin> so I am using a dialect of racket to write my own markup language, using some literate programming library
20:10:48 <slacker2014> metahumor:  Thanks for the tip.
20:11:05 <ab9rf> a friend of mine who teaches CS uses racket for some of his classes, and was telling me about it
20:11:24 <slacker2014> when I find an unfamiliar symbol in a library that isn't listed in hoogle, is it a safe assumption that the symbol is bound to a function?
20:11:29 <ab9rf> i used to be a big scheme fan, but i overdosed on parentheses and developed an aversion
20:11:50 <s2mitrov> ab9rf:a lot of universities use racket as their intro to CS language
20:11:50 <Welkin> slacker2014: don't use hoogle for that, search hayoo, or install local hoogle and build local docs for all of your libraries
20:12:00 <Welkin> hoogle covers very little
20:12:07 <metahumor> ^^ hayoo is best for operators
20:12:16 <Welkin> @where hayoo
20:12:16 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
20:12:29 <slacker2014> Welken: Oh! good to know. :)
20:12:51 <Welkin> hoogle is really only good if you install it locally and build your own docs
20:13:06 <Welkin> otherwise it won't help you much unless you are searching for something in base
20:13:22 <Welkin> hoogle does allow to search by type signature though, while hayoo does not
20:13:35 <ab9rf> yeah, the search-by-type-sig is nice
20:13:40 <Welkin> but hayoo has everything
20:13:57 <cheers> https://github.com/tweag/ghc/tree/linear-types anyone know how far along this is?
20:14:23 <Welkin> cheers: from what I have heard, don't expect anything until 8.6 at least
20:14:35 <cheers> ah. well, at least there's a target (:
20:14:39 <cheers> thanks for the info
20:14:41 <slacker2014> welking: Okay.  In the general cause, these would be symbols representing functions exported by the package right?
20:15:04 <slacker2014> Welkin: ^
20:15:13 <Welkin> who knows. Search and see
20:15:44 <slacker2014> Okay.
20:16:25 <Welkin> if you are searching for an operator, like <*>, wrap it in parentheses like this (<*>)
20:17:31 <slacker2014> Welkin:  Okay, thank you.  Looking for (|||).  Xmonad defines this to list layouts.
20:17:47 <Welkin> I think that is also in Data.Arrow
20:18:05 <Welkin> Control.Arrow*
20:18:21 <Welkin> it's in a lot of packages actually
20:18:28 <slacker2014> Yes, a whole bunch of packages define this.  This is great!
20:18:56 <slacker2014> I thought I had hit a dead end when I didn't find it on hackage.
20:19:07 <ski> Racket is quite nice
20:20:01 <ab9rf> i dunno, lispy languages seem noisy to me
20:20:16 <ski> just don't look at the brackets
20:20:26 <ski> (and indent correctly)
20:20:29 <ab9rf> that's like not thinking about the elephant
20:21:05 <Welkin> my s-expressions can become quite difficult to read
20:21:09 * ski . o O ( "Riastradh's Lisp Style Rules" at <https://mumble.net/~campbell/scheme/style.txt> )
20:21:24 <Welkin> especially if they are filled with quasiquotes and unquotes of different kinds
20:21:46 <ski> yea, nested quotes can be a little bit messy
20:23:47 <Welkin> I also miss the partial application haskell gives me for free
20:23:56 <slacker2014> But still, lesser syntax to learn. :)
20:24:35 <enterprisey> ideas for wrapping long lines of compositions?
20:25:05 <enterprisey> as in, any stylistic opinions for/against any of: leaving a . at the end of the line, putting a . at the beginning of each line
20:25:21 <Welkin> I prefer a (.) at the end of the line
20:25:37 <Welkin> I find that I always prefer to have my operators at the end
20:25:52 <Welkin> whether it is <> or <*> or $ or . or =<<, etc
20:27:28 <metahumor> i prefer operators like that at the beginning, because i read left-to-right and i want to know what is going on when i start reading a line
20:27:46 * enterprisey should've definitely known better than to toss out a bikeshedding question
20:28:31 <enterprisey> I'm staring down a 5-function composition of monad running, and beginning to doubt some design choices
20:28:35 <metahumor> enterprisey: put the compositions in a list, then fold composition over it, and decide how to line-break lists
20:28:41 <enterprisey> ooh, that's an idea
20:28:43 <metahumor> enterprisey: use a do block?
20:29:03 <enterprisey> I can do that? I thought I was only allowed to work in one monad at a time
20:29:16 <enterprisey> unless you're talking about the list monad
20:29:33 <enterprisey> (wait that wouldn't be helpful)
20:30:51 <metahumor> oh you mean you have like "runReaderT . runMaybeT . evalStateT"
20:32:48 <enterprisey> exactly
20:33:30 <enterprisey> except for some reason I'm flipping each one, since this is a test suite and I'd rather pass in the stuff first
20:33:59 <enterprisey> because it turns something type'd as a bunch of monads into something else type'd as a bunch of other monads
21:02:15 <sdrodge> enterprisey: (`runStateT` s) instead of flip runStateT s
21:02:20 <sdrodge> saves a little space
21:02:26 <enterprisey> ooh, good suggestion
21:02:35 <Welkin> o.o
21:02:42 <Welkin> are you one of those people?
21:02:48 <sdrodge> I am.
21:02:56 <sdrodge> I think?
21:02:59 <sdrodge> Depends what those people are.
21:03:01 * cppxor2arr holds his breath
21:03:03 <Welkin> who thinks that dropping characters in their variable names will "save space"
21:03:06 <Welkin> code golfer
21:03:07 <enterprisey> Welkin: guilty of using () <$ instead of the fmap & const version
21:03:25 <enterprisey> also guilty of gratuitous lambda-casing
21:03:44 <sdrodge> Honestly, Haskell has a bit of a code golf flavor to it.
21:03:48 <enterprisey> true
21:04:00 <sdrodge> So many single character variable names.
21:04:04 <Welkin> only in pointless form
21:05:15 <sdrodge> I dunno, wouldn't traditional advice about variable naming suggest runStateT :: StateT state monad a -> state -> monad (a, state)
21:05:28 <sdrodge> instead of runStateT :: StateT s m a -> s -> m (a, s)
21:05:56 <[Leary]> I'll put in a vote for 'operators at the start'. I usually go with one of these styles, but I'm not very consistent about which: http://lpaste.net/362966
21:05:59 <Welkin> I thin it's the math influence
21:06:08 <Welkin> think*
21:06:15 <Welkin> it works with haskell
21:06:20 <Welkin> it doesn't work with other languages
21:06:26 <sdrodge> I agree.
21:06:30 <Welkin> because they are not assignments, they are bindings
21:07:02 <Welkin> for intermediate variables, I always use a more descriptive name
21:07:23 <sdrodge> I'm not saying Haskell does it wrong. Just pointing out it's weird to suggest that my use of (`runStateT` s) instead of flip runStateT s is code-golfing in some way inconsistent with good Haskell.
21:07:50 <Welkin> I didn't say it wasn't good
21:08:14 <sdrodge> Okay, misunderstood you then.
21:08:30 <sdrodge> As for the original bikeshedding question
21:08:39 <sdrodge> enterprisey: I prefer operators starting the lines
21:09:05 <sdrodge> Just like [Leary] did in their lpaste.
21:16:25 <s2mitrov> `f` a also has different semantics? benefits? not sure what the word im looking for is, to flip f a
21:17:08 <enterprisey> also I have another fun issue
21:17:31 <enterprisey> I currently write f a b = evalStateT (unChecker a) b
21:17:35 <enterprisey> wondering how to write this pointfree
21:17:48 <pikajude> @pl f a b = evalStateT (unChecker a) b
21:17:48 <lambdabot> f = evalStateT . unChecker
21:18:01 <pikajude> seems straightforward enough
21:18:30 <pikajude> i mean, if you eta reduce, it's f a = evalStateT (unChecker a)
21:18:33 <enterprisey> oh wait I was wrong
21:18:38 <pikajude> and from then the pointfree version is obvious
21:18:39 <enterprisey> yeah what I posted is easy
21:18:43 <enterprisey> I was struggling with
21:18:49 <enterprisey> f a b = evalStateT (unChecker b) a
21:18:58 <enterprisey> order is key lol
21:19:05 <pikajude> @pl f a b = evalStateT (unChecker b) a
21:19:06 <lambdabot> f = flip (evalStateT . unChecker)
21:19:11 <pikajude> makes sense
21:19:15 <enterprisey> oh boy I'm bad
21:19:19 <enterprisey> lol, tyty
21:22:29 <sdrodge> s2mitrov: what difference are you getting at?
21:25:14 <s2mitrov> sdrodge: if f has two arguments and is rank-n in the first one, you can do partially applied infix (e.g (`f` x)) and it'll work, while flip f x does not
21:25:46 <sdrodge> interesting
21:25:53 <enterprisey> and another one, sorry: I have f :: a -> b, and g :: c -> d -> a - I want to make h :: c -> d -> b
21:26:06 <enterprisey> so far I have h x y = f $ g x y
21:26:11 <enterprisey> but there has to be a better way
21:26:23 <enterprisey> maybe with composition and parens? but I can't come up with anything that typechecks
21:27:37 <sdrodge> :t (.) . (.)
21:27:38 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
21:28:46 <enterprisey> I remember reading about that a while ago, but it obviously didn't sink in :p tysm
21:28:48 <sdrodge> I think it's also called blackbird from Data.Aviary.Birds
21:28:50 <sdrodge> :t blackbird
21:28:52 <lambdabot> error: Variable not in scope: blackbird
21:28:54 <enterprisey> classic haskell
21:29:22 <enterprisey> from the most recent changelog of that library
21:29:23 <enterprisey> "Removed the "useful" combinators (to emphasize that Data.Aviary is not a utility library)."
21:29:24 <enterprisey> hello?
21:29:27 <s2mitrov> i should use Data.Aviary.Birds for personal projects
21:30:11 <enterprisey> I'll use it and get roasted by the people working on this with me, lol
21:30:27 <s2mitrov> :D
21:33:01 <sdrodge> enterprisey: Another way to "spell" blackbird in that example is: h = (f .) . g
21:33:19 <sdrodge> And that does work "every" time.
21:33:27 <enterprisey> yeah, this is a corner of Haskell that I should go into more
21:33:42 <sdrodge> I don't know how well-known that pattern is.
21:33:43 <enterprisey> it's more fun than slinging around type families, imo
21:34:38 <sdrodge> I originally learned about it from this talk, if you're interested in seeing more examples: https://www.youtube.com/watch?v=seVSlKazsNk
21:35:00 <enterprisey> ah, the things I do to write pointfree formulas
21:35:02 <s2mitrov> oh hey isnt this the ATS guy
21:35:18 <enterprisey> love the title
21:35:28 <s2mitrov> nevermind
21:35:31 <bontaq``> <3 the birds package.  when i give some talks on haskell at work I definitely want to introduce it with "most haskell programmers use the birds package to simplify code"
21:35:32 <s2mitrov> classic white guy racism :"^)
21:36:16 <s2mitrov> https://www.youtube.com/watch?v=zt0OQb1DBko for another awesome talk
21:36:35 <enterprisey> my watch later list is getting longer and longer
21:36:43 <enterprisey> I already have a bunch of the I/O 2012 talks on there
21:37:16 <s2mitrov> i gotta figure somethin out for lambdaconf for this year; i have enough aeroplan miles for a free flight
21:38:00 <s2mitrov> that 900 dollar ticket price + a few hundred for accomodation and food is a bit ouch though
21:40:14 <enterprisey> ScopedTypeVariables is for type signatures in where clauses, right
21:40:25 <s2mitrov> yee
21:40:31 <ski> e.g.
21:43:44 <enterprisey> uh, the birds have failed me
21:43:48 <enterprisey> looking for (a -> b -> c) -> (c -> d -> e) -> a -> b -> d -> e
21:44:23 <enterprisey> and if anyone's starting to wonder where I get these dumb type sigs from, I'm writing a typechecker for a language that's C with a bigger type system
21:45:04 <enterprisey> oh I was wrong
21:45:12 <enterprisey> it is (a -> b -> c) -> (d -> c -> e) -> a -> b -> d -> e
21:46:46 <enterprisey> actually, what can I google to figure out how I can make these myself
21:51:48 <sdrodge> enterprisey: That one looks like \f g -> (flip g .) . f
21:52:08 <[Leary]> @djinn (a -> b -> c) -> (d -> c -> e) -> a -> b -> d -> e
21:52:08 <lambdabot> f a b c d e = b e (a c d)
21:52:09 <sdrodge> And eta reduction is the thing to look up, I guess?
21:52:22 <[Leary]> @pl f a b c d e = b e (a c d)
21:52:22 <lambdabot> f = flip ((.) . (.) . flip)
21:52:32 <enterprisey> whoa
21:52:37 <enterprisey> so lambdabot does it for you lol
21:52:44 <sdrodge> yes
21:52:47 <enterprisey> although the human version is much better in this case
21:52:52 <sdrodge> no
21:53:08 <sdrodge> I would arrive at the lambdabot version if I continued to make my version point free.
21:53:17 <enterprisey> well, I was referring to the 51:59 version vs the 51:26 version
21:53:19 <enterprisey> oh right
21:53:21 <enterprisey> I see what you mean
21:53:39 <sdrodge> It's the same difference between (f .) . g vs. (.) . (.)
21:56:27 <ski>   infixr 9 .:; (.:) = (.) . (.)
21:59:07 <sdrodge> ski: I would prefer ... personally.
21:59:58 <sdrodge> Besides (.:) is already taken by aeson.
22:00:06 <[Leary]> I like ... too, but as infixl 8. Mixes in better with compositions.
22:02:54 <ski> number of characters in `.:' is number of arguments "passed on", number of dots is number of dots in the definition
22:03:06 <ski> ditto for `(.::) = (.) . (.) . (.)'
22:03:27 <ski> that was my rationale for selecting those symbols, years back ..
22:03:46 <sdrodge> (.....)
22:04:01 <ski> heh, i think that's harder to read, at a glance :)
22:04:13 <sdrodge> marginally, yeah.
22:04:26 <sdrodge> I could be convinced to do it your way if not for the conflict with aeson.
22:04:56 <ski> fwiw, i think my probably predates aeson ;)
22:05:02 <[Leary]> If I had it my way, we'd use ., .., ... and probably never need higher. Unfortunately .. is illegal. :(
22:05:06 <sdrodge> ski: I believe it.
22:05:53 <ski> in any case, `.:' is only half serious, half a cute hack
22:06:39 <sdrodge> perhaps we ought to define it as fmap `fmap` fmap instead :)
22:06:54 <ski> nah, at least say `fmap . fmap' then
22:07:17 <sdrodge> yeah, fair
22:07:35 <ski> there can be a point to using a more specific operation than necessary, when one's already going to use it in the more restricted sense anyway
22:07:58 <sdrodge> I've definitely run into the problem of "wait which fmap is this?" while reading code before.
22:08:28 <ski> so, `map' over `liftM' over `liftA' over `fmap'/`(<$>)'
22:08:51 <ski> (and `(<$>)',`(<*>)' are bad name choices, imho)
22:09:04 <sdrodge> do explain
22:09:14 <sdrodge> (why you think they're bad choices)
22:09:19 <ski> imho `(<*>)' should be called `(<$>)'
22:09:38 <ski> `(<*>)' suggests a more symmetric operation to me, since the symbol looks symmetric
22:09:55 <sdrodge> That's a reasonable point, actually.
22:10:01 <[Leary]> Not much more so than <$>
22:10:20 <ski> then `(<$>)' could be `($>)' or something ..
22:10:21 <sdrodge> I'm always annoyed when pedagogical texts do x <*> y instead of f <*> x
22:11:00 <ski> also, there ought to be an analogue between `$' and `<$>' (which is currently called `<*>')
22:11:48 <cocreature> I’m sure unicode has some star character that’s not symmetric :)
22:11:49 <ski> so, in `f $> ia <$> ib', the angles point to the actions
22:12:59 <ski> (oh, and `$' (and `$!') ought to be left associative :)
22:13:20 <sdrodge> now that's heresy.
22:14:24 <ski> well, you should never ever type `foo $ bar x y $ baz $ blah' when you mean `foo . bar x y . baz $ blah' / `(foo . bar x y . baz) blah', anyway :)
22:14:53 <ski> consider the second defining equation of
22:14:54 <ski> @src foldl'
22:14:54 <lambdabot> foldl' f a []     = a
22:14:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:15:01 <ski> we can currently write it as
22:15:30 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
22:15:31 <[Leary]> Fair. I don't mind which way $ goes; as long as it's the lowest precedence it wont affect my usage.
22:15:40 <ski> with left-associative `$!' and `$', we could write
22:15:46 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
22:17:01 <ski> @src $!
22:17:02 <lambdabot> f $! x = x `seq` f x
22:20:21 <pikajude> is there a library that provides a compat layer over TH?
22:20:23 <pikajude> like base-compat
22:20:33 <pikajude> i realize it'd be a little harder to do
22:24:24 <cocreature> pikajude: th-abstraction does that but only for a limited interface
22:25:53 <pikajude> ooh, backwards compatible datatype definitions
22:25:57 <pikajude> that's what i needed
22:32:00 <dminuoso> ski: o/ sorry I dropped out suddenly, had to drop off a train.
22:32:31 <dminuoso> 08:37:42 <ski> dminuoso : fwiw, could you elaborate on what you had in mind with "kind of makes sense if you consider Peano construction" ?
22:33:16 <dminuoso> ski: So let me start with what initiated the thought process. I just started at the definition of a list, and realized "hey this kind of looks like a weird product between some type `a`" and something that basically looks like Peano numbers
22:33:28 <dminuoso> data List a = Cons a (List a) | Nil
22:33:43 <dminuoso> data Peano = Succ (Peano) | Zero
22:35:35 <ski> dminuoso : ok
22:35:43 <ski> did you see my ornaments comment ?
22:36:08 <Taneb> dminuoso, this kind of correspondence is discussed in Okasaki's Purely Functional Data Structures, which may be of interest
22:36:23 <Taneb> iirc it was used to define random access lists
22:37:45 <dminuoso> ski: Not sure. Im reading your comments around `08:35:59 <ski>` right now
22:37:50 <s2mitrov> how readable is purely functional data structures?
22:37:58 <pikajude> awww, there's no recCCompat
22:38:02 <dminuoso> Taneb: Ah, this is frequently mentioned. Perhaps I should take a look.
22:38:04 <pikajude> that's unfortunate
22:39:42 <Maxdamantus> If a programming language is non-lazy and has a unit type and an array type (for arrays whose size are determined at creation time), `unit[]` should be compiled to have the same representation as some integer type.
22:39:51 <ski> "Ornamental Algebras, Algebraic Ornaments" by Conor McBride in 2011-01-23 at <http://plv.mpi-sws.org/plerg/papers/mcbride-ornaments.pdf>,<http://plv.mpi-sws.org/plerg/papers/mcbride-ornaments-2up.pdf>
22:40:12 <ski> it would be nice with a language feature for this, rather than having to encode it manually, though
22:41:05 <ski> Maxdamantus : so no uniform representation for you ?
22:41:11 <dminuoso> ski: Alright, going to look through it. By the way, when I said that the construction of `Fin n` makes sense, I just meant in order to construct `n` you basically have to construct all previous numbers first.
22:41:51 <Maxdamantus> ski: what do you mean by uniform representation? You mean where all values are stored in objects that have to be referenced via pointers?
22:42:03 <guest_> hi guys, this is my code http://lpaste.net/362969 , here pk  is ` PublicKey "\134M\130F\142\CAN\190\v,\228\190\232v\171\243]5\CAN\t\211\151\DC1]\188\t\206\233k\190\237\218>" `, I want to extract the string from  this, how can i do it?
22:42:05 <ski> well .. yes, before constructing `Succ (Succ (Succ Zero))', you have to first construct `Succ (Succ Zero)'
22:42:08 <Maxdamantus> I guess that's partly what I was thinking of when I said "non-lazy".
22:42:35 <Maxdamantus> since laziness suggests there is something like that "uniform representation": thunks.
22:42:54 <ski> Maxdamantus : well .. or at least that all values have the same size, like tagged pointer vs. tagged integer, say
22:43:46 <ski> well, being by-value doesn't mean you have to scrap uniform representation
22:44:08 <ski> uniform representation means that you can use type erasure for parametric data types, and for polymorphism
22:44:58 <ski> otherwise, when you have `foo :: forall a. ..a..', you need to pass some kind of "typeinfo" at run-time, at least describing the size of values of type `a', or possibly more info about layout (say perhaps for GC purposes)
22:46:11 <Maxdamantus> When I've thought about how I'd implement that sort of polymorphism (ie, avoiding ending up with `id$Double` and `id$Long`), I've thought it should basically be special cased for the size of the values represented by the parametric types.
22:46:37 <Maxdamantus> So `id :: Long -> Long` and `id :: Double -> Double` would both just use the `id` function special-cased for 8-byte values.
22:47:06 <ski> ok, so you replicate the code for each specialization of polymorphic code
22:47:15 <Maxdamantus> Only for each size.
22:47:39 <Maxdamantus> Since the functions that are declared "for all" types don't actually care what the type is
22:47:48 <ski> ok, if there a definite/bounded number of sizes ?
22:48:02 <ski> or can you make new data types with larger size ?
22:48:08 <Maxdamantus> If you have something like a class constraint in Haskell, the instance should be passed in as an argument.
22:48:17 <mniip> Maxdamantus, "size"?
22:48:38 <mniip> usually longs are passed in arithmetic registers while floats are passed in floating or simd registers
22:48:40 <guest_>  hi guys, this is my code http://lpaste.net/362969 , here pk  is ` PublicKey "\134M\130F\142\CAN\190\v,\228\190\232v\171\243]5\CAN\t\211\151\DC1]\188\t\206\233k\190\237\218>" `, I want to extract the string from  this, how can i do it?
22:49:25 <Maxdamantus> ski: there should be a finite set of potentially instantiable types known at compile time.
22:49:26 <ski> mniip : well, i think Maxdamantus is thinking about an array, or a list, of `Long' or whatever ?
22:49:35 <Maxdamantus> ski: afaics, that's even true in Haskell.
22:49:36 <ski> mniip : if so, you can't then have polymorphic recursion, and existentials, without delaying compilation (JIT or RTCG)
22:49:39 <ski> er
22:49:40 <ski> Maxdamantus ^
22:49:49 <ski> Maxdamantus : nope, polymorphic recursion
22:50:07 <Maxdamantus> Well, existentials need special handling.
22:50:22 <Maxdamantus> I don't think that's standard Haskell, to be fair.
22:51:15 <ski> > let silly :: Show a => [a] -> [String]; silly [] = []; silly (x:xs) = show x : silly (map (: []) xs) in silly [0,1,2,3]
22:51:17 <lambdabot>  ["0","[1]","[[2]]","[[[3]]]"]
22:51:22 <ski> this is Haskell98
22:52:11 <mniip> guest_, case pk of PublicKey s -> ...
22:53:04 <ski> `silly' also needs to construct `Show' instances at run-time
22:53:53 <mniip> fsvo "construct"
22:55:08 <mniip> there's $fShowInt and $fShow[]
22:55:10 <ski> it needs to apply the construction specified in `Show a => Show [a]', repeatedly
22:55:26 <mniip> and all you need to do to start with $fShowInt and repeatedly apply $fShow[] to it
22:55:31 <ski> aye
22:56:43 <ski> (point being that you can't inline away the instance passing, either, in general)
22:57:35 <mniip> yes
23:00:08 <Maxdamantus> Yeah, so I guess that requires the same sort of handling as existentials.
23:01:50 <Maxdamantus> Doesn't seem like it excludes the possibility of a non-uniform representation. It just means you sometimes need to generate code that takes the size as an argument.
23:03:08 <dminuoso> ski: At any rate, the most interesting discovery from this, is the equivalence of B^A and `A -> B`
23:04:39 <mniip> err
23:04:50 <mniip> dminuoso, that's usually different notation for the same thing
23:05:27 <ski> dminuoso : now consider the laws `a^1 = a',`(a^b)^c = a^(c*b)',`a^0 = 1',`a^(b+c) = a^b * a^c',`1^c = c',`(a*b)^c = a^c * b^c', interpret these as type isomorphisms/bijections
23:06:41 <mniip> ski, what is meant by B^A and A->B there?
23:07:02 <ski> in addition to the obvious `1 * a = a = a * 1',`(a * b) * c = a * (b * c)',`0 + a = a = a + 0',`(a + b) + c = a + (b + c)',`0 * c = 0 = c * 0',`(a + b) * c = a * c + b * c',`c * (a + b) = c * a + c * b',`a * b = b * a',`a + b = b + a'
23:07:14 <mniip> exponential object vs hom-set?
23:07:25 <ski> mniip : `A -> B' is the set/type of functions from `A' to `B'. `B^A' is the same thing
23:07:34 <ski> no hom-sets
23:07:47 <mniip> right but whatever material dminuoso was reading it seemed like they used to mean different thing
23:08:39 <ski> dminuoso just discovered that `|A -> B|  =  |B|^|A|', for finite `A' and `B'
23:08:46 <mniip> ah
23:10:35 <ski> for the next exercise, define `N !' so that `| N ! |  =  |N| !', and define `C(N,K)' so that `| C(N,K) |  =  C(|N|,|K|)', where `C(n,k)' is the binomial coefficient, the number of ways one can choose `k' objects, without regard for order, out of `n' total
23:12:14 <centril> > class Foo x where method :: x ; instance Foo Int where method = 1 ; class Bar x where method :: x ; instance Bar Int where method = 2 ; method :: Int
23:12:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘class’
23:12:24 <dminuoso> ski: That is not meant for me, is it?
23:12:42 <centril> why is lambdabot being difficult :(
23:12:49 <ski> dminuoso : it is, if you care for it
23:13:12 <centril> > class F x where m :: x ; instance F Int where m = 1 ; class B x where m :: x ; instance B Int where m = 2 ; m :: Int
23:13:14 <lambdabot>  <hint>:1:1: error: parse error on input ‘class’
23:13:23 <ski> @let class Foo x where {method :: x}; instance Foo Int where {method = 1}; class Bar x where {method :: x}; instance Bar Int where {method = 2}
23:13:23 <dminuoso> centril: I think > expects an expression
23:13:24 <lambdabot>  .L.hs:181:9: error:
23:13:24 <lambdabot>      Multiple declarations of ‘method’
23:13:24 <lambdabot>      Declared at: .L.hs:175:9
23:13:40 <ski> @let class Foo x where {methodF :: x}; instance Foo Int where {methodF = 1}; class Bar x where {methodB :: x}; instance Bar Int where {methodB = 2}
23:13:43 <lambdabot>  Defined.
23:13:47 <centril> > method :: Int
23:13:50 <lambdabot>  error:
23:13:50 <lambdabot>      • Variable not in scope: method :: Int
23:13:50 <lambdabot>      • Perhaps you meant one of these:
23:13:51 <centril> oh
23:13:55 <dminuoso> ski: Alright, Ill see what I can do.
23:14:24 <centril> ski: hmm... I didn't get that error in ghci, what gives..?
23:14:31 <centril> (multiple declarations..)
23:14:48 <ski> (dminuoso : and when i say define, i don't mean you have to do it in Haskell. just do it conceptually, in math, on paper, or however you prefer)
23:15:04 <ski> > methodF :: Int
23:15:07 <lambdabot>  1
23:15:08 <ski> > methodB :: Int
23:15:10 <lambdabot>  2
23:15:12 <ski> centril : which error ?
23:15:16 <dminuoso> ski: I gathered as much. To be honest Im a bit confused, but perhaps I can make sense of it. :)
23:15:22 <centril> ski:  Multiple declarations of ‘method’
23:15:28 <dminuoso> Gotta drop off the train, thank you for the input so far ski.
23:15:35 <centril> ski: the same-naming was intentional
23:15:38 <ski> dminuoso : np
23:15:50 <centril> (the whole point even)
23:15:59 <[Leary]> ski: I guess set theoretically a^0 = 1 corresponds to the empty relation which is vacuously a function, but how does that make sense type theoretically?
23:16:15 <mniip> [Leary], \x -> case x of { }
23:16:28 <guest_> <mniip> :  case pk of PublicKey s -> ... this thing does not work
23:16:33 <ski> centril : `Foo' and `Bar' defined in different modules ?
23:16:44 <mniip> guest_, define "does not work"
23:17:13 <centril> ski: I literally wrote the class, the instance, the class, the instance, the expression in ghci one by one
23:17:15 <centril> and got no error
23:17:37 <centril> does ghci do some sorta overriding?
23:17:49 <ski> [Leary] : for all inhabitants of `0', you need to pick an inhabitant of `a'. there are zero inhabitants of `0', so you're done
23:17:59 <mniip> centril, yes
23:18:03 <guest_>  <mniip> : this error http://lpaste.net/362973
23:18:06 <mniip> the new class shadows the old one
23:18:19 <ski> @type let void :: Void -> a; void v = case v of {} in void
23:18:19 <[Leary]> That feels wrong, but I guess. >.>
23:18:21 <lambdabot> Void -> a
23:18:48 <mniip> guest_, what package is Crypto.PubKey.Ed25519 from?
23:18:54 <ski> @djinn-add type NotNot a = Not (Not a)  -- type Not a = a -> Void
23:18:54 <lambdabot> Cannot parse command
23:18:58 <ski> @djinn-add type NotNot a = Not (Not a)
23:19:00 <ski> -- type Not a = a -> Void
23:19:08 <centril> mniip: that is pretty sneaky... ghci made me a liar =P
23:19:09 <ski> @djinn NotNot (Either a (Not a))
23:19:09 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
23:19:21 <guest_>  <mniip>:  https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html#t:PublicKey
23:19:34 <centril> I assumed this meant that GHC was clever and picked the last method defined, not that it was a ghci thing
23:19:40 <centril> or is that the algorithm used?
23:19:45 <ski> centril : oh .. you didn't enter both `Foo' and `Bar' at the same time ?
23:19:50 <centril> ski: na
23:19:58 <ski> (i did, and got "Multiple declarations of ‘method’")
23:20:26 <mniip> ah right
23:20:27 <mniip> Bytes
23:20:47 <mniip> centril, in general in haskell you can define anything in any order
23:20:54 <mniip> centril, in ghci not so much
23:21:18 <cocreature> guest_: you should be able to use https://hackage.haskell.org/package/memory-0.14.14/docs/Data-ByteArray.html#v:convert to convert the PublicKey to a ByteString
23:21:22 <ski> in GHCi, you can use `:{' and `:}', to enter multiple lines, that may be mutually recursive, and which will be processed together, without shadowing
23:21:23 <centril> ski: interesting... I tried this in ghci and promptly went on to claim that GHC uses the "last item defined with the name" to a fellow rustacean, but I guess I was terribly wrong
23:21:39 <ski> you can also use `;', as you/i did
23:22:17 <centril> In any case, it sparked a thought in that rustacean about how to fix a serious problem trait with method call syntax Rust currentlyhas
23:22:19 <mniip> guest_ sounds like 'unpack' should do it
23:22:29 <mniip> or yes, 'convert'
23:22:45 <ski> centril : what's that problem, ooc ?
23:23:38 <centril> ski: I added  Iterator::flatten to the standard library, which the trait Itertools {..} impl<T: Iterator> Itertools for T {..} already had... and so breakage in a month or so..
23:23:46 <centril> (flatten == join)
23:24:04 <guest_> <cocreature> :  convert gives this error http://lpaste.net/362974
23:24:09 <centril> but picking the last imported trait could fix this
23:24:16 <centril> whenever there is ambiguity
23:24:21 <cocreature> guest_: add an explicit type signature
23:26:07 <ski> centril : you know if you import two modules in Haskell, both exporting `foo', if/when you actually try to use (unqualified) `foo', you'll get an ambiguity error, you must explicitly qualify (possibly using a local abbreviation/alias of the module name, which can even collect multiple distinct modules under the same alias)
23:27:22 <centril> ski: seems like a semver hazard
23:27:31 <centril> but then haskell is kinda YOLO over semver =P
23:27:41 <ski> iirc, if you use an overloaded operation in Ada (can overload on both input and output types, as well as arity of course), it'll complain if there's ambiguity (rather than silently defaulting to whichever version it "thinks" you wanted, as certain other languages ..)
23:28:37 * ski thinks there ought to be individual rename on import & export, in Haskell
23:28:47 <centril> yes please
23:29:41 <ski> also the type checker ought to report identifiers (like types ..) relative to the current modules in scope, not leaking implementation details of the actual module defining it
23:30:13 <ski> (one issue here is if the identifier is currently imported via more than one module, which path to use ?)
23:30:22 <guest_> <cocreature> : it works (explicit type signature) :)
23:31:32 <ski> guest_ : fwiw, if you say "<cocreature> ..." it looks like you're quoting (or faking) something cocreature said earlier. why not just use the nickname, without angle bracket ? :)
23:31:51 <ski> (just a tip)
23:32:44 <guest_> ski : new to freenode, don't know earlier, will try from next time
23:33:01 <ski> (another issue with rename is that `Show' and `Read' won't be happy)
23:33:26 <ski> guest_ : np, cheers. welcome to the channel
23:46:05 <centril> ski: do you know of any papers on type hole programming?
23:46:16 <centril> I'm going to propose that Rust steals that idea
23:46:23 <centril> (from Haskell)
23:47:38 <sdrodge> They can steal it from Idris or Agda instead if they want :P
23:49:16 <centril> sdrodge: why instead?
23:52:55 <sdrodge> Just kidding around. Haskell got the feature later than those languages did.
23:53:26 <centril> sdrodge: really? I could have sworn that I've been doing  expr :: _  for ages
23:53:55 <sdrodge> I could easily be wrong. Human memory isn't particularly reliable.
23:54:15 <mniip> git remembers
23:55:23 <sdrodge> praise be
23:55:33 <centril> mniip: unless the history is rewritten
23:56:31 <cocreature> centril: there are two features, one is called “typed holes” which allows you to put a _ in place of a term and see the type GHC expects, the other is putting _ in a type signature. the first one is relatively old (7.10 iirc or maybe even 7.8), the later only appeared in 8.0 iirc
23:56:54 <cocreature> centril: and sdrodge is right, this feature has existed in agda and idris before that
23:56:57 <centril> cocreature: oh yes
23:57:19 <centril> cocreature: who got it first? Idris or Agda?
23:57:32 <cocreature> dunno
23:57:35 <centril> damn
23:58:03 <cocreature> I wouldn’t be surprised if it existed in some other proof assistants before that
23:58:12 <sdrodge> I would guess Agda, given that it's much older than Idris.
23:59:09 <cocreature> sdrodge: I’m not sure that’s true. iirc edwin mentioned at somewhere that he started idris around the same time that agda got started
