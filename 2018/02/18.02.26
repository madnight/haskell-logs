00:17:39 <ertes-w> helo
00:45:40 <granny_> HELP!how do i install irssi?
00:46:06 <cppxor2arr> why ask here
00:46:51 <[exa]> granny_: certainly not using haskell. Ask at your distro's IRC channel
00:49:05 <granny_> [exa]: what's that?
00:49:37 <cppxor2arr> granny: point is irssi install help is off topic here. all about haskell here
00:51:12 <CodeKiwi> https://www.xkcd.com/1654/
00:51:43 <cppxor2arr> heh
00:54:17 <quchen> anohigisavay: Yes it is, but it’s not straightforward.
00:54:29 <quchen> I once wrote a script to do that for me, let me see whether I can find it.
00:54:35 <quchen> Use case: coding on an airplane.
00:54:53 <anohigisavay> quchen: :D thanks
00:55:28 <quchen> anohigisavay: Haven’t run it in quite some time though. The idea is to get the Stackage snapshot packages in a list and then preloading all of them individually. https://github.com/quchen/stackage-everything/
00:56:09 <quchen> anohigisavay: I was asked to create a proper package out of this, but never got around to doing it :-/
00:57:34 <anohigisavay> quchen: saved my day thank you so much
00:58:00 <quchen> anohigisavay: The script there gives you a .cabal file that you can then feed to stack somehow. I forgot how, haven’t done it in two years :-/
00:58:21 <quchen> Stack has a flag for »download but don’t compile«, so using that one it worked somehow.
00:58:34 <quchen> Sorry for my blurry memory and the hacky program.
00:59:11 <quchen> stack build --prefetch --dry-run
01:10:21 <quchen> anohigisavay: I changed the readme a bit, should be clearer now.
01:11:13 <anohigisavay> quchen: by `adjust the parameters` did you mean the comment line at the top?
01:12:21 <quchen> anohigisavay: No, the arguments in »main«. They tell the script which LTS release to build
01:13:09 <anohigisavay> quchen: I got this warning: Warning: Cannot run preprocessors. Run 'configure' command first.
01:13:19 <anohigisavay> quchen: but seems the tarball has been created
01:13:47 <quchen> anohigisavay: Oh, there is no need to run the cabal stuff
01:14:11 <quchen> Just run ./Generate.hs, then go into the output directory and run »stack build --prefetch --dry-run«
01:14:23 <quchen> anohigisavay: And time it!
01:14:31 <quchen> time stack build --prefetch --dry-run
01:14:36 <quchen> And then tell me how long it takes :-)
01:23:31 <anohigisavay> quchen: sorry am a bit busy. will catch you later :P
01:25:25 <anohigisavay> had no luck :'( https://paste.pound-python.org/show/s5e6ScL9JmthMrTf9Crh/
01:26:44 <quchen> anohigisavay: It says 5.4, is that right? That’s a very old release
01:27:53 <quchen> It worked with 10.5 when I tried it just now. main = generatePackage "10.5" "10.5" "input/stackage-lts-10.5.cabal"
01:28:04 <quchen> And before wget…10.5…
01:34:19 <anohigisavay> quchen: umm. there's no stackage-lts-10.5.cabal in the input folder
01:34:54 <anohigisavay> quchen: oh i see
01:37:03 <anohigisavay> quchen: now i got this error when trying 10.5:
01:37:06 <anohigisavay> quchen: https://paste.pound-python.org/show/CTH33mHzAzpU9yerh2o8/
01:41:58 <quchen> Hmmmmmmmmmmmm
01:48:20 <anohigisavay> quchen: _(:з」∠)_
01:48:30 <quchen> Getting the same error now
01:50:11 <quchen> I guess the complaint is that the generated package depends on libraries
01:50:32 <quchen> …which we don’t care about since we’re heavily abusing the system, but meh
01:51:34 <quchen> If you’re short on time, delete the 30-something packages from the generated .cabal file and try again.
01:51:47 <quchen> It’s stupid work but does not take terribly long.
01:56:04 <merijn> quchen: Does stack not support a way of mirroring locally? I know you can just point cabal-install at a local hackage mirror, at least
01:56:19 <quchen> Yup, works when you remove the complaint files
01:56:35 <quchen> merijn: I don’t think it allows you to mirror Stackage, just specific packages
02:26:03 <anohigisavay> quchen: thanks :) i'll try it again when i get home
02:29:06 <quchen> anohigisavay: I rewrote it a bit. Try the new version, should be a no-brainer.
02:29:27 <quchen> anohigisavay: git clone; ./Generate.hs --lts 10.6 > script; chmod u+x script; ./script
02:29:28 <quchen> wait
02:29:29 <quchen> Done.
02:46:37 * kuribas still doesn't use stack, only cabal
02:46:48 <Rembane> kuribas: Oldschool! :D
02:47:02 <kuribas> I just need to completely remove .cabal once in a while, then I'm fine again :)
02:47:08 <kuribas> (and .ghc)
02:47:19 <merijn> kuribas: Are you using new-build?
02:47:23 <piyush-kurur> Rembane: kuribas with cabal new-build stack I think is irrelevant
02:47:29 <kuribas> what's new-build?
02:47:35 <merijn> kuribas: o.O
02:47:35 <piyush-kurur> okey merijn got there before me
02:47:56 <merijn> kuribas: new-build is the future replacement of "cabal build", which is Nix inspired
02:48:20 <Putonlalla> When I worked that way, it allowed me to be so lazy that I never upgraded GHC, kuribas.
02:48:26 <merijn> kuribas: So cabal projects are completely independent while still being able to share identical dependencies
02:48:30 <piyush-kurur> kuribas: and is much better than using stack
02:49:00 <merijn> kuribas: Think of it as "all your builds are automagically sandboxed, while sharing any dependencies if possible"
02:49:08 <kuribas> ah cool :)
02:49:09 <tdammers> stack has become particularly problematic since the cassava thing
02:49:27 <merijn> kuribas: Have a look at: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
02:49:43 <kuribas> merijn: should I promote it instead of stack?
02:50:00 <merijn> kuribas: There's still some rough edges due to it being in development, but it's so much better I'm using it over sandboxes 100% now
02:50:05 <merijn> kuribas: I dunno, never used stack :p
02:50:17 <kuribas> ah, old school too
02:50:40 <merijn> kuribas: So if you like the your current cabal workflow, new-build let's you do things mostly like you always used to, except with even less suck
02:51:32 <merijn> kuribas: The main problem I have with new-build is that a lot of tools like hdevtools/ghc-mod don't play well with it yet. (In fact, my goal for this week is to chop up ghcid into something that plays nicer with vim error highlighting to solve that issue for myself)
02:52:02 <kuribas> yeah, I want haskell-mode to keep working...
02:52:31 <merijn> kuribas: yeah, the tooling is taking a while to catch up :/
02:52:35 <kuribas> though I am not sure it uses any of those...
02:52:47 <kuribas> perhaps I should help with those
02:55:12 <AWizzArd> Does Intero (Emacs) offer a (stack-) project wide „rename function” refactoring util?
02:56:14 <cocreature> AWizzArd: no
02:56:42 <AWizzArd> Aah it seems „HaRe” can do this: https://github.com/alanz/HaRe
02:57:12 <cocreature> it can definitely do it in a single file but iirc it doesn’t do project wide renames although that might have changed
03:02:40 <kuribas> what does intero give that haskell-mode doesn't?
03:03:21 <merijn> I'm using vim anyway, so none of those work for me anyway :p
03:03:33 <chisui> Is there a way of creating a composable, singleton like datatype that is able of holding actual values? You could create something like "data TList (l :: [*]) where TNil :: TList '[]; TCons :: a -> TList as -> TList (a ': as)"
03:03:41 <chisui> but that doesn't compose well.
03:03:56 <merijn> chisui: Compose well in what way?
03:05:17 <chisui> If I want to create a TList of TList I would like it to have the type "TList '['[]]" not "TList '[TList '[]]"
03:05:36 <chisui> The singleton like Type should not occure in the dependent type
03:05:44 <chisui> Is that possible?
03:06:35 <chisui> The best way I could come up with was giving TList a fake SingI instance
03:08:36 <chisui> The List example is somewhat constructed though. Ultimatly I want to create a Tree that represents its structure in its type but still can hold arbitrary values of the given types.
03:09:41 <lyxia> it looks like you want dependent types
03:11:12 <merijn> chisui: Note, there are no dependent types in Haskell and as you're discovering, faking them is rather painful
03:11:23 <merijn> There's a reason the paper on it is called Hasochism ;)
03:12:04 <chisui> merlijn: do you mean the singletons paper?
03:13:56 <chisui> I know I want dependent types and I know they are painful to use but I thought you could construct such a type
03:14:20 <merijn> chisui: If you really want dependent types, have you considered Idris?
03:14:54 <chisui> yes I have considered Idris
03:15:56 <kuribas> idris isn't really production ready
03:16:33 <merijn> kuribas: tbf, neither is dependent haskell
03:17:05 <kuribas> idris also doesn't have much libraries
03:17:21 <tdammers> "idris isn't production ready" is kind of an in-joke by now, isn't it
03:17:46 <merijn> I'm just saying the answer to "how do I do this cleanly in Haskell" is very likely "you don't"
03:18:15 <chisui> I will be using concurrency in this project and last I checked Idris wasn't there yet on that front
03:18:31 <Putonlalla> It all depends on what you're producing, tdammers.
03:19:00 <kuribas> tdammers: it's also succesfully avoiding success :)
03:19:04 <chisui> In my case it's a research project
03:22:48 <tdammers> Putonlalla: that goes for every language though, doesn't it
03:23:25 <Putonlalla> Yes.
03:25:30 <tdammers> take PHP, for example - after two decades of ongoing development and massive adoption, the language still doesn't support strings or arrays, and hashmaps are basically forbidden due to HashDoS vulnerabilities
03:26:34 <bo> As non PHP dev - *surprised*
03:26:37 <dminuoso> 12:17           merijn | I'm just saying the answer to "how do I do this cleanly in Haskell" is very likely "you don't"
03:26:41 <dminuoso> merijn: Can you elaborate what you mean by that?
03:27:01 <merijn> dminuoso: Working with dependent types
03:27:03 <dminuoso> Ah.
03:29:08 <alanz> AWizzArd, HaRe is built into hie
03:29:13 <ventonegro> Although Idris's C runtime is far from Haskell's RTS, Idris has an actively maintained JVM target
03:29:25 <ventonegro> That could be an option for some people
03:29:29 <alanz> (and in fact is the reason hie exists)
03:29:49 <chisui> Is there a way of telling ghc to pretend that a typefamily is injective?
03:29:58 <jcjf> Wow... that's an interesting fact about PHP
03:30:04 <ventonegro> https://github.com/mmhelloworld/idris-jvm
03:31:08 <chisui> ventonegro: that sounds pretty interesting. Do you know how well that integrates with scala?
03:31:41 <ventonegro> chisui: I don't know, sorry... Not a Java/Scala developer myself
03:31:55 <asdkjkjs> what the fuck is a haskell
03:32:29 <jcjf> asdkjkjs: a kind of curry
03:32:38 <quchen> chisui: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
03:32:43 <cordawyn> ventonegro: afaik, idris-jvm (still) does not make it possible to build JARs (and idris packages)?
03:33:14 <cordawyn> also, it relies heavily on having Main.main method in your "executable"
03:33:22 <jcjf> how is eta lang coming along?
03:33:33 <asdkjkjs> so its python for hipsters
03:33:46 <ventonegro> cordawyn: Can't you create the JAR yourself in your build system
03:33:48 <chisui> isn't eta just a subset of Haskell?
03:34:14 <AWizzArd> alanz: I didn’t know about „hie”. Will have a look, thx!
03:34:38 <cordawyn> ventonegro: I guess so. I just think it's quite limiting with regards to modularizing of idris code, overall
03:34:40 <alanz> otherwise known as haskell-ide-engine.
03:34:44 <ventonegro> cordawyn: https://github.com/mmhelloworld/idris-jvm/blob/master/docs/compiling-idris-without-main-module.md
03:35:36 <cordawyn> 17 days ago... I'm getting old :)
03:35:40 <chisui> you could also just put it in the classpath and invoke the code with reflection
03:35:50 <bontaq``> I haven't seen many updates to eta for awhile... wonder if it's still alive
03:36:05 <cordawyn> ventonegro: thanks, I'll check it out
03:36:17 <ventonegro> cordawyn: sure, hope it helps
03:37:57 <bontaq``> actually huh looks like eta is still trucking along
04:01:57 <guest_> hi guys i am trying to use `randomByteString` function from this library (https://hackage.haskell.org/package/raaz-0.2.0/docs/Raaz-Random.html) , and I am getting this error (http://lpaste.net/362908), any one know  how to solve it?
04:09:25 <fishythefish> guest_: it can't tell whether 42 has type ALIGN or type BYTES Int, so add a type annotation to clarify
04:09:57 <guest_>  <fishythefish> : how ?
04:10:10 <fishythefish> well, which do you want it to be?
04:10:36 <guest_>  <fishythefish> : lets say ALIGN
04:10:41 <fishythefish> (42 :: ALIGN)
04:11:45 <guest_>  <fishythefish>: this does not work `randomByteString (42::ALIGN)`
04:12:31 <fishythefish> guest_: be more specific. did your compiler spit out an error? did your computer light on fire?
04:14:04 <guest_>  <fishythefish> : it gives this error http://lpaste.net/362909
04:15:12 <fishythefish> guest_: well, of course. without a Show instance, it can't print anything
04:15:23 <fishythefish> you need to use the result to make something you can display
04:16:03 <fishythefish> but that at least demonstrates that the call to randomByteString is being done properly
04:17:08 <guest_> <fishythefish> : can add show instance to it ? is it possible (i am new to haskell :()
04:17:16 <chisui> guest_: Take a look at the example you linked to. `RT` is a Monad that has to be evaluated before you can do anything with its value
04:17:45 <chisui> guest_: you can't add a meaningful Show instance to `RT` here unfortunatly
04:17:51 <fishythefish> guest_: no, you can't. you can define a wrapper type and make a Show instance for that
04:18:59 <chisui> guest_: use `securely` or `insecurely` to evaluate the `RT` Monad
04:19:17 <chisui> https://hackage.haskell.org/package/raaz-0.2.0/docs/Raaz-Core-Memory.html#v:securely
04:21:35 <noan> what's the recommended way to go about setting up a haskell dev environment on ubuntu LTS? the repo versions from ubuntu are very old... Tarball and manual PATH update?
04:22:02 <chisui> noan: what about stack?
04:22:43 <guest_> ok guys got it , I can't print the value of `randomByteString (42::ALIGN)`, I stored it in some variable which shows its type  as `RT mem ByteString`, can I convert it to ByteString?
04:23:01 <noan> chisui, I could grab stack from a tarball also
04:23:12 <merijn> noan: I install the bindists myself on basically every OS, yes
04:23:18 <merijn> noan: Works perfectly fine
04:23:31 <hpc> stack is the easiest way to get a controlled build envrironment
04:23:51 <hpc> you may also want to install ghc and cabal from tarballs just so you have faster repl access though
04:24:31 <noan> https://www.haskell.org/platform/linux.html#linux-generic
04:24:34 <noan> Opinions of this?
04:24:56 <chisui> guest_: `RT` itself does not hold any `ByteString` it basically is a recipe of how to create a random BysteString given an environment
04:25:08 <Psybur> When would you ever want to use "insecurely" in Raaz? That leaves the crypto information unsafe? I guess if your using random numbers in a game its fine?
04:25:17 <merijn> noan: I don't use the platform myself, I just install the GHC bindist
04:26:31 <Psybur> Whoa, I just remembered I had a weird dream where I had a bunch of wild crows that I would give puzzle boxes with rewards inside of them. I named them after some people on IRC haha merijn you had a crow named after you!
04:27:04 <kuribas> do you need something like redis in haskell?
04:27:37 <opqdonut> sure, you can use redis with haskell
04:27:41 <Psybur> They all knew their names and would line up for roll call every morning and theyd get a treat when Id call their name and they stepped forward and squawked haha
04:27:53 <kuribas> opqdonut: what does it give that haskell doesn't have?
04:28:09 <merijn> Psybur: Sounds like you spend too much time here before bed :p
04:28:10 <opqdonut> well consider writing a stateless web application in haskell
04:28:15 <opqdonut> and storing the state in redis
04:28:18 <Psybur> I actually only spend time here at work :P
04:28:21 <chisui> noan: stack you can install stack without a package manager with a "curl .. | sh" command. It also can take care of upgrading itself
04:28:24 <opqdonut> for easy clustering
04:28:49 <Psybur> ertes had a crow and ski had a crow too haha
04:28:51 <opqdonut> it's just the same as with other languages, sometimes you want a separate database, sometimes not
04:29:25 <maerwald> curl ... | sh
04:29:27 <maerwald> love it
04:29:37 <maerwald> execute arbitrary code from the internet
04:29:43 <opqdonut> well isn't that what we do all day long?
04:29:47 <maerwald> no
04:29:54 <kuribas> opqdonut: is that easier than storing haskell data as binary blobs (or xml, json) in a RDBMS?
04:30:17 <noan> chisui, can stack give me a global ghc as well installed?
04:30:35 <opqdonut> kuribas: I don't think easiness is the criterion for choosing between these, they're different approaches
04:30:40 <chisui> maerwald: I don't like it either but it's the what the Stack docu itself tells you to do
04:30:42 <opqdonut> kuribas: but it should be as easy I think
04:30:48 <opqdonut> if not easier
04:30:49 <maerwald> chisui: yeah well... stack.
04:31:47 <ertes-w> what?
04:32:06 <guest_> <chisui> : what it means `it basically is a recipe of how to create a random BysteString given an environment` ?
04:32:12 <opqdonut> maerwald: so how is curl|sh from stack's official site via https worse than, say, installing an .rpm distributed by their site?
04:32:17 <chisui> noan: yup: run `stack ghci` anywhere
04:32:59 <noan> chisui, sounds good to me
04:33:39 <opqdonut> ok, an rpm is easier to remove or upgrade, but from a security perspective?
04:34:45 <chisui> guest_: `RT` does not contain a value. It is a function that takes a seed, `securely` is a way of providing a seed
04:35:40 <hvr> opqdonut: and .rpm is actually more principled than stack trying to reinvent the system packaging layer
04:35:47 <chisui> opqdonut: depending on what repositories you are using there is additional auditing
04:37:32 <maerwald> opqdonut: erm
04:37:35 <maerwald> are you serious?
04:37:50 <maerwald> code run through the package manager is usually sandboxed and *very* restricted what it can do
04:38:15 <ertes-w> the problem of curl|sh is not curl|sh itself, but the common community habits behind it
04:38:21 <maerwald> even if you tried to come up with a malicious rpm, it's hard
04:38:45 <ertes-w> "supporting multiple package managers is hard, so let's just circumvent package management altogether"
04:39:17 <ertes-w> "let's probe the system based on heuristics instead of providing multiple versions of the same package"
04:39:23 <ertes-w> etc.
04:40:25 <ertes-w> i don't think there are any security implications in curl|sh that wouldn't exist if you would install a package
04:41:02 <hvr> ertes-w: one thing I actually liked about .rpm is that it keeps hash-sums of the files it installs
04:41:16 <maerwald> ertes-w: oh, a lot
04:41:18 <hvr> ertes-w: and you can ask rpm to verify those checksum to search for corruypted files
04:42:32 <hvr> or that it keeps a reflog of when something was installed/upgraded
04:42:52 <ertes-w> yeah, in general i'd prefer package managers
04:43:04 <maerwald> it's already about the installation process itself and the way access to the root file system is restricted
04:43:15 <maerwald> or even network access, syscalls
04:43:16 <ertes-w> although i've used curl|sh in the past from sources i trust
04:43:17 <maerwald> depends on the PM
04:43:32 <ertes-w> right, that's a valid point
04:43:50 <ertes-w> installing a package may not involve giving the source root access
04:45:11 <hvr> I'd still pointout that rpm & deb et al have about 2 decades of engineering & experience in them
04:45:20 <maerwald> most PMs also have file collision detection, so just replacing /bin/bash with something won't work :P
04:50:50 <opqdonut> maerwald: rpm post-install scripts etc. are run as root, without sandboxing
04:51:37 <chisui> use Nix
04:52:16 <opqdonut> don't get me wrong, I too prefer installing packages via my distribution package manager
04:52:26 <opqdonut> but the curl|sh hate is a bit overblown too, IMO
04:52:38 <hvr> what hate?
04:52:54 <noan> https://github.com/Twinside/vim-hoogle
04:52:56 <opqdonut> comes up often on the internet, and here just a while ago
04:53:03 <noan> Is there a better plugin for hoogle support?
04:53:11 <opqdonut> but this is offtopic, I'll get back to work
04:53:22 <tdammers> noan: :!hoogle
04:53:36 <maerwald> opqdonut: --noscripts
04:54:04 <Boomerang> noan: I have this in my .ghc/ghci.conf: `:def hoogle \s -> return $ ":! hoogle search -l --count=15 \"" ++ s ++ "\""`
04:54:30 <Boomerang> As well as: `:def doc \s -> return $ ":! hoogle search -l --info \"" ++ s ++ "\""`
04:54:37 <opqdonut> maerwald: even with noscripts, you will then be running the code installed by the rpm without a sandbox (though maybe not as root)
04:54:58 <opqdonut> maerwald: what I'm saying is trust matters, not whether the code was distributed as a shell script or as an rpm or whatever
04:55:01 <maerwald> yes and that's already a fundamental difference
04:55:10 <Boomerang> But :!hoogle requires no setup
04:55:12 <maerwald> there is more trust involved with curl .. | sh
04:55:17 <maerwald> I don't trust people.
04:55:25 <opqdonut> how?
04:55:28 <opqdonut> how is there more trust?
04:55:36 <maerwald> because of all the things I just mentioned
04:56:16 <opqdonut> a malicious rpm takes only a bit more effort than a malicious shell script
04:56:30 <maerwald> not really
04:56:52 <tdammers> the problem isn't the shell script
04:57:07 <opqdonut> yeah
04:57:15 <tdammers> piping an unsigned rpm directly into an rpm installer is just as bad
04:57:23 <opqdonut> even with --noscripts
04:57:30 <maerwald> that's incorrect
04:57:30 <opqdonut> (btw, note that stack isn't telling you to run the script as root)
04:58:01 <hvr> tdammers: slightly less so, if rpm is configured to verify crypto sigs and you've setup your trustdb
04:58:12 <tdammers> hvr: hence, "unsigned rpm"
04:58:14 <opqdonut> he said unsigned
04:58:20 <hvr> tdammers: right
04:58:25 <TMA> signature does not entail any guarantee either -- besides 'was not tampered with after the signature was made'
04:58:29 <opqdonut> if you can trust the rpm, or the curled script, everything is fine
04:58:29 <tdammers> rpm signing takes away most of the problems
04:58:46 <tdammers> opqdonut: the problem with the curled script is you have nothing to base your trust on
04:59:05 <opqdonut> well, https and possibly a posted cryptographic hash
04:59:13 <tdammers> at best, you can verify that the script comes from the rightful owner of the domain with https
04:59:23 <opqdonut> but yeah the infrastructure isn't as good as with deb/rpm
04:59:36 <tdammers> but the cryptographic hash is only meaningful if you can be sure that the thing you just hashed is the same thing you're about to execute
04:59:46 <tdammers> but if you pipe curl output directly into a shell, you can't do that
04:59:55 <opqdonut> yes
05:00:00 <dminuoso> > join (1,(3,4))
05:00:02 <lambdabot>  error:
05:00:02 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M482966489214...
05:00:02 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:00:06 <dminuoso> :t (1,(3,4))
05:00:08 <lambdabot> (Num b, Num a2, Num a1) => (a1, (a2, b))
05:00:12 <dminuoso> :t join (1,(3,4))
05:00:13 <lambdabot> (Num a2, Num a1, Monoid a1) => (a1, a2)
05:00:20 <dminuoso> Where does this Monad instance come from?
05:00:26 <metahumor> you mean Monoid?
05:00:41 <metahumor> or how is "join" possible?
05:00:44 <tdammers> well, you could, but all the ways I can think of would require downloading the entire script first, then hash it, and only then feeding it to a shell, but that kind of defeats the purpose of piping directly into the shell, doesn't it
05:00:49 <dminuoso> :t join
05:00:50 <lambdabot> Monad m => m (m a) -> m a
05:01:18 <Psybur> % join [[1,2]]
05:01:19 <yahb> Psybur: [1,2]
05:01:28 <Psybur> @src join
05:01:28 <lambdabot> join x = x >>= id
05:02:10 <metahumor> dminuoso: instance (Monoid m) => Monad (,) m where join (f, (g, x)) = (f <> g, x)
05:02:28 <Psybur> % join (Just (Just 1))
05:02:28 <yahb> Psybur: Just 1
05:02:30 <metahumor> or g <> f prolly
05:02:35 <dminuoso> Ohh https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-324
05:02:44 <metahumor> % join ("a", ("b, "c"))
05:02:44 <yahb> metahumor: ; <interactive>:77:22: error: lexical error in string/character literal at end of input
05:02:57 <metahumor> % join ("a", ("b", "c"))
05:02:58 <yahb> metahumor: ("ab","c")
05:03:03 <metahumor> yeah, f <> g
05:03:13 <dminuoso> metahumor: I was just looking for some elegant ways to get isomorphisms such as `(a,(b,c)) -> (a,b,c)`
05:03:23 <dminuoso> Guess `join` is not that :)
05:03:23 <Psybur> % ("a",("b","b")) >>= id
05:03:23 <yahb> Psybur: ("ab","b")
05:03:31 <metahumor> dminuoso: there's no generic way to do that afaik
05:03:37 <Psybur> % ("a",("b","c")) >>= id
05:03:37 <yahb> Psybur: ("ab","c")
05:03:56 <metahumor> re this Monad instance, compare it to the Monad instance for State
05:04:03 <dminuoso> metahumor: Ah heh interesting.
05:04:16 <dminuoso> metahumor: I guess this does make sense if you consider how State arises.
05:04:24 <dminuoso> (The two adjoint functors that State is from I mean0
05:04:25 <Psybur> % join . join $ ("a",("b","c"))
05:04:25 <yahb> Psybur: ; <interactive>:81:25: error:; * Couldn't match expected type `([Char], a)' with actual type `[Char]'; * In the expression: "c"; In the expression: ("b", "c"); In the second argument of `($)', namely `("a", ("b", "c"))'; * Relevant bindings include it :: ([Char], a) (bound at <interactive>:81:1)
05:04:52 <chisui> Does anyone know why my `cabal repl` exits with "ghc-pkg: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)" ?
05:06:06 <metahumor> i guess it's more like Writer...?
05:06:24 <metahumor> https://wiki.haskell.org/Monoid#On_the_Writer_monad
05:06:33 <Psybur> % join (("a","b"),"c")
05:06:34 <yahb> Psybur: ; <interactive>:82:17: error:; * Couldn't match expected type `(([Char], [Char]), a)' with actual type `[Char]'; * In the expression: "c"; In the first argument of `join', namely `(("a", "b"), "c")'; In the expression: join (("a", "b"), "c"); * Relevant bindings include it :: (([Char], [Char]), a) (bound at <interactive>:82:1)
05:07:26 <metahumor> Psybur: that might be a Comonad
05:08:29 <dminuoso> metahumor: No its not like Writer.
05:09:01 <dminuoso> metahumor: If you consider the two (adjoint) functors: ((->) a) and ((,) b) then you can :.: compose them in two ways
05:09:01 <metahumor> that link has the Monad instance for tuples exactly what we are looking at
05:09:18 <dminuoso> metahumor: Because they are adjoint you get a monad back. Depending on the order you then get either State or Store (Costate)
05:09:39 <Psybur> % extend (("a","b"),"c")
05:09:39 <yahb> Psybur: ; <interactive>:83:8: error:; * Couldn't match expected type `w a -> b' with actual type `(([Char], [Char]), [Char])'; * In the first argument of `extend', namely `(("a", "b"), "c")'; In the expression: extend (("a", "b"), "c"); In an equation for `it': it = extend (("a", "b"), "c"); * Relevant bindings include it :: w a -> w b (bound at <interactive>:83:1)
05:10:15 <metahumor> % extract (("a", "b"), "c")
05:10:16 <yahb> metahumor: "c"
05:10:24 <metahumor> % duplicate (("a", "b"), "c")
05:10:24 <yahb> metahumor: (("a","b"),(("a","b"),"c"))
05:10:44 <metahumor> % extract fst (("a", "b"), "c")
05:10:44 <yahb> metahumor: ; <interactive>:86:1: error:; * Could not deduce (Monoid b0) arising from a use of `extract'; from the context: Monoid t bound by the inferred type of it :: Monoid t => t at <interactive>:86:1-29; The type variable `b0' is ambiguous; These potential instances exist:; instance forall a k (b :: k). Monoid a => Monoid (Const a b) -- Defined in `Data.Functor.Const'; inst
05:11:11 <metahumor> % extend fst (("a", "b"), "c")
05:11:12 <yahb> metahumor: (("a","b"),("a","b"))
05:11:31 <metahumor> dminuoso: yeah i remember this conversation about :.: and State
05:12:21 <metahumor> if StateT was actually ((->) a) :.: ((,) b) then the Applicative instance for StateT would not need an Monad constraint on the inner "m"
05:12:21 <kuribas> :t extend
05:12:22 <lambdabot> error: Variable not in scope: extend
05:12:51 <metahumor> but the Applicative instance we use for StateT only makes sense if the inner m is Monad
05:13:08 <Psybur> %extend id (("a","b"),"c")
05:13:16 <Psybur> % extend id (("a","b"),"c")
05:13:16 <yahb> Psybur: (("a","b"),(("a","b"),"c"))
05:13:27 <metahumor> extend id === duplicate
05:13:38 <Psybur> Yeah I just realized :D
05:13:56 <dminuoso> Basic comonad laws.
05:14:06 <metahumor> https://hackage.haskell.org/package/comonad-5.0.3/docs/Control-Comonad.html#t:Comonad
05:14:11 * dminuoso should print them out
05:14:56 <dminuoso> metahumor: Oh wait. Just realized that my judgement to consider Writer different was faulty. Writer _is_ basically just a Monad instance around ((,) a) if you want.
05:15:48 <dminuoso> metahumor: I still find it amazing that you get this plethora of really amazing and basic monads and comonads with such small things.
05:16:09 <dminuoso> The things you can do with just a function and a pair.
05:16:40 <dutchie> adjoint functors are great
05:17:12 <dminuoso> dutchie: If only I understood what `adjoint` actually meant =)
05:17:43 <metahumor> instance (Monoid s, Applicative f) => Applicative (WeirdStateT s f) where f <*> a = WeirdStateT $ \s -> let (f',s') = runWST f s in let (a',s'') = runWST a s in (f' <*> a', s' <> s'')
05:17:48 <dutchie> they are just upside down mumble mumble twisty twisty snake lemma
05:18:12 <metahumor> but that WeirdStateT is just a composition of Writer and Reader in a not a very useful way
05:21:22 <[exa]> btw is there some good new practical reading about comonads newer than 'comonads are objects' ?
05:34:00 <Hjulle> I am using the Interactive-Haskell mode (from haskell-mode) in emacs to get a ghci-like shell. It works fine, except that when I load a file that has a qualified import it ignores the "qualified" and gives me "ambigous occurence" errors, despite having qualified the import. Does anyone know why or what to do about it?
05:37:10 <ertes-w> Hjulle: do you have a custom .ghci file?
05:38:00 <ertes-w> Hjulle: if yes, be sure to use e.g. -ignore-dot-ghci in your haskell-process-args-ghci variable
05:45:31 <Hjulle> ertes-w: It didn't help
05:54:55 <Hjulle> However, disabling haskell-process-auto-import-loaded-modules did help. Perhaps it was not a question of what was qualifed or not, but rather what was loaded.
05:55:28 <Hjulle> ertes-w: Thanks
06:29:43 <Athas> What's a simple way to increment a Float by the smallest possible amount to obtain a different Float?
06:29:52 <Athas> (I don't care what happens at NaN or infinity.)
06:30:23 <metahumor> Athas: its going to be different depending on the order of magnitude of the Float
06:30:34 <Athas> metahumor: I know, that's why I don't just embed a constant.
06:30:45 <Athas> I see the 'ieee' package has a method.  Strange how it's not in base.
06:31:02 <Taneb> (unsafeCoerce :: Iso' Float Word32) +~ 1
06:32:25 <Athas> Taneb: points for gumption!
06:32:44 <cocreature> Taneb: iirc unsafeCoerce really is unsafe for Float → Word32
06:34:19 <metahumor> > decodeFloat 0.00001
06:34:22 <lambdabot>  (5902958103587057,-69)
06:34:32 <ventonegro> cocreature: In which way?
06:34:46 <metahumor> i tried unsafeCoerce last night on Double -> ByteString, got a sigsegv
06:35:17 <Rembane> :D
06:36:43 <cocreature> ventonegro: iirc it can break completely (to the point where your program just segfaults) since floats and words are stored in different registers
06:36:50 <metahumor> > (uncurry encodeFloat . Control.Arrow.first (+1) . decodeFloat) 0.00001
06:36:52 <lambdabot>  1.0000000000000003e-5
06:37:08 <metahumor> Athas: there you go
06:37:16 <metahumor> > (uncurry encodeFloat . Control.Arrow.first (+1) . decodeFloat) 0.1
06:37:19 <lambdabot>  0.10000000000000002
06:37:31 <Athas> That's nice too!
06:37:38 <Athas> I just went with the ieee package, though.
06:37:38 <ventonegro> cocreature: I see
06:37:52 <Athas> cocreature: in practice, are Floats not always boxed on GHC?
06:38:03 <cocreature> see https://stackoverflow.com/questions/6976684/converting-ieee-754-floating-point-in-haskell-word32-64-to-and-from-haskell-floa
06:38:27 <cocreature> Athas: hm good point, maybe it’s only unsafeCoerce :: Float# -> Word32# that goes wrong?
06:40:32 <merijn> cocreature: You're a bad, bad person >.>
06:40:47 <cocreature> merijn: I’m the one that suggested that this is a bad idea!
06:41:21 <merijn> also, maybe you need unsafeCoerce# instead of unsafeCoerce
06:41:28 <merijn> You know, for extra unsafety... :p
06:41:33 <cocreature> ah right
06:41:56 <[exa]> the real feeling of unsafe
06:42:14 <quchen> tagToEnum# that shit
06:42:19 <quchen> unsafeCoerce is not unsafe enough
06:42:20 <metahumor> Athas: you like that "succIEEE" runs a C ffi?
06:42:21 <cocreature> the docs for unsafeCoerce# explicitely mention that Float# -> Word32# doesn’t work
06:42:41 <cocreature> not sure about "unsafeCoerce :: Float -> Word" but I definitely wouldn’t trust it :)
06:43:00 <merijn> metahumor: C FFI is pretty efficient, though
06:43:14 <Athas> metahumor: I don't mind it, if Haskell is really unable to express this efficiently.
06:43:14 <quchen> Segfaults are much more fun if they happen only after the next GC (or even later!). Segfaults right away are too gentle of a shot in the foot.
06:43:22 <quchen> In other news, don’t coerce floats to words. :-S
06:43:38 <cppxor2arr> it's always a good dream having a segmentation fault
06:43:45 <Athas> Lots of C code runs underneath my Haskell anyway!
06:44:05 <cocreature> “Sigh. This is horrible, but then so is unsafeCoerce.” gotta love those ghc source code comments
06:44:12 <Putonlalla> It's one thing to be unsafe, but the `UniqDFM` module from `ghc` features `alwaysUnsafeUfmToUdfm`.
06:44:20 <quchen> inlinePerformIO is also a good source of fun.
06:44:56 <cocreature> quchen: oh I didn’t even know that was a thing
06:45:03 <cocreature> *adds inlinePerformIO everywhere*
06:45:17 <metahumor> Athas: use the newer ieee754 package
06:45:21 <merijn> cocreature: It's more famous by it's old name
06:45:23 <quchen> cocreature: pure . pinlinePerformIO -- everywhere to make the typechecker happy
06:45:28 <merijn> cocreature: accursedUnutterablePerformIO
06:45:33 <quchen> Pssst
06:45:39 <quchen> That name is such a giveaway :-(
06:45:39 <cocreature> merijn: ah I know that one :)
06:45:54 <cocreature> yeah inlinePerformIO sounds surprisingly harmless
06:46:13 <quchen> Inline means it’s fast
06:46:21 <merijn> quchen: It is fast!
06:46:27 <merijn> At crashing, mostly, but still!
06:46:43 <cocreature> if your program segfaults immediately it finishes quite fast!
06:46:50 <quchen> As we all know, being fast is morally okay.
06:46:55 <quchen> Or how did that go again
06:47:34 <dminuoso> "Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. Very unsafe."
06:47:37 <dminuoso> Heh
06:48:19 <quchen> It also exposes lots of things for floating out. Such as allocating buffers.
06:48:55 <Taneb> cocreature: the horrible thing is I'm not unsafeCoercing Float and Word32 there, I'm unsafeCoercing (Float -> Float) and (Word32 -> Word32)
06:49:20 <merijn> Taneb: You just made me very sad
06:49:30 <Taneb> merijn: I make me very sad too, don't worry
06:50:00 <Taneb> (actually, I think they're Float -> Identity Float and Word32 -> Identity Word32 but same difference)
06:50:03 <merijn> Taneb: Pretty sure you should consult a priest or something...
06:50:06 <Athas> I really don't like how frequently unsafe operations are used in Haskell.
06:50:22 <quchen> …almost never?
06:50:35 <quchen> I mean, #haskell is certainly not a good estimator for their real world usage
06:50:36 <merijn> quchen: Clearly you're not looking at the right Haskell :p
06:50:39 <kuribas> Athas: I only use them in numerical code that must be really fast.
06:50:40 <quchen> :-þ
06:51:00 <dminuoso> Though wait a second.. Im staring at the definition of accursedUnutterablePerformIO. One can simply pattern match on IO objects? o.o
06:51:01 <cocreature> apart from unsafePerformIO around ffi calls, I’m not sure I’ve ever used one of the unsafe operations (directly)
06:51:16 <Taneb> I did once write a factorial calculator that segfaulted if you gave it a number over 11
06:51:19 <merijn> dminuoso: Sure
06:51:28 <Athas> quchen: many of the foundational libraries use it, don't they?
06:51:33 <merijn> dminuoso: If you import the IO constructor from one of the dangerous magic libraries
06:51:58 <kuribas> Athas: not doing bound checks in a vector operation can speed this quite a bit up.
06:52:23 <dminuoso> merijn: This is fairly interesting. I remember someone in here talking about how ultimately all evaluation is caused by case pattern matches.
06:52:24 <merijn> kuribas: V.unsafeIndex all the things :p
06:52:35 <quchen> dminuoso: Might have been me.
06:52:43 <carter> There’s some correct float word casting tools in 8.4
06:52:54 <kuribas> :t \f -> fmap join . traverse f
06:52:54 <merijn> dminuoso: You should go browse through the modules in ghc-prim if you wanna see dirty magic
06:52:56 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
06:53:05 <quchen> dminuoso: Case evaluates. Let allocates. Function application… I don’t know what that does exactly.
06:54:18 <quchen> It pushes arguments. That’s what application does.
06:54:28 <quchen> Kind of a bookkeeping job.
06:54:35 <merijn> quchen: I thought it did something with curry :p
06:55:37 <dminuoso> quchen: If it pushes, does that imply GHC uses push/enter?
06:55:56 <quchen> eval/apply also pushes things, but different things.
06:56:01 <quchen> GHC uses eval/apply.
06:56:15 <quchen> Push/enter pushes arguments, eval/apply pushes partial function applications.
06:56:29 <quchen> Other than argument handling, the two machines are the same. In particular, let and case work the same way.
06:57:54 <kuribas> is there are shorter way for: "fmap join . traverse f" ?
06:58:06 <Taneb> :t fmap join
06:58:07 <lambdabot> (Functor f, Monad m) => f (m (m a)) -> f (m a)
06:58:19 <quchen> :t \f -> fmap join . traverse f
06:58:20 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
06:58:26 <quchen> Hmmmmm.
06:58:57 <kuribas> lets say fmap join . traverse f :: (a -> IO (Maybe b)) -> (Maybe a) -> IO (Maybe b)
07:00:35 <kuribas> I guess not....
07:00:40 <dminuoso> kuribas: Mmm, could it be that `f` is missing some >>= inside?
07:00:59 <kuribas> dminuoso: no?
07:01:13 <kuribas> :t \f -> fmap join . traverse f :: (a -> IO (Maybe b)) -> (Maybe a) -> IO (Maybe b)
07:01:15 <lambdabot> error:
07:01:15 <lambdabot>     • Couldn't match type ‘a1 -> IO (Maybe b1)’ with ‘IO a0’
07:01:15 <lambdabot>       Expected type: (a1 -> IO (Maybe b1)) -> Maybe a1 -> IO (Maybe b1)
07:01:48 <ski> perhaps you could use `(=<<) :: (a -> MaybeT IO b) -> (MaybeT IO a -> MaybeT IO b)', using `maybe mzero return :: Maybe a -> MaybeT IO a' ?
07:02:48 <quchen> I think you should write this as a 3-line do block with good names.
07:02:58 <kuribas> yeah :)
07:03:15 <cocreature> or you could just use unsafeCoerce to make it typecheck
07:03:19 <ski> @type \f -> runMaybeT . (MaybeT . f =<<) . maybe mzero return
07:03:20 <lambdabot> Monad m => (a1 -> m (Maybe a2)) -> Maybe a1 -> m (Maybe a2)
07:03:25 <quchen> cocreature: ಠ_ಠ
07:04:32 <cocreature> I think that caused a segfault in quchen
07:04:41 <merijn> cocreature is my kinda programmer ;)
07:05:24 <dminuoso> cocreature: In a really sad way this reflects some of the C programmers I've met. "Want to change struct A into struct B? Just cast the pointer from A* to B*.
07:05:52 <merijn> dminuoso: Might work, depending on the struct
07:06:23 <dminuoso> merijn: Until aliasing optimizations kick in because some inlining cost has dropped below a threshold due to some unrelated code change 2 weeks later.
07:06:55 <cocreature> dminuoso: most people that write C shouldn’t be allowed to do so :)
07:07:00 <ventonegro> dminuoso: C guarantees that if struct A has struct B as the first field, that will always work
07:07:04 <AWizzArd> Just from the signature I have difficulties to see why there is mapM when there is also traverse.
07:07:20 <merijn> AWizzArd: Because mapM predates Traversable
07:07:29 <AWizzArd> Okay, just something historical. I see. Thx.
07:07:38 <cocreature> AWizzArd: traverse is basically what mapM should have been
07:07:50 <AWizzArd> I was wondering if there is any non-evil implementation for mapM that is doing something totally different when compared to traverse.
07:07:57 <cocreature> and traverse_ is mapM_
07:08:01 <AWizzArd> Good.
07:08:02 <dminuoso> ventonegro: That is downright incorrect.
07:08:05 <AWizzArd> Makes sense now.
07:08:37 <merijn> AWizzArd: Similarly, why mapA and liftA2 and liftM2, and tons of other redundant methods exist
07:08:53 <cocreature> AWizzArd: there is also for/for_ which are the flipped variants of traverse/traverse_ and can be useful in some cases
07:09:09 <merijn> AWizzArd: Fun fact, Applicative wasn't invented/discovered until about 6 years after Monad, which in turn was invented about 7-8 years after Haskell :p
07:09:09 <dminuoso> ventonegro: Or.. wait. I misread that. My apologies.
07:09:22 <ventonegro> dminuoso: ;)
07:10:07 <dminuoso> ventonegro: It's not type punning in this case though, because the underlying object is still accessed through an lvalue expression of its effective type.
07:11:08 <Athas> kuribas: that's interesting.  Apart from disabling bounds checks, must numerical/HPC code I have seen does not derive its performance from doing unsafe things.
07:11:13 <cocreature> what’s the usecase for this? isn’t just accessing the field and getting the address of that just as simple?
07:11:36 <Athas> Perhaps it is because most languages used for numerical computing don't require special unsafe operations to work with unboxed data, or perform vectorisation.
07:11:42 <kuribas> Athas: including freezing/unfreezing vectors?
07:12:01 <kuribas> Athas: I found that quite handy (not really unsafe though)
07:12:03 <Athas> kuribas: since most such languages are impure, that's not really a thing that comes up.
07:12:24 <merijn> Athas: tbh, you don't really need unsafe for uboxed data
07:12:29 <kuribas> Athas: then they're not really safe?
07:12:54 <Athas> The vector package in Haskell a great design, and the most well-polished example of high-performance FP I know.  (But it is somewhat limited.)
07:13:05 <Athas> kuribas: by "safe", I would say "stays within the language semantics".
07:13:21 <Athas> The problem with Haskell's unsafe operations is that they may violate the language semantics.  It's not about whether the program is correct or not.
07:14:11 <kuribas> Athas: well, C has a lot of undefined semantics.
07:15:28 <kuribas> Athas: and in C segmentation fault is within language semantics, so it's easier to stay "safe".
07:16:18 <Athas> kuribas: sure, but most HPC does not depend on it for performance, although I'd expect most non-trivial C code contains some kind of harmless undefined behaviour.
07:18:09 <kuribas> Athas: without freeze, etc, you'd need to copy a lot more.
07:18:15 <kuribas> that would affect performance.
07:18:50 <kuribas> of course, it's not needed if you write imperative style (returning mutable arrays).
07:19:33 <kuribas> but it's handy to have a function return an immutable array, then mutate it when you know it's safe.
07:19:48 <Athas> Yeah, that's what people usually do.  It might lead to bugs, but it at least stays within the language semantics, do you can debug it with standard tools.
07:20:34 <kuribas> I could of course write two versions for each function.
07:21:51 <AWizzArd> merijn: this whole thing is an exploratory process, but very interesting to know the history. Sometimes it is helpful to learn things in the order in which they were discovered/invented.
07:22:07 <anoe> +1
07:22:20 <AWizzArd> Maybe a Haskell in the future may get rid of them and decide to be incompatible ot Haskell 2010.
07:22:47 <merijn> Well, AMP is already incompatible with Haskell2010 :p
07:22:54 <merijn> i.e. Applicative being a superclass of Monad
07:23:16 <Athas> Don't worry, it'll be part of Haskell 2022!
07:23:37 <cocreature> Athas: did it get moved? I thought the plans were for a Haskell 2020
07:28:25 <Athas> cocreature: I'm just extrapolating from the time it took to get from Haskell 98 to Haskell 2010.  My involvement in the process is limited to accidentally deciding to eat lunch in the meeting room for the working group at ICFP last year.
07:28:40 <cocreature> heh
07:30:08 <cocreature> tbh Haskell2020 seems like a project that can only fail. either you specify the GHC implementation which would be great but for that you really want some kind of living standard that is continously updated instead of something that gets updated every 10 years, also at that point you are effectively precluding any other compilers due to the complexity or you specify some arbitrary subset of GHC which is
07:30:09 <cocreature> mostly useless since that’s not the language people use
07:32:37 <Athas> Haskell is essentially just as much of an implementation-defined language as OCaml these days.
07:32:52 <Athas> Maybe slightly less, since you do have things like UHC, which I'm not sure have an analog in OCaml.
07:33:52 <merijn> cocreature: There's plenty of stuff in GHC that can be specified with little worry
07:34:59 <Athas> merijn: then why was Haskell 2010 so very conservative?
07:35:14 <cocreature> merijn: sure but then just give me a specification of some GHC extensions/features and admit that it’s only a partial specification of the language instead of trying to come up with some definition of “Haskell” that nobody actually uses
07:35:18 <Athas> Even things like multi-parameter type classes, FlexibleInstances, and FlexibleContexts are not part of Haskell 2010.
07:35:31 <merijn> Athas: I don't quite know, tbh
07:35:56 <Athas> I suspect there is still some preference for keeping standard Haskell an "elegant" language, and a tacit belief that these extensions are dirty.
07:36:20 <Athas> But since they will never go away, maybe we should just accept that Haskell is a slightly overweight C++-esque language in practice.
07:36:49 <Rembane> Athas: How is Haskell C++esque?
07:36:51 <merijn> Athas: lol...
07:37:02 <merijn> Athas: What kinda lightweight C++ are you using?
07:38:19 <Athas> Rembane: it's nowhere as bad, of course, but it shows the same character of growing many new and complicated features.
07:40:34 <Rembane> Athas: Ah. Like C++ has all features ever? :)
07:40:59 * ertes-w finally gave up on System.Console.GetOpt
07:41:00 <Athas> Yes.  You can't remove features once they are in, even if you come up with a better idea later.
07:41:22 <thoughtpolice> FlexibleContexts, FlexibleInstances, and MPTCs are all 'easy' to specify until you realize they get most of their use on the backs of extensions that are not so easy. MPTCs in particular are not going to be very useful without fundeps or TFs. Now you have a real specification problem. The other thing is that historically the Haskell standard has not tried not to ascribe any particular strategy for type checking, evaluation,
07:41:22 <thoughtpolice> etc, out of a sense of strangling implementations.
07:41:31 <Athas> And the language is not designed as a whole, so there are some features that either overlap, or interact weirdly.
07:41:33 <thoughtpolice> And you can remove features. People just get mad at you. They get mad at you whatever you do.
07:41:42 <merijn> ertes-w: Give in to optparse-applicative! :p
07:42:15 <Athas> thoughtpolice: and the problem with fundeps and TFs is that they overlap significantly in usage, and so it is ugly to have both, right?
07:42:21 <thoughtpolice> If you have someone who thinks the Haskell standard is worthless and GHC is haskell, and then we enhance GHC to make <feature X they use> more powerful and it changes -- people often complain anyway. You can't win.
07:42:49 <thoughtpolice> Athas: That's not a problem IMO. Haskell has always had many ways to express a single thing; having both wouldn't be bad, per se. But it would be extremely difficult to formalize them in the manner the standard was traditionally written.
07:43:08 <ertes-w> merijn: i'm already a regular user of that one, but i was under the impression that GetOpt would be shorter for simpler cases
07:43:14 <Athas> Really?  It's been some years since I read the Haskell Report, but I don't remember it as being particularly formal.
07:43:26 <ertes-w> merijn: i was wrong =)
07:43:32 <thoughtpolice> > The other thing is that historically the Haskell standard has not tried not to ascribe any particular strategy for type checking, evaluation,
07:43:34 <Athas> It was useful as a language tutorial, I thought.  The SML definition, say, certainly is not.
07:43:35 <lambdabot>  <hint>:1:116: error: parse error on input ‘type’
07:44:02 <Athas> Do TFs and fundeps ascribe a particular strategy?
07:44:20 <Athas> And in any case, I'm dubious that the Haskell report has much value if it specifies a language that is not being used.
07:44:27 <thoughtpolice> Well, they have various ramifications on things like termination checking, which in turn impacts how you might want to structure things.
07:44:51 <thoughtpolice> Or even how you might want to write it at all. It's a specification, so teasing those things out is challenging.
07:45:31 * thoughtpolice must leave as he was on hold on the phone
07:45:39 <ertes-w> Athas: it's still (almost) the language GHC uses – the language it builts its extensions on
07:45:57 <ertes-w> Athas: it's like saying XML has no value because everybody uses XHTML anyway
07:46:24 <ertes-w> *builds
07:47:32 <ertes-w> (except you would be right in that case…  XML has no value)
07:47:59 <Athas> ertes-w: it has *some* value, but not as much.  When I want to interact with Haskell in any meaningful way, I'll read GHC's documentation for what it thinks Haskell looks like.
07:53:58 <ertes-w> Athas: i would think of that as a privilege, not a problem:  you can read GHC's documentation, and you'll be learning a language that is almost the same as the one defined by the report
07:54:06 <ertes-w> also i don't think GHC's documentation is exhaustive
07:56:28 <Athas> I think the lack of interest in the report is a result of its lack of relevance.
08:02:12 <ertes-w> is there really a lack of interest compared to other languages?  i've programmed C and C++ for years, and i've never looked at their specs
08:03:50 <ertes-w> the problem is:  the report is not a tutorial, so you're not going to learn haskell from it, but once you've learned haskell from other sources, it'll only ever be useful in detail questions
08:04:00 <cocreature> both C and C++ have multiple relevant compilers and a lot of people care about being able to compile their code with multiple of them which means that they need to respect the standard. they might not read it directly but they care about the fact that it exists
08:04:07 <Bowlslaw> Hutton's Programming Haskell is best Haskell
08:04:29 <cocreature> for Haskell the fact that there is a standard is just irrelevant to programmers since the compiler everyone uses doesn’t implement the standard and there is no other relevant compiler
08:04:57 <ertes-w> in other words: the report is simply not that useful to the average programmer…  you might look into it, if you want to exactly what the indentation rules for 'if' are, but more likely you'll just try if your desired style compiles or not
08:04:59 <hyperisco> not enough companies making proprietary compilers for Haskell, shame
08:06:11 <hyperisco> you have to also figure that C and C++ are more suited for systems programming, and so having many compilers for many architectures is unsurprising
08:06:43 <EvanR> so you need many backends
08:07:00 <ertes-w> what companies would even be interested in writing a competing haskell compiler?
08:07:15 <EvanR> if there was enough demand they would
08:07:18 <Taneb> ertes-w: Intel had an internal one for a while I think, but I don't think they did much with it
08:07:22 <cocreature> standard chartered for some definition of “haskell” ;)
08:07:30 <Taneb> But the amount of companies that write Haskell is already quite small
08:07:32 <cocreature> Taneb: that was only a different backend for ghc afaik
08:07:53 <hyperisco> EvanR, maybe. I don't know enough of the history or perspective of compiler devs / companies selling compilers
08:08:03 <ertes-w> even if it were huge, writing an alternative compiler for haskell is a serious investment
08:08:09 <Athas> Perhaps the notion of having a "language spec" is just not that useful when you have a dominant open source implementation.
08:08:12 <Taneb> cocreature: fair enough
08:08:13 <hyperisco> EvanR, seems to me they'd be inclined to take over the whole compilation process to lock people in to their ecosystem
08:08:16 <ertes-w> writing a C compiler not so much
08:08:21 <EvanR> compare and contrast commercial C++... also a serious investment
08:08:46 <EvanR> hyperisco: thats what it was like yes
08:10:08 <noan> is there a cleaner syntax for type constructors than to use parens?
08:10:10 <hyperisco> what you need is a reason for a company to develop a new Haskell compiler which supports unique features
08:10:20 <hyperisco> such as a particular platform, or new language features
08:10:46 <tdammers> or even just different performance characteristics
08:10:52 <EvanR> or a haskell like language which is an improvement over the language
08:11:04 <EvanR> or for a different purpose
08:11:05 <tdammers> e.g., one might want a Haskell compiler that is more suitable for low-latency applications
08:11:10 <EvanR> which exists!
08:11:10 <hyperisco> Haskell++
08:11:18 <tdammers> EvanR: several, actually
08:12:10 <merijn> hyperisco: That already exists
08:12:12 <EvanR> standards are something you can do after the fact, to formalize good ideas that different implementations have agreed on
08:12:19 <hyperisco> but then it is a bit of a chicken and egg… it would be substantial cost to make a new Haskell compiler just for an internal project… i.e. why not use another language
08:12:26 <merijn> hyperisco: It's called Mu and not being open sourced because lawyers in big corporations are fraidy cats
08:12:26 <EvanR> maybe that was the case with haskell at some point
08:12:56 <tdammers> hyperisco: in practice, people tend to either invent a new language, or pay someone to hack what they need into GHC
08:13:06 <hyperisco> and who is vying to buy a compiler, or support?
08:13:28 <EvanR> corporate clients
08:14:32 <hyperisco> I am just saying there is a barrier to entry… it would be easy to start using Haskell for X if there was a tool for it already
08:14:57 <hyperisco> but you can't budget developing the tool into the X project, so you use something else
08:15:02 <hyperisco> and so the status quo perpetuates
08:17:00 <hyperisco> for example, I can now use FP for web programming because PureScript exists, but I couldn't have reasonably developed PureScript myself before doing a web project
08:17:26 <merijn> hyperisco: You could've
08:17:33 <merijn> hyperisco: How do you think Clojure got started?
08:17:35 <merijn> Or ghcjs?
08:18:11 <tdammers> hyperisco: you don't have to go from zero to production-ready industry-strength compiler right away
08:18:22 <hyperisco> no I could not have… obviously someone figured how to make it work
08:18:30 <hyperisco> I said there was a barrier, not that it was impassable
08:18:32 <tdammers> you could also take one of the currently somewhat experimental compilers and throw enough money at it to make it a feasible contender
08:18:44 <merijn> tdammers: Or enough time
08:19:03 <tdammers> merijn: same thing, for the purpose of this discussion
08:19:06 <hyperisco> now that the ball is rolling it will pick up developers and attention
08:19:41 <hyperisco> and yes ghcjs is okay too, and now with WSL possibly more usable for me
08:19:58 <noan> does ghcjs still have pretty poor performance?
08:20:18 <hyperisco> back when I had to download a VM just to have the thing running… it was coming along but not easy yet
08:20:20 <noan> I was thinking about functional ways to do frontend and it seemed to be too slow really to be an option for me
08:20:55 <bontaq``> I've heard v good things about idris' JS compiler... but then I don't think there's even an html library for it yet
08:21:18 <bontaq``> ReasonML is picking up steam though, I think that or elm is prob best bet if you wanted to go full functional frontend
08:21:29 <EvanR> i tried using idris JS
08:21:32 <bontaq``> (plus reason isn't gonna be dropped, since facebook supports it)
08:22:24 <EvanR> there is very little support code written already, you will be learning the elab reflector in order to generate js instances for your types
08:24:04 <ertes-w> the reason to use GHCJS is to have GHC-haskell and GHC's RTS in JS
08:24:25 <ertes-w> the latter in particular…  use concurrent threads instead of callback-based event handling
08:25:34 <ertes-w> the value of that is so large that i would definitely go through the trouble of making GHCJS work rather than resorting to something like PureScript
08:26:32 <cocreature> does purescript not have threading?
08:27:19 <hyperisco> cocreature, whatever the JavaScript runtime supports
08:27:47 <cocreature> hyperisco: well you can build it on top of the js runtime like ghcjs does
08:28:07 <hyperisco> there are such thing as web workers, and you can use those if you want
08:28:32 <cocreature> web workers are quite different from ghcjs lightweight threads
08:29:04 <ski> noan : how do you mean ?
08:29:47 <noan> ski, I was misphrasing, but I meant in cases where I need to do something like f (Just a)
08:29:53 <ertes-w> cocreature: you could certainly build what amounts to python's coroutines on top of purescript, but i remember very well what a huge pain it was to use…  there is a lot of value in having concurrency built into the language and the base library
08:30:04 <hyperisco> well, I don't know what would be equivalent, but every js runtime should have a non-preemptive scheduler for supporting asynchrony
08:30:12 <noan> is there an alternative to the (). I attempted f $ Just a, but it was unsuccessful. I forget the error I got though
08:30:34 <ski> noan : hm, `Just' is a data constructor, not a type constructor
08:30:34 <cocreature> ertes-w: right I completely agree. I was just trying to figure out if purescript already has concurrency built in but it seems like the answer is no :)
08:30:50 <noan> ski, sorry, failure of terminology, just starting to learn now
08:30:55 <hyperisco> what does "built in" mean?
08:30:55 <noan> I'm used to scala :(
08:31:11 <ertes-w> cocreature: a quick web search reveals that people seem to have built coroutine libraries already
08:31:13 <hyperisco> to me, "built in" would mean it is part of the language semantics
08:31:17 <cocreature> hyperisco: forkIO is a GHC primitive that you can’t easily implement within a library
08:31:34 <ski> noan : yea, np, that's why i remarked on the standard terminology, so that you now know how people use the terms
08:31:39 <ski> noan : usually, `f $ Just a' should work .. however, i prefer it without `$'
08:31:47 <hyperisco> okay, well, there are libraries which bind to various JavaScript things
08:31:48 <ertes-w> but yeah, those are still libraries
08:31:58 <hyperisco> there is a library for asynchronous effects… see Aff
08:32:09 <ertes-w> hyperisco: it's not the same thing
08:32:23 <cocreature> that’s probably still quite different from being able to run an arbitrary IO action in a different thread
08:32:38 * ski thinks brackets are not to be afraid of
08:32:45 <hyperisco> I don't know… what is unique about that?
08:33:02 <hyperisco> you are talking about application threads, not OS threads, right?
08:33:05 <ertes-w> hyperisco: things like forkIO, IO exceptions and general I/O, timing and locking are all connected…  it's not a matter of "having threads", it's a matter of having a whole language and base library built on them
08:33:31 <hyperisco> okay, well, it sounds like you're talking about Aff
08:34:06 <EvanR> for one thing $ can't always be used, it only works in some cases
08:34:09 <ertes-w> hyperisco: if you use I/O in haskell, the RTS will translate your blocking calls into event-based multiplexing using whatever the compiler target supports (epoll, JS events, etc.)
08:34:16 <EvanR> ( ) always works
08:34:22 <hyperisco> which schedules multiple "fibers", handles exceptions, supports arbitrary effects
08:35:48 <hyperisco> ertes-w, okay, and the only difference in PureScript is that you have to explicitly lift an action to Aff, if it is not already, for it to be non-blocking (as opposed to Eff, which is either blocking or you don't get a result)
08:35:51 <cocreature> hm Aff does indeed look quite promising
08:36:31 <`Guest00000> is the distinction eager/lazy irrelevant in a language without _|_ ?
08:37:25 <EvanR> there is still a performance difference
08:37:40 <ertes-w> hyperisco: let's say (delay 10) is an Eff effect that suspends the action for 10 seconds, and i lift (delay 10) to Aff…  will other threads keep running?  or will everything be suspended for 10 seconds?
08:37:42 <`Guest00000> irrelevant :)
08:37:58 <EvanR> an unfold followed by a fold is inefficient when you do it like ruby and build a huge structure in memory first
08:38:00 <ski> are there other cases where `$' won't work, apart from higher-rank ?
08:38:01 <EvanR> then consume it
08:38:08 <cocreature> `Guest00000: it also depends on what you consider _|_, [1..] is not bottom in Haskell
08:38:17 <hyperisco> ertes-w, it doesn't necessarily block in Eff either, depending on how you implemented it
08:38:28 <`Guest00000> wow, that's right
08:38:33 <ertes-w> hyperisco: (delay 10) is supposed to block
08:38:47 <ski> the difference between termination and non-termination can be seen as an extreme case of a "performance difference"
08:39:44 <Taneb> `Guest00000: the short answer is "no"
08:40:04 <hyperisco> ertes-w, I brought up web workers because afaik that is the only way to have parallelism
08:40:07 <`Guest00000> short answers are often too short
08:40:20 <ertes-w> hyperisco: i'm not talking about parallelism, i'm talking about concurrency
08:40:29 <ertes-w> web workers are irrelevant
08:40:40 <hyperisco> ertes-w, well then what do you mean by delay for 10 seconds? how do you implement that? it matters
08:40:52 <ertes-w> hyperisco: and that's exactly the point
08:40:53 <EvanR> concurrency, 10000 things happening at once... parallelism... 4 things happening at once because you have 4 cores :)
08:41:04 <EvanR> concurrency is better
08:41:14 <hyperisco> ertes-w, okay, well, it is a weird point
08:41:29 <Taneb> EvanR: interleaving of operations is a valid implementation of concurrency
08:41:36 <Taneb> EvanR: it's a different tool for a different job
08:41:43 <ertes-w> hyperisco: it matters whether i use an Eff-based 'delay' or an Aff-based 'delay'…  that's why i compared it to python coroutines, because judging by the description, Aff is basically that
08:41:43 <hyperisco> if you run a hot loop checking the current time, and because JavaScript is single threaded, this will delay everything by 10 seconds
08:41:56 <ertes-w> hyperisco: in haskell everything is Aff
08:42:05 <hyperisco> if you use setTimeout for 10 seconds, everything else will keep running, but this is also inherently not blocking
08:42:07 <EvanR> i hate busy looping
08:42:17 <EvanR> even on micro controllers
08:42:27 <hyperisco> ertes-w, no, the distinction in delay has nothing to do with Eff or Aff
08:42:34 <hyperisco> ertes-w, it has everything to do with how you implement the delay
08:43:08 <ggVGc> Eff Aff Eff Aff!
08:43:10 <ertes-w> hyperisco: Aff is not a library in haskell, it's built-in and called IO…  even if you just use putStrLn or threadDelay you're already using a concurrency-aware I/O system underneath that translates everything into fd-based multiplexing (native) or event-based waiting (JS)
08:43:51 <hyperisco> okay… I really don't get what you're saying and I have to get back to work
08:44:03 <ertes-w> hyperisco: i'm sorry, i can't make it any clearer
08:44:17 <EvanR> is how it's implemented in js important
08:44:26 <monochrom> Examples and counterexamples will be it clear. But programmers hate empirical evidence.
08:44:27 <ertes-w> hyperisco: just try to work with python's coroutines, if you want to see what i mean…  or perhaps Aff, because i believe they are the same thing
08:44:47 <hyperisco> if you have a single threaded runtime and non-preemptive scheduling, how can you be surprised that running a hot loop to delay 10 seconds delays everything
08:45:07 <monochrom> Those who are great at empirical evidence have already gone into biochem and made more money.
08:45:07 <hyperisco> it would be no different if you used ghcjs… it is how the js runtime works
08:45:20 <ertes-w> hyperisco: why would 'delay' be a hot loop?
08:45:24 <ertes-w> i never said that
08:45:27 <hyperisco> because you said it blocks
08:45:34 <ertes-w> hyperisco: that's not the same thing
08:45:44 <hyperisco> okay, then you use setTimeout?
08:46:06 <ertes-w> no, you use a semantically blocking 'delay', and the RTS *translates* that into setTimeout
08:46:07 <hyperisco> maybe you should define blocking for me
08:46:22 <hyperisco> okay then, sure, you can do that with Aff no problem
08:46:36 <EvanR> i have a question... lets say i want to implement a pure function such that when accessed at a particular point in the domain, it uses some hidden state in such a way that purity is still maintained. i am finding it tricky because it may in general be accessed from multiple threads or from itself recursively...
08:46:45 <hyperisco> if you use setTimeout in Eff it doesn't block
08:46:47 <EvanR> am i missing anything that will help
08:47:03 <ertes-w> hyperisco: 'delay' is an Eff effect, so no, you can't simply use it with Aff
08:47:11 <ertes-w> you have to reinvent 'delay' for Aff
08:47:27 <monochrom> Perhaps you also need to lock the hidden state, or STM it, or use a lock-free concurrent data structure for it.
08:47:55 <monochrom> What is "access"? Do you write?
08:48:02 <EvanR> no, its function application
08:48:02 <hyperisco> ertes-w, okay I don't know what you are talking about again
08:48:26 <hyperisco> ertes-w, what is the specific delay function you are referring to?
08:48:42 <ertes-w> hyperisco: you have a language and base library based on Eff, and Eff does not support concurrency…  is that correct?
08:48:44 <EvanR> i though to lock the hidden state, but now if f 1 looks at f 0, deadlock
08:49:41 <hyperisco> ertes-w, what counts as support to you? you can use asynchronous actions, but Eff isn't going to wait for the result
08:50:02 <hyperisco> to wait for results, you'd use Aff
08:50:40 <hyperisco> the impedance is probably because I am used to how PureScript does this and not familiar with how Haskell does it
08:50:51 <hyperisco> never used concurrency in Haskell before
08:51:00 <dminuoso> Ive been pondering about remaking my expression evaluator. Right now I have some data type http://lpaste.net/362920 but it's extremely lacking because I dont know how to both gain an actual Algebra from this, while somehow allowing for variable expressions of an arbitrary type.
08:51:03 <EvanR> o_O
08:51:09 <EvanR> one of haskells best features
08:51:10 <ertes-w> hyperisco: it means that you can blockingly wait for stuff to happen from multiple threads
08:51:37 <hyperisco> multiple? hm
08:53:27 <EvanR> you can barely write an IO program in haskell without using threads somewhere
08:53:27 <ertes-w> hyperisco: one thread can wait for data from a network connection, another can wait for a delay to expire, etc…  all at the same time, and there is a scheduler that will translates all of those requests into appropriate low-level calls (be it event callbacks in JS or native epoll)
08:53:46 <ertes-w> hyperisco: in particular you don't need to concern yourself with callbacks at all…  you just fork threads and block them
08:53:53 <hyperisco> ertes-w, I have not done this with Aff yet but reading the docs, yes, this is doable
08:55:43 <ertes-w> hyperisco: and i absolutely believe that…  so now my point is that you have Eff *and* Aff, and they don't work together…  if anything in Eff blocks, you can't use it, because it will block the world, not just its Aff thread…  Eff actions don't know anything about Aff threads
08:55:46 <hyperisco> ertes-w, I am not sure what the verbosity difference is. With Aff you would forkAff, which then gives you back the fiber for the running Aff
08:56:38 <hyperisco> okay… I am not sure what the misunderstanding is here
08:56:58 <ertes-w> hyperisco: perhaps you should just give haskell concurrency a shot =)
08:57:27 <monochrom> Or you Aff.
08:57:33 <hyperisco> something which blocks in Eff trivially lifts to Aff
08:57:54 <hyperisco> and there is no mechanism by which Aff could make it not block, even if you rewrote it all for Aff
08:58:06 <hyperisco> this is just not how things work in the js runtime
08:58:13 <piark_> hello
08:58:22 <hyperisco> there is no pre emptive scheduling, there is only one thread…
08:58:35 <cocreature> discussions where either side is not familiar with what the other side is talking about tend to be particularly productive :)
08:58:45 <hyperisco> uh huh
08:59:55 <hyperisco> I also feel like we're going between block in a semantic sense and block as in blocks all the CPU time during execution
09:00:12 <ertes-w> hyperisco: i'm not talking about lifting being impossible…  if you lift a blocking Eff action, it will block more than just its Aff fiber
09:00:38 <hyperisco> you can have two Aff fibers, but while one is running the other is not
09:00:57 <hyperisco> so if one Aff fiber is doing some long running computation, the other Aff fiber just has to wait
09:01:12 <cocreature> hyperisco: let me try to rephrase what I think ertes-w is saying: if you take the "delay" operation from purescripts standard library and you use liftAff or whatever that function is called to lift it into Aff, will calling that lifted function block other threads?
09:01:18 <ertes-w> hyperisco: exactly…  you simply can't use blocking…  you would have to write an Aff version of the effect that hands control back to Aff's scheduler
09:01:36 <hyperisco> yes you would, ertes-w
09:02:04 <hyperisco> or, you would look into web workers
09:03:05 <hyperisco> cocreature, if it is implemented using setTimeout, then no
09:03:14 <cocreature> hyperisco: how is it implemented?
09:03:22 <hyperisco> if it is implemented as a hot loop checking the current time, then yes
09:03:39 <ertes-w> hyperisco: and that's my point…  python has a similar system called asyncio i had the distinct displeasure of using, and it basically has the same problem:  if you use asyncio, you've locked yourself out of most python libraries, including the large portions of the standard library
09:03:43 <hyperisco> well I don't know what delay function we're talking about
09:04:01 <cocreature> so purescript has no "wait/delay/…" function in the standard librarys
09:04:08 <cocreature> s/librarys/library?/
09:04:25 <hyperisco> I am not sure what a standard library is in PureScript tbh
09:04:34 <ertes-w> i think JS doesn't even really have a way of blocking without doing anything
09:04:39 <hyperisco> I think there is a GitHub org with a bunch of repos in it, and maybe those are considered the standard
09:04:55 <ertes-w> because it's so heavily built on callbacks
09:05:03 <ertes-w> well, it has 'alert'
09:05:24 <ertes-w> but even if you don't use anything like that you still have the same problem:  you have to use Aff-specific libraries
09:05:52 <cocreature> ertes-w: that’s why I’m not sure your comparison to python is actually applicable here. the problems in python come from the fact that the builtin primitives do actually block. so far I haven’t seen a purescript primitive for which this is actually true
09:06:01 <hyperisco> so the distinction here sounds more like that Haskell chose to have one IO to rule them all
09:06:24 <hyperisco> whereas in other languages you have some options, and they do not necessarily play nice together
09:07:52 <hyperisco> I wouldn't argue with the effect this has on splintering the ecosystem… noticed the same thing happened to D, for example, with its choice of garbage collection
09:08:02 <ertes-w> cocreature: well, that relaxes the problem, but doesn't eliminate it:  instead of not being able to use a library you have to bind it to Aff's scheduler
09:08:06 <Psybur> hyperisco, what are some examples of "multiple IOs"?
09:09:05 <Psybur> Maybe you explained and I havent scolled up enough :D?
09:09:20 <ertes-w> haskell has a system that basically requires programmers to make that binding from the very start…  you simply don't have the option to write non-concurrent code in the first place
09:09:51 <hyperisco> Psybur, imagine you wrote a different runtime with C and then made bindings using Haskell's FFI
09:10:10 <ertes-w> you want to use Handle IO with a custom resource?  you're going to have to tell the RTS how it can translate blocking actions into events
09:10:31 <hyperisco> Psybur, you're still using IO, because that is what main uses, but you can then call into this other runtime system, which has its own way of doing stuff
09:11:09 <hyperisco> Psybur, so, somewhat like that, in PureScript you can make whatever bindings you want to JavaScript, and main is Eff, but you can use your bindings to do whatever else you want… and in that sense you have many ways of doing scheduling and effects and so on
09:12:05 <ertes-w> hyperisco: you could say that Aff works very similarly to FreeT…  it's a coroutine monad, and don't get me wrong, Aff and FreeT are great…  i *want* them, but i want them in the base library at the core =)
09:12:26 <hyperisco> as ertes-w says, having multiple (popular) ways to do things can cause fracturing in the ecosystem of libraries
09:12:51 <ertes-w> you still have the option to go single-threaded in haskell:  just don't fork
09:12:59 <ertes-w> you're not really losing anything by having a concurrent IO
09:14:21 <hyperisco> ertes-w, I get the intuition that PureScript leans heavily on its JavaScript underpinning
09:15:19 <hyperisco> it has an opinion on functional programming style but not runtimes, to which it defers to however JavaScript does things
09:16:16 <hyperisco> in fact I read some old comments about the FFI, for example, being too friendly with JavaScript
09:17:33 <hyperisco> but at the same time there is the benefit that you're reasonably close to JavaScript… strict semantics help… and that gives its own ease of use
09:17:55 <hyperisco> figure that 90% of code is going to come from JavaScript libraries, not PureScript libraries, and that can make sense
09:30:56 <EvanR> hyperisco: skeptical that implementing concurrency with webworkers is "however js does things"
09:32:11 <ertes-w> hyperisco: luckily JS's design works as a compiler target…  personally i prefer the built-in nature of haskell threads and the way they interact…  for example killing a thread is a matter of throwing an exception at it
09:32:33 <ertes-w> therefore given a choice, i'll almost always go with GHCJS
09:33:44 <EvanR> poor function implemented with hidden state
09:33:45 <ertes-w> EvanR: i'm pretty sure Aff doesn't use web workers
09:34:11 <ertes-w> or if it does, it's just a way to facilitate parallelism, not concurrency
09:34:14 <EvanR> its crazy how such a simple interface is so tricky
09:46:31 <hyperisco> ertes-w, well at least we agree the answer isn't to use JavaScript XD
09:51:12 <hyperisco> it is tough getting by without the tools that we have… being able to write most a program like it wasn't concurrent, for example, because it is the same syntax
09:51:28 <hyperisco> or asynchronous rather
09:51:51 <hyperisco> and then having tools for dealing with concurrency, which JavaScript really doesn't have
09:52:23 <hyperisco> maybe there are some js libs I don't know of, but for such a highly concurrent language (or at least in its use environment), you'd think it would do better natively
09:52:28 <EvanR> assembly language
09:52:31 <hyperisco> though last I heard they are adding async/await
09:52:53 <EvanR> not meant to be used directly by humans
09:53:00 <hyperisco> so, that's something, for those annoyed by the Promisify noise
09:54:13 <ertes-w> hyperisco: implementing concurrency in plain JS wouldn't be such a pain, if it had TCO
09:54:29 <EvanR> ... why
09:54:56 <ertes-w> because concurrency can easily be built on top of CPS
09:55:37 <hyperisco> I was calling that asynchrony because it is still sequential, just you have to wait for results
09:55:47 <dminuoso> ertes-w: TCO is the one thing that keeps every major browser from ES6 conformance even.. =)
09:55:51 <dminuoso> It's kind of funny.
09:56:08 <hyperisco> whereas by concurrency I figured we meant multiple threads/fibers/whatevers running "at the same time", or in other words, not sequentially
09:56:54 <hyperisco> JavaScript's sophistication in that department is addEventListener and removeEventListener
09:56:57 <ertes-w> dminuoso: is TCO part of ES6?
09:57:13 <dminuoso> ertes-w: Yes.
09:57:42 <dminuoso> ertes-w: Safari (both desktop and mobile) is the only one that implements TCO. The entire rest has 0 support for it.
09:57:54 <ertes-w> i was going to say: i can't believe TCO isn't forced on language implementors by the spec in 2018
09:57:55 <ertes-w> =)
09:57:58 <dminuoso> http://www.ecma-international.org/ecma-262/6.0/#sec-tail-position-calls
09:58:08 <hyperisco> just go bounce bounce bounce on the trampoline
09:58:09 <ertes-w> seriously, people need to be forced to implement TCO
09:58:40 <dminuoso> ertes-w: Guido doesn't do it because.. well I guess it makes producing sensible backtraces harder..
09:58:44 <hyperisco> if you have TCO then aren't you implicitly modifying the call stack? my errors!
09:59:08 <ski> s/TCO/"proper tail recursion"/
09:59:33 <EvanR> there isnt a call stack
09:59:50 <hyperisco> well it either tracks the call stack or doesn't, and I would think your optimisation would require it not to
10:00:09 <hyperisco> it is a little something you give up in way of debugging
10:00:25 <noan> hyperisco, a properly optimised tail call does not have its own stack frame
10:00:26 <ski> ((a) it's not an optimization if it's a language requirement; (b) the point isn't about how to implement it, but about the space requirements of being able to have an unbounded amount of active tail calls)
10:00:30 <dminuoso> hyperisco: The rationale in Ruby is "disabled by fault in order to not confuse beginners when their stacktrace looks weird", but you can turn it on easily.
10:00:37 <noan> once compiled it unrolls the tail calls into a loop
10:00:42 <noan> a simple jump, basically
10:00:43 <hyperisco> but, call stacks are an ancient tool anyways… like debug lines… we can do better
10:00:46 <noan> no stay frame involved.
10:00:46 <ertes-w> dminuoso: i would believe that explanation from any other person
10:02:20 <dminuoso> ertes-w: There's a really lengthy and tiring article on anti-intellectualism http://neopythonic.blogspot.de/2009/04/tail-recursion-elimination.html
10:02:41 <dminuoso> ertes-w: Essentially the rationale is: "Debugging is more important than language features"
10:02:57 <EvanR> https://xkcd.com/1270/
10:03:09 <hyperisco> when you start learning a PL, know that they've made concessions to account for your ineptitude
10:03:11 <ertes-w> dminuoso: in any case i believe you don't need perfect stack traces with FP…  it would be enough to show the first few calls and the last few calls, or perhaps even mark some functions as "stack traces from here to depth n"
10:03:27 <ertes-w> much like cost centres are optional
10:03:34 <hyperisco> EvanR, I like the alt text too
10:03:51 <hyperisco> in fact I think I have to explain FP that way every time now
10:03:51 <ski> (e.g. iirc MIT Scheme keeps the last 100 calls around for debugging purposes, while still having "proper tail recursion". otoh Chicken Scheme converts everything to CPS, treating the C stack as a heap, never returning on it, only GCing it when it's full. still "proper tail recursion", without treating returns as "just a jump")
10:05:20 <EvanR> you could have a debug runtime for development, then once you prove it cant fail, use the faster undebuggable product runtime
10:05:33 <EvanR> but have TCO work in both cases, somehow
10:05:42 <hyperisco> well, it isn't always speed, it is also about not crashing, i.e. the infamous stack overflow
10:05:50 <dminuoso> Ultimately I dont think its useful to know about the depth of a stack inside a tail recursing function any way..
10:06:14 <EvanR> yes TCO is not an optimization
10:06:15 <dminuoso> I mean its not like you gain much useful knowledge from "hey this has recursed 20 times", and its probably not hard to gain that knowledge through different ways.
10:06:18 <ski> it's useful to know that you can have an unbounded number of active tail calls, in bounded space
10:06:21 <EvanR> its about whether the code works at all
10:06:42 <hyperisco> dminuoso, actually yes there can be great knowledge
10:06:50 <dminuoso> hyperisco: Such as?
10:06:56 <hyperisco> dminuoso, because you can, for example, also have your debugger take you back through every state in the stack
10:07:20 <ski> (also, debuggers typically don't record how many times a `while' loop has spinned around, for you to look at the backtrace thereof)
10:07:23 <hyperisco> also, it isn't necessarily the self-recursive function, but also what happened in the stack before then
10:07:50 <hyperisco> but, I don't think it is worth making too many concessions for the sake of keeping stack traces around
10:08:03 <hyperisco> maybe figure out a different debugging method
10:08:19 * ski . o O ( declarative debugging )
10:08:42 <hyperisco> in fact it is probably backwards to start with "how do you debug it"
10:08:53 <cocreature> how do "Set Int" and "IntSet" compare in terms of memory usage?
10:10:50 <dminuoso> hyperisco: My beef is just that the specific argument from Guido himself is that "Recursion is not necessary to solve problems, keeping programs easily debuggable is more important" has this way of removing making writing programs easily away, creating the need to have easily debuggable programs in the first place.
10:10:53 <hyperisco> backwards because instead of ending up with the most debuggable language, it would be better to end up with a language where the least number of bugs were made
10:11:10 <dminuoso> hyperisco: Exactly my thought.
10:13:55 <hyperisco> what Guido is saying sounds like half of one and two quarters of the other
10:14:33 <hyperisco> calling a function is an entry on the call stack, whereas an iteration of a loop does not… so that opinion is merely that loop iterations are not worth having on your call stack
10:16:55 <hyperisco> I never had the thought cross my mind to structure my program such that functions corresponded to useful call stack entries
10:17:08 <hyperisco> that sounds kind of… insane
10:19:29 <EvanR> here is my mad science way to utilize hidden state to implement a pure function
10:20:20 <hyperisco> does it involve dry ice and food colouring?
10:21:01 <EvanR> theres an mvar which contains Left state or Right state. when you access the function, if its Right, then immediately put Left oldState back. then compute the answer, possibly update the state by writing Right newState
10:21:26 <EvanR> if its Left, then put Left oldState back and compute the answer a slower way, dont update state
10:21:42 <EvanR> now theres no deadlocking (?)
10:22:46 <c_wraith> there's no deadlocking with unsafePerformIO anyway... it grabs a mutex.
10:23:17 <EvanR> there would be if you take the state, do something (which may involve recursively calling this function), then put the state back before returning the answer
10:23:24 <c_wraith> well, OK, there can be deadlocking if you get multiple unsafePerformIO calls depending on each other.
10:23:32 <EvanR> right
10:25:56 <EvanR> though i have no idea if this is all wrong, because the computation for new state is lazy
10:26:20 <EvanR> you put a thunk back in the mvar, the recursion may not have even happened yet...
11:08:44 <hyperisco> how is cli depending on both mtl and transformers
11:08:55 <hyperisco> aren't those differently opinionated packages?
11:09:10 <hyperisco> is cli the popular option for making cli progs?
11:09:49 <dminuoso> Interesting.. so GHC has the ability to be angry at users: https://i.imgur.com/dWWHCzs.png
11:10:09 <hyperisco> seems to explode on stack, so I guess not
11:10:18 <cocreature> hyperisco: mtl wraps transformers
11:10:34 <hyperisco> terminfo isn't building on stack, a dep of cli
11:10:36 <cocreature> hyperisco: mtl only provides the typeclasses and instances for the transformer types defined in transformers
11:11:52 <hyperisco> oh maybe mtl does the class thing then, which is arguable
11:12:54 <hyperisco> because terminfo is not xplatform… requires curses… mkay
11:13:29 <hyperisco> seems insane for just doing basic parsing of CLI args and dispatching
11:14:28 <hc> dminuoso: haha
11:14:39 <hyperisco> optparse maybe?
11:14:58 <cocreature> hyperisco: afaict "cli" does things like displaying progress bars and colors which isn’t easily portable
11:15:07 <hyperisco> but it sounded cool
11:15:08 <cocreature> optparse-applicative is great
11:15:17 <hyperisco> that should be doable in ansi…
11:15:36 <hyperisco> I realise not all terminals suppose ansi but that is their problem
11:16:04 <hyperisco> also that there are different opinions on how to interpret certain commands
11:16:17 <EvanR> while we are complaining about 70s tech, can we have sane replacement for terminals and termemus
11:16:25 <hyperisco> lol
11:16:27 <EvanR> no? ok didnt think so
11:17:27 <hyperisco> I think there is some intelligence in the unix idea of string plumbing
11:17:38 <Welkin> you mean 1960's tech, like the mouse, the GUI, and networked computing?
11:17:39 <EvanR> uhm...
11:17:51 <hc> what would be a sane replacement for a terminal?
11:18:02 <Welkin> hc: brain-computer interface
11:18:03 <dminuoso> EvanR: I like sending undocumented VT100 escape sequences to control making things pretty.
11:18:08 <hc> Welkin: oh, that
11:18:13 <dstolfa> can we start by implementing the ideas from the 70s first?
11:18:23 <dstolfa> unix is a step backwards
11:18:25 <hyperisco> well, what else is the CLI about than to do string plumbing
11:18:25 <dstolfa> not forward
11:18:32 <Welkin> everything is strings o.o
11:18:34 <EvanR> :|
11:18:35 <Welkin> the web is strings
11:18:38 <hc> has someone ported turbo vision to haskell? ;)
11:19:35 <hyperisco> the intelligence is that strings are minimally structured, while being more readable than binary, and so are easily used for everything
11:19:46 <EvanR> :|
11:19:46 <hyperisco> whether the right strings go to the right places is someone else's problem
11:20:02 <EvanR> go back in your time machine
11:20:04 <ddellacosta> I see the word "witness" used a lot in discussions around types--is its meaning similar to "prove?"
11:20:04 <maerwald> separation of concerns xD
11:20:27 <ski> ddellacosta : yes. in a constructive sense
11:20:28 <hyperisco> ddellacosta, "a witness" is another name for "a proof"
11:20:39 <ddellacosta> ski, hyperisco: thanks a lot!
11:21:05 <ddellacosta> ski: is the origin intuitionist/constructive logic?
11:21:16 <hyperisco> because rule 1 in abstract mathematics is to invent new terminology so as to not dirty yourself with other ideas
11:21:30 <ddellacosta> hyperisco: lol
11:21:37 <EvanR> well, you will see proofs containing axiomatic terms like LEM or axiom of choice... but i dont think they have the spirit of a witness
11:21:41 <Welkin> hyperisco: like monad?
11:21:48 <ski> a constructive proof of `exists x :: T. P x' consists of a value `v' of type `T', and a proof that `P v' holds. we sometimes say that `v' is a witness, here
11:22:03 <Welkin> https://en.wikipedia.org/wiki/Monad_(philosophy)
11:22:04 <Welkin> :D
11:22:24 <hyperisco> lol
11:22:34 <ddellacosta> is there a godwin's law for programming discussions, only replace "nazi" with "monad?"
11:23:00 <hyperisco> no but there should be, because it tends to be stopping point of useful discussion
11:23:06 <ski> LEM has a constructive interpretation in linear logic .. if you use the multiplicative disjunction to formulate it, i.e.
11:23:07 <ddellacosta> shoot I think I just inadvertently Godwin'ed this convo
11:23:10 <EvanR> https://memegenerator.net/img/instances/80691927/monads.jpg
11:23:29 <ski> one can prove LEM, with continuations
11:23:50 <EvanR> i need to get more into linear logic
11:24:05 <ski> LEM in linear logic is basically `id'
11:24:43 <ddellacosta> ski: btw thanks for your comment above, re: explaining how 'v' is a witness in that constructive proof example
11:24:46 <ddellacosta> that helped a lot
11:25:04 <ski> to prove a multiplicative disjunction, you don't pick an alternative. instead you just wait for your opponent to dispute (disprove) one of the alternatives. using that information, you then go on to prove the other alternative
11:25:43 <ddellacosta> ski: huh...is that some way to get around the law of excluded middle?
11:25:45 <ski> so, it's a lazy way of proving disjunctions, so to speak, waiting for your opponent to do more of the dirty work, before you get arsed to do anything
11:25:55 <hyperisco> what if your opponent is waiting on you? how does linear logic prevent or recover from deadlocks?
11:26:07 <ddellacosta> (nevermind, I think I'm off on a tangent)
11:26:39 <ski> hyperisco : your opponent waiting on you would be the additive diusjunction (think `Either'), not the multiplicative one .. different things
11:26:52 <ski> there are also two conjunctions
11:27:20 <ski> one of them is "both `A' and `B'", you prove both parts, using a single common set of resources
11:27:29 <ski> (that's the multiplicative conjunction)
11:28:09 <ski> the additive conjunction is "`A' with `B'", aka "external choice" (the additive *dis*junction is "internal choice"), you're offering your opponent the choice of which alternative you'll prove
11:28:36 <ski> that way, you can "reuse" the same resources when proving both, since actually only one of them will happen
11:29:00 <hyperisco> clever trevor
11:29:00 <ski> if you're ordering eggs and bacon, that's multiplicative conjunction, aka "tensor"
11:29:24 <hyperisco> well I'm vegetarian, so I'll just take the eggs
11:29:55 <Welkin> how isthat vegetarian?
11:30:00 <EvanR> uhg
11:30:03 <ski> if the cafe offers "tea or coffee" with the cake, then probably they're offering you the choice of either one, so you get tea "with" coffee, additive conjunction
11:30:04 <Welkin> hyperisco: would you eat balut?
11:30:22 <hyperisco> Welkin, that depends on what balut is
11:30:37 <Welkin> hyperisco: fertilized duck eggs (with a fetus inside)
11:30:49 <EvanR> tea or coffee would be conjunction?
11:30:55 <EvanR> i.e. 'with' ? confused
11:31:14 <ski> if they say "on tuesdays, we either serve soup or salad", then they're offering you one of the alternatives, but you'll have to see which you can get on tuesday, not your choice
11:31:27 <hyperisco> Welkin, ah, I know of that. No, but regardless of any other reason I wouldn't because it sounds disgusting to me.
11:32:23 <hyperisco> so… additive disjunction?
11:32:33 <ski> EvanR : it seems to me that "or" is sometimes used as "additive disjunction", and sometimes as "additive conjunction", in english. the difference being who gets to make the choice
11:32:48 <hyperisco> what is multiplicative disjunction?
11:33:00 <ski> an additive conjunction is like a lazy pair. also you only get to grab one of the parts
11:33:17 <ski> multiplicative disjunction is unfortunately harder to explain
11:33:18 <EvanR> linear logic rules might be an easier way to see the difference between these 4 connectives
11:33:33 <hyperisco> I guess so, because there doesn't seem to be much room left in these cafe examples, though they are clear
11:33:51 <ski> multiplicative disjunction is like playing two games in parallel, letting what happens in one game inform your play in the other, and vice versa
11:34:08 <EvanR> that just made my brain explode
11:34:13 <ski> and there's also linear implication, `-o'
11:34:44 <ski> e.g. if `(*)' is "tensor", the multiplicative conjunction, then you can't prove `dollar -o dollar (*) dollar', can't duplicate resources
11:34:48 <hyperisco> hrm, not much intuition there for me
11:35:10 <ski> but if `&' is additive conjunction, "with", then you *can* prove `dollar -o dollar & dollar'
11:35:28 <hyperisco> because one dollar in, one dollar out
11:35:43 <hyperisco> no free lunches in linear logic
11:35:52 <EvanR> because you can choose left or right dollar but not both?
11:35:52 <ski> `dollar -o tea & coffee' could be one of the transactions that're offered/allowed at the cafe
11:35:56 <ski> yep
11:36:18 <ski> then there's the "exponentials", "of course" `!', and "why not" `?'
11:36:32 <ski> `! A' means that you're explicitly allowed to reuse `A' as many times as you like
11:36:49 <ski> so, probably the rule would actually be `!(dollar -o tea & coffee)'
11:37:26 <hyperisco> it isn't a suffix operator? shame
11:37:29 <ski> `? pizza' you mean that you're required to consume as many pizzas as your opponent / the environment wants to
11:37:36 <ski> s/you mean/would mean/
11:38:16 <ski> there are also four neutral elements, corresponding to additive/multiplicative disjunction/conjunction
11:38:43 <EvanR> is this full linear logic
11:38:47 <ski> (fwiw `!' is a comonad, and `?' a monad)
11:38:49 <ski> yep
11:38:49 <EvanR> or a subset
11:38:54 <hyperisco> neutrals… how do those differ from identities?
11:39:25 <ski> intuitionistic linear logic throws our multiplicative disjunction, its corresponding neutral element, and also the "why not" modality
11:39:34 * hyperisco wishes to program in the "why not" monad one day
11:39:48 <EvanR> i dont get why not
11:39:56 <ski> (`!' and `?' are similar to `[]' "necessary" and `<>' "possibly" in modal logic)
11:40:02 <EvanR> and since its a monad seems like i should
11:40:51 <EvanR> and whats with the name exponential
11:40:54 <hyperisco> took me a minute to realise you were drawing operators
11:40:55 <ski> well, the neutral element for "either", the additive disjunction is basically `Void', in Haskell terms. there are no proofs of it. from it, everything follows (`void :: Void -> a')
11:41:15 <hyperisco> ⬚ ♢  not sure where a solid box is
11:41:25 <hyperisco> ☐
11:41:33 <hyperisco> that is, uh, not quite the right one
11:41:44 <ski> the neutral element for "with", let's write it `erase' is a garbage can, where you can throw away anything that you don't like. you can't get rid of `erase', however
11:42:34 <ski>   ◻  ◊
11:42:35 <EvanR> as anyone who has tried to throw away a garbage can can attest to
11:43:31 <ski> the neutral element of "tensor" is like Haskell `()'. it contains no information. you can conjure it up out of nothing, and dispose of it as easily
11:44:03 <hyperisco> ski, you should write this up on the ski blog
11:44:27 <ski> the neutral element of the multiplicative disjunction "par", `bot', is something like "your current subgame / thread of execution dies/terminates"
11:45:40 <ski> now, consider LEM, `a (+) (a -o _|_)', where `(+)' is multiplicative disjunction, and `_|_' is its neutral element, `bot'  (btw, note that my symbols differ a little bit from Girard's)
11:46:15 <ski> so, you get two subgames going, when you try to prove this
11:47:01 <ski> let's say you wait for the caller/opponent to disprove the right subgame, `a -o _|_'
11:47:17 <hyperisco> ⊥
11:47:36 <ski> to disprove it, they need to show that from it, "falsity", actually `_|_', follows
11:48:12 <EvanR> uhm, and theres a on the left
11:48:17 <ski> it's a (linear) implication, so they'll need to call it with an argument of type `a', then disprove/use up the result of type `_|_', and then somehow prove `_|_'
11:48:37 <EvanR> do they have access to it
11:48:51 <ski> so, as soon as they can find an `a', they can call it. getting a "value" of type `_|_' which is just what they wanted in order to finish the refutation
11:49:18 <ski> (and this means that the right subgame dies/terminates. proving `_|_' is something like `killCurrentThread')
11:49:52 <hyperisco> okay, but hang on, going back to your cafe here… the cafe says "we serve either tea or not tea on Tuesdays"
11:49:53 <ski> but now, *we* receive the `a' from this subgame, which we then prompty use to win the left one
11:50:10 <hyperisco> so, come Tuesday, I am going to find out whether it is tea or not tea, but they're going to figure it out
11:50:23 <ski> well, they're going to figure out
11:50:31 <ski> they'll be the ones who will tell you
11:50:46 <ski> (and it was soup or salad, dwiw)
11:50:51 <ski> (s/dwiw/fwiw/)
11:51:06 <hyperisco> they may make a mean cup of coffee but I wouldn't go as far to assume they can prove an arbitrary proposition true or not true
11:51:41 <hyperisco> yeah it was soup or salad, but not it is the LEM Café
11:51:48 <hyperisco> but now*
11:51:49 <ski> anyway, in linear logic, `a -o b' is the same thing as (equivalent to) `a (+) (b -o _|_)'
11:52:11 <ski> so proving `a (+) (a -o _|_)' basically amounts to proving `a -o a', which is `id'
11:53:07 <hyperisco> mm… okay… I suppose I have to grok multiplicative disjunction to understand this fully
11:53:07 <ski> the soup and salad example was `soup & salad', additive conjunction. not `soup (+) salad', multiplicative disjunction
11:53:27 <hyperisco> I thought (+) was additive disjunction
11:53:28 <ski> anyway linear logic is a logic of resources
11:53:55 <ski> there is a ban on reusing (and not using at all) a resource/assumption
11:54:06 <ski> except where explicitly permitted, by the `!' "of course" modality
11:54:27 <EvanR> when then find an a, then terminate, how do you get access to the a, is it not used up ?
11:54:47 <EvanR> they*
11:55:04 <hyperisco> will have to read the arcane version of the theory then
11:55:09 <ski> EvanR : they pass it to you, when they call the "function" of type `a -o _|_' that you provided in the right subgame. operationally, this will never return/terminate (instead ending the subgame/thread)
11:55:35 <EvanR> ok its like a callback
11:55:52 <EvanR> but on the left, its still your turn?
11:55:56 <ski> btw, there can be more back and forth action between the subgames, not just in-one-direction and not just once
11:56:02 <ski> sure
11:56:13 <hyperisco> so if there is a linear logic, is there a geometric logic?
11:56:44 <ski> actually there is
11:56:52 <ski> look into Topos theory, and sheaves
11:57:06 <ski> there's two thick tomes called "Sketches of an elephant", by Johnstone, iirc
11:57:12 <hyperisco> do you know the correspondence of that theory?
11:57:28 <ski> i don't know much about geometric logic
11:58:00 <hyperisco> I have to study more on logics… too much to study
11:58:17 <hyperisco> but it is interesting stuff in its relation to philosophy
11:58:19 <ski> "Topology via Logic" by Steven Vickers might also be interesting here
11:58:25 <hyperisco> and then relation to programming… a bridge?
11:58:33 <ski> he connects topology and logic to black box observations
12:00:22 <ski> anyway, Girard symbols for linear logic :
12:00:42 <hyperisco> if you want a laundry list of symbols, check out subjective logic, if you haven't yet
12:01:40 <hyperisco> checking Wikipedia there are 13
12:02:10 <ski> additive disjunction ⌜⊕⌝, neutral element ⌜0⌝ ; additive conjunction ⌜&⌝, neutral element ⌜⊤⌝
12:02:13 <ski> multiplicative disjunction ⌜⅋⌝, neutral element ⌜⊥⌝ ; additive conjunction ⌜⊗⌝, neutral element ⌜1⌝
12:02:33 <ski> the symbols i use in personal notes :
12:03:12 <ski> additive disjunction ⌜1⌝, neutral element ⌜0⌝ ; additive conjunction ⌜×⌝, neutral element ⌜1⌝
12:03:25 <EvanR> question what about negation
12:03:27 <ski> multiplicative disjunction ⌜⊕⌝, neutral element ⌜⊥⌝ ; additive conjunction ⌜⊗⌝, neutral element ⌜⊤⌝
12:03:38 <hyperisco> wasn't -o ⊥ negation?
12:03:41 <ski> (i think my symbols make the duality more apparent)
12:03:46 <EvanR> that is what im asking
12:03:51 <ski> hyperisco : yep
12:04:14 <ski> in papers they typically write it with a superscript `_|_' (to the right)
12:04:19 <ski> but it's equivalent to what you said
12:04:56 <ski> (i also prefer using `0' and `1' for the actual initial and terminal objects in the category ..)
12:05:25 <hyperisco> there is a logic for concurrent programming I can't remember… maybe that was modal
12:05:41 <hyperisco> but there was yet another I remember watching a short talk on
12:05:42 <ski> there is a beautiful presentation of classical linear logic, with multiple assumptions and multiple conclusions
12:05:58 <ski> you get intuitionistic linear logic, if you restrict to only having one conclusion
12:06:13 <hyperisco> the environment being that messages could come in any order at any time, including coming from the future
12:06:40 <ski> (and then multiplicative disjunction, its neutral element, negation, and "why not" doesn't make sense, since you can't keep their rules intact then)
12:07:04 <ski> hyperisco : hm, thinking of that paper about rational and fractional types ?
12:07:10 <ski> by Sabry and someone ?
12:07:34 <hyperisco> I didn't read a paper on it, just watched a person presenting the results
12:07:39 <ski> mhm
12:09:30 <hyperisco> it caught my attention because reasoning about these messy environments easily becomes a nightmare
12:09:40 <ski> anyway .. in SML, which has  callCC : ('a cont -> 'a) -> 'a  you can easily prove  lem : unit -> ('a,'a cont) either
12:10:33 <ski> and it works like you'd expect from above, it captures the current continuation, passes a `Right' value to it, containing a contination that, when/if called with a value, will jump back to the previous continuation, using `Left' that time
12:11:15 <ski> so, it's like boldly claiming there is no proof of  'a  , and if you're called on your bluff, you go back in time and claim there is a proof of it
12:11:42 <ski> in SML/NJ, i should say, though i think at least Mlton also has `callCC'
12:12:21 <EvanR> haha
12:12:57 <EvanR> they provide you with the impossible value, and before it causes the universe to implode, you grab it and use it for your own purposes
12:13:46 <ski> @djinn-add type CallCC a = (Not a -> a) -> a
12:13:51 <ski> @djinn CallCC (Either a (Not a)) -> Either a (Not a)
12:13:51 <lambdabot> f a =
12:13:51 <lambdabot>     case a (\ b -> Right (\ c -> b (Left c))) of
12:13:51 <lambdabot>     Left d -> Left d
12:13:51 <lambdabot>     Right e -> Right e
12:14:27 <ski> hm, that `case' seems a bit redundant, but otherwise that's basically how you prove it
12:15:08 <ski> it takes a little more work if `Not a' isn't an alias for `a -> Void' (in SML/NJ, it isn't, it's an abstract data type of continuations)
12:16:23 <ski> (they have an operation  throw : 'a cont -> 'a -> 'b  iirc)
12:17:18 <EvanR> which looks ex falso
12:17:23 <ski> indeed
12:17:31 <ski> the trick is implementing the inverse
12:19:40 <ski> anyway, when one proves that if a prime divides a product, it divides a factor, one typically does that by assuming that it doesn't divide one factor, and then go on to prove it divides the other factor
12:19:56 <ski> so, this is actually a multiplicative disjunction being proved, then
12:21:01 <ski> (one could do more work, and actually go on to decide which alternative to prove, without waiting for the opponent to disprove one of them. but that's more involved)
12:21:32 <EvanR> er
12:21:51 <EvanR> cant it divide both factors
12:21:56 <ski> sure
12:22:11 <EvanR> so what kind of arguement is that
12:22:30 <ski> "either it divides the first factor, so we're done, or it doesn't. in the latter case, then ..."
12:22:56 <EvanR> oh hmm
12:22:56 <hisoka> Hi, I have a beginner question with regards to data types.. I have a type declared as : data Configuration v = Configuration { configurationMap   :: Map.Map v Status, configuration Graph :: Graph v } ... I have a function that is returning a 'Map.Map v Status' when it should be a 'Configuration v'... How do I convert it into the correct data type?
12:23:40 <hyperisco> hisoka, use the Configuration constructor
12:24:09 <hisoka> Well I tried doing Configuration (the code) and it still doesn't work
12:24:13 <hyperisco> though it looks like you have to come up with a  Graph v  as well
12:24:26 <ski> another way to think about the multiplicatives is that when proving a multiplicative disjunction, one's using a single shared set of resources, splitting it in two disjoint parts, proves the two conjuncts *separately* (without interaction)
12:24:39 <hyperisco> is  Graph v  Monoid? then use mempty
12:24:41 <ski> er, that should be, multiplicative conjunction
12:25:04 <hisoka> the function has a signature : initConfiguration :: Ord v => Graph v -> Configuration v
12:25:13 <hisoka> my implementation is: initConfiguration v = Map.fromList [ (a,b) | a <- (vertices v), b <- [Free] ]
12:25:14 <ski> while when proving a multiplicative disjunction, there is no splitting of resources, and one's proving the two disjunctions "in parallel", with interaction
12:25:35 <hyperisco> oh, so you are given a graph! well just use that then
12:25:43 <hisoka> I know for my Graph module I could of just put Graph (Map.Map v [v]) and it worked
12:25:53 <ski> this means that there'll be "funny" scoping, like binding a variable in one disjunct expression, and then using it in the other one
12:25:58 <hyperisco> hisoka, do you know how to use ghci?
12:26:21 <hisoka> probably not to the same extent as the people here
12:26:31 <hisoka> but yeah, i've been testing thing out with regular data
12:26:40 <hyperisco> what is  :t Configuration  ?
12:26:52 <hisoka> so if i udnerstand correctly I could return a Graph isntead of Configuration?
12:27:03 <hyperisco> you do not understand correctly
12:27:34 <ski>   initConfiguration v = Configuration { configurationMap = Map.fromList [...] , configurationGraph = ... }  -- ?
12:27:51 <hisoka> :t Config gives me .....  Configuration :: Map.Map v Status -> Graph v -> Configuration v
12:27:52 <lambdabot> error:
12:27:53 <lambdabot>     Not in scope: type constructor or class ‘Map.Map’
12:27:53 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
12:28:04 <hyperisco> hisoka, so what does that tell you?
12:28:10 <ski> yea, you need to both construct a map and a graph, in there
12:28:31 <hisoka> I need a Map.map and a Graph v to return a Configuration v
12:28:36 <ski> oh, `v' already is a graph ?
12:28:47 <hyperisco> yes, and where can you get both of those?
12:28:59 <ski> perhaps `v' is what you want to put in the `configurationGraph' field, then ?
12:29:25 <hyperisco> the wrong person is answering Socrates here
12:30:47 <hisoka> Looking at the signature, I am even more confused
12:30:48 * ski retreats to the corner, with a scottish cap
12:31:08 <hyperisco> okay, the signature of what, and what confuses?
12:31:17 <dgpratt> I wonder if a sufficiently clever diffing algorithm could ever recognize that a certain change was a "refactoring only" change, or if that would stray into "halting problem" territory
12:31:27 <hisoka> So the Data type Configuration needs 2 elements?
12:31:47 <hyperisco> dgpratt, for Turing complete languages? halting problem, as you are testing functional equivalence, yes?
12:32:07 <monochrom> Most refactorings follow pretty rigid patterns.  I think it can be done.
12:32:10 <hisoka> Right now I am returning a 'Map.map v Status' but it should return a graph along with it ?
12:32:19 <dgpratt> that was my suspicion, yes, hyperisco
12:32:21 <hyperisco> hisoka, that's right
12:32:48 <hyperisco> dgpratt, yeah functional equivalence is right in there with unsolvable problems
12:33:26 <hisoka> Thank you that clarifies it! :)
12:33:43 <hisoka> One small question though, how do you return two things?
12:33:56 <hyperisco> hisoka, you don't, but you can return one thing which contains two things
12:34:02 <hisoka> can I do x { Map.map... , v }?
12:34:32 <hyperisco> the type of Configuration tells you it is a function
12:35:11 <hyperisco> if you have a function  f :: a -> b -> c  and some  x :: a  and  y :: b  how can you get a  z :: c ?
12:35:42 <hisoka> I'd do Configuration x b
12:35:55 <hisoka> well I guess in that context f x b
12:35:58 <hisoka> well I guess in that context f x y
12:36:24 <hyperisco> yes, and so apply this same principle to Configuration, your Map, and your Graph
12:52:03 <hisoka> Thank you hyperisco for the clarifications :)
12:52:10 <hyperisco> glad to help
12:52:15 <gremblygunk> what are your thoughts on elixir, #haskell?
12:52:20 <hyperisco> ski was showing you the record notation version
12:54:21 <dstolfa> gremblygunk: my opinion is that it's ruby on BEAM
12:58:35 <hyperisco> why is stack exec so slow for running my executable
12:59:23 <gremblygunk> dstolfa: have you used it? how does it compare to haskell?
13:00:41 <metahumor> how i wish (>>=) for lists had a simple syntax in python...
13:00:49 <metahumor> itt.chain.from_iterable be damned
13:03:02 <dstolfa> gremblygunk: it's not comparable
13:03:04 <hyperisco> metahumor, can't you just use list comprehensions?
13:03:06 <dstolfa> gremblygunk: depends on your usecase
13:03:33 <dstolfa> gremblygunk: BEAM is useful for distributed systems, where it has state replication, no sharing and employs an actor model across a distributed system
13:03:37 <hyperisco> > [y | x <- [1..10], y <- [0..x]]
13:03:39 <lambdabot>  [0,1,0,1,2,0,1,2,3,0,1,2,3,4,0,1,2,3,4,5,0,1,2,3,4,5,6,0,1,2,3,4,5,6,7,0,1,2...
13:04:09 <dstolfa> it's not very good if you try to do things that have to pass a lot of state around so you do lots of copying
13:05:08 <hyperisco> and if I want to pass switches and arguments to my exe do I really have to dig it out of .stack-work? D:
13:05:10 <dstolfa> haskell OTOH does lazy evaluation. this modifies the termination behaviour of the program and gives you some useful programming patterns, such as an infinite stream of data that can terminate. there are optimisations that are done in GHC that have to do with CBV based on the results of strictness analysis, but don't work every time
13:05:25 <amalloy> hyperisco: probably generator comprehensions, since metahumor appears to want an iterable rather than a list
13:05:38 <hyperisco> oh right, that strict thing
13:05:53 <hyperisco> generators… the non-strict list
13:08:06 <gremblygunk> dstolfa: what about a usecase of a massively concurrent website?
13:08:24 <dstolfa> gremblygunk: depends. it's likely not going to be good to implement it only using one paradigm and you'll have to trade off
13:09:55 <dstolfa> gremblygunk: your massively concurrent service can be done on top of BEAM or something like ponylang. it's easy to do with that, so you can do things like consensus on it (if we're talking distributed system). if we're just talking local concurrency, it will depend if you have to do any sharing and how much copying you'll have to do if you have to share. state replication can benefit performance if you
13:10:01 <dstolfa> can localise lots of accesses on replicated data and don't have to update it often. if you do, you will spend most of your time copying
13:10:48 <dstolfa> the problem is that current operating systems don't expose support for easy data localisation in caches that are based on cache coherence protocols in userspace, so you'll have to fight that a bit
13:16:02 <metahumor> hyperisco, amalloy: i have simple expressions like (mol.atom for mol in system)
13:16:16 <pikajude> http://lpaste.net/7392124936778678272
13:16:20 <pikajude> okay. what am i missing here
13:16:27 <metahumor> it'd be great if i could just have that, and then >>= (batom.name for batom in atom.bonded_atoms)
13:16:46 <Tuplanolla> If you have an enumerated type `E` and a formatter `formatE :: E -> String`, you can get the corresponding parser for free via `parseE = asum (fmap (fmap . const <*> try . string . formatE) enumerated)`.
13:16:55 <Tuplanolla> It's not optimal, but it's still pretty nice.
13:17:04 <metahumor> doesn't matter whether it's lists or iterators, the fact that i have to write the subexpression explicitly into the [_ for _ in _ for _ in _] is bleh
13:17:19 <Tuplanolla> I wonder how hard it would be to derive an optimal version.
13:18:11 <Rembane> metahumor: Won't the splash operator help you?
13:18:31 <amalloy> metahumor: i don't love python's generator notation either, but it's just notation. >>= doesn't work out as well when you have to use a bunch of things that aren't actually functions, such as field lookups
13:20:21 <pikajude> oh, I found it
13:20:36 <pikajude> although the message says "The package needs to specify at least 'cabal-version >= 1.23'", the check in code specifies >=2.0
13:20:39 <pikajude> what the hell
13:21:51 <MarcelineVQ> what build system?
13:22:06 <pikajude> cabal?
13:22:48 <pikajude> ah, someone updated the version check in code and forgot to update the error message
13:22:55 <pikajude> should be an easy fix
13:23:08 <MarcelineVQ> ah alrighty, just wondering because there had been issues with that error popping up with stack in the past
13:23:20 <pikajude> presumably the reason is that people set their "cabal-version" to "1.23" :P
13:24:05 <hyperisco> is there much point to having a String newtype if you're advocating the use of OverloadedStrings? meh
13:24:50 <WarzoneCommand> hmm lens question; suppose I have some field x of a datatype that requires some function f to be applied when *setting* the field (i.e. to make sure that the internal invariants are maintined). Now this function f may have some typeclass constraint C. When I want to *get* the field x (using my lens), I don't really want the constraint on C though. Is there a nice way about this? (except for definin
13:24:51 <MarcelineVQ> sure why not, overloaded strings is just for literals yeah?
13:24:56 <WarzoneCommand> g Getter and Setter with different names and types)?
13:26:43 <John882> Hello, I'
13:27:09 <John882> am trying to do the Mirror example (http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/)
13:27:58 <WarzoneCommand> (in my specific application the 'x'es are vectors, and I want to make sure they remain *unit* vectors, thus when setting the vector I need to normalize them. This requires a Floating constraint which I don't want when I use the lens as a getter)
13:28:04 <John882> but yesod get errors on compile time http://lpaste.net/362926
13:28:22 <John882> Anyone got any idea how can i fix this?
13:29:20 <Gurkenglas> WarzoneCommand, have you considered projected coordinates?
13:30:06 <WarzoneCommand> Gurkenglas: what do you mean exactly?
13:30:47 <John882> http://lpaste.net/362927 <- errors here
13:30:52 <Gurkenglas> WarzoneCommand, for example you could keep the vectors scaled such that one coordinate stays equal to 1
13:31:13 <Gurkenglas> (or -1, or 0 and repeat with the next coordinate)
13:32:46 <Gurkenglas> Each unit vector represents a ray starting at the origin. You can pick other points along each ray to represent them.
13:33:12 <WarzoneCommand> hmm yes, but I'm not sure how to maintain that, e.g. if I pick some vector in a different direction, and I want to make sure that I store a unit vector I still need to normalize no?
13:33:49 <Gurkenglas> Why do you need to store a unit vector? What do you mean by pick some vector in a different direction?
13:34:41 <xacktm> hello, is new-build incompatible with happy/hmatrix?  I basically have an empty cabal 1.24.0.2 project with some dependencies and ran new-build http://dpaste.com/2X7PP2W
13:34:51 <Gurkenglas> (Another coordinate system would be longitude/latitude)
13:35:05 <WarzoneCommand> I'm implementing something that does a world to view coordinate transformation, for that I need unit vectors to compute the particular rotation
13:36:44 <Gurkenglas> Normalizing to length 1 needs square roots. Normalizing a particular coordinate to one needs division.
13:36:53 <xacktm> (this is my cabal file, just ran new-build http://dpaste.com/0FKS6P8 )
13:37:01 <WarzoneCommand> Gurkenglas: yeah I also thought of that, but then I would need trigonometric operations
13:37:49 <WarzoneCommand> basically, I'm hoping to avoid having a Floating constraint on the numeric type for as long as possible
13:38:31 <xacktm> a good ol' cabal sandbox seems to compile fine.... maybe I won't use new-build this time :/
13:38:46 <Gurkenglas> Walk me through when you'd need a floating constraint under particular-coordinate-equals-one
13:40:03 <WarzoneCommand> having only one coordinate to be equal to one does not imply having a unit vector
13:40:35 <ski> John882 : add a space after the `$' .. or just remove it altogether
13:41:01 <Gurkenglas> Let's convert the vector from my representation to yours lazily, keep going and see where it being a unit vector actually gets used :3
13:41:21 <ski> John882 : `$(...)' is Template Haskell syntax, which you probably didn't intend to touch
13:42:03 <ski> John882 : or if you did, perhaps you forgot to turn on that language extension ?
13:42:38 <ski> add `{-# LANGUAGE TemplateHaskell #-}' to the top of your source, in the latter case
13:43:39 <ski> John882 : for the middle error, i think you can enable `OverloadedStrings'
13:47:56 <John882> ski: ... I feel like an idiot, yeah I have enabled in the source file but not in this file
13:48:27 <John882> I am using both of these since yesod pretty much forces you to use TemplateHaskell and OverloadedStrings,
13:49:17 <John882> ski: thank you :)
13:57:20 <gremblygunk> what are some things to consider when choosing between ghcjs, purescript and elm?
13:57:53 <Tuplanolla> @google elm is wrong
13:57:53 <lambdabot> http://reasonablypolymorphic.com/blog/elm-is-wrong
13:57:54 <lambdabot> Title: Elm Is Wrong :: Reasonably Polymorphic
14:01:39 <nigelvr> Just started learning haskell today. If you have a function f ∷ A → B, does that mean that f is of type  A → B? because I thought '::' was like 'type-of'
14:03:02 <boj_> nigelvr: it means f takes something of type A and returns something of type B
14:04:44 <nigelvr> right, but doesn't it say something crazy like "f is a function of type A->B"? if you catch my drift? maybe i'm thinking too much about it
14:05:19 <maerwald> A -> B is the type, yeah
14:05:43 <maerwald> or type signature
14:05:45 <maerwald> whatever
14:06:02 <nigelvr> gotcha.
14:06:28 <MarcelineVQ> "If you have a function f ∷ A → B, does that mean that f is of type  A → B" yes, exactly
14:09:58 <fishythefish> nigelvr: by the way, which part of "f is a function of type A -> B" seems crazy?
14:11:06 <nigelvr> fishythefish: i'm just getting used to functional programming.
14:11:32 <ski> functions are values, too
14:11:55 <fishythefish> nigelvr: sure, I don't mean to insinuate that this should all seem natural immediately; I'm genuinely curious
14:12:33 <ski> to specify the type of a function value, you have to specify (a) the expected type of the input/argument; and (b) the type of the output/result that you get when calling the function with a value of type as in (a)
14:13:17 <Squarism> Is there some standard way of creating .html test reports with stack?
14:13:33 <ski> e.g. `not :: Bool -> Bool' says that the value `not' is a function, which accepts `Bool'eans, and produces `Bool'eans in response
14:13:48 <maerwald> @where learnhaskell
14:13:48 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:14:07 <maerwald> nigelvr: ^ good read
14:14:48 <ski> if you write a list of `Bool'eans, like `[False,False,True,False]', then the type of that is `[Bool]', meaning "list of `Bool'eans"
14:15:15 <nigelvr> gotcha, thanks maerwald
14:15:34 <ski> since functions are values, you can also store them in lists, like e.g. `[not,not . not]', a list of functions. this list has type `[Bool -> Bool]', every element of this list is a function from `Bool' to `Bool'
14:15:50 <Bowlslaw> maerwald: sounds scottish/irish/welsch/some white people from a rainy land language
14:16:06 <maerwald> Bowlslaw: what exactly?
14:16:10 <Bowlslaw> your name lol
14:16:16 <maerwald> it's a PoE reference
14:16:21 <Bowlslaw> Path of Exile?
14:16:26 <ski> (fwiw, `not . not' is the composition of the `not' function with itself, like a unix pipe if you know about that. in general `f . g' is the function that, when called with an input, will pass that to `g', then pass the output from there to `f', and finally will return the result that `f' produces)
14:16:26 <maerwald> pillars of eternity
14:16:38 <Bowlslaw> heard a lot of good things about that game
14:16:48 <maerwald> it's not written in haskell I think
14:16:49 <maerwald> xD
14:16:54 <Bowlslaw> lol
14:16:56 <ggVGc> name one game that is
14:17:04 <Bowlslaw> i made tic tac toe
14:17:05 <ggVGc> (ghc)
14:17:05 <Bowlslaw> PWNED
14:17:13 <maerwald> frag
14:17:13 <nigelvr> i think john carmack ported wolfenstein 3d in haskell
14:17:17 <maerwald> no
14:17:22 <ski> @where Frag
14:17:23 <lambdabot> http://www.haskell.org/haskellwiki/Frag
14:17:24 <maerwald> that was just a twitter post
14:17:32 <ggVGc> pretty sure the original version of wolfenstein was in haskell
14:17:38 <nigelvr> lol
14:18:05 <maerwald> carmack probably lost interest in haskell when he tried to build something serious with a lot of state and high performance
14:19:08 <Bowlslaw> well that's not one of Haskell's strong points right?
14:19:11 <maerwald> no
14:19:15 <Bowlslaw> you'd use C++ for that or something
14:19:53 <maerwald> people are trying to make it better, but then come up with even more complexity (abstraction wise)
14:20:06 <maerwald> you can't convince game programmers to use that stuff
14:20:20 <maerwald> games are not about correctness or elegance
14:20:21 <nigelvr> what stuff, specifically?
14:20:25 <maerwald> frp
14:20:52 <nigelvr> ah, thought you were talking about new C++ features
14:21:02 <maerwald> making C++ better, lol
14:25:01 <dminuoso> maerwald: Thats not entirely correct. Large domain specific languages quickly evolve because languages like C++ borderline suck to describe higher level game behaviors that dont really rely on performance.
14:25:48 <maerwald> huh? show me an example
14:28:29 <dminuoso> maerwald: Things like Lua/JavaScript/Python are fairly common in certain high level abstractions (what's commonly called "scripting"
14:28:43 <Bowlslaw> perl > python
14:28:49 * Bowlslaw runs from impending shitstorm
14:30:28 <Tuplanolla> Watch nobody care.
14:31:05 <Bowlslaw> mmk
14:31:36 <dminuoso> maerwald: Im guessing it could be partially attributed to the lack of actual programming expertise in content designers.
14:32:09 <dminuoso> Lua is almost as simple as go, so you can probably actually teach it to Orangutans.
14:35:31 <pikajude> ooh, cabal-install HEAD uses the nice new haddock stylesheet by default
14:35:34 <pikajude> lovely!
14:36:44 <maerwald> dminuoso: no idea why you call those domain specific languages
14:37:30 <dminuoso> maerwald: That was poorly phrased.
14:37:30 <mailman> hey guys, what the hell is going on when there are kinds in typeclass definitions?
14:37:39 <mailman> is there a resource I can read about that?
14:37:55 <mailman> e.g class Category (cat :: k -> k -> ∗) where
14:38:30 <fishythefish> mailman: compare with class Functor (f :: * -> *) where ...
14:38:40 <maerwald> dminuoso: well sure, games are not entirely written in C++
14:39:00 <sm> ooh haskell game dev chat
14:39:04 <fishythefish> hence, instance Functor Maybe is fine, but instance Functor Int is not
14:39:10 <mailman> fishythefish: Alright that makes sense, thanks
14:40:10 <dminuoso> mailman: Those are polymorhic kinds, as in (cat :: forall k. k -> k -> *)
14:41:00 <dminuoso> :k Category
14:41:01 <lambdabot> (k -> k -> *) -> Constraint
14:42:35 <maerwald> sm: you're coming late to the party xD
14:45:23 <sm> yes, drat
14:45:47 <sm> and found myself with nothing to add :)
14:46:42 <sm> just perpetually in hope of more haskell game dev action
14:46:46 <hdon> hi all :) first time haskell programmer. any tips on getting started? i was reading through a getting started guide, and one of its examples depends on "Control/Parallel". ghc/ghci try finding a file like this relative to my PWD but to no avail. i'm using ubuntu 16 and the ghc package i installed does include some Control/ stuff but not Control/Parallel. i'm using ghc version 7.10.3 so maybe Control/Parallel isn't part of the stdlib in this version?
14:48:02 <dminuoso> hdon: Hi. We use dots as separators, so that would be spelled Control.Parallel. That is from the package `parallel`. Are you using cabal-install?
14:48:12 <Squarism> anyone using the stack test --coverage feature? I seem to hit https://github.com/commercialhaskell/stack/issues/1008 which doesnt state any clear workaround
14:48:56 <sm> hdon: http://hoogle.haskell.org/?hoogle=Control.Parallel&scope=set%3Astackage&= shows which package provides this, then you can translate this to a system package via https://packages.ubuntu.com/search?keywords=parallel&searchon=names&suite=xenial&section=all (probably one with ghc in the name)
14:49:08 <hdon> dminuoso: my mistake :) i was looking at the strace and i suppose Control.Parallel maps to filenames like Control/Parallel.{hs,lhs,hsig,lhsig}
14:49:45 <hdon> dminuoso: no i'm not using cabal-install yet. is this a package manager for haskell and/or ghc?
14:50:41 <dminuoso> hdon: Amongst other things. It also helps manage configure/compile/install packages as well as your own projects.
14:51:05 <hdon> dminuoso: ahhh okay thanks :)
14:51:18 <hdon> sm: is this some kind of web interface to a haskell package repository?
14:51:31 <sm> yep
14:52:23 <dminuoso> hdon: It's even more! Hoogle allows you to find things by either name or by type signature (which is incredibly helpful if you already know what shape the function is in, but you have no idea what it might be called)
14:52:24 <hdon> sm: i suppose that standard library content would not appear here? meaning... Control.Parallel is not part of the standard library?
14:52:35 <hdon> dminuoso: wow, cool
14:52:40 <sm> standard library content is included
14:53:09 <hdon> hmm, ok
14:53:42 <dminuoso> hdon: You can check at the top. Everything that is in `base` is the standard library plus some more.
14:54:03 <sm> so Control.Parallel is provided by the "parallel" haskell package, which is packaged in ubuntu as "libghc-parallel-dev"
14:54:15 <hdon> thanks sm :)
14:54:20 <dminuoso> hdon: Or alternatively you can switch to cabal-install/stack and use them to manage dependencies =)
14:54:48 <hdon> dminuoso: could i see an example of something "in base" if that's easy for you?
14:55:17 <dminuoso> hdon: Type `base` at the top into the search box. That will allow you to search for the package name.
14:55:24 <dminuoso> Then you can inspect the contents of `base`
14:55:29 <hdon> ahhhh thanks :)
14:55:51 <sm> in this case it'll also find a lot of other things named "base" in other packages
14:56:50 <hdon> well, that was diappointing
14:57:32 <hdon> i installed libghc-parallel-dev and ran the par example from https://wiki.haskell.org/Haskell_in_5_steps but it only used one CPU core
14:58:18 <dminuoso> hdon: Did you build with -rtsops as well as passing +RTS -N2 to the executable?
14:58:26 <hdon> dminuoso: no
14:58:49 <dminuoso> hdon: So you didn't run the example as per wiki =)
14:58:59 <hdon> fair point :) i will try it the options
15:01:05 <hdon> well, i did a direct copy and paste from the wiki and still only using one core. i notice that the wiki does not say +RTS or -N2
15:01:15 <hdon> ohh
15:01:20 <hdon> when i run ./A i use those options
15:02:45 <EvanR> interesting, would you expect any random installed haskell binary to accept theses options?
15:02:45 <dminuoso> hdon: You have to compile with -rtsopts it enables certain RTS flags in the resulting binary that can steer the RTS.
15:03:13 <dminuoso> EvanR: I was confused as heck the first time I profiled a Haskell program.
15:03:27 <EvanR> ah
15:03:30 <hdon> so, to my intuition, the interface between the operating system is generally that the program's entry point will receive things like command-line arguments and environment variables. in this case, i don't see anything in the program code that seems to reference anything like this, yet these options seem to have an effect. what's the deal? :)
15:03:32 <sm> only the *first* time ?
15:04:08 <EvanR> hdon: RTS options are magic, you dont manage them in the code
15:04:19 <EvanR> hence my question
15:04:30 <hdon> ah :)
15:04:37 <hdon> i'm a newb EvanR i can't help
15:04:56 <hdon> as a haskell programmer, how can i access command line options the way i would from a C program?
15:04:56 <dminuoso> hdon: EvanR is asking for a newcomers perspective. So you are in the best position to help.
15:05:03 <dminuoso> ;-)
15:05:05 <EvanR> no i was asking anybody
15:05:20 <EvanR> you dont expect something like RTS opts for programs written in C for ex
15:05:37 <dminuoso> hdon: base comes with System.Console.GetOpt which has the necessary primitives
15:05:50 <sm> EvanR: oh, ok. Yes I would, until recently when no rtsopts by default became a thing
15:05:51 <hdon> oh, ok. in that case... i would not have any intuition at this time that i could pass those options to a haskell program, and i'd be convinced i couldn't pass them to any effect in a program i had written unless i had written some code to interpret those arguments somehow
15:06:00 <dminuoso> hdon: It's not very usable to create complex programs from, but this is probably where you should pick up a learning resource.
15:06:03 <hdon> dminuoso: thanks :)
15:06:08 <EvanR> its kind of like, goes against "shouldnt matter what language the progrma was written in"
15:06:21 <EvanR> sm: yeah didnt know that
15:06:59 <shapr> hdon: for quick hacks where I want command line args, I use https://hackage.haskell.org/package/ReadArgs
15:07:17 <sm> also here's a really simple command line parser I was just looking at (no libs): http://hackage.haskell.org/package/propellor-5.3.3/docs/src/Propellor-CmdLine.html#processCmdLine
15:07:30 <hdon> so maybe this is dumb, but i typed "base.console.getopt" into hoogle and got no results
15:07:41 <hdon> oh it's system my bad
15:07:48 <dminuoso> hdon: Oh well.. actually considering your level that's a bit too far ahead.
15:07:52 <sm> just type getopt
15:07:55 <dminuoso> hdon: System.Environment.getArgs
15:08:04 <dminuoso> hdon: That will work to get started for a few things.
15:08:08 <shapr> yeah, getArgs is the c-style argv/argc thing
15:08:15 <hdon> dminuoso: is getOpt more like gnu getopt?
15:08:24 <dminuoso> hdon: Kinda
15:08:51 <dminuoso> hdon: I mean except for the "gnu getopt" part thats exactly what it is.
15:09:16 <dminuoso> But yeah.
15:09:39 <hdon> :3
15:10:29 <hdon> ok so, is there something like car or cdr (from lisp) that i have to use to evaluate all elements of a [String] type?
15:11:11 <dminuoso> hdon: This is where you are probably best served with a decent learning resource.
15:11:15 * EvanR slaps hdon witg a haskell tutorial
15:11:20 <hdon> lol ok
15:11:20 <hdon> thanks guys
15:12:32 <shapr> hdon: I just noticed https://mmhaskell.com/liftoff/
15:12:43 <shapr> I'm enjoying the more advanced posts, maybe the beginner posts are also good?
15:13:17 <dminuoso> hdon: Though let it be said that unlike Lisp, Haskell is lazy. So things are not evaluated the same way - you're better off losing your old notion of "when things are evaluated" real fast =)
15:14:08 <hdon> dminuoso: i can do that. thanks :)
15:14:30 <hdon> thanks shapr i'll set my computer to work doing something and give this a read :)
15:15:03 <dminuoso> shapr: Mmm. Part 4 wants an email address.
15:15:06 <dminuoso> Sounds fishy and spammy.
15:18:42 <sm> hdon: I like https://leanpub.com/haskell-cookbook/read
15:19:22 <kar1> dminuoso: But it says 100% secure?
15:20:55 <sm> and only I like it, it seems. Nobody speaks of it but me, ever. But I pass it on to you. Perhaps you will read these words and like it too. :)
15:21:51 <EvanR> actually ive never heard of this one
15:21:57 <kar1> sm: it's in my bookmarks. I like too...
15:21:58 <MarcelineVQ> sm: I've seen it but not taken the time to read it :>
15:22:29 <EvanR> "As examples, two subtypes of Num are Fractional (e.g., 3.5) and Integer (e.g., 123)"
15:22:34 <EvanR> :S
15:22:37 <dminuoso> kar1: Oh you're right. If it asks for my credit card number, they just want to confirm my email address, right?
15:22:41 <sm> it's really extremely good. Nothing covers that particular space better IMHO
15:22:46 <bontaq``> this is pretty sweet sm
15:23:51 <kar1> dminuoso: What are you implying, that you can't trust strangers on interwebs? ;-)
15:25:21 <kar1> dminuoso: It would explain a lot though...
15:25:26 <dminuoso> kar1: No I can, it's like you said. 100% secure.
15:25:50 <EvanR> it has a nice font, you can trust them
15:25:53 <dminuoso> :t (>=>)
15:25:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:26:13 <dminuoso> Can you somehow use type applications on infix operators?
15:27:11 <EvanR> :t (>=>) @Maybe
15:27:12 <lambdabot> error:
15:27:13 <lambdabot>     Pattern syntax in expression context: >=>@Maybe
15:27:13 <lambdabot>     Did you mean to enable TypeApplications?
15:27:42 <dminuoso> EvanR: Mmm. Just found this ticket https://ghc.haskell.org/trac/ghc/ticket/12363
15:27:43 <dminuoso> :(
15:27:48 <EvanR> :t let f = (>=>) in f @Maybe
15:27:49 <lambdabot> error:
15:27:49 <lambdabot>     Pattern syntax in expression context: f@Maybe
15:27:49 <lambdabot>     Did you mean to enable TypeApplications?
15:27:56 <EvanR> darnit
15:28:20 <EvanR> lambdabot, enable TypeApplications
15:29:23 <MarcelineVQ> that's not a valid type app anyway ^^;
15:29:52 <EvanR> why
15:30:09 <MarcelineVQ> because I'm too dumb to import >=> in my ghci before speaking
15:30:35 <MarcelineVQ> but also because of how type application works
15:30:56 <MarcelineVQ> (>=>) @Maybe :: (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c  is fine
15:31:58 <MarcelineVQ> @ is visible type application    :t let f = (>=>) in f @Maybe    sort of hides the 'visible' part of >=>    more info here, still looking for the relevantr section  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#visible-type-application
15:33:40 <fishythefish> EvanR: https://ghc.haskell.org/trac/ghc/ticket/12363
15:34:02 <fishythefish> oh nvm dminuoso already found it
15:34:13 <metahumor> % :t (>=>) @Maybe
15:34:13 <yahb> metahumor: (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
15:34:17 <dminuoso> One of the interesting use cases seems to be `catch` actually
15:34:23 <metahumor> yahb coming through with the extensions
15:34:30 <MarcelineVQ> % :t let f :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c; f = (>=>) in (f @Maybe)
15:34:30 <yahb> MarcelineVQ: (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
15:34:35 <dminuoso> so you can specify `do ... `catch` @SomeException handle`
15:34:36 <MarcelineVQ> % :t let f = (>=>) in (f @Maybe)
15:34:36 <yahb> MarcelineVQ: ; <interactive>:1:19: error:; * Cannot apply expression of type `(a0 -> m0 b0) -> (b0 -> m0 c0) -> a0 -> m0 c0'; to a visible type argument `Maybe'; * In the expression: (f @Maybe); In the expression: let f = (>=>) in (f @Maybe)
15:34:40 <dminuoso> That looks pretty cool actually
15:35:01 <EvanR> messing with infix operators while their infix is kind of like, jumping the shark. and the reason typeclasses are basically necessary to do arithmetic
15:40:24 <shapr> dminuoso: I put in my email address, it's not phishy or spammy
15:57:27 <dibblego> is there a library that turns the ANSI codes off for windows? e.g. linux: https://i.imgur.com/isJcTNv.png
15:58:41 <dminuoso> dibblego: Win32 no longer has native ANSI escape code supports afaik
15:59:00 <dibblego> right, so how to write the code so that it works on windows?
15:59:24 <dminuoso> dibblego: What do you mean "it works" - do you want to have colors on Windows?
15:59:38 <dibblego> no, but I also don't want escape codes printed
16:02:12 <shapr> How do I set a default executable in a cabal file?
16:02:14 <dibblego> putStrLn . (if isWindows removeEscapes else id) $ "\ESC[95m\ESC[45mhi\ESC[m" -- I want this function, or similar
16:02:27 <dibblego> +then
16:03:36 <fishythefish> shapr: afaik, by only having one executable
16:04:12 <shapr> aw, ok
16:05:43 <fresheyeball> hey out there
16:06:11 <fresheyeball> Are there any examples out there of using Servant 13's streaming combinators?
16:06:46 <Welkin> fresheyeball: did you ask in #servant?
16:06:57 <fresheyeball> Welkin: I didn't know there was a #servant
16:07:01 <fresheyeball> I will head over there
16:07:06 <Welkin> the authors are there
16:07:12 <Welkin> they respond pretty fast
16:26:00 <dong910325[m]> > Bowlslaw (IRC) 离开了聊天室
16:26:02 <lambdabot>  error:
16:26:03 <lambdabot>      Data constructor not in scope: Bowlslaw :: t0 -> t1 -> terror: Data cons...
16:26:05 <dong910325[m]> > pfurla (IRC) 离开了聊天室
16:26:07 <lambdabot>  error:
16:26:08 <lambdabot>      Variable not in scope: pfurla :: t0 -> t1 -> terror: Data constructor no...
16:26:51 <Welkin> what is this spam?
16:26:54 <Welkin> and from a matrix user?
16:26:56 <Welkin> a bot?
16:27:15 <hpc> at least it's not matrix netsplitting
16:27:15 <MarcelineVQ> you typed more than he did :>
16:28:55 <EvanR> terror
16:29:00 <glguy> That looks like a bit of accidentally copy/paste. "离开了聊天室" translated to "Left the chat room"
16:29:20 * ski was just about to suggest that
16:29:43 <ski> (back from a few minutes over an hour)
16:29:45 <Welkin> which is exactly what spam looks like
17:10:49 <dmwit> dibblego: I would use the "annotated" versions of either pretty or wl-pprint-annotated. Annotate docs with the coloring you want to do. Then when you render you can choose to either include or ignore the annotations.
17:11:32 <dibblego> dmwit: cool, thanks
17:30:16 <shapr> what's the best library for safeHead and friends?
17:30:54 <shapr> I'm teaching a "parsing with Haskell" class tomorrow, figured I'd show off some applicative parsers and then work from monoid -> functor -> applicative
17:31:54 <shapr> maybe it makes more sense to just show off the awesome, and then show how they work if someone asks
17:32:26 <EvanR> the top down approach
17:32:40 <shapr> yeah, don't give 'me aspirin before they have a headache
17:36:15 <jle`> safeHead is already in base fwiw
17:36:27 <jle`> but friends aren't
17:36:27 <dibblego> I use papa
17:36:50 <dibblego> λ> :t head
17:36:50 <dibblego> head :: Cons s s a a => s -> Maybe a
17:40:48 <dmwit> shapr: The safe package has the complete set.
17:41:08 <shapr> ok, thanks
17:43:35 <c_wraith> dibblego, that looks very lens
17:43:57 * dibblego puts on sunglasses
18:14:42 <lylek> https://www.haskell.org/news down? :(
18:19:25 <taumuon> does anyone know of a good graphics package for a beginner haskeller? something like a html5 canvas or processing, with line drawing and frames and such?
18:19:51 <EvanR> taumuon: theres gloss
18:20:46 <taumuon> thanks, I'll check it out!
18:20:49 <EvanR> its not like canvas or processing, for the graphics part you compute a Picture
18:20:57 <EvanR> which is a value
18:21:41 <EvanR> and an instance of Monoid, so you can layer pictures together
18:21:47 <taumuon> sounds interesting
18:22:36 <EvanR> i used it to make this! https://www.youtube.com/watch?v=qek030hAGKE
18:23:11 <taumuon> ooh nice
18:23:25 <taumuon> yeah i love doing stuff like that to get a handle on a new lang.
18:24:06 <EvanR> yeah its actually really cool, but the font for text sucks ...
18:24:25 <sm> nice!
18:25:48 <EvanR> this demo is cooler https://www.youtube.com/watch?v=p1xUViqtYFA
18:26:47 <taumuon> that's really cool
18:28:24 <taumuon> what can you tell me about game programming in haskell?  enjoyable?
18:29:49 <sm> immature, low activity, enjoyable, popular!
18:30:09 <EvanR> I...
18:30:55 <EvanR> i can't really tell you much. but there is an IRC channel for it #haskell-game
18:31:02 <taumuon> are you able to avoid the traitional game loop pattern?
18:31:06 <sm> pff ignore those guys
18:31:10 <taumuon> traditional*
18:31:11 <EvanR> sure
18:31:31 <EvanR> if you look at gloss youll see its not a loop, it calls your callbacks
18:31:43 <taumuon> ok
18:31:50 <sm> last seen in #haskell-game: "sm" blather
18:31:50 <EvanR> much like youd do in js
18:32:14 <EvanR> which... actually makes a loop impossible
18:32:19 <sm> EvanR: is your demo pure gloss then ?
18:32:22 <EvanR> yes
18:32:36 <EvanR> but i have other projects that dont use gloss
18:32:46 <EvanR> like, SDL or cocoa
18:33:13 <sm> how are you finding the effort to results ratio ? improving ?
18:33:50 <sm> haskell game dev seems to be quite costly early on
18:34:02 <EvanR> setup seems about the same to me as in C
18:34:24 <sm> once you know haskell, right ? interesting
18:34:45 <EvanR> well, the bare library part is not much different
18:35:20 <EvanR> the question is of course what happens once you get into the game dev part
18:37:01 <EvanR> i believe many video game projects in C get to where they are via a short cut, the design pattern of throwing everything in global variables and controlling their mutation carefully
18:37:11 <EvanR> which haskell doesnt have
18:37:46 <sm> seems to work for them!
18:38:00 <EvanR> yeah...
18:38:08 <sm> but we could do the same I assume. We just choose not to
18:38:17 <EvanR> ive tried, its pretty bad
18:38:46 <EvanR> haskell doesnt make your stay at the global variable motel very comfortable
18:38:54 <taumuon> can i ask a question you guys are probably really sick of? Can you guess what it might be?
18:39:09 <EvanR> yes you can ask a question, no i cant
18:39:23 <sm> what's a good book to learn haskell!
18:39:27 <taumuon> what the bloody hell is a monad?
18:39:31 <sm> doh
18:39:59 <EvanR> i have a linked for that
18:40:01 <EvanR> link*
18:40:08 <taumuon> please!
18:40:26 <sm> https://leanpub.com/haskell-cookbook/read#leanpub-auto-tutorial-on-impure-haskell-programming
18:40:29 <EvanR> http://dev.stephendiehl.com/hask/#monads
18:41:30 <EvanR> Monad is some typeclass, so now you have to learn about type classes, might as well just learn haskell :)
18:42:55 <taumuon> all i can understand at the moment is that a monad is a magical box that you can do naughty things in
18:43:14 <taumuon> and that i have to become a maths professor to do basic things in haskell
18:43:26 <EvanR> right, thats not what it is
18:43:28 <geekosaur> that last is false
18:43:38 <EvanR> that is one of the myths
18:43:45 <geekosaur> you have to follow rules, certainly, but that's true of any language or programming environment
18:44:02 <geekosaur> the fact that ours sometimes have weird names is irrelevant
18:44:04 <taumuon> sorry i was being a bit facetious
18:44:25 <shapr> I put up the repo I'm using for teaching parsing tomorrow, any suggestions for improvement? https://github.com/shapr/sandsieve/blob/master/Main.hs
18:44:40 <shapr> taumuon: I've never finished a college math class :-(
18:44:52 <shapr> writing Haskell is much easier than math classes.
18:45:14 <shapr> oh wait! I passed trigonometry, never mind.
18:45:31 <EvanR> cool program
18:45:33 <taumuon> thanks for the links guys. Reading them now.
18:45:39 <c_wraith> trig? how? so much memorization. :(
18:46:15 <shapr> c_wraith: I was doing badly until Darius Bacon taught me Euler's Identity
18:46:32 <c_wraith> I think the only trig I remember is the law of cosines, and that's because I have used it so many times
18:47:05 <davean> shapr: I don't know what Haskell *you're* writing but lately my haskell looks a lot like math class, with more formalism :-p
18:47:12 <shapr> davean: lucky you
18:47:33 <c_wraith> davean, aren't you working on a basis for writing good numerical code? :P
18:47:55 <carter> i thought it was ed
18:47:58 <davean> c_wraith: that sounds more like carter, if by "work" you mean "wants to work on but never will"
18:48:03 <shapr> I will also point out I'm only using attoparsec because davean convinced me.
18:48:16 <carter> davean:  hey, i'm doing random stuff this week related to uniform sampling
18:48:25 <davean> carter: Link me to the hackage page!
18:48:27 <c_wraith> davean, oh, yeah. I was thinking of carter and failing to remember the right name.
18:48:58 <davean> c_wraith: Its pretty easy to keep us clear in your head, he's the insane one, I'm the crazy one
18:49:13 <c_wraith> davean, that's ludicrous
18:50:12 <carter> hehe
18:50:16 <davean> I've been working on formal distributed systes libraries that are composible
18:50:30 <carter> which was on my todo list at one point
18:50:32 <carter> in theory
18:50:40 <carter> now i just help davean sometimes instead
18:50:41 <carter> :)
18:58:54 <davean> You nap :-p
18:59:15 <davean> carter: talking about which, need better leader election options for networks with failure ...
18:59:53 <carter>  Sure.  Let me ship random soon firstssss ;)
18:59:56 <carter> Plz
19:02:18 <amalloy> tw
19:03:42 <shapr> Any good "parsing in Haskell" tutorials I should read before giving my lesson tomorrow?
19:05:22 <taumuon> is anyone familiar with this guy? https://www.youtube.com/watch?v=UIUlFQH4Cvo im enjoying his lecture series
19:06:29 <EvanR> yeah he is famous
19:06:37 <taumuon> is your lesson aimed at beginners shapr?
19:07:02 <taumuon> Erik talks about parsers in lecture 8
19:27:39 <taumuon> is there any way ghci can watch a project file and reload on change?
19:36:21 <EvanR> taumuon: that is a feature of "IDEs" like haskell mode
19:37:13 <taumuon> roger that Evan, thanks.
19:52:31 <sophiag> hi all. i'm wondering what priority queue libraries people like? there seem to be three in lts: PSQueue (seems to be the most popular), PQueue.Prio (likely out of the question for me due to speed concerns), and PriorityQueue.FingerTree
19:54:15 <sophiag> i should mention i don't need fancy custom comparators, but do need to store the values in two different orders. not sure if there's a way to cut down on overhead with that. one of the orders is naive enough i may just use a vector or sequence instead. and i'll probably wrap any data structures in a state monad for the interface
19:58:06 <geekosaur> note that a psq already uses two different orderings: priority and search key
20:01:30 <sophiag> that might be a downside actually. i'm just using it as a buffer so don't need lookup and definitely don't want to be sorting it. i figure i'll likely keep two copies, one for each order
20:02:56 <sophiag> psq seems the fastest though. unless i decide to just use vectors and deal with the insertion myself
20:02:57 <jle`> sophiag: for priority queues i usually use Data.Map from containers
20:03:09 <jle`> it's pretty optimized
20:04:23 <sophiag> jle`: yeah, it is. i would guess faster than psq
20:05:59 <jle`> it looks like the main API difference is that pqueue supports multiple items at the same key
20:06:09 <jle`> but for simplicity i usually just use Data.Map with NonEmpty
20:06:28 <jle`> Data.Map is probably fast enough that it won't be your bottleneck
20:06:43 <jle`> i wouldn't use psqueue because that sounds like the wrong data sturcture
20:06:49 <jle`> since it's a priority search queue
20:06:53 <jle`> and you just want a priority queue
20:07:36 <sophiag> yeah, you're right. i'm mainly comparing data.map to vector now, but i don't think vector could be faster if i need ordering
20:08:15 <sophiag> i can probably get away with either a vector or sequence for the order that's essentially order of arrival and data.map for the one that actually needs to be sorted on insertion
20:09:53 <EvanR> you could create a list in order using unsafeInterleaveIO
20:10:03 <EvanR> instead of appending to a sequence
20:11:24 <pavolzetor> is there way to speedup stack haddock command?
20:11:48 <sophiag> EvanR: eh, don't think i'll go that route
20:12:34 <EvanR> something about appending to a vector, even a mutable vector doesnt seem right
20:14:45 <sophiag> oh yeah. *facepalm*. i'd need to use a sequence instead :p
20:16:06 <EvanR> heres a silly idea... prepend stuff onto a list and also keep a counter of the lists size. then when you want a vector, turn the list into a vector backwards
20:16:45 <sophiag> eh...
20:17:28 <sophiag> actually the more i think about Data.Sequence PQueue.Prio seems more appealing
20:19:08 <sophiag> it seems odd to me that it would be faster given what i remember from okasaki, but i'm reading some stuff to that effect
20:27:29 <sophiag> ok, so i'm leaning towards Data.IntMap and Data.Sequence, each wrapped in a lazy State monad. old standards i guess
20:28:16 <ab9rf> often the simple solution turns out to be the best
20:28:28 <sophiag> true
20:28:33 <sophiag> plus i suppose asking these questions is a classic case of "why guess when you can test"
20:28:55 <ab9rf> as well as the hoary adage about avoiding premature optimization
20:29:05 <sophiag> that was knuth
20:29:18 <sophiag> and it always makes me feel like teenage darth vader from the star wars prequals
20:29:30 <ab9rf> nobody said that knuth was incapable of hoary
20:29:32 <sophiag> "you underestimate my power" lol
20:30:07 <ab9rf> good ol' darthy
20:30:23 <ab9rf> i was never a big star wars fan though
20:30:34 <ab9rf> never saw the prequels
20:30:44 <sophiag> you're not missing much
20:30:48 <sophiag> good memes tho
20:30:52 <EvanR> if programming languages were spacecraft from starwars
20:30:56 <ab9rf> EvanR: hah
20:31:02 <sophiag> anyway, tbh i have often been put off by haskellers defaulting to lists no matter what
20:31:19 <ab9rf> sophiag: the thing is, for a lot of things lists are fine
20:31:37 <sophiag> i get lazy lists are often fine, especially if you maintain backpressure
20:31:39 <ab9rf> because the runtime will never actually construct the list
20:31:39 <EvanR> a list as a priority queue... if youre usually inserting near the beginning
20:31:51 <sophiag> ab9rf: exactly
20:32:16 <sophiag> but i wish we could have an OverloadedLists extension
20:32:42 <ab9rf> ugh
20:33:06 <sophiag> there are plenty of times where, e.g. Data.Map, is a better choice but i see folks using lists instead. or mutable vectors inside worker loops, that's another "optimization" i would go ahead with
20:33:45 <EvanR> ive heard complaints about not having special syntax of some sort for Data.Map
20:34:12 <sophiag> yeah, i can agree with that
20:34:43 <ab9rf> EvanR: i've occasionally thought about that, but ultimately it doesn't bother me that much
20:35:17 <EvanR> but the thing is, special syntax for making a small fixed map, and lookups would help that much really
20:35:17 <ab9rf> a whole generation of programmers have been spoiled by all the perly languages that have a primitive dictionary type
20:35:45 <sophiag> that's one good thing you can say about scala
20:35:49 <EvanR> because Data.Map operations are usually more wholesale in nature, do a union, then intersection, then split
20:36:23 <sophiag> but as for special syntax, yeah i'd like to see more of it for data structure and less for combinators
20:36:31 <ab9rf> if i need a large constant map i just bury it in a submodule and import it where needed
20:37:11 <EvanR> one thing though is the need to import it and wrangle the qualifications
20:37:28 <EvanR> where you can just get started in say pythong
20:37:29 <ab9rf> haskell's module system is often annoying to deal with
20:38:27 <ab9rf> i have this one project i've been working on on and off for a year that i keep getting stuck on
20:38:48 <sophiag> probably also a good point that we use small maps less because of records
20:38:48 <sophiag> in a lot of dynamic languages maps/dicts also stand in for record types...
20:39:02 <ab9rf> invariably the solution comes to me while i'm falling asleep or something, but by the time i can get back to the computer or even just find a notebook and pen, i've lost it
20:39:41 <EvanR> right... we dont use Data.Map as special needs records
20:40:08 <EvanR> otoh we dont have proper records
20:41:18 <sophiag> lol
20:41:43 <sophiag> also using map instead doesn't get around the nesting problem. all those languages still have that
20:42:51 <sophiag> although tbh i always try to just avoid it by doing unknuth-y things like cheap key encoding schemes
20:43:56 <sophiag> if you can encode the structure you want in integers in a way that's cheap to work with and then use an IntMap you get flatness and ordering with faster insertion and lookup
20:44:05 <ab9rf> sophiag: i still occasionally hvave to talk people out of using anonymous tuples instead of a record type
20:44:08 <sophiag> and by integers i obviously mean Int
20:44:54 <sophiag> ab9rf: lol, i think i just wrote one of those even tho i know they're generally ill-advised
20:45:04 <ab9rf> i do it too sometimes
20:45:12 <ab9rf> and often end up paying for it later
20:45:15 <sophiag> oh, this was a type synonym tho
20:45:34 <sophiag> and all the same type. i would never due it in any other case
20:45:48 <EvanR> (\(a,b,c,d,e) -> (a,b,c,f d,e)) its so easy
20:45:59 <ab9rf> EvanR: haha
20:46:04 <sophiag> lol
20:46:51 <sophiag> if they're all the same type you can just index it with Control.Lens.Tuple
20:47:21 <sophiag> then it's like having a short list you've guaranteed the length of
20:47:32 <EvanR> groundbreaking
20:49:31 <sophiag> sadly, it sort of is groundbreaking when you use languages where all your errors are like those and it would be a PITA to automate checking them so you don't
20:51:03 <ab9rf> now i have one of those long-running projects banging around in the back of my head with this vague "if you do it this way it'll work trust me!" and the other voice is going "ha! you know that won't work! you tried that last year and it didn't!"
20:51:21 <ab9rf> i need either more or less booze
20:52:02 <EvanR> yep i have run into counless crazy schemes in haskell that ended up failing miserably
20:52:19 <ab9rf> i've never got any of these to actual code
20:52:32 <ab9rf> i usually can't even figure out what the crazy data structure that i dreamt up actually looks like
20:52:37 <EvanR> it sort of makes me feel timid, only go for tried and true boring strategies
20:53:50 <ab9rf> hm, an idea just struck me
20:53:52 <ab9rf> need to find paper
20:54:08 * EvanR hands ab9rf a roll
20:54:30 <dfeuer> You know the old one about the tools of a mathematician's trade being paper and pencil, meaning they always have to borrow a pen to scribble on a napkin.
20:57:50 <ab9rf> and i lost it
20:58:11 <ab9rf> becuase the washer beeped at me, and i had to transfer laundry, and while i was doing that my head was taken over by a traveling wilbury's song
20:58:39 <sophiag> yikes, sorry for your head
20:58:41 <sophiag> :)
20:58:51 <ab9rf> eh, at least roy orbison sounds good
20:58:53 <ab9rf> :)
21:01:12 <batman_> Codec.Serialise.deserialise is giving me Left (DeserialiseFailure 0 "expected null")
21:01:45 <batman_> i have passed a = Codec.Serialise.serialise "somestring" to it
21:04:04 <ab9rf> obviously, it expected null
21:04:36 <EvanR> maybe how it deserializes is affected by what type you are expecting
21:04:55 <EvanR> > read "()"
21:04:57 <lambdabot>  ()
21:05:03 <EvanR> > read "3"
21:05:06 <lambdabot>  *Exception: Prelude.read: no parse
21:05:49 <ab9rf> serialize should be able to serialize anything
21:06:07 <ab9rf> well, aything with a Serialise instance :)
21:06:42 <dibblego> what ever happened to lambdabot "Yes! Haskell can do that." ?
21:06:55 <EvanR> it was voted off the island
21:07:33 <batman_> guys : is Serialise even a good and stable package >>??
21:07:44 <EvanR> never heard of it
21:08:06 <EvanR> were you looking for Binary
21:08:13 <batman_> EvanR : what are suggestion for serialisation package >>?
21:08:25 <ab9rf> last commit on github was 18 days ago, so the dev isn't dead
21:10:57 <jle`> batman_: oh, it looks like it's the package formerly known as binary-serialise-cbor
21:11:14 <jle`> which was considered 'good'
21:11:25 <EvanR> interesting
21:11:33 <jle`> its maintainer is dcoutts so it's probably a quality package
21:11:55 <EvanR> batman_: i have a feeling you are specifying the wrong type to deserialize to
21:12:48 <ab9rf> the docs are at least well-written
21:12:55 <jle`> batman_: yeah, it's hard to say what is wrong without more detail
21:12:59 <batman_> EvanR : i just mentioned that i serialised it using the provided serialised function and for my own satifaction i checked the type for both and it matches
21:13:00 <jle`> about what you are doing
21:13:03 <ab9rf> i've never used it, but it's rare that complete crap packages have well-written documentatin
21:13:29 <jle`> can you show code?
21:13:40 <ab9rf> batman_: deserialize cannot infer the type from the binary blob
21:13:51 <EvanR> batman_: i see you can serialize fine... i was talking about deserialization
21:14:42 <jle`> batman_: if you are serializing a stirng, make sure you are deserializing it as a string
21:14:44 <jle`> using a type annotation
21:14:46 <jle`> or something
21:15:19 <jle`> > (read . show) 3
21:15:21 <lambdabot>  *Exception: Prelude.read: no parse
21:15:25 <jle`> > (read . show) 3 :: Int
21:15:28 <lambdabot>  3
21:16:41 <batman_> jle` : you were right enforcing the type using :: String worked
21:16:52 * EvanR no respect
21:17:23 <jle`> it's not really enforcing so much as giving ghc any way of figuring out what you want
21:17:27 <batman_> jle` : thank you, so what do you think is it a good lib to use for serilization or there are some other options ??
21:17:44 <jle`> you could have also used it as a string somewhere else, and type inference would have helped :)
21:18:08 <jle`> cbor is solid and has a lot of benefits, but there are a lot of different options for serialization
21:18:20 <jle`> each with different drawbacks and benefits
21:19:03 <jle`> the one i usually use is binary, or cereal
21:19:13 <jle`> but 'store' is a new-ish one that has some nice benefits too
21:19:35 <jle`> either of them are probably fine unless you have some really specialized requirement
21:19:40 <jle`> s/either/any
21:19:46 <Squarism> reading about "stack test --coverage" at  https://docs.haskellstack.org/en/stable/coverage/ says "These test-suites link against your library, rather than building the library directly." . What does that mean really? Not having library in "build depends" or no?
21:20:02 <Squarism> build-depends:
21:20:03 <ab9rf> cbor is useful if you specifically need to use RFC 7049 serialization for some reason
21:20:41 <Squarism> oh.. it explained it below. nvm
21:21:05 <batman_> jle` : so are you saying serialise is good lib and is well maintained ??
21:22:31 <jle`> i haven't used it myself but i've heard just as much
21:23:03 <jle`> it's probably not the most widely used library but it's probably fine unless you have some specialized requirements
21:24:42 <batman_> jle` : as for requirements i would say i would prefer a lightweight format so which lib implements that also which is the most widely used one ??
21:25:00 <batman_> jle` : sorry for packing so many questions into one :P
21:25:52 <EvanR> binary's default formats are not really implemented by anybody else
21:25:58 <EvanR> maybe youre looking for JSON
21:25:59 <geekosaur> re that mathematicians' tools thing... I have snark about (day)dreams needing a flight recorder in one local file.
21:28:54 <dfeuer> Could someone help me figure out what form of https://stackoverflow.com/questions/48954495/is-it-possible-to-get-all-contexts-of-a-traversable-lazily  (if any) would be a good fit for lens?
21:29:24 <dfeuer> (Or another package? For that matter, has someone else already written this?)
21:30:20 <batman_> EvanR : i have a custom data type which uses Network.Socket so i if i'm writing an instance to serialise my type and Network.Socket.SockAddr is not already instance of that i class i need to write it myself right ????
21:30:35 <EvanR> yes
21:30:50 <parsnip> what do you do in python if you want Maybe (Maybe Bool). i think None won't work there. so maybe i use Maybe Int, with 1, 0, -1, and None
21:31:34 <EvanR> in js i have done, {just: {just: true}}, {just: null}, null
21:31:44 <ab9rf> batman_: you may well have to write a custom instance for SockAddr; i doubt many existing libs provide a serialization instanec for that
21:31:55 <ab9rf> that could be hard since SockAddr is a pretty opaque type
21:33:01 <ab9rf> hm, i guess in Network.SockAddr it's a simple algebraic so deriving an instance shoud be easy
21:33:28 <ab9rf> i've spent too much time in low-level network code, where you can't assume much of anything about a sockaddr
21:33:35 <ab9rf> "it's this long and contains stuff"
22:19:48 <Phyx-> dibblego: Windows does support ANSI codes, anyway you'd want something like we did in GHC https://github.com/ghc/ghc/blob/master/compiler/main/SysTools/Terminal.hs#L35
22:21:05 <dibblego> Phyx-: ok thanks, I will have a look
22:33:16 <xacktm> does anyone know what happens when you run `cabal exec ihaskell install` ?  does jupyter use the packages installed in the cabal sandbox?
22:42:47 <batman_> can someone please help me with this error : http://lpaste.net/362932
22:46:55 <guest_> hi guys I was trying to use Raaz Crypto Library's randomByteString function `str = securely (randomByteString (40 :: BYTES Int) :: RandM ByteString)` it return type is `IO ByteString`, how do I convert it to ByteString type?
22:49:43 <cocreature> batman_: you need to provide an explicit implementation since the default instance relies on Generic and apparently there is no Generic instance
22:50:21 <cocreature> guest_: you don’t, you use do notation/>>= to build other IO actions on top of it.
22:50:53 <cocreature> guest_: see https://www.vex.net/~trebla/haskell/IO.xhtml for a more detailed explanation of how you use IO in Haskell
23:02:23 <batman_> cocreature : http://lpaste.net/362933 it says PortNumber is not part of Network.Socket but it is infact there in their documentation and i can use it with ghci
23:06:57 <jchia> batman_: You need to distinguish between type constructors and value constructors
23:07:16 <cocreature> specifically the value constructor is called PortNum in this case
23:08:25 <gestone> so i see there are conditional monadic computations with methods like when and unless
23:08:42 <jchia> batman_: I see that PortNum is deprecated, so practically, you should use something like fromIntegral.
23:08:54 <gestone> is there a function with type sig (Monad m) => Bool -> m () -> m () -> m ()?
23:09:16 <gestone> it would be sort of like when, but its implementation would be like:
23:09:36 <gestone> ifThenElse p s t = if p then s else return t
23:09:51 <cocreature> gestone: that doesn’t typecheck
23:10:13 <gestone> oh whoops not return t
23:10:16 <gestone> just t
23:10:23 <dminuoso> gestone: it's called `if/then/else`
23:10:28 <cocreature> not sure what the advantage over just using if is
23:10:30 <cocreature> there is "bool"
23:10:34 <gestone> fair enough
23:10:36 <cocreature> but note that it flips the arguments
23:10:55 <cocreature> so "ifThenElse b = flip (bool b)"
23:12:26 <gestone> where is bool located?
23:12:40 <cocreature> http://hoogle.haskell.org/?hoogle=bool
23:12:47 <ab9rf> bool smells
23:12:49 <cocreature> oh I got the argument order wrong apparently
23:13:07 <cocreature> I guess that shows how often I use it compared to regular if then else :)
23:14:22 <dminuoso> cocreature: In HOFs such a function could be more elegant though, no?
23:15:04 <cocreature> dminuoso: dunno, I don’t find lambdas “inelegant”
23:15:42 * dminuoso hides his tacit programming booklets
23:16:00 <dminuoso> Yes, lambdas are just fine!
23:17:01 <dminuoso> cocreature: I guess in the end I shouldn't be that scared. After all I dont think you can do pattern matching without naming points.
23:17:08 <cocreature> I mean sure it can save you a few characters but it’s not like I’m limited by typing speed when programming
23:17:26 <cocreature> dminuoso: you can with LambdaCase
23:17:52 <dminuoso> cocreature: Well, that's kind of naming them in the case patterns still.
23:18:56 <cocreature> you’re naming something different. e.g. if the constructors don’t take arguments then you don’t name anything
23:19:29 <batman_> cocreature : what does <>,<*>, & <$> operators mean in haskell
23:20:00 <cocreature> batman_: have you tried looking at the documentation? :)
23:20:16 <dminuoso> Mmm, what was the hoogle alternative?
23:20:22 <cocreature> hayoo
23:20:56 <dminuoso> cocreature: Ah thanks. Was asking because hoogle at least didn't list <>
23:21:14 <cocreature> dminuoso: http://hoogle.haskell.org/?hoogle=(%3C%3E)
23:21:38 <dminuoso> cocreature: Interesting. https://www.haskell.org/hoogle/?hoogle=%3C%3E
23:21:43 <dminuoso> Are these different hoogle versions?
23:21:58 <cocreature> yes hoogle 5 vs hoogle 4
23:22:43 <cocreature> the only reason to use hoogle 4 is slightly better type search in some cases. apart from that hoogle 5 is superior in every way
23:22:50 <cocreature> I haven’t used hoogle 4 in ages
23:23:05 <batman_> cocreature : yeah but they are not clear so i thought i might get a better explanation here
23:23:38 <cocreature> batman_: <> = mappend, <$> = fmap
23:24:26 <cocreature> batman_: all of those operators are typeclass methods so you’ll have to look at how they work for specific instances
23:26:34 <cocreature> I don’t have time right now to walk you through it but maybe someone else can.
23:27:24 <batman_> cocreature : what do you mean by typeclass methods ??
23:27:33 <cocreature> :t (<>)
23:27:34 <lambdabot> Monoid m => m -> m -> m
23:27:55 <cocreature> the implementation for that function is defined by the Monoid instance for m
23:28:00 <dminuoso> batman_: To understand <> you just have to understand what a monoid is.
23:28:16 <dminuoso> batman_: I guess in a way the same applies to the other operators and their respective typeclasses as well
23:31:53 <dminuoso> cocreature: Gotcha. I didn't realize they had the version listed at the bottom. They looked so similar apart from the URL. :)
23:32:55 <cocreature> dminuoso: yeah it’s a bit confusing. the big “alpha” disclaimer on the hoogle 5 website also doesn’t help since at least for my usecases it is significantly more useful than hoogle 4
23:36:22 <dminuoso> batman_: A monoid is just a set of elements with a binary associative operation that is closed over the set, with a left and right identity. (<>) is that operation (in mathematics usually denoted either (*) or (+)), with mempty as the left and right identity.
23:36:41 <dminuoso> batman_: Since one way to look at a type is a `set of values`..
23:39:59 <dminuoso> So what might be (G, ∘, 0) in mathematics, could be denoted as (Monoid m => m, (<>), mempty)
23:47:19 <parsnip> classes are sets of types!
23:47:33 <parsnip> but they overlap
23:47:39 <parsnip> like gmail labels
23:47:54 <cppxor2arr> haha gmail labels
23:48:08 <parsnip> gmail labels ruined email
23:50:25 <dminuoso> parsnip: Wait a second...
23:50:33 <dminuoso> parsnip: Is this actually the reason why classes are called classes?
23:50:37 <dminuoso> In Haskell I mean.
23:51:15 * dminuoso is already feeling the blowing of his mind
23:57:24 <dminuoso> parsnip: What I mean is, is `class` used in the sense of set theory?
