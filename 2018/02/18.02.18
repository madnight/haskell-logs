00:02:09 <u-ou> moo
00:12:59 <qeyoa> u-ou: moo
00:13:50 <u-ou> moo :)
00:13:57 <lambda-11235> μ
00:22:11 <u-ou> bedtime :O
00:41:02 <maybefbi> how do i get atom's plugins use stack exec paths?
00:41:39 <maybefbi> i did a stack build --copy-compiler-tool ghc-mod hoogle weeder hlint stylish-haskell cabal-install intero
00:42:04 <maybefbi> so now ghc-mod is here stack exec -- ghc-mod
00:42:23 <maybefbi> i want atom to use stack exec -- which ghc-mod
00:45:30 <qeyoa> what paths are they using by default
00:45:52 <maybefbi> they are just using what is inside $PATH
00:46:02 <maybefbi> they use node's spawn
00:46:36 <maybefbi> but for me ghc-mod changes based on stack's resolver
00:46:57 <maybefbi> current stack project's resolver
00:47:23 <maybefbi> so i put everything in  --copy-compiler-tool directory
00:51:49 <maybefbi> its ok let me try with direnv tool in my shell
00:54:20 <qeyoa> well, i never used atom for haskell, but i had some problems with emacs and haskell's tidal not finding ghci since i compiled stack. So i just made a bash script called ghci, with `stack ghci --gci-options $*` and added the folder with this bash  script to the $PATH
00:55:59 <maybefbi> ok
01:38:36 <ian5v_> hiya! what's the meaning of '--|'? (hard to google :)
01:39:06 <ian5v_> parse error in ghci, a friend tells me that -- | is a haddock comment
01:40:22 <anohigisavay> ian5v_, `-- |` is haddock comment, while --| is not
01:41:10 <ian5v_> anohigisavay: could that mean that --| just parse errors so that we're not accidentally typing "--|" when we mean "-- |"?
01:41:29 <anohigisavay> ian5v_, --| can be an operator, i.e. you can define it
01:41:46 <ian5v_> ooh i don't know anything about custom operators
01:41:47 <ian5v_> exciting c:
01:43:01 <anohigisavay> ian5v_, i didn't know it myself either xD
01:43:09 <anohigisavay> tried randomly in ghci
01:43:41 <anohigisavay> anyone using vscode? how can i configure it to properly indent continuation lines of data definitions?
01:44:08 <anohigisavay> i.e. align `|` with `=` in the above line
01:44:20 <anohigisavay> or `,` with `{`
01:45:09 <anohigisavay> now i can only indent by a factor of tab width, i.e. 2, 4, 6, 8...
01:45:47 <remix2000> I have a aeson object. I want to replace value by key (with 'lens-aeson').How can i do that?
01:59:04 <anohigisavay> did i miss something?
02:05:48 <[exa]> remix2000: most probably something like this:  object ^? key "theKey"
02:11:12 <remix2000> [exa]: I wanted to shorten the text in post object ({ 'content': 'abcdef...', ...etc }): shortenPost post = key (T.pack "content") . _String %~ (T.pack . take 320 . T.unpack) $ post
02:47:31 <freeman42x]NixOS> any ideas why I am getting a pattern matching error here? http://lpaste.net/2942386784870334464
02:50:24 <geekosaur> you have one value whose *type* is (f b a). You can't decompose a value into individual types
02:52:01 <geekosaur> er, (g b a)
02:58:47 <freeman42x]NixOS> geekosaur, I don't get how I am supposed to implement fmap then
03:05:31 <cocreature> freeman42x]NixOS: you can’t implement fmap without knowing anything about f
03:06:02 <cocreature> you are going to put some constraint on f that allows you to perform the operation
03:06:10 <cocreature> +to need
03:06:54 <freeman42x]NixOS> cocreature, oh, that makes sense... I think, going to try something
03:13:53 <asheshambasta> So… I'm working on a small-ish Haskell program that needs to do some slightly complex things depending on its state: eg. connect to RabbitMQ & start an http server based on the presence of a "credentials" file in some folder it is watching. I've been reading this https://stackoverflow.com/questions/15467925/maintaining-complex-state-in-haskell and was wondering if there's a simpler way to approach this in Haskell (I'm new to Haskell
03:13:53 <asheshambasta> o I'd first like to be focussed on learning the language than learning its sub-domains like FRP). Or am I missing something by asking this question?
03:16:36 <boj> asheshambasta: if you are simply tracking state then no, you don't need to go off into crazy FRP land
03:17:59 <asheshambasta> boj: okay, phew. But whats the _simpler_ way to tackle my kind of problem?
03:18:12 <cocreature> asheshambasta: often state is just stored in an MVar or TVar
03:19:22 <boj> asheshambasta: holding your state data type in a TVar from the STM library is a nice way to go
03:20:38 <asheshambasta> cocreature, boj: thanks, I'll read up on that.
03:25:22 <freeman42x]NixOS> cocreature, the constraints would be similar to the way I did it here? http://lpaste.net/8928231191467786240
03:26:36 <cocreature> freeman42x]NixOS: depends on what you mean by “similar”. a “Functor f” constraint is not going to cut it :)
03:27:16 <cocreature> freeman42x]NixOS: try figuring out the type signature of the operation you want to perform on "f b a"
04:05:36 <nullie> how can I find latest lts for ghc-7.10.3?
04:07:33 <cocreature> nullie: https://www.stackage.org/ lists the latest lts per ghc version at the bottom left
04:07:56 <nullie> ah, thanks
04:15:31 <tsahyt> given a sum type in which each alternative has a field of a certain type, how would I construct a lens (getter) to always retrieve that field?
04:15:49 <tsahyt> to make this a bit more complicated, in one alternative this field is nested in a record
04:26:11 <tsahyt> e.g. data Foo = Foo Text | Bar Quux; data Quux = Quux { quux :: Text }, I'd need a getter for the Text fields
04:26:25 <tsahyt> I suppose I could just use to and a custom function, but is there a way to construct this from generated lenses?
04:28:39 <hello-world-abou> hello
04:46:42 <joe9> I have been off haskell for a while. Just want to check if cabal has taken over from stack?
04:48:12 <nullie> I can't parse that you said, but looks like stack is used everywhere
04:49:40 <gems> Hey!
04:49:52 <joe9> nullie: last year, there was talk about cabal being able to do whatever stack is doing now. not sure if that has happened yet.
04:50:03 <maerwald> joe9: definitely not
04:52:22 <gems> I am new to FP and was wondering what language to choose. Haskell looks like it has a big community and great support. Why do you guys love haskell?
04:55:40 <liste> gems: haskell is quite unique (if you don't count some fringe languages) in that it's the only language with referential transparency and lazy evaluation
04:55:55 <liste> those make an enormouse difference in the programs you write
04:57:01 <Phyx-> joe9: hell no..
04:57:09 <joe9> gems: haskell is pure and it is a good help to learn fp. Once you get good with fp programming, it will be an easier jump to any of the impure languages.
04:57:36 <maerwald> gems: to chose for what
04:58:01 <maerwald> there are more interesting languages feature-wise, but they don't have the same traction in terms of ecosystem, support etc
04:58:05 <liste> gems: in Haskell, in general, you can replace function calls with their definitions, like if "f x = p x + q x", you can replace "f (a b)" with "p (a b) + q (a b)"
04:58:19 <bontaq> learning it is like to going to the well-spring for a lot of functional ideas put into other languages.  i feel future-proofed.  plus you can dive deeper into comp sci papers
04:58:26 <liste> gems: that way you can reason about your code in whole another level
04:58:52 <gems> hmm
04:59:16 <liste> gems: calculate the results of function calls manually just like they were mathematical equations
04:59:31 <maerwald> just point him to a tutorial
04:59:48 <gems> What about the community, you guys seem responsive
05:00:21 <liste> the community is great
05:00:29 <joe9> community is a big bonus. The most helpful there is.
05:00:30 <liste> gems: do the "Try it!" tutorial here https://www.haskell.org/
05:00:37 <liste> that gives some idea on the language
05:00:40 <gems> I already did haha
05:01:05 <gems> I can oldy do the very basics though, took me 3 hours to make a insertion sort funtion
05:01:10 <gems> only*
05:01:17 <maerwald> If you just care about the language, Idris, Agda or F* might be way more interesting to you
05:01:23 <maerwald> but they don't have an ecosystem like haskell
05:01:46 <gems> I was thinking about OCaml too, and maybe erlang/elixir
05:02:05 <maerwald> Those are more useful to get a job, that's for sure
05:02:26 <gems> I'm not doing this for a job, I just want tolearn more
05:02:34 <maerwald> but they don't adhere to the purity concept the way haskell does
05:03:02 <maerwald> purity is not necessary for a language to be functional, but it feels more "mathematical" if it does
05:03:17 <gems> Hmm, what is so great about purity anyway? And how can a language be 100% pure?
05:03:43 <maerwald> gems: see http://staffhome.ecm.uwa.edu.au/~19115656/key_papers/Sabry%20-%201998%20-%20What%20is%20a%20purely%20functional%20language.pdf
05:03:59 <gems> Like, for networking and stuff. Wont you have to use mutable variables for that?
05:04:18 <maerwald> don't confuse purity with language features :)
05:04:31 <gems> Ok
05:04:34 <maerwald> we have mutable variables
05:04:38 <maerwald> but, different
05:06:23 <maerwald> it's less about what language featuere there are, but about what is the preferred way to solve problems and how does the language help you with that
05:06:49 <gems> Ohh
05:06:52 <gems> That makes sense
05:07:06 <gems> So each language promotes a way of thinking
05:07:13 <maerwald> Well...
05:07:33 <maerwald> C++ certainly doesn't, it just dumps all possible language features in front of you and you basically assemble your own language :P
05:07:42 <gems> Haha true
05:08:10 <gems> But in context to FP languages
05:09:11 <maerwald> a purely functional language certainly promotes a very specific way of thinking
05:09:16 <[exa]> guys, C++ promotes a way of thinking
05:09:29 <[exa]> but it's like "steroid-boosted macro assembly"
05:09:53 <gems> Haha
05:10:09 <maerwald> I don't like to be exposed to compiler details. That's a sign of a bad language
05:10:09 <gems> C is steroid-boosted macro assembly
05:10:22 <gems> Really?
05:10:35 <gems> I find that useful for debugging
05:11:07 <[exa]> maerwald: tbh typeclasses arose as a tradeoff between compiler details
05:11:30 <maerwald> what I mean is that, in order to really understand a feature, I have to understand how it was implemented
05:11:37 <maerwald> which is the case for e.g. Java Generics
05:11:43 <gems> When reading up oh haskell, I got confused by typeclasses, what are they exactly
05:12:00 <maerwald> in C++ you have to know how everything is implemented
05:12:07 <maerwald> otherwise you will hit weird corner cases
05:12:15 <[exa]> maerwald: which is kindof expected from a _programmer_
05:12:18 <maerwald> no.
05:12:20 <[exa]> the point is it's 2018 now
05:12:37 <maerwald> I am talking about language features
05:13:01 <maerwald> if I have to understand how the compiler has implemented that feature to understand the feature, then the language itself is misdesigned
05:13:01 <[exa]> ok maybe I misunderstood that
05:13:02 <gems> I am super confused
05:13:43 <[exa]> gems: the typeclasses are just predicate-like statements about collections of types.
05:14:04 <gems> Ohh, kinda like OCaml modules?
05:14:15 <[exa]> gems: if the language thinks "Num ttttt", it means that ttttt is in typeclass Num, which means that it can act as a Number (+, *, negate, ...)
05:14:20 <maerwald> [exa]: and actually, laziness kind of does that
05:15:00 <gems> Ohh, most languages have that
05:15:47 <[exa]> gems: it's nothing special in fact, but you can do much useful stuff in Haskell with that
05:16:15 <[exa]> gems: if you know OO languages, typeclasses would be the interface-level layer of parent classes that everyone's deriving
05:16:40 <[exa]> except there are no objects
05:16:50 <gems> I never really worked with programming languages directly, I'm a sys admin
05:16:52 <maerwald> but isn't haskell inherently OOP? :P
05:17:34 <[exa]> gems: lucky you. :]
05:17:47 <gems> Ha
05:18:30 <gems> I'm planning to move my division to NixOS, but to do so, I want some background in FP before telling my team to start using a functional distro
05:18:43 <maerwald> what?
05:18:49 <maerwald> that's totally orthogonal
05:19:18 <gems> How so?
05:20:05 <maerwald> I don't know. They have pretty much nothing to do with each other
05:20:22 <[exa]> nixos is declarative, the point that it's implemented functionally is kindof unrelated
05:20:41 <maerwald> [exa]: what do you mean with "implemented functionally"
05:21:21 <gems> It has some functional properties like it having immutable packages
05:21:23 <[exa]> wait nixos isn't implemented in haskell?
05:21:29 <maerwald> C++
05:21:33 * [exa] learns the ugly truth
05:22:19 <maerwald> "functional package manager" is basically just advertisement terminology and doesn't mean much beyond "it's declarative and you can have (kind of) reproducible configurations"
05:23:27 <maerwald> and since there are distro agnostic tools that can do that already...
05:23:27 <gems> Ohh, I though that because of the packages being immutable and the state never replacing itself
05:24:13 <gems> Welp, I'm sorry I wasted you time, I still am probably going to learn haskel though
05:24:23 <maerwald> it takes a lot of effort
05:24:58 <gems> Well, we will se.
05:25:03 <gems> Sorry again
05:25:08 <maerwald> huh? :o
05:29:22 <qeyoa> maerwald, is your nick from POE?
05:29:55 <ddk> Hello all ... have a good morning or night !!
05:31:22 <ddk> well I am totally new to web programming, I know and love Haskell, I have to write a simple web-app ...how should I proceed... can you please guide with the libraries
05:31:56 <maerwald> qeyoa: obviously
05:32:06 <qeyoa> highfive
05:32:14 <maerwald> o/
05:32:37 <remix2000> How can I shorten this function? https://github.com/remi6397/remi6397.github.io-generator/blob/8968d6cadaba8ea02cf4aea8e5753b207c674252/src/Main.hs#L79
05:33:17 <ddk> hello !!
05:34:46 <lyxia> remix2000: authorMap = ... . map (\post -> (author post, [post])) postList
05:35:34 <ddk> well I am totally new to web programming, I know and love Haskell, I have to write a simple web-app ...how should I proceed... can you please guide with the libraries
05:38:48 <lyxia> remix2000: M.toList $ M.mapWithKey makeAuthor authorMap
05:39:09 <remix2000> lyxia: thanks. That's not clear at the moment you are concentrating on writing a program that should do something. :D
05:39:32 <ddk> well I am totally new to web programming, I know and love Haskell, I have to write a simple web-app ...how should I proceed... can you please guide with the libraries
05:40:26 <bennofs[m]> Is there a standard solution to the problem of depending on native libraries that may have pkg-config files, but also may not? last I checked cabal hard-depends on pkgconfig being available if you specific pkgconfig-depends
05:40:29 <lyxia> remix2000: what is not clear?
05:41:20 <lyxia> ddk: you don't need to paste the same message once every 5 minutes to be read.
05:41:48 <kuribas> I implemented breadth first search with lenses.  It gives the right results but then hangs.  Any idea how to fix this?  http://lpaste.net/362621
05:42:04 <remix2000> lyxia: Now I'm thinking what M.mapWithKey does and what should be the content of authorMap
05:42:39 <ddk> lyxia: I 'm pasting bcoz no-one is responding to my question :_)
05:43:05 <recursion-ninja> How do I get cabal to link to the mono-traversable package when generating documentations? When I run the command "cabal haddock --for-hackage --haddock-option=--hyperlinked-source" I get the message "Warning: The documentation for the following packages are not installed. No links will be generated to these packages: mono-traversable-1.0.8.1". Do I need to reinstall the source with some special
05:43:11 <recursion-ninja> flags or something?
05:43:29 <maerwald> bennofs[m]: what do you mean with may or may not?
05:43:47 <kuribas> ddk: I find beam nice for db access.
05:44:07 <maerwald> I suspect you are talking about distros adding pkg-config files on their own, which is fundamentally a bad and wrong thing. In that case I'd only care what upstream does
05:44:12 <bennofs[m]> i mean that some distributions have old packages or package it without pkg-config. Also, pkg-config itself is not available on some of the target systems
05:44:36 <bennofs[m]> so there should be a way to supply overrides even if you don't have pkgconfig, but the package specifies some pkgconfig-depends
05:44:38 <ddk> kuribas: can you tell me about whole setup, I'm totally new to web dev field
05:44:59 <kuribas> ddk: there are many options, yesod for example.
05:45:13 <kuribas> ddk: https://www.yesodweb.com/
05:45:24 <bennofs[m]> maerwald: looking to resolve this PR: https://github.com/keera-studios/hcwiid/pull/4
05:45:39 <kuribas> ddk: I heared good things about servant
05:45:41 <lyxia> kuribas: bfs' recurses infinitely
05:45:54 <kuribas> lyxia: yeah.  I don't know how to fix it though...
05:46:21 <maerwald> bennofs[m]: doing it properly would just be switching Build-Type to custom imo and writing a Setup.hs that deals with all cases
05:46:22 <ddk> kuribas: yes I saw there are many options and that's one of my biggest problem, to choose between them, I want to go for simplicity and ofcourse not with the older ones
05:47:13 <lyxia> kuribas: bfs' = leaf <> (children_ . bfs'),   no need for id'
05:47:17 <bennofs[m]> maerwald: but then it's not obvious from the metadata what the package depends on which also sucks
05:47:33 <kuribas> lyxia: I tried that, it gives a depth first search
05:47:34 <bennofs[m]> it also goes against the cabal solver, as the solver won't know the native deps of that package
05:47:48 <lyxia> kuribas: ah my bad.
05:47:50 <maerwald> bennofs[m]: can you not use fields from the cabal file in Setup.hs? Pretty sure you can
05:48:18 <kuribas> lyxia: I don't even know if it's possible, it is just an experiment
05:56:20 <lyxia> kuribas: I see. It seems to be missing a conditional construct
05:57:05 <lyxia> a kind of thing that doesn't play too well with lenses
06:01:07 <kuribas> how can I make a duplicate of a lens with a specialized type?
06:01:46 <lyxia> cloneLens?
06:01:49 <Gurkenglas> What do you mean, a duplicate? You just specialize it
06:02:06 <Gurkenglas> If you need to specialize it two different ways, specialize it to ALens and cloneLens that
06:02:26 <Gurkenglas> (to get two general lenses which you can each specialize)
06:02:53 <kuribas> does that work with a Getter?
06:03:27 <lyxia> no
06:14:50 <kuribas> it doesn't work with a conditional either: http://lpaste.net/362621#a362622
06:18:08 <lyxia> kuribas: bfs' trees f s = if hasn't trees s then (pure s) else (trees . leaf <> bfs' (trees . children)) f s  ?
06:19:17 <recursion-ninja> How do I get cabal to link to the mono-traversable package when generating documentations? When I run the command "cabal haddock --for-hackage --haddock-option=--hyperlinked-source" I get the message "Warning: The documentation for the following packages are not installed. No links will be generated to these packages: mono-traversable-1.0.8.1". How do I install the documentation for ths package?
06:21:41 <kuribas> lyxia: right, and tree needs to be rank 2
06:35:46 <kuribas> lyxia: hm, it seems easier to implement the bfs without lenses, and use them only as field accessors.
06:45:19 <danilo2> Hi guys! Im wonderign if I can do something like this. I want to create Storable nstance for my structure, which has several fields. However, while poking it I dont watn to poke every field unless they are really needed. I can guarantee that this structure will not mutate on other thread and that it is just constant in memory.
06:45:54 <danilo2> So, If it Looks like `data Foo = Foo !Int !Int !Int !Int` when I poke it I would like not to poke all the Ints, but only the ones that I will really acess later
06:57:32 <kuribas> lazy poke?  I don't think that's possible
07:04:49 <hask_bee_3> Is anyone here using Stack's Nix integration?
07:05:08 <lyxia> kuribas: it is
07:05:49 <hpc> not with a strict data type like that though
07:06:01 <kuribas> lyxia: are refering to my bfs?
07:08:23 <danilo2> kuribas: I dont think "lazy poke" is the good description here, but something like that. Namely telling Haskell - here is pointer for the beginning of the memory. You dont have to do anything with it, its constant and has good format for you
07:08:46 <kuribas> danilo2: a bytestring?
07:08:59 <kuribas> a bytestring is just binary data.
07:09:30 <danilo2> kuribas: again, sometihng along the lines. However I want to keep Haskell datatype there and be able to access its fields
07:10:13 <kuribas> danilo2: why do you want to do that?  Performance?
07:10:16 <hask_bee_3> I've got a question about https://docs.haskellstack.org/en/stable/nix_integration/
07:10:16 <hask_bee_3> They give this example of how to use Nix in stack.yaml:    packages: [glpk, pcre]
07:10:38 <hask_bee_3> Why would anyone want to do that? That doesn't specify the versions of glpk and pcre. Isn't the whole point of Nix to clearly define versions?
07:10:44 <danilo2> kuribas: yeah, Im considering how we can achieve the best possible performance usign very low level haskell
07:11:34 <kuribas> danilo2: I wouldn't look at storable first for performance.
07:11:44 <kuribas> there's a cost with marshalling.
07:11:57 <kuribas> unless you need to use a high performance C library.
07:12:38 <kuribas> But in that case I would just avoid many calls to C, and perform few calls which do more work.
07:12:42 <danilo2> kuribas: I need to implement high performance graph, which can be modified across different threads, so the best way I see I can do it now is to use Foreign.Ptr to store nodes
07:13:42 <recursion-ninja> How do I get cabal to link to the mono-traversable package when generating documentations? When I run the command "cabal haddock --for-hackage --haddock-option=--hyperlinked-source" I get the message "Warning: The documentation for the following packages are not installed. No links will be generated to these packages: mono-traversable-1.0.8.1". How do I install the documentation for ths package?
07:14:24 <kuribas> danilo2: this graph is written in C?
07:14:34 <danilo2> no, it can be written in HS
07:14:55 <kuribas> then I wouldn't use storable.
07:15:15 <kuribas> I'd try something in haskell first, using mutable ptr/vector if it has to.
07:15:16 <danilo2> kuribas: what would you use then? To have mutable high performance graph across threads?
07:16:33 <danilo2> kuribas: Mutable vector uses storable as well if you want high performance and unboxed things
07:16:50 <kuribas> STRef?
07:17:16 <danilo2> kuribas: STRef works 4 times slwer than poking / peeking Ptr values
07:17:32 <danilo2> kuribas: (I got very detiaed tests here)
07:17:59 <danilo2> kuribas: moreover STRef doesnt support unboxed values, so youve got next performance loss
07:22:08 <dmwit> recursion-ninja: cabal install --enable-documentation mono-traversable-1.0.8.1 --reinstall
07:22:22 <dmwit> recursion-ninja: You may want to --dry-run to make sure it's not reinstalling any dependencies.
07:22:38 <dmwit> recursion-ninja: You might also like to but enable-documentation: True in your ~/.cabal/config
07:23:10 <dmwit> (Sorry, I didn't mean "make sure it's not reinstalling any dependencies". I meant "make sure it's not changing the versions of any dependencies".)
07:24:17 <[exa]> What are the best chances to make GHC-produced binaries small? (E.g.: Haskell program that prints something has 800kB, compared to ~5kB of C/C++)
07:26:31 <dmwit> There's not much advice on that in the documentation, but here's what it has: https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/smaller.html
07:26:53 <dmwit> I find `strip` often reduces the executable's size by a lot.
07:27:12 <dmwit> You can also look into dynamic linking, but I don't know much about it, so I can't give super great advice there.
07:27:42 <dmwit> You'll never go below the size of the RTS, though, which itself is largish.
07:28:21 <dmwit> Oh, the docs already mention `strip`. =P
08:03:09 <recursion-ninja> dmwit: Thanks for the suggestion. I'm suprised that this isn't the default.
08:16:03 <danilo2> Hi guys! I want to use IORefs in the most performant way. I;ve got my structure which holds several Ints. Everything is unboxed. However as far as I see IORefs cannot hold unboxed values. There is a special library for it but it requires me to have PRim isntance of my struct. The question is - what is the right approach here
08:16:49 <danilo2> I'm trying to find the best way to store this structure in IORef like chunks. Basically this is a graph of nodes. Each node has several Ints + pointers to other nodes
09:17:35 <Zemyla> danilo2: You want something like this https://www.schoolofhaskell.com/user/edwardk/unlifted-structures
09:30:02 <bash0r> Does the bytestring package copy the ByteString on splitAt?
09:30:30 <EvanR> i hope not
09:31:39 <EvanR> a bytestring is really a tuple consisting of a pointer into a possibly shared byte array, (base, offset) and a length. substrings dont require a copy (but can be forced to copy using copy)
09:32:25 <bash0r> EvanR: thank you very much.
09:40:59 <croben> Anyone want a free ticket to Lambda days?
09:45:08 <kuribas> where is that?
09:46:26 <kuribas> danilo2: if you want _ultimate speed_ why use haskell?  you could write something in C or rust, then write a binding to haskell...
09:47:17 <kuribas> danilo2: haskell is great because it gives good enough speed, and an elegant language with many safety garantuees.
09:47:47 <kuribas> danilo2: I wouldn't use it for _ultimate speed_
09:48:25 <Bowlslaw> Haskell makes representing a mathematical model easier than any other language i've seen
09:48:38 <int-e> (It's also great for prototyping algorithms, I find. I'm often doing algorithmic optimizations in Haskell, and sometimes translate the final version to C for extra speed.)
09:49:46 <bash0r> croben: free ticket? Taken.
09:51:06 <bash0r> kuribas, int-e: doesn't the C-binding introduce extra overhead?
09:52:14 <EvanR> kuribas: i heard that rust is not really "ultimate speed" at the moment
09:52:19 <kuribas> Bowlslaw: sure, but if you then go messing around with mutable storables, it kind of defeats the point.
09:52:22 <dysfun> bash0r: at call time. you typically spend a lot longer in that function than calling it
09:52:50 <EvanR> also you can write slow and wrong code in C
09:52:56 <EvanR> or any language
09:52:57 <kuribas> EvanR: fortran then?
09:53:14 <EvanR> i dont know anything about fortran
09:53:29 <dysfun> rust is competitive, if not as fast as c++
09:53:43 <int-e> bash0r: what C binding?
09:53:44 <kuribas> or use the GPU...
09:53:51 <bash0r> dysfun: the computation needs to big enough, though.
09:53:58 <EvanR> kuribas: now youre cooking with gas
09:54:04 <bash0r> int-e: a binding to any C function.
09:54:07 <dysfun> then again, if you're writing it in c++, you've already fucked it up
09:54:16 <Bowlslaw> hahahaha
09:54:20 <kuribas> I don't know how much graph algorithms gain on the GPU
09:54:42 <kuribas> EvanR: with futhark of course ;-)
09:55:16 <int-e> bash0r: well, if you write a hybrid program (not what I had in mind), then perhaps you should not have timing critical inner loop that crosses the Haskell/C boundary all the time.
09:55:34 <dysfun> kuribas: that depends on all sorts of thins, of course
09:57:29 <bash0r> int-e: if you look at the really, really big issues of performance, a single optimized function won't scale well enough anyways. I think putting another server into the cluster will improve performance a lot more.
09:57:58 <bash0r> So why bother with optimizing on that level anyways?
09:58:35 <kuribas> operations which can be performed on a single computer will not be sped up by using clusters.
09:58:36 <int-e> bash0r: perhaps I have very single-minded programs
09:58:40 <MarcelineVQ> aside from maintenance cost? it all adds up is why a person might bother hehe
10:00:02 <bash0r> MarcelineVQ: maintenance cost for code in a different language, bindings, etc isn't low either.
10:00:46 <esand> exit
10:01:47 <esand> exit
10:01:49 <esand> exit
10:02:25 <MarcelineVQ> erm, I think I've missed your original point
10:03:33 <bash0r> ^^
10:09:08 <bash0r> kuribas: yes, of course. Those programs need optimization. But most software nowadays seems to be deployed as web application anyways. So another server in the cluster solves the issue.
10:11:07 <sbrg> Aeson lets me omit Nothing fields by using `genericToJSON defaultOptions { omitNothingFields = True }`, which means that records containg `Maybe` values which are Nothing get encoded such that the Nothing fields are simply left out, instead of being set to `null`. However, there are some APIs where some fields are nullable, and some can be omitted. This means that I might want the null behavior from some
10:11:08 <sbrg> Maybe values within a record, but the omit behavior from other Maybe values within the same record. I can get around this by manually definining an instance and using the `.:?` combinator, but I was wondering: Is it possible to encode this behavior on the type level? That is, create a newtype Optional such that, given values of type `Record { foo :: Maybe Int, bar :: Optional Int }`, then `Record Nothing
10:11:10 <sbrg> Nothing` would be encoded to `{foo: null]}`?
10:11:29 <kuribas> bash0r: the nice thing about haskell is that it isn't the fastest language, but it gives good tradeof in in performance, safety garantees and development speed.
10:35:22 <bash0r> kuribas: I chose haskell for rich syntax and type system. I don't care about performance implications at all.
10:36:34 <kuribas> bash0r: still it will give you less unpleasant surprises like in python.
10:37:18 <bash0r> kuribas: for sure. I'm surprised how good GHC is at optimizing some things. I write a naive implementation of my algorithm and boom it's surprisingly fast.
10:38:37 <Bowlslaw> that is a strong point of compilers
10:41:34 <Bowlslaw> I'm excited to use Haskell for data visualization
10:47:05 <um1b0zu> Haskell for data visualization?
10:47:12 <um1b0zu> oh no
10:55:24 <lyxia> sbrg: yes
10:58:07 <Ryan_> HELL YES
10:58:25 <lyxia> sbrg: It should be straightforward to define Optional. Otherwise, just write the instance for the record by hand.
11:00:03 <freeman42x]NixOS> any reason why: sum (101, 42) returns 42? this is confusing to me
11:00:23 <ddellacosta> I'm trying to understand a detail in this article about Haskell's type system being unsound. The quote is "This is easy enough in Haskell since Haskell’s type system is unsound." (about halfway down: https://jozefg.bitbucket.io/posts/2014-11-19-recursion.html)
11:01:05 <ddellacosta> It's not clear what this is in relation to, but is it because you can implement `fix` in the type system?
11:01:30 <ddellacosta> per this article: https://en.wikipedia.org/wiki/Fixed-point_combinator " The heart of Curry's paradox is that untyped lambda calculus is unsound as a deductive system, and the Y combinator demonstrates that by allowing an anonymous expression to represent zero, or even many values."
11:01:46 <ddellacosta> is that (in this case) why?
11:02:07 <cocreature> :t sum
11:02:08 <lambdabot> (Num a, Foldable t) => t a -> a
11:03:03 <cocreature> freeman42x]NixOS: take a look at the type signature, "t a" has to unify with (Int, Int), so "t" is "(Int,)". The Foldable instance can only “talk about” the "a" so that’s the second Int
11:07:24 <Cale> ddellacosta: yeah
11:07:28 <freeman42x]NixOS> cocreature, thank you, not sure then if my solution to implementing summed makes sense (was supposed to just tweak existing code) http://lpaste.net/508099875271868416
11:08:18 <ddellacosta> Cale: thanks!
11:08:46 <cocreature> freeman42x]NixOS: I don’t think you’re supposed to use "sum" here. try using (+) directly
11:08:59 <cocreature> freeman42x]NixOS: liftA2 is still going to be useful
11:09:29 <Cale> freeman42x]NixOS: Due to the way that the type system works, it becomes natural to think of pairs in Haskell as containers for a single element together with a label of some sort, and the label goes in the first position.
11:10:46 <freeman42x]NixOS> cocreature, these were the requirements and this was the code http://lpaste.net/530823391888801792 I do not think I am allowed to take out sum from the code
11:11:36 <dandy> what is the point of Data.Functor.Sum
11:11:36 <dandy> ?
11:11:42 <freeman42x]NixOS> cocreature, oops, reqs: https://i.imgur.com/DzrSFPe.png
11:12:37 <cocreature> freeman42x]NixOS: so the existing code had a type error?
11:13:03 <freeman42x]NixOS> cocreature, yup, supposed to fix the code using only those 3 functions
11:14:02 <freeman42x]NixOS> sum <$> liftA2 (,) x y type checks, but I think the author wanted to sum the 2 values
11:14:11 <Cale> dandy: Well, it's like Either, but for things with a type parameter
11:14:58 <dandy> data Sum f g a = InL (f a) | InR (g a)
11:15:05 <dandy> so the f and g are functors?
11:15:34 <suzu> yes
11:16:19 <cocreature> freeman42x]NixOS: not sure what the author’s intentions are tbh. trying to do this using "sum" is at least weird
11:16:29 <Cale> dandy: Typically, yeah
11:16:32 <cocreature> freeman42x]NixOS: and as you’ve noticed yourself for tuples it’s just wrong
11:16:51 <Cale> dandy: Obviously they don't have to be, given that definition, but that's where it makes the most sense.
11:17:23 <dandy> thanks
11:18:13 <dandy> im converting the functor instance of Sum to dictionary transforming functions
11:25:39 <MarcelineVQ> freeman42x]NixOS: the exercise is just to make things typecheck by inserting    pure   or   <$>  or  <*>   don't worry too much about intent
11:27:14 <freeman42x]NixOS> ok, I'll pretend it didn't bother my OCD :D
11:30:15 <MarcelineVQ> agree that it's weirdo
11:32:13 <MarcelineVQ> especdially since you write summed again later on and it's used how you'd actually expect
11:32:50 <Bowlslaw> zip is a cool function
11:35:32 <dmwit> Bowlslaw: You might also like transpose, which is like zip but for arbitrarily many input lists.
11:35:54 <dmwit> (Also it handles the edge cases of unequal-length lists a bit differently.)
11:37:41 <freeman42x]NixOS> just a quote from the Haskell book: "We know it seems somewhat crazy, but we promise there are really times real coders do this in real code. Pinky swear." - one of the authors on using Constant applicative
11:42:21 <cocreature> freeman42x]NixOS: it’s actually reasonably common, “lens” uses it quite heavily :)
11:45:19 <cocreature> then again the internals of the lens library are probably not a good indicator for what “real coders” do in “real code” :)
11:45:47 <Cale> edwardk is imaginary
11:46:03 <hpc> edwardk is hyperreal
11:46:31 <monochrom> edwardk is complex. :)
11:46:48 <Bowlslaw> lol
11:47:08 <Bowlslaw> anyone here used Haskell for data visualization?
11:49:28 <Cale> Bowlslaw: Depends on what you consider to be data visualisation, but I've generated some charts.
11:50:28 <Bowlslaw> Cale: that's pretty much what I'm talking about. I want to crawl the web for some info and then mark it up all pretty-like in some graphs
11:51:47 <freeman42x]NixOS> got another question about pattern matching and not working code that seems to be the same: http://lpaste.net/8915036351854804992
11:52:37 <Cale> freeman42x]NixOS: Think about the type
11:52:39 <freeman42x]NixOS> oh, I think I get it
11:52:54 <Cale> freeman42x]NixOS: The type of the (Constant a) on the left and right is actually different
11:53:04 <Cale> While the type of c on both sides has to be the same
11:53:43 <Cale> Bowlslaw: There are a couple of libraries, but I've just as often found myself writing code to generate shapes directly with diagrams or something.
11:57:57 <freeman42x]NixOS> Cale, don't you mean that the type is the same in: fmap _ (Constant a) = Constant a ? Constant a
11:58:34 <Cale> No, the type of the Constant a on the left hand side of the equation is something like Constant a s, while the one on the right is Constant a t
12:01:15 <freeman42x]NixOS> Cale, ok, I get it, thank you
13:08:30 <Bowlslaw> i'm not used to all these really cool functions...
13:09:49 <Welkin> which ones?
13:11:39 <Bowlslaw> so functions only ever take one argument at a time due to currying?
13:11:53 <Welkin> yes
13:11:58 <Bowlslaw> omg
13:12:00 <Bowlslaw> mind = blown
13:12:04 <Welkin> technically, there is no "partial application" either
13:12:08 <Cale> Bowlslaw: Effectively -- the compiler is free to compile versions of them which are faster and take more at once.
13:12:10 <Welkin> because all functions only take one parameter
13:13:05 <Cale> But from the programmer's point of view, there's no distinction between a function which takes one argument and produces another function, and a function which takes two (or more) arguments.
13:13:20 <Cale> When you write A -> B -> C, it really means A -> (B -> C)
13:13:23 <Welkin> it blew my mind too when I first learned about it
13:13:29 <Cale> and when you write f x y it really means (f x) y
13:13:38 <bash0r> Thanks to the nice application syntax. That's different in Scala.
13:13:52 <Welkin> bash0r: we don't speak that name in here
13:14:04 <bash0r> Welkin: ouh, I'm sorry.
13:14:09 <kaol> @let oneIn = (1 `elem`)
13:14:10 <lambdabot>  Defined.
13:14:17 <kaol> > oneIn [2,3,4]
13:14:18 <lambdabot>  False
13:14:41 <kaol> @let contains = (`elem` [2,3,4,5])
13:14:42 <lambdabot>  Defined.
13:14:48 <kaol> > contains 3
13:14:50 <lambdabot>  error:
13:14:50 <lambdabot>      Ambiguous occurrence ‘contains’
13:14:50 <lambdabot>      It could refer to either ‘Lens.contains’,
13:14:58 <Welkin> kaol: what are you doing?
13:15:04 <kaol> @let containsStuff = (`elem` [2,3,4,5])
13:15:05 <lambdabot>  Defined.
13:15:08 <kaol> > containsStuff 3
13:15:10 <lambdabot>  True
13:15:16 <Welkin> you can play with lambdabot in private message
13:15:39 <bash0r> Welkin: let me correct: in the programming language whose name can not be named it's different.
13:16:00 <mniip> we don't have any taboos on langauges here
13:16:06 <mniip> as long as you stick to the topic
13:16:09 <Welkin> bash0r: that's because it is java by a different name
13:16:25 <Welkin> mniip: I think bash0r knows it is a joke
13:16:29 <kaol> Nothing much, just something I like to give as an example about partial application.
13:16:29 <Cale> You can talk about any language you want as long as it's Haskell.
13:16:30 <mniip> okay
13:16:34 <Welkin> mniip: you russians
13:16:40 <Welkin> no sense of humor
13:16:45 <mniip> no that's germans
13:17:07 <bash0r> mniip: I know it'l a joke. ;)
13:17:21 <bash0r> Actually, I'm german.
13:17:38 <Welkin> technically, I'm both
13:17:39 <Welkin> and much more
13:18:46 <Bowlslaw> i'm glad you have issues with Scala
13:19:07 <Bowlslaw> i tried learning it and more details of FP a few months ago and it was horrible
13:19:36 <Bowlslaw> Programming in Haskell is awesome btw
13:19:36 <Welkin> I've had my share of testing out all the new fad languages. Haskell is the only one that feels right to me
13:19:43 <bash0r> IMHO Scala is just for people that need to stick with the JVM for legacy reasons.
13:20:05 <Bowlslaw> Kotlin is a new fad language, but it's actually quite nice
13:20:18 <systemfault> Why would it be fad?
13:20:29 <Bowlslaw> if you hate Java(like I do) Kotlin gives you the advantages of Java and then some
13:20:37 <systemfault> It's much more interesting to use Kotlin than Java to write Android applications.
13:21:12 <kuribas> bash0r: and appease the business men.
13:21:32 <systemfault> True that.
13:21:50 <kaol> I'll be giving a talk about Haskell at work at an internal functional programming event day next week.
13:22:01 <bash0r> kuribas: mhh yes, you are right.
13:22:16 <systemfault> kaol: Nice :)
13:22:35 <kuribas> bash0r: what do you actually program at work?
13:22:49 <bash0r> kaol: good luck. I failed convincing my last boss on using Scala. Haskell would be a no go.
13:23:05 <Welkin> don't ask permission
13:23:07 <Welkin> ask forgiveness
13:23:20 <Welkin> if they don't forgive you, just quit and find a new job
13:23:38 <kaol> They like to tell us "do as you would do", I'll see how far I can take it.
13:24:12 <Welkin> decisions about which tools to use are never rational
13:24:15 <Welkin> they are emotional
13:24:21 <Welkin> that is how java is so popular
13:24:31 <Welkin> no one ever got fired for choosing IBM--- I mean the JVM
13:24:39 <kaol> I just finished some 8000 lines of Haskell at home and put it to production, I may have some things to say.
13:25:20 <bash0r> kuribas: I'm student. My last job was at a Java-shop implementing some software like an auction house for transports. As a retailer, you can place your bid on a route. I was doing the testing with Selenium. I wrapped it up in a nice EDSL allowing a lot easier navigation on the site than their current implementation.
13:25:28 <Welkin> if you want to convince someone of something, use emotional appeals, not appeals to reason
13:25:46 <mniip> Welkin, avoid success at all costs
13:26:00 <Welkin> yes, the haskell manifesto
13:26:36 <kuribas> > map (chr.succ.ord) "HAL"
13:26:38 <lambdabot>  "IBM"
13:26:52 <mniip> > map succ "HAL"
13:26:54 <lambdabot>  "IBM"
13:26:58 <Welkin> o.o
13:27:06 <Welkin> I'm sorry Dave
13:27:08 <Welkin> I cannot do that
13:27:39 * kuribas applauds mniip
13:27:47 <mniip> "you are like a baby" "watch this"
13:28:28 <bash0r> Can anybody tell my why Java people are still afraid of lambdas?
13:29:11 <Welkin> bash0r: because lambdas eat coffee beans?
13:30:05 <Welkin> java is the kingdom of nouns
13:30:12 <Welkin> lambdas are the kingdom of verbs
13:30:16 <Welkin> have you read that essay?
13:30:33 <Welkin> https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
13:30:35 <Welkin> it's great
13:36:56 <Welkin> haha
13:37:02 <Welkin> I never read the comments before
13:37:03 <Welkin> wow
13:37:07 <Welkin> all from 2006
13:37:24 <Welkin> it looks like anything you would see in comments today. Nothing has changed
13:37:36 <Welkin> such insightful comments as "you are an idiot"
13:39:23 <bash0r> No, I didn't yet. Seems like I have to read that.
13:40:20 <Welkin> don't read the comments, they are worthless
13:40:27 <Welkin> only read the essay itself
13:40:56 <hpc> one links to http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html
13:41:07 <hpc> but even then the link is the only substance in that comment
13:48:25 <ertes> haha, that's a great article
16:26:45 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
16:26:45 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
16:27:50 <bash0r> I don't want to recompute everything after appending to the buffer.
16:46:58 <Cale> bash0r: Yeah, that can be continued. https://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/Data-Attoparsec-ByteString.html#t:IResult
16:47:12 <metahumor> i'm looking at cis194 (spring '13) hw 7, which defines JoinList. how would one write an Arbitrary instance for JoinList?
16:47:24 <Cale> (there's similar stuff for Text if you're parsing that)
16:50:32 <Cale> metahumor: something like  oneof [Empty, Single <$> arbitrary <*> arbitrary, Append <$> arbitrary <*> arbitrary <*> arbitrary]
16:51:00 <metahumor> Cale: thanks! where could I have read something that is of that structure?
16:51:46 <Cale> metahumor: I just made it up, but you can presumably read the instances in the quickcheck library itself.
18:53:44 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
18:53:44 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
19:02:24 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
19:02:24 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
19:13:31 <dmwit> metahumor: Can you not just `indexJ i (jl :: JoinList Size Integer) == ...` or whatever?
19:14:03 <metahumor> let me try that
19:18:51 <sm> joeyh: around ? In debug-me docs, what do you mean by "the strong set of the GnuPG web of trust" ? I'd like to be able to take control in debug-me, which I think requires that I find a signer or signing event corresponding this web
19:19:22 <metahumor> dmwit: that works, thanks!
19:29:01 <metahumor> dmwit, Cale: thanks for all the guidance. is there a way to define Arbitrary instances that still retain some invariant? for example, Size in the datatype above shouldn't be arbitrary, on second thought
19:30:09 <metahumor> "Append (sx + sy) x y" where "sx = size x; sy = size y", for example, is the invariant
19:38:09 <Cale> metahumor: Yeah, if you need some invariant to be retained, you should write the Arbitrary instance to maintain it. Gen is a monad, so you can just build the other parts, and then figure out what the sizes should be.
19:39:09 <Cale> (actually, you could do that with just the Applicative in this case)
19:39:21 <byorgey> metahumor: write the Arbitrary instance to construct JoinLists using +++, which computes the size for you
19:39:44 <metahumor> byorgey: wow from the teacher himself. thank you!
19:39:48 <Cale> ah, if you already have smarter functions then yeah, use them :)
19:39:48 <byorgey> (+++) <$> arbitrary <*> arbitrary  or something like that
19:39:51 <byorgey> sure =)
19:40:12 <metahumor> your homeworks strongly suggest testing the props =)
19:40:24 <byorgey> yes, that is a good idea =)
19:40:55 <metahumor> it took me a while to get indexJ to work such that the editor looks right -- but it was still wrong for the "indexJ 0 (Append ...)" case
19:40:56 <Axman6> The universe of Haskellers is growing, but is still a small town in man ways. seeing students come in here around assignment time for various courses around the globe is pretty entertaining, because the lecturers are pretty well known
19:41:05 <Axman6> many*
19:41:19 <byorgey> I think I wasn't expecting the students to know about QuickCheck at this point in the course, but if you do then by all means use it
19:42:10 <byorgey> metahumor: also, I don't know if you already fixed this, but Size should be a newtype, not  type Size = Int
19:42:19 <metahumor> yeah, i was mistaken in chat here
19:42:34 <byorgey> ok
19:42:43 <metahumor> i found out when i was writing the Score newtype too
19:43:14 <metahumor> Cale, byorgey: that (+++) <$> ... made the test work, thank you
19:45:14 <metahumor> uhh, nope. quickcheck doesn't always generate the case that makes it break. i'll work on it some more
19:56:46 <keep_learning> Hi everyone, I have cloned this repo https://github.com/IlyasRidhuan/ElGamal
19:57:08 <keep_learning> and trying to run stack build inside the project directory, but I am getting http://lpaste.net/362632
19:57:18 <wroathe> So I have two functions that generate infinite lists of palindromic numbers, in one function I'm reversing the integer arithmetically and then checking equality, and in the second function I'm converting it to a string and comparing it to the string's reverse
19:57:37 <wroathe> And I'm trying to test the performance of each by summing the first 5000 palindromes and printing the result using Criterion
19:57:59 <keep_learning> Could some one please tell me how to run the code.
19:58:10 <wroathe> This is the function that's being benchmarked: sumPalindromes = print $ sum $ take 5000 palindromes
19:58:21 <wroathe> Like so: bench "5000" $ nfIO $ sumPalindromes
19:58:54 <Axman6> wroathe: that won't work, you need to provide a parameter to sum palindromes or the execution will only happen once
19:59:42 <wroathe> Hmm, I tried it that way and in both cases I was getting lots of outliers
20:00:02 <wroathe> This was my previous test: sumPalindromes n = print $ sum $ take n palindromes
20:00:16 <hatds> I've got a Data.Vector of Double's and am going to do some statistics on it: finding the mean, variance and calculating some of the percentiles.  My question is: What is the "go to package" that I should be using before rolling the code myself??
20:00:21 <metahumor> keep_learning: what happens if you follow the Warning and add Components to the cabal file?
20:00:39 <Axman6> I wouldn't t=print the result, use nf (\n -> sum . take n $ palindromes) 5000
20:00:57 <metahumor> hatds: foldl, the package
20:01:01 <Axman6> hatds: well, my foldl-statistics package is pretty good for that :)
20:01:33 <Axman6> which is build on foldl, but provides you with more options than foldl (you can trade precision for speed)
20:03:15 <Axman6> keep_learning: the cabal file needs to mention the moldues which are used in the library in either the exposed-modules or other-modules section of the library definition
20:03:25 <hatds> @Axman6 does it do percentiles?  I want to Winsor my data to remove outliers, say by dropping the top and bottom 10 percent
20:03:26 <lambdabot> Unknown command, try @list
20:03:51 <Axman6> hatds: no, but if you know how to do that efficiently, I would be interesting in adding it :)
20:04:12 <hatds> metahumor: foldl package would just be rolling it my own, wouldn't it?
20:04:52 <metahumor> hatds: Axman6 has the nice library he just told you about, otherwise you'd have to figure out your own online calculations
20:05:00 <Axman6> I mainly wrote the library for fun, because I thought that the statistics package was too restrictive by forcing you to use Vector Double, when many stastics can be computed using a fold, and many can be build monoidally
20:05:28 <gestone> if i want to go from Text -> ByteString, what's the recommended function to use?
20:05:32 <metahumor> i'm not familiar what the error bound is for calculating percentiles online
20:05:45 <Axman6> gestone: there's several in Data.Text.Encoding
20:06:03 <metahumor> more exactly, "estimating" percentiles
20:06:19 <keep_learning> metahumor Axman6 Thank you!
20:07:19 <gestone> Axman6: thanks, just want to make sure there aren't little gotchas with some of these functions
20:07:19 <Axman6> keep_learning: is it working?
20:07:30 <gestone> like foldl vs foldl'
20:07:41 <Axman6> gestone: they should be documented. it's going the other direction which can cause problems anyway
20:07:43 <hatds> looks like the statistics package does quantiles
20:08:03 <gestone> Axman6: got it. is it recommended to use the strict version or lazy?
20:08:17 <metahumor> gestone: there are strict and lazy ByteStrings, different libs and functions use different ones for different purposes
20:09:09 <Axman6> I try to avoid lazy bytestrings/text, they're usually a sign that lazy IO is being used which can cause all sorts of problems
20:09:23 <gestone> metahumor: so if i'm just converting Text -> ByteString so that it can be marshelled by aeson into an entity it's probably better to use strict then
20:11:34 <wroathe> Axman6: Newb question but, in your above example you wrote "take n $ palindromes", won't having an infinite list on the RHS of $ cause it to just hang infinitely?
20:12:01 <Axman6> no?
20:12:06 <Axman6> @src ($)
20:12:07 <lambdabot> f $ x = f x
20:12:47 <Axman6> $ does essentially nothing, you may be thinking of $!, which only evaluated until it knows what the constructor of a value is and no further
20:13:23 <wroathe> Axman6: I guess my real question is, why is $ needed in this situation? My previous implementation was just "take n palindromes"
20:13:43 <wroathe> Sorry, I'm still learning the Haskell precedence rules
20:15:53 <parsnip> wroathe: (\n -> f . g n $ y) is same as (\n -> f $ g n y)
20:16:07 <parsnip> some people have a habit of preferring the former
20:16:35 <parsnip> especially, for other situations, it helps to convert to point free if the opportunity presents itself.
20:16:54 <mniip> $ is only needed to avoid parentheses
20:17:12 <parsnip> f x $ g y is same as (f x) (g y)
20:17:17 <mniip> (and for the ($ x) section)
20:17:24 <mniip> it's an evaluational no-op
20:17:30 <parsnip> and thus (f x (g y))
20:17:34 <parsnip> er
20:19:26 <joehask> Hi! I'm testing Haskell / C performance and I've got strange results. I would be very thankful if anybody could take a look at it. I'm testing very simple 2 programs - basically lop with int incremenetation. Here are both C and Hs versions: http://lpaste.net/362633 .
20:20:24 <keep_learning> Hi Everyone, I have changed the cabal file and it compiling http://lpaste.net/2670662157015711744
20:21:13 <keep_learning> But when I am running, stack exec my-project-exe, then I am getting Executable named my-project-exe not found on path:
20:21:14 <joehask> basically, when the C version when run as `./out 1 100000` (which means 10^15 increments) runs on my system in about 0.5s - which itself seems strange, the number seem to be too big. On the other hand, running Haskell version with 10^9 increments runs on my system in about 0.9s which seems to low, taking in cnsideration ive got here buffy 3ghz xeon proc
20:22:34 <wroathe> joehask: Without looking at the implementation, are you ensuring you've got compiler optimizations disabled?
20:22:52 <olligobber> this commit is so satisfying: https://github.com/olligobber/LambdaCalc/commit/63a5296ebc72231f5babe6439df8995292b0692a
20:23:19 <joehask> wroathe: no, I enaled both compiler optimizations and looked at generated asm code. The C compiler cannto optimize much because all parameters are provided via cmd args
20:24:35 <mniip> looks to me like the compiler should be able to optimize all 3 loops out
20:25:45 <mniip> joehask, could not reproduce
20:25:58 <mniip> at -O2 it's instant meaning it optimized the loops out
20:26:06 <mniip> at -O1 it's iterating forever
20:26:33 <mniip> indeed
20:26:42 <mniip>  618:	0f af f0             	imul   %eax,%esi    61b:	0f af f0             	imul   %eax,%esi     61e:	0f af f0             	imul   %eax,%esi
20:26:52 <keep_learning> If I remember correctly then when I ran stack build with other Haskell projects, it created a dist directory but I am wondering why it is not creating in this case.
20:27:40 <Axman6> keep_learning: what exactly are you running? stack exec ElGamal-exe?
20:29:11 <joehask> mniip: hmm, so how I should compare the performance? Should I always compile C progs without optimizations in such simple cases?
20:29:37 <mniip> try making the pointer volatile
20:29:47 <mniip> int volatile *ptr
20:30:54 <keep_learning> Axman6 Thank you. I was running stack exec my-project-exe. Silly me :)
20:32:21 <mniip> as for ghc, I don't think ghc really knows how to fold a sequence of additions into multiplication
20:32:44 <joehask> mniip: oh, thanks! that would make the tirck in the best possible form! By the way, when I change it to volatile then even if im incrementing not pointer but ordirnary int it runs now 2 times slower than haskell
21:17:57 <grandMasterFlash> how to split a string by delimeter without using Data.List.Split.spliton
21:18:38 <Axman6> why not use that?
21:18:48 <metahumor> an annoying combination of "break" and "fst" and "snd" and "foldr"
21:20:09 <[Leary]> Or break, case and foldr, which is slightly less annoying.
21:20:42 <[Leary]> or let.
21:24:23 <ab9rf> is the delimeter a single character?
21:24:34 <ab9rf> cuz that's peasy-easy
21:25:01 <ab9rf> also, do you need to split on each delimiter or just on the first occurrence/
21:25:58 <ab9rf> it's only slighrtly harder if the delimeter is a longer string
21:26:49 <metahumor> he left. the other option (cheekily) was to use Data.Text.splitOn
21:27:07 <metahumor> i think he just did not want to have the Data.List.Split dependency
21:28:11 <ab9rf> it's not like split is hard to implement :)
21:41:42 <A_> i have a stack project with package.yaml when i try to put a dependency there in this case split it will build succesfully bt i cant import the module
21:43:28 <Axman6> have you added split to your cabal file?
21:44:09 <A_> Axman6 : but we aren't supposed to touch cabal file right ? and i installed other dependencies just but placing them in package.yaml
21:44:34 <Axman6> stack still uses cabal files afaik?
21:44:39 <MarcelineVQ> Axman6: if a person is using pacakge.yaml and stack they use that instead of a cabal file
21:44:45 <MarcelineVQ> it's part of hpack
21:45:11 <Axman6> oh, ok. fair enough, I have no idea about hpack
21:45:42 <Axman6> olligobber ..: head $ head ... :|
21:45:54 <olligobber> Axman6, got a better idea?
21:46:03 <Axman6> yes, pattern match
21:47:36 <Axman6> case words of ((p:ps):t) -> case (p,t) of -> ...; _ -> <something to handle the exceptional case>
21:47:38 <MarcelineVQ> A_: people can't guess what you've tried, you need include how you're importing and what your package.yaml and/or cabal file look like
21:47:46 <Axman6> case words s of*
21:48:19 <olligobber> Axman6, that's how it used to be, and it was quite messy
21:48:22 <Axman6> olligobber: also calling words repeatedly (and then later calling unwords) feels like a code smell to me
21:48:43 <olligobber> I want the first 2 words though :/
21:48:50 <ab9rf> i don't trust that unwords . words is truly id
21:49:03 <Axman6> also I should've said ... case (toLower p,t) of
21:49:08 <olligobber> it isn't but in this case, excessive whitespace is irrelevant
21:49:19 <ab9rf> still smelly
21:49:36 <ab9rf> why break all the words when you don't care about most of them
21:49:48 <olligobber> Axman6, so like, let ((p:_):t) = words s in case (toLower p, t) of
21:49:49 <ab9rf> don't do more work than you need to
21:49:53 <ab9rf> just because you're a lazy programmer
21:50:06 <Axman6> olligobber: that's not a safe pattern match
21:50:20 <olligobber> why not?
21:50:35 <olligobber> oh, could be empty string
21:50:48 <Axman6> stateLoop Nothing "" will cause a pattern match exception
21:50:48 <olligobber> ugh
21:51:08 <olligobber> > tail []
21:51:10 <lambdabot>  *Exception: Prelude.tail: empty list
21:51:13 <olligobber> oops
21:51:15 <ab9rf> meow
21:52:12 <olligobber> I see...
21:54:06 <Axman6> olligobber: http://lpaste.net/362636
21:54:22 <Axman6> you should compile this code with -Wall to find when you've missed cases
21:56:19 <olligobber> Axman6, didn't know -Wall was a thing, thankyou
21:56:27 <Axman6> (there is a spurious case that GHC will complain about, the ([]:t) case, but I don't think words can ever return an empty list if it returns any results)
21:58:16 <Axman6> if you're in ghci, you can turn it on with :set -Wall
21:58:24 <Axman6> (and you can run ghci with -Wall otherwise
21:58:57 <ab9rf> words will return an empty list on empty input
22:00:06 <ab9rf> or on input that consists only of characters that satisfy isSpace
22:00:22 <ab9rf> > words "\t\t\t\t"
22:00:24 <lambdabot>  []
22:00:42 <Axman6> but it will never return [[]])
22:00:47 <Axman6> [[]]*
22:00:50 <ab9rf> yeahm, you'll never get [[]]
22:00:52 <olligobber> or []:_
22:01:12 <ab9rf> but the compiler cna't possiblu know that
22:01:27 <Axman6> right, that was my point
22:01:32 <ab9rf> indeed
22:03:56 <inradius> Is there any equivalent to make clean in ghc? I ran ghc --make -O, and it cluttered the directory, was just curious if there is an easy way to remove the object files and compiled files
22:04:05 <metahumor> how do you guys feel about quchen's (and others') style suggestion to name all "_..." patterns?
22:04:34 <olligobber> I'm just gonna use _, I think it makes the code less cluttered
22:04:41 <Axman6> inradius: why're you running ghc --make? I haven't seen that mentioned for years now
22:05:35 <MarcelineVQ> metahumor: anything that helps the reader
22:06:41 <ab9rf> will it make it easier for you tunderstand your code when you go back to look at it six years later?
22:06:56 <olligobber> maybe `-tmpdir /tmp/ghc/` will avoid the excess files
22:07:15 <ab9rf> or six weeks later whne you get paged because it broke and you're drunk at your sister's wedding reception?
22:07:26 <olligobber> ab9rf, I feel like someone reading the code for the first time will understand it better if fewer variables are declared
22:08:31 <ab9rf> so the less information you give to this poor hapless person, the better?
22:08:46 <[Leary]> I find code that replaces unused variables with _ is cleaner and more readable when there are only a few underscores. But on a big product data type it obscures what you're matching against and what the other fields hold.
22:09:44 <olligobber> Axman6, the code you linked re-uses `p` :P
22:10:21 <Axman6> that's when you use RecordPuns
22:10:47 <Axman6> olligobber: aren're you glad you're using -Wall? ;)
22:11:13 <olligobber> I didn't use -Wall, I noticed it when typing it in
22:11:22 <ab9rf> it's alawys best to conceal as much information as possible from future readers of yuour code
22:11:43 <MarcelineVQ> people sure like sarcasm in here :>
22:11:48 <olligobber> also, returning (Nothing, Nothing) ends the loop
22:11:49 <ab9rf> that way, they'll assume that your code is not insanely stupid, and not realize that until they've spent hours figuring out why the fuck you did the stupid thing you did
22:12:20 <olligobber> ab9rf, I'd rather my code be readable
22:13:03 <Axman6> [Leary]: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-puns
22:13:07 <ab9rf> MarcelineVQ: i get a lot more sarcastic when i'm drunk
22:14:24 <olligobber> ab9rf, I mean, the code my interpreter is used on will be completely unreadable, better make my code atleast slightly readable
22:14:45 <[Leary]> That's a nice idea, Axman6. But at the same time, shadowing makes me uncomfortable.
22:15:38 <Axman6> what do you name your varliables when pattern matching then?
22:16:54 <[Leary]> Depends on the situation. I might strip the field down to its first few letters, or prime it.
22:17:34 <Axman6> well, you can always use Foo{firstName = fname} = ...
22:17:45 <Axman6> to avoid needing to _ all the fields yuo don't use
22:17:49 <Axman6> you*
22:20:30 <[Leary]> Too many underscores or ugly record syntax ... what a dilemma.
22:20:40 <olligobber> hmm, -Wall picked up a pattern where I missed the possibility a list could be empty
22:20:44 <ab9rf> usually the solution to that is to reconsider the record syntax....
22:20:56 <olligobber> that list was defined as `((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables)`
22:20:57 <ab9rf> olligobber: -Wall is a good thing, taken in moderation
22:21:10 <ab9rf> ooh monkeyface operator!
22:21:20 <olligobber> `variables = ((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables)` I mean
22:21:33 <olligobber> ab9rf, is there a better thing that monkeyface?
22:21:38 <olligobber> *than
22:21:47 <ab9rf> olligobber: no, i just think monkeyface operator is funny
22:21:57 * olligobber pets ab9rf 
22:22:13 <Axman6> (:[]) = pure
22:22:21 <Axman6> and is a character longer
22:22:34 <ab9rf> yeah, but "pure" is boring
22:22:36 <ab9rf> monkeyface is funny
22:22:39 <olligobber> Axman6, ty
22:22:51 <Axman6> > let `variables = ((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables) in variables
22:22:53 <lambdabot>  <hint>:1:5: error: parse error on input ‘`’
22:23:00 <Axman6> > let variables = ((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables) in variables
22:23:02 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
22:23:22 <Axman6> > let variables = ((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables) in text $ unwords variables
22:23:29 <lambdabot>  mueval-core: Time limit exceeded
22:23:34 <ab9rf> oops
22:23:39 <Axman6> > let variables = ((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables) in unwords variables
22:23:39 <olligobber> Axman6, that's an infinite list
22:23:41 <lambdabot>  "a b c d e f g h i j k l m n o p q r s t u v w x y z a' b' c' d' e' f' g' h'...
22:23:57 <ab9rf> we like indefinite lists
22:24:09 <olligobber> > let variables = ((:[]) <$> ['a'..'z']) ++ ((++"'") <$> variables) in drop 52 variables
22:24:10 <lambdabot>  ["a''","b''","c''","d''","e''","f''","g''","h''","i''","j''","k''","l''","m'...
22:24:40 <ab9rf> hehe
22:24:40 <Axman6> "drop 52 variables" sounds like like a line from a nerd rap song
22:26:17 <olligobber> fixed: https://github.com/olligobber/LambdaCalc/commit/0f2cba3611d613eda9ffde1bc816cd234d76f046
22:27:26 <Axman6> looking good, nice work
22:28:34 <danilo2> Hi guys! I need to create a list of Ints, with instant access time (it would be great if there would be completely no overhead) and it should be indexed by types. Like `lst :: Lst '[X,Y,Z]; a = get @X lst` . The problem is that I'm unable to do it. I was trying to impement it as recursive strict tuples, like
22:28:35 <olligobber> removed monkeyface operator :(
22:29:01 <metahumor> danilo2: types don't exist at runtime!
22:29:16 <Axman6> but singletons do
22:29:18 <ab9rf> how ar eyou going to index by tppes?
22:29:20 <danilo2> `data T = T {-# UNPACK #-} !Int  {-# UNPACK #-} !Int | Z` . And was trying to encode everything using typeclasses. Still, when accessing n-th eleent ghc seems to jump over each tuple element
22:29:20 <ab9rf> types
22:29:31 <olligobber> danilo2, if it's recursive tuples, it won't have instant access time
22:29:37 <danilo2> metahumor: I didnt tell I want types at runtime
22:29:52 <ab9rf> also, what do you nmeab by "instant access time"? O(1)?
22:30:02 <olligobber> you wanted it indexed by types though?
22:30:09 <danilo2> olligobber: If during compilation time you know that you need element form 5th tuple and you know that every element is unpacked int, why cannot you get constant acess time ?
22:30:27 <danilo2> olligobber: yes, thats the whole point. I've got it indexed by types
22:30:28 <olligobber> true...
22:30:48 <olligobber> danilo2, it can't be indexed by types, since types don't exist at run time
22:31:08 <Axman6> data Lst (xs :: [Type]) a where Nil :: Lst '[] a; Cons :: a -> Lst xs a -> Lst (y:xs) a
22:31:10 <danilo2> ab9rf: by instant access time I mean jsut to unpack it during compilation time to variables and thread it like variables
22:31:13 <metahumor> danilo2: you want O(1) indexing at compile time?
22:31:31 <danilo2> metahumor: I want it to be indexed at compile time
22:32:14 <metahumor> danilo2: then you want Axman6's HList-like with some "find" function
22:32:20 <danilo2> olligobber: I've got implementation which works and indexes it by types. You clearly can write `get :: forall a. ContainsKey a ls => List (ls :: [Type]) -> Int` .Its simple to do using typeclasses
22:32:23 <Axman6> O(1) is what makes this a bit harder, though take a look at the way that SuperRecord is imeplemented to see how you can get constant time indexing into vinyl style records
22:33:06 <Axman6> danilo2: look at SuperRecord, it's quite simple, and uses a SmallArray# internally to give constant time indexing
22:33:39 <danilo2> metahumor: This is not a problem actually. If Im not wrong the HList like functions you refer to are implemented using GADTs, which exaclty as my r-tuples, have runtime overhead even if GHC solves durign compilation time which element to access (!)
22:33:41 <Axman6> there's a few other libraries which do similar things, but I happen to have just contributed to superrecord and made it a lot faster :)
22:34:12 <dminuoso> Just to be sure because the discussion arose last weekend. Is an unlifted type necessarily Unboxed?
22:34:37 <Axman6> that's probably a better question for #ghc
22:34:45 <dminuoso> Axman6: Alright thanks for the tip
22:34:47 <Axman6> (though opeople in here may also know)
22:35:06 <danilo2> Axman6: ok, so here is the thing. I dont even want to use SmallArray#. It sohuld be doable without it. If I know that I've got few variables and I can index them at compile time, why do I have to put them in an array and access at runtime ?
22:36:20 <Axman6> danilo2: what other structure is going to give youi constant time access?
22:36:36 <osa1> dminuoso: unlifted is not necessarily unboxed
22:36:47 <Axman6> anything algebraic is going to be O(log n) or so, except tuples I guess, but you can't really generalise tuples
22:36:56 <danilo2> Axman6: something like `foo a b c = do ...` inside do I can access `a` `b` and `c` simply by mentioning its name
22:37:19 <osa1> dminuoso: I'll show an example if I can find it
22:37:19 <Axman6> sure...
22:37:26 <danilo2> Axman6: I want to index it during compilation time, not runtime!
22:38:41 <danilo2> Axman6: so If I've got something like `data T = T !Int !Int | Z` and `lst = coerce T 1 (T 2 (T 3 Z)) :: List X Y Z` then I should be able to do `get @X lst` and just ask GHC to unpack everything to variables during compilation time
22:39:02 <danilo2> *`List '[X,Y,Z]`
22:39:25 <osa1> dminuoso: https://github.com/ghc/ghc/blob/master/compiler/types/Type.hs#L282-L289
22:39:38 <osa1> dminuoso: so ByteArray# is unlifted but boxed
22:39:38 <Axman6> danilo2: should that be T !Int !T?
22:39:44 <danilo2> oh, yes
22:39:48 <danilo2> im sorry
22:40:02 <Axman6> danilo2: have you ried this with the GADT approach?
22:40:05 <Axman6> tried*
22:40:56 <danilo2> Axman6: not yet. but I'll do, brb
22:41:13 <Axman6> there's a few things you'll need to write
22:41:36 <Axman6> (not sure if any libraries offer exactly what you're after, but the type families you need a trivial
22:42:34 <danilo2> Axman6: I know typefamilies gadts etc pretty well. Im just wonderign why ghc cannot optimize it
22:43:44 <Axman6> it should be able to if you inline the Lst value you're using
22:45:01 <danilo2> Axman6: give me 10 mins, ill implement it and check how it behaves
22:46:05 <Axman6> danilo2: because the recursive calls aren't on the same type, you should get full unrolling of the function indexing into the list. see https://stackoverflow.com/questions/42179783/is-there-any-way-to-inline-a-recursive-function for some examples
22:46:23 <Axman6> if things go right, hopefully everything would inline and have no overhead at runtime
22:47:12 <Axman6> anyway, I'm heading home, would be interested to see how this goes so let me know later
22:55:30 <dminuoso> osa1: Ahh that's illustrative. Thank you.
22:56:07 <dminuoso> osa1: Does the converse hold true? I mean it seems reasonable that every unboxed type is necessarily unlifted.
22:56:29 <dminuoso> Or rather implicitly unlifted at least.
22:58:14 <osa1> dminuoso: right. unboxed types don't have same heap representation as boxed so can't be used as polymorphic arguments. if an unboxed value had a lifted type you could use it in a polymorphic arg position.
22:59:33 <dminuoso> I see. Thank you.
23:01:12 <danilo2> Axman6: I've jsut tried it and still it has runtime overhead:
23:01:40 <danilo2> Axman6: http://lpaste.net/362644
23:01:57 <danilo2> Axman6: the pureLoop_X runs much faster than pureLoop_Z
23:08:50 <danilo2> Anyway , if anyone knows if it is somehow doable with current GHC Id be very thankful for hints
