00:13:13 <halogenandtoast> this one looks even more fun
00:13:14 <halogenandtoast> private/var/folders/c8/k9jjjm914bq62nnh7wqpbsyxj29666/T/stack8515/postgresql-simple-0.5.3.0/src/Database/PostgreSQL/Simple/Types.hs:90:10: error:
00:13:17 <halogenandtoast>         • No instance for (Semigroup Query)
00:13:26 <halogenandtoast> there might be an update for that one though
00:28:32 <phadej> not yet, will be on Friday
00:28:51 <phadej> https://github.com/haskell-infra/hackage-trustees/issues/155
00:31:55 <Cale> https://blog.jle.im/entry/in-memory-of-ertugrul-soylemez.html
00:33:49 <halogenandtoast> Yeah it really sucks that ertes is gone.
00:35:42 <Cale> Yeah, I just found out :(
00:55:08 <mupf> Does anyone know if Jason Lee is around here too?
00:59:09 <dminuoso> mupf: Dont tell me you have more bad news. :(
01:02:27 <mupf> No, I just read his blog entry. I guess, it would be nice to talk to him someday.
01:02:38 <ibttis> are there any news on what happened?
01:02:48 <cocreature> mupf: I guess you mean justin le instead of jason lee?
01:03:26 <cocreature> mupf: he’s around under the nick jle`
01:03:27 <mupf> Sorry, guess I have to blame my autocorrect again
01:03:39 <mupf> Writing with my phone at the moment
01:03:45 <mupf> Thanks
01:04:34 <mupf> ibttis: in case you're truly interested about the circumstances, I would prefer to tell you in private. Ertes was a very private person after all.
01:05:54 <AWizzArd> What are guys talking about? What news? And why was ertes mentioned?
01:06:02 <ibttis> I didn't really know him, however I've heard about it in 2 other channels people mentioning his death
01:06:02 <halogenandtoast> cocreature: after all that, same problem
01:07:05 <cocreature> halogenandtoast: sry, then I’m out of ideas :/
01:07:09 <tdammers> I believe many of us would like to know more about the circumstances, but the posts kind of suggests that this is kept somewhat private on purpose.
01:08:14 <mupf> ibbtis what channels? Feel free to pm me
01:08:42 <ibttis> gonna stop my morbid curiosity tbh
01:08:49 <AWizzArd> Omg, I am in shock. For over a year I was talking to Ertes nearly every day.
01:08:51 <ibttis> I didn't know the guy
01:09:17 <mupf> tdammer it's not the circumstances, but I'm not sure he He wanted anyone to post it somewhere public
01:10:23 <mupf> Well, not going into details: it was a natural cause.
01:11:28 <halogenandtoast> cocreature: no worries, thanks so much for the help
01:11:31 <mupf> It's kinda odd that he is still around here on IRC.
01:14:39 <tdammers> mupf: so I've heard
01:14:47 <tdammers> mupf: still very sudden though
01:21:39 <mupf> Indeed.
01:31:26 <dminuoso> mupf: Well Im guessing ertes was using a bouncer that's still connected.
01:31:49 <mupf> Yes
01:47:01 <Ariakenom> mupf: Not sure if it was said but jle` can be found here fairly often, yes.
02:01:51 <ocharles> today is gonna be a tough day. not news I ever wanted to hear :(
02:03:28 <phadej> ocharles: ?
02:03:41 <ocharles> phadej: the news about ertes
02:03:43 <phadej> ah
02:04:01 <phadej> "good" that nothing else bad happened
02:08:00 <dysfun> like this wasn't enough
02:08:49 <ddellacosta> ocharles: thanks for linking to that blog post of his btw. Nice to spread that around so folks know more about his contributions. I've found it really informative so far
02:09:07 <ocharles> his hangman one is a classic :)
02:09:28 <dysfun> has someone looked into continuity of his work?
02:09:30 <ocharles> unless you meant the asteroids blog post, which is mine. I'm still quite here :)
02:10:17 <ddellacosta> ocharles: oh whoops, sorry you didn't link to it, someone else did, but it's on your blog
02:10:38 <ocharles> oh yea, he wrote a blog post on my very blog
02:10:43 <ddellacosta> so I should rather say, thanks for posting it in the first place!
02:11:05 <ocharles> https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
02:11:09 <ddellacosta> yeah ^
02:20:12 <ddellacosta> ocharles: where can I find the hangman post you just mentioned? I don't see it linked in your last post on reddit (sorry, I was talking about a previous memorial post on reddit above) or on his blog
02:22:08 <ocharles> it's the one on monoids, iirc
02:22:10 <cocreature> ddellacosta: http://community.haskell.org/~ertes/hangman/
02:22:22 <ddellacosta> thanks!
02:22:42 <ocharles> oh cool, it's yet another one
02:27:15 <mupf> I try to build up a archive of his public legacy later on. Make it available somewhere central. I already have a local copy of his diaspora account now. In case you guys have more links, feel free to pm me.
02:27:24 <mupf> I would be grateful.
02:27:53 <merijn> mupf: Maybe mail haskell-cafe and/or post to /r/haskell for submissions to get better reach?
02:29:00 <mupf> Will do, thanks.
02:29:48 <mupf> Fun fact: Ertes wrote  my conscientious objection. He made me a gay Mormon.
02:31:35 <ddellacosta> mupf: wow!! That sounds like an interesting story
02:32:38 <mupf> He spent half the night writing it for me the day before I needed it. It was accepted without question. The text is still available online. But it is in German.
02:33:02 <mupf> We read it out loud so much on parties.
02:33:07 <ddellacosta> haha
02:33:07 <mupf> lol
02:33:50 <ddellacosta> btw other than the links above this may be worth adding to whatever you're collecting, was linked from Justin Le's post: https://hub.darcs.net/ertes/articles/browse/media-processing.lhs <- unfinished post on comonads
02:34:42 <mupf> Can you post me all. Links via pm. I'm on mobile. Easier to look them up later on
02:34:48 <ddellacosta> oh sure, sorry, will do
02:34:52 <mupf> Thanks
02:38:49 <mupf> Another fun fact: I was standing at the door frame of our class room, waiting for him at our final exam in school. He was literally never on time. 5 seconds later and he would have failed math (!).
02:39:17 <Ariakenom> mupf: Could you link the gay mormon write up?
02:39:22 <mupf> Sure
02:39:31 <mupf> Give me a second
02:42:12 <mupf> https://www.mupfelofen.de/kriegsdienstverweigerung-mal-anders
02:43:11 <Ariakenom> Thank you
02:44:30 <mupf> You're welcome
02:52:58 <dysfun> i honestly didn't know you could be a gay mormon
02:53:22 <dysfun> legitimately, i mean
03:00:07 <tdammers> great prose
03:03:50 <mupf> You can't
03:04:26 <dysfun> so you do the next best thing, declaring it and ignoring the hate?
03:15:33 * hackage hasql 1.2 - An efficient PostgreSQL driver and a flexible mapping API  http://hackage.haskell.org/package/hasql-1.2 (NikitaVolkov)
03:20:29 <f-a> is there anything to run a pager inside ghci? :browse somemodule can get quite long
03:24:30 <quicksilver> to be honest I view the HTML documentation of the module in a browser
03:24:40 <quicksilver> running ghci inside emacs is another option ;)
03:26:09 <f-a> thanks quicksilver
03:36:31 <kuribas> Does there already exist a structure with efficient cons and snoc in the base libraries?
03:36:45 <kuribas> like data DoubleEnded = DoubleEnded [a] [a]
03:37:03 * hackage hasql 1.3 - An efficient PostgreSQL driver and a flexible mapping API  http://hackage.haskell.org/package/hasql-1.3 (NikitaVolkov)
03:37:07 <quicksilver> well there is Data.Sequence which has very good performance in a variety of cases
03:37:56 <kuribas> yeah, but with an extra log factor
03:37:57 <quicksilver> you could also try Okasaki dequeues
03:38:05 <quicksilver> log factors are constant
03:38:09 <quicksilver> don't believe the log lie
03:38:20 <quicksilver> just try it and see if it performs fast enough for you
03:38:29 <dysfun> Data.Sequence performance is pretty good
03:38:29 <quicksilver> http://hackage.haskell.org/package/dequeue-0.1.12/docs/Data-Dequeue.html (okasaki dequeues)
03:38:44 <kuribas> my double ended definition would be faster though
03:38:49 <quicksilver> perhaps it is pedagogically clearer to say "constant factors are log"
03:39:44 <kuribas> sequence will be overkill
03:40:50 <quicksilver> typical naive double ended list implementations incur an unpredictable O(n) reverse from time to time
03:40:55 <kuribas> I need to divide a list into the longest subsequences which add to -4 or less.
03:41:01 <quicksilver> naturally exactly how often depends how you usei t
03:41:03 * hackage hasql-transaction 0.6.0.1 - A composable abstraction over the retryable transactions for Hasql  http://hackage.haskell.org/package/hasql-transaction-0.6.0.1 (NikitaVolkov)
03:41:18 <quicksilver> but sequence and dequeue do very well in a wide range of access patterns
03:42:33 * hackage hasql-cursor-query 0.4.4.1 - A declarative abstraction over PostgreSQL Cursor  http://hackage.haskell.org/package/hasql-cursor-query-0.4.4.1 (NikitaVolkov)
03:42:59 <kuribas> like this: [4, 0, -2, -3, 1, 3] => [[4], [0, -2, -3, 1], [3]]
03:43:18 <kuribas> (it's an actual problem, not a puzzle)
03:46:11 <[exa]> kuribas: dynamic programming?
03:46:30 <kuribas> [exa]: I think it can be done in linear time.
03:46:38 <kuribas> something like that
03:46:42 <opqdonut> kuribas: just write a loop (i.e. recursive function) and aggreagate?
03:46:59 <dmwit> kuribas: Why does this problem require a fancy structure?
03:47:01 <[exa]> kuribas: how's [4] adding to [-4] or less?
03:47:30 <kuribas> [exa]: I only need the longest subsequence for lists adding to 4 or less
03:48:05 <kuribas> opqdonut: in my O(n) solution it does.  But I'd like to hear of a better one :)
03:48:22 <[exa]> so basically want to split the list to elements that are contained in a subseq that adds to <-4, and the others, yes?
03:48:53 <kuribas> yes
03:49:13 <[exa]> kuribas: btw if you have O(n) solution you probably aren't going any faster because you need O(n) at least read a reasonable portion of input
03:49:15 <kuribas> the other ones should be singletons
03:49:33 <kuribas> [exa]: yeah
03:49:55 <Ariakenom> [2,-6,1,1] should be what?
03:50:12 <[exa]> afaik [[2],[-6,1,1]]
03:50:23 <kuribas> [[2, -6], [1], [1]]
03:50:31 <[exa]> kuribas: that's not longest?!
03:50:33 * hackage hasql-transaction 0.7 - A composable abstraction over the retryable transactions for Hasql  http://hackage.haskell.org/package/hasql-transaction-0.7 (NikitaVolkov)
03:50:45 <kuribas> [exa]: ah right :)
03:50:53 <[exa]> :]
03:51:18 <dmwit> kuribas: This is a fun puzzle. I admit I'm quite surprised it can be done faster than sorting the list.
03:51:19 <kuribas> I'll need to adapt my solution...
03:51:26 <Ariakenom> :p
03:52:08 <dmwit> kuribas: It's pretty trivial to do if you sort the list first and don't care about the order of the result, of course.
03:52:16 <orion> For a language to express the concept of a Monad, must it have higher-kinded types?
03:52:19 <kuribas> dmwit: I do care
03:52:26 <dmwit> And reasonable but not trivial if you sort the list first and do care about the order.
03:52:56 <kuribas> it's the solution for the minimal size of a size 4 truetype cmap table (assuming to overlap, then it get's harder).
03:53:30 <kuribas> format 4 cmap
03:53:52 <kuribas> now I am not sure it can be done in O(n)
03:54:41 <kuribas> dmwit: I don't see how sorting helps
03:54:55 <kuribas> dmwit: the order of the list must be preserved
03:54:57 <dmwit> I will show you. =)
03:55:22 <Ariakenom> It's reminiscent of the "Maximum subarray" problem
03:55:42 <Ariakenom> So my thoughts go to kadane's algorithm
03:55:47 <tdammers> orion: depends on your definition of "express"
03:55:58 <marutks> I can't 'stack upgrade'   , fails with AesonException "Error in $['extra-deps'][0]: failed to parse field 'extra-deps': failed to parse field extra-deps: (Invalid package identifier: \"rio-0.1.1.0@rev:0\",\"rio-0.1.1.0@rev:0\")"
03:56:00 <tdammers> you can certainly have monads in JavaScript, but they will not be reflected in any types
03:57:36 <[exa]> Ariakenom: this only has some different internals, you need matching maximum size (not sum) and the subsolutions may be filtered by summing to something greater than -4
04:02:25 <dmwit> kuribas: https://lpaste.net/1783685620082671616
04:02:32 <marutks> what should I do to upgrade stack ?
04:02:43 <Ariakenom> well with maximum you know to keep only non-negative substrings. In this case you should keep some that don't sum to <-4 as well
04:04:36 <dminuoso> marutks: https://github.com/commercialhaskell/stack/issues/3903
04:04:37 <kuribas> dmwit: the type is [a] -> [[a]]
04:04:38 <dmwit> Fun fact: the type signature I gave caught a bug in my first implementation.
04:05:01 <byorgey> marutks: https://docs.haskellstack.org/en/stable/install_and_upgrade/#upgrade  you can run the executable from get.haskellstack.org with the -f option
04:05:05 <dmwit> kuribas: It's easy to translate my form to yours: `(\(sumsToSmallNumber, rest) -> sumsToSmallNumber:map return rest)`.
04:05:05 <kuribas> dmwit: I wonder if you solved the same problem?
04:05:44 <dmwit> Dunno. Now I wonder if you were precise when you said subsequence instead of substring.
04:06:58 <Ariakenom> I was about to say yes. I assumed substring because of the ordering constraint
04:08:44 <kuribas> hm, is this a better description?  I need to minimize the number of subsequences, where each subsequence is either a singleton, or adds to no more than -4.
04:08:55 <kuribas> the resulting list is the concatenation of the original.
04:09:03 * hackage diagrams-postscript 1.4.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.4.1 (BrentYorgey)
04:10:33 <Ariakenom> kuribas: Are you aware of the definitions of subsequence and substring? And do you want a subsequence?
04:10:51 <kuribas> Ariakenom: no, what is the difference?
04:10:57 <kuribas> I suppose I mean substring then?
04:11:22 <Ariakenom> yes. subsequences are not necessarily contiguous
04:12:06 <kuribas> ok, substring then
04:15:28 <Ariakenom> nice. yeah your "concat new = old" does imply that now
04:27:57 <dmwit> kuribas: Nice, your "minimize the number of substrings" clarified an edge case I was pondering in the shower.
04:28:35 <dmwit> (Namely: if I could make substrings of length 5 and 5, would that be better or worse than if I could shift some elements from the middle to make it 3 and 6?)
04:32:57 <dmwit> It still seems tricky, of course, but at least it seems well-posed. =)
04:52:15 <dmwit> kuribas: [-4,1,-1]?
04:52:49 <kuribas> [[-4, 1, -1]]
04:53:07 <kuribas> hm, it seems I need even more constraints
04:56:43 <Ariakenom> if we use kadane to find a minimum substring and then repeat on the strings before and after that.
04:56:56 <Ariakenom> stopping when the minimum is greater than -4
04:58:39 <Ariakenom> Then all that's left is to "fix up" the ok groups by seeing if we can extend them left or right to include more elements
04:58:48 <Ariakenom> possibly ...
05:01:01 <Ariakenom> We know they won't reach another group since that would yield a greater minimum
05:05:47 <Ariakenom> And by Kadane's I mean https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm
05:17:33 * hackage mwc-probability-transition 0.4 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.4 (ocramz)
05:18:29 <Ariakenom> no that wont work
05:18:48 <kuribas> Ariakenom: sorry, I changed my problem description...
05:19:37 <Ariakenom> to?
05:23:03 * hackage cabal2spec 2.1.1 - Convert Cabal files into rpm spec files  http://hackage.haskell.org/package/cabal2spec-2.1.1 (PeterSimons)
05:23:25 <kuribas> Ariakenom: https://lpaste.net/5319408083762413568
05:23:30 <kuribas> minimize the cost function
05:23:49 <kuribas> by partitioning the list
05:24:46 <tabaqui1> how stable is GHC.Compact? On hackage it is marked as unstable, but there are only 3 tickets on gho and all are closed
05:25:25 <dmwit> kuribas: That... actually seems like the same problem to me.
05:25:31 <dmwit> oh
05:25:38 <kuribas> dmwit: I thought so, but I was wrong
05:25:41 <dmwit> I see, it's not.
05:25:49 <kuribas> in fact, it seems easier
05:25:59 <dmwit> Indeed. `id`
05:26:08 <dmwit> well, `return`
05:26:35 <dmwit> Ack, I guess not.
05:26:39 <dmwit> Okay, it's just a different problem.
05:27:01 <kuribas> is partition the right term?
05:27:26 <dmwit> Probably not. But I know what you mean, I think.
05:27:26 <kuribas> like [1, 2, 3] => [[1], [2, 3]], [[1, 2], [3]], etc...
05:28:37 <Ariakenom> Could just state it in symbols. solve x = y; concat y = x; minimize (cost y)
05:29:37 <kuribas> nevermind, I have a solution already
05:29:43 <kuribas> unless you'd like to know the problem :)
05:31:03 * hackage simple-effects 0.10.0.2 - A simple effect system that integrates with MTL  http://hackage.haskell.org/package/simple-effects-0.10.0.2 (darwin226)
05:33:28 <Ariakenom> kuribas: ofc. after all of this :)
05:40:17 <dmwit> Well, entries that are 8 or less and in the middle of the list can definitely get merged into their neighbor, without making the solution any worse. And 12 or greater can definitely go in a singleton without making the solution any worse. But those 9,10,11 values seem tricky.
05:42:33 * hackage testbench 0.2.1.2 - Create tests and benchmarks together  http://hackage.haskell.org/package/testbench-0.2.1.2 (IvanMiljenovic)
05:55:17 <kuribas> Ariakenom:   <kuribas> Ariakenom: https://lpaste.net/5319408083762413568
05:55:17 <kuribas>   <kuribas> minimize the cost function
05:55:17 <kuribas>   <kuribas> by partitioning the list
05:55:17 <kuribas>  <tabaqui1> how stable is GHC.Compact? On hackage it is marked as unstable,
05:55:20 <kuribas> 	    but there are only 3 tickets on gho and all are closed
05:55:23 <kuribas>     <dmwit> kuribas: That... actually seems like the same problem to me.
05:55:26 <kuribas>     <dmwit> oh
05:55:31 <kuribas>   <kuribas> dmwit: I thought so, but I was wrong
05:55:34 <kuribas>     <dmwit> I see, it's not.
05:55:37 <kuribas>   <kuribas> in fact, it seems easier
05:55:40 <kuribas>     <dmwit> Indeed. `id`
05:55:40 <kuribas>     <dmwit> well, `return`
05:55:43 <kuribas>     <dmwit> Ack, I guess not.
05:55:47 <kuribas>     <dmwit> Okay, it's just a different problem.
05:55:50 <kuribas>   <kuribas> is partition the right term?
05:55:52 <kuribas>     <dmwit> Probably not. But I know what you mean, I think.
05:55:56 <kuribas>   <kuribas> like [1, 2, 3] => [[1], [2, 3]], [[1, 2], [3]], etc...
05:56:00 <kuribas> <Ariakenom> Could just state it in symbols. solve x = y; concat y = x;
05:56:03 <kuribas> 	    minimize (cost y)
05:56:05 <merijn> kuribas: Get a better client that stops you from pasting multiple lines >.>
05:56:06 <kuribas>   <kuribas> nevermind, I have a solution already
05:56:09 <kuribas>   <kuribas> unless you'd like to know the problem :)
05:56:11 <kuribas>           * hackage simple-effects 0.10.0.2 - A simple effect system that
05:56:14 <kuribas> 	    integrates with MTL
05:56:17 <kuribas> 	    http://hackage.haskell.org/package/simple-effects-0.10.0.2
05:56:20 <kuribas> 	    (darwin226)
05:56:23 <kuribas> <Ariakenom> kuribas: ofc. after all of this :)
05:56:26 <kuribas>     <dmwit> Well, entries that are 8 or less and in the middle of the list can
05:56:30 <kuribas> 	    definitely get merged into their neighbor, without making the
05:56:33 <kuribas> 	    solution any worse. And 12 or greater can definitely go in a
05:56:36 <kuribas> 	    singleton without making the solution any worse. But those 9,10,11
05:56:39 <kuribas> 	    values seem tricky.
05:56:42 <kuribas>           * hackage testbench 0.2.1.2 - Create tests and benchmarks together
05:56:46 <kuribas> 	    http://hackage.haskell.org/package/testbench-0.2.1.2
05:56:48 <kuribas> 	    (IvanMiljenovic)
05:56:51 <kuribas> ERC> Ariakenom: https://lpaste.net/5030956108773064704
05:56:56 <kuribas> sorry
05:57:00 <kuribas> Ariakenom: https://lpaste.net/5030956108773064704
05:57:04 <kuribas> merijn: irc
05:57:08 <kuribas> merijn: erm erc from emacs
05:57:14 <kuribas> don't know why it pasted all that
05:57:20 <kuribas> Ariakenom: so I want a better version of "best"
05:57:32 <kuribas> as this one is O(n!)
05:58:52 <Ariakenom> I thought you meant to describe what the problem was at a higher level
05:59:12 <kuribas> Ariakenom:  yeah, this is the problem
06:00:33 <kuribas> Ariakenom: the real problem is to find a minimum segmentation for a format 4 cmap table: https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-4-segment-mapping-to-delta-values
06:00:52 <[exa]> kuribas: _please_ use pastebin
06:01:19 <[exa]> (even for pasting errors :D)
06:01:23 <kuribas> [exa]: I know, that was a problem with my client.  Sorry about that :(
06:01:44 <[exa]> np I started to react before actually reading what's in there
06:03:19 <danpl> hey guys, I’ve encountered this example in a haskell book and I can’t get my head around it
06:03:21 <danpl> fibs = 1 : scanl (+) 1 fibs
06:03:42 <kuribas> danpl: it uses lazyness :)
06:04:33 <kuribas> danpl: this is what happens:
06:04:36 <[exa]> danpl: did you see the vaguely related example with fibs = 0:1:zipWith (+) fibs (tail fibs) ?
06:06:37 <danpl> [exa]: that’s even more confusing  :( what I can’t grasp is what is sort of the base case?
06:07:06 <kuribas> danpl: the base case is the (1:)
06:07:31 <kuribas> danpl: so it uses that to find the second element
06:07:32 <danpl> kuribas: oh, so the initial list we pass to scanl is [1]?
06:07:44 <kuribas> danpl: no, the initial list is already the result
06:08:07 <kuribas> danpl: it's (1:_something), where _something isn't evaluated yet
06:08:38 <kuribas> danpl: so it finds 1, then it can calculate the first element of _something
06:09:21 <kuribas> danpl: so _something becomes (1:_something2)
06:10:43 <electrocat> can you tell ghcid to drop me in a repl if compilation succeeds?
06:11:22 <kuribas> danpl: the reason it doesn't loop, is that because of lazyness, it doesn't care the rest of the list isn't evaluated yet.
06:11:52 <kuribas> danpl: it only looks for the first element, which is uses to calculate the second.
06:12:06 <kuribas> danpl: then it uses the second to calculate the third, and so on.
06:14:09 <cocreature> electrocat: afaik no
06:14:33 <Hjulle> What's a good channel for asking questions about category theory?
06:14:43 <cocreature> Hjulle: there is ##categorytheory iirc
06:17:15 <danpl> kuribas: gotcha, it clicked finally. thanks
06:19:04 <Hjulle> What's a category where all arrows have inverses called? One such that for all arrows f : a->b, there exists an f^-1 : b -> a such that f o f^-1 = id and f^-1 o f = id.
06:20:05 <cocreature> Hjulle: a groupoid
06:20:38 <Hjulle> Thanks
06:26:18 <dmwit> kuribas: There are 2^(n-1) ways to split a list, not n!. Exponential still sucks, obviously, and I'm super confident it can be done in subexponential time, but at least it's not n^n... =)
06:30:16 <phadej> monoidoid, so funny.
06:31:03 * hackage streaming-concurrency 0.3.1.2 - Concurrency support for the streaming ecosystem  http://hackage.haskell.org/package/streaming-concurrency-0.3.1.2 (IvanMiljenovic)
06:37:09 <kuribas> dmwit: ah right, thanks
06:37:40 <kuribas> dmwit: I am pretty sure it can be done in linear time :)
06:37:55 <kuribas> dmwit: the advantage of this is that it is easier to test if the solution works.
06:38:37 <Ariakenom> it's always nice to have a simple solution for verification
06:54:33 * hackage streaming-process 0.1.0.0 - Streaming support for running system process  http://hackage.haskell.org/package/streaming-process-0.1.0.0 (IvanMiljenovic)
07:10:52 <EvanR> good morning
07:16:05 * ddellacosta waves good morning to EvanR from Japan, where it is almost time for bed
07:26:10 <jchia_> Hi EvanR
07:41:04 <dmwit> kuribas: Yes, the "obviously correct" solution is always good to have. If nothing else than as a QuickCheck target. =)
07:43:36 <EvanR> i now see that "obviously not wrong" and "not obviously wrong" are both relatively weak against "obviously correct", what have we been doing with these awful adages
07:48:38 <chessai> Does anyone know why cabal new-haddock fails to parse this UNPACK pragma, but cabal new-build is fine with it? https://gist.github.com/chessai/471d30fd6e10df796d8a59ec2cf244aa
07:49:36 <merijn> chessai: Haddock and GHC are not the same tools, so the fact that it works for one doesn't say much about the other?
07:50:08 <merijn> chessai: Also, which cabal-install version?
07:50:25 <chessai> merjin: I understand that it's not necessary for their behaviour to be the same, but it would most certainly be preferable
07:50:37 <chessai> 2.2.0.0
07:50:45 <c_wraith> that's a weird failure, though. pragmas are intended to be parsed as comments by tools that don't understand them.
07:50:46 <merijn> new-haddock pre 2.2 was definitely utterly broken, 2.2 *might* be better
07:51:29 <chessai> going to see if this is already a reported issue
07:51:34 <merijn> I've mostly been using HEAD to get a sane new-haddock
07:51:49 <merijn> chessai: Might wanna try cabal-install HEAD first to see if it's not already fixed
07:51:58 <chessai> alright
07:52:06 <cocreature> that looks more like an issue related to haddock rather than cabal-install
07:52:22 <chessai> that's where i was going to report the issue, haddock
07:52:26 <merijn> cocreature: Well, for some versions of cabal "new-haddock" was a no-op after running new-build :)
07:52:38 <cocreature> merijn: it’s clearly not a noop here :)
07:52:53 <merijn> cocreature: 2.2 might've already gotten the fix for that, yes
07:53:23 <cocreature> my point is that a parse error is very unlikely to be related to issues in cabal-install
07:54:16 <merijn> cocreature: On the one hand, yes. On the other, that looks more like GHC's fancy new error output than haddock's
07:54:35 <chessai> haddock uses the GHC API, no?
07:54:48 <merijn> I think the newest version does, yes
07:55:13 <chessai> [nix-shell:~/development/freq]$ haddock --version
07:55:13 <chessai> Haddock version 2.19.0, (c) Simon Marlow 2006
07:55:13 <chessai> Ported to use the GHC API by David Waern 2006-2008
07:56:06 <chessai> a new version came out a few days ago
07:56:20 <chessai> of haddock
07:57:03 <cocreature> the new version was shipped with 8.4.2 so it has been out for a bit longer by now. it just took quite some time until someone got around to uploading it to hackage
07:57:16 <chessai> ah, alright
07:58:20 <chessai> switching from 841 to 842
07:58:30 <chessai> and the newer haddock, ofc
07:58:34 <chessai> will see if it still fails
08:00:31 <mupf> Could anyone in here give me some advice in how to get going in learning Haskell on Arch Linux? These are the packages I already have installed: https://paste.ubuntu.com/p/8CVm9WjYBW/ I'm just looking for an straigh-forward way of creating new projects to try out code snippets.
08:00:48 <mupf> etc.
08:04:25 <Cale> mupf: I would recommend against using Arch's Haskell-related packages, sadly. They've messed up a bunch of stuff related to linking, to the extent that I would probably prefer just to install things in almost any other way.
08:05:04 <mupf> I was somehow aware of that.but sadly, this alternate haskell repository seems also down
08:05:59 <mupf> so what's the "way to go" now?
08:06:03 * hackage require 0.0.1 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.0.1 (NickSeagull)
08:07:32 <hexagoxel> oh my, the power of ghc plugins
08:08:52 <EvanR> mupf: the situation on arch is a bit dicey, because ghc really wants to statically link stuff. But arch haskell packages including ghc dont install any static libs
08:09:10 <EvanR> I am reading this for the latest: https://wiki.archlinux.org/index.php/Haskell
08:09:15 <cocreature> mupf: remove everything haskell-related that you installed via pacman except for ghc, ghc-libs and ghc-static and then use cabal to manage deps
08:09:25 <cocreature> (or stack if you prefer that)
08:11:18 <Cale> Or you could even go a step further and get the generic linux binary of GHC from mupf: Yeah, possibly the simplest thing is just to install the generic linux binaries for GHC https://www.haskell.org/ghc/download_ghc_8_4_2.html and then just get the tarball of cabal-install from Hackage, and run its bootstrap script... hopefully that should work well, I haven't tried it in some time.
08:11:57 <cocreature> how you get GHC doesn’t really matter for the most part
08:12:06 <Cale> ah, okay
08:12:22 <Cale> I was unsure as to whether their packages made any changes to it
08:12:37 <mupf> I check it out asap
08:12:40 <mupf> thanks
08:12:42 <cocreature> at least they haven’t made changes that broke things for me so far :)
08:13:05 <cocreature> but the arch repos are still stuck at 8.2.2 so if you want 8.4 you’ll have to get it from somewhere else
08:13:29 <cocreature> cabal also has official binaries these days so you might be able to avoid the bootstrap script https://www.haskell.org/cabal/download.html
08:13:37 <cocreature> but I’ve never used them so no idea how well they work
08:14:20 <Cale> tbh, lately I don't even install ghc globally on my machine and just use nix-shell to obtain it all the time :)
08:14:48 <Cale> (but that's more involved so I wouldn't recommend it unless you're already planning to become comfortable with nix)
08:15:17 <cocreature> even if you don’t use nix, there is little reason to install it globally. you can just change the path or use cabal’s -w option
08:16:31 <mupf> downloading cabal-install and ghc binaries now
08:22:42 <mupf> cocreature Cale : got it. unpacked cabal, works. extracted ghc. But what now?
08:23:01 <EvanR> wow the arch wiki on this is incredibly confusing and misleading to me
08:23:30 <mupf> At least I knew it was broken because I had troubles installing it before
08:23:42 <mupf> a few months ago.
08:24:00 <mupf> Maybe I switch to nix once I get used to Haskell ;)
08:24:24 <mupf> it sounds intriguing
08:25:32 <cocreature> mupf: follow the installation instructions in the GHC tarball. iirc it’s the classic "./config --prefix=… && make install" dance
08:28:03 * hackage tintin 1.2.5 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.2.5 (NickSeagull)
08:29:52 <ziman> I just "pacman -Sy stack" and then use that to build stuff
08:31:02 <mupf> Perfect.
08:32:03 * hackage forma 1.1.0 - Parse and validate forms in JSON format  http://hackage.haskell.org/package/forma-1.1.0 (mrkkrp)
08:32:50 <mupf> ziman what's stack?
08:33:55 <sm> just for the record, I've seen arch users say their haskell packages work fine when you follow the arch wiki page
08:34:19 <sm> morning all
08:34:25 * shapr hugs sm
08:34:40 <shapr> GOOD MORNING!
08:35:13 <mupf> morning shapr
08:36:36 <shapr> mupf: good morning! how's code?
08:37:49 <EvanR> yeah this is me reading from a non-arch/arch-refugee perspective
08:38:26 <mupf> shapr: currently trying to figure out how to create a haskell dev environment on my arch system
08:52:24 * sm hugs shapr
08:52:57 <sm> mupf: excuse me if I misremember, was it you that informed haskell-ops about ertes ?
08:54:42 <sssilver> hey guys, semiofftopic, in Set theory, how would you represent set of m that is a subset of M but is neither x nor y -- does { m | m ∉ {x, y}} ⊆ M make sense?
08:56:38 <Entroacceptor> 17:54 < sssilver> hey guys, semiofftopic, in Set theory, how would you represent set of m that is a subset of M but is neither x nor y -- does { m | m ∉ {x, y}} ⊆ M make sense?
08:56:42 <Entroacceptor> wha, sorry
09:01:29 <skeuomorf> What does this mean? `data Stream (method :: k1) (framing :: *) (contentType :: *) a`. So, I know what a data declaration is, I also know that we can have data types with no constructors https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#data-types-with-no-constructors   However what does (x :: k) signify here and what does the whole expression mean in this context?
09:01:56 <Entroacceptor> sssilver: wouldn't you just say m ⊆ M \ {x,y}
09:02:30 <sssilver> Entroacceptor: is \ the correct symbol for that?
09:03:00 <Entroacceptor> or wait, I think I misinterpreted your question
09:03:33 <Entroacceptor> A\B is everything in A but not in B. {1,2,3} \ {3} = {1,2}
09:03:52 <skeuomorf> sssilver: It's *a* correct notation https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation
09:04:09 <skeuomorf> sssilver: Set Difference
09:05:04 <Entroacceptor> or would you say "m is any subset of M, but not subset x and definitely ont subset y"
09:05:12 <sssilver> ty skeuomorf
09:05:19 <skeuomorf> sssilver: cheers
09:05:20 <sssilver> Entroacceptor: x and y are not sets
09:05:29 <sssilver> they're elements of set
09:05:52 <skeuomorf> sssilver: Entroacceptor still stands
09:06:04 <skeuomorf> sssilver: {x, y} is a set of the elements x and y
09:06:14 <sssilver> sure yeah, that makes sense
09:11:13 <mupf> sm yes
09:14:40 <lyxia> skeuomorf: much like function parameters have types, a type constructor's parameters have kinds, and you can make them explicit with that notation.
09:14:48 <jchia_> What's a good library for doing simple mysql queries (making no or very little use of 'JOIN')? Ability to also use postgresql by the same library or library family/group is preferred.
09:15:39 <sm> mupf: I'm very sorry. Excuse me if this is a painful subject, but did you provide them any more details ? None of the posts so far have provided any, confirmed you are a real person, etc. (But it seems you are).
09:18:03 <sm> a lot of us have happy memories of chatting with ertes and if/when possible it would be good to know a little more about what happened.
09:19:44 <mupf> sm: I could provide you with at least some details in case you truly interested about what happened. But I prefer not to discuss this in public. Feel free to PM me.
09:20:02 <mupf> ertes really cared about his privacy and I respect that.
09:20:48 <mupf> And yes, I am a real person. I considered him my best friend ever since we first met back in 2002.
09:25:09 <sm> mupf: fair enough. I think the community would be glad to know, but I respect that. Thanks
09:26:16 <skeuomorf> lyxia: ok, are these parameters optional? cause the usecase that I've seen only uses the method parameter e.g. `type StreamGet  = Stream 'GET`
09:26:52 <mupf> sm: retrospective; when I got the note, I really wanted to know about what exactly happened. I really needed to know. That's why I think it is important to tell people in case they are interested about it. It's kind of an balancing act between what I think is important and ertes' privacy
09:28:04 <lyxia> skeuomorf: they're not optional, this is Stream being applied to its first argument, and you can then apply StreamGet to the rest of it.
09:28:46 <lyxia> skeuomorf: for example you can also write "type T = Maybe", this doesn't mean Maybe's parameter is optional.
09:32:20 <mupf> sm: one thing tough. He truly enjoyed and appreciated life. He was kind of a... Let me look up the right term
09:33:24 <mupf> man-about-town
09:33:55 <mupf> Bon viveur
09:38:40 <skeuomorf> lyxia: Oh, I get it, thanks!
09:41:09 <gazanga> why map (-2) [1..5] have error, but map (*2) [1..5] is OK?
09:41:31 <mnoonan> :t (*2)
09:41:33 <lambdabot> Num a => a -> a
09:41:34 <mnoonan> :t (-2)
09:41:35 <lambdabot> Num a => a
09:41:48 <mnoonan> special case in the parser for prefix - as negation :|
09:42:01 <mnoonan> but you can use this:
09:42:05 <mnoonan> :t negate
09:42:06 <lambdabot> Num a => a -> a
09:42:06 <gazanga> so how i map (-)
09:42:16 <gazanga> ah thanks!
09:42:40 <gazanga> wait no, negate is not what i want
09:42:45 <yushyin> subtract
09:42:46 <gazanga> its nagating
09:42:49 <mnoonan> oops, sorry :|
09:42:52 <gazanga> :)
09:42:54 <mnoonan> yes, 'subtract' :)
09:42:54 <nshepperd> :t (subtract 2)
09:42:55 <lambdabot> Num a => a -> a
09:42:58 <gazanga> i need map (-2) some list
09:43:02 <gazanga> ah OK :)
09:43:29 <gazanga> thanks again
09:49:30 <gazanga> is there function to multiply all elements in a list?
09:49:43 <gazanga> [1,2,3] == 6
09:50:11 <sedeki> product [1,2,3]
09:50:16 <gazanga> i can use fold i think but is there something else?
09:50:20 <gazanga> ah great!
09:50:22 <gazanga> :-)
09:50:25 <gazanga> thanks
09:50:33 <sedeki> np
10:03:17 <AWizzArd> When I don’t demand strictness – are there cases where ghc can prove that it would be okay to make my code strict (i.e. non-lazy) and then does so? So direct values instead of thunks?
10:05:11 <kaol> AWizzArd: https://wiki.haskell.org/Performance/Strictness#Strictness_analysis
10:06:08 <AWizzArd> kaol: thx
10:07:49 <quicksilver> sometimes it proves the values themselves are not necessary
10:07:54 <quicksilver> and you don't even get values
10:07:56 <quicksilver> just code
11:08:36 <cocreature> if GHC didn’t have strictness analysis, the implementation of "sum" and "product" in base would suck even more
11:14:10 <dmj`> teh: ping
11:14:56 <dmj`> jml: ping
11:19:09 <loppy> I get this error running ` stack --nix ghci cardano-sl-core:test:goldentest --test ` , error =   ` singleBuild: invariant violated, missing package ID missing`
11:19:34 <loppy> stack --nix build cardano-sl-core:test:goldentest --test  <--- works fine and builds
11:24:01 <IRC-Source_63579> hi
11:31:53 <loppy>  I get this error running ` stack --nix ghci cardano-sl-core:test:goldentest --test ` , error =   ` singleBuild: invariant violated, missing package ID missing`
11:31:59 <loppy> stack --nix build cardano-sl-core:test:goldentest --test  <--- works fine and builds
11:39:33 * hackage extra 1.6.7 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.6.7 (NeilMitchell)
11:43:55 <johnw> phadej: ;)
11:44:34 <johnw> @tell phadej You might enjoy the article "Generic Programming with Adjunctions" by Ralf Hinze too
11:44:34 <lambdabot> Consider it noted.
12:05:19 <kaol> I wish the type system would somehow catch it if I used readMVar when I meant to use takeMVar.
12:06:16 <mitchellsalad_> you'd also need a type system for your type system to make sure you don't write down the wrong type!
12:08:34 * hackage zephyr 0.1.1.0 - Zephyr tree shaking for PureScript Language  http://hackage.haskell.org/package/zephyr-0.1.1.0 (coot)
12:15:53 <lukelau> kaol: It would be cool if there were dependent types to hold type information about wether or not an MVar was full or not
12:16:08 <phadej> johnw: thanks
12:18:00 <cocreature> lukelau: that seems somewhat hard given that another thread can change that
12:19:25 <kaol> I've no idea how to pull it off but it makes me sad that both are MVar a -> IO a. Come on, tell the world about your side effect.
12:33:44 <EvanR> youre wishing for a model of concurrency to be encoded in your dependent types... or have a whole type system dedicated to it
12:34:33 <EvanR> like ordering the megasampler at the mexican restaurant, takes guts
12:35:30 * kaol also wants a pony
12:40:36 <dmwit> cocreature: On the other hand, giving some threads only read permissions and other threads only write permissions would be a cinch. (In fact you probably don't even need dependent types for that.)
12:40:46 <dmwit> ...*and* is sufficient for many use cases of MVar.
12:52:35 <nshepperd1> Sounds like a linear typing kinda thing
12:53:12 <dmwit> Plain old Haskell types do just fine.
12:53:27 <nshepperd1> newtype LinearMVar a = Linear (MVar a)
12:53:49 <dmwit> newtype Reader a = Reader (MVar a); newtype Writer a = Writer (MVar a); takeMVar :: Reader a -> IO a; putMVar :: a -> Writer a -> IO ()
12:54:05 <nshepperd1> I mean, an mvar designed for holding linear typed values would indeed only support take and put
12:54:20 <dmwit> ...readMVar is just a take and then a put.
12:54:39 <dmwit> So if the goal is to prevent the wrong thread from using readMVar, just allowing those operations isn't enough.
12:54:44 <nshepperd1> And maybe readMVar would have a different type indicating that the contained value is not linear
12:55:19 <nshepperd1> readMVar requires nonlinear use of the returned reference
12:55:50 <dmwit> Okay, I'm lost.
12:56:06 <mitchellsalad_> dmwit: readMVar is not a take then a put anymore, it's a primitive
12:56:35 <EvanR> luckily :)
12:56:56 <mnoonan> readMVar is take, give you a copy, and put another copy back
12:57:21 <EvanR> when it was literally that, there were some nasty race conditions when you have more writers
12:57:32 <dmwit> mitchellsalad_: Neat.
12:57:36 <dmwit> mnoonan: Apparently not, any more.
12:57:47 <mitchellsalad_> dmwit: See also readTVarIO ;)
12:58:03 <mnoonan> dmwit: well, ok :) I just was trying to dig into why readMVar is nonlinear
12:58:15 <EvanR> the new readMVar feels kind of like a cheat
12:58:34 <EvanR> get the job done, but by ignoring the MVar narrative
12:59:18 <mitchellsalad_> I don't see it that way, it seems strictly better than actually taking the lock for a brief instant
12:59:27 <dmwit> agreed
12:59:39 <EvanR> yeah it does seem better
12:59:53 <EvanR> like my net worth in monopoly is also better if i cheat :)
13:00:10 <cocreature> haha I love that analogy :)
13:00:53 <YellowOnion> Has anyone tried developing with "Windows subsystem for Linux"?
13:02:58 <EvanR> microsofts naming policies ;_;
13:03:14 <EvanR> i would love a windows subsystem for linux
13:03:26 <EvanR> that works
13:03:43 <nshepperd1> I don't think it actually solves the problem, i just noticed it's one way readMVar and takeMVar could reasonably have different types
13:04:04 <nshepperd1> takeMVar works on "non-copyable" types
13:04:15 <YellowOnion> EvanR, I know the name for it is bizare.
13:07:01 <YellowOnion> EvanR, Their old name for Windows running older versions of windows was a good one "WoW' windows on windows.
13:07:12 <nshepperd1> The wine project should rename itself "Linux subsystem for Windows"
13:07:37 <EvanR> hahaha
13:08:09 <EvanR> BeOS subsystem for OS/2, good luck predicting what that is
13:09:15 <gazanga> a clue? here (https://lpaste.net/2172549987672522752) there are 2 function. the first one is wrriten twice. the second implementation is more haskelly. please give me a hint how to write the second function (fun2) in more haskelly way.
13:09:22 <YellowOnion> win32 subsystems for dos.
13:10:29 <gazanga> i don't see other way then just if statement.
13:11:32 <gazanga> please no solution :-)
13:11:58 <gazanga> if you give a hint i'll show you a picture of my cat.
13:12:39 <gazanga> it's a very sesy cat!
13:12:43 <gazanga> *sexy
13:13:28 <koala_man> the sum of the hailstone sequence?
13:14:02 <gazanga> koala_man: is this question for me?
13:14:14 <koala_man> gazanga: yes. that's what fun2 computes, right?
13:14:35 <gazanga> i don't know what it is "hailstone sequence"."
13:14:43 <koala_man> or its even parts anyways
13:14:55 <sm> EvanR: oh - re arch wiki page, I hadn't seen your comment about it page before I mentioned it
13:14:56 <gazanga> ifbut it doesnt matter
13:15:04 <gazanga> *but
13:15:30 <gazanga> if the number is 0 do 1, id it's even do this, and if its odd do that. thats all
13:15:39 <EvanR> reading it i was having flashbacks to linux distro system maintainence flamewars
13:15:52 <gazanga> sorry if its 1 do 0
13:15:58 <EvanR> the right way to do stuff was always the most acrimonious when it came to arch
13:16:27 <gazanga> EvanR: you talking about my functions?
13:16:40 <EvanR> no
13:16:43 <gazanga> OK
13:16:57 <sm> or WAS he ?
13:17:03 <sm> heheh
13:17:10 <gazanga> koala_man: this is my sexy cat https://ibb.co/i8HMqo
13:17:10 <EvanR> dundund
13:17:27 <koala_man> mmmmh I'd pet that
13:17:35 <EvanR> clicking it in hopes itll be haskell related
13:17:39 <gazanga> :-)
13:17:54 <gazanga> he is disabled cat :)
13:17:57 <sm> beautiful!
13:18:01 <gazanga> thanks!
13:18:42 <EvanR> disabled cat is disabled?
13:19:16 <gazanga> don't understand
13:19:21 <YellowOnion> gazanga, I'm not sure what you mean by "more haskelly" all 3 examples are fine.
13:19:22 <gazanga> but wait ill show you :)
13:19:34 <gazanga> YellowOnion: this is the exercise
13:19:49 <gazanga> YellowOnion: look here http://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
13:20:20 <gazanga> YellowOnion: and its homework for this chapter: http://www.seas.upenn.edu/~cis194/spring13/lectures/04-higher-order.html
13:21:29 <YellowOnion> :t iterate
13:21:31 <lambdabot> (a -> a) -> a -> [a]
13:21:51 <blarrrrrrrr> I keep on getting this error trying to invoke ghci `Error: singleBuild: invariant violated, missing package ID missing`
13:22:10 <blarrrrrrrr> using this command % stack --nix ghci cardano-sl-core:test:hedgehog --test
13:22:21 <blarrrrrrrr> using this command  `stack --nix ghci cardano-sl-core:test:hedgehog --test `
13:22:51 <koala_man> gazanga: I think the function looks fine, though since it's based on a well known mathematical sequence, it's possible to express it in terms of that instead
13:24:41 <gazanga> koala_man well i'm not familliar with this sequence. damn math again!
13:25:19 <koala_man> gazanga: it's also known by several names, see https://en.wikipedia.org/wiki/Collatz_conjecture
13:25:22 <gazanga> YellowOnion: i thought about it also but because iterate return [a] i didn't see how can i use it. but i akways get the head of it maybe.
13:25:29 <gazanga> or something else
13:25:49 <gazanga> thanks i'll look at it
13:26:23 <YellowOnion> gazanga, fun1' makes sense because it's a list, but fun2 seems too trival for it to matter...
13:26:38 <EvanR> collatz conjecture is good for generating brouwerian counterexamples at this point in history
13:27:01 <EvanR> since some of the unsolved things brouwer used are now solved
13:35:25 <YellowOnion> gazanga, http://amar47shah.github.io/posts/2016-08-28-point-free-part-2.html
13:39:41 <gazanga> thanks YellowOnion
13:42:09 <gazanga> i found a video of my cat that show how he is disabled. it is when he was young. and yes it is falling all the time also today. https://photos.app.goo.gl/AEmqglWFuy6mTeqC3
13:42:48 <gazanga> i also need to hold him that it could drink well :-)
14:08:02 <gazanga> how can i move from this:
14:08:11 <gazanga> aggregate f = (.) sum $ map f
14:08:13 <gazanga> to this:
14:08:23 <gazanga> aggregate f = (.) sum . map $ f
14:08:30 <gazanga> it's the same
14:08:33 <gazanga> but how
14:09:15 <gazanga> there is one more point (.) in there that i cant "read". what is the meaning?
14:10:01 <infinisil> :t (.) sum $ map f
14:10:02 <lambdabot> (FromExpr c, Show a, Num c) => [a] -> c
14:10:11 <infinisil> :t (.) sum . map $ f
14:10:12 <lambdabot> (FromExpr c, Show a, Num c) => [a] -> c
14:10:45 <geekosaur> (.) is . as a prefix function, that is ((.) a b) means (a . b)
14:11:14 <geekosaur> the extra parens are what tells it to use it as a function instead of an operator
14:12:43 <gazanga> is it mean that actually it is something like that:  (sum . map) . f
14:13:33 <gazanga> (.) sum . map $ f == (sum . map) . f  ----- (?)
14:14:14 <gazanga> > :t (sum . map) . f
14:14:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
14:14:28 <gazanga> :t (sum . map) . f
14:14:29 <lambdabot> error:
14:14:29 <lambdabot>     • Could not deduce (Foldable ((->) [()]))
14:14:29 <lambdabot>         arising from a use of ‘sum’
14:15:15 <gazanga> geekosaur: dont understand what is the difference between function and operator in your explanation
14:15:29 <geekosaur> the difference is only syntax
14:15:38 <dpyro> what's the difference between say `fmap` and `second` if you apply it to something like Either?
14:16:00 <gazanga> dpyro: i dont no what are those function :-)
14:16:08 <gazanga> didn't get there yet
14:16:10 <geekosaur> if you try to write (. a b) it does not mean the same thing as (a . b), you need to do something to tell the compiler you want (.) to be prefix instead of infix
14:16:11 <dpyro> i'm asking everyone here :)
14:16:25 <geekosaur> so we wrap it in extra parentheses like that
14:16:35 <gazanga> geekosaur: this i understand. but there is more . there.
14:16:40 <geekosaur> which in an expression like that one avoids even uglier stuff later
14:16:57 <geekosaur> try writing that with the . infix instead of prefix
14:17:07 <geekosaur> it gets ugly fast. the prefix form is clearer
14:17:16 <gazanga> i tried: (sum . map) . f
14:17:21 <gazanga> is it not the same?
14:18:31 <geekosaur> :t sum . map
14:18:32 <lambdabot> (Num [b], Foldable ((->) [a])) => (a -> b) -> [b]
14:18:37 <geekosaur> does that type make sense to you?
14:18:57 <gazanga> it's confusing
14:19:17 <gazanga> it was a tricky question? :)
14:19:20 <geekosaur> it's *nonsense*, more or less
14:19:25 <gazanga> ah Yes.
14:19:28 <geekosaur> it wants, among other things, to treat a list as a number
14:19:46 <geekosaur> so no, not the same thing
14:20:55 <gazanga> can you explain what does it mean? ((->) [a])  -- (even if its not useful i want to understand how to read it)
14:21:20 <geekosaur> that is a function that takes some kind of list and produces ... we know not what
14:21:36 <geekosaur> [a] -> something_here_we_can't_know
14:22:19 <gazanga> but function (till now) i always see like that (a -> b)
14:22:29 <geekosaur> right, this is prefix syntax for functions
14:22:47 <gazanga> ah like ((+) 2)
14:22:47 <geekosaur> because the b comes from the Foldable, and can't be named as such
14:22:50 <geekosaur> yes
14:22:59 <geekosaur> also just like that (.) you were asking about
14:23:15 <gazanga> OK.
14:23:22 <gazanga> thanks
14:23:51 <geekosaur> which still leaves that that type doesn;'t make much sense, and you should be wary of it
14:24:27 <geekosaur> basically any time you see something like (Num [a]) or anything else that isn't simply (Num somename), you should be looking to see where you made a mistake
14:26:20 <infinisil> :t (.)
14:26:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:26:26 <infinisil> :t (.) sum
14:26:27 <lambdabot> (Num c, Foldable t) => (a -> t c) -> a -> c
14:26:37 <geekosaur> in this case, the mistake is that you think ((sum . map) f a) is the same as (sum . (map f a))
14:26:45 <infinisil> :t map
14:26:46 <lambdabot> (a -> b) -> [a] -> [b]
14:26:52 <infinisil> :t (.) sum . map
14:26:53 <lambdabot> Num c => (a -> c) -> [a] -> c
14:27:28 <geekosaur> (I think)
14:29:10 <geekosaur> it's something of a common error. basically it looks like if you can dangle one parameter off the end, you should be able to do two the same way — but you can't, the types won't work; you need an extra application
14:29:43 * zykt[m] uploaded an image: arm.png (72KB) <https://matrix.org/_matrix/media/v1/download/matrix.org/wlBZNMUqkxsAjkrMAhfmOEID>
14:30:32 <nshepperd1> It looks to me like the confusion is thinking that "aggregate f = (.) sum . map $ f" involves (sum . map)
14:30:45 <nshepperd1> Which is forgetting that function application is highest precedence
14:31:08 <nshepperd1> It's ((.) sum) . map
14:31:16 <geekosaur> @unpl f (g a b)
14:31:16 <lambdabot> f (g a b)
14:31:20 <geekosaur> whoops
14:31:25 <nshepperd1> Not (.) (sum . map)
14:31:39 <geekosaur> (f (g b)) can be (f . g), but (f (g b c)) has to be something like ((f .) . g)
14:32:20 <gazanga> geekosaur: your last line very not clear to me :-)
14:32:55 <gazanga> the last part of course
14:33:01 <geekosaur> @pl \a b -> f (g a b)
14:33:01 <lambdabot> (f .) . g
14:33:25 <geekosaur> it can't be (f . g), it has to be (f .) . g
14:33:38 <gazanga> i dont know what is (f .) . g
14:33:57 <geekosaur> (f .) means (\x -> f . x)
14:34:04 <gazanga> OK
14:34:10 <geekosaur> you know (1+) ?
14:34:14 <geekosaur> same thing
14:34:22 <gazanga> yes
14:34:38 <geekosaur> (f .) is partially applied (.) the same way (1+) is partially applied (+)
14:34:54 <gazanga> yes so x in your lambda is a function passing
14:35:53 <pdxleif> I was looking to wrap a C API that depends on a resource by putting that context / resource in a reader monad (this one, in particular: https://github.com/pxqr/udev/blob/master/src/System/UDev/Context.hs#L55)
14:36:55 <gazanga> but again how (f (g b c)) is like ((f .) . g)
14:37:31 <pdxleif> So far I can write "wrappedDoThing :: FilePath -> ReaderT Foo IO Blah; wrappedDoThing path = ReaderT (\resource -> doThing resource path)"
14:37:38 <gazanga> g gets 2 arguments and then the result is passed to f
14:37:55 <geekosaur> yes, and your in tuition telsl you that should be the same as (f . g). but it is not
14:38:19 <geekosaur> what actually happens is it tries to apply b to c, *then* apply (f . g). which is wrong
14:38:26 <pdxleif> But I was hoping to not have that type sig specify an instance, and instead write it as (MonadReader Foo, m, MonadIO m) => FilePath -> m Blah
14:38:57 <geekosaur> which is why you need to insert the extra (.) to tell it no, c is a second argument, not a parameter to be applied to b
14:38:57 <pdxleif> Would such a thing be possible? Been playing around with asks/reader as liftIO...
14:39:38 <geekosaur> basically the (f .) means "there's another parameter to be applied" — which is c
14:40:10 <geekosaur> otherwise it thinks there isn't, and when it reaches "b c" is says "ah, c is a parameter for b"
14:40:42 <EvanR> which would allow it to work with "any reader monad as long as it has the Foo environment", seems like its going through a lot to allow not that much
14:41:27 <EvanR> for example it wont allow a monad which has a Foo and a Bar environment together in a pair
14:41:29 <gazanga> geekosaur: thanks for the explanation but i can't understand what you are telling me. i will save it for later reading. now my brain can't figure it out :)
14:41:38 <geekosaur> so (f . g) means there is one parameter coming up later. ((f .) . g) means there are two
14:41:54 <geekosaur> and that f has just claimed one of them
14:42:09 <nshepperd1> I use this 'aggregate' function all the time by the way. I call it sumMap by analogy with foldMap
14:42:34 <pdxleif> EvanR: Yeah - I could make it more general. I assumed other environments would go in a different Reader.
14:42:45 <EvanR> :(
14:42:51 <nshepperd1> sumMap f xs = sum (map f xs)
14:42:58 <aarvar> pdxleif: MonadReader has a fundep, so you can only have one environment per monad
14:43:04 <aarvar> but you can use classy lenses
14:43:11 <pdxleif> Figured it out. Just "ask >>= (\r => doThing r path".
14:43:17 <aarvar> (MonadReader r m, HasFoo r, MonadIO m) => ...
14:43:22 <EvanR> mtl insanity
14:43:28 <pdxleif> Shoulda known by the nested monads in the error message I was getting. Sorry for the noise.
14:43:30 <aarvar> how is it insanity?
14:43:48 <pdxleif> aarvar: Ah, thanks.
14:44:33 <EvanR> at least do you also expose a thing :: Foo -> FilePath -> IO Blah
14:44:41 <aarvar> why would you?
14:44:53 <aarvar> you can just use runReaderT
14:45:18 <EvanR> so you can use it without having to create a suitable monad to satisfy the transformerization
14:45:38 <aarvar> a suitable monad already exists
14:45:41 <aarvar> it's called ReaderT
14:45:43 <pdxleif> EvanR: That's the signature of the thing I'm wrapping, e.g. https://github.com/pxqr/udev/blob/master/src/System/UDev/Device.hs#L79
14:45:50 <aarvar> ReaderT Foo IO, in this case
14:46:10 <phadej> alaf Sum foldMap
14:46:15 <phadej> :t alaf Sum foldMap
14:46:16 <lambdabot> (Num b, Foldable t) => (a -> b) -> t a -> b
14:46:19 <EvanR> you could also "just" use liftIO in case youre not in IO
14:46:32 <phadej> :t \f xs -> sum (fmap f xs)
14:46:33 <EvanR> you could just jump through hoops you have set up
14:46:33 <lambdabot> (Functor t, Num a1, Foldable t) => (a2 -> a1) -> t a2 -> a1
14:46:44 <aarvar> EvanR: what?
14:47:12 <phadej> power to the newtypes, alaf.
14:47:21 <EvanR> pdxleif: cool
14:47:44 <EvanR> aarvar: i appreciate the option to keep things simple
14:48:08 <ggVGc> has anyone here used cloud haskell for a real project?
14:48:13 <ggVGc> I'm fairly curious about it
14:49:12 <nshepperd1> alaf Cthulhu ftaghn
14:49:43 <aarvar> EvanR: I assume you also favor using church encoded lists rather than foldable then?
14:49:53 <phadej> there's alaf even in Cabal, http://hackage.haskell.org/package/Cabal-2.2.0.1/docs/Distribution-Compat-Newtype.html#v:alaf
14:50:00 <pdxleif> If you want mtl instanity, why not use MonadIO, MonadBase IO, MonadTrans IO, etc all at once?
14:50:07 <phadej> I'm proud I put it there
14:52:34 <EvanR> thats an odd conclusion
14:53:15 <aarvar> EvanR: well, Foldable is about as useful as MonadIO
14:53:43 <EvanR> i wasnt advocating using liftIO and MonadIO
14:53:55 <EvanR> ill advocate using just IO everywhere
14:54:05 <phadej> alaf, is cool.
14:54:09 <EvanR> not church encoded IO
14:54:09 <phadej> :t alaf Const traverse
14:54:10 <lambdabot> (Monoid a', Traversable t) => (a -> a') -> t a -> a'
14:54:14 <phadej> :t foldMapDefault
14:54:15 <lambdabot> (Monoid m, Traversable t) => (a -> m) -> t a -> m
14:54:16 <aarvar> then you also shouldnt advocate using Foldable?
14:54:26 <phadej> definitions just fall out of it
14:54:50 <EvanR> i havent found Foldable to be a pain in the ass
14:55:14 <aarvar> how is MonadIO a pita
14:55:20 <EvanR> you can basically replace list with Foldable f and all the functions basically just work
14:55:46 <aarvar> and you can't with MonadIO?
14:55:48 <EvanR> "just use runReaderT ..." ...
14:55:54 <EvanR> when you want to apply a function
14:55:57 <EvanR> heh
14:56:20 <EvanR> no you cant with MonadIO actually, unless you use the lifted IO package or whatever
14:56:31 <aarvar> only to the extent that you also cant with foldable
14:56:34 <EvanR> which exports polymorphic prelude IO stuff
14:56:37 <aarvar> with MonadIO you can only replace IO return types
14:56:45 <aarvar> and with Foldable you can only replace list arguments
14:56:49 <EvanR> and then liftIO many things
14:57:06 <i0-dfn> `cabal clean && cabal configure --enable-profiling && cabal build` fails for me with lots of linker errors like /run/user/1000/ghc11175_0/ghc_16.p_o:(.text+0x12224): undefined reference to `transformerszm0zi5zi5zi0zm1bbDhu8ypp8LC8lJMFju65_ControlziMonadziTransziCont_zgzgze_CagA_cc'
14:57:08 <aarvar> well, yes the prelude isnt sufficiently polymorphic
14:57:30 <aarvar> kind of like how it used to not generalize everything to Foldable
14:57:42 <EvanR> to contrast at least having a normal IO action in the api, you suggested using classy lenses...
14:57:45 <i0-dfn> i'm using a nix binary cache and wondering if that is the issue. for example if i do `nm /nix/store/*-transformers-0.5.5.0/lib/ghc-8.2.2/transformers-0.5.5.0/libHStransformers-0.5.5.0-*.a | grep transformerszm0zi5zi5zi0zm1bbDhu8ypp8LC8lJMFju65_ControlziMonadziTransziCont_zgzgze_` i get a bunch of close-but-not-exact matches
14:58:11 <EvanR> just saying there is a distinction between the two in terms of complexity
15:17:03 <Arney> hello, whats the best haskell pdf  can link me too
15:17:28 <Arney> inb4 "whats the best" i heard learn you a haskell for great good is considered old
15:20:28 <EvanR> even older but imo still good
15:20:32 <EvanR> @where gentle introduction
15:20:33 <lambdabot> http://www.haskell.org/tutorial/
15:31:22 <yukkuri> hi, is programming possible without decision-making imperative control strucures (if/then/else/ternary) AND without decision-making pattern-matching (choosing the block of execution based on argument (?)partial inspection)?
15:31:23 <ggVGc> my personal experience is that learn you a haskell for great good didn't really get me going very well the first times I tried learning haskell
15:31:35 <yukkuri> just in theory
15:31:44 <ggVGc> after I had done some stuff, I started using it as kind of a reference
15:31:52 <ggVGc> but for first steps, it wasn't working for me
15:32:02 <ggVGc> I think I've heard others echo similar experiences
15:32:27 <ggVGc> I think what actually got me into really writing haskell as some playing around with Elm
15:32:39 <ggVGc> after having a go at haskell a few times previously
15:33:17 <yukkuri> i've came from #javascript channel, where some guy told me i should not use ternary in favour of Either monad, but i had hard time understanding if it is possible to implement actual Either monad without using ternary/if/then/else or pattern-matching for presence of Left value in current state
15:33:39 <ggVGc> yukkuri: a CPU is literally a thing that executes binary choices
15:33:41 <ggVGc> so, I would say no
15:33:48 <ggVGc> at the end of the day you have inputs and branching
15:34:08 <dyl> yukkuri seems a little silly to try to force monads into JS.
15:34:21 <dyl> I mean, you could do it, but without a strong static typechecker, you're not going to get much out of it.
15:34:26 <Arney> EvanR: thanks
15:34:27 <Arney> gn!
15:34:42 <yukkuri> yes, sure, it is not of a great benefit aside from the code golf
15:34:57 <EvanR> this just became a different question
15:35:03 <ggVGc> haha yes
15:35:14 <ggVGc> I feel I missed the ballpark by quiate a stretch
15:35:32 <EvanR> i interprted the first question as , can you program without using any decision making forms
15:35:50 <EvanR> ifthenelse, case analysis, or anything which makes a decision
15:35:52 <hpc> just use church booleans
15:35:57 <yukkuri> so, if javascript do not have means to distinguish null/undefined from a value by a pattern-matching and based on this choose a path of execution, you are forced to use control structes and anyways end up in ternary/if/then/else
15:36:05 <hpc> true = function(t,f,x) {t(x)}
15:36:13 <EvanR> good call
15:36:13 <hpc> false = function(t,f,x) {f(x)}
15:36:19 <EvanR> its hard to see how that is making any decision
15:37:09 <EvanR> ultimately, the behavior of a pure function is predetermined, and the only choice is up to the user to pick which input to use
15:38:11 <EvanR> function(t,f,x){ return t(x); }
15:38:32 <yukkuri> const true = (t,f,x) => t(x);
15:38:38 <yukkuri> const false = (t,f,x) => f(x);
15:38:56 <yukkuri> i think
15:39:05 <EvanR> what in gods name
15:39:15 <yukkuri> ES6 syntax for lambdas
15:39:27 <EvanR> at least its not -> (t,f,x) t(x)
15:39:33 <yukkuri> (x) => x     ===     \x -> x
15:40:02 <yukkuri> ow, parens in JS case alaso unnessesery
15:40:09 <yukkuri> just x => x
15:40:15 <EvanR> right, so you see that if-then-else is hardly fundamental
15:40:35 <yukkuri> but making choice based on something is
15:40:49 <EvanR> those combinators dont make any choices...
15:41:08 <EvanR> i think choice is an illusion
15:41:23 <ggVGc> EvanR: your parents taught you well
15:41:32 <EvanR> o_O
15:41:55 <ggVGc> if your kids belive choice doesn't exist, they'll be very well behaved
15:42:04 <ggVGc> I'll keep that in mind when I have my first child
15:42:16 <yukkuri> this is might be true, but in our narrow view of a tiny fraction of a universe this might be not so obvious
15:42:38 <yukkuri> illusion is overwhelming
15:42:38 <EvanR> seeing whats not obvious... tonight on #haskell
15:44:17 <yukkuri> this world is a gargantua-scale state-machine and we are parts of it, be that cogs, nuts, cofee stains or some friendly logo.
16:07:19 <gazanga> :t (.)
16:07:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:07:57 <gazanga> can you please explain why i can right this with also parentesis in (a -> c)?
16:08:07 <gazanga> right = write
16:09:56 <gazanga> i understand it like that: for example ((+2) . (*3)) 4, so a is 4. if i do parentesis in (a -> c) i dont have a variable 4 (in my example) but a function.
16:10:20 <gazanga> > ((+2) . (*3)) 4
16:10:22 <lambdabot>  14
16:11:40 <emilypi> :t ((+2) . (*3))
16:11:41 <lambdabot> Num c => c -> c
16:12:20 <emilypi> :t ((+2) . (*3)) 4
16:12:21 <lambdabot> Num c => c
16:13:39 <gazanga> (b -> c) -> (a -> b) -> a -> c -- how can this is exactly this: (b -> c) -> (a -> b) -> (a -> c)
16:14:10 <gazanga> it is all functions
16:14:15 <gazanga> where the variable is?
16:14:50 <Rembane> The parenthesis don't matter.
16:14:53 <Rembane> AFAIK. :)
16:14:59 <emilypi> gazanga: when you have just (b -> c) -> (a -> b) -> (a -> c), you define the composite arrow (f . g) = a -> a. The only difference between the (a -> c) signature and ... -> a -> c is that you're applying it to the a in a -> c, as opposed to returning a function. The parens don't really matter
16:15:25 <emilypi> er, (f . g) : (a -> c)
16:18:18 <gazanga> a step backword: fun :: a -> b -> c. why it is the same as fun :: a -> (b -> c)?
16:19:16 <gazanga> what do i need to read to understand this?
16:19:58 <geekosaur> because (->) associates rightward, like 2 ** 3 ** 5 is 2 ** (3 ** 5)
16:20:06 <geekosaur> as for why, it's so partial application works
16:21:05 <geekosaur> and currying, which is related but not identical
16:21:43 <iqubic> What is currying?
16:21:46 <gazanga> geekosaur: this i understand. so why i have a problem with this:(.) :: (b -> c) -> (a -> b) -> (a -> c)?
16:21:57 <geekosaur> given (f a b), if you say (f a), you want it to peel off *one* parameter and apply it, which means (a -> b -> c) has to be (a -> (b -> c)) so you can peel off the (a) and be left with (b -> c)
16:22:49 <geekosaur> I don't know what problem you have with that
16:23:03 <geekosaur> so I'm not sure how to answer that question
16:23:38 <gazanga> :-D yes the problem is that i don't know how to explain what i dont understand.
16:23:48 <geekosaur> so let's try this
16:23:53 <geekosaur> :t map
16:23:55 <lambdabot> (a -> b) -> [a] -> [b]
16:24:14 <geekosaur> this is also ((a -> b) -> ([a] -> [b])
16:24:16 <gazanga> map i understand very well (i think)
16:24:39 <geekosaur> which is why if you say (map f) for some appropriate f, you have a function ([a] -> [b])
16:25:17 <geekosaur> :t (.)
16:25:18 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:26:04 <geekosaur> so if you have (f . g), you have consumed (b -> c) (which is f) and (a -> b) (which is g), and you have something that expects (a) and produces (c) (that is, (a -> c))
16:26:23 <geekosaur> which is why the above is the same as (b -> c) -> (a -> b) -> (a -> c)
16:27:21 <gazanga> so (f . g) returning a function the take a and return c?
16:27:35 <geekosaur> yes
16:28:17 <geekosaur> (f . g) is the same as (\x -> f (g x)) which is "take some x, apply g to it, then apply f to the result of that to produce something else"
16:28:43 <geekosaur> so (f . g) :: (a -> c), if (f :: b -> c) and (g :: a -> b)
16:29:29 <gazanga> yes i think i understand everything you said in this session ;-)
16:29:55 <gazanga> thanks!
16:30:29 <gazanga> in what hours are you usually come here? you explain to me like i'm 5 (which is good!)
16:30:47 <gazanga> (it is a compliment :-))
16:33:44 <gazanga> OK so why the composition need parentesis in the first and second arguments? why it cant be like this: b -> c -> a -> b -> a -> c
16:34:01 <gazanga> so it will have 5 arguments
16:34:09 <gazanga> and return a value
16:36:10 <atchoum> hey yah
16:36:46 <atchoum> 4th place on freenode that's an achievement of its own.
16:37:32 <gazanga> wait fun :: a -> b -> c -- a and b are variables? and fun :: (a -> b) -> c its distinction that its a function?
16:37:35 <gazanga> from a to b
16:37:43 <atchoum> just behind 1st) #linux 2nd) #archlinux #3d) python and #4th) archlinux
16:37:49 <atchoum> oups meant haskell.
16:38:27 <atchoum> type theory is leading the world bro
16:38:50 <atchoum> gazanga: a and b are type
16:38:58 <atchoum> (a->b) is a function
16:39:30 <atchoum> or rather type of a function
16:40:05 <gazanga> atchoum: f :: a -> b -> c cant be the same as f :: (a -> b) -> c?
16:40:11 <atchoum> I wrote a shitty blog post about it : http://david-kremer.fr/haskell/blogging/2017/10/01/haskell-evaluation-made-simple.html
16:40:21 <atchoum> gazanga: it's not the same at all.
16:41:30 <atchoum> (a->b) is just a function
16:41:47 <atchoum> or rather `the type of a function`
16:43:29 <gazanga> yes i think i again understand what i was little confused about
16:43:34 <gazanga> thanks atchoum
16:44:06 <geekosaur> gazanga, because c isn;t a parameter, it's a result of something else. (b -> c -> a -> b -> a -> c) means you have to give it a (c), instead of it applying a (b -> c) function to a (b) to make a (c)
16:46:53 <gazanga> geekosaur: after reading it couple of times i think i understand :-)
16:47:34 <gazanga> but what about this? fun :: a -> b -> c -> d -> e
16:47:45 <gazanga> (e) is just at the end
16:48:03 <gazanga> not in the "middle" as in the composition
16:48:12 <atchoum> > typeof (**)
16:48:14 <lambdabot>  error:
16:48:14 <lambdabot>      • Variable not in scope:
16:48:15 <lambdabot>          typeof :: (Double -> Double -> Double) -> t
16:48:25 <atchoum> > :type (**)
16:48:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:48:29 <geekosaur> precisely because of that, the only implementation of that function is (undefined :: e)
16:48:31 <gazanga> (i dont know what `fun` is.
16:48:37 <gazanga> its just for example
16:48:52 <geekosaur> because it can't make an (e) any other way. (and "undefined" throws an exception because it doesn't know how to make one either)
16:50:01 <gazanga> :t undefined
16:50:02 <lambdabot> a
16:50:31 <geekosaur> it claims to make a value of any type you want. this is impossible; there are no normal values that are of every possible type
16:50:37 <geekosaur> so what it actually does is throw an exception
16:50:42 <geekosaur> > 3 + undefined
16:50:44 <lambdabot>  *Exception: Prelude.undefined
16:50:55 <geekosaur> > "abc" ++ undefined
16:50:57 <lambdabot>  "abc*Exception: Prelude.undefined
16:51:34 <gazanga> OK
16:52:22 <gazanga> i need to have a break to let it sink in. thank you very much geekosaur
16:52:40 <gazanga> have a good night from here :-)
16:54:59 <atchoum> >:t (**)
16:55:15 <atchoum> > :t (**)
16:55:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:55:19 <geekosaur> :t (**)
16:55:20 <lambdabot> Floating a => a -> a -> a
16:55:29 <geekosaur> no "> " on the :-commands here
16:55:36 <atchoum> (1) ** (2)
16:55:53 <atchoum> geekosaur:
16:56:07 <atchoum> CS is cool
16:56:32 <atchoum> can you imagine ppl writing Java code ?
16:56:43 <atchoum> That's cool but ho
16:56:45 <EvanR> i try not to
16:57:31 <EvanR> otoh haskell might suck too: http://www.stephendiehl.com/posts/production.html
16:58:03 <EvanR> no date on that post because its timeless
16:58:13 <atchoum> << The myths are sometimes trueisms. >>
16:59:30 <atchoum> << As we’ve all learned the hard way, the Prelude is not your friend. >>
17:00:34 * atchoum is mmh currently looking for other out of context tasty citations
17:00:54 <atchoum> << For many problem domains the libraries simply aren’t written yet. >>
17:01:01 <EvanR> "Haskell is useless" - SPJ
17:02:33 * atchoum is feeling that he should stop and go to bed instead
17:03:03 <bob> hi
17:06:00 <atchoum> << by my estimates in the United States there are probably only around 70-100 people working on Haskell fulltime and a good deal more working part-time or anticipating using it >>
17:06:05 <atchoum> mmh
17:06:27 <orion> For a language to express/represent the concept of a Monad, must it have higher-kinded types? tdammers replied earlier this morning: 'depends on your definition of "express"'
17:06:44 <boj_> that number seems pretty low
17:07:12 <EvanR> to represent a monad, you must first represent a type class
17:07:18 <EvanR> which many languages can do
17:07:24 <atchoum> orion: not knowing what is a higher kinded type, there is monad implementation available in about almost all languages I've heard of.
17:07:26 <EvanR> but theyll probably get it wrong
17:07:47 <atchoum> boj_ underestimated maybe but
17:08:16 <atchoum> if you think of it 100ppl working on _one_ language is huge if they can coordinate themselvese
17:08:29 <EvanR> indeed you have monad libraries in many langauges, some of which have nothing in the area of type systems to speak of
17:08:53 <Cale> If you have first class functions, you can sort of do something impractical, but to implement the abstraction in a way which is at all usable, you need the ability to abstract over a higher kinded type
17:08:56 <boj> atchoum: sorry, i misread that. you meant the compiler/language itself, not people working as professionals with it
17:09:15 <Cale> and if you want it to be *really* usable, you need something akin to type classes
17:09:43 <Cale> Because passing around dictionaries of the Monad operations is not going to be worth it probably most of the time
17:11:04 <EvanR> that being said, for a specific monad, you could cook up something that accomplishes the same thing, even without fancy features
17:11:17 <EvanR> since you dont have to do dynamic implementation stuff
17:11:21 <atchoum> boj: I suppose that's very intricated. Ppl working on core functionalities like compilers and all must have funding. Compiler is vital for a community to live on. So it maybe that we are on the low rate to have a vital community around haskell but still the community lives on. Proofs are many.
17:11:41 <atchoum> this channel is one.
17:12:40 <Cale> EvanR: yeah, though there's not a whole lot of point in even recognising the structure if you're not going to abstract over it
17:12:55 <atchoum> boj: yes 100 ppl working on the core language is not a lot but that's still, by some standards, a lot. There is many fields where not as much ppl are around but are still progressing.
17:12:58 <Cale> There's not a whole lot to Monad after all.
17:13:12 <EvanR> correct
17:13:37 <EvanR> but people may only be focusing on monads because of a specific use case, like Option
17:13:46 <EvanR> or parsing
17:14:14 <orion> I thought that languages like Java could represent individual instantiations of Monad (such as a List), but they are incapable of representing a Monad itself.
17:14:19 <atchoum> Monads in other languages maybe a strong advocacy for haskell. Don't you think ?
17:14:29 <EvanR> but Option and parsing dont sound sexy, so they inflate the task at hand by calling it monads ;)
17:15:02 <EvanR> i would settle for Applicative in other languages
17:17:38 <Tuplanolla> Don't neglect `Alternative`.
17:18:24 <Cale> orion: The problem in Java is definitely the higher kinded type issue.
17:33:53 <orion> Cale: Is my statement true?
17:36:10 <Cale> orion: Probably, I don't know modern Java very well. It was certainly true of the Java that I learned over a decade ago.
17:36:56 <Cale> If Java still doesn't have higher kinded type variables for its generics, it is absolutely true
17:37:36 <Cale> But being able to implement particular monads is nothing special or useful.
17:37:59 <Cale> Like, it's not worth recognising that these things are monads unless you can write code which would work with an arbitrary choice of monad
17:40:41 <orion> Sure
17:46:34 <JayKobe6k> Cale: in terms of polymorphism it might not be useful.. but if you have monads which you _know_ are monads, you can atleast apply equational reasoning
17:46:48 <JayKobe6k> You get the benefit of having some expectations about behavior
17:47:18 <JayKobe6k> Also, you get the knowledge of how it can interact with other structures
17:47:30 <JayKobe6k> getting to traverse and those types of things
17:50:22 <crestfallen> hi something I forget regarding unifying functions. on line 20 re:  foldl (flip (:)) :: Foldable g => [a] -> g a -> [a]       how do you read the ' g a '  part in that signature?  foldl (flip (:)) :: Foldable g => [a] -> g a -> [a]
17:50:35 <crestfallen> sorry paste here https://lpaste.net/2355873197754155008
17:51:04 <crestfallen> hi something I forget regarding unifying functions. on line 20 re:  foldl (flip (:)) :: Foldable g => [a] -> g a -> [a]       how do you read the ' g a '  part in that signature?  https://lpaste.net/2355873197754155008
17:51:18 <Cale> I'm not sure I understand the question
17:51:28 <Cale> That is a type function g applied to the argument a
17:52:42 <shachaf> crestfallen: The type in line 20 isn't what you get by applying a function with the type on line 19 to (flip (:))
17:53:07 <dibblego> orion: yes it is definitely true, see http://functionaljava.org/ for examples of the problem, as well as many (failed) attempts to overcome it.
17:53:40 <crestfallen> one moment please
17:55:24 <crestfallen> right shachaf so that is an intermediary step to illustrate the unification?
17:55:49 <shachaf> What unification?
17:55:57 <orion> dibblego: Thank you
17:57:55 <crestfallen> the unification of foldl with (flip (:))
17:58:10 <crestfallen> foldl (flip (:)) :: Foldable g => [a] -> g a -> [a]
17:58:22 <shachaf> What's the type of foldl that you're using?
17:58:35 <dibblego> crestfallen: when you read [g] you can also read it (and type it) as [] g
17:59:14 <crestfallen> dibblego: one sec pls
17:59:35 <crestfallen> > :t foldl
17:59:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:02:23 <crestfallen> shachaf: see on line 15 where its say the (flip (:)) is the correct pattern for foldl . I guess there are some errors in my notes there..
18:03:00 <Cale> :t foldl
18:03:01 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:03:06 <Cale> :t flip (:)
18:03:07 <lambdabot> [a] -> a -> [a]
18:03:26 <dyl> :t Data.List.foldl
18:03:27 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:03:31 <dyl> Oh. Right.
18:03:36 <Cale> So we must have b = [a] (and a in the type of foldl becomes a in the type of flip (:))
18:03:54 <Cale> So, the result of foldl (flip (:)) becomes
18:04:00 <Cale> [a] -> t a -> [a]
18:04:13 <Cale> and of course, we preserve the Foldable t constraint
18:05:54 <crestfallen> "that is a type function g applied to the argument a"   as you said, in this case that would be (:)  , right Cale ?
18:07:05 <crestfallen> ie. [a] -> t a -> [a]    g == t
18:12:33 <crestfallen> i.e. function g is (:) constrained to the Foldable type  ?
18:13:27 <crestfallen> :t (:)
18:13:28 <lambdabot> a -> [a] -> [a]
18:13:48 <crestfallen> :t (flip (:))
18:13:49 <lambdabot> [a] -> a -> [a]
18:14:04 <crestfallen> :t foldl
18:14:05 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:14:58 <crestfallen> (b -> a -> b) ~ [a] -> a -> [a]       < that is the jist of the unification
18:15:09 <crestfallen> I assume
18:15:42 <crestfallen> :t foldl (flip (:))
18:15:43 <lambdabot> Foldable t => [a] -> t a -> [a]
18:16:07 <crestfallen> anyone critique that please?
18:17:31 <EvanR> it got as far as b = [a]
18:17:56 <EvanR> then got 100% on the test
18:18:14 <crestfallen> pardon?
18:18:56 <EvanR> the difference between the type for foldl and foldl (flip (:)), besides losing 1 argument, is the substitution b ==> [a]
18:19:12 <EvanR> that is the unification
18:20:01 <crestfallen> right , thanks, that's what I meant by the gist of the unification, but my notes don't express that very well, if its indeed correct
18:20:43 <crestfallen> EvanR: is there a more formal way to go through the steps of unification as I attempted to do?
18:22:10 <crestfallen> if you were to write them down in notes?
18:22:11 <EvanR> to be formal i would backtrack and ask what a unification problem is and what form the solution is supposed to even look like
18:22:57 <EvanR> is a unification problem a pair of expressions, and the solution a set of substitutions to make the expressions equal?
18:24:11 <EvanR> (expressions here being type expressions)
18:25:00 <crestfallen> the problem is that foldl takes a function of the form (b -> a -> b), so the first argument must satisfy that form   ..   um..well yeah are we looking for an equality ?
18:25:49 <crestfallen> so (flip (:)) satisfies that form with [a] -> a -> [a]
18:26:03 <EvanR> i think you are doing a different kind of problem, you are trying to infer the type of foldl (flip (:))
18:26:24 <EvanR> unification is involved as a subtask, which youre totally glossing over
18:26:40 <crestfallen> kindly rephrase that
18:28:02 <EvanR> my terminal is 10 lines high right now so basically I'm reconstructing what youre asking... you are trying to infer a type?
18:28:06 <crestfallen> what I'm asking is if you know the type for (:) , flip and foldl, you should be able to write out the steps of unification using ~ notation etc
18:28:09 <EvanR> i got caught up in unification
18:28:47 <crestfallen> as I attempted in those notes.
18:28:52 <EvanR> the steps of type inference right, of foldl (flip (:)) ?
18:29:38 <crestfallen> ok I didn't realize it was called , say, handwriting the steps of type inference. those are different things?
18:30:00 <crestfallen> I was introduced to the idea as unification
18:31:25 <EvanR> i dont care about jargon much, i just wanted to make sure were talking about the same thing
18:31:53 <crestfallen> are we?
18:32:34 <crestfallen> I didn't catch your phrase of ...
18:32:37 <EvanR> type inference / type reconstruction works on 1 expression/program (with some environment of facts). unification operands on several expressions
18:32:48 <EvanR> operates*
18:32:59 <crestfallen> unification is involved as a subtask, which youre totally glossing over
18:33:28 <EvanR> unification has some role here somewhere. but you want to infer a type is the main goal
18:33:58 <crestfallen> ok yeah, I'd like to anticipate exactly what ghci is doing if you do :t foldl (flip (:))
18:34:16 <crestfallen> or at least write it ....
18:34:17 <EvanR> to infer the type of foldl (flip (:)) you can begin with the typing rule for applications
18:34:26 <crestfallen> as friendly to human readers
18:36:03 <EvanR> if foldl has type u1 -> u2 and (flip (:)) has type u1, then the whole thing must have type u2
18:36:30 <crestfallen> copy that
18:37:00 <EvanR> the type of foldl involves foralls, so to learn more about u1 -> u2 you need to instantiate the type vars, with more unknowns
18:37:12 <crestfallen> hmm
18:37:13 <iqubic> What are we talking about?
18:37:14 <EvanR> until you get a ->
18:38:36 <EvanR> once you do, then you can begin to record "equalities" between the unknowns and known types, and between each other
18:39:02 <crestfallen> that's where the notation ~ comes in?
18:39:11 <EvanR> to get all necessary facts though, youll have to recursively apply these rules until the expressions are just leaves
18:40:10 <crestfallen> I briefly heard about expressions/sub-expressions as nodes/leaves  , yes. however...
18:40:42 <crestfallen> could we look at lines 18-24 in the paste ?
18:40:47 <crestfallen> iqubic https://lpaste.net/2355873197754155008
18:40:55 <EvanR> like, (flip (:)) :: u1, but thats also an application (of a polymorphic function) so you need to apply the rule again
18:41:35 <crestfallen> on line 24 ..
18:42:16 <crestfallen> ([t] -> t -> [t]) is an equality with (flip (:))  correct EvanR  ?
18:43:23 <crestfallen> is *in equality
18:43:39 <EvanR> i think this is a bit muddy
18:43:45 <crestfallen> ok thanks
18:43:49 <EvanR> first, on line 19 you should put explicit forall
18:44:19 <crestfallen> frankly I haven't used forall atall
18:44:29 <EvanR> line 20 should be rewritten to not use Foldable, because you didnt on line 19
18:44:42 <EvanR> concentrate on only 1 version of foldl
18:44:46 <crestfallen> ok
18:45:19 <EvanR> on line 24, if youre in the middle of the process, i see t as being a specific unknown type, so no forall t
18:46:13 <EvanR> at the end of the process if you still have knowns, you can put foralls back. which is called generalization
18:46:20 <EvanR> if you still have UNknowns
18:46:37 <crestfallen> sorry I don't get the use of forall
18:47:31 <EvanR> it distinguishes type variables that stand for concrete but unknown types from placeholders that can be any type you want
18:47:32 <crestfallen> on 24 I think ghci was using t but an irc member changed it to g for illustration? not sure
18:47:49 <crestfallen> ok copy that
18:48:35 <crestfallen> so t is commonly used by ghci as a distinct but unknown type var ?
18:48:48 <crestfallen> *concrete
18:49:03 <EvanR> nope ghci is showing you the generalization, and omitting the forall
18:49:13 <EvanR> for convenience / confusion
18:49:19 <crestfallen> :)
18:49:36 <EvanR> try :set -fprint-explicit-foralls
18:49:50 <crestfallen> whats that?
18:50:00 <EvanR> it will show the foralls instead of hiding
18:50:06 <crestfallen> a ghci command?
18:50:08 <EvanR> in ghci
18:50:29 <crestfallen> but in any case ...
18:50:36 <EvanR> specific-but-unknown-types show up in the middle of your inference work
18:51:14 <crestfallen> ....   -> g a -> [a] is read "a function of type g applied to an argument of type a "
18:51:17 <EvanR> you could call them existential variables, as opposed to universal
18:51:32 <crestfallen> yikes
18:51:50 <crestfallen> is the above post correct?
18:52:11 <EvanR> i dont think your question was correct
18:52:21 <EvanR> which was "how to read g a in ..."
18:53:03 <EvanR> g is a type function, not a regular function
18:53:36 <crestfallen> right so that means (:) is valid within the constraint
18:53:40 <EvanR> no
18:54:01 <EvanR> this is possible:  g = []
18:54:32 <crestfallen> dont follow that
18:54:41 <EvanR> also possible: g = Maybe
18:54:44 <EvanR> but not (:)
18:59:55 <iqubic> "g a" is a type function that takes only one argument. (:) is a type fuction that takes two argument. Therefore the g of g a can't be (:).
19:00:13 <monochrom> (:) is not a type function.
19:00:55 <EvanR> "g a" cant be a type function
19:01:10 <iqubic> Oh. What is the definition of a type function?
19:01:14 <EvanR> since it appears on the left of a ->
19:01:20 <EvanR> :k (->)
19:01:22 <lambdabot> TYPE q -> TYPE r -> *
19:01:27 <EvanR> foiled again
19:01:46 <EvanR> iqubic: * -> *
19:01:57 <iqubic> Oh, I see.
19:02:07 <iqubic> So, Either is a type function?
19:02:14 <EvanR> yeah
19:02:15 <crestfallen> is that related to category theory ?
19:02:37 <EvanR> no its ad hoc haskellese
19:03:01 <crestfallen> ok sorry I don't follow you kind people
19:03:24 <crestfallen> I haven't looked at kind yet :k   et al
19:04:03 <mniip> :k Int#
19:04:04 <lambdabot> error:
19:04:04 <lambdabot>     Not in scope: type constructor or class ‘Int#’
19:04:04 <lambdabot>     Perhaps you meant one of these:
19:04:10 <mniip> :k GHC.Prim.Int#
19:04:12 <lambdabot> TYPE 'GHC.Types.IntRep
19:04:59 <haskell_noob> how do i fix this compilation error: https://lpaste.net/1594177584080355328
19:05:31 <EvanR> the actual error seems to be cut off
19:05:31 <crestfallen> flip (:) is    ([t] -> t -> [t])
19:05:39 <crestfallen> that much I can see
19:05:44 <haskell_noob> https://lpaste.net/5079468120863670272
19:05:55 <EvanR> o_O
19:06:08 <crestfallen> foldl requires a function with that form  , correct so far?
19:06:55 <EvanR> :t fold (:)
19:06:56 <lambdabot> Foldable ((->) a) => [a] -> [a]
19:07:05 <EvanR> :t flip (:)
19:07:06 <lambdabot> [a] -> a -> [a]
19:07:12 <EvanR> yep that is correct
19:07:42 <EvanR> foldl :: (b -> a -> b) -> b -> [a] -> b, correct
19:08:36 <EvanR> (if you had foralls, you would not be led to think they are the same a in the two statements)
19:10:14 <crestfallen> sorry I don't know how to use foralls at this time
19:10:30 <EvanR> foldl :: forall a b . (b -> a -> b) -> b -> [a] -> b
19:10:45 <EvanR> flip (:) :: forall a . [a] -> a -> [a]
19:10:59 <fragamus> Is there an industrial strength Simplex solver for haskell
19:13:19 <crestfallen> thanks for your help EvanR I'm lost right now
19:13:37 <EvanR> I know
19:14:05 <EvanR> step 1, understand the question
19:14:07 <EvanR> ???
19:14:09 <EvanR> profit
19:15:59 <crestfallen> I've been trying to pose questions that would help me learn how to put the process into steps that would profit , say , teaching a young person
19:16:51 <crestfallen> I don't understand the use of the (.) notation in the above examples of forall
19:17:37 <EvanR> do you get lambda notation...   \x -> x + 1
19:17:48 <crestfallen> yeah
19:18:06 <EvanR> here x is not a global variable or implicitly defined variable, its introduced in view and has a limited scope
19:18:30 <crestfallen> right it could be xx
19:18:51 <EvanR> forall a . Maybe a is the same thing
19:19:03 <EvanR> instead of \ its forall, instead of -> its .
19:19:23 <crestfallen> ok thanks
19:19:33 * hackage freq 0.1.0.0 - Are you ready to get freaky?  http://hackage.haskell.org/package/freq-0.1.0.0 (chessai)
19:20:09 <haskell_noob> how do i understand this line : newtype InitRequest req contentType res accept = InitRequest   { unInitRequest :: NH.Request   } deriving (Show) ?
19:20:18 <haskell_noob> which ghci extension is this?
19:20:37 <crestfallen> so a and b are only in the scope of the foldl signature
19:20:43 <EvanR> right
19:21:48 <crestfallen> so on line 24 the t and [t] are used to distinguish a new and unique type that is the result of unification
19:22:03 <crestfallen> using ~ notation
19:22:42 <EvanR> t stands for some type
19:23:25 <EvanR> according to your line, t = a
19:23:36 <crestfallen> yes
19:23:44 <EvanR> but without context, we dont know what a means
19:23:54 <EvanR> perhaps its some other type
19:24:53 <crestfallen> its the result of the previous lines beginning with (:) :: a -> [a] -> [a]
19:25:19 <EvanR> i must have missed that line, or am looking at the wrong paste
19:25:32 <crestfallen> (corruption of line 12,13)
19:25:37 <EvanR> oh
19:26:04 <EvanR> (:) :: forall a. a -> [a] -> [a]
19:27:05 <crestfallen> ok I need to work on that. I was trying to find a clear way to visualize the process. can you see what I'm attempting to do?
19:27:15 <EvanR> not exactly
19:27:37 <crestfallen> sorry really need to go. really appreciate your time EvanR
19:27:55 <EvanR> i have been missing the original "problem" to solve. we have "steps" but not of what
19:28:27 <EvanR> later
19:29:08 <crestfallen> If you had to teach someone what was happening when ghci unifies the types of two functions, in this case foldl (flip (:)), how would you illustrate it step by step, if forall was not yet understood.
19:29:43 <crestfallen> EvanR:
19:29:48 <crestfallen> ^
19:30:27 <EvanR> see thats not what i understand ghci to be doing
19:30:47 <EvanR> its infering the type of 1 expression, foldl (flip (:))
19:31:09 <EvanR> which happens to involve 2 functions
19:31:21 <EvanR> and this one does not
19:31:26 <EvanR> :t [1,2,3]
19:31:28 <lambdabot> Num a => [a]
19:32:10 <EvanR> :t sum [1,2,3]
19:32:11 <lambdabot> Num a => a
19:32:56 <EvanR> inferring 1 type rather than unifying 2 types
19:33:10 <mniip> hol' my beer
19:33:18 <mniip> % set :ddump-tc-trace
19:33:20 <yahb> mniip: ; <interactive>:35:6: error: Variable not in scope: ddump :: String -> a0 -> a0; <interactive>:35:6: error:; * Couldn't match expected type `[ASetter s t a b -> b -> s -> t]' with actual type `String -> a0 -> a0'; * Probable cause: `(-)' is applied to too few arguments; In the second argument of `(:)', namely `ddump - tc - trace'; In the expression: set : ddump - tc - trace; In
19:33:31 <mniip> % :set -ddump-tc-trace
19:33:31 <yahb> mniip:
19:33:40 <mniip> %% :t foldl (flip (:))
19:33:41 <yahb> mniip: http://qp.mniip.com/y/58
19:34:36 <EvanR> mniip is like #haskell Iron Man or inspector gadget
19:35:59 <mniip> 1527128926 [05:28:46] <crestfallen> If you had to teach someone what was happening when ghci unifies the types of two functions, in this case foldl (flip (:)), how would you illustrate it step by step, if forall was not yet understood.
19:36:04 <mniip> instantiate/generalize
19:36:56 <mniip> whenever an instance of an identifier is introduced into the typechecking scope, all its type variables are instantiated to fresh new unused variables
19:38:02 <mniip> whenever a typechecked expression is bound to a toplevel identifier (or where-bound), its type is generalized (over the type variables appearing in it)
19:39:04 <crestfallen> mniip: I don't know if you're demeaning me or not
19:39:09 <mniip> what
19:39:12 <EvanR> lol
19:39:22 <mniip> the first one was obviously a joke
19:39:37 <mniip> the instantiation/generalization is a honest idea
19:40:28 <mniip> though, that only works when identifiers form a DAG.
19:40:51 <mniip> if there's recursion or mutual recursion you might need to get down to business with actual constraint generation/solving/tidying
19:42:42 <crestfallen> can't follow .. many thanks. more drama later crucify_me
19:43:33 * hackage freq 0.1.0.1 - Are you ready to get freaky?  http://hackage.haskell.org/package/freq-0.1.0.1 (chessai)
19:45:03 * hackage semirings 0.1.3.0 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.1.3.0 (chessai)
19:54:17 <haskell_noob> i have a Network.Http.Types.URI instance. How do get the raw query such as http://<a>/?b=c  ?
20:00:03 <pavonia> haskell_noob: What type is that?
20:00:33 * hackage haskell-igraph 0.7.0 - Haskell interface of the igraph library.  http://hackage.haskell.org/package/haskell-igraph-0.7.0 (kaizhang)
20:04:32 <haskell_noob> pavonia : this is a phantom type. i just found out.
20:04:57 <haskell_noob> so this can help type the expression on the right hand side but has no impact on the newtype per se.
20:05:16 <haskell_noob> let me paste a link to the code that I am using to connect to k8s pod.
20:05:33 * hackage serverless-haskell 0.5.0 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.5.0 (AlexeyKotlyarov)
20:05:42 <haskell_noob> pavonia : here it is : https://github.com/kubernetes-client/haskell
20:06:02 <haskell_noob> <pavoni> ^^
20:06:09 <haskell_noob> <pavonia> ^^
20:06:57 <pavonia> That's a whole project
20:08:03 <haskell_noob> <pavonia> let me paste the relevant type.
20:08:47 <haskell_noob> ``` newtype InitRequest req contentType res accept = InitRequest   { unInitRequest :: NH.Request   } deriving (Show) ```
20:13:52 <pavonia> haskell_noob: How is that related to your question?
20:15:08 <haskell_noob> <pavonia> sorry, i had 2 questions. The first question was how to read the above type. because my code was not compiling due to the missing type for accept.
20:15:30 <haskell_noob> <pavonia> the second question i have is that i have a URI instance, i need the complete string for request.
20:16:31 <pavonia> You didn't say what URI class or type you're referring to
20:20:15 <haskell_noob> <pavonia> : newtype InitRequest req contentType res accept   = InitRequest {unInitRequest :: http-client-0.5.7.1:Network.HTTP.Client.Types.Request} here is the type.
20:21:40 <enterprisey> haskell_noob: so  you have a value of type InitRequest?
20:21:55 <enterprisey> also the angle brackets are unnecessary for pinging someone
20:23:45 <haskell_noob> <enterprisey> yeah
20:23:56 <haskell_noob> i have that urlRequest..let me paste the link.
20:24:44 <haskell_noob> <enterprisey> https://lpaste.net/5408100528519380992
20:25:23 <enterprisey> so you wish to go from the urlRequest to something like http://a/?b=c
20:25:25 <enterprisey> right?
20:25:29 <haskell_noob> yes.
20:26:20 <enterprisey> I can't actually find anything of type Network.HTTP.Client.Types.Request
20:26:29 <enterprisey> you didn't write this type yourself right
20:28:14 <pavonia> Network.HTTP.Client has getUri :: Request -> URI
20:28:17 <haskell_noob> <enterprisey> https://hackage.haskell.org/package/http-client-0.1.0.0/docs/Network-HTTP-Client-Types.html#t:Request
20:28:44 <haskell_noob> <pavonia> <enterprisey> i need the raw string from the URI ? how do i get that?
20:28:53 <enterprisey> angle brackets are not needed to ping some btw
20:28:55 <enterprisey> *someone
20:29:04 <pavonia> Use show on the uri value
20:29:27 <haskell_noob> hmmm?
20:29:37 <enterprisey> so the whole thing would be Prelude.putStrLn . show . getUri $ urlRequest
20:29:59 <haskell_noob> thanks @enterprisey?
20:30:17 <enterprisey> although pavonia found the function ty
20:30:20 <haskell_noob> let me try that. also (how do i ping a user? i thought @ would do it but wasnt sure).
20:30:33 <enterprisey> you just say their username
20:30:39 <enterprisey> surrounded by symbols
20:30:49 <enterprisey> for example asdfenterprisey wouldn't ping me, but !@#$%enterprisey$%^& would
20:31:05 <enterprisey> just enterprisey is the usual method
20:31:13 <enterprisey> although if you're saying something to someone, it's usually like
20:31:15 <enterprisey> enterprisey: asdf
20:32:02 <haskell_noob> thank you..so i guess my name sticks. Let me try this and see if i can address my core issue. I am not able to open a websocket to the k8s exec call.
20:35:18 <haskell_noob> enterprisey pavonia its missing the query string..let me see how i can get the entire string with auth header and query strings in one string.
20:35:45 <haskell_noob> https://192.168.99.100:8443/api/v1/namespaces/default/pods/busybox-test/exec enterprisey pavonia
20:36:01 <enterprisey> you also don't have to ping someone if odds are they're looking at the channel
20:36:12 <haskell_noob> :)
20:36:43 <enterprisey> on the other hand, the person whose name starts with pavoni (to avoid the ping) probably isn't looking here anymore, but also probably isn't in the conversation anymore
20:36:43 <enterprisey> anyway
20:37:03 <haskell_noob> silly me. i find the ping useful, because i am not looking at the window actively or trying to get my code to compile.
20:37:15 <enterprisey> just so you know I have zero experience with the http-client library
20:37:17 <enterprisey> ah that's fine
20:37:31 <enterprisey> I see you're using the webchat gateway
20:37:52 <enterprisey> usually you can configure IRC clients to send a ping whenever any message is sent in a given channel, regardless of whether it's pinging you
20:38:09 <haskell_noob> yeah. so the interface is probably clunky for me and the notification is the only way for me know something happened.
20:38:23 <haskell_noob> or so i think..till i find a better way.
20:38:50 <enterprisey> test
20:39:42 <enterprisey> it does not appear that webchat is able to ping you on any activity
20:39:44 <enterprisey> enterprisey_test:
20:40:28 <boj> so, haskell. fun times
20:40:30 <enterprisey> so if you're going to be using a lot of IRC (which I recommend, as this channel is an incredible resource when people who know things are online), a desktop client is recommended
20:40:50 <enterprisey> I use hexchat myself; others use quassel
20:40:56 <enterprisey> anyway back to actual haskell
20:40:58 <haskell_noob> let me get hexchat.
20:44:55 <haskell_noob2> enterprisey: on hexchat now. So what is the one method that gives me the complete URL : path/?query and headers.
20:49:41 <qqwy> Hey all!
20:49:58 <qqwy> Question: What is the difference between a 'weak' monad and a 'strong' monad?
20:50:25 <qqwy> I am currently reading the paper 'The Essence of Dataflow Programming' which states that all monads in Haskell are strong
20:53:35 <enterprisey> qqwy: this is something from category theory I think
20:54:03 <qqwy> I think so too
20:55:13 <enterprisey> https://mathoverflow.net/questions/85391/any-example-of-a-non-strong-monad
20:55:24 <enterprisey> in particular, the lambda-calculus answer looks promising
20:55:43 <enterprisey> to totally butcher the answer, if the monads weren't strong, do notation wouldn't be possible
20:59:58 <enterprisey> ah, I think I got it
21:02:24 <qqwy> thanks :D
21:03:55 <enterprisey> qqwy: ok
21:04:05 <enterprisey> so the wikipedia article says https://en.wikipedia.org/wiki/Strong_monad
21:04:37 <enterprisey> so, for every monad, if you have a tuple (a, m b), you should be able to convert it to m (a, b)
21:04:48 <enterprisey> ^ warning may be incorrect
21:05:51 <EvanR> fmap (fst that,) (snd that) ?
21:09:08 <nshepperd> :t sequence :: Monad m => (a, m b) -> m (a, b)
21:09:09 <lambdabot> Monad m => (a, m b) -> m (a, b)
21:10:33 <enterprisey> uh I think we're going to have to wait until someone who knows more category theory than me comes along
21:11:25 <enterprisey> because the answer I linked talks about the idea of evaluating expressions inside a monad, but also somehow you can combine an context and an expression using the tensor product
21:11:33 <nshepperd> so it's basically saying that sequence exists for (a,) and obeys the traversable laws
21:12:01 <nshepperd> i wonder if there's a corresponding category theory thing for 'sequence @ Either a'
21:12:33 * hackage bits-extra 0.0.1.2 -   http://hackage.haskell.org/package/bits-extra-0.0.1.2 (haskellworks)
21:13:19 <enterprisey> wild guess that it's probably something to do with symmetric monoidal monads
21:26:00 <edmundnoble> Also a strong monad, just a different monoidal operation
21:26:45 <edmundnoble> And sequence is an odd way to put it I think, it's just `\b ma -> (,) b <$> ma`
21:26:51 <edmundnoble> You just need `fmap`, not even `Applicative`
21:27:28 <edmundnoble> Oh actually no, sequence with Either has nothing to do with strong monads.
21:27:37 <dminuoso> Hi. I have some `data Config = Config { addr :: IP, ... }`, where it's very likely that a consumer uses the ToString instance, which might produce an error if the format is not correct. Right now my problem is that deeper inside my server it suddenly crashes when I access that field.
21:27:42 <dminuoso> And a random "Prelude.read: no parse" exception inside the server is rather nasty
21:28:11 <dminuoso> How can I reasonably deal with this? The constructor is not under my control.
21:28:31 <edmundnoble> So, `IP` has a constructor which can fail at runtime, which users frequently use?
21:29:01 <dminuoso> edmundnoble: Yes. Im writing a small server library framework. Someone who uses my framework has to supply some `IP` here and there.
21:29:19 <edmundnoble> And the IP constructor isn't under your control, to be clear.
21:29:24 <dminuoso> Correct.
21:29:37 <edmundnoble> And `Config`?
21:29:53 <edmundnoble> Is that under your control?
21:30:07 <dminuoso> Yes it is, mmm.
21:30:15 <dminuoso> So I guess I could provide a smart constructor for Config..
21:30:37 <edmundnoble> What would it do?
21:32:00 <edmundnoble> What I would do is `data Config = Config { addr :: !IP, ... }`
21:32:14 <edmundnoble> That way the `addr` will be fully evaluated by the caller of the constructor
21:32:33 <edmundnoble> Though it seems a bit hacky, and it's a shame `IP` has that constructor, it makes sense to me.
21:32:44 <edmundnoble> Moves the failure out of random parts of your code.
21:33:25 <dminuoso> edmundnoble: That's just a bug report waiting to happen heh.
21:33:45 <edmundnoble> Yes, and waiting to be answered by "don't use unsafe functions" ;)
21:34:24 <edmundnoble> This way the failure mode is basically the same as a strict language.
21:35:20 <dminuoso> edmundnoble: Well the crash will still happen inside my server, unless I choose to have my external `runServer` be strict in the Config argument.
21:35:25 <dminuoso> Which might actually not be so bad..
21:36:15 <edmundnoble> I agree, that actually sounds fine to me
21:39:41 <dminuoso> edmundnoble: Just a theoretical question.. what if I had some `Config { addrs :: [IP] }` instead? I mean I can force the evaluation of the entire list first but I dont know whether that'd be good style
21:40:08 <edmundnoble> Well, consider what `Config { addr :: !IP }` is short for.
21:40:24 <edmundnoble> Really, it's just `seq addr (Config addr)`, right?
21:40:55 <edmundnoble> So if you fully evaluate the `[IP]` in `runServer`, *or* in a smart constructor for `Config`, you're golden :)
21:44:02 <edmundnoble> Using, for example, `nf`, `rnf`, or even a fancy `foldr'` call.
21:48:29 <edmundnoble> Maybe just `nf` the entire `Config` in `runServer`.
21:55:53 <dminuoso> edmundnoble: Something along those lines? https://gist.github.com/dminuoso/aaf5f3a57c2f5a0add26797a9c36f443
21:56:25 <edmundnoble> What that will do is ensure the `Config` value is not an error or undefined
21:56:31 <edmundnoble> None of the fields
21:56:43 <edmundnoble> Oh sorry
21:56:44 <edmundnoble> I misread
21:56:59 <edmundnoble> I don't think that will work, because GHC can recognize the whole thing returns `()` and short-circuit
21:57:13 <edmundnoble> `nf :: Config -> Config` is the sig you want
21:57:53 <edmundnoble> Hmmmm.
21:57:57 <edmundnoble> No, I'm wrong.
21:58:05 <dminuoso> edmundnoble: How could it short-circuit? It would have to ignore all the seq in place
21:58:19 <dminuoso> Ah nevermind
21:58:41 <edmundnoble> So I think you're close
21:58:51 <edmundnoble> No, I think you're fine actually
21:59:05 <edmundnoble> https://www.irccloud.com/pastebin/7ropeJY2/
21:59:14 <edmundnoble> Where `rnf :: NFData a => a -> ()`
21:59:21 <edmundnoble> Which is basically what you have there, but generic
21:59:27 <edmundnoble> So that should be fine :)
21:59:28 <dminuoso> edmundnoble: Ah the only mistake left is that I should probably use pseq rather than seq
22:00:17 <edmundnoble> I agree, that sounds right
22:00:34 <edmundnoble> Don't want the server starting, *then* a failure
22:03:43 <dminuoso> edmundnoble: Alright. This looks great, thanks a lot for your help and input. :)
22:04:09 <edmundnoble> You're welcome, thanks for the question, I learned from it :)
22:05:31 <cocreature> seq vs pseq is kind of weird. it seems like we use seq pretty much everywhere even though pseq might be more appropriate
22:05:58 <cocreature> e.g. foldl' wouldn’t work like we want it to if seq didn’t behave like pseq in that case
22:06:50 <edmundnoble> Good point, I'm not sure why it doesn't break as-is.
22:07:48 <cocreature> I wonder if there is actually a case where GHC treats them differently or if the difference is just something that could exist in a hypothetical Haskell implementation
22:09:05 <dminuoso> This just gave me a real good taste of how annoying unsafe functions can be in a lazy language..
22:09:39 <cocreature> dminuoso: btw you could also consider using merijn’s validated-literals package to catch all of this at compile time
22:10:17 <edmundnoble> https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-November/011482.html
22:10:39 <edmundnoble> Apparently there is a real difference, specifically in allowed optimizations
22:11:06 <edmundnoble> At least there, anyway
22:11:21 <cocreature> that still doesn’t explain why it works for foldl'
22:11:37 <cocreature> which simon explicitely acknowledges here https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-November/011480.html
22:28:42 <dminuoso> cocreature: base does not appear to be using seq at all
22:28:48 <dminuoso> for foldl' that is
22:29:19 <Cale> dminuoso: are you sure it's not using it indirectly?
22:30:49 <dminuoso> Cale: f $! x = let !vx = x in f vx
22:31:17 <dminuoso> Or wait.. ah..
22:31:24 <dminuoso> bang patterns desugar into seq, dont they?
22:33:24 <iqubic> yes.
22:34:01 <kuribas> are there existing cms frontends you can plug-in to make a haskell website?
22:34:16 <kuribas> like wordpress for php
22:34:27 <kuribas> or at least something language agnostic
22:34:27 <EvanR> i see foldl' here using seq, in so many words http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.List.html
22:37:43 <dminuoso> EvanR: Oh.. I didn't realize it was specialied for []. I just stared at Data.Foldable
22:38:29 <kuribas> specialized to allow fusion?
22:39:31 <quicksilver> depends what you mean by 'CMS'
22:39:33 <EvanR> i guess Foldable does not do the magic seq stuff for you
22:39:45 <Cale> kuribas: I'm not sure it's quite what you're looking for, but Obsidian just released https://github.com/obsidiansystems/obelisk
22:39:50 <quicksilver> for largely non-interactive websites, hakyll is the only active projet I know of
22:40:01 <Cale> It's not a CMS, just a platform for building web applications in general
22:40:03 <quicksilver> for web applications there are many - yesod, servant, etc
22:40:06 <Cale> (and mobile)
22:40:20 <kuribas> Cale: no, I mean, creating a webapplication with some content management build in.
22:40:24 <dminuoso> EvanR: Well it does implicitly through $! which uses bang patterns
22:40:35 <kuribas> Cale: Like editing and adding pages, menus, widget areas.
22:40:59 <Cale> Yeah, we don't yet have a reflex-cms
22:41:04 <Cale> as far as I'm aware
22:41:10 <kuribas> would there be interest in it?
22:41:18 <Cale> I think there would :)
22:41:52 <kuribas> what would the minimal features be?
22:41:57 <kuribas> blogging as well?
22:42:07 <Cale> Well, I dunno :)
22:42:20 <Cale> You probably know better than I do what you'd want to see
22:43:14 <kuribas> maybe port the wordpress interface?
22:43:53 <kuribas> perhaps modular, rather than monolythic
22:44:05 <kuribas> interfacing with a REST api.
22:44:17 <robstr> morning, I'm looking for a way to take a `ByteString -> [[Word]]` like, emit every 5 elements, then the next 5 ... Is there already something like this ?
22:44:50 <cocreature> robstr: Word or Word8?
22:44:58 <robstr> cocreature: Word8
22:45:21 <cocreature> robstr: something like chunksOf 5 . ByteString.unpack
22:45:31 <robstr> `chuksOf` thx
22:46:14 <cocreature> chunksOf is not in base but it’s in "extra" and "split" which are both fairly small packages without a heavy dep footprint
22:48:12 <mxf> oh, that's a nice function, good to know I don't have to reinvent in next time.
22:49:25 <mxf> although I guess it could be generalised to monoid, no?
22:50:02 <cocreature> mxf: not sure what you mean by that. what would the type of the generalized version be?
22:50:11 <robstr> cocreature: works, thank you
22:53:07 <mxf> cocreature, hm, just woke up… Guess I should have a coffee first. Let me try to write it :)
22:54:28 <cocreature> mxf: you could make something like chunksOf :: Monoid a => Int -> [a] -> [a] but that’s not quite a generalized version of the existing chunksOf. you would need to turn each element into a singleton list to get back the old version
22:55:06 <iqubic> cocreature: What does the Monoid constraint do for you?
22:55:27 <cocreature> iqubic: it lets you smash together the individual chunks
22:55:36 <iqubic> I thought it was chuncksOf :: Int -> [a] -> [[a]]
22:56:08 <cocreature> sure that’s the current type signature but mxf was proposing to generalize it to Monoid
22:56:21 <glguy> :t \i -> map mconcat . chunksOf i
22:56:23 <lambdabot> Monoid b => Int -> [b] -> [b]
22:56:35 <iqubic> Yeah, I was going to suggest that.
22:58:14 <cocreature> sure you can certainly achieve that using the current version of chunksOf. I was just curious if mxf was thinking of some interesting generalization that I was missing
23:11:15 <kuribas> Cale: does reflex mix well with javascript?  Or are you supposed to write everything in it?
23:11:49 <kuribas> not that I am sure javascript mixes with javascript, as there are dozens of different frameworks.
23:14:14 <starlord123> > digits n = map (\x -> read x :: Integer) $ groupBy (\_ _ -> False)  $ show n
23:14:16 <lambdabot>  <hint>:1:10: error:
23:14:16 <lambdabot>      parse error on input ‘=’
23:14:16 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
23:14:31 <starlord123> > let digits n = map (\x -> read x :: Integer) $ groupBy (\_ _ -> False)  $ show n
23:14:32 <lambdabot>  <no location info>: error:
23:14:33 <lambdabot>      not an expression: ‘let digits n = map (\x -> read x :: Integer) $ group...
23:14:55 <starlord123> Is there a better way of getting the digits?
23:15:04 <starlord123> given a number
23:15:26 <cocreature> starlord123: does “use the digits package” count? :)
23:16:08 <starlord123> this is part of learning haskell
23:16:24 <starlord123> coding challenge :-)
23:16:27 <cocreature> groupBy (\_ _ -> False) is pretty weird. I would use something like "map (\x -> [x])" or "map pure" instead
23:17:12 <Cale> kuribas: yeah, you can FFI to javascript fairly easily
23:17:13 <cocreature> and I would use some arithmetic operations instead of show + read. might not make things shorter but probably faster
23:17:31 <Cale> kuribas: There's a library called ghcjs-dom with Haskell bindings to the entire DOM api
23:17:54 <kuribas> Cale: is it easy to do things like drag/drop?
23:18:17 <starlord123> cocreature, yeah I was thinking of successively (`mod` 10) and collecting it in a list
23:18:22 <Cale> Well, the DOM doesn't exactly make that trivial to begin with, but it's at least as easy as it is in Javascript?
23:18:45 <Cale> There's an example somewhere...
23:18:51 <starlord123> cocreature, the biggest hurdle for me is to get awy from for loop
23:19:03 <kuribas> Cale: I was hoping the nice abstractions make it easier :)
23:19:23 <Cale> https://github.com/reflex-frp/reflex-examples/blob/master/drag-and-drop/DragAndDrop.hs -- maybe you can abstract something out of this :)
23:19:29 <mxf> cocreature, you were missing nothing. I wasn't properly awake yet and was trying to figure out why it was specialised to lists.
23:19:51 <cocreature> starlord123: translating a for loop into a recursive function is a mechanical process so if you know how to express it as a for-loop you can start with that and then try to clean it up
23:19:54 <kuribas> Cale: right, thanks
23:20:08 <mxf> turns out, after fetching a coffee: lists aren't just monoids. There's also an "uncons", which monoids don't hav
23:20:11 <mxf> hev
23:20:13 <mxf> have
23:20:25 <cocreature> mxf: heh :)
23:21:30 <Cale> mxf: Lists aren't monoids at all -- the type of lists of values of some type is *a* monoid.
23:22:09 <Cale> But any example of a monoid you can find will have more which is true of it than that it is just a monoid.
23:22:40 <Cale> It would be strange if there were some ineffable monoid which had no properties apart from being a monoid.
23:22:49 <mxf> Cale, ah! Thanks for clarifying that for me
23:23:11 <kuribas> Cale: () ?
23:23:19 <kuribas> > () <> ()
23:23:21 <lambdabot>  ()
23:23:32 <cocreature> kuribas: that has the property that there is just a singlne element which is more than “it’s a monoid” tells you
23:24:00 <kuribas> cocreature: it's the simplest monoid?
23:24:24 <mxf> So, is there such a thing like a comonoid, with something like: `w a -> (a, w a)`? (as in a generic uncons)
23:24:27 <cocreature> sure, but that doesn’t change the fact that it has more properties than just being a monoid
23:24:58 <kuribas> cocreature: yeah, being the simplest monoid already means it's more than just a monoid.
23:25:39 <iqubic> mxf: Why do you want a comonoid? What uses would it have?
23:26:20 <kuribas> wouldn't the dual of a monoid still be a monoid?
23:26:34 <mxf> iqubic, I was just wondering how to write a generic chunksOf, if this would be possible and whether it makes sense
23:26:41 <kuribas> but in the reverse order
23:27:14 <kuribas> it seems Dual does that
23:27:17 <mxf> I have no idea about the ct-lingo, sorry if that was more confusing than helpful
23:27:51 <iqubic> How does someone figure out what the dual of some data/typeclass is?
23:27:56 <kuribas> > Dual "hello" <> Dual "World, "
23:27:58 <lambdabot>  Dual {getDual = "World, hello"}
23:28:24 <iqubic> What does dual do?
23:28:42 <iqubic> Dual*
23:29:08 <cocreature> iqubic: have you looked at the docs?
23:29:24 <Ariakenom> a -> (a -> a) => (a -> a) -> a => a ?
23:29:35 <kuribas> iqubic: swaps the arguments to mappend
23:32:04 <iqubic> :k dual
23:32:05 <lambdabot> error:
23:32:05 <lambdabot>     Not in scope: type variable ‘dual’
23:32:05 <lambdabot>     Perhaps you meant type constructor or class ‘Dual’ (imported from Data.Monoid)
23:32:14 <iqubic> :k Dual
23:32:16 <lambdabot> * -> *
23:32:46 <kuribas> is Dual a proper dual in the CT sense?
23:33:04 * hackage potoki-hasql 1.5 - Integration of "potoki" and "hasql".  http://hackage.haskell.org/package/potoki-hasql-1.5 (NikitaVolkov)
23:33:05 <mxf> What exactly does "is:exact" do, when I use it in hoogle? Searching for "f a -> (f a, a) is:exact" yields `swap :: (a, b) -> (b, a)` which I find surprising
23:33:25 <iqubic> What's the ct sense of dual?
23:33:34 <cocreature> mxf: I don’t think is:exact does anything when searching for a type. it only takes effect if you search for a name
23:33:58 <mxf> ah, ok, that explains things
23:34:49 <mxf> I wish I knew what I was doing, heh.
23:34:57 <mxf> s/was/am/
23:35:00 <kuribas> iqubic: reversing the morphisms?
23:35:02 <cocreature> don’t we all :)
23:43:12 <Ariakenom> does anyone here use some custom prelude they like?
23:44:24 <Cale> I use the Prelude from base and like it.
23:47:06 <cocreature> Ariakenom: I use and like protolude
23:48:21 <iqubic> What benefits does protolude have over prelude?
23:48:50 <Ariakenom> what's meant by "A sensible starting Prelude for building custom Preludes."
23:49:31 <cocreature> iqubic: you could just try to answer questions by looking at docs instead of having people spoon-feed you everything :)
23:50:04 <Ariakenom> How much customisation is needed?
23:50:13 <cocreature> Ariakenom: once you use a custom prelude it makes sense to make a project specific prelude module from which you reexport the custom prelude (e.g. protolude) but also potentially other things that you are going to use a lot in this project
23:50:22 <mxf> +1 protolude. Everything sensible is already imported.
23:51:02 <cocreature> Ariakenom: it’s not so much customization as it is additions
23:51:28 <Ariakenom> ok
23:52:12 <mxf> The only grief I have with protolude is, that it feels like it bans me from using String (which is nice when debugging)
23:52:13 <Ariakenom> "Banishes impure exception throwing outside of IO."? div :: a -> NonZero a -> a
23:52:43 <cocreature> there are always exceptions to not throwing exceptions :)
23:53:32 <cocreature> mxf: given that it overloads Debug.Trace to work with Text instead I haven’t really found that to be a problem
23:54:03 * hackage hasql-pool 0.4.3.1 - A pool of connections for Hasql  http://hackage.haskell.org/package/hasql-pool-0.4.3.1 (NikitaVolkov)
23:55:53 <cocreature> mxf: and it’s not like it removes the APIs that work on String, it just overloads them to work on Text as well
23:56:04 * hackage hasql-pool 0.5 - A pool of connections for Hasql  http://hackage.haskell.org/package/hasql-pool-0.5 (NikitaVolkov)
