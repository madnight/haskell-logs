00:00:02 <jchia1> I think I can't derive Eq for a GADT. What's the next best thing I can do to avoid manually implementing the Eq instance?
00:00:19 <geekosaur> I mean, sometimes "backhand training" is a way to go. and sometimes you;re going against their cognition and you're seeting them up for failure
00:00:26 <dyl> jchia1: if you don’t mind, what does the GADT look likeV
00:00:29 <geekosaur> but you're "the expert" who thinks "it's for their own good"
00:00:50 <geekosaur> that *attitude* has a trap in it
00:00:57 <dyl> Oh absolutely.
00:01:03 <geekosaur> then why do you keep puishing it?
00:01:18 <dyl> But that’s why the way you present the feedback you give is important.
00:01:27 <dyl> You need to ensure the user is getting something primary (better code) from it
00:01:33 <dyl> and also something secondary (learning)
00:01:41 <geekosaur> no, you're pushing the trap again
00:01:43 <dyl> The best tools are training wheels they will eventually discard.
00:01:54 <geekosaur> you know with full certainty yoauy you know best
00:01:55 <dyl> You can’t lord over them forever.
00:01:58 <dyl> No I don’t.
00:02:06 <dyl> That’s why I keep saying that user studies are key.
00:02:21 <dyl> I can’t know what is or isn’t good advice ahead of time, only what patterns of presentation are effective.
00:02:30 <dyl> And that comes from marketing and PR.
00:02:49 <geekosaur> but they only work if you aren;t carrying that attitude around. because that attitude will lead you to believe you're doing them good when you aren't
00:02:55 <dyl> Truly interesting tools would be even more dynamic and adaptive.
00:03:10 <dyl> And that attitude is the dominant problem in tooling today.
00:03:30 <dyl> That’s the attitude that suggests “if we just give them Julia and Jupyter notebooks they’ll suddenly know what to do!”
00:03:39 <dyl> The word for that attitude is conceit.
00:04:08 <cocreature> jchia1: iirc deriving-compat can derive Eq1 for GADTs but I might be misremembering
00:04:22 <dyl> The first rule of UX is “don’t make the user think”, the corollary is “don’t assume the user can’t think”.
00:04:49 <dyl> jchia1: you can stand-alone derive for GADTs I think
00:04:54 <dyl> It’s worked for me sometimes
00:05:26 <dyl> geekosaur: you have to in some sense assume users are well intentioned idiots
00:05:29 <dyl> Don’t patronize them
00:05:37 <dyl> But tap into that good intention and help them fulfill their goals.
00:05:43 <dyl> Trust they can learn and that they will.
00:05:58 <dyl> They only seem like idiots.
00:06:01 <jchia1> dyl, cocreature: Something like this: https://gist.github.com/jchia/d6cfeae0df45d6a3afedd77aa6eac045
00:06:04 <mxf> Hi *, Is it possible to search for instances of a type class on hoogle?
00:06:08 <geekosaur> I'm sorry but that statement itself is patronizing and going to make problems for both you and them
00:06:12 <jchia1> Just an excerpt
00:06:23 <dyl> geekosaur: you’re emphasizing confrontation and not addressing the theory.
00:06:32 <dyl> I know what you’re saying and I get it.
00:06:42 <cocreature> mxf: afaik it isn’t
00:06:47 <dyl> But I’m not talking to a user right now.
00:07:06 <dyl> One moment while I look at the posted sample.
00:07:10 <dyl> We should also take this to offtooic.
00:07:13 <geekosaur> I know the theory. The theory includes that if you have that attitude *anywhere* then it will leak into what you do.
00:07:25 <dyl> What exactly is “that attitude”?
00:07:37 <geekosaur> [21 07:05:05] <dyl> geekosaur: you have to in some sense assume users are well intentioned idiots
00:07:42 <geekosaur> the attitude that leads to that statement
00:07:52 <dyl> And I maintain... Which attitude?
00:07:59 <dyl> You can reach the same place many different ways.
00:08:00 <geekosaur> it doesn't matter what audience youre expressing it to, that attitude is a toxin that spreads
00:08:18 <dyl> How does it spread?
00:08:23 <dyl> And what makes it toxic
00:08:30 <dyl> Again, you haven’t identified the attitude
00:08:44 <mxf> cocreature, I was looking for instances of Contravariant, maybe I was tackling this the wrong way. I could look for reverse dependencies, I guess.
00:08:45 <dyl> Just an outcome you’re identifying with an unstated attitude.
00:09:03 <dyl> We should take this to offtopic
00:09:08 <dyl> Someone is actually asking for Haskell help
00:09:10 <mxf> cocreature, thanks for being my rubber ducky ;)
00:09:41 <cocreature> mxf: just looking at the instances in https://hackage.haskell.org/package/contravariant-1.4.1/docs/Data-Functor-Contravariant.html#t:Contravariant should already help
00:09:42 <dyl> #haskell-offtopic
00:09:46 <dyl> Let’s continue over there
00:09:59 <Axman6> thanks
00:11:01 <dyl> geekosaur: i’d like to hear your input genuinely
00:11:09 <mxf> cocreature, yeah, I was curious if there were other instances for f not being essentially (->)
00:11:10 <dyl> I understand where you’re coming from, I think.
00:11:32 <dyl> Anyhow, join me in offtopic and let’s keep talking.
00:11:45 <cocreature> mxf: there are the boring instances for things that are both covariant and contravariant, e.g., Const a
00:12:37 <cocreature> but you kinda need a function somewhere to get a parameter in a negative position
00:13:19 <mxf> ah, I see. Yes that's what I thought. When I first saw contramap I was *very* confused.
00:13:21 <dyl> geekosaur: the point of that statement is that you can’t assume users are thinking about the problem in as holistic or complete of a way, and even if they are they may just be working backwards from a desired and unfulfilled conclusion
00:13:37 <mxf> cocreature, thanks for clearing that up for me!
00:13:38 <dyl> “How I want it to work” is a massive obstacle to “it works”.
00:13:58 <dyl> And the Valhalla in which these aren’t distinct doesn’t exist, though it’s the ultimate goal of good design.
00:14:01 <cocreature> mxf: often you see specialized versions of Op, e.g., Predicate
00:14:07 <mxf> the type signature of contramap, that is.
00:14:09 <cocreature> mxf: hasql also uses them
00:14:25 <cocreature> s/them/Contravariant/
00:14:35 <Axman6> yeah Hasql makes good use of Contravariant functors
00:14:40 <mxf> ah, thanks. I'll have a look at it.
00:14:47 <dyl> Believing that you can fully trust your user and they know just as well *in the same way* that you the designer does is even more toxic.
00:15:05 <Axman6> there's a nice duality between Functors for decoding and contravariant functors for encoding
00:15:07 <dyl> That’s denying any recognition of their affordances.
00:15:22 <dyl> It’s assuming the only users that matter are smart and curious ones who are paying full attention
00:15:25 <Axman6> dyl: what happened to #haskell-offtopic? :P
00:15:29 <dyl> He hasn’t joined yet.
00:15:39 <dyl> I’m waiting for it and checking.
00:16:30 <mxf> Axman6, yeah, I guess that whole profunctor lens business is slowly making sense for me :)
00:17:02 <Axman6> mxf: check out https://www.youtube.com/watch?v=JZPXzJ5tp9w
00:17:56 <geekosaur> ffs. ok, apparently I say this in public. I don;t frequent offtopic, because there are people with even more toxic versions of that attitude there,.
00:18:09 <geekosaur> which I said in /msg
00:19:40 <dyl> just go to offtopic haha
00:19:44 <dyl> I want to continue
00:19:47 <mxf> Axman6, I think I already have watched this, good timing you bring that up again, because I feel like now I can really grok it.
00:19:52 <dyl> And I don’t do PMs :)
00:20:16 <Axman6> mxf: yeah it felt extremely relevant to your learning right now :)
00:21:26 <mxf> Axman6, cocreature: thanks a bunch :)
00:23:48 <dyl> geekosaur: just calling an attitude toxic and saying you want to avoid it is a fast track to accomplishing nothing
00:24:05 <dyl> Join offtopic, what me worry?
00:24:25 <dyl> Confront it if it bothers you so much
00:24:35 <dyl> This just isn’t the right place when people have real Haskell questions.
00:26:29 <Axman6> @pl \x y -> ((x,y),f x y)
00:26:30 <lambdabot> ap (ap . ((,) .) . (,)) f
00:26:57 <Axman6> @pl \(x, y) -> ((x,y),f x y)
00:26:57 <lambdabot> uncurry (ap (ap . ((,) .) . (,)) f)
00:27:13 <Axman6> @pl \(x, y) -> ((x,y),f (x,y))
00:27:13 <lambdabot> uncurry (ap (ap . ((,) .) . (,)) ((f .) . (,)))
00:27:37 <Axman6> @pl \x -> (x,f x)
00:27:38 <lambdabot> ap (,) f
00:27:38 <cocreature> Axman6: it’s not getting better :)
00:27:46 <Axman6> BAM! :P
00:27:56 <Axman6> (,) <*> f
00:28:21 <cocreature> I still find that harder to read than \x -> (x, f x) tbh :)
00:30:52 <Ariakenom> there's also (,) <$> id <*> f
00:39:25 <dyl> geekosaur: Engineers and designers are distinguished largely by whether they think something is defined by how it “looks” or how it “works”.
00:39:51 <dyl> The distinction of fallacy is that engineers often think how something works intrinsically matters more than how it is presented as working.
00:39:57 <akfp`> how can I get stack to tell me why "happy" is being built?  --dry-run says which packages needs to be built before it's built, but not why it's being built.
00:40:07 <dyl> And designers think that how something looks like it works matters intrinsically more than how it actually works.
00:40:50 <dyl> I think: design to teach users to (slowly) unify the two.
00:41:09 <dyl> Ensure that understanding the interface leads to understanding the implementation.
00:41:27 <dyl> Assume users are going to act like idiots, but have faith that they aren’t realty
00:41:32 <dyl> really.*
00:41:36 <cocreature> dyl: this is still offtopic here
00:41:42 <dyl> I know :(
00:41:48 <dyl> He refuses to join offtopic and I hate PMs.
00:42:08 <dyl> I just wanted to put a cap on things as I think the discussion has ended with one party abdicating.
00:42:16 <cocreature> just accept that not everyone wants to discuss things with you :)
00:42:31 <dyl> cocreature with the wisdom :)
00:42:36 <dyl> Right you are.
00:42:42 <dyl> I’m young and dumb, ;).
00:43:17 <cocreature> oh I’m both of those things as well or at least I like to believe so for the former (I’m sure about the latter :))
00:43:22 <dyl> I was just annoyed by getting a response in PM and then no follow through
00:43:26 <dyl> I’d just like people to say that.
00:43:31 <dyl> Rather than ragequit.
00:43:44 <dyl> If you tell me you don’t want to discuss, okay!
00:44:02 <dyl> But don’t say you just don’t want to do it in a certain way and then not respond when someone humors you.
00:44:15 <dyl> I’m probably younger and dumber than most regulars in this channel haha.
00:44:27 <dyl> I’ve been here since I was 15, with some breaks.
00:44:38 <petercommand> why do you hate PMs?
00:45:01 <dyl> Because on IRC I value interjections from more knowledgeable or wiser parties.
00:45:18 <dyl> I would prefer to discuss in a space where someone who knows more might be able to interject.
00:45:27 <dyl> IRC isn’t a confessional, it’s a cafe.
00:45:48 <petercommand> :)
00:46:01 <cocreature> another day of me being sad that Cale’s "select" function never made it into base :(
00:46:01 <dyl> I only managed to finish my senior project in high school because a certain guy interjected to provide me resources and tips.
00:46:03 * hackage protocol-buffers 2.4.10, protocol-buffers-descriptor 2.4.10, hprotoc 2.4.10 (k_bx): https://qbin.io/wv-oman-si6j
00:46:11 <dyl> I later found out “a certain guy” was Marlow...
00:46:18 <dyl> But that’s what makes IRC special.
00:46:29 <dyl> We’re all just handles, we judge each other on the content of what we say.
00:46:39 <dyl> IRC quenches celebrity.
00:47:12 <dyl> I like that about it.
00:48:05 <dyl> The only ranking is functional and administrative; in good channels ops aren’t celebrities they’re dedicated volunteers and public servants.
00:48:29 <dyl> Or they have a larger stake in the toocox
00:48:33 <dyl> Topic*
00:49:35 <dyl> But man, realizing that Jaffacake was Marlow after finishing my HS senior project (an LLVM frontend for STG) was a trip.
00:50:25 <dyl> Or, maybe I got the IRC handle wrong, it was  forever ago.
00:52:21 <dyl> cocreature: what was this select?
00:53:08 <[exa]> the unixy-socketish select
00:53:19 <[exa]> ?
00:54:13 <dyl> But kqueue :p
00:54:46 <petercommand> what is kqueue?
00:54:47 <dyl> Kernel = OG busy wait loop
00:54:52 <cocreature> dyl: https://mail.haskell.org/pipermail/libraries/2008-February/009270.html
00:55:02 <dyl> kqueue is the BSD mechanism that you should use in place of epoll or select.
00:55:12 <dyl> Basically you ask the kernel to notify you, rather than poll it.
00:55:17 <dyl> It’s push rather than pull
00:55:35 <akfp`> i have an on-topic question! how can I get stack to tell me *why* happy is being compiled?
00:55:52 <dyl> *is* being compiled?
00:56:02 <dyl> You probably have a dependency that uses it in some way.
00:56:16 <petercommand> oh, adding yourself into the queue :)
00:56:20 <akfp`> I have some ghcjs tests and in the process happy is being compiled, which is rubbish.
00:56:23 <cocreature> akfp`: I’m not sure there’s an easy way. the problem why things like --dry-run don’t work is probably that happy is a build-tool-depends rather than a regular build-depends
00:56:26 <dyl> kqueue = kernel queue
00:56:52 <akfp`> what's a build-tool-depends?
00:57:06 <dyl> It means the project depends on the package for building but not during runtime.
00:57:34 * hackage hedis 0.10.2 - Client library for the Redis datastore: supports full command set,pipelining.  http://hackage.haskell.org/package/hedis-0.10.2 (k_bx)
00:57:34 <dyl> So it’s not linked in, but it is needed for building.
00:57:53 <akfp`> so I need to download all of hackage and grep through the cabal files?
00:58:32 <dyl> I think there’s a way to print a tree, but I don’t know if it includes build depends
00:58:44 <dyl> You could just grep through the build folder though :)
00:59:00 <akfp`> where's the build folder? you mean somewhere in .stack-work?
00:59:03 <dyl> Everything you might want to grep is already downloaded in the process.
00:59:07 <dyl> Oh I don’t use stack.
00:59:10 <dyl> I just use cabals
00:59:19 <dyl> cabal*
00:59:29 <dyl> Someone else might be better equipped to answer that.
00:59:33 <akfp`> I don't like switching build system more than twice a month.
00:59:43 <dyl> That’s why I don’t use stack. :p
01:00:09 <dyl> I just never found the time or reason to switch.
01:00:20 <dyl> still use*
01:00:33 <dyl> Still use cabal* sorry
01:01:48 <akfp`> my build-plan includes about 500 packages, so I'd rather use stackage at least... but that's offtopic.  I need to find what to grep!
01:01:59 <mxf> Where does the positive and negative position lingo come from? Positive and negative with regards to what?
01:02:23 <jesyspa> mxf: You can see positives as "outputs" and negatives as "inputs".
01:02:38 <mxf> Haskell really makes me feel like I need a math major
01:02:54 <mxf> jesyspa, I get what it means, but where does the lingo come from?
01:03:15 <jesyspa> Oof, well, it's used in logic for implications.
01:03:26 <mxf> Ah!
01:04:26 <mxf> jesyspa, thanks for pointing me in the right direction
01:05:20 <jesyspa> No worries, sorry I can't be more specific.  If you're really curious, you could probably ask math.SE for where it was first used.
01:05:32 <mxf> I generally find it unhelpful to use lingo without explaining it where it comes from tbh. Maybe that's because I'm not a native speaker, I don't know.
01:06:32 <cocreature> maybe it’s something like a -> b is equivalent to ¬a∨b so a is negative and b is positive
01:06:36 <cocreature> but I’m just guessing here
01:06:56 <cocreature> eh and the -> is supposed to be logical implication, not a function type
01:07:40 <jesyspa> It is like that (whether the thing occurs negated or not), except that if we're looking at logics we generally prefer to see -> as fundamental and negation as defined.
01:08:42 <cocreature> that depends on what kind of logic you’re talking about
01:09:26 <jesyspa> Hm, in which would the opposite be the case?  (In some it doesn't matter, of course.)
01:09:52 <sclv> positive and negative make the most sense to me in the sense of co and contravariance
01:10:04 <sclv> the a in a -> b is contravariant
01:10:13 <sclv> its "negative" because it flips the variance
01:10:34 <cocreature> jesyspa: I was mostly refering to the cases where it doesn’t matter (e.g. propositional logic) and it’s fairly common to use negation as the primitive there
01:11:08 <petercommand> sclv: what does varaiance mean in this context
01:11:27 <sclv> as on covariant and contravariant functor
01:11:30 <jesyspa> Hmm, fair enough, I guess I'm a bit biased to the categorical approaches. :)
01:11:47 <sclv> or as in subtyping
01:12:07 <cocreature> jesyspa: sure I’m too but I would be surprised if this terminology originates from the categorical approaches
01:12:09 <dyl> mxf: you don’t, don’t worry!
01:12:16 <dyl> But if it inspires you to study math...
01:12:22 <dyl> (cough do it cough)
01:12:27 <dyl> (Math is cool yo)
01:12:47 <dyl> It won’t help with Haskell all that much though.
01:13:42 <dyl> jesyspa the most common usage of contra- and co-variant you’ll see in programming is in object oriented languages with inheritance.
01:14:22 <dyl> Covariance in that case is when a function parameter of type A can take any argument that is either A or a subtype of A.
01:14:38 <dyl> Contravariance is the other way around.
01:14:39 <mxf> dyl, that's exactly my point. It doesn't help but it borrows lingo and uses it in a slightly different way or meaning
01:14:47 <petercommand> sclv: I know how variance is used in subtyping, but I am not that familiar with functors
01:14:50 <dyl> For example if you have a collection type
01:14:58 <dyl> Which is of type Collection<Apple>
01:15:04 <sclv> akfp`: you can print out a visualization of the dep graph of your package to see where happy is required
01:15:05 <sclv> https://docs.haskellstack.org/en/stable/dependency_visualization/#dependency-visualization
01:15:11 <dyl> And a method .add(x: Fruit)
01:15:24 <dyl> Then shouldn’t the return type be Collection<Fruit>?
01:15:29 <jesyspa> cocreature: Oh, I definitely think it predates that.  I expect it comes from the notion of a positive formula.
01:15:35 <jesyspa> dyl: Wrong highlight? :)
01:15:41 <sclv> akfp`: I _think_ that works with build deps too
01:15:55 <dyl> Probably.
01:16:17 <dyl> Contravariance in a typing context means widening, covariance means generalizing.
01:16:19 <dyl> Very roughly.
01:16:33 <dyl> Generalizing in a constrained way though.
01:16:38 <dyl> Such as by subtyping.
01:16:46 <sclv> or rather with build-tool-depends deps
01:16:48 <dyl> And widening in a constrained way also, such as by supertyping.
01:16:54 <dyl> But that’s just one example.
01:17:53 <dyl> Co and contra variance in the context of typing should be understood in terms of a lattice.
01:18:20 <petercommand> sclv: why is the a in a -> b contravariant?
01:18:30 <jesyspa> petercommand: You can actually think of variance in subtyping as a special case of variance here.  You have some kind of relation between types A is a subtype of B (A <= B).
01:18:31 <sclv> in subtyping terms
01:18:38 <dyl> Yes.
01:18:46 <dyl> In terms of a type system with subtyping.
01:18:46 <sclv> if you have an a' that is a subtype of a, then you can't use it in a -> b
01:19:00 <sclv> or er, vice versa i mean
01:19:08 <dyl> If that position is covariant, you can
01:19:18 <dyl> If it’s contravariant you cannot
01:19:24 <jesyspa> petercommand: Now every function B -> X can also be seen as a function A -> X, just like every A can be seen as a B.  Hence, A -> X <= B -> X.
01:19:49 <jesyspa> petercommand: So we say that the operation that sends a type T to a function T -> X is covariant with respect to the <= relation.
01:19:58 <dyl> Covariance: if A :> B, then A -> X ⇒ B -> X
01:20:17 <sclv> right, that's clearer
01:20:18 <dyl> Contravariance: if A <: B, then B -> X ⇒ a -> X
01:20:36 <dyl> We
01:20:39 <dyl> Er*
01:20:44 <dyl> Yeah.
01:20:49 <dyl> Basically just flip the arrows around
01:21:40 <dyl> Contravariance: if A :> B, then B -> X ⇒ A -> X
01:21:41 <jesyspa> petercommand: The final distinction, I suppose, is that when we talk about covariance in the context of functors, instead of talking about the <= subtyping relation, we talk about functions A -> B.
01:21:43 <dyl> There we fix
01:21:48 <dyl> There we go*
01:22:29 <dyl> But jesyspa i think that can be confusing, it’s more useful to think about lattices
01:22:41 <dyl> Categories can encode lattices
01:22:52 <dyl> But they’re not a natural way to discuss them.
01:23:10 <jesyspa> petercommand: So instead of just saying "A <= B is true implies A -> X <= B -> X is true", we say "every function A -> B gives rise to a function (A -> X) -> (B -> X)".
01:23:47 <dyl> (A lattice is just a set equipped with an ordering, which because arrows in a category have direction, trivially generated a category)
01:23:54 <dyl> generates*
01:24:10 <dyl> (Also caveat emptor on “just”)
01:24:45 <jesyspa> dyl: Thank you, I'm familiar with the notion of a lattice :)  I prefer the more practical example.
01:25:17 <dyl> Category theory is assembly for algebra. Sometimes an example in C is more prudent...
01:25:41 <dyl> But if you can see that a subtyping system generates a lattice of types...
01:26:13 <dyl> Then understand co/contra variance as the relationship between the direction of arrows in that lattice and in what a position in a function (parameter or return) “accepts”.
01:26:28 <dyl> Co = same way.  Contra = opposite way.
01:26:50 <jesyspa> petercommand: Oh, I think I got the arrows turned around at some point, sorry about that ^^;  I hope it's still clear.
01:26:59 <dyl> Arguments TEND to be covariant and return values TEND to be contravariant.
01:27:05 <dyl> Not always but usually.
01:27:29 <dyl> In Haskell we push the limits ;).
01:27:44 <dyl> But in Java for example that’s a hard rule.
01:28:34 * hackage rdf4h 3.0.4 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-3.0.4 (RobStewart)
01:28:35 <petercommand> jesyspa: I am still thinking about it..^^
01:28:52 <dyl> petercommand the best example I know is this
01:29:05 <dyl> Imagine you have some Set<T> type.
01:29:28 <dyl> When you append an element to it, what happens when you append something that is a sibling type to T?
01:29:53 <petercommand> sibling type?
01:29:55 <dyl> You want to return Set<T join S>
01:29:58 <mxf> Axman6, thanks again for the talk suggestion, i think that's a lot clearer to me now.
01:30:07 <dyl> Meaning they share a parent supertype
01:30:15 <dyl> So say I have Set<Apple>
01:30:21 <dyl> And I append an Orange
01:30:31 <dyl> The result should be Set<Fruit>
01:30:41 <petercommand> yep
01:30:51 <dyl> Because Fruit is the lattice join of Apple and Orange under subtyping as a lattice
01:31:16 <dyl> But if I have the same Set<Apple> and append a Fuji, then it’s still a set of Apples
01:31:37 <petercommand> the largest common factor
01:31:38 <dyl> So the return type of append is contravariant.
01:31:44 <dyl> Lattice join :)
01:32:03 <dyl> And yes, analytical LUB and GLB are lattice joins and meets.
01:32:18 <dyl> Lattices are ways of talking about sets with ordering operations.
01:32:43 <dyl> A join us the “least common parent”
01:32:53 <dyl> A meet is the “greatest common child”
01:32:55 <dyl> So to speak.
01:33:33 <dyl> They use the same symbols as disjunction and conjunction in logic respectively.
01:33:38 <dyl> And that’s not an accident.
01:34:01 <dyl> It’s also not an accident that exterior and inner products in differential algebra use the same symbols.
01:34:30 <dyl> (Well, exterior does, inner we usually use a dor instead)
01:34:52 <petercommand> Can I say that the result type is contravariant because it generalizes the T in Set<T>?
01:35:46 <petercommand> it finds the least common parent
01:36:12 <dyl> A covariant position with T (usually denoted T+) allows T or any of its subtypes.
01:36:31 <dminuoso> I have a web service. Each request is forkIO'd into a handler, and I want to measure the time for handling a packet for debugging purposes. I cant decide whether getCurrentTime is good enough, or whether I should rather grab `clock` for monotonic timers
01:36:42 <dyl> A contravariant position (T-) accepts T or any of its supertypes.
01:36:47 <dminuoso> (Actually not as much debugging purposes, rather for INFO logging)
01:36:58 <petercommand> dyl: ah..
01:37:14 <dyl> So do you see why parameters TEND to be covariant?
01:37:31 <dyl> And return types TEND to be contravariant?
01:37:56 <petercommand> yep
01:37:57 <dyl> Think of append :: Set A -> B -> Set ?
01:38:19 <dyl> Shouldn’t the ? be the lattice join of A and B?
01:38:37 <dyl> but also shouldn’t you accept any subtype of B in the second position?
01:38:52 <dyl> The return is contra, the second parameter is co.
01:39:07 <petercommand> yep
01:39:14 <petercommand> We can have a smaller set as its argument types, and a bigger set as its output type
01:39:22 <dyl> You got it.
01:39:26 <dyl> The reason this relates to category theory...
01:39:34 <dyl> Is that any lattice is trivially encoded as a category.
01:39:43 <dyl> These are originally CT terms.
01:39:55 <dyl> So co means “arrows go the same way”
01:40:02 <dyl> And contra means “arrows go opposite ways”
01:40:33 <dyl> And what were relating is the category generated by the subtype lattice and the category invoked by some position in a function
01:40:40 <dyl> It’s easier to just think about lattices tho there’s
01:40:45 <dyl> Though*
01:41:15 <dyl> A covariant functor from C to D is one where arrows are preserved in some sense
01:41:50 <dyl> A contravariant functor is one where they are preserved but reversed.
01:42:10 <dminuoso> :t contramap
01:42:11 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
01:42:14 <dminuoso> :t map
01:42:15 <lambdabot> (a -> b) -> [a] -> [b]
01:42:17 <dminuoso> :t fmap
01:42:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:42:32 <dyl> So think about the endofunctor from ℤ  -> ℤ defined by (-)
01:43:05 <dyl> ℤ -> ℤ ^op
01:43:09 <dyl> Sorry
01:43:20 <dyl> Where the category is Z (the integers) and an arrow exists when A > B
01:43:48 <dyl> The functor (-) preserves the same relationship between objects and arrows
01:43:55 <dyl> But it reverses all of the arrows
01:44:16 <dyl> This is why we use T+ and T- to denote covariance and contravariance
01:44:28 <dyl> petercommand: does that make sense?
01:45:19 <dyl> Btw an endofunctor is a functor that maps a a category to itself, I was mistaken in invoking the term,
01:45:47 <dyl> because I’m the categories generated by ℤ and < and > respectively the arrows are reversed and so they are not the same category.
01:45:53 <petercommand> ah, I was about to say that I don't know that term ;)
01:45:56 <dyl> They are the “op” of each other though.
01:46:05 <dyl> One is the “dual” of the other.
01:46:16 <dyl> They’re “the same” but also “mirrored”.
01:46:43 <dyl> Neither says less or more, but they’re not exactly equivalent because they’re reversed.
01:46:55 <dyl> They’re mirror images.
01:47:37 <dyl> That’s what “co-something” or “the dual of something” means in general”.
01:47:50 <dyl> In this case it’s not the same “co” though.
01:48:08 <dyl> Co means “same”, contra means “opposite”.
01:48:50 * dyl denies the urge to mention adjuncts.
01:48:50 <petercommand> dyl: I am not following...I am not familiar enough with some of the category theory terms
01:48:54 <dyl> Ok.
01:48:57 <Faraon_> what is this page? https://tinyurl.com/ya79dnx5
01:49:13 <dyl> Do you understand what I mean in terms of, say, Java types?
01:49:23 <dyl> Also, do you understand what a lattice is?
01:49:40 <dyl> A lattice is just a set equipped with an ordering.
01:49:44 <petercommand> yes, I understand lattice, and the fruit example
01:50:02 <dyl> So, think about a lattice as a graph.
01:50:16 <dyl> Where an arrow from A -> B means A > B
01:50:26 <dyl> In other words, supertypes have arrows to subtypes,
01:50:30 <dyl> Right?
01:50:44 <petercommand> yes
01:50:57 <dyl> Via some math (Cayley) I won’t mention, any such graph is also a category.
01:51:12 <dyl> Because a category is just a set of objects and arrows between them.
01:51:15 <dyl> It’s super simple.
01:51:22 <petercommand> Cayley's theorem?
01:51:37 <dyl> There are a few Cayley’s theorems :).
01:51:42 <dyl> But, yes.
01:51:49 <petercommand> haha
01:51:58 <dyl> Now imagine you have such a graph for the integers (ℤ) under <
01:52:02 <dyl> And another under >
01:52:07 <petercommand> I know the one about groups
01:52:29 <Ariakenom> are sparks and threads idfferent?
01:52:30 <dyl> Let’s call them Cat(Z, <) and Cat(Z, >)
01:52:31 <petercommand> finite group isomorphic to a permutation group
01:52:48 <dyl> They have exactly the same objects
01:52:59 <dyl> And the arrows between those objects are almost the same too!
01:53:02 <dyl> They just go the opposite way
01:53:20 <dyl> So if we call the former C, we would call the later C^op
01:53:28 <dyl> Because... the arrows are opposite!
01:53:32 <dyl> See: easy, right?
01:53:47 <petercommand> yes!
01:53:59 <petercommand> that's easy :)
01:54:02 <dyl> A functor from C to C preserves the direction of the arrows, so it’s covariant
01:54:11 <dyl> A functor from C to C^op reverses them
01:54:21 <dyl> So it’s contravariant
01:54:26 <dyl> That’s all there is to it :).
01:54:54 <dyl> It can be generalized more but this is an easy and instructive example.
01:55:04 <petercommand> dyl: what are the objects and arrows in a functor?
01:55:17 <dyl> A functor maps one category to another
01:55:24 <dyl> Objects and arrows are what make up a category
01:55:41 <dyl> A category is just a set of objects and a set of arrows between them
01:55:53 <dyl> Which you can probably see is equivalent to a directed graph right?
01:56:03 <petercommand> yep
01:56:16 <dyl> The general case is, take two arbitrary objects in C (a and b)
01:56:29 <dyl> If there exists an arrow a -> b
01:56:39 <dyl> and a functor C -> D
01:56:51 <dyl> Which we will call f
01:57:06 <dyl> Then a -> b ⇒ f a -> f b
01:57:13 <dyl> :t fmap
01:57:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:57:58 <dyl> And if it’s contravariant functor then a -> b will be mapped by the functor to f b -> f a
01:58:29 <dyl> :t contramap
01:58:30 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
01:58:35 <dyl> See what I mean now?
01:58:54 <petercommand> so the objects in D are like "f k" for some k right?
01:59:06 <dyl> If you have a functor f
01:59:19 <petercommand> Ok.
01:59:29 <dyl> Then every element of D can be written f x where x is an element of C
01:59:39 <dyl> In other words, it maps each object in C to an object in E
01:59:43 <dyl> D*
02:00:05 <dyl> And also maps the arrows but that’s a little more loosey goosey
02:00:21 <dyl> Because it can either be “map them with the same direction”
02:00:28 <petercommand> there are arrows between every object in C?
02:00:29 <dyl> Of “map them with reversed directions”
02:00:37 <dyl> Not every single one.
02:00:49 <dyl> Think about a category as a directed graph
02:00:50 <dyl> For now.
02:01:05 <dyl> That’s a pretty good analogy that covers most useful cases.
02:01:17 <dyl> Just remember it isn’t exactly right it’s just a very close metaphor.
02:01:44 <dyl> As long as you’re dealing with finite categories or nice infinite ones it will work though.
02:01:55 <dyl> And that’s the relevant Cayley’s theorem :p
02:02:21 <dyl> Just think about directed graphs for now though.
02:02:23 <petercommand> so, (Z, <) would be an instance of an infinite category right?
02:02:29 <dyl> Yes but a nice one.
02:02:42 <petercommand> a nice one :3
02:02:50 <dyl> Not pathological ;).
02:02:55 <petercommand> haha
02:03:28 <dyl> Categories are among the most general algebraic structures you can come up with.
02:03:49 <dyl> They’re a way of encoding almost any algebraic structure the same way
02:03:58 <dyl> and then talking about the similarities or differences.
02:04:14 <dyl> But the directed graph analogy is useful here.
02:04:24 <dyl> And it also holds in the majority of cases.
02:04:30 <petercommand> yeah, the definition of a category is very general
02:04:48 <dyl> This is why I call it an “assembly” for algebraic structures.
02:04:54 <petercommand> :)
02:05:18 <dyl> But it’s not in of itself all too useful
02:05:38 <dyl> Most of the interesting stuff is encoded in functor
02:05:45 <dyl> functors*
02:05:51 <dyl> And natural transformations
02:06:06 <dyl> But the point is, getting back to it
02:06:22 <dyl> That a covariant functor from C -> D preserves the direction of arrows.
02:06:32 <dyl> A contravariant functor reverses them.
02:06:53 <dyl> So if you can imagine how you generalize from a lattice to a category.
02:07:03 <dyl> And how to visualize a category as a directed graph...
02:07:14 <dyl> That should be shortly clicking :)
02:07:31 <dyl> Subtyping is an ordering of types.
02:08:40 <dyl> petercommand: a lot of CT and Haskell is hard because it’s simple.
02:09:01 <dyl> You just have to relax and realize that it’s not actually complex, just very simple. And that’s why it’s difficult.
02:09:17 <dyl> You’ve clearly studied math so you know what I mean :).
02:09:47 <petercommand> by simple, do you mean abstract? :)
02:10:00 <dyl> Theyre orthogonal concepts
02:10:07 <dyl> But abstract things do tend to be simple
02:10:10 <dyl> But also hard.
02:10:26 <dyl> Simplicity doesn’t make things easier, it can often make it hard because as humans we think in concretions.
02:10:44 <petercommand> I agree
02:10:48 <dyl> Category theory is hard because if you don’t have a catalogue of examples to refer to, you’re dealing in pure abstraction which isn’t natural to humans.
02:11:05 <dyl> But if we were machines it would be the easiest math there is.
02:12:37 <dyl> Anyhow does my explanation of co/contra make some sense now generality?
02:12:40 <dyl> Generally?*
02:12:52 <dyl> :t fmap
02:12:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:12:59 <dyl> :t contramap
02:13:00 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
02:13:09 <dyl> Think of f as a functor (because it is ;))
02:14:26 <dyl> Functor could be called “CovariantFunctor”
02:14:37 <maphael_schumape> hi i've been watching haskellrank and have been trying the functional problems on hackerrank (funny name for a site). I have to write a function to replicate integers from a list (arr) a given amount of times (n) but I'm a bit confused. I'm trying to partially apply replicate with n arguments then fill in the blanks by supplying the the second argument through map to build a list
02:14:58 <dyl> And Contravariant could be called ContravariantFunctor
02:15:25 <dyl> :t replicate
02:15:26 <lambdabot> Int -> a -> [a]
02:16:05 <dyl> maphael_schumape can you restate the problem?
02:16:12 <petercommand> dyl: umm..I think I still have to think about it..:p
02:16:14 <dyl> I’m not sure what you’re trying to do.
02:16:30 <dyl> petercommand: give me an example of a case you’re not sure about.
02:16:40 <dyl> I think you get the general idea.
02:17:22 <dyl> If we have a lattice L and generate a category Cat(L) then Cat(L)^op is the same but with the lattice operation flipped around.
02:17:48 <dyl> Cat(L) -> Cat(L) is a covariant functor
02:18:16 <dyl> Cat(L) -> Cat(L)^op is contravariant
02:18:31 <maphael_schumape> dyl: i have to finish a function f n arr = [what i write]. it is supposed to return a list of the integers so n = 2 arr = [1,4] you get [1,1,4,4]
02:18:45 <dyl> Just remember that the “contra” just means “the structure is the same but the directions of the arrows are reversed”.
02:18:48 <dyl> There’s no more to it.
02:18:59 <dyl> It’s hard because it’s simple :).
02:19:04 <dyl> And that’s the hardest kind of hard
02:19:25 <dyl> maphael_schumape: im not entirely sure what you mean.
02:19:46 <dyl> So you need to figure out what f is.
02:19:59 <dyl> And then apply it to each element and concatenarte the results?
02:20:21 <dyl> I need more than one example to understand what the problem is :p
02:20:37 <maphael_schumape> dyl here is an example f 2 [1,2,3] = [1,1,2,2,3,3] f 0 [1,2,4] = []
02:20:55 <dyl> The right hand doesn’t make sense to me.
02:20:59 <dyl> Is that one or two examples?
02:21:43 <dyl> So in other words it’s “f array = <an array where each element of array is duplicated n times>”?
02:21:43 <maphael_schumape> two examples dyl
02:21:52 <maphael_schumape> yeah dyl
02:21:54 <dyl> f array n*
02:21:55 <dyl> Okay
02:22:11 <dyl> So think about for each element of array, producing a new array of size ℕ
02:22:12 <maphael_schumape> so this is my code but i think there is an issue between the read and intercalate ""
02:22:13 <maphael_schumape> https://paste.debian.net/1025628/
02:22:14 <dyl> n
02:22:16 <petercommand> dyl: I think I get it :)
02:22:25 <maphael_schumape> i'm a bit confused about what the compiler says
02:22:39 <dyl> And then concatenating the results.
02:22:45 <petercommand> dyl: Thanks for the explanation :3
02:22:55 <dyl> No problem
02:23:02 <dyl> This channel is why I can even write Haskell
02:23:07 <dyl> I’m just paying it forward
02:23:28 <dyl> maphael_schumape think first about [T] -> [[T]]
02:24:06 <maphael_schumape> so that i thought i could handle as map (replicate n) arr
02:24:13 <dyl> Right and
02:24:38 <dyl> > map (replicate 2) [1, 2, 3]
02:24:38 <maphael_schumape> that seems to work
02:24:40 <lambdabot>  [[1,1],[2,2],[3,3]]
02:24:46 <dyl> What is left now?
02:25:04 <maphael_schumape> a list of pairs
02:25:23 <maphael_schumape> well maybe not pairs not sure if that is a different data type
02:25:29 <mxf> maphael_schumape, what helps me a lot in those cases is ghci and :t and hoogle.
02:25:46 <maphael_schumape> oh i've been using them i really like them mxf. the name is such a rip off :O
02:25:49 <dyl> How about this
02:26:13 <dyl> > concat $ map (replicate 2) [1, 2, 3]
02:26:15 <lambdabot>  [1,1,2,2,3,3]
02:26:18 <dyl> Do you see how that works?
02:26:31 <dyl> Now how would you create a function for that with arbitrary n and an arbitrary list!
02:26:33 <dyl> ?*
02:26:34 <lambdabot> Maybe you meant: v @ ? .
02:26:50 <dyl> Also note that a $ b just means a (b)
02:27:28 <dyl> It’s just a way of saying “everything to the right of $ should be taken as if it were parenthesized)
02:27:44 <dyl> “*
02:27:47 <maphael_schumape> f n arr = concat $ map (replicate n) arr
02:27:52 <dyl> Yup!
02:27:54 <maphael_schumape> i think it was because i was using application before
02:28:02 <maphael_schumape> but in terms of naive set theory ideas that doesnt really work
02:28:43 <dyl> @let test n xs = concat $ map (replicate n) xs
02:28:44 <lambdabot>  Defined.
02:28:58 <dyl> > test 4 [1, 2, 3]
02:29:00 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3]
02:29:09 <dyl> When you have a problem you can’t solve
02:29:19 <maphael_schumape> i usually use paper
02:29:36 <dyl> break it fown into easier sub problems,
02:29:52 <dyl> And that’s a usually good habit
02:30:09 <dyl> Paper and pencil are your friends.
02:30:25 <dyl> Don’t be afraid to use the REPL though
02:30:48 <dyl> Using paper and pencil is something many programmers forget about :).
02:30:52 <dyl> It’s a very good habit to have.
02:31:24 <dyl> Just remember to break the problem up into smaller problems.
02:31:26 <maphael_schumape> by the way i wasn't sure what function in prelude this was since i don't know what the type signature would look like not that i have a use. but if you want to rearrange the function arguments of a function can you do it with a list
02:31:35 <maphael_schumape> like a two argument flip
02:31:44 <dyl> :t flip
02:31:45 <lambdabot> (a -> b -> c) -> b -> a -> c
02:32:55 <dyl> maphael_schumape and never be afraid to ask questions in this channel
02:33:10 <dyl> This is easier the nicest and most helpful channel on freenode
02:33:19 <maphael_schumape> no i mean like f a b c d -> f  a d c b by specifying a list like [0,3,2,1]
02:33:22 <maphael_schumape> but thank you
02:33:38 <dyl> But then you have f a not f a b c d right?
02:33:44 <dyl> Because a is a lost title
02:33:50 <dyl> List type*
02:33:56 <dyl> But you’ve got the right idea.
02:34:20 <dyl> How would you go from [a] to (a, a, a, a)
02:34:21 <maphael_schumape> i mean like a higher order function that rearranges the arguments according to how you specify
02:34:53 <dyl> And how would you handed an array whose length isn’t a multiple of 4?
02:34:58 <dyl> Handle*
02:35:18 <alexad> the idea of a [a] -> (a, a, a, a) frightens me
02:35:25 <dyl> f a b c d = f a d c b
02:35:31 <dyl> Er
02:35:36 <maphael_schumape> oh
02:35:39 <maphael_schumape> i mean g
02:35:47 <maphael_schumape> they should be immutable
02:35:56 <dyl> @let g f a b c d = f a d c b
02:35:56 <maphael_schumape> dw i don't think it is in prelude
02:35:57 <lambdabot>  Defined.
02:36:16 <dyl> > g (:) 1 2 3 4
02:36:19 <lambdabot>  error:
02:36:19 <lambdabot>      Ambiguous occurrence ‘g’
02:36:19 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.g’,
02:36:23 <dyl> Damnit
02:36:24 <dyl> Okay
02:36:58 <dyl> @ley testf a b c d = f a d c b
02:36:59 <lambdabot>  Defined.
02:37:14 <dyl> > testf (:) 1 2 3 4
02:37:16 <lambdabot>  error:
02:37:16 <lambdabot>      • Could not deduce (Typeable a0) arising from a use of ‘testf’
02:37:16 <lambdabot>        from the context: FromExpr t
02:37:29 <dyl> Goddamit lambdabot
02:37:55 <dyl> @let testf a b c d = f a d c b
02:37:56 <lambdabot>  .L.hs:195:1: warning: [-Woverlapping-patterns]
02:37:57 <lambdabot>      Pattern match is redundant
02:37:57 <lambdabot>      In an equation for ‘testf’: testf a b c d = ...
02:38:35 <dyl> @let dinglewhop f a b c d = f a d c b
02:38:36 <lambdabot>  Defined.
02:38:47 <dyl> > dinglewhop 1 2 3 4
02:38:50 <lambdabot>  error:
02:38:50 <lambdabot>      • Could not deduce (Num t30)
02:38:50 <lambdabot>        from the context: (Num (t1 -> t2 -> t3 -> t4 -> t5), Num t3,
02:38:58 * dyl sigh
02:39:22 <dyl> > dinglewhop (:) 1 2 3 4
02:39:24 <lambdabot>  error:
02:39:25 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Integer -> Integer -> t5’
02:39:25 <lambdabot>        Expected type: Integer -> [Integer] -> Integer -> Integer -> t5
02:39:51 <dyl> Okay one moment
02:40:04 <dyl> I’m being dumb
02:40:09 <dyl> Sorry lambdabot.
02:40:15 <mupf> Can anyone tell me how to start with haskell using arch linux? https://wiki.archlinux.org/index.php/Haskell#ArchHaskell_repository seems to be offline?
02:40:34 <dyl> @let f a b c d = (a - b) + (c - d)
02:40:35 <lambdabot>  .L.hs:196:17: error:
02:40:35 <lambdabot>      Ambiguous occurrence ‘f’
02:40:35 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
02:40:44 <maphael_schumape> that site is online you can install cabal it says
02:40:52 <maphael_schumape> using cabal-install
02:41:01 <dyl> @let fuckingChrist a b c d = (a - b) + (c - d)
02:41:02 <lambdabot>  Defined.
02:41:18 <dyl> > testf fuckingChrist 1 2 3 4
02:41:20 <lambdabot>  error:
02:41:20 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M310424128593...
02:41:20 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
02:41:25 <dyl> ..........
02:41:48 <mupf> maphael_schumape: what exactly is cabal?
02:42:13 <dyl> cabal is a means of installing GHC packages
02:42:51 <dyl> The point is, maphael_schumape, this can be written in a decently obvious way
02:43:00 <dyl> Our bot is just being tricky
02:43:00 <maphael_schumape> mupf you could do pacman -S ghc
02:43:10 <mupf> maphael_schumape: thanks I check it out
02:43:14 <dyl> Cabal isn’t a part of ghc
02:43:24 <dyl> Look for cabal or cabal-install
02:43:28 <mupf> as far as i remember, haskell packackes were quite broken
02:43:33 <mupf> in the official repository
02:44:15 <dyl> Don’t install Haskell packages via your system package manager.
02:44:29 <dyl> The idea that that’s a good idea is an anti pattern.
02:44:29 <maphael_schumape> oh okay ignore what i said
02:44:45 <dyl> Unfortunately perpetuated by Perl and Python
02:45:06 <mupf> Hrm, cabal-install seems to have alot of dependencies.
02:45:10 <mupf> haskell packages
02:45:30 <dyl> It does have a lot of Haskell dependencies.
02:45:42 <dyl> Can you get a binary distribution?
02:45:56 <dyl> Or are you on a source only package management system?
02:46:38 <mupf> most packages should be  binary
02:46:53 <mupf> ah installation worked fine
02:47:04 <dyl> 👍
02:47:24 <dyl> GHC has a package system called usually ghc-pkg
02:47:33 <dyl> But it doesn’t handle getting the packages
02:47:50 <dyl> It’s kind of like Python easy_install
02:47:55 <mupf> any tutorial i could read up for cabal?
02:47:56 <mupf> and getting started with it
02:48:04 <dyl> And cabal is like pip
02:48:20 <dyl> You should mostly use it in the scope of individual projects.
02:48:21 <mxf> mupf, that's a common thing, most libraries/programmes have a lot of dependencies. Also, the compiler is quite slow, you really want a fast machine with lots of RAM :/
02:48:41 <dyl> For global installs there is a new and specialized method.
02:48:51 <dyl> But I am not privy or educated in the details.
02:48:58 <dyl> Do keep in mind cabal new-build
02:49:06 <dyl> cabal new-install
02:49:07 <dyl> Etc
02:49:11 <dyl> They are better.
02:49:39 <mxf> mupf, I guess you could go with https://wiki.archlinux.org/index.php/haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
02:50:10 <mupf> thanks
02:50:16 <mxf> mupf, note: I'm not an arch user, but skimming it, it looks sensible
02:50:20 <dyl> You should have also gotten shell completions with your install so
02:50:20 <dyl> try to use the new-* subcommands when poasble.
02:50:20 <dyl> possible*
02:50:38 <dyl> I am drunk and tired. My roommate is telling me to go to bed.
02:50:48 <dyl> I told him I have to help new haskellers.
02:50:52 <dyl> He understands.
02:51:04 <mupf> lol
02:51:05 <maphael_schumape> you are good at explaining things while drunk dyl but if you have to go to bed take care of yourself
02:51:11 <mxf> mupf, the cliff notes: don't use arch's dynamicly linked modules, don't use the haskell-platform. Either use stack or cabal new-*
02:51:21 <mupf> I only have a minute left anyway, but  I will come back to you guys.
02:51:34 <dyl> I am one of those programmers who feels more kinship with artists
02:51:48 <dyl> Self destruction is a part of the process of creation
02:51:57 <mupf> lol
02:52:06 <mupf> I like it in here
02:52:19 <dyl> All I have to work on tomorrow is a Vulkan based rendering engine for molecular modeling.
02:52:21 <dyl> No biggie.
02:52:33 <maphael_schumape> mupf can i ask why haskell-platform is bad as well as system package managers
02:52:35 <dyl> Also this is the best channel on freenode.
02:52:55 <dyl> People here always love to help other people. We don’t gatekeep.
02:53:01 <dyl> That’s why I feel like I have to help
02:53:34 <dyl> This is the only channel on freenode where there truly are no stupid questions.
02:54:02 <dyl> No matter what, if it’s ontopic, someone will at least try to help.
02:54:12 <dyl> This is a place of learning.
02:54:44 <dyl> We’re all noobs here.
02:54:48 <dyl> Just in different ways.
02:55:19 <dyl> Except edwardk. Ed is a wizard.
02:57:46 <mxf> maphael_schumape, updating tends to get complicated in those cases when you have multiple projects and packages version diverge. This is commonly known as "cabal hell", but is mostly avoided nowadays by stack or cabal new-*.
02:58:51 <mxf> maphael_schumape, https://wiki.haskell.org/Cabal/Survival has a bit of background, but tbh the article is quite antiquated
02:59:05 * dyl suggests using the new commands
02:59:21 <dyl> Stack is nice but if you want to play around it’s just one extra layer of abstraction
02:59:37 <dyl> It’s good to learn how cabal works even if it hurts.
02:59:49 <dyl> It’s like losing you Haskell virginity.
03:00:04 <dyl> your*
03:00:45 <dyl> Stack just makes things more confusing for neophytes I think
03:01:27 * dyl has given up and probably  isn’t sleeping tonight.
03:01:50 <mxf> dyl, go sleep, don't drink and IRC :P
03:02:02 <dyl> In the words of Aesop Rock: must not sleep, mis warn others (about mutability)
03:02:08 <dyl> must*
03:02:24 <dyl> Eh, it’s not about the alcohol
03:02:33 <dyl> I slept in until 4PM on Sunday
03:02:53 <dyl> I ended up at someone else’s house last night and she and I were up pretty early.
03:03:03 * hackage int-multimap 0.3.1 - A data structure that associates each Int key with a set of values  http://hackage.haskell.org/package/int-multimap-0.3.1 (OShev)
03:03:12 <dyl> I’ll just go to work early and leave early, hay my 9h in.
03:03:17 <dyl> get*
03:03:18 <mupf> dyl: a very close friend tried to teach me haskell for 5yrs now. guess it's time now.
03:03:28 <mupf> So I will be around. :)
03:03:33 <dyl> mupf: just remember that it’s easier than you think :)
03:03:37 <mupf> and jsut ordered grahams book
03:03:45 <dyl> If something is hard, just forget what you know.
03:04:01 <mupf> Ha! :) you sound like him
03:04:05 <dyl> Haskell isn’t hard at all.
03:04:31 <mupf> Well, I dont really understand haskell code (yet) but it always looks like good example code to me
03:04:33 <dyl> Learning to not think in terms of other languages is what is hard,
03:04:35 <mupf> not real code tough
03:04:39 <dyl> as someone who is trilingual...
03:04:45 <dyl>  it’s the same.
03:05:01 <dyl> The hard part isn’t learning (say) Spanish
03:05:11 <mupf> got to go, sorry. I come back to you dyl
03:05:13 <dyl> The hard part is learning to think in Spanish when you speak Spanish.
03:05:28 <dyl> mupf: my best regards and best of luck.
03:05:37 <dyl> May the force be with you.
03:05:38 <maphael_schumape> bye thanks for the help dyl. i still haven't cracked it but have stuff to do
03:05:54 <dyl> maphael_schumape: don’t be afraid to PM me or mention me
03:06:01 <dyl> I have a bouncer so I’ll see it.
03:06:10 <dyl> My account is never offline, I just might not be checking it.
03:06:25 <mupf> dyl: can I open up a query too?
03:07:08 <maphael_schumape> okay cool i'll do that dyl
03:07:13 <maphael_schumape> mxf thanks for the article
03:07:18 <dyl> Sure, but I recommend asking in an open channel because many people here know far more than I do,
03:07:32 <dyl> And I’m not an master, just a journeyman,
03:07:36 <dyl> .*
03:07:46 <dyl> a*
03:07:48 <dyl> Christ.
03:07:56 <dyl> I hate phone virtual keyboards.
03:08:06 <dyl> They can’t keep up with 95wpm.
03:08:51 <dyl> Also, re Christ: I’m not a Christian but... JC was a cool bro.
03:09:03 <dyl> Jefferson Bible yo.
03:10:14 <dyl> (Jefferson composed his own version of the Bible for his own purposes which cut out all mention of miracles or divinity and only included Jesus’ deeds as man.)
03:10:37 <dyl> (He never intended it to be published.)
03:11:34 <tdammers> fun fact; Jesus himself apparently never claimed to be divine himself, and most evangelists don't mention anything of the sort either
03:11:49 <kaol> Could you please take it elsewhere?
03:11:49 <dyl> Yeah, it’s sad.
03:11:53 <tdammers> (also, this is absolutely -blah material)
03:12:58 <dyl> I had a very good experience once where I went to a monastery in Greece where no one there had ever left for decades. I spoke with the head priest and told him I was an atheist (of sorts...)
03:13:11 <dyl> and I explained to him my ethics.
03:13:34 * hackage xmlbf 0.4.1 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  http://hackage.haskell.org/package/xmlbf-0.4.1 (RenzoCarbonara)
03:14:27 <[exa]> let's have #haskell-ontopic
03:14:42 <dyl> Any he told me he thought I was closer to Christ’s teachings than most Christians he’d met, and that I shouldn’t feel I need to be Christian to live by that.
03:14:48 <dyl> It was formative.
03:14:54 <dyl> But yeah, no more.
03:15:05 <dyl> It’s now 6AM EST.
03:15:17 <dyl> People are waking up.
03:16:38 <dyl> Last thing: This was someone who had lived in a monastery for 50 years focusing on his religious devotion with little to no contact with the outside world, so I took it seriously.
03:22:36 <world> I have data type like , `data mydataType = A {r:R} | B {r:R} | C {r:R} how do I check mydataType is A,B or C?
03:23:24 <cocreature> world: pattern matching
03:23:58 <world> cocreature : yeh I tried but can I do in single function?
03:24:42 <cocreature> world: not sure what you mean by that. why does pattern matching require multiple functions?
03:26:04 <world> cocreature : I have to write separate functions for A B and C?
03:27:51 <tdammers> case mydataValue of { A r -> ...; B r -> ...; C r -> ... } -- no need for separate functions
03:27:57 <cocreature> world: ah so you’re looking for something like "isA :: MyDataType -> Bool"?
03:29:05 <world> cocreature: i need somthing like (getType input) that return A B or C
03:29:45 <cocreature> world: you could change your type to something like "data Tag = A | B | C; data MyDataType = MyDataType {tag :: Tag, r :: R}"
03:30:16 <world> cocreature: cool
03:30:20 <world> cocreature: thanks
03:30:54 <tdammers> yeah, that's pretty much it
03:31:26 <felko> Is there a category-theoretical analogue of Functor for types of kind (* -> *) -> * ? Something that looks like this: `class Functor2 (f2 :: (* -> *) -> *) where fmap2 :: (forall a. f a -> g a) -> f2 f -> f2 g`
03:31:32 <tdammers> A, B and C in your first approach aren't really properly first-class - you can pattern-match on them, and you can use them as constructor functions, but you can't do things like equality comparisons on them
03:33:00 <world> cocreature: I have some function `f  :: Control.Monad.IO.Class.MonadIO m => input-> m output`, how do I check if output == (getType input) where (getType input) returns type is `output`
03:34:03 * hackage hspec-golden-aeson 0.7.0.0 - Use tests to monitor changes in Aeson serialization  http://hackage.haskell.org/package/hspec-golden-aeson-0.7.0.0 (scottfleischmanplow)
03:34:18 <cocreature> world: I think you’re confusing variable names and types here. are "input" and "output" types or variable names (or both but in that point things will be less confusing if you choose different names)
03:35:38 <world> cocreature : ok, one function return type is `m MyType` that I need to check if it is of something type `MyType`
03:36:00 <world> cocreature : I mean its value
03:37:01 <cocreature> world: it sounds like your problem is “given "f :: a -> b" and "x :: f a", how can I get "f b"” to which the answer is “use fmap”
03:38:39 <world> cocreature :  ok, let's say  `a :: m Type; a = 1`,  `b ::  Type; b = 1` then how do I check if a == b ? (I am noob in haskell)
03:39:08 <cocreature> world: fmap (== b) a
03:39:27 <cocreature> although a is probably something more like "a = pure 1" rather than "a = 1"
03:39:56 <world> cocreature : here m is MonadIO
03:40:51 <cocreature> doesn’t really change anything I said :)
03:54:17 <world> cocreature : fmap (== b) a does this thing is boolean type?
03:54:40 <cocreature> world: no it will be of type MonadIO m => m Bool
03:55:11 <world> cocreature : so how to I appy if condition to it?
03:55:20 <cocreature> world: if you don’t understand why it doesn’t make sense to get something of type Bool, I recommend monochrome’s excellent IO tutorial https://www.vex.net/~trebla/haskell/IO.xhtml
03:56:09 <fatahland> can i print a char to terminal, then down a line and print another char under and then move up to the first line but to the next place after the printed char and print there something?
03:56:32 <fatahland> **
03:56:33 <fatahland> *
03:56:39 <fatahland> something like that ^
03:57:07 <Rembane> fatahland: Yes, but you need a terminal library. Or... it becomes much easier if you have one.
03:57:48 <fatahland> is there such a library?
03:58:21 <ph88> hi cocreature
03:58:23 <Rembane> fatahland: This looks promising: https://hackage.haskell.org/package/ansi-terminal
04:00:16 <fatahland> thanks Rembane. i have an exercise (http://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf) (look at exercise 3). i dont think the meant that i will use this library. is there a different aproach you can think of?
04:02:12 <cocreature> ph88: hm?
04:02:30 <Rembane> fatahland: Well, you can calculate the height of each bar of the histogram first, then do some transformation that makes them look good on the screen and then print them.
04:02:46 <ph88> cocreature, you remember i had problems with newer ghc version being slow ?
04:02:50 <Rembane> fatahland: and you need to print a line at a time.
04:03:05 <Rembane> fatahland: Do you know what a transpose is?
04:03:18 <fatahland> no Rembane
04:03:30 <cocreature> ph88: yep, looked like the bug was found when I last checked the issue
04:03:38 <cocreature> found and fixed :)
04:03:41 <fatahland> is this standard library? they want me to use standrad libraries.
04:03:44 <ph88> yes spj fixed it and used my program as testcase lol :p
04:04:06 <Rembane> fatahland: It's a way to turn the rows of a matrix into the columns of a matrix. Check out Data.List. :)
04:04:20 <fatahland> OK thanks ramatevish
04:04:22 <Rembane> > transpose [[1,2,3], [4,5,6], [7,8,9]]
04:04:24 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
04:04:32 <fatahland> sorry, Rembane
04:04:33 <Rembane> fatahland: No worries.
04:04:46 <fatahland> :-)
04:11:38 <cocreature> ph88: taking the time to isolate bugs to minimal examples is annoying but it’s really satisfying when it leads to your bug being fixed :)
04:28:24 <Putonlalla> What would be a good practical example of the benefits of Haskell's abstractions for a novice?
04:28:41 <Putonlalla> My first thought was parser combinators, but I'm not so sure.
04:29:20 <hpc> that's a good one
04:30:20 <hpc> MVar and the other concurrency primitives are excellent too
04:31:19 <cocreature> MVar is more of a black box rather than an abstraction that you can dissect and understand
04:31:20 <hpc> but MVar in particular, it's crazy easy to understand
04:31:23 <ph88> cocreature, yes i was in some uncertainty at first if and also it looked overwhelming but since i had no other option i just bit the bullet
04:31:58 <Putonlalla> Ah, `async` is a good one too.
04:38:40 <Putonlalla> Now I just need to find some articles that discuss them at an accessible level.
04:39:42 <Ariakenom> Putonlalla: STM - The lack of side effects is great there
04:40:11 <hpc> oh yeah, STM is a good one
04:40:25 <hpc> a lot of languages say they have it, but haskell was first and best
04:40:33 * hackage lucid-extras 0.1.0.1 - Generate more HTML with Lucid  http://hackage.haskell.org/package/lucid-extras-0.1.0.1 (glutamate)
04:40:42 <Ariakenom> stops you from (atomically (atomically x)) which you could think would work in an impure language
04:41:55 <Ariakenom> better example   atomically $ atomically x >> y
04:48:46 <Putonlalla> The example doesn't even have to be super amazing since the competition is so modest. Consider paragraph 6.5.2.3.5 from N1570 (the C11 standard draft). "Accessing a member of an atomic structure or union object results in undefined behavior." There are no conditions; it's just undefined.
05:24:35 <iron_houzi> I've lifted this code from a Monadic Parser document co authered by Eric Meijer: https://gist.github.com/ironhouzi/ecd2d8b731fb4870c5290e32c5653c93 -- Why are `result`, `zero` and `item` defined using lambdas?? Couldn't the functions be defined without lambdas??
05:26:24 <cocreature> iron_houzi: probably so that everything that belongs to the "Parser a" type is right of the equal sign
05:26:30 <cocreature> it’s just as stylistic thing
05:26:57 <iron_houzi> OK, I don't understand the style, but thanks cocreature.
05:27:11 <cocreature> iron_houzi: what exactly do you not understand?
05:27:20 <iron_houzi> The benefit of the style
05:27:44 <iron_houzi> ..but I don't need to understand it either.. just curious you know
05:27:53 <cocreature> it might be surprising to see something of type "a -> Parser a" that takes two arguments
05:28:17 <cocreature> so by moving one argument to the right of the equal sign you make it easier to see that it’s probably part of the "Parser a" thing
05:36:52 <Cale> Also, if you were to replace the definition of Parser with a newtype (rather than a type synonym), the lambdas would occur as arguments to the newtype's data constructor
05:37:05 <Cale> So it sort of prepares for that eventual change as well
05:44:43 * Ariakenom chants the ancient memorized texts ... yagni
05:45:51 <AWizzArd> Let’s say I am running several computations via async. Haskell’s runtime will probably ensure that all are handled in a fair way and that my app stays responsive. Now something comes in and I want to priotize it. It’s very important to favor this. Is there a way to do/express this in Haskell?
05:48:58 <[exa]> AWizzArd: that's sometimes complicated even with bare pthreads
05:50:03 <barrucadu> AWizzArd: haskell threads have no notion of priority, so you'd have to roll your own thing
05:50:24 <[exa]> (also, a quick search through RTS's Schedule.c doesn't reveal anything priority-related)
05:51:30 <Ariakenom> I did bumb into this ticket recently https://ghc.haskell.org/trac/ghc/ticket/7606
05:51:36 <Ariakenom> about priority
05:51:47 <[exa]> Maybe you can block the other threads off (with some kind of mutex) until the prioritized thing is done?
05:58:04 <Ariakenom> I would personally prefer being able to allocate resources over priorities. But I don't think you can keep threads away from a capability without binding all
06:06:22 <oo_miguel> I do not understand why the instance of STM in the MonadPlus is: retry
06:06:39 <oo_miguel> why: mzero = retry
06:06:49 <Cale> because  retry `orElse` x = x
06:06:56 <Cale> and x `orElse` retry = x
06:07:21 <oo_miguel> Cale: ok I was not aware of that
06:07:23 <oo_miguel> thank you
06:07:54 <Cale> Well, in general, that's the thing that mzero ought to satisfy with respect to mplus
06:09:45 <orion_> In Javascript (Node.js specifically) I have to use Promises for blocking operations. Are Promises mathematically similar in any way to ContT?
06:11:30 <phadej> orion: mathematically they are more similar to `async`
06:12:05 <orion> Could you help me understand why?
06:12:18 <phadej> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.8039&rep=rep1&type=pdf
06:12:35 <orion> "The URL does not match any resource in our repository."
06:12:49 <phadej> gmm
06:13:07 <orion> OH, strange.
06:13:13 <orion> It loaded now. Must have been a transient error.
06:13:26 <edwardk> orion: you can think of them in terms of like ContT () IO
06:13:36 <orion> Hi edwardk!
06:13:45 <orion> edwardk: "them" = Promises?
06:14:18 <edwardk> as you want to capture the current continuation for call backs and stuff in the javascript world
06:15:28 <phadej> (implementations forbit fullfilling promises more than once, so I guess they are a little weaker than ContT () IO)
06:15:57 <edwardk> its not quite exact though as you also have a failure continuation, etc
06:15:57 <AWizzArd> With `timeout` I can have threads cancel themselves. Is there a way to „freeze” running threads, i.e. stop them and continue them a few seconds later?
06:16:22 <phadej> AWizzArd: threadDelay
06:17:32 <orion> edwardk: I've read about MonadBaseControl, and how some Monads can't be represented because they have multiple "exit points". When you said, "failure continuation", is that similar to an "exit point"?
06:17:33 <AWizzArd> phadej: threadDelay works on the current thread. I want to delay another one.
06:17:44 <AWizzArd> As if this other thread just happened to run into a threadDelay.
06:19:31 <edwardk> i have no idea whether you could shoehorn this into MonadBaseControl because you might be able to smash them together using Either at all of the steps of the way.
06:23:23 <Cale> The thing that MonadBaseControl does for you is neither difficult nor trivial, but MonadBaseControl makes it easier to get it wrong.
07:02:51 <dmwit> I can make sure only the bottom few bits of an Integer are set with something like `fitInSize w n = mod n (2^w)`. Is there a cheaper way?
07:04:28 <Ariakenom> dmwit: you can replace the mod with .&. (bitwise and)
07:05:13 <habolabo_> hmm. is there a simple pointer for getting the idea of "data (SomeClass a) => D a = D [a]" into a heterogeneous list?
07:06:36 <dmwit> Ariakenom: Cool. So something like `n .&. (bit w - 1)`.
07:07:05 <dmwit> I guess this assumes `n>=0`, but I think I'm okay with that.
07:08:03 <Ariakenom> dmwit: Looks good. I'd think it behaves as (for me) expected for negative
07:08:47 <dmwit> Ah, so it does.
07:09:12 <Ariakenom> negative Integers just have trailing ones :)
07:09:45 <dmwit> ?google existential antipattern
07:09:46 <lambdabot> https://medium.com/@jonathangfischoff/existential-quantification-patterns-and-antipatterns-3b7b683b7d71
07:10:11 <dmwit> habolabo_: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ is the one I wanted
07:10:18 <Ariakenom> so (x .&. -1) = X
07:10:37 <habolabo_> thanks, let me check that out
07:11:51 <Ariakenom> and x .|. -1 = -1
07:12:36 <AWizzArd> There is an action `killThread :: ThreadId -> IO ()`. Is there also something like this for „delayThreadExecution”, which takes the ThreadId of the thread in question that I want to pause?
07:12:44 <Ariakenom> It's mathematically elegant and symmetrical
07:14:21 <dmwit> AWizzArd: No, but there's `threadDelay`. Use other means for communicating to a thread that it should call that.
07:15:29 <AWizzArd> dmwit: yes okay.
07:18:35 <orion> edwardk: I wasn't asking about an instantiation of MonadBaseControl. I am trying to discover whether a Promise's "then/fail" functions/handlers are at all similar to the phrase "multiple exit points" as used in the Haskell community.
07:21:33 * hackage texmath 0.11.0.1 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.11.0.1 (JohnMacFarlane)
07:45:17 <ph88> is there a way to print out the quickcheck generated testcase before the test is run? My program is stuck in a loop and i don't know with which input
07:46:57 <Ariakenom> > trace "abc" 3
07:46:59 <lambdabot>  error:
07:46:59 <lambdabot>      Variable not in scope: trace :: [Char] -> Integer -> t
07:47:03 <byorgey> ph88: add a call to 'traceShowId' to the property, perhaps?
07:47:58 <ph88> the property ?
07:48:09 <ph88> oh the function that is used for the test ?
07:48:12 <byorgey> right
07:48:53 <byorgey> prop_test_the_thing arg1 arg2 = traceShowId (arg1,arg2) $ thing1 == thing2 ...
07:49:39 <ph88> you have 2 args ? i only have one
07:51:34 <byorgey> ph88: it was just an example.  A quickcheck property could have any number of args
07:52:43 <byorgey> I used to use the bin-package-db package to programmatically access info about the package database.  Does anyone know where that functionality went?  bin-package-db seems to no longer exist.
07:53:01 <dmwit> ph88: I bet using byorgey's tools for writing good Arbitrary instances will fix your loop. =P
07:53:27 <ph88> what tools ?
07:53:53 <ph88> the loop is not in the arbitrary generation i think
07:53:56 <dmwit> Actually Lysxia wrote the tool, but byorgey brought awareness to it.
07:54:00 <dmwit> https://github.com/Lysxia/boltzmann-samplers
07:54:13 <dmwit> (it=the technique)
07:54:50 * byorgey kind of doubts that will fix the loop
07:55:50 <ph88> byorgey, i'm not sure how to place the trace ..  https://bpaste.net/show/a26c405d6570
07:56:08 <ph88> parser_prop :: (Eq a, Data a, PrettyPrint a) => Parser a -> a -> Bool
07:57:22 <dmwit> byorgey: http://hackage.haskell.org/package/ghc-8.4.1/docs/Packages.html looks relevant
07:58:53 <dmwit> I find it a bit surprising that Hackage doesn't list bin-package-db any more. I had to look on Stackage to see it. I wonder what's up with that.
07:59:38 <byorgey> ph88: where did you import trace from?
08:00:02 <byorgey> dmwit: ah, thanks, so it does.
08:00:10 <ph88> that's a good question o_O
08:00:15 <byorgey> dmwit: I don't think it's ever been on Hackage.  It came bundled as a core package with GHC.
08:01:32 <ph88> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
08:01:41 <byorgey> The reasoning is probably that stuff on Hackage is supposed to be able at least in theory to be used/compiled by any Haskell compiler.  bin-package-db was always GHC-specific.
08:01:46 <ph88> removed since 8.0.1
08:01:50 <Gurkenglas_> Is there a better "i -> Traversal s t a b -> IndexedTraversal i s t a b" than "\i -> reindexed (const i) . indexing"?
08:02:24 <byorgey> ph88: thanks, good find!
08:02:34 <byorgey> ph88: also, you should be importing trace from  Debug.Trace
08:03:04 <ph88> yes i figured that out by now xD
08:05:15 <Gurkenglas_> Is there a tool that I can give something like "f a -> f b -> f (a, b)" and it would give me a list of functions implemented by any library among which would include those of type "IndexedLens' i s a -> IndexedLens' i s b -> IndexedLens' i s (a, b)"?
08:05:51 <ph88> byorgey, it doesn't work that well  .. i get:    AST IN:s)
08:05:58 <ph88> i don't know what is   s)
08:05:59 <ph88> strange
08:08:06 <Gurkenglas_> Given a record declaration with TH lenses into two fields of the same type, how do I combine them into a traversal?
08:08:26 <Lears> Is there a good structure/library for partial, "all that match this" lookups? E.g. you can do something like `data Map2 k1 k2 a = Map2 (Map k1 (Map k2 a)) (Map k2 (Map k1 a))`.
08:13:01 <cocreature> Lears: can you be a bit more specific? is there a fixed number of tag types (k1 and k2 in your example) and each datapoint is associated with at most one tag of each type?
08:13:11 <cocreature> what do the queries look like that you want to answer?
08:13:15 <byorgey> Gurkenglas_: you can't, because there is no guarantee that their targets are disjoint.  However, see lensProduct from Control.Lens.Unsound perhaps?
08:14:51 <Gurkenglas_> Lears, looking through google results on 'hackage multidimensional indix database', https://hackage.haskell.org/package/data-store seems to do what you want
08:15:32 <Gurkenglas_> byorgey, lensProduct does match the example query from the first question, but the question was for a tool
08:16:07 <cocreature> Gurkenglas_: lensProduct + both answers your last question
08:16:37 <Gurkenglas_> Oh! Of course.
08:17:03 <ph88> do you guys ever compile because it's nice to see your program compiling? :p
08:17:38 <infinisil> ph88: I spent hours just watching the stdout of compilations, it's beautiful
08:17:40 <Gurkenglas> Get a grip on your reward center :v
08:19:18 <infinisil> Excuse me, I need to whine a bit:
08:19:31 <infinisil> I need to write a compiler for an assignment for university
08:19:39 <infinisil> Which is interesting
08:19:41 <ph88> nice !
08:19:47 <infinisil> However
08:19:52 <infinisil> We need to use Java..
08:20:21 <infinisil> It's horrible, it's truly horrible
08:20:31 <cocreature> infinisil: it’s a challenge!
08:20:38 <Lears> Looks promising, Gurkenglas_. The docs look to be broken right now though, so it's hard to say with much certainty. cocreature: The basic idea is just keys that factor and wanting to get all results matching some part of the key. Fixed number of tag types is fine if the number includes 2 and 3, but target values could match multiple keys.
08:20:44 <infinisil> Knowing Haskell and how good it would fit compiler writing makes it even more horrible
08:20:48 <Gurkenglas> write a haskell compiler in java, then the assignment compiler in haskell
08:21:18 <Gurkenglas> Lears, see the documentation for a few versions back
08:21:31 <cocreature> that data-store package was last updated in 2013 …
08:21:50 <infinisil> Gurkenglas: Well I could just ship a ghc binary with the code and use that, everything is IO () in java anyways, so that wouldn't even be a problem :)
08:22:22 <Gurkenglas> (You know what would be nice? A generated .exe downloadable from each hackage page with unbuilt docs which builds (and uploads? security?) the docs)
08:22:47 <infinisil> But seriously, the amount of casting, cringy ast representations, random mutations, subclassing makes it painful
08:23:04 <cocreature> we should just stop with the silly idea that docs should be generated by hackage and get cabal and stack to upload docs automatically
08:24:13 <infinisil> </rant>
08:26:32 <ph88> infinisil, can you run something else on the jvm ?
08:27:15 <ph88> you can call it from java i think
08:27:29 <infinisil> It's an automated test system on their servers, I commit my source code via svn (barf), then they compile it and run the tests
08:29:03 <ph88> well which languages are installed on the servers ?
08:29:05 <ph88> only java ?
08:29:14 <infinisil> I'd think so
08:29:21 <infinisil> Eh it's not worth trying to cheat the system
08:29:50 <infinisil> Oh also what's great is that the tests are only run every hour at :00, so if you commit at :01 you have to wait an hour for the tests to run
08:30:12 <infinisil> And they take 30 minutes to run, so you get the results 1:30 hours later
08:30:46 <infinisil> And the only result you get is... A score! Nothing else, no logs. You do get the error message when it crashes I think
08:31:35 <infinisil> And they have about 400 secret tests we have no idea about
08:33:57 <Gurkenglas> You could crash with a message containing a test that you can tell won't go well
08:34:34 <infinisil> Heh yeah, I think some friends said they use this as a workaround
08:35:05 <Gurkenglas> Does the administration endorse this?
08:35:23 <infinisil> Haven't heard anything from them@
08:35:42 <Gurkenglas> Are all submissions tested in parallel? It seems like 30 minutes is a weird constant
08:36:33 <infinisil> All tested in parallel, starting at :00, only when all finished the results are published, which takes roughly 30 minutes
08:36:40 <byorgey> just make a submission which crashes with a message containing all the secret tests
08:37:32 <infinisil> I also thought of trying to get a remote port forward working to get to look at stuff directly hah
08:38:30 <Gurkenglas> If intero and lens are on stackage, how can my lens fork of lens fail to build intero?
08:38:44 <infinisil> I wouldn't be surprised if they secured it rather poorly
08:39:39 <ph88> i have two strings, i want to compare them line by line. If they are the same print in white. If they are different print in blue and red. Should i use a zip function for combining the lines ?
08:40:39 <Gurkenglas> ph88, zipWith, yes. Why do you think you need to ask that?
08:41:18 <ph88> i don't use zip much
08:41:29 <Gurkenglas> (or zipWithM for direct printing instead of annotating the lines with a piece of data representing color)
08:41:30 <ph88> what if the lines are unequal
08:41:37 <ph88> or maybe i'm better off using a diff package
08:41:58 <infinisil> > zipWith (\a b -> if a == b then "white" else "blue") (lines "Hello\nthere") (lines "Hello\nyou")
08:42:00 <lambdabot>  ["white","blue"]
08:45:20 <Gurkenglas> https://lpaste.net/5533898982452887552 <- "intero.exe: unrecognised flag: -traditional" ???
08:47:37 <Gurkenglas> Took my lens fork, tried to open a file, got that it failed to build intero because two deps are incompatible, added extra-deps as recommended, ran intero-restart, got this
08:49:59 <infinisil> Oh great, I've been waiting for 50 minutes now for the test results, still not published
08:50:16 <infinisil> I don't get any notification whatsoever, just refreshing the page continuously
08:50:41 <infinisil> I could set up an automated thing that ends up sending a notification though, Hmm..
08:51:28 <infinisil> NOO
08:51:44 <infinisil> It updated, but the fix I made didn't make it work
08:56:58 <ania123_> I do not have haskell related question, but since intelligent people are here and they know technical terminology, I have need the following sentence to be corrected
08:57:01 <ania123_> Recently, high expressive power of the X calculus  has been demonstrated by natural encoding of Y calculus into the X calculus
08:58:02 <ania123_> help?
08:58:40 <nsnc> Lol intelligent people here?
08:59:34 <nsnc> Ehh, I'm sure someone here might be somewhat intelligent enough to help you.
09:00:04 * hackage step-function 0.2 - Staircase functions or piecewise constant functions  http://hackage.haskell.org/package/step-function-0.2 (phadej)
09:00:14 <ania123_> no?
09:00:46 <Gurkenglas> ania123_, how is that sentence in need of correction?
09:01:39 <ania123_> gramatically
09:01:44 <ania123_> in english
09:01:57 <ania123_> formulated more nice way...
09:06:39 <Gurkenglas> for both of those different types of correction, ##English seems like the proper channel for this
09:12:50 <ph88> Gurkenglas, zipWith discards some lines
09:23:13 <agg4000> hi there, does anyone know their way around the Yampa module? I have a question about combining pausing and switching between signal functions
09:30:17 <maphael_shoemapp> im new to haskell and was wondering whether using parallel list comprehensions is a bad thing?
09:30:45 <maphael_shoemapp> since it is an extension i wonder if it is bad practice
09:32:15 <Boomerang> maphael_shoemapp: Extensions are used all the time in Haskell, it is not bad practice to use them. :-) I am not familiar with the parallel list one, so I can't comment about its use in particular.
09:32:56 <byorgey> seems fine.  If it fits your use case nicely, go for it.
09:33:28 <tdammers> AFAIK it's fine to use, though like many things parallel, can produce unexpected results
09:33:41 <monochrom> It depends on the extension. The dichotomy is not "is it an extension or not".
09:34:18 <maphael_shoemapp> tdammers please can you elaborate
09:34:44 <monochrom> The correct dichotomy is "with this extension do I still have a clean semantics or not".
09:37:15 <JuanDaugherty> for some notion of clean. There's one that had to be overcome to have extensions in the 1st place, the thing that would throw a noobie
09:38:26 <maphael_shoemapp> i don't understand what you mean JuanDaugherty do you mean in that it is not clean by deviating from the spec
09:39:00 <monochrom> Sure. My clean means how easy it is to comprehend someone else's code.
09:39:01 <JuanDaugherty> maphael_shoemapp, monochrom will tell you what he means by clean
09:39:16 <JuanDaugherty> it's not a term i use
09:40:20 <maphael_shoemapp> okay thank you so if it is case by case i might as well ask if the use of extensions hurts in this context https://paste.debian.net/1025695/
09:40:31 <maphael_shoemapp> the comment should say polynomial integration
09:41:30 <maphael_shoemapp> i thought to use parallel list comprehensions because if i do it with a comma it puts all the permutations in the resultant list
09:41:35 <tdammers> well, when you parallelize code, the textbook problem is that it's not usually obvious which parts actually benefit from parallelization
09:42:28 <tdammers> this is exactly why we don't have a "sufficiently smart compiler" yet that transparently optimizes your code by parallelizing it in the right places
09:42:44 <JuanDaugherty> so the issue is with expectations about the reality vs the con on "parallel"
09:43:01 <monochrom> tdammers, this is just parallel list comprehension, aka syntax sugar for zip.  This is not parallelization.
09:43:17 <JuanDaugherty> and how hard it is to get to the expectation, viz
09:43:42 <JuanDaugherty> that where possible work will spread across available physical threads
09:43:59 <monochrom> At most the gotcha is what if two lists have different lengths.
09:44:16 <JuanDaugherty> need a bunch of extensions and stuff
09:45:20 <JuanDaugherty> easy to test if you have like 8 or more threads
09:45:44 <maphael_shoemapp> monochrom++
09:45:53 <JuanDaugherty> which is fairly common these days
09:46:26 <JuanDaugherty> at AWS you can get 96 threads for about $6/hr
09:47:11 <maphael_shoemapp> thank you that answers my question everybody; i will keep it in my code
09:47:15 <maphael_shoemapp> take care
09:47:50 <tdammers> monochrom: oh, right, d'oh
09:48:07 <tdammers> ignore everything I said, then
09:56:04 * hackage range-set-list 0.1.3 - Memory efficient sets with ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.1.3 (phadej)
10:20:44 <tabaqui1> can I pass values in the code on compile stage in the similar way as -D ans CPP preprocessor?
10:20:56 <tabaqui1> like x :: Int; x = #OUTSIDE
10:21:04 <tabaqui1> and ghc --pass OUTSIDE=10
10:21:19 <WeSt> hello :)
10:22:40 <tabaqui1> I want to hardcode string (server url) in a code without generating Constants.hs
10:24:32 <WeSt> I´m a haskell beginner. I need someone to help me with simpleHTTP an TagSoup.. Pls :)
10:24:47 <tabaqui1> WeSt: just ask
10:26:33 * hackage kleene 0 - Kleene algebra  http://hackage.haskell.org/package/kleene-0 (phadej)
10:27:02 <pavonia> tabaqui1: You can pass -DOPTION=... to GHC
10:27:22 <WeSt> I get with simpleHTTP a long String. I need do filter out all html elements and format the text from the text of the homepage
10:27:39 <tabaqui1> pavonia: -D affects only C preprocessor, I cannot use it as haskell value
10:28:15 <pavonia> tabaqui1: How would you pass a Haskell value from command line?
10:28:28 <tabaqui1> pavonia: dunno, here am I asking
10:29:02 <tabaqui1> usually, I generate Constans.hs and run plain ghc
10:29:12 <tabaqui1> but it's an ugly solution
10:29:13 <pavonia> I don't understand the concept. In what case wouldn't -D work for your purpose?
10:29:28 <tabaqui1> look, I have some constant
10:29:41 <tabaqui1> serverUrl :: String; serverUrl = "example.com"
10:29:54 <WeSt_> pls again...the site quit
10:30:44 <tabaqui1> and sometimes I want to use another Url without creating new commit
10:31:31 <tabaqui1> so I have a script that takes one argument (3 actually), fills jinja template with them and run ghc build
10:31:37 <dsal> I'm using Network.Wai.Application.Static in an app.  It's serving up some javascript, but not specifying the content encoding (i.e., misinterpreting utf8).  How do I convince it to do something slightly better?
10:31:41 <WeSt_> hm.
10:31:45 <phadej> tabaqui1: you can cpp-options: -DOUTSIDE=10 and use "OUTSIDE" in code, just enable {-# LANGUAGE CPP #-}
10:32:31 <pavonia> They don't what to do that, apparently
10:32:37 <dsal> I guess I should do it in my html
10:34:32 <tabaqui1> phadej: oh, it simply works
10:34:43 <tabaqui1> can I pass strings such way?
10:34:50 <phadej> another option is to use TH, $(qRunIO $ readFile "secrets" >>= lift . read)
10:35:03 <tabaqui1> quoted and non-quoted strings aren't valid
10:35:32 <tabaqui1> TH is pretty slow, preprocessor is better
10:35:36 <phadej> tabaqui1: I guess you can, CPP doesn't care much about arguments lexical structure
10:36:10 <phadej> put TH into own module, you won't (re)compile it often
10:36:31 <cocreature> you need to add the quotes in the -D… argument. CPP doesn’t replace things in string literals
10:36:54 <cocreature> and make sure you escape quotes properly if you’re passing it via your shell
10:38:10 <tabaqui1> fine, thanks
10:42:56 <nshepperd> generating Constants.hs sounds like a good solution to me
10:45:04 <nshepperd> except that cabal is a weird build system so i don't know how to do it in that
10:46:38 <sclv> nshepperd: generating in which way? with TH or CPP?
10:46:49 <sclv> either can be done just with flags
10:46:55 <sclv> that specify TH or CPP
10:49:42 <nshepperd> with a script
10:50:56 <nshepperd> putting {-# Language CPP #-} in your Constants.hs and not enabling it elsewhere is another good idea
10:52:22 <nshepperd> then your constants can be typesafe and only produce one error in Constants.hs instead of a bunch of errors everywhere if you pass something malformed on the command line
10:56:10 <Throb-4-U> hi
10:58:56 <shapr> hi Throb-4-U, are you learning Haskell?
10:59:44 <Throb-4-U> hi shapr
10:59:52 <Throb-4-U> it is an interesting language!
11:00:34 <shapr> Throb-4-U: got any questions?
11:01:40 <Throb-4-U> Is haskell good for machine learning, sir?
11:02:23 <shapr> Throb-4-U: I think so, have you seen https://blog.jle.im/entry/purely-functional-typed-models-1.html ?
11:02:38 <shapr> Throb-4-U: there's also tensorflow bindings: https://github.com/tensorflow/haskell
11:04:04 * hackage hdocs 0.5.3.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.5.3.0 (AlexandrRuchkin)
11:24:26 <infinisil> Thinking about switching to ghci or turtle for shell scripting
11:24:45 <infinisil> It's just so much better than bash
11:25:05 <infinisil> The types, the packages, the safety
11:26:38 <jp_rider> Any idea why I'm getting the following? Unsupported extension: DeriveLift
11:26:51 <jp_rider> Docs say it was added in 7.2.1 and I'm running 7.10.3
11:29:02 <Tuplanolla> I don't know, but it's already available in 8.0.2, jp_rider.
11:30:50 <byorgey> jp_rider: and you have e.g.  {-# LANGUAGE DeriveLift #-} at the top of your .hs file?
11:31:27 <jp_rider> yes
11:31:49 <byorgey> jp_rider: is your code something you can share?
11:32:28 <jp_rider> sure. let me commit
11:32:33 * hackage text-region 0.3.1.0 - Marking text regions  http://hackage.haskell.org/package/text-region-0.3.1.0 (AlexandrRuchkin)
11:32:47 <byorgey> jp_rider: what exactly gives you that error?  i.e. are you running some command?
11:33:43 <phadej> DeriveLift is added only in GHC-8.0 https://ghc.haskell.org/trac/ghc/wiki/LanguagePragmaHistory
11:34:05 <jp_rider> https://github.com/jprider63/LMonad-Yesod/blob/c33a828166f225f35778eda0dd3bc950fbba8964/src/Internal.hs#L19
11:34:25 <danilo2_> Hi guys! I've got a very strange situation here. I'm not using any existentials etc - im just using my simple typeclass. What happens here is that when I add superclass contraint `Monad m =>` I get runtime performance drop 20ms -> 3,5s. Its reproducible. Is there ANY reason why superclass constraint can affect performance?
11:34:30 <byorgey> phadej: huh, you're right.  So I guess there is a typo on the GHC users guide that says it was added in 7.2.1
11:34:34 <jp_rider> Ah, I guess these docs are wrong
11:34:35 <jp_rider> https://downloads.haskell.org/~ghc/8.4.1/docs/html/users_guide/glasgow_exts.html#extension-DeriveLift
11:35:33 <byorgey> danilo2_: maybe the extra dictionary passing makes some things no longer inlined?  I really have no idea, I am just guessing
11:36:12 <monochrom> You will need to have the actual code and reproduce on your own computer before you can diagnose anything or test any hypothesis.
11:36:29 <monochrom> But since I am too lazy to do that I decide that I am not the one to ask to see the code.
11:38:36 <AndreasK> danilo2_: Could also fail the specialize with that constraint. But without checking the core output it's all just speculation
11:40:48 <fragamus> hey im confused, I am in ghci and I accidentally defined a function without using let and it didn't give me an error.  did a new feature go into ghci?
11:41:12 <monochrom> Yes. Some time last year or something.
11:41:29 <fragamus> that's bitchen
11:41:48 <zachk> danilo2_, i've heard some monads can introduce quadratic time runs, and that polymorphism can impact performance
11:42:04 * hackage uri-bytestring 0.3.2.0 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.3.2.0 (MichaelXavier)
11:43:15 <monochrom> Great, more speculation and hearsay with zero predictive power.
11:43:30 <zachk> sorry :(
11:44:22 <monochrom> May as well just cut to the mustard and say "the sun may or may not rise tomorrow, but pray to the Flying Spaghetti Monster for it. He may or may not ensure that the sun will rise tomorrow.  If yes, he has listened to your prayer. If not, he's just testing your faith".
11:45:04 * hackage monadIO 0.11.0.0 - Overloading of concurrency variables  http://hackage.haskell.org/package/monadIO-0.11.0.0 (ThomasDuBuisson)
11:45:05 <monochrom> But I guess zero predictive power is great for "community building".
11:47:06 <AndreasK> Somones edgy
12:00:34 * hackage simple-log 0.9.5 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.9.5 (AlexandrRuchkin)
12:03:27 <infinisil> How bad of an idea is it to use Turtle/ghci as your shell and use a library as your "aliases" and other common functions, the init file if you will
12:03:47 <geekosaur> I'm reminded of the old BUGS entry for m4 -e
12:03:54 <infinisil> So the start time should be fast because nothing has to be interpreted
12:04:03 <geekosaur> "it takes a certain state of mind to use this"
12:04:08 <geekosaur> :)
12:04:50 <infinisil> I should really just give it a go, it's just a matter of habit
12:05:08 <infinisil> I bet I could prevent hours of pain by doing this
12:06:34 <drbrule> very basic question here if someone would be so kind. I have a function that takes arguments, the type of which is :: IO ()
12:06:50 <drbrule> I want to run the function from ghci and pass it commands.
12:07:44 <infinisil> drbrule: The type of the arguments are IO ()? What's the type of the whole function?
12:08:00 <drbrule> but when I run the commands it does't work. yes, but it calls another function
12:08:49 <drbrule> I get a Couldn't match expected type ‘(() -> [Char]) -> a’ with actual type ‘IO ()’
12:08:54 <byorgey> drbrule: something of type  IO ()  is not a function.
12:09:17 <cocreature> drbrule: can you show us the code producing that error?
12:09:17 <drbrule> really? weird
12:09:35 <cocreature> functions are things of type "a -> b" for some choice of a and b
12:09:58 <byorgey> drbrule: why is that weird?  Or put another way, why do you think it is a function?
12:10:25 <drbrule> I thought it was a function with no arguments that returns something in IO
12:10:45 <byorgey> drbrule: there's no such thing as a function with no arguments.
12:11:09 <byorgey> drbrule: something of type   IO ()   is simply an IO action.
12:11:31 <byorgey> I agree with cocreature that it would be helpful to see your code.  You can paste it on  lpaste.net .
12:12:27 <danilo2_> zachk: Monads can introduce performance overhead, sure. But this is only a constraint `Monad m`, it is resolved and cannot introduce anything unless imwrong
12:12:44 <drbrule> ah ok
12:13:16 <drbrule> so functions with no arguments don't exist, but can I think of an action as a function with no args?
12:13:52 <monochrom> If your code is wrong, then how you think is also wrong.
12:14:06 <byorgey> drbrule: you can think of it however you like.  But personally I don't see how thinking about things as functions with no args is helpful.
12:14:11 <byorgey> Every function in Haskell takes one argument.
12:14:25 <monochrom> (The scientific empirical criterion for how you judge your mental model.)
12:14:32 <drbrule> ok, I'll need to spend more time reading up on actions at https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions
12:14:53 <drbrule> I unfortunately cannot share the code.
12:15:40 <monochrom> You will also need to be aware that around here "function" is as in math, not as in C.
12:16:24 <drbrule> I figured you could think of it as a function from null set
12:17:03 <cocreature> danilo2_: if specializing fails, you end up passing the dictionary explicitely and you lose other potential improvements that are made after specializing and inlining
12:17:25 <monochrom> But I/O cannot be functions, not even if I'm OK with arity 0.
12:17:58 <monochrom> Because function as in math means the same parameter causes the same answer everything.
12:18:20 <monochrom> And this means for arity-0 functions you pass no parameter and you get the same answer everytime.
12:18:28 <infinisil> monochrom: I think it's confusing drbrule because `main :: IO ()` behaves like `void main()` when you run it, aka a function without arguments
12:18:52 <drbrule> ah ok
12:19:27 <monochrom> infinisil: This is why I reminded about function as in math not C.
12:19:28 <drbrule> thanks for explaining
12:19:48 <infinisil> My explanation is: main defines an action that can do input/output, and it returns nothing, the (). This is nothing but a declaration, it doesn't run anything
12:20:10 <monochrom> Anyway so getChar is disqualified for function because the whole point is to give a different answer every time.
12:21:22 <infinisil> The () in `main :: IO ()` is like the void in `void main()`
12:21:39 <monochrom> So anyway the conclusion is to read my http://www.vex.net/~trebla/haskell/IO.xhtml
12:22:00 <dmwit> I'm having trouble squaring away "I thought it was a function with no arguments" with "I want to run the function and pass it commands".
12:22:12 <dmwit> If you think of it as a function with zero arguments, fine. But then that means you can only pass it up to 0 commands.
12:22:47 <monochrom> Err, wait, someone actually wanted that?!
12:22:56 <drbrule> I think the issue is the code uses Options.Applicative, so I need to dig into that to figure out what is getting passed
12:23:05 <dmwit> monochrom: Those are direct quotes from drbrule in the past 15 minutes.
12:23:34 <monochrom> Options.Applicative uses little or no IO
12:24:04 <cocreature> it does use "getArgs" which is how you’re getting the parameters in this case
12:24:08 <dmwit> It's possible that drbrule will be interested in the difference between `main` and `:main` in ghci, or in the IO action `setArgs`.
12:24:12 <danilo2_> cocreature: there are two instances and I use INLINE pragma everywhere here to force inlining. I've inspected core - here is the difference: https://pastebin.com/raw/BeRSNGd3
12:24:18 <dmwit> (`withArgs`? I can never remember which API they settled on)
12:24:50 <drbrule> I'll look up what :main does. I have not used it
12:25:16 <dmwit> `:main foo bar baz` sets the argument list to `["foo", "bar", "baz"]`, then calls `main`.
12:25:34 <drbrule> Yeah that fixed it
12:25:37 <dmwit> (The argument list here is what you will get from `getArgs`.)
12:25:48 <drbrule> Thank you.
12:28:12 <cocreature> danilo2_: the core that you want to look at is the one that calls buildLayersFold to make sure everything is being properly specialized. not the core of the definition of buildLayersFold
12:31:18 <dmwit> (An aside: it would be nice if `:main` also promised to execute `main` on a bound thread. Would make debugging of GUI code in ghci a bit more convenient.)
12:33:29 <monochrom> -fno-ghci-sandbox helps
12:33:55 <dmwit> Thanks, that's a good tip.
12:34:27 <mxf> monochrom, oh, thanks for the tip. When I fuzzed around with sdl I noticed -fobject-code helped for some reason.
12:36:00 <dmwit> What price do I pay when I enable -fno-ghci-sandbox?
12:36:47 <mxf> lol, that sounds like you are about to sacrifice a goat
12:37:30 <dmwit> "sandbox" does not appear on https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html =(
12:37:56 <cocreature> it’s in https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/release-7-0-1.html
12:38:44 <dmwit> I shouldn't have to look at release notes for old compilers to know what flags are available on the latest release.
12:39:25 <monochrom> Perhaps removed in 8.4?  It's present in 8.2.
12:39:32 <cocreature> dmwit: sure, I wasn’t trying to suggest this is adequate documentation but it might still be helpful if you’re interested in figuring out what it does :)
12:39:55 <dmwit> I sort of guessed everything in the one sentence of the release notes just by reading the name of the flag...
12:39:58 <cocreature> ghc --show-options still shows it
12:40:07 <dmwit> It's present in 8.4.
12:40:19 <monochrom> yikes, so where is it?
12:40:51 <dmwit> Undocumented, it seems. =(
12:41:54 <cocreature> “BUT, note that the debugging features (breakpoints, tracing, etc.) need the expression to be running in a separate thread, so debugging is only enabled when using the sandbox.” there is at least a comment that explains why you might want the sandbox
12:42:13 <dmwit> Nice, that's exactly what I was wondering! Where do you see that?
12:42:40 <cocreature> https://github.com/ghc/ghc/blob/af0757de4649ca562a0e9a624ebef155113531ab/libraries/ghci/GHCi/Run.hs#L152
12:43:05 <dmwit> When I used https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/search.html to search for "sandbox" there were no relevant hits.
12:43:22 <dmwit> Oh! Not in the documentation at all, but in the source. Okay, that explains why the search didn't work.
12:44:13 <dmwit> I would bet the comment isn't even right. Probably all that's required is that GLUT be run in a bound thread, not "the main thread".
12:45:04 <dmwit> But yes, very related to my complaints about debugging GUI stuff in ghci. =D
12:46:58 <cocreature> someone™ should make a patch to document this :)
12:47:32 <monochrom> ghci only offers "in main thread" and "in a new thread by forkIO".  So choosing the former is a workaround rather than a good solution.
12:48:22 <monochrom> Although, you want to choose one bound thread and have all GLUT commands run in that. main is a safe choice for that.
12:48:38 <dmwit> forkOS apperas to work fine in ghci here.
12:49:04 <dmwit> (and `forkOS (isCurrentThreadBound >>= print)` prints `True`)
12:50:50 <mxf> since this is somewhat relevant to my interests: Ideally I'd like a bound thread and reload code in the same thread again (because the particular foreign code is not threadsafe (sdl/libx11/opengl))
12:51:51 <mxf> This means either using -fno-ghci-sandbox and not using the debugger or modifying ghci, right?
12:52:12 <dmwit> mxf: Typically you have to hope that either 1. your GUI library of choice offers a thread-safe way to add a synthetic event to the queue; then you handle that event in your main loop or 2. whoever bound your GUI library did an exceptional job of fitting in with GHC's IO manager and you can use the usual MVar stuff.
12:52:41 <dmwit> mxf: To my knowledge, none of the existing libraries do (2). At least gtk2hs and probably others (gtk2hs is just the one I'm most familiar with) do (1).
12:53:13 <dmwit> mxf: See also dmwit.com/gtk2hs which has some in-depth discussion of this problem.
12:53:39 <dmwit> It is a bit specific to gtk2hs, but the basic ideas should translate pretty well to the other frameworks.
12:53:42 <mxf> well sdl2 uses libx11 or libxcb on linux and that's not threadsafe (generating the xid, afair)
12:54:19 <mxf> I'd guess it's the same with gtk2hs?
12:54:26 <mxf> I'll have a look
12:54:30 <mxf> thanks for documenting this
12:55:20 <mxf> and yeah, opengl and tls comes into play, too
12:55:41 <dmwit> yuuuup
12:57:00 <mxf> at least with OpenGL you can switch threads with MakeCurrent…
12:59:30 <zincy> How do I get the state to continously be evaluated? Tried this -   forever $ do     query <- readLn :: IO Query     execStateT (executeQuery query) initialForest
13:01:01 <monochrom> That looks find. Unless I don't know what you think executeQuery means and what executeQuery really means despite what you think.
13:01:08 <monochrom> s/find/fine/
13:01:10 <infinisil> zincy: "continuously be evaluated"?
13:01:28 <jle`> zincy: you might not want forever :: IO a -> IO a... maybe you want forever :: StateT s IO a -> StateT s IO a ?
13:01:34 <infinisil> Ah, just repeat it, nvm
13:01:38 <monochrom> And yeah unless I don't know what you think "continuously evaluated" means and what it really means despite what you think.
13:02:26 <jle`> zincy: if you want the state to propagate between queries, you need to forever the STateT action, not the IO action
13:02:33 <glittershark> Does anyone know of any Haskell bindings to Libpostal? cursory google doesn't turn anything up
13:02:52 <dmwit> zincy: You might like to move the `forever` into the `execStateT`, as in `execStateT (forever $ liftIO readLn >>= executeQuery) initialForest`.
13:03:33 <zincy> Isnt the type of forever an IO?
13:03:40 <dmwit> :t forever
13:03:41 <lambdabot> Applicative f => f a -> f b
13:03:42 <dmwit> Nope!
13:03:55 <dmwit> Or rather... *maybe*!
13:04:04 * hackage taffybar 2.1.0 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-2.1.0 (eyevanmalicesun)
13:05:07 <infinisil> Why is forever in Control.Monad and not Control.Applicative??
13:05:17 <johnw> historical reasons?
13:05:22 <dmwit> forever predates Applicative
13:05:22 <infinisil> Oh right
13:06:06 <monochrom> We need to merge the two into ControlData.ApplicativeMonad
13:06:23 <zincy> How do I run the following inside my main function which returns IO ? I cant lift can I ? execStateT (forever $ liftIO readLn >>= executeQuery) initialForest`
13:06:32 <dmwit> Applicative is probably the most common prey in `base`.
13:06:56 <dmwit> zincy: Why not `main = execStateT (forever $ ...) initialForest`?
13:07:00 <monochrom> That code looks right too.
13:07:20 <monochrom> Perhaps you need real parentheses instead of fake $ ?
13:08:09 <monochrom> Yeah let's see how far we can avoid seeing real code.
13:08:11 <dmwit> :t \q f -> execStateT (forever $ liftIO readLn >>= q) f -- I don't think so, monochrom
13:08:13 <lambdabot> (Read a1, MonadIO m) => (a1 -> StateT s m a2) -> s -> m s
13:08:51 <zincy> real code - https://lpaste.net/2630667717908103168
13:09:24 <zincy> A solution in progress to https://www.hackerrank.com/challenges/merging-communities
13:10:00 <monochrom> See? Your real code looks nothing like your mock code.
13:10:14 <dmwit> I agree with monochrom, as usual.
13:10:19 <cocreature> zincy: you are mixing things of type IO a and StateT [Tree Int] IO a in the same do block in "executeQuery"
13:10:40 <monochrom> In your real code, you have already incorporated readLn into inside executeQuery.  So you just have to add liftIO to the readLn there.
13:10:45 <dmwit> zincy: `query <- liftIO readLn`.
13:11:10 <dmwit> You can drop the type annotation. But if you want to keep it, it has to change to `StateT [Tree Int] IO Query`.
13:11:13 <monochrom> WHY DO PEOPLE LIE?!
13:11:23 <johnw> I'd tell you, but I'd be lying
13:11:29 <monochrom> haha
13:13:29 <zincy> Any ideas -     • Couldn't match expected type ‘StateT [Tree Int] IO a0’                   with actual type ‘IO b0’     • In the first argument of ‘execStateT’, namely ‘(executeQuery)’
13:15:04 <mxf> dmwit, hm, wow, gtk sounds like even less fun than sdl2.
13:15:12 <elvishjerricco> With a cabal file that has a lib and an exe depending on that lib, is it possible to build that exe against a version of that lib that's in a particular package db rather than letting cabal build the lib itself? This is with Setup.hs, not cabal-install.
13:15:29 <elvishjerricco> Ultimately I'm experimenting with per-component Nix derivations, so I need to be able to build exes against the final installed output of the lib, not any local ./dist build.
13:17:58 <monochrom> I haven't tried but I think yes.
13:18:49 <mxf> dmwit, fwiw, i currently use foreign-store via rapid to spin up a bound thread via async and poll events there. No idea if that would help with gtk, just thought that I should maybe mention it.
13:21:12 <zincy> Updated the code but the compiler still isnt happy with the liftIO $ readline  - https://lpaste.net/8314764842028236800
13:22:01 <jle`> zincy: what is the error?
13:22:13 <jle`> the problem is probably the type annotation
13:22:20 <zincy>  src/merging_communities.hs:80:12: error:     • Couldn't match type ‘IO’ with ‘StateT [Tree Int] IO’       Expected type: StateT [Tree Int] IO Query         Actual type: IO Query     • In a stmt of a 'do' block: query <- liftIO $ readLn :: IO Query       In the expression:         do query <- liftIO $ readLn :: IO Query            forest <- get            case query of              (M a b) -> do ...              (Q a) -> d
13:22:45 <jle`> zincy: yeah, the problem is that that do block expects a StateT [Tree Int] (IO Query)
13:22:48 <jle`> on that line
13:22:51 <jle`> but you gave it an `IO Query`
13:23:08 <jle`> according to your type annotation
13:23:20 <jle`> you can either make the type annotation say the thing you actually want
13:23:24 <jle`> or remove it altogether
13:23:30 <jle`> since it doesn't really add anything
13:23:33 <zincy> So in a monad transformer you always return the base monad
13:23:38 <zincy> which in this case is IO Query?
13:23:49 <jle`> what do you mean by 'return', exactly?
13:23:56 <jle`> it's just normal do block rules
13:24:01 <jle`> every line in a do block has to have the same type
13:24:02 <zincy> The last expression in the do block
13:24:11 <jle`> ah no, every line has to be of the same type
13:24:19 <jle`> so if you're using a monad transformer, every line has to be of that same monad transformer
13:24:34 <jle`> zincy: are you perhaps misreading `liftIO $ readLn :: IO Query` as `liftIO (readLn :: IO Query)` ?
13:24:38 <jle`> because those are two different things
13:24:41 <zincy> so lift promotes the base monad to the transformer?
13:24:50 <jle`> the thing you wrote parses as (liftIO readLn :: IO Query)
13:24:59 <jle`> zincy: lift :: m a -> t m a
13:25:22 <zincy> yeah i think i am
13:26:27 <jle`> so you can either write liftIO (readLn :: IO Query)
13:26:37 <jle`> or liftIO $ readLn :: StateT _ IO Query
13:26:41 <jle`> or just `liftIO readLn`
13:26:51 <jle`> the type annotation doesn't really add anything there, so there's no point in even keeping it :)
13:27:11 <zincy> ah ok
13:27:45 <jle`> zincy: as you wroute it, (liftIO readLn :: IO Query) has type IO Query, but every line has to be StateT
13:28:10 <jle`> in (liftIO readLn :: IO Query), liftIO is using its IO instance, liftIO :: IO a -> IO a
13:28:37 <zincy> so the <- is wrapping it in stateT ?
13:29:00 <zincy> ah so it compiles
13:29:08 <jle`> liftIO :: IO a -> StateT s IO a, here
13:29:24 <jle`> it embeds an 'IO a' into a `StateT s IO a`
13:29:29 <zincy> but the each input line isnt updating the previous state only the inital  state everytime
13:29:32 <jle`> or well, it's supposed to be that, if you use it correctly
13:30:32 <jle`> zincy: can you show your fixed code
13:30:35 <zincy> https://lpaste.net/7493909571430252544
13:34:51 <jle`> zincy: you never update your state
13:35:04 <jle`> try using 'put' or something similar
13:35:20 <jle`> 'get' reads the state, but doesn't modify it
13:35:33 <jle`> you need to use 'put' or something similar to update the State of a StateT action
13:35:55 <zincy> It works!
13:36:00 <jle`> :D
13:36:02 <zincy> Thanks so much :D
13:36:06 <zincy> so happy
13:36:20 <zincy> What misunderstanding was holding me back?
13:36:59 <jle`> maybe you expected defining 'newForest' to update the state?
13:37:52 <zincy> I think there were two things - I didn't realise that the IO had to wrap Query and not ()
13:38:16 <zincy> That combined with not realising every  line in a do block need to have the same type
13:39:03 <zincy> How does the forever work in here
13:39:04 <zincy>   execStateT (forever executeQuery) initialForest
13:39:14 <zincy> :t forever
13:39:16 <lambdabot> Applicative f => f a -> f b
13:39:52 <Average-user> Anyone knows an algorithm to change the root of an Rose Tree? From Data.Tree for example
13:40:17 <jle`> you can just use the old tree as the new child?
13:40:30 <jle`> changeRoot tree = Tree newRoot [tree]
13:40:43 <jle`> or you can just pattern match and change it manually
13:41:06 <jle`> changeRoot (Node _ xs) = Node newRoot xs
13:41:20 <zincy> where is newRoot coming from?
13:41:33 <jle`> zincy: look at the definiution of forev er
13:41:39 <jle`> zincy: forever x = x >> x
13:41:43 <jle`> zincy: it just sequences the action with itself
13:41:48 <jle`> er, forever x = x >> forever x
13:41:53 <zincy> ah thanks
13:41:55 <jle`> zincy: newROot is whatever you want the new root to be
13:41:56 <zincy> makes sense
13:42:20 <jle`> so if i wanted to change the root to, say, 5, i would write changeRootToFive (Node _ xs) = Node 5 xs
13:43:24 <jle`> zincy: the 'magic' of forever with StateT is how StateT defines (>>)
13:43:36 <jle`> zincy: it defines (>>) to sequence/propagate changes in state
13:43:49 <zincy> right that makes sense - ad hoc polymorphism
13:44:13 <jle`> s/ad hoc//
13:44:18 <zincy> so for the root change are you just appending the old tree to the list of children
13:44:42 <jle`> in the first method yeah, in the second method i'm changing the root by just replacing it
13:46:11 <zincy> In what case would it make sense to effectively delete the old root?
13:46:17 <zincy> Im confused
13:46:40 <jle`> i'm not sure myself
13:47:19 <zincy> haha it still changes the root which was the original problem
13:47:23 <jle`> maybe for data security
13:48:04 <jle`> if the root label is a user password, you're gonna just wanna replace it with stars ;)
13:48:24 <zincy> hehe
13:49:36 <zincy> if every line in the do block has to be of the same type - how is this permitted inside the StateT -   forest <- get
13:49:54 <zincy> as the type of forest would be [Tree Int] right?
13:50:23 <zincy> Which  is not the same type as StateT [Tree Int] IO Query
13:50:41 <zincy> or
13:50:42 <jle`> get is the line
13:50:48 <jle`> get :: StateT [Tree Int] IO Query
13:50:54 <jle`> er sorry
13:50:58 <zincy> I guess desugaring the do notation would be informative
13:51:00 <jle`> StateT [Tree Int] IO [Tree Int]
13:51:07 <jle`> get :: StateT s m s
13:51:32 <jle`> sory, i didn't quite mean to say that they all hve to have the same type, but that they hvae to be of the same monad
13:52:56 <zincy> I guess in the do block essentially all the return values have to be of the same type but when you bind a variable the result can be of any type
13:53:30 <jle`> all the lines ahve to be of the same monad, but the results can all have different types
13:53:43 <jle`> you can have IO Int, IO (), IO Bool, IO String, etc. all in a do block together
13:54:06 <jle`> as long as they are all IO-something.  but you can't just have a line that's an Either Int Double
13:54:16 <zincy> so a monad transformer is no different
13:54:22 <zincy> its just a monad with a monad inside
13:54:32 <jle`> i don't think to think of it as a monad inside
13:54:36 <jle`> i think of it as a monad function
13:54:42 <jle`> it takes a monad and returns a new monad
13:54:48 <Tuplanolla> Don't think to think, just think.
13:54:59 <jle`> look at the kind of StateT, StateT s :: (* -> *) -> (* -> *)
13:55:10 <jle`> it takes a (* -> *) (a monad) and returns a new (* -> *) (another monad)
13:56:04 <jle`> `StateT s IO` is just your normal monad, just defined in terms of a "higher-order function", in a sense
13:56:26 <zincy> I guess bind only works if you have one monadic context
13:58:09 <EvanR> join :: Think (Think a) -> Think a
13:58:46 <EvanR> zincy: in the type of bind says it all
13:58:50 <EvanR> :t (>>=)
13:58:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:58:56 <EvanR> there is exactly 1 `m'
13:59:03 <EvanR> you cant mix and match
13:59:21 <EvanR> but a and b do not have to match
13:59:47 <zincy> Im confused about how a monad transformer allows you to combine monads
14:00:05 <EvanR> a monad transformer applied to a monad... is a monad, it is the m
14:00:09 <jle`> StateT doesn't really "combine" monads
14:00:11 <zincy> is a mt just a function that takes a monad and returns a monad?
14:00:14 <jle`> it takes a monad, and gives a new monad
14:00:33 <jle`> the new monad might have some enhanced features that the original one didn't have
14:01:08 <zincy> Am I right in saying to use the new features you have to lift?
14:01:14 <monochrom> This is why all confusions are caused by wrong presumptions.
14:01:28 <monochrom> No. The old features.
14:01:31 <jle`> zincy: lift lets you bring in functions from the original monad
14:01:35 <jle`> er, not functions, actions
14:01:41 <jle`> lift :: m a -> StateT s m a
14:01:47 <zincy> The original monad is the base monad right?
14:01:49 <jle`> lift lets you use the original monad's actions in the STateT s monad
14:02:01 <jle`> zincy: it's the monad that was given as the argument to StateT s
14:02:08 <jle`> not necessarily a "base monad", whatever that means
14:02:09 <monochrom> I don't see why the word "base" helps but sure.
14:02:28 <EvanR> base hurts because people call the very bottom of a "monad transformer stack"... the base monad
14:02:37 <monochrom> Humanity is known to waste time on naming the most irrelevant aspects and losing focus.
14:02:40 <zincy> Right so we use the old monads features by promoting it to the new monad with lift?
14:02:56 <monochrom> Perhaps because they just want to write essays not actual code.
14:03:12 <jle`> zincy: MonadTrans and lift is like Functor and fmap
14:03:23 <jle`> zincy: Maybe takes a type and gives it "optional" abilities
14:03:32 <jle`> but you still want to be able to use functions on your original type
14:03:43 <jle`> a 'Maybe Int' is an "optional Int"
14:03:47 <EvanR> if people becoming programmers because they cant write proofs, and people write essays because they cant write code... then where does it end. or is it a cycle
14:03:49 <jle`> but you still want to use Int functions on a Maybe Int
14:04:00 <jle`> that's what fmap :: (Int -> Int) -> (Maybe Int -> Maybe Int) does
14:04:13 <jle`> it lets you use functions on the original type on your Maybe-type
14:04:17 <jle`> to prevent code-reuse
14:04:27 <jle`> imagine having to write a separate function for every time you Maybe a type
14:04:39 <jle`> 'lift' is the same thing; `StateT s` takes a Monad and gives it state abilities
14:04:46 <jle`> but it's useful to use actions of the original monad
14:04:53 <jle`> so we have lift :: m a -> StateT s m a
14:05:04 <jle`> so you can re-use all of the actions you defined in your original monad to work with StateT s m a
14:05:28 <zincy> ah ok
14:05:28 <monochrom> EvanR: It ends with: programmers are more well-paid than religious jobs, so we get all the people who would do great in religions.
14:05:39 <monochrom> Just look at Larry Wall.
14:06:44 <EvanR> that makes the highest paid job polymorphic in who you get
14:06:59 <EvanR> you get someone who would be great in *
14:07:33 <zincy> So what comes after Monad Transformers?
14:07:36 <EvanR> mass murder, cleaning sceptic tanks, ...
14:08:05 <jle`> nothing, you've finished haskell :)
14:08:14 <jle`> congrats!
14:08:24 <zincy> Dont believe you
14:08:26 <zincy> for a second
14:08:28 <zincy> haha
14:08:31 <monochrom> This is not highschool. There is no "calculus 17" after "calculus 16".
14:08:38 <jle`> at least, maybe, you have finished the somewhat linear portion of haskell learning
14:08:44 <EvanR> zincy: https://cdn-images-1.medium.com/max/1600/1*gh9POXppzNAgtncJj17K9w.jpeg
14:08:48 <jle`> everything now on is just, write code
14:08:53 <jle`> look things up as you find the need
14:09:09 <Tuplanolla> You can now begin anew with Coq, zincy.
14:09:23 <zincy> haha
14:09:41 <zincy> Maybe learn to write proofs yes
14:09:45 <fr33domlover> zincy, it's like you're done growing up and figuring out the basics of the world, and now all the possible adventures are just waiting for you to find them :)
14:10:00 <jle`> zincy: you've basically finished the tutorial level
14:10:09 <zincy> 6 months ago I couldn't print a string
14:10:16 <jle`> now time to just write useful programs :)
14:10:23 <zincy> Im glad those days are behind me
14:10:39 <zincy> Although sometime I worry they arent
14:10:45 <fr33domlover> :t print
14:10:46 <lambdabot> Show a => a -> IO ()
14:10:49 <fr33domlover> ^_^
14:11:29 <zincy> EvanR: yes I guess I am also still at the first stage there haha
14:11:39 <EvanR> just do the last stage
14:12:00 <zincy> but when you learn something you want to show everyone
14:12:22 <EvanR> by writing monad tutorials/
14:12:25 <Tuplanolla> You need proofs in your life.
14:12:25 <zincy> like when people interview they ask questions about that thing they cant believe they finally understood last night
14:12:26 <fr33domlover> zincy, for me I've found that nothing at all, no matter how much reading, nothing helped shape my Haskell coding like plain practice, lots of practice writing stuff
14:12:34 <fr33domlover> Months of it
14:13:02 <zincy> do proofs give you that haskell feeling we all love?
14:13:19 <Tuplanolla> No, but you must join the cult anyway.
14:13:26 <mniip> EvanR, print :: (MonadReader a m, Show a, MonadBaseControl IO m) => m ()
14:13:45 <zincy> Tuplanolla : haha
14:14:15 <EvanR> noice
14:15:02 <EvanR> if had a proof that this code generation algorithm i wrote worked... then it would work. but i dont, and it doesnt. QED
14:15:25 <EvanR> thats indicative of something
14:16:04 <JayKobe6k> Is there a function for a -> (a -> b) -> (a, b)
14:16:37 <EvanR> @djinn  a -> (a -> b) -> (a, b)
14:16:37 <lambdabot> f a b = (a, b a)
14:17:06 <EvanR> @pl \a f -> (a, f a)
14:17:06 <lambdabot> liftM2 (.) (,) (flip id)
14:17:09 <JayKobe6k> I was asking if there was something existing :p
14:17:12 <JayKobe6k> I know it's easy to write
14:17:16 <EvanR> (.) (,)
14:17:45 <EvanR> flip id o_O
14:17:52 <EvanR> :t flip id
14:17:54 <lambdabot> b -> (b -> c) -> c
14:18:01 <Tuplanolla> Perhaps in here, JayKobe6k.
14:18:01 <Tuplanolla> @hackage data-aviary
14:18:02 <lambdabot> http://hackage.haskell.org/package/data-aviary
14:18:20 <JayKobe6k> eh, if its not in base, then I'm not interested :p I don't want to pull in an entire lib for one function
14:18:42 <EvanR> but, code reuse... DRY...
14:18:50 <Tuplanolla> These left pad haters, I swear...
14:19:11 <EvanR> you dont want two people int he universe to both write g x f = (x, f x)
14:19:29 <fr33domlover> :t (***) id
14:19:30 <lambdabot> (b' -> c') -> (b, b') -> (b, c')
14:20:11 <glittershark> :t (.).(.)
14:20:12 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
14:20:16 <glittershark> more blackbirds!
14:22:03 <phadej> give the tuple a name, and you'll have a name for the function too.
14:22:28 <phadej> also. https://hackage.haskell.org/package/ghc-justdoit
14:23:51 <monochrom> Oh haha interesting.
14:24:25 <monochrom> What happens if I give it something dumb like f :: Int -> Int?
14:24:27 <fr33domlover> :t flip $ (***) id
14:24:29 <lambdabot> (b, b') -> (b' -> c') -> (b, c')
14:24:43 <fr33domlover> :t flip $ (&&&) id
14:24:44 <lambdabot> b -> (b -> c') -> (b, c')
14:24:53 <fr33domlover> JayKobe6k, another version ^_^
14:24:57 <glittershark> nice fr33domlover
14:25:19 <fr33domlover> :t flip $ (id &&&)
14:25:20 <lambdabot> b -> (b -> c') -> (b, c')
14:25:24 <fr33domlover> :t flip (id &&&)
14:25:25 <lambdabot> b -> (b -> c') -> (b, c')
14:25:26 <glittershark> is delta in base anywhere?
14:25:31 <glittershark> @pl \x -> (x, x)
14:25:31 <lambdabot> join (,)
14:25:34 <glittershark> heh
14:25:36 <monochrom> I think no.
14:26:23 <fr33domlover> pl has a tendency to use class functions in a super confusing way
14:26:37 <monochrom> Yeah.
14:26:46 <monochrom> @type join (,)
14:26:47 <glittershark> I honestly adore how much pl likes `instance Monad ((->) r)`
14:26:48 <lambdabot> b -> (b, b)
14:26:49 <fr33domlover> like Monad and Functor instances that are super non intuitive
14:26:53 <fr33domlover> like for tuples
14:27:12 <glittershark> that `join` is for `(->) r` afaict
14:27:15 <monochrom> @type (,)
14:27:17 <lambdabot> a -> b -> (a, b)
14:27:29 <mniip> glittershark, I use it every so often
14:27:36 <mniip> join, <*>, for functions
14:28:04 <monochrom> Make it a->a->(a,a).  So yeah it's ((->) a) (((->) a) (a,a))
14:28:23 <mniip> itym  ((->) a) (((->) a) ((,) a a))
14:32:28 <dyl> All these -> and , hurt my eyes
14:33:20 <EvanR> and youra joints
14:33:36 <monochrom> You can say you prefer (Func a) ((Func a) (Pair a a))
14:35:06 <dyl> EvanR: was that an adjoint joke?
14:36:06 <EvanR> yes
14:37:01 <dyl> EvanR: What did the forgetful functor do for his stoner friend?
14:37:09 <EvanR> heard this one
14:37:10 <dyl> He left adjoint as a free object.
14:37:16 <dyl> Yes but it’s still pretty satisfying.
14:37:25 <EvanR> whos there
14:37:26 <EvanR> oh
14:37:32 <EvanR> zzz
14:37:49 <dyl> ?
14:47:04 <mniip> EvanR: knock knock
14:50:37 <sssilver> hey guys, I have a loosely related to Haskell question
14:51:02 <sssilver> we have a microservice in Haskell that keeps breaking because the interface with other external things is HTTP
14:51:18 <sssilver> and the HTTP request that we get should be very specifically crafted for us to be able to service it
14:51:45 <sssilver> how can I ensure that the Lua nginx plugins that dispatch these services to us won't break our service?
14:51:51 <sssilver> *these requests to us
15:02:39 <habolabo_> @type <~
15:02:40 <lambdabot> error: parse error on input ‘<~’
15:41:00 <gobby> I'm having a strange issue with GHCi, I have imported a datatype from a package and it complains that its not the same type. It is the same type but it just has the filepath included
15:41:18 <gobby> ``
15:41:22 <gobby> ` Couldn't match type ‘Tx’                      with ‘cardano-sl-core-1.1.1:Pos.Core.Txp.Tx’       NB: ‘cardano-sl-core-1.1.1:Pos.Core.Txp.Tx’             is defined in ‘Pos.Core.Txp’ in package ‘cardano-sl-core-1.1.1’           ‘Tx’ is defined at             /home/jordan/Documents/IOHK/cardano-sl/core/src/Pos/Core/Txp.hs:(183,1)-(187,49)`
15:42:40 <delYsid> Given Goldable f => f a, where a is an arbitrary sum type, is there a simple (generic?) way to count how often each constructor appears?
15:43:05 <jle`> delYsid: where is Goldable from?
15:43:22 <c_wraith> gobby, that usually means you have two different versions of the same package (cardano-al
15:43:26 <delYsid> haha :-), typo
15:43:48 <jle`> ah, for what?
15:43:48 <c_wraith> err. cardano-sl-core in this case, installed.
15:43:54 <jle`> it sounds like something from uniplate
15:44:16 <c_wraith> gobby, sounds like you installed a second version of a package that was already installed.
15:44:18 <delYsid> Foldable
15:44:25 <jle`> oh i see
15:44:47 <jle`> you can use a list comprehension, which is lightweight
15:45:07 <jle`> length [ () | Just _ <- toList x ]
15:45:15 <c_wraith> delYsid, I think you can use stuff from Data.Data
15:46:26 * nshepperd . o O (Alchemy f => f -> Gold)
15:46:26 <jle`> yeah, Data.Data works as well, you can do ((== toConstr (Just ()) . toConstr) or something similar
15:46:56 <jle`> length . filter thatFilterTHing
15:47:05 <delYsid> Right now, its probably easier to pattern match my way through this by hand, I was just wondering if there is something for "reflecting?" about data types without actually being concrete.
15:47:23 <jle`> Data.Data gives you toConstr
15:47:27 <jle`> > toConstr (Just ())
15:47:30 <lambdabot>  Just
15:47:34 <jle`> > toConstr (Left ())
15:47:37 <lambdabot>  error:
15:47:37 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘toConstr’
15:47:37 <lambdabot>        prevents the constraint ‘(Data b0)’ from being solved.
15:47:42 <jle`> > toConstr (Left () :: Either () ())
15:47:45 <lambdabot>  Left
15:48:10 <jle`> > map toConstr [Right "hello", Left 4, Right "goodbye"]
15:48:12 <lambdabot>  [Right,Left,Right]
15:48:49 <jle`> and Constr's have an Eq instance so you can compare them for equality
15:49:37 <delYsid> jle`: oh, that is very useful, thanks!
15:50:00 <jle`> it only works if your data type has a Data instance
15:50:37 <jle`> but yeah i'd probably just use pattern matching with list comprehensions, it's generic enough to work on any Foldable instance if you toList them
15:53:22 <gobby> c_wraith: would this be evident in my cabal file?
15:53:51 <delYsid> jle`: well, not having to list every constructor by hand becomes useful pretty fast.
15:54:33 <jle`> you'll still have to specify the constructor y ou need
15:54:44 <jle`> delYsid: you don't need to list every constructor...just the one you want to match on
15:54:51 <jle`> oh sorry i misread
15:54:59 <jle`> you wanted to count all of them
15:55:11 <jle`> yeah, you can just do a frequency map of the map toConstr'd then
15:55:30 <delYsid> yeah, nice one.
15:55:47 <jle`> > M.fromListWith (+) . map ((,1) . toConstr) $ [Right "hello", Left 4, Right "goodbye", Left 9, Left 0, Left 2]
15:55:49 <lambdabot>  error:
15:55:50 <lambdabot>      • Could not deduce (Ord Constr)
15:55:50 <lambdabot>          arising from a use of ‘M.fromListWith’
15:55:54 <jle`> aw, no Ord instance
15:56:02 <c_wraith> gobby, not necessarily. I assume you did something like install all your dependencies, then add a dependency on the new package?
15:56:16 <jle`> @let instance Ord Constr where compare = compare `on` show
15:56:18 <lambdabot>  Defined.
15:56:19 <jle`> > M.fromListWith (+) . map ((,1) . toConstr) $ [Right "hello", Left 4, Right "goodbye", Left 9, Left 0, Left 2]
15:56:21 <lambdabot>  fromList [(Left,4),(Right,2)]
15:56:26 <jle`> oh well
15:58:00 <c_wraith> gobby, I'd try wiping the sandbox for that project and rebuilding it. there are other approaches, but they require being a lot more familiar with cabal
15:58:05 <lyxia> delYsid: I wrote the equivalent of that using Generics instead of Data.Data https://hackage.haskell.org/package/generic-data-0.1.0.0/docs/Generic-Data-Internal-Meta.html#v:conId
15:58:50 <gobby> c_wraith: cheers ill delete the stack-work file
16:09:03 * hackage purescript 0.12.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.12.0 (garyb)
16:13:38 <jle`> yay new purescript version
16:14:02 <paf31_> instance chains landed in this release
16:14:05 <paf31_> very exciting
16:14:24 <gobby> c_wraith: deleting stack work didn't work
16:14:32 <gobby> c_wraith: I still have the same issue
16:17:07 <iqubic> What release of GHC are we on?
16:17:15 <c_wraith> gobby, hmm. I don't know enough about stack to be of much help, then. I can tell you for certain that when ghc starts including package names and versions in types, the problem is that you have multiple packages offering the same types and you're trying to mix them in incompatible ways.
16:17:53 <gobby> c_wraith: fair enough, thanks!
16:23:58 <crestfallen> https://lpaste.net/8863788149243904000      hi this function should return 4,672,540 with totalSuccessful, according to the textbook. I am getting the result 235,644. (see line 75 and 100). any ideas?
16:24:49 <mniip> is lpaste missing CSS or just a redesign...
16:25:28 <mniip> ah, both, both is good
16:25:43 <lyxia> nice indeed
16:26:30 <crestfallen> clueless here. I'm working with an online solution...
16:27:40 <crestfallen> Ive lost track of this exercise.
16:27:43 <lyxia> crestfallen: is this code that was given to you
16:28:12 <crestfallen> the textbook provides the solution as it goes along lyxia
16:29:17 <crestfallen> though the 4 functions at the very bottom were added by someone online going through the book
16:32:15 <lyxia> Try going through the book slowly and check that the code does what the textbook says it does, try some small inputs and see whether the outputs make sense...
16:33:08 <crestfallen> this is too much the book is super dry and doesn't explain much. eg "Modify the final program to produce the nearest solutions if no exact solution is possible". I just have no clue how to even think about that. .. lyxia  well no the textbook says I should have a result in the millions...
16:34:27 <crestfallen> super dry like japanese beer
16:35:08 <crestfallen> lyxia, thanks can't deal with it...
18:32:54 <fresheyeball> DataKinds question
18:33:10 <fresheyeball> if I have data Foo = Bar | Baz
18:33:17 <fresheyeball> is there a way to write a function
18:33:55 <fresheyeball> such that this is an implimentation? `f Bar = Proxy :: Proxy Bar`?
18:34:22 <fresheyeball> ultimately, I want a way to go from the constructor Bar to a Proxy of its promoted type
18:34:57 <geekosaur> data and type level are distinct, so I think not unless you want to play with TH
18:35:03 <geekosaur> er, value and type level
18:35:12 <fresheyeball> so I know I can do it with the Singletons package
18:35:24 <fresheyeball> but I dont want to pull in Singletons just to do it one time, and only in one direction
18:35:46 <fresheyeball> I never totally understood what the singletons quasi-quote really does to make that whole api work
18:37:11 <geekosaur> quasiquotes are more or less a way to do "canned" TH
18:37:39 <geekosaur> so it's relying on TH to be able to look up the same name in both value and type level
18:38:01 <fresheyeball> I see, just not something I can easily write out
18:38:12 <fresheyeball> Thats disappointing
18:38:19 <fresheyeball> atleast we have Singletons though
18:38:20 <geekosaur> well, by hand it can be. if it's short enough, I usually script it
18:38:38 <fresheyeball> well I dont know what to write
18:38:45 <glguy> fresheyeball: If you want to see the generated code using singletons package you can -ddump-splices
18:39:26 <fresheyeball> right right
18:39:34 <fresheyeball> I just wanted to understand conceptually
18:40:18 <fresheyeball> Guess I am runinng -ddump-slices and reverse engineering it
18:44:18 <geekosaur> can probably find the definition of the quasiquoter
18:45:04 * hackage adb 0.1.0.1 - Android Debug Bridge (ADB) protocol  http://hackage.haskell.org/package/adb-0.1.0.1 (StephenBlackheath)
18:46:59 * geekosaur pops singletons haddock… wishes he hadn't
18:49:39 <geekosaur> oh, not a custom quasiquoter, you use a normal Dec quasiquoter with it
18:50:00 <geekosaur> and there'a a decent amount of machinery around it, from the looks of it
18:51:18 <geekosaur> yeh, honestly? use the lib unless it's so short that you can do it by hand (like your example with 2 nullary constructors)
18:52:34 <geekosaur> and use -ddump-splices to see what to do by hand in that case
18:53:55 <glguy> even better is to not use it manually or with the library
19:23:50 <jle`> fresheyeball: `f Bar = Proxy :: Proxy Bar` is already possible in normal haskell
19:23:52 <jle`> fresheyeball: and it compiles
19:24:10 <jle`> @let data Foo = Bar | Baz
19:24:11 <lambdabot>  Defined.
19:24:36 <jle`> :t let f :: a -> Proxy Bar; f _ = Proxy in f
19:24:37 <lambdabot> a -> Proxy 'Bar
19:25:43 <jle`> for what it's worth though, GHC does not link Bar (the value) and 'Bar (the type) in any way; any association between the two has to be done in user-space
19:27:55 <geekosaur> I have to admit I was wondering about why they had asked it that way
19:28:06 <geekosaur> unless they meant automating it somehow, which is where TH comes in
19:47:05 <crestfallen> hi would someone mind critiquing the evaluation order on this function? thanks:   https://ptpb.pw/Xaq_
19:48:19 <crestfallen> I don't like the looks of the first line of evaluation..
19:48:55 <c_wraith> crestfallen: I don't see what *order* has to do with the comment there
19:49:45 <crestfallen> only that the lines represent each recursion.. how would you write that c_wraith ?
19:50:04 <crestfallen> each* line represents each recursion
19:50:12 <c_wraith> I think your base case is off.  I think you need split [] = [[]]
19:50:28 <c_wraith> Oh, that doesn't type check.
19:50:46 <rotaerk> [([],[])] ?
19:51:06 <c_wraith> I'm not really sure what this function is supposed to be doing, but that looks more right
19:51:29 * glguy is inspired with confidence
19:51:33 <rotaerk> lol
19:52:07 <crestfallen> the [_] = [] prevents an infinite recursion, in the context of the whole program .. let me paste
19:52:14 <crestfallen> apparently
19:52:24 <crestfallen> one moment pls
19:52:25 <c_wraith> just make this function right.
19:52:42 <c_wraith> And now I see.  I probably would have named it "splits"
19:53:19 <c_wraith> and yeah, rotaerk nailed the base case
19:54:04 <crestfallen> please see here. very confused. this is a graham hutton book example. see the split function.
19:54:07 <crestfallen> https://ptpb.pw/0SvM
19:56:21 <rotaerk> I guess with (split [1,2,3]), ([1,2,3],[]) isn't considered one of the splits
19:56:34 <rotaerk> err wait, ([], [1,2,3])
19:56:43 <rotaerk> but perhaps it should be
19:57:47 <rotaerk> actually, your split [] seems fine
19:57:57 <crestfallen> its from a book. sorry again I'm green to the gills with this exercise. I need to study it further.
19:58:13 <glguy> crestfallen: What's your question?
19:58:35 <crestfallen> It was re: my evaluation order in comments
19:58:45 <crestfallen> is it correct, how to make it more clear?
19:58:56 <c_wraith> there is no evaluation order in the comments
19:59:23 <crestfallen> very sorry disregard it please
19:59:31 <rotaerk> based on the example output, I would think split [] = []; split [a] = [([a], [])]
19:59:43 <crestfallen> I was attempting to express the evaluation order
19:59:54 <crestfallen> with the arg [1,2,3]
19:59:55 <c_wraith> evaluation order depends on the demand order
20:00:06 <c_wraith> that's sort of Haskell's whole thing
20:00:29 <crestfallen> sorry. peace out. please let me ask again in about an hour...
20:02:31 <c_wraith> Hmmm..  I think it should either produce a [] on both sides or neither side.
20:02:34 <glguy> Well, we're just about to start year 3 of n_blownapart/crucify_me/crestfallen trying to learn Haskell. They do say that third time is a charm
20:02:50 <rotaerk> c_wraith, yeah
20:03:37 <rotaerk> those could be titles for the 3 books in some teen angst trilogy
20:05:02 * Clint smirks.
20:06:41 <rotaerk> we may have been confusing him by critiquing the function itself
20:06:51 <rotaerk> because he was just trying to understand how the function worked
20:07:16 <haskell_noob> i am trying to debug a wss connection my curl request connects but the websockets client is not. How do i find out what headers are being published
20:11:34 <c_wraith> haskell_noob: what portion is in Haskell?
20:11:58 <dyl> His legal name is Haskell Noob. So, he is.
20:12:09 <haskell_noob> c_wraith, the wss client is in haskell. the server is minikube pod.
20:12:17 <dyl> (I jest.)
20:12:34 <dyl> What error do you get if any?
20:13:26 <haskell_noob> https://lpaste.net/8381735713023983616
20:13:40 <haskell_noob> i setup a curl client and that connects just fine.
20:13:58 <haskell_noob> i need to find out if my tls parameters that  i set up are being used or am i lying somewhere.
20:14:35 <haskell_noob> and @dyl, i am noob till i get that darn fmap <$> <**>, -> >>= gets used in a single function :).
20:15:33 <dyl>  400 is bad syntax in the request.
20:15:38 <dyl> Can you show how you’re constructing the request?
20:15:51 <dyl> 400 means that the server doesn’t understand what it’s getting.
20:15:52 <haskell_noob> sure let me paste that real quick.
20:17:15 <haskell_noob> https://lpaste.net/4266588333951418368
20:17:40 <haskell_noob> i can link to the entire file if the context is not sufficient.
20:18:04 * hackage MonadRandom 0.5.1.1 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.5.1.1 (BrentYorgey)
20:18:48 <haskell_noob> how can i print the actual request i am making or the ws client is making, is there a trace call i can enable?
20:20:53 <haskell_noob> @dyl : here is the file : https://github.com/dservgun/haskell/blob/master/kubernetes-exec-helper/src/Kubernetes/WSClient.hs
20:20:53 <lambdabot> Maybe you meant: url pl do
20:27:07 <haskell_noob> <dyl> i will try to check them again.
20:38:34 <dyl> Sorry let me look
20:39:04 <dyl> haskell_noob: its a lot to look through
20:39:17 <dyl> Have you considered running Wireshark locally and looking at what’s sent?
20:39:24 <dyl> It might give you a lead.
20:39:32 <dyl> Filter by the port you’re using and the protocol.
20:39:46 <dyl> If it’s HTTPS you can set up wireshark to MITM.
20:40:14 <dyl> Seeing what’s actually on the wire is probably the most useful approach.
20:41:00 <haskell_noob> how do i do that, <dyl> i tried wireshark..but i kinda need a good intro to using that.
20:45:41 <dyl> Wireshark can be a little intimidating at first.
20:46:03 <dyl> Just start by capturing on your loopback interface (or whichever it is)
20:46:07 <dyl> and then filter by http
20:46:23 <dyl> There’s a handy dandy filter building tool.
20:46:46 <dyl> Looking at and inspecting the requests is worth the time you might have to spend figuring out how to do it.
20:46:57 <dyl> Wireshark is an invaluable tool when you’re dealing with network stuff.
20:47:29 <haskell_noob> perfect..the rookie question is that the server is running locally, so i am looking at lo interface?
20:47:57 <haskell_noob> i was using tcp port 8443? is  that incorrect?
20:49:51 <kandinski> how does one pronounce <*>? and <**>?
20:50:13 <rotaerk> I don't think I usually pronounce operators
20:50:44 <kandinski> I ask because =<< is pronounced 'bind', so I figured maybe <*> has also a name.
20:51:01 <boj> kandinski: i think "apply" and "reverse apply"
20:51:02 <iqubic> <*> is 'ap'
20:51:12 <kandinski> thanks
20:51:24 <iqubic> kandinski: bind is >>= actually.
20:51:55 <kandinski> I was looking at a flipped version here, thanks.
20:52:07 <rotaerk> :t join
20:52:08 <lambdabot> Monad m => m (m a) -> m a
20:52:31 <rotaerk> :t \f -> join . fmap f
20:52:32 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
20:53:28 <iqubic> :t flip \f -> join . fmap f
20:53:29 <lambdabot> error: parse error on input ‘\’
20:53:41 <iqubic> :t flip (\f -> join . fmap f)
20:53:43 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a2
20:53:56 <iqubic> That's bind.
20:54:08 <iqubic> :t flip (join . fmap)
20:54:09 <lambdabot> error:
20:54:10 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ b -> a
20:54:10 <lambdabot>       Expected type: (a -> c) -> b -> b -> c
20:54:23 <jle`> kandinski: in code, it's usually unpronounced
20:54:24 <rotaerk> I'm thinking join, not bind, is the simplest thing to demonstrate monads to someone with
20:54:32 <jle`> kandinski: reading `f <$> x <*> y` is supposed to be like reading `f x y`
20:54:37 <rotaerk> since it's the simplest example of sequencing, and bind is just a mechanism for building something to sequence
20:55:06 <jle`> kandinski: but referring to it individually usually people say "ap"
20:55:23 <jle`> iqubic: i sometimes call (=<<) bind
20:55:47 <jle`> if bind were a named identifier/alias in haskell it would probably be (=<<), not (>>=)
20:55:56 <jle`> just to be similar to fmap/ap
20:56:33 <kandinski> thanks, I was thinking of how to discuss it with people as we learn.
20:57:22 <kandinski> the nicta/data61 course has (=<<) as bind, not the other way around. I realise they are just the flipped version of each other.
20:57:36 <kandinski> from the nicta course:
20:57:36 <kandinski> class Applicative f => Monad f where
20:57:36 <kandinski>   -- Pronounced, bind.
20:57:36 <kandinski>   (=<<) ::
20:57:46 <kandinski> I hope the three line paste is justified
20:57:50 <kandinski> data61 course now
21:00:20 <kandinski> Also in the course, <**> in Monad seems to be the same as <*> in Applicative. Probably the new name is to avoid naming conflicts as we go through the exercises.
21:01:21 <rotaerk> kandinski, <**> is in Applicative
21:01:37 <rotaerk> it's just flip (<*>)
21:03:08 <kandinski> let me check the data61 course repo, in case this is me making a mistake.
21:04:25 <kandinski> Compare https://github.com/data61/fp-course/blob/997775d290517706a2179023fc9cdfd6a1686950/src/Course/Monad.hs#L109 to https://github.com/data61/fp-course/blob/997775d290517706a2179023fc9cdfd6a1686950/src/Course/Applicative.hs#L33
21:05:19 <kandinski> Same signature for <*> and <**> :: f => f(a -> b) -> f a -> f b
21:05:44 <kandinski> Except that Applicative defines <*> and Monad defines <**>
21:06:04 <rotaerk> in the context of your course, use the definitions it gives, but... it looks like it's a bit dated
21:06:20 <rotaerk> in terms of what is standard
21:06:35 <kandinski> it also defines bind as =<< Monad f => (a -> f b) -> f a -> f b
21:07:04 <liamd> any thoughts on debugging a scraper constructed with Scalpel?
21:07:17 <kandinski> rotaerk: thanks, I'll keep it in mind.
21:07:25 <jle`> bind makes sense in parallel to fmap and ap
21:07:32 <jle`> as higher-order "lifting" functions
21:07:38 <jle`> fmap, ap, and bind all lift functions in some way
21:07:40 <rotaerk> kandinski, http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#v:-60--42--42--62-
21:07:44 <jle`> (>>=) does not
21:07:49 <jle`> (at least not directly)
21:08:10 <jle`> fmap ::   (a ->   b) -> m a -> m b
21:08:26 <kandinski> rotaerk: thank you, you realise I was not saying "no you're wrong" but "waitaminute, my course says otherwise"
21:08:26 <jle`>   ap :: m (a ->   b) -> m a -> m b
21:08:35 <rotaerk> kandinski, yes
21:08:42 <jle`> bind ::   (a -> m b) -> m a -> m b
21:08:46 <rotaerk> just pointing you to where the standard one is defined
21:08:51 <jle`> er, i wrote those wrong
21:08:56 <jle`> excuse my spam
21:09:03 <jle`> fmap ::   (a ->   b) -> (m a -> m b)
21:09:09 <jle`>   ap :: m (a ->   b) -> (m a -> m b)
21:09:14 <jle`> bind ::   (a -> m b) -> (m a -> m b)
21:09:25 <jle`> note the common pattern
21:09:34 <kandinski> rotaerk: yeah, it's a bit overwhelming, having to learn the current way but also the slightly older for whatever reason way from the course.
21:09:42 <jle`> they all lift some sort of (a -> b) to (m a -> m b)
21:10:17 <kandinski> jle`: neat, thanks
21:11:40 <iqubic> jle`: What's the old way?
21:12:29 <jle`> the old way?
21:12:33 <mniip> 5/22/2018 [07:08:50] <jle`> bind ::   (a -> m b) -> (m a -> m b)
21:12:36 <mniip> flip bind
21:12:39 <rotaerk> kandinski, IMO abandon the courses once you think you've got a good enough foundation
21:12:50 <rotaerk> then use documentation
21:12:52 <jle`> mniip: the discussion was about whether bind was (>>=) or (=<<)
21:12:54 <kandinski> I'm reading the Haskell Book in parallel
21:12:57 <mniip> o
21:13:06 * mniip goes back to hiding
21:13:22 <kandinski> but at this point I still need the strong framework of one exercise at a time, with tests that someone else wrote.
21:13:48 <iqubic> jle`: Yoou said, "the slightly older, for whatever reason way."
21:14:19 <kandinski> I get that in both >>= and =<< the mnemonic (or 'a' mnemonic) is "push the (monadic) value through the function"
21:14:34 <kandinski> so it's easy to remember the type anyway
21:14:41 <jle`> kandinski: that's cute
21:14:51 <jle`> the way i think of it is that the arrows point in the ordering of effects
21:15:09 <kandinski> well, one gets insights whenever one finds them. What other reason was there for the choice of operator?
21:15:24 <jle`> i always thought of it as indicating the order of effects
21:15:38 <kandinski> yes, arrows indicate ordering when more than one bind is performed in a sequence, correct?
21:15:50 <jle`> even just with one
21:16:01 <jle`> `x >> y` means that the effects of x happen before the effects of y
21:16:23 <jle`> so putStrLn "hello" >> putStrLn "world", prints hello first and then world second
21:16:41 <kandinski> neat
21:16:51 <kandinski> but that's >> not >>=
21:17:00 <jle`> yes, it's the same for >>=
21:17:08 <Lears> % print "first" >>= \_ -> print "second"
21:17:09 <yahb> Lears: "first"; "second"
21:17:10 <jle`> the arrows point in the direction of the order of effects
21:17:32 <rotaerk> kandinski, an arguably more fundamental function (compared to bind) for monads is "join", which takes m (m a) and turns it into an m a
21:17:35 <iqubic> :t (<<)
21:17:36 <lambdabot> error:
21:17:37 <lambdabot>     • Variable not in scope: <<
21:17:37 <lambdabot>     • Perhaps you meant one of these:
21:17:53 <dyl> haskell_noob: probably!
21:17:56 <dyl> Give it a shot
21:18:00 <dyl> Filtering by port is usually yenlugh
21:18:04 <dyl> Enough*
21:18:12 <jle`> my favorite typo of today
21:18:51 <rotaerk> kandinski, if you look at the signature, that is really the basis for monadic sequencing ... you have to "run" the outer m (m a) in order to get the inner m a before you can run *that* one to get the a
21:18:59 <rotaerk> i.e. the signature itself enforces an ordering
21:19:29 <rotaerk> and if you look at how bind can be defined like:
21:19:35 <rotaerk> :t \f -> join . fmap f
21:19:36 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
21:19:55 <kandinski> rotaerk: yeah, it's in the book. However, it's interesting that the minimal complete definition in the haskell docs use >>= and don't call it bind. http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Monad-Instances.html#t:Monad
21:20:08 <rotaerk> what that means is that it's just using a simple map to turn a:  m a into a m (m b), and then using join to sequence the result
21:20:48 <kandinski> yeah, thanks
21:21:03 <kandinski> that is beyond intuition, much appreciated
21:23:39 <jle`> by the way, really sad to hear that mmfreak/ertesx passed away suddenly :(
21:23:48 <rotaerk> really?!
21:24:02 <jle`> when i was learning haskell originally, he was the one who always helped me on #haskell
21:24:13 <rotaerk> :( I hadn't heard
21:24:15 <jle`> my impression of the haskell community as a friendly and patient one was shaped by him
21:24:36 <jle`> https://byorgey.wordpress.com/2018/05/21/ertugrul-soylemez-1985-2018/
21:24:50 <jle`> he always took the time to give detailed explanations to my silliest questions
21:24:58 <jle`> and i still have notebooks of notes from conversations with him
21:25:16 <rotaerk> hmm, born the same year as me
21:26:01 <rotaerk> yea I've talked to him a good bit, myself...
21:26:10 <jle`> he always made #haskell feel like a home for me and everyone who visited while he was a regular here
21:26:18 <boj> oh my, interacted with ertes a lot here :(
21:26:22 <iqubic> This makes me super sad.
21:27:39 <iqubic> I notice that the user name is still being colored for me. Makes me feel like he is still here.
21:28:04 <jle`> :(
21:28:16 <MarcelineVQ> there is an ertes here
21:28:48 <iqubic> RIP :(
21:29:02 <jle`> hm apparently signed on on May 19
21:29:15 <jle`> must be some remote server artifacts
21:29:43 <boj> could be an autoconnecting cloudirc or something
21:30:10 <iqubic> I suppose so. I will miss ertes a lot. He was the one who explained traversals to me i a way that made me finally understand their usefulness.
21:31:48 <iqubic> Why does life have to be so full of sad things?
21:33:10 <geekosaur> I use a bouncer, likely if I keeled over all of a sudden nobody would think of taking it down
21:33:40 <geekosaur> it'd just keep running until the next time someone upgrades the vmm
21:33:50 <boj> "where did that grumpy old man go?" - "oh, just a few day nap, probably"
21:34:45 <kandinski> I'm sorry for your loss, folks.
21:34:52 <sclv> his breakdowns of the various frp approaches were models of clarity
21:35:31 <sclv> and it was very notable that he didn't try to oversell his package -- he just explained where it lay in the design space, and what the tradeoffs were, with honesty
21:37:40 <iqubic> I miss ertes. https://www.xkcd.com/686/
21:39:54 <DaringlyEsoteric> that's deep
21:46:19 <iqubic> As I was climbing the Functor, Applicative, Monad conceptual mountain for the first time a few years ago, ertes was the one who really helped me see the distiction between those three concepts. His explainations were so clear, so concise, and so informative. He was a definate pillar of our community. My condolences to us all.
22:03:30 <iqubic> I'm not sure I want to continue working on my Haskell projects anymore.
22:17:42 <iqubic> To pay ertes a tribute, I'm going to read the guides mentioned in byorgey's blog post. I feel that is the respectable thing to do.
22:18:56 <EvanR> wow ertes was really young
22:21:29 <iqubic> Was he?
22:22:06 <nshepperd> 1985, not much older than me
22:23:23 <nshepperd> sad :(
22:32:41 <iqubic> I love the way that ertes has presented foldr in this blog post: http://ertes.eu/tutorial/foldr.html
22:33:08 <DaringlyEsoteric> we should archive his site before it goes down
22:34:35 <iqubic> We should definately do that.
22:36:24 <DaringlyEsoteric> https://web.archive.org/web/*/http://ertes.eu
22:37:40 <starlord123> let c1 = ["bbbab","bbaa","b","ba","abbb"]
22:37:55 <starlord123> let c2 = ["aba","","b","bbaaa"]
22:38:08 <starlord123> deleteFirstsBy (\x y -> y `isInfixOf` x) c1 c2
22:38:23 <iqubic> Looks like someone archived it after his passing.
22:38:29 <starlord123> result is ["bbbab","ba","abbb"]
22:38:54 <starlord123> can someone please explain why "ba" is in the result?
22:39:02 <jle`> what is deleteFirstsBy ?
22:39:17 <cocreature> jle`: https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#v:deleteFirstsBy
22:39:30 <jle`> whoa
22:39:42 <starlord123> The deleteFirstsBy function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.
22:40:46 <jle`> i can't believe this has been in Data.List this whole time and I have never noticed
22:40:59 <cocreature> heh, I just saw it the first time as well
22:41:23 <starlord123> I used hoogle to find it
22:41:27 <nshepperd> oh, it's the *By form of (\\)
22:41:34 <starlord123> by searching with the signature
22:41:50 <starlord123> using it for the first time too
22:41:51 <jle`> nshepperd: oh i see
22:41:58 <jle`> so \\-by
22:42:18 <nshepperd> exactly
22:42:22 <boj> starlord123: i suppose "b" is in "ba" and satisfied the isInfixOf condition?
22:42:25 <jle`> i wonder what i would have called it. differenceBy?
22:42:48 <EvanR> well, \\ union and intersect dont behave exactly like set
22:42:59 <EvanR> they behave like whateverFirst
22:43:32 <EvanR> > union [1,2,2] [3]
22:43:34 <boj> > "b" `isInfixOf` "ba"
22:43:35 <lambdabot>  [1,2,2,3]
22:43:37 <lambdabot>  True
22:43:41 <EvanR> > union [1,2] [3,3]
22:43:44 <lambdabot>  [1,2,3]
22:43:50 <nshepperd> > intersect [1, 1] [1]
22:43:53 <lambdabot>  [1,1]
22:43:57 <nshepperd> ¯\_(ツ)_/¯
22:44:06 <EvanR> > intersect [1] [1,1]
22:44:06 <starlord123> > "ba" `isInfixOf` "b"
22:44:10 <lambdabot>  [1]
22:44:10 <lambdabot>  False
22:44:19 <nshepperd> it doesn't even behave like a bag...
22:44:26 <starlord123> the order is reversed
22:45:15 <dminuoso> Lets say I have a `Handler` in a catches, how can I choose to only deal with a specific AsyncException? Should I simply pattern match and rethrow?
22:45:29 <EvanR> i think you can understand it terms of operation... intersect includes the first instance of x in the first list it finds in the second list
22:45:45 <nshepperd> starlord123: well, "b" is indeed infix of "ba"
22:46:13 <EvanR> > union [2,2] [3,3]
22:46:15 <lambdabot>  [2,2,3]
22:46:22 <EvanR> for union no idea
22:47:15 <ddellacosta> am I correct that I can define a foldable instance for a type without a monoid instance (but _with_ a semigroup instance) by defining `foldr` only?
22:47:48 <starlord123> nshepperd, my idea is to remove all the elements in the first list c1 which are infxes of atleast one elem in c2
22:48:29 <nshepperd> starlord123: I would use a filter for that, honestly
22:48:30 <bwe> JSON request in via POST, JSON response as output. Which haskell framework/module do you advise me to wrap my Haskell functions into?
22:48:42 <cocreature> starlord123: "aba" deletes "b", "" and "b" don’t delete anything and "bbaaa" removes "bbaa"
22:49:21 <cocreature> starlord123: maybe you want something like "filter (\x -> any (x `isInfixOf`) c2) c1"?
22:50:35 <ddellacosta> actually nothing is preventing me from defining foldMap it looks like. Hmm
22:51:02 <starlord123> cocreature, yes it makes sense now, thanks
22:51:16 <starlord123> cocreature, nshepperd filter is more clear I agree
22:51:34 <dminuoso> Also an unrelated question. When I have `IO ()` that will never finish, should I rather encode it as `forall a. IO a` just to denote the bottom in the type?
22:51:38 <cocreature> ddellacosta: the Monoid constraint is in the type signature of "foldMap" not on the type that you’re defining the instance for
22:51:40 <starlord123> started with this so wanted to understand how it behaves
22:51:59 <nshepperd> the behaviour of deleteFirstsBy with a non-equality predicate seems like an unnecessarily confusing thing to have to deal with
22:52:15 <ddellacosta> cocreature: ah right, I was confused. Thanks!
22:52:26 <nshepperd> > deleteFirstsBy (\a b -> a == 2) [1, 2, 3] [0]
22:52:28 <lambdabot>  [1,2,3]
22:52:33 <nshepperd> > deleteFirstsBy (\a b -> b == 2) [1, 2, 3] [0]
22:52:36 <lambdabot>  [1,3]
22:52:42 <cocreature> the argument order in the function passed to deleteFirstsBy also seems quite confusing
22:52:52 <nshepperd> that the argument order is wrong -_-
22:53:02 <nshepperd> who ordered that!
22:53:34 * hackage basic 0.1.0.0 - Lifting values from base types  http://hackage.haskell.org/package/basic-0.1.0.0 (MatthewFarkasDyck)
22:55:42 <nshepperd> I suppose the author expected that it doesn't matter because people would only ever pass different kinds of 'equality' that are symmetric
22:56:44 <cocreature> why does deleteFirstsBy not have a type like (b -> a -> Bool) -> [a] -> [b] -> [a]? that would at least make the order clear
22:58:14 <nshepperd> hm, you're right. having the type of the function be (a -> a -> Bool) is a totally unnecessary restriction
22:59:15 <cocreature> I’ve gone from “oh neat, a function in Data.List that I didn’t know about” to “please just remove this function from Data.List”
22:59:23 <nshepperd> haha
22:59:28 <boj> haha yeah
23:00:02 <jle`> ddellacosta: some people prefer `IO Void`
23:00:16 <ddellacosta> jle`: I don't follow, I'm sorry
23:00:22 <jle`> ddellacosta: which isn't a RankN type, to avoid problems with impredicative types
23:00:33 <jle`> ddellacosta: `forever :: IO a -> IO Void`
23:00:40 <dminuoso> ddellacosta: I think jle` means me ;)
23:00:47 <jle`> oh sorry, yes :)
23:01:10 <ddellacosta> oh! gotcha, yeah I was thinking this was some crazy type-level magic about foldMap going over my head...haha
23:01:14 <dminuoso> jle`: Ah. `IO Void` feels slightly more expressive :)
23:01:25 <jle`> dminuoso: `IO Void` has the advantage that it can be used as [IO Void], Maybe (IO Void), etc.
23:02:10 <jle`> and it can be converted to your original (forall a. IO a) with `vacuous :: IO Void -> (forall a. IO a)`
23:02:45 <nshepperd> I use 'IO a' for anything that's an output
23:03:10 <starlord123> thank you folks,
23:03:17 <nshepperd> if you want to put it in a list you can just put [forever foo :: IO Void] after all
23:03:39 <starlord123> I will avoid using these esoteric functions
23:03:39 <jle`> yeah, as an output, even `... -> [IO a]` works
23:04:10 <jle`> but `IO Void` is nice as a self-documenting kinda thing
23:05:10 <EvanR> forall a . a is kind of a oblique way to say "no value"
23:05:12 <nshepperd> I don't think 'forever :: forall a b. IO a -> IO b' is any less self-documenting
23:05:19 <EvanR> Void seems more direct
23:05:51 <EvanR> from the perspective of someone who semi-kinda knows haskell
23:06:09 <EvanR> or has heard of a Void type
23:06:39 <jle`> :t forever
23:06:40 <lambdabot> Applicative f => f a -> f b
23:06:47 <c_wraith> a universal type variable is a lot more pleasant to work with.
23:06:56 <c_wraith> It unifies with anything, if it's one branch of a conditional
23:07:06 <dminuoso> jle`: Ahh.. I just tried fiddling it through and things immediately went bad because the loop sits inside a `catches`
23:07:08 <dminuoso> :t catches
23:07:09 <lambdabot> error:
23:07:10 <lambdabot>     Ambiguous occurrence ‘catches’
23:07:10 <lambdabot>     It could refer to either ‘Control.Exception.catches’,
23:07:15 <dminuoso> :t Control.Exception.catches
23:07:16 <lambdabot> IO a -> [Control.Exception.Handler a] -> IO a
23:07:20 <dminuoso> :t Control.Exception.Handler
23:07:22 <lambdabot> Exception e => (e -> IO a) -> Control.Exception.Handler a
23:07:47 <jle`> as a return type, `-> IO a` is probably more practical yes
23:07:51 <cocreature> dminuoso: an exception handler that loops seems weird
23:08:00 <dminuoso> cocreature: No it doesn't, that's the point. :P
23:08:11 <jle`> as an input type IO Void might be a better choice
23:08:16 <nshepperd> right, it would be a bit annoying to be doing 'if condition then foo else (absurd <$> bar)' all the time
23:08:18 <jle`> the alternative being a RankN type
23:08:24 <jle`> or vacuous
23:08:25 <jle`> :t vacuous
23:08:26 <lambdabot> Functor f => f Void -> f a
23:09:01 <jle`> this is a very similar debate/tradeoff to how mapM_ and family take an ( -> f a) instead of a ( -> f ()) like it arguably "should"
23:09:09 <jle`> :t mapM_
23:09:10 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
23:09:11 <cocreature> dminuoso: it’s not weird or it doesn’t loop?
23:11:19 <cocreature> is there a way to see active flags in ghci?
23:11:30 <cocreature> e.g. -fobject-code, -O, …
23:11:44 <dminuoso> cocreature: loop `catches` [...]`, where the catches clause all break out of the loop. So in reality the whole thing can't be IO ()
23:11:46 <cocreature> :show(i) language only shows things like extensions
23:11:49 <dminuoso> Errr, it cant be IO Void
23:12:08 <cocreature> dminuoso: ah yeah that makes a lot more sense than an exception handler that is an infinite loop :)
23:12:46 <nshepperd> the last time this came up I think I asked about this but no-one knew the answer: I remembered reading that there was some kind of performance problem that would sometimes happen with mapM_ due to building up some thunks due to throwing away the unneeded b's
23:13:02 <nshepperd> or something
23:13:10 <nshepperd> but I couldn't find a source
23:13:33 <nshepperd> so now I'm thinking that I hallucinated the whole problem
23:14:40 <c_wraith> there were some bugs regarding that at one point
23:14:51 <cocreature> ah ":set" is what I’m looking for
23:15:18 <c_wraith> Maybe with FTP switchover and some instance of mapM_ not being appropriately lazy?
23:15:48 <c_wraith> I don't remember the details, just that there was some bug for a short time with a new version of mapM_
23:17:10 <nshepperd> that rings a bell... I think we tried to make mapM_ use Applicative and drop the Monad constraint
23:20:00 <cocreature> https://www.snoyman.com/blog/2017/01/foldable-mapm-maybe-and-recursive-functions also seems somewhat relevant
23:24:12 <nshepperd> ah, that looks like what I was thinking of
23:24:22 <nshepperd> but I don't know how the FTP was involved
23:25:04 * hackage graphviz 2999.20.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.20.0.0 (IvanMiljenovic)
23:27:26 <cocreature> nice, finally a new graphviz release that’s compatible with GHC 8.4 and fgl 5.6
23:36:44 <johnw> nice
23:39:01 <iqubic> mApply :: b -> Maybe (a -> b) -> a -> b
23:39:06 <iqubic> mApply defY mf x = maybe defY (\f -> f x) mf
23:39:11 <iqubic> What is the use of that?
23:39:52 <jle`> who told you it was useful?
23:39:57 <jle`> (what context, i mean)
23:40:12 <iqubic> Going through ertes' foldr tutorial and wondering if that has a use beyond just a teaching exercise
23:40:49 <iqubic> He wanted you to learn to use the maybe function as the fold on the Maybe datatype.
23:41:14 <jle`> if he uses it in the tutorial, then you have a good example right there of why it would be useful :)
23:41:28 <jle`> specifically, the situation where it is used
23:41:54 <iqubic> Right. He's basically showing that foldr Church encodes a list.
23:42:14 <iqubic> And he's using a simpler Church encoding to show you why you might want that.
23:42:37 <dminuoso> iqubic: There's an interesting monad transformer that leverages that: LogicT ;)
23:43:00 <iqubic> He's not using the term "Church Encoding" but that's how he's presenting foldr.
23:43:35 <dminuoso> There's very little value in confusing you with terms from lambda calculus when you're just trying to gain an understanding for foldr as a beginner.
23:44:09 <iqubic> Hence why ertes doesn't use the term "church encoding." I know that.
23:50:04 * hackage bench-graph 0.1.0 - Plot and compare benchmarks  http://hackage.haskell.org/package/bench-graph-0.1.0 (harendra)
