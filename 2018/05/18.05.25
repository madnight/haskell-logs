00:00:03 * geekosaur agrees re halting problem
00:00:15 <geekosaur> almost cited that earlier but it was sounding like a different problem then
00:00:31 <alexad> geekosaur, it sounds sort of but not completely like the halting problem
00:00:41 <cocreature> well we already established that a restriction to a non-turing complete language is fine so the halting problem doesn’t necessarily apply
00:00:48 <alexad> he might have a more constrained problem to solve that might prove possible, I really don't know yet
00:01:01 <alexad> cocreature, ah okay
00:01:52 <pavonia> If your operations are very expensive, it would be much cheapter to know the amount of needed operations in advance before wasting time/resources
00:02:57 <cocreature> pavonia: right my point is that for most operations figuring out the number of needed operations is not going to be cheaper than running those operations
00:03:14 <cheater> the halting problem is only a problem if you have turing completeness. there are many language families that don't have the halting problem. it's a red herring.
00:03:33 <cheater> well, there are non-tc langs with the halting problem too, but there are many without it.
00:04:01 <cheater> (i think there are non-tc langs with the hp, not sure tbh)
00:04:16 <alexad> cheater, yeah, sorry, I came in late and thought this had to do with analysing haskell itself
00:04:23 <alexad> not some dsl or something
00:04:55 <cocreature> if you want to restrict the number of steps for practical reasons, non-tc doesn’t really help you since knowing that a program halts doesn’t mean it halts within a reasonable amount of time
00:05:03 <cheater> cocreature: i disagree. "run and see it fail" isn't a good approach, i would much rather know at compile time. just like... i don't have to run a haskell program to see it fail, i can have the compiler check the types.
00:05:11 <cheater> alexad: no problem :)
00:05:45 <cheater> cocreature: that's why i would like to come up with some good definition of "cost" so that i can try to make a language where that can be computed before run time
00:06:04 <cheater> cocreature: what do you think of the question i asked above where i do x = 2 + 2 etc?
00:07:30 <cocreature> cheater: I don’t understand the question. if you have some usecase for this you should know what you are interested in counting, no?
00:11:22 <cocreature> I mean if you are interested in this from a theoretical perspective, that’s fine but then just say so!
00:11:41 <cocreature> it sounds like you are asking us for restrictions that can get your thing to work which seems pretty weird if you have a usecase for this
00:15:04 * hackage haskell-snake 1.0.0 - Snake game implemetation in Haskell using SDL2  http://hackage.haskell.org/package/haskell-snake-1.0.0 (cgenie)
00:15:23 <jle`> jchia: isn't () a binding? ;)
00:15:45 <jle`> oh wait i see what you mean
00:16:03 <jle`> jchia: it looks like you might want MultiWayIf ?
00:16:10 <pavonia> That question actually becomes interesting when thinking of contracts running on a blockchain like Ethereum does. If you'd knew the aprox. number of steps needed to execute the program at compile time, you could save the money wasted for doing evaluations that will not finish before running out of gas
00:16:26 <pavonia> Not sure if there are many real-world use cases, though
00:16:40 <jle`> ha ha
00:16:59 <liste> running user-submitted code
00:17:55 <cocreature> if your goal is running user-submitted code then the language is usually already fixed and in most cases it’s turing complete so you’re pretty much out of luck
00:18:38 <cheater> cocreature: i'm interested in this from a practical perspective: build a language that will only allow up to n steps of complexity. For use by every day programmers. However, this idea is fairly new to me, so i'm still in the pure theory phase, and that's why i'm soliciting lots of input.
00:19:12 <cheater> liste: yeah, that's a good example
00:19:15 <cocreature> cheater: there are type systems that track resources such as resource-aware ml
00:19:17 <cheater> pavonia's example is cool too
00:19:25 <smokeywonder> has anyone tried clojure and just disliked it overall for reasons other than it being dynamically typed and dealing with java from time-to-time? like things you consider design flaws?
00:19:44 <cheater> cocreature: i'm not sure how "resources" relate here, what are resources?
00:20:34 <cheater> anyways liste and pavonia's reasons are good ideas but my main reason is to make a programming language where programs will not be infinitely complex, so that it's easier to reason about them in your head.
00:20:35 <jchia> Axman6: I mean in that gist, Haskell syntax doesn't allow me to just drop the "let x" and "in x", right?
00:20:55 <jchia> Me question is why there is such a limitation
00:21:08 <cocreature> cheater: that’s mostly irrelevant to the overall principle. you assign some abstract resource usage to primitive operations, e.g., an addition costs 1 a multiplication costs 2, …
00:21:20 <Ariakenom> cheater: Any total language will not run _infinitely_ at least.
00:21:40 <Ariakenom> I did hear about a language that only allowed polynomial runtime as well though
00:21:43 <edmundnoble> If you want resource-aware types, there's a bounty of literature and some implementations you can look at.
00:22:04 <edmundnoble> See http://www.raml.co/
00:22:32 <jchia> Axman6: In other words, I want to use the guard as an expression in a larger expression, but if I drop "let x" and "in x" from the gist (https://gist.github.com/jchia/d785c6dfaea8dfd6745a3315b2ce70d1), the code won't compile.
00:23:04 <jle`> jchia: i think that's what multiwayif is for
00:23:08 <jchia> So am I right that this is indeed not allowed? If not allowed, why not?
00:23:09 <jle`> drop the let x and in x
00:23:14 <jle`> and do `if | ...`
00:23:28 <jle`> jchia: just having a bar in the middle of nowhere might be too ambiguous of syntax
00:23:46 <edmundnoble> Note that you will have runtime-dependent asymptotics which you can model, but which you can't practically restrict without going all the way to something like "polynomial only", because you'll have types like `f(x) :: Int Timed (TimeToCompute(y) * 4 + TimeToCompute(z) * length(h))`
00:23:46 <jle`> having a keyword before it makes things a bit less ambiguous i think
00:24:11 <cheater> Ariakenom: sure, but you can still have a very very complex program in a total language, and i want to strongly disincentivize that, and make it impossible without active consent.
00:25:52 <Ariakenom> cheater: Sure. You said infinitely so I commented on that and marked that part especially.
00:25:53 <jchia> jle`: Yes, you're right. I think I've always been using MultiwayIf in a simple way without pattern matching. I didn't realize I could pattern match with it.
00:26:20 <jle`> yeah, multi-way ifs is basically naked guard syntax
00:26:28 <jle`> so you can do your pattern guard and all your normal stuff with it
00:26:55 <Ariakenom> edmundnoble: you just need "less than 10" in the input type right?
00:27:26 <jle`> jchia: your specific example though could just be written with guards
00:27:31 <jle`> er sorry, with a case satement
00:27:40 <jle`> but i know that might just be this specific case
00:27:56 <jle`> case sqlRow of
00:27:59 <jle`>   [ ... ] -> ..
00:28:00 <edmundnoble> I mean some concerns you will have are a) how do you weight asymptotics versus constants? and closely related, b) how do you factor in runtime information? c) how do you know if a program "takes too long", unless you have a ballpark of the input size and acceptable running time? d) will you include space analysis? e) what is a "step", when multiple parts of the program can have nondeterministic runtime (e.g. memory
00:28:00 <edmundnoble> access, paging, instruction scheduling)?
00:28:00 <cheater> Ariakenom: sure, just saying what my main focus is :)
00:28:30 <cheater> cocreature: what did you not understand about those code examples above?
00:28:30 <edmundnoble> Ariakenom: You'll need much more information than that, because you don't know if running a program taking "less than 10" twice will still take "less than 10"
00:29:06 <jchia> jle`: Yeah, I was using case originally because I couldn't use a pattern guard, but I think the multiwayif is cleaner.
00:29:19 <cocreature> cheater: oh I understood them it just wasn’t clear why you were asking _us_ what you want to count since if you have some goal with this it seems like that goal should tell you what you need to count
00:29:43 <edmundnoble> Also as you said earlier cheater you certainly will need a way to opt-out, because a lot of algorithms can seem to take a lot of time but practically don't. And how do you deal with that? Do you assert that an operation will take "practically" f(x, y, z) steps for inputs x, y, z?
00:29:50 <edmundnoble> Do you introduce a bound?
00:30:20 <edmundnoble> I'm just spitballing here, I have no idea if what you're talking about is possible but these are just some things I think you would have to solve.
00:30:27 <cheater> cocreature: well, i'm trying to get some input about what you think about either.
00:30:28 <edmundnoble> I like ultrafinitism, this is kind of like ultrafinitism for program types.
00:31:11 <cheater> cocreature: so for example it seems like both options would let me reach the goal that i stated, but it's not sure which option is better.
00:31:27 <jchia> jle`: Thanks for pointing out multiwayif
00:31:33 <cocreature> it now sounds like your goal is more of a static analysis that warns users if their programs might be unnecessarily complex rather than defend against attackers
00:31:44 <jle`> jchia: no problem!
00:32:03 <edmundnoble> I believe what you're thinking about will ultimately reduce to some kind of convex optimization problem requiring at least limited dependent types, and a lot of user interaction.
00:32:24 <Guest66028> danilo2: the struct version is still using boxed ints
00:32:24 <cheater> cocreature: why did you think it was about defending against attackers?
00:32:39 <cheater> oh, you mean, to stop people from doing DOS?
00:32:42 <cocreature> yes
00:33:04 <cheater> yeah, i mean that's desirable, but only a foregone conclusion here, since that's not the point here
00:33:27 <cheater> and yeah, it's more about being able to present the person with a code base that's as simple as possible
00:33:41 <cheater> after all, code is for being read.
00:33:43 <edmundnoble> By simple do you mean performant?
00:33:45 <edmundnoble> This seems unrelated.
00:34:08 <cheater> no, by simple i mean as uncomplicated as possible
00:34:10 <cocreature> if your goal is giving hints to users than you have very different constraints. e.g. it might be fine to miss some cases where programs are unnecessarily complex
00:34:30 <cheater> cocreature: well.. less hints, and more hard constraints
00:34:44 <edmundnoble> That sounds completely impossible to me. You can write a cyclomatic complexity checker. That's going to be something.
00:35:05 <edmundnoble> But you can't tell me whether or not I should introduce a type class or data type, or if my algorithm is the simplest it can be, or if it's implemented in a simple way.
00:35:21 <cocreature> if you could tell what “as uncomplicated as possible” means you could probably just write the program for your users
00:35:25 <cheater> edmundnoble: did you see the simple code examples i provided above? it was possible for those code examples. note we're talking about a language i'm designing which is not turing complete.
00:35:51 <cheater> cocreature e.g. at the top of the file you go and say "steps = 400" and nothing in your file can take more than 400 steps, including the cost of executing anything outside that file
00:36:16 <edmundnoble> I don't see how you're relating performance to simplicity here
00:36:52 <cocreature> cheater: I’m not sure “400 steps” is a useful restriction. for most interesting programs the number of steps will depend on the input
00:37:08 <edmundnoble> If your language has a "canonical form" then you can tell the user "hey your program is not canonical"
00:37:10 <cheater> cocreature: well, that's kind of fuzzy. so the criterion isn't technical, but it's psychological: to make programs as uncomplicated /to reason about/. i think that a notion seated in psychology is going to yield better results than a specific technical notion, that's why i take that as the root idea, and now i'm trying to derive technical definitions that could help achieve that.
00:37:38 <cheater> cocreature: for example?
00:37:57 <edmundnoble> This language isn't turing complete so that isn't going to happen cocreature
00:38:08 <cheater> edmundnoble: i never spoke about performance. maybe you confused someone else's conversation with ours?
00:38:11 <cocreature> edmundnoble: eh non-turing completeness doesn’t prevent loops
00:38:25 <cocreature> e.g. a program that given a list of numbers outputs their sum
00:38:32 <edmundnoble> cocreature: True.
00:38:39 <cheater> the language is at most primitive recursive, which means you could eg fmap and fold over finite data structures.
00:38:40 <edmundnoble> cheater: you're saying "nothing in your file can take more than 400 steps", no?
00:38:47 <edmundnoble> "Take more than n steps" sounds like a performance requirement
00:39:02 <cheater> edmundnoble: yes, but it's about presenting the reader with a program that's simple, it's not about saving cpu time. it's about saving brain space.
00:39:43 <edmundnoble> So your definition of "step" is really not "your program takes n steps" but rather "your program has been measured to have more than n complexity units"?
00:40:51 <cheater> i don't know what you mean by "complexity units" here
00:41:06 <edmundnoble> Some kind of unit measuring the complexity of the program
00:41:10 <edmundnoble> From a psychological viewpoint
00:42:29 <cheater> well, yeah. i mean look at the message above with code starting with x = 2 + 2. there i try to think about what approach of counting the beans would be better for this purpose.
00:43:46 * edmundnoble Right, I think ultimately it will come down to some weighted combination of syntactical measures of the program.
00:44:01 <edmundnoble> IMO all these things will do is encourage the user to optimize for "least complexity units" instead of writing the program they think needs to be written, in the way they think it needs to be written.
00:44:45 <cheater> i think that's a good default
00:44:56 <cheater> if you want to make the code more complex, have a good reason for that
00:45:07 <edmundnoble> Well, is factoring out code making it more or less complex?
00:45:42 <edmundnoble> It introduces dependencies. It also decreases the amount of code to reason about. On a syntactic level, if you auto-deduped similar code, I think my code would be trash.
00:46:16 <cheater> bear in mind you're also the person writing steps = 400 at the top of the file
00:46:42 <cheater> (that's just an example of how this could work, it could work some other way too)
00:47:26 <cheater> what i'm saying is it's about you providing a constraint to yourself, and then if you exceed it heed it as a warning that your code might be doing something different than you expect it to
00:47:54 <edmundnoble> I mean you could try coming up with some syntax to avoid a certain piece of code being flagged as complex. But that's *still* more inconvenient than refactoring. It's like using IntelliJ with Scala; the IDE tells me some code is wrong, my options are to go along with it and refactor it so it doesn't think it's wrong, or turn off the IDE's error detection within that block. Both options are crap.
00:48:01 <cheater> then you'd inspect where the excessive cost comes from, and if you find it's fine, then you bump it, to, say, 500.
00:48:32 <cheater> you don't need to flag code from being excluded, you just need to bump the number. you're the one putting it in in the first place.
00:48:49 <edmundnoble> Well then, you have small pieces of complex code making the limit less useful. Or you have to refactor the code into multiple files so that you can have different limits.
00:49:16 <cheater> not necessarily, because if a.txt depends on b.txt, then a has to account for b's cost too.
00:49:45 <cheater> so if b already costs 400, and code in a alone costs 100, you'll need 500 for a, or something like that.
00:52:20 <edmundnoble> So it's strictly additive, then, this complexity cost? e.g. `if (b) a else c` has complexity `f(b) + f(a) + f(c)`?
00:53:34 <edmundnoble> What if `a` and `c` both call into `d`?
00:54:11 <cocreature> seems like you would at least want "f(b) + max(f(a), f(c))"
00:54:47 <cheater> yeah, that's one thing i was considering. I think it would be a good idea to count d twice, what do you think? i mean they will probably call into d with different parameters, essentially making both calls for d different things, so you have to consider this twice when thinking about what will happen.
00:55:14 <cheater> cocreature: wow, good point. i wouldn't have thought of this myself, but that's a good thing to consider.
00:55:15 <edmundnoble> I think counting `d` twice is probably a good idea because otherwise deduplication *always* results in lower complexity.
00:56:05 <cocreature> I still think you want to count the number of steps in relation to the input rather than limit yourself to a fixed number of steps
00:56:46 <cheater> edmundnoble: yeah, and it also aligns with the goal of not being able to create arbitrarily complex things. like, if you shouldn't be able to create a list of 100000 elements, you also shouldn't be allowed to create a list of 100 elements, each of which is a list of 1000 elements
00:56:53 <edmundnoble> Right.
00:57:10 <edmundnoble> So I'd think about which program transformations do what to complexity, now.
00:57:17 <cheater> cocreature: right, you never said, why do you think that's necessary? can you come up with some good examples of where the steps depend on input?
00:57:42 <cheater> edmundnoble: what transformations are you thinking of?
00:57:53 <cocreature> cheater: I already gave you an example: a program that given a list outputs the sum of the elements in that list
00:58:11 <cocreature> basically as soon as you introduce any data structures the number of steps is probably going to depend on the size of those data structures
00:59:34 <edmundnoble> Well, firstly refactors
00:59:42 <edmundnoble> Whether or not you want refactors to change complexity and how
01:00:21 <edmundnoble> Secondly I guess "refurbishments"; things like `x + x` vs `2 * x`
01:00:38 <edmundnoble> Thirdly semantic-changing operations
01:01:17 <edmundnoble> In my ideal complexity management system the first changes nothing, the second changes little, the third can change a lot
01:01:47 <edmundnoble> I mean it's a bit odd to me also to use `f(b) + max(f(a), f(c))` for `if`
01:02:17 <cocreature> why is that odd?
01:02:39 <edmundnoble> What that means is introducing a branch, if you have `a` and going to `if (b) a else c`, will almost always change complexity a very small amount
01:03:05 <edmundnoble> Maybe add a constant or something too
01:03:21 <edmundnoble> Maybe consider the possibility of having multiple dimensions of complexity
01:05:28 <edmundnoble> Also make sure to deduplicate constants but *don't* perform constant folding; that way factoring a constant into a variable doesn't change complexity, because otherwise factoring out `1000` into a constant when you have an expression `1000 - 90` may decrease complexity.
01:05:45 <edmundnoble> Unless you want that!
01:06:46 <edmundnoble> Anyway my advice in general is consider complexity in terms of program transformations because they're exactly what the user will consider doing when they hit the ceiling
01:07:18 <edmundnoble> And consider that there will always be some users who will just bump the ceiling forever, and that the proportion who do that is never going to be zero but you can try to minimize it
01:16:13 <[exa]> hm guys, is there a parallelizable alternative of JuicyPixels' generateImage?
01:16:34 * hackage eventstore 1.1.4 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-1.1.4 (YorickLaupa)
01:17:20 <kvothe> I have a pure function foo which might throw some exception. I want to do try foo and rethrow the exception if there is one. However, try takes an IO action as an arguement. Is there any equivalent of try which takes a pure function as arguement?
01:17:54 <tdammers> no
01:18:00 <tdammers> not a sane one anyway
01:18:22 <tdammers> it's impossible, because of non-strict evaluation
01:18:50 <tdammers> the exception will only be thrown when the expression that throws it is evaluated deeply enough
01:22:40 <kvothe> Is it a good idea to force the evaluation?
01:22:56 <[exa]> sometimes.
01:22:57 <merijn> kvothe: Also, throwing exceptions from pure code is a terrible idea
01:23:03 * hackage urlencoded 0.4.2.0 - Generate or process x-www-urlencoded data  http://hackage.haskell.org/package/urlencoded-0.4.2.0 (fgaz)
01:23:09 <merijn> kvothe: Because laziness can easily cause the exception to leak out of the handle/catch
01:23:23 <kvothe> I want to do something like this https://lpaste.net/3704370255842246656
01:23:30 <merijn> kvothe: The only *safe* way to throw exceptions in a way that can be caught is via throwIO (or throwM from exceptions)
01:23:48 <merijn> kvothe: Yeah...don't use throw
01:24:29 <merijn> Someone should volunteer to add a huge warning to 'throw' and how it should be avoided
01:25:22 <kvothe> So what should I do if my pure code has an exception?
01:25:34 <cocreature> return Maybe/Either instead
01:25:36 <merijn> kvothe: Use Maybe or Either, generally
01:25:36 <dminuoso> kvothe: Use Maybe
01:26:30 <kvothe> how should I handle it?
01:26:50 <dminuoso> kvothe: You can use the Functor/Applicative/Monad/Alternative interfaces, as well as pattern matching.
01:27:25 <merijn> kvothe: There's a whole bunch of tools for dealing with Maybe, such as
01:27:27 <merijn> :t maybe
01:27:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:27:29 <merijn> :t fromMaybe
01:27:30 <lambdabot> a -> Maybe a -> a
01:29:55 <kvothe_> sorry I got disconnected!
01:30:39 <kvothe_> So why is throwing exceptions from pure code a bad idea?
01:31:52 <dminuoso> kvothe_: because it wouldn't be pure anymore, now would it.
01:33:22 <michalrus> Hmm, in tests, -Wall -Werror doesn’t warn me about missing record fields. It does in library. How can I make it do that?
01:34:41 <cocreature> michalrus: are you sure that you have recompiled?
01:35:00 <cocreature> michalrus: changing warning flags won’t trigger recompilation automatically
01:35:01 <michalrus> It’s been so always. :P I just didn’t notice.
01:35:32 <dminuoso> kvothe_: Maybe/Either _are_ exceptions except they are pure.
01:36:00 <michalrus> cocreature: Also: “By default, you get a standard set of warnings which are generally likely to indicate bugs in your program. These are: … -fwarn-missing-fields …”
01:36:23 <dminuoso> kvothe_: They completely model exceptions. They let you have success and failure paths. You can tag information about failure along (Either). All the instances Functor/Applicative/Monad/Alternative together with most functions relating to maybe and either somehow give you a bag of tools to have pure exceptions.
01:36:30 <kvothe_> dminuoso: why not? The function signature of throw is Exception e => e -> a
01:36:36 <cocreature> michalrus: can you show us your cabal file?
01:36:48 <dminuoso> kvothe_: When I say exceptions I mean that as a concept.
01:37:18 <dminuoso> kvothe_: An exception is just something that has the ability to shortcircuit some computation/path. Maybe/Either do exactly that.
01:39:58 <michalrus> cocreature: here it is, with copyright and module list censored http://termbin.com/ntop :]
01:41:19 <michalrus> Could it be that it doesn’t catch cross-subproject usages? I.e. if I missed fields in tests in a record from library?
01:42:09 <merijn> dminuoso: Either doesn't completely model exceptions
01:42:14 <michalrus> cocreature: yes, it seems so. :/
01:42:17 <merijn> dminuoso: It can't do subclassing and selectively catching
01:42:41 <cocreature> michalrus: ouch that’s annoying
01:43:16 <michalrus> So the only solution would be to have strict records, right?
01:45:33 <merijn> michalrus: Might just be a GHC bug. Also are you importing the type's constructor and fields? Maybe missing an import accidentally silences the warning?
01:46:59 <michalrus> merijn: yes, not explicitly, but I’m importing everything from the module where that record is defined, and that module exports everything it defines.
01:47:13 <merijn> michalrus: I'd consider that a bug in GHC
01:47:29 <cocreature> michalrus: I can’t reproduce this. I get a warning even if I define a record in a lib and use it in a test suite
01:47:38 <michalrus> :(
01:48:26 <geekosaur> exports how? if it's explicit, you need to explicitly name the fields too because they're also (selector) functions
01:49:00 <michalrus> geekosaur: no, no, implicit. `module A.B.C where`, without an explicit list.
01:52:22 <merijn> Somewhat unrelated, but I feel compelled to mention the trick of being able to write "module Foo (module Foo) where" to export everything inside Foo without explicitly listing it
01:52:26 <cocreature> michalrus: maybe try to isolate it to some minimal example? the fact that it’s working for me but not for you suggests that there is something weird going on
01:52:40 <merijn> (This is useful when you want to re-export another module, but don't want to manually list everything in this module for exporting)
01:55:33 * hackage eventsource-api 1.3.1 - Provides an eventsourcing high level API.  http://hackage.haskell.org/package/eventsource-api-1.3.1 (YorickLaupa)
01:55:36 <cheater> cocreature: sorry, had to go for a while
01:57:51 <cheater> edmundnoble: that's a good point with the transformation. what do you mean by semanting-changing operations? can you give some examples please?
01:59:32 <michalrus> merijn: thank you.
01:59:47 <cheater> cocreature: ok, so if you have a function that accepts a list, and computes its sum, first of all there are no general loops (like with a counter) or recursion / destructuring of data, so you can't do those. But you do get a fold. So you could go and say "sum xs = fold (+) 0 xs". Now the question is whether we want the complexity to change based on the length of xs.
02:00:05 <michalrus> cocreature: ohhhh, I get it. `data X = X Int Int ; main = print (X {})`.
02:00:12 <michalrus> This will compile and fail in runtime.
02:00:18 <michalrus> With -Wall.
02:00:47 <cheater> i would say you should change the complexity, because otherwise you could have arbitrarily large (essentially, turing complete) computations happen
02:01:35 <geekosaur> not sure any of the record field warnigs apply to that case, theyt apply to *named* fields.
02:01:54 <geekosaur> and X {} is kinda explicitly asking for trouble
02:02:03 <geekosaur> unless X is actually nullary
02:03:22 <michalrus> Yes, that’s very true, but would you say this should compile? :þ
02:04:54 <merijn> michalrus: Yes
02:05:12 <geekosaur> there is in fact a strong argument for it doing so: the only time (X {}) means anything is precisely in the cases you expect it to warn
02:05:45 <geekosaur> wither X is nullary and the {} isn;t needed, or it is not and you are explicitly using an undefined expression
02:06:01 <merijn> geekosaur: Also super useful for writing future-proof pattern matches
02:06:17 <geekosaur> but pattern matches don;t trigger this problem
02:06:20 <merijn> "case foo of Foo{} -> doStuff" <- works even if Foo changes types/arguments
02:06:27 <merijn> Sure
02:06:58 <geekosaur> so why drag pattern matches into something explicitly not about pattern matches?
02:07:35 <merijn> I was referring to the usefulness of X{}
02:07:55 <geekosaur> never mind, of course confusingly out of scope pedantry is more correct
02:08:05 <geekosaur> the asker cares about print (X {})
02:08:11 <cocreature> I didn’t even know X{} worked for non-record types in an expression context
02:09:23 <michalrus> merijn: ohhh, I see. OK. :) Thanks for explanation.
02:09:42 <AWizzArd> Functional Dependencies are just a tool to reduce the number of acceptable implementations for a multi-parameter type class right? (plus it may help inference)
02:10:15 <merijn> AWizzArd: Well I don't think "reducing the number of acceptable implementations" is a goal, but it is a side-effect of how they work, yes
02:10:16 <geekosaur> in any case, in pattern matches the case of getting an unexpected bottom just because you listed no fields isn't a thing
02:10:52 <cocreature> A warning that prevents you from accidentally using X{} for non-record types seems pretty reasonable
02:10:54 <merijn> AWizzArd: The main reason they exist is to help inference/type-checking in case where one parameter is derived from another (like a container type)
02:11:18 <AWizzArd> merijn: Okay interesting, thanks for clarifying.
02:11:21 <geekosaur> AWizzArd, functional dependencies exist so the compiler can determine the type of an expression without manual annotation. which is a serious problem with mulltiple parameter type classes otherwise
02:11:39 <geekosaur> you use functional dependencies, or you use associated types (which came later)
02:12:01 <AWizzArd> Good to know. I thought that improved inference was just a side effect and that their main purpose was to restrict the number of possible implementations.
02:12:20 <AWizzArd> I got those both exactly wrong, thanks for clarifying.
02:12:45 <AWizzArd> Makes sense even, now that I think about it.
02:13:30 <AWizzArd> I would implement only those cases I care for and not think about someone else providing an additional/conflicting implementation of a type class.
02:13:48 <geekosaur> can't get closed world that way anyway
02:14:03 <AWizzArd> But: FD is only interesting when dealing with multi-parameter TCs yes?
02:14:43 <geekosaur> also only possible in that case, because you don;t have anything to relate otherwise
02:14:59 <geekosaur> or at least only meaningful
02:16:05 <geekosaur> class Foo a | a -> ??? -- what possible ??? is there? you need an additional parameter for any other name to be in scope
02:18:37 <AWizzArd> Good.
02:19:43 <merijn> geekosaur: I think you actually can have a FunDep with only one param. Of course it's a completely useless and trivial one, but I think the syntax allows it
02:20:08 <geekosaur> tautological?
02:20:27 <geekosaur> I did think of that but as I said, 'only meaningful'
02:22:04 <Ariakenom> tautological in natural language has always confused me. I first heard it in logic where it means true as far as I am concerned
02:22:53 <merijn> Ariakenom: Tautological means "true in a circular way" and in natural language generally means "redundant description" (which is somewhat similar)
02:22:58 <geekosaur> tautological in natural language is usually emphasis or potentially necessary redundancy (i.e. to block other possible meanings, because natural language doesn't do logic)
02:23:16 <AWizzArd> merijn: that would be a type class which can have at most one implementation?
02:23:22 <geekosaur> basically the fundep | a -> a is a tautologuy: if you know type a, of course you already know type a
02:23:34 <geekosaur> it adds no information at all
02:23:50 <geekosaur> and you can;t say e.g. | a -> Int, it has to be a type variable from the class head
02:23:58 <geekosaur> or from an associated type class
02:24:04 <geekosaur> er, associated type
02:24:15 <Ariakenom> well confused was a strong word I guess
02:26:38 <merijn> geekosaur: I think you can do "-> a" too
02:26:54 <merijn> No clue what that *means*, but you can
02:27:16 <merijn> In fact, both "a ->" an "-> a" are allowed according to my quick ghci test
02:30:09 <Ariakenom> The natural language meaning is older afaik so it's not misused or anything. But whenever I hear it in a technical concept my brain goes to the propositional definition.
02:37:56 <Cale> Tautological means true in a manner independent of the logical atoms that the statement is built from, i.e. not only true, but true in a way which only requires logic to verify.
02:41:23 <dminuoso> cocreature: Thank you. I've decided to not just fix the lazy issue, but rewrite the whole thing. There's too many things that annoy me :P
02:42:47 <cheater> Cale: so in other words, polymorphically true?
02:43:25 <cocreature> dminuoso: sounds like a good way to procrastinate from what oyu sohuld actually be doing :P
02:47:02 <dminuoso> cocreature: well it's just 500 lines of code or so, plus I consider it just practice :)
02:48:19 <dminuoso> This toEnum/fromEnum abuse to parse numbers into data and back again with `error` being flung around has been mildly annoying as well
02:52:08 <ontanj> can someone tell me where to read more on this notation? `do [1, 2, 3, 4]; "curry"` i'm (kind of) familiar with the do-notation but this specific one seems different.
02:53:02 <ontanj> or is it just the same?
02:53:17 <dminuoso> ontanj: do-notation desugars into >>= and >>
02:53:38 <dminuoso> ontanj: so that is equivalent to: [1,2,3,4] >> "curry"
02:53:59 <cocreature> which is using the Monad instance of []
02:54:13 <ontanj> and `;` is instead of newline?
02:54:21 <dminuoso> ontanj: rightr
02:55:11 <ontanj> great! that will help me. thanks!
02:55:37 <tabaqui1> instance (MonadTrans t, Monad m, Monad (t m)) => MonadBase m (t m) where liftBase = lift
02:55:38 <michalrus> cocreature: merijn: regarding that X{} discussion, when using -XStrictData, it gets a nice compiler error. :b
02:55:45 <tabaqui1> what is wrong with this definition?
02:55:56 <michalrus> Constructor ‘X’ does not have the required strict field(s)
03:01:18 <ontanj> dminuoso: sorry but could you just tell me how to translate all of `do [1, 2, 3, 4]; "curry"` to >>= / >>? can't make it work
03:02:38 <geekosaur> they did
03:02:44 <geekosaur> [25 09:53:16] <dminuoso> ontanj: so that is equivalent to: [1,2,3,4] >> "curry"
03:03:03 <ontanj> of course! thanks!
03:03:23 <liste> > do [1,2,3,4]; "curry"
03:03:25 <lambdabot>  "currycurrycurrycurry"
03:03:38 <liste> > [1,2,3,4] >> "curry"
03:03:40 <lambdabot>  "currycurrycurrycurry"
03:03:43 <ontanj> dminuoso: missed that you already did. thanks!
03:07:24 <geekosaur> tabaqui1, I don't suppose you happen to have any error messages from that?
03:07:42 <dminuoso> ontanj: every line `a <- b` gets desugared into `b >>= \a -> ...`, and if you have just `b` then it gets desugared into `b >> ... `
03:09:20 <AWizzArd> shapr: Yesterday we talked about automatic refactoring. I was thinking of this one: you have a `data` declaration with a few positional fields and some functions using the type, with corresponding pattern matching. At a certain number of fields the refactorer can rewrite the code to use RecordWildcards, and get rid of the positional arguments.
03:10:23 <dminuoso> ontanj: These two generate the same code: https://gist.github.com/dminuoso/eb373ab99b98bc27c68d936e245c7f24
03:10:37 <dminuoso> ontanj: So you can write it in the same style without do-notation. :)
03:19:13 <cocreature> tabaqui1: do you get some error or why do you think it’s wrong?
03:19:39 <geekosaur> I'm through trying to figure out how to reproduce it locally
03:19:44 <Axman6> it looks like it would overlap with other instances
03:20:12 <Axman6> seems like a classic example of a problematic class instance
03:21:04 <tabaqui1> geekosaur, cocreature: no errors
03:21:04 <Axman6> it also feels wrong, should the base monad not be the lowest level monad? (usually IO)
03:21:29 <geekosaur> and no explanation. were you looking for random guesses?
03:21:43 <tabaqui1> I just think it is an obvious instance and I am wondering why it is not in transformers, transofmers-base libs
03:22:04 <Axman6> ehat is MonadBase supposed to do?
03:22:09 <Axman6> w*
03:22:24 <tabaqui1> Axman6: it is like MonadIO but for any monad
03:22:28 <cocreature> tabaqui1: that instance differs from the existing instances
03:22:36 <Axman6> tabaqui1: are you sure about that?
03:22:48 <Axman6> I have a feeling it should be recursive
03:22:55 <tabaqui1> liftBase allows to lift any monad actions in child monad
03:23:03 <cocreature> tabaqui1: e.g. if you have something like ReaderT e (StateT s IO) you would get MonadBase (StateT s IO) (ReaderT …) whereas the existing instance gives you MonadBase IO (ReaderT …)
03:23:23 <Axman6> if you have ExceptT e (ReaderT r (WriterT w IO)), are you supposed to get IO or ReaderT r (WriterT w IO)?
03:24:05 <tabaqui1> Axman6: liftBase . print :: String -> ReaderT r (WriterT w IO) ()
03:24:13 <Axman6> I have a feeling you want the the former
03:24:24 <geekosaur> I don;t know MonadBase as such. I know it's used by MonadBaseControl where you have to know what exactlky is going on for it to work right, so you can;t get away with autogenerated instances for it or probably MonadBase (which might lead to the wrong exception handling)
03:24:26 <Axman6> otherwise it's not a particularly interesting class
03:25:43 <tabaqui1> tabaqui1: that instance differs from the existing instances
03:25:46 <tabaqui1> > cocreature
03:25:49 <lambdabot>  error: Variable not in scope: cocreature
03:26:11 <tabaqui1> cocreature: existing instances of MonadBase for transformers match my definition
03:26:26 <tabaqui1> liftBaseDefault = lift . liftBase
03:26:44 <Axman6> I don't think that matches your implementation
03:26:46 <tabaqui1> and ReaderT, ExceptT... are implemented with it
03:26:57 <Axman6> what is the implementation for ReaderT?
03:26:58 <tabaqui1> Axman6: it does
03:27:42 <tabaqui1> instance (MonadBase b m) ⇒ MonadBase b (ReaderT a m) where liftBase = liftBaseDefault
03:27:53 <Axman6> right, that is not what you wrote
03:28:06 <tabaqui1> well, there is no instance MonadBase m m for any Monad
03:28:10 <Axman6> it says the base of (t m) is the same as the base of m
03:28:33 * hackage text-regex-replace 0.1.1.3 - Easy replacement when using text-icu regexes.  http://hackage.haskell.org/package/text-regex-replace-0.1.1.3 (EricRochester)
03:28:39 <Axman6> which means it recurses until there is a monad transformer which does not recurse, ie, IO or ST
03:28:42 <tabaqui1> no it says that 'b' is a base for 'm' implies that 'b' is a base for 't m'
03:28:54 <tabaqui1> b -> m -> tm
03:29:07 <Axman6> yes
03:29:26 <Axman6> you wrote: instance (MonadTrans t, Monad m, Monad (t m)) => MonadBase m (t m) where liftBase = lift
03:29:44 <Axman6> that does not recurse to make the base of (t m) the same as the base of m
03:29:50 <Axman6> which is the prupose of the class
03:29:52 <tabaqui1> I just omit 'm' in the chain
03:30:01 <Axman6> so you have a way of talking about the innermost monad
03:30:06 <tabaqui1> m -> tm
03:30:08 <tabaqui1> *omit 'b'
03:32:43 <Axman6> ok, the type of liftBase :: MonadBase b m => b a -> m a, yes?
03:33:24 <tabaqui1> right
03:33:44 <tabaqui1> lift :: m a -> t m a
03:33:55 <tabaqui1> lift . liftBase :: b a -> t m a
03:33:59 <Axman6> , and the point is so that you czn run print True inside m a with liftBase (print True), yes?
03:34:17 <tabaqui1> yep
03:34:27 <Axman6> tabaqui1: that doesn't work because liftBase doesn't know what the base monad of m is
03:34:46 <Axman6> which is the point of the class
03:35:24 <Axman6> it would be using an instance for MonadBase m m => m a -> t m a (roughly)
03:35:39 <tabaqui1> lift . liftBase :: (MonadBase b m, MonadTrans t) => b a -> t m a
03:36:06 <Axman6> ie, in the case of  ExceptT e (ReaderT r (WriterT w IO)), liftBase would have type ReaderT r (WriterT w IO) a -> ExceptT e (ReaderT r (WriterT w IO)) a, _not_ :: IO a -> ExceptT e (ReaderT r (WriterT w IO)) a, which is what you want
03:36:16 <tabaqui1> liftBase maps 'b a' to 'm a' here
03:36:20 <tabaqui1> right?
03:36:24 <Axman6> tabaqui1: there is no constraint on m which says that is has a MonadBase instance
03:36:55 <Axman6> only if it is known that the m has a MonadBase instance
03:37:14 <Axman6> what you wrote would work for single level monad transformers, but not more than one transformer
03:38:12 <Younder> You could use fibered categories
03:38:22 <Axman6> since there are instances for MonadBase IO IO and MonadBase ST ST
03:39:01 <Younder> They are all the craze in categorical type theory
03:39:17 <Axman6> anyway, general instances like this are almost always a bad idea, but I can't remember why
03:39:42 <tabaqui1> Axman6: nope, liftBase does have signature of IO a -> ExceptT e (ReaderT r (WriterT w IO)) a
03:39:53 <tabaqui1> you can use single liftBase as with MonadIO
03:39:59 <tabaqui1> that's the poitn
03:40:02 <tabaqui1> *point
03:40:18 <Axman6> tabaqui1: no, it doesn't, because you haven't said it does in the constraint to the class instance
03:40:53 <tabaqui1> ah, okay
03:41:15 <Axman6> you may be able to get it to work if you have: instance (MonadTrans t, Monad m, Monad (t m), MonadBase b m) => MonadBase b (t m) where liftBase = lift . liftBase
03:41:28 <tabaqui1> instance (MonadTrans t, MonadBase b m, Monad (t m)) => MonadBase b (t m) where liftBase = lift
03:41:41 <tabaqui1> righty
03:41:43 <tabaqui1> *right
03:41:44 <Axman6> I think it needs to be lift . liftBase
03:41:51 <tabaqui1> yep
03:41:57 <tabaqui1> you're right
03:42:03 * hackage graphviz 2999.20.0.2 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.20.0.2 (IvanMiljenovic)
03:42:05 <tabaqui1> but there is no such instance anyway
03:42:33 <Axman6> I'm fairly certain there's a good reason why there isn't one
03:44:31 <tabaqui1> that's is what I want to ask before (and failed with instance)
03:58:50 <cocreature> the problem with such an instance is that it overlaps which pretty much everything
04:00:11 <newhoggy> Does anyone know if the ForeignPtr inside a ByteString is guaranteed to have an alignment?
04:00:52 <newhoggy> I'm hoping it is guaranteed to always be aligned at Word64 boundaries.
04:00:53 <tabaqui1> import with hidden instances would be very useful
04:02:37 <Axman6> newhoggy: I would be surprised if it is, since the ForeignPtr might come from elsewhere (see my PR on the text-utf8 package for how I get around it)
04:03:08 <geekosaur> tabaqui1, it's also quite unsound. typeclasses don't work that way
04:05:35 <newhoggy> This one? https://github.com/text-utf8/text-utf8/pull/1
04:06:01 <Axman6> it doesn't make much sense to hide instances, because there should only be zero or one instance for a class for a given type (ignoring MPTCs I think)
04:06:12 <Axman6> yep
04:08:06 <Axman6> anyone now of something that would allow symbolic evaluation of boolean expressions? like wanting to take [0 0 X 0] * [Y 0 Z 1] and get back which combinations of bits are in the result
04:09:04 <Axman6> so, in that cse it woul be [Y*X 0 Z*X X 0] (I think)
04:10:04 * hackage baserock-schema 0.0.1.0 -   http://hackage.haskell.org/package/baserock-schema-0.0.1.0 (locallycompact)
04:10:53 <Axman6> I wonder if cryptol would do that...
04:11:33 <Younder> sounds like the NSA guy's are being busy
04:12:07 <Axman6> ?
04:12:56 <cocreature> Axman6: what kind of operator is * supposed to be here?
04:13:01 <Younder> Topological taxonomy of categories is an epic idea
04:13:04 * hackage hledger-irr 0.1.1.14 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.14 (JoachimBreitner)
04:13:33 <Axman6> multiplication, as in Word4 * Word4 -> Word8
04:14:00 <cocreature> ah makes sense
04:14:00 <Axman6> or Word n * Word m -> Word (m+n)
04:14:55 <xpika> I learned about free monads today. Are there any real world usages of free monads?
04:17:15 <Axman6> many
04:18:01 <xpika> like would I be able to find them on hackage?
04:18:33 <edmundnoble> Free monads are used all over the place for encoding interfaces to be accessed by higher-level business logic.
04:18:54 <edmundnoble> They're more a "real app" thing than a "build a library which uses them" thing, from what I know
04:19:03 <edmundnoble> Though there are libraries providing them
04:19:08 <Axman6> if you look at the packages which depend on the free, or freer-effects packages you'll find some
04:19:12 <xpika> One example I saw was parameritising IO behaviour, but then I found the monad prompt which should be able to do that too.
04:19:25 <xpika> Axman6: good idea
04:19:25 <edmundnoble> Monad prompt is the exact same thing
04:19:27 <edmundnoble> It's just a different name
04:19:42 <edmundnoble> It's a specific free monad, there are many encodings
04:19:48 <edmundnoble> Each with different tradeoffs
04:21:00 <xpika> ok, I found quite a few reverse dependencies on https://packdeps.haskellers.com/reverse/free
04:26:52 <lyxia> xpika: pipes uses a free monad, though it's not constructed in a generic way using Free.
04:27:09 <tabaqui1> it looks like static build add the whole library in compiled binary
04:27:27 <tabaqui1> I thought only symbols that necessary for evaluation
04:27:45 <tabaqui1> look
04:27:54 <geekosaur> only objects files containing such symbols. which is likely more than you think
04:27:55 <tabaqui1> main = print 1   -- 2.2M
04:28:03 * hackage crawlchain 0.3.0.0 - Simulation user crawl paths  http://hackage.haskell.org/package/crawlchain-0.3.0.0 (axm)
04:28:09 <tabaqui1> main = print $ InvalidUrlException "String" "String" - 4.1M
04:28:33 * hackage quickcheck-classes 0.4.11.1 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.4.11.1 (andrewthad)
04:28:46 <geekosaur> you need --split-objects or (preferred if supported) --split-sections if you want something smaller than entire module
04:31:09 <tabaqui1> nope, nothing changes
04:31:45 <geekosaur> then more things are being pulled in and you get to (a) examine Core (b) learn how ghc works
04:31:56 <geekosaur> in sted of blindly assuming haskell is a strange-looking C
04:32:40 <cocreature> I’m also not sure if "base" is built with --split-sections by default?
04:32:45 <geekosaur> and that obviously the things you mention are the only things conceivably needed (there's a lot more going on there than is explicitly written)
04:32:58 <geekosaur> base is almost always built with --split-objects or --split-sections
04:33:19 <geekosaur> but there's a lot of typeclass machinery pulled in by that line
04:33:44 <tabaqui1> well, I import the only one type from the http-client
04:33:50 <tabaqui1> and my binary grows for a 2M
04:33:58 <tabaqui1> it's the "data Proxy = Proxy ByteString Int"
04:37:03 * hackage hasql 1.3.0.1 - An efficient PostgreSQL driver and a flexible mapping API  http://hackage.haskell.org/package/hasql-1.3.0.1 (NikitaVolkov)
04:40:34 * hackage postgresql-simple 0.5.4.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.5.4.0 (phadej)
04:41:21 <mupf> arrgh screw arch linux. i'm still trying to figure out how to compile an application using cabal. before trying to install ghc manually.
04:41:36 <mupf> it seems just to be broken.
04:41:43 <edmundnoble> Have you tried cabal new-build?
04:41:48 <mxf> mupf, i'd kindly suggest just going with stack :)
04:42:11 <__monty__> mupf: I can't recommend nix strongly enough for haskell on arch.
04:42:20 <dmwit> ?tell mbwgh Rereading, my comments do appear a bit mysterious. What I was getting at is that, even for a fully parenthesized expression like `(x+y)+z`, which bits get evaluated first depends on the strictness behavior of `+`. So "which thing gets evaluated first" is related to "how does it parse", but "how does it parse" is also not enough to answer "which thing gets evaluated first".
04:42:20 <lambdabot> Consider it noted.
04:42:36 <cocreature> __monty__: can you be a bit more specific? then it might be possible to help you :)
04:42:38 <dmwit> ?tell mbwgh (Indeed, "which thing gets evaluated first" can even depend on *the runtime values* involved.)
04:42:38 <lambdabot> Consider it noted.
04:42:42 <cocreature> eh ^ mupf
04:42:51 <tabaqui1> mupf: just do not use arch repos
04:43:11 <tabaqui1> stack from get.haskellstack.org
04:43:30 <tabaqui1> or ghc from repo and cabal from scratches
04:43:56 <mxf> mupf, I linked you before how to properly set up cabal on arch. Did that not work out for you?
04:44:09 <mxf> Curious why it broke for you
04:44:19 <__monty__> Or, get set up with nix and enjoy a next level experience ; )
04:45:02 <mupf> mxf: I got somehow the impression that ghc is broken and cabal works fine. Maybe I got something wrong. Well, I finally have some real time to set it up properly. Maybe I mixed something up.
04:45:03 <mxf> nix is going too far for my liking. The answer shouldn't be: Just install another Distro on your machine.
04:45:23 <__monty__> mxf: It's not a distro. It's just a better package manager : )
04:45:32 <mupf> Well, in case I buy a new computer soon I really consider using nix
04:45:32 <cocreature> mupf: cabal calls GHC so that seems weird
04:45:45 <hpc> __monty__: the package database is the distro
04:46:05 <mupf> https://paste.ubuntu.com/p/3Wy9n5JcHR/ this is what I get when I try to compile something
04:46:30 <cocreature> mupf: can you show us the output of "ghc-pkg list"?
04:46:50 <__monty__> hpc: Nope, disagree. You can use nix on Mac OS X, that's a clear enough indicator package manager /= distro.
04:46:51 <Cale> mxf: Well, you don't have to use it as a complete distro to get use out of the package manager and build system
04:46:54 <mupf> Oh, well. I just uninstalled everything haskell related to get a fresh start
04:46:56 <mupf> lol
04:47:08 <mupf> Maybe someone can guide me trough it (again)?
04:47:30 <cocreature> mupf: install ghc, ghc-libs and ghc-static from the arch repos. then get cabal from somewhere
04:47:31 <Cale> mxf: I use Linux Mint on my desktop machine, but use the nix package manager all the time to build projects.
04:47:44 <mupf> cocreature: alright, one moment
04:48:13 <cocreature> Cale: tbf nix is a bit more invasive than most other package managers to the point where calling it another distro isn’t entirely unreasonable
04:48:33 <Cale> Is it?
04:48:34 <__monty__> I use nix on two arch boxes and a mac. It's really non-intrusive. You get to pick exactly what you install with nix.
04:49:02 <__monty__> I wouldn't expect apt or yum to work out on arch let alone mac.
04:49:03 <cocreature> Cale: well it entirely ignores your existing system so it’s like you have two distros installed side-by-side
04:49:17 <Axman6> I'm trying to play with this new obelisk thing, and not having a lot of fun installing the entire universe using nix :\
04:49:25 <Cale> That also means it's nicely self-contained :)
04:49:42 <cocreature> sure I’m not saying it’s a bad thing but it’s quite different from the usual package managers
04:49:43 <Axman6> currently compiling GHC and python seems a bit much, surely there should be binary caches for these for mac
04:49:48 <Cale> Axman6: Are you missing caches?
04:49:55 <Cale> Ah... yeah there really should be
04:50:06 <Axman6> I've been trying to figure that out, but the docs aren't good
04:50:48 <mupf> cocreature: it worked out like a charm
04:50:58 <Axman6> I tried adding the one listed on the obelisk page from obsidian systems, but tht doesn't seem to have anything, and I can't for the life of me find where I'm supposed to find trustworthy caches for mac software
04:51:03 <cocreature> mupf: great!
04:51:06 <mupf> i can compile now
04:51:19 <mupf> thanks
04:51:45 <Cale> Axman6: One sec, let me see if anyone who would know about the status of the caches is up :)
04:51:56 <tabaqui1> good hardware, mupf
04:51:58 <Axman6> I've been trying to figure that out, but the docs aren't goodfor some reason runing nix-shell in the obelisk dir is compiling GHC 7.4.1, which seems insane
04:52:18 <tabaqui1> cabal install Cabal takes half an hour on my asus x200
04:52:22 <Axman6> uh, ignore the first half of that
04:52:48 <Axman6> I've been trying to run this for most of today, so far I've compiler and installed LLVM and Clang too
04:53:11 <mupf> tabaqui1: I have nothing special. intel i3, thinkpad edge e130
04:53:34 <cocreature> the premise of nix saving you compile time by having caches never seems to work out for me :/
04:53:34 <mupf> downloaded cabal binary and compiled the project generated using cabal init
04:53:53 <tabaqui1> mupf: ah, you didn't install Cabal from the sources
04:54:01 <Cale> Axman6: Yeah, that's definitely a cache miss, and you can consider it a bug, given that you have the binary caches set up correctly.
04:54:18 <Axman6> well, how do I know its set up correctly?
04:54:29 <Axman6> I can't even find where I'm supposed to set cache urls
04:54:30 <mupf> tabaqui1: no need to
04:54:34 <mxf> mupf, out of curiosity, where did you download cabal from?
04:54:53 <cocreature> mxf: cabal has official binaries https://www.haskell.org/cabal/download.html
04:55:03 <Axman6> since installing nix on macOS doesn't give you a /etc/nixos/configuration.nix, it's not clear where I am actually supposed to make changes
04:55:11 <mupf> mxf: https://www.haskell.org/cabal/release/cabal-install-2.2.0.0/cabal-install-2.2.0.0-x86_64-unknown-linux.tar.gz
04:55:15 <Cale> ahhhh
04:55:24 <Axman6> I added something that looked appropriate to /etc/nix/nix.conf but who knows
04:55:49 <merijn> Axman6: Maybe under /opt/local? That's where macports puts it's stuff
04:55:51 <Cale> yes, that's the correct file
04:56:37 <Axman6> I've tried to use nix many times, and every time I give up after a day of compiling the universe. it's incredibly frustrating
04:56:38 <Cale> binary-caches = https://cache.nixos.org https://nixcache.reflex-frp.org
04:56:38 <Cale> binary-cache-public-keys = ryantrinkle.com-1:JJiAKaRv9mWgpVAz8dwewnZe0AzzEAzPkagE9SP5NWI=
04:56:43 <mxf> cocreature, ah, I didn't know there was a website on haskell.org (and eh, haskell platform)
04:56:48 <Cale> you'll want it to contain something like that
04:56:58 <maerwald> there's also a nixos channel isn't there
04:57:58 <Cale> Axman6: is that roughly what you already had, or different?
04:58:00 <Axman6> Cale: I had the first line, not the second, but after changing that, it;s gone back to compiling python
04:58:07 <Cale> hmm
04:58:15 <mxf> I still find it strange that ghc comes with Cabal-the-library, but not with a mean to actually use it. Or do I miss something?
04:58:20 <Axman6> (and seemingly lost all the progress it had made in the last hour or so)
04:59:12 <maerwald> mxf: you mean a *frontend*?
04:59:21 <maerwald> you can *use* the library ;)
04:59:25 <Axman6> ... it also seems to be compiling GHC 7.8.4 with GHC 7.4.2... I'm surprised those even run on here
04:59:41 <Cale> Axman6: Which version of Mac OS X btw?
04:59:54 <Axman6> 10.13.4
05:00:20 <mxf> maerwald, yes, because instead of "Hello World" we haskellers like to code a package installer first :P
05:00:48 <Axman6> Cale: should this discussion be taken elsewhere?
05:01:07 <Cale> Maybe #reflex-frp would be better
05:01:30 <__monty__> Axman6, Cale: Or #nixos, since the folks over there are really helpful.
05:01:47 <Cale> __monty__: yeah, though this is a problem with a very specific nix cache :)
05:01:56 <exarkun> How do I make a QuickCheck Gen for String of length 16?
05:02:00 <maerwald> mxf: especially since Cabal-the-library has the most unreliable API
05:02:02 <Cale> It might be that we just haven't actually put all the right stuff in that cache yet
05:02:09 <mxf> I'd be curious how to get a cabal-install bootstrapping thing into ghc proper to make the experience for newcomers better
05:02:24 <merijn> mxf: People are against that for hysterical raisins
05:02:34 <noan> why doesn't Protolude expose a type alias from String to [Char]?
05:02:47 <cocreature> noan: because it wants you to use Text
05:02:59 <merijn> mxf: Although, tbh just installing a binary GHC and cabal-install works fairly smooth in my experience
05:03:06 <mxf> merijn, "People" should stop wasting others people time, to be frank.
05:03:24 <maerwald> let's not pull out this old tool war again
05:03:30 <mxf> haha, yeah
05:03:40 <maerwald> suffice to say there is enough bad blood that already wasted peoples time
05:03:44 <mxf> maybe -offtopic is better suited
05:04:04 <lyxia> exarkun: vectorOf 16 arbitrary :: Gen String
05:04:18 <noan> cocreature, ah, I assume then that Char is rather low level and lacks unicode support or something?
05:04:45 <cocreature> noan: no the problem is that a linked list of unicode characters is often a very inefficient representation of a unicode string
05:04:50 <mxf> merijn, sorry, I sounded a lot harsher than I meant to be. I hope I didnt step on anyones toes
05:04:58 <mxf> I didn't mean to offend
05:05:31 <lgas> hi.  is there any extension that will let you use a record update as a section, eg. allowing you to express (\u -> u {emailAddress = email}) as just ({emailAddress = email})?
05:05:48 <exarkun> lyxia: Okay I think that part makes sense... How do I make QuickCheck use it though?
05:06:21 <merijn> noan: Char is probably the most accurate unicode representation compared to most other language. Linked list of Char are just a terrible model for string processing
05:06:47 <merijn> noan: [Char] can easily take up 24 bytes *per character* on 64bit architectures due to all the indirection
05:06:48 <lgas> or I guess maybe something like "LambdaRecordApplication" or something to just get "\{emailAddress = email}"?
05:06:55 <jkiui> please suggest some beginner friendly book for c++
05:07:02 <lyxia> exarkun: quickCheck $ forAll (vectorOf 16 arbitrary) $ \s -> my_prop s   for example
05:07:04 <merijn> lgas: PRetty sure you want lens :)
05:07:05 <jkiui> Hello guys
05:07:14 <jkiui> Waiting for a reply
05:07:25 <merijn> lgas: Although, you might wanna have a look at the RecordWildCards extensions
05:07:35 <jkiui> Anybody here
05:07:44 <jkiui> Please suggest some book for c++
05:07:46 <exarkun> jkiui: You might want a different channel, perhaps #c++
05:08:07 <jkiui> ok thank you
05:08:08 <lgas> yeah I'm normally pretty lensy but just had a situation where I was trying to clean up some existing code without changing dependencies
05:08:13 <jkiui> and sorry
05:08:16 <jkiui> bye
05:08:19 <jkiui> exit
05:08:33 <merijn> noan: Text, on the other hand, is for storing big blobs of unicode text, and as such has a MUCH smaller memory footprint (about 2 bytes per character, plus some overhead every 1000 (or more) or so characters)
05:09:03 <lgas> in this case it was for a function being passed to Map.adjust so I don't think that RecordWildcards will help but I haven't used them that much so I'll review the docs and check
05:09:21 <lgas> thanks
05:09:59 <exarkun> lyxia: Hm.  And ... if I'm using Hspec? :/
05:10:35 <merijn> exarkun: Hspec is more of a higher level combined testing framework. I'm 95% sure there's a QuickCheck for Hspec library
05:10:59 <exarkun> merijn: There is but it doesn't appear to involve calling `quickCheck` directly.
05:11:08 <lyxia> exarkun: replace quickCheck with prop
05:12:01 <lyxia> hspec itself integrates QuickCheck :)
05:12:16 <cocreature> which SAT solver lib do people use these days?
05:12:21 <dminuoso> Let's say I have some `data A = A Int | B String | C (String, Bool)` and some [A] - is there some cheap trick to turn this into a kind of map (pseucode incoming) { A: [1,2,3], B: ["foo", "bar"], C: [("A", True), ("B", False) ]} ?
05:12:31 <cocreature> I just want something that I can throw a cnf at. I don’t need fancy observable sharing tricks like ersatz
05:12:51 <cocreature> and it doesn’t need to be pure Haskell
05:12:54 <Axman6> exarkun: you might not want to use the default Arbitrary Char instance btw, unless this was fixed it only generates ASCII characters
05:12:59 <dminuoso> Right now Im using list comprehensions with pattern matching: as = [x <- ]
05:13:07 <dminuoso> Err sorry enter key pressed too early
05:13:11 <merijn> dminuoso: M.unionWith (++) ?
05:13:30 <cocreature> Axman6: iirc that was fixed
05:13:35 <merijn> dminuoso: Combined with "map M.singleton" + some preprocessing
05:13:52 <Axman6> cocreature: was it fixed in QuickCheck or in Text thought?
05:13:57 <lyxia> @check \c -> c < '\128'
05:14:00 <lambdabot>  *** Failed! Falsifiable (after 8 tests):
05:14:00 <lambdabot>  '\304524'
05:14:00 <merijn> oh, wait, no that doesn't work
05:14:24 <cocreature> Axman6: quickcheck, take a look at the changelog for 2.10 https://hackage.haskell.org/package/QuickCheck-2.11.3/changelog
05:14:31 <dminuoso> merijn: Right now I have functions like: f as = [x | A x <- as]
05:14:32 <cocreature> “Random strings and characters now include Unicode characters by default.”
05:14:39 <Axman6> ah great
05:14:40 <dminuoso> merijn: For each constructor (and in reality there's a lot more)
05:14:56 <merijn> dminuoso: That's probably easiest, yeah
05:15:17 <exarkun> lyxia: what's `arbitrary` in the first expression you gave?
05:15:51 <exarkun> Oh, from Arbitrary?
05:16:10 <dminuoso> merijn: What bag of tricks would I have to grab into, if I wanted to express `getAll A` or `getAll B` in a type safe manner?
05:16:24 <lyxia> dminuoso: you could use generics + higher-kinded data. data A f = A (f Int) | B (f String) | C (f (String, Bool))   and define [A Identity] -> A [] with Generics.
05:16:32 <lyxia> exarkun: yes
05:16:35 <merijn> dminuoso: tbh, the list comprehensions is about as easy as it gets
05:16:58 <merijn> lyxia: Then you still have to write a comprehensions per constructor, so I don't think that helps much
05:17:37 <dminuoso> merijn: I have a feeling that TH would be necessary if I wanted something along those lines
05:17:57 <lyxia> ah right there are many constructors...
05:18:13 <merijn> dminuoso: Probably, yes
05:18:37 <dminuoso> Alright. So Ill write constructors now, then scrab my boilerplate with TH.
05:18:46 <dminuoso> Thanks for the input merijn and lyxia.
05:18:56 <lyxia> you can also filter by constructors with generics though...
05:19:54 <dminuoso> lyxia: Yeah at that point list comprehensions are probably still more compact.
05:21:10 <noan> merijn, thanks, I always assumed that the haskell compiler would do some "magic" in the special [Char] case actually for efficiency purposes
05:21:18 <noan> How wrong I was
05:22:09 <merijn> noan: For literals it does some magic, in the sense that literals are stored more densely inside binaries and there's some smart conversions functions in Text to efficiently convert them. Also general list fusion. But no, there's no magic
05:22:35 <merijn> noan: [Char] is nice for ease of manipulation, but as soon as you want to do more thorough text processing you want to grab Text
05:27:18 <Axman6> dminuoso: what about prisms?
05:27:49 <Axman6> each . having _A :: [A] -> [A] I think
05:27:59 <Axman6> :t each . having _Left
05:28:00 <lambdabot> error:
05:28:00 <lambdabot>     • Variable not in scope:
05:28:00 <lambdabot>         having
05:28:06 <Axman6> hmm
05:28:52 <merijn> Axman6: You'd still have to manually write the prisms and/or use TH to generate them
05:29:13 <Axman6> sure
05:36:20 <cemerick> I have a relatively simple cabal file that has two components, a library and a test-suite, and the latter depends on the former. `stack test` works just fine, but `stack ghci :tests` fails looking for the library's .so (though I see an appropriately-named .a in .stack-work). What should I be looking to tweak to fix this?
05:37:55 <merijn> cemerick: Did you add a dependency on your library in the test-suite?
05:38:12 <cemerick> merijn: yes, in build-depends
05:38:30 <merijn> cemerick: Ah, then maybe it's a mismatch between static and dynamic builds
05:38:38 <cemerick> I think something might be subtly wrong in my environment, as this absolutely used to work as-is
05:39:38 <cemerick> merijn: if it were just that, then blowing away .stack-work and running ghci should work, right?
05:39:53 <cocreature> cemerick: try "stack ghci --tests :tests"
05:40:18 <cocreature> s/--tests/--test"
05:40:30 <cocreature> and maybe a "stack build --test" before
05:40:51 <exarkun> lyxia: thanks
05:41:00 <dminuoso> :t having
05:41:01 <lambdabot> error:
05:41:01 <lambdabot>     • Variable not in scope: having
05:41:01 <lambdabot>     • Perhaps you meant one of these:
05:45:19 <cemerick> cocreature: ok, that works, and is super-super-silly
05:45:50 <cocreature> cemerick: yeah it’s quite confusing
05:47:30 <cemerick> entirely separate question: is there any place other than .stack-work that should be cleared to eliminate any prior cached build info? I moved some modules in the library from other-modules to exposed-modules, but the change isn't having an effect in ghci
05:48:34 <dminuoso> Axman6: what is `having` supposed to be?
05:48:54 <geekosaur> cemerick, did you restart ghci? it only checks the module db on startup
05:49:07 <Axman6> filter which works on optics
05:49:16 <Axman6> :t has
05:49:17 <lambdabot> Getting Any s a -> s -> Bool
05:49:17 <cemerick> geekosaur: yeah, not trying to :r or whatever
05:49:24 <Axman6> :t filtering
05:49:25 <lambdabot> error: Variable not in scope: filtering
05:49:30 <Axman6> :t filtered
05:49:31 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
05:49:34 <cemerick> separate `stack ghci --test :tests invocations
05:49:46 <dminuoso> Oh yes. `(Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a` looks exactly like I was missing...
05:49:48 <Axman6> :t filtered (has _Left)
05:49:48 <dminuoso> uh...
05:49:49 <lambdabot> (Applicative f, Choice p) => Optic' p f (Either b c) (Either b c)
05:50:08 <Axman6> :t each filtered (has _Left)
05:50:09 <lambdabot> (Applicative f, Choice p, Each (Either b c -> Bool) t (a -> Bool) (p a (f a))) => p a (f a) -> t
05:50:13 <Axman6> :t each . filtered (has _Left)
05:50:14 <lambdabot> (Applicative f, Each s t (Either b c) (Either b c)) => (Either b c -> f (Either b c)) -> s -> f t
05:50:15 <dminuoso> To a lens expert, can you tell what a lens does by staring at its type?
05:50:23 <dminuoso> (or optics in general I guess)
05:50:30 <Axman6> most of the time :)
05:50:40 <dminuoso> Huh okay. To me all of this is just garbled noise.
05:53:21 <Axman6> Applicative generally tells you you have a Traversal or Prism (which are instances of optics which can point to zero or more things). If you just have Functor it'll be Lens (roughly)
05:54:07 <cocreature> often the types are also more specialized, e.g., "view" take a Getting which gives you some idea on what it’s going to do
05:55:07 <dminuoso> Axman6: The Functor/Applicative bit is actually the one thing I understand why :)
05:55:55 <Axman6> :t \x -> _Left x
05:55:56 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
05:56:19 <Axman6> IIRC Choice tells you to have a Prism
05:57:02 <cocreature> I’d say most of the time it’s more a case of pattern matching the types against the things you know rather than actually thinking about what the constraints lets you do
05:57:08 <cocreature> e.g. you see Choice so it has to be a prism
05:57:17 <tabaqui1> btw, split-objs helped
05:57:22 <tabaqui1> I just cookied it wrong
05:57:26 <tabaqui1> thanks
06:01:17 <hasty> anybody here familiar with hedgehog?
06:01:38 <cocreature> hasty: just ask your actual question instead :)
06:02:57 <hasty> When I get a test failure for a golden test, hedgehog actually prints "\n" in my string rather then jumping to a newline
06:03:22 <hasty> prints "\n" in the example failure string
06:03:44 <geekosaur> guessing it uses show, in which case you likely can't change it
06:03:59 <hasty> I'd like it to jump to a newline (easier to read) rather than print "\n" contained in my string
06:04:08 <maerwald> I think this \n thing comes up so frequently, it should be part of fbut
06:04:10 <dminuoso> "prismatic profunctors"
06:04:31 <maerwald> well, it kinda is already I guess https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
06:04:46 <cocreature> hasty: what exactly do you mean by golden test here? last I checked hedgehog didn’t have any builtin support for golden testing
06:05:34 <bitonic> is there an easy way to list all the dependencies of a cabal package?
06:06:06 <xpika> is there a way to encode conditionals in such a way that the true/false sub expressions can be analysed independently of execution ?
06:06:12 <hasty> cocreature: `serialize data === "serialized_data"`
06:06:23 <hasty> and vice versa
06:07:16 <dminuoso> xpika: What exactly are you trying to do?
06:08:34 <cocreature> hasty: you’re probably going to have to implement your own version of (===) that doesn’t rely on Show
06:09:34 <ClaudiusMaximus> xpika: not sure what you mean, but i did some code generation with something like `if_ :: CodeGen m => Expr Bool -> m true -> m false -> m (true, false)`
06:09:45 <hasty> cocreature: cheers
06:10:01 <xpika> eg. do { a <- getFile “a.txt” ; if (length a > 10) then getFIle “b.txt” else getFile “c.txt” }  something like that . But in such a way that I could inspect all calls to getFile
06:10:39 <dminuoso> xpika: Haskell does not really have "calls to functions". What are you trying to do exactly?
06:10:56 <dminuoso> xpika: What information are you hoping to obtain?
06:12:07 <xpika> dminuoso: for instance, it would be nice to generate a list of all file references in my application. Provided of course my application was contained in a single expression tree.
06:12:58 <xpika> dminuoso: it would also be nice if I could declare such file references nested behind conditionals
06:13:51 <ventonegro> xpika: You can use a Writer monad and your `getFile` function could write the name of the file it just opened
06:14:22 <xpika> ventonegro: I would like do this kind of thing statcially, before the application runs
06:14:35 <xpika> I realize I may be asking quite a bit
06:14:45 <Kolany> what is this page? https://tinyurl.com/ya79dnx5
06:14:57 <ventonegro> xpika: How, given that you want to evaluate the `if`?
06:15:59 <xpika> ventonegro: that’s where I’m asking for guidance. Some way of capuring it in a data type.  Maybe the If monad haha
06:16:20 <Axman6> Kolany: there's no way anyone is clicking that
06:17:12 <cemerick> I previously thought that exposed-modules was what drove those loaded when ghci starts, but now I see it's entirely dependent upon the transitive import graph
06:17:24 <cemerick> Is there a way to get ghci to act like I *thought* it was acting? :-P
06:17:46 <ventonegro> xpika: It's not about monads... You can't evaluate which branch your application will take without running it
06:18:07 <Boomerang> cemerick: You could try `cabal repl` or `stack repl`
06:18:40 <ventonegro> xpika: Unless you do some sort of abstract interpretation
06:18:49 <cemerick> Boomerang: same thing; isn't `repl` just an alias for `ghci`?
06:18:59 <xpika> ventonegro: I’m really intrigued by the idea
06:19:16 <Boomerang> Sure but you get to specify one of the cabal targets and load all the exposed-modules
06:19:17 <xpika> ventonegro: I would like to apply it to things like databases as well as files
06:20:20 <Boomerang> cemerick: Or do you want all the modules to also be imported when you open ghci/repl?
06:20:53 <ventonegro> xpika: Sounds interesting indeed
06:21:12 <xpika> I feel like someone must have come up with something like this already
06:21:17 <xpika> I just need to keep looking
06:21:29 <ventonegro> xpika: https://en.wikipedia.org/wiki/Abstract_interpretation
06:21:33 <Boomerang> In that case I don't think there's a default way to do it, if you really need to reopen ghci often maybe import all the modules you want in a local .ghci file :)
06:21:56 <jchia_> Why do people use greek leters in their code? Is it just a matter of taste or is there some pragmatic reason? https://www.stackage.org/haddock/lts-10.10/mustache-2.3.0/Text-Mustache-Types.html#t:ToMustache
06:22:13 <jchia_> maybe it's clearer to read?
06:22:33 <Axman6> I hate it when people do that
06:22:47 <Axman6> if you want that in your code, do it in your editor, not in published code
06:22:53 <cemerick> Boomerang: I'm using `stack ghci --test :tests`. The tests target depends upon the library defined in the same cabal file, which specifies a set of exposed-modules. They're all loaded if I start a "regular" ghci, but only those imported by the test sources are loaded in the test ghci.
06:22:57 <barrucadu> jchia_: omega looks a bit like a moustache, so it's a pun there
06:23:03 <xpika> ventonegro: interesting ...
06:23:03 <dminuoso> Axman6: these identifers will not infest your code though.
06:23:13 <dminuoso> Axman6: as far as I can tell they just use it for type variable names.
06:23:33 * hackage ats-pkg 2.10.2.0 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-2.10.2.0 (vmchale)
06:23:35 <Axman6> but it adds an extra level of mental translation when reading it
06:24:29 <jchia_> barrucadu: I see. Didn't think of that, but I find it helps to make a distinction between the type variables and other things.
06:24:48 <jchia_> Axman6: Hard to edit, probably. Why do you hate it?
06:24:59 <Boomerang> cemerick: So you want do loads multiple cabal/stack target at once? test and library
06:25:31 <Boomerang> I don't think that's possible in cabal, no idea for stack. In raw ghci you could do: ghci -isrc -itest test/Main.hs
06:26:01 <Axman6> jchia_: I find it more difficult to read too
06:27:57 <jchia_> i c
06:27:58 <jchia_> Between mustache & stache, I'm trying to pick one. Any comments?
06:29:18 <jchia_> I have a simple template, not in a separate file, but in my code, and a list of data that i want to use to render the template
06:29:37 <cemerick> Boomerang: ok, I just need to specify both "targets", e.g. `stack ghci --tests projectname:lib :tests`
06:30:12 <Boomerang> cemerick: Cool I didn't know that worked in stack :D Good to know
06:30:37 <cemerick> It'd be nice to have a shortcut like :tests for the main library target
06:31:34 * hackage baserock-schema 0.0.1.1 -   http://hackage.haskell.org/package/baserock-schema-0.0.1.1 (locallycompact)
06:37:33 * hackage baserock-schema 0.0.1.2 -   http://hackage.haskell.org/package/baserock-schema-0.0.1.2 (locallycompact)
06:38:28 <Boomerang> Quick iteration times on baserock-schema! :D
06:40:29 <exarkun> What's wrong with `Prelude.map Prelude.concat ["foo" :: Data.ByteString.ByteString]`?
06:41:52 <lyxia> exarkun: concat expects a list of lists, but map applies it to a ByteString
06:42:29 <exarkun> What about just `Prelude.concat ["foo" :: Data.ByteString.ByteString]`?
06:43:42 <lyxia> that's a list of ByteString, which is not a list of lists.
06:44:32 <ventonegro> :t map concat
06:44:33 <lambdabot> Foldable t => [t [a]] -> [[a]]
06:45:17 <ventonegro> :t map concat @[]
06:45:18 <lambdabot> error:
06:45:18 <lambdabot>     Pattern syntax in expression context: concat@[]
06:45:18 <lambdabot>     Did you mean to enable TypeApplications?
06:45:32 <ventonegro> meh
06:45:43 <geekosaur> % :t map concat @[]
06:45:43 <yahb> geekosaur: ; <interactive>:1:1: error:; * Cannot apply expression of type `[t0 [a0]] -> [[a0]]'; to a visible type argument `[]'; * In the expression: map concat @[]
06:45:50 <geekosaur> heh
06:46:20 <geekosaur> % :t map (concat @[])
06:46:20 <yahb> geekosaur: [[[a]]] -> [[a]]
06:48:17 <mbwgh> In `newtype UnliftIO m = UnliftIO { unliftIO :: forall a. m a -> IO a }`, the wrapped function is Rank2, not existential. What would be the GADT equivalent?
06:49:42 <mnoonan_> isn't it just "data UnliftIO m where UnliftIO :: (forall a. m a -> IO a) -> UnliftIO m"?
06:51:18 <mbwgh> would `data UnliftIO m where UnliftIO :: forall a. (m a -> IO a) -> UnliftIO m` be the existential variant then?
06:54:38 <S11001001> mbwgh: yep. kind of unusable though unless you have a forall a. m a
06:55:58 <mbwgh> Ok, thanks. Just wanted to clear up the syntactic concept
07:00:17 <tabaqui1> do you know some good http(s) library without zlib dependency?
07:00:23 <tabaqui1> s/some/any
07:00:38 <tabaqui1> performance doesn't matter
07:01:13 <cocreature> tabaqui1: any specific reason why you want to avoid a dep on zlib?
07:03:17 <tabaqui1> cocreature: we describe this component as "cross-platform, simple, not requiring installation application"
07:03:27 <tabaqui1> that is the reasone why I'm using hs-tls instead of tls
07:03:59 <glguy> What's hs-tls?
07:04:37 <tabaqui1> err, tls instead of openssl
07:05:01 <tabaqui1> it's github page named as hs-tls
07:05:31 <geekosaur> there's a pure haskell implementation of the haskell zlib api but I'm guessing you need to custom build other stuff to use it instead of zlib
07:06:22 <geekosaur> if you're really lucky, something may already have a cabal flag for it. no, I don;t know what currently, and as the hackage package list has been failing to load for me (browser choking on css?) ever since the latest upgrade I can;t easily check
07:06:32 <tabaqui1> Is it simplier than writing simple specific http client?
07:07:12 <geekosaur> since the interface is supposed to be drop-in identical it's likely jut changing the dependency in the cabal file. or seeing if there's already a flag to do so
07:07:59 <cocreature> if your only goal is to make something self-contained I would just bundle zlib with your app
07:08:59 <maerwald> bundling zlip is a good way to introduce vulnerabilities long-term
07:09:03 <jchia_> Here I see warning options start with '-fwarn': http://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/options-sanity.html Here I see they start with '-W': https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html Why the difference? So, e.g. there's -fwarn-tabs and -Wtabs. How come? Is it just newer GHC having a different way of specifying options?
07:09:24 <merijn> jchia_: -W is the new future way for warnings
07:09:26 <glguy> GHC migrated to the -W flags for warnings
07:09:29 <merijn> jchia_: -f is historical
07:09:38 <jchia_> -f still supported for backward compatibilty?
07:09:43 <merijn> jchia_: Yes
07:09:46 <jchia_> OK
07:10:11 <geekosaur> and -W because that's what other compilers use these days
07:10:24 <geekosaur> and -fblah is kinda horribly overloaded anyway
07:11:00 <geekosaur> (there's intended to be more flexibility in warnings/errors in the future, and making -f support that without breaking every other -f option would be a nightmare)
07:11:25 <tabaqui1> geekosaur: anyway, I'll try first with pure zlib
07:11:33 <tabaqui1> can you tell me a package name, please?
07:11:50 <geekosaur> yes, let me just load the page I just told you I can;t load
07:19:33 <mbwgh> merijn: I wanted to ask a few more questions yesterday about what we were talking about concerning transformers and unliftio, but it seems you had to leave. Did I understand you correctly in the vague sense that the UnliftIO approach gives you the best of two worlds, in being able to "reify the handle" and not having to pass the dictionary around? Also, since the "batteries included" package of unliftio
07:19:39 <mbwgh> comes with a LoggingT instance, and you mentioned it yourself, what's your opinion on transformer based logging?
07:22:07 <mbwgh> merijn: And thanks for reminding me of the package in the first place. I gave it another look, and at first glance, liked what I saw.
07:33:33 * hackage baserock-schema 0.0.1.3 - Baserock Definitions Schema  http://hackage.haskell.org/package/baserock-schema-0.0.1.3 (locallycompact)
07:33:51 <maerwald> hm, seems clojurescript is a competitor to ghcjs
07:35:06 <merijn> mbwgh: UnliftIO is basically "grab the handle out of ReaderT and apply runReaderT (or whatever transformer specific version for stuff like LoggingT) to get an "IO a" out of "m a", yes"
07:35:40 <merijn> mbwgh: monad-logger mostly seems pretty nice from what I've used it for so far
07:38:22 <merijn> mbwgh: Basically, suppose I'm in an "m a" block and I have another "foo :: m a", where m is some sort of ReaderT (or stack of multiple) obviously you can trivially just do "v <- ask; runReaderT foo v" to unwrap foo into an "IO a", and UnliftIO just generalises that across (potentially many) transformer layers (like LoggingT, etc.) so if you use the handle pattern plus a custom (newtyped?) transformer for
07:38:28 <merijn> it, you can make it UnliftIO and and pass it to IO callbacks
07:38:44 <merijn> mbwgh: Anyway, I have to run again, so... ;)
07:39:19 <mbwgh> merijn: You are a busy man.
07:39:55 <mbwgh> merijn: But thanks again
07:42:18 <__monty__> maerwald: I think clojurescript's still more mature but it's clojure...
07:43:27 <mbwgh> Is clojure not held in high regard around these parts?
07:44:42 <cemerick> I have a couple of numeric constants that I've put in top-level definitions, without any type annotations. Later in the module, I want to use them in different circumstances, but their types are being constrained such that the compiler complains
07:44:44 <dminuoso> If I want to augment binary's Get monad with failures (because the data might be bad), would I just use use ExcepT?
07:45:09 <cemerick> Shouldn't those constants be specialized to suit each usage?
07:45:56 <guillaum2> Is there any reason Int (Prelude.Int) and Data.Int.Int64 should be different?
07:46:02 <mbwgh> cemerick: It could be that they are inferred as Double or Integer due to the monomorphism restriction
07:46:03 <__monty__> mbwgh: The only issue I have with clojure is rich's disdain for type systems.
07:46:44 <cocreature> guillaum2: yes, if you’re on a 32bit system
07:47:14 <cocreature> dminuoso: I guess the MonadFail instance is not sufficient for you?
07:48:30 <cemerick> mbwgh: they're definitely being constrained to a type appropriate for _one_ of the usages in the file, which makes me think that it's not that sort of defaulting?
07:50:03 <cocreature> cemerick: you can compile with -XNoMonomorphismRestriction to see if that’s the problem
07:50:07 <lyxia> cemerick: it's not defaulting, but it's not inferring a polymorphic type for those constants.
07:50:39 <cemerick> mbwgh: (also, I'm fundamentally a lisper, but there's not really much of a basis for dialogue between Clojure and e.g. Haskell. Sort of like expecting photographers and musicians to commiserate re: materials)
07:52:11 <guillaum2> cocreature: (good point, this aside, no other reason? I'm observing a 10x performance differenc on a trivial benchmark)
07:52:54 <Boomerang> cemerick: You could also put a type signature for those constants: a, b, c, d :: Num a => a
07:54:17 <mbwgh> cemerick: If nothing helps, maybe a minimal example would be in order
07:54:53 <cemerick> Boomerang: nope, tried that before
07:55:01 <cemerick> mbwgh: you got it, monomorphism, /ht cocreature
07:55:04 * hackage bhoogle 0.1.2.7 - Simple terminal GUI for local hoogle.  http://hackage.haskell.org/package/bhoogle-0.1.2.7 (andrevdm)
07:55:08 <cemerick> whew, that was painful
07:55:33 <mbwgh> The monomorphism restriction just has to go
07:55:36 <cemerick> I thought of monomorhpism, but was under the impression it only applied to functions, etc
07:55:58 <cocreature> guillaum2: you could have rewrite rules or specializations that only apply to Int. is your benchmark public?
07:56:12 <cemerick> mbwgh: I really don't understand why it should apply to constants. Will have to re-read the relevant material, but that seems nuts
07:57:26 <cocreature> cemerick: the reason why we have the monomorphism restriction is that you usually expect values to behave like values, i.e., they are computed only once
07:57:39 <cocreature> cemerick: now if your value is polymorphic it will be computed multiple times
07:58:02 <cocreature> cemerick: obviously that’s not a problem if you just have something like x :: Num a => a; x = 1 but x could be very expensive to calculate
07:58:53 <cemerick> cocreature: note that I'm talking about literal constants, e.g. x = 123
07:59:27 <cocreature> cemerick: right but the monomorphism restriction is based on the type not on how you define the value
07:59:32 <cemerick> I take the point re: constant expressions, but that's not this
07:59:39 <cocreature> cemerick: so x = 123 behaves identically to x = veryexpensivecomputation
07:59:56 <guillaum2> cocreature: I'm creating a minimal example.
07:59:57 <cemerick> so I've learned! ;-P
08:00:53 <geekosaur> note that ghc relies on this a bit, since a String constant gets unpacked at runtime so isn't quite as cheap as e.g. an Int constant
08:01:40 <mbwgh> Wasn't there a proposal about string literals?
08:02:00 <cemerick> tests passing happily, thanks again mbwgh, cocreature
08:02:28 <geekosaur> proposal? you may be thinking of OverloadedStrings which has been around for a while
08:03:08 <geekosaur> but this is about String being [Char] which is inefficiently stored, so specifically String literals are stored in a (ghc-internal) packed form and unpacked at runtime
08:03:59 <geekosaur> of course mitigating this at least somewhat is that lists are lazy so the whole thing isn't necessarily unpacked in one go
08:04:23 <mbwgh> geekosaur: https://github.com/ghc-proposals/ghc-proposals/pull/124
08:04:39 <mbwgh> geekosaur: I am not sure if it applies though
08:04:50 <guillaum2> cocreature: https://gist.github.com/guibou/5bd16f862c6a0011c6179100660219ca
08:05:24 <cheater> when i do runghc Setup.hs repl, every time i do this everything gets recompiled. how do i prevent that? i don't want everything recompiled, just the files that change.
08:05:39 <geekosaur> I think that's more general and may be more an appeal to get e.g. Text literals
08:05:52 <geekosaur> which currently get unpacked to String and repacked to Text
08:05:54 <geekosaur> at run time
08:06:36 <geekosaur> also stuff like compile-time-checked IP addresses, which some http packages care about
08:07:36 <mbwgh> Well if you care about text performance, you would use text anyway, so I thought this was the kind of thing you were talking about
08:08:08 <cocreature> guillaum2: I’ll take a look in a few minutes
08:08:20 <geekosaur> no, I was just talking about the fact that the ghc runtime currently depends on "literals" not actually being literal
08:08:39 <geekosaur> another example is numeric literals being implicitly wrapped in fromInteger or fromRational
08:09:58 <guillaum2> cocreature: thank you. Actually replacing the `product [1..n]` by a manual tail recursion gives similar results for Int and Int64, so your hypothesis about a broken rewrite rule / specialization may be right
08:10:12 <geekosaur> so the machinery (and overhead) to support that has to be there anyway, which limits what you might get from doing it at compile time
08:10:48 <geekosaur> potentialluy limits at least
08:12:11 <cocreature> guillaum2: looks to me like it’s enumFromTo
08:17:52 <guillaum2> cocreature: indeed, -ddump-rule-firings show something like that. I'll open a bug
08:18:10 <cocreature> guillaum2: if you take a look at the core, the Int64 version doesn’t fuse
08:19:30 <sclv> geekosaur: just saw in scrollback that hackage doesn't work for you!?
08:19:34 <sclv> eek
08:19:43 <dminuoso> cocreature: Isn't MonadFail supposed to be for non-pattern matches in list comprehensions?
08:19:50 <sclv> (fyi, you can still get the old interface at http://hackage.haskell.org/packages/ if that helps...)
08:19:55 <dminuoso> Or wait.. pattern matches on <-
08:20:10 <cocreature> dminuoso: well that’s one usecase but nothing stops you from using it for something else
08:20:23 <geekosaur> sclv, page load freezes before anything renders. also happens sometimes (reproducibly but don;t recall examples right now) on random haddock pages
08:20:27 <cocreature> dminuoso: and Get’s instance looks quite reasonable if all you want is to fail early and produce an error message
08:20:45 <geekosaur> browser acting like some resource is blocking forever instead of loading
08:22:05 <__monty__> sclv: Aw, you got my hopes up there was still a way to use hackage with the old theme : (
08:22:38 <sclv> geekosaur: so like no new css theme works for you at all?
08:22:44 <sclv> or rather no page with the new css?
08:22:47 <geekosaur> chrome Version 66.0.3359.181 (Official Build) (64-bit) linux/debian, console shows no errors, page load just freezes without rendering anything
08:22:55 <dminuoso> cocreature: Well it feels shabby to use a generalized abstraction when I want to rely on the specific implementation of this monad.
08:23:16 <geekosaur> (haddocks sometimes freeze partway through. likewise parts of the ghc manual, which also makes me think might be some common js or css resource)
08:23:30 <sclv> there's no common resource between them afaik
08:23:39 <geekosaur> interesting
08:23:49 <dminuoso> cocreature: Is there a relationship with Alternative? That is will `fail` give me an empty?
08:23:51 <cocreature> dminuoso: that seems silly. if you are just using a specific instance that’s totally fine.
08:23:59 <dminuoso> Fair enough
08:24:15 <sclv> except maybe some of them embed jquery?
08:24:22 <geekosaur> huuuh. apparently latest chrome reload eventually did manage to load the packages list. maybe it's a browser bug and they're getting a handle on it
08:24:24 <sclv> but like... everything does these days :-)
08:24:32 * sclv feels relief
08:24:55 <cocreature> dminuoso: the only law that MonadFail requires is that fail s >>= f = fail s
08:25:08 <geekosaur> also that was loading the old page, not the new one; I hadn't realized it moved
08:49:49 <sclv> geekosaur: yeah the new one might actually be better for the browser? not sure tbh.
09:04:59 <lamba_> hello, I'm wondering what parsing library would you use if megaparsec was overkill and you want something not more powerful than regex?
09:05:26 <cocreature> lamba_: regex-applicative maybe?
09:05:26 <lamba_> also I remember there was a website for good default libraries but I cannot remember the name
09:05:58 <cocreature> although I would probably still use megaparsec, it’s reasonably light on deps and the additional features don’t get in your way ime
09:07:00 <lamba_> cocreature, sounds good
09:08:07 <lamba_> i'm not really going to need any more power so instead of learning to use megaparsec regex-applicative seems great
09:22:03 * hackage crawlchain 0.3.0.1 - Simulation user crawl paths  http://hackage.haskell.org/package/crawlchain-0.3.0.1 (axm)
09:34:46 <cheater> does anyone know why runghc keeps on rebuilding those projects?
09:35:01 <cheater> does it always do that? is there a way to cache with runghc?
09:36:55 <davean> cheater: thats not really what runghc does - if you want that why aren't you actually building it?
09:37:56 <davean> cheater: to quote, "runghc allows you to run Haskell programs without first having to compile them."
09:38:14 <cheater> right, yeah
09:38:26 <cheater> what is the alternative to running runghc Setup.hs repl?
09:38:29 <geekosaur> runghc is an interpreter, not a compiler. there are no bytecode files.
09:38:32 <cheater> i don't have cabal in this project.
09:38:49 <davean> cheater: cabal is
09:38:53 <davean> so, make a cabal file
09:38:59 <davean> or, you could compile Setup.hs
09:39:03 <davean> using ghc its self
09:39:03 <cheater> i have a cabal file, but cabal is not available on this system
09:39:08 <davean> though really, just add cabal
09:39:15 <davean> you can just compile cabal if you have GHC
09:39:19 <davean> which you clearly do
09:39:24 <davean> but you can also compile Setup.hs
09:39:25 <cheater> is there a way to do this with ghc
09:39:42 <davean> yes, compile Setup.hs, but it'll still have to recompile everything else ...
09:41:22 <geekosaur> in theory there might also be making repl use -fobject-code, but you then lose a decent chunk of ghci functionality
09:41:40 <geekosaur> and no, if you want that functonality, it must reinterpret the sources
09:42:32 <geekosaur> if you really want that to change, making bco saveable and loadable is something that's been languishing in the ghc bug tracker for several years because nobody's had the time or sufficient inclination
09:42:55 <geekosaur> but beware you're likely to run into bugs, such as the bco backend not being able to tell boxed and unboxed tuples apart
09:48:02 <davean> cheater: why are you against just installing cabal thouhg?
09:48:15 <davean> If you can compile and run this thing, you can install cabalq
09:49:00 <davean> we know oyu can create files, and interact with the system, and have ghc to compile it with, which is all you need.
09:59:34 * hackage data-diverse-lens 4.1.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  http://hackage.haskell.org/package/data-diverse-lens-4.1.0.0 (louispan)
10:07:22 <cheater> davean: this is inside a nix build, and i don't know how to make it provide cabal.
10:08:11 <cheater> (i'm finding out)
10:24:33 * hackage tintin 1.4.5 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.4.5 (NickSeagull)
10:34:03 <jchia_> GHC is emitting a -Wredundant-constraints warning on a type synonym definition under ConstraintKinds. Is that reasonable?
10:34:27 <jchia_> How could GHC know whether the constraint is redundant?
10:34:45 <jchia_> It's only a type synonym, not an actual function.
10:35:13 <jchia_> type Parser a =
10:35:13 <jchia_>   forall m e s . ( MonadReader DatePair m, SS.MonadState (Int, HM.HashMap Sym SymRec) m
10:35:13 <jchia_>                  , MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => m a
10:35:23 <jchia_> The warning is on the "IsString (Token s)"
10:39:38 <cocreature> jchia_: it could be redundant if it is implied by one of the other constraints. e.g. a superclass on MonadParsec or something like that
10:41:26 <jchia_> cocreature: I haven't analyzed that yet, but removing the constraint breaks the compilation.
10:46:42 <dmwit> jchia_: If removing the constraint stops it from compiling, then getting a redundant constraint warning about it sounds like a bug to me.
10:47:08 <cocreature> yeah doesn’t sound very redundant :)
10:49:16 <jchia_> cocreature, dmwit: Actually it's user (my) error. The error was on a line that used the type synonym, not the line that defines it.
10:49:24 <jchia_> I mean "the warning"
10:55:25 <cocreature> ah that makes more sense
11:07:33 * hackage rainbox 0.20.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.20.0.0 (OmariNorman)
11:08:35 <jchia_> I defined Semigroup and Monoid instances for a newtype that has one type parameter. I got a GHC error that suggested using UndecidableInstances. Is there another way? https://gist.github.com/jchia/316dff3a66366ecf0efcb1aeac82ad11
11:09:13 <jchia_> I'm concerned about compilation time and more cryptic error messages if I unable UndecidableInstances
11:09:59 <jchia_> Incidentally, I'm not sure whether mappend should be based on (<>) or on the mappend for a
11:10:16 <cocreature> UndecidableInstances are not as bad as their name suggests
11:10:44 <cocreature> GHC has a very conservative check for ensuring that instance resolution terminates, UndecidableInstances turns that off
11:10:57 <cocreature> in the worst case, you produce a loop at compile time
11:11:14 <EvanR> usually you do instance Monoid a => Monoid (MyCoolType a)
11:11:16 <jchia_> cocreature: I'm mostly concerned about compilation time.
11:11:52 <cocreature> UndecidableInstances shouldn’t increase compile time for reasonable code. ofc if you produce an infinite loop then your compile times are quite large :)
11:12:20 <lyxia> jchia_: just make it (Monoid a), or (Semigroup a, Monoid a) if your Semigroup is not a superclass of Monoid.
11:12:41 <jchia_> EvanR: With the new "Semigroup a => Monoid a" requirement, do you just do "Monoid a => (Monoid (MyCoolType a))" plus "Semigroup a => (Semigroup (MyCoolType a))"?
11:13:15 <lyxia> yes, Monoid implies Semigroup
11:13:40 <jchia_> lyxia: I encountered this error as part of trying to make my types conform to the new requirement in 8.4 that Semigroup is a superclass of Monoid.
11:14:22 <jchia_> Then should I define the mappend of the newtype in terms of its (<>) or the mappend of the inner type?
11:14:53 <cocreature> if you’re using 8.4 you don’t need to define it at all
11:15:18 <jchia_> I'm using 8.2 trying to make my code 8.4-ready
11:15:21 <lyxia> either is fine, so mappend = (<>)
11:18:51 <jchia_> I suppose the new Semigroup a => Monoid a requirement in 8.4 just entails the use of UndecidableInstances for newtypes like the one I have.
11:19:50 <sclv> i don't think that the Semigroup => Monoid thing should change the need for undecidable instances or not
11:19:57 <sclv> if you needed it before, you needed it after
11:19:58 <dmwit> jchia_: Others have said it, but just to be explicit about the solution being proposed: since you know `Semigroup a => Semigroup (CdRoot a)`, you can always replace a `Semigroup (CdRoot a)` constraint with a `Semigroup a` constraint.
11:20:02 <sclv> and if you didnt you still shouldn't
11:20:08 <sclv> right
11:20:37 <dmwit> jchia_: ...and if you do, the constraint will be smaller than the head.
11:20:39 <jchia_> sclv: In 8.2, I can define Semigroup and Monoid separately
11:20:45 <sclv> right
11:20:45 <jchia_> without the =>
11:21:36 <sclv> see what dmwit said
11:22:52 <dmwit> Then whether you can replace `(Semigroup a, Monoid a)` with just `Monoid a` depends on which `base` you're using. But the other replacement depends only on code you've shown us and not at all on how `Monoid`, `IO`, or `Semigroup` are defined.
11:23:02 <cocreature> to make this explicit: if you use "instance (Monoid a, Semigroup a) => Monoid (CdRoot a) where …" you don’t need UndecidableInstances and your code works with 8.2 and 8.4
11:23:12 <cocreature> if you care about the redundant constraint, you probably need CPP
11:23:26 <jchia_> dmwit: Thats a good point. Did someone else say it just now?
11:23:39 <jchia_> Maybe I missed it
11:29:02 <jchia_> It didn't occur to me that I could help GHC with type inference by 'reducing' the constraint on the LHS of the '=>'. It's counter-intuitive to me.
11:29:45 <jchia_> Thanks for the discussion.
11:39:44 <dysfun> if you're using a lot of extensions, deleting things is helpful more often than i'd like to admit
11:47:32 <exarkun> I have `type ShareNumber = Integer`.  But only non-negative integers are valid.  Should I make this `data ShareNumber = ShareNumber Integer` with a public constructor that enforces non-negativeness?
11:48:14 <exarkun> And with `type ShareNumber = Integer` it doesn't seem like I can make a QuickCheck Arbitrary instance to generate only non-negative integers because there's already an Arbitrary Integer instance.
11:48:46 <pavonia> newtype is the better choice here, I think
11:48:47 <exarkun> Another reason to make it an algebraic type?
11:48:58 <fishythefish> you probably want newtype, but same idea
11:48:58 <exarkun> pavonia: ah?
11:49:23 <exarkun> guess I should learn about newtype.
11:49:52 <fishythefish> newtype is like data for when you have a single unary constructor but eliminates the runtime overhead data would introduce
11:50:19 <fishythefish> it also allowed for stuff like GeneralizedNewtypeDeriving and so on (which you don't need here), and has different strictness properties (which you probably don't care about here)
11:50:24 <fishythefish> allows*
12:13:41 <mupf> Haskell is still a bit confusing. Still waiting for that enlightening moment
12:15:23 <benzrf> hehe
12:15:27 <benzrf> mupf: what's the latest confusoin?
12:16:32 <EvanR> that moment when you feel compelled to write a monad tutorial
12:17:03 <mupf> I just started with cis194 because graham huttons book confused me a little. so, guess I'm just struggling getting used to this kind of language. nothing in particular.
12:17:36 <machinedgod> EvanR: That moment when you fail at a tech interview because you used a monad (in Java), and your interviewer doesn't know what a monad is
12:17:42 <mupf> I had literally no problem learning C. It felt straight forward.
12:18:10 <EvanR> if you had learned haskell first, and never heard of C, maybe the it would be the opposite
12:18:18 <EvanR> because honestly C makes no sense in some cases
12:19:00 <mupf> e.g.?
12:19:15 <EvanR> however there are elements that C programmer haskell students can draw correlaries to
12:19:27 <EvanR> sum types correspond to tagged unions in C
12:20:20 <EvanR> lets not get into some vagaries of C semantics
12:20:52 <ddellacosta> mupf: FWIW I think your experience is pretty common (reminds me of mine, certainly). Stick it out and I promise you'll have not just one but multiple enlightening moments which will make up for the confusion you're feeling now.
12:21:46 <ddellacosta> there's a lot of generality to get comfortable with in Haskell, which I personally think is the biggest challenge--C and most other languages tend to be a lot more concrete right out of the gate
12:22:28 <ddellacosta> (not to dismiss EvanR's point about "what if you learned Haskell first?")
12:22:44 <mupf> ddellacosta: thanks. I will stick it out for sure
12:22:52 <EvanR> my point is purely hypothetical, everyone and their dog has learned C or similar first, and then has to unlearn it to learn haskell
12:23:24 <ddellacosta> yeah, EvanR, I definitely think that's a valid point to make
12:24:29 <ddellacosta> what's embarrassing is how much better at Haskell my dog is compared to me
12:24:51 <EvanR> http://www.indiana.edu/~jkkteach/Q550/Pennings2003.pdf
12:25:07 <ddellacosta> haha, nice
12:25:43 <ddellacosta> "Now, back to Elvis. I noticed when playing fetch with Elvis that he uses the third strategy of jumping into the lake at D. It also seemed that his y values were roughly proportional to the x values."
12:25:46 <ddellacosta> I love this
12:26:04 <EvanR> i know
12:31:13 <EvanR> looking for study into dogs doing haskell
12:32:26 <sword_smith> Hi, I have an expression which I don't know how to write. It does not seem to work with nested where subexpressions. In the 1st where there are two definitions that share specific values. How do I declare values that are in scope of both these definitions?
12:32:47 <Rembane> sword_smith: A where expression might help you there.
12:32:51 <Rembane> sword_smith: Or a let ... in.
12:33:20 <__monty__> sword_smith: You can only have one where clause that applies to all the equations.
12:33:25 <cocreature> sword_smith: use a "case" expression instead of pattern matching on the lhs of the equal sign and then you can share the definition using a "where"
12:33:31 <ddellacosta> sword_smith: can you give us an lpaste or gist or something?
12:33:49 <sword_smith> ddellacosta: Yes.
12:34:04 <__monty__> So I'm completely wrong? Where am I getting my where understanding from?
12:36:33 <EvanR> where is not an expression
12:36:41 <EvanR> unlike let x = _ in _
12:36:44 <sword_smith> EvanR: What is it then? :)
12:36:48 <sword_smith> https://pastebin.com/qCg8m9C1
12:37:05 <__monty__> A syntactic construct.
12:37:06 <EvanR> its a container of expressions you can attach to a declaration, or a case alternative
12:37:39 <EvanR> a limitation which can cause confusion
12:38:11 <ddellacosta> sword_smith: can you simply put all of these in the same where term? I don't see why you want the nesting
12:38:33 <ddellacosta> this still looks like pseudo-code, may be helpful to see what you're actually trying to do here
12:39:00 <sword_smith> ddellacosta: I am putting together opcodes for a compiler.
12:39:17 <sword_smith> concatenating them
12:40:19 <cocreature> sword_smith: why are you nesting the definition of valueA instead of defining it on the same level as value0?
12:40:47 <sword_smith> ddellacosta: I see what you mean by not nesting them. I will try to put them all on the same level and see how that works. Thank you.
12:41:07 <ddellacosta> sure thing
12:44:50 <crestfallen> hi any interesting and illustrative examples of this ? :
12:44:57 <crestfallen> :t map map
12:44:58 <lambdabot> [a -> b] -> [[a] -> [b]]
12:45:20 <EvanR> :t fmap fmap
12:45:21 <lambdabot> (Functor f2, Functor f1) => f1 (a -> b) -> f1 (f2 a -> f2 b)
12:45:32 <EvanR> :t fmap . fmap
12:45:34 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
12:45:39 <ddellacosta> crestfallen: more generally https://github.com/ekmett/lens/wiki/Derivation ?
12:45:42 <crestfallen> no capice
12:46:07 <crestfallen> capiche
12:46:28 <crestfallen> read: no capiche
12:46:37 <ddellacosta> crestfallen: what were you looking for exactly when asking that question?
12:47:30 <crestfallen> it was an example of determining unification  https://stackoverflow.com/questions/17148385/unifying-types-in-haskell    I wanted to see how it works
12:48:25 <crestfallen> or inferring one type as per Evan*R 's preferred term.
12:48:47 <ddellacosta> ah okay
12:49:20 <EvanR> infer the type of map map (\x -> x >>= (\y -> y))
12:49:45 <crestfallen> ddellacosta, thanks for that link . a wider menagerie of types I will certainly read that
12:50:12 <crestfallen> >  map map (\x -> x >>= (\y -> y))
12:50:13 <ddellacosta> crestfallen: yeah sorry, after seeing that SO I think I was kind of coming out of left field there...probably because my mind is on lens lately. But glad if you find it useful!
12:50:14 <lambdabot>  error:
12:50:14 <lambdabot>      • Couldn't match expected type ‘[a -> b]’
12:50:14 <lambdabot>                    with actual type ‘m0 (m0 b0) -> m0 b0’
12:50:48 <crestfallen> it'll prolly confused me but thanks :)
12:50:56 <crestfallen> confuse*
12:51:04 <ddellacosta> crestfallen: bookmark it and ignore it for now if so!
12:51:15 <crestfallen> EvanR what's that?
12:51:22 <EvanR> what
12:51:43 <crestfallen> I don't know the notation >>=
12:51:49 <fishythefish> :t (>>=)
12:51:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:52:18 <crestfallen> sorry not there yet. Is there a way to see map map in use that I could understand?
12:52:39 <crestfallen> or should I forego it
12:53:09 <EvanR> the exactly problem is whats asked in that SO post
12:53:12 <EvanR> exact*
12:53:21 <EvanR> so, back to "understand the question"
12:54:08 <fishythefish> > zipWith ($) (map map [(+1), (*2)]) [[1, 2], [3, 4]]
12:54:11 <lambdabot>  [[2,3],[6,8]]
12:54:27 <oisdk> Hey, so if I want to use a CPP macro to conditionally use some new function in base (oneShot, in my case), how do I know what conditions to use in the macro?
12:55:12 <oisdk> Should it be MIN_VERSION_base(...) or __GLASGOW_HASKELL__(...)? Where can I find the point where that particular function was first included?
12:55:45 <crestfallen> fishythefish, thanks you're a patient person
12:58:03 <noan> crestfallen, many in the haskell community generally are
12:58:31 <crestfallen> cool. Everyone is supercool
12:58:41 <fishythefish> the `map map` bit is pretty straightforward when you expand it: map map [(+1), (*2)] = [map (+1), map (*2)], but since functions don't have a Show instance, you may want to play around with applying it to different arguments
12:58:45 <fishythefish> > zipWith ($) (map map [(+1), (*2)]) (repeat [1..4])
12:58:47 <lambdabot>  [[2,3,4,5],[2,4,6,8]]
12:59:29 <crestfallen> excellent
13:00:13 <crestfallen> so the second map only applies (*2)
13:00:27 <crestfallen> in the first example
13:00:42 <fishythefish> in both examples
13:01:03 <fishythefish> assuming you mean the second map in `[map (+1), map (*2)]`
13:03:22 <crestfallen> fishythefish, is map map commonly used?
13:03:48 <my_mom_hot> hi
13:04:17 <fishythefish> I wouldn't consider it a common idiom, no, but only because I have never needed a function to do what `map map` does
13:04:56 <fishythefish> there's nothing intrinsically wrong with it, though; you're making appropriate use of higher order functions
13:04:57 <crestfallen> my_mom__hot, < that is ...provocative :)
13:05:14 <dyl> :t (.).(.)
13:05:16 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:05:50 <ddellacosta> dyl: that is so weird I was just poking at that myself, this very moment
13:05:58 <dyl> :t (`fmap`).(`fmap`)
13:06:00 <lambdabot> error: parse error on input ‘)’
13:06:00 <ddellacosta> I'm trying to understand how that works
13:06:05 <dyl> :t fmap . fmap
13:06:07 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
13:06:26 <dyl> Now substitute in the functor instance for (-> r)
13:06:33 <crestfallen> yeah I think it was for illustrative purposes. actually EvanR I didn't understand the initial SO question but at least I can follow the inferred type
13:06:34 <fishythefish> -1
13:06:36 <dyl> Or whatever it was.
13:06:56 <dyl> fmap . fmap is just fmap one layer deeper in a stack of functors.
13:07:07 <dyl> :t fmap . fmap . fmap --we can go deeper
13:07:09 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
13:07:13 <fishythefish> ddellacosta: are you trying to work out what (.) . (.) does or just how the type is derived?
13:07:27 <ddellacosta> fmap . fmap seems more obvious to me, for whatever reason, than `(.) . (.)`
13:07:32 <ddellacosta> fishythefish: yeah, let's say both, haha
13:07:37 <crestfallen> what *does* that do?
13:07:49 <fishythefish> what it does is relatively straightforward from the types
13:07:52 <ddellacosta> the fact is that I can't really understand what it does until I understand how the type is derived
13:07:57 <__monty__> :t fmap fmap fmap
13:07:58 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
13:08:06 <kaol> :t fmap `fmap` fmap
13:08:07 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
13:08:10 <ddellacosta> fishythefish: I mean, sure, on that level yeah, but I don't have an intuition for it yet
13:08:25 <ddellacosta> doing some dumb manual substitution now to wrap my head around it
13:08:26 <dyl> fmap . fmap . fmap === fmap `fmap` fmap `fmap` fmap
13:08:31 <dyl> > fmap `fmap` fmap `fmap` fmap
13:08:33 <lambdabot>  error:
13:08:33 <lambdabot>      • No instance for (Typeable f2)
13:08:33 <lambdabot>          arising from a use of ‘show_M885580131854924185230160’
13:08:37 <dyl> Oh come on...
13:08:39 <fishythefish> crestfallen: you have a b -> c and an a1 -> a2 -> b, so you can get a function a1 -> a2 -> c by supplying the a1 and a2 to your second argument to get a b, then applying your first argument to get a c
13:08:42 <dyl> :t fmap `fmap` fmap `fmap` fmap
13:08:43 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
13:09:08 <dyl> ddellacosta It became more intuitive to me when I started thinking in terms of fmap = (.) :p
13:09:09 <__monty__> ddellacosta: ... Is just function composition for functions that take 2 arguments. Is how I look at it at least.
13:09:24 <dyl> It's way easier to see in terms of fmap than in terms of . with the infix arrow type constructors.
13:09:29 <ddellacosta> dyl, __monty__: yeah, I dunno why I have the block on (.) but not fmap
13:09:33 <dyl> If you rewrite a -> b as (-> b) a it's also easier.
13:09:46 <ddellacosta> dyl: ah that's helpful, let me try that
13:09:49 <dyl> (then it becomes clear f is (-> b))
13:09:58 <dyl> Yeah, undo the infix and it will become much easier.
13:10:08 <crestfallen> fishythefish, that's regarding the SO question?
13:10:21 <fishythefish> crestfallen: no, that's re: your question about what (.) . (.) does
13:10:45 <dyl> Not *all* of them btw, just the important ones :)
13:11:01 <crestfallen> thanks friend . one day I'll get it fishythefish
13:11:16 <dyl> (a -> b) -> f1 (f2 a) -> f1 (f2 b) ⇒ (a -> b) -> (-> c) ((-> d) a) -> (-> c) ((-> d) b)
13:11:41 <dyl> etc
13:11:55 <dyl> f1 = (-> c), f2 = (-> d)
13:12:01 <dyl> then expand it out into infix and you'll find (.).(.)
13:12:54 <atchoum> I have a dissertation topic
13:13:25 <atchoum> « Is automatic code generation equivalent to evil » ?
13:13:56 <atchoum> I was wondering actually if any « automatically generated code » couldn't be replaced by an equivalent well thought concept.
13:14:11 <Tuplanolla> Man reinvents compilers.
13:14:29 <dyl> :t (fmap flip) . (flip fmap)
13:14:30 <lambdabot> (a1 -> a2) -> (a2 -> b -> c) -> b -> a1 -> c
13:14:34 <dyl> Where did the Functor go .___.?
13:14:41 <dyl> ?free floop :: (fmap flip) . (flip fmap)
13:14:41 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/Type.hs:(152,17)-(160,45): Non-exhaustive patterns in case
13:14:45 <dyl> Eyy
13:15:03 * hackage load-env 0.2.0.1 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.2.0.1 (PatrickBrisbin)
13:15:05 <rom1504> atchoum: how is automatic code generation related to evil in any way ?
13:15:17 <dyl> My first lambdabot bug!
13:15:19 <dyl> \o/
13:15:45 <dyl> @let floop = (fmap flip) . (flip fmap)
13:15:46 <lambdabot>  Defined.
13:16:06 <dyl> > floop (+1) (+) 1 2
13:16:08 <lambdabot>  4
13:16:38 <dyl> Seriously though where did the Functor constraint go?
13:17:00 <marvin2> > fmap (+) (+1) 1 2
13:17:03 <lambdabot>  4
13:17:31 <fishythefish> dyl: what constraint?
13:21:03 * hackage charsetdetect-ae 1.1.0.4 - Character set detection using Mozilla's Universal Character Set Detector  http://hackage.haskell.org/package/charsetdetect-ae-1.1.0.4 (Artyom)
13:23:23 <tvN> why
13:28:11 <dyl> fishythefish Functor
13:28:18 <dyl> :t fmap
13:28:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:28:22 <dyl> :t floop
13:28:23 <lambdabot> (a1 -> a2) -> (a2 -> b -> c) -> b -> a1 -> c
13:28:28 <dyl> @src floop
13:28:28 <lambdabot> Source not found. Do you think like you type?
13:28:30 <fishythefish> :t fmap (+1) [1, 2] -- where did the constraint go?
13:28:31 <lambdabot> Num b => [b]
13:28:34 <dyl> (it's (fmap flip) . (flip fmap))
13:28:42 <dyl> ........
13:28:46 <dyl> doy.
13:28:49 <fishythefish> :)
13:29:39 <__monty__> :t fmap (+1)
13:29:40 <lambdabot> (Num b, Functor f) => f b -> f b
13:29:48 <__monty__> :t fmap flip
13:29:50 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
13:29:58 <__monty__> :t flip fmap
13:30:00 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:30:53 <__monty__> fishythefish: I don't get it. Why does the constraint disappear when composing?
13:31:13 <fishythefish> __monty__: because you're using the Functor instance for ((->) r)
13:31:35 <fishythefish> the same reason the Functor instance disappears in fmap (+1) [1, 2] -- because you've specialized to [a]
13:32:04 <__monty__> But there you provide a functor value, you don't do that with the other example.
13:32:28 <__monty__> :t (fmap (+1)) . (fmap (*2))
13:32:30 <lambdabot> (Num b, Functor f) => f b -> f b
13:32:41 <fishythefish> :t listToMaybe . fmap (+1)
13:32:42 <lambdabot> Num a => [a] -> Maybe a
13:32:53 <fishythefish> the fact that I provided a list value isn't important
13:33:27 <fishythefish> the point is that in unification I determine that I'm no longer working with a general `Functor f`
13:33:32 <fishythefish> that `f` must in fact be `[]`
13:35:41 <__monty__> Not seeing it. The f in flip fmap has to be (-> c)? What about the f in fmap flip?
13:35:43 <fishythefish> __monty__: in dyl's example, the fact that you have a (.) means that the LHS and RHS must be functions, so the correct Functor instance is known
13:36:47 <fishythefish> :t fmap flip
13:36:49 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
13:36:50 <fishythefish> :t (.)
13:36:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:37:33 <fishythefish> unify the type of fmap flip with the type of the first argument of (.), and likewise unify flip fmap with the second argument
13:38:28 <dyl> :t (fmap flip) `fmap` (flip fmap)
13:38:29 <lambdabot> (a1 -> a2) -> (a2 -> b -> c) -> b -> a1 -> c
13:38:37 <dyl> fishythefish that's not quite it here.
13:38:45 <dyl> :t fmap flip
13:38:46 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
13:38:47 <dyl> :t flip fmap
13:38:48 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:38:53 <dyl> ¯\_(ツ)_/¯
13:39:05 <fishythefish> probably said (.) when I meant `flip`, but same idea
13:39:24 <fishythefish> the point is that (.) and flip don't operate on general Functors
13:39:30 <dyl> :t (fmap `fmap` fmap) flip
13:39:32 <lambdabot> (Functor f2, Functor f1) => f1 (f2 (a -> b -> c)) -> f1 (f2 (b -> a -> c))
13:39:38 <__monty__> I'm having trouble unifying f (a -> b -> c) and (a -> b) -> f b.
13:39:51 <dyl> :t ((fmap `fmap` fmap) flip) `fmap` (flip fmap)
13:39:52 <lambdabot> Functor f => f a1 -> (a1 -> a2 -> b -> c) -> f (b -> a2 -> c)
13:39:58 <fishythefish> __monty__: make sure to rename type variables appropriately
13:40:00 <dyl> Now that's what I call podracing.
13:40:48 <EvanR> __monty__: theres an implicit forall, so in the two signatures potentially different f, different a, different b ...etc
13:40:55 <__monty__> If f = (-> c) then the second part resembles the first but there's an f I don't know what to do with in the first.
13:41:09 <fishythefish> (-> c) is not a (covariant) Functor
13:41:15 <fishythefish> (->) c is, but that means (c ->)
13:41:22 <__monty__> EvanR: The names don't give me trouble. I know the (a -> b) in the second could be the a in the first.
13:41:31 <EvanR> k
13:42:30 <__monty__> Why does f need to be a covariant functor?
13:42:52 <EvanR> Functor is covariant functor
13:43:18 <__monty__> Ah.
13:43:34 <__monty__> Ok, so I'm even more stuck : )
13:44:19 <EvanR> whats the question?
13:44:50 <__monty__> How do you unify f (a -> b -> c) and (a -> b) -> f b.
13:45:16 <Rembane> liftA2?
13:45:19 <Rembane> :t liftA2
13:45:20 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:45:34 <Rembane> Hm... maybe...
13:46:14 <jle`> __monty__: step by step :)
13:46:24 <jle`> __monty__: it helps to write (->) in prefix form
13:46:28 * EvanR reads this as f1 (a1 -> b1 -> c1) and (a2 -> b2) -> f2 b2
13:47:17 <jle`> f1 ((->) a1 ((->) b1 c1))
13:47:47 <jle`> (->) ((->) a2 b2) (f2 b2)
13:47:58 <hc> > ((.) . (.)) (* 2) (+) 3 2
13:48:00 <lambdabot>  10
13:48:11 <hc> what's the purpose of (.) . (.) ?
13:48:22 <EvanR> argument position juggling
13:48:24 <jle`> hc: are you asking what it does?
13:48:32 <hc> jle`: more like what you use it for
13:48:32 <jle`> or why it exists?
13:48:33 * hackage stratosphere 0.23.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.23.0 (jdreaver)
13:48:36 <hc> have you got a concrete example?
13:48:40 <hc> i mean, mine is pretty silly
13:48:43 <jle`> hc: isn't what you gave a concrete example?
13:48:54 <jle`> hc: it's not something i would ever use in actual code
13:49:04 <jle`> it's mostly used for code obfuscation and silly tricks
13:49:08 <hc> =) okay
13:49:24 <jle`> it's also a nice exercise in understanding how types unify and match up
13:49:50 <hc> tbh I don't really understand what it does yet, I just looked at the types and substituted appropriate functions
13:49:56 <__monty__> hc: I use it like a "delayed" (.). So just composition but you let the first function consume two values instead of one.
13:50:09 <jle`> :t (.).(.)
13:50:10 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:50:16 <__monty__> I think it's called the blackbird operator.
13:50:23 <jle`> honestly, the types should tell you everythin gyou need to know :)
13:50:47 <Lears> @djinn (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:50:47 <jle`> @unpl (.).(.)
13:50:47 <lambdabot> (\ x g x0 x1 -> x (g x0 x1))
13:50:47 <lambdabot> f a b c d = a (b c d)
13:50:53 <EvanR> also the boobs operator
13:51:30 <jle`> hc: in your case, it's (3 + 2) * 2
13:51:39 <ddellacosta> speaking of: I'm feeling really stupid but I'm having a tremendously hard time getting the types to line up when trying to work through (.).(.)
13:51:51 <jle`> no need to feel stupid :)
13:51:56 <__monty__> Is -> a functor or (a ->)?
13:52:05 <jle`> it's tricky, that's why it's a common exercise
13:52:08 <ddellacosta> which is crazy because I feel (felt?) like I understood composition really well...it's just, when staring at (.).(.), or rather the types, I don't see how they resolve
13:52:09 <EvanR> pointless form is not for human consumption, for the most part
13:52:14 <jle`> __monty__: `(->) a`, or (a ->)
13:52:18 <jle`> __monty__: do you see why?
13:52:20 <jle`> :t fmap
13:52:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:52:25 <jle`> (->) there would not make sense
13:52:33 <jle`> (a -> b) -> (->) a -> (-> b) is meaningless
13:52:39 <jle`> so (->) itself cnanot be a Functor
13:53:00 <__monty__> Ok, back to the drawing board for the unification.
13:53:05 <jle`> * (a -> b) -> (->) a -> (->) b
13:53:43 <isovector> i've got a problem I can't figure out how to model satisfactorily. i want to somehow consolidate `data Waiting = WaitingForInt | WaitingForBool` and `data Has = HasInt Int | HasBool Bool`
13:54:01 <jle`> __monty__: how are you sure that the two things you wrote unify?
13:54:06 <jle`> did you get it from somewhere?
13:54:19 <EvanR> thats what i was wondering, i think it might be a misreading of two ghci outputs
13:54:26 <jle`> isovector: consolidate how?
13:54:47 <jle`> as in make them one data type?
13:54:52 <isovector> jle`: the actual sumtypes are 5+ constructors; i'd like to use the same data type so i don't need to keep them in sync
13:54:52 <__monty__> :t (flip fmap) . (fmap flip)
13:54:53 <lambdabot> Functor f => f (a -> b1 -> c) -> ((b1 -> a -> c) -> b2) -> f b2
13:54:59 <__monty__> Woops.
13:55:13 <__monty__> :t (fmap flip) . (flip fmap)
13:55:14 <lambdabot> (a1 -> a2) -> (a2 -> b -> c) -> b -> a1 -> c
13:55:16 <jle`> isovector: oh, as in use the same data type for both situations?
13:55:20 <__monty__> ^ jle`
13:55:27 <EvanR> i think they want to "dont repeat yourself"
13:55:31 <isovector> jle`: yeah
13:55:52 <jle`> __monty__: what am i looking at?
13:56:36 <jle`> isovector: something people have done is something like `data Has f = HasInt (f Int) | HasBool (f Bool)`
13:56:42 <jle`> isovector: and your original Has is Has Identity
13:56:48 <jle`> and your waiting is Waiting Proxy
13:56:53 <__monty__> (fmap flip) . (flip fmap) and why the Functor constraint disappears. The unification shows up because of (.).
13:57:18 <jle`> at
13:57:20 <jle`> *ah
13:57:34 <jle`> :t fmap flip
13:57:35 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
13:57:44 <EvanR> :t ((fmap flip) .) `asAppliedTo` (flip fmap)
13:57:45 <lambdabot> ((a1 -> a2) -> (a2 -> b -> c) -> a1 -> b -> c) -> (a1 -> a2) -> (a2 -> b -> c) -> b -> a1 -> c
13:58:26 <jle`> isovector: it's some varation of the 'higher kinded data' pattern
13:58:28 <EvanR> (a1 -> a2) -> (a2 -> b -> c) -> a1 -> b -> c appears to be the final "middle" type
13:58:43 <isovector> hehehe i coined the phrase higher kinded data ;)
13:59:12 <jle`> oh hey, you're sandy maguire :)
13:59:18 <isovector> yup! hi!
13:59:31 <jle`> hi!
13:59:38 <jle`> oh just fyi i was looking for a way of contacting you
13:59:44 <jle`> i adopted the HKD tricks for my backprop library
13:59:45 <isovector> that approach mostly works, but it's a little unsatisfactory because functions that are paused `WaitingForInt` now needs some extraneous exhaustive cases that are unclear how to write
14:00:15 <jle`> basically to allow a BVar of a data type be translated automatically into a data type of BVar's
14:00:27 <jle`> to allow users to pattern match out of backpropagatable variables
14:00:50 <jle`> isovector: oh, you also want to ensure "type-safety" -- like, pair up the waitings with the right types?
14:00:58 <isovector> jle`: yeah, ideally
14:01:09 <jle`> in that case you might find some use for GADTs
14:01:30 <isovector> when it's in GADT form it's unclear how to get back `Waiting` though :D
14:01:30 <jle`> then the thing that is being "waited on" is a part of the type
14:01:44 <isovector> jle`: also my email should show up on my website -- were you viewing on mobile by any chance?
14:01:46 <jle`> you can convert back and forth using an existential
14:01:56 <jle`> isovector: oh i mean, that was all i wanted to say ;)
14:02:07 <isovector> oh, cool ahhah. have a link i can look at?
14:02:16 <isovector> also i'm not sure how existentialization helps here
14:03:00 <lyxia> data WaitingFor a = WFBool :: WaitingFor Bool | ...   data Has a = Has :: WaitingFor a -> a -> Has a
14:03:15 <jle`> https://backprop.jle.im/03-manipulating-bvars.html , ctrl+f "higher-kinded data interface"
14:03:29 <jle`> isovector: data SomeWaiting = SW (Waiting a)
14:03:31 <isovector> lyxia: ahh, brilliant
14:03:49 <jle`> SomeWaiting is equivalent to your original Waiting type
14:04:28 <jle`> you can re-use Some from the dependent-sum library
14:04:33 <jle`> type SomeWaiting = Some Waiting
14:04:56 <jle`> and...
14:05:12 <jle`> type Has = DSum Waiting Identity
14:05:20 <isovector> toooooo high tech :D
14:05:43 <jle`> `data SomeWaiting = SW (Waiting a)` should be enough to give you your original data type :)
14:05:59 <jle`> re-using generic combinators like Some just is nice because you have access to generic helper functions written for those combinators
14:06:06 <jle`> but it's not strictly necessary
14:06:53 <jle`> lyxia's `Has` is actually just `Waiting :*: Identity`, from GHC.Generics
14:07:30 <isovector> okay, one last thing. how do i get an `Eq` instance for `Some Waiting`? does dependent-sum give me that?
14:09:09 <isovector> i guess i could just pack typeable and eq dicts into the gadt
14:09:28 <jle`> it's not easy right now
14:10:09 <jle`> dependent-sum makes you define an instance of GEq
14:10:17 <EvanR> theres testEquality
14:11:09 <jle`> either way you'll have to define it manually case-by-case, unless you want to go through Typeable
14:11:22 <jle`> it will presumably be easier once QualifiedConstraints lands
14:12:47 <jle`> er, QuantifiedConstraints
14:12:57 <jle`> hopefully one day i'll just know it as Qua<tab>
14:13:36 <Tuplanolla> `QuantumChromodynamics`.
14:15:06 <fishythefish> don't forget QED
14:15:18 <fishythefish> causes all proofs to terminate but requires you to sum an infinite series of Feynman diagrams for each one
14:15:57 <jle`> first you have to prove that your proof terminates
14:16:03 <isovector> `SomeTT (_ :: TT a) == SomeTT (_ :: TT b) = case eqT @a @b of { Just Refl -> True; Nothing - False }`
14:16:23 <isovector> kinda gross but it works :D
14:16:45 <jle`> :D
14:17:09 <infinisil> Quiz question
14:17:24 <isovector> thanks all
14:17:30 <infinisil> What's a neat way to represent a rose tree that doesn't have a root value?
14:17:47 <jle`> infinisil: if you have a rose tree that does, it's just [rose tree]
14:17:59 <isovector> infinisil: [Cofree [] a]
14:18:35 <EvanR> take the fixed point of the process of proving your proof terminates
14:18:47 <infinisil> jle`: Nope
14:19:06 <infinisil> isovector: I don't know cofree so I can't say if that works :)
14:19:18 <suzu> it works
14:19:32 <jle`> `Cofree [] a` is the typical rose tree
14:19:35 <suzu> cofree f a for f ~ [] is a rose tree
14:19:44 <jle`> so [Cofree [] a] is a list of rose trees
14:19:45 <isovector> infinisil: `data Cofree f a = Cofree a (f (Cofree f a))`
14:19:55 <suzu> technically it is a forest
14:20:01 <isovector> but with weirder data constructor names :)
14:20:30 <EvanR> green cofree
14:20:44 <Welkin> organic
14:20:48 <suzu> farm-to-table
14:20:52 <Welkin> free-range
14:20:57 <isovector> it's an `f`-shaped tree with an `a` at every branch
14:21:26 <infinisil> So the problem with [Tree a]
14:21:41 <infinisil> Where is the element a stored?
14:22:02 <infinisil> data Tree a = Tree [Tree a] ?
14:22:07 <isovector> nowhere
14:22:20 <EvanR> phantom
14:22:37 <infinisil> There is something not visually as nice, but nicer conceptually
14:22:46 <infinisil> Well imo at least
14:22:50 <jle`> i didn't quite mean [Tree a]
14:23:00 <jle`> i meant data RoseTreeWithoutRoot a = [RoseTreeWithRoot a]
14:23:01 <infinisil> Ah right
14:23:11 <jle`> s/data/type
14:23:28 <infinisil> I want a single data type for a rose tree without a root
14:24:06 <infinisil> Revealing in 10
14:24:11 <isovector> what's wrong with [Cofree [] a]? :D
14:24:15 <suzu> data RoseTree a = Tree [RoseTree a] | Leaf a
14:24:17 <fishythefish> data RootlessRose a = [(a, RootlessRose a)]
14:24:29 <infinisil> fishythefish \o/
14:24:42 <isovector> lol
14:24:43 <suzu> o shit
14:24:51 <infinisil> fishythefish: Ya got it
14:25:08 <jle`> that's just the expansion of [Cofree [] a] :)
14:25:12 <fishythefish> yup :P
14:25:19 <jle`> like, if you go in the definition
14:25:22 <jle`> and replace f with []
14:25:23 <infinisil> jle`: (still don't know what cofree is :))
14:25:25 <jle`> it's exactly that :)
14:25:33 <fishythefish> infinisil: dual to Free, just reverse the arrows, etc
14:25:35 <jle`> infinisil: imagine what you wrote, but parameterizing on list
14:25:46 <suzu> it's like the fixpoint of a functor
14:25:49 <jle`> data RootlessCofree f a = f (a, RootlessCofree a)
14:25:59 <jle`> er
14:26:02 <jle`> data RootlessCofree f a = f (a, RootlessCofree f a)
14:26:13 <jle`> in that form, you can see that if you set f ~ [], that's exactly the same thing :)
14:26:23 * infinisil thinks about that
14:26:35 <infinisil> Nice
14:27:26 <jle`> data RoseTree a = RT a [RoseTree a]
14:27:32 <jle`> if you parameterize on the list:
14:27:40 <jle`> data Cofree f a = CF a (Cofree f a)
14:27:49 <jle`> Cofree is just a rose tree but you parameterize on the list
14:28:01 <jle`> i didn't intend for the characters to line up like that but that was a neat coincidence
14:28:55 <__monty__> Still stuck on (fmap flip) . (flip fmap), I guess I just don't understand unification? http://ix.io/1bpA
14:29:10 <jle`> __monty__: it's not an easy one, for what it's worth
14:29:19 <jle`> so it might not be that you don't understand it, it is just too tedious
14:29:27 <fishythefish> ^
14:29:57 <EvanR> or both
14:30:11 <fishythefish> __monty__: you're taking the types of `fmap flip` and `flip fmap` as given, yeah?
14:30:25 <Welkin> __monty__: what about just fmap . fmaop?
14:30:50 <Welkin> it might even help to consider (.).(.)
14:31:01 <Welkin> :t (.) . (.)
14:31:02 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
14:31:08 <Welkin> :t fmap . fmap
14:31:09 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
14:31:18 <suzu> :t fmap . fmap . fmap
14:31:19 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
14:31:20 <Welkin> :t fmap `fmap` fmap
14:31:22 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
14:31:27 <suzu> :t fmap <$> fmap
14:31:28 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
14:31:31 <Welkin> fmap and (.) are the same for functions
14:31:34 <suzu> never stop never stopping
14:34:24 <EvanR> :t fix fmap
14:34:26 <lambdabot> error:
14:34:26 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ f b
14:34:26 <lambdabot>       Expected type: (f a -> f b) -> f a -> f b
14:35:37 <ddellacosta> I keep coming back here to see what folks are talking about now and it keeps being (.).(.)
14:35:47 <Welkin> they like boobies
14:35:47 <ddellacosta> meanwhile I sit in front of my editor trying to figure out (.).(.)
14:35:55 <Welkin> don't sit at your computer
14:36:02 <Welkin> grab a sheet of paper and a pen
14:36:08 <Welkin> that is the only way I was able to understand it
14:36:15 <Welkin> work out the type unification on paper
14:36:38 <ddellacosta> Welkin: yeah I mean, I'm essentially doing that by writing out a bunch of (b -> c) -> (a -> b) -> a -> c but yeah, guess you're right
14:36:46 <ddellacosta> writing out in my editor I mean
14:36:48 <ddellacosta> in any case
14:36:51 <Welkin> that sucks o.o
14:36:56 <Welkin> a pen and paper is superior
14:37:04 <i0-dfn> does anyone know what @ means in GHC Core output?
14:37:06 <ddellacosta> yeah alright, let me try it
14:37:14 <srk> any backpack users around?
14:37:19 <ddellacosta> first I have to find some paper haha
14:38:05 <isovector> i0-dfn: type applications, isn't it?
14:40:00 <infinisil> Welkin: I agree, I long tried to do everything electronically, but it just isn't as well fit for figuring out things
14:40:09 <infinisil> Need to scribble stuff all over the place!
14:40:35 <i0-dfn> isovector: ah thanks that seems to make some sense
14:41:24 <jmite> I'm trying to run Haskero with VSCode, but I get the following error: /home/joey/.stack/programs/x86_64-linux/ghc-8.2.2/lib/ghc-8.2.2/package.conf.d/package.cache: GHC.PackageDb.readPackageDb: inappropriate type (Not a valid Unicode code point!)
14:41:36 <jmite> That's with the following command: stack ghci --with-ghc intero "--ghci-options=-ignore-dot-ghci -Wall" --no-build --no-load
14:41:43 <jmite> Anybody know what causes this?
14:44:33 * hackage mameya 0.1.0 - static site generator made to learn Haskell  http://hackage.haskell.org/package/mameya-0.1.0 (bururabit)
14:45:18 <geekosaur> huh, thought those had been fixed in all cases by forcing the package db to always be utf8. root cause is some installed-by-stack package has non-utf8 (usually iso8859, often in a description string) in its package registry entry which is derived from its cabal file
14:47:45 <__monty__> :t (fmap flip) . (flip fmap)
14:47:46 <lambdabot> (a1 -> a2) -> (a2 -> b -> c) -> b -> a1 -> c
14:48:24 <jle`> @unpl (fmap flip) . (flip fmap)
14:48:24 <lambdabot> (\ x -> fmap (\ f x0 y -> f y x0) (\ y -> fmap y x))
14:48:38 <jle`> @. t unpl (fmap flip) . (flip fmap)
14:48:38 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "t")
14:48:42 <jle`> @. type unpl (fmap flip) . (flip fmap)
14:48:43 <lambdabot> (t1 -> a) -> (a -> t2 -> t3) -> t2 -> t1 -> t3
14:48:48 <Welkin> :t (flip.) . ((. flip))
14:48:49 <lambdabot> ((b1 -> a1 -> c1) -> a2 -> b2 -> c2) -> (a1 -> b1 -> c1) -> b2 -> a2 -> c2
14:49:16 <Welkin> :t ((.) flip) . (flip (.))
14:49:17 <lambdabot> (a -> b1) -> (b1 -> b2 -> c) -> b2 -> a -> c
14:49:39 <infinisil> Are there colors in #haskell?
14:50:18 <infinisil> Like are irc color codes passed through?
14:50:23 <Welkin> try it
14:50:24 <suzu> no
14:50:40 <suzu> #haskell has +c, color codes are filtered out
14:50:41 <Welkin> hello
14:50:45 <infinisil> Welkin: Well I did write these two messages with colors, so you just confirmed it :)
14:50:47 <Welkin> is that bold?
14:50:50 <geekosaur> iirc it was on for a while and then came all the spam using blinding colors and it was turned off
14:50:55 <suzu> ^
14:51:15 <infinisil> Welkin: (I can see my own colors, because the client renders them, so i need somebody else to confirm it)
14:51:27 <Welkin> you are not in color
14:51:36 <infinisil> geekosaur: I always thought those spammers would be the easiest to automatically filter out
14:51:43 <jle`> testing colors
14:51:50 <infinisil> Colors would be nice for syntax highlighting for lambdabot
14:52:14 <geekosaur> infinisil, in a sense they are… until you go to, say, #reddit-soccer where you get lots of team colors and national flag representations, etc.
14:52:27 <Welkin> that is a thing that exists?
14:52:30 <infinisil> geekosaur: Well but we're not #reddit-soccer :)
14:52:51 <geekosaur> right but the filtering is provided by freenode, not by a #haskell specific bot
14:52:57 <Welkin> is #reddit-soccer as a bloated javascript app now?
14:53:00 <geekosaur> and freenode doesn;t try to guess what channels have what rules
14:53:27 <infinisil> Yeah, I'm thinking of a #haskell bot the automatically detects highly-likely spammers and kicks them
14:53:32 <infinisil> that*
14:53:42 <geekosaur> Welkin, the channel actually has nothing to do with reddit these days. it started out as a splinter group off of the actual /r/soccer channel on (then) snoonet
14:53:50 <geekosaur> and has turned into tis own thing since
14:54:54 <geekosaur> there's a #reddit-tennis that came from the same dispute and likewise is no longer affiliated with reddit
14:55:58 <geekosaur> but renaming an irc vhannel is a PITA once it gets up to 50-100 users (imagine trying to rename #haskell with 1784 clients that "know" what its name should be)
14:56:11 <infinisil> Redirect?
14:56:30 <geekosaur> there are forward bans, but for a channel with a lot of history they'd need to be more or less permanent
14:56:40 <geekosaur> we get folks who were last in here in 2006
14:56:40 <infinisil> Probably
14:56:46 <infinisil> Whoa
14:56:53 <geekosaur> for that matter, iirc shapr disappeared for most of a decade
14:57:23 <infinisil> Whoa, that means..
14:57:29 <infinisil> geekosaur: You're at least 10 years old
14:58:25 <EvanR> calling you out
14:58:32 <jle`> i am born the same year haskell was :)
14:58:36 <jle`> s/am/was ?
14:58:47 <__monty__> Haskell the Curry or Haskell the language?
14:59:05 <__monty__> Are you Haskell Curry?
14:59:08 <jle`> haskell the vision
14:59:15 <ddellacosta> jle`: Oppenheimer vis-a-vis Haskell
14:59:26 <EvanR> this is haskellvision
14:59:47 <jle`> maybe i am just Haskell itself, finally becoming self-aware
14:59:57 <EvanR> we control the applicative and the alternative
15:00:18 <EvanR> dial H for haskell
15:07:28 <infinisil> EvanR: I'm afraid H=44 is not a valid phone number
15:07:52 <EvanR> whats H=44
15:07:57 <EvanR> > ord 'H'
15:07:59 <lambdabot>  72
15:08:32 <infinisil> Damn youths these days, don't even know the traditional call numbers for letters
15:09:21 <EvanR> wat
15:09:28 <EvanR> just 4
15:09:34 <Welkin> infinisil: you and your electricity
15:09:43 <infinisil> EvanR: https://en.wikipedia.org/wiki/Telephone_keypad
15:10:26 <EvanR> i was at about 20 words a minute on that thing at one time
15:11:06 <infinisil> Well I actually don't know shit, I may be wrong on the double 4's
15:17:53 <EvanR> infinisil: when dialing phone numbers with a word in them... you would just dial the 1 number and move on, no toggling through.
15:18:09 <EvanR> in the old days
15:19:28 <geekosaur> the older folks when/where I was growing up till referred to the local phone exchange as "LAfayette 4" (524-xxxx)
15:19:47 <geekosaur> without area code because most of the northern half of the state was in the same area code back then
15:23:24 <__monty__> :t fmap flip
15:23:25 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
15:25:04 <marvin2> > fmap flip (-) 5 10
15:25:06 <lambdabot>  error:
15:25:06 <lambdabot>      • No instance for (Typeable c0)
15:25:06 <lambdabot>          arising from a use of ‘show_M540467337569376304832519’
15:25:14 <marvin2> mmm
15:25:16 <__monty__> :t flip fmap
15:25:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:25:31 <Welkin> you need to group the expression
15:25:37 <Welkin> :t (-)
15:25:38 <lambdabot> Num a => a -> a -> a
15:25:47 <Welkin> :t fmap (flip (-))
15:25:48 <geekosaur> infinisil, 44 would be t9 text entry on old cellphones, for dialing numbers H just means 4
15:25:48 <lambdabot> (Num c, Functor f) => f c -> f (c -> c)
15:30:45 <__monty__> Whew, finally managed the unification. Had my signature for (.) flipped.
15:32:06 <__monty__> I mechanically understand why the Functor constraint disappears from (fmap flip) . (flip fmap) now but it's definitely still not intuitive or straightforward. Is there an intuitive explanation?
15:33:48 <EvanR> since the f was determined to be a specific type, the instance was chosen, and the constraint discharged from the type
15:34:58 <EvanR> since f was instantiated, how would you even write the Functor constraint if you wnated to
15:35:23 <EvanR> you dont usually write types like Ord Int => Int -> Int -> Int
15:39:22 <phadej> :t substract
15:39:23 <lambdabot> error:
15:39:23 <lambdabot>     • Variable not in scope: substract
15:39:23 <lambdabot>     • Perhaps you meant ‘subtract’ (imported from Prelude)
15:39:26 <phadej> :t subtract
15:39:27 <lambdabot> Num a => a -> a -> a
15:39:32 <phadej> subtract 5 12
15:39:39 <phadej> > subtract 5 12
15:39:41 <lambdabot>  7
15:40:37 <__monty__> EvanR: I understand why the constraint disappears. I don't see how I could look at (fmap flip) . (flip fmap) and understand at a glance why the f's'll be determined.
15:41:06 * EvanR tries to see "where" the f is determined
15:41:14 <fishythefish> it's not always at a glance clear
15:41:56 <EvanR> the . makes both ( )'s functions
15:42:08 <EvanR> but they were already both functions
15:42:52 <EvanR> fmap flip, since flip operates on functions, makes the functor in question ... functions
15:43:47 <fishythefish> it's hard to analyze this "locally"
15:43:48 <fishythefish> :t fmap flip
15:43:49 <ddellacosta> and meanwhile holy shit I finally figured out how to unify (.).(.). Only took me like two and a half hours of reading IRC, futzing about in ghci, reading a bunch of stuff on line, trying to work it out on paper, failing at that, reading more stuff online, then reading this: https://gist.github.com/rebcabin/375cc457241ba7d8ee90cb48312b5c9d and realizing what I was confused about
15:43:49 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
15:43:56 <EvanR> dang
15:44:14 <fishythefish> :t flip fmap -- likewise
15:44:15 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:44:26 <ddellacosta> now maybe I can try to understand all this flip fmap stuff y'all have been talking about
15:44:33 <EvanR> you mean infer the type of (.) . (.) ...
15:44:55 <ddellacosta> EvanR: yeah sorry I mean, walking through the types where I apply (.) to (.), then (.) to that
15:45:10 <fishythefish> :t ((fmap flip) .) -- still have a constraint
15:45:11 <lambdabot> Functor f => (a1 -> f (a2 -> b -> c)) -> a1 -> f (b -> a2 -> c)
15:45:11 * EvanR tries to grok fmap flip
15:45:16 <fishythefish> :t (. (flip fmap)) -- likewise
15:45:17 <lambdabot> Functor f => (((a -> b) -> f b) -> c) -> f a -> c
15:45:41 <__monty__> EvanR: What you said sounds untrue. If the functor was already determined for fmap flip then there wouldn't be a constraint in its type, right?
15:45:46 <EvanR> ok yeah fmap f works on any functor
15:45:54 <EvanR> youre right
15:46:25 <EvanR> the specific functor is determined through a combination of everything
15:46:55 <EvanR> imagine if you tried to use this code without a type checker :)
15:47:04 <fishythefish> imagine if you tried to use this code
15:48:00 <geekosaur> people do. leading tot he next one: imagine if you tried to *read* this code
15:48:16 * geekosaur hates code that assumes he's got ghc and all deps loaded in his brain
15:49:21 <fishythefish> that's the dream for augmented reality -- look at something and have its type pop up
15:51:43 * EvanR puts on haskellvision glasses
15:52:21 <EvanR> its full of *
15:52:22 <geekosaur> (and then you get something like lens, where the types are so complex specifically so you *don;t* have to know them: everything is "regular" enough that you can figure it out without them)
15:52:51 <geekosaur> learn some simple conventions and you can read it and ignore the types
15:54:54 <crestfallen> please help me go through the recursion in euclid's extended algorithm   https://lpaste.net/6425008343076569088
15:54:55 <__monty__> I think reading the fmap flip thing'd be easier if it was applied to something. The constraint having been dispatched is only weird because the function wasn't applied to a functor yet. At least I wouldn't notice the constraint had vanished before application.
15:55:13 <crestfallen> the haskell is at the bottom of the paste
15:56:13 <EvanR> the . does complicate things
15:56:37 <EvanR> perhaps type infer this: \x -> (fmap flip (flip fmap x))
15:57:23 <__monty__> Alright, enough wrapping of my brain around vanishing functors. Thanks for the help understanding this. nn peoples
16:02:38 <shapr> geekosaur: something like 5-7 years, yeah
16:03:53 <crestfallen> I can follow the row reductions well enough on lines 9-16, but the recursive element stops me dead in the water
16:04:18 <crestfallen> even though the row reductions are recursive themselves
16:05:18 <crestfallen> complicated by the where statements.
16:07:58 <fishythefish> crestfallen: which part is tripping you up?
16:09:03 <crestfallen> the pattern matches in the where statement fishythefish
16:09:28 <crestfallen> and how they relate to line 42
16:09:28 <fishythefish> you can rewrite them as let...in if that would make it easier
16:11:18 <crestfallen> even with the trace, I can't see how it works
16:11:29 <fishythefish> @let extendEu a 0 = (1, 0); extendEu a b = let (q, r) = quotRem a b; (s, t) = extendEu b r in (t, s - q * t)
16:11:30 <lambdabot>  Defined.
16:12:32 <fishythefish> this reads fairly sequentially: to compute extendEu a b, let q be the quotient and r the remainder of a / b. Let (s, t) be the result of extendEu b r, and finally produce (t, s - q * t)
16:13:00 <fishythefish> > extendEu 10 55
16:13:02 <lambdabot>  (-5,1)
16:13:28 <fishythefish> > (-5) * 10 + 1 * 55 == gcd 10 55
16:13:30 <lambdabot>  True
16:14:42 <crestfallen> oh man. could we use the sample values extendEu 80 62 ?
16:15:22 <fishythefish> > extendEu 80 62
16:15:24 <lambdabot>  (7,-9)
16:15:36 <fishythefish> > 7 * 80 - 9 * 62 == gcd 80 62
16:15:38 <lambdabot>  True
16:16:12 <crestfallen> > gcd 80 62
16:16:14 <lambdabot>  2
16:17:11 <crestfallen> yeah thanks, I was hoping to, once again, write out the calculations by hand by using the pattern matching from the original extendEu fuction.
16:17:26 <fishythefish> are you struggling with the Haskell implementation in particular, or is it just unclear how the math/algorithm works?
16:17:43 <crestfallen> the math part is 95% clear
16:18:10 <crestfallen> except for the entirety of the matrices
16:18:35 <crestfallen> the row reduction I can read well. very nice
16:19:26 <fishythefish> the matrices are just the matrix representation of the row reduction procedure
16:19:42 <fishythefish> this isn't really haskell though; what are you using as a math reference?
16:21:27 <crestfallen> (q,r) = (1,18)   .  reference is https at bottom of paste  (too large to post)
16:21:40 <crestfallen> math stackexchange
16:21:53 <crestfallen> the haskell solution I found online
16:22:33 <fishythefish> IMO that isn't the clearest exposition but whatever works for you
16:23:22 <mbwgh> Is there a symbol for "category membership", like c `elem` C ?
16:23:54 <crestfallen> really, well I couldn't say because its my first exposure to abstract algebra / matrices, and I can see what the recursion is doing in the row reductions
16:23:57 <crestfallen> fishythefish:
16:24:17 <crestfallen> and *at least I can see ..
16:24:24 <fishythefish> mbwgh: depends on what you mean, but my initial inclination is \in (LaTeX)
16:24:54 <fishythefish> crestfallen: you might as well ignore the matrices, then; they don't add any new information and you don't make use of them
16:25:23 <crestfallen> ok. but is the haskell solid?
16:25:33 <crestfallen> it does work
16:25:49 <fishythefish> sure, it's basically a direct translation of the mathematical procedure
16:26:08 <dmwit> mbwgh: What is category membership?
16:26:58 <mbwgh> I have some object a, and want to express that a is an object of category C
16:27:11 <crestfallen> fishythefish: I'm really hip to writing the output out by hand for each recursion, so that's really what Im asking for help with
16:27:57 <crestfallen> esp so  I can how the where statements pass values into line 42
16:28:13 <mbwgh> I'm working hard in trying to grok Bartosz's book, but it's informal in lots of places of course, so not a lot of notation is introduced
16:28:22 <crestfallen> I know that's not the correct way to say it: "pass values ..."
16:28:30 <fishythefish> mbwgh: a ∈ C is a common (abuse of) notation, but some people will specifically use O(C) or Obj(C) or similar to represent the set/class of objects of C, so a ∈ Obj(C), for example
16:28:54 <dmwit> Yes, as fishythefish says.
16:29:18 <mbwgh> fishythefish: So Obj: C -> Set, and then I can fall back to notation I already know?
16:29:20 <fishythefish> crestfallen: do you understand my version of extendEu using let...in instead of where?
16:29:33 <dmwit> N.B. a ∈ Obj(C) is still an abuse of notation if C is not small.
16:29:38 <fishythefish> mbwgh: depends on if your category is small
16:30:17 <mbwgh> What is an example of a large(?) category?
16:30:29 <fishythefish> the category of sets
16:30:34 <fishythefish> there is no set of all sets
16:30:35 <dmwit> The category of categories, with functors as arrows.
16:30:49 <dmwit> ok, ok, the category of *small* categories. ;-)
16:30:50 <mbwgh> I thought only the category of small categories exists?
16:30:54 <mbwgh> ah
16:30:56 <fishythefish> likewise, groups, rings, topological spaces, vector spaces, R-modules, etc.
16:31:00 <mbwgh> So Cat isn't small
16:31:09 <dmwit> Certainly not *only* the category of small categories exists.
16:31:18 <crestfallen> frankly both structures obscure my idea of how to hand write output  .. how to begin
16:32:05 <fishythefish> crestfallen: depends on how you want your output formatted
16:32:15 <fishythefish> the important thing is whether you understand what that syntax deos
16:32:16 * dmwit ponders the epistemological consequences of taking "Only the category of small categories exists." as an axiom.
16:32:16 <fishythefish> does*
16:32:44 <dmwit> Presumably the category of small categories in that situation would itself be small.
16:32:45 <crestfallen> its substitution
16:32:57 <fishythefish> mbwgh: FWIW, using the same notation for both sets and classes is common - but as a courtesy you probably want some exposition pointing out when something is a class vs. a set
16:33:16 <mbwgh> I don't think I know what a non-small category is yet. But given that I have an object a, say, ... wait if Set isn't small ... do I know any small categories? Argh
16:33:16 <fishythefish> comprehension becomes less restricted when working with classes, so that's the main syntactic change
16:33:34 <dmwit> I object on the grounds that category theory can itself be a foundation of mathematics and need not ingratiate itself to set theory.
16:33:53 <crestfallen> so (q, r) = (1,18) for the first recursion
16:34:03 <fishythefish> mbwgh: any preordered set gives you a small category
16:34:09 <fishythefish> and preorders are useful for gaining intuition
16:34:15 <dmwit> One can take "a ∈ Obj(C)" to be simply a piece of syntax in category theory without attempting to translate it into set theory.
16:34:23 <fishythefish> monoids, directed graphs are small categories
16:34:51 <EvanR> i've seen a : Obj(C), and abusing even more, a : C
16:35:03 <fishythefish> crestfallen: right, so write that however you want
16:35:11 <dmwit> mbwgh: Take any graph; the category whose objects are nodes and arrows are paths is small.
16:35:12 <EvanR> f : a -> b would obviously be a morphism in C
16:35:44 <crestfallen> just as I have it ^     ?
16:36:02 <EvanR> if youre not doing set theory... then literally the large and small is weird
16:36:05 <mbwgh> EvanR: You didn't say that b : Obj(C). It could be the component of a natural transformation
16:36:10 <fishythefish> crestfallen: didn't check your math, but yeah, just writing (q, r) = (1, 18) is fine
16:36:21 <mbwgh> Category theory is not small
16:36:29 <EvanR> mbwgh: welcome to category theory notation, a huge amount has to be hidden to get anywhere
16:36:51 <EvanR> its a pile of conventions
16:36:52 <crestfallen> but line 44 has the second call to extendEu  , so how would you write that? fishythefish
16:37:18 <crestfallen> and plug everything into line 42 ?
16:37:35 <fishythefish> crestfallen: depends, there isn't really a single correct way to do this
16:37:44 <fishythefish> i might write it as a separate computation and then substitute the result
16:37:51 <fishythefish> or just expand it inline if it's small enough
16:38:19 <fishythefish> in the context of a math assignment, I'd just have written down the table instead
16:38:30 <dmwit> mbwgh: Wait until you see the version of category theory where objects are a defined notion, not part of the definition. =P
16:39:04 * hackage hw-prim 0.6.1.0 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.1.0 (haskellworks)
16:39:04 <mbwgh> dmwit: It'll all make sense later, right?
16:39:07 <fishythefish> crestfallen: presumably, no one is checking to make sure you wrote down the exact same sequence of characters they did - if this is an exercise to check your own understanding, all that matters is that you can write it in a consistent and coherent fashion and get the right answer
16:39:31 <fishythefish> or do "arrows-only" category theory if you hate objects
16:39:43 <crestfallen> you said "write it as a separate computation" . that seems like my style, however please tell me if there are cons to that.
16:40:11 <crestfallen> in any case it doesn't look very nice on paper
16:40:22 <fishythefish> crestfallen: again, it's all a question of what works for you. fwiw, writing it as a separate computation is nice from a referential transparency perspective
16:41:33 <mbwgh> Just to see if I got it so far. If C is a large category, I can't take Obj as a functor C -> Set. Is it a functor to some other category then, or just notation? And what's a class in this context really, should I think in terms of equivalence classes and all that?
16:41:40 <crestfallen> after (q,r) = (1,18)  , what would you write to express (s, t) = extendEu b r     ? fishythefish
16:42:16 <fishythefish> depends on what b is, but I would write (s, t) = extendEu b 18 = ..., where the ... is filled in based on evaluating the recursive call
16:42:45 <crestfallen> b = 62 at this stage ?
16:43:41 <fishythefish> mbwgh: not "class" in the sense of "equivalence class"
16:43:55 <fishythefish> it just means some collection without the size restriction imposed on sets
16:44:15 <fishythefish> giving a more rigorous answer depends on your axiomatization of set theory
16:44:33 <fishythefish> crestfallen: sure, I'm not checking the math at this point
16:44:53 <EvanR> a hierarchy of universes sizes
16:45:18 <crestfallen> from the initial values  extendEu 80 62
16:45:31 <mbwgh> Is this related to what's going on in dependently typed languages?
16:48:58 <fishythefish> mbwgh: what connection are you thinking of, precisely? we can classify categories as small or not without introducing a type system
16:49:13 <EvanR> its part of the same theme of avoiding russells paradox
16:50:26 <dmwit> mbwgh: Obj in that situation is not a mapping of any kind. `a ∈ Obj(C)` is just a chunk of notation that means `a` is an object of `C`.
16:50:26 <EvanR> Obj( ) isnt a functor
16:50:44 <dmwit> There is no more primitive thing to translate that statement to. You've reached the foundation of that piece of math.
16:50:46 <mbwgh> Yes, I was referring to the comment about universe sizes. In dependently typed languages, Type :: Type is not a given, but Type :: Type1, Type1 :: Type2 etc.
16:51:00 <fishythefish> well, you can consider a functor Cat -> Set mapping each small category to its set of objects, can't you?
16:51:06 <EvanR> Obj(C) is just a piece of the data needed to have a category
16:51:18 <dmwit> fishythefish: He explicitly said he was talking about a large category.
16:52:05 <mbwgh> Man. The one time I try to connect the dots, there are no dots :(
16:52:11 <EvanR> mbwgh: small and large can be relative, if you consider categories larger than large categories, and such
16:52:11 <fishythefish> dmwit: responding more to EvanR's claim that Obj is not a functor; mbwgh seems aware of the restriction based on "If C is a large category, I can't take Obj as a functor"
16:52:34 <EvanR> it all seems a bit silly, and tedious, so i think people try to avoid it
16:52:50 <mbwgh> Evanr: Well I don't really know what large means anyway. I just know that there's small. And assumed that non-small was called large.
16:53:11 <dmwit> mbwgh: Correct. There are no dots. Just like if I were to ask, "What does {} mean?", there's no more primitive thing to translate the empty set to. That's the foundation. Category theory *can* be undertaken as an alternate foundation to set theory.
16:53:13 <EvanR> dwelling on that is really admission that youre doing set theory
16:53:29 <EvanR> instead of category theory like you should be doing :)
16:53:43 <mbwgh> hmm
16:54:28 <newhoggy> I have a strictness problem.  I'm running something in ST and I want it to evaluate lazily
16:54:33 * hackage happlets 0.1.0.0 - "Haskell Applets" provides an event handler and a canvas for building simple GUI apps.  http://hackage.haskell.org/package/happlets-0.1.0.0 (RaminHonary)
16:54:35 <newhoggy> https://github.com/haskell-works/hw-prim/blob/085e555b0f8b6291fdd18b8d816da40df036c448/src/HaskellWorks/Data/Vector/AsVector64s.hs#L31
16:54:42 <newhoggy> But it looks like when I run this over a large input it loads everything into memory :(
16:54:42 <dmwit> (I mean, an alternate foundation to math, where two of the alternatives are "category theory" and "set theory". I did not mean that you could set category theory as a foundation to motivate set theory. Maybe you can, but that's not what I meant.)
16:55:08 <mbwgh> To be fair, the dwelling started when an exemplary piece of notation was given and called "abuse of notation"
16:55:48 <EvanR> fully explicit category theory, in some kind of type theory, would be horrendous :)
16:55:49 <dmwit> Yes. I live in regret of that moment. I should not have called it so.
16:56:17 <dmwit> I should have just said it's a different, parallel notation, and should not be confused with the usual set theory notation that uses the same sequence of Unicode codepoints. =)
16:57:33 <mbwgh> Use it, not confuse it. Deal.
16:58:26 <mbwgh> Opinionated: Since you all seem to know quite a bit about category theory, what do you think about Bartosz's book?
16:58:32 <crestfallen> fishythefish: schlogging through that .. pls stand by :)
16:59:43 <dmwit> don't know it
17:00:30 <EvanR> category theory for programmers?
17:00:54 <mbwgh> Yes.
17:01:13 <mbwgh> The one with the piggies and the fireworks.
17:02:09 <mbwgh> (Well, you might choose to not call it book, since it is not in print. It started as a blog post series.)
17:06:53 <EvanR> its pretty thin on the "for programmers" it seems to me
17:07:04 <EvanR> it has some haskell in there
17:07:51 <EvanR> and using haskell to explain pure CT seems like its going to overcomplicate things, because you have all the caveats about haskell
17:08:20 <mbwgh> What caveats are you referring to?
17:11:17 <EvanR> well, comonoids
17:11:38 <EvanR> here you have comonoids defined in Haskell
17:12:07 <EvanR> but it turns out every object in Hask is a comonoid with an implementation that does nothing
17:12:08 <geekosaur> haskell can only do "CT lite" with lots of restrictions and limitations
17:12:26 <EvanR> leaving you with a "wtf" feeling
17:12:50 <blonkhart> in my view the pedagogical value of the book is not limited in any way by the use of examples translated into haskell.
17:13:39 <mbwgh> But you spoke about "overcomplicating things". And indeed as geekosaur said, CT in Haskell doesn't really work in lots of places. But what kind of language should he have chosen instead? Agda? Coq?
17:13:59 <EvanR> that would be interesting
17:14:16 <EvanR> and probably even more complicated!
17:14:36 <mbwgh> But it is intended for an audience (as far as I can tell) that are familiar with C++ "and the like".
17:14:42 <geekosaur> pretty sure if you really wanted to show program examples of CT you'd need a custom language. I mean, agda can probably do it but the boilerplate etc. would hide what you'e trying to show
17:14:44 <EvanR> it is?
17:15:30 <mbwgh> Well, he is a prominent person in the C++ community, so I gather that's where quite a lot of his readers are coming from.
17:15:33 * hackage happlets-lib-gtk 0.1.0.0 - The "Haskell Applets" Gtk+ ver. 2 back-end for "happlets".  http://hackage.haskell.org/package/happlets-lib-gtk-0.1.0.0 (RaminHonary)
17:16:06 <geekosaur> might also be worth considering is there's likely a reaason why the #c++ evalbot is written in haskell
17:16:17 <mbwgh> As a matter of fact, he is the reason I got started with Haskell in the first place, after reading one or two blog posts of his where he related C++ template meta programming to purely functional programming
17:16:32 <geekosaur> i.e. at least some c++ folks are conversant enough in haskell, vs. not knowing much more about gda than that it exists
17:17:05 <mbwgh> Yeah, Haskell pops up all the time on conferences like CppCon as well
17:17:37 <EvanR> well the posts explain the basics of category theory, but i didnt see much application for programming. there are just definitions written in haskell
17:18:31 <EvanR> there are a lot of CT examples in the book "basic category theory"
17:19:30 <mbwgh> He explains algebraic data types, and their relation to bicartesian closed categories. Natural transformations and how you can use parametricity for things like fmap f . (alpha :: F a -> G a) = alpha . fmap f. But not a lot of languages even have a notion of parametric polymorphism
17:20:45 <mbwgh> I am currently at the chapter about limits and colimits. There the examples get way more advanced, like type unification and their relation to .. equalizers I think. Most languages don't have type inference.
17:21:15 <infinisil> mbwgh: Most languages don't even have sum types
17:21:21 <infinisil> What a horrible world we live in
17:21:45 <mbwgh> Well, they have "open sum types" *cough
17:23:02 <mbwgh> But yes, the title "for programmers" might be overselling things a little. I haven't worked my way through all of it though, so I can't say
17:23:50 <mbwgh> Oh, but I saw that there will be recursion schemes later. Those are for programmers I guess
17:24:04 <fishythefish> the c++ audience is more evident in the first few posts, where he tries to translate CT/Haskell into C++ templates
17:24:14 <EvanR> where are the recursion schemes?
17:24:23 <fishythefish> but it's gross and kind of obscures the point, so I think the decision to drop that aspect was overall a good one
17:24:51 <blonkhart> i think it is more about being written in a style accessible to programmers (not theorem-proof theorem-proof), rather than focused on applications to programming settings
17:25:23 <fishythefish> but in my experience, every exposition on category eventually reaches a point where the concepts are abstract enough that no amount of piggies and fireworks will be enough to help me really grok the concepts
17:25:34 <fishythefish> at some point, I just want exercises and examples in lots of different categories
17:26:32 <mbwgh> EvanR: There isn't a dedicated chapter. But there is an F-Algebras chapter, and Catamorphisms and Folds subsections. But I literally only saw the headings. There is also a lenses subsection in the next chapter after that
17:29:53 <Phenotype-Alpha> anyone here good with proofs and complexity theory of algo big-o(n) etc..
17:31:36 <infinisil> Phenotype-Alpha: Just ask your question. It's the best way to find out if anybody can help
17:33:16 <mbwgh> fishythefish: That might be true. But I tried other books as well, like the ones from David Spivak, and quickly noticed just how much I was lacking in terms of mathematical foundations. Even if you keep at it, there's no way to complete a text like that in reasonable time. I will however keep coming back to it, and do a little better then I guess.
17:33:18 <Phenotype-Alpha> Lets say I have a specific function like T(N)=exp(n^3)/lg(n) , 2 <= n how can I find a function where T(n)=big-o(g(n)), T(n)=omega(g(n)) and also T(n)=theta(g(n))
17:33:48 <fishythefish> Phenotype-Alpha: this channel is for haskell specifically, not help on general theory of computation
17:34:34 <Phenotype-Alpha> Ok but I didnt find a channel for that and felt data structures and complexity would be of interest for people skilled in haskell
17:35:08 <fishythefish> mbwgh: that's very likely true. as with most abstractions, it's almost essential to have exposure and understanding of multiple concrete instances in order to really grok the abstract case
17:35:13 <geekosaur> this sounds more like a question for one of the stackexchange sites anyway
17:35:19 <fishythefish> or office hours
17:37:19 <mbwgh> fishythefish: I never feel like I really grok anything anyway. Sure, I need intuition from concrete instances of a pattern. But the meta-pattern in learning patterns consists to some extent of "making peace with the definition at some point"
17:37:49 <dmwit> Phenotype-Alpha: As annoying as that is, "it's off-topic everywhere else" does not imply "it's on-topic here".
17:39:39 <mbwgh> And who said we like data structures anyway. Church-encode everything I say
17:41:30 <fishythefish> plus the answer is obviously to sleep for T(N) and then return a constant value
17:41:45 <Phenotype-Alpha> I understand guys/gals it's just that Haskell is so nice I though the community as welcoming as the language ... I learned my lesson I won't do a Britney Spears on y'all
17:42:12 <Phenotype-Alpha> would be
17:42:16 <fishythefish> the community is welcoming to on-topic questions :)
17:42:46 <fishythefish> and some degree of slightly-off-topic ones, but this is a bit too far removed
17:43:17 <w1n5t0n> hi, I have manually installed a module in a cabal sandbox and I'm trying to load it with running "import myModule" on the ghci but it's not finding it
17:45:44 <Phenotype-Alpha> you guys are a bit too functional for me ... cant we be a little more organic? Why does everything need a box
17:47:06 <dmwit> w1n5t0n: How are you running ghci?
17:47:26 <fishythefish> Phenotype-Alpha: we have unboxed types too!
17:47:31 <dmwit> If you're in a cabal sandbox, you need to ask cabal to point ghci at the package database; e.g. `cabal exec ghci`.
17:48:17 <Tuplanolla> People are talking about three kinds of boxes at the same time.
17:48:44 <mbwgh> Do boxes form a category?
17:49:09 <fishythefish> establish a preorder based on which boxes fit in others and I think so
17:50:06 <Phenotype-Alpha> Guys do you know what channel would be the right box for my question
17:50:07 <mbwgh> I like boxes now
17:50:22 <Tuplanolla> Try #haskell-offtopic, Phenotype-Alpha.
17:50:26 <w1n5t0n> dmwit: I run "ghci" from within the folder I initialized the sandbox
17:51:00 <infinisil> Phenotype-Alpha: Maybe ##cs
17:51:04 <dmwit> w1n5t0n: Yes, that will not do. =)
17:51:25 <fishythefish> mbwgh: caveat: this may only work for spherical boxes in a vacuum or something
17:51:49 <mbwgh> Wait what?
17:51:52 <edmundnoble> That category admits an injection to the category of burritos
17:52:02 <infinisil> Phenotype-Alpha: Or how about ##math?
17:52:06 <edmundnoble> Witnessed by unfolding the sphere into a tube
17:52:16 <fishythefish> mbwgh: nothing, just some theory/physics humor
17:52:27 <Phenotype-Alpha> Tried math already no help there
17:52:40 <Phenotype-Alpha> will try cs though sounds like a good box
17:52:50 <infinisil> Phenotype-Alpha: No help meaninG?
17:53:05 <Phenotype-Alpha> they couldnt help me ... no answer
17:54:01 <fishythefish> Phenotype-Alpha: creating a function with a given time complexity is easy - just artificially execute a number of operations proportional to that complexity
17:54:50 <w1n5t0n> dmwit: so how can I load it into ghci?
17:55:15 <crestfallen> fishythefish: hi again, that first line extendEu a 0 = (1,0)     ..    that's not a base case, is it?    https://lpaste.net/6425008343076569088
17:55:23 <fishythefish> crestfallen: yes, that's a base case
17:55:40 <Phenotype-Alpha> fishythefish now thats what im talking about :) but the thing is im not sure of the order of complexity of exp(N^3)/lg(n) the fact that it is a fraction is throwing me off
17:55:42 <mbwgh> Phenotype-Alpha: What is g(n) anyway?
17:56:43 <dmwit> w1n5t0n: 20:47 < dmwit> If you're in a cabal sandbox, you need to ask cabal to point ghci at the package database; e.g. `cabal exec ghci`.
17:57:30 <fishythefish> Phenotype-Alpha: the fact that it's a fraction is irrelevant
17:57:44 <Phenotype-Alpha> g(n) is the function we are looking to define as the upper and lower bound of T(n) giving us big-o(g(n)) = T(n) and Omega(g(n)) = T(n)
17:58:37 <fishythefish> g(n) = { for i from 0 to T(n): some-constant-time-operation }
17:58:48 <Phenotype-Alpha> but what is determining the growth of my function ... am i not supposed to look at the growth rate of the denominator and numerator like in a limit or something
17:59:05 <fishythefish> as long as computing T(n) does not have higher complexity than T(n) itself, you're fine
18:02:03 * hackage unpacked-maybe 0.1.0.0 - An unpacked maybe data type  http://hackage.haskell.org/package/unpacked-maybe-0.1.0.0 (chessai)
18:02:16 <crestfallen> so I have extendEu 80 62  = (18, 62 - (1* 18)) or extendEu 80 62  = (18, 44)    ..   but that's wrong fishythefish
18:02:42 <glguy> Phenotype-Alpha, fishythefish: You might continue that in a channel where it's ontopic, or in /msg
18:02:48 <Phenotype-Alpha> fishythefish thanks a lot for the pointer im already feeling like im getting close to understanding if I got it right now I just need to figure out what complexity my function has and create another function with the same complexity
18:02:58 <Phenotype-Alpha> ok sorry stopping now
18:03:01 <Phenotype-Alpha> thanks for help
18:03:02 <Eduard_Munteanu> Or in #haskell-blah, I suppose.
18:03:11 <fishythefish> glguy: tbh, I'm only in this because the conversation of finding an ontopic channel was getting longer than just answering the question
18:03:26 <fishythefish> but yeah, Phenotype-Alpha, i'll accept DMs if you want
18:03:36 <fishythefish> crestfallen: I don't see the recursive call in there
18:06:02 <crestfallen> can we trace all those variables?
18:06:28 <ReaperX> hello
18:06:31 <fishythefish> crestfallen: well, it's your code; if you want to add traces, go for it
18:06:44 <Eduard_Munteanu> Hi, ReaperX.
18:06:52 <ReaperX> hi
18:08:19 <ReaperX> It has been more then 10 years before comming to irc :-)
18:09:19 <ReaperX> but it still rulez
18:10:21 <ReaperX> any one awake ?????????????
18:11:15 <mbwgh> Sorry, we're all using slack now
18:11:33 * hackage unpacked-either 0.1.0.0 - An unpacked either data type  http://hackage.haskell.org/package/unpacked-either-0.1.0.0 (chessai)
18:11:55 <ReaperX> damn bots
18:12:07 <Eduard_Munteanu> It's probably late evening in US, so I guess yeah. OTOH, it's 4 AM here. :)
18:12:44 <mbwgh> Good lord. 3 am here, still chasing diagrams tho
18:12:48 <ReaperX> here 3 am
18:13:10 <ReaperX> ff bots
18:13:24 * Eduard_Munteanu expects a GDPR notice to pop up any minute now that location data has been collected
18:13:55 <ReaperX> mbwgh still awake
18:14:56 <mbwgh> Almost reached the limit
18:15:25 <ReaperX> lol
18:15:55 <ReaperX> whois alive in here
18:16:33 <fishythefish> plenty of people, but most aren't going to jump in for an offtopic chit-chat
18:19:58 <ReaperX> fff keeps listening to the drops
18:20:14 <crestfallen> fishythefish: could I pm you
18:20:20 <fishythefish> crestfallen: if you'd like
19:21:35 <reachingfourpeas> #help
19:22:00 <reachingfourpeas> That was a mistake, nvm
20:53:32 <excelsiora> hi!
20:55:43 <cocreature> hey excelsiora :)
20:56:04 <excelsiora> what's up?
20:57:04 * hackage beam-sqlite 0.3.2.1 - Beam driver for SQLite  http://hackage.haskell.org/package/beam-sqlite-0.3.2.1 (TravisAthougies)
21:02:28 <excelsiora>  /list
21:34:51 <suzu> excelsiora: did you die
22:00:53 <iqubic> No. excelsiora is still very much alive.
22:19:11 <Arcaelyx> Anyone have any thoughts on Rust vs Haskell for building out a scalable websocket server?
22:25:20 <suzu> i know haskell and i don't know rust
22:25:31 <suzu> so i would use haskell to make the server because i know it
22:25:33 <suzu> /shrug
22:51:26 <iqubic> > length (1, 2)
22:51:28 <lambdabot>  1
22:51:34 <iqubic> WAT?!?!
22:51:43 <glguy> is your 2048 done yet?
22:52:15 <iqubic> No. I'm still working on it. I'm getting sidetracked by random haskell videos online.
22:52:26 <iqubic> :t length
22:52:27 <lambdabot> Foldable t => t a -> Int
22:58:20 <glguy> > ("ab", sort) <*> ("cd", "example")
22:58:22 <lambdabot>  ("abcd","aeelmpx")
22:58:30 <glguy> same sort of interpretations of tuples that leads to that
23:05:35 <pavonia> :t  \a b c d -> (a, b) <*> (c, d)
23:05:37 <lambdabot> Monoid a1 => a1 -> (a2 -> b) -> a1 -> a2 -> (a1, b)
23:16:11 <iqubic> Wait, so it calls mappend on the first elements?
23:19:53 <EvanR> > length (2,2)
23:19:55 <lambdabot>  1
23:21:06 <EvanR> > length (Right 2)
23:21:08 <lambdabot>  1
23:21:15 <cocreature> it probably makes more sense if you look at the behavior of toList
23:21:17 <EvanR> > length (Left 2)
23:21:19 <lambdabot>  0
23:21:19 <cocreature> > toList (1,2)
23:21:21 <lambdabot>  error:
23:21:21 <lambdabot>      Ambiguous occurrence ‘toList’
23:21:21 <lambdabot>      It could refer to either ‘F.toList’,
23:21:27 <EvanR> finally something to break to monotony
23:21:35 <cocreature> > F.toList (1,2)
23:21:37 <lambdabot>  [2]
23:21:59 <EvanR> > length () -- this better be good
23:22:01 <lambdabot>  error:
23:22:01 <lambdabot>      • Couldn't match expected type ‘[a0]’ with actual type ‘()’
23:22:01 <lambdabot>      • In the first argument of ‘length’, namely ‘()’
23:22:24 <cocreature> does that count as “good”?
23:22:38 <EvanR> why is it expecting a list
23:23:38 <EvanR> i expected the error to be "no instance for Foldable"
23:23:48 <iqubic> I guess lambdabot seeing (Foldable t) and decided t ~ List
23:24:32 <cocreature> probably ExtendedDefaultRules
23:25:02 <cocreature> yeah if you disable that you get the error you would expect
23:25:32 <EvanR> lispers chuckling at haskell for saying length (x,y) is 1 and length () is ERROR
23:25:47 <EvanR> looks almost like off by 1 error
23:25:52 <iqubic> Yes.
23:29:45 <EvanR> and triples are not Foldable
23:30:24 <mjoldfield> iqubic: This reddit thread from a few years ago talks about why length (2,2) == 1: https://www.reddit.com/r/haskell/comments/3okick/foldable_for_nonhaskellers_haskells_controversial/
23:32:32 <nshepperd> (a,) ~ Writer a
23:34:11 <kuribas> > length $ Just [1, 2, 3]
23:34:13 <lambdabot>  1
23:35:00 <mjoldfield> > length <$> Just [1,2,3]
23:35:02 <lambdabot>  Just 3
23:37:16 <EvanR> > length "<$> Just [1,2,3]"
23:37:18 <lambdabot>  16
23:40:47 <kuribas> > length (1, (2, 3, 4))
23:40:49 <lambdabot>  1
23:41:18 <kuribas> > over _2 length (1, (2, 3, 4))
23:41:20 <lambdabot>  error:
23:41:20 <lambdabot>      • Could not deduce (Foldable ((,,) Integer Integer))
23:41:20 <lambdabot>          arising from a use of ‘length’
23:41:32 <kuribas> > over _2 length (1, [2, 3, 4])
23:41:35 <lambdabot>  (1,3)
23:42:09 <kuribas> > (1, [2, 3, 4]) ^. _2 . to length
23:42:11 <lambdabot>  3
23:43:17 <kuribas> > views _2 length (1, [2, 3, 4])
23:43:19 <lambdabot>  3
23:43:26 <kuribas> does views have an operator version?
23:43:30 <cocreature> ^.
23:43:34 <cocreature> oh views not view
23:43:37 <kuribas> yeah
23:43:58 <Axman6> > (1, [2, 3, 4]) ^. _2 . to length
23:44:00 <lambdabot>  3
23:44:13 <cocreature> ternary functions don’t work particularly well in infix form
23:44:17 <kuribas> hm & maybe?
23:44:29 <kuribas> > (1, [2, 3, 4]) ^. _2 & length
23:44:31 <lambdabot>  3
23:44:37 <Axman6> that too
23:44:38 <kuribas> that'll do :)
23:44:45 <cocreature> I would just use "to"
23:44:57 <kuribas> cocreature: yeah, it seems more descriptive
23:54:02 <noan> speaking of that.... where can I find a definition for ^.
23:54:10 <noan> hoogle gives back nothing
23:54:22 <jle`> noan: it's a part of the lens library, in Control.Lens.Operators
23:54:32 <jle`> i can give you the definition by heart though
23:54:36 <cocreature> noan: https://hoogle.haskell.org/?hoogle=(%5E.)
23:54:41 <jle`> (^.) = flip view
23:55:17 <jle`> x ^. l = view l x
23:55:42 <cocreature> give a man a definition and he’ll be happy for a day. teach a man to find the definition and he’ll be happy for a lifetime
23:55:47 <noan> ty
23:56:12 <jle`> noan: note that the "official" hoogle is like five years out of date
23:56:20 <jle`> hoogle.haskell.org is kept up to date
23:56:29 <jle`> if you're just looking for a definition, you can also use stoogle
23:56:36 <jle`> nobody calls it that but that's what i call stackage hoogle
23:56:39 <noan> cocreature, or in my case, "Let the lady know you need parens around symbolic functions and she'll not need to ask you dumb questions in future"
23:57:27 <noan> jle`, ty
23:57:31 <cocreature> noan: oh sry, didn’t mean to assume a gender. I just know the original quote in that form. fwiw it also works without parens https://hoogle.haskell.org/?hoogle=%5E.
23:57:38 <kuribas> noan: you can install hoogle locally as well
23:57:52 <jle`> i wonder when they will update hoogle
23:57:59 <jle`> i understand the reasons for it not being updated
23:58:19 <kuribas> noan: you'll need lens for it to show up, but it's a common dependency
23:58:20 <noan> cocreature, ah, yeah, my issue was using the wrong hoogle. I get no results in the /hoogle one
23:58:21 <noan> cheers
23:58:24 <cocreature> I think not updating it is causing more harm than good
23:58:37 <jle`> noan: the /hoogle one can be 'hacked' to show it, in an unhelpful way, heh
23:58:46 <jle`> noan: if you do (^.) +lens it'll work, but that means you have to already know it's from lens
23:58:50 <cocreature> sure the typesearch is worse in the new hoogle but what good is a type search that doesn’t index a reasonably large set of packages
23:59:02 <jle`> which is like, the reason why you'd want it in the first place heh
23:59:08 <cocreature> and afaik there are no plans to improve type search in the new hoogle so if that’s the main reason we’ll be stuck at this forever
23:59:22 <jle`> cocreature: the way i see it it's unupdated as a motivation to finish hoogle 5 faster
23:59:30 <kuribas> you can fork it to create a better hoogle
23:59:34 <noan> jle`, heh, I did know it was from lens, but lens is big
23:59:39 <noan> and I wanted the type signature basically
