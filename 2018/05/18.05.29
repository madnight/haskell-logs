00:04:35 <freusque> Hi. What about hackage pages such as this one https://hackage.haskell.org/package/zeromq4-conduit ?
00:04:52 <cocreature> freusque: what about it?
00:04:58 <freusque> The generated page has no hyperlinks
00:05:06 <freusque> for its modules
00:05:28 <cocreature> on the bottom right there is a link to the build log that explains why docs coulnd’t be built
00:05:42 <cocreature> maintainers can upload docs themselves but sadly a lot of people don’t do that
00:05:46 <freusque> I see
00:05:51 <freusque> thanks.
00:14:52 * hackage hifi 0.1.4.0 - WiFi connection script generator  http://hackage.haskell.org/package/hifi-0.1.4.0 (gonz)
00:19:33 * hackage hw-hspec-hedgehog 0.1.0.5 - Interoperability between hspec and hedgehog  http://hackage.haskell.org/package/hw-hspec-hedgehog-0.1.0.5 (haskellworks)
00:44:38 * hackage conduit-algorithms 0.0.8.1 - Conduit-based algorithms  http://hackage.haskell.org/package/conduit-algorithms-0.0.8.1 (luispedro)
00:50:36 * hackage hifi 0.1.4.1 - WiFi connection script generator  http://hackage.haskell.org/package/hifi-0.1.4.1 (gonz)
00:53:33 * hackage filecache 0.4.0 - A cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.4.0 (SimonMarechal)
00:57:36 * hackage speechmatics 0.1.0.0 - Upload audio files to speechmatics to get a transcription  http://hackage.haskell.org/package/speechmatics-0.1.0.0 (Jappie)
01:07:27 <kuribas> wouldn't a haddock -> texinfo translator be useful?
01:07:41 <kuribas> You could then have hyperlinked documentation inside emacs.
01:08:18 <ventonegro> Yes
01:09:15 <kuribas> can you easily write modules for haddock?
01:09:23 <kuribas> or is it self-contained?
01:10:09 <kuribas> (seems self-contained)
01:12:18 <kuribas> so an extra option in .cabal/config to create additional info docs.
01:12:24 <kuribas> and command line switch
01:17:19 <gonz_> !hoogle Monad m => [m a] -> m [a]
01:17:41 <cocreature> :t sequence -- gonz_
01:17:41 <gonz_> Oh, there's no hoogle command?
01:17:42 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:17:50 <cocreature> @hoogle Monad m => [m a] -> m [a]
01:17:51 <lambdabot> NumericPrelude.Base sequence :: Monad m => [m a] -> m [a]
01:17:51 <lambdabot> Hledger.Utils sequence' :: Monad f => [f a] -> f [a]
01:17:51 <lambdabot> Control.Monad.Run mswitch :: (Monad m, MonadUnTrans MaybeAlg t) => [t m b] -> m b -> m b
01:18:02 <gonz_> cocreature: Yeah, I just wanted to see if there was a hoogle command so I could check a signature I already know hoogle can find
01:18:24 <gonz_> Ah, `@hoogle`
01:18:26 <gonz_> Cool
01:18:26 * hackage potoki-core 1.5.3 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-1.5.3 (NikitaVolkov)
01:19:56 <gonz_> Do packages have to be explicitly added to Stackage or do they pull from Hackage like NixOS do?
01:20:12 <cocreature> they have to be added explicitely
01:20:15 <kuribas> gonz_: you can also install it on your own computer
01:22:35 * hackage potoki-cereal 0.2 - Streaming serialization  http://hackage.haskell.org/package/potoki-cereal-0.2 (NikitaVolkov)
01:23:46 <gonz_> I don't remember ever adding one of my packages to Stackage but somehow it's installable via `stack install`
01:24:16 <cocreature> which package?
01:24:43 <gonz_> https://hackage.haskell.org/package/hifi
01:25:54 <cocreature> that’s not on stackage afaict, "stack install" just falls back to hackage automatically
01:28:40 <gonz_> Right, that makes sense.
01:30:54 <kuribas> wouldn't it be useful to have hackage documentation in a computer readable format?
01:30:56 <kuribas> like xml?
01:31:05 <kuribas> So it could be easily read by tools.
01:31:49 <kuribas> Or an easily searchable binary format.
01:33:20 <kuribas> haddock's output is good for human reading, but not for tools.
01:33:36 <kuribas> Something with a stable format.
01:34:23 <sclv> the hie gsoc project is to let ghc create such an output directly
01:34:34 <sclv> or rather there are two related gsoc projects
01:34:40 <sclv> one to output fully annotated source
01:35:07 <sclv> and the other to simply move the name-resolution to ghci and improve the hi output
01:35:17 <sclv> the hi output is less stable
01:35:28 <sclv> but it does give something tool-searchable
01:36:19 <kuribas> the problem is that those change, and then the tools break
01:55:17 <kvothe> how do I convert an integer to a bytestring of specific number of bits?
01:56:49 <kvothe> I can do encode (42 :: Int64) to get a 64 bit bytestring. Is there a way to get any n bit bytestring?
01:57:16 <jesyspa> It sounds like what you want is a runtime value to end up on the type level, no?
01:57:18 <hc> kvothe: http://hackage.haskell.org/package/binary-0.9.0.0/docs/Data-Binary-Put.html
01:59:19 <cocreature> depending on how much you care about performance you can map testBit over [0..n - 1], convert groups of 8 into Word8 and then turn that into a bytestring (and probably reverse somewhere along the way)
02:19:03 <[exa]> hm guys, is there some good bucketing function? a list-processing variant of SQL "select function(x) from ... group by y"
02:19:34 <noan> Anyone have any pointers where I could read about the limitations of GHCJS? I mean, I assume they must exist
02:20:25 <cocreature> noan: limitations in what sense?
02:21:01 <kuribas> [exa]: there are sql like comprehensions
02:21:26 <noan> cocreature, like, language features that cannot be used etc. Or libraries that can't compile typically.
02:21:40 <noan> for instance, anything involving FFI to c, would logically be unavailable
02:21:53 <cocreature> right but that’s the only limitation in that regard that I’m aware of
02:21:59 <noan> wow really?
02:22:29 <kuribas> [exa]: wouldn't that be just "groupBy y . map function"
02:22:43 <simon> what pretty-printing library should I use? there's pretty, pretty-printer, GenericPretty.
02:22:46 <cocreature> I might be forgetting something but ghcjs is really impressive in the sense that it just works™
02:22:49 <cocreature> simon: prettyprinter
02:23:19 <simon> cocreature, fanks!
02:23:30 <noan> cocreature, okay then, thanks
02:24:13 <[exa]> kuribas: probably in the reverse order but yes, that would work. groupBy works on non-continuous subsequences?
02:24:33 <kuribas> [exa]: no, you'll need to sort first
02:25:07 <kuribas> [exa]: groupBy y . sortBy y . map function
02:25:09 <[exa]> so I'm probably not getting much faster/slower by shoving it in Data.Map to do the "aggregation"?
02:25:51 <kuribas> [exa]: same complexity
02:26:30 <kuribas> [exa]: sql also uses lookup tables to optimize that
02:26:34 <[exa]> yep
02:26:38 <[exa]> ok thanks
02:26:55 <kuribas> there's no O(n) solution in the general case AFAIK
02:28:08 <simon> cocreature, is there a prettyprinter tutorial?
02:28:48 <cocreature> simon: not sure if there is some dedicated tutorial but the haddocks are quite good and have examples. anything specific that you’re having trouble with?
02:29:06 <simon> cocreature, whoops, there's actually two modules in the package called tutorial
02:29:18 <simon> cocreature, no, just couldn't find a starting point.
02:29:43 <cocreature> simon: those tutorials are for more advanced features. they’re probably not going to be useful to get started
02:29:56 <simon> hm.
02:30:00 <cocreature> for getting started just take a look at the haddocks in https://hackage.haskell.org/package/prettyprinter-1.2.0.1/docs/Data-Text-Prettyprint-Doc.html
02:30:24 <simon> cocreature, okay.
02:30:43 <cocreature> the “starting out” section links you to the functions that are probably going to get you quite a long way
02:49:51 <rotcev> is there some way to see the evaluation of function application as it happens?
02:51:39 <jchia> rotcev: You can try using 'trace'.
02:52:01 <jchia> Is there a way to make a ByteString from a 'UArray Int Word8' without copying?
02:53:23 <dminuoso> rotcev: Mmm I just found ghc-vis, which might be what you are looking for
02:55:25 <cocreature> jchia: iirc the ByteArray# underlying an UArray is not pinned which means you can’t get a stable ForeignPtr to it so you can’t build a ByteString from it
02:56:45 <cocreature> a ShortByteString should be possible
02:57:15 <pavonia> jchia: Is there a special reason you're using UArray instead of Vector? I'd be easier to convert between ByteString and Vector efficiently
02:57:48 <cocreature> pavonia: is it? vector is also not pinned iirc?
02:58:36 <jchia> I'm using this package: http://hackage.haskell.org/package/network-house-0.1.0.2/docs/Net-Packet.html#t:Chunk
02:59:01 <pavonia> cocreature: It should be possible to go from ByteString to a Ptr and from that to Vector
02:59:06 <pavonia> or vice versa
02:59:16 <jchia> cocreature: They give me network packet payload as "UArray Int Word8", but I need to parse it with binary package, which expects ByteString
02:59:18 <rotcev> dminuoso: that looks interesting, i think it could be what i wanted
02:59:49 <jchia> ^pavonia
02:59:59 <cocreature> pavonia: I’m not sure about the Vector -> ByteString direction. ByteString requires that the memory is pinned, i.e., it won’t be moved by the GC. iirc the storage underlying an unboxed vector isn’t pinned
03:00:25 <jchia> What about GC? Don't I need to be concerned about pointers being moved around if I used the same pointer in different array/bytestring/vectors?
03:00:35 <rotcev> dminuoso: also the ghci :print seems useful
03:12:27 <pavonia> jchia: Have you tried how (ByteString.pack . outBytes) performs against the naive loop version?
03:21:29 <dminuoso> https://gist.github.com/rotcev/42aa72f477cdf7b83a42ccb78688ffc8 <- why doesn't this print `1 : (2 : (_t3 ::[Integer]))` at the end?
03:21:38 <dminuoso> (Where _t3 is the thunk that will evaluate to the empty list)
03:22:40 <cocreature> dminuoso: take a look at the implementation of take
03:23:06 <int-e> exactly. unsafeTake 1   (x: _) = [x]
03:23:33 <dminuoso> Ah! Thank you both. rotcev ^-
03:23:55 <rotcev> ah
03:25:38 <int-e> (Heh, that implementation of 'take' is a bit more fancy than I expected.)
03:27:30 <cocreature> I wonder how it compares against the naive implementation
03:28:13 <kuribas> does spock expire sessions?
03:28:58 <dminuoso> rotcev: https://gist.github.com/dminuoso/0253609d33f4431333aec183eb5a3936
03:29:34 <dminuoso> Interesting. Why is `1` not represented as a thunk in this?
03:30:17 <cocreature> kuribas: http://hackage.haskell.org/package/Spock-0.12.0.0/docs/Web-Spock-Config.html#t:SessionCfg lets you configure how long sessions should live and whether they should be renewed
03:30:37 <rotcev> dminuoso: we're getting into muddy water :-)
03:31:25 <int-e> dminuoso: Because it's evaluated as part of evaluating that 2. In fact, I would expect that the list produced never contains thunks as values, because the values are needed for knowing when to stop. But of course, if in doubt, consult the source code.
03:31:51 <int-e> (and if that fails, the STG core)
03:31:58 <dminuoso> int-e: ahh.. you are spot on
03:32:04 <dminuoso> int-e: https://gist.github.com/dminuoso/a0e46f867e7a0260e52a7af2fe9c6395
03:32:09 <kuribas> cocreature: right, thanks
03:32:33 <dminuoso> rotcev: The water seems to be very clear! :-)
03:33:24 <dminuoso> int-e: (Slight correction, the values are needed to know the next value)
03:33:32 <dminuoso> So if you force the nth element, you necessarily force all previous elements
03:33:39 <int-e> matsurago: err, hmm, never mind the "when to stop", that doesn't apply to enumFrom...
03:33:46 <int-e> huh?
03:33:58 <cocreature> > [undefined, 1] !! 1
03:34:00 <lambdabot>  1
03:34:05 <int-e> (wrong nick, not sure how that happened)
03:35:35 <int-e> dminuoso: but it's still true, apparently, that the list never contains thunks as values: https://lpaste.net/373607007371919360
03:36:36 <int-e> > [1..] !! 10000
03:36:38 <lambdabot>  10001
03:38:46 <rotcev> dminuoso: i believe i understand your gist
03:40:44 <rotcev> dminuoso: https://gist.github.com/rotcev/c3454d4692f2b5379af1751f39305c10
03:41:02 <rotcev> this is exactly what we expected
03:41:40 <rotcev> indeed, the take in Base seems fancy
04:17:30 <dminuoso> int-e: well in order to know what the nth enum is, it has to calculate all previous ones, no?
04:18:30 <dminuoso> I mean lets assume for a second that all previous values were left in thunks. How could it know what an arbitrary thunk evaluates to?
04:18:31 <stan> Having an issue: The same package name is used in multiple local packages  hedgehog used in: - PLIndex "hedgehog-0.6" - PLIndex "hedgehog-0.6"
04:18:42 <stan> what is -PLIndex
04:19:17 <int-e> > iterate (1+) 1 !! 10000
04:19:19 <lambdabot>  10001
04:19:21 <int-e> > iterate (1+) 1 !! 100000
04:19:23 <lambdabot>  100001
04:19:45 <dminuoso> int-e: Right Im guessing that whatever the implementation is, it does something like that.
04:20:25 <int-e> > let go !n = n : go (n+1) in go 1 !! 10000
04:20:28 <lambdabot>  10001
04:20:42 <int-e> dminuoso: for Integer at least, it appears to be closer to that
04:20:50 <int-e> (for enumFrom)
04:21:55 <dminuoso> int-e: I couldn't make sense of the implementation.
04:22:40 <zxtx> Hey, are there any guides / tutorials / papers on writing an interpreter in Haskell that includes ADTs
04:22:47 <zxtx> in perticular type-checking ADTs
04:23:07 <dminuoso> zxtx: the book "Types and Programming Languages" is probably your best bet to get started on the theory.
04:23:34 <dminuoso> zxtx: The execution/evaluation is usually separate from type checking.
04:24:20 <zxtx> dminuoso, oh I was going for some code that wrote an interpreter since I figured there would be a type checker there as well. My main interest is in the type checker
04:24:23 <int-e> dminuoso: enumDeltaInteger x d = x `seq` (x : enumDeltaInteger (x+d) d)  (in GHC.Enum) is clear enough. There's a lot of noise around, rewrite rules for making foldr/build fusion work.
04:24:54 <dminuoso> int-e: Ahh I was looking at Int, which had some more noise to it.
04:25:16 <int-e> dminuoso: Int is different in that it has an upper bound
04:25:30 <dminuoso> zxtx: Then the book would be even more appropriate.
04:25:45 <int-e> > [9223372036854775806..]
04:25:46 <lambdabot>  [9223372036854775806,9223372036854775807,9223372036854775808,922337203685477...
04:25:55 <int-e> hmm
04:26:03 <int-e> > [9223372036854775806..] :: [Int]
04:26:04 <lambdabot>  [9223372036854775806,9223372036854775807]
04:26:53 <rotcev> dminuoso: thanks for taking the time with me today on this topic
04:27:35 <aleator> Hi all! I'm having trouble using criterion properly (for stupid microbenchmark pissing contest). How come my measurement shows that naive quicksort is faster than Data.List.sort? See https://pastebin.com/iUqrMU42.
04:30:00 <dminuoso> Is it appropriate to call a type system a kind of automated theorem prover?
04:32:17 <dminuoso> Or maybe rather the type checker.
04:33:18 * hackage tintin 1.5.0 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.5.0 (NickSeagull)
04:37:39 <zincy> Any used persistant for hooking up to a DB? How do you get the value out of the Entity constructor when performing queries
04:40:16 <ziman> just match on it
04:40:23 <ziman> or use the projection function
04:44:00 <hpc> dminuoso: it's accurate
04:44:26 <hpc> dminuoso: although it operates at two levels, types as propositions and values as proofs
04:44:52 <hpc> (or maybe if you're feeling fancy in a language that distinguishes them, kinds as propositions and types as proofs)
04:45:16 <hpc> sometimes it's not a theorem prover in a useful logic system though
04:45:18 <hpc> :t undefined
04:45:19 <lambdabot> a
04:45:20 <hpc> :t fix id
04:45:21 <lambdabot> a
04:45:34 <hpc> ^ those are proofs of any proposition
04:46:13 <dminuoso> hpc: so they effectively act as falsity?
04:46:51 <hpc> as in the false proposition? that would be the empty type
04:46:59 <hpc> (it has no values, which means no proofs)
04:47:10 <dminuoso> But Void has bottom
04:47:16 <hpc> exactly
04:47:34 <hpc> Void still has no defined values, so it fits the role
04:48:16 <hpc> in a better logic system, you don't have bottom
04:48:26 <hpc> (obviously this requires the proof language to not be turing-complete)
04:48:46 <hpc> (because you can always get bottom from an infinite loop)
04:49:36 <hpc> there's some other stuff that matches up to logic really conveniently too
04:49:36 <Maxdaman1us> Well, you might have bottom, but you shouldn't be able to prove it.
04:49:41 <Maxdaman1us> From a contradiction, anything follows.
04:49:49 <hpc> (->) is implication, (,) is conjunction, Either is disjunction
04:49:53 <dminuoso> hpc: In a twisted sense that'd be curry's paradox right?
04:50:11 <hpc> Maxdamantus: you don't prove bottom, bottom is the proof
04:50:22 <dminuoso> Ohh
04:50:39 <rotcev> :t fix
04:50:39 <dminuoso> hpc: Because regardless of the proposition, bottom is always a valid proof of it?
04:50:40 <lambdabot> (a -> a) -> a
04:50:41 <hpc> (a -> Void) = ¬a
04:50:52 <hpc> dminuoso: yep
04:50:58 <Maxdamantus> hpc: the proof is the program that has a bottom type, which shouldn't exist (but it does in Haskell)
04:51:09 <hpc> if you read the type of fix as a proposition, if something implies itself than it is true
04:51:18 <hpc> but everything implies itself
04:51:23 <hpc> even false propositions
04:51:58 <hpc> Maxdamantus: by bottom type you mean Void?
04:52:08 <Maxdamantus> Ah, maybe the misunderstanding was what "bottom" was; I've always thought of "bottom" being a type, not some value/program.
04:52:10 <hpc> that can exist in a more consistent language
04:52:17 <hpc> bottom is undefined
04:52:23 <hpc> > undefined
04:52:25 <lambdabot>  *Exception: Prelude.undefined
04:52:25 <hpc> > fix id
04:52:28 <lambdabot>  *Exception: <<loop>>
04:52:37 <Maxdamantus> Yeah, I've never liked that description.
04:52:38 <hpc> or an infinite loop, or some other expression that doesn't evaluate to anything
04:52:40 <dminuoso> Maxdamantus: bottom is the least defined value
04:52:51 <dminuoso> (which requires talking about definedness)
04:53:04 <Maxdamantus> Especially in Haskell, where you need to realise it as being of a monotype.
04:55:03 * hackage require 0.2.0 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.2.0 (NickSeagull)
04:55:26 <tdammers> you can think of bottom in one of two ways: a singleton value that inhabits all types, or the absence of a value / undecidability
04:55:32 <Maxdamantus> You'd need to have an abstract notion of bottom being "the result of running something that can't successfully be run", which seems silly to me.
04:56:22 <Maxdamantus> You usually run things to get a value, but you never get a value out of running `undefined :: Int`, or substituting any other type in there.
04:56:39 <Maxdamantus> so there's no actual bottom value at least.
04:56:43 <tdammers> well, you can reason both ways
04:56:59 <tdammers> you can also say that trying to get a value out of `undefined :: Int` yields the bottom value
04:57:12 <tdammers> so does `undefined + 1`
04:57:18 <Maxdamantus> The bottom value of type Int?
04:57:22 <tdammers> the bottom value
04:57:26 <tdammers> it inhabits all types
04:57:38 <tdammers> even Void
04:57:56 <tdammers> both lines of reasoning work
04:57:58 <dminuoso> Maxdamantus: _|_ :: forall a. a
04:58:03 <tdammers> but you have to pick one or the other
04:58:28 <tdammers> i.e., you can't start reasoning in terms of "bottom is a value", and then later change your mind for the rest of your argument
04:58:51 <tdammers> also, in practice, bottom may be a value, but evaluating it may not terminate
04:59:17 <Maxdamantus> dminuoso: well, the placement of the forall quantification is a bit misleading there; logically it should be something more like: `forall a. _|_ :: a`
04:59:40 <Maxdamantus> dminuoso: you give me a type, `a`, and I'll give you a value of that type (supposedly)
05:00:44 <dminuoso> Maxdamantus: no, what you are talking about is
05:00:46 <dminuoso> :t absurd
05:00:48 <lambdabot> Void -> a
05:01:38 <hpc> not quite
05:01:50 <hpc> you can prove absurd in a consistent language
05:02:11 <hpc> because Void really does imply anything
05:02:23 <hpc> and if you could ever make a value of that type you'd really be in trouble
05:02:26 <hpc> but you can't so it's fine
05:02:42 <dminuoso> Maxdamantus: also interestingly, when I say that `_|_ :: forall a. a` the whole thing turns out to be an abstraction over a type already.
05:02:45 <hpc> ... actually yeah
05:02:49 <hpc> nvm you're right
05:02:50 <dminuoso> :t undefined @Int
05:02:52 <lambdabot> error:
05:02:52 <lambdabot>     Pattern syntax in expression context: undefined@Int
05:02:52 <lambdabot>     Did you mean to enable TypeApplications?
05:02:53 <simon> for a parser combinator in applicative style, I'd like to parse "foo(a, b)" as: 'Foo <$> arg <,> arg' where (<,>) is like (<*>) but where it also eats a comma and some whitespace. unfortunately, <,> isn't a valid operator name. I've settled with <**> for now, but I don't think it's very obvious that it eats a comma and whitespace, too, and I'd settle with `comma` if I could make that have infixl 4 like <*>.
05:02:57 <dminuoso> % :t undefined @Int
05:02:57 <yahb> dminuoso: ; <interactive>:1:12: error:; * Expected kind `RuntimeRep', but `Int' has kind `*'; * In the type `Int'; In the expression: undefined @Int
05:02:59 <simon> .. any ideas?
05:03:00 <hpc> you pass _|_ :: Void to that, and get _|_ :: something else
05:03:53 <simon> whoops. 'Foo <$> call "foo" <,> arg <,> arg' (eating the name 'foo' and the parentheses), of course.
05:04:34 <dminuoso> simon: Why not make some combinator that will give you args as a list?
05:04:49 <simon> dminuoso, my AST constructor takes a fixed number of arguments.
05:05:55 <phadej> simon: withComma p = p *> eatCommaAndWhitespace; Foo <$> withComma arg <*> arg'
05:06:03 <simon> dminuoso, I thought about an 'args2 :: Parser a -> Parser b -> Parser (a, b)' and similarly an args3, but since my AST constructor is uncurried, and since the rest of my parser is written in applicative style, I thought this'd be neat...
05:06:11 <phadej> simon: or: Foo <$> arg <* eatcommaAndWhitespace <*> arg'
05:07:05 <simon> phadej, this was what I did before: Foo <$> arg <*> comma arg <*> comma arg. but I thought the 'comma' gets lost there, like, there's a few places where combinators don't take concrete-syntax commas, like the syntax 'if foo within bar' -> IfExp foo bar'
05:07:39 <simon> phadej, maybe that *is* the prettiest solution. I thought maybe Foo <$> arg <,> arg was pretty, too. but not syntactically possible.
05:08:25 <simon> s/lost/visually lost/
05:08:49 <simon> this really a things from the Small Things Dept., I should probably not worry about it. :)
05:10:25 <merijn> If Foo is a record with named fields you can use RecordWildCards and do-notation to do that nicely
05:10:52 <merijn> simon: See this example: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Parsers.hs#L71-L79
05:11:45 <merijn> simon: By splitting it up and using <* it's both still clear what matters about the parsing and what is getting swallowed but thrown away
05:12:01 <merijn> And with RecordWildCards you avoid the issue of "shit, I have to invent unique names"
05:12:39 <simon> merijn, wot. that's pretty neat.
05:13:37 <merijn> simon: :)
05:14:43 <merijn> simon: A lot of people think RecordWildCards can only pattern match records, but it can also construct them and IF there's a variable in scope with the appropriate field name, it will use that as the value for the field :)
05:15:32 <Maxdamantus> 00:02:21 < dminuoso> Maxdamantus: also interestingly, when I say that `_|_ :: forall a. a` the whole thing turns out to be an abstraction over a type already.
05:15:51 <Maxdamantus> dminuoso: exactly, so your notion of _|_ (which doesn't exist in Haskell) is a function, not an actual "bottom" value.
05:16:06 <dminuoso> Maxdamantus: that depends on what you mean by function really
05:16:13 <Maxdamantus> dminuoso: in a language that is not Haskell, you might describe that as `(a: Type) -> a`
05:16:46 <dminuoso> Maxdamantus: In one perspective its fully polymorphic because it happens to inhabit all types.
05:17:02 <Maxdamantus> That function could very well be an obtainable value, but you're obviously not going to be able to successfully call it, because the function won't be able to produce a value itself.
05:18:42 <Maxdamantus> dminuoso: well, the type I gave is not polymorphic in the way that Haskell is polymorphic, since there are no free variables.
05:20:19 <Maxdamantus> also note that the type above is not the type of `absurd`; it's a function that takes a type, not a `Void`
05:21:18 <Maxdamantus> as hpc said, `absurd` is perfectly logical; I can define it in Idris no problem.
05:21:47 <Maxdamantus> I can't define something of type `(a: Type) -> a`, because that would let me prove anything.
05:23:58 <dminuoso> Maxdamantus: Honest question: How can you know Idris and still write JavaScript code without causing damage to your computer every day?
05:24:27 <Maxdamantus> dminuoso: maybe knowing Idris lets me write JavaScript without damaging my computer.
05:24:29 <dminuoso> Otoh that might be a bit presumpteous.. how much money does your employer dish out for monitors every week?
05:25:43 <Maxdamantus> Well, my employer hasn't spent any money on hardware for me specifically since I arrived.
05:27:13 <Maxdamantus> fwiw I don't know Idris *that* well, but I understand the basic concepts in DTT/whatever and have proved some basic things in it.
05:29:02 <dminuoso> Maxdamantus: Oh I know. In secret you write all your code in PureScript. The other colleagues constantly wonder how their "Idris-knowing type god" can write such abstract JavaScript code - but they trust you because you always seem to ship quality JS code!
05:43:21 <exarkun> aeson (by way of servant-server) is serializing empty `Map Integer [ByteString]` as "[]" instead of "{}"... What gives?
05:47:28 <Axman6> o.O
05:48:02 <exarkun> something to do with ToJSONKey instances ... maybe?
05:48:05 <kuribas> dminuoso: wouldn't they be tipped off by the fact that all your functions are written curried?
05:48:09 <lyxia> that's surprising
05:49:57 <lyxia> exarkun: how did you serialize it
05:51:20 <lyxia> I'm getting {}
05:51:32 <exarkun> I narrowed it down a bit further, my question was wrong, sorry
05:52:00 <exarkun> it's actually `Map ShareNumber [ShareData]` where `newtype ShareNumber = ShareNumber Integer`
05:52:07 <phadej> simon: both `comma p <*>` and `p <+>` are such you can make mistake and type system won't help you to catch it. So IMHO they are both equally bad or good. Yet, I'd not make new operators except if there are really more "<+>" than "<*>"
05:52:58 <exarkun> (but now I'm trying to figure out how I ended up with a non-string key at all, since you can't do that in json...)
05:54:49 <kuribas> non string keys are serialized as a list of pairs
05:55:55 <kuribas> well, it depends on the key
05:57:21 <kuribas> if the key is itself a composite object, the resulat is an array of two element arrays.
05:57:40 <kuribas> by default.  It can be overridden.
05:58:07 <guestedmfd> hello
05:59:14 <exarkun> kuribas: by providing a ToJSONKey instance?
05:59:36 <kuribas> exarkun: yeah
06:04:50 <dave24> Hello, I'm on OSX and ghc is trying to run gcc with an option `-no-pie` which it does not recognize. Where can I get a gcc that works with ghc?
06:06:02 <mnoonan> dave24: how did you install ghc?
06:06:51 <dave24> mnoonan: I downloaded the haskell platform core and ran the installer
06:07:09 <mnoonan> I believe the Haskell Platform isn't really recommended anymore
06:07:28 <dave24> oh, what should I use instead?
06:07:40 <eelster> I use stack on mac and I love it.
06:07:53 <mnoonan> same
06:07:54 <mnoonan> https://docs.haskellstack.org/en/stable/install_and_upgrade/#macos
06:08:03 <dave24> ok, I'll try that.
06:08:34 <eelster> I'd use brew to install it so you can easily keep it up to date, but that's just a personal preference.
06:09:05 <mnoonan> dave24: for reference later on, iirc OSX's "gcc" is actually a version of clang.
06:09:08 <merijn> I usually just install the GHC bindist on OSX (and any platform, really)
06:09:28 <mnoonan> so if you're running into weird problems with your gcc, just realize it might not really be one at all :)
06:09:55 <dave24> mnoonan: yes I have 3 GCCs and 1 clang installed, none of them work :D
06:10:18 <aleator> Hi! I'm having trouble using criterion properly: naive quicksort benchmarks 2 times faster than Data.List.sort. Can anyone see what's up? See https://pastebin.com/iUqrMU42
06:27:08 <Axman6> aleator: you might want to force the list to normal form and pick one type for it before the test
06:28:13 <Axman6> so, have nums <-  replicateM 10000 randomIO :: IO [Int]; let !_ = deepseq nums (); ...
06:33:12 <dave24> I used stack and managed to build something, but now the resulting executable segfaults
06:34:32 <eelster> Is there infinite recursion by chance?
06:39:53 <yorick> hi! how do I tell ./Setup install to only install specific targets?
06:40:13 <yorick> I currently do ./Setup build exe:thing, but with installation, it can't find otherthing
07:02:30 <mbwgh> Does anybody have an idea where you can read more about defining "pointwise lifting of operators"? I am talking about things like instance Semigroup b => Semigroup (a -> b). Addition of functions likewise can be defined as f + g = \x -> f x + g x. This can be extended to things like functions returning some field F ~ F^1, and the function is itself a vector. Likewise, interpreting linear transformations as
07:02:36 <mbwgh> "functions returning vectors", again form a vector space Hom(V,W). Now the point-wise lifting of addition and scalar multiplication even preserves linearity. The point is, once you start looking for things like that, they start to pop up everywhere, but it is hard to find a general treatment of this topic. There is a wikipedia article: https://en.wikipedia.org/wiki/Pointwise . But alas, although the more
07:02:42 <mbwgh> general setting of some algebraic structure A is mentioned briefly, no citation is given.
07:05:07 <AWizzArd> I would like to introduce an alias  `type RuleInfo = ([Expr i1 i2 r], Rule i1 i2 r i o)`  – but GHC complains and demands that I do  `type RuleInfo i1 i2 r i o = ([Expr i1 i2 r], Rule i1 i2 r i o)`  instead, where the type parameters show up again. Is there a way to go with my preferred version?
07:05:38 <merijn> AWizzArd: How would GHC figure out where those type variables come from?
07:05:40 <AWizzArd> So I can say just `RuleInfo` vs `RuleInfo i1 i2 r i o`
07:06:01 <AWizzArd> merijn: I want it to treat this as a hard macro.
07:06:05 <merijn> You could try making it a RankN type, but that might not work out nicely in all cases
07:07:01 <merijn> Actually, I have no idea if that even makes sense
07:07:13 <AWizzArd> Can something like PatternSynonyms help?
07:09:22 <merijn> Why would it?
07:09:31 <merijn> PatternSynonyms is for pattern matching, not types
07:10:18 <mbwgh> type RuleInfo = forall i1 i2 r i o. ([...) would be the logical first thing to try.
07:11:16 <merijn> mbwgh: See, the more I think about it, the less I'm sure that formulation makes any sense whatsoever
07:12:47 <AWizzArd> So I’ll probably go with the explicit type parameters then. Thx for confirming.
07:21:04 * hackage llvm-hs-pretty 0.4.0.0 - A pretty printer for LLVM IR.  http://hackage.haskell.org/package/llvm-hs-pretty-0.4.0.0 (sdiehl)
07:46:48 <portnov> hi all
07:47:26 <portnov> Q: how do I express "packages: [some-directory]" feature of stack.yaml in package.yaml ?
07:48:13 <AWizzArd> Is there something like an „upsert” for Data.Map.Strict?
07:48:25 <AWizzArd> Nevermind: `alter` looks good
07:53:11 <jah_> anybody know the stack build flag to not let warnings stop the build?
08:02:20 <machinedgod> kandinski: Ahoy hoy
08:02:25 <machinedgod> Oups, wrong channel, sorry
08:26:36 <dminuoso> Intero doesn't seem to pick up the QuickCheck dependency from my package.yaml. Im getting flycheck errors on `could not find module "Test.QuickCheck"`  inside my Spec.hs
08:26:50 <dminuoso> `stack test` runs just fine though
08:28:30 <dminuoso> (I've already tried killing intero as well as completely restarting emacs to no avail)
08:31:27 * hackage require 0.2.1 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.2.1 (NickSeagull)
08:33:10 <[exa]> dminuoso: (intero-toggle-debug) and retry ?
08:33:48 <[exa]> dminuoso: after that I'd go with strace to see where it looks for the modules
08:36:23 <dminuoso> [exa]: Mmm. This is so frustrating strange. It suddenly picks up the module..
08:39:04 <[exa]> dminuoso: and they said debugging doesn't work! :D
08:40:56 <dminuoso> I mean dont get me wrong, I appreciate all the work put into intero, but at times it doesn't really feel stable..
08:41:34 <sm> sounds like all haskell editor integration ever :)
08:43:40 <texasmynsted> ghcid
08:44:09 <texasmynsted> ghcid is very nice
08:45:04 <sm> it doesn't integrate with the editor. And yes, agreed
08:50:00 <Myrl-saki> https://gist.github.com/adrianparvino/a160a28b1b3e6e6ea06cc681947f0c69
08:50:15 <Myrl-saki> I made something to demonstrate how BTC PoW works. :D
08:53:27 <Athas> Does Data Parallel Haskell work/build these days?
09:06:30 <phittacus> Hi.
09:06:31 <phittacus> It's quite off-topic, but I don't have a better place to ask. (I would appreciate if you would point me to a more relevant channel)
09:06:32 <phittacus> I'm quite interested in fp, plt and type theory (not off-topic part:  I developed all that because of Haskell :) and want to go for masters degree to Germany, but I struggle to chose univercity -- is TUM any good in this context? Is it worth it to go there if one's interested in plt\tt?
09:51:42 <delYsid> Monad is like a hammer. If you have a Monad, everything looks like a nail.  When reading pure functional code in Haskell or Purescript, I happened to spot this pattern pretty often: do { x <- qux; pure $ bar $ qux } which is clearly just bar <$> qux.  Easier to read, and (probably) more efficient.  I wonder why functional people have this tendency to overuse 'do' which makes their codes sometimes almost look like a different language...
09:52:18 <delYsid> er, pure $ bar $ x, but you get the idea.
09:53:11 <glguy> It's likely not more efficient if you're using it at a specific instance, say IO, and it allows you to name the result which can make code easier to understand
09:54:05 <dave24> Whenever I call into other packages my program segfaults. Does anybody have any ideas why this might be, I don't know how to debug this.
09:54:23 <dave24> runhaskell works fine
09:54:44 <delYsid> Hmm, interesting. I mostly felt the variable was an anoyance, something that needed naming which actually wouldn't need a name.
09:55:30 <delYsid> er, binding, or whatever
09:55:50 <delYsid> Maybe I am more of an applicative fan then others.
09:56:18 <delYsid> Probably, since I find it sad GHC has no idiom brackets :-)
09:58:28 <pavolzetor> what are packages that let me do printf when using foundation?
09:58:39 <pavolzetor> or anything like python 'string'.format()
09:58:49 <pavolzetor> I especially need zero padding
09:59:27 <crick_> Can someone please look at my convex hull code, I don't know where I am going wrong! I feel I have written it correctly... : https://lpaste.net/6642900787145998336
09:59:54 <glguy> pavolzetor: There's very little code using foundation. You can check the reverse deps list to see if there's anything available: http://packdeps.haskellers.com/reverse/foundation
10:00:14 <crick_> I have used the graham scan algorithm
10:01:30 <pavolzetor> hmm, the edge package is not in stackage
10:02:05 <glguy> That's pretty normal, you can add things to your extra-deps if you're using stack
10:09:10 <pavolzetor> I rather not pull stuff outside snapshot
10:09:12 <pavolzetor> http://hackage.haskell.org/package/fmt-0.6/docs/Fmt.html
10:09:40 <pavolzetor> I tried the example '>>> format "{} + {} = {}" 2 2 4' and it does run
10:11:01 <glguy> We can't see your screen
10:11:50 <dminuoso> Are there libraries that expose part of their quickcheck suite? In particular Im looking for a clean way to provide for Arbitrary instances and some useful testing combinators.
10:13:42 <pavolzetor> Give me a sec, I am trying to get it run; it works in repl
10:16:15 <joeyh> hmm, my cabal upload is stalling (repeatedly)
10:16:26 <joeyh> hackage is up though, generally
10:17:43 <pavolzetor> glguy, I misunderstood haskell error message
10:18:12 <pavolzetor> basically, putStrLn needed foundation string, but the error was showing on different line
10:19:08 <pavolzetor>     * No instance for (Fmt.Internal.FromBuilder String)
10:19:32 <glguy> Why are you using foundation?
10:19:59 <pavolzetor> It would be more helpful to print that below the putStrLn as that is the latest point where the conversion must happen
10:20:18 <glguy> What conversion?
10:20:36 <pavolzetor> from the builder type to the string i suppose
10:20:44 <glguy> There's no conversion
10:20:54 <pavolzetor> I added (fromList) to fix it
10:21:38 <pavolzetor> maybe it is called differently, my understanding is that it fixes the type at that point from a set of potential types that the format builder supports
10:22:25 <pavolzetor> and I use foundation because it is single package that has most of the stuff and it is consistent with nice API
10:25:31 <pavolzetor> it requires some explicit type specifications to interoperate with the other packages. I would love to see something like python built-in library in foundation
10:28:46 <JuanDaugherty> it's the summer of love!
10:29:54 <shapr> I love Haskell!
10:31:39 <JuanDaugherty> https://www.youtube.com/watch?v=5CaMUfxVJVQ what I think of when I hear people use that word like they do currently
10:33:18 <JuanDaugherty> i'd lover to see you up on the catwalk, O hs princess!
10:33:27 <JuanDaugherty> *love
10:37:16 <JuanDaugherty> i still can't stop laughing about referring to someone's choice of joomla by referring to the awareness that their choice of platform turned to shit
10:37:38 <__monty__> DonJuanDaugherty?
10:37:49 <glguy> JuanDaugherty: Maybe you're looking for #haskell-offtopic?
10:39:16 <JuanDaugherty> in " I would love to see something like python built-in library in foundation " dose foundation mean prelude?
10:39:51 <glguy> ?hackage foundation
10:39:51 <lambdabot> http://hackage.haskell.org/package/foundation
10:40:18 <JuanDaugherty> ah y, remember now
10:43:12 <dmwit> joeyh: mightybyte was complaining similarly the other day; maybe hop into #haskell-infrastructure and see if they know why that's still happening?
10:43:29 <JuanDaugherty> Maybe #haskell-offtopic | #haskell-blah
10:52:39 * hackage katip 0.5.5.1 - A structured logging framework.  http://hackage.haskell.org/package/katip-0.5.5.1 (MichaelXavier)
10:54:50 <crestfallen> hi I changed line 94's   <-   to a   <=   . I'm assuming that is a typo. how should this line look? thanks   https://github.com/evturn/programming-in-haskell/blob/master/09-the-countdown-problem/09.11-exercises.hs
10:55:02 <tabaqui1> where can I read about mock unit-testing?
10:55:15 <tabaqui1> I found one article on Pusher blog, but it is too specific
10:55:31 <tabaqui1> I do not want to write new monad for each IO library
10:57:36 <crestfallen> with my edit, the program compiles but on running it returns brief error: divide by zero
10:58:03 * hackage git-annex 6.20180529 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-6.20180529 (JoeyHess)
10:59:29 <__monty__> EvanR: : o ^ ; )
10:59:35 <dminuoso> > 1 `div` 0
10:59:37 <lambdabot>  *Exception: divide by zero
10:59:38 <dminuoso> crestfallen: ^-
10:59:54 <dminuoso> crestfallen: So something causes an expression to be evaluated, where you are trying to divide by zero.
11:00:22 <crestfallen> thanks yeah no clue. this program is in a beginning haskell book. fully overwhelmed by it
11:00:25 <crestfallen> dminuoso,
11:00:59 <crestfallen> just git pulled all these solutions.
11:01:00 <dminuoso> crestfallen: That's just some other readers attempted solutions to the book.
11:01:08 <crestfallen> yeah
11:01:21 <dminuoso> crestfallen: As you have discovered, first there's syntax bugs, then there's logic bugs..
11:01:33 <dminuoso> That's kind of bound to happen if you refer to examples written by other readers. =)
11:02:09 <crestfallen> my edit is incorrect though it compiles. yeah no chance I could even *dream* of solving these exercises
11:02:51 <dminuoso> crestfallen: Did you do the previous excercises?
11:03:48 <crestfallen> let's put it this way: in the entire first chapter of the sicp book, I solved pascal's triangle alone. aside from that, I pinched all the solutions
11:03:57 <crestfallen> in scheme
11:05:04 <dminuoso> crestfallen: The point of excercises is not to have a solution. The point is let you engage yourself with it.
11:05:10 <dminuoso> So there's little value in pinching solutions.
11:06:04 <xafizoff> @help
11:06:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:06:07 <crestfallen> word
11:06:32 <xafizoff> ?src Maybe
11:06:32 <lambdabot> data Maybe a = Nothing | Just a
11:06:51 <xafizoff> ?wiki Maybe
11:06:51 <lambdabot> https://wiki.haskell.org/Maybe
11:07:56 <__monty__> crestfallen: Debugging solutions is harder than writing them in the first place.
11:08:55 <crestfallen> I am making progress with type inferring / type unifying. also by studying the evaluation order (writing out by hand) . I'm getting some of the mathy stuff but I don't know if I will get this stuff from a book ..  dminuoso
11:08:58 <crestfallen> word __monty__
11:09:47 <dminuoso> crestfallen: Well if you effectively skip out on excercises..
11:11:05 <__monty__> crestfallen: I didn't mean it's harder so you'll learn more, more the opposite. You said you couldn't *dream* of solving the exercises. Then how do you expect to succeed at debugging someone else's solutions? : )
11:11:58 <dminuoso> crestfallen: Excercises are crucial to learning. It's when you approach a problem that's barely beyond your horizon and force yourself to solve it that you can learn the most.
11:12:28 <dminuoso> So when you progress from excercise 1 to 2 and things seem harder, that's because a problem will only engage you if you dont know how to solve it yet.
11:12:44 <crestfallen> this is not barely beyond my horizon.
11:13:27 <dminuoso> crestfallen: Like you said, you started skipping out on excercises in chapter 1.
11:13:34 <dminuoso> You're staring at some excercises in chapter 9.
11:13:36 <monochrom> OK, so backtrack, re-start the previous chapter.
11:17:27 <noan> So I have a bit of a mental puzzle. It basically works out to this situation.. Obviously the haskell compiler can check to a reasonable degree if a function definition is non-total. But lets say what I want is essentially a total map between an ADT and resultant values, at run time. I can construct this relatively easy as a function, but this means re-evaluation. It's a bit computationally expensive and I was thinking I'd like to use a
11:17:27 <noan> Map, but Map wouldn't guarantee at a type level the totality. Is there a map type that enforces totality at construction time, or am I chasing a red herring and being stupid?
11:18:34 <monochrom> Lazy evaluation learning order: let {studyChapter i = if understand i then done else studyChapter (i-1)} in studyChapter (maximum :: ChapterNumber)
11:20:43 <[exa]> noan: if it's total, I guess there is a finite number of "cases" right?
11:21:00 <dminuoso> noan: What do you mean by "reevaluation"
11:21:44 <crestfallen> how would a beginning be expected to comprehend the error I got after guessing the operator should be >=    ?    https://lpaste.net/73864881916346368
11:22:38 <monochrom> Gosh, by Chapter 9 you would not call yourself a beginner.
11:22:53 <[exa]> crestfallen: this shounds like libc being linked twice to the program
11:23:19 <crestfallen> no clue [exa] what that means
11:23:47 <monochrom> And this sounds like a stack bug.
11:24:05 <dminuoso> [exa]: not the libc, rather the crt1/crti
11:24:18 <[exa]> yeah.
11:24:19 <monochrom> Why is stack involved in the first place?
11:24:21 <dminuoso> And that's definitely a compiler issue
11:24:34 <dminuoso> (because you'd have a really hard time taking control of this)
11:24:41 <mnoonan> is that asking ghc to use the final executable as an input to the linker? what is going on there?
11:24:57 <dminuoso> monochrom: if you install ghc through stack...
11:25:10 <glguy> "stack ghc 09.11-exercises" this command doesn't look like a normal way to build a project with stack in the first place
11:25:19 <monochrom> Then either "it works out of the box" or it's a stack bug.
11:25:42 <dminuoso> Im guessing that 09.11-exercises _somehow_ gets interpreted as flags?
11:25:42 <glguy> You probably don't need to involve stack in the first place for just working through exercises. That's a much heavier weight tool
11:26:01 <dminuoso> But yes, if you rename the file with a .hs suffix and then compile it, it will work "fine", crestfallen.
11:26:09 <dminuoso> But boy thats quite surprising
11:27:35 <mnoonan> indeed, something weird like that. i have no problem if I do "stack ghc test.hs" and then "stack ghc test", but if I rename test to 09.11-exercises, I get a linker error
11:28:07 <mnoonan> crestfallen: anyway, the point is you're not compiling the right file (or possibly even have overwritten your input file?)
11:28:29 <dminuoso> Ah..
11:28:39 <dminuoso> so it seens like for some reason ld is accepting the file as linker input
11:29:46 <crestfallen> ok , trying to follow that. not sure good people. let me work on that and if I may change the subject.. a member told me not to think of "handwriting" two types and unifying them into a single type, but to infer a single type. I'm making some headway and looking at examples online. I enjoy it too. but when there is no constraint inferred by ghci, do you have a unification of types, or what should the terminology be?
11:30:57 <fishythefish> sounds like what they're saying is not to think of the result as a new type generated from "adding" the two types you already have
11:31:06 <fishythefish> rather, it's a single type which is equal to the two simultaneously
11:32:09 <crestfallen> but barring a need for a constraint , there are still other elements that influence your way of going about it, right?
11:32:17 <tsahyt> I found bhoogle yesterday and thought it'd be nice to have a GTK version. So here's some shameless self-promotion: https://github.com/tsahyt/hoogle-gtk
11:32:30 <dminuoso> crestfallen: Do you have a concrete example to talk about?
11:32:47 <fishythefish> crestfallen: a concrete example would be nice, and would also clarify what you mean by "constraint"
11:32:52 <mnoonan> (btw, this seems to be a ghc issue rather than a stack issue. I see the same behavior when invoking ghc directly)
11:33:06 <dminuoso> And apparently the bug is so extreme, it crashes IRC clients.
11:33:28 <crestfallen> really appreciate it mnoonan ... seriously crashes your client?
11:33:59 <dminuoso> mnoonan: I tried it, and Im getting similar but different issues.
11:34:03 <dminuoso> mnoonan: I think its a non-bug.
11:34:18 <dminuoso> If the linker is, for whatever obscure reasons, happy to accept it as input - well..
11:34:32 <crestfallen> please don't look monochro*m
11:34:36 <dminuoso> mnoonan: https://gist.github.com/dminuoso/b0a115fac5987e894f4a2b7dc02fc1d4
11:34:38 <mnoonan> crestfallen: similar enough that I'm sure it's the same issue: https://lpaste.net/1321234572788105216
11:35:09 <dminuoso> So it's just that the linker receives your haskell file as an object file input
11:35:26 <dminuoso> which apparently ld silently accepts.
11:35:28 <crestfallen> @let gg :: (a -> b) -> a -> c -> b; f a c = f a
11:35:29 <lambdabot>  .L.hs:179:1: error:
11:35:29 <lambdabot>      The type signature for ‘gg’ lacks an accompanying binding
11:35:29 <lambdabot>      |
11:35:44 <crestfallen> @let gg :: (a -> b) -> a -> c -> b; gg f a c = f a
11:35:45 <lambdabot>  Defined.
11:36:04 <crestfallen> > gg (+) 1 "t" 4
11:36:06 <lambdabot>  5
11:36:14 <crestfallen> :t gg (+)
11:36:15 <lambdabot> Num a => a -> c -> a -> a
11:36:35 <crestfallen> so the machine works out the constraint
11:36:53 <mnoonan> dminuoso: yeah, basically the same except I'm on ld.gold
11:36:55 <fishythefish> :t 5
11:36:56 <lambdabot> Num p => p
11:37:17 <dminuoso> mnoonan: right, they use GNU ld though
11:37:24 <fishythefish> ignoring defaulting right now, the Num constraint is still there
11:37:25 <dminuoso> might even be a gcc bug
11:38:26 <crestfallen> > gg const id 5 "t"
11:38:28 <lambdabot>  error:
11:38:28 <lambdabot>      • No instance for (Typeable a0)
11:38:28 <lambdabot>          arising from a use of ‘show_M274021919512569318324479’
11:40:12 <dminuoso> > gg (+) 1 "t" 4 -- crestfallen
11:40:12 <crestfallen> gg (+) 4 "t" 1
11:40:14 <dmwit> > gg const id 5 "t" 4
11:40:14 <lambdabot>  5
11:40:17 <lambdabot>  4
11:40:17 <dminuoso> :t gg (+) 1 "t" 4 -- crestfallen
11:40:18 <lambdabot> Num a => a
11:40:26 <crestfallen> oops
11:41:23 <dminuoso> mnoonan: so the only question is why does GCC with GNU ld try to link crt1/crtl twice..
11:41:26 <crestfallen> > :t gg const id
11:41:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:41:34 <crestfallen> :t gg const id
11:41:35 <lambdabot> c -> b -> a -> a
11:41:52 <dminuoso> :t const . $ const id
11:41:54 <lambdabot> error:
11:41:54 <lambdabot>     parse error on input ‘$’
11:41:54 <lambdabot>     Perhaps you intended to use TemplateHaskell
11:42:00 <dminuoso> :t (const .) $ const id
11:42:01 <lambdabot> b1 -> b2 -> a -> a
11:42:10 <crestfallen> fishythefish, sorry reading your comments now
11:42:33 <Gurkenglas> Using the quantum computer simulator QIO, "main = print $ sim $ and <$> replicateM 2 randBit" prints "[(True,0.25),(False,0.25),(False,0.25),(False,0.25)]". Shouldn't equal states be thrown together?
11:42:44 <dmwit> "Google for Haskell" -> "hoogle"; "Hoogle UI in Brick" -> "bhoogle". The Haskell community really needs to work on its imagination.
11:43:10 <glguy> himagination
11:43:19 <dminuoso> dmwit: Just be glad our wiki is not named hiki
11:43:31 <dmwit> dminuoso: =D
11:43:34 <[exa]> :D
11:45:47 <dmwit> Gurkenglas: "Should" questions are v tricky to answer.
11:47:00 <tsahyt> dmwit: I plead guilty
11:47:07 <tsahyt> but at least I didn't name it ghoogle
11:47:26 <crucify_me> anyway that is the sort of exercise I like doing. but fishythefish could you reword this please ? :     ignoring defaulting right now, the Num constraint is still there
11:50:11 <fragamus> Hi I need some help with a recursive function in the list monad
11:50:13 <crucify_me> sorry how did my nick change
11:50:30 <fragamus> f xs = do {return xs;x<-[1,2,3]; if sum (x:xs) < 10 then do {f (x:xs)} else return () }
11:50:54 <fragamus> The part I don’t want is the return in the else clause
11:51:15 <tsahyt> what do you want it to do if the sum is >= 10?
11:51:36 <fragamus> Not generate that permutation
11:52:03 <tsahyt> :t guard
11:52:05 <lambdabot> Alternative f => Bool -> f ()
11:52:09 * hackage ccast 0.1.0.0 - typesafe c-style casts; useful for FFI  http://hackage.haskell.org/package/ccast-0.1.0.0 (chessai)
11:52:24 <tsahyt> fragamus: this is probably what you want instead of the if
11:53:16 <fragamus> Ok tsahyt thanks
11:53:35 <tsahyt> fragamus: also the first return doesn't do anything
11:53:52 <tsahyt> so there's probably something else wrong
11:54:56 <crestfallen> sorry fishythefish I stepped away and my nick changed
11:55:18 <crestfallen> why would that happen
11:55:57 <fishythefish> :t 1 + 1
11:55:58 <lambdabot> Num a => a
11:56:01 <fishythefish> :t 1 + (1 :: Int)
11:56:02 <lambdabot> Int
11:56:29 <crestfallen> anyway that is the sort of exercise I like doing. but could you reword this please ? :     ignoring defaulting right now, the Num constraint is still there
11:56:30 <byorgey> crestfallen: because of a netsplit
11:58:07 <fishythefish> crestfallen: you were talking about a constraint being "worked out" during unification
11:58:36 <fishythefish> I'm still not sure whether you specifically mean a typeclass constraint or if you're talking about something more general, but I'm demonstrating that the typeclass constraint can persist
11:59:28 <crestfallen> but before unifying (+) it's polymorphic, so I don't quite see this
11:59:49 <fishythefish> it's polymorphic after too
12:00:52 <crestfallen> but the constraint looked at alone is not polymorphic, that's what a constraint is ii understand correctly
12:01:57 <the_2nd> if I have a functioned defined which is never used, will it end up somewhere in the binary?
12:02:04 <the_2nd> *function
12:02:05 <crestfallen> sorry I don't get your point
12:02:09 <dminuoso> crestfallen: strictly speaking no
12:02:26 <fishythefish> a constraint alone is not a value, so the question of polymorphism in the usual sense is moot
12:02:29 <dminuoso> crestfallen: It's not the context that makes something polymorphic. Think about a context as "reducing" possible choices.
12:02:48 <dminuoso> `Num a => a` is actually short for: `forall a. Num a => a`
12:03:12 <crestfallen> ok yeah so Num a =>   is describing 2 or 3 possibilities
12:03:21 <fishythefish> no
12:04:06 <crestfallen> > gg (+) (4 :: Int) "t" 5
12:04:09 <lambdabot>  9
12:04:10 <dmwit> the_2nd: Could do. I've sometimes found `strip` can cut my executable size by a factor of 3 or more.
12:04:14 <fishythefish> even with the (Num a) constraint, there are certainly more than 2 or 3 possibilities for what a is, and potentially infinitely many possibilities for a value of a
12:04:49 <dminuoso> :t head
12:04:51 <lambdabot> [a] -> a
12:05:12 <dminuoso> crestfallen: Consider this example. It's a polymorphic function (because it abstracts over some type named `a`)
12:05:40 <crestfallen> > gg (+) (4 :: Int) "t" (5 :: Integral)
12:05:42 <lambdabot>  error:
12:05:43 <lambdabot>      • Expecting one more argument to ‘Integral’
12:05:43 <lambdabot>        Expected a type, but ‘Integral’ has kind ‘* -> Constraint’
12:06:06 <fishythefish> > gg (+) (4 :: Int) "t" (5 :: Int)
12:06:08 <lambdabot>  9
12:06:13 <mnoonan> dmwit: doesn't that only remove symbols and debug information, or are there some magic arguments to strip that I want to know about immediately? :)
12:06:29 <dmwit> % :t head @Char -- head has no constraint, so this is okay
12:06:29 <yahb> dmwit: [Char] -> Char
12:06:45 <dmwit> % :t (+) @Char -- (+) has constraints that Char doesn't satisfy, so this is not
12:06:45 <yahb> dmwit: ; <interactive>:1:1: error: No instance for (Num Char) arising from a use of `+'
12:06:56 <crestfallen> dminuoso, that I do see
12:07:00 <dminuoso> crestfallen: the user of `head` can freely choose what `a` is going to. You can pick _any_ type whatsoever
12:07:07 <dminuoso> With no constraints.
12:07:13 <crestfallen> copy that
12:07:17 <dmwit> mnoonan: Dunno. `strip` is a black box to me, and I haven't been passing it any special arguments as far as I know, unless Fedora chooses some unusual defaults or something.
12:07:27 <dminuoso> :t maximum
12:07:29 <lambdabot> (Ord a, Foldable t) => t a -> a
12:07:36 <crestfallen> but I'm not clear about Num a => a having infinite possibilities
12:07:55 <dminuoso> :t GHC.OldList.maximum
12:07:56 <lambdabot> Ord a => [a] -> a
12:08:01 <geekosaur> Num is something *we* attach meaning to. ghc has no clue about such
12:08:11 <geekosaur> it's not like it has a built-in notion of "number"
12:08:17 <dminuoso> crestfallen: Consider this now. The consumer of maximum can still pick `a` but you no longer have the complete freedom of any type.
12:08:31 <dminuoso> That is, your choice for a has been limited to any type that has an instance Ord.
12:09:09 <crestfallen> copy that but not what geekosaur posted :/
12:09:20 <geekosaur> [29 19:07:14] <crestfallen> but I'm not clear about Num a => a having infinite possibilities
12:09:30 <mnoonan> dmwit: ah, I see. afaik it can only remove symbols and debug info, but I also know those can be surprisingly large.
12:09:38 <crestfallen> sorry did I misquote member there?
12:09:42 <geekosaur> ghc doesn't get to say "there's a specific idea that pins this down". it has to assume anything could potentially be "a"
12:09:48 <fishythefish> crestfallen: what do you think the possibilities for Num a => a are?
12:10:35 <crestfallen> in terms of types, not actual numbers like 6776 right?
12:10:46 <fishythefish> tbh, I don't know, it's your terminology
12:10:50 <fishythefish> I'm trying to figure that out
12:11:44 <crestfallen> ghc sees the (+) operator and I thought there would only be a handful of possible types, like < 10
12:11:56 <fishythefish> no, the type could be anything which has a Num instance
12:11:59 <dminuoso> crestfallen: In order to do type unification well you have to juggle a few concepts. Ideally you need know where universal quantifications exist and when to use fresh type variables. I think you're overreaching your capabilities for now.
12:12:11 <fishythefish> this depends on what modules you have loaded
12:12:29 <geekosaur> crestfallen, (a) open world assumption. Anyone can add a new instance *at any time* including months or years after you compiled the code
12:12:43 <geekosaur> then they link to the library that has that and it has to be able to deal
12:12:47 <fishythefish> ghc doesn't see the (+) operator as special and recognize a special list of types
12:13:06 <crestfallen> weird I was completely on the wrong track
12:13:14 <geekosaur> (b) ghc still cannot know that "Num a" means something special. it means something to *people*. it's exactly the same as "Flublyxk a => a" to ghc
12:13:28 * dminuoso names his next typeclass Flublyxk
12:13:38 <exarkun> pls no
12:14:14 <dmwit> I write `instance Num a => Num (ZipList a)`. Now there are infinitely many `Num` instances.
12:14:22 <crestfallen> well, the book certainly hasn't covered this.
12:14:29 <dminuoso> exarkun: It cant be worse than zonking
12:14:42 <mnoonan> crestfallen, what book are you using?
12:14:52 <dmwit> At least zonking has a whopping long comment explaining what it is and why it's needed.
12:14:57 <fishythefish> I'm kinda skeptical that the book you're following has you doing type unification by hand
12:15:25 <crestfallen> hutton 2nd edition. I'm sure its a great book, it's very sparse though, and the examples are huge
12:16:06 <crestfallen> its just something I thought I was getting. A guy has to have a angle :)
12:16:08 <dminuoso> And yet you pinch solutions to your examples...
12:16:18 <mnoonan> fishythefish: as long as there are folks writing "zipWith id" out there, it might not hurt to do some hand-unifying :)
12:16:22 <dminuoso> The whole discussion is a bit confusing.
12:16:34 <crestfallen> wtf should I do then
12:16:52 <dminuoso> Solve excercises perhaps?
12:17:10 <fishythefish> mnoonan: certainly, I'm just commenting that progressing up to point X in book Y doesn't say anything about whether you're ready to grok type unification
12:17:33 <mnoonan> fair point
12:17:37 <crestfallen> word
12:17:47 <mnoonan> crestfallen: so typeclasses are covered in ch 3 according to the toc
12:17:47 <crestfallen> its way more complicated than I thought
12:18:01 <fishythefish> fwiw, this isn't the first conversation we've had with crestfallen about type unification and each time the fundamentals seem to be lacking
12:18:05 <mnoonan> you're going to keep having a bad time if you don't put in labor on the fundamentals
12:18:06 <fishythefish> so I agree with dminuoso here
12:18:06 <dminuoso> crestfallen: Its not that complicated, but I think you are just lacking too much foundation for now.
12:18:45 <crestfallen> << aka crucify_me
12:19:25 <crestfallen> one moment pls
12:21:17 <geekosaur> the problem with "lacking too much foundation" is they've been doing this for some 3 years now
12:21:35 <geekosaur> some aspect of the foundation isn't making it through
12:22:01 <fishythefish>  /shrug in many cases, floundering for 3 years won't get you as far as following a more rigorous process for 3 months
12:22:50 <crestfallen> 3 years ?
12:23:46 <mnoonan> seriously! trying a faulty method of learning isn't just a slower version of following a good method of learning.
12:24:04 <maerwald> learning is great!
12:24:19 <maerwald> you just have to forget about *teaching*
12:24:57 <crestfallen> :t map map
12:24:59 <lambdabot> [a -> b] -> [[a] -> [b]]
12:25:51 <crestfallen> geekosaur, why do you say 3 years ..
12:26:31 <geekosaur> 2018 May 22 03:02:12 <glguy>	Well, we're just about to start year 3 of n_blownapart/crucify_me/crestfallen trying to learn Haskell. They do say that third time is a charm
12:26:57 <geekosaur> it's kinda noticeable when the same person's basically going over the eexact same things for this long
12:27:30 <geekosaur> at least if you keep an eye on channel activity
12:27:39 <crestfallen> no I started before I left for colombia in June 2017. to be fair I had a poor outcome with trying to learn scheme though
12:28:36 <__monty__> I have a type: [I] -> I -> (I -> Maybe a) -> Maybe a that doesn't typecheck without the Maybe's anything obviously wrong with my thinking it should?
12:28:37 <crestfallen> ..before that
12:29:00 <dminuoso> __monty__: Have to see the implementation.
12:29:32 <crestfallen> so I won't use this channel any longer. what a drag
12:30:18 <mnoonan> a better idea is to not take it personally, but listen when people are telling you why what you are doing is not going to go well for you.
12:30:57 <noan> [exa], yes, finite. dminuoso the function each time its result is needed would fully evaluate. Whereas a full data structure once needed would evaluate that structure only once.
12:31:07 <noan> if I understand right
12:31:47 <Tehnix3> Anyone have experience with building a project with stack inside a docker container, and "saving" the progress of the builds, without having to commit the container?
12:32:18 <Tehnix3> some combination of --work-dir and maybe --stack-root, but not sure what is necessary
12:32:23 <dminuoso> Tehnix3: That happens by default already
12:32:34 <dminuoso> Tehnix3: Docker stores each intermediate layer
12:32:48 <Tehnix3> Ah, i mean from a docker run
12:33:36 <Tehnix3> e.g. `docker run -v $(pwd):/src -it ghcjs:lts-9.21 stack build`
12:33:58 <dminuoso> noan: Im guessing the mapping of values is not known at compile time but decided at some point during runtime?
12:35:54 <crestfallen> mnoonan, how would a person not take that personally. "listening" on an irc channel is not the same as how one is raised to listen.
12:36:39 <fishythefish> crestfallen: we're not saying Haskell isn't for you, just that the way you seem to be going about learning it doesn't seem to be that effective
12:36:52 <__monty__> dminuoso: http://ix.io/1bKD
12:37:19 <fishythefish> __monty__: what would a version without the Maybes do?
12:37:27 <crestfallen> << see moniker
12:38:14 <mnoonan> You have to separate your actions from your identity. You're doing the wrong thing, and people are trying to help you succeed. That's not a judgment against you as a person.
12:38:16 <__monty__> fishythefish: Exact same function. Just a type variable that represents "Maybe something" instead of Maybe a type variable that represents "something".
12:38:45 <fishythefish> __monty__: can't be the exact same function; you're pattern matching on the Maybe constructors and producing Maybe values
12:38:56 <dminuoso> __monty__: If case (mb_parent x) produces Nothing, what should the whole thing do?
12:39:36 <__monty__> Ah, type variables don't abstract over levels?
12:39:46 <fishythefish> what do you mean by "levels"?
12:39:55 <dmwit> __monty__: I don't understand the question. In particular I don't understand what it would mean to typecheck a type (or at least, I can't connect what I would think it meant to what you said).
12:40:01 <dminuoso> 21:37     __monty__ | fishythefish: Exact same function. Just a type variable that represents "Maybe something" instead of Maybe a type variable that represents "something".
12:40:05 <dminuoso> I cant make sense of that statement
12:40:27 <dmwit> Typechecking happens on computations.
12:40:31 <dmwit> (Kind checking happens on types.)
12:40:47 <__monty__> dmwit: I meant typechecking the function.
12:40:50 <fishythefish> __monty__: if you want a type that represents the possibilities of Maybe Int, Maybe Char, Maybe Bool, etc. then you want Maybe a
12:41:12 <crestfallen> mnoonan, thanks I really appreciate that. also fishythefish has helped me with a saint's patience and I appreciate it. At least I'm getting familiar with some of it.
12:41:40 <__monty__> At it's simplest my question is why can't `forall a. a` equal `forall b. Maybe b`?
12:41:56 <fishythefish> __monty__: because I could pick an a that isn't a Maybe b
12:41:58 <dminuoso> __monty__: Because that's not the same thing?
12:42:12 <dminuoso> __monty__: polymorphism means _the consumer_ gets to decide.
12:42:35 <fishythefish> forall a. a is only inhabited by _|_, but Nothing inhabits forall b. Maybe b
12:42:38 <__monty__> Ah, right. /duh
12:43:33 <fishythefish> crestfallen: my advice is to set aside the type unification and other advanced topics until you have a strong enough grasp of the foundations to really understand our discussions about them
12:43:42 <dminuoso> __monty__: I think what you were hoping for is a typed hole _
12:43:57 <dminuoso> __monty__: Which is the equivalent of "something goes in here, but I dont want to name it - you figure it out with type inference"
12:43:58 <fishythefish> hutton's book is a good one to follow, but rather than trying to get through it as quickly as possible, do all of the exercises yourself and don't look at others' solutions
12:44:13 <__monty__> Thanks. Time to stop I guess when you start making such silly mistakes. I was using the knowledge that all the functions passed would return a Maybe but that's not true in the general (polymorphic) case.
12:44:15 <dminuoso> __monty__: (but I dont know whether thats truly useful for you)
12:45:08 <__monty__> dminuoso: Not in this case but I'm sure it'll come in handy.
12:47:43 <dminuoso> __monty__: Kind of curious what your thought process was though. Why do you think `forall a. a` would work?
12:48:51 <__monty__> dminuoso: I was assuming the fact that I'm only ever gonna pass functions that return a Maybe. The type checker can't know that though.
12:50:27 <fishythefish> __monty__: the type system is a very good place to document that fact :)
12:50:34 <fishythefish> the real question is why you want `forall a. a` :P
12:51:54 <__monty__> Less typing : )
12:52:12 <dminuoso> __monty__: Like I said, typed holes ;)
12:52:19 <dminuoso> (If that was your goal)
12:52:57 <__monty__> dminuoso: Aren't typed holes to find out what type you should write somewhere? Hmm, researching.
12:53:00 <dminuoso> Though I kind of like having explicit type signatures. It makes contracts more visible and reduces chances of type inference going wrong.
12:55:51 <__monty__> Yeah, as I thought. In this case I knew I should write Maybe a but for some reason I wanted to get away with `a`.
12:56:17 <mnoonan> __monty__: a hole where a value should go won't compile, and ghc will tell you what type you need there. a hole where a *type* should go will tell you what type is needed but still can compile.
12:57:16 <__monty__> Oh, mnoonan, thanks. Doesn't seem documented here: https://wiki.haskell.org/GHC/Typed_holes
12:57:19 <Eduard_Munteanu> Well, not if the type is obnoxious and redundant. Sometimes types contain useful bits and less useful bits.
12:57:29 <dminuoso> __monty__: Now that in that type signature the presence of a type variable (starts with lowercase letter) implies universal quantification.
12:58:03 <mnoonan> __monty__: maybe it has another name, I'm not sure. All I know is it was recently very handy to me when I needed to write a long type to disambiguate something, and I could stub most of it out with a _ :)
12:58:21 <dminuoso> __monty__: That is when you have some `a` in that type signature, then there's an implied `forall a.` - which can be read as "for every possible choice of a"
12:58:45 <mnoonan> ah, PartialTypeSignatures
12:59:27 <Eduard_Munteanu> For example in xmonad you might want to say something is a layout, but not spell the entire thing out.
12:59:43 <dminuoso> It kind of goes into "Proxy pattern" and TypeApplications area
13:00:55 <Tehnix> __monty__: (jumping into it a bit here, so please disregard if I've misunderstood the question) a way to think about it is that is that the more general/polymorphic the type is, the less things you can actually do on it. For example, there's only one implementation of `id :: a -&gt; a`. Try to think about it. If you tried to do `+`, since you can't do that on *every* type, you would then need to restrict it to the type
13:00:56 <Tehnix> that at least implements the typeclass Num. In the same vein, `forall a. a` is *more* strict in the operations available than `forall a. Maybe a`, because with the latter you can at least do some unpacking of `Maybe` etc.
13:01:12 * hackage hakyll 4.12.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.12.3.0 (JasperVanDerJeugt)
13:01:38 <Eduard_Munteanu> Did you just use HTML entity syntax inside quotes? :))
13:02:13 <Lears> Only madmen give their layouts type signatures.
13:02:41 <Tehnix> Me? going through a bridge, no idea if my backticks added some additional stuff :open_mouth:
13:02:51 <Lears> Unfortunately I do suffer from madness and that type signature is 6 lines long.
13:03:15 <Tehnix> wait, jesus, what the hell did my message look like? .-.
13:03:16 <dminuoso> Named type applications would be cool!
13:03:25 <Eduard_Munteanu> Tehnix, it replaced '>' with ampersand plus gt.
13:03:36 <geekosaur> some clients do that
13:03:40 <__monty__> Lears: 6 lines wrapped or just spread over 6 lines?
13:03:49 <Eduard_Munteanu> Oh, ok, thought it was intentional or something. :)
13:03:50 <Tehnix> haha, lol, weird
13:04:23 <mnoonan> oh, I heard you like types!
13:04:24 <mnoonan> replicate :: (Integer ~~ n) -> (a ~~ x) -> ([a] ~~ Replicate n x  ::: (IsZero n --> Replicate n x == Nil) && (IsSucc n --> Replicate n x == Cons x (Replicate (Pred n) x)))
13:04:24 <geekosaur> especially web clients are prone to 'auto-escape' when something's already dealing on theother side, so in effect it gets double encoded but singly decoded
13:04:33 <Eduard_Munteanu> dminuoso, what do you mean?
13:04:49 <geekosaur> __monty__, spread over 6 lines, but … complex xmonad layouts do tend to get rather large types
13:04:58 <geekosaur> because layouts are more or less type functions
13:05:10 <geekosaur> encoded as constructors
13:05:13 <Lears> I don't allow wrapping, __monty__.
13:05:16 <Eduard_Munteanu> Layout _ or whatever should be fine. :)
13:05:19 <dminuoso> Eduard_Munteanu: Lets say you have some `forall s t a b x y. ....` and you just want to specify `x` in some case.
13:06:07 <Eduard_Munteanu> Hm.
13:06:09 <dminuoso> But I guess ultimately we have the same problem in function application too. That is if I really want to only apply the 5th argument, Im going to have to (.) . (.) ... my balls out
13:06:28 <Eduard_Munteanu> Agda has that for implicit arguments.
13:06:43 <__monty__> Lears: Nightmares about burritos? I feel ya ; ) I was more getting at is it a 6 line paragraph signature or is it six lines because you chose to break after each argument?
13:07:00 <Eduard_Munteanu> e.g. f {x = 3} 0 1
13:07:01 <cantor> Is there a term for a type that is both a Sum type and a Product type? e.g. data MyType = A Int Int
13:07:05 <cantor> oops
13:07:23 <cantor> e.g. data MyType = A Int Int | B Bool Bool
13:07:30 <dminuoso> cantor: Thats a sum of product types?
13:07:57 <mnoonan> Eduard_Munteanu: it looks like PartialTypeSignatures was specifically influenced by Agda there
13:07:58 <cantor> dminuoso: Yeah, I was just wondering whether there's a "special" term
13:07:58 <__monty__> ADT?
13:08:48 <cantor> __monty__: Well, ADT refers to either/or/and, I was wondering whether there was a term for this special case
13:08:50 <dminuoso> cantor: Well foremost its just a sum type I guess?
13:09:53 <cantor> Yeah, I was referring to it as a Sum-of-Product types before, but just wondering
13:10:32 <Lears> Right __monty__, I figured that's what you meant. The line breaks are more focused on producing a readable layout than on cramming as much in as possible, but most lines are still meaty.
13:11:43 <cantor> Thanks folks, see you in infinitesimal heaven
13:17:56 <noan> dminuoso, correct, it's determined at runtime, but in a way that results in a total function. Currently the value I provide later to my render function is a function basically like TileId -> Image, rather than say, Map TileId Image
13:18:55 <dminuoso> noan: You could memoize it
13:19:17 <dminuoso> noan: Note that in a very cool sense a function can be thought of as a container. =)
13:19:39 <dminuoso> Someone wise once taught me that.
13:19:55 <noan> dminuoso, I thought I couldn't memoise such a function?
13:20:10 <dminuoso> noan: Why couldnt you?
13:20:25 <noan> I just thought that's the way the evaluation semantics of haskell work with respect to thunks and such
13:20:30 <__monty__> dminuoso: Conor McBride?
13:20:43 <noan> Infact, I use the function pricecely as if it were a well-defined Map
13:20:48 <noan> a box if you will
13:21:01 <noan> the only reason I'd move away from that model would be performance
13:22:03 <mnoonan> noan: I missed the start of this, so apologies if it is off base. but I wrote this library that might be relevant: https://hackage.haskell.org/package/justified-containers
13:22:23 <noan> https://github.com/AlexaDeWit/runlike/blob/master/src/Types/Tileset.hs#L55
13:23:17 <noan> basically this is what I am doing, and using that last bit, the a -> Form e to create the backgroundTile and foregroundTile functions here... https://github.com/AlexaDeWit/runlike/blob/master/src/View.hs#L18
13:27:15 <dminuoso> noan: You can memoize functions. In a way this is guaranteed by purity.
13:28:30 <tijko> Hi I have some legacy haskell code that needs ghc 6-12.3 but I'm getting ghc-pkg not found error on install
13:28:50 <noan> dminuoso, okay, but.. how. Would you know where I could learn about memoisation in haskell?
13:28:53 <tijko> I checked the path and the bin is there, a google search isn't showing much
13:29:36 <noan> I'm used to memoisation requiring essentially a mutable external scope to manipulate
13:29:37 <glguy> noan: Memoization isn't something you can "turn on" for functions. You'd have to implement it using the solution you're asking questions about now
13:30:11 <noan> glguy, Obviously, but to accomplish it I need to understand the language semantics better to understand when things will be stored and when not
13:31:11 <glguy> noan: You do the kinds of things you're already asking about. Store the results in a Map, or an Array, or some other structure like that
13:31:24 <glguy> and then your function indexes into that
13:36:29 <dminuoso> noan: The thing to keep in mind is that GHCs execution model is call-by-need which by default memoizes values.
13:39:01 <noan> ty
13:40:12 <Eduard_Munteanu> Call-by-need, memoize indeed / Call-by-need is better / ...
13:41:08 <reactormonk> Is there a way I can return two types from a type family?
13:42:24 <Eduard_Munteanu> reactormonk, you can return a pair of types
13:42:30 <geekosaur> Either or equivalent. caller always decides the result type, you do not get to say 'it will be something from this family' and then choose for yourself
13:42:43 <reactormonk> Eduard_Munteanu, like a good old tuple? Or does it need to be a '(,) ?
13:42:46 <geekosaur> or if you mean both at the same time, tuple or etc.
13:42:57 <geekosaur> but perhaps you should give more detail
13:43:23 <Eduard_Munteanu> reactormonk, yeah, though you should probably use '(,) if it's not meant to be inhabited.
13:43:59 <Eduard_Munteanu> It also allows you to specify the kind properly.
13:45:03 <Eduard_Munteanu> e.g. type family Dup (a :: k) :: (k, k)
13:49:58 <bodisiw> i'm missing something dumb about type classes i think... can anyone explain this type error? https://lpaste.net/972051317851684864
13:50:35 <dminuoso> QC question: If Im writing a property and I need a random value - how do I obtain it? Should I just specify it as an argument to my `prop_ ...` or is there some monad I can describe my property in?
13:51:40 <geekosaur> bodisiw, I think we also need to see px2height? that said, PixelRGB8 in px2int is a *data* constructor, not a *type*; but in the error, it's a type
13:51:48 <geekosaur> types and data constructors are distinct
13:52:21 <geekosaur> data Maybe a = Nothing | Just a -- Maybe is a type constructor, Nothing and Just are data constructors. Nothing is not a type, nor is Just.
13:52:21 <bodisiw> sry, i changed the name to px2int for the paste, so the error is just wrong
13:52:56 <geekosaur> so if you have a value whose type is PixelRGB8, it has nothing to do with the data constructor PixelRGB8 that px2int is using
13:53:16 <Eduard_Munteanu> And simply slapping on a Pixel typeclass won't do anything.
13:53:17 <geekosaur> the type of that value is unknown aside from "some 'a' with a Pixel instance"
13:54:07 <bodisiw> geekosaur, right -- but its defined as `data PixelRGB8 = PixelRGB8 !Pixel8 !Pixel8 !Pixel8 ...`, which i thought made the constructor as well
13:54:21 <geekosaur> it does, but they're still distinct
13:54:33 <bodisiw> and there is also a `instance Pixel PixelRGB8 where...`
13:54:53 <Gurkenglas> http://hackage.haskell.org/package/QIO-1.3/docs/QIO-QioSyn.html#v:cond allows construction of non-unitaries :
13:54:55 <Gurkenglas> *:S
13:54:59 <Eduard_Munteanu> bodisiw, someone else could add a different instance at any time.
13:55:03 <geekosaur> so, you are matching the constructor which gives you a specific type. but your signature says *any* type that has a Pixel instance, not PixelRGVB8 specifically
13:55:23 <geekosaur> and when your signature says that, it is actually saying the caller chooses the type. you don't get to choose it in your implementation
13:56:08 <geekosaur> you don;t get to switch types on the fly, either; if you said 'Pixel a => .. a ..' then it's going to be the same 'a' everywhere, not PixelRGB8 in one place and PixelRGBA8 somewhere else in the same function
13:56:10 <bodisiw> geekosaur, hmm, so the error i would expect would be that i'm missing matches for other instances
13:56:14 <geekosaur> no
13:56:26 <geekosaur> more instances won't help
13:56:31 <bodisiw> ahhh i got it
13:56:37 <bodisiw> i think that makes more sense
13:56:59 <[exa]> noan: you can rely on the fact that a let-binding (including toplevel) is evaluated only once, therefore if you somehow manage to let-bind all of your values, you'll have automemoization. In your case I suggest a manual cache using Array of Maybes and/or Map, possibly by IORefs if you want to avoid monads.
13:57:00 <bodisiw> nope, confused again
13:57:06 <geekosaur> 'px2int :: Pixel a => a -> Int' means the caller says what 'a' is and you promise to honor it. As soon as you mention a *speciifc* a, you have violated the contract you declared to the caller
13:57:37 <bodisiw> right, as long as `a` is a Pixel
13:57:53 <Eduard_Munteanu> bodisiw, you might want to have px2int defined in the instance if you expect it to get a PixelRGB8
13:57:54 <geekosaur> yes, but you thne have a case that tries to select a speciifc 'a' to produce
13:57:55 <bodisiw> so i can basically only use the functions defined in the Pixel class?
13:58:19 <geekosaur> you can't do that; 'a' came from the caller, you can only write code that can work with any such 'a', not specific ones
13:58:26 <fishythefish> and the knowledge that `a` has a `Pixel` instance should be sufficient to implement the function; you shouldn't have to introspect the actual type chosen for a given invocation
13:58:37 <glguy> bodisiw: Yes, you can use the methods of the Pixel class with this value
13:59:00 <noan> [exa], why would one wish to avoid monads?
13:59:47 <dminuoso> bodisiw: That's the implication. You dont know anything about the type except that an instance (including its method) must be provided.
14:00:19 <bodisiw> okay, this all makes sense.  i was hoping i could match on the different instances similar to the sum types
14:00:26 <geekosaur> and you can;t find out the type with a pattern match, even if it happens to have the same name
14:00:48 <dminuoso> bodisiw: wonderful things come from the fact that you cant possibly know.
14:00:51 <geekosaur> there *are* ways to do that, but they come with their own limitations and costs
14:01:00 <dminuoso> bodisiw: You get a wealth of free theorems.. =)
14:01:20 <bodisiw> dminuoso, i'm a newb still, but i've seen enough to grok that part ... when i know what i'm doing, it's very elegant!
14:02:46 <reactormonk> Uhm, how do I extract stuff out of tuples on typelevel?
14:03:00 <glguy> With more type families
14:03:25 <dminuoso> bodisiw: The idea is that since polymorphism prevents you from knowing something about a type (or just very little in presence of typeclass constraints), you can definitely judge what a function cant do.
14:03:44 <dminuoso> bodisiw: The most trivial example is, consider a function `f :: a -> a` - what can it possibly do? How many ways can you think of implementing this?
14:03:52 <reactormonk> glguy, you make it sound like "if type families don't solve your problem, you're not using enough"
14:04:41 <bodisiw> dminuoso, right i get the static analysis vs dynamic dispatch part of this
14:05:08 <Eduard_Munteanu> reactormonk, type family Fst (pair :: (k, l)) :: k
14:05:08 <bodisiw> (er, i mean eschewing runtime polymorphism)
14:08:31 <Eduard_Munteanu> Probably best as a closed type family.
14:21:03 <infty> ?src ($)
14:21:03 <lambdabot> f $ x = f x
14:21:45 <Myrl-saki> Is there any way to warn about unused constraints?
14:22:15 <phadej> -Wunused-constraints
14:22:22 <glguy> -Wredundant-constraints
14:22:32 <phadej> I remembered wrong :(
14:22:38 <glguy> ghc --show-options | fgrep constraint
14:22:57 <phadej> !, good one
14:23:03 <Myrl-saki> Thanks!
14:25:08 <Myrl-saki> Does -Wredundant-constraints also work for constraint synonyms?
14:25:38 <Myrl-saki> Tried and see, and I don't think so.
14:25:41 <Myrl-saki> Tried and saw*
14:27:22 <dyl> ghc --show-options is absurdly long.
14:27:40 <dyl> "-fvectorisation-avoidance" ← why?
14:28:18 <glguy> dyl: Look in the users guide to see what they wrote about it
14:28:36 <dyl> I love how google kept "-" but removed "+".
14:29:05 <dyl> "Always enabled by default." Huh
14:29:56 <dyl> Ah I see, it allows the optimizer to try to determine if vectorization would be bad and if so not vectorize.
14:30:14 <Average-user> Does someone knows how could I generate all trees of n nodes? And I don't mean binary trees, but rose trees
14:30:22 <dyl> It's not "don't vectorize" but rather "be a bit smarter".
14:30:49 <dyl> Average-user Sounds like induction to me.
14:31:22 <glguy> Average-user: What have you tried so far?
14:31:22 <dyl> What order do you want to generate them in?
14:32:15 <Average-user> glguy: I've only made some research
14:32:27 <dyl> Also, I assume the contents of the nodes doesn't matter?
14:32:34 <Average-user> Trying to find some algorithms
14:32:38 <dyl> Your leaves are always [], specifically.
14:32:42 <Average-user> dyl: The content does not matter right
14:32:52 <dyl> You should try to think of this inductively. Your base case is [], right?
14:32:54 <glguy> You could make the type: generate :: [a] -> [Tree a]
14:33:06 <glguy> and then instead of a number you provide the values to store in the nodes
14:33:22 <dyl> The value seems irrelevant, it could just be unit to start with.
14:33:30 <dyl> [] being the smallest tree, [()] next...
14:33:46 <glguy> Yeah, if the value was irrelevant you'd use [()]
14:33:54 <dyl> But the question is how do you want to induct, by breadth or by depth? Because you can always produce a new tree by adding another () to the top level list.
14:33:58 <Average-user> https://www.oeis.org/a000055
14:34:02 <dyl> [] -> [()] ->[(), ()] -> ...
14:34:09 <dyl> But that's not very interesting.
14:34:19 <dyl> Likewise, neither is:
14:34:24 <Average-user> There are values found for the amount of trees of n nodes
14:34:24 <dyl> [] -> [[]] -> [[[]]]
14:35:00 <lyxia> Average-user: there's a pretty simple solution using the "size-based" package
14:35:32 <Average-user> lyxia: Don't know about that. I'll see what I can find
14:36:03 <Average-user> lyxia: Can you send a link or something?
14:36:21 <lyxia> @hackage size-based
14:36:21 <lambdabot> http://hackage.haskell.org/package/size-based
14:38:05 <mitchellsalad__> Is there a Dhall IRC channel?
14:39:35 <glguy> Average-user: How about: https://gist.github.com/glguy/ff1ed5c445b7e4b7e0c62768be4355e0
14:40:32 <Average-user> glguy: That was fast. It might take me a while to understand it. I'll come back to you then
14:42:09 <mitchellsalad__> Dhall question: what's the syntax for accessing a field of a record stored in a file?
14:43:32 <Average-user> glguy: But that generates extra trees, that are isomorphic between them selfs If we don't care about the content
14:44:04 <glguy> OK, then modify it to eliminate the equivalence class you have in mind
14:47:09 * hackage binary-ext 2.0 - An alternate with strong-typed errors for `Data.Binary.Get` monad from `binary` package.  http://hackage.haskell.org/package/binary-ext-2.0 (warlock)
14:49:06 * hackage fsnotify 0.3.0.1 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.3.0.1 (thomasjm)
14:51:28 <dyl> glguy neat, hadn't thought about a StateT approach.
14:52:15 <Average-user> glguy: The problem is that I might want to generate a large amount of trees, and I think it would  probably be better to eliminate isomorphism after generating all the trees
14:52:28 <dyl> One thing I still wonder about is the *order* in which trees are generated.
14:52:59 <glguy> Average-user: The generated trees are all distinct from each other in my code, even ignoring the labels
14:53:06 <dyl> e.g. if you're using this for testing/fuzzing purposes, the approach might be different than otherwise.
14:53:11 <glguy> so whatever isomorphism you have in mind you'll have to be more specific
14:54:36 <Average-user> glguy: Like the integer sequence I send. If you define the root (Node _ [Node _ [Node _]]) == (Node [Node _, Node _])
14:55:15 <Average-user> forget the part of "define the root" I thought of writing something  and then I didn't
14:56:02 <Average-user> Two Trees Are isomorphic if you can root rotate and reflect them to bee exactly the same
14:56:34 <dyl> So, in other words if you consider data Tree a = Node a SET (Tree a)
14:56:41 <dyl> You don't care about ordering of the subtrees.
14:56:42 <glguy> You're trying to say you want undirected trees
14:56:47 <dyl> Or that.
14:57:36 <hexfive> is it considered bad practise to generalize functions like `f :: Int -> Maybe SomeType` to `g :: (Alternative f) => Int -> f SomeType`?
14:57:37 <Average-user> https://duckduckgo.com/?q=+Number+of+trees+with+n+unlabeled+nodes.+&t=canonical&iax=images&ia=images&iai=http%3A%2F%2Foeis.org%2FA000055%2Fa000055.gif
14:57:59 <dyl> hexfive depends on if you need that generalization.
14:58:14 <dyl> Generally, if you're writing a library be general, if you're writing an application be specific.
14:58:14 <glguy> hexfive: You lose information when you do that
14:58:29 <hexfive> ah, right
14:58:31 <glguy> hexfive: I'd consider that example in particular to be a bad practice
14:58:36 <dyl> Make it as simple as possible, but not simpler.
14:58:51 <dyl> But yeah, in that case I don't think it's a good idea.
14:58:55 <hexfive> kk thanks, that makes sense
14:58:58 <Average-user> dyl: Thanks Einstein (If I'm not mistaken)
14:59:01 <dyl> Yes, haha.
14:59:10 <dyl> Except he never said that I believe.
14:59:31 <dyl> – Abraham Lincoln
15:00:00 <dyl> hexfive another way to look at it is that you should consider what it is about the type or constraint you're actually using.
15:00:36 <hexfive> in my specific case, i don't really care that something is wrapped in a maybe specifically
15:00:54 <hexfive> using the alternative makes for less unwrapping/rewrapping
15:00:59 <dyl> It might be helpful to give a more complete example to give an idea.
15:01:18 <dyl> It's hard to say if it's a good idea or not *just* from the type signature, as we don't know what properties of the types involved you're using.
15:01:31 <dyl> In general though, you can always generalize *when you need to*.
15:01:46 <dyl> Overgeneralizing can rapidly make things pretty messy.
15:01:51 <hexfive> hmm
15:02:15 <dyl> You may not care if it's in a Maybe specifically, but will you ever feed it anything else?
15:02:25 <hexfive> occasionally
15:02:36 <dyl> Then it seems reasonable to generalize it.
15:02:36 <hexfive> might be in a transformer stack w/ io and an alt instance
15:02:41 <dyl> But only so much as you plan to actually use it.
15:02:47 <dyl> This is why it makes sense to generalize in public library API: you can't predict every case of how a user will use your library.
15:02:52 <dyl> It's just a restatement of the robustness principle.
15:03:01 <dyl> Be liberal in what you accept and conservative in what you emit.
15:03:20 <hexfive> But to me, this kind of feels the opposite of that
15:03:21 <dyl> The type signature is in a sense a contract. You're telling the user "this is what you need to satisfy for this to work".
15:03:25 <glguy> hexfive: "generalizing" it means that the user of this function won't be able to rely on it only providing 0 or 1 results any more
15:03:41 <hexfive> in that we are exact in what is expected, but might emit different things depending on the inferred type
15:03:44 <dyl> They will only be able to rely on it producing something that is Alternative.
15:03:54 <__monty__> dyl: Unless you want security ; )
15:04:14 <dyl> The reason it feels different hexfive, is probably because what I said applies to parameters.
15:04:18 <dyl> Return values are another story.
15:04:28 <dyl> A generalized return value indicates you're not willing to be specific about what you return.
15:04:37 <dyl> You could return a Maybe under both signatures, but the caller gets less information.
15:04:51 <dyl> So, a better policy might be: widen parameters but narrow return types.
15:04:58 <dyl> (which is robustness)
15:05:27 <hexfive> is there some magic function that will lift a maybe to an arbitrary # of its instances?
15:05:33 <dyl> What do you mean?
15:06:00 <dyl> (btw)
15:06:01 <dyl> (compare:)
15:06:03 <dyl> (`f :: Int -> Maybe SomeType` to `g :: (Alternative f) => Int -> f SomeType`)
15:06:16 <dyl> (`f :: Maybe Int -> SomeType` to `g :: (Alternative f) => f Int -> SomeType`)
15:06:17 <hexfive> Actually, not sure about my last q
15:06:21 <dyl> See how those feel different?
15:06:34 <dyl> (beyond being totally different, see how the generalization affects the contract differently?)
15:06:49 <dyl> The former is probably bad, the latter is probably good.
15:07:25 <hexfive> wouldn't the second be impossible without a typeclass or similar?
15:07:31 <hexfive> like Monad
15:07:46 <dyl> We're assuming SomeType is a concrete type in scope.
15:08:00 <dyl> And what do you mean, there's an Alternative f constraint right there :p.
15:08:03 <hexfive> but how to get to SomeType from (f SomeType)
15:08:08 <dyl> We don't?
15:08:16 <dyl> I should have named the second pair f2 and g2 or something.
15:08:22 <hexfive> sry, Int
15:08:39 <dyl> Depends on what SomeType is.
15:08:43 <hexfive> unbinding the Int needs information about the underlying concrete type, no?
15:08:44 <dyl> We're just ignoring that here.
15:09:14 <dyl> Perhaps type SomeType = Maybe () ¯\_(ツ)_/¯
15:09:15 <dyl> Who knows.
15:09:35 <dyl> I don't know if there's any useful witnesses to those types.
15:09:47 <dyl> My point is that there's a difference in widening/narrowing parameter and return types.
15:09:55 <dminuoso> If I need some 5 pieces of arbitrary data (that are somehow correlated) inside a Property, would I cook them up into a (,,,,), and then have some prop_Foo :: (A,B,C,D,E) -> Property?
15:10:05 <dminuoso> Or are there ways to get arbitrary data from inside a Property?
15:10:34 <hexfive> I see. kinda. thanks dyl
15:10:42 <dyl> I need to cook up a more useful example.
15:11:02 <dyl> The point is that the behavior of generalizing or quantifying over a position depends on where it is.
15:11:15 <lyxia> dminuoso: A -> B -> C -> D -> E -> Property   also works
15:11:20 <dyl> Widening a parameter type says "I (the function) need less information"
15:11:26 <dyl> Widening the return type says "you get less information".
15:11:59 <dyl> You would widen the return type when you don't want to be specific about what type you're actually returning. But this usually ends up being a path to the existential typeclass antipattern.
15:12:33 <dyl> what concrete type*
15:12:45 <dminuoso> lyxia: Ah that wont work because the data are related. So I'd just have some `f :: Gen (A,B,C,D,E)` and then specify my property with `forAll f \(a,b,c,d,e) -> ...` ?
15:12:45 <dyl> So yeah, like glguy said, generalizing a return type is *usually* bad.
15:13:23 <dyl> You will pretty much never see a type (SomeClass f) ⇒ a -> f b
15:14:00 <hexfive> It seems like a very useful thing though
15:14:06 <dyl> What?
15:14:24 <hexfive> not disputing the anti-pattern aspect :p
15:14:40 <lyxia> dminuoso: yes
15:15:19 <dminuoso> lyxia: Alright. Thank you very much.
15:15:23 <dyl> hexfive It's just that when you have such a broad return type but narrow parameter...
15:15:29 <hexfive> dyl: because if it's known that the only needed property of the result action is 'optionality', it can slot in anywhere that's present
15:15:33 <dyl> How many interesting functions could possibly exist?
15:15:42 <lyxia> dminuoso: you might also nest forAlls  forAll getA $ \a -> forAll (getB a) $ \b -> forAll (getC a b) $ \c -> ...
15:15:48 <dyl> hexfive But that's the ETC antipattern :).
15:15:59 <dyl> If the only result needed is "optionality", return a Maybe!
15:16:12 <dyl> You can't *recover* the information about what type it actually was.
15:16:27 <dyl> (Unless you're using dynamism or reflection or something like that.)
15:16:43 <hexfive> right, but then embedding it in another thing takes more effort
15:17:17 <dyl> Not really.
15:17:29 * hexfive goes to read about etc antipattern because doesnt know what is talking about
15:17:31 <dyl> Embed it in the type that expresses the simplest (but not simpler than that!) set of possible results.
15:18:00 <hexfive> isn't (Alternative f) => f a, simpler than Maybe a?
15:18:05 <Average-user> About the trees thing. This looks good, if anyone else is interested https://www.cs.auckland.ac.nz/courses/compsci720s1c/lectures/mjd/treenotes.pdf
15:18:09 <hexfive> it doesn't encompass all of its properties
15:18:28 <dyl> "simpler" perhaps isn't the right word.
15:18:29 <hexfive> and if the only required property is optionality
15:18:37 <hexfive> ???
15:18:45 <dyl> (Alternative f) => f a tells you less about what f a is, and less about what you can do with it.
15:18:52 <hexfive> yeah
15:18:58 <dminuoso> lyxia: Ah that's basically what I was looking for. Should have been so obvious now that I see it.
15:18:58 <dyl> A "simpler" constraint, means a less simple thing to deal with.
15:19:01 <dminuoso> Thanks again.
15:19:08 <dyl> "All people" is a simpler constraint than "all adults".
15:19:13 <dyl> But it's not *easier* to deal with.
15:19:20 <dyl> Because now we have to consider the possibility of children too.
15:19:30 <dyl> simpler constraint != simpler to work weith
15:19:36 <hexfive> well
15:19:39 <hexfive> wellll
15:19:42 <dyl> A better word is "weaker".
15:19:45 <dyl> A weaker constraint.
15:19:51 <dyl> A concrete type is a very strong constraint.
15:19:51 <hexfive> if your strategy only needs to know theres people
15:20:00 <dyl> (implicitly)
15:20:01 <hexfive> it would indeed be simpler if you knew less about them
15:20:08 <dyl> As an input yes.
15:20:11 <dyl> But not as an output.
15:20:25 <hexfive> hrmm
15:20:48 <dyl> `(Person a) ⇒ a -> b` vs `(Adult a) ⇒ a -> b` (where all Adults are People)
15:20:52 <dyl> vs...
15:21:06 <dyl> `(Person a) ⇒ b -> a` vs `(Adult a) ⇒ b -> a`
15:21:10 <dyl> also let's pretend b is a concrete type.
15:21:14 <dyl> Not quantified. My bad.
15:21:22 <dyl> Like Int or something.
15:21:53 <hexfive> but what does this function do?
15:21:54 <dyl> I have to run and pick up my phone from repairs, but, keep in mind there is a difference in stronger/weaker constraints in covariant and contravariant positions.
15:22:00 <dyl> I don't know!
15:22:02 <hexfive> ok
15:22:06 <dyl> It's abstract. *handwaves*
15:22:09 <phadej> too complicated examples. Produce /anything/: producer :: Input -> Maybe a; consume /Void/: consume :: Void -> Output
15:22:28 <phadej> because, consume :: (forall a. a) -> Output is pita and *different*, than consume :: a -> Output
15:24:55 <phadej> more real-world example pair is: action :: MonadIO m => Input -> m (),  somethingWeird :: IO () -> Output (because `forall m. MonadIO m => m () ~ IO ()`, so better to force the specialisation)
15:25:15 <phadej> and this is why
15:25:17 <phadej> :t to
15:25:18 <lambdabot> (Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
15:25:20 <phadej> :t view
15:25:21 <lambdabot> MonadReader s m => Getting a s a -> m a
15:25:33 <phadej> or actually,
15:25:35 <phadej> :t lens
15:25:36 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
15:25:42 <phadej> :t over
15:25:44 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
15:25:47 <hexfive> idk what any of these things are :o
15:26:11 <phadej> there's same pattern. It might take take to digest.
15:27:42 <phadej> lens stuff or?
15:28:25 <dyl> My examples are complicated but rely on simple premises :p.
15:28:30 <dyl> Yours are simple but rely on complex premises.
15:28:44 <phadej> in short: constructors of optics (to, lens, prism etc) return polymorphic types, because then you can use them in many places
15:29:14 <phadej> but "consumers"/operators (view, over) want something specific, so they take that
15:30:51 <phadej> dyl: I think that when one speaks about "abstract" stuff it's good to keep things abstract (e.g. Void / forall a. a) because you intution won't screw you
15:31:58 <phadej> protip: you can screw up your OO colleagues about whether Square should inherit Rectangle, or other way around
15:32:23 <t7> it inherits Shapable
15:32:36 <phadej> (and the answer is: Consider SquareBuilder and RectanbleBuilder i.e. mutation)
15:32:41 <t7> (but rectangle is more general)
15:32:59 <phadej> well, it depends ;)
15:33:42 <phadej> if you have .setWidth / .setHeight
15:33:43 <t7> FourSidedShapeBuilderFactory
15:34:03 <infinisil> BuilderFactory??
15:34:06 <infinisil> Ew
15:35:09 * hackage axiom 0.4.7 - Web EDSL for running in browsers and server nodes using transient  http://hackage.haskell.org/package/axiom-0.4.7 (AlbertoCorona)
15:35:46 <t7> i saw a brilliant talk on why dependency injection frameworks are awful
15:36:03 <t7> i want to show it to all my colleagues
15:36:31 <dminuoso> t7: dependency injection frameworks are a fancy "my language has no currying functions" solution
15:36:38 <fishythefish> okay, but imagine your talk allowed you to supply the thing you want to complain about...
15:36:41 <dminuoso> Same goes for factory patterns...
15:37:51 <phadej> dminuoso: `reflection` is btw dependency injection solution. we cannot make instances by (partially) applying with data we got on start-up...
15:38:10 <phadej> I heard IOHK abused Given :P
15:40:46 <dyl> t7 when I was using Scala for some work, I discovered that pretty much anywhere DI is useful, Reader is better.
15:40:47 <dminuoso> phadej: well the idea of Reader/partiall applied functions captures the notion of deferring the supplication of some dependency to some other place.
15:40:57 <dyl> Or rather using Reader as a form of DI that is sane.
15:41:21 <dyl> t7 also link :p
15:42:43 <dyl> Even in Scala you can use Reader as "DI-lite" within components when you're dealing with existing codebases which use DI.
15:43:32 <dminuoso> dyl: I tried understanding Angular once - then I saw this: http://acegik.net/blog/media/f973ec46-ece6-432b-a96f-46bd93f738e8/injector_diagram.png
15:43:36 <phadej> you can, but using type-classes is tempting as there's strong guarantee that if I see the instance here, and see the instance there I see the same instance!
15:44:07 * hackage zip-archive 0.3.2.5 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.3.2.5 (JohnMacFarlane)
15:46:45 <t7> dyl, cant find it again!
15:47:02 <dyl> dminuoso run.
15:47:09 <dyl> Angular is.... it's so Google.
15:47:14 <dyl> I don't know how else to put it.
15:47:32 <dyl> Overengineered in a way that makes you feel clever at first, and then depressed.
15:47:45 <phadej> http://okmij.org/ftp/Haskell/tr-15-04.pdf read, its interesting paper
15:47:56 <dminuoso> dyl: Suffice it to say.. React was much simpler. While it has some lots of unnecessary garbage, at its very core it can be thought of a simple pure function Props -> DOM
15:48:04 <t7> when i moved from angular to react at work it was great
15:48:06 <dminuoso> After 15 minutes of reading I understood how React was to be used.
15:50:53 <t7> it was even better once i started splitting components into data and presentation
15:51:11 <t7> so code dealing with changing props was in a single place
15:51:16 <t7> isolated from other stuff
15:52:57 <t7> aka use state as little as possible
15:53:02 <t7> also use typescript
16:20:17 <srk> wohoo, there's some new fancy javascript on hackage but I'm getting gateway timeouts /o\
16:20:37 <srk> is there possibly a templating system that could be used to generate whole haskell project?
16:21:27 * dminuoso sees first line mentioning "javascript", and second line suspiciously looking for a "boilerplate"
16:22:08 <srk> :D
16:22:22 <dminuoso> srk: `cabal init` has you covered though
16:22:36 <dminuoso> stack also brings its own thing should you care for that
16:22:45 <srk> it's actually a boilerplate reduction attempt. I'm trying to generate a whole library
16:22:48 <srk> right
16:23:09 <srk> I can use custom Setup.hs machinery to even generate it ad-hoc
16:23:59 <srk> guess I'll just use some dumb templating that can replace stuff in files
16:25:29 <srk> generating haskell with haskell is fun!
16:47:27 <dcoutts_> relying on implementation-defined de facto standards is great, until it isn't
16:47:29 <dcoutts_> https://blogs.msdn.microsoft.com/devops/2018/05/29/announcing-the-may-2018-git-security-vulnerability/
16:50:01 <hpc> remember, version control is bad
16:50:28 <hpc> i save all of my code in projectname 3 - new (final) copy - copy.zip
16:50:45 <sinetek> security is not everything
16:50:46 <dcoutts_> oh no, I was thinking about the way people reuse complex tools like this in security-sensitive applications
16:50:59 <dcoutts_> like sharing package indexes
16:51:54 <sinetek> i mean people are whining about git using SHA-1 since the stone age
16:52:33 <hpc> really this is why tools should be simple
16:52:54 <hpc> also i question the usefulness of client-side source control hooks
16:52:58 <dcoutts_> I'd note that the only bits of C in the trusted base for the hackage repo syning system is an impl of SHA256 and ed25519, iirc not even zlib.
16:54:48 <hpc> also it's weird that that's published under "devops"
16:54:56 <hpc> apparently every programmer since 2005 is devops now
16:57:10 <monochrom> What is devop? Does it mean someone who has used sudo?
16:57:55 <Hafydd> I tried to use sudo once, but it said "this incident has been reported", so I didn't try that again.
16:58:14 <monochrom> I write code, use sudo, and teach a couple of university courses. I think I can create a new category for myself: profdevop.
16:58:44 <dcoutts_> devprofp
16:59:08 <Hafydd> devprop
17:01:08 <hpc> one time i ran ls -h
17:01:13 <hpc> but there were a bunch of scary words
17:01:27 <hpc> now i just reboot vms instead
17:02:00 <monochrom> I miss VMS. It came with version control for all files.
17:02:25 <monochrom> VMS at school implies you can't tell your prof "my dog ate my homework"
17:02:47 <monochrom> Because it keeps all old versions of your files.
17:03:40 <hpc> http://half-life.wikia.com/wiki/Dog
17:04:31 <hpc> that sounds nice as long as you have enough disk space
17:05:06 <hpc> and don't have large binary-ish files constantly being created and deleted
17:05:11 <hpc> like say, a browser cache :P
17:19:34 <programmer777> test
17:20:22 <programmer777> Would anyone know how to save the CookieJar from Network.HTTP.Types to a file to be reread later?
17:34:15 --- mode: karatkievich.freenode.net set +o ChanServ
17:53:16 <jchia> pavonia: I think ByteString.pack doesn't work on UArray source.
17:54:35 * hackage refined 0.2.0.0 - Refinement types with static and runtime checking  http://hackage.haskell.org/package/refined-0.2.0.0 (chessai)
17:54:47 <Axman6> ByteString.PAck . UArray.toList would work though, no?
17:55:03 <Axman6> pack*
18:32:07 <jchia> Question about dealing with Ptr/Addr#: When using pointers to do low-level things, I suppose after GC, the address in a pointer changes. So between the time a pointer is read and the time I use it to do something low-level like a FFI memcpy, what are the consequences if GC happens and relocates the pointer? How do I make sure I don't use a stale pointer in the low-level operation that uses the pointer? Example: https://gist.github.com/jchia/40ee37ed760cca87babe
18:34:29 <mniip> that links nowhere
18:34:55 <mniip> jchia, there's pinned bytearrays for this very reason
18:35:33 <mniip> the general idea is to never use Addr# on heap values
18:36:02 * hackage speechmatics 0.1.1.0 - Speechmatics api client  http://hackage.haskell.org/package/speechmatics-0.1.1.0 (Jappie)
18:39:24 <jchia> mniip: I'm given a UArray by a library and I'm trying to copy it to a new ByteString efficiently.
18:40:33 <mniip> do you have a ByteArray#
18:40:48 <fresheyeball> so I wrote a conduit thing, with runConduitRes
18:40:59 <jchia> mniip: Yes
18:41:13 <fresheyeball> and, I went to test it by using `List.replicate` to make some inputs
18:41:16 <mniip> % :t copyByteArray#
18:41:16 <yahb> mniip: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
18:41:23 <fresheyeball> and... nothing happens
18:41:27 <fresheyeball> I am at a total loss
18:41:45 <fresheyeball> I've put putStrLn, in every part of the conduit
18:41:49 <fresheyeball> nothing fires
18:42:05 <fresheyeball> I even attempted !() <- runConduitRes
18:42:14 <fresheyeball> to demand that the function returned a value
18:42:23 <fresheyeball> and no errors, but also nothing happens
18:42:33 <fresheyeball> AAA
18:42:43 <jchia> mniip: What's the connection between ByteString and MutableByteArray#?
18:43:15 <mniip> you can freeze a MutableByteArray# to a ByteArray#
18:43:54 <jchia> mniip: I ultimately need to copy to a ByteString. How do I get from the MutableByteArray# to the ByteString?
18:44:50 <mniip> hmm
18:46:17 <mniip> % :t Data.ByteString.Internal.unsafeCreate
18:46:17 <yahb> mniip: Int -> (Ptr Word8 -> IO ()) -> Data.ByteString.ByteString
18:46:39 <mniip> % :t copyByteArrayToAddr#
18:46:39 <yahb> mniip: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d
18:46:47 <mniip> you can probably make do with these
18:49:30 <jchia> mniip: I already have this: https://gist.github.com/jchia/40ee37ed760cca87babed902950051ed, and I'm just concerned about GC moving my cheese. Is using unsafeCreate+copyByteArrayToAddr better in this regard?
18:50:09 <mniip> yes
18:50:22 <mniip> copyByteArrayToAddr copies from the right location
18:51:00 <jchia> mniip: So use unsafeCreate to create uninitialized ByteString, and then copyByteArrayToAddr# to copy from the UArray?
18:51:09 <mniip> and Ptr Word8 that ByteString allocates is pinned
18:51:15 <mniip> at least during unsafeCreate's execution
18:52:51 <jchia> mniip: Thanks
18:53:42 <jchia> mniip: But what is State# and what am I supposed to do with it?
18:53:52 <mniip> % :i IO
18:53:52 <yahb> mniip: newtype IO a = GHC.Types.IO (State# RealWorld -> (# State# RealWorld, a #)) -- Defined in `GHC.Types'; instance Alternative IO -- Defined in `GHC.Base'; instance Applicative IO -- Defined in `GHC.Base'; instance Functor IO -- Defined in `GHC.Base'; instance Monad IO -- Defined in `GHC.Base'; instance MonadPlus IO -- Defined in `GHC.Base'; instance Monoid a => Monoid (IO a) -- Defined in `GHC.Base'; inst
18:54:12 <mniip> that's the IO baton
18:54:59 <geekosaur> and ST, iirc
18:55:07 <mniip> yes
18:55:35 <geekosaur> but usually you're going to be using State# RealWorld there and it's what's going on "under" the IO wrapper
18:55:45 <mniip> is hackage docs slow for anyone else
19:04:08 * hackage hw-fingertree-strict 0.1.1.1 - Generic strict finger-tree structure  http://hackage.haskell.org/package/hw-fingertree-strict-0.1.1.1 (haskellworks)
19:05:59 <glguy> mniip: Lagging a bit for me
19:06:19 --- mode: ChanServ set +o glguy
19:06:19 --- mode: glguy set +b *!*@gateway/shell/matrix.org/*
19:09:04 --- mode: glguy set -b *!*@gateway/shell/matrix.org/*
19:14:45 <nkaretnikov> is there an easy way to make sure that numbers generated by system.random are not repeated? for example, if i use `rollDice = getStdRandom (randomR (1,6))` to generate a number from 1 to 6, i want to make sure that every 6 numbers are distinct. so i'm okay with: 2, 1, 3, 6, 5, 4, 1, ... of course, i could use something like an ioref to keep track of what i've already used and modify my range. but is there a simpler way to
19:14:45 <nkaretnikov> do this?
19:15:49 <geekosaur> that *is* the simple way
19:15:56 <geekosaur> random means random, not nonrepeating
19:16:12 <geekosaur> you want shuffle / randomized list
19:16:52 <nkaretnikov> geekosaur: i didn't say that it's non-repeating. i said what i want to get based on the example in the haddocks
19:17:12 <nkaretnikov> if there's a better function for this, i'm all ears
19:17:15 <sinetek> just use 5, i chose it fairly randomly
19:17:40 <geekosaur> you want each set of 1..6 to be randomized within. this is shuffle with repeat when the heap is empty
19:18:11 <sinetek> unsafeIO read a pixel on the screen
19:18:16 <sinetek> okay don't listen to me
19:19:01 <geekosaur> that's ahrder than you think anyway
19:19:07 <nkaretnikov> sinetek: could you add anything valuable to the conversation?
19:20:32 <sinetek> wellll, yes
19:20:38 <sinetek> if you can perform file IO, open /dev/urandom
19:22:46 <sinetek> oh okay i read the thing again, sry
19:24:47 <nkaretnikov> sinetek: didn't mean to sound harsh. just would like some advice with this and jokes waste time.
19:25:21 <glguy> nkaretnikov: You'll end up generating numbers from 1-6, 1-5 ... 1-2 that you can use to shuffle the numbers 1-6 and just repeat that process over and over
19:26:40 <glguy> Using either this or a local implementation: http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
19:42:45 <nkaretnikov> glguy: i was thinking of generating a random number in range (0, length-1) and use that as an index into some list-like data structure that'd contain my range, but that doesn't sound efficient. for example, xs = [1..6]; rand <- (0,5); returns 3; result = xs[3], then xs[3] is removed, so the next iteration is xs = [1,2,3,5,6]; rand <- (0, 4); ... there are two issues with this imo: if my "list" is sequential, i'm wasting a
19:42:45 <nkaretnikov> lot of space (assuming the list is big, i'll still need to force some portion of it) and perhaps might just use a number (but in this case i'd need to maintain a list of hits: that is, after generating a number i check that it's not in a list of previously generated ones, if it is, then i'll need to try again -- this might lead to delays, or just add one to the result, but that might lead to less random results? i guess
19:42:45 <nkaretnikov> to answer that i need to look into the rng). sorry for the messy reply. could you maybe expand a bit on what you suggested?
19:43:07 <nkaretnikov> glguy: as for the shuffle package, i'm not sure how to utilize it for my problem
19:43:39 <glguy> The package handles the messiness of extracting elements from the list in an efficient way
19:44:27 <nkaretnikov> glguy: could you maybe show an example? i've looked through oleg's post, but i'm not sure i'll be using it as intended.
19:45:12 <glguy> You'll use shuffle :: [a] -> [Int] -> [a]
19:47:06 <xpika> is there a lens operation that exemplifies the notion of zipWith ?
19:47:27 <nkaretnikov> glguy: is the second argument here supposed to be the output of `randoms`?
19:48:27 <glguy> That's the "sequence (r1,...r[n-1]) of numbers such that r[i] is an independent sample from a uniform random distribution [0..n-i]"
19:48:59 <nkaretnikov> glguy: yes, i read that. what i'm not sure about is how to get this sequence.
19:49:15 <glguy> so for shufflig a list of 6 elements that'd be 6 numbers in the ranges [1-6, 1-5, 1-4, 1-3, 1-2, 1-1]
19:49:30 <glguy> You'll have to make that using, for example, getRandomRIO
19:49:43 <glguy> shuffleM :: MonadRandom m => [a] -> m [a]
19:49:45 <glguy> will work with IO
19:50:10 <glguy> the manual version is good if you're manually threading around your own StdGen
19:50:34 * hackage serverless-haskell 0.5.1 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.5.1 (AlexeyKotlyarov)
19:50:55 <nkaretnikov> glguy: okay, let me write something.
19:51:13 <nkaretnikov> glguy: thanks for making it clear. i'd certainly got it wrong without your input.
19:56:42 * tabemann laments that getting cairo to work with gi-gtk is such a hack
19:58:49 <tswett> Oh hi.
20:32:37 <alx741> t
20:32:44 <alx741> oops, sorry
21:16:58 <tysonzero> Hey, does anyone know how to point hs-source-dirs to a parent directory?
21:17:29 <Axman6> that sounds like a bad idea
21:22:50 <tysonzero> why does it sound like a bad idea?
21:24:08 <tysonzero> The specific reason is because I want to have multiple projects in the same src hierarchy, specifically the frontend and backend of a miso app.
21:29:28 <cocreature> I don’t think you can do that
21:31:02 <cocreature> I’m not sure what the sdist tarball is supposed to look like in that case
21:32:45 <tysonzero> hmm, ok, so I should try and get it working with just two "executable"s if I do want it in the same hierarchy
21:33:03 <cocreature> I’m not sure what the advantage of splitting it into multiple cabal projects would be tbh
21:33:09 <cocreature> so yeah that seems like the way to go
21:33:34 <tysonzero> ok cool, and as long as the "library" part is buildable by both ghc and ghcjs there should be no issues?
21:33:55 <cocreature> yep
21:34:15 <cocreature> you probably want something like "if impl(ghcjs) buildable: False" and the inverse on the other for the executables
21:36:13 <tysonzero> Will do, it seems like I need to actually put the dependencies and such in the `else` clause too
21:36:26 <tysonzero> to make sure that ghcjs can't see dependencies it cant build
21:36:29 <tysonzero> and likewise for ghc
21:38:15 <cocreature> I think recent cabal versions handle this properly if buildable: false is set but iirc stack still looks at the deps in that case
21:40:10 <tysonzero> Ah ok, yeah I'm using nix and cabal version 2ish, so not super recent.
21:40:17 <tysonzero> like 2.0.something I think
21:40:26 <cocreature> you can see an example of a cabal file that has a similar setup in the miso repo https://github.com/dmjio/miso/blob/master/examples/haskell-miso.org/haskell-miso.cabal
21:52:17 * hackage webex-teams-api 0.2.0.0 - A Haskell bindings for Webex Teams API  http://hackage.haskell.org/package/webex-teams-api-0.2.0.0 (nshimaza)
22:05:35 * hackage webex-teams-conduit 0.2.0.0 - Conduit wrapper of Webex Teams List API  http://hackage.haskell.org/package/webex-teams-conduit-0.2.0.0 (nshimaza)
22:08:03 * hackage webex-teams-pipes 0.2.0.0 - Pipes wrapper of Webex Teams List API  http://hackage.haskell.org/package/webex-teams-pipes-0.2.0.0 (nshimaza)
22:13:21 <arahael> codewars is pretty nifty.
22:32:07 <dminuoso> Is there some way to express `both (>= 1) (1,0)`
22:36:08 <dminuoso> > anyOf both (>= 1) (1,0)
22:36:11 <lambdabot>  True
22:36:15 <ClaudiusMaximus> > uncurry (on (&&) (>=1)) (1, 0)
22:36:18 <dminuoso> > allOf both (>= 1) (1,0)
22:36:18 <lambdabot>  False
22:36:20 <lambdabot>  False
22:36:27 <cocreature> or foldMapOf for the general case
22:37:05 <ClaudiusMaximus> oh, both is a lensy thing
22:37:41 <cocreature> or even just "view"
22:37:53 <dminuoso> cocreature: how is that?
22:37:58 <cocreature> > view (both . to (>= 1) . to Any) (1,0)
22:38:00 <lambdabot>  Any {getAny = True}
22:38:04 <cocreature> > view (both . to (>= 1) . to All) (1,0)
22:38:06 <lambdabot>  All {getAll = False}
22:39:43 <dminuoso> Ah that's interesting.
22:40:18 <cocreature> if you don’t already know the answer, try figuring out why that works. it’s pretty neat imho :)
22:45:30 * hackage rebase 1.2.4 - A more progressive alternative to the "base" package  http://hackage.haskell.org/package/rebase-1.2.4 (NikitaVolkov)
22:48:59 * hackage rerebase 1.2.2 - Reexports from "base" with a bunch of other standard libraries  http://hackage.haskell.org/package/rerebase-1.2.2 (NikitaVolkov)
22:54:16 <nshepperd> rerebase X_X
22:55:00 * hackage animate-frames 0.0.0 -   http://hackage.haskell.org/package/animate-frames-0.0.0 (jxv)
22:57:29 * hackage animate-frames 0.0.1 - Convert sprite frames to animate files  http://hackage.haskell.org/package/animate-frames-0.0.1 (jxv)
22:58:39 <Axman6> :t view (both . to (>= 1) . _Wrapped)
22:58:41 <lambdabot> error:
22:58:41 <lambdabot>     • Could not deduce (Monoid (Unwrapped Bool))
22:58:41 <lambdabot>         arising from a use of ‘both’
22:59:13 <Axman6> :t view (both . to (>= 1) . _Wrapped) :: (Int,Int) -> All
22:59:14 <lambdabot> error:
22:59:14 <lambdabot>     • Couldn't match type ‘Unwrapped Bool’ with ‘All’
22:59:14 <lambdabot>       Expected type: (All -> Const All All) -> Bool -> Const All Bool
22:59:25 <Axman6> :t view (both . to (>= 1) . re _Wrapped) :: (Int,Int) -> All
22:59:27 <lambdabot> (Int, Int) -> All
22:59:31 <Axman6> :t view (both . to (>= 1) . re _Wrapped)
22:59:33 <lambdabot> (Unwrapped t ~ Bool, Rewrapped t t, Num a, Ord a, Monoid t, Data.Bitraversable.Bitraversable r, MonadReader (r a a) m) => m t
22:59:53 <Axman6> clearly ^_^
23:01:40 <cocreature> re _Wrapped is not even shorter than to Any ;)
23:02:38 <nshepperd> :t anyOf both (>=)
23:02:39 <lambdabot> error:
23:02:39 <lambdabot>     • Couldn't match type ‘a -> Bool’ with ‘Bool’
23:02:39 <lambdabot>       Expected type: a -> Bool
23:02:43 <nshepperd> :t anyOf both (>=1)
23:02:47 <lambdabot> (Num a, Ord a, Data.Bitraversable.Bitraversable r) => r a a -> Bool
23:02:50 <dminuoso> > allOf folded (>=3) (1,2,3)
23:02:52 <lambdabot>  error:
23:02:52 <lambdabot>      • No instance for (Foldable ((,,) Integer Integer))
23:02:53 <lambdabot>          arising from a use of ‘folded’
23:02:53 <dminuoso> Brrr
23:03:24 <nshepperd> > anyOf each (>2) (1,2,3,4)
23:03:26 <lambdabot>  True
23:05:57 <dminuoso> cocreature: Im not fully versed on profunctor optics yet, so I dont fully understand how `to` works
23:06:22 <cocreature> dminuoso: this is not about "to", it’s about "view"
23:06:29 <cocreature> and you don’t need profunctor optics for this
23:06:31 <dminuoso> cocreature: well `view` is simple.
23:07:23 <cocreature> view for Lens is simple but I find it kind of neat that you can just relax the type signature and get something that uses a Monoid constraint to also work for Traversal
23:08:32 <nshepperd> i don't have a clue how the type for 'to' in lens works, but isn't it just a getter that applies your function?
23:08:32 <dminuoso> :t (both . to (>= 1) . to Any)
23:08:33 <lambdabot> (Num a, Ord a, Contravariant f, Applicative f, Data.Bitraversable.Bitraversable r) => (Any -> f Any) -> r a a -> f (r a a)
23:08:41 <dminuoso> o.o
23:10:15 <dminuoso> Okay so I take it, that
23:10:41 <dminuoso> view :: Monoid m => Traversal' s m -> s -> m
23:11:29 <cocreature> that would mean that "view" also requires a Monoid constraint if you apply it to a Lens
23:12:38 <cocreature> the type signature of "view" in lens is helpful for figuring this out (ignoring the MonadReader stuff, that’s just for convenience)
23:20:58 <nshepperd> :t view `asAppliedTo` (undefined :: Traversal' s m)
23:20:59 <lambdabot> (Monoid a, MonadReader s m) => Getting a s a -> m a
23:21:13 <nshepperd> :t view `asAppliedTo` (undefined :: Lens' s a)
23:21:14 <lambdabot> MonadReader s m => Getting a s a -> m a
23:21:25 <dminuoso> :t asAppliedTo
23:21:26 <lambdabot> (a -> b) -> a -> a -> b
23:21:51 <dminuoso> Ah thats pretty cool
23:22:06 <dminuoso> lambdabot has become my type unification slave now.
23:22:27 <nshepperd> :t (+) `asAppliedTo` (undefined :: Int) -- unifies the first argument for you
23:22:28 <lambdabot> Int -> Int -> Int
23:22:54 <dminuoso> :t view
23:22:55 <lambdabot> MonadReader s m => Getting a s a -> m a
23:23:50 <nshepperd> The Monoid constraint comes from: 'instance Monoid a => Applicative (Const a)'
23:25:40 <cocreature> exactly!
23:25:48 <dminuoso> Kind of wish you hadn't spoiled that for me.
23:26:47 * nshepperd hides
23:27:09 <dminuoso> :(
23:32:47 <dminuoso> > (both . to (>= 1) . to Any) Const (1,2)
23:32:49 <lambdabot>  Const (Any {getAny = True})
23:35:14 <dminuoso> cocreature: At any rate, Im still missing the profunctor optics part.
23:35:17 <dminuoso> But I think its solvable.
23:35:29 <dminuoso> profunctors are simple!
23:36:00 <nshepperd> :t to
23:36:01 <lambdabot> (Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
23:36:25 <dminuoso> type Optic p f s t a b = p a (f b) -> p s (f t)
23:36:27 <dminuoso> Mmmm
23:36:38 <cocreature> at some point I understood profunctor optics but it’s not something that I keep in my working memory :)
23:36:47 <dminuoso> so that looks kind of like a generelization of a lens
23:37:03 <dminuoso> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
23:37:33 <dminuoso> But it's curious that Optic no longer has a Functor contraint on `f`
23:37:54 <dminuoso> Is that to admit either Functor or Contravariant?
23:38:36 <nshepperd> :t (\f g -> contramap f . g . f) :: (s -> a) -> Getter s a
23:38:38 <lambdabot> (Functor f, Contravariant f) => (s -> a) -> (a -> f a) -> s -> f s
23:38:52 <nshepperd> I know that you can also write 'to' like the above
23:38:59 <nshepperd> i'm not sure what the difference is
23:39:36 <dminuoso> cocreature: I tried following edwards crazy talk on monad transformer lenses.
23:39:54 <dminuoso> It was clarity for the first 5 minutes, cool for the next 3, and magical crazy unicorn stuff for the remaining 40.
23:40:14 <cocreature> if you want to understand profunctor lenses, take a look at matthew pickering’s paper
23:40:35 <dminuoso> http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf this one?
23:40:42 <cocreature> yep
23:41:14 <cocreature> iirc there is also a talk from jeremy on that on youtube somewhere if you prefer watching a talk over reading a paper :)
23:41:35 <dminuoso> I need to practice reading papers more, so my preference must be set aside.
23:45:35 <nshepperd> :t (\f g -> contramap f . g . f) :: Contravariant f => (s -> a) -> Optic' (->) f s a
23:45:36 <lambdabot> Contravariant f => (s -> a) -> Optic' (->) f s a
23:46:13 <nshepperd> ah, well i guess i didn't use fmap, so there is no functor needed
