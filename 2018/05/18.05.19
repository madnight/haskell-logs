00:31:49 <squeezer> hello everyone
00:32:01 <squeezer> do you guys return functions?
00:34:28 <geekosaur> when it's appropriate, yes. And Haskell being an FP language, it is often appropriate and even idiomatic.
00:34:39 <geekosaur> But for beginners it can be rather confusing at times
00:34:55 <kuribas> squeezer: yes, they are also often called combinators
00:35:18 <squeezer> returning functions confuses me every time I do it
00:35:20 <kuribas> squeezer: as you "combine" behaviour to get new behaviour :)
00:35:34 <kuribas> squeezer: don't worry, it takes time
00:35:36 <squeezer> I have gotten through 15 years of professional programming career never once returning a function
00:35:39 <kuribas> then it becomes natural
00:35:52 <squeezer> and honestly my programs still did what they had to do
00:35:56 <squeezer> and now I find myself in this position
00:36:02 <squeezer> where apparently returning functions is a thing
00:36:04 <geekosaur> because most languages make it painful or even impossible. but in Haskell it's often the natural way to do things
00:36:12 <squeezer> and apparently there are people who actually do it routinely
00:36:19 <kuribas> squeezer: some problems are more elegant in a functional way
00:36:28 <kuribas> squeezer: like recursive descent parsing
00:36:43 <squeezer> so if you got a function, why on earth return it instead of calling it?
00:36:47 <squeezer> you can just call it
00:36:49 <squeezer> and it'll work
00:37:11 <kuribas> squeezer: because you can build more composable software.
00:37:11 <squeezer> sorry I know this is technically not about haskell
00:37:18 <squeezer> I hope this isn't considered offtopic
00:37:27 <kuribas> squeezer: you build up behaviour out of existing behaviour.
00:37:31 <kuribas> it isn't
00:37:59 <squeezer> I build composable software by composing types out of types
00:38:07 <squeezer> where does returning functions come in?
00:38:24 <kuribas> squeezer: have you looked at a parser in haskell?
00:38:47 <squeezer> or like I got a function main() that calls a bunch of functions which also call functions... that is what I understand by "composable"
00:38:52 <squeezer> kuribas: nope
00:39:03 <kuribas> squeezer: also something simple as map (+1) [1..10]
00:39:19 <squeezer> that's not returning a function
00:39:22 <squeezer> that's just a map
00:39:27 <kuribas> squeezer: yes, (+1) returns a function
00:39:36 <kuribas> it's sugar for \x -> x + 1
00:39:41 <loli> often in Haskell I write map (+) [1..10] to return a list of functions
00:39:57 <loli> often used with <*> right after
00:40:38 <kuribas> > (+) <$> [a, b] <*> [c, d]
00:40:41 <lambdabot>  [a + c,a + d,b + c,b + d]
00:40:54 <squeezer> hmm
00:40:58 <squeezer> I find map to be intuitive
00:41:01 <squeezer> I pass a function to it though
00:41:02 <squeezer> not return
00:41:17 <loli> well in this case if we say
00:41:33 <geekosaur> in a lazy language, in a certain sense you're *always* returning a "function"
00:41:51 <kuribas> geekosaur: an imperative function then?
00:41:55 <loli> map (+) [1..10] => Num a => [a -> a]
00:42:25 <kuribas> > (map (+) [a, b]) <*> [c, d]
00:42:27 <lambdabot>  [a + c,a + d,b + c,b + d]
00:43:05 <kuribas> squeezer: it generates the sum for each pair of values from the lists
00:44:09 <kuribas> map returns a list of functions, then <*> combines it with the second list
00:45:32 <kuribas> squeezer: you may think, why not do it directly?  That's what liftA2 does.  But this works with functions of any arity.
00:46:21 <kuribas> > (,,,) <$> [a, b] <*> [c, d] <*> [e] -- for example
00:46:24 <lambdabot>  error:
00:46:24 <lambdabot>      • No instance for (Typeable d0)
00:46:24 <lambdabot>          arising from a use of ‘show_M663974562823434192127026’
00:46:32 <kuribas> > (,,) <$> [a, b] <*> [c, d] <*> [e] -- for example
00:46:34 <lambdabot>  [(a,c,e),(a,d,e),(b,c,e),(b,d,e)]
00:48:55 <loli> in a more impure setting, sometimes I return a closure which is a function
00:49:23 <loli> which holds inside itself some mutable variable that when i call said function changes itself. It's a neat little toy
00:50:36 <kuribas> squeezer: one of the advantages of using the combinator approach, is that you can build primitives, which you can easily understand or test, then build more complex pieces out of it.  HOFs are indespensable here.
00:51:20 <kuribas> squeezer: they give you software which you can reason about more easily, so make it easier to maintain, less bugs, ...
00:54:44 <squeezer> I still don't understand it :( how do I understand it?
00:55:04 <loli> well a very simple example is add2 = (+ 2)
00:55:17 <loli> here (+ 2) returns a function
00:55:19 <loli> (+ 2) :: Num a => a -> a
00:56:50 <squeezer> yeah I get it
00:57:02 <squeezer> I don't understand why to write a function that returns a function that adds two to x
00:58:05 <squeezer> the problem isn't that I don't understand the concept of functions being stored or returned as values
00:58:32 <squeezer> I have often created hashmaps and arrays of functions in other languages
00:58:55 <loli> huh, is lpaste still offline?
00:59:05 <squeezer> the problem is that I don't understand the paradigm, the rationale of returning functions, the practical use
00:59:51 <kuribas> squeezer: see my applicative example
00:59:56 <loli> well would a toy example of solving the problem how much water can a list/array hold if you dumped water over it help at all?
01:00:32 <squeezer> loli: how do you mean
01:00:38 <squeezer> dump water over list?
01:00:42 <loli> so imagine some array or sequence
01:00:48 <squeezer> sure easy
01:00:58 <loli> now imagine it as a bar graph with the indencies as the x axis and the value as y axis
01:01:06 <squeezer> array/sequence of what?
01:01:11 <loli> numbers
01:01:13 <squeezer> just numbers?
01:01:14 <squeezer> ok
01:01:26 <loli> in my solution I return functions everywhere
01:01:30 <loli> https://ghostbin.com/paste/knabd
01:01:32 <loli> as seen here
01:01:49 <mjoldfield> squeezer: Suppose you were writing code to manipulate an image. Say you had a function which made it brighter, or another which made it black and white, whatever. You'd probably separate defining the transformations from applying them. Perhaps you have some funky way of applying the transform to a gazillion images at once. Combining functions lets you easily make a new function which does a bunch of transformations.
01:01:49 <mjoldfield>  The code which applies the transformations to the images doesn't need to know all the details: it just sees  a new transformation.
01:02:05 <loli> I solve this problem by getting the max value to the left and right at each point
01:02:24 <squeezer> mjoldfield: sure defining the function would be different from applying it
01:02:33 <squeezer> defining to me would mean coding it
01:02:39 <squeezer> applying would mean calling it
01:03:04 <loli> here "maxRight key = maxGen key . reverse" I return a function with maxGen key . reverse
01:03:17 <loli> even
01:03:21 <loli>  maxL = maxLeft id is a function
01:03:27 <loli> as maxLeft takes 2 arguments, but I only give it 1
01:03:37 <mjoldfield> squeezer: so how would you define a new function which called the 'make brighter' function n times, where n is only known at runtime, without modifying the machinery to apply the transformations
01:03:40 <squeezer> mjoldfield: your example is good coz I understand it
01:03:46 <squeezer> I imagine
01:03:55 <squeezer> brighten() would return a brighter image
01:04:06 <squeezer> that I would pass back to it
01:04:18 <squeezer> (provided it didn't take a parameter of how much brighter I want the image)
01:04:45 <squeezer> is that bad?
01:05:02 <squeezer> also why not just brighten(how_much)
01:06:01 <mjoldfield> If I were writing it, then I'd have a function called applyTransformation which took a transformation and an Image
01:06:23 <mjoldfield> Then I could make loads of new transformations as I wanted to by combining old ones.
01:06:32 <mjoldfield> So I could say stuff like:
01:06:47 <mjoldfield> muchBrighter = brighter . brighter
01:07:12 <mjoldfield> And it would be easy to apply:
01:07:25 <mjoldfield> applyTransformation brighter selfie
01:07:41 <mjoldfield> applyTransformation muchBrighter selfie
01:08:10 <mjoldfield> Because I pass a function to applyTransformation I can make that function in any way I like
01:08:24 <mjoldfield> I could even do something like;
01:08:41 <mjoldfield> applyTransformation (pasteImageOver background) selfie
01:09:10 <mjoldfield> Where background is some other data which is only relevant to pastImageOver
01:09:24 <mjoldfield> If you put types on it, you might say:
01:09:31 <mjoldfield> brighter :: Image -> Image
01:09:46 <mjoldfield> applyTransformation :: (Image -> Image) -> Image -> Image
01:09:57 <mjoldfield> pasteOverImage :: Image -> Image -> Image
01:10:03 * hackage haddock-library 1.6.0 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.6.0 (HerbertValerioRiedel)
01:10:08 <mjoldfield> pasteOverImage background :: Image -> Image
01:10:24 <squeezer> so why not just define muchbrigher img = brighter img brighter img?
01:10:31 <squeezer> what's the conceptual advantage?
01:10:38 <kuribas> wouldn't that be (Color -> Color) -> (Image -> Image) ?
01:11:19 <mjoldfield> To me there is a conceptual advantage in separating how the transforms are defined from how they're applied.
01:11:40 <mjoldfield> applyTransformation only needs a (Image -> Image) transformer function and it doesn't matter how I make it
01:12:03 <squeezer> mmm
01:12:04 <squeezer> so you say
01:12:13 <squeezer> "I want something that takes an image and returns an image"
01:12:19 <squeezer> and I will invoke it
01:12:36 <mjoldfield> But I want the freedom to make that image -> image thing at runtime
01:13:03 <mjoldfield> Perhaps by taking a Image -> Image -> Image thing and fixing one of the input images
01:13:06 <squeezer> what does that even mean? code need to be precompiled before executing on the CPU
01:13:22 <kuribas> squeezer: HOFs are implemented as closures.
01:14:08 <kuribas> squeezer: they are basically the current invironment together with the "code instructions".
01:14:13 <mjoldfield> It means I get to combine the functions into other functions, just as you're used to combining values
01:14:36 <kuribas> squeezer: but it's more complex than that, because ghc also does inlining, etc...
01:14:50 <mjoldfield> I think it helps to think of a closure as a function with some data associated with it.
01:15:02 <squeezer> :(
01:15:14 <squeezer> is there a book or an article that I can read and definitely get this stuff?
01:15:16 <kuribas> squeezer: in C it would be a function pointer and a data pointer
01:15:35 <mjoldfield> I liked Hutton's book on Haskell.
01:15:50 <mjoldfield> 'Programming in Haskell', 2nd edition
01:15:53 <squeezer> like "here read these 300 pages and even if your IQ is 75, you'll definitely get it"
01:16:02 <squeezer> I've read Learn you a Haskell and Real World Haskell and still don't get it
01:16:05 <squeezer> don't get me wrong
01:16:07 <squeezer> I can program in Haskell
01:16:13 <squeezer> I just tend to never return functions
01:16:28 <johnw> ?
01:16:32 <squeezer> and it never even happens that I think "oh cool now's a good time to return a function"
01:17:00 <squeezer> I know how to do it
01:17:03 <squeezer> the type system makes sense
01:17:06 <squeezer> it just doesn't come up
01:17:08 <squeezer> I can't explain
01:17:08 <kuribas> squeezer: whenever you write a function with more than two arguments, you are returning a function.
01:17:27 <kuribas> it's called currying
01:17:30 <johnw> a -> (b -> c) is just a -> b -> c
01:17:33 <squeezer> kuribas: yeah I even get that
01:17:48 <kuribas> squeezer: so you probably wrote many functions returning functions :)
01:17:52 <johnw> yeah, why make a point of "returning functions"?
01:18:03 <johnw> i don't think I've ever thought of them that way even
01:18:18 <squeezer> but personally I never find myself returning functions, in sort of a more explicit way than the currying that happens with multiparameter functions
01:18:33 <johnw> why is that a problem, squeezer?
01:19:04 * hackage haddock-api 2.20.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-api-2.20.0 (HerbertValerioRiedel)
01:19:23 <squeezer> johnw: because one of my friends told me that I am a lesser being if I don't routinely return functions
01:19:37 <johnw> that just sounds bizarre to me
01:19:49 <squeezer> johnw: do you return functions?
01:19:56 <johnw> i never even ask myself that question
01:20:01 <johnw> i just write functions
01:20:03 <squeezer> well I just asked you that question
01:20:07 <kuribas> squeezer: they also often not explicit.  For example type Parser = String -> Maybe (a, String)
01:20:08 <johnw> i do it all the time
01:20:12 <johnw> any time I write a function with more than one argument
01:20:22 <squeezer> no I mean in a more explicit fashion
01:20:27 <johnw> how is that different?
01:20:34 <johnw> how would you even write it differently?
01:20:38 <kuribas> squeezer: So when you write (Parser Int), a parser that parses an integer, you actually return a function.
01:21:06 <squeezer> it's completely different because when you have a sum :: Int -> Int -> Int and you just return sum a b c = a + b + c
01:21:13 <squeezer> I'd argue that even though currying happens
01:21:20 <squeezer> you're not returning a function
01:21:23 <squeezer> you're returning an Int
01:21:30 <johnw> this all sounds like questing after someone else's unicorn
01:21:40 <loli> not until you apply the 2/3 arguments
01:21:59 <squeezer> loli: we need to define "you" in that sentence
01:22:13 <squeezer> "you" don't apply anything. the runtime does that.
01:22:16 <mjoldfield> squeezer: OK, suppose you have this: toy f = map f xs
01:22:17 <squeezer> "you" just return an int
01:22:35 <squeezer> mjoldfield: sounds good
01:22:38 <mjoldfield> squeezer: I assume you're happy with toy (+1), toy (*2), etc
01:22:47 <loli> the person programming inputs the 2/3 arguments, if the person programming inputs 1, and delays the argument, then sum does not return an int
01:23:04 <loli> map (sum 2 3) [1..10] could be an example of what the programmer can write
01:23:14 <kuribas> squeezer: a very common way to create functions is composition.
01:23:15 <loli> in this case sum 2 3 is a function from Int -> Int
01:23:37 <squeezer> sure, I understand very well how map works
01:23:43 <kuribas> > map ((+1).(*2)) [1..5] -- squeezer like this
01:23:46 <lambdabot>  [3,5,7,9,11]
01:24:05 <squeezer> ouch
01:24:09 <mjoldfield> squeezer: It seems to me that it's good to be able to write stuff like
01:24:27 <mjoldfield> toy (applyTwice (+1))
01:24:41 <kuribas> squeezer: like in the image manipulation example, you may have filters (Color -> Color), then you can create a new filter with composition(.)
01:24:51 <squeezer> kuribas: that map I don't understand :(
01:25:15 <mjoldfield> where applyTwice f = f . f
01:25:15 <kuribas> squeezer: (+1) . (*2) multiplies by 2, then adds 1.
01:25:23 <kuribas> :t (.)
01:25:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:25:29 <squeezer> I would write that as map foo [1..5] where foo does those operations and returns a result
01:25:58 <squeezer> is that lame?
01:26:37 <kuribas> squeezer: it's another way of looking at things
01:27:18 <squeezer> and I would even write that foo as a closure
01:27:27 <squeezer> but I would NOT use that dot
01:27:33 <kuribas> squeezer: you're way is more like "how" to do it.  The FP approach is more "what" you do.
01:27:54 <kuribas> squeezer: think of (.) as Filter -> Filter -> Filter
01:28:08 <kuribas> squeezer: it takes two filters and combines them into one.
01:28:17 <kuribas> squeezer: you don't really want to know how it does it.
01:28:28 * hackage haddock 2.20.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.20.0 (HerbertValerioRiedel)
01:28:36 <squeezer> mmmm takes two filters and combines them into one
01:28:48 <squeezer> trying to picture 1. what's a filter 2. what would combining them look like
01:29:05 <kuribas> type Filter = Color -> Color
01:29:16 <squeezer> yes sure
01:29:24 <squeezer> a filter is a function that takes a color and returns a color
01:29:26 <squeezer> I dig it
01:29:55 <squeezer> now when you say combines filters
01:29:59 <squeezer> aka
01:30:00 <kuribas> then combineFilters :: Filter -> Filter -> Filter; combineFilters = (.)
01:30:23 <squeezer> yeah
01:30:46 <squeezer> oh wait
01:30:52 <squeezer> I think it makes sense
01:31:30 <squeezer> yeah sure you have a function combineFilters that takes two functions and calls them
01:31:38 <squeezer> ah interesting, and combineFilters doesn't need to worry about filter arguments
01:32:01 <kuribas> yeah
01:32:08 <squeezer> that's pretty cool right?
01:32:13 <kuribas> yeah, exactly :)
01:32:22 <kuribas> and combineFilters is just composition
01:32:40 <squeezer> yeah but literally what we did here is
01:33:04 <squeezer> "what if we came up with a function that took two functions as arguments and called them and returned the result"
01:33:21 <kuribas> yes
01:34:16 <squeezer> you could do that in Python
01:34:24 <squeezer> or Swift
01:34:31 <kuribas> sure
01:34:57 <squeezer> and yet somehow it's extremely rare in Swift or Python to do this, while in Haskell people do this all the time
01:35:26 <kuribas> squeezer: it's about culture.  Also Python people try to avoid it, and the language doesn't make FP really easy.
01:35:47 <squeezer> hmph
01:35:57 <squeezer> I think now's the time for me to begin my journey
01:36:03 <squeezer> of returning my first thousand functions
01:36:32 <squeezer> kuribas: mjoldfield loli lambdabot you guys are phenomenally wonderful
01:37:36 <juhp> sclv: ah https://hackage.haskell.org/package/vector-0.12.0.1/revisions/.json works
01:38:31 <hvr> juhp: that's a fairly recent addition; but be careful not to rely on its schema never changing ;0
01:38:51 <juhp> okay
01:39:30 <juhp> don't worry, I don't find revision json that useful anyway :)
01:41:21 <mjoldfield> squeezer: Do you know Perl ?
01:41:29 <squeezer> mjoldfield: I know about it
01:41:33 <squeezer> I wouldn't say I know it
01:42:22 <squeezer> I know Python and Swift fluently, Rust pretty well, C++ pretty well, Golang fluently, some Javascript, some Objective C, some Pascal
01:42:45 <mjoldfield> There's a good book 'Higher Order Perl' which talks about this sort of thing in Perl.
01:45:32 <kuribas> squeezer: I'd say swift lends itself well for this approach.  But probably many swift programmers come from objective-C
01:55:17 <geekosaur> in a certain sense, smalltalk-style OOP abstracts this in a different way: as message selector. (this is not true, or at least not true in the same way, in Java or C++ style OOP. but you have to get *really* abstract to see these)
01:57:15 <geekosaur> (I will also note that seeing these kids of abstractions can be useful, but aren't necessary or we'd never have gotten past Jacquard looms. so not being able to think about them at that level isn't necessarily a bad thing)
01:58:32 <pindab0ter> I'm trying to get a project configured with dependencies and their sub dependencies. Can someone point me to a good resource to understand this workflow or maybe give me some pointers 1:1?
02:34:27 <iron_houzi> I could really need some help with my design to understand how to utilize haskell in the best possible way. I am parsing latin strings to Tibetan unicode: https://github.com/ironhouzi/hstib/blob/typing/src/Main.hs. The "lexer" parses the string to a [Letter] and I was hoping to use pattern matching on [Letter] to derive correct generation of unicode. Say matching [Ka, Ya, A, Nga] as [Subscribed, Subscriber,
02:34:29 <iron_houzi> Vowel, Suffix], would be perfect, but I don't know it its possible to do in Haskell..
02:35:19 <iron_houzi> This means I would have to create some classifications for the Letters somehow..
02:38:13 <iron_houzi> ..what's even more complicated is that there are 4 different letters that can be classified as Subscriber, but there are different sets of Subscribed for each of the four Letters in the Subscriber set..
02:39:21 <iron_houzi> I'm porting this from Python and I see that I'm quickly departing from what I feel is idiomatic Haskell, so I could really use som input to understand how to solve this idiomatically
03:17:20 <shiona_> does TVar [TVar Player] make sense to people as a "player queue" for a multiplayer lobby? I have a thread that listens to connections, puts new connectees into the queue (list) launches a thread for that player to communicate with. Yet another thread picks players from the queue and needs a way to tell the players that they moved from the queue to a game
03:18:12 <shiona_> so the first TVar there is so that the lobby and gamelauncher can share the list of waiting players and the inner TVar so that a player thread and game launcher can communicate
03:19:03 <shiona_> I assume there are better solutions I'm not familiar with, that's why I'm asking
03:25:21 <c_wraith> shiona_: it makes sense, but if the outer TVar is change very often it'll cause problems
03:25:48 <c_wraith> shiona_: TVar isn't great with a single point of contention, due to the use of optimistic locking
03:26:34 <c_wraith> shiona_: On the other hand, your use case doesn't seem like it'll have much contention at all
03:29:41 <shiona_> The outer TVar should not change that often
03:31:18 <c_wraith> even if it does, you can often use striping to massively reduce contention issues.  (that is, create multiple top-level TVars and partition the values being stored between them)
03:38:04 * hackage forma 1.0.0 - Parse and validate forms in JSON format  http://hackage.haskell.org/package/forma-1.0.0 (mrkkrp)
04:21:40 <maerwald> anyone knows why cabal new-installs installs nothing?
04:29:20 <c_wraith> Now I want to create a package named nothing
04:30:28 <c_wraith> is new-install actually implemented?  I haven't been paying a lot of attention, but when the new-* commands started getting added, istr new-install wasn't initially implemented
04:44:36 <zincy> What is a good method for parsing stdin queries of the form M 2 3        Q 3         Q 2
04:45:13 <maerwald> c_wraith: it's buggy crap
04:45:15 <zincy> The first char represents the type of query and the integers following are parameters. I Have a custom query type I made but am not sure how I should parse it.
04:45:43 <maerwald> I don't know why it's half-implemented, I find that to be quite dangerous
04:47:44 <setre> what is matched with this pattern? f (a:(xss@b:xs)))
04:48:45 <c_wraith> setre: lists with at least 2 elements
04:48:55 <srk> anyone using vim with haskell conceal? trying to find a usable font. looks like it's not compatible with hasklig
04:48:58 <setre> what is a and b?
04:49:08 <c_wraith> setre: the first two elements of the list
04:49:21 <setre> c_wraith: okay thank you
04:49:52 <c_wraith> setre: xxs is the tricky one - it's the tail of the input list.  It's equivalent to (b:xs)
04:50:29 <setre> hmm okay
04:51:04 * hackage motor 0.3.0, motor-reflection 0.3.0, motor-diagrams 0.3.0 (owickstrom): https://qbin.io/xl-chaos-qz0l
04:51:58 <c_wraith> > let f (a:(xxs@b:xs)) = (a, xxs, b, xs) in f [1,2,3,4]
04:52:00 <lambdabot>  (1,2,2,[3,4])
04:52:09 <c_wraith> setre: oh, I was wrong.  Misread the precedence
04:52:37 <c_wraith> setre: due to the precedence of @ being higher than :, xxs is actually the same as b.  I think that's a bug in the pattern
04:52:55 <setre> so it can be simplified?
04:53:18 <c_wraith> yeah, it could just be (a:b:xs)
04:53:31 <setre> weird
04:54:19 <c_wraith> I think, based on the names, the pattern was intended to be (a:xss@(b:xs))
04:54:36 <c_wraith> err (a:xxs@(b:xs))
04:55:58 <setre> which would be a,b == the first two elements of the list, xxs the tail of the list and xs the tail of the tail of the list?
04:56:08 <c_wraith> setre: exactly
04:56:24 <setre> cool, thank you
04:57:50 <michi7x7> zincy: https://goo.gl/AebMcD
04:57:59 <maerwald> oh wow, in Cabal-3 half of the API is deprecated again... this will be fun to support cabal-1.2.x, cabal-2.x and 3.x simultaneously
04:58:30 <maerwald> haskell motto: break API as often as you can, because we have semver, right?
05:06:31 <zincy> michi7x7: Wow that is pretty crazy haskell infers the type from the string?
05:06:53 <michi7x7> zincy: sure
05:09:23 <zincy> So what are the limitations of using deriving read vs using say a full blown parser like parsec?
05:09:34 <zincy> Thanks much more elegant than my solution
05:19:22 <michi7x7> zincy: well, the format matches the format of deriving(Show), you have no control over it
05:19:25 <michi7x7> zincy: http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Read
05:24:24 <infinisil> And (correct me if I'm wrong), Read/Show only does String, which is kinda bad for representing text
05:35:31 <maerwald> not bad, but inefficient
05:44:43 <tdammers> it's OK for parser input though
05:45:10 <tdammers> most of the time, you're iterating over the input in a linear fashion, which is exactly what String represents
05:45:38 <tdammers> also, s/semver/pvp/
05:46:13 <infinisil> Is Text really less efficient?
05:46:17 <tdammers> no, it's not
05:46:27 <tdammers> Text is usually more efficient
05:46:58 <tdammers> but you cannot derive some Text -> a function like you can derive Read
05:47:22 <tdammers> Read itself isn't the most performant either, due to the way it is implemented
05:47:39 <tdammers> (or rather, writing Read parsers that perform well is quite hard)
05:48:53 <int-e> > read ('"' : repeat ' ') :: Int
05:48:59 <lambdabot>  mueval-core: Time limit exceeded
05:49:38 <int-e> > read " ((-  3) )" :: Int
05:49:40 <lambdabot>  -3
05:52:38 <int-e> (The first example fails to terminate because "read" is built on top of a lexer... which recognizes string constants, various numerical literals, and identifiers. afaiui, that is the main reason why read tends to be slow, especially for a simple task like reading a list of integers. Handling brackets is a comparatively minor drain on performance.)
05:53:47 <maerwald> how can I pass flags to the C linker when invoking cabal new-build
05:56:50 <electrocat> maerwald: adding those options is .cabal is allowed somehow?
05:57:00 <electrocat> or satisfactory
05:57:33 <int-e> maerwald: hmm, what is the right name for PROG in --PROG-option here, --cc-option perhaps?
06:01:03 <maerwald> --ld-options seems to exist, but I still get stupid fPIC error
06:01:38 <int-e> ah, how did I misread "C linker" as "C compiler"
06:07:13 <maerwald> seems there is no proper solution to https://docs.haskellstack.org/en/stable/faq/#i-get-strange-ld-errors-about-recompiling-with-fpic
06:09:56 <freeman42x> is there anything obviously inefficient in this piece of code? https://paste2.org/vWghcPUN
06:12:46 <lyxia> recomputing a scanl of [1..n-1] for every n seems inefficient indeed
06:13:33 <int-e> > take 10 $ iterate (* 0.3) 1
06:13:35 <lambdabot>  [1.0,0.3,9.0e-2,2.7e-2,8.1e-3,2.43e-3,7.289999999999999e-4,2.186999999999999...
06:13:52 <chisui> Is there a way to serialize Datatypes with existential quantification in such a way that captured constraints are preserved?
06:15:58 <merijn> chisui: I'm betting no
06:16:07 <merijn> chisui: That sounds like an implementation nightmare
06:16:23 <chisui> merjin: it is
06:16:24 <freeman42x> lyxia: I see what you mean, but I don't know how to simplify this further except by using mathematical formula, which I will proceed to do right now :)
06:17:28 <lyxia> indeed the formula for geometric series is a good alternative.
06:19:16 <chisui> merijn: My last idea is to create a version of the class I'm interested in that provides all functions I need as distributed-static Static values and serialize the vtable directly that way. But that seems like a hack
06:19:19 <int-e> freeman42x: you could express sysB as a list rather than a function... something like  scanl (+) (fromIntegral card) (iterate (* perc) (perc * fromIntegral ticket))
06:19:40 <merijn> chisui: What are you trying to do, exactly?
06:23:41 <infinisil> What would be a good way to run a trivially parallelizable IO action?
06:23:54 <merijn> infinisil: How slow is it?
06:24:03 <merijn> infinisil: Also, how many?
06:24:08 <infinisil> I have a [String] and would like to run a command on each one of them and gather the results
06:24:17 <infinisil> About 2500, pretty slow, takes like a minute
06:24:36 <infinisil> Currently I'm calling a single command with all the arguments, which only uses 1 core
06:24:51 <merijn> infinisil: You can either use async's mapConcurrently, which doesn't play too well with too big datasets
06:25:24 <infinisil> Oh, that would just spawn 2500 threads?
06:25:34 <merijn> infinisil: Well, is this code you plan to publish/put on hackage anytime soon? If not, I've got some unreleased code you could try
06:25:43 <merijn> infinisil: Yeah, pretty much
06:25:44 <infinisil> Nope, just my own personal usage
06:25:55 <infinisil> Sure, why not :)
06:26:22 <merijn> infinisil: So, this is something I've been meaning to get around to finishing up and putting on Hackage for ages, but I can't find the time: https://github.com/merijn/broadcast-chan
06:27:19 <merijn> infinisil: Specifically, what's been really nice in my code so far is: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-conduit/BroadcastChan/Conduit.hs#L21-L33
06:27:44 <merijn> infinisil: Basically, take a function "a -> IO b" and run it N times in parallel while processing a stream
06:28:46 <merijn> Although mapConcurrently might work just as well, depending on what you're doing and how much data
06:29:37 <int-e> infinisil: from the description, https://hackage.haskell.org/package/async-pool sounds more applicable than async. it has a mapConcurrently just like async does but you can bound the number of workers.
06:30:11 <int-e> (disclaimer, I have never used it.)
06:31:18 <infinisil> merijn: Seems a bit excessive for my usecase, but I guess I could try to give it a go
06:31:42 <infinisil> int-e: Thanks that sounds like it would work well, I'll use this in the end probably :)
06:31:43 <merijn> infinisil: Depends on how you're getting the data, how you're processing it, etc. :)
06:31:58 <infinisil> I guess I could explain what I'm doing exactly
06:32:09 <int-e> (spawning 2500 haskell threads is not a big deal, but running 2500 commands in parallel might strain the operating system quite a bit)
06:32:28 <int-e> (where I've interpreted "command" as "external command")
06:32:34 <chisui> merijn: Something like this https://hastebin.com/caxogavaje.hs
06:33:21 <infinisil> I'm writing a tiny CLI that initially computes a perceptual hash over all images in a directory. After this indexing phase you can ask it whether a new picture already is present in the directory, by comparing it with all the calculated hashes
06:34:08 <int-e> Ah, also opening 2500 files simultaneously might run into resource bounds. So I'd definitely want some pooling there.
06:34:20 <infinisil> I'm using the blockhash CLI for doing hash calculation (which also has a package on hackage actually, I should use that)
06:35:07 <infinisil> But I think the CLI might be faster, it's written in C
06:36:37 <infinisil> merijn: How would your package handle that?
06:38:00 <merijn> infinisil: Well, the way to setup that would be to use a conduit produces filepaths, write a function that "FilePath -> IO Hash" (or "FilePath -> IO (FilePath, Hash)") so you end up with a conduit of hashes that you can then stream into a database/datastructure to store
06:38:29 <merijn> infinisil: In fact, that problem is kinda similar to what I'm using it for: Running data analysis in paralle on input files and dumping the results into an SQLite db :p
06:39:27 <int-e> https://hackage.haskell.org/package/async-extras-0.1.3.2/docs/src/Control-Concurrent-Async-Extra.html#mapPool  is cool
06:42:37 <int-e> (I'd expect this to be slightly slower than a proper pool of worker threads... but it's essentially a one-liner)
06:43:15 <freeman42x> I run into this issue before but I can't figure it out this time: https://i.imgur.com/1au4TuX.png , the parentheses expression evaluates fine in GHCI , and both sides of / are not Ints. So I don't know what gives, how to figure it out
06:43:57 <jchia_> What does section 2.5 of the Haskell Report really mean regarding floating point literals? According to the grammar, "1" is not supposed to be a floating point literal, but ghci has no problem accepting it as such ("let x = 1 :: Double"). https://www.haskell.org/onlinereport/lexemes.html#lexemes-numeric
06:44:13 <int-e> freeman42x: ticket is an int, you're multiplying it by something that isn't
06:44:14 <c_wraith> freeman42x: text is way better than pictures for code.  but the problem is card and ticket are Int
06:45:05 <merijn> c_wraith: I'm seriously confused how people taking screenshots of code started becoming common in the past years...
06:45:27 <int-e> freeman42x: worse, the error message doesn't correspond to the code.
06:45:33 <merijn> jchia_: That's because all integral are Num and Double is a Num instance
06:45:34 <c_wraith> merijn: some part of me assumes it's a plagiarism-detector evasion technique
06:46:23 <merijn> jchia_: Floating literals are restricted to Fractional or Rational, whereas integral literals are just Num
06:46:25 <freeman42x> int-e: that is the main issue I am having, but that is the error message given by the compiler.
06:46:26 <merijn> :t 1
06:46:27 <lambdabot> Num p => p
06:46:29 <merijn> :t 1.0
06:46:30 <lambdabot> Fractional p => p
06:46:31 <freeman42x> thank you, that was it
06:46:57 <int-e> freeman42x: note that the error message has "fromIntegral ticket", but the code snippet doesn't.
06:47:21 <merijn> jchia_: But Num is a superclass of Fractional, so any integral literal can automatically also be converted to any type of floating point literals :)
06:48:33 <freeman42x> int-e: ah yeah, I was trying to fix it by adding it, must have been a cache issue
06:48:33 <infinisil> Well, I quickly tried with mapConcurrently from async-pool, but I get "thread blocked indefinitely in an STM transaction" :/
06:49:37 <jchia_> merijn: I suppose when ghci sees '1.2' it figures that it's a floating-point literal and gives it type "Fractional a => a" whereas for '1', it's a decimal literal and ghci gives it type "Num a => a". Is that right?
06:49:48 <merijn> jchia_: Yes
06:49:49 <infinisil> Hah, there even is an issue for it: https://github.com/jwiegley/async-pool/issues/7
06:50:42 <merijn> jchia_: And from there type inference kicks in and tries to constraint it to more specific types (in your let example you're explicitly constraining it to Double), so it then checks whether that typechecks
06:50:52 <merijn> jchia_: And since "instance Num Double" the answer is: Yes
06:51:44 <jchia_> merijn: OK. I was actually led to this question because of Text.Megaparsec.Byte.Lexer.float (parser for floating point). (https://www.stackage.org/haddock/nightly-2018-05-19/megaparsec-6.5.0/Text-Megaparsec-Byte-Lexer.html#v:float). I was wondering why it does not accept something like "1".
06:53:10 <merijn> jchia_: Ah, because your parser might not be similar to Haskell, and so you might not want to allow the same :)
06:54:46 <jchia_> merijn: I suppose sometimes you really want a parser that requires the '.' (e.g. in ghci), and if you want to be more accomodating you can always use something like "MP.try MP.float <|> (fromIntegral @Int <$> MP.decimal)"
06:54:53 <merijn> Right
07:31:59 <Georgeoftown> Is there any free to help me with a haskell problem
07:32:31 <barrucadu> Don't ask to ask, just ask
07:33:35 <Georgeoftown> I have to deploy this function, removeOperator :: Operator -> OperatorSequence -> OperatorSequence
07:34:11 <freeman42x> one more question, WAT! https://i.imgur.com/JyQ8E8s.png did I break enums or something
07:35:08 <Georgeoftown> Operator is 'A' or 'b' and OperatorSequence is "AcCbAcDCaBb"
07:36:23 <MarcelineVQ> freeman42x: how about (Enum a, Num a) =>
07:38:24 <aarvar> what a useless error message. It even gives a "possible fix"
07:39:40 <pavonia> Georgeoftown: So what is your question/problem?
07:46:46 <infinisil> Hah
07:47:48 <infinisil> I'm kinda proud of myself, I just created a usable CLI within a couple hours
07:47:55 <Georgeoftown> This is the problem https://imgur.com/J75B0EB
07:48:16 <EvanR> infinisil: did you use haskeline (sp)
07:48:24 <infinisil> EvanR: I did not
07:48:30 <EvanR> interesting
07:48:36 <infinisil> It's a usable CLI, but by no means a nice one :P
07:50:51 <infinisil> Georgeoftown: How many arguments does your first pattern take vs how many does the second one take?
07:52:05 <infinisil> Georgeoftown: The error tells you that those two numbers are different, they need to be the same for it to compile
07:52:12 <Georgeoftown> I want boot take 2 but i down know how
07:53:19 <infinisil> Georgeoftown: Look at line 8, where is the Operator argument? The y?
07:53:38 <infinisil> It's not there, and you need to add it line you did on line 7
07:53:50 <infinisil> s/line you/like you
07:55:12 <Georgeoftown> I see
07:56:58 <Georgeoftown> ¿Looks good?
07:57:01 <Georgeoftown> https://imgur.com/COeoe62
07:57:54 <infinisil> Sure
07:58:07 <infinisil> I mean it compiles
07:58:25 <infinisil> Ship it!
08:00:45 <Georgeoftown> And works, thanks, i'll ask more https://i.imgur.com/4IASz61.jpg
08:12:03 <infinisil> Georgeoftown: Please use a paste service such as http://lpaste.net/ or https://gist.github.com/ in the future though
08:12:11 <infinisil> Instead of sharing pictures
08:16:05 <Georgeoftown> oks
08:21:05 <Georgeoftown> https://gist.github.com/georgeoftown/11b03e7856dbb34cc6bf98ccbc26bc82
08:21:21 <Georgeoftown> lpaste is offline
08:21:50 <int-e> hmm? looks fine from here
08:22:23 <Georgeoftown> ERR_CONNECTION_TIMED_OUT for me
08:23:15 <int-e> so... isInverse x y = removeInverses zs <-- are you sure you want to remove both x and y?
08:23:56 <Georgeoftown> yes, if they are equals both goes out
08:24:16 <Georgeoftown> "equals" aA or bB or cC
08:24:24 <int-e> ah, it's simplifying
08:24:34 * hackage JuicyPixels-scale-dct 0.1.2 - Scale JuicyPixels images with DCT  http://hackage.haskell.org/package/JuicyPixels-scale-dct-0.1.2 (phadej)
08:25:00 <int-e> Georgeoftown: which case you could consider what happens to A B B^-1 A^-1 in your function
08:25:04 <pindab0ter> I'm trying to wrap my head around how stack/cabal works. It seems I'm missing dependencies of dependencies. I'm not sure what the best way of getting these is. Anyone who can point me in the right direction?
08:25:58 <int-e> pindab0ter: That question is not concrete enough, I believe. Both tools come with 'install' commands that resolve dependencies recursively.
08:25:58 <Georgeoftown> empty
08:26:07 <int-e> Georgeoftown: have you checked?
08:26:35 <Georgeoftown> same error
08:26:38 <int-e> Georgeoftown: because I'm pretty sure that it actually returns A A^-1.
08:27:09 <int-e> oh, the error
08:27:19 <int-e> Georgeoftown: you never handle the case of a singleton list
08:27:48 <Georgeoftown> singleton?
08:27:53 <int-e> single element
08:27:55 <int-e> (i.e., removeInverses [x] = [x])
08:28:10 <Georgeoftown> it cant be
08:28:10 <pindab0ter> int-e: I'm still at the stage of figuring out what the difference is between Stack and Cabal, what their responsibilities are and how much overlap there is.
08:29:00 <Georgeoftown> the predicate tells it
08:29:20 <Georgeoftown> allwais pair
08:29:41 <int-e> > case [1] of [] -> "empty" | x : y : zs -> "at least two elements"
08:29:43 <lambdabot>  <hint>:1:27: error: parse error on input ‘|’
08:29:48 <int-e> > case [1] of [] -> "empty"; x : y : zs -> "at least two elements"
08:29:50 <lambdabot>  "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
08:30:14 <int-e> > case [1,2] of [] -> "empty"; x : y : zs -> "at least two elements"
08:30:16 <lambdabot>  "at least two elements"
08:30:20 <int-e> > case [] of [] -> "empty"; x : y : zs -> "at least two elements"
08:30:20 <Georgeoftown> aBAb is the minimun
08:30:22 <lambdabot>  "empty"
08:30:48 <Ariakenom> pindab0ter: are you using both at the same time?
08:31:21 <parzydeuko> guys, what's your opinion on Learn You a Haskell? is it a good resource for a beginner?
08:31:59 <pindab0ter> l
08:32:38 <byorgey> parzydeuko: it's OK but not the best. Try this guide instead: https://github.com/bitemyapp/learnhaskell/blob/master/README.md
08:32:52 <pindab0ter> Ariakenom: I am at the moment. Created a new project using IntelliJ which contains a .cabal file and a stack.yaml file
08:34:07 <Ariakenom> Haven't really used stack much. But  you should afaik only use stack in that setup
08:37:14 <pindab0ter> Ariakenom: I'll give that a go
08:37:42 <pindab0ter> So yeah, if I add a dependency that has dependencies of it's own, it will not automatically get those, am I correct in saying that?
08:44:21 <electrocat> byorgey: shameless plug of your own class :p
08:46:18 <electrocat> byorgey: how would you consider it's density? could it be taught in half of a semester?
08:54:40 <Georgeoftown> Error goes out
08:54:51 <Georgeoftown> but not works as espected
08:54:53 <Georgeoftown> https://gist.github.com/georgeoftown/11b03e7856dbb34cc6bf98ccbc26bc82
09:12:10 <blankhart> i am deepening my understanding by looking at medium to large scale open source haskell applications (not libraries or frameworks).  does anyone have recommendations? i have benefited from xmonad, pandoc, matterhorn, lambdabot, and dino-rush, and am looking for others of the type.
09:12:55 <sm> hledger
09:13:03 * hackage implicit 0.2.0 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..  http://hackage.haskell.org/package/implicit-0.2.0 (Juri_)
09:13:35 <sm> leksah
09:13:42 <sm> darcs
09:13:54 <sm> and of course, ghc
09:14:25 <sm> cardano-sl
09:17:20 <juri_> yay! new implicitcad release! :)
09:17:29 <sm> darcsden
09:18:24 <jakov> Hello ! I am currently learning QuickCheck and trying out the tutorial at https://www.schoohttps://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testinglofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing     At the heading at "A first attempt" my quickcheck fails and says    *** Failed! Falsifiable (after 4 tests and 4 shrinks):    'a'    "a" " .  I see that one is a Char, the other is a [Char], but i don't
09:18:25 <jakov> understand why the internals of QuickCheck test [Char] against Char.
09:24:20 <blankhart> thank you sm
09:31:27 <lyxia> jakov: prop_split_inv is a property on Char and [Char], its type is    prop_split_inv :: Char -> [Char] -> Property
09:31:34 <sm[m]> blankhart: and then there's http://joeyh.name/blog/entry/fridge_0.1 !
09:32:14 <lyxia> prop_split_inv :: Char -> [Char] -> Bool   actually, and then Bool is converted to Property by quickCheck
09:32:59 <lyxia> jakov: so the fact that the test fails means that    prop_split_inv 'a' "a" = False
09:33:35 <qqwy> Hello everyone!
09:33:44 <qqwy> I am trying to grok Comonads
09:33:51 <qqwy> and am currently looking for examples of Comonads
09:34:29 <qqwy> The only thing I have seen and understand so far is the 'Spreadsheet' analogy, where an infinite stream is modeled as a comonad (as are infinite streams of infinite streams)
09:34:47 <qqwy> but 'infinite streams' are probably not the only practical Comonad instance, right?
09:37:26 <blankhart> wow sm, that pinpointed my exact use case
09:37:57 <sm[m]> bingo!
09:38:51 <sm[m]> I, eh.. am surprised to find the world's second haskell-controlled-fridge enthusiast :)
09:39:02 <sm[m]> so quickly
09:39:52 <blankhart> why wouldn't you use haskell to control it?
09:40:06 <blankhart> you use ruby?
09:40:52 <sm[m]> I am sadly a bit behind with my fridge control setup.
09:41:14 <sm[m]> nifty though isn't it
09:41:17 * hackage grammatical-parsers 0.3.1 - parsers that combine into grammars  http://hackage.haskell.org/package/grammatical-parsers-0.3.1 (MarioBlazevic)
09:42:06 <EvanR> qqwy: another one is a convolution or cellular automaton, also grids
09:42:14 <sm[m]> I am digging all of these refrigeration wizards materialising on the scuttlebutt thread
09:42:15 <EvanR> qqwy: another one is the "store" comonad
09:42:44 <EvanR> some space paired with a location
09:42:55 <qqwy> EvanR: Some kind of 'database' like thing?
09:42:59 <EvanR> also, the non-empty list
09:43:10 <qqwy> How is 'Store' different from the 'Write' monad?
09:43:15 <EvanR> a database with a cursor
09:43:50 <EvanR> Writer builds up a monoid expression on the side
09:44:09 <blankhart> yes, especially if i ever have time for a real raspberry pi project, sm
09:44:30 <EvanR> Store is totally different
09:44:57 <byorgey> electrocat: to sufficiently motivated students, sure.  When I taught it, it only met 1 hour per week.  But there has to be sufficient time to wrestle with the assignments.
09:46:14 * hackage dependency 1.1.0.0 - Dependency resolution for package management  http://hackage.haskell.org/package/dependency-1.1.0.0 (vmchale)
09:55:06 <jakov> @lyxia: Thank you for your help ! Is it correct that the 'xs' in the function definition of "prop_split_inv c xs" can be interpreted as type of Char ? Then it would evaluate to false after applying the (unsplit . split) function.     Or am i completely wrong ?  How should i fix it ?
09:55:06 <lambdabot> Unknown command, try @list
10:05:27 <EvanR> jakov: 'xs' is named as if it were a list, and a Char is not a list, and neither will be considered to be Boolean o_O
10:05:37 <EvanR> three different types altogether
10:08:05 * hackage dhall 1.14.0 - A configuration language guaranteed to terminate  http://hackage.haskell.org/package/dhall-1.14.0 (GabrielGonzalez)
10:11:26 <jakov> Okay. As you have guessed, I am new to haskell, and still have to get the 100% faith to believe the type. What makes the ( unsplit . split) combination return a Char when the output of unsplit is clearly specified as a String ?
10:13:02 <EvanR> i cant get your page to load
10:13:16 <EvanR> what are the types of unsplit and split
10:15:25 <jakov> import Test.QuickCheck
10:15:25 <jakov> import Data.List (intersperse)
10:15:25 <jakov>  
10:15:25 <jakov> split :: Char -> String -> [String]
10:15:29 <jakov> split c [] = []
10:15:32 <jakov> split c xs = xs' : if null xs'' then [] else split c (tail xs'')
10:15:35 <jakov>     where xs' = takeWhile (/=c) xs
10:15:36 <EvanR> oh lord
10:15:38 <jakov>           xs''= dropWhile (/=c) xs
10:15:41 <EvanR> don't page entire files into IRC
10:15:41 <jakov>  
10:15:45 <jakov> unsplit :: Char -> [String] -> String
10:15:48 <jakov> unsplit c = concat . intersperse [c]
10:15:51 <jakov>  
10:15:54 <jakov> -- show
10:15:57 <jakov> prop_split_inv c xs = unsplit c (split c xs) == xs
10:15:58 <jakov>  
10:16:01 <jakov> main = quickCheck prop_split_inv
10:16:01 <EvanR> use a paste site like gist
10:16:04 <jakov> -- /show
10:16:14 <jakov> Sorry. I thought it was short enough
10:16:21 <EvanR> its not
10:16:28 <jakov> got it.
10:17:02 <EvanR> so the result of split is of type (String -> [String])
10:17:10 <EvanR> and unsplit takes a Char
10:17:19 <EvanR> so unsplit . split doesnt have the right type
10:17:38 <EvanR> i mean, the two cant be .-ed together, the input and output types dont match
10:19:15 <EvanR> but split c cs returns a [String], and unsplit c takes a [String], so that makes sense
10:19:24 <EvanR> split c xs*
10:19:30 <jakov> exactly
10:19:42 <jakov> what do you mean by "split c xs*"
10:19:49 <EvanR> i made a typo naming what was what
10:20:11 <EvanR> and _ == _ returns a Bool
10:21:05 <jakov> btw :  https://gist.github.com/JackTheEngineer/78127defe3196d70d811b6e50d28a15a
10:23:19 <lyxia> This is the link BTW https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing
10:23:34 <EvanR> i wonder why that wasnt loading earlier...
10:29:26 <Looan> https://tinyurl.com/ya79dnx5
10:29:28 <lyxia> jakov: why did you think (unsplit . split) or whatever correct variant of that returns a Char?
10:30:23 <jakov> Because the test says          *** Failed! Falsifiable (after 3 tests and 2 shrinks):
10:30:23 <jakov> 'a'
10:30:23 <jakov> "a"
10:31:07 <lyxia> What is printed is not the output of unsplit.
10:31:32 <lyxia> It's the inputs of prop_split_inv that make it return False.
10:38:17 <jakov> Oh, thank you. That was a fault in my implementation. Thank you very much !!!
10:50:27 * hackage dhall-nix 1.1.4 - Dhall to Nix compiler  http://hackage.haskell.org/package/dhall-nix-1.1.4 (GabrielGonzalez)
10:51:19 * hackage dhall-json 1.2.0 - Compile Dhall to JSON or YAML  http://hackage.haskell.org/package/dhall-json-1.2.0 (GabrielGonzalez)
10:54:11 * hackage dhall-bash 1.0.13, dhall-text 1.0.10 (GabrielGonzalez): https://qbin.io/happen-german-ugps
10:56:34 * hackage bytestring-encodings 0.2.0.1 - checks to see if a given bytestring adheres to a certain encoding  http://hackage.haskell.org/package/bytestring-encodings-0.2.0.1 (chessai)
11:08:38 <biglambda> If I do a cabal new-build and I have profiling: True in my .project file I should be able to cabal new-run with +RTS -p
11:08:48 <biglambda> Or am I missing on part.
11:08:54 <biglambda> *one
11:09:03 <biglambda> maybe in .cabal…
11:10:27 <Welkin> you add that to ghc-options
11:10:40 <biglambda> I’m still getting cabal: the flag -p requires the program to be built with -prof
11:46:29 <Profpatsch> How come Control.Category’s >>> is infixr 1 in Haskell and infixr 9 in Purescript?
11:47:06 <Welkin> because purescript is not haskell
11:47:45 <Profpatsch> Welkin: Duh
11:47:56 <Profpatsch> Yes it is (in that context)
11:48:12 <Profpatsch> The fixity logic is exactly the same afaik
11:48:25 <Profpatsch> And the operator zoo as well
11:49:13 <Profpatsch> In Purescript this means you can do  foo >=> bar >>> baz >=> …
11:49:18 <Profpatsch> Which is quite nice.
11:49:46 <Profpatsch> Ah, sorry, that’s bs, that works in Haskell as well.
11:49:59 <Profpatsch> But why the giant difference in fixity?
11:50:21 <Profpatsch> I’d ask in the Purescript channel, but they use slack m(
11:52:20 <blankhart> in purescript isn't it the primary function composition operator, i.e. a replacement for .
11:53:00 <Welkin> that is <<<
11:53:11 <infinisil> :t (<<<)
11:53:12 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
11:53:16 <infinisil> :t (.)
11:53:18 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:53:32 <blankhart> oh of course
11:53:32 <Profpatsch> blankhart: Right
11:53:49 <Profpatsch> There is no specialized <<< in Purescript
11:53:57 <Profpatsch> <<< is in Semigroupoid
11:54:43 <Profpatsch> The >=> >>> >=> chaining is quite the cute trick https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Sugar.hs#L55
11:55:00 <Profpatsch> Makes for awesome pipelines.
11:55:29 <infinisil> :t (>=>)
11:55:30 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:55:39 <infinisil> :t join
11:55:41 <lambdabot> Monad m => m (m a) -> m a
11:55:48 <Welkin> I think its ugly
11:56:35 <Profpatsch> edgy
11:57:00 <Profpatsch> Sorry, edgeeey
11:57:27 <Franciman> Hi
11:58:00 <Welkin> Control.Category.. is infixr 9, just like the (.) from prelude
11:58:09 <Welkin> <<< is infixr 1
11:58:10 <biglambda> If you enable profiling: true in a newstyle build, where does it put the profiling output?
11:58:30 <Welkin> I don't know why, but I never use the <<< ones
12:01:31 <Welkin> what is with all the people joining with names that look like random sequences of letters?
12:01:54 <capisce> all the good names are taken
12:02:06 <electrocat> naming things is the hardest thing
12:02:16 <Welkin> capisce: are you, talkin' to me?
12:02:34 <electrocat> i spend a lot more time than i'd like to admit trying to name concepts
12:03:01 <electrocat> biglambda: shouldn't it tell you when you do the build?
12:03:11 <capisce> Welkin: yes, you clearly took one of the best names
12:04:51 <blankhart> I know more than Apollo,
12:04:53 <blankhart> For oft, when he lies sleeping
12:04:55 <blankhart> I see the stars at bloody wars
12:04:57 <blankhart> In the wounded welkin weeping;Y
12:05:02 <biglambda> electrocat: searching through the build output, I don’t see anything about that, where is it normally printed?
12:05:06 <fakenullie> I've just realized that azure is sky
12:06:27 <infinisil> Hey, what's an alternate prelude you can recommend?
12:06:36 <Welkin> none
12:06:40 <Welkin> just use the normal one
12:06:43 <biglambda> Here’s my .project file
12:06:44 <electrocat> biglambda: it should say Linking <executable> ...
12:06:45 <biglambda> https://lpaste.net/4105240753536499712
12:07:27 <electrocat> or do you mean the output of the profiling dat?
12:07:29 <electrocat> data*
12:07:31 <Welkin> if you really need something other than the normal prelude, you will write a wrapper yourself anyway
12:07:49 <Welkin> simply importing prelude and hiding what you don't want
12:07:49 <infinisil> Yeah I won't do that
12:07:57 <biglambda> electrocat: Yes.
12:08:10 <electrocat> building with profiling does not perform profiling
12:08:17 <infinisil> Yeah of course I could do that, but I'm asking if people have tried an alternate prelude and liked it
12:08:25 <Welkin> I have tried ones
12:08:29 <Welkin> I don't reccomend any
12:08:33 <davean> infinisil: Control.Lens is decent
12:08:48 <electrocat> biglambda: it just puts the profiling intrumentation in place
12:09:03 <infinisil> davean: So the lens package?
12:09:10 <biglambda> Is see I tried new-run with +RTS -p but I get
12:09:10 <biglambda> cabal: the flag -p requires the program to be built with -prof
12:09:12 <Welkin> if you don't even know what you want, how can you choose an alternative prelude?
12:09:25 <Welkin> if you knew, you would make one yourself
12:09:33 <davean> infinisil: It mostly supplants the prelude, so yes
12:09:41 <electrocat> biglambda: because it passes the +RTS to cabal instead maybe?
12:09:46 <electrocat> try running it directly
12:09:52 <davean> But Welkin isn't wrong
12:10:02 <davean> if you don't know what you want, then you're going about this all wrong
12:10:04 <infinisil> davean: I haven't used lens at all actually, I should really get into that
12:10:30 <biglambda> Hmm… I’m putting it in cabal config now
12:10:45 <infinisil> Yeah I don't know what I want, I just thought about checking out some alternate basic packages and how they differ to the normal prelude
12:13:55 <biglambda> Actually screwed up the linker symbols :) ....
12:22:49 <biglambda> Ok, got it compiling with these ghc-options https://lpaste.net/1874918980376854528
12:22:56 <biglambda> Still no profiling output
12:25:28 <biglambda> Switching back to old style building for now.
12:25:48 <crestfallen> hi please see textbook question on line 29. I'm having trouble seeing how my guess - commenting out line 34 - causes 'solve' to not terminate. https://gist.github.com/varreli/07fcc841c73f59e308a603082a75558f
12:27:16 <crestfallen> Is that even the right solution or is it a coincidence that without line 34 we have the same behavior?
12:31:22 <crestfallen> this program is getting too large for me to keep track of.
12:32:16 <crestfallen> module ShowExpression is here https://ptpb.pw/8RFE
12:35:27 <HaskellLord69> You you run this through ghci?
12:35:35 <HaskellLord69> Have you*
12:37:00 <crestfallen> you talkin to me ?  :)
12:37:16 <crestfallen> taxi driver HaskellLord69
12:37:54 <crestfallen> I ran this through ghci its slow but does run
12:38:31 <crestfallen> ie before the commenting out of line 34
12:44:08 <Guest96211> hey
12:45:03 <crestfallen> Guest96211, ping
12:45:26 <crestfallen> quiet here I'm a beginner
12:45:56 <infinisil> crestfallen: You're being rude
12:46:07 <Guest96211> Why ping me cresfallen
12:46:45 <crestfallen> infinisil, why ? really I was just saying hey back to them. please don't think I'm rude
12:47:09 <infinisil> "quiet here I'm a beginner" <- That sounds rude
12:48:40 <crestfallen> infinisil, why I said I'm a beginner because I didn't want Guest96211 to think I would be able to help. why do you think that's rude? I'm very sorry.
12:50:29 <crestfallen> It was a misunderstanding. I was hoping to get a response to my question and I thought someone had asked me something "did you run that through ghci?" then I didn't hear back so I said it was quiet. do you see infinisil
12:50:52 <crestfallen> very sorry
12:50:55 <infinisil> Ah I see
12:51:07 <iron_houzi> I could really need some help with my design to understand how to utilize haskell in the best possible way. I am parsing latin strings to Tibetan unicode: https://github.com/ironhouzi/hstib/blob/typing/src/Main.hs. The "lexer" parses the string to a [Letter] and I was hoping to use pattern matching on [Letter] to derive correct generation of unicode. Say matching [Ka, Ya, A, Nga] as [Subscribed, Subscriber,
12:51:09 <iron_houzi> Vowel, Suffix], would be perfect, but I don't know it its possible to do in Haskell..
12:51:11 <iron_houzi> ..what's even more complicated is that there are 4 different letters that can be classified as Subscriber, but there are different sets of Subscribed for each of the four Letters in the Subscriber set..
12:51:19 <infinisil> Yeah it sounded like "You be quiet here, I'm a beginner, people should reply to me"
12:51:37 <infinisil> crestfallen: All cool now, misunderstanding :)
12:51:48 <iron_houzi> I'm porting this from Python and I see that I'm quickly departing from what I feel is idiomatic Haskell, so I could really use som input to understand how to solve this idiomatically
12:53:36 <crestfallen> sorry yeah I was lazy in the way I posted that. typically I'm careful to write well.
12:56:07 <infinisil> iron_houzi: Can you maybe write down a detailed description of how it would work? It's hard to help just by your short description
13:00:33 <redrapscallion> so I'm looking at this snippet : https://lpaste.net/7650346178864742400 and I'm not sure why that ++ is valid between two Just monads
13:01:10 <iron_houzi> Not sure how to do that without writing a few pages on it.. Basically, if I have types A, B, C, D, E, F and some class of types named Foo where A, B, C are classified as a Foo, and D, E, F is classified as a Bar. Then I was hoping I could pattern match on the classifications. Is that possible to do in Haskell?
13:02:25 <redrapscallion> > Just "Hello" ++ Just "World"
13:02:27 <lambdabot>  error:
13:02:27 <lambdabot>      • Couldn't match expected type ‘[a]’
13:02:27 <lambdabot>                    with actual type ‘Maybe [Char]’
13:02:37 <kaol> redrapscallion: It's not between two Maybe Strings but Strings. (>>=) unwraps them.
13:03:19 <infinisil> iron_houzi: You can write a function that does the mapping from `Letter -> Class`, then pattern match on the Class
13:04:01 <iron_houzi> infinisil: Interesting, does that pattern have a name, so I can google it and see some examples?
13:04:19 <iron_houzi> You can pattern match on functions?? That's super dope!
13:04:25 <infinisil> Ah no
13:04:59 <infinisil> `let class = letterToClass letter; in case class of Foo -> ...; Bar -> ...`
13:14:35 <redrapscallion> kaol: so if I understand correctly, those lambdas only exist to pull the string out of the Just monad so that we can combine the strings together with ++?
13:15:15 <blankhart> iron_houzi, you may be looking for ViewPatterns extension
13:15:31 <redrapscallion> kaol: is there a shorter way to do it? (without using do notation)
13:20:05 <hpc> > (++) <$> Just "hello" <*> Just "world"
13:20:07 <lambdabot>  Just "helloworld"
13:24:06 <marvin3> another way:
13:24:12 <marvin3> > liftA2 (++) (Just "hello") (Just "world")
13:24:14 <lambdabot>  Just "helloworld"
13:32:20 <crestfallen> hi again my question regards lines 83 to 89. I'm not sure how removing the wildcard list [_] causes non-termination in the main function solve. So far I can only see that there would be more pairs. I also don't know if removing line 88 is the correct solution or if its a coincidence that its non-terminating. I became overwhelmed with this program and can't think straight. https://gist.github.com/varreli/07fcc841c73f59e308a603082a75558f
13:35:27 <noan> Is there something severely wrong with me if I'm tempted to write my own damn abstraction over SDL2 instead of helm?
13:37:50 <crestfallen> better paste here: https://lpaste.net/3517523630684635136
13:38:27 <crestfallen> I can't load lpaste sometimes
13:54:32 <redrapscallion> > (Just $ Just "Hello") >>= id
13:54:35 <lambdabot>  Just "Hello"
13:54:46 <redrapscallion> why does this work? id is not a (a -> m b)
13:55:11 <peutri> yes it is
13:55:24 <peutri> for a = m b
13:56:30 <infinisil> :t (>>= id)
13:56:31 <lambdabot> Monad m => m (m b) -> m b
13:56:59 <infinisil> :t (>>=)
13:57:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:57:46 <infinisil> With id being the second argument, we have `a = m b`
13:58:08 <infinisil> So >>= :: Monad m => m (m b) -> (m b -> m b) -> m b
13:59:17 <redrapscallion> hmm, it looks like I have a fundamental misunderstanding on type signatures then.
13:59:48 <redrapscallion> I thought that if it was (a -> m b), then that would imply that a is one level less wrapped in m than m b is
14:00:31 <infinisil> a in that case really means any type
14:01:02 <infinisil> And because m is a type level function of kind * -> *, applying it to the type b yields a new type
14:01:23 <infinisil> So both a and m b are just types, and they can be the same
14:23:06 <d34df00d> Hey
14:23:23 <d34df00d> Why TyConI from Language.Haskell.TH might not have anything in the DerivClauses list?
14:24:42 <kaol> > Just "Hello" <> Just "World"
14:24:44 <lambdabot>  Just "HelloWorld"
14:25:22 <c_wraith> d34df00d: I would expect that when the data type doesn't explicitly declare it's deriving anything.
14:25:28 <d34df00d> http://bpaste.net/show/627941b7b9e8
14:25:39 <d34df00d> c_wraith: well, it does I guess, I just pasted the example above.
14:27:39 <c_wraith> hmm.  what version of ghc?
14:27:48 <d34df00d> 8.0.2
14:27:52 <d34df00d> 8.2.2 same thing.
14:28:06 <d34df00d> (from stackage lts-11.9 or smth)
14:28:57 <infinisil> :t (<>)
14:28:58 <lambdabot> Monoid m => m -> m -> m
14:30:52 <c_wraith> d34df00d: That looks like a GHC bug more than anything
14:31:20 <electrocat> Monoid o.O
14:31:35 <d34df00d> c_wraith: so, everything is all right on my side?
14:31:39 <d34df00d> I'd report it then I guess.
14:31:45 <c_wraith> d34df00d: it looks like it to me
14:32:45 <d34df00d> On a slightly related note, I finally went through a lens tutorial last week, and then I wrote something like this for Language.Haskell.TH.Con:
14:32:54 <d34df00d> http://bpaste.net/show/b45c3cd58314
14:32:58 <d34df00d> Does it look like a Prism candidate?
14:35:17 <phadej> that's (affine) traversal
14:35:37 <phadej> Prism would have build :: Name -> Con
14:36:29 <d34df00d> My lens-fu is level 0 at this point, so how's that a traversal?
14:36:57 <phadej> well, that's not anything, but ??? Con Name can be at most Traversal
14:37:37 <infinisil> :i Monoid
14:37:41 <infinisil> Aw
14:38:05 <d34df00d> Right, let's put it another way. Defining a pair of functions like this feels like boilerplate, so is there a way for me to specify the Con <-> Name relationship I want more concisely and, like, once?
14:38:12 <d34df00d> And then use that instead of my conName and updateName?
14:39:18 <phadej> d34df00d: kind of, you can write Traversal directly, like conName f (NormalC n x) = NormalC <$> f n <*> pure x -- etc, but dunno if it's more concise at the end
14:39:39 <d34df00d> If I have to write just one function — that surely is!
14:39:56 <phadej> @src lens
14:39:56 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:40:02 <phadej> :/
14:40:02 <d34df00d> Cause right now the knowledge about this relationship is split between two different functions, and that just feels bad.
14:40:50 <infinisil> @src Lens
14:40:50 <lambdabot> Source not found. Abort, Retry, Panic?
14:41:01 <infinisil> @src foldl
14:41:02 <lambdabot> foldl f z []     = z
14:41:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:41:13 <phadej> d34df00d: http://hackage.haskell.org/package/lens-4.16.1/docs/Language-Haskell-TH-Lens.html
14:41:33 <phadej> http://hackage.haskell.org/package/lens-4.16.1/docs/src/Language-Haskell-TH-Lens.html#line-435
14:41:34 * hackage animate 0.7.0 - Animation for sprites  http://hackage.haskell.org/package/animate-0.7.0 (jxv)
14:42:50 <d34df00d> Right, so it handles GadtC and RecGadtC having multiple names slightly differently.
14:42:57 <d34df00d> Which, I guess, is somewhat reasonable too.
14:43:11 <d34df00d> Though, yeah, I see now why it's rather a Traversal' Con Name.
14:44:22 <d34df00d> Well, I'd rather write a Traversal using this idea, yeah.
14:44:37 <d34df00d> Is there something special for a Traversal that can have either 0 or 1 element?
14:45:15 <phadej> d34df00d: not in `lens`, but in theory yes. http://oleg.fi/gists/posts/2017-03-20-affine-traversal.html
14:45:24 <d34df00d> It shouldn't be a Lens' a (Maybe b), cause updates would be funny and updating code would be able to look like it's not shape-preserving, right?
14:45:53 <phadej> yes, Lens a (Maybe b) is more powerful (it can remove / add `b`)
14:46:06 <johnw> infinisil: hi
14:46:09 <johnw> infinisil: an issue for what?
14:46:11 <infinisil> johnw: Hi!
14:46:12 <d34df00d> Neat, I probably have some understanding of lenses then.
14:46:13 <d34df00d> Thanks!
14:46:23 <infinisil> johnw: Not sure about the context
14:46:24 <phadej> d34df00d: cheers
14:46:36 <johnw> <infinisil:#haskell> Hah, there even is an issue for it: https://github.com/jwiegley/async-pool/issues/7 [06:49:28]
14:47:05 <infinisil> johnw: Ah right, yeah I got an STM error when I tried to use it, which is most likely the same as the one mentioned in the issue, the solution there worked for me
14:47:20 <johnw> so what's on Hackage is still broken?
14:47:32 <infinisil> Hold on, I haven't checked that
14:47:42 <infinisil> I'm using stack, so it might not be the latest hackage version
14:47:58 <johnw> ah
14:48:53 <infinisil> johnw: Hmm.. it does say it's using 0.9.0.2 which is the latest one on hackage
14:49:08 <infinisil> That is with `stack list-dependencies` in the project directory
14:50:41 <johnw> infinisil: ok, I'll reopen the issue
14:51:07 <infinisil> Did you not push a new version with the fix then?
14:51:18 <johnw> Would you be able to afford me a test case that shows the bad behavior, and then the resolution with that change?
14:51:24 <johnw> i pushed the latest version last night
14:51:52 <infinisil> Yeah hold on
14:53:28 <johnw> thanks, then I will resolve the matter today with that test in hand
14:53:46 <johnw> I'm in a "get all my projects passing green on Travis" kick this week
14:54:08 <infinisil> johnw: https://github.com/Infinisil/hashsearch/commit/6d52c27734d442c90cb50a87170840206aecf6a5#diff-f8f3412da88cd4806f23d59fe59ebc3bR22
14:54:42 <johnw> this is your test?
14:54:54 <infinisil> The old version there works, with the change it doesn't
14:55:07 <infinisil> I mean it's not much of a test i guess
14:55:12 <johnw> heh
14:55:16 <johnw> no, not really :)
14:55:26 <infinisil> I just wrote that tool today really sloppily
14:56:06 <infinisil> johnw: Does it not happen for you if you create pool -> create task group -> mapConcurrently ?
14:56:15 <johnw> i haven't tried recently
14:56:37 <infinisil> I guess I could minimize it a bit, see if it still happens with simpler io actions
14:57:19 <johnw> my hero!
15:04:20 <infinisil> johnw: https://github.com/Infinisil/hashsearch/blob/async-pool-stm-failure/src/Main.hs
15:04:27 <infinisil> Error is in the readme
15:04:37 <johnw> you're awesome, will do it in a moment
15:04:51 <infinisil> Nice :)
15:05:15 <johnw> I'm refining my nix GHC env to be consistent with the build expression that get used by Hydra
15:05:17 <johnw> Travis, I mean
15:27:31 <alej> Hi friends, suppose I want to derive a C interface for an arbitrary Haskell library...are there any tools that will get me a decent amount of the way there?
15:28:25 <johnw> I don't know of any
15:28:29 <johnw> not in that direction
15:28:49 <johnw> wouldn't be that hard to write, though, if you're familiar with haskell-src-exts or template-haskell
15:35:01 <alej> I assume exported functions need to be monomorphic?
15:42:51 <maerwald> building documentation for bytestring-builder-0.10.8.1.0 fails?
15:44:46 <maerwald> great, so new-build also fails and no plan can be run
16:24:57 <orzo> Hello, I'm trying to use Data.Data to define the following function, itemStatusNum sch = constrIndex $ toConstr sch
16:25:20 <orzo> This would turn an sch object into an Int depending on which constructor case it is
16:26:46 <orzo> My issue is that some cases involve STM and IO in their subfields and so deriving Data fails.  I'm really only using Data.Data for this one function.  Is there a way to automatically defined Int values for each case without a full instance of Data?
16:42:55 <EvanR> orzo: Generics is a thing. I just pulled it up to see if i could solve your issue, couldnt, but still might be worth looking into
16:43:11 <EvanR> TH can also access data types
16:48:15 <lyxia> https://hackage.haskell.org/package/generic-data-0.1.0.0/docs/Generic-Data-Internal-Meta.html with this Generics library that's (conIdToInt . conId)
16:48:44 <lyxia> I can whip up a self contained example if you want.
16:51:30 <orzo> is that your own package?
16:51:47 <orzo> I'm going to try it out.
16:52:46 <orzo> thanks EvanR too for giving it a go
16:53:19 <lyxia> orzo: it is!
16:55:53 <EvanR> lol... i just discovered poor mans printf
16:56:15 <EvanR> do { whatever; whatever; error (show stuff); whatever } and
16:56:25 <p0a> Hello
16:56:29 <EvanR> error (show stuff) $ f x y z
16:56:41 <p0a> I'm interested in creating a graphical histogram from some values. Is there a way to do that?
17:00:23 <johnw> p0a: gnuplot bindings might be your simplest option?
17:00:56 <p0a> johnw: how do I install those things? I'm a bit confused
17:01:12 <p0a> I tried `cabal install Graphics' but it didn't work. I want to use http://hackage.haskell.org/package/Histogram-0.1.0.2/docs/Graphics-Histogram.html which seems to do what I want
17:01:28 <johnw> this would be the package to use https://hackage.haskell.org/package/gnuplot
17:02:08 <p0a> cool! Thanks
17:02:13 <johnw> i think the main advantage to doing it with gnuplot is that you can get things looking exactly how you want outside of the Haskell program, and then easily make the program generate the gnuplot commands you need
17:02:23 <p0a> god I tried to write something in common lisp, then C++ and now Haskell
17:02:27 <p0a> the Haskell was the best experience
17:03:13 <p0a> for small stuff where the structures involved are complicated it's really great
17:03:51 * hackage numhask-prelude 0.0.4.1 - A numeric prelude  http://hackage.haskell.org/package/numhask-prelude-0.0.4.1 (tonyday567)
17:04:12 <sclv> p0a: also you depend on the pkg, not the module
17:04:33 <sclv> So in your example, not Graphics but Histogram
17:04:42 <sclv> Since thats the pkg name
17:05:23 <p0a> sclv: I don't really understand...
17:05:37 <p0a> sclv: I did `cabal install gnuplot' but I'm not sure what to import now
17:07:27 <p0a> sclv: Okay! I am trying `cabal install histogram' now
17:07:33 * hackage difference-monoid 0.1.0.0 -   http://hackage.haskell.org/package/difference-monoid-0.1.0.0 (oisdk)
17:08:11 <p0a> yeah I just don't get how to use the installed packages.
17:08:12 <p0a> :/
17:10:44 <sclv> note that case matters!
17:10:59 <p0a> yeah but `import Histogram' fails
17:14:18 <orzo> lyxia: do I need to import something from *.Internal.* to use your conIdToInt?
17:15:01 <maerwald> it seems haskell-ide-engine doesn't have "show type for expression"
17:15:02 <maerwald> uh
17:15:18 <maerwald> I can just get the type for an identifier, lol
17:23:32 <p0a> Hm... any help?
17:23:59 <p0a> not sure how to use these packages. I have `cabal install histogram' and `cabal install gnuplot'. How do I import them in my program?
17:26:41 <dyl> p0a: check the hackage package and look at what modules they expose.
17:26:53 <dyl> Then import X.Y.Z and so forth.
17:27:20 <dyl> There are a few different forms of imports: https://wiki.haskell.org/Import
17:29:57 <p0a> dyl: `Graphics.Histogram'
17:30:34 <dyl> Then import that per the above wiki page.
17:31:07 <p0a> Well `import Graphics.Histogram' doesn't work, neither does `import Graphics'
17:31:18 <p0a> ah okay, this time I get it
17:31:28 <p0a> I had to rerun my ghci instance
17:31:42 <p0a> thanks!
17:43:21 <lyxia> orzo: yeah it's only exported from Internal.Meta for now
17:47:12 * hackage ats-pkg 2.10.1.8 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-2.10.1.8 (vmchale)
18:00:36 * hackage sdl2-fps 0.0.2 - Run of the mill, frames per second timer implementation  http://hackage.haskell.org/package/sdl2-fps-0.0.2 (jxv)
18:13:32 <nkhodyunya> Hello
18:26:04 * hackage animate-sdl2 0.1.1 - sdl2 + animate auxiliary library  http://hackage.haskell.org/package/animate-sdl2-0.1.1 (jxv)
18:32:27 <ddellacosta> nkhodyunya: hello
18:43:25 <ph88> is it possible to get the sourcecode line of a type ?
18:47:04 * hackage ats-format 0.2.0.27 - A source-code formatter for ATS  http://hackage.haskell.org/package/ats-format-0.2.0.27 (vmchale)
18:57:37 <redrapscallion> suppose I had this snippet : https://lpaste.net/3774193534878351360
18:57:49 <redrapscallion> without changing the type signature of the function to Shape -> Maybe Float
18:57:59 <pdxleif> Is there like a "get or put if empty" operation for MVars?
18:58:04 <redrapscallion> what other solutions are there for this problem?
18:58:29 <pdxleif> Just thinking of the case where I have one or more pull-based concurrent consumers, but I don't want to run the producer if there are no consumers.
18:59:12 <pdxleif> err, push-based, actually
18:59:20 <redrapscallion> what I'd really like is for it to throw a compile-time error if the Shape isn't a Circle, although I'm not sure how that would work.
19:03:09 <ddellacosta> redrapscallion: my first instinct is that you want to leverage typeclasses somehow here, for example create a `HasRadius` typeclass and use that as a constraint
19:04:15 <ddellacosta> alternatively you could specify each shape as an individual data type--that may simplify things depending on what you want to do
19:04:18 <pdxleif> I guess there's `orElse` in STM
19:08:24 <EvanR> pdxleif: you can poll an MVar, but the results are immediately invalid and useless
19:08:42 <EvanR> TVar gives more flexibility in doing weird shenanigans
19:09:17 <EvanR> "i dont want to run the producer if there are no consumers" sounds somehow super broken
19:09:43 <EvanR> like thats not the producers responsibility to figure out
19:19:13 <pdxleif> I tried "atomically $ readTMVar v `orElse` (tryPutTMVar v 5 *> readTMVar v)", but it always seems to run the second action.
19:19:29 * hackage openpgp-Crypto 0.6 - Implementation of cryptography for use with OpenPGP using the Crypto library  http://hackage.haskell.org/package/openpgp-Crypto-0.6 (StephenWeber)
19:20:07 <pdxleif> It says "takeTMVar" will retry if the TMVar is empty
19:23:30 <ddellacosta> project.cabal configuration question: is there a way to not have to duplicate my build-depends entry in my executable section that I've specified in my library section other than dropping the cabal-version?
19:24:06 <ddellacosta> assuming I'm understanding the note in the docs starting with "Prior to Cabal 1.8, build-depends specified in each section were global to all sections..."
19:24:20 <ddellacosta> under http://cabal.readthedocs.io/en/latest/developing-packages.html#build-information
19:25:14 <pdxleif> Hmm, now it's working.
19:25:22 <ddellacosta> seems like rather than build-depends being global by default, it would be handy to specify some kind of "inherits" kind of thing. Apologies if I'm missing something obvious here--I've been using stack for a while and now I'm trying to get a better handle on cabal
19:27:07 <sclv> ddellacosta: currently there's no way to share stuff
19:27:22 <sclv> however, you only need to depend on stuff in the executable section that is used in the executable
19:27:28 <sclv> so often i have a library that imports a ton of stuff
19:27:32 <sclv> an exe that depends on the library
19:27:42 <sclv> but the exe itself only imports a few things directly
19:27:47 <sclv> so it still has a very slim build-depends
19:28:03 <sclv> (shared sections are coming really soon iirc)
19:29:31 <ddellacosta> sclv: thanks--so to make sure I'm understanding you correctly, let's say my lib Foo imports a, b, and c, each of which corresponds to a library dependency specified in my build-depends in my library section--will I still have to list each of those (a, b, c) in my build-depends in my executable section (where I use Foo)
19:29:59 <sclv> ddellacosta: only if your executable imports modules defined in a,b,c
19:30:08 <sclv> otherwise it just should depend on Foo the library
19:30:15 <sclv> and it gets those deps transitively
19:30:18 <sclv> just like normal
19:30:38 <sclv> note that your executable's Main.hs should be in a different directory than the source directory of your library
19:30:39 <ddellacosta> huh okay--that is what seems natural to me, but I must be doing something weird...oooh I'm using the same source directories for each, that must be it
19:30:46 <ddellacosta> jinx, haha
19:30:47 <sclv> yep!
19:30:52 <sclv> that's an irritating gotcha
19:30:56 <sclv> we should warn better about that
19:31:02 <sclv> feel free to open a ticket on the cabal tracker
19:31:12 <sclv> (you're the second person i've seen get bit by that in the last two weeks)
19:31:18 <ddellacosta> yeah that is what bit me. Okay cool, thanks for that clarification sclv, that was super helpful
19:31:33 <ddellacosta> gotcha yeah, definitely seems like a warning would be handy there
19:33:43 <Lears> So I've got some weird code where `\x -> f (g x)` is accepted and `f . g` triggers a type error from GHC that doesn't look like a type error to me: https://lpaste.net/6204007794383781888
19:33:51 <Lears> Can anyone tell me what's going on?
19:34:52 <ddellacosta> weird, I can't get to lpaste.net right now
19:37:06 <geekosaur> Lears, I suspect that's impredicative types
19:38:58 <geekosaur> basically that "a" is rank-2, and (.) can't typecheck across it. ($) can because of an evil typechecker hack, and the lambda avoids it a different way
19:43:12 <pdxleif> Is there an Oz-style single-assignment variable available as some lib?
19:43:31 <EvanR> theres at least two "IVar" packages
19:44:45 <pdxleif> Nice, thanks
19:45:21 <EvanR> i dont see one called "ivar" written by ekmett so there must be something wrong with the whole concept :)
19:51:25 <Lears> I don't totally understand geekosaur, but I'm reading about impredicative types. It looks like GHC just doesn't have very good support for this kind of construction. The GHC Users Guide's section on the topic suggests newtype wrappers as a workaround, which seems to work here.
19:51:52 <geekosaur> impredicative types are kinda nasty
19:52:20 <geekosaur> but ghc's main problem with thme is nobody has ever bothered to work out what they *should* do, people just expect them to somehow guess what they intended
19:52:48 <infinisil> What are impredicative types?
19:54:12 <geekosaur> a mess
19:54:30 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#impredicative-polymorphism
19:54:56 <geekosaur> (which I can;t load because chrome keeps choking on the new ghc manual and the new hackage/haddock, sigh)
19:55:08 <geekosaur> (which may be a badly behaved extension but I can't debug it)
19:57:27 <sclv> infinisil: a general way to understand impredicative types is that they are types which contain a "forall" inside a type constructor
19:57:37 <infinisil> Interesting
19:57:41 <sclv> so e.g. Maybe (forall a. Show a => a)
19:57:49 <sclv> the problem is just that inference for them is not possible
19:57:55 <Lears> My actual use case is passing around `MyLayoutTransformer l1 l2 l3 l4 Window -> X (Maybe (MyLayoutTransformer l1 l2 l3 l4 Window))`s in such a way that the `LayoutClass ln Window` methods are accessible. Then I can write one Message which can be passed one of these to do arbitrary Message things.
19:57:57 <sclv> there's no "most general unifier" in their presence
19:58:04 <sclv> so you need to make an ad-hoc choice
19:58:11 <sclv> and there's no "good" way to make that choice
19:58:11 <infinisil> Not that I ever felt a need for these impredicative types, but certainly interesting
19:58:34 <sclv> so instead GHC doesn't allow them, and instead just requires you specify a data constructor that _explicitly_ takes something quantified inside
19:58:41 <EvanR> whats impredicative about them
19:58:44 <sclv> which is just as powerful, just slightly more verbose
19:58:49 <sclv> EvanR: therein lies a tale :-/
19:58:57 <sclv> its an old name that goes back to logic
19:59:09 <EvanR> right ive seen that jargon around a lot
19:59:14 <EvanR> not sure how it relates
19:59:17 <sclv> basically a predicative proposition is one that is _predicated_ on some universe
19:59:25 <sclv> so its not over "everything" but over "some set"
19:59:45 <sclv> and the reason you want that, in logic, is if you don't say what you're quantifying over, you're quantifying over everything including, possibly, yourself
19:59:51 <sclv> and then you get russell-style paradoxes
20:00:28 <sclv> or rather a predicative proposition is one in which all quantification is predicated
20:00:56 <sclv> i think i'm getting the story right. so an "impredicative type" is one that has unbounded quantification inside it
20:01:51 <sclv> the etymology tends to confuse more than illuminate here in my experience, though its of historic interest
20:02:28 <sclv> and helps you understand why people also talk about predicative vs. impredicative type theories, even though those don't correspond at all to having impredicative types or not (i know, ugh)
20:02:48 <EvanR> maybe the answer is in van heijenoort
20:09:26 * hackage rainbow 0.30.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.30.0.0 (OmariNorman)
20:15:08 <sclv> I mean... I just gave an abbreviated version of the answer
20:15:18 <sclv> i know its confusing
20:15:21 <sclv> its a confused etymology
20:17:38 <EvanR> thing is i already knew all that, but i still dont get it
20:18:13 <EvanR> will probably take years of study in a darkened forgotten chamber to realize its all nonsense
20:19:50 <EvanR> heres a different question. if you dont enable that extension, can we be sure we are using Predicative Types? :)
20:25:34 * hackage rainbow 0.30.0.2 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.30.0.2 (OmariNorman)
20:27:46 <dmwit> Yes. And even some predicative types are ruled out.
20:28:39 <dmwit> e.g. `data FooTy a where FooTm :: FooTy (forall a. a)` is probably just fine, but ruled out.
20:33:48 <EvanR> that seems wacky
20:34:25 <EvanR> what does it mean to hold a FooTy (forall a . a)
20:34:45 <johnw> i guess given non-strict semantics it's just another unit
20:53:34 * hackage descript-lang 0.2.0.0 - Library, interpreter, and CLI for Descript programming language.  http://hackage.haskell.org/package/descript-lang-0.2.0.0 (jakobeha)
22:09:39 <aka> Is there a standard QuasiQuoter for Haskell syntax? So I can do anti-quotation like "eval [| ($x, $y) |] = (eval x, eval y)"
22:10:13 <johnw> maybe haskell-src-exts has one
22:11:46 <aka> thanks! I will give it a shot
22:14:48 <ddellacosta> what's going on here? https://stackoverflow.com/questions/49167726/cabal-library-cannot-import-exposed-modules --That is, is the example linked to in the question wrong? I had the same problem with a library module not being found in my executable, and solved it in the same way just now. I banged my head against it for a while, basing my cabal file on that example, before I found that SO post.
22:17:25 <cocreature> ddellacosta: the solution already describes what’s wrong, no? you need to add the package to build-depends
22:18:02 <sclv> its a good point that the example's incomplete tho
22:18:07 <ddellacosta> cocreature: sorry, that was probably a confusing way for me to word it: my question is about the example given in the cabal docs; similarly to the SO poster, I followed that example and couldn't figure out why it wasn't working
22:18:16 <ddellacosta> sclv: btw, thanks for filing this! https://github.com/haskell/cabal/issues/5335
22:18:18 <sclv> or rather, it shows the different stanzas, but not the obvious pattern
22:18:26 <sclv> (i added a comment on the docs to that issue too)
22:18:33 <ddellacosta> oh great, thanks
22:27:18 <wz1000> sclv: did you see my messages on #haskell-ide-engine?
23:16:04 * hackage etc 0.4.0.1 - Declarative configuration spec for Haskell projects  http://hackage.haskell.org/package/etc-0.4.0.1 (RomanGonzalez)
23:17:15 <LeelooMinai> Anyone alive?
23:17:33 <masticass[m]> Yep. :)
23:17:55 <LeelooMinai> Human?
23:18:10 <EvanR> half elf
23:18:47 <LeelooMinai> Don't even know how to write it, but, did anyone notice something strange?
23:18:53 <masticass[m]> I guess. Last time I checked I still was. x)
23:19:14 <EvanR> no
23:19:27 <masticass[m]> Something strange about what?
23:20:03 <LeelooMinai> I guess I am gone anyways: something strange with people/society + internet
23:20:35 <EvanR> related to haskell?
23:21:02 <LeelooMinai> Yes, no, I don't know?  How am I supposed to answer this question...
23:21:58 <LeelooMinai> I am not trolling -need help.
23:22:06 <fnurglewitz> with haskell?
23:22:20 <masticass[m]> "I guess I am gone anyway?" What do you mean? It depends on what field, if you mean computer science in general I didn't notice anything weird, if you're wondering about the paranoia that's going on in Europe and basically everywhere with the facebook mess. I have noticed some odd behaviors yes. But this is a Haskell related chatroom bud.
23:22:21 <LeelooMinai> No, with what I asked initially.
23:22:43 <masticass[m]> "Anyone alive?" you mean?
23:22:49 <LeelooMinai> I am a programmer myself. Or at least I was.
23:23:05 <LeelooMinai> But there's something wrong.
23:23:52 <LeelooMinai> And there are two choices: I am insane or there's something wrong.  Either way. I cannot do anything but ask for help.
23:24:02 <fnurglewitz> yeah, I know that feeling, weak/dynamic typing `are coming outta the goddamn walls!`
23:24:24 <LeelooMinai> No, I can think logically.
23:24:56 <LeelooMinai> Well, I guess if I am insane this doesn't mean anything.
23:25:23 <masticass[m]> I don't get where you're going at honestly. If it's depression then it's normal. Just get your mind and hands on a project.
23:25:48 <LeelooMinai> Depression - I wish... I can deal with depression.
23:25:59 <LeelooMinai> There's something wrong with how people behave.
23:26:14 <LeelooMinai> At least from my point of view.
23:26:34 <LeelooMinai> And I even tried to test if I have schizophrenia...
23:26:54 <LeelooMinai> But that's kind of ridiculous... I cannot test myself.
23:27:23 <EvanR> LeelooMinai pass this turing test
23:27:44 <LeelooMinai> Right... exactly...
23:27:49 <EvanR> you have 3 tries
23:28:06 <LeelooMinai> It's the problem - people do not pass my Turning Test...
23:28:16 <LeelooMinai> Turing I guess
23:28:27 <EvanR> hmm
23:28:46 <LeelooMinai> EvanR: It's an infinite regress
23:28:52 <masticass[m]> Mate. At least spell it correctly.
23:29:17 <LeelooMinai> I find this comment absurd, considering.
23:30:26 <LeelooMinai> And as always... silence...
23:30:57 <LeelooMinai> It must be one of those "deafening silences"
23:32:07 <LeelooMinai> I cannot distingush you from AI and you cannot distinguish me from AI or other troll.
23:33:15 <LeelooMinai> The irony - one of the first things I observed that people have less and less capability to communicate.
23:33:21 <EvanR> i can distinguish on topic from off topic
23:33:39 <LeelooMinai> Yes, but you are not communicating with me.
23:34:17 <LeelooMinai> It's like humans are not humans any more.
23:35:04 <LeelooMinai> When I entered IRC 30 years ago - there were less people/bots per channel, but this situation would not happen.
23:35:23 <LeelooMinai> Which kind of proves my point. And it's both ridiculous and scary.
23:35:28 <EvanR> must be the tomorrow people
23:36:04 <EvanR> I'm saying that random banter goes in a different channel
23:36:21 <EvanR> this one is reserved for serious haskell discourse
23:36:23 <LeelooMinai> You are proving my point.
23:36:36 <EvanR> super serious
23:36:47 <LeelooMinai> I am even more super sserious.
23:37:22 <LeelooMinai> Are you human?
23:38:15 <LeelooMinai> You are not - human would answer.
23:38:18 <LeelooMinai> \part
23:38:27 <woodson> you need to rest man
23:38:33 <woodson> oh he left...
23:38:44 <masticass[m]> Well. That's over.
23:39:24 <woodson> Does this happen often here ? I only use IRC for #haskell
23:39:35 <woodson> and its my first time seeing this
23:40:02 <masticass[m]> Can't tell. I have only just joined.
23:40:03 <EvanR> weird people are on the internet
23:40:08 <[exa]> like a massive offtopic? yes.
23:40:16 <EvanR> been that way for a while now
23:41:00 <woodson> EvanR: Now, I can't even tell if he was trolling or serious.. Got me worried for him
23:41:04 <woodson> geez..
23:41:51 <[exa]> woodson: he obviously needed to get rid of the computer for some time, which I guess was achieved
23:42:24 <masticass[m]> If the dude was having a rough time the best place for him to find answers to his problems would be a psychologist and if he can't afford one even Yahoo Answers would be a better place than an Haskell related chatroom.
23:43:23 <[exa]> yahoo answers :D
23:43:39 <woodson> Ya.. but I dont think that trouble people can think in this order ...
23:43:55 <EvanR> lol
23:44:22 <EvanR> perhaps yahoo billiards
23:44:40 <[exa]> I seriously hope for his good that he gets to wikihow, follows some illustrated howto there and finds a new meaning in the work
23:45:27 <woodson> ya..
23:45:38 <woodson> How about I switch this up..
23:45:43 <woodson> anyone familiar with ghcjs?
23:45:47 <[exa]> :D
23:46:04 <woodson> can seem to find anyone to help me with something on #ghcjs or #reflex-frp
23:46:08 <woodson> maybe timezone...
23:46:26 <[exa]> maybe because you ask to ask. :]
23:46:47 <[exa]> but yes, ghcjs is sometimes blackmagicky so I guess answers are sparse
23:47:06 <[exa]> what's the problem?
23:47:33 <woodson> I am import a third part js library in my project js-yaml
23:47:44 <woodson> and when I try to compress with closure compiler
23:48:04 <woodson> and load it in the browser
23:48:07 <woodson> I get this errorr "TypeError: c[g] is undefined"
23:48:37 <woodson> I've also defined an extern file for it and passed it to the closure compiler
23:48:57 <woodson> so, I am out of options not suure what could be the issue
23:49:19 <[exa]> does js-yaml fail even separated from the rest of ghcjs after being closure-compiled?
23:50:03 <[exa]> also, if it works before compression, it would mean there's an issue with the closure compiler.
23:50:30 <woodson> it works before closure compiler
23:50:40 <woodson> so, if I just use the all.js everything is fine
23:51:56 * EvanR leaves a haskell related chatroom and goes to sleep
23:51:57 <woodson> I am 100% sure that its closure compiler just not sure how to get  it to work and the error does tell me much ... welll of course that something is not defined
23:52:01 <woodson> but ya..
