00:01:41 <dminuoso> On a scale from 1 to 10, how nasty would it be to have some function `a -> Maybe a` that uses unsafePerformIO with `catches`?
00:02:19 <tdammers> dminuoso: use case, please?
00:03:09 <dminuoso> tdammers: Earlier I had the problem of writing a library, where a user has to provide some `IP` which sadly has some unsafe methods of construction.
00:03:36 <dminuoso> Now I can address this with strictness, but in certain cases that might not be possbile.
00:04:16 <tdammers> so what would you be doing inside the unsafePerformIO?
00:05:19 <dminuoso> tdammers: f x = unsafePerformIO $ (x `pseq` Just x) `catch` const (return Nothing)
00:05:22 <dminuoso> Something along those lines
00:06:09 <dminuoso> I have no specific use case for this, it's just a hypthetical scenario at this point.
00:06:48 <cocreature> I would just add extra validation before cnostructing the IP instead of trying to catch the exception
00:07:31 * Axman6 would at least like to see a NFData constraint on a
00:08:01 <cocreature> you also don’t want to catch all exceptions
00:08:18 <dminuoso> Right, because it might catch async exceptions right?
00:08:21 <cocreature> so it’s probably better to make a specific function for the type you care about rather than a generic a -> Maybe a
00:08:24 <cocreature> yep
00:08:56 <cocreature> for the generic case there is the "spoon" package but given that it just catches everything I wouldn’t recommend it
00:10:26 <Ariakenom> I don't quite get the error-panic difference in protolude
00:10:28 <dminuoso> It could be so cool if I could put an unlifted constraint on the data somehow
00:10:50 <cocreature> Ariakenom: "panic" is the same as "error". panic is just a better name for it :)
00:11:06 <dpyro> I'm getting an infinite loop when i do `length m` where m is a Data.HashMap.Strict ... is there anyway to figure out why?
00:12:59 <dminuoso> dpyro: You could use `-fbreak-on-error`, run your expression through `:trace` in GHCi and interrupt in the loop?
00:13:22 <dpyro> well there's no error, it just eats up 100% CPU
00:13:44 <dminuoso> dpyro: the flag is just so when you use ^C that it breaks with the debugger
00:13:52 <dpyro> ooo
00:15:32 <kuribas> A monoid is a cathegory of a single element.  So then for a haskell "Monoid a", that single element would be the type "a", and the morphisms the values of a?
00:16:11 <dminuoso> kuribas: It depends on the perspective. A monoid can also be considered a category in which every object has a unique morphism going to every other object
00:16:20 <Ariakenom> cocreature: So error,undefined are intended as dev time only
00:16:45 <dminuoso> (or conversely a category is a monoid in which not all the morphisms compose)
00:17:47 <kuribas> dminuoso: right, so every single object cathegory is a monoid, but the inverse is not true?
00:17:57 <dminuoso> kuribas: Correct
00:18:08 <kuribas> dminuoso: also, isn't composition required for all cathegories?
00:18:36 <dminuoso> kuribas: that was somewhat poorly phrased, let me try again
00:21:03 <Ariakenom> Might work out. But the difference in intention between basically the same thing wasn't exactly clear. error now gives warnings! but also we added panic which is error
00:21:47 <tdammers> dminuoso: I'm with cocreature here - validate beforehand instead of resorting to this kind of black magic
00:22:15 <dminuoso> kuribas: In one perspective the difference between a monoid and a category is that in a category morphisms only compose if their endpoints match. In a monoid any would compose.
00:23:10 <dminuoso> kuribas: If you represent that inside a category, then you'd have a single element with a bunch of endomorphisms. Each morphism represents an element of your monoids set, with id being 0
00:24:03 * hackage hasql-optparse-applicative 0.3.0.3, hasql-optparse-applicative 0.3.0.2 (NikitaVolkov): https://qbin.io/empty-data-yb85
00:24:52 <dminuoso> kuribas: So yes.
00:26:18 <kuribas> dminuoso: but then in a multi object monoid, different arrows would represent the same function?
00:26:25 <kuribas> dminuoso: or are they the same arrow?
00:26:41 <kuribas> dminuoso: like 4 -> 6, 5 -> 7
00:26:59 <dminuoso> kuribas: Mm forget I said that.
00:27:27 <kuribas> dminuoso: they are the same function obviously
00:29:49 <kuribas> dminuoso: now I am a bit confused
00:30:10 <dminuoso> kuribas: My apologies.
00:31:07 <kuribas> np :)
00:32:33 <kuribas> this also confuses me: https://en.wikipedia.org/wiki/Monoid_(category_theory)
00:33:00 <kuribas> if a monoid is an object M, how can the morphism µ be from MxM -> M?
00:33:23 <kuribas> I thought morphisms are only on objects inside a cathegory?
00:33:42 <dminuoso> kuribas: It talks about a monoidal category
00:34:00 <edmundnoble> Multi-object monoid == category
00:34:47 <edmundnoble> A morphism from MxM -> M is a way of talking about monoids inside a monoidal category, where the "monoidal operation" is "x" there.
00:34:53 <dminuoso> kuribas: Which means your category is equipped with a bifunctor (your binary associative operation) and a respective identity (up to a natural iso)
00:35:04 <kvothe> how do you catch multiple exceptions of different types?
00:35:10 <dminuoso> kvothe: catches
00:39:30 <kuribas> dminuoso: then isn't MxM -> M identity?
00:40:05 <kuribas> dminuoso: for example "a" ++ "b" == "ab", so "a"x"b" -> "ab" == "ab" -> "ab"
00:41:56 <cocreature> Ariakenom: yep
00:42:17 <dminuoso> kuribas: Think of a bifunctor as a functor with two arguments
00:44:56 <kuribas> dminuoso: ah right, so a bifunctor is a mapping between a product cathegory and a cathegory.
00:44:59 <dminuoso> Right
00:45:11 <kuribas> then what is MxM ?
00:46:19 <Cale> category doesn't have an h in its name in English
00:46:34 <kuribas> right
00:47:44 <Cale> kuribas: Sorry, I missed some context, what are you asking about?
00:47:51 <dminuoso> kuribas: Its a product category
00:48:37 <kuribas> dminuoso: or wait, for strings MxM would be the result of concatenation, then µ is the identity morphism?
00:48:38 <Cale> If M is meant to be an ordinary monoid in the category of sets, and the function M x M -> M is meant to be multiplication, then x is the Cartesian product of sets
00:49:08 <Cale> i.e. A x B = {(a,b) : a in A and b in B}
00:49:40 <dminuoso> kuribas: In Hask one monoidal category would be using (:.:) which composes two functors into a single functor
00:49:40 <Cale> Or is this somehow not what we're talking about?
00:49:49 <kuribas> Cale: well, I am refering the the x inside a circle on https://en.wikipedia.org/wiki/Monoid_(category_theory)
00:49:59 <dminuoso> kuribas: Like I said. Thats the symbol for product category
00:50:09 <dminuoso> kuribas: Its a generalization of the cartesian product for categories.
00:50:12 <Cale> The definition of the tensor product depends on the choice of monoidal cateogry
00:50:15 <Cale> category*
00:50:37 <kuribas> dminuoso: but µ is a morphism in M, and MxM isn't in M
00:50:42 <Cale> It's just something which satisfies particular conditions, and there are lots of examples of operations on objects of various categories which meet those conditions
00:50:49 <Cale> You need to say what you mean in each instance.
00:51:07 <Cale> So, for example in the category of sets, the usual choice is Cartesian product.
00:51:12 <dminuoso> kuribas: Dont rush. We're not in the monoid yet, we're talking about the monoidal category.
00:51:27 <Cale> In the category of vector spaces over a given field, it might literally be the tensor product of vector spaces.
00:52:01 <kuribas> right
00:52:03 <dminuoso> kuribas: a monoidal category is a category equipped with a certain bifunctor
00:52:09 <Cale> In a type theory, it would probably be the product type
00:52:48 <Cale> For the category of functors from a given category to itself (and the natural transformations between them), it might be functor composition
00:53:14 <Cale> (it could also be the product of functors, if the category has products)
00:53:28 <Cale> It's important to specify
00:53:44 <dminuoso> kuribas: when we make that boring joke "monads are just..." then our category is the category of endofunctors, in which each object its an endofunctor and morphisms are natural transformations.
00:53:46 * ventonegro scrolls up
00:54:05 <dminuoso> kuribas: To tell the joke right you'd say "a monad is a monoid in the monoidal category of endofunctors, which is equipped with functor composition for its bifunctor"
00:54:20 <kuribas> dminuoso: yeah :)
00:55:27 <dminuoso> kuribas: (And curiously you can tell the same joke with Applicative, just with a different bifunctor)
00:55:42 <kuribas> dminuoso: for the String type, what does M (x) M mean?
00:56:00 <dminuoso> kuribas: Wait. What category are you thinking of?
00:56:08 <kuribas> the String monoid
00:56:12 <dminuoso> No which category
00:56:19 <kuribas> hask I suppose
00:57:16 <kuribas> erm no, the cathegory of the single object String, with morphisms String -> String, if that makes sense?
00:57:55 <dminuoso> Cale: Are single object categories interesting here?
01:00:28 <Cale> Not usually...
01:00:40 <dminuoso> kuribas: Consider the category of Endofunctors in Haskell. You'd have some objects like `Maybe` or `[]`. There's some natural transformations like `maybeToList` in there.
01:00:52 <dminuoso> Those act as morphisms between your objects
01:01:03 * hackage hadolint 1.6.6 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.6.6 (lorenzo)
01:01:49 <dminuoso> kuribas: If you want a monoidal category, it means you need a bifunctor that acts on your category Ef: (Ef x Ef -> Ef). So that bifunctor takes any pair of objects (endofunctors), and maps them to a new endofunctor
01:02:03 <dminuoso> It also takes any pair of natural transformations, and maps them to some natural transformation.
01:02:21 <kuribas> dminuoso: you mean (Maybe a) ?
01:02:27 <dminuoso> kuribas: No `Maybe`
01:02:33 <dminuoso> kuribas: Maybe itself is the Functor.
01:02:38 <dminuoso> not (Maybe a)
01:04:25 <dminuoso> kuribas: So that bifunctor needs to be able to combine two functors into a single functor (satisfying some laws). One way to do this, is to _compose_ them (which satisfies the necessary laws)
01:04:56 <kuribas> yes
01:05:53 <dminuoso> kuribas: Now there's some choice for object/morphism that acts as an identity (up to natural iso) wrt to that composition.
01:06:19 <dminuoso> The composition is usually denoted :.: in Haskell (you can write that type operator if you like)
01:06:50 <dminuoso> So `Maybe` can be composed with say `IO` to: `Maybe :.: IO`. What you get back is again a functor
01:08:19 <kuribas> so Compose ?
01:08:29 <kuribas> :t Compose
01:08:31 <lambdabot> error:
01:08:31 <lambdabot>     • Data constructor not in scope: Compose
01:08:31 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
01:08:37 <makalu> in c++ I can throw runtime_error if I just need an exception that's printed out and has no special semantics. Is there a basic exception type in haskell I can use without defining a new type? I have used ioError . userError but it adds stuff to the string.
01:08:42 <AWizzArd> I would like to build a little EDSL, supporting literals, vars, and/or/not and function calls. And I wanted to ask how calls are best modelled in Haskell.
01:08:45 <AWizzArd> Should I have something like data Expr arg1 arg2 arg3 outType = .. | Call1 (arg1 -> outType) | Call2 (arg1 -> arg2 -> outType) | Call3 (arg1 -> arg2 -> arg3 -> outType) | ..   ?
01:08:56 <dminuoso> kuribas: Yes.
01:09:04 <kuribas> dminuoso: right, I get it :)
01:09:22 <dminuoso> kuribas: So now the monoidal category has some additional requirements (which should sound familiar from the monoid)
01:09:45 <dminuoso> kuribas: That bifunctor has to be associative (up to a natural iso), and have an identity (up to a natural iso)
01:10:10 <Boomerang> AWizzArd: Why don't you just model a function call with 1 argument when then if you need more than one, you curry the function calls
01:10:13 <dminuoso> kuribas: Can you think of a functor that acts as an identity for functor composition?
01:10:22 <dminuoso> (up to an isomorphism)
01:10:28 <kuribas> Indentity?
01:10:31 <dminuoso> Right.
01:10:49 <kuribas> ah cool
01:11:16 <AWizzArd> Boomerang: hmm, so just  data Expr a = .. | Call a | ..
01:11:38 <AWizzArd> And then create a call via `Call someFn`?
01:13:06 <dminuoso> kuribas: Now generally you'd call that choice of object `I`
01:13:32 <dminuoso> kuribas: Because we're looking at the category of endofunctors `I` (just like every object) happens to be an Endofunctor.
01:14:35 <dminuoso> kuribas: Now a monoid inside that monoidal category is a single object `M` equipped with two morphisms: μ: MxM -> M and η: I -> M
01:14:59 <kuribas> dminuoso: how do you know this stuff?  Are you a mathematician?
01:15:15 <dminuoso> kuribas: In our category that means `η: (M :.: M) -> M` and `η: Identity -> M`
01:15:23 <kuribas> right
01:16:01 <dminuoso> :t join
01:16:03 <lambdabot> Monad m => m (m a) -> m a
01:16:09 <Boomerang> AWizzArd: No you would need two arguments to apply the function, something like "add 1 2" you could model it as "App (App (Var "add") (Lit 1)) (Lit 2)"
01:16:20 <dminuoso> kuribas: If you rewrite that as: `join :: (m :.: m) a -> m a`
01:16:22 <dminuoso> :t return
01:16:24 <lambdabot> Monad m => a -> m a
01:16:35 <dminuoso> kuribas: and that as: `pure :: Identity a -> m a`
01:16:44 <dminuoso> kuribas: You'll see the monoid emerge.
01:16:47 <kuribas> dminuoso: but that's a monad?  Oh wait...
01:16:51 <Boomerang> Or with an infix form: Var "add" `App` Lit 1 `App` Lit 2
01:17:25 <kuribas> dminuoso: ah cool, you explained the "haskell joke" :)
01:17:42 <dminuoso> kuribas: Note that you still require some commuting diagrams
01:17:53 <dminuoso> That is the mere signatures are not enough.
01:17:58 <dminuoso> You have to follow some additional laws
01:19:24 <dminuoso> https://upload.wikimedia.org/wikipedia/commons/b/b1/Monoid_mult.png
01:19:25 <dminuoso> https://upload.wikimedia.org/wikipedia/commons/1/10/Monoid_unit.png
01:19:30 <dminuoso> Which are basically your monad laws
01:19:52 <kuribas> dminuoso: that's really neat.  I like this about math, you learn more stuff, then it clicks, and actually appears simpler.
01:22:36 <kuribas> dminuoso: but haskell monoid isn't a CT monoidal cathegory then?
01:23:06 <dminuoso> kuribas: The typeclass `Monoid` just represents the group theory idea of a monoid.
01:23:20 <kuribas> ok, it makes sense now
01:23:46 <Cale> Or a monoid object in (Hask, (,), ()) if you want
01:24:49 <kuribas> right
01:25:23 <AWizzArd> Boomerang: so that would resemble (<*>) a bit, yes?
01:26:33 <kuribas> dminuoso: did you study CT in college?
01:26:39 <dminuoso> kuribas: Im a school dropout
01:26:54 <Boomerang> Maybe, I'm not sure what the Applicative would be in your EDSL...
01:27:03 <kuribas> dminuoso: so you're home schooled, like me then...
01:27:23 <kuribas> dminuoso: well, I didn't drop out, I studied music
01:27:40 <dminuoso> kuribas: I do some reading on my own. But I learned a lot from the awesome folks in this channel.
01:28:05 <kuribas> you don't need an institute in order to learn
01:28:47 <tdammers> IME being good at programming / knowing your stuff, and having a relevant formal education, tend to be mostly orthogonal
01:29:26 <AWizzArd> Boomerang: I wasn’t thinking about this at all. I just saw the resemblance, how the <*> operator gets repeated, and your `App` example as well.
01:29:37 <AWizzArd> Boomerang: Thx for your input. I will play a bit with that idea.
01:30:02 <[exa]> formal CS education is still quite nice for not reusing the mistaken assumptions from 1950-1990
01:30:06 <Ariakenom> #haskell isn't an institute of higher learning? I've been tricked
01:30:11 <[exa]> :D
01:30:21 <dminuoso> tdammers: I've met quite a bunch of academia folks who formally studied CS, wrote their Bc and Ms thesis in those topics and they are complete morons not worth hiring.
01:30:40 <tdammers> indeed
01:30:48 <merijn> tdammers: I dunno, I've found there are some pretty reliable gaps in self-taught people without a formal degree. Granted the same gaps appear in some people with degrees, depending on where they got them
01:31:00 <tdammers> merijn: try me
01:31:25 <Ariakenom> *fight pit forms*
01:31:29 <tdammers> D:
01:31:33 <ventonegro> Maybe 'moron' is too harsh? Surely they lack some software engineering skills, but those should be mentored as well
01:32:38 <[exa]> merijn: btw can you elaborate on the properties of the resulting morons? (constructive criticism probably)
01:32:45 <tdammers> ventonegro: I've worked "with" some people who had CS degrees and all, but they were completely resistant to mentoring or progressive insight or any of that
01:32:57 <dminuoso> ventonegro: My last example is of a student who wrote his Bc thesis on implementing a pairing based cryptograpic scheme. He didn't know: what a group is, what an exception is, what the difference between a public and a private key is, he didn't really know anything.
01:33:06 <dminuoso> But he got his degree and he's now working on his master thesis.
01:33:31 <dminuoso> The kind of bullshit you sometimes see in some universities is amazing.
01:34:03 <ventonegro> I'd say that the college failed him instead
01:34:22 <dminuoso> ventonegro: Best of it: I helped him a bunch, and he directly copied my code, sold it off as his own. His professor found out that he ripped off large chunks of his encryption scheme.
01:34:26 <dminuoso> Still got the degree.
01:35:03 * hackage yam-config 0.3.0 - Yam Configuation  http://hackage.haskell.org/package/yam-config-0.3.0 (leptonyu)
01:35:47 <dminuoso> merijn: Im curious, what exactly did you mean by that?
01:36:01 <ventonegro> Also, a lot of people who would be a lot happier not bothering with higher education is often pressured by family and friends to get a degree
01:36:03 * hackage yam-logger 0.3.0, yam-transaction 0.3.0, yam-web 0.3.0 (leptonyu)
01:36:12 <dminuoso> merijn: Are you saying that the gap in self-taught people is much larger than in ones that have received formal education?
01:36:16 <dminuoso> (Which I'd probably agree with)
01:38:22 <greg__> Hey. Why Map isn't an instance of Category?
01:39:04 <dminuoso> kuribas: So the monoid is in `smashing these composed layers together`. That is `join` smashes two layers of (functor) composition together, and it doesn't matter which order you do it in (associativity). And `pure` gives you a layer that acts as an identity wrt to the smashing.
01:39:07 <Cale> How do you define composition without an Ord instance?
01:39:08 <cocreature> I’d say it’s probably slightly easier to miss an entire subfield of CS when you’re self-taught than when you have received formal education but in the end the differences between individual people are way larger than difference between the average self-taught person and the average person that has received formal education
01:39:11 <dminuoso> kuribas: (to bring it all together)
01:39:15 <Cale> also, what is id?
01:39:25 <cocreature> greg__: Data.Map also only works for finite maps so you can’t implement "id"
01:39:46 <hc> http://www.catb.org/jargon/html/education.html
01:40:20 <kuribas> dminuoso: yeah, thanks
01:40:51 <kuribas> merijn: try me as well.  I don't mind filling those gaps
01:41:03 <kuribas> (if I know what they are)
01:42:53 <kuribas> ventonegro: I had a collegue with a CS degree, who didn't know how to write parsers.
01:43:29 <kuribas> ventonegro: He might still be a smart dude, but his attitude of I know everything better bothered me.
01:44:01 <dminuoso> kuribas: In a cool and fancy way Applicative is also a monoid in the category of endofunctors. Only difference is that the category of endofunctors is equipped not with functor composition, but with the Day convolution operator.
01:44:19 <dminuoso> That is, the bifunctor is a different one
01:45:14 <ventonegro> I had sometimes to "fix" code with awful asymptotic behaviour from other colleagues when the input data became large. They simply thought it wasn't worth learning, frameworks are what anyone would need nowadays...
01:45:59 <dminuoso> ventonegro: That
01:46:34 <ventonegro> And although I didn't enjoy it at the time, an analysing all those running times in college paid off
01:47:11 <tdammers> kuribas: writing parsers is a bit of a specialist area, really... most programming jobs out there don't really require any in-depth knowledge of it
01:47:37 <dminuoso> tdammers: Seeing how easy it is to write parsers with things like megaparsec, there's no excuse not to know the basics. :P
01:48:03 <kuribas> tdammers: perhaps... but their solution to read tab delimited or csv files was pretty hairy.
01:48:15 <tdammers> kuribas: that is kind of bad, yes
01:48:42 <kuribas> tdammers: that probably falls just under basic string manipulation
01:48:45 <tdammers> kuribas: but in this case I would argue that what is much worse than the inability to write a working CSV parser is the decision to not use an existing CSV library
01:49:09 <tdammers> note that parsing CSV isn't completely trivial
01:49:27 <kuribas> there was so much that was bad about that code, I don't want to think about it
01:50:49 <dminuoso> tdammers: Any issues are trivially fixed. Send a mail "Dont write non-ascii characters, ';' or '"' into the application or it will crash"
01:50:49 <tdammers> well, some people are just plain incompetent
01:51:08 <tdammers> dminuoso: it's funny because it's true. and also sad.
01:52:27 <tdammers> dminuoso: "If your name is O'Brien, we will not be able to accept you as a customer, because our customer support staff will not be able to find your account in our CRM system. We suggest marrying or adopting a pseudonym."
01:52:37 <tdammers> true story
01:52:45 <tdammers> (though we didn't actually tell the customer that)
01:53:01 <dminuoso> What. Why?
01:53:07 <dminuoso> Oh because of the '?
01:53:11 <tdammers> yes
01:53:22 <tdammers> the input sanitation from the search box would simply cut off everything from the ' on
01:53:39 <tdammers> but then the next stage of sanitation would toss out single-letter search terms
01:53:57 <AndreasK> Input sanitation is hard. I've seen cabal crash with some pattern match error when I used the wrong cmd flags in the past
01:53:58 <tdammers> so searching for "O'Brien" was equivalent to searching for ""
01:54:43 <tdammers> input sanitation gets especially hard when you don't understand the difference between encoding/decoding, sanitation, and validation
01:55:19 <dminuoso> tdammers: The amount of mojibake Ive had to endure in the past 5 years makes me cry.
01:56:23 <tdammers> our system would also reject customers whose name or address contained any of the words "SELECT", "UPDATE", "INSERT", "DELETE"
01:56:41 <tdammers> fortunately this particular check was easy to bypass, because the comparison was case-sensitive
01:56:43 <dibblego> we wrote a non-trivial CSV parser, http://github.com/qfpl/sv/
01:58:13 <tdammers> dibblego: build-depends: attoparsec -- tells me that this is not an ad-hoc thing
01:58:28 <dibblego> what is not an ad-hoc what?
01:58:39 <tdammers> sv is not an ad-hoc wannabe CSV parser
01:58:45 <dibblego> I don't know what that means.
01:59:21 <tdammers> it means you just throw something together quickly, to solve the exact problem at hand, without any design efforts worth mentioning
01:59:45 <tdammers> "example-driven development"
01:59:50 <dibblego> It was not written quickly, but it does solve the exact problem at hand, unlike any of the hundreds of other CSV parsers I have seen.
02:00:13 <dibblego> "design efforts" cam from the same place we wrote all the other kick-arse parsers
02:00:22 <tdammers> of course
02:00:28 <merijn> tdammers, [exa], dminuoso: Whoops, got dragged into a quick meeting. Mostly stuff on virtual memory, out-of-order CPUs, caching, etc.
02:01:06 <dibblego> argonaut for example, which was copied in purescript, and was kind-of-not-realy-because-it-cannot copied into aeson
02:01:09 <merijn> In general a lot of self-taught programmers seem to often lack a basis in basic computer architecture. Not saying all of them, but certainly a large portion
02:01:10 <dibblego> same design efforts
02:03:03 * hackage yam-config 0.3.1, yam-logger 0.3.1, yam-transaction 0.3.1, yam-web 0.3.1 (leptonyu)
02:03:33 <tdammers> dibblego: what I mean is this is not a CSV parser written for the purpose of parsing one very specific set of example CSV files in order to get them imported into one very specific project, and completely ignoring any and all specs
02:03:34 <kuribas> merijn: hmm, I was more expecting something like advanced math
02:03:45 <kuribas> merijn: more abstract stuff
02:04:08 <dibblego> tdammers: no it is not, and I'm not fond of being suspected of such a thing, despite how common it is.
02:04:44 <merijn> kuribas: tbh, that doesn't affect me all that often
02:05:06 <tdammers> dibblego: you're not suspected at all. I was trying to express praise here.
02:05:15 <merijn> kuribas: You can get quite far with a bit of basic algebra, maybe some linear algebra (although, tbh I'm sorely lacking in that and it's rarely been a problem)
02:05:21 <dibblego> tdammers: I understand this. I am not here to fuck chickens :)
02:05:28 <tdammers> dibblego: good :D
02:05:39 <merijn> kuribas: However, when it comes to getting moderately reasonable performance out of your code the basic computer architecture stuff is crucial
02:05:53 <kuribas> merijn: linear algebra seems pretty important when you go to more mathematical stuff, like machine learning
02:06:08 <merijn> kuribas: Like I always joke (well, not really a joke...), arrays are the universal HPC data structure :)
02:06:18 <tdammers> merijn: like what, knowing what a swapfile is, what it means to be CPU-bound vs. being IO-bound, what caches exist and how they affect performance?
02:06:40 <merijn> kuribas: Yeah...my educated opinion is the lots of modern machine learning is basically just fucking about and not worth investing too much effort in right now
02:06:49 <dibblego> tdammers: do you know how I know that if you type 94 '(' characters into python right now, you'll get a stack over flow? Because we wrote a python parser, then used hedgehog to generate python programs, of which one was 94 nested expressions, and since hedgehog does automatic shrinking, it found the minimal failure case
02:07:09 <merijn> tdammers: Well, that, but also how paging and memory mapping works and (causally related) how mmap is the best syscall ever
02:07:13 <kuribas> merijn: I do like the nice pictures, and the unbeatable chess AI.
02:07:19 <tdammers> dibblego: you wrote a python parser? you must love pain.
02:07:34 <dibblego> my team did, I like solving problems such as python
02:07:42 <tdammers> nicely said
02:08:00 <dminuoso> merijn: Funny, I would have thought the opposite.
02:08:03 <dibblego> there was a talk on it at lambdajam just this week
02:08:11 <kuribas> merijn: understanding how alphazero works is definitely on my learning list
02:08:23 <tdammers> I pondered writing a PHP parser in Haskell at some point
02:08:33 <merijn> kuribas: Hint: Most people working on CNN can't really tell you why it works either :p
02:08:33 <dminuoso> merijn: I mean I have some solid basic knowledge because I wrote a kernel once. It's something I recommend every software developer should do in his career.
02:08:42 <kuribas> tdammers: just use this? https://hackage.haskell.org/package/language-python
02:08:43 <dibblego> tdammers: we preserve this property print . parse = id
02:08:46 <AndreasK> kuribas: https://xkcd.com/1838/ Something like this xD
02:08:49 <tdammers> the idea was to build a system that would do some automated code auditing to detect common security mistakes
02:08:52 <dminuoso> Not a full fledged production ready kernel, but writing some toy kernel until you get a working userspace, you learn so much from it..
02:08:57 <merijn> kuribas: I had lunch with some ML phds, they're like "yeah, I don't really get why any of this works either"
02:08:58 <dibblego> kuribas: see the property above, which is essential to solve problems
02:09:01 <tdammers> company blew up before we could start on it though
02:09:13 <merijn> dminuoso: Yeah, that helps a lot
02:09:15 <dibblego> we wrote direct tail-call elimination into python, for example, for which you need that property to hold
02:09:22 <merijn> dminuoso: Did you do any virtual memory/MMU stuff?
02:09:29 <dminuoso> merijn: I had a working userspace.
02:09:38 <dibblego> https://github.com/LightAndLight/pyfactor/blob/master/example/Example.hs#L162
02:09:43 <marius_> join mm
02:09:46 <merijn> dminuoso: You can have a working userspace without that, just look at DOS :p
02:09:47 <kuribas> merijn: that must mean we are approaching real intelligence :)
02:10:18 <merijn> kuribas: Wanna get a superpower when it comes to asking nasty questions at future ML talks?
02:10:29 <tdammers> merijn: "basically, we have this pile of linear algebra here, and we throw information in on one end, and then we just wiggle it until the thing that comes out on the other end looks somewhat right"
02:10:52 <merijn> kuribas: Look up the "No Free Lunch" theorem paper(s) by Wolpert (there's two, one about ML and one about optimisation)
02:11:16 <tdammers> dibblego: I don't understand how you would need an exact print . parse identity for that
02:11:24 <merijn> It's the "yes, but what's your baseline?" question of ML ;)
02:11:29 <kuribas> I suppose alphazero just gives weights for certain patterns.
02:11:44 <dibblego> tdammers: are you going to delete the comments when you rewrite the syntax tree?
02:12:04 <tdammers> dibblego: depends what you use the output for - if all you do is feed it to an interpreter, sure, why not
02:12:23 <dibblego> because that's just getting started, that's why :)
02:12:23 <merijn> dminuoso: Anyway, I hope you don't disagree that "I wrote a toy kernel" is wildly outside of the norm for self-taught programmers :)
02:12:27 <tdammers> dibblego: but if it's for some sort of refactoring tool, then yes, you need to keep them around
02:12:46 <merijn> dminuoso: Like, probably 4 or more standard deviations away from the amount of stuff the average self-taught person knows :)
02:12:48 <tdammers> dibblego: also, I'm not 100% sure there is such a thing as semantically irrelevant comments in python
02:13:47 <lightandlight> I'm about 98% sure
02:14:11 <merijn> 95% at best for me :p
02:14:46 <tdammers> at the very least, inspecting things and extracting their doc comments is rather trivial (the "first thing in a function or class is a string literal" thing)
02:14:59 <tdammers> I don't know if something similar is possible for #-style comments
02:15:26 <tdammers> then again, worst comes to worst a module can figure out its own filename and just read the source file in
02:17:34 <dminuoso> merijn: For me it started with a simple question. I was staring at a C program and looked at the main function and saw a "return 0" and asked myself.. well on the stack.. what does it return to? That's when I fell into the rabbit hole and didn't stop until I had my own modified GCC, with parts of my own standard C library, my own memory subsystem..
02:17:37 <merijn> kuribas: As for the higher math stuff, don't get me wrong, I like CT and that sorta neat stuff. But if we're talking sheer ROI it doesn't look very good unless you're, like, edwardk and already mostly fluent in that stuff :)
02:18:11 <kuribas> merijn: ROI?
02:18:15 <dminuoso> merijn: Maybe I expect too much of others. In a way I expect others to have the same curiosity that shoudl make them investigate.
02:18:19 <merijn> kuribas: Return On Investment
02:18:37 <merijn> kuribas: i.e. the amount of practical pay-off compared time invested to learn and understand
02:19:04 <kuribas> merijn: it helps you understand lens ;-)
02:19:19 <merijn> As an average programmer you should be able to breeze through a book on basic computer architecture and OS design
02:19:19 <dminuoso> kuribas: I dont think you need to learn any maths to in order to know how to use lens.
02:19:28 <dminuoso> kuribas: Apart from some basic things you can pick up in an afternoon.
02:19:36 <merijn> kuribas: tbh, I don't use lens all that often and when I do I don't find myself wishing I knew more CT
02:20:00 <merijn> And the nice thing about the computer arch and OS stuff is that it's portable between programming languages
02:20:09 <Ariakenom> "already fluent" He learnt too at some point though, or is he eternal?
02:20:10 <dminuoso> Isn't lens completely new territory that doesn't have much existing papers/knowledge?
02:20:10 <kuribas> It's just cool to recognise the patterns, but I don't think you are a worse programmer without.
02:20:27 <dminuoso> Ariakenom: Edward is an eternal being from the kmettiverse.
02:20:57 <merijn> Ariakenom: Pretty sure Edward is an android, since he doesn't sleep
02:21:06 <merijn> Ariakenom: So he probably just downloaded it, matrix style
02:21:41 <kuribas> merijn: I think a basic understanding of the haskell typeclasses is more important than the CT background behind it.
02:21:43 <merijn> Ariakenom: Anyway, like I said, don't interpret this as me arguing against learning CT or higher math. By all means, do! But do it because you're curious and find it neat
02:21:44 <dminuoso> kuribas: The ROI is just much lower. I personally learned a few random CT bits out of curiosity and self interest.
02:22:02 <dminuoso> Except monoids.
02:22:05 <dminuoso> Everybody should know monoids.
02:22:20 <merijn> Ariakenom: And if your end goal is "become better at writing real world code" I can recommend other things that will more quickly help you :)
02:22:26 <merijn> dminuoso: I love monoids, they're so easy ;)
02:28:16 <Ariakenom> Sure. I just took issue with the ROI and "already know".
02:39:06 <kuribas> merijn: one of the things about higher math is that you need to pass a certain threshold for them to become usefull.
02:39:15 <kuribas> merijn: and then so many things fall into place.
02:39:28 <kuribas> merijn: I think that's the biggest ROI for math.
02:39:53 <kuribas> But if you talk about webapps, probably not so much :)
02:46:47 <Ariakenom> I will not rest until I can derive my webapp from its type sig
02:48:15 <liste> @exference IO ()
02:48:16 <lambdabot> Unknown command, try @list
02:48:20 <liste> :(
02:48:26 <liste> @djinn IO ()
02:48:26 <lambdabot> Error: Undefined type IO
02:48:40 <liste> why doesn't it write my app for me :(
02:56:15 <dminuoso> kuribas: The value in math is more of a phiolosophical nature. If you begin to see the monoid structure of a monad it's a pretty cool feeling - but it will not make you write cleaner code.
03:09:34 * hackage hasbolt-extras 0.0.0.10 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.10 (ozzzzz)
03:20:33 * hackage imap 0.3.0.7 - An efficient IMAP client library, with SSL and streaming  http://hackage.haskell.org/package/imap-0.3.0.7 (mkawalec)
03:22:33 * hackage emailparse 0.2.0.9 - An email parser that will parse everything  http://hackage.haskell.org/package/emailparse-0.2.0.9 (mkawalec)
03:39:54 <haskell_noob2> i need help debugging wss connection.
03:40:18 <haskell_noob2> i am using wuss that is supposed to take care of most of the certificate issues. It seems to be failing.
03:40:25 <haskell_noob2> how do i debug this ?
03:41:50 <cocreature> haskell_noob2: can you be a bit more specific than “it seems to be failing”?
03:42:56 <haskell_noob2> ``` Exception MalformedResponse (ResponseHead {responseCode = 400, responseMessage = "Bad Request", responseHeaders = [("Date","Thu, 24 May 2018 10:35:44 GMT"),("Content-Length","52"),("Content-Type","text/plain; charset=utf-8")]}) "Wrong response status or message."```
03:43:09 <haskell_noob2> i have a python and curl client that work with the above parameters.
03:43:16 <haskell_noob2> i mean the headers.
03:43:56 <haskell_noob2> [("sec-websocket-protocol","v4.channel.k8s.io"),("Connection","upgrade"),("Upgrade","websocket"),("Authorization","Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwixxxxx")]
03:45:31 <haskell_noob2> i was looking into tls-debug utils, for some reason i cant seem to build it on ghc 8.0.2. Let me see if i get that installed and have better error messages.
03:46:23 <dminuoso> ddellacosta: By the way, did you get the message?
03:47:16 <ddellacosta> dminuoso: hey! No, I'm traveling now and only been on sporadically
03:47:29 <haskell_noob2> cocreature : this is the error when i try to build hs-tls : ``` Error: Stack configuration file stack.yaml exists, use 'stack solver' to fix the existing config file or '--force' to overwrite it.
03:47:29 <haskell_noob2> Called from:
03:47:29 <haskell_noob2>   throwString (src/Stack/Init.hs:64:9 in stack-1.6.1-H3nqM53WCLm2pOB5sFJMgO:Stack.Init)
03:47:29 <haskell_noob2> ```
03:47:31 <ddellacosta> oh there it is
03:47:56 <cocreature> haskell_noob2: that looks like you’re trying to call "stack init" rather than "stack build"
03:48:02 <ddellacosta> dminuoso: thanks! I am hoping to tackle this while I'm on my next (long) flight--so thanks, that's timely
03:48:33 <dminuoso> ddellacosta: One easy way to do the transformation is by reading it out aloud.
03:48:40 <haskell_noob2> build gives me ``` Error: While constructing the build plan, the following exceptions were encountered:
03:48:41 <haskell_noob2> In the dependencies for tls-1.4.1:
03:48:41 <haskell_noob2>     cryptonite-0.24 from stack configuration does not match >=0.25 (latest matching version is 0.25)
03:48:41 <haskell_noob2> needed since tls is a build target.
03:48:41 <haskell_noob2> ``` and am not sure why i need to update the stack file.
03:48:47 <dminuoso> ddellacosta: ($a) reads "apply a to", (.) reads "after"
03:48:52 <ddellacosta> dminuoso: interesting...will give it a shot
03:49:17 <kvothe> I have a function foo which is pattern matched for different values of its arguements. I make multiple function calls within the function each of which might throw an exception. If there is an exception at any function call, I want to short circuit the rest of the computation and do some cleanup
03:49:25 <kvothe> Is there a clean way of doing this?
03:49:46 <dminuoso> kvothe: Can you show the code you have?
03:49:56 <haskell_noob2> lambdabot bracket
03:50:02 <cocreature> haskell_noob2: what exactly are you trying to do? it sounds like you have fetched the source of tls manually and are now trying to run "stack build" in that repo. you probably want to just add it to the build-depends section in your cabal file instead
03:50:23 <kvothe> https://lpaste.net/9066824520479801344
03:51:17 <haskell_noob2> cocreature : i did a git checkout, i tried running make reinstall, but that gave me cabal errors. So i assumed it was a stack project with a stack.yaml file. Let me see how they build it on the repo and try them.
03:51:29 <dminuoso> kvothe: What kind of exceptions are you expecting?
03:51:57 <cocreature> haskell_noob2: ah you’re trying to build "tls-debug" rather than "tls"?
03:52:05 <kvothe> dminuoso: CryptoErrors, Deserialisation failures, socket errors
03:55:42 <haskell_noob2> cocreature :  echo "{ resolver: lts-9.21, packages: [ core/, debug/, session/ ], extra-deps: [ memory-0.14.14, foundation-0.0.19, basement-0.0.6, cryptonite-0.25 ], flags: {} }" >  stack.yaml, this was missing. So now i can build it. I am hoping to trace some traffic to the server so i know what is going wrong.
03:55:52 <dminuoso> kvothe: You could use any of Control.Exceptions mechanisms. Maybe `catches`, just be careful to only catch the exceptions you care about.
03:56:19 <cocreature> haskell_noob2: I’m not sure that’s going to be useful. afaict the tls-debug package is intended to debug the tls package itself not code using the tls package
03:56:21 <dminuoso> kvothe: Be sure to look at `bracket` and `finally` for any cleanup actions
03:56:23 <haskell_noob2> kvothe : bracket ( idont know how  to make lambdabot send the type signature), though that might be a place to start.
03:56:37 <cocreature> haskell_noob2: if you want to trace some traffic to the server, I would try wireshark
03:56:59 <haskell_noob2> i have the wireshark output. How do i diff to see which headers are missing / different? is there a simple way?
03:57:22 <cocreature> not sure, sry
03:57:23 <kvothe> dminuoso: But catches expects me to construct the same type that my original function was returning
03:57:36 <jesyspa> kuribas: A tangent on the "monads as monoids of endofunctors" thing: a really cool thing you may want to check out if you liked that approach is enriched categories.  It lets you say the same in different words (that generalise in different ways).
03:57:59 <dminuoso> kvothe: Consider the perspective of the consumer.
03:58:16 <dminuoso> kvothe: If one side does `IO Int` and the other side does `IO Bool`
03:58:23 <dminuoso> What is the overall type?
03:58:50 <dminuoso> kvothe: If you want to communicate possible value, you can embed this in an Either or Maybe.
03:58:55 <dminuoso> *possible failure
03:59:43 <kvothe> dminuso: makes sense
04:00:10 <haskell_noob2> to add to dminuoso's point, kvothe, a bracket also masks interrupts during resource cleanup, so going Either, Maybe is probably the direction to go into, imo.
04:00:25 <kuribas> jesyspa: sounds interesting :)
04:00:46 <kvothe> haskell_noob2: Thanks. Will check out brackets
04:02:03 <kvothe> However, is there no way of doing exception handling like in OO languages? try{func1;func2} catch(func1failure) catch(func2failure)
04:02:11 <haskell_noob2> cocreature, that was it. Once i updated the stack.yaml file, it worked. I have the tls-simpleclient now. so i can probably trace the traffic as hs-tls expect. I am using wuss which is using hs-tls underneath.
04:02:19 <kvothe> Something along those lines
04:02:23 <dminuoso> kvothe: catches does just that, but its quite possible Either might be a better fit.
04:02:51 <dminuoso> kvothe: Either/Maybe model exceptions but in a way that you can do some pretty cool tricks.
04:04:01 <dminuoso> > asum [Nothing, Nothing, Just 3, Just 4]
04:04:03 <lambdabot>  Just 3
04:04:07 <kvothe> dminuoso: catches is for a single function call right? What about a bunch of function calls?
04:04:22 <dminuoso> kvothe: not function calls. For an `IO a` action
04:05:00 <dminuoso> kvothe: an `IO a` for some choice of a can be composed (via >>/>>=/multiple lines in do notation) from multiple actions
04:05:35 <kvothe> dminuoso: makes sense
04:11:02 <merijn> kvothe: GHC's exceptions are actually rather sophisticated and can even do sub-classing where you can group exceptions and catch entire (sub)groups
04:11:18 <tdammers> yeah
04:11:22 <tdammers> the one thing you don't get is checked exceptions
04:12:17 <merijn> Simon's paper on extensible exceptions is pretty good
04:12:24 <merijn> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.205&rep=rep1&type=pdf
04:13:14 <dminuoso> kvothe: What we consider a function is just a plain value mapping that is closer related to "evaluating a value" rather than "doing/entering". So we don't like to talk about "function calls"
04:13:44 <Ariakenom> dminuoso: That asum example works with IOError too
04:14:21 <dminuoso> Ariakenom: How would you use that?
04:14:54 <dminuoso> kvothe: And its also related to Haskells lazy evaluation model. So just because you express some `f 1` it does not mean it will actually be evaluated on the spot.
04:16:10 <Ariakenom> dminuoso: IO has an alternative instance.
04:16:15 <Ariakenom> :t many getLine
04:16:17 <lambdabot> IO [String]
04:16:38 <Ariakenom> read lines until exception :)
04:16:49 <hpc> that... huh
04:16:59 <hpc> that's pretty useful
04:17:03 <tdammers> kvothe: it's probably best to forget for now that "procedures" in an imperative language and "functions" in Haskell are both called "functions" sometimes; they are very different beasts
04:18:11 <Ariakenom> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.IO.html#mplusIO
04:18:29 <dminuoso> Ariakenom: TIL.
05:09:04 <world> is haskell scripting or programming language?
05:10:04 <lyxia> how is scripting different from programming
05:10:57 <world> lyxia c is programming langue and bash  is scripting
05:11:50 <exarkun> hspec is deprecated in favor of hspec2 but hspec2 is alpha and last released in 2014?
05:13:27 * Clint claps.
05:14:43 <exarkun> http://hackage.haskell.org/package/hspec doesn't really look deprecated but using it gives compile time warning of "Module ‘Test.Hspec’ is deprecated: use hspec-2.* instead"
05:15:02 <dminuoso> world: The distinction is usually useless.
05:15:08 <dminuoso> world: It's programming either way.
05:15:47 <exarkun> world: Maybe you want to ask a different question.  What's your interest in Haskell?
05:24:43 <Ariakenom> QuickCheck was innovative right? In what precisely?
05:27:43 <__monty__> exarkun: hspec2 (deprecated in favor of hspec) is what I see on hackage.
05:28:02 <__monty__> exarkun: Maybe you're using hspec-1.*?
05:28:33 <exarkun> oh
05:28:50 <exarkun> I guess so.  stack recommended a version and I blindly copy/pasted.
05:28:59 <exarkun> actually, hspec-0.*
05:29:23 <exarkun> Also I misunderstood the distinction between "hspec2" and "hspec-2.*".
05:31:26 <exarkun> thanks
05:36:39 <__monty__> np
05:43:17 <merijn> world: I agree with the others that your question isn't really sensible, but to make an attempt to answer it: the main Haskell compiler (GHC) generates machine code libraries/executables like, e.g. C and Rust, so would almost certainly classify as "programming language" for people who think there's a real distinction between that and scripting
05:46:02 <lyxia> Ariakenom: it introduced property-based testing, showing how to leverage the spectrum of properties between "this function doesn't crash" and "this function is equivalent to that reference" for testing.
05:53:43 <Ariakenom> lyxia: Right thanks. So it was first with that.
06:01:15 <world> merijn : thanks
06:02:03 <Ariakenom> This is a long list of property-based testing implementations https://en.wikipedia.org/wiki/QuickCheck I don't suppose anyone has another?
06:04:13 <merijn> Ariakenom: The way QuickCheck combined the ability to generate complex arbitrary input data with a notion of properties to effectively do "high-level fuzzing" and the ability of QuickCheck to automaticall shrink failing test cases to a minimal reproducing example where both new and innovative at the time
06:05:29 <merijn> Hell, I'd say it's STILL innovative compared to many testing approaches out there :p
06:06:33 <Ariakenom> merijn: thanks a lot. quite thorough.
06:09:33 * hackage tintin 1.3.5 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.3.5 (NickSeagull)
06:26:33 * hackage extensible-effects-concurrent 0.1.2.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.2.0 (SvenHeyll)
06:36:58 <GobGobGobbbyyyy> I get a `dodgy-imports` warning when I import a type, specifically for use in a type signature. Is there something I can do to fix this besides turning off the dodgy imports warning?
06:38:18 <Cale> GobGobGobbbyyyy: Do you need to import its data constructors?
06:38:36 <Cale> That warning happens when you import a type with its data constructors, but only export the type
06:39:35 <Cale> (so importing the constructors doesn't do anything)
06:40:09 <Cale> So if you have  MyType(..)  in your import list, just change that to  MyType  on its own
06:41:33 * hackage quickcheck-classes 0.4.11 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.4.11 (andrewthad)
06:45:19 <djtyml> Hi, does anyone know how to look for callers and definition of an symbol in a large haskell program, using vim?
06:47:33 * hackage codec-rpm 0.2.2 - A library for manipulating RPM files  http://hackage.haskell.org/package/codec-rpm-0.2.2 (clumens)
06:57:37 <mpickering> After doing an inner join with persistent is there a way to turns [(Entity a, Entity b)] into [(Entity a, [Entity b])] by grouping on the first key without using Data.List.groupBy
07:00:03 * hackage cabal-bounds 1.6.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-1.6.0 (DanielTrstenjak)
07:00:34 * hackage freq 0.1.0.2 - Are you ready to get freaky?  http://hackage.haskell.org/package/freq-0.1.0.2 (chessai)
07:01:07 <merijn> mpickering: tbh, I found joins in persistent such a hassle I ended up just using persistent's rawSql to convert the output into what I needed
07:01:25 <mpickering> hmm, ok
07:01:48 <mpickering> I feel like this is such a common thing to want to do that there must be a solution..
07:02:35 <liste> @hackage esqueleto
07:02:35 <lambdabot> http://hackage.haskell.org/package/esqueleto
07:02:52 <merijn> mpickering: How did you even do a JOIN anyway? Persistent doesn't natively support them, and esqueleto I gave up before even trying it
07:03:06 <mpickering> I'm using esqueleto
07:03:35 <mpickering> Sorry, in my head they are the same thing
07:03:40 <merijn> liste: tbh I can't in good conscience recommend anyone use esqueleto, it's horribly limited in what it allows, actually throws all persistent's type safety out the window and just generally my attempts to use it were rather painful
07:04:11 <cocreature> the idea of making a SQL lib that doesn’t support joins out of the box still confuses me
07:04:20 <liste> merijn: how is it type unsafe?
07:04:22 <exarkun> How do I pick from among the various Haskell systems for dealing with mutable state?
07:04:36 <merijn> exarkun: Depends on what kinda mutable state and what you wanna do with it
07:04:48 <merijn> liste: I recall seeing an elaborate blogpost about that
07:05:12 <liste> not saying I haven't had my pains with esqueleto :)
07:05:38 <exarkun> merijn: okay ... what's the decision tree to follow
07:06:06 <Ariakenom> exarkun: What's your reason for mutable state?
07:06:39 <exarkun> Ariakenom: http-accessible service for storing and retrieving state
07:07:00 <exarkun> Ariakenom: probably morally equivalent to, eg, a sql database
07:07:02 <Philonous> merijn, Honestly, I find esqueleto to be an OK compromise if you need to write SQL that can't be expressed in pure persistent (i.e. anything with joins) and while it allows you to write invalid SQL it's still more pleasant than writing raw SQL
07:08:07 <Ariakenom> exarkun: so, eh, what's your reason for not wanting an sql database?
07:08:28 <exarkun> "morally equivalent to" not "feature equivalent to"
07:08:36 <__monty__> Ariakenom: Not sure what you were looking for when you asked for another. Other quickcheck implementations? There's hedgehog and smallcheck (not the same but similar).
07:08:43 <exarkun> I'm not working with SQL, I'm not working with relational data
07:09:27 <exarkun> Besides, installing MySQL won't help me learn anything about Haskell.
07:09:29 <merijn> Philonous: tbh, I found writing SQL to be orders of magnitude more pleasant than esqueleto
07:09:52 <Philonous> Really? *shrug* fair enough
07:10:32 <Ariakenom> exarkun: What about persistence?
07:10:44 <merijn> Philonous: As soon as you wanna do more complex things than completely trivial joins it becomes much easier to google SQL than dealing with esqueleto's confusing types
07:11:33 <exarkun> Ariakenom: There ... will be some ... The network interface delegates actual operations to a backend (a typeclass).  Right now I'm working on the in-memory instance of the typeclass.  Soon I'll work on the on-disk instance.
07:12:18 <Ariakenom> exarkun: If you want simple and for learning I'd say have a look at STM
07:12:49 <Philonous> merijn, Maybe it depends on what you want to do. I find I need (simple) joins basically all the time, but more complex things like CTEs etc. very rarely.
07:13:50 <Ariakenom> I said learning because otherwise you'd probably want a library that handles persistence
07:15:02 <exarkun> When you say "persistence" do you mean "durability" or the class of data structures without in-place modification?
07:15:30 <Ariakenom> I mean writing to disk
07:16:23 <exarkun> Okay.  I think I see how to do the writing-to-disk version of this.  That just involves operations in the IO monad.  There's not so much Haskell state to mutate once I can mutate the disk.
07:17:52 <Ariakenom> Not sure I follow. I didn't mean to give any advice on how to handle the disk stuff
07:17:53 <merijn> exarkun: tbh, I still have no clue what sort of state you have and what sorta manipulation you plan to do on it
07:19:05 <exarkun> merijn: Okay, concretely: inserts and modifies on a pair of `Map ByteString (Map Integer ByteString)`.
07:19:27 <merijn> Sounds rather relational to me, tbh :p
07:19:29 <exarkun> call that type `MemoryStorage`
07:19:53 <exarkun> okay, it's not, but that really doesn't matter, I'm not building a sql database
07:20:25 <merijn> You could just use SQLite, that'd solve both the disk and memory issue :)
07:20:30 <exarkun> With STM it sounds like I would make each MemoryStorage a TVar MemoryStorage instead, and then do the inserts/modifies with modifyTVar?
07:20:33 <Ariakenom> But, again, have a look at STM https://hackage.haskell.org/package/stm-2.4.5.0/docs/Control-Monad-STM.html
07:20:34 <exarkun> Guys
07:20:40 <exarkun> I am a new Haskell programmer
07:20:43 <exarkun> I want to learn Haskell
07:20:52 <exarkun> I thought this was a channel to learn Haskell in
07:21:18 <merijn> exarkun: The problem is that your problem description is too vague to give useful feedback/advice
07:21:35 <exarkun> merijn: The problem is I don't know Haskell well enough to ask better questions without help
07:21:57 <merijn> "I wanna store data in memory and on disk" -> ok, what kinda data? what do you wanna do with it? why does it need two separate backends?
07:22:04 * hackage generics-mrsop 1.0.0.1 - Generic Programming with Mutually Recursive Sums of Products.  http://hackage.haskell.org/package/generics-mrsop-1.0.0.1 (vcmiraldo)
07:22:12 <exarkun> I described the data structure and the operations, what else can I describe?
07:22:28 <Ariakenom> Yes, that's how you could use STM.
07:23:02 <lortabac> exarkun: if you are a beginner, you can start with an IORef, I think they are simpler than STM
07:23:04 <exarkun> I expect the in-memory backend will be useful because it takes less configuration to set up, it's faster for naive usage, and I can use it to implement a test suite for the typeclass
07:23:19 <exarkun> I expect the on-disk backend will be useful for anyone who actually wants to store some data
07:23:39 <exarkun> and it should then pass the same test suite as I develop for the in-memory backend
07:24:27 <cocreature> exarkun: sounds like something that I would use sqlite for. it has an in-memory backend and you can ofc also persist the db
07:24:48 <cocreature> if you just want in-memory you could consider rolling your own but I definitely wouldn’t want to roll my own persistence layer
07:24:49 <exarkun> yes, SQLite3 is great, I love it
07:25:03 <exarkun> one time I worked at a company that built its flagship product on it
07:26:18 <exarkun> Maybe I'll even use SQLite3 for this, I don't know.  Probably not, I think the on-disk format might be defined already and changing it could be hard.  But maybe not impossible.
07:26:34 * hackage freq 0.1.0.3 - Are you ready to get freaky?  http://hackage.haskell.org/package/freq-0.1.0.3 (chessai)
07:26:58 <cocreature> exarkun: if you have an existing format that you need to conform to, you can take a look at "binary" for serialization
07:27:00 <exarkun> I still have to build a layer on top of the persistence system though, the interface to this data isn't SQLite3 API calls (or SQL strings)
07:27:17 <Ariakenom> lortabac: sounds like there will be concurrent. but atomicModifyIORef is a thing I suppose
07:27:19 <merijn> exarkun: Sure
07:27:33 <exarkun> cocreature: Cool, hadn't seen `binary` before, I'll keep it in mind
07:28:19 <cocreature> exarkun: but binary will only take care of the “converting Haskell data to a specific binary format”-part. rolling your own persistence backend is a lot more complex if you care about getting acid guarantees
07:28:56 <exarkun> cocreature: Yep, I'm aware of all those challenges.  Due to the operations supported and the nature of the data itself, acid is probably not necessarily so the problem is _slightly_ easier.
07:29:07 <merijn> acid-state is nice for that, but nested maps sounds to relational to function well with acid-state
07:29:30 <exarkun> But yea.  I've spent plenty of time in my career learning how filesystems will screw you.
07:29:38 <cocreature> even if it’s not necessary, I’d personally prefer to stay on the safe side :)
07:30:00 <merijn> exarkun: Anyway, if your format isn't pre-defined SQLite3 is excellently suited for "application specific file formats", hell that's one of the recommended use-cases on their website
07:31:30 <exarkun> I'm going to read more about IORef and STM now I guess.  Thanks for the pointers.
07:32:37 <merijn> exarkun: IORef is basically just a "reguar" mutable variable like you find in most other languages. STM is a library that lets you write atomic transactions on multiple mutable variables
07:35:43 <quicksilver> and as a middle ground, MVar and Chan are things that let you design sane multi-threading code with shared variables that work predictably
07:40:09 <cocreature> ffs, shadowed dependencies here we go again …
07:40:36 <mbwgh> I have a question about streaming, particularly about .. `streaming`, which according to the documentation is to be regarded as part of the "pipes universe". If I need some functionality which appears to be missing, like recursively traversing a directory tree, what is the idiomatic thing to do? Am I supposed to implement it myself, since I have all the tools? Am I supposed to search hackage? There after
07:40:42 <mbwgh> all some streaming-* packages on hackage that are not on stackage. Am I supposed to use the one from conduit and "convert types", like shown in the readme? How do you approach this kind of situation "idiomatically"?
07:42:00 <merijn> mbwgh: Where does it say that it's considered "part of the pipes universe"?
07:42:41 <merijn> mbwgh: tbh, my experience with pipes has been...mixed. I like it conceptually and it's theoretically really elegant...but
07:43:02 <merijn> In my experience conduit just feels so much easier to use practically and with a bit more ecosystem support
07:43:10 <cocreature> pipes is really nice as long as pipes itself is all you need
07:43:41 <cocreature> once that’s not sufficient and you need to reach for pipes-group, pipes-parse, … things can get a bit awkward
07:43:57 <merijn> mbwgh: As for "how to do things like recursively traversing a directory tree?" if no one has writtena library for that, then yes you'd have to implement it yourself
07:44:23 <merijn> mbwgh: I know conduit already has a producer for that I've been using in my own code (since persistent & co already required conduit anyway)
07:44:43 <mbwgh> From the readme, paragraph 9: "Questions about this library can be put as issues through the github site or on the pipes mailing list. (This library understands itself as part of the pipes "ecosystem.")"
07:45:43 <cocreature> “streaming” is basically “what if we dropped bidirectional flow from pipes and integrated pipes-group directly” iirc
07:47:16 <mbwgh> I opened a thread on r/haskell a few months ago, asking which streaming libraries people use nowadays. I think ocharles recommended streaming, and has done so before. Some other person introduced their "streamly" library as well, though it is very very new, and the "ecosystem problem" would probably apply there as well
07:47:59 <merijn> mbwgh: Any specific reason you're using streaming beyond "that recommendation on reddit"?
07:49:15 <merijn> mbwgh: Because conduit has this built-in: https://hackage.haskell.org/package/conduit-1.3.0.2/docs/Data-Conduit-Combinators.html#g:5
07:50:03 <merijn> So if you're lazy and just wanna get something working, that might safe you a bunch of time
07:51:03 * hackage constrictor 0.1.1.2 - strict versions of many things in base  http://hackage.haskell.org/package/constrictor-0.1.1.2 (chessai)
07:51:18 <cocreature> mbwgh: there is a streaming<->conduit adaptor package that might also be helpful https://hackage.haskell.org/package/streaming-conduit-0.1.2.2/docs/Streaming-Conduit.html
07:51:21 <mbwgh> merijn: I have dabbled into both conduit and pipes. When I tried to use pipes-concurrency, I ran into some bugs that make it very hard to use. The corresponding conduit concurrency package on the other hand uses the old conduit combinators, of which there are .. five? Kind of awkward. There is a streaming concurrency package as well, but as already stated, other aspects of a full-blown streaming ecosystem
07:51:26 <mbwgh> are missing. It's kind of a choose 2 of 3 situation unfortunately
07:52:03 <merijn> mbwgh: Hah, I actually wrote some code for conduit to process a pipeline in parallel, but it's (still) unpublished
07:52:16 <merijn> mbwgh: What kinda concurrency do you want/need?
07:52:36 <kosmikus> it's equally easy to interoperate between "streaming" and "pipes" as it is to interoperate between "streaming" and "conduit" in my experience
07:52:41 <mbwgh> cocreature: I saw that, yes. But I was wondering, if deepening the dependency tree of your application like that is worth it, or you should just cut the middleman?
07:52:57 <kosmikus> so if the situation is "I have code using streaming, but want something which exists in conduit", then there's no reason not to combine
07:53:07 <merijn> mbwgh: Do you just want to parallelise part of the processing?
07:53:26 <kosmikus> if the situation is "I need to start something new, and will need a lot of stuff which is pre-built in the conduit world", you're probably better off directly using conduit
07:53:50 <cocreature> mbwgh: depends on whether you can be bothered to invest the time to write a version for streaming or not :)
07:54:04 <merijn> And/or pay someone to do it for you ;)
07:54:22 <kosmikus> I agree with ocharles though that streaming is very nice for its overall conceptual simplicity, and there are many applications that can benefit from streaming that don't need any IO at all, for example, and then typically both conduit and pipes feel like overkill.
07:55:31 <mbwgh> merijn: At the moment I am not really working on anything. I did write an interactive image scraper a while ago that made use of concurrency. You basically give it a list of links, each of which will result in another list of links (top gallery -> [preview page -> actual picture], kind of). There is a gui on top that should not freeze just because more pictures/thumbnails are fetched. This all worked out
07:55:37 <mbwgh> using STM and two or three queues, but the code was super imperative
07:58:21 <merijn> mbwgh: I've been working on a new Chan library to replace all my problems I have with Chan and provide "batteries-included" functionality, one thing I've done is write some wrapper stuff to parallelise streaming for IO bound stuff (i.e. "run N parallel functions of this long IO task in the middle of my stream"), the API still need a bunch of polish for me to release it, so outside opinions would be welcome
07:58:29 <mxf> What I disliked about streaming was its own ByteString type and its tie-in in its eco system.
07:58:33 <merijn> mbwgh: Which would basically give you: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-conduit/BroadcastChan/Conduit.hs#L21-L40
08:00:12 <mxf> I didn't understand why that was necessary besides performance
08:00:22 <merijn> mbwgh: Stuff like "stream a bunch of URLs to fetch pictures from in parallel" is exactly the sorta stuff I wrote it for, so if this code is experimental enough please mess around with it and lemme know what can be better
08:00:54 <lortabac> kosmikus: unrelated question, what happened to the idea in the "Open data types and open functions" paper? Is there a reason why it has never been implemented?
08:03:07 <mbwgh> merijn: A first thought would be to try to generalize IO of course, since then you would be able to write tests using `dejafu`. But then you might descend in to the monad-trans-control-hell...
08:04:54 <mbwgh> merijn: How does your package relate to the existing conduit concurrency package? And, say, things like streamly?
08:05:52 <merijn> mbwgh: What's the name of the conduit concurrency one?
08:06:04 <kosmikus> lortabac: well, let's say it's not entirely trivial to implement. it would require quite a bit of time and dedication to implement it in any good way (i.e., make it work well with separate compilation, still have efficient pattern matching, etc). spj wasn't strictly against it, but also let's say somewhat skeptical it would work out well. personally, I ended up never having quite enough time to pursue
08:06:10 <kosmikus> this, and I also never found anyone enthusiastic enough who would want to take it on instead.
08:06:31 <merijn> mbwgh: You mean stm-conduit?
08:06:43 <kosmikus> lortabac: so I don't think there's any deep reason why it couldn't work at all, and from time to time I still would like to have just that, and am tempted to go back to it. but it isn't a question of finding just one free weekend ...
08:07:27 <mbwgh> merijn: I think so, yes.
08:07:53 <mbwgh> mxf: To be fair, the thing you are speaking of is in a separate package you don't have to use, `streaming-bytestring`
08:07:54 <merijn> mbwgh: That one tries to decouple different sections of your pipeline so that your producer can keep producing without blocking while the consumer is busy
08:08:24 <merijn> mbwgh: My code runs the same IO function in parallel as a single stage of a regular conduit
08:09:04 <merijn> mbwgh: Say I have "fetchURL :: URL -> IO Result", now obviously fetching a URL is rather slow, so if I'd stream a million URLs and sequentially fetch them, that'd suck
08:09:37 <mxf> mbwgh, yes, but as far as I could tell, the ecosystem kind of used it in place of bytestring. But that was several months ago, so things might have changed
08:09:44 <merijn> mbwgh: So parMapM basically says "right, I'm gonna process N URLs in parallel and as soon as one finishes, start the next one"
08:10:32 <merijn> mbwgh: So you'd expect a million URLs to take 1,000,000/N time units, instead of 1,000,000
08:10:41 <mbwgh> merijn: And stm-conduit doesn't do that?
08:10:50 <merijn> (Of course this means you sacrifice ordering, so results might come out in a different order)
08:10:55 <lortabac> kosmikus: that's a pity, this paper was a kind of revelation to me :) I think it could simplify lots of code that uses type-classes to allow extensibility
08:10:55 <mxf> merijn, is there a difference in feature sets between broadcast-chan-{conduit,pipes}?
08:11:34 <merijn> mxf: Yeah, the pipes one produces a parser and is honestly kinda meh to use, because pipes doesn't really let you write the kinda code you want for this
08:11:52 <mbwgh> merijn: And it sounds like you might be able to generalize IO to Applicative, at first glance
08:12:21 <kosmikus> lortabac: thanks for the kind words. and yes, as I said, I'm still occasionally tempted to revisit it. but so far, never enough to actually do it :)
08:12:33 <merijn> mbwgh: Not easily, because I'm using IO heavily in the threading
08:12:36 <mxf> merijn, ah, I see, fair enough.
08:13:22 <merijn> I'm actually planning to update this to work with MonadUnliftIO, but I haven't had the time
08:13:47 <merijn> mxf: I actually asked Tekmo to make it easier to support pipes, but he doesn't want to
08:14:01 <merijn> https://github.com/Gabriel439/Haskell-Pipes-Safe-Library/issues/34
08:14:40 <merijn> Then you would be able to use any UnlifIO instance as the function result
08:14:51 <merijn> Which would be nice with stuff like monad-logger
08:15:37 <cocreature> I kind of like the attitude in the Haskell system of always wanting to get things right instead of just working but sometimes it can just be annoying as hell …
08:15:40 <merijn> I've considered just dropping pipes because it's making my life so difficult
08:15:55 <merijn> cocreature: To be fair, here it wouldn't even be less right
08:16:14 <merijn> cocreature: Like, the dependency footprint is trivial and it doesn't even change the implementation of SafeT
08:17:12 <cocreature> merijn: yeah but “I'm not convinced that UnliftIO is the correct abstraction. I think the correct abstraction is either MonadManaged” very much reflects the attitude that I was referring to
08:17:22 <mxf> Well, I guess I can understand both viewpoints, that's a tough call to make
08:17:44 <mxf> otoh, that leads to a gazillion streaming libraries
08:18:05 <merijn> I've heard machines is nice, but it doesn't have enough ecosystem support right now
08:18:29 <mxf> (just noticed a few days ago that hasql has another streaming library)
08:18:52 <merijn> cocreature: OTOH UnliftIO is a time-proven abstraction that's at least workable and has wide support and almost no cost
08:19:05 <cocreature> one of the biggest proponents of machines is no longer around here :(
08:19:16 <merijn> cocreature: MonadManaged OTOH is a real bitch to use in my experience
08:19:59 <merijn> Because you can't return anything from Managed safely, and lifting everything into Managed is also a PITA
08:20:33 * hackage cabal-lenses 0.8.0 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.8.0 (DanielTrstenjak)
08:20:51 <cocreature> merijn: oh I entirely agree that the instance should be added. no need to convince me :)
08:21:48 <mbwgh> How old is UnliftIO? I thought it was a newer replacement for things like monad-control? But you called it time-proven, so I am most certainly mixing things up right now.
08:22:03 <merijn> mbwgh: UnliftIO itself is new
08:22:16 <merijn> mbwgh: The pattern it implements is not
08:23:04 <merijn> mbwgh: So UnliftIO itself isn't really "time-proven", but it's approach/implementation is
08:23:16 <merijn> Which is why it's seen rather rapid adoption
08:23:45 <merijn> Because it's an obviously sensible approach and the core lib is so light on dependencies it costs very little to support
08:24:09 <merijn> (i.e. only base and transformers and basically everyone already depend on those anyway)
08:24:30 <GobGobGobbbyyyy> Cale: I used the type in a hedgehog generator
08:26:46 <Cale> GobGobGobbbyyyy: Yeah, the warning is just about the way in which you're importing the type
08:27:12 <Cale> GobGobGobbbyyyy: You're apparently trying to import its data constructors, but the data constructors were never exported in the first place for you to be able to do that
08:27:50 <GobGobGobbbyyyy> oh so i need to export the data type in that module im imported the data type from
08:28:00 <Cale> It doesn't sound like you need the data constructors, only the type
08:28:01 <GobGobGobbbyyyy> im importing*****
08:28:03 <Cale> So only import the type
08:28:26 <Cale> (which is all you can do anyway, unless you change it so that you're exporting the data constructors as well)
08:28:33 * hackage cabal-cargs 1.0.0 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-1.0.0 (DanielTrstenjak)
08:28:43 <Cale> What does your import declaration look like?
08:28:57 <GobGobGobbbyyyy> Cale: So change TypeIWant (..) to TypeIWant
08:29:01 <Cale> yes
08:29:06 <GobGobGobbbyyyy> thanks
08:29:22 <mbwgh> merijn: In the app I wrote that I mentioned before, I had the following situation. I was fooling around with `MonadLogger` and `MonadHttp` classes "for learning purposes". This lead to the interesting situation where I had to pass an IO action to a GTK handler and I had to reify a partially applied logging function with `Monadlogger m, m ~ IO`. Or something similar like that. It made the whole abstraction
08:29:27 <mbwgh> crumble. And indeed, monad-logger turns out to have some `MonadLoggerIO` class. Is this something that `UnliftIO` would have addressed? I have become very vary of mtl-style effect modeling, especially if the concrete instance boils down to some ReaderT...
08:30:33 <mbwgh> *wary
08:30:37 <merijn> mbwgh: unliftIO basically gives you "m a -> IO a", so yes that'd solve this issue
08:31:14 <merijn> mbwgh: UnliftIO basically only really works for ReaderT-like transformers that can be losslessly "unwrapped" to IO
08:31:35 <merijn> mbwgh: So all the manual getting and passing on of logging stuff would be handled by UnliftIO
08:31:53 <merijn> mbwgh: (indeed, LoggingT is an UnliftIO instance in recent versions)
08:33:03 * hackage extra 1.6.8 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.6.8 (NeilMitchell)
08:33:25 <mbwgh> merijn: Just to get an additional opinion on this (I have already heard people talk from the other side of the "opinion fence"), why would you prefer mtl-style effect modeling to things that have been described as "Service Pattern" or "Handle Pattern"?
08:33:43 <mbwgh> merijn: Assuming you do, of course
08:33:50 <merijn> I don't like mtl-style modelling :p
08:34:05 <merijn> I prefer concrete transformer stacks to typeclass polymorphic bollocks
08:34:44 <merijn> I like the handle pattern, but I don't like always having to manually pass it everywhere. And if you stuff the handle inside a ReaderT to avoid that, then you basically already have UnliftIO
08:34:57 <merijn> mbwgh: So I'd argue UnliftIO *is* the handle pattern
08:37:40 <[exa]> hm guys, any good library for working with quaternions?
08:37:53 <zezeri> hello
08:37:58 <zezeri> question to IRL haskell users
08:38:02 <[exa]> (possibly octonions, sedonions, etc)
08:38:09 <zezeri> do ppl actually code extremeley concise code ?
08:38:15 <zezeri> as in one line that does a ton of complicated shit
08:38:32 <zezeri> it seems so much harder to read and understand vs breaking it up and doing it in multiple lines
08:39:08 <[exa]> zezeri: some other languages take lots of code to express a simple idea. Simple stuff should take 1 line.
08:39:15 <merijn> zezeri: I prefer not too, but the line between "1 line of complicated shit" and "an elegant pointfree formulation of the problem" varies per person :)
08:40:03 <[exa]> zezeri: extremely compressed code is not usually desired, but seeing the algorithm in a 'simple&readable' form usually helps a lot
08:40:25 <zezeri> alright :) So I guess it depends, as usual
08:41:01 <[exa]> zezeri: a nice example, if you know the tarjan's scc algorithm: http://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Graph.html#scc
08:41:12 <zezeri> I am asking because i am currently trying to do a function that in 1 line takes a list of ints and returns a list of lists that contain all the factors of said ints.
08:41:19 <zezeri> And while that solution will likely be elegant
08:41:25 <zezeri> it will also be complicated af probably D
08:41:26 <zezeri> :D
08:41:33 <zezeri> cheers, will check it out
08:41:43 <exarkun> do you have a function that can measure elegance
08:42:28 <[exa]> zezeri: your english description of the problem doesn't fit on 1 line, you can't expect the haskell description to fit
08:42:53 <zezeri> elegance is a function that is approaching infinity as you approach writing the least lines/letters :D?
08:43:19 <exarkun> That sounds like "shortness"
08:43:21 <zezeri> lol
08:43:23 <zezeri> it does ,yes
08:43:24 <[exa]> zezeri: did you see the auto-gzipped code in php exploits? you'd love that
08:43:36 <exarkun> Are "short" and "elegant" synonyms?
08:44:03 <zezeri> No they are not - I just mentioned the first thing I thought of.
08:44:50 <mbwgh> merijn: Interesting. So you use UnliftIO not out of necessity, but because every ReaderT-like dictionary can be restored by it, *and* you don't have to pass them explicitely, giving you the best of both worlds? Did I understand that correctly?
08:45:06 <[exa]> hoogle quaternion -> no results?
08:45:12 * [exa] sad
08:45:35 <[exa]> oh, it's in cayley-dickson
08:45:46 <mjoldfield> [exa] : There's at least one geometric algebra library floating around, and the quaternions are just the bivectors in R3
08:47:31 <mbwgh> zezeri: You can use point-free style and still be descriptive. After all you can write f = g . h where g x = ... . And give type signatures to the functions, or use descriptive argument names.
08:48:03 <zezeri> yes descriptive argument names are important af
08:48:06 <mbwgh> And use names other than g and h...
08:48:13 <zezeri> please
08:48:24 <zezeri> a,b,g,f,x,xs,y,ys is all i need ;)
08:49:36 <mjoldfield> zezeri: What would you call a list of xs ?
08:49:38 <mjoldfield> :)
08:50:05 <zezeri> xsxs  ;D?
08:50:35 <mbwgh> zezeri: I think it depends on factors like: Is a type-signature directly above? How far away is the current use of the name from its type? If I have f :: String -> Bool; f s = ... the name 's' is perfectly fine I think. Instead of refining the name 's' to something like 'Name', I would rather define a type synonym for 'String' or a newtype and change the type signature accordingly.
08:51:48 <__monty__> I keep writing pointfree monstrosities in the hopes my brain'll just get used to them and everyone'll think I'm a wizard.
08:51:58 <mbwgh> zezeri: Of course, if the usage of 's' is far away from the type signature, the function might just be too long.
08:53:31 <mbwgh> __monty__: I sometimes write stuff like (f .) . g without thinking about it. Afterwards I don't know how I came up with it and change it to pointed style
08:54:25 <__monty__> mbwgh: I just spend 10 min re-understanding them every time : )
08:54:45 <zezeri> lmao :D
08:56:43 <zezeri> [exa] "your english description of the problem doesn't fit on 1 line, you can't expect the haskell description to fit"
08:56:52 <zezeri> It is definitely possible to do it in one line tho :P
08:56:59 <zezeri> maybe it is a long line.
08:58:56 <[exa]> zezeri: please don't do long lines
08:59:09 <[exa]> zezeri: do you like to buy books printed on a 10km tape?
08:59:33 <exarkun> How do I use shouldRespondWith to match a response body and header?  https://hackage.haskell.org/package/hspec-wai-0.9.0/docs/Test-Hspec-Wai.html
08:59:36 <exarkun> The example does not compile.
08:59:50 <zezeri> you are correct, i do expect the function to not end up being *too* long. I hope anyways.
09:00:16 <exarkun> "Couldn't match type ‘[Char]’ with ‘ResponseMatcher’"
09:00:58 <mbwgh> exarkun: ResponseMatcher seems to implement IsString.
09:01:10 <mbwgh> exarkun: Try turning on -XOverloadedStrings
09:01:11 <__monty__> zezeri: `map (\n -> [i | i <- [1..n], mod n i == 0])` Not efficient but it's a one-liner.
09:01:37 <exarkun> I think I have it turned on.  {-# LANGUAGE OverloadedStrings #-}
09:01:53 <exarkun> Do I have to import something?
09:02:16 <zezeri> thank you :) I will compare that to the solution i come u with^^
09:03:06 <mbwgh> exarkun: If it is not a string literal, you probably have to use `fromString` yourself and may have to import something like Data.String I think. Or GHC.Exts.
09:03:22 <exarkun> ah
09:04:19 <oisdk> Anyone have familiarity with the internals of Data.Functor.Rep? (in adjunctions) The Rep used for Cofree is Data.Sequence, but from what I can tell it only needs a list (http://hackage.haskell.org/package/adjunctions-4.4/docs/src/Data-Functor-Rep.html#line-380). Anyone know why that might be?
09:04:35 <mbwgh> exarkun: Just to be on the safe side, which example are you looking at?
09:06:18 <exarkun> mbwgh: get "/" `shouldRespondWith` "foo" {matchStatus = 404}
09:06:22 <exarkun> mbwgh: mostly
09:06:33 * hackage cabal-bounds 2.0.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-2.0.0 (DanielTrstenjak)
09:06:34 <exarkun> mbwgh: my code is slightly different, I'm trying to override matchStatus and matchHeaders
09:06:53 <exarkun> mbwgh: I think you got it with your comment about string literals.  I was not using a string literal.
09:07:24 <exarkun> I changed the type of the variable from String to ResponseMatcher (itself defined with a literal) and it's happy now
09:07:41 <Franciman> Hi
09:07:47 <mbwgh> exarkun: Great.
09:07:50 <Franciman> Is anybody using haskell in augmented reality projects?
09:08:19 <mbwgh> If by augmented reality you mean category theory...
09:08:27 <Franciman> :P
09:08:46 <Franciman> teach me to use category theory in haskell!
09:08:56 <Franciman> Or maybe it's the opposite, use haskell in category theory
09:10:14 <sm> someone is using it for VR anyway.. rumpus
09:10:31 <Franciman> thank you
09:11:09 <mbwgh> Franciman: Bartosz Milewski's book "Category Theory for Programmers" uses Haskell to explain concepts. But only after working through examples of Conor McBride's Agda course you realize just how far away we still are from expressing a lot of the math
09:11:55 <mbwgh> And I do not mean Unicode...
09:12:00 <Franciman> lol
09:12:05 <Franciman> thank mbwgh will do it
09:12:13 <Franciman> I'm reading CT for programmers
09:12:30 <Franciman> my main concern so far was: how can I make this stuff useful for my programming
09:12:42 <Franciman> for now I haven't yet been able to design my code in a super smooth way using CT
09:13:14 <EvanR> so far its a big theme is interface vs implementation
09:13:25 <EvanR> you want to be dealing interfaces, and the right interfaces, as much as you can
09:13:47 <EvanR> dealing with
09:13:59 <Franciman> I see, as far as I understood, you say: my ADT has these operations
09:14:07 <Franciman> oh it's a LONGCATEGORICNAME
09:14:39 <mbwgh> Hmm. You may appreciate that haskell ADTs form a semi-ring, by virtue of Hask being a bicartesian closed category. Or that by parametricity, for some function fun :: F a -> G a where F and G are functors, satisfy the naturality condition `fmap f . fun = fun . fmap f`. Things like that.
09:14:41 <EvanR> i still have not gotten much farther than yeah "that there thing is identified as a NAME"
09:14:47 <Franciman> or maybe you have an ADT and see that you can define other primitive operations to make working with it more comfortable, because it has categoric properties
09:15:55 <AWizzArd> I am looking for an example for an Expr type that goes beyond the classical example (Var, Lit, Add, Sub, Mul). This could work but I want an EDSL that makes tens if not hundreds of functions available. It would be a bit time consuming to add them all to Expr.
09:16:27 <EvanR> do the hundreds of "functions" all have the same signature
09:16:38 <mbwgh> Franciman: I think there is a lot of work to do before you really can come up with new abstractions yourself. But then, the Simps, er, ekmett will already have done it.
09:16:47 <EvanR> you could have a Binop and Unop expression which contains the operation as a component
09:16:49 <AWizzArd> EvanR: I am actually not sure
09:17:02 <Franciman> ahah got it
09:17:15 <AWizzArd> EvanR: yeah, I was thinking about Call1, Call2 and Call3 – the `n` indicates how many arguments the fn takes.
09:17:18 <Franciman> thanks mbwgh and EvanR
09:17:28 <iqubic> Does haskell have a promise functionality, like in JS?
09:17:40 <cocreature> iqubic: take a look at the "async" package
09:18:31 <AWizzArd> iqubic: also nice is this one, as it gives some examples in a way that is nice to digest: https://www.youtube.com/watch?v=DebDaiYev2M
09:19:04 <mbwgh> cue: Simon Marlow's book
09:19:43 <mbwgh> Really this should be lambdabot's job
09:19:50 <iqubic> cocreature: Async looks like it is only for IO. Is that what we what?
09:19:53 <EvanR> @where simon marlow's book
09:19:54 <lambdabot> I know nothing about simon.
09:20:03 <cocreature> iqubic: well I don’t know what you want :)
09:20:10 <EvanR> iqubic: time to define what a promise is
09:20:24 <EvanR> i mean, IO a could be a promise
09:21:12 <cocreature> I don’t think it makes sense to use JS promises for non-IO things so if you want to replicate their functionality, IO seems appropriate
09:21:18 <EvanR> JS has a couple things backwards which require things that require nothing in haskell
09:21:52 <EvanR> and they keep inventing new things to do the things that require nothing in haskell
09:22:13 <iqubic> EvanR: Can you elaborate, with an example?
09:22:55 <EvanR> coroutines, callbacks, promises, web workers
09:23:05 <EvanR> probably stuff i dont know about yet
09:23:52 <mbwgh> "futures are a monad"
09:23:56 <EvanR> futures
09:24:35 <AWizzArd> And monads are just lax functors from a terminal bicategory.
09:24:40 <iqubic> Futures are a monad? Wait what?!?
09:24:47 <EvanR> of course
09:25:03 * hackage rtcm 0.2.17 - Haskell bindings for RTCM.  http://hackage.haskell.org/package/rtcm-0.2.17 (markfine)
09:25:21 <iqubic> But what operations does future support?
09:25:28 <mbwgh> Async only implements functor I think. But you give it an IO action, so...
09:26:06 <EvanR> iqubic: i think were in a tarpit of jargon right now, until you specify what features YOU want, you might be overlooking simply haskell's IO type
09:26:32 <mbwgh> I think in C++ they wanted to add an std::then or std::future::then, but I don't know if that is reality already
09:26:34 <EvanR> called something or other isnt a feature
09:27:17 <cocreature> mbwgh: async used to provide a Monad instance for Concurrently but they dropped it because it doesn’t match the Applicative instance (which runs things in parallel)
09:27:33 <EvanR> iqubic: did you look at the first screen of the async haddocks
09:28:04 <iqubic> EvanR: I want a wait to run a number of IO functions in parallel, and wait for all of them to finish, before continuing.
09:28:18 <byorgey> mgttlinger: yes, but that library also defines the Concurrently wrapper which is Applicative and Alternative
09:28:21 <mbwgh> cocreature: Ah, interesting
09:28:23 <EvanR> theres a operation for that in async
09:29:07 <cocreature> iqubic: take a look at mapConcurrently
09:29:58 <mbwgh> But that will spawn N asyncs, no? If these map to something like http requests, that might not be what you want
09:30:30 <zezeri> https://pastebin.com/muxviHjt
09:30:34 <zezeri> Anyone know what I am doing wronG?
09:31:15 <EvanR> that sounds exactly like what they want
09:31:29 <cocreature> mbwgh: if you want to limit the number of concurrent operations you can use the async-pool package
09:32:00 <byorgey> zezeri: did you paste the right code?  mod x == 0  is a type error.
09:32:09 <mbwgh> zezeri: What does `mod` do? Is it a partially applied .. `mod` ?
09:32:52 <iqubic> Is there a version of waitBoth :: IO a -> IO b -> IO (a, b) that works with lists?
09:33:12 <exarkun> iqubic: not that I could find
09:33:19 <iqubic> So like waitAll :: [IO a] -> IO [a]
09:33:19 <byorgey> zezeri: also, 11487 > 10000 so it is not included in the list [3829 .. 10000]
09:33:26 <byorgey> zezeri: perhaps did you forget a zero?
09:33:38 <zezeri> omg
09:33:40 <zezeri> i forgot a zero.
09:33:41 <zezeri> lmfao
09:33:44 <zezeri> thank you :D
09:33:52 <byorgey> sure =)
09:34:18 <zezeri> also byorgey and mbwgh: the mod function takes two integers and returns the remainder. `mod` is the same but just as infer function.
09:34:25 <zezeri> it is correct syntax actually
09:34:31 <zezeri> unless im missing something
09:34:32 <zezeri> :)
09:34:49 <zezeri> oh man if i commit small errors at this level
09:34:56 <byorgey> zezeri: yes, it takes *two* integers.  In the code you pasted, you are only giving it one argument
09:35:04 <zezeri> no i am giving it 2 arguments
09:35:12 <zezeri> x (from the list) and 3829
09:35:15 <zezeri> that is two arugments
09:35:15 <zezeri> :)
09:35:19 <mbwgh> you wrote mod x == 0
09:35:23 <iqubic> Is it possible for me to write my hypothetical waitAll function myself? Or should I just use mapConcurrently?
09:35:24 <byorgey> zezeri: in your paste https://pastebin.com/muxviHjt  I see  mod x == 0
09:35:29 <zezeri> oh my
09:35:32 <zezeri> apologies
09:35:37 <zezeri> i somehow cut out the 3829
09:35:42 <zezeri> bad day for coding apparently
09:35:42 <zezeri> :D
09:35:44 <mbwgh> impliying 0 == (mod x :: Integral a => a)
09:35:45 <byorgey> zezeri: ok, no worries =)
09:35:54 <zezeri> thank you all for being so attentive :)
09:35:58 <asheshambasta> Hi Haskellers. Looks like I've spent 5-6 months with learning Haskell and I'm currently writing a Production Haskell service for a side project. Moreover, I find myself shifting to Emacs from IntelliJ.
09:36:04 * hackage zip 1.1.0 - Operations on zip archives  http://hackage.haskell.org/package/zip-1.1.0 (mrkkrp)
09:36:04 <asheshambasta> Just wanted to share that.
09:36:11 <byorgey> asheshambasta: congrats =)
09:36:39 <asheshambasta> byorgey: thanks
09:36:47 <asheshambasta> and by far, this is the most helpful community I've seen
09:36:57 <asheshambasta> (I come from, ahem, Scala)
09:37:00 <iqubic> Wait, I'm stupid, mapConcurrently is exactly what I want. Or perhaps forConcurrently.
09:37:40 <mbwgh> There is no stupidity, there is just having not stared at the types not long enough
09:37:41 <AWizzArd> asheshambasta: welcome at Emacs.
09:37:49 <mbwgh> and grammar
09:37:56 <iqubic> (Semigroup a, Monoid a) => Monoid (Concurrently a)
09:38:18 <iqubic> Why do you need both constraints? Can't you get by with just Monoid a?
09:38:23 <mbwgh> When will Monoid imply Semigroup?
09:38:36 <mbwgh> 8.6? 8.4?
09:38:46 <asheshambasta> AWizzArd: thanks!
09:39:07 <mbwgh> iqubic: The integration of Semigroup is still an on-going process
09:39:36 <cocreature> mbwgh: in 8.4 that’s already the case
09:39:38 <asheshambasta> I must thank kuribas (offline) for meeting me for a beer and introducing me to Haskell in Emacs though
09:39:44 <mbwgh> Ah, great.
09:39:57 <iqubic> You live close enough to meet up?
09:40:14 <mbwgh> I wish I knew Haskellers irl
09:40:23 <asheshambasta> iqubic: we're both in Belgium, and we're a tiny country
09:40:43 <asheshambasta> iqubic: and we have the best beers in the world
09:40:53 <iqubic> Yes, that's right.
09:41:19 <t7> incorrect
09:42:09 <asheshambasta> but wow, after struggling with tooling in an IDE (IntelliJ), getting things to work in Emacs is so wonderful
09:42:55 <shapr> after this summer's work on haskell-ide-engine, I expect haskell+emacs to be even better
09:42:57 <AWizzArd> asheshambasta: some of us here at work do irc, bash, slack and emails via Emacs (-:
09:43:06 <AWizzArd> shapr: that sounds very good
09:43:16 <mbwgh> People always bitch about Haskell tooling, and have yet to experience FORTRAAAN
09:43:34 <Franciman> holy words
09:44:17 <asheshambasta> AWizzArd: I'd love to do that too — I'm all for simplifying my life with the bunch of tools I'm being forced to use for work
09:44:33 <asheshambasta> and the less the number of tools that run JS on my computer and hog resources, the better
09:44:44 <mbwgh> Oh and I just learned the other day that free form Fortran is still fixed-width fortran with an increased maximum line length
09:45:10 <AWizzArd> shapr: can you hint what work you expect to be done over the summer on HIE?
09:45:21 <asheshambasta> shapr: +! AWizzArd
09:45:27 <asheshambasta> +1 **
09:45:49 <shapr> AWizzArd: alanz is the coordinator for that effort, and the discussion happens on #haskell-ide-engine
09:46:08 <AWizzArd> k
09:46:21 <shapr> AWizzArd: have you seen the cool stuff on https://github.com/haskell/haskell-ide-engine ?
09:46:51 <AWizzArd> shapr: si – I scrolled through the animations.
09:47:28 <iqubic> does that work with emacs?
09:47:46 <AWizzArd> shapr: I am interested to see what kinds of automatic refactorings we can get out of hie.
09:47:51 <shapr> it does, though it was a pain to setup when I gave a lightning talk about refactoring browsers a few months ago
09:48:11 <shapr> AWizzArd: the ones with support work great, but I really wish for "extract selection to function"
09:48:16 <shapr> I'm not sure if HaRe supports that or not
09:55:18 <iqubic> When people encounter issues with IO, they think "I'll use threads" now they have "owt polrbms"
09:55:50 <mbwgh> What kind of issues with IO?
09:56:21 <Franciman> mutable state?
09:57:07 <iqubic> Franciman: Yes. Haskell and mutable state is kinda terrible.
10:01:20 <gazanga> hello. can i say that (.) is the opposite of function types? (.) is like f (g (h (i))) (from right to left), but function types are from the left yes? for example: fun :: (a -> b) -> c -> n, is doing at first the function (first argument to fun) and then it return a function that takes c and then it return n, so it's left from right. am i right till now?
10:02:32 <xlii> i think you mean fun :: (a -> b) -> (c -> n)
10:02:34 <gazanga> if i am right isn't it a paradox that (.) itself in the definition id from left to right but actually it operate from right to left
10:02:46 <gazanga> id = is
10:03:09 <gazanga> xlii: why does it matter?
10:03:31 <xlii> fun :: (a -> b) -> c -> n returns an arbitrary type n
10:03:37 <xlii> and c becomes a parameter
10:03:50 <xlii> the last argument is always the return type
10:03:50 <cocreature> (a -> b) -> c -> n and (a -> b) -> (c -> n) are equivalent
10:04:07 <xlii> why though
10:04:22 <cocreature> because that’s how Haskell syntax works :)
10:04:33 <cocreature> a -> b -> c is equivalent to a -> (b -> c)
10:04:41 <Lears> The brackets are just implicit in the former. (->) is a binary operation.
10:05:22 <xlii> confusing
10:06:11 <xlii> cocreature: do you know how to use the (x:xs) notation in a function that gets a list of tuples?
10:06:12 <cocreature> xlii: that’s why you can use "(+) 1" to get a function that adds 1 to its argument
10:06:36 <cocreature> xlii: do you have some code that’s causing problems? I’m not sure I understand the question
10:07:37 <gazanga> xlii: fun :: a -> b -> c -- is a function that takes `a` and return a function that takes `b` and return `c`. fun' :: a -> (b -> c) is again function that takes `a` and return a function that takes `b` and return `c`.
10:07:53 <mxf> gazanga, (.) works like that, because that's how compose works in maths, or so I am told. You can pronounce it "after" if that makes more sense to you
10:08:05 <xlii> makes sense
10:09:08 <gazanga> mxf yes i know. it is strange that in the definition its from left to right but in practice its the oppopsite.
10:09:38 <cocreature> gazanga: what exactly do you mean by “in the definition”?
10:09:47 <mxf> It would be fun if you could flip the arrows ;)
10:09:50 <gazanga> the type signature of the function.
10:10:02 <dukedave> Forgive the vagueness: What's the property (law?) called which means you can (given referential transparency), substitute out a function's definition with a call to it?
10:10:04 <gazanga> cocreature ^^
10:10:29 <gazanga> :t (.)
10:10:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:10:58 <mxf> (.) :: c <- a <- (b <- a) <- (c <- b)
10:11:01 * mxf runs
10:11:17 <cocreature> gazanga: so what you find confusing is that (b -> c) comes before (a -> b) in the type signature but the function of type a -> b is applied first?
10:11:24 <cocreature> mxf: you can run but you can’t hide!
10:11:26 <gazanga> it's like this: (((b -> c) -> (a -> b)) -> a -> c) yes?
10:12:09 <cocreature> gazanga: no it’s equivalent to (b -> c) -> ((a -> b) -> (a -> c))
10:12:25 <cocreature> dukedave: isn’t that exactly referential transparency?
10:12:40 <cocreature> dukedave: to quote wikipedia: “An expression is said to be referentially transparent if it can be replaced with its corresponding value without changing the program's behavior.”
10:13:26 <gazanga> cocreature es you are right i meant what you said, it is left to right but applied right to left. and also ehat you say is confusing but it is how the function defined i suppose.
10:13:31 <gazanga> es =yes
10:13:46 <gazanga> ehat = what
10:14:05 <cocreature> gazanga: the order might make more sense if you look at the fact that (f . g) x = f (g x)
10:14:13 <gazanga> it's like f y z = f z y
10:14:26 <iqubic> Not really.
10:15:05 <mxf> gazanga, what would you want the type signature to look like?
10:15:27 <gazanga> cocreature: yes this i understand. but still it's strange as contrary to other functions (i think)
10:15:37 <gazanga> mxf i don't know :-)
10:16:09 <gazanga> `on the contrary` i think is more accurate
10:17:40 <cocreature> gazanga: fwiw there are packages that define a flipped version of (.), e.g., https://hackage.haskell.org/package/flow-1.0.12/docs/Flow.html#v:.-62-
10:18:17 <cocreature> but then you have (f .> g) x = g (f x) and I’m not sure that’s less confusing
10:18:19 <gazanga> i have a nother question: the ($) is of type (a -> b) -> a -> b (if i recall). i understand that it is like `do parentesis from here to end` but if i just look at the type sugnature it is not seems like that. also how can i benefit from this: (>3) $ 4 -- what is the advantage of this ($) operator.
10:18:43 <gazanga> cocreature: it is more confusing. i dont know what is (.>)
10:18:55 <cocreature> gazanga: take a look at the link I posted
10:19:42 <mbwgh> gazanga: You might be more comfortable with Control.Arrow.>>>, which denotes diagrammatic composition (f >>> g) instead of (g . f). But in practice it is less awkward to work with Data.Function.&, which is just (flip ($)), that is, reversed function application. Then You can write things like f x & (\y -> g y & (\z -> h z)). And eta-reduction makes this f x & g & h. Instead of (h . g . f) x.
10:19:48 <cocreature> there is no benefit to using "($)" in "(>3) $ 4". "(>3) 4" works just as well
10:20:04 <cocreature> ($) makes sense if you have a compound expression on the right
10:20:14 <cocreature> e.g. (>3) $ 2 + 2
10:20:22 <gazanga> cocreature: so (.>) is like (((f g) h) z )?
10:20:52 <cocreature> without ($) that would be parsed as ((>3) 2) + 2
10:21:08 <mbwgh> or you have more than 3 dollars
10:21:33 <cocreature> gazanga: where are f, g, h and z coming from here and how are they applied to (.>)? I’ve shown the definition of (.>) above: (f .> g) x = g (f x)
10:22:36 <gazanga> cocreature: understood.
10:23:16 <mxf> gazanga, ($) is nothing more than syntactic sugar, to avoid having a closing paren. Often used together with a do block for example.
10:23:56 <gazanga> mbwgh: thanks. i think i sort of understand what you said :)
10:24:00 <mbwgh> Or if you want to map function application, for instance `map ($ 2) [(*2), (+2), (^2)]`.
10:24:07 <mxf> there are use cases for ($) as a function, but I find those confusing, tbh
10:24:33 <gazanga> mxf but from the type signature ( (a -> b) -> a -> b) how can i see it?
10:24:41 <mbwgh> gazanga: It is also interesting to note the similarity between (&) and (>>=)!
10:24:45 <cocreature> gazanga: it’s also worth pointing out that the fact that ($) behaves the way it does is not related to its type or its definition but to the fact that it’s precedence is declared as "infixr 0 $"
10:25:17 <mxf> hah, yes, that's very important to know :)
10:25:57 <gazanga> what does it mean cocreature? what is precedence 0?
10:26:10 <cocreature> it’s the lowest precedence level in Haskell
10:26:37 <cocreature> which means that if you have something like "f $ x + y" it will be parsed as "f $ (x + y)" because (+) has a higher precedence
10:26:48 <mxf> gazanga, I parse `(a -> b)` as f. than it takes another a. you plug that into f. f returns b, and that's what ($) returns
10:27:02 <quicksilver> $ is occasionally useful as a section.
10:27:06 <mbwgh> gazanga: Like (*) having a higher precedence (is evaluated prior to) (+). infixr or infixl denote the difference between an operator, say, (+), evaluated as x + (y + z) or (x + y) + z.
10:27:29 <quicksilver> > map ($[1,2,3][D9,10,11) [length,head]
10:27:30 <mxf> gazanga, same with (.), that's why it's starts with (b -> c) and not with (a -> b)
10:27:31 <lambdabot>  <hint>:1:16: error: lexical error at character '\DEL'
10:27:48 <quicksilver> > map ($[9,]10,11) [length,head]
10:27:50 <lambdabot>  <hint>:1:8: error: lexical error at character '\DEL'
10:27:53 <quicksilver> wow
10:28:26 <quicksilver> mosh is not doing well here
10:28:26 <mxf> gazanga, does that make any sense?
10:28:33 <gazanga> what will hapen if the $ will have the biggest precedence?
10:28:45 <quicksilver> > map ($[9,10,11]) [length,head]
10:28:47 <lambdabot>  [3,9]
10:29:03 <cocreature> gazanga: if ($) had higher precedence than (+) then f $ x + y would be parsed as (f $ x) + y
10:29:54 <mbwgh> And f . g $ x would parse as f . (g $ x), yielding f . y, a type error
10:30:15 <cocreature> mbwgh: depends on the type of g :)
10:30:59 <mbwgh> True :P
10:31:29 <gazanga> what is the precedence of parentecise?
10:31:51 <gazanga> parentesis(?)*
10:31:57 <mbwgh> There is no parens operator. You might refer to things like (,) though. Is that it?
10:32:05 <mbwgh> :i (,)
10:32:15 <gazanga> mxf i need to think about it. it's not very clear :-)
10:32:53 <mbwgh> I don't think fixity makes sense for (,), scratch that
10:33:20 <iqubic> :t (,)
10:33:21 <lambdabot> a -> b -> (a, b)
10:33:28 <mbwgh> As a value constructor, it's just a binary function, having highest precedence as is usual for functions.
10:33:36 <iqubic> > , 10 20
10:33:38 <lambdabot>  <hint>:1:1: error: parse error on input ‘,’
10:33:48 <iqubic> > 10, 29
10:33:50 <lambdabot>  <hint>:1:3: error: parse error on input ‘,’
10:33:58 <iqubic> > (10, 20)
10:34:00 <lambdabot>  (10,20)
10:34:10 <iqubic> Why do you have to surround that in parens?
10:34:33 <iqubic> You don't need to surround $ in parens, but it too is an infix operatori.
10:35:02 <gazanga> thanks all for the help for now :-)
10:35:32 <mbwgh> iqubic: Tuple constructors are built-in. Hence, magical. You can't define "mix-fix" operators like that in Haskell. You can define `data _,_ ...` in languages like Agda that support mix-fix notation. But not in Haskell.
10:35:51 <cocreature> mbwgh: they left
10:36:01 <mbwgh> :(
10:37:27 <dmwit> "It's built-in" doesn't explain why it needs parens.
10:37:46 <dmwit> I suspect the answer to that is to clarify what `10,20,30` means.
10:38:15 <mbwgh> Yes, I should've referred to (,,) instead
10:38:27 <dmwit> `(10,20,30)` vs one of `((10,20),30)` or `(10,(20,30))` depending on what associativity you choose.
10:40:54 <dmwit> gazanga: Parens have the highest precedence, then record substitution, then function application, then all infix operators in precedence order after.
10:41:19 <dmwit> "record substitution" probably isn't the right word. "record syntax", maybe?
10:42:03 <mbwgh> dmit: With record substitution, you mean MyRecord { myField = ... } ? In an expression like return MyRecord { ...} where parens aren't necessary?
10:42:21 <Lears> Record updates having higher precedence than function application still irks me. It just looks so wrong.
10:42:31 <Myrl-saki> If I'm looking for a
10:42:32 <gazanga> dmwit: rhanks!
10:42:33 <dmwit> mbwgh: Parens are necessary if it associates the wrong way, of course. =)
10:42:36 <gazanga> *thanks
10:42:39 <Myrl-saki> If I'm looking for a Haskell job, what should I expect?
10:42:55 <dmwit> mbwgh: This is true whether record syntax or function application has higher precedence.
10:43:36 <tdammers> Myrl-saki: the Haskell job market is much smaller than that for mainstream languages, so finding a job could take significantly longer
10:44:42 <dmwit> mbwgh: In Haskell, `f x { y = z }` parses as `f (x { y = z })`, and parens are needed if you intend `(f x) { y = z }` instead. Of course one could imagine another language with the other tradeoff.
10:46:05 <Myrl-saki> tdammers: How much longer do you think would that be? I'm based in SEA, so I practically can only take remote jobs. :/
10:47:24 <gazanga> (.>) :: (a -> b) -> (b -> c) -> a -> c infixl 9. is it means that (.>) is left associative and also most precedence?
10:47:26 <dmwit> Would you consider moving? Galois is hiring, but you'd have to move to Portland, Dayton, or DC.
10:47:34 <mbwgh> dmwit: Thanks for clearing it up. My view about the fixity story was overly simplistic. I could imagine a language that had better records though...
10:48:03 <gazanga> infixl means `left assiciative`?
10:48:14 <dmwit> infixl means left associative, yes.
10:48:24 <gazanga> thanks.
10:48:27 <dmwit> % :i +
10:48:27 <yahb> dmwit: setInteractiveContext; ic_tythings: Identifier `interactive:Ghci16.it'; Identifier `interactive:Ghci15.it'; Identifier `interactive:Ghci14.it'; Identifier `interactive:Ghci13.it'; Identifier `interactive:Ghci12.it'; Identifier `interactive:Ghci11.it'; Identifier `interactive:Ghci10.it'; Identifier `i
10:48:32 <dmwit> oh dear
10:48:36 <mxf> huh
10:48:37 <dmwit> % :quit
10:48:38 <yahb> dmwit:
10:48:41 <dmwit> % :i +
10:48:42 <yahb> dmwit: class Num a where; (+) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 +
10:48:51 <mbwgh> What is happening
10:48:53 <dmwit> > x + y + z
10:48:55 <lambdabot>  x + y + z
10:48:59 <tdammers> Myrl-saki: hard to say. If the right job happens to be around tomorrow, then not very long, but it could easily take a few months, at least if you restrict yourself to actual Haskell jobs (fully committed to using more or less only Haskell)
10:49:04 <dmwit> Oh, right. That didn't show what I wanted it to show at all.
10:49:07 <mxf> oh, you don't have to put infix operators in parens?!
10:49:08 <dmwit> > (x+y) + z
10:49:10 <lambdabot>  x + y + z
10:49:13 <Myrl-saki> dmwit: Not within 5 years, sadly.
10:49:17 <tdammers> Myrl-saki: a lot depends on your skill set too, ofc
10:49:21 <mxf> that changes EVERYTHING
10:49:30 <dmwit> gazanga: There you go, evidence that infixl means left-associative. =P
10:49:40 <dmwit> mxf: eh?
10:50:03 <dmwit> mxf: Oh, did you mean about `:i +`? Yeah. =)
10:50:03 <cocreature> mxf: it only works for :i afaik
10:50:50 <Myrl-saki> tdammers: True, thanks.
10:50:55 <dukedave> cocreature: oh, ha, okay then, I thought there was another term for it, but you're correct, it's just 'referential transparency' :)
10:51:09 <mbwgh> mxf: You can put them in parens if you want to pass them to higher order functions, like `foldl' (+) 0`. Or if you want to use them in prefix form, like in `(+) x y`. Dually, you can put a normal function in backticks if you want to use it in infix form, like in "x `elem` xs".
10:51:14 <gazanga> dmwit i dont understand the evidence
10:51:35 <dmwit> > x + (y+z) -- this requires parentheses, and the output includes them
10:51:36 <gazanga> > (x+y) + z
10:51:37 <lambdabot>  x + (y + z)
10:51:38 <lambdabot>  x + y + z
10:51:45 <dmwit> > (x+y) + z -- this does not require parentheses, and the output does not include them
10:51:46 <gazanga> this? ^^
10:51:48 <lambdabot>  x + y + z
10:52:20 <cocreature> Myrl-saki: I think I have seen a few Haskell jobs in singapore which counts as part of SEA afaik :)
10:52:25 <dmwit> gazanga: Is the accompanying commentary helpful, or are you still confused?
10:52:57 <Myrl-saki> cocreature: We're almost neighbors with SGP, so I'll give that a look. :D
10:53:00 <gazanga> still confuse. is the (+) left associative? that what you want me to see?
10:53:06 <mbwgh> For what it's worth, I don't think people learn fixities off by heart
10:53:25 <dmwit> gazanga: Yes, it is left-associative. Yes that is what I wanted you to see. I also wanted you to see the `infixl` declaration in `:i +`.
10:53:28 <dmwit> % :i +
10:53:29 <yahb> dmwit: class Num a where; (+) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 +
10:53:40 <Myrl-saki> Well, apparently, I got my geography wrong.
10:53:44 <Myrl-saki> But still close enough.
10:53:49 <gazanga> ah dmwit i didn't notice that
10:54:15 <gazanga> wait what is exactly: % :i + dmwit?
10:54:35 <dmwit> The `%` is an IRC-only thing that tells yahb I want it to run the rest of the line in ghci.
10:54:38 <gazanga> it's a "nick" for infixl?
10:54:49 <dmwit> `:i` is a ghci command for learning information about an identifier.
10:54:49 <gazanga> ah
10:55:31 <dmwit> (short for `:info`)
10:55:39 <gazanga> what is yahb?
10:55:46 <dmwit> yet another haskell bot =)
10:55:54 <gazanga> :-D
10:56:01 <mbwgh> When will they make a Lambdaman movie?
10:56:07 <gazanga> i understand.
10:56:10 <gazanga> thanks
10:56:20 <dmwit> I think a play on YAHT, which is an older but still somewhat popular Haskell tutorial. No points for guessing what YAHT stands for. =)
10:56:52 <cocreature> I never get any points :(
10:57:06 <dmwit> cocreature++ pity points for you!
10:57:22 <cocreature> \o/ thanks dmwit!
10:57:41 <dmwit> ?karma cocreature
10:57:41 <lambdabot> cocreature has a karma of 22
10:58:10 <dmwit> I feel lied to, used.
10:58:47 <gazanga> > (x + y) + z
10:58:49 <lambdabot>  x + y + z
10:58:55 <gazanga> > x + (y + z)
10:58:57 <lambdabot>  x + (y + z)
10:59:08 <__monty__> dmwit: Is it take 4 YAHTZEE?
10:59:49 <gazanga> dmwit: can you explain again why they different cases?
11:00:02 <cocreature> dmwit: ofc I only counted dmwit points. all other points don’t count!
11:00:49 <gazanga> wait. the first outputs without parentesis because + is left associative and the prentesis are on the left so no need for them?
11:01:01 <dmwit> right
11:01:05 <dmwit> cocreature: =D
11:01:34 <gazanga> so second need it to keep the hogher precedence of the parentesis to evaluate before the left variable?
11:01:43 <gazanga> hogher = higher
11:02:27 <dmwit> Also right, though this is about how the expression parses and not about how it evaluates.
11:02:43 <gazanga> OK
11:02:45 <dmwit> Those are often closely connected, but the connection is not super duper straightforward.
11:02:53 <gazanga> :()
11:02:58 <gazanga> i meant :-)
11:03:10 <gazanga> (i was in different language)
11:06:23 <mbwgh> dmwit: What are you getting at?
11:07:24 <mizu_no_oto>  Myrl-saki: you might also cast a slightly wider net and look for remote FP jobs in general.
11:08:10 <Myrl-saki> mizu_no_oto: Yeah, I actually prefer remote jobs.
11:08:25 <Myrl-saki> I'm not too efficient working at home
11:08:39 <Myrl-saki> But I'm bad with moving around too.
11:08:48 <Myrl-saki> moving around long distances, I mean.
11:09:34 <mizu_no_oto> There's a number of places doing functional programming in Scala, for example, and at least a couple places using F#, ocaml, etc.
11:09:50 <Myrl-saki> Ohhh, you were talking about other FP languages.
11:10:16 <Myrl-saki> mizu_no_oto: I've had slight experiences with C# and I kinda ejoyed it.
11:10:28 <Myrl-saki> So I'm thinking of taking up F#.
11:18:08 <tdammers> IME, the best way to find Haskell and FP jobs in general is to focus your search
11:18:35 <tdammers> hang out in the relevant forums, subreddits, mailing lists, etc., many jobs are posted there that never reach the job boards
11:19:00 <tdammers> also get in touch with the local programming community, go to meetups and stuff like that, mingle, talk up some people
11:19:38 <tdammers> this isn't going to get you a job immediately, but it's a small world, people know one another, and chances are one thing leads to another at some point
11:19:57 <Myrl-saki> tdammers: Yeah, I've done that last year, but it was a keyboard group. He asked me for my CV. :D
11:20:08 <Myrl-saki> s/group/meetup/
11:20:21 <infinisil> What's a keyboard meetup?
11:20:33 <Myrl-saki> infinisil: We show each other keyboards. Yeah, Weird, right?
11:20:40 <infinisil> Whaaa
11:20:44 <__monty__>  Such a strange fetish.
11:20:49 <Myrl-saki> __monty__: lmao
11:20:50 <tdammers> keyboards as in music, or keyboards as in computers?
11:21:04 <Myrl-saki> tdammers: computers, to make it even weirder. :P
11:21:35 <tdammers> ah, hmm
11:21:40 <tdammers> well that's actually less weird
11:21:56 <tdammers> showing each other music instruments but not playing them, that would be super weird
11:22:01 <Myrl-saki> Lmao
11:22:26 <Myrl-saki> tdammers: FWIW, when we were showing off our keyboards, we got looks from people because a considerable had blue switches.
11:22:39 <woodson> question guys how is the do notation implemented in haskell? if it is syntatic sugar for bind I would like to know how its implemented?
11:23:29 <Myrl-saki> woodson: `do a <- x; y` == `x >>= (\a -> y)`
11:23:33 <Myrl-saki> II
11:23:37 <Myrl-saki> IIRC.
11:23:52 <Myrl-saki> Now that I think about it, it's actually kinda elegant.
11:24:01 <woodson> Myri-saki, I get that
11:24:16 <woodson> I am wondering how the do notation is implemented
11:24:31 <cocreature> woodson: it’s built into ghc
11:24:34 <woodson> I would like to implement a small syntax sugar of mine
11:24:37 <woodson> just wondering how
11:24:41 <woodson> hmm..
11:25:40 <__monty__> I think the only way to introduce real sugar (no stevia allowed) is through ghc extensions.
11:25:56 <Myrl-saki> Cheeky. :P
11:26:07 <Myrl-saki> __monty__: What do you consider Stevia?
11:26:11 <woodson> guys, if I would like to implemented some sort of syntatic sugar is TH the only way?
11:26:14 <woodson> or..?
11:26:49 <cocreature> you can use a preprocessor, quasi quotes or maybe GHC plugins can modify the parser as well (not sure about that)
11:27:27 <woodson> cocreature: Any links that introduces how to get started with them?
11:27:54 <cocreature> woodson: https://www.well-typed.com/blog/2014/10/quasi-quoting-dsls/ is a nice introduction to quasi quoters
11:27:57 <woodson> I will make a google search but if you have any specific in mind
11:28:02 <__monty__> Myrl-saki: Just something like if or while, which is easy to implement in haskell but isn't in most other languages so you might erroneously think of it as sugar.
11:28:02 <woodson> oh thanks
11:29:14 <woodson> I would like to have a list of monads and I am wondering if I could replace it to a do notation
11:29:15 <Myrl-saki> __monty__: You mean something like a DSL using Monad, with "keywords"?
11:29:16 <__monty__> Aren't quasiquotes TH?
11:29:30 <Myrl-saki> __monty__: Like guard/for etc.?
11:29:37 <__monty__> Yeah.
11:29:38 <cocreature> woodson: although tbh I rarely find that a slightly simplified snytax is worth the effort
11:29:53 <cocreature> __monty__: sure
11:31:08 <woodson> crocreature: I am just looking to see if I could impletement a elmish syntax for the reflex libraries HTML
11:31:26 <woodson> I think the current way of things sucks a bit when you have a big template
11:31:29 <woodson> of html
11:32:04 <woodson> and you gotta call a bunch of different functions that are not somehow related to the html syntax
11:33:57 <cocreature> you also give up a fair amount of things by switching to a custom syntax, e.g., you probably have worse error messages, chances are there are less docs for your syntax, editor tooling like “show type of expression” is not going to work, …
11:36:29 <woodson> cocreature: If I can at least get it working we'll see how it goes.. if its not the right way.. oh well at last I will have learned how to use Quasi-quotes
11:37:53 <cocreature> heh fair enough :)
11:38:33 <cocreature> woodson: btw if you want something like elm in Haskell maybe take a look at "miso" which is conceptually much closer to elm than reflex is and afaict (I’m not too familiar with elm) the syntax is also reasonably close
11:41:04 <woodson> Yea, I have tried it before. I just like the html syntax
11:41:28 <woodson> elementfunc [attributes] [html content]
11:52:59 <ineedahcker> hi guys. Im after a good hcker. someone could help pls?
11:55:07 <Tuplanolla> We're all good here, ineedahcker.
11:55:46 <ineedahcker> hi Tuplanolla
11:55:54 <ineedahcker> can we talk in pm?
11:56:08 <Tuplanolla> There's no need to.
11:56:15 <ski> @where hackage
11:56:16 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps',`status'
11:59:33 <ineedahcker> im looking for someone who can delete a fb acc. pls someone help
12:00:25 <Ariakenom> lol ski
12:06:27 --- mode: ChanServ set +o geekosaur
12:12:43 --- mode: verne.freenode.net set +o ChanServ
12:14:25 <sm> hrm.. how would you find the decimal point character from the system locale ?
12:15:16 <phaazon> hey, how am I supposed to debug segfault with gdb + ghc RTS? :/
12:15:25 <phaazon> I tried to compile with stack build --ghc-options -debug
12:15:32 <phaazon> but I still don’t have any interesting debug symbols :(
12:17:47 <cocreature> phaazon: are you sure the segfault is in the rts and not in some ffi code that you’re using?
12:18:01 --- mode: geekosaur set -o geekosaur
12:18:24 <phaazon> cocreature: I’m pretty sure it’s in libmagic
12:18:30 <phaazon> but I don’t even see the Haskell callback
12:18:35 <phaazon> I’ll paste the stacktrace I have
12:19:08 <exarkun> What function creates a lazy ByteString of length (L :: Integer) consisting of the low 8 bits of (x :: Char)?
12:19:10 <phaazon> cocreature: https://gist.github.com/phaazon/428f868e660f2ac5135571f3e0cc4cc6
12:19:42 <phaazon> cocreature: with bt, I get:
12:19:58 <phaazon> https://gist.github.com/phaazon/d8d46864178de7215efe8dcc26abbbac
12:20:11 <phaazon>  there’s not much thing I can use :(
12:20:43 <phaazon> :D
12:20:58 <cocreature> phaazon: if you have a GHC built with dwarf debug symbols you can compile with -g3 to hopefully get a more useful backtrace
12:22:26 <phaazon> --ghc-options -g3?
12:22:30 <cocreature> yep
12:22:42 <phaazon> ok let me see :)
12:22:59 <phaazon> `gcc' failed in phase `Assembler'. (Exit code: 1)
12:23:01 <phaazon> argh :(
12:23:06 <phaazon> doesn’t seem supported
12:23:13 <cocreature> gcc broke shit
12:23:30 <cocreature> phaazon: which OS are you on?
12:23:33 <phaazon> archlinux
12:23:37 <phaazon> 64 bit
12:24:12 <cocreature> hm, I have a GHC build that has the fix applied for archlinux 64bit if you’re willing to run code sent to you by strangers on the internet :)
12:24:29 <phaazon> fix?
12:24:31 <phaazon> what fix?
12:24:37 <phaazon> is there a known issue about that?
12:26:17 <cocreature> yes, as I mentioned gcc broke things in a new version https://ghc.haskell.org/trac/ghc/ticket/15068
12:27:21 <phaazon> cocreature: :/
12:27:26 <phaazon> thanks
12:28:12 <phaazon> cocreature: yet, I thought Haskell now compiles to LLVM?
12:28:22 <cocreature> by default it doesn’t
12:28:33 <phaazon> I need to make it target LLVM then
12:28:35 <HAZARLI23> tdxpv fzqyl jaemv :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:28:36 <Arzuyu_taniyan_v> cvfus unmoy nfwwm :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:28:36 <cocreature> and the llvm backend doesn’t support dwarf debug info
12:28:40 <HAZARLI23> krsvc xdetw gzkgk :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:28:42 <nickim_yok> yilsi qjeoe zrzeo :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:28:43 <nickim_yok> wkenn sryrg stxsj :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:28:43 <phaazon> I already intensively use llvm in Rust
12:28:44 <phaazon> ah
12:28:45 <HAZARLI23> feyvz eumvz htest :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:28:46 <nickim_yok> lhcpq ersvd oysxv :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:29:23 <phaazon> cocreature: so I guess my issue is going to be hard to fix :/
12:29:31 <phaazon> I don’t get why libmagic segfaults like that
12:29:38 <phaazon> maybe it’s broken system lib
12:29:39 <cocreature> phaazon: well just build a GHC with that patch applied
12:29:55 --- mode: tomaw set +o mniip
12:29:59 <_oNLy_yOu_> slamf qmmhf ednbm :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:30:05 --- mode: mniip set +b *!~TURK@*
12:30:23 <geekosaur> geurh
12:30:29 --- mode: verne.freenode.net set +o ChanServ
12:30:35 --- mode: mquin set +o mniip
12:30:43 <phaazon> geekosaur: hallo
12:31:37 <astsb_38m> guqoa cscyt njnsi :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:31:39 --- mode: mniip set +bbbb *!*@104.237.255.131 *!*@202.81.242.188 *!*@187-108-067-184.ip3.com.br *!*@233-179-0-131.e-client.com.br
12:31:42 <Siir> jfyvi xomld xgiyb :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:31:42 <Siir> kvojr glxff yjove :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:31:42 <Siir> ljxks uiilz atwcl :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:31:50 --- mode: mniip set +b *!*@206.189.157.115
12:32:29 <_LiGhT_> cnlfb phnod fizst :FUCK TRUMP FUCK america!!!! we are from TURKEY
12:34:13 --- mode: ChanServ set +o geekosaur
12:34:14 --- mode: ChanServ set +o geekosaur
12:34:53 --- mode: ChanServ set +o byorgey
12:37:16 <fresheyeball> hey folks
12:37:23 <fresheyeball> lets say I have a type Foo
12:37:32 <fresheyeball> Foo is deriving (Enum)
12:37:52 <fresheyeball> now I have a type `data FooPair = FooPair Foo Foo`
12:37:59 <fresheyeball> how can I make `FooPair` an Enum?
12:39:17 <geekosaur> manually, and make sure you understand the consequences (row-major vs. column-major, etc.)
12:39:59 <geekosaur> which is why the standard disallows deriving Enum for types with non-nullary constructors
12:42:03 <Ariakenom> What are the idiomatic usages of enum?
12:42:21 <Ariakenom> just [x..y] enumeration?
12:42:30 <geekosaur> and sometimes succ and pred
12:42:51 --- mode: ChanServ set -o byorgey
12:43:22 <geekosaur> but the tricky part is those usages tend to assume values are linear. as soon as you have FooPair Foo Foo, it's not linear any more and there are both mathematical and often oeprational questions as to correct behavior
12:43:35 --- mode: geekosaur set -o geekosaur
12:44:01 <Tuplanolla> > (42, 13) > (7, 69)
12:44:03 <lambdabot>  True
12:44:05 <Tuplanolla> Then there's this.
12:44:22 <geekosaur> yes, that's one of them
12:44:33 <joel135> lexicographic makes sense
12:44:41 <geekosaur> although that's mroe Ord which is even more fo a linear assumption than Enum
12:45:49 --- mode: mniip set -o mniip
12:45:50 <geekosaur> (Enum can often have *some* meaning; Ord is dubious at best. Note for example that complex numbers are not Ord, or any sensible alternative formulation of same: try coming up with one that's stable across both polar and rectangular representations sometime.)
12:47:28 <Tuplanolla> The lexicographic order topology is an option, but it's just not metrizable.
12:48:17 <Tuplanolla> I've used it at least once in simulation programming.
13:05:30 <ph88> does anyone know of some attempts to make a program to convert imperative to functional style ?
13:06:43 <veverak> in what sense?
13:07:43 <infinisil> ph88: Write down the semantics of the imperative language as a state transition function, emulate it by passing the state directly
13:08:24 <EvanR> is that really a change of style
13:10:02 <tdammers> question is; *why* would you want to do that?
13:10:31 <EvanR> also, how do you convert functional to imperative
13:10:57 <mbwgh> There is a paper that discusses SSA (static single assignment format) regarded as a simple functional language: https://www.cs.princeton.edu/~appel/papers/ssafun.ps . So in some sense, compilers do it all the time, but that is probably not what you want
13:22:01 <geekosaur> ph88, in general there's no algorithm to do that well. you can come up with ways to do it poorly though
13:22:49 <ph88> has anyone seen attempts of people trying ?
13:24:39 <infinisil> I mean, what I said should work in all cases, it's just not efficient and nice, but it works
13:25:06 <mbwgh> I am currently reading Bartosz Milewski's book and am repeating the chapter on function objects. I am not clear on how the definition he gives should make any sense. Is it somehow logical or "natural"? To be more precise: Given that you might want to work with some categorical product and a morphism from this product to some other object, it might be logical to assert that when another such
13:25:07 <infinisil> ph88: But yeah that's probably not what you're looking for
13:25:12 <mbwgh> product/morphism pair exists, you might want to be able to show that "one can expressed via the other" via some factorizer (as was the case for the already introduced product/coproduct constructions). But at this stage I am kind of stumped. Where should the factorizer go? Which diagram should commute? Are the projection functions important? Things like that. How should one approach these problems?
13:28:39 <nepomukspencer[m> Thanks to LYAH I am now trying to write every Python-function as single expression and feeling uneasy when writing imperative if-else-...-constructs.
13:29:46 <EvanR> at least in ruby if then else returns a value
13:33:19 <mbwgh> In C you have the ternary ?:, which I have only come to appreciate as more than a syntactical curiosity after Haskell
13:33:51 <nepomukspencer[m> Python also has a ternary operator (x if c else y) which I prefer - and is an expression. Functionally-infected. I hope this won't get into may way during the informatics-study.
13:35:12 <mbwgh> Don't call it functional, or Guido might decide to remove it
13:35:49 <EvanR> guido will shoot first?
13:37:03 <mbwgh> He might be benevolent, but he's still a dictator
13:37:23 <__monty__> Hasn't Guido retired?
13:37:32 <__monty__> We all bow to the FLUFL now.
13:37:42 <mbwgh> When did that happen?
13:37:51 <atchoum> nope it's a life title. BDFL ?
13:38:34 <mbwgh> Real dictatorship doesn't end with death anyways
13:41:26 <nepomukspencer[m> Still miss function-compositon with python. At least it can be implemented with a few lines.
13:42:29 <mbwgh> As an operator?
13:43:20 <__monty__> https://www.python.org/dev/peps/pep-0401/
13:43:37 <nepomukspencer[m> Nope, unfortunately only as a function.
13:43:46 <mbwgh> :(
13:44:52 <atchoum>  there's no `operator` in python I think
13:45:05 <atchoum> only aliased syntax with method calls ?
13:45:27 <mbwgh> "Recognized that C is a 20th-century language with almost universal rejection by programmers under the age of 30"
13:46:29 <atchoum> « what's the alternative ? C++ ? It's not that much better but at least it is still improving ? »
13:47:32 <mbwgh> Mgnle all te nms!
13:47:38 <Tuplanolla> You mean "growing", atchoum.
13:47:59 <mbwgh> C++ has "folds" now
13:48:33 <nepomukspencer[m> I use something like f = compose(g, h, i, j) ... Better than nothing
13:49:26 <mbwgh> You would be hard pressed to implement that in C++. Taking pass-by-value, pass-by-const-ref, move semantics and all that into account
13:52:23 <nepomukspencer[m> Another 10 years necessary to fully get the grasp of C++.
13:53:48 <mupf> If everything works out, I have to code... C for a living soon.
13:53:56 <mbwgh> Just read everything Scott Meyers has ever written
13:54:23 <[exa]> "learn the god damned assembly"
13:54:31 <mupf> Trying to learn Haskell for personal use tough.
13:54:36 <mbwgh> I think C can be a beautiful thing. Very to-the-point.
13:55:20 <mbwgh> Functions not being first-class hurts, though.
13:55:40 <mupf> Well, I personally consider C a fun challenge. I just wrote a game in C. Believe me, that's nothing you really wanna do but I just love challenges. It was fun.
13:55:54 <nepomukspencer[m> Indeed
13:55:57 <[exa]> C/C++ is a direct macro-styled assembly generator with some doodads. thinking anything more about the languages makes you a java programmer without jvm
13:56:06 <veverak> " Functions not being first-class hurts, though." -> that's why I love C+++
13:58:02 <Ariakenom> [exa]: C sin't assembler. assembler has tail calls :p
13:58:29 <veverak> mbwgh: also, I believe that owrking ocmpose(g,h,i,j) should not be a complex thing in C++
13:58:40 <[exa]> Ariakenom: good point! :]
13:58:56 <mbwgh> [exa]: That kind-of implies that all C++ programmers want to do OOP though, which is certainly not the case. In fact, the STL is *kind of* functional in nature. Kind of, since the iterator interface is not really compositional. It never was intended to be though, they started as an abstraction over near and far pointers
13:59:34 <[exa]> Ariakenom: I have a macro to replace the current stack frame and jump to the function manually :]
14:00:21 <[exa]> mbwgh: fully agree, they try to get the composition-style programming in as hard as possible
14:00:50 <[exa]> mbwgh: still it has to be an assembly generator
14:01:06 <mbwgh> veverak: You would expect that. But then doing things "right", like a standard-compliant container, is nigh-impossible for mere mortals
14:01:22 <veverak> mbwgh: I code C++ a lot
14:01:23 <eschnett> ... or composing containers
14:01:49 <veverak> mbwgh: I believe that really depends on exactly you want
14:01:51 <veverak> :)
14:02:05 <veverak> simple composition that works most of the time is not so complex I believe
14:02:21 <[exa]> mbwgh: there are simple-to-follow guidelines for that
14:02:42 <veverak> and yeah, because of this debate I have strong urge to write operator| to compose things
14:02:49 <veverak> *functions
14:03:55 <veverak> mbwgh: as [exa] said, there are guidelines for a lot of the stuff
14:04:10 <atchoum>  operators are functions, isn't it ?
14:04:29 <infinisil> :t (+)
14:04:31 <lambdabot> Num a => a -> a -> a
14:04:35 <infinisil> Looks like it!
14:04:40 <atchoum> :t (<*>)
14:04:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:04:57 <infinisil> :t (fmap)
14:04:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:05:00 <infinisil> :t (<$>)
14:05:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:05:04 <veverak> yup, idea is to have func1 | func2 | func3 in C++ .... and yeah that requires a specific operator| which is a function
14:05:17 <atchoum> but then everything is. What would be the fundamental difference between a function and a value ?
14:05:57 <infinisil> atchoum: Every function is a value, because functions are first-class, but not every value is a function
14:06:16 <infinisil> functions are values that take an argument
14:06:33 <infinisil> something like that
14:06:40 <atchoum> And then where is the fundamental distinction (should I say duality ?) -- Values and Types ?
14:06:44 <veverak> to accept fail, C++ does not really consider a functio nfirst class I believe, it's just that it's close enough
14:06:49 <mbwgh> atchoum: I wouldn't say everything *is* a function. 3 :: Int isn't a function. But it is isomorphic to three :: () -> Int; three = const 3.
14:07:49 <mbwgh> threeInv :: (() -> Int) -> Int would be the inverse
14:08:12 <[exa]> veverak: what about making something that wraps everything in std::bind?
14:08:20 <mbwgh> well, not of three, but of some function f :: Int -> (() -> Int)
14:08:40 <veverak> [exa]: that is obvious choice, depends on what exactly do you want to achieve I believe
14:08:53 <fragamus> Hi has anyone ever used Haskell with http://scip.zib.de
14:09:09 <mbwgh> There has to be something like that already in boost
14:09:13 <veverak> [exa]: you could also focus more on lambdas, but lambdas allow taking arugments by reference, which is dangerous (especially if finall composed function is returned out of block context and not called)
14:09:15 * atchoum is wondering what's the theory behind programming
14:09:57 <[exa]> veverak: anyway they _could_ make a nice syntax for partial applications (operator-less composition of 2 expressions is basically disallowed now afaik)
14:10:08 <Tuplanolla> Type theory goes pretty deep, but the COBOL side doesn't have any, atchoum.
14:10:31 <veverak> [exa]: they could, and maybe they will
14:10:39 <veverak> [exa]: but I believe focus is somewhere else now
14:10:44 <[exa]> veverak: btw the fact with referencing is not necessarily true, you can decide on copy/ref similarly as with lambdas
14:10:50 <[exa]> well gonna see.
14:10:52 <__monty__> nepomukspencer[m, atchoum, mbwgh: Python function composition as an operator: http://ix.io/1biR ; D
14:11:21 <veverak> [exa]: I mean, with std::bind, you can write f() that returns std::bind and accepts only by copy (which is safe more or less)
14:11:39 <veverak> [exa]: with something that works with lambdas, you can't force the coder to not to use reference in the lambda capture seq.
14:12:50 <[exa]> ok let's stop the offtopic
14:12:52 <[exa]> D:
14:13:06 <Peaker> Hi, was wondering about a little project: we have nix, cabal-project, stack and git submodules -- all of which can encode roughly the same information.  Maybe a tool to translate typical configs between them would be nice?
14:13:18 <mupf> Ha, found it. One link I wanted to post regarding the C topic above.
14:13:18 <[exa]> the thing with lambdas goes directly to variable lifetimes, which is not fixable in C++
14:13:26 <mupf> https://web.archive.org/web/20110719001859/http://ertes.de/techblog/2008-11-17-2-obscure-c.html
14:13:42 <infinisil> Peaker: The problem is that they totally can't encode the same information
14:13:42 <nepomukspencer[m> __monty__: I've implemented a monad in python as well. But I still not believe I understood this pattern well enough ;)
14:13:52 <infinisil> Peaker: The subset of information that all of them can encode is probably tiny
14:14:01 <Peaker> infinisil, what differences do you mean?
14:14:02 <veverak> [exa]: f(&my_object, Object::methods, 22, _!, "test") | []( auto T &){ ... wololo .... ;} | CallableObject{...args...}
14:14:20 <veverak> [exa]: you can have this, but you may burn in hell after that
14:14:27 <infinisil> Peaker: How much similarity is there from git submodules to nix??
14:14:30 <veverak> let's get back to Haskell :)
14:14:31 <Peaker> infinisil, I'm just talking about references to hackage versions and to some git repos containing cabalized packages
14:14:53 <Ariakenom> atchoum: Have seen lambda calculus?
14:14:54 <Peaker> infinisil, nix can refer to cabalized packages at a particular version/hash
14:14:59 <atchoum> nope
14:15:20 <atchoum> I would like to have something neat (epub format) about fundamentals.
14:15:27 <Peaker> infinisil, in Lamdu, we have stack, cabal, and nix support -- and we manually sync the 3 using mechanical/tedious work
14:15:45 <Peaker> infinisil, I'm thinking about adding a mega-repo with submodules too instead of stack.yaml
14:15:47 <infinisil> Peaker: Yeah that's still gonna be hard, what's the cabal version of any specific git revision? What's the git revision of a with-nix customized package?
14:16:04 <infinisil> Peaker: It's easy when you go from low-information to high-information amount
14:16:05 <Peaker> infinisil, I don't need to worry about that -- I just refer to a specific git hash anyway
14:16:15 <[exa]> mupf: that's a good reading. if you're interested, you can read the paper 'some were meant for C' from Kell, it's a nice reading about what functional programming in general is not good at yet
14:16:20 <[exa]> mupf: lexically scoped functions) to get things to work.
14:16:26 <atchoum> there's some implementations of Haskell pure type system for javascript I think.
14:16:26 <Peaker> infinisil, either to a git hash, or a hackage version
14:16:47 <[exa]> mupf: oh sorry bad paste, I wanted to paste the link: https://www.cl.cam.ac.uk/~srk31/research/papers/kell17some-preprint.pdf
14:16:50 <Ariakenom> Does anyone have a nice info on lambda calculus for atchoum
14:17:10 <mupf> [exa] thanks. Can you post the link via pm please? I'm on mobile
14:17:25 <[exa]> mupf: PM'd
14:17:41 <infinisil> Peaker: Ah yeah, that might work, but you can't translate the full information from one to another
14:17:43 <mupf> https://web.archive.org/web/20110719000535/http://ertes.de/techblog/2009-01-11-1-python-church-lists.html another interesting post about python
14:17:48 <mupf> Thanks exa
14:18:10 <infinisil> Peaker: You'll have to "bootstrap" e.g. the cabal file before you can update it with sha's from the submodules
14:18:19 <__monty__> nepomukspencer[m: This was just because I saw discussion about composition only being possible as a function not an operator in python.
14:19:26 <infinisil> Peaker: So it's not a conversion, but rather like an information extraction over different formats or so
14:20:01 <Peaker> infinisil, yeah, would need to run nix-pkgs to fill in nix references, for example
14:20:36 <Peaker> infinisil, but I can see many projects that just refer to specific stackage/hackage versions + git repos could use a tool like this to be agnostic to whether they are built in "stack" or "nix" or what not
14:21:15 <infinisil> Peaker: I'm just using stack2nix to get a nix-buildable thing tbh, works great
14:21:16 <Peaker> Though it feels a bit like XKCD standards :-) (https://imgs.xkcd.com/comics/standards.png)
14:21:47 <infinisil> Eh, making tools to convert between standards is not a new standard :)
14:22:21 <Peaker> yeah, but: Annoyed by having so many build tools? Let's make another build tool that converts between build tools :)
14:24:10 <infinisil> I mean it's not a build tool if it doesn't build anything, right?
14:24:40 <infinisil> If you were to create a new file format for specifying the git/nix/cabal versions of the dependencies then that would be a new standard like thing
14:36:03 * hackage plur 0.1.0.0 - Plurality monad: Zero, one, or at least two.  http://hackage.haskell.org/package/plur-0.1.0.0 (joelb)
14:38:13 <Ariakenom> Does anyone have a lambda calculus introduction?
14:38:33 * hackage load-env 0.2.0.0 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.2.0.0 (PatrickBrisbin)
14:39:08 <Cezar_> can I learn haskell in 12h ? :)
14:41:04 <Ariakenom> finals Cezar_? :p
14:41:37 <Cezar_> Ariakenom you can say that again
14:41:39 <mbwgh> Ariakenom: In my all-encompassing download folder, I have "Lambda Calculus" by Mayer Goldberg and "A tutorial introduction to the lambda calculus" by Raul Rojas, which you could google
14:43:09 <Ariakenom> mbwgh: I wanted to recommend it to atchoum. Would you recommend either?
14:43:43 <atchoum> thanks
14:44:16 <mbwgh> Ariakenom: There's a reason they are still in my download folder. I haven't read them. The Tutorial paper seems more accessible though, the other more exhaustive
14:44:55 <mbwgh> Cezar_: To answer your question, no. Do you have a specific question though?
14:45:14 <Cezar_> I might have over the next 12 h :)
14:46:13 <Cezar_> I see that my teachers have an obsesion on parsers, so my final goal would be to write a parser in haskell
14:46:23 <blankhart> Ariakenom, there is https://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf
14:56:32 <Cleisth57> Hello, can anybody tell me what topics we have here on this channel?
14:57:55 <srhb> Cleisth57: All things Haskell programming language.
14:58:12 <Cleisth57> What is Haskell though?
14:59:14 <srhb> Cleisth57: It's a functional programming language. I'm curious how you found this channel if you didn't seek it out to learn about that :)
14:59:25 <Ariakenom> Well those are some sources atchoum, I don't know anything about them. From your questions I think you would like Lambda Calculus though.
15:02:05 <__monty__> Cleisth57: You just stumbled across one of the best channels freenode has to offer (imho).
15:02:26 <Cleisth57> thats what I heard lol
15:02:53 <Cleisth57> what does this channel cover? And why is it so fantastic?
15:03:48 <infinisil> Cleisth57: https://www.haskell.org/
15:29:41 <boj> what is the workflow for bypassing aeson decoding in a reflex app, but still turning the json into haskell values?
15:42:46 <geekosaur> I am having trouble reading that question as anything other than "how do I decode JSON without decoding JSON?"
15:43:26 <EvanR> yeah, aeson has some kind of mechanism to decode the json without constructing the Value first
15:43:51 <EvanR> I heard (tm)
15:44:53 <geekosaur> well, there's the low level FromJSON class but only for primitive values. as soon as you have two such, you're in for pain.
15:50:38 <dmj`> boj: you go directly from JSVal to Value
15:51:10 <dmj`> boj: miso does this for all events / web socket communication
15:51:13 <dmj`> @package miso
15:51:13 <lambdabot> http://hackage.haskell.org/package/miso
15:52:01 <dmj`> boj: https://github.com/dmjio/miso/blob/master/ghcjs-src/Miso/FFI.hs#L57
15:52:20 <boj> dmj`: thanks for the tip!
15:53:15 <dmj`> boj: There was a bug where you couldn’t contain nested objects, but that should be fixed in miso, unsure in reflex. Have to use `getKeys`.
15:56:16 <boj> geekosaur: more like, how do i decode json without aeson. it has had severe performance issues in ghcjs for large data sets, which my team just ran into today. wasn't sure how to approach it
16:08:04 <EvanR> you know your haskell has jumped the shark when you see a vim "tectonic shift" of 3 columns of line numbers to 4
16:09:03 <hpc> ... i know exactly what you're talking about
16:09:12 <hpc> and i don't even turn on line numbers in vim
16:11:32 <infinisil> Lol, university event "Drunk Haskell"
16:12:03 <infinisil> Programming competition where you get a beer for completed takss
16:13:04 <infinisil> But I don't drink and am antisocial, so that's a double-nope from me
16:33:58 <texasmynsted> where can I find more detail on Haskell core language as GHC compiles.
16:34:00 <Nokurn> hpc: ETHZ?
16:41:22 <lyxia> texasmynsted: there's a pdf of it in the GHC repo.
16:42:00 <lyxia> https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf
17:06:04 * hackage simple-effects 0.11.0.0 - A simple effect system that integrates with MTL  http://hackage.haskell.org/package/simple-effects-0.11.0.0 (darwin226)
17:37:57 <hcarr> how does one use TextShow.Debug.Trace.TH ?
17:38:51 <Welkin> who is one?
17:38:53 <Welkin> Neo?
17:38:58 <Welkin> from the matrix?
17:39:29 <Clint> why you so blur one
17:39:29 <hcarr> ok then, how do you use TextShow.Debug.Trace.TH ?
17:40:20 <mniip> yeah Welkin
17:40:23 <mniip> how do you use that
17:40:36 <Welkin> never have
17:41:46 <EvanR> obligatory "one does not simply.."
17:42:03 <Welkin> what about two?
17:42:05 <Welkin> or three?
17:42:37 <EvanR> hcarr: is this a particular package, link to haddocks?
17:42:39 <mniip> hcarr, looks like you just splice the make* like you would traceTextShow
17:43:55 <mniip> I expect it takes the type constructor name in the "Name" argument
17:45:06 <hcarr> I want to use it something like:  f2 a = $(makeTraceTextShowId <var a>)
17:45:37 <mniip> no
17:46:02 <mniip> $(makeTraceTextShowId 'TypeOfA) a
17:46:10 <hcarr> I need to see the value of a Text variable inside a function that does not have Show constraints
17:46:31 <hcarr> I will try that.  Be right back.
17:46:33 <mniip> that's going to be problematic
17:46:58 <mniip> type erasure is a thing
17:51:54 <hcarr> I thought that one could use makeTraceTextShowId like traceTextShow.  But I do not know how to link the variable name I want to the Name required by makeTraceTextShowId
17:52:26 <mniip> that's not what that Name is for
17:52:33 <mniip> as I already explained that's for the datatype
17:57:43 <EvanR> @botsnack
17:57:43 <lambdabot> :)
17:57:52 <EvanR> y u no respond to PM
17:58:16 <geekosaur> I would expect that something by that name creates a function that can show something as Text
17:58:25 <geekosaur> but I can't find that module, so…
17:59:57 <EvanR> :t fmap catMaybes . sequence
17:59:58 <lambdabot> Monad f => [f (Maybe a)] -> f [a]
18:02:11 <EvanR> anything involving sequence and fmap i come up with is usually falling short somehow, of some more sophisticated method
18:04:57 <Axman6> :t traverse catMaybes
18:04:59 <lambdabot> Traversable t => t [Maybe b] -> [t b]
18:05:29 <Axman6> IIRC traverse f = fmap f . sequence is a law, no?
18:05:58 <hcarr> thanks - got it:  f1 = $(makeTraceTextShowId (mkName "Example")) (Example 1 2)
18:06:12 * EvanR tries to see how that maps into what i neede
18:06:15 <Axman6> uh, wrong type, my bad
18:06:32 <Axman6> it probably doesn't, I'm an idiot
18:07:09 <EvanR> waahahahaaha
18:07:59 <EvanR> i second the notion to talk about "Monad f =>"
18:08:07 <EvanR> its very suggestive
18:08:21 <EvanR> the motion?
18:08:30 * EvanR calls the whole thing off
18:11:02 <EvanR> also is there english for this... avoided means one thing, avoidable means another thing, what about a suffix for "must be avoided"
18:13:00 <i0-dfn> i'm using -hr to profile retainer sets but it doesn't tell me the actual object being retained, how can i ask the ghc RTS for that information?
18:13:07 <i0-dfn> using -hc crashes immediately, unfortunately
18:20:15 <tA_> holy moly its benzrf
18:20:20 <tA_> Haven't seen that name in a while
18:20:23 <benzrf> O:
18:20:29 <benzrf> ive been here almost constantly for years!
18:20:36 <benzrf> i just don't log in and out almost ever
18:20:51 <tA_> I havent seen you since the Homestuck irc about 4 years back
18:20:56 <benzrf> lmao
18:21:03 <benzrf> oh do you not normally come in this channel
18:21:07 <tA_> Nope
18:21:08 <benzrf> i couldnt remember where i knew you from
18:21:12 <benzrf> well, this is off topic anyway
18:21:43 <tA_> Yeah, I was hoping someone would have a good resource for serving css with my happstack page
18:21:56 <Welkin> serving css?
18:21:59 <Welkin> it's just a file
18:22:02 <Welkin> you serve it like any other file
18:22:32 <tA_> Yeah but I'm dumb and don't understand happstack fully. I've got it generating my html fine at the moment
18:25:38 <boj> tA_: i don't know anything about happstack, but it seems to have a Happstack.Server.FileServe module
18:25:58 <boj> ideally you'd just serve up the directory with the css in it
18:54:59 <zezeri> anyone here :)?
18:55:31 <zezeri> https://pastebin.com/z9VCV0v3 if so, i have a question
18:56:55 <geekosaur> :t length > 15
18:56:56 <lambdabot> error:
18:56:56 <lambdabot>     • No instance for (Ord ([a0] -> Int)) arising from a use of ‘>’
18:56:56 <lambdabot>         (maybe you haven't applied a function to enough arguments?)
18:57:12 <t`> Is it possible to generate a unique type for an expression? Like.. "(a :: Proxy Somety) <- someIOop". Can I make it so that Somety will be disjoint for all other types?
18:57:20 <geekosaur> you didn;t tell it where to stick the value, so it sticks it on the end of (length > 15) and the result is a nonsense type
18:58:19 <geekosaur> (\x -> length x > 15), or a point-free version which is less readable: (> 15) . length
19:03:03 <blonkhart> t`, what is your ultimate purpose?
19:05:25 <t`> blonkhart: I want to do; a <- ..; b <- ..; c <- a + b; and ask if c was derived from a at some point
19:06:09 <t`> blonkhart: If I could do something like "data Ty x = ..." for each leaf in the above then I could store them in a type-level set and prove that c is indeed derived from a
19:09:26 <Axman6> There are ways of doing something like that using indexed monads
19:09:41 <t`> Axman6: Oh? that would be awesome, any pointers?
19:10:20 <Axman6> I have a shitty gidt with something sort of similar:v
19:10:22 <Axman6> https://gist.github.com/axman6/764b609229fd9f53d3c7294a0c1ba4fe
19:11:36 <Axman6> The idea in the gist is to be able to allocate resources which are uniquely tagged at the type level, and a list of live resources is maintained - resources can't be used once they have been deallocated
19:12:57 <t`> Axman6: Oh, that's cool! I'll try it out
19:13:03 <t`> Is there a name for this?
19:15:10 <woodson_> Anyone know a good reference or tutorial that explains how to setup nginx and haskell web app?
19:15:10 <Axman6> no idea
19:15:15 <woodson_> lol
19:15:22 <Axman6> type inference can e a bit painful though
19:15:57 <Axman6> woodson_: what would make the app being haskell any more difficult than just using nginx as a proxy?
19:16:01 <Welkin> woodson_: you don't need nginx
19:16:09 <Axman6> also that
19:16:16 <Welkin> you can run a haskell web server directly, at least with warp
19:16:55 <Welkin> compile your program, push it to your server, and run it
19:17:11 <Welkin> you can look at keter for a decent deployment solution
19:17:32 <Welkin> but really, to get started all you need is to scp your binary to the server
19:17:33 <woodson_> ok I will try that.
19:17:37 <Welkin> then ssh into your server and run it
19:17:41 <EvanR> t` "indexed monads"... another name you might see is "type state"
19:17:53 <woodson_> I am doing it on my laptop
19:17:58 <woodson_> just want to try nginx
19:18:04 <woodson_> since I have never used it before
19:18:11 <Welkin> nginx is only necessary if you need a reverse proxy for some reason
19:18:11 <woodson_> and everything is about php
19:18:14 <t`> EvanR: Oh cool, I'll have a look at that!
19:18:25 <Welkin> or need some advanced features of nginx
19:18:31 <t`> EvanR: Is there a name for "generating unique types" in a more general setting? Like I'd call this gensym at the term level
19:20:19 <woodson_> Welkin: I'm gonna read about it
19:20:57 <woodson_> http://www.aosabook.org/en/posa/warp.html "provides performance on a par with nginx"
19:21:07 <edmundnoble> t`: I'd probably call that gensym too. Or call the two freshTermName and freshTypeName
19:22:45 <edmundnoble> Generating unique types =/= generating unique type *names* though
19:22:56 <edmundnoble> You aren't generating unique *terms* with gensym either
19:23:47 <t`> edmundnoble: Fair. Well, all I want is types that are guaranteed to be disjoint from any others.
19:24:28 <edmundnoble> Maybe `freshType`? Or are you looking for an implementation? Using Template Haskell?
19:25:31 <t`> edmundnoble: Pointers to various ways to do this or implementations would be good. Hmm.. how would one do this with TH?
19:26:42 <edmundnoble> Well this is going to depend on what you want to do it for; there's some tricks involving stuck type families that have been used in some obscure Kmett library, but in TH I'd just generate data decls.
19:27:49 <t`> edmundnoble: I was thinking about data decls. But I don't know how many of these I would need and I don't know how to assign different types to different terms.
19:28:25 <edmundnoble> What are you doing this for?
19:29:31 <t`> edmundnoble: So if I have "a <- ..; b <- ..; c <- ...; d <- a + b"; I want to guarantee that inside a call to "fn x (\valx -> ...)" you can only access a and b since they are derived from c
19:29:36 <t`> erm from d
19:29:40 <t`> but not c
19:29:44 <t`> since it's disjoint
19:31:23 <t`> If I could generate a unique type for each leaf, then I could leave a and b polymorphic, make them equal in the a + b call, and then verify that they are all the same in fn d (\vald -> ...)
19:33:41 <edmundnoble> I think I'm missing some background
19:34:45 <t`> edmundnoble: So.. I have some data and I process it. And I want to guarantee that when I'm looking at the output of that processing I'm only analyzing inputs that went into making that output
19:34:46 <t`> And nothing else
19:35:30 <t`> Or at least, that the result of the analysis never included anything that wasn't an input to the computation
19:35:50 <edmundnoble> So you want to make sure that the only things that went into computing the output are the inputs you declared?
19:35:58 <edmundnoble> A-ha
19:36:07 <t`> Yup
19:41:24 <edmundnoble> So what may help here is limiting your expression language beyond Monad
19:41:34 <edmundnoble> Into something like `Arrow` without the `arr` method
19:41:42 <edmundnoble> So that arbitrary closures can't be included
19:42:21 <t`> edmundnoble: Yeah, I can imagine doing this if it's an arrow
19:42:45 <t`> But I'd really like to stick to Monad
19:43:57 <edmundnoble> It's be even less expressive than `Arrow` because `arr :: (a -> b) -> p a b` lets you include arbitrary closures
19:43:58 <edmundnoble> I mean you could use TH to generate datatypes and unsafeCoerce to those types
19:47:04 <t`> edmundnoble: That sounds pretty invasive though
19:47:11 <edmundnoble> It is
19:47:20 <edmundnoble> I'd write a compiler plugin
19:47:48 <t`> Oh, interesting. I had not considered this
19:48:10 <edmundnoble> Ultimately what you're doing approaches language-change anyway. And zero-capture closures *are* useful; in fact, I think CloudHaskell has something similar.
19:48:50 <edmundnoble> Oh nvm that's "you can close over *serializable* data"
19:48:58 <edmundnoble> You want something more restricted
19:49:23 <edmundnoble> I'm sure the hnix folks would love something like this too
19:49:35 <t`> Oh?
19:49:39 <t`> Why would hnix be interested?
19:50:44 <edmundnoble> Well, not "sure" :)
19:50:51 <edmundnoble> But knowing dependencies is part of the point of nix
19:50:56 <geekosaur> to make sure unrelated derivations etc. don;t get tangled up in it?
19:51:08 <edmundnoble> Right
19:51:39 <t`> Ah, cool. That makes sense
20:08:51 <iqubic> > map absurd []
20:08:53 <lambdabot>  []
20:09:10 <iqubic> Huh, what the heck is going on there?!?
20:09:17 <iqubic> :t absurd
20:09:17 <rotaerk> :t absurd
20:09:18 <lambdabot> Void -> a
20:09:19 <lambdabot> Void -> a
20:09:24 <rotaerk> lel
20:09:35 <dyl> > fix error
20:09:37 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
20:09:57 <iqubic> :t error
20:09:58 <lambdabot> [Char] -> a
20:10:03 * hackage extensible-effects-concurrent 0.1.2.1 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.2.1 (SvenHeyll)
20:11:07 <iqubic> So how does my absurd example work?
20:12:38 <edmundnoble> `[]` has type `forall a. [a]`
20:13:06 <edmundnoble> You can say every element of `[]` is of type `Void`
20:13:45 <edmundnoble> That's as true as "all of the people in Starbucks today are purple", if Starbucks is empty
20:13:56 <edmundnoble> Purple people not existing isn't a problem
20:14:24 <edmundnoble> :t ([] :: [Void])
20:14:25 <lambdabot> [Void]
20:15:20 <nshepperd> > map undefined []
20:15:22 <lambdabot>  []
20:15:25 <edmundnoble> :t []
20:15:26 <lambdabot> [a]
20:20:03 * hackage backprop 0.2.3.0 - Heterogeneous automatic differentation  http://hackage.haskell.org/package/backprop-0.2.3.0 (jle)
20:22:33 * hackage extensible-effects-concurrent 0.1.2.2 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.2.2 (SvenHeyll)
20:29:45 <iqubic> So Void is the empty set?
20:31:03 * hackage hopenpgp-tools 0.21.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.21.1 (ClintAdams)
20:31:26 <nshepperd> [] is the empty set
20:31:53 <nshepperd> it can be an empty set of Voids just as well
20:32:26 <iqubic> huh? What does that mean?
20:36:24 <arahael> nshepperd: What's an empty set of Void
20:38:03 * hackage text-postgresql 0.0.3.0 - Parser and Printer of PostgreSQL extended types  http://hackage.haskell.org/package/text-postgresql-0.0.3.0 (KeiHibino)
20:41:00 <nshepperd> arahael: it's empty!
20:43:17 <jle`> iqubic: what part about `map absurd []` is troubling you?
20:43:19 <jle`> just match up the types :)
20:43:24 <jle`> :t map
20:43:25 <lambdabot> (a -> b) -> [a] -> [b]
20:43:28 <jle`> :t absurd
20:43:29 <lambdabot> Void -> a
20:43:38 <jle`> so map :: (Void -> a) -> [Void] -> [a]
20:43:55 <jle`> the input is ([] :: Void]), and the output is ([] :: [a)
20:44:35 <jle`> everything seems normal?
20:50:03 <marxS> hi
20:57:26 <iqubic> jle`: Yeah, all of that makes sense.
20:57:31 <iqubic> I get how that works.
21:01:14 <codeathon> Hello!
21:01:28 <iqubic> jle`: Wait, all it does is change the type of the empty list?
21:01:58 <jle`> i mean, that's what map does for all empty lists
21:02:01 <jle`> map _ [] = []
21:02:18 <jle`> map for an empty list always ignores the function
21:02:22 <jle`> @src map
21:02:22 <lambdabot> map _ []     = []
21:02:22 <lambdabot> map f (x:xs) = f x : map f xs
21:02:28 <iqubic> Right. And because of that lazyness you can plug in Absurd and stuff just works.
21:02:34 <jle`> it's not because of laziness
21:02:43 <jle`> it's the same for a strict list or strict language too
21:02:48 <jle`> it's just basic evaluation
21:02:51 <jle`> map _ [] = []
21:03:01 <jle`> it's teh same thing as const x _ = x
21:03:04 <mnoonan_> Q: "How many lists are there of type [a], where a is a 2-element type?"  A: 1 + 2 + 2*2 + 2*2*2 + ...
21:03:08 <jle`> > const () absurd
21:03:10 <lambdabot>  ()
21:03:21 <codeathon> feel free to participate in codeathon.byethost12.com/mobile.html, use the main website for PC only. Sorry if this may seem as a spam.
21:03:26 <mnoonan_> Q: "How many lists are there of type [Void], where Void is a 0-element type?"  A: 1 + 0 + 0*0 + 0*0*0 + ...
21:03:38 <kebertx[m]> The first pattern that's matched
21:03:49 <iqubic> mnoonan_: I find that weird, yet totally true.
21:04:19 <mnoonan_> iqubic: that's totally fair!
21:04:24 <mnoonan_> how do you feel about Maybe Void?
21:04:39 <cobreadmonster> iqubic: that's true of all of mathematics.
21:04:40 <jle`> how do you feel about `Proxy Void`
21:04:52 <jle`> > fmap absurd Proxy
21:04:54 <lambdabot>  Proxy
21:05:01 <iqubic> Maybe Void is a two element set.
21:05:02 <jle`> all fmap does for Proxy is "change its type"
21:05:11 <jle`> same for empty lists
21:05:12 <iqubic> jle`: I don't know what Proxy is.
21:05:18 <jle`> data Proxy a = Proxy
21:05:24 <mnoonan_> iqubic: are you counting bottom as one of the two, or not?
21:05:24 <jle`> iqubic: Proxy a is a list that's always empty
21:05:32 <jle`> iqubic: or, a Maybe with only Nothing (no Just)
21:05:39 <jle`> data Maybe a = Nothing | Just a
21:05:42 <jle`> now imagine Maybe without Just
21:05:47 <iqubic> mnoonan_: no. I'm not.
21:05:51 <jle`> data Maybe a = Nothing    -- that's Proxy
21:05:59 <mnoonan_> iqubic: then it's just one element
21:06:01 <iqubic> You have Nothing, and Just a. For some a
21:06:27 <mnoonan_> you have Nothing, and a Just x for each x of type Void.. but there are no such xs :)
21:06:36 <iqubic> So Proxy is like Void, but with a phantom type? Why is that useful at all?
21:06:58 <mnoonan_> no, Proxy is like () with a phantom type
21:07:01 <jle`> Proxy is not like Void
21:07:10 <arahael> nshepperd: Sorry about the delay - an empty set of Void being empty makes perfect sense. :)
21:07:15 <jle`> Proxy is (), yeah, with a phantom type parameter
21:07:18 <jle`> well, it's useful here
21:07:21 <jle`> for helping explain what fmap does
21:07:23 <jle`> with absurd
21:07:26 <jle`> and the empty list :)
21:08:41 * mnoonan_ . o O ( if you have Maybe Void, you have Nothing )
21:09:09 <jle`> deep
21:12:24 <EvanR> iqubic: you can get into trouble trying to make types into sets
21:15:39 <EvanR> but theres probably a morally correct way to do it
21:20:18 <iqubic> why is proxy closer to () than to Void?
21:20:54 <EvanR> because there are proxy values, but no Void values
21:22:13 <EvanR> data Proxy t = Proxy
21:22:19 <EvanR> data Void
21:22:27 <iqubic> Oh, I see.
21:22:46 <iqubic> That makes a lot sense. What is Proxy good for?
21:23:04 <darkJedi> Hi I'm going through this course on Functional Programming by University of Glasgow. And I'm stuck at this module 'Parsing using Parsec' for 2 weeks now. In here they are trying to build a XML Parser. https://lpaste.net/2269653034957012992
21:23:28 <EvanR> getting typeclass instances for stuff when the method doesnt want or need stuff
21:23:36 <darkJedi> Can anyone help me in understanding list parser?
21:23:38 <EvanR> :t size
21:23:39 <lambdabot> error:
21:23:39 <lambdabot>     • Variable not in scope: size
21:23:39 <lambdabot>     • Perhaps you meant one of these:
21:23:49 <EvanR> :t sizeOf
21:23:51 <lambdabot> error:
21:23:51 <lambdabot>     • Variable not in scope: sizeOf
21:23:51 <lambdabot>     • Perhaps you meant one of these:
21:24:04 <marxS> :t length
21:24:05 <lambdabot> Foldable t => t a -> Int
21:24:43 <Axman6> darkJedi: What don't you understand?
21:25:15 <EvanR> sizeOf :: Storable a => a -> Int. the argument isnt actually used, sizeOf is basically a number associated with a type
21:25:16 <darkJedi> :Axman6 the flow of the code for list_parser
21:25:40 <Axman6> can you elaborate?
21:25:54 <EvanR> one way would be for Storable to use Proxy... sizeOf :: Storable a => Proxy a -> Int
21:27:08 <darkJedi> Right now I'm confused what will be the input for it. And then what will eventually ls. And tag should take 2 values but instead it is taking one in ```map (tag "list-elt") ```
21:27:13 <iqubic> What is Storable? Is that a complex thing to understand?
21:27:23 <EvanR> no its not complex
21:27:43 <EvanR> look at the haddocks, it lets you peek and poke values in memory
21:28:08 <Axman6> darkJedi: well, brackets parses something surrounded by [ and ]
21:28:17 <darkJedi> okay
21:28:41 <Axman6> commaSep parses as many of the things pared by the parser passed to it, separated by ','
21:28:47 <mnoonan_> iqubic: if you want to write a function that takes a type as a parameter, Proxy is kind of a way of turning a type into a value
21:28:58 <Axman6> so we have things of the form [ XXX , XXX , XXX ]
21:29:12 <iqubic> mnoonan_: Can you give me an example of that?
21:29:46 <Axman6> showParser looks like it's the place where recursion in th e parser happens - so whatever showParser can parse can also be placed inside [ and ] and separared by ','
21:30:02 <mnoonan_> say you had a typeclass like "class DescribeType a where describe :: __? -> String"
21:30:13 <acertain> i'd really like operator sections like (+ 2 + 3) (to mean \x -> (x + 2) + 3 since (+) is infixl)
21:30:15 <darkJedi> I think I didn't understand showParser
21:30:24 <mnoonan_> one solution would be to have "describe :: a -> String", and have describe ignore its parameter
21:31:04 <iqubic> Right, but then you'd stil have to pass in a value of some sort.
21:31:09 <Axman6> showPArser is the combination of all the other parsers - it tries to parse a list, if that fails it tries to parse a tuple, if that fails it tries to parse a resord etc.
21:31:12 <Axman6> record
21:31:14 <mnoonan_> but that's sort of ugly, and if you didn't happen to have an 'a' on hand, you'd have to pass 'describe' something like "undefined :: a" or "error foo :: a"
21:31:33 <mnoonan_> so instead, you could define 'describe' like this: "describe :: Proxy a -> String"
21:31:50 <darkJedi> oh! okay
21:31:53 <mnoonan_> then you don't actually need an 'a' value to call describe. you can just do "describe (Proxy :: Proxy a)"
21:32:05 <darkJedi> I had done this sort of approach in my lisp interpreter.
21:32:07 <mnoonan_> or with TypeApplications, "describe (Proxy @a)"
21:32:59 <iqubic> So the Proxy is kinda like a way to tag a type?
21:33:36 <darkJedi> Axman6: Now suppose I get a string like "["hello", "world"]"
21:33:55 <EvanR> a Proxy t is like a value of type t without the value
21:34:01 <darkJedi> Then in ls I should get ["hello", "world"] right?
21:34:02 <mnoonan_> iqubic: I guess I kind of think of it as a dummy value that just carries a type along with it?
21:34:15 <darkJedi> or something else
21:34:16 <darkJedi> ?
21:34:18 <Axman6> darkJedi: sorry, in a meeting now, someone else should be able to help you though
21:34:26 <darkJedi> okay Thanks
21:34:38 <EvanR> hence the name
21:34:54 <EvanR> it serves every purpose as a value of type t, except for the value part
21:35:05 <iqubic> How do you construct a useful value of Proxy?
21:35:16 <EvanR> with the constructor
21:35:19 <mnoonan_> > Proxy :: Proxy Int -- like so!
21:35:21 <lambdabot>  Proxy
21:35:37 <mnoonan_> > Proxy @Int -- or like this
21:35:39 <lambdabot>  <hint>:1:7: error: parse error on input ‘@’
21:35:51 <mnoonan_> I guess lambdabot doesn't have -XTypeApplications set
21:36:18 <darkJedi> iqubic: Can you help me out here in understanding the flow of list_parser ? https://lpaste.net/2269653034957012992
21:36:25 <iqubic> I see. And where would you do use that in actual code?
21:38:24 <EvanR> when you need "constants" out of a typeclass dictionary
21:38:38 <iqubic> constants?
21:38:45 <mnoonan_> iqubic: here's a concrete example. They have a typeclass for getting a JSON schema for a type: https://www.stackage.org/haddock/lts-7.12/json-schema-0.7.4.1/Data-JSON-Schema-Types.html
21:38:54 <EvanR> the describe thing above is a String that depends on the type, not the value
21:39:21 <mnoonan_> the schema is attached to the *type*, not the *value*. so a method like "schema :: a -> Schema" wouldn't make sense really.
21:39:43 <mnoonan_> but "schema :: Proxy a -> Schema" does
21:39:56 <EvanR> and schema :: Schema, also doesn't
21:40:02 <EvanR> that would really be a constant
21:40:07 <geekosaur> % Proxy @Int
21:40:08 <yahb> geekosaur: Proxy
21:40:12 <geekosaur> yahb has it
21:40:14 <iqubic> I see.
21:51:45 <iqubic> So if all you need is a way to pick which typeclass instance you are using, but don't need any values of said type, then you can just use Proxy?
21:53:10 <iqubic> If that is true, then how does this differ from things like mepty :: (Monoid a) => a?
21:53:23 <halogenandtoast> Hello, has anyone seen this error when trying to build with profiling? https://gist.github.com/halogenandtoast/ebbbf7236699f58785f3405198538d10
21:53:54 <halogenandtoast> Things I have tried: tried building with GHC 8.4.2, no luck. Ran `stack clean`, deleted `.stack-work`.
21:53:58 <EvanR> mempty is a value of the type
21:54:12 <EvanR> Proxy a is just a stand-in
21:54:20 <iqubic> What's the difference?
21:55:08 <EvanR> in all the examples so far the data associated with the type, in the class, was some other type, not `a'
21:55:15 <EvanR> if its type a, then yeah you dont need proxy
21:55:49 <EvanR> the type variable has to be somewhere however, for instance selection to work
21:57:11 <mnoonan_> right, a "Proxy a" isn't an "a", and there is no "Proxy a -> a" function out there
21:58:42 <dminuoso> iqubic: Think of Proxy as an antiquated way of doing TypeApplications :P
21:58:51 <mnoonan_> here's something kind of interesting you can do:
21:59:13 <iqubic> So if you have a "Proxy a" you don't have a value of type a? You just have thing that signifies we want to chose the typeclass instance for a?
21:59:27 <mnoonan_> @let like :: a -> Proxy a -> a; like x _ = x
21:59:28 <lambdabot>  Defined.
21:59:32 <iqubic> dminuoso: I don't actually know what TypeApplications are.
21:59:45 <mnoonan_> > mempty `like` "Hello, world!"
21:59:47 <lambdabot>  error:
21:59:47 <lambdabot>      Ambiguous occurrence ‘like’
21:59:47 <lambdabot>      It could refer to either ‘Lens.like’,
21:59:52 <mnoonan_> oh damnit
22:00:08 <iqubic> @undefine
22:00:08 <mnoonan_> @let asIn :: a -> Proxy a -> a; asIn x _ = x
22:00:08 <lambdabot> Undefined.
22:00:09 <lambdabot>  Defined.
22:00:16 <mnoonan_> > mempty `asIn` "Hello, world!"
22:00:18 <lambdabot>  error:
22:00:18 <lambdabot>      • Couldn't match expected type ‘Proxy a’ with actual type ‘[Char]’
22:00:18 <lambdabot>      • In the second argument of ‘asIn’, namely ‘"Hello, world!"’
22:00:28 <iqubic> What?!?!
22:00:30 <mnoonan_> oh what am i even doing :|
22:00:44 <dminuoso> iqubic: Consider this example: https://gist.github.com/dminuoso/29b23e473a425347580ccb22371c94c1
22:00:52 <EvanR> iqubic: yes, of course, you do not have an a. data Proxy t = Proxy. theres no t
22:00:54 <dminuoso> iqubic: How could you possibly use `sizeOf` ?
22:01:00 <EvanR> its a phantom
22:01:00 <mnoonan_> > mempty `asIn` (pure "Hello, world!")
22:01:02 <lambdabot>  ""
22:01:05 <mnoonan_> there we go :)
22:01:27 <mnoonan_> > mempty `asIn` (Proxy :: Proxy Int)
22:01:29 <lambdabot>  error:
22:01:29 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘mempty’
22:01:29 <lambdabot>      • In the first argument of ‘asIn’, namely ‘mempty’
22:01:44 <mnoonan_> > mempty `asIn` (Proxy :: Proxy (Sum Int))
22:01:46 <lambdabot>  Sum {getSum = 0}
22:01:50 <iqubic> dminuoso: You'd need some sort of thing to tell you which typeclass instant to use.
22:01:59 <iqubic> s/instant/instance/
22:02:10 <dminuoso> iqubic: You'd need some sort of way to specify what `a` is going to be. Its not really specific to typeclasses.
22:02:24 <iqubic> right. I see. So you use Proxy
22:02:35 <iqubic> Can you use Proxy without a typeclass?
22:02:41 <EvanR> sure
22:02:46 <dminuoso> iqubic: So you'd start out with `sizeOf :: a -> Int` maybe, but that wont work if you dont have an actual value. You'd have to resort to using it like `sizeOf (undefined :: Int)`
22:02:53 <EvanR> but it wont do anything
22:03:06 <EvanR> its isomorphic to ()
22:03:22 <EvanR> its like a pet rock
22:03:34 <iqubic> dminuoso: What is the issue with that?
22:03:46 <dminuoso> iqubic: Do you really want to use `undefined` everywhere?
22:04:10 <dminuoso> It's your sledgehammer of "this thing will fit"
22:04:15 <mnoonan_> you don't know that passing undefined is safe there, except by gentlemen's agreement
22:04:20 <cocreature> the problem with using undefined is also that it’s unclear to users of your API whether undefined is an acceptable value
22:04:24 <mnoonan_> but passing Proxy certainly is safe.
22:04:33 <cocreature> if something accepts Proxy a, you know that it doesn’t care about the value
22:04:37 <iqubic> Right, because that makes sense.
22:04:45 <EvanR> undefined placed accidentally somewhere would be a disaster, and nothing stops you
22:04:47 <iqubic> How is undefined defined?
22:04:56 <EvanR> @src undefined
22:04:56 <lambdabot> undefined = error "Prelude.undefined"
22:04:56 <mnoonan_> undefined = undefined :)
22:04:58 <dminuoso> iqubic: you could think that `undefined = undefined`
22:05:10 <iqubic> What?!?
22:05:20 <mnoonan_> @let undef = undef
22:05:21 <lambdabot>  Defined.
22:05:22 <iqubic> but that's infinite recursion.
22:05:23 <mnoonan_> :t undef
22:05:24 <lambdabot> t
22:05:30 <dminuoso> iqubic: So?
22:05:34 <EvanR> ... thats the entire point of undefined
22:05:37 <dminuoso> iqubic: The value of infinite recursion is bottom.
22:05:37 <iqubic> > undef
22:05:43 <lambdabot>  mueval-core: Time limit exceeded
22:05:50 <iqubic> Right, so that happens.
22:06:01 <mnoonan_> that's why you shouldn't go handing undefined to functions :)
22:06:12 <mnoonan_> if they ever peek at it, boom
22:06:26 <EvanR> undefined is radioactive waste
22:07:02 <iqubic> Well this cool and weird at the same time.
22:07:54 <dminuoso> iqubic: Both Proxy/TypeApplications let you (provide a witness for/specify) a type. So instead you'd write `... sizeof :: Proxy a -> Int` in my example. That way when you use it `sizeOf (Proxy :: Proxy Int)` you are providing some hint in the type system to let the compiler know what `a` in sizeof is going to be.
22:07:59 <iqubic> Proxy seems like a way to chose a typeclass to use, but without needing to actually construct a value of the type you want to use.
22:08:05 <dminuoso> iqubic: Its a way to choose a _type_
22:08:10 <dminuoso> its not about typeclasses.
22:08:21 <iqubic> A type is different from a typeclass?
22:09:56 <EvanR> yes sir
22:09:56 <dminuoso> iqubic: a typeclass is just a collection of types.
22:10:16 <iqubic> What does that mean?
22:11:35 <dminuoso> iqubic: Eq is a big bag that contains all the types that can be compared for equality. Inside contexts you could say that `Eq a => a` is a requirement that `a` be inside Eq - and to have a membership card you need to provide an instance with all necessary methods.
22:12:11 <dminuoso> Which is why you can't have some value of type `Eq` - it just doesnt make sense.
22:15:34 <dminuoso> In my example: `sizeOf :: forall a. BitSize a => Int` If you use `sizeOf` the goal is to pick `a`
22:16:52 <EvanR> this "its a set" narrative doesnt seem compelling
22:17:01 <EvanR> a type class is an interface
22:17:59 <EvanR> C a => ... notation says you want a to support the interface
22:18:21 <EvanR> operationally you will be passed a dictionary containing the implementation
22:21:13 <dminuoso> iqubic: Note that in my original code that you could use TypeApplications, and then just say `sizeOf @Int` which would be equivalent to the version `sizeOf (Proxy :: Proxy Int)` except I dont have to create these fake values that just carry type information.
22:27:30 <jle`> iqubic: you probably meant, chose what typeclass *instace* to use
22:27:36 <jle`> *instance
22:27:43 <jle`> not choose what typeclass to use
22:28:06 <iqubic> jle`: Yes, that is what I mean.
22:28:07 <jle`> iqubic: if i do `sizeOf (Proxy :: Proxy Int)`, i'm picking the Int instance of the Storable typeclass
22:28:12 <jle`> i am not picking a typeclass to use
22:28:15 <jle`> it is fixed as Storable
22:28:49 <jle`> however, there are situations where you can use type applications to pick between different typeclasses
22:29:10 <jle`> but that might not have been what the discussion was about :)
22:29:57 <dminuoso> jle`: You got my curiosity. How do you do that?
22:30:06 <jle`> you can just use a typeclass
22:30:06 <dminuoso> Is there such a thing as polymorphic typeclasses?
22:30:07 <iqubic> dminuoso: If you use TypeApplications, do you still have to declare that the sizeOf function takes a Proxy a as input?
22:30:08 <jle`> foo @Monad
22:30:15 <iqubic> What does that do?
22:30:15 <dminuoso> iqubic: Nope
22:30:35 <dminuoso> iqubic: In that case you'd just have: `sizeOf :: forall a. Bitsize a => Int`
22:30:41 <jle`> foo @X lets you pick 'X' for a type variable
22:30:48 <jle`> % :t fmap
22:30:49 <yahb> jle`: Functor f => (a -> b) -> f a -> f b
22:30:52 <jle`> % :t fmap @Maybe
22:30:52 <yahb> jle`: (a -> b) -> Maybe a -> Maybe b
22:30:55 <dminuoso> iqubic: Think of sizeOf taking one type parameter "a" before you can use it
22:30:57 <jle`> ^ that lets you fill in 'Maybe' for 'f'
22:31:34 <cocreature> you also often see it when you’re doing some hlisty stuff, e.g., https://hackage.haskell.org/package/generics-sop-0.3.2.0/docs/Generics-SOP.html#v:hcliftA
22:31:37 <koala_man> is it considered awful to do  case () of  _ | cond1 -> res1; _ | cond2 -> res2; ... as a form of if-else chain?
22:31:48 <iqubic> dminuoso: If I call "sizeOf @Int" what is the type signature of "sizeOf?"
22:31:52 <jle`> dminuoso: this is why i think it's useful to call Maybe, Monad, Either, 'True, 'Just, etc. all "types"
22:31:58 <cocreature> koala_man: just use MultiWayIf instead
22:32:42 <dminuoso> jle`: Right. But how do you pick a typeclass?
22:32:49 <jle`> dminuoso: just foo @Monad
22:32:50 <koala_man> nice.
22:32:59 <jle`> % :t Proxy
22:32:59 <yahb> jle`: forall k (t :: k). Proxy t
22:33:03 <jle`> % :t Proxy @Monad
22:33:03 <yahb> jle`: Proxy Monad
22:33:05 <jle`> ^ picking a typeclass
22:33:53 <koala_man> cocreature: what does it mean by "In GHC 7.6, the use of MultiWayIf doesn’t affect layout, instead allowing the previous layout (prior to the if keyword) to remain unchanged"? I do want to support < 7.8
22:34:13 <iqubic> % :t sizeOf @Int
22:34:13 <yahb> iqubic: ; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `Int'; * In the expression: sizeOf @Int
22:34:21 <iqubic> What?
22:34:35 <jle`> % :t sizeOf
22:34:35 <yahb> jle`: ; <interactive>:1:1: error:; * Variable not in scope: sizeOf; * Perhaps you meant one of these: `Data.Set.size' (imported from Data.Set), `Data.Map.size' (imported from Data.Map), `Data.IntSet.size' (imported from Data.IntSet)
22:34:42 <jle`> ^ that's why
22:34:48 <jle`> sizeOf is not imported
22:35:01 <dminuoso> jle`: Wow I didnt know you could be polymorphic over a typeclass. That is so cool :)
22:35:21 <dyl> “In GHC 7.6, the use of MultiWayIf doesn’t affect layout, instead allowing the previous layout (prior to the if keyword) to remain unchanged. This was changed shortly afterwards; in GHC 7.8 and later, MultiWayIf affects layout, just like ordinary function guards do.”
22:35:28 <cocreature> koala_man: see https://ghc.haskell.org/trac/ghc/ticket/7783
22:35:29 <dyl> As in syntactic layout.
22:35:32 <iqubic> Whhy would you want to be polymorphic in that way?
22:35:45 <cocreature> koala_man: but 7.6 is ancient. do you have some specific reason why you want to support that?
22:35:50 <jle`> dminuoso: edwardk put it best
22:36:22 <jle`> dminuoso: "GHC 7.4 gave us the ability to talk about ConstraintKinds. They stopped crashing the compiler in GHC 7.6"
22:36:37 <dminuoso> iqubic: the sizeOf you are using is a slightly different one.
22:36:44 <iqubic> it is?
22:36:58 <dyl> jle`: hah
22:37:17 <dminuoso> iqubic: Foreign.Storable has a sizeOf that suffers from the original problems we talked about.
22:37:18 <dminuoso> iqubic: That is you have to specify `undefined` if you dont have a value at hand
22:37:18 <dminuoso> @let class Bitsize a where sizeOf :: Int
22:37:18 <dminuoso> jle`: ConstraintKinds is some truly black magic.
22:37:18 <lambdabot>  .L.hs:162:9: error:
22:37:19 <lambdabot>      • Could not deduce (Bitsize a0)
22:37:19 <lambdabot>        from the context: Bitsize a
22:37:34 <jle`> gotta allow dem ambiguous types
22:38:13 <dminuoso> Can I toggle extensions on yahb?
22:38:26 <jle`> dminuoso: i like it because it put Monad, Eq, MonadState, etc. on the same level as Maybe, Either, Int
22:38:28 <jle`> dminuoso: yes
22:38:33 <jle`> % :set -XAllowAmbiguousTypes
22:38:33 <yahb> jle`:
22:38:39 <dminuoso> % class Bitsize a where sizeOf :: Int
22:38:39 <yahb> dminuoso:
22:38:50 <dminuoso> % instance Bitsize Int where sizeOf = 64
22:38:51 <yahb> dminuoso:
22:39:05 <jle`> spooky
22:39:08 <dminuoso> % sizeOf @Int
22:39:08 <yahb> dminuoso: 64
22:39:18 <jle`> % :t sizeOf
22:39:18 <yahb> jle`: ; <interactive>:1:1: error:; Ambiguous type variable `a0' arising from a use of `sizeOf'; prevents the constraint `(Bitsize a0)' from being solved.; Probable fix: use a type annotation to specify what `k0', `a0' should be.; These potential instance exist:; instance [safe] Bitsize Int -- Defined at <interactive>:17:10
22:39:20 <koala_man> cocreature: because it's still used in Ubuntu LTS. However, I just saw that 7.6.3 was the last of that kind, and I already blacklisted that because of an optimizer bug that ruins my program
22:39:24 <koala_man> so never mind
22:39:30 <jle`> huh that's weird
22:39:38 <jle`> should be sizeOf :: Bitsize a => Int
22:40:08 <dminuoso> jle`: GHCi at least would show: sizeOf :: Int
22:40:09 <dminuoso> misleadlingly
22:40:15 <jle`> i guess ghci has problems dispalying type signatures of allowambiguoustypes
22:40:28 <jle`> er, of ambiguoustypes
22:40:32 <dminuoso> Ah
22:40:42 <dminuoso> Weird, I thought ghci could do this. Humm..
22:40:51 <cocreature> koala_man: there is an 18.04 lts release by now and there’s a ppa for GHC so you can get it on older releases. I really don’t think the effort of supporting more than the last 3 releases of GHC (which is generally the policy in the Haskell ecosystem) is worth it (but ofc you’re free to do so :))
22:41:03 <geekosaur> I think ghci has problems depending on options
22:43:32 <Axman6> darkJedi: did you sort out your parser question?
22:44:06 <koala_man> I try to be nice about GHC support because I don't target Haskell users, but yeah, there's a limit
22:44:43 <dminuoso> iqubic: Internally polymorphic values are abstractions over types. That is, think of them as values that take an additional type parameter that needs to be specified. GHC figures out what that type parameter needs to be based on annotations and inference.
22:45:02 <cocreature> koala_man: ah fair point although in that case, distributing binaries for your application seems like an easier and more convenient solution than supporting ancient Haskell toolchains
22:45:12 <dminuoso> iqubic: TypeApplications and Proxy let you do this manually. In some cases a full type annotation might be too annoying to write, or in case of sizeOf even impossible.
22:45:34 <cocreature> either way, I’ll shut up now :)
22:46:04 <koala_man> there's plenty of binary options, but you know Linux users :P
22:46:20 <dminuoso> iqubic: You can observe this fact when you enable -ddump-simpl and use something polymorphic like `fmap`
22:46:34 <cocreature> koala_man: oh you’re developing shellcheck? nice!
22:46:58 <koala_man> yup ^^
22:50:16 <marxS> how long have you guys/girls been using haskell for?
22:50:17 <Axman6> niced, I should use that more often
22:50:20 <Axman6> nice*
22:50:28 <Axman6> marxS: 10 years
22:50:49 <jle`> marxS: five years about i think for me
22:51:08 <marxS> Axman6, do you use it for most of the developing you do?
22:51:35 <Axman6> yes, nearly exclusively, except for the odd SQL and shell
22:51:45 <jle`> i use haskell for about 90ish% of my day to day coding for work and research
22:51:57 <marxS> damn
22:52:00 <iqubic> like 1 year
22:52:21 <jle`> i know, so much non-haskell :'(
22:52:24 <marxS> well I guess it also depends what you're doing
22:52:33 <marxS> you likely wouldn't use it for systems eng lol
22:53:46 <marxS> I've been learning ocaml recently but there's not much active community (that I can find), being here helps with some of the general functional programming stuff
22:53:51 <Axman6> why not?
22:54:18 <marxS> why not what?
22:54:26 <Axman6> use it for systems engineering
22:54:38 <marxS> well why would you when you can use rust, or c++?
22:54:58 <marxS> if you're tight on memory, haskell is probably not the thing you'd use lol
22:55:04 <Axman6> better type system, more safety. performance isn't the be all and end all
22:55:13 <marxS> rust's type system is pretty nice
22:55:19 <marxS> and is safe
22:55:30 <Axman6> if you understand the haskell memory model it's not hard to write low memory haskell
22:56:05 <boj> marxS: https://ivorylang.org
22:56:28 <marxS> hmm boj, never heard of this before, will check it out
22:56:45 <boj> that said, you can write quite a bit with boring old haskell
23:02:28 <boj> i really liked this article. shows that if you pay attention you can write performant haskell with minimal memory allocations https://chrisdone.com/posts/fast-haskell-c-parsing-xml
23:07:28 <geekosaur> there was that sound driver written a decade ago or something like that. but… not sure that's anything to show off
23:13:16 <dminuoso> I have a tiny crypto implementation. Is there rewrite/refactoring potential in here? https://gist.github.com/dminuoso/69e9775fa9165c3bb335903d7cebc965
23:14:55 <jle`> dminuoso: why don't you just have it take strict bytestrings?
23:15:52 <cocreature> or make "go" operate on a lazy bytestring
23:16:18 <cocreature> which might be cheaper
23:16:47 <dminuoso> cocreature: There's no ByteArrayAccess instance for lazy bytestrings
23:17:43 <dminuoso> jle`: Honestly I have a bit of a strict/lazy mess which I dont know how to address.
23:17:51 <jle`> dminuoso: in that case, keep the original ones lazy and just strict them at the last minute
23:18:02 <dminuoso> jle`: Like Im doing right now?
23:18:17 <jle`> looks like you strict it from the beginning
23:18:23 <jle`> go would probably benefit from working on lazy bytestrings
23:18:48 <dminuoso> jle`: In most cases you'd be getting 16 or 32 bytes.. a lazy bytestring is beneficial here?
23:19:09 <jle`> ah, in total?
23:19:11 <dminuoso> Yes
23:19:19 <jle`> maybe not then.  just have the function take strict bytestrings then
23:19:36 <jle`> if you're insistent on having them take lazy bs you can use viewpatterns to clean up some of the repitition
23:19:39 <dminuoso> Where would the lazy/strict conversion go? A shallow wrapper around decodedPassword that transforms?
23:19:49 <cocreature> dminuoso: why do you even have lazy bytestrings?
23:20:02 <cocreature> if you’re bytestrings are that short you are not likely to gain anything from that
23:20:25 <dminuoso> cocreature: well the overall input is guaranteed to be no more than 4096 bytes, and it's realistic I will have to use everything.
23:20:27 <dminuoso> That aside
23:20:43 <jle`> decodedPassword (toStrict->auth) (toStrinct->secret) (toStrict->pass)
23:20:45 <dminuoso> cocreature: Two primary reasons: The protocol library Im using happens to give me lazy bytestrings. I can address this by rewriting it myself.
23:20:53 <dminuoso> The other is: Ive been repeatedly told in this channel to not worry about it..
23:20:55 <jle`> but that kind of shows how silly it is to have it take lazy bytestrings in the first place
23:21:23 <cocreature> dminuoso: I wouldn’t worry about it in terms of performance but more in terms of consistency and expressing intent
23:21:41 <cocreature> if your protocol library gives you lazy bytestrings, I would just immediately convert those to strict bytestrings
23:21:51 <jle`> yeah, it's not a perf issue, it's just a normal 'use the types that mean what you want' thing
23:22:08 <dminuoso> cocreature: I might as well rewrite the library then. There's ByteStrings flying around everywhere.
23:22:33 <dminuoso> But you are right..
23:22:41 <jle`> for example, what if the replicate function didn't take an Int, but instead, a string whose elngth indicates the Int?
23:22:52 <jle`> and you don't use the string at all, you just find the length rgith away?
23:22:59 <jle`> why are you even having it take a String?  why not just have it take an Int?
23:24:06 <cocreature> dminuoso: my point is convert at the boundaries where you’re interfacing with APIs that you don’t control to the types that your own code operates on rather than litter your own code with conversions
23:25:22 <dminuoso> cocreature: I have a feeling I might want to use TH for that..
23:25:43 <dminuoso> But I get what you are saying
23:25:47 <cocreature> hard to say without knowing a bit more context :)
23:26:03 <dminuoso> cocreature: https://github.com/erickg/RADIUS/blob/master/src/Network/RADIUS/Types.hs
23:26:40 <cocreature> lazy bytestrings seem like a pretty weird choice here …
23:27:26 <dminuoso> cocreature: my guess it was just an implication of using binary
23:30:10 <jle`> dminuoso: the sane thing would probably to just have your function take strict bytestrings, and then have the people that call your function convert first
23:30:14 <jle`> before calling your function
23:31:34 <dminuoso> cocreature: or maybe Ill just rewrite the entire library. Its small and it probably cant hurt :)
23:31:52 * geekosaur smells famous last words
23:31:54 <cocreature> dminuoso: I don’t think binary is biased when it comes to whether you encode/decode strict or lazy bytestrings. e.g. whether you use getByteString or getLazyByteString is a deliberate choice and not something imposed to you by bytestring
23:36:00 <cheater> hi
23:38:03 <Axman6> o/
23:38:06 <cheater> in a programming language, if i am given a set of values a, and another set of target values b, is it possible to create a "distance" or "cost" function, such that it reflects the amount of transformations needed to derive b from a?
23:38:44 <dminuoso> cocreature: But the frontend of binary (decode/encode) use lazy BS
23:38:58 <Axman6> sounds a little like a levenshtein distance
23:39:13 <dminuoso> cocreature: Even the package description says that binary is for serialization from and to lazy BS
23:39:29 <jle`> cheater: if you really have a set, it sounds like just a set difference plus the intersection
23:39:30 <jchia> I'd like to clarify some doubts about guards. In the gist, I'm using a pattern guard and have to bind it to some otherwise-useless variable x. Is it true that pattern guards have to be bound to something (e.g. variable or function definition)? If so, why is the syntax so restrictive (I can't use it as part of an expression)?
23:39:36 <jchia> https://gist.github.com/jchia/d785c6dfaea8dfd6745a3315b2ce70d1
23:40:28 <jle`> cheater: er sorry, it's just the size of the set of items in a and not b, and the set of items in b and not a
23:40:30 <geekosaur> cheater: what happens if there are multiple such paths?
23:40:32 <cheater> jle`: no... let's say you are given the numbers 2, 3, and 5. How many operations do you need to arrive at the number 1023?
23:40:36 <cocreature> dminuoso: sure but my point is that this is the type of the final result/input and independent of the type of the individual values in your byte stream
23:40:38 <jle`> cheater: https://en.wikipedia.org/wiki/Symmetric_difference
23:40:40 <cheater> geekosaur: you pick the shortest you can find.
23:40:52 <cocreature> dminuoso: also it does have an incremental interface where you feed it strict bytestrings
23:40:52 <jle`> cheater: wait, hold on
23:40:59 <geekosaur> if there are enough that checking all of them for minimum cost is expensive (I smell NP completeness)
23:41:00 <jle`> cheater: originally you said that the target is a set
23:41:04 <jle`> cheater: now the target is a single number?
23:41:13 <cheater> jle`: no... let's say you are given the numbers 2, 3, and 5. How many operations do you need to arrive at the numbers 1023?
23:41:14 <jle`> cheater: do you mean, set the set of just "1023" ?
23:41:23 <cheater> yes.
23:41:24 <jle`> cheater: hm, what sort of operations?
23:41:30 <jle`> cheater: if we're talking about set operations, then:
23:41:34 <cheater> well, that's another question, right?
23:41:37 <jle`> 1) remove 2
23:41:39 <jle`> 2) remove 3
23:41:41 <jle`> 3) remove 5
23:41:45 <jle`> 4) add 1023
23:41:47 <cheater> you don't have 1023.
23:41:51 <cheater> you're trying to derive it.
23:41:57 <dminuoso> cocreature: Ah..
23:42:00 <Axman6> wha operations are you allowed to use?
23:42:01 <cheater> you could just be given +, or maybe you're given + and *
23:42:12 <cheater> Axman6, the operations are part of the initial set
23:42:28 <jle`> cheater: it depends on what you are allowed to "do" with 2, 3, and 5
23:42:39 <cheater> i'm trying to come up with a generalized notion of distance(stuff you started with, stuff you want)
23:42:46 <cheater> or if not distance, then cost
23:42:57 <jle`> cheater: sounds like just a graph search?
23:43:15 <Axman6> jchia: I'm not sure I understand the question
23:43:16 <cheater> i mean, sure, that's one way to look at it
23:43:17 <jle`> it's still not exactly clear what you mean
23:43:28 <jle`> cheater: what is an example of a way to arrive at 1023 from 2,3,5, from what you are thinking?
23:43:34 <jle`> so we know what you mean
23:43:37 <cheater> i'm trying to create a general definition that's in some way sound
23:44:06 <jle`> can you show one example of a way to "go from 2,3,5 to 1023", that you are thinking of?
23:44:20 <jle`> it's still not clear what "go from" means here
23:44:35 <cheater> jle`: if you start with 2, 3, 5, and +, and you want to arrive at 9, you may go 2 + 2 + 5. That's 2 operations.
23:44:43 <cheater> that's probably the minimal distance.
23:45:08 <cocreature> so your transformations are n-ary operators?
23:45:14 <cheater> i.e. the minimal distance between {2 3 5 +} and {2 3 5 + 9}
23:45:35 <cheater> cocreature: transformations are given as part of the initial set
23:45:43 <jle`> it's kind of weird to put + in the same set as 2 3 5, since they aren't really the same type of thing
23:46:11 <jle`> cheater: it sounds like you want something like a graph search
23:46:12 <cheater> not really. sets are not bound to have one type of value. it's only a haskell convention.
23:46:24 <jle`> cheater: i know, but putting it in the same set is not useful here
23:46:30 <cheater> it's very useful
23:46:36 <cheater> because maybe you want to arrive at *
23:47:02 <jle`> so it's not clear what your "operation" is
23:47:14 <cheater> what is the minimal distance between {+ lambda rec} and {+ lambda rec *}?
23:47:30 <jle`> what are the allowed operations?
23:47:36 <cheater> whatever is on the left
23:47:43 <jle`> it's impossible talk about any distance without talking aout the allowed operations
23:47:47 <cocreature> it sounds like your question is something like “given a set of terms, can I construct a program composed of those terms that evaluates to some other term”
23:48:16 <cheater> cocreature: right, or more exactly: assuming i can, what is the smallest amount of steps, and how do i define steps?
23:48:31 <jle`> instead of "steps", do you mean "terms"?
23:48:38 <cheater> i don't know
23:48:43 <cheater> how do you understand terms here?
23:48:56 <jle`> one of {2, 3, 5, +}
23:48:58 <cocreature> are you interested in the size of the program or the number of evaluation steps?
23:49:15 <cocreature> either way this seems undecidable for turing complete languages so you probably want to put some restrictions on this
23:49:24 <jle`> so '2 + 2 + 5' would require five
23:49:24 <cheater> cocreature: how is size different from number of evaluation steps?
23:49:47 <cheater> cocreature: yes, i've already given up tc for other reasons. what other restrictions would you suggest?
23:49:54 <jle`> `2 + 2 + 5` has five things, but only needs two steps to evaluat edown to 9
23:49:58 <cheater> jle`: mhm
23:50:06 <cocreature> cheater: if you have a term that corresponds to a loop, you might have a relatively small program but the number of steps can be far larger
23:50:25 <cocreature> cheater: I don’t know what restrictions are appropriate. depends on what your underlying goal is
23:50:29 <cheater> jle`: is it correct to say that the number of terms is the same as number of AST nodes?
23:50:47 <cheater> with recursive inclusion of data dependencies
23:51:34 <jle`> i'm not sure if terms is the right word to use here actually for how '2 + 2 + 5' having 5, but yeah i think it's something similar to AST nodes
23:54:09 <cheater> for example, if i did           "x = 2 + 2; x + x" to go from { "_ = _" 2 + } to { "_ = _" 2 + 4 }, how would we count here? would we count 9? 1: x, 2: "_ = _", 3: 2, 4: +, 5: 2, 6: ;, 7: x; 8: +, 9: x      or would we first transform away any data dependencies and function calls, so we're counting on the "x + x" line simplified to maximum extent, ie "2 + 2 + 2 + 2", which is 7?
23:54:49 <cheater> cocreature: my underlying goal is to be able to limit the number of steps.
23:55:48 <cocreature> cheater: in what way? you just want an interpreter that doesn’t run forever?
23:56:04 * hackage ideas 1.7 - Feedback services for intelligent tutoring systems  http://hackage.haskell.org/package/ideas-1.7 (BastiaanHeeren)
23:57:06 <cheater> pretty much, yeah
23:57:13 <cheater> but not only that
23:57:20 <cocreature> just count the number of steps and stop after some limit?
23:57:20 <cheater> also not able to do arbitrarily complex things
23:57:37 <cocreature> that’s too vague. what specifically are you trying to prevent?
23:57:42 <cheater> well, that's not really safe, you could have your car run out of gas before you get where you're going
23:58:04 <cheater> it'd be much better to be able to somehow predict the number of steps, so that you can figure out if you'll have enough in the tank, or maybe you should just make your journey more modest.
23:58:45 <cheater> cocreature: basically, as you say, being able to make sure we stop after n steps, but also, being able to tell that we'll be done computing before n is up.
23:59:19 <cocreature> I’m still not sure what your goal here is. if you want to know if you’ll be done computing in n steps, just run for n steps and check if you’re done
23:59:22 <alexad> This sounds like the halting problem but I'm very stupid so I probably just don't understand
23:59:33 <cocreature> I don’t think you are going to be able to do anything more efficient than that in general
