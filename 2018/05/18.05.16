00:52:26 <kuribas> Why isn't there a ghc wasm target?  Wouldn't that be easier than javascript?
00:52:53 <Ariakenom> ghcjs predates wasm afaik
00:52:59 <boj> kuribas: manpower
00:53:29 <hc> wasm target would be totally awesome :)
00:53:34 <geekosaur> there's at least two people working on wasm currently
00:53:45 <Ariakenom> but it's harder not easier afaik. wasm needs to port more of the runtime than js
00:53:50 <geekosaur> and both regularly popping up in #ghc with questions; it's not exactly trivial
00:54:10 <hc> It's about time something like wasm happened, though
00:54:19 <hc> js is just a weird target language ;-)
00:55:06 <boj> i think tweag has a project, and elvishjerrico gave up his work. not sure what the state is these days
00:57:20 <boj> kuribas: a reply to a question i asked https://www.reddit.com/r/haskell/comments/8806xt/tweag_io_we_are_hiring/dwi8heu/
00:57:42 <hc> geekosaur: what's the difficulty of using wasm compared to JS btw?
00:58:01 <hc> When using the asm subset of js, I mean
00:58:52 <geekosaur> you're probably better off talking to elvishjerricco and/or ninetoo about that; I don't know details, just been seeing them trying to figure various things out
00:59:21 <geekosaur> part of it is that, while ghc has an llvm backend that could hypothetically be used to generate wasm, it doesn't really use it right
00:59:33 <geekosaur> (but a new one is in the works which may be more suitable)
01:00:13 <elvishjerricco> Yea so the RTS is actually way easier to build for wasm than JS. We can reuse almost all the C / Cmm in the RTS, whereas GHCJS has to rewrite all of it
01:00:52 <elvishjerricco> The LLVM backend isn't currently suitable because wasm doesn't have tail calls. There's a proposal that should hopefully be merged into the wasm spec within the next few months, and then we just have to wait on LLVM supporting the wasm instruction
01:01:08 <elvishjerricco> So we use the Haskell -> C version of GHC, which uses a trampoline for tail calls.
01:01:18 <elvishjerricco> https://github.com/WebGHC/wasm-cross
01:01:34 <boj> elvishjerricco: maybe i was mistaken, are you still working on this?
01:01:46 <elvishjerricco> boj: Yea, I just don't have a lot of time for it
01:02:06 <boj> cool, figured as much
01:02:08 <elvishjerricco> A couple of weeks ago I got the whole GHC at least building. Still a few binary issues lingering before we can move on to syscall emulation though
01:04:12 * hackage tasty 1.1.0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-1.1.0.1 (RomanCheplyaka)
01:17:39 <kuribas> boj, elvishjerricco: is that 2/3 performance improvement over ghcjs?
01:18:07 <kuribas> because I measured my (numerical) code to be about 1000x slower than the native one.
01:18:29 <kuribas> 3x improvement would mean 30x slower, still much
01:18:31 <elvishjerricco> kuribas: I'm not really sure what performance improvement to expect over GHCJS. I do expect it to be significant though. 5-10x would not be surprising. Though 1000x slower does not sound characteristic of GHCJS to me...
01:18:35 <elvishjerricco> but
01:18:55 <elvishjerricco> the 2-3x slower was with respect to another team's implementation of Haskell->wasm, since they're using a native code generator
01:19:03 <kuribas> right
01:19:41 <cocreature> 1000x sounds like something went very wrong :)
01:19:46 <elvishjerricco> kuribas: I'm guessing there's something else at play with your 1000x
01:19:56 <elvishjerricco> Like I think `Integer` is WAY slower on GHCJS, IIRC
01:20:05 <kuribas> I am using double btw
01:20:06 * hvr typically saw ~10x-50x slowdown re native ghc binaries when running on nodejs of ghcjs
01:20:21 <hvr> for some parser-heavy code
01:20:22 <kuribas> well Num, specialized to Double everywhere
01:20:22 <elvishjerricco> Yea, doubles should be ok on GHCJS
01:20:29 <elvishjerricco> so that's odd
01:20:39 <elvishjerricco> But 10x-50x does sound about like GHCJS's wheelhouse...
01:20:47 <kuribas> it's been a while though, perhaps that has improved now
01:20:54 <hvr> the most annoying part w/ ghcjs on nodejs however was its mem footprint which was 10x
01:21:12 <cocreature> for a 1000x slowdown, I would question whether I’m actually benchmarking correctly
01:21:19 <elvishjerricco> If I'm expecting a third the speed of native with the C backend to wasm, then we'd have 3-17x faster than GHCJS
01:21:54 <kuribas> that'd be great
01:24:26 <elvishjerricco> The problem is that GHC wants to represent things in very precise and compact memory regions with an eye for making said memory fast (often even storing important things in registers). GHCJS gets absolutely none of that, and relies on the JIT to find it all. Considering how unidiomatic the JS is and how many indirections it follows, the JIT utterly fails.
01:27:58 <quicksilver> yeah because thinks like javascript JITs are inherently heuristic and optimised based on idiomatic / common cases
01:28:21 <quicksilver> (and optimised based on synthetic benchmarks that happen to matter because people run those benchmarks when new browsers come out :P)
01:56:59 <cocreature> is there a way to :add multiple main modules in ghci, e.g. the main of the test and of an executable?
01:57:21 <cocreature> I’m fine with not being able to access one of them but I’d like them to be checked on :r
01:57:29 <hvr> cocreature: what would the semantics be?
01:58:00 <cocreature> hvr: load and typecheck both, bring only one of them in scope
01:58:25 <[exa]> cocreature: import both to one module and re-export the selected main?
01:58:39 <hvr> cocreature: unfortunately ghci has a fundemantal limitation which blocks us from having "multi component" support in cabal repl
01:58:49 <cocreature> [exa]: yeah that’s what I’m doing currently. I was hoping for a nicer solution :)
01:59:22 <[exa]> cocreature: maybe there's a name to quickly redefine the name of main
01:59:25 <[exa]> *way
01:59:43 <cocreature> hvr: I know that’s why I’m not using cabal repl but just raw ghci :)
02:00:20 <hvr> cocreature: yeah... that's also why most of the time I don't use cabal repl, but rather rely on .ghc.env files ;)
02:01:11 <cocreature> ghc.env files only solve half of the problem. e.g. you still need to manually specify default-extensions
02:03:40 <AWizzArd> When writing Haskell programs we can/do use three languages that ghc will make use of: value language, type language and kind language. Is that correct?
02:05:11 <merijn> hvr: .ghc.env seems very unreliable if you have multiple components, though
02:05:20 <merijn> hvr: I never got them to *actually* work
02:05:40 <merijn> hvr: The only thing they really appear to do is break regular ghci
02:09:41 <kuribas> AWizzArd: I see it as two languages: (value with type type), (type with type (kind or type))
02:10:37 <tdammers> I'm not sure calling them "languages" is such a good idea
02:11:38 <tdammers> conceptually, we have these three levels (terms, types, kinds), but modern Haskell kind of blurs these, and a properly dependently-typed language like Idris doesn't really distinguish them at all
02:16:12 * hackage splitmix 0.0.1 - Fast Splittable PRNG  http://hackage.haskell.org/package/splitmix-0.0.1 (phadej)
02:17:34 <AWizzArd> Okay, thanks for the inputs.
02:20:33 <AWizzArd> How can I search http://ircbrowse.net/browse/haskell ? I’ve tried Google with the site: specifier already.
02:21:01 <merijn> AWizzArd: I don't think you really can very well
02:22:14 <asdfgh> If Haskell can consistently be parallelized because most of the program is purely functional and the rest is isolated in monads, why weren't there efficient Haskell -> Itanium compilers?
02:22:41 <boj> asdfgh: science
02:22:50 <AWizzArd> merijn: possibly this could be a fun side project – write a web scrawler and copy that whole database :-)
02:22:52 <merijn> asdfgh: Because Itanium was a horrifically difficult architecture to generate code for
02:23:11 <cocreature> also automatic parallelization is far from a solved problem
02:23:12 <merijn> AWizzArd: You could just try emailing Chris Done and ask if he can get you a copy...
02:23:26 <merijn> automatic parallelisation is the opposite of a solved problem :)
02:24:01 <tdammers> just taking a bit of code and transforming it into code that can run in parallel is the easy part
02:24:07 <tdammers> the hard part is deciding when to do it
02:24:13 <merijn> I've seen about 30 projects (from bachelor's/master's to 4 year EU projects with multiple partners) all of which boil down too "we'll take some pure code, do some statistical analysis over past results and run it in parallel optimised based on our results!"
02:24:24 <merijn> Basically all of them fail in the same predictable ways :)
02:24:48 <boj> failure is predictable! maybe we can derive something from that :p
02:25:00 <tdammers> it's like how Hitler's meterologists used statistical approaches to predict a particularly mild winter, and we all know how that ended
02:25:21 <merijn> My master project was doing the same thing
02:25:26 <merijn> It was going to be so easy!
02:25:38 <shiona_> Is there some meaningful difference between Data.Serialize and Data.Binary?
02:26:13 <merijn> shiona_: Binary originally only supported lazy BS and no incremental strict decoding, that has since been fixed
02:26:22 <asdfgh> merijn: I've seen the claim that strictly-evaluated code is easier to parallelize than non-strict. Besides highly-imperative closure reduction to work efficiently on Von Neumann architectures, is Haskell unsuitable for pervasive SISAL-like parallelism because of this?
02:26:25 <merijn> shiona_: There was talk (years back) on merging them, but it never happened
02:26:36 <merijn> shiona_: binary is probably the most reasonable "default" choice by now
02:26:50 <shiona_> ok. That would have been my next question. Thank you.
02:27:06 <tdammers> asdfgh: lazy evaluation introduces additional difficulties, yes
02:27:08 <merijn> asdfgh: Naah, auto-paralellising strict code is just as hard (my project used strict code)
02:27:21 <tdammers> asdfgh: but they're not fundamental, really
02:27:47 <asdfgh> merign, tdammers: Also, there are more recent purely functional, pervasively parallel languages for GPUs like Futhark. Do they have significant differences in core structure from Haskell?
02:28:12 <tdammers> asdfgh: I have no idea, but I would expect them to
02:28:19 <asdfgh> (Futhark examples seemed semantically similar to Haskell when I looked at them)
02:28:22 <merijn> asdfgh: Ask Athas :p
02:28:35 <merijn> asdfgh: Well, that might be, because the guy who wrote Futhark is a regular here :p
02:28:46 <asdfgh> merijn: Thanks for the reference.
02:29:59 <merijn> In other news, dons is helping me get over my impostor syndrome: https://twitter.com/donsbot/status/996665301155631105 ;)
02:30:37 <asdfgh> Are there alternatives to lazy & eager evaluation? merijn: lol
02:31:07 <merijn> I've gotten "ghci; filter even [1..5]" down as force of habit to figure it out by now
02:31:30 <Athas> asdfgh: the core of functional languages are decently suited to parallel execution, but they also come with a few parts that are not.
02:31:58 <Athas> A parallel functional language is very much like a subset of a mainstream functional language, with only minor differences.
02:32:17 <merijn> asdfgh: Yes, but I don't know any examples of the top of my head
02:32:33 <asdfgh> Athas: What are those differences? Is that off topic here?
02:35:42 * hackage network-simple-tls 0.3 - Simple interface to TLS secured network sockets.  http://hackage.haskell.org/package/network-simple-tls-0.3 (RenzoCarbonara)
02:36:19 <jchia> I already have "default (Int, Double)" at the top of my source code file but I'm still getting the warning "Defaulting the following constraint to type". Can I make the warning disappear for cases when I already specified a default and appear for cases when I didn't?
02:36:46 <jchia> Also, can the default be put in the cabal file?
02:36:58 <asdfgh> Thanks for the help
02:37:32 <merijn> jchia: o.O
02:37:57 <merijn> jchia: Of course that won't work
02:38:07 <merijn> jchia: The warning is about the fact that it IS defaulting
02:38:26 <merijn> jchia: And the trivial solution is: 1) just annotate the type or 2) disable the warning
02:39:11 <merijn> jchia: It doesn't make sense for the warning to "disappear when I already specified a default" because that fact that it's USING that default is what it's warning about
02:40:46 <merijn> jchia: Also defaulting to Int and Double is default behaviour, so adding an explicit default annotation for those is redundant
02:41:04 <merijn> oh, wait, I suppose the default is Integer and Double
02:41:07 <merijn> Anyway
02:43:36 <Saizan> jchia: if you really want there's -fno-warn-type-defaults
02:44:26 <Athas> asdfgh: no linked lists!
02:44:47 <merijn> hah, I like Lennart casually humble-bragging on reddit
02:45:11 <merijn> "Why did you learn Haskell?"-thread: "When the first Haskell report came out I wanted to try it. But there was no Haskell compiler. So I learned Haskell in order to write the compiler (hbc)."
02:45:25 <electrocat> merijn: lol
02:58:23 <quicksilver> it is the best way to learn a new language
02:58:42 <quicksilver> although you if you want to really learng it properly you should make it self-hosting
03:00:07 <tdammers> to truly learn a programming language, it's best to invent it yourself
03:13:56 <dibblego> I do not agree re: self-hosting
03:14:05 <dibblego> try self-hosting python, for example
03:15:17 <jchia> merijn: I'm looking for a warning where I didn't specify the defaults and they are defaulting with the 'default default'
03:21:35 <quicksilver> dibblego: I was being a little flippant :)
03:21:46 <dibblego> :)
03:21:55 <edwardk> dibblego: the pypy stuff paid off pretty well over there actually :)
03:22:20 <dibblego> edwardk: orly? I look forward to playing spot-the-difference with cpython
03:22:49 <quicksilver> dibblego: continuing the theme of flippancy, perhaps languages which are not conveniently capable of self-hosting compilers, maybe they are not worth learning :)
03:23:12 <dibblego> quicksilver: regardless, they can be learned, but it requires haskell.
03:24:41 <edwardk> dibblego: when do you get to sydney?
03:26:13 <dibblego> all 6 of us arrive at 1940 UTC+10 on 20180520
03:27:02 <dibblego> how the bloody hell is sydney?
03:27:20 <edwardk> k was basically just checking to see if we'd have any time on the ground for prep before the workshop
03:27:28 <edwardk> not bad actually
03:27:36 <dibblego> crikey, yeah nah
03:27:42 <edwardk> having a pretty good time modulo the kinda meh weather
03:27:52 <dibblego> what is meh about it?
03:28:12 <edwardk> its colder than boston, ergo meh
03:28:19 <dibblego> some people say sydney weather is great, then proceed to say silly things
03:28:24 <dibblego> haha
03:28:32 <dibblego> ummm, we are going to a place...
03:28:55 <dibblego> http://www.weatherzone.com.au/qld/darling-downs/stanthorpe
03:29:02 <edwardk> i come to australia to get warm. you are failing your geographically mandated mission
03:29:14 <dibblego> it gets warm there all the other weeks of the year
03:29:39 <dibblego> so, when we tell people "it gets to -1" then they say "lol that's not even cold"
03:29:57 <dibblego> there's a thing, "it gets to -1 in a sub-tropical climate"
03:30:04 <dibblego> it's different to all the other -1
03:30:44 <dibblego> Canberra is like "cold" because it gets to -7 but it's actually not cold
03:31:09 <dibblego> anyway, it will be day time, so all good, promise
03:31:48 <dibblego> here are some interesting python programs, https://gist.github.com/LightAndLight/3500e6cb28af865095c8f2bab46cb62f
03:31:59 <edwardk> hah. remind me to pack survival gear for the inevitable crash and ensuing buddy comedy that will result
03:32:16 <dibblego> I already have that on board :)
03:33:21 <dibblego> many of those python programs were generated by haskell (hedgehog)
03:36:32 <dibblego> I know a pilot who briefs passengers like this, "This is an Electronic Location Transmitter (ELT), place the ELT on top of the aircraft, so that the antenna is pointing to the sky, unless the aircraft is upside-down, in which case, place the ELT underneath the aircraft, so that the antenna pointing to the sky"
03:43:03 <lightandlight> Most of them are from me being way too familiar with python's "grammar" and "semantics"
03:43:37 <lightandlight> Re: scroll-up: I think PyPy probably works "better" than cpython
03:43:55 <lightandlight> "works" "better"
03:43:57 <dibblego> what is this thing, "better"?
03:44:00 <dibblego> ok
03:50:06 <merijn> jchia: Such a warning does not exist
03:51:02 <tdammers> dibblego: isn't that actually an Emergency Location Transmitter?
03:56:55 <shiona_> I'm continuing my quest of learning networking with haskell. Now I'm in a situation where two players can play a game of Rock-Paper-Scissors, but only if everything goes according to plan. Next up would be to notify player1 if player2 disconnects, but I don't know how I would do this. The situation is that a "thread" (forkFinally) is in a blocking recv and would need to monitor a TVar at the same time to
03:57:01 <shiona_> know if the other player is still connected
03:57:47 <dibblego> er yeah, thanks
03:58:13 <cocreature> shiona_: maybe https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:race would be helpful?
03:58:59 <merijn> cocreature: Or work around it by rolling your own receive
03:59:28 <shiona_> cocreature: that looks like it might work
03:59:35 <cocreature> merijn: that sounds like way too much work ;)
03:59:41 <merijn> shiona_: Are you okay with a *nix specific (I think)? approach
03:59:46 <merijn> cocreature: Doesn't have to be, tbh
03:59:51 <merijn> shiona_: Because there's https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Concurrent.html#v:threadWaitReadSTM
04:00:31 <merijn> shiona_: Which would let you combine polling the socket and another "disconnect" notification together in STM
04:00:44 * hackage pipes-network 0.6.5 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.6.5 (RenzoCarbonara)
04:05:39 <shiona_> I think race sounds like a simpler/easier to understand solution
04:07:12 <merijn> shiona_: Probably, but it's nice to know that threadWaitRead(STM) and co exist when you wanna handroll more advanced primitives :)
04:07:31 <merijn> Since they let you plug your own custom code directly into the existing event-loop of the GHC rts :)
04:08:04 <shiona_> Sounds fancy, but I don't think I'm quite there yet.
04:12:42 * hackage dual-tree 0.2.2 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.2 (BrentYorgey)
04:12:44 <cocreature> merijn: do you know of some code that uses threadWaitReadSTM? I recall that I’ve seen it used somewhere but atm I’m having trouble seeing how you would use it
04:16:20 <merijn> cocreature: How so? What's the problem?
04:16:39 <merijn> The only code I know that uses is my unreleased experimental ZeroMQ implementation :p
04:17:19 <cocreature> ah now I got it I think
04:17:20 <merijn> cocreature: Lots of C/C++ libraries expose a file descriptor you can use to poll for library status (i.e. "do I have new messages?") since it's one of the few cross-language ways to block
04:17:57 <merijn> cocreature: All it does is "block this haskell thread until this Fd is marked readable", except it does this an STM transaction so you can poll multiple STM sources
04:18:22 <liste> merijn: so you're implementing ØMQ in pure Haskell?
04:18:40 <merijn> liste: Naah, I gave up on that code years ago
04:18:53 <merijn> liste: But that's what I was doing, yes
04:21:56 <Ariakenom> merijn: What interesting do you have to share from that?
04:23:12 <Ariakenom> Oops eh, add a noun of your choosing
04:23:46 <merijn> Ariakenom: Not much, I had a parser for the various protocol versions around that time and some basic work on different socket types, but I only ever implemented one or two sockets before I got to swamped with other work and it ended up on the heap of "projects I would like to finish if I could get paid to do it, but would rather play videogames than work on in my free time"
04:25:37 <Ariakenom> cool. what made you pick zeroMQ?
04:27:31 <merijn> I wanted to use it for some stuff that ended up on the same heap ;)
04:27:53 <Ariakenom> it's an attractive heap
04:28:24 <merijn> There's lots of cool stuff on there that no one wants to pay me for ;)
04:29:29 <merijn> Like the completely fictional high-level CUDA bindings, that I, in hindsight, regret not investing the time to write in the first year of my PhD :p
04:30:01 <merijn> OTOH, without the 3 year struggle with C++ I probably wouldn't know as well how I'd want them to work
04:30:42 * hackage quickspec 2.1 - Equational laws for free!  http://hackage.haskell.org/package/quickspec-2.1 (NickSmallbone)
04:31:17 <Ariakenom> I've always wondered over what models to use for GPU and graphics stuff.
04:32:18 <merijn> Speaking of which, something I'm curious about: Is anyone aware of tools that help me link to templated C++ functions from Haskell?
04:32:59 <merijn> Note: I'm not expecting the templates to be instantiated, I just want to call *already* instantiated template functions, so I need to know how to get the right mangled name to call
04:33:00 <Ariakenom> what were the features of the ideal bindings?
04:33:18 <merijn> Ariakenom: Type-safe method for calling kernels
04:33:47 <merijn> I spend so much time debugging stupid errors due to the kernel parameters not matching the host side
04:34:27 <cocreature> merijn: inline-c/inline-c-cpp?
04:35:31 <merijn> cocreature: Pretty sure those don't support template functions
04:35:56 <merijn> All the C++ binding tools seem to focus all their effort on supporting objects, which I couldn't care less about
04:36:12 <cocreature> merijn: not directly but afaik they’ll generate a C wrapper that calls your template function
04:37:04 <merijn> cocreature: Which doesn't work for me, since there is no actual function for it to call :)
04:37:10 <quicksilver> not in a smart way which involves using type inference to populate the parameters of the template
04:37:15 <quicksilver> as far as I know
04:37:38 <merijn> quicksilver: I'm okay with explicitly wrangling the types, as long as I don't have to write N specialisations for the same template
04:37:46 <cocreature> merijn: huh? why is there no function to call?
04:38:05 <merijn> cocreature: Because it's GPU kernel which can't be called and is just a pointer to pass to the driver
04:38:14 <merijn> cocreature: But that means I need to somehow *get* that pointer
04:38:29 <cocreature> ah ok
04:38:34 <cocreature> no idea then, sry
04:38:35 <merijn> cocreature: Which means knowing the mangled template function name for the stub
04:40:05 <quicksilver> https://purelyfunctional.org/posts/2017-05-30-haskell-binding-c++-template.html looks relevant
04:41:07 <cocreature> quicksilver: not really (disclaimer: I wrote that post :))
04:41:21 <merijn> quicksilver: That relies on manually writing 'extern "C"' wrappers
04:41:30 <merijn> Which is exactly what I don't want to do :)
04:42:20 <merijn> Also, most of the tools seem to have...spartan documentation :)
04:42:36 <Ariakenom> can you TH extern C?
04:43:10 <merijn> Most don't mention templates at all, tbh
04:43:16 <cocreature> Ariakenom: that’s basically how inline-c works
04:43:17 <merijn> Which is probably the sane thing
04:43:24 <merijn> But I don't care about doing sane things!
04:43:55 <merijn> If I wanted to do sane and feasible things I wouldn't have started a PhD!
04:44:48 <Ariakenom> But you can surely generate the instances programmatically with TH?
04:47:05 <quicksilver> yeah I couldn't find anything that had proper template support
04:47:15 <quicksilver> they concentrate on interfacing to the C++ ABI
04:47:20 <quicksilver> not the C++ API (compile-time)
04:50:07 <t_> data Complex a = !a :+ !a   What does '!' mean here?
04:50:27 <t_> the code is from http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Complex.html#Complex
04:50:43 <liste> t_: it's a strictness annotation
04:51:28 <liste> t_: https://wiki.haskell.org/Performance/Data_types#Strict_fields
04:52:25 <t_> liste: Thank you so much!
04:57:23 <ongy> glguy: btw. did you reply to my askinga bout config-schema a while ago? I never saw an answer
05:23:39 <andreabedini> question: when I build my project with cabal new-build I get a lot of "ignoring (possibly broken) abi-depends field for packages", what does that mean?
05:24:52 <merijn> andreabedini: Which GHC version and which cabal-install version?
05:25:08 <andreabedini> ghc-8.2.2 cabal-install version 2.2.0.0
05:25:49 <merijn> andreabedini: Ah, this seems potentially related? https://ghc.haskell.org/trac/ghc/ticket/14381
05:26:26 <Taneb> andreabedini: which operating system are you on?
05:26:37 <andreabedini> macos
05:27:03 <andreabedini> merijn Taneb, yeah that must be related
05:28:23 <jchia_2> Question about OverloadedLabels/getField: Has Section 2.2 of this proposal actually been implemented? https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0002-overloaded-record-fields.rst I can't seem to detect the IsLabel instance for using "#x :: Foo -> Int" when I have a "data Foo = Foo {x :: Int}".
05:29:11 <Taneb> andreabedini: I believe it's nothing to worry about
05:29:27 <jchia_2> At the top of the document, it says "implemented: 8.2"
05:30:03 <jchia_2> Or, is some library supposed to provide the IsLabel instance?
05:30:11 <andreabedini> Taneb: cool, thanks :)
05:34:30 <cocreature> jchia_2: afaik it hasn’t been implementetd since there wasn’t a clear agreement on whether an instance for functions should provide lenses, record accessors or something else
05:34:57 <jchia_2> cocreature: OK. I suppose the "implemented: 8.2" is not accurate, then.
05:35:52 <cocreature> yeah something like “partially implemented” would be more accurate
05:40:13 <bahamas> hello. I'm on mac os x and I'm trying to install the haskell-ide-engine with stack. however, I get an error about undefined symbols "_iconv". does anyone have any idea how I can go around this issue?
05:40:34 <merijn> bahamas: Lemme guess, you have MacPorts somehwere?
05:41:34 <bahamas> merijn: brew
05:41:58 <merijn> bahamas: Not sure how it works with homebrew, but MacPorts libraries link against their own version of libiconv, rather than the one that ships with OSX, so if your Haskell libraries link against C libraries installed via MacPorts stuff starts whining about that
05:42:36 <merijn> bahamas: So that's the direction to troubleshoot in
05:44:45 <bahamas> merijn: I found this issue /usr/local/opt/libiconv/lib
05:44:45 <bahamas>   - /usr/local/lib
05:45:34 <bahamas> sorry. I mean this issue https://github.com/commercialhaskell/stack/issues/825. I tried this solution, but I still get the same https://github.com/commercialhaskell/stack/issues/825#issuecomment-210866660
05:46:10 <bahamas> so I have no idea what else I can try, because I don't have much experience with Haskell or C libraries
05:53:02 <bahamas> uninstall libiconv with homebrew worked. I don't know what formula depended on that one, but hopefully I will at some point
05:53:10 <bahamas> *uninstalling
06:01:19 <jchia_2> Has anyone used Data.Generics.Labels (generic-lens-labels)? Is it something you could recommend?
06:24:52 <merijn> jchia_2: Any specific reason why you want these overloaded label like things?
06:25:09 <dminuoso> Just so Im on the right path. I want to prepare a library to be built with stack, and I have no idea how to configure this.
06:25:17 <merijn> bahamas: FYI you can tell cabal to use specific linker flags to make it prefer another library to fix this kinda issue
06:25:21 <dminuoso> It seems that hpack contains the documentation I need, is there any other useful resources?
06:25:24 <jchia_2> merijn: To get around the lack of OverloadedRecordFields. I have many types with the same field names.
06:25:27 <merijn> bahamas: But that means you have to specify that flag every time
06:26:00 <dminuoso> I've been skimming through the stack documentation, there does not appear any immediately useful bits for exposing a library in there.
06:26:03 <merijn> jchia_2: If you keep them in separate modules and import qualified that's not necessarily a problem, but that depends on how you write code I suppose
06:26:41 <merijn> dminuoso: So far my approach has been "just stick with cabal-install, because that's what I use and wait for some stack user to contribute a stack.yaml thingamajig" :p
06:27:16 <cocreature> dminuoso: you don’t need hpack. stack works just fine with cabal projects
06:27:25 <merijn> My code isn't free as in speech or free as in beer, it's free as in puppies
06:27:34 <merijn> aka, you'll have to pay to get it fixed ;)
06:27:56 <cocreature> all you need is a stack.yaml file and you only need that if you want people to hack on your project rather than just fetch it from hackage or use it as a dep from your github repo
06:28:00 <jchia_2> merijn: That will mean a ton of modules with quite long names so the code using the will be quite long. Renaming the record type names will also be a quite tedious.
06:28:19 <jchia_2> It's similar to the workaround of prefixing the field name with the (record) type name.
06:28:30 <merijn> jchia_2: You can alias module names during import, if the length is the issue :)
06:28:44 <dminuoso> cocreature: Ah. So hpack is just used to generate a cabal file from package.yaml?
06:28:46 <jchia_2> merijn: There are many records and only 26 letters in the english alphabet.
06:28:54 <cocreature> dminuoso: yes and it’s an optional feature
06:29:20 <cocreature> dminuoso: it’s also independent from stack. stack makes it easy since it automatically calls hpack but apart from that you can just as well use hpack with cabal
06:29:39 <bahamas> merijn: how would I specify that flag if I'm using stack?
06:30:00 <merijn> bahamas: As a non-stack user: absolutely no clue :)
06:30:42 * hackage integreat 0.2.2.1 - Integrate different assays.  http://hackage.haskell.org/package/integreat-0.2.2.1 (GregorySchwartz)
06:31:54 <jchia_2> merijn: If I follow the convention of using the first letter of the record type name as the import alias, if I have two record types that start with the same letter, then it won't work. If I have no convention, then reading the code requires remember which alias stands for which module.
06:32:47 <merijn> jchia_2: I'd probably do something like "import Foo.Bar.Blah as Person" (if it had, say, a person record) and then use "Person.name" or "Person.id" to access the fields
06:33:11 <merijn> Of course that somewhat assumes you have one record per module, so might not work
06:33:22 <vidlew> free as in vector space
06:33:41 <merijn> jchia_2: Anyway, most/all of these features to work around this are quite brittle and new atm, so there's no real "rock-solid" solution/answer for you
06:34:38 <dminuoso> cocreature: Oh there we go. Cabal is well documented it appears =) https://www.haskell.org/cabal/users-guide/developing-packages.html
06:34:53 <merijn> dminuoso: Anyway, unless you yourself use stack I'd just let some stack user do it for you ;)
06:36:09 <dminuoso> merijn: I use stack. ;)
06:36:12 <cocreature> merijn: tbh I wouldn’t even let it do them for you. just let them do it locally. unmaintained stack.yaml files are more annoying than no stack.yaml files ime
06:36:26 <cocreature> dminuoso: wait what? then I don’t understand your question
06:36:35 <cocreature> dminuoso: did you miss a negation in your initial question?
06:36:54 <vidlew> @let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) $ ack m $ n-1
06:36:56 <lambdabot>  Defined.
06:37:03 <vidlew> > ack 3 3
06:37:05 <lambdabot>  61
06:37:09 <vidlew> > ack 4 4
06:37:12 * hackage normalize 0.3.0.0 - Normalize data using a variety of methods.  http://hackage.haskell.org/package/normalize-0.3.0.0 (GregorySchwartz)
06:37:15 <lambdabot>  mueval-core: Time limit exceeded
06:37:58 <jchia_2> merijn: I put the record type DogHealthRecord in the module Records.DogHealthRecord and DogShelterInfo in Records.DogShelterInfo, I'm going to have long code using things like DogHealthRecord.name and DogShelterInfo.name. I can't abbreviate with the first letter 'D' because that would lead to ambiguity. Yeah, I haven't found any solution that I like and it's for me at least half the pain when developing in Haskell.
06:38:02 <vidlew> ack 3 4
06:38:06 <vidlew> > ack 3 4
06:38:08 <lambdabot>  125
06:38:12 <vidlew> > ack 4 3
06:38:18 <lambdabot>  mueval-core: Time limit exceeded
06:38:44 <cocreature> jchia_2: I don’t think merijn or anyone else is saying that the current situation is great. but the alternatives aren’t the promised land you’re looking for either ime
06:38:46 <dminuoso> cocreature: Okay so I use stack for no real reason other than that's what Im used to it, and that it makes switching between GHC versions kind of easy.
06:39:06 <dminuoso> cocreature: I have a library that I want to package up to be used in another program.
06:39:16 <merijn> dminuoso: tbh, switching GHC versions with cabal is pretty trivial too :p
06:39:28 <cocreature> dminuoso: upload it to hackage?
06:39:41 <jchia_2> cocreature: OK. I've tried a few. Every workaround has some important downsides.
06:39:41 <merijn> dminuoso: The only thing I do is "change my path" and everything else Just Works (TM)
06:39:53 <jchia_2> like merjin said
06:40:37 <dminuoso> merijn: In Ruby I know that comfy feeling, but that's because I have deep knowledge about how it works, how files are rqeuired, how libraries are loaded, etc. GHC is still shrouded, and Im swamped in so many things I need to read..
06:41:56 <merijn> dminuoso: Anyway, the Cabal docs are a pretty good starting point for writing cabal files (or just run "cabal init" and answer the questions for a minimal starting point)
06:42:15 <Nightwish> o.o
06:42:22 <Nightwish> 1734 users
06:42:38 <Nightwish> someone told me this is a fun place to be, is it?
06:42:46 <cocreature> dminuoso: if you don’t want to upload it to hackage, then just reference it in extra-deps
06:42:59 <byorgey> Nightwish: very fun, especially if you want to learn about the Haskell programming language
06:43:09 <Nightwish> ah i see
06:43:40 <Nightwish> well, i have no idea what that is (shames) so i guess i'll get going
06:43:42 * hackage subsample 0.1.0.0 - Subsample data.  http://hackage.haskell.org/package/subsample-0.1.0.0 (GregorySchwartz)
06:43:48 <byorgey> Nightwish: https://www.haskell.org/
06:43:52 <cocreature> dminuoso: you can specify git repos, local and remote tarballs and local directories in extra-deps
06:46:12 * hackage normalize 0.3.0.1 - Normalize data using a variety of methods.  http://hackage.haskell.org/package/normalize-0.3.0.1 (GregorySchwartz)
06:54:26 <dysfun> how do i use client certificate authentication with Data.Conduit.Network.TLS ? i can't see any hooks for that sort of thing
06:59:09 <dminuoso> cocreature: Mmm fair enough. It cant be that hard =)
06:59:14 <dminuoso> Thank you both cocreature and merijn.
07:01:43 <ch3pjw> I have a probably somewhat ridiculous problem of my own making: https://gist.github.com/ch3pjw/829a5254a629328728a58529cb594639
07:02:01 <ch3pjw> If anyone is a type-class or existential guru, I could really use a hand.
07:03:51 <ventonegro> existential guru :)
07:07:34 <electrocat> ch3pjw: you know that ghc can't reason backwards through instance declarations?
07:07:54 <electrocat> c1 & c2 does not prove c1 and c2
07:08:08 <electrocat> well in theory it does
07:08:15 <electrocat> but in practice ghc can't
07:09:14 <ch3pjw> electrocat: I think I'm struggling because my intuition about what I know is fighting with how GHC works!
07:10:43 <ch3pjw> electrocat: I'm struggling because I want to be able to say in my tests that my existential type is Arbitrary, but I don't want to have to depend on QuickCheck in the library...
07:12:14 <cocreature> QuickCheck is a pretty light dep. if you’re really doing this only to avoid a dep on QuickCheck I would highly recommend just depending on QuickCheck instead :)
07:12:30 <c_wraith> Or just create an orphan instance?
07:12:35 <cocreature> yeah or that
07:13:05 <cocreature> existentials without GADTs are almost never a good solution
07:13:12 <c_wraith> there's no real problem with orphan instances in applications, and tests are applications.
07:13:27 <c_wraith> orphans only tend to be problems when they're in libraries
07:13:56 <[exa]> ch3pjw: could you implement that thing in prolog?
07:15:16 <ch3pjw> [exa]: proglog as in the language? I've never written any prolog
07:15:31 <electrocat> ch3pjw: are you sure your definition of Ex is correct?
07:15:47 <ch3pjw> electrocat: "correct" in what sense?
07:15:51 <electrocat> oh nvm
07:16:05 <ch3pjw> electrocat: This is really just an experiement in a bigger library of mine
07:16:05 <electrocat> i got confused because it wasn't GADT syntax
07:16:19 <ch3pjw> https://github.com/concert/clapi
07:16:34 <ch3pjw> electrocat: yeah, I've been pondering GADTs, but I've never used them before
07:16:47 <ch3pjw> electrocat: I'm not sure what the pros/cons are...
07:17:07 <ch3pjw> I fear I keep trying to stray into dependent-type land too...
07:18:07 <electrocat> GADTs isn't a difficult concept though
07:19:08 <c_wraith> cocreature: existentials that don't contain a type class dictionary can be pretty useful without a GADT.  Coyoneda being one well-known example.
07:20:03 <[exa]> ch3pjw: the point is that backwards-unification on list contents doesn't work very well.
07:20:10 <[exa]> ch3pjw: anyway, did you see intersection calculus?
07:20:38 <ch3pjw> [exa]: no, I haven't. I shall have a google...
07:20:51 <[exa]> ch3pjw: I believe it's kindof close to what you're describing
07:21:14 <cocreature> c_wraith: fair point. I was more referring to the fact that you often see people use existentials to get some kind of heterogenous data structure and it pretty much always ends in problems :)
07:21:45 <ch3pjw> cocreature: What would be your preferred way of representing heterogenous data structures?
07:21:58 <[exa]> ch3pjw: this is probably a good read http://www.di.unito.it/~dezani/papers/wit02.pdf
07:22:03 <merijn> ch3pjw: The preferred way is "don't" :)
07:22:14 <merijn> ch3pjw: The one after that is "use a sum type"
07:22:18 <cocreature> ch3pjw: just apply the operation you want to perform before you put things in a data structure
07:22:31 <[exa]> ch3pjw: (but it's just what it reminds me, which may be way off :D )
07:22:33 <merijn> ch3pjw: existentials are somewhere way, way at the bottom of the list of alternatives
07:22:33 <cocreature> ch3pjw: e.g. instead of making a list of things with a Show constraint just make a list of String
07:22:41 <tdammers> ch3pjw: depends... but the reason why [forall a. Show a => a] isn't a good idea is because you can just use [String] instead
07:23:10 <ch3pjw> merijn: I'm trying to write an API framework that "knows" about some types.
07:23:18 <ziman> it's arguably easier for "heterogeneous list literals", though
07:23:37 <ch3pjw> merijn: so I'm building a tree of values that I don't know at compile type, because the provider of the API specifies types
07:23:42 <merijn> ch3pjw: For APIs that rely on some kind of pre-determined interface there's also what I like to call OO Haskell
07:24:06 <ch3pjw> merijn: in our case, the provider of the API publishes a spec and the broker enforces it
07:24:18 <merijn> ch3pjw: Which is basically just Tekmo's "Scrap your typeclasses" post: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
07:25:13 <merijn> ch3pjw: That shouldn't really matter, though? Just make your datatype/operations polymorphic in whatever the user of the framework passes in?
07:25:29 <merijn> ch3pjw: Presumably you've some fixed and finite set of operations inside your framework
07:26:33 <ch3pjw> merijn: yes - but it caches the current state of the world so that providers can just keep publishing up-to-date data, and subscribers can come in late and get what the latest values are...
07:26:55 <ch3pjw> so the type of that cache is determined by the provider
07:27:10 <merijn> ch3pjw: I don't see how that rules out my suggestion?
07:28:17 <ch3pjw> merijn: If a provider can give me any hetergenous mix of data, which I will need to pass on to clients at some point, do I not need a heterogenous collection to keep it in?
07:28:35 <merijn> ch3pjw: Well, the provider know in advance what it wants to give, yes?
07:28:59 <ch3pjw> That's true, but it's a separate program talking to the broker over the network...
07:29:05 <merijn> And the provider controlled the APIs type. So you can just make the provider provide a single sumtype
07:30:15 <merijn> "data ProviderAData = ...", then the provider just stores a list/set/map/whatever of ProviderAData
07:30:26 <merijn> And you can add how many sumtypes you need there
07:30:39 <ch3pjw> I had some problems with just making it a sumtype when I started wanting lists of values. Nesting meant I lost type safety on the contents of the list...
07:30:42 <ch3pjw> I think
07:30:58 <ch3pjw> (At least, I had to do more work validating each item manually)
07:31:42 * hackage wizard 0.1.0.0 - the fantastical wizard monoid  http://hackage.haskell.org/package/wizard-0.1.0.0 (chessai)
07:31:43 <cocreature> ch3pjw: how are you going to give the data to clients? that’s probably some network packet right? so you can just take network packets as inputs and have the caller convert to those rather than accepting a list of heterogenous inputs with a sufficient amount of constraints that allow you to convert items to network packets
07:32:00 <merijn> Also that
07:32:39 <cocreature> either use sumtypes if you actually need to inspect the data or have the caller convert it
07:32:49 <ch3pjw> cocreature: effectively just keeping the serialised data in the data structure?
07:32:55 <cocreature> right
07:33:33 <ch3pjw> I debated that, but it felt a bit like a cop-out...
07:34:35 <cocreature> it doesn’t need to be the data that’s being sent out over the network at the end. you can have some intermediate data structure that provides more information if you need that
07:35:00 <cocreature> but accepting heterogenous inputs only to then convert them to a homogenous data structure is only asking for unnecessary trouble
07:35:31 <merijn> ch3pjw: Well, if that's the only thing you're going to do with it anyway?
07:35:48 <merijn> ch3pjw: What else does the provider do with that heterogeneous data?
07:35:52 <cocreature> if you really want to avoid the need for clients to call the conversion function you can accept a proper hlist (with the types reflected at the type-level) or play some printf style tricks for variadic arguments
07:38:09 <ch3pjw> The provider that I'm currently trying to build has a plug system, so the plugins (C code) can publish the types of arguments they accept, which is then handled dynamically by the provider of the API, which publishes them to the broker
07:38:09 <cocreature> ch3pjw: also note that since Haskell is lazy you still don’t pay for the conversion if you end up discarding some items if that’s what your worried about
07:38:30 <ch3pjw> cocreature: :+1:
07:39:08 <ch3pjw> I'm in this annoying territory where I'm kinda just receiving arbitrary data, storing it and passing it on to clients
07:39:20 <ch3pjw> But there's quite a lot of validation in the middle to reject bad messages
07:40:02 <ch3pjw> I don't know if https://github.com/concert/clapi makes any sense at all just from a quick glance at the code...
07:41:17 <cocreature> not to me, sry :)
07:41:25 <cocreature> too large to take a quick look ;)
07:44:38 <ch3pjw> cocreature: no worries, it's just hard to explain the nuance of what it does quickly!
07:45:47 <bahamas> question about haskell-ide-engine. I see that there are two ways to clone the project, one with support for ghc 8.4.2, if I understand correctly. is there any reason not to use 8.4.2?
07:47:58 <hackage> ACTION amazonka-core 1.6.0, amazonka-serverlessrepo 1.6.0, amazonka-test 1.6.0, amazonka-ecs 1.6.0, amazonka-route53-domains 1.6.0, amazonka-sagemaker-runtime 1.6.0, amazonka-lex-runtime 1.6.0, amazonka-mediastore 1.6.0, amazonka-elastictranscoder 1.6.0, amazonka-storagegateway 1.6.0, amazonka-kinesis-video-archived-media 1.6.0, amazonka-cloudsearch 1.6.0, amazonka-ses 1.6.0, amazonka-dynamodb-dax 1.6.0, amazonka-iot 1.6.0, amazonka-waf-regional 1.6.0,
07:47:59 <alanz> bahamas, I you use the one with 8.4.2 support, you lose 8.0.2 support
07:48:22 <alanz> unless you install the 0.1.0.0 version to get 8.0.2, and then the master for the rest
07:48:50 <alanz> And I guess someday these things should have installers
07:51:59 <bahamas> alanz: can you break it down what that entails exactly? does it mean vs code won't be able to give me nice features on a project that only supports 8.0.2? I'm just starting out with vs code + hie
07:52:44 <alanz> if you use the makefile, it installs hie-8.0.2, hie-8.2.1, hie-8.2.2 for the 0.1.0.0 version
07:53:09 <alanz> if you use master, it installs hie-8.2.1,hie-8.2.2,hie-8.4.2
07:53:27 <alanz> and the vscode wrapper will choose accordingly
07:53:47 <alanz> the hie exe has to match the ghc version in the project
07:53:58 <bahamas> yeah. first time I used stack install, but then I saw in the vs code extension that I should run `make build` so now I did that
07:54:13 <alanz> So if you make the 8.0.2 one from the one branch, and the others from master, you will be fine
07:54:34 <alanz> and the makefile only works properly on linux.
07:54:36 <bahamas> so if I understand it, if I have a project that uses ghc 8.4.2, I need to build hie with 8.4.2 support
07:54:44 <alanz> or rather, the one for 0.1.0.0
07:54:47 <alanz> yes
07:55:09 <bahamas> oh, I'm on mac. I'll find out soon enough if it works properly. so far it's still going
07:55:12 <alanz> But I have a suspicion that the vscode wrapper may need to be updated to select 8.4.2
07:55:35 <alanz> otherwise see the makefile for master, it asks stack where the exe's should go
07:55:56 <alanz> and I guess it needs to be retrofitted to the 0.1.0.0 branch
07:56:44 <bahamas> hm, it would be a lot nicer if this "just worked", i.e. have support for all versions with just one install. how hard would it be to make this happen?
07:58:14 <bahamas> I just noticed you're the author of the extension. nice to meet you :)
08:02:04 <alanz> bahamas, thanks. But most of the good stuff in the extension is done by Tehnix2
08:07:27 * hackage amazonka-support 1.6.0, amazonka-elb 1.6.0, amazonka-clouddirectory 1.6.0, amazonka-gamelift 1.6.0, amazonka-glue 1.6.0, amazonka-codecommit 1.6.0, amazonka-autoscaling 1.6.0, amazonka-application-autoscaling 1.6.0, amazonka-appstream 1.6.0, amazonka-swf 1.6.0, amazonka-appsync 1.6.0 (BrendanHay)
08:07:44 <bahamas> alanz: regarding having an installer. is that an infrastructure issue? lack of resources?
08:08:03 <alanz> I was just thinking of making an issue for it
08:08:09 <alanz> purely lack of resources
08:08:26 <alanz> And it might make sense to do something similar to the hvr ppa for GHC
08:08:36 <alanz> or prevail upon him to host it there too
08:08:51 <alanz> of course, supporting multiple platforms is an issue
08:09:16 <alanz> Ideally it should be in a stack snapshot, and binary caching should exist
08:09:19 <alanz> we can dream
08:09:33 <alanz> One day it will be available like that on nix, I think
08:09:58 <bahamas> alanz: when you say lack of resources, does it mean money or man-power?
08:10:16 <alanz> man power
08:10:27 <alanz> it's not a money-driven project
08:10:36 <alanz> so more volunteer time, I guess
08:11:16 <bahamas> I'm not very experienced with haskell, but if it's something that just needs some steps to go through, I would look at it.
08:14:12 <hackage> ACTION amazonka-alexa-business 1.6.0, amazonka-comprehend 1.6.0, amazonka-snowball 1.6.0, amazonka-fms 1.6.0, amazonka-cloudhsmv2 1.6.0, amazonka-mechanicalturk 1.6.0, amazonka-resourcegroups 1.6.0, amazonka-medialive 1.6.0, amazonka-cost-explorer 1.6.0, amazonka-certificatemanager-pca 1.6.0, amazonka-transcribe 1.6.0, amazonka-marketplace-metering 1.6.0, amazonka-elasticache 1.6.0, amazonka-mediaconvert 1.6.0, amazonka-ecr 1.6.0, amazonka-resourcegrou
08:16:30 <mniip> that's long
08:17:06 <maerwald> something went wrong
08:18:12 <jchia_2> amazonka has many packages. Maybe they all got uploaded at once.
08:18:40 <jchia_2> then some bot got confused because there are too many packages?
08:19:27 <sm> mniip: doesn't hackage normally elide those ?
08:19:51 <mniip> not really
08:20:05 <mniip> it just accumulates packages for about 1 minute
08:20:18 <mniip> and it tried to print them all on one line but ran out of IRC line length
08:20:19 <sm> ok. Well I guess IRC did it :)
08:20:34 <maerwald> how well defined are multi param type classes? any known edge cases?
08:20:55 <maerwald> sm: hey, random question, do you use event sourcing in hledger?
08:21:36 <sm> hey maerwald: eh, well would you call recording transactions and "replaying" them to get balances every time, event sourcing ?
08:22:19 <maerwald> kind of
08:22:47 <lyxia> maerwald: You can encode them as single-param type classes over tuples of types, I think that makes them pretty well defined.
08:24:21 <csauce> lyxia: I always thought that for multi param typeclasses you need to have functional dependencies, is my assumption wrong? Or is that something you could do with either tuples or multiparam typeclasses?
08:24:31 <dminuoso> Mmm. I have a local extra-deps package using a file folder, is there a way to force rebuilding that package when it changed?
08:24:49 <cocreature> dminuoso: it will automatically do that
08:25:45 <dminuoso> cocreature: Mmm it doesn't. When I pass --force-dirty it picks up the change
08:26:27 <dminuoso> cocreature: What mechanism does it use to know it changes? Does it use fsevents?
08:26:32 <cocreature> dminuoso: huh that sounds wrong, what kind of file are you editing. just a regular haskell source file?
08:26:37 <dminuoso> Yeah
08:26:55 <cocreature> do you have the module properly declared in exposed-modules/other-modules?
08:27:21 <dminuoso> cocreature: Im using hpack right now, the cabal file declared the module properly in exposed-modules
08:27:42 <lyxia> csauce: there are plenty of uses without fundeps
08:28:13 <cocreature> dminuoso: hm, weird. can you show us your stack.yaml file just to be sure it’s not something silly?
08:28:31 <lyxia> csauce: and you can encode most (all?) fundeps with type families and equalities.
08:30:23 <dminuoso> cocreature: https://gist.github.com/dminuoso/cc67b0fcffbfe8b95fe0976c5bcc2c34
08:31:07 <dminuoso> Updated with app.cabal
08:33:43 <dminuoso> Changes I made in Compass.Server were not picked up by test-app when I tried `stack build` inside test-app/
08:34:29 <cocreature> I wonder if it gets confused because compass is also a stack project
08:34:47 <cocreature> what happens if you specify it in "packages" rather than "extra-deps"?
08:36:07 <dminuoso> cocreature: Ah that does the trick
08:36:47 <dminuoso> cocreature: Wow this is weird. Now it picks up the changes even if I switch it back. Something is fishy.
08:40:21 <cocreature> dminuoso: I don’t know how the rebuild mechansim is implemented but I wouldn’t be particularly surprised if it just looks at the last time the files were modified. so changing things back will still cause a rebuild
08:51:00 <zincy> How do I use forM_ with getLine and print?
08:53:09 <lukelau> Is it possible to exit a forever created via a forkIO with killThread?
08:55:37 <lyxia> zincy: what are you trying to do
08:55:41 <lyxia> lukelau: yes.
08:57:43 <lukelau> I basically have forkIO $ forever $ handle … but whenever I call killThread on that threadID, it function inside still gets run and throws an exception due to another resource being closed
08:57:52 <lukelau> The exception gets thrown repeatedly
08:59:17 <zincy> lyxia : Continously read from stdin and print string to stdout
08:59:38 <lukelau> lyxia: http://lpaste.net/365654
09:00:15 <lyxia> zincy: if you want to do that forever you can use "forever".  forever (getLine >>= print)
09:02:33 <lyxia> lukelau: do you have a minimal compilable example
09:07:10 <Boomerang> zincy: You might be interested by the `interact` function (if it's forever that you're after) :-)
09:08:34 <jchia_2> megaparsec question: With input of ByteString, I want to parse some type 'a' and produce '(a, ByteString)' where the ByteString is the part of the input spanned by the parsed 'a'. How can this be done? If I extract a sub-ByteString and parse that for the 'a', there are two problems: i) Where the sub-ByteString ends is generally not clear. ii) Error message will be bad (position will be wrong). So, this workaround doesn't really work.
09:10:01 <jchia_2> The context, to be clear, is that within some ParsecT, as part of parsing something bigger, I want to parse 'a' and also get the ByteString for the part of the input that the 'a' spans.
09:11:12 <lyxia> jchia_2: https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec.html#v:match
09:11:32 <lukelau> lyxia: http://lpaste.net/365656
09:11:56 <lukelau> This ends up spewing a “hGetLine: end of file” exception ad infinitum
09:13:44 <jchia_2> lyxia: Thanks
09:13:55 <zincy> Boomerang : interact id   :D
09:14:17 <lyxia> lukelau: I also see a "thread killed" message at the beginning though, so isn't it working?
09:14:38 <lyxia> ah I see
09:14:49 <lyxia> it's catching the ThreadKill exception and printing it
09:14:55 <Boomerang> I assumed you want to do stuff with input before outputting it :)
09:16:30 <lyxia> lukelau: don't catch "SomeException"
09:17:28 <sm> jchia_2: you can save and restore the parser's position
09:17:51 <lukelau> lyxia: How do I avoid catching it? Rethrowing?
09:18:20 <Boomerang> interact $ unlines . map reverse . lines -- Now that's useful! :D
09:18:30 <lukelau> lyxia: I get the threadKilled exception, but does catching it prevent it from being killed?
09:18:46 <lyxia> lukelau: yes that's what's happening
09:19:01 <lyxia> lukelau: the better practice is to specialize the handler to a specific exception type
09:19:47 <sm> jchia_2: like at https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Read/Common.hs#L1068
09:19:59 <lyxia> lukelau: do you need to catch any possible exception?
09:21:00 <lukelau> I want to print them
09:21:14 <lukelau> Or at least thats what the original author of this code intends on doing
09:22:05 <lukelau> lyxia: Is it possible to catch all but ThreadKilled?
09:23:27 <lyxia> lukelau: you can inspect and rethrow exceptions. Here you can use `asyncExceptionFromException` to check whether an exception is asynchronous.
09:24:33 <lyxia> this assumes you only use throwTo with AsyncException
09:24:38 <jchia_2> sm: Thanks. lyxia suggested just using match. I tried it and it works.
09:26:31 <lukelau> lyxia: perfect!
09:26:45 <lukelau> http://lpaste.net/365657
09:26:59 <lukelau> Thanks, works a treat now
09:30:52 <lukelau> Another quick question is it possible to send an interrupt signal to a child process *without* interrupting your own process?
09:32:06 <lukelau> interruptProcessGroupOf seems to send SIGINT to the current process
09:32:44 <exarkun> Process group is not the same thing as "all my children"
09:33:15 <exarkun> Maybe you want to create a child and make it the leader of a new process group and launch all the rest of your children as children of that process and then SIGINT that process
09:33:25 <exarkun> (woooo process management it's the best)
09:39:32 <lukelau> Hmm System.Process doesn’t seem to provide many functions outside of just spawning child processes
09:42:04 <lukelau> Ah well SIGTERM it is then
09:43:08 <exarkun> Why is there no instance arising?  https://gist.github.com/exarkun/be4119915620bfe977c9f0047b02293e
09:43:12 <Franciman> Hi
09:43:18 <Franciman> How can I write to a unix's named pipe?
09:43:38 <Franciman> I was trying with writeFile, but it doesn't work, it says it can't find the file
09:45:08 <exarkun> Franciman: You can't non-blocking open a named pipe for writing if it hasn't already been opened for reading
09:45:30 <Franciman> I see
09:48:46 <Franciman> exarkun, so how can I resolve this issue?
09:49:37 <exarkun> Franciman: Handle the error and retry at the appropriate time?  Fix the reader so that the pipe has already been opened for reading?  Switch away from named pipes entirely?
09:50:57 <exarkun> There's apparently also GHC.IO.Handle.FD.openFileBlocking which will perform a blocking open instead of a non-blocking open
09:51:06 <Franciman> k thanks
09:51:20 <exarkun> That _doesn't_ strike me as an awesome solution since if it has to block, you don't know how long it is going to block for...
09:51:29 <Althar> Hey all - Haskell novice here, I am at a bit of a loss trying to under the compiler error here & why it applise : http://lpaste.net/365658
09:51:33 <exarkun> And if the reader never shows up you're just stuck.  I guess.
09:51:46 <exarkun> Maybe you can do something with some concurrent package to interrupt it.  Not sure.
09:51:59 <glguy> Althar: It looks like you forgot to include the compiler error in the paste
09:52:04 <Franciman> ok thanks
09:52:35 <lyxia> exarkun: https://github.com/bos/aeson/issues/187
09:53:06 <Althar> new paste with the compiler error
09:53:07 <Althar> http://lpaste.net/365660
09:53:10 <lyxia> exarkun: basically, there is no satisfactory canonical instance people agree on
09:53:22 <Althar> I am trying to understand why the types cannot be derived "automatically"
09:53:40 <fishythefish> Althar: what monoid do you expect to be used?
09:54:02 <glguy> Althar: what type do you think pushToken has? That's worth understanding, but the problem is that your pushToken definition is probably wrong
09:54:33 <Althar> I was hoping to be able to use the StreamWriter within any Monadic context, if that is the correct term for it
09:54:52 <Althar> so it could be in the IO monad, or another one
09:55:11 <exarkun> lyxia: Oh.  So the complaint is specifically about the ByteString.  So there's a ByteString field somewhere in WriteVector that the derivation to fail.
09:55:18 <glguy> Althar: you should have: pushToken :: Monad m => Token -> StreamWriter m (); pushToken x = writer ((),[x])
09:55:24 <glguy> or even better: pushToken x = tell [x]
09:55:56 <Althar> is unless I am mistaken, isn't () a concrete type?
09:55:58 <glguy> Althar: the problem is that you had it returning mempty instead of () but then you were ignoring the returned 'a' variable so nothing was forcing it
09:56:08 <glguy> Althar: concrete type doesn't really mean anything
09:56:24 <glguy> forcing it to pick any particular type
09:56:39 <glguy> so the Monoid constraint couldn't be solved
09:57:37 <Althar> "returning mempty instead of () but then you were ignoring the returned 'a' variable so nothing was forcing it" right, I think I am misunderstanding what "() means
09:57:54 <glguy> () means different things at the value and type levels
09:58:14 <glguy> The value () has the type ()
09:58:27 <glguy> :t ()
09:58:28 <lambdabot> ()
09:58:31 <glguy> :t [(),(),()]
09:58:33 <lambdabot> [()]
09:58:37 <glguy> :t Just ()
09:58:38 <lambdabot> Maybe ()
09:59:27 <exarkun> Any chance there is a BSON encoder already built for Servant?
10:00:05 <glguy> When we need *some* value but the particular value is uninteresting we use the "unit" value ()
10:00:31 <Althar> ok, starting to make a bit of sense
10:01:28 <Ariakenom> data () = ()
10:02:19 <Althar> so given => WriterT w m a
10:02:48 <Althar> is there always an 'identity' for a?
10:06:10 <ski> (Althar : fwiw, next time, annotate the existing paste with updates, like the errors you got, in this case)
10:07:03 <Althar> @ski Yes. will keep that in mind for next time, thanks
10:07:03 <lambdabot> Maybe you meant: wiki src ask
10:09:53 <ski> Althar : fwiw, i don't understand your last question
10:10:22 <Althar> ski : I'll prepare a quick paste bin to illustrate
10:11:14 <ski> (in your paste, it appears the problem was that in the first call to `pushToken', whose monadic result is named `a', the implementation has no was of knowing what type of `a' you intended -- as opposed to `b', which must have type `()', because of the type signature on `main')
10:11:31 <ski> (er, `testStream', not `main')
10:14:01 <Althar> ski : I get that much
10:14:02 <Althar> http://lpaste.net/365662
10:14:35 <Althar> but what I don't understand is why the variable is unambiguous in the first instance, but not the second
10:15:31 <Welkin> Althestan
10:15:54 <wz1000> is it possible to generically match over a polymorphic type? Suppose I have some Data d => d. Can I match over all of its subterms of type Data a => Maybe a, where a is arbitary?
10:16:10 <ski> afaics, you shouldn't get any ambiguity in that second snippet, either
10:18:08 <Althar> ski : correct - it breaks when I chain pushToken
10:18:29 <Althar> so if the first call can be inferred, wouldn't the second one be as well?
10:19:04 <cocreature> wz1000: I don’t think I understand your question, can you provide some example of the code you’re trying to write?
10:19:11 <ski> Althar : i think it ought to be, speaking about that last paste
10:19:43 <ski> Althar : perhaps you have a separate ambiguity issue, elsewhere in your code ?
10:20:18 <Althar> ski : e.g. testStream = pushToken TokenA >> pushToken TokenB
10:20:31 <Althar> that's all the code
10:20:32 <ski> there you'll definitely get ambiguity
10:20:48 <Althar> ok, so that's obvious to you - guess I don't see "it" yet :)
10:21:00 <Althar> what makes it ambiguous here?
10:21:07 <ski> because `(>>)' ignores the monadic result of the first (the left) action, and therefore there's no context which can resolve that ambiguity
10:21:27 <wz1000> cocreature: Suppose I have some complicated AST data D = C1 (Maybe Int) | C2 (Maybe Bool) ...
10:21:38 <ski> if you have `foo :: IO Char' and `bar :: IO Int', then `foo >> bar :: IO Bar', the type `Char' disappears
10:21:47 <Welkin> wz1000: that looks like a mess
10:22:17 <Althar> ski : duh... ok yeah that makes complete sense now - obviously the do notation is equivalent, but it makes sense here in particular
10:22:27 <wz1000> and I have a functions forall d. Data d => Maybe d -> m and m -> m -> m
10:22:45 <ski> in your case, you have `pushToken TokenA >> pushToken TokenB :: StreamWriter IO ()', and therefore we know `pushToken TokenA :: StreamWriter IO a' and `pushToken TokenB :: StreamWriter IO b' for some `a' and `b'
10:22:59 <wz1000> I want a funtion D -> m
10:23:21 <ski> Althar : furthermore, we know that the monadic result type of the whole, i.e. `()', must be the monadic result type of the *right* operand, iow `b' must be the type `()'
10:23:42 <cocreature> wz1000: and you have a Data instance for D?
10:23:45 <Althar> ski : yes
10:23:58 <ski> Althar : but the context gives no way to determine what actual type to use in place of `a' .. and since we have a `Monoid' constraint on that, we therefore get an ambiguity problem
10:24:31 <wz1000> cocreature: yes
10:25:00 <ski> Althar : all clear, now ?
10:25:24 <Althar> ski : yes, thank you very much for the clarification
10:25:28 <ski> great :)
10:34:11 <cocreature> wz1000: hm not sure if you can do that, sry
10:36:44 <humanoyd> What is the correct way to get a C-like output from GHC? I've tried compiling a file containing `main = putStrLn "foo"` with `ghc -c -ddump-cmm Foo.hs > log` but the word "foo" does not appear at all in the output
10:40:56 <rckd> hey guys, is there any function like "dropUntil" "skipUntil"?
10:41:23 <rckd> i want to take the elements from a list from the first occurence of a given value
10:41:39 <sm> dropWhile
10:41:50 <rckd> omg
10:41:52 <rckd> xD
10:42:32 <sm> also good to know: break, span, partition
10:43:03 <Welkin> :t partition
10:43:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:43:12 <Welkin> :t break
10:43:13 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:43:18 <Welkin> what's the difference?
10:43:32 <glguy> There's no way to know
10:43:48 <sm> break and span look at the longest prefix of the list, partition filters the whole list
10:44:02 <cocreature> glguy: I’ve heard of this really cool trick where you read the docs to figure out what things do!
10:44:07 <rckd> ok thanks ill look into it
10:44:24 <johnw> partitition is like sorting all the True's to the beginning and then calling break
10:44:29 <sm> pff cocreature you must be oooold
10:44:29 <Welkin> why would I read source code when I could just ask and get an answer in seconds?
10:44:33 <johnw> except, preserves order
10:44:35 <mpickering> Is there a way to get persistant to not prefix all the fields with the name of the data type?
10:44:36 <Welkin> I am sick of reading source code
10:44:56 <Welkin> the "docs" often don't exist, or don't tell you much of anything
10:45:06 <sm> there are very good docs in this case
10:45:13 <cocreature> the docs for break and partition exist and are fairly clear imho
10:45:15 <rckd> so start using php. then u'll get sick of writing code
10:45:55 <Welkin> mpickering: yes, you can specify a name for the table
10:45:55 <sm> I recommend having a "ho X" browser shortcut to search hoogle for X, "h X" for haddock, etc.
10:46:03 <Welkin> unless you mean the representation of the record in haskell
10:46:08 <Welkin> then I don't know
10:46:11 <mpickering> I mean the haskell representation
10:46:18 <Welkin> you could use postgresql-siple instead, or headgehog
10:46:21 <Welkin> hedgehog*
10:46:21 <sm> s/haddock/hackage/
10:46:30 <mpickering> I want to use the records with lenses
10:46:41 <mpickering> but not have these annoying prefixed names
10:46:43 <cocreature> humanoyd: search for "[102,111,111]" instead
10:46:47 <Welkin> hedgehog is like persistent, but more useful
10:46:56 <rckd> everytime i google for "hoogle" it asks: did you mean "google"? :P
10:47:02 <cocreature> humanoyd: but for most usecases looking at cmm is not going to particularly enlightening, what are you trying to do?
10:47:15 <Welkin> just use duckduckgo and you don't need a browser shortcut
10:47:21 <Welkin> just type !h or !hoogle
10:47:26 <Welkin> !hayoo, !hackage
10:47:41 <cocreature> Welkin: you probably mean groundhog. hedgehog is the QuickCheck alternative
10:48:06 <Welkin> sure
10:48:08 <Welkin> whatever it's called
10:48:12 <Welkin> I don't use it
10:48:24 <Welkin> come up with ebtter names people
10:49:59 <exarkun> Not in scope: data constructor ‘:<|>’
10:50:03 <exarkun>     Perhaps you want to add ‘:<|>’ to the import list in the import of ...
10:50:12 <exarkun> except it's right there in the import list, what gives?
10:50:50 <lyxia> you might have imported the type constructor (:<|>), but not the data constructor (if it exists at all)
10:51:14 <Welkin> that is annoying
10:51:26 <Welkin> you might need ((:<|>)(..))
10:51:31 <Welkin> or some other ugly mess
10:51:39 <humanoyd> cocreature: ah, there it is :) Thank you! I just wanted to see what Haskell looks like closer to the metal
10:52:08 <Welkin> it's easier to just import all
10:52:20 <Welkin> is this for servant?
10:52:32 <cocreature> humanoyd: if you’re interested in that you might want to take a look at the STG paper or the “how to make a fast curry”-paper
10:52:41 <exarkun> Welkin: yes
10:53:15 <exarkun> if I have to ((:<|>)(..)) ... then ... (:<|>) is a ... type?
10:54:04 <Welkin> if you import Type(..) that means import the Type and all of its constructors
10:54:07 <exarkun> that did fix it fwiw, thanks
10:54:22 <exarkun> Welkin: yea, that part I get... I am surprised that :<|> is a type, is all.
10:54:29 <Welkin> it is a type operator
10:54:36 <Welkin> which servants uses heavily
10:54:43 <Welkin> I have always just imported all of servant at once
10:55:47 <exarkun> I don't like that so much as then I rarely know where a name comes from (which I often want to know because I rarely know what a name means and have to go look it up)
10:57:19 <Welkin> if you modules are small enough, that isn't a problem
10:57:34 <Welkin> for a library like servant or scotty, I justi mport everything
10:57:51 <sm> Welkin: oh nice, I didn't know duckduck had !h for google. You'll still need the browser shortcut if you prefer https://hoogle.haskell.org/ though (covers more packages)
10:57:54 <Welkin> I only import piecemeal from general libraries like containers
10:58:01 <sm> s/google/hoogle/
10:58:03 <exarkun> Welkin: the size threshhold for modules across which that becomes a problem depends more on the maintainer than on some absolute value
10:58:22 <exarkun> Welkin: and when the maintainer is me, that size is pretty small :)
10:59:06 <mpickering> ok you can turn off name prefixing with setting  mpsPrefixFields
11:00:00 <exarkun> Like, looking at http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html now I need to figure out where `run` comes from.
11:00:12 <exarkun> at least I can narrow it down a bit because I suspect it is something in Wai
11:01:00 <humanoyd> cocreature: thx
11:02:18 <Akii> exarkun probably Warp http://hackage.haskell.org/package/warp-3.2.22/docs/Network-Wai-Handler-Warp.html
11:02:35 <exarkun> Akii: just realized that
11:02:46 <exarkun> so, I dunno, case in point
11:03:16 <fresheyeball> I have a bad one folks
11:03:24 <fresheyeball> <no location info>: error:
11:03:26 <fresheyeball>     ghc: panic! (the 'impossible' happened)
11:03:28 <fresheyeball>   (GHC version 8.0.2 for x86_64-unknown-linux):
11:03:30 <fresheyeball>  tyConRoles sees a TcTyCon TemplateKey
11:03:33 <Welkin> fresheyeball: upgrade
11:03:36 <Welkin> you are using old ghc
11:03:40 <Welkin> 8.4.2 is current
11:03:43 <fresheyeball> Welkin: I cant
11:03:59 <fresheyeball> that is big task right now
11:04:05 <fresheyeball> we have someone working on it
11:04:08 <Welkin> I have had that happen before on macos
11:04:11 <fresheyeball> but I can't just upgrade
11:05:14 <statusbot> Maintenance update: restarting now -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5afc72b04d949804bd9be1a1
11:11:18 <cocreature> fresheyeball: try to isolate it to a minimal example
11:11:23 <statusbot> Maintenance update: Hackage is up and  operational again. Thank you for your patience. -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5afc72b04d949804bd9be1a1
11:11:34 * hackage pipes-network-tls 0.3 - TLS-secured network connections support for pipes.  http://hackage.haskell.org/package/pipes-network-tls-0.3 (RenzoCarbonara)
11:13:14 <cocreature> fresheyeball: looks like https://ghc.haskell.org/trac/ghc/ticket/12083
11:13:39 <cocreature> so upgrade is probably your only solution
11:24:03 <rckd> Hey guys, why is this (http://lpaste.net/2030498441188081664) running endless when calling: take 10 $ scaleOf C major
11:24:42 <rckd> (im quite new to haskell and dont really know whats going on with that lazy stuff :-D)
11:25:30 <exarkun> https://gist.github.com/exarkun/bb04a7f1c2dcd66a7a6d583c6ba7008e - I don't understand why this error talks about FromJSON instance when all I'm doing is currying a function to avoid some repetition later on
11:28:00 <rckd> maybe it's easier to test / look at here: https://repl.it/repls/ImmediateIntentLeadership
11:29:13 <Welkin> if scaleOf is strict, then it won't work
11:30:10 <rckd> dont know how to determine that
11:30:12 <rckd> xD
11:30:20 <exarkun> Blub.  The error is about a different type than I am looking at.
11:30:53 <Welkin> just test each of your functions
11:31:06 <Welkin> you can use `take 1` to test them
11:31:33 <rckd> if i do take 1 $ scaleOf C major
11:31:34 <rckd> it works
11:31:37 <Welkin> well, you could also inspect it using ghci, but that is more work
11:31:43 <rckd> but 2+ fails
11:32:02 <sm> rckd: you're trying to test `elem` of an infinite list
11:33:12 <rckd> ok that makes sense
11:33:28 <rckd> a dirty fix like    notes = pick intervals $ take 12 scale'   does the job
11:33:33 <rckd> but that seems kinda ugly
11:33:34 <rckd> :P
11:34:25 <sm> repl.it looks handy
11:34:34 <Welkin> repel it
11:58:34 * hackage util 0.1.10.1 - Utilities  http://hackage.haskell.org/package/util-0.1.10.1 (MatthewFarkasDyck)
11:59:36 <johnw> haha
11:59:58 <johnw> not even any Haddocks; I wonder why it's on Hackage?
12:01:11 <Tuplanolla> Does `(f a -> f b -> f c) -> (a -> b -> c)`, the dual of `liftA2`, have a name?
12:02:45 <sm> that's quite a name grab!
12:07:07 <[exa]> Tuplanolla: I'd go with dropA2 (just a quick guess)
12:08:59 <[exa]> (btw it looks like 'f' would need comonad-ish features to provide this kind of implementation)
12:09:47 <Tuplanolla> I've only come across `newtype` wrappers that support this kind of thing, so it feels like a generalized `ala`.
12:13:04 <johnw> or lowerA2
12:13:33 <[exa]> btw lowerA2 is defined somewhere?
12:13:53 <johnw> Tuplanolla: I think that would need 'f' to be a Comonad
12:14:03 <[exa]> (btw btw. is there a co-applicative for comonads where the pure works like extract?)
12:14:10 <johnw> https://cstheory.stackexchange.com/questions/16241/is-there-a-concept-of-something-like-co-applicative-functors-sitting-between-com?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
12:14:15 <johnw> :)
12:14:16 <exarkun> No instance for (servant-0.13.0.1:Servant.API.ContentTypes.MimeUnrender servant-0.13.0.1:Servant.API.ContentTypes.OctetStream [Char]) arising from a use of ‘serve’ :/
12:14:18 <danilo2> edwardk: Hi Edward! I've read your article (https://www.schoolofhaskell.com/user/edwardk/unlifted-structures) and I'd like to ask you what is the current state of the art of mutable references in HS?
12:14:47 <[exa]> johnw: oh wow thanks
12:15:03 <danilo2> edwardk:  Aare we able to get away with all the pointer indirections like described there or are there any new approaches? I'm making mutable graphs (nodes pointing to other nodes). Im currently using storable instances and manual memory management for that, but Im always researching other approaches
12:25:03 <exarkun> How do I `stack hoogle` for "serve"?
12:34:43 <exarkun> Ah.  OctetStream [Char] no good.  Must OctetStream ByteString.
12:39:36 <EvanR> who uses [Char] as an octect stream
12:39:43 <EvanR> philistines
12:50:47 <cocreature> danilo2: afaik not much has changed. however, there is a GHC proposal for mutable constructor fields
12:51:47 <EvanR> o_O
12:51:52 <danilo2> cocreature: oh! I didnt know aobut it. How is it called ?
12:52:03 <EvanR> how in the types does that work
12:52:06 <cocreature> danilo2: “mutable constructor fields” https://github.com/ghc-proposals/ghc-proposals/pull/8
12:53:01 <cocreature> it seems somewhat dormant but it has prominent supporters and afaik people have also started implementing this so I’ve not lost hope that we’ll get this eventually :)
12:54:48 <danilo2> cocreature: I would really really want to see it. This would be a life saver in many cases. Im a big fan of this idea now
12:55:11 <EvanR> but type safet, ref transparency
12:56:46 <danilo2> EvanR: it will be similar to IORef / MonadST - it will be typesafe and will proide ref transparency. You woudl not be able to modify such fields without a monad
12:57:21 <cocreature> EvanR: all it does is eliminate the indirection you get by having a field of type IORef a
12:57:39 <EvanR> ah
12:58:15 <danilo2> The problem is that current IORefs have 3 pointers of indirection
12:58:47 <danilo2> implementing mutable graphs for example requires now to make big hacks - for example we are currenlty managing memory manually by our cpp memory manager and keep everything as storable
12:58:55 <danilo2> this way we get decent performance, but its ugly
13:00:53 <cocreature> I wonder if getting rid of the indirection will result in GHC being able to move mutable fields to registers so you don’t have overhead over an immutable field
13:02:24 <cocreature> e.g. if you currently have something like "data HashTable k v = HashTable { size :: IORef Int, … }" you get worse code than if you go for "data HashTable k v = HashTable { size :: Int, …}" and construct new HashTables
13:02:39 <cocreature> the problem with the latter is that it’s unsafe without linear types
13:03:04 * hackage bdcs 0.6.1 - Tools for managing a content store of software packages  http://hackage.haskell.org/package/bdcs-0.6.1 (clumens)
13:03:43 <cocreature> it’s kind of funny how GHC is getting better support for imperative, mutable APIs while at the same time a lot of languages are getting better support for functional programming :)
13:10:04 <danilo2> cocreature: yes, I thought exactly the same
13:20:34 * hackage proxy 0.1.0.0 - proxy helpers  http://hackage.haskell.org/package/proxy-0.1.0.0 (chessai)
13:27:27 <fresheyeball> anyone explain the intention of GEq?
13:27:37 <fresheyeball> is it type level eq or term level as well
13:27:48 <fresheyeball> as in, if these types match, then term level must match
13:27:48 <shapr> :t GEq
13:27:49 <lambdabot> error: Data constructor not in scope: GEq
13:27:51 <shapr> ?
13:28:00 <fresheyeball> https://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-GADT-Compare.html#t:GEq
13:30:14 <pavonia> What's the meaning of the different colors in package versions on Hackage? E.g. the Spock package seems to have red, yellow and violet http://hackage.haskell.org/package/Spock
13:31:37 <geekosaur> blah. old hackage had a legend for the colors, although it was well hidden
13:32:14 <geekosaur> ah, click on the "(info)" at the end
13:32:31 <geekosaur> although it then uses a different set of colors
13:33:03 <geekosaur> this is … less than helpful
13:33:40 <pavonia> Haha, indeed
13:33:54 <pavonia> so green is violet then
13:51:04 * hackage size-based 0.1.1.0 - Sized functors, for size-based enumerations  http://hackage.haskell.org/package/size-based-0.1.1.0 (JonasDuregard)
13:57:34 * hackage gtk-sni-tray 0.1.3.0 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.3.0 (eyevanmalicesun)
14:16:40 <danilo2> edwardk: I was just testing the Struct package provided by you. The benchmark is simple - Im creating a Struct and Im reading / writing a field in a loop. It seems its exactly 2 times slower than updating just a value in a Pointer. Do you think we can optimize it somehow to match the pointer performance? Test: http://lpaste.net/365667
14:45:33 <slevin> I'm struggling implementing the instance for MonadCont for a simple transformed `data Tainted a = Dirty a | Clean a` type, which reads `newtype TaintedT m a = TaintedT {runTainted :: m (Tainted a)}`
14:46:18 <slevin> I'm trying something like this `instance (MonadCont m) => MonadCont (TaintedT m) where
14:46:18 <slevin>   callCC f = TaintedT $ callCC $ \c -> extractTaint (f (TaintedT . c))`,
14:46:18 <slevin> but i cant seem to satisfy ghc... :( Any tips?
14:52:43 <shapr> aha! the "hidden" hoogle options can be seen with "hoogle search --help" and "hoogle server --help" etc
14:53:10 <shapr> hoogle was fine the whole time, I just didn't expect extended docs to be only available under each 'command'
14:53:42 <shapr> so now I wish cmdargs would announce that there's more help under each command
14:54:28 <infinisil> I wish more commands had man pages :/
14:55:07 * lambdabot wants a pony
14:55:13 <shapr> :t pony
14:55:15 <lambdabot> error: Variable not in scope: pony
14:55:18 <shapr> I see the problem.
14:55:54 <shapr> infinisil: add man page generation to cmdargs?
14:56:37 <shapr> though I don't think ndm uses linux
15:00:04 <shapr> glguy: thanks for the help with cmdargs and hoogle
15:08:25 <codedmart> How would I go about calculating a CRC32 for a large file I am using http-client to stream up to a server?
15:09:00 <codedmart> I am using https://hackage.haskell.org/package/http-client-0.5.12.1/docs/Network-HTTP-Client-MultipartFormData.html#v:partFileSource
15:09:49 <codedmart> And was going to use https://hackage.haskell.org/package/crc-0.1.0.0/docs/Data-Digest-CRC32.html
15:10:09 <codedmart> So I was hoping I could use updateDigest on each chunk of the stream for the file.
15:31:41 <jbetz> how do I create a `DMap t Identity` from a sum type of zero argument constructors?
15:40:04 <glguy> jbetz: What part do you not know how to do? What's an example of your type 't'?
15:40:58 <jbetz> glguy: `type Action = A | B | C | D`
15:41:29 <glguy> That has the wrong kind to be used with a DMap , maybe you just need a: Map Action ?
15:42:13 <omegablitz> hi guys! im trying to use the sdl2 haskell library on windows - does anyone have any idea on how to set this up? ive tried a number of things, and they all error at compile time. i can send debug logs if desired
15:42:52 <jbetz> glguy: it needs to be `* -> *`?
15:43:19 <glguy> jbetz: DMap :: (k -> *) -> (k -> *) -> *
15:43:29 <jbetz> and I need a `DMap` to use the fan function in `reflex`
15:43:32 <jbetz> `fan :: GCompare k => Event t (DMap k) -> EventSelector t k`
15:43:48 <jbetz> hmm, okay
15:47:26 <jbetz> yeah, this is probably overkill for my purposes
15:48:26 <EvanR> now that i have a windows computer i really should set up haskell (and sdl, and etc) on it
15:48:42 <hpc> omegablitz: it's easiest with stack, because there's a way to get the C dependencies installed with it
15:48:42 <EvanR> and come out of the cave of ignorance
15:49:04 * hackage self-extract 0.2.0.0 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.2.0.0 (brandonchinn178)
15:49:05 <hvr> hpc: no it isn't
15:49:20 <hpc> it's how i did it
15:49:30 <hvr> hpc: doesn't mean it's "the easiest"
15:49:58 <EvanR> lets get constructive, what is the easiest, and show that its easier than stack
15:50:05 <hpc> that
15:50:22 <hpc> because i doubt it's easier than "stack install i-forget-what-it's-called-x86_64"
15:51:22 <hvr> hpc: the burden of proof is actually on your side; you claimed it to be the easiest w/o giving any proof; you're trying to convince us
15:52:12 <EvanR> convene the council
15:52:33 <hpc> postulate windows : Void -- this is probably safe
15:52:55 <MarcelineVQ> stack doesn't grab any c deps, or does it now?   omegablitz: best to pastebin your errors so people know where things fail. error at compile time is fairly vague
15:53:28 <srhb> MarcelineVQ: I assume they mean --nix (so that Nix does grab them)
15:53:38 <hpc> aha! found it
15:53:44 <hpc> stack exec -- pacman -S mingw-w64-x86_64-pkg-config mingw-w64-x86_64-SDL2 # via https://old.reddit.com/r/haskellgamedev/comments/4jpthu/windows_sdl2_is_now_almost_painless_via_stack/
15:53:59 <srhb> ... or not
15:54:16 <EvanR> pacman... windows... what
15:54:18 <MarcelineVQ> for all we know so far they could simply have a code error
15:54:19 <hpc> srhb: this is windows remember
15:54:29 <srhb> Nah, I choose oblivion. :-)
15:54:35 <davean> ... so you manually install the stuff, inside stack, and thats somehow automatic?
15:54:51 <davean> I'm baffled
15:55:07 <hpc> davean: i never said automatic, just that there's a way with stack ;)
15:55:08 <EvanR> oblivion is only for windows
15:55:16 <hpc> skyrim is better
15:55:25 <davean> hpc: thats not even with stack though
15:55:35 <hpc> davean: it's in the stack environment
15:55:43 <shadowdaemon> Stack uses MSYS2 on Windows.
15:55:47 <srhb> EvanR: wine stack exec -- oblivion
15:55:52 <srhb> Checkmate.
15:56:27 <EvanR> any second there will be a reddit thread for can we stop recommending stack already
15:56:28 <shadowdaemon> I just started using Stack on Windows.  It's "fairly" simple I guess.
15:56:59 <hpc> gonna be honest, it's all the same to me on windows
15:57:19 <hpc> if someone ever twists my arm and makes me learn windows development, i am going to pick F#
15:57:28 <hpc> and then maybe i'll learn what crap is
16:21:45 <zer0packet> exit
16:43:44 <EvanR> comment subexpression elimination is a bit weird in haskell because it might cause extra sharing that you were trying to avoid
16:43:53 <EvanR> but isnt it weird in other languages too?
16:44:02 <EvanR> like, when evaluation causes side effects
16:45:53 <omegablitz> i got compilation to succeed - i switched to sdlmixer2. thanks guys!
17:10:27 <vidlew> > data Bit = One | Zero
17:10:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
17:10:35 <vidlew> @data Bit = One | Zero
17:10:36 <lambdabot> Unknown command, try @list
17:10:41 <vidlew> @list
17:10:41 <lambdabot> What module?  Try @listmodules for some ideas.
17:10:52 <johnw> any reason you want to define that here?
17:10:57 <vidlew> can you define data types with lambdabot?
17:11:09 <johnw> i don't know
17:11:14 <johnw> probably, but I don't remember all the syntax
17:11:16 <EvanR> @let Bit = One | Zero
17:11:17 <lambdabot>  Parse failed: Parse error: |
17:11:21 <EvanR> @let data Bit = One | Zero
17:11:23 <lambdabot>  Defined.
17:11:26 <vidlew> nice
17:11:28 <johnw> hah, lovely
17:11:42 <EvanR> :t One
17:11:43 <lambdabot> Bit
17:12:02 <vidlew> @let data Nat where Zero :: Nat; Succ :: Nat -> Nat
17:12:03 <EvanR> Two Bit, Red Bit, Blue Bit
17:12:03 <lambdabot>  .L.hs:195:9: error:
17:12:04 <lambdabot>      Multiple declarations of ‘Zero’
17:12:04 <lambdabot>      Declared at: .L.hs:192:12
17:12:18 <iqubic> :k Bit
17:12:20 <lambdabot> *
17:12:22 <vidlew> @let data Nat where Zero_ :: Nat; Succ :: Nat -> Nat
17:12:24 <lambdabot>  Defined.
17:12:30 <vidlew> oh cool
17:12:36 <iqubic> :k Nat
17:12:37 <lambdabot> *
17:14:06 <vidlew> @let data Blerg a where Qwe :: Blerg (); Qaz :: Blerg a -> Blerg (Maybe a)
17:14:07 <lambdabot>  Defined.
17:14:18 <vidlew> oh cool you can do gadts
17:14:37 <vidlew> :t Qaz $ Qaz Qwe
17:14:38 <lambdabot> Blerg (Maybe (Maybe ()))
17:15:16 <iqubic> vidlew: can you please take this to /msg?
17:15:37 <vidlew> don't know how
17:16:58 <iqubic> type "/msg lambdabot" And then you should get another window/tab/buffer where you can continue issuing commands
17:18:21 <vidlew> got it
17:25:56 <vidlew> can you use DataKinds with lambdabot?
17:26:38 <EvanR> yes
17:26:42 <fishythefish> :k True
17:26:43 <lambdabot> Bool
17:28:55 <vidlew> oh nice
17:44:34 * hackage transformers-either 0.1.1 - An Either monad transformer  http://hackage.haskell.org/package/transformers-either-0.1.1 (lambda_foo)
17:53:24 <suzu> /lol
17:57:44 <EvanR> orDieWithCode
17:57:49 <EvanR> WithHonor
17:59:51 <tysonzero> Does anyone know how to statically link SDL for OSX?
17:59:57 <tysonzero> *SDL2
18:01:34 * hackage hw-prim 0.5.0.5, bits-extra 0.0.0.3 (haskellworks): https://qbin.io/bean-casio-lf16
18:21:50 <tysonzero> I'm trying to release a binary that depends on SDL, but it seems it is not being statically linked as I get the following error: dyld: Library not loaded: libSDL2_mixer-2.0.0 dylib
18:21:52 <tysonzero> Anyone have any ideas
18:24:03 <jchia> tysonzero: What OS?
18:24:28 <M-rgh> Ok.
18:24:41 <jchia> OK, OSX
18:25:40 <jchia> I'm not familiar with OSX, but do you have libSDL static library installed to start with?
18:32:01 <EvanR> i'm not sure if i did something smart or not
18:34:26 <EvanR> i tried to use traversable and an "expression functor" to label subexpressions with unique numbers http://lpaste.net/5871031040193069056
18:34:58 <EvanR> but the fact that my label function is being called recursively inside the "visit" function is making me nervous, is that stupid or what
18:35:26 <EvanR> i do get consecutive numbers...
18:35:43 <tysonzero> I'm not sure if I have a static libSDL library
18:35:43 <EvanR> though, i fail to label to top most expression
18:35:47 <tysonzero> I will look into that now
18:36:45 <EvanR> i figured recursion is somehow done for me by traverse
18:46:29 <tysonzero> How do I link to the sdl static library?
18:46:32 <tysonzero> https://stackoverflow.com/questions/17620884/static-linking-of-sdl2-libraries
18:46:36 <tysonzero> I see this stackoverflow but its about C
18:46:43 <tysonzero> so not sure how to apply the same concepts to haskell
18:49:53 <EvanR> i would look up how to static link any C lib in haskell
18:54:29 <glguy> EvanR: Wouldn't this be more direct? http://lpaste.net/5370350291428311040
18:54:53 <glguy> oh,nevermind
18:54:58 <glguy> it's just what you wrote inlined :)
18:55:13 <glguy> It took me a moment playing with it to internalize your types
18:55:29 <glguy> EvanR: I don't see any issue with your use of traverse
19:22:11 <codygman> Not sure if offtopic or not, but how much should I care about an i5 vs an i7 in a new laptop where I want ghci, ghc, and emacs/spacemacs to run as fast and smoothly as possible?
19:26:43 <sm> codygman: I think you should care.. you're going to be waiting for builds a lot
19:27:08 <sm> I have an i7 and wish for something faster
19:27:45 <codygman> Yeah, I was checking out a laptop with a hexacore Intel Core i7-8750H
19:27:51 <davean> codygman: Most of the stuff that is "slow" is single thread limited
19:27:56 <codygman> aww
19:27:58 <davean> i5s mostly just lack the HTing
19:28:23 <davean> What causes most of the noticable latency though being single core performance, thats irrelivent.
19:28:24 <codygman> davean: so the slow stuff won't be helped by more cores then
19:28:44 <davean> Some i7s are higher spec than i5s in single core terms, but the reverse also happens
19:28:56 <davean> codygman: not reall. Dependencies builds are parallel
19:29:08 <davean> but each file is compiled as a single thread, and linking is a single thread
19:29:27 <EvanR> glguy: really......
19:30:53 <codygman> davean: I think it's the same case for org-mode, emacs, and spacemacs. So after ssd+fast/enough ram, a cpu with a high clock speed would be better than more cores?
19:31:10 <davean> Generally
19:32:03 <davean> if you're working on large projects, and changing build plans a lot, more cores is great
19:32:29 <EvanR> mkay so traverse is really only replacing the first level anyway
19:34:08 <EvanR> so additional recursion really is the only way to do it, alright
19:36:18 <sm> related: 5 year old i7 macbook air to a modern macbook pro - would I see much change in build times ?
19:36:38 <EvanR> i wonder how many horrible recursive case analyses i can avoid now that i know that works :)
19:36:40 <sm> to my inexpert eye, they don't look that fast
19:37:29 <glguy> sm: the modern macbook pro was noticably faster than the 3-year older one, so I'm pretty sure it'll do well against a 5-year old air
19:38:09 <ackthet> sm: likely you would but it kinda depends on exactly which i7 you have
19:38:13 <ackthet> and which pro you get
19:39:42 <davean> sm: Theres been a LOT of improvements in the last 7 years, I'm not sure where a "modern" macbook lies, but yah, definately. Both in single and multi threaded
19:39:44 <sm> I have a.. 1.7GHz i7, with 1600MHz DDR3 ram. And I suppose I'd be getting the non-touchbar macbook, which unfortunately seems slower
19:39:52 <ackthet> how many cores?
19:39:57 <sm> ..than the touchbar model
19:40:11 <ackthet> they only offer dual cores on the pros...
19:40:14 <ackthet> TIL
19:40:28 <ackthet> oh thats the 13"
19:40:37 <davean> sm: Oh yah, the RAM upgrade alone would be massive
19:40:43 <ackthet> ^
19:40:59 <sm> I have 8G, I guess the pros can go to 16 now
19:41:05 <davean> Its not the amount
19:41:09 <davean> its the performance
19:41:11 <sm> oho
19:41:16 <davean> lower latency and higher bandwidth
19:41:33 <ackthet> also the ssd will help with build times in some cases
19:41:35 <sm> ackthet: htop shows 4 cpus, which I think means.. I have 2 cores + HT ?
19:41:57 <EvanR> oh and i realize why i couldnt label the top expr... because i was thinking the other thing was the entry point duh
19:41:59 <ackthet> so 2 -> 4 cores already helps right off the bat
19:42:05 <davean> sm: or no hyperthreading
19:42:10 <ackthet> tl;dr, you would see improvement
19:43:12 <sm> good to know. If I ever get my hands on a spare $1500 then..
19:43:19 <ackthet> right...
19:43:21 <ackthet> haha
19:43:43 <ackthet> why is life so expensive
19:43:53 <sm> or.. get a cheap fast linux desktop.. but.. a *desktop*.. that would feel weird :)
19:44:23 <EvanR> i need a new desktop
19:47:07 <tysonzero> Ok I have the `.a` files in question
19:47:12 <tysonzero> how do I force GHC / stack to link to them
19:52:12 <tysonzero> I'm getting `Warning: ignoring unrecognised input `libSDL2.a'`
20:22:37 <iqubic> Why doesn't the code for StateT execStateT for the functor and applicative and monad instances?
20:23:25 <monochrom> Parser error.
20:27:28 <glguy> Abort, Retry, Fail?
20:28:59 <monochrom> I miss that.  Why doesn't Windows do it anymore?
20:29:36 <glguy> Becoming unresponsive became popular
20:29:46 <iqubic`> Yeah.
20:37:13 <tysonzero> anyone have any idea how to statically link `.a` files on osx?
20:38:54 <dmj`> @google static linking with ghc
20:38:55 <lambdabot> https://ro-che.info/articles/2015-10-26-static-linking-ghc
20:44:34 * hackage affine 0.1.1.0 - Affine spaces (generalized)  http://hackage.haskell.org/package/affine-0.1.1.0 (MatthewFarkasDyck)
20:56:59 <tysonzero> @dmj` that didn't work, ld: library not found for -lcrt0.o
20:57:00 <lambdabot> Unknown command, try @list
20:57:17 <dmj`> tysonzero: what didn’t work
20:57:29 <tysonzero> Following that website (running "stack build --ghc-options='-optl-static -optl-pthread' --force-dirty")
20:57:37 <glguy> You can't make a completely statically linked executable on mac
20:57:52 <davean> or linux
20:57:59 <davean> what platforms can you these days?
20:58:05 <tysonzero> I just need `SDL` statically linked
20:58:15 <tysonzero> https://github.com/metinsay/SkyKnight/tree/master/wingsuit
20:58:20 <tysonzero> this is the haskell project in question
20:58:25 <tysonzero> It uses sdl2
20:58:30 <tysonzero> which isn't installed on most macs
20:58:30 <glguy> On mac you can't statically link in the c runtime
20:58:33 <tysonzero> so I need to bundle that in some way
20:58:37 <tysonzero> hmm ok
20:58:47 <tysonzero> So how do I go about deploying the above project
21:00:14 <tysonzero> I really need to have a standalone executable (or .sh or whatever) for OSX that works on machines that don't currently have SDL2 installed
21:00:59 <glguy> The traditional way would be to make a bundle that includes the shared libraries you need
21:01:41 <tysonzero> ok thanks, is there a stub project or some easy and quick way to get that set up?
21:01:56 <glguy> No, but this helps http://hackage.haskell.org/package/cabal-macosx
21:02:24 <tysonzero> Will check it out! thanks
21:27:36 <Zipheir> Is it even possible to statically link SDL2? It makes heavy use of dlopen(), IIRC.
21:27:37 <blu3r4d0n> Hi everyone I've decided to learn haskell
21:28:07 <iqubic> We can help you.
21:28:28 <blu3r4d0n> Thanks, I'm definitely going to need it
21:28:29 <EvanR> davean: javascript
21:29:15 <dminuoso> Hi. When I send a SIGINT to my program with C-c, I get some "^C" output in my terminal before the async exception is received: "^CShutting down server."
21:29:15 <dminuoso> Can someone enlighten me which subsystem does this and why?
21:29:24 <M-rgh> \o/
21:31:10 <M-rgh> That's a function of your terminal.
21:31:40 <codedmart> I have no idea how to use conduit. I am doing a `sourceFileBS fp $$ scanl updateDigest (digest "" :: CRC32) =$ sinkNull`. What do I use to return the value from scanl?
21:32:02 <dyl> dminuoso: http://simonmar.github.io/posts/2017-01-24-asynchronous-exceptions.html
21:32:04 <dyl> ¯\_(ツ)_/¯
21:32:09 <dyl> Might be related might not
21:32:44 <M-rgh> Run sleep 1000 and then in a separate terminal run ps -ef $(grep 'sleep 1000' | awk 'print $2}') and you should see the same thing.
21:32:50 <dminuoso> M-rgh: How do some programs, say weechat, prevent that then?
21:33:40 <dyl> Is this is Haskell program?
21:33:44 <glguy> You install a handler for that signal
21:34:34 <dminuoso> If I type C-c, I don't get any visual indication.
21:34:34 <dminuoso> M-rgh: That example doesn't work - what exactly are you trying to demonstrate?
21:34:47 <M-rgh> Not sure but I suspect it's because weechat is an ncurses program and therefore has full control of the terminal.
21:34:48 <M-rgh> glguy: that won't stop the terminal from printing that message.
21:34:52 <dyl> Also that sounds like a signal handler.
21:34:59 <dminuoso> glguy: But the RTS has a handler for SIGINT too, which is how the async exception must be produced.
21:35:07 <dyl> SIGINT isn’t one you can opt out of a program catching.
21:35:10 <dyl> Or handling.
21:35:28 <glguy> ^C sends a handlable signal
21:35:46 <dminuoso> dyl: Mmm. Is it possible that the program can toggle whether or not C-c would sent a SIGINT in the first place?
21:35:49 <dminuoso> Err glguy.
21:36:07 <dyl> Only SIGKILL and SIGSTOP aren’t handleable I think
21:36:10 <M-rgh> dyl: yeah, I thought might be the case! I think it's SIGTERM
21:36:15 <dyl> Also, that’s up to your terminal emulator
21:36:29 <dyl> C-c is almost universally considered to be SIGINT
21:36:32 <M-rgh> Let me check. I'm not up with my signal numbers these days!
21:36:43 <dyl> If you don’t want your program to die with it, then handle it.
21:36:56 <dyl> Just be aware that signal handling is... finicky ¯\_(ツ)_/¯
21:37:05 <iqubic> I don't know what any of this stuff is. I'm a Linux n00b
21:37:10 <M-rgh> From signal(7): "The signals SIGKILL and SIGSTOP cannot be caught or ignored"
21:37:18 <dyl> But, your dependencies shouldn’t be installing signal handlers, I don’t think.
21:37:31 <dyl> That’s not something you do in a library.
21:37:41 <M-rgh> It's not about trapable or non-trapable it's to do with the shell.
21:38:11 <dyl> Maybe I’m misinterpreting but I think dminiuoso wants his program to handle C-c in its own way
21:38:16 <dyl> Rather than shut down automatically.
21:38:17 <M-rgh> dyl: agreed it's a nightmare ;)
21:38:23 <dminuoso> No I just care about understanding where the "^C" comes from.
21:38:33 <dminuoso> The one I see in my terminal
21:38:34 <dyl> That means C-c
21:38:37 <dyl> ^C
21:38:49 <blu3r4d0n> It's what you typed is it not?
21:38:52 <dyl> And I’m not sure, I think that’s up to your emulator.
21:38:58 <dyl> Whether or not it echoes it I mean.
21:39:01 <dyl> But you did type it.
21:39:12 <dyl> M-rgh: libdispatch <3
21:39:12 <blu3r4d0n> I think the system just does that regardless of emulator
21:39:19 <dminuoso> blu3r4d0n: C-c is not a character - I thought it was just a control sequence from my emulator that was translated into a SIGINT
21:39:28 <dyl> libdispatch is such a wonderful thing
21:39:30 <dminuoso> But if thats the case, why don't I see that in weechat.
21:39:44 <dyl> Curses?
21:39:51 <EvanR> what system just does that
21:39:53 <dminuoso> What's so special about curses?
21:39:56 <glguy> weechat and other programs like that aren't getting a sigint from ^C
21:39:56 <dyl> Don’t question how curses works.
21:40:06 <dyl> Curses is black magic, it even says so on the tin.
21:40:08 <M-rgh> ;)
21:40:10 <blu3r4d0n> It is lol
21:40:13 <M-rgh> Curses manages the screen.
21:40:28 <dminuoso> glguy: Does curses use some ANSI escape codes to disable that behavior?
21:40:29 <dyl> It might also just issue a clear after receiving ^C
21:40:32 <M-rgh> Therefore it can dictate what is printed when it dies.
21:40:34 <dyl> Yeah
21:40:41 <blu3r4d0n> Yeah
21:40:43 <dyl> It could clear whatever your terminal emulator normally shows
21:40:52 <dyl> And depending on how it’s implemented you might not see both states.
21:40:53 <Zipheir> dminuoso: Isn't that just the terminal echoing the keypress? The effect of that keycode is to send SIGINT, but the keypress is still decoded and echoed by your tty.
21:40:55 <M-rgh> dminuoso: it's stty
21:41:18 <M-rgh> Zipheir: that's correct.
21:41:20 <dyl> M-rgh: Hey now don’t call people’s code stty.
21:41:32 <EvanR> this is like primer where after inventing time travel they get a call from themselves, and wonder how cell phones work "dunno"
21:41:58 <dyl> Tide goes in, tide goes out.
21:42:00 <dyl> You can’t explain that.
21:42:06 <M-rgh> Sorry dyl . It'll never happen again. Promise.
21:42:15 <Zipheir> dyl: Tide goes in, stains come out.
21:42:47 <jchia> Is there a tool that lets an end-user edit the value of some data type visually? The data could be nested. The use case is to represent config data, so the type serves as a schema, and let user edit config values.
21:42:56 <EvanR> the question is complicated by the fact that no one here is using a terminal
21:43:02 <EvanR> that i know of
21:43:07 <dyl> What do you mean?
21:43:09 <jchia> So, I provide the data definition and the tool auto-generates whatever is needed to edit the data.
21:43:18 <dyl> We certainly all use terminal emulators.
21:43:27 <Zipheir> The key word is 'emulator'
21:43:35 <dyl> Right and that was my point.
21:43:37 <blu3r4d0n> Nah, I'm in a teletype session lol jk
21:43:41 <EvanR> but answer you give about "terminals" dont necessarily apply
21:43:46 <dyl> You might not even see an update.
21:43:53 <dyl> Because the subsequent one happens too fast.
21:43:57 <dyl> It’s all up to implementation.
21:44:23 <dyl> TTYs have no many edge cases emulating them is hardly entirely consistent when you poke at edge cases.
21:44:42 <dyl> Curses can very much clear the screen before you see something that was otherwise printed.
21:44:48 <dyl> In many emulators.
21:44:51 <EvanR> this is wild speculation
21:45:06 <dyl> Oh good, I was worried it was boring speculation.
21:45:17 <M-rgh> The terminal handling stuff in the Linux kernel is some of thorniest in the entire kernel codebase.
21:45:30 <blu3r4d0n> The sass level in this channel is 100%
21:45:31 <dyl> My point is, it’s magical.
21:45:32 <blu3r4d0n> lol
21:45:36 <dyl> Don’t question it, just sacrifice goats.
21:45:40 <EvanR> i get "^C" printed in iterm2
21:45:46 <dyl> So do I.
21:45:49 <codedmart> Ah I see now.
21:45:58 <dyl> But I don’t see it from vim I believe.
21:45:58 <EvanR> in some programs not others
21:46:01 <M-rgh> It even lead to a spat between Alan Cox and Linux Torvalds.
21:46:11 <blu3r4d0n> I use gnome-terminal, it just depends on the program
21:46:45 <dyl> Torvalds loudly and pricklishly expressing his (generally well founded) opinion?
21:46:48 <dyl> Say it ain’t so.
21:47:24 <dyl> M-rgh: any links about this though?
21:47:27 <dyl> Sounds interesting.
21:47:54 <EvanR> am i being deviant by taking my RSW based monad and putting the R and the W-builder into the same thing as the state, and just using State
21:48:05 <M-rgh> Search Results
21:48:06 <EvanR> RWS*
21:48:06 <M-rgh> Kernel hacker Alan Cox quits Linux, Intel • The Register
21:48:06 <M-rgh> https://www.theregister.co.uk/2013/01/24/alan_cox_quits_linux
21:48:21 <tysonzero> Ok wtf is going on, if I put `main = putStrLn "foo"` and compile it on windows, it's not printing anything
21:48:25 <dyl> 404?
21:48:32 <dyl> > on Windows
21:48:34 <lambdabot>  error:
21:48:34 <lambdabot>      Data constructor not in scope: Windows :: b -> b -> c
21:48:35 <dyl> Frankly who can say?
21:48:54 <tysonzero> that seems like it shouldnt happen right
21:48:58 <tysonzero> > id
21:49:00 <lambdabot>  error:
21:49:00 <lambdabot>      • No instance for (Typeable a0)
21:49:00 <lambdabot>          arising from a use of ‘show_M79917134750593954024929’
21:49:04 <dyl> > fix error
21:49:06 <EvanR> open Windows, break Windows
21:49:06 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
21:49:11 <EvanR> fix Windows
21:49:20 <tysonzero> > print "wtf windows"
21:49:22 <lambdabot>  <IO ()>
21:49:35 <EvanR> % putStrLn "windows"
21:49:35 <yahb> EvanR: windows
21:49:42 <M-rgh> dyl: that article isn't right.
21:49:42 <EvanR> god i love that bot
21:49:45 <blu3r4d0n> You guys are making my night lol
21:49:52 <blu3r4d0n> And yeah, it's messed up
21:49:56 <blu3r4d0n> https://www.theregister.co.uk/2013/01/24/alan_cox_quits_linux_development/
21:50:00 <dminuoso> M-rgh: Ahh. Okay that answered it all =)
21:50:04 <M-rgh> dyl: https://linux.slashdot.org/story/09/07/29/1925224/alan-cox-quits-as-linux-tty-maintainer-ive-had-enough
21:50:18 <tysonzero> Ok seriously though that seems catastrophically bad?
21:50:25 <dminuoso> M-rgh: So my terminal driver might be in raw mode (as it is the case for weechat, perhaps ncurses in general?)
21:50:43 <dminuoso> M-rgh: In cooked mode C-c would be caught, translated into SIGINT while a "^C" gets printed on the scren
21:50:46 <EvanR> tysonzero: sometimes a compiled program for windows has its stdio redirected in some weird way, such as to a file in the same dir as the exe
21:50:54 <EvanR> i imagine it could could also be redirected to nowhere
21:51:00 <EvanR> its a flag you can set
21:51:08 <dyl> > Data.Bytestring.Internal. accursedUnutterablePerformIO (print “wtf windows”)
21:51:10 <lambdabot>  <hint>:1:63: error: lexical error at character 'w'
21:51:13 <tysonzero> Is it perhaps a stack thing / a threaded thing/
21:51:29 <dyl> 00:50 dyl: > Data.Bytestring.Internal.accursedUnutterablePerformIO (print "wtf windows")
21:51:30 <tysonzero> my cabal file contains `ghc-options:         -O2 -Wall -threaded`
21:51:42 <dyl> > Data.Bytestring.Internal.accursedUnutterablePerformIO (print "wtf windows")
21:51:44 <lambdabot>  error:
21:51:44 <lambdabot>      Not in scope:
21:51:44 <lambdabot>        ‘Data.Bytestring.Internal.accursedUnutterablePerformIO’
21:51:48 <dyl> Lame.
21:52:08 <dyl> > Data.ByteString.Internal.accursedUnutterablePerformIO (print "wtf windows")
21:52:10 <lambdabot>  error:
21:52:10 <lambdabot>      Not in scope:
21:52:10 <lambdabot>        ‘Data.ByteString.Internal.accursedUnutterablePerformIO’
21:52:23 <M-rgh> dminuoso: I'm not sure. I'd assumed it was a terminal setting.
21:52:39 <iqubic`> Do we actually want an IO a -> a as a function?
21:52:43 <dyl> :t Data.ByteString.Internal.accursedUnutterablePerformIO
21:52:44 <lambdabot> IO a -> a
21:52:52 <dyl> Yes.
21:52:54 <dyl> Yes we do.
21:53:00 <iqubic`> What is the point?
21:53:06 <tysonzero> hmm, this is really weird
21:53:09 <jle`> well
21:53:14 <jle`> it's not that we want any ol `IO a -> a`
21:53:18 <dminuoso> M-rgh: I should really study the tty layer a bit more.
21:53:20 <jle`> a *specific* one is helpful sometimes
21:53:28 <dyl> There are a few of them though,
21:53:30 <dyl> .-8
21:53:32 <dyl> .*
21:53:37 <M-rgh> dminuoso: Nooooooooooo
21:53:38 <tysonzero> wait is a Setup.hs required?
21:53:43 <jle`> maybe some specific ones :)
21:53:53 <M-rgh> It'll cost you your sanity!
21:53:53 <dyl> dminuoso that way lies only madness and despair
21:53:54 <M-rgh> At best.
21:53:59 <jle`> it's basically the .Internal module of ghc
21:54:06 <dyl> Lasciate ogne speranza voi ch’intrate
21:54:18 <iqubic> What IO a -> a functions are helpful?
21:54:31 <jle`> dyl: the function you are trying to use wouldn't show you anythign anyways
21:54:35 <jle`> dyl: lambdabot prints out values
21:54:37 * EvanR gives dminuoso the MIDI layer
21:54:41 <dminuoso> dyl: I dont know. The last time I asked that question "when I write `return 0;` in some main function in C, what can it return to", a few weeks later I ended up writing an entire kernel
21:54:42 <jle`> dyl: even if you couild do that, you'd just get ()
21:54:47 <dyl> EvanR: no stop!
21:54:55 <dyl> Have mercy man
21:55:09 <dminuoso> Because it turns out it's really useful to understand the entirety of your subsystems to some degree.
21:55:23 <jle`> iqubic: it's mostly useful for FFI
21:55:23 <dyl> You might as well link a pirated copy of some book on “PHP in production”.
21:55:43 <dyl> And I’m working on an emoji based APL dialect.
21:55:49 <dyl> Sometimes our curiosity can drive us mad.
21:56:10 <iqubic> jle`: That makes sense.
21:56:23 <iqubic> dyl: Are there any good APL tutorials out there?
21:56:25 <jle`> it's also definitely not the function that most people think it is
21:56:47 <dyl> Idk I just ordered some ancient used book for $3
21:57:00 <dyl> dminuoso: Show me the TTY layer and I will show you fear in a handful of dust.
21:57:24 <dminuoso> iqubic: unsafePerformIO is basically a promise that says: "I know this looks impure, but I promise that I have sufficient proof that this is actually pure in some way"
21:58:02 <dyl> Unrelated: anyone listen to the new Jon Hopkins album?
21:58:05 <dyl> It’s good.
21:59:15 <blu3r4d0n> Nah I haven't
22:00:03 <dyl> Emerald Rush is so satisfying.
22:00:28 <M-rgh> Given the list of people he's similar to I somewhat dismayed that I haven't any of his stuff.
22:01:02 <dyl> Opalescent, Immunity and now Singularity are all fantastic in their own ways.
22:01:24 <dyl> Everything from ambient to classical to microhouse and techhouse.
22:01:37 * M-rgh rushes off to remedy his deficient music knowledge.
22:01:42 <dyl> It’s the kind of music to just sit and listen through.
22:01:55 <M-rgh> dyl: any recommendations to start with or any of those?
22:02:14 <dyl> Just listen to the new one, it kind of covers all of the bases at various points.
22:02:22 <dyl> Just be aware it’s an album, like a movie.
22:02:29 <dyl> It’s meant to be listened to in one go.
22:02:47 <blu3r4d0n> I love stuff like that
22:02:50 <M-rgh> I pretty much only listen to albums.
22:02:51 <dyl> The songs don’t have choruses or verse structure, it’s just one hour long evolution.
22:03:15 <dyl> Each song grows from A to B and doesn’t really have any coarse structural repetition.
22:03:24 <EvanR> omg offtopic
22:03:30 <dyl> OKAY MOM
22:03:48 <dyl> FIIIINE
22:03:52 <blu3r4d0n> really though it was offtopic lol
22:03:57 <dyl> It was.
22:04:01 <dyl> <3 EvanR
22:05:37 <dminuoso> What exactly is the use case for type annotations in patterns? How is this useful?
22:07:07 <johnw> dminuoso: have you ever tried to match an exception?
22:07:21 <johnw> the type you should in the pattern's annotation determines what you catch
22:07:25 <johnw> s/should/choose
22:07:41 <dyl> Shameless plug for ##cheese
22:07:53 <dyl> The only 100% cheese based channel.
22:08:02 <dyl> It’s Haskell related.
22:08:10 <dyl> It’s empty so it can be related to anything vacuously.
22:08:27 <dyl> johnw: how many cases does that apply in though?
22:08:28 <EvanR> is there a premade method to run a state computation inside another state computation "hypothetically"...
22:08:39 <EvanR> like forkState or something
22:09:00 <dyl> What resolves the superposition?
22:09:14 <dyl> Or are you doing it for side effects?
22:09:16 <johnw> dyl: it applies both in cases and function arguments ;)
22:09:27 <dyl> That’s true ℤ
22:09:28 <EvanR> doing it to see what would happen
22:09:29 <dyl> .*
22:09:37 <johnw> EvanR: you could use LogicT on top of your state monad
22:09:50 <johnw> that's sort of what it's for, I suppose
22:09:56 <EvanR> hmmm
22:09:57 <dyl> EvanR: I guess I mean what is the goal of running this state computation “hypothetically”?
22:10:09 <dyl> What is the state you want to capture and if so what will you do with it?
22:10:10 <EvanR> to what the effect on the state would be
22:10:16 <dminuoso> johnw: Okay that's interesting. Given two `Handler ()` (which seem to have existential types, right?), how does Haskell pick the right one?
22:10:23 <EvanR> to see what*
22:10:37 <dminuoso> johnw: Is there some reflection going on the handlers?
22:10:40 <dyl> But how is that being encoded?
22:10:56 <dyl> I guess I’m not sure what you mean.
22:11:21 <dyl> Oh I see
22:11:25 <dyl> Forking state.
22:11:33 <EvanR> get the current state, run a state action starting with it, get the final state, then decide if it should be merged in
22:11:57 <EvanR> i dont see such a thing in the haddocks
22:12:21 <dyl> Well, seems like a saturated State type
22:12:37 <dyl> would have inhabiting values you could just copy and run on another threadwith the usual async/await model.
22:12:55 <dyl> You could also just think of it as capturing the continuation.
22:13:00 <dyl> And cloning it.
22:13:09 <johnw> dminuoso: yes, Typeable reflection
22:14:01 <dyl> It seems to me this would be pretty nicely expressive with continuations.
22:14:09 <dyl> Maybe you want ContT StateT ...
22:15:08 <EvanR> earlier today i was calling this "substate" in my mind... sounds totally rad
22:17:35 <johnw> LogicT is implemented using continuations
22:17:54 <EvanR> how is this related to Logic/LogicT
22:18:15 <johnw> maybe not, n/m
22:18:57 <blu3r4d0n> Night guys
22:20:18 <pdxleif> Anyone familiar with recommended way to "poll" file descriptors? https://stackoverflow.com/questions/50383042/recommended-way-to-poll-a-file-descriptor-in-haskell
22:20:20 <EvanR> dminuoso: honestly that bit of magic going on with exceptions was very confusing to me as a haskell beginner, who as a beginner, expected exceptions to be pretty straightforward
22:20:55 <EvanR> pdxleif: well... theres https://hackage.haskell.org/package/select
22:22:08 <pdxleif> EvanR: Yeah, that works. Just wasn't sure if it's maintained. Last published in 2013.
22:22:11 <tysonzero> Ok probably a stupid question, but how do I actually run https://github.com/danfran/cabal-macosx
22:22:30 <pdxleif> Currently using GHC.Event, which wraps epoll on Linux, but it says "
22:22:31 <EvanR> heh... how much has select changed
22:22:32 <pdxleif> This module should be considered GHC internal."
22:23:28 <pdxleif> I guess the advantage of using GHC.Event is that it doesn't require an extra package to be installed, and epoll is a bit more modern. But otherwise both seem to work fine.
22:23:33 <EvanR> if you just want to read when ready, you can fork a thread
22:23:40 <EvanR> if you just want to write when ready fork a thread
22:23:47 <pdxleif> I guess I like that GHC.Event doesn't require me to forkIO a thread - I just supply a callback.
22:23:49 <EvanR> otherwise... fork two threads?
22:25:10 <tysonzero> glguy
22:25:17 <tysonzero> do you know how to get it working at all?
22:25:18 <pdxleif> I'm not actually doing file IO - just listening for an event from udev (when e.g. the system brightness is changed) https://github.com/pxqr/udev/blob/master/examples/monitor.hs#L36
22:25:31 <pdxleif> I guess there's no forkIO in that example.
22:25:54 <EvanR> hGet should still work
22:26:35 <EvanR> i guess the recommended way is "dont use poll/select"
22:27:17 <pdxleif> As in hGetChar? That causes an exception "resource exhausted (Resource temporarily unavailable)" when I subsequently call the C function on that thing.
22:27:36 <pdxleif> I don't actually want to read data from the descriptor myself, just get notified when it's ready, then call that C function.
22:28:04 <EvanR> what C function
22:29:07 <EvanR> odd
22:29:39 <pdxleif> Well, this: https://github.com/pxqr/udev/blob/master/src/System/UDev/Monitor.hs#L141
22:30:17 <pdxleif> Which looks like it calls the C function on line 113.
22:30:33 <dminuoso> EvanR: It's not an exception topic, in fact as it turns out it's not even a Haskell/GHC/RTS topic.
22:30:33 <dminuoso> Or wait.. you referred to my last question
22:30:36 <EvanR> it becomes readable but then you cant read it? :(
22:31:15 <pdxleif> What I see on the console is:
22:31:16 <pdxleif> unable to receive message
22:31:17 <pdxleif> *** Exception: receiveDevice: resource exhausted (Resource temporarily unavailable)
22:31:28 <EvanR> is that ByteString IO
22:34:34 <EvanR> you could also FFI bind to select or poll yourself
22:34:54 <pdxleif> The comment says "Receive data from the udev monitor socket", so it stands to reason it's not going to be happy with me if I've already read a char from the socket, myself.
22:35:05 <EvanR> oh
22:35:19 <EvanR> right
22:35:49 <pdxleif> It's just calling the C function "udev_monitor_receive_device". Seems like a nicer Haskell wrapping could be made of this than just calling bare C functions.
22:37:27 <pdxleif> The Python version is better documented, though it seems they just use select(2) on the file descriptor over there, too: http://pyudev.readthedocs.io/en/v0.14/api/monitor.html
22:38:54 <pdxleif> I just wanna perform an action (update display) when the brightness on my laptop is adjusted.
22:41:21 <dminuoso> EvanR: In the end Exceptions are not trivial in any language. In C++ it took me some years to fully understand what's truly going on. In Haskell at least you don't have think as much about stack unwinding and destructors. ;)
22:42:19 <Axman6> pdxleif: what are you polling? is it new data on the FD? could you just use readFile, which is "blocking" but uses async apis under the hood?
22:43:07 * Axman6 reads back
22:43:11 <EvanR> yeeah no
22:43:23 <EvanR> its meant to be polled and then read by the library
22:43:37 <EvanR> or system lib
22:44:30 <pdxleif> Axman6: A socket file descriptor returned by udev; see the comments on http://presbrey.scripts.mit.edu/doc/libudev/libudev-udev-monitor.html#udev-monitor-receive-device
22:44:44 <pdxleif> Oh hey, there's hWaitForInput in System.IO
22:49:44 <EvanR> i'm not sure thats going to do what you want, after investigating
22:51:24 <pdxleif> Yeah, it still seems to give me the same "resource exhausted" error.
22:52:08 <pdxleif> Either select or GHC.Event works... they just don't seem exactly be "recommended", but I suppose I have a non-standard case, here.
22:52:55 <EvanR> because, it reads 1 or more bytes into the buffer, looks at them to see if its decodes to a character, and returns without removing it from the buffer
22:54:23 <EvanR> however it does make use of this GHC.IO.Device
22:54:44 <EvanR>  ready :: a -> Bool -> Int -> IO Bool
22:56:14 <geekosaur> threadWait{Read,Write} might be of interest
22:56:17 <dminuoso> How does Haskell know which dictionary to pass? I mean there's an existential type hidden away in the Handler: https://gist.github.com/dminuoso/9748354585d515aa7a1e15b6632ae40b#file-f-hs-L4
22:57:10 <EvanR> you chose SomeException
22:57:21 <EvanR> looks like
22:57:37 <dminuoso> EvanR: the dictionary choice has to come out of `handler`, just consider the following line
22:57:54 <pdxleif> geekosaur: Oh neat - that works perfectly, thanks!
22:58:42 <EvanR> oh yeah
22:58:47 <EvanR> theres a dictionary in the handler
22:58:49 <dminuoso> EvanR: If you have a handler `AsyncException -> IO a`, then this would have to use the dictionary from `instance Exception AsyncException`, but how does Haskell do this?
22:59:24 <EvanR> theres an Exception dictionary wrapped inside the Handler
23:00:18 <dminuoso> EvanR: So pattern matching makes that dictionary available?
23:00:23 <EvanR> something magically tests whether the exception occurring is compatible with that type, by using dynamic Typeable stuff
23:00:32 <EvanR> if so, it converts
23:00:41 <EvanR> :t fromException
23:00:42 <lambdabot> Exception e => SomeException -> Maybe e
23:00:46 <cocreature> dminuoso: existentials basically just have an additional field that stores the dict
23:02:04 <EvanR> (this is a heck of a lot of advanced stuff for something many people consider a basic language feature)
23:04:55 <dminuoso> cocreature: It's not that existential if I can just pattern match and observe/use that dict, is it?
23:05:35 <EvanR> you can always do that
23:05:36 <dminuoso> I mean, what's the type of tryHandler? `Exception e => Handler a -> IO a` ?
23:06:00 <cocreature> dminuoso: huh? that’s exactly what ExistentialQuantification gives you so I’m not sure what you mean by “it’s not that existential”
23:06:01 <EvanR> GADT pattern matching gives you type info within the case, but it cant escape
23:06:20 <EvanR> or you get a "my brain exploded" error
23:06:42 <dminuoso> EvanR: Oh. Is that the escaping skolem confusiation?
23:06:45 <cocreature> poor spj, his brain must have exploded quite a lot by now
23:06:57 <EvanR> yes
23:07:46 <EvanR> indeed even in this case, its fine. you get a dictionary that works for any exception type you want
23:08:31 <dminuoso> I should grab a ticket for Haskell eXchange 2018 =)
23:08:45 <dminuoso> Just saw that Marlow and SPJ are both key note speakers
23:09:30 <EvanR> i mean, whatever was thrown can be converted to SomeException, which can be passed to the fromException in this particular dictionary you found
23:09:50 <dminuoso> EvanR: It's not as much "what does this do", as it is rather "why does this work"
23:10:40 <EvanR> then, in your handler lambda, you can make use of the details of e, but only to produce the a
23:10:58 <EvanR> and nothing else can see details of e
23:12:14 <EvanR> "what does it do" is why it works... imagine runtime being untyped lambda calculus... the type system was just the theory that stopped the computer from crashing a burning. without it, you can do anything
23:12:50 <EvanR> like pass an unknown exception to an unknown conversion function in an unknown dictionary :)
23:14:26 <EvanR> to add fuel to the fire, look at the exception hierarchy example in the haddocks...... they are using "cast" to dismiss the type system :)
23:15:23 <EvanR> :t cast -- ok i remember where cast is from
23:15:24 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
23:15:41 <EvanR> so its still safe
23:21:32 <shiona_> I'm still working on my networked game learning experience. I have a "lobby" that has a TVar [Player] (where player contains a socket) where I wait for players to gather before starting games. For each player I have a lightweight thread listening on what's happening. I could give each player the TVar [Player] list of waiting players to modify when that player disconnects, but I'd like something cleaner.
23:22:28 <shiona_> For a moment I thought I had a brilliant solution, but that would have required TVar to be an instance of Monad which it isn't, probably because it does not make sense or it can't be done.
23:23:20 <EvanR> you have a thread blocked on reading from each socket right, and that thread crashes when they disconnect
23:23:37 <EvanR> in the finalizer for that thread, remove them from the TVar
23:23:49 <Axman6> sounds like a great place for channels and dup[T]Chan
23:23:54 <EvanR> or if youre using Async, do it in the parent thread
23:24:24 <shiona_> on the disconnect the read returns zero bytes which I test and tell that there has been a disconenct and then I'd like to do something about the situation
23:24:29 <EvanR> what ... last night we fixed someone overcomplicated it with TChans by just using 1 TVar
23:24:49 <EvanR> thats only one way for disconnect to happen
23:25:15 <EvanR> you can handle all of them with the finally part of forkFinally, or async
23:25:53 <shiona_> I have used forkFInally here and there in the code, but it has become quite a mess
23:26:49 <EvanR> i have a lot of agents going on in one program i have, and i nest them within monitor or parent asyncs which can deal with their failure or termination in various ways
23:27:00 <EvanR> like telescopes
23:27:24 <EvanR> particular wrappers are so simple they "cant fail" and so you get the feeling of reliability
23:28:17 <EvanR> forkFinally is kind of the poor mans version of this
23:28:44 <shiona_> I guess I should swap to async while the code is still somewhat simple
23:31:10 <EvanR> for notifying everyone about the disconnect yeah, a dupped TChan might be good
23:31:12 <Ariakenom> A tree is a nice way to structure things. even threads. connected and without cycles. parents most of the way up
23:33:11 <shiona_> EvanR: but in the terms of forkFinally, did you mean that my lobby should have something like "newclient <- accept; atomically $ modifyTVar (insert newclient) playerpool; forkFinally (play newclient somechannelortvar) (\_ -> atomically $ modifyTVar (remove newclient) playerpool)"
23:34:16 <EvanR> for the most basica functionality yeah
23:34:55 <cocreature> that needs some masking to be safe. otherwise you can end up registering a new player while your thread gets killed before the forkFinally is executed
23:36:11 <EvanR> isnt the final state the same
23:36:38 <EvanR> since there is no other effects happening here besides adding and removing (unique) objects
23:36:39 <cocreature> no you end up with a new player being inserted but no thread for the player
23:36:49 <cocreature> and it will never be removed
23:37:15 <EvanR> what is the situation again... the server thread is killed with an async exception?
23:37:32 <cocreature> you execute modifyTVar (insert …) … and then the thread dies
23:37:45 <dpyro> is there a type or a concept for a curried function that needs only one parameter applied to be computed?
23:37:53 <shiona_> "nc <- accept; forkFinally (atomically (modifyTVar (insert nc) pp) >> play nc) (\_ -> atomically (modifyTvar (remove nc) pp))" ?
23:37:56 <dpyro> like "Functor", "Monoid", etc.
23:38:09 <cocreature> I mean if that takes down your whole app it doesn’t matter a whole lot but I would recommend to always make sure that resource allocations are safe in the presence of exceptions
23:38:36 <EvanR> who could send that kill... the thread is anonymous and was just created
23:38:58 <cocreature> shiona_: I would just do something like forkIO (bracket (modifyTVar (insert …) …) (modifyTVar (remove …) …) …)
23:39:15 <cocreature> EvanR: the exception gets thrown to the thread that calls forkFinally not the new thread
23:39:17 <EvanR> if the server thread dies... yeah issue
23:39:26 <EvanR> its all borked
23:39:36 <dminuoso> EvanR: Well `tryHandler :: Exception e => A` for some A right?
23:39:43 <shiona_> never seen a bracket before. Hope it's not too complicated
23:40:08 <cocreature> shiona_: "bracket" is what you should use in pretty much all cases for resource allocation
23:40:18 <dminuoso> EvanR: Actually I think I know how to simplify this
23:40:38 <EvanR> tryHandler seems a bit odd
23:40:41 <cocreature> shiona_: it makes sure that weird conditions where the thread dies after a resource has been allocated but before the finalizer is registered don’t happen
23:41:06 <cocreature> dminuoso: what is tryHandler supposed to be?
23:42:02 <dminuoso> cocreature: Let me make a simple testcase to illustrate my question
23:44:38 <Axman6> dpyro:  can you give an example of what you mean?
23:46:32 <dpyro> something like: funcList = [(+ 1), (+ 2), abs]
23:46:34 <dpyro> Axman6
23:47:45 <cocreature> dpyro: what do you mean by “compute”? (+) 1 still “computes” something namely the function that adds one to its argument
23:48:01 <dminuoso> @letpaste 481743567941795840
23:48:02 <lambdabot>  .L.hs:165:9: error:
23:48:02 <lambdabot>      • Could not deduce (Some a0)
23:48:02 <lambdabot>        from the context: Some a
23:48:23 <dpyro> cocreature i think i'm just looking for the type
23:48:35 <dpyro> my guess is its something like [a → b]
23:48:54 <Ariakenom> :t [(+ 1), (+ 2), abs]
23:48:56 <cocreature> dpyro: just ask ghci :)
23:49:00 <lambdabot> Num a => [a -> a]
23:50:26 <EvanR> dpyro: doesnt seem to be what you were asking.. you mean like... a function which can fully compute some answer with only 1 more argument
23:50:37 <dpyro> yes
23:50:46 <dpyro> im wondering if there's a class for it
23:50:54 <EvanR> since A -> B -> C -> D is curried, it only takes 1 argument, and is of the form a -> b
23:51:17 <cocreature> my point is “fully compute some answer” is not a very vague concept in a language with first class functions
23:51:28 <Ariakenom> A -> X             A -> (B -> C -> D)
23:51:36 <cocreature> s/not//
23:51:49 <dminuoso> cocreature: Ah I think I was just a bit confused. `tryHandler :: Handler a -> IO a` there is no Exception constraint. =)
23:52:42 <dminuoso> Im guessing that inside that binding `handler :: Exception e *> e`
23:52:51 <cocreature> dminuoso: don’t you mean something like tryHandler :: Handler a -> IO a -> IO a?
23:53:14 <dminuoso> Oh right for Nothing yeah.
23:53:31 <Ariakenom>  A -> B -> C -> D =  A -> (B -> C -> D) which matches a->b
23:53:53 <Ariakenom> with b = B -> C -> D
23:55:41 <cocreature> dminuoso: so what exactly is your question? :) or did things click by now :)
23:55:49 <dminuoso> cocreature: Everything starts clicking =)
23:55:55 <cocreature> great ;)
23:58:56 <dminuoso> cocreature: So if I pattern match on `(Handler handler)`, I'd end up with some `handler :: exists e. Exception e *> e` - and like ski tried burning into my head a few months ago, existential types can be thought of tuples =)
23:59:20 <cocreature> dminuoso: what is *> supposed to mean here?
23:59:35 <dminuoso> cocreature: He used that notation as an alternative to => for existentials
23:59:45 <EvanR> a pairing of an instance with a value
