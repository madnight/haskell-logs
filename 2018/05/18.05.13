00:01:32 <jle`> @where learnhaskell
00:01:32 <lambdabot> https://github.com/bitemyapp/learnhaskell
00:05:17 <letsfindout> jle`: thanks, I'll check that out
00:26:11 <hololeap> i'm looking at a generalized way of using a list to key out a value from (in essense) `Fix (Compose (Either e) IntMap)`, and i've pulled out something that looks a lot like `Fix (ReaderT i m)`. does anyone know if there is something deeper to this type? is it essentially the same as mfix?
00:27:12 <johnw> Fix (Compose (Either e) IntMap) is the same as Free IntMap e
00:28:12 * hackage pronounce 1.1.0.2 - A library for interfacing with the CMU Pronouncing Dictionary  http://hackage.haskell.org/package/pronounce-1.1.0.2 (NoahGoodman)
00:32:24 <hololeap> so then it's a free monad built off of the IntMap functor... and i'm converting it to something like `Free (ReaderT Int Maybe) e`
00:33:02 <johnw> which I believe should be equivalent to ReaderT Int (Free Maybe) e
00:34:02 <hololeap> huh, weird
00:34:29 <johnw> and further, Free Maybe e is equivalent to (Int, e)
00:35:19 <hololeap> how?
00:35:31 <johnw> values of type Free Maybe e are things like:
00:35:35 <johnw> Pure (_ :: e)
00:35:48 <johnw> oh, never mind
00:35:58 <johnw> I forgot that you have recourse to Nothing
00:36:34 <johnw> so, any number of Just wappers, terminating in either Nothing or some 'e'
00:36:46 <johnw> (Int, Maybe e), then
00:36:50 <hololeap> oh, so you were maybe saying that Free Identity e is equivalent to (Int, e)
00:37:02 <hololeap> or i guess isomorphic
00:37:08 <johnw> well, in Haskell it is because you can "count" the newtype wrappears
00:37:23 <johnw> with Maybe, we do the same counting, but we can end in one of two ways
00:37:39 <hololeap> so would it be isomorphic to (Int, Bool, e)?
00:37:48 <hololeap> or, no...
00:37:48 <johnw> there's a chance there's no 'e' at all
00:38:02 <hololeap> (Int, Maybe e)
00:38:03 <johnw> Fix Maybe is isomorphic to Nat, for example
00:38:13 * hackage mmark-ext 0.2.1.0 - Commonly useful extensions for the MMark markdown processor  http://hackage.haskell.org/package/mmark-ext-0.2.1.0 (mrkkrp)
00:38:21 <johnw> Free just lets us add a new base case to 'f'
00:38:31 <johnw> yeah, (Int, Maybe e)
00:38:48 <johnw> which should be more memory efficient
00:44:34 <jared-w> Memory efficiency, pffh. It's all abuot the zygoprehistomorphisms
01:04:12 * hackage qnap-decrypt 0.3.2 - Decrypt files encrypted by QNAP's Hybrid Backup Sync  http://hackage.haskell.org/package/qnap-decrypt-0.3.2 (alexkazik)
01:19:12 * hackage publicsuffix 0.20180513 - The publicsuffix list exposed as proper Haskell types  http://hackage.haskell.org/package/publicsuffix-0.20180513 (wereHamster)
01:53:29 <xiaohei> Hi, how to pattern match on a data constructor that takes function as argument? like this one: data MyType a = MyType (String -> a)
01:54:24 <xiaohei> I am writing a Functor instance for this type, I don't know how to fmap on it.
01:55:41 <c_wraith> xiaohei: there's nothing special..    instance Functor MyType where fmap f (MyType g) = ...
02:00:20 <pavonia> Is there a way to hand memory allocated with `new' somehow over to the GC? I have to create several C strings dynamically that are possibly never deleted. Keeping references to all of them would be a big hassle
02:02:07 <xiaohei> c_wraith: Yes, that catches the match, so the right side of the equal sign should be: fmap (fmap f g), and g must be also a Functor?
02:02:50 <xiaohei> c_wraith: a typo, = MyType (fmap f g)
02:07:12 * hackage css-syntax 0.0.7 - This package implments a parser for the CSS syntax  http://hackage.haskell.org/package/css-syntax-0.0.7 (wereHamster)
02:12:42 * hackage gi-pangocairo 1.0.17 - PangoCairo bindings  http://hackage.haskell.org/package/gi-pangocairo-1.0.17 (inaki)
02:13:42 * hackage gi-gtk 3.0.23 - Gtk bindings  http://hackage.haskell.org/package/gi-gtk-3.0.23 (inaki)
02:18:29 <c_wraith> xiaohei: that works, though fmap seems needlessly polymorphic there.  This also works: = MyType (f . g)
02:19:03 <c_wraith> xiaohei: that's because fmap when given a function as its second argument is just (.)
02:23:12 * hackage plot-light 0.4.3 - A lightweight plotting library, exporting to SVG  http://hackage.haskell.org/package/plot-light-0.4.3 (ocramz)
02:35:01 <iron_houzi> Is utilization of typeclass Read an anti-pattern?
02:36:02 <c_wraith> Read is kind of not intended to be much more than a toy.
02:36:17 <electrocat> iron_houzi: depends, its not great for real world parsing
02:36:21 <electrocat> it's fine for debugging though
02:37:33 <electrocat> albeit not very useful
02:39:05 <iron_houzi> thanks
03:34:01 <juanOsorio> Hey haskell community! I am having a little bit of trouble differenciating . and $ for functions. I have following function : decode xs = concat $ map (\(i, c) -> take i $ repeat x) xs. this however does not compile if you define it as concat . map (lambda) xs. Why is this?
03:34:19 <juanOsorio> I mean load. not compile.
03:35:23 <c_wraith> juanOsorio: they are totally different.  the fact that some expressions mean the same thing if you swap some of them is purely coincidence
03:35:28 <c_wraith> :t ($)
03:35:29 <lambdabot> (a -> b) -> a -> b
03:35:31 <c_wraith> :t (.)
03:35:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:36:15 <juanOsorio> what do $ and . mean then?
03:36:30 <c_wraith> ($) is function application.  (.) is function composition
03:37:04 <c_wraith> @src ($)
03:37:04 <lambdabot> f $ x = f x
03:37:09 <c_wraith> @src (.)
03:37:09 <lambdabot> (f . g) x = f (g x)
03:37:14 <juanOsorio> so . can be just seen as chaining functions without aplying them?
03:37:32 <c_wraith> Not just "can be seen as".  "is".  :)
03:39:04 <juanOsorio> thank you very much
04:48:14 <jchia_> I'm thinking of the actual benefits of using the mono-traversable package. It's supposed to let you do mapping, folding etc. on monomorphic containers, like Text, that don't expose a type variable for the type of the element. However, besides Text and ByteString, what else is there for which this sort of mapping/folding is useful?
04:51:12 <cocreature> jchia_: note that it’s not only for monomorphic containers. it includes monomorphic mapping on polymorphic containers as well
04:51:45 <cocreature> so you can abstract over Text, [Char], Vector Char, … if all your code only consists of mapping Chars
04:56:33 <jchia_> cocreature: It seems that for polymorphic containers the more complicated types (using type families) incurred is an overkill and the type inference also suffers. Now I'm thinking that since the 'mono-ness' is in practice mainly to address Text and ByteString, maybe I should switch away from it as my standard library for map, fold, traverse -related things.
04:57:46 <jchia_> When I wrote my code in terms of mono-traversable functions for dealing with non-Text and non-ByteString, I also have to give them complicated type signatures
04:57:50 <jchia_> 'write'
04:57:50 <cocreature> yeah, I don’t use it myself because I don’t find it super useful
04:59:02 <jchia_> It looked nice when I chose it, but it just dawned on me that in practice, it's really just addressing Text and ByteString.
05:00:06 <cocreature> well there are also things like unboxed vectors and Data.Set that can’t have Functor instances
05:00:40 <jchia_> cocreature: True
05:01:16 <cocreature> but most of the time you either get away with something like Functor or you just specialize your code to some concrete type
05:01:46 <jchia_> cocreature: However, I can still the mono-traversable with "import qualified" instead of making it the basis of my custom prelude.
05:02:02 <jchia_> Right now my custom prelude is based on classy-prelude.
05:02:34 <cocreature> sure as I said, I don’t use mono-traversable at all so I’m certainly not trying to convince you to keep using it :)
05:03:10 <jchia_> Just trying to get some perspective on this. I think I'll switch to another alternative prelude when I have time. Not sure which one. Too many to choose.
05:04:02 <cocreature> I’m quite fond of protolude personally. it’s mostly just reexports + a small number of convenience features
05:15:42 * hackage yesod-bin 1.6.0.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.6.0.3 (MichaelSnoyman)
05:16:24 <jchia_> cocreature: OK. protolude and foundation are two options I'm going to consider when I finally have time to switch.
05:18:24 <fr33domlover> I've been wondering about this whole growing prelude ecosystem
05:18:36 <fr33domlover> I see a lot of options, and it's very interesting,
05:19:13 <fr33domlover> But I keep using regular Prelude, it seems to feel safe to me and familiar and answers my needs
05:19:41 <fr33domlover> I'm curious which use cases lead people to stop and consider switching to one of the alernatives :)
05:21:31 <cocreature> fr33domlover: I’m mostly just annoyed by having 10 lines of imports for even the simplest stuff
05:21:42 <cocreature> and String
05:21:58 <cocreature> so protolude is mostly reexports + Text which solves that problem perfectly for me
05:22:28 <fr33domlover> cocreature, hmm yeah I guess I have those little annoyances too
05:22:34 <fr33domlover> head, init, etc. being non total
05:22:49 <fr33domlover> functions for showing stuff, especially as Text
05:22:56 <fr33domlover> missing
05:23:01 <cocreature> yeah although tbh I haven’t found the partial functions in Prelude to be much of a problem
05:23:30 <fr33domlover> cocreature, I suppose none of these issues are really much of a problem
05:23:35 <electrocat> these concepts are simply non-total, you just shouldnt use them
05:23:36 <fr33domlover> They're just... little annoyances
05:23:45 <fr33domlover> I guess they acumulate
05:23:51 <Axman6> jchia_: I quite like lens' Each class fir the mono=tranersable style stuff
05:23:53 <fr33domlover> Until you stop and say, I want something better
05:24:03 <cocreature> for me protolude plays in the same league as default-extensions. it’s just nice to not have 20 lines of boilerplate at the top of each file
05:24:40 <fr33domlover> That's fairly lightweight though, I think
05:24:42 <fr33domlover> cocreature,
05:24:44 <electrocat> is it bad practice or something to put all of these extensions once in the cabal file?
05:24:57 <fr33domlover> I mean, some stuff like in foundation is a much bigger change
05:25:01 <fr33domlover> Than just imports
05:25:06 <cocreature> right
05:25:11 <cocreature> that’s why I don’t use foundation :)
05:25:20 <electrocat> why do people insist of putting them every time in the file every time
05:25:41 <jchia_> Axman6: What lens'?
05:25:44 <Axman6> electrocat: many of them aren't needed in every file
05:25:53 <Axman6> :t each
05:25:54 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
05:25:54 <fr33domlover> electrocat, maybe easier to track which files require which extensions
05:26:01 <cocreature> electrocat: depends on who you ask :) I tend to put the “lightweight” extensions in the cabal file and then more complicated extensions in the individual files
05:26:22 <fr33domlover> electrocat, I personally put them in files when writing a library, and sometimes in cabal file if writing a program
05:27:14 <Axman6> I am ok putting things like OverloadedStrings in the cabal file, but DataKinds probably not
05:27:29 <electrocat> sure, it depends on the extension
05:27:49 <fr33domlover> Some extensions also add flexibility at the cost of ambiguity etc.
05:28:05 <fr33domlover> So you don't want them applied to your whole project automatically
05:28:17 <fr33domlover> Just those few places where you really need them
05:28:33 <electrocat> that's fair
05:28:50 <jchia_> electrocat: I put the standard set of extensions in the cabal files for my project. The argument goes that if you list the extensions in the file, it's clear to the reader of the file. However, I consider the set of standard extensions standard for my project and I don't want to clutter my .hs files with boilerplate.
05:29:23 <fr33domlover> Also some projects like idk maybe Yesod, Servant etc.
05:29:30 <fr33domlover> Have sets of extensions you need everywhere
05:29:38 <fr33domlover> So you just drop them in the cabal file
05:29:51 <jchia_> electrocat: When a file requires additional extensions, i list them in the file itself.
05:29:53 <fr33domlover> Because you just need them everywhere anyway if you buy into these tooks
05:29:55 <fr33domlover> *tools
05:31:06 <fr33domlover> ah I have a question!! What do you think about the NoMonomorphismRestriction extension, and when it's right to use it?
05:31:30 <cocreature> fr33domlover: I tend to just use an explicit type annotation instead
05:31:38 <fr33domlover> It's a default in Yesod projects but sometimes causes very annoying confusing type errors
05:31:49 <fr33domlover> I've been wondering why they chose to use it
05:31:53 <fr33domlover> cocreature, same
05:31:54 <jchia_> There are some extensions that are fairly harmless that I think you can use everywhere.
05:32:04 <jchia_> even if you don't need them. you can make them standard
05:32:29 <jchia_> it saves you the trouble of thinking of which extensions you have turned on
05:33:00 <fr33domlover> jchia_, personally I like knowing which extensions I use, because more extensions complicate the mental model
05:33:16 <fr33domlover> So I feel more comfortable when I'm aware of what I use and what I don't
05:33:55 <electrocat> i would like to just always have the extensions enabled that basically just lift the restrictions from GHC
05:33:56 <cocreature> having to think about whether an instance requires flexible instances or not complicates my mental model more than just turning it on :)
05:34:17 <jchia_> fr33domlover: If you decide to always use a relatively harmless extension in your projects, then there is no additional complication. E.g. TupleSections.
05:34:25 <jchia_> You just remember that you are using it.
05:34:41 <electrocat> definitely Flexible*
05:34:54 <electrocat> i always forget this is not a thing with Haskell2010
05:35:07 <fr33domlover> cocreature, jchia_ hmmm good point, yeah I guess I use TupleSections and FlexibleInstances very often and it's like a standard in my mind
05:35:32 <cocreature> most of the syntactic sugar extensions are also pretty reasonable to always turn on, e.g. LambdaCase, TupleSections, MultiWayIf, BangPatterns, …
05:35:54 <cocreature> because seeing the syntax already tells you that they have to be enabled
05:36:02 <cocreature> it’s not “hidden”
05:36:32 <fr33domlover> The ones with type features are the scary ones I like to be aware of :p
05:36:58 <fr33domlover> I admit a reason may be that I don't actually know all those type system features very well
05:37:07 <electrocat> fr33domlover: which features come to mind? :p
05:37:38 <cocreature> the only type-system extensions that I tend to turn on project wide are ScopedTypeVariables, RankNTypes and GADTs
05:37:59 <fr33domlover> electrocat, RankNTypes :p
05:38:00 <cocreature> for GADTs you have again that they’re very visible so you can’t miss it
05:38:09 <electrocat> for me it's GADTs, Type Families and FunDeps
05:38:30 <electrocat> and as cocreature mentioned, you usually see that you're using them
05:38:34 <electrocat> except for fundeps maybe
05:38:45 <electrocat> oh and KindSignatures
05:39:40 * fr33domlover has been recently interested in the use of type level declarations as an alternative to doing stuff with Template Haskell
05:39:50 <jchia_> electrocat: I have TypeFamilies turned on too, but I suppose it's a harder decision than something like TupleSections. Although it's obvious that you're using it, it also turns on MonoLocalBinds, KindSignatures, ExplicitNamespaces.
05:40:51 <jchia_> I think MonoLocalBinds can cause code to stop compiling
05:41:09 <fr33domlover> The best extension in the world is DeriveAnyProgram ;)
05:41:15 <fr33domlover> Coming in GHC 999 ;)
05:41:16 <cocreature> I just don’t use TypeFamilies enough in most projects to justify turning them always on
05:41:27 <cocreature> fr33domlover: will it be as useless as DeriveAnyClass? :)
05:42:55 <fr33domlover> Btw I want to share something annoying about specs!
05:43:02 <fr33domlover> I'm writing a library based on a spec,
05:43:18 <fr33domlover> And the algorithms in the spec are written with an obvious bias for JS
05:43:33 <fr33domlover> Or other stuff
05:43:47 <fr33domlover> Imperative, not specifying the types of things,
05:44:04 <fr33domlover> Working with raw values without validating anything until the very last moment
05:44:06 <fr33domlover> etc.
05:44:33 <fr33domlover> And it makes it very non obvious to implement in pure functional style
05:44:43 <fr33domlover> I find it annoying, I must say :p
05:45:34 <fr33domlover> It's just data transformations, they could be described in a more functional style, be general, rather than spaghetti imperative pseudo code
05:45:55 <fr33domlover> (Which I guess is how the spec authors usually write code, probably Javascript)
05:46:23 <electrocat> fr33domlover: probably :p
05:46:41 <aarvar> not much of a spec then is it?
05:46:44 <fr33domlover> It's also nearly impossible to look at the algo and feel sure that all cases are handles, and what the code flows are etc.
05:46:57 <fr33domlover> aarvar, I find that it's a trend
05:47:20 <fr33domlover> aarvar, like, new web stuff being written with obvious JS bias in the pseudo code
05:47:33 <fr33domlover> Or even clearly stating the code is just JS lol
05:47:38 <aarvar> why is there pseudo code at all
05:49:12 <fr33domlover> aarvar, sometimes it helps a lot to describe stuff in a spec
05:49:46 <fr33domlover> i just think a spec is better when its algorithms are written using tools that make it easy to see all cases are handled, data is typed etc.
05:49:55 <fr33domlover> it's just safer and clearer
05:50:32 <fr33domlover> And if someone wants to use a dynamic language with dynamic types, that's okay, but it shouldn't compromise the quality of the spec
05:50:58 <mniip> ugh
05:51:14 <fr33domlover> Much like people can write apps in dynamically typed languages etc. but do program verification using other languages with strong type systems
05:51:32 <fr33domlover> A spec is like that verification, it should be explicit and complete and thorough
05:51:49 <electrocat> that's why reading type system specs are nice :p
05:51:54 <mniip> I've asked about the contravariant monoidal comparator functor in ##c++ and no one understood me :(
05:51:56 <fr33domlover> But what do I know, I never wrote a spec :p
05:52:04 <electrocat> even though because of the declarative nature they like to omit any kind of control flow
05:53:06 <fr33domlover> electrocat, i like the way new ghc features and extensions are described in the ghc manual :p
05:53:08 * aarvar considers saying for the nth time that there's no such thing as dynamic types
05:53:15 <fr33domlover> often it feels like that capture all the edge cases
05:53:23 <fr33domlover> it feels thorough and mature
05:53:31 <fr33domlover> *they capture
05:53:51 <electrocat> fr33domlover: could you give an example? :)
05:54:34 <electrocat> aarvar: preaching to the choir :p
05:54:37 <fr33domlover> electrocat, i guess it's everything. typed template haskell, applicative do, type families and all the related features :)
05:54:45 <aarvar> like the part where they explain how aliasing a type family magically makes fundeps work?
05:55:26 <electrocat> you're so cynical :p
05:56:31 <ddk> hello all
05:56:34 <aarvar> haskell may be better than everything else, but it still sucks :)
05:56:48 <fr33domlover> Idk I like Haskell a lot
05:56:59 <fr33domlover> Far more than everything else I tried before
05:57:14 <fr33domlover> Feels the most natural to me
05:57:15 <aarvar> fr33domlover: hence the "better than everything else" part
05:57:18 <ddk> I have a specific question with distributed-process library, anyone here familiar with it
05:57:19 <fr33domlover> To the way my mind works
05:57:35 <fr33domlover> aarvar, what's the "sucks" part? ^_^
05:58:03 <ZeuPiark> hello
05:58:18 <fr33domlover> mniip, tbh i wouldn't know what it means either :p
05:58:57 <ddk> there is a function mkClosure whose type is ```mkClosure :: (a -> b) -> Closure b
05:58:58 <aarvar> inability to abstract over instance declarations, lack of dependent types, type family weirdness
05:59:04 <mniip> well, consider data Comparator a = (a -> a -> Odering)
05:59:05 <aarvar> for starters
05:59:11 <mniip> Comparator is a contravariant functor
05:59:12 <int-e> aarvar: hah, does this mean you have more complaints about Haskell than about any other programming language, because you use it so much?
05:59:42 <mniip> it is a contravariant applicative: it's easy to implement divide :: (a -> (b, c)) -> Comparator b -> Comparator c -> Comparator a
05:59:43 <aarvar> int-e: that, and most languages are so terrible you can't even begin to complain about them
05:59:45 <int-e> (there's certainly be some truth in that, in my case)
05:59:47 <mniip> and conquer :: Comparator Void
06:00:08 <ddk> mniip: hello do you have experience with distributed-process aka cloud haskell
06:00:13 <mniip> no
06:00:25 <ddk> mniip: okay thanks
06:00:30 <mniip> I only know the fancy mathematical crap and none of the practical aspects
06:00:52 <fr33domlover> ddk, try mailing lists if you can't get help in the channel! :)
06:00:58 <electrocat> aarvar: these are just difficult problems, and we don't have enough people to solve them
06:01:35 <aarvar> electrocat: well, I think the first one I listed really shouldnt be that difficult
06:01:37 <aarvar> but oh well
06:01:51 <electrocat> aarvar: your frustrations also stem, i believe, from that haskell is largely research driven and has less stability focussed development
06:01:53 <ddk> fr33domlover: thanks actually I wanted quick response, btw I have contacts with some of its authors
06:01:56 <fr33domlover> aarvar, ghc welcomes ideas for new features ^_^
06:02:01 <aarvar> electrocat: no, that's not it
06:02:12 * hackage hw-prim 0.5.0.4 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.5.0.4 (haskellworks)
06:02:20 <electrocat> aarvar: wel that's where the type family weirdness comes from :p
06:02:25 <aarvar> fr33domlover: I have a less-than-half-finished proposal
06:02:39 <ddk> so anyone here familliar with cloud Haskell ...Q
06:02:46 <aarvar> electrocat: well...
06:02:51 <electrocat> ddk: just state your question
06:03:21 <electrocat> aarvar: i wonder what you mean with abstracting over instance declarations
06:03:41 <aarvar> electrocat: https://github.com/aaronvargo/ghc-proposals/blob/class-constructors/proposals/class-constructors.rst
06:03:52 <ddk> electrocat: problem is too specific , its a little wauge for me to express the problem in a general sense or with no context of CH
06:05:14 <ddk> my problem is mkClosure function takes another function t (t :: a -> b) and its argument a and gives a (Closure b)
06:05:22 <electrocat> aarvar: i'll let you know if i see any glaring issues
06:05:40 <aarvar> electrocat: I stopped writing when I got to the type families part :)
06:05:56 <aarvar> actually it can handle them quite nicely though I think
06:06:01 <aarvar> I just got annoyed at how dumb they are
06:07:04 <ddk> but when I am calling $(mkClosure t ) (something) ,, where something is not of type a ( say t :: Int -> Int) but here something is of type String, then also compiler is not hitting me with the error, I wanted to know why this behaviour
06:07:35 <electrocat> aarvar: ah
06:07:37 <electrocat> i see
06:07:38 <fr33domlover> ddk, can you try writing a code snippet
06:08:05 <ddk> fr33domlover: okay one min
06:08:18 <electrocat> aarvar: i would do the syntax differently though :p
06:08:29 <aarvar> electrocat: in what way?
06:08:44 <aarvar> it needs to use the existing instance syntax for backwards compatibility :/
06:10:44 <fr33domlover> ddk, if you use $() I assume mkClosure makes a TH splice then! so mkClosure itself returns Exp. Idk if it matters, just pointing out the little detail
06:11:00 <electrocat> aarvar: yeah, just don't like it, can't think of anything better though
06:11:00 <aarvar> electrocat: see the "Splitting a class" section
06:11:08 <fr33domlover> (I never used distributed process)
06:11:23 <aarvar> electrocat: I was going to maybe suggest alternate syntax as well
06:11:31 <aarvar> and various syntactic sugars
06:11:35 <aarvar> haven't gotten to that part yet
06:11:50 <electrocat> aarvar: do you know how type class inference works?
06:11:57 <aarvar> electrocat: wdym?
06:12:21 <aarvar> as in how it infers dictionaries? more or less
06:12:25 <electrocat> this might be non-trivial to implement
06:12:30 <aarvar> electrocat: how so?
06:12:46 <aarvar> it shouldn't affect that at all
06:13:39 <aarvar> electrocat: it's almost purely syntactic, though not quite
06:16:32 <ddk> fr33domlover: yes It uses TH
06:18:03 <ddk> fr33domlover: I don't know why lpaste.net is not working for me, can you suggest something else to share the code snippet
06:18:06 <electrocat> aarvar: no you're right
06:18:30 <electrocat> aarvar: this is a gripe of mine as well, i would like to see a solution like this
06:18:52 <aarvar> writing boilerplate instances gets pretty tiresome
06:19:25 <aarvar> maybe I should add more motivating examples
06:19:44 <aarvar> there are much more painful ones than the one I give
06:20:34 <electrocat> aarvar: the splitting classes example might be problematic though
06:20:40 <aarvar> electrocat: why
06:20:49 <electrocat> you're using the class constructor as an actual type class
06:20:54 <aarvar> no I'm not
06:20:56 <aarvar> :)
06:20:59 <aarvar> where did I do that
06:21:28 <electrocat> well you defined Applicative as a constructor
06:21:38 <electrocat> which means that it needs to be able to appear in type signatures
06:21:43 <aarvar> no
06:21:53 <aarvar> classes and class constructors exist in different namespaces
06:22:02 <aarvar> there's both an Applicative class and an Applicative class constructor
06:22:03 <electrocat> ok, sorry, i'm just skimming it
06:22:14 <aarvar> with the latter not being the primary constructor for the former
06:22:22 <ddk> where to paste the code snippet
06:22:32 <ddk> lpaste.net is not working
06:22:43 <aarvar> electrocat: that's the purpose of being able to give different names for primary constructors
06:23:03 <electrocat> aarvar: i see
06:23:18 <aarvar> so, it just completely separates classes from their construction
06:23:18 <ddk> giving this error : A web handler threw an exception. Details: SqlError {sqlState = "53100", sqlExecStatus = FatalError, sqlErrorMsg = "could not extend file \"base/16389/63782\": No space left on device", sqlErrorDetail = "", sqlErrorHint = "Check free disk space."}
06:23:53 <aarvar> electrocat: its the same as changing a data type in a backwards compatible manner
06:24:32 <leeched> ddk: you could create a gist on github
06:24:32 <aarvar> electrocat: e.g. if you add a new field, you can change the constructor name and redefine the old constructor
06:24:40 <aarvar> er, add a new field to a record
06:24:42 * hackage websockets-snap 0.10.3.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.10.3.0 (JasperVanDerJeugt)
06:24:52 <aarvar> ignoring certain limitations of pattern synonyms
06:25:05 <aarvar> or you can not export the constructor, same thing
06:27:16 <aarvar> electrocat: but at least we're going to get DerivingVia, which doesn't really solve the fundamental problem, but whatever!
06:30:53 <maerwald> \_ -> Nothing :: b -> Maybe a
06:30:53 <maerwald> is this function pure wrt the definition "purity is the (weak) equivalence of call-by-name, call-by-value and call-by-need"?
06:32:28 <electrocat> aarvar: solving this syntactically is the easiest way
06:33:01 <electrocat> i'd rather have some more general extension of the type system
06:33:27 <electrocat> but you always run into type class coherence related issues
06:33:46 <aarvar> electrocat: huh?
06:33:54 <aarvar> not with this proposal you cant
06:34:02 <electrocat> aarvar: i know
06:34:38 <electrocat> i'd rather solve this using actual instance declarations
06:34:43 <aarvar> good luck
06:34:47 <electrocat> but that might not be possible
06:34:56 <aarvar> I don't think you can do that without creating a new language
06:35:27 <aarvar> and it'd still be hard
06:35:59 <aarvar> electrocat: but I have ideas I'd like to try
06:36:39 <aarvar> yesterday edwardk was telling me about an idea he has which is pretty interesting
06:36:42 * hackage hw-rankselect 0.12.0.2 - Rank-select  http://hackage.haskell.org/package/hw-rankselect-0.12.0.2 (haskellworks)
06:37:57 <aarvar> but so far its an unsolved problem
06:40:42 * hackage Hastodon 0.5.0 - mastodon client module for Haskell  http://hackage.haskell.org/package/Hastodon-0.5.0 (syucream)
06:42:30 <electrocat> aarvar: damnit
06:42:38 <electrocat> distraction me from my work with your interesting idea's
06:43:03 <aarvar> distracting people is one thing I'm good at
06:50:03 <the_2nd> I have a sum type and would like to produce a list of all possible sums, with defaults for their fields. e.g. One 0, Two 0, Three "" 0. Is that possible?
06:51:20 <Rembane_> the_2nd: without actually typing out each choice?
06:51:25 <the_2nd> yep
06:51:54 <Rembane_> the_2nd: Generics or Scrap your Boilerplate is the way to go AFAIK.
06:52:02 <Rembane_> the_2nd: Or maybe Data.Typeable
06:52:24 <the_2nd> I want to produce some sort of documentation for the types and need a list to print the constructors of the sum type
06:53:22 <Rembane_> the_2nd: This might be a useful technique: https://chrisdone.com/posts/data-typeable check the end of this blogpost.
06:53:23 <the_2nd> I could do it by hand, risking missing updates of that list
06:56:47 <the_2nd> thank you, I'll take a look at it
06:57:00 <kuribas> the_2nd: is it finite?
06:57:28 <the_2nd> kuribas, the types? They might have infinite types as fields
06:57:39 <the_2nd> but these would be ignored by my functions anyway
06:57:48 <kuribas> then the list of all possibilities would be infinite
06:58:26 <the_2nd> document (After "") = "Selects everything after a provided string"
06:58:50 <the_2nd> I'd like to produce a list of the type to map document on it
06:58:58 <the_2nd> currently I'd have to do this by hand
07:01:24 <kuribas> the_2nd: some code would be helpful
07:01:48 <the_2nd> kuribas, one sec
07:03:35 <kuribas> > [minBound .. maxBound] :: [Bool]
07:03:37 <lambdabot>  [False,True]
07:04:05 <kuribas> > [minBound .. maxBound] :: [Ordering]
07:04:07 <lambdabot>  [LT,EQ,GT]
07:05:58 <the_2nd> kuribas, https://pastebin.com/37Lj5jtE
07:08:47 <the_2nd> kuribas, I fear these only work if there's no sub-fields
07:08:54 <kuribas> yes
07:09:24 <kuribas> you could do that with generics
07:09:42 <kuribas> so documentation is a list of all comment strings?
07:09:59 <the_2nd> for example
07:10:06 <the_2nd> I expanded Documented to
07:10:45 <the_2nd> https://pastebin.com/uEKVZHiC
07:11:08 <the_2nd> I'd like to be able to have some "writeDocumentation" method with as little overhead as possible
07:14:47 <lyxia> the_2nd: do you have some default values to put in the fields or is it fine to just let them be undefined
07:14:57 <kuribas> so self documented functions?
07:15:00 <kuribas> or commands
07:16:06 <kuribas> I'd probably use a (Map String Command)
07:16:12 <kuribas> instead of a sum type
07:17:13 <kuribas> then the documentation for each would be (map documentation $ elems map)
07:17:42 <kuribas> but I'm still guessing what you want this for
07:20:49 <kuribas> I don't think a sum type is the best way here
07:24:18 <jchia_> How come I convert a "data Foo { x :: Int, y :: Bool }" to a "(Int, Bool)", i.e. transfer the element values, without boilerplate? coerce doesn't work.
07:24:41 <jchia_> "How can"
07:25:36 <aarvar> jchia_: you could use generics
07:25:56 <jchia_> aarvar: Do you mean with "fromRep . toRep"?
07:26:18 <mitchty> is there a way to get what the latest revision a package in hackage has? I thought there used to be a way to get that via the webpage, but not finding it today
07:26:26 <aarvar> jchia_: requires a bit more than that I think
07:26:40 <aarvar> since they have different meta data
07:26:51 <jchia_> i mean "from . to"
07:26:53 <lyxia> to . coerce . from
07:26:56 <jchia_> OK
07:26:57 <mitchty> aka if there were another reivsion for mtl http://hackage.haskell.org/package/mtl-2.2.2/revision/0.cabal
07:27:21 <kuribas> jchia: myConv (Foo x y) = (x, y)
07:29:22 <mitchty> nevermind, found this https://github.com/haskell-infra/hackage-trustees/blob/master/revisions-information.md
07:31:48 <jchia_> from and to, especially to, seem quite useful, but lens also have things with the same name. Otherwise, I would be reexporting them in my custom prelude.
07:35:32 <jchia_> kuribas: Yeah, sometimes I wonder whether my goal to reduce boilerplate is making my code more complicated.
07:36:06 <kuribas> jchia: if it is just that I wouldn't bother...
07:36:20 <kuribas> jchia: OTOH, if you have 500 lines of ADTs...
07:38:24 <jophish> bitemyapp: are there any plans to update sdl2 to support SDL 2.0.6?
07:38:44 <jophish> particularly to expose the functions in https://www.libsdl.org/tmp/SDL/include/SDL_vulkan.h
07:44:12 * hackage wordchoice 0.1.2.7 - Get word counts and distributions  http://hackage.haskell.org/package/wordchoice-0.1.2.7 (vmchale)
07:48:53 <seanparsons> I'm still a bit baffled as to how people hook cabal new-build into a build process, does everyone else just construct the deep build path to the executable so they can do whatever they need with it? (Like incorporating it into a Docker image for example)
07:52:59 <phadej> seanparsons: check cabal-plan http://hackage.haskell.org/package/cabal-plan
07:53:32 <phadej> it will construct the path for you. And yes, I use it to find the executable to put it into a Docker image :)
07:54:39 <phadej> (you could either use cabal-plan exe, or the lib; we use lib as build process is orchestrated by Haskell thing anyway)
07:57:12 <seanparsons> Oh ho! Now this sounds like exactly what I want. Cheers phadej!
07:57:53 <phadej> you're welcome
08:15:12 * hackage z3 4.3.1 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-4.3.1 (IagoAbal)
08:35:44 <EvanR> i'm trying to parse lines in megaparsec which may have # a comment between the end of the line data and the newline
08:36:10 <EvanR> but my comment parser ideas keep consuming the newline itself, which screws up sepBy
08:36:23 <EvanR> which uses \n(spaces) as the separator
08:41:44 <Welkin> EvanR: go thank your mother!
08:42:17 <bitemyapp> jophish: since when did I become maintainer of an SDL library?
08:42:36 <Welkin> bitemyapp: since right now
08:42:38 <Welkin> congrats
08:42:59 <EvanR> for contributing to the overpopulation of the earth? also off topic
08:43:15 <Welkin> EvanR: how is it offtopic?
08:43:20 <bitemyapp> EvanR: I always knew you were RMS in disguise
08:43:24 <Welkin> do you know what day it is?
08:43:31 <EvanR> lol
08:43:45 <bitemyapp> it's very unpopular to be RMS right now, not a good look.
08:43:55 <EvanR> abort()
08:44:09 <Welkin> what about being kanye?
08:44:19 <EvanR> next they are going to ask to change that api call name
08:44:29 <EvanR> next they are going to ask to take it out of the dictionary
08:44:40 <EvanR> newspeak pls
09:00:12 <phadej> EvanR: don't consume newline in your comment parser?
09:00:36 <phadej> i.e. comment = char '#' *> skipMany nonNewlineCher ?
09:01:54 <phadej> (not `skipUntil '\n'`)
09:04:43 <EvanR> could have sworn i tried that
09:05:40 <EvanR> but skipMany (notChar '\n') does not consume the \n indeed
09:06:27 <phadej> :)
09:08:38 <EvanR> that simplifies the other crap i came up with for the comment parser
09:08:54 <Welkin> phadej: do you use ghcjs at your company?
09:12:35 <phadej> Welkin: nope
09:13:23 <phadej> too little frontend cose to justify it (for my needs)
09:15:07 <phadej> (and others are happy with elm or typescript, dunno if anyone uses purescript in client project)
09:15:42 <Welkin> phadej: from your website, it looked like you build a lot of things that are typically built with react, which is why I asked
09:16:21 <phadej> yeah, but i don't work in client projects :)
09:18:42 <the_2nd> kuribas, sorry I left, my UI froze and I forgot to restart my IRC
09:19:15 <kuribas> the_2nd: eh, np...
09:19:21 <the_2nd> the types already exist as-is. So that's why they're sum types, the docs aren't the only purpose. I'll take a look at Generics, thanks for the help so far
09:20:49 <phadej> Welkin: and many at Futurice write React apps. that's hard to change
09:25:42 * hackage hledger-diff 0.2.0.14 - Compares the transactions in two ledger files.  http://hackage.haskell.org/package/hledger-diff-0.2.0.14 (gebner)
09:26:12 * hackage fsnotify-conduit 0.1.1.0 - Get filesystem notifications as a stream of events  http://hackage.haskell.org/package/fsnotify-conduit-0.1.1.0 (MichaelSnoyman)
09:30:42 <biglambda> Anyone have a minute to help me work through a build issue?
09:31:11 <glguy> The only way to find out is to ask the actual question
09:32:05 <biglambda> I already posted the same question and you kindly responded actually.
09:32:26 <biglambda> I’m trying to install a local version of OpenCL library.
09:32:54 <biglambda> I get this error: <no location info>: error:
09:32:54 <biglambda>     module ‘Control.Parallel.OpenCL.Query’ is a package module
09:33:27 <biglambda> The only new information I have is that if I change the module name of Query to QueryB in the package. It installs.
09:33:39 <biglambda> But that is of course a breaking change.
09:34:50 <cocreature> biglambda: which command are you running to install the package?
09:35:08 <biglambda> cabal install from within the cloned directory
09:35:38 <biglambda> Also cabal install from a sandbox that has opencl as an added source.
09:41:15 <biglambda> I’ve been trying to find that error message in cabal source, just to try and understand what it means exactly but I haven’t found it yet.
09:41:25 <cocreature> biglambda: hm I just cloned the repo, and ran "cabal install OpenCL" in a sandbox that the repo added using add-source and it works fine
09:41:45 <biglambda> frustrating.
09:41:58 <cocreature> which version of cabal are you using?
09:42:13 <biglambda> 1.24.0.0
09:42:20 <cocreature> that’s quite old, maybe try upgrading
09:42:25 <biglambda> ok
09:46:07 <Welkin> how are so many people using cabal 1.24?
09:46:12 <Welkin> where is this coming from?
09:46:33 <Welkin> biglambda: how did you install cabal initially?
09:48:08 <biglambda> In this case it’s coming from the MacOS Haskell platform
09:48:36 <biglambda> I’m on GHC 8.0.1 btw
09:49:34 <noan> biglambda, https://www.haskell.org/platform/#osx platform is available at modern versions
09:50:05 <Welkin> we are on 8.4.2
09:50:09 <Welkin> on haskell platform
09:50:12 <Welkin> for mac osx
09:50:14 <noan> ye
09:50:46 <biglambda> Ok, I’m always afraid to upgrade my stuff because of breaking changes…
09:51:12 <biglambda> But I’ll reinstall now.
09:52:26 <Welkin> I'm running 8.4.2 on mac with no problems
09:52:33 <Welkin> installed via the platform
09:52:37 <Clint> just ignore all the stuff that's still broken on 8.4
09:53:03 <Welkin> and cabal 2.2.0.1
09:53:13 <Welkin> you definitely want cabal 2.2
09:53:16 <Welkin> then you can use new-build
09:55:29 <biglambda> Ok, I’ve done all that.
09:55:50 <biglambda> Getting an error on new-build clang: error: unknown argument: '-no-pie'
09:56:14 <biglambda> I’ll try putting -fPIC in my cabal ghc options
09:56:34 <Welkin> also https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
09:56:57 <Welkin> new-build, new-run is pretty much all you need
09:57:19 <suzu> stack tho
09:57:25 <Welkin> suzu: no
09:57:31 <suzu> no????????
09:58:08 <glguy> biglambda: That no-pie warning with GHC 8.4.2 on macOS seems harmles
09:58:12 <Welkin> suzu: have you seen cabal nix-style builds?
09:58:17 <Welkin> I linked it above
09:58:36 <suzu> i haven't
09:58:38 <suzu> will read
09:58:41 <suzu> is it worth moving off of stack for it?
09:58:59 <Welkin> yes
09:59:02 <Welkin> stack is obsolete
09:59:03 <biglambda> glguy: Not a warning
09:59:28 <glguy> biglambda: What are you trying to build that generates that error?
09:59:40 <biglambda> OpenCL library
09:59:41 <glguy> suzu: You don't have to commit one way or the other to try it :)
09:59:49 <suzu> to try it, i suppose not
10:00:10 <suzu> i do enjoy that stack will fetch the correct compiler though
10:00:24 <Welkin> suzu: cabal can do that too
10:00:28 <suzu> sweet
10:00:31 <Welkin> automatically
10:00:39 <glguy> Welkin: How do I turn that on?
10:00:42 <Welkin> you can install and manage however many versions of ghc you want
10:00:56 <Welkin> and then tell cabal which one to use with the -w flag (or in the cabal config)
10:00:56 <EvanR> i'm here to learn stuff
10:01:04 <suzu> i'll take a look at this
10:01:20 <suzu> i suppose the only dependency is having an up-to-date cabal?
10:01:22 <glguy> Welkin: Manually installing compilers, and specifying the compiler with -w is what I do now and doesn't seem automatic :)
10:01:34 <biglambda> https://pastebin.com/xZ4YbzTB
10:01:59 <EvanR> dang...
10:02:21 <Welkin> glguy: it creates a .ghc.environment.[arch]-[version] file
10:03:10 <glguy> Yes, but that doesn't help with fetching or selecting the "correct" GHC, right?
10:03:35 <Welkin> no, I don't believe so
10:03:41 <EvanR> what about once you find the correct ghc... how to install it
10:03:44 <Welkin> you'll still need to use -w or add it to your config
10:03:51 <glguy> biglambda: What does 'gcc --version' show for you?
10:04:01 <glguy> I'm building on current versions of mac and don't get that output
10:04:44 <biglambda> https://pastebin.com/1NQ0PNc2
10:05:33 <glguy> biglambda: That's a different version than the current one, maybe your Xcode is out of date? and what used to be an error is now a warning
10:06:56 <biglambda> Ok brb, gotta restart to upgrade xcode.
10:07:00 <Welkin> o.o
10:07:02 <Welkin> xcode
10:07:19 <Welkin> you mean the xcode command-line tools?
10:08:00 <glguy> Welkin: I think the versions are all tied together
10:08:16 <Welkin> you can install the command-line tools without installing xcode
10:09:36 <DigitalKiwi> that include dir is different than mine
10:12:37 <iqubic> I've been trying to understand Monad Transformers by writing the instance declarations of Functor, Applicative, and Monad for MaybeT. Any other instance declarations I should write to round out my understanding?
10:13:58 <suzu> read the mtl docs
10:14:45 <aspidites> I've seen lots of posts on reddit about cross compiling. Does anyone happen to know how difficult it is to compile an sdl application for android?
10:14:48 <iqubic> What do the mtl docs teach me?
10:15:05 <suzu> how to use monad transformers
10:15:12 <suzu> you can also read the source and see how they work under the hood
10:16:38 <iqubic> suzu: I'm want to write the instances for MaybeT for myself. Anything other than Functor, Applicative and Monad that I should write?
10:17:07 <suzu> i think that should be all
10:17:09 <aspidites> :i MaybeT
10:17:24 <suzu> maybe Semigroup..?
10:17:37 <suzu> Semigroup / Monoid
10:17:37 <iqubic> MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
10:17:47 <suzu> right
10:17:59 <suzu> write the MonadTrans instasnce ;)
10:18:03 <iqubic> Should I write the MonadTrans instance?
10:18:21 <iqubic> Or the alternative instance?
10:18:50 <suzu> write MonadTrans. then you can use 'lift'
10:19:11 <iqubic> What instance gives me liftIO?
10:19:26 <lyxia> monadio
10:19:28 <suzu> MonadIO
10:19:45 <iqubic> Should I write the MaybeT instance for MonadIO?
10:19:55 <suzu> you mean the MonadIO instance for MaybeT?
10:19:57 <suzu> yeah
10:20:02 <suzu> then you can liftIO
10:20:04 <iqubic> I do mean that.
10:20:31 <iqubic> Is there an Alternative instance for MaybeT that I should write.
10:20:42 <iqubic> Note, this is just for learning purposes.
10:21:12 <cocreature> iqubic: you can just take a look at the existing instance
10:21:32 <suzu> MaybeT has a whole bunch
10:21:37 <suzu> you can just rewrite them all if you like
10:21:42 <suzu> http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html
10:24:58 <neongreen> so I'm making a thingy to grep over all of Hackage (with regexes) online: http://codesearch.aelve.com/haskell
10:25:14 <neongreen> any feature requests? or usecases that you can think of?
10:25:25 <biglambda> Well that was fun.
10:26:00 * DigitalKiwi thought you got lost
10:26:18 <biglambda> Had to update my OS to update XCode
10:26:27 <biglambda> You know how that goes.
10:26:42 <cocreature> neongreen: nice!
10:26:49 <DigitalKiwi> I'm surprised you're back that quickly then tbh
10:27:08 <biglambda> Yeah. Apple’s not to shabby.
10:27:31 <cocreature> neongreen: it might be nice if there was an option to ignore comments.
10:27:39 <DigitalKiwi> no lately they've been taking a long time and done the shitty windows approach
10:27:56 <DigitalKiwi> You used to be able to update without logging out and taking 30 minutes
10:28:23 <biglambda> Yeah. I hate these constant reminders to upgrade
10:29:02 <Welkin> I get them every single day
10:29:06 <Welkin> I always clck "remind me tomorrow"
10:29:13 <suzu> same
10:29:18 <Welkin> because there is no option for "shut up and don't bother me again"
10:29:24 <Welkin> on linux, no such issue
10:29:28 <suzu> if i upgrade it's gonna nuke my machine
10:29:29 <Welkin> mac gets worse every day
10:29:33 <DigitalKiwi> I still don't know why they changed it, was only recent 1-2 versions they added the mandatory loading screen?
10:29:36 <Welkin> I am transitionaing away from it
10:29:45 <suzu> i only use a mac because my work forces me to
10:29:47 <Welkin> I do all of my programming on linux now
10:29:49 <suzu> arch linux at home
10:30:06 <suzu> which has whacko haskell packages but that's a separate problem
10:30:10 <DigitalKiwi> lolarch
10:30:11 <aarvar> neongreen: find all uses of unsafePerformIO?
10:30:31 <neongreen> cocreature: ignoring comments isn't exactly easy but it's on the roadmap, yeah
10:30:34 <biglambda> I’ve been on remind me tommorow for a year apparently.
10:31:06 <EvanR> hahaha
10:31:17 <DigitalKiwi> I just do it when I'm going to bed, and then it doesn't reboot because terminal won't close, and then remind me tomorrow >.>
10:32:41 <Welkin> does anyone remember apple's solution to the battery estimate feature giving the wrong value on the new macbooks?
10:32:53 <Welkin> they disabled the feature entirely, for everyone regardless of hardware
10:32:59 <aarvar> don't buy apple?
10:33:14 <suzu> i legit just bought my mom an iphone for mother's day
10:33:20 <biglambda> I think it’s still the best OS
10:33:22 <Welkin> iphone is still okay
10:33:26 <Welkin> there isn't much better out there
10:33:33 <suzu> i personally use a Pixel
10:33:47 <hpc> just don't turn it off and on too many times, or it'll throttle the cpu to compensate for the battery going bad
10:33:53 <suzu> there's nothing better than an iPhone when it needs to be braindead to use
10:33:58 <biglambda> Yeah, I bought my mom a laptop from Apple for Xmas
10:34:23 <biglambda> Now  I don’t have to hear about her computer today.
10:34:24 <neongreen> aarvar: too many of those, unfortunately. Though something like "find all unsafePerformIOs that are used for global vars and where the coder forgot to add NOINLINE" might be more useful, yep
10:34:31 <DigitalKiwi> I mean yeah as much as some things are annoying I actually like most of macos better than anything else and parallels is good enough that any linux I want is within reach...
10:34:46 <Welkin> DigitalKiwi: linux + gnome shell or kde
10:34:58 <aarvar> neongreen: might be useful to be able to hide/fold the actual occurences, and just see a list of packages
10:35:00 <DigitalKiwi> arch with xmonad
10:35:07 <Welkin> sure, I like tiling wms too
10:35:20 <hpc> my only complaint nowadays with native linux is that dark themes don't work perfectly with web browsers
10:35:42 <DigitalKiwi> this is really ot now :|
10:35:48 <iqubic> That sucks.
10:35:54 <EvanR> dude have you tried puppy linux?!
10:35:59 <EvanR> oops
10:36:01 <aarvar> nixos with xmonad
10:36:01 <iqubic> Tiling WMs are the greatests.
10:36:04 <DigitalKiwi> 10 years ago
10:36:16 <iqubic> aarvar: NixOS with EXWM.
10:36:26 <DigitalKiwi> EvanR 10 years ago
10:36:39 <catsup> is it possible to tell ghci to use a different history file (to make it local to the repository)?
10:36:42 <aarvar> I wish emacs would play nice with TWMs
10:36:47 <DigitalKiwi> though... iqubic 10 years ago too hehe
10:37:07 <neongreen> aarvar: huh, this wouldn't have occurred to me. Do you have any situations in mind when this could be useful?
10:37:14 <kuribas> aarvar: it doesn't?
10:37:17 <aarvar> neongreen: nope
10:37:31 <iqubic> aarvar: Look into EXWM.
10:37:32 <iqubic> It stands for Emacs X Window Manager.
10:37:47 <DigitalKiwi> it's X built into emacs
10:37:50 <aarvar> iqubic: why would I want that
10:37:55 <aarvar> I want the opposite of that
10:38:07 <aarvar> kuribas: by default things open in a new window in emacs rather than a new frame
10:38:08 <DigitalKiwi> runs on bare hardware
10:38:21 <aarvar> so I end up using both emacs' window manager and xmonad
10:38:27 <aarvar> which is kind of dumb
10:38:31 <kuribas> aarvar: so write some lisp?
10:38:38 <aarvar> kuribas: too much work
10:38:46 <aarvar> and then I'd have to learn elisp
10:38:51 <aarvar> do it for me plz
10:39:21 <iqubic> aarvar: What do you want?
10:39:27 <catsup> what do you mean 'by default', there is no opening of files 'by default'
10:39:28 <kuribas> aarvar: find-file-other-frame?
10:39:51 <aarvar> https://github.com/davidshepherd7/frames-only-mode
10:39:56 <catsup> you just either use the command to open in a window, or the command to open in a frame
10:40:14 <DigitalKiwi> "An active, growing community exists around the language, and more than 5,400 third-party open-source libraries and tools are available in the online package repository Hackage.[43]"
10:40:15 <DigitalKiwi> Showing 1 to 100 of 12,619 entries
10:40:20 <DigitalKiwi> Well they're not wrong...
10:40:20 <aarvar> I tried to get that to work once but couldnt
10:40:32 <kuribas> aarvar: it literally does what you want
10:40:46 <catsup> kuribas: that doesn't mean it works
10:40:49 <aarvar> kuribas: yes, except it didn't seem to work :)
10:40:55 <aarvar> I want it to work
10:40:56 <EvanR> more than 9000 libraries
10:41:01 <catsup> aarvar: do you want all elisp scripts that try to open a frame to open a window instead?
10:41:15 <aarvar> catsup: other way around
10:41:23 <catsup> er yeah i meant the other way around
10:41:27 <kuribas> catsup: yes it works
10:41:30 <aarvar> yes, I think so
10:41:39 <monochrom> Hello, I'm new to this channel. Is this Emacs Victim Mutual Support Group? >:)
10:41:40 <aarvar> maybe there are exceptions where I don't, not sure
10:41:50 <aarvar> monochrom: apparently
10:42:08 <DigitalKiwi> monochrom shh just let it happen
10:42:20 <kuribas> aarvar: also, emacs has it's own tiling built in
10:42:28 <catsup> that seems like it would break things, or at least break expectations
10:42:36 <aarvar> kuribas: yes, that's the problem
10:42:39 <kuribas> aarvar: I don't see what a tiling WM would bring
10:42:50 <DigitalKiwi> monochrom at least nobody has mentioned that emacs sucks and vim/spacemacs is boss
10:42:53 <aarvar> consistent key bindings?
10:43:21 <iqubic> monochrom: Emacs is the gateway drug to Lisp.
10:43:33 <catsup> for example sometimes a script might pop up a window and not move the cursor there, sometimes it would move the cursor there; but you're not going to get that cursor/window focus translated into xwindow focus
10:43:41 <Welkin> iqubic: no
10:43:41 <aarvar> kuribas: also, what if I have two emacs windows and some other window outside of emacs?
10:43:44 <Welkin> elisp is terrible
10:43:52 <DigitalKiwi> it's true first I started using spacemacs and then I started learning scheme
10:44:06 <monochrom> Meanwhile in #haskell-offtopic someone is trying to bring up Typeable.
10:44:13 <catsup> scheme is a a lot better than elisp
10:44:15 <Welkin> but luckily there is work being done to replace emacslisp with guile scheme
10:44:36 <catsup> Welkin: i read that that was going badly, a long time ago.  it seems like it would.
10:44:49 <cocreature> monochrom: something is going wrong here …
10:44:57 <aarvar> catsup: meh, maybe I should just start trying to change it for individual commands...
10:45:15 <DigitalKiwi> I mean it's Sunday the fact that anyone is talking at all is surprising
10:45:20 <Welkin> it is mother's day
10:45:24 <catsup> aarvar: that seems like a good idea.  you should try that mode too though, maybe it got fixed.
10:45:29 <DigitalKiwi> We're all avoiding our mothers?
10:45:30 <aarvar> think I only really use the repl and magit anyway
10:46:09 <aarvar> catsup: hm, but now that I think about it, if I have two separate frames, I still want it to always open things in the second frame
10:46:14 <aarvar> rather than create a third one
10:46:46 <Welkin> just C-x o
10:47:04 <aarvar> well, right now I do SPC 1 and SPC 2
10:47:06 <aarvar> with spacemacs
10:47:27 <iqubic> Does dante provide any way to access GHCi?
10:47:33 <aarvar> which is probably a bad habbit actually
10:47:59 <iqubic> aarvar: It's fine.
10:48:07 <aarvar> iqubic: not really
10:48:24 <iqubic> How can I get access to GHCi if I use dante?
10:48:32 <aarvar> what if I have two emacs frames open on separate workspaces, each with two windows
10:48:38 <aarvar> now I need to use 3 and 4 for one of them
10:48:46 <aarvar> and have to remember which one
10:49:16 <iqubic> Just use EXWM and only have one instance of Emacs running at a time.
10:49:17 <aarvar> I should be using SPC w l or whatever it is
10:50:03 <aarvar> whatever, it doesn't matter enough for me to bother to change it
10:50:06 <iqubic> I don't know the spacemac commands.
10:50:25 <DigitalKiwi> whatever the emacs one is but with a space
10:51:17 <Welkin> lately I work in a single emacs frame that is 80x34
10:52:11 <DigitalKiwi> https://en.wikipedia.org/wiki/TRS-80_Model_100 do you use this
10:53:10 <the_2nd> Welkin, what's on the rest of your screen then?
10:53:34 <DigitalKiwi> anime girl
10:53:39 <Welkin> another, much smaller, terminal emulator
10:53:41 <the_2nd> Welkin, I run a 3 screen setup and still manage to fill that yp
10:53:42 <Welkin> and the nothing else
10:53:46 <biglambda> This cabal new-build is nice.
10:54:06 <DigitalKiwi> biglambda go to #haskell-offtopic plz with that
10:54:16 <biglambda> Sorry.
10:54:31 <DigitalKiwi> today is backwards day
10:54:45 <jmcarthur> Yeah, I am kind of enamored with new-build these days.
10:54:45 <Welkin> no, it's mother's day
10:54:48 <biglambda> So about my mom.
10:55:09 <Welkin> note that you can also just use `new-run` and it will rebuild if necessary before running
10:55:40 <biglambda> How do you add a local dependency with the new-style build
10:55:48 <Welkin> cabal.project
10:55:52 <Welkin> or cabal.project.local
10:55:58 <DigitalKiwi> if it wasn't for us our moms wouldn't even get to celebrate mother's day so shouldn't they be thanking us hmph
10:56:19 <Welkin> https://www.haskell.org/cabal/users-guide/nix-local-build.html#specifying-the-local-packages
10:56:29 <kuribas> since when is cabal off-topic?
10:56:58 <Welkin> someone might want to update the cabal user guide
10:57:01 <Welkin> it is out of date
10:57:11 <cocreature> how about you :)
10:57:11 <DigitalKiwi> kuribas it's a joke, people are being offtopic here and in -offtopic asking about ontopic stuff
10:57:13 <Welkin> new-run now works, but it says it doesn't
10:57:27 <kuribas> DigitalKiwi: right :)
10:57:30 <dminuoso> DigitalKiwi: You mean people being offtopic in -offtopic
10:57:33 <Welkin> cocreature: I don't know how
10:57:39 <Clint> learn
10:57:48 <DigitalKiwi> dminuoso hmm, paradox
10:58:21 <Welkin> zeno?
10:59:12 <iqubic> Zeyes?
10:59:58 <cocreature> Welkin: the user guide is in the repo https://github.com/haskell/cabal/tree/master/Cabal/doc although it looks like that specific thing has already been update
11:00:19 <Welkin> the user guide says version 2.0
11:00:36 <cocreature> yeah makes sense, 2.0 didn’t have new-run
11:00:44 <Welkin> someone needs to push an update then
11:01:08 <iqubic> What is the current cabal version.
11:01:28 <Welkin> 2.2.0.1
11:01:30 <Welkin> or higher
11:01:59 <Welkin> yeah 2.2.0.1
11:03:37 <biglambda> This blankety blank just restored my faith in haskell.
11:06:02 <Welkin> ?
11:06:15 <iqubic> \n
11:06:34 <iqubic> \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
11:06:44 <iqubic> that blankety blank.
11:07:25 <Welkin> well, time for holiday festivities
11:08:03 <dminuoso> Is there some way to prevent someone from making a particular instance of a class for my type?
11:08:05 <biglambda> It’s a build tool option that has the word new in it
11:08:15 <biglambda> But apparently it’s off topic :)
11:08:30 <dminuoso> I have a Secret newtype wrapper and want to lightly enforce that someone doesn't do some standalone deriving `Show`
11:09:04 <iqubic> Just write your own Show instance that does nothing.
11:09:26 <neongreen> dminuoso: I think that if you don't export the constructor, they won't be able to derive any instances
11:09:43 <iqubic> "Can't derive an instance that already exists." Don't quote me on that.
11:10:16 <DigitalKiwi> 	'"Can't derive an instance that already exists." Don't quote me on that.' -- iqubic
11:10:44 <iqubic> Darn you.
11:11:30 <Guest89713> make sure you don't derive generic then, either
11:12:40 <dminuoso> neongreen: Ah great. :)
11:12:56 <iqubic> Guest89713: Why is that bad?
11:13:25 <dminuoso> neongreen: I probably cant prevent someone from making an instance altogether, can I?
11:14:34 <Guest89713> it lets users introspect into a type (at least, GHC's representation of it)
11:15:01 <Guest89713> not sure if that's true if you don't export the constructor though
11:15:01 <dminuoso> Though I suppose if I completely hide the internal type of Secret, then it becomes a lot harder to anything meaningful with it.
11:15:16 <dminuoso> If I dont even export an unSecret, then someone cant accidentally leak it into some log
11:15:38 <iqubic> Just export some helpful constructors and utility functions. That's all you really need.
11:21:16 <iqubic> What is Secret used for?
11:24:44 <iqubic> If I foldr a list that's the same as reversing it and running foldl, right?
11:27:33 <cocreature> iqubic: good luck reversing an infinite list :)
11:27:41 <hpc> @check \f z list -> foldr f z list == reverse (foldl f z (reverse list))
11:27:42 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 2 shrinks):
11:27:43 <lambdabot>  <[()] -> [()] -> [()]> [(),()] [[()],[()]]
11:28:13 <iqubic> What?!?!
11:28:35 <hpc> what indeed
11:28:39 <iqubic> What is the error?
11:28:55 <hpc> not sure
11:29:14 <Tuplanolla> You forgot to flip `f`.
11:29:19 <hpc> Tuplanolla: ooooh
11:29:29 <iqubic> Why do you need flip f?
11:30:05 <cocreature> hm I’m not sure how to parse that counterexample
11:30:37 <biglambda> Keep getting stuck on this: cabal: Failed to build documentation for fail-4.9.0.0 (which is required by
11:30:37 <biglambda> exe:
11:30:56 <cocreature> biglambda: it’s a known bug
11:31:11 <biglambda> Tried —disable-documentation doesn’t have an effect
11:31:34 <cocreature> maybe try (temporarily) disabling it in your ~/.cabal/config
11:31:46 <cocreature> the problem is that "fail" doesn’t have any modules
11:32:01 <cocreature> well that’s one problem. the other is that new-build treats haddock failures as fatal errors
11:32:43 <iqubic> Unit is Bottom, right?
11:33:12 <cocreature> no
11:33:22 <cocreature> Unit is ()
11:34:10 <biglambda> cocreature: looks like that worked
11:35:07 <Albtrz[m]> iqubic: bottom is undefined
11:37:02 <iqubic> So what is up with the quickcheck error?
11:38:51 <infinisil> @check \f z list -> foldr f z list == reverse (foldl (flip f) z (reverse list))
11:38:53 <lambdabot>  +++ OK, passed 100 tests.
11:39:11 <dminuoso> Albtrz[m]: not quite. bottom is rather the value of a computation that doesn't complete correctly
11:39:24 <cocreature> infinisil: QuickCheck clearly need to produce infinite lists!
11:39:48 <dmwit> ?quickcheck \f -> f () /= () -- how are functions printed?
11:39:48 <lambdabot> Unknown command, try @list
11:39:52 <infinisil> Totally!
11:39:52 <dmwit> ?check \f -> f () /= () -- how are functions printed?
11:39:54 <lambdabot>  <hint>:1:69: error:
11:39:56 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
11:40:26 <cocreature> @check \f -> f () /= ()
11:40:28 <lambdabot>  *** Failed! Falsifiable (after 1 test):
11:40:28 <lambdabot>  <() -> ()>
11:40:34 <iqubic> Huh?
11:40:37 <cocreature> ^ dmwit
11:40:45 <dmwit> Not a very informative way to print functions, I have to say.
11:40:50 <cocreature> yep
11:41:11 <iqubic> @check \f -> f () = f ()
11:41:11 <lambdabot>  <unknown>.hs:1:12:Parse error: =
11:41:11 <dmwit> But at least I can now read the counterexample found above for the previous thing (what information is available in it, anyway).
11:41:27 <iqubic> @check \f -> f () == f ()
11:41:29 <lambdabot>  +++ OK, passed 100 tests.
11:41:44 <iqubic> I wonder what 100 tests were tried.
11:42:00 <dmwit> `\() -> ()`, 100 times =)
11:42:33 <iqubic> ;) LOL
11:43:25 <iqubic> So what is the previous counter example to the folding thing?
11:43:39 <iqubic> :t flip id
11:43:40 <lambdabot> b -> (b -> c) -> c
11:43:46 <iqubic> :t ($)
11:43:47 <lambdabot> (a -> b) -> a -> b
11:44:06 <iqubic> :t flip (flip id) -- same type as $
11:44:07 <lambdabot> (b -> c) -> b -> c
11:44:33 <infinisil> iqubic: You can PM lambdabot to not spam this channel
11:44:33 <iqubic> :t flip . flip id
11:44:34 <lambdabot> b1 -> b2 -> (b1 -> b2 -> c) -> c
11:44:38 <iqubic> I will.
11:44:53 <iqubic> Why is that last one different?
11:45:18 <iqubic> flip (flip id) isn't flip . flip id?
11:45:35 <iqubic> No it's flip $ flip id.
11:45:47 <iqubic> Which has the same type as ($)
11:45:49 <iqubic> Odd.
11:46:18 <dminuoso> iqubic: It's not really. =)
11:46:31 * hackage animate-preview 0.1.1 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.1.1 (jxv)
11:48:16 <biglambda> new-build also seems to ignore extra-include-dirs
11:48:58 <dminuoso> iqubic: One interesting way to think about it, is that `id` _can_ be ($)
11:48:59 <cocreature> biglambda: iirc the problem is that it somehow applies it to the wrong thing. if you specify it explicitely for a package in cabal.project/cabal.project.local it works
11:49:16 <dminuoso> > length `id` [1,2]
11:49:18 <lambdabot>  2
11:49:31 <biglambda> I see. What’s the syntax to specify for a specific package?
11:50:42 <cocreature> biglambda: https://cabal.readthedocs.io/en/latest/nix-local-build.html#package-configuration-options
11:53:19 <biglambda> That works, thanks.
11:54:52 <dminuoso> iqubic: `flip . flip id` has that shape for the same reason why `flip id` looks a bit funky at first glance. Remember that you are working with polymorphic types. `forall a. ... a`, a might be a function itself.
12:03:45 <cocreature> if I have two functions "f" and "g" in a module with "f" calling "g" and only "f" is exported. does it make sense to put an INLINABLE pragma on "g" so that the definition of "g" is available when "f" is specialized/inlined?
12:06:26 <cocreature> Productivity: 25.7% well that’s not good is it …
12:11:34 <EvanR> if i have intervals of integers that dont overlap as keys, is there a slick map structure for this i am missing
12:11:50 <EvanR> lookup, update by point that is within the interval
12:12:51 <dpyro> is there some automagic way that monads are handled that allows you to elide them as a parameter?
12:12:58 <monochrom> Yes look for "interval trees".
12:13:28 <EvanR> i saw that... is it overkill for non-continuous, non-overlapping
12:13:35 <[exa]> interval trees have overhead for overlap
12:13:43 <dminuoso> dpyro: what does "elite them as a parameter" mean?
12:13:43 <monochrom> Oh, disjoint.
12:13:50 <dpyro> :t getOrderbook: ParadexPublicClient -> Market -> ClientM ParadexOrderbook in one context but is Market -> ClientM ParadexOrderbook in another
12:13:52 <lambdabot> error: parse error on input ‘->’
12:13:56 <[exa]> normal ordered tree with a slightly wrapped search function should work
12:14:17 <cocreature> dpyro: I don’t understand the question. what exactly are you hoping to do with those functions?
12:14:25 <EvanR> can you somehow use Data.Map machinery to do that
12:14:37 <dpyro> let me try and conjure up a code snippet
12:18:12 <dpyro> cocreature: https://pastebin.com/skbzxaNh
12:18:19 <dpyro> hopefully that shows what i'm trying to understand
12:20:16 <cocreature> dpyro: can’t you just apply getNonce to  a client before you pass it to clientTest?
12:20:58 <dpyro> yes, but in this case there is no explicit ParadexPublicClient that i know of
12:21:18 <cocreature> you already seem to have made one in line 7?
12:21:50 <dpyro> well in that case there's getNonce and other stuff created from the {..} expansion
12:21:56 <dpyro> but i don't think there is an entire client
12:22:15 <dpyro> it seems to be applied automagically using that expansion
12:22:22 <Boraders> I have a haskell project with only the dependency diagrams >= 1.4 and it fails to build under cabal new-build with error:
12:22:27 <cocreature> dpyro: ah now I get it
12:22:32 <Boraders> cabal: Failed to build documentation for fail-4.9.0.0
12:22:36 <dpyro> maybe something is being shadowed
12:22:39 <Boraders> any ideas what to do about that?
12:22:39 <dpyro> so it looks magical
12:22:41 <cocreature> dpyro: there are two different things that are both called getNonce
12:22:46 <cocreature> dpyro: one is the record selector
12:22:48 <dpyro> yes that's my suspicion
12:22:56 <cocreature> that has the type you showed
12:23:08 <cocreature> the other is introduced via record wildcards
12:23:16 <cocreature> and has type ClientM ParadexNonce
12:23:32 <cocreature> dpyro: if you use a typed hole it will show you the type of the variables in scope
12:23:39 <cocreature> Boraders: temporarily disable docs
12:24:06 <dpyro> type hole?
12:24:12 <dpyro> *typed hole?
12:24:14 <Boraders> cocreature: do you know the command for it?
12:24:29 <cocreature> Boraders: it’s disabled by default so you probably enabled it in ~/.cabal/config
12:24:44 <Boraders> thanks
12:25:00 <cocreature> dpyro: you can place an _ where GHC expects a term and it will tell you the type of the thing it would like to have there
12:25:12 <cocreature> and also the type of variables that are in scope
12:25:51 <dpyro> oo, is that a debugging feature mostly?
12:26:20 <cocreature> well your code won’t compile unless you replace it my something else, so yeah :)
12:26:34 <cocreature> but it’s extremely useful. I often start with something like f = _ and then gradually refine it
12:26:40 <cocreature> until there are no more holes left
12:27:35 <dpyro> ok, thanks, i will try that! at least i now know why it appears automagical
12:34:37 <daukadolt> wowzers
12:37:53 <nha__> how can i install a package that cant resolve dependency problems (i have a clean install of haskell platform)
12:38:02 <nha__> i tried cabal sandbox but it doesnt work
12:38:09 <nha__> im trying to install gitit
12:38:12 <cocreature> nha__: can you show us the full error message?
12:38:29 <nha__> (conflict:
12:38:29 <nha__> binary==0.8.5.1/installed-0.8..., pandoc => binary>=0.5 && <0.8)
12:38:30 <nha__> Backjump limit reached (currently 2000, change with --max-backjumps or try to
12:40:24 <cocreature> sounds like you’re trying to use a fairly old version of pandoc
12:40:39 <hvr> cocreature: actually I think the culprit is filestore
12:41:24 <hvr> it's got a pointless custom Setup.hs
12:42:02 <cocreature> hvr: huh? filestore doesn’t seem to depend on either binary or pandoc
12:42:11 <hvr> cocreature: it's a transitive dep of gitit
12:42:18 * hackage plot-light-examples 0.3.0.0 - Example binaries for plot-light  http://hackage.haskell.org/package/plot-light-examples-0.3.0.0 (ocramz)
12:42:23 <cocreature> ah ok
12:42:34 <hvr> cocreature: and one you'd run into sooner or later
12:42:44 <hvr> cocreature: I was trying with new-install
12:46:14 <humpmydumpy> exactly why on earth would one use a lang like erlang which embraces errors instead of a lang like haskell which embraces upfront correctness? i'm really not seeing erlang's use case over haskell
12:46:44 <int-e> nha__: hmm maybe cabal install --allow-newer=time gitit (in a sandbox... not sure that it'll work, but at least it finds a sane install plan)
12:47:34 <int-e> (hmm, that's with ghc-8.2.2)
12:49:02 <nha__> int-e: getting the same error with that - on ghc 8.4.2
12:53:03 * hackage haskey 0.3.0.2 - A transactional, ACID compliant, embeddable key-value store.  http://hackage.haskell.org/package/haskey-0.3.0.2 (hverr)
12:53:40 <int-e> @where paste
12:53:41 <lambdabot> Haskell pastebin: http://lpaste.net/
12:53:44 <EvanR> humpmydumpy: prudence
12:53:59 <int-e> hmm, what happened to lpaste?
12:54:05 <EvanR> RIP
12:54:14 <humpmydumpy> EvanR: can you explain more?
12:54:26 <Clint> time to bring back hpaste
12:54:35 <EvanR> generally theres an unbounded cost to being correct upfront
12:54:57 <tdammers> you'd think that "pastebin clone that works" would be a solved problem by now
12:55:05 <EvanR> haskell identified many specific places where the cost is low to be correct
12:55:16 <int-e> nha__: http://paste.debian.net/1024531/ .. the other idea I have is that it's a different cabal-install version
12:56:55 <nha__> yea my cabal-install is 2.2
12:57:58 <int-e> (which I'm building right now... taking a while)
12:58:30 <nha__> thanks for taking the time
12:58:52 <hvr> ok, I see what the problem is
12:59:21 <int-e> nha__: wait a second... this is still ghc-8.2.2, my bad
13:00:03 * hackage haskey-mtl 0.3.0.1 - A monad transformer supporting Haskey transactions.  http://hackage.haskell.org/package/haskey-mtl-0.3.0.1 (hverr)
13:01:49 * hackage th-lift 0.7.9 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.7.9 (MathieuBoespflug)
13:02:59 <reactormonk> Do the type variables in constrains play any matter if a functional dependency can be determined or not?
13:03:16 <hvr> nha__: well, you *could* try with --allow-newer=haddock-library:base
13:03:42 <hvr> that should be able to find an install-plan
13:04:11 <nha__> yea it found an install plan
13:04:14 <nha__> lets see how it pans out
13:04:36 <enterprisey> @pl \x -> (fst x, fst (snd x), snd (snd x))
13:04:36 <lambdabot> ap (liftM2 (,,) fst (fst . snd)) (snd . snd)
13:07:06 <hvr> nha__: I'm afraid you'll run into a compile failure, e.g. in blaze-markup-0.7.1.1
13:07:29 * hvr mumbles something about missing upper bounds
13:17:41 <nha__> yea failed on skylighting-0.1.1.5
13:18:15 <Clint> gitit is undermaintained
13:20:21 <Mitsos101> Hello everyone! How can I implement an immutable array of Ints, where the only operations supported are (!) and listArray? I've looked at the Data.Array implementation, but I'm not sure if I need everything in there.
13:21:11 <infinisil> :t listArray
13:21:12 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
13:25:44 <dmj`> Mitsos101: you could newtype it
13:29:08 <Mitsos101> dmj`: I want to implement it myself
13:29:43 * hackage indexed-list-literals 0.2.1.0 - Type safe indexed list literals  http://hackage.haskell.org/package/indexed-list-literals-0.2.1.0 (DavidMD)
13:31:47 <EvanR> lets see what the most primitive array thingie there is is... other than ByteArray#
13:33:32 <EvanR> ok so theres Array#
13:33:37 <dmj`> Mitsos101: vector uses Data.Primitive.Array
13:36:14 <EvanR> but if you want an array of unboxed ints... seems like the libs went with ByteArray#
13:44:35 <nha__> i love how every software related to the web has a million dependencies
13:45:17 <EvanR> the web must be a huge pile of solved problems
13:47:53 <geekosaur> it is. pity that every solved problems spawns 3-4 new unsolved ones >.>
13:48:54 <humpmydumpy> is time to replace ghc with some fresher, something better?
13:49:12 * hackage web3 0.7.2.0 - Ethereum API for Haskell  http://hackage.haskell.org/package/web3-0.7.2.0 (akru)
13:49:23 <dmj`> nha__: yea, most serious web projects end up being over 1MB in size, makes ghcjs more appealing. uber.com’s homepage is over 1MB.
13:49:29 <geekosaur> something newer but more broken, js style?
13:49:46 <geekosaur> "but it's newer, must be better"
13:50:19 <EvanR> just use better compression
13:50:49 <EvanR> nasa funding research to determine how to compress two bits into one
13:51:28 <nha__> the complexity is more of an issue than storage size
13:52:44 <humpmydumpy> geekosaur assuming ppl capable of implementing a new hs compiler are comparable to erratic js devs. the disrespect
13:53:28 <geekosaur> it's the "this is old, must trash it and start over with newerthereforebetter" mentality that is the problem here, not js devs
13:54:08 <geekosaur> you're basically demonstrating where my snark about every solved problem spawning 3 new unsolved ones came from
13:57:48 <humpmydumpy> sometimes newerthereforebetter is very much true. i have no idea or opinion on if it's time to replace ghc. hence the question.
13:59:20 <geekosaur> also, you're making an implicit assumption that replacing ghc is somehow simple
13:59:32 <geekosaur> you might go look at the history of haskell compilers over the past decade
14:00:53 <dminuoso> EvanR: I have devised such a strategy. Just forget about one bit, and guess it when you need it. I guarantee it's 50% correct of the time.
14:02:46 <humpmydumpy> geekosaur: so, you essentially have no answer to the question and only took away from it an incorrectly perceived assumption
14:03:02 <geekosaur> humpmydumpy, I suppose that is what you;d take away from it]
14:05:23 <geekosaur> your question combines "I don't know what I'm talking about" and "I want a new toy and everyone else should be honored to give me one"
14:06:28 <Gobert> having issues with my types
14:06:33 <Gobert> `  NB: ‘Text’ is defined in ‘Data.Text.Internal’           ‘Data.Text.Internal.Lazy.Text’             is defined in ‘Data.Text.Internal.Lazy’       Expected type: IO Text         Actual type: IO Data.Text.Internal.Lazy.Text`
14:06:40 <Gobert> `  NB: ‘Text’ is defined in ‘Data.Text.Internal’           ‘Data.Text.Internal.Lazy.Text’             is defined in ‘Data.Text.Internal.Lazy’       Expected type: IO Text         Actual type: IO Data.Text.Internal.Lazy.Text`
14:07:02 <infinisil> humpmydumpy: Maybe have a look at Idris
14:07:21 <Gobert> when I used `Text` as a type GHC complains its in Data.Text.Internal.Lazy.Text
14:07:49 <humpmydumpy> geekosaur: haha, no, it does not. you've incorrectly assumed a great deal from a simple question
14:07:58 <johnw> Gobert: you're using a strict Text where you need a lazy, or vice versa
14:08:02 <geekosaur> that was no simple question
14:08:07 <humpmydumpy> it was
14:08:09 <geekosaur> no
14:08:32 <geekosaur> it's simple if you are around age 5
14:08:32 <monochrom> Evidently the correct respond is to look away and not respond at all.
14:10:00 <dminuoso> Why is the either package not part of mtl? What's the relationship with ExceptT that is part of mtl?
14:10:27 <monochrom> I am not so convinced about "age 5" but my perspective is that in the only sense of armchair philosophy it is simple to wonder idly "is it time to replace GHC?", "is it time to just kill half of the population to solve over-population problems?"
14:11:48 <nha__> gitit is quite nice
14:12:02 <nha__> (was faster to just install previous haskell platform)
14:12:03 <monochrom> We don't have a code of conduct for this channel (and I support keeping it that way) but if there is one I would like to add this clause "armchair philosophy is strictly banned".
14:12:04 <mrm> monochrom: Thanos did nothing wrong.
14:12:15 <dminuoso> I mean why do I have to stare at ErrorT, EitherT and ExceptT when they all seem to be Either transformers..
14:12:16 <EvanR> i was seriously wondering what RNG thanos was using for that
14:12:40 <EvanR> was it cryptosecure
14:12:44 <EvanR> spoiler alerts
14:12:54 <mrm> I don't feel so good...
14:12:57 <johnw> nha__: are there any sites using gitit I could check out?
14:14:05 <sm> hey there johnw
14:14:10 <sm> http://darcs.net uses it
14:14:20 <nha__> johnw: no clue but i tried, cliki2 (common lisp), and gollum (ruby), and gitit seems much nicer
14:21:36 <johnw> sm: cool, how do you like it?
14:22:11 <EvanR> what is EitherT
14:22:53 <dminuoso> https://hackage.haskell.org/package/either-4.4.1.1/docs/Control-Monad-Trans-Either.html
14:23:23 <sm> johnw: I haven't used it seriously myself but it looked pretty good. I think it has no community but it is maintained
14:23:40 <EvanR> dminuoso: whats funny is... thats an old version
14:23:51 <EvanR> the new version is not that
14:24:05 <dminuoso> What the
14:24:07 <EvanR> deprecado
14:24:18 <EvanR> it also has way fewer dependencies
14:24:19 <dminuoso> Gah. What is going on here. :|
14:24:42 <dminuoso> EvanR: Yeah but then there should be a `maybe` package too, shouldn't it?
14:24:48 <EvanR> i feel like at some point people said EitherT is out and ExceptT is in
14:25:09 <EvanR> luckily i had never paid much attention to EitherT
14:25:33 <dminuoso> EvanR: From what I can tell the name ExceptT is a transformers thing, but why does mtl carry that over? For compatibility?
14:25:49 <EvanR> also the ErrorT documentation said that IT is deprecated
14:26:55 <EvanR> so ExceptT seems to be the last transformer left standing at the end of highlander... 2 ... or something
14:27:19 <dminuoso> EvanR: Aha.. so it seems like the EitherT _is_ ExceptT.
14:27:26 <aarvar> but with the right name
14:28:03 <dminuoso> Staring at the versions it seems as if the `EitherT` from the `either` package got moved into mtl (with a rename)
14:28:59 * sm corrects his last remark: slightly maintained
14:29:39 <sm> someone should modernise gitit
14:30:12 <EvanR> `either' is an entirely different package now
14:30:17 <EvanR> get with the program
14:30:38 <EvanR> silly people thinking project names should continue to refer to the same thing
14:31:00 <EvanR> also a random blog post says ExceptT is god, so there
14:32:16 <shmendrik> i have this data type: data MessageTree = Leaf
14:32:16 <shmendrik> | Node MessageTree LogMessage MessageTree ;;; and this text is not fully understood to me. please explain me: A MessageTree should be sorted by timestamp: that is, the timestamp of a LogMessage in any Node should be greater than all timestamps of any LogMessage in the left subtree, and less than all timestamps
14:32:16 <shmendrik> of any LogMessage in the right child.
14:33:04 <johnw> sm: it seems like gitit is exactly the sort of thing UR/Web would be great for
14:33:05 <lemmih> shmendrik: Do you understand the Haskell code?
14:33:18 <shmendrik> yes lemmih
14:33:32 <shmendrik> i just dont understand exactly what it is saying.
14:33:46 <sm> johnw: maybe! but you'd be giving up useful tech like pandoc
14:34:04 <johnw> sm: or convience Adam to create a module for talking to a subprocess
14:34:06 <shmendrik> ido i need to sort it that the left tree will be bugeer numbers and the right tree with small numbers?
14:34:35 <EvanR> seems like you should keep it sorted every time you insert a message
14:34:36 <shmendrik> and the most right is with the lowest number and the most left with the biggest one?
14:34:54 <shmendrik> EvanR: yes this i understand
14:34:55 <EvanR> dont build the tree out of order
14:35:01 <lemmih> shmendrik: Other way around.
14:35:35 <lemmih> shmendrik: left subtree < this node < right subtree.
14:35:40 * sm checks out the sonic2 progress at https://www.twitch.tv/puffnfresh
14:37:59 <shmendrik> lemmih: thanks and of course the the subtrees themselves must be in order?
14:38:54 <lemmih> shmendrik: Yes. Never construct a MessageTree that is out of order.
14:39:03 <naudiz> #join cpp
14:39:07 <shmendrik> lemmih: great thanks!
14:39:07 <naudiz> oops
15:01:05 <DigitalKiwi> you know I want to be pissed at people on imgur especially but people likes you too giving spoilers about infinity war but if it wasn't for that I wouldn't have watched it already...but yeah the choice of watch it as soon as possible or risk seeing spoilers everywhere isn't cool :| </rant>
15:04:46 <mrm> wot m8?
15:05:00 <DigitalKiwi> meh nothing
15:06:19 <DigitalKiwi> https://www.xkcd.com/109/
15:07:01 <DigitalKiwi> also relevant https://www.xkcd.com/1053/
15:14:03 <DigitalKiwi> like someone got pissed at me in high school for "ruining" citizen kane (1941) for them, and people got mad at martin freeman for saying bilbo outlives smaug in the hobbit (1937) which shouldn't be much of a surprise anyway...
15:16:02 <monochrom> I like spoilers because... wait why is this in #haskell? :D
15:16:15 <johnw> because once spoiled, you can't exit?
15:16:18 <DigitalKiwi> because people were posting spoilers
15:16:45 <hpc> spoiler alert: theorems for free ends with theorems
15:16:50 <hvr> that's like applying rnf on a plot
15:17:11 <monochrom> haha hvr
15:23:29 <DigitalKiwi> There's a slight difference between something released 75 years ago and something that hasn't even been out a month in theaters with regard to how much expectation there is on avoiding spoilers, but as the ten thousand comic illustrates some people still haven't seen something just because everyone else has. Like I've only read 5 of the HP books and haven't seen most of the movies but I don't expect people to not spoil it ya know, but
15:23:29 <DigitalKiwi>  people my age have kids that haven't seen it yet ya dig? k, supper time
15:23:53 <monochrom> DigitalKiwi: Please move this elsewhere.
15:25:04 <nh> lets invest in old computers
15:25:12 <nh> wrong channel
15:29:47 <EvanR> way ahead of you
15:29:58 <EvanR> vintage 2011 macbook air
15:30:39 <DigitalKiwi> jesus fucking christ sorry I was done I'll fuck off then
15:32:23 <EvanR> so i implemented a virtual machine complete with stack, interrupts, memory mapping, a machine language, and debugger
15:33:02 <EvanR> writing code for it in ascii machine code is painful
15:33:10 <EvanR> its also super slow
15:33:24 <EvanR> should i write the compiler to x86-64 or the compiler from haskell to it
15:35:45 <EvanR> or persist in isolation
15:55:19 * hackage streamly 0.2.0 - Beautiful Streaming, Concurrent and Reactive Composition  http://hackage.haskell.org/package/streamly-0.2.0 (harendra)
16:01:13 * hackage fast-arithmetic 0.6.0.4, gmpint 0.1.0.13 (vmchale): https://qbin.io/cams-voting-997f
16:16:13 * hackage fast-arithmetic 0.6.0.5 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.0.5 (vmchale)
16:18:13 * hackage hailgun 0.4.1.8 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.4.1.8 (cdepillabout)
16:26:42 * hackage continued-fraction 0.1.0.10 - Types and functions for working with continued fractions in Haskell  http://hackage.haskell.org/package/continued-fraction-0.1.0.10 (vmchale)
16:28:43 * hackage hasktags 0.70.0 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.70.0 (jhenahan)
16:30:03 <suzu> EvanR: make the VM JIT
16:35:42 * hackage animate-preview 0.1.2 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.1.2 (jxv)
16:38:42 * hackage animate-preview 0.1.2.1 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.1.2.1 (jxv)
16:39:52 <zezeri> Hello :)
16:40:41 <suzu> hlo
16:41:34 <zezeri> https://pastebin.com/JfpJqrsN
16:41:40 <zezeri> any idea anyone :D?
16:42:45 <Cale> btw, your list appends are going to take quadratic time in n
16:43:01 <Cale> xs ++ ys takes O(length xs) steps to fully evaluate
16:43:46 <zezeri> So I should not use (++)
16:43:46 <zezeri> `?
16:43:48 <Cale> and so if you keep doing this, you're going to spend 1 + ... + (n-1) = n(n-1)/2 time doing appends
16:43:54 <Cale> You shouldn't append to the end of a list
16:44:09 <zezeri> oh
16:44:15 <zezeri> so if i do x:xs then it is very cheap?
16:44:19 <Cale> yeah
16:44:21 <zezeri> or if i do [x] ++ xs
16:44:25 <Cale> yeah
16:44:33 <zezeri> ok, thank you for the hint.
16:45:01 <zezeri> I did it like this because i wanted to have the smaller fibbonaci values first
16:45:06 <Cale> You should be able to define it recursively in such a way that the tail of the list is produced by the recursive function application
16:45:42 <Cale> You could of course just take your slow fib, and map it over an appropriate list as well
16:46:06 <Cale> nfib m = map fib [0 .. m-1]
16:46:21 <zezeri> what you say wrt map makes a lot of sense. Have not yet used map at all
16:46:30 <zezeri> so much to learn
16:47:28 <Cale> But a better way would be to generalise a little bit: define a function lucas n a b which gives the first n terms of a Fibonacci-like sequence which starts with the values a and b rather than 0 and 1
16:47:36 <zezeri> i mean could always do sth like take n infiniteFibList
16:47:59 <Cale> and then you can define nfib n = lucas n 0 1
16:48:18 <Cale> (Such sequences are called Lucas sequences, hence my choice of name)
16:48:26 <zezeri> that sounds smart
16:48:27 <zezeri> :D
16:48:49 <Cale> You'll find it's easier to make the recursion work
16:49:07 <Cale> (In fact, easy enough that it'll be obvious how to make an infinite Fibonacci sequence as well)
16:49:40 <zezeri> so I guess the only way to make it work is to do it in a totally different way
16:49:43 <zezeri> i suspected that
16:49:59 <zezeri> i guess its good that i didnt overlook sth
16:50:02 <zezeri> thank you!
16:50:25 <Cale> Well, you could also change your base case I suppose.
16:51:11 <Cale> Like, if you wanted a minimal change to your existing code, just change the recursive case to add on [fib (m-1)] instead of [fib m]
16:51:22 <Cale> and then make the base case nfib 0 = []
16:51:56 <zezeri> this worked perfectly
16:51:59 <zezeri> urgh why did not see this
16:52:04 <zezeri> thank you again.
16:53:13 <zezeri> omg
16:53:23 <zezeri> i think it was because i put fib m-1 instead of fib (m-1)
16:53:23 <zezeri> mfw.
16:54:19 <Cale> yeah, that's (fib m) - 1
16:54:33 <Cale> Function application always binds more tightly than any infix operator
16:54:49 <zezeri> yes, makes sense
16:54:57 <zezeri> i have to say this irc is excellent
16:55:10 <zezeri> you guys have helped me with literally every single of my issues so far :D
16:55:51 <Cale> Cheers! Hopefully some day you'll be able to pay it forward too :D
16:56:32 <zezeri> I hope so - i have to admit that i find it extremely taxing to learn haskell so far though and ive only so far sratched the surface.
16:56:54 <zezeri> to my problem there are like 10 more elegant solutions and im already kind of proud about having found this trivial one.
16:57:40 <Cale> It took me something like 2 months to feel like I could do real work in Haskell, and about a year to be comfortable, if that means anything.
16:58:30 <hpc> same
16:58:36 <Cale> Everyone's a bit different of course, but it does take some time rewiring your brain if you're used to programming in another way.
16:58:41 <hpc> it was like learning programming for the first time all over again
17:00:35 <zezeri> makes sense, i guess
17:00:45 <zezeri> i hope i can start doing sth useful-ish in the near-mid term
17:00:56 <zezeri> but lack the skills still.
17:01:14 <zezeri> its hard to motivate myself to keep grinding these small problems without seeing anything grow or building anything
17:01:34 <zezeri> that part was a bit easier with C/C++
17:02:02 <zezeri> I do wonder what most ppl here use haskell for
17:03:01 <Cale> I work for Obsidian Systems developing primarily web and mobile applications in Haskell
17:03:42 <Cale> We use it both for our (HTTP/websocket server) backends, and for our frontends.
17:04:50 <Cale> For the web, we compile Haskell to Javascript which controls the DOM using GHCJS (and we use the Reflex functional reactive programming system with reflex-dom to manage the contents of the DOM)
17:05:13 * hackage word 0.1.0.1 - Words of arbitrary size  http://hackage.haskell.org/package/word-0.1.0.1 (MatthewFarkasDyck)
17:05:28 <Cale> For mobile, we take what is pretty much the same code, and compile it to native ARM code that interacts with a webview object.
17:05:37 <zezeri> Interesting!
17:05:39 <Clint> o_O
17:06:04 <Cale> (That mostly happens automatically via ghcjs-dom and jsaddle)
17:07:18 <zezeri> I hope I can somehow find some smaller personal projects i can do.
17:07:32 <Cale> But you can use Haskell for almost anything that's not too stringently memory-constrained. Like, you probably don't want to try compiling Haskell to run on really tiny microcontrollers, but you might use it as a metalanguage to generate C code for them.
17:07:45 <zezeri> mhmm interesting point
17:08:18 <Cale> (and some people have done just that in order to avoid the need for a realtime operating system)
17:09:42 * hackage text-utf8 1.2.3.0 - An efficient packed UTF-8 backed Unicode text type.  http://hackage.haskell.org/package/text-utf8-1.2.3.0 (HerbertValerioRiedel)
17:10:07 <Cale> Right now, I'm working on a Reflex-DOM SVG backend for the "Chart" library, which I'll then use to put some nice graphs into a client application.
17:11:32 <zezeri> interesting
17:12:37 <Cale> (It already has some other backends I could use... and might if I run out of time, but I'd prefer something that goes more directly to constructing DOM)
17:21:47 <zezeri> i wonder if using haskell with time becomes less mentally taxing :D
17:23:19 <phadej> zezeri: it does
17:27:06 <phadej> think about that as that with Haskell you can but unfortunately have to climb higher, but with some other tools you cannot even reach such higher grounds
17:27:23 <phadej> (higher, and maybe steeper)
17:28:18 <phadej> Having a human guide would help, I wonder how I managed to struggle though all beginner swamps
17:30:06 <zezeri> well this irc channel is like a human guide :D
17:30:12 <zezeri> or several actually
17:38:56 <phadej> we have different opinions on which routes are best :)
17:39:54 <zezeri> hahaha
17:39:56 <zezeri> fair
17:40:15 <zezeri> so far each route has led me to my destinaton though ;)
18:52:38 <jchia> Is there a variant of zip that expects both input lists to be the same length (errors if they are not). Yeah, I know it's a partial function, but it's better than a function that silently produces garbage.
18:53:16 <Cale> jchia: I don't have that, but I can offer you 'align' from the 'these' package
18:53:44 <Cale> jchia: data These a b = This a | That b | These a b
18:54:03 <Cale> align :: [a] -> [b] -> [These a b]
18:54:12 <Cale> (that's a specialisation, it's actually generalised to other functors)
18:57:20 <jchia> Cale: What does align do when the input list lengths are different?
18:57:34 <Cale> jchia: Gives a result having the length of the longer of the two lists
18:58:30 <jchia> Cale: What does it use to fill in the blanks?
18:58:37 <Cale> There will be some initial segment consisting of elements constructed with These, and then a tail of elements constructed with either This or That, depending on which list was longer
19:00:39 <jchia> Cale: OK. I need to reject cases where the input lists have unequal length.
19:01:37 <Cale> Yeah, it's not actually quite the solution to your problem
19:06:06 <infinisil> Here we go boys, compiling about a million haskell modules
19:06:40 <Axman6> hooray for parallel builds
19:07:27 <jchia> infinisil: What's the context?
19:08:07 <infinisil> Trying to update domenkozar's https://github.com/domenkozar/hie-nix
19:08:32 <byorgey> jchia, Cale: traverse justThese $ align as bs  ?
19:08:39 <byorgey> it even rhymes =)
19:08:44 <infinisil> Which has stack2nix as a dependency, and I'm trying to compile haskell-ide-engine for all 3 ghc versions (8.0, 8.2.2 and 8.4)
19:08:54 <infinisil> Both are pretty big projects
19:09:23 <byorgey> if you want it to error you can further compose with   fromMaybe (error "blah")
19:09:51 <infinisil> Well I guess there are always bigger projects
19:09:57 <infinisil> But I need to compile every dependency myself
19:10:13 <infinisil> Every haskell dependency*
19:11:25 <jchia> byorgey: Thanks. I think that's actually what I was looking for. The justThese is important.
19:12:21 <infinisil> Oh also I'm compiling wine along that, I hope my PC isn't on fire when I wake up
19:12:35 <jchia> infinisil: OK, I thought you managed to get GHC to compile a lot of modules in parallel.
19:12:44 <infinisil> Ah yeah no
19:24:16 <byorgey> infinisil: you might want to submerge it in liquid nitrogen before you go to bed, just in case
19:26:57 <infinisil> Eh it's fine
19:27:11 <infinisil> Even if my house went up in flames, i have git commit and pushed
19:27:41 <byorgey> oh, ok, no worries then
19:28:16 <byorgey> I'm always glad to see people taking fire safety seriously
19:28:26 <mniip> I have autocommit and push on smoke detectors
19:37:42 * hackage micro-recursion-schemes 5.0.2.2 - Simple recursion schemes  http://hackage.haskell.org/package/micro-recursion-schemes-5.0.2.2 (vmchale)
19:38:54 <infinisil> cat .git/hooks/prefire  =>  git commit && git push
19:39:06 <infinisil> Gotta love the hooks
19:49:42 * hackage language-ats 1.2.0.10 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.10 (vmchale)
19:59:12 <jchia> Lens question: Is there a more succinct way to write this, particularly to remove the repetition of 'view'? foo :: ((Int, Bool), (Char, Text)) -> (Bool, Char, Text); foo = (,,) <$> view (_1 . _2) <*> view (_2 . _1) <*> view (_2 . _2)
20:00:51 <glguy> No, and yes
20:01:22 <glguy> view (runGetter ((,,) <$> Getter (_1 . _2) <*> Getter (_2 . _1) <*> Getter (_2 . _2)))
20:02:57 <jchia> glguy: I suppose using lens I can't write something shorter than '(\((_, x), (y, z)) -> (x, y, z))'. I suppose using lens for this sort of thing is more suitable for large input tuples.
20:03:15 <glguy> That lambda's looking pretty good
20:03:50 <jchia> glguy: It's OK for small input tuple, but for large input tuple and small output, then I think the lens way is better.
20:04:04 <jchia> With large input tuple, the lambda will have a lot of underscores
20:04:08 <glguy> I think the lambda way is probably better in both cases
20:14:04 <abprof> Anyone made any cool games with haskell?
20:21:36 <dmj`> abprof: yea
20:22:06 <abprof> dmj': How'd you do it?
20:22:41 <dmj`> abprof: compile to js
20:22:47 <dmj`> abprof: http://2048.haskell-miso.org/
20:23:17 <dyl> Why do I do this to myself
20:23:30 <dyl> Just ate a steak drenched in really really hot sauce
20:23:35 <dyl> I’m sweating like a pig.
20:23:35 <abprof> dmj': I mean how did you architect it :)
20:24:02 <dmj`> abprof: oh, it depends on what you’re building I guess. What kind of game do you want to make.
20:24:57 <abprof> dmj': I'm thinking of a doodle jump clone
20:25:28 <abprof> but I want to make it in a fully scalable way
20:25:29 <dmj`> abprof: doodle jump is a very respectable game
20:26:03 <dmj`> abprof: it’s right up there with crossy road
20:27:04 <dmj`> abprof: so by scalable you want the full enchilada, rankings, database, mobile, etc.
20:27:42 <tian_> I find that I can use "f $ (x,y) = x" in ghci. What does it mean?
20:28:22 <abprof> dmj': haha no I don't want to do that much work. What I mean is I want to have a very decoupled architecture that would theoretically work for larger games
20:28:33 <tian_> Oh i know....
20:28:52 <tian_> define $ again ...
20:29:27 <dmj`> abprof: decoupled meaning your presentation logic is separate from IO logic?
20:31:07 <abprof> dmj': I mean that if I change the way one part of the game works it shouldn't affect the other parts of the game
20:31:46 <abprof> dmj': for example, an inheritance based architecture in OOP is more coupled than an entity system
20:32:30 <abprof> entity-component system*
20:33:50 <dmj`> abprof: https://mario.haskell-miso.org/ is similar to what would be used in doodle jump
20:34:06 <dmj`> abprof: here’s the code for it, https://github.com/dmjio/miso/blob/master/examples/mario/Main.hs
20:36:21 <dmj`> abprof: the code is very clean, the game state is completely decoupled from any kind of IO, or presentation logic.
20:38:32 <abprof> dmj': I'll check it out
20:43:00 <dmj`> abprof: if you do go ahead and make doodle jump, I’d just use SVG. Bet it would look great on mobile too.
20:44:59 <abprof> dmj': I'm not planning on distributing, just learning. I think I'll use reflex-sdl2. Trying to figure out some architecture for frp
20:48:05 <tian_> we can use `newtype` only if we can use `type`, can we say this?
20:48:55 <pavonia> No, type doesn't introduce a new data constructor
20:49:19 <dmj`> abprof: cool
20:52:25 <tian_> pavonia: they are both the alias, one is in code, the other is in compling
20:53:18 <tian_> pavonia: because newtype only has one ctor ans ctor only receives one type
20:53:29 <tian_> is this right?
20:54:32 <pavonia> Not sure I understand, the newtype constructor isn't present at runtime, AFAIK
20:56:21 <tian_> emmm, maybe i expressed not that properly...
20:56:37 <tian_> Thank you!
20:56:42 <mcbears> I think what they're asking is, is the declaration `newtype A = A B` only valid where `type A = B` would be valid
20:56:45 <mcbears> is that right?
21:00:18 <pavonia> type can also alias non-*-kinded types, I think newtype can't
21:00:48 <pavonia> i.e. `type T = IO' is okay while `newtype T = T IO' isn't
21:59:53 <iqubic> What is the point of using Continuations?
22:00:52 <johnw> iqubic: does that question have any more context?
22:01:08 <iqubic> No. I'm just learning about things for the sake of learning.
22:01:23 <glguy> Does your 2048 game work?
22:01:53 <iqubic> No. I guess I should focus on that instead of learning new things.
22:02:14 <johnw> iqubic: http://newartisans.com/2013/05/understanding-continuations/
22:02:42 <iqubic> Any future questions I have will be directed towards working on my 2048 games.
22:02:46 <johnw> note that continuations are deeply fundamental, moreso than they appear at first
22:03:01 <glguy> You'll learn more if you start writing programs, using the stuff you're learning will help you to develop a better understanding of things
22:04:13 <iqubic> glguy: I suppose that makes sense.
22:04:59 <glguy> Using the stuff you're trying to learn will also help guide you to learning new things that will help in the kinds of programs you're wanting to write
22:05:12 <iqubic> Yeah, that makes a lot of sense.
22:07:20 <iqubic> Instead of thinking "Thing x looks like an intersting thing to learn about, how can it be used in programs?" I should be thinking along the lines of "I want to do thing y, is there a good way to do that?" and let that guide my learning.
22:09:17 <iqubic> Like for example: I assume tuples/lists are the right way to return multiple values from a function
22:39:54 <atchoum> hello
22:40:19 <atchoum> https://stackoverflow.com/questions/2732197/level-order-in-haskell <- I am looking for writing a level order traversal of a binary tree in haskell (not homework but personal interest, I am a hobbyist).
22:40:26 <atchoum> I wrote a short function
22:41:14 <atchoum> http://vpaste.net/RAfGp <-
22:41:33 <iqubic> So you want a Breadth-First traversal?
22:41:43 <atchoum> but the complexity is not O(n). So What can one do to have a pure iterative version ?
22:42:02 <atchoum> iqubic: yes basically that's it but the academic term is « level order traversal » I think.
22:42:13 <iqubic> I see.
22:42:52 <atchoum> The whole algo is here btw http://vpaste.net/OvFF7
22:43:39 <atchoum> the problem is the descent algo
22:44:09 <atchoum> I don't want to use (++) operator, so I don't know exactly how to write it. Maybe with a monadic expression ? Or something like that ?
22:44:23 <atchoum> I don't see what is escaping me from writing a O(n) version.
22:45:13 <atchoum> it can be recursive, right ?
22:45:47 <atchoum> (map (:) foo) bar comes to mind also
22:54:55 <atchoum> what would be the equivalent of a while loop in haskell ?
22:55:10 <dminuoso> atchoum: recursion
22:55:12 <atchoum> while (not (null aList))
22:55:19 <HaskellLord69> :t while
22:55:20 <lambdabot> error: Variable not in scope: while
22:55:24 <HaskellLord69> :(
22:55:24 <atchoum> dminuoso: yes
22:55:29 <cocreature> what’s the option to suppress the "src<…>" stuff from -ddump-simpl?
22:55:55 <dminuoso> atchoum: Basically you think in terms of induction.
22:56:09 <dminuoso> atchoum: You recurse to proceed and you define a base case to terminate.
22:56:15 <atchoum> dminuoso: I am still trying this level order traversal without (++)
22:56:45 <aleator> atchoum: Why do you want to avoid ++?
22:57:05 <atchoum> because it's not good
22:57:13 <dminuoso> atchoum: Why is it not good?
22:57:27 <atchoum> It's O(m+n) operation
22:57:35 <aleator> atchoum: Eh? You mean that right associated, repeated ++ might be bad, right?
22:57:49 <atchoum> so if I use it in a O(n) algorithm my algo becomes O(n²)
22:57:57 <dminuoso> atchoum: look at the `shows` trick
22:58:02 <cocreature> ah -dsuppress-ticks
22:58:38 <aleator> atchoum: Wait.. given lists of length m and n, xm++xn is O(m), right? It never traverses the second lisxt
22:59:06 <atchoum> well ok but that's still O(n²)
22:59:30 <dminuoso> atchoum: Hence `shows` trick.
22:59:31 <dminuoso> atchoum: You also might want to look into ditching your list entirely
22:59:51 <atchoum> you mean that : https://stackoverflow.com/questions/9197913/what-is-the-shows-trick-in-haskell ?
23:00:27 <atchoum> dminuoso: yes, basically an iterative version would be probably simpler
23:00:44 <dminuoso> atchoum: what exactly are you trying to do?
23:01:06 <atchoum> see discussion above
23:01:48 <atchoum> gtg
23:06:37 <dminuoso> atchoum: Ah I just joined, didn't see the previous discussion.
23:13:09 <dminuoso> atchoum: There might be more condense solutions, but basically your code could be rewritten as: `f ts = ts >>= toList`
23:15:10 <aleator> I've got a somewhat nasty bit of code here: https://ipfs.io/ipfs/QmYbwzKAU7Wwscy8jKrKW3kE6B161B32SJwaN4uyFebT3g , anyone bother to take a look to see if I do something obviously wrong?
23:23:10 <atchoum> dminuoso: ok
23:23:53 <atchoum> seems hard to do at first sight, i need a function that map the values from a list of nodes
23:24:29 <dminuoso> atchoum: You just need an instance Foldable for your BinaryTree
23:25:20 <atchoum> ok, I need to implement the typeclass then
23:25:48 <atchoum> you only need to define foldMap
23:26:18 <dminuoso> atchoum: Or foldr if you prefer.
23:27:34 <dminuoso> atchoum: Also note that the word `traverse` has a somewhat different meaning in Haskell. It's related to Traversable (which happens to be subclass of Foldable)
23:27:57 <iqubic> subclass?
23:28:05 <iqubic> Why do you say that?
23:28:06 <atchoum> you mean when I say postorder Traversal ? yeah I suppose
23:28:45 <dminuoso> iqubic: https://wiki.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/558px-FunctorHierarchy.svg.png
23:29:16 <dminuoso> iqubic: The other direction is called superclass. Im not entirely certain whether `subclass` is the right term to express the opposite direction.
23:29:50 <atchoum> dminuoso: so basically, what do I do then ?
23:30:06 <dminuoso> u08:12        dminuoso | atchoum: There might be more condense solutions, but basically your code could be rewritten as: `f ts = ts >>= toList`
23:30:16 <dminuoso> atchoum: So you're doing a fold inside a monad.
23:30:29 <dminuoso> But generally it's just folding.
23:31:23 <dminuoso> atchoum: also note that depending on what your goal is (how you want to use that list) a `traverse` might be more useful to you
23:32:46 <atchoum> dminuoso: http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Foldable.html  <- I think there is an error in the doc here
23:33:04 <atchoum> foldMap f (Leaf x) = f x -- Shouldn't it be
23:33:17 <atchoum> foldMap f (Leaf x) = (f x) `mappend` mempty ?
23:34:04 <atchoum> ha no my bad
23:34:36 <atchoum> so I just do foldMap getNodeValue myTree ?
23:34:42 <iqubic> I think so.
23:34:51 <atchoum> not bad :p
23:39:10 <atchoum> tail recursion is its own reward
23:39:19 <atchoum> I don't get it straight yet
23:41:03 <rckd> hey guys, stupid question incoming: when i do something like   data T a = X Int Bool    what is happening to a? And how can the Int and Bool be used later on when doing something like   let x = X 10 True   This  confuses me a lot :-D
23:41:16 <cocreature> for a datatype "data X = X [Int] Int" I have a list xs :: [X], a set of Ints and a number of partitions of that set into two sets s1, s2 and for each of those partitions I need to answer "length [length as' | X as b <- xs, let as' = filter (`member` s1) as, b `member` s2]". Any ideas how I could do some clever caching here to speed this up?
23:42:15 <cocreature> xs stays constant throughout a large number of queries so if I can do some expensive precomputation it will probably pay off but I’m not sure what I should precompute to answer the queries fast
23:55:18 <Cale> cocreature: Why length [length ... | ...] ?
23:55:31 <cocreature> Cale: eh the outer length should be "sum" sry
23:55:37 <Cale> ah
23:55:50 <BasDirks> What is the recommended Haskell code formatter these days?
23:57:57 <Cale> cocreature: Maybe turn the lists into multisets represented by Maps of Ints?
23:58:13 <Cale> cocreature: That way you could use Map.intersection
23:58:21 <Cale> rather than lots of membership tests
23:59:22 <cocreature> Cale: ah good idea, I tried something similar to that but your idea sounds better, thanks!
