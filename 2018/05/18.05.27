00:26:10 <owickstrom> Anyone that knows if there's something like 'Fin' from Idris in the 'singletons' Haskell package, i.e. a bounded natural number?
00:26:49 <owickstrom> Or should I use Nat and POrd together somehow?
00:26:51 <tsahyt> owickstrom: there's this but not in singletons https://hackage.haskell.org/package/finite-typelits-0.1.3.0/docs/Data-Finite.html
00:28:39 <owickstrom> tsahyt: Ah, thanks. That looks like the right thing. I guess I'll need to define Sing instances for it, but might work anyway.
00:29:04 <tsahyt> owickstrom: I'm not sure this is exactly what you want though. It's been a long time since I looked at idris.
00:30:44 <owickstrom> I'll try it, thank you. :)
00:33:20 <owickstrom> Got inspired by Eisenberg's talk on Stitch, so I'm trying to make the core parts of my application indexed and safer.
00:33:47 <Axman6> Fin is pretty simple to implement right? data Fin n where FSucc :: Fin n -> Fin (S n); FZero :: Fin (S n) (I think, it's been a long time since I looked at Fin)
00:33:52 <owickstrom> And a good excuse to try out singletons.
00:34:13 <Axman6> also, you're the owickstrom of haskell at work fame right?
00:34:38 <tsahyt> everytime I try out singletons I'm at first amazed what you can do with it, and then annoyed at how "ugly" (for lack of a better word) it is compared to e.g. idris
00:34:40 <owickstrom> Axman6: yeah, I think so. Could try it with the $(singletons ...) TH magic to get the right instances.
00:34:59 <owickstrom> Axman6: Hehe, I dunno about fame, but yes.
00:35:09 <Axman6> I love you work, keep it up
00:35:15 <owickstrom> Thanks! :)
00:59:16 <p0a> Hello! How can I improve this code? https://pastebin.com/ps8e5jR7
00:59:53 * hackage ptr 0.16.5 - Abstractions for operations on pointers  http://hackage.haskell.org/package/ptr-0.16.5 (NikitaVolkov)
00:59:54 <p0a> Criticism is welcome. It's a program that counts the number of points that satisfy x1^2 + ... + xk^2 = r^2 in (mod q).
01:03:24 <hrnz> your notation is really misleading because for most values of q, F_q is not Z/qZ
01:04:32 <p0a> hrnz: can you explain? I thought F_q is (mod q)?
01:05:53 <hrnz> F_q is the field with q elements (if it exists). But clearly, Z/4Z is not a field (so calculating with integers mod 4), because 2 * 2 = 0, so 2 is a zero divisor, which can't happen in fields.
01:06:15 <hrnz> But there is a field with 4 elements! Consider F_2[x]/(x^2+x+1)
01:07:33 <p0a> oh no
01:08:51 <p0a> hahah! that's the best criticism
01:08:59 <p0a> it's when your program is wrong to begin with
01:09:02 <p0a> lol
01:09:20 <p0a> hrnz: thanks
01:09:38 <hrnz> But when q is a prime number, Z/qZ and F_q are the same thing
01:09:54 <setre> what is likely to be slowing this down: https://lpaste.net/1540493048385896448 ?
01:10:06 <p0a> yeah but I'm interested in q = p^k
01:10:08 <p0a> as well
01:11:04 <p0a> setre: super itself I'd guess?
01:13:34 * hackage names-th 0.2.0.4 - Manipulate name strings for TH  http://hackage.haskell.org/package/names-th-0.2.0.4 (KeiHibino)
01:16:08 <setre> p0a: compared it to this https://github.com/samidarko/hackerrank/blob/1aa2072f0ec942114868edd144c06948f6fa1f5d/fp/recursion/super-digit.hs which is much faster
01:16:57 <p0a> setre: it looks your supers are the same
01:17:10 <p0a> setre: so the slowness comes from whatever before it, which is weird to me
01:17:59 <p0a> setre: replace his makep with yours and vice versa, see if that changes the speed
01:18:08 <p0a> setre: otherwise it's in the other chunk of code in main
01:19:01 <setre> okay will do, thanks
01:22:59 <setre> seems i have some errors in my code
01:25:01 <setre> there's a bug in this: https://lpaste.net/397791281020928 which is not in this: https://github.com/samidarko/hackerrank/blob/1aa2072f0ec942114868edd144c06948f6fa1f5d/fp/recursion/super-digit.hs
01:27:56 <cocreature> setre: afaict you swapped n and k
01:28:06 <setre> cocreature: haha thanks
02:01:02 * hackage capataz 0.2.0.0 - OTP-like supervision trees in Haskell  http://hackage.haskell.org/package/capataz-0.2.0.0 (RomanGonzalez)
02:55:56 <numnum> I'm trying to use SuperRecord and the example has the following snippet: `person = #name := "Alex" & #age = 23 & rnil` When I try to run it, I got "parse error on input '#'". I'm guessing I must enable Language Extension ... can anyone help me to name this extension?
02:59:56 <jophish> numnum: check this out: https://github.com/takenobu-hs/haskell-symbol-search-cheatsheet
03:00:04 <numnum> nobody? :(
03:00:10 <numnum> ah thanks
03:00:13 <jophish> in your case OverloadedLabels is what you want
03:02:16 <numnum> yup, it works. thanks.
03:03:41 <jophish> you might consider raising an issue against the documentation of SuperRecord
03:31:24 <dexterlb> I run some code in ghci and it goes into an infinite loop. How can I interrupt it and cause it to print a stack trace?
03:31:57 <Axman6> ctrl-C will stop it but stack traces don't really exist in (GHC) haskell without some changes to the code
03:33:46 <dexterlb> Axman6, so, what do I need to do? I want to figure out which part of the code is going into a loop
03:34:59 <Axman6> you might want to look into the GHCi debugger support and step through the code to see what's happening. Also the Debug.Trace module might help you with printing intermediate results and function arguments
03:51:21 <dminuoso> dexterlb: You could use -fbreak-on-error while running your program through GHCi's trace
03:51:28 <dminuoso> and then ^C in the loop
03:53:52 <sword_smith> I get the error "Non-exhaustive patterns in case" and it is because my type system is suboptimal. How do I learn with which argument the failing function has been called?
03:54:54 <dminuoso> sword_smith: You could insert some irrefutable pattern and produce an error that show's the argument maybe?
03:55:33 <dminuoso> sword_smith: Are you using guards?
03:56:25 <sword_smith> dminuoso: Only patters, not guards.
03:57:29 <sword_smith> dminuoso: Maybe I could expand the cases to include all and then call undefined on the ones that are not already included?
03:57:39 <dminuoso> sword_smith: Mmm, does fwarn-incomplete-patterns help?
03:57:43 <__monty__> Having some trouble with ghcid and cabal new-repl for my test-suite while new-build succeeds without problems: http://ix.io/1bwF
03:57:48 <dminuoso> (It should be enabled by -W or -Wall)
03:58:00 <sword_smith> dminuoso: My emacs flychecker already warns me of the underdefined function
03:58:36 <sword_smith> And I know which function is problematic. I just need to know how it is called, with which argument it is failing
04:01:51 <dexterlb> dminuoso, I got it to show a stack trace, but it only shows <unknown> names. I guess I need to somehow enable profiling?
04:02:56 <__monty__> dexterlb: Are you sure you really want a stack trace and don't just think you want a stack trace?
04:15:23 <Heffalump> Any suggestions for a simple extensible records library (preferably no TH required to use it)? I'm a bit lost in a see of options. HList looked simple in the paper but looks really complicated on Hackage. Vinyl looks simple-ish but the tutorial claims no TH and then goes on to say to use it for the singletons.
04:15:32 <Heffalump> in a *sea* of options
04:21:14 <Hjulle> Just curous, why do you prefer to avoid TH?
04:22:56 <Heffalump> makes code and errors harder to understand, stage restrictions make code more awkward to write
04:23:10 <Heffalump> I don't mind writing a bit more boilerplate by hand in exchange
04:23:27 <Heffalump> once I understand the boilerplate I might be more willing to use TH to remove it
04:26:35 <reactormonk> Is there a concept of "the return value of this hlist will fulfill the conditions for typeclass X"?
04:31:42 <lyxia> Heffalump: the tutorial is misleading, you don't need singletons to use vinyl
04:40:10 <dcoutts__> reactormonk: there's something very much like that in generics-sop for products (which are essentially equivalent to hlists)
04:44:14 <pseudonymous> Is there a nice, down-to-earth guide on operating stack ? I am reading "Learn you a Haskell" and intend on playing with "Write yourself a Scheme in 48 Hours", but I am getting hampered by stack a fair bit. Particularly the divide between extra-deps, build-deps and counter-intuitive things like "stack install parsec" apparently doing nothing to satisfy my parsec needs
04:44:48 <reactormonk> I don't really understand why it expect effect ( effect ( ... ) ) instead of just effect ( ... ) - anyone got an idea? https://gist.github.com/reactormonk/6e7c0a63bc6d417f892aa94546393faf
04:45:15 <atchoum> pseudonymous: makes me think that scheme has the DrRacket IDE. Why Haskell has not a proper IDE ?
04:45:30 <reactormonk> pseudonymous, you want parsec to build your code?
04:45:53 <reactormonk> atchoum, what do you mean? ghcid is a proper IDE ;-)
04:46:25 <__monty__> reactormonk: No, it's 2/3's of an IDE : p
04:46:28 <pseudonymous> atchoum: well, I personally never used DrRacket when using Scheme. I like that it's there, but never needed it. I really think the language/ecosystem itself needs a clear, clean and concise set of tools which are well documented (think Golang) and let the community plug these into the various editors out there.
04:46:38 <lyxia> reactormonk: your code is truncated
04:46:46 <reactormonk> lyxia, lemme post the whole thing
04:47:03 <reactormonk> lyxia, updated
04:47:48 <reactormonk> ... now with dependencies too
04:47:51 <pseudonymous> reactormonk: no :) I want to install parsec as a library dependency. I am now remembering something about "stack install" being not unlike the golang install command.  What I'm saying is, I am struggling finding someone who just goes through the motions of using stack, from a new project to adding a dependency to.. whatever else is necessary.
04:47:52 <atchoum> pseudonymous: I disagree a little bit with you in such a sense that a fully integrated solution is much more likely to be universally useful.
04:48:23 <lyxia> reactormonk: cook is missing the Proxy argument
04:48:24 <atchoum> about the golang subsystem, I don't know if there is such an IDE for golang, but there is a couple of features that come to mind.
04:48:51 <atchoum> editors are not IDEs.
04:49:11 <atchoum> I am hesitating between going on emacs or keep searching for IDEs.
04:49:28 <reactormonk> pseudonymous, https://docs.haskellstack.org/en/stable/GUIDE/#adding-dependencies
04:49:28 <__monty__> atchoum: I'm on the side of IDEs always suck anyway so I'd rather piece together what works for me.
04:49:51 <__monty__> atchoum: Currently, just go with emacs.
04:49:59 <reactormonk> lyxia, duh, thanks
04:50:14 <atchoum> I learnt a little bit of lisp with sicp lately so why not
04:50:15 <maerwald> golang and "concise set of tools"
04:50:18 <maerwald> are you serious?
04:50:29 <pseudonymous> Last time I started setting up Emacs again. I ended with a week+ of yak-shaving. OK; granted, I like writing Lisp. But.. :P
04:50:34 <lyxia> reactormonk: :)
04:52:04 <pseudonymous> maerwald: Well, of course, complimenting langauge X on language Y's channel for decision Z will always gain you criticism. But yes, I actually think the set of standard golang tools is one of the most compelling facets of the language. I think I might like Haskell a lot, but right now, I'm not a fan of the tooling I'm running into :(
04:52:14 <reactormonk> lyxia, if you wanna mess around with it, there's also build missing an s2 argument, and after that it gets pretty damn hairy
04:53:57 * hackage yam-config 0.3.2 - Yam Configuation  http://hackage.haskell.org/package/yam-config-0.3.2 (leptonyu)
04:55:25 * hackage yam-transaction 0.3.2, yam-web 0.3.2 (leptonyu): https://qbin.io/dark-poster-3dc1
04:56:35 <__monty__> pseudonymous: Think of it this way, despite the tooling many don't stick with go, while it's vice versa for haskell ; )
04:57:33 * hackage yam-logger 0.3.2 - Yam Logger  http://hackage.haskell.org/package/yam-logger-0.3.2 (leptonyu)
04:58:53 <atchoum> it's weird that haskell is still not ranked on github
04:59:05 <atchoum> while this chan is on par with #python in term of users.
04:59:11 <pseudonymous> reactormonk: thanks :) Playing around with that link. Don't even have a package.yaml file (but have the stack.yaml file).. Will create a new project and try again.
04:59:54 <__monty__> atchoum: I think what you're seeing there is because of the number of people that use haskell and like vim/emacs/irc, i.e. Old Stuff ; )
04:59:54 <atchoum> pseudonymous: I need to spend more time with haskell.
05:00:01 <pseudonymous> atchoum: Of every programmer I meet in person, almost no one uses IRC. I think they're all on Slack, Gitter or somesuch these days
05:00:22 <Ariakenom> There
05:00:25 <Ariakenom> There
05:00:41 <reactormonk> pseudonymous, all these hipsters
05:00:49 <Ariakenom> There's some hs|fp of those too
05:00:49 <__monty__> pseudonymous: You don't *need* the package.yaml though. You'll bring in another moving part to understand if you're gonna use hpack.
05:01:38 <kuribas> are there dedicated haskell slack channels?
05:01:51 <pseudonymous> GRRRRR - had hoped stack was the 500 meters of thick cement encasing the nuclear fallout that is cabal (Don't know why, but all tutorials/blog posts I find so far seem to recommend avoiding cabal..)
05:02:22 <kuribas> pseudonymous: nah, cabal is ok.
05:02:27 <__monty__> pseudonymous: That's mostly outdated info if you use the new-* family of commands.
05:02:44 <__monty__> pseudonymous: Stack uses cabal-the-library, just not cabal-install.
05:02:54 <atchoum> mmh
05:03:12 <atchoum> i'm trying to run ghcid but i'v got an error
05:03:28 <atchoum> i'v got a user install of stack
05:03:34 <__monty__> pseudonymous: Fwiw, I went from ghc -> cabal -> stack -> cabal -> nix.
05:03:46 <atchoum>  /bin/sh: ghci: command not found
05:04:05 <atchoum> I have aliased ghci to `stack ghci`
05:04:20 <__monty__> Aliases are only interactive, can't be used by scripts.
05:04:32 <atchoum> so where is my ghci :(
05:05:01 <Ariakenom> kuribas: Might not be. There's some general FP channels though.
05:05:17 <Ariakenom> which I've heard of but never seen
05:05:35 <kuribas> Ariakenom: scala perhaps?  It's more hipster.  Or clojure
05:06:47 <__monty__> atchoum: What do you mean? You need to provide the right command. ghid --command='stack ghci --ghc-options=-fno-code'
05:06:57 <atchoum> okay
05:07:41 <__monty__> atchoum: You can't pass an alias as if it's a command. They're strictly for interactive use afaik.
05:07:52 <atchoum> yes it works now
05:08:16 <maerwald> __monty__: note that cabal new-* is not complete
05:08:27 <maerwald> so soggesting it as a full alternative is a bit whacky
05:08:39 <__monty__> maerwald: I haven't run into problems yet though.
05:08:45 <maerwald> then try cabal new-install
05:08:52 <maerwald> which is still unsupported and buggy
05:08:54 <__monty__> And I didn't say it's a stack replacement.
05:09:04 <__monty__> I have no need for new-install.
05:09:08 <maerwald> good for you lol
05:09:12 <atchoum> stack is best than cabal ?
05:09:18 <__monty__> I merely stated that the info on cabal is outdated.
05:09:33 <atchoum> I think it is important for a language to have a community
05:09:52 <__monty__> atchoum: You're in that community rn : p
05:10:11 <maerwald> __monty__: you also pointed to the cabal new-* familiy of tools, without saying that it's still experimental
05:10:33 <__monty__> Stack isn't better than cabal. Nor the other way round.
05:10:38 <atchoum> who is running the hackage repo ?
05:10:51 <maerwald> there's a hackage channel I think
05:10:55 <atchoum> __monty__: I like to learn of one build system :)
05:11:16 <atchoum> what's the difference between stack and cabal ?
05:11:22 <__monty__> maerwald: All I said was the information on cabal is outdated if you use new-*, that's not in any way misleading imo.
05:11:59 <atchoum> from stack overflow «Is stack a replacement for Cabal?» «Yes and No.»
05:12:18 <__monty__> atchoum: Once you take stack far enough you'll end up running into cabal anyway.
05:13:00 <maerwald> __monty__: maybe the info is outdated, but your's was incomplete ;)
05:13:14 <Ariakenom> kuribas: I went and checked. The # Haskell channel had 2k members out of 8k in generaö
05:13:17 <maerwald> atchoum: there is cabal-the-library and cabal-the-tool
05:13:24 <maerwald> the library is used by stack too
05:13:29 <maerwald> the tool not
05:13:46 <maerwald> so stack competes with cabal-the-tool
05:14:01 <__monty__> maerwald: That's fair but in practice I'm not convinced a beginner'll run into problems. That makes it sound like FUD.
05:14:10 <maerwald> lolwat
05:14:16 <atchoum> maerwald: so probably cabal-the-tool will be eaten by stack while cabal-the-library will continue to evolve on its way. I don't like making prediction of the future though.
05:14:22 <maerwald> cabal new-install is buggy and experimental, that's not fud
05:14:26 <maerwald> look it up in the documentation
05:14:53 <maerwald> atchoum: no, they will evolve independently
05:14:53 <__monty__> maerwald: But you don't need new-install to develop projects.
05:15:09 <maerwald> now you are assuming specific use cases
05:16:42 <__monty__> atchoum: If it's not clear yet the haskell community is very divided on tooling issues. Path of least resistance is to go with stack. If otoh you want to understand the choice you'll have to work with cabal-install for a while, then check out stack for a while, then preferably check out nix and only after doing all that you can make an informed decision.
05:17:22 <__monty__> maerwald: Fair point.
05:18:50 <mupf> I started learning Haskell a few days ago and now I'm sticking with cabal. tbh: I didn't had a closer look at stack yet, but cabal felt easy enough to begin with. I also like the ideah of having every application I write sandboxed. What's the deal with stack? any similarities?
05:19:45 <atchoum> __monty__: I tihnk ppl will adopt what works and so what has the more community effort and documentation will snow ball until the other possibilities will be reduced to legacy software. The problem of build system doesn't need 50 solutions.
05:20:02 <atchoum> btw i can'tb uild leksah
05:20:38 <petrus> My Spock based application fails to compile with ghc-8.4.2 due to the Semigroup/Monoid chamge. The offending file is at https://github.com/agrafix/Spock/blob/master/reroute/src/Data/PolyMap.hs The error message is at https://lpaste.net/4857024411619819520 Any suggestion?
05:20:46 <__monty__> atchoum: Python still has pip and easyinstall so I disagree.
05:21:08 <Ariakenom> atchoum: There are still trade offs and different opinions. This has been going on for some time.
05:21:15 <atchoum> http://vpaste.net/UWBAY
05:21:41 <atchoum> __monty__: easyinstall is abandoned I think, or at least, doesn't show such a wide use.
05:22:01 <__monty__> atchoum: Sure but it *still* works.
05:22:28 <Ariakenom> Build systems do have 50 solutions though. make is still in use
05:22:49 <siraben> Anyone know of any books teaching physics with programming?  For Haskell there's https://arxiv.org/pdf/1412.4880v1.pdf but I want to know if there's something more approachable
05:23:15 <Ariakenom> which shows that momentum can make things damn slow
05:25:18 <atchoum> siraben: usually ppl dont do numerical computation with haskell but with matlab/octave/scipy whatever. Even if Haskell can do the job pretty well. You wont have trouble to find plenty of reference for computational physics out and solving differential equations numerically there.
05:27:22 <atchoum> mmh is there a way for cabal and stack to cooperate ?
05:27:39 <atchoum> or are they maintaining their dependency tree  totally isolated ?
05:28:35 <__monty__> atchoum: cabal-install and stack can't interoperate, that's almost the entire point of stack ; )
05:29:06 <Ariakenom> siraben: something like this? https://twitter.com/patrikja/status/999573177020964864
05:29:43 <atchoum> I've got this error message while trying to install leksah : http://vpaste.net/Pzmxr
05:30:33 <atchoum> basically I think ill try to install dependencies by hand trying to hit what works with stack
05:30:45 <atchoum> currently having typed stack install gi-gtk-hs seems to work.
05:31:18 <atchoum> Let's say I am an organization and I want to run my private hackage repository. Would it be possible ?
05:31:52 <__monty__> atchoum: I'd just use a different resolver, you can find a good one here: https://www.stackage.org/package/leksah
05:32:12 <siraben> Ariakenom: Yes, thanks for that!
05:32:23 <petrus> siraben: http://web.mit.edu/fnl/volume/302/rebusco_et%20al.html, http://www-personal.umich.edu/~mejn/computational-physics/
05:32:33 <siraben> Ariakenom: Alas, it doesn't go too far
05:32:50 <Ariakenom> siraben: hm?
05:33:13 <siraben> Ariakenom: It's not very deep
05:33:25 <siraben> But otherwise a good resource
05:33:58 <Ariakenom> There are a bunch of chapters here https://dslsofmath.github.io/BScProj2018/
05:34:13 <siraben> Ariakenom: Yeah that is what I was referring to.
05:34:21 <Ariakenom> but maybe that's not a lot. Your question just reminded me of that tweet I had seen earlier
05:35:12 <Ariakenom> Chalmers does so much cool FP stuff
05:36:49 <__monty__> atchoum: Recent post on this: https://www.snoyman.com/blog/2018/05/building-packages-outside-snapshots
05:38:14 <atchoum> __monty__: thanks
05:38:23 <atchoum> thank you very much
05:39:52 <atchoum> it appears I think I had a missing binary package (external dependency being gobject-introspection on archlinux)
05:40:38 <atchoum> can you recommend an HTTP/web framework for haskell ?
05:43:12 <fragamus> somehow Data.Set.powerset is not defined on my nixos thingy
05:43:37 * hackage hifi 0.1.3.0 - WiFi connection script generator  http://hackage.haskell.org/package/hifi-0.1.3.0 (gonz)
05:43:45 <fragamus> can anyone shed light before I go digging
05:43:55 <Ariakenom> atchoum: primarily for learning? (just clarifying, I don't have any suggestions myself)
05:44:22 <fragamus> Data.Set.powerSet
05:45:31 <fragamus> I was really looking forward to using it instead of rolling my own
05:46:37 <atchoum> Ariakenom: basically to run things
05:47:04 <atchoum> see if it can be real simple to write a webservice + ORM + deployment
05:47:28 <atchoum> (locally first and then do the deployment through docker / etc).
05:47:29 <__monty__> atchoum: I keep hearing yesod, scotty, servant, spock. Don't have a recommendation.
05:47:30 * hackage hifi 0.1.3.1 - WiFi connection script generator  http://hackage.haskell.org/package/hifi-0.1.3.1 (gonz)
05:52:43 <fragamus> https://stackoverflow.com/questions/6428279/why-data-set-has-no-powerset-function
05:55:00 <kuribas> atchoum: I really miss a NumPy or SymPy for haskell
05:55:39 <maerwald> it would probably have tremendous type complexity, scaring away half of the potential users
06:00:26 <petrus> Anybody has managed to compile Spock with ghc-8.4.2?
06:06:29 <atchoum> http://vpaste.net/pJ8IU
06:06:41 <exio4> just in case (also asked in #hakyll), is there a way to run an IO action when a file is modified? it's for a pdf-gen (based on metadata), I'm currently using a bash script which I run between the blog build and the actual deployment
06:07:14 * atchoum is sad to encounter so much build issues.
06:07:48 <__monty__> exio4: Maybe System.FSNotify?
06:08:06 <exio4> I'm using Hakyll which is doing that on its own already, though
06:10:10 <Heffalump> lyxia: I see, thanks. I'll have a play without them then.
06:42:08 <atchoum> i have this error with stack : http://vpaste.net/cPWYp
06:42:40 <atchoum> gi-gtk-hs and haskell-gi-overloading are installed, how can I try to install ltk anyway ?
06:42:47 <atchoum> by ignoring future version ?
06:46:06 <__monty__> atchoum: Did you try with the older resolver?
06:46:18 <atchoum> __monty__: I couldn't find a resolver actually
06:46:50 <atchoum> __monty__: actually I found an older resolver for ltk, but this is not useful to install leksah in its more recent version.
06:47:12 <__monty__> Ah, you're right.
06:51:45 <atchoum> (the older resolver worked fine for ltk, but it had to download another compiler and all) apart from that, I am wondering if `ltk` has forgot to update its dependency.
06:51:52 <atchoum> i mean the ltk team
06:52:40 <atchoum> a more cryptic error is http://vpaste.net/AQNGl
06:54:40 <cocreature> atchoum: have you tried following the recommendation at the bottom?
06:54:56 <atchoum> I am currently looking into the `stack solver` option.
06:55:21 <huxx> Hey guys
06:55:32 <cocreature> atchoum: "stack solver" never works for me but ymmv. I would recommend to add it to extra-deps
06:55:33 <atchoum> but I think it has to work with a source directory.
06:55:36 <hamishmack> atchoum: I highly recommend using nix to install Leksah https://github.com/leksah/leksah#getting-leksah
06:55:38 <huxx> Does anybody have faced this function in a library ? foldrr :: (Foldable t, Foldable f) => (a -> b -> b) -> b -> t (f a) -> b foldrr f = foldr (flip (foldr f))
06:56:42 <cocreature> atchoum: btw "stack install" is for installing executables and copying them to ~/.local/bin. if you want to install a library just use "stack build"
06:57:01 <hamishmack> Nix performs a similar role to stackage/stack, but also covers the non haskell dependencies of Leksah (like Gtk)
06:58:21 <Welkin> and cabal new-install does what stack does without the mess
06:58:29 <Welkin> with nix-style builds
06:58:43 <hamishmack> If you do want to get it working with stack I would recommend building it from the github source
06:59:04 <cocreature> gotta love how Haskellers feel the need to turn every question about some build tool into a recommendation for another build tool
06:59:15 <atchoum> hamishmack: that is just what I was getting into.
06:59:39 <hamishmack> But keep in mind you will need to install the Gtk dev dependencies manually
06:59:52 <atchoum> I already installed them from my distribution package manager.
06:59:55 <Welkin> cocreature: that is only because the stack team tries to cause trouble in the community by splitting it apart all the time
07:00:04 <Welkin> so it should be eliminated
07:00:28 <cocreature> yeah trying to eliminate something that a significant portion of the community is using is surely going to make everything better
07:01:11 <rotaerk> functional fascism
07:01:15 <maerwald> Welkin: cabal new-install is buggy and experimental
07:01:32 <atchoum> competition between standards is not necessarily a bad thing.
07:02:10 <Ariakenom> I always use curl and a sufficiently recursive makefile
07:02:49 <Welkin> maerwald: it is not, it works great
07:02:56 <Welkin> atchoum: there is no standard
07:03:13 <maerwald> Welkin: lol
07:03:14 <atchoum> I was wondering if the word standard should be put into my phrase.
07:03:17 <Welkin> atchoum: cabal is the standard if there is any, as it is the only build tool
07:03:22 <Welkin> stack just wraps cabal
07:03:26 <atchoum> Should have used `solutions` instead
07:03:32 <Welkin> cabal is *the only* build system
07:03:33 <maerwald> Welkin: did you actually try it and checked the documentation
07:03:44 <maerwald> which still says it's unsupported
07:03:45 <rotaerk> afaik, unless cabal new-* resolve this (I haven't learned those yet), nix is the only complete build solution, right now, for resolving all dependencies and allowing reproduction of builds without depending on having a bunch of stuff pre-installed in your environment
07:03:54 <Welkin> maerwald: the docs are very outdated at the moment
07:03:58 <maerwald> and new-install occasionally does nothing (as in, not install any symlink)
07:03:59 <Welkin> they are for cabal 2.0
07:04:03 <rotaerk> unfortunately it's not easy to learn
07:04:03 <Welkin> we are on cabal 2.2.0.1
07:04:06 <Welkin> which works perfectly
07:04:11 <maerwald> it doesn't
07:04:18 <Welkin> it has in my use of it
07:04:19 <__monty__> hamishmack: nix won't help atchoum in this case sadly because the leksah expression doesn't build on darwin currently.
07:04:36 <maerwald> then don't say it's not buggy when your use case is obviously limited to the working subset
07:04:57 <Welkin> okay then
07:05:13 <Welkin> I have not experienced bugs, so I can say it is not buggy
07:05:21 <Welkin> how would I know otherwise if I have not had your experience?
07:05:23 <Welkin> you make no sense
07:05:33 <atchoum> Welkin: you have probably never worked on a QA team
07:05:36 <hamishmack> __monty__ it should.  Can you post an issue
07:05:47 <atchoum> Welkin: absence of proof is not proof of absence
07:06:08 <maerwald> Welkin: "maerwald: it is not, it works great"
07:06:32 <atchoum> basically I'd say.
07:06:33 <Welkin> I've also never hear anyone complain about bugs in it until you, just now
07:07:02 <cocreature> eh, if new-build didn’t have known bugs and missing features it would have replaced build
07:07:41 <hamishmack> __monty__ Did you follow these instructions? https://github.com/leksah/leksah#nix
07:07:44 <cocreature> those bugs and missing features might not be problematic for a lot of usecases (I use new-build myself quite a lot) but saying that there are no known bugs is just silly
07:07:57 <Welkin> okay, enough of this
07:08:02 <maerwald> Welkin: did you try new-install without a pkgname?
07:08:11 <Welkin> yes, all the time
07:08:14 <huxx> can anyone tell me if the is a better way to fold a nested structure that doing that ? foldrr :: (Foldable t, Foldable f) => (a -> b -> b) -> b -> t (f a) -> b foldrr f = foldr (flip (foldr f))
07:08:14 <__monty__> hamishmack: No, just tried installing from nixpkgs.
07:08:19 <maerwald> good, because it does nothing for me
07:08:21 <Welkin> I never said there are no known bugs
07:08:24 <maerwald> it installls no symlink
07:08:25 <Welkin> I said it works for me
07:08:25 <hamishmack> Oh yeah that is broken
07:08:37 <hamishmack> You have to install from github for now
07:08:39 <Welkin> oh wait, new-install?
07:08:41 <maerwald> yes
07:08:41 <Welkin> I never use install
07:08:44 <Welkin> I use new-build
07:08:44 <maerwald> see
07:08:49 <dufferz> Yoooooo
07:08:52 <Welkin> new-install is just a synonym for new-build'
07:08:56 <maerwald> what?
07:09:01 <Welkin> yes
07:09:07 <Welkin> read the docs
07:09:07 <maerwald> *facepalm*
07:09:13 <maerwald> it is not
07:09:38 <huxx> Anyone to answer my question please :) ?
07:10:17 <Welkin> okay, I misread that
07:10:20 <Welkin> yes, it doesn't work
07:10:26 <maerwald> ...
07:10:30 <Welkin> but I have never needed to use it
07:10:35 <Welkin> you just need new-build
07:10:36 <maerwald> that took you long to realize
07:10:42 <Welkin> because I don't use it
07:10:43 <Welkin> of course
07:10:51 <maerwald> sometimes it's also useful to listen closely ;)
07:11:05 <Welkin> anyway, enuogh of this
07:11:16 <Welkin> I did'nt come online just now to waste my life in a pointless argument
07:11:45 <maerwald> my point being: recommending new-* command to new users without saying that is experimental is not a good thing
07:12:02 <huxx> People are angry today :P
07:12:03 <Welkin> also, the docs are wrong
07:12:03 <maerwald> and "I don't use new-<command>" is not a compelling argument
07:12:08 <Welkin> new-run works
07:12:16 <Clint> huxx: Welkin has that effect on people
07:12:23 <rotaerk> huxx, looks reasonable to me
07:12:57 <huxx> rotaerk: what, my question, or the angry people ^^ ?
07:13:15 <rotaerk> your solution to the problem :P
07:13:16 <maerwald> reminds me of that stallman argument "But what should people use instead of facebook?" -- Stallman: "I don't use facebook."
07:13:44 <huxx> rotaerk: I feel like I am rewriting something, but I believe in people here so thanks :)
07:14:07 <rotaerk> well I don't know everything in haskell, so it's possible there's something already out there
07:14:21 <rotaerk> but if you can't find it, just use this for now and replace later if you find something
07:14:21 <cocreature> huxx: you could add some helper for that but then where do you stop? do you also want versions for 3 nested foldables, 4, 5, …
07:15:08 <huxx> cocreature: I have a spatial grid containing buckets that contains objects
07:15:21 <cocreature> huxx: if you already depend on lens then you can simplify it
07:15:27 <cocreature> :t foldrOf (folded . folded)
07:15:29 <lambdabot> (Foldable f2, Foldable f1) => (a -> r -> r) -> r -> f1 (f2 a) -> r
07:15:35 <cocreature> but I wouldn’t recommend picking up lens for that
07:15:58 <huxx> Yep I already depend on lens
07:16:13 <huxx> Okay I will stick to the first solution then
07:23:38 <huxx> cocreature: Do you meant that having a join-like function for my f (t a) would be better ?
07:25:02 <cocreature> huxx: depending on your application it might also make sense to work with a newtype. e.g. instead of "type Grid a = [[a]]" work with "newtype Grid a = Grid [[a]]" and then you don’t need a nested foldr
07:25:07 <cocreature> huxx: not sure what you mean by that
07:25:37 <huxx> data Bucket     a = Bucket BucketId (V.Vector a)                                deriving Showdata Grid       a = Grid GridSize GridDivision BucketSize (M.IntMap (Bucket a)) deriving Show
07:25:39 <atchoum> basically what would you go with to create a new project from scratch ? stack init ?
07:26:53 <cocreature> atchoum: yeah if you’re using stack, then "stack init" is the way to go
07:27:12 <Welkin> cabal init
07:27:14 <Welkin> without stack
07:27:17 <atchoum> mmh cool
07:27:39 <atchoum> I think a good project should maintain build script for all the build systems out there.
07:27:45 <atchoum> stack new did the work
07:27:57 <cocreature> oh right, I confused stack new and stack init
07:28:00 <Welkin> atchoum: then you would have to support a lot of them
07:28:07 <atchoum> it generated a cabal file
07:28:13 <atchoum> that's cool
07:28:15 <Welkin> atchoum: of course, stack uses cabal
07:28:20 <Welkin> its a wrapper over it
07:28:37 <Welkin> you still have to learn how to use cabal even if you use stack
07:28:56 <atchoum> mmmh I am trying to see how quickly one can go from idea to production.
07:29:12 <cocreature> huxx: hm I’m not sure how you end up with the case where you need the nested foldr here. is that just for the implementation of the Foldable instance for Grid?
07:30:33 <atchoum> seems than  nix is downloading a whole linux distro for me.
07:30:49 <huxx> cocreatre: yes
07:30:58 <huxx> cocreature: yes
07:31:01 <cocreature> huxx: you should be able to just derive the Foldable instance
07:31:11 <Welkin> atchoum: nix encapsulates an entire system
07:31:17 <Welkin> not just the haskell parts
07:31:31 <huxx> cocreate: I have a second case where I have [Bucket a]
07:31:40 <atchoum> hopefully that download will be made once and for all.
07:32:11 <atchoum> or could it mean that i can uninstall everything on my distro ?
07:32:19 <atchoum> Why would it download systemd :|
07:32:51 <cocreature> probably because gtk has a dep on systemd or something like that
07:33:22 <atchoum> it started compiling, apparently, leksah is going to work with nix compilation.
07:33:41 <atchoum> some warnings though
07:33:51 <dminuoso> I would like to have the same data constructor in different data records in the same module. Is there some way to do this?
07:35:11 <cocreature> dminuoso: no there is (sadly) no DuplicateConstructors extension or something like that
07:39:13 <maerwald> gtk+ doesn't depend on systemd
07:49:02 * hackage tomland 0.2.0 - TOML parser  http://hackage.haskell.org/package/tomland-0.2.0 (shersh)
07:50:07 <atchoum> how can you import the content of a file in the current directory ? Just `import` doesn't work, Do I have to build the package file ?
07:55:16 <atchoum> basically I suppose everything must be compiled to be imported, you can't have just in time compilation ?
07:55:48 * atchoum is wondering how to simply set up a proper environment with haskell, knowing that he is using stack for ghc / ghci
07:56:22 <cocreature> atchoum: which command are you running to check that the import is working?
07:57:11 <atchoum> i'm just having a script, which does `import BinaryTree`. In the same folder, I have a `BinaryTree.hs` file with all the definitions I need. I am wondering if I need to do something a little bit more fancy to have this setup working
07:57:44 <cocreature> and you’re running "ghc FileName.hs" where FileName.hs is the file containing the import?
07:58:19 <atchoum> I import it in ghci with :load
07:58:31 <atchoum> ghci>:load FileName.hs
07:59:04 <cocreature> do you have a "module BinaryTree" header in the BinaryTree.hs file?
07:59:09 <atchoum> nope
07:59:38 <cocreature> you need that for everything but the Main module where it is optional
08:00:53 <atchoum> ok, thx.
08:01:02 <atchoum> working on it.
08:01:43 <cocreature> "module BinaryTree where" should be the full header if you want to export everything from that module
08:02:04 <cocreature> you can also specify an explicit export list to limit what is being made available to the outside
08:09:49 <Gurkenglas> Where's Data.Array's Maybe-lookup? :(
08:15:47 <glguy> in lens
08:19:02 <atchoum> http://vpaste.net/PxjDV <- I use a stack for doing the inorder traversal, is that a good solution ?
08:21:33 <Gurkenglas> Should https://hackage.haskell.org/package/array-memoize contain memoList :: [a] -> Int -> Maybe a?
08:22:20 <glguy> atchoum: I'd have gone with: https://gist.github.com/glguy/15e6450c518d3d1851fc6f13aec3c23a
08:23:19 <glguy> atchoum: When variables are going to only be used in a very narrow context, short ones help readability
08:23:39 <maerwald> Gurkenglas: such a function would be easy to write no? given that you can check the bounds manually
08:24:34 <Gurkenglas> maerwald, yes but beware trivial inconveniences
08:24:51 <maerwald> such as?
08:25:25 <Gurkenglas> People not writing it themselves because it's not worth the gain, though they would have used it had it been there
08:26:26 <Gurkenglas> atchoum, I'd do something like "inOrderTraversal (Node x l r) = inOrderTraversal l ++ x : inOrderTraversal r", perhaps using difference lists to avert logarithmically many ++ evaluations per item
08:26:40 <maerwald> sounds like an easy addition to the safe package
08:26:41 <glguy> Gurkenglas: That's what my paste does
08:27:49 <Gurkenglas> Does it need the accumulator?
08:27:51 <atchoum> Gurkenglas: I tried to avoid the ++ hence the stack.
08:28:20 <glguy> Gurkenglas: No, it doesn't use an "accumulator", but is does have an inlined DList
08:28:45 <glguy> atchoum: You have too many cases due to nested pattern matching looking for EmptyTs
08:28:47 <rotaerk> acowley, https://github.com/Rotaerk/vulkanTest/issues/1
08:28:51 <rotaerk> thoughts?
08:31:53 <atchoum> glguy: yes indeed
08:31:58 <atchoum> my code is ugly
08:33:49 <glguy> atchoum: Did you see my paste. It's got the same general idea you're using with keeping a stack, but it keeps a stack of results instead of trees to process
08:35:38 <atchoum> yes I saw it.
08:35:46 <atchoum> it 's beautiful
08:35:50 <Gurkenglas> Ah, it became clear to me when I wrote it "aux (Node x l r) = aux l . (x :) . aux r"
08:36:19 <atchoum> I wonder how I couldn't come with that first try
08:36:36 <atchoum> I am wondering if using substitutions would alow me to get to your result.
08:45:02 <deeplearner> join #rust
08:51:38 <maerwald> wrong irc server
09:00:13 <zfnmxt> How does this type? (return "foo") 1
09:01:33 <lyxia> zfnmxt: return :: Monad m => a -> m a     set "m = (->) b",   return :: a -> b -> a
09:01:37 <zfnmxt> Oh. Does it enforce it to be the (->) monad?
09:01:39 <zfnmxt> Ah
09:01:46 <zfnmxt> You beat me to  it :)
09:02:02 <exio4> zfnmxt: (return "foo") has type Monad m => m String, using it as a function (assuming Int as parameter), Monad m => m String ~ Int -> a
09:02:09 <zfnmxt> That's a devious example :D
09:02:14 <exio4> zfnmxt: given Int -> a is (->) Int a ...
09:02:22 <zfnmxt> Right, right.
09:02:23 <exio4> Monad m => m String ~ (->) Int a
09:02:30 <exio4> well, you got it :p
09:02:38 <zfnmxt> I was just doing it in the context of the list monad so I was being stupid and not even thinking about (->) :)
09:02:39 <zfnmxt> Thanks!
09:09:00 <`Guest00000> > return "foo" $ undefined
09:09:02 <lambdabot>  "foo"
09:12:43 <`Guest00000> > join (,) $ 5
09:12:45 <lambdabot>  (5,5)
09:15:53 <dmwit> > join(,)5
09:15:55 <lambdabot>  (5,5)
09:16:08 <dmwit> Keep those dollas fo yo wallet.
09:16:45 <glguy> `Guest00000: is makin' it rain
09:19:24 <dmwit> > (replicate =<< fromEnum) =<< return "foo" 1
09:19:27 <lambdabot>  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
09:19:36 <dmwit> Bind is associative, right? ;-)
09:41:33 * hackage time-quote 1.9.0.0 - Quasi-quoters for dates and times  http://hackage.haskell.org/package/time-quote-1.9.0.0 (ThomasTuegel)
09:53:02 <monochrom> @type fromEnum >>= replicate
09:53:04 <lambdabot> Enum a => a -> [a]
09:53:59 <monochrom> @type return "foo" 1
09:54:00 <lambdabot> [Char]
09:56:52 <monochrom> > length ((replicate =<< fromEnum) =<< return "foo" 1)
09:56:54 <lambdabot>  324
09:57:21 <monochrom> > sum (map fromEnum "foo")
09:57:24 <lambdabot>  324
09:57:39 * EvanR monochrom do you realize you can play with lambdabot in PM (tm)
09:58:22 <EvanR> youre disturbing the silence
09:58:28 * monochrom is too dumb to learn how to use PM (tm)
10:00:06 * hackage animate-preview 0.1.2.4 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.1.2.4 (jxv)
10:00:52 <d34df00d> Hey folks
10:02:15 <d34df00d> I made a library that TH-generates a data type with a subset of constructors of another data type → https://github.com/0xd34df00d/enum-subset-generate . I'd like some critique and comments! And a more concise motivating example, if something comes to mind.
10:02:22 <Gurkenglas> Should http://hackage.haskell.org/package/HDBC-2.4.0.2/docs/Database-HDBC-Types.html#t:IConnection be turned into an implicit parameter "?conn"?
10:02:26 <d34df00d> And a better name, cause this one sounds dumb.
10:29:34 <Gurkenglas> How should a library that allows memoized arbitrarily mutual recursion look? I'm thinking of using recursive do notation
10:31:56 <hpc> mutualMemo $ \(f, g) x -> (f x, g x) seems like a good first pass
10:32:16 <Gurkenglas> That's only two though, and with the same parameter
10:32:54 <hpc> would all the functions be the same type?
10:32:59 <Gurkenglas> no
10:33:15 <hpc> so you're stuck using tuples or type class wizardry
10:33:24 <Gurkenglas> "memoFix f" could look like "f' <- somethingsomething f f'"
10:33:35 <hpc> hmm
10:33:41 <Gurkenglas> And then the rest of the do block would have access to f' as well, forward and backward
10:36:27 <hpc> i suppose mutual memoization is single-function memoization multiple times, but each "primitive" function has access to the memoized definitions
10:36:55 <hpc> at the top-level, f = memo $ \f x -> something using g
10:37:02 <hpc> g = memo $ \g x -> something using f
10:37:50 <hpc> or this works anywhere you can write mutually recursive definitions
10:37:53 <hpc> so where blocks and let-in too
10:38:07 <hpc> that might be all you need
10:39:12 <Gurkenglas> I think you're right and we never needed recursive do for this
10:40:52 <Gurkenglas> In the same way that you don't actually need memoFix if you just don't want to look at the tries
10:42:54 <alexad> Is there a good place I can learn about how haskell works with recursive operations in general? In terms of optimisation to tail-calls, potential need of trampolining, etc?
10:43:36 <alexad> or is the language and compiler designed such that I basically don't need to worry about it and recursive operations are always unwrapped to prevent overflows?
10:45:03 <hpc> most of the time it just works but you do need to understand thunks and lazy evaluation to figure out performance issues and such
10:45:03 * hackage htoml-megaparsec 2.0.0.0 - Parser for TOML files  http://hackage.haskell.org/package/htoml-megaparsec-2.0.0.0 (vmchale)
10:45:31 <hpc> i vaguely remember there being a good series of posts on ezyang's blog but now i can't find it
10:47:31 <maerwald> seems leksah is still hard to build
10:47:43 <hpc> alexad: http://blog.ezyang.com/2011/04/the-haskell-heap/ - maybe this will help?
10:48:25 <alexad> hpc, thanks
10:48:26 <hpc> you might be able to skip to the implementing in python post
10:48:39 <hpc> and there's probably better resources out there, but i can't remember them
10:50:18 <cocreature> something like stgi can also be quite helpful for understanding Haskell’s evaluation model
10:50:26 <cocreature> @where stgi
10:50:26 <lambdabot> I know nothing about stgi.
10:50:31 <cocreature> meh
10:51:43 <cocreature> hm I can’t remember the command to add something to that list
10:51:46 <cocreature> here’s the link https://github.com/quchen/stgi
10:51:58 <hpc> @where+ stgi https://github.com/quchen/stgi
10:51:58 <lambdabot> Okay.
10:52:03 <cocreature> ah!
10:52:04 <cocreature> thanks
10:53:57 <alexad> hpc, heh, fire ze missiles
10:56:02 <alexad> just as a general rule, once you evaluate a function for a given argument, future evaluations of that same function are essentially memoised, right?
10:56:10 <alexad> I'll just keep reading in any case
10:57:50 <rotaerk> alexad, I don't think that's something you can count on, though I'm not really all that familiar with GHC optimizations
10:57:50 <hpc> alexad: functions aren't memoized, but thunks stay evaluated
10:58:12 <hpc> (f 5) and (f 5) are two different evaluations
10:58:15 <rotaerk> if you want to avoid re-evaluation, bind the result to something
10:58:25 <hpc> but evaluate listOfFiveElements twice and the second time doesn't do work
10:59:28 <alexad> rotaerk, bind? as in assign it to a name?
10:59:34 <rotaerk> yea
10:59:45 <alexad> as in blah = f 5, then I can blah ad infinitum and receive only one evaluation
10:59:52 <alexad> since the result of f 5 is thunked
11:00:22 <rotaerk> memoizing evaluations for everything by default would not be a good thing; sometimes it's actually better to re-evaluate than to pull from memory
11:01:29 <hpc> something you'll discover later on is that there are memoization libraries
11:01:42 <hpc> they do things like transform a function f into a list [f 0, f 1, f 2, ...]
11:01:50 <hpc> and then give you back a function that looks up values in that list
11:02:10 <hpc> the list itself is just a list, so it doesn't recompute
11:16:14 <asjkdhaksjd> hola alguien??
11:16:47 <glguy> asjkdhaksjd: This is an English speaking channel
11:16:57 <asjkdhaksjd> no problem
11:17:01 <asjkdhaksjd> i can try
11:17:03 <asjkdhaksjd> hahaah
11:17:21 <asjkdhaksjd> i have a simple doubt
11:17:30 <asjkdhaksjd> can i ask u?
11:17:46 <cocreature> asjkdhaksjd: is it a question about Haskell?
11:17:51 <asjkdhaksjd> yes
11:17:53 <glguy> asjkdhaksjd: You can write out your whole question and if someone wants to try to answer it they will
11:18:00 <cocreature> asjkdhaksjd: then sure go ahead!
11:18:02 <setre> this is my attempt: https://lpaste.net/708824682224156672 at https://www.hackerrank.com/challenges/super-digit/problem unfortunately it fails some test cases, can anyone help me figure out what is wrong?
11:18:05 <asjkdhaksjd> aah ha
11:18:16 <asjkdhaksjd> its very simple but i dont know how to do it
11:18:27 <asjkdhaksjd> i have to create a list
11:18:36 <asjkdhaksjd> with 1024 positions
11:18:42 <asjkdhaksjd> but with the same value
11:18:46 <asjkdhaksjd> i mean a list of ints
11:18:51 <asjkdhaksjd> with 0
11:18:59 <asjkdhaksjd> but 1024 times
11:19:05 <cocreature> :t replicate
11:19:05 <Adluc> > take 1024 (repeat 0)
11:19:06 <lambdabot> Int -> a -> [a]
11:19:07 <glguy> asjkdhaksjd: You can write the whole question on a single line before you press ENTER
11:19:08 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
11:19:11 <asjkdhaksjd> [0,0,0....]
11:19:16 <cocreature> > replicate 5 0
11:19:18 <lambdabot>  [0,0,0,0,0]
11:19:24 <asjkdhaksjd> sorry glguy
11:20:24 <asjkdhaksjd> ahaha with (take 2014 (repeat 0)) should works :D thks
11:20:40 <asjkdhaksjd> :t foldl
11:20:41 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:20:46 <asjkdhaksjd> hoho nice bot
11:21:02 <cocreature> I would use "replicate" instead of take + repeat. makes it easier to see what the intention is
11:21:24 <glguy> setre: Looks like your implementation of createP is wrong
11:21:42 <glguy> err, maybe not
11:21:53 <cocreature> setre: do you have an example of a failing testcase?
11:21:53 <asjkdhaksjd> cocreature: you're right, its also more easy
11:22:13 <setre> cocreature: sure one moment
11:23:07 <setre> cocreature: https://lpaste.net/6451691029266432000
11:23:27 <cocreature> setre: that’s going to overflow if you parse it as an Int
11:23:33 <cocreature> setre: try using Integer instead
11:24:00 <cocreature> both for parsing "n" as well as for the intermediate calculations in "super"
11:24:04 <setre> cocreature: okay thanks :)
11:24:12 <cocreature> > maxBound :: Int
11:24:14 <lambdabot>  9223372036854775807
11:24:20 <cocreature> your number is definitely larger than that :)
11:24:26 <setre> yeah :)
11:25:14 <cocreature> you might also need it for "k" but at least in this example it’s not necessary
11:25:24 <cocreature> and realistically you probably also don’t need it for intermediate calculations
11:25:49 <cocreature> so you could also try to just get rid of first converting "n" to an Int using "read" only to then convert it back to a String in "createP"
11:26:23 <glguy> You don't even need to bother with createP
11:26:50 <glguy> The digital sum of (createP n k) is the digital sum of n * k
11:27:50 <Gurkenglas> Requesting "cheat :: (a -> v) -> a -> v" such that let f = cheat g in (f x, f y) is equal to one of (f x, f x) or (f y, f y)
11:28:30 <Gurkenglas> By "knowing" that g x is equal for all x with which g will be called
11:32:33 <glguy> Gurkenglas: That won't quite be possible, you'll at least need something like: (a -> v) -> IO (a -> v)
11:32:47 <glguy> so that you can distinguish which uses of cheat introduce unique "cheat" functions
11:38:00 <Gurkenglas> How would "cheat g = let ref = unsafePerformIO Nothing in \x -> let y = g x in unsafePerformIO $ modifyIORef ref (<|> y) >> readIORef ref" fail? I expect the timing here to be like in memoize
11:38:27 <Gurkenglas> *unsafePerformIO $ newIORef Nothing
11:38:39 <Gurkenglas> And fromJust, bah.
11:38:49 <glguy> let f = cheat g in (f x, f y) could be rewritten to:   (cheat g x, cheat g y)
11:38:59 <glguy> and now we've lost the sharing between the two
11:39:16 <Gurkenglas> Ah. Does the same hold for memoize?
11:39:44 <`Guest00000> what about cheat :: (a -> v) -> () -> a -> v
11:40:08 <`Guest00000> or    (a -> v) -> ((), a -> v)
11:40:33 <`Guest00000> let ((), f) = cheat g in
11:40:51 <glguy> Gurkenglas: sure, you have to rely on what your compiler actually does with the code. When you start throwing unsafePerformIOs around things get less predictable
11:41:17 <monochrom> That is a lot of unsafePerformIO's.
11:41:19 <glguy> Gurkenglas: I was thinking something like: https://gist.github.com/glguy/1e06a452af937e3efe71855ea76756db
11:42:05 <glguy> Gurkenglas: in addition to hoping that f in f=cheat g   doesn't get inlined, your code hopes that ref isn't inlined,
11:42:54 <monochrom> On that tangent, what do you think if I rename "inlining" to "common subexpression introduction"? >:)
11:43:15 <glguy> approved!
11:43:37 <Tuplanolla> What is it common with, monochrom?
11:44:02 <glguy> Tuplanolla: in the case of multiple inlinings, the other inlining
11:51:12 * hackage servant-streaming 0.2.0.0 - Servant combinators for the 'streaming' package  http://hackage.haskell.org/package/servant-streaming-0.2.0.0 (jkarni)
11:51:19 <dmwit> monochrom: Somebody at work recently was telling me about an "outliner".
11:51:49 <dmwit> I commented that it sounded like common subexpression elimination, but after some thought we came up with a difference, so I will use that difference to object to the name "common subexpression introduction". =)
11:51:59 <cocreature> llvm has an outliner pass iirc
11:52:04 <dmwit> yes, that's the one
11:52:33 <cocreature> dmwit: what’s the difference? the fact that you can parametrize the parts that you outline?
11:52:38 <dmwit> yes
11:52:50 <dmwit> Geez, let me type. No fair you being faster at describing the difference than me. =)
11:53:14 <dmwit> Okay, I'll leave it at that in case that's enough explanation. But if it's not I'll try to add some details.
11:53:27 * hackage servant-streaming-client 0.2.0.0 - Client instances for the 'servant-streaming' package.  http://hackage.haskell.org/package/servant-streaming-client-0.2.0.0 (jkarni)
11:53:43 <cocreature> dmwit: sry, I was just curious if my guess was correct :)
11:53:48 <monochrom> We can delete "common". I just like to pair up "introduction" with "elimination" as per natural deduction.
11:54:42 <dmwit> I don't see how "subexpression elimination" is a good name for it, either.
11:55:43 * hackage servant-streaming-docs 0.2.0.0 - Client instances for the 'servant-docs' package.  http://hackage.haskell.org/package/servant-streaming-docs-0.2.0.0 (jkarni)
11:56:20 <monochrom> Then flip it around to get "temp var elimination" and "temp var intrdouction"!
11:56:31 <dmwit> monochrom: Here, I'll be more explicit. Imagine you see two subexpressions "1+2" and "1+3". CSE won't do anything; an outliner might extract `f=(1+)` and turn them into "f 2" and "f 3".
11:57:12 <monochrom> HIgher-order CSE will do it.
11:57:21 <dmwit> monochrom: By comparison, inlining might turn "f 2" and "f 3" into "1+2" and "1+3", which don't have common subexpressions.
11:57:52 <cocreature> it gets more interesting if you have something like a + 1 + b and a + 2 + b and you turn that into f x = a + x + b
11:58:02 <Tuplanolla> We've gone from "common subexpression introduction" to "subexpression introduction" to just "introduction".
11:58:04 <dmwit> monochrom: Okay, okay, how about seeing `1+10+2` and `1+11+2` and extracting `f x = 1+x+2`?
11:58:04 <monochrom> (Cf. "higher-order resolution" vs just "resolution", also "higher-order pattern matching" vs just "pattern matching")
11:58:04 * hackage servant-streaming-server 0.2.0.0 - Server instances for the 'servant-streaming' package.  http://hackage.haskell.org/package/servant-streaming-server-0.2.0.0 (jkarni)
11:58:12 <dmwit> monochrom: There really is no common subexpression there.
11:58:37 <monochrom> Although, the higher-order versions are pretty much uncomputable, so meh.
11:59:05 <monochrom> But higher-order resolution is specified to do that example too.
11:59:37 <dmwit> Huh, I don't know about resolution.
11:59:53 <Ariakenom> sharing - unsharing
12:00:10 <dmwit> That is... not an easy term to google for.
12:01:54 <Ariakenom> polateg - getalop
12:01:58 <dmwit> Oh dear. "The core of higher-order resolution (hereafter HORES)"
12:02:15 <monochrom> In theorem provers, a beginner may ask why you don't simply write down induction as "forall pred. (pred 0) and (forall n. pred n implies pred (n+1)) implies (forall n. pred n)", and let resolution or unification detect that it is applicable to "forall n. n + 1 = 1 + n"
12:03:04 <monochrom> And the answer is the same as why we don't usually regard "1+10+2 and 1+11+2 ==> \x -> 1 + x + 2" as an automatable CSE.
12:03:48 <monochrom> Both require higher-order unification, and: 1. Few people even think of doing it; 2. Then they find out it's really hard, like uncomputable hard.
12:04:32 <monochrom> Some of them settle for "higher-order pattern matching" which is less ambitious, more computable, and is good enough for many examples.
12:05:14 <monochrom> And I was one of those beginners.
12:06:12 <monochrom> So anyway in most theorem provers, induction is offered as its own command, rather than "oh just use resolution with a library theorem"
12:07:53 <glguy> More like <monologue> amirite?
12:08:30 <monochrom> Maybe I should talk to lambdabot in PM? >:)
12:08:32 <dmwit> I am in deep support of monochromologues.
12:09:43 <dmwit> Sometime when he isn't talking I go visit his website and read his archives.
12:09:49 <monochrom> haha
12:10:32 <Myrl-saki> How to know what directories GHC is searching at?
12:10:44 <monochrom> -v tells you
12:11:22 <Myrl-saki> package primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh overrides a previously defined package
12:12:01 <Myrl-saki> Is this telling me that I should provide the same primitive as GHC is compiled with??
12:16:50 <cocreature> Myrl-saki: I don’t think that’s necessarily an error?
12:17:08 <Myrl-saki> cocreature: `primitive` is causing my builds to fail.
12:17:31 <cocreature> Myrl-saki: so what’s the actual error message?
12:17:41 <Myrl-saki>  cannot find any of ["libHSprimitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh.a","libHSprimitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh.p_a","libHSprimitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh-g
12:17:43 <Myrl-saki>                    | hc8.0.2.so","libHSprimitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh-ghc8.0.2.dylib","HSprimitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh-ghc8.0.2.dll"] on library path
12:17:47 <Myrl-saki> Err
12:17:54 <Myrl-saki> Forgot to M-l on Weechat, sorry.
12:18:11 <Myrl-saki> And yeah, that file exists.
12:18:33 <Myrl-saki> Might have been PEBCAK, I don't check the search path of GHC.
12:18:36 <cocreature> it exists somewhere but probably not where GHC is searching :)
12:18:53 <Myrl-saki> cocreature: Most likely.
12:19:18 <Myrl-saki> cocreature: I just overrode my primitive override to use my system primitive.
12:19:23 * Myrl-saki shrugs
12:19:26 <Myrl-saki> Seems to be working now.
12:19:38 <cocreature> oh nix?
12:19:43 <Myrl-saki> Yep. :D
12:19:48 <reactormonk> Getting some errors even though the typeclasses seem to compile just fine, the invocation doesn't quite work - errors: https://gist.github.com/reactormonk/99c7b580b43d0437a2f0ac43682722f0 - code: https://github.com/reactormonk/modules
12:19:57 <Myrl-saki> Was using stackage2nix.
12:19:59 <cocreature> nix really didn’t seem to like me trying to override packages shipped with GHC when I last tried this
12:20:30 <Myrl-saki> cocreature: ++, but not overriding is even worse for me since I'm fetching a package from Github(reflex).
12:21:14 <cocreature> Myrl-saki: last I tried to do something like this I found this https://github.com/NixOS/nixpkgs/issues/25045
12:21:47 <cocreature> I don’t think peti’s comment is correct here since cabal and stack deal with this just fine but I’ve never figured out how to do this with nix
12:23:43 <Myrl-saki> Path of least resistance. And it works. Yay.
12:23:45 <Myrl-saki> :D
12:24:14 <cocreature> Myrl-saki: hm actually I have a project where I’m overriding primitive
12:24:19 <cocreature> and it works …
12:24:41 <cocreature> oh primitive isn’t even a boot package
12:25:11 <cocreature> ah nvm it is
12:25:27 <Myrl-saki> cocreature: I think there's something going on with Nix search paths.
12:26:12 <pseudonymous> Hey - I have a strange (though probably simple) error/issue. If I sit in ghci and type "import Control.Monad.Except", everything is fine. If I place the same statement in my Main.hs file, however. Everything blows up. I'm using the 'new-template' stack template (so stack + hpack (?))
12:26:18 <Myrl-saki> cocreature: Which is probably required for GHCJS, because GHCJS's boot packages is in a separate boot packages file, yet they override the main package list.
12:26:26 <dmwit> reactormonk: First step is to produce a minimal reproducing example.
12:26:34 <cocreature> Myrl-saki: hm yeah I definitely haven’t tried that with ghcjs
12:26:52 <dmwit> I don't know about other folks here, but I don't plan on trying to grok 200 lines of Haskell at a glance.
12:26:54 <glguy> pseudonymous: "everything blows up" probably isn't what the error message says
12:27:38 <dmwit> pseudonymous: How do you start ghci? How do you compile Main.hs? What is the exact error?
12:27:56 <dmwit> (...what is the exact code?)
12:28:17 <pseudonymous> No - very specifically, when I compile (using 'stack build --fast') I get this: https://lpaste.net/7717833274864697344
12:28:36 <cocreature> pseudonymous: you need to add mtl to your build-depends
12:28:36 <monochrom> scheme48 eh?!
12:28:57 <pseudonymous> monochrom: just a tutorial :)
12:29:04 <mnoonan> pseudonymous: if your package is split into a library and an app, maybe your app's dependencies aren't correct?
12:29:46 <monochrom> Very likely stack is more bureacracy than infrastructure for most beginner purposes.
12:29:48 <cocreature> "stack ghci" merges the flags for the different targets so if you miss a dep for the executable but have it in the lib it will still be present in "stack ghci"
12:30:05 <monochrom> I mean even cabal is.
12:30:21 <reactormonk> dmwit, I'm not sure I can really reduce the example... it's still gonna be 50 LoC of pure engine code
12:30:54 <mud> pseudonymous: What's in your package.yaml ?
12:31:16 <pseudonymous> cocreature: you were right :) But.. how would you know (except experience) ?
12:31:19 <reactormonk> let me check what I can cut, maybe it'll help
12:31:42 <Rembane> monochrom: I just got the impulse to create another way to handle dependencies for Haskell. A lightweight, beginner friendly way. This can't end well.
12:31:52 <cocreature> pseudonymous: a missing module error is usually either a typo or a missing build-depends
12:31:52 <monochrom> haha
12:32:12 <Rembane> monochrom: https://xkcd.com/927/
12:32:16 <lyxia> Rembane: effect book deps -> deps  this dependency looks fishy
12:32:27 <pseudonymous> Rembane: on behalf of all Haskell Noobs.. https://xkcd.com/927/ (grr, you beat me to it..)
12:32:40 <glguy> Rembane: Maybe add a new yaml file that generates this package.yaml and stack.yaml?
12:33:08 <lyxia> reactormonk: ^ (sorry Rembane)
12:33:12 <monochrom> Don't forget foo.cabal
12:33:16 <epta> what is a proper way to generate ctags in vim nowadays? (automatically on save)
12:33:23 <glguy> monochrom: That gets generated from the generated package.yaml
12:33:25 <Rembane> pseudonymous: ^^
12:33:35 <cocreature> how about a toml file that generates a yaml file, that would be refreshing!
12:33:45 <Rembane> glguy: Nah! dhall file!
12:33:55 <reactormonk> lyxia, huh, thanks. Now I get a different error
12:34:08 <Rembane> lyxia: No worries. :)
12:34:11 <pseudonymous> cocreature: I am mostly fumbling through this (that is, project- and dependency management). That said, I'm beginning to realise there's dependencies (something provided by a resolver..?) and extra-deps.. Do you know of a resource/link which actually takes the time to describe this ?
12:34:37 <dmwit> epta: I don't do that. But if I wanted to, I'd probably use my `vim-yard` to indicate to vim where the project root is and my `cabtags` to generate the tags.
12:35:00 <dmwit> epta: https://github.com/dmwit/vim-yard and https://github.com/dmwit/cabtags
12:35:46 <dmwit> epta: Or if you're asking more generally how to run an action on each save, check out `:help au`.
12:36:14 <pseudonymous> What really confused me is that 'ghci' would allow the import of 'Control.Monad.Except' which the stack project (or 'stack ghci') wouldn't.. So haskell's own GHCI apparently will pull in more stuff than a new stack project ?
12:36:16 <glguy> pseudonymous: stack is an extra layer to learn for orchestrating the build process for complex projects
12:36:32 <glguy> It has a documentation website you can read
12:36:57 <reactormonk> in the error message https://gist.github.com/reactormonk/9065c4e007c5ba00cd3fdbb567868d37 does that mean the compile could infer depTail, or does it just mention the first one it can't?
12:37:09 <monochrom> stack is a build tool and many more things that, for sanity-check reasons, requires you to list all packages you use.
12:37:19 <epta> dmwit: cool!
12:37:22 <lyxia> reactormonk: I think you need a CanCook constraint on finish. Even though there is a universal instance, you get stuck trying to solve "HasRecipe effect target book deps" because that choice depends on the type "book".
12:37:26 <cocreature> pseudonymous: I already gave the likely explanation for why "stack ghci" has more deps available a few lines above
12:37:47 <cocreature> pseudonymous: and https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/ should probably be helpful
12:38:03 <reactormonk> lyxia, but I don't have the deps type on finish
12:39:22 <monochrom> You are at a point where it is like some European royal family is giving their blessing to the marriage between you and a prince or princess you are in love with. Congratulations!
12:39:31 <lyxia> reactormonk: the CanCook class has no deps arguments though
12:39:47 <monochrom> But then they say: First, before the wedding, take one year to learn royal stack etiquette...
12:40:35 <reactormonk> lyxia, does have state1 (that one I know, it's '[]), and state2 (that one I don't know, inferred by the computation)
12:44:59 <pseudonymous> glguy: I have browsed, though most pages fail to offer much explanation beyond the instructions. So I still run into issues such as these. I do learn bits and pieces from the wiki, but it's fragmented and sometimes only makes sense after I've gotten some information from here :)
12:46:05 <lyxia> reactormonk: you can have finish :: forall book state2 effect target. CanCook book '[] state2 effect target => ...
12:47:27 <setre> this program uses all my memory (i think) if ran with very large numbers. why? https://lpaste.net/5929351408968007680
12:47:39 <mud> pseudonymous: It does tend to be a little confusing. Have you read the page that cocreature linked to? It's an important one for understanding, though it's a little concise.
12:49:38 <reactormonk> lyxia, I'm already passing state1 - with `nil` - so it should already be determined?
12:51:00 <reactormonk> although with removing that recursive fundep, I'm now getting some interesting errors - https://gist.github.com/reactormonk/0546f1e742ee9c58a969622d408e01f4
12:51:24 <dmwit> setre: You'll probably get better behavior with `super [p] = [p]; super p = super $ ...`.
12:51:46 <dmwit> setre: Calling `length` forces the entire input list into memory, whereas a pattern match only forces the first one or two cons cells.
12:52:18 <pseudonymous> mud: yes, just gave it a read :)
12:52:20 <setre> dmwit: oh thanks. I'll try this
12:53:13 <dmwit> setre: You might also like `genericReplicate :: Integer -> [a] -> [a]` as a replacement for `take (fromIntegral k) . repeat`.
12:53:39 <dmwit> Shouldn't affect performance at all, but it's nice knowing about these kinds of library functions. =)
12:54:27 <dmwit> setre: If you still have bad performance after removing `length`, my next guess would be `sum`. Turning on `-O2` or changing `sum` to `foldl' (+) 0` should help with that.
12:54:35 <shachaf> pA lot of the generic functions are a bad idea, aren't they?
12:54:45 <setre> dmwit: thanks!
12:55:06 <dmwit> setre: (For historical reasons, `sum` is implemented with `foldr`. There are some hacks in place to make it do the more efficient thing if it knows to, but I'm always distrusting of those for probably no good reason.)
12:55:10 <shachaf> Much better to use (fromInteger . length) than genericLength, except if you're using lazy naturals
12:56:18 <cocreature> setre: glguy already mentioned this before but it still applies: instead of taking the digital sum after replicating the string k times you can take the digital sum of the original string and multiply it by k
12:56:28 <cocreature> shachaf: genericReplicate looks pretty reasonable
12:56:35 <cocreature> dmwit: sum is a foldl for lists
12:56:46 <dmwit> Oops, yes.
12:56:46 <shachaf> @src genericReplicate
12:56:46 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:56:51 <cocreature> it’s still bad because it should be a foldl' but at least GHC’s strictness analyzer usually catches this
12:56:55 <dmwit> Either way, `foldl'` is going to be better.
12:56:57 <setre> cocreature: right thanks
12:57:51 <cocreature> every two weeks or so I’m tempted to try to change the definition of sum and product but I just can’t bring myself to deal with the bikeshedding that will surely arise from this
12:58:23 <dmwit> But mah lazy nats!
12:58:46 <dmwit> Which I have literally used once to show somebody how they worked and never touched again because for real code they're awful.
12:58:47 <cocreature> don’t you want a foldr for that rather than a foldl?
12:59:02 <mud> dmwit: They are cool though xD
12:59:25 <dmwit> Leaving the list as a list is a more efficient lazy nat anyway.
12:59:33 <shachaf> dmwit: Some people would say the same thing about lists!
12:59:36 <setre> with -O2 my solution is very fast but not without :)
12:59:45 <dmwit> s/+/++/g;s/*/>>/g
13:00:08 <cocreature> setre: yeah that sounds like the shitty definition of sum that is being optimized to a better version
13:00:17 <shachaf> i,i is a function :: Nat -> Nat a natural transformation?
13:00:42 <setre> foldl (+) 0 is good or bad?
13:00:43 <glguy> Naturally
13:00:52 <dmwit> setre: v. bad
13:00:56 <cocreature> setre: foldl' (+) 0 is the good definition
13:01:04 <dmwit> setre: Not as good for lazy numbers as foldr, not as good for strict numbers as foldl'
13:01:15 <setre> cool
13:01:28 <cocreature> it does at least have the advantage over foldr that GHC can optimize it to a foldl' :)
13:01:36 <cocreature> so I’d say it’s not quite as bad as foldr (+) 0 :)
13:01:36 <dmwit> heh
13:02:10 <zezeri> for haskell noobs, are there any easy projects you guys can recommend doing?
13:02:27 <zezeri> I would like to start doing (something very very simple) that is practical at least in some way
13:02:30 <cocreature> zezeri: depends on what you’re interested in
13:02:30 <dmwit> Project Euler is a popular choice.
13:02:45 <cocreature> scheme in 48h is a popular tutorial where you build a scheme interpreter
13:02:47 <shachaf> Speaking of the naturals, it's really pretty surprising that Nat -> Nat is homeomorphic to the irrationals, isn't it
13:02:47 <maerwald> zezeri: do you have gui experience?
13:03:06 <glguy> zezeri: Advent of Code has a bunch of little programming exercises
13:03:12 <shachaf> Maybe I shouldn't be too surprised.
13:03:21 <cocreature> shachaf: hm interesting, never thought about that
13:03:42 <dmwit> shachaf: I don't know what homeomorphic means, but "an infinite list of digits" is pretty irrationals-like.
13:03:55 <dmwit> And you don't even have to have the codomain be as big as Nat to get that.
13:04:09 <maerwald> probably a ct term for something banal
13:04:14 <shachaf> dmwit: No, it's not a list of digits, it's a list of naturals
13:04:26 <dmwit> Yes, I know.
13:04:34 <glguy> zezeri: if you want a bigger project, make a program you're interested in
13:04:34 <shachaf> Nat -> Bool is quite different from the reals/irrationals
13:04:55 <shachaf> The homeomorphism is via continued fractions, I think
13:05:16 <zezeri> I will be looking into both advent of code and project euler.
13:05:22 <zezeri> Those are some great suggestions, thanks everyone :)
13:05:32 <shachaf> Anyway this is offtopic in here
13:05:38 <glguy> Project Euler will teach you more number theory than programming
13:06:00 <zezeri> cocreature : I like game/engine dev.
13:06:06 <zezeri> but that is not necessarily haskells domain, i know.
13:06:31 <zezeri> maybe to evaluate/parse/analyse diffable asses
13:06:35 <zezeri> *assets not asses
13:07:06 <cocreature> zezeri: well you might not want to build some 60fps 3d shooter in Haskell but building some 2d platformer or something like that works just fine.
13:07:14 <cocreature> zezeri: http://jxv.io/blog/2018-02-28-A-Game-in-Haskell.html is a pretty nice overview
13:07:40 <zezeri> i mean ideally I would like to make something where haskell can really "shine". A typical game is probably not that.
13:08:00 <zezeri> still a very cool link, cocreature I will check it out
13:08:09 <rotaerk> I just wanna see if there is sufficient capability to work around the GC pause in order to be able to make a "60pfs 3d shooter"
13:08:16 <rotaerk> fps *
13:08:40 <maerwald> cocreature: what you linked to involves non-trivial concepts
13:08:47 <rotaerk> not that I actually want to make a shooter...
13:08:59 <cocreature> zezeri: I’d say Haskell is a pretty decent language for making a small game so I wouldn’t let that stop you if you like making games
13:09:21 <maerwald> I would advise against that adventure, but anyway
13:09:40 <maerwald> more likely it will lead to frustration and confusion about advanced concepts
13:09:56 <setre> monad transformer stacks?
13:10:06 <cocreature> especially for these kind of learning projects, having fun and not losing motivation is the most important part
13:10:43 <zezeri> I mean I am aware you can do anything with haskell. In an ideal world I would like to do something that really lends itself to haskell and demonstrates me why it is an awesome language. (I have seen glimpses of it in the trivial exercises and learning i have doen os far)
13:11:19 <maerwald> parsing, lol
13:11:25 <glguy> zezeri: the most important thing is that you are interested in the project you pick so that you actually stick with it
13:11:27 <cocreature> my point is Haskell is not as ill-suited to making games as you might think so you can certainly learn why it’s an awesome language
13:11:33 <setre> is pandoc a solid example of a great haskell application. it parses and translates between document formats
13:11:52 <maerwald> the parsing part is great, probably, the other parts is up to taste
13:12:09 <mud> setre: I find it quite useful personally. I haven't actually looked at the code for it though.
13:12:41 <mnoonan> shachaf: is "homeomorphic" really the word you want here? do you just mean isomorphic as sets?
13:13:54 <zezeri> You are correct in saying that it is most important finding a project that you are passionate about so that you retain motivation.
13:14:20 <maerwald> if you like gui programming there are lots of useful things
13:14:42 <maerwald> and not that complicated (if you are familiar with the gui toolkits already)
13:14:42 <rotaerk> the main reason that haskell isn't the best language for games is that it's not Unreal, Unity, CryEngine, etc
13:15:05 <zezeri> Games and engines also need supporting tools obv
13:15:11 <zezeri> i.e. analysing level files
13:15:22 <maerwald> and reliable performance
13:15:47 <maerwald> there's just too much know-how in other languages, that no one bothers
13:16:05 <zezeri> yeah, that is true
13:16:30 <zezeri> it was mentioned that parsing is  one of the most remarkable practical uses
13:16:39 <shachaf> mnoonan: I mean homeomorphic
13:16:45 <maerwald> write an SQL parser
13:16:51 <maerwald> that could be fun
13:16:57 <maerwald> could start with a subset of SQL
13:16:57 <shachaf> But maybe I'm not talking about Haskell, which is why this is a bit off-topic. :-)
13:17:01 <shachaf> (But maybe I am!)
13:17:02 <tdammers> there's another reason why Haskell isn't very strong in games
13:17:05 <rotaerk> not an oracle SQL parser, though
13:17:14 <rotaerk> ugh
13:17:21 <tdammers> which is that in game programming, "fake it 'till you make it" often just means faking it forever
13:17:23 <mnoonan> shachaf: ok, I'll bite.. what topology on N -> N?
13:18:00 <tdammers> games take dirty shortcuts, that's kind of how it's done, more or less
13:18:04 <maerwald> tdammers: I think it's also the dev workflow overall, yes
13:18:14 <tdammers> more like the economics
13:18:33 <zezeri> it depends highly.
13:18:46 <zezeri> also note engine dev vs game dev
13:18:50 <maerwald> in haskell you would have to worry and reason about effects a lot up-front and then smash in your own teeth, because your architecture forces you to rewrite stuff
13:18:54 <tdammers> a game doesn't usually see 10+ years of ongoing development - you write it, you ship it, and then maybe ship a handful of bugfix releases
13:19:09 <zezeri> i think if haskell has potential for gamedev it is probably for some supporting stuff
13:19:11 <maerwald> exactly, you don't refactor
13:19:13 <tdammers> ofc, engines *do* see 10+ years of development
13:19:14 <zezeri> analysing assets, converting
13:19:26 <shachaf> mnoonan: Product topology, I guess?
13:19:33 <zezeri> imagine you have a huge level with like ~50k entities
13:19:35 <tdammers> but then again, engines are exactly the part where realtime-ish performance considerations become paramount
13:19:45 <zezeri> and each entity has ~20 properties
13:20:07 <zezeri> but i guess you would just use python for that?
13:20:08 <zezeri> dunno.
13:20:24 <tdammers> I love haskell to pieces, but I don't think a nontrivial game engine is something that I would want to write in it
13:20:48 <maerwald> yes, you would pick clojure
13:20:54 <tdammers> lol no
13:20:56 <maerwald> xD
13:21:16 <zezeri> i understand that tdammers. I think you would want to use haskell only as a supplementary tool to the engine. Aka none of the actual engine code is haskell. YOu just use it to work with asset files the engine produced.
13:21:18 <zezeri> for example
13:21:19 <tdammers> however for, say, something like an MMORPG, Haskell would be perfect IMO
13:21:32 <maerwald> an mmorpg framework could be interesting
13:21:35 <setre> I found jekor's video on analysing the game toy Cuboid (it's on youtube) pretty cool
13:21:36 <zezeri> to exploit the ability to iterate fast and multithread with haskell
13:21:45 <tdammers> yeah, or maybe use haskell for the high-level stuff, driving an engine written mostly in C++
13:22:01 <zezeri> even there i imagine you would be writing in C style most of the time
13:22:01 <tdammers> (or, idk, maybe rust? haven't looked into that deeply enough yet)
13:22:09 <zezeri> and thus not really playing to haskells strengths
13:22:28 <zezeri> isnt the "flashy prime example" of haskell that facebook anti spam project they have going?
13:22:33 <mnoonan> shachaf: on further reflection, it *is* obvious from your "continued fraction" hint. The best kind of obvious :)
13:22:34 <maerwald> tdammers: once I was offered a job for casino games and they actually had the idea to make some kind of declarative DSL to easily build custom games from generic building blocks. I think haskell would be a good fit there
13:22:46 <tdammers> however, if an alternative runtime were available that were more suitable for low-latency programming, then maybe Haskell could do more in this area
13:23:01 <tdammers> maerwald: definitely, that's the other direction I was thinking in
13:23:10 <tdammers> a bit like how people use Haskell for embedded
13:23:43 <dufferz> what is up, my dudes?
13:24:12 <zezeri> we are developing a game engine in haskell
13:24:13 <zezeri> you?
13:24:20 <maerwald> no, we are dreaming xD
13:24:26 <rotaerk> pretending to develop *
13:24:47 <maerwald> hey, we are coming up with a concept first :P that's what haskellers do
13:25:19 <dufferz> awesome, sounds productive
13:25:28 <mnoonan> I think doing a wolf3d-ish game would be pretty fun
13:25:50 <mnoonan> (and accessible, especially if you weren't too worried about performance)
13:25:59 <zezeri> https://store.steampowered.com/app/299740/Miscreated/
13:26:04 <zezeri> they have one huge levels
13:26:08 <zezeri> *one huge level
13:26:19 <zezeri> with thousands of entities/actors and each has a lot of properties
13:26:33 <zezeri> they did some tools to analyse all these entities and their properties and see if there were bad values
13:26:42 <zezeri> (think a light that had a huge radius or way too high multiplier)
13:26:57 <zezeri> that kind of stuff i could imagine haskell being useful
13:30:31 <rotaerk> pfft, you make it sound like haskell's greatness is only applicable in niche contexts
13:30:42 <rotaerk> *cough*
13:30:45 <ddellacosta> [emacs filter] anyone using interactive-haskell-mode with evil-mode? I'm annoyed by the fact that it doesn't seem to know where the beginning of the line is, taking the cursor into account, and not sure what I need to fix it
13:31:00 <ddellacosta> taking the prompt into account, rather
13:31:22 <iqubic> ddellacosta: I am running into the same exact issue. I don't have a fix, sorry.
13:31:39 <ddellacosta> iqubic: np--I'll ping you if I figure something out!
13:36:27 <dmwit> Yay, I figured out what I want the semantics to be, now I just have to figure out how to make it not incredibly inefficient.
13:41:36 <tdammers> I don't know what you guys are doing, but I'm mainly trying to find reasons *not* to build a game engine in Haskell
13:42:32 <zezeri> tdammers https://np.reddit.com/r/rust/comments/78bowa/hey_this_is_kyren_from_chucklefish_we_make_and/doslvsb/
13:42:40 <zezeri> some reasons are mentioend here.
13:42:53 <zezeri> and some others have been mentioend when we discussed it earlier
13:43:08 <tdammers> well, actually the best reason is that I have too many side projects already, and about 100 ideas for more
13:45:54 <dmwit> Okay, so. I'm going to build a collection of `[(a, Int)]`s. (Actually, it will be very common to have a run of equal `a`s with increasing `Int`s, so it will be run-length encoded to something like `[(a, (Int {- start -}, Int {- length -}))]`.)
13:46:34 <dmwit> I'd like to do some operations on it, like, given an `[(a, Int)]`, find if any of the elements in the collection are superstrings of it.
13:47:02 <dmwit> Let's say that's the only operation I care about. What would be an efficient data structure?
13:47:12 <foobert> For some reason I can't wrap my head around the liftIO instances. Doesn't matter which, currently I am looking at `instance MonadIO (ReaderT r m)`. `liftIO` has a `IO a -> m a` type signature. So it takes an IO and embeds the value of that IO in another monad. But then why does every instance use liftIO as well. As in `liftIO = lift . liftIO`? That surely looks infinitely recursive... how does this ever stop or rather work? And yes 
13:47:40 <dmwit> foobert: Because the "recursive" `liftIO` has a different choice of `m`.
13:47:59 <dmwit> foobert: In `liftIO :: IO a -> ReaderT r m a`, we call `liftIO :: IO a -> m a`.
13:48:03 <tdammers> the other day I ran into this kind of syntax... the Int {- length -} thing... and it took me a solid 15 minutes to realize that it's not some weird GHC extension, but just plain old comments
13:48:28 <hpc> haha
13:48:55 <hpc> yeah, i am definitely more used to seeing -- comments
13:49:07 <dmwit> foobert: Essentially the final expansion of `liftIO` is a chain of calls to `lift`, one for each transformer.
13:50:29 <dmwit> foobert: (By the way, everything after "And yes" got cut off.)
13:50:49 <foobert> It was "And yes I'm a beginner" so not much of value was lost ;)
13:51:31 <foobert> Maybe I just need to sleep over this for it to click but it seems like each transformer just adds another "lift . liftIO" so even though a different liftIO is used, it still ends up being "lift . lift . [lift . ]
13:51:47 <dmwit> foobert: Yes, that's exactly correct.
13:51:50 <foobert> Without it ever finishing
13:52:03 <dmwit> foobert: And since there's a finite number of transformers before you bottom out at `IO`, there's a finite chain of `lift`s.
13:52:46 <rotaerk> :t liftIO (undefined :: IO a)
13:52:47 <lambdabot> MonadIO m => m a
13:53:23 <iqubic> ddellacosta: You left #emacs without solving your issue? Why?
13:53:36 <dmwit> foobert: So for `ReaderT r (StateT s (ExceptT e IO))`, you get `liftIO @(R (S (E IO))) = lift . liftIO @(S (E IO)) = lift . lift . liftIO @(E IO) = lift . lift . lift . liftIO @IO = lift . lift . lift . id`
13:53:42 <rotaerk> note there's a #haskell-emacs channel
13:54:04 <iqubic> ddellacosta: ^^^
13:54:58 <dmwit> re: my question, perhaps it is time to learn about suffix trees (?)
13:55:00 <foobert> dmwit: Oh my god I was completely missing the `liftIO = id` part.
13:55:10 <foobert> dmwit: Thanks, now it's crystal clear
13:55:31 <dmwit> Although it seems like the run-length encoding part is going to be hard to deal with.
13:56:07 <foobert> dmwit++
13:56:12 <foobert> (no idea if that works)
13:56:28 <ZeuPiark> hello
13:56:29 <rotaerk> don't, you'll make him fat
13:56:47 <dmwit> foobert: it works =)
13:56:53 <atchoum> I was thinking about fat
13:58:01 <atchoum> __monty__: you seem pretty motivated to make Haskell a better language for newcomers and non-experts. Have you a community of your own in the community ?
13:58:03 * hackage generic-data 0.1.1.0 - Utilities for GHC.Generics  http://hackage.haskell.org/package/generic-data-0.1.1.0 (lyxia)
13:59:05 <atchoum> especially this post: https://www.snoyman.com/blog/2017/01/safe-prelude-a-thought-experiment
13:59:12 * hackage Persistence 1.1 - Quickly detect clusters and holes in data.  http://hackage.haskell.org/package/Persistence-1.1 (Ebanflo)
14:03:28 <iqubic> atchoum: that artical seems to suggest that we should change the type signature of head to "head :: [a] -> Maybe a" which seems thunderingly inconvenient
14:03:45 <atchoum> iqubic: why not after all
14:04:18 <atchoum> iqubic: it's either that or have a good exception handling system
14:06:06 <atchoum> that's actually a good question because it does seem to raise a good controversy. Indeed, it maybe absolutely clumsy to have to treat the return value of `head` as a Maybe, but that's what we intend to do with Haskell. To have purity has much as possible through fancy design patterns. In my opinion, such a flaw could be answered by addressing the proper design pattern to deal with the result of `Maybe`. Don't you think ?
14:07:24 <atchoum> I dunno but in my short haskell experience, I encountered plenty of situations with partial functions, and to know how to adress a return value of Maybe without cluttering a program can be a very interesting pattern to learn.
14:08:45 <atchoum> what do you think ?
14:09:23 <iqubic> If you have a function that can return a Maybe a then you can get rid of it by using this function:
14:09:30 <iqubic> :t maybe
14:09:32 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:09:51 <atchoum> yes I know this function.
14:10:30 <Eduard_Munteanu> Depends on how you want to handle errors. If you want to ignore missing values in monadic code, you can use stuff like forM_.
14:10:51 <atchoum> that's the analogous of continue ?
14:10:57 <iqubic> no.
14:11:05 <iqubic> :t forM_
14:11:06 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
14:11:51 <iqubic> Basically it takes a list of monadic actions and runs them all in sequence, while ignoring all the results that get created.
14:11:59 <nshepperd> 'head :: [a] -> Maybe a' seems pointless to me. unless you happen to be in a monadic Maybe context already, you'll have to pattern match to eat the output. in which case you would have just pattern matched on the list itself already
14:12:10 <__monty__> atchoum: I try to help where I can, mostly just a coincidence I saw your questions tbh and I saw an opportunity to promote nix ; )
14:12:28 <Eduard_Munteanu> > do { mx <- return (Just 2); forM_ mx $ \x -> return x} :: Identity Int
14:12:30 <lambdabot>  error:
14:12:30 <lambdabot>      • Couldn't match type ‘()’ with ‘Int’
14:12:30 <lambdabot>        Expected type: Identity Int
14:12:41 <Eduard_Munteanu> > do { mx <- return (Just 2); forM mx $ \x -> return x} :: Identity Int
14:12:43 <lambdabot>  error:
14:12:43 <lambdabot>      • Couldn't match type ‘Maybe Integer’ with ‘Int’
14:12:43 <lambdabot>        Expected type: Identity Int
14:13:21 <iqubic> Eduard_Munteanu: it's trying to match the final return of forM_ (M ()) with Identity Int.
14:13:30 <atchoum> say for a good example you have a list of integers, and a function that returns a Maybe Int if the integer is a multiple of 3
14:13:38 <atchoum> Nothing otherly.
14:14:05 <iqubic> > do { mx <- return (Just 2); (forM mx $ \x -> return x} :: Identity Int)
14:14:07 <lambdabot>  <hint>:1:54: error: parse error on input ‘}’
14:14:13 <dmwit> :t foldr . (const .)
14:14:14 <lambdabot> Foldable t => (a -> b) -> b -> t a -> b
14:14:19 <iqubic> Huh?!?
14:14:44 <Logio> I don't see why head :: [a] -> Maybe a is any more controversial than say, lookup :: a -> [(a,b)] -> Maybe b
14:14:46 <atchoum> > forM_ [1,2,4,6,8,9] (if (x%3) == 0 then Just x else Nothing)
14:14:48 <lambdabot>  error:
14:14:48 <lambdabot>      • Couldn't match expected type ‘Integer -> m b0’
14:14:48 <lambdabot>                    with actual type ‘Maybe Expr’
14:14:55 <Eduard_Munteanu> > do { mx <- return (Just 2); (forM mx $ \x -> return x) :: Identity Int }
14:14:56 <__monty__> atchoum: #haskell is a pretty wonderful place as far as irc goes, I merely mimic others' behavior.
14:14:57 <lambdabot>  error:
14:14:57 <lambdabot>      • Couldn't match type ‘Maybe Integer’ with ‘Int’
14:14:57 <lambdabot>        Expected type: Identity Int
14:15:04 <dmwit> Logio: FWIW, I think it should be `lookup :: a -> [(a, b)] -> [b]`. =P
14:15:09 <atchoum> > forM_ [1,2,4,6,8,9] (\x -> if (x%3) == 0 then Just x else Nothing)
14:15:11 <lambdabot>  Nothing
14:15:34 <nshepperd> i can count on one finger the number of times I've used listToMaybe
14:15:38 <atchoum> > forM [1,2,4,6,8,9] (\x -> if (x%3) == 0 then Just x else Nothing)
14:15:40 <Logio> dmwit: oh, right!
14:15:40 <lambdabot>  Nothing
14:15:55 <atchoum> :t forM
14:15:56 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
14:16:02 <dminuoso> atchoum: why not use filter in that case
14:16:14 <dmwit> ...with the requisite `Eq a`, of course.
14:16:26 <Eduard_Munteanu> I'm not sure why it doesn't like my example.
14:16:33 <atchoum> dminuoso: dunno talking about Maybe`s and List`s and Monad`s
14:16:36 <iqubic> nshepperd: I can count the number of times I've used listToMaybe with out using any fingers. It's 0 times.
14:16:49 <iqubic> I really need to write more haskell code.
14:17:00 <mniip> I've used maybeToList
14:17:15 <dminuoso> I used listToMaybe a few times in tandem with list comprehensions
14:17:22 <iqubic> :t maybeToList
14:17:23 <lambdabot> Maybe a -> [a]
14:17:24 <dmwit> Eduard_Munteanu: Because `forM mx return :: Identity (Maybe Int)`.
14:17:37 <iqubic> mniip: why? Why do we want that?
14:17:46 <dminuoso> e.g.: maybeToList [x | F x <- as]
14:17:46 <Eduard_Munteanu> Oh, duh.
14:18:12 <dminuoso> err listToMaybe!
14:19:19 <Eduard_Munteanu> > do { mx <- return (Just 2); forM_ mx $ \x -> return () } :: Identity ()
14:19:21 <iqubic> is F x just pattern matching on the elements of as?
14:19:21 <lambdabot>  Identity ()
14:20:00 <atchoum> what is Identity ?
14:20:18 <Eduard_Munteanu> atchoum, a somewhat trivial monad
14:20:23 <iqubic> Data Identity x = Identity x
14:20:44 <atchoum> so a type is a monad ?
14:20:51 <iqubic> Sure.
14:20:52 <Eduard_Munteanu> Sure.
14:21:03 <iqubic> Instance Monad Identity where...
14:21:15 <Eduard_Munteanu> :k Monad
14:21:17 <lambdabot> (* -> *) -> Constraint
14:21:21 <iqubic> Sure.
14:21:35 <iqubic> :k Identity
14:21:36 <lambdabot> * -> *
14:21:41 <atchoum> So everything is a monad ?
14:21:48 <Eduard_Munteanu> No. :(
14:21:50 <ZeuPiark> bye
14:22:03 <atchoum> too bad
14:22:06 <Eduard_Munteanu> Just certain type functions.
14:22:09 <iqubic> No. Only things for which the Instance declaration of Monad has been created.
14:22:26 <atchoum> iqubic: that's haskell-centric dont you think :p ?
14:22:48 <iqubic> yes. But this is a haskell channel, so I'm going to be haskell centric.
14:22:51 <awesomeaniruddh> Are there functions that make dealing with (Int, Int) nice?
14:23:07 <awesomeaniruddh> I.e., is there a better way of expressing this for example: \(x,y) -> x + y
14:23:13 <dmwit> :t uncurry (+)
14:23:14 <lambdabot> Num c => (c, c) -> c
14:23:28 <ddellacosta> > uncurry (+) (1,2)
14:23:30 <lambdabot>  3
14:23:46 <dmwit> uncurry is the catamorphism for (,)
14:23:51 <Eduard_Munteanu> :t let f x y = x + y in uncurry f
14:23:52 <lambdabot> Num c => (c, c) -> c
14:24:00 <iqubic> It is? What's a catamorphism?
14:24:16 <awesomeaniruddh> :t uncurry
14:24:17 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:24:28 <atchoum> I was actually realizing that monad's analogies are everywhere
14:24:31 <dmwit> A catomorphism is a conversion from a data type to its Church-encoded form.
14:24:31 <awesomeaniruddh> Nice
14:24:52 <iqubic> dmwit: so foldr is the catamorphism for lists?
14:24:56 <ddellacosta> awesomeaniruddh: there are some ways to use Arrows and also BiFunctor too for various operations on (some) tuples
14:24:59 <dmwit> ...but usually with arguments flipped to be more convenient for common usage. =)
14:25:03 <dmwit> iqubic: right
14:25:10 <dmwit> iqubic: And `maybe` is the catamorphism for `Maybe`.
14:25:21 <Eduard_Munteanu> Catomorphism sounds like a shapeshifting cat.
14:25:29 <ysangkok> reminds me of https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/
14:25:40 <iqubic> So cata is the generic catamorphism?
14:25:41 <glguy> atchoum: To have an instance of the Monad class you need a type with kind * -> *, and you need implementations of return and (>>=) using that type that satisfy the documented laws for the Monad class
14:25:48 <ddellacosta> dmwit: I thought catamorphism was only related to recursion schemes, didn't realize it was more general
14:25:53 <dmwit> ysangkok: Right, that's the generic way to construct catamorphisms.
14:25:55 <iqubic> Yeah, me too.
14:26:06 <ddellacosta> or maybe recursion schemes are more general than I understood...
14:26:07 <dmwit> (,) is a recursive type which happens not to recurse. =)
14:26:10 <monochrom> Eduard_Munteanu: Indeed, http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
14:26:16 <ddellacosta> dmwit: aha...interesting
14:26:19 <atchoum> sorry what's a `kind` ?
14:26:31 <iqubic> dmwit: isn't tat a paradox, or a contadiction?
14:26:34 <dmwit> atchoum: Computations are classified by types. Types are classified by kinds.
14:26:35 <ddellacosta> atchoum: type of the type...think the next higher level up
14:26:36 <mnoonan> value is to type as type is to kind
14:26:38 <Eduard_Munteanu> :D
14:26:45 <dmwit> iqubic: Pretty zen, isn't it?
14:26:47 <glguy> atchoum: What are you using to learn Haskell, kinds a very likely to be covered in it
14:26:49 <iqubic> yes.
14:27:09 <atchoum> right now i'm in structure and interpretation of computer languages.
14:27:22 <Eduard_Munteanu> :k *
14:27:23 <lambdabot> error:
14:27:23 <lambdabot>     Not in scope: type constructor or class ‘*’
14:27:23 <lambdabot> error: Operator applied to too few arguments: *
14:27:33 <iqubic> :k (*)
14:27:34 <lambdabot> error:
14:27:34 <lambdabot>     Not in scope: type constructor or class ‘*’
14:27:35 <atchoum> but I was looking for something maybe more theoretical and related with type theory.
14:27:42 <atchoum> (and Haskell).
14:27:46 <dmwit> TaPL is nice.
14:27:48 <dmwit> ?where tapl
14:27:48 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
14:27:54 <mnoonan> ^ TaPL++
14:27:54 <Eduard_Munteanu> I was going to mention sorts.  :)
14:28:01 <glguy> atchoum: Do you mean "computer programs"?
14:28:12 <iqubic> Eduard_Munteanu: what are sorts?
14:28:26 <monochrom> Yeah I would love to have "structure and interpretation of computer languages" exist. :)
14:28:32 <Eduard_Munteanu> iqubic, "types" of kinds
14:28:36 <monochrom> Hell maybe I should write it myself!
14:28:42 <iqubic> I see. Why do we need sorts?
14:28:47 <ddellacosta> monochrom: sign me up
14:28:49 <atchoum> glguy: yes
14:29:12 <glguy> atchoum: You'll need to pick some material that teaches Haskell to learn Haskell specific things
14:29:18 <dmwit> monochrom: Dunno if you saw my question about data structures earlier, but I feel you would be especially likely to know the answer in case you didn't.
14:29:33 <Eduard_Munteanu> iqubic, well, we have kind functions and all that, which needs to be typed
14:29:42 <glguy> iqubic: Because you're going to start writing programs one day and you'd like some compile time checking that your program is structured correctly
14:30:04 <iqubic> I see. I will start writing programs one of these days.
14:30:38 <Eduard_Munteanu> iqubic, but you can't really write sorts in Haskell code, although the compiler can tell you about them
14:30:39 <iqubic> Haskell is a lazy language, and I am a lazy programmer. It's like we were meant for each other. /s
14:31:02 * hackage data-diverse 4.1.0.0 - Extensible records and polymorphic variants.  http://hackage.haskell.org/package/data-diverse-4.1.0.0 (louispan)
14:31:08 <monochrom> Types are invariants.
14:32:10 <monochrom> With most decidable type systems, types are very easy data invariants.  By the time you get to full-blown dependent types, they're general-purpose invariants.
14:33:15 <Eduard_Munteanu> With DTs you usually get an infinite hierarchy of types, kinds, sorts etc.
14:33:24 <Myrl-saki> cocreature: Apparently, I had a ~/.ghc directory, and guess what was interfering with my builds. Yeah..
14:34:29 <mnoonan> is there any worse sin than giving a distinct name to the third member of an obviously infinite list?
14:34:46 <monochrom> Yeah. 4th member. >:)
14:34:57 <mnoonan> inconceivable!
14:35:05 <Eduard_Munteanu> In Agda it's infinite plus one (omega), because you can write stuff that's polymorphic in the hierarchy level.
14:35:53 <iqubic> agda sounds complex
14:37:18 <Eduard_Munteanu> Not very. It looks much like Haskell for basic stuff.
14:37:27 <dmwit> mnoonan: Yeah, deciding that since the list is obviously finite we should just equate all the elements after the first.
14:38:08 <iqubic> Eduard_Munteanu: But dependent types really confusing.
14:38:44 <monochrom> All confusions are caused by wrong presumptions.
14:38:56 <ysangkok> iqubic: they seem really intuitive in the idris book
14:39:03 <ysangkok> iqubic: i can really recommend it
14:39:03 <monochrom> Especially since dependent type systems are very logical.
14:39:04 <Eduard_Munteanu> iqubic, here's the lists definition for example: https://github.com/agda/agda-stdlib/blob/master/src/Data/List/Base.agda
14:39:28 <Eduard_Munteanu> Other than having types parametrized by universe level, it's fairly Haskell-like.
14:39:31 <dmwit> monochrom: Counterpoint: some confusions are caused by having a working set limited to 7 items.
14:39:35 <monochrom> I mean, hell, dependent type systems are equivalent to the very definition of logic in the first place.
14:40:36 <iqubic> Eduard_Munteanu: that's not a definition of list. That is a collection of list utilities. That file actually imports Agda.builtin.list on line 24
14:40:52 <__monty__> monochrom: You don't even need dependent types for that.
14:41:12 <byorgey> mnoonan: position, velocity, acceleration, jerk, snap, crackle, pop ...
14:41:19 <Eduard_Munteanu> iqubic, er, yeah, but you can look at the function types.
14:41:38 <iqubic> and they confuse me.
14:42:03 <iqubic> explicit forall, and what the heck is a set?
14:42:05 <monochrom> __monty__: Do you mean: We don't need dependent types to confuse illogical people? >:)
14:42:08 <Eduard_Munteanu> iqubic, Set 0 is just *
14:42:27 <Eduard_Munteanu> And Set 0 has type Set 1.
14:42:33 <Eduard_Munteanu> And so on.
14:42:58 <__monty__> monochrom: No, that CHL applies to non-dependent type systems equally well.
14:43:01 <iqubic> Is that where we get Set Omega from?
14:43:25 <iqubic> But what is the type of Set a?
14:43:44 <__monty__> iqubic: Set a+1
14:43:56 <Eduard_Munteanu> iqubic, yeah, when you ask for the type of a universe polymorphic type, you'll get Set \omega.
14:44:36 <Eduard_Munteanu> \forall a. Set a : Set \omega
14:45:03 <iqubic> map : ∀ {a b} {A : Set a} {B : Set b} → (A → B) → List A → List B
14:45:08 <Eduard_Munteanu> Note the quantifier is now in the type as opposed to what you asked.
14:45:16 <iqubic> Oh, I see.
14:45:26 <iqubic> I don't get that first argument ther.
14:45:29 <epta> what is the best way to express an invariant in a function signature? Like, for function `f :: T -> ()' field `a :: Maybe Int' of an argument `t :: T' is `Just i', where `data T = T { a :: Maybe Int, ... }'.
14:45:48 <Eduard_Munteanu> iqubic, a and b are levels
14:45:52 <iqubic> I get that
14:46:02 <iqubic> But why express them at all?
14:46:13 <glguy> epta: You can make a new type that doesn't use Maybe for that field
14:46:27 <byorgey> epta: (1) write a comment saying what you just said, (2) make a new data type which is like T but has an Int field instead of Maybe Int, (3) use Agda
14:46:39 <Eduard_Munteanu> iqubic, to introduce them in scope, Agda needs to have stuff explicitly brought in
14:46:45 <atchoum> what is the main activity of haskellers ? Do they write haskell for a living ?
14:47:13 <iqubic> No. The main activity of Haskellers is writing code for a hobby.
14:47:17 <byorgey> atchoum: some do, and some don't.
14:47:49 <Eduard_Munteanu> atchoum, and some write Haskell occasionally at work, even if it's not the main thing
14:47:51 <epta> the thing is that T is huge, and copying T is not a best option, so I'm looking for a way to express some kind of a witness that `a' is `Just i'
14:48:53 <mnoonan> byorgey: oh my. I think "jerk" was the first "third thing" that got me riled up, but I hadn't heard the followups..
14:49:29 <iqubic> And the 4th thing there is "Snap"
14:49:32 <byorgey> the followups are mostly tongue-in-cheek.  Jerk is actually important in designing real-world systems.  Higher derivatives mostly aren't.
14:49:55 <Eduard_Munteanu> epta, add a 'Maybe a -> a'  function?
14:51:36 <byorgey> epta: can you change the definition of T?  You could give it a parameter that expresses whether this invariant should hold or not, and define the type of the 'a' field based on that
14:51:52 <byorgey> other than that, I would say there isn't really a good way to do this in Haskell
14:51:56 <epta> yep, for that case there could be fromJust, and I can logically prove using grep that it not going to be called on Nothing, but it'd great to prove it for compiler and get rid of of fromJust making it impossible to compile with Nothing branch
14:52:42 <glguy> epta: Yout can parameterize T with some new variable f, and then have the 'a' field have type 'f Int'
14:52:45 <byorgey> hmmm, maybe something with pattern synonyms
14:52:50 <mnoonan> epta: Do you really need the field to be a `Maybe a`?
14:52:51 <glguy> epta: now you can have T Maybe and T Identity
14:54:59 <mnoonan> or even just `T a` and `T ()`, perhaps
14:55:20 <glguy> Yeah, better
14:55:33 <epta> glguy: yep, this parametrization sounds reasonable, thanks
14:56:34 <mnoonan> you could also give the function in question a `T -> a` rather than just a `T`.
14:56:55 <mnoonan> "in addition to"
14:57:30 <mnoonan> "here's your T, and here's how you get that a out of it that you want"
14:57:56 <epta> btw, could singletons be used for having such kind of a witness?
14:57:59 <Eduard_Munteanu> iqubic, btw, you can't actually write Set omega in code because its type would be a Set (omega + 1), much like you can't write sorts in Haskell code because you'd need an extra level.
15:05:50 <iqubic> Right, this sort of thing is kinda explained in the book "Godel, Escher, Bach" which is my favorite book ever.
15:06:03 <iqubic> So I have a kinda background of this.
15:16:53 <Gonz4> Hi, i'm tryng to create a function that takes a list of function and then apply them on an element(sorry about my english), what i've done is that:
15:16:55 <Gonz4> appllyListFunctions :: [(a->b)] -> a -> b
15:16:55 <Gonz4> appllyListFunctions functions elem = foldl applyFunction elem functions
15:16:55 <Gonz4> applyFunction :: (a->b) -> a -> b
15:16:55 <Gonz4> applyFunction function elem = function elem
15:17:19 <Gonz4> can someone see what im doing wrong?
15:18:24 <hpc> Gonz4: what do you get when you apply a list of functions?
15:18:50 <hpc> (that should be enough of a hint for you to spot it yourself)
15:19:08 <Gonz4> im tryng to understand it
15:19:24 <Gonz4> i think it should returns an element
15:19:36 <hpc> say you have five functions
15:19:46 <hpc> you apply the same value to each of them
15:19:50 <hpc> how many answers do you have?
15:20:07 <Gonz4> i think only one, the last?
15:20:46 <hpc> oh, wait
15:20:54 <hpc> you want f (g (h x)) kind of a thing?
15:21:04 <Gonz4> yes!
15:21:16 <hpc> ah, it was hard to tell from your description
15:21:17 <hpc> cool, so
15:21:19 <Gonz4> ohm uhmm
15:21:32 <Gonz4> yes eys that
15:21:37 <hpc> say you do applyListFunctions [f, g, h] x
15:21:38 <iqubic> foldr (.) list -- perhaps?
15:21:39 <hpc> x :: a
15:21:49 <hpc> x, y, z :: a -> b
15:21:54 <hpc> er, f, g, h :: a -> b
15:22:02 <hpc> so the first "step" is h x
15:22:04 <hpc> which has a type of b
15:22:12 <hpc> then g (h x) is a type error
15:22:16 <iqubic> And then it fails to type check.
15:22:17 <hpc> because g takes an a, but got a b
15:22:33 <iqubic> :t \list -> foldr (.) list
15:22:35 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
15:23:20 <hpc> foldr (.) id list
15:23:54 <Gonz4> looks complicated, i'm trying with it to understand how does fold works
15:24:23 <hpc> Gonz4: so basically, your first problem is that your functions can't be composed
15:24:40 <hpc> [a -> a] -> a -> a, is probably what you want
15:24:50 <Gonz4> i try that way
15:24:57 <Gonz4> but still having error
15:25:25 <hpc> so the next issue you're having is that foldr and foldl take a list of functions and a zero element
15:25:28 <hpc> and then the list
15:25:39 <hpc> er
15:25:48 <hpc> that's completely wrong
15:26:13 <hpc> so the next issue you're having is that foldr and foldl take a function that combines list elements and a thing that caps off the list
15:26:36 <hpc> the list is of functions, so you need a thing that combines functions
15:26:38 <hpc> that's (.)
15:26:44 <hpc> and a thing that caps off the list, that's id
15:26:52 <hpc> > id "anything"
15:26:54 <lambdabot>  "anything"
15:27:06 <hpc> > (+ 5) . (* 2) $ 1
15:27:08 <lambdabot>  7
15:27:34 <monochrom> Oh this is a cool exercise I could give to my students.
15:27:45 <hpc> and usually you want it to be foldr instead of foldl
15:28:00 <hpc> all together:
15:28:10 <hpc> applyListFunctions :: [a -> a] -> a -> a
15:28:40 <hpc> applyListFunctions functions value = foldr (.) id functions value
15:28:48 <Gonz4> yes, in facts i try doing [a -> a] -> a -> a, as you say, an then try with foldr, and it works
15:28:56 <hpc> (foldr (.) id functions) is the fold that gives you a final function that's the combination of all of them
15:28:59 <hpc> and then applied to value
15:29:20 <hpc> if it looks like foldr has "too many" arguments
15:29:44 <Gonz4> hpc: its really dificult to me to see how thath works, i'm trying to follow u anyway
15:30:23 <monochrom> The trick is to accept that foldr can produce a function, that nothing says it must only produce a number.
15:31:17 <hpc> http://static.flickr.com/4025/4347879619_b9efdbbbec.jpg or http://www.cantab.net/users/antoni.diller/haskell/units/images/foldr.png are helpful visualizations
15:31:30 <Gonz4> monochrom: sure, i can figure that. The true thing is that it is a ejercice from an exam
15:31:36 <hpc> [f, g, h] = f : g : h : []
15:31:50 <Gonz4> and that function should works for any type of list of fucntions
15:32:00 <hpc> replace [] with id, and (:) with (.) and you have something that applies all the functions the way you want
15:32:08 <hpc> so foldr (.) id
15:32:21 <hpc> f . g . h . id
15:32:26 <Gonz4> what does id do?
15:32:33 <hpc> id is the identity function
15:32:35 <hpc> :t id
15:32:36 <lambdabot> a -> a
15:32:37 <hpc> > id "anything"
15:32:39 <lambdabot>  "anything"
15:33:45 <Gonz4> nice, so if a do foldl (.) (id elem) [functions]
15:33:50 <Gonz4> foldr* sorry
15:33:54 <Gonz4> should work?
15:34:37 <hpc> not quite, remove elem and put it at the very end
15:35:02 <hpc> foldr builds a function that does everything in the list
15:35:11 <hpc> and then you apply that to the thing
15:35:47 <Gonz4> ahah
15:35:49 <Gonz4> aplicarFunciones :: [a->a] -> a -> a
15:35:49 <Gonz4> aplicarFunciones funciones elemento = foldr ($) elemento funciones
15:35:55 <Gonz4> should works?
15:36:40 <hpc> ah, that should work too
15:37:25 <hpc> replace (:) with ($) and [] with elemento, and [f, g, h] folds into f $ g $ h $ elemento
15:38:03 * hackage warp-tls-uid 0.2.0.0 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.2.0.0 (YoshikuniJujo)
15:39:37 <Gonz4> really thanks, i will try it and see what happns :)
15:41:27 <EvanR> stgi is cool, i'm glad my screen froze when someone mentioned that a while back
15:41:41 <EvanR> @where stgi
15:41:41 <lambdabot> https://github.com/quchen/stgi
15:41:46 <EvanR> :thumbsup:
15:45:23 * hackage warp-tls-uid 0.2.0.1 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.2.0.1 (YoshikuniJujo)
15:55:49 <atchoum> could potentially haskell be totally using eager evaluation ?
15:56:10 <atchoum> btw, how does this relate to « normal-order evaluation » and « applicative-order evaluation » ?
15:56:19 <hpc> as long as it does so in a way that adheres to non-strict semantics, sure
15:56:29 <hpc> in fact ghc sometimes applies strictness optimizations
15:57:11 <atchoum> in fact normal-order «is» lazy evaluation, isn't it ?
15:58:18 <atchoum> from sicp, they have shown a number of case where it implies to evaluates two times the argument. So I understand that ghc enforces strictness from time to time.
15:59:30 <atchoum> what was the example already ? Something like (square (x+2)) that would evaluate to `(x+2) * (x+2)` and then, `(x+2)` wouljd have to be evaluated two times instead of one for applicative order.
16:01:17 <monochrom> I did not pay attention to the details of normal order and applicative order.  But I know call-by-name and call-by-need.
16:01:50 <monochrom> Call-by-name is when you evaluate x+2 twice because the example causes two copies of x+2 to appear.
16:02:43 <monochrom> Call-by-need is when the example causes instead two pointers to the same copy of x+2 so x+2 is evaluated only once with in-place destructive update by the answer.
16:03:02 <monochrom> Call-by-need equals lazy evaluation.
16:04:00 <atchoum> mh yeah everything is a thunk.
16:04:05 <monochrom> Apart from that redundancy vs sharing, call-by-name and call-by-need have the same termination and non-termination (and both maximum chance of termination).
16:06:17 <EvanR> yeah i have heard, outside SICP, that "lazy" specifically implies an optimization where "both" (x+2)'s are the same object at runtime
16:06:33 <EvanR> which gets updated to avoid more than 1 eval uation
16:07:45 <EvanR> just normal order would give you copies of the arguments everywhere
16:08:11 <dmwit> atchoum: Haskell does not promise that `let y = x+2 in y*y` evaluates `x+2` only once. (Though it seems at the current time that being efficient more or less requires making that promise.)
16:08:51 <dmwit> ...which is what everybody else, said, too, in their own way, I suppose.
16:08:51 <monochrom> Oh! I think I now recall that applicative order is eager evaluation --- evaluate x+2 first (and then discover that the parent is "const False (x+2)" and be buggered...)
16:09:23 <dmwit> I have a cunning plan.
16:09:27 <EvanR> making that promise also allows lazy evaluation to always complete in at most (sometimes less than) the number of steps eager evaluation would take
16:09:30 <dmwit> 1. Fork on thread for each subexpression.
16:10:01 <atchoum> very evil for a start
16:10:12 <EvanR> hey we have cheap threads
16:10:31 <EvanR> and thrills
16:11:06 <atchoum> doing evil can be enjoyable.
16:11:19 <monochrom> dmwit: I invented that 4 years ago. Or rather, I invented a cool name for it: crazy evaluation. It rhymes with "lazy evaluation" so it's very cool.
16:11:36 <dmwit> dope
16:11:48 <EvanR> crazy evaluation would be, fork a thread for each subexpression, whose evaluation could cause side effects (like x++)
16:11:55 <geekosaur> pretty sure that's one of the bogosorts that has been around forever
16:12:19 <monochrom> It is a great way to poke fun at people who speak like "non-strict evaluation" tells you anything at all.
16:12:44 <monochrom> But anyway the really traditional name is "speculative evaluation".
16:12:51 <monochrom> which is rather boring.
16:12:54 <EvanR> it does tell you anything at all, right
16:13:10 <EvanR> i mean, something at all
16:13:20 <geekosaur> it tells you something, just not what you'd like to think it tells you
16:13:35 <EvanR> curious, what do i like to think it tells me
16:13:47 <geekosaur> (generic "you")
16:13:52 <EvanR> still curious
16:14:14 <geekosaur> one of those human foibles, we like to make dumb assumptions. see also the black swan fallacy
16:14:46 <monochrom> For the price of almost 20 letters (plus probably a whole year of learning denotational semantics to decipher "non-strict"), it tells you approximately just 1 bit of information.
16:15:04 <atchoum> EvanR: that's amazing and in the mean time, not really intuitive :) because a naive parser wouldn't bother to store the thunk corresponding to (x+2) but would expand the expression as far as possible. BTW I am really wondering if there is other languages doing such things. And BTW this is also some kind of memoization I think.
16:15:24 <atchoum> I have a problem with this object : (debug 3) :: (Num (IO b), Show b) => IO b
16:15:41 <monochrom> And in practice it completely defeats the purpose because most of the time if someone asks you about evaluation order, their goal is to predict time usage and space usage, not just to be reassured of "oh it will terminate".
16:16:00 <monochrom> At which point "non-strict evaluation" tells you 0 bits of information you don't already know.
16:16:17 <EvanR> what is amazing, the number-of-steps result?
16:17:42 <EvanR> i have a problem with Num (IO b) too
16:18:49 <monochrom> You probably need my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
16:20:42 <atchoum> I fixed it
16:21:16 <atchoum> monochrom: that must be the 4th or 5th time you tell me about your IO tutorial :)
16:21:41 <atchoum> that's kind of a running gag :)
16:22:37 <EvanR> monochrom is like inspector gadget of tutorials
16:22:56 <EvanR> and tautologies
16:23:04 <atchoum> I'll do it another time.
16:23:51 <atchoum> I mean the tutorial, one more time.
16:26:46 <atchoum> > let debug x = do { putStrLn ("Evaluate object"); return x} in let square u = do {r<-u;putStrLn "Calculate square"; return (r*r)} in (square (debug (4+3)))
16:26:49 <lambdabot>  <IO Integer>
16:26:59 <__monty__> monochrom: Your definition of call by need and name seems to differ from what I remember.
16:27:23 <atchoum> weird
16:27:43 <EvanR> % let debug x = do { putStrLn ("Evaluate object"); return x} in let square u = do {r<-u;putStrLn "Calculate square"; return (r*r)} in (square (debug (4+3)))
16:27:43 <yahb> EvanR: Evaluate object; Calculate square; 49
16:28:36 <EvanR> this one doesnt exhibit any lazy behavior because IO
16:29:15 <atchoum> I thought if I didn't print the number it would still be lazy.
16:29:22 <__monty__> monochrom: Woops. Guess I was wrong. I was thinking call by reference.
16:29:41 <EvanR> if you dont print anything, you cant tell the difference
16:29:56 <atchoum> that's true :)
16:30:13 <atchoum> there is no `explain` keyword like it can be in SQL ?
16:30:14 <EvanR> if you do put in an impure print hack, you can detect a difference
16:30:56 <EvanR> but printing in IO is intentionally going to happen "in order"
16:31:16 * atchoum is side glancing (impure print hack -- omg what is that supposed to mean ?)
16:31:39 <EvanR> in Debug.Trace theres this thing, trace :: String -> a -> a
16:31:44 <geekosaur> atchoum, you can ask it to output Core, which is the internal format and usually shows how evaluation will be done. but you have to learn to read it. (same is true if you want details from EXPLAIN, really)
16:31:50 <EvanR> when the second args is evaluated, the string is printed
16:32:34 <EvanR> as a last debugging resort
16:33:24 <int-e> atchoum: for example, you can do this in ghci: import Debug.Trace, and then  let fib n | traceShow ("fib",n) False = undefined; fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 4
16:35:10 <atchoum> cool
16:35:36 <atchoum> then the fib evaluation is lazy but not very efficient.
16:35:40 <atchoum> Thanks all
16:35:44 <atchoum> must go to bed
16:36:29 <int-e> (note that  fib n | traceShow ("fib",n) False = undefined  features a guard that is always False (so the "undefined" is never evaluated)... but has a side effect because of the "impure print hack" embedded in Debug.Trace.traceShow)
16:36:30 <awesomeaniruddh> http://www.cis.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
16:36:50 <awesomeaniruddh> I'm a little confused about how to do the last problem
16:37:07 <awesomeaniruddh> (Implementing an instance of expr for M.Map String Integer -> Maybe Integer)
16:39:17 <awesomeaniruddh> Actually with the whole homework... I don't understand what I'm really doing
16:39:42 <awesomeaniruddh> I am able to implement most of the functions just fine, I'm just confused about what's actually going on
16:39:55 <ddellacosta> awesomeaniruddh: can you maybe talk about what you didn't understand in the corresponding lecture notes? http://www.cis.upenn.edu/~cis194/spring13/lectures/05-type-classes.html
16:40:11 <ddellacosta> or, drill into a specific point in the homework that isn't making sense?
16:40:34 <ddellacosta> for example, are you having a hard time figuring out how to write Expr in terms of syntax, or etc.?
16:41:06 <awesomeaniruddh> So... besides the last problem
16:41:13 <awesomeaniruddh> My issues are not with the Haskell itself so to say
16:41:26 <awesomeaniruddh> but with how it's being used to create this interface
16:42:01 <ddellacosta> in what sense? Sorry I'm not trying to be obtuse--trying to drill into what is confusing you here
16:42:17 <awesomeaniruddh> Honestly this is probably something I need to just work out on my own
16:42:25 <awesomeaniruddh> Let's focus on the coding issue here - that you can actually help me with
16:42:30 <ddellacosta> awesomeaniruddh: okay sure
16:42:39 <awesomeaniruddh> So I'm having trouble implementing the Expr instance for the Map as i said
16:42:44 <ddellacosta> right okay
16:43:07 <awesomeaniruddh> issue 1: variables are represented as maps from a Map to a Maybe Integer
16:43:21 <awesomeaniruddh> This implies that the product of two variables or the sum is *also* a variable
16:43:24 <awesomeaniruddh> Which is confusing to me :/
16:44:08 <ddellacosta> give me one sec to load up a file locally here
16:44:31 <dmwit> % let square x = x*x in square (Debug.Trace.trace "evaluated argument" 3)
16:44:31 <yahb> dmwit: evaluated argument; 9
16:44:36 <dmwit> atchoum: ^
16:45:19 <dmwit> > let x :: Num a => a; x = Debug.Trace.trace "evaluated x" 3 in x*x
16:45:21 <lambdabot>  error:
16:45:21 <lambdabot>      Not in scope: ‘Debug.Trace.trace’
16:45:21 <lambdabot>      No module named ‘Debug.Trace’ is imported.
16:45:29 <dmwit> % let x :: Num a => a; x = Debug.Trace.trace "evaluated x" 3 in x*x
16:45:30 <yahb> dmwit: evaluated x; evaluated x; 9
16:45:30 <int-e> awesomeaniruddh: an expression is represented by a function (M.Map String Integer -> Maybe Integer) ... think of the M.Map String Integer as giving the value for each variable, and the Maybe Integer as the result (the result is undefined if the expression refers to a variable that is not present in the map)
16:45:39 <dmwit> % let x :: Integer; x = Debug.Trace.trace "evaluated x" 3 in x*x
16:45:39 <yahb> dmwit: evaluated x; 9
16:46:06 <awesomeaniruddh> int-e: that interpretaion is what lead to me to think that the product of two "variables" is also a variable
16:46:23 <ddellacosta> awesomeaniruddh: are you talking about a type variable here?
16:46:45 <awesomeaniruddh> Okay what, holy shmoles, I was horribly confused
16:47:10 <ddellacosta> awesomeaniruddh: ?
16:47:13 <int-e> awesomeaniruddh: but it's not... the expression x + y would look up the values of x and y, and add them... which is different from what is done for just a variable
16:47:15 <awesomeaniruddh> So...not only variables, but *all* expressions are encoded as functions from a Map to a Maybe INteger
16:47:42 <int-e> awesomeaniruddh: that's what I wrote above, yes.
16:48:31 <awesomeaniruddh> That feels confusing. How should a literal be represented?
16:48:58 <int-e> awesomeaniruddh: well, does it have to look up a variable value?
16:49:06 <awesomeaniruddh> Nope
16:49:09 <int-e> awesomeaniruddh: if not, perhaps it should just ignore the variable map...
16:50:03 <awesomeaniruddh> Ahh
16:50:07 <awesomeaniruddh> that makes a lot of sense
16:51:03 * hackage ats-format 0.2.0.28 - A source-code formatter for ATS  http://hackage.haskell.org/package/ats-format-0.2.0.28 (vmchale)
16:52:53 <ddellacosta> awesomeaniruddh: seems like int-e has resolved your confusion there?
17:39:05 * hackage tweet-hs 1.0.1.40 - Command-line tool for twitter  http://hackage.haskell.org/package/tweet-hs-1.0.1.40 (vmchale)
17:43:06 * EvanR bemoans the crippling behavior of GHCI where, if there is 1 type error, you cannot inspect the type of anything anywhere
17:43:36 <EvanR> i comment out the offending code, reload, inspect types. slows things down
17:44:46 <dmwit> EvanR: -fdefer-type-errors
17:45:06 <dmwit> One day there will be -fdefer-syntax-errors, and you'll be able to stuff any old garbage down GHC's throat.
17:45:46 <Eduard_Munteanu> -fdefer-runtime-errors
17:48:06 <Eduard_Munteanu> -std ecma
17:49:31 <Eduard_Munteanu> Interesting, ECMA is an anagram of ACME. Coincidence? I think not.
17:49:36 <EvanR> defer life
17:49:48 <geekosaur> defer sense
17:51:19 <Clint> geekosaur: what precipitates xmonad releases?
17:51:52 <Eduard_Munteanu> Neutrinos?
17:51:53 <geekosaur> someone who knows how being around. "someone who knows how" is difficult because whoever works it out each time disappears post-releaset
17:52:28 <Clint> that is certainly not the answer i expected
17:54:14 <geekosaur> "orgbaized" has never been xmonad's strong point (go look at -contrib)
17:54:18 <geekosaur> *organized
17:54:42 <Clint> fair enough
18:21:17 <dmwit> Clint: Typically, an xmonad release happens when a sufficiently annoyed user volunteers to do it themselves.
18:26:22 <Clint> dmwit: interesting
18:26:29 <Lears> Technically there are v0.14 milestones set up in the core and contrib github repos with a number of old, stalled PRs/issues in each. Don't know if anyone has plans for those, or what would still need to be done if they did get cleaned out.
18:29:24 <dmwit> I think officially pmade is the current maintainer. I haven't been super attentive lately, so I don't know how active he is.
18:29:51 <dmwit> Also, there's an #xmonad you may be interested in. =P
18:30:34 <geekosaur> he begged off about a month ago, no time
18:30:55 <geekosaur> I'd love to think the reason maintainers vanish shortly after a release is because they get a hot new job out of it :p
18:31:11 <Lears> As far as I can tell, byorgey is the only one in the github organisation who's active.
18:32:59 <dmwit> I stopped using xmonad when I realized I could get 95% of its utility out of Gnome's "tile to right/left half of screen" feature. And because it's a C codebase, I'm never tempted to sink an entire weekend into improving it.
18:33:14 * geekosaur is …. not as active as he should be. mostly because of times like now when sequestered in low light because headache
18:33:29 <dmwit> (I mean, I'm never tempted to sink an hour into it and discover a full weekend later that I'm still hacking.)
18:33:51 <dyl> I honestly pretty much only need 1/2 L/R and quarter screen tiling.
18:33:55 <dyl> 99% of the time.
18:34:29 <dyl> I just never really WANT to have that many tiled windows. I’d rather just have them all spread across desktops and hide/show as needed.
18:34:38 <dyl> So each of my desktops is like two stacks of windows.
20:34:51 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
20:34:51 --- topic: set by geekosaur on [Thu May 17 06:28:54 2018]
20:34:51 --- names: list (clog ddellacosta toovs hjdskes aniruddh tabemann xcmw marxS tomsen Saukk argent0 sun777 sigmundv wedens otto_s raynold MoarSpaceFi bbrodriguez tzemanovic enterprisey InstantGratifica youtmon iqubic hphuoc25 juhp SHARIF ecx andyhoang1 theDon kmurphy4 erikd freeman42x]NixOS xpycm banc rotaerk woodson lagothri1 lassulus Linter newhoggy carafe dented42 hucksy_ beka kapil___ lastmanstanding dxld DTZUZO dxld[work] octobanana Dabo sword865 jdt numberten aidecoe)
20:34:51 --- names: list (Nikotiini louispan andyhuzhill ian_andrich ericsagnes taumuon blackfalcon[m] danso night___ amiri YongJoon systemfault korans jfredett emilypi infty oisdk kefin__ weird_error nighty- bydo atk mnoonan_ skeuomorf harfangk blasen hamishmack staafl lambda-11235 rkazak ammazza mkoenig ck_y sim590 MP2E codesoup beauby hiratara pavonia hive-mind AndreasK amirpro jud StoneToad jmnk milli alexteves ego hegge xkapastel JimmyRcom_ Adluc alx741 hpc jbalint rcdilorenzo)
20:34:51 --- names: list (refold ccomb zdenal fr33domlover yazmir8azyr MarcelineVQ thblt Shumatsu JARVISuk tg gienah_ rembo10 DrAwesomeClaws Khisanth ryantm d34df00d connrs zymurgy morgib[m] alex`` Nik05 Durbley lnostdal reactormonk Frans-Willem SCHAPiE bas080 atondwal urodna APic dminuoso thunderrd pseudonymous Wamanuz2 johnvonneumann_ troydm exarkun exio4 sdothum drbean milanj andromeda-galaxy seizo noxd Heffalump PLPD-Bot machinedgod sword_smith beerdrop robstr catsup moei zyla_)
20:34:51 --- names: list (dmiles spopo valentinbuza nD5Xjz dbe jle` justanotheruser dan_f gonz_ xinming monochrom tessier swalladge Ukari telser `0660 keep_learning brynedwards nshepperd XorSwap Fatalnix Lears aijony hodapp vodkaInf1rno slackman mrBen2k2k2k klugez Tspoon_ XMunkki Logio liff ent hc don_quijote[m] Zipheir` mulk Tourist cheater acarrico nesqi dpower excelsiora kaychaks niklasl seanparsons Sgeo_ Unhammer WarzoneCommand zaquest miklcct ph88 leat falafel[m] liste)
20:34:51 --- names: list (Maxdamantus Natch sm gspia jibby typedrat simplegauss karlguy dcoutts_ averell whiteline peutri boj sveit phreedom pfoetchen Myrl-saki jrabe jrm leothrix jcarpenter2 ssarah kadoban Cthalupa R0b0t1 martingale unyu Eduard_Munteanu nisstyre elih-19[m] darxun cjay- Blkt dysfigured hiredman bcoppens absence otulp jimmyrcom ptek jkachmar MindlessDrone ps-auxw mupf mda1 nksegos elomatreb dedgrant colescott avocado DDR jw358 sw4n m0rphism stvc bitonic alexbiehl)
20:34:51 --- names: list (sdressel insanitea jibby_ c_wraith Younder aib tabaqui1 jchia sellout sis7 thaumavorio dispanser logcat debugloop peddie fergusnoble Destol blackblankx[m] edwardk nsnc zebrah jcjf jonh eikke navilan Morgawr markus1199 zmt00 benzrf oharvey niko wollw dave_uy drewr pranz1 dtulig _flow__ Ninja3047 uglyfigurine pikajude nkaretnikov trosa d3z trulsa ibttis tylerdma1e mlen maerwald tdammers buzo Mattias dsal @ChanServ mquin rodarmor nwf DTZUZU hulvat Digit)
20:34:51 --- names: list (shenaurin_av[m] jonge fall_ ongy ioanluca Tesseraction revprez_anz bbear kloeri albel727 marens andyo pjan jdnavarro Guest42448 dysfun Majiir grumble sigmundv_ stites richi235 ByronJohnson spacebug emerson Sigyn esph x1n4u S007 ManiacTwister kosmikus obfusk Jaxan yushyin dejanr nyuszika7h akermu s4msung bxc uwap naudiz hrnz aksz noctux zipper anhj d-rk1[m] seveg Nokurn cheshircat Foritus phryk acowley klntsky_ sleonard nnplv revprez_stg dolio mounty)
20:34:51 --- names: list (squisher bluepixel agrif yukkuri paf31_ shutdown_-h_now nepomukspencer[m lugh minad SlashLife cocreature wrengr_away StianL nckx cpape shoogz JoelMcCracken amf brisbin killtheliterate alanz lachenmayer wonko77 nullifidian randallb_ meck gxt m1dnight1 sqrt2 jix Quillasp[m] Charn pierrot mderhaeg cschnei__ RaptorJesus avn Cale pacak piyush-kurur fbauckho loqoman r33pich33p[m] sevcsik1 tv RGamma centril kaesebrot[m] tehidiot[m] infinisil ma27 bod_ drewbert)
20:34:51 --- names: list (jackhill wonko7 xplat vladan mitchellsalad_ brool jchia_ jakutis koz_ deepfire` divVerent kav malade_mental snamellit chelfi Tuplanolla aananev guillaum2 zyla[m] wtfunctional Superman[m] infinity0 arkadefr Nussi mountaingoat hvr raek kandinski fresheyeball Guest29863 cjwelborn liyang orion heath brent80_plow cpallares SegFaultAX umpc fxrs srk revprez_atlanta przembot durazasa[m] texasmynsted Orbstheorem srhb nibbling ectos xa0 pikhq Forkk stiell a3f lopex)
20:34:51 --- names: list (lavalike nootz[m] akfp` m4lvin thisa[m] byorgey lambdabot dilinger Anthaas Hanma[m] benonsoftware ackthet datajerk edofic jameshjacksonjr[ herzmeister[m] sielicki davidar dirb aaronc[m] gelidae[m] pnrfne[m] asayers[m]1 drasich[m] rellen razvanc-r[m] kar1[m] stigo[m] xMajedz[m] zykt[m] ykoda[m] sophien[m] ProofTechnique[m patrl[m] asm[m]1 cptpie[m] vthriller blitzlightnin[m] abailly[m] fosskers[m] Mougan[m] saci[m] tchernobog[m] thejonny[m] cipher1024[m])
20:34:51 --- names: list (usgroup1[m] tomas_gallegos[m asyncawake[m] FAssis[m] sm[m] a-s[m] Guest1573[m] eeyun[m] trbyoneda[m] devault[m] NikitaKuznetsov[ rukoyatka[m] davidar_ gymcap[m] WinterFox[m] drewfer[m] garphy`aw guest3rzghbmr[m] nattofriends[m] hd[m] kasbah[m] lycium[m] japhir[m] lightandlight homam[m] wilo[m] ziman joncfoo abdolence[m] neel12[m] fristonio[m] testtestqqq[m] shekel[m] maverickwoo[m] Prince781[m] ackien[m] bb010g Rick[29SMPittsbu tuxether[m] devr[m])
20:34:51 --- names: list (mm-vcleo[m] noperope[m] octalsrc[m] valkyr2e Shaunthesheep[m] asenski[m] jhhuh[m] porcow[m] cgfbee nh2[m] mniip cesardv Gabscap Mon_Ouie fairfieldt tjbp bollu hydraz fakenullie ralu mceier twk- ketralnis mstruebing1 bodie_ ggVGc int-e blackdog koala_man yahb dam30n[m] henriquezanin[m] devpav[m] senchopens[m] ninjatrappeur[m] ajbreen[m] leavittx[m] Obscurity[m] tester668[m] Willjox[m] reactormonk[m] Yoann[m]1 kerscher[m] vinjohn[m] testtt0x11[m] ph[m])
20:34:51 --- names: list (plll[m] geetam DavesTestingAcco camael[m] alibabzo[m] M-rgh alpharho[m] pam_cakes[m] onaka[m] noteventime[m] Deleh[m] xacktm bkrn[m] tibike_m[m] KuninoSagiri[m] aniketd[m] himmAllRight[m] tuxitagnu[m] Chris[m]6 seanalexander[m] kebertx[m] Vi0[m] hakan[m] dlilja[m] tinwood[m] m1andrew[m] rprospero[m] nlx[m] TylerCecil[m] ShalokShalom[m] alexshpilkin[m] riadvargas[m] richardsd[m] oknf[m] zalipuha[m] cocarl[m] M-szia darkunicorn[m] william[m]1 mrno[m])
20:34:51 --- names: list (dbramucci[m] aquarial[m] mcspud geekosaur cyphase Arguggi loc tolt duoi urdh aweinstock Cathy wagle fredcy joehillen Ferdirand jokester marble_visions angerman asjo platz bbaren cschneid_ TommyC netneon0011[m] tezos_noob[m] ertes clarkf akshayn nkhodyunya dopplergange worch Squarism jophish ClaudiusMaximus angular_mike_ Meow-J___ darthThorik langkid1 Lord_of_Life ctag verement survove dinkarg[m] sudden delYsid qwertydvorak benl23 llinguini sbauman)
20:34:51 --- names: list (ryanbooker stig heyj Peter_Storm terrorjack msmorgan peteretep exit70 joel135 spinda solidsnack xplat|work_ simony dmj` lexi-lambda Argorok gridaphobe mpickering redcedar thoughtpolice rann Tritlo dashed essent sethetter ianconnolly_ srid blackrain Guest59221 anaxios sppqd[m] pistasj[m] phittacus mad[m]1 absurd[m] siegvriel[m] reem_ huaw Quora luminousnine freeman42x dustman[m] jvalleroy[m] mstruebing sgoody[m] Mateus[m]1 solarus mbrcknl_ jorendorff bigs)
20:34:51 --- names: list (mindtree zpconn__________ amatecha__ Wizek CARAM____ changyj_ tarcwynne__ chriswk dstockwell mankyKitty Scorchin trig-ger_ metalrain__ hsiktas gmzara[m] Taneb Reisen jakehehrlich fds mjoldfield sellout- amx Sp4rrowh4wk tnks zv Zialus qz kwantam BrAsS_mOnKeY kjak h30 stilgart chat_ carbolymer bartavelle bengt_ prg318 mgaare Amadiro pita przemkovv hesaid alicemaz yrid revprez dustinm mtjmullen bspar sssilver greeny leah2 ft aminb gentauro gnusosa marek)
20:34:51 --- names: list (duncan^ bafain defanor kuno zaiste emptythought[m] implementation Madars Deadhand wz1000 jarodwr[m] coeus tomaw reu blaird[m] llwu chivay michalisko treehaqr linduxed Profpatsch Flonk mk-fg phaazon bbee Willis galeido jwynn6 ccase flounders[m] bind kiltzman dpren ahihi noplamodo Eagle_Erwin lukelau mgttlinger[m] mimi_vx Igloo jstolarek mahalex Paks bgamari iphy coil[m] mikeplus64 byte512 kini Ekho tismith bananagram Wolf480pl deba5e12 tehnix[m] sunhay)
20:34:51 --- names: list (Zowlyfon ion romac[m] sujeet Voldenet fgaz aurieeeh lin_ gurkenglas[m] Ewout diskie Liskni_si ancarda tkr Moyst statusfailed Tehnix2 qahqah[m] ayk[m] Ranhir Baplar[m] bs338 swflint deva[m] Adeon bob_twinkles dibblego Sose qzo Fairy dvgroc[m] riussi[m] beppe[m] PatrickM[m] rihardsk[m] Google[m] ElliotKiyomizu[m srenatus capsel[m] superpat[m] agraba[m] chkl[m] asthma[m] moofd[m] youdi[m] ritaoncloud[m] h1ccup[m] jelewaus[m] magnap nmdanny[m] brigdeer[m])
20:34:51 --- names: list (happyente[m] atopuzov[m] mitach[m] mrdjc[m] squarfed[m] tynanbe lkurusa thekyriarchy__ avatias0[m] hkd[m] teuffy[m] kxra_ rszibele[m] rbutler[m] Kevin[m]4 guillaumecherel[ M0x8badf00d[m] Aaa[m]1 snoyberg Nerka[m] arrdem[m] araspik[m] tiktaalik[m] KevinMGranger M-ming8 asonixdog[m] M-HirmeS scrypso[m] sagecube[m] Elorm[m] gelnana[m] reconmaster[m] am2on juliusberger[m] MacGyver[m] sigterm[m] semyon[m] zzander57[m] M-DarkTrancer Albtrz[m] howsiwei[m])
20:34:52 --- names: list (coorey[m] brunocado[m] robotgerman[m] kwaku[m] h_ndrik[m] xodbox[m] dezren39[m] bmjh petrolifero[m] smaller_infinity djangoblockchain mxdemeanor[m] likwrk[m] windy328ghoee[m] ajtowns[m] kbkn[m] m00n[m] ku-po[m] uchronian[m] jumzi[m] cevin[m] stuebinm[m] putputlaw[m] dombesz[m] okalldal[m] Cadey[m] icen[m] sclv[m] chatnowvvv[m] icrbow[m] Ekho[m] yefllower[m] dbane[m] unclechu kassick[m] capncanuck[m] M-kitsune ub[m] ixian adaschma[m] chominist[m])
20:34:52 --- names: list (superobserver[m] timdeh[m] brunocad[m] tylerkvochick[m] fxb8[m] jhuizy[m] HoelKervadec[m] michbad braidn[m] Naughtmare[m] ttk2[m] fdb[m] jbweston[m] vicky520666[m] Heino[m] jmnoz swarm1321[m] remloh[m] phatex[m] comrade-goofus[m intheclouddan beemo[m] astompydan[m] sanfrancisco[m] vars[m] jiji606[m] goto[m] joeo[m] ThousandLions[m] ArchieT hiq[m] zygentoma[m] laaksoan[m] chedi[m] Barnabas[m] oats[m] Makinit kinboy[m] ssaavedra[m] hdurer[m] vsts[m])
20:34:52 --- names: list (blue42[m] felipeac[m] dkellner[m] tet[m] tyler274 amidstbinary[m] guaraqe[m] SamLord[m] benbika[m] FjordPrefect pebble2011[m] el_tejon[m] innaytool[m] samprotas[m] towaii[m] Dako300[m] emme[m] georg3[m] jamshoot[m] Guest94427 aoeupl[m] omtcvxyz[m] dadadus[m] mossid[m] mith[m] jomari[m] naviknair7[m] fizzgig[m] bgrayburn[m] Half-Shot megamanmalte[m] charlag[m] vitamin-q M-ms M-moyamo sqzlh JackM[m] masaeedu[m] patonw[m] nelag[m] kumori[m] ibraheemmoosa[m])
20:34:52 --- names: list (piluex[m] h4z3[m] demonslayer[m] aiken[m] stekke[m] Matthew[m] puffnfresh idnar[m] Braveheart[m] gpunk[m] thekyriarchy NapoleonMalapart ph0zzy weareswarmcity[m Akito[m] sigmacool[m] trikl[m] M-whoops sudoreboot[m] toma[w] trevorriles[m] lbpc[m] Jikstra[m] pcm77[m] Orbstheorem[m] wzy8L-B2[m] jupiter[m] Mike[m]1 anomie[m]1 R2D2[m] wahrsagevogel[m] anhduy[m] goodboy[m] blaha[m] jansc[m] undu[m] hendrik[m] greentrophy[m] nanoplink[m] MaJoe[m] M-krsiehl)
20:34:52 --- names: list (JanPath[m] zaphar_ps[m] angelbeats[m] jerin[m] maigel[m] turt2live dmp1ce[m] WilliamHamilton unknownln lierdakil[m] wizek[m] aer[m] RheaParekh[m] bennofs[m] albertsg[m] M-wamaral aspiwack[m] berton Gratin[m] ahri spacekitteh[m] lysgaard[m] ollieh javjarfer[m] caseypme[m] neiluj equalunique[m] HMPerson1 andreabedini x0x0_ nbrr[m] posco caa51h pdxleif noan rotty kaol dogui cow-orker saftsuse fryguybob spion- adarshaj quicksilver simon flebron Guest15337)
20:34:52 --- names: list (M2tias froztbyte [df]_ sdx23 spoonm sdrodge anishathalye malthe fugyk zemm tripty jtz tomku codebam sys9mm grayhatter lispy ysangkok [exa] abra0 clever drdo cetchmoh martinmch harmaahylje acro Laney capisce falafel ironChicken jvanbure statusbot clampy Guest21928 integral dumptruckman dpepsilon abbe mads- f32ff_ Fubar^ hanDerPeder barrucadu AlainODea Zoddo bytesighs mgttlinger Youmu gluegadget yaknyasn cgag Guest82928_ noobst iravid andrew_n_ zmanian)
20:34:52 --- names: list (etrepum feepo_ ebutleriv prizim shachaf jinblack dmwit amosbird LeaChim alek1 arahael croben_ c-rog jdevlieghere ircbrowse_ Hijiri_ wraithm butterthebuddha swhalen_ jtcs exferenceBot john883 lionanee- wting_ mrm a_t poga Velpoman_ dbohdan atomi zenzike_ ilbelkyr mjrosenb kriztw Rembane tctara_ DustyDin1o bs Putonlalla nurupo paraseba GGMethos julmac d6e dpanth3r_ ianp Solarion_ stammon Ivan__1 eagleflo dexterfoo taktoa[c] typetetris jameshaydon ryanponce)
20:34:52 --- names: list (feltnerm jml jmct monad_cat nicoulaj sdemos Kamuela hansihe kyagrd milessabin georgew billstclair mbrock_ adamse kipd ericbmerritt_ zgrepc cstrahan ocharles jzelinskie ghuntley avdi joedevivo tlevine xaimus guios theorbtwo ghostyy jorj dh runawayfive burp_ cjh` Hjulle gargawel Patternmaster Axman6 cn28h Clint magicman glguy Guest40090 tumdedum Kneiva kqr wto ventonegro micro Guest89285 jared-w yumh jzl Dykam sms petercommand NinjaTrappeur bertschneider)
20:34:52 --- names: list (gothos neaty Jello_Raptor chrzyki mt linuxdaemon rgrau dan64- sha-2 snsapiens PotatoGim ajmccluskey lumimies Ankhers bjs bno1 Guest55398 tureba phadej Guest61066 robogoat Jonno_FTW reptar_ iross oldsnakey anoe TimWolla Ornedan shapr Guest47384 oleks electrocat tinco Geekingfrog jrslepak cyberlard Robin_Jadoul mattp__ jluttine nshepperd1 Jon dyl cynick toure|gone epta tsahyt SolarAquarion Klumben chirpsal1 Chobbes dqd Tharbakim orzo Randy vaibhavsagar)
20:34:52 --- names: list (comboy Guest87130 dredozubov gdsx bshelden azahi lukeshu sanitypassing opqdonut hongminhee_ cross iron_houzi wamaral veverak adamCS shiona_ bwe EricZou codedmart OliPicard danza-cloud NemesisD spicydonuts_ mikedlr bradparker Guest42244 ranberry shans__ S11001001 flux cdornan_ akfp Vq Deewiant jbetz pagoda_5b alexknvl Guest11839 mbeidler wavewave higherorder libbyk pyrtsa Guest13947 cansis rootmos_ vikram__________ tjpeden_ wizonesolutions zph mkurkov__)
20:34:52 --- names: list (runeks stux|RC-- betawaffle quaestor fiatjaf Meanirelli Soft Hafydd Strix seliopou Fylwind cods Guest60910 fluxit thebnq sakshams Cheaterman mak` rev_strangehope Mansa bornjre japesinator d3lxa ftop CuriousErnestBro Ke kennp linnae2 alp strugglingming dessmm jonrh Cir0X Novitsh fingerzam ReinH peschkaj dgonyeo gornikm yaroot vin-ivar banjiewen nbouscal incomprehensibly si14 dukedave oh_lawd prefork Xorlev setre firefly__ hackage m0ar marsam eacameron)
20:34:52 --- names: list (badzergling Guest85232 johs Guest57197 parseval elvishjerricco nelll runde Guest32087 thomashoneyman dgpratt gleber_ isaac_ thi_ carter fuziontech joeyh mathu Akii kerrhau webstrand _6a68 riatre Guest72348 eddsteel fnurglewitz verlet64 capicue rizary rjungemann Tallenz sunra pchiusano bbielsa Bengi_ caw_______ pasukon Chadtech sclv stephe marcel_ bgyss grandy______ Guest36441 JayKobe6k ycheng paroxp WhereIsMySpoon_ wtw lieven Guest11123 luigy Zemyla)
20:34:52 --- names: list (gopnikovitch owlscientist armlesshobo Guest72215 stass lyxia DwarfMaster drewbarbs xnyhps relrod HalfEatenPie scinawa monty Guest52309 catern Philonous raoulb Guest50286 pta2002 hexagoxel mitchty Guest49751 michalrus ekleog ndeine Athas stux|RC-only ncl28 Ring0` michi7x7 nikivi joeytwiddle Map pikolinosimo Unode beaky oldsk00l deni rootnode bitemyapp ynyounuo echoreply michaelpj soncodi ephemeron baweaver davean matchray canta chindy qdickon nemesit|znc)
20:34:52 --- names: list (rbocquet raid cnomad markhuge n3parikh idupree lpsmith Biohazard_ _janne TallerGhostWalt lpvb_ keyking_ duairc mxf Desoxy tek0 domenkozar kody^ eldritch ahf noexcept pharaun PHO__ kubrat_ Guest86887 earthy Chousuke binaryblade_ bjarki Bigcheese mmaruseacph2 tippenein da-x_ Princess17b29a CindyLinz ljhms crlane gareth_ nek0 hjklhjklhjkl ijp-znc Frankablu tabaqui tarnover andjjj23 anderson henrytill QuRyu jaargon deu mr_yogurt bsmt bjobjo EvanR saurik)
20:34:52 --- names: list (ec2-user1 philosau1 geal xxpor_ stefan- emmflo _cyril_ gilbertw1 rom1504 carc crooked kipras`away amuck MasseR Guest31134 niluje eL_Bart0- skeuchel hiptobecubic lukky513 Guest2049 hcit vqrs lokydor_ Guest57420 heinrich5991 karahobny asm89 rjeli_ freeside PyroLagus SuperTux88 arw Purlox Entroacceptor mrozek RahulS knmae lowryder hsyl20 mrus suzu Eliel)
20:34:55 <nisstyre> uniqueness types seem to be an alternative for maintaining purity but having I/O
20:35:08 <nisstyre> I don't know if there was much research on them back when Haskell was being developed
20:35:22 <edwardk> nisstyre: linear types and uniqueness types both can fill that niche
20:35:39 <edwardk> basically treat the universe as a 'unique' or 'linear' resource you pass along
20:36:07 <edwardk> both work for more or less opposite reasoning
20:36:59 <edwardk> nisstyre: there was clean, which was a pretty serious effort at investigating uniqueness typing
20:37:20 <nisstyre> yeah I tried using Clean but they decided to basically stall any serious development on it
20:37:24 <nisstyre> so it's a toy language basically
20:39:13 <nisstyre> this looks exciting though https://github.com/ghc-proposals/ghc-proposals/pull/111
20:39:23 <edwardk> i had one problem where i wanted to use clean to model it because it was a monad in a setting where uniqueness types exist, (it involved a monad for quantum computing) and then i was sad because i could even write down the concept, because they'd conflated all use of monads with IO, much like how benl23's ddc ties the 'do' notation to his region-driven reference stuff
20:39:34 <edwardk> er because i couldn't even
20:39:56 <edwardk> i'm a lot less excited by linear types in haskell than a lot of folks, i admit
20:40:05 <edwardk> as they aren't really linear, and they aren't really affine
20:40:16 <nisstyre> oh, hmm
20:40:46 <sclv> excited by the idea of trying to bring in linear types as per https://golem.ph.utexas.edu/category/2018/05/linear_logic_for_constructive.html
20:40:48 <edwardk> they aren't linear because if i throw an exception at your thread they leak. they aren't affine because i can't drop them on the floor by any other mechanism than throwing an exception.
20:41:01 <sclv> (which isn't the current proposal, but it would be neat to explore!)
20:41:13 <sclv> (those actually really affine btw)
20:41:20 <benl23> in ddc you can use ‘do’ for plain monads, completely separate from the effect system. There’s an example with parser monads
20:41:22 <edwardk> they are in this awkward intermediate ground where they work in toy programs, but not ones that actually need exception handling
20:41:50 <edwardk> benl23: sorry, i may have been speaking out of my ass there. i'll have to go back and learn what you've done
20:42:06 <edwardk> (this is one reason why i tagged you)
20:42:18 <benl23> :-)
20:43:30 <benl23> the effect system in ddc now is completely orthoganal to the pure FP language. This is diffferent to the system i wrote for my thesis
20:43:35 <edwardk> sclv: shachaf would be happy with the chu space connection
20:44:18 <edwardk> benl23: damnit. now i have to learn about "disco".
20:44:22 <shachaf> To be fair, what *doesn't* have a Chu space connection?
20:44:47 * edwardk fishes out Giorgio Moroder songs to get into the right mood.
20:45:06 <sclv> the simplest simplest version of chu space stuff is arguably the construction of the integers from the naturals, so... :-)
20:45:09 <edwardk> shachaf: no idea. but i bet if they exist, there is a chu space of such things
20:45:15 <benl23> when it comes to programming languages, it’s dance or die.
20:55:33 * hackage yam-config 0.3.3 - Yam Configuation  http://hackage.haskell.org/package/yam-config-0.3.3 (leptonyu)
20:57:11 * hackage yam-transaction 0.3.3 - Yam transaction  http://hackage.haskell.org/package/yam-transaction-0.3.3 (leptonyu)
20:59:29 * hackage yam-web 0.3.3 - Yam Web  http://hackage.haskell.org/package/yam-web-0.3.3 (leptonyu)
21:02:15 <edwardk> i think i missed whatever was discussed around why the 0 multiplicity in the "linear" types proposal was bad. is there a link i can follow to see what was said?
21:26:36 <Asassin333> paskell
21:26:39 <Asassin333> or haskell
21:26:50 <Asassin333> i prefer pascall lollies
21:27:00 <Asassin333> i love da marshmellows
21:27:03 <Asassin333> jajajajajajajajaja
21:27:06 <Asassin333> onya guys
21:27:14 <Asassin333> keep up da good work
21:28:45 <Asassin333> love u nerds
21:29:16 <glguy> Asassin333: This channel is for discussing Haskell, it's not for random banter
21:29:38 <Asassin333> but i have no idea what haskell even is
21:30:02 <ddellacosta> Asassin333: you should check it out!
21:30:10 <Asassin333> im a 40 y.o. unemployed drop out who still lives with his mom
21:30:13 <ddellacosta> are you a programmer?
21:30:19 <Asassin333> im a loser
21:30:22 <Asassin333> lol
21:30:41 <ddellacosta> Haskell is for everybody
21:31:12 <Asassin333> on a serious note,  i did a year of a computer science degree but quit
21:31:21 <Asassin333> just wasnt interested in C++
21:31:26 <Asassin333> or SQL
21:31:37 <ddellacosta> well you should definitely check it out if you've ever found programming interesting. It may change how you feel about it
21:31:59 <Asassin333> hmmm i'll keep it in mind thanks
21:32:14 <ddellacosta> and folks here tend to be quite helpful
21:32:26 <Asassin333> being on a computer too long is bad for my mental health
21:32:34 <ddellacosta> I understand!
21:32:35 <Asassin333> i need social interaction
21:32:44 <Asassin333> thats why i quit my course
21:33:06 * hackage edit 0.0.1.0 - A monad for rewriting things.  http://hackage.haskell.org/package/edit-0.0.1.0 (theindigamer)
21:34:40 <rotaerk> oh, a 40 year-old haskell-virgin
21:35:15 <ddellacosta> c'mon be friendly
21:35:20 <rotaerk> though I guess those are pretty common
21:35:44 <ddellacosta> well, that's probably true
21:36:16 <Asassin333> i said im not a pro9grammer rotarek
21:36:27 <rotaerk> yes, I know, I was making a silly joke
21:36:54 <Asassin333> but if ur female maybe u can change the virgin part for me
21:36:58 <Asassin333> loo
21:37:18 <glguy> Asassin333: You're welcome to come back if you end up having Haskell questions
21:37:19 <ddellacosta> I think we're getting fully off-topic here
21:37:22 <Asassin333> my life sucks
21:37:33 <dibblego> Asassin333: Stop now.
21:37:38 <Asassin333> i shouold end it really
21:37:43 <Axman6> @where ops
21:37:43 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
21:37:45 --- mode: ChanServ set +o glguy
21:37:45 --- mode: glguy set +q *!*@144.138.131.74
21:42:51 <badzergling> is there a crypto hashing library that's pure haskell?  I "need" something that works in GHCJS
21:43:37 <argent0> how can I exit early from a monadic `do`?
21:43:58 <glguy> argent0: Not in general, do and return aren't about control-flow
21:44:04 <nisstyre> badzergling: does this not work? https://hackage.haskell.org/package/bcrypt-0.0.11/docs/Crypto-BCrypt.html
21:44:29 <nisstyre> I see it's using Foreign.C.String for some reason, not sure if GHCJS supports that
21:44:50 <nisstyre> oh it is calling C code sorry, nevermind
21:44:57 <badzergling> the algo i need is actually `SHA256`, so bcrypt is no good anyway.
21:45:17 <EvanR> argent0: think about what you want the result to be if you exit early
21:45:24 <nisstyre> what about https://hackage.haskell.org/package/cryptonite
21:45:43 <badzergling> cryptonite is certainly not pure haskell.
21:46:02 <EvanR> the answer determines what options you have, what methods
21:46:08 <badzergling> `uncaught exception in Haskell thread: ReferenceError: h$cryptonite_sha256_init is not defined`
21:46:18 <nisstyre> you're right
21:46:29 <nisstyre> I guess the reason they use foreign function calls is that this stuff is hard to get right
21:46:42 <nisstyre> they want to avoid sidechannel attacks, etc
21:46:53 <EvanR> another reason is that crypto computation timing is much harder to control in haskell than C
21:47:05 <boj> badzergling: i suppose you could find a js implementation and use the GHCJS FFI to call it. browser crypto is pretty frowny though
21:47:21 <argent0> EvanR: ok, last question for tonight, what would be a cleaner way to write these ~20 loc: https://lpaste.net/2448221007572369408 ?
21:48:01 <EvanR> you could use when instead of the if then else Left
21:48:04 <EvanR> :t when
21:48:06 <lambdabot> Applicative f => Bool -> f () -> f ()
21:48:31 <EvanR> two whens then you can begin line 12 without having indented yet
21:49:25 <argent0> I tried `when` but it needs `()` and I have `Either String ()`. What am I missing?
21:49:41 <EvanR> oh
21:49:44 <EvanR> yeah
21:50:17 <EvanR> another shot: if all your code will be computing type Curses (Either Sting ()), then you probably want to implement a new monad which allows "throwing" in addition to curses commands
21:50:24 <EvanR> then the when thing would work
21:50:39 <argent0> EvanR: ok, thanks for the advice
21:50:42 <EvanR> you could implement it with the ExceptT monad transformer
21:51:21 <EvanR> type MyApp a = ExceptT String Curses a
21:51:41 <dminuoso> :t fail
21:51:42 <lambdabot> Monad m => String -> m a
21:51:58 <EvanR> unless Curses already has that
21:52:34 * hackage numhask 0.2.2.0 - numeric classes  http://hackage.haskell.org/package/numhask-0.2.2.0 (tonyday567)
21:53:02 <dminuoso> Is it reasonable to still have code floating around that uses `fail` without incuring a MonadFail constraint?
21:53:49 <Axman6> for futureproofing it's probably not a great idea
21:54:37 <argent0> EvanR: `Curses` is an instance of `Exeception` so that seems to be the case. I'll check it tomorrow thanks
21:54:53 <EvanR> interesting...
21:54:53 <Axman6> that sounds wrong...
21:55:05 <EvanR> yeah
21:55:13 <dminuoso> :k Exceptoin
21:55:14 <lambdabot> error:
21:55:15 <lambdabot>     Not in scope: type constructor or class ‘Exceptoin’
21:55:15 <lambdabot>     Perhaps you meant ‘Exception’ (imported from Control.Exception)
21:55:16 <dminuoso> :k Exception
21:55:17 <lambdabot> * -> Constraint
21:56:28 <dminuoso> Axman6: Okay, well Im not quite sure how `binary` expects me to do error handling during put - but I have a feeling that might not be possible.. I mean if I produce a lazy bytestring then the consumer might be sending it on the wire already.
21:56:53 <glguy> dminuoso: You aren't expected to do error handling during put
21:57:15 <EvanR> encoding is usually the part which cant fail right
21:57:40 <nisstyre> if it's deterministic I don't see how it could...
21:58:12 <EvanR> perhaps if your source material hasnt been fully produced yet and is coming from a flaky source
21:58:21 <nisstyre> like random numbers
21:58:27 <nisstyre> but then your encoding code would nevet get called
21:58:27 <EvanR> more like the disk
21:58:46 <dminuoso> EvanR: Well I have some invariants in my data that I cant express in the type system, mostly "length of strings"
21:59:19 <EvanR> if it gets as far as encoding without having those invariants checked, then you might as well destroy the world
22:00:02 <dminuoso> So if I dont want to use smart constructors, Id have to insert an extra validation pass?
22:00:16 <EvanR> you have no validation at all?
22:00:25 <EvanR> waiting until the last minute? :S
22:00:36 <EvanR> rails style, horrible stuff
22:00:55 <dminuoso> EvanR: Im just rewriting an existing piece of software - so..
22:01:11 <EvanR> smart ctors is one way to ensure you do these validations ahead of time, and enforce it with types
22:02:03 <EvanR> in my experience doing the validation early has saved my ass so many times, whereas getting crashing during the likes of final encoding leads to debug misery
22:15:56 <dminuoso> EvanR: There's so much repetition going on.. if only TH was more accessible this might be easier.. :P
22:16:16 <jared-w> dminuoso: in my experience, a lot of the "I need TH for this" is really "I don't have the right abstraction" in disguise ;)
22:16:27 <jared-w> Of course, if you're dealing with lots of low level boilerplate that's another thing
22:17:06 <dminuoso> jared-w: It's a lot of low level boilerplate because Im reimplementing the RADIUS protocol. So I have to deal with about 100 different possible attributes.
22:19:08 <EvanR> generating support code from API specs...
22:19:20 <EvanR> better than writing the code by hand
22:19:36 <EvanR> as long as you dont screw up, the bugs are in the spec
22:19:38 --- mode: glguy set -qo *!*@144.138.131.74 glguy
22:20:09 <tdammers> jared-w: the "right abstraction" often involving dependent types...
22:20:28 <jared-w> Well if you've got a space ship, everything looks like a planet to colonize... ;)
22:22:19 <jared-w> dminuoso: definitely sounds like a job for TH though
22:23:14 <tdammers> hammer and nail sure applies, but the things that TH is genuinely useful for are often those where you need to do term-level-style programming to produce type-level stuff
22:23:29 <tdammers> "I have this data here, now generate me some types"
22:23:53 <tdammers> if it's just term-to-term or type-to-type, you can generally do it without TH
22:24:31 <tdammers> so that's why I said "dependent types"
22:25:11 <tdammers> the other thing where TH is relevant is when you want to embed not-Haskell in Haskell source - QQ can improve things there (or completely ruin your day, as the case may be)
22:26:35 <jared-w> That's for sure :)
22:26:51 <jared-w> I've seen a lot of really cool stuff with QQ, especially the inline-Lang style packages
22:33:18 <jared-w> grading code is so boring :|
22:34:24 <jared-w> ah well, at least I have an empty irc channel to amuse me
22:34:39 <dminuoso> tdammers: amusingly a dependently typed map would be really awesome for this.
22:35:09 <jared-w> dminuoso: Is haskell not powerful enough to do that yet or is it just too much pain per square inch to get that singleton'd out? :p
22:38:34 <EvanR> there are dependent maps floating around
22:38:38 <tdammers> I'd wager the latter
22:38:51 <tdammers> it can definitely be done, at least with a few GHC extensions
22:38:58 <pacak> Is there a way to tell stack not to run tests after their compilation? https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md suggests that's there's no-run-tests flag but it's not working for me.
22:39:14 <jared-w> ahh, the good 'ol {-# Language KitchenSink #-}
22:39:40 <jared-w> EvanR: good to know. I figured, since iirc there's a cute proof floating around somewhere that any dependent type stuff can be simulated with enough singleton abuse(?)
22:40:10 <tdammers> pacak: stack build --no-run-tests?
22:40:28 <tdammers> pacak: obviously if you use the stack test shortcut, that should override it
22:40:52 <tdammers> jared-w: {-#LANGUAGE AllOfThemEvenTheOnesThatAreMutuallyExclusive #-}
22:41:20 <dminuoso> tdammers: Curious, which extensions are mutually  exclusive?
22:41:46 <jared-w> usually syntax ones that clobber each other, iirc? I don't know of a lot of others that are mutually exclusive
22:42:03 <pacak> tdammers: I'm using stack build blah:test. Adding --no-run-test to command line works but I'd like to specify it in the config file somewhere
22:46:18 <dminuoso> jared-w: but honestly the singletons library is a bit scary. It seems like an acamedias dream that can only be grasped if you're some post-doc person having real feelings for types.
22:46:30 <dminuoso> Just seeing the list of necessary extensions is uh: "DefaultSignatures EmptyCase ExistentialQuantification FlexibleContexts FlexibleInstances GADTs InstanceSigs KindSignatures RankNTypes ScopedTypeVariables TemplateHaskell TypeFamilies TypeInType TypeOperators UndecidableInstances"
22:46:46 <tdammers> pacak: why? why have tests when you're never going to run them?
22:47:23 <tdammers> dminuoso: I was going to say "oh, that's just standard procedure", but then I got to "UndecidableInstances"
22:47:56 <dminuoso> tdammers: Granted, most of them Im familiar with and have no deep issues. But when that's the toolbox just to play with singletons..
22:48:29 <jared-w> UndecidableInstances is basically mandatory when doing anything nontrivial with type families due to the overly cautious halting heuristic they use, iirc
22:48:37 <jared-w> It's "basically harmless"
22:48:50 <dminuoso> jared-w: Worst case the compiler loops and errors out right?
22:48:57 <tdammers> first step towards untyped programming. slippery slope.
22:49:00 <tdammers> :P
22:49:15 <jared-w> most of the time it'll catch the loop, I think. But yeah worst case scenario it just hangs while compiling
22:49:23 <jared-w> /shrug
22:49:24 <pacak> tdammers: I'm planning to run some of them under different conditions - it's up to gitlab-ci.yaml decide when and how to run them. On dev machine I want only to make sure tests are compiling successfully and small subset of them runs - via a different command.
23:05:31 <jchia> Is there a more efficient way to copy from a Ptr Word8 to a UArray Int Word8 than to peekElemOff and writeArray element-by-element?
23:18:26 <phadej> jchia: doesn't seem that internals are exposed so you could do that :/
23:21:15 <EvanR> you can expose the internals yourself
23:22:21 <jchia> phadej: Thanks, that's what I thought. If I could get the pointer, I use memcpy like hGetArray does. I find it odd that they provide hPutArray and hGetArray but no way to do other low-level interaction with the array.
23:22:43 <jchia> EvanR: How do I expose the internals myself? Do you mean fork the package for my own use?
23:22:59 <jchia> Here's how hGetArray does it using memcpy: http://hackage.haskell.org/package/array-0.5.2.0/docs/src/Data.Array.IO.html#hGetArray
23:24:49 <pavonia> deaoneebur90: Could you finally decide on a nick name?
23:27:50 <EvanR> jchia: usually an Internals module somewhere, and GHC.Prime
23:27:54 <EvanR> GHC.Prim
23:28:21 <EvanR> if theres no Internals module.......
23:28:27 <EvanR> gotta fork :(
23:30:06 <jchia> EvanR: I'm not familiar with GHC.Prim. Is there, for example, a special relationship between GHC.Prime.Array# and the array types in Data.Array?
23:30:31 <jchia> 'array' has no internal module
23:30:41 <cocreature> UArray is a wrapper around a ByteArray# but that won’t help you much if the constructor is not exposed (which sadly seems to be the case)
23:31:18 <cocreature> oh actually it is exposed from Data.Array.Base I think
23:31:57 <cocreature> that module doesn’t have haddocks but it’s still exposed
23:33:18 <jchia> cocreature: OK, let me check out Data.Array.Base. The usual way I know a module exists is through haddocks. I suppose in this case one would have to discover it by reading the source code?
23:33:33 <enterprisey> :t id
23:33:34 <lambdabot> a -> a
23:34:08 <cocreature> jchia: the module is at least listed on the package page. what’s missing is the link to the haddocks
23:34:20 <cocreature> but yeah, reading the cabal file is the only way to really see which modules are exposed afaik
23:35:51 <jchia> cocreature: I see. My local haddocks somehow doesn't have it.
23:36:11 <cocreature> there are no haddocks for this module, they are explicitely disabled
23:36:40 <cocreature> which seems pretty silly tbh. if you are going to expose the module, why remove docs from it
23:36:54 <cocreature> if you want it to be internal say so in the docs and probably call it *.Internal
23:39:37 <jchia> cocreature: Data.Array.Base is neither listed on my local stack-generated haddocks nor listed here: https://www.stackage.org/lts-10.10/package/array-0.5.2.0. Maybe some haddock option decides whether the listing happens.
23:40:07 <cocreature> jchia: it is listed here https://hackage.haskell.org/package/array
23:40:33 <cocreature> hackage bases the module listing on the cabal file and not on which modules have haddocks
23:40:36 <jchia> cocreature: Yeah, I saw it. I was just noting the difference between haddock at different places.
23:40:38 <cocreature> apparently stackage doesn’t
23:43:55 <cocreature> but the version on hackage isn’t correct either if you have things like flags that can change the exposed modules
23:46:46 <marxS> why would you advise somebody to learn haskell over something like clojure or ocaml?
23:47:10 <opqdonut> haskell has purity and laziness
23:47:20 <opqdonut> it's a great language for learning what those concepts really mean
23:47:47 <opqdonut> (clojure and ocaml have only "occasional" purity and laziness)
23:48:32 <ddellacosta> I'll add that once you learn Haskell, Clojure, at least, won't be super hard to learn
23:48:40 <opqdonut> yeah
23:49:06 <ddellacosta> and I don't know enough OCaml to say one way or another, but I suspect it'll at least be easier, since they share a lot of DNA
23:49:08 <opqdonut> OTOH if your aim is to program in (say) clojure, learning haskell first makes no sense
23:49:13 <ddellacosta> true
23:49:27 <opqdonut> but I think once you program in clojure, learning a bit of haskell will improve your clojure
23:49:38 <opqdonut> (or maybe ruin clojure for you)
23:49:45 <EvanR> clojure takes some getting used to after haskell, in particular the figuring out a way to evaluate stuff in order to cause side effects
23:49:48 <ddellacosta> but as someone who learned Clojure first and Haskell second, purely because I wanted to expand my mind, Haskell has been way more mind-expanding (not that Clojure wasn't)
23:49:58 <marxS> I guess my aim is to learn some more FP but to double up as making myself more employable
23:50:04 <ddellacosta> yeah, the laziness in Clojure is a really different beast
23:50:10 <marxS> but FP languages in general seem seldom used in industry
23:50:16 <dminuoso> ddellacosta: Any language that does not change the way you are thinking about programming is not worth learning.
23:50:21 <EvanR> it has some laziness, but evaluation is what causes side effects so...
23:50:30 <ddellacosta> dminuoso: true--and Clojure at least did change my way of thinking, up to a point
23:50:47 <dminuoso> ddellacosta: Clojure in itself is not bad - there's certainly much worse languages around.
23:50:53 <ddellacosta> dminuoso: agreed
23:51:01 <ddellacosta> marxS: it's worth learning a functional language because it'll help with writing everything else, IMHO
23:51:30 <marxS> ddellacosta, yeah, I wanted to learn some more anyway (after some exposure to haskell at college)
23:51:44 <marxS> just figured it'd also be neat if it came with the benefit of being used widely in industry lol
23:51:56 <ddellacosta> none of those you mentioned are widely used
23:51:58 <dminuoso> marxS: Even if you dont continue writing Haskell, I think it will greatly improse the way you think about problems.
23:52:20 <ddellacosta> marxS: Haskell and OCaml will give you insight into types that Clojure will not, so consider that
23:53:05 <ddellacosta> again not that I think Clojure is a bad language but I think types are valuable to understand, in general--as opqdonut said above learning Haskell has improved my Clojure!
23:53:22 <marxS> ok nice thanks
23:53:35 <marxS> I will probably learn some more ocaml for the time being then
23:53:38 <ddellacosta> on the other hand, if you write JS in particular ClojureScript has a lot of momentum there
23:53:40 <dminuoso> marxS: Haskell also teaches you functional concepts much more directly, because Clojure has too many escape hatches.
23:53:48 <ddellacosta> yeah ^
23:54:03 <marxS> dminuoso, those same escape hatches come with any hybrid languages (like ocaml), no?
23:54:05 <aniruddh> http://www.cis.upenn.edu/~cis194/spring13/hw/06-laziness.pdf
23:54:07 <dminuoso> marxS: Right.
23:54:12 <aniruddh> Im confused about how to implement multiplication
23:54:17 <aniruddh> for exercise 6
23:54:39 <gonz_> marxS: OCaml isn't used much in industry
23:54:53 <marxS> gonz_, used by JS :p
23:55:01 <gonz_> If you've checked even one job listing board you'll notice it's far behind Haskell
23:55:07 <gonz_> Considerably so
23:55:13 <rotcev> I'm by no means a haskell pro, whatsoever, but what I have learned from toying with the language is definitely extremely valuable. I also know a bit of clojure, and I think the concepts you can learn from LISP are also extremely valuable. I would suggest learning at least a bit of both clojure and haskell
23:55:15 <gonz_> it also has a smaller community in general
23:55:25 <marxS> gonz_, yeah the community does seem somewhat absent
23:55:37 <marxS> when I've been trying to ask questions or whatever there's no where to really get a quick response
23:55:38 <dminuoso> 08:46           marxS | why would you advise somebody to learn haskell over something like clojure or ocaml?
23:55:41 <dminuoso> marxS: Why not learn all three?
23:55:52 <marxS> dminuoso, time constraints I guess
23:55:55 <systemfault> gonz_: Used for writing compilers at facebook... and there's the classic "Jane Street"
23:56:06 <dminuoso> marxS: Just start with one, and pick up one other as you go.
23:56:07 <systemfault> So, there are people using it :)
23:56:15 <gonz_> systemfault: Look at the job market. Jane Street using it does not a market make.
23:56:17 <dminuoso> marxS: You dont have to fully dive into it - just enough to solve problems.
23:56:50 <gonz_> systemfault: The argument given here is that learning Haskell is a waste of time because it's not used in industry. But then saying that OCaml is worthwhile is the complete opposite. OCaml is _less_ popular.
23:57:00 <monad> hi
23:57:01 <dminuoso> marxS: Im fluent in 6 programming languages and I have some basic experience with maybe a dozen more - you just pick these things up over time. I think "why not learn both" is often more valuable than "focus on only one"
23:58:02 <rotcev> marxS: if you have only time to focus on a single language for now, i would personally suggest haskell, because i find it much more mind-expanding than clojure
23:58:03 <gonz_> marxS: If this is a business decision to you, go with something like Scala or Clojure to learn FP. If learning languages is fun and you want to change the way you think I think Haskell will be far more impactful than any of the other alternatives.
23:58:05 <dminuoso> (But I'd consider myself good in only one languages, the other ones Id say Im on some intermediate level)
23:58:10 <spoonm> I thought haskell was being used more and more in production
23:58:15 <rotcev> i can't speak for ocaml because I haven't used it before
23:58:15 <systemfault> gonz_: Learning a bit of Haskell has repercussions on your other, more mainstream, languages... Scala, Java, C++, even JavaScript.
23:59:00 <dminuoso> spoonm: Over the past few years there's been a slow and steady paradigm shift in most mainstream languages. Functional concepts have been coming to imperative languages, with it more and more people discover pure functional languages.
23:59:50 <monad> has anyone looked at curry the language?
23:59:53 <gonz_> systemfault: I wasn't saying Haskell is a waste of time. I was saying that was the argument given by marxS. He wants to make it a business decision and I was arguing that if it's a business decision, OCaml is a terrible language to learn.
