00:00:03 <omegablitz> hello
00:00:22 <zenspider> where do I find these?
00:00:52 <zenspider> I must be diving the wrong directory on github
00:01:42 <dminuoso> zenspider: pointfree is not a what, it's an adjective
00:01:52 <[exa]> zenspider: https://wiki.haskell.org/Pointfree it's _not_ practical, but makes you super comfortable with all the ways of function composition
00:02:16 <zenspider> you're not talking about hlint config then?
00:02:47 <cheater> is there a common version of flip map or flip fmap?
00:03:02 <[exa]> cheater: usually called 'for'
00:03:07 <johnw> for is not flip map
00:03:12 <cheater> why?
00:03:13 <johnw> sadly
00:03:15 <johnw> for = forM
00:03:18 <cheater> k
00:03:26 <opqdonut> :t for
00:03:27 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
00:03:28 <johnw> i really wish it were flip map too
00:03:32 <opqdonut> so it's kinda like forA
00:03:36 <johnw> yeah
00:03:43 <johnw> it's flip traverse
00:03:46 <johnw> rather than flip map
00:03:59 <[exa]> there's no 'for' without A/M ?
00:04:01 <dminuoso> johnw: Why do you wish for that to exist? I mean you can conjure `<&> = flip fmap` with no real cost
00:04:05 <[exa]> :(
00:04:28 <dminuoso> What's the benefit of shipping such miniscule flipped things?
00:04:31 <johnw> dminuoso: in long chains of $, <&> is not friendly
00:04:38 <dminuoso> Ah
00:04:40 <johnw> I want to write: foo $ bar $ for xs $ \x -> ...
00:04:51 <johnw> but I'll give it a try
00:04:56 <johnw> I want to write: foo $ bar $ xs <&> \x -> ...
00:04:59 <johnw> I think that would work fine here
00:05:33 <[exa]> is there some nice syntactical trick for writing 'flipped <$>' other than >$< (which is for cofunctors)?
00:05:51 <opqdonut> <€>
00:05:53 <opqdonut> ;)
00:05:54 <[exa]> lol
00:05:58 <Ariakenom> (`map`xs) also works there
00:06:06 <dminuoso> johnw: What about a section foo $ bar $ (`fmap` xs) $ \x -> ...
00:06:14 <zenspider> answer: https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml
00:06:16 <johnw> yeah, ugly though
00:06:21 <dminuoso> [exa]: cofunctor?
00:06:23 <johnw> it just breaks the symmetry
00:06:24 <dminuoso> :s
00:06:31 <johnw> mapM f xs <-> forM xs f
00:06:38 <johnw> but map f xs <-!-> for xs f
00:06:39 <[exa]> dminuoso: contravariant functors, sorry
00:06:45 <[exa]> too much morning here
00:07:03 <dminuoso> I recently got beaten with a stick in here for proposing to use the word cofunctor just to realize the categorical notion suggests `co` flips arrows :P
00:07:25 * Ariakenom raises stick
00:07:52 <[exa]> dminuoso: Contravariant functors are also occasionally called cofunctors. [wiki]
00:08:25 <dminuoso> [exa]: I've read a few papers that do this as well. I got convinced by some folks in here that it's not a useful thing to do, because "Co" generally means to flip arrows.
00:08:30 <[exa]> dminuoso: maybe someone invented a way to flip the functor more directly so 'cofunctor' name is now taken
00:08:30 <dminuoso> The dual of a functor happens to be just a functor.
00:08:42 <johnw> "... the sentence "TT is a functor" is clearly self-dual, as Mac-Lane explicitely pointed out in his Categories for the Working Mathematician. So, given a functor TT a "cofunctor", interpreted as the dual concept, would be just TT itself."
00:09:45 <[exa]> we need a better name, 'contravariant' is too long to be said very often
00:10:03 <dminuoso> [exa]: You could shorten it to `Contra` maybe
00:10:13 <tdammers> life is so much easier when you are "pragmatic"
00:10:25 <Cale> and can shoot in 8 directions
00:10:48 <tdammers> and there's feet in all of them?
00:10:51 <Ariakenom> Isn't it already called Contra somewhere?
00:11:05 <dminuoso> Ariakenom: microlens-contra
00:11:29 <dminuoso> As far as I can tell it's called Contravariant everywhere, according to hoogle
00:11:55 <johnw> generally in books on category theory, I just find them called functors from an opposite category
00:12:02 <johnw> they aren't specially named
00:12:29 <Cale> Yeah, can't get a much shorter name than no name at all
00:12:53 <cheater> :type (<&>)
00:12:59 <cheater> :t (<&>)
00:13:00 <lambdabot> Functor f => f a -> (a -> b) -> f b
00:13:05 <quicksilver> yes, in cat theory books/papers you'd say "a functor from C^op -> C"
00:13:06 <dminuoso> johnw: You mean instead of saying `f : A -> B` is a contravariant functor you'd say `f : A^op -> B` is a functor?
00:13:20 <Cale> yeah
00:13:40 <quicksilver> which makes it really easy to say things like  C xC^op -> C
00:13:53 <cheater> hi Cale :)
00:13:58 <dminuoso> quicksilver: What does `x` denote there?
00:14:09 <quicksilver> product
00:14:18 <quicksilver> that's a functor of two arguments
00:14:20 <dminuoso> quicksilver: Ah. Was just confused because you missed a space there.
00:14:22 <cheater> ×
00:14:26 <dminuoso> Thought xC was a thing
00:14:28 <quicksilver> yeah, typing on 3G, latency is bad
00:18:16 <infinisil> Huh? Your key presses do a roundtrip before you see them or what?
00:19:12 <cheater> probably
00:19:32 <Axman6> need moar mosh
00:19:58 <johnw> he's quicksilver; his Net access, not so quick
00:20:10 <johnw> your nick should be slowsilver on 3G
00:22:39 <dminuoso> quicksilver: See, in Haskell I'd have just written C -> C^op -> C =P
00:24:14 <quicksilver> infinisil: yes,my IRC client is over ssh running in screen
00:24:30 <quicksilver> more modern technologies are rumoured to exist but this works for me :)
00:24:31 <infinisil> Lol
00:25:32 <dminuoso> What is `screen`
00:25:48 <dminuoso> Sounds like a fork of tmux.
00:26:06 <Boomerang> A stripped down tmux :-) Maybe older...
00:26:10 <Logio> it's the older one of the two
00:26:53 <dminuoso> tmux was invented because you cant sensibly get a tiling window manager on macOS
00:27:06 <dminuoso> That's my theory.
00:28:31 <Boomerang> According to Wikipedia screen was first release in 1987 whereas tmux was released in 2007 :o
00:28:42 <cocreature> I have a list of zipper like things that focus on disjunct leaf nodes in the same tree. is there a nice way to modify all those leaves and merge it back into a single tree?
00:28:50 <dminuoso> Boomerang: Don't believe the propaganda.
00:32:44 <quicksilver> cocreature: depends how your 'zipper like things' are constructed.
00:32:55 <quicksilver> it's very possible you can just chain the four modifications and be done with it.
00:33:47 <quicksilver> altenratively maybe you are now wishing you had a Traversal not a list of zipper like things
00:34:01 <quicksilver> s/four//;
00:38:15 <cocreature> quicksilver: ah that’s a good point, a Traversal does sound like the right direction
00:41:16 <quicksilver> zipper is more about being able to move a cursor around
00:41:33 <quicksilver> lens gives you good ways of specifying multiple cursors with a query DSL
00:42:07 <zenspider> ok... traceShow is nifty... but it gets ugly reading it partially outputting the actual result and tracing inside of it. I don't suppose there is any way around that since that is actually what it is doing, is there?
00:42:39 <ziman> you could replace traceShow with something that prints to stderr, for example
00:42:49 <ziman> (or to a file)
00:44:17 <zenspider> I suppose it probably is... but that's going to my repl in emacs and it doesn't care. I suppose it might be buffering wonky tho
00:49:04 <cocreature> zenspider: forcing the evaluation of the thing using deepseq before you call traceShow on it will ensure that the traceShows inside of the value will be evaluated first
00:49:55 <zenspider> cocreature: blah blah blah... um... what?
00:50:23 <zenspider> I don't think I'm in that deep. It was enough for me to actually debug my problem pretty easily. that said, your words are not words to me (yet)
00:51:52 <cocreature> well if you would like us to explain things to you, you need to be a bit more precise than “your words are not words to me”
00:53:48 <zenspider> well... I've got something like this:
00:53:49 <zenspider>  
00:53:50 <zenspider>  | otherwise = traceShow (headf x, tailf x) $ headf x : unfold donef headf tailf (tailf x)
00:54:43 <zenspider> I've only just found deepseq... so I still don't quite know what it does... I have no idea what you mean by "before you call traceShow" as that's the first thing I'm doing.
00:55:27 <cocreature> so your problem is that you also have traceShow in "headf" and "tailf" and those get interleaved?
00:55:31 <Cale> He just means inside the traceShow, which ironically, will be after :)
00:56:05 <zenspider> the deepseq doco is... pretty opaque. HUGE instance list. starting to look like rust doco. :P
00:56:34 <Cale> Yeah, because almost any user defined data type can support an instance of that
00:56:47 <cocreature> I don’t mean inside the traceShow, I mean something like "let r = (headf x, tailf x) in deepseq r (traceShow r $ …)"
00:56:53 <Cale> It's just "things for which there is a way to evaluate all parts of them"
00:56:55 <zenspider> cocreature: no. this is unfold and it is lazy, so the repl starts to produce the output and the tracing happens on a per element basis
01:00:10 <zenspider> ok. my brain is mushy. this has bbeen fun. Thank you all for your support. At some point I'll come back and ask about more optimal emacs workflow for haskell. I feel clunky compared to how I do racket still
01:00:24 <zenspider> I need to get that bb key cleaned out
01:01:08 <robstr> What is the way to ask cabal for a specific version, I'm using nix and want to check which package version cabal is using right now
01:02:47 <lemmih> robstr: Version of cabal or version of some specific package?
01:03:13 <robstr> lemmih: version of a specific package,
01:03:14 <zenspider> looks like --constraint=CONSTRAINT
01:03:28 <zenspider> `cabal help install`
01:03:47 <zenspider> or:
01:03:49 <zenspider>   cabal install foo-1.0             Specific version of a package
01:03:49 <zenspider>   cabal install 'foo < 2'           Constrained package version
01:04:10 <lemmih> robstr: I think you have to ask ghc-pkg.
01:04:20 <robstr> zenspider: I dont want to install a specific version, I want to check wich version got picked
01:04:24 <quicksilver> I think a sound guideline is 'don't use traceShow, learn more idiomatic techniques'
01:04:36 <quicksilver> which is not to say that traceShow isn't useful or interesting
01:04:39 <robstr> lemmih: Thank you, I will check this
01:04:40 <quicksilver> (but I've never used it personally)
01:04:41 <zenspider> quicksilver: totally. working on it.
01:04:42 <cocreature> robstr: ghc-pkg list
01:04:53 <robstr> cocreature: :) ty
01:04:54 <zenspider> (slowly)
01:07:28 <butterthebuddha> Supposing that R is a (not necessarily commutative) division ring R with p^2 elements (p a prime), how do I show that its center (a field) must have p elements?
01:07:35 <butterthebuddha> Whoops, wrong channel.
01:08:41 <cocreature> osa1: great blogpost!
01:08:55 <nilOps> Is there some tutorial or something to help get a better understanding of Applicative for (-> t)?
01:09:13 <cheater> does anyone know of a good way to do "jump to definition" in vim on larger haskell code bases? I'd be happy with something that utilizes tags, but also something that just uses rg and then finds the definition in the files rg finds would be fine. or anything else that's pretty good, really.
01:09:42 <osa1> cocreature: glad you liked it :) thanks for sharing
01:10:17 <nilOps> Going through fp-course and I got the applicative tests to pass, but I'm not sure I actually get it
01:10:26 <quicksilver> Axman6: thanks for reminding me. You puhsed me into finally getting mosh working :P
01:10:50 <cheater> nilOps: read the source code for the functions you use. try playing around with a few applicatives and see what happens if you plug in different kinds of data
01:12:02 <Cale> cheater: Yeah, hasktags is what we use.
01:12:51 <cocreature> osa1: you seem to be a lot of GC work recently. are you pursuing some larger project or just trying to understand things and fixing some bugs here and there?
01:13:12 <Cale> (to generate tags files for vim's jump to definition to work on)
01:13:17 <osa1> sharing it on /r/haskell I mean*
01:13:21 * osa1 can't type while eating
01:13:35 <cocreature> was easy enough to infer what you were referring to :)
01:14:05 <cheater> Cale: what do you put in your vimrc for that? or is it a plugin?
01:14:33 <cheater> ah yeah https://github.com/MarcWeber/hasktags
01:16:45 <cheater> Cale: do you also happen to have something good for quickfix?
01:20:04 <Cale> Yeah, it's nothing vim-specific, just a program to generate tags for Haskell sources
01:20:11 <Cale> I don't know what you mean by quickfix
01:24:30 <osa1> cocreature: yeah there's a larger project that I'm working on. I can't give any details at this point but you'll eventually hear about it as the plan is to merge it to GHC :)
01:24:58 <cocreature> osa1: sounds good, looking forward to seeing the results! :)
01:26:12 * hackage eventstore 1.1.3 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-1.1.3 (YorickLaupa)
01:34:07 <JonnyRaa1> cheater: if you use a tags program and put the file it produces in your :pwd (normally the trunk of your repo, just run the tags program from there) then vim magically picks it up and you can just use <C-]> (with many other commands) to jump to definition
01:34:53 <JonnyRaa1> fzf can also search your list of tags and you can use the preview window to jump about without losing focus on your current window with <C-}>
01:35:32 <JonnyRaa1> if you do :h tags you'll find some of the goodness
01:37:53 <JonnyRaa1> you can also use Ack/ag to sortof get find usages (its basically just a greplike text search thing) but tags are loads faster for go to definition as they are basically a cache.  You can also set it up so when you save a file in vim it updates your tags, I'm using fast-tags which is specifically designed for that
01:39:02 <JonnyRaa1> that face was supposed to be [colon]pwd!
01:41:19 <electrocat> there are also plugins that take advantage of this tag information for autocompletion
01:42:55 <JonnyRaa1> you can also just use the built-in <C-x>] for that aswell
01:45:32 <JonnyRaa1> I actually think all the different native autocomplete modes are really nice - I mostly use <C-x>n (local completion), <C-n> (configurable completion - I have mine set to look in buffers open in splits in the current tab) and then the tags one above.
01:45:42 * hackage aeson-diff 1.1.0.5 - Extract and apply patches to JSON documents.  http://hackage.haskell.org/package/aeson-diff-1.1.0.5 (ThomasSutton)
01:45:48 <JonnyRaa1> take a bit of configuring though
01:48:33 <electrocat> i have this stupid large tags file with definitions from base :p
01:54:12 <ddellacosta> anyone here familiar with dante? I'm trying to simply get it started, and I'm terrible at emacs and stuck at 'cabal: repl failed for...' with some messages about 'Try to customize (probably file-locally or directory-locally) `dante-project-root' and/or `dante-repl-command-line'.'
01:55:05 <JonnyRaa1> electrocat: hah! nice.  I can imagine that's probably pretty useful.  I made a thing to generate imports based on jumping to tags but it only works on local code because of limited tags
01:55:27 <ddellacosta> the docs don't make it particularly clear to me what those variables are for, even when I go to the customization page in emacs
01:56:04 <ddellacosta> well, the first one at least
01:58:28 <cheater> JonnyRaa1: thanks
02:04:31 <ddellacosta> okay nevermind that's apparently not my problem
02:26:12 * hackage cabal-rpm 0.12.3 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.12.3 (JensPetersen)
02:34:15 <JonnyRaa> cheater: your welcome :)
02:36:10 <JonnyRaa> you're!
02:42:10 <Ariakenom> Why does Alternative need Applicative?
02:45:07 <mbwgh> Is there a quick way, using some "back of the envelope semiring of types calculation", that it kind of makes sense to represent linear transformations (R^m -> R^n) as R^(n*m) matrices? What I get is (R^(n*m) -> R), which *could* possibly make sense if interpreted the right way.
02:45:30 <mbwgh> *a quick way to show
02:45:58 <Boomerang> Ariakenom: I think Alternative needs Applicative to define `some` and `many`, have a look at the implementation :-)
02:46:14 <mniip> mbwgh, yeah, a linear transformation is uniquely determined by where it sends the basis vectors
02:46:25 <quicksilver> erm, the fact that matrices represent linear maps is a consequence of the theorems about existence and uniqueness and orthogonality of finite bases
02:46:45 <quicksilver> or certainly that's one way of developing the theory
02:46:56 <quicksilver> you could start with the matrices and work back instead.
02:47:06 <Ariakenom> Boomerang: but some and many could add the applicative constraint themselves
02:47:31 <jle`> mbwgh: i just recently wrote a blog post about this https://blog.jle.im/entry/you-could-have-invented-matrices.html
02:49:42 <jle`> mbwgh: basically if you're talking about a linear transformation from R^m, then you all you need to do is talk about what the transformation does with any 'm' bases
02:50:22 <mniip> there is a natural isomorphism
02:50:26 <jle`> mbwgh: since f(a v1 + b v2 + c v3) = a f(v1) + b f(v2) + c f(v3), all you need to talk about is f(v1), f(v2), and f(v3)
02:50:31 <mniip> between Hom(R^m, R^n) and R^mn
02:50:39 <mniip> in the category of linear spaces
02:51:04 <jle`> mbwgh: and if your target is R^n, then it means that you need n coefficients to describe the targets of your m bases in your original space
02:51:25 <jle`> mbwgh: so you need to describe what happens to m bases, which takes n coefficients each.  m * n.
02:51:31 <mniip> jle`, that feels like it's just one side of the isomorphism
02:51:38 <mbwgh> jle`: Ah, you mean that by linearity, I could reduce (R^n^R^m) in the types calculation to something like n^m?
02:51:50 <jle`> what is R^n^R^m
02:52:21 <mbwgh> This ADT kind of thinking is maybe stretching it a little. I meant (R^m -> R^n).
02:52:41 <mniip> it's not "^"
02:52:51 <jle`> mbwgh: i'm saying that if you have bases v1, v2, v3, you can represent any vector x as (a v1 + b v2 + c v3)
02:52:55 <mniip> "^" only means hom-sets in Set
02:52:59 <mbwgh> So if you're talking about the base of, say, R^m, you would only regard some set of vectors of cardinality m, for instance.
02:53:15 <mbwgh> mniip: So this is the "stretching it a little" part?
02:53:18 <mniip> yes
02:53:21 <jle`> mbwgh: so f(x) is really f(a v1 + b v2 + c v3), which is just a f(v1) + b f(v2) + c f(v3)
02:53:36 <jle`> mbwgh: yes, you only need to talk about m basis vectors to fully describe f
02:53:42 <quicksilver> mniip: not necessarily. That notation is used in any category said to have exponential objects.
02:54:04 <quicksilver> mniip: (but, admittedly, matrix spaces are not exponential objects as far as I can see)
02:54:17 <jle`> mbwgh: since f(x), for *any* x, is just a linear combination of f(v1), f(v2), and f(v3)
02:54:21 <mniip> or are they
02:54:25 <jbetz> in cabal, is there a way to say that a build target has the same build dependencies as another, or the same plus or minus some?
02:54:40 <jle`> mbwgh: so knowing f(v1), f(v2), and f(v3) gives you all information possible about f
02:54:40 <quicksilver> well they're exponentials of the for R^(m*n)
02:54:46 <mniip> so?
02:55:22 <mniip> oh there's the deal, is the morphism eval : (\vec v, A) \mapsto A\vec v  linear?
02:55:30 <jle`> jbetz: there might be some recent advancements in common stanzas, but usually i just use hpack for stuff like that
02:55:51 <mniip> it is bilinear
02:55:58 <mniip> so it's not a morphism in Vect
02:55:59 <mbwgh> jle`: Is linearity a homomorphism for some (V, +, *)? I never see it called that way.
02:56:41 <jle`> mbwgh: yes, it's actually one of the examples in the wikipedia entry for homomorphisms
02:57:12 * hackage tasty-rerun 1.1.12 - Run tests by filtering the test tree depending on the result of previous testruns  http://hackage.haskell.org/package/tasty-rerun-1.1.12 (OliverCharles)
02:57:19 <jle`> a linear map, that is
02:57:52 <jle`> a linear transformation is essentially a vector space homomorphism
02:58:37 <shachaf> But that sentence is defining "vector space homomorphism", not "linear transformation"
02:58:42 <mbwgh> How would you write down the "algebraic structure tuple" for some vector space with a non-fixed field? Would that be (V, F, +, *)? I've seen it either written in words, or using more complicated notation, like mappings from F to some Hom(...), but never like that.
02:58:51 <shachaf> "homomorphism" isn't really a word with a precise meaning in general
02:59:03 <mbwgh> shachaf: I
02:59:12 * hackage tasty-ant-xml 1.1.4 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.1.4 (OliverCharles)
02:59:22 <jle`> shachaf: yes fair enough, realized that after i typed it that "is" is not the right word
02:59:42 <mbwgh> shachaf: I've always thought that it meant mapping some structure (M, op, e) to some other structure (M', op', e') while preserving the laws.
02:59:52 <mbwgh> Are there different meanings?
03:00:13 <shachaf> That's a universal algebra definition which is reasonably general, I guess
03:00:25 <shachaf> But it doesn't cover topological spaces for example
03:01:00 <shachaf> (You can argue that Chu spaces give the best general precise meaning of "homomorphism". But not many people do.)
03:01:49 <mbwgh> To be fair, I don't see myself arguing about Chu spaces in the near future :)
03:02:02 <mniip> jle`, mbwgh I wouldn't call linearity a "homomorphism" - personally I reserve that word for various models: monoids, rings,...
03:02:15 <mniip> "linear map" is a kind of morphism though: in the category of vector spaces
03:03:27 <mniip> by model I mean the thing that goes "a finite set of functional symbols and a finite set of predicate symbols and a function from those to their arity"
03:03:42 * hackage logging-effect 1.3.0 - A mtl-style monad transformer for general purpose & compositional logging  http://hackage.haskell.org/package/logging-effect-1.3.0 (OliverCharles)
03:04:38 <mbwgh> Could you expand on that, say for monoid? Just so that I'm able to follow your terminology
03:04:49 <shachaf> Are you OK with vector spaces over a finite field? :-)
03:05:19 <shachaf> It's kind of a silly argument, anyway, because everyone knows what you're talking about. Doesn't matter too much what you call it.
03:05:56 <mniip> mbwgh, a monoid has one binary functional symbol: + and one predicate symbol: =
03:06:00 <mniip> also binary
03:07:22 <mniip> a group also has an unary functional symbol: -
03:07:47 <mniip> oh
03:07:54 <mbwgh> I've spent the whole weekend wrapping my head about AD, and the correct types of operations like multiplication or the differentiation operator. When you look at the literature, f(x) denotes both the function and a point in its codomain, which can become confusing. This is some kind of thing where "everyone knows what you're talking about" does complicate things
03:07:55 <mniip> a monoid also has a functional symbol of arity 0
03:07:59 <mniip> the '0' constant
03:08:02 <mbwgh> s/about/around
03:08:47 <mniip> in some literature functions and dependencies are mixed up yes
03:08:53 <mniip> in my experience happens mostly in physics
03:09:04 <mbwgh> And in school :)
03:09:25 <mniip> you have various P(V, T), T(V, P) which make no sense if we were to interpret anything here as "function"
03:09:53 <shachaf> mbwgh: People mix up a lot of other things too. Like thinking of the derivative, which really ought to be a linear map, as a scalar.
03:10:16 <mniip> derivative is an (R -> R) -> (R -> R) operator
03:10:19 <mbwgh> Yeah but y = f(x) is colloqially introduced as function
03:10:28 <mniip> mbwgh, only "f" here is the function
03:10:36 <mbwgh> exactly
03:10:42 <shachaf> mniip: That only works in one dimension.
03:10:58 <mniip> shachaf, sure
03:11:06 <mbwgh> In QM, "d/dx" suddenly becomes an "operator". So does "x" by the way
03:11:25 <mniip> (G -> H) -> (G -> H) where G, H are lie groups
03:11:36 <mniip> that's about as general as I can pretend to know :p
03:11:48 <shachaf> Physicists have a lot of notation, and some of it works pretty well when you figure out what it really means
03:11:54 <shachaf> Or even when you don't
03:13:02 <shachaf> mniip: I was thinking e.g. (R^n -> R^m) -> R^n -> (R^n -o R^m)
03:13:14 <shachaf> Where -o is a linear map
03:13:46 <mniip> hmm
03:13:49 <mniip> that's 'differential'
03:13:50 <hvr> shachaf: sometimes physicists' notation feels like duck typing to me
03:13:53 <mniip> not 'differentiation'
03:14:05 <mniip> oh er
03:14:05 <shachaf> ?
03:14:09 <mniip> I was thinking 'derivative'
03:15:05 <mniip> df(x) is a linear map, yes. f'(-) not so much
03:16:07 <shachaf> I don't know what those are
03:16:20 <mniip> hvr, too me 2 years of failing at physics to understand that for a physicist y(x) means a dependency in general and not any specific function
03:16:36 <mniip> took*
03:19:36 <shachaf> This is enough typing on my phone for one night. I'll go to sleep instead.
03:24:07 <jophish> int-e: have you had any further thoughts on this: https://github.com/ghc-proposals/ghc-proposals/pull/28
03:24:58 <Tops2> Is there a way to neatly convert a boolean to an Integer? I can only come up with "if b then 1 else 0"
03:25:20 <Taneb> :t fromEnum :: Bool -> Int
03:25:22 <lambdabot> Bool -> Int
03:25:29 <Taneb> > fromEnum True
03:25:31 <lambdabot>  1
03:25:33 <Taneb> > fromEnum False
03:25:36 <lambdabot>  0
03:25:36 <jophish> hey Taneb, how's things?
03:25:44 <Taneb> jophish: not bad, not bad
03:25:53 <opqdonut> I wouldn't use fromEnum for that, it's kind of an implementation detail that Bool is ordered False<True
03:25:57 <Taneb> Things are all go here
03:26:11 <opqdonut> > bool 0 1 False
03:26:12 * hackage cql 4.0.1 - Cassandra CQL binary protocol.  http://hackage.haskell.org/package/cql-4.0.1 (romanb)
03:26:12 <jophish> So I hear, sounds very busy
03:26:13 <lambdabot>  0
03:26:16 <opqdonut> > bool 0 1 True
03:26:19 <lambdabot>  1
03:26:29 <opqdonut> ^ That's what I'd use, or just the if-then-else
03:27:18 <Tops2> ok, that helped me, thank you :)
03:27:19 <opqdonut> note that if you want an actual Integer, you need to combine something with fromEnum anyway, since fromEnum produces Ints
03:27:51 <Tops2> yes, I want an actual Integer
03:29:12 <int-e> jophish: only that I don't have any time or energy to push this through... maybe I should've added a comment that it's up for adoptation.
03:29:31 <jophish> int-e: it doesn't seem like there's much more to do in it
03:29:47 <jophish> as in, I can't see why it shouldn't be merged in now personally
03:44:29 <dysfun> i want to incrementally parse json, but aeson seems to have no support for this. where do i go now?
03:45:05 <dysfun> specifically, i want to parse newline-delimited json that's streaming in from a socket
03:47:45 <lyxia> do you want to do things/return values before you get a whole value?
03:48:14 <dysfun> no, i'm happy to wait for an entire value at a time
03:48:31 <cocreature> dysfun: maybe something like pipes-aeson is what you’re looking for?
03:48:44 <dysfun> eek, i'm using conduit for everything else
03:49:06 <dysfun> but i suppose i can read their code and see how they're handling it
03:49:15 <cocreature> aeson exposes its attoparsec parsers
03:49:23 <dysfun> aha!
03:49:30 <cocreature> so if you can hook attoparsec into conduit, you can hook aeson into conduit
03:49:43 <dysfun> conduit-extra provides for exactly this
03:50:08 <dysfun> thanks, i hadn't realised the parsers were exposed
03:52:12 * hackage acquire 0.2.0.1 - Abstraction over management of resources  http://hackage.haskell.org/package/acquire-0.2.0.1 (NikitaVolkov)
03:58:42 * hackage ecstasy 0.2.1.0 - A GHC.Generics based entity component system.  http://hackage.haskell.org/package/ecstasy-0.2.1.0 (isovector)
04:19:15 <int-e> jophish: oh I sent you a private message ... are you blocking those?
04:40:00 <dminuoso> Currently I have a `WriterT [Attr] ...` in my stack, where I can collect response attributes early on. Right now I have a `acceptWith :: [Attr] -> Handler Packet` that can add some final attributes before responding.
04:40:23 <dminuoso> Would it make sense to ditch this in favor of `tell`ing these attributes and then just using `accept :: Handler Packet`?
04:56:55 <ph88> how can i make this function work for Text ?  https://bpaste.net/show/23ba15bad75a
04:58:02 <cocreature> ph88: use "string" instead of "char"
04:58:10 <cocreature> ph88: "char" is for parsing a single character
04:58:31 <ph88> but sometimes i need to parse a single character
04:58:35 <ph88> like a semicolon
04:58:48 <cocreature> well you can use a single-character Text
04:58:53 <cocreature> or use "char" in those cases
04:59:21 <cocreature> but chrt takes a Text as its argument so you need to use "string" not "char"
05:00:20 <ph88> ooh
05:01:30 <ph88> but now when i use my function i get    chrt '\\'   Couldn't match expected type ‘T.Text’ with actual type ‘Char’
05:01:44 <ph88> char is not overloaded to be Text of size 1 ?
05:01:48 <isovector> no
05:01:49 <cocreature> use chrt "\\"
05:02:14 <cocreature> OverloadedStrings converts double-quoted string literals to Text, not single-quoted char literals
05:02:38 <ph88> what if i want to input a Char but have the parses yield Text ?
05:03:11 <cocreature> either use "char" and convert the output or use "string" and convert the input
05:03:32 <cocreature> i.e. Text.singleton <$> char c or string (Text.singleton c)
05:03:34 <ph88> so maybe   pack <$> M.char c   ?
05:03:40 <ph88> ah ok great
05:03:45 <ph88> i'll go for that
05:03:57 <cocreature> pack converts a list of Chars to Text, not a single Char
05:04:39 <ph88> do you think this makes a difference in resulting binary ?   Text.singleton <$> char c or string (Text.singleton c)
05:07:22 <cocreature> probably. but I doubt it makes a difference in performance
05:09:01 <ph88> thank you cocreature
05:28:28 <maerwald> there's still no alternative to ghc-mod, is there?
05:33:32 <MarcelineVQ> there's several, including intero, dante (leverages ghci), haskll-ide-engine, and (depending on what al features you're after) ghcid
05:38:12 * hackage network-simple 0.4.1 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.4.1 (RenzoCarbonara)
05:41:12 * hackage katydid 0.3.1.0 - A haskell implementation of Katydid  http://hackage.haskell.org/package/katydid-0.3.1.0 (awalterschulze)
05:41:17 <maerwald> intero is written for stack and emacs
05:41:23 <maerwald> and it doesn't have completion afaik
05:42:54 <maerwald> haskell-ide-engine was what I rememberd I think
05:44:26 <maerwald> but no vim integration
05:46:01 <MarcelineVQ> it's got neovim
05:46:16 <maerwald> that's not vim
05:51:22 <mbwgh> I have a question again about what we talked about before, maybe it's more general. I was playing around with some chain rule examples. Using Euler notation, it is defined as `D (f . g) = (D f . g) * (D g)`, where * is point-wise multiplication of functions for the one-dimensional case. If you have higher-dimensional functions, say if `f` and `g` return or accept some tuple, if you want to calculate "the
05:51:28 <mbwgh> derivative, without loss of information", Jacobians more or less fall out naturally if you calculate "all the partials you can". Then, (*) might have some type along the lines of `(*) :: Num a => ((a, a) -> (a, a)) -> ((a, a) -> ((a, a), (a, a))) -> (a, a) -> (a, a)`. If you squint a little, you have a vector and a matrix, which you can "somehow mush together" to get another vector (matrix multiplication
05:51:34 <mbwgh> seems like a natural choice). But you have to "get them" first by applying the last argument to all of the functions. This looks awkward, but hey we're in the reader monad so it can look nice again. Oh wait, the applicative suffices. Oh wait, any Applicative suffices. Anyhow, using the syntactic sugar it reads nicely again, as if the continuations never existed. But this reminds me again of when people use
05:51:40 <mbwgh> f(x) to denote both a function and its output, which works out fine if things like (f * g) are defined point-wise as \x -> f x * g x. And afterwards I read the beautiful differentiation paper by Conal Elliot, where he arrived at similar results. This might all be super trivial and coincidental, but I can't shake the feeling that there's something deeper going on that I could learn from. What is it though?
05:51:47 <mbwgh> Sorry for the verbosity and fuzzy question.
05:53:46 <lyxia> sounds related to the type of jacobian in https://hackage.haskell.org/package/ad-4.3.5/docs/Numeric-AD.html#v:jacobian
06:06:14 <mbwgh> I was more thinking along the lines of this: People confuse functions with their outputs all the time. It seems to work out most(?) of the time. In the specific example, the "multiplication" operator was actually a specific function composition operator (I started with the rest and arrived at the inferred type). But the Monad instance for ((->) r) allows me to treat functions as if the argument had already
06:06:20 <mbwgh> been applied, turning composition into (matrix) multiplication again by "allowing me to confuse functions with their outputs again". Up until now, I thought that the F/A/M instances of ((->) r) were just some curiosity. I think I read that pure and ap are the K and S operators, too, but didn't think much of it. I just feel like there is something to be understood here...
06:07:38 <mbwgh> It could just as well be that I am chasing after a boring tautology.
07:01:01 <maerwald> https://youtu.be/kZL41SMXWdM cool talk about event sourcing
07:06:12 * hackage ghc-prof 1.4.1.2 - Library for parsing GHC time and allocation profiling reports  http://hackage.haskell.org/package/ghc-prof-1.4.1.2 (MitsutoshiAoe)
07:20:48 <cheater> JonnyRaa: :)
07:20:52 <treborobert> newb question.  is there a way in Prelude to enter multiple commands, like you can in bash with &&?  I'm working on a module, and to test it in Prelude, I have to reload it  ":l mymodule.hs" and then to test my function "mymodule 4"
07:21:29 <ventonegro> treborobert: it's called the REPL, not Prelude
07:22:17 <Taneb> treborobert: I think you mean "GHCi", not "Prelude". Prelude is the library which is imported automatically, and GHCi uses the imported libraries as its prompt (which is why it says "Prelude>")
07:23:12 * hackage djinn-lib 0.0.1.3 - Generate Haskell code from a type. Library extracted from djinn package.  http://hackage.haskell.org/package/djinn-lib-0.0.1.3 (AlejandroSerrano)
07:23:34 <Taneb> treborobert: to answer your actual question, I don't think there is a way to do that
07:24:29 <cocreature> depends on what you mean by “command”. if we’re talking about IO actions you can use do notation to combine multiple actions
07:25:22 <Taneb> cocreature: :l is a GHCi command
07:25:25 <ventonegro> they want to mix GHCi commands (reload) with evaluation
07:25:51 <cocreature> ah
07:30:13 <treborobert> sorry for the incorrect terminology.  yes, i want to be able to do reload and run in one line.
07:30:20 <treborobert> is that possible?
07:30:36 <treborobert> Taneb ok.  thank you.
07:30:45 <Lears> If you just compile and run the executable from a regular shell it's not difficult.
07:31:30 <treborobert> Lears ok.  I'll do that instead.  I just thought there might be a way to do it in GHCi.
07:32:03 <cocreature> treborobert: you can write the commands in a script and load that script using :script
07:33:35 <treborobert> cocreature ok i'll look into that later.  for now i'll just go the regular shell route.  thank you all.
07:34:38 <hexagoxel> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:def
07:35:15 <hexagoxel> so if you put `:def combine \x -> return $ map (\c -> if c == ';' then '\n' else c) x` in your .ghci
07:35:39 <hexagoxel> then i _think_ you can do :combine :reload; main
07:36:06 <hexagoxel> or otherstuff like a custom :reloadand def
07:36:22 <mbwgh> treborobert: You could also just keep ghci running, have the editer in another window. The command history can be "traversed" with the arrow key. So you don't have to retype `:reload` and `mymodule 4`, just press (up up enter, up up enter). I know this isn't ideal either, but better than nothing
07:48:02 <jophish> hexagoxel: hi, are you around?
07:48:57 <hexagoxel> jophish: yeah, what's up?
07:52:25 <jophish> hexagoxel: Is anything happening with iridium?
07:52:44 <jophish> because it's really nice!
07:52:57 <newbiee> hi o/
07:53:03 <jophish> hey, newbiee
07:57:21 <hexagoxel> jophish: thanks! and yeah sorry, i have some changes lined up that i have not pushed/published yet.
07:59:07 <hexagoxel> the next goal was to properly support new-build, including testing with different ghc versions, but that bit is still in planning phase.
08:00:17 <hexagoxel> (and stack support would be pretty similar to new-build.)
08:01:12 * hackage vector-sized 1.0.2.0 - Size tagged vectors  http://hackage.haskell.org/package/vector-sized-1.0.2.0 (jophish)
08:06:24 <jophish> hexagoxel: looking forward to it!
08:06:26 <newbiee> i just need a confirmation, once i created my project with stack, to create an executable to run it i just have to do "stack build" and then "stack exec my_name_project" ?
08:07:09 <exarkun> my_executable_name
08:07:17 <exarkun> which may or may not be the same as your project name, I guess
08:09:07 <newbiee> ok thanks, i probably missed something during the build of my project
08:13:13 <hexagoxel> jophish: i have pushed what i have so far
08:13:19 <mbwgh> newbiee: The executable name is inside the package.yaml
08:13:41 <mbwgh> newbiee: By default, that is <your-project-name>-exe
08:14:10 <jophish> Thanks!
08:14:13 <mbwgh> newbiee: Unless you used a different stack template than the current default one, or none at all
08:15:39 <newbiee> @mbwgh yep i find it in .stack-work/install/x86_64-linux/lts-11.9/8.2.2/bin
08:15:39 <lambdabot> Unknown command, try @list
08:15:51 <simon> I'm toying around with an AST, trying to parameterize all its sub-constructors so that the same AST can be used for keeping parse information at first, and then type annotations later. it turns out that this means I have to change all cases of pattern matching throughout the code. I recall a professor once saying that that's a drawback with using pattern matching extensively. what do you guys do? use an abs
08:15:57 <simon> tract interface or wrap this up as a one-time cost?
08:16:26 <newbiee>  mbwgh yep i find it in .stack-work/install/x86_64-linux/lts-11.9/8.2.2/bin
08:17:12 <newbiee> i used the simple template, not the default one, i don't have the app dir and other conf files
08:17:24 <newbiee> but it's good now :)
08:29:08 <EvanR> simon: another way is to use a separate ADT for the other kinds of info
08:30:19 <EvanR> also you should check out generic programming for traversing these kinds of trees, the traversing algorithm can be extracted ad reused
08:31:18 <Ariakenom> Generic is such a bad name :(
08:31:59 <EvanR> yeah because i cant find the refernce....
08:35:07 <Ariakenom> Are there any fancy fast|small encodings of Rationals?
08:36:11 <dmwit> I don't know of anything faster or smaller than Rational but with the same denotation.
08:36:22 <EvanR> two recursively runlength encoded naturals with a sign bit?
08:37:25 <dmwit> What is "recursively runlength encoded" and why is it good?
08:38:25 <EvanR> https://link.springer.com/chapter/10.1007/978-3-319-10882-7_24
08:39:02 <EvanR> the size
08:39:05 <EvanR> for one thing
08:39:06 * ski . o O ( : Tarau : )
08:39:42 <exarkun> Ariakenom: What are you using Rational for?
08:40:14 <exarkun> If your requirements are "Rational" it's hard to find something that beats Rational.  Maybe your requirements are different, though, and Rational is only one solution you've found so far.
08:40:17 <Ariakenom> nothing in particular why? just wondering about a default number type
08:40:49 <EvanR> naturals :)
08:42:22 <Ariakenom> Oh right I said Rationals. I meant rationals :p
08:42:22 <EvanR> ime no matter what the default number type is, it will soon be inappropriate for whatever reason
08:43:25 <EvanR> even if you pick surreals, that doesnt give you matrix arithmetic for example
08:43:33 <Ariakenom> And I'm not after rationals per se.
08:43:33 <dmwit> `Double`s are very fast, vaguely fancy, and can represent many rationals.
08:43:35 <Boomerang> Ariakenom: What are you willing to give up for fast|small encoding of rationals? Dynamic range, precision? If neither then Rational is probably the best option :)
08:44:11 <exarkun> If you don't actually have any requirements, anything will do.  I suspect it's more likely that you just haven't figured out the requirements yet.
08:44:16 <EvanR> i'm willing to give up the problems with rational arithmetic
08:44:17 <mnoonan> for some purposes, it might be useful to use continued fraction expansions
08:44:20 <Ariakenom> Well the desired attributes aren't defined
08:44:28 <mnoonan> but not for most purposes, I'd bet :)
08:44:52 <dmwit> Wise tautology #5: The solution depends on the problem.
08:45:27 <EvanR> since a solution might solve more than one problem, you could solve first then search for the problem :)
08:45:27 <Ariakenom> The one problem with Rational I've heard is that the memory usage can run away
08:45:28 <ski> monochrom should add that to his list, if he haven't already
08:45:40 <Ariakenom> with sin - exp and similar I'd think
08:45:43 <exarkun> Ariakenom: If you want a one-size-fits-all solution, you're not going to find it.
08:45:56 <dmwit> ski: It is #5 on his list. =)
08:46:07 <ski> ok : )
08:46:10 <EvanR> even worse you cant do sin or exp on rationals
08:46:17 <ski> it sounded like the style of the rest
08:46:35 <Zemyla> I want an Algebraic type which allows encoding any solution of a polynomial.
08:46:38 <dmwit> Rational does not support sin or exp.
08:46:57 <Ariakenom> My current solution is Rational with the denominator limited to N-bits. Where N is a few words.
08:47:02 <dmwit> Zemyla: You might like the cyclotomic package.
08:47:21 <dmwit> Ariakenom: Then you might like the Fixed type, available from base.
08:47:29 * ski . o O ( <https://en.wikipedia.org/wiki/Rational_trigonometry> )
08:47:31 <maerwald> do we have a nice library for symbolic computation wrt numbers then?
08:47:38 <dmwit> (Though it does have slightly different tradeoffs than what you describe.)
08:47:41 <noan> I just realized http://hackage.haskell.org/package/async-pool-0.9.0.2/docs/Control-Concurrent-Async-Pool.html is not a monad
08:47:51 <noan> Is there a monad form of something similar?
08:47:52 <Zemyla> Don't use Fixed yet, it's still broken.
08:48:51 <Zemyla> > realToFrac (1.7 :: Double) :: F.Fixed F.E1
08:48:53 <lambdabot>  1.6
08:49:08 <dmwit> > fromRational 1.7 :: F.Fixed F.E1
08:49:11 <lambdabot>  1.7
08:49:18 <dmwit> I blame Double, not Fixed.
08:49:23 <ski> it truncates ?
08:49:33 <Zemyla> I blame fixed because the representation of 1.7 in Double is 1.699something.
08:49:42 <Zemyla> It truncates, not rounds.
08:49:43 <Ariakenom> Fixed is base 10? I think I want it to work perfectly for small rationals
08:50:09 <Zemyla> Fixed is a custom base.
08:50:12 <dmwit> What promise of fromRational is broken?
08:50:52 <Ariakenom> is it N / B where B is fixed?
08:50:57 <dmwit> Yes.
08:51:06 <Gurkenglas> Intero should attempt stack install hlint if it does not find hlint
08:52:47 <Ariakenom> The one disadvantage with that to a dynamic B is factors.
08:53:25 <Zemyla> I am pretty sure it also truncates when doing multiplication and causes incorrect results.
08:53:59 <EvanR> when i see 1.7 double, i do not think "1.7"
08:54:00 <Ariakenom> My solution also truncates. Seems the right choice for my vague goals.
08:54:05 <EvanR> i think 1.6999...
08:54:27 <EvanR> rounding seems more complicated than truncating
08:54:33 <EvanR> to reasonabout
08:55:13 <EvanR> however, if you know that someone is giving you a "2-decimal-places-float"... then you could round in order to recover a decimal number
08:55:33 <EvanR> i dont have enough space in my margin for the proof however
08:56:05 <shapr> I want to build a simple repl that lets me edit a chunk of json I fetch via http, do you think yocto or aeson would be friendlier to tab completion with Haskeline?
08:56:13 <shapr> or is there a better option?
08:57:20 <Ariakenom> With the Fixed base set to some large number you can't represent, say, a base that's a power of 2 about that big.
08:58:12 <Ariakenom> and a power of 3 base, just smaller than a limit
08:58:30 <EvanR> you should make egyptian fractions the default
08:58:50 <Ariakenom> show instance requires unicode terminal?
08:59:12 <EvanR> lol
09:00:09 <EvanR> you can use modern notation. 1/3 + 1/5 + 1/10
09:00:46 <EvanR> yocto seems very spartan
09:00:46 <Ariakenom> thanks for the links and discussion
09:00:52 * Ariakenom waves
09:02:12 <Gurkenglas> maximumOn *still* isn't in base? :I
09:02:38 <maerwald> oh jeez, haskell-ide-engine requires stack -.-
09:03:29 <cocreature> Gurkenglas: and the versions you can find in some packages (e.g. the one in extra) don’t actually behave like sortOn in that they cache results but are just a wrapper around maximumBy
09:03:51 <dminuoso> Is there some lens trick you can do for this?  ifH c t = view pType >>= \ty -> guard (ty == c) >> t
09:04:10 <dminuoso> Basically I want to something along the lines of `ifH Foo a <|> ifH Bar b`
09:06:16 <dminuoso> Or maybe I should gist the real code I have right now
09:06:30 <dminuoso> https://gist.github.com/dminuoso/e9ac9ec118e951634c84a0ffc215cafa
09:06:51 <Gurkenglas> https://github.com/ndmitchell/hlint#emacs-integration doesn't find "hs-lint"
09:08:29 <cocreature> Gurkenglas: have you installed the hs-lint.el file?
09:08:44 <Gurkenglas> :t mfilter (==c) (view ?pType) >> ?t
09:08:45 <lambdabot> (?t::m b, ?pType::Getting Expr s Expr, MonadReader s m, MonadPlus m) => m b
09:09:09 <Gurkenglas> cocreature, not manually. that link says "a copy is installed locally in the data directory" though
09:09:29 <cocreature> Gurkenglas: right but you still need to add it to your load path if you want emacs to find it
09:09:45 <Gurkenglas> What is a load path? Shouldn't that link mention this?
09:09:52 <cocreature> something like (add-to-list 'load-path "path/to/data/dir")
09:10:35 <cocreature> the load path is the list of paths that emacs searches if you require something
09:10:38 <Gurkenglas> hmk. Do you also know how I find this data directory?
09:10:57 <cocreature> depends on how you installed hlint
09:11:10 <Gurkenglas> stack install hlint
09:11:21 <dminuoso> Gurkenglas: Wait. What is that ? magic?
09:11:39 <Gurkenglas> :t ?x -- dminuoso, implicit parameters
09:11:40 <lambdabot> (?x::t) => t
09:12:25 <Gurkenglas> @let gurktest = ?x + ?x
09:12:27 <lambdabot>  Defined.
09:12:30 <Gurkenglas> :t gurktest
09:12:31 <lambdabot> (Num a, ?x::a) => a
09:12:33 <Gurkenglas> > gurktest
09:12:35 <lambdabot>  mueval-core: internal error: PAP object entered!
09:12:35 <lambdabot>      (GHC version 8.2.2 for x86_64_unknown_linux)
09:12:35 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
09:12:38 <Gurkenglas> > let ?x = 5 in gurktest
09:12:40 <lambdabot>  error:
09:12:40 <lambdabot>      • Couldn't match expected type ‘p’
09:12:40 <lambdabot>                    with actual type ‘forall a. (?x::a, Num a) => a’
09:12:46 <Gurkenglas> > let ?x = 5 :: Int in gurktest
09:12:49 <lambdabot>  error:
09:12:49 <lambdabot>      • Couldn't match expected type ‘p’
09:12:49 <lambdabot>                    with actual type ‘forall a. (?x::a, Num a) => a’
09:12:49 <mbwgh> What, people use XImplicitParams ?
09:12:51 <Gurkenglas> hmm.
09:13:06 <glittershark> How do I make a pattern for a closed type family only match when two type variables are equal?
09:13:17 <glittershark> I'm trying to make a custom TypeError for when a type-level list is non-unique
09:13:32 <Gurkenglas> > let ?x = (5 :: Int) in ?x + ?x -- ???
09:13:34 <lambdabot>  10
09:13:45 <Gurkenglas> muh referential transparency :(
09:14:01 <glittershark> This warns about the last two patterns overlapping: https://gist.github.com/glittershark/97383c51ab7194f5d0663c9183143edf
09:14:25 <glittershark> is this just something I'm going to have to do with an inductive typeclass?
09:14:56 <dminuoso> Gurkenglas: Ah I see. Thanks for pointing me to mfilter, it looks like the combinator I was missing. :)
09:15:25 <lyxia> glittershark: swap the last two clauses
09:15:51 <lyxia> glittershark: the order of the clauses of a closed type family matters.
09:15:53 <EvanR> ski: rational trig is cool
09:16:12 <glittershark> oh nice lyxia
09:16:14 <glittershark> tyyy
09:25:50 <cocreature> Gurkenglas: it looks like stack doesn’t install data files so you’re going to have to manually copy this somewhere https://github.com/commercialhaskell/stack/issues/1005
09:26:50 <gentauro> parsing question :) I'm trying to parse a very basic domain (SKK combinators) without the usage of Parsec (even though I end up creating a mini-version). I can easily parse "terms" when I over use parenthesis, but if I just use the necesary, I get stucked. I learned from the past, so here is a GIST to easy the question: https://gist.github.com/gentauro/aae12374d389c247b29134f7b01e5328
09:31:17 <gentauro> Boomerang: are you good at parsing, without using Parsec? :)
09:31:33 <EvanR> so if the grammar is t = S | K | t t, you have an infinite loop
09:33:00 <Boomerang> gentauro: Maybe, I've used Text.Read (from base) before. What are you trying to do?
09:34:20 <Boomerang> Text.ParserCombinators.ReadP (from base) can also be useful
09:34:24 <gentauro> I'm just parsing SKK combinators (very "easy" domain)
09:34:30 <EvanR> youll have to do e = t | t t, t = S | K | (e)
09:34:53 <gentauro> Boomerang: I created a gist -> https://gist.github.com/gentauro/aae12374d389c247b29134f7b01e5328
09:34:59 <Boomerang> Ah I didn't see the previous message (checking it oy now)
09:35:21 <gentauro> I just seem to get stucked in my psApp (goes into an inf. loop)
09:35:50 <EvanR> two mutually recursive parsers, one for e one for t
09:36:39 <EvanR> when separated and parentheses added to the rules, they dont have themselves as a possible prefix
09:37:43 <vidlew> > :m Control.Monad.Writer
09:37:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:37:53 <vidlew> > import Control.Monad.Writer
09:37:55 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
09:38:18 <vidlew> > return 5 :: Writer String Int
09:38:20 <lambdabot>  WriterT (Identity (5,""))
09:38:27 <vidlew> ok
09:39:22 <vidlew> > f = let fs = 0:1:(zipWith (+) fs $ tail fs) in (fs!!)
09:39:24 <lambdabot>  <hint>:1:3: error:
09:39:24 <lambdabot>      parse error on input ‘=’
09:39:24 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
09:39:39 <vidlew> > let f = let fs = 0:1:(zipWith (+) fs $ tail fs) in (fs!!) in f 5
09:39:41 <lambdabot>  5
09:39:47 <vidlew> > let f = let fs = 0:1:(zipWith (+) fs $ tail fs) in (fs!!) in f 6
09:39:50 <lambdabot>  8
09:41:09 <vidlew> how do you define variables with lambdabot
09:41:17 <vidlew> does it work like hugs or ghci
09:41:21 <EvanR> @let x = 0
09:41:23 <gentauro> EvanR: yes, I'm using t = S | K | t t
09:41:23 <lambdabot>  Defined.
09:41:32 <vidlew> oh nice
09:41:34 <EvanR> gentauro: thatll loop
09:41:48 <gentauro> yeah, pretty much
09:41:51 <EvanR> because of the "left recursion"
09:41:57 <vidlew> @let f = let fs = 0:1:(zipWith (+) fs $ tail fs) in (fs!!)
09:41:59 <lambdabot>  Defined.
09:42:01 <gentauro> but it doens't if I use parenthesis
09:42:04 <vidlew> > f 100
09:42:06 <lambdabot>  error:
09:42:06 <lambdabot>      Ambiguous occurrence ‘f’
09:42:06 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
09:42:14 <EvanR> well your grammar doesnt allow parentheses
09:42:21 <vidlew> @let fib = let fs = 0:1:(zipWith (+) fs $ tail fs) in (fs!!)
09:42:23 <lambdabot>  Defined.
09:42:27 <vidlew> > fib 100
09:42:29 <lambdabot>  354224848179261915075
09:42:54 <vidlew> > putStrLn "dwvcwdvcgvg"
09:42:56 <lambdabot>  <IO ()>
09:43:02 <vidlew> hm
09:43:08 <gentauro> EvanR: if I replace this line with "ps xy" (https://gist.github.com/gentauro/aae12374d389c247b29134f7b01e5328#file-skk-hs-L22)
09:43:15 <EvanR> gentauro: first, defined a "term" as an S or a K or a parenthesized expression
09:43:21 <gentauro> I can parse it with https://gist.github.com/gentauro/aae12374d389c247b29134f7b01e5328#file-skk-hs-L30-L49
09:43:21 <vidlew> getLine
09:43:24 <vidlew> > getLine
09:43:26 <lambdabot>  <IO [Char]>
09:43:34 <vidlew> very interesting
09:43:43 <EvanR> then parse 1 or more terms in a row, and foldl them with App
09:43:48 <EvanR> thats an expression
09:44:09 <EvanR> and it all loops around swimmingly
09:46:52 <EvanR> foldl1
09:50:33 <gentauro> EvanR: could you please specify "e = t | t t, t = S | K | (e)" in terms of data types in Haskell? Thx
09:52:03 <Cale> data Expr = ETerm Term | EApp Term Term; data Term = S | K | TExpr Expr
09:54:06 <gentauro> Cale: got it
09:55:37 <EvanR> you dont have to actually make two ADTs, but its more type safe if you do
09:56:12 * hackage hasql-optparse-applicative 0.3.0.1 - "optparse-applicative" parsers for "hasql"  http://hackage.haskell.org/package/hasql-optparse-applicative-0.3.0.1 (NikitaVolkov)
09:56:17 <EvanR> you just need two parsers
09:56:23 <vidlew> @list
09:56:23 <lambdabot> What module?  Try @listmodules for some ideas.
09:56:37 <EvanR> term :: Parser Expr, expr :: Parser Expr
09:56:49 <Cale> Yeah, I was just being very direct about the translation
09:57:22 <gentauro> EvanR: I'm guessing that I will need to have an intermidiate ADT, which can easily be translated to data Term = S | K | A Term Term right?
09:57:22 <Cale> data Expr = S | K | App Expr Expr  is probably sufficient
09:57:40 <EvanR> gentauro: not really ^
09:57:54 <gentauro> Cale: that's what I'm using right now -> https://gist.github.com/gentauro/aae12374d389c247b29134f7b01e5328#file-skk-hs-L3-L7
09:57:54 <Cale> You can just parse your concrete syntax directly to that
09:58:49 <EvanR> #haskell, mainly chat about parsers and build systems :)
09:59:02 <gentauro> and chatbots going insane :D
09:59:26 <infinisil> I created a nix eval bot for #nixos in Haskell \o/
10:01:30 <tdammers> the toolchain tarpit: as a language becomes more advanced, working on its toolchain becomes so interesting that nobody ever does anything else with it
10:04:33 <maerwald> tdammers: why is editor support still so poor then?
10:04:45 <Cale> infinisil: Are you using hnix? :)
10:08:34 <bbear> it is weird because I read books on DSL and compilers and Parsing Grammar but never they told me about Haskell.
10:08:37 <gentauro> and chatbots going insane :D
10:08:40 <gentauro> ups
10:08:46 <bbear> see ya
10:09:55 <Ariakenom> Hey who linked me cyclotomic? that's cool
10:18:48 <Sonolin> good morning everybody :)
10:20:30 <Ariakenom> good evening
10:21:01 <Sonolin> 'evening :)
10:38:49 <Mitsos101> Hello everyone! I haven't found any dynamic programming implementations using only lists on the Internet, so here's my implementation of the 0/1 knapsack problem: http://lpaste.net/365639 (wv = [(weight, value)]) Is there anywhere I can post this?
10:39:11 <maerwald> jesus :D
10:39:39 <maerwald> Mitsos101: maybe https://wiki.haskell.org/Dynamic_programming_example
10:40:14 <EvanR> lpaste is back o_O
10:42:18 <Mitsos101> maerwald: is it wiki-quality code though? I have 0 experience in Haskell
10:42:46 <EvanR> you could probably use a where clause and name some of these lambdas
10:43:29 <glguy> Mitsos101: You should work to break that expression up into more named pieces so that someone else could read it
10:43:47 <maerwald> haskell wiki is more throw-in stuff, not very well maintained, so it's fine to just add stuff imo
10:44:11 <Mitsos101> I initially did that, but I just named them "helper" and "fillTable", which isn't very descriptive
10:44:18 <glguy> Even if it's not well groomed it's good to only put useful stuff in in the first place
10:44:59 <glguy> Mitsos101: That's OK, above the implementation of "fillTable" you can include comments that explain what it does, what it's arguments mean, etc
10:45:04 <EvanR> name choices aside even if you used f1 f2 f3... the multiple lines would help a lot
10:46:37 <Mitsos101> glguy: the code is just two for-loops translated to Haskell, I don't know what to explain
10:46:42 <Mitsos101> EvanR: I see, good point
10:47:15 <glguy> Mitsos101: If it can't be explained, it might not be a good example for other people to see
10:47:51 <kuribas> Mitsos101: did you try to exploit lazyness?
10:48:29 <Sonolin> I love haskell :)
10:48:41 <Mitsos101> glguy: good point
10:48:46 <Mitsos101> kuribas: no, not at all
10:49:52 <kuribas> here's a nice problem: create a list of ascending numbers starting with 1.  If x is in the list, then so should (x*2), (x*3) and (x*5) be.  No other numbers should be in the list.
10:51:17 <kuribas> it has a nice elegant haskell solution
10:51:39 <nikivi> Can someone explain me the difference between a type and a data structure?
10:51:57 <nikivi> I am trying to understand why some say things like 'Haskell/Rust has stronger types than Go'
10:52:04 <nikivi> I thought that you can create custom types in Go as type is just a data structure
10:52:09 <Mitsos101> What this code does is exploit the structure of the relation f(i, j) = max(f(i - 1, j - w[i]) + v[i], f(i - 1, j)), so we just move the DP table w[i] indices back and add v[i] to every element, and zip them together. (in retrospect, it seems that if I used drop instead of chunksOf, this would be more readable)
10:53:37 <kuribas> nikivi: I think it means that haskell has stronger type safety garantees.
10:54:17 <kuribas> nikivi: the type determines which data structure you use.
10:54:20 <dminuoso> nikivi: Type theory goes much much further than just tagging data.
10:54:22 <nikivi> I am also curious, for example JavaScript doen't have an Integer type
10:54:27 <nikivi> Can you make a custom integer type?
10:54:35 <nikivi> Or it's a limitation of the language
10:54:35 <dminuoso> nikivi: JavaScript has only a single `Object` type.
10:54:41 <kuribas> nikivi: yes, but it will not be efficient.
10:54:50 <kuribas> nikivi: you could define an integer inductively.
10:54:53 <EvanR> there are several Integer implementations for js
10:55:06 <dminuoso> nikivi: What you are referring to is a design problem that stems from the fact that JavaScript was developed in 10 days.
10:55:10 <EvanR> they can be made more efficient by exploiting floating point
10:55:15 <dminuoso> nikivi: There was simply no time to put in any integer objects.
10:55:36 <mizu_no_oto> nikivi: types in Javascript are fundamentally different from types in e.g. Haskell.
10:55:39 <EvanR> they didnt listen to me when i said, just provide a natural number type
10:55:55 <dminuoso> nikivi: But JavaScript does not have types (or it has just a single generic "Object" type)
10:56:00 <nikivi> dminuoso Why doesn't JS still have an Integer type?
10:56:09 <nikivi> It's been many years since it's been made
10:56:13 <nikivi> not have*
10:56:38 <nikivi> mizu_no_oto How are they fundamentally different?
10:57:00 <dminuoso> nikivi: You'd have to ask the committee.
10:57:02 <nikivi> dminuoso When you say 'Type theory goes much much further than just tagging data'. Do you mean that you can use types to talk about relationships?
10:57:16 <EvanR> https://brendaneich.com/2010/10/should-js-have-bignums/
10:57:24 <EvanR> haha
10:57:29 <mizu_no_oto> nikivi: In Haskell, you could say that the type system is a syntactic method for classifying program phrases according to the kinds of values they compute.
10:57:50 <dminuoso> ^- quoted from Types and Programming Languages. ;)
10:58:07 <maerwald> nikivi: go is as type safe as haskell, the language doesn't allow invalid operations on data types. What people mean with "weak" is often expressivity. Go's enums sucks and it doesn't have ADTs or generics
10:58:14 <mizu_no_oto> That is to say, you can look at the text of the program, and types are assigned to expressions statically.
10:58:16 <AWizzArd> Do we have someone here who knows the Rete algorithm pretty well?
10:58:28 <kuribas> isn't it so that haskell types are based on (mathematical) type theory, while in other languages they are ad-hoc?
10:58:40 <dminuoso> nikivi: But yes. Haskells type system lets you express a lot of domain specific invariants and logic in a statically verifiable manner.
10:58:42 <kuribas> (other languages = mainstream languages)
10:59:03 <mizu_no_oto> In Javascript, a type is really a runtime tag describing the actual kind of data you have at runtime.
10:59:34 <EvanR> that blog post from brendan eich and the comments is probably a very good clue to why js is or is not whatever
10:59:37 <maerwald> nikivi: so when people talk about strong type system, they usually just mean expressivity, not safety
10:59:38 <hexagoxel> Mitsos101: without considering if you solve the exact same problem, have you seen https://rosettacode.org/wiki/Knapsack_problem/0-1#Haskell ?
11:00:03 <dminuoso> nikivi: As an example take: data Expr a = Add (Expr a) (Expr a) | Sub (Expr a) (Expr a) | Eq (Expr a) (Expr a) | Lit a
11:00:12 <nikivi> maerwald I see now, thank you. You can still write generics and ADTs in Go thought, just that language has no first class support for it, right?
11:00:13 <hexagoxel> either way, rosettacode seems to be a good place for such examples
11:00:29 <maerwald> nikivi: as the language is turing complete, you can do anything, but good luck with that
11:00:54 <maerwald> to simplify: no, you can't (unless you are insane) ;)
11:01:12 <dminuoso> nikivi: And maybe extend this with some further `... | Truth Bool`
11:01:24 <mizu_no_oto> Bob Harper would describe JS as being 'unityped' since it can really only be statically typed by saying every expression is the tagged union of object, double, array, etc. etc.
11:02:09 <Mitsos101> hexagoxel: it's the same problem, thanks
11:02:37 <mizu_no_oto> Whereas in Haskell, you can actually have programs that fail to compile due to distinctions that don't exist at runtime - for example, that you tried to use an Int that represents an X coordinate somewhere you expected a Y coordinate.
11:03:00 <dminuoso> nikivi: Or rather.. just look into GADTs. They might give you a radically simple way to express things that rudimentary type systems like Go's cant express.
11:03:01 <mizu_no_oto> Even though it's just compiled to a hardware int.
11:03:02 <infinisil> Cale: Nope, not using hnix. Last time I checked it wasn't ready for use at all, but johnw has done a lot of work on it, so I'm gonna give it a go again soon
11:03:42 <maerwald> dminuoso: why would you need to look at GADTs?
11:04:13 <EvanR> i like radically simple
11:04:19 <maerwald> have you written some go yet? it doesn't even have typed enums, there is no reason to pull out GADTs
11:04:41 <EvanR> i should learn some go
11:04:48 <maerwald> EvanR: it will take you 30minutes
11:04:56 <infinisil> Go shall be burried in the ground
11:04:57 <nikivi> maerwald Only wrote Go and Python thus far, very interested in Rust/Haskell for its 'rich' type systems
11:05:14 <nikivi> Just was curious what was meant by 'rich' type systems
11:05:23 <EvanR> takeM_ 30minutes
11:05:28 <EvanR> exception: ran out of minutes
11:05:54 <infinisil> Just imagine if all the efforts of Google for Go went into Haskell (or similar) instead
11:06:00 <EvanR> infinisil: before or after i get a high paying job with it
11:06:07 <dmwit> maerwald: how long to learn rust
11:06:13 <maerwald> a week
11:06:21 <maerwald> maybe 2
11:06:39 <dmwit> dope. We should make a "how long it takes an X expert to learn Y" matrix.
11:06:39 <infinisil> There's a big difference between "learning" and "mastering" a language though
11:06:58 <maerwald> dmwit: well, go was the quickest for me so far. Because there is almost nothing to learn
11:07:13 <maerwald> the two pain points are: go routines and slices. Then you are done
11:07:32 <EvanR> the easiest language to learn in C, because i already know it
11:07:33 <infinisil> Go routines is just an async function, right?
11:07:36 <EvanR> is C
11:08:12 <mizu_no_oto> nikivi: Python's like JS in that its dynamically typed.
11:08:12 <maerwald> infinisil: https://stackoverflow.com/questions/4522387/how-can-i-emulate-gos-channels-with-haskell
11:09:17 <mizu_no_oto> Haskell has some nice features that are comparatively rare in statically typed languages, like 'algebraic data types'.  An ADT is basically a tagged union of structs.
11:09:22 <infinisil> Yeah but that's channels, not go routines, I don't think they are strictly related, they are just used often together afaik
11:09:54 <barrucadu> infinisil: A goroutine is a lightweight thread, like Haskell threads or Erlang processes.
11:10:17 <mizu_no_oto> So you might say 'data BinaryTree a = Node a (BinaryTree a) (BinaryTree a) | Leaf'
11:10:22 <infinisil> barrucadu: Right, but other than the "lightweight" part, they don't differ from threads in other languages, correct?
11:10:53 <maerwald> infinisil: erm, they use go routines ofc with the channels
11:11:05 <mizu_no_oto> basically a binary tree is either a node with a value and two subtrees whose values are all the same type, or it's an empty leaf.
11:11:12 <maerwald> mostly emulated by forkIO or similar
11:11:45 <infinisil> maerwald: But like, you can use go routines without channels and channels without go routines, they don't depend on each other in any way
11:11:54 <infinisil> I'd think
11:11:56 <barrucadu> infinisil: Well, the "lightweight" bit is pretty important.  They're language-threads multiplexed onto a small number of operating system threads.
11:12:11 <maerwald> infinisil: I didn't say that, did you read the SO thread I posted?
11:12:27 <infinisil> I did skip through it, will read more thoroughly
11:13:24 <shapr> https://a-tour-of-go-in-haskell.syocy.net/en_US/index.html ?
11:13:47 <infinisil> Haha, he's saying "go has channels which are natively supported" because it can't be supported by the type system because lol no generics
11:14:27 <shapr> Go naysayers have generic complaints.
11:14:31 <Cale> EvanR: you should learn some go: https://senseis.xmp.net/
11:14:45 <Cale> The other Go is not as good
11:15:10 <barrucadu> go is pretty hard, Go not so much
11:15:18 <maerwald> Cale: there are only 2 non-asians which have a high rank in Go afaik, so it's considered an extremely difficult thing to learn for people outside of that culture :P
11:15:38 <Cale> Depends on what you consider a high rank
11:15:42 <maerwald> the official ones
11:15:49 <infinisil> maerwald: Well I still think that channels and goroutines aren't strictly related or dependent on each other
11:15:52 <Cale> Like a high professional rank, sure
11:15:55 <maerwald> yep
11:16:02 <maerwald> I think one is a russian
11:16:05 <Cale> There are plenty of amateurs who are strong for amateurs around the world
11:16:24 <maerwald> infinisil: they are very related
11:16:29 <nikivi> I still am curious about what dmwit meant with 'Type theory goes much much further than just tagging data'
11:16:39 <Cale> Most of the rest of the world obviously doesn't have as strong a professional system as China, Korea and Japan.
11:16:50 <nikivi> Isn't type a way to tag data. I just read the wiki entry for 'Type system'
11:17:03 <infinisil> maerwald: How so? I mean sure, they often are used together, but each of them can be used on its own
11:17:03 <maerwald> channels are how go routines communicate with each other in real world Go code. That is *very* related. And it's designed for that purpose
11:17:07 <EvanR> there are at least two meanings associated with "types"
11:17:22 <maerwald> infinisil: just because they can be used on its own doesn't mean they are unrelated
11:17:28 <EvanR> runtime tagging is about dynamic types, compile time analysis is about static types
11:17:32 <infinisil> maerwald: Hmm I guess
11:17:57 <EvanR> its tough to draw a real comparison between the two
11:18:45 <nikivi> Dynamic languages don't do any compile time analysis?
11:19:16 <EvanR> some of them get away with very little
11:19:33 <EvanR> like, ruby cant tell you if a variable is misspelled until runtime
11:19:46 <EvanR> much less if you use the wrong type of data somewhere
11:20:15 <nikivi> What language has the 'strictest' compiler where you can still get stuff done? Idris?
11:20:16 <maerwald> merijn would say type checking is by definition static
11:21:11 <EvanR> nikivi: there are languages used for formally verified stuff
11:21:19 <EvanR> that get stuff done
11:21:23 <nikivi> Yeah I read about Agda
11:21:28 <nikivi> But I thought it was not turing complete
11:21:50 <nikivi> I read that in order to be a 'proof checker' you can't be turing complete
11:21:53 <EvanR> you cant really check that your floating point hardware is correct at runtime, by then its too late.
11:21:57 <nikivi> Because you can't prove if the program halts
11:22:08 <EvanR> but you can write the hardware in a formally verified language
11:22:53 <EvanR> otoh its too late if your code is running on a mars probe, but they still just use C normally
11:23:16 <infinisil> RIP to turing completeness
11:23:22 <infinisil> Let our languages be pacman complete instead
11:23:37 <EvanR> agreed
11:23:53 <EvanR> MMORPG complete
11:24:07 <infinisil> How to solve the halting problem: Don't use turing machines as your model, you can do better
11:24:32 <EvanR> however bigprofitgame-completeness is incompatible with minecraft completeness, which allows you to construct turing complete stuff within the game
11:24:43 <infinisil> Heh
11:25:20 <infinisil> Hmm, question: I often think that you can guarantee that your program terminates if you just make it timeout if it takes too long
11:25:43 <infinisil> Is there anything preventing this?
11:26:07 <EvanR> terminating vs terminating-with-useful-results
11:26:08 <nikivi> Whats a good book on modern 'foundations of mathematics'?
11:26:11 <nikivi> https://hott.github.io/book/nightly/hott-online-1075-g3c53219.pdf?
11:26:23 <EvanR> if you only want terminating, write your program as "return 0;"
11:26:31 <nikivi> correct link https://homotopytypetheory.org
11:26:43 <infinisil> EvanR: Oh good point
11:27:01 <nikivi> I can't get over how 'cryptic' mathematic notation looks
11:27:05 <infinisil> But the chances of accidentally it being an infinite loop are higher the longer the program runs
11:27:20 <EvanR> proof requested
11:27:25 <mizu_no_oto> maerwald: There are more than 2 professional non-asian go players.
11:27:33 <nikivi> It tries to contain as much as possible within as little space as possible
11:28:01 <EvanR> chinese is very cryptic, because i dont know chinese
11:28:12 * hackage jukebox 0.3.6 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.3.6 (NickSmallbone)
11:29:13 <nikivi> EvanR Is there a central committee that confirms what the correct math notation is?
11:29:27 <nikivi> I thought you can potentially create your own math symbols on the spot
11:29:31 <infinisil> nikivi: It's just convention
11:29:34 <infinisil> You totally can
11:29:40 <Cale> There is no central committee
11:29:49 <EvanR> you can and you better introduce it somewhere if you do
11:30:10 <EvanR> if you use someone elses notation, then you dont
11:30:15 <EvanR> QED
11:30:32 <EvanR> (have to introduce it)
11:30:35 <infinisil> nikivi: It's just like a programming language and its standard library
11:30:37 <dminuoso> nikivi: It's not cryptic, it's just a domain specific language.
11:30:47 <mizu_no_oto> maerwald: https://en.wikipedia.org/wiki/List_of_Go_players#European_Go_Professionals_Players plus there's also Michael Redmond and James Kerwin.
11:30:54 <nikivi> Only you can't run math
11:30:58 <nikivi> to see if it works
11:31:05 <dminuoso> nikivi: You can prove things in math instead.
11:31:05 <EvanR> go is 2 levels of offtopic right now
11:31:19 <EvanR> golang was 1 level
11:31:27 <nikivi> dminuoso I thought that proofs only work within the axioms that you chose
11:31:29 <shapr> ok, I have a basic question: how do I change the output of "hoogle --help" ?
11:31:39 <shapr> I spent two hours failing to change that output
11:31:48 <dminuoso> nikivi: Just like running a program only works within the input parameters.
11:31:53 <dminuoso> nikivi: I dont see what your point is.
11:32:08 <shapr> for example, hoogle has "--info" as a valid working command line argument, but it doesn't show up in "hoogle --help"
11:32:13 <shapr> and I cant figure out how to fix that.
11:32:23 <nikivi> I am just saying that in programming world there is so much tools that help you get stuff done: IDE, debugger
11:32:34 <nikivi> in math all you have is paper, pen and internet
11:32:45 <dminuoso> nikivi: And tons of papers which you can think of as libraries.
11:33:15 <EvanR> a lot of math is not written in a formal language, like programming languages are
11:33:16 <infinisil> nikivi: Unless you use proof assistant tools, or a language like Coq or Idris
11:33:25 <infinisil> Or isabelle
11:33:33 <infinisil> (which is a proof assistant i think)
11:33:37 <EvanR> programming uses formal language, except perhaps HTML programming
11:34:00 <nikivi> But Coq, Idris, Isabelle can only deal with math that is computable
11:34:05 <nikivi> But there is math that is not computable
11:34:07 <EvanR> math is informal that youre supposed to assume may be made formal if demanded
11:34:09 <nikivi> if I understand correctly
11:34:16 <dminuoso> nikivi: Its not about computability. Its about provability.
11:34:43 <infinisil> Yeah, you can't do math that requires infinite proofs, because then you couldn't prove it and it wouldn't be a proof
11:35:01 <dmwit> Eh, it is about computability. "provability" is relative to your logic. The logics of Coq, Idris, Agda are explicitly designed to contain only computable things.
11:35:06 <shapr> anyway, trying to fix hoogle was frustrating
11:35:07 <glguy> shapr: The output is generated by the CmdArgs package from this stuff https://github.com/ndmitchell/hoogle/blob/f3f1dca9b5112c3354a980975540df95d9b44d4a/src/Action/CmdLine.hs
11:35:08 <EvanR> unless you prove it terminates by unconstructive means
11:35:13 <glguy> https://hackage.haskell.org/package/cmdargs-0.10.20/docs/System-Console-CmdArgs-Implicit.html
11:35:43 <shapr> glguy: thanks! I'll see if I can use that to fix the problem
11:35:47 <shapr> glguy: are you writing any cool code?
11:35:58 <dmwit> I'm not so sure I'm on board with this "can do math that requires infinite proofs" thing, either.
11:36:12 <johnw> infinisil: I would think it's up to the task now
11:36:13 <shapr> glguy: do any of the ivory/tower people show up here?
11:36:15 <dmwit> Correction: I'm not so sure I'm on board with this "can't do math that requires infinite proofs" thing, either.
11:36:42 <shapr> just wondering how hard it would be to get ivory/tower running on my ergodox keyboard, it's almost the same flavor of ARM as stm32
11:36:44 <infinisil> johnw: Does it work with all of nixpkgs and the hashes are the same and stuff?
11:36:45 <glguy> shapr: Beyond work projects I've been playing with more solving games with minisat via Ersatz mostly
11:36:49 <glguy> shapr: I don't think so
11:36:54 <shapr> oh that sounds nifty
11:36:56 <dminuoso> nikivi: At any rate. Math can be learned, it's just a bit silly to dive into a homotopy type theory book and expect to get a firm grasp of things. It's like picking up a chinese news paper and expecting to get an idea of what its content is about.
11:37:20 <johnw> infinisil: ok, maybe not *that* ready
11:37:35 <infinisil> Heh, alright
11:37:36 <johnw> infinisil: I haven't done a full "equal evaluation comparison" of the entirety of nixpkgs, though I've been working on it
11:37:47 <infinisil> Nice
11:38:00 <infinisil> I'll probably restructure my bot to enable multiple nix evaluators
11:38:03 <johnw> hnix has a --find option that will recursively descend and evaluate every attribute it can find, and it reports <<loop>> in places I wouldn't expect it to right now
11:38:14 <dminuoso> nikivi: Without understanding the domain, you cant read a text well. Without understanding the grammar you cant read a text. Without understanding the symbols you cant even figure out the grammar.
11:38:37 <shapr> glguy: think you'll try justin le's trainable models code for that? https://blog.jle.im/entry/purely-functional-typed-models-1.html
11:38:55 <infinisil> johnw: What means "wouldn't expect it"?
11:38:58 <nikivi> dminuoso I agree. The problem is that I have bits and pieces about math I've read and learned from my CS classes and things I read but I don't have a coherent picture of math as it is.
11:39:13 <johnw> infinisil: I should never see "<<loop>>"
11:39:19 <nikivi> That's why I asked if there was a good 'Foundations of math' book that maybe clears those things a little
11:39:23 <dminuoso> nikivi: Do you have any particular field of interest in math?
11:39:27 <EvanR> after reading hott, you still wont have a coherent picture, actually it might be even more incoherent
11:39:30 <johnw> so, I've been fixing those as time permits
11:39:31 <dminuoso> (Math is a rather general and broad thing)
11:39:37 <EvanR> because it doesnt agree with a lot of math culure
11:39:47 <nikivi> dminuoso I am interested in programming and making programs run correctly
11:39:55 <dminuoso> nikivi: Have you read TaPL?
11:40:14 <shapr> glguy: just general games? or steam games, flash games?
11:40:17 <infinisil> johnw: I still don't quiet get what <<loop>> indicates, but fixes are always nice. Is it some fixed-point loop thing?
11:40:18 <nikivi> dminuoso I started reading it, have to finish it
11:41:04 <johnw> infinisil: it's an infinite recursion
11:41:34 <infinisil> Ah, so just the equivalent of nix's "possible infinite recursion"
11:41:47 <EvanR> "definitely infinite recursion"
11:41:52 <nikivi> Haskell being a lazy language means that it won't run into infinite recursion loops, right?
11:42:00 <EvanR> false
11:42:03 <EvanR> > let x = x in x
11:42:04 <dminuoso> infinisil: Some primitive cases of infinite recursion can be detected by the rts
11:42:07 <lambdabot>  *Exception: <<loop>>
11:42:13 <dminuoso> > let i = i ++ [1] in take 5 i
11:42:16 <lambdabot>  *Exception: <<loop>>
11:42:33 <johnw> right
11:42:41 <johnw> except the <<loop>> I'm encountering isn't from Haskell
11:42:50 <johnw> it's in my own implementation of laziness inside hnix
11:42:56 <dminuoso> oh heh
11:43:03 <johnw> usually it means I'm being too strict some place
11:43:08 <dminuoso> nikivi: No. You can definitely get into infinite recursion.
11:43:10 <johnw> often in the implementation of a particular builtin
11:43:10 <glguy> shapr: The last couple have been puzzle apps from my phone. https://github.com/glguy/5puzzle https://play.google.com/store/apps/details?id=com.groundcontrol.zhed&hl=en_US
11:43:37 <infinisil> johnw: seq?
11:43:43 <nikivi> I always wondered how does the program know to stop if it gets to infinite recursion?
11:43:49 <johnw> infinisil: not sure what your asking...
11:44:02 <dminuoso> nikivi: However, because Haskell (usually) only evaluates into WHNF if you produce data constructors while doing the infinite recursion you can use it.
11:44:19 <johnw> nikivi: if, while forcing a thunk, you see the same thunk being forced again, you can report infinite recursion
11:44:42 <infinisil> johnw: The particular builtin that often gets you <<loop>>, is it builtins.seq?
11:44:50 <johnw> no
11:44:58 <johnw> last time it was hasAttr :)
11:45:00 <dminuoso> > iterate (+1) 0
11:45:03 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:45:05 <dminuoso> @src iterate
11:45:05 <lambdabot> iterate f x = x : iterate f (f x)
11:45:15 <infinisil> johnw: Heh alright, wouldn't have expected that one
11:46:26 <johnw> infinisil: it's just a matter of lining up semantics exactly with C++ Nix
11:46:32 <johnw> which sometimes can only be done by fixing the errors as they occur
11:46:48 <infinisil> johnw: Needs a spec already :(
11:49:38 <nikivi> johnw why are you rewriting nix in haskell? wouldn't it waste the time people invested in C++  codebase?
11:50:12 <johnw> i'm impatient for them to do certain things, like better error reporting, and I don't want to code that in C++
11:50:28 <johnw> so at the very least, hnix can be an incubator for ideas
11:50:39 <dminuoso> nikivi: reimplementing software does not waste other peoples time.
11:50:47 <infinisil> I'm totally interested in doing nix transformations and other meta-language stuff with hnix
11:50:53 <dminuoso> nikivi: At worst it wastes your own time. At best you get to make things better.
11:50:55 <EvanR> not immediately at least
11:51:11 <EvanR> if you ever release the reimplementation, it may cause other people to begin wasting their time on it :)
11:51:23 <EvanR> like a nerd snipe
11:52:36 <dminuoso> Wasn't the original implementation different from GHC?
11:52:45 <dminuoso> I mean the original Haskell implementation
11:52:58 <EvanR> gofer?
11:53:42 <nikivi> Do you have to know a bit of C to appreciate what Haskell gives you?
11:54:45 <infinisil> nikivi: The more you know other languages the more you appreciate haskell
11:54:50 <ph88> anyone know what this c:\sr folder is that stack creates ?
11:55:30 <nikivi> I read that Haskell was used as a kind of laboratory for different language features
11:55:40 <nikivi> Is it hard to reverse 'bad' decisions I am curious?
11:56:44 <Cale> Well, most of the decisions happened to be good, but it's all quite modular -- there is a system of language extensions which can individually be turned on or off, and unpopular ones occasionally get removed.
11:56:55 <jbetz> hackage lets you see the dependencies of a package, but is there any way to see what packages are dependent on it?
11:57:13 <infinisil> johnw: Heh, why are you not in #hnix?
11:57:22 <johnw> is there such a thing?
11:57:30 <Cale> https://packdeps.haskellers.com/reverse
11:58:09 * dminuoso hands Cale impredicative polymorphism
11:58:36 <geekosaur> it's on the way out in favor of VTA
11:58:45 <jbetz> Cale: sweet, thanks
11:59:06 <dminuoso> geekosaur: VTA?
11:59:22 <geekosaur> visible type appliation aka foo @Int etc.
11:59:35 <dminuoso> Oh I have that enabled everywhere. =)
11:59:36 <Cale> I actually really dislike TypeApplications right now
12:00:10 <Cale> I think it shouldn't work unless the type variables were explicitly quantified
12:00:23 <Cale> similar to ScopedTypeVariables
12:01:11 <Cale> as it stands, library authors have to be careful when explicitly quantifying type signatures that the order in which the type variables are listed agrees with the convention that TypeApplications would give, even if they don't use TypeApplications
12:01:30 <Cale> Because otherwise, they'll break other code which happens to use TypeApplications.
12:01:57 <robstr> I have a strange ghc error, when trying to compile it will consume 100% cpu & wont stop, trying to build a small example directly yields in a compilertime error.. any idea how to debug this ?
12:02:15 <Cale> robstr: Are you using UndecidableInstances?
12:02:22 <robstr> Cale: no
12:02:27 <Cale> hmm
12:03:34 <infinisil> Btw, what are these ratings on hackage?
12:03:55 <infinisil> Either I just don't get it or it's the worst rating system ever
12:04:10 <robstr> Cale: I think it has to do with `enter` from Servant but not 100% sure
12:04:27 <Zipheir> 4/5 stars, excellent library, nice staff, good ambience.
12:04:28 <Cale> robstr: It's really hard to tell without being able to see your program :)
12:04:31 <glittershark> Servant probably uses UndecidableInstances under the hood somewhere
12:04:41 <Cale> yeah, it probably does
12:05:13 <Cale> (In fact, it definitely does)
12:05:14 <infinisil> Zipheir: But it only goes 0-3, and it seems that 95% of libraries have rating 0
12:05:22 <geekosaur> infinisil, it's whatever the person setting a rating thinks it is. which probably means both of those at once >.>
12:05:36 <glittershark> doesn't GHC have a max recursion depth for superclass elaboration though?
12:05:54 <glittershark> I'd expect that to trigger *eventually* rather than GHC just spinning
12:06:03 <infinisil> geekosaur: And there's no restriction on who can rate or so? It's just a really underused feature?
12:06:19 <geekosaur> most people don;t even realize it's a thing, I think
12:06:45 <Zipheir> infinisil: Probably for the best. An unannotated numeric rating for a library is really unhelpful...
12:07:21 <robstr> Cale: true :)
12:07:26 <infinisil> I mean ratings work on the rest of the internet too
12:07:40 <glittershark> "work"
12:09:20 <Cale> I haven't used Servant for anything nontrivial to know where its pitfalls might be. Most of our applications just use Snap, and even that's overkill given that we're primarily serving single-page applications that do most of their communication via websockets.
12:09:40 <jbetz> is there anyway to make `cabal new-build` exclude certain targets in a package referenced from `cabal.project`?
12:10:47 <cocreature> jbetz: I don’t think there’s a way to exclude targets (except for test and bench targets) but if you specify targets explicitely only those will be built
12:12:43 <jbetz> cocreature: okay, that should be good enough. thanks!
12:26:43 <sm> infinisil: yes, an underused feature, probably it has some tricky problems remaining to solve
12:26:54 <sm> #hackage will know
12:31:42 * hackage expressions 0.1.6 - Expressions and Formulae a la carte  http://hackage.haskell.org/package/expressions-0.1.6 (jakubdaniel)
12:49:12 <Gurkenglas> Why is emacs installing intero-0.1.28 when I open a .hs when the latest intero release is 0.1.31?
12:50:22 <MarcelineVQ> I expect intero depends on your resolver, so whatever resolver is in scope will determine the version you're getting
12:51:57 <Gurkenglas> Are there alternatives to regularly manually replacing the resolver the global project uses with the newest resolver?
12:52:57 <MarcelineVQ> You could make a script but none that I'm aware of
12:53:23 <MarcelineVQ> I'm okay with this, people get into enough trouble without the tools making trouble all on their own
12:55:54 <Ariakenom> infinisil: your pcj was showing :)
12:56:25 <hexagoxel> just use "resolver: nightly" in your stack.yaml. and then insert and evil laugh about the idea of reproducable builds in general.
12:57:11 <infinisil> Ariakenom: Because of Go a bit ago? Otherwise I have no idea what you mean
12:57:25 <Ariakenom> yes
12:57:26 <MarcelineVQ> oh do nightly and lts without version work on the cli, do they work in yamls? they didn't (lts anyway) when I tried in the past
12:57:34 <MarcelineVQ> *they do work on the cli
12:58:33 <Ariakenom> I was away so I got quite delayed in my response . more than i noticed
12:59:24 <infinisil> Ariakenom: Ah yes, I sure like jerking over inferior languages :)
13:03:53 <ph88> anyone know what this c:\sr folder is that stack creates ?
13:07:45 <sm> I believe it's the global stack root, ~/.stack on unix. Usually set to that short name to avoid windows filepath length limits
13:12:31 <ph88> ooh right ok
13:12:42 <ph88> didn´t notice it before the last time i used stack on windows
13:13:17 <ph88> another question ... ghc is now doing called arity analysis  .. which takes a very long time .. is there anything i can do about this ?
13:17:33 <ph88> i saw this bug https://ghc.haskell.org/trac/ghc/ticket/10293 it was fixed by only by testing on haskell-src-exts
13:26:35 <tdammers> @tell maerwald because editor support doesn't get more interesting to make as a language gets more complex
13:26:36 <lambdabot> Consider it noted.
13:32:22 <koala_man> if I want to use a regex in a function, how can I reasonably avoid it being frequently recompiled? for example, is  'f x = x `matches` regex where regex = compile ".*"'  likely to keep the compiled version between invocations?
13:33:39 <EvanR> you can manually float the definition of regex outside the function
13:33:42 <[exa]> koala_man: move the definition to a broader scope
13:34:57 <quicksilver> I believe GHC will float what koala_man wrote anyway won't it?
13:35:02 <quicksilver> it has no dependencies
13:35:32 <EvanR> that sounds a bit scary
13:36:00 <dminuoso> Wow. intero constantly deducing `P -> m a -> m a` for some binding when it should be `(MonadReader E m, MonadPlus m) => P -> m a -> m a`
13:36:06 <dminuoso> Why do I still use intero :(
13:36:08 <EvanR> if regex = [1..]
13:36:12 <quicksilver> yes, let-floating is a bit scary
13:36:14 <koala_man> I'm not quite sure how that works. I've done the typical memoizing trick with something like   f = let re = compile ".*" in \x -> x `matches` re
13:36:18 <quicksilver> but it's also pretty useful
13:36:56 <ph88> is it possible to override the ghc version stack uses but still use lts for packages ?
13:37:15 <quicksilver> (google GHC let-floating to see examples of why it's nice and also problems it causes(
13:38:24 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html?highlight=full-laziness#ghc-flag--ffull-laziness
13:39:03 <ph88> i have a bad regression from lts-9.21 (ghc 8.0.2) compile in under 2 minuts to lts-11.6 (ghc 8.2) compile for hours
13:40:27 <koala_man> how can I determine whether the code is recompiled? will a simple Debug.Trace do, or can that change when GHC decides to float?
13:40:34 <koala_man> s/recompiled/re-evaluated/
13:41:11 <tdammers> Debug.Trace.trace should do the trick
13:43:56 <AndreasK> ph88: Yes but it's likely to break for complex projects, if you have transitive dependencies on packages shipped with ghc
13:44:30 <ph88> AndreasK, i want to try old packages with newer ghc .. to see if the regression is due to my deps or ghc bug
13:44:52 <AndreasK> ph88: There is a compiler: setting iirc and the option to have stack use the system ghc
13:45:09 <AndreasK> But I don't know the exact option names from the top of my head
13:45:27 <EvanR> koala_man: probably better to look at the core generated using the particular optimization flags you plan on using
13:46:09 <ph88> oki
13:47:46 <AndreasK> ph88: I think there was an regression with alex or happy. If you somehow depend on these that might be the reason
13:48:15 <ph88> don´t think so .. but i don´t know how to check either
13:48:38 <AndreasK> If you don't generate code, or parsers for things then it's unlikely.
13:48:59 <ph88> i use megaparsec
13:49:07 <AndreasK> That should be fine
13:49:15 <AndreasK> Or if it's not an different issue
13:49:31 <ph88> https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-variant
13:49:35 <ph88> this looks like a good option
13:50:23 <ph88> wow ghc is already on 8.4
13:51:16 <AndreasK> There was less time than usual between 8.2 and 8.4 :)
13:52:06 <Gurkenglas> What stack command will tell me which resolver can build monad-dijkstra?
13:52:44 <Gurkenglas> Or, how should I make Control.Monad.Search available for my stack scripts?
13:54:41 <glguy> Gurkenglas: stack solver can call out to cabal-install to try and find a build plan, but in general the model of stack is that figuring out what versions to use is your job
13:56:05 <ph88> Gurkenglas, maybe staversion can help you
13:56:22 <tdammers> right, yeah, trace itself can trip up the inlining heuristic I guess
13:57:43 <statusfailed> Is it possible to get a constant-time slice of a bytestring? "drop" says it's O(n)
13:57:53 <AndreasK> tdammers: Inlining yes, but should be fine for recomputation afaik. Unless you hope for CSE and use different trace messages
13:57:58 <statusfailed> I want to get N characters after a certain byte in the strnig
13:59:12 <statusfailed> oh, it's because I'm using lazy instead of strict
13:59:13 <statusfailed> nevermind :D
14:01:03 <tdammers> AndreasK: but inlining itself can change what gets evaluated when, so you have a bit of a Heisenberg situation there
14:01:58 <monochrom> Perhaps you need to read the core code.  Twice --- once without trace and once with trace.
14:05:40 <Gurkenglas> ph88, that seems to go in the wrong direction - staversion is Resolver -> Package version, I want Package version -> Resolver
14:08:38 <ph88> Gurkenglas, maybe the stackage.org website will help you. You can also ask for a feature request on staversion
14:10:58 <hvr> Gurkenglas: what problem are you trying to solve that requires "solving for a resolver"?
14:12:43 <AndreasK> I debugged some layout code for two days. Turns out the algorithm is fine. The graph I base the layout on is crap ...
14:13:55 <shapr> whoops
14:13:56 <hvr> ph88: fwiw, this isn't something that staversion would be efficient at
14:13:57 <monochrom> Oh heh solving for resolver sounds very meta.
14:14:16 <hvr> ph88: it'd have to download all resolvers there are
14:14:16 <ph88> hvr, what efficiency ?
14:14:34 <hvr> ph88: and those are worth several MiBs
14:14:38 <monochrom> AndreasK: w00t Graph layout algorithm?
14:14:53 <AndreasK> monochrom: Serializing a control flow
14:15:01 <ph88> hvr, its ok to download a few mb
14:15:47 <monochrom> 1MB = 1 milli GHC :)
14:16:26 <hvr> ph88: all LTS stackage yaml files are currently about 1.3GiB
14:16:28 <AndreasK> I've recently added some trace debug and forgot to take it out when I ran a benchmark. Ended up with a 2,5GB text file
14:16:33 <monochrom> Type-level skill is measured in milliolegs. File size is measured in milliGHCs. :)
14:17:03 <tdammers> there's also the millikmett, a unit of library programming productivity
14:17:05 <AndreasK> Well forgot isn't really true. I didn't care because I underestimated the amount of stuff it would add to the logs
14:17:27 <pdxleif> Is there a preferred way of listening for file changes (e.g. on udev / sysfs)? I've seen examples use select(2), or poll(2). This one seems to be using epoll, but I'm assuming System.Event is now GHC.Event, which says "
14:17:31 <pdxleif> This module should be considered GHC internal."
14:18:00 <pdxleif> Err, this is the one using System.Event: https://wiki.haskell.org/Simple_Servers#Epoll-based_event_callbacks
14:18:10 <hvr> ph88: ...and all the nightlies are about 5GiB
14:18:36 <pdxleif> Has me wondering if there's some lib wrapping GHC.Event that I'm supposed to use, instead?
14:18:44 <monochrom> pdxleif: ghcid uses fsnotify, if it helps.
14:19:24 <monochrom> To be sure, I don't know how fsnotify does it.
14:20:45 <pdxleif> I've used fsnotify - it uses inotfiy on linux or fsevents on osx or whatever on windows...
14:21:01 <pdxleif> *inotify
14:21:04 <ph88> hvr, it can be compressed i think
14:21:41 <pdxleif> I was just thinking, to get a notification when a hardware value changes, via sysfs / udev / dbus / ...?
14:22:35 <hvr> ph88: gzip compression buys you about a factor 5x
14:22:43 <pdxleif> This udev package is a thin wrapper over the udev lib. In their example they're using a wrapper for select(2): https://github.com/pxqr/udev/blob/master/examples/monitor.hs#L36
14:23:17 <ph88> hvr, where are the yaml´s ? i will try to compress them
14:23:25 <hvr> ph88: but I'm not sure if the webservice allows to use http-level compression
14:24:25 <ph88> by the way .. is there a nightly that is exactly equal to each lts ?
14:39:12 * hackage expressions-z3 0.1.4 - Encode and Decode expressions from Z3 ASTs  http://hackage.haskell.org/package/expressions-z3-0.1.4 (jakubdaniel)
14:40:12 * hackage cayley-client 0.4.6 - A Haskell client for the Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.4.6 (MichelBoucey)
14:42:12 <H91wka> Hi. I wonder if you use any lightweight alternatives to the Emacs haskell-mode. It's not a secret that haskell-mode is not ideal, in fact, very humble TextMate bundle for haskell causes less frustration at this point.
14:53:44 <monochrom> I'm pretty sure TextMate would offend me in some other aspects.
14:54:57 <monochrom> It is no secret that the whole world is not ideal and everything is frustrating.
14:56:25 <MarcelineVQ> it's pretty ideal if you avoid the people
14:58:18 <H91wka> monochrom: phylosophy is great, but even basic stuff like indentation is broken in haskell-mode.
14:59:13 <monochrom> Oh you take mine as empty talk?  The fact is that emacs haskell-mode is not broken for me.  At least not enough.
14:59:17 <jackhill> H91wka: intero might be an option, but I'm not sure how usable it is outside of stack.
15:00:27 <H91wka> jackhill: AFAIK intero is a replacement of haskell-interactive-mode rather than haskell-mode itself
15:01:09 <iqubic> Jackneilll: You can't use intero without stack.
15:03:12 <jakov> Hello ! I am a haskell beginner and would appreciate your help in the following case:
15:03:44 <jakov> I have a list of values, and a list that says how many times each value should appear
15:04:54 <jakov> like so : values = [ 1 , 2, 4] , frequencies = [ 2, 4, 3], and the result of my desired function should be [1,1,  2,2,2,2, 4,4,4]
15:04:57 <Tuplanolla> :t replicate -- Make use of, jakov.
15:04:59 <lambdabot> Int -> a -> [a]
15:05:09 <jakov> I have tried the following:
15:05:28 <iqubic> I think I see a one liner that might do this.
15:05:35 <iqubic> :t zipWith
15:05:36 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:05:39 <jakov> s = concat $ zip (map genericReplicate frequencies) values
15:06:27 <iqubic> What does genericReplicaticte do?
15:06:39 <iqubic> :t replicate
15:06:40 <lambdabot> Int -> a -> [a]
15:07:01 <jakov> it accepts a generic Integer value, not only int
15:07:32 <iqubic> jakov: what is the error you are getting? Does your code compile?
15:07:33 <monochrom> zipWith is what you're looking for. zip is not very useful for this.
15:08:01 <iqubic> :t zip
15:08:02 <lambdabot> [a] -> [b] -> [(a, b)]
15:08:03 <jakov> Yes, zipwith works !! Thank you very much !
15:08:55 <iqubic> s = concat $ zipWith genericReplicate frequencies values
15:11:11 <jakov> yes, that's what i used. Thank you
15:11:19 <monochrom> genericReplicate is probably just because [1,2,3] defaults to [Integer] not [Int]
15:12:09 <monochrom> I wouldn't be surprised if the actual code actually had [Int].
15:14:54 <iqubic> :t genericReplicate
15:14:55 <lambdabot> Integral i => i -> a -> [a]
15:41:55 <fresheyeball> hey
15:41:58 <fresheyeball> I have an idea
15:42:35 <fresheyeball> data SomeEq = SomeEq (forall a. (Typeable a, Eq a) => a)
15:42:50 <fresheyeball> can we use cast to write an instance Eq SomeEq ?
15:43:31 <fresheyeball> SomeEq a == SomeEq b = maybe False (== b) $ cast a
15:43:39 <fresheyeball> that doesn't work, but I dont understand why
15:43:40 <johnw> you don't know that the 'a' of two different SomeEq is in any way related
15:43:56 <fresheyeball> johnw: right, which is why I am using cast
15:44:02 <johnw> they are Eq a, so they're comparable with other a's, but you don't know what 'a' is or how to get another one
15:44:07 <fresheyeball> if the types dont match, its false
15:44:09 <johnw> cast won't work here
15:44:28 <johnw> you mean you want to test for *type equality*, and not value equality?
15:44:35 <fresheyeball> both
15:44:37 <nshepperd_> that should work
15:44:44 <nshepperd_> what's the actual type error you get?
15:44:47 <fresheyeball> if type is equal, then check values
15:44:52 <johnw> ah
15:44:57 <johnw> that should work, yeah
15:45:12 <fresheyeball> nshepperd_: Ambiguous type variabel 'a1' ariising from an operator section
15:45:31 <fresheyeball> prevents the constrain '(Eq a1)' from being solved
15:45:39 <johnw> yeah, i think you can't let the 'a' escape its bounds
15:45:43 <johnw> effectively your pattern match is:
15:45:54 <johnw> SomeEq (x :: forall a. (Typeable a, Eq a) => a)
15:45:59 <johnw> and you're want to have a body like:
15:46:01 <johnw>  -> cast @a x
15:46:05 <johnw> except that 'a' isn't in scope here
15:46:23 <nshepperd_> oh wait, your data definition is incorrect, right
15:46:55 <nshepperd_> it should be data SomeEq = forall a. (Typeable a, Eq a) => SomeEq a
15:47:03 <nshepperd_> if you want it to be existential
15:47:05 <johnw> yes
15:47:16 <johnw> then a should be in scope for the body of the case match
15:48:45 <fresheyeball> nshepperd_: you got it
15:48:48 <fresheyeball> that fixed it
15:48:58 <fresheyeball> I thought forall hoisted? no?
15:49:25 <nshepperd_> I prefer using GADT syntax for stuff like this, because it's more consistent
15:50:44 <lyxia> fresheyeball: there's a difference between "SomeEq :: (forall a. (Typeable a, Eq a) => a) -> SomeEq" and "SomeEq :: forall a. (Typeable a, Eq a) => a -> SomeEq".
15:50:52 <nshepperd_> 'data SomeEq = SomeEq (forall a. (Typeable a, Eq a) => a)' means that the value inside the SomeEq constructor is polymorphic
15:51:14 <fresheyeball> nshepperd_: I dont see the difference based on that wording
15:51:26 <fresheyeball> make the contained value polymorphic is my intention
15:52:47 <fresheyeball> I see the different position, but I really dont see yet
15:52:51 <nshepperd_> put a different way it means that the receiver of a SomeEq can take out the value and choose any type for the contents: case x of SomeEq value -> { print (value :: Int) }
15:52:57 <johnw> fresheyeball: consider the difference between forall a. SomeEq a, and SomeEq (forall a. a)
15:53:05 <johnw> and what happens at construction
15:53:07 <nshepperd_> what you want is that you can choose any type to put into a SomeEq
15:53:19 <fresheyeball> oh shit
15:53:22 <fresheyeball> I made a bottom
15:53:27 <nshepperd_> SomeEq (1 :: Int), SomeEq ("hello" :: String)
15:53:32 <fresheyeball> I see
15:53:34 <johnw> well, not exactly bottom, it's still typeable and eq
15:53:39 <fresheyeball> (forall a. a) is undefined
15:53:39 <johnw> but the type it actually is is no longer recoverable
15:53:49 <fresheyeball> data Foo = Foo (forall a. a)
15:53:54 <fresheyeball> is unconstructable
15:54:02 <johnw> you could still get a TypeRep out of it, I think
15:54:06 <johnw> and compare those
15:54:15 <johnw> you just can't reference the type 'a'
15:54:40 <nshepperd_> in GADT syntax, what you wrote is 'data SomeEq where SomeEq :: (forall a. (Typeable a, Eq a) => a) -> SomeEq'
15:54:59 <nshepperd_> whereas what you want is 'data SomeEq where SomeEq :: forall a. (Typeable a, Eq a) => a -> SomeEq'
15:55:16 <fresheyeball> nshepperd_: Ooo it is easier to see in the GADT way
15:55:35 <nshepperd_> yes, it's much clearer imo
17:09:35 <jle`> fresheyeball: i wouldn't say that the contained value is polymorphic; in the existential type case, the contained value is monomorphic
17:09:45 <jle`> but the constructor is polymorphic still
17:19:51 <jared-w> I really want to like the massiv library but I've yet to figure out how tf to do matrix multiplication in it and that's quite frustrating :p
17:20:07 <Welkin> what massive library?
17:20:18 <jared-w> https://github.com/lehins/massiv
17:20:53 <jared-w> ah, gotta manually insert a bunch of 'computeAs' functions everywhere
17:20:56 <jle`> apparently the name is a pun
17:21:05 <Welkin> lol
17:21:14 <Welkin> that sounds like an ozzie/kiwi joke
17:21:18 <Welkin> compute *AS*
17:21:37 <Welkin> I don't like libraries with stupid names
17:22:08 <jared-w> I feel like the name is pretty not stupid; it means 'Array' in russian and it's an array manipulation library ¯\_(ツ)_/¯
17:22:16 <Welkin> matrix
17:22:17 <Welkin> not array
17:22:30 <Welkin> an array is the implementation
17:22:52 <jared-w> Matrices are just N dimensional arrays, or arrays are just 1 dimensional matrices, are they not?. Depends on where you wanna split your hairs, I suppose :p
17:25:42 * hackage either-both 0.1.0.0 - Either or both  http://hackage.haskell.org/package/either-both-0.1.0.0 (MatthewFarkasDyck)
17:29:16 <jared-w> Also, it has super strong types but I can't declare a statically sized array?
18:05:10 <ph88> does anyone know where i can find   Multi-paradigm Just-In-Time Compilation   by    Don Stewart ?
18:05:21 <ph88> and .. where did this go in the latest ghc guide?  https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ext-core.html
18:09:12 * hackage filtrable 0.1.1.0 - Class of filtrable containers  http://hackage.haskell.org/package/filtrable-0.1.1.0 (MatthewFarkasDyck)
18:11:16 <andreabedini> ph88: https://web.archive.org/web/20170118091715/https://www.cse.unsw.edu.au/~pls/thesis/dons-thesis.ps.gz
18:11:38 <geekosaur> ext-core hasn't worked in over a decade and was removed
18:17:12 * hackage Map 0.0.0.0 - Class of key-value maps  http://hackage.haskell.org/package/Map-0.0.0.0 (MatthewFarkasDyck)
18:19:01 <glguy> MatthewFarkasDyck strikes again
18:20:23 <suzu> is he known for something?
18:21:58 <EvanR> does anyone know a reference to a splittable name generator
18:22:27 <EvanR> besides the splittable RNG, which produces random numbers instead of just names
18:23:48 <ph88> thx andreabedini
18:24:26 <ph88> geekosaur, is it possible to dump core before any further steps (like optimizing) ? how ?
18:25:51 <lyxia> suzu: he's been making clones of many packages with questionable choices of names (notably with small edit distance from the original names)
18:26:12 <suzu> lol.
18:26:43 <ph88> nobody to moderate that ? :/
18:27:48 <suzu> anybody can upload packages
18:28:00 <suzu> and i think hackage forbids package deletion
18:28:05 <suzu> otherwise you get left-pad shenanigans
18:28:13 <suzu>  /shrug
18:29:38 <suzu> ph88: i think -ddump-simpl will do what you want
18:29:43 <jle`> there was some recent drama on reddit/github about this
18:29:53 <suzu> github??
18:29:59 <suzu> that's a place to talk???
18:31:39 <jle`> hackage-trustees repo issue tracker
18:32:22 <jle`> also the libraries mailing list too
18:32:25 <jle`> https://github.com/haskell-infra/hackage-trustees/issues/132
18:32:39 <suzu> https://hackage.haskell.org/package/Fortnite-Hack-Cheats-Free-V-Bucks-Generator-1.0.1
18:32:41 <suzu> https://hackage.haskell.org/package/Clash-Royale-Hack-Cheats
18:32:43 <suzu> wow
18:33:46 <geekosaur> ph88, probably but I couldn't tell you which option offhand. you probably want to compare https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#compiler-debugging-options to the Commentary
18:34:21 <jle`> a little bit of a different situation, but the question of some sort of spam prevention on hackage has come up a few times recently
18:34:33 <geekosaur> and be aware that an arrangement that makes sense to you may not be how ghc works, i.e. there is no guarantee that core exists at whatever stage you think represents the "unoptimized core" you want
18:35:13 <jle`> although i guess in this case, these are legitimate packages?
18:36:07 <ph88> maybe this flag  -ddump-prep 	Dump prepared core
18:36:07 <lyxia> indeed they are
18:38:42 * hackage avro 0.3.0.3 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.0.3 (alexeyraga)
18:39:09 <suzu> is there some way to get stack to just tell me what the upper bounds of my deps are
18:39:24 <suzu> i want to release a package to hackage but do so properly
18:39:44 <suzu> i feel like there should be a guide for this
18:39:51 <suzu> "do this before hackaging or suffer death"
18:40:30 <monochrom> Usually cabal-install gives advice, even at the time of "cabal sdist".
18:41:03 <sm> suzu: ultimately you've got to build with the deps and see
18:41:36 <jle`> suzu: if you're using current vesions then there isn't any other way to know what the right upper bounds are other than PVP or a time machine
18:41:43 <sm> or just guess.. or leave them out..
18:41:54 <suzu> i currently leave them out. but i use stack so it chooses versions
18:42:36 <jle`> i'm mostly just careful with lower bounds
18:42:39 <monochrom> Sounds like an undecidable problem.
18:42:54 <suzu> found it
18:42:58 <suzu> `stack list-dependencies`
18:43:31 <suzu> so i can just pin against current major ver
18:45:25 <glguy> suzu: the stack upload and sdist commands have a flag for adding bounds
18:45:46 <suzu> oh sweet
18:46:37 <jle`> that sounds handy
18:47:40 <payne> sweet jesus
18:47:45 <payne> lotsa people like Haskell
18:48:10 <glguy> For libraries in particular leaving out your upper bounds makes for future headaches whether your using stack or not
18:48:20 <glguy> youre*
18:48:20 <juri_> it's been the wave of the future since 1985.
18:48:24 <glguy> you're**
18:50:44 <jle`> payne: lotsa people idle on freenode #haskell, at least :)
19:00:42 * hackage keccak 0.1.0 - haskell keccak functions  http://hackage.haskell.org/package/keccak-0.1.0 (aupiff)
19:13:39 <ph88> so i tried these ghc options   -ddump-ds -ddump-prep -ddump-simpl    but i don't see any core hcr files popping up in my project folder  .. anyone know how to generate core the right way ?
19:16:22 <geekosaur> all -d options output to stdout, you have to add -ddump-to-file. none of them generates an hcr file as such. -ddump-simpl would produce a foo.dump-simpl file
19:17:17 <monochrom> There is no "the". There are many. Depends on why you want core.
19:18:12 <monochrom> But I reckon that programmers are the least likely to grok non-determinism and choice.
19:19:45 <monochrom> But I don't know how to get hcr of any kind anyway.  I just happen to know how to decide between simpl and prep.
19:30:18 <ph88> geekosaur, nothing extra is outputted to stdout :(    stack build --ghc-options="-ddump-ds -ddump-prep -ddump-simpl -j4 -O2 -fexcess-precision -optc-O3 -optc-ffast-math -rtsopts=none -no-rtsopts-suggestions"
19:31:01 <monochrom> I hate stack, so I'm going to just hypothesize that stack ate your stdout.
19:31:12 <monochrom> But of course, I have absolutely zilch evidence for that.
19:31:40 <monochrom> More likely is that building is skipped altogether because "everything is up-to-date".
19:32:00 <ph88> i used stack clean before
19:32:10 <monochrom> Or mayble I don't hate stack I just hate stack users.
19:32:22 <ph88> :'(
19:32:24 <geekosaur> ph88, it'll be in one of the directories under .stack-work
19:32:39 <ph88> ok let me at dump to file then
19:32:41 <geekosaur> stack itself uses several -d options + -ddump-to-file
19:32:42 <sm> stack clean --full ?
19:33:04 <monochrom> Oh so stack ate your stdout afterall.
19:33:40 <monochrom> So it's still moral to hate stack.  (Wrong inference?)
19:33:44 <sm> stack build --force-dirty --ghc-options=-fforce-recomp ?
19:34:28 <ph88> ill try thx
19:34:50 <sm> these "never" work for me, but try em all
19:36:09 <dibblego> :)
19:39:49 <suzu> -ddump-all -ddump-i-really-mean-it -ddump-pretty-please
19:51:16 <dfeuer> Ping edwardk
19:55:28 <ph88> ok interesting .. stack/ghc is compiling all the modules twice now o_O
19:55:29 <mmaruseacph2> Haskell Communities and Activities Report 34 is now out
19:56:03 <mmaruseacph2> https://wiki.haskell.org/Haskell_Communities_and_Activities_Report
19:59:49 <ph88> ok looks like i got some dump files now, thx guys
20:01:52 <ph88> if anyone know which flag will generate which file from which stage of the compile process that would be great ^^
20:07:46 <geekosaur> ph88, you almost certainly want to be looking at https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler
20:08:04 <geekosaur> the overview is likely the place to start
20:21:42 * hackage wai-routes 0.10.2 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.10.2 (AnupamJain)
20:23:10 <ddellacosta> sorry my internet cut out right after posting that, so I missed any responses that came after. But I think I was just confused about the relationship between `build` and `new-build`, so nevermind--sorry for the noise.
21:03:12 * hackage json-rpc-generic 0.2.1.4 - Generic encoder and decode for JSON-RPC  http://hackage.haskell.org/package/json-rpc-generic-0.2.1.4 (KeiHibino)
21:25:12 * hackage bson 0.3.2.6 - BSON documents are JSON-like objects with a standard binaryencoding.  http://hackage.haskell.org/package/bson-0.3.2.6 (VictorDenisov)
22:08:31 <dmj`> just me or haskell infra for nixpkgs pretty broke these days
22:11:18 <geekosaur> I gather it's being worked on. but that's pretty much all I know about it
22:24:48 <boj> dmj`: what do you mean?
22:33:26 <tow> how do i query, insert,delete hashmap that stores connection information of multiple threads ? how to I share this with all threads? using TChan is good idea to do this?
22:33:39 <EvanR> TVar
22:35:16 <EvanR> which will not only allow you to query insert or delete from the hashmap, but block waiting for some condition on the hashmap to be true
22:35:34 <EvanR> by explicitly using retry if the condition does not hold
22:36:58 <pdubs> was just reading this post http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html and really liked it
22:37:33 <EvanR> hrm i remember that one and thinking it was a bit too misleading
22:38:19 <pdubs> Do you reccomend any good sources for learning that stuff?
22:38:56 <boj> pdubs: just doing, really. i recall reading that and thinking that i got it, but the truth is i didn't. what helped was just applying the concepts in real code
22:39:23 <boj> the moment you can read and understand typeclassopedia, i think you get it
22:39:58 <pdubs> Thanks!
22:40:05 <pdubs> Ooo I like this chart
22:40:21 <EvanR> How to learn about monads... 1. get a PhD in computer science
22:40:29 <tow> EvanR: currently I am using TChan that contains (insertCommand,key,value)   for insert, (deletecommand,key) for delete and (queryCoommand,MChar(value)) , there is one thread running forever that accets these things and manages hashmap. is it good idea to do this?
22:40:30 <EvanR> O_o o_O O_o
22:40:40 <boj> tow: ouch
22:40:58 <EvanR> no thats too complex
22:41:10 <boj> tow: you just want to work with a TVar. sounds like you may have used Go before
22:41:51 <tow> boj : I hav'nt used Go before
22:41:57 <EvanR> TVar (HashMap K V) will let you execute transactions on the hashmap from any thread
22:42:11 <EvanR> they will be properly serialized by the STM system
22:42:19 <boj> tow: sorry, i meant no offense. just sounded like a solution that lang community would use
22:42:42 * hackage avro 0.3.0.4 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.0.4 (alexeyraga)
22:42:46 <EvanR> and you can use other TVars and TThings in the transaction
22:46:08 <tow> boj it's ok
22:48:51 <tow> boj, EvanR basically I want to store socket for perticular connection, which should be retrive when needed from any thread using the connectionid, is thre any better way to do this?
22:50:14 <EvanR> as far as this specific thing goes, it sounds like a decent way
22:50:55 <boj> tow: i've written something similar recently, the way EvanR described it is how i did it. works great
22:50:56 <EvanR> i have a question for you, what do you do about connection IDs after a connection is gone
22:51:56 <tow> EvanR : will get rid of it
22:52:24 <EvanR> i mean, all the agents which happen to have one on them...
22:52:35 <EvanR> it goes nowhere right, how do they know
22:56:18 <tow> EvanR, boj so you guys recommend TChar  (HashMap K V), other is there any other way other than hashmap?
22:57:14 <EvanR> TVar
22:57:43 <EvanR> there are many ways all bad
23:04:26 <tow> EvanR : we want to expose api 1. ConnectionId = getConnection(IP,Port)   2.sendMessage(ConnectionId,Message  )
23:05:13 <EvanR> you can put both of those operations in a record which was constructed by closing over the TVar
23:05:25 <EvanR> then give that record to whatever is using the API
23:05:32 <tow> EvanR: when we receive ConnectionId in sendMessage how would we get that perticular connection object sotred?
23:06:16 <EvanR> the implementation would do an atomic access to the TVar to get it
23:07:12 * hackage swagger-petstore 0.0.2.0 - Auto-generated openapi-petstore API Client  http://hackage.haskell.org/package/swagger-petstore-0.0.2.0 (jonschoning)
23:08:12 * hackage pinboard 0.9.12.10 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.9.12.10 (jonschoning)
23:08:50 <tow> EvanR : could you please exlain what is mean by "closing over the TVar"
23:09:59 <EvanR> data MyAPI = MyAPI { getConnection :: IP -> Port -> STM (Maybe ConnectionId); sendMessage :: ConnectionId -> Message -> STM () } for instance
23:10:51 <EvanR> makeMyApi :: TVar (HashMap K V) -> OtherStuffYouNeedToMakeThisWork -> MyAPI
23:11:53 <EvanR> makeMyApi tv otherStuff = MyApi { getConnection = ...; sendMessage = ... }
23:12:27 <EvanR> these actions are in the STM monad here not IO, as a suggestion to make them more composable
23:13:02 <EvanR> s/;/,/
23:16:45 <EvanR> now whatever holds an api can execute the actions but can't see the underlying TVar, if thats what you wish
23:24:03 <tow> EvanR : can multiple thread have handle to `MyApi` and  will it still work ? ,  if different agents call `makeMyApi` , then each agent would have its own exclusive <connectionid, value> map isnt it?
23:24:15 <EvanR> no agent calls makeMyApi
23:24:48 <tow> I see
23:24:57 <EvanR> yes if multiple threads have the MyAPI, it will work. thats the beautify of STM
23:26:08 <tow> sorry, a haskell noob, so an agent merely calls getConnection and sendMessage APIs then?
23:26:25 <EvanR> yes, within a transaction
23:26:48 <tow> great! thank you very much
23:29:19 <tow> EvanR: does this design have a name?
23:29:47 <EvanR> object oriented programming?
23:32:05 <tow> EvanR: :)
