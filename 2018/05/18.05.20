01:59:04 * hackage binary-tagged 0.1.5 - Tagged binary serialisation.  http://hackage.haskell.org/package/binary-tagged-0.1.5 (phadej)
02:01:03 * hackage gtk-strut 0.1.2.1 - Libary for creating strut windows with gi-gtk  http://hackage.haskell.org/package/gtk-strut-0.1.2.1 (eyevanmalicesun)
02:09:51 <Georgeoftown> What am I doing wrong?
02:10:09 <Georgeoftown> https://gist.github.com/georgeoftown/43f9fcc872322e72011fe88c6f591ca1
02:10:53 <jesyspa> Georgeoftown: the = bool is strange.
02:11:00 <jesyspa> Oh, wait, I see.
02:11:16 <jesyspa> You want to add testOperator x xs for the non-empty case.
02:11:23 <jesyspa> So testOperator x xs | ...
02:11:45 <jesyspa> And it shouldn't be = Bool, it should be = True or = False
02:12:11 <jesyspa> Or maybe I'm misunderstanding your code; in any case, you are giving a definition and then also doing some case analysis; that can't work.
02:12:15 <MarcelineVQ> = True or = False  would be wrong there as well when using guards
02:12:35 <Georgeoftown> mmm
02:12:50 <jesyspa> Yes, that's why you need the testOperator x xs added--at least, that's how I understand the intent.
02:17:43 <MarcelineVQ> the parse error is   = Bool   being there, there's sure to be more errors after that, but it's a place to start
02:18:23 <Georgeoftown> yes more errors
02:19:45 <jesyspa> What is the intent of the code?  It looks to me like testOperator x [] = removeInverses (RemoveOperator x OperatorSequence) == [] would work for what you want.
02:20:17 <MarcelineVQ> What's the type of removeInverses?
02:22:17 <Georgeoftown> *RemoveInverses> :t removeInverses
02:22:17 <Georgeoftown> removeInverses :: OperatorSequence -> OperatorSequence
02:24:06 <noan> is there a table for function precedence of infix functions implemented by Prelude?
02:25:02 <MarcelineVQ> noan: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
02:25:40 <noan> Thanks MarcelineVQ, I was looking at the haskell report and failed to find it
02:25:41 <noan> cheers
02:25:45 <MarcelineVQ> not entirely comprehensive for what comes in modern prelude
02:25:59 <noan> yeah that's fine, when in doubt open up Prelude
02:26:04 * hackage bits-extra 0.0.1.1 -   http://hackage.haskell.org/package/bits-extra-0.0.1.1 (haskellworks)
02:37:44 <iron_houzi> I'm trying to parse [Letter]. I was hoping I could do something like `parse letters [isPrefix, isConsonant, isVowel, isSuffix]`, which means that the first letter is prefix, second is a consonant ..etc. The `is..` functions all Letter -> Bool. Problem is that I also need the functions `subscribes` and `superscribes` which are Letter -> Letter -> Bool. Can I define a function that applies a list of functions
02:37:47 <iron_houzi> to a list of letters, where some functions take a single letter and others take two letters? (https://github.com/ironhouzi/hstib/blob/typing/src/Main.hs#L200-L226)
02:38:10 <stondo> hello everyone
02:38:59 <stondo> I'm trying to write a very simple unit test with hspec in stack project, but I'm getting ghc: could not execute: hspec-discover
02:41:56 <Georgeoftown> this is the error now
02:41:57 <Georgeoftown> https://gist.github.com/georgeoftown/43f9fcc872322e72011fe88c6f591ca1
02:43:24 <jesyspa> iron_houzi: It seems to me like you want the functions to be [a] -> (result, [a]); in your case [Letter] -> (Bool, [Letter]).
02:43:28 <jesyspa> You can then compose those.
02:43:40 <jesyspa> Basically, the functions "eat up" as much of the input as they need and then return the rest.
02:43:44 <iron_houzi> If I `parse [Ka, A, Nga] [isConsonant, isVowel, isSuffix]` it means: Ka is consonant, A is vowel, Nga is suffix. If I `parse [Ka, Ya, A, Nga] [subscribes, isVowel, isSuffix] it means Ka subscribes Ya (consuming the two first letters), A is vowel and Nga is suffix..
02:44:37 <jesyspa> Yeah, that sounds reasonable to me :)
02:45:01 <jesyspa> You can make a function convert1 :: (Letter -> Bool) -> [Letter] -> (Bool, [Letter])
02:45:22 <jesyspa> convert1 f [] = (False, []) \ convert1 f (x::xs) = (f x, xs)
02:45:39 <jesyspa> And convert2 :: (Letter -> Letter -> Bool) -> [Letter] -> (Bool, [Letter])
02:46:06 <jesyspa> convert2 f (x::y::xs) = (f x y, xs)
02:48:49 <iron_houzi> jesyspa: Not exactly clear to me. It seems like you have one function that consumes a single Letter and another function consuming two, but then how do I work out which one to apply?
02:50:00 <jesyspa> You have to apply them manually to your functions, but then you get a uniform list of functions [[Letter] -> (Bool, [Letter])].  (What you're really doing here is using the State monad.)
02:50:35 <jesyspa> So you can say parse [Ka, Ya, A, Nga] [convert2 subscribes, convert1 isVowel, convert2 isSuffix].
02:53:32 <iron_houzi> Thanks, but this just seems ugly to me.. I was hoping parse could handle the complexity of consuming Letters until the head function is totally applied ..
02:53:52 <iron_houzi> ..and then move on to the next one
02:54:10 <iron_houzi> *the next function in the list
02:58:54 <jesyspa> I don't think there's a clean way to do that, though I suspect there are messy ones involving typeclasses and existential types...
02:59:09 <jesyspa> I think the state monad is really what you mean here, though, so I'd express it via that.
03:10:20 <iron_houzi> Could I use Either monad to return Bool or (Letter -> Bool). The former causes the next function in the list tail to be applied, the latter uses the list head function.. ?
03:11:14 <iron_houzi> Sorry, but I didn't get the State monad jesyspa :(
03:12:09 <jesyspa> No, I don't think so; what you want is for different types to work in the same context, and you can't do that without wrapping them somehow.
03:12:16 <jesyspa> Let me write an example...
03:15:03 * hackage simpleconfig 0.0.10 - Short description of your package  http://hackage.haskell.org/package/simpleconfig-0.0.10 (AlexeyKotlyarov)
03:18:12 <jesyspa> (Oops, I see I mixed up my :: and : just now... sorry about that.)
03:19:21 <jesyspa> iron_houzi: You can get an interface like this: https://ideone.com/4gAQFg
03:19:51 <jesyspa> (Though really, you probably just want to write isVowel and such to be parsers in the first place.)
03:24:42 <iron_houzi> jesyspa: I really appreciate your feedback, but I certainly need time for digestion. By suggesting parsers, this seems like a completely new approach. Could you please elaborate on this?
03:26:08 <jesyspa> iron_houzi: I think it might be better if I link you to something; e.g. http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
03:26:55 <jesyspa> Basically, instead of trying to formulate your problem as a combination of two lists, you build up a "parser" that does the work for you.  There is a nice set of primitive operations that will let you express most of the things you may want.
03:34:26 <iron_houzi> jesyspa: Thank you so much for this feedback. I'll read that document now.
03:49:12 <kuribas> is it hard to use external javascript code with reflex?
04:16:25 <Gurkenglas> Does/Should "IndexedTraversal' t (f a) a -> IndexedTraversal' [t] (Free f a) a" exist in a library?
04:28:18 <statusfailed> does base have any way to do circular shifts? Doesn't seem to be in Data.Bits
04:30:05 <Gurkenglas> freetrav trav = reindexed (const []) (indexing _Pure) `failing` icompose (:) (_Free .> trav) (freetrav trav)
04:30:51 <Gurkenglas> statusfailed, http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bits.html#v:rotate
04:31:55 <Gurkenglas> (googling "haskell circular bit shift" put "rotate" in bold!)
04:42:59 <statusfailed> Gurkenglas: wow. I swear I tried that XD
04:43:00 <statusfailed> thanks!
04:43:47 <mbwgh> I have seen this example for the semantic function a few times: [[a+b]] = [[a]] + [[b]]. Just to get the types right in my head, why do we need to apply the oxford brackets to `a` and `b`, but not `+`? Or is it `+` that uniquely the types of `[[a]]` and `[[b]]` and is for this reason assumed to be known? Why not something like `[[+]] [[a]] [[b]]`?
04:44:23 <mbwgh> *uniquely determines
04:45:52 <Gurkenglas> Never seen that in Haskell. *googles oxford brackets* quasi quotation is usually written [| |] in Haskell
04:45:57 <lyxia> Operators tend are sometimes overloaded to simplify the notation
04:46:23 <lyxia> I would assume the + in [[a+b]] and [[a]] + [[b]] are different
04:46:56 <mbwgh> Gurkenglas: See for instance here https://en.wikibooks.org/wiki/Haskell/Denotational_semantics . Conal Elliot uses this notation as well when writing about denotational design / type class morphisms
04:46:59 <lyxia> inside the brackets is a syntactic + and outside it is a semantic one.
04:47:52 <lyxia> on this page they are typeset differently
04:48:23 <mbwgh> yeah, and maybe I am overthinking this way too much
04:49:45 <mbwgh> So should I just read it as [[a+b]] "means" addition of whatever `a` and `b` "mean" "for some suitable definition of addition", or something like that?
04:49:49 <lyxia> in many languages "+" on its own does not form an expression, so in a way it doesn't make sense to apply the semantic function to it.
04:49:52 <Gurkenglas> Before you have that denotations are compositional, the meaning of [[a+b]] is computed by some function String -> Meaning, where the string contains those three symbols.
04:50:24 <Gurkenglas> After you have that denotations are compositional, you know that what is between the oxford brackets is arranged in the shape of a syntax tree
04:50:31 <Gurkenglas> and the meaning is computed via a fold of that tree
04:51:01 <Gurkenglas> As in, meaning (+(a,b)) = meaning(+, meaning(a), meaning(b))
04:52:01 <mbwgh> So, basically a QuasiQuoter for my own special little language? :)
04:53:47 <Gurkenglas> I don't know whether the intuitions you have for those terms add up to what I wanted to convey, but you seem happy. If you want you can try to rephrase that.
04:56:55 <BoogieMan_> @pl \a -> a
04:56:55 <lambdabot> id
04:57:08 <BoogieMan_> @pl \a b -> a ++ ' ':b
04:57:08 <lambdabot> (. (' ' :)) . (++)
05:00:15 <Gurkenglas> http://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Indexed.html#v:selfIndex says selfIndex :: IndexedGetter a a b
05:00:25 <Gurkenglas> :t selfIndex :: IndexedGetter Int Int Bool
05:00:27 <lambdabot> error:
05:00:27 <lambdabot>     • Couldn't match type ‘Bool’ with ‘Int’
05:00:27 <lambdabot>       Expected type: p1 Bool (f1 Bool) -> Int -> f1 Int
05:00:33 <Gurkenglas> :t selfIndex :: IndexedGetter Int Int Int
05:00:35 <lambdabot> (Functor f, Contravariant f, Indexable Int p) => p Int (f Int) -> Int -> f Int
05:00:40 <Gurkenglas> Should it be selfIndex :: IndexedGetter a a a?
05:06:37 <Gurkenglas> :t (`indexed` []) :: IndexedTraversal' [Bool] Int Int -- Why doesn't this work?
05:06:38 <lambdabot> error:
05:06:38 <lambdabot>     • Could not deduce (Indexable [a0] p1)
05:06:38 <lambdabot>         arising from a use of ‘indexed’
05:06:46 <Gurkenglas> :t (`indexed` [True]) :: IndexedTraversal' [Bool] Int Int -- but this does
05:06:47 <lambdabot> (Applicative f, Indexable [Bool] p) => p Int (f Int) -> Int -> f Int
05:07:15 <mbwgh> Ok, I should have left out the goddamn smiley. I am not happy. Rephrasing: `[[a+b]]` stands for something like `parse "a+b" :: String -> Hutton` with `data Hutton = Add Hutton Hutton | ...`, so I would have something like `Add (Var "a") (Var "b")` at this point, implying I have some lookup table for variable names. But then that is how far I could go at this point. You wrote `meaning(+, meaning(a),
05:07:21 <mbwgh> meaning(b))`. Then `(+, meaning(a), meaning(b))` would be the recursive tokenizing step. But isn't the "outer meaning call" of a different type then, corresponding to some `eval :: Hutton -> Int` function?
05:09:06 <Gurkenglas> mbwgh, afaik Hutton doesn't have to have that definition. It could be IO ().
05:10:10 <Gurkenglas> mbwgh, denotations being compositional tells you that (parse "a+b") has form (parseAdd (parse "a") (parse "b"))
05:12:26 <mbwgh> And that is how for as it goes, then? The types of parse and parseAdd are not further specified?
05:13:48 <Gurkenglas> I'm not sure how far the texts you read specify it - you could specify that Hutton has that definition. But the definition of denotations being compositional you linked does not care about such further specifications.
05:13:58 <mbwgh> Maybe I should concentrate more on the fact that denotations are compositional, which is probably the point here anyway, rather than trying to make things concrete in my head
05:15:10 <Gurkenglas> mbwgh, that does not mean that denotations being compositional has no concrete effects. One thing it implies is that, if "4" has the same meaning as "2*2" then "1+2*2" has the same meaning as "1+2*2" (assuming + has low precedence <.<)
05:15:30 <Gurkenglas> *the same meaning as "1+4" ._.
05:16:50 <Gurkenglas> At the end that is. Um. m(4)=m(2*2) => m(1+4)=m(1+2*2).
05:20:49 <mbwgh> I see. Can the meaning of "compositional" also be kind of formalized? Should I interpret `+` as some composition operator for meaning functions here?
05:21:43 <mbwgh> Similarly to how you can define addition and multiplication of functions point-wise, effectively composing them?
05:22:13 <Gurkenglas> denotation is a synonym for meaning. Compositionality is a property of m.
05:22:48 <jesyspa> mbwgh: If I'm understanding correctly, a denotation is compositional if it arises as a universal transformation from the action on the individual parts.
05:23:44 <jesyspa> It may be easiest to think about it in comparison to lists: you can see a foldr as giving meaning [[Cons x xs]] -> cons [[x]] [[xs]], and [[Nil]] -> nil.
05:24:13 <Gurkenglas> Compositionality of a function f :: Tree a -> b apparently means f has form foldTree g
05:24:17 <jesyspa> If you specify cons and nil, you've specified the entire fold.
05:24:24 <Gurkenglas> http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:foldTree
05:24:48 <jesyspa> Yeah, exactly.  If you can express your denotation as a fold over the constructors, it's compositional.
05:25:27 <Gurkenglas> Meaning is hard to define. Therefore we talk about properties that do not depend on the definition of meaning.
05:25:42 <mbwgh> Interesting. But what does "universal transformation" mean here?
05:26:10 <jesyspa> The unique function that acts just by acting on the constructor at each point.
05:26:42 <jesyspa> There is a very clean formalisation of this, but it requires a bit of category theory to understand.
05:26:47 <jesyspa> Or, rather, formulate.
05:27:08 <Gurkenglas> jesyspa, does it mean the same as "f has form foldTree g"?
05:27:10 <mbwgh> So, things like universal constructions/properties?
05:27:17 <jesyspa> Gurkenglas: Yes.
05:28:03 <jesyspa> mbwgh: Yes.
05:31:17 <mbwgh> Ok, this has been valuable input. Thank you all very much.
05:31:37 <jesyspa> https://maartenfokkinga.github.io/utwente/mmf91m.pdf may be useful, as may http://chrislambda.github.io/blog/2014/01/30/catamorphisms-in-15-minutes/
05:31:54 <jesyspa> They describe what a compositional denotation must look like.
05:32:03 <jesyspa> It may help to think of some non-compositional examples, too.
05:34:29 <mbwgh> Wait, so oxford brackets are banana brackets?
05:35:37 <mbwgh> Sorry, scratch that, they define concave brackets too, as well as [[.]] for hylo
05:36:57 <mbwgh> But since you linked catamorphisms as well, that would be [(_)]
05:37:14 <mbwgh> no ([_])
05:37:15 <mbwgh> ugh
05:37:43 <mbwgh> There might be a rabbit hole here
05:37:56 <jesyspa> I don't think the usage is consistent everywhere.
05:38:39 <jesyspa> The core is that denotations are mappings from syntax to semantics, and compositional denotations are denotations that are also catamorphisms.
05:53:04 * hackage potoki-hasql 1.4 - Integration of "potoki" and "hasql".  http://hackage.haskell.org/package/potoki-hasql-1.4 (NikitaVolkov)
05:54:44 <juri_> has anyone here worked with the 'accelerate' library?
05:54:54 <kuribas> does [[a]] just means evaluate a?
05:55:05 <kuribas> doesn't
05:57:54 <statusfailed> juri_: Do you have a question about it? I looked at it once a long while ago
05:58:52 <juri_> not really, just wondering about experiences. i have a large library i'm looking at porting to it...
06:02:03 <Gurkenglas> kuribas, you only use [[]] when you haven't yet defined what "evaluate a" means exactly
06:02:21 <Gurkenglas> In order to define it, or talk about properties
06:04:47 <Gurkenglas> (... epistemic status may be lower than that vocabulary suggested)
06:05:12 <juri_> i used [[]] last night, in order to pre-evaluate an object at all of the intersection points, before classifying those intersections.
06:05:43 <juri_> it worked to improve my use of caches, and to parallelize object evaluation.
06:06:05 <Gurkenglas> juri_, can I look at the code?
06:06:19 <juri_> Gurkenglas: one moment.
06:07:06 <mbwgh> juri_: I have looked into it a while ago, and was a little dissatisfied that you could typecheck programs that would crash at run-time because of unimplemented type class methods. So you need to take care. Also, there is a worrying bug concerning the llvm backend: https://ghc.haskell.org/trac/ghc/ticket/14251 . I don't know the ramifications of this. So I would suggest you play around with it first before
06:07:12 <mbwgh> going all in
06:07:31 <juri_> http://kalli1.faikvm.com/ImplicitCAD/Stable/changeset/2ecac90d0cde8e17ee13669c4dd72cd23d466c04
06:11:56 <noan> Is there a more high-level networking/tcp library thank "network" that one would recommend if I wanted to abstract over it via Elerea?
06:12:19 <noan> Once a connection is established, I would like to treat it as a pair of Gen/Sink pairs
06:14:29 <Gurkenglas> Ha! juri_, [[1]] isn't meant as the list that contains only the list containing only 1, but as the semantic meaning of the letter 1
06:15:01 <Athas> juri_: I have some Accelerate experience, although I have never written anything large in it.
06:15:16 <Athas> The Accelerate maintainer usually hangs out somewhere on Gitter, not IRC.
06:15:53 <juri_> Athas: I'm looking at a port of ImplicitCAD to it.
06:16:23 <juri_> ... what's gitter? :P
06:16:45 <Athas> juri_: some web-based chat platform.
06:17:04 <juri_> just what no-one needed. ;)
06:17:10 <Athas> Indeed.
06:19:42 <mbwgh> yuri_: I assume it's the gitter channel linked here https://www.datahaskell.org/
06:20:05 <mbwgh> yuri_: And at least gitter is way more accessible than, say, slack
06:21:11 <mbwgh> Why people choose these proprietary platforms I don't get either. Probably, there's some really cool features I don't know about
06:21:12 <Athas> Yes, Gitter is not bad, just unnecessary.  Slack consistently annoys me.
06:21:58 <juri_> the last thing i want is to have to keep a web browser open to juggle chat channels. *sigh*
06:22:26 <Athas> With Slack, you need a browser tab per organisation!
06:23:14 <mbwgh> "a"? Try several. I use palemoon for normal browsing, firefox when palemoon fails me, but I could only get slack to work with chrome
06:23:57 <mbwgh> Hmm, haven't tried lynx yet...
06:24:15 <juri_> welp, thanks for pointing me there. now i have MORE content to read. still reading the mailing list.
06:24:47 <mbwgh> Sorry :(
06:32:54 <ph88> is it possible to get the sourcecode line of a type ?
06:44:48 <tezos_noob[m]> i was trying to connect to wss client, and i have access to the TLS params. Which library should i be using to establishing a secure websockets connection?
06:55:27 <Gurkenglas> How would you write an IndexedTraversal' [Int] (Free [] b) b?
06:55:34 <Gurkenglas> How would you write an IndexedTraversal' [Int] (Cofree [] b) b I mean
06:55:39 <Gurkenglas> already got the Free part:
06:55:56 <Gurkenglas> :t let freetrav trav = icompose (:) (_Free .> trav) (freetrav trav) in freetrav
06:55:58 <lambdabot> Applicative m => (Indexed a1 (Free f a2) (m (Free f a2)) -> f (Free f a2) -> m (f (Free f a2))) -> Indexed [a1] a3 b -> Free f a2 -> m (Free f a2)
06:56:24 <Gurkenglas> Whoops, copied the wrong query. Not on top of my game
06:56:50 <Gurkenglas> :t let freetrav trav = reindexed (const []) (indexing _Pure) `failing` icompose (:) (_Free .> trav) (freetrav trav) in freetrav
06:56:51 <lambdabot> Applicative f1 => (Indexed a1 (Free f2 a2) (f1 (Free f2 a2)) -> f2 (Free f2 a2) -> f1 (f2 (Free f2 a2))) -> Indexed [a1] a2 (f1 a2) -> Free f2 a2 -> f1 (Free f2 a2)
07:07:29 <Gurkenglas> :t let freetrav trav = reindexed (const []) (indexing _Pure) `failing` icompose (:) (_Free .> trav) (freetrav trav) in itoListOf (freetrav itraversed)
07:07:31 <lambdabot> TraversableWithIndex a1 f => Free f a2 -> [([a1], a2)]
07:08:29 <Gurkenglas> The correspondent for Cofree will have to choose between preorder, postorder etc... lets use preorder
07:12:12 <Gurkenglas> Is there a better "i -> Traversal s t a b -> IndexedTraversal i s t a b" than "\i -> reindexed (const i) . indexing"?
07:20:04 <Fatalnix> Hey guys, I don't knw anything much about haskell, but I need to install some haskell packages for a program to work. I have installed ghc, and I have been told that I should install cabal to make package installation easy. The problem is, I have no idea how to install cabal. ghc did not ship with it, and when I looked at the website I just have a couble of tarballs I am not sure what to do with.
07:20:32 <Fatalnix> oh wait this one comes with a configure, I didnt see that, nvm
07:21:48 <cocreature> Fatalnix: you can also find binaries on https://www.haskell.org/cabal/download.html
07:23:11 <Fatalnix> YEah maybe I should do that. thesource for the cabal library appears to have a syntax error in the setup.hs file
07:24:08 <hvr> Fatalnix: what OS are you on?
07:24:31 <Fatalnix> Linux x86_64
07:24:38 <hvr> ubuntu, debian, ...?
07:24:45 <Fatalnix> Linux darkstar 4.14.12 #1 SMP Thu Jan 11 04:58:06 EST 2018 x86_64 Intel(R) Core(TM) i5-7300U CPU @ 2.60GHz GenuineIntel GNU/Linux
07:24:49 <Fatalnix> Slackware
07:25:08 <cocreature> a syntax error in the setup.hs file seems somwhat unlikely
07:25:18 <Fatalnix> I thought the same
07:25:27 <cocreature> but you probably also want the source of cabal-install and follow the README in that instead of the source of the cabal lib
07:27:23 <kuribas> Gurkenglas: isn't it sort of an operator then?  Like evaluate (a + b) = evaluate a + evaluate b
07:28:06 <kuribas> Fatalnix: on linux the package is usually called cabal-install
07:37:39 <Fatalnix> there. Got all that settled :D I installed a package that I needed to run cmake for this project, but it still says that package insn't installed. Here's what I tried: I did the sandbox thing for cabal, installed it as a normal user. That didn't work, so I thought maybe it was kind of like the way cpan works, where it will look in the root cabal stuff, so I installed it as root and it didnt work.. I'm not sure what I could do to satisfy this
07:37:39 <Fatalnix> program that the package is in fact installed.
07:38:22 <hvr> Fatalnix: is the project/program you're trying to build publicly available?
07:39:00 <Fatalnix> Yesh. I am trying to set up this game somebody told me about called hedgewars. It uses cmake, and has haskell sources in it, apparently- which need some package named "vector"
07:39:48 <Fatalnix> I'm not quite exactly sure where it's looking, I'm sure it's just a path confusion issue somewhere
07:40:02 <Fatalnix> Possibly not even Haskell related.
07:40:07 <hvr> it's this one, right? https://github.com/hedgewars/hw
07:40:26 <Fatalnix> yes
07:41:34 <Fatalnix> Looks to be written in a mix of languages
07:41:56 <hvr> Fatalnix: ok, why did you install things in a `cabal sandbox`?
07:42:10 <hvr> I don't see that recommended in the build guide
07:42:43 <Fatalnix> The documentation for cabal  install recommended it to prevent confusion between versions. When I installe dit as root, I didn't install in a sandbox.
07:42:48 <Fatalnix> just to test that
07:43:01 <hvr> Fatalnix: if ghc doesn't find the haskell libs you `cabal install'ed, then it's mostly likely because you did install them into a sandbox which isn't visible to ghc by default
07:43:23 <Fatalnix> so, when i switched to root, I installed without a sandbox, that was my theory too
07:43:25 <hvr> Fatalnix: also, if you `cabal install` it goes by default into your ${HOME}/.cabal
07:43:37 <hvr> it doesn't install them "globally" for all users
07:43:38 <Fatalnix> ok
07:43:50 <hvr> or rather, into your ${HOME}/.ghc/
07:44:07 <Fatalnix> so is there a way to get out of the sandbox?
07:44:41 <hvr> just remove the sandbox again (cabal sandbox delete), and `cabal install` normally
07:44:48 <Fatalnix> I see
07:45:15 <Fatalnix> huh. says I'm not in a sandbox, but we'll see what happens
07:45:30 <hvr> you probably changed your CWD
07:45:42 <hvr> cabal sandboxes are merely CWD sensitive
07:45:55 <Fatalnix> aha
07:45:59 <hvr> similiar to how Git works
07:46:04 <Fatalnix> so it's meant for things like, your personal projects?
07:46:07 <hvr> yeah
07:46:15 <Fatalnix> That's actually kind of cool
07:46:34 <hvr> ...but we're moving away from it, to an even cooler concept :0
07:46:42 <Fatalnix> I see
07:47:05 <Fatalnix> I do not know much about Haskell, I mostly write in Elixir
07:47:09 <Fatalnix> and Erlang
07:47:19 <hvr> if you're curious, this is where the action is: http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
07:47:22 <mjrosenb> using lenses, I can use (mapValue ^. at key) to get a key from a map, how would I do it if instead the map is a member of a struct that is being lensed into?
07:47:48 <Fatalnix> Good news, it actually accepted the package now.
07:47:56 <Fatalnix> so yeah it was just the blasted sandbox
07:48:16 <mjrosenb> do i just need to view getMap struct ^. at key? this seems like not the correct way.
07:48:17 <hvr> yeah, hedgewars uses a highly non-standard way to build
07:48:29 <Fatalnix> Huh.
07:48:35 <hvr> which would require special instructions to work w/ cabal sandboxes
07:48:37 <Fatalnix> I wouldn't know.
07:49:17 <Fatalnix> I noticed it seems to be written in a combination of rust haskell and pascal  rofl
07:49:26 <Fatalnix> or at least I thought I spotted some rust
07:49:33 <hvr> Fatalnix: and if all you care aabout is getting hedgewars working, and manage to avoid getting sucked into coding Haskell, you can ignore sandboxes for now :)
07:49:58 <Fatalnix> Haskell is on my list of things to play with at some point. I just never did because ghc was so big
07:50:12 <Fatalnix> I would forget I was even installing it
07:50:29 <Fatalnix> then my battery would die before it finished every time
07:50:48 <hvr> yeah, ghc is a bit of an outlier when it comes to its distribution size
07:51:35 <mjrosenb> speaking of ghc, is there a distribution that actually ships ghcjs?
07:51:59 <Fatalnix> Does ghc have an MS/PC/DR-DOS 16 bit target available for my 486 box btw? I'd be more inclined to play with it on that since that's my office computer upstairs.
07:51:59 <mjrosenb> every computer I have has ghc-8.*, which means I can't cabal install ghcjs
07:52:04 <hvr> mjrosenb: NixOS? :)
07:52:20 <mjrosenb> hvr: I looked, and did not see ghcjs available.
07:52:27 <mjrosenb> is it in the unstable channel?
07:52:50 <hvr> mjrosenb: I was looking into packaging ghcjs as part of http://downloads.haskell.org/debian/, but it's non-trivial to get it cleanly packaged :-/
07:53:15 <mjrosenb> I also have ~0 experience with nixos, so I would not be surprised if it was completely my failure to find it.
07:53:41 <mjrosenb> (is ghcjs shipped with the haskell platform; is the haskell platform still a thing?)
07:54:15 <hvr> mjrosenb: I think most people install ghcjs via https://github.com/reflex-frp/reflex-platform these days
07:54:43 <hvr> mjrosenb: the Haskell Platform is still a thing! the HP for GHC 8.4.2 was released just a couple weeks ago
07:55:08 <hvr> but ghcjs isn't yet part of it; it could be though in theory
07:55:09 <Fatalnix> It looks like Hugs supports DOS targets
07:55:18 <Fatalnix> So I could check that out
07:55:27 <hvr> Fatalnix: Hugs is kinda dead
07:55:31 <Fatalnix> Aww
07:55:55 <Fatalnix> I didn't necessarily expect it to be updated
07:56:20 <hvr> Fatalnix: if you manage to install it, you can definitely learn Haskell98 with it
07:56:33 <Fatalnix> how different is Haskell98?
07:56:54 <hpc> it's "less"
07:57:00 <Fatalnix> up to 20 years of standards difference, right?
07:57:03 <hvr> Fatalnix: Haskell98 is a very small part of what people today consider Haskell (which is basically Haskell2010 + various extensions)
07:57:08 <hpc> haskell2010 was haskell98 with some extensions integrated in
07:57:22 <hpc> but they're pretty major ones, like FFI
07:57:24 <Fatalnix> I see
07:57:30 <Fatalnix> oh yes FFI is nice
07:57:38 <mjrosenb> and there are many haskell extensions that add in features that people would consider 'essential'
07:57:43 <Fatalnix> so you can't mix C and Haskell98 code very well?
07:57:45 <hvr> Fatalnix: i.e. most modern Haskell programs go beyond Haskell2010, and also most literature you find will likely assume at least HAskell2010
07:58:01 <hpc> you can, FFI still existed as an extension
07:58:05 <hpc> it just wasn't standardized
07:58:15 <mjrosenb> but did hugs98 support an ffi?
07:58:21 <hvr> Fatalnix: also, the standard libraries shipping with GHC have significantly diverged from the ones specified in Haskell2010...
07:58:38 <mjrosenb> I mean, since it is interpreted, it *should* be pretty easy to hack the runtime to follow an ffi.
07:59:08 <hvr> iirc Hugs did support some kind of FFI
07:59:32 <hvr> in fact, https://github.com/fuzxxl/Hugs/blob/master/docs/ffi-notes.txt
08:00:05 <duncan^> Hugs also runs on Plan 9
08:00:21 <duncan^> Hugs is still awesome in that respect
08:00:22 <hpc> from outer space?
08:00:36 <mjrosenb> from bell labs.
08:01:16 <hvr> but they named it after the movie
08:02:14 <Fatalnix> hvr: what better way to learn some Haskell than to reinvent EVERYTHING
08:02:14 <mjrosenb> hvr: honestly, if anyone ever told me they didn't name it after the movie, I would not believe them.
08:02:15 <Fatalnix> :D
08:03:11 <mjrosenb> Fatalnix: that is actually not a bad idea.  writing a lazily evaluated language, and Monad Maybe and Monad List instances gave me a *very* good idea of how haskell works
08:03:30 <Fatalnix> Haskel98 didnt' have monads?
08:04:02 <mjrosenb> except these %~^.<>=ing lenses, apparently
08:04:09 <hvr> Fatalnix: if you are serious about learning HAskell, here's some great courses: http://www.seas.upenn.edu/~cis194/fall16/ & https://github.com/data61/fp-course
08:04:28 <mjrosenb> it did, and probably had the two instances I mentioned, but that doesn't mean you can't write your own instance for it.
08:04:44 <Eduard_Munteanu> It had monads. Really, Haskell2010 isn't a big overhaul, just a few things got into the standard (or out).
08:05:22 <mjrosenb> I didn't realize anything was removed.  I assume it was stuff that had its roots in the 90's and was never a good idea?
08:05:36 <mjrosenb> akin to C removing trigraphs?
08:05:38 <hvr> mjrosenb: for one, n+k syntax was removed
08:05:44 <Eduard_Munteanu> n+k patterns, yeah
08:06:03 <mjrosenb> oh right, that one...
08:06:33 <hvr> mjrosenb: and also attaching class constraints to data types
08:07:04 * hackage show-please 0.5.5 - A wrapper type V with improved Show instances  http://hackage.haskell.org/package/show-please-0.5.5 (DavidFox)
08:07:05 <mjrosenb> I feel like I've kind of wanted that one on occasion, but I can see how it is superfluous.
08:10:56 <mjrosenb> is it intentional that the type parameters of lenses spell out 'stab'?
08:12:44 <hpc> don't forget the functor, it's fstab
08:12:47 <hpc> clearly lens is a filesystem
08:13:35 <mjrosenb> https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens.html -- those huge charts don't mention a functor.
08:13:35 <Georgeoftown> can someone see this?
08:13:37 <Georgeoftown> https://gist.github.com/georgeoftown/6c29ba6436e209c2b4ac28635bb04f80
08:14:54 <mjrosenb> Georgeoftown: that is being parsed as (testOperator x):(xs ys)
08:15:06 <hpc> mjrosenb: https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Type.html#t:LensLike
08:16:14 <mjrosenb> Georgeoftown: aols, x is not defined anywhere.
08:16:32 <Georgeoftown> mmm
08:16:34 * mjrosenb looks at hands, confused
08:29:23 <dmj`> When building a lexer, is there a way to tell cabal to pass the -g flag to alex. Like an “alex-options” stanza in the cabal file.
08:37:01 <Georgeoftown> Now only one error
08:37:02 <Georgeoftown> https://gist.github.com/georgeoftown/6c29ba6436e209c2b4ac28635bb04f80
08:37:49 <fakenullie> I think you have to parenthesize x:xs
08:41:28 <mjrosenb> Georgeoftown: I assume you're going to do something else with x, since as it is written, you can replace all instances of (x:xs) with xs, and it will do the same thing.
08:44:00 <Georgeoftown> yes
08:44:06 <Georgeoftown> *TestOperator> :t testOperator
08:44:06 <Georgeoftown> testOperator :: Operator -> OperatorSequence -> Bool
08:44:24 <Georgeoftown> x is the operator
08:44:57 <Georgeoftown> but its part of operatorSequece
08:48:38 <ph88> does haskell have this?  https://secure.php.net/manual/en/language.constants.predefined.php
08:49:50 <kadoban> ph88: With CPP extension it should have __LINE__ and __FILE__ and a few others, I dunno which
09:02:04 * hackage ghc-trace-events 0.0.0 - Faster replacements for traceEvent and traceEventMarker  http://hackage.haskell.org/package/ghc-trace-events-0.0.0 (MitsutoshiAoe)
09:03:04 <kuribas> Is haskell suited for any program?
09:04:36 <kuribas> I tried applying for a haskell job, and the interviewer kept asking if I thought haskell is suited for for any programming job.  Like it was a bad thing to assume.
09:04:47 <mjrosenb> insertM v (Just s) = Just (S.insert v s); insertM v Nothing = Just $ S.singleton v
09:05:14 <mjrosenb> Is there some nicer way of writing this? it is like simultaneously using Set and Maybe as a monoid.
09:06:39 <kuribas> mjrosenb: S.insert v (fromMaybe S.empty s) ?
09:08:10 <mjrosenb> hrmm, that is a different direction than I was thinking of, but that is nice.
09:09:56 <kuribas> is Set a monoid?
09:10:34 <glguy> kuribas: Do not know how to determine that?
09:10:51 <kuribas> glguy: yeah, I just looked it up :)
09:11:03 <kuribas> glguy: read over it first time, sorry.
09:11:16 <c_wraith> the instance list is so easy to ignore, for how important it is
09:11:23 <mjrosenb> instance Ord a => Monoid (Set a) -- Defined in ‘Data.Set.Internal’
09:11:24 <c_wraith> Though it's better than it used to be
09:11:43 <glguy> On that topic, don't forget about :info! for when you really want to see the instances
09:11:54 <mjrosenb> I was wondering why the instance had the Ord a constraint, then I figured it out.
09:12:51 <kuribas> mjrosenb: then Maybe Set is a nested monoid
09:14:19 <mjrosenb> > Just (singleton 4) `mappend` Just (singleton 3)
09:14:22 <lambdabot>  error:
09:14:23 <lambdabot>      • Variable not in scope: singleton :: Integer -> a
09:14:23 <lambdabot>      • Perhaps you meant one of these:
09:14:35 <c_wraith> :t S.singleton
09:14:37 <lambdabot> a -> S.Set a
09:14:41 <c_wraith> use that one
09:14:44 <mjrosenb> > Just (S.singleton 4) `mappend` Just (S.singleton 3)
09:14:46 <lambdabot>  Just (fromList [3,4])
09:14:51 <mjrosenb> so it is!
09:18:03 <kuribas> mjrosenb: perhaps foldMap id?
09:18:58 <kuribas> :t foldMap id Nothing
09:19:00 <lambdabot> Monoid m => m
09:19:13 <kuribas> :t foldMap id (Just undefined)
09:19:14 <lambdabot> Monoid m => m
09:20:05 <kuribas> eh, that's concat
09:20:42 <kuribas> :t concat
09:20:43 <lambdabot> Foldable t => t [a] -> [a]
09:21:00 <c_wraith> :t fold
09:21:02 <lambdabot> (Monoid m, Foldable t) => t m -> m
09:21:27 <glguy> mjrosenb: Another option: maybe (Set.singleton v) (Set.insert v)
09:21:53 <glguy> Also: foldMap id === fold
09:22:03 * hackage iCalendar 0.4.0.4 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.4.0.4 (ChristianRoedliAmble)
09:23:15 <kuribas> mjrosenb: so: S.insert v (fold s)
09:24:02 <kuribas> or v <> fold s
09:24:12 <glguy> type error
09:24:24 <kuribas> S.Singleton v <> fold s
09:28:44 <ph88> how can i get the trace output of a without mixing it with the code of the next line ?  https://bpaste.net/show/c1a41b2dafbf
09:32:57 <sm> add a newline ?
09:35:19 <c_wraith> ph88: evaluate the parsed data structure fully before outputting it.
09:40:03 <c_wraith> ph88: print (what ghci uses to produce output for non-IO values) does character-at-a-time output.  lazy instances of Show will result in the structure being evaluated as it is being printed.
09:40:19 <c_wraith> ph88: that's the source of the interleaving you're seeing.
09:41:00 <c_wraith> ph88: to get rid of the interleaving, you need to make sure that whatever ghci prints requires evaluating the entire structure before it can produce any output
09:43:38 <cocreature> you can use "force" from deepseq for that
09:45:26 <noipmups> What's the purpose of `extend` function in Comonad typeclass? Could anyone, please, give me an example of its real world usage?
09:47:19 <c_wraith> noipmups: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
09:55:40 <[exa]> noipmups: any kind of caching environment can generally be viewed as comonad. You can 'drop' the cache by extract, and 'extend' can be regarded as modifying a transformation from function that ignores/discards the cache to a function that preserves the cache
09:55:54 <jesyspa> Neat demonstration of comonads, although I wonder if there's a neat extension of this for 2D grids.
09:56:42 <[exa]> s/modifying//
09:56:44 <jesyspa> Maybe U (U a) is also comonadic?
09:57:30 <[exa]> jesyspa: isn't standard maybe just *->* ?
09:57:43 <[exa]> *Maybe
09:57:51 <jesyspa> [exa]: Sorry, Maybe wasn't part of the type there
09:58:00 <jesyspa> s/Maybe/Perhaps/
09:58:01 <[exa]> oh so :]
09:59:24 <[exa]> jesyspa: well, can you extract 'a' from that?
09:59:33 <jesyspa> Yes, you've got a double extract.
10:00:05 <jesyspa> I'm fairly sure that whenever M is a (co)monad, M . M is a (co)monad.
10:00:17 <noipmups> Thank you all. I'm reading the article and still have a problem to get my head around what `extend` do in 1D/2D context.
10:00:21 <[exa]> hm that's interesting
10:00:46 <jesyspa> (Perhaps even that whenever M is a monoid in a category, M mappend M is a monoid in that category. ;))
10:01:15 <jesyspa> But I'm not sure whether the comonoidal structure you get here represents a 2D grid the way it represents a 1D grid.
10:01:32 * [exa] gonna try on simple cases
10:03:49 <[exa]> noipmups: btw there was a better and more colorful article on comonads vs cellular nets somewhere out there
10:12:54 <noipmups> <[exa]> I've also read https://jaspervdj.be/posts/2014-11-27-comonads-image-processing.html. From this article it seems that `extract` behave similarly to `fmap` (referring to the sentence "We want to convert all pixels in the image, and the conversion function is supplied as f :: FocusedImage a -> b")
10:18:30 <ph88> sm, if i put a newline there is still "b <-" on the left and "$ wp" on the right .. i don't want to contaminate the next line in the sourcecode by putting things in the middle
10:19:00 <ph88> c_wraith, not sure what interleaving you are talking about. I was not asking about the output of trace
10:20:26 <cocreature> ph88: so you want to trace "a" without having a trace statement in your code? that sounds weird …
10:21:25 <ph88> i want a trace statement but not in the middle of the line that starts with   b <-
10:21:53 <ph88> some dummy line with the trace statement would be good, but i don't know how to make it
10:22:19 <cocreature> traceShowM a
10:22:28 <ph88> thx
10:25:28 <iqubic> :t traceShowM
10:25:29 <lambdabot> error: Variable not in scope: traceShowM
10:31:49 <tabaqui2> hey all
10:31:59 <tabaqui2> how do you solve problems with cabal on arch linux?
10:32:16 <tabaqui2> I cannot install any package because it cannot load Prelude
10:32:49 <cocreature> tabaqui2: remove everything Haskell-related that you installed via pacman except for ghc, ghc-static and ghc-libs
10:33:09 <tabaqui2> cocreature: XMonad too?
10:33:43 <cocreature> yes
10:34:52 <tabaqui2> cocreature: cabal?
10:35:41 <cocreature> tabaqui2: when I say “everything” I really mean “everything” :)
10:36:40 <tabaqui2> cocreature: ok, I'll try, thanks
10:41:58 <tabaqui2> meh, it works
10:42:00 <tabaqui2> thanks :)
10:45:20 <ph88> anyone know how i can lookAhead without consuming any input until the end of the input ?
10:46:01 <fr33domlover> ph88, which parser
10:46:06 <ph88> megaparsec
10:46:52 <zincy> Does a type need to have an instance of monoid to permit an instance of foldable?
10:47:53 <meeples> why in the five hells is `concat` not named `flatten`?
10:48:53 <kuribas> meeples: because flatten implies multiple layers?
10:49:02 <ph88> zincy, looks like yes  fold :: Monoid m => t m -> m
10:49:28 <kuribas> > concat [[[1]], [[2]], [[3, 4]]]
10:49:30 <lambdabot>  [[1],[2],[3,4]]
10:49:41 <zincy> How do you make a tree an instance of monoid?
10:49:56 <ph88> zincy, by defining mempty and mappend
10:50:09 <barrucadu> zincy: No, a type doesn't need to be a Monoid to be a Foldable.
10:50:22 <barrucadu> And actually it can't be, because Monoid and Foldable have different kinds
10:50:41 <ph88> ah yes barrucadu is right, fold is not needed for the minimum implementation
10:50:42 <barrucadu> the *elements* of your Foldable might need to be a Monoid for some operations (like fold)
10:50:50 <tabaqui2> ph88: in fold 't' is Foldable and 'm' is Monoid
10:50:50 <zincy> data Tree a   = Node a          [Tree a]   | Nil   deriving (Show, Eq)
10:50:52 <ph88> zincy, mempty can be an empty tree .. but how do you want to add your trees together (on paper even)
10:51:31 <zincy> So would you define mappend depending on the particular use case of your joining operation ?
10:51:43 <zincy> Or depending on the exact implementation of the tree?
10:51:57 <ph88> on the joining operation i think
10:51:59 <zincy> I mean surely for the definition of tree I gaver there is only one valid instance of monoid
10:52:18 <ph88> but i'm not sure if i would use monoid in that case because likely i want different kinds of joining operations
10:53:00 <ph88> zincy, you can define monoid as you like, it will be valid if it type checks
10:53:42 <kadoban> Monoid does have some laws
10:54:06 <zincy> Surely it could type check despite not having an identity?
10:54:12 <[exa]> zincy: can you think of a way of joining trees that preserves associativity?
10:54:34 <[exa]> s/preserves/has/
10:54:59 <zincy> exa : hmm
10:55:02 <ph88> zincy, what do you mean not having an identity ?
10:55:47 <ph88> zincy, i think an easy implementation would be to make a new tree with 2 nodes and put the trees in there
10:56:12 <kadoban> mempty <> x = x    and x <> mempty = x are the identity laws for Monoid
10:56:52 <zincy> I can't think of an associative joining operation for trees
10:57:35 <zincy> ph88 : What would the root node of the new tree be?
10:58:53 <kadoban> I would think some specific trees could have an associative joining operation, but ... not sure it's really a good idea usually.
10:59:21 <zincy> ph88: By not having an identity I meant not following the identity lows for monoid. The type checker wont catch this right
10:59:38 <[exa]> it's easy for ordered search trees where you can kindof ignore the exact rotation
11:00:11 <[exa]> zincy: what about if you relax your requirements a bit and assume the contained 'a' is a monoid?
11:00:35 <zincy> exa: Yes this is a good idea. I thought of this before fleetingly
11:01:04 * hackage nanovg 0.6.0.0 - Haskell bindings for nanovg  http://hackage.haskell.org/package/nanovg-0.6.0.0 (cocreature)
11:02:21 <[exa]> I don't know if it's a required property for a nice monoid instance on the general tree you have, but I see no other way to create an uniquely identified root element of a new tree than <>ing the 2 original root elements
11:02:37 <[exa]> but maybe there's something smarter. :]
11:02:58 <zincy> Yeah it's a tricky tree right because of its generality?
11:04:33 <[exa]> seems so.
11:05:24 <zincy> How would I express a monoid class constraint for a? Would I do it in my implementation of foldable or in the original type for the tree
11:06:03 <kadoban> zincy: As a constraint on the instance of Foldable
11:06:05 <[exa]> instance Monoid a => Monoid (Tree a) ?
11:06:19 <kadoban> (and in any other operations that need it, outside of Foldable)
11:06:51 <[exa]> oh, for foldable. :]
11:10:01 <zincy> Hmm but foldable only refers to a type of kind * -> *
11:12:45 <[exa]> zincy: Foldable has to be generic for all contained types anyway
11:13:14 <monochrom> I'm looking at your "data Tree a   = Node a          [Tree a]   | Nil" and wondering why it is designed this way.  Is there any reason you allow Node 4 [Nil, Nil, Nil] as a possibility and is it really important?
11:14:13 <monochrom> Especially what's the difference among the following three: Node 4 [], Node 4 [Nil, Nil], Node 4 [Nil, Nil, Nil]
11:14:20 <zincy> monochrome: tbh a Nil node seems pointless to me aswell
11:15:01 <zincy> could I just remove Nil?
11:15:10 <monochrom> Yes, it's your code.
11:15:29 <zincy> Makes sense thanks for pointing it out
11:16:00 <[exa]> now what to do with an empty tree?
11:16:26 <zincy> exa: in the context of foldable?
11:16:58 <[exa]> no, how to represent it with just Node a [Tree a]
11:17:25 <zincy> Does an empty tree make sense?
11:17:43 <cocreature> depends on your application
11:18:05 <monochrom> Foldable will require an empty tree.
11:18:06 <[exa]> empty tree seems like an obvious candidate for 'mempty'
11:18:25 <infinisil> zincy: You need some basecase in the recursion, otherwise you can't even construct such a tree
11:18:41 <zincy> true
11:18:59 <[exa]> well the base case can be Node _ [], but there's still 1 element there
11:19:00 <monochrom> Node 4 [] can be a base case.
11:19:29 <monochrom> So this is when I would define two types, not one.
11:20:46 <zincy> This would be so much simpler as a binary tree
11:20:49 <monochrom> data Tree a = Empty | NonEmpty (Node a); data Node a = NodeOf a [Tree a]
11:21:17 <monochrom> Err no that's still wrong.
11:21:20 <cocreature> that’s a weird tree
11:21:43 <cocreature> oh nvm I can’t read
11:21:44 <monochrom> data Tree a = Empty | NonEmpty (Node a); data Node a = NodeOf a [Node a]
11:23:00 <rotaerk> or just use data Tree a = Node a [Tree a]
11:23:09 <rotaerk> and use Maybe to handle empty/non-empty-ness
11:23:15 <fr33domlover> or just use Data.Tree ? :)
11:24:52 <monochrom> Oh Foldable doesn't require an empty tree.
11:26:00 <zincy> Foldable technically shouldnt require an instance of monoid or empty trees which is why I am surpised at the difficulty of making data Tree a   = Node a          [Tree a] . into a foldable
11:26:42 <fr33domlover> ph88, did you get an answer? I don't remember megaparsec functions but if there's none to do this directly, you could try using 'try' or figuring out how much it left and use 'take' of that length, or stop the parser entirey, grabbing that text, and then keep parsing
11:27:08 <glguy> zincy: No, a type doesn't have to be an instance of Monoid to be an instance of Foldable
11:30:26 <zincy> glguy: I said exactly that right?
11:30:26 <glguy> Perhaps, I'm just scanning through the backlog. So then.. Yes,*
11:30:26 <zincy> glguy: No worries I wasnt sure 10 mins ago
11:30:26 <glguy> zincy: What difficulty are you having making an instance for that type?
11:30:26 <monochrom> Oh haha Data.Tree decides to just do pre-order traversal for foldMap.
11:30:26 <zincy> Foldable
11:30:26 <glguy> instance Foldable Tree where foldMap f (Node x xs) = f x <> foldMap (foldMap f) xs
11:30:26 <zincy> :t foldMap
11:30:26 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:31:27 <zincy> glguy: How would you specifiy the typeclass constraint for monoid
11:31:40 <glguy> Just like lambdabot did there
11:31:51 <glguy> I probably just don't know what you're asking
11:32:00 <zincy> GHC wont let me append such a type sig to foldmap in the foldable method
11:32:14 <glguy> zincy: You don't get to put type signatures in instance declarations
11:32:22 <glguy> that're automatically determined from the class definition
11:32:28 <glguy> they're*
11:33:11 <glguy> There's technically an extension that lets you write them, but that doesn't give you any extra power, it just makes things more explicit. You have to copy the automatically generated one
11:33:46 <glguy> http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Foldable.html#t:Foldable
11:35:56 <glguy> foldMap is declared to have the type (Monoid m => (a -> m) -> t a -> m) when making an instance of (Foldable t), so for Trees the type of the method will always be: foldMap :: Monoid m => (a -> m) -> Tree a -> m
11:36:44 <glguy> and the "minimal complete definition is "foldMap | foldr", so we only have to implement one of those two and we're done
11:37:20 <zincy> and foldr is derived from our definition of foldMap?
11:37:38 <glguy> Once you've implemented the minimal complete definition, everything else can be derived
11:37:44 <zincy> I confused about what foldmap does
11:37:46 <zincy> :t foldMpa
11:37:49 <zincy> :t foldMap
11:37:51 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:37:52 <lambdabot> error:
11:37:52 <lambdabot>     • Variable not in scope: foldMpa
11:37:52 <lambdabot>     • Perhaps you meant one of these:
11:38:00 <glguy> "Map each element of the structure to a monoid, and combine the results."
11:39:19 <zincy> so it essentially hijacks the m's monoid instance to do the work
11:39:34 <[exa]> yeah, exactly
11:39:44 <glguy> hijack is probably a bit harsh, but it certainly uses (m)'s instance to combine the values
11:40:12 <zincy> :t mConcat
11:40:14 <lambdabot> error:
11:40:14 <lambdabot>     • Variable not in scope: mConcat
11:40:14 <lambdabot>     • Perhaps you meant one of these:
11:41:22 <[exa]> zincy: lowercase c
11:41:31 <zincy> :t mconcat
11:41:33 <lambdabot> Monoid a => [a] -> a
11:41:37 <zincy> oops
11:41:39 <zincy> :mconcat
11:41:46 <zincy> :t mconcat
11:41:48 <lambdabot> Monoid a => [a] -> a
11:42:05 <zincy> :t foldMap
11:42:06 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:46:14 <infinisil> Oh no, goodbye lambdabot
11:46:19 <spoonm> rip
11:46:33 <mupf> Can anyone recommend me a book to start learning Haskell? I'm a C programmer wo likes real books. ;)
11:46:48 <spoonm> do you guys consider it poor form if I have a big file and start importing everything qualified so that later on I know where each function is coming from?
11:46:53 <glguy> mupf: Hutton's Programming in Haskell
11:46:58 <glguy> 2nd ed.
11:47:06 <mupf> Thanks
11:47:07 <zincy> glguy : +1
11:47:38 <infinisil> spoonm: Sounds like a good idea
11:51:38 <mupf> oh nice, it's not even that expensive.
11:52:27 <AndreasK> mupf: Everything might be excessive, but qualified imports are often nice for readability
11:52:58 <spoonm> AndreasK: the problem is really that there are too many imports lol
11:53:21 <spoonm> so I'm considering having a few more files instead and importing just a few stuff from those
11:53:32 <doyougnu> mupf: there is also byorgey's intro to Haskell class: https://www.cis.upenn.edu/~cis194/spring13/ It's not a book but might be a useful cross reference for you
11:56:10 <hpc> mupf: cis194 is a good default because it's an actual course, it's a popular recommendation when others come in with similar questions
11:56:29 <AndreasK> spoonm: I mostly find qualified imports more tedious for writing code, I've never had them be an issue for reading/refactoring. Otherwise spliting large files into multiple modules can make things easier as well.
11:58:07 <[exa]> spoonm: if there's a way to split it, do it. Sometimes it's also nice to avoid lots of qualified names by having an extra module that just renames and reexports all the stuff you need.
12:00:24 <meeples> is there some technical reason why cabal is so balls compared to leiningen?
12:00:57 <meeples> why can't haskell have a lein equivalent already?
12:01:16 <doyougnu> meeples: that is why I use stack
12:01:17 <monochrom> Economics. No one is paying.
12:01:29 <doyougnu> its not a perfect replacement, but it's close enough for my purposes
12:02:19 <glguy> meeples: Cabal's new-build functionality is pretty good. If you have a specific question about cabal feel free to ask it, but that kind of open-endeded non-question isn't on-topic
12:08:49 <sclv> Right. If there’s a particular feature you want or need, odds are someone can show a way
12:08:59 <mounty> I've been playing around with Arrows and using the HXT library as a base.  I've come to the conclusion that you can't have mixed tags as peers.  I mean you can't have for example <movement><x>5</x><y>-3</y></movement> because HXT is hard-wired to expect a given tag at a given level.  This is down to xpList I suppose.  I wonder if there's a way round it.
12:09:13 <mounty> In the case above, I'd expect the Haskell datatype to be:  type Movement = Xmove Int | Ymove Int
12:09:21 <mounty> In the game tournament example referenced above, an example might be having PLAYER, CHEERLEADER and COACH tags at the same level under TEAM.
12:09:34 * hackage wai-middleware-travisci 0.1.0 - WAI middleware for authenticating webhook payloads from Travis CI  http://hackage.haskell.org/package/wai-middleware-travisci-0.1.0 (mitchellwrosen)
12:09:51 <mounty> type Member = Player ... | CheerLeader ... | Coach ...
12:09:59 <mounty> s/type/data/
12:28:50 * dmj` loves lmdb
12:50:05 <Bolo2> hi
12:50:14 <spoonm> hello Bolo2
13:03:33 * hackage obdd 0.8.2 - Ordered Reduced Binary Decision Diagrams  http://hackage.haskell.org/package/obdd-0.8.2 (JohannesWaldmann)
13:42:03 * hackage HasBigDecimal 0.1.1 - A library for arbitrary precision decimal numbers.  http://hackage.haskell.org/package/HasBigDecimal-0.1.1 (thma)
14:45:34 * hackage componentm 0.0.0.2 - Monad for allocation and cleanup of application resources  http://hackage.haskell.org/package/componentm-0.0.0.2 (RomanGonzalez)
14:47:16 <srk> A Profunctor is just a bifunctor that is contravariant in the first argument and covariant in the second. What's the problem?
14:47:19 <srk> <3
14:48:15 * srk sunday evenings when hacking code turns into black magic
14:49:02 <maerwald> that's a bad sign
14:49:46 <srk> not really, learning is part of the process
14:51:24 <hpc> srk: i understood that one
14:51:48 <srk> I'm working on it :D
14:52:33 <srk> concurrently reading functional programming with bananas lenses and barbed wire :D
14:52:50 <maerwald> srk: black magic is always bad
14:53:23 <t7> then why have a defence of the dark arts program ?
14:53:25 <srk> maerwald: it's probably obvious after some time :)
14:54:28 <srk> t7: I would rather do profunctors than defensive programming
14:57:43 <srk> https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
14:57:46 <srk> better
15:19:34 * hackage componentm-devel 0.0.0.2 - Easy REPL driven development using ComponentM  http://hackage.haskell.org/package/componentm-devel-0.0.0.2 (RomanGonzalez)
15:37:42 <fatahland> hello i have this function i need to write (https://lpaste.net/6454632480568770560). can you give me a hint what a prerequesite function i need to have to solve the main function here (skips)?
15:38:04 <fatahland> or a clue what should i think about?
15:38:47 <glguy> fatahland: Have you read the problem description yet?
15:39:00 <fatahland> yes of course.
15:39:45 <glguy> You're going to need a function that returns "every nth element from the input list", so write that first then
15:40:10 <fatahland> great. thank you :-)
16:10:02 <phz_> hey peeps
16:10:44 <phz_> is there any lead / material out there about current research and implementation (maybe a GHC extension?) to remove the GC of Haskell and replace it with something else?
16:11:09 <phaazon> I know that the laziness of Haskell would make it fairly impossible but I’m just wondering if people are searching
16:11:29 <phaazon> I especially thought about LinearTypes
16:11:53 <glguy> I wouldn't expect that to be something being seriously researched
16:12:10 <phaazon> glguy: :(
16:12:41 <phaazon> I’ve been doing a looooot of Rust for the past two years and enjoying it but hm, I’d completely stick to Haskell if I could have the same runtime performance / memory footprint
16:12:54 <phaazon> and that would require a tighter control of how the memory is eaten up
16:13:05 <phaazon> I’m not sure people actually care about that in Haskell
16:30:10 <fatahland> glguy: OK i have this function that give me back the n'th element from every list.
16:30:37 <fatahland> all the n'th from specific list of course
16:31:37 <glguy> cool, you're all set then!
16:31:41 <fatahland> but stil how any elemenet from my list's `skips` function, knows in what place he is?
16:34:06 <fatahland> for example: skips [1,2,3,4,5,6,7,8,9,10], how element `3` "knows" he is the third so i could get him and all the rest of the `thirds`?
16:35:19 <glguy> because you wrote skips to keep track of that
16:36:24 <fatahland> yes this is what i need to think of :-)
16:36:53 <fatahland> is there a library function to find n'th element (all of them) in a list?
16:38:27 <glguy> No, you won't need any library functions now, just write skips to use the thing you finished earlier
17:00:42 <int-e> :t (!!)
17:00:55 <int-e> oh.
17:03:05 <int-e> :t (!!)
17:03:14 <lambdabot> [a] -> Int -> a
17:07:23 <benzrf> are the Foldable & Traversable instances for Map guaranteed to be in asc key order
17:14:05 <lyxia> that's a fair assumption to make IMO
17:17:43 <EvanR> !! gets the i-th element... not the n-th element... :)
17:18:20 <EvanR> 7th element vs ... (i=7)th
17:18:54 <int-e> EvanR: huh?
17:19:19 <EvanR> thought you were responding to fatahland
17:19:42 <int-e> EvanR: you're using undefined values there: i and n?
17:19:53 <EvanR> as in the phrase "ith element"
17:20:03 <EvanR> or jth
17:20:10 <int-e> EvanR: I kind of was... but very vaguely.
17:20:25 <EvanR> > [1..] !! 7
17:20:27 <lambdabot>  8
17:20:33 <int-e> EvanR: I don't understand what the difference between "n-th" and "i-th" is supposed to be.
17:20:35 <EvanR> huehuehueh
17:20:56 <EvanR> the 7th element has index 6
17:20:59 <int-e> Yes, we count from zero. Sue the Haskell committee.
17:21:28 <EvanR> in ith its obvious.. unless we get up to where you actually with use a th ending on the actual numberth
17:22:01 <int-e> EvanR: the sad thing is, that if one is golfing that splits function, computing the indices and using !! seems to be the best way.
17:22:28 <EvanR> so i propose that people use ith for 0-base and nth for 1-based ordinal notation
17:22:43 <int-e> EvanR: yeah well, forgive me for not reading your mind
17:22:58 <EvanR> never
17:22:59 <int-e> (no harm done, but my confusion was genuine)
17:23:32 <EvanR> (they are actually using 1-based it looked like)
17:23:39 <int-e> (and I think you're silly)
17:24:13 <int-e> Well, the examples should remove all doubt.
17:26:21 <EvanR> "Hackage, the packages are of variable quality but some of them are pretty good!" -- spj
17:26:25 <int-e> transpose . skips = skips <-- at least this function has one nice property
17:26:43 <int-e> EvanR: high praise :)
17:27:07 <EvanR> as time goes on the more people who shy away from posting their good stuff to hackage, for whatever reason, the more crap is going to take over there
17:27:35 <EvanR> i keep finding haskell projects on github only
17:28:09 <int-e> Let's blame stack.
17:28:11 <glguy> benzrf: That's how the instances are currently implemented, but that behavior isn't guaranteed by the documentation
17:28:32 <EvanR> how is stack invove
17:28:33 <glguy> so it could change, though I can't imagine that it would
17:28:51 <int-e> EvanR: by making it easier to install packages directly from github
17:28:57 <EvanR> oh cool
17:28:59 <EvanR> :)
17:29:06 <int-e> (or so I hear)
17:29:36 <EvanR> that kind of circumvents every problem with hackage
17:29:38 <woodson> Anyone familiar with nix postIntall variable?
17:29:40 <woodson> https://nixos.org/nix/manual/#ssec-values
17:29:50 <woodson> It doesnt seem to say much about it in the manual
17:30:20 <woodson> I just want to know if I can just start writing my script or if it a function that accepts some variable
17:30:43 <glguy> woodson: There's an IRC channel for Nix
17:31:34 <infinisil> woodson: I'll answer the question in #nixos
17:33:20 <int-e> infinisil: I'm running lambdabot btw... while it's really supposed to come back by itself, that fails sometimes. so if it doesn't come back for several minutes, hilighting me may bring it back sooner :)
17:33:59 <benzrf> glguy: :\
17:34:13 <EvanR> you should set up a script for that
17:34:27 <int-e> EvanR: guess why it's usually coming back by itself
17:34:45 <EvanR> int-e bot (cyborg?) to bring back the bot
17:35:10 <int-e> (I made the failing gear a bit more robust now... it was socat (used for SSL) crashing occasionally)
17:35:31 <sm> ops is hard
17:35:39 <EvanR> ive noticed some ssl software we use fail occasionally
17:35:48 <EvanR> whats the deal!
17:36:22 <sm> reliability is hard, I mean
17:36:30 <sm> stupid computers
17:36:42 <int-e> they work amazingly well, all things considered
17:36:51 <int-e> (most of the time)
17:36:58 <sm> ah yeah
17:37:34 <sm> even a bit too well :)
17:37:38 <EvanR> error correcting codes in your error correcting codes
17:44:19 <erisco> hows it
18:21:19 <redrapscallion> what exactly is >> used for? >>= makes sense because the first action's value gets passed to the second, but why would I ever want to use >> since it discards the result produced by the first argument?
18:22:08 <redrapscallion> the haddock docs say it's "like sequencing operators (such as the semicolon) in imperative languages.", but I don't see the connection.
18:22:58 <andreabedini> redrapscallion: maybe you want the first action but you don't need its result? putStr "hello" >> putStr "world"
18:27:07 <redrapscallion> andreabedini: ah, I think I know where my misunderstanding is. I don't know the difference between an "action" and a "result".
18:27:48 <redrapscallion> andreabedini: my understanding is that the "action" only happens because putStrLn returns IO (), and without that, nothing will happen.
18:28:37 <andreabedini> redrapscallion: that's a great place to be! :D
18:28:41 <andreabedini> redrapscallion: consider
18:28:41 <redrapscallion> but if I don't take the result of putStrLn "hello", how does that ever print "hello"? wouldn't that just end up printing "world" if the first IO () gets thrown out?
18:28:42 <andreabedini> :t getLine
18:28:43 <lambdabot> IO String
18:28:57 <andreabedini> :t putStrLn
18:28:58 <lambdabot> String -> IO ()
18:29:34 <andreabedini> I (personally) read the first as "some IO that gives me (or returns) a String"
18:30:02 <andreabedini> and the second as "you give me a string and ""make"" some IO that returns nothing"
18:31:10 <andreabedini> redrapscallion: to answer your question, the >> still combines the two "actions"
18:31:48 <EvanR> redrapscallion: you may be confusing result with "effect"
18:31:52 <andreabedini> so getLine >> putStrLn "hello" still contains the "action" contained in getLine
18:31:56 <EvanR> when you execute actions you get effects and results
18:32:05 <EvanR> >> only gives the effects
18:32:08 <andreabedini> I'm using "action" only within quotes
18:32:26 <glguy> redrapscallion: (x >> y) is short for (x >>= \_ -> y)
18:32:55 <glguy> similarly: (x >> y) is (do _ <- x; y)
18:36:06 <redrapscallion> so what exactly does "effect" mean here?
18:36:27 <redrapscallion> and why do we return IO () in a function if we don't actually need the IO () part? (given that only the "effect" of the IO is important, and not the result)
18:36:34 <byorgey> it depends on the monad.  In the case of IO it means "something gets printed on the screen or read from the keyboard etc."
18:36:43 <glguy> The "throw out" behavior you're describing would be: redsthing _ x = x
18:36:44 <byorgey> redrapscallion: it's the () part we don't need.
18:38:00 <byorgey> when executed, a value of type   IO a   (1) possibly causes some I/O stuff to happen (effect), and (2) returns a value of type 'a' (result)
18:40:58 <redrapscallion> byorgey: so then a type of IO () can either (1) cause some I/O stuff to happen, and (2) return... nothing?
18:41:30 <glguy> Not nothing, a value with type ()
18:41:31 <redrapscallion> but if it returns nothing, then you're saying that even if we returned an IO (), it wouldn't do anything, meaning that it only causes effect?
18:41:53 <geekosaur> wjhat does "do anything" mean here?
18:42:10 <Lears> % do { x <- putStrLn "hello"; print ( x == () ) }
18:42:10 <yahb> Lears: hello; True
18:42:22 <geekosaur> Haskell is about functions that consume and produce values, so you alway have to produce *something*. we use () when thw value doesn;t matter, because something else does
18:42:55 <byorgey> redrapscallion: an  IO ()  returns a value of type ().  But there is only one such value (which is also called () ), so a value of type () is uninformative.  It is like a void function in Java or C.
18:43:37 <byorgey> redrapscallion: so yes, you're exactly right, the only purpose of an  IO ()  value is to cause effects
18:43:50 <byorgey> for example   putStrLn "hello" :: IO ()
18:44:12 <byorgey> it causes "hello" to be printed on the screen, but it does not yield any interesting result
18:44:30 <Axman6> @src ()
18:44:30 <lambdabot> data () = ()
18:58:32 <EvanR> > ()
18:58:34 <lambdabot>  ()
18:58:48 <EvanR> > replicate 3 ()
18:58:50 <lambdabot>  [(),(),()]
19:29:34 * hackage gtk-sni-tray 0.1.3.1 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.3.1 (eyevanmalicesun)
20:01:47 <tian_> :t seq
20:01:48 <lambdabot> a -> b -> b
20:03:16 <tian_> seq is usually introduced to improve performance by avoiding unneeded laziess. how to understand this?
20:03:42 <tian_> from `http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:seq`
20:15:42 <tian_> Got it.
21:08:53 <Alex______> Hi there - any recommendations on a library I can use for making outbound API calls to a REST service?
21:11:26 <jle`> wreq maybe?
21:11:31 <jle`> but it's a little heavy
21:15:19 <Alex______> thanks jle - will check that out
21:15:29 <Axman6> Alex______: servant-client is excellent for modelling an API and then generating the client library for it for free
22:22:04 * hackage dns 3.0.4 - DNS library in Haskell  http://hackage.haskell.org/package/dns-3.0.4 (KazuYamamoto)
22:32:26 <hphuoc25> Hello. I encountered this error while running 'stack ghci --with-ghc intero': attempting to use module ‘main:Prelude’ (./src/Prelude.hs) which is not loaded
22:32:32 <hphuoc25> I'm on mac os, Intero 0.1.31 (GHC 8.2.2), stack 1.7.1
22:32:35 <hphuoc25> Can anyone help?
22:39:17 <beta> I am using  this library http://hackage.haskell.org/package/timers-updatable-0.2.0.2/docs/System-Timer-Updatable.html, for spawning thread I want to know how to kill that thread?
22:39:57 <cocreature> beta: have you looked at https://hackage.haskell.org/package/timers-updatable-0.2.0.2/docs/Control-Concurrent-Killable.html ?
22:40:15 <beta> cocreature: yes
22:40:24 <cocreature> and that doesn’t work for you?
22:40:51 <beta> cocreature: what happens when i kill thread that is already died?
22:41:32 <Axman6> probably nothing
22:41:42 <cocreature> yeah afaik that’s a noop
22:43:07 <beta> cocreature: so it does not throw any exceptions ?
22:43:23 <Axman6> why should it?
22:43:49 <Axman6> beta: also you could try resding the code to see what it does
22:43:51 <cocreature> what would the observable effect of throwing an exception be?
22:44:04 <beta> Axman: ok
22:44:25 <cocreature> reading the code probably entails digging into the GHC rts to figure out how throwTo behaves if a thread has died so I’m not sure that’s particularly helpful here
22:44:27 <beta> cocreature: may be thread not found i guess
22:45:25 <cocreature> beta: the thread still exists. it won’t be garbage collected until there is no reference to the ThreadId
22:45:35 <cocreature> and once there is no reference you can’t throw an exception to it
22:46:10 <beta> cocreature: then that's cool
22:47:40 <beta> cocreature: , Axman6: thanks guys
23:01:23 <woodson> anyone knows how to set the nix postInstall attribute on a reflex project skeleton?
23:01:50 <woodson> No, one seems alive in the reflex irc chat so I am trying here
23:02:15 <Axman6> That's probably becaus ethe authors of reflex at are Yow LambdaJam at the moment running workshops :)
23:02:57 <Axman6> (or, at least I thing ryantrinkle and dalaing are)
23:03:02 <Axman6> think*
23:04:14 <woodson> Well, it sucks that they are the only one that can answer this..
23:04:35 <woodson> I've been beating myself up trying to figure out this thing...
23:06:33 <DaringlyEsoteric> I am considering learning Haskell, but should probably be practicing on my studies instead. Would anyone here like to help me justify putting aside time to learn it without feeling guilty?
23:07:48 <woodson> DaringlyEsoteric: lool, avoid it if you got studies..
23:08:35 <DaringlyEsoteric> awww, at least you're honest
23:08:41 <DaringlyEsoteric> ^woodson
23:10:45 <Axman6> You should learn haskell, but not at the expense of learning you're paying money to do
23:11:39 <DaringlyEsoteric> ah, by studies I meant high school but I was trying to sound fancy haha
23:13:23 <woodson> If you got time go for it
23:13:38 <Axman6> well, do both, just prioritise school over extra curricular learning
23:14:21 <woodson> Axman6, are you familiar with nix?
23:14:28 <Axman6> not really
23:14:42 <woodson> oh man...
23:15:05 <woodson> this past week as really been painful playing with haskell on the frontend
23:17:04 * hackage xmonad-vanessa 0.2.0.1 - Custom xmonad, which builds with stack or cabal.  http://hackage.haskell.org/package/xmonad-vanessa-0.2.0.1 (vmchale)
23:18:09 * dyl shimmies.
23:19:13 <[exa]> DaringlyEsoteric: high schools are that demanding now?
23:20:59 <dyl> DaringlyEsoteric: let me give you my own brand of bad advice.
23:21:20 <dyl> You need to care in a perfectionist sense about your grades only for college applications, and references will ultimately mean far more.
23:21:37 <dyl> It’s better to get a B and spend your time learning about the topic and getting excited about it
23:21:50 <DaringlyEsoteric> [exa] I have ~3 hrs of hw a night rn since finals are in 2 weeks
23:21:53 <dyl> than to get an A and be an exercise driven robot the entire time.
23:22:09 <dyl> In the best classes with the best courses, you won’t have to decide.
23:22:20 <dyl> But in many you will have to choose whether you care about schoolwork or learning.
23:22:31 <Axman6> DaringlyEsoteric: sounds like you should be doing homework instead of IRC then :P
23:22:35 <dyl> ^
23:22:38 <DaringlyEsoteric> ahhahahaha
23:22:39 <DaringlyEsoteric> so true
23:22:56 <dyl> Also: discipline sucks but it is the ur-skill.
23:23:17 <dyl> Doing things you don’t immediately want to do for short term gain and being able to keep the long term goal in mind is critical.
23:23:23 <dyl> It’s easily the hardest skill.
23:23:24 <DaringlyEsoteric> ouch. I was hoping you wouldn't say that since I do most of my work the class before
23:23:30 <dyl> So did I.
23:23:41 <dyl> I did all the way through junior year of college.
23:23:48 <dyl> But it stops working.
23:23:53 <DaringlyEsoteric> yeah
23:23:54 <dyl> You can’t maintain that.
23:23:59 <dyl> As much as you wish you could.
23:24:09 <DaringlyEsoteric> college must have been horrible
23:24:10 <DaringlyEsoteric> yeah
23:24:20 <dyl> College was... a ride.
23:24:23 <dyl> A learning experience.
23:24:31 <[exa]> DaringlyEsoteric: ah finals lol
23:24:35 <dyl> I ended up not getting into any graduate programs after graduating,
23:24:42 <dyl> but after a gap year of research work
23:24:52 <dyl> I’m now heading to UCSD for my PhD :).
23:24:58 <dyl> Sometimes we have to fail to succeed.
23:25:04 <DaringlyEsoteric> [exa] yeah haha. "now that you finished the AP test let's assign random busywork while you get finals in the rest of your classes"
23:25:07 <[exa]> fail early, fail often
23:25:07 <Axman6> Earliest Deadline First is an optimisal scheduling strategy, which allows 100% utilisation of a resource, but it is a very stressful one for humans to maintain and doesnt' do a good job accounting for context switching overhead
23:25:14 <dyl> [exa]: yes!
23:25:21 <dyl> Do I smell an erlanger?
23:25:22 <DaringlyEsoteric> dyl: wow, that's an awesome turn of events!
23:25:23 <dyl> ;)
23:25:38 <dyl> DaringlyEsoteric: I also had an offer from UIUC but it was really weird.
23:25:53 <dyl> Regardless
23:26:16 <dyl> College might be the last safe place you have to fail hard and learn from it.
23:26:25 <[exa]> dyl: how's phd programs at UCSD?
23:26:28 <dyl> Grad school is certainly the last opportunity you have in which you’re protected.
23:26:33 <DaringlyEsoteric> haha yeah
23:26:38 <dyl> [exa]: I’m not there yet.
23:26:40 <DaringlyEsoteric> after that... :/
23:26:53 <dyl> But I got a very good impression from the progsys group.
23:26:59 <dyl> And the design lab.
23:27:04 <[exa]> cool
23:27:22 <dyl> I’m interested in a design oriented user centric approach to PL problems essentially.
23:27:27 <dyl> So it seems a very good fit.
23:27:56 <dyl> Or rather, PL is just the vehicle, what I’m concerned with are design problems that require that to drive them to a solution.
23:28:08 <[exa]> I'm kindof curious how phds work in america (doing one in mid-eastern europe now)
23:28:26 <dyl> The biggest difference is a PhD and a masters are two different paths more or less
23:28:33 <dyl> You don’t need a masters to start a PhD.
23:28:41 <dyl> And it can sometimes hurt you to have one.
23:28:51 <[exa]> yeah that is cool
23:28:54 <dyl> But we have a longer high school/college cycle.
23:29:01 <[exa]> publishing earlier would help the whole thing here a lot
23:29:20 <dyl> I just got my first publication and first authorship out :).
23:29:31 <dyl> Obviously, as a PL/math/design person
23:29:35 <[exa]> great!
23:29:38 <dyl> it was in the Journal of Physical Chemistry
23:29:45 <dyl> ¯\_(ツ)_/¯
23:29:50 <[exa]> almost haskell. :D
23:30:38 <dyl> In my PhD im trying to synthesize what I learned working in design and marketing, the problems I see in the life sciences where I’ve done my research experiences, and the tools I’ve picked up in math and CS.
23:30:54 <dyl> Somehow I’ll make this work, I think there’s a path here that hasn’t been tread enough yet.
23:30:58 <[exa]> in fact life sciences totally need computer people
23:31:03 <dyl> Yes.
23:31:07 <[exa]> (/me doing cheminformatics now as a side job)
23:31:10 <dyl> They’re helpless right now.
23:31:21 <dyl> They depend on the one grad student or postdoc who can program
23:31:38 <dyl> My focus in on tooling for academics in other areas of the sciences.
23:31:50 <dyl> How do we design programming tools for people who aren’t programmers but still have that mindset?
23:31:56 <[exa]> well not totally helpless, but sometimes the people from the other institution here spend 3 days on doing something that would be 2 seconds in bash script
23:32:06 <dyl> That was literally last week.
23:32:17 <dyl> Someone was having this problem organizing files for feeding into a program
23:32:23 <[exa]> anyway, people had success with teaching them R
23:32:36 <dyl> num=1; for file in $(ls | sort --version-sort --field-separator=-); do mv "$file" "$(printf "AuCluster-%05u.tif" $num)"; let num=$num+1; done
23:32:36 <Axman6> "success"
23:32:39 <dyl> ¯\_(ツ)_/¯
23:33:15 <dyl> The big problem I see today is that people in our area assume that if they build a shining utopia on a hill of a language academics will migrate to it.
23:33:17 <dyl> They won’t.
23:33:22 <[exa]> Axman6: it's a limited success but it prevented some people by wasting X days on drawing the plots by hand in photoshop. That's an educational success
23:33:36 <dyl> You need to focus on tooling that guides a learning process while not inconveniencing them.
23:34:04 <dyl> Academics don’t have the patience to spend  two weeks learning to do something “better” even if it has long term benefit.
23:34:05 <[exa]> the best thing I did was teaching them unix
23:34:19 <[exa]> like, "put that in a goddamn text file"
23:34:35 <[exa]> and a bit of cut/paste/awk magic
23:34:58 <Axman6> We definitely need better tooling around the sorts of things scientists do with python and R in Haskell
23:35:08 <dyl> I regularly help someone with some task (on Mac) and end up installing a package manager, zsh, sublime text, etc
23:35:21 <dyl> And then a week later they’re acting like they couldn’t live without these things.
23:35:35 <[exa]> Axman6: no idea if Haskell will be better. They don't do programming, they need the numbers transformed and they need it now.
23:35:39 <dyl> Axman6: you won’t get them using Haskell
23:35:44 <dyl> It’s not that it’s not a good language
23:35:49 <dyl> It’s just not the right language
23:35:58 <dyl> We need to better understand why Python works so well for academics.
23:36:02 <dyl> That means user studies.
23:36:09 <[exa]> Axman6: in fact, making them go away from M$ Word, Excel and GraphPad for doing statistics is 99% of the success
23:36:26 <[exa]> yeah and photoshop for scatterplots.
23:36:29 <dyl> pandas and scipy are much better exit vehicles.
23:36:41 <dyl> Thankfully plenty of academics despise word.
23:36:48 <Axman6> "photoshop for scatterplots" :|
23:36:51 <dyl> But they tend to also be the ones who use latex.
23:37:07 <[exa]> yes, the word-despising community is specific to math/cs
23:37:14 <dyl> And chemistry.
23:37:22 <[exa]> others like the image-positioning orgies
23:37:33 <dyl> The point is that you have to stop trying to shoehorn your favorite solution onto the field.
23:37:42 <dyl> You need to actually shut up, listen, and study what they use and why.
23:37:53 <dyl> That’s something engineers in CS are horrible at it general.
23:37:53 <[exa]> Axman6: anyway, the point is that with developing a scientific package you can not know what the scientist will want to do (that's why he's a scientist)
23:37:56 <dyl> in*
23:38:10 <[exa]> Axman6: and python packages are by far the easiest to take apart and tweak
23:38:13 <dyl> You also can’t waste their time or expect an up front investment.
23:38:28 <dyl> I analogize it to reaction activation energy
23:38:34 <dyl> You can’t expect a large degree of it.
23:38:39 <dyl> The best approach is to build catalysts.
23:38:58 <[exa]> I supply them with one-time-magic scripts
23:39:14 <[exa]> they can usually take it apart and modify if it's already working
23:39:18 <[exa]> learning something on the way
23:39:38 <dyl> That’s another aspect of the problem though
23:39:47 <[exa]> but you can't expect that a postdoc will even _have_ time to spend 1 year in reeducating himself on programming languages
23:39:53 <dyl> Academics will see a script in a supplement of a nature paper
23:39:57 <dyl> And assume it’s good code
23:40:01 <[exa]> (not saying there aren't such cases, but in general they won't)
23:40:02 <dyl> And reproduce the patterns for years
23:40:13 <[exa]> yes. :D
23:40:20 <dyl> I think the best tact right now is non intrusive coding assistants
23:40:34 <dyl> Tools which offer you better approaches at no cost which can be easily ignored
23:40:46 <dyl> But when accepted provide a benefit and train you into better practices
23:40:51 <dyl> You basically need to sneakily yeah.
23:40:54 <dyl> Teach^
23:41:01 <[exa]> yes. :D
23:41:15 <[exa]> I've had a success with a simple makefile last week btw
23:41:29 <dyl> e.g. “you could write it this way, but this way is much nicer and also here’s the benchmark showing this suggestion is much more efficient”
23:41:35 <[exa]> (before there was a grad student who was serving as a makefile)
23:41:43 <dyl> Simple makefiles are incredibly useful in so many places.
23:41:43 <Axman6> There's some work being done here (Data61) on making tooling for python, to initially make things like linters and automatic refactoring
23:42:15 <[exa]> oh science.
23:42:19 <dyl> anyhow, for me: I get the problems from life sciences
23:42:23 <dyl> I get the approach from design
23:42:28 <dyl> And I get the tools from CS/Matt
23:42:30 * [exa] needs to AFK, thanks for discussion anyway :]
23:42:31 <dyl> Math*
23:42:37 <dyl> Cheers!
23:43:07 <dyl> Axman6: but if you just autorefactor the user learns nothing and becomes mystified
23:43:09 <Axman6> Also, I think Bioshake is an awesome example of using haskell to make working with complex systems simpler
23:43:15 <dyl> Toy have to build the user into the cycle
23:43:21 <dyl> Tight feedback loops!
23:43:29 <Axman6> dyl: there's no reason why the refactoring can's also teach the author
23:43:32 <dyl> Encourage the user to do things which make providing better feedback easier.
23:43:42 <dyl> Yes, but you can’t do that when it’s “too automatic”.
23:43:48 <dyl> There has to be an explicit process to it.
23:43:59 <dyl> e.g. suggestion, confirmation, and acknowledgement
23:44:06 <Axman6> and this is common in "fixit" type tools "Hmm, you shouldn't do this because... instead you should do ..., would you like to do that automatically?"
23:44:09 <dyl> You can’t just “ok imma edit your whole file” cool?
23:44:20 <dyl> I don’t think automatic is good here.
23:44:30 <dyl> Automatic risks danger of the user abandoning the tool when you fail
23:44:32 <Axman6> the example that is used in the Data61 work is removing mutable default arguments
23:44:47 <dyl> But can you explain why that’s good to the user tangibly?
23:44:56 <dyl> Or are you just trying to tell them what to do
23:45:05 <dyl> This is the paradox.
23:45:09 <Axman6> yes, of source you can, this is widely done
23:45:13 <dyl> You can’t give the best globs advice
23:45:15 <dyl> Global*
23:45:16 <Axman6> in most languages
23:45:26 <Axman6> course*
23:45:27 <dyl> But will the user you’re targeting understand why it’s good?
23:45:31 <dyl> Do they have that context?
23:45:45 <Axman6> yes, because you will explain it to them...
23:45:48 <Axman6> with the tool
23:45:54 <dyl> And how do you explain it?
23:46:05 <dyl> If it’s in text as an actual explanation, you’ve already lost.
23:46:14 <dyl> It needs to be tangible.
23:46:31 <dyl> It needs to be something they’re focused on, not a distraction.
23:46:35 <dyl> Even if it’s correct.
23:46:36 <Axman6> "Wartning, this thing you are doing is dangerous because X, instead you should do Y: <example>"
23:46:58 <Axman6> I don't think you are giving the users enough credit
23:46:59 <dyl> Wouldn’t showing them an example of how it could fail be better? Even without the warning text?
23:47:06 <dyl> First law of UX
23:47:09 <dyl> Don’t make the user think.
23:47:10 <Axman6> sure, do that then
23:47:18 <dyl> And also I worked in design and marketing for many years
23:47:24 <dyl> You can never give users too little credit.
23:47:28 <dyl> Users are drunk apes.
23:47:35 <Axman6> you'rwe making this out to be a much harder problem that it actually is in most cases
23:47:37 <dyl> You get very very jaded very fast.
23:47:55 <dyl> But the general problem for a defined cohort is the interesting problem
23:48:13 <dyl> You’re making this out to be a much easier problem than it actually is in most useful cases
23:48:34 <dyl> Of course in the end it all comes down to user studies.
23:48:45 <dyl> You can’t hypothesize a better way and then just assume it’s better.
23:48:58 <dyl> You need to actually see how people approach it, why they do so, and iterate.
23:49:33 <Axman6> sure, that's fine, and this is something we do a lot here at Data61
23:49:45 <geekosaur> glad someone still does
23:50:10 <dyl> ^
23:50:17 <dyl> There are different approaches.
23:50:23 <dyl> My approach I term humanistic.
23:50:27 * geekosaur moderately grumpy, this place's mgmt got new software that clearly wasn't tested against anyone's actual needs.
23:50:39 <dyl> I’m concerned with the user first, and working from that.
23:50:50 <dyl> Even if it means ignoring good principles otherwise in some ways.
23:51:04 <Axman6> yep, that's what our (quite large) UX teams does
23:51:06 <dyl> Ultimately if you have to serve users, you need to focus on users.
23:51:09 <dyl> Not ideal users.
23:51:12 <dyl> But real users.
23:51:42 <dyl> The kinds of tooling I want to work on are not so subtly intended to shape real users into being closer to ideal users :).
23:51:52 <dyl> But by making it a benefit to them.
23:51:56 <dyl> Not by telling them “you must”.
23:52:10 <geekosaur> well. sometimes yes, sometimes they actually have reasons for what they do
23:52:21 <dyl> geekosaur: they always have reasons for what they do.
23:52:37 <dyl> The trick is figuring out what they are and how you can turn those reasons into the basis for better habits.
23:52:43 <dyl> Without interrupting their workflows too much.
23:52:44 <Axman6> often that reason is "Because I don't actually know what I'm doing but I saw someone do this once"
23:52:54 <dyl> Often? 90% of the time :p
23:53:04 <dyl> That’s the biggest problem in academia.
23:53:04 <Axman6> exactly
23:53:06 <dyl> By far.
23:53:06 <geekosaur> often yes, sometimes it's because there's something going on that nobody realized
23:53:22 <dyl> And *they may not want to be told outright*
23:53:35 <dyl> If you explicitly tell a user what they’re doing is wrong, you’ve lost.
23:53:43 <dyl> You can only suggest a better way.
23:53:53 <dyl> We like negative feedback tools.
23:53:57 <dyl> But most users don’t.
23:54:51 <dyl> You have to condition the user to learn that your tools will provide them benefit
23:55:00 <dyl> and not frustrate them or put up obstacles along the way.
23:55:18 <dyl> And one interesting approach here is to provide different feedback based on how the user uses the tools
23:55:30 <Axman6> )Someone I know recently spent some time working on a tool which was widely used in a certain industry as a standard modeling tool. I was recently open sourced and it was clear it was written by developers who were used to MATLAB and not C++, and chad copied over many idioms, such as indexing arrays using arr[x,y], which cause the results at worst to be completely invalid. Good tooling (like, even just using -Wall) would have helped them a lo
23:55:31 <Axman6> t
23:55:35 <dyl> You can be more liberal or lax with the feedback you are willing to give once someone is clearly trusting the tool
23:55:40 <dyl> You have to be more careful early on
23:56:26 <dyl> Most academics will just turn off -Wall
23:56:31 <dyl> And then complain when it breaks.
23:56:37 <dyl> And completely ignore the warning feedback.
23:56:48 <dyl> Even if it solves the problem.
23:56:51 <johnw> how can anyone know what most academics do?
23:56:51 <dyl> Users are not rational.
23:57:14 <dyl> I can’t know what most will do, but I’ve spend years working in the life sciences and have a pretty good idea of the patterns of dysfunction.
23:57:21 <dyl> That’s why I’m focused on this area.
23:57:27 <dyl> Data scientists have their own issues.
23:57:35 <dyl> Bioinformatics is fuuuuuuucked.
23:57:44 <dyl> But they have new blood coming in that will help.
23:58:19 <Axman6> ri make bioiunformatics  less fucked, look at https://github.com/PapenfussLab/bioshake
23:58:23 <Axman6> ri make bioiunformatics  less fucked, look at https://github.com/PapenfussLab/bioshake
23:58:25 <Axman6> uh
23:58:33 <geekosaur> another point I'm trying to make is that you can run into things like someone does the "not optimal" thing because the "optimal" one causes e.g. working memory glitches that slow them down in other ways. (yes, this happens, at least in business office contexts where I've worked) global UX sometimes means looking beyond the data entry screen
23:58:56 <dyl> geekosaur absolutely
23:58:57 <Axman6> and also https://www.youtube.com/watch?v=lu90p7EWXJE&amp;index=6
23:59:08 <dyl> That’s why I think explanatory messaging is relatively useless alone
23:59:25 <geekosaur> and there's a hidden gotcha there because, well, how many geeks are ont he spectrum? which *changes that*
23:59:27 <dyl> Better to provide “hey here’s how your code performs and here’s how this suggested refactoring performs”
23:59:35 <dyl> Let them pretend they’re making the decision.
23:59:42 <geekosaur> no
23:59:45 <dyl> Let them take ownership over the refactoring
23:59:57 <dyl> Most cases can be mocked and simulated pretty easily.
