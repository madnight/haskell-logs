00:04:44 <iqubic> HLint is such a good code checker.
00:04:52 <iqubic> myMap f = foldr (\x rest -> f x : rest) []
00:05:22 <iqubic> And it suggests "map (\x -> f x)"
00:05:41 <johnw> and that's just map f
00:05:54 <iqubic> I know.
00:06:09 <iqubic> But I'm learning how to use foldr, so this is good practice.
00:08:30 <iqubic> I wish ertes was here so I could praise him for the excellent work he's done on this fold tutorial.
00:13:40 <iqubic> Why is concatMap so hard to write with a single foldr?
00:13:50 <iqubic> Is that even possible?
00:16:16 <cocreature> depends on what you mean by a single “foldr”. if you take (++) as a primitive it’s quite easy
00:17:07 <iqubic> really?
00:17:40 <iqubic> I actually wrote (++) as a foldr function because that's one of the things ertes showed in hsi tutorial.
00:17:45 <iqubic> http://ertes.eu/tutorial/foldr.html
00:18:09 <ddellacosta> iqubic: I just hacked this together: concatMap' f = foldr (\a b -> (f a) ++ b) []
00:18:19 <ddellacosta> probably better ways to write it
00:18:22 <iqubic> Yeah, that looks right.
00:18:46 <iqubic> I'm working on a list join using foldr and (++)
00:19:27 <iqubic> myFlatten = foldr (\x rest -> x ++ rest) []
00:19:31 <iqubic> That's what I have.
00:19:45 <iqubic> If I want I can replace (++) with:
00:19:51 <iqubic> myAppend xs ys = foldr (:) ys xs
00:19:56 <iqubic> But I don't really care.
00:20:57 <iqubic> Oh, wait:
00:21:10 <iqubic> myFlatten = foldr (++) []
00:23:34 <iqubic> Well it feels good to just have the proper intuition to just be able to write this in one fluid motion:
00:23:36 <iqubic> myFilter p = foldr (\x rest -> if p x then x : rest else rest) []
00:24:38 <ddellacosta> folds are a great example of something that seems intimidating before you spend some time with it, then it feels like second nature, and also seems so obvious in some sense...and they are so integral to so many topics
00:24:55 <iqubic> yeah. I totally get you.
00:25:06 <iqubic> Now, time to talk about stateful folds.
00:25:18 <iqubic> Things like sum and product and take.
00:26:08 <ddellacosta> iqubic: all of those seem like they can be generalized by e.g. foldMap
00:26:30 <ddellacosta> well, not sure how take fits in there tbh
00:26:34 <iqubic> All of what do? My fold functions.
00:26:46 <iqubic> ddellacosta: Ertes' guide mentions it.
00:26:48 <ddellacosta> I mean, sum, product, concatMap for that matter
00:26:50 <ddellacosta> ah okay
00:27:40 <iqubic> Oh, I see.
00:28:13 <ddellacosta> it's funny because as you've been going through that I've been trying to wrap my head around lens, and it is like a generalization of all of this yet again...or at least, seems like it based on the small amount I've been able to grasp so far
00:28:51 <cocreature> not sure calling lens a generalization of folds really makes sense
00:28:58 <iqubic> lens is great. I understand lens a lot better.
00:29:09 <ddellacosta> cocreature: yeah you're right, I guess it's more because I was working on traverse and there was overlap there
00:29:39 <iqubic> I really enjoyed "lens over tea a lot"
00:29:42 <ddellacosta> probably more correct to call it a generalization/expansino of function composition (?)
00:29:49 <ddellacosta> expansion*
00:30:00 <ddellacosta> iqubic: what's that, got a link?
00:30:26 <cocreature> calling it a generalization of Traversable is definitely appropriate
00:30:39 <cocreature> ddellacosta: https://artyom.me/lens-over-tea-1
00:30:47 <ddellacosta> nice, thanks cocreature
00:31:10 <iqubic> What is with the disclaimer at the top of the page?
00:31:26 <iqubic> This site was last updated on May 21, 2018 under intriguing and mysterious circumstances. If you're unsure whether I'm alive (or at least have internet), see my Last.FM.
00:31:38 <ddellacosta> I've been banging my head against https://github.com/ekmett/lens/wiki/Derivation and I'm finding it slow going, so it's nice to have other resources
00:31:47 <ddellacosta> iqubic: yeah weird
00:32:01 <ddellacosta> maybe just an automated thing tho
00:32:28 <iqubic> Perhaps. But the date is today.
00:33:50 <ddellacosta> ¯\_(ツ)_/¯
00:34:14 <dminuoso> ddellacosta: There's an interesting technique to discovering some of the lens concepts yourself if you want to solve a few directed homework assignments.
00:34:25 <ddellacosta> dminuoso: do tell!
00:34:47 <iqubic> dminuoso: I actually remember doing those exercises last december.
00:35:07 <ddellacosta> dminuoso: I've been coming at it completely backwards, actually, via Comonads...I would _not_ recommend this (accidental, mostly) approach
00:35:11 <dminuoso> ddellacosta: `data V3 = V3 !Int !Int !Int` take this type, and write a Traversable instance for it. That's just step 1.
00:35:21 <dminuoso> iqubic: Incidentally it was ertes who taught me lenses this way. ;)
00:35:47 <iqubic> Oh.. I see. Sadly he is gone. He was a great teacher to us all.
00:36:02 <ddellacosta> dminuoso: cool I'll give it a shot...is there no web page that lays this all out? Not that I'm complaining, any help is most appreciated
00:36:05 <ddellacosta> wait really?
00:36:11 <ddellacosta> he passed away? That's sad
00:36:13 <dminuoso> ddellacosta: It's just 2-3 steps so its kind of quick. :)
00:36:18 <tsahyt> I just read byorgey's post
00:36:48 <tsahyt> so I guess I'll chime in here for a second and say that ertes was the person who finally made me understand FRP
00:36:59 <ddellacosta> dminuoso: okay I've got half an hour-ish, let's see how far I can get :-D
00:37:35 <dminuoso> ddellacosta: Once you have done that, write a function `traverseX` that only acts on the first component of V3 in the same sense as `traverse`.
00:38:45 <ddellacosta> for anyone else who didn't know about ertes: https://byorgey.wordpress.com/2018/05/21/ertugrul-soylemez-1985-2018/
00:38:51 <ddellacosta> thanks dminuoso, will try that next
00:38:57 <iqubic> TraverseX should run the function f on just the first component of the V3 and id on the other 2
00:39:09 <ddellacosta> shh don't give me any hints
00:39:10 <jle`> tsahyt: same
00:39:31 <jle`> iqubic: not quite id
00:40:27 <systemfault> Oh shit :( RIP Ertes.
00:42:10 <jesyspa> dminuoso: About the exercise; doesn't Traversable take a * -> *, while your V3 is *?
00:42:18 <ddellacosta> yeah I'm stumbling over that now
00:42:20 <dminuoso> jesyspa: Oh indeed my bad!
00:42:27 <dminuoso> ddellacosta: `data V3 a = V3 !a !a !a`
00:42:37 <jesyspa> Ah, okay :)
00:42:42 <ddellacosta> right, okay, was starting to do that--thanks!
00:43:39 <dminuoso> ddellacosta: You can derive Functor/Traverasble using DeriveFunctor and DeriveTraversable if you want, or you can just write them out yourself.
00:43:41 * ddellacosta cheats and drops {-# LANGUAGE DeriveFunctor #-} to the top of the file
00:43:44 <ddellacosta> haha, jinx
00:43:49 <dminuoso> Errr *DeriveFoldable :P
00:43:51 <dminuoso> Haha
00:44:00 <iqubic> ddellacosta: That's totally fine.
00:44:03 <ddellacosta> I'll do the work for Foldable at least, I can use the practice
00:44:35 <dminuoso> ddellacosta: I did the same until the work felt completely mechanical and mindnumbing.
00:44:45 <ddellacosta> yeah, I can see that
00:44:51 <ddellacosta> I'm not quite there yet, but soon
00:46:59 <ddellacosta> okay nevermind that was boring, haha
00:47:10 <ddellacosta> I mean, the Foldable instance
00:47:47 <jesyspa> I must be missing something, because the traversable instance doesn't look very difficult...
00:48:12 <dminuoso> jesyspa: It's not difficult. ;)
00:48:23 <dminuoso> jesyspa: The key is actually figuring out traverseX with a suitable type signature.
00:48:42 <jesyspa> Ah, okay :)
00:49:17 <iqubic> I know the type signature, but I'm not giving it away.
00:50:06 <ddellacosta> jesyspa, dminuoso: yeah it's just liftA3 isn't it?
00:50:17 <ddellacosta> on to traverseX
00:50:37 <dminuoso> ddellacosta: Can you gist what you have?
00:50:45 <ddellacosta> dminuoso: sure one sec
00:52:20 <ddellacosta> dminuoso: haven't nailed down traverseX yet but here's it so far: https://lpaste.net/8624581659385135104
00:52:47 <dminuoso> ddellacosta: It might be helpful to rewrite traverse in terms of just <*>
00:52:48 <ddellacosta> I'm trying to wrap my head around what that type signature will look like
00:52:53 <ddellacosta> dminuoso: oh, okay
00:54:30 <ddellacosta> ugh, I have to get going--I'll have to get back to this later. thanks all for your help and dminuoso especially for the suggestion. Do you mind if I ping you later for the next part?
00:54:48 <dminuoso> ddellacosta: Absolutely.
00:54:55 <ddellacosta> great, thanks!
00:54:58 * ddellacosta waves
01:03:44 <cheater> hi
01:03:50 <cheater> why does Integral require Real?
01:04:23 <cocreature> cheater: because if you can implement toInteger you can certainly also implement toRational
01:06:36 <cheater> ok
01:17:17 <halogenandtoast> I can't seem to figure out why this is an m PostgresConf instead of a PostgresConf, does anyone have any pointers: https://gist.github.com/halogenandtoast/5d39b3216541915d760e979fc07d94c6
01:18:42 <halogenandtoast> I assumed using the do syntax inside of a function that returns a Parser, which is a MonadFail, should strip that off.
01:18:43 <jaspervdj> halogenandtoast: Look at fromDatabaseUrl's signature
01:19:17 <jaspervdj> You essentially want a two-step there:
01:19:19 <halogenandtoast> Right, but when I call it I'm using do syntax in a MonadFail context.
01:19:39 <halogenandtoast> listening, because I know I'm wrong some how
01:19:40 <jaspervdj> appDatabaseUrl <- o .: "database-pool-size" <*> o .: "database-url"
01:19:58 <cocreature> halogenandtoast: but you’re fmapping it
01:20:00 <jaspervdj> appDatabaseConf <- fromDatabaseUrl appDatabaseUrl
01:20:24 <cocreature> fromDataBaseUrl <$> … <*> … is of type "m (m0 …)"
01:21:50 <halogenandtoast> so should I just use =<< instead here
01:22:23 <jaspervdj> Yep `=<<` would do the trick
01:23:05 <cocreature> or something like "join (liftA2 fromDatabaseUrl … …)"
01:26:32 <halogenandtoast> I'll play with this to see if I can figure it out.
01:26:34 <cheater> thanks cocreature that helped me
01:26:41 <cheater> is there a standard function that's (a -> b) -> (a, a) -> (b, b)?
01:26:43 <halogenandtoast> thanks for the help
01:27:27 <jesyspa> bimap, I think?
01:27:30 <cocreature> cheater: not directly but you can use something like "\f -> bimap f f"
01:27:46 <cocreature> or if you want to codegolf (which I don’t recommend) "join bimap"
01:28:20 <jesyspa> There's probably also some lens l so that over l behaves this way.
01:28:39 <cocreature> yeah "both" but depending on lens just for that is somewhat silly
01:28:55 <cocreature> and "over both f" isn’t really shorter than "bimap f f"
01:29:04 <jchia1> ertes is gone? https://byorgey.wordpress.com/2018/05/21/ertugrul-soylemez-1985-2018/
01:29:16 <jaspervdj> Control.Arrow gives you "\f -> f *** f" (but I also prefer the bimap version)
01:29:26 <jle`> jchia1: yes, sadly
01:29:36 <jle`> :(
01:29:46 <jchia1> RIP. I'm sad. I was just chatting with him several days ago.
01:30:42 <cocreature> I still haven’t fully grasped that he’s gone. I keep waiting for him to join some discussion here :(
01:30:58 <jchia1> I'm the same. So unexpected.
01:31:30 <ventonegro> That sucks indeed
01:33:18 <iqubic> Do we know why he died?
01:39:42 <Ariakenom> I think I heard something about some heart issues but I'm not sure.
01:54:52 <tdammers> terribly young if you ask me
01:57:20 <iqubic> 33 by my calculations
01:59:03 * hackage expiring-containers 0.2 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.2 (OShev)
02:06:23 <johnw> my logs show him speaking in this channel just a short while ago
02:06:38 <johnw> (whether days or weeks, I cannot tell from the timestamps)
02:09:09 <jle`> my logs have him last talking on may 11th, making a joke in a discussion i was in actually
02:09:23 <merijn> oh damn, he was around pretty much my entire Haskell carreer
02:09:52 <johnw> yeah, all of mine so far too
02:11:30 <iqubic> jle`: The offical logs show that he was last seen a day before he was around a day before he passed.
02:12:16 <kuribas> ouch, that sucks
02:13:48 <kuribas> so young
02:18:40 <cheater> cocreature: thanks
02:20:25 <gama> when to use runChanLoggingT over runFileLoggingT from https://hackage.haskell.org/package/monad-logger-0.3.28.5/docs/Control-Monad-Logger.html#t:MonadLogger
02:21:50 <merijn> gama: That just lets you log to a Chan which you can then process in a separate thread
02:22:35 <gama> merijn : which is recommended?
02:22:51 <merijn> It Depends (TM)
02:23:12 <gama> merijn : TM means?
02:23:15 <merijn> They are for separate use-cases and we can't decide which one is best for your code
02:24:28 <gama> merijn :  for logging in file?
02:29:28 <Ariakenom> gama: runFileLoggingT seems appropriate, no?
02:30:05 <gama> Ariakenom : ok
02:30:14 <gama> merijn :  Ariakenom : thanks
02:34:50 <dpyro> If i have a f ::  ClientM [Order] is there anyway to access that ClientM such that i can f = do g 123 where g :: Int -> ClientM [Order] or does this make no sense at all?
02:38:13 <cocreature> dpyro: sorry, I don’t understand the question. you already have f but now you want to redefine it in terms of g?
02:38:28 <zyla[m]> dpyro: What do you mean by "access that ClientM"? The code you posted (`f = g 123`) should work just fine.
02:40:17 <quicksilver> mm_freak :(
02:42:38 <dpyro> i'm using servant client generics which does some magic (to me) generic stuff to turn data MyClient = MyClient { f :: ClientM Int, g :: ClientM String } etc. into `c = mkClient; MyClient {..} = c`
02:43:12 <dpyro> I don't actually understand what's going on there, i understand the record wildcards usage but i dont know how you can do that in a let block
02:43:18 <dpyro> (its let c = ...)
02:45:01 <alp> dpyro, every definition in a let can just use all sorts of patterns just like with toplevel definitions
02:45:05 <quicksilver> no reason why you can't put that in a let block
02:45:11 <quicksilver> unless you made a syntax error
02:45:13 <alp> let Just a = Just 10
02:45:18 <alp> for example
02:47:07 <jle`> quicksilver: :(
02:48:15 <dpyro> when I do that alp, i can use f in that scope and nested scopes but what I can't seem to do is define a customF :: ClientM Int
02:48:27 <dpyro> it has to be customF :: MyClient -> ClientM Int
02:48:58 <dpyro> if its not in that initial data {} then there's no "implicit" MyClient parameter
02:49:09 <dpyro> and it has to be done explicitly
02:49:34 <dpyro> implicit parameters dont seem like a haskell thing to do so i'm pretty sure i'm missing something
02:51:35 <zyla[m]> dpyro: Nothing is implicit here. `let MyClient{..} = something` is binding the names `f` and `g` in the scope of the let. There they have a different type than the record selector - they lack the initial `MyClient` argument
02:51:50 <merijn> jle`: Does anyone know what happened?
02:52:07 <alp> dpyro, yeah I see what you mean. but why not just do: MyClient {..} = mkClient ?
02:52:13 <zyla[m]> And the global `f` and `g` get shadowed
02:53:17 <tdammers> one gotcha with pattern-matching in lets is that it's easy to write partial expressions
02:53:34 * hackage tintin 1.0.3 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.0.3 (NickSeagull)
02:53:39 <tdammers> > let Just a = Nothing in (a :: String)
02:53:41 <lambdabot>  "*Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Ju...
02:53:59 <dpyro> alp: because to do a customF it seems that i have to do something like customF MyClient{..} = -- do something with f here
02:54:42 <dpyro> and customF :: MyClient -> ClientM Int so I need to pass that c into invoking customF
02:55:35 <zyla[m]> tdammers: -Werror=incomplete-uni-patterns should prevent that
02:55:39 <alp> what's customF here? a field?
02:56:16 <dpyro> a function written outside the MyClient datatype that the MyClient bindings to do something more complicated on top of it
02:56:24 <dpyro> *that uses the
02:58:55 <alp> I don't follow.
02:59:00 <alp> could you paste your code?
02:59:08 <alp> or did you? I might have missed it.
02:59:48 <cocreature> merijn: iirc someone mentioned that it was something heart-related
03:02:23 <merijn> cocreature: Damn, that's unlucky at his age
03:03:28 <cocreature> merijn: yeah it sucks :(
03:05:06 <Ariakenom> If I'm your source 1h ago then I'll point out that I just thought I heard something.
03:06:21 <cocreature> no someone else mentioned that a few days ago iirc
03:15:10 <dpyro> apologies alp, i think just talking it out with you guys gave me enough insight to figure out what i needed to figure out ☺️
03:26:52 <jle`> merijn: byorgey's blog post is the only information i have
03:29:12 <alp> dpyro, no worries, as long as you figured it out :)
03:30:27 <sras> What is a good place to ask for a review of a tutorial/introduction to FP and Haskell that I am writing?
03:31:03 <electrocat> sras: this is a good place :p
03:31:20 <electrocat> or reddit maybe
03:31:30 <jle`> this is good, but you can also post a RFC on reddit
03:34:38 <danilo2> Hi guys! Imagine you want to create the fastest possible implementation of a mutable graph in Haskell (nodes pointing to nodes, every node has Haskell data (numbers, arrays, sets) and edges also have data attached). What would be your approach? Asking out of curiosity - weve implemented it using storable and raw pointer machinery, but its ugly and not very haskellish
03:34:39 <sras> electrocat: Yes. good to know.  I didn't post to reddit as it still a work in progress, and I just want feed back on the direction it is going.  I ll post the link here now.
03:37:17 <Cale> danilo2: "Fastest possible" is probably not compatible with "not ugly"
03:38:50 <Cale> danilo2: Usually if I'm representing graphs, I just use stuff somewhat like  Map Vertex (Set Vertex), but this only performs reasonably well, and perhaps not as fast as you need.
03:39:23 <Cale> (There are lots of obvious variations on types like that if you want to include more labels)
03:39:47 <danilo2> Cale: Ok, they can be ugly. Its ok for me to work in IO monad the whole time. I've got basically two problems here: 1. When I Haskell data structure is Storable, then having a pointer to it I cannot access a signle field out of it without deserializing the whole structure, which is inefficient. Thats why we do not store such structures but we type-level track where their fields are. But Im looking if anything better exists.
03:39:51 <cocreature> talking about “fastest possible implementation” without including the operations you want to perform on the graph doesn’t get you very far
03:40:22 <danilo2> Cale: Another problem is that we attach CPP sets to our nodes (to keep the list of successors), but again, converting CPP sets to any haskell representation (like allowing iteration over it) is suboptimal
03:40:56 <electrocat> danilo2: why make it storable at all?
03:41:48 <danilo2> cocreature: sure! I want the following operrations: add / delete nodes, connecting nodes, reconnecting them. Every node is one of few constructors of a data type and it contains references to edges. Each edge has pointers to src and tgt nodes. Every node has also some data attached (like special edge to other node defining its type, etc).
03:42:37 <danilo2> cocreature: other operations are: traversing the graph, reconnecting nodes, removing them, making a fast copy-paste of some part of the graph inside the same graph, serializing the graph to disk and de serialzing it
03:43:43 <danilo2> electrocat: because when using storable and raw pointers we were able to create graphs where we are able to create 1M of nodes in much less than a second, while IORefs or ekmett's structs package performed MUCH worse (in case of IORefs it was almost 5-10 times slower)
03:44:14 <electrocat> danilo2: yeah making that many refs makes the GC suffer
03:45:30 <danilo2> electrocat: we need to operate on graphs of size of few millions of nodes , addign and removing them as fast as possible. So we ended on having our own memory manager in C nad creating a node is basicaly a memcpy with pre-cached layers initial data. Thats why we use storable, but the problems I described above are still here and I trully hate them
03:46:26 <cocreature> danilo2: alright that’s a pretty decent description of the mutations that you want to apply to the graph but you probably also want to inspect the graph in some way (otherwise why store it in the first place). the right data structure depends on what kind of analyses you are using, the ratio of analyses to mutations, whether mutations arive in batches or not, …
03:46:33 <bwe> How do I import data constructors correctly? https://lpaste.net/665753715092750336
03:47:02 <bwe> I find it strange that in the same ghci session I can use the data constructor, here `Person`. How can I bring it in scope of qy.hs?
03:47:53 <danilo2> cocreature: the graph is internal of a compiler. its an IR of a language. So we are making a lot of different modifications. On the begignning we are expanding nodes to other forms (after parsing and analysis we are expanding them to some kind of CORE subset) then we are evaluating and typecheckign based on the graph
03:48:16 <merijn> bwe: "import Foo (Person(Person))"
03:48:23 <danilo2> cocreature: so in the first stage we are massively remving and adding new nodes. Then we are mostly traersing, finding patterns and removing more than adding
03:48:48 <merijn> bwe: "import Foo (Person)" imports the *type* Person, but not the constructor. Alternatively, "import Foo (MyType(..))" imports all constructors for MyType
03:51:07 <electrocat> danilo2: so your IR is cyclic?
03:51:10 <merijn> danilo2: You can access a single field with some boilerplate code, though
03:51:47 <merijn> danilo2: If you know the offset of the field relative to the root pointer, nothing stops you from just manipulating the pointer directly and accessing the field directly
03:52:38 <merijn> danilo2: Also, is any of thise code public, because I'd be very interested to see it
03:52:55 <danilo2> electrocat: it is. First, nodes are data structures that have links to other nodes. But each node has also set of its successors, so yo ucan easily replace a node and reconnect edges. Mroeover we've got also edges telling us where some expressions came from, which aslo make cycles. However, we knwo exactly where these cycles. Types also have cycles, but only on the end, like type of "Type" is this type itself. But e precisely know w
03:52:57 <merijn> danilo2: And somewhat relatedly, are you storing graphs on disk and if so, what format are you using for that?
03:53:18 <kuribas> I also wonder if anyone knows about Gracjan Polak (the maintainer of haskell-mode)?
03:53:27 <kuribas> He stopped contributing since september last year.
03:53:27 <danilo2> electrocat: so removing nodes is very efficinet here - we know that part of a graph is no longer needed and we traverse it, knowing where not to look in order not to be cycled
03:53:45 <electrocat> i would also be very interested in seeing this :D
03:54:30 <merijn> danilo2: And thirdly, what kinda stuff are you guys doing with graphs?
03:55:16 <danilo2> merijn: we are already doing it. We tag graphs with type level description of types that we stroe there, so you can for example tell that your nodes have '[X,Y,Z] data attached. We stroe internally pointer offsets, pre compute it during compilation time, store it in a state in a tuple, so worker pattern in GHC can completely unbox it and we've got a nice monadic api to access these layers (we've got the same perofmrance as C ptr der
03:55:57 <danilo2> merijn: code is public, take a look here: https://github.com/luna/luna-core/tree/static-layers   (branch static-layers)
03:56:19 <danilo2> merijn: especially see this: https://github.com/luna/luna-core/blob/static-layers/core/test/spec/Luna/Test/Spec/IRSpec.hs
03:56:22 <bwe> merijn: Thanks!
03:56:45 <danilo2> merijn: we are doing our graph compiler, type inferencer and interpreter for Luna: http://luna-lang.org
04:01:49 <merijn> danilo2: Ah, so I guess you're just serialising code and building the graph at runtime, rather than storing the graph on disk
04:02:51 <danilo2> merijn: we are storing on disk "pre-compiled" IR. Something like function specialization etc
04:03:18 <danilo2> merijn: but we also store in-memory graph serialization sometimes in order to paste it into the graph - its useful for exampling when "inlining" functions
04:07:46 <AWizzArd> In the Hspec docs I see this for auto discovery:   {-# OPTIONS_GHC -F -pgmF hspec-discover #-}
04:08:01 <AWizzArd> What are the `-F` and `-pgmF` options?
04:08:34 <merijn> AWizzArd: Seems like that would be answered by having a look at the GHC user guide? :)
04:09:58 <cocreature> merijn: don’t you know that reading docs is only for old people? :)
04:10:19 <AWizzArd> merijn: I have it open but didn’t find it and thought that maybe somebody here may know this by heart.
04:11:09 <merijn> AWizzArd: There's a flag reference section which lists all GHC flags
04:11:12 <cocreature> AWizzArd: the user guide has a search box on the right that you can use to find things https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/search.html?q=pgmf&check_keywords=yes&area=default
04:12:01 <AWizzArd> Great, that helped, thx.
04:12:05 <AWizzArd> I am getting the error when trying `stack test` that  output was redirected with -o, but no output will be generated because there is no Main module.
04:25:32 <cheater> hi
04:25:49 <cheater> can someone help me figure out why this is taking so extremely long to compute? https://lpaste.net/6557071818560110592
04:27:02 <Cale> cheater: btw, uncurry f <$> zip xs ys = zipWith f xs ys
04:27:41 <tdammers> cheater: 3-second glance says 1. lists might not be the best data structure for this, and 2. see if you're suffering from excessive laziness
04:28:10 <Cale> Yeah, I'm suspicious of this summation that's going on...
04:29:50 <cocreature> that looks like a foldl' on an unboxed vector might be a better choice than a foldr on lists
04:30:24 <cheater> hmm
04:30:36 <cheater> a vector of 22050 ints?
04:30:38 <Cale> addLists is pretty expensive, it computes the length of both lists, and it's used recursively in firstPeakOnly
04:30:40 <cocreature> although that will still allocate new vectors so you could even consider going for a mutable vector
04:30:52 <cheater> Cale: agreed
04:31:02 <merijn> cheater: 22k ints isn't that much memory, tbh
04:31:14 <quicksilver> 640k should be enough for anyone
04:31:16 <cheater> Cale: i just wanted something like "zip while padding to the longer one"
04:31:17 <merijn> > 22050 * 8 /1024.
04:31:20 <lambdabot>  <hint>:1:17: error:
04:31:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:31:23 <merijn> > 22050 * 8 /1024.0
04:31:25 <lambdabot>  172.265625
04:31:42 <merijn> cheater: Looks like 172 KB, if we assume 64bit ints in an unboxed vector
04:31:51 <cheater> merijn: now multiply that by 22050.
04:31:54 <merijn> cheater: Hardly the sort of memory consumption you'd worry about
04:31:56 <Ariakenom> on topic, is there some easy to use haskell profiling?
04:32:11 <Cale> :t alignWith (mergeThese (+))
04:32:13 <lambdabot> error:
04:32:13 <lambdabot>     Variable not in scope: alignWith :: t0 -> t
04:32:13 <lambdabot> error:
04:32:18 <Cale> aww, no these
04:32:23 <merijn> cheater: I already multiplied by 22050? Or do you mean you have 22k vectors of 22k integers?
04:32:24 <phadej> these is not Safe :/
04:32:42 <merijn> Ariakenom: GHC has profiling support built-in
04:32:50 <merijn> Ariakenom: Have a look at the user's guide chapter on it
04:32:51 <cheater> merijn: yeah, because you're summing them, right?
04:32:58 <phadej> (well, that's technicality which can be solved, but would be coold to have these in lambdabot)
04:33:01 <Cale> Ariakenom: Yeah, ghc has lots of profiling stuff
04:33:05 <merijn> cheater: I didn't look at the code, tbh
04:33:07 <Ariakenom> merijn: but it's not the first thing suggested?
04:33:10 <cheater> also.. i might want to carry the summation together, i guess
04:33:13 <Cale> http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
04:33:19 <cheater> rather than sum on every recursive step
04:33:23 <cheater> i guess that's really expensive
04:33:51 <merijn> Ariakenom: Well, it depends, 5 minutes of thinking can sometimes easily defeat an hour's worth of measuring and benchmarking :)
04:34:02 <taktoa> anyone know why there's no "Minimal complete definition" in the generated Haddock for this typeclass, even though I have `{-# MINIMAL (merge | mergeMany) #-}` in the definition? https://i.imgur.com/ymgLwEU.png
04:34:05 <Cale> However, time profiling has been a lot less useful ever since they did the change to the way that cost centre stacks are treated
04:34:22 <merijn> Ariakenom: Especially if, like a bunch of people here, you have a pretty good understanding of how GHC generates code and optimises
04:34:42 <taktoa> code can be seen here https://github.com/taktoa/eqsat/blob/master/library/EqSat/TermIndex/Class.hs#L483-L553
04:34:46 <merijn> Ariakenom: i.e. non-strict summations are always easy suspects for optimisation
04:35:23 <phadej> hmm, there is lightweight heap profiling using +RTS -T
04:35:51 <phadej> hmm, there is lightweight heap profiling using +RTS -T -h
04:35:56 <Ariakenom> merijn: I'd hope for a few minutes to profile and not an hour
04:36:08 <phadej> don't need to turn --profiling
04:36:27 <merijn> Ariakenom: Depends on your problem, etc.
04:37:05 <cocreature> is there a way to demote a lens "Traversal s t a b" to a "Fold s a"? it seems like it should be possible to deal with the fact that the types change if all you need is a fold but I can’t find anything for this
04:37:05 <phadej> (and from heap profile you an spot e.g. space leaks which cause things to go slow)
04:37:14 <Cale> Ariakenom: Well, it doesn't take an hour to profile, it might take an hour to decipher the results.
04:37:35 <cocreature> Cale: if you haven’t already compiled your deps with profiling it might take an hour to turn it on :)
04:37:39 <Cale> haha
04:37:41 <phadej> ghc manual doesn't tell that, maybe I have to write a writeup on that
04:37:42 <Cale> fair enough
04:38:11 <Cale> phadej: That's really interesting actually
04:38:13 <phadej> cocreature: cast?
04:38:35 <phadej> cocreature: I mean, just give it a moe specific type signature, and its demoted?
04:39:06 <cocreature> phadej: that only works for a Traversal' s a not a Traversal s t a b afaict
04:39:10 <merijn> taktoa: Odd, that seems like it should work, tbh
04:39:15 <AWizzArd> What could be the (probably configuration) reason for Hspec not finding my file with test cases?
04:39:27 <phadej> cocreature: thata's because we don't have UnickedFold s s a a
04:40:01 <taktoa> merijn: hmm, I mirrored the question to #hackage; if I don't get an answer there I guess I'll file an issue on haddock
04:40:07 <merijn> cocreature: Well, at least it Just Works now with new-build :)
04:40:27 <cocreature> phadej: so I’m just out of luck here? I thought since a fold doesn’t use the resulting new structure it should be possible to deal with the fact that the types change
04:41:23 <merijn> taktoa: And you've made sure you're looking at the right/most recent haddock output?
04:41:31 <phadej> cocreature: let me think. You shouldn't run into situation where you Have `Traversal s t a b` which aren't unifiable with `Traversal s s a a` and thus `Fold s s a a`
04:41:50 <phadej> cocreature: otherwise you do something fishy, but I might be wrong, so give a more concrete example
04:42:27 <cocreature> phadej: I have something like "traverseLeafs :: Traversal Tree Tree Leaf Tree" that lets you replace leafs with new subtrees
04:42:43 <taktoa> merijn: yes; I just figured it out: {-# MINIMAL merge | mergeMany #-} (without the parentheses) works
04:42:48 <phadej> that's not lawful traversal.
04:42:52 <taktoa> and it breaks once I add the parentheses
04:43:03 <phadej> as when you traverse you change the structure you traverse
04:43:26 <merijn> taktoa: Ah, that's probably still worth a haddock ticket
04:43:49 <phadej> fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g) -- i bet it's violated
04:43:50 <taktoa> yeah, the GHC manual says parentheses are allowed
04:44:28 <cocreature> phadej: ah right. hm, I guess I’ll have to find some other way to deal with this or just not call it a traversal since it’s certainly useful for me :)
04:44:56 <phadej> cocreature: Traversal' (Tree a) (Tree a) a a, and then join :: Tree (Tree a)
04:44:59 <phadej> -> Tree a
04:45:14 <phadej> factoring out the join makes everything work
04:46:15 <cocreature> do you mean "Traversal (Tree a) (Tree b) a b"? otherwise I don’t see how this is going to work
04:46:22 <phadej> cocreature: yeah.
04:46:30 <cocreature> thanks, that looks promising!
04:46:36 <phadej> Or actually, use Monad Tree directly to replace leafs with other trees
04:54:03 * hackage tintin 1.0.4 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.0.4 (NickSeagull)
04:55:12 <sras> Hey! I Would like some feedback/comments on this Haskell tutorial/introduction I have been writing, targeting people who are completly new to Haskell/FP,  https://sras.me/haskell/introduction.html
04:55:51 <taktoa> merijn: ticket filed: https://github.com/haskell/haddock/issues/834
04:56:36 <merijn> sras: You have a type error in getRankMessage
04:56:52 <merijn> sras: RankWithScore has a type argument that's missing in the type of that function
04:57:33 <sras> merijn: Yes!
04:58:28 <merijn> sras: That same error occurs in a couple examples using that function
04:59:08 <sras> merijn: Oh. I think I meant the version of RankWithScore without the type argument there. The one at the end of the 'Types' subheading...
04:59:33 * hackage factory 0.3.2.0 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.3.2.0 (AlistairWard)
04:59:47 <sras> merijn: I guess that it might cause some confusion anyway...
05:00:00 <merijn> sras: Probably wanna change the 2nd use of that type to a different name
05:04:24 <sras> merijn: Yes. Done.
05:19:40 <gama> how to get current filename in haskell?
05:20:21 <electrocat> gama: filename of? executable?
05:20:22 <int-e> :t System.Environment.getProgName
05:20:23 <lambdabot> IO String
05:21:22 <gama> electrocat:  how do I get line no and filename using this https://hackage.haskell.org/package/monad-logger-0.3.28.5/docs/Control-Monad-Logger.html#t:LoggingT?
05:28:00 <electrocat> gama: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.11.0.0/GHC-Stack.html
05:28:32 <electrocat> there might be a better way
05:28:41 <electrocat> but you can use HasCallStack to get this information
05:29:19 <merijn> monad-logger also has TH functions for logging that do that
05:30:20 <electrocat> ah, yes, it's even mentioned in the link gama sent
05:36:37 <mniip> % System.Environment.getProgName
05:36:38 <yahb> mniip: "<interactive>"
05:36:41 <mniip> hmm
05:41:15 <gama> electrocat : thanks
05:46:13 <bwe> Can you recommend a service / means where and how I can easily host a haskell function? Something like github.com/seek-oss/serverless-haskell -- deployment procedure for linux would do the job as well.
05:48:53 <dminuoso> ventonegro: what does "host a haskell function" mean exactly?
05:49:08 <merijn> bwe: Personally I'd just dump stuff on a VPS (depending on the usecase)
05:50:12 <dminuoso> Sorry I meant bwe.
05:50:30 <bwe> dminuoso: Write haskell Module. Deploy. JSON in -> JSON out.
05:51:03 * hackage bishbosh 0.0.0.3 - Plays chess.  http://hackage.haskell.org/package/bishbosh-0.0.0.3 (AlistairWard)
05:51:24 <bwe> merijn: Who cares about the binary to be running? what about package updates? what is of utmost importance yet I oversee now since I never did it?
05:51:36 <bwe> Oh, and yes, compiling time.
05:51:59 <dminuoso> bwe: If compiling time gets so large that it becomes an issue, chances are you are no longer writing a trivial project and have the resources to hire an entire team.
05:52:15 <merijn> Also, you only compile once, then dump it on the VPS
05:52:36 <bwe> merijn: So you deploy only the binary?
05:52:55 <dminuoso> bwe: Here we go for the docker route. We built a docker in gitlab and just shove it onto the production server.
05:53:00 * bwe meanwhile sifts through http://www.shimweasel.com/hs_gbu/#10.2
05:53:01 <dminuoso> *a docker container
05:53:11 <tdammers> why on earth would you want the source code and the build toolchain on the web server?
05:53:16 <merijn> bwe: Sure
05:53:24 <tdammers> that'd be terrible
05:53:47 <dminuoso> bwe: Note that Im not saying that Docker is the best option, but it's certainly not terribad.
05:54:25 <bwe> merijn: build on macOS and dump the binary on Linux VPS? Does that work out?
05:54:26 <[exa]> I object in a strongest possible term against calling docker 'not terribad'
05:54:29 <tdammers> next you're gonna tell me you're using git to upload your files to the production server
05:54:56 <dminuoso> [exa]: I was hoping for this! What is your point of view?
05:55:07 <tdammers> bwe: it works if you compile in a vm
05:55:31 * dminuoso mumbles docker
05:55:38 <[exa]> dminuoso: sorry, it was just a random anti-docker line, I don't know your setup so I can't give advice
05:55:54 <bwe> tdammers: Hrmpf, then I would need additional disk space. Can I at least make stack to install a recent GHC globally?
05:55:57 <[exa]> dminuoso: but usually it is 'learn unix and get a proper sysadmin, save millions'
05:56:10 <tdammers> bwe: fsvo "globally"
05:56:20 <dminuoso> [exa]: I dont know much about nixOS, but Docker at least gives you fairly consistent builds..
05:56:37 <tdammers> bwe: all stack-installed GHC versions are shared between stack environments on the same host and user, so in that sense they are "global"
05:56:46 <merijn> bwe: Build inside VirtualBox on macOS
05:56:54 <tdammers> merijn: that's what I suggested
05:56:57 <dminuoso> [exa]: The "just go the unix-sysadmin route" will blow up so badly where each system differs in libraries, behavior and so on
05:57:02 <bwe> tdammers: Oh, I should less worry about that, then.
05:57:21 <tdammers> also, disk space is cheap
05:57:45 <merijn> tdammers: Weren't you complaining about 12 parallel GHC builds taking up too much valuable SSD space ;)
05:57:53 <[exa]> dminuoso: that's why the sysadmin is there (sysadmin should be the only guy who actually _knows_ what libraries the software is actually run with)
05:58:18 <merijn> dminuoso: That's why you build your program completely static and get rid of that problem :p
05:58:27 <tdammers> merijn: I was complaining about how 12 different GHC versions ate my SSD. But then I bought a 2 TB HDD, and it turns out that running GHC off of that doesn't actually make things much slower even
05:58:52 <dminuoso> merijn: Hehe. Ever tried to statically link the glibc into some C/C++ project?
05:59:10 <dminuoso> Ulrich Drepper thinks he knows better than you.
05:59:13 <electrocat> you shouldn't statically link glibc though
05:59:28 <dminuoso> electrocat: But what if you had a reason to? :P
05:59:39 <tdammers> re the unix sysadmin route: if you're deploying at the kind of scale where this stuff starts to matter, and managing things manually is no longer feasible, you will be deploying to machines under your control, which means you can just prescribe the exact OS you want
05:59:43 <electrocat> dminuoso: don't use glibc, use something else :p
06:00:03 <dminuoso> electrocat: In our case we were using Qt + other things which basically forced glibc on us.
06:00:03 <electrocat> glibc becomes less portable statically linked vs dynamic
06:00:07 <merijn> dminuoso: Simple solutions: 1) Don't use glibc, 2) dynamically linking libc is probably something you can get away with without issue
06:00:08 <dminuoso> And our target system had no dynamic loader
06:00:18 <[exa]> tdammers: that's true in a very narrow area of deployments
06:00:24 <bwe> tdammers: How can I get rid of some older GHC versions?
06:00:34 <electrocat> dminuoso: i guess you're screwed than :p
06:00:38 <tdammers> bwe: depends how you installed them, but usually you can just delete them
06:00:51 <dminuoso> electrocat: Heh. :)
06:01:13 <tdammers> bwe: in the case of stack-installed GHCs, the brute force method of simply nuking the entire .stack directory is often easier
06:01:32 <dminuoso> electrocat: The conversation at the table went like this: "Okay we need this really old (15yr+) glibc version, that will build statically. Where can we find it?" "Uhh. just look in debian stable repositories?"
06:01:35 <tdammers> although if you have a customized config in there, you will want to back that up first
06:01:45 <electrocat> lol
06:01:58 <electrocat> speaking of static linking
06:02:03 <electrocat> trying to build ghc with musl
06:02:35 <electrocat> terminfo is failing to find ncurses for some reason
06:03:14 <electrocat> while it's explicitly passed as an argument to ./configure
06:03:39 <tdammers> [exa]: a narrow but extremely popular area of deployments
06:04:01 <dminuoso> electrocat: In the end docker is simply less effort. While granted you could make a lot of cool things with full static builds, nixOS, unix sysadmins that do their job and everything - but a lot of places have some shit in their infrastructure.
06:04:06 <dminuoso> And docker lets you avoid a lot of bullshit.
06:04:54 <dminuoso> Thats at least the experience we have.
06:05:41 <kuribas> do you need to include ghc and everything in the image?
06:05:48 <bwe> tdammers: How to delete GHC versions softly?
06:06:06 <electrocat> dminuoso: i would argue that nixos solves the same problems in a different way
06:06:44 <kuribas> dminuoso: can you build a haskell program in docker, then keep only the binary and application data in the image?
06:07:30 <bwe> merijn: any objections from your side against deploying with https://hackage.haskell.org/package/hapistrano ?
06:08:29 <merijn> bwe: My objection would be: I don't know how that works, I understand how the "simple" way works, so unless I'd be running an actual business with sysadmin staff I'd just do whatever I find simplest and know :)
06:09:15 <bwe> I wonder: How mature is continuous integration with haskell as of now?
06:10:00 <electrocat> kuribas: i've got a way for doing that
06:10:18 <kuribas> electrocat: care to tell me how?
06:10:30 <barrucadu> It's a secret.
06:10:39 <ocharles> Has anyone used hint here? I had it working great, but now it's started breaking. My application links fine, but when I try and use hint I get `cannot satisfy -package-id aoi-1.0-inplace: aoi-1.0-inplace is unusable due to missing dependencies:aeson-1.2.3.0-LCLVoF73EXv9YBrMN75cXd ...`
06:10:51 <ocharles> Yet that very dependency is in my `ghc-pkg dump` output
06:10:59 <electrocat> i build it with nix, tell nix to give me the transitive closure of it's runtime dependencies and put it in an image, it's a 10 line shell script
06:11:17 <kuribas> bwe: my packages on github are checked by travis.  That works fine.
06:12:10 <bwe> kuribas: does your build chain end there? or does it deploy the built binaries and restarts depending processes?
06:12:22 <merijn> bwe: See also the haskell-ci script by hvr to setup Travis CI from github (if that's what you use)
06:12:35 <merijn> bwe: https://github.com/haskell-ci/haskell-ci
06:12:42 <kuribas> bwe: I am just checking it compiles fine.
06:12:50 <kuribas> bwe: and running tests
06:12:52 <bwe> kuribas: How do you deploy?
06:13:02 <kuribas> bwe: I don't, they are libraries
06:14:57 <tdammers> to be fair, you said "continuous integration", not "continuous deployment"
06:15:56 <bwe> tdammers: My definition differs. Thanks for your observation.
06:16:20 <dminuoso> electrocat: Probably yes. I have not looked into nixOS because it's quite a bit of learning.
06:16:48 <ocharles> In fact, cabal repl, import Language.Haskell.Interpreter ; runInterpreter ( return () )  is enough to get that error
06:18:54 <merijn> ocharles: Oh! I have a sneaky suspicion!
06:19:09 <ocharles> Pray tell
06:19:11 <merijn> ocharles: Which GHC version?
06:19:12 <ocharles> It worked yesterday!
06:19:19 <ocharles> 8.2.2
06:19:23 <merijn> (and which cabal-install)
06:19:32 <ocharles> 2.1.0.0
06:19:42 <merijn> Any .ghc.environment files lying around?
06:19:55 <ocharles> si. two
06:20:03 <merijn> What happens if you nuke those first?
06:21:21 <ocharles> it works if I nuke them and call the binary directly
06:21:29 <ocharles> but if I use new-run it just regenerates them crashes
06:21:52 <merijn> ocharles: I'm guessing Language.Haskell.Interpreter is built on GHC?
06:23:29 <ocharles> What do you mean by built on GHC? I wonder if the problem is that it comes from a nix environment or something
06:24:15 <merijn> ocharles: GHC by default picks up environment files, so if runInterpeter is calling GHC code (and loading those environment files) that's what's breaking, because those environment files hide a bunch of installed packages
06:24:53 <merijn> ocharles: 8.4.3 will likely get a fix for dealing with this. I guess for now you should tell cabal to stop making GHC generate those (although I'm not 100% sure how)
06:24:54 <ocharles> Right, Language.Haskell.Interpreter is `hint`, which is just a wrapper around the GHC API
06:26:04 * hackage haskey-mtl 0.3.1.0 - A monad transformer supporting Haskey transactions.  http://hackage.haskell.org/package/haskey-mtl-0.3.1.0 (hverr)
06:38:46 <cocreature> you can’t tell cabal to stop generating environment files atm
06:40:09 <ocharles> I wonder if making that file be a fifo pipe to /dev/null would work
06:40:37 <ocharles> but anyway, I'm not convinced it's the problem. I think the problem is hint coming from a nix environment, whereas yesterday cabal new-build installed it
06:40:47 <ocharles> just trying to confirm that
06:46:25 <ocharles> yea, so not being in a nix-shell with hint seems to work. weird
06:50:32 <zincy> How do I profile my code? I just have one file with a main function
06:53:51 <merijn> zincy: GHC User's Guide has a chapter on profiling
06:54:34 * hackage hexmino 0.1.1.0 - A small game based on domino-like hexagonal tiles  http://hackage.haskell.org/package/hexmino-0.1.1.0 (pasqu4le)
06:56:26 <zincy> does the ghc command run or compile?
06:56:43 <zincy> As this cmd leads to a warning ghc -prof -fprof-auto -rtsopts Main.hs
06:56:56 <zincy> well error that  error:     Failed to load interface for ‘Control.Monad.State.Lazy’     Perhaps you haven't installed the profiling libraries for package ‘mtl-2.2.2’?     Use -v to see a list of the files searched for.
06:57:14 <Ariakenom> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
06:57:20 <merijn> zincy: The problem is that you're using modules from another package (mtl) and didn't tell GHC about them
06:58:03 <merijn> zincy: Generally you will not want to build your code by invoking GHC directly, but rather using cabal-install (or stack) to build your code (and tell GHC about all the libraries it needs)
06:58:25 <merijn> zincy: In case of cabal you can tell it to build a profiling version by passing "--enable-profiling"
06:58:39 <zincy> Main lives in a stack project with dependencies all listed
06:58:59 <merijn> I don't know how stack works, tbh, so can't tell you how to make it build profiling code
07:00:33 * hackage vector-bytes-instances 0.1.1 - Serial (from the bytes package) for Vector (from the vector package)  http://hackage.haskell.org/package/vector-bytes-instances-0.1.1 (RenzoCarbonara)
07:08:33 * hackage pipes-binary 0.4.2 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.4.2 (RenzoCarbonara)
07:19:26 <sras> phadej: around?
07:22:29 <phadej> sras: pong
07:23:41 <phadej> sras: I'll leave soon for a meetup, but I'll reply then, I have client running all the time
07:24:50 <sras> phadej: So I made this repo (https://github.com/sras/servant-examples) with a bunch of small snippets that show how to do common things using Servant. Can you please take a quick look and see if you can include it in the examples page here (http://haskell-servant.readthedocs.io/en/stable/examples.html) ?
07:26:17 <alp> sras, perhaps the cookbook would even be better?
07:26:22 <phadej> sras: oh, cool. Could you mention them on #servant, alp will be intersted
07:26:34 <alp> but yeah, let's discuss this in #servant :)
07:27:04 * hackage web3 0.7.3.0 - Ethereum API for Haskell  http://hackage.haskell.org/package/web3-0.7.3.0 (akru)
07:28:17 <sras> alp: Will ping you on #servant
07:37:15 <jared-w> So weird to me that Agda only has 466 stars on github
07:38:56 <merijn> jared-w: So weird to me that somehow people think "github stars" are a meaningful metric for, well, anything :)
07:39:26 <byorgey> now it has 468.  but I agree with merijn =)
07:39:47 <monochrom> What are github stars for?
07:39:48 <byorgey> woah, it has the exact same number of stars as issues o.O
07:39:54 <merijn> monochrom: Good question :)
07:40:07 <cocreature> some people use them as bookmarks
07:40:13 <monochrom> haha
07:40:13 <merijn> monochrom: The same thing as likes, afaict :p
07:40:33 <ventonegro> What cocreature said
07:40:35 <tdammers> merijn: actually no, likes are for tuning facebook's targeted ad services
07:40:50 <tdammers> then again, github stars may actually serve the same purpose
07:40:53 <merijn> edwardk: Hope you don't mind being the opening quote for my thesis ;)
07:41:54 <jared-w> haha, what's the quote?
07:42:15 <merijn> @quote this.is.the.point
07:42:15 <lambdabot> roconnor says: <roconnor> where are all the category theoriest? why don't they already have all the answers for us? <edwardk> roconnor: this is the point in your career where you look around for the
07:42:15 <lambdabot> cavalry and realize that you're it ;)
07:42:37 <jared-w> merijn: I don't think github stars are a meaningful metric for anything, I just find it interesting how a (in my mind) fairly influentual project has less than 1k stars and far more useless projects have 5k stars because they involve JS and CSS ¯\_(ツ)_/¯
07:42:37 <merijn> It seemed oddly fitting for a thesis opening ;)
07:42:40 <shapr> oh that's a good quote
07:42:47 <shapr> merijn: yeah that's a wonderful choice
07:43:02 <jared-w> I like it :) What's the thesis about?
07:43:12 * byorgey has the same question as jared-w 
07:43:22 * jared-w is starting to plan for a PhD in CS at PSU soon
07:43:47 <merijn> jared-w: How despite 14 years of doing graph processing on GPUs still no one has a clue what they're doing, including me :p
07:43:49 <shapr> byorgey: I really love your cis194 course, thanks for writing it!
07:44:07 <shapr> merijn: ooh, draft versions available?
07:44:08 * Ariakenom makes space to add an opening quote to his recently turned in master's thesis
07:44:25 <merijn> shapr: I have like 5 pages of introduction written... :p
07:44:30 <byorgey> shapr: you're welcome, glad you enjoyed it!
07:44:54 <jared-w> I can already tell that my thesis will be fucking beautiful
07:44:59 <byorgey> jared-w: oh, sounds like fun!
07:45:01 <jared-w> because I'm going to procrastinate so hard on actually writing...
07:45:08 <barrucadu> haha
07:45:09 <merijn> jared-w: Same here :p
07:45:16 <shapr> avoid success :-P
07:45:21 <barrucadu> I tried to do all my LaTeX procrastination before starting to write the content
07:45:25 <barrucadu> That didn't go so well
07:45:27 <jared-w> "See this lambda? I wrote it in pure tikz"
07:45:27 <merijn> Well, I haven't wasted too much time on playing with the layout yet
07:45:27 <electrocat> jared-w: can confirm, due in 2 weeks, very much procrastinating
07:45:30 <byorgey> jared-w: https://www.beeminder.com/  <-- only reason I got my thesis written
07:45:48 <jared-w> byorgey: oooh this is gonna be a lifesaver
07:45:50 <sclv> Lol i think edward lifted that quip from me, who in turn lifted it from will byrd
07:45:56 <merijn> barrucadu: I got a lot of pretty solid LaTeX procrastination done so far
07:46:26 <jared-w> electrocat: my sympathies lol
07:46:34 <jared-w> byorgey: thanks! I'm really looking forward to the PhD
07:46:44 <sclv> (who of course said it about scheme specs iirc)
07:46:48 <merijn> I should set up my old pomodoro technique of just having a reminder every 15 minutes of "you should be writing" as pop-up ;)
07:46:56 <merijn> jared-w: That's how you can tell you haven't started yet ;)
07:47:09 <jared-w> so I hear :p
07:47:13 <shapr> merijn: I do that with adjustments, if popup during work, increase timeout, if not, decrease timeout
07:47:26 <jared-w> Undergrad drives me nuts though, so I have a feeling the masters/phd work will be much more natural fit for me
07:47:34 <electrocat> heuristic anti-procrastination? :p
07:47:43 <shapr> Best trick I've found for getting work done is to download everything I'll need to my laptop and disconnect from the internet entirely
07:47:46 <jared-w> I haven't narrowed down what I want to work on a lot, but it'll be fairly heavily influenced by what advisor I pick and what funding we can get, I imagine...
07:47:54 <shapr> electrocat: yeah, works well for me
07:48:02 <merijn> shapr: Doesn't really work when you'r actively googling papers, etc. while writing
07:48:15 <shapr> merijn: sure, it takes a few iterations
07:48:27 <jared-w> shapr: my best trick so far is a countdown clock. Seeing the actual time ticking down does wonders for some reason. Then every 20 minutes, take a break
07:48:35 <electrocat> maybe i should disable wifi for a while..
07:48:43 <shapr> I do wish for a tool I could ask to get all papers cited by this paper, and all papers that cited this paper.
07:48:58 <electrocat> transitive citation closure? :D
07:49:02 <shapr> yup!
07:49:10 <electrocat> would be very useful
07:49:11 <jared-w> I actually wrote a script on my laptop that, every 20 minutes, shuts off the keyboard and mouse and blocks my screen with an unmovable terminal that says "take a 5 minute break, kiss your fiance, and check your agenda"
07:49:32 <shapr> and some way to annotate citations as to what the linked paper covers
07:49:37 <shapr> jared-w: ooh, smart
07:49:50 <electrocat> that would just break my focus
07:49:57 <shapr> would remind me of my motivation
07:50:10 <shapr> electrocat: I have part of a tool to do the paper stuff
07:50:16 <shapr> I should really finish that
07:50:27 <jared-w> It does break my focus, but the wins are worth it. For me the most important thing is to avoid major hyperfocus where I start focusing so hard I completely lose track of time and my productivity starts to go down because of tunnel vision
07:50:55 <shapr> breadth first search instead of depth first?
07:51:02 <jared-w> So the few times where I get pissed off because I'm about to write something and (oh darn, the break screen popped up) are offset by how much more productive I actually end up being lol
07:51:55 <electrocat> jared-w: i think i would need a popup that would say the exact opposite
07:52:18 <merijn> Yeah...if I interrupt when I'm in the flow of writing that'd completely reduce my productivity to zero, given how hard of a time I have getting started usually :p
07:52:18 <jared-w> "get back on the computer and stop making out already"? :p
07:52:22 <edwardk> i would probably spend that five minutes fuming, and planning out how to build a time machine to go back and beat up the past version of me that somehow thought this was a good idea ;)
07:52:44 <jared-w> oh no I only block my screen for 30 seconds lol
07:53:19 <jared-w> I just _say_ I should take a 5 minute break, but if I don't want to, at least I have the 30 seconds to adjust my eyes, reorient myself, make sure I'm actually on task and not just hyperfocusing myself into a hole... :)
07:53:30 <jared-w> (Most of the time I just take the 30 second break)
07:53:43 <shapr> I have both sides of that, hard to get started, but often focused on something that does not lead to my goal.
07:53:51 <zincy> yes breaks are hard to take
07:53:59 <merijn> shapr: High-five, join the club!
07:54:00 <edwardk> people have goals? =)
07:54:18 <zincy> leaving problems unsolved is painful
07:54:21 <Squarism> Im going to hold a presentation on FP/Haskell tomorrow at work. Anyone got some good USP/PR? Why not-so-technically interested people should care about it.
07:54:42 <zincy> blockchain + haskell seem to interest non tech people
07:54:46 <electrocat> shapr: same
07:55:03 <tdammers> edwardk: I prefer having a starting point and enough interesting leads to work on, but apparently most people are not like that
07:55:07 <jared-w> Squarism: you'll have to cater it to your audience. The question I always try to figure out is "what do they hate the most about programming and their general flow of things and how does Haskell improve on that model?"
07:55:39 <electrocat> edwardk: planning on doing a stream in the near future?
07:55:41 <tdammers> jared-w: not just that, you also have to provide examples of direct rewards
07:55:46 <merijn> My advisor complisulted me by saying my creativity helped my research more than my "lack of work effort harmed it"
07:55:57 <edwardk> electrocat: i'm currently in australia and unable to use my fancy streaming setup
07:56:00 <tdammers> merijn: clueless
07:56:04 <edwardk> electrocat: i get back in a week or so
07:56:06 <jared-w> exactly, tdammers :)
07:56:09 <Squarism> zincy, is there some particular case that you have in mind?
07:56:12 <merijn> tdammers: hmm?
07:56:14 <Squarism> jared-w, good point
07:56:26 <tdammers> merijn: this whole calvinist hard work ethic has, on a global scale, probably done at least as much harm as it has done good
07:56:31 <jared-w> So some people really *really* hate writing repetitive and boilerplate code. They'll love deriving in haskell
07:56:36 <zincy> Squarism: Look at Cardano a blockchain written in Cardano
07:56:53 <Squarism> zincy, thanks
07:57:01 <jared-w> Others really miss generics. The fact that generics are "free" in haskell will be awesome for them.
07:57:09 <zincy> I get so much hate from my friends for using haskell
07:57:10 <merijn> tdammers: To be fair, my direct effort isn't that amazing, since I spend a lot of time working on stuff not at all related to my thesis
07:57:44 <jared-w> Surprisingly, the thing that my coworker appreciates the most about haskell is that using it makes you think like a better programmer and secondly that the compiler yells at you when you break things
07:57:57 <tdammers> merijn: turns out that doing something other than the thing you "should" be doing is a severely underestimated source of productivity
07:58:05 <zincy> I just hope one day they will be forced at work to maintain a haskell codebase :)
07:58:20 <merijn> tdammers: Well considering we've had plenty of discussions before about how our Chinese phd's constantly overworking themselves is actively harmful to their research output she has a somewhat more reasonable standard than normal in academia
07:58:28 <zincy> tdammers: Yes
07:58:34 <jared-w> But, I think most web dev people who have been working in php/js for 5+ years learn to have a deep appreciation for a language that warns you about type changes after spending hours hunting down those bugs :)
07:59:02 <merijn> tdammers: Sure, but in the end I'm also on schedule to finish enough stuff to actually write a thesis, so some more focus might've helped me :p
07:59:45 <zincy> Can you go straight into a phd in CS without a masters or undergrad ?
07:59:57 <zincy> and just take say 2 years longer hehe
08:00:03 <merijn> zincy: Theoretically? Yes. Practically, probably not
08:00:14 <jared-w> Without a masters, some will. Without undergrad? I don't know of any that would actually do that
08:00:17 <zincy> They wont fund you for a start I guess
08:00:46 <jared-w> I suppose if you took the GRE and passed it with a really high score they'd be fine with it? ¯\_(ツ)_/¯
08:00:46 <merijn> zincy: In the US and UK it's reasonably common to start a phd after your undergrad. In the rest of Europe starting a PhD without a master's is almost unheard of
08:00:51 <zincy> Anyone motivated enough could do undergrad in a year I speculate
08:01:07 <merijn> zincy: I doubt it, unless the undergrad program is super light
08:01:20 <jared-w> zincy: if you skip all the general classes and even tier-2 relevant classes, perhaps
08:01:47 <zincy> I mean if you went the self-study route and worked every day
08:02:01 <tdammers> although I believe some universities have fast-track programs where you can exam out of a lot of classes and get a master's in like half the normal time, under certain conditions
08:02:24 <jared-w> yeah, but undergrad has a /lot/ of content in it. You'll still take more than a year to power through it
08:03:08 <zincy> merijn: are you planning on academia?
08:03:16 <merijn> zincy: Fuck no
08:03:30 <zincy> so why the phd?
08:03:54 <merijn> I've seen my advisor go(ing) through tenure track hell, I'll pass on that :)
08:04:12 <electrocat> merijn: this seems familiar
08:04:21 <zincy> What is tenure track hell
08:04:36 <zincy> some form of slavery?
08:04:46 <merijn> zincy: Because 1) I'm interested in R&D positions where it helps and 2) I like teaching and if possible would like spend at least some time doing it, which also benefits from a PhD
08:04:53 <merijn> zincy: Basically, yes
08:05:00 <electrocat> lol
08:05:04 <jared-w> Tenure track hell contributes a lot to the "publish or die" mentality of academia as well
08:05:54 <merijn> zincy: Tenure track = "we pay you for X (usually 4-5) years, if you meet these ridiculous requirements (in terms of funding, etc.) at the end we give you a permanent position, else you're fired"
08:06:04 * hackage hfmt 0.2.2 - Haskell source code formatter  http://hackage.haskell.org/package/hfmt-0.2.2 (danielstiner)
08:06:34 <rockbmb> Sorry to interrupt: can someone tell me whether or not unqualified imports/exports impact compilation times of Haskell projects?
08:06:44 <zincy> so what are the options after failure?
08:06:53 <zincy> oh haskell
08:06:54 <quicksilver> rockbmb: nope
08:07:02 <quicksilver> rockbmb: I mean, they don't. Not that I can't tell you :)
08:07:05 <zincy> dont be sorry haha
08:07:17 <merijn> zincy: So then you work 80 hour weeks trying to supervise your students, teach classes (and watch out you don't get negative feedback, because despite teaching effort not counting for your tenure track negative ratings will hurt you), and write grant proposals in an attempt to get more money and hopefully hit your tenure track goals
08:07:20 <electrocat> "sorry to interrup", an indication we're getting side tracked
08:07:30 <rockbmb> Thank you for the help :thumbsup:
08:07:36 <AWizzArd> How can I turn off `-Wmissing-signatures` in ghci?
08:07:55 <electrocat> AWizzArd: -Wno-missing-signatures
08:07:59 <dmwit> quicksilver: really? that seems unlikely. surely ghc has to at least look at the hi file for any spurious import
08:08:01 <merijn> zincy: The option after failure is "leave academia permanently", because after completing a tenure track unsuccessfully the odds of any university hiring you are basically 0
08:08:11 <dmwit> rockbmb: you, too
08:08:22 <zincy> haha
08:08:51 <zincy> How can I understand to read proofs better?
08:08:56 <jared-w> merijn: damn, that's harsh
08:09:04 <merijn> dmwit: But it only has to read one hi file for each import statement regardless of whether it's qualified or not
08:09:07 <dmwit> rockbmb: i think extra imports *will* increase compilation time, though probably not by much
08:09:22 <merijn> dmwit: So whether it's qualified or not will not impact compilation time
08:09:29 <electrocat> zincy: what kind of proofs?
08:09:43 <zincy> I am studying algorithms atm and implementing in haskell. Also what would you recommend as an approach to learning to reason about run time complexity?
08:09:48 <jared-w> You'd probably have to import like 1k+ modules for it to really start to matter? But by then your compilation speed hit would be for other reasons than what you're importing :p
08:09:48 <dmwit> agreed. is that the distinction being made?
08:10:04 * hackage hapistrano 0.3.5.6 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.5.6 (juanpaucar)
08:10:24 <jared-w> zincy: equational reasoning is generally the recommended approach. That and amortized analysis (but that's a bit complicated and often unnecessary)
08:10:25 <zincy> proving correctness of algorithms
08:10:43 <jared-w> Bird's "Pearls of functional algorithm design" is the hallmark of FP algorithms and algorithm analysis iirc
08:11:08 <zincy> thanks
08:11:19 <rockbmb> dmwit: Alright, I'll keep that in mind. 45 minutes to compile a project is a little onerous.
08:11:35 <jared-w> What are you compiling with? Compiler flags can usually cut down a lot of time
08:11:52 <AWizzArd> electrocat: good, that worked
08:12:40 <merijn> jared-w: I'd say that it's Okasaki who has that honour
08:12:56 <jared-w> oh right, that's very true
08:13:14 <dmwit> rockbmb: is that every compile, or is that mostly dependencies that won't get rebuilt?
08:13:38 <jared-w> Pearls would be more for learning how to think like a FP programmer and Okasaki more for learning how to do the complexity analysis and thinking about FP structures, then :)
08:13:53 <dmwit> 45 minutes is common forwthe latter, v. rare for the former
08:14:17 <rockbmb> Fortunately it's not every compile, but even if it's the former case it'd be nice to speed up the process.
08:14:45 <dmwit> so generally not super painful during dev. though i agree the end-user experience is a bit off
08:15:00 <ddellacosta> zincy: I will also add that if you are just trying to get a baseline in reasoning about complexity, I think CLRS is great
08:15:17 <ddellacosta> not sure if you meant exclusively in the functional programming context or not
08:15:36 <jared-w> rockbmb: do you compile with fast compilation flags and optimizations turned off when doing dev stuff?
08:16:07 <rockbmb> Let me take a look at if that's the case.
08:17:46 <rockbmb> `stack build --fast --test --ghc-options=+RTS -A256m -n4m -RTS -O0 -j -dynamic` is what is used every time.
08:20:10 <JayKobe6k> Does hackage have a kine of "reverse dependencies" thing.  So that I can see what projects depend on some other project
08:20:24 <merijn> JayKobe6k: Not builtin, but it exists
08:20:41 <merijn> JayKobe6k: https://packdeps.haskellers.com/reverse
08:22:21 <jared-w> +RTS and -RTS?
08:23:23 <merijn> jared-w: Those delimit rtsopts
08:23:24 <jared-w> oh right, nvm
08:23:44 <jared-w> Yeah just takes me a second to remember that every time I see it :p
08:24:32 <JayKobe6k> merijn: cool, thanks
08:28:03 * hackage protobuf 0.2.1.2 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.1.2 (NathanHowell)
08:29:34 * hackage hsimport 0.8.6 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.8.6 (DanielTrstenjak)
08:40:29 <tabaqui1> here is says how can I pass strings with macro flag
08:40:31 <tabaqui1> https://github.com/haskell/cabal/issues/4414
08:40:39 <tabaqui1> but it doesn't work with cabal install on version 1.24
08:41:28 <tabaqui1> actually, I need the same with stack, but cabal doesn't work too
08:46:46 <tabaqui> i'm still here)
08:47:13 <cocreature> tabaqui: how exactly are you specifying the flag and what’s the error?
08:49:04 * hackage Gamgine 0.5.3, layers-game 0.5.3 (DanielTrstenjak): https://qbin.io/soft-bread-65hk
08:56:00 <zincy> Can the use of deriving Eq lead to performance issues?
08:56:07 <zincy> In the case of rose trees?
08:57:08 <fresheyeball> mornin' Haskllers
09:01:49 <gobby> ghc is giving me this error : <command line>: cannot satisfy -package hedgehog-0.6
09:02:13 <gobby> ive added hedgehog to the stack.yaml file and the cabal file
09:07:33 <cocreature> gobby: which command are you running that is producing this error?
09:08:02 <dminuoso> gobby: Are you sure it's ghc and not ghc-mod?
09:09:31 <gobby> stack --nix ghci cardano-sl-core:test:golden-tests
09:09:52 <cocreature> try running "stack build --test" first
09:11:24 <mitchellsalad_> Does this function have a name? (a -> Either b c) -> [a] -> ([b], [c])
09:11:42 <cocreature> mitchellsalad_: partitionEithers is really close
09:11:52 <cocreature> :t partitionEithers
09:11:53 <lambdabot> [Either a b] -> ([a], [b])
09:12:06 <mitchellsalad_> Thanks :)
09:14:19 <fresheyeball> mitchellsalad_: cocreature that one is in my library Compactable
09:15:35 <fresheyeball> https://hackage.haskell.org/package/compactable-0.1.2.0/docs/Control-Compactable.html#v:fmapBifold
09:15:45 <fresheyeball> mitchellsalad_: ^^ that is the max general version
09:16:00 <fresheyeball> fmapBifold :: (Compactable f, Functor f, Bifoldable g) => (a -> g l r) -> f a -> (f l, f r)
09:16:44 <mitchellsalad_> Nice!
09:17:08 <mitchellsalad_> Just curious, why "fmap" prefixes? We already lost "map" to list. Let's not cede more territory to its evil.
09:17:33 <fresheyeball> mitchellsalad_: consistency with other libraries
09:17:47 <fresheyeball> which... I already messed up not calling `compact` `catMaybes`
09:18:17 <mitchellsalad_> Oh, *that* one I'd love to see changed, too, due to https://hackage.haskell.org/package/compact-0.1.0.1/docs/Data-Compact.html
09:19:28 <fresheyeball> mitchellsalad_: pssst lastest is 0.1.2.0
09:20:15 <mitchellsalad_> pssst I linked a different library ;)
09:20:31 <fresheyeball> oh haha
09:20:35 <fresheyeball> right the compact regions thing
09:20:58 <mitchellsalad_> Yeah. Not that no libraries should ever have name collisions or anything, but I imagine compact regions will be eventually moved into base.
09:21:12 <fresheyeball> I would bite the bullet and rebrand, but it turns out this albegra is just not about Maybe. So catMaybes feels wrong.
09:22:34 <cocreature> "compact" looks very much like "wither"
09:22:48 <gobby> cocreature: I did that already, I just did it again to be sure. Have the same issue
09:23:14 <fresheyeball> cocreature: https://hackage.haskell.org/package/compactable-0.1.2.0/docs/Control-Compactable.html#v:traverseMaybe
09:23:19 <fresheyeball> traverseMaybe is wither
09:23:29 <fresheyeball> Wither is overconstrained
09:23:33 <cocreature> gobby: hm weird, what happens if you pass --test to to the stack ghci command as well?
09:24:19 <mitchellsalad_> fresheyeball: A radical proposal: 1. keepIf :: (a -> Bool) -> f a -> f a; 2. dropIf :: (a -> Bool) -> f a -> f a; 3. filter :: f (Maybe a) -> f a
09:24:20 <cocreature> fresheyeball: are there any interesting instances of Compactable that aren’t Traversable?
09:25:25 <cocreature> ah you don’t even require a Functor constraint, fair enough
09:25:44 <fresheyeball> cocreature: :P
09:26:48 <gobby> cocreature: That works. How weird.
09:27:08 <fresheyeball> mitchellsalad_: I like it, but it too radical for me
09:27:12 <gobby> cocreature: Why does stack need an additional --test flag
09:27:15 <fresheyeball> I want to show up in searches for `filter`
09:28:00 <cocreature> gobby: because it doesn’t build tests by default. but the fact that it still allows you to specify a test target is pretty weird and I would consider it a bug
09:28:17 <fresheyeball> anyone have thoughts on this lib? https://github.com/composewell/streamly/tree/master/src/Streamly
09:28:55 <fresheyeball> mitchellsalad_: if you adopt Compactable, you should grep your codebase for catMaybe and mapMaybe, partitionEithers and the like
09:29:10 <fresheyeball> you are going to be suprised how many things you can simplify and gain some small perf
09:29:12 <mitchellsalad_> definitely!
09:29:29 <mitchellsalad_> Can you say more about why `catMaybes` is not a great name for `compat`?
09:29:47 <fresheyeball> Because of the CompactFold typeclass
09:29:52 <cocreature> fresheyeball: gain perf? how is it faster than the functions in base?
09:29:53 <fresheyeball> Its just not about `Maybe`
09:30:04 <mitchellsalad_> Ah, I see
09:30:18 <fresheyeball> cocreature: fmapMaybe in Compactable is faster than `catMaybes . fmap` because its one pass
09:31:06 <gobby> cocreature: Thanks again, should I report the bug?
09:31:12 <mitchellsalad_> fresheyeball: I think you're onto a great abstraction but the names are awfully long and awkward :)
09:31:42 <fresheyeball> mitchellsalad_: feel free to sumbit a PR, there is much work to be done there
09:32:00 <fresheyeball> Better exploring the relationship between the two classes is badly needed
09:32:17 <mitchellsalad_> I don't have any ideas, I'm just thinking there could be some brand new snazzy names, like connor mcbride's "smash"
09:32:39 <cocreature> fresheyeball: a) have you checked that GHC doesn’t optimize "catMaybes . fmap" to the same core? and b) that seems like an unfare comparison. you can just as well use mapMaybe to get your version using "base" and compact . fmap to turn your version into the one based on catMaybes
09:33:20 <boj> yeah, curious to see what the core code looks like. seems like that would be optimized out either way
09:33:28 <fresheyeball> cocreature: it might be the same in the case of list. I have not done that work yet. Its on my list though.
09:33:49 <fresheyeball> you can fmapMaybe lots of things that are not lists though
09:33:58 <fresheyeball> and write functions that abstract over it
09:34:03 <fresheyeball> for example at work I have
09:34:07 <cocreature> sure your version is obviously more general. I just take issue with claims about performance without benchmarks :)
09:34:20 <fresheyeball> search :: Compactable f => Text -> f Text -> f Text
09:34:42 <fresheyeball> cocreature: fair. I would say its a goal, but I certainly cant prove it right now.
09:37:22 <cocreature> fresheyeball: mapMaybe has some rewrite rules that you might want to steal. otherwise you are probably losing out on performance rather than gaining by switching to fmapMaybe :)
09:37:50 <fresheyeball> cocreature: when there is an existing one, Compactable uses that and inlines it.
09:38:14 <fresheyeball> hopefully it will get the same rewrite benefit
09:38:39 <cocreature> fresheyeball: how so? if you would implement fmapMaybe for lists using mapMaybe that should work but you don’t do that
09:39:13 <fresheyeball> OOoo you are right
09:39:20 <fresheyeball> I should update that
09:39:28 <fresheyeball> good catch
09:39:39 <cocreature> gotta go fast!
09:39:57 <fresheyeball> well like I said, it endevors to have all the fastest version of these functions
09:40:20 <fresheyeball> it for sure has not succeeded yet. I am hoping lovely people who consume the lib will submit updates when they spot things like this.
09:41:32 <cocreature> I’ll definitely add that lib to my toolset and see if I end up using it :)
09:43:25 <lukelau> Is it possible to pattern match a polymorphic parameter?
09:43:39 <dmwit> lukelau: nope
09:43:49 <lukelau> damn
09:44:11 <dmwit> Wow, the way haddock reports DefaultSignatures defaults is ultra-confusing.
09:44:53 <dmwit> lukelau: Perhaps you should ask a more open-ended question with a bit of context about what you're trying to do. You might get suggestions of alternate approaches if you give us something to go on. =)
09:48:21 <quicksilver> you can pattern match on a GADT even when the value concerned has a polymorphic type
09:48:27 <quicksilver> which probably isn't what was being asked, but still
09:48:39 <quicksilver> "polymorphic parameter" could mean different things
09:50:08 <lukelau> dmwit: The end goal is to do something like this: https://lpaste.net/2254676973622132736
09:50:56 <lukelau> The pattern matching part was just to see if I could do it on an individual case by case basis since this doesn’t typecheck
09:50:57 <glguy> lukelau: the variable 'a' on line 1 and 2 are different, each one is local to its type signature
09:51:28 <lukelau> glguy: Thanks!  Deleting it worked
09:52:47 <quicksilver> as an alternative you can enable ScopedTypeVariables and add "forall a ." to the beginning of the type sig on line 1
09:56:02 <lukelau> quicksilver: This is a bit unrelated, but I’ve been having a hard time groking rank N types/forall a. annotation. Don’t all type signatures in the form `a -> a` infer `forall a. a -> a`?
09:56:27 <quicksilver> well
09:56:44 <quicksilver> it is logical to read "a -> a" as "forall a . a -> a"
09:56:53 <quicksilver> the key difference is that the first form is legal haskell
09:56:57 <quicksilver> and the second isn't :)
09:57:07 <lukelau> Not even with the extension?
09:57:09 <dmwit> lukelau: Yes, there is an implicit forall. But ScopedTypeVariables is special compiler magic that distinguishes between implicit and explicit foralls.
09:57:10 <quicksilver> the second is permitted by certain extensions
09:57:35 <habolabo> heterogeneous tree... existential types...
09:57:42 <quicksilver> (in particular, the second is essential for higher ranked types to be written in any kind of sensible way)
09:58:01 <quicksilver> but scopedtypevariables, in a desire to be backwards compatible with plain haskell
09:58:36 <quicksilver> chooses to only actually scope the variables when you write an explicit forall.
09:59:03 <lukelau> that makes sense
09:59:17 <quicksilver> it's a backwards compatibility hack
09:59:27 <quicksilver> but it works well enough.
10:00:17 <dmwit> :t \x -> maybe False (x==) . Data.Aeson.decode
10:00:18 <lambdabot> (aeson-1.2.3.0:Data.Aeson.Types.FromJSON.FromJSON a, Eq a) => a -> BSLC.ByteString -> Bool
10:00:43 <dmwit> Fully-qualified type signatures sure are noisy.
10:01:06 <lukelau> > aeson-1.2.3.0:Data.Aeson.Types.FromJSON.FromJSON
10:01:08 <lambdabot>  error:
10:01:08 <lambdabot>      Not in scope: data constructor ‘Data.Aeson.Types.FromJSON.FromJSON’
10:01:08 <lambdabot>      No module named ‘Data.Aeson.Types.FromJSON’ is imported.
10:01:32 <quicksilver> you wouldn't want to accidentally confuse that with aeson-1.2.2.0:Data.Aeson.Types.FromJSON.FromJSON
10:01:33 * hackage set-extra 1.4.1 - Functions that could be added to Data.Set.  http://hackage.haskell.org/package/set-extra-1.4.1 (DavidFox)
10:01:49 <quicksilver> just think of the consequences
10:02:45 <lukelau> By the way, this is what I had in mind when I mentioned pattern matching https://lpaste.net/1326853811645448192
10:04:03 <blackbriar> hello?
10:04:21 <fresheyeball> blackbriar: hiya
10:04:33 <blackbriar> not used to irc
10:04:38 <dmwit> lukelau: No, a `FromJSON a` constraint only qualifies you to call `FromJSON` methods. It does let you assume you have a value of any particular `FromJSON` instance. Which is why I said "nope" as my answer to "can I?". =)
10:04:40 <fresheyeball> blackbriar: all god
10:04:44 <fresheyeball> blackbriar: all good
10:05:14 <dmwit> lukelau: Or, to say it another way: if `bar :: FromJSON a => ...`, then it is the *caller* of `bar` who gets to choose which `FromJSON` instance is used, not the implementor.
10:05:18 <blackbriar> anyone online with experience in either networking or game engines?
10:05:27 <blackbriar> (in haskell?)
10:05:28 <lukelau> dmwit: that’s a better way of looking at things
10:05:47 <dmwit> blackbriar: There is #haskell-game, I believe. But generally, it is considered polite to just ask your question rather than asking for experts.
10:06:27 <blackbriar> nono, it's just a nich'e question
10:06:35 <fresheyeball> blackbriar: yes
10:06:56 <fresheyeball> blackbriar: welcome to niche land, where all things are niche
10:07:18 <blackbriar> TL;DR how hard is it to do decentralised, synchronised networking in Haskell
10:09:06 <fresheyeball> blackbriar: I think that is hard in general
10:09:14 <fresheyeball> I dont know how to do it
10:09:37 <blackbriar> oh, yes. it's hard
10:09:47 <blackbriar> with out of order packets
10:09:53 <blackbriar> no central authority
10:10:08 <blackbriar> latency
10:11:19 <blackbriar> just wondering if it's " when pigs fly"  hard or "x days with a team of experts"  hard
10:11:30 <fresheyeball> oh
10:11:32 <cocreature> blackbriar: how hard it is probably mostly depends on whether there is a library for the protocol you’re thinking of
10:11:44 <fresheyeball> its not "when pigs fly" hard. I am sure its doable.
10:12:12 <blackbriar> and commercially viable. so asynchronous bandwidth
10:15:46 <blackbriar> cocreature: no idea, just wondering what the options are
10:18:09 <cocreature> blackbriar: distributed networking is mostly a set of tradeoffs, e.g., how resistant you are to failing/malicious nodes, the level of consistency among the participacting nodes, … so I would recommend that you first figure out which tradeoffs fit your application and then search for a protocol that fits
10:18:19 <blackbriar> (also, whenever i lookup decentralised gaming, i get blockchain based games :/ )
10:18:35 <blackbriar> cocreature: will do, brb
10:20:28 <quicksilver> distributed network services exist
10:21:03 <quicksilver> if you're happy to pay, you could base certain kinds of game off a service like pubnub
10:21:11 <quicksilver> (many other services with varying tradeoffs exist)
10:21:22 <quicksilver> (and it would be perfectly fine to use haskell in the client)
10:22:43 <blackbriar> i have this idea for a free game with no central servers
10:23:24 <blackbriar> discovery run through steam or similar
10:23:45 <blackbriar> (mostly so i wouldn' t have to pay for server cost and maybe make something crazy)
10:32:44 <dmwit> blackbriar: I wouldn't expect distributed networking to be any harder in Haskell than in other languages. That is, very very hard. But not because Haskell makes it hard.
10:33:43 <blackbriar> mmmh, okay
10:41:38 <AWizzArd> I would like to construct recursive data but this runs into an error. I have assembled a 5-line demo here: https://lpaste.net/6092105908999946240
10:42:04 <AWizzArd> I forgot the type:  data Foo s i o = Foo { stor :: s, next :: (i -> s -> Maybe (Foo s i o))}
10:42:19 <AWizzArd> New link: https://lpaste.net/7999861645226541056
10:42:38 <blackbriar> now, i am a novice as well
10:42:54 <AWizzArd> I would like to put any kind of „store” into a Foo. It can be a Data.Map. It can be an array. A HashMap, a FingerTree, etc.
10:43:27 <AWizzArd> And an accessor that takes some input, a store and maybe returns another Foo.
10:44:09 <blackbriar> data foo = ... ?
10:44:23 <AWizzArd> blackbriar: second link, this one: https://lpaste.net/7999861645226541056
10:44:33 <AWizzArd> In the first one I forgot the data declaration.
10:44:42 <blackbriar> data foo = .. instead of data foo s i o=...?
10:44:53 <blackbriar> haven' t seen that second syntax before
10:45:18 <AWizzArd> blackbriar: But my type constructor depends on those types.
10:45:49 <AWizzArd> From what I know in most cases on the lhs all polymorphic type vars should appear that will be used on the rhs.
10:47:11 <blackbriar> data x = y x x is a tree structure that uses itself
10:47:31 <blackbriar> data x = y | z
10:48:03 <blackbriar> you do not need to define anything besides the name in the first half of the assignment
10:48:08 <blackbriar> (i think)
10:48:50 <AWizzArd> but `data x = y | z` is not even valid Haskell. We would have to use uppercase names no?
10:49:03 <glguy> AWizzArd: The type of the next field in your Foo type is  (i -> s -> Maybe (Foo s i o))
10:49:17 <AWizzArd> glguy: yes
10:49:17 <glguy> AWizzArd: But obviously bar doesn't have a type that is compatible with that
10:49:25 <glguy> so you can't write: Foo myStore bar
10:49:41 <AWizzArd> glguy: Right. I just wonder how I could achieve this.
10:50:20 <glguy> AWizzArd: change bar's type and implementation to match what Foo expects
10:53:08 <AWizzArd> glguy: the lookup needs an Int for sure. And I want to call M.lookup so I have to put a `M.Map` in there. As the keys are Ints I already know `M.Map Int`.  And the return value should be some Foo.
10:53:27 <AWizzArd> So I can say it should be:  bar :: Int -> M.Map Int (Foo s Int o) -> Maybe (Foo s Int o)
10:55:03 <glguy> AWizzArd: No, that doesn't match
10:55:08 <AWizzArd> glguy: but that still results in a similar type error. The second arg of `Foo` expects a `M.Map Int (Maybe a)`. But instead bar is a `M.Map Int (Foo (M.Map Int (Maybe a)) Int o)`
10:55:29 <AWizzArd> Yeah, so I wonder how they can be made to match. I agree that this is not correct.
10:56:04 <glguy> AWizzArd: try making a newtype for the thing you want to set the type 's'  to
11:04:34 * hackage cabal-lenses 0.7.1 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.7.1 (DanielTrstenjak)
11:05:04 * hackage cabal-cargs 0.9.1 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.9.1 (DanielTrstenjak)
11:06:00 <glguy> AWizzArd: https://gist.github.com/glguy/461149536083acd1e684c3201a92bf69
11:08:29 <AWizzArd> glguy: Thx, that helped!
11:12:06 <dmj`> Someone should make servant bindings to this https://pokeapi.co/
11:15:04 * hackage data-diverse 4.0.0.0 - Extensible records and polymorphic variants.  http://hackage.haskell.org/package/data-diverse-4.0.0.0 (louispan)
11:16:34 * hackage pipes-misc 0.5.0.0 - Miscellaneous utilities for pipes, required by glazier-tutorial  http://hackage.haskell.org/package/pipes-misc-0.5.0.0 (louispan)
11:38:22 <lukelau> Is it possible to use a lens as both a getter and setter like this: https://lpaste.net/8348169061842026496
11:38:36 <lukelau> Where f is a “lens” like (myFieldOne . myFieldTwo)
11:45:15 <jle`> lukelau: yes
11:45:23 <jle`> but default haskell type inference makes this tricky
11:45:30 <jle`> one solution would be to give foo an explicit type annotation
11:45:45 <jle`> foo :: Lens s t a b -> s -> ...
11:46:03 <jle`> so ghc knows that you are passing in a lens you are intending to use in multiple ways
11:49:57 <dmwit> I think you actually have to write `foo :: Lens s s a a -> s -> s`.
11:50:42 <dmwit> Otherwise when setting the field to `x^.f` it tries to treat `x^.f` as an `a` (because that's what the read end says) and a `b` (because that's what the write end says) at the same time and pukes.
11:51:06 <dmwit> (Or use the short form for this, `foo :: Lens' s a -> s -> s`.)
12:01:13 <exarkun> which one is the good cli argument parsing library?
12:02:01 <MarcelineVQ> optparse-applicative is pretty good, and optparse-generic if you need some automation
12:11:32 <exarkun> thanks
12:31:23 <shapr> exarkun: for cheesy quick hacks, I like http://hackage.haskell.org/package/ReadArgs
12:33:02 <exarkun> simple
12:33:34 * hackage tintin 1.2.4 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.2.4 (NickSeagull)
12:46:51 <dyl> Heh, tintin.
12:46:55 <dyl> That's a fun name.
12:50:24 <quicksilver> well in my mind tintin is a mud client
12:50:30 <quicksilver> but names get reused in the end :)
13:01:08 * tdammers is in favor of just using UUIDs for package names
13:02:19 <dysfun> tdammers: itym cryptographically strong hashes of the contents
13:05:29 <codedmart> Anyone with some pointers on how I can apply this to yesod forms. I am not using digestive-functors: https://stackoverflow.com/questions/12106964/validation-spanning-multiple-fields#12107785
13:38:35 <tdammers> dysfun: no, those are for package versioning
13:38:54 <tdammers> package names are just random UUIDs, generated using a cryptographically strong RNG
13:46:40 <sfogarty> Hello. I'm working on non-functional tests for haskell code, for grading assignments. Properties like "does this function use recursion vs list comprehensions vs hof", or even "how many lines of code (AST nodes?) is this function."  This would require some kind of reflection/introspection, or perhaps just parsing the source file. It occurs to me this might be something that's already available, or at least worth checking on before
13:48:59 <johnw> haskell-src-exts should let you do such analysis, I believe
13:49:04 <johnw> but it won't be trivial work
13:52:25 <sfogarty> johnw, is that likely to be better than Language.Haskell.Parser?
13:52:50 <johnw> haven't used that one!
13:52:59 <geekosaur> it's the old haskell-src package
13:53:05 <geekosaur> which is H98, no extensions
13:53:58 <sfogarty> These are students. I'm not expecting them to use any extensions :)
13:54:06 <geekosaur> and does very little beyond just making some kind of AST which might or might not be useful; in addition to the parser HSE provides a lot of useful stuff to operate on the generated AST
13:54:36 <geekosaur> basically there is very little reason to use haskell-src even if its parser is sufficient for what you're doing; HSE is where all the useful stuff is
13:55:07 <sfogarty> Roger. HSE it is.
13:55:31 <geekosaur> and if you plan to make use of ghc-api with it in any way, HSE can do that, haskell-src can't
13:55:37 <sfogarty> I figured I'd at least ATTEMPT to do this the right way before I just throw a fancy grep at it.
14:06:04 * hackage panic 0.2.0.0 - A convenient way to panic.  http://hackage.haskell.org/package/panic-0.2.0.0 (IavorDiatchki)
14:19:34 * hackage panic 0.3.0.0 - A convenient way to panic.  http://hackage.haskell.org/package/panic-0.3.0.0 (IavorDiatchki)
14:27:04 * hackage reactive-banana-automation 0.5.0 - home (etc) automation using reactive-banana  http://hackage.haskell.org/package/reactive-banana-automation-0.5.0 (JoeyHess)
14:37:07 * hackage panic 0.4.0.0 - A convenient way to panic.  http://hackage.haskell.org/package/panic-0.4.0.0 (IavorDiatchki)
14:43:11 <mjrosenb> so, I heard that I can install ghcjs through nix.  Does anyone know how exactly that can be done?
14:44:34 * hackage data-diverse-lens 4.0.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  http://hackage.haskell.org/package/data-diverse-lens-4.0.0.0 (louispan)
15:01:33 <iqubic> Ertes' foldr tutorial is confusing me. Why does he bother deriving sum as a stateful thing, when you can literally just do "sum = foldr (+) 0"?
15:02:56 <lukelau> jle` dmwit: thanks, adding the explicit type signature fixes it!
15:06:26 <infinisil> :t httpLbs
15:06:27 <lambdabot> error: Variable not in scope: httpLbs
15:06:46 <infinisil> How would I catch an error in this function: https://hackage.haskell.org/package/http-client-0.5.12.1/docs/Network-HTTP-Client.html#v:httpLbs
15:06:57 <infinisil> httpLbs :: Request -> Manager -> IO (Response ByteString)
15:07:14 <infinisil> The function docs don't even mention how errors are handled
15:07:42 <glguy> infinisil: search for the word "exceptions" on that page
15:09:00 <glguy> Because that module's documentation actually spends a lot of time talking about exceptions
15:09:17 <infinisil> Heh why didn't I think of this myself, thanks
15:14:33 <johnw> @tell phadej I heard you asked for an ELI5 intuition of adjunctions. Maybe the special case of a Galois connection would help: We can relate floats to ints in a way that preserves order with "floor" or "ceiling". This means that if order is all we care about, we can turn a float question into an int question and solve it using just "the minimum structure". Adjunctions in this sense are optimizers: they carve out the crux of the
15:14:33 <johnw> particular matter from a richer domain.
15:14:33 <lambdabot> Consider it noted.
15:15:12 <dyl> @tell lambdabot my heart will go on
15:15:12 <lambdabot> Nice try ;)
15:15:28 <dyl> I don’t know what I expected.
15:17:49 <Vyse007> Been trying to understand the ((->) r) monad for a while now. Can't seem to fully grok the idea. Any good explanations of this online?
15:18:39 <johnw> Vyse007: it abstracts the context of "some constant input", or an environment, such that you can easily compose multiple functions that all depend on this same environment
15:19:21 <johnw> to see why it's useful, try to compose two functions manually of type e -> a -> b and e -> b -> c
15:20:11 <mjoldfield> Vyse007: I wrote this about it http://mjoldfield.com/atelier/2014/07/monads-fn.html
15:20:13 <johnw> or rather, a -> e -> b and b -> e -> c, to be a bit more accurate
15:20:41 <Vyse007> johnw: Yeah, I've seen it referred to as the reader monad. Makes sense to me, but when I try to write the fmap and (>>=) instances I always find myself confused. ((->)a) denotes ( a -> e) right? So what would the fmap signature look like?
15:20:54 <aarvar> or you can think of it in terms of join: join :: (r -> r -> a) -> r -> a
15:20:59 <johnw> just substitute each f with ((->) a)
15:21:18 <glguy> Vyse007: (->) a b   is the same as.   a -> b
15:21:38 <aarvar> fmap :: (a -> b) -> (r -> a) -> r -> b
15:21:39 <Vyse007> mjoldfield: Thanks! Looks pretty detailed, might be exactly what I needed.
15:23:36 <dyl> fmap = (.) basically
15:23:44 <Vyse007> Huh. I thought it would be  (a -> b) -> (a -> r) -> (b -> r), which I suppose is what was confusing me.
15:24:08 <aarvar> Vyse007: that function doesn't exist :)
15:24:15 <ph88> should i use readProcessWithExitCode from System.Command or System.Process ?
15:24:37 <aarvar> ((->) r) a = r -> a
15:25:04 <Vyse007> aarvar: Yeah, I realized that as soon as I typed it out the first time lol
15:25:46 <ph88> hhmm System.Process seems to have more support
15:25:47 <aarvar> contramap :: (b -> a) -> (a -> r) -> (b -> r) does exist though
15:26:53 <geekosaur> System.Cmd is quick and dirty stuff. in general I'd use System.Process in programs and System.Cmd if messing around in ghci or etc.
15:27:07 <geekosaur> or for really quick and dirty programs
15:27:24 <geekosaur> (but even then I'd think twice: there is nothing so permanent as a quick hack)
15:27:25 <Vyse007> aarvar: Haven't gotten around to reading about contravariant yet. :(
15:28:37 <tabaqui> cocreature: sorry, again about the flags
15:29:07 <tabaqui> I'm trying to pass ghc-option -DTEST="some_string" in a code
15:29:44 <tabaqui> when I just ghc -DTEST=\"some_string\" it works well
15:30:05 <tabaqui> but when I try to send it in cabal with command line, like so:
15:30:37 <tabaqui> cabal install --ghc-options='DTEST=\"some_string\"' --verbose
15:30:51 <geekosaur> the ''s change it
15:30:54 <tabaqui> I can see that actual value of the macro is just some_string
15:30:56 <geekosaur> you don;t want or need the \s
15:31:20 <geekosaur> and I'm not sure what happens after that because what it would get is kinda broken to begin with
15:31:30 <tabaqui> I've tried many combinations with '"\ but none of them passes " inside
15:32:56 <tabaqui> --ghc-option=-DTEST="string"
15:33:24 <tabaqui> actual flag is '-DTEST=string' inspecting verbose output
15:35:21 <geekosaur> mm, yep. -v3 shows it not doing the right thing early on
15:36:37 <geekosaur> looks like it just strips quotes entirely
15:36:42 <geekosaur> double quotes
15:37:36 <geekosaur> think you file a bug against cabal
15:37:57 <tabaqui> do you know any workaround?
15:38:06 <geekosaur> not seeing one
15:38:11 <tabaqui> ok, thanks
15:38:13 <Tuplanolla> It's a shame there are no digraphs or trigraphs for quotes.
15:39:44 * tabaqui is out
15:40:19 <glguy> tabaqui: Does it have to be on the command line?
15:47:13 <rotaerk> hmm I'm pondering how memory management for interactive programs might be done, to eliminate GC pause as a concern
15:48:24 <rotaerk> the size of your working set impacts the GC pause time, which I *think* is impacted more by the number of nodes rather than the total amount of memory used (although the total amount probably impacts the copying time during GC)
15:48:25 <glguy> In ObjC/Cocoa you can use an autorelease pool where all the memory allocated for a particular request can be released at the end of handling that request
15:48:55 <ph88> does anyone feel in a refactoring mood? i could use some help with this function https://bpaste.net/show/ce0689258dca
15:49:05 <rotaerk> so compact regions are one solution, which reduces the number of nodes, but these have restrictions such as the data must be fully evaluated and immutable
15:49:15 <zincy> Anyone got any ideas on this https://stackoverflow.com/questions/50477398/naive-functional-implementation-of-union-find-disjoint-set-has-poor-performance
15:49:33 <rotaerk> another solution would be manual memory management with malloc and free, for long-lived stuff
15:49:48 <rotaerk> and it can be mutable, even
15:49:50 <Tuplanolla> You can break lines after `let` and `case`, ph88.
15:49:56 <glguy> ph88: start by naming things as new top-level definitions
15:49:58 <Tuplanolla> That's a start.
15:50:09 <rotaerk> but storing non-trivial data structures into this memory ... I'm unclear on how that would work in haskell
15:50:36 <rotaerk> are there utilities for high level manipulation of malloced memory
15:50:52 <rotaerk> hmm oh wait, I guess it is Storable...
15:52:24 <glguy> ph88: and before you start refactoring this, make it typecheck
15:52:34 <zincy> ph88: look at hlint and hindent
16:18:08 <tabaqui> glguy: double-quotes? Well, I wanted it so, but now I have to find another way
16:18:25 <glguy> tabaqui: It works from the .cabal file
16:19:06 <tabaqui> yeah, it's not an option
16:20:41 <tabaqui> the project will be built on some build server and I'm looking for a way to create different versions on the same git commit
16:22:06 <glguy> If there's a fixed set of strings you can put them in the .cabal file behind flags
16:22:20 <glguy> cabal configure -fthisversion or cabal configure -fthatversion
16:25:03 <tabaqui> earlier, I used jinja template and generated Configuration.hs before the actual compilation
16:26:23 <tabaqui> I dunno, currently there are develop, stage, production options, I hope nothing more will be added
16:35:32 <zezeri> hello : )
17:17:43 <met-denise-milan> hi
17:18:12 <met-denise-milan> hi
18:03:54 <Noldorin> Is there such a thing as a "generalised" monad, where the bind function has the type :: ma -> (ma -> mb) -> mb?
18:04:03 * hackage streaming-with 0.2.2.0 - with/bracket-style idioms for use with streaming  http://hackage.haskell.org/package/streaming-with-0.2.2.0 (IvanMiljenovic)
18:04:53 <andreabedini> Noldorin: isn't that flip ($) ?
18:04:59 <andreabedini> :t flip ($)
18:05:00 <lambdabot> a -> (a -> c) -> c
18:05:00 <EvanR> :t flip ($)
18:05:01 <lambdabot> a -> (a -> c) -> c
18:05:05 <EvanR> jinx
18:07:22 <EvanR> :t app
18:07:23 <lambdabot> ArrowApply a => a (a b c, b) c
18:07:24 <Noldorin> andreabedini, right, but I'm thinking of a type class for it, and practical uses...
18:08:18 <andreabedini> Noldorin: I'm not sure what you are trying to express with that type ...
18:08:31 <EvanR> a cartesian category is has the notion of "lambda" and "apply"
18:08:49 <EvanR> not sure if monads are relevant
18:08:57 <EvanR> to that or to your type
18:09:17 <Noldorin> EvanR, they're probably not directly, but I'm thinking of a generalisation of the concept of a monad
18:09:34 <Noldorin> since the monad bind function has type ma -> (a -> mb) -> mb
18:10:01 <EvanR> strictly interpreted, youre talking about x -> (a -> y) -> y
18:10:17 <EvanR> not sure what if anything ma and mb are supposed to be
18:10:31 <EvanR> m a? m b ?
18:11:10 <Noldorin> EvanR, eh sorry, yes. `m` is a monad with type constructor `m`.
18:11:24 <Noldorin> (coming back to Haskell after a long time out here)
18:11:38 <EvanR> Applicative and Functor can be considered generalizations of monads, by losing some requirements
18:11:56 <EvanR> there is such a thing as an indexed monad, which lets you put extra restrictions on the bind type
18:12:48 <Noldorin> anyway, surely it would be a generalisation to take a with its monadic context, and allow the monadic function to determine how to deal with the value, rather than the monadic type class to do the 'piercing'.
18:12:59 <Noldorin> EvanR, normally they're specialisations though... so how do you mean "losing some requirements"?
18:13:11 <EvanR> hmm?
18:13:18 <Noldorin> ignore me
18:13:34 <EvanR> monad is a specialization of the concept of functor
18:13:55 <EvanR> in the same way that prime numbers are special kinds of numbers
18:13:59 <Noldorin> EvanR, I meant specialisation in what they allow you to do (which admittedly is not the common notion of "specialisation")
18:14:02 <Noldorin> right
18:14:25 <Noldorin> what I really mean is "less powerful", not so much "specialisation" in its conventional sense.
18:14:26 <EvanR> what is your notion of specialization
18:14:48 <Noldorin> ^
18:15:03 <EvanR> so you want a further specialization of monads, for more power
18:15:15 <Noldorin> EvanR, correct. according the above type signature, which I proposed.
18:15:22 <EvanR> i still havent processed it
18:15:33 <EvanR> m a -> (m a -> m b) -> m b
18:15:47 <EvanR> or with args flipped
18:15:57 <EvanR> (m a -> m b) -> (m a -> m b)
18:16:23 <Noldorin> mhm
18:16:24 <EvanR> what would the laws be
18:16:44 <Noldorin> hmm, let me think
18:17:20 <johnw> EvanR: "monad is a specialization of the concept of functor"... something about that doesn't sound right
18:17:34 <EvanR> yeah maybe
18:18:00 <johnw> like, I wouldn't say that a field specializing the concept of a monoid, really, even though they're related to the definition
18:18:17 <EvanR> if functor is an OOP class, then monad inherits from it :)
18:18:34 <johnw> sure, in the category of Hask, Monad definitley appears in a hierarchy descending from Functor
18:18:39 <Noldorin> just, I concede that was the wrong choice of word...
18:18:43 <Noldorin> yes*
18:19:05 <EvanR> so in real life, monad is a specialization of endofunctor
18:19:23 <EvanR> which is a specialization of functor haha
18:19:26 <johnw> I'd rather so that a monad is a restricted composition of two functors related by adjunction
18:20:01 <johnw> and sure, the composition of any two functors is always a functor, making a monad also a functor
18:20:17 <johnw> but it's when you say it the other way around, that a monad *is* a specialization of the idea of functors... that's when it gets fishy
18:20:53 <EvanR> my point was that Noldorin isnt trying to get a generalization of monads in the sense of applicative or functor
18:21:22 <Noldorin> EvanR, so thinking about it, left/right identity and associativity should still hold for this
18:21:55 <EvanR> you might be missing categories
18:22:08 <Noldorin> hmm?
18:22:19 <EvanR> m a and m b only tell you the output type (if this is monads-like)
18:22:28 <Noldorin> my knowledge of category theory is rudimentary to saw the least. I forgot most of what I learnt.
18:22:32 <EvanR> but youre trying to develop some kind of apply operator
18:22:49 <Noldorin> say* gah, auto-correct today
18:23:02 <EvanR> so you really need the input types too
18:23:12 <Noldorin> EvanR, which are a and b, no?
18:23:24 <EvanR> a is not an input
18:23:30 <EvanR> its an output
18:23:46 <EvanR> category gives you the input and output types
18:23:51 <Noldorin> okay so what is an input type here?
18:24:16 <EvanR> :t ($)
18:24:17 <lambdabot> (a -> b) -> a -> b
18:24:27 <EvanR> :t app
18:24:28 <lambdabot> ArrowApply a => a (a b c, b) c
18:24:44 <EvanR> (a b c, b) and b are inputs there
18:24:49 <EvanR> ignore the type of ($)
18:26:06 <Noldorin> what does this mean?
18:26:36 <EvanR> not much, i am just speculating on your speculation
18:26:52 <iqubic> What the heck is app? Why is is that useful?
18:27:07 <johnw> ($) is app specialized to (->)
18:27:12 <johnw> so app is the generalization
18:27:14 <Noldorin> oh okay
18:27:18 <johnw> app is the "closed" of a closed cartesian category
18:29:01 <Noldorin> EvanR, I mean, I imagine this concept of generalised monad and bind function working very similar to a normal monad, except the monadic function (formerly just a function returning a monadic type) now take a value of a monadic type for input too, rather than the wrapped type. so it can e.g. pattern match over that monadic value.
18:29:46 <EvanR> :t extract
18:29:47 <lambdabot> error:
18:29:47 <lambdabot>     • Variable not in scope: extract
18:29:47 <lambdabot>     • Perhaps you meant ‘retract’ (imported from Control.Monad.Free)
18:30:35 <EvanR> i meant extend
18:30:49 <EvanR> extend :: Comonad w => (w a -> b) -> w a -> w b
18:31:01 <EvanR> almost...
18:31:39 <johnw> Noldorin: can you give the type of what you're talking about?
18:33:02 <Noldorin> johnw, well, I'm talking about a more powerful extension of a monad (a specification, I think) – in general. do you want a specific example of where this concept / type class might be useful?
18:33:22 <johnw> I want to see the type you're describing as the operation of this extension
18:33:26 <johnw> to see if I recogniez it
18:33:30 <johnw> because I couldnt' follow your description
18:34:30 <jle`> Noldorin: just state what you're trying to say using types
18:34:39 <jle`> instead of paragraphs :)
18:34:48 <Noldorin> jle`, I thought I already did above?
18:34:56 <Noldorin> johnw,
18:35:07 <jle`> your ma -> (ma -> mb) -> ma ?
18:35:21 <jle`> tat's just the type of ($)
18:35:32 <jle`> what you are describing is the "function application"
18:35:37 <EvanR> m a -> (m a -> m b) -> m b
18:35:48 <johnw> that's also identity
18:36:06 <jle`> `m a -> (m a -> m b) -> m a` is alos just function application
18:36:07 <EvanR> presumably there would be constraints somehow on m
18:36:09 <johnw> oh, n/m
18:36:26 <johnw> i mean, if you write it (m a -> m b) -> m a -> m b
18:36:36 <EvanR> yeah i did that above
18:36:37 <jle`> i mean, the constraints aren't 'necessary'
18:36:43 <jle`> because you already have a free function already
18:36:52 <jle`> that function already exists for all m, even non-Functor m's
18:37:03 <jle`> it's even...more general than Functor :O
18:37:03 <EvanR> if you dont have constraints, you cant really do anything with specific m
18:37:20 <jle`> EvanR: (m a -> m b) -> m a -> m b is implementable without any constraints on m
18:37:27 <EvanR> of course
18:37:47 <Noldorin> EvanR, jle` johnw the usual monad laws
18:37:51 <johnw> he's suggesting a type class where you could specialize instances by knowing what 'm' was
18:38:15 <jle`> Noldorin: can you give an example of a specific type where (m a -> m b) -> (m a -> m b) is something other than just foo f x = f x ?
18:38:21 <jle`> what would instances be?
18:38:25 <jle`> Maybe?
18:38:30 <johnw> more specifically, what would the laws be
18:38:39 <Noldorin> johnw, the monad laws
18:38:40 <jle`> what are the "usual monad laws" here?
18:38:47 <jle`> how would the monad laws apply here?
18:38:55 <johnw> Noldorin: then what are you proposing?
18:38:56 <Noldorin> left identity, right identity, associativity
18:38:59 <Noldorin> hm?
18:39:03 <johnw> we already have monads and ($)
18:39:08 <jle`> Noldorin: what left/right identity?
18:39:14 <jle`> Noldorin: can you state the laws specifically
18:39:22 <jle`> because if i just copy and paste the monad law definitions, they don't work
18:39:36 <EvanR> why not
18:40:23 <jle`> they don't typecheck
18:40:53 <jle`> return a >>= f = f a
18:41:00 <jle`> assuming we're still using return :: a -> m a
18:41:10 <jle`> it doesn't typecheck
18:41:17 <jle`> with this new "bind"
18:41:19 <EvanR> perhaps return :: m a -> m a :)
18:41:39 <EvanR> with the restriction that it doesnt do anything
18:41:55 <jle`> the restriction that it is 'id' ?
18:42:10 <Noldorin> (m >>= f) >>= g  ===  m >>= (\x -> f x >>= g)
18:42:17 <Noldorin> for a start
18:42:21 <jle`> in that case, the law is `id a >>= f =  f a`
18:42:30 <jle`> which is saying that >>= has to be ($)
18:42:38 <jle`> and no other definition is allowed
18:42:50 <jle`> *flip ($)
18:43:39 <Noldorin> yeah, you may be right
18:44:57 <EvanR> sounds like a categorical-like result, sounds complicated, the only answer is super trivial :)
18:45:05 <gigagiga> how does ghcjs etc compare to clojurescript? does it produce super efficient code through google closure compiler? is full stack dev as easy? is it as good as elm?
18:45:13 <Noldorin> EvanR, hah, I suspect so.
18:46:56 <jle`> trying to prove that the only implementation of (>>=) that typechecks is ($)
18:47:02 <jle`> but it's a little more convoluted
18:47:26 <jle`> i guess technically there are typechecking definitions for specific m's
18:47:52 <jle`> ah, for Maybe, you can have _ >>= _ = Nothing, and that satisfies those laws.
18:48:14 <jchia1> What is the 'Setup' program in the .stack/ directory with names like this? Cabal-simple_mPHDZzAJ_2.2.0.1_ghc-8.4.2
18:48:19 <jle`> so we need more than just that law to say anything
18:48:20 <jchia1> Is it part of stack, cabal or GHC?
18:49:21 <sclv> the Setup.hs is part of cabal
18:49:50 <sclv> Cabal the library that is
18:49:58 <sclv> it manages the build
18:50:16 <sclv> the ones stack keeps around are compiled versions of the "default" ones for different ghc versions
18:50:17 <jchia1> OK
18:52:34 <Noldorin> jle`, I wonder if there are any useful definitions for >>= under this concept other than flip ($)...
18:52:52 <Noldorin> non-trivial, that is
18:53:27 <johnw> a useful abstraction usually generalizes repetition; trying to go from an invented abstraction to a use case is typically pretty fruitless
18:53:38 <Noldorin> true, johnw
18:53:48 <jle`> i mean, you can implement silly non-trivial ones for any specific monad
18:54:15 <jle`> x >>>= y = y (x >> x >> x >> x >> x >> x)
18:54:18 <Noldorin> jle`, flip ($) should work for *every* monad though, right? and it's probably the only such one
18:54:26 <jle`> the thing i gave also works for every monad
18:54:32 <Noldorin> ah
18:54:47 <jle`> so that's what things like laws are supposed to reject
18:55:06 <jle`> i think the return laws are supposed to prevent this one in particular, but we haven't really said anything about what those laws are
18:55:49 <EvanR> er x >>>= y = y (x >> x >> x >> x >> x >> x) is a silly law? or what
18:55:56 <jle`> EvanR: that's a silly implementation
18:56:01 <jle`> that works for any Applicative m
18:56:10 <EvanR> of what
18:56:11 <jle`> that isn't "trivial" or flip ($)
18:56:28 <jle`> EvanR: of a (m a  -> (m a -> m b) -> m b)
18:56:39 <EvanR> interesting
18:57:16 <jle`> :t \f x y -> f y (x >> x >> x >> x >> x)
18:57:17 <lambdabot> Monad m => (t1 -> m b -> t2) -> m b -> t1 -> t2
18:57:35 <jle`> hm i think i did that wrong
18:58:33 <Noldorin> anyway, as a use case for my "monad+" concept, what about e.g. Maybe computations where Nothing may get mapped to Just x in any step?
18:58:48 <Noldorin> I could definitely think of more use cases
18:58:55 <jle`> what would that definition be?
18:59:08 <jle`> where would the x come from?
18:59:10 <johnw> that sounds more like Const, which is only Applicative
18:59:39 <jle`> Noldorin: can you write that out using pattern matching so we know what you mean?
19:01:44 <Noldorin> johnw, not that I'm aware of...
19:02:21 <johnw> so, how are you going to map Nothing to Just x?
19:02:42 <jle`> where would the x come from? :p
19:02:48 <Noldorin> jle`, well, one such "monadic+ function" could be the function that maps Nothing to Just 1 and Just _ to Nothing.
19:03:02 <jle`> Noldorin: so this doesn't work for all a's
19:03:07 <Noldorin> johnw, jle` well it's the monadic function that creates the x, not the bind operator
19:03:09 <jle`> only for specific a's ?
19:03:24 <johnw> this is all starting to sound like Kafka's take on monads
19:03:26 <jle`> Noldorin: can you write the implementation of your bind operator
19:03:36 <jle`> specialBind Nothing f = ???
19:03:39 <johnw> yeah, I want to see an implementation before going any further
19:03:40 <jle`> specialBind (Just x) f = ???
19:04:20 <Noldorin> jle`, flip ($) works here, I think
19:04:21 <rotaerk> Kafka makes me think of Kefka
19:04:24 <jle`> and if you use `Just 1`, then you already have something pretty different, since your type signature no longer can be Maybe a -> (Maybe a -> Maybe b) -> Maybe b
19:04:31 <jle`> Noldorin: flip ($) doesn't map nothing to Just 1
19:04:32 <Noldorin> johnw, I'd be curious on that. do link me, if you have any resources on it.
19:04:43 <johnw> curious on what?
19:04:44 <jle`> Noldorin: can we see your special bind that would map Nothing to Just x ?
19:04:47 <Noldorin> jle`, I'm not saying it does. but a monadic fn then could
19:04:59 <Noldorin> johnw, Kafka's take on monads
19:05:01 <johnw> I was making a joke.  Reading "The Transformation" gave me a similar feeling to this conversation. :)
19:05:10 <jle`> Noldorin: what is that monadic function?
19:05:18 <jle`> i'm saying that such a function cannot possibly exist
19:05:24 <EvanR> a (m a -> m b) transformation
19:05:27 <Noldorin> oh, I thought there was a language called Kafka... you meant the author :-P
19:05:34 <jle`> oh i see
19:05:45 <jle`> you mean that the (m a -> m b) given would do that, not the special bind
19:05:47 <Noldorin> EvanR, correct
19:05:57 <Noldorin> sorry, I thought I made that clear...
19:05:59 <Noldorin> well, now it is
19:06:10 <jle`> Noldorin: your "monad+" concept seems awfully close to the idea of function application
19:06:21 <jle`> the ability to apply a (Maybe a -> Maybe b) function onto a Maybe a
19:06:22 <EvanR> wait... ($) and flip ($) are both id ?
19:06:26 <jle`> it is realized in function application
19:06:35 <jle`> "function application" is a powerful abstraction, and isn't to be taken for granted
19:06:45 <jle`> but i tink "function application" is the revelation that you are thinking of
19:06:57 <MarcelineVQ> "<johnw> this is all starting to sound like Kafka's take on monads" please, no meat touching ma'am
19:07:05 <Lears> > id (+1) 1
19:07:07 <lambdabot>  2
19:07:15 <Lears> I always knew id was useful.
19:07:25 <Noldorin> MarcelineVQ, meat touching?
19:07:44 <EvanR> > id 1 (+1)
19:07:44 <Noldorin> let me think about this...
19:07:46 <lambdabot>  error:
19:07:46 <lambdabot>      • Could not deduce (Num a0)
19:07:46 <lambdabot>        from the context: (Num ((a -> a) -> t), Num a)
19:07:57 <jle`> Noldorin: think about it -- your idea of a (Maybe a -> Maybe a) that might 'flip a Nothing into a Just"
19:07:59 <MarcelineVQ> just a little reference joke
19:08:02 <jle`> Noldorin: that's a function
19:08:10 <jle`> and the idea of "applying" it to a Maybe a
19:08:13 <jle`> that's function application
19:08:16 <Noldorin> MarcelineVQ, ah. to a line form Kafka? :)
19:08:17 <Lears> > (flip id) 1 (+1)
19:08:19 <lambdabot>  2
19:08:36 <MarcelineVQ> nothing so direct hehe
19:08:40 <jle`> i don't mean to say this to diminish what you are suggestiong; more to say that function application is a very powerful tool that is often taken for granted
19:08:51 <Noldorin> MarcelineVQ, hah, now I'm curious
19:08:58 <Noldorin> jle`, I see...
19:09:09 <Noldorin> jle`, it certainly obeys the usual monadic laws...
19:09:18 <jle`> the ability to take a function like (\case Just x -> Nothing; Nothing -> Just 1)
19:09:28 <jle`> and apply it to "Maybe a" like Nothing or Just 7
19:09:35 <jle`> that is realized in "function application"
19:10:06 <monochrom> Although, you shouldn't use a type variable there.
19:10:48 <Noldorin> jle`, I wonder if any other definitions of bind for this "monad+" concept would be useful though... function application is by far the most obvious useful one, of course.
19:11:40 <Noldorin> jle`, actually, I can think of them
19:11:47 <haskell_noob> <dyl> thanks for the tips, i have two wireshark outputs. I would like to do a diff to see which headers, options are missing from my client? how do i do that in wireshark?
19:12:42 <jle`> Noldorin: also it is still not clear what "the usual monad laws" mean here
19:12:47 <jle`> the monadic laws do not typecheck
19:12:51 <Noldorin> anyway, thanks for your help guys. I'll be back in a little bit.
19:12:53 <Noldorin> jle`, why not?
19:13:03 <jle`> i showed an example earlier with return a >>= f = f a
19:13:07 <jle`> if return :: a -> m a
19:14:05 <iqubic> jle`: I just wanted to say thank you for for helping me grok lenses, traversals, and prisms last night.
19:14:34 <jle`> no problem, i'm glad it was helpful! :)
19:14:59 <iqubic> Question, is it possible to compose lenses so that you can manipulate the head of the list in this data structure:
19:15:08 <iqubic> ([a], b)
19:15:33 <glguy> _1 . _head
19:15:40 <iqubic> I mean, obviously _head is a prism, but would you still be able to compose it in that order.
19:15:57 <johnw> yes
19:16:07 <jle`> _head isn't quite a prism
19:16:14 <jle`> but yes
19:16:25 <johnw> right, it makes little sense to "review" _head
19:16:25 <jle`> or rather i should be asking, "what happens when you try?"
19:16:29 <glguy> In that it's "not a prism"
19:16:34 <iqubic> Why is _head not a primsm?
19:16:40 <iqubic> *prism?
19:16:44 <iqubic> :t review
19:16:45 <jle`> iqubic: prisms are both deconstructors and constructors
19:16:46 <lambdabot> MonadReader b m => AReview t b -> m t
19:16:50 <jle`> like Just and Nothing
19:16:53 <jle`> head is not a constructor
19:17:03 <jle`> [] and (:) are constructors, so there are prisms associated with both
19:17:35 <iqubic> What does the prism for (:) do? Isn't a prism only supposed to have 0 or 1 targets?
19:17:46 <jle`> it has a single (a,[a]) target
19:17:49 <jle`> the fields of (:)
19:17:54 <jle`> or, single or 0
19:18:01 <iqubic> Oh, that's really bizarre.
19:18:07 <jle`> i mean, it's the same as Just
19:18:16 <jle`> for a prism, 'Just x' targets/constructs with the x
19:18:22 <jle`> here you have Cons (a,[a])
19:18:38 <jle`> so `Cons (x,xs)` targets/constructs the (x,xs)
19:18:48 <iqubic> So using the _cons prism you can manipulate either the head, or the tail, or both?
19:19:01 <jle`> using cons you get both the head and the tail if they exist
19:19:08 <Noldorin> jle`, oh sure. it relies on us replacing `return` with `id` in the usual laws
19:19:26 <jle`> Noldorin: yes, and if you replace return with id, then the law is `id a >>>= f = f a`
19:19:38 <jle`> Noldorin: which restricts the definition of (>>>=) to only be flip ($)
19:19:44 <jle`> there is no other possible definition
19:19:50 <Noldorin> hmm, yes
19:20:34 * hackage exp-cache 0.1.0.0 -   http://hackage.haskell.org/package/exp-cache-0.1.0.0 (ChrisCoffey)
19:21:58 <jle`> iqubic: it's the same thing as pattern matching on (:)
19:22:16 <jle`> iqubic: when you do, you get both the head and the tail
19:23:33 <EvanR> you can only get a value out of a list at all, much less the head, if the list is non empty, and its non empty if and only if it was built using (:)
19:24:39 <EvanR> which requires a tail
19:24:47 <EvanR> so there you have it
19:34:55 <hye> @type fmap
19:34:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:35:07 <hye> @type (***)
19:35:08 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:48:49 <EvanR> principle of least surprised did not happen just now when i used Monoid First with a bunch of >>'s insead of <>
19:48:52 <EvanR> and it did not work
19:55:09 <dmwit> It lives! http://dmwit.com/revnes-memmap.png
19:56:26 <dmwit> I can parse INES format ROMS and set up a memory map that should more or less reflect how the NES would have things on startup.
19:57:29 <dmwit> I can also disassemble the PRGs, but no UI for that yet. =P
20:08:20 <jle`> dmwit: congrats :D
20:08:39 <dmwit> Thank you!
20:18:43 <ddellacosta> > In other words, if we see the type a -> a, we know that the corresponding value must be the identity function.
20:18:46 <lambdabot>  <hint>:1:15: error: parse error on input ‘,’
20:18:56 <ddellacosta> oh whoops, sorry lambdabot, meant to quote that
20:19:43 <ddellacosta> in any case, checking my understanding of the above ^ : I can think of trivial examples of functions that take an 'a' and return an 'a' that aren't id, but is that because their types become realized that we can't then say that they have type a -> a?
20:20:33 <ddellacosta> e.g. (\n -> n + 1) is in some sense a -> a, but I guess it's actually really Int -> Int or (Num a) => a -> a huh?
20:21:16 <ddellacosta> sorry, not sure if that's making sense...really I'm just trying to understand how it is that we know that a -> a could _only_ be id
20:22:59 <Nokurn> ddellacosta: a -> a doesn't know anything about a, so it can't do anything with it. Like you said, if you have Int -> Int then you can do anything on the parameter than you can do to an int
20:23:24 <byorgey> ddellacosta: right, (\n -> n + 1) does not have type  a -> a, because something with type  a -> a  promises it will work for *any* type a which the caller chooses
20:23:40 <byorgey> (\n -> n + 1) will not work if I choose to give it, say, Bool
20:23:50 <ddellacosta> Nokurn, byorgey okay thanks, this is helpful
20:24:33 <ddellacosta> I feel like there's something deeper going on here about the generality of type variables that I'm not getting yet, even though intuitively what you're both saying makes sense to me
20:26:54 <sclv> ddellacosta: it helps if you write the full type
20:27:03 <sclv> arguably `a -> a` is not meaningful on its own
20:27:06 <sclv> just like x + 5 is
20:27:12 <sclv> or is not, rather
20:27:25 <sclv> because you don't know what `x + 5` means if you don't know what `x` can be
20:27:38 <sclv> so just like \x -> x + 5 is more meaningful
20:27:42 <sclv> because it says where x comes from
20:27:44 <sclv> so too, in types
20:27:53 <sclv> we need to say where `a` comes from
20:27:59 <sclv> so we write `forall a. a -> a`
20:28:08 <sclv> and "forall" is to types sort of what lambda is to terms
20:28:27 <sclv> in that it lets you introduce something new, bound to a fresh name
20:28:40 <ddellacosta> sclv: ah okay, that last bit is what I needed I think
20:29:41 <ddellacosta> sclv: I'm only really familiar with that kind of quantification in terms of logic--is what you're talking about coming from type theory? Probably a dumb question, but just trying to figure out how to trace this back to logic
20:29:42 <jle`> this is a common confusion
20:29:42 <sclv> in haskell's type system, we can often leave the `forall` implicit (unbound variables get a `forall` inserted at the very beginning of the type), so you don't necessarily see it
20:29:58 <sclv> ddellacosta: this is where logic and type theory intersect!
20:30:13 <jle`> leaving off the forall gives you some ambiguity
20:30:15 <ddellacosta> sclv: gotcha
20:30:20 <ddellacosta> jle`: yeah it's confused me for some time
20:30:27 <sclv> (i.e. curry howard)
20:31:30 <ddellacosta> sclv: aha okay. Yeah I've been familiar with that indirectly for some time but other than stuff like sum types / product types and their correspondence with or / and in logic it's mostly a new thing to me
20:32:02 <ddellacosta> I need a "curry howard" for dummies book or something
20:33:33 <sclv> a lot of people think this is a really good intro: https://golem.ph.utexas.edu/category/2018/05/linear_logic_for_constructive.html
20:33:43 <sclv> erm sorry
20:33:45 <sclv> wrong link
20:33:50 <monochrom> There is a Logic for Dummies. I read it and it's actually fine.
20:33:56 <sclv> http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf
20:33:57 <ddellacosta> sclv: haha, that looks interesting too...
20:33:58 <sclv> that one
20:34:06 <ddellacosta> sclv: thanks! I'll check it out
20:34:10 <ddellacosta> I really appreciate it
20:36:16 <sclv> i tend to think of it as a realization of brouwer's constructive program, which isn't the approach wadler takes. instead its just an extension of the "bhk interpretation" https://en.wikipedia.org/wiki/Brouwer%E2%80%93Heyting%E2%80%93Kolmogorov_interpretation
20:37:41 <ddellacosta> huh...I thought intuitionist logic and Brower's constructivism were the same thing
20:37:51 <ddellacosta> not that I know much about either...haha
20:38:03 <sclv> they are, basically. what i mean is wadler's explanation doesn't go via bhk
20:38:11 <ddellacosta> oh sorry, I was confused
20:39:01 <ddellacosta> well, this is more than enough for me to start with--thanks for all these resources, sclv
20:40:29 <ddellacosta> sclv: although, I will ask a few more questions related to your last point--is the approach you're talking about covered anywhere? Is it important/useful to get familiar with that after reading Wadler's paper?
20:40:55 <ddellacosta> covered anywhere in a survey fashion, I suppose is what I'm asking
20:43:51 <ddellacosta> hmm, perhaps the links at the bottom of that wikipedia page are what I'm asking for
20:45:55 <sclv> i'm partial to this: https://www.illc.uva.nl/Research/Publications/Reports/ML-1991-05.text.pdf
20:46:02 <sclv> might require some prior knowledge :-)
20:46:22 <sclv> oh lol its the same as at the bottom of the wikipedia article
20:55:43 <ddellacosta> sclv: haha, well, good to get confirmation! thanks again for the hel
20:55:44 <ddellacosta> help
21:09:49 <lyxia> ddellacosta: The first three chapters of this thesis are an introduction to logic/lambda-calculus/Curry-Howard: http://gallium.inria.fr/~scherer/phd_thesis/scherer-thesis.pdf
21:10:01 <ddellacosta> lyxia: thanks, I'll check it out!
21:11:49 <ddellacosta> lyxia: huh, unless I'm mistaken (highly possible) this sounds like the question I was asking: "In order to better understand the theoretical underpinnings of this mechanism, we ask:  when is it the case that there is a unique program that could have been guessed, or in other words that all possible guesses result in equivalent program fragments? Which types have a unique inhabitant?"
21:12:10 <ddellacosta> in any case thanks, this looks like a great resource for me to learn more
21:13:29 <lyxia> indeed it is!
21:14:55 <ddellacosta> that's great
21:33:26 <halogenandtoast> I'm having a hard time tracking down what this issue could be. I get the error `Prelude.init: empty list` and I've tracked it down to this line `liftIO $ runRedis redis $ do`, but I don't seem to have any other debug information
21:34:07 <halogenandtoast> basically the error in my logs is `[Error#yesod-core] Prelude.init: empty list @(yesod-core-1.4.37.2-LIseENOYLU27OotkzfbtS:Yesod.Core.Class.Yesod ./Yesod/Core/Class/Yesod.hs:693:5)`
21:36:27 <halogenandtoast> and line 693 is just `    $logErrorS "yesod-core" e
21:36:35 <halogenandtoast> Any ideas on how to get a back trace
21:42:46 <EvanR> man how did you find the code for 1.4.37.2
21:44:46 <EvanR> ah its linked on the hackage page
21:48:10 <EvanR> halogenandtoast: there is one place in yesod-core 1.4.37.2 where "init" is used (rather than ByteString init)
21:48:23 <EvanR> according to grep
21:48:55 <EvanR> i checked the code for Monad.Logger which is where the $logError TH is coming from and didnt see any init
21:49:50 <EvanR> halogenandtoast: resourcesFromString in Routes/Parse.hs ...
21:50:22 <EvanR> perhaps youre triggering explody stuff in a config file which is eventually piped to that yesod function
21:55:07 <cocreature> halogenandtoast: if you compile with profiling support you can run your program with +RTS -xc to get a backtrace on exceptions
21:58:21 <EvanR> hmm yeah the error may not even originate from yesod itself, but some other library
21:58:57 <EvanR> redis...
22:06:08 <cocreature> if "init" wasn’t in base you could also add a HasCallStack constraint and emit a better error message
22:08:36 <halogenandtoast> sorry I was afk
22:09:14 <halogenandtoast> hmm
22:10:29 <halogenandtoast> I have a feeling it has something to do with trying to use a redis url to connect and there not being a username/password
22:10:43 <halogenandtoast> but connecting locally doesn't use a password so that's weird
22:13:59 <cocreature> halogenandtoast: I would recommend to not waste time guessing and just recompile with profiling instead :) you can still guess while things are recompiling (if you haven’t already built your deps with profiling support)
22:14:21 <halogenandtoast> cocreature: yeah I'm compiling with profiling support (I think, haven't done this before)
22:14:33 <halogenandtoast> Basically running: stack build --ghc-options '-rtsopts -fprof-auto -fprof-auto-calls' --executable-profiling --library-profiling
22:14:47 <cocreature> halogenandtoast: just use "stack build --profiling"
22:15:20 <halogenandtoast> my version of stack doesn't have that option
22:15:37 <cocreature> ah sry, "stack build --profile"
22:16:06 <halogenandtoast> okay yeah I see it now, trying that
22:16:18 <halogenandtoast> only 196 more libraries to compile ;-)
22:28:00 <dminuoso> @tell ddellacosta Now try to relax the Applicative constraint. You can do this by merely applying Functor and Applicative laws mecahnically.
22:28:00 <lambdabot> Consider it noted.
22:35:34 <buhman> I'm trying to compare the example usage of and if/then/else expression vs a slightly different function that uses pattern matching in a where binding
22:35:39 <buhman> https://lpaste.net/4754765857391902720
22:36:04 <buhman> I'm not convinced which I like more, or if there's an even better way to express that
22:37:08 <opqdonut> this is the perfect use case for a list comprehension
22:37:08 <delta> whenever I am using `stack build` command it gives this error https://lpaste.net/6288044610556002304
22:37:16 <delta> how to fix this?
22:37:27 <opqdonut> buhman: vals = [x | Just x <- values]
22:37:36 <opqdonut> instead of isJust&fromJust
22:37:46 <buhman> yeah I thought isJust/fromJust was awkward
22:37:52 <marxS> hey
22:39:53 <buhman> https://lpaste.net/3871505059875389440
22:40:16 <buhman> opqdonut: what do you think about "if all (==Nothing)" vs "maybeAverage" ?
22:40:35 <delta> whenever I am using `stack build` command it gives this error https://lpaste.net/6288044610556002304 , how to fix this?
22:42:08 <dminuoso> :t sequence
22:42:09 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
22:42:13 <dminuoso> buhman: ^-
22:42:24 <halogenandtoast> cocreature: for some reason when building with profiling I get `ghc: ^^ Could not load '_NhkReaderzm0zi0zi0zmDKtinjKDPl02EsxhbbvJOU_TypeziSlug_zdfPersistFieldSqlSlug1_closure', dependency unresolved. See top entry above.
22:42:35 <buhman> welp, I don't know about those types yet
22:42:49 <dminuoso> buhman: dont be scared.
22:42:56 <Lears> :t catMaybes -- also this.
22:42:57 <lambdabot> [Maybe a] -> [a]
22:42:57 <uglyfigurine_> What are some major costs of GADTs?
22:43:34 <dminuoso> buhman: Basically this says you can make some `[Maybe a]` into `Maybe [a]` (amongst other things)
22:43:40 <dminuoso> buhman: You could probably also use
22:43:42 <dminuoso> :t traverse
22:43:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:43:58 <dminuoso> Or actually not in this case probably.
22:44:04 <marxS> hey, so I've been learning Ocaml for the past few weeks but the lack of community and libraries is becoming annoying. Would the transition to a pure functional language like haskell be very difficult?
22:44:47 <dminuoso> > sequence [Just 3, Just 4, Just 5}
22:44:49 <lambdabot>  <hint>:1:33: error: parse error on input ‘}’
22:44:52 <dminuoso> > sequence [Just 3, Ju, Just 5]
22:44:54 <lambdabot>  error:
22:44:54 <lambdabot>      • Data constructor not in scope: Ju :: Maybe a
22:44:54 <lambdabot>      • Perhaps you meant one of these:
22:44:55 <dminuoso> > sequence [Just 3, Just 4, Just 5]
22:44:57 <lambdabot>  Just [3,4,5]
22:44:59 <dminuoso> > sequence [Just 3, Nothing, Just 5]
22:45:01 <lambdabot>  Nothing
22:45:02 <buhman> marxS: as a python peasant, I don't feel like haskell is that scary
22:45:41 <marxS> buhman, how convenient does haskell feel though? In Ocaml I enjoyed the fact that I could jump to imperative when I felt it made stuff a lot easier
22:45:45 <uglyfigurine_> marS I am coming to haskell from the java -> scala -> Haskell. It's not too difficult to get started but the language does have a lot of features I have yet to encounter
22:45:48 <marxS> the hybrid-style was nice
22:46:35 <boj> marxS: you can write things imperatively with do-notation, which tends to help
22:46:36 <dminuoso> buhman: Haskell is not scary. The main difficulty people experience is just the radical paradigm shift. Pure and lazy languages are not very common. ;)
22:47:05 <uglyfigurine_> marxS, http://dev.stephendiehl.com/hask/ thats a good blog article for beginners
22:47:15 <marxS> do you guys/girls use haskell for everyday projects?
22:47:16 <dminuoso> I repeatedly hear that if people pick up Haskell as their first language, they find it rather easy.
22:47:21 <dminuoso> marxS: Yes. :)
22:47:22 <marxS> or does it serve as a some-what back up language?
22:47:22 <halogenandtoast> boj: It also tends to hurt when you don't understand how that works with things like Either or Maybe.
22:47:29 <halogenandtoast> Or it did in my case
22:47:33 <boj> marxS: yep, my whole team works with it
22:47:40 <dminuoso> marxS: Its not the silver bullet for anything, but for the vast majority of problems Haskell is surprisingly good.
22:47:53 <uglyfigurine_> dminuoso, i find that the language is huge. So many extensions, so many different ways of thinking. Its not difficult to get started though
22:47:56 <halogenandtoast> IO was easier to understand with do notation, some of the others seems like witchcraft when coming from other languages.
22:48:04 <buhman> marxS: I guess it depends on your goal; I'm seeking the "radical paradigm shift", and not so much "do I feel like I can conveniently express things the same way I've expressed them previously"
22:48:47 <marxS> well my initial goal of learning ocaml stemmed from trying to understand a library
22:48:51 <marxS> but I enjoyed the functional aspects
22:50:17 <buhman> dminuoso: that sequence magic seems encouraging; I think the book starts talking about those types in the next chapter
22:51:33 <cocreature> halogenandtoast: that looks like stack screwed up somewhere. I would try a "stack clean"
22:51:33 * hackage tomland 0.1.0 - TOML parser  http://hackage.haskell.org/package/tomland-0.1.0 (shersh)
22:51:42 <halogenandtoast> cocreature: good call, will try that
22:51:46 <uglyfigurine_> marxS, I also found https://haskell-at-work.com/episodes/ to be a good resource
22:52:07 <marxS> link doesn't work uglyfigurine_
22:52:17 <halogenandtoast> cocreature: and nope :\
22:52:32 <uglyfigurine_> whoops, I just cut it short manually. Its https://haskell-at-work.com/episodes.html
22:52:49 <marxS> I remember we had a first year haskell course at university
22:52:56 <marxS> and when we hit monads, it scared me away for a while
22:52:57 <marxS> lol
22:53:43 <TommyC> Your Uni. actually had a haskell course? Nice.
22:53:56 <halogenandtoast> the relevant line, I believe is `newtype Slug = Slug { unSlug :: Text } deriving (Show, Eq, Read, PathPiece, PersistField, PersistFieldSql)
22:53:56 <uglyfigurine_> anyways, gl with your learning endeavors. im off to bed
22:54:23 <marxS> TommyC, only because the profs teaching the course founded haskell
22:54:24 <marxS> lol
22:54:29 <TommyC> oh lol
22:54:38 <halogenandtoast> marxS: Monads are scary until they are not.
22:54:46 <halogenandtoast> Like most extremely abstract things.
22:54:53 <boj> quite boring once you get them
22:55:57 <halogenandtoast> I mean, my take on why there important to Haskell, is simply that they let you sequence things in a meaningful way
22:56:26 <halogenandtoast> meaningful and pure way
22:56:34 <cocreature> halogenandtoast: hm that’s not good :( I would probably try nuking .stack-work
22:56:43 <halogenandtoast> okay :(
22:58:30 <halogenandtoast> cocreature: yeah didn't work either, it's weird because it first tells me it's building the library 1/16 and builds all 16 modules, then it tries to go through them all again and fails on the second pass
22:59:00 <halogenandtoast> https://gist.github.com/halogenandtoast/ebbbf7236699f58785f3405198538d10
23:02:38 <cocreature> halogenandtoast: the first time it compiles the regular object files, the second time it compiles the object files for profiling (*.p_o)
23:03:03 <cocreature> halogenandtoast: if possible maybe try upgrading to 8.4.2. I vaguely recall some issues with TH and profiling which have been fixed since
23:04:33 <halogenandtoast> cocreature: dumb question, but is there a stack lts image for that?
23:04:39 <cocreature> no
23:04:46 <cocreature> you have to use a nightly snapshot
23:05:00 <halogenandtoast> okay
23:05:26 <halogenandtoast> trying it now.
23:05:28 <dminuoso> uglyfigurine: Absolutely yeah. Haskell has a very high ceiling, but I think learning the basics to write effective code is not hard.
23:05:43 <halogenandtoast> thanks for the help by the way, a lot of this stuff isn't territory I've dealt with yet.
23:06:06 <halogenandtoast> dminuoso: Haskell basically ruined every other language for me.
23:06:13 <halogenandtoast> I keep programming in Ruby and wanting things from Haskell
23:06:43 <halogenandtoast> How do I know if this method can fail? Wait for it to fail.
23:07:25 <marxS> halogenandtoast, are there things you wouldn't use haskell for?
23:07:30 <marxS> apart from the obvious stuff like web dev lol
23:07:38 <halogenandtoast> marxS: I use it for web dev
23:07:45 <buhman> marxS: why not web dev?
23:07:48 <cocreature> lots of people use it for web dev
23:08:03 <halogenandtoast> marxS: I would not use it for graphics programming
23:08:03 <marxS> really lol
23:08:18 <halogenandtoast> Or really anything where you need fine-grain control over memory.
23:08:28 <buhman> marxS: I think ghcjs by itself would fully justify learning haskell for practical objectives
23:08:47 <halogenandtoast> But I wouldn't really use any language with a GC if that were the case.
23:09:16 <cocreature> whether Haskell is a good choice for frontend webdev might be debatable but it’s certainly an excellent choice for the backend
23:09:46 <halogenandtoast> It's great for API backends, because the classes are almost self documenting for the API
23:10:05 <halogenandtoast> When writing an iPhone app they often just sent us the Haskell definitions
23:10:11 <dminuoso> marxS: I'd stay away from Haskell for embedded development if memory requirements are tight.
23:10:27 <dminuoso> marxS: Also Haskell is not the best language for kernel development. But a Haskell kernel has been written before.
23:10:34 <buhman> marxS: https://github.com/dmjio/miso for example is something I'd like to use once I feel sufficiently learned
23:11:18 <marxS> well my original reason for learning ocaml was to understand (and use) this https://github.com/o1-labs/snarky
23:12:03 * hackage graphviz 2999.20.0.1 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.20.0.1 (IvanMiljenovic)
23:12:41 <cocreature> marxS: sounds like you might be interested in https://github.com/gstew5/snarkl :)
23:13:16 <marxS> cocreature, oh this looks very interesting
23:13:18 <marxS> thanks
23:14:31 <halogenandtoast> By the way marxS I think Haskell for a web backend is a really good choice due to type safety and often being forced to account for and manage failure.
23:14:42 <halogenandtoast> It's one of the biggest problems I face as a rails developer.
23:15:03 * hackage streaming-with 0.2.2.1 - with/bracket-style idioms for use with streaming  http://hackage.haskell.org/package/streaming-with-0.2.2.1 (IvanMiljenovic)
23:15:07 <halogenandtoast> Well, the biggest problem I face as a rails developer is other rails developers.
23:16:07 <kuribas> same for python
23:16:52 <halogenandtoast> kuribas: as much as neither side will admit it, but at this point, the two languages are practically the same aside from a few syntax choices.
23:17:09 <halogenandtoast> python does seem to have a lot better math/science libraries though
23:17:14 <kuribas> yeah
23:17:14 <marxS> cocreature, this library is lit
23:17:32 <kuribas> halogenandtoast: ruby seems to be more smalltalk-like
23:17:40 <kuribas> but the differences are superficial
23:17:47 <halogenandtoast> kuribas: most people don't use the smalltalk-like features though
23:18:00 <halogenandtoast> the whole method dispatch system gets really messy
23:18:01 <kuribas> also ruby blocks are more powerful than python lambdas
23:18:18 <kuribas> which can only contain expressions
23:18:34 <halogenandtoast> kuribas: true, but you have list comprehensions
23:18:56 <halogenandtoast> which Ruby still doesn't have
23:19:02 <halogenandtoast> because blocks.
23:19:04 <kuribas> I don't like them so much.  They are overused in python.
23:19:29 <kuribas> That could be because I like HOFs more, as a haskell programmer.
23:19:40 <halogenandtoast> well yeah
23:19:47 <kuribas> like map, filter, reduce, etc...
23:20:03 * hackage connection-string 0.2.0.0 - A library for parsing connection strings.  http://hackage.haskell.org/package/connection-string-0.2.0.0 (GeorgePollard)
23:20:45 <kuribas> halogenandtoast: that also shows another problem with python, that statements aren't expressions
23:20:53 <kuribas> at least lisp got that right
23:22:05 <halogenandtoast> cocreature: more fun...  No instance for (Semigroup DateTime)
23:22:23 <halogenandtoast> that might just mean I need to update that library
23:22:51 <halogenandtoast> ugh, that's the latest
23:23:44 <kuribas> halogenandtoast: doesn't it bother you, dealing with this clumsy code everyday, when you know it can be so much easier?
23:24:40 <halogenandtoast> Given current context, I'm not sure if you're making light of my current issue with Haskell, or my general usage of rails.
23:24:53 <kuribas> rails
23:24:57 <halogenandtoast> Ah well...
23:25:11 <halogenandtoast> I quit programming in rails, I know to technical support at Heroku
23:25:15 <halogenandtoast> *now do
23:25:47 <kuribas> ah
23:26:01 <halogenandtoast> And I'm hoping when I get the itch to go back into programming
23:26:09 <halogenandtoast> that I'm good enough at Haskell to do that for a job instead
23:27:00 <halogenandtoast> Rails is now my fallback (just like PHP was my fallback when I was learning rails)
23:29:04 <kuribas> halogenandtoast: is that a build error you get?
23:29:20 <kuribas> semigroup was added to base in later versions of ghc
23:30:07 <halogenandtoast> Well the long of it is I got an error in Yesod about Prelude.init, but no backtrace. So I tried compiling with profiling, but that failed so cocreature suggested switching to ghc 8.4.2, so now I'm compiling again and apparently the dates library hasn't been updated since 2015
23:30:27 <halogenandtoast> So I'm trying to switch it out now.
23:31:42 <cocreature> halogenandtoast: if you just want to test if 8.4.2 helps at all, just patching it to add the semigroup instance might be easier
23:32:44 <halogenandtoast> cocreature: I don't know the first thing about patching in Haskell, in Ruby, I'd just reopen the class and redefine whatever I want because it isn't compiled.
23:33:14 <halogenandtoast> Is there a haskellwiki page on this?
23:33:22 <kuribas> halogenandtoast: in haskell it means you need to actually change the source.
23:33:29 <cocreature> halogenandtoast: download the source, e.g., using "stack unpack". modify it and point to the modified source in your stack.yaml
23:33:50 <kuribas> monkey patching is not allowed, for good reasons
23:33:56 <halogenandtoast> kuribas: well of course
23:34:15 <halogenandtoast> cocreature: thanks, I will try that if alternative methods don't work
23:35:39 <cocreature> halogenandtoast: it’s not so much about alternative methods not working but about being able to quickly test if 8.4.2 helps at all before you spend the time to replace "dates" by something else :)
23:36:09 <halogenandtoast> Right, I've unpacked it, now I have to figure out how to add a Semigroup instance for DateTime
23:36:12 <halogenandtoast> ;-)
23:36:15 <kuribas> I'd be reluctant to use a package which doesn't work with modern ghc
23:36:42 <cocreature> sure you should probably replace it but that doesn’t mean you should stop everything else right now to replace it
23:37:08 <kuribas> right :)
23:37:13 <cocreature> halogenandtoast: instance Semigroup DateTime where (<>) = mappend
23:37:59 <tdammers> kuribas: the whole SMP issue is kind of common though, I wouldn't dismiss a package for not having fixed that just yet
23:38:56 <cocreature> tdammers: yeah but if that package hasn’t been updated since 2015 and the source repo and home page urls are dead, I probably would dismiss it :)
23:39:32 <tdammers> why is it that people automatically assume that something that hasn't been changed for a few months is broken...
23:39:55 <cocreature> well it _is_ broken with never GHCs
23:40:19 <halogenandtoast> tdammers: I didn't assume it was broken, I compiled, it was broken ;-)
23:40:24 <cocreature> and the fact that it hasn’t been updated for a few years suggests that the maintainer might not be particularly active
23:40:45 <cocreature> ah looks like there’s a repo on github https://github.com/portnov/dates
23:41:15 <tdammers> just saying, sometimes the reason something isn't seeing a lot of updates is because it just works
23:41:51 <kuribas> seems to be popular (29 downloads in the last 30 days)
23:42:15 <tdammers> personally, if something gets updated a lot, first thing I do is check what those updates are, because often enough, a lot of updates just means that the design isn't very good, or that it's still in an unstable state
23:43:05 <halogenandtoast> tdammers: yeah I agree.
23:43:33 <kuribas> tdammers: or it gets lots of feature requests?
23:44:10 <halogenandtoast> kuribas: that sounds a lot like instability to me ;-)
23:44:36 <kuribas> halogenandtoast: dunno.  I am pretty sure I can keep adding to my own libraries indefinitely.
23:44:41 <cocreature> halogenandtoast: adding new features doesn’t need to break existing features
23:46:04 <halogenandtoast> I'm mostly kidding
23:47:36 <halogenandtoast> cocreature: I apparently got to the unpack step and can't figure out how to get stack to look in that directory
23:47:45 <halogenandtoast> I added packages: - dates-0.2.2.1/
23:48:08 <halogenandtoast> because that was my understanding of the documentation, but clearly that is wrong
23:49:30 <halogenandtoast> maybe I need to name it ./dates-0.2.2.1
23:49:31 <halogenandtoast> trying that
23:50:55 <kuribas> halogenandtoast: filing an issue on github could be useful, if the author is still active
23:51:45 <cocreature> halogenandtoast: both should work afaik. what’s the error?
23:54:31 <halogenandtoast> cocreature: /private/var/folders/c8/k9jjjm914bq62nnh7wqpbsyxj29666/T/stack6193/dates-0.2.2.1/Data/Dates/Types.hs:62:10: error:
23:54:34 <halogenandtoast>         • No instance for (Semigroup DateTime)
23:55:00 <cocreature> halogenandtoast: have you added the instance?
23:55:47 <halogenandtoast> cocreature: yes the reason it wasn't working is stupid
23:56:23 <halogenandtoast> cocreature: there was another packages directive further down that I missed.
23:56:30 <cocreature> ah :)
