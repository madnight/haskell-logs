00:02:11 <cocreature> `Guest00000: so you want a version of updateLookup that always returns the old value (if it exists)?
00:02:12 * hackage tasty-dejafu 1.2.0.2 - Deja Fu support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-dejafu-1.2.0.2 (barrucadu)
00:05:08 <`Guest00000> i want good functions
00:06:05 <cocreature> *shrug* if you don’t want to be precise, it’s hard to help you
00:06:51 <`Guest00000> and yes, i want updateLookup which returns the old value
00:07:13 <`Guest00000> it seems it can't be implemented externally to Data.Map
00:07:43 <cocreature> you can implement this using alterF
00:08:40 <cocreature> (,) a is a functor so you can use that for "f"
00:10:59 <cocreature> :t \f k -> Map.alterF (\case Nothing -> (Nothing, Nothing); Just a -> (Just a, Just (f k a))) k
00:11:00 <lambdabot> error:
00:11:00 <lambdabot>     Not in scope: ‘Map.alterF’
00:11:00 <lambdabot>     Perhaps you meant one of these:
00:11:06 <cocreature> :t \f k -> Data.Map.alterF (\case Nothing -> (Nothing, Nothing); Just a -> (Just a, Just (f k a))) k
00:11:07 <lambdabot> Ord k => (k -> t -> t) -> k -> M.Map k t -> (Maybe t, M.Map k t)
00:11:15 <cocreature> ^ `Guest00000
00:12:37 <`Guest00000> >_<
00:16:42 * hackage gi-cairo 1.0.16 - Cairo bindings  http://hackage.haskell.org/package/gi-cairo-1.0.16 (inaki)
00:20:42 * hackage gi-gdk 3.0.16 - Gdk bindings  http://hackage.haskell.org/package/gi-gdk-3.0.16 (inaki)
00:25:45 <`Guest00000> which meaning even is there in returning old value only if deleting it?
00:27:42 * hackage git-vogue 0.3.0.0 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.3.0.0 (ChristianMarie)
00:33:38 <`Guest00000> thanks though
00:34:42 * hackage pronounce 1.1.0.1 - A Haskell library for interfacing with the CMU Pronouncing Dictionary  http://hackage.haskell.org/package/pronounce-1.1.0.1 (NoahGoodman)
00:38:43 <dpyro> is there any simple reduction for: parseUrlPiece t = UU <$> parseUrlPiece t
00:38:46 <dpyro> ?
00:39:36 <cocreature> dpyro: fmap UU . parseUrlPiece?
00:40:52 <dpyro> cocreature: woo it works thanks
00:59:32 <dminuoso> If I want to abort a forkIO'd thread prematurely, would I just `myThreadId >>= killThread` ?
01:14:01 <iron_houzi> Would you bother with sets for membership checking if cardinality is super low (< 5) .. or is there value to expressing your code in terms of set theory in general. I'm new to haskell, so I'm very interested in idiomatics..
01:15:10 <iron_houzi> I guess there's probably not a definitive answer here, but I'm always interested in listening to other opinions.
01:21:12 * hackage hlrdb-core 0.1.1.1 - High-level Redis Database Core API  http://hackage.haskell.org/package/hlrdb-core-0.1.1.1 (identicalsnowflake)
01:22:01 <cocreature> dminuoso: in most cases, I would “just stop executing code”, i.e., have something like "unless cond $ continue"
01:22:17 <osa1> dminuoso: what do you mean by prematurely? killThread just raises an async exception in the thread so there's nothing premature about it
01:22:50 <osa1> ah, I see what you mean. yeah use killThread but make sure to mask exceptions in critical regions that shouldn't be interrupted
01:23:14 <cocreature> in most cases I would also throw a more semantically useful exception
01:23:24 <cocreature> if you don’t catch it, it will still kill your thread
01:23:32 <osa1> right
01:23:38 <cocreature> but you give the caller of the code that throws the exception the chance to do something about it
01:24:01 <cocreature> killing the whole thread isn’t very friendly to consumers of your code :)
01:24:52 <cocreature> iron_houzi: I generally start with Data.Set and then if that part of the code becomes a bottleneck think about whether you can replace it with something that’s better at smaller sizes
01:25:01 <cocreature> iron_houzi: but the overhead of Data.Set is really not so bad
01:25:39 <iron_houzi> cocreature: Thanks, what do you think about the point of expressing your code in terms of set theory.. is that important to you?
01:25:53 <cocreature> iron_houzi: I’m not sure what you mean by that
01:26:32 <cocreature> expressing arbitrary code in terms of set theory seems pretty weird
01:26:37 <iron_houzi> cocreature: Oh .. I mean using the set operators, subset, set difference, union ..etc..
01:26:47 <cocreature> well if you’re operating on sets use the set operators
01:26:54 <cocreature> if you’re not operating on sets, don’t use them :)
01:27:12 <iron_houzi> ok ok ..
01:27:27 <cocreature> maybe I’m misunderstanding the question
01:27:37 <cocreature> iron_houzi: what do you see as the alternative? use lists instead of sets?
01:28:04 <iron_houzi> cocreature: No, it's probably me, not managing to articulate my question.
01:28:23 <iron_houzi> cocreature: Yes, lists would be the natural replacement for me .. or perhaps a Map
01:28:33 <cocreature> well a Map is a very different data structure
01:29:11 <iron_houzi> cocreature: Sure, but I would assume you can convert the Map keys into a list ..
01:29:14 <cocreature> if you want a set of elements, use Data.Set. if you want a key-value mapping use Data.Map. if you want a list of elements, i.e., you care about order use lists
01:29:24 <cocreature> use the data structure that best represents your problem
01:30:28 <cocreature> if you use a list to represent a set (apart from performance problems) whoever tries to understand the code has to guess whether the order matters and whether duplicates are allowed
01:30:53 <iron_houzi> cocreature: Yes, this is a very good point
01:30:57 <cocreature> whereas if I see that some API operates on Data.Set I know immediately that there are no duplicates and the order doesn’t matter
01:50:12 * hackage git-vogue 0.3.0.1 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.3.0.1 (ChristianMarie)
02:06:52 <dminuoso> cocreature: I forkIO a request handler on a network request. There's some early verification going on where I might decide to silently discard the package and not call the users request handler at all
02:07:21 <dminuoso> So my thought was to kill the entire thread because once I detect some failure conditions, there's no reason for the thread to live any longer
02:10:45 <dminuoso> Oh.. I see what you meant. I might as well just throw a simple exception.
02:35:20 <cocreature> dminuoso: why not just use something like "unless (failureCondition) restOfProcessing
02:36:20 <noan> so, I recently upgraded my linux distro, and now my cabal stuff is all screwy when it comes to installing things. Often dependencies fail to resolve with messages like " cannot satisfy -package-id hashable-1.2.7.0-Q2TKVDwk4GBEHmizb4teZ". Performing a --force-reinstalls on explicitly the subdependency resolves the issue, but it's tedious to resolve the tree from the bottom up
02:37:08 <noan> Does cabal store cached versions of dependencies somewhere? I tried completely deleting ~/.ghc and  ~/.cabal and everything in /tmp named cabal, but the issue persisted
02:37:27 <noan> it occurs both with the new-install and install style commands.
02:37:42 <cocreature> noan: try "ghc-pkg list" to see where the packages are coming from
02:39:27 <noan> cocreature, OH MY GOD THANK YOU
02:39:38 <noan> the damn thing even is like "protip use ghc-pkg recache"
02:39:44 <noan> did that, everything seems better now
02:44:42 * hackage clash-ghc 0.99.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.99.1 (ChristiaanBaaij)
02:46:12 * hackage clash-lib 0.99.1, clash-prelude 0.99.1 (ChristiaanBaaij): https://qbin.io/redeem-boc-96n4
03:11:31 <sordinaprime> Hey haskellers anyone familiar with Alga (aka algebraic-graphs on hackage), is there a way to follow edges from a node without having to manually construct an edgelist, or enumerate all possible edges?
03:12:25 <sordinaprime> ie. I'd like something like (Graph a -> a -> [a])
03:14:33 <ZeuPiark> hello
03:26:33 <abdolence[m]> Haskello everyone :)
03:40:00 <xpika> abdolence[m]: hi
03:49:42 * hackage git-vogue 0.3.0.2 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.3.0.2 (ChristianMarie)
04:04:42 * hackage extensible 0.4.9 - Extensible, efficient, optics-friendly data types and effects  http://hackage.haskell.org/package/extensible-0.4.9 (FumiakiKinoshita)
04:04:59 <electrocat> abdolence[m]: that's terrible :p
04:05:42 * hackage simple-vec3 0.4.0.6 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.6 (DmitryDzhus)
04:12:42 * hackage csg 0.1.0.2 - Analytical CSG (Constructive Solid Geometry) library  http://hackage.haskell.org/package/csg-0.1.0.2 (DmitryDzhus)
04:29:32 <abdolence[m]> Aha :)
04:29:42 * hackage sdl2-sprite 0.0.0 - Sprite previewer/animator  http://hackage.haskell.org/package/sdl2-sprite-0.0.0 (ChrisDone)
04:31:42 * hackage sdl2-sprite 0.0.1 - Sprite previewer/animator  http://hackage.haskell.org/package/sdl2-sprite-0.0.1 (ChrisDone)
04:40:12 * hackage api-builder 0.15.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.15.0.0 (Intolerable)
05:01:36 <`Guest00000> how would you call a function :: (a -> (b, a)) -> k -> Map k a -> (b, Map k a) ?
05:06:52 <int-e> :t M.updateLookupWithKey
05:06:54 <lambdabot> Ord k => (k -> a -> Maybe a) -> k -> M.Map k a -> (Maybe a, M.Map k a)
05:07:23 <int-e> (not quite)
05:09:36 <int-e> :t M.alterF
05:09:38 <lambdabot> (Ord k, Functor f) => (Maybe a -> f (Maybe a)) -> k -> M.Map k a -> f (M.Map k a)
05:10:19 <`Guest00000> alterButNotQuite
05:10:37 <`Guest00000> adjustAndGet
05:10:53 <`Guest00000> adjustAndWith
05:11:01 <int-e> :t M.alterF :: (Maybe a -> (b, Maybe a)) -> k -> M.Map k a -> (b, M.Map k a)
05:11:02 <lambdabot> error:
05:11:02 <lambdabot>     • No instance for (Ord k1) arising from a use of ‘M.alterF’
05:11:02 <lambdabot>       Possible fix:
05:11:10 <int-e> :t M.alterF :: Ord k => (Maybe a -> (b, Maybe a)) -> k -> M.Map k a -> (b, M.Map k a)
05:11:11 <lambdabot> Ord k => (Maybe a -> (b, Maybe a)) -> k -> M.Map k a -> (b, M.Map k a)
05:12:08 <`Guest00000> adjustMustExistF
05:13:29 <int-e> :t M.alterF . (\f -> second Just . fromJust . f)
05:13:30 <lambdabot> Ord k => (Maybe a -> Maybe (d, a)) -> k -> M.Map k a -> (d, M.Map k a)
05:13:37 <int-e> mm
05:14:02 <int-e> :t M.alterF . (\f -> second Just . f . fromJust)
05:14:03 <lambdabot> Ord k => (a -> (d, a)) -> k -> M.Map k a -> (d, M.Map k a)
05:15:17 <int-e> anyway, I wouldn't give it a name
05:15:43 <`Guest00000> but  it's a best type for me
05:33:12 * hackage base-prelude 1.2.1 - The most complete prelude formed solely from the "base" package  http://hackage.haskell.org/package/base-prelude-1.2.1 (NikitaVolkov)
05:34:37 * Clint looks around for quchen
05:35:05 <jchia_> phadej: Are you maintaining OneTuple now? There was an email where you asked to take over, but on Hackage, the original author is still listed as maintainer.
05:35:48 <jchia_> I see that the package is still broken for GHC 8.4 but I don't know how I can help seeing that there's no github link.
05:37:08 <cocreature> jchia_: there is this great thing called google which makes it pretty easy to find repos even if there is no github link on hackage :) https://github.com/phadej/OneTuple
05:37:31 <jchia_> cocreature: Yeah, but if he's not the maintainer, then doing something there may lead to nowhere.
05:38:21 <jchia_> If he's the official maintainer, maybe he will link it from the hackage page.
05:38:29 <jchia_> but i only see jack dorsey
05:44:45 <phadej> jchia_,cocreature, no i didn't yet asked hackage admins to give me maintainer bit
05:45:10 <jchia_> phadej: OK
05:46:19 <phadej> and the repo is just to make changes, i guess I made that repo to make a patch to send the author, or something like that. I have 390 repositories atm, I fork a lot :/
05:46:55 <phadej> jchia_: do you need GHC-8.4.1 support there asap?
05:47:29 <jchia_> phadej: It's not urgent. I was going to ask to be a maintainer, but then you said you already asked, so I didn't.
05:47:54 <jchia_> phadej: I mainly need it for the tuple package.
05:49:39 <phadej> jchia_: ok, I'll send the admins a message, https://wiki.haskell.org/Taking_over_a_package says 2-6 week, it's 4 now.
05:51:15 <jchia_> phadej: I see that you maintain a lot of packages. Let me know if you need help with OneTuple.
05:52:00 <phadej> I hope it won't need attention for next 10 years ;)
05:55:20 <phadej> ... though it would be probably nice to rename it to Solo and make it into proper -compat package...
05:55:33 <phadej> but then it will break, `tuple`...
05:56:13 <bas_> Can I ask a modest beginner question?
05:56:14 <phadej> but maybe one can coordinate that with lennart
05:56:17 <phadej> bas_: feel free
05:56:47 <bas_> if I declare I type like so: data Color = White | Black
05:56:58 <bas_> (I am coding up a chess engine)
05:57:57 <bas_> and have another data PieceInstance = PieceInstance Color Piece
05:58:46 <bas_> (assume a Piece type like: data Piece = Rook | Pawn etc)
05:59:52 <bas_> and have a function: lm (PieceInstance Color Pawn) = [Nothing]
05:59:59 <bas_> (it is a holder for now)
06:00:07 <bas_> this does not compile
06:00:25 <bas_> because there is no data constructor for Color
06:01:00 <bas_> However: what am I missing? Since I can write a function that accepts Bool
06:01:08 <cocreature> bas_: you need to pattern match on White and Black
06:01:10 <bas_> and the definition of Bool = True | False
06:01:24 <cocreature> i.e. the constructors of Color rather than the name of the type
06:01:36 <cocreature> just like you need to pattern match on True and False rather than Bool
06:02:00 <bas_> and in a signature it should be okay right
06:02:23 <bas_> so one could write: f :: Color -> Int
06:02:33 <bas_> and then you need two implementations?
06:03:34 <cocreature> f :: Color -> Int; f White = 1; f Black = 2
06:03:42 <bas_> yeah
06:03:42 <cocreature> that’s only a single implementation with a pattern match
06:03:46 <bas_> or
06:03:54 <cocreature> it’s equivalent to f c = case c of White -> 1; Black -> 2
06:03:59 <bas_> f c = 0
06:04:11 <bas_> making it sort of generic?
06:04:18 <bas_> like applying to all cases
06:04:28 <cocreature> right but then you could just make it f :: Int; f = 0 :)
06:05:04 <bas_> haha
06:05:09 <bas_> thank you
06:05:23 <bas_> I come from a java / scala world
06:05:32 <Entroacceptor> if you're not interested in the value, you can even do _, as in your example above
06:05:42 <Entroacceptor> lm (PieceInstance _ Pawn) = [Nothing]
06:05:48 <bas_> ah ja!
06:05:58 <bas_> thank you so much
06:06:09 <bas_> learning haskell is incredibly rewarding
06:44:12 * hackage hOpenPGP 2.7 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.7 (ClintAdams)
06:44:28 <lastmanstanding> I'm trying to learn haskell. I've got some code at https://pastebin.com/jcTCbtzP which is attempting to solve https://www.hackerrank.com/challenges/fp-list-replication/problem
06:44:51 <lastmanstanding> right now I'm getting a compiler error which says that there's a type mismatch.
06:45:09 <lastmanstanding> can someone point out what I'm doing wrong?
06:45:28 <glguy> lastmanstanding: Sure. When you have a question about a type error be sure to include it in your paste, though
06:46:10 <glguy> lastmanstanding: In this case you misunderstood what do-notation is for
06:46:57 <glguy> https://gist.github.com/glguy/1e60cc87fb949f6148c321c1aee83758
06:46:57 <aliqmasilf> how easy is it to scale haskell vertically? i hear it's quite pain in the ass, not as easy as erlang
06:47:12 <lastmanstanding> glguy: sorry. traceback is at https://pastebin.com/Ja3YwFnc. what can I read ro fix my understanding of do?
06:48:01 <glguy> lastmanstanding: Depends on what resource you're using to learn Haskell. In Haskell "return" isn't like in C, it isn't control flow that returns a result from a function definition
06:48:46 <aliqmasilf> how easy is it to scale haskell vertically? i hear it's quite pain in the ass, not as easy as erlang
06:49:04 <lastmanstanding> glguy: ok. I'm using learnxinyminutes.com will be moving on to learnyouahaskell
06:49:20 <aarvar> lyah, ew
06:49:40 <shookees1> haha
06:49:45 <glguy> lastmanstanding: Technically you can use do, but it's kind of missing the point: https://gist.github.com/glguy/1e60cc87fb949f6148c321c1aee83758#gistcomment-2587148
06:50:25 <aliqmasilf> * horizontally i mean, adding more servers
06:50:29 <glguy> lastmanstanding: Hutton's Programming in Haskell 2nd Ed. is worth picking up if you're in the market for a good book
06:50:43 <lastmanstanding> glguy: Ah. I'm still stuck to defining the "how to do it", rather than what needs to get done right?
06:51:00 <lastmanstanding> glguy: thanks for the book ref. I'll pick it up ASAP.
06:52:40 <seanparsons> Is there a sensible way of getting the full path inside dist or dist-newstyle where it's building something to? So that I can incorporate it into a script and without specifying it all manually such that it breaks when anything like the version changes.
06:52:52 <seanparsons> Where it is cabal.
06:53:17 <glguy> seanparsons: the run and new-run commands are good for that. I don't know the answer to your question though
06:54:20 <seanparsons> Ah, not to actually run what's in there, I need the path for something else.
07:00:20 <jhublar> I was thinking I might lean haskell to inform my thoughts otherwise.
07:00:27 <jhublar> Learn, even.
07:02:31 <duncan^> Otherwise what?
07:02:42 <jhublar> Other domains.
07:02:51 <jhublar> in general.
07:02:55 <duncan^> What does that mean?
07:03:08 <jhublar> Experiences inform our perceptions.
07:03:26 <jhublar> they bend the Now like a lens.
07:03:28 <jhublar> Or something.
07:03:45 <duncan^> did you mean to say that you want to learn Haskell to expand your knowledge? Not sure what you mean
07:04:52 <jhublar> No, not expand my knowledge, though, I imagine learning about function control constructs would add a few bits upstairs most certainly.  But, I was thinking -- looking at problems with that paradigm might be interesting.
07:05:17 <jhublar> Would it change my understanding of automating other tasks?
07:05:22 <jhublar> of /modelling/ other problems?
07:05:31 <jhublar> How would that affect how I delegate workloads?
07:05:39 <jhublar> Would I see metrics differently?
07:06:07 <jhublar> I think I would gain insights.
07:06:23 <jhublar> I'm wondering what insights /you've/ gained.
07:06:26 <int-e> .. o O ( it might cure your obsession with buzzwords )
07:06:33 <jhublar> Ah.
07:06:35 <jhublar> There we go.
07:06:42 * hackage smallcheck 1.1.4 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.1.4 (RomanCheplyaka)
07:06:51 <jhublar> It might expand my semiotics
07:08:16 <jhublar> What kind of work do you perform with Haskell, int-e ?
07:12:24 <jhublar> monads sound neat.
07:12:53 <jhublar> seems ideal for test driven development.
07:12:59 <jhublar> ;)
07:17:42 * hackage animate-preview 0.0.0 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.0.0 (jxv)
07:18:09 <EvanR> :|
07:25:42 * hackage ghc-syntax-highlighter 0.0.1.0 - Correct syntax highlighter for Haskell using GHC itself  http://hackage.haskell.org/package/ghc-syntax-highlighter-0.0.1.0 (mrkkrp)
07:32:49 --- mode: ChanServ set +o glguy
07:32:49 --- mode: glguy set +j 5:10
07:33:40 --- mode: glguy set -j
07:54:59 <EvanR> dragon book has not very much on the details of compiling in a garbage collecto
07:55:35 <EvanR> anynody got a reference for garbage collection as it relates to compiling
08:04:24 <jchia_> Can I get some style advice on the use of runExceptT? https://gist.github.com/jchia/4eb956c1244b4829eb1910e0cc55dcd6
08:13:01 <lyxia> it seems overkill if the ambient monad already has fail
08:13:55 <jchia_> lyxia: The reason I'm using runExceptT is so that I can exit early when something like bar produces a Left. Is it overkill?
08:14:35 <jchia_> If I don't do this, I'll need to use case statements everywhere something like bar is used so that Left leads to fail. Is there a better way?
08:15:03 <lyxia> Define   liftEither :: Either String a -> IO a   and you get the same result, without runExceptT
08:22:46 <jchia_> lyxia: Thanks. What about foo3? I've updated the gist.
08:25:02 <jchia_> I didn't define a special liftEither, but made use of Control.Monad.Except.liftEither.
08:25:04 <EvanR> liftEither already exists too
08:25:39 <EvanR> ah but not with String error type
08:26:58 <lyxia> jchia_: yes that looks okay.
08:27:42 * hackage hopenpgp-tools 0.21 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.21 (ClintAdams)
08:39:47 <zezeri> hello :)
08:39:54 <zezeri> Any windows stack users here?
08:40:16 <simon> I upgraded stack from 1.6.5 to 1.7.1 and now I'm getting "Error while parsing $.dependencies - expected Array, Object, or String, encountered Null"
08:40:40 <zezeri> I want to automate my haskell workflow a bit and have a single .bat file that I click and it opens up notepad++, starts ghci etc
08:40:42 <zezeri> so far it works well
08:40:47 <simon> for my package.yaml, that is.
08:41:19 <zezeri> However I want to start ghci with the :set prompt "ghci> "
08:41:29 <zezeri> how can i do this in one go?
08:41:34 <zezeri> usually i go like this:
08:41:39 <zezeri> cmd.exe stack ghci
08:41:45 <zezeri> :set prompt "ghci> "
08:41:48 <zezeri> can i do this on one go?
08:41:50 <simon> zezeri, have you considered modifying your .ghci file?
08:41:54 <zezeri> oh :D
08:41:58 <zezeri> that would be even easier i guess
08:42:27 <simon> there are some pretty neat .ghci files to get inspired from online. :)
08:45:07 <simon> what happened between stack 1.6.5 and 1.7.1 that makes it unable to parse dependencies in my package.yaml?
08:45:32 <zezeri> thank you for the hint, simon :)
08:46:13 <simon> zezeri, you're welcome!
08:47:38 <simon> ahhh, apparently the 1.7.1 stack yaml parser can't handle empty sections.
08:47:44 <simon> I don't know why. :-|
08:54:38 <Boarders> Does anyone know if there is a function like: unionWithList :: (b -> b -> b) -> [(a,b)] -> [(a,b)] -> [(a,b)]
08:54:47 <Boarders> or do you have to go through Map?
08:56:19 <cocreature> Boarders: you probably have to go through Map although rather than changing this specific part of the code to use Map I would recommend to take a look if you can’t change the surrounding code to work on Map as well
08:58:28 <Boarders> good point, I think it actually makes more sense to use a map
08:58:31 <Boarders> thanks
09:00:12 * hackage incremental-parser 0.3.1.1 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.3.1.1 (MarioBlazevic)
09:03:30 <athan> There's probably not an easy way to... trade TMVars, is there? Take this scenario - you're drawing from some `a :: TMVar ()`: `x <- takeTMVar a` - now, you have some other `b :: TMVar ()`, could you possibly trade `b` for `a`, without affecting the present or future value of `a`?
09:03:45 <athan> and furthermore, atomically?
09:05:24 <EvanR> you can retry until both TMVars are full before you do something
09:05:32 <EvanR> not sure if thats what you want
09:06:47 <cocreature> what does “trading b for a” mean?
09:06:50 <EvanR> i mean, that is what will happen if you do do { x <- takeTMVar mv1; y <- takeTMVar mv2; putTMVar mv2 x; putTMVar mv1 y } atomically
09:07:09 <cocreature> it sounds like you want to swap values but that will obviously affect the value of `a` which you say you don’t want to do
09:15:22 <noan> Wonder if I could get some advice about how to compose things... I need to load a bunch of images in Helm via this function: https://hackage.haskell.org/package/helm-1.0.0/docs/Helm-Engine-SDL-Asset.html and as I believe that the end of the provided IO results in the collection/freeing of the loaded image... So I think I need to nest the image creations into each-other. I was considering a chain of tuples essentially to compose them to
09:15:22 <noan> avoid GC. I was wondering if anyone could give me a push in the right direction?
09:16:14 <noan> having a giant series of like, Image -> IO Image, Image -> IO  (Image, Image), etc. I'm concerned this still won't work with my approach anyway
09:17:26 <noan> Oh I guess it doesn't explicitly collect... yet when I tried to <- compose with pure it segfaulted out...
09:17:40 <EvanR> o_O
09:18:20 <noan> I'll give this another try. Pure should be fine in principle no?
09:19:14 <EvanR> segfaulting is not normally a thing, it only happens when you are messing directly and wrongly with FFI, or you are using a broken library that uses FFI
09:19:33 <EvanR> or some other low level unsafe magic primitive
09:20:09 <capisce> noan: "The expected usage would be to use withImage for each image you need to load before running the engine, and then use the images with graphics. Once the engine stops running, the image will then be automatically cleaned up."
09:20:14 <capisce> noan: is that what you're doing?
09:21:50 <noan> EvanR, :D
09:21:55 <noan> capisce, that's the goal yes
09:22:02 <noan> but I'm struggling a little with composition
09:23:05 <capisce> noan: https://github.com/z0w0/helm/issues/119#issuecomment-331312889
09:24:12 * hackage tasty-stats 0.2.0.4 - Collect statistics of your Tasty testsuite  http://hackage.haskell.org/package/tasty-stats-0.2.0.4 (minad)
09:26:34 <capisce> noan: if you have several image assets you'll need to do something like withImage engine "a.png" $ \imageA -> withImage engine "b.png" $ \imageB -> ...
09:27:28 <noan> capisce, <3
09:27:33 <noan> I was afraid of exactly this
09:27:35 <noan> fuck
09:27:35 <noan> okay
09:28:40 <noan> so there's no real way around the huge nesting thing?
09:29:36 <cocreature> noan: there are various ways to get around this, one of the simpler ones is probably https://hackage.haskell.org/package/managed-1.0.6/docs/Control-Monad-Managed.html
09:30:04 <noan> <3
09:30:58 <noan> thanks this is exactly what I needed
09:33:57 <aarvar> or you can just indent your code differently - no more nesting!
09:42:56 <capisce> noan: if not for that managed monad I'd probably have chosen a solution like this: https://pastebin.com/KdgK4EZa
09:43:28 <capisce> well, with the necessary fixes to make it compile
09:58:09 <noan> aarvar, indenting has nothing to do with nesting :3
09:59:12 <aarvar> noan: then I'm sorry to  tell you this, but statements in a do block are all nested :)
10:02:48 <noan> aarvar, actually, you make a good point, indentation in haskell has syntactic meaning and thus nesting and indentation are less extricable than other things at times
10:04:05 <aarvar> noan: I'm more suggesting that worrying about nesting is silly
10:04:37 <aarvar> and that the only real worry is about how your editor decides to format it
10:07:50 <aarvar> It doesn't make much sense to me to say that `do a <- xs; b <- ys; c <- zs; foo` somehow avoids nesting while `xs >>= \a -> ys >>= \b -> zs >>= \c -> foo` doesn't
10:09:41 <Franciman> Hi
10:13:07 <Franciman> I'm writing a program which interacts with a server, so I have a lot of requests and then I wait for responses (most of the time asynchronously) and run a continuation. Is there any pattern in haskell to write code like this in a composable fashion?
10:15:23 <noan> aarvar, the lambda piles just feels more syntactically cluttered
10:15:29 <hololeap> is it possible to rewrite this in terms of foldr/foldl ? http://dpaste.com/3R8B6CQ
10:15:41 <aarvar> noan: they are
10:15:47 <aarvar> but "nesting" isn't the issue
10:18:34 <Franciman> hololeap, probably using foldM ?
10:19:17 <noan> aarvar, pedantry!
10:21:41 <electrocat> Franciman: your question is to general, what do you want to compose? give an example
10:22:36 <Franciman> for example I'd like to write something like:
10:22:44 <Franciman> response <- request
10:22:51 <Franciman> operations response
10:22:55 <Franciman> anotherRequest
10:23:01 <Franciman> and this would be asynchronous
10:23:11 <sedeki> response <- request ?
10:23:16 <Franciman> it's a do, sorry
10:23:22 <Franciman> I thought about a monad, but it's not necessary
10:23:30 <electrocat> do the requests need to be synchronized in any way?
10:24:00 <Franciman> no
10:24:11 <electrocat> then perform every request in a seperate thread?
10:24:17 <Franciman> and if they do?
10:24:26 <Franciman> do need to be synchronized
10:24:48 <srk> possibly mapM join $ mapConcurrently ?
10:25:33 <aarvar> noan: the only thing I'm good at
10:25:41 <aarvar> that and finding ghc bugs
10:26:04 <Franciman> hmm I think I need to think about it further
10:26:07 <Franciman> I'm quite confused
10:28:01 <electrocat> Franciman: are you familiar with haskell's concurrency constructs?
10:28:48 <Franciman> like async, STM and MVars?
10:28:53 <electrocat> yeah
10:29:18 <Franciman> yes, but I'm quite a beginner
10:29:38 <Franciman> I have read simon marlow's book. And wanted to try to do something using concurrency
10:29:42 * hackage animate-preview 0.1.0 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.1.0 (jxv)
10:31:58 <noan> :t withMany
10:31:58 <lambdabot> error: Variable not in scope: withMany
10:37:42 * hackage morte 1.6.19 - A bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.6.19 (GabrielGonzalez)
10:40:50 <glguy> Diagrams question for anyone (or byorgey), what's the correct way to do this https://gist.github.com/glguy/e001971a886b4be22a39209437ae0cc7 Currently I'm hacking it with centerXY and a custom calculated translateY. The point is that I want the center of the diagram at (0,0) so that when I rotate the "house" shape the 4 corners of the square stay in the same place but the "roof" of the house rotates 90 degrees
10:41:27 <glguy> lineFromVerticies doesn't seem to respect the center of my diagram being 0,0, and using centerXY appears to be putting the center at the average of the bounds
10:41:33 --- mode: glguy set -o glguy
10:41:59 <glguy> so somewhere like (0,2.5)
10:42:18 <DigitalKiwi> glguy needing help? has hell frozen over :|
10:42:40 <glguy> Hey, I never claimed not to need help :-p
10:42:41 <DigitalKiwi> I suppose even glguy is mortal afterall
10:43:10 <noan> cocreature, I was reading the documentation a little... it looks like I shouldn't use runManaged for my program, since I have a long-running loop and that apparently risks leaking? Should I look at allocating a massive group of the Managed resources and then perform withMany on my loop to lift it to IO?
10:43:17 <noan> basically something like that?
10:45:59 <DigitalKiwi> glguy I'm going to choose to believe you're only pretending to not know everything for the sake of letting someone else feel good about helping you
10:56:01 <glguy> Well, it looks like I just haven't found quite the right "fromVerticies" function to center things at the origin
11:11:10 <noan> cocreature, nevermind I think I figured out how to do what I want
11:21:29 <byorgey> glguy: you're making things much harder than they have to be, since you already have the vertex coordinates you want, but then you make them into a line (which throws away the absolute position information) and then go through the centerXY and translateY contorrtions just to move them back to where they started
11:21:51 <byorgey> glguy: instead of  strokeLoop . closeLine . lineFromVertices,  try   strokeLocLoop . fromVertices
11:33:56 <glguy> byorgey: Thanks!!
11:35:30 <glguy> I'm just rendering out some solutions to Zhed https://glguy.net/output.svg
11:35:53 <glguy> Is there any support for laying things out on a grid or is mconcatting a bunch of manually translated diagrams the way to go?
11:38:42 * hackage Fin 0.2.2.0 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.2.0 (MatthewFarkasDyck)
11:38:46 <johnw> glguy: the latter works well
11:39:11 <johnw> there's a Grid example out there, but it's not as nice as just translating
11:39:23 <johnw> just remember to alignTL
11:39:43 <johnw> map f xs where f = something # alignTL # translateX xpos # translateY ypos
11:39:55 <johnw> mconcat $
11:40:35 <glguy> What's the alignTL add to the mix?
11:40:56 <johnw> it causes your translation coordinates to have an origin at the top-left, I believe
11:48:39 <glguy> Overall it looks like this https://github.com/glguy/5puzzle/blob/master/Zhed/Picture.hs
11:52:12 * hackage Fin 0.2.3.0 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.3.0 (MatthewFarkasDyck)
11:56:32 <dpyro> is there an operation that will produce a combination from a set of lists? ex. a = [1,2] b = ['x, 'y'] you get [1, 'x'], [1,'y'], [2,'x'], [2,'y']?
11:56:38 <dpyro> erm every combination
11:57:00 <sclv> dpyro: that isn't well typed
11:57:14 <dpyro> would they all have to be of the same type then?
11:57:24 <monochrom> Cartesian product?  liftA2 (,) [1,2] ['x', 'y']
11:57:25 <sclv> for it to work on lists, yes
11:57:37 <sclv> but yes, in general, using the list monad/applicative gives you this automatically
11:57:43 <dpyro> cartesian product is the term i believe, yes
11:57:46 * monochrom is silently changing [1,'x'] to (1,'x')
11:58:06 <glguy> sequence
11:59:07 <glguy> > sequence [[1,2],"xy"]]
11:59:10 <lambdabot>  <hint>:1:22: error: parse error on input ‘]’
11:59:13 <glguy> Oh yeah, types
11:59:27 * glguy goes back to cooking
11:59:46 <dpyro> not related but is there a way to trim down the GHCI prompt? the whole line is taken up by a list of imported module 🤔
11:59:57 <dpyro> thanks, i will try something like that monochrom
12:00:16 <glguy> I put the modules in their own line, the prompt is configurable
12:00:33 <glguy> And colored then so they don't stand out
12:00:55 <dpyro> oooh so sorta like how you can customize a shell prompt?
12:01:01 <glguy> Yeah
12:01:25 <humanoyd> dpyro: :set prompt "> "
12:01:46 <dpyro> ty humanoyd!
12:02:33 <humanoyd> dpyro: you don't even need the quotation marks, it seems
12:02:42 <monochrom> :set prompt "Prelude Control.Applicative Data.Functor Control.Monad Data.Foldable Data.Traversable Data.Maybe Data.Either Data.List> "
12:02:44 <monochrom> >:)
12:03:03 <dpyro> you monster, monochrom
12:03:15 <humanoyd> dpyro: oops, sorry, you do for the trailing space
12:06:02 <simon> what's the point in using Control.Monad.RWS compared to your own composition?
12:07:07 <simon> I seem to happen to want exactly an RWS (R for scope, W for outputting various intermediate code things, and S for something akin to register allocation)
12:12:54 <philzook> I had kind of a neat idea that I'm not sure how to achieve and was looking for some help.
12:13:02 <philzook> Is there a way to write a typeclass instance that matches only on sort of the Rank 2 (forall a. a -> a) (only id) rather than (Int -> Int) for example? Or is there a way to get a value-level type representation for a function like (id, const, swap, fst, etc) that is polymorphic?
12:13:14 <crestfallen> hi where is my .cabal file within stack or do I need to create one somewhere? my system doesn't recognize cabal commands.
12:13:42 * hackage word 0.1.0.0 - Words of arbitrary size  http://hackage.haskell.org/package/word-0.1.0.0 (MatthewFarkasDyck)
12:15:12 <crestfallen> it doesn't appear that I have one
12:15:49 <dmwit> dpyro: https://stackoverflow.com/q/4119730/791604 has more ways to skin your cat
12:16:00 <dmwit> Of course, mine is the only valuable one. ;-)
12:16:33 <dmwit> philzook: Doesn't sound super possible to me, though I may be misunderstanding.
12:17:07 <benzrf|> hello!
12:17:13 <sclv> crestfallen: do you have a package.yaml file?
12:17:29 <sclv> in your project?
12:17:33 <simon> if I have a Writer monad with output of type w, how does it output multiple things? does it assume that w is a Monoid?
12:17:51 <sclv> simon: yes, there's a constraint to force that
12:18:19 <benzrf|> Is it possible to do something like  "class (forall a b. (Foo a, Foo b) => Foo (p a b)) => Bar p"
12:18:46 <simon> so if I am outputting three different things in lists, I could collect them under one newtype and add a Monoid instance for mappend'ing them threeway?
12:18:52 <benzrf|> that is: can i have a class Bar where having "Bar p" allows deduction of "Foo (p a b)" if we also have "Foo a" and "Foo b"
12:19:25 <dmwit> ?tell aarvar My other answer does exactly what you suggest (no GADT, and just have `mkFilter :: FilterType -> IO Filter`). The accepted answer mentions why that's less desirable: it means code duplication, in that every constructor of `Filter` has to have a corresponding constructor in `FilterType`. The GADT has no such duplication -- there is a *single* constructor that promotes any `FilterType` to a
12:19:25 <lambdabot> Consider it noted.
12:19:31 <dmwit> `Filter`.
12:19:34 <dmwit> oh no
12:19:35 <dmwit> ?tell arvar `Filter`.
12:19:35 <lambdabot> Consider it noted.
12:19:46 <dmwit> oh double no, poor arvar
12:20:08 <aarvar> ...
12:20:12 <benzrf|> ahaha
12:20:43 <benzrf|> In particular: I'm doing some really garbage typeclass tomfoolery for fun, and i have my own Category class which is "Category cat k" and then the methods all have a "k" constraint - that is, it lets me put a constraint on the objects of the category
12:20:48 * dmwit waves at aarvar
12:21:12 <benzrf|> but then i want a class for bifunctors, but i want it to be possible to deduce that the bifunctor preserves the constraint
12:21:19 <aarvar> dmwit: I don't see how :/
12:21:27 <aarvar> but whatever, would need a larger example probably
12:21:43 <dmwit> aarvar: You don't see how what? How it avoids code duplication?
12:21:51 <dpyro> dmwit oooh list comprehensions! forgot that was a thing
12:21:56 <crestfallen> sclv, yeah I do .. thanks for responding
12:22:15 <crestfallen> I think I do I saw it yesterday
12:22:37 <aarvar> dmwit: right
12:22:40 <sclv> saw it yesterday1?
12:23:01 <dmwit> aarvar: Sure. Without GADTs, I have `Owner` and `OwnerT`; `Product` and `ProductT`; and `ReportProduct` and `ReportProductT`.
12:23:09 <sclv> like, are you at your console now? you can just look into your project directory and see if it has a project.yaml
12:23:19 <sclv> if it does, that's an "hpack" format file
12:23:30 <dmwit> aarvar: With GADTs, I have just `Owner`, `Product`, `ReportProduct`, and a "T" combinator.
12:23:34 <aarvar> dmwit: do you have the link? I lost it
12:23:39 <sclv> if you do a stack command like "sdist" or "build" it should also generate a cabal file for your project
12:23:40 <crestfallen> one moment thanks sclv yes I'm on my machine
12:23:41 <sclv> that you can use cabal with
12:23:44 <dmwit> aarvar: https://stackoverflow.com/q/49946389/791604
12:24:05 <sclv> (assuming your question is just about a missing cabal file, and not a missing cabal binary)
12:24:24 <aarvar> dmwit: what is "OwnerT"
12:24:28 <crestfallen> I have the executable, and the filename.hs but I deleted .o and .hi
12:24:36 <dmwit> (Well, with some name fiddling, what I actually have is `OwnerT`, `ProductT`, and `ReportProductT`, together with a "T-removing" combinator.)
12:24:41 <crestfallen> sclv, ^
12:24:41 <sclv> (if there's no command named 'cabal' on your system, then you need to install it, from a package manager, or just by downloading the binary from https://www.haskell.org/cabal/download.html)
12:24:56 <sclv> its fine to delete .o and .hi
12:25:00 <aarvar> dmwit: oh, your second answer isn't what I was suggesting
12:25:04 <dmwit> aarvar: It is the argumentless constructor that you pass to `mkFilter` to tell it that you want to make a filter whose constructor is `Owner`.
12:25:12 <aarvar> dmwit: I was suggesting not having the Fitler type at all
12:25:21 <aarvar> and defining Filter to just be the function which does the filter
12:25:31 <aarvar> assuming that's all that's actually done with the value
12:25:39 <dmwit> Ah, right.
12:25:42 <crestfallen> I thought cabal was essential to stack and was included
12:25:52 <sclv> stack makes use of cabal under the hood, yes
12:25:57 <aarvar> so you just have FilterType -> ReportId -> IO (Record -> Bool), or whatever
12:25:57 <sclv> but it doesn't put it on your path iirc
12:26:05 <dmwit> aarvar: Well, in that case, since the question doesn't mention any consumers of filters at all, we may as well use () for that, right? ;-)
12:26:13 <crestfallen> ok thanks working...
12:26:20 <aarvar> right, needs more context
12:26:29 <aarvar> probably an instance of the xy problem
12:26:30 <dmwit> aarvar: It's not at all clear to me what the collection of consumers is. So better to represent the data explicitly as requested, then any consumers you want to write that work with that data can be written.
12:26:49 <dmwit> aarvar: e.g. maybe they want to display filters to the user somehow, or sort them, or store them in a database, or...
12:27:05 <aarvar> just seems like much of the time when I think I may need a GADT, I don't need a GADT
12:27:19 * dmwit nods agreeably
12:33:15 <crestfallen> sclv, it worries me to have both on the system. one doesn't supersede the other would it? it looks like it's installing ghc
12:33:44 <sclv> wait, what are you running that's installing ghc? the apt-get?
12:33:59 <sclv> they can live both on the same system just fine fwiw
12:34:13 <sclv> stack manages things independently of the system ghc
12:34:28 <crestfallen> yeah debian stretch  ' $ sudo apt-get install cabal-install '
12:34:57 <crestfallen> ok cool so looking at my project dir
12:35:09 <sclv> they're two independent ecosystems, basically
12:35:56 <noan> crestfallen, I recommend personally to install via the "generic" haskell platform
12:36:09 <noan> https://www.haskell.org/platform/
12:36:19 <noan> in terms of having a system install
12:36:30 <sclv> the distro managed one is often not the most recent
12:36:37 <sclv> but depending on what you want, that may be fine, or not :-)
12:36:53 <noan> on debian I fear it may be ancient
12:37:01 <noan> on ubuntu 16.04 it was still far too old
12:37:02 <crestfallen> thanks this is just for going through a textbook
12:37:10 <sclv> ok that should be fine then
12:37:25 <sclv> if anything lol an older cabal and ghc are probably closer to what the textbook was targeting :-)
12:37:50 <crestfallen> textbook copyright 2016
12:38:16 <sclv> for real dev purposes in the future you might want something newer, but cross that bridge when you come to it
12:39:00 <crestfallen> yeah thanks. so how do I get the yaml / .cabal files in my project? should I compile again?
12:39:21 <sclv> erm
12:39:35 <sclv> if you don't have yaml files i'm surprised you have a "project"?
12:39:45 <sclv> it sounds more like its just... some files :-P
12:40:20 <sclv> to create a cabal project from scratch you run `cabal init`
12:40:43 <sclv> to do textbook exercises you don't need a project, you can just use ghc --make on files directly
12:41:16 <sclv> if you had an existing stack project, which i thought you did, you'd have a "stack.yaml" and "project.yaml" already, and the project.yaml would be auto-converted to the cabal file
12:41:48 <crestfallen> I was trying to add ghc-options: -O2 to the .cabal file for optimization of the file , as per a member's suggestion yesterday
12:41:56 <sclv> oh
12:42:06 <sclv> you can just compile with ghc --make -O2 :-)
12:42:14 <johnw> also, -O2 rarely actually helps
12:42:18 <sclv> all this runaround lol
12:42:22 <johnw> I've never yet seen it help me over -O
12:42:29 <johnw> and it can hurt
12:42:40 <crestfallen> --make   ok that was what I was missing earllier
12:42:42 <sclv> i've seen it in rare cases, but yeah, just like in gcc it is only sometimes better
12:42:49 <geekosaur> uh
12:42:55 <geekosaur> --make shouldn;t be needed these days
12:42:56 <sclv> the main thing that i've seen that helps, is raising the unfolding threshold
12:43:03 <sclv> geekosaur: o_O
12:43:11 <sclv> i guess depends on the compiler version?
12:43:18 <geekosaur> from ghc7.0 on\
12:43:20 <sclv> (i never learned we didn't need it because its muscle memory)
12:43:50 <sclv> wow thats a long time for me to never learn that i didn't need it!
12:44:18 <wollw> Hmm... Maybe I should be asking in #math but maybe someone can help me here.  I'm struggling to think about the proper way to construct, I suppose, a higher order graph of sets of vertices in a graph and a little confused where to begin.  The end result would be a randomized polygonal mesh with nodes attached to each polygon where each polygon is has links to the vertices that make it up, as well as links to
12:44:19 <wollw> the polygonal neighbors.  I probably need more theory at this point.  Any reading suggestions?
12:45:15 <sclv> what makes it "higher order"
12:45:27 <johnw> edges can be vertices?
12:45:55 <wollw> johnw: pretty much my thought
12:46:12 <wollw> shared vertices would be edges too though
12:46:31 <johnw> this is starting to sound like a closed category
12:47:23 <sclv> wollw: i would think higher-order meant edges could have 2-cells between them, etc?
12:47:33 <sclv> not that edges are literally vertices?
12:47:54 <sclv> i.e. can you have an edge between an edge and a vertex? or just between verticies, and then 2-edges between edges, etc?
12:48:14 <sclv> and can you have edges between 2-edges
12:48:41 <sclv> for an n-graph you typically want something like a simplicial complex, i think
12:49:25 <sclv> but you really can just represent it as a set of nodes, a set of edges between nodes, a set of edges between edges, etc.
12:50:07 <wollw> that's likely the way I'll be going
12:50:10 <sclv> so a potentially infinite list where at each level you have an indexed collection of things that each have two "endpoints" that point into the prior collection of indexes
12:52:02 <crestfallen> so yeah stack ghc --make -O2 file.hs  (and that w/o --make) .. -O2  (that's oh not zero) is an 'invalid option' fwiw
12:52:15 <wollw> Pretty sure Simplicial Complex was the concept I was looking for.
12:52:22 <sclv> wollw: https://hal.inria.fr/hal-00707901v1/document
12:52:44 <sclv> flag complexes, mentioned there, are a simpler version that often suffices
12:52:49 <wollw> Thank you.
12:55:10 <sclv> crestfallen: `stack ghc` doesn't pass flags directly i think
12:58:35 <sclv> i think its something like `stack  ghc -- Bar.hs -O2` but i can't promise that
12:58:42 * sclv is not a heavy stack user
12:59:04 <Welkin> die stack
13:00:01 <crestfallen> thanks I use an old 32bit machine anyway. its fun waiting for the 35? second evaluation.  sclv   die stack? I thought it was the standard .. I'm just learning basic haskell what a rough undertaking
13:00:30 <Welkin> stack is not standard in any way
13:00:47 <Welkin> it is relatively new (came out around 2013/14)
13:01:02 <Welkin> cabal is the build system
13:01:07 <Welkin> and now package manager
13:01:22 <Welkin> oh no, stack came out in 2015
13:01:25 <Welkin> so very new
13:01:48 <crestfallen> well I'm not splitting hairs about it. as long as stack is stable enough to get me through a textbook, right?
13:02:12 <Welkin> stack was once great
13:02:14 <sclv> all its doing in this config is reinvoking the ghc it installed
13:02:19 <Welkin> but the new cabal makes it obsolete
13:02:28 <sclv> and passing the arguments past the `--` directly to it
13:02:28 <Welkin> a lot have moved on to using nix as well
13:02:36 <sclv> so its just a passthrough for a ghc installation at this point
13:02:44 <sclv> and i mean... its fine for that
13:02:51 <sclv> if it works for you and you're learning
13:02:56 <sclv> imho the most important thing is to stay learning
13:03:02 <sclv> and not get bogged down in build tool minutae
13:03:03 <crestfallen> yeah good call
13:03:31 <Welkin> however, you will need to learn how to use cabal
13:03:32 <crestfallen> yeah its how I got haskell on my system. it seems fine for now.
13:03:41 <Welkin> and stack doesn't even hide that from you, because you still use a .cabal file anyway
13:03:45 <Welkin> so it's pretty pointless
13:03:48 <Welkin> like pointer chasing
13:04:00 <crestfallen> what do you mean pointer chasing
13:04:40 <Welkin> a waste of time and resources; extra overhead for no benefit
13:04:47 <crestfallen> I want to learn more math. I found a math student at uc berkeley who wants to learn haskell. so we are starting a club
13:04:53 <Welkin> extra abstraction
13:04:54 <Boarders> I tend to find writing the cabal file is much nicer anyway even if you are using stack
13:05:40 <crestfallen> ok thanks I'll keep it in mind that the new cabal is more pure, if I understand correctly
13:05:49 <Welkin> more pure?
13:05:53 <Welkin> no idea what you mean by that
13:06:06 <crestfallen> just cleaner idk
13:06:21 <crestfallen> I have no idea what I mean by it either
13:07:43 <crestfallen> so if I run $ ghc that is the system ghc and is using cabal right?
13:08:04 <crestfallen> now that I installed it
13:08:13 <wollw> cabal uses ghc, not the other way around
13:08:42 <Welkin> cabal gives you complete control over what you are doing
13:08:42 * hackage animate-sdl2 0.0.0 - sdl2 + animate auxiliary library  http://hackage.haskell.org/package/animate-sdl2-0.0.0 (jxv)
13:08:54 <Welkin> you can use multiple vrsions of ghc for different projects
13:09:04 <crestfallen> btw its $ cabal --version cabal-install version 1.24.0.1
13:09:14 <Welkin> wow
13:09:17 <Welkin> that is OLD
13:09:22 <sclv> for learning its fine imho
13:09:25 <Welkin> we are on cabal 2.2.x
13:09:44 <sclv> like just stay learning, and learn about tools and stuff only as you get blocked
13:09:50 <Welkin> you can at least upgrade it
13:09:57 <Welkin> cabal install cabal-install
13:10:07 <crestfallen> ok cool will do
13:10:31 * [exa] likes the cabal mantras
13:11:20 <crestfallen> I use nam myoho renge kyo .. lotus sutra
13:11:20 <aarvar> Welkin: weren't people using nix before stack?
13:11:27 <Welkin> aarvar: probably
13:11:35 <Welkin> I just didn't know about it until later
13:11:45 <[exa]> nix is that old?
13:11:57 <aarvar> yes
13:12:15 <[exa]> lol 2003 according to wiki
13:12:50 <aarvar> I think I first tried nixos in 2014 or 15, before going back to arch for a while
13:12:56 <[exa]> it wasn't getting much coverage until around 2016 tbh
13:12:57 <aarvar> now back on nixos
13:13:13 <[exa]> (arch is a mess)
13:13:22 <aarvar> so I've heard
13:13:28 <noan> syntactically speaking, what's the "nice" way to compose nested Monad stuff?
13:13:43 <aarvar> noan: depends really
13:13:47 <noan> Basically, I have a function that I need to perform some IO and then produce some Non-run Managed resources.
13:13:51 <aarvar> but mtl and classy optics is a start
13:13:53 <noan> Ie, I need IO Managed a
13:13:54 <Welkin> compose what exactly?
13:14:02 <Welkin> what is nested monad "stuff"?
13:14:05 <Welkin> monad transformers?
13:14:21 <aarvar> noan: Managed has an instance of MonadIO
13:14:26 <Welkin> liftIO
13:14:29 <[exa]> noan: I always make a tiny class just for surviving the one nesting I need
13:15:49 <noan> I don't entirely understand. Like, my function will start by performing simple IO, basically I need a bunch of things that are just IO FilePath
13:15:59 <aarvar> :t liftIO
13:16:00 <lambdabot> MonadIO m => IO a -> m a
13:16:00 <noan> then I need to use the FilePath values to create managed
13:16:07 <aarvar> liftIO :: IO a -> Managed a
13:16:15 <noan> oh, I can lift an IO -> TO a managed?
13:16:28 <aarvar> yes
13:16:56 <noan> so then I can just basically liftIO $ getFileName "Blah" and I end up here with Managed a
13:16:58 <Welkin> you can use explicit `lift` as many times as you need to unwrap any layers of your monad stack
13:17:00 <noan> right?
13:17:06 <aarvar> yes
13:17:07 <Welkin> liftIO is nice because it automates that for you
13:17:12 <noan> thanks
13:17:21 <crestfallen> slightly off topic..
13:17:22 <noan> I was like "But lifting my Managed to IO isn't what I want at all"
13:17:51 <ni291187> hey
13:18:03 <aarvar> getFileName and such should really be generalized to MonadIO in the first place though
13:18:09 <crestfallen> I work at a major cs university ucBerkeley. why has it been so hard for me to find haskell people? I've even put up flyers... :)
13:18:32 <aarvar> because cs education is mostly bs?
13:18:35 <aarvar> (random guess)
13:18:56 <wollw> crestfallen: try UCSD?
13:18:56 <[exa]> crestfallen: don't worry it's the same everywhere
13:19:03 <Welkin> I would never study CS at university
13:19:11 * wollw still needs to finish a degree there...
13:19:17 <aarvar> lol, I tried to tell my classmates to try haskell and they were like "but all the jobs are in Java"
13:19:35 <wollw> in VisArts, funny enough
13:19:38 <crestfallen> wow, actually that is encouraging aarvar  !  I don't study cs I work for an unrelated science dept
13:19:49 <Welkin> yes, most cs curriculum is all java and oop and outdated crap that has nothing to do with actual computer science
13:19:56 <aarvar> crestfallen: granted, this was at a community college
13:20:07 <[exa]> crestfallen: from the 20% of the students that are able to pass the whole bachelor course here, around 5% are willing to think outside their current favourite programming language, and 0.5% can survive trying to wrap around the monads
13:20:15 <sclv> crestfallen: berkeley's cs department is very not-fp compared to other departments
13:20:19 <aarvar> but we learned how C++ and Java are the only languages used in industry
13:20:32 <sclv> its really much more electrical engineering oriented, or it was years ago at least
13:20:37 <sclv> i don't think it evolved that much
13:20:40 <[exa]> aarvar: you mean c# and java? :]
13:20:48 <aarvar> no, I mean C++
13:20:50 <sclv> its a systems department :-)
13:21:10 <Welkin> even engineering is a terrible course to study in university
13:21:10 <aarvar> [exa]: C++ is for the good programmers, while Java is for the ones that aren't good enough to write C++
13:21:13 <aarvar> is what we learned
13:21:17 <[exa]> wow.
13:21:23 <crestfallen> anyway dang, its all above me. I love learning haskell and a little math here and there
13:21:23 <aarvar> wow indeed
13:21:28 <Welkin> it's mostly focused on made-up/outdated "industry"
13:21:38 <Welkin> and I did study electrical/computer engineering
13:21:40 <Welkin> o.o
13:21:45 <Welkin> should have gone for pure physics
13:21:46 <aarvar> [exa]: also, haskell is really slow and terrible, so don't mention it
13:21:47 <Welkin> or something else
13:21:55 <crestfallen> I studied English
13:22:01 <aarvar> definitely don't mention that you could do all the assignments in a fraction of the time in it
13:22:08 <wollw> C++ and Java is even what UCSD's Computing and the Arts program introduces.
13:22:16 <aarvar> that would be comparing apples to oranges, because C++ is really fast
13:22:44 <Welkin> your programs run really fast, it just takes forever to write them, and they are wrong
13:22:48 <Welkin> in c++
13:22:51 <aarvar> and the C++ compiler writers are geniuses, and the haskell ones not so much
13:23:15 <[exa]> yes, c++ compiler writers do black magicks without publishing
13:23:17 <Welkin> slow c++ is easy to write too though, lol
13:23:35 <aarvar> well, they never mention that high level C++ is going to be slower than high level haskell
13:23:41 <Welkin> have you see nthe terrible standard library?
13:23:45 <aarvar> because of course they think their super fast C++ is already high level
13:23:53 <edwardk> fwiw- my college experience also had that c and java feel. and my math degree was done at a university that didnt believe in category theory
13:23:58 <crestfallen> I have this idea. to master haskell and some discrete math, even if it takes me years, and not worry about jobs and such
13:24:16 <aarvar> edwardk: like, believed it was abstract nonsense?
13:24:21 <[exa]> edwardk: so they were into homotopy?
13:24:24 <edwardk> yep
13:24:25 <aarvar> lol
13:25:04 <edwardk> nah more into teaching high school teachers -- who needed to have a masters in order to comply with the new laws at the time
13:25:07 <aarvar> edwardk: how did you survive?
13:25:31 <monochrom> Oh so yesterday I came up with this ridiculous theory of why these inferior languages are so popular and so many jobs.
13:25:40 <edwardk> graduated fast enough that they didnt know what to make of it and then let me do whatever i wanted
13:25:43 <aarvar> edwardk: the community college requires masters degrees...but not in the same subject
13:25:45 <[exa]> monochrom: please elaborate. :D
13:25:47 <Welkin> worse is better, popular things are popular because they are popular
13:26:03 <Welkin> just like the rich get richer, the poor get poorer
13:26:11 <aarvar> I had two cs teachers with masters in education, and one with a masters in psychology
13:26:15 <aarvar> lol
13:26:43 <[exa]> ok regarding the language choice
13:26:45 <aarvar> Welkin: no, the rich are succesful because they're geniuses. Haven't you heard?
13:26:49 <monochrom> Precisely because they're horrible, the companies that chose them now have to hire more people to fix the problems and get it to work. Employment opportunities balloon.
13:27:09 <aarvar> monochrom: pretty sure I've said that before
13:27:15 <edwardk> to be fair i taught in the cs department with a masters in math while i was getting my masters in cs. they could let me teach because i had that random piece of paper
13:27:15 <Welkin> "opportunities" is an interesting way to phrase it
13:27:24 <Welkin> more like they need more dumb slaves
13:27:31 <aarvar> edwardk: I'd rather have someone with a degree in math than cs
13:27:49 <aarvar> but yes, the whole credentials thing is generally silly
13:28:17 <aarvar> I should add that these teachers also couldnt program :)
13:28:23 <Welkin> or teach?
13:28:37 <aarvar> or teach
13:28:55 <aarvar> well, they were okay at teaching completely incorrect things
13:29:16 <edwardk> meh i think there is a real bar to clear when it comes to teaching proper computer science. so many folks who come in from outside (or even inside the discipline frankly) really couldn't use the master theorem to save their life.
13:29:19 <aarvar> like, catch every exception immediately and then print an error or something
13:29:28 <[exa]> last time on c++ class I was hating how java stuff needs a check before almost each access to variables, and one student asked if haskell checks whether the value is a thunk everytime
13:29:32 <aarvar> make sure to wrap every new statement in a try/catch to catch out of memory exceptions!
13:30:03 <[exa]> and kindof pointed out that strictness analysis is a bit more complicated than nullability analysis
13:30:23 <Welkin> have lil wayne teach computer science
13:30:30 <monochrom> I can't use the master theorem to save my life. OTOH I think the master theorem is pretty weak in the first place, it isn't adequate to save anyone's life.
13:31:15 <[exa]> monochrom: no one can even remember the master theorem, the stuff is usually easier to prove on the spot
13:31:19 <crestfallen> what about my ^ plan ? more and more, even with excellent help here, I'm worried I can't learn this stuff alone
13:31:39 <wollw> Not caring about the master theorem is I think what lead me away from CS and more toward Math in the first place.  Haskell only sealed the deal.
13:31:39 <monochrom> Yeah, ad hoc techniques actually work better for this.
13:31:40 <edwardk> i mention it mostly because so many people get through a cs degree with no more an understanding of complexity theory than 'searching costs a log, right?'
13:32:03 <monochrom> Heh
13:32:12 <Welkin> that's because it's not really computer science
13:32:16 <aarvar> lol, we also learned that O(n/2) is faster than O(n)
13:32:21 <Welkin> there are at most 2 classes in computer science
13:32:26 <Welkin> everything else is programming or software engineering
13:32:38 <[exa]> aarvar: lol
13:32:43 <edwardk> aarvar that is a professor worth firing
13:32:54 <aarvar> average case for linear search is O(n/2) while worst case is O(n)
13:32:54 <[exa]> the O is the same don't you see? :D
13:33:02 <sclv> crestfallen: I and many others learned it alone, with some occasional help from irc :-)
13:33:03 <aarvar> edwardk: to be fair, he was an adjunct, at a community college
13:33:05 <aarvar> not a professor
13:33:14 <aarvar> that was the one with the masters in psychology
13:33:26 <Welkin> big O is pretty useless anyway
13:33:37 <Welkin> it doesn't take into account the actual hardware
13:33:42 <[exa]> Welkin: it's a great way of communication
13:34:05 <edwardk> aarvar daying the expected number of elements visited is n/2 is valid. talking about O(n/2) is sloppy thinking
13:34:12 <edwardk> er saying
13:34:14 <[exa]> Welkin: and getting the actual "best speed on hardware X" is reducible to NP
13:34:26 <Welkin> not at all
13:34:33 <Welkin> just design for the hardware
13:34:36 <EvanR> so uh
13:34:37 <aarvar> edwardk: right
13:34:38 <Welkin> use the cache efficiently
13:35:05 <sclv> so thinking O(n) is diffrerent than O(n/2) is a great example of why mathematics should be more explicit about scoping and variable binding
13:35:06 <EvanR> ExceptT (RWS vs RWST (Either...
13:35:06 <aarvar> he had O(n/2) on the slide, and was supposedly explaining big-O
13:35:22 <aarvar> sclv: yes, what the heck is n
13:35:22 <edwardk> welkin: which cache? i do plenty of stuff cache obliviously because optimizing for one cache necessarily suboptimizes for all the others
13:35:25 <aarvar> where is it bound
13:35:30 <aarvar> x^2 is not a function
13:35:31 <aarvar> etc
13:35:44 <[exa]> Welkin: the question is "how can you know your cache optimization is optimal"
13:35:50 <Welkin> I guess you can't
13:35:53 <Welkin> it's all empirical
13:35:55 <[exa]> Welkin: also "didn't you forget about the magic instruction X"
13:36:33 <edwardk> big o notation is quite useful when problems get large or to tease apart behavior as they tend in that direction
13:36:36 <aarvar> why don't we write integral (\x -> 2 * x)
13:36:37 <[exa]> what I wanted to say is that there are people working on getting rid of the O notation by something more hardware-related, but they failed
13:36:41 <[exa]> (so far)
13:37:01 <sclv> integral when written longhand at least explicitly binds the variable somewhere
13:37:12 * hackage plot-light 0.4 - A lightweight plotting library, exporting to SVG  http://hackage.haskell.org/package/plot-light-0.4 (ocramz)
13:37:15 <noan> on the topic of uni
13:37:17 <aarvar> sclv: the dx right?
13:37:23 <aarvar> but then you throw that away when you compute it!
13:37:28 <monochrom> Mathematicians are using a convention started 300 years ago when math and physics were very close (like, Newton would both a mathematician and a physicist), and these "y is a depedent variable, meaning it is a function of the independent variable x" makes more sense in physics, because y also depends on a million other variables but they are not your focus right now.
13:37:32 <aarvar> and now somehow you have an expression rather than a function
13:37:40 <edwardk> exa: you can teach -calculus- through big O notation instead of the usual limits. Knuth is a big fan of that approach, btw
13:37:43 <opqdonut> EvanR: ExceptT RWS a is r -> s -> (s,w,Either err a)
13:37:55 <aarvar> dependent variables are nonsense
13:37:56 <noan> here's some comedy for you all. I live in Göteborg. The city where this guy teaches: https://en.wikipedia.org/wiki/John_Hughes_(computer_scientist)
13:38:01 <aarvar> death to dependent variables
13:38:01 <monochrom> But evidently now that we have nailed predicate logic, it is no longer very logical.
13:38:02 <[exa]> edwardk: like replacing limits by O ?
13:38:05 <crestfallen> sclv, I have zero experience as a programmer
13:38:17 <noan> Haskell is basically a mandatory component of CS in uni here. There are I believe 0 haskell jobs.
13:38:19 <edwardk> exa yeah
13:38:24 <aarvar> My calc homework was full of let y = f(x)
13:38:30 <opqdonut> EvanR: RWST Either a is r -> s -> Either err (a, s, w)
13:38:31 <edwardk> drops in for the epsilon delta proofs etc
13:38:41 <noan> Everyone I talk to about it seem completely put off about it and irritated by things like purity
13:38:42 <sclv> crestfallen: you got frustrated by confusing ways to invoke a compiler. that's like the canonical programmer experience!
13:38:44 <noan> "I JUST WANT MY LOOPS"
13:38:49 <opqdonut> EvanR: so in the former fail doesn't update state, while in the latter it does
13:38:52 <Welkin> noan: toucan sam?
13:38:52 <[exa]> edwardk: that sounds brutal, going to show students next year to see what will their faces look like
13:38:54 <monochrom> I do the reverse of Knuth's. I teach big O through limits :)
13:38:57 <opqdonut> EvanR: errrr except the other way around...
13:39:03 <EvanR> opqdonut: .....
13:39:04 <EvanR> ;_;
13:39:04 <aarvar> noan: great, fail them all
13:39:11 <Welkin> isn't that also a name for a drug?
13:39:14 <aarvar> it's like physics majors complaining about calculus
13:39:35 <edwardk> exa; i took an entire nonstandard analysis class that was taught this way. the professor had always wanted to try
13:39:44 <noan> aarvar, the thing is, the do the bare minimum to get through the course, but in the real world they're just like LOL NO HASKELL
13:39:52 <noan> I live in a city of c# and java.
13:40:03 <Welkin> why would you want haskell jobs?
13:40:04 <EvanR> opqdonut: yeah i'd like fail to not update state
13:40:07 <aarvar> noan: dont all cs majors do the bare minimum?
13:40:11 <Welkin> imagine if haskell was as popular as javascript
13:40:11 <noan> Welkin, because I want to write haskell
13:40:11 <aarvar> that's what cs is for right?
13:40:18 <Welkin> then by definition it would be a terrible language
13:40:22 <Welkin> because to be popular, it has to be bad
13:40:31 <edwardk> noan: i live in the real world and write quite a bit of haskell out here
13:40:32 <noan> aarvar, I dunno, I never studied it
13:40:37 <Welkin> noan: writing haskell for someone else is not as fun as writing it for yourself
13:40:41 <aarvar> edwardk: but you're special!
13:40:43 <Welkin> any time something becomes work, the fun is gone
13:40:48 <noan> Welkin, I might be more fun that writing scala for them.
13:40:54 <aarvar> (and if you're not, find me a haskell job plz)
13:40:54 <noan> it*
13:41:11 <noan> edwardk, okay, but how many require me to not relocate?
13:41:17 <edwardk> aarvar; shoot me a resume in email
13:41:19 <[exa]> edwardk: do you have some slides or material from the class?
13:41:34 <edwardk> exa: i might have a folder full of class notes
13:41:38 <aarvar> edwardk: oh, forgot to mention, it's blank xd
13:42:04 <noan> edwardk, aarvar's CV is just a piece of paper with a mathematical proof on it and the words "Just read the type signature."
13:42:08 <edwardk> aarvar: write some more open source stuff -then- swnd me a resume then ;)
13:42:14 <[exa]> edwardk: or maybe possibly some links to definitions/theorem lists if they are already on the web
13:42:17 <crestfallen> sclv, I wasn't frustrated really. I just had it wrong as usual. I have a mental problem. I always think the actual code is way more difficult/complex than it is. As if I superimpose complexity on stuff and cannot see it for what it is
13:42:25 <edwardk> typing on my phone. apologies for all the typos
13:42:26 <noan> edwardk, you have remote haskell positions open possible?
13:42:44 <sclv> crestfallen: it was just a joke about the amount of programming that is wrangling with getting things to work or reading docs, as compared to writing code
13:42:45 <aarvar> edwardk: can I just write "understands a reasonable amount of type theory and FP and mathy shit" on it?
13:42:49 <aarvar> I guess not
13:43:05 <[exa]> aarvar: "can work with simple symbolic logic"
13:43:09 <aarvar> lol
13:43:11 <aarvar> ew, logic
13:43:19 <aarvar> just a degenerate form of type theory
13:43:28 <[exa]> don't scare the workers! :D
13:43:31 <edwardk> noan: frankly, i don't believe in hiring for more junior positions remotely. it's really hard to teach someone when they aren't in the office with you.
13:43:33 <wollw> Doesn't it take logic to evaluate types?
13:43:44 <edwardk> noan: i've just never seen it work out well
13:43:47 <Welkin> "expert in Microsoft Word, Excel, and Powerpoint"
13:43:51 <aarvar> wollw: na
13:44:05 <[exa]> Welkin: heck, excel can run neural nets
13:44:09 <sclv> right. the more senior the dev, typically the more independent you can expect them to be
13:44:13 <wollw> Maybe I'm using an overbroad definition of logic.
13:44:28 <Welkin> https://en.wikipedia.org/wiki/Logic_(musician)
13:44:30 <Welkin> the rapper?
13:44:34 <wollw> I hope not.
13:44:36 <edwardk> its hard enough when you're hiring the king of their field remotely, to try to get them to integrate with the rest of their team
13:44:37 <noan> edwardk, fair enough. I have a lot of haskell to learn, although I would consider myself an otherwise competent developer :3
13:44:39 <aarvar> a proposition is just a type of homotopy level 1 (or -1, depending on how you want to count), what's the problem?
13:44:49 <monochrom> No! Logic is a degenerate form of probability theory!
13:44:50 <crestfallen> sclv, yes thanks I really appreciate your insight. I waste a hell of a lot of time with that. I am a master procrastinator. how do you really hunker down and focus? I've never gained that discipline except in athletics
13:44:58 <aarvar> (it is 1 right?)
13:45:04 <wollw> monochrom: what if i don't believe in random chance?
13:45:18 <Welkin> wollw: the universe doesn't care
13:45:26 <Welkin> the universe don't give a shit
13:45:27 <aarvar> everything is degenerate category theory!
13:45:28 <wollw> agreed
13:45:38 <Boarders> aarvar: if you want to get into doing stuff professionally then for your first gig you probably shouldn't worry too much about how hip your colleagues are to haskell and dependent types and infinity,1 categories
13:45:48 <monochrom> You can go Bayesian. It's a theory. You apply it to whatever that fits the axioms.
13:45:54 <aarvar> Boarders: but then I'll die
13:46:12 <aarvar> don't make me write scala
13:46:20 <noan> aarvar, DO YOU WANT JOB OR NOT
13:46:21 <[exa]> lol scala
13:46:25 <noan> I CAN GIEB YOU SCALA JOB NOW
13:46:26 <wollw> monochrom: thanks
13:46:26 <noan> PLS TAKE
13:46:28 <Boarders> it is hell but just aim for an escape path after 3-6 months once you've learnt what there is to learn from the setting
13:46:29 <edwardk> aarvar: where are you located?
13:46:34 <Cale> aarvar: Category theory is degenerate everything?
13:46:43 <aarvar> edwardk: seattle-ish
13:46:49 * wollw falls back on the four humors.
13:47:22 <edwardk> try to talk tony into getting you down to QFPL in brisbane or something. you guys see eye to eye on a lot of stuff
13:47:27 <Welkin> black bile, yellow, blood, and phlegm?
13:47:50 <aarvar> edwardk: do I want to move to australia?
13:47:55 <[exa]> noan: anyway, the trick with haskell jobs is that you can write haskellish in any language
13:48:05 <edwardk> then i got nothing
13:48:12 <aarvar> but maybe I should
13:48:27 <crestfallen> that is a dismal set of 4 humours
13:48:41 <aarvar> edwardk: a lot of stuff like what? "Don't make me write scala"?
13:49:04 <edwardk> i gave in and moved to boston to make the employment thing work. its hard to say "hey i want to work in this narrow niche, but i dont want to move and have no work experience" something has to give
13:49:13 <noan> [exa], yeah, we write pretty pure scala where I work
13:49:19 <aarvar> edwardk: fair enough
13:49:27 <noan> recently I had to write some javascript, but it's all pure too
13:49:32 <noan> just not type checked statically :(
13:49:52 <[exa]> noan: it's possible to write javascript that typechecks itself before execution
13:50:11 <[exa]> noan: there's a toolkit for that somewhere
13:50:16 <Sose> noan: look into flowtype
13:50:19 <maerwald> from facebook afair
13:50:20 <edwardk> exa: i call that "purescript" ;)
13:50:28 * noan shrugs
13:50:39 <[exa]> no, purescript is external
13:50:42 <aarvar> edwardk: but otherwise QFPL sounds awesome
13:50:42 <maerwald> https://github.com/facebook/flow
13:50:45 <noan> it was specifically requested to be javascript to be approachable to our ops team
13:50:52 <Cale> exa, edwardk: I call that "Haskell" :)
13:50:53 <noan> since they'll take ownership of it once complete
13:51:03 <edwardk> cale: :)
13:51:08 <noan> so I just wrote it really carefully with promises as my """""monad"""""
13:51:18 <[exa]> :D
13:52:48 <aarvar> edwardk: give me some ideas for libraries to write
13:53:58 <edwardk> aarvar: propagators, work with me speeding up discrimination, i have a bunch  of half finished transients code that could be shipped, other approaches to my promises stuff could be faster...
13:54:29 <aarvar> edwardk: at the moment I'm working on a little library like https://hackage.haskell.org/package/labels
13:54:31 <aarvar> but better
13:54:47 <edwardk> i have 200+ repos on github but only 125 projects on hackage. so there is a pretty wide cross section of unfinished work to pick through
13:55:12 <aarvar> edwardk: k, I'll take a look
13:55:20 <aarvar> edwardk: you'll probably have to explain them to me though
13:55:27 <edwardk> thats fine
13:55:30 <tdammers> I would argue that "unfinished" doesn't necessarily imply "worth putting more work into"
13:55:39 <aarvar> lol
13:55:44 <edwardk> i'm not terribly shy about talking about projects :)
13:55:49 <tdammers> at least that's how my projects work
13:55:57 <aarvar> presumably "pick through" means "find the things worth working on"
13:56:02 <monochrom> I have a brilliant idea. We just dicussed that logic is a degenerate form of both homotopic type theory and probability theory. Perhaps there is a way to unify the two. HomoTopic Type Probability = HTTP. >:)
13:56:03 <edwardk> tdammers most of mine get abandoned for time more than anything
13:56:04 <tdammers> fair enough
13:56:07 <maerwald> tdammers: you just want us to help you now :P
13:56:28 <aarvar> edwardk: oh, and I started writing a ghc-proposal
13:56:31 <aarvar> I should finish that
13:56:35 <tdammers> maerwald: of course, but I'd want you to work on the stuff that's already "production ready"
13:56:37 <aarvar> though it'll probably never happen
13:57:16 <edwardk> monochome: i just want conor to rename all of his epigram style stuff, stuff that is completely incompaible with HoTT. It should clearly be called NoTT.
13:57:31 <monochrom> Haha that's awesome
13:57:53 <edwardk> it did start at nottingham... :)
13:58:25 <noan> https://github.com/ekmett/perhaps/blob/master/src/Control/Monad/Perhaps.hs
13:58:29 <Cale> edwardk: hahaha
13:58:29 <aarvar> edwardk: I think I already tried to show you this before, but https://github.com/aaronvargo/ghc-proposals/blob/class-constructors/proposals/class-constructors.rst
13:58:35 <noan> I just went to the weird place
13:58:41 <Cale> I think he'd like that as well
13:58:53 <noan> believe :: Perhaps a -> a
13:59:18 <benzrf> edwardk: hey, is there anything in constraints thet might allow this https://benzrf.com/uploads/92492a4808218325.log
13:59:21 <aarvar> I'm getting tired of duplicating typeclass instances
13:59:27 <aarvar> and deriving via doesn't actually solve the problem
13:59:31 <edwardk> noan: i wrote that as a pair programming exercise to show a guy how to backport things clear to 7.2 robustly
13:59:37 <benzrf> or does doing something like that fundamentally require certain boilerplate
14:00:10 <noan> edwardk, ah. I don't understand the type though
14:00:23 <noan> Can a | Can't Void... doesn't this mean it can only ever be a Can a?
14:00:29 <noan> that there's no way to construct a can't?
14:00:44 <edwardk> benzrf: that is what quantified constraints are for
14:00:56 <benzrf> quantified constraints?
14:01:05 <aarvar> when are those going to be done
14:01:05 <benzrf> oh sick
14:01:07 <benzrf> i never heard about that
14:01:14 <edwardk> bottom inhabits all types. we use Void morally as uninhabited, here i'm using it as inhabited by bottoms
14:01:16 <noan> oh wait, a void can still be created by creating an error/exception? like, errors are the only things that can go there
14:01:25 <noan> yeah, I just understood
14:01:27 <edwardk> aarvar guessing 8.6 maybe 8.8
14:01:39 * aarvar hopes for 8.6
14:01:51 <aarvar> though I imagine they'll still be buggy
14:02:05 <benzrf> maaaaaaaaaaaaaan
14:02:09 <benzrf> i PRECISELY need them rn
14:02:12 <edwardk> basically this is somewhere between Maybe and Either in that it can smuggle out an error for what went wrong but you cant care
14:02:35 <edwardk> benzrf: i've been fighting for them for years now
14:03:15 <aarvar> too bad I've forgotten all the things I wanted them for
14:03:24 <aarvar> now I'll have to try to remember
14:05:21 <benzrf> rn im trying to do some awful hacky shit
14:05:37 <benzrf> but in particular i want a category instance for matrices
14:05:49 <benzrf> but you need a KnownNat constraint to have id
14:06:02 <edwardk> yep Category in haskell is crippled
14:06:30 <aarvar> edwardk: oh yeah...how do you get Ob a => Ob (Identity a) when using the unsafeCoerce hack?
14:06:32 <edwardk> hence why all my fancier category theory bits replace it
14:06:33 <benzrf> so i made a hacky version of Category which includes a constraint, but now i have no way of making it clear that the constraint carries over to bifunctor image
14:06:40 <benzrf> -,-
14:06:43 <aarvar> edwardk: unsafeCoerce the constraint?
14:06:48 <edwardk> yep
14:06:51 <benzrf> edwardk: i was looking @ categories but it's all specialized to kind *
14:06:51 <aarvar> sounds really dangerous
14:06:57 <edwardk> yep
14:07:12 <aarvar> edwardk: I had another idea that could work, but probably not nicely
14:07:16 <edwardk> benzrf: github.com/ekmett/hask
14:07:28 <edwardk> its dated and doesnt work any more but its as close as i got
14:07:34 <aarvar> edwardk: create a dsl for types, with a constructor for applications, but where functions use defunctionalization
14:07:51 <aarvar> so that you have type lambdas but keep type inference
14:07:57 <benzrf> yeah i remember looking @ it
14:08:07 <aarvar> then write your constraints so they only depend on the interpretation of that type language
14:08:12 <aarvar> may or may not work
14:08:26 <edwardk> aarvar: you can compile down to combinators for the lambdas
14:08:33 <aarvar> edwardk: that too
14:08:52 <aarvar> edwardk: figured defunctionalization is easier since there's already TH for it
14:09:15 <aarvar> and it probably produces nicer errors
14:10:00 <benzrf> edwardk: oh, only put the constraint on id?
14:10:07 <benzrf> hrm
14:10:09 <aarvar> but I'm not very hopeful that CT will ever really work in haskell
14:11:23 <aarvar> maybe if injective type families are finished (or were they already?) then inference with just defunctionalization might be bareable
14:11:34 <edwardk> benzrf note the impact on "Nat" in that it has to know the end points are functors and you need to be able to recover the Ob constraints on the objects from arrows
14:11:58 <benzrf> augh, i guess you couldnt avoid the boilerplate i was worried about :{
14:12:08 <aarvar> but last I checked there's no way to prove that a defunctionalized function is injective
14:12:12 <aarvar> which completely ruins it
14:12:25 <aarvar> currently
14:12:36 <benzrf> you basically have to match on ob every time you wanna use id on something functored
14:12:45 <benzrf> i guess you could use fmap id but that'd be pretty verbose :\
14:13:35 <benzrf> oh well...
14:14:10 <edwardk> benzrf there is code in there for producing the proof that if f is a functor and a is an object of its domain then f a is an object of the codomain
14:14:31 <aarvar> problem is you have to apply all the evidence manually xd
14:14:49 <edwardk> this can become part of the superclass constraints of Functor in there once we have QuantifiedConstraints
14:14:51 <benzrf> y i k e s https://hackage.haskell.org/package/hask-0/docs/Hask-Tensor.html#v:associate
14:15:11 <benzrf> edwardk: yeah, that's precisely why i wanted qc
14:15:21 <edwardk> the fun one is the definition of return and bind in Compose
14:16:30 <benzrf> all these constraints, god
14:17:55 <benzrf> why can't we just have non-constraint kinds whose inhabitants have runtime presence
14:18:35 <aarvar> what do you mean?
14:18:47 <benzrf> it seems like it'd far, far, far simpler to do everything i'm trying to do if i could just parameterize my type of morphisms over a kind of knownnats
14:18:59 <edwardk> my current plan is to go back and revisit this hask stuff some day by adding a ghc plugin to resolve the extra constraints it offers
14:19:02 <aarvar> dependent types?
14:19:06 <aarvar> that would make it easier :)
14:19:10 <edwardk> that would fix the stuff for 'Compose; etc.
14:19:17 <benzrf> aarvar: we already have bits of dependent typing
14:19:25 <aarvar> with dependent types you wouldnt have to bother with Ob
14:19:35 <aarvar> benzrf: in some sense, Ob is faking dependent types
14:19:40 <benzrf> yeah
14:19:42 <aarvar> Ob a is the runtime component of a
14:19:45 <aarvar> and a is the type component
14:19:46 <benzrf> precisely
14:20:07 <benzrf> i'm saying that if we could have types with implicit runtime components, that would get rid of the need for 10000000 constraints all over the place
14:20:23 <aarvar> well, there'd be nothing implicit about it
14:20:26 <aarvar> and they wouldn't be types
14:20:27 <benzrf> well, i'm sure that would be opening up its own can of worms...
14:20:28 <aarvar> but yes
14:20:34 <aarvar> why's that?
14:20:40 <edwardk> the problem with the normal approach to dependent types is that the typed core stuff really complicates things. we have all this stuff for type families, etc. that are all kind of morally in the same space and which has rather complicated interactions with the idea of converting stuff to, say, beta-eta-long normal forms. so richard's thesis is super complicated.
14:21:01 <benzrf> what is richard's thesis
14:21:14 <benzrf> aarvar: well, as it is, we can kind of count on knowing what is and isn't there at runtime
14:21:18 <aarvar> he's the one implementing dependent haskell
14:21:22 <benzrf> it becomes more complicated and requires more consideration
14:21:24 <edwardk> richard eisenberg, goldfirere the guy who is writing all the dependent haskell stuff
14:21:25 <benzrf> ah
14:21:42 <aarvar> benzrf: you'd still be able to know that
14:21:45 <benzrf> er, when i say "we", i mean we as people reading/writing haskell code
14:21:53 <aarvar> although I'm not sure whether that's actually desirable
14:21:55 <benzrf> yeah, but it adds complexity :)
14:21:58 <edwardk> https://arxiv.org/abs/1610.07978
14:22:05 <aarvar> that's where you'd want multiplicity polymorphism
14:22:08 <aarvar> with 0 multiplicity
14:22:21 <aarvar> and then I wonder if all of that is worth it compared to just letting the compiler try and erase things
14:22:42 * hackage streaming-eversion 0.4.0.0 - Translate pull-based stream folds into push-based iteratees.  http://hackage.haskell.org/package/streaming-eversion-0.4.0.0 (DanielDiazCarrete)
14:22:57 <tdammers> I feel this belongs in this discussion: https://summerofcode.withgoogle.com/projects/?sp-page=4#5851493949767680
14:22:59 <edwardk> the multiplicity polymorphism stuff does come at some real costs. it becomes really hard for a lot of standard compiler optimizations to work in the presence of linear types, affine types, etc.
14:23:34 <edwardk> even just plumbing it all through a compiler the size of ghc is quite complicated
14:23:36 <aarvar> edwardk: I was more just thinking that the type signatures can get really large
14:23:43 <edwardk> there is that too
14:23:46 <aarvar> if you want maximum polymorphism
14:23:50 <aarvar> so then you want some way to hide it all
14:24:00 <edwardk> i keep playing around with how i'd express all my beloved spmd-on-simd stuff in haskell and every time i do i cry at the sizes of the types i'd get
14:24:04 <aarvar> and I don't like the idea of subtyping
14:24:20 <edwardk> even before adding polymorphism over uniform/varying
14:24:21 <aarvar> how is the proposed subtyping for linear types supposed to interact with typeclasses?
14:24:51 <benzrf> considering just hopping to idris to do this
14:25:00 <edwardk> in general if you have a bounded subtyping lattice. e.g. with 2-3 points, you can replace it by adding things one universe up and using unbounded quantification instead.
14:25:02 <aarvar> ew, idris
14:25:12 <benzrf> ew? :(
14:25:14 <edwardk> e.g. how all the stuff around ? and ?? was replaced with levity polymorphism
14:25:37 <aarvar> edwardk: right, I'm thinking just using parametric polymorphism is better
14:25:42 <aarvar> but then even larger type signatures
14:26:18 <edwardk> the horrible syntactic hacks we have for ( ) and (p,q) can be replaced with a similar lattice style trick if we really wanted to be fully sound. i just can't convince ghc-hq folks that its worth the price of admission
14:27:11 <benzrf> it's just that i was hoping to use this garbage with some code i wrote that uses diagrams
14:27:24 <benzrf> also i doubt idris has a maintained linear algebra library
14:27:48 <edwardk> benzrf: to do this today you can always just use the semigroupoids package for your matrix multiplication and use the semiid stuff there to pick out KnownNat  constraints
14:27:52 <edwardk> for identity matrices
14:27:56 <benzrf> hmm
14:28:03 <edwardk> benzrf: that is a large part of why it was written in the first place
14:28:08 <edwardk> it was my first foray in this direction
14:28:12 <benzrf> well
14:28:15 <benzrf> there's a problem here
14:28:21 <aarvar> edwardk: Does conor mcbride's theory handle e.g. affine types as well? Seems like it should work for pretty much any substructural types?
14:28:32 <benzrf> ultimately, matrices are just one instance - i'm trying to set up some machinery for compact closed categories
14:28:38 <edwardk> aarvar: with some minor tweaks you can handle affine, yeah
14:28:52 <benzrf> : > https://i.imgur.com/onaPJEV.png
14:28:54 <edwardk> i mean ultimately that is what our "Linear Types" are, are affine types in the presence of exceptions, etc.
14:28:56 <aarvar> edwardk: don't you just pick a different rig?
14:29:13 <aarvar> edwardk: right, why not have affine types then
14:29:18 <aarvar> or affine and linear
14:29:30 <edwardk> aarvar: affine is what i call our "linear types" =)
14:29:51 <aarvar> except they force you to pretend to consume the variable right?
14:29:58 <aarvar> (but not actually)
14:30:05 <edwardk> nah, i can throw exceptions and so you can leak them
14:30:07 <benzrf> oh wait
14:30:09 * benzrf looks at semiid
14:30:20 <benzrf> hmm
14:30:38 <benzrf> eh, this is still all * isnt it
14:30:46 <aarvar> edwardk: what about when you mask exceptions? Does bottom still screw them up?
14:31:18 <aarvar> or I guess it doesn't matter at that point
14:31:21 <edwardk> benzrf: it should be polykinded.
14:32:17 <benzrf> oh, i was looking at Bifunctor
14:32:20 <aarvar> hmm, is there a linear variant of HoTT?
14:32:22 <benzrf> i guess id have to define my own bifunctor class
14:32:30 <aarvar> seems like linearity would conflict with univalence?
14:32:46 <benzrf> aarvar: what would "linear variant of hott" mean
14:32:56 <aarvar> HoTT with linear types?
14:33:02 <aarvar> or substructural types more generally
14:33:05 <edwardk> Semigroupoid :: (k -> k -> *) -> Consraint doesn't care about the kind of its argument, nor does Ob :: (k -> k -> *) -> k -> Constraint
14:33:11 <aarvar> guess it would make no sense
14:33:12 <benzrf> yeah aight
14:33:17 <benzrf> aarvar: idk
14:33:29 <benzrf> edwardk: so you dont have a class for semigroupoid functors?
14:33:53 <benzrf> but yeah i'm doing a lot of lmap and rmap so :\
14:33:58 <edwardk> aarvar: well, you could adapt something like neelk or benton's work on building a category of linear types and tying it to a dependent type theory through an adjunction, and then try to do that on a dependent type theory where HoTT works
14:34:00 <aarvar> well, univalence basically says the strongest claim you can make is that two types are isomorphic right? But linear isomorphism is stronger
14:34:13 <benzrf> no it doesnt
14:34:14 <aarvar> edwardk: sounds over my head
14:34:21 <benzrf> oh, well
14:34:29 <aarvar> benzrf: no?
14:34:32 <benzrf> i mean, i guess it sort of implies that?
14:34:39 <aarvar> if isomorphism implies equality..
14:35:21 <edwardk> benzrf: http://hackage.haskell.org/package/semigroupoid-extras
14:35:23 <aarvar> so you could weaken it maybe, and say only linearly isomorphic types are equal
14:35:25 <benzrf> ooh
14:35:27 <edwardk> that has semifunctor, etc.
14:35:33 <aarvar> then you add irrelevant or affine types or something, and you're back to square 1
14:35:48 <edwardk> aarvar: equality gets bigger, isomorphism doesn't get smaller
14:36:30 <benzrf> ^
14:36:38 <benzrf> edwardk: yeah this is still gonna introduce about as many constraints :\
14:36:50 <aarvar> edwardk: wdym
14:36:53 <edwardk> benzrf: didn't say it was magic, just that it already existed ;)
14:36:56 <aarvar> sorry, I'm dumb
14:37:09 <benzrf> tfw no quantifiedconstraints ;A;
14:37:38 <benzrf> o wellllll
14:37:38 <edwardk> aarvar: i don't have strong intuitions for how linear types and univalence would interoperate.
14:38:08 <edwardk> the neelk/benton approach would be how i'd try it if i were to do so though
14:38:33 * aarvar googles even though it will be over his head
14:39:25 <edwardk> https://www.cl.cam.ac.uk/~nk480/dlnl-paper.pdf is the neelk paper. it links to the older Benton paper
14:40:19 <edwardk> basically builds an adjunction between a dependent type theory and a linear type theory, then uses the monad/comonad given by that adjunction to do fun things like reason about hoare triples in the linear logic and to rederive the computational lambda calculus of moggi on the dependent type side
14:41:07 <edwardk> as i've been beating my head against a wall trying to figure out how to model effects for coda, this approach has been heavily on my mind
14:41:19 <benzrf> what's coda
14:41:40 <aarvar> when will coda replace haskell and let us use CT
14:41:43 <edwardk> me getting bored and playing around with another compiler
14:42:25 <Adluc> edwardk: dont want to hijack discussion, but from where did you gain all the knowledge?
14:42:30 <edwardk> coda is more focused on being better at typeclasses than haskell than at being better at category theory
14:42:32 <aarvar> never of course, since edwardk will give into the temptation to have global coherence, and then get stuck in nominal type hell
14:42:47 <aarvar> does better at typeclasses mean no global coherence?
14:42:56 <edwardk> Adluc: from assuming everybody in the haskell community knew all the things that Cale was in here rambling about, and chasing down every reference he ever made ;)
14:43:07 <edwardk> aarvar: hell no
14:43:17 <aarvar> so nominal type hell :)
14:43:25 <Cale> hahaha
14:43:29 <edwardk> heaven vs. hell is a matter of perspective
14:43:42 <aarvar> edwardk: what does it do better then?
14:43:48 <aarvar> fundeps actually work?
14:43:54 <aarvar> coherence with dependent types?
14:43:57 <edwardk> deep accurate class hierarchies.
14:44:16 <aarvar> like, abstracting over construction so you dont get ever increasing boilerplate?
14:44:31 <edwardk> if it is going to take me 5 years to get semigroup in as a superclass of monoid or to get applicative a superclass of monad, it behooves me to grant equal time to the development of a language in which i would simply never have to have the fight
14:44:37 <aarvar> p.s., did you see my ghc proposal that solves that problem
14:44:48 <aarvar> unfinished, but still
14:45:01 <aarvar> I don't think you need a new language
14:45:16 <edwardk> aarvar: you have a thing you like involving crazy fundeps, etc. which is pretty far outside of the overton window for the discussion everybody else is having. i have a completely different approach
14:45:23 <aarvar> edwardk: no, this isnt that
14:45:26 <aarvar> this is totally different
14:45:32 <aarvar> and actually within the realm of possibility
14:46:09 <edwardk> anyways i think we are still fundamentally talking about two different things
14:46:12 <aarvar> edwardk: the proposal just changes the instance syntax so that `instance Foo` instantiates what I call a "class constructor"
14:46:22 <aarvar> a class constructor can instantiate any number of instances
14:46:28 <aarvar> so you can derive entire instance sets at once
14:46:37 <aarvar> it also lets you add a new superclass without breaking code
14:46:46 <edwardk> and that does nothing towards the problem that i'm attempting to address
14:46:50 <aarvar> as long as the class didnt previously exist, and you have control of the subclass
14:46:51 <edwardk> so like i said, different problems
14:46:53 <aarvar> oh
14:46:56 <aarvar> then I misunderstood
14:46:59 <aarvar> what is the problem
14:47:17 * edwardk grabs something to drink, because we'll be here a while ;)
14:47:39 <aarvar> was also trying to think of ways to allow retroactive superclassing
14:47:52 <edwardk> that is part of the story here, but a fairly small part
14:48:03 <aarvar> uh oh
14:48:23 <edwardk> okay, in the interest of picking a fight, the sort of core principal i'm dealing with is that 'haskell is bad at abstraction'
14:48:27 <edwardk> by that i mean several things
14:48:36 <edwardk> so it'll take a bit of time to unpack that statement
14:48:37 <DigitalKiwi> sometime when you guys are finished with whatever you're talking about can someone explain when any of this would actually be useful like what specific real world problem can any of this solve or why any of it is necessary you know what I mean? :|
14:48:38 <aarvar> 1. bad at abstracting over instance construction
14:48:46 <aarvar> 2. very bad at 1
14:49:32 <edwardk> lets go talk about a very simplistic example. dealing with a shallow class hierarchy means if i go to add a new superclass into it, every person who instantiates the class heirarchy has all of their code broken
14:49:48 <aarvar> right
14:49:50 <edwardk> we had to fight tooth and nail to get applicative in as a superclass of monad, even Functor as a superclass of monad because of that pain
14:50:00 * aarvar 's proposal solves this so far
14:50:12 <edwardk> ignore your proposal for now please
14:50:15 <aarvar> k
14:50:21 <edwardk> or we'll keep getting derailed
14:50:59 <edwardk> so basically what happens is that haskell is good at dealing with fairly shallow coarse-grained class heirarchies
14:51:25 <edwardk> if i wanted to push Semimonad in as a superclass of Monad, or Semiapplicative in as a superclass of Applicative, we'd have another 5 year war, and a ton of breakage.
14:51:31 <aarvar> right
14:51:48 <edwardk> If as a mathematician i tried to model field with the full level of fidelity i'm capable of, it winds up with about 600 transitive superclasses
14:52:07 <edwardk> there is no way on earth i could convince a large cross section of the haskell community to adopt such a class as a replacement of RealFrac or something ;)
14:52:26 <edwardk> because the huge burden on implementors
14:52:33 <aarvar> right, keep going
14:52:58 <edwardk> i figured there are 1700 other people in the channel so its worth setting the stage right for people who aren't you =)
14:53:15 <aarvar> =(
14:53:42 <edwardk> so there are several proposals for how to bolt in some kind of superclass default proposal into haskell
14:53:50 <edwardk> and they are all pretty badly flawed in various ways
14:54:32 <edwardk> either someone like richard wants it to be a loud noisy crutch only used temporarily until folks rewrite away from the problem, or folks like conor want it to work, but only really properly consider linear chains of classes.
14:54:37 <Rembane_> I want proofs! Wooooooooo!
14:55:23 <edwardk> but in either case you run into the situation where to properly talk about superclass defaults you need to _prove_ that it when you have a type Foo that is both a Monad and a Comonad and a Traversabler that liftM = liftW = fmapDefault can fill in for Functor and that you can't care
14:55:35 <edwardk> and the language of expressing those _proofs_ goes beyond what haskell is capable of
14:55:43 <edwardk> so Rembane_ scooped me there ;)
14:55:57 <Rembane_> edwardk: Sorry 'bout that. I got carried away. :)
14:56:19 <aarvar> right, so you want to require proofs that all possible instances are equal
14:56:23 <noan> is there a fold function for Data.Array that will let me have access to the index value? Trying to find something atm
14:56:37 <edwardk> so im that interest a lot of my work on coda has been on making sure that there is a language that can exist that has proper typeclasses and has enough functionality that you can express that liftM  = liftW = fmapDefault are equal up to functional extensionality
14:57:23 <edwardk> aarvar: consider (,) e  it is a monad (if e is a monoid) it is traversable (regardless) and it is a comonad (regardless)
14:57:41 <aarvar> edwardk: problem: you have classes A and B
14:57:42 <edwardk> so if you specified the Monad/Traversable and Comonad instances, each one of them would want to fill in the superclass defaults for Functor
14:57:54 <aarvar> you want to add a new superclass C which is a superclass of both A and B
14:58:09 <edwardk> that is another problem i'll address later we haven't built up enough vocabulary yet
14:58:25 <aarvar> sorry :)
14:58:29 <edwardk> np
14:58:34 <benzrf> it seems pointless anyway to try to do something like make fully accurate classes for fields in a language like haskell
14:58:55 <benzrf> do we even have an actual definition for what equality is
14:58:56 <edwardk> benzrf: i'm not saying that the resulting language is particularly close to haskell.
14:59:11 <benzrf> oh i misread
14:59:14 <edwardk> benzrf: i'm saying hey i want a language that is better at deep accurate class hierarchies than haskell is
14:59:19 <edwardk> and i';m exploring what those consequences are
14:59:33 <aarvar> (we should also just make haskell better)
14:59:40 <edwardk> this so far has led me to say, well, i need a dependent enough type theory to talk about equality, and that equality needs to be able to handle funext.
14:59:57 <aarvar> observational TT to the rescue!
15:00:16 <edwardk> aarvar: that is what 80% of what i do is all about. it still behooves me to take my "20% time" and go off and explore big moves that diverge heavily from what could be doine here.
15:00:16 <benzrf> how's this project different from sth like idris
15:00:17 <edwardk> er done
15:00:34 <edwardk> benzrf: idris has something it calls typeclasses that are more like scala implicits.
15:00:48 <Tuplanolla> I also have this problem, where I want all kinds of things that I don't really even understand.
15:00:50 <aarvar> benzrf: they fall apart once you use them with dependent types
15:00:56 <aarvar> since it cant prove different instances are the same
15:01:01 <edwardk> you bolt a bunch of ad hoc rules onto a pattern unifier that say hey when you are looking for an Eq a dictionary and have an Ord a one, here;'s how you go about it.
15:01:12 * hackage cdeps 0.1.1.1 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.1 (vmchale)
15:01:13 <edwardk> this is the standard pattern used by Coq, Agda, Idris, etc.
15:01:16 <benzrf> ah
15:01:17 <edwardk> its how _every_ dependently typed language works
15:01:49 <Boarders> what is the cabal new-* version of stack exec if there is one?
15:01:52 <edwardk> Instead, what I'm proposing is to modify the unifier the way Wadler modified the one used for Hindley-Milner to get us typeclasses in haskell, extra constraaints on the type variables.
15:02:18 <edwardk> boarders: cabal new-run?
15:02:34 <benzrf> hmm
15:02:36 <benzrf> bbl
15:02:37 <edwardk> there is also cabal new-exec
15:02:40 <Boarders> ah ok it was obvious :)
15:03:02 <Boarders> not sure how I convinced myself it was not that
15:03:38 <aarvar> so in edwardk's dream language you require proofs that all instances are coherent?
15:03:42 * hackage pipes-transduce 0.4.4.0 - Interfacing pipes with foldl folds.  http://hackage.haskell.org/package/pipes-transduce-0.4.4.0 (DanielDiazCarrete)
15:04:00 <edwardk> anyways, once i accept that i need a dependent type theory, then the question of how to properly add haskell-style typeclasses to a dependent type theory comes up, so a lot of the work then turns to seeing that the category of constraints is thin, has an internal hom, has a proper notion of sums, etc. its a full locally-cartesian closed category, etc.
15:04:27 <edwardk> aarvar: yes, but give me a little more rope please
15:05:15 <edwardk> basically the key is showing that those proof obligations have some canonical module in which they must be defined and where those obligations can be discharged
15:05:40 <edwardk> and then you can move to something more like a coq-style set of tactic tricks to discharge most of them automatically
15:06:01 <aarvar> so no orphan proofs?
15:06:04 <aarvar> or something
15:06:04 <edwardk> much like how i write coq today, i write in something that morally feels more like haskell under the program construct, then get a ton of proof obligations to discharge
15:06:32 <edwardk> well, lets digress for a moment to first get a notion of a partial order of modules in a language like haskell
15:07:15 <edwardk> we can build a preorder on haskell-style modules by just saying Foo <= Bar when Foo imports Bar directly. then computing the transitive, reflexive closure of that gives you a partial order on modules
15:07:53 <edwardk> now given that partial order, we can now work out how to find instances, without instances 'infecting' interfaces like they do in ghc today. (ignoring orphans, kill them all)
15:08:04 <edwardk> we'll backfill the functionality orphans supply later
15:08:12 * hackage reddit 0.2.3.0 - Library for interfacing with Reddit's API  http://hackage.haskell.org/package/reddit-0.2.3.0 (Intolerable)
15:09:11 <edwardk> ignoring mptcs, fundeps, flexible instances, flexible contexts, there is at most one place to go look for a given instance Foo Bar, which is basically whichever module, the module defining the class Foo or the module defining the data type Bar, imports the other transitively. if neither do so the instance can't exist.
15:10:04 <edwardk> addressing the orphan situation relies on being able to fill in a place that does exist when that location isn't in the partial order.
15:10:54 <edwardk> but you can chase this down to show that when you have a deep class hierarchy with classes defined in different modules it projects onto this partial order in a well behaved way.
15:11:01 <edwardk> why do i care about this stuff?
15:11:28 <edwardk> well, when i want users to be able to retroactively create some Semimonad class that i've never heard about, i want some way to promote existing monads to it
15:12:18 <edwardk> and to do so i need to know if the thing that has a monad could have known about the class for semimonad -- could there even _be_ a manual instance, which is what this extra partial ordering on modules helps me identify
15:13:28 <aarvar> so then you can distinguish between "monad without semimonad" and "monad with semimonad" instances?
15:13:48 <edwardk> i'd also like to be able to make existing data types into semimonads using weaker constraints than the constraint on monad, which entails me writing little local instances for each of the things i want to fix up  and then the local proof that this is coherent with the one you'd get by dumbing down the larger monad to semimonad entailment
15:14:16 <edwardk> but the key for all the software engineering of this stuff is that there has to be some unique file at each point where all these proofs would have to live
15:15:02 <aarvar> edwardk: sounds like something you could do with a module system?
15:15:06 <edwardk> yeah, basically the goal is to prove exactly that you can't care that i added this class later on, that users can be empowered to retroactively expand the class hierarchy _up_ as well as down
15:15:25 <edwardk> i don't parse how that applies.
15:16:03 <edwardk> i have module systems all over the place in these random dependently typed language. i don't have any proper notion of typeclasses
15:17:00 <edwardk> i can make it very easy for me the core libraries author or whatever to extend upwards, but its important to me that users also be able to extend things without my knowledge, and that several folks be able to do so without knowledge of each other
15:17:12 * hackage OneTuple 0.2.2 - Singleton Tuple  http://hackage.haskell.org/package/OneTuple-0.2.2 (phadej)
15:17:50 <aarvar> er, ignore me
15:17:57 <edwardk> so much for calling it Solo to match up with Solo#
15:18:02 <aarvar> I didnt mean replace typeclasses with modules
15:18:26 <aarvar> but what I was thinking was dumb, so nvm
15:18:31 <edwardk> np
15:19:22 <edwardk> so then the question becomes how to really think about all this typeclass stuff. and there i've been sort of leaning on a 'theory of theories' based pretty closely on the notion of the adjunction between syntax and semantics that lawvere likes to talk about
15:19:53 <aarvar> and that's where you'll completely lose me :)
15:20:52 <edwardk> to make that more concrete, my mental model of what a 'theory / typeclass' is in this framework is that you have a bag of types, a bag of operations and a bag of laws governing the behavior of those operations. you might say 'well, we're in a dependently typed theory so there is no difference between operations and laws' but i want to keep them seperate for now.
15:21:12 <pavonia> What is the purpose of OneTuple when we already have Identity?
15:21:17 <edwardk> you can view this as a sort of idealized story about a typeclass. e.g. Magma gives you a type m, and an operation (<>) :: m -> m -> m
15:21:21 <Rembane_> edwardk: I'm gonna jump in and ask: Do you think keeping and expanding on type classes in Haskell is a good idea?
15:21:28 <edwardk> pavonia: a strict one-tuple is actually a rather different beast.
15:21:36 <edwardk> pavonia: notably it can be a legal MonadFail
15:21:41 <edwardk> Identity cannot
15:21:47 <edwardk> Rembane_: yes
15:21:54 <edwardk> Rembane_: god yes =)
15:22:57 <aarvar> Rembane_: do you mean within haskell, or for new languages?
15:23:03 <pavonia> edwardk: It says OneTuple "has the expected laziness properties", so it's not strict, no?
15:23:05 <edwardk> anyways in this category of theories, my objects are typeclasses expressed in this form, and my arrows add types/operations/laws to get a new class.
15:23:34 <aarvar> uh oh, meta-categories
15:23:38 <edwardk> pavonia: i phrased that badly
15:24:15 <Rembane_> aarvar: Within Haskell. Other languages have both better, the same and worse solutions. :)
15:24:22 <Rembane_> edwardk: Sweet! :)
15:24:30 <aarvar> Rembane_: well then obviously
15:24:35 <edwardk> so taking Magma, i might have an arrow from that to UnitalMagma that adds the identity element for the binary operation and the two unit laws. and a completley unrelated arrow from Magma to Semigroup that adds the associativity law.
15:24:42 <aarvar> that ship sailed decades ago xd
15:25:01 <edwardk> now to throw some 10 dollar category theory words at the problem. Monoid is the 'pushout' of those two arrows from Magma.
15:25:34 * aarvar has at least seen the word pushout
15:25:53 <edwardk> the two paths from Magma commute. (all paths in this category of constraints commute, so this isn't surprising, its a partial-order-like place)
15:26:25 <edwardk> but they also commute in a sort of idealized way, in that there isn't anything smaller that contains the laws/operations added by unital to magma and that are added by semigroup to magma
15:26:41 <edwardk> anything else that has a path from both unitalmagma and semigroup will factor through monoid
15:26:48 <edwardk> and do so uniquely
15:27:12 * hackage foldl-transduce 0.6.0.0 - Transducers for foldl folds.  http://hackage.haskell.org/package/foldl-transduce-0.6.0.0 (DanielDiazCarrete)
15:27:16 <edwardk> these pushouts are something a bit special, so its worth calling them out, because they are places where haskell today can shine
15:27:57 <aarvar> you mean in that you can define Monoid a = (Semigroup a, Unital a) without worrying about the Magma's being different?
15:27:59 <edwardk> its also worth noting that relative to a sort of empty top level vacuous constraint, Default and Semigroup don't pushout to get Monoid. you need the unit laws
15:28:22 <edwardk> and yeah, effectively the product there is good enough
15:28:26 <aarvar> this is the problem with idris :)
15:29:17 <edwardk> it being valid relies on that coherence property, that both of those want to give you a magma, and that you need to know it'll be the same one regardless of the path you took. thinness of the category gives you that in real typeclasses
15:29:29 <aarvar> right
15:29:40 <edwardk> i'm just sort of setting a stage and some common vocabulary so i can use it
15:30:15 <aarvar> you need to get some stage hands :)
15:30:32 <edwardk> not every diamond in my category of constraints is a 'pushout square' sometimes you do start with something like Default and Semigroup and want to build Monoid, but then that isn't a pushout of those two theories relative to some base, its adding laws of its own
15:31:16 <edwardk> now haskell has the problem that with 600 transitive superclasses above a class i have to write 600 instances to write just the leaf level concern i'm interested in
15:31:41 <edwardk> my goal is to be able to pay for the number of _immediate_ superclasses and some coherence properties between them rather than everything transitively above me
15:32:04 <edwardk> there may be 600 superclasses above field, but maybe only 5-6 immediate superclasses no matter how anal retentive i may be
15:32:08 <edwardk> division rings, etc.
15:32:28 <edwardk> in haskell a lot of my libraries i wind up writing about 40 instances for each data type
15:32:32 <aarvar> hm, I think I see
15:32:38 <edwardk> that is about the limit of getting these accurate hierarchies into haskell for me
15:32:44 <edwardk> doing more gets painful fast
15:32:45 <aarvar> you prove that the immediate super instances are coherent, and then recursively the whole hierarchy is?
15:32:51 <edwardk> yep
15:32:56 <aarvar> interesting
15:33:22 <edwardk> but to do so i need enough of a dependent type theory to talk about equality of functions up to funext
15:33:54 <aarvar> so OTT?
15:33:58 <edwardk> and to have proper typeclasses i pretty much have to abandon HoTT along the way. i tried tying typeclasses to the bottom couple of h-levels and only having them for h-sets and h-props
15:34:12 <aarvar> pretty sure nominal type roles are incompatible with univalence
15:34:46 <edwardk> currently basically just starting from a sort of simple mltt + axiom k + funext axiom. i don't need funext to be computable here.
15:35:10 <edwardk> k gives me nice pattern matching, funext makes it possible to check those equalities, etc.
15:35:55 <edwardk> i can get fancy and note that i have a semilattice of notions of equality based on assumed axioms and then lift those directly into my category of constraints.
15:36:13 <edwardk> now, "Constraint" isn't "Prop", its bigger
15:36:22 <edwardk> it has computationally relevant bits.
15:36:29 <edwardk> Traversable tells you how to traverse, not just that you could
15:37:09 <aarvar> can you prove that all instances of the same type are equal in this language?
15:37:19 <edwardk> using Set and Prop as the names for my more traditional dependent type universes, in my setting here i'm playing with an adjunction between Constraint and Prop that factors through Dict embedding Constraint into Set.
15:37:38 <edwardk> aarvar: thats the key to talking about all this stuff through the adjunctiony bits here
15:38:08 <Welkin> habari
15:39:08 <edwardk> basically you get an embedding into Constraint for any Prop. which is the constraint that the prop is inhabited, and the Prop that a given dictionary for a Constraint _could_ be constructed. this gives rise to a monad on Constraint, and an idempotent comonad on Prop that does nothing
15:40:04 <edwardk> and the 'is constructable' thing in prop can be viewed as taking Dict :: Constraint -> Set   and then dumbing it down into Prop by erasure
15:40:15 <edwardk> hence the factoring bit i mentioned
15:40:19 <aarvar> or Not (Not (Dict c))
15:40:32 <edwardk> pretty close to that anyways
15:40:47 <edwardk> both keep you from accessing the dictionary, just by different means
15:42:41 <edwardk> so as to what coda is, its mostly a research playground for me. i have a bunch of questions about how to parse languages more efficiently i'd like to play with, i have a bunch of questions about how to deal with deep accurate class hierarchies and package management to avoid compiling crap you aren';t using when you go to lean on something like lens, i have a bunch of questions i'm interested in around how to build an efficient runtime system
15:42:42 <edwardk> based on all this stuff i'm doing with SPMD-on-SIMD evaluation and how to apply it to a haskell-like language, etc.
15:44:15 <edwardk> i figure i'll throw all these things into a pot, build for a while, see what works out in practice
15:44:21 <aarvar> now add mptcs :)
15:44:26 <edwardk> i fully expect 70% of these experiments to fail
15:44:48 <edwardk> well, when i talked about the uniqueness of where to go find the instance that was without MPTCs for simplicity
15:44:55 <aarvar> ah
15:45:14 <aarvar> It must be pretty complicated with them though?
15:45:19 <edwardk> but it still holds in a more general setting with them, flexible instances, etc. just becomes more complicated and becomes a bounded number of locations, if we want all that functionality intact.
15:45:27 <edwardk> i'm not entirely sure that we do
15:45:35 <aarvar> I assume there's a reason why ghc can't always identify orphan instances
15:45:52 <edwardk> well, the thing is with ghc because of how we manage _packages_ we kinda have to have orphan instances
15:46:10 <aarvar> I just mean that it doesn't always produce a warning
15:46:14 <edwardk> my fixes there require tackling all my package management stuff differently too
15:46:15 <aarvar> or could that be fixed
15:46:25 <edwardk> it should always emit a warning if you have it turned on
15:46:31 <edwardk> -Worphans is accurate
15:46:45 <aarvar> does -Wall not enable it?
15:46:47 <edwardk> its just that not every package has -Wall on
15:46:53 <edwardk> it does
15:47:18 <Welkin> worphans
15:47:18 <Welkin> lol
15:47:26 <aarvar> I thought it wasnt so clear what is and isnt an orphan once you have all those extensions
15:47:29 <Welkin> I always find those -W flags funny
15:47:31 <Welkin> -Wall
15:47:35 <Welkin> makes me think of pink floyd
15:47:42 <edwardk> nah, with all the extensions its still clear
15:48:15 <aarvar> edwardk: oh, and my proposal isn't a default superclass proposal btw
15:48:18 <aarvar> since you mentioned those
15:49:10 <edwardk> this does remind me i need to get around to writing up that poison pragma proposal for ghc
15:49:18 <aarvar> what does that do
15:49:21 <edwardk> and to finish up the proposal i was working on for Decidable Instances
15:49:59 <Boarders> what is the recommended way to upgrade cabal?
15:50:02 <aarvar> edwardk: I suspect that with "class constructors" you actually could have your 600 classes, though you would still need to modify existing packages to do it
15:50:10 <aarvar> the modifications just wouldnt break anything else
15:50:14 <edwardk> {-# POISON instance Foldable ((,) e) #-}  -- makes it so that in any downstream dependency of the module that defines that, any attempt to use Foldable ((,) e) results in a compile time error, like it would if the instance resolution was ambiguous
15:50:22 <aarvar> hmm
15:50:35 <aarvar> what would you use that for
15:51:13 <edwardk> a few things. one is that corporate haskell folks who have their own preludes and want to rule out using certain instances can put it in place to prevent accidental length (1,2) problems if they feel its evil.
15:51:38 <edwardk> another is that you can see building your library with a flag that turns on a bunch of them to lint and check that you aren't using them by accident even without infecting downstream libraries
15:51:47 <Welkin> what are corporate haskell folks?
15:51:55 <aarvar> lol
15:51:56 <Welkin> corporeal?
15:52:08 <Welkin> corporal punishment?
15:52:18 <edwardk> Welkin: there are a lot of little 8-10 person shops writing haskell with some in house custom prelude, and rules about their local style, etc.
15:52:40 <Welkin> oh, you mean like fpcomplete and all of their typeclass nonsense libraries
15:52:52 <Welkin> classy-prelude
15:53:33 <Welkin> they may as well rename Haskell to Typeclasskell
15:54:04 <edwardk> them, standard chartered (a bit bigger than 8-10 people, though!), us here a Digital Asset, tweag, a bunch of folks over at iohk, etc.
15:54:12 * hackage animate-sdl2 0.1.0 - sdl2 + animate auxiliary library  http://hackage.haskell.org/package/animate-sdl2-0.1.0 (jxv)
15:54:28 <phadej> Welkin: e.g . Futurice has 2.x people working on Haskell and we have custom prelude
15:54:55 <phadej> it's something you'll do for any big / long enough project
15:55:05 <edwardk> we probably have a half-dozen little haskell shops here in the boston area
15:55:06 <aarvar> or small project
15:55:23 <edwardk> phadej: i tend to avoid doing so myself, but thats my own peculiar foible i guess
15:55:27 <edwardk> its at least a popular pattern
15:55:36 <simon> in Copenhagen there's one, as far as I'm aware. ^_^
15:55:58 <simon> consisting of 3 people. there are probably a bunch of freelancers, but they tend to socialize like cats.
15:56:02 <capisce> phadej: 2.x?
15:56:12 <phadej> capisce: >2 && <3
15:56:27 <phadej> on average
15:56:28 <simon> that's an interesting interval.
15:56:29 <Welkin> phadej: or just don't use the prelude
15:56:41 <capisce> phadej: makes sense
15:57:07 <Welkin> but then your files will look like purescript
15:57:09 <phadej> Welkin: our prelude is basically a lot of imports which don't clash
15:57:16 <edwardk> phadej: too bad cabal won't let you write ^>= 2 for that
15:57:18 <Welkin> 20 imports at the top just to do basic things
15:57:43 <aarvar> imports with the standard prelude get pretty ridiculous
15:58:20 <Welkin> that depends on how you program
15:58:23 <phadej> i.e. we are not redefining things, but cherry-picking selected parts: https://github.com/futurice/haskell-futurice-prelude/blob/master/src/Futurice/Prelude/Internal.hs
15:58:45 <phadej> edwardk: you mean ^> 3 :)
15:58:51 <phadej> ^> 2 :)
15:58:52 <Welkin> I have come to appreciate the prelude being imported by default
15:59:01 <Welkin> especially after experiencing purescript
15:59:04 <edwardk> aarvar: they do get ridiculous i admit, but i confess i kind of like knowledge about what is in scope to be relatively local to the file. it reduces pressure go get  a globally consistent set of names considerably. we still have things like Map/Set, etc. that need to be qualified anyways, etc.
15:59:29 <aarvar> edwardk: there's always a few functions I always find myself reaching for though
15:59:35 <phadej> ... and we only export name of types, not their methods :)
15:59:51 <aarvar> and it's probably more work to import them than to just not use them
16:00:03 <Welkin> what about backpack?
16:00:17 <Welkin> can't you use that to have block-scoped imports?
16:00:21 <edwardk> phadej: so unpacked-containers will play havoc with you? =)
16:00:23 <aarvar> edwardk: oh, and then there's importing all the mtl stuff
16:00:25 <Welkin> like ocaml modules
16:00:41 <Tuplanolla> Don't you wish you could share individual functions instead of having to package them up?
16:00:54 <edwardk> Welkin: backpack is package granularity, its not like ml functors in that you open them locally and what not
16:00:56 <Welkin> Tuplanolla: npm?
16:01:39 <Tuplanolla> That's also a package manager, Welkin.
16:01:58 <Welkin> Tuplanolla: half of the packages only contain a single function
16:02:30 <phadej> edwardk: I don't see a conflict, if we end up using say unpacked map with X, we can instantiate it in futurice-prelude package and use it
16:02:31 <aarvar> imagine trying to find packages then :)
16:03:02 <phadej> edwardk: in corporate setting I'm ok with having fat big "base-lib"
16:04:13 <Tuplanolla> I'm suggesting packages might not be the silver bullet to code reuse and something else could coexist.
16:04:55 <Lears> nix has something like that Tuplanolla; `import ./file.nix` is an expression with the value in file.nix.
16:07:01 <edwardk> phadej: my experience is in the other direction in that i find the "big fat base-lib" approach increases on boarding time as users need to figure out what is in and out of our arbitrary bag of stuff, but i fully understand that i'm in the minority on this position.
16:07:21 <phadej> edwardk: well, it's 2 of us, the onboarding is not a concern :?
16:07:32 <edwardk> at 2 not a problem. at 30 more so =)
16:07:56 <phadej> edwardk: yeah, so I don't say our approach is the only right, or that it works for everyone. We are happy :)
16:08:26 <edwardk> anyways that is the sort of scenario i want to offer up a poison pragma for
16:08:33 <jle`> does using error vs. errorWithoutStackTrace have any runtime performance effects?
16:09:05 <edwardk> jle`: there was a performance hit when the stack trace stuff was introduced, i don't remember how bad it was though
16:09:30 <jle`> is it something you worry about when writing libraries?
16:09:52 <edwardk> not really
16:10:13 <jle`> right now i'm just making the decision based on semantic reasons i guess, hopefully that guides the way correctly
16:10:15 <jle`> thanks
16:10:29 <edwardk> i concern myself mostly with factors of 2 or more, not 5-10%
16:11:08 <edwardk> i figure if i get most of the big ticket stuff right and use the correct asymptotics for everything then i generally get performance in line with what i need
16:11:29 <jle`> good guidelines :)
16:12:12 * hackage backprop 0.2.2.0 - Heterogeneous automatic differentation (backpropagation)  http://hackage.haskell.org/package/backprop-0.2.2.0 (jle)
16:12:43 <Welkin> what is this jle` ?
16:12:56 <jle`> error vs errorWithoutStackTrace ?
16:12:59 <Welkin> are you doing deep learning in haskell?
16:13:17 <jle`> backprop is a library i've been nursing for a while now :)
16:13:35 <jle`> i released it officially in Februrary
16:25:41 <edwardk> i've been playing around with a little backpack based ad/linear library design, but haven't managed to get it to a usable state yet
16:25:59 <noan> Is there a standard function that looks like this? ---> fmapSnd :: Functor f => (b -> c) -> f (a, b) -> f (a, c)
16:26:19 <edwardk> my goal being to let you work completely monomorphically in the leaf level types, and handle things like quaternions, dual quaternions, ad, matrices of these things, etc
16:26:23 <jle`> noan: that's just (fmap . second)
16:26:33 <jle`> or (fmap . fmap) if you like to be obfuscatey
16:26:34 <edwardk> noan: fmap.fmap
16:27:10 <noan> so that would keep the fst in my result value, right?
16:27:16 <edwardk> yep
16:27:22 <jle`> noan: one way to find out :)
16:27:23 <edwardk> the second functor here is (,) a
16:27:34 <Welkin> :t fmap . fmap
16:27:36 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
16:27:42 <Welkin> yeah, that's too clever
16:27:44 <jle`> > (fmap . second) negate [('a',2),('b',4),('c',6)]
16:27:46 <lambdabot>  [('a',-2),('b',-4),('c',-6)]
16:27:53 <Welkin> I'd go with fmap . second
16:28:19 <Welkin> actually wait
16:28:20 <Welkin> o.o
16:28:23 <jle`> :t fmap . second
16:28:24 <lambdabot> Functor f => (b -> c) -> f (d, b) -> f (d, c)
16:28:26 <Welkin> fmap on tuples already does that
16:28:34 <jle`> oh hey, that's literally the exact type you had, heh
16:28:39 <jle`> Welkin: yes, for tuples, fmap = second
16:28:47 <Welkin> oh yeah
16:28:47 <edwardk> > [(1,2),(3,4)] & mapped._2 +~ 1
16:28:49 <lambdabot>  [(1,3),(3,5)]
16:28:50 <jle`> just like for functions, fmap = (.), for lists, fmap = map
16:28:51 <Welkin> I'd still use second
16:28:58 <edwardk> > [(1,2),(3,4)] & mapped.mapped +~ 1
16:29:00 <lambdabot>  [(1,3),(3,5)]
16:29:18 <jle`> i'd use second just like how i'd use map for lists instead of fmap, just to make it a bit quicker to process when i'm reading code
16:29:28 <jle`> but (fmap . fmap) isn't particularly bad as far as these things go
16:30:06 <noan> > (fmap . snd ) negate [('a', 2)]
16:30:08 <lambdabot>  error:
16:30:08 <lambdabot>      • Couldn't match expected type ‘(a0, (Char, Integer) -> b)’
16:30:08 <lambdabot>                    with actual type ‘Integer -> Integer’
16:30:22 <noan> yeah, looks like "second" works but not snd
16:30:26 <Welkin> second comes from Data.Arrow
16:30:28 <jle`> second is a higher order function
16:30:29 <edwardk> 'second' isn't 'snd'
16:30:32 <Welkin> snd doesn't have the right type
16:30:33 <edwardk> :t second
16:30:34 <jle`> i'd use the one from Data.Bifunctor
16:30:34 <edwardk> :t snd
16:30:34 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
16:30:35 <lambdabot> (a, b) -> b
16:30:37 <Welkin> snd is an accessor
16:30:40 <Welkin> it pulls out the second value
16:30:48 <jle`> second :: (a -> b) -> (c, a) -> (c, b)
16:30:48 <edwardk> :t Data.Bifunctor.second
16:30:50 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
16:31:01 <edwardk> :t Data.Profunctor.second'
16:31:02 <lambdabot> Data.Profunctor.Strong.Strong p => p a b -> p (c, a) (c, b)
16:31:02 <jle`> noan: second maps a function over the second item in a tuple
16:31:07 <edwardk> ^- lots of colors for this bikeshed =)
16:31:11 <Welkin> o.o
16:31:14 <Welkin> oh lawd
16:31:18 <noan> jle`, and then I headdesked
16:31:23 <jle`> noan: fmap maps a function over the contents of a functor
16:31:44 <jle`> noan: so if you think of second as taking a function and lifting it to a "tuple function"
16:31:51 <jle`> and fmap as taking a function and lifting it to a "functor function"
16:32:01 <jle`> then (fmap . second) takes a function and makes it a functor-tuple function
16:32:03 <jle`> heh
16:32:10 <jle`> double lift
16:32:12 * hackage cdeps 0.1.1.2 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.2 (vmchale)
16:33:05 <edwardk> noan: fmap.fmap.fmap  and traverse.traverse.traverse, etc. are fairly general patterns
16:33:25 <jle`> higher order functions are the best :D
16:33:26 <Welkin> fmap . fmap . fmap is a popular joke in here
16:33:38 <jle`> :t map . second
16:33:39 <lambdabot> (b -> c) -> [(d, b)] -> [(d, c)]
16:33:52 <jle`> :t first . map . second
16:33:53 <lambdabot> (b -> c) -> ([(d1, b)], d2) -> ([(d1, c)], d2)
16:34:01 <jle`> :t fmap . first . map . second
16:34:02 <lambdabot> Functor f => (b -> c) -> f ([(d1, b)], d2) -> f ([(d1, c)], d2)
16:34:11 <jle`> ^ see you can lift your (b -> c) into an arbitrarily nested structure
16:34:14 <jle`> just by composing lifting functions
16:34:23 <enterprisey> while we're on doing fun things with first & second
16:34:23 <noan> composition is magic
16:34:27 <Welkin> no
16:34:28 <Welkin> it is not
16:34:38 <Welkin> composition is just function application
16:34:53 <noan> obviously.
16:34:54 <Welkin> (f . g) a= f (g a)
16:34:57 <noan> I'm making a joke
16:34:59 <enterprisey> anyone have a good way to write (a -> b -> c -> d -> e) -> (a, b) -> (c, d) -> e
16:35:11 <enterprisey> I have the trivial way and some bizarre thing that "pointfree" spat out
16:35:13 <edwardk> @djinn (a -> b -> c -> d -> e) -> (a, b) -> (c, d) -> e
16:35:14 <lambdabot> f a (b, c) (d, e) = a b c d e
16:35:14 <jle`> enterprisey: \f (x, y) (a, b) =  f x y a b
16:35:14 <Welkin> I dislike that word "magic"
16:35:22 <Welkin> may as well say "god did it"
16:35:27 <edwardk> @pl \a (b, c) (d, e) -> a b c d e
16:35:27 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .)
16:35:28 <enterprisey> going for something pointfree & disgusting jle`
16:35:35 <edwardk> enterprisey: try that =)
16:35:42 <enterprisey> yep that's the bizarre thing that pointfree said
16:35:45 <enterprisey> my favorite part is `ap`
16:36:08 <noan> Welkin, I use it merely as a term of praise for things that work well :3
16:36:08 <jle`> enterprisey: i thought you were asking for a "good" way :)
16:36:11 <Welkin> enterprisey: use a good old lambda expression
16:36:12 <enterprisey> :)
16:36:25 <enterprisey> yeah I absolutely plan to use the "good" way in the codebase
16:36:30 <Welkin> point-free is like a shotgun
16:36:31 <enterprisey> but I was wondering if there's anything devilish
16:36:55 <Welkin> it even has little shars all over the place (.)
16:36:59 <enterprisey> I was going down the path of (.) <$> uncurry <*> uncurry
16:37:02 <Welkin> shards of shrapnel*
16:37:04 <jle`> edwardk: does your leafy ad method have a github repo? :)
16:37:23 <edwardk> :t fmap uncurry . uncurry
16:37:24 <lambdabot> (a1 -> b1 -> a2 -> b2 -> c) -> (a1, b1) -> (a2, b2) -> c
16:37:31 <edwardk> ^- enterprisey how is that?
16:37:31 <enterprisey> wow
16:37:34 <enterprisey> beautiful
16:37:38 <noan> So on a similar topic, is there then a similar way to express this? .... sequenceSnd :: (p, Maybe a) -> Maybe (p, a)
16:37:46 <jle`> noan: that's just sequence
16:37:47 <noan> something like (sequence . second)?
16:38:00 <edwardk> manually wrote it as \f ab cd -> uncurry (f ab) cd -- then @pl'd it
16:38:09 <enterprisey> interesting
16:38:17 <jle`> % :t sequence @((,) p) @Maybe
16:38:17 <yahb> jle`: ; <interactive>:1:16: error: Not in scope: type variable `p'
16:38:17 <edwardk> er \f ab cd -> uncurry (uncurry f ab) cd
16:38:22 <jle`> % :t sequence @((,) Int) @Maybe
16:38:23 <yahb> jle`: (Int, Maybe a) -> Maybe (Int, a)
16:38:30 <jle`> % :t sequence @((,) _) @Maybe
16:38:30 <yahb> jle`: (w, Maybe a) -> Maybe (w, a)
16:39:01 <noan> I am so confused
16:39:09 <jle`> :t sequence
16:39:11 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:39:15 <jle`> (p,) is a Traversable
16:39:20 <jle`> Maybe is a Monad
16:39:24 <jle`> it just works :)
16:39:24 <edwardk> noan: we just call your sequenceSnd 'sequence'
16:39:41 <jle`> sequenceSnd :: (p,) (Maybe a) -> Maybe ((p,) a)
16:39:44 <edwardk> noan: (,) e is a traversable functor so Sequence just works
16:39:47 <edwardk> er sequence
16:39:48 <jle`> sequence :: t (Maybe a) -> Maybe (t a)
16:39:48 <noan> :t sequence
16:39:49 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:39:58 <jle`> use (p,) for t
16:40:02 <jle`> Maybe for m
16:40:22 <jle`> the function you want is (p,) (Maybe a) -> Maybe ((p,) a)
16:40:36 <jle`> which fits with sequence's t (Maybe a) -> Maybe (t a)
16:41:24 <noan> I'm still confused as to how (a, m a) fits the type constraint t (m a)
16:41:38 <noan> er, (p, m a)
16:41:43 <Welkin> (a,) is the  t
16:41:44 <noan> since the left isn't a monad.
16:41:46 <edwardk> noan: (,) a b = (a, b)
16:41:51 <Welkin> (,) is the constructor for a tuple
16:41:55 <noan> uh huh
16:42:02 <Welkin> (,) a has kind * -> *
16:42:09 <Welkin> (,) :: * -> * -> *
16:42:18 <noan> :t (,)
16:42:19 <lambdabot> a -> b -> (a, b)
16:42:41 <edwardk> so you can pick t = (,) p        and get:  (,) p (m a) -> m ((,) p a)   -- then when you shuffle the (,) back into infix position you get (p, m a) -> m (p, a)
16:43:53 <edwardk> sequence (a, m) = (,) a <$> m
16:43:57 <Welkin> the motion picture association
16:44:04 <Welkin> conspiracy?
16:44:32 <edwardk> which note is more powerful, as for this special case you can do it for any functor, it doesn't even need m to be a monad
16:44:32 <noan> I think I sort of get it in a hand-wavey sort of way
16:44:49 <noan> I think I need more time and experience with haskell syntax
16:44:58 <noan> to be able to properly grok etc
16:45:11 <Welkin> haskell is needlessly confusing for newcomers because of special syntax support for things like lists and tuples
16:45:16 <Welkin> there are a lot of cases like this
16:45:18 <Welkin> unfortunately
16:45:23 <Welkin> but yes, with time you will get it
16:45:24 <jle`> noan: are you familiar with how infix operators work in haskell
16:45:28 <Welkin> you just have to use it a bit
16:45:34 <jle`> noan: `1 + 3` is just syntactic sugar for `(+) 1`
16:45:56 <jle`> er, for (+) 1 3
16:46:06 <jle`> so (a, b) is just syntactic sugar for (,) a b
16:46:17 <noan> yeah I know about that.
16:46:26 <jle`> so the function you want is (,) p (Maybe a) -> Maybe ((,) p a)
16:46:41 <Welkin> noan: and you know about kinds?
16:46:43 <jle`> noan: also, remember that `f x y` is really for (f x) y
16:47:05 <jle`> noan: when you write `mod 4 5`, that's really `(mod 4) 5`
16:47:06 <noan> Welkin, I think so, but still sort of handwavey
16:47:20 <Welkin> :kind (,)
16:47:23 <jle`> so the function you want is:
16:47:25 <Welkin> :k (,)
16:47:25 <lambdabot> * -> * -> *
16:47:33 <Welkin> :k (,) String
16:47:34 <lambdabot> * -> *
16:47:36 <jle`> ((,) p) (Maybe a)  -> Maybe (((,) p)  a)
16:47:37 <Welkin> :k (,) String Integer
16:47:38 <lambdabot> *
16:47:54 <Welkin> the * means Type
16:48:01 <Welkin> no idea why it is a star instead of Type
16:48:15 <jle`> noan: do you see how `((,) p) (Maybe a)   -> Maybe ( ((,) p)  a )` lines up with `t (Maybe a) -> Maybe (t a)` ?
16:48:25 <jle`> t is ((,) p)
16:48:28 <noan> I think so yews
16:48:31 <noan> yes
16:48:36 <jle`> and `((,) p)` has a Traversable instance
16:48:44 <jle`> instance Traversable ((,) p) where
16:48:49 <noan> but how the fuck does the compiler know to treat (,) p as the t and not (,)
16:49:01 <jle`> noan: (,) cannot be t
16:49:05 <jle`> do you see why?
16:49:11 <jle`> t has to take a single type parameter
16:49:15 <noan> ah hah
16:49:18 <Welkin> and Traversable can only be defined for a type with kind * -> *
16:49:21 <noan> so t must have kind * -> *
16:49:25 <noan> not  * -> * -> *
16:49:27 <jle`> yes, from the type of sequence
16:49:29 <jle`> :t sequence
16:49:30 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:49:31 <Welkin> same with functor
16:49:36 <Welkin> and monad, and many others
16:49:38 <jle`> the only way that makes sense is if 't' takes a single parameter
16:49:45 <jle`> if t was (,), that type signature makes no sense
16:49:47 <noan> okay that makes sense.
16:49:55 <jle`> sequence :: (,) (m a) -> m ((,) a)    -- ????
16:49:59 <jle`> that's a nonsensical type signature
16:50:10 <jle`> t ~ (,) is not a thought that the compiler can even entertain
16:50:13 <Welkin> and that is one reason, also, why fmap for tuples only maps over the second element
16:50:30 <noan> thanks guys
16:50:41 <noan> this is gonna need some time to stew and let the consequences of it buble up
16:50:58 <Welkin> I do hope you mean bubble, and not buble
16:51:05 <noan> Bublé
16:51:07 <jle`> michael buble
16:51:13 <noan> :3
16:51:21 <jle`> noan: but really though, i'm on your side a bit, i don't really like using sequence on tuples
16:51:37 <noan> This whole thing though makes me not want to use tuples
16:51:44 <jle`> good, don't use tuples :)
16:51:44 <Welkin> tuples are not that useful
16:51:59 <Welkin> I only use them for association lists (basically, a list representation of a map/table)
16:52:02 <noan> In this case tuple is what I get from assoc
16:52:04 <noan> :t assoc
16:52:05 <lambdabot> error:
16:52:05 <lambdabot>     • Variable not in scope: assoc
16:52:05 <lambdabot>     • Perhaps you meant one of these:
16:52:08 <jle`> sequence on tuples is kinda assymetrical, like fmap on tuples, and so it's not really my favorite tool
16:52:12 <Welkin> or for pattern matching on many values at once in a case expression
16:52:22 <jle`> that's why i use 'first' and 'second' instead of 'fmap'
16:52:49 <jle`> you can do something similar with bitraverse
16:52:51 <jle`> :t bitraverse id pure
16:52:53 <lambdabot> error:
16:52:53 <lambdabot>     • Variable not in scope:
16:52:53 <lambdabot>         bitraverse :: (a0 -> a0) -> (a1 -> f0 a1) -> t
16:52:58 <jle`> @let import Data.Bitraversable
16:52:59 <lambdabot>  Defined.
16:53:01 <Tuplanolla> The symmetry is an illusion caused by it not being a dependent sum type.
16:53:02 <jle`> :t bitraverse id pure
16:53:03 <lambdabot> (Applicative f, Bitraversable t) => t (f c) d -> f (t c d)
16:53:03 <Welkin> you are almost always better served by defining an ADT instead of using tuples
16:53:04 <noan> So, lets say I need like, 3 values that may or may not have the same time
16:53:09 <jle`> :t bitraverse pure id
16:53:10 <lambdabot> (Applicative f, Bitraversable t) => t c (f d) -> f (t c d)
16:53:11 <noan> and I want a guarantee that there are EXACTLY 3
16:53:28 <noan> I can create a data type to box them, but if I want an existant type... hlist?
16:53:28 <Welkin> data Three a b c = Three a b c
16:53:31 <jle`> noan: in practice you'd make a data type
16:53:37 <noan> okay
16:53:40 <jle`> that has names
16:53:44 <jle`> and not something like THree, heh
16:53:49 <jle`> usualyl your data type represents something useful
16:53:55 <jle`> so you can give it a meaningful name, with meaningful field accessors
16:53:58 <noan> it's what I've used so far
16:54:06 <noan> https://github.com/AlexaDeWit/runlike
16:54:11 <jle`> > bitraverse id pure (Just 'a', 3)
16:54:13 <lambdabot>  Just ('a',3)
16:54:14 <noan> newby haskell in progress if you want to cringe
16:54:17 <jle`> > bitraverse pure id ('a', Just 3)
16:54:19 <lambdabot>  Just ('a',3)
16:54:25 <Welkin> data TaePoDong k i m = TaePoDong k i m
16:54:32 <jle`> that's a way to do the Maybe-extracting symetrically on either side of the tuple i guess
16:55:05 <edwardk> noan: (,,) takes 3 type arguments, and you can write out (a,b,c) or (,,) a b c   -- this pattern generalizes
16:55:23 <jle`> now we just need Tritraversable
16:55:40 <edwardk> I called it "Triversable" when i needed it inside of the ermine code =)
16:55:51 <jle`> cute :)
16:56:00 <jle`> who called it Bifunctor and not Bunctor
16:56:03 <Welkin> oh, you are making a game?
16:56:05 <jle`> missed opportunity
16:56:12 <Welkin> I never knew helm was a haskell implementation of Elm
16:56:13 <Welkin> o.o
16:57:21 <noan> Welkin, there are many things named helm. Helm is not a haskell implementation of elm
16:57:48 <noan> it does use the elm architecture with respect to structuring of the program, but it's not for rendering to elm etc
16:58:10 <Welkin> that is what I meant
16:58:11 <noan> very similar patterns, but sdl2 not dom
16:58:13 <noan> ah, yeah
16:59:06 <noan> so far I'm at the stage where I can export map data automatically from the Tiled map-editor via a python script, and then compile that resultant map and render it
17:00:52 <Welkin> I was writing a book on haskell (to teach the language) and also to teach how to build a roguelike that runs in the console.
17:01:45 <Welkin> too bad I can't recommend it, since I'm rewriting it all, and it won't teach how to build a videogame anymore
17:02:04 <noan> I'm sure I'll managed :3
17:02:20 <noan> I'm picking the language up pretty fast since I have experience with pure-fp scala
17:02:23 <noan> and also with elm
17:03:21 <Welkin> most of learning haskell is learning how to think with functional programming, and getting used to non-strict evaluation
17:03:26 <Welkin> the syntax of haskell is relatively easy
17:03:51 <Welkin> not as easy as lisp/scheme
17:06:49 <noan> for me the main thing is wrapping my head around the type system
17:07:12 <noan> good night
17:08:13 <EvanR> > maxBound
17:08:15 <lambdabot>  ()
17:08:23 <EvanR> jle` is at it again
17:09:18 <EvanR> i object to the idea that lisp syntax is easy
17:09:29 <Welkin> there is none easier
17:09:42 <Welkin> in fact, is there even a syntax at all?
17:09:45 <EvanR> is whitespace or a language with N consecutive letter A easy
17:09:45 <Welkin> it's already an AST
17:10:14 <EvanR> is a superflat plane the most beautiful landscape
17:10:56 <EvanR> is machine language programming, where the state of the system is a huge array of Word64 easy
17:11:06 <Welkin> you don't have the same issues with prefix vs infix and precendence rules like in haskell
17:11:23 <Welkin> the way an expression is written is exactly how it is interpreted
17:11:31 <EvanR> but the thing is, expression syntax is easier for me to read and write
17:11:57 <EvanR> because thats how millenia of notation crammed it down my throat? dunno but there oyu have it
17:12:43 <EvanR> take away your english language, now you should find it much easier to communicate with human beings
17:13:05 <EvanR> no pesky english language
17:15:39 <Welkin> that's okay
17:15:43 <Welkin> I can use chinese
17:15:46 <Welkin> or swahili
17:15:50 <Welkin> or create a new language
17:15:57 <capisce> chinese is failry ambiguous too
17:16:17 <Welkin> yes
17:16:20 <Welkin> word order changes meaning
17:16:26 <Welkin> it has very little grammar
17:16:39 <EvanR> the chinese room guy does not mind
17:16:54 <EvanR> perhaps that is the moral of the story of plain syntax
17:18:49 <capisce> lojban claims to be unambiguous
17:19:11 <capisce> http://www.dictionary.com/e/lojban/
17:19:26 <Rembane_> How?
17:24:14 <capisce> Rembane_: their website has information about that: https://mw.lojban.org/papri/Lojban
17:25:51 <Rembane_> capisce: Thank you!
17:56:06 <bobbymax31> Hello
17:56:24 <bobbymax31> I'd like some help with understanding how to infer types of lambda functions
17:57:04 <bobbymax31> I've got f :: Int, g :: Bool and trying to infer type of h which is: h = \x -> x f g
17:57:11 <bobbymax31> Can anybody help?
17:57:50 <EvanR> do you know the inference rule for lambdas
17:58:22 <bobbymax31> Sort of
17:58:34 <bobbymax31> I was able to infer the type of h using :type in ghc
17:58:46 <bobbymax31> But I wanted to know how to infer it step by step basically
17:59:11 <EvanR> step by step, did you ever look up "algorithm M"
17:59:20 <bobbymax31> No
17:59:46 <bobbymax31> I don't know what Algorithm M is
18:00:23 <EvanR> actually, I think it's algorithm W
18:00:44 <EvanR> that's the classic type inference algorithm
18:00:57 <bobbymax31> I'll look it up
18:00:59 <EvanR> so you could (re)start there
18:01:05 <bobbymax31> Thanks :)
18:03:36 <Cale> bobbymax31: If you're just looking to figure it out by hand, it's enough just to think about the types of the subexpressions
18:04:22 <bobbymax31> I tried doing so, but wasn't really able to figure out how haskell reached the type of the lambda expression
18:05:38 <EvanR> here is my rule https://i.imgur.com/nDXFG9x.jpg
18:06:25 <EvanR> if you read it backwards, then to determine the A and the B, you try to infer the type of the lambda body with some placeholder A as the type of x in context
18:07:41 <EvanR> the answer is A -> B, you just need to get as specific as you can what A and B are, given what else you know. which is f :: Int and g :: Bool
18:08:27 <Cale> bobbymax31: Okay, so you know that x has to be a function
18:08:33 <EvanR> if you get as specific as possible without getting concrete answers, then you replace remaining unknowns with type variables and foralls
18:08:48 <Cale> bobbymax31: and it's got to take an Int before producing another function (since f is an Int)
18:09:05 <Cale> and then the function it produces has got to produce a Bool
18:09:14 <Cale> er has got to consume a Bool
18:09:34 <Cale> So x :: Int -> Bool -> a  for some type a we don't have any information about yet
18:09:56 <Cale> and x f g :: a
18:10:14 <Cale> So the lambda as a whole is taking something of type (Int -> Bool -> a), and producing something of type a
18:10:22 <Cale> So it has type (Int -> Bool -> a) -> a
18:10:47 <Cale> and since we haven't discovered any further information about a, we might as well generalise, and say that this is a polymorphic function.
18:11:39 <bobbymax31> Does that mean that if f and g are more complex, for example f :: Num a => Either Bool a -> b & g :: c -> Either c Int, the infered type would then follow through the same steps?
18:11:41 <EvanR> A=Int -> Bool -> a,  B = a
18:11:49 <Cale> bobbymax31: yep
18:11:57 <bobbymax31> For the same lambda expression i'd then get this:
18:12:08 <Cale> bobbymax31: any constraints on variables would just get collected up
18:12:18 <bobbymax31>  Num a => ((Either Bool a -> b) -> (c -> Either c Int) -> t) -> t
18:12:20 <bobbymax31> ?
18:12:29 <Cale> yes
18:12:40 <bobbymax31> Now i understand it
18:12:42 <bobbymax31> Thank you :)
18:13:27 <EvanR> it works by recursively using the inference rule on subexpressions, each form of subexpression has a rule to guide you
18:13:55 <EvanR> but the trick is introducing the unknowns and then ruling out what they are later, like clue
18:14:24 <bobbymax31> It's all because of the rule you sent
18:14:40 <EvanR> the one i sent only takes care of the lambda
18:14:46 <EvanR> you need another one for x f g
18:14:57 <EvanR> specifically (x f) g
18:15:13 <bobbymax31> Type instantiation rule?
18:15:18 <EvanR> the (e e) rule, application
18:18:39 <lars1212> a
18:18:50 <EvanR> bobbymax31: ... https://i.imgur.com/36qvwqg.jpg
18:19:06 <EvanR> again you have to read it backwards, bottom to top
18:20:11 <bobbymax31> I think I understand it
18:20:14 <bobbymax31> Let me work through it
18:20:15 <EvanR> in your case you knew what B was, g :: Bool. but A would be a new unknown
18:20:51 <EvanR> until the next step....... yeah
18:21:47 <EvanR> oops, if you know what g is... that tells you A, not B. keeping variables straight is hard :)
18:22:31 <bobbymax31> Yeah was confused for a bit there!
18:22:59 <EvanR> matching the pattern, e1=(x f) e2=g
18:24:51 <bobbymax31> We first apply the application rule for x f
18:24:55 <bobbymax31> then apply it for (x f) g
18:24:57 <bobbymax31> Yeah?
18:25:50 <EvanR> before recursing i would complete "clue" notes on what i know so far
18:26:14 <EvanR> making up new names for the unknown types helps
18:26:31 <EvanR> g :: Bool, already known
18:26:44 <EvanR> (x f) :: u1, not known
18:27:05 <EvanR> but the name u1 can be used in the next iteration
18:27:13 <bobbymax31> Ok
18:27:18 * dyl dances awkwardly in the corner.
18:27:20 <EvanR> esp since its about the expression (x f)
18:27:36 <bobbymax31> Makes sense..
18:29:26 <EvanR> also x :: u0
18:29:41 <EvanR> from a previous step
18:30:05 <bobbymax31> The one with the rule of lambda expressions?
18:30:08 <EvanR> yes
18:30:11 <bobbymax31> Ok
18:31:50 <dyl> Just remember, if an expression doesn’t typecheck you can always make a blood sacrifice to shift your consciousness into a parallel universe where it does.
18:31:58 <dyl> That’s how we got all these GHC extensions.
18:32:31 <EvanR> surely that will cause your mind the crumble to madness
18:32:57 <bobbymax31> It already is sort of going crazy rn
18:33:33 <EvanR> the idea is to find some sanity in the chaos, and hopefully these rules are that. as i see it
18:33:58 <EvanR> if they make sense in isolation, at least we can feel good about that when we give up and go home for the night
18:34:22 <bobbymax31> Fair enough
18:34:25 <EvanR> lol
18:34:44 <bobbymax31> Thank you for your help, i really do appreciate it
18:35:05 <dyl> EvanR: Eldritch derivation is a necessary but unknowable evil.
18:36:42 * hackage wai-session 0.3.3 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.3.3 (StephenWeber)
18:37:43 <isaiah_> Hello there, is this a good place for me to ask newb questions about functional programming?
18:38:41 <dyl> Welcome to the right place :).
18:38:50 <isaiah_> Sweet!
18:39:02 <dyl> :t Data.ByteString.Internal. accursedUnutterablePerformIO
18:39:03 <lambdabot> error:
18:39:03 <lambdabot>     Not in scope: data constructor ‘Data.ByteString.Internal’
18:39:03 <lambdabot>     Perhaps you meant one of these:
18:39:14 <dyl> :t Data.ByteString.Internal.accursedUnutterablePerformIO
18:39:15 <lambdabot> IO a -> a
18:39:20 <dyl> EvanR ^
18:39:59 <EvanR> how is that in scope
18:40:07 <dyl> > Data.ByteString.Internal.accursedUnutterablePerformIO (return 42)
18:40:09 <lambdabot>  error:
18:40:09 <lambdabot>      Not in scope:
18:40:09 <lambdabot>        ‘Data.ByteString.Internal.accursedUnutterablePerformIO’
18:40:14 <EvanR> try yahb
18:40:16 <dyl> I’m not... sure.
18:40:22 * EvanR gets behind borax water drum
18:40:26 <dyl> @ Data.ByteString.Internal.accursedUnutterablePerformIO (return 42)
18:40:38 <dyl> What was yahb’s command key?
18:40:49 <EvanR> check the necronomicon
18:40:58 <dyl> I can’t, the pages keep changing.
18:41:22 <isaiah_> So I'm brand new to functional programming, I originally spent some time Java / other OOP stuff and my day job is mostly scripting, Python and some backend node js stuff. Decided to get to know functional just for fun. I've heard a few talks etc and something is confusing me. The main definition of functional is no side effects, correct? So why can't a function have internal scoped state that makes
18:41:25 <dyl> The index tells you only what is contained within the horrors of the human psyche, not what is contained within the book.
18:41:28 <isaiah_> assignments within itself, but no side effects outside its scope? isn't that functionally equivalent?
18:41:39 <dyl> The idea isn’t no side effects ever.
18:41:51 <dyl> But rather to isolate the parts of your program that don’t have side effects.
18:42:01 <dyl> Because those are the ones you can reason about in a useful and consistent way.
18:42:23 <dyl> And also you can have internal scoped state while pretending you don’t, but you have to be very careful.
18:42:34 <dyl> This is what many “unsafe_____” functions are for.
18:42:34 <isaiah_> But can't I reason about a function with some internal state the same way I would without one? Since the end result is that F(x) = F(x)?
18:42:57 <dyl> For example I might implement matrix multiplication using unsafe pointers but in a way I can verify is correct, and hide it behind what appears to be a pure function.
18:43:00 <EvanR> if the internal state is used in such a way that is never visible to the outside world, then you are still a pure function
18:43:11 <dyl> It depends on how that state is kept and how it is managed.
18:43:21 <dyl> In general, most state is safe if it’s kept internal.
18:43:43 <isaiah_> So, is a for loop functional if the entire state is kept within the function and never exposed?
18:43:46 <dyl> But some “optimized” forms of state are not inherently safe and have to be carefully checked.
18:44:09 <dyl> This is the difference between State and ST in Haskell.
18:44:18 <dyl> State is safe by construction. ST is not always.
18:44:41 <dyl> isaiah_ there are also different ways to think of “state”.
18:44:53 <dyl> The functional form of state I personally call “an integrator”.
18:45:03 <dyl> In relation to a circuit which takes its own output as an input.
18:45:18 <dyl> As long as the state is kept internal and can’t be fucked with externally though, you can prove it’s safe.
18:45:31 <dyl> The point isn’t “no state” so much as “determinism”.
18:45:39 <isaiah_> Ok that makes sense
18:45:41 <dyl> What you care about is that f x is always the same.
18:45:45 <isaiah_> But why isn't a for loop deterministic
18:45:52 <dyl> No matter when you call it, if the parameters are the same, the result is the same.
18:45:57 <dyl> It could be, and often is.
18:46:09 <dyl> In functional languages you just tend to use recursion instead of loops
18:46:28 <dyl> They’re analogous and one can be expressed in terms of the other. I would argue recursion is more powerful though.
18:46:56 <dyl> Some recursive algorithms can be written as loops, but you end up needing state outside the loops modified within them.
18:47:02 <dyl> Think of a depth first search.
18:47:13 <dyl> You can write it with loops but you’ll need a variable that acts like a stack.
18:47:37 <isaiah_> Ok that makes sense
18:47:44 <isaiah_> And of course that's a great use for recursion
18:47:53 <dyl> Functional languages tend to be constructed such that stack overflows from recursion aren’t an issue.
18:48:01 <isaiah_> Right
18:48:06 <dyl> So we can use recursion freely without worrying so much.
18:48:09 <dyl>  Trade offs :)
18:48:12 <ddellacosta> isaiah_: side note, and not everyone agrees with this, but rather than thinking about "functional programming" as a monolithic thing I'd suggest instead focusing on specific qualities and how they manifest. In this case I think what you'd find useful to focus on is the concept of referential transparency: https://en.wikipedia.org/wiki/Referential_transparency
18:48:27 <`Guest00000> can you have functions at type level yet in Haskell? like (Int, Int) -> CellType
18:48:34 <dyl> I agree with ddellacosta
18:48:50 <isaiah_> I just found myself thinking while listening to talks, "this just sounds like good OO programming. I never expose state in a function anyway or have any "side effects" except for I/O"
18:49:06 <dyl> OO and FP aren’t contradictory or distinct
18:49:10 <dyl> They’re different philosophies really
18:49:24 <dyl> What you’re describing is the principle of encapsulation applied to state
18:49:42 <isaiah_> Right and encapsulation is just... normal coding in my mind lol
18:49:42 <dyl> But in many FP oriented languages you explicitly state where IO can happen.
18:49:58 <dyl> Namely it can only happen at the “top level”.
18:50:04 <dyl> Impure code can call pure code
18:50:11 <isaiah_> Right that makes sense
18:50:12 <dyl> But pure code can’t call impure code (generally)
18:50:25 <dyl> So think of a webservice that acts as a calculator
18:50:47 <dyl> Dealing with HTTP is impure, but parsing a string and evaluating it isn’t.
18:50:54 <isaiah_> Right so
18:51:02 <dyl> The pure part can be reasoned about and tested more consistently.
18:51:09 <dyl> This is just good coding in any language.
18:51:15 <isaiah_> As a programmer who has no experience whatever in fp, what about the code I would right wouldn't be fp?
18:51:17 <dyl> But FPO langs tend to enforce it more.
18:51:25 <isaiah_> because i would right a function that follow f(x) = f(x)
18:51:31 <ddellacosta> `Guest00000: yeah, for example https://wiki.haskell.org/GHC/Type_families
18:51:42 <isaiah_> *i would write
18:52:00 <dyl> isaiah_: you can always write OO code in a language without objects like C, no?
18:52:04 <dyl> Same with FP.
18:52:11 <dyl> It’s just a school of thought, an approach.
18:52:12 <juri_> does anyone here use accelerate-llvm-*?
18:52:19 <dyl> The difference is how the language and compiler you use is oriented.
18:52:28 <dyl> Does it enforce this behavior? Does it provide primitives for it?
18:53:41 <isaiah_> Like, say we're both taking that chllenge of the calc web service. I would create a function that takes in a string and outputs a number. Same result from same input every time. And you would do the same. Why would yours be fp and mine not? Or is this use case too simple for the differences to be manifested?
18:53:42 <dyl> The big things that functional programming focuses on is isolating side effects and referential transparency,
18:53:59 <dyl> The big thing that OO focuses on is a certain model of encapsulation derived from (imo) the message passing model.
18:54:19 <dyl> isaiah_: it’s not really correct to ask “is this FP” in that way I don’t think
18:54:37 <dyl> If we both wrote reverentially transparent functions, that’d be what we’d have done.
18:54:41 <dyl> I could write one in C.
18:54:49 <dyl> But the question is does the language make it hard NOT TO?
18:55:07 <dyl> And does it force you to mark what is or isn’t pure or reverentially transparent?
18:55:20 <isaiah_> Ok. So the people talking about "functional style JS" are kind of being facetious
18:55:22 <dyl> In C that would be float eval(const char *str)
18:55:40 <dyl> But the compiler cant prove that function won’t do side effecting things like read from stdin
18:55:44 <isaiah_> because anyone who's writing good code (referentially transparent) is already doing that
18:55:51 <ddellacosta> isaiah_: that's exactly why I suggested not getting caught up in "OO" vs. "FP," as in the end there is no coherent, universally agreed on definition of either. You'll get more mileage out of considering "smaller" concepts like referential transparency, idempotency, etc. etc.
18:55:53 <dyl> In Haskell you know that if a function signature doesn’t contain IO it doesn’t do IO
18:55:57 <dyl> That’s the distinction.
18:56:04 <dyl> It’s about guarantees.
18:56:11 <dyl> ddellacosta: ^
18:56:18 <dyl> 100% agree with ddella
18:56:24 <isaiah_> Ok. that makes sense.
18:56:52 <dyl> You can do OO and FP in any language, the question is how much the compiler helps you, and how much it constrains you to keep you disciplined.
18:57:06 <dyl> This is why it’s called an “object ORIENTED” language.
18:57:12 <dyl> You can use an object model in anything.
18:57:27 <dyl> But an OO language makes it easy or encourages it and provides constraints and guarantees for it.
18:58:14 <dyl> Same concept.
18:58:15 <isaiah_> Ok. So in an OO language, the object is the garauntee, and in a fp language the methodology is the garauntee in a way
18:58:17 <ddellacosta> yeah dyl I mean, the only place I'd disagree with you is that I'm even skeptical that it's worth talking about "OO" as a thing unto itself at all, even in the expansive way you're talking about it, but that's kind of getting into quibbling territory for what I think you're explaining well
18:58:46 <dyl> ddellacosta: im hand waving for clarity, but I’m also one of the weird people who does have a concrete definition of what OO should be :p
18:59:06 <dyl> When I say OO here what I mean is “what you think of as OO from using Java and Python
18:59:06 <ddellacosta> I hear you there...so much
18:59:15 <ddellacosta> gotcha
18:59:17 <dyl> Not readily definable, but still referenceable.
18:59:20 <isaiah_> So what I'm getting from this is that I shouldn't have an idea in my head of a dichotomy between OO and FP
18:59:20 <guidj0s> ddellacosta: A very simplistic and good-enough definition is to say that oo is about saying x.f() instead of f(x), IMO.
18:59:23 <dyl> I think OO means message passing :p
18:59:34 * dyl [purism intensifies]
18:59:36 <ddellacosta> guidj0s: so, like using lens? :-D
18:59:42 <dyl> isaiah_ right
18:59:48 <guidj0s> ddellacosta: I know 0 about lens :-)
18:59:49 <dyl> Don’t think of them as attributes or classifications of languages
18:59:55 <EvanR> the cthulu stuff was probably more relevant to OOP
18:59:56 <dyl> So much as approaches to program structure.
18:59:59 <ddellacosta> isaiah_: agreed
18:59:59 <dyl> They share many principles.
19:00:07 <dyl> But apply them differently.
19:00:12 <dyl> So focus on the individual principles.
19:00:15 <dibblego> you should try doing FP in other languages
19:00:28 <dyl> For example in python have you used functools and itertools?
19:00:39 <dyl> Those are both very functionally oriented stdlib modules.
19:00:44 <isaiah_> a bit yeah.
19:00:56 <isaiah_> And I do basic currying and stuff in the js i write
19:01:13 <dibblego> I first did FP in python about 11 years ago, learned it was impossible, and so started working on a compiler
19:01:16 <dyl> FP and OO are best thought of as “schools” of thought.
19:01:25 <isaiah_> But i think the source of my confusion was the fact that I had gotten the impression I was doing things that weren't "natural to the language"
19:01:31 <isaiah_> which is apparently not the case
19:01:34 <dyl> They’re not really two different things in terms of languages or program design, just in terms of approaches to the aforementioned.
19:01:46 <dyl> That’s what I mean by “oriented”
19:01:57 <dyl> x Oriented = makes x natural to the language
19:01:59 <ddellacosta> isaiah_: I think it's pretty clear when a language makes specific things hard or difficult, and that's definitely useful to notice
19:02:03 <dyl> But that’s a sliding scale.
19:02:15 <EvanR> doing nice functional things in dysfunctional languages is a recipe for heartache, wrist ache, and having your coworkers talk about you behind your back
19:02:26 <dyl> Python doesn’t make functional techniques easy, but they’re possible and enabled and the standard library provides utilities for that approach.
19:02:31 <isaiah_> EvanR why is that?
19:02:36 <dibblego> not in any practical way
19:02:38 <dyl> EvanR not always
19:02:46 <EvanR> isaiah_: well, try it
19:02:53 <isaiah_> like why is currying a bad idea in JS?
19:02:56 <dyl> Using functools and itertools in python can be great.
19:03:03 <dibblego> EvanR: http://functionaljava.org/ was the introduction of FP into the mainstream for Australia.
19:03:04 <EvanR> currying is not bad in JS
19:03:07 <dyl> Nothing is a good idea in JS :p
19:03:12 <EvanR> but it hurts your hands
19:03:14 <dyl> But ignore me haha
19:03:22 <dibblego> isaiah_: you'll blow stack
19:03:27 <dyl> That’s one example
19:03:29 <dibblego> the same is true for python
19:03:38 <dibblego> though, we have direct TCO in our python compiler
19:03:41 <dyl> If you try to implement some algorithms “functionally” namely using recursion in a language not oriented towards it
19:03:53 <dyl> you will end up recursing too much and blowing the stacks
19:03:57 <dyl> stack*
19:04:13 <isaiah_> Ok. So the debate with fp is really about builting interpreters with orientation toward things like allowing tons of recursion
19:04:14 <dyl> Most FP oriented languages don’t have stacks in the same sense.
19:04:16 <dibblego> unless you then write a Free interpreter for a trampoline
19:04:19 <EvanR> function fcurried(x){ return function(y){ return function(z){ return f(x,y,z); }}}
19:04:27 <isaiah_> not so much whether or not js or python writers should be doing it regularly
19:04:27 <dyl> That’s more what “orientation” is about.
19:04:28 <EvanR> fcurried(x)(y)(z)
19:04:39 <dyl> Think of it this way
19:04:44 <EvanR> not really a stack situation ^
19:04:48 <dibblego> isaiah_: that's just one component; the real deal is obtaining the practical benefits of FP in these languages, rather than just saying, "yes it has the map function (so what?)"
19:04:52 <dyl> Some human languages are better oriented towards describing certain things than others yes?
19:04:58 <dyl> Or may be easier to sing in than others.
19:05:04 <dyl> It’s just a matter of specialization.
19:05:07 <dyl> There’s no free lunch,
19:05:18 <EvanR> use the right tool for the job? no matter what human you are?
19:05:19 <dyl> no language can be the best at expressing everything in any way.
19:05:24 <dyl> EvanR yes
19:05:27 <dibblego> EvanR: that adds a constant factor to any other stack operations
19:05:38 <dyl> There are some things I wouldn’t use a functional language for.
19:05:43 <dyl> And others I would always reach for one for.
19:05:48 <dyl> It depends on what I’m doing.
19:05:51 <EvanR> dibblego: its not growing the stack without bounds though, like other issues do
19:05:57 <EvanR> its just slow
19:05:57 <dibblego> I don't know what a functional language is, but like what?
19:06:00 <dibblego> EvanR: right
19:06:02 <dyl> But understanding the variety of available approaches can make you a better programmer.
19:06:12 * hackage sparrow 0.0.2.0 - Unified streaming dependency management for web apps  http://hackage.haskell.org/package/sparrow-0.0.2.0 (athanclark)
19:06:17 <dyl> Knowing which tool to reach for in a given situation.
19:06:23 <`Guest00000> what's the simplest way to have type-level arrays in Haskell currently (indexed by (Int, Int), storing simple data)?
19:06:38 <dyl> If I want to write a toy compiler? Way easier in a functional language.
19:06:46 <dyl> If I want to write a kernel extension filesystem?
19:06:49 <dyl> I’m not using Haskell lol
19:07:04 <dibblego> why not?
19:07:12 <dyl> GC, for one.
19:07:19 <dyl> Ever written a kernel extension?
19:07:19 <isaiah_> why would a toy compiler be easier in haskell?
19:07:24 <dibblego> so you mean, GC languages, not FP languages?
19:07:25 <`Guest00000> dyl: that's an implementation problem
19:07:28 <dibblego> Yes.
19:07:33 <dyl> My point is I wouldn’t use Haskell
19:07:37 <dyl> Not because it’s FP
19:07:37 <guidj0s> Conclusion: should be fun to write OO-ish C that translates imperative-ish Haskell into funcional-ish JS.
19:07:40 <dyl> But I wouldn’t use it.
19:07:56 <dyl> The languages I recommend learning are: C, Erlang, Haskell, Prolog, Python, Lisp and Smalltalk
19:08:07 <dyl> If you learn all of those you’ll have a very good grasp of the available approaches.
19:08:24 <dyl> You may not ever use them (cough prolog)
19:08:25 <dibblego> dyl: try agda
19:08:29 <dyl> I hav.
19:08:30 <isaiah_> If you wouldn't mind dyl, why exactly would make haskell a better choice for a compiler?
19:08:41 <dyl> A variety of things.
19:08:47 <dyl> It’s hard to summarize in short notice.
19:09:02 <dyl> ADTs, pattern matching, easier testing.
19:09:09 <dyl> Compilers are mostly deterministic internally.
19:09:23 <dyl> It’s easier to translate a type checker’s logic to functional forms.
19:09:28 <dyl> Less impedance.
19:09:37 <dyl> It’s just more natural to express some of the concepts.
19:09:39 <guidj0s> "If you cannot summarize something in short notice, you don't really know it" -- Somebody (read "Eisntein" if it feels nice)
19:09:56 <dyl> No, that’s a bad paraphrasing of Feynman
19:10:10 <dyl> “If you can’t explain something to a freshman you don’t really understand it.”
19:10:15 <dyl> (Sic)
19:10:28 <dyl> But I’m on my phone waking to the bar.
19:10:32 <guidj0s> Thing is that is not funny.
19:10:58 <isaiah_> so basically, you would pick haskell because it has tools that make things like recursion easier, which is helpful for the kind of searching required for a compiler?
19:11:01 <dyl> Also I think what you just said is wrong.
19:11:10 <dyl> isaiah_: it’s not really about recursion here
19:11:28 <dyl> Do you think I could explain to you why I think Spanish is easier for writing poems to me than English?
19:11:34 <dyl> (I am bilingual.)
19:11:41 <dyl> You can’t explain something easily without shared context.
19:12:04 <dyl> You just have to give FP a try :)
19:12:13 <dyl> You’ll figure out what I mean in time on your own if you keep exploring.
19:12:19 <dyl> Maybe it won’t be easier for you, even.
19:12:48 <dyl> I regularly mix and match languages in my own projects, personally.
19:13:09 <dyl> I’m working on one right now in C, C++, Obj-C, Swift, and Haskell
19:13:21 <dyl> With Python and Scheme scripting support
19:13:23 <DigitalKiwi> search hackage for "language" sometime to see evidence of how haskell programmers really like parsing other languages
19:13:28 <dyl> ^
19:13:53 <guidj0s> Hahahahah
19:14:32 <DigitalKiwi> is it because haskell is good at it or we just don't have anything better to do than write compilers, who knows
19:14:34 <isaiah_> ich kann zwei Sprachen auch sprechen, aber mein Frage ist was sind der Spezifisch Mustern das ein Sprachen hat
19:14:43 <dyl> A good analogy:
19:14:55 <dyl> Some songs are easier to play on guitar than on piano, and vice versa.
19:15:04 <dyl> But that doesn’t mean either instrument is deficient in any way.
19:15:11 <dibblego> haskell can do left bind without complaining, and has library support for compiler-writing like no other language
19:15:13 <dyl> They’re just suited to different approaches to constructing music.
19:15:28 <ddellacosta> isaiah_: やってみれば分かる
19:15:30 <isaiah_> Spanisch ist romantisch: es ist einfacher zu Poesie gemacht.
19:15:30 <dyl> dibblego: except maybe Ocaml ;)
19:15:36 <dibblego> Ocaml is not even close.
19:15:40 <isaiah_> Was hat Haskell?
19:15:49 <dibblego> can't even get to lens with ocaml
19:15:50 <dyl> Ich bin ein jägerschnitzel
19:16:11 <ddellacosta> seriously though haskell is really nice for lexing/parsing, lots of great libraries there
19:16:34 <ddellacosta> maybe in part because of applicative
19:16:53 <dyl> I still want “return” deprecated lol
19:16:57 <dyl> Let me just use pure
19:17:06 <dyl> “return” needs to die.
19:17:07 <ddellacosta> like any language, Haskell has cruft
19:17:10 <guidj0s> Slightly related to the discussion: https://www.youtube.com/watch?v=iSmkqocn0oQ
19:17:28 <dyl> Avoid success at all costs!
19:18:14 <EvanR> DigitalKiwi: i resemble that remark
19:18:26 <dyl> New York’s hottest new club is... Haskell
19:18:28 <dyl> Glass, steam, bear traps, and just when you think the fun is over — knock knock, who’s there? It’s Black George Washington! All that, and a party room filled with human bathmats.
19:20:06 <ddellacosta> dyl: well then. I think that's my cue to go back to learning about Comonads
19:20:08 * ddellacosta waves
19:20:20 <dyl> You may be asking, what’s a human bathmat?
19:20:27 <dyl> That’s when midgets with dreadlocks lay face down on the ground.
19:20:34 <juri_> doom. the package i want to use doesn't compile.
19:20:44 <dyl> ddellacosta: comonads are fun :)
19:21:09 <dibblego> ddellacosta: write me the function that maps a function on a list, but that function needs to know the subsequent element to compute its result
19:21:29 <dyl> That’s not comonadic.
19:21:33 <dyl> Sublist zippers aren’t comonads.
19:21:38 <dyl> Only elementwise zippers.
19:21:51 <dyl> You can’t define extract for a 2 wide sublist zipper.
19:21:54 <dibblego> [] is a semi-comonad
19:21:56 <ddellacosta> dyl: so far seems like :-D
19:22:03 <dibblego> NonEmpty is a comonad
19:22:03 <ddellacosta> dibblego: okay let me see
19:22:08 <dyl> Guys were scaring isaiah_
19:22:25 <dyl> Comonads are just coburritos.
19:22:27 <dyl> Don’t worry.
19:22:58 <isaiah_> well thank you all, you've been very helpful
19:23:06 <ddellacosta> dibblego: that is really helpful actually, thanks. I mean your first comment...ties in with what I was reading here: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:23:06 <dyl> Just give it a shot.
19:23:10 <isaiah_> I'm off to learn closure and haskell
19:23:16 <dyl> If you’re a curious self-teaching person FP can be really fun.
19:23:18 <ddellacosta> isaiah_: good luck, come back any time
19:23:24 <isaiah_> Thanks, I will!
19:23:29 <dyl> This is the friendliest channel on freenode I think
19:23:36 <isaiah_> Haha I think you're right
19:23:41 <dyl> People here are always happy to help others learn.
19:23:52 <isaiah_> That's why I prefaced with "hey can i ask newb questions..."
19:23:58 <dyl> Yes haha
19:24:05 <isaiah_> well aware of the dire consequences of doing that in the wrong place
19:24:07 <dyl> We’re all newbs in some way or another here
19:24:16 <isaiah_> Cheers!
19:24:18 <dyl> Except edwardk
19:24:20 <dyl> He’s just an alien.
19:24:24 <dibblego> ddellacosta: next, write duplicate and extract, for (Store a) in data Store a b = Store (a -> b) a
19:24:36 <ddellacosta> dibblego: will give it a shot
19:24:48 <ddellacosta> reading this now, coincidentally: https://www.schoolofhaskell.com/user/edwardk/cellular-automata/part-1
19:25:04 <dibblego> duplicate :: Store a b -> Store a (Store a b); extract :: Store a b -> b
19:25:08 <dyl> If you want to summon Edward just mention Kan extensions or Yoneda
19:25:13 <dyl> He’ll appear instantly.
19:25:22 <dibblego> he's in Sydney
19:25:44 <dyl> You act as if he can only be in one place at a time.
19:26:42 * hackage etc 0.4.0.0 - Declarative configuration spec for Haskell projects  http://hackage.haskell.org/package/etc-0.4.0.0 (RomanGonzalez)
19:27:12 * hackage plot-light 0.4.1 - A lightweight plotting library, exporting to SVG  http://hackage.haskell.org/package/plot-light-0.4.1 (ocramz)
19:40:19 <infinisil> Hey
19:41:01 <infinisil> I remember seeing a package on hackage that provided a monad for having secure information flow based on some model (not ACL)
19:41:15 <infinisil> But I can't remember its name!
19:41:57 <infinisil> Anybody happen to know such a package?
19:49:38 <infinisil> It might have been https://hackage.haskell.org/package/seclib
20:05:12 * hackage plot-light 0.4.2 - A lightweight plotting library, exporting to SVG  http://hackage.haskell.org/package/plot-light-0.4.2 (ocramz)
20:17:02 <byorgey> infinisil: ttp://hackage.haskell.org/package/mac  perhaps?
20:17:58 <byorgey> I missed the h somehow.
20:21:41 <infinisil> byorgey: Yeah that's the one, thanks!
20:21:53 <byorgey> glad to help!
20:25:12 * hackage rakuten 0.1.1.3 - The Rakuten API in Haskell  http://hackage.haskell.org/package/rakuten-0.1.1.3 (matsubara0507)
21:30:43 <biglambda> Does anyone know what an error like: module ‘Control.Parallel.OpenCL.Query’ is a package module
21:30:45 <biglambda> means?
21:37:00 <dmwit> Is that the exact error?
21:37:01 <glguy> biglambda: I think it means that it's part of the package you're already working on, you don't need to :load it, you can import it
21:37:32 <biglambda> The whole error is: Preprocessing library OpenCL-1.0.3.4...
21:37:33 <biglambda> <no location info>: error:
21:37:33 <biglambda>     module ‘Control.Parallel.OpenCL.Query’ is a package module
21:38:23 <biglambda> It builds fine in local directory but when I try to cabal install it, it fails like that.
22:54:20 <xiaohei> I am writing a Functor instance for a datatype, but the code failed to compile and I have no idea why: http://bit.ly/2IxJVjo
22:54:43 * hackage componentm 0.0.0.0 - Monad for allocation and cleanup of application resources  http://hackage.haskell.org/package/componentm-0.0.0.0 (RomanGonzalez)
22:54:45 * hackage lifted-async 0.10.0.2 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.10.0.2 (MitsutoshiAoe)
22:55:41 <xiaohei> Anyone can help me?
22:58:24 <pavonia> xiaohei: You can't match on the values like this, you don't know what type f and g are of
22:58:43 <pavonia> *f' and g
22:59:10 <xiaohei> But I need to transform the argument a with f, right?
22:59:55 <pavonia> Yes, but you have to rely on f a and g a already having an Functor instance
23:00:18 <Cale> xiaohei: Those "patterns" don't make any sense -- f and g might not have constructors which look anything like that
23:00:38 <KernelBloomer> what future haskell holds? I dont find any jobs requiring haskell.. hmm?
23:00:52 <Cale> So yeah, you'll want something like  instance (Functor f, Functor g) => Functor (MyWrapper f g) where
23:00:52 <xiaohei> So i have to add some constraints for f and g?
23:01:23 <Cale>   fmap f (MyWrapper x y) = MyWrapper (fmap f x) (fmap f y)
23:01:56 <Cale> KernelBloomer: There are more and more jobs all the time. I'm working as a Haskell programmer.
23:02:09 <KernelBloomer> Cale, as remote?
23:02:12 <Cale> yep
23:02:14 <xiaohei> Oh, this makes sense to me.
23:02:17 <KernelBloomer> cool Cale !
23:02:27 <KernelBloomer> Cale, is it easy to get haskell job (remote)
23:02:30 <Cale> no
23:02:42 <Cale> The competition is pretty solid
23:02:43 <KernelBloomer> pre requisites? (must have experience in haskell I suppose? )
23:02:48 <KernelBloomer> ah I see
23:02:53 <KernelBloomer> damn indians
23:02:54 <KernelBloomer> :(
23:02:58 <Cale> huh?
23:03:11 <KernelBloomer> the competition comes from india and other parts of Asia, isnt it?
23:03:16 <KernelBloomer> in programming
23:03:26 <Cale> It's more like, there are people who have been programming in Haskell for 10 years. Not necessarily people from any particular country.
23:03:55 <Cale> In fact, if you live in the US, you probably have some amount of advantage with US companies, because it's getting pretty hard to hire all the best people from elsewhere.
23:04:01 <xiaohei> I am learning Haskell not for finding a job using Haskell, I am learning it for its abstraction concepts, which are really cool.
23:04:36 <KernelBloomer> Cale, unfortunately I am not from great America :( I wish I was but I am not. tons of jobs there in US with little to no competition
23:06:00 <Cale> I don't know of much competition from India actually. Mostly seems to be Europe and the US.
23:06:09 <Cale> But there are people all over of course.
23:06:40 <texasmynsted> so for the data61 classes, the preference is to use cabal for projects over stack.  I presume that inexperienced people end up messing things up with Stack and supporting only cabal simplifies support.
23:07:28 <Cale> texasmynsted: I imagine the difference doesn't matter so much
23:07:38 <texasmynsted> I started with stack, then moved to cabal.  Now I wonder if that was foolish.
23:07:50 <Cale> Just use whatever
23:08:06 <Cale> If you can install the dependencies you need, it's probably fine :)
23:08:25 <cocreature> someone made a fork of the data61 course the other day targetted at stack users
23:09:17 <iqubic> What is the point of the following data type:
23:09:49 <iqubic> Data these a b = This a | That b | These a b
23:09:50 <iqubic> ???
23:10:01 <Cale> iqubic: see align
23:10:06 <Cale> :t align -- is it in scope?
23:10:07 <lambdabot> error: Variable not in scope: align
23:10:12 <iqubic> I don't know what align is.
23:10:19 <iqubic> What module is it in?
23:10:23 <cocreature> iqubic: it’s like Either but it can also represent the case where both sides are present
23:10:28 <Cale> http://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html
23:10:32 <texasmynsted> I did not really care stack vs cabal before but now I think that was bad.  Intero requires Stack
23:11:23 <sclv> But many other editor tools do not require stack
23:11:47 <texasmynsted> but it seems to me that global deps could be provided via stack just fine, and one could simply use cabal for the data61 class. Right?
23:11:47 <sclv> Intero’s only real selling point is that it is more stack integrated tbh
23:11:48 <Cale> There are a lot of cases where you want to line up two containers holding values of types a and b respectively, and end up with a sort of "union"
23:12:06 <texasmynsted> heh oh
23:12:20 <iqubic> What does align even do? Is it useful in production code.
23:12:25 <texasmynsted> So maybe I do not care about Intero if I do not use stack
23:12:29 <Cale> We use it a fair amount
23:12:36 <sclv> Data61 materials aren’t particularly for cabal either
23:12:55 <sclv> They just presume ghci :-)
23:13:21 <xiaohei> Cale: How do I create a MyWrapper object?
23:13:40 <Cale> xiaohei: By applying MyWrapper to a value of type f a and a value of type g a
23:14:06 <texasmynsted> ok
23:14:13 <Cale> xiaohei: For example,  MyWrapper [1,2,3] (Just 5) :: MyWrapper [] Maybe Integer
23:14:32 <iqubic> How would "align :: [a] -> [b] -> These [a] [b]" work?
23:14:50 <Cale> iqubic: You mean [These a b]
23:14:59 <iqubic> I do?
23:15:08 <iqubic> Oh, I do indeed.
23:15:17 <iqubic> How would that work?
23:15:25 <xiaohei> I get it, thank you Cale.
23:15:44 <iqubic> I mean I assume "nil = []" for lists.
23:15:44 <Cale> So you'd get something like   align [1,2,3] ["hello", "world"] = [These 1 "hello", These 2 "world", This 3]
23:16:02 <Cale> and if we did it the other way around
23:16:26 <Cale> align ["hello", "world"] [1,2,3] = [These "hello" 1, These "world" 2, That 3]
23:16:37 <iqubic> I understand.
23:16:51 <iqubic> What the heck does unalign do? Is it just the opposite of that?
23:17:15 <Cale> yeah, sort of
23:17:43 <iqubic> And now we have crosswalk too? Is this stuff useful at all?
23:17:55 <Cale> I've never used crosswalk
23:18:15 <Cale> I imagine there's some places where it's useful, it's just not on my radar.
23:18:22 <iqubic> And then we have the not useful at all bicrosswalk.
23:18:34 <iqubic> An abstraction too great to be worth using.
23:19:13 <iqubic> I mean it's too perfect an abstraction to have any useful instances.
23:19:52 <Cale> I suspect there are plenty of other instances
23:20:12 <iqubic> No. Bicrosswalk only has the two instances listed.
23:20:13 <Cale> (though whether anyone has written those instances is another thing)
23:20:25 <Cale> How do you know that?
23:20:42 <Cale> In principle, it seems like a lot of bifunctors could support an operation like that
23:21:07 <Cale> bisequenceL seems useful
23:21:12 <iqubic> cale: What I mean to say is, the hackage page only lists two instances. There may be more instances.
23:21:16 <Cale> Even if just for These
23:21:23 <Cale> Yeah
23:22:42 <iqubic> I love how the traversals for these are called "here" and "there".
23:25:30 <Cale> iqubic: For a practical example, in FRP, you often want to merge two Events of different types, and so it's sometimes very natural to use align/alignWith
23:25:50 <Cale> alignWith :: (These a b -> c) -> Event t a -> Event t b -> Event t c
23:26:46 <Cale> So that lets you decide what value the resulting Event fires with based on whether just the first, just the second, or both input events are firing
23:27:21 <Cale> I probably use that around once a month
23:28:45 <iqubic> I see.
23:28:45 <iqubic> I don;t do any frp.
23:31:20 <iqubic> These is my favorite thing. I love these.
23:37:49 <iqubic> These is to Either what or is to xor
23:38:02 <sebastianrkg> is there any way to have an opaque Ptr (to a C struct)? The struct definition is enormous and I don't really want to describe it for inline-c to use, so I would prefer to have the Ptr not typed and not `peek`-able
23:47:15 <SlashLife> sebastianrkg: Coming from a C++ background, so this may not be the best thing to do in Haskell, but couldn't you introduce an empty fake struct in C and use a pointer to *that*, and then on the C side cast it around?
23:48:12 * hackage componentm 0.0.0.1 - Monad for allocation and cleanup of application resources  http://hackage.haskell.org/package/componentm-0.0.0.1 (RomanGonzalez)
23:48:50 <EvanR> so i have a loop that does getLine in ghci
23:49:06 <EvanR> and while i can hit enter forever
23:49:11 <EvanR> i cant hit ctrl-C :(
23:49:29 <Maxdamantus> (note that unlike in C++, you can't have a completely empty struct, though that solution should work if you just create a struct with a char in it or something)
23:49:31 <EvanR> and i cant kill the process
23:52:54 <cocreature> sebastianrkg: just create a new datatype with no constructors and use a Ptr to that datatype
23:53:04 <cocreature> sebastianrkg: if you don’t make a Storable instance you can’t peek
23:57:11 <glguy> EvanR: how about ^Z
23:57:40 <glguy> And then killing the job, e.g. kill -9 %1
23:58:03 <letsfindout> is there a better intro to haskell than "Learn You a Haskell"?
