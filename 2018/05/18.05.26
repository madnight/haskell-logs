00:00:05 <kuribas> noan: lens types are rather convoluted
00:00:30 <cocreature> jle`: what is there to be finished? afaik the only thing that’s missing is a better type search and iirc neil mentioned in the Haskell cast that the worse type search is a deliberate tradeoff since the old one didn’t scale to large package sets so I don’t see this changing anytime soon
00:00:46 <jle`> noan: ah in that case i usually use the index on the hackage docs :)
00:00:58 <jle`> cocreature: hm
00:01:05 <jle`> cocreature: well then, motivation to release hoogle 5 faster
00:01:05 <kuribas> And the documentation of lens is rather cryptic
00:01:47 <jle`> lens documentation is a lot better than people give it credit for i think, and it comes with some nice tutorials too :)
00:01:48 <noan> I grasp the basic idea of lenses, but I need to learn how the Lens lib itself works
00:01:58 <noan> in Elm and Scala understanding them isn't really difficult at all
00:02:03 <jle`> (^.) is pretty clear, "view the value pointed to by a Getter or Lens"
00:02:07 <kuribas> jle`: well, I am staring at things like Choice, and have no idea what it does
00:02:23 <cocreature> jle`: it already has a number of hackage releases. afaict all that’s missing is removing the alpha disclaimer and adding a url redirect from the old hoogle
00:02:31 <noan> jle`, here's an a and a getter, gimme the result of the getter used with the a
00:02:51 <jle`> kuribas: Choice is probably an implementation detail, no end user of lens has to actually ever use it
00:02:52 <noan> jle`, conceptually trivial, but learning the lib takes time to understand the various types and ways they compose and such
00:03:00 <jle`> kuribas: lens probably doesn't have to re-export it
00:03:15 <kuribas> jle`: it's in the type of _Left
00:03:18 <kuribas> :t _Left
00:03:19 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
00:03:33 <Axman6> that tooI feel lens get tarred with the same brush as the most obscure parts of it, there's some kind of crazy stuff in there with not amazing docs, but a lot of it has excellent docs
00:03:47 <jle`> ah yeah, that is *definitely* an abstraction leakage/implementation leakage
00:03:59 <jle`> _Left :: Prism (Either a c) (Either b c) a b
00:04:06 <cocreature> kuribas: type signatures being confusing and docs being confusing are not the same thing
00:04:33 <cocreature> the docs for _Left show you the type signature in terms of Prism which has docs and provide several usage examples
00:04:36 <jle`> you don't need to understand Choice to understand _Left, you just need to understand Prism
00:04:44 <noan> lens uses the standard terms though I think right?
00:04:51 <noan> Iso, Prism, Lens, Getter, Setter?
00:04:55 <cocreature> although I’m a bit confused why ghci just ignores the type synonym here
00:04:58 <jle`> so the docs only mention _Left with the Prism type
00:05:04 <Axman6> I feel it could occasionally do things like remind the user that ((->) a) is MonadReader and is probably the most useful use for the things which work on MonadReader (though I should probably check the docs and make sure that's not the case these days)
00:05:05 <jle`> yeah, ghci is the culprit here
00:05:14 <kuribas> "A Getter s a is just any function (s -> a), which we've flipped into continuation passing style, (a -> r) -> s -> r and decorated with Const to obtain:"
00:05:18 <jle`> noan: yeah, if anything, it invented them :)
00:05:22 <kuribas> That isn't user friendly?
00:05:42 <jle`> kuribas: where is that in the docs?
00:05:45 <noan> jle`, I would not be surprised if it did. Functional scala is inspired by haskell, and Elm is written IN haskell.
00:05:47 <jle`> oh i see it
00:06:04 <jle`> kuribas: i mean, it's helpful enough if you stop after the first comma
00:06:07 <kuribas> jle`: https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Getter.html
00:06:10 <jle`> "A Getter s a is just any function (s -> a)"
00:07:13 <jle`> yeah that could probably be re-written to have a period there instead of a comma
00:07:20 <kuribas> jle`: I am just saying, not every haskell user who wants to use a lens knows what Const does, and what CPS is.
00:07:35 <Axman6> I wish we could define type patterns for GHCi, to sy things like, if you see a type of this chape, also tell the user it matches this other name for that type (so, something of type Applicative f => (a -> f b) -> s -> f t should say it also has type Traversal s t a b)
00:07:48 <jle`> kuribas: i know, but from the beginning of the sentence, most haskell users should already know what a Getter does
00:07:55 <jle`> "A `Getter s a` is just any function (s -> a)"
00:08:44 <jle`> but having a comma instead of a period after that clause does make it sound like the rest of that sentence is relevant
00:08:53 <jle`> for understanding what a Getter is
00:09:08 <noan> oh, wait, I need to make my datatypes Functors if I want to use lens with them don't I?
00:09:12 <cocreature> Axman6: at some point I was trying to accomplish something like this as a GHC plugin to modify error messages but I couldn’t figure out how modify the error messages on unification failures
00:09:14 <noan> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
00:09:16 <kuribas> jle`: something like: "a getter retrieves the value pointed at the focus of the optic".
00:09:25 <jle`> it's...not the way i would have written it, but if i were a new haskeller i would just see "A `Getter s a` is a function (s -> a)" and then understand what a GEtter is
00:09:28 <cocreature> noan: no that Functor constraint is an implementation detail
00:09:31 <jle`> noan: no, you do not :)
00:09:39 <jle`> noan: the "things" are the s, t, a, and b
00:09:44 <jle`> noan: note that none of them need to be functors
00:09:49 <jle`> in fact, they actually can't be functors
00:09:56 <jle`> since it wouldn't typecheck/kindcheck
00:09:58 <cocreature> kuribas: the docs on the type synonym themselves say “A Getter describes how to retrieve a single value in a way that can be composed with other LensLike constructions.” which seems fairly reasonable
00:10:05 <Axman6> cocreature: sounds like it could make an interesting student project
00:10:31 <noan> ah okay
00:10:34 <jle`> the actual documentation for `Getter` is not unreasonable i don't think
00:11:03 <jle`> but yeah the module header might be a bit scary
00:11:25 <kuribas> cocreature: yeah, that's pretty clear
00:11:41 <jle`> i think some of it is an artifact of a time when the *implementation* of the lens library was pretty novel/something worth talking about
00:11:43 <cocreature> it might help to have some subsection titled “implementation details” (or something similar) where you put the cps and Const stuff
00:11:43 <noan> Is there a decent way to generate Lenses for my types without writing boilerplate?
00:11:50 <cocreature> noan: makeLenses
00:12:05 <Axman6> see Control.Lens.TH
00:12:11 <kuribas> jle`: right, so it was meant for people who already understood the concepts
00:12:19 <Axman6> (which is exported by Control.Lens)
00:12:21 <jle`> kuribas: it was meant for people who want to know about how it was implemented
00:12:23 <jle`> i think
00:12:33 * hackage potoki-core 0.11 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-0.11 (NikitaVolkov)
00:12:41 <jle`> a big chunk of the module header documents the implementation, which is probably scary for a new haskeller
00:12:53 <kuribas> jle`: but it could easlity have both
00:12:55 <jle`> i would just move all talk of implementation to its own small section, it doesn't deserve to be at the top of the module
00:12:59 <jle`> i don't think so
00:13:16 <jle`> documentation is supposed to first address how to use the library, right?
00:13:16 <noan> cocreature, cheers
00:14:02 <jle`> having implementation take up so much space at the module header means you devote a bunch of space to explaining the implementation before you can even get to learning how to use it later on in the page
00:14:51 <jle`> the module header for the Getter page actually goes back into talking about usage halfway down so that's kinda nice
00:15:16 <jle`> but putting the implementation at the top also implies that they're explaining the implementation because you need to know it to use it
00:15:30 <jle`> in this case though the implementation of 'getter' is not something that any person using lens ever has to know
00:15:58 <kuribas> jle`: right
00:15:59 <jle`> (except for when type signatures leak v.v)
00:16:29 <kuribas> it'd be nice to have an option to rewrite type-signatures in their most general form
00:16:32 <jle`> ok so i guess my position has circled around a bit, but i do think that the actual function and export documentation for lens is pretty good these days
00:17:10 <cocreature> it’s not a case of missing docs but maybe a case of too much docs/docs being in the wrong place
00:17:10 <kuribas> jle`: yeah, I completely agree
00:17:24 <kuribas> jle`: and also the types ghci gives
00:17:47 <jle`> is it too late too submit projects for gsoc? :)
00:17:54 <cocreature> yes :)
00:17:57 <jle`> :(
00:18:16 <jle`> that probably has to be near the top of my haskell usability/ergonomics wishlist
00:19:02 <kuribas> jle`: compare with this: https://hackage.haskell.org/package/microlens-0.4.9.1/docs/Lens-Micro.html#g:2
00:19:24 <cocreature> tbf for lens specifically, you are probably better off reading the simplified type signatures in the docs than checking types in ghci anyway
00:19:55 <jle`> ghci isn't the only culprit though, i think it breaks when you start doing hole driven development and start debugging type errors
00:20:24 <jle`> kuribas: refreshing :)
00:21:18 <siraben> What are some recommended books for learning Haskell?  Ideally it should be in print.
00:21:27 <kuribas> jle`: that includes tooling
00:21:31 <siraben> http://haskellbook.com/ seems good but it's not available in print yet -_-
00:21:41 <jle`> -_-
00:21:48 <kuribas> cocreature: that includes tooling
00:22:02 <jle`> (sorry that is me sharing in your sadness, not me mocking you)
00:22:13 <cocreature> kuribas: what includes tooling?
00:22:23 <kuribas> cocreature: tooling will gives you the type ghci gives
00:22:38 <kuribas> cocreature: like hovering over a function in emacs
00:22:49 <cocreature> sure
00:23:56 <siraben> jle`: What about lectures on Haskell?  Or is it too "new" for courses to be based on it?
00:24:07 <jle`> @where learnhaskell
00:24:08 <lambdabot> https://github.com/bitemyapp/learnhaskell
00:24:22 <Athas> Haskell is older than Java!
00:24:23 <kuribas> siraben: haskell is from the same year as java :)
00:24:55 <cocreature> siraben: I’ve heard good things about the second edition of Graham Hutton’s book “programming in Haskell” which is available in print afaik
00:25:10 <siraben> jle`: Yes I read that resource before but wanted to find video lectures
00:25:19 <siraben> Athas: Argh, my apologies!
00:25:24 <kuribas> Athas: oh right, it's 5 years older
00:26:48 <Athas> siraben: I also recommend Hutton's "Programming in Haskell".
00:27:38 <Athas> Some people like its style.  It's very concise and to the point.  Others prefer more verbose/demonstrative exposition.
00:29:12 <siraben> Are there "minimal" implementations of Haskell that can be experimented with?  Kinda like Scheme vs. Common Lisp.
00:29:54 <siraben> Miranda, perhaps?
00:30:05 <jle`> you can just use a minimal subset of ghc haskell, if that's what you mean?
00:30:08 <Athas> siraben: the Miranda implementation is not free.
00:30:26 <Athas> What kind of experimentation do you want?  Experimentation with implementation, or just a smaller language?
00:30:54 <Athas> Haskell is not large (about the size of Scheme, really) if you don't use any GHC extensions.
00:31:06 <siraben> What headers would I need to put to do that?
00:31:11 <Athas> None.
00:31:18 <Athas> It's (almost) what you get by default.
00:31:41 <jle`> you can also just like, not use those features
00:31:44 <jle`> even if they were enabled
00:32:00 <Athas> Looking at the Haskell 98 report, it seems to spend only 78 pages on the language, and then about 150 on the standard libraries.
00:32:08 <Athas> Haskell 2010 is only trivially larger.
00:32:45 <jle`> if we're talking about implementing a haskell compiler, then haskell 98/2010 are probably good points to start off with...but a haskell compiler isn't the easiest compiler to write, as far as compilers for popular languages go, heh
00:32:52 <kuribas> siraben: the advanced features should "get into your way" when programming.
00:33:07 <kuribas> siraben: should not
00:33:21 <jle`> siraben: yeah, it's always a choice to use a ghc-specific feature
00:33:34 <jle`> but some of them are pretty useful
00:33:36 <jle`> like tuple seconds
00:33:44 <siraben> Right, I just find that reimplementing library features helps understanding
00:33:48 <jle`> > map ('a',) [1,6,2,3]
00:33:50 <lambdabot>  [('a',1),('a',6),('a',2),('a',3)]
00:33:53 <siraben> Like append, filter, map etc.
00:33:55 <jle`> ^ that requires a ghc-specific feature
00:34:00 <Athas> siraben: then do it!
00:34:05 <siraben> Yay :)
00:34:08 <Athas> siraben: it used to be a recommended exercise to re-implement the Prelude.
00:34:11 <jle`> siraben: that's definitely a common thing for exercises :)
00:34:30 <Athas> There are some things that are really annoying to re-implement (like the basic types and addition and such), but the list combinators are good exercise.
00:34:34 <jle`> siraben: oh, do you mean a "minimal haskell" as in, a minimal set of functions that you have to use in order to do things?
00:34:42 <kuribas> siraben: you can try implement the specific version (for list for example).  Look at the generic ones later.
00:34:42 <jle`> or like a minimal language with minimal features
00:34:51 <siraben> I tried to learn haskell last year before I knew enough FP, so giving it a second try after following SICP.
00:34:59 <siraben> *which teaches Scheme
00:35:06 <jle`> almost all of haskell's standard libraries is written within haskell
00:35:06 <siraben> jle`: Like a minimal set of functions
00:35:14 <jle`> siraben: ah yeah, ok
00:35:21 <david_____> is someone here familiar with the qfpl course? :) i have a question
00:35:35 <jle`> yeah, almost all of haskell's standard libraries are implementable with just pattern matching
00:35:43 <jle`> without requiring any functions given magically by the compiler
00:35:51 <cocreature> david_____: just ask your actual question directly :)
00:35:55 <siraben> So Haskell is purely functional?  No "set!" at all?
00:35:58 <jle`> the exception are some of the built-in types like Int
00:36:10 <kuribas> siraben: try doing sicp exercises in haskell?
00:36:20 <Athas> siraben: there is unsafePerformIO (a GHC extension function), but apart from that there is nothing like set!.
00:36:21 <siraben> kuribas: A scheme interpreter would be fun to write
00:36:22 <jle`> siraben: yes, it actually "has" to be purely functional, because of laziness
00:36:29 <jle`> sunafePerformIO is not really anything like set
00:36:35 <siraben> But if I write a Scheme interpreter, how can it simulate "set!"
00:36:42 <kuribas> siraben: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
00:36:43 <jle`> siraben: using normal functions and values
00:36:55 <jle`> siraben: that's the thing about haskell, it makes you realize how reliant you were on compiler magic
00:37:04 <jle`> siraben: when it's something you could just write using normal functions
00:37:22 <jle`> it lets you realize that "side effects" are never necessary, it's just things you can write on your own
00:37:44 <jle`> siraben: your scheme interpreter is just a pure function
00:37:56 <siraben> Side effects make reading code so much easier, because everything is composable and works in the same way.
00:37:56 <kuribas> jle`: unless you want it to do IO?
00:37:58 <jle`> it tracks set through normal function application, etc.
00:38:10 <siraben> IO is implemented purely functionally as well in Haskell?
00:38:13 <siraben> Through monads?
00:38:18 <jle`> siraben: side-effects makes it much much harder to read code
00:38:20 <jle`> are you kidding? ;)
00:38:28 <jle`> siraben: every single line you read might have global side-effects
00:38:35 <jle`> it might affect something in a completely different place
00:38:37 <newhoggy> Anyone know why "Data.Vector.Storable.createT (undefined :: forall s. ST s (Maybe (DVSM.MVector s Word64)))" doesn't work?
00:38:38 <Athas> siraben: no, IO is *implemented* with compiler magic/intrinsics, but the interface is monadic.
00:38:47 <jle`> there is no way to understand code in a side-effective world
00:38:51 <newhoggy> The error I get is: Couldn't match type ‘Maybe’ with ‘[]’, Expected type: ST s [DVSM.MVector s Word64], Actual type: ST s (Maybe (DVSM.MVector s Word64))
00:38:54 <jle`> kuribas: i'm making the distinction between side-effects and effects
00:39:02 <jle`> IO is programmed using first-class effects
00:39:07 <jle`> effects as first-class, pure values
00:39:17 <jle`> siraben: IO in haskell is programmed purely
00:39:27 <jle`> "the interface is monadic" isn't a true statement
00:39:29 <kuribas> jle`: right, but you'll need effects also in the interpreter, so it will not be a pure function
00:39:36 <siraben> jle`: I'm using IO in a REPL, how could it affect global state?
00:39:46 <siraben> Input -> AST -> Eval -> Print
00:39:47 <kuribas> jle`: as in scheme, every function can do IO
00:39:57 <jle`> in haskell, you assemble IO purely
00:40:01 <siraben> Ah so implementing (read) could be tricky?
00:40:10 <Athas> newhoggy: my guess is you have a 'return' too much or too little.  GHC seems to default to the list monad if it infers something to be monadic that probably shouldn't be.
00:40:22 <jle`> siraben: this is a common thing actually for people learning haskell when coming in from other languages
00:40:37 <jle`> siraben: you learn certain things and then think "but how will i do (X thing that i used to do)?"
00:40:38 <cocreature> newhoggy: this typechecks for me
00:40:46 <kuribas> siraben: why not check out the wikibook I linked?
00:40:46 <siraben> Because you could write a REPL in Scheme which is run in a REPL in Haskell
00:40:50 <siraben> kuribas: I just did.
00:40:54 <cocreature> newhoggy: so I would guess that the problem probably comes from the context you’re trying to use it in
00:40:56 <jle`> siraben: it might be best to just see when you start to implement the things
00:41:07 <jle`> siraben: and you will find that the things you are worrying about aren't problems at all
00:41:09 <newhoggy> Works in the repl:
00:41:15 <newhoggy> λ> DVS.createT (undefined :: forall s. ST s (Maybe (DVS.MVector s Word64)))
00:41:15 <newhoggy> *** Exception: Prelude.undefined
00:41:38 <Athas> siraben: if you want your Scheme interpreter to support *real* IO, then the implementation in Haskell also needs to run in the IO monad.
00:41:40 <jle`> siraben: when you read code written with side-effects, you always have to track the side-effects in your head.
00:41:44 <siraben> What about locks in file I/O?
00:41:53 <jle`> siraben: haskell has first-class effects, for IO
00:42:03 <jle`> siraben: meaning your scheme interpreter is a *pure* function, Text -> IO ()
00:42:08 <siraben> Right.
00:42:12 <jle`> it takes a text file, and outputs a program
00:42:18 <jle`> haskell is about writing that pure function
00:42:28 <jle`> it's about *describing* the IO that that scheme source file will do
00:42:34 <jle`> you never actually do any of the IO
00:42:36 <jle`> you just *describe* it
00:42:39 <Athas> siraben: in Haskell, in the IO monad, you can do pretty much whatever you want in terms of calling low-level effectful functions.  So you lock files just like you would in any other language.
00:42:53 <Athas> The only thing special about Haskell, IO-wise, is that it forces you to be honest in the types about where it might happen.
00:42:53 <jle`> and i think also thinking about IO as monadic is a pretty big distraction
00:43:00 <jle`> i wouldn't call it "the IO monad"
00:43:09 <jle`> because most of the things about IO actually don't have anything to do with monads
00:43:17 <jle`> the useful part about IO is unrelated to the fact that it is a monad
00:43:22 <jle`> and most of the time you are using, you won't be using it monadically
00:43:27 <siraben> Anyone do their Haskell programming in Emacs?  What configuration are you using?
00:43:50 <Athas> siraben: I use a very lightly configured haskell-mode.  More complex setups exist, but I found them fragile.
00:43:58 <cocreature> I use haskell-mode in pretty much the default config
00:44:03 <cocreature> + ghcid outside of emacs
00:44:17 <jle`> siraben: having these "but how will I do (X thing that I used to do in a different language)?" thoughts is pretty normal for people learning haskell when coming from a different language :)  but trust me, when you start writing the code, you'll see that those concerns end up being non-issues for the most part
00:44:19 <siraben> Athas: And that handles indentation too?
00:44:22 <kuribas> siraben: haskell-mode + flycheck-haskell
00:44:31 <newhoggy_> I think you're right.  Something wrong with my context.
00:44:34 <siraben> jle`: Right.  I felt the same way learning Scheme
00:44:40 <jle`> that's why a lot of people say that haskell is easier to learn as a first language
00:44:42 <siraben> Can't wait to see Haskell's magical powers
00:44:58 <jle`> because if you learn haskell coming from another language, you become your own worst enemy with distractions, heh
00:45:15 <jle`> siraben: enjoy the journey :)(
00:45:27 <jle`> for what it's worth, writing compilers and interpreters is actually haskell's "killer app"
00:45:43 <siraben> jle`: Oh that fits right in.
00:45:47 <jle`> haskell is great for a lot of things but if there's one niche where it unreasonably excels so far in, it's compilers/interpreters
00:46:03 <jle`> kind of funny how it ended up that way
00:46:14 <boj> (or stream parsing, that is what i am doing atm)
00:46:35 <siraben> I've been writing compilers and interpreters in Scheme myself, but it would be nice to have actual lazy programming, pattern matching and compile-time type checking in my language
00:46:48 <siraben> Which is what made me want to learn Haskell
00:47:11 <siraben> So parsing would be the step from Text -> AST?
00:47:34 <newhogg__> Thanks cocreature.  It's all sorted now.
00:47:55 <kuribas> siraben: TBH, I think scheme makes for a nice previous language when going to haskell.
00:48:14 <kuribas> siraben: as they already prefer pure functions
00:48:29 <kuribas> siraben: and treat functions as first class objects
00:49:08 <Athas> siraben: yes.  I vaguely remember that you have to enable one of two available indentation modes.
00:49:12 <Axman6> > (Right "This", ["has","several","strings"],("I","wonder", Just "what", ("we", "can", do "!"))) & partsOf template %~ (reverse @[String])
00:49:14 <lambdabot>  error:
00:49:14 <lambdabot>      Pattern syntax in expression context: reverse@[String]
00:49:14 <lambdabot>      Did you mean to enable TypeApplications?
00:49:19 <Athas> (I don't know why haskell-mode is such a mess.)
00:49:26 <Axman6> urgh, yes I did lambdabot
00:49:28 <kuribas> Athas: mess in what way?
00:49:38 <Axman6> > (Right "This", ["has","several","strings"],("I","wonder", Just "what", ("we", "can", do "!"))) & partsOf template %~ (reverse :: [String] -> [String]))
00:49:40 <lambdabot>  <hint>:1:151: error: parse error on input ‘)’
00:49:48 <Axman6> > (Right "This", ["has","several","strings"],("I","wonder", Just "what", ("we", "can", do "!"))) & partsOf template %~ (reverse :: [String] -> [String])
00:49:50 <lambdabot>  (Right "!",["can","we","what"],("wonder","I",Just "strings",("several","has"...
00:49:57 <newhogg__> Also thanks Athas
00:50:02 <cocreature> kuribas: mess in that it can be very confusing to setup. there are multiple indentation modes, multiple repl modes, …
00:50:06 <cocreature> newhogg__: I’m curious, what was the problem?
00:50:13 <Axman6> > (Right "This", ["has","several","strings"],("I","wonder", Just "what", ("we", "can", do "!"))) & partsOf template %~ (reverse :: String -> String)
00:50:15 <lambdabot>  (Right "!nac",["ewt","ahwredn","owIsgni"],("r","tslare",Just "vess",("ah","s...
00:50:37 <Athas> kuribas: well, it's been a while since I looked closely into it, but for example that there are two indentation schemes, called haskell-indent-mode and haskell-indentation-mode (or something like that).
00:50:40 <kuribas> Athas: the defaults should work fine?
00:50:55 <kuribas> Athas: haskell-indent-mode is the old one, and it's pretty hairy.
00:51:03 <siraben> kuribas: I relied on the Scheme reader to parse the text, but it would be fun to parse it myself.
00:51:12 <newhogg__> This is the working solution:
00:51:15 <newhogg__> go :: [BS.ByteString] -> [DVS.Vector Word64]
00:51:15 <newhogg__> go bs = case DVS.createT (buildOneVector n bs) of
00:51:15 <newhogg__>   (cs, ws) -> if DVS.length ws > 0
00:51:17 <newhogg__>     then ws:go cs
00:51:19 <newhogg__>     else []
00:51:26 <Athas> kuribas: yet it's the one that uses the 'indent' term, which is the general Emacs term for indentation.
00:51:33 * hackage potoki-core 0.12 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-0.12 (NikitaVolkov)
00:51:37 <newhogg__> Problem is I attempted to do this:
00:51:47 <kuribas> Athas: haskell-indentation could have been named haskell-indent2-mode
00:51:54 <kuribas> or haskell-indent-ng
00:51:55 <newhogg__> go :: [BS.ByteString] -> [DVS.Vector Word64]
00:51:55 <newhogg__> go bs = do
00:51:55 <newhogg__>   _ <- createT …
00:51:57 <newhogg__>   …
00:52:01 <kuribas> Athas: but haskell-indentation stuck
00:52:18 <cocreature> newhogg__: ah makes sense
00:52:29 <Athas> Yes, that would probably have been better.  Oh, and I see that `turn-on-haskell-indentation` also became `haskell-indentation-mode` (three years ago).  Good!  As I said, I haven't kept up much.
00:52:42 <kuribas> Athas: IMO hasell-indentation is far from perfect, but it's much better then haskell-indent.  Then again I am biased since I wrote haskell-indentation-mode :)
00:52:50 <Athas> I did notice that it was starting to improve last time I checked in.
00:53:09 <kuribas> Athas: so you may direct any rants towards me :)
00:53:09 <newhogg__> And with that I managed to convert my ST monad computation from strict to lazy.  \o/
00:53:39 <siraben> I like this Haskell version of `map' using hieroglyphs https://www.reddit.com/r/ProgrammerHumor/comments/7gztuf/%F0%93%82%80%F0%93%81%9F%F0%93%8C%8Dhs/
00:54:03 <newhogg__> Seems to have doubled the speed to.  Not understanding why though :/
00:54:13 <kuribas> siraben: A difference between haskell and scheme is that haskell programmers prefer using combinators (and currying), while scheme programmers tend to write out loops.
00:54:36 <newhogg__> I guess it might have something to do with improved locality?
00:54:36 <kuribas> siraben: and of course ADTs and lazyness.
00:54:39 <siraben> kuribas: Write out loops?
00:54:43 <siraben> Like iterations?
00:54:49 <kuribas> siraben: like recursive functions?
00:54:55 <siraben> Oh yes.
00:55:16 <siraben> I often rewrite my functions in CPS in Scheme to do exceptions
00:55:44 <siraben> Streams can be implemented, but Haskell does it much more elegantly
00:56:48 <kuribas> siraben: for example, in haskell you'd write: sum = foldl' (+) 0
00:58:23 <siraben> Are there toy implementations of a haskell interpreter written in haskell?
00:58:30 <siraben> For a subset of Haskell
00:58:48 <jle`> siraben: eventually the big picture is "Text -> Program", where program is a data type that describes all of the effects that your source file encodes.  then finally a Program -> IO (), which translteas your program's encoding into a description of IO
00:58:59 <jle`> siraben: actually that's one of the usual 'midterm' projects for most haskell courses
00:59:14 <siraben> jle`: Which one?  Haskell in Haskell?
00:59:18 <jle`> there are hundreds of those scattered around in students hardrives ~
00:59:24 <siraben> It's like Scheme in Scheme
00:59:27 <jle`> siraben: a small haskell-like language compiler/interpreter
01:00:09 <jle`> but if you follow a haskell course, chances are you will end up being told to make one as an exercise
01:00:16 <jle`> usually about halfway through
01:00:42 <jle`> my sample size on haskell courses i've read through is admittedly small though
01:01:48 <jle`> yes this disqualified LYAH as a real haskell course
01:01:56 <jle`> s/disqualified/disqualifies
01:02:43 <kuribas> siraben: in scheme it would be like this: (define (sum l) (if (null? l) 0 (+ (car l) (sum (cdr l)))))
01:03:18 <siraben> kuribas: Alternatively, if you have defined `reduce': (define (sum l) (reduce l + 0))
01:03:29 <kuribas> siraben: yeah, that's more like haskell :)
01:04:01 <siraben> A Scheme->Haskell compiler would be an interesting project, actually.
01:04:33 * hackage type-of-html 1.4.0.1 - High performance type driven html generation.  http://hackage.haskell.org/package/type-of-html-1.4.0.1 (knupfer)
01:06:31 <siraben> What about macros in Haskell?
01:06:36 <siraben> Are they not necessary?
01:08:20 <kuribas> siraben: template haskell
01:08:47 <kuribas> siraben: usually you try the combinator approach first, then generics.
01:08:56 <kuribas> siraben: TH only when it doesn't fit those
01:15:02 <kuribas> oh no, they replaced sicp (scheme) with python!  http://www.posteriorscience.net/?p=206
01:16:49 <siraben> kuribas: Yeah, it's sad.
01:17:05 <siraben> Scheme is a much easier language to reason with, because the syntax just goes away
01:17:48 <kuribas> siraben: exactly.  It's also a better language.
01:18:16 <siraben> And plus you get to write small, self-evaluating interpreters in it!  There's PyPy, but it's large and unless you know the intricacies of the CPython runtime, you can't replicate it.
01:19:57 <siraben> Hmm Haskell lectures are really hard to find.
01:20:02 <siraben> video lectures*
01:21:06 <kuribas> siraben: I found this? https://www.youtube.com/playlist?list=PLtRG9GLtNcHBv4cuh2w1cz5VsgY6adoc3
01:21:53 <martinmch> siraben: There's a bunch on pluralsight
01:21:54 <martinmch> https://www.pluralsight.com/courses/haskell-fundamentals-part1
01:22:11 <siraben> Right, but with a textbook to go with it.
01:22:15 <siraben> And exercises
01:22:24 <kuribas> siraben: not to mention weird quirks, like boolean being a number, if doing implicit conversion, using exception for control flow (for example generators).
01:22:37 <siraben> But it's fine, I'll buy Programming in Haskell and learn from that.
01:23:04 <siraben> kuribas: Yes.  I think Python's weak typing made me overconfident as a programmer initially.
01:23:11 <Myrl-saki> How do I add a dependency to Cabal only if I'm using ghcjs?
01:23:14 <centril> Has anyone ever considered the shorthand syntax:    foo :: (x :: Ty, y: Ty) -> Ty = x + y   which destructures tuples and adds a type signature at the same time?
01:23:36 <siraben> kuribas: e.g. "Why are there no strings in C?  Why can't I do a + b to concatenate them???"
01:23:57 <centril> also:   foo :: (x :: Ty) -> (y :: Ty) -> Ty = x + y
01:24:05 <kuribas> siraben: well, you could in C++
01:24:17 <siraben> kuribas: Ah, but I never learned C++.
01:24:32 <kuribas> siraben: it supports operator overloading.  But unlike in haskell, it's lawless.
01:24:43 <siraben> "lawless"?
01:25:18 <kuribas> siraben: you can overload an operator to do anything you want.
01:25:25 <kuribas> siraben: compare with (<>)
01:25:31 <kuribas> :t (<>)
01:25:32 <lambdabot> Monoid m => m -> m -> m
01:25:50 <centril> kuribas: Haskell does not really encode any laws in type classes tho; so that's a bit misleading
01:26:00 <centril> its just "hand waved" in documentation
01:26:05 <kuribas> centril: right, so it's less lawless :)
01:26:16 <centril> kuribas: right
01:26:35 <siraben> Oof the terminology (Monads, Monoids, Semigroups, Functors etc.) will take a bit getting used to!
01:26:45 <siraben> Sounds like some category theory-level stuff
01:27:13 <Axman6> because it is, bu these are all simple concepts
01:27:20 <kuribas> siraben: there isn't much more to it, other than that <> is expected to be associative.
01:27:31 <kuribas> siraben: and for Monoid you need mempty
01:28:26 <centril> siraben: Semigroup:  A binary operation   * : A -> A -> A,  where * respects associativity,    Monoid:  Semigroup where * also has an element 'e' which is left and right identity for the operation
01:28:52 <centril> (*, 1, Nat)  constitutes a monoid  and so does  (+, 0, Nat)
01:29:16 <centril> (&&, True, Bool)  and  (||, False, Bool)  constitute monoids also
01:29:48 <jesyspa> kuribas: I think a stronger argument is that C++ allows you to overload with no reference to a typeclass at all. :)
01:30:03 <kuribas> siraben: anyway, so the associative bit isn't enforced by haskell, but at least you need to match the signature.
01:30:37 <siraben> centril: Oh that was pretty simple!
01:31:02 <siraben> Haskell makes those  annotations explicit, which is nice
01:31:27 <kuribas> > "hello, " <> "world" -- siraben: to concatenate strings
01:31:29 <lambdabot>  "hello, world"
01:31:50 <siraben> :t (<>)
01:31:51 <lambdabot> Monoid m => m -> m -> m
01:32:02 <siraben> So why is it a Monoid?
01:32:09 <siraben> Why not String -> String -> String
01:32:28 <boj> > Just 1 <> Just 2 <> Nothing
01:32:31 <lambdabot>  error:
01:32:31 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M816923765786...
01:32:31 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:32:39 <centril> siraben: Consider function composition:  '(>>>) :: (a -> b) -> (b -> c) -> (a -> c)'  and an identity function  'id :: a -> a'.  Function composition respects associativity and left/right identity.   A monad is a type constructor 'M :: Type -> Type'  for which you have  'pure :: a -> M a'  and '(>=>) :: (a -> M b) -> (b -> M c) -> (a -> M c)'.   A monad also respects associativity and left/right identity
01:32:55 <centril> (>=>)  is called "kleisli-composition"
01:33:44 <kuribas> siraben: because String is a monoid under concatenation.  (it is a list actually).
01:34:16 <siraben> Does Programming in Haskell teach category theory as well?
01:34:33 <kuribas> siraben: not really
01:34:38 <siraben> Haskell from First Principles claims to do so, making those concepts easier
01:34:59 <centril> siraben: (++, "", String)
01:35:13 <centril> kuribas: I beg to differ personally :)
01:35:18 <kuribas> siraben: the type signature you gave is the more specific, less generic version.
01:35:31 <centril> Haskell seems to me a gateway drug into category theory, which is great
01:36:08 <centril> siraben: You will be joking about 'coconut's in no time ;)
01:36:12 <kuribas> :t (<>) :: String -> String -> String -- siraben this works as well
01:36:13 <lambdabot> String -> String -> String
01:36:15 <siraben> When it comes to category theory, Wikipedia is not of much use, it seems
01:36:44 <centril> siraben: It explains category theory from the perspective of mathematicians, not programmers
01:37:04 <centril> If you are a programmer odds are you'll have a hard time learning from it
01:37:07 <kuribas> siraben: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
01:37:31 <siraben> And when you learn category theory, in what other ways does it benefit you?
01:37:38 <siraben> e.g. how do you view things differently through category theory?
01:38:03 <centril> siraben: good programming is about composition and how to do it well; category theory is the study of composition
01:38:14 <kuribas> siraben: it makes you see how things fit together, which is rather cool
01:38:57 <centril> For example, taking monads, and reversing the arrows (the dual) gives you another interesting structure known as 'comonad'
01:39:41 <centril> ("arrow" can be thought of as functions)
01:40:06 <siraben> It amazes me how deep computer science be at times, makes me wonder if it's invented or discovered.
01:40:53 <centril> siraben: Wadler would says it is discovered,  https://www.youtube.com/watch?v=aeRVdYN6fE8
01:41:24 <siraben> I saw his Strange Loop talk: https://www.youtube.com/watch?v=IOiZatlZtGU
01:42:08 <centril> siraben: It makes you ask:  maybe mathematics is a branch of computer science ;)
01:43:22 <siraben> At 31:04 he says that if we sent a program in lambda calculus we might be able to talk to aliens
01:44:11 <siraben> But then, there are so many equivalent models of computation, they could be using Brainfuck as their model of computation
01:45:07 <siraben> Anyway, offtopic.
01:46:06 <centril> siraben: my bet is on lambda calculus with de-bruijn indices or SKI
01:47:04 <siraben> http://worrydream.com/AlligatorEggs/ is a good primer to lambda calculus for children
01:47:32 <siraben> Someone should make one for category theory
01:50:54 <jesyspa> siraben: In programming, it's often useful to abstract away: instead of working with specific types, work with types that satisfy certain conditions, for example.  As your abstractions grow, you start wanting to abstract not just types, but type constructors.  It turns out that category theory has a lot to say about those.
01:53:15 <siraben> Is there a recommended free Haskell implementation?
01:53:20 <siraben> Ideally GPL
01:53:31 <kuribas> siraben: I like how abstractions in haskell flow from the structure of things, rather than being imposed by the language creator or developer.
01:53:39 <dysfun> ghc is free, but it's not gpl
01:53:52 <dysfun> it's the one that's actually seeing all the research though
01:53:57 <kuribas> siraben: for example existential types, they were added because of their logic counterpart, but turn out to be very useful.
01:54:02 <Axman6> There is very little GPL code in the Haskell ecosystem, most of it is BSD or MIT licensed
01:54:13 <siraben> kuribas: jesyspa: In a way, it's similar to macros in Lisp, you abstract higher and higher
01:54:17 <centril> dysfun: so I think "free" was intentional here; as in not FOSS but free
01:54:31 <dysfun> centril: well they're all free in that case?
01:54:38 <aarvar> most of them are
01:54:41 <siraben> Axman6: How come?
01:54:50 <kuribas> siraben: yes, except that it's easier to prove type safety and soundness
01:54:56 <centril> dysfun: there's a difference between free software and open source :)
01:55:07 <dysfun> well they're all both, so far as i'm aware
01:55:15 <Axman6> because the community generally doesn't like the viral effects the GPL forces on users
01:55:27 <kuribas> siraben: and if you need that power, you can always use TH.
01:55:43 <centril> dysfun: no, GPL is a free software license, BSD is not
01:56:05 <dysfun> centril: gonna have to disagree with that. BSD is a free software license, it's just not a strong copyleft
01:56:18 <aarvar> define free
01:56:19 <Axman6> indeed
01:56:28 <Axman6> the absence of restriction
01:56:43 <Axman6> which clearly does not include the GPL ;)
01:57:05 <siraben> Well, the GPL has its own definition of freedom.
01:57:10 <centril> Axman6: "free == the absence of restriction" is a very political statement
01:57:14 <siraben> It's a difficult issue.
01:57:38 <dysfun> well i can't see GHC getting made proprietary any time soon
01:58:00 <Athas> The FSF says that the BSD license is free, and if anyone has any authority on the term, they are probably the ones.
01:58:02 <Axman6> despite being primarily developed at Microsoft Research
01:58:19 <siraben> Are you talking about the FreeBSD license?
01:58:39 <dysfun> the entire family of BSD licenses is free
01:58:48 <Athas> While there is little GPL code in the Haskell ecosystem, there is also essentially no proprietary code.
01:58:48 <Axman6> the BSdD 3-clause license is generally what is meant by "the BSD license"
01:59:05 <Axman6> Athas: that's not true
01:59:57 <Athas> Axman6: depends on how you define "the Haskell ecosystem", maybe.  I know people have closed Haskell code bases, but they are not part of "the ecosystem" in my mind.
02:00:03 <siraben> Hah there's https://wiki.haskell.org/Haskell_Lisp
02:00:19 <siraben> Lisp in Haskell, Haskell in Lisp, Haskell with Lisp syntax
02:00:29 <centril> I would personally use GPL2+ for larger projects, but maybe ASL2.0 + MIT for smaller libraries
02:00:37 <Axman6> Athas: my initial thought is Facebook's spam filtering system, which is (likely) a very large codebase which is not open
02:00:40 <Athas> I use the ISC license because the text is shorter.
02:00:44 <Athas> Axman6: it's not part of the ecosystem.
02:00:58 <Axman6> Facebook contribute to the ecosystem
02:00:59 <Athas> Nobody can even use it except Facebook, so the license does not matter.
02:01:19 <centril> Athas: you could use parts...
02:01:26 <Axman6> well, by that reasoning there can be no proprietary code in the ecosystem :)
02:01:30 <Athas> I am pretty sure there are no proprietary Haskell libraries.
02:01:43 <Athas> Axman6: how so?  There are plenty of proprietary Java and C++ libraries which form part of their ecosystem.
02:01:49 <dysfun> in perl we had "the cpan" (hackage) and "the darkpan" (all the code you can't see that isn't open source)
02:02:14 <dysfun> obviously there is a haskell darkpan, but that isn't something any of us see, so it may as well not exist in "the ecosystem"
02:02:14 <centril> Axman6: no proprietary code is a worthwhile goal :)
02:02:16 <Athas> I don't think the Haskell tooling (Cabal) can handle proprietary libraries.
02:02:17 <siraben> The issue is proprietary binaries is that you blindly trust it.
02:02:41 <siraben> Having strong copyleft seems like the best way to combat against it.
02:02:51 <dysfun> it depends
02:02:57 <Axman6> centril: I'm ok with that too. I brain nearly broke when I came across a proprietary JS library for making charts (highcharts I think)
02:02:59 <dysfun> strong copyleft on libraries in particular
02:03:14 <cocreature> what is the Setup.hs version of cabal’s cc-options field?
02:03:16 <dysfun> i've started using the MPL for libraries as a balance
02:03:18 <siraben> JavaScript is still suffering from non-free code
02:03:19 <centril> dysfun: what is weak copy left? MPL?
02:03:21 <Athas> siraben: yes, copyleft is a weapon you use to fight (real and important) problems.  But in the Haskell community, that problem has not cropped up.
02:03:25 <centril> MPL seems like a useless license
02:03:35 <centril> with no actual guarantees
02:03:39 <siraben> centril: X11 (or MIT) license is permissive
02:03:53 <dysfun> centril: no, weak copyleft is BSD etc. MPL is actually a strong copyleft that has fewer integration issues with both gpl and proprietary software
02:04:04 <dysfun> MPL is actually quite a pragmatic license, i didn't realise until recently
02:04:19 <siraben> Maybe it's the background of the languages and their communities that make certain license practices proliferate
02:04:26 <dysfun> it's more copyleft than apache
02:04:33 <siraben> e.g. Emacs Lisp code that I've seen is almost always free under GPL
02:04:42 <centril> dysfun: how is BSD copyleft? it has no requirements about derivative code having to have the same freedoms as the original source...
02:04:47 <dysfun> (in that the source itself *is* strong copyleft)
02:05:14 <dysfun> centril: that is why we say it's not a *strong* copyleft
02:05:45 <Athas> siraben: yes, definitely.  And it's very easy to build tooling that depends on source code being available, which makes supporting proprietary code awkward.
02:05:46 <dysfun> but you're still making it available for people to use, what's not copyleft about that
02:05:53 <centril> dysfun: it's not copyleft at all; such requirements about derivative code are the essence of copyleft... MPL is weak copyleft.
02:06:15 <Athas> GHC is totally unsuited for binary-only libraries, although it does of course support proprietary software delivered in source form.
02:06:20 <dysfun> we're wandering into opinion territory here
02:06:26 <siraben> That brings to mind, decompilers in Haskell?
02:06:29 <centril> dysfun: "Copyleft (a play on the word copyright) is the practice of offering people the right to freely distribute copies and modified versions of a work with the stipulation that the same rights be preserved in derivative works down the line."
02:06:32 <Athas> siraben: does not exist.
02:06:59 <siraben> Athas: There are no decompilers written in Haskell?
02:06:59 <aarvar> dysfun: more like "I'm going to redefine all the terms" territory
02:07:05 <centril> aarvar++
02:07:14 <Athas> siraben: oh, maybe.  I thought you meant decompilers that targeted Haskell.
02:07:21 <dysfun> oh, you don't like the FSF's definition of "free software" either?
02:07:28 <aarvar> but programmers are good at that :)
02:07:36 <siraben> I support the definition of free software by the FSF
02:07:55 <siraben> but "free" has been used poorly in the English language
02:08:13 <siraben> Spanish has "libre" which makes it much more distinct than "gratis"
02:08:20 <aarvar> dysfun: who, me?
02:08:29 <dysfun> aarvar: yes, you
02:08:36 <aarvar> I didnt say that
02:08:46 <aarvar> copyleft usually only refers to liscenses like the GPL
02:08:50 <Athas> You can always disambiguate by saying Free Software (capitalised) for the specific term defined by the FSF.
02:08:51 <dysfun> then at most i could be redefining *one* term
02:08:52 <kuribas> Athas: static binding libraries?
02:08:58 <aarvar> while BSD is "permissive"
02:09:03 <Athas> kuribas: ?
02:09:08 <centril> dysfun: the MPL license seems to me a toothless license which only stipulates that derivative **files** have the same rights preserved; but you can easily put all the interesting improvements in a different file... I would not recommend it to anyone.
02:09:09 <siraben> Athas: That's one way to do it.  It's harder in spoken.
02:09:20 <Athas> siraben: you just yell instead.
02:09:29 <kuribas> <Athas> GHC is totally unsuited for binary-only libraries, (..)
02:10:02 <Athas> kuribas: but the ABI is so fragile.  Maybe it would work for locked-down snapshots a la Stackage...
02:10:03 <dysfun> centril: the problem is that for libraries, making them a strong copyleft means people just won't use them. MPL is a compromise position, granted
02:10:04 <siraben> And the whole argument over Open Source != Freedom is headache inducing, so it MIT vs. GPL etc.
02:10:11 <siraben> s/it/is
02:10:13 <centril> siraben: the notion of "libre" is in itself highly contested; there are "negative" and "positive" freedoms, etc.
02:10:38 <centril> dysfun: then I just use MIT/ASL2.0 -- MPL seems like a false promise wrt. copyleft
02:10:40 <siraben> So, no Free implementations of Haskell?
02:10:51 <Athas> siraben: GHC is Free, but not Copyleft.
02:10:59 <siraben> That's fine enough for me.
02:11:02 <dysfun> centril: indeed, i have traditionally used MIT and recently ASL2, but i'm switching some stuff to MPL
02:11:21 <Athas> In fact, all publicly available Haskell implementations are Free to my knowledge.
02:11:32 <centril> dysfun: I tend to dual-license under ASL + MIT
02:11:45 <dysfun> centril: the per-file boundary is actually more genius than it seems, because under most library designs, it's pretty hard to do what you describe
02:12:10 <dysfun> i'm actually against MIT licensing these days in principle. The apache2 is a better license given that america still won't shut up about software patents
02:12:15 <centril> dysfun: what if you just move out all the functions but one from the file...?
02:12:17 <dysfun> that said, i'm in europe
02:12:48 <centril> dysfun: ah yes; I think all software licenses should have an anti-software-patents clause in them
02:13:05 <dysfun> centril: if you're stealing a single function i honestly don't care. i do care if you copy loads of my code and then improve it and don't give me the improvements
02:13:44 <dysfun> in clojure we have a slightly more challenging situation in that clojure is EPL licensed which precludes GPL software
02:13:48 <centril> dysfun: I meant the reverse... you take out all but one function from the file, put them somewhere else and them make improvements to those but don't share them back.
02:14:02 <centril> dysfun: european public license?
02:14:05 <dysfun> not that github isn't full of GPL clojure software anyway, but i wouldn't like to discuss such things with a lawyer
02:14:08 <dysfun> centril: eclipse
02:14:12 <centril> dysfun: oh; eff that
02:14:33 * hackage hw-prim 0.6.2.0 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.0 (haskellworks)
02:16:05 <centril> so... no one had any input on my semi-proposal:   foo :: (x :: Ty) -> (y :: Ty) -> Ty = x + y      as a shorthand syntax
02:16:12 <centril> bad idea?
02:16:13 <dysfun> centril: yes, but... the community has used epl for lots of libs too :/
02:17:10 <siraben> Any ambiguous Haskell syntax I should be aware of?
02:17:18 <siraben> I was already confused by f x
02:17:26 <centril> siraben: that's a very broad question...
02:17:53 <siraben> Err, ok. Nevermind.
02:18:15 <centril> siraben: 'f x' as in function application or definition?
02:18:25 <siraben> Application
02:18:38 <siraben> But it's minor
02:18:41 <centril> siraben: It's a lovely syntax; really, Haskell got it right!
02:19:01 <siraben> Maybe I've been in parenthesis land too long
02:19:08 <centril> siraben: clearly, yes :)
02:19:09 <siraben> Code without parens feels so... naked?
02:19:22 <centril> siraben: noise-free :)
02:19:26 <dysfun> yo dawg, i hear you like lisp
02:19:51 * centril has an irrationally bad reaction to lisp.
02:19:53 <siraben> Giving up homoiconicity is a little hard
02:20:04 <jesyspa> free == left adjoint to forgetful, no need to get into politics. :)
02:20:17 <Axman6> jesyspa++
02:20:20 <siraben> But at least I'll learn how to actually parse a programming language
02:20:23 <centril> jesyspa: heh :P
02:20:45 <dysfun> siraben: it's annoying at first, but haskell is sufficiently flexible we don't often need macros
02:21:42 <dysfun> that said, every time i have to write template haskell, i consider becoming a rutabaga farmer
02:21:48 <siraben> I already started rewriting some of my Project Euler solutions into one liners in Haskell
02:21:51 <centril> dysfun: elaborator reflection seems nice tho
02:21:59 <centril> (Idris)
02:22:25 <dysfun> centril: i haven't gotten that far with idris i'm afraid, too busy with real world stuff :/
02:23:30 * dysfun is actually writing golang today and it's just awful
02:23:40 <Axman6> :(
02:23:47 <siraben> Games in Haskell?
02:24:08 <siraben> That would be amazing, because Haskell is pure and just imagine all that mutation going on in a game
02:24:09 <centril> dysfun: my sympathies; no one should be forced to write golang. that's just inhumane :/
02:24:23 <dysfun> yes, it's pretty awful
02:24:32 <dysfun> but fortunately it's nearly done
02:24:40 <dysfun> and then i hope to not write any more ever again
02:25:07 <centril> :t sum
02:25:08 <lambdabot> (Num a, Foldable t) => t a -> a
02:25:18 <siraben> :t :t
02:25:19 <lambdabot> error: parse error on input ‘:’
02:25:29 <centril> > sum([1, 2, 3, 4])  -- siraben you can write like this
02:25:31 <lambdabot>  10
02:26:33 <kuribas> siraben: there's frp to manage all that mutation
02:26:52 <jesyspa> siraben: IMHO, abstractions over type constructors give a different "kind" (no pun intended) of abstraction than macros.  I can't quite formulate it, though.
02:27:14 * centril thinks we should deprecate the word 'kind'
02:27:52 <centril> it's really just a synonym of 'type'...
02:30:15 <siraben> kuribas: frp?
02:30:31 <kuribas> siraben: functional reactive programming
02:31:03 <siraben> How would one do memoization in Haskell?
02:31:33 <jesyspa> centril: Nonono.  When you talk of models of type theory, kinds absolutely play a key role.
02:31:34 <siraben> Especially for streams
02:31:52 <centril> jesyspa: "kind" is just "type of type"
02:32:00 <kuribas> siraben: lazy lists usually
02:32:12 <kuribas> siraben: it depends on the application or algorithm
02:32:52 <jesyspa> centril: Yes, but that's an important distinction.
02:33:01 <siraben> Symbolic manipulation seems much harder in Haskell
02:33:08 <siraben> For instance I want to write a symbolic differentiator
02:33:10 <centril> jesyspa: I'm saying we should say "type type" or "type of type"
02:33:20 <siraben> The pattern matcher helps a lot but parsing is weird
02:33:53 <Axman6> > deriv $ \x -> x^2 + x^3 + y
02:33:55 <lambdabot>  error:
02:33:55 <lambdabot>      Variable not in scope: deriv :: (Expr -> Expr) -> t
02:34:11 <siraben> e.g. (deriv '(* x 2) 'x) => x (deriv '(^ x 5) 'x) => (* 5 (^ x 4))
02:34:17 <siraben> Maybe I should stop using s expressions
02:34:32 <jesyspa> centril: That really doesn't sound so clear.  I agree it depends on context (I'm fine with it in Agda), but you need to realise there's contexts where making that distinction is useful, and where types and kinds are very different beasts.
02:34:50 <siraben> oops (deriv '(* x 2) 'x) should be 2
02:35:06 <centril> jesyspa: right; from an Agda / Idris perspective :)
02:35:12 <kuribas> siraben: you'd create a expression ADT
02:35:15 <Axman6> > diff (\x -> x^2 + x^3 + y) x
02:35:17 <lambdabot>  error:
02:35:17 <lambdabot>      • Variable not in scope: diff :: (Expr -> Expr) -> Expr -> t
02:35:18 <lambdabot>      • Perhaps you meant ‘dff’ (imported from Data.Graph)
02:35:38 <centril> :t (^)
02:35:39 <lambdabot> (Num a, Integral b) => a -> b -> a
02:35:40 <Axman6> hmm, I thought ad was imported into lambdabot
02:35:45 <kuribas> siraben: it should be easier to get right
02:36:08 <centril> the lambda bot type error is making no sense... why is 'Expr' mentioned?
02:36:17 <Axman6> because of y
02:36:22 <Axman6> :t y
02:36:23 <lambdabot> Expr
02:36:26 <centril> oh god...
02:36:29 <centril> why
02:36:29 <Axman6> > iterate f y
02:36:31 <lambdabot>  [y,f y,f (f y),f (f (f y)),f (f (f (f y))),f (f (f (f (f y)))),f (f (f (f (f...
02:36:45 <centril> :i Expr
02:36:56 <centril> :(
02:37:20 <centril> lambdabot: I am disappointed in you.
02:37:35 <Axman6> @import Numeric.AD
02:37:35 <lambdabot> Unknown command, try @list
02:37:44 <Axman6> > import Numeric.AD
02:37:47 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
02:37:56 <Axman6> @let import Numeric.AD
02:37:57 <lambdabot>  .L.hs:136:1: error:
02:37:57 <lambdabot>      Could not find module ‘Numeric.AD’
02:37:57 <lambdabot>      Perhaps you meant
02:38:03 <Axman6> :(
02:38:10 <centril> is there a manual somewhere?
02:41:04 <mniip> > Data.Data.toConstr x
02:41:06 <lambdabot>  error:
02:41:06 <lambdabot>      • No instance for (Data Expr) arising from a use of ‘toConstr’
02:41:06 <lambdabot>      • In the expression: toConstr x
02:42:24 <mniip> :t GHC.Generic.from x
02:42:25 <lambdabot> error:
02:42:25 <lambdabot>     Not in scope: ‘GHC.Generic.from’
02:42:25 <lambdabot>     No module named ‘GHC.Generic’ is imported.
02:42:30 <mniip> :t GHC.Generics.from x
02:42:32 <lambdabot> error:
02:42:32 <lambdabot>     • No instance for (GHC.Generics.Generic Expr)
02:42:32 <lambdabot>         arising from a use of ‘GHC.Generics.from’
02:42:37 <mniip> aw
02:42:44 <mniip> then we might never know!
02:43:09 <mniip> :t typeOf x
02:43:11 <lambdabot> TypeRep
02:43:13 <mniip> > typeOf x
02:43:15 <lambdabot>  Expr
02:43:15 <siraben> [1..]
02:43:19 <mniip> aha
02:45:30 <siraben> lambdabot: 1 + 2
02:45:32 <mniip> > tyConModule $ typeRepTyCon $ typeOf x
02:45:35 <lambdabot>  "Debug.SimpleReflect.Expr"
03:01:07 <reactormonk> I wanna add a type alias constraint which contains a type family - which makes the compiler tell me I need UndecidableSuperclasses. Good / bad idea? Constraint: https://hackage.haskell.org/package/data-diverse-3.1.0.0/docs/Data-Diverse-TypeLevel.html#t:UniqueMember
03:03:31 <Gurkenglas> Can I generate a coverage report for a single .hs stack script?
03:04:01 <Gurkenglas> What is the simplest way to convert a .hs stack script into a stack project?
03:39:28 <michalrus> Can I prevent this from compiling? `testCase "-fwarn-incomplete-uni-patterns" $ do { Just a <- pure (Nothing :: Maybe Int) ; print a }`
03:39:39 <cocreature> Gurkenglas: write a cabal file and then run "stack init"
03:39:52 <michalrus> And resulting in `Exception: user error (Pattern match failure in do expression at …`?
03:40:17 <michalrus> On the other hand:
03:40:19 <michalrus> > do { Just a <- [Nothing, Nothing, Just 5] ; return a }
03:40:21 <lambdabot>  [5]
03:40:26 <michalrus> So ummm.
03:43:00 <cocreature> michalrus: hm, I suppose you could enable MonadFailDesugaring and make a newtype for IO that doesn’t have a MonadFail instance but that’s obviously rather annoying
03:43:38 <michalrus> Mhm. :’
03:47:00 <Gurkenglas> so mkdir foo, mv bar.hs foo/bar.hs, cd foo, stack exec cabal init, stack init?
03:47:48 <cocreature> Gurkenglas: I would probably just hand-write the cabal file rather than use "cabal init" but both should work
03:48:26 <cocreature> you could also create a new project using "stack new" and copy your source files in there
03:53:17 <Gurkenglas> The "cabal.EXE: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible" error means my "stack exec cabal init" is using a very old cabal, right? How do I update that one?
03:54:14 <Gurkenglas> Should there be a command for converting a script into a project? Should I post a stack github issue?
03:55:03 <cocreature> afaik that issue exists regardless of which version of cabal you are using. you need to invoke cabal directly rather than via "stack exec"
03:59:00 <Gurkenglas> cocreature, do I need to make sure the cabal version that uses is the same as the one stack uses?
03:59:30 <cocreature> no
04:04:20 <Gurkenglas> "cabal: The program 'ghc' version >=6.4 is required but it could not be found." x.x
04:04:36 <cocreature> just hand-write the file and save yourself the trouble :)
04:05:46 <Gurkenglas> Okay I'll try to read how to write those ;_;
04:06:15 <cocreature> there are a few examples here https://cabal.readthedocs.io/en/latest/developing-packages.html#creating-a-package
04:06:24 <cocreature> or just look at a cabal file in another project
04:06:41 <dminuoso> @tell ddellacosta If you look at (($ b) . ($ c) . V3) <$> (f a), then there's a way to rewrite (($ b) . ($ c) . V3). Read it like this: "b applied to" after "c applied to" after "V3 applied to something" - if you rewrite with a lambda it will look nicer.
04:06:41 <lambdabot> Consider it noted.
04:07:48 <Gurkenglas> Thanks, didn't find that page on that domain
04:12:28 <mupf> EvanR: About yesterday; I just discovered "Learn you a Haskell for Great Good" and it seems to be the right book for me. It really helped "getting the gist".
04:20:13 <Gurkenglas> https://lpaste.net/5393146513251631104 hm?
04:21:19 <cocreature> Gurkenglas: have you tried using lowercase for the field name?
04:21:52 <cocreature> afaik Cabal supports both but I think stack might use its own parser?
04:24:15 <cocreature> Gurkenglas: hm I just tried running "stack init" with that cabal file and it works just fine. are you using an old version of stack?
04:25:47 <Gurkenglas> cocreature, no. Lowercasing it worked. Should the cabal docs that provide this example be tweaked?
04:26:43 <cocreature> I don’t think so for me the uppercase variant works just fine so I suspect that something else is going on here
04:28:20 <cocreature> Gurkenglas: ah which version of ghc are you using?
04:32:30 <Gurkenglas> stack exec ghc -- --version thinks for a few seconds and then says The Glorious Glasgow Haskell Compilation System, version 8.2.2
04:32:42 <cocreature> and stack --version shows 1.7.1?
04:33:46 <cocreature> Cabal recently changed to a new parser so I wonder if stack somehow ends up using an older version for you that doesn’t handle this properly
04:35:47 <Gurkenglas> cocreature, Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2
04:35:57 <Gurkenglas> be back in a few hours
04:42:42 <sphinxo> is it possible to do something like http://okmij.org/ftp/ML/first-class-modules/open_gadts.ml with backpack?
04:45:18 <cocreature> sphinxo: I’ve only skimmed it briefly and it isn’t entirely clear to me which part you are referring to but http://qfpl.io/posts/backpack-for-initial-and-final-encodings/ is probably worth a look
04:48:40 <sphinxo> cocreature: thanks! that looks helpful. The part i'm interested in is defining constructs of a language separately. ( modular compilers? )
04:55:30 <anohigisavay> hi. how could i add input data files for tests?
04:56:36 <anohigisavay> for example my test depends on piping a source file into conduit
04:57:27 <cocreature> anohigisavay: add them to extra-source-files
04:58:21 <anohigisavay> cocreature, thank you
05:05:29 <dexterlb> hello.. I want to make a custom parametric type an instance of a class only if the parameter satisfies another class. For example, to make a "passthrough" functor instance which calls fmap on the underlying type, I want something like this: https://lpaste.net/8671153308330622976
05:05:39 <dexterlb> what is the correct syntax to do this?
05:08:32 <cocreature> dexterlb: the syntax is not the problem. the problem is that "a" has the wrong kind
05:08:52 <cocreature> dexterlb: an instance of Functor has to be of kind * -> *, "a" here is of kind *
05:47:56 <asheshambasta> anyone familiar with anything in emacs that can let me see all functions in a given haskell file/module??
05:56:10 <mapael> what is the difference between && and and
05:57:14 <epta> :t and
05:57:16 <lambdabot> Foldable t => t Bool -> Bool
05:57:19 <epta> :t (&&)
05:57:21 <lambdabot> Bool -> Bool -> Bool
05:58:38 <mapael> so my understanding is that these are Bools that are foldable
05:58:43 <mapael> but then that contradicts itself
05:58:58 <mapael> as then you would have a bool that meets the typeclass criteria and one that doesn't
05:59:22 <bjs> mapael: the bools aren't foldable, t is
05:59:42 <cocreature> mapael: and works for things like lists of Bool whereas (&&) is a binary operator
06:00:15 <rotcev> > and [True, True]
06:00:17 <lambdabot>  True
06:00:21 <rotcev> > and [True, False]
06:00:22 <bjs> mapael: `and = foldr (&&) True`
06:00:23 <lambdabot>  False
06:00:58 <hc>  > and [ ]
06:01:07 <hc> > and [ ]
06:01:09 <lambdabot>  True
06:01:14 <mapael> ahh so it is like the equivalent of and xs = foldl True xs ?
06:01:21 <mapael> sorry i mean
06:01:33 <mapael> and xs = foldl && True xs
06:02:29 <bjs> mapael: well it's like the foldr I gave above
06:02:33 <Axman6> roughlthough it would more likely be foldr (&&) True as (&&) is lazy in its second argument, so we can use foldr on infinite lists of Bools
06:02:58 <c_wraith> maerwald: syntactic note - you need the operator to be in parens to make it a function that can be passed as an argument to something else
06:03:07 <bjs> > and (False : repeat True)
06:03:09 <lambdabot>  False
06:03:10 <c_wraith> err.  mapael
06:03:15 <bjs> which wouldn't terminate with your foldl variant
06:05:36 <mapael> oh my bad i'm pretty new to this sorry i suppose && is infix anyway
06:06:03 <c_wraith> mapael: you are correct.  But it's all good.
06:06:48 <mapael> could you elaborate Axman6 on why a right fold works on infinite list of bools but a left fold doesn't?
06:08:07 <c_wraith> mapael: the simplest explanation is that foldr reduces to a call to f on non-empty input.  foldl reduces to a call to foldl in that case
06:08:33 <c_wraith> > foldl f z [a, b, c] :: Expr
06:08:35 <lambdabot>  f (f (f z a) b) c
06:08:41 <c_wraith> > foldr f z [a, b, c] :: Expr
06:08:43 <lambdabot>  f a (f b (f c z))
06:09:31 <c_wraith> Hmm.  that doesn't really show what I hoped, since it's large-step.
06:09:35 <c_wraith> :t foldr
06:09:36 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:09:43 <c_wraith> @src foldr
06:09:43 <lambdabot> foldr f z []     = z
06:09:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:09:45 <jam_balaya> why does ByteString repeat so many of the prelude's basic functions? for instance, there's BS.map, why not just use fmap and make BS an instance of Functor?
06:09:48 <c_wraith> @src foldl
06:09:48 <lambdabot> foldl f z []     = z
06:09:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:09:59 <c_wraith> there, that shows what I mean
06:10:27 <c_wraith> jam_balaya: it can't be an instance of Functor.  It has the wrong kind.
06:11:20 <jam_balaya> what has the wrong kind?
06:11:33 <c_wraith> jam_balaya: ByteString itself.
06:11:37 <c_wraith> :t fmap
06:11:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:12:05 <Axman6> jam_balaya: what is the a in that type?
06:12:28 <c_wraith> jam_balaya: if ByteString was an instance of Functor, fmap would have the type (a -> b) -> ByteString a -> ByteString b
06:12:46 <c_wraith> jam_balaya: but ByteString doesn't have a type argument
06:14:39 <c_wraith> mapael: do you see what I was getting at, in the difference between foldr and foldl? In the recursive cases of each, the top-level function is different.  In foldr, it's a call to f.  In foldl, it's a call to foldl.
06:15:08 <mapael> c_wraith im still in the process of trying to understand it on paper but from my paper right now foldr seems to work; i'm just about to check foldl
06:15:33 <c_wraith> mapael: in the case of foldr, it means that whether or not the rest of the list gets looked at depends on f.  In the case of foldl, it always looks at the rest of the list.
06:15:47 <jam_balaya> hm i think i get it. isn't it odd that so many types have to define their own map function?
06:15:48 <c_wraith> mapael: ah, nice.  Working through it on paper is a great way to look at it.
06:15:49 <mapael> c_wraith it seems that foldr (&&) True [infinite false list] = True && False && .. so then i tcan terminate
06:16:30 <jam_balaya> i thought Functor was supposed to abstract away stuff that's mappeable so that fmap can be reused
06:16:53 <cocreature> jam_balaya: it’s supposed to abstract over things where you can change the type during mapping
06:16:59 <cocreature> that’s not the case for ByteString
06:17:08 <c_wraith> jam_balaya: Functor has plenty of limits, given the nature of the haskell type system.
06:17:21 <cocreature> jam_balaya: for non-type changing maps there are things like MonoFunctor but they’re not used a whole lot
06:17:21 <c_wraith> jam_balaya: it's still better than not having it. :)
06:18:16 <Axman6> ByteStrings simply are not functors
06:18:18 <jam_balaya> hm is there an analogue of the Iterator interface from OOP design?
06:18:33 <Axman6> there are many
06:18:36 <c_wraith> jam_balaya: traditionally, the Traversable class covers that.
06:18:54 <c_wraith> jam_balaya: though it's not an immediately obvious correspondence
06:19:34 <mapael> c_wraith I see what you mean now, it looks like on paper that foldl with an infinite lists of falses and the (&&) function starting with a True value will call itself forever
06:19:52 <jam_balaya> im seeing for instance that Data.Text also has its own map
06:19:57 <c_wraith> mapael: that's exactly what it will do
06:20:51 <Axman6> there are things like MonoTraversable which give an interface which allow mapping of types such as Text and ByteString
06:20:54 <mapael> c_wraith i use paper more than my computer for program design because i'm learning haskell right now. It has the hidden bonus of i can draw my trees as function inputs which is really nice
06:21:03 * hackage hid-examples 0.1.0.0 - Examples to accompany the book "Haskell in Depth"  http://hackage.haskell.org/package/hid-examples-0.1.0.0 (bravit)
06:21:22 <c_wraith> Funny thing about reading the "The Essence of the Iterator Pattern" paper.  It feels like it's the very first version of the lens library, but no one realized it yet.
06:21:26 <mapael> well not that you can't do trees with other languages just new to programming beyond scripting for calculations
06:22:29 <jam_balaya> alright then, so there's an interface but it's not standardized or not used for some reason. so for instance there's a bunch of map/words/lines/etc functions that are all supposed to do the same by convention basically?
06:22:31 <c_wraith> mapael: it's a fantastic habit.  It teaches you a lot that's harder to pick up without it.
06:24:54 <c_wraith> jam_balaya: note that there are some significantly more advanced patterns that unify various traversal patterns into the same shape in the lens library. It's unclear to me if I should really recommend you look into it, though, as it has a *lot* of conceptual overhead. It's cool, but it's also full of "what the hell is going on here?"
06:25:20 <jam_balaya> i'm planning on looking at lenses either way, thanks
06:26:45 <mapael> thanks c_wraith i'll keep it up
06:27:47 <jam_balaya> im just a bit surprised that there's all these base classes like Eq, Ord, Show but then the ones relating to containers seem to be so odd
06:28:18 <jam_balaya> weird names both the classes and the methods/operators, weird hierarchy
06:28:48 <c_wraith> jam_balaya: to some extent, that really is an artifact of choices made early on in the design of Haskell's type system.  Type constructors are curried, type constructors are generative, and things like that.
06:31:03 <c_wraith> jam_balaya: In fact, if you look at the history of Haskell, those choices were made before type classes were even added.  The interaction wasn't considered in nearly the same depth as some other facets of the language.  It's sort of a coincidence that they worked out even as well as they have.
06:31:46 <jam_balaya> I find it a bit strange that functional programming is supposed to be about function composability and reuse (via classes) and then you end up with something very OOPish like every type having its own "methods" and implementing only a few of the most basic classes
06:31:59 <jam_balaya> It's really off putting.. conceptually, at least
06:32:55 <c_wraith> the fact is, there are very few classes that actually are used heavily
06:33:30 <c_wraith> Because it's not OOP, and classes are usually the wrong way to solve a problem. :)
06:33:41 <c_wraith> also, they're totally unrelated to OOP classes.
06:33:57 <orion> c_wraith: Why is it wrong?
06:34:09 <jam_balaya> when i said classes, i meant haskell classes
06:34:29 <c_wraith> orion: most of the time, you want to be using higher-order functions
06:34:30 <jam_balaya> which is pretty much the same as interfaces+generics in OOP
06:34:37 <orion> c_wraith: Why?
06:35:43 <cocreature> orion: because very often there is more than one useful behavior for a specific types and just passing the appropriate one is more convenient than having to mess with newtypes
06:35:53 <c_wraith> orion: they're a lot less limited.  classes are essentially functions from type to value.
06:36:14 <kuribas> jam_balaya: you can also pass dictionaries explicitly, but classes are more convenient.
06:36:57 <c_wraith> orion: and further, it really helps if you limit the instances of the class such that you can write code that's generic over all instances.  That is, they're not just for name overloading.
06:37:08 <c_wraith> orion: but that limits their applicability even further.
06:42:19 <orion> cocreature: When there is more than one useful behavior for a specific type, wouldn't that indicate the use of multiple type classes being instantiated by the type?
06:42:47 <orion> One instantiation for each useful behavior.
06:43:20 <epta> is there any good examples of three-layer-cake architecture?
06:43:44 <epta> like as is this blogpost http://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
06:43:52 <cocreature> orion: that assumes that there is a fixed number of behaviors for all types and that you can find a useful categorization to decide which typeclass something belongs to
06:44:27 <c_wraith> orion: it was more about something like Monoid and Int.  There are many different ways Int can be a Monoid.
06:44:39 <cocreature> orion: e.g. let’s say you want to eliminate the function parameter from "map" and replace it with a typeclass. there are tons of useful functions that you can map over so by tying that to the type you limit yourself severly
06:46:31 <orion> I see.
06:47:18 <c_wraith> > 2 `mappend` 3
06:47:20 <lambdabot>  error:
06:47:20 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M288079160538...
06:47:20 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:47:33 <c_wraith> > 2 `mappend` 3 :: Int
06:47:35 <lambdabot>  error:
06:47:35 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘mappend’
06:47:35 <lambdabot>      • In the expression: 2 `mappend` 3 :: Int
06:47:45 <c_wraith> > getSum $ 2 `mappend` 3 :: Int
06:47:47 <lambdabot>  5
06:47:52 <c_wraith> > getProduct $ 2 `mappend` 3 :: Int
06:47:54 <lambdabot>  6
06:48:11 <rotaerk> epta, I don't think I see much general usefulness in that design pattern
06:51:44 <rotaerk> it also just doesn't make sense in places
06:52:00 <rotaerk> such as the "realization" at the bottom of what the names of the layers are
07:06:03 * hackage derive-storable 0.1.2.0 - Derive Storable instances with GHC.Generics.  http://hackage.haskell.org/package/derive-storable-0.1.2.0 (mkloczko)
07:13:13 <kuribas> > getSum $ getProduct $ 2 <> 3
07:13:15 <lambdabot>  6
07:15:09 <rotaerk> :t (getSum, getProduct)
07:15:11 <lambdabot> (Sum a1 -> a1, Product a2 -> a2)
07:16:57 <beefjoe> does foo x = 2*x behave the same as foo = \x-> (*) 2 x
07:18:40 <c_wraith> beefjoe: it has the same meaning, though GHC treats them slightly differently while optimizing
07:24:24 <__monty__> I can't seem to figure out the command to use with ghcid so it runs cabal new-repl lib:mylib *and* my test-suite. What documenation should I be looking at?
07:49:46 <beefjoe> Thanks!
07:57:35 <opsman> good morning everyone. I need to turn a list of 400 integers into a 20 x 20 coord grid with a triple --- (0,0,27) for example. I've tried many combinations of zipWith3 , map , and repeat. Along with my own function. I'm close but just cant seem to get the correct coords in the pair of the triple.
08:00:03 * hackage postgresql-simple-migration 0.1.12.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.12.0 (ameingast)
08:00:33 <[exa]> opsman: can you show the example output that you'd like on 2x2 coord grid, say integers [10,11,12,13] ?
08:02:01 <opsman> I looking for a simple list of triples that represent a grid coord and value
08:02:25 <opsman> (0,0,22),(0,1,33)...
08:02:35 <[exa]> so [(0,0,10),(0,1 ...)] oic
08:02:37 <opsman> I have the list of values...400 of them
08:02:47 <[exa]> do you have some code to work with?
08:03:00 <opsman> I need to transform them into a 20 x 20 grid
08:03:38 <[exa]> (or do we start from zero?)
08:04:18 <opsman> I was looking for library function options...I feel confident I could code it with my own functions.
08:06:02 <opsman> Should I just buckle down and do that (code everything) of is there a faster way with library functions...ie zipWith3
08:07:42 <opsman> I'm fairly new to haskell and programming data structures in general.
08:08:07 <[exa]> opsman: so what about first numbering the list of your numbers to [(0,a), (1,b), (2,c), ...]
08:08:21 <[exa]> and then transforming the numbers to coordinates?
08:09:34 <[exa]> (you can transform the "sequence number", say 62, to coordinates in your grid (3,2) using one div and one mod)
08:10:30 <[exa]> the other way -- just generate the list of coordinates first and zip it to your data after that
08:11:44 <opsman> lol...-palm to forehead-thanks I think I'll do that...generate coords and then zip with values...so simple a solution.
08:12:22 <[exa]> if you've got the input in the correct order this is probably the fastest
08:12:58 <[exa]> btw suggest you generate the coords from [0..] and try a concatMap
08:13:25 <opsman> so the coords should be a...that was my next ??
08:14:07 <opsman> haven't used concatMap...I'll look it up in and play with in ghci
08:14:45 <[exa]> the idea is to have a function that gets i and expands it to [(i,0),(i,1),......,(i,19)]
08:14:59 <[exa]> then you get this function and apply it to list of [0..19]
08:15:04 <[exa]> and concat the results
08:15:19 <[exa]> which is what concatMap is exactly good for :]
08:15:59 <opsman> thanks -> exa...I beleive I can work it out from there.
08:25:14 <blasen> does lambdabot eventually have concrete (eK)samples for that abstractions? [:t blah, @src blah, @sample blah? .. or sth in that ways?
08:27:49 <[exa]> opsman: btw post the result after you have it, I guess it can be made a nice oneliner
08:28:59 <Gurkenglas> https://lpaste.net/7971853072567631872 there sure seems to be a main in there
08:30:34 <Gurkenglas> Does someone see a simple way to have a folder that watches https://codereview.stackexchange.com/questions/tagged/haskell and produces a stack project with the given code snippet?
08:31:00 <Gurkenglas> *each time a new "question" is posted
08:31:57 <monochrom> Haha that's extraordinary devotion to stack.
08:32:57 <monochrom> Perhaps start with IRC which is simpler. "watch #haskell and for each lpaste URL produce a stack project"
08:33:44 <Gurkenglas> I put one into a .hs file manually, rewrote some, got an infinite loop, needed to put it in a stack project so I can use --coverage and am currently in the usual process of fighting the interface hydra
08:34:39 <monochrom> Pretty sure plain vanilla GHC has a simpler way to do coverage than scaffolding a full-fledged stack project...
08:35:22 <monochrom> After all, stack --coverage, after much ado, still just calls up GHC for the real work.
08:37:03 <monochrom> I am now convinced that the joke about "the toaster by the software engineer" is an accurate assessment and it is not just talking about people who do OOP.
08:37:33 * hackage simple-effects 0.11.0.1 - A simple effect system that integrates with MTL  http://hackage.haskell.org/package/simple-effects-0.11.0.1 (darwin226)
08:39:42 <[exa]> opsman: btw disregard the concatMap advice, list comprehensions are probably faster for producing the coord list :D
08:40:41 <monochrom> I think after -O both become very similar asm code. It's OK.
08:41:12 <opsman> exa: after building the coords with list comprehension and playing around I think I got it ...
08:41:32 <[exa]> (monochrom: faster for a humant to write :] )
08:41:45 <opsman> [(x,y,z) | x <- [0..19], y <-[0..19], z <- (take (y-x)) a20x20Grid]
08:41:48 <blasen> jslave: var grid=(cols,rows)=>({xy:i=>[i%cols,(i/cols)|0],i:([x,y])=>y*cols+x}); var chess=grid(8,8); [chess.xy(63),chess.i([7,7])] //<opsman>I have the list of values...400 of them. I need to transform them into a 20 x 20 grid. <-- here's a solution that converts [x,y] to index and vice versa for javascript. grid(8,8) will give you 8x8 = 64 fields .. 0 indexed
08:41:48 <jslave> blasen: [ [ 7, 7 ], 63 ]
08:41:56 <monochrom> Yes, that be true.
08:42:06 <blasen> or that:) cool.
08:42:08 <opsman> a20x20Grid is a list of 400 integers..
08:42:53 <opsman> maybe pre-mature...I need to check the resulting list...
08:42:54 <[exa]> opsman: does it work correctly? (I guess it will produce something a bit different than you want it to
08:43:33 <blasen> you basically would just define an accessor (function?), leaving the array as it is.
08:43:34 <[exa]> opsman: anyway, separate the steps-- first produce the coords, then zip the data with them. Also, zipping can't be easily done with list comprehensions (afaik)
08:43:46 <opsman> nope...
08:43:54 <blasen> would be nice to see that in haskell.
08:44:59 <[exa]> blasen: using arithmetic for this is a bit of overkill, isn't it
08:46:40 <monochrom> Try telling that to Gödel when he was proving his incompleteness theorem. :)
08:46:46 <opsman> zip [(x,y) | x <- [0..19], y <-[0..19]] a20x20Grid
08:47:01 <blasen> arithmetic overkill? totally. :v
08:48:15 <blasen> well for a 1e10x1e10 board, if you want to move sth from field to another .. 5xtimes - > no.
08:49:08 <opsman> that produces ((0,0),value),((0,1),value)....
08:49:50 <monochrom> Do you want (0,1,value)?
08:50:53 <[exa]> opsman: almost there, you can try zipWith and a simple lambda that arranges it just nice
08:51:09 <opsman> nomochrom: yes...I'll have to search and perform calcualtions on values in the grid...
08:51:10 <monochrom> Yeah
08:51:46 <monochrom> zipWith (\ (x,y) v ->  ____ ) [(x,y) | x <- [0..19], y <-[0..19]] a20x20Grid
08:52:01 <monochrom> But here is an example of zipWith can do:
08:52:08 <[exa]> also it has a nice pointfree version
08:52:26 <monochrom> > zipWith (\a b -> a-b) [10, 20] [1, 2]
08:52:28 <lambdabot>  error:
08:52:28 <lambdabot>      Ambiguous occurrence ‘zipWith’
08:52:28 <lambdabot>      It could refer to either ‘Data.List.zipWith’,
08:52:41 <monochrom> @undefine
08:52:42 <lambdabot> Undefined.
08:52:43 <monochrom> > zipWith (\a b -> a-b) [10, 20] [1, 2]
08:52:45 <lambdabot>  [9,18]
08:53:18 <blasen> jslave: Object.entries(lib.cartesian([1,2,3],["a","b"]))  // eachL [i, [x,y]]
08:53:19 <jslave> blasen: [ [ '0', [ 1, 'a' ] ], [ '1', [ 1, 'b' ] ], [ '2', [ 2, 'a' ] ], [ '3', [ 2, 'b' ] ], [ '4', [ 3, 'a' ] ], [ '5', [ 3, 'b' ] ] ]
08:53:38 <monochrom> But I don't want to learn javascript.
08:53:57 <[exa]> wtf is a js bot doing in #haskell anyway?
08:54:19 <monochrom> Or rather, is that license for me to bring my COBOL bot into this channel as well?
08:55:01 <[exa]> :]
08:55:40 * [exa] makes a silent wish for exorcism
08:57:29 <[exa]> opsman: anyway, I have to go AFK but just wanted to point you to an interesting thing -- after you get the inner lambda for the zipWith done, try feeding it to lambdabot using @pl to see a pointfree form
08:57:30 <opsman> would not ((0,0),88) not be easier to use in searches given I could use fst or snd with head?
08:57:41 <[exa]> opsman: also. :]
08:57:52 <opsman> thanks for your time exa
08:58:12 <[exa]> ok I guess I can run the spoilers now
08:59:02 <[exa]> > zipWith (uncurry (,,)) [(i,j)|i<-[0..],j<-[0..19]]   ['a'..]
08:59:04 <lambdabot>  [(0,0,'a'),(0,1,'b'),(0,2,'c'),(0,3,'d'),(0,4,'e'),(0,5,'f'),(0,6,'g'),(0,7,...
08:59:34 <[exa]> opsman: np :]
09:00:12 <opsman> what an amazing language. I'm so in over my head
09:01:24 <monochrom> Oh haha uncurry does it.
09:03:14 <noan> :t uncurry
09:03:15 <lambdabot> (a -> b -> c) -> (a, b) -> c
09:03:25 <noan> neat
09:03:58 <SkullScript2> Hello everyone
09:04:03 <noan> SkullScript2, hey
09:04:37 <noan> opsman, haskell is very easy fundamentally. It's just that it's very expressive so others may often write very information-dense things ;)
09:04:52 <noan> it's very information-dense
09:05:50 <blasen> jslave: var grid=(array,cols,rows)=>{ var xy=i=>[i%cols,(i/cols)|0],i=([x,y])=>y*cols+x; return (x,y)=>array[i([x,y])]; }; var users=range(1,400).map(Person.create); var board=grid(users, 20, 20); board(4,5) // it uses higher order function .. u should love it. just pass your array as first argument  grid(yourArray, totalX, totalY)
09:05:51 <jslave> blasen: birthdate, sex, name: 'Andrea'
09:06:03 <SkullScript2> I'm surprised someone already had the name SkullScript
09:06:39 <monochrom> blasen: I think the javascript lessons are better off in #haskell-offtopic
09:07:00 <opsman> zipWith (uncurry (,,)) [(i,j)|i<-[0..],j<-[0..19]]   ['a'..]
09:07:17 <opsman> It took me a few minutes to digest....
09:07:25 <opsman> thats amazing
09:07:39 <opsman> newbie has mindblown
09:07:57 <monochrom> uncurry (,,) is pretty non-obvious. But try (\ (x,y) v -> (x,y,v)) first.
09:08:36 <blasen> monochrom: i think you never actually talk about haskell.
09:08:57 <noan> :t (uncurry (,,))
09:08:59 <lambdabot> (a, b) -> c -> (a, b, c)
09:09:30 <noan> ah that makes sense
09:09:31 <opsman> monochrom: I'll have to because at the least I will recognize what's happening with the lambda a few weeks from now.
09:09:44 <Skull_Script> Here we go now I got my name back XD
09:09:51 --- mode: ChanServ set +o monochrom
09:09:56 --- mode: monochrom set +b *!*@unaffiliated/bigcake
09:09:56 --- kick: blasen was kicked by monochrom (blasen)
09:10:03 --- mode: monochrom set +b *!*@unaffiliated/jslave
09:10:04 --- kick: jslave was kicked by monochrom (jslave)
09:10:12 --- mode: monochrom set -o monochrom
09:11:53 <noan> opsman, do you understand the uncurry (,,) thing? If not I can try to walk you through it
09:12:13 <Skull_Script> So I am new to hacking, i was wondering if anyone had any good recommendations for places to practice
09:12:27 <Skull_Script> I use HackThisSite a lot, any other suggestions?
09:12:40 <monochrom> This channel is not about hacking.
09:12:43 <noan> Skull_Script, you mean learning software security?
09:12:53 <Skull_Script> yes
09:13:02 <monochrom> Furthermore this channel is not a directory service either so I won't answer "where instead?"
09:13:23 <opsman> noan: "information-dense" I'm plagiarizing that term.
09:13:32 <noan> opsman, it's a term from linguistics.
09:13:40 <noan> opsman, for instance, chinese is more information dense than english
09:13:47 <opsman> apt.
09:14:58 <opsman> okay, I gotta get back on task..thaks everyone for your time and patience. as always a good experience in this channel.
09:15:04 * hackage unity-testresult-parser 0.1.0.0 -   http://hackage.haskell.org/package/unity-testresult-parser-0.1.0.0 (incertia)
09:15:07 <maerwald> Skull_Script: there were some haskell hacking challenges somewhere, but I don't exactly remember where
09:15:08 <noan> opsman, have a great time
09:15:57 <Skull_Script> Oh ok cool! I just found this IRC channel I didn't know Haskell had a site too
09:16:23 <noan> Skull_Script, Haskell is a major programming language, with a large community.
09:16:57 <Skull_Script> Oh? Ok, that sounds interesting
09:17:02 <noan> Skull_Script, fyi the main reason I haven't offered you learning resources is that they way you asked sounded "Black-Hat" and very general
09:17:03 * noan shrugs
09:17:31 <maerwald> noan: lol what
09:18:34 <noan> maerwald, if someone asks you to "Teach me to hack", what's your response?
09:18:46 <maerwald> "sure"
09:19:11 <maerwald> assuming that he actually means "hacking"
09:19:45 <noan> maerwald, do we mean "programming" or undermining software systems?
09:20:01 <noan> the former, "sure", the latter, nä.
09:20:18 <maerwald> I'm not criminalizing people I don't know
09:20:36 <maerwald> hacking in terms of software security is an important part of programming
09:20:41 <noan> maerwald, of course it is
09:20:50 <noan> maerwald, but things somehow can sound very black hat
09:21:02 <maerwald> that was just in your head I think
09:21:04 <noan> and I'm happily motivated to help white hats, but black hats can do it they damn self
09:21:08 <noan> maerwald, probably
09:21:16 <noan> I'm a judgemental cunt in all likelyhood
09:25:33 * hackage unity-testresult-parser 0.1.0.1 -   http://hackage.haskell.org/package/unity-testresult-parser-0.1.0.1 (incertia)
09:34:01 <WarzoneCommand> question about linear: basically I want to access the i^th element of a vector of type V2 a. I'm expecting that something like: (V2 0 1)^.ix 0 == 0 would work. But somehow the Index type of a V2 a is defined as 'E V2'? That does not make sense to me
09:37:37 <iqubic> So I wrote this myself, and I have no why it works. I was just kinda playing around with in until everything worked.
09:37:40 <iqubic> http://dpaste.com/1W44VP4
09:38:03 * hackage clay 0.13.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.13.1 (seanparsons)
09:38:19 <iqubic> Can someone help me.
09:40:30 <c_wraith> iqubic: usually that pattern is used in writing left folds with foldr
09:42:07 <c_wraith> iqubic: it's not necessary in this case, though.  you're not doing a left fold.
09:43:34 <c_wraith> iqubic: you could also write it as http://dpaste.com/35K2H6H
09:44:15 <c_wraith> iqubic: so what part are you curious about - why your version worked, or how else you might write it?
09:46:13 <iqubic> I don't know how my version works.
09:46:47 <iqubic> Wait, how does your version work>
09:49:03 <ddellacosta> iqubic: I'm actually trying to figure out why you used `const []` instead of doing what c_wraith did
09:49:19 <c_wraith> iqubic: well, does http://dpaste.com/2RN78C9 make sense to you?
09:51:17 <iqubic> ddellacosta: That's how ertes presented the code in his foldr tutorial
09:51:36 <iqubic> Yes, I see why that take while works.
09:51:55 <c_wraith> iqubic: well, that version is *very* closely related to the foldr version I provided
09:52:13 <c_wraith> iqubic: basically, foldr is for abstracting out exactly that recursion pattern
09:52:23 <ddellacosta> iqubic: ah okay
09:52:34 <iqubic> I wrote this too: http://dpaste.com/2A9KWHY
09:53:12 <iqubic> Which makes it easier to write takeWhile recursively.
09:53:33 <iqubic> Bt why does your thing without const [] work?
09:54:00 <c_wraith> iqubic: because I'm not passing pred along every step - I'm just closing over it.
09:54:45 <iqubic> and that lets you get rid of the const? How?
09:54:57 <c_wraith> there's no argument to ignore anymore
09:55:25 <iqubic> I see.
09:56:10 <iqubic> BTW xs is a free variable, so you can get rid of that in the argument list.
09:56:30 <iqubic> In this: http://dpaste.com/35K2H6H
09:56:55 <c_wraith> I don't think "free" is the right term.  But you can eta-reduce it away
09:57:21 <iqubic> Yes. That is what I meant. Not sure what a "free" variable is.
09:57:34 <iqubic> But I have to go now, so we can tackle that later.
09:57:41 <c_wraith> a free variable is one that isn't bound in the code.  foldr is a free variable there.
09:57:56 <iqubic> Why is foldr free?
09:58:13 <c_wraith> it's not defined there.  So you're using whatever version of it is defined in scope
09:58:19 <nshepperd> I am not a de bruijn number, I am a free variable!
09:58:33 * hackage idris 1.3.0 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-1.3.0 (EdwinBrady)
09:59:01 <ddellacosta> iqubic: does this tweak of your last explicit version help re: what's up with 'const []'? http://dpaste.com/3K2DA2E
09:59:33 <iqubic> yes.
09:59:57 <iqubic> I still don't understand how foldr can return a function though.
10:00:02 <c_wraith> :t foldr
10:00:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:00:24 <c_wraith> `b' can unify with `(c -> d)'
10:00:40 <iqubic> Right, but how does that work in the takeWhile example?
10:00:50 <monochrom> Yeah, b is up to you, make it a list type or array type or function type or whatever
10:01:18 <infinisil> Idris 1.3.0 :OOO
10:01:22 <iqubic> I see. So what is the type of b in the takeWhile function we have?
10:01:34 <c_wraith> (a -> Bool) -> [a]
10:01:59 <c_wraith> But you should go ahead and write out the full type of f in your example
10:02:02 <c_wraith> that would help a lot
10:02:16 <iqubic> I'll do that when I return. I don't have time now.
10:02:34 <monochrom> This will take time.
10:02:57 <iqubic> Finding the tyoe signature of f?
10:03:17 <monochrom> Do not expect that learning time can be shortened by pure reading.
10:09:44 <ddellacosta> iqubic: it may help to split 'f' out to another function to see what's going on, fwiw
10:10:06 <noan> wait what? why does foldr result in t a -> b and not t b?
10:10:28 <noan> oh. it doesn't in and of itself take an a
10:11:25 <ddellacosta> noan: in iqubic's first one?
10:11:28 <noan> nevermind I misread hard.
10:11:45 <noan> I misread "t a -> b" as t (a -> b)"
10:12:00 <noan> basically I'm stupid
10:12:24 <ddellacosta> noan: this one is definitely tricky!
10:20:33 * hackage crawlchain 0.3.1.0 - Simulation user crawl paths  http://hackage.haskell.org/package/crawlchain-0.3.1.0 (axm)
10:24:15 <hc> whoever pasted http://dpaste.com/1W44VP4 earlier... now I understand it. feels good :-)
10:25:03 * hackage flay 0.4 - Work generically on your datatype without knowing its shape nor its contents.  http://hackage.haskell.org/package/flay-0.4 (RenzoCarbonara)
10:30:08 <ddellacosta> hc: yeah I had to poke at it a bit before it made sense to me. iqubic I wonder if this makes it (more) obvious why yours is distinct from the alternative: http://dpaste.com/15RB16J
10:30:25 <ddellacosta> in any case, neat little trick there
10:47:42 <Gurkenglas> https://lpaste.net/4539077229761527808 "Could not find module `Prelude'"
10:47:46 <Gurkenglas> What do I do?
10:48:37 <monochrom> Perhaps you or someone else forgot to include "base" in the dependencies.
10:49:01 <monochrom> But eh, I don't know jack, I don't know stack, I don't know intero.
10:49:07 <monochrom> s/eh/meh/
10:50:59 <emilypi> Gurkenglas: i've run into this before attempting to drop in intero as a replacement for a custom haskell-mode configuration. The solution was to start from a minimal intero setup, and slowly add new haskell-mode hooks. Some of them conflict with intero.
10:51:03 <emilypi> you'll have to find out which
10:51:17 <emilypi> (if you're using emacs, that is)
10:51:21 <emilypi> I imagine it's the same with vim
10:51:49 <Gurkenglas> I've previously used intero, this problem wasn't around before I last restarted this PC
10:52:30 <Gurkenglas> Which I did because while working in emacs I got a blue screen of death on windows (!)
10:52:40 <Gurkenglas> haven't had one in years
10:52:55 <emilypi> yikes
10:54:01 <Gurkenglas> Haven't changed the .emacs file in at least days
10:57:11 <Gurkenglas> @where ops
10:57:11 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
10:57:22 <monochrom> Yes?
10:57:54 <Gurkenglas> The person currently named exwrittoo93 has changed their nicks dozens of times in the last hour
10:58:23 <monochrom> Ah, there
10:58:30 --- mode: ChanServ set +o monochrom
10:58:31 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.37.45.207.76
10:58:31 --- kick: droplipil96 was kicked by monochrom (droplipil96)
10:58:37 <geekosaur> and has been for the past several days. but hasnt really caused an issue
10:59:12 <monochrom> Well OK, I can unban, maybe they won't bother to re-join.
10:59:21 --- mode: monochrom set -b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.37.45.207.76
10:59:26 --- mode: monochrom set -o monochrom
11:00:54 <Gurkenglas> monochrom, the bottom of the paste includes the .cabal file
11:02:12 <monochrom> I think demonically rather than angelically.  Whereas you think of "they have been here without issue", I think of "they can be outside without issue".  Whereas someone thinks "I wouldn't criminalize someone I don't know", I think "I wouldn't trust someone I don't know".
11:06:33 * hackage testing-feat 1.1.0.0 - Functional Enumeration of Algebraic Types  http://hackage.haskell.org/package/testing-feat-1.1.0.0 (JonasDuregard)
11:09:07 <maerwald> that has been sufficiently demon-strated
11:09:30 <monochrom> Haha
11:10:16 <maerwald> my eyes hurt from looking at clojure code, I need some haskell code
11:11:24 <monochrom> Perhaps take a look at the source code of testing-feat which was just announced by the hackage bot a moment ago.
11:14:37 <maerwald> yes, it has types. Feels good
11:17:07 <ddellacosta> maerwald: Clojure has types, it's just that no one wants to admit it
11:17:34 * ddellacosta may or may not write Clojure at his day job
11:17:49 <maerwald> I just feel so lost when looking at any piece of code
11:18:23 <ddellacosta> maerwald: (trying hard to not start ranting) let's just say, I feel your pain
11:18:38 <ddellacosta> anyways, this is #haskell so
11:18:41 <ddellacosta> I will shut up now
11:19:18 * ddellacosta goes back to poking at comonads
11:27:11 <zincy> If I am writing an API that uses websockets and servant is it overkill to define the websocket handlers as servant endpoints?
11:36:34 <coventry> Where is the `:{ :}` notation used in this example documented? <http://hackage.haskell.org/package/base-4.11.1.0/docs/Debug-Trace.html#v:traceM> I tried to hoogle it, but got a parse error. https://www.haskell.org/hoogle/?hoogle=%3A%7B+%3A%7D
11:37:33 <Cale> coventry: The documentation for GHCi?
11:37:48 <Cale> If you type :? on the ghci prompt, it'll be one of the things which is mentioned
11:38:22 <coventry> Cale: Thanks.
11:38:24 <ddellacosta> coventry: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#multiline-input
11:38:39 <ddellacosta> a.k.a. what Cale said
11:38:43 <coventry> Even better, thanks.
11:42:13 <koala_man> in Parsec, how can I get the string of input that a parser would match?
11:42:43 <hpc> like turn a parser into a generator?
11:43:29 <hpc> that operation doesn't exist in parsec, but i vaguely remember there being a library where the same code defines a parser and generator?
11:43:43 <cocreature> koala_man: not sure about parsec but megaparsec calls it "match" https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec.html#v:match maybe that’s at least a helpful search term
11:43:46 <hpc> i tried looking for it once about a year ago and didn't find it
11:43:59 <koala_man> like if I have a parser  readInt = read <$> many1 digit  that given "123 foo" consumes "123" and returns 123, I want the actual string "123"
11:44:30 <koala_man> cocreature: exactly that, yes
11:45:15 <infinisil> koala_man: Just don't use read then?
11:47:12 <koala_man> infinisil: imagine it's a much larger parser
11:47:40 <cocreature> koala_man: I can’t find anything for parsec but it should be possible to write it yourself by calling getPosition before and after
11:48:56 <koala_man> cocreature: I did it with a lookahead to get the end position, and then anyChar until the position matches, but it seems inefficient
11:49:10 <koala_man> because the position is line/column instead of char offset
11:49:44 <cocreature> ah that’s annoying :/
11:50:58 <koala_man> I guess I could use getInput, but then I still need to find the length of two potentially long [Char]s
11:52:30 <cocreature> yeah that’s going to be tricky given that megaparsec doesn’t track the number of consumed characters afaict
11:53:48 <cocreature> at least now I have one more reason to be happy that I can use megaparsec in my projects ;)
11:55:33 * hackage pipes-zlib 0.4.4.2 - Zlib and GZip compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.4.2 (RenzoCarbonara)
11:56:17 <Gurkenglas> I suppose if a restart caused the intero problem I'll restart again ._.
11:56:45 <Gurkenglas> Or should I carry this to the devs so they can try to see what went wrong?
11:59:47 <Peaker> Hey, is ghc 8.4 usable with perf -G (call-graph based perf)? Does it tell you which source definitions were expensive? (Rather than inner core ones)
12:04:55 <Gurkenglas> https://lpaste.net/9112957790703321088 I sure see a main
12:05:30 <Gurkenglas> Wait, I don't. Where did it go!? :DD
12:11:52 <lamdev> hello, i'd like to know if the symbol "@" has a known use in haskell's type signatures? including any extension supported or that would be soon to be supported? i'd like to use a custom pretreatment of haskell source file to automatize some stuff, but i'd need to be sure it doesn't risk clashing with something later on
12:13:12 <cocreature> lamdev: I don’t think it’s used in type signatures but it’s used for TypeApplications
12:13:55 <cocreature> and as-patterns
12:14:05 <Gurkenglas> Can ghc output write <<loop>> when ghci doesn't?
12:16:42 <lyxia> yes
12:18:27 <lamdev> i didn't know about type applications, i'll look into it cocreature, thanks!
12:19:04 <cocreature> lamdev: out of curiousity, what are you trying to automate?
12:25:33 <lamdev> cocreature: well, newtypes are powerful and kind of ubiquitous, but their verbosity and redundancy when you wrap or unwrap them (like in say foo :: Foo Int -> Int ; foo (Foo a) = a*2 ) are quite annoying to me.
12:26:12 <cocreature> lamdev: so you want implicit conversions from/to newtypes? that seems to destroy a lot of the benefit of newtypes
12:26:42 <lamdev> Since there's nearly always just one constructor per newtype (very often named the same way), it would make sense to me to shorten the unwrapping syntax by merely using a small, unwrapping operator, like (foo :: Foo Int -> Int; foo *a = a*2) with here star as "newtype unwrapper" operator.
12:27:18 <lamdev> cocreature: i don't think newtypes' power is in their tag-ness... more in the way they're treated differently at the type level? but i could be wrong...
12:28:39 <cocreature> lamdev: most of the time when I reach for a newtype I do so to avoid mixing up different things, e.g., I very often use newtypes around Int to ensure I don’t end up using the wrong one somewhere. and in those cases you really don’t want implicit conversions
12:28:53 <lamdev> At any rate, no information would be lost, simply, instead of writing out time and again the unique constructor to unwrap the value, you'd just put a star or whatever else, and then the right constructor would be inserted...
12:29:21 <cocreature> although it sounds like your conversions are not implicit but just shortened so I guess that’s not that bad (although I personally still doubt it will be worth the cost of a preprocessor)
12:29:54 <lamdev> cocreature: well the information about the real type is in the type signature... granted sometimes you don't use them but in that case you can always write the constructor manually of course. and besides it would not be implicit at all, as you said it's for the sake of brevity, and readability
12:31:44 <lamdev> i think we'd use newtypes even more profusely if we could manage them with less verbosity. i mean after all, the whole point of newtypes is to end up, after the types have been erased, with the exact same value than what you'd have without the wrapping... does it really make sense to write manual wrapping and unwrapping which will not even have incidence on the final binary's content?
12:33:07 <cocreature> we could throw away the entire type system because having a type system doesn’t affect the final binary
12:33:15 <cocreature> so I’m not sure that’s a useful argument to make
12:33:23 <maerwald> let's go clojure :P
12:33:53 <cocreature> (well I guess technically with typeclasses that’s not entirely true but my point still stands)
12:34:26 <lamdev> cocreature: i said wrapping and unwrapping was not relevant, but the type system is: the functions you apply to a newtype wouldn't be the same (a priori) than the original value. but the manual unwrapping and wrapping is for nothing at the very end, just there to say "i still know it's a newtype", but that in my opinion could be shortened
12:35:09 <lamdev> in the ideal i'd love to write something like a ghc extension or whatever, but i don't have the knowledge for that yet! i planned on using a very simple parsing system, writing something like
12:35:35 <cocreature> wrapping and unwrapping is how you convert from one type to another so I don’t think you can see the type system in isolation from wrapping/unwrapping
12:35:43 <lamdev> foo :: @Foo (@Bar a) -> @Bar (@Bla a) -> (a,a)     ; foo **a **b = (a,b)
12:36:08 <lamdev> cocreature: and my idea is just to shorten the unwrapping syntax. it's really just shortening, nothing's implied or hidden away
12:36:28 <cocreature> lamdev: are you aware of "coerce"? that can often take a way a lot of the pain of rewrapping things
12:37:01 <cocreature> I guess I’m just very sceptical of adding more syntax for things that I don’t see as a problem but don’t let me stop you :)
12:37:13 <lamdev> by contrast: foo :: Foo (Bar a) -> Bar (Bla a) -> (a, a) ;   foo (Foo (Bar a)) (Bar (Bla b)) = (a, b) -- seriously not as readable to me, even if the example might be a bit particular
12:37:43 <cocreature> you can just use "foo = coerce"
12:37:47 <lamdev> cocreature: i'll look into coerce! it reminds me of something, so perhaps i already looked into it.
12:37:58 <lamdev> cocreature: what would coerce do?
12:38:03 * hackage brick 0.37.1 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.37.1 (JonathanDaugherty)
12:38:08 <cocreature> :t coerce
12:38:10 <lambdabot> error:
12:38:10 <lambdabot>     • Variable not in scope: coerce
12:38:10 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
12:38:13 <lamdev> oh you mean i'd read the types and infer the transformations?
12:38:15 <cocreature> :t Data.Coerce.coerce
12:38:16 <lambdabot> Coercible a b => a -> b
12:38:27 <Gurkenglas> Hmmmm. "fix $ (repeat 0:) . (zipWith . zipWith) f x" converges, but "fix $ map (0:) . (zipWith . zipWith) f x" does not.
12:38:27 <cocreature> GHC generates magical Coercible instances for newtypes
12:39:12 <Gurkenglas> It's relatively clear what happens, but it's so... wrong
12:39:59 <lamdev> *it'd read the types
12:40:46 <lamdev> i doubt it would work if it weren't just transformations between types without any "inner value" modifications : if i have a (Foo Int) and (Bar Int) and i want to  the multiply the values together, i'm not sure how coerce could tell i don't wanna add them?... and with that kind of thing, would i need to write Coercible instances for all my types?
12:41:11 <lamdev> though if it can be generated automatically or something...
12:42:18 <Gurkenglas> Ah, I suppose I want map (0:) . (++[]) instead of map (0:) there
12:42:27 <Gurkenglas> *(++ repeat []), of course
12:43:02 <Gurkenglas> (or transpose twice.)
12:43:15 <the_blorg> How to have a function implementation depend on the classes that the data belongs to? Kind of like "pattern matching on classes".
12:43:23 <cocreature> lamdev: you could still coerce the individual values to get something like "f :: Foo -> Bar -> Int; f x y = coerce x * coerce y" but that’s not really an improvement over explicit unwrapping imho
12:43:30 <the_blorg> So I could for example define a version of Set that works for any type, but uses a more efficient algorithm when the data has an Ord instance.
12:43:38 <cocreature> the_blorg: you can’t do that
12:43:59 <lamdev> cocreature: yeah, it just moves the verbosity to the expression side...
12:44:39 <cocreature> lamdev: you can define "c = coerce" you get "c x * c y" which is about as short as your custom syntax afaict ;)
12:45:09 <Gurkenglas> Wait, that still wouldn't converge. :C
12:45:18 <lamdev> cocreature: yeah... a unary symbolic operator still feels more readable... but i agree it is a viable alternative
12:45:37 <the_blorg> cocreature: That is unfortunate. It would be an elegant way of making a version of Set that has a Functor instance.
12:46:41 <cocreature> lamdev: preprocessing has a relatively high cost. you need to tell your build tool about them, editor tooling like “show type at position” won’t work, ghci doesn’t play nice with preprocessors, … so I would recommend that you think about whether making your code slightly shorter is really worth those downsides
12:48:57 <lamdev> cocreature: well, the "show type at position" never worked for me so far :P and so far i didn't really need it, but it might change... but i agree, it's always a problem when transforming the language from the outside...
12:50:34 <Gurkenglas> the_blorg, there would still be a problem that an Eq instance that equates two distinguishable values X and Y would let you do fmap id (S.fromList [True, False]) == fmap ((\xy -> case xy of X -> True; Y -> False) . bool Y X) (S.fromList [True, False]) /= S.fromList [True, False]
12:51:31 <cocreature> lamdev: anyway, sry for being so negative. I’ll stop now :)
12:52:15 <lamdev> cocreature: no, you raised valid points!
12:52:31 <lamdev> btw, is there nowadays a possibility to mark a function as "public" wrt exporting, or do we still have to write the very huge lists of exports at the start of the modules? cuz that's an extension of the language i'd love to see!
12:53:57 <cocreature> you still need an export list
12:54:11 <nobby> I cannot delete my cabal file, it keeps reappearing
12:54:15 <lamdev> cocreature: sigh... well maybe in the future...
12:54:19 <nobby> is this an OS issue?
12:54:21 --- mode: ChanServ set +o monochrom
12:54:40 <cocreature> nobby: are you using stack?
12:54:44 --- mode: monochrom set -bb *!*@unaffiliated/jslave *!*@unaffiliated/bigcake
12:55:01 <sclv> nobby: why are you trying to delete it?
12:55:03 --- mode: monochrom set -o monochrom
12:55:15 <nobby> cocreature: Yep im using stack
12:55:20 <sclv> (if you're using stack, it'll auto-generate the cabal file from the package.yaml file)
12:55:26 <sclv> (which is the intended behaviour)
12:55:28 <nobby> sclv: Because i want to modify package.yaml to generate a new cabal file
12:55:46 <sclv> nobby: but if you modify package.yaml it should generate the new cabal file for you automatically
12:55:48 <sclv> which is why it reappears?
12:55:50 <cocreature> lamdev: if you want to export everything but a certain set of functions you can accomplish this by introducing a module indirection where one module exports everything and the other imports that module using a "hiding" clause and reexports it
12:55:59 <sclv> unless you mean you literally just can't delete/overwrite the file?
12:56:27 <sclv> in which case you should check permissions
12:56:42 <sclv> but you shouldn't manually need to delete it -- it should get updated with the changes from the package.yaml automatically afaik
12:56:51 <nobby> sclv: cheers!
12:57:46 <lamdev> cocreature: hm yeah, good idea... it's still the problem of having to manage the lists of existing functions in two different places... with that method, it'd even be across two different files... if we had a "pub" statement like in rust, commenting out a function would automatically and logically remove it from the exports of the module... :/
13:04:02 <EvanR> or idris
13:04:40 <edwardk>  
13:05:46 <EvanR> how about a committee to come up with the next greatest module bookkeeping language
13:08:31 <monochrom> It is simpler to have a checkbox beside each function, or entity, for marking it for export.
13:09:33 * hackage sixty-five-oh-two 1.0.0.0 - An eDSL for writing 65(C)02 bytecode.  http://hackage.haskell.org/package/sixty-five-oh-two-1.0.0.0 (aearnus)
13:14:17 <coventry> When I try the `:step main` command described here, ghci hangs. Do I need to do something else to drop into single-step debugging in modern ghci? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#single-stepping
13:15:48 <coventry> Seems like it might be some kind of debugger state, from the fact that I had already stopped on a breakpoint...
13:16:03 * hackage hashtables 1.2.3.1 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.2.3.1 (mgmeier)
13:16:38 <coventry> OK, it doesn't happen if I restart ghci.
13:20:04 <Modius> So let's see how fast I can get kicked out from here. . . pipes or conduits (ducks)
13:21:06 <infinisil> I now know of the ST, Cont, STM, and parser monad, which are all very interesting and 'special'. Are there any more of those that are less known?
13:21:29 <Younder> monads is just like plumbing, just with more fussy connections
13:22:13 <infinisil> MonadTrans count be counted too I guess
13:23:19 <jesyspa> infinisil: Probability is a cool one, IMHO.
13:23:36 <lyxia> infinisil: Async, Par, Gen.
13:24:03 <infinisil> Oh and Free and Cofree are interesting too
13:24:08 <lyxia> oh wait Async is not a monad. I was thinking of futures or promises or something...
13:24:45 <tvN> why haskell?
13:25:01 <infinisil> Nice though, I didn't know of all of those
13:26:50 <EvanR> i counted about 19 monads at one point
13:28:03 * hackage sixty-five-oh-two 1.1.0.0 - An eDSL for writing 65(C)02 bytecode.  http://hackage.haskell.org/package/sixty-five-oh-two-1.1.0.0 (aearnus)
13:28:17 <infinisil> I just read about Cont, hoping I could use it for what I'm doing, but it's not what I expected
13:28:32 <infinisil> Or maybe I just don't yet get all its use cases
13:28:33 * hackage simple-effects 0.12.0.0 - A simple effect system that integrates with MTL  http://hackage.haskell.org/package/simple-effects-0.12.0.0 (darwin226)
13:29:55 <geekosaur> you may never get all its use cases. cps is a thing for a reason :)
13:30:02 <Gurkenglas> How can "fix $ (repeat 0:) . (zipWith . zipWith) f x" and "fix $ map (0:) . (zipWith . zipWith) f x" be tweaked such that both converge?
13:33:00 <tvN> why should one learn haskell? why is immutability important? why functional over OOP?
13:33:18 <Rembane> tvN: Enlightenment!
13:33:54 <infinisil> tvN: https://stackoverflow.com/a/1604828/6605742
13:34:01 <initiumdoeslinux> tvN: http://jiri-kremser.github.io/rx-devconf-presentation/pic/lambda.jpg
13:34:31 <tvN> thx
13:35:25 <monochrom> https://www.youtube.com/watch?v=1qBHf8DrWR8  (Wadler's talk "why FP matters")
13:36:03 <monochrom> It turns out it is not so much immutability as thinking wholesale and therefore more composable.
13:37:16 <duncan^> that doesn't look like Wadler
13:37:20 <monochrom> In fact all of the OOP promises of abstraction, composition, reuse, etc failed miserably except for Smalltalk because most OOP languages still start with the von Neumann model.
13:37:39 <monochrom> Oh oops Hughes.
13:37:59 <monochrom> And it shows. Smalltalk is the one that delivered the promises.
13:38:32 <monochrom> But then you look at Smalltalk's seamlessly letting you pass around "blocks" and it's FP all over again. So there.
13:39:42 <monochrom> Shameless plug: http://www.cs.utoronto.ca/~trebla/CSCC24-2018-Summer/00-intro-p1.pdf
13:39:48 <tvN> tbh, im not a fan of OOP or anything, i actually just don't understand how or why OOP got big in the first place, what was wrong with like whatever being used before OOP became/hit mainstream
13:39:56 <EvanR> marketing
13:40:14 <EvanR> the big thing before OOP, "structure programming" was pretty bad
13:40:16 <Modius> Most of what we do in "OOP" is Java etc. which is off of getting C++ programmers to be able to write the same software they were use do writing.
13:40:18 <EvanR> structured programming
13:40:19 <Modius> In +
13:40:19 <Modius> Copyright (c) 1998-2003 P.I. Engineering, Inc.
13:40:54 <Modius> In C++ it was more important to deal with ownership (not leak memory/confusion) than anything else.
13:41:25 <monochrom> OOP was a reasonable attempt at more abstraction than structured programming.  I mean until you implement it and use it, you wouldn't know how well it works out.
13:41:32 <Modius> "OOP" in C++ was a way to have random groups of things with functions on them that woudln't leak.
13:41:49 <monochrom> At any rate Smalltalk was (and still is) pretty good.
13:42:04 <Modius> "OOP" in single-reference languages like Java wasn't some clean slate devised way of programming but to bring C++ programmers over.
13:42:21 <monochrom> Simula too. At least for its intended application.
13:44:01 <monochrom> At any rate my slides have an "Appendix: Backus's Proposal" at the end showing why FP is the one that achieves all the niceties of abstraction, reuse, components...
13:44:59 <Gurkenglas> I made https://lpaste.net/5956169055915212800 to use ghci to look at the usual where-based implementation more closely. It says my implicit parameters are unbound, though. Can I fix this without giving each line a type signature?
13:46:06 <Gurkenglas> Alternatively, what sequence of keystrokes would show me the values of the where bindings for given a, b in the where version?
13:48:29 <coventry> I'm invoking ghci with `stack ghci`. The key chord Alt-b doesn't work as I expect (backward-word in emacs). It works fine at the bash command line, though. Where can I configure this? I tried running with `--package readline`, but that didn't make any difference, and anyway, other readline bindings work.
13:49:11 <mud> coventry: ghci would have to support that if I understand correctly, which it doesn't
13:49:55 <coventry> OK. I can live with Ctrl-right, I guess.
13:50:13 <geekosaur> cov entry, ghci does not care what packages you have loaded, it is built against "haskeline" which si a sort of mini-readline that exists so ghci can be built the same way on linux + os x + windows
13:50:28 <geekosaur> it has some configurability but not quite enough
13:50:31 <AndreasK> coventry: afaik ghci uses haskeline not readline
13:51:15 <coventry> That's OK. I'll probably end up running it under emacs, anyway.
13:51:37 <reactormonk> coventry, intero?
13:52:04 <ggVGc> I think you meant vim
13:52:08 <coventry> reactormonk: Don't know... I'm not there, yet.
13:52:09 <ggVGc> easy mistake to make
13:52:22 <reactormonk> ggVGc, evil, mostly.
13:52:56 <reactormonk> Although I meant to give neovim a try... but that comes after i3.
13:53:28 <ggVGc> if I already had some basic emacs knowledge, I'd probably be using evil, but vim is too ingrained in my brain and hands
13:53:31 <infinisil> Okay, after reading through a couple Cont/CPS readings, I found this one to be the best by far: https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
13:54:12 <mud> neovim is pretty nice. Not very different from vim of course
13:54:19 <EvanR> learning new crazy computer programs will stave off alzheimers
13:54:30 <EvanR> dont let vim win
13:54:55 <Modius> FWIW, I gave up on the mess that was ghc-mod integration years back; but snoyman's emacs (on github) and intero integration seems to work very well.
13:54:55 <coventry> Spacemacs is sort of evil (in the bad way), but I like it anyway.
13:54:58 <monochrom> infinisil: Have you seen mine? http://www.vex.net/~trebla/haskell/cont.xhtml
13:55:03 <ggVGc> mud: different enough that it gets to me in daily work, so I gave up several times already. It's a shame because I like a lot that it's an actual community project, rather than "Bram, and the occasional accepted patch every few years"
13:55:05 <Zipheir`> infinisil: The Haskell wikibook is actually pretty solid.
13:55:29 <ggVGc> does anyone else feel Haskell suffers a lot in readability, but shouldn't necessarily need to
13:55:40 <maerwald> yes
13:55:48 <infinisil> monochrom: I have not
13:55:51 <ggVGc> I think even for experienced haskellers, a lot of stuff is a lot harder to read than it could be
13:56:07 <ggVGc> it has started bothering me a lot lately
13:56:08 <mud> ggVGc: I don't too deep into config compared to others I don't think. It took me a few to figure out what plugins I could use or what to use instead, but that was about it for me.
13:56:09 <EvanR> depends on the writing style
13:56:09 <maerwald> haskell is terrible to read in general
13:56:16 <maerwald> but there are worse languages
13:56:17 <ddellacosta> ggVGc: I'm not sure, I find that most of the time the challenge I have reading Haskell is in understanding the concepts
13:56:42 <ggVGc> ddellacosta: that's part of the problem. A lot of "concepts" are used way too much where there's no need
13:56:47 <ggVGc> complicating very simple things into monsters
13:56:50 <ggVGc> for no reason
13:56:55 <maerwald> I agree too
13:56:56 <ggVGc> other than maybe masturbation
13:57:01 <EvanR> which haskell code are you referring to
13:57:18 <ddellacosta> ggVGc: then we aren't really talking about readability are we? It sounds like you're complaining about concepts prevalent in Haskell code
13:57:19 <Zipheir`> Haskell has a lot of syntax, but the fact that so many weird symbols are just functions is a great help.
13:57:25 <maerwald> ggVGc: but I think that may also be an open source phenomena. I don't think it's that bad in industry/proprietary software
13:57:34 <maerwald> because they simply don't have the time to waste
13:57:42 <ggVGc> EvanR: not any specific piece. Just the attitude while writing haskell that many (including me) have, which is too much generalisation, lots of use of anonymous functions
13:57:54 <EvanR> yeah i dont do any of that
13:58:04 <infinisil> Hehe, there's this if you're confused over (non-function)-symbols in haskell: https://github.com/takenobu-hs/haskell-symbol-search-cheatsheet
13:58:05 <EvanR> i use very few lambdas
13:58:06 <ggVGc> maerwald: oh, yeah, all that commercial proprietary haskell I've seen does tell a different story :(
13:58:15 <ddellacosta> "too much generalization"--I always use just enough :-p
13:58:35 <ddellacosta> seriously though, I dunno, I think this is pretty subjective
13:58:37 <EvanR> use generalization twice a day whether you need to or not
13:58:44 <ddellacosta> ha
13:59:02 <maerwald> well, the type system is so expressive that it calls for it. It's like saying C programmers do way too many memory tricks. It's true ;)
13:59:11 <ggVGc> that is also true
13:59:20 <ggVGc> for some reason C programmers seem to have passing by value
13:59:24 <ggVGc> even though it's often even faster
13:59:29 <ggVGc> but it doesn't feel as good eh
13:59:38 <ggVGc> hate*
13:59:42 <EvanR> i pass structs by value to annoy C programmers
13:59:48 <maerwald> C is pass-by-value
13:59:55 <EvanR> as opposed to by reference
13:59:59 <ggVGc> maerwald: okay, well, many people only pass pointers by value
13:59:59 <ddellacosta> I mean, vs. pointers I guess
14:00:06 <Rembane> ggVGc: :D
14:00:07 <maerwald> pointers are values :P
14:00:13 <ggVGc> that was my point
14:00:14 <ggVGc> (er)
14:00:17 <fsestini> lol
14:00:25 <EvanR> lets not devolving into "call by foo" jargon tarpit
14:00:26 <ddellacosta> I got it, heh
14:00:56 <EvanR> call-by-in-passing-reference
14:01:19 <ggVGc> anyway, I've been writing a lot of elixir the past year, and it's a very different culture favouring to avoid anonumous functions, and generally being more verbose, and I think it's a lot better
14:01:36 <ggVGc> I wonder how a more verbose haskell would be
14:01:44 <EvanR> by anonymous do you mean lambdas or
14:01:47 <ggVGc> yeah
14:01:56 <EvanR> yeah i really havent seen a lot of that
14:02:21 <EvanR> but i cant stand java style verbosity
14:02:28 <monochrom> COBOL is the most verbose.
14:02:29 <ddellacosta> see I don't know that lambdas/anonymous functions are inherently bad. I think for every language you have to be careful to think hard about how the next programmer is going read the code
14:02:47 <ddellacosta> and in any language there is the possibility of creating unreadable noise
14:02:47 <ggVGc> also, in general, it seems the elixir community favours not using higher order functions that much, and haskell favours it as much as possible
14:02:55 <mud> ddellacosta: What if I suspect that I won't like the next guy?
14:03:03 <monochrom> "line noise" is subjective too.
14:03:10 <ggVGc> and I think I'm starting to lean more towards the side of trying to avoid higher order functions if I can
14:03:14 <ddellacosta> mud: I only said you have to think hard about it...haha
14:03:24 <mud> True
14:03:28 <EvanR> i noticed elixir being painfully verbose, every function is named with fully qualified names
14:03:30 <ddellacosta> ggVGc: see that doesn't seem like a place to start
14:03:41 <EvanR> so theres a serious lack of code factoring
14:03:42 <ddellacosta> _why_ do we want to avoid higher-order functions?
14:04:21 <ggVGc> ddellacosta: code becomes a lot clearer in many cases, and you avoid stepping into the "generalising too early" trap
14:04:38 <ggVGc> this is just my personal experience, hence why I asked how others feel
14:04:48 <monochrom> There is nothing bad about lambda. Sometimes a lambda is too long and causes a too-long line of code. That is bad but the reason is too-long not lambda. You can make a data type declaration too long, too, does it mean algebraic data types are bad now?
14:05:05 <EvanR> the first thing i noticed when beginning functional programming is how much less code you can write, the 10 line dance to do something can be copied into a function
14:05:25 <EvanR> i dont want to undo that
14:05:33 <ddellacosta> ggVGc: on the contrary, I find that if everyone knows what a fold does, then we've eliminated a whole bunch of boilerplate, standardized on a very powerful, mathematical concept, and we now have a shorthand so that other devs can see immediately what something is doing
14:05:43 <monochrom> People who suck at logic want to avoid higher-order functions.
14:05:44 <ddellacosta> something that would otherwise be pretty verbose and hard to grok
14:05:54 <fsestini> ggVGc: that would be because of the (bad) premature generalization, wouldn’t it?
14:06:14 <EvanR> yes please maps and folds over loops that mutate a structure
14:06:31 <monochrom> To be sure, OOP is even harder than higher-order functions. People are struggling with OOP too. The difference is that the job market forces them to cope.
14:06:40 <Rembane> Higher order OOP ftw!
14:07:10 <EvanR> ggVGc: isnt elixir supposed to be like ruby in some ways, which use 10s of blocks per procedure, and blocks are essentially lambdas
14:07:13 <monochrom> But my colleagues teaching OOP to students confirm that the students don't get Visitor or even the easier ones.
14:07:18 <ggVGc> ddellacosta: I'm all for really general higher order functions like map and fold, but started being less for higher order functions introduced by the project at hand
14:07:30 <ggVGc> I'm more careful nowadays before creating a new higher order function anyway
14:07:35 <EvanR> how do you write ruby without blocks...
14:07:46 <ggVGc> and often end up being able to express myself a lot clearer after thinking about it some more
14:07:56 <monochrom> In short, the students have only learned that OOP means getters and setters.
14:07:59 <ggVGc> by  for example writing two functions that return values instead
14:08:06 <ggVGc> and by picking those values well
14:08:06 <EvanR> every method that uses blocks is essentially a higher order fucntion
14:08:13 <ddellacosta> ggVGc: okay so then we need to start qualifying "higher order function," because if you start there you've basically ruled out one of the most powerful ways to use FP to compose, abstract, modularize code
14:08:40 <ddellacosta> "ad-hoc higher-order functions" perhaps are bad, but that's probably more about the "ad-hoc" part
14:08:46 <ggVGc> ddellacosta: there's a difference between "common higher order functions we're all used to" and "this higher order function someone wrote in this module"
14:08:51 <EvanR> no way
14:09:03 <ddellacosta> EvanR: in regard to what?
14:09:04 <EvanR> you guys are crazy
14:09:10 <ggVGc> that is accurate
14:09:14 <ggVGc> but is it relevant?
14:09:21 <ddellacosta> ggVGc: yes so we're agreeing...?
14:09:27 <EvanR> yes its relevant
14:09:36 <ddellacosta> EvanR: I'm still not sure what your "no way" was responding to
14:09:37 <EvanR> have you ever tried to replace an imperative HTML template with functional programming?
14:09:44 <EvanR> ddellacosta: adhoc higher order functions being bad
14:09:54 <ddellacosta> EvanR: oh I'm not saying that they are bad
14:09:54 <monochrom> Oh, I'm ready to agree that if you don't have at least 3 use cases for your higher-order function, you should not create it.
14:09:59 <EvanR> to eliminate repetition you want to factor out common patterns
14:09:59 <ggVGc> fwiw I'd argue there's very little, if anything, in common between elixir and ruby
14:10:03 <nshepperd> I don't really think about whether my functions are higher order on a daily basis
14:10:09 <ggVGc> other than the choice of do/end
14:10:27 <monochrom> But it's along the same line as me saying if you don't have at least 3 instances for your class, you should not create it.
14:10:49 <EvanR> ggVGc: i'm really sorry but it sounds like youve had a bad experience with basic functional programming, and so have elixir programmers
14:10:50 <monochrom> Generally any abstraction and generalization, really.
14:11:05 <unclechu> hey guys, could i catch exception for thread failing because 'mvar blocks indefinitely' case? i mean is there some data-type for this exception so i could filter it?
14:11:12 <EvanR> haskell may not be the best proving ground for it, since its very high level
14:11:12 <ggVGc> monochrom: I think what I'm mainly getting at is, a lot of higher order functions can be written as a combination of much simpler functions returing a value each
14:11:15 <monochrom> (And yes, there are 3 examples for my last sentence, so there!)
14:11:18 <ggVGc> which makes the use case much clearer
14:11:22 <ddellacosta> EvanR: I was more trying to drill in to what the distinction was that ggVGc was trying to make
14:11:39 <EvanR> it sounds like ggVGc is having a problem with something specific now
14:11:51 <ddellacosta> I don't really think I agree regardless, but taking "all higher-order functions are bad" at face value was too much to stomach
14:12:15 <EvanR> higher order functions, which make sense, is bread and butter of FP
14:12:27 <nshepperd> unclechu: the exception is called BlockedIndefinitelyOnMVar
14:12:31 <ddellacosta> ggVGc: a lot of higher order functions being expressible as combinations of much simpler functions sounds like exactly why we want to use higher-order functions
14:12:32 <EvanR> badly named undocumented and inscrutibly coded, maybe that is bad
14:12:33 <monochrom> ddellacosta: How about we focus the discussion to "all higher-order functions written by monochrom"? :)
14:12:37 <fsestini> but premature/excessive generalization is a general, well understood issue. you can “instantiate” it with hofs, but it has nothing to do with hofs per se.
14:12:47 <monochrom> ALL HIGHER-ORDER FUNCTIONS FROM MONOCHROM ARE BAD!
14:12:56 <ddellacosta> monochrom: oh we're talking about YOUR higher-order functions? Well in that case :-p
14:12:57 <nshepperd> unclechu: from Control.Exception
14:13:05 <unclechu> nshepperd (IRC) thanks!
14:13:27 <hpc> lambdabot:
14:13:27 <unclechu> yep, already found by hoogling around
14:13:30 <hpc> er
14:13:36 <hpc> @remember monochrom ALL HIGHER-ORDER FUNCTIONS FROM MONOCHROM ARE BAD!
14:13:36 <lambdabot> Done.
14:13:57 <monochrom> But every abstraction or generalization requires you to think "is this worth my time?". I agree with that. I champion that too for classes. Both Haskell classes and Java classes.
14:14:04 <geekosaur> …and of course monochrom is a higher order function…
14:14:12 <ddellacosta> maybe we should take this to #haskell-offtopic
14:14:37 <ddellacosta> meanwhile, on #haskell-offtopic __monty__ is asking about ghcid/cabal stuff...
14:14:58 <EvanR> i could also come in and, because of an issue i had, and say that lexical scope is bad. it was involved in something i had an issue with, and you can accomplish the same thing in a more primitive way without lexical scope. all lexically scoped variables can be translated into extra parameters, which are easier to understand, and more verbose
14:15:01 <geekosaur> heh
14:15:42 <ddellacosta> EvanR: reminds of the time I spent programming Python with a "senior" dev where they had a 400 line if/else block because "it's more explicit"
14:15:42 <EvanR> and be missing out on a huge advancement in programming science
14:15:43 <maerwald> EvanR: I don't think this was about language, but more about ecosystem
14:15:50 <ggVGc> EvanR: I think there's a balance, and I think maybe haskell often lures us into premature generalisation
14:15:52 <maerwald> and the point was entirely valid
14:15:58 <ggVGc> maybe I'm just crap at writing haskell
14:16:01 <ggVGc> (I am)
14:16:13 <ddellacosta> frankly, I think it's hard to talk about this stuff without lots of examples
14:16:18 <EvanR> my experience in what were talking about is mostly from scheme, lua, javascript
14:16:20 <ddellacosta> hard to talk about it usefully at least
14:16:30 <ggVGc> ddellacosta: yeah that's fair
14:16:36 <nshepperd> one or two times I have gotten value from rewriting a monadic fold kind of thing (which is higher order) as a data type and a step function that just updates that data type once
14:16:50 <maerwald> ddellacosta: I would say the opposite is true. If you pull in just one example into such a discussion, the discussion is dead by nitpicking on the example and diverging opinions on why the example was a good example or not
14:17:05 <nshepperd> but in my experience, general principles about programming are always wrong
14:17:12 <EvanR> haskell might be an environment with too much going on to see how great FP style can be
14:17:32 <monochrom> maerwald: Yeah but I don't understand how you went from "lots of examples" to "just one example".
14:17:37 <ddellacosta> maerwald: the problem is, the alternative is this kind of endless apples to oranges conversation where everyone's experience is varying and means we may all be talking about completely different things
14:18:07 <maerwald> monochrom: if it's more than one, the discussion is dead, because no one wants to waste his time on it
14:18:19 <monochrom> I want to.
14:18:31 <EvanR> ggVGc: ok i'm more inclined to get on board with the "i suck at reading and writing haskell" than "haskell sucks at being written or read, according to me, given that I suck"
14:18:32 <maerwald> I would say such a thing is better off at a mailing list
14:18:40 <monochrom> OK true.
14:18:41 <maerwald> if you present an essay-like argument
14:18:51 <EvanR> yeah i would appreciate some specific code examples
14:19:00 <monochrom> The problem with high-frequency chatting, eh?
14:19:15 <maerwald> EvanR: haskell is going more and more into the OOP direction though
14:19:21 <EvanR> how so
14:19:40 <maerwald> heavy use of transformers and classes is very OOP stylish
14:19:44 <monochrom> Haskell is fulfilling more and more promises that OOP failed to deliver.
14:20:04 <monochrom> I mean, think positive! Heh.
14:20:16 <EvanR> i have an issue with that style, but its pretty unique, i havent noticed anything OOP being like that
14:20:27 <maerwald> and indeed, for just being "functional" you don't need that much of a strong type system
14:21:28 <EvanR> every now an then i see a pattern that is doing good and i dont think i'd be able to pull it off without a type system
14:21:38 <EvanR> but for the most part now i do all GHC in my head... in any language
14:23:06 <mud> EvanR: I sure use the type system everywhere personally. It's way more expressive than most
14:23:53 <EvanR> well yeah
14:24:35 <bb010g> Hey all! I was raving about this channel in a group, and someone there said I should tell you that directly, so this is to tell you all that you're great, friendly, knowledgeable people doing cool stuff. Thanks. :)
14:24:59 <mud> bb010g: Nice :)
14:28:01 <EvanR> you take that back
14:31:01 <iqubic> Well I guess I don't understand foldr very well.
14:32:11 <maerwald> EvanR: I realized I don't like haskells type system primarily because of the expressivity, but because of the plug-and-play and documentational nature of function signatures. Although, you can lose both those properties when overusing the expressivity... very easily
14:32:11 <monochrom> Sometimes you have to do the algebra rather than use intuition.
14:32:19 <monochrom> Hell, s/Sometimes/Always/
14:32:33 <ddellacosta> iqubic: are you still going over the stuff you posted earlier?
14:32:48 <iqubic> yes.
14:33:02 <iqubic> I'm trying to figure out the type of f in this: http://dpaste.com/35K2H6H
14:33:12 <EvanR> yeah you have this huge thing to shoot yourself in the foot with
14:33:24 <EvanR> but its not like it would be an accident
14:33:48 <ddellacosta> iqubic: that is a more straightforward fold--f should be (a -> [a] -> [a]) I would imagine
14:34:16 <iqubic> I'm not sure though.
14:34:27 <iqubic> How can foldr return a function?
14:34:30 <maerwald> EvanR: type-synonyming a monad transformer stack already kills both properties
14:34:45 <iqubic> That part confuses me so much
14:34:46 <ddellacosta> iqubic: the first one you posted did that
14:34:47 <maerwald> now you have no idea what is under the hood and plug-and-play is mostly gone too
14:35:00 <ddellacosta> iqubic: did you see the last thing I linked to?
14:35:06 <monochrom> ddellacosta and iqubic: Are you referring to the (const []) version? Are you referring to the simpler version?
14:35:30 <iqubic> I'm refering to the version I just posted. The one where you close over pred.
14:35:46 <ddellacosta> iqubic: that is not returning a function as far as I can tell
14:35:46 <monochrom> I am a bit baffled. Is there anything that says foldr is not allowed to return a function?
14:36:18 <iqubic> No.
14:36:37 <iqubic> ddellacosta: What is the type of foldr, as used in the takeWhile function?
14:36:56 <reactormonk> If I want a dynamically typed type-indexed map, I'd use Proxy + Dynamic?
14:37:03 <monochrom> A more benign and practical example is "foldr (.) id [sin, cos, tan] = sin . (cos . tan)" so it computes a function just fine.
14:37:21 <iqubic> But what does the id do?
14:37:25 <monochrom> The takeWhile example is just less usual.
14:37:39 <monochrom> OK it's really sin . (cos . (tan . id))
14:37:40 <ddellacosta> iqubic: did you see this? http://dpaste.com/15RB16J
14:37:57 <maerwald> just use foldr1
14:38:54 <ddellacosta> I flipped the order you passed the predicate in around for the myTakeWhile1 function to make it more obvious (to me, at least) what it was doing
14:38:58 <monochrom> reactormonk: I think yes?
14:39:00 <zenspider> I'm working through exercises in Programming in Haskell and most of the time when I'm re-defining something from prelude, I can just tack on 'N to make it have a unique name.
14:39:16 <EvanR> maerwald: right... dont you usually use a newtype instead?
14:39:40 <monochrom> I tack on "my" but meh.
14:39:43 <zenspider> Is there a way I can do that w/ instances? I'm guessing not. Is there a way I can keep my instance decls w/o commenting them out or getting Duplicate intance decl errors?
14:39:57 <monochrom> Oh maybe I should tack on 'meh :)
14:39:57 <maerwald> EvanR: is that really better?
14:40:02 <EvanR> yes
14:40:08 <maerwald> marginally
14:40:13 <zenspider> maybe some sort of partial import of the prelude?
14:40:14 <EvanR> no one needs to know how you implemented a monad
14:40:33 <EvanR> as long as the api works
14:40:33 <maerwald> and now all sorts of features are stuffed into it
14:40:35 <maerwald> like an object
14:40:36 <iqubic> What is accrete doing?
14:40:37 <zenspider> or other scoping mechanism
14:40:48 <EvanR> not an object, but a new programming language
14:40:55 <maerwald> you removed the declarative notion and replaced it with OOP
14:40:57 <maerwald> as I said
14:40:58 <ddellacosta> zenspider: you could do NoImplicitPrelude and then use qualified imports
14:41:07 <EvanR> more like imperative programming
14:41:09 <ddellacosta> iqubic: that's the (a -> b -> b) function for foldr
14:41:13 <maerwald> no, it's definitely OOP
14:41:17 <monochrom> NoImplicitPrelude is a sledgehammer.
14:41:17 <EvanR> NO U
14:41:19 <zenspider> ddellacosta: implying I need to import everything I want rather than reject what I don't?
14:41:20 <maerwald> NOOO
14:41:20 * EvanR leaves
14:41:22 <maerwald> :D
14:41:29 <ddellacosta> zenspider: yeah, whitelist vs. blacklist basically
14:41:57 <zenspider> that doesn't sound good to me... I think I'm siding w/ monochrom
14:41:58 <maerwald> now we don't call it god-object, but god-transformer
14:41:58 <ddellacosta> where, "reject what I don't need" = renaming stuff per your previous comment
14:42:12 <maerwald> look at the web frameworks, they all have a god-transformer ;)
14:42:15 <zenspider> ddellacosta: what do you mean by that last bit?
14:42:21 <ddellacosta> yeah I'm not saying I disagree with monochrom, just throwing that out there
14:42:34 <zenspider> in racket I can do an import w/ renaming, or basically saying "everything except (x, y, z)"
14:42:47 <maerwald> e.g. https://hackage.haskell.org/package/snap-core-1.0.3.1/docs/Snap-Core.html#g:1
14:42:55 <ddellacosta> zenspider: oh, mostly just that you can't really "reject" anything in prelude without the NoImplicitPrelude thing
14:43:05 <iqubic> why is the type of accrete so complex?
14:43:06 <zenspider> ah. gotcha
14:43:15 <ddellacosta> iqubic: because that's how you wrote it :-p
14:43:40 <monochrom> If you merely "import Prelude()", you are still allowed "f x@0 = x" because the inferred type can still be "(Num a, Eq a) => a -> a"
14:43:59 <monochrom> or rather, (Prelude.Num a, Prelude.Eq a) => a -> a
14:44:12 <zenspider> the chapter I'm in hasn't even touched imports yet... so this is all new
14:44:27 <monochrom> If you use NoImplicitPrelude, then even that code is banned, because the compiler is like "where is Eq and Num when I need them?!"
14:44:28 <zenspider> chapter I'm in -> the book so far in the chapter I'm up to
14:44:36 <ddellacosta> iqubic: it may be helpful to re-write it as a -> ((a -> Bool) -> [a]) -> ((a -> Bool) -> [a]) (<- see those last parens)
14:44:58 <monochrom> The use case of NoImplicitPrelude is when you say you want to provide your own Num and Eq!
14:45:27 <monochrom> (And have it used by code of the form "f x@0 = x".)
14:45:45 <iqubic> ddellacosta: That's the a continuation that creates a function of type ((a -> Bool) -> [a])
14:45:58 <zenspider> If I go that route... I'm getting "Not in scope: type constructor or class 'Prelude.Eq'
14:46:17 <monochrom> The more typical example is that do-notation is desuagared to Prelude.>>=, and you use NoImplicitPrelude to force do-notation to desugar to your >>=
14:46:18 <Modius> Under what search terms can I find what the behavior is of GHC to stuff at the top of a source file? All that { } stuff, as well as https://github.com/snoyberg/conduit and the  #!/usr/bin/env stack at the top. . .
14:46:33 <monochrom> There is a monad tutorial that actually uses that feature.
14:46:40 <ddellacosta> iqubic: yeah you take in an 'a' and a ((a -> Bool) -> [a]), and return a ((a -> Bool) -> [a])
14:46:55 <ddellacosta> and so at the very end you pass in the predicate and the whole "stack" finally gets run
14:47:02 <ddellacosta> when you force evaluation I mean
14:47:15 <iqubic> What does the "stack" do?
14:47:32 <ddellacosta> well it's the function your accumulator has built up
14:47:59 <iqubic> And what does it do?
14:48:04 <__monty__> Modius: You'll want to search for pragmas, most commonly language pragmas.
14:48:30 <zenspider> Modius: "#!/usr/bin/env stack" is normal shell stuff. Are you asking about that? (in part?)
14:48:31 <__monty__> Modius: The other thing's called a shebang line and it's a unix thing.
14:49:01 <ddellacosta> iqubic: it filters each value, and appends the next function's result to that, finally returning the filtered list
14:49:10 <monochrom> And you now need to learn stack too. Haha good luck.
14:49:27 <Modius> zenspider: Sort of - while I'll be on windows for now, mostly interested in what ghc-wise tells it to treat stuff at the top outside of the language.
14:49:32 <Modius> Guess the word is 'ghc pragmas'
14:49:52 <aarvar> monochrom: you mean RebindableSyntax?
14:50:01 <aarvar> NoImplicitPrelude just doesn't import the prelude
14:50:02 <zenspider> Modius: https://downloads.haskell.org/~ghc/6.10.2/docs/html/users_guide/pragmas.html is what I've been poking at
14:50:22 <monochrom> This is Java-for-1st-year-students all over again. All those "public class X { public static void main(..." you have to either explain or sweep under the rug.
14:50:26 <zenspider> I'm not sure if that's exhaustive tho
14:50:34 <__monty__> Modius: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas More recent version ; )
14:50:47 <monochrom> aarvar: Oh yeah, I forgot that one.
14:50:53 <coventry> haskeline claims that M-F/B chords are bound to forward/backward word. https://github.com/judah/haskeline/wiki/KeyBindings#emacs-specific-bindings
14:51:13 <coventry> Maybe that's for a later version than I have.
14:51:26 <__monty__> Modius: And the wiki page on shebang should be a good overview.
14:51:39 <zenspider> oops. old version in my url...
14:52:27 <monochrom> Haskell is moving towards the OOP direction, especially the Java direction, because #!/usr/bin/env stack
14:52:45 <zenspider> so... the gist I've gotten so far is either comment out my duplicate instance declarations or use a sledgehammer pragma and import everything I need explictly?
14:53:04 <monochrom> Yeah.
14:53:07 <iqubic> ddellacosta: If I build up a function "stack" when is it called? I don't have id in my code.
14:53:29 <monochrom> Hmm you have a duplication instance declaration? What have you done? :)
14:53:51 <ddellacosta> iqubic: well, so look at the myTakeWhile1 in the last paste I gave you
14:53:56 <monochrom> Oh come on id doesn't call any function either.
14:54:01 <__monty__> monochrom: How is a stack shebang OOP?
14:54:02 <zenspider> monochrom: working through exrcises in Hutton's book
14:54:03 <reactormonk> Can't do HashMap (forall a. Proxy a) Dynamic apparently - other ideas?
14:54:19 <iqubic> ddellacosta: How does that help me?
14:54:20 <Adeon> what kind of scripts do you write as stack shebang?
14:54:23 <Adeon> that's the first time I've seen it
14:54:25 <monochrom> __monty__: To be honest and fair it is not, it is just more Java-ish, as said.
14:54:30 <ddellacosta> iqubic: if you just run that like 'myTakeWhile1 [1..10]' you see it'll return a function
14:54:38 <zenspider> monochrom: eg implement: instance Eq a => Eq (maybe a) where ...
14:54:40 <__monty__> Adeon: A haskell script : )
14:54:41 <ddellacosta> iqubic: that is the output of your foldr
14:54:42 <mud> Adeon: It allows you to just run them as-is. It's quite nice
14:54:51 <ddellacosta> to run it, you pass it a predicate function
14:55:09 <ddellacosta> iqubic: say, myTakeWhile1 [1..10] (< 10)
14:55:12 <mud> You can just set the file as executable and run it, like you do with eg python
14:55:17 <__monty__> Adeon: You can achieve something similar with a nix shebang, though that'll work for a much broader array of languages.
14:55:21 <mud> Which I have no idea what that has to do with java or OOP, seemingly nothing.
14:55:26 <Adeon> I thought runghc was for that
14:55:34 <Adeon> but I guess stack uses the stack ecosystem for stack scripts
14:55:38 <Adeon> yeah sounds nice
14:55:40 <iqubic> so calling it partially produces a function?
14:55:48 <mud> Adeon: Those can't do libraries, and also can't do compilation iiuc
14:56:00 <zenspider> this is too hard to follow... I'll just comment out for now.
14:56:02 <mud> s/libraries/packages/
14:56:09 <__monty__> Adeon: The nix shebang uses runghc explicitly.
14:56:29 <ddellacosta> iqubic: well in fact calling myTakeWhile1 with a single arg is not calling it "partially" as it were, but recall everything in Haskell is a function of a single arity
14:57:03 <ddellacosta> iqubic: the main thing to wrap your head around is that you are building up a *function* with your foldr as opposed to a list or something else. It's just another value.
14:57:10 <__monty__> monochrom: I don't see how a shebang is related to java, I've never used one with java. It's commonly used for shell and other scripting languages.
14:57:21 <ddellacosta> at least, it seems like that's where you're getting stuck--forgive me if I'm offbase there
14:58:10 <monochrom> People use stack scripts because they can specify to download one more copy of GHC behind your back because your existing copy and version can't be trusted.
14:58:33 <aarvar> so use nix instead
14:58:50 <monochrom> __monty__: Did you see it when I said "public class X { public static void main(..."?
14:59:18 <__monty__> monochrom: Nope, missed it.
15:00:16 <monochrom> I'm just teasing stack.
15:00:58 <maerwald> all this stack and nix evangelism...
15:01:08 <jesyspa> Maybe someone should make a dependency management system for Haskell that scans for what dependency management system you have installed and does the right thing for that.
15:01:17 <maerwald> ...
15:01:26 <ddellacosta> do I really have to pull out that xkcd link
15:01:31 <aarvar> no
15:01:32 <texasmynsted> anybody recommend an article or something to help me determine for global installs Stack vs. Cabal?
15:01:33 <maerwald> jesyspa: that's what package managers do ;)
15:01:38 <monochrom> Yeah, see, people are incapable of the Subtraction Method.
15:01:44 <ddellacosta> aarvar: whew
15:01:58 <iqubic> What is the xkcd link?
15:02:04 <aarvar> no
15:02:06 <texasmynsted> I would be fine with nix but it seems I would need stack and cabal also
15:02:07 <ddellacosta> hahaha
15:02:13 <ddellacosta> sorry aarvar, hahaha
15:02:15 <aarvar> texasmynsted: why?
15:02:17 <geekosaur> texasmynsted, for global installs? stack simply doesn't do global. it can give you a public-ish symlink into its private install for deployment, but that's it
15:02:19 <__monty__> iqubic: Search for xkcd standards.
15:02:23 <texasmynsted> why what?
15:02:28 <jesyspa> maerwald: Nonono, this would be a meta-package manager.  Or, rather, a package meta-manager.  It wouldn't actually track what packages you have installed, just what package managers you have installed, and which one is best for installing the package in question.
15:02:34 <texasmynsted> global for one user
15:02:35 <texasmynsted> I mean
15:02:36 <aarvar> why would you need stack?
15:02:40 <geekosaur> and stack depends on having full control over its world, that's how it keeps things from interfering with each other
15:02:44 <texasmynsted> for things like ghcid
15:02:50 <geekosaur> whereas global is kinda by definition interfering with everything
15:02:50 <monochrom> Like the way when I have a problem caused by eating too much, people only try to think of "hmm I know a thing you can eat to solve that".
15:02:53 <aarvar> that works with any ghci
15:03:02 <maerwald> jesyspa: a package manager unifies build tools and dependency management across tools, languages, ecosystems, ...
15:03:11 <aarvar> you would still want to use cabal though
15:03:15 <geekosaur> maerwald, yup, and then you get arch
15:03:19 <aarvar> just not to manage dependencies
15:03:29 <texasmynsted> sigh
15:03:40 <geekosaur> packagemannagers manage *their* world. which isn;t necessarily the world you want or need
15:03:50 <texasmynsted> so I have multiple machines. One uses stack globally, and one cabal.
15:03:57 <texasmynsted> Cabal seems fine
15:04:20 <texasmynsted> the base install was from Haskell platform
15:06:03 <texasmynsted> the machine setup from statck I am considering finding a way to remove haskell (and stack) then re-install haskell platform so it can match the the other machine and be up-to-date
15:06:49 <__monty__> texasmynsted: The platform isn't necessarily more up to date than stack though.
15:07:11 <mud> texasmynsted: What is haskell platform actually doing for you there? I've yet to see the point of it. Just install either stack or GHC and cabal-install
15:07:25 <texasmynsted> It gets pretty tiresome "maintaining" these.  Kind of wish there was a way to run all my haskell from some docker config or something
15:08:02 <texasmynsted> Doesn't it install GHC?
15:08:13 <texasmynsted> hmm
15:08:20 <maerwald> no, you should use a virtual machine, have docker inside, and use stack from within nix
15:08:41 <monochrom> I haven't started, but rsync is my next scheme for building a package on a fast computer and then copying them to a couple of other slower computers.
15:08:43 <mud> texasmynsted: HP? Probably, but GHC isn't that hard to install yourself. That's what I used to do with cabal-install.
15:08:49 <texasmynsted> HP?'
15:08:56 <geekosaur> haskell platform
15:08:57 <mud> I got tired of typing it out.
15:09:01 <texasmynsted> oh
15:09:16 <mud> And stack there's like one thing to maintain, 'stack upgrade' every once in a while
15:09:26 <monochrom> hahahaha maerwald
15:09:29 <geekosaur> which is …. if you just want a simple fixed base, it's got its uses. but the haskell ecosystem changes far too quickly for a batteries-included platform to keep up
15:09:30 <texasmynsted> So maybe 1. install ghc, 2. install cabal-install
15:09:41 <monochrom> @remember maerwald no, you should use a virtual machine, have docker inside, and use stack from within nix
15:09:41 <lambdabot> It is forever etched in my memory.
15:09:44 <geekosaur> it's like you bought a cellphoen battery but it needs to be recharged 16 times a day
15:09:48 <texasmynsted> 3. install everything else with cabal-install
15:10:08 <mud> texasmynsted: Yes, that would be my recommendation if you like cabal-install
15:10:11 <sclv> mud: that's all the haskell platform is
15:10:14 <sclv> in core
15:10:21 <sclv> it installs GHC, cabal-install, and stack
15:10:25 <sclv> in locations that make sense for your OS
15:10:45 <maerwald> actually, you could use cabal-install via stack exec, no?
15:10:51 <texasmynsted> At this point I am a little less impressed with stack, so cabal-install is fine with me
15:10:57 <sclv> so it just bundles up a standard collection of compatible modern editions of basic tools
15:11:09 <sclv> and per-OS puts them in the idiomatic place for that OS
15:11:13 <sclv> using an idiomatic installer
15:11:16 <texasmynsted> hm
15:11:31 <mud> sclv: I'm not seeing much benefit then ... especially if you're going to do stack, it's already easy to install, and then won't lag behind waiting for HP to update.
15:11:48 <sclv> stack typically doesn't lag in HP these days
15:11:54 <sclv> since stack doesn't release much more frequently than ghc
15:12:01 <texasmynsted> The problem with haskell platform is that I do not see how to upgrade GHC
15:12:04 <sclv> if you _only_ use stack, then it manages other stuff for you
15:12:09 <sclv> texasmynsted: just install a new platform
15:12:09 <texasmynsted> I guess with cabal-instal?
15:12:15 <sclv> to get a new ghc
15:12:20 <geekosaur> cabal-install can;t install ghc
15:12:26 <sclv> the platform will put different ghc versions in different locations
15:12:26 <texasmynsted> ok
15:12:30 <sclv> and let you switch between them
15:12:35 <geekosaur> all you can do is install a new platform, or install ghc separately in which case what benefit?
15:12:40 <texasmynsted> so get the HP w/o all the dependencies?
15:12:45 <geekosaur> pretty much
15:12:56 <sclv> (the tool to switch between them is activate-hs)
15:13:02 <texasmynsted> If I install "over" what I have now, will it break anything?
15:13:11 <sclv> the benefit of the platform is it installs ghc, cabal and stack all together
15:13:31 <__monty__> monochrom: You could easily get remote builds with nix.
15:13:32 <sclv> and it manages the ghc install paths so they automatically keep different versions in different locations
15:13:36 <ddellacosta> sclv: is that something I can install independently of the platform? activate-hs
15:13:36 <sclv> and activate-hs switches between them
15:13:41 <sclv> ddellacosta: not really
15:13:47 <ddellacosta> sclv: gotcha, okay
15:13:51 <texasmynsted> I just want it to be easy because in 6 months I am not going to recall how I installed any of it
15:13:54 <sclv> its just a shell script that manages aliases with idiomatic platform locations
15:13:58 <geekosaur> if you wnt to switch between ghc versions minus the platform, take a look at hvr's setup for travis
15:14:03 <monochrom> I don't want to learn nix, I just want to learn rsync.
15:14:18 <monochrom> My case is that my package versions are extremely static.
15:14:20 <geekosaur> also I have a perl script that wraps hvr gcc installs so I can select easily by e.g. envars
15:14:42 <sclv> (note that the platform does _not_ manage multiple ghcs on widows, because windows is awful)
15:14:51 <texasmynsted> Is nix an alternative to stack and or cabal-install?
15:14:56 <sclv> texasmynsted: no
15:15:13 <sclv> its is a complementary way to manage package environments for haskell projects
15:15:17 <fsestini> gnu stow is pretty good to switch btw ghc installs also
15:15:18 <texasmynsted> I thought it was a package manager, (and an os in the case of Nix-os)
15:15:18 <sclv> but you still need to actually build
15:15:19 <mud> texasmynsted: Mostly an alternative to stack, not an alternative to cabal-install
15:15:40 <sclv> and idiomatically you then either run stack or cabal-install _within_ a configured nix-shell
15:15:42 <maerwald> nix is not haskell specific
15:15:50 <maerwald> that is not comparable with stack in any way
15:16:15 <monochrom> Hey, conditional probability!
15:16:21 <sclv> nix is when you want to manage a fully reproducable build-process, including foreign libs and all imho
15:16:40 <monochrom> Pr(A) and Pr(B) may be incomparable, but Pr(A | Haskell) and Pr(B | Haskell) may be comparable.
15:16:41 <sclv> part of that means that it also takes charge of managing haskell dependencies
15:16:52 <texasmynsted> nix sounds useful for CI/CD
15:16:55 <sclv> however it doesn't replace the actual building
15:17:05 <haskell_noob1> question about ghci: how do i do only a screen ful when ``` :browse ```?
15:17:06 <monochrom> But anyway you said it,
15:17:08 <maerwald> funny thing is, no one uses nix in devops
15:17:12 <monochrom> @quote maerwald docker
15:17:12 <lambdabot> maerwald says: no, you should use a virtual machine, have docker inside, and use stack from within nix
15:17:18 <monochrom> (hehe)
15:17:27 <sclv> maerwald: no, plenty of haskell shops that have standardized on nix do!
15:17:41 <sclv> (i guess its still rare in the broader devops world)
15:17:54 <monochrom> Cale uses nix. What's devop and why is Cale not one?
15:17:54 <maerwald> kubernetes bro and all that crap that comes with it
15:17:55 <texasmynsted> why docker in a vm?
15:18:12 <__monty__> maerwald: IOHK uses nixops.
15:18:15 <monochrom> texasmynsted: I think it's a joke :)
15:18:15 <maerwald> texasmynsted: because that was actually the way people used it for a long time (especially in windows)
15:18:38 <sclv> haskell_noob1: there's no native paging built into ghci
15:18:45 <maerwald> monochrom: half-joke
15:18:53 <texasmynsted> heh
15:18:54 <sclv> this old question suggests using something like `tmux` or `screen` for generic pager facilities: https://www.reddit.com/r/haskell/comments/2y2f1p/pager_in_ghci_like_less/
15:19:08 <geekosaur> texasmynsted, because docker can do things a vm can't, and until docker learned how to use a vm instead of linux cgroups the only way to use it on windows was in a linux vm
15:19:11 <monochrom> Well yeah all good jokes are based on cruel reailty on steroid.
15:19:13 <coventry> There are security benefits to running docker in a vm.
15:19:22 <haskell_noob1> sclv i thought i missed that part of the ghci..its a bit lame. Seems to be a basic functionality?
15:19:29 <geekosaur> (well, vms can but it's painful to set up)
15:19:34 <maerwald> coventry: docker...security... in one sentence, really?
15:19:36 <sclv> haskell_noob1: it would be nice to have imho
15:19:47 <haskell_noob1> so how do you work around it : sclv?
15:19:54 <sclv> i don't work around it
15:19:54 <monochrom> Oh w00t vms.
15:19:56 <sclv> i dont' mind
15:20:00 <geekosaur> I think there's a ghci page on the wiki that shows how to wrap internal commands in e.g. a pager?
15:20:03 <sclv> i just scroll back in my terminal :-)
15:20:14 <geekosaur> which basically runs something like :browse into a file and then runs the pager on that
15:20:23 <coventry> maerwald: Well, it's mainly true because docker containers provide relatively weak security. :-)
15:20:23 <haskell_noob1> i am browsing the kubernetes library, and it has a ton of generated swagger code..its just hard to scroll that back.
15:20:38 <awesomeaniruddh> http://www.cis.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
15:20:51 <texasmynsted> tmux :-)
15:20:53 <maerwald> coventry: yes... and by increasing the TCB people think they increase security
15:20:55 <awesomeaniruddh> I'm not sure how to optimize the second function in the first problem on there ^
15:20:56 <maerwald> which is funny
15:20:56 <haskell_noob1> i was this close to getting back to tmux :).
15:20:58 <maerwald> but a fallacy
15:21:10 <haskell_noob1> ok, tmux it is.
15:21:37 <monochrom> Haha it's sad how many problems and lack of things are solved by moar wrapping.
15:21:57 <monochrom> I guess that's composability.
15:22:01 <texasmynsted> . . . adding another layer of abstraction
15:22:26 <maerwald> that's actually just a more fancy version of obfuscation...
15:22:34 <sclv> hm, i don't see an enhancmeent request for a ghci pager on the ghc trac
15:22:44 <sclv> if anyone wants to file one, it would be a fine ticket
15:22:57 <maerwald> "look, our system is so complex we don't know what actions it may perform, so we add a more complex system around it, so the attacker might be as confused as we are"
15:24:50 <texasmynsted> or add a layer of abstraction so one can deal only with the problem at hand, ignoring all the things that are _not_ the problem at hand
15:24:59 <awesomeaniruddh> Uhn, help please?
15:25:00 <awesomeaniruddh> Uhm*
15:25:54 <haskell_noob1> sclv do i have to login to create trac ticket and this is not really a bug, i couldnt see a link where i could make this enhancement request.
15:26:25 <haskell_noob1> or can lambdabot just parse the words and create one for us :)?
15:26:28 <sclv> yes you need to login to create tickets, and tickets can be enhancement requests as well as bugs
15:26:47 <haskell_noob1> let me do that. thanks.
15:28:33 <ddellacosta> awesomeaniruddh: by optimize, do you mean to rewrite per the exercise instructions?
15:29:09 <awesomeaniruddh> ddellacosta: yes
15:29:36 <ddellacosta> awesomeaniruddh: so you were able to figure out the first one, just having trouble with the second one (fun2)?
15:29:46 <awesomeaniruddh> yes
15:30:10 <haskell_noob1> no priveleges..guess rookie status.
15:30:23 <ddellacosta> awesomeaniruddh: so can you talk about where you are feeling stuck on that one?
15:30:39 <awesomeaniruddh> I don't know where to even start :/
15:30:51 <awesomeaniruddh> I considered doing a fold on [1..x]
15:31:02 <Lears> Read the hint.
15:31:04 <awesomeaniruddh> but I'm not sure how to make that work without using if statemetns
15:31:18 <awesomeaniruddh> I did and did not find it to be very helpful
15:37:34 <haskell_noob1> how do i setup hoogle data for my project in stack?
15:42:14 <maerwald> looks like foldr
15:42:22 <maerwald> I don't know what he means with takeWhile and iterate either
15:42:40 <haskell_noob1> i guess it is "stack hoogle"
15:42:40 <maerwald> at least for fun1
15:43:04 <awesomeaniruddh> maerwald: yes, my solution to fun1 was a filter composed with foldr
15:49:29 <maerwald> ah
15:49:44 <maerwald> it's easy
15:49:58 <maerwald> I would even suggest to use if-then-else
15:51:24 <maerwald> awesomeaniruddh: you first have to express the two operations (depending on even or not) with an initial value
15:51:37 <maerwald> that's exactly what iterate gives you
15:52:10 <maerwald> with "two operations" I mean the recursions only, not the "adding up numbers"
15:52:21 <maerwald> and from there you compose with other stuff
15:52:40 <awesomeaniruddh> I'm confused :(
15:53:02 <maerwald> I find the functions from the exercise cleaner than the "idiomatic" ones
15:53:20 <maerwald> he just wants you to do a lot of composition and implicit recursion
15:54:10 <maerwald> awesomeaniruddh: "fun2 (n `div` 2)" and "fun2 (3 * n + 1)"
15:56:08 <maerwald> maybe play with 'iterate' a bit to see what it does
15:57:16 <maerwald> iterate (\x -> if even x then ??? else ???)
15:59:27 <maerwald> but that's really not idiomatic at all
15:59:32 <awesomeaniruddh> maerwald: I was hoping to avoid if-then statements
15:59:46 <maerwald> you can avoid them later
16:10:37 <dminuoso> @let data V3 a = V3 a' a' a'
16:10:38 <lambdabot>  .L.hs:158:16: error:
16:10:38 <lambdabot>      Not in scope: type variable ‘a'’
16:10:38 <lambdabot>      Perhaps you meant ‘a’ (line 158)
16:10:42 <dminuoso> @let data V3 a' = V3 a' a' a'
16:10:43 <lambdabot>  Defined.
16:11:07 <dminuoso> @let traverseX f (V3 a b c) = (\c' -> V3 a b 'c) <$> (f c)
16:11:07 <lambdabot>  .L.hs:161:42: error:
16:11:08 <lambdabot>      • Syntax error on 'c
16:11:08 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
16:11:23 <dminuoso> @let traverseX f (V3 a b c) = (\c' -> V3 a b c') <$> (f c)
16:11:24 <lambdabot>  Defined.
16:11:35 <dminuoso> @let traverseY f (V3 a b c) = (\b' -> V3 a b' c) <$> (f c)
16:11:36 <lambdabot>  Defined.
16:12:17 <ddellacosta> oh jeez so it's as simple as `view f v3 = f Const v3` where f = a traverse function
16:12:47 <ddellacosta> or rather, `view f v3 = getConst $ f Const v3
16:12:52 <ddellacosta> er, close `
16:13:07 <maerwald> awesomeaniruddh: did you get it?
16:13:07 <ddellacosta> wow neat
16:14:00 <coventry> Is there any emacs support for showing the current location in another buffer, when stepping through code with the debugger (`:step`, and so on)?
16:14:06 <dminuoso> ddellacosta: Yes. And that is pretty much the definition of `view` in the lens package:
16:14:07 <ddellacosta> @let view' f v3 = getConst $ f Const v3
16:14:09 <lambdabot>  Defined.
16:14:13 <dminuoso> ddellacosta: view l = Reader.asks (getConst #. l Const)
16:14:19 <ddellacosta> > view' traverseX (V3 1 2 3)
16:14:21 <lambdabot>  3
16:14:25 <ddellacosta> nifty
16:14:33 <ddellacosta> wow, awesome...thanks dminuoso!
16:14:41 <dminuoso> ddellacosta: now you can have a nested `V3`, then you can compose them with function composition
16:14:49 <dminuoso> it should become also obvious why lenses appear to compose in reverse
16:15:12 <dminuoso> ddellacosta: next up, write a function `over` that takes an update function, and wraps it with `Identity` to update rather than view the substructure
16:15:23 <ddellacosta> okay wow, I have to think about that bit, composition I mean
16:15:56 <ddellacosta> dminuoso: okay, cheating a bit as I've been reading that derivations page off and on this past week, but
16:16:41 <dminuoso> ddellacosta: figure out how `over` must work (in case you havent cheated)
16:18:50 <ddellacosta> @let over' f update v3 = runIdentity $ (f (Identity . update) v3)
16:18:51 <lambdabot>  Defined.
16:18:59 <ddellacosta> > over' traverseX' (+1) (V3 1 2 3)
16:19:01 <lambdabot>  error:
16:19:01 <lambdabot>      • Variable not in scope:
16:19:01 <lambdabot>          traverseX'
16:19:08 <ddellacosta> > over' traverseX (+1) (V3 1 2 3)
16:19:10 <lambdabot>  error:
16:19:10 <lambdabot>      • No instance for (Show (V3 Integer))
16:19:10 <lambdabot>          arising from a use of ‘show_M11405170332399880214080’
16:19:16 <ddellacosta> whoops
16:19:19 <dminuoso> ddellacosta: all good
16:19:27 <dminuoso> @let data V3 a = V3 a' a' a' deriving (Eq, Show)
16:19:28 <lambdabot>  .L.hs:160:1: error:
16:19:28 <lambdabot>      Multiple declarations of ‘V3’
16:19:28 <lambdabot>      Declared at: .L.hs:158:1
16:19:40 <ddellacosta> well that's annoying, it won't let us overwrite?
16:20:02 <dminuoso> @let deriving instance Show V3
16:20:02 <lambdabot>  .L.hs:160:24: error:
16:20:03 <lambdabot>      • Expecting one more argument to ‘V3’
16:20:03 <lambdabot>        Expected a type, but ‘V3’ has kind ‘* -> *’
16:20:07 <dminuoso> @let deriving instance Show (V3 a)
16:20:08 <lambdabot>  .L.hs:160:1: error:
16:20:08 <lambdabot>      • No instance for (Show a) arising from a use of ‘showsPrec’
16:20:08 <lambdabot>        Possible fix:
16:20:19 <ddellacosta> haha
16:20:28 <ddellacosta> well it works for me in GHCI
16:20:32 <dminuoso> @let deriving instance (Show a) => Show (V3 a)
16:20:33 <lambdabot>  Defined.
16:20:37 <ddellacosta> okay
16:20:40 <ddellacosta> > over' traverseX (+1) (V3 1 2 3)
16:20:42 <lambdabot>  V3 1 2 4
16:20:49 <ddellacosta> oh hmm why is X at the end
16:21:13 <ddellacosta> oh guess that's how it was defined above
16:21:15 <dminuoso> Heh yeah
16:21:18 <ddellacosta> in any case, this is pretty slick
16:21:33 <dminuoso> ddellacosta: And that is also how lens defines `over` by the way ;-)
16:21:41 <ddellacosta> I now can trace this through logically, although I'm not yet getting all the nuances by a long stretch
16:21:44 <dminuoso> ddellacosta: you could then trivially write `set` in terms of `over` or directly
16:22:13 <ddellacosta> dminuoso: gotcha, yeah I did cheat a small amount by the fact that I had read that derivations wiki page, although it was still a revelation to see how you got me to that using Const/Identity point
16:22:18 <ddellacosta> to define view and over
16:22:21 <ddellacosta> pretty awesome
16:22:57 <dminuoso> ddellacosta: the pretty cool thing is also how they compose. It's essentially for the same reason that `fmap . fmap` works
16:23:01 <dminuoso> ddellacosta: or `traverse . traverse`
16:23:36 <dminuoso> If you manually expand the evaluation for one usage it might become clear
16:23:56 <ddellacosta> > over' (traverseY.traverseY) (+1) (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9))
16:23:58 <lambdabot>  V3 (V3 1 2 3) (V3 7 10 9) (V3 7 8 9)
16:24:15 <dminuoso> well try to pick two different lenses
16:24:18 <dminuoso> ;)
16:24:36 <ddellacosta> ha, sorry just trying to wrap my head around how composition works
16:25:14 <dminuoso> Let me fix the definitions real quick
16:25:48 <ddellacosta> actually I'm pretty surprised at what just happened there...definitely something I'm not understanding
16:26:40 <dminuoso> @let over' f update v3 = runIdentity $ (f (Identity . update) v3)
16:26:41 <lambdabot>  Defined.
16:26:54 <dminuoso> or actually you can just use the lens view they will work too
16:27:12 <dminuoso> > (V3 1 2 3) ^. (traverseX)
16:27:15 <lambdabot>  3
16:27:25 <dminuoso> @undef
16:27:25 <lambdabot> Undefined.
16:27:35 <dminuoso> @let data V3 a' = V3 a' a' a' deriving (Show, Eq)
16:27:36 <lambdabot>  Defined.
16:27:38 <ddellacosta> oh wow I didn't realize they were _that_ general that what we just defined could work using the lens operators
16:27:52 * ddellacosta 's mind is blown
16:27:54 <dminuoso> @let traverseX f (V3 a b c) = (\a' -> V3 a' b c) <$> (f c)
16:27:55 <lambdabot>  Defined.
16:28:01 <dminuoso> @let traverseY f (V3 a b c) = (\b' -> V3 a b' c) <$> (f c)
16:28:02 <lambdabot>  Defined.
16:28:06 <dminuoso> @let traverseZ f (V3 a b c) = (\b' -> V3 a b c') <$> (f c)
16:28:07 <lambdabot>  .L.hs:164:42: error:
16:28:08 <lambdabot>      • Variable not in scope: c'
16:28:08 <lambdabot>      • Perhaps you meant one of these:
16:28:11 <dminuoso> @let traverseZ f (V3 a b c) = (\c' -> V3 a b c') <$> (f c)
16:28:12 <lambdabot>  Defined.
16:28:27 <ddellacosta> (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9)) ^. traverseX.traverseY
16:28:30 <ddellacosta> whoops
16:28:32 <ddellacosta> > (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9)) ^. traverseX.traverseY
16:28:34 <lambdabot>  9
16:28:53 <dminuoso> oh haha second
16:28:55 <dminuoso> @undef
16:28:55 <lambdabot> Undefined.
16:28:55 <ddellacosta> hmm, not what I expected
16:29:05 <dminuoso> @let data V3 a' = V3 a' a' a' deriving (Show, Eq)
16:29:06 <lambdabot>  Defined.
16:29:08 <dminuoso> @let traverseX f (V3 a b c) = (\a' -> V3 a' b c) <$> (f a)
16:29:09 <lambdabot>  Defined.
16:29:16 <dminuoso> @let traverseY f (V3 a b c) = (\b' -> V3 a b' c) <$> (f b)
16:29:17 <lambdabot>  Defined.
16:29:27 <dminuoso> @let traverseZ f (V3 a b c) = (\c' -> V3 a b c') <$> (f c)
16:29:29 <lambdabot>  Defined.
16:29:31 <dminuoso> ddellacosta: Try now.
16:29:35 <ddellacosta> > (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9)) ^. traverseX.traverseY
16:29:37 <lambdabot>  2
16:29:42 <jackhill> msg Tribot callsign W5lln
16:29:45 <ddellacosta> right! sweet
16:30:07 <dminuoso> ddellacosta: basically it first traverses over the more general structure. This makes sense because overall its a (partial) traversal over the larger thing.
16:30:23 <dminuoso> :t traverseX
16:30:24 <lambdabot> Functor f => (t -> f t) -> V3 t -> f (V3 t)
16:30:49 <dminuoso> ddellacosta: so foremost it must be the more general/larger lens on the left hand side
16:32:01 <dminuoso> ddellacosta: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
16:32:06 <aarvar> that's quite a strange use of "more general"
16:33:19 <dminuoso> okay maybe "larger" would be the more correct term
16:33:23 <ddellacosta> the "larger" part makes it click for me
16:33:30 <ddellacosta> yeah, I got it in any case
16:34:14 <dminuoso> ddellacosta: now a simple lens is one where `a ~ b` and `s ~ t`
16:34:14 <aarvar> na, larger is also wrong
16:34:50 <ddellacosta> aarvar: what would the right term be?
16:35:03 <dminuoso> aarvar: from the perspective that you have a nested V3, it first traverses around the "outer" V3, which you could say is larger
16:35:17 <ddellacosta> dminuoso: I think the thing I'm stuck on is why they compose in that order, I have to go back and trace it through again I think
16:35:58 <dminuoso> aarvar: maybe you can help ddellacosta understand it better then
16:36:59 <ddellacosta> I gotta step away for a bit anyways. dminuoso, thanks so much for getting me this far--I'm way closer to understanding lens than I was before
16:38:05 <ddellacosta> I'll probably ping you for help again once this has had a bit of time to settle in and make more sense
16:40:51 <dminuoso> ddellacosta: remember that `over` simply applies the lens to a (Identity wrapped) update function and the data structure
16:41:03 <dminuoso> ddellacosta: and think about what `traverseX` does.
16:42:43 <dminuoso> :t traverseX (Identity . (+1))
16:42:44 <lambdabot> Num t => V3 t -> Identity (V3 t)
16:42:56 <dminuoso> ddellacosta: ^- see how that function _itself_ is a valid traversal functoin?
16:43:08 <dminuoso> :t traverseX
16:43:09 <lambdabot> Functor f => (t -> f t) -> V3 t -> f (V3 t)
16:43:17 <dminuoso> ddellacosta: it fits nicely into (t -> f t)
16:45:16 <dminuoso> > traverseX (traverseY (Identity . (+1))) (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9))
16:45:18 <lambdabot>  Identity (V3 (V3 1 3 3) (V3 4 5 6) (V3 7 8 9))
16:45:26 <dminuoso> and by law of composition:
16:45:38 <dminuoso> > (traverseX . traverseY) (Identity . (+1)) (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9))
16:45:40 <lambdabot>  Identity (V3 (V3 1 3 3) (V3 4 5 6) (V3 7 8 9))
16:46:32 <xpika> is there a word for a value that is specifically not a function? like As in Char but not (a -> Char) ?
16:47:26 <hpc> data?
16:48:05 <xpika> can’t data as be data Pred = Pred (a -> Char) ?
16:49:31 <dminuoso> xpika: What do you need the term for?
16:49:50 <xpika> I’m thinking of a language extension
16:50:21 <xpika> where you have a function like identity, which can’t accept a function as an argument
16:51:53 <xpika> like a stricter version of identity
16:52:08 <dminuoso> Curious. Why would this be useful?
16:52:11 <xpika> specialised
16:52:22 <xpika> type safety
16:55:36 <dminuoso> xpika: what's the use case?
16:55:50 <dminuoso> What value do you gain from not considering functions as data?
17:02:32 <infinisil> Whoa, I may have just created a type that's a Monad, which I haven't seen anywhere else
17:02:43 <infinisil> And it's what I need
17:05:54 <xpika> dminuoso: if I saw something like
17:05:57 <xpika> >  (negate&&&id) pi
17:06:00 <lambdabot>  (-3.141592653589793,3.141592653589793)
17:06:12 <jesyspa> infinisil: Oh cool, what does it do?
17:06:17 <xpika> I wouldn’t think pi is some kind of function
17:10:17 <infinisil> jesyspa: Like a computation that's not done yet because it needs some computation result later, so it provides a way to continue the execution upon providing the result. But the result itself can also be another such unfinished computation
17:10:28 <coventry`> Is it still true that the ghci debugger is "drastically useless"? https://github.com/haskell/haskell-mode/issues/399#issuecomment-70408159 "
17:10:41 <infinisil> s/result later/result/
17:10:58 <infinisil> Wait
17:11:13 <jesyspa> infinisil: So `data M a = K (M a) (a -> M b)`
17:11:14 <infinisil> No I'm confusing things
17:11:26 <infinisil> Something like
17:12:42 <dminuoso> xpika: Can you elaborate on what "type safety" means for you?
17:12:43 <jesyspa> Actually, this sounds a lot like the free monad of an interaction structure.
17:13:12 <infinisil> jesyspa: data Result a b r = Final r | Comp (a, b -> Result a b r)
17:13:41 <hpc> yeah that's definitely a free monad
17:14:09 <hpc> infinisil: check out https://hackage.haskell.org/package/free sometime
17:14:15 <infinisil> I simplified it a bit
17:14:29 <infinisil> My type also provides a way to choose between multiple computations
17:14:36 <jesyspa> The result is a bit different than what I'm used to, since the a is lifted out of the result, but yeah.
17:14:43 <jesyspa> Still a free monad, I'd say.
17:15:19 <infinisil> Hmm nice, I'll have to check out free monads (again, I did read about them but forgot everything previously)
17:15:24 <jesyspa> Ah, no, the a being lifted out is fine, it's the command part, while b is the response part.
17:15:52 <infinisil> What I'm using this for is
17:16:52 <infinisil> To create sorting algorithms that provide a way to choose which comparison you're gonna do next
17:17:53 <infinisil> E.g. with the merge part of merge sort, you can always either merge the lowest elements, or the largest elements, meaning possible comparisons
17:18:06 <infinisil> meaning 2 possible comparisons*
17:18:40 <jakov> Hello ! I am currently learning the list monad, from LYAHFGG, doing the 'knights quest'. I have solved the problem, but i find my code quite ugly:  https://gist.github.com/JackTheEngineer/e34ccd73d8dccd93c3d6313245256f9d   How is it done in haskell, that the states of the variables are saved inbetween calculations ?
17:19:52 <jakov> in that case p1, p2, p3.  and how to write the code to make it for paths of variable lenghts ?
17:19:53 <jesyspa> infinisil: Could you show a code example?
17:20:01 <jakov> it's in the link
17:20:16 <infinisil> jesyspa: Um, I can, but it's not done, I'm wildly experimenting
17:20:52 <jesyspa> That's fine, I've just been working on something that also uses this kind of free monad and it's cool to see I'm not the only one ^^
17:21:39 <atchoum> knight quest is about finding all the possible positions on a chess board ?
17:21:45 <atchoum> (for a knight obviously)
17:22:30 <jakov> yes. THen there is the challenge to return the path(s) to a given position
17:22:34 <infinisil> jesyspa: Um alright, but be warned, it's Haskell-gore
17:23:38 <infinisil> jesyspa: https://gist.github.com/Infinisil/6990951ed610c134f8d795411678eb54
17:23:59 <infinisil> The cmerge' there implements the merge part i described
17:24:15 <jesyspa> Ooh, double negation, interesting.
17:24:39 <atchoum> mmh jakov I think that you assume that such a path is existing for every position on the board.
17:24:56 <infinisil> The csort' there doesn't currently work, because I currently stopped at implementing flatten which would be join when it's a monad
17:25:53 <jakov> @atchoum: Exactly. If it doesn't it returns the empty list
17:25:54 <lambdabot> Unknown command, try @list
17:26:02 <atchoum> jakov: I typically think about an iterative procedure but in Haskell I don't know.
17:26:19 <atchoum> jakov: I think that you can actually reach all positions with the knight.
17:26:46 <jesyspa> Wait, I'm looking at it all wrong, never mind me.  And I guess it wouldn't be 100% trivial to express as a free monad.  But hm.
17:26:54 <jesyspa> Feels like it should be possible.
17:26:59 <atchoum> so basically the problem would be to explore all 4 possible move, then explore the 4*4 all possible moves, and then...
17:27:21 <atchoum> so 4**n evaluations where n is the length of the path.
17:28:08 <atchoum> and you would have to use recursion to solve it and keeping track of the path along the way.
17:28:16 <jakov> yeah. That's exactly what the list monad is good for.
17:28:17 <atchoum> have you a link to the assignment ?
17:28:23 <infinisil> jesyspa: I'll just take a look at some free tutorials
17:28:40 <infinisil> Thanks for the info on that :)
17:28:44 <atchoum> jakov: I would be intersted by looking at how you solve it with the list monad.
17:29:01 <jesyspa> infinisil: I have this feeling that C could be expressed as `C (Int -> Int) (a -> a -> Ordering)`.
17:29:24 <jesyspa> Err, with some extra detail that I'm currently missing.
17:29:43 <jakov> It's in the book: Learn you a haskell for great good, Chapter 12, 'The list monad'. http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad
17:29:50 <jesyspa> No, sorry: `C ((Int -> Int) -> (a -> a -> Ordering) -> C a s)`
17:29:59 <infinisil> jesyspa: Then the comparison function is there, which is not the case with my implementation
17:30:08 * infinisil looks
17:30:26 <atchoum> jakov: but he gives the solution ?
17:30:45 <atchoum> mmh no forget it
17:31:18 <infinisil> jesyspa: My first Int there is the number of choices you have
17:31:33 <atchoum> jakov: you are typically encountering the kind of problem I find it hard  to deal with in Haskell compared to iterative solutions where I can visually see what I would have to write in an imperative language.
17:31:42 <infinisil> jesyspa: Hmm I guess I could just make it an array then, would be simpler
17:31:51 <atchoum> Being able to do the same in Haskell would be really great for me.
17:32:16 <infinisil> I thought using this Int, Int -> combo would guarantee that you only use one choice, but this doesn't work
17:32:17 <atchoum> I think that you can recursively write the thing with filter and map and takeWhile
17:32:35 <infinisil> You can still call the function with all other integers
17:32:45 <jesyspa> infinisil: I'm not sure what presentation is best, just feels like some kind of transformation like this may make it neater.  I was about to say, C Int (Int -> (a -> a -> Ordering) -> C a s) looks promising to me.
17:33:05 <jesyspa> Hmm, are you sure you're not trying to encode something that needs dependent types?
17:33:15 <atchoum> jakov: that's a typical path finding algorithm in any case. They are hard to do in Haskell.
17:33:38 <infinisil> jesyspa: Eh no, I just realized it doesn't matter, I can just use an array
17:33:41 <pikajude> using the cabal.project syntax, how do I enable documentation for all packages?
17:33:56 <jesyspa> Ah, okay.  I'm not sure how that looks.
17:34:40 <infinisil> jesyspa: C [(a, a, Ordering -> C a s)]
17:35:02 <infinisil> Yeah but the (a -> a -> Ordering) is nicer
17:35:14 <jesyspa> Oh, in that sense.
17:35:22 <infinisil> C [((a -> a -> Ordering) -> C a s)]
17:35:43 <jesyspa> Yeah, cool ^^
17:35:44 <infinisil> Oh but
17:36:02 <jcarpenter2> is the implementation of <*> for Applicative [] required to iterate over either the list of functions, or the list of values, first, or can it do in either order?
17:36:44 <infinisil> jesyspa: I made it like (a, a, Ordering -> ..) so that I'm free to do stuff in the IO monad or wherever I want. That wouldn't work with (a -> a -> Ordering)
17:37:18 <infinisil> So it should be C [((a -> a -> m Ordering) -> C a m s)] rather
17:37:24 <jcarpenter2> i'm not sure if any of the applicative laws force it to be either one way or the other - i can maybe write a test program and check
17:37:34 <jakov> @atchoum. It doesn't seem to be too hard for a fixed depth: https://gist.github.com/JackTheEngineer/e34ccd73d8dccd93c3d6313245256f9d  . I would like to know, if someone had the same problem before, returning the list of function parameters to monadic functions.
17:37:34 <lambdabot> Unknown command, try @list
17:37:57 <jcarpenter2> i.e. should it be "function major" or "value major"
17:38:14 <jcarpenter2> or does it not matter
17:41:23 <atchoum> jakov, yeah for a fixed depth, but that's not elegant imho. This is actually far from satisfying. If your algo would perform at a fixed depth, then this depth must be a parameter of the algo, not hardcoded in your function. So your problem remains though: how to generically find the path from (a) to (b) for a knight on a chess board.
17:42:10 <aarvar> jcarpenter2: what's meant by "iterate first"
17:42:11 <atchoum> one could ask, for example, is there a way to arbitrarily chain (n monadic) operations like the one you did with a final `guard` at the end.
17:42:23 <atchoum> I am sure there is.
17:42:30 <atchoum> :t foldM
17:42:31 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
17:42:31 <glguy> atchoum: just iterate the step function until you reach your destination
17:43:39 <atchoum> :t repeatM_
17:43:40 <lambdabot> error:
17:43:40 <lambdabot>     • Variable not in scope: repeatM_
17:43:40 <lambdabot>     • Perhaps you meant one of these:
17:43:44 <atchoum> ok
17:44:30 <jcarpenter2> [\x -> (x, 3), \x -> (x, 4)] <*> [1, 2] returns [(1, 3), (2, 3), (1, 4), (2, 4)]
17:44:39 <glguy> atchoum: I haven't been reading the whole chat, is the question just how to find a path from one location on the chess board to another location using a Knight?
17:44:45 <jcarpenter2> aarvar: does it have to do that, or could it instead return [(1, 3), (1, 4), (2, 3), (2, 4)]?
17:45:03 <jesyspa> infinisil: Sorry, I have to go now, I'll take a look later ^^
17:45:07 <aarvar> jcarpenter2: you mean, would the latter be a valid applicative?
17:45:08 <atchoum> glguy: look at the link https://gist.github.com/JackTheEngineer/e34ccd73d8dccd93c3d6313245256f9d
17:45:10 <jcarpenter2> yes
17:45:31 <atchoum> and try for a better solution :)
17:45:56 <atchoum> objviously there is code duplication going there. And the problem is http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad
17:46:04 <aarvar> jcarpenter2: yes, for every applicative there's also a "reverse" applicative
17:46:07 <atchoum> (knight problem assigment somewhere)
17:46:12 <jcarpenter2> oh, fascinating
17:46:17 <glguy> Ok
17:47:19 <aarvar> jcarpenter2: with liftA2 f = flip (liftA2 (flip f))
17:47:59 <jcarpenter2> lovely
17:48:37 <aarvar> quiz: does that applicative have a valid monad?
17:49:59 <aarvar> jcarpenter2: http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Applicative-Backwards.html
17:50:24 <aarvar> :t (<**>)
17:50:25 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
17:50:52 <aarvar> > [\x -> (x, 3), \x -> (x, 4)] <**> [1, 2]
17:50:54 <lambdabot>  error:
17:50:54 <lambdabot>      • Could not deduce (Num b0)
17:50:54 <lambdabot>        from the context: (Num ((a -> (a, b)) -> b1), Num b)
17:51:03 <glguy> atchoum: How about this? https://gist.github.com/JackTheEngineer/e34ccd73d8dccd93c3d6313245256f9d
17:51:13 <glguy> atchoum: Then you can use pathInN 3
17:51:17 <aarvar> oops
17:51:41 <aarvar> > [1, 2] <**> [\x -> (x, 3), \x -> (x, 4)]
17:51:43 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
17:52:25 <atchoum> :t (<$)
17:52:26 <lambdabot> Functor f => a -> f b -> f a
17:53:13 <jcarpenter2> woohoo, my program works
17:53:38 <aarvar> you didnt actually run it, did you?
17:54:02 <jcarpenter2> http://coliru.stacked-crooked.com/a/fbbc093e4ac9c3f9
17:54:42 <atchoum> glguy: I don't get the trick of how you do it without an accumulator but that's spectaculary
17:54:46 <atchoum> good
17:55:04 <aarvar> jcarpenter2: oh god
17:55:04 <atchoum> i'll need to read that code again and again to understand
17:55:37 <aarvar> looks like my C++ homework
17:56:36 <atchoum> glguy: ah yes I got it, the monadic magic.
17:56:52 <jakov1> glguy: Nice work ! Thank you
17:58:08 <atchoum> glguy: did you actually write a level-order tree evaluation with just three lines of a monadic expression ?
17:59:06 <atchoum> What's hard to understand is that when you do `next <- moveKnight start`, it means that actually next can be any value in the list returned by `moveKnight start`
17:59:10 <atchoum> that's so confusing.
17:59:14 <glguy> atchoum: This code explores the tree in depth-first order
17:59:33 <aarvar> what is "monadic magic"?
17:59:46 <glguy> Yes, the code will be evaluated where 'next' is each value in the list
18:00:16 <jcarpenter2> that's amazing glguy
18:00:20 <jcarpenter2> monads *and* recursion
18:00:40 <iqubic> How does one know if foldr is the right tool to use in a given situation?
18:00:51 <atchoum> glguy: if it's depth-first then it means it evaluates every node, but it is not guaranteed to return the shortest path ?
18:01:12 <glguy> atchoum: This code only returns paths of the requested length
18:01:21 <glguy> If you want code that returns the shortest path you'd write it differently
18:01:33 <atchoum> could you do it ?
18:01:48 <glguy> sure, but gotta eat dinner first. I'll be around later
18:01:49 <atchoum> : p I mean could you do it without too much modifications of your original code ?
18:01:59 <atchoum> okay see you then ;)
18:03:09 <atchoum> actually you could just evaluate pathInN over every integer until the list is not empty and you'd have your response.
18:03:14 <atchoum> (I believe).
18:03:20 <atchoum> Composability to the rescue.
18:03:32 <atchoum> That wouldn't be very efficient though.
18:03:37 <jakov1> glguy: I am curious about it too, could you please append your shortest path to the gist ?
18:04:16 <atchoum> I believe it can be done without too much modification of the monadic expression but that's up to glguy :)
18:06:03 <atchoum> :t guard
18:06:04 <lambdabot> Alternative f => Bool -> f ()
18:12:16 <glguy> That'd be an iterative-deepening depth first search, and is actually pretty efficient in time and particularly in space
19:05:17 <infinisil> Hah, I actually need fmap (fmap (fmap in my code
19:05:37 <clever> :O
19:07:02 <iqubic> Why is that?!?
19:07:27 <iqubic> Are you dealing with a monand transformer stack?
19:08:20 <infinisil> Writing a Functor instance for something that has an inner generic functor f and a list, the first fmap is for the inner functor, the second for the list, the third is for the recursion in my definition
19:08:40 <infinisil> So the second one could be just map actually, but fmap looks cooler :P
19:09:54 <iqubic> Why do you need a recursive application of fmap?
19:10:53 <infinisil> The type contains itself within it
19:11:22 <iqubic> I see. That makes a lot of sense
19:13:23 <Cale> iqubic: Note that if you transform a monad a bunch, the thing you end up with is still just a monad, and so you only need one fmap to apply a function to its result
19:13:23 <rotaerk> hmm in my haskell program that uses the vulkan API, I made a FunPtr of a haskell function, and passed it to Vulkan to be used as a debug callback, but whenever it should be calling it, my program freezes
19:13:32 <rotaerk> any idea how I would even begin to diagnose this?
19:14:10 <rotaerk> pretty sure it's failing at the point at which vulkan should be calling my function
19:14:55 <Cale> iqubic: It's only if you have several functors/monads which are applied to something where you might need to fmap a function more than once. A common case in our real-world code is nested Map structures, like Map k1 (Map k2 v)
19:15:01 <iqubic> I see. But writing the functor instance of a monad transformer requires multiple fmap.
19:15:14 <Cale> Possibly, sure
19:19:32 <benzrf> aughhhh how the fuck do i load a local project in ihaskell
19:19:35 <benzrf> ;A;
19:42:49 <benzrf> .........fuck
19:43:08 <benzrf> something seems to have broken my code between ghc 8.0.2 and 8.2.2
19:43:10 <benzrf> :X
19:45:59 * hackage cyclotomic 0.5.1 - A subfield of the complex numbers for exact calculation.  http://hackage.haskell.org/package/cyclotomic-0.5.1 (ScottWalck)
19:50:28 <glguy> Today's project has been making a program to solve this game: https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/loopy.html
19:50:58 <glguy> https://github.com/glguy/5puzzle/blob/master/Loopy.hs
19:53:56 <infinisil> Umm, 4 levels deep of fmaps now..
19:54:07 <infinisil> fmap (fmap (fmap (fmap ..
19:54:13 <infinisil> Needed to change the type a bit :)
19:59:19 <iqubic> This seems wrong.
20:02:16 <infinisil> iqubic: The type is `data Result i o m a = Final a | Comp [ (i -> m o) -> m (Result i o m a) ]`
20:02:28 <infinisil> If you wanna write the Functor instance yourself
20:02:31 <iqubic> I see. What is this for?
20:03:17 <infinisil> It's a computation that either is done and returns a, or it provides a number of follow-up computations to run, each of them needing a function i -> o to continue
20:03:42 <iqubic> But you wrap it m for some reason?
20:03:43 <infinisil> So you can iteratively select a computation to run until you get a final result
20:04:01 <infinisil> So that i -> o can run in any monad (e.g. IO)
20:04:38 <iqubic> Right, so you make it like a monad transformer, instead of a pure thing.
20:04:49 <infinisil> Yeah
20:05:20 <iqubic> data Result i o a = Final a | Comp [ (i -> o) -> (Result i o a) ]
20:05:29 <iqubic> That would be simpler, I guess.
20:05:40 <infinisil> Indeed, but I need the m
20:05:40 <iqubic> But not what you want here.
20:06:04 <iqubic> Using the m is making this rather hard I suppose.
20:06:34 <iqubic> Do you need help with this, or do you just want to struggle with it for a bit longer?
20:12:59 <infinisil> Nah I was just ranting
20:15:21 <iqubic> Alright, that sounds good.
20:15:54 <jmcarthur> infinisil: The version without the m looks like a free monad, so the version with the m maybe should look like a free monad transformer?
20:16:28 <infinisil> jmcarthur: Yeah I'll have to read up on that, was suggested before already
20:16:40 <infinisil> I'm currently just having fun defining the instances for everything
20:16:50 <jmcarthur> :)
20:18:14 <iqubic> Is there even a use for "Result"?
20:18:40 <infinisil> I create this because I need it, so yes
20:39:11 <iqubic> I still don't get how it is useful, but I'm sure you see the need for it.
20:41:00 <siraben> Is Category Theory for Programmers a good way to learn category theory from basics?  https://github.com/hmemcpy/milewski-ctfp-pdf
20:49:42 <boj> siraben: it's definitely a nice intro from a programmer point of view
20:56:21 <benzrf> siraben: what's your motive in learning category theory? and what's your math background?
21:08:48 <siraben> benzrf: 1. Mostly curiosity.  I want to understand the theoretical concepts that underly Haskell, in the same way in learning lambda calculus for Lisp.  My math background is still at the high school level because I'm in high school, but the knowledge relevant to category theory is some group theory, and some type theory
21:09:04 <benzrf> the lambda calculus underlies haskell more than category theory does
21:09:26 <benzrf> i'm not sure whether group theory in specific is so relevant to category theory
21:09:45 <benzrf> and type theory definitely isn't a requirement :)
21:09:48 <siraben> The book appears to be self contained
21:10:13 <benzrf> personally, as a math person, that book gets on my nerves
21:10:26 <benzrf> if youre interested in math for its own sake, i dunno whether i'd recommend it or not?
21:10:42 <siraben> The math side of category theory seems less approachable than this one
21:11:06 <benzrf> well, yeah, that's true
21:11:08 <siraben> I mean for me it makes sense to go from CS -> Math in concepts like this
21:11:29 <siraben> e.g. sigma notation is just a loop, recursive functions, differentiation being pattern matching
21:11:36 <siraben> and so on
21:11:42 <benzrf> ...differentiation isn't pattern matching...?
21:11:52 <cocreature> you can always start with that book and if/when you’re interested in a more rigorous mathematical view of ct you pick up some other book in addition to that
21:11:52 <benzrf> oh, do you mean like, rules for differentiating
21:11:52 <siraben> Sorry, I mean rewrite
21:11:55 <siraben> Yeah
21:12:11 <benzrf> if that's what you're interested in
21:12:12 <siraben> And of course deriving the rules from first principles helps
21:12:21 <benzrf> i might recommend that you try out Software Foundations
21:13:17 <benzrf> it's not category theory, but it /is/ Actual Math, and in particular it's all about type theory, which is basically the most important rigorous understanding of the analogies you just described
21:13:55 <siraben> Side note; Gödel, Escher, Bach has been an amazing read so far, because of its approach to Gödel's Incompleteness Theorem
21:14:00 <benzrf> :)
21:14:11 <siraben> benzrf: Software Foundations seems interesting
21:14:27 <benzrf> i dont know, in retrospect, whether GEB's exposition was ideal
21:14:33 <benzrf> but it's definitely entertaining as fuck
21:14:54 <benzrf> siraben: it doubles as a course in a certain style of compsci and as an introduction to coq
21:14:54 <siraben> After reading the Typographical Number Theory section, reading certain proofs in Coq became so much easier
21:15:00 <benzrf> oh, you use coq?
21:15:05 <siraben> Looked at it
21:15:13 <siraben> The idea of proving program correctness is fascinating.
21:15:27 <siraben> Went through the tutorial
21:15:30 <cocreature> then you should definitely read software foundations :)
21:15:35 <Zipheir`> siraben: Conceptual Mathematics is pretty decent too.
21:16:00 <benzrf> if your brain works like mine, getting to grips with a proof assistant is a good way of building a cognitive foundation for where rigor in math comes from
21:16:20 <benzrf> er, well, if you're sufficiently far in GEB, you may already have a decent chunk of that -
21:16:44 <siraben> Maybe it's perception, math notation feels so scary, but code is so *logical*
21:17:12 <Zipheir`> siraben: It's not just you. Mathematical notation is infamous. :)
21:17:15 <benzrf> but learning coq or agda or something *in particular* might help build something on which you can understand the *actual constructs* involved in rigorous math
21:17:23 <siraben> Zipheir`: Oh, phew.
21:17:48 <benzrf> whereas GEB teaches you about the notion of formalism, but not much that's useful in practice when doing math
21:17:49 <Zipheir`> siraben: "Oh, look at this d/dx thing. Looks like a fraction, good thing I know fractions!"
21:18:08 <siraben> Zipheir`: Hey look it's cos^-1(x) it must be equal to 1/cos(x) !
21:18:18 <Zipheir`> Exactly.
21:18:19 <siraben> benzrf: Eventually I want to get to the point where I can prove simple things like calculus rules in Coq
21:18:32 <benzrf> that's........... not a great pick >.>;
21:18:39 <siraben> Oof why not?
21:18:50 <benzrf> real analysis is quite subtle in constructive settings
21:18:50 <siraben> e.g. Power rule can be proven using the binomial theorem
21:19:32 <siraben> Speaking of theorem proving, there was a really good intercative theorem prover for Typographical Number Theory
21:19:37 <benzrf> o=
21:19:40 <siraben> https://github.com/jcoglan/tnt
21:19:51 <Zipheir`> siraben: Oh wow
21:20:58 <siraben> Zipheir`: I'll check Conceptual Mathematics out
21:22:09 <benzrf> siraben: if i were you, i'd check out software foundations first
21:22:21 <Zipheir`> siraben: It's a little weird. Some of the concepts are a little mind-bending, and there really need to be more exercises.
21:22:24 <siraben> benzrf: Yep.
21:22:48 <benzrf> learning coq allowed me to transfer over my extensive experience writing functions wholesale into proving universals
21:23:08 <benzrf> it's exactly the same cognitive muscle
21:23:22 <siraben> benzrf: Proving universals?
21:24:17 <benzrf> universally quantified statements, i.e. things of the form "for all X, ..."
21:25:13 <Zipheir`> Curry/Howard all the way.
21:25:33 <siraben> What is Coq proved in?
21:25:40 <benzrf> what do you mean
21:25:45 <siraben> How do we know if Coq's proofs are correct?
21:25:53 <benzrf> we need to trust two things:
21:26:04 <benzrf> 1. that the underlying system, the calculus of inductive constructions, is consistent;
21:26:18 <benzrf> 2. that the ocaml code implementing coq implements that system correctly
21:26:25 <benzrf> (2) is almost certainly false
21:26:27 <benzrf> :)
21:26:31 <siraben> Oof
21:26:46 <benzrf> but it still leaves open far less room for error than human brains.
21:27:22 <benzrf> you probably trust ghc to recognize when your programs are ill-formed, even though it almost certainly has bugs that allow through malformed programs
21:27:34 <siraben> http://us.metamath.org/index.html is amazing
21:27:46 <siraben> benzrf: Right.
21:27:49 <benzrf> in practice, you'd almost definitely have to be deliberately trying to abuse the bugs for them to make a difference
21:28:00 <siraben> Hah say that to a C programmer
21:28:06 <benzrf> lol
21:28:09 <benzrf> ive never looked too closely at metamath
21:28:15 <benzrf> although it seems interesting
21:28:26 <benzrf> i like curry-howard too much
21:28:28 <siraben> Clicking through the proofs is a good way to go from first principles
21:29:24 <benzrf> i'd imagine it's ontologically satisfying
21:29:40 <siraben> Oh yes what is a good way to learn the Hindley Milner Type inference algorithm?
21:29:50 <siraben> The notation on Wikipedia is again, making it harder than it should be
21:30:26 <benzrf> but personally, i've already grown comfortable enough with the ontology of the math i do that the nicer aspects of actually /using/ coq win me over
21:30:37 <benzrf> siraben: hindley-milner is a system, not an algorithm - which one are you asking about?
21:30:47 <siraben> Sorry the system
21:30:49 <siraben> Type system
21:31:15 <benzrf> hindley milner is a bit janky anyway btw
21:31:30 <siraben> How so?
21:31:51 <benzrf> it sits at a very nice pragmatic sweet spot for haskell's purposes, but it's a bit weird as an object of mathematical study
21:31:56 <Zipheir`> benzrf: Well, that wasn't something I expected to read today. o_O
21:32:09 <benzrf> which line? :p
21:32:24 <Zipheir`> benzrf < hindley milner is a bit janky anyway btw
21:32:26 <benzrf> lol
21:33:22 <benzrf> siraben: hindley milner doesnt have -XRankNTypes
21:33:30 <siraben> Speaking of math, 3Blue1Brown is amazing
21:33:39 <benzrf> in fact i believe that's what distinguishes it from system f (i might be wrong tho idk much about system f)
21:34:06 <benzrf> so in particular this means you get foralls in only certain kinds of positions
21:34:35 <benzrf> well, this may well just be the fact that i dont know the motivation behind the construction of hindley milner
21:35:00 <benzrf> i guess it could turn out that there's a compelling underlying thing that gives rise to it - i was just assuming it was a pragmatic thing
21:35:04 <benzrf> >.>
21:37:02 <benzrf> siraben: type theories are generally deductive systems akin to things like TNT, but whose sentences are "judgments" rather than "propositions"
21:37:36 <benzrf> particularly, type theories are quite often /decidable/ (in the sense that it is computable whether a given judgment can be deduced or not)
21:38:09 <benzrf> this notation on wikipedia is showing axioms of deduction https://wikimedia.org/api/rest_v1/media/math/render/svg/10d6e781d61259108db5fbfcfd84cb47daac33a6
21:40:08 <siraben> benzrf: Why ZFC harder to "get" than Peano?
21:40:22 <benzrf> we should probably move this conversation to -blah
21:40:32 <siraben> Which channel
21:40:35 <benzrf> #haskell-blah
21:41:11 <siraben> Isn't it #haskell-offtopic
21:41:35 <siraben> I can't seem to join haskell-blah
21:42:12 <benzrf> o.O
21:42:17 <benzrf> offtopic is another channel that exists, i think
21:42:23 <benzrf> i joined -blah years ago and never left it
21:42:26 <benzrf> im not sure what the distinction is
21:42:36 <benzrf> i don't think -blah is invite-only or anything...
21:42:37 <infinisil> siraben: I can join it no problem
21:43:06 <siraben> Must be a bug in ERC
21:43:21 <siraben> Emacs IRC
21:44:05 <siraben> benzrf: Wow how do you stay on IRC channels for /years/?
21:44:20 <benzrf> :p
21:44:30 <benzrf> fine, my bouncer's uptime is more like a month or so
21:44:49 <siraben>  You must have the most complete record of many channels
21:45:33 <benzrf> lots of people have bouncers
21:45:36 <infinisil> There's lots of people running bouncers, and IRC is very old, so I'd think a lot of people have complete records of many channels
21:45:38 <benzrf> this is very offtopic though
21:45:51 <siraben> Yes
21:46:14 <siraben> (I just joined IRC two months ago)
21:47:57 <benzrf> what error are you getting when you try to join #haskell-blah
21:48:56 <pavonia> It requires you to be connected with mode +Z (secure connection), IIRC
21:49:22 <siraben> benzrf: no error
21:49:30 <benzrf> oh
21:49:32 <siraben> How do I check my current mode?
21:49:39 <benzrf> who doesn't use ssl
21:49:44 <benzrf> smh
21:49:51 <pavonia> /mode siraben
21:49:58 <siraben> +i
21:50:12 <siraben> I can't use SSL because of a bug in GNUTLS
21:50:21 <siraben> That doesn't allow ERC to connect
21:50:25 <siraben> I'll figure it out later.
21:50:41 <benzrf> ._.
21:51:38 <siraben> pavonia: How did you type that without executing the command?
21:51:50 <pavonia> /say ...
21:51:58 <siraben> hi
21:52:09 <siraben> hello
21:52:16 <siraben> No echo?
21:52:28 <benzrf> hello
21:52:34 <siraben> Ok
21:52:34 <siraben>  
21:54:34 <infinisil> Oh my god, the thing with computation steps and stuff I've been trying to implement doesn't work after all
21:54:43 <infinisil> Well it does work, but it's not what I really wanted
21:54:48 <benzrf> heh
21:55:04 <infinisil> And I actually now have no idea how to implement what I actually want
21:57:46 <infinisil> Oh actually
21:58:01 <infinisil> Coroutine might just be what I need
21:58:35 <infinisil> My goal for now is to create a merge sort
21:58:41 <infinisil> But not just any merge sort
21:59:13 <infinisil> This merge sort shall allow the user to compare between the elements in an IO action, and the user shall also be able to choose which comparison he wants to do next
22:00:38 <infinisil> So the merge sorts needs to first split everything up, collect the "comparisons to do" of the leafs, ask the user to choose one, run that comparison, then potentially advance whatever next step is now available
22:01:44 <infinisil> And a Coroutine might just do something like that, because of the suspendability/resumability of calculations
22:03:59 <iqubic> Does Haskell have Coroutines?
22:04:50 <benzrf> that's the wrong question
22:05:00 <benzrf> the right question is "is there a haskell library implementing coroutines"
22:05:04 <benzrf> the answer to that is yes
22:05:59 <infinisil> https://hackage.haskell.org/package/monad-coroutine
22:06:53 <cocreature> the various streaming libs can also be seen as coroutines
22:06:57 <benzrf> ^
22:07:02 <benzrf> pipes
22:10:23 <infinisil> Eh, I don't think I could do that with pipes
22:10:39 <infinisil> This monad-coroutine package actually looks exactly like what I need
22:15:30 <benzrf> why not?
22:16:42 <infinisil> Think about it for a while or try to implement it with pipes, I'm 90% certain you'll hit a wall
22:18:27 <infinisil> I don't know pipes all that well, but having thought about this problem for some time now I can say it's definitely not easy
22:20:11 <cocreature> infinisil: if you instantiate Coroutine with Yield for "s" and specialize some type parameters in pipes you end up at pretty much the same thing
22:20:32 <cocreature> so if one of those works chances are the other will work as well
22:20:57 <infinisil> I need not Yield but Await (or something similar)
22:21:20 <cocreature> you get both in pipes so that’s not the problem
22:22:00 <infinisil> Well I'll have to go to sleep now
22:22:47 <infinisil> I'll consider pipes when coroutine doesn't work out :)
22:23:18 <cocreature> oh I’m not saying pipes is the better solution here, I just wanted to point out the similarity between monad-coroutine and pipes
22:23:37 <infinisil> Ah
22:27:34 <benzrf> infinisil: yeah, you want request/respond, not the literal "pipe" parts of pipes
22:33:43 * hackage sql-words 0.1.6.1 - SQL keywords data constructors into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.6.1 (KeiHibino)
23:11:15 <tsahyt> I've been wondering for a while, why does reflex have version bounds on base that prohibit use of new GHC versions?
23:12:02 <tsahyt> at least the version on hackage does. the current bounds on github are high enough to use GHC 8.4
23:13:05 <portnov> hello
23:13:14 <portnov> anyone working with cloud-haskell?
23:13:29 <cocreature> tsahyt: the reflex team doesn’t seem to care a whole lot about hackage releases ime since they use reflex-platform
23:14:42 <tsahyt> I see
23:15:09 <tsahyt> I guess I'll stick with reactive-banana as an FRP framework for convenience then
