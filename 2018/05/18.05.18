00:00:04 * hackage cabal-sort 0.0.5.4 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.5.4 (HenningThielemann)
00:00:24 <Ariakenom> cocreature: not much, no. I'll stick ot it
00:01:47 <dminuoso> Short of TH, is that even possible?
00:01:55 <jesyspa> Ariakenom: I think there is some cleverness you could do with typeclasses, but the generecity part would be annoying.  Basically, make a typeclass ToListable a f with instances ToListable a [a] and ToListable a r => ToListable a (a -> r).
00:02:20 <jesyspa> (Not saying it's a good idea, but it's a neat trick.)
00:03:02 <Ariakenom> not nice :)
00:03:31 <dminuoso> zincy: Rewrite the function (so that you float arguments that may be omitted for point-free style to the right), use lambdas or semantic editor combinators like (.) . (.)
00:05:01 <dminuoso> Or maybe a separate binding where the order is changed if you need multiple styles
00:05:42 <jle`> Ariakenom: in the past a ListSections extension has been floated around
00:05:51 <jle`> where you have [,,,] :: a -> a -> a -> [a]
00:06:07 <jle`> er, a -> a -> a -> a -> [a]
00:06:21 <jle`> just like how we now have (,,,) :: a -> b -> c -> d -> (a,b,c,d)
00:06:31 <jle`> i believe the extension was actually fully implemented but just never merged
00:08:52 <Ariakenom> jle`: interesting. makes sense
00:12:44 <mniip> how about
00:13:01 <dminuoso> Ariakenom: (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
00:13:18 <dminuoso> ListSections for free!
00:13:22 <mniip> :t fmap (fmap (fmap (fmap (toListOf each)))) (,,,)
00:13:22 <jle`> @pl \x y z a -> [x,y,z,a]
00:13:23 <lambdabot> (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
00:13:23 <lambdabot> a4 -> a4 -> a4 -> a4 -> [a4]
00:13:56 <shadowdaemon> mniip: Are you partially responsible for this "Powder Toy" app?
00:14:01 <mniip> uhhh yes
00:14:02 <jle`> :t (fmap . fmap . fmap . fmap . toListOf) each (,,,)
00:14:04 <lambdabot> a4 -> a4 -> a4 -> a4 -> [a4]
00:14:09 <zincy> diminuoso : Thanks!
00:14:11 <shadowdaemon> mniip: Nice!
00:14:12 <dminuoso> Does lambdabot's @pl provably work?
00:14:14 <jle`> i mean i guess? :)
00:14:21 <jle`> dminuoso: what do you mean by 'work'
00:14:28 <shadowdaemon> I thought I recognized that name from somewhere.
00:14:28 <jle`> does it give something correct?
00:14:30 <mniip> shadowdaemon, you can join us in #powder if you want
00:14:31 <dminuoso> jle`: I mean, is there some proof of consistency for what it does?
00:14:37 <jle`> consistency?
00:14:52 <jle`> do you mean like, correctness?
00:14:54 <dminuoso> jle`: Can @pl give me wrong answers?
00:14:55 <shadowdaemon> mniip: I was just messing around with it, but it sure is fun.
00:15:09 <jle`> dminuoso: ah.  are you asking if pl has any known bugs?
00:15:36 <dminuoso> jle`: Let me ask differently: How does @pl work?
00:15:45 <dminuoso> Does it implement some published algorithm?
00:16:19 <jle`> https://github.com/bmillwood/pointfree
00:17:04 <jle`> it doesn't look like there are any bugs on the issue tracker
00:17:22 <jle`> or, are you asking if @pl's source is formally verified?
00:17:36 <dminuoso> jle`: Well the algorithm it implements, rather than the source.
00:17:37 <jesyspa> dminuoso: There is a theorem stating that given any term in a lambda calculus with certain additional features, there is an equivalent term that has no lambda-abstractions.
00:18:59 <jle`> usually it's just a mechanical translation to SK calculus terms
00:19:24 <jesyspa> This theorem is constructive, so you can implement it in code.  The idea is a recursive traversal of your expressions, where the key combinators needed are the ap of Reader and const.
00:20:01 <jesyspa> More combinators may be used to reduce the size of the result, flip and (.) being the most obvious ones.
00:21:26 <jle`> dminuoso: if you do a few terms by hand (translating to SK) then you'll start seeing how the process is a bit mechanical
00:21:33 <Ariakenom> any common operator name for flip (.)?
00:21:41 <jesyspa> To give a simple example, suppose you have a term of the form \x -> y z, where y and z may mention x.  Then you can run this algorithm recursively to get pointfree y' and z' (basically, representing \x. y and \x. z), and then the equivalent term is ap y' z'.
00:21:43 <mniip> jle`, I can do that stuff in my head
00:21:46 <jle`> Ariakenom: there's (>>>), but its associativity is a bit different
00:22:03 <zincy> What am I missing here
00:22:04 <jesyspa> Since ap y' z' x = (y' x) (z' x), you get exactly what you want.
00:22:05 <zincy> foldr (\a b -> a + b) [] ([1 .. 4] :: [Int])
00:22:16 <mniip> zincy, [] is not a number
00:22:22 <jle`> Ariakenom: its associativity was picked to be used with other operators, so it's not really a suitable drop-in replacement for (.) in many situations
00:22:31 <jle`> zincy: what are you trying to implement?
00:22:47 <zincy> mniip : Thanks I thought that argument was for the initial value of the reduce
00:22:55 <mniip> zincy, it is
00:23:00 <dminuoso> jesyspa: Ah that looks not so hard
00:23:03 <jle`> zincy: you are reducing to a number
00:23:03 <mniip> however you probably don't want it to be []
00:23:09 <jle`> so the initial value should be a number
00:23:15 <mniip> it's computing 1 + (2 + (3 + (4 + [])))
00:23:32 <zincy> Makes sense thanks
00:24:09 <jesyspa> dminuoso: Yeah, it's fairly straightforward, though you end up adding more and more combinators as you want more performance.
00:24:13 <zincy> This is what I am actually trying to do: create a list of trees where population is an int - foldr (\member forest -> forest : [makeSet member]) [] [1 .. population]
00:24:32 <zincy> Making a disjoint set
00:25:06 <jle`> :t foldr
00:25:07 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
00:25:09 <mniip> that doesn't look right
00:25:18 <mniip> :t (\member forest -> forest : [makeSet member])
00:25:19 <lambdabot> error: Variable not in scope: makeSet :: t -> a
00:25:26 <mniip> :t (\member forest -> forest : [?makeSet member])
00:25:28 <lambdabot> (?makeSet::t -> a) => t -> a -> [a]
00:25:40 <mniip> no way that can match (x -> y -> y)
00:26:04 <jle`> zincy: are you just trying to apply a function to every item in a list?
00:26:38 <zincy> Yes that would be simpler :D
00:26:43 <jle`> you can use map :)
00:26:46 <jle`> > map negate [1,5,2,3]
00:26:49 <lambdabot>  [-1,-5,-2,-3]
00:26:51 <zincy> haha much more elegant
00:27:03 <jle`> although, it's worth trying to figure out how to implement map using foldr
00:27:23 <jle`> your idea was close
00:27:27 <zincy> map makeSet [1..population]
00:27:31 <jle`> just make sure to be aware of what the arguments and outputs should be
00:27:59 <zincy> jle` yeah that would be a good exercise right?
00:28:10 <jle`> for the function argument, the first argument is the item in the item in the list, the second argument is the accumulating result, and the output is the new result
00:28:11 <zincy> I guess both would work but just using map is far more elegant
00:28:17 <jle`> zincy: yeah, it's actually a common exercise :)
00:28:28 <jle`> zincy: it seems you were close, just your output is a bit off
00:28:43 <jle`> you want to return a list, with a new item at the front
00:28:54 <jle`> you might have switched the arguments of (:) in your head
00:29:01 <zincy> Oh and it would have worked?
00:29:12 <jle`> it would have been closer to working :)
00:29:19 <zincy> I dont understand why the order of the arguments to (:) matter?
00:29:28 <jle`> zincy: what do you think (:)  does?
00:29:59 <zincy> Oh is there a reverse (:)
00:30:13 <zincy> I guess (:) appends a new element as the head
00:30:13 <jle`> what would a "reverse (:)" do?
00:30:16 <zincy> :t (:)
00:30:17 <lambdabot> a -> [a] -> [a]
00:30:28 <jle`> > 'a' : "hello"
00:30:31 <lambdabot>  "ahello"
00:30:42 <jle`> so yes, the order does matter
00:30:45 <zincy> reverse : would be helloa
00:30:47 <jle`> > 1 : [1,2,3]
00:30:50 <lambdabot>  [1,1,2,3]
00:31:02 <jle`> zincy: ah yeah, that's often called 'snoc'
00:31:15 <zincy> Ah ok
00:31:22 <jle`> it's not a common list operation though
00:31:31 <jle`> people often implement it as xs ++ [x]
00:31:37 <zincy> I was assuming that (:) somehow magically called snoc if you reverse the args
00:31:38 <jle`> > "hello" + ['a']
00:31:41 <lambdabot>  error:
00:31:41 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘+’
00:31:41 <lambdabot>      • In the expression: "hello" + ['a']
00:31:43 <zincy> don't know why I thought that
00:31:46 <jle`> > "hello" ++ ['a']
00:31:49 <lambdabot>  "helloa"
00:32:09 <jle`> zincy: if you come from another progrmaming language, you might be used to implicit coersion
00:32:15 <jle`> haskell doesn't do any of that :)
00:32:35 <zincy> Yeah I guess implicit coercion is a slippery slope
00:32:46 <jle`> zincy: also you might be mixing up (:) conceptually with (++)
00:32:56 <zincy> yes I am
00:33:03 <pindab0ter> What's the conceptual difference?
00:33:05 <zincy> i actually thought they were equivalent
00:33:09 <jle`> it's a common confusion, no worries :)
00:33:14 <jle`> pindab0ter: follow the types :)
00:33:23 <zincy> ++ takes two lists?
00:33:23 <jle`> when in doubt, the types usually hold the answer
00:33:29 <jle`> :t (:)
00:33:30 <lambdabot> a -> [a] -> [a]
00:33:31 <jle`> :t (++)
00:33:32 <lambdabot> [a] -> [a] -> [a]
00:33:36 <pindab0ter> Ah, right
00:33:41 <pindab0ter> A small but important difference
00:33:48 <pindab0ter> Oh lol, that bot is pretty cool!
00:33:54 <jle`> zincy: writing (\member forest -> [makeSet member] ++ forest) would have worked
00:34:10 <zincy> ooh cool
00:34:12 <jle`> and you can simplify it by looking at the definition of (++)
00:34:22 <jle`> and seeing that (++) is defined so that [x] ++ ys = x:ys
00:34:34 <jle`> so (\member forest -> makeSet member : forest) would have been ok
00:35:35 <zincy> :D
00:35:48 <zincy> Thanks this conversations has been very enlightening!
00:35:53 <zincy> *conversation
00:36:18 <jle`> no problem, hope it was helpful :)
00:36:46 <zincy> super helpful
00:36:54 <Boomerang> jle`: Next implement foldl in terms of foldr :D
00:37:07 <zincy> thanks good idea
00:37:16 <zincy> I am writing all these exercises down
00:37:22 <Boomerang> That's a bit more advanced though...
00:37:46 <Boomerang> So maybe you should tackle other intermediary exercises first :)
00:38:16 <zincy> Are there any good lists of exercises on the web? I found the 99 problems one but its very beginner oriented
00:38:54 <pindab0ter> I personally love exercism.io, though I doubt it will be much different from 99 problems
00:40:44 <Ariakenom> :t foldr . flip -- "follow the types"
00:40:45 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
00:44:25 <Boomerang> > foldl (flip (:)) [] [1,2,3] -- reverse
00:44:27 <lambdabot>  [3,2,1]
00:44:34 * hackage range-set-list 0.1.2.1 - Memory efficient sets with ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.1.2.1 (phadej)
00:44:38 <Boomerang> > (foldr . flip) (flip (:)) [] [1,2,3] -- reverse ?
00:44:40 <lambdabot>  [1,2,3]
00:45:40 <Ariakenom> I know it's wrong. I was badly giving an example of following the types not working
00:45:52 <phadej> latter makes flip . flip
00:46:02 <phadej> :t flip . flip
00:46:03 <lambdabot> (b -> a -> c) -> b -> a -> c
00:46:29 <phadej> foldr (:) [] = id
00:46:55 <zincy> Planted the exercises seed
00:46:55 <zincy> https://github.com/therewillbecode/haskell-exercises/blob/master/README.md
00:47:02 <zincy> Feel free to add some :)
00:47:45 <pindab0ter> zincy: nice
00:49:24 <zincy> pindab0ter : Thanks
00:50:35 <elvishjerricco> Is there anything like GHC_PACKAGE_PATH for the Cabal library (i.e. Setup.hs)? I'd like to be able to add package dbs with an environment variable, not command line arguments
00:57:06 <zincy> Just checking is this the best way to represent a tree? data Tree a = Node a  (Tree a)  (Tree a)   | Nil
00:58:23 <zincy> I am trying to represent a trees where nodes can have any number of children
00:58:23 <cocreature> zincy: depends on the operations you want to perform on the tree but in most cases that’s a very reasonable representation
00:58:32 <infinisil> zincy: The best? There is no single best way to do anything, but yes, what you described is a well known representation for a binary tree
00:58:39 <cocreature> if you want any number of children use something like Node a [Tree a] | Nil
00:59:33 <zincy> :)
00:59:36 <zincy> Cheers
01:00:18 <infinisil> One problem with this one is that you can't do min/max calculations easily
01:00:37 <infinisil> E.g. what's the maximum/minimum of a tree t = Nil ?
01:01:02 <infinisil> You'll have to use something like Maybe (Int, Int) to describe min/max
01:01:23 <andreabedini> worse, what would Node 1 [Nil, Nil, Nil] represent ?
01:01:48 <infinisil> A node with value 1 and 3 empty subtrees?
01:01:48 <jakub> hi, is it possible to hide symbols in ghci via the :m directive?
01:02:06 <infinisil> jakub: :set prompt "> "
01:02:32 <jakub> infinisil: no i mean, an equivalent to "import X hiding (a,b,c)
01:02:53 <andreabedini> infinisil: sure, as long as you have a meaning for "empty subtree"
01:03:28 <infinisil> andreabedini: It's very common to use empty trees as leafs of a tree
01:03:29 <Boomerang> infinisil: If you give that tree an instance of Foldable, then you can do: getMin . foldMap Min
01:03:38 <andreabedini> usually a tree with arbitrary number of subtrees is called a rose tree and defined as Tree a = Tree a [Tree a] (without the Nil case)
01:03:51 <jesyspa> You can just drop the Nil case if those thinsg bother you.
01:04:06 <infinisil> andreabedini: Ah I see, true dat
01:04:17 <andreabedini> infinisil: I see you point too (re leaves)
01:04:38 <infinisil> I guess it depends on the usecase of the rose tree
01:04:41 <andreabedini> my version attaches values to leaves, yours doesn't
01:08:02 <Boomerang> @let obfuscatedFoldl f = flip $ foldr (flip (.) . flip f) id
01:08:04 <lambdabot>  Defined.
01:08:10 <Boomerang> > obfuscatedFoldl (flip (:)) [] [1,2,3]
01:08:12 <lambdabot>  [3,2,1]
01:18:30 <zincy> Say I have these two functions size :: Tree a -> Int size (Node a forest) = 1 + (sum $ map ((+ 1) . size) forest)             depth :: Tree a -> Int depth (Node a forest) = 1 + (maximum $ map ((+ 1) . depth) forest)
01:18:43 <zincy> Would it be more or less elegant to abstract out the common pattern?
01:23:05 <mniip> the common pattern already exists and is called foldMap
01:23:53 <mniip> size is already implemented as Data.Foldable.length
01:24:32 <mniip> hmm, maximum is trickier because it's not associative...
01:25:05 <quicksilver> what monoid instance are you picturing for tree?
01:25:14 <quicksilver> we don't know where his labels live either, I don't think
01:25:32 <mniip> monoid instance?
01:25:35 <quicksilver> oh yes, the labels are on the nodes
01:25:37 <mniip> I was picturing a Foldable instance
01:25:47 <mniip> the only one that satisfies the laws
01:26:05 <mniip> zincy, you might write a tree-specific fold
01:26:23 <mniip> foldTree :: (a -> [b] -> b) -> b -> Tree a -> b
01:26:51 <zincy> quicksilver: I guess the monoid instance in my case would best be served by connecting the root of the shallower tree to the root of the deeper tree
01:27:05 <mniip> that doesn't sound associative
01:29:23 <zincy> Would it be associative if no weighting was applied for the depth?
01:29:42 <zincy> Just arbritrarily connect one root to the other
01:31:35 <quicksilver> I was not making a lot of sense
01:31:39 <quicksilver> apologies for that
01:31:49 <quicksilver> having reconfigured my brain, what I actually want to say is:
01:32:08 <quicksilver> the 'depth' calculation is quite different from size, and you definitely can't get it from the Foldable abstraction.
01:32:44 <quicksilver> so, Foldable just feeds you the elements in some order; Foldable can be defined just by providing 'toList' even if that's not necessarily the best way.
01:33:00 <quicksilver> that's good enough for 'size' but doesn't help with depth at all.
01:33:11 <zincy> no worries
01:33:56 <quicksilver> the actual shared recursion pattern there is a catamorphism
01:34:15 <quicksilver> which is basically just a way of saying "the natural recursion pattern down your recursive data type"
01:34:53 <quicksilver> whilst that's interesting to know I don't think it necessarily helps you write clearer code or code which can be abstracted in more useful ways
01:54:16 <zincy> quicksilver : Interesting :)
01:57:27 <gentauro> Boomerang: Ended up writting this for my SKK parse :) -> https://gist.github.com/gentauro/aae12374d389c247b29134f7b01e5328#file-_skk-hs-L34-L62
01:57:38 <gentauro> not the prettiest Haskell code, but does the job :P
01:58:38 <quicksilver> zincy: also does your 'depth' have a bug?
01:58:53 <quicksilver> it seems like you shouldn't need to add one and *also* map (+ 1)
02:04:42 <zincy> quicksilver : Does a one element tree have a depth of 1? That is the assumption I was making
02:04:59 <zincy> Or is depth referring to edges instead
02:05:58 <[exa]> hm guys, well, since sed is T-complete
02:06:11 <[exa]> is there a λ-calculus interpreter for sed?
02:09:25 <barrucadu> [exa]: I've seen a Turing machine implemented in sed.  You "just" need to write a lambda calculus interpreter in that!
02:09:49 <[exa]> barrucadu: yeah, I've seen similar reduction using BF interpreter... :D
02:10:19 <[exa]> otoh I honestly imagine that coding λ in that shouldn't be _that_ hard
02:11:23 <gentauro> [exa]: BF interpreter?
02:11:54 <[exa]> gentauro: https://github.com/svbatalov/bf.sed
02:13:01 <gentauro> ah, got it
02:23:51 <cocreature> turns out, if you use -fno-code you can’t run your code. who would have thought that …
02:29:15 <malade_mental> Hi, I wrote this piece of code https://frama.link/_QFpx0f_ (lpaste seems to be down) based on the example on custom data types from the HCFP , this works but I don't understand why I have to specify that I want to run "Main.read". Isn't this implicit?
02:34:12 <cocreature> malade_mental: the problem is that there is a function called "read" that’s imported by default so it’s ambiguous whether you want to use that or the one you defined yourself
02:35:05 <malade_mental> cocreature: so I'd just have to "hide" the read from prelude?
02:35:40 <merijn> malade_mental: That or rename your read, yeah
02:36:04 <merijn> Shadowing prelude functions is generally not a great idea if you want other people who read your code to not hate you :)
02:36:34 <malade_mental> héhé
02:37:08 <malade_mental> but would this be possible to tell that my read function belongs to the Move data type?
02:37:58 <cocreature> functions are not scoped by the types they operate on if that’s what you’re asking
02:38:05 <malade_mental> that's it
02:38:09 <malade_mental> thanks cocreature
03:08:24 <Winkelfrau> I just started playing with criterion and am not sure if I am testing correctly: https://paste.ofcode.org/GMUmaFReKDtxFKRuvB6ecc
03:09:10 <Winkelfrau> Is my "1k" test really inserting the 1000 key/value pairs? So is the "make" test not required to be that complicated?
03:09:40 <Winkelfrau> I am using a strict map but a function call that creates such a map could be lazy and not run.
03:10:09 <Winkelfrau> And is the "read" test really timing how much time it takes to read all one million values?
03:10:47 <[exa]> Winkelfrau: maybe you want to parenthesize the whnf parameter
03:11:37 <Winkelfrau> [exa]: can you give one example? I thought I did parenthesize them :-)
03:12:52 <[exa]> oh, wrong guess (I'm always forgetting that whnf works on functions)
03:14:20 <[exa]> anyway, you can try with nf
03:15:34 <[exa]> (because I'm not sure if getting whnf of a Map is computationally demanding at all)
03:23:38 <phz_> hey!
03:23:56 <phz_> do you know whethere persistent-postgresql supports special clause for insertions?
03:24:01 <phz_> like ON CONFLICT?
03:24:09 <phz_> if not, I guess I’ll have to use sqlRaw
03:50:26 <ph88> when i keep my code the same and all my deps but upgrade ghc from 8.0.2 to 8.2.1 then compiling gets stuck at "Called arity analysis"  ..  i'm not sure what to do about this. Anyone advice ?
03:51:35 <cocreature> ph88: try to isolate it to some minimal example
03:56:35 <phz_> damn
03:56:49 <phz_> I have an INSERT sql query I pass to rawSql (persistent)
03:57:06 <phz_> yet the query doesn’t return anything… so I don’t know what I should use as PersistField type
03:57:17 <phz_> (it’s actually RawSql type)
04:04:00 <zincy> So.. the state monad works by being a newtype wrapper around a function?
04:04:44 <quicksilver> yes. State s a can be thought of as s -> (s,a)
04:05:23 <zincy> I am getting confused by the act argument
04:05:25 <zincy> execState :: State s a -> s -> s execState act = snd . runState act
04:06:06 <quicksilver> act is the "State s a" value
04:06:17 <zincy> ah
04:06:20 <cocreature> and runState unwraps the newtype
04:06:30 <zincy> so runState just unwraps the function
04:07:00 <quicksilver> and you'll notice that they use (a,s) not (s,a)
04:07:12 <zincy> So what would be the kind of exec state once the act argument is applied? Would it be a concrete type ?
04:07:17 <quicksilver> but (s,a) would actually be more consistent with other stuff which is why I said it that way.
04:07:29 <quicksilver> execState act :: s -> s
04:07:37 <zincy> Or would the s in s -> (s, a ) still need to be applied?
04:07:49 <quicksilver> it's still waiting for an s yes
04:08:00 <quicksilver> execState act is a function which take states to states
04:08:41 <zincy> So lets say we had a simple stateful counter
04:09:08 * hackage haxl 2.0.0.0 - A Haskell library for efficient, concurrent,and concise data access.  http://hackage.haskell.org/package/haxl-2.0.0.0 (SimonMarlow)
04:09:27 <zincy> Where inc :: Int -> State Int inc n = State $ \curr -> ((), curr + n)
04:10:07 <cocreature> oh new hax
04:10:09 <cocreature> *haxl
04:10:13 <quicksilver> that has the type Int -> State Int ()
04:10:43 <quicksilver> but go on
04:11:39 <juri2mol> \q gchristensen
04:12:19 <juri2mol> oops :)
04:13:37 <zincy> would execState $ inc 1 $  State $  \_ -> ((),0) work the way I expect?
04:14:22 <cocreature> zincy: no that’s a type error
04:14:22 <zincy> I would expect this to have an initial stateful counter set to 0 which is then incremented by 1
04:15:05 <cocreature> zincy: the first problem is that this is equivalent to "execState (inc 1 (State (\_ -> ((), 0)))" whereas you need something more like "execState (inc 1) _"
04:15:32 <cocreature> zincy: the second problem is that "State (\_ -> ((), 0))" is of type State Int (), whereas you need something of type Int
04:15:48 <cocreature> e.g. execState (inc 1) 0
04:16:19 <zincy> Ok so the state is only the second value of the tuple
04:16:39 <zincy> so when setting state we pass an int and then put is called behind the scenes?
04:16:55 <zincy> ok thanks that makes sense
04:17:19 <zincy> I guess I was trying to replicate the logic of put :: s -> State s () put s = State $ \_ -> ((), s)
04:18:03 <zincy> So how do you represent a counter initialised to 0?
04:18:18 <zincy> State $ \_ -> ((),0)
04:19:26 <cocreature> I think you are slightly confusing things. something of type "State Int a" does not represent the value of a counter. it represents a modification of a counter
04:19:54 <cocreature> so "State (\_ -> ((), 0))" is not a counter that’? initialised to 0, it’s something that resets the counter to 0 regardless of the previous value
04:20:08 <zincy> So what I wrote would represent a modification to state that yields an empty intermediate value?
04:20:50 <zincy> such a modification would be passed to execState or evalState right in order to change the state value?
04:21:27 <zincy> So is this the usefulness of the state monad that we can chain state modifying actions easily?
04:22:51 <cocreature> yeah pretty much
04:23:18 <cocreature> you could just as well pass around the state manually. that can just get a bit annoying sometimes
04:24:00 <zincy> Thanks!
04:24:11 <zincy> Super helpful as always
04:24:36 <zincy> Teaching haskell must be a lot harder than learning it
04:25:17 <cocreature> stick around here long enough and you can experience the joy of teaching Haskell yourself ;)
04:25:35 <zincy> hehe that would be nice :)
04:32:35 <hpc> zincy: most of the hard work in teaching haskell comes from learning things well enough to explain them properly
04:35:30 <dminuoso> Well I think that's only a small portion of it.
04:35:39 <dminuoso> Teaching in general is not easy.
04:41:30 <ongy> is there any extension that allows me to pattern match on Text? Or do I have to convert to String to support that?
04:43:50 <Boomerang> ongy: "OverloadedStrings" seems to work :)
04:44:12 <Boomerang> > let f "hey" = True; f :: Text -> Bool in f "hey"
04:44:14 <lambdabot>  error:
04:44:14 <lambdabot>      Not in scope: type constructor or class ‘Text’
04:44:52 <Boomerang> Or did you want to pattern match like on a list `(x:xs)`?
04:44:59 <ongy> nah, full text
04:45:00 <jbetz> if I want to generate a database model from a domain model (i.e., map column names and types), is it better to use TH or Generics?
04:45:55 <jbetz> of course, I'll also want to auto-derive the `FromRow` instance for converting between them
04:46:10 <Boomerang> ongy: then how about using `PatternView`? let f (unpack -> (x:xs)) = ...
04:47:19 <Boomerang> Or even better: let f (uncons -> Just (x, xs)) = ...
04:51:35 <Boomerang> IIRC PatternGuards are now enabled by default so you could do without enabling extensions: f text | Just (x, xs) <- uncons text = ...
05:04:35 <merijn> Boomerang: They're part of Haskell2010, yes
05:04:55 <merijn> So by now PatternGuards have been standard for almost a decade and everyone still forgets >.>
05:05:51 <merijn> ongy: With OverloadedStrings it should work the same way it does for integral types, etc.
05:06:01 <Cale> PatternGuards are really nice for dealing with GADTs sometimes, where you need to patten match on something in order to observe a type equality before continuing to match on something else.
05:06:22 <merijn> Cale: Also for dealing with "if this is in a Map" style guards
05:06:34 <Cale> yeah
05:07:03 <Boomerang> I showed PatternGuards to a colleague, and now we have "| True <- check something" in the codebase :p
05:07:28 <merijn> Boomerang: Please slap your colleague
05:07:48 <Cale> hahaha
05:07:58 <Boomerang> It's like the functional equivalent of "return check == true;"
05:08:16 <opqdonut> | "True" <- show (check something)
05:08:52 <hvr> Boomerang: even though everyone knows you're supposed to write `return !!check` ;-)
05:08:57 <Cale> Still, I'll take that over someone violently abusing fancy types and singleton nonsense to obtain no additional actual guarantees.
05:09:58 <ongy> hu, I thought it didn't work with overlaoded strings. But if it does, that makes things easy
05:11:02 <Boomerang> hvr: `return !!check` is a real thing though! When you want to change a truthy value into a bool. :-/
05:11:05 <ddellacosta> so, I've realized I don't really understand the point of join. Suggestions on tutorials/exercies/etc. for developing more of an understanding?
05:11:23 <ddellacosta> exercises*
05:12:30 <ddellacosta> I guess maybe it's more useful to try to grok it in the context of specific monads...
05:12:35 <opqdonut> yes, definitely
05:12:49 <opqdonut> for some monads >>= is more natural, for some monads join
05:13:09 <ddellacosta> opqdonut: that's helpful--can you suggest any examples of the latter?
05:13:21 <opqdonut> join for [], >>= for Maybe, for instance
05:14:05 <opqdonut> join for Writer, >>= for State
05:14:16 <opqdonut> YMMV on what feels more natural though
05:14:19 <ddellacosta> opqdonut: okay great, thanks--that's as good a place to start as any I think
05:14:32 <ddellacosta> I'll play around and see what I can glean
05:15:13 <opqdonut> so remember that "join op = op >>= id" and "op >>= f = join (fmap f op)"
05:15:18 <Boomerang> :t join @[]
05:15:19 <lambdabot> error:
05:15:20 <lambdabot>     Pattern syntax in expression context: join@[]
05:15:20 <lambdabot>     Did you mean to enable TypeApplications?
05:15:36 <opqdonut> for [], you have "op >>= f = concat (map f op)"
05:15:46 <opqdonut> so >>= is quite literally implemented in terms of join
05:16:18 <ddellacosta> huh, I did not know that
05:18:26 <ddellacosta> also, for context, part of the reason I'm trying to understand it now is that I've embarked on a project to learn comonads and it seems that the dual (duplicate?) is more natural in many examples I've seen so far
05:18:34 * hackage datafix 0.0.0.2 - Fixing data-flow problems  http://hackage.haskell.org/package/datafix-0.0.0.2 (sgraf812)
05:18:35 <opqdonut> yes
05:18:37 <opqdonut> I think so too
05:20:24 <merijn> Really? I finx comonads a lot less natural, tbh
05:20:31 <merijn> s/finx/think
05:20:38 <merijn> Dunno wtf happened there >.>
05:21:18 <ddellacosta> merijn: I think that was more about the use of (the dual of join) duplicate used in comonads vs. extend, whereas in monads bind seems more common
05:21:27 <ddellacosta> I mean, that's what I mean at least, haha
05:22:15 <ddellacosta> not that I've got much of an intuition for comonads yet
05:22:36 * hackage hasbolt-extras 0.0.0.9 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.9 (ozzzzz)
05:34:40 <hexagoxel> the showsPrec method has precedences from 0 to 11. However, type annotation seems to have a precedence of (-1).
05:35:12 <hexagoxel> So if your custom Show instance uses type annotations, how can you make that work?
05:35:36 <merijn> hexagoxel: If your custom show uses type annotations, I'm already utterly horrified
05:35:57 <quicksilver> I feel you have gone behind the expected use case of Show instances :)
05:36:20 <hexagoxel> merijn: is it not lawful?
05:36:39 <merijn> I'm not sure, but it's definitely horrible :)
05:36:42 <quicksilver> I think it's fair to say that when Show/Read was designed people weren't thinking in terms of terms which would require type annotations
05:37:10 <quicksilver> but clearly you odn't have to use showsPrec; you can just write your own precedence logic
05:37:20 <quicksilver> explicit params should be safe?
05:37:34 <quicksilver> "((foo)::Bar)" worst case
05:38:22 <quicksilver> (although it can't be reliable, due to qualified imports)
05:38:31 <quicksilver> depending on what you were hoping to rely on it for.
05:40:23 <hexagoxel> syntactic validity is sufficient. that way i can throw a code formatter at the output and get something readable.
05:42:45 <dminuoso> ddellacosta: the only reason comonad might feel more natural is because once you grok Monad you have a much easier time understanding such abstractions.
05:43:48 <dminuoso> ddellacosta: Also comonad has a much more limited set of possible instances in Haskell (mostly because `extract` can often not be implemented), and the existing instances overlap much more strongly than monad instances
06:02:29 <noan> anyone know of a good replacement prelude package that will still be compatible with base etc? kinda new here, but I want one with no unsafe head type stuff
06:03:32 <jchia_> noan: What do you mean by compatibility with base?
06:03:59 <noan> jchia_, er, maybe I'm dumb, but I mean like... it re-exports types that are generally widely used, rather than defining its own.
06:04:05 <noan> ie I still want []
06:05:20 <noan> https://hackage.haskell.org/package/classy-prelude decent?
06:06:29 * hackage asn1-codec 0.2.0 - Encode and decode ASN.1  http://hackage.haskell.org/package/asn1-codec-0.2.0 (andrewthad)
06:06:30 <jchia_> noan: Re-exporting seems like a common approach among alternative preludes, anyway. Personally, I use classy-prelude. It has its uses but it has quirks. I've heard good things about Protolude. Both classy-prelude and protolude are stated as removing partial functions.
06:06:46 <noan> I'll give it a chance for now
06:07:15 <noan> I disabled implicit prelude for builds, and now explicitly importing the default prelude feels dirty
06:07:20 <jchia_> I haven't used Protolude but would like to try it some time when I have time.
06:08:33 <jchia_> Prelude has too much history baggage. I recommend finding an alternative prelude that suits your use case.
06:10:03 <jchia_> noan: With classy-prelude, it's common to need to add annotation or other things to help the compiler because the type inference is weaker
06:10:11 <jchia_> particularly, this happens with the mono-traversable stuff.
06:11:01 <jchia_> it's convenient to just use 'map' on things like Text, but you pay the price with occasionally impaired type inference in other cases.
06:12:34 <jchia_> noan: And quirks like this one: https://github.com/snoyberg/mono-traversable/issues/163
06:17:48 <quicksilver>  hmm giving up newtype deriving seems a high price to pay for roles
06:20:17 <noan> thanks jchia_
06:24:19 <jchia_> One of the reasons I used classy-prelude is so that I don't have to import many different modules qualified in order to use their functions, e.g. lookup from IntMap, Map, HashMap. In this area, classy-prelude is helping. I can just use the 'lookup' function from mono-traversable, sometimes with help to the compiler in the form of something like 'asHashMap'.
06:24:24 <ddellacosta> dminuoso: thanks--just to be clear, I was only talking about how the dual of join (duplicate) was more natural in comonad, vs. how bind is more natural in monad. Right now I've spent more time with monad so my intuition is much stronger there
06:25:27 <ddellacosta> all of that aside your comments about how comonad has a more limited set of instances is useful to understand--it's not clear to me yet what instances exist
06:25:40 <noan> ClassyPrelude seems incompatible with SafeHaskell :8
06:27:37 <Gobester> I'm trying to import Hedgehog into my module, and therefore need to add dependency. Trouble is, a different version of the same dependency exists in my cabal file. Is there a way to resolve this?
06:27:57 <Gobester> besides allow-newer: true
06:31:10 * hackage camfort 0.905 - CamFort - Cambridge Fortran infrastructure  http://hackage.haskell.org/package/camfort-0.905 (madgen)
06:31:38 <dminuoso> ddellacosta: Store is probably the most interesting to look at.
06:31:55 <dminuoso> ddellacosta: Or maybe Tree
06:32:00 <ddellacosta> dminuoso: funny you should say that...I'm trying to figure this out right now: https://www.schoolofhaskell.com/user/edwardk/cellular-automata/part-1
06:32:27 <ddellacosta> I need to figure out how to meaningfully play with Store myself, I'm having a hard time with that now
06:32:40 <ddellacosta> feels like I'm cargo culting all of it atm
06:33:03 <ddellacosta> but, I remember this feeling from learning a bunch of other stuff in Haskell already so it's okay :-D
06:33:47 <shiona_> I have probably asked this before, but does anyone remember a 'diagrams' service that ran online somewhere. One where you could write haskell code and it would use diagrams package to draw an svg on the same page? I haven't been able to find it for a while.
06:33:58 <ddellacosta> Tree seems like it'd overlap with list/zipper/array/etc. kind of comonads
06:34:34 <ddellacosta> er shiona_ weirdly enough that post I _just_ linked to used to do that at one point, apparently...maybe not exactly it but kind of a funny coincidence
06:35:13 <shiona_> The link brought the idea back
06:35:23 <ddellacosta> ah okay nevermind then
06:35:52 <inkbottle> I've "identified" 3 kind of types in Haskell, sum, product and "function type". I feel like there is a discrepancy between the two former and the later: Is there a "deep down" reason behind that discrepancy?
06:36:25 <inkbottle> Among the differences, you cannot pattern match on function type
06:36:53 <inkbottle> It seems to me you almost always can with product and sum
06:37:37 <inkbottle> And you never have data constructor for function type
06:38:11 <inkbottle> Would that be "dangerous" if we could pattern match on function types?
06:41:08 * hackage slate 0.11.0.0 - A note taking CLI tool.  http://hackage.haskell.org/package/slate-0.11.0.0 (evuez)
06:42:00 <Ariakenom> inkbottle: function type is the most general, you don't _really_ need the others. In theoretical "what you can compute" terms
06:42:33 <inkbottle> OK
06:42:43 <Ariakenom> inkbottle: how would you pattern match on functions btw?
06:42:58 <dmwit> Gobester: I'm not sure I understand the problem yet.
06:43:09 <dmwit> Gobester: What ar eth two locations that specify different versions?
06:43:15 <dmwit> Gobester: One is the cabal file; what's the other?
06:43:57 <opqdonut> a function type is just a big product type
06:44:12 <Gobester> the existing dependency is in the stack.yaml file
06:44:19 <dmwit> opqdonut: Yes. Some call it an "exponential".
06:44:21 <Gobester> the subpackage
06:44:36 <Gobester> the subpackage I'm using, when I add hedgehog as a build dependency
06:44:50 <Gobester> it says it needs xxxx-dependency
06:44:52 <dmwit> Why do you need different versions of hedgehog in your cabal and stack configs?
06:45:05 <Gobester> I don't need different versions
06:45:11 <dmwit> So... problem solved?
06:45:22 <Gobester> its asking for an earlier version of a dependency that is already listed
06:45:30 <Gobester> and I can't add both versions to the same stack.yaml file
06:45:56 <dmwit> What is "it" in "its [sic] asking for an earlier version"?
06:46:17 <Gobester> hedgehog is asking for an earlier version of a dependency that is already listed in my stack.yaml file
06:46:21 <inkbottle> Ariakenom: No, it's only I've notice they differ, in their functionalities; and therefore I was troubled, by the lack of symmetry
06:46:36 <inkbottle> noticed*
06:47:03 <dmwit> aha
06:48:00 <Gobester> dmwit: Yep
06:48:49 <dmwit> Gobester: So, you should probably either use an older version of the dependency, a newer version of hedgehog, or vendor hedgehog and update it to support the newer version of the dependency yourself if that hasn't already been done.
06:48:56 <Ariakenom> inkbottle: For example a Tuple as a function with A B as elements would take any function (A->B->c) as argument and return a c.
06:49:36 <ph88> cocreature, i have reduced my code to show the problem ... but it's still in several files
06:49:43 <inkbottle> Ariakenom: I agree
06:49:51 <phadej> Is there a lib to do unsharp mask on juicypixels images (or any finite kernel convolution?)
06:50:01 <Gobester> dmwit: Can't use the older version because it may break other things in the repo, I was currently using the latest version of hedgehog so I guess a solution would be to use an earlier version of hedgehog
06:51:07 <dmwit> uh?
06:51:53 <dmwit> You say "hedgehog is asking for an earlier version of a dependency that is already listed in my stack.yaml file". Surely using an earlier hedgehog would only make that problem worse.
06:53:23 <Ariakenom> inkbottle: so the the lack of symmetry can be explained as sum and product is a limited form that allows pattern matching. Different performance characteristics too. I guess, not sure.
06:54:01 <inkbottle> Ariakenom: makes sense, yes.
06:55:02 <Gobester> dmwit: You're right
06:55:08 <Gobester> dmwit: thanks for the help!
06:59:25 <noan> So what's the deal with specialize/inline for imported functions? I'm assuming this has to do with compiler optimisation and attempting to inline function definitions, and compile after inlining as upposed to compiling the dependant module first and then simply linking?
06:59:37 <noan> I've just got a few compiler warnings about impossible specialization
06:59:43 <noan> trying to make sure I understand right
07:00:36 <dminuoso> noan: https://wiki.haskell.org/Inlining_and_Specialisation
07:00:48 <noan> <3
07:04:37 <mbwgh> How do you translate literate haskell files to, say, pdf?
07:05:24 <Putonlalla> Use `lhs2TeX` and then `pdflatex`, mbwgh.
07:06:56 <mbwgh> Thank you very much.
07:08:40 <mbwgh> Unfortunately, it says `code` is not defined
07:09:06 <ph88> cocreature, i created a bug report for this #15164
07:09:31 <mbwgh> The file starts with a `\begin{code}`
07:10:06 <jchia_> Is there a name for the technique of representing expression trees like L52-65 to facilitate interpretation? https://github.com/llvm-hs/llvm-hs-examples/blob/master/arith/Arith.hs
07:10:33 <jchia_> Does this technique work if I need to work with multiple types (not just Double), e.g. Int64, Double, Bool, in a type-safe manner?
07:11:37 <Putonlalla> @hackage recursion-schemes -- See the fixed point machinery here, jchia_.
07:11:37 <lambdabot> http://hackage.haskell.org/package/recursion-schemes -- See the fixed point machinery here, jchia_.
07:12:02 <jchia_> Putonialla: Can it be made to work with multiple expression types used together?
07:12:20 <Putonlalla> Do you mean mutually recursive types?
07:12:48 <quicksilver> jchia_: TypedExprF t a
07:13:10 <jchia_> E.g. I may have Plus a a that adds two Doubles together, but I also want Select b a a that uses a boolean to select between two values of the same type, hence expressions with multiple types.
07:13:20 <Putonlalla> That's fine.
07:13:51 <merijn> noan: So GHC does a bit of both. In a whole program optimising compiler the compiler will look at ALL code and detect inlining/specialising anywhere, but as you point out that's rather annoying since it leaves you unable to do independent compilation
07:14:02 <jchia_> Putonialla: Thanks. I'm going to check out the library and the paper. When should I use the micro package? http://hackage.haskell.org/package/micro-recursion-schemes
07:14:29 <Putonlalla> I don't know. The other package isn't that big.
07:14:30 <merijn> noan: The other, classic C alternative, is to compiles modules independently and just not inline/specialise things in other modules (obviously a big performance loss, especially for a language like Haskell where many optimisations rely on inlining)
07:15:52 <merijn> noan: GHC takes the middle road, it compiles independently, but if it thinks a function looks promising (or you annotate it) it will dump a representation of it into the interface file, so that when another module links against it can still use those versions to inline "across" the module boundary
07:16:27 <Putonlalla> It doesn't take much effort to roll your own recursion schemes either.
07:17:04 <Putonlalla> Usually one fixed point combinator with `cata` and `ana` is sufficient.
07:17:58 <jchia_> Any recommended path for efficiently learning recursion schemes? I found this: https://github.com/passy/awesome-recursion-schemes. Not sure whether it's good.
07:18:39 <merijn> My approach to using recursion schemes is: Try to read the paper, get endlessly frustrated, give up and just write regular recursive functions while being much happier :p
07:19:27 <Putonlalla> There's a nice series of blog posts about them somewhere.
07:20:05 <Putonlalla> Still, using them is the easiest way to become enlightened.
07:20:43 <Putonlalla> (Finding answers is easier once you know the questions.)
07:21:09 <cocreature> merijn++
07:21:36 <jchia_> Putonlalla: Putonlalla: I do have a concrete syntax at hand that I want to express with recursion schemes and interpret into some language like C or IR.
07:21:56 <merijn> Putonlalla: I try to, but then I waste 30 minutes to do something I can write the naive recursive code for in 20 seconds :)
07:22:07 <merijn> Also, I can actually understand the naive recursive version a month from now :p
07:23:05 <merijn> On the one hand, recursion-schemes seem like cool ideas, on the other hand, the number of examples where they actually do something impressive rather than just make stuff confusing is rather small
07:23:35 <merijn> All in all, not sure if recommend :p
07:23:44 <Putonlalla> It's unlikely that you find a use case for them, but if you do, that's dandy.
07:24:18 <Ariakenom> I'm not a fan of how "naive" is used in computing discourse.
07:24:31 <aarvar> even if you don't use recursion schemes, Fix and open recursion are useful for extensibility
07:24:45 <Ariakenom> checking wiktionary made me more confused https://en.wiktionary.org/wiki/naive
07:24:51 <Ariakenom> (computing) Intuitive
07:25:25 <aarvar> that's probably the main advantage, rather than the little bit of code saved by using cata etc
07:25:31 <jchia_> Ariakenom: I suppose 'naive' just generally means 'unsophisticated'
07:25:56 <unyu> aarvar: Do recursion schemes really save any typing whatsoever?
07:26:12 <jchia_> aarvar: What's the distinction between using Fix and using recursion scheme?
07:26:24 <aarvar> unyu: sometimes
07:26:36 <cocreature> jchia_: they go hand in hand. you use Fix to define your type and recursion schemes to operate on that type
07:27:03 <aarvar> well, you could use Fix without schemes
07:27:15 <aarvar> though you'd essentially just be manually reimplementing them
07:27:16 <Ariakenom> jchia_: Possible. I sort of like wiktionary parsing computing's use of naive into intuitive though
07:27:21 <jchia_> aarvar: So you use something other than recursion-schemes to do the interpretation?
07:28:03 <unyu> Just how regular do your loops have to be so that most of them can be replaced with recursion schemes?
07:28:37 <cocreature> that depends on which recursion scheme you’re talking about
07:28:51 <aarvar> unyu: I would object to the use of the word "loop", but most recursive functions fit the basic patterns
07:29:16 <unyu> Oh, by “loop”, I meant the actual computation, not the code that gives rise to it.
07:29:18 <aarvar> jchia_: you can use what's called "open recursion"
07:29:28 <aarvar> where you take the function to recurse with as an argument
07:29:41 <aarvar> it ultimately amounts to the same thing though
07:30:19 <aarvar> rather than defining an algebra (f a -> a), you could define a function (Fix f -> a) -> Fix f -> a
07:30:25 <aarvar> where the argument is the function to recurse with
07:30:38 <merijn> Ariakenom: You did cut of the part after intuitive
07:30:50 <merijn> Ariakenom: "(computing) Intuitive; designed to follow the way ordinary people approach a problem."
07:30:54 <aarvar> noting that Fix f = f (Fix f), that's the same as (Fix f -> a) -> f (Fix f) -> a
07:30:56 <merijn> The last part seems pretty clear
07:31:29 <unyu> aarvar: The need to pack and unpack the Fix data constructor, alone, is sufficient to discard this route.
07:31:34 <aarvar> the "cata" scheme is where you take the function to recurse with and apply it to each of those inner (Fix f), by mapping f
07:31:35 <Ariakenom> merijn: I considered it unnecessary
07:31:41 <aarvar> unyu: nonsense
07:32:11 <aarvar> unyu: unless you're saying it's better to use the schemes
07:32:12 <merijn> But yeah, in 3 or 4 attempts of using recursion-schemes I have not ever really found it saving much time and it usually added boilerplate and confusion
07:32:19 <aarvar> 1. there are ways to deal with that. and 2. you gain extensibility
07:32:49 <merijn> aarvar: My personal experience just extending by hand as often been just as easy
07:33:01 <unyu> The runtime cost of packing and unpacking the data constructor is annoying, especially if you do it all over the place in the program.
07:33:01 <aarvar> if you have an algebra for f and an algebra for g, then you have an algebra for f + g
07:33:12 <aarvar> unyu: what runtime cost?
07:33:15 <aarvar> Fix is a newtype
07:33:22 <aarvar> and you dont even have to use Fix
07:33:31 <Putonlalla> On that note, has anyone used the "trees that grow" pattern for anything besides GHC?
07:33:43 <aarvar> you can instead have a separate Base functor type via a type family or fundep
07:33:53 <unyu> aarvar: “map Fix” is not the identity function, though. And that's just one example.
07:34:05 <cocreature> unyu: "coerce" is :)
07:34:21 <aarvar> unyu: it can be inlined into identity anyway presumably
07:34:24 <unyu> cocreature: Well, that's not why one would want to use Haskell, is it?
07:34:28 <merijn> aarvar: Eh, how?
07:34:32 <mnoonan> aarvar: not as often as you'd like :|
07:34:40 <merijn> unyu: Are you sure you're not confusing coerce with unsafeCoerce?
07:34:42 <mnoonan> (but see the 'roles' package)
07:34:45 <cocreature> unyu: huh? I don’t see the problem with writing "coerce"
07:34:46 <aarvar> as long as `f` gets specialized
07:34:47 <merijn> unyu: coerce is perfectly reasonable
07:34:49 <aarvar> I would think it would
07:34:52 <unyu> Mmm.
07:35:05 <merijn> :t Data.Coerce.coerce
07:35:06 <lambdabot> Coercible a b => a -> b
07:35:21 <unyu> How exactly is this thing implemented?
07:35:28 <mnoonan> compiler magic
07:35:33 <merijn> unyu: GHC auto derives Coercible instances for newtypes
07:35:40 <unyu> Oh, interesting.
07:35:42 <cocreature> avoiding the cost of "map Fix" is exactly what "coerce" was made for
07:35:44 <aarvar> coerce won't work though actually, thanks to type roles
07:35:50 <merijn> unyu: You can control/disallow certain conversion via role annotations (see GHC guide for details)
07:37:38 <aarvar> and if the fmap doesn't get optimized away then you can use rewrite rules to make it do so, can't you?
07:37:48 <aarvar> once again, as long as f gets specialized
07:38:13 <unyu> Does GHC check that your rewriting rules make sense?
07:38:25 <unyu> Or is it “trust me, I proved this”?
07:38:30 <aarvar> the latter
07:38:33 * hackage opaleye 0.6.7000.0 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7000.0 (tomjaguarpaw)
07:39:13 <aarvar> would be nice if it required proof, but haskell isn't a theorem proving language :(
07:40:08 <aarvar> unyu: if you're not sure about a rule you can go prove it in coq I guess, or maybe with liquid haskell
07:40:08 <merijn> unyu: rewrite rules, like unsafeCoerce, are for when you feel your Haskell experience isn't sufficiently C like :)
07:40:18 <lavalike> unyu: I'm pretty sure there's a Simon PJ talk about how that works, but I can't quite find it right now
07:40:28 <merijn> unyu: i.e. undefined operational behavioural details breaking your shit in subtle ways :)
07:40:44 <unyu> merijn: “insufficiently C like” --> I love that take on it.
07:40:45 <merijn> unyu: Gotta keep life interesting for yourself
07:41:15 <aarvar> has there ever been a case of someone writing an invalid rule?
07:41:27 <merijn> aarvar: Probably
07:41:47 <lavalike> unyu: I can only find the paper, but the talk also covered "roles" just like this document https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf
07:41:54 <unyu> lavalike: Thanks! Checking.
07:41:55 <merijn> unyu: When I get bored with Haskell working to predictably I spice up my life this way: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs ;)
07:42:27 <merijn> On the plus side, it's super fast, so there's that!
07:42:39 <noan> merijn, thanks. Are there significant reasons NOT to mark things for inlining?
07:42:43 <cocreature> merijn: needs more unsafeCoerce!
07:42:48 <noan> if I'm writing an application, not a library especially
07:42:53 <merijn> noan: It will blow up your binary size and compilation will take ages
07:42:59 <aarvar> oh yeah, and catamorphisms are the basis of fusion
07:43:26 <noan> merijn, is there a sort of rule of thumb one can apply for deciding which is the "right" choice?
07:43:30 <lavalike> unyu: it must be here, unfortunately one needs an account to see these but they are free https://skillsmatter.com/legacy_profile/simon-peyton-jones#skillscasts
07:43:42 <aarvar> noan: between what choices?
07:43:47 <merijn> noan: "Profile it and check what part is too slow, then figure out how to make it faster"
07:43:48 <noan> aarvar, inlining and not
07:43:58 <merijn> noan: Where inlining/specialisation is one way of making things faste
07:44:00 <noan> merijn, touché, the same answer as always
07:44:05 <noan> "Just profile if it's slow."
07:44:06 <vaibhavsagar> is there a GHCi-JS that I can run in the browser?
07:44:07 <aarvar> noan: you can look at the core
07:44:10 <merijn> noan: GHC is pretty good at deciding what to inline
07:44:30 <aarvar> and there's also INLINEABLE, not just inline
07:44:30 <merijn> noan: But yeah, if that's not enough you'll find yourself profiling, looking at Core, etc.
07:44:52 <merijn> noan: Note that inlining isn't even guaranteed to make things better, might make things worse
07:44:55 * noan pouts about the compiler warning me that things can't be specialised :(
07:45:07 <noan> merijn, ofc
07:45:09 <aarvar> noan: what?
07:45:15 <merijn> noan: I don't think that's a standard warning, though
07:45:23 <noan> src/Main.hs: warning:
07:45:23 <noan>     Could not specialise imported function ‘Helm.Keyboard.presses1’
07:45:23 <noan>     Probable fix: add INLINABLE pragma on ‘Helm.Keyboard.presses1’
07:45:30 <noan> ah, maybe I can just turn it off
07:45:41 <aarvar> are you using -Weverything?
07:45:42 <merijn> noan: How did you enable warnings?
07:45:56 <noan> aarvar, yes, but with specific ones turned off where appropriate
07:46:06 <merijn> noan: Unlike gcc/C++ you probably want -Wall, not -Weverything
07:46:20 <merijn> noan: Because, unlike gcc and co, -Wall does in fact hold all sane warnings
07:46:28 <aarvar> or most of them
07:46:34 <aarvar> wasnt it missing a couple?
07:46:39 <maerwald> there is little material on how to improve haskell performance, people just keep saying you have to profile stuff and figure out something
07:46:48 <merijn> aarvar: There's a bunch not in -Wall, but those are also not always sane
07:47:07 <aarvar> merijn: it was missing the one for warning against \(x:xs) -> ...
07:47:10 <merijn> noan: You *might* want to add -Wcompat too if you like being paranoid
07:47:13 <noan> I for my own sake want to experiment with -Weverything, disabling those I find non-helpful, then see what I wend up with
07:47:54 <merijn> noan: -Wall are ALL warnings that are actually important and -Wcompat contains warnings that WILL become issues in future versions of GHC (so you can enable it to future-proof your code)
07:48:11 <merijn> aarvar: tbh I don't think that one is very important
07:48:41 <merijn> aarvar: Because to me it's "obvious"
07:48:42 <aarvar> merijn: I don't think I've ever made that mistake, but still seems like it should be on by default
07:48:56 <aarvar> but yes, not that important
07:49:03 <aarvar> but it is sane
07:49:32 <merijn> I usually want it disabled because if I write pattern matching lambda's that's usually to not have a case with GHC complaining ;)
07:49:45 <maerwald> it boils down to trying random things and then admit you still don't know why the thing you tried is faster than the other
07:50:38 <dminuoso> So interesting.. GHC doesn't provide me with some thread join mechanism - it's almost as if GHC promotes realizing it's a software problem that can be solved directly, rather than blindly adhering to some opionated thread model that POSIX wants me to use.
07:50:44 * hackage sbv 7.8 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-7.8 (LeventErkok)
07:50:59 <noan> I personally want to be trained by the compiler for now to have "good habbits"
07:51:09 <noan> so things like -Wmissing-exported-signatures
07:51:11 <merijn> noan: Right, but that's what -Wall is for :)
07:51:31 <noan> Oh, I missread.
07:51:31 <merijn> noan: That one is in -Wall :)
07:51:40 <aarvar> noan: what does that one do?
07:51:48 <noan> for some reason I was reading the -Wall list as -Weverything
07:51:52 <noan> yeah then I'm happy
07:52:26 <noan> aarvar, warns if you lack a type signature for a top level export
07:52:30 <merijn> noan: Stuff like the inlinable warning is for when you're actively trying to find stuff you missed when trying to optimise, rather than merely "good clean coding standards"
07:53:13 <merijn> noan: Well, that one ISN'T in -Wall, because -Wall by default is stricter
07:53:28 <merijn> noan: -Wmissing-exported-signatures only complains about missing signaturs on exported functions
07:53:41 <merijn> noan: By default -Wall complains about ANY top level function without a signature
07:53:47 <merijn> Even when not exported
07:54:59 <noan> ah
07:55:21 <noan> thanks guys
07:55:43 <noan> I want to bring haskell into my day-job and I want to learn good habbits asap if I'm gonna be the one pushing for it :3
07:58:14 <aarvar> noan: use unsafePerformIO a lot
07:58:39 <merijn> pfft
07:58:40 <merijn> boring
07:58:46 <merijn> unsafeCoerce is where it's at
07:58:52 <merijn> And, of course
07:58:58 <merijn> reallyUnsafePtrEquality#
07:59:11 <dminuoso> removeIO (IO m) = case m realWorld# of (# _, r #) -> r
07:59:13 <dminuoso> It's so clear
07:59:13 <cocreature> you shouldn’t use anything whose name doesn’t end in a magic hash
07:59:29 <merijn> cocreature++
07:59:33 <aarvar> merijn: unsafePerformIO is equivalent to unsafeCoerce isn't it?
08:00:02 <merijn> cocreature: Well "Any" is probably also fine
08:00:08 <merijn> aarvar: Not really
08:00:09 <aarvar> you can at least derive the latter from the former, and i think you can derive the former from the latter?
08:00:15 <merijn> aarvar: By which I mean, absolutely not :p
08:00:21 <aarvar> merijn: how so
08:00:26 <merijn> You can create unsafeCoerce via unsafePerformIO, yes
08:00:27 <cocreature> merijn: we need to rename Any to Any#!
08:00:40 <merijn> But I don't think you can recreate unsafePerformIO with unsafeCoerce
08:00:41 <dminuoso> merijn: How does that work?
08:00:52 <cocreature> dminuoso: it’s literally in the docs of unsafePerformIO :)
08:01:00 <aarvar> merijn: in that case unsafePerformIO would be more dangerous :)
08:01:02 <merijn> dminuoso: Put it in an MVar with polymorphic type, then read it
08:01:09 <setre> is ordNub in the standard library?
08:01:15 <cocreature> setre: no
08:01:21 <setre> cocreature: thanks
08:01:26 <dminuoso> cocreature: It's just mentioned _that_ its possible
08:01:27 <Ariakenom> do we need an unutterableAcursed link?
08:02:12 <merijn> And still I prefer reallyUnsafePtrEquality# in terms of names :)
08:02:20 <cocreature> dminuoso: well it has code that converst from [Int] to [Char]. it should be pretty easy to generalize that to a -> b :)
08:02:28 <aarvar> merijn: isn't `IO a` represented as `a`?
08:02:36 <aarvar> I wonder if you can define unsafePerformIO = unsafeCoerce
08:02:41 <aarvar> probably not, but maybe?
08:02:52 <cocreature> % unsafePerformIO (putStrLn "hello world")
08:02:53 <yahb> cocreature: hello world; ()
08:03:02 <cocreature> % unsafeCoerce (putStrLn "hello world") :: ()
08:03:03 <yahb> cocreature: ()
08:03:22 <aarvar> :/
08:03:33 <aarvar> oh
08:03:34 <dminuoso> cocreature: Ah I was just looking for unsafeCoerce, mentally skipped that code. ;-)
08:03:35 <aarvar> you could use runST
08:03:38 <aarvar> maybe?
08:03:50 <aarvar> yeah, that'd probably work
08:05:06 <merijn> aarvar: No, IO a is "State# RealWorld -> (#State# RealWorld, a#)"
08:05:26 <aarvar> merijn: IO a is ST RealWorld a, no?
08:05:27 <merijn> aarvar: See here: https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/GHC-Types.html#t:IO
08:05:34 <aarvar> which you could coerce to ST s a, and use runST on
08:05:42 <merijn> aarvar: ST and IO are both specialisation of State#
08:05:52 <aarvar> right
08:05:55 <merijn> aarvar: Hence why you can convert ST to IO (but not vice versa)
08:06:08 <aarvar> what?
08:06:19 <aarvar> can't you convert IO to ST RealWorld?
08:06:26 <electrocat> yeah
08:06:38 <aarvar> so then you can get unsafePerformIO with unsafeCoerce and runST
08:06:45 <merijn> aarvar: IO *is* "State# RealWorld", but ST is "State# a"
08:06:58 <merijn> aarvar: So you can convert ST to IO by restricting the State# argument
08:07:06 <merijn> aarvar: But you cannot generalise the State# argument
08:07:13 <aarvar> merijn: huh?
08:07:20 <merijn> So you can convert arbitrary ST actions into IO actions, but not vice versa
08:07:32 <aarvar> IO a = State# RealWorld -> (#State# RealWorld, a#)
08:07:43 <merijn> aarvar: What you're saying is the exact reason you can't do that :p
08:07:43 <aarvar> ST s a = State# s -> (#State# s, a#)
08:07:53 <aarvar> IO a = ST RealWorld a
08:08:06 <merijn> aarvar: Right, so ST can be converted into IO
08:08:13 <aarvar> and IO into ST RealWorld
08:08:13 <electrocat> by instantiating s with Realworld
08:08:25 <merijn> aarvar: You cannot "runST" "ST RealWorld"
08:08:29 <aarvar> merijn: duh
08:08:32 <aarvar> because of the forall
08:08:35 <merijn> aarvar: runST requires the state parameter to be polymorphic ;)
08:08:37 <aarvar> that's where you need unsafeCoerce :)
08:08:52 <aarvar> unsafeCoerce :: ST RealWorld a -> ST s a
08:08:54 <electrocat> aarvar: yeah unsafeIOtoST is implemented as unsafeCoerce
08:09:00 <aarvar> or unsafeCoerce :: IO a -> ST s a
08:09:35 <electrocat> unsafeIOToST (IO io) = ST $ \ s -> (unsafeCoerce# io) s
08:10:54 <merijn> And people complain haskell is too safe to do what they want... :p
08:10:59 <aarvar> % let x = runST $ unsafeCoerce $ putStrLn "hello" in x
08:10:59 <yahb> aarvar: hello
08:11:06 <Putonlalla> > add''quotes''around"this"
08:11:09 <lambdabot>  ''this''
08:11:12 <aarvar> % let x = runST $ unsafeCoerce $ putStrLn "hello" in show x
08:11:13 <yahb> aarvar: "hello; ()"
08:11:18 <aarvar> see, works
08:11:29 <aarvar> so unsafePerformIO is equivalent to unsafeCoerce
08:11:36 <aarvar> if you have runST
08:11:46 <aarvar> and STRef
08:12:29 <electrocat> that's interesting because they use different primitives
08:13:11 <aarvar> hmm, why isn't unsafePerformIO just defined like that
08:13:27 <merijn> aarvar: Instead of?
08:13:56 <merijn> Anyway, time to go
08:14:06 <electrocat> well in the end you're doing the same thing
08:14:24 <electrocat> except you're now adding an unsafeCoerce
08:15:18 <aarvar> yeah, nvm :)
08:15:34 <electrocat> runST and performUnsafe is just runRW#
08:17:58 <electrocat> i've got a function that lifts a rewrite rule from rewriting single constraints to performing a rewrite in a set of constraints
08:18:02 <electrocat> how do i call this function?
08:19:59 <ventonegro> I'm finding that typing lots of "hPutStr out blah" becomes ugly quickly, so part of me wants to do "traverse (hPutStr out) <list of strings>" but know I am creating a new list just for aesthetic reasons. Is it too bad?
08:20:18 <ventonegro> traverse_
08:20:29 <aarvar> ventonegro: you arent creating a new list, most likely
08:20:46 <electrocat> indeed, just use the list
08:21:01 <aarvar> ventonegro: it can be fused away, and even if it isn't, due to lazy evaluation it wont get held in memory
08:21:04 <electrocat> it will be optimised away probably
08:21:36 <ventonegro> Cool, thanks for the validation guys :)
08:21:41 <dyl> fishythefish: what’s this about cuing me?
08:22:06 <fishythefish> ah, there was a conversation about terse code in languages with symbol alphabets
08:22:12 <dyl> Am I the goto APL person now? I’m still learning the language as I implement it! The basic structure is easy but learning how to problem solve in it takes practice (much like Haskell).
08:22:17 <dyl> Clearly we need emoji.
08:22:38 <dyl> Maybe I should start with an Emojilude hackage package.
08:22:45 <dyl> The entire Haskell prelude, in emoji.
08:23:05 <dyl> I don’t know how that would work with type constructors vs values w.r.t. casing though.
08:23:28 <dyl> https://twitter.com/t3xtm0de/status/600711130324008961?lang=en
08:23:58 <quicksilver> emoji are operators I think
08:24:32 <quicksilver> I do kind of like hieroglyphics for type vars
08:24:42 <quicksilver> although it depends on the font in your editor whether I *actually* like it
08:25:13 <dyl> Modern OS’ usually have fallback typefaces for missing characters.
08:25:35 <dyl> Most typefaces don’t implement all the weird stuff, just a couple system typefaces.
08:25:39 <quicksilver> yeah but for it to be nice you want it to work and have compatible line weights with the rest of your text
08:25:46 <quicksilver> which you are unlikely to get with a fallback font.
08:26:01 <dyl> I do like using Fira Code with Haskell
08:26:06 <dyl> The ligatures are nice.
08:26:39 <dyl> Otherwise I use Source Code Pro or plain old Menlo.
08:32:17 <centril> Hey folks; Is anyone here familiar with the publishing industry?
08:32:35 <centril> (i.e: written a book, or something..)
08:40:31 <EvanR> dyl: https://twitter.com/emojihaskell
08:45:31 <albeit> Reading https://two-wrongs.com/dynamic-dispatch-in-haskell-how-to-make-code-extendable, and have a couple questions: how do you do the same style of dynamic dispatch if certain commands take "args" of different types, or their "exec" return different types? Seems like it works because everything is just thrown into Strings
08:47:42 <EvanR> it looks like the point there is to use a record of functions instead of a type class, not to use strings
08:47:44 <infandum> In Control.Foldl, what is the id fold? Like, just return the structure the way it was?
08:48:23 <EvanR> when you do this, you are coming up with a common interface that clients of your "extendable" code can use
08:48:27 <glguy> infandum: I wouldn't expect there to be one
08:48:38 <albeit> EvanR but all the functions are required to use strings for both input and output no? It doesn't seem very extendable if everything has to deal with raw strings
08:48:50 <EvanR> if you say that different extends need a different interface... youre not doing that
08:49:10 <EvanR> i dont think the string thing was particular relevant
08:49:37 <glguy> albeit: Change String to whatever result type you need it to be
08:49:59 <EvanR> do you have an example of two implementations of one interface, but you think they need two different argument types?
08:50:01 <albeit> But how would I make different invocations, one that has args :: [Int], and one that has args :: [Text]?
08:50:04 <EvanR> or result types
08:50:23 <glguy> albeit: You'd parse the strings as Ints if a particular command chose to interpret the args as ints
08:50:55 <mupf> Hello
08:51:07 <mupf> Does anyone know ertes in here?
08:51:18 <mupf> This is really important and I have very sad news.
08:51:22 <EvanR> :(
08:51:24 <albeit> Hmm... so if the messages were being read off a socket, instead of args :: String, I could make args a socket, and then the function is responsible for parsing its own arguments?
08:51:40 * hackage gi-cairo 1.0.17 - Cairo bindings  http://hackage.haskell.org/package/gi-cairo-1.0.17 (inaki)
08:51:54 <infandum> glguy: Why not?
08:52:08 <glguy> albeit: of course, all that matters is that there's some format from which you can distinguish a command and then each of those commands can parse the rest of the arguments as relevant to them
08:52:28 <glguy> infandum: Because folds are about being able to go from many values to one value
08:53:26 <EvanR> mupf: yes everybody knows ertes here, used to be mmfreak
08:53:31 <infandum> glguy: What about Fold.list?
08:53:58 <glguy> infandum: what about it?
08:54:36 <infandum> It returns all of the values in another container
08:54:46 <fishythefish> it's a single list value
08:54:52 <glguy> OK, but that doesn't make it an identity fold
08:54:55 <albeit> Okay, I think its clarifying. So instead of parsing a full message from the socket into a giant sum type and then dispatching each message to a function, I would instead write a number of functions that are responsible for parsing the rest of their arguments and performing an action?
08:55:11 <infandum> That's true, but it returns all of the values
08:55:22 <EvanR> albeit: so this is specific to being able to change out command parsers, so it makes sense for the interface to take strings
08:55:30 <glguy> and it only returns the structure the way it was in the special case that you happen to be consuming a list
08:55:50 <EvanR> the same pattern works for other situations, if you want to switch out other things, youd have a different common interface
08:55:56 <glguy> albeit: Yeah, that statement makes sense
08:55:59 <fishythefish> infandum: yes, but only in a list
08:56:56 <infandum> glguy: My goal is to divide all elements in a foldable by the sum, without loading the whole thing into memory
08:57:40 <glguy> infandum: That won't be possible
08:57:50 <albeit> Is there an example anywhere of a large-ish app that uses some form of dynamic dispatch for network messages?
08:57:55 <glguy> The whole thing has to load to compute the sum
08:58:01 <glguy> because you have to know the sum to divide by it
08:58:39 <EvanR> if you can request the foldable twice
08:58:51 <EvanR> first pass compute the sum, second pass do the mapping
08:59:16 <infandum> glguy: True, but you don't need to load the whole structure into memory as you can get the sum consuming with constant memory, then fmap divide consuming constant memory
08:59:42 <infandum> EvanR: True, but calling the variable twice, in my experience, loads it all into memory
08:59:48 <EvanR> but if this is like linear types, and you can only consume once, youre screwed
08:59:54 <glguy> infandum: For that to work you'd have to generate the list twice independently
09:00:21 <infandum> like f xs = fmap (/ m) xs where m = sum xs would probably hold xs in memory
09:00:22 <glguy> infandum: In that case you don't need anything special, just apply 'sum' to the structure the first time and then fmap with division the second time you generate it
09:00:23 <EvanR> infandum: its possible to defeat that behavior if its begin generated from a thunk
09:01:33 <glguy> albeit: What're you trying to do specifically?
09:01:35 <jchia_> cocreature: Question about llvm-hs/llvm-hs-pure: What do I use to assign a value to a temporary variable?
09:02:28 <unyu> lavalike: I guess I found one downside of Coercible. Since it's based on a type class, you can't make a coercion applicable “here” but not “there”.
09:02:45 <infandum> That function is what I would want to use, however
09:02:50 <albeit> I have a giant sum type of all message type that just feels wrong, and I want to make it easier to add different message types without modifying the sum everytime.
09:03:17 <glguy> albeit: OK, I have an example in my IRC client
09:03:37 <unyu> What's wrong with a gigantic sum of all possible classes of messages?
09:04:38 <glguy> albeit: Maybe this is relevant, a configuration file can select various "hook" modules to install that will process messages as they come through. Hooks are defined by implementing this record
09:04:39 <glguy> https://github.com/glguy/irc-core/blob/v2/src/Client/Hook.hs#L55-L60
09:04:41 <albeit> Not sure... just feels like a giant monolithic object
09:04:46 <dyl> EvanR not emoji enough.
09:04:47 <dminuoso> albeit: It's not?
09:04:53 <dyl> I still see english.
09:05:17 <dyl> This one is deep: "empty :: 🕗 -> a"
09:05:18 <glguy> albeit: and then as messages come through they are run through all the configured "hooks" to see if that hook applies to it: https://github.com/glguy/irc-core/blob/v2/src/Client/EventLoop.hs#L245-L250
09:05:22 <dminuoso> albeit: It's *product* types that are giant.
09:05:47 <glguy> albeit: Similarly all /commands are stored in a big map, and when the user types one the command is looked up from the map to see how its handled
09:05:53 <glguy> and that entry is responsible for processing its arguments
09:06:43 <glguy> albeit: Here's the datastructure that stores the lists of commands supported, and that can be altered at runtime: https://github.com/glguy/irc-core/blob/v2/src/Client/Commands.hs#L303-L313
09:06:54 <glguy> rather than having a large sum type of all the commands
09:07:39 <jchia_> cocreature: Is it that when I use an instruction like add or fadd in LLVM.IRBuilder.Instruction, the result itself is the temporary variable?
09:08:06 <albeit> Thanks glguy, just reading through it now
09:08:23 <jchia_> so I don't get to control the name
09:17:21 <albeit> glguy: Why did you choose to use that method, instead of a sum type of the possible commands?
09:17:55 <glguy> albeit: Because this makes it easier to package up the parser with the commands and to reflect on the commands supported to make an in-client list of the commands and their documentation
09:19:28 <albeit> So some clients would not support certain commands?
09:23:45 <glguy> albeit: If you wanted, I don't actually remove commands. The primary benefit is being able to enumerate the supported commands at runtime and bundling up a command's logic, parser, and documentation in one place
09:29:46 <filwisher> Is it possible to get cabal to print out the linker flags it would use for a specific ".cabal" target? I can build with `ghc-options: -v` and copy and paste the output but I would like to be able to pull the paths out in a build script so it's not just tied to my machine
09:32:27 <cocreature> jchia_: a basic block is composed of a sequence of Named Instruction. you create assignments using the := constructor of Named
09:34:42 <cocreature> jchia_: oh you’re talking about IRBuilder, yeah then just use the result you get from "add"
09:35:55 <cocreature> jchia_: you can use "named" to give name suggestions if you want a more readable output
09:51:58 <AWizzArd> Is Data.HashTable offering the best performing mutable hashmap implementation for Haskell? I see that it is ca. 40% faster than a Data.Map for insertions 425 msecs for Data.Map vs 258 msecs for Data.HashMap on my system for a million inserts.
09:52:16 <AWizzArd> But then again a mutable HashMap on the JVM let’s me insert a million entries in about 35 msecs.
09:53:46 <AWizzArd> For a million reads (all vals from the map) the picture is then again surprising: 82 for Data.Map but 281 for Data.HashMap. So the mutable map is even slower than the immutable one for reads.  And the JVM reads its million entries in just 30 msecs.
09:54:22 <AWizzArd> I wonder if I did something wrong or if not why Haskell can’t come closer to what the JVM does.
09:54:53 <AWizzArd> Essentially I copied the benchmarks from the criterion examples, so I think they’re fine.
09:54:55 <Athas> Data.HashTable isn't mutable, is it?
09:55:14 <Athas> Oh, it is.  I confused it with something else.
09:55:23 <Athas> (Data.HashMap.)
09:56:25 <AWizzArd> The immutable map is performing nicely. Not ultra fast but it offers way more functionality than a mere JVM HashMap. So I see some value there.
09:58:40 <EvanR> have you tried IntMap
09:59:18 <AWizzArd> EvanR: yes, and those offer times of 128 msecs for writing and 73 msecs for reading.
09:59:35 <EvanR> for a million entries?
09:59:40 <AWizzArd> si, on my hardware
09:59:49 <EvanR> sounds pretty good :)
10:00:00 <AWizzArd> Indeed, this is pretty good. Plus this is the immutable thing.
10:00:27 <AWizzArd> I saw the immutable version on the JVM: 675 for creation and 275 for reading.
10:00:27 <EvanR> mutable anything within haskell incurs writer barrier penalities, and mutable anything outside haskell gets FFI penalty :(
10:00:30 <Athas> My guess is that Data.HashTable is a relatively naive implementation, while the JVM's hashtable is probably very highly tuned and well-engineered.
10:01:09 <Athas> Data.HashTable cites a thirty year old paper for its design.  Maybe the JVM is based on more recent research.
10:01:13 <EvanR> HashTable had a lot of work done on it, it just did win in haskells immutable environment
10:01:21 <EvanR> didnt*
10:01:32 <EvanR> and yeah java has had more money spent on it
10:01:37 <AWizzArd> The basic JVM HashMap code seems to be from 1997: http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/HashMap.java?av=f
10:02:22 <EvanR> you could use something like java-bridge or inline-java :)
10:02:37 <AWizzArd> Nah, I don’t want that for sure.
10:02:48 <AWizzArd> Frege would give me native access anyway if I had to.
10:03:10 <AWizzArd> I was just wondering what the reasons might be that Haskell couldn’t do a bit better here if mutability is allowed.
10:03:27 <c_wraith> that package shouldn't be relied on.
10:03:39 <AWizzArd> c_wraith: which one?
10:03:53 <Athas> It's very easy to write Haskell code that performs heap allocations for thunks and such.  On the other hand, it's easy to write Java code that does not allocate at all.
10:04:06 <Athas> If the Java code is very finely tuned to not allocate on the critical paths, then that can easily tip the balance.
10:04:13 <c_wraith> whatever provides Data.Hashtavle
10:04:19 <Athas> c_wraith: base?
10:04:28 <AWizzArd> c_wraith: this was Data.HashTable.IO
10:04:31 <EvanR> hashtables
10:04:50 <c_wraith> try things like unordered-containers for highly-optimized pure hash tables
10:04:56 <EvanR> i havent seen anyone win using that package yet
10:05:09 <dyl> Athas I wonder how one might define a subset of Haskell which is friendly wrt not performing too many heap operations.
10:05:13 <AWizzArd> c_wraith: okay good
10:05:17 <dyl> Stackskell so to speak.
10:05:30 <Athas> dyl: this language is a start: https://github.com/ollef/sixten
10:05:34 <EvanR> Registerskell please
10:05:38 <Athas> It looks very cool.  Unboxed functional programming!
10:06:23 <AWizzArd> c_wraith: now that you mention it: I already put that dependency into my package.yaml file but forgot to write an implementation for benching.
10:06:44 <EvanR> AWizzArd: what... you didnt try HashMap (haskell) yet o_O
10:07:13 <Athas> HashMap is really good in my experience.
10:07:17 <AWizzArd> EvanR: do you mean Data.HashMap.Strict ?
10:07:28 <alexteves> huh can I get HSpec to print assertion failures in multiple lines, rather than one big string full of \n?
10:07:31 <AWizzArd> From the unordered-containers?
10:07:34 <EvanR> yes, thats unordered-containers
10:07:45 <alexteves> or maybe it's HUnit here? I'm using assertEqual
10:07:53 <c_wraith> note that unordered-containers had a lot of work done. ghc was actually patched a couple times to improve the performance of the underlying HAMT used in unordered-containers
10:08:00 <AWizzArd> EvanR: right, I did not try it yet. I did download the dependency but didn’t try it yet. But I will quickly do now.
10:08:11 <EvanR> also https://github.com/haskell-perf/dictionaries
10:08:24 <EvanR> might be old at this point
10:12:28 <AWizzArd> EvanR: no I made a mistake by forgetting about the bench test for the unordered HashMap implementation. But I’m doing this now and will see how that performs.
10:13:06 <Athas> But you probably cannot expect to beat the JVM on performance in places where the JVM is strong.
10:13:08 <EvanR> always a good contest
10:13:13 <Athas> A huge amount of engineering has gone into it.
10:13:18 <cocreature> the hashtables package is just kind of slow
10:14:00 <cocreature> I started working on a new implementation of mutable hashtables in Haskell last week but haven’t gotten around to doing comprehensive testing and benchmarking so far
10:14:24 <cocreature> but on a simple “insert a million entries” benchmark, it’s about twice as fast as hashtables and I haven’t done anything particularly clever so far
10:15:42 <cocreature> which is kind of embarassing given that hashtables even goes as far as implementing parts in C
10:15:59 <c_wraith> for what it's worth, unordered-containers was built to compete with clojure's default map type.
10:16:38 <c_wraith> it's the same data structure (immutable hashed array-mapped trie)
10:17:23 <c_wraith> so if you want the most apples-to-apples comparison of performance between ghc and the jvm, that's the target to compare against.
10:17:51 <AWizzArd> Hmm, this comes as a surprise. The HashMap from Data.HashMap.Strict performs very bad.  780 msecs for creation and 256 for reading.    (vs. 425 and 83 for Data.Map)
10:18:27 <AWizzArd> My fn signature is this:  makeHM :: Int -> HM.HashMap Int Int    and the implementation is   makeHM n = foldl' (\m k -> HM.insert k k m) HM.empty [0..n]
10:18:45 <AWizzArd> bench "makeHM" $ whnf makeHM 1000000
10:18:52 <AndreasK> Data.Map or Data.Map.Strict?
10:19:03 <AWizzArd> Data.Map.Strict
10:19:11 <EvanR> Data.HashMap.Strict
10:19:27 <AWizzArd> import qualified Data.HashMap.Strict as HM
10:20:16 <AndreasK> AWizzArd: Although I assume the advantage of the hashmap would be in lookup, not on insert
10:20:37 <EvanR> nah its supposed to be good at everything :)
10:21:13 <EvanR> clojures version also has this gimmicky thing to speed up appending at the end
10:21:36 <EvanR> stuff people seem to want to do
10:22:19 <AWizzArd> Data.Map.Strict’s (Map Int Int): 425/83.    Data.HashMap.Strict’s (HashMap Int Int): 780/256.        Data.HashTable.IO’s (HashTable Int Int): 254/277
10:22:51 <AWizzArd> First number is for creating a map with a million key/value pairs.  Second number for reading all one million vals (via key lookup).
10:22:54 <cocreature> AWizzArd: might be interesting to test it with a newtype for Int where the hash function is just the identity
10:23:06 <dyl> This always amused me: http://ridiculousfish.com/blog/posts/array.html
10:23:08 <dyl> Not Haskell but still.
10:23:33 <AWizzArd> The huge winner seems to be Data.Map.Strict. It’s immutable and ordered and has very nice lookup functions and is very fast for lookups.
10:23:45 <AWizzArd> The candidate that should be the best performer is the slowest.
10:24:04 <EvanR> for Int... use IntMap
10:24:44 <EvanR> also i demand a recount
10:24:58 <AWizzArd> For Data.IntMap’s (IntMap Int): 128/73
10:30:48 <woodson> are record sum type something to be avoid ? So, data SomeData = M1 { unwrap :: SomeData1 } | M2 {unwrap2 :: SomeData2 } etc..
10:31:13 <EvanR> unwrap (M2 x) ==> *explode*
10:31:17 <mnoonan_> woodson: yes, it makes all of those record accessor functions partial
10:32:11 <EvanR> now unwrap and unwrap2 take more thinking to use correctly, for anyone whoever works on the code
10:32:32 <dminuoso> @let data SomeData = M1 { unwrap :: Int } | M2 { unwrap2 :: Float }
10:32:34 <lambdabot>  Defined.
10:32:34 <EvanR> and there will always be the nagging feeling that the running code will crash
10:32:44 <dminuoso> > unwrap (M2 1.0)
10:32:47 <lambdabot>  *Exception: No match in record selector unwrap
10:35:01 <woodson> wait why did it blow up?
10:35:08 <woodson> no march in record selector?
10:35:21 <woodson> it doesnt know where the unwrap is coming from?
10:35:41 <EvanR> what did you expect it to return
10:35:46 <woodson> https://www2.gogoanime.se/grancrest-senki-episode-19
10:36:01 <EvanR> unwrap returns an Int
10:36:08 <EvanR> which int would it return
10:36:13 <woodson> @let data SomeData = M1 { unwrap :: Int } | M2 { unwrap2 :: Float }
10:36:14 <lambdabot>  .L.hs:173:1: error:
10:36:15 <lambdabot>      Multiple declarations of ‘SomeData’
10:36:15 <lambdabot>      Declared at: .L.hs:170:1
10:36:18 <woodson> :t unwrap
10:36:20 <lambdabot> SomeData -> Int
10:37:03 <geekosaur> unwrap implicitly pattern matches against M1 because that's what it's defined for,  so if you feed it an M2 it throws
10:37:59 <gobb> I'm currently adding a dependency to my cabal file. I'm adding `hedgehog >= 0.6`
10:38:12 <gobb> but then ghc complains about hedghog-0.5
10:38:17 <geekosaur> unwrap x = case x of { M1 a -> a; _ -> error "No match in record selector unwrap" }
10:39:00 <EvanR> not a very friendly accessor function
10:39:11 <geekosaur> yes, well, now you know why lens exists
10:39:38 <EvanR> @let useless x = case x of { M1 a -> Left a; M2 b -> Right b }
10:39:39 <lambdabot>  Defined.
10:39:40 <dminuoso> geekosaur: That would be prisms though, wouldnt it?
10:39:42 <EvanR> :t useless
10:39:44 <lambdabot> SomeData -> Either Int Float
10:39:54 <EvanR> > useless (M1 2)
10:39:55 <geekosaur> I mean the package
10:39:56 <lambdabot>  Left 2
10:39:57 <dminuoso> ah
10:39:59 <EvanR> > useless (M2 1.0)
10:40:01 <lambdabot>  Right 1.0
10:40:03 <EvanR> \o/
10:40:26 <woodson> wait so..
10:40:37 <woodson> record fields translate to case of?
10:40:45 <woodson> when accessing them?
10:40:52 <EvanR> for sums
10:41:07 <woodson> oh wow...
10:41:08 <EvanR> otherwise its field (K _ _ _ x _ _) = x
10:41:13 <woodson> I did not know this
10:41:40 <woodson> so the best way to know have to pattern match everything is to use lenses?
10:41:43 <EvanR> what did you think would happen? :)
10:42:12 <woodson> EvanR: Honestly this is the first time that I am giving it some thought
10:42:22 <geekosaur> also the field (K _ _ _ x _ _) silently also becomes a case
10:42:27 <woodson> so I never thought about what would happen
10:43:14 <woodson> So, how would lenses help me in this case?
10:43:23 <woodson> can you guys just show me briefly the difference
10:43:29 <dminuoso> > mfix Right
10:43:32 <woodson> I dont usually use lense
10:43:32 <lambdabot>  Right *Exception: <<loop>>
10:43:48 <dminuoso> How can I trivially construct `Right ( Right ( Right ( Right ...` ?
10:43:58 <EvanR> woodson: what do you want to happen when you try to access the wrong thing?
10:44:36 <woodson> EvanR: Why would I access the wrong thing?
10:45:03 <EvanR> because youre accessing a field that does not exist
10:45:08 <EvanR> because you asked to
10:45:12 <lyxia> dminuoso: you can't because it has an infinite type
10:47:01 <woodson> EvanR: Ok, say we have a type BadType String in the sum type
10:47:09 <woodson> this is what it would return
10:47:10 <jbetz> what does it mean if a type is prefixed with `@`? e.g., `encodeUtf8 @Text @ByteString "патак"`
10:47:36 <dminuoso> jbetz: TypeApplications
10:47:58 <woodson> EvanR: @let data SomeData = M1 { unwrap :: Int } | M2 { unwrap2 :: Float } | BadType Text
10:48:40 <aarvar> you shouldn't use non-total record selectors like that
10:48:48 <aarvar> just delete them. problem solved
10:48:51 <EvanR> agreed
10:49:45 <EvanR> woodson: it would return a data type declaration?
10:49:45 <dminuoso> jbetz: Basically type variables are implicitly universally quantified. That is: `length :: forall a. [a] -> Int`. To use `length` you have to specify what `a` is - GHC figures this out for you, but sometimes it may be ambiguous. It's then frequently too annoying to specify a full type signature.
10:50:41 <EvanR> but if you dont specify a pull type signature, you might not understand what your application is being applied to
10:50:44 <EvanR> full*
10:52:20 <woodson> aarvar: I am not trying to use them now, I am trying to understand the reason for later on
10:52:34 <woodson> saying not to just use them doesnt help me later on
10:52:42 <aarvar> woodson: because they generate partial functions
10:52:45 <aarvar> partial functions are bad
10:52:51 <EvanR> we went over all that
10:52:59 <EvanR> now were trying to understand what woodson wants
10:53:56 <dminuoso> jbetz: And in some cases it might not even be possible to specify a type signature, say because you have an ambiguous type. Imagine we had some `class Sizeof a where bitSize :: Int`
10:54:08 <dminuoso> jbetz: How could you possibly use bitSize?
10:54:10 <woodson> EvanR: I believe that I said ealier how would lenses help me ?
10:54:32 <woodson> because someone mention this is the reason why we have lenses
10:54:35 <woodson> right?
10:54:42 <EvanR> i asked a question twice
10:55:00 <EvanR> you said "it will return this:" and gave something nonsensical
10:55:27 <EvanR> lenses do a lot of stuff
10:55:33 <aarvar> er, optics
10:55:39 <EvanR> but you have to know what you want
10:55:43 <aarvar> in this case you'd probably want a prism, though I don't really know
10:55:54 <EvanR> thats one possibility
10:57:28 <phadej> to answer my "Is there a lib to do unsharp mask on juicypixels images (or any finite kernel convolution?)": looks like I can easily add that to my own JuicyPixel-scale-dct (as I need symmetric kernels only)
10:57:37 <geekosaur> woodson, I said that because basic Haskell records have a lot of annoying behaviors, of which this is only one. the original impetus for van Laarhoven lenses was this and some other fundamental issues (such as composability: go look at record update syntax sometime)
10:57:50 <jbetz> dminuoso: you'd need `a` to be concrete? not sure I'm following
10:57:51 <johnw> ients
10:59:09 <dminuoso> jbetz: Lets say GHC ships with that class, with some `instance Sizeof Int where bitSize = 32; instance Sizeof Float where bitSize = 32` and so forth
10:59:15 <woodson> geekosaur: ya, but what I want to clearify is if we are using lenses then is ok of to use record sum types ?
10:59:17 <jbetz> dminuoso: wait no, `bitSize` doesn't take any args, so that's impossible
10:59:24 <dminuoso> jbetz: Exactly. ;-)
10:59:49 <dminuoso> jbetz: The old trick was to somehow insert a bogus value that acts as a type witness. That's what the Proxy pattern is about if you've seen that.
10:59:51 <geekosaur> woodson, not really because they're still partial. lens has some hacks (you can get it to produce a Maybe, but it's somewhat expensive)
11:00:27 <woodson> The only thing that I am getting honestly is that the issue is that they are partial
11:00:37 <woodson> and under the hood it translte to a case of
11:00:40 <EvanR> what do you want to accomplish?
11:00:55 <EvanR> if you just want "use record sum types", then theres no solution here
11:00:59 <geekosaur> this is a place where sum types with records are bad design to begin with
11:01:13 <EvanR> yes, records are records, product types. not sums
11:01:14 <woodson> EvanR: for now what I wanted to accomplish works I am just using sum types without the record syntax
11:01:21 <aarvar> what's partial?
11:01:24 <jbetz> dminuoso: I've seen the proxy pattern but didn't understand it until now. thanks :D
11:01:29 <EvanR> record fields in sum types
11:01:32 <geekosaur> there are cases when they're viable, but you have to do manual checking because otherwise it has to be runtime validation of the constructor
11:01:35 <woodson> but I just wanted to know why record sum types are not recommended
11:01:48 <aarvar> what is a "record sum type"
11:01:58 <geekosaur> one solution is to move that to type level so it can be checked at compile time; another is to use a mechanism that can give you partial results without exceptions (of which lens is one)
11:02:08 <aarvar> a sum type with field accessors? that's a wart in the language
11:02:11 <EvanR> because if you use the partial accessors, you have to think harder to know when they are valid, or else the program crashes badly
11:02:24 <EvanR> and anyone modifying the code must understand the code, rather than have the type checker tell them they did something wrong
11:02:39 <geekosaur> you can't check whether the record accessor is valid at compile time, basically
11:02:42 <EvanR> right there should be no such thing as a "record sum type"
11:03:00 <EvanR> a record is a record, and a sum is a sum
11:03:07 <dminuoso> jbetz: So if you look at `map` it formally takes *3* arguments. One type argument and two value arguments.
11:03:13 <johnw> what about a sum of records?
11:03:14 <woodson> ok.. a sum type of records?
11:03:19 <woodson> is that of ok ...?
11:03:19 <EvanR> thats fine
11:03:24 <aarvar> dminuoso: what?
11:03:30 <EvanR> A MyRecord1 | B MyRecord2 | C MyRecord3
11:03:41 <dminuoso> Oh oh! 4 sorry.
11:03:47 <dminuoso> 2 type arguments and 2 value arguments. :)
11:03:54 <EvanR> or a record of sums
11:04:08 <EvanR> MyRecord { a :: Either A B; b :: Either C D }
11:05:06 <dminuoso> jbetz: So GHC figures out what these type arguments must be and passes them for you. TypeApplications lets you do this manually.
11:05:14 <woodson> Ok, I will have to try them on my end
11:05:31 <woodson> but the main issue is that it they blow up because they are partial
11:05:41 <woodson> and we need to handle them somehow
11:05:57 <EvanR> that you will have a hard time verifying manually, all the time, that they will not blow up, because you used them in the wrong place
11:06:08 <EvanR> you dont handle blowing up
11:06:12 <EvanR> you avoid it
11:06:23 <johnw> or better yet, make blowing up a type error
11:06:32 <EvanR> yes!
11:06:35 <aarvar> that's what was meant by avoiding it :)
11:06:44 <EvanR> well avoid it somehow
11:06:44 <woodson> thats why i said BadType Text last time
11:06:48 <johnw> one doesn't avoid shadows in the daylight
11:06:50 <woodson> but that did not make sense
11:07:19 <aarvar> woodson: what you probably wanted to say was unwrap :: SomeData -> Maybe Int
11:07:46 <dminuoso> aarvar: That's more correct now isn't it?
11:07:59 <dminuoso> Im open to criticsm if Im just telling nonsense.
11:08:01 <EvanR> thats possible but may not help, if Nothing has no recourse, should be impossible
11:08:26 <aarvar> dminuoso: well...ignoring that it's actually curried, sure
11:19:36 <mbwgh> How can I convert a literate haskell source to a vanilla haskell one?
11:21:14 <mbwgh> Please. I hate lhs so goddamn much right now
11:24:00 <geekosaur> there's a program buried inside the ghc internal bin directory (or possibly lib depending on how your ghc was packaged) called unlit
11:24:32 <geekosaur> but note that it's a preprocessor for the ghc parser and may not necessarily produce human-readable/nicely formatted output
11:25:19 <phadej> it's nicely formatted, it's only filled with #line pragmas
11:25:28 <phadej> or the formatting of code blocks is preserved
11:29:34 <mbwgh> Ok then maybe it isn't going to help much. I was trying to work through the liquid haskell tutorial, but writing the code yourself is not really possible, with the explanations provided. The lhs files from the repo do work, as far as I can tell, but I have no idea what's going on
11:31:41 <mbwgh> There is a liquid haskell slack channel, but of course my browsers are too old and I should install the app >(
11:35:16 <chisui> Hey, I have a question about assiciated data families: https://hastebin.com/xijobovuxe.hs Why do I need the `C a` Constraint here? Isn't the only way to define an instance for `D` by implementing `C` and thus satisfying all Constraints for `D` on `C` anyways?
11:39:29 <sytherax> hello
11:39:54 <sytherax> anybody looked at lean language?
11:40:01 <sytherax> https://leanprover.github.io/tutorial/
11:41:07 <mbwgh> Or does anybody know how I can convince liquidhaskell that fromList ["bla", "blubb"] is a {v:Vector String | vlen v == 2} ?
11:41:42 <noan> What's the reason for return :: a -> m a anyway? Isn't pure always sufficient?
11:42:09 <phadej> noan: return is historical
11:42:19 <phadej> there were times when there wasn't Applicative
11:42:20 <noan> oh right, monads aren't applicatives in haskell
11:42:21 <noan> are they
11:42:29 <phadej> they are for few last years
11:42:31 <mbwgh> noan: Histerical raisins. Monad is way older than Applicative.
11:42:45 <noan> ah play
11:42:50 <noan> okay*
11:42:55 <phadej> (since GHC-7.10)
11:44:20 <noan> okay cool, thanks guys
11:45:11 <phadej> and there is a proposal "monad of no return" :)
11:45:20 <phadej> but i'm not sure if it's moving forward or not
11:45:39 <Welkin> that is kind of dumb
11:45:45 <Welkin> there is no reason to remove it
11:45:51 <Welkin> return = pure by default now, I believe
11:46:00 <Welkin> then you would also have to talk about removing liftM
11:46:06 <Welkin> because fmap exists
11:46:09 <cocreature> the proposal won’t remove return, it will only remove it from the Monad typeclass
11:46:10 <Welkin> and ap
11:46:12 <Welkin> because <*>
11:46:17 <cocreature> so you’re actually guaranteed that return = pure
11:46:35 <phadej> Welkin: what cocreature said
11:46:45 <Welkin> where will it live then?
11:46:52 <phadej> next to liftM and ap
11:46:53 <Welkin> in yet-another typeclass?
11:46:55 <cocreature> just a top level function like ap
11:47:01 <Welkin> okay
11:47:01 <cocreature> defined as return = pure
11:47:05 <aarvar> what if return can be implemented more efficiently in the monad case?
11:47:14 <aarvar> I don't know of any such example though
11:47:32 <cocreature> aarvar: that doesn’t make sense. if you could have a more efficient implementation for return you could just as well use that for pure
11:47:39 <aarvar> cocreature: not necessarily
11:47:51 <aarvar> the Applicative and Monad instances might have different constraint
11:47:53 <aarvar> constraints
11:47:55 <setre> can you help me make a faster version of this: map fst $ ordNub $ filter ((>= k) . snd) $ zip xs (map (numTimesFound xs) xs)
11:48:08 <aarvar> e.g. Applicative f => Applicative (Foo f) vs Monad f => Monad (Foo f)
11:48:18 <cocreature> ah fair point
11:48:21 <setre> where numTimesFound xs x = (length . filter (== x)) xs
11:48:27 <phadej> aarvar: I can believe tht for >> vs. *>, but hardly for `return`
11:48:44 <aarvar> phadej: Like I said, I don't know of any actual examples :)
11:50:55 <aarvar> setre: do you need to maintain the order of the list?
11:51:01 <setre> aarvar: yes
11:54:56 <aarvar> setre: I suppose you could sort, group, and filter, and then iterate again to put them back in order
11:55:11 <aarvar> or something like that
11:57:07 <aarvar> setre: er, as in create a Set of the elements that should be kept, and then filter using that Set
11:58:35 <setre> hmm okay thanks
11:59:34 <aarvar> setre: that's probably dumb though
12:00:16 <phadej> so is the idea to "keep elements which occur >= k times" ?
12:00:18 <aarvar> you could just traverse with a state of Map a Int
12:00:56 <setre> phadej: yeah keep one of them in order
12:01:03 <setre> of first appearance
12:01:26 <phadej> setre: your map fst $ ordnub $ ... keeps all
12:02:32 <phadej> I'd use http://hackage.haskell.org/package/discrimination-0.3/docs/Data-Discrimination.html#v:group :)
12:04:32 <setre> aarvar: could you show me how that would look? beginner
12:04:33 <phadej> mapMaybe (\xs -> if length xs > 2 then Just (head xs) else Nothing) $ group [1,2,3,1,2,3,1,2 :: Int]
12:04:36 <phadej> [1,2]
12:04:50 <setre> cool
12:04:58 <phadej> (note: group from discrimination works differently than the Data.List.group)
12:05:43 <phadej> `length xs > 2` can be made lazier; which may or may not make it run even faster
12:07:30 <cocreature> fwiw you might want to benchmark discrimination. last time I tried benchmarking it, you needed quite a lot of elements until it payed off
12:08:22 <phadej> it's single (lazy) traversal of the list, so it pays off that way.
12:08:25 <dmwit> setre: import Data.MultiSet as MS, then use toList . fromList
12:08:39 <phadej> dmwit: won't that screw the order?
12:08:47 <dmwit> Oh, definitely.
12:09:24 <dmwit> Okay, I'll put Data.MultiSet.Ordered on my weekend plan. =)
12:09:59 <dmwit> In the meantime, Data.Map.Ordered will probably do with a bit more verbosity. Let's see...
12:10:04 <phadej> dmwit: as http://hackage.haskell.org/package/insert-ordered-containers ? :)
12:10:44 <dmwit> Oh, I didn't know about that one. I was talking about ordered-containers.
12:10:52 <phadej> TIL ordered-containers
12:11:31 <phadej> they are done at about same time :S
12:13:21 <dmwit> Oh, insert-ordered-containers incurs a log(n) penalty for traversal. Boo!
12:13:44 <dmwit> You should use the trick I do in ordered-containers to use more memory but keep the same asymptotics as the underlying container.
12:15:38 <dmwit> Hm, maybe with HashMaps it's harder to use that trick.
12:16:04 <phadej> well it's isn't, I could still have Map Tag (k, v)
12:16:14 <phadej> but writing `traverse` is tricky for ordered-container
12:16:20 <dmwit> Yes, but then insert wouldn't have the same asymptotics as HashMap insert.
12:16:51 <monochrom> Interesting!
12:17:07 <phadej> dmwit: it won't, yes.
12:17:52 <phadej> as insert-ordered-containers is used in construct-traverse-done, expensive single final traversal isn't a problem
12:18:11 <phadej> or in one place I know it's used, dunno if someone else uses it too
12:18:47 <phadej> (i been told something like that lives in GHC codebase too)
12:18:55 <dmwit> Yeah, I guess ordered-containers can't have O(n) traverse either.
12:18:57 <dmwit> Bummer.
12:21:12 <dmwit> (It's not too hard to write an O(n*log n) traverse, though. I probably should do so.)
12:21:13 <monochrom> Just traverse in insert order. :)
12:21:31 <dmwit> monochrom: Yes, the trick is rebuilding the Map k (Tag, v) with the updated v's.
12:22:05 <dmwit> monochrom: foldMap in O(n) is easy, because you don't have to return an updated structure, just touch each element. But traverse has to update the structure, and there are two to keep in synch.
12:22:07 <mark721> hi guys
12:22:27 * monochrom uploads insert-order-containers-literally which has O(n)-time traverse-in-insert-order but Ω(n^2) time for everything else.
12:22:58 <monochrom> Oh w00t this would make a nice exam question!
12:23:13 <monochrom> Or assignment question if it's pretty hard.
12:23:14 <dmwit> You said that last time we talked about it, too. ;-)
12:23:19 <dmwit> It's pretty hard.
12:23:35 <dmwit> Well, depending on how you ask it, I guess.
12:23:56 <monochrom> Can I augment an AVL tree to help with it?
12:24:15 <monochrom> Because I'm looking for an augmentation question anyway.
12:25:00 <phadej> so far all "you have two variables you want to preserve order" -> "you have two trees"
12:25:09 <monochrom> Ah! I can. Great! The last missing piece in my assignment is done!
12:25:26 <AndreasK> phadej: Yeah ghc has https://hackage.haskell.org/package/ghc-8.4.1/docs/UniqDFM.html
12:25:58 <phadej> AndreasK: cool, thanks
12:29:05 <dmwit> monochrom: In case you would like to refer to the previous iteration of this discussion, I have located it in my logs at June 15, 2016 around 1400 in some time zone (probably US west coast time).
12:29:13 <monochrom> In the context of my course (just 2nd-year data structures), logarithmic time per element is good enough.
12:30:05 <johnw> monochrom: what institution do you teach at?
12:30:13 <Welkin> the mental one
12:30:16 <monochrom> U of Toronto, Scarborough campus
12:30:19 <johnw> nice
12:30:59 <Welkin> still doesn't change the fact that all of that is useless on modern computers
12:36:11 * mrcmatuszak  
12:41:24 <monochrom> Oh! I forgot that in the Haskell community "traverse" means Traversable, not just read-only walk.
12:42:22 <dmwit> Oh, yeah, ordered-containers already has an O(n) read-only walk.
12:58:58 * hackage hformat 0.3.2.0 - Simple Haskell formatting  http://hackage.haskell.org/package/hformat-0.3.2.0 (AlexandrRuchkin)
13:11:43 <albeit> I'm trying to "stack install gi-gtk", and it fails but suggests I add some extra-deps, which I do. But when I include "haskell-gi-overloading-0.0", it says it needs "haskell-gi-overloading-1.0", and when I switch to 1.0 it then says it needs 0.0. Any idea why?
13:13:01 <cocreature> albeit: can you show us the full error message?
13:14:30 <albeit> Sure: https://lpaste.net/5176891310715437056
13:15:19 <albeit> And then when I switch to 1.0: https://lpaste.net/5473486221575454720
13:15:33 * hackage simple-log 0.9.4 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.9.4 (AlexandrRuchkin)
13:15:56 <albeit> (I need to use 0.0 as well because I am on GHC 8.2.*)
13:17:30 <jackhill> albeit: I don't know about your problem, but I see that there is a warning about using gi-gtk with GHC 8.2 https://github.com/haskell-gi/haskell-gi#️-ghc-82x-️
13:18:17 <albeit> jackhill: Yeah, that's why I'm trying to install it with overloading disabled
13:18:19 <cobreadmonster> monochrom: Where exactly do you study that you use Haskell for algorithms?
13:18:55 <monochrom> I don't actually study anything that uses Haskell for algorithms.
13:19:18 <monochrom> I'm teaching a data structure course but it's still in the imperative setting.
13:19:26 <jackhill> albeit: ah cool. Unfortunately, I don't know about the dependency problem, I just came across that when searching
13:19:48 <monochrom> What I do with Haskell is that I sometimes write in Haskell to check answers because clearly imperative languages are not to be trusted!
13:20:42 <pavonia> Is lpaste broken somehow? I get a lot of connection timeouts lately, and if it works, it looks like CSS isn't properly applied
13:21:13 <monochrom> yes
13:21:32 <monochrom> disk full I heard
13:21:42 <maerwald> someone should fork lpaste anyway and remove that annoying linting
13:21:54 <monochrom> heh
13:24:24 <HaskellLord69> https://github.com/lpaste/lambda-paste
13:24:27 <HaskellLord69> is this official
13:25:04 * hackage lifted-stm 0.1 - STM operations lifted through monad transformer stacks  http://hackage.haskell.org/package/lifted-stm-0.1 (MikhailVorozhtsov)
13:27:27 <spoonm> I'm having some problem with Codec.Binary.UTF8.String (encodeString)
13:27:50 <maerwald> not sure why one would go with yesod for a simple paste app...
13:27:52 <spoonm> when given "»", which is "\187", it spits out "\194\187", adding a Â do the beginning of the string
13:28:00 <spoonm> I don't understand why
13:28:14 <cocreature> albeit: afaict the problem is that the packages rely on an automatic flag and stack doesn’t set flags automatically
13:28:23 <geekosaur> because it's generating utf8, not unicode codepoints
13:28:33 <cocreature> albeit: try manually building the packages (e.g. gi-gobject) with enable-overloading set to false
13:29:11 <geekosaur> a unicode codepoint can have a value > 255. a machine level character can't. so utf8 encodes them as multiple bytes
13:29:12 <cocreature> albeit: if you’re not familiar with how you change flags with stack, take a look at https://docs.haskellstack.org/en/stable/yaml_configuration/#flags
13:29:15 <EvanR> its ambiguous, thanks to ByteStrings Show instance
13:29:42 <EvanR> in String \187, its a Char, in \194\187 its two bytes
13:30:03 <EvanR> you could use notation "»" vs <194 187>
13:30:11 <geekosaur> if you then show that ByteString then you see that, and it's a bit confusing if you are trying to treat it as the original string-of-codepoints instead of string-of-utf8-encoded-machine-chars
13:30:41 * hackage planb-token-introspection 0.1.3.0 - Token Introspection for PlanB  http://hackage.haskell.org/package/planb-token-introspection-0.1.3.0 (mtesseract)
13:31:23 <EvanR> fact: Â is not involved in any way
13:32:16 <spoonm> I understand that characters in utf8 can be composed of multiple bytes and all, but I'm seeing Â where a utf8 string is treated, which is weird to me
13:32:19 <monochrom> Programmers are supposed to be the ones most aware that software lies.
13:32:32 <spoonm> I'd screenshot, but dmenu takes control of the keyboard
13:32:42 <spoonm> the string it prints in the end is Â»
13:32:50 <geekosaur> spoonm, if your output encoding is iso8859 then that string would display with the Â
13:32:52 <EvanR> then something is not treating <194 187> as utf8
13:32:58 <geekosaur> if it's utf8 then it will display without it
13:33:09 <spoonm> huh
13:33:22 <monochrom> spoonm: Do not trust "printing". Re-direct output to a file, then use a hex editor.
13:33:47 <spoonm> monochrom: i-it's dmenu ;-;
13:33:59 <EvanR> dmenu must not be doing utf8 properly
13:34:00 <spoonm> just an arg, but I'll see how it's treating the prompt
13:34:21 <EvanR> actually i remember it not doing unicode properly
13:34:34 <AWizzArd> data Foo a b = Foo Int a b      data Bar a b c d = Bar (Foo a b) c d       data Baz a b c d e f = Baz e f (Bar a b c d)
13:34:37 <AWizzArd> => what is the Haskell way to solve this? I start with simple values and create Rules and want to put them into a Node which then gets compiled into a Network. How can I fight an ever growing number of polymorphic vars?
13:34:41 <monochrom> Yeah, perhaps dmenu is the broken one?
13:34:45 <spoonm> stuff like テスト works in the prompt, so I dunno
13:35:02 <EvanR> is your japanese using shift-jis ?
13:35:10 <spoonm> come again?
13:35:27 <EvanR> its common to get japanese text encoded in shift-jis
13:35:31 <EvanR> which is not utf8
13:35:37 <spoonm> I didn't know that
13:36:00 <monochrom> Programmers are supposed to be the ones who are most aware that a modern computer, hardware+software, consists of so many layers that every layer is trying hard to screw you over by performing a broken translation.
13:36:03 <EvanR> and many programs work with shift-jis
13:36:37 <EvanR> utf8 everywhere!!!1111
13:40:44 <Ariakenom> latin-231512
13:40:51 <Ariakenom> no wait utf16
13:40:55 <Ariakenom> - windows
13:40:58 <NemesisD> hey everyone. i'm trying to write this type alias, is it possible? something like this: type Errors (es :: [*]) = Sum (Const <$> es), such that Errors '[A, B] ~ Sum '[Const A, Const B]
13:41:34 <monochrom> No, we don't have type-level <$>
13:41:36 <NemesisD> in other words, can i map a *-> * over a [*]
13:41:39 <NemesisD> oh no!
13:42:15 <monochrom> We don't even have type-level list comprehension.
13:44:20 <EvanR> wth not
13:44:22 <NemesisD> hmm, maybe i can work out something else like a cons that applies Const as you go
13:44:50 <monochrom> The road to hell is paved with Dependent Haskell.
13:45:59 <EvanR> if you want to write your own system of logic to check types you can: http://www.shenlanguage.org/
13:46:14 <monochrom> https://aphyr.com/posts/342-typing-the-technical-interview
13:47:20 <NemesisD> i'm just trying to turn a pretty powerful union type that forces you to use functors in its type list to opt out of the functor with Const
13:47:42 <machinedgod> monochrom: Sorry for just parachuting into the conversation, but could you elaborate a bit about "The road to hell..."?
13:47:56 <oisdk> What's the name of the free structure that adds negation to a monoid? I want to say "difference monoid" but googling that doesn't return anything useful.
13:48:30 <oisdk> > data Diff a = Diff a a
13:48:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
13:48:43 <oisdk> > mappend (Diff xn xp) (Diff yn yp) = Diff (xn `mappend` yn) (xp `mappend` yp)
13:48:46 <lambdabot>  <hint>:1:35: error:
13:48:46 <lambdabot>      parse error on input ‘=’
13:48:46 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:48:53 <oisdk> compare (Diff xn xp) (Diff yn yp) = compare (mappend yn xp) (mappend xn yp)
13:49:17 <monochrom> machinedgod: Just watch the pilgrim's progress (regress?) of NemesisD, many others, and the link I just gave.
13:49:50 <machinedgod> monochrom: Right, I just opened the linkn, I didn't think they're connected. Okay.
13:50:12 <machinedgod> The reason why I asked was because I'm lightly using some dependent types in my software, and I'm pretty happy with it!
13:50:29 <monochrom> There are multitudes of others in history and in future. If you missed the past, just hang on and watch the future unfold.
13:50:56 <monochrom> Lightly eh?  It's a slippery slope, soon it will not be so lightly any more.
13:52:03 <monochrom> Then again S&M implies that what I see as hell other people see as pleasure.
13:52:07 <machinedgod> monochrom: Yeah I totally get what you mean. It has a tendency to infect the rest of the code quite quickly, but thanks to rankNtypes, I keep it hidden :-D
13:52:47 <EvanR> in the future the accepted paradigm will be to directly program with things your program does wrong or may do wrong, because the default is perfect and unrunnable. you have to add problems to get it to run
13:53:38 <machinedgod> monochrom: Btw, the article is brilliant, I'm laughing my ass off :-D
13:54:35 <opto> “Couldn’t you use the built-in lists?” Criss asks, his brow furrowing.
14:01:38 <EvanR> i agreed sometimes the redefinition of this stuff is shorter than the import statement
14:02:08 <EvanR> thats when you know youre on to something with language design... or off your rocker in module system design
14:06:50 <spoonm> ┐(´～｀)┌ the same treatment is given to the items as it is given to the prompt, so I don't know what's wrong
14:07:31 <spoonm> running dmenu -p '»' from a shell just works, but not from X.U.Dmenu
14:10:42 * hackage nakadi-client 0.5.1.0 - Client library for the Nakadi Event Broker  http://hackage.haskell.org/package/nakadi-client-0.5.1.0 (mtesseract)
14:14:29 <tosku> @help
14:14:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:14:47 <spoonm> and it works with these: http://0x0.st/seJX.png
14:16:51 <spoonm> but not if the args go through encodeString
14:21:05 <jp_rider> Hi. I'm using template haskell and have a `Type` and a function like `toLabel :: Label l => Int -> l`. There's no way to run `toLabel x :: Type` and get the result in TH right?
14:22:47 <jp_rider> I want to check an invariant on `toLabel x` and throw an exception at compiletime if the invariant isn't true.
14:24:14 <benzrf> is anyone here versed in the linear package
14:24:38 <benzrf> jp_rider: why not?
14:25:55 <jp_rider> The `Type` I have is a value. How do I lift it to a usable type in TH?
14:26:17 <jp_rider> This kind of `Type`: http://hackage.haskell.org/package/template-haskell-2.13.0.0/docs/Language-Haskell-TH-Syntax.html#t:Type
14:26:24 <benzrf> what do you mean by a "usable type"
14:26:55 <pavonia> Type has several constructors, you can build a values from these
14:27:33 <jp_rider> Yes, I have the Type. Can I use a Type as a type at compile time?
14:28:24 <jp_rider> Or generate an expression that is evaluated at compile time after I generate it?
14:28:35 <benzrf> why do you need to?
14:28:46 <maerwald> weird, cabal new-install does nothing
14:28:53 <benzrf> wait
14:29:00 <benzrf> jp_rider: when you say "toLabel x :: Type"
14:29:10 <benzrf> is the "Type" there supposed to be the Type value you had?
14:29:15 <jp_rider> yes
14:29:20 <benzrf> cuz i tohught you meant literally "toLabel x :: Type"
14:29:27 <benzrf> ok now your question makes more sense
14:29:29 <jp_rider> haha no, sorry
14:31:16 <jp_rider> Can you generate $(..) with TH? I don't see anything from the docs
14:31:22 <benzrf> you can
14:31:30 <benzrf> well, wait
14:31:40 <benzrf> you can splice into a quoted expression
14:33:18 <benzrf> it depends on the specifics of what you're asking :V
14:33:21 <jp_rider> what do you mean?
14:33:46 <benzrf> you can do something like [| foo $x |]
14:34:25 <maerwald> why does cabal new-install not symlink anything?
14:35:54 <jp_rider> you can generate that with TH?
14:35:57 <benzrf> edwardk: hey, you around to answer a question about linear?
14:36:04 <benzrf> jp_rider: that's a valid expression is all i mean
14:41:33 <jp_rider> ah. I think my situation is something like: mkLabel "LabelName". but it seems like (mkLabel :: String -> Q Dec) cannot generate $(..)
14:42:29 <jp_rider> I'll see if I can test the invariant when runtime starts
14:43:39 <aarvar> are you doing some OverloadedLabels like thing?
14:44:16 <dmwit> cobreadmonster: So you want to do some Haskell projects. How complicated are you interested in?
14:45:35 <cobreadmonster> Something that can ideally keep my attention.
14:45:38 <cobreadmonster> I like challenges.
14:48:07 <dmwit> Well, you could think about making a game.
14:48:37 <dmwit> Roguelikes are pretty fun and don't need a ton of GUI work; or I've always wanted to see a good physics game written in Haskell with Hipmunk.
14:49:37 <jp_rider> aarvar: No, I don't think it's related, although I'm not too familiar with OverloadedLabels
14:50:08 <dmwit> Or if you're more into PL-y stuff, I've wanted to see a translation of "Lightweight Monadic Programming in OCaml" to Haskell for a long time. It's a bit tricky because Haskell doesn't differentiate between type constructors as carefully as OCaml does, but I've often thought something that inferred returns and binds (but not lifts) should be pretty doable in Haskell.
14:51:20 <dmwit> You could think about building a Wayland compositor. I think it would be super neat to see a compact, xmonad-style core theory of window management that took into account compositing's extra capabilities like duplicating, scaling, and recoloring windows.
14:52:15 <dmwit> cabal new-* still has some kinks that need ironing out, and I'd be happy to give you some pointers to stuff that needs doing and isn't allocated to anybody.
14:52:33 <sm> cobreadmonster, dmwit: for micro challenges (15m), https://www.codingame.com/clashofcode is pretty fun
14:53:24 <cobreadmonster> I'll take a look at the ocaml thing.
14:53:27 <cobreadmonster> is that a paper?
14:53:32 <dmwit> You could try to implement the AlphaZero algorithm with the Haskell TensorFlow bindings.
14:53:35 <dmwit> yeah
14:54:41 <dmwit> You could write an emulator for some early console.
14:54:46 <dmwit> So many possibilities.
14:55:09 <Tuplanolla> You could make all kinds of useless garbage.
14:55:17 <sm> like puffnresh is doing on twitch (sonic2)
14:55:32 <sm> puffnfresh
14:57:20 <cobreadmonster> I wonder if Haskell is a good language for network related things?
14:57:31 <cobreadmonster> I've used it only for parsing and what not.
14:58:02 <hpc> what sort of network things?
14:58:32 <hpc> it's pretty great for the protocol part of things, because of parsing and concurrency
14:58:33 <EvanR> Yes! Haskell can do that!
14:58:41 <hpc> EvanR: i miss @faq
14:59:01 <Tuplanolla> I wouldn't write router firmware with it.
14:59:18 <Tuplanolla> Then again, I wouldn't write router firmware with anything.
14:59:23 <dmwit> Tuplanolla: HaNS would like to have a word with you.
15:02:12 <maerwald> does anyone use haskell-ide-engine?
15:02:19 <maerwald> I find the documentation to be severely lacking
15:19:21 <infinisil> maerwald: I am
15:19:31 <infinisil> maerwald: There's #haskell-ide-engine btw
15:19:36 <maerwald> I only get linter warnings, nothing else seems to work
15:20:24 <Welkin> clean your lint trap
15:20:41 <Welkin> did you know that lint is not just cotton fibers, but also dead skin?
15:20:45 <Welkin> and dirt
15:20:46 <infinisil> maerwald: It took me a bit to get it working well
15:20:58 <Welkin> dust is dead skin cells too, a lot of the time
15:21:03 <johnw> maerwald: I've been trying to use it
15:21:10 <johnw> maerwald: actually, let me try again real quick
15:21:12 <maerwald> infinisil: the documentation is very little
15:21:22 <maerwald> Welkin: did you take datura?
15:21:31 <Welkin> is that a drug?
15:22:37 <infinisil> johnw: I have a pretty stable setup for NixOS & stack, I could help you if something isn't working
15:22:48 <johnw> I don't use stack
15:23:20 <lukelau> Is there a way to create a handle that basically does /dev/null, without having to use /dev/null?
15:23:27 <infinisil> Hmm yeah, I couldn't get it to work with cabal unfortunately..
15:23:37 <infinisil> I haven't tried running emacs in a nix-shell though, maybe that's the solution
15:24:03 <maerwald> johnw: the installation works very well with new-build
15:24:10 <johnw> I get this from hie: cannot satisfy -package-id aeson-1.2.4.0-G9AwmJGyHa062BMlqjD9fS
15:24:13 <maerwald> although the documentation is falsely stack-focused
15:24:15 <Welkin> when will new-build become build?
15:24:23 <johnw> maybe my dist/ is out of date
15:24:24 <maerwald> johnw: which ghc version
15:24:24 <infinisil> johnw: And the compiling works with cabal?
15:24:30 <johnw> 8.2.2
15:24:31 <Welkin> stack brainwashing
15:24:37 <johnw> one sec, let me make sure
15:24:56 <infinisil> I've gotten most of my hie problems from not realizing the project doesn't even build
15:25:11 <Welkin> what is hie?
15:25:17 <infinisil> haskell-ide-engine
15:25:26 <Welkin> what does it do?
15:25:38 <maerwald> something intero doesn't
15:25:39 <infinisil> Welkin: https://github.com/haskell/haskell-ide-engine
15:25:41 <johnw> maybe nix-buffer isn't starting the hie process in the right environment
15:25:44 <maerwald> tryint go be a proper API
15:25:52 <Welkin> I don't use anything fancy
15:25:58 <Welkin> just syntax highlighting
15:26:04 <infinisil> hie is niiice
15:26:08 <infinisil> LSP in general
15:26:11 <Welkin> I don't lke ides
15:26:20 <nsnc> i don't like ideas
15:26:20 <Welkin> pain in the ass and fragile
15:26:23 <maerwald> infinisil: yes, because finally someone didn't just think about his own narrow use case ;)
15:26:26 <infinisil> Welkin: I use emacs with it
15:26:30 <lukelau> johnw: Are you using stack or cabal?
15:26:34 <johnw> cabal
15:26:35 <Welkin> I use emacs with plain haskell-mode
15:26:54 <lukelau> Make sure there’s no rogue .stack-work or stack.yaml
15:26:58 <johnw> yeah, still getting hie: <command line>: cannot satisfy -package-id aeson-1.2.4.0-G9AwmJGyHa062BMlqjD9fS
15:27:06 <lukelau> Also what happens when you run `hie -v`
15:27:06 <johnw> even though it cabal configure'd and build'd just fine
15:27:20 <lukelau> hie --version sorry
15:27:48 <Welkin> more tools means more dependencies, means more breakage and more frustration, less time spent getting things done
15:27:57 <lukelau> You need to use a version of hie that was compiled with your projects version
15:28:00 <johnw> Welkin: you're not wrong
15:28:06 <infinisil> Welkin: You're missing something though
15:28:06 <johnw> lukelau: double-checking something
15:28:23 <johnw> but when it works, it's awsemoe
15:28:25 <infinisil> Auto-completion, types-on-hover, some really nice stuff there
15:28:25 <EvanR> tools are supposed to help
15:28:31 <Welkin> I don't need any of that
15:28:41 <maerwald> I don't even know how to get the error message on startup
15:28:58 <lukelau> Yeah hie is pretty fragile at the moment, my gsoc project is to improve the testing infrastructure for it
15:29:05 <johnw> lukelau: Version 0.1.0.0 x86_64 ghc-8.2.2
15:29:06 <infinisil> maerwald: Which error message?
15:29:17 <EvanR> but what, this is the stone age of software. we have no perfected the tools yet
15:29:28 <infinisil> maerwald: The logs for hie get written to /tmp/hie-logs or so
15:29:30 <EvanR> we have crap and may not realize it
15:29:34 <lukelau> johnw: is your project 8.2.2?
15:29:38 <johnw> yes
15:29:54 <johnw> i just keep getting this aeson package error
15:30:11 <dyl> EvanR: the way I like to put it is by analogy to architecture.
15:30:16 <infinisil> johnw: Might be worth asking in #haskell-ide-engine if nobody here knows
15:30:17 <dyl> We’re still in the phase of pattern building.
15:30:23 <dyl> We haven’t hit humanism quite yet.
15:30:29 <maerwald> infinisil: that directory doesn't exist
15:30:41 <infinisil> maerwald: /tmp/hie.log
15:30:44 <johnw> infinisil: but who would be in #haskell-ide-engine that isn't also here? :)
15:30:52 <Welkin> EvanR: programming mostly is crap still
15:30:59 <dyl> Computers are horrible.
15:31:03 <Welkin> software is not an engineering practice, not even close
15:31:14 <lukelau> wait johnw update your hie
15:31:16 <EvanR> we all suck
15:31:18 <infinisil> johnw: True, but #haskell-ide-engine is much lower traffic -> more chance of being seen by the right people :)
15:31:20 <Welkin> it's more like tinkering and hoping things don't break
15:31:22 <EvanR> everything is bad
15:31:26 <lukelau> johnw: current version is 0.2.0.0
15:31:27 <maerwald> infinisil: doesn't exist either
15:31:33 <infinisil> I sense some pessimism in here
15:31:45 <johnw> lukelau: will try
15:31:48 <dyl> They’re nihilists, Donny.
15:31:48 <Welkin> if we built bridges how we build software, we'd all be dead
15:31:53 <infinisil> maerwald: Did you start hie in debug mode?
15:31:54 <Welkin> or airplanes, or cars, etc
15:32:01 <johnw> lukelau: I'm using domenkozar's packaging of hie for Nix
15:32:17 * dyl is going into his PhD with a focus on toolbuilding.
15:32:19 <infinisil> maerwald: Oh, see hie --help
15:32:19 <johnw> https://github.com/domenkozar/hie-nix
15:32:20 <maerwald> infinisil: probably not. When I start my editor it shows an error at the bottom, but I have no idea how to see all of it
15:32:24 <dyl> Hopefully I make the situation better and not worse!
15:32:36 <maerwald> some error wrt haskell-lsp:blahblah
15:32:53 <dyl> s/better/less bad/
15:33:04 <infinisil> maerwald: Ah the blahblah error, yeah that's very common
15:33:36 <maerwald> jesus christ why are these plugins so badly documented
15:33:44 <lukelau> johnw: maybe try changing this line https://github.com/domenkozar/hie-nix/blob/dbb89939da8997cc6d863705387ce7783d8b6958/update.sh#L3 to the latest head
15:33:51 <Welkin> dyl: just don't make any new javascript libraries that are thousands of lines of code for doing something that you can do in one line in plain javascript
15:33:56 <lukelau> johnw: I’m not familiar with hie-nix
15:34:15 <dyl> My first project will be a device which punches you every time you open a JS context.
15:34:39 <dyl> USB-C enabled negative reinforcement engine
15:34:45 <lukelau> maerwald: what editor are you using
15:35:30 <dyl> Linters and compilers can emit additional warning levels such as “PUNCH”, “SLAP”, and “DISTRESS_PSYCHE” (requires the TTS module)
15:36:30 <dyl> The second revision will include an under the desk foot to kick you.
15:36:46 <dyl> I’ll get it rolling by having it used during live coding streams.
15:36:52 <Welkin> dyl: does it also play the audio from that indian television show with the guy shouting "How can she slap!? How can she slap!?"
15:37:01 <dyl> “Pay money to add linting rules!”
15:37:23 <dyl> You don’t like the live coder using tabs? Donate $20 and his desk will kick him every time he uses them instead of spaces.
15:37:50 <glguy> dyl: #haskell-offtopic is good for random banter
15:37:56 <dyl> Apologies.
15:39:15 <maerwald> infinisil: https://git.io/vppuo this is why I get
15:41:12 <infinisil> maerwald: Hmm weird, haven't seen that one, I'd ask in #haskell-ide-engine
15:41:33 <maerwald> seems buggy stuff not worth my time
15:42:34 <lukelau> maerwald: could you file an issue for this https://github.com/haskell/haskell-ide-engine?
15:42:54 <maerwald> for which of the 300 problems I have
15:47:06 <lukelau> maerwald: all 300!
15:47:28 <maerwald> I don't even know what they are and which plugin is responsible
15:47:34 <maerwald> and I'm not sure I want to invest the time
15:47:35 <johnw> maerwald: I think I've seen that one once before, a while back...
15:47:40 <johnw> don't remember what the fix was
15:47:53 <johnw> I *think* I didn't have lsp-haskell loaded, and so that plugin wasn't registered yet
15:48:02 <lukelau> maerwald: can you run `hie --version`
15:48:27 <lukelau> That error you linked isn’t a plugin problem
15:49:05 <maerwald> Version 0.1.0.0, Git revision c68ba8d5cfb9cb89d04efd2bbda575d055a5e10b (1287 commits) x86_64 ghc-8.0.2
15:49:14 <infinisil> If everybody said "not worth my time" then haskell-ide-engine probably wouldn't exist :). I admire the effort that went into creating it and don't mind spending a couple hours to get it working
15:49:17 <maerwald> also note how "cabal new-install" does nothing, you have to copy it yourself
15:49:34 <johnw> especially if I'm just one hour away from having refactoring capabilities
15:49:58 <maerwald> well, ghc-mod and ALE work fine here, except that getting ghc-mod to work with newer ghcs is a pain
15:50:06 <lukelau> maerwald: that’s an old version
15:50:09 <johnw> i never did get ghc-mod working
15:50:22 <maerwald> but then again, hie seems to use "cabal-helper" too, which is a very weird and bad thing
15:50:28 <johnw> the hdevtools author is looking into the blocker for me on that front
15:50:37 <johnw> having ultra-fast syntax highlighting would probably be my #1 request
15:50:37 <infinisil> johnw: I got ghc-mod working after days of pain
15:50:42 <lukelau> Stick in there, when it works its pretty cool
15:50:42 <infinisil> But then it wasn't reliable at all
15:50:47 <johnw> :(
15:51:21 <lukelau> maerwald: `git pull` and `make all` inside haskell-ide-engine
15:51:27 <maerwald> lukelau: that's exactly the version the documentation points me to
15:51:27 <maerwald> https://github.com/haskell/haskell-ide-engine#getting-the-source-for-ghc-802-821-822
15:51:37 <maerwald> git checkout hie-0.1.0.0
15:51:53 <maerwald> also, I don't use stack, so "make all" does not work
15:53:19 <lukelau> maerwald: what version of ghc does your project use?
15:53:27 <maerwald> 8.0.2
15:53:47 <johnw> lukelau: that update script is still running here; here's hoping
15:53:56 <Welkin> are you sure LSP doesn't mean Lumpy Space Princess?
15:54:17 <lukelau> maerwald: Hm I haven’t tested that. Might be a matter of bringing a hotfix over to that branch
15:54:42 <maerwald> ok, so back to ghc-mod and ALE
15:56:54 <lukelau> johnw: Fingers crossed!
15:57:47 <lukelau> maerwald: what editor are you using?
15:57:59 <maerwald> gvim
15:58:42 <lukelau> And which LSP-client?
15:59:17 <maerwald> autozimu/LanguageClient-neovim
16:01:13 <lukelau> Thanks, I have the same setup so I’ll take a look at it tonight
16:01:34 <maerwald> cool
16:01:53 <maerwald> I don't have so much time for playing with those things though
16:02:03 <maerwald> so for now I'm back to ghc-mod
16:02:35 <infinisil> I've been meaning to create a nix-buildable (so reproducible) emacs + haskell-ide-engine setup which Just Works (tm)
16:07:10 <johnw> if I can pass in the emacs that I build as an argument, that would be great
16:08:01 <maerwald> editor configs are not meant to be reproducible
16:08:34 <johnw> lukelau: nope, update.sh not working here
16:08:35 <maerwald> that's like someone telling me what clothes to wear for work
16:08:38 <johnw> failing on stack-related things
16:08:55 <johnw> maerwald: you do know that tons of jobs in the world do exactly that :)
16:09:07 <maerwald> I don't work for those companies
16:09:23 <maerwald> and I bet most programmers would not
16:10:05 <infinisil> maerwald: It would be great for people who just want to try it out fast without having to debug stuff first
16:10:39 <infinisil> johnw: Yeah it would be configurable
16:11:29 <maerwald> I believe in clean, well-maintained APIs that work without fiddling and hours of debugging :P
16:11:44 <maerwald> so yeah, I should use nano
16:13:12 <infinisil> maerwald: Have fun lol
16:13:28 <infinisil> I'm enjoying hie while you do that
16:13:50 <maerwald> so it works for 50% of the people :P
16:13:56 <lukelau> johnw: what happened?
16:14:34 <infinisil> maerwald: It took me a while to get it working, and multiple attempts at that, but now I got it working it's so worth it
16:14:37 <johnw> lukelau: stack2nix: /private/var/folders/5_/8_f3jnlx3w3cktynjwtmb7_w0000gn/T/s2n-99924/stack-8.0.2.yaml does not exist. Use 'stack init' to create it.
16:15:18 <maerwald> infinisil: ghc-mod is already hard to get working, so what do you gain?
16:15:40 <lukelau> johnw: is this when running hie or during update.sh?
16:15:42 <johnw> my biggest problem with ghc-mod was hard it was to keep it working
16:15:54 <johnw> but that was in the days when I didn't have nix
16:15:56 <infinisil> maerwald: I struggled even longer and suffered more pain trying to get ghc-mod working, that was before I even knew hie was a thing
16:15:58 <johnw> lukelau: update.sh
16:16:02 <maerwald> yep, but hie uses those same codebases and will probably have similar problems in the long run
16:16:14 <infinisil> Then I gave up when ghc-mod broke yet again
16:16:16 <maerwald> it's not a rewrite
16:16:21 <infinisil> And hie is so much better
16:16:47 <johnw> someone should name their ide engine "brittle", just to win us over by its transparency
16:16:53 <infinisil> maerwald: hie is trying to get rid of the last pieces of ghc-mod I'm pretty sure
16:17:04 <maerwald> infinisil: it's still using cabal-helper
16:17:05 <maerwald> afais
16:17:09 <maerwald> which is one of the worst parts of it
16:17:15 <infinisil> What's bad about it?
16:17:26 <maerwald> it compiles stuff at runtime, without cabal
16:17:32 <maerwald> and as such can fail in a hundred ways
16:17:47 <maerwald> in a temp directory somewhere in ~/.local or so
16:18:14 <infinisil> Well in any case hie works for me, certainly much better than ghc-mod ever did
16:18:44 <infinisil> I could share my config, but since I'm using emacs this wouldn't help you very much probably
16:18:56 <johnw> infinisil: can I see it?
16:19:30 <lukelau> johnw: I dunno what exactly this wrapper does. You could try dropping a line at #haskell-ide-engine and see if anyone knows?
16:19:58 <infinisil> johnw: https://github.com/Infinisil/system/tree/master/config/new-modules/dev/haskell and https://github.com/Infinisil/system/blob/master/config/emacs/modules/haskell.nix
16:19:59 <johnw> lukelau: sorry, my daily "time to spend trying to get HIE working" has been used up :)
16:20:18 <johnw> it's a problem I nibble on a little bit at a time
16:20:33 <lukelau> johnw: fair enough, its a slow painful process
16:20:50 <johnw> i just need to poke domenkozar to update hie-nix
16:20:59 <infinisil> johnw: There's an issue for it
16:21:26 <johnw> and a PR even
16:24:57 <infinisil> johnw: Oh and apparently it got resolved: https://github.com/domenkozar/hie-nix/pull/10#issuecomment-389907174
16:25:08 <infinisil> Very nice
16:25:22 <johnw> actually, i'll just try it now
16:25:35 <infinisil> Yeah I'll build it too and see how it works
16:42:07 <johnw> still building...
16:42:17 <johnw> since my desktop died, I only have a laptop to work on, and it's overtaxed by far
16:42:30 <Welkin> I always only have a laptop to work on
16:42:41 <Welkin> I like it though
16:42:57 <johnw> i hope you're not doing a multi-core Docker build at the same time as several multi-core Nix builds
16:43:06 <Welkin> I don't do either of those
16:43:10 <Welkin> and I only have 2 cores
16:43:23 <johnw> yeah, some use cases make "laptop only" make a lot more sense
16:43:26 <Welkin> I've done all of my software development on a macbook air for the last 4 years
16:43:29 <johnw> me, I want an 18 core i9
16:43:38 <hpc> johnw: don't be ridiculous, you run kubernetes locally so you only have to make a container when you're doing a build :P
16:43:49 <Welkin> I got a new laptop, but I prefer the older one that I am using now
16:43:54 <johnw> hpc: my brother does that
16:44:02 * hpc dies a little inside
16:44:18 <hpc> (although i will confess that i quite like vagrant)
16:44:18 <johnw> i've considered it
16:44:26 <johnw> although, it only really works well for Linux peolpe
16:44:32 <johnw> macOS doesn't have great virtualization stories
16:45:19 <johnw> infinisil: built!
16:45:53 <infinisil> johnw: Nice
16:46:58 <johnw> nope, still hie: <command line>: cannot satisfy -package-id aeson-1.2.4.0-G9AwmJGyHa062BMlqjD9fS
16:47:21 <johnw> this is actually my universal experience with hdevtools and ghc-mod
16:47:27 <johnw> a never ending series of cannot satisfy errors-
16:48:02 <infinisil> Hmm.. I've never really had that
16:48:08 <infinisil> johnw: Can you try with a fresh project?
16:48:16 <johnw> no, I have to get other things done now
16:48:22 <johnw> I have gotten HIE to work just once
16:49:07 <johnw> thankfully, flycheck-haskell, while slow, is stable as a rock
16:49:32 <Welkin> johnw: but, but, plate tectonics, earthquakes!
16:50:04 <Welkin> and rocks spin and fly through space ta unimaginable speeds!
16:50:21 <Welkin> and collide with each other, casuing explosions
16:54:41 * hackage gtk 0.14.10 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.14.10 (HamishMackenzie)
16:59:46 <rotaerk> your mom throws "cannot satisfy" errors
17:30:10 * hackage fast-arithmetic 0.6.0.6 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.0.6 (vmchale)
17:42:14 * hackage gtkglext 0.13.2.0 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.13.2.0 (HamishMackenzie)
18:13:59 <dyl> rotaerk: really?
18:14:14 <dyl> Low brow.
18:19:10 <ddellaco_> I'm really confused: when I build my project (using `cabal new-build`) I see diagrams-1.4 getting built, but when I start up a repl via `cabal new-repl` and load a module which imports `Diagrams.Prelude`, I get an error that it can't be found. Any ideas?
18:36:30 <c_wraith> in dependent type theory, what's the name of a pair (t, x : t), again?
18:46:19 <monochrom> dependent pair?  a type (or sentence) and its witness?
18:49:49 <EvanR> (A,B) is just a pair (type), (x:A, B(x)) is a dependent pair (type). (A : U, A) is a pointed type
18:50:00 <EvanR> not sure about (t, x:t), (color on the right)
18:50:18 <EvanR> colon
19:00:26 <infinisil> Heh, https://github.com/githubuser is actually a user
19:00:34 <infinisil> It's what stack uses as a default homepage
19:01:01 <EvanR> free publicity. brilliant
19:01:13 * EvanR registers example.com
19:03:12 <infinisil> Aw yeah, I got my xmonad config working with stack + haskell-ide-engine
19:03:26 <infinisil> Finally I can know what the type of my layout actually is
19:05:49 <infinisil> layout :: ModifiedLayout AvoidStruts (ModifiedLayout SmartBorder (ModifiedLayout SmartSpacing (MultiToggle (HCons StdTransformers EOT) BinarySpacePartition))) Window
19:05:53 <infinisil> Ah yes
19:06:46 <EvanR> lisp eat your heart out
19:09:55 <geekosaur> wanting to know the actual type of your layout might be grounds to consult a psychologist >.>
19:11:42 <Eduard_Munteanu> You could use _ to type it partially if you wish.
19:18:44 <infinisil> Eh, I'm not gonna write that type out, I don't care
19:21:03 <EvanR> wait a minute
19:21:24 <EvanR> how do you use newtypes over Int as keys to an IntMap
19:28:51 <geekosaur> there's an EnumMap that will do that if you derive Enum through it
19:32:07 <EvanR> does that have a conversion cost?
19:52:53 <chessandgo> I have a question concerning bracket. I have some code that have some TChans, TVars, and threads, quite a mess. However I only have one resource I really want to make sure to release, which is a websocket connection. will wrapping the top level function with bracket allow this resource to be released (from a control C interupt)
19:54:04 <chessandgo> bracket has some notes on code that could potentially block (such as MVars)
19:55:08 * hackage yam-app 0.1.13 - Yam App  http://hackage.haskell.org/package/yam-app-0.1.13 (leptonyu)
19:59:07 * hackage yam-job 0.1.13 -   http://hackage.haskell.org/package/yam-job-0.1.13 (leptonyu)
20:00:30 * hackage yam-servant 0.1.13 -   http://hackage.haskell.org/package/yam-servant-0.1.13 (leptonyu)
20:01:15 * hackage yam-transaction-postgresql 0.1.13 -   http://hackage.haskell.org/package/yam-transaction-postgresql-0.1.13 (leptonyu)
20:14:49 * hackage yam-app 0.2.0 - Yam App  http://hackage.haskell.org/package/yam-app-0.2.0 (leptonyu)
20:15:38 * hackage yam-servant 0.2.0, yam-job 0.2.0 (leptonyu): https://qbin.io/wilson-frames-2ftd
20:17:34 * hackage yam-transaction-postgresql 0.2.0 -   http://hackage.haskell.org/package/yam-transaction-postgresql-0.2.0 (leptonyu)
20:49:48 <rotaerk> dyl, <3 low brow
21:24:36 <juhp> any good ways to query Hackage about package revisions?
21:25:06 <juhp> I mean from a shell or library
21:26:57 <juhp> if not I will just settle for downloading .cabal files
21:35:45 <sclv> juhp: http://hackage.haskell.org/package/lens/revisions/
21:35:52 <sclv> you can request it as JSON as well
21:36:01 <juhp> sclv: thanks yes
21:36:26 <sclv> there's also a recent revisions rss feed http://hackage.haskell.org/packages/recent/revisions.rss
21:37:02 <sclv> also the best way to query the cabal files is to just unzip the 01-index.tar.gz and read it with the tar library to see when multiple files exist
21:39:24 <juhp> I see
21:44:04 <juhp> I forget how to GET json
21:45:56 <sclv> curl -H "Accept: application/json" http://hackage.haskell.org/package/lens/revisions/
21:46:09 <juhp> sclv: thanks a lot
21:46:17 <sclv> or the equivalent using your lib of choice :-)
21:46:38 <sclv> for some things on hackage we take a suffix too, like ".json" but for some reason not for revisions
21:46:41 <sclv> just an oversight i guess
21:48:02 <juhp> okay yep that is what I thought I remembered...
21:49:25 <juhp> maybe I should file an rfe, though I don't think I need it - thanks a lot!
22:06:21 <felixphew> hi - would anyone be able to help me compile GHC for Solaris?
22:06:51 <felixphew> the only build I could find to bootstrap rom is 7.0.3, and 32-bit
22:08:25 <felixphew> I'm reading through the porting instructions at the moment, but I'm not sure exactly how "similar hardware" they have to be generated on
22:08:35 <felixphew> (the .hc files, that is)
22:10:57 <cocreature> felixphew: you might have more luck in #ghc with that question
22:12:40 <felixphew> cocreature: ok, thanks
22:34:41 <EvanR> whats better, ((++[2]) . (++[1]) . id) [], or reverse (2:1:[])... pretend theres a lot more than 2 items being placed one at a time
22:48:13 <jle`> better like stylistically?
22:49:23 <EvanR> performance
22:49:46 <EvanR> :-ing over and over then reversing at the end
22:50:08 <EvanR> or (++[x]).-ing and applying to [] at the end
22:52:25 <jle`> i think the (++[x])-ing is like, the bad asymptotic case of list building
22:52:57 <EvanR> huh no thats the builder thing
22:53:21 <EvanR> the last (++[x]). you do is the end of the list
22:53:30 <jle`> oh ah
22:53:32 <jle`> misread sorry
22:56:06 <jle`> *misunderstood :)
22:57:12 <johnw> lukelau: still here?
22:59:34 <EvanR> it seems superficially similar to me, but wondering if theres some hair splitting ghc thingie that would make them different
23:00:52 <EvanR> in both cases you have to build up a big chain, and then run over it again to begin to generate elements from the other side
23:01:17 <EvanR> but ones in the heap, the other is... on the stack maybe?
23:24:16 * hackage bindings-DSL 1.0.25 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.25 (JohnWiegley)
23:34:32 * hackage bindings-posix 1.2.7 - Project bindings-* raw interface to Posix  http://hackage.haskell.org/package/bindings-posix-1.2.7 (JohnWiegley)
