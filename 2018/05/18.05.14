00:01:20 <Axman6> BasDirks: I use stylish-haskell, but have no specific reasons for or against it compared to any other tool. I find the s-h defaults are pretty good
00:03:17 <aleator> BasDirks: I like brittany a lot.
00:03:43 <BasDirks> Thanks Axman6, aleator.
00:03:55 <aleator> .. but that's only because it happens to write code somewhat like me. Not that it would have any objective merit.
00:05:39 <iqubic> BasDirks: For what it's worth I use hlint, but only because that's what Emacs' Dante mode uses.
00:05:55 <quicksilver> rckd: nothing happens to 'a'. You have just given yourself the ability to label your data with a type
00:05:59 <cocreature> iqubic: hlint is not a code formatter
00:06:04 <dminuoso> rckd: T is a phantom type.
00:06:16 <quicksilver> so you can have foo :: T Int and bar :: T String
00:06:32 <quicksilver> which wouldn't be very useful from what yu've written so far, but it is sometimes useful to do things like that.
00:07:26 <quicksilver> to get the 10 and True back, you'd use case matching, as in case x of X n t -> {- write something using n and t -}
00:07:38 <BasDirks> aleator: subjective or not, thanks for the recommendation. It's been a while since I've looked into these things. iqubic: thanks.
00:15:07 <rckd> dminuoso ok thanks, ill look into that
00:17:19 <jesyspa> cocreature: If the number of ints is small, you could consider trying to represent them as unsigned integers and then doing bitmasking to get the result.  However, I'm not sure the cost of computing these wouldn't outweigh what you're doing now.
00:26:32 <quicksilver> there are bitvector packages on hackage but I am not familiar with their performance
00:29:05 <iqubic> what even are bitvectors?
00:30:41 <AndreasK> A vector of bits presumably?
00:31:10 <cocreature> jesyspa: I have a few thousand of them so that’s probably not going to work but thanks for the idea!
00:31:16 <AndreasK> Or packed booleans if you want to view it that way
00:43:55 <iqubic> :t callCC
00:43:56 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
00:49:42 * hackage pivotal-tracker 0.2.0.0 - A library and a CLI tool for accessing Pivotal Tracker API  http://hackage.haskell.org/package/pivotal-tracker-0.2.0.0 (utdemir)
01:08:43 * hackage ede 0.2.9 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.9 (BrendanHay)
01:13:00 <kuribas> > succ ()
01:13:43 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
01:14:15 <jle`> neat how the Enum + Bounded laws require that succ () be undefined
01:14:35 <jle`> laws that require methods to be partial are great
01:14:44 <jle`> sorry, too much sarcasm maybe
01:14:53 <Taneb> > toEnum 0 :: ()
01:14:55 <lambdabot>  ()
01:14:58 <Taneb> > toEnum 1 :: ()
01:15:00 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
01:16:35 <kuribas> so succ should have been Enum a => a -> Maybe a?
01:17:24 <AndreasK> Sometimes it feels if some people want everything to be wrapped in Maybe :)
01:17:29 <jle`> probably not since some types should have total succ's
01:17:42 <jle`> it's only types that have Bounded instances that are required to be partial
01:17:56 <kuribas> AndreasK: I would
01:18:22 <maerwald> AndreasK: yeah, those people should switch to a language that actually supports totality ;)
01:18:23 <kuribas> I have only found one use for head, that is with scanl
01:18:34 <maerwald> and stop whining
01:18:43 <kuribas> but then that function should have been written differently
01:19:03 <kuribas> maerwald: most haskell programmers actually prefer totality
01:19:03 <jle`> people use head with group/groupBy sometimes, but group/groupBy should really return NonEmpty's
01:19:18 <kuribas> head/tail are mostly historical (with scheme/ml background)
01:19:27 <maerwald> kuribas: haskell is not a total language :)
01:19:29 <jle`> they should be hidden behind an import instead of in prelude
01:19:37 <cocreature> jle`: the one from Data.List.NonEmpty does return NonEmptys :)
01:19:41 <kuribas> maerwald: I didn't say it is?
01:19:54 <maerwald> then see my initial comment
01:19:55 <jle`> cocreature: yes, i always import it instead :)  very grateful for that one
01:19:56 <kuribas> maerwald: hence prefer, not require
01:20:19 <kuribas> Does Enum make sense for an not regular sequence?
01:20:36 <kuribas> like 0, 1, 2, 3, 4, 5, 10?
01:20:43 <jle`> Enum is only used in haskell for list comprehension sugar
01:20:48 <jle`> that is its only purpose
01:20:54 <jle`> er sorry, list enumeration sugar
01:21:01 <kuribas> it's not for conversion to numbers as well?
01:21:06 <kuribas> like C++ enum?
01:21:08 <iqubic> Nope.
01:21:13 <tdammers> I use pred / succ a lot
01:21:46 <kuribas> then what should I use for conversion to/from numbers?
01:21:51 <jle`> kuribas: fromIntegral
01:22:05 <jle`> oh, you mean for enumerables/c enums
01:22:21 <dminuoso> jle`: I use Enum in some serialization cases when I need to map some Tag to a number (say because the protocol maps 1 to `Foo`, 2 to `Bar` etc
01:22:24 <kuribas> jle`: yeah
01:22:32 <jle`> i'd say that's a hacky usage
01:22:46 <jle`> it's convenient
01:22:51 <jle`> but you can also just use Data.Data or GHC.Generics
01:22:52 <tdammers> feels brittle
01:22:59 <kuribas> jle`: erm, I need it for a binary file format
01:23:30 <dminuoso> Mmm I guess it is brittle
01:23:34 <jle`> @let data Dir = N | E | S | W deriving (Data, Generic)
01:23:35 <lambdabot>  .L.hs:167:26: error:
01:23:35 <lambdabot>      Not in scope: type constructor or class ‘Generic’
01:23:35 <lambdabot>      |
01:23:41 <AndreasK> In situations where I use head, I would use at best something like fromMaybe (error "...") (safeHead xs) instead. Since it's either the case that I know it's not empty or I do know and just don't want to deal with that case in the moment
01:23:42 <jle`> @let import GHC.Generic
01:23:42 <lambdabot>  .L.hs:136:1: error:
01:23:42 <lambdabot>      Could not find module ‘GHC.Generic’
01:23:42 <lambdabot>      Perhaps you meant GHC.Generics (from base-4.10.1.0)
01:23:43 <tdammers> in fact I'd avoid implicit enum values in C++ for that too
01:23:44 <jle`> @let import GHC.Generics
01:23:45 <lambdabot>  Defined.
01:23:47 <jle`> @let data Dir = N | E | S | W deriving (Data, Generic)
01:23:49 <lambdabot>  Defined.
01:23:54 <tdammers> just make the mapping explicit - it's verbose, but that's OK in this case
01:24:12 <tdammers> because the information isn't actually redundant
01:24:15 <jle`> > (constrIndex . toConstr) [N,E,S,W]
01:24:17 <lambdabot>  2
01:24:20 <jle`> heh
01:24:25 <jle`> > map (constrIndex . toConstr) [N,E,S,W]
01:24:27 <lambdabot>  [1,2,3,4]
01:24:45 <dminuoso> I suppose the main problem is that `toEnum` becomes partial
01:25:17 <kuribas> tdammers: I could of course just completely hide the underlying representation.
01:25:40 <tdammers> kuribas: indeed
01:25:43 <Cale> AndreasK: I just use (\(x:xs) -> x) which, if it ever fails, gives a source file and location
01:25:51 <Cale> > (\(x:xs) -> x) []
01:25:54 <lambdabot>  *Exception: <interactive>:3:2-13: Non-exhaustive patterns in lambda
01:26:03 <kuribas> tdammers: well, at least in the module export, because I'll need it in the code.
01:26:13 <jle`> > fromConstr (indexConstr (dataTypeOf N) 1)
01:26:15 <lambdabot>  ()
01:26:21 <jle`> > fromConstr (indexConstr (dataTypeOf N) 1) :: Dir
01:26:23 <Ariakenom> wait? 1-indexed constructors?
01:26:23 <lambdabot>  error:
01:26:23 <lambdabot>      • No instance for (Show Dir)
01:26:23 <lambdabot>          arising from a use of ‘show_M62377504647679644168801’
01:26:33 <jle`> @let deriving instance Show Dir
01:26:35 <lambdabot>  Defined.
01:26:38 <jle`> > fromConstr (indexConstr (dataTypeOf N) 0) :: Dir
01:26:40 <lambdabot>  *Exception: Prelude.!!: negative index
01:26:45 <jle`> hm
01:26:54 <jle`> oh yeah, it's 1-indexed
01:27:05 <tdammers> kuribas: I'm talking about braindead stupid code: case dir of { N -> 0; W -> 1; S -> 2; E -> 3 }
01:27:06 <jle`> > map (fromConstr . indexConstr (dataTypeOf N)) [1..4]
01:27:08 <lambdabot>  [(),(),(),()]
01:27:11 <jle`> > map (fromConstr . indexConstr (dataTypeOf N)) [1..4] :: [Dir]
01:27:13 <lambdabot>  [N,E,S,W]
01:27:27 <jle`> there, toEnum/fromEnum, for any instance of Data :)
01:27:36 <jle`> only slightly tricker with GHC.Generics
01:27:44 <Ariakenom> why is it 1-indexed?
01:27:47 <kuribas> that's neat
01:27:55 <tdammers> one thing that icks me is the action-at-a-distance effect of inserting additional constructors
01:28:03 <AndreasK> Cale: Yeah thats even better :) I do sometimes even use custom (error "What/Why") for these. But in the end that's still partial.
01:28:18 <tdammers> it's just super easy to break this
01:28:27 <jle`> AndreasK: the 0 is for the type constructor
01:28:52 <jle`> (disclaimer, i made that up and it doesn't make sense)
01:30:00 <jle`> it's really interesting how different the approaches in Data.Data and GHC.Generics are, yet how subtle their overlap is
01:30:08 <jle`> *overlap in use case
01:31:19 <kuribas> What's better, UnicodeVariationSequences or UnicodeVarSeqs
01:31:29 <kuribas> (sorry stupid question)
01:31:30 <jle`> hm
01:31:38 <jle`> UnicodeVarSeqs has a simpler API but is outdated
01:31:48 <jle`> the last update was years ago
01:32:05 <kuribas> jle`: what do you mean?
01:32:14 <jchia> aeson question: If for some type Foo I implement toJSON, the default toEncoding is simply "value . toJSON". However, if I implement only toEncoding for Foo, can I get a toJSON based on the toEncoding? I would like the code to be DRY.
01:32:32 <jle`> oh sorry just making a joke about how often in haskell we get so many packages with similar functionalities whose names are almost identical
01:32:59 <kuribas> jle`: ah I see :)
01:33:15 <kuribas> jchia: the reason for the two is that it's more efficient.
01:33:21 <jle`> it depends on how often they are used
01:33:38 <kuribas> not so often I suppose
01:34:08 <jchia> kuribas: I know. Does that mean if I want efficiency I may have to implement both toJSON and toEncoding? (The representation is non-standard so I can use the generic instances).
01:34:17 <jchia> can't
01:34:59 <jle`> i try to assign variable names roughly based on zipf's law
01:35:13 <jle`> (regarding their lengths)
01:35:15 <jle`> s/variable/identifier
01:35:58 <cocreature> jchia: I don’t think you can, Encoding is a wrapper around a ByteString builder. if you want a value you would have to parse the resulting bytestring
01:39:09 <jchia> cocreature: I suppose a related point is that if you implement both toJSON and toEncoding, you probably want tests to check that "value . toJSON" produces the same result as toEncoding.
01:39:21 <cocreature> right
01:39:30 <cocreature> property test all the things!
01:43:24 <jchia> cocreature: Actually, I wonder about dictionary order. If the toJSON and toEncoding use different dictionary key order, the encoding bytestring will be different.
01:44:03 <jchia> But I'm not sure if the inequality is a real problem except for the test failure.
01:44:10 <cocreature> well fix your test :)
01:44:53 <jchia> cocreature: I think the right way is to make FromJSON and Eq instances also, even if you don't need them.
01:45:17 <jchia> That's a lot of trouble for being able to use toEncoding.
01:45:21 <cocreature> that’s not necessary, you can just decode to Value and use the Eq instance of that
01:45:32 <jchia> true
01:59:12 * hackage permutations 0.1.0.0 - Permutations of finite sets  http://hackage.haskell.org/package/permutations-0.1.0.0 (MatthewFarkasDyck)
02:03:46 <dminuoso> Mmm, when I use a constraint based transformer as opposed to specifying a full stack, couldn't that prevent optimizations?
02:05:22 <cocreature> dminuoso: sure if GHC isn’t able to specialize things (which can happen fairly easily across modules when you don’t add INLINABLE constraints), things will go bad
02:18:33 <AWizzArd> http://www.stephendiehl.com/posts/monads.html   says:  type (a ~> b) c = c a b       – what is that `~>` there?
02:19:26 <cocreature> AWizzArd: it’s the name of the type synonym
02:19:28 <liste> AWizzArd: it's the name of that type alias
02:23:55 <AWizzArd> Ooh okay, sure! Thx :-)
02:45:39 <lortabac> hello
02:45:53 <lortabac> I have a program that makes GHC get stuck
02:46:20 <lastmanstanding> I'm struggling with IO while learning Haskell. I have a program http://dpaste.com/1TK0MZ6 which throws a compiler error. Can someone help?
02:46:31 <lortabac> it doesn't look like non-termination in instance resolution
02:46:50 <lortabac> anyone knows why this could happen or how to debug?
02:47:00 <lastmanstanding> I understand I'm using read in the wrong way/
02:47:01 <lastmanstanding> ?
02:47:02 <lemmih> lortabac: Using any unsafe extensions?
02:47:14 <kuribas> how do you annotated do variable bindings?
02:47:28 <capisce> lastmanstanding: that's a compile error, not a compiler error :)
02:47:39 <lortabac> lemmih: it happened when I switched to the new version of generic-lens
02:47:49 <lemmih> lastmanstanding: Look at 'length unique xes'.
02:47:53 <lastmanstanding> capisce: sorry. I meant that my program is not compiling.
02:47:54 <lortabac> lemmih: so yes, lots of unsafe extensions probably :)
02:48:43 <lemmih> lortabac: I think your best option is to comment out code until you find the exact location of the problem.
02:49:26 <capisce> lastmanstanding: should that be "head $" and not "head ."?
02:49:57 <lortabac> lemmih: I think too, compiling with -v didn't help much
02:50:50 <cocreature> lortabac: compiling with -O0 is also often a useful first step
02:51:06 <lortabac> cocreature: it gets stuck on all -O levels
02:52:04 <lastmanstanding> capisce: . is function chaining no? Yes. You're right.
02:52:23 <tdammers> lortabac: that is an important piece of information already
02:52:26 <cocreature> lortabac: if it happens at -O0 I would start searching for a bug in my own code first :)
02:52:32 <lastmanstanding> I'll give this another hour or so and come back. Clearly I've not done my work.
02:52:52 <cocreature> GHC certainly has bugs but an infinite loop at -O0 is not that common
02:53:01 <lortabac> cocreature: true, but it worked until today :)
02:53:22 <cocreature> lortabac: that’s not really an indicator in either direction
02:53:27 <lortabac> :)
02:53:50 <lortabac> I just tried it in GHCI, it still gets stuck
02:54:11 <tdammers> seriously, I've seen more than one GHC ticket where an improvement in GHC itself revealed bugs in existing code
02:54:50 <cocreature> either way narrowing it down by removing code is a good first step
02:54:56 <tdammers> yes
02:55:14 <tdammers> also if you can boil it down to say 100 lines in a self-contained source file, people will be a lot more willing to take a look
02:55:23 <lortabac> ok I will try by commenting functions one by one
02:55:36 <lortabac> tdammers: I can't post the code for the moment
02:56:01 <tdammers> lortabac: why? legal reasons?
02:56:17 <lortabac> tdammers: it's for my job
02:56:37 <lortabac> but I can try narrowing it down and producing a minimal example
02:56:47 <tdammers> by all means do
02:56:55 <tdammers> chances are you figure it out all by yourself this way ;)
02:57:01 <lortabac> maybe :)
03:02:17 <maerwald> any good introductions into event sourcing in haskell?
03:06:51 <fr33domlover> maerwald, what do you mean?
03:07:55 <maerwald> fr33domlover: what is not clear with this question?
03:10:44 <capisce> markus1199: http://abailly.github.io/posts/cm-arch-design.html
03:11:34 <capisce> markus1199: this might be Scala but maybe it's still interesting: https://www.youtube.com/watch?v=1rFY2SfdDoE
03:12:10 <capisce> maerwald: ^^
03:12:14 <capisce> sorry markus1199
03:12:16 <capisce> http://abailly.github.io/posts/event-source.html
03:12:34 <capisce> http://blog.akii.de/posts/2017-06-04-eventsourcing-in-haskell.html
03:12:37 <maerwald> thanks
03:22:53 <AWizzArd> I once found a web page that explained how and when ghc is using the stack and when it’s using the heap.
03:23:05 <AWizzArd> I think I recall they talked about `let` and `case`.
03:23:09 <MarcelineVQ> surely some ezyang post
03:24:31 <AWizzArd> MarcelineVQ: oki, will have a look. Thx for the pointer.
03:25:35 <MarcelineVQ> he's got a little series starting with http://blog.ezyang.com/2011/04/the-haskell-heap/
03:26:26 <AWizzArd> MarcelineVQ: reading this now.
03:26:53 <AWizzArd> Those little images remind me of adit.io
03:28:32 <AWizzArd> That was not it, but also an interesting read.
03:29:00 <AWizzArd> The one I was looking for was something like: everything goes to the heap with the exception of everything that you put into `case` (or something like that).
03:32:26 <bwe> Hi,  getValue [Volume 67000] -- returns 13.4
03:32:44 <bwe> 13.5 - getValue [Volume 67000] -- returns 9.999999999999964e-2
03:32:59 <bwe> How do floating point right?
03:33:25 <bwe> I expect the result of 0.1, not 9.999999999999964e-2.
03:33:54 <liste> bwe: just truncate to a given number of decimals
03:34:05 <liste> round*
03:34:32 <liste> @let import Numeric
03:34:34 <lambdabot>  Defined.
03:34:50 <tdammers> this is inherent to floating-point numbers
03:34:52 <lemmih> > showFFloat (Just 1) 9.999999999999964e-2 ""
03:34:54 <lambdabot>  "0.1"
03:35:15 <tdammers> if you want to do these calculations exactly, pick a different numeric type, e.g. Scientific
03:35:24 <liste> bwe: floats can't represent "0.1" exactly, they just use a number very close to that
03:35:35 <liste> (same applies for doubles)
03:36:07 <bwe> tdammers: Well, I don't need a precise result per se, I would be fine with precision of 3 decimals.
03:36:25 <bwe> tdammers: Is there a reason here to go for Scientific instead of roundTo?
03:36:32 <liste> bwe: then you can just use showFFloat
03:37:26 <AWizzArd> bwe: you probably know this already, but just in case: https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
03:37:27 <tdammers> bwe: only if you want the calculations themselves to be 100% exact. If this is a garbage-in-garbage-out scenario anyway, and you're only interested in a sane presentation, then keep using floats and just round (i.e., showFFloat or the like)
03:37:55 <tdammers> > printf "%3.1f" 9.999999999999999999999e-2
03:37:57 <lambdabot>  error:
03:37:57 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M852401676066...
03:37:57 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
03:38:04 <tdammers> > printf "%3.1f" 9.999999999999999999999e-2 :: String
03:38:06 <lambdabot>  "0.1"
03:38:09 <liste> volume measurements are probably not precise anyway
03:38:15 <tdammers> exactly
03:38:22 <bwe> liste, tdammers: Yup, I'll go for the showFFloat scenario. AWizzArd: True, how did you know?
03:38:58 <tdammers> bwe: see my printf example, too - showFFloat of course works, but if you're going to assemble string output anyway, printf might make for nicer code
03:39:13 * hackage hspec-core 2.5.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.5.1 (SimonHengel)
03:40:03 <bwe> tdammers: I expect to return a Double.
03:40:13 * hackage hspec 2.5.1, hspec-discover 2.5.1 (SimonHengel): https://qbin.io/surely-depend-rotk
03:40:29 <tdammers> bwe: then just keep the 9.9999999999999999e-2 thing around
03:40:45 <bwe> tdammers: Which makes testing bad.
03:40:56 <tdammers> then you're testing wrong
03:41:16 <tdammers> you shouldn't assert that the return value is exactly 0.1
03:41:18 <liste> just check if the difference is smaller than some eopsilon
03:41:28 <liste> epsilon*
03:41:36 <tdammers> you should assert that it's between 0.1 +/- epsilon
03:41:47 <tdammers> where epsilon is a sufficiently small number
03:42:07 <liste> for every δ, there's an ε
03:42:18 <bwe> tdammers: having a piece of example code handy for me?
03:42:29 <tdammers> because when you write assertEqual result 0.1, you're not actually comparing against 0.1 exactly, but rather against whatever closest possible approximation the float can represent
03:42:45 <cocreature> @hackage HUnit-approx
03:42:45 <lambdabot> http://hackage.haskell.org/package/HUnit-approx
03:42:50 <cocreature> ^ bwe
03:43:22 <cocreature> liste: no, for every ε there’s a δ!
03:44:23 <ancarda> I have a question about error handling in Haskell. Why does `readFile :: FilePath -> IO String` throw an exception and not something like `Either IOErrorCode (IO String)`? Why is an exception used and not always a value of some kind?
03:45:24 <liste> cocreature: thanks for the correction :)
03:45:38 <liste> there's a song we used to memorize that but I remembered the song lyrics wrong
03:45:46 <capisce> ancarda: http://degoes.net/articles/bifunctor-io
03:45:56 <liste> they were "there's a δ, for every ε"
03:45:59 <capisce> ancarda: if anything it'd have to be IO (Either IOErrorCode String)
03:46:45 <cocreature> liste: where’s the video of you performing that song? :)
03:48:22 <ancarda> capisce: Thanks for the link, I might have to try reading that again as my mind is all foggy trying to understand what he's talking about
03:48:25 <liste> cocreature: not me, but https://youtu.be/zxFCQplZgKI?t=3m1s
04:10:55 <Darwin226> So I'm having issues with the text-icu package on Windows again. I've recently updated the icu lib to version 61 and now I'm getting unknown symbol errors
04:11:20 <Darwin226> So I've done a bit of digging around
04:11:38 <Darwin226> The error is something like "unknown symbol ucnv_getMaxCharSize61"
04:11:58 <Darwin226> but the actual library exports that symbol as "__imp_ucnv_getMaxCharSize61"
04:12:30 <Darwin226> and changing that in the text_icu.c file in the text-icu library "seems" to work
04:12:49 <Darwin226> and by seems to work I mean I get the same error but about a different symbol
04:13:08 <Darwin226> so before I go and change all of them to the __imp prefix I thought I'd ask if anyone knew anything about this
04:13:44 <Darwin226> Is there supposed to be some mechanism that translates those things? Because the source doesn't mention the 61 at the end of the symbol
04:13:54 <Darwin226> yet somehow the missing symbol has the 61 at the end
04:14:22 <Darwin226> so some interaction must be happening between the text-icu library and the icu lib I have installed
04:16:42 <cocreature> Darwin226: https://github.com/bos/text-icu/pull/36 looks relevant
04:17:16 <Darwin226> Hey, it's me, LukaHorvat
04:17:27 <cocreature> oh :)
04:18:10 <Darwin226> This did fix the error with icu58, but it seems to break with 61
04:24:43 <Darwin226> So I've checked with a colleague who still has the 58 version and it seems that it also exported getMaxCharSize with the imp prefix
04:24:46 <Darwin226> so that can't be it
04:31:50 <BernhardPosselt> I'm parsing a few things out of an XML and the parsing can fail or there simply can be no element to parse. now I'm stuck with a List Maybe (Either (Thing ParseError))
04:32:17 <BernhardPosselt> is there a way to flatten this to a Either List ParseError
04:32:40 <fr33domlover> BernhardPosselt, which library are you using
04:32:59 <BernhardPosselt> fr33domlover: none (tried to translate the issue from java)
04:33:13 <BernhardPosselt> lambdas and checked exceptions don't play nicely
04:33:37 <quicksilver> yes, BernhardPosselt
04:33:41 <fr33domlover> BernhardPosselt, you mean you're writing your own XML parser?
04:33:53 <BernhardPosselt> fr33domlover: no, I need to parse Strings into Integers
04:34:04 <BernhardPosselt> or Decimals
04:34:08 <quicksilver> with the right instances, sequence has the type [Either Error a] -> Either Error [a]
04:34:25 <quicksilver> note that by convention we put the failure condition on the left, not the right
04:35:05 <BernhardPosselt> I see thanks
04:35:43 <quicksilver> > sequence [Right 1, Right 2, Right 3]
04:35:45 <lambdabot>  Right [1,2,3]
04:36:48 <fr33domlover> BernhardPosselt, also check out functions like 'maybe', 'fromMaybe', 'either'
04:36:58 <bbear> I don't understand how foldMap works
04:38:31 <fr33domlover> bbear, do you understand how folding works? foldl, foldr?
04:38:44 <ddellacosta> bbear: can you say more about what you're having trouble with?
04:39:02 <ddellacosta> oh whoops...maybe good to go with one line of questioning at a time :-D
04:39:41 <Ariakenom> ddellacosta: not on my IRC. we need concurrency!
04:39:47 <ddellacosta> haha
04:49:27 <robstr> I'm trying to use a custom monad for servant but stuggle with compile errors https://gist.github.com/rsoeldner/4147af54504259f57e1c412ef6b06a4d - the Problem for me seems how to convert IO <-> Handler, can someone help here ?
04:51:15 <Gurkenglas_> How do I set getChar to resolve on the next button press, not the next newline press?
04:51:30 <robstr> OMG got it, just needed a `liftIO`
04:51:46 <quicksilver> Gurkenglas_: change the buffering setting on standard input
04:52:29 <quicksilver> https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#g:12
04:52:34 <Gurkenglas_> quicksilver: hSetBuffering stdout NoBuffering didn't help
04:52:41 <quicksilver> stdin
04:52:49 <Gurkenglas_> that too
04:53:22 <quicksilver> using windows?
04:53:25 <Gurkenglas_> linux
04:53:29 <quicksilver> odd
04:53:33 <Gurkenglas_> openSUSE, to be exact
04:53:56 <Gurkenglas_> Uh I suppose that machine I'm actually sshing onto might not be openSUSE
04:54:54 <Gurkenglas_> *checks* yep, openSUSE.
04:55:09 <BernhardPosselt> when dealing with nested Monads like Maybe Either (a, b) and I want a map operation that maps the innermost value, I want a Monad Transformer, correct?
04:55:15 <Gurkenglas_> hmm maybe the ssh has buffered std
04:55:46 <Gurkenglas_> BernhardPosselt: for that specific case applicative composition is enough
04:56:01 <BernhardPosselt> composition?
04:56:10 <kuribas> @hoogle (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
04:56:11 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
04:56:11 <lambdabot> Text.XML.Cursor (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:56:11 <lambdabot> Text.XML.Cursor.Generic (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:56:40 <BernhardPosselt> Gurkenglas_: I guess composition is different from <*>
04:56:51 <Gurkenglas_> In fact if you don't need traverse-like behavior you need even less
04:57:24 <kuribas> there is no two argument (>>=) right?
04:57:41 <Gurkenglas_> :t fmap (fmap (+1)) :: Maybe (Either a Int) -> Maybe (Either a Int)
04:57:42 <lambdabot> Maybe (Either a Int) -> Maybe (Either a Int)
04:58:17 <quicksilver> Gurkenglas_: ssh doesn't buffer when terminal settings forbid it
04:58:22 <quicksilver> Gurkenglas_: however, your terminal program might
05:00:23 <Gurkenglas_> open xfce4-terminal, run ssh, run emacs, open shell, run .hs using stack, despair about buffering
05:00:51 <kuribas> BernhardPosselt: or a lens :)
05:00:53 <quicksilver> what paste service do people use now lpaste is down?
05:02:02 <aleator> quicksilver: Not the answer you're looking for: ipfs :)
05:02:05 <Gurkenglas_> Ah yes someone update the topic.
05:02:08 <quicksilver> Gurkenglas_: https://pastebin.com/8ekYCFpt
05:02:13 <Ariakenom> :t fmap . fmap . fmap
05:02:14 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
05:02:26 <quicksilver> Gurkenglas_: for me that program compiles and very clearly doesn't buffer the getchar
05:02:35 <quicksilver> admittedly the only GHC I have to hand is 6.12
05:02:39 <quicksilver> but I don't believe this has changed
05:03:08 <Gurkenglas_> quicksilver: buffers it for me
05:03:22 <quicksilver> oh hang on 'open shell'
05:03:25 <quicksilver> emacs shell does line buffering
05:03:43 <quicksilver> if that's what you meant.
05:03:49 <cocreature> quicksilver: github gists are pretty ok imho
05:04:08 <Ariakenom> (fmap.fmap.fmap) :: (a->b) -> Maybe (Either (x,a)) -> Maybe (Either (x,b))
05:04:12 <quicksilver> cocreature: I don't like random IRC help pastes being attached to my work github account
05:04:19 <quicksilver> cocreature: mayb that's really dumbon my part
05:04:22 <quicksilver> I am quite dumb.
05:04:42 <quicksilver> I could log into github as quicksilver in an incognito window but that seems like a lot of work :)
05:04:53 <cocreature> quicksilver: you can make “private gists” that are still publically viewable to anyone that knows the link but not listed in your github profile
05:05:30 <Gurkenglas_> quicksilver: that was it, and so ends the relvancy of my question to #haskell
05:05:59 <quicksilver> Gurkenglas_: yay. Try M-x term for an emacs shell which isn't line-buffered
05:06:14 <quicksilver> but beware it's hard to type emacs commands in it because your keys are being sent to subprocesses :)
05:06:43 <marvin3> @pl \mx my f -> mx >>= \x -> my >>= \y -> f x y
05:06:43 <lambdabot> (. ((.) . (>>=))) . (.) . (>>=)
05:06:58 <Gurkenglas_> quicksilver: coulda told me that before i opened it D:
05:07:09 <marvin3> kuribas, there you go :]
05:07:12 <Gurkenglas_> Can't even Ctrl-Z out of emacs ;_;
05:08:03 <kuribas> marvin3: yeah, I'm using join $ liftM2 f x y now
05:08:38 <marvin3> :t liftM²
05:08:39 <lambdabot> error:
05:08:39 <lambdabot>     • Variable not in scope: liftM²
05:08:39 <lambdabot>     • Perhaps you meant one of these:
05:08:43 <marvin3> :t liftM2
05:08:44 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:09:35 <marvin3> different signature of the function, (a -> b -> c), not (a -> b -> m c)
05:10:37 <quicksilver> Gurkenglas: https://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html
05:12:30 <Gurkenglas> quicksilver: this "term escape character" C-c merely prints "^C" as if I wrote that in as a command when pressed twice
05:13:48 <Gurkenglas> Ah, I misread. C-c o gets out
05:18:40 <Gurkenglas> Can I capture keyboard events such as arrow keys and backspace using getChar?
05:19:09 <Gurkenglas> Can I print lines such that I can take back their printing?
05:19:36 <maerwald> why don't you test getChar in ghci
05:21:13 <liste> @hackage vty -- Gurkenglas
05:21:13 <lambdabot> http://hackage.haskell.org/package/vty -- Gurkenglas
05:21:44 <liste> @hackage ansi-terminal -- Gurkenglas
05:21:44 <lambdabot> http://hackage.haskell.org/package/ansi-terminal -- Gurkenglas
05:21:51 <Gurkenglas> maerwald: I found it unlikely enough that this would work that I would get an answer that suggests an alternative to getChar which does this
05:22:02 <Gurkenglas> *that I expected to get
05:22:27 <quicksilver> it is possible to get arrow keys from getChar but it requires you to write part of your own terminal emulator
05:22:33 <quicksilver> I don't really recommend that
05:23:00 <quicksilver> I would suggest using a proper terminal keyboard layer like the two liste posted, or switching to a library with real keyboard events like SDL
05:23:04 <quicksilver> depends what you're trying to do
05:30:23 <dminuoso> edwardk: Hey there. Was EitherT from the either package moved into mtl and renamed to ExceptT?
05:30:40 <hvr> dminuoso: hah, that's a super fun story!
05:30:49 <hvr> ed loves to tell that story
05:33:37 <Gurkenglas> stack unpack reactive-banana-wx, cd reactive<TAB>, stack init --solver: "Dependency tree exhaustively searched." it tried using lts-10.10 and ghc-8.2.2. wat do?
05:34:01 * hvr bites his tongue
05:36:49 * mclaren bites his tongue. the blood gushes out of the now-severed tongue.
05:36:54 <kuribas> I talked with a recruiter who was actually interested in haskell :-)
05:37:03 <wz1000> hvr: any update on uploading haddock 2.20 to hackage?
05:37:10 <hvr> wz1000: ah, good point!
05:37:30 <kuribas> She wanted to speak about it with the manager.
05:37:39 <hvr> wz1000: will try to get this done today/tomorrow
05:37:43 <wz1000> cool
05:38:05 <hvr> wz1000: thanks for not posting a reddit thread about it! :-)
05:39:57 <hvr> kuribas: ...and it didn't turn out to be a phonetic mixup of pascal vs haskell?
05:40:05 <kuribas> hvr: no :-)
05:40:14 <kuribas> hvr: though I hope the manager doesn't think that
05:40:41 <kuribas> "Pascall, that old language?"
05:41:06 <Darwin226> How does the linker know to look for libsomething if the extra-library field only mentions 'something'?
05:41:15 <hvr> no, the other 28 year old one....
05:41:28 <opqdonut> Darwin226: that rule is built into the unix linkers
05:42:12 <Darwin226> Because my text-icu thing seems to work if I put 'libicuio' into extra-libraries
05:42:18 <Darwin226> and it doesn't with just icuio
05:42:32 <hvr> Darwin226: is this windows?
05:42:36 <Darwin226> Indeed
05:42:55 <hvr> :-)
05:43:08 <Darwin226> It worked before with icu 58
05:43:10 <hvr> I don't remember details, but I do recall there was some trickiness on windows re that lib prefix
05:43:12 <Darwin226> but doesn't with icu 61
05:46:42 * hackage hedgehog 0.6 - Hedgehog will eat all your bugs.  http://hackage.haskell.org/package/hedgehog-0.6 (JacobStanley)
05:49:48 <habolabo> hmm. it seems rather... complicated... to set up local library sharing
05:51:21 <Gurkenglas> https://pastebin.com/xRgAa0Ex seems like the end is not supposed to pop up even if there's a dependency tree with no solution, but how does one handle this sort of situation?
05:52:09 <Darwin226> Is there a way to show which dynamic libraries GHCi is linking/attempting to link?
05:57:56 <Gurkenglas> Can I use stack to, say, build the package as cabal would?
05:59:02 <ventonegro> Gurkenglas: What's wrong with `stack build`?
06:01:12 * hackage hasbolt-extras 0.0.0.8 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.8 (ozzzzz)
06:01:40 <Gurkenglas> ventonegro: suggests stack init
06:01:49 <Gurkenglas> ventonegro: suggests stack init --solver
06:02:02 <Gurkenglas> ventonegro: says Dependency tree exhaustively searched.
06:03:49 <ventonegro> Gurkenglas: Why does it suggest `stack init`? What's the rest of the message?
06:04:27 <Gurkenglas> ventonegro: https://pastebin.com/gTReDrm7
06:05:03 <ventonegro> Gurkenglas: Could you also paste stack.yaml?
06:05:23 <Gurkenglas> ventonegro: no such file
06:05:53 <ventonegro> Gurkenglas: Now I am confused
06:06:19 <ventonegro> Gurkenglas: Why are running stack to begin with?
06:06:26 <ventonegro> are you*
06:06:26 <Gurkenglas> ventonegro: stack unpack downloads whatever's on hackage, reflective-banana-wx does not use stack
06:06:46 <Gurkenglas> ventonegro: How do I use Haskell stuff without stack?
06:07:13 <ventonegro> Gurkenglas: Try cabal new-build
06:07:26 <Gurkenglas> How do I use stack to run cabal new-build?
06:09:28 <ventonegro> Gurkenglas: `stack install cabal-install`
06:09:44 <ventonegro> And add ~/.local/bin to your PATH
06:11:29 <Gurkenglas> While that's installing, shouldn't stack work for all of these?
06:11:44 <Gurkenglas> As in, how can cabal find a resolution if stack can't?
06:12:25 <ventonegro> You don't even have a stack.yaml file, so I don't understand the complaint
06:12:55 <MarcelineVQ> when solving constrains stack only considers what's in resolvers, if nothing compatable is found it calls out to cabal-install to make a build plan from what hackage can provide
06:12:57 <Gurkenglas> ventonegro: stack init should generate that one afaik
06:14:03 <Gurkenglas> MarcelineVQ: that sure sounds like stack should never fail if cabal doesn't
06:15:27 <MarcelineVQ> idk, my cabal crashes when solving so I can't test it out :X
06:16:28 <zenwan> hello, anyone with more knowledge of existential types/ST monad care to have a look? I've translated this code (https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) into the ST monad, the abomination here: https://bpaste.net/show/93149490bb8c. Seemed to be fine, but after adding the commented lines it fails to compile (https://bpaste.net/show/6fb0fd20572a). What exactly is it complaining about?
06:16:53 <ventonegro> Cabal crashes? I don't believe you
06:17:18 <ZeuPiark> hello
06:19:31 <lyxia> zenwan: by default the type variable s in those local signatures is fresh and distinct from the one on line 21
06:19:35 <mniip> zenwan, you tried to use an array created in a different runST block
06:19:57 <lyxia> zenwan: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lexically-scoped-type-variables
06:20:19 <mniip> oh rather
06:20:24 <mniip>     let -- processVertex :: DS.Seq Int -> (Int, Int) -> ST s (DS.Seq Int)
06:20:28 <mniip> this creates a new 's' variable
06:20:37 <mniip> differnt from the one in the surrounding do block
06:20:48 <Taneb> ...is it bad I just used id infix because I wanted $ with a different fixit
06:20:49 <Taneb> y
06:21:00 <mniip> hence the 's' in the closed-over binding 'dist' is different
06:25:21 <zenwan> hmm, i guess I should re-read the theory, as it's not clear to me how to ensure that it uses the same s as in the enclosing binding. Simply enabling ScopedTypeVariables doesn't seem to solve the issue. Thanks anyway.
06:26:42 <cocreature> zenwan: you need to add an explicit forall for ScopedTypeVariables to have any effect
06:27:28 <zenwan> yeah, i just did that and it worked
06:27:50 <zenwan> i thought forall s. was supposed to be implicit
06:28:07 <zenwan> thanks
06:28:46 <Ariakenom> zenwan: But wouldn't you want to use the inferred, more general type?
06:29:40 <Ariakenom> You can replace the type declaration with "processVertex :: _" to have ghc tell you the inferred type
06:30:07 <cocreature> zenwan: the forall is implicit. the reason why you need to make it explicit for ScopedTypeVariables is so that turning on ScopedTypeVariables won’t break existing code
06:30:12 <cocreature> it’s just an ugly hack
06:30:21 <dmwit> Gurkenglas: Hm, my understanding of stack differs from what MarcelineVQ said. My understanding is that stack only uses a fixed version of any package in the current resolver, and ships out to a solver only for packages it doesn't know about. So it's easy to have a failure with stack but not cabal: any time cabal would choose a different version than what's in the resolver, e.g.
06:30:31 <rotcev> i am looking at the ScopedTypeVariables wiki page (https://wiki.haskell.org/Scoped_type_variables), I am curious as to what the definition of "free type variable" is, I can't really tell the difference between mkpair2 and mkpair3
06:31:03 <cocreature> dmwit: stack does have a mode where it calls out to cabal to do dependency solving. (stack init --solver)
06:31:15 <JonnyRaa> Hi!  I'm looking for some help with using lenses - I'm trying to use a lens which is parameterised like this: Lens' (LegsAtLocation a) [a] on LegsAtLocation a and LegsAtLocationB.  My function takes the lens as a parameter and I'm stuggling to find the right type/combination of extensions!  I feel like I could probably pass the same lens in twice at the top level and it would just work but that feels ugly
06:31:18 <cocreature> but it doesn’t seem to do exactly what cabal does because it never seems to work :)
06:31:29 <dmwit> Gurkenglas: (It's probably also possible for cabal's solver to fail when stack wouldn't, e.g. because cabal's solver definitely isn't complete whether by design or by bug.)
06:32:44 <dmwit> rotcev: Free type variables are those ones not bound by a `forall` or a `class` declaration.
06:32:57 <MarcelineVQ> dmwit: when stack is solving, in order to create a stack.yaml where one doesn't exists, it will try a list of resolvers before asking cabal to help
06:32:58 <dmwit> Not 100% sure of the rules for type families/instances.
06:33:15 <dmwit> MarcelineVQ: ah, ok
06:33:20 <MarcelineVQ> and if one works that's the resolver that goes in the new yaml
06:35:13 <dmwit> rotcev: Actually, I think I'd skip that wiki page (it's way too brief) in favor of the GHC documentation, which is quite readable. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables
06:35:46 <rotcev> dmwit: thanks, i'll have a read
06:36:07 <JonnyRaa>   type TrainLegs = LegsAtLocation TrainLeg
06:36:07 <JonnyRaa>   type FormationLegs = LegsAtLocation FormationLeg
06:36:07 <JonnyRaa>   data LegsAtLocation a = LegsAtLocation {
06:36:07 <JonnyRaa>     _arrivals :: [a]
06:36:07 <JonnyRaa>   , _departures :: [a]
06:36:08 <JonnyRaa>   }
06:36:08 <JonnyRaa>   claimItem :: forall a. Lens' (LegsAtLocation a) [a] -> (TrainLegs, FormationLegs) -> FormationLeg
06:36:09 <JonnyRaa>             -> ((TrainLegs, FormationLegs), Maybe TrainLeg)
06:36:09 <JonnyRaa>   claimItem theLens currentState@(allLegs, subset) leg = (output, match)
06:36:10 <JonnyRaa>     where
06:36:10 <JonnyRaa>     output :: (TrainLegs, FormationLegs)
06:36:11 <JonnyRaa>     output = case match of
06:36:11 <JonnyRaa> >>    Just trainLeg -> (set theLens remaining allLegs, over theLens (leg :) subset)
06:36:12 <JonnyRaa>       Nothing -> currentState
06:36:16 <MarcelineVQ> woops
06:39:39 <rotcev> is it true that forall is present, even if i don't explicitly type it?
06:40:20 <rotcev> and i suppose explicitly typing forall is only beneficial when you are using some of these extensions
06:41:33 <dmwit> Yes, in Haskell, every type variable is implicitly universally quantified at the top level of the type.
06:41:45 <Gurkenglas> ventonegro: https://pastebin.com/U2w0ULL4
06:42:08 <dmwit> Yes, explicitly typing forall is only beneficial (indeed, only allowed) when you are using certain GHC extensions.
06:43:14 <dmwit> The other big extensions where explicit foralls change things are RankNTypes, ExistentialQuantification, and GADTs.
06:44:11 <cocreature> those extensions don’t really change things. they allow you to compile code that would otherwise fail to compile
06:44:21 <cocreature> existing code should be unaffected by turning them on
06:44:42 <dmwit> No objections from the defense.
06:44:56 <ventonegro> Gurkenglas: Sorry, but this seems related to the packages you are trying to build, which I don't know :(
06:45:12 <ventonegro> Gurkenglas: Did you try with `new-build`?
06:45:26 <Gurkenglas> ventonegro: Do you think cabal got further than stack?
06:45:44 <Gurkenglas> (Should read replies via logs)
06:45:52 <dmwit> Gurkenglas: That's odd. wx is definitely on Hackage.
06:46:02 <cocreature> have you run "cabal update"?
06:46:09 <ventonegro> Gurkenglas: Doesn't look like it, the error is similar
06:46:39 <cocreature> also 1.24 is a fairly old version of cabal. you might want to try a newer one
06:46:48 <dmwit> Gurkenglas: Oh, `cabal build`.
06:46:58 <dmwit> Gurkenglas: You should `cabal install --only-dependencies` before you `cabal build`.
06:47:05 <dmwit> Gurkenglas: Or, as suggested above, use `cabal new-build`.
06:48:07 <dmwit> Gurkenglas: Or use `cabal install` instead of `cabal build`. (`cabal build` doesn't do any dependency management, by design.)
06:55:45 <JonnyRaa> So I can make my code compile by passing the same lens in twice with different type signatures if I use the raw lens... however if I write a function where I pass the lens in once and then pass it off to the subsequent function twice it doesn't compile.  I'm assuming that I    The chain of functions goes like this: claimItem arrivals arrivals (arrivals is the lens) is ok, but claimItemUgly lens = claimItem lens lens fails to compile.  I
06:55:45 <JonnyRaa>  feel like I'm probably just not expressing the type properly and the compiler can't help me if I just replace it with an underscore
06:56:17 <JonnyRaa> so I couldn't just write claimItemUgly arrivals
06:58:33 <cocreature> JonnyRaa: can you show us the code and the error messages? that might make it a bit easier to follow
07:00:28 <lyxia> claimItem lens = claimItem (cloneLens lens) (cloneLens lens)    or add a type signature to claimItem with an explicit Lens argument type (there is a forall in Lens which prevents GHC from inferring it).
07:01:55 <JonnyRaa> I tried posting some of it before but I think I got momentarily kicked off for flooding!
07:02:05 <aarvar> with PartialTypeSignatures you can write foo (l :: Lens _ _ _ _) = ...
07:02:13 <aarvar> and it will infer the rest
07:04:19 <JonnyRaa> type signatures: `  claimItem :: Lens' (LegsAtLocation TrainLeg) [TrainLeg] -> Lens' (LegsAtLocation FormationLeg) [FormationLeg] -> (TrainLegs, FormationLegs) -> FormationLeg -> ((TrainLegs, FormationLegs), Maybe TrainLeg)`
07:04:41 <JonnyRaa> really the first two arguments are actually the same lens
07:04:59 <Taneb> JonnyRaa: what happens if you write "cloneLens" before each instance of the lens?
07:05:08 <JonnyRaa> so TrainLegs and FormationLegs are just aliases for LegsAtLocation Formation leg...
07:05:12 <JonnyRaa> I'll just try that
07:05:49 <JonnyRaa> underscores produced a different error message but still complaining about mismatch between FormationLeg and Train
07:08:05 <JonnyRaa> which is the same error message as with cloneLens:
07:08:05 <JonnyRaa>     • Couldn't match type ‘TrainLeg’ with ‘FormationLeg’
07:08:05 <JonnyRaa>       Expected type: ([FormationLeg] -> f [FormationLeg])
07:08:05 <JonnyRaa>                      -> LegsAtLocation FormationLeg -> f (LegsAtLocation FormationLeg)
07:08:05 <JonnyRaa>         Actual type: ([TrainLeg] -> f [TrainLeg])
07:08:06 <JonnyRaa>                      -> LegsAtLocation TrainLeg -> f (LegsAtLocation TrainLeg)
07:08:06 <JonnyRaa>     • In the second argument of ‘claimItem’, namely ‘(cloneLens lens)’
07:08:07 <JonnyRaa>       In the expression: claimItem (cloneLens lens) (cloneLens lens)
07:08:07 <JonnyRaa>       In an equation for ‘claimItemUgly’:
07:08:08 <JonnyRaa>           claimItemUgly lens = claimItem (cloneLens lens) (cloneLens lens)
07:08:08 <JonnyRaa>    |
07:08:09 <JonnyRaa> 41 | claimItemUgly lens = claimItem (cloneLens lens) (cloneLens lens)
07:08:09 <JonnyRaa>    |
07:08:13 <cocreature> JonnyRaa: use a pastebin site
07:11:13 <JonnyRaa> so code is here:  there are one or two functions/types missing but they aren't that important https://pastebin.com/KV7Y6Yy4
07:14:28 <JonnyRaa> claimItem's contents are fairly irrelevant except for the use of lenses on two different LegsAtLocation types
07:15:32 <JonnyRaa> it did all previously work on TrainLegs.. I'm in the process of rewriting to remove the maybe return value and just have it modiy the FormationLegs instead
07:17:11 <cocreature> JonnyRaa: try something like claimItem :: (forall a. Lens' (LegsAtLocation a) [a]) -> (TrainLegs, FormationLegs) -> FormationLeg -> ((TrainLegs, FormationLegs), Maybe TrainLeg)
07:18:30 <JonnyRaa> I think I already tried that.... I'll just have a go
07:19:22 <cocreature> note the parenthesis
07:22:06 <JonnyRaa> excellent, that seems to have got it!  Thanks :)  I thought I'd already tried that aswell!  maybe I didn't have the right extension enabled at the time
07:24:07 <JonnyRaa> ok, clearly not - I just took out all the other ones I'd put in!  Thanks for your help
07:25:09 <cocreature> yw :)
07:37:12 * hackage hasktags 0.70.1 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.70.1 (jhenahan)
07:53:39 <Average-user1> I'm trying some maze related algorithms and I would like to draw them. What GUI library should I use?
07:54:10 <Haskel_user> Bonjuor
07:54:18 <sm> gloss or diagrams probably
07:58:42 * hackage deriving-compat 0.4.2 - Backports of GHC deriving extensions  http://hackage.haskell.org/package/deriving-compat-0.4.2 (ryanglscott)
08:01:28 <JonnyRaa> Bit of a syntax question:  Is there a nice way to annotate pattern matched (eg tuple) variables with types?  I know you can do the following:  (a, b) = doSomethingThatMakesATupleTo blah :: (String, Int)  but I find it a lot easier to read type signatures when they are on the line above... to the extent that I'm tempted to seperate the pattern match and the calculation so the type is more easily readable
08:07:12 <mariusmarius> Test
08:08:19 <shapr> mariusmarius: 10-4
08:09:15 <lemmih> JonnyRaa: You can do 'a :: T1\n b :: T2'
08:09:18 <dmj`> JonnyRaa: you can give a and b signatures in a where block above
08:09:29 <dmj`> what lemmih said
08:13:03 <JonnyRaa> Nice one!  That's better!  Do they have to be on seperate lines?
08:14:49 <Boomerang> JonnyRaa: They don't if they have the same type: "a, b :: Int", otherwise they do unfortunately. I which something like "(a, b) :: (Int, Char)" was possible though
08:15:42 <Boomerang> *wish
08:15:54 <Welkin> why?
08:15:56 <Welkin> that is awful
08:15:58 <Welkin> just use two lines
08:16:07 <Welkin> it's not like you are saving anything by not using two lines
08:17:40 <Boomerang> Sometimes I want to give the type for the whole tuple (think type aliases). I guess in these cases you could do: "t :: (Int, Char); t@(a, b) = ..."
08:17:52 <mnoonan> D:
08:18:44 <Boomerang> Would something like "(x, y) :: Point" really be aweful?
08:19:16 <JonnyRaa> Boomerang:  yeah that seems the most intuitive way of writing it to me aswell.  seperate lines is still loads better than end of the line though
08:26:56 <aarvar> Boomerang: the types can be inferred anyway though, so does it really matter?
08:28:01 <aoijrwg> Hi! I'm learning how to implement programming languages. I've implemented Lisp, lambda calculus and had some fun with variations on those. I'm looking to learn how to implement a language with the features of ML, such as it's type system which I understand is similar but simpler than in Haskell. Is there some book, whitepaper, tutorial or otherwise that instructs in how to create a compiler for ML, or a similar language?
08:28:57 <Welkin> implement algorithm W for the Hindley-Milner type system
08:29:06 <lemmih> aoijrwg: I like http://dev.stephendiehl.com/fun/
08:30:06 <Boomerang> aarvar: Well we're talking about a stylistic choice for how to write the type signature, I agree if you don't need the type signature and it doesn't add much to document the code then you might as well not have it. :-)
08:30:46 <Boomerang> But type inference is not always that good when you start using DataKinds or the mode dependently typed stuff :)
08:33:12 <aarvar> Boomerang: well, you can always annotate the whole expression and let it infer the type for each individual thing
08:33:27 <aarvar> (x, y) = blah :: Foo
08:34:05 <aarvar> Boomerang: and you mean gadts
08:35:28 <bbear> can you tell me exercises to work with foldr foldl foldMap ?
08:35:35 <bbear> I tried this morning but really get stuck
08:35:47 <bbear> (+) with integer is a monoid iirc
08:35:57 <bbear> so mappend can be (+)
08:36:35 <bbear> but I don't get how you can do it with `list`, the `:` is not commutative, well I am not sure [] is a monoid instance.
08:36:43 <bbear> as far I can tell I am not sure.
08:36:57 <bbear> The only thing I know is that I know nothing.
08:37:15 <mnoonan> lists with mempty = [] and mappend = (++) give a monoid
08:37:24 <bbear> ha yes so mappend is (++)
08:37:40 <mnoonan> also, mappend doesn't need to be commutative
08:37:43 <bbear> but that's not really algorithmically efficient since (++) is a O(n) operation
08:37:48 <mnoonan> but you at least need the same type on both sides :)
08:38:18 <bbear> don't you have efficient data structure with the same properties as the monoid and O(1) mappend ?
08:38:33 <bbear> maybe foldr instead of foldl would do it
08:38:41 <Taneb> bbear: not in the standard library although such data structures do exist
08:38:43 <bbear> I mean you can still get the complexity you want.
08:39:20 <aarvar> left associated (++) is inefficient
08:39:50 <aarvar> [a] ++ ([b] ++ ([c] ++ xs)) is the same as a:b:c:xs
08:40:55 <aarvar> bbear: so as long as foldMap uses a right fold it's fine
08:41:19 <bbear> ok
08:44:16 <jesyspa> bbear: I think there's a trick where instead of using (++) directly, you basically compose functions that perform the concat once you've given an argument.
08:44:38 <jesyspa> So instead of working with [a] as a Monoid, you work with a subset of [a] -> [a] as a monoid under composition.
08:48:12 <aarvar> also known as a DList
09:14:38 <isovector> heya -- i'm trying to get GHC.Generics-generated instances to inline across a package boundary, but my INLINE pragmas seem to have no effect
09:14:42 * hackage tomland 0.0.0 - TOML parser  http://hackage.haskell.org/package/tomland-0.0.0 (shersh)
09:14:43 <isovector> any suggestions for what i might try?
09:15:37 <glguy> isovector: Can you show the code where the inline pragmas are?
09:17:19 <isovector> glguy: https://github.com/isovector/ecstasy/blob/master/src/Data/Ecstasy/Internal/Deriving.hs#L48-L71
09:17:36 <isovector> in particular the one on line 70 is killing my perf
09:18:19 <glguy> isovector: and then where are you using gGetEntity that it's not inlining?
09:19:23 <glguy> isovector: This kind of code is why lens package provides the insanely named "fusing" and "confusing"
09:19:48 <isovector> glguy: this is the only usage of it: https://github.com/isovector/ecstasy/blob/master/src/Data/Ecstasy/Internal.hs#L42-L59
09:20:23 <isovector> even specializing `getEntity` directly to my type doesn't help :/
09:21:03 <glguy> isovector: generics can't optimize away when that optimization relies on GHC applying Monad laws to do it
09:21:32 <isovector> ahh interesting. this confusing thing looks promising
09:22:14 <glguy> isovector: This package explains more of the concept: https://github.com/glguy/generic-traverse/blob/master/src/Boggle.hs
09:22:29 <glguy> and is more complete than what "confusing" can do at the cost of being a lot more code
09:22:56 <isovector> fantastic. thanks!
09:29:32 <isovector> glguy: is this boggle stuff on hackage anywhere?
09:31:27 <glguy> isovector: No. It is written the way it is to explain how it works. To make this into a production package would probably benefit from collapsing the layers together. fusing and confusing are usually enough
09:32:31 <Taneb> glguy: minor grammar error on line 85, should be "its" not "it's"
09:35:43 <isovector> glguy: gotcha. it's not clear to me that my use is a `LensLike` but maybe the type synonyms are just hurting my brain. is it sufficient to just lift my entire `f` into `Yoneda f`?
09:36:34 <glguy> isovector: Oh, yours isn't a LensLike, but it's the same idea. Yoneda f would only be enough to help with the Functor case, not Applicative
09:36:55 <isovector> Codensity?
09:37:37 <glguy> You should be able to use the type "confusing" uses
09:37:53 <lin_> Good Evening. Are any archlinux users here? It seems that haskell packages are a mess under archlinux. Is there a good solution?
09:38:21 <isovector> glguy: i'll give it a go. thanks! been looking for a reason to use the kan-extensions package for a while :D
09:38:31 <isovector> lin_: are you doing hs development?
09:39:26 <cocreature> lin_: the solution is to avoid installing any haskell related packages via pacman except for ghc, ghc-libs and ghc-static
09:39:50 <maerwald> just install ghc locally in a prefix in $HOME
09:39:56 <maerwald> no reason to even use the pm
09:40:20 <maerwald> the pre-built ghc tarballs allow installing into arbitrary prefixes
09:40:21 <lin_> I am planning on starting. atm I am just tweaking xmobar and xmonad but I am joing some nlp projects in haskell. so doing everything inside of cabal or stack is possible.
09:40:34 <geekosaur> lin_, remember that any packaged language environment is there to support the package system, not you as developer. which comes up with pretty much every language used for development
09:40:38 <lin_> do gch and ghc-static not contradict?
09:41:01 <glguy> ArchLinux's Haskell packages are a mess because they appear to only be intended for use for building ArchLinux distributed executables, not for arbitrary development.
09:41:16 <geekosaur> no, ghc-static depends on ghc, it's the static library components that the ghc package normally omits
09:41:31 <cocreature> glguy: funnily enough the changes managed to also piss off the people that just want to use some Haskell executables :)
09:42:05 <glguy> I guess they took "you can't please all the people all the time" to mean that you shouldn't please any of them, then !
09:42:12 * hackage recaptcha 0.1.0.4 - Functions for using the reCAPTCHA service in web applications.  http://hackage.haskell.org/package/recaptcha-0.1.0.4 (JohnMacFarlane)
09:42:15 <jesyspa> lin_: I've found stack to be a good solution.
09:42:29 <geekosaur> they're in kind of an impossible situation, really
09:42:50 <geekosaur> and compromise leads to trying to serve too many masters
09:44:49 <lin_> so the most sensical thing would be to install ghc, ghc-libs and ghc-static, the install stack and cabal _not_ from pacman and install everything else via cabal or stack and do development within cabal sandboxes/stack sandboxes?
09:45:07 <geekosaur> correct answer is probably to focus on their own purpose, and explicitly say so. "this package is to support our packages, if you intend to do development then follow the recommendations of the development community" (which almost invariably will tell you to install your own private setup instead of the package manager)
09:45:37 <geekosaur> perl, python, ruby, etc. have been doing this for years
09:45:57 <cocreature> lin_: yep, if you go down the stack route than you don’t even need to install the ghc packages since stack will fetch its own copy of ghc
09:46:12 * hackage filestore 0.6.3.3 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.3.3 (JohnMacFarlane)
09:46:14 <cocreature> lin_: if you go down the cabal route you might want to checkout cabal new-build instead of cabal sandboxes
09:46:41 <lin_> the project I'm joining is using cabal/cabal sandboxes.
09:47:20 <lin_> but for xmonad and other little things stack sounded more sensible. Will I run into problems if I try both?
09:47:28 <cocreature> no they don’t interact
09:48:01 <cocreature> I even use both on the same project
09:48:24 <maerwald> we clearly need more tools
09:49:11 <isovector> glguy: so after making the changes to run everything in `Curried (Yoneda f) (Yoneda f)`, i seem to have just pushed all of the time+allocations into Yoneda.fmap :D
09:49:14 <lin_> so if i use stack (not from pacman) will it install ghc and cabal?
09:50:53 <glguy> isovector: Once you start down this road you have to start looking at GHC core to see where things are getting left behind
09:51:14 <glguy> for types of any interesting size the optimizer starts giving up early and you have to urge it along with extra flags and nonsense
09:52:09 <isovector> i'm cool looking at the core. unsure if i should be looking in the package that defines the generics or in the actual application code
09:52:20 <infandum`> Does fgl BFS work with undirected graphs?
09:52:45 <glguy> isovector: You have to look at the core where you'd assumed that the generics would be optimized away
09:55:00 <isovector> sounds good. thanks!
10:05:31 <cocreature> lin_: it will install GHC, it won’t install the cabal executable automatically (although you can use stack to install it)
10:08:19 <fresheyeball> hey out there
10:08:23 <lin_> cocreature: would that make sense?
10:08:26 <fresheyeball> is "using" now a language keyword?
10:08:39 <isovector> fresheyeall: i don't think so
10:08:47 <isovector> (also hi!)
10:08:56 <fresheyeball> isovector: hey dude!
10:09:27 <isovector> 1https://www.stackage.org/haddock/lts-11.9/parallel-3.2.1.1/Control-Parallel-Strategies.html#v:using there's this though
10:09:49 <fresheyeball> isovector: yeah, I just dont understand my syntax error I think
10:10:00 <fresheyeball> had a red hearing where it compiled, but should not have
10:10:04 <fresheyeball> herring*
10:12:08 <fishythefish> fresheyeball: do you have a paste?
10:12:09 <cocreature> lin_: sure if you want to use both, installing one using the other makes sense
10:15:21 <fresheyeball> ha!
10:15:39 <fresheyeball> fishythefish: isovector it was MonadComprehsions
10:16:24 <fresheyeball> MonadComprehensions adds `using` as a new keyword
10:16:59 <isovector> fresheyeball: what's your use case for monadcomprehensions????
10:25:05 <lin_> cocreature: isovector geekosaur thank you
10:47:32 <glguy> MonadComprehensions doesn't add using as a keyword, but TransformListComp does
10:48:36 <glguy> though I'm surprised to learn that turning on MonadComprehensions turns on that aspect of TransformListComp
10:49:00 <fishythefish> MonadComprehensions implies both TransformListComp and ParallelListComp, doesn't it?
10:49:16 <glguy> no
11:12:16 <cocreature> what does the "… `cast` <Co:7>" stuff in -ddump-simpl’s output mean?
11:12:32 <cocreature> it doesn’t seem to be coercions since -dsuppress-coercions doesn’t get rid of it
11:12:50 <noan> maybe a stupid question, but do IO actions by default happen in an asynchronous model via an internal "hidden" thread pool or execution context... or are they synchronous unless explicitly forked?
11:14:27 <jp_rider> Anyone know the flag to disable this warning?
11:14:28 <jp_rider> -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS
11:15:50 <cocreature> jp_rider: follow the suggestion? :)
11:16:04 <geekosaur> only viable if you dont need to sup[port older ghcs
11:17:13 <cocreature> yeah although that was added in 7.10 iirc so you can still go back quite some time
11:17:40 <geekosaur> -Wno-deprecated-flags I think
11:18:18 <geekosaur> noan, that's a bit complicated, but in general each thread serializes/sequences its own IO operations
11:18:20 * hackage ghc-syntax-highlighter 0.0.2.0 - Syntax highlighter for Haskell using lexer of GHC itself  http://hackage.haskell.org/package/ghc-syntax-highlighter-0.0.2.0 (mrkkrp)
11:18:53 <jp_rider> thanks geekosaur!
11:19:08 <noan> geekosaur, basically though.. if I just write only plain IO without any additional threading specific code... I'm running single threaded
11:19:09 <noan> right?
11:19:14 <geekosaur> some of the complications come from the fact that individual low level I/O operations may not correspond to higher level things, so for example putStrLn is serialized as a sequence of hPutChar which may interleave with those done by another thread
11:19:34 <geekosaur> pretty much, yes
11:19:42 <noan> cool that's all I needed
11:19:51 <sm> might there be any newer/more complete paypal API client than https://github.com/meoblast001/paypal-rest-client ?
11:20:00 <noan> Scala IO types are typically automatically handled via an "Execution Context" that manages threading
11:20:13 <noan> so you basically aint gotta do shit in scala, wanted to check if it was the same or not
11:22:57 <noan> where would be the right place to look if I wanted something like a wait to have several processes run of different threads such that the eventually yield a result, which I can "collect back"
11:23:19 <noan> ie If I wanted to batch many operations off in parallel but collect the results at the end before moving to the next stage in the main thread?
11:23:48 <davean> noan: async?
11:24:02 <geekosaur> ghc itself provides only primitives that you can use to build that. the async package provides some of those higher level things\
11:24:11 <geekosaur> there's also machines, which provides even higher level abstractions
11:24:20 <noan> davean, thank you
11:24:28 <davean> http://hackage.haskell.org/package/async for clarity
11:24:36 <noan> yeah I found it
11:24:42 <MarcelineVQ> also  parallel  depending on what you're doing
11:24:44 <noan> appreciate the nod in the right direction
11:24:48 <davean> I like machines but I don't think thats what he meant here
11:25:18 <davean> It might be the answe rhe needs, he hasn't really explains what he's trying to do, only how he's trying ot do it
11:25:33 <davean> Same with parallel
11:26:08 <davean> Hell, he might actually want a worker pool even.
11:27:41 <noan> Oh, I'm just trying to understand the typical everyday stuff one needs when programming
11:27:52 <noan> I don't have a specific need right now actually
11:28:00 <MarcelineVQ> async is pretty typical
11:28:46 <MarcelineVQ> but note also the modules under Control.Concurrent in base
11:29:44 <noan> yeah, I was reading that when I asked
11:29:58 <noan> and was perplexed by the inability to create yielding tasks
11:30:00 <davean> well, I'd like to point out http://hackage.haskell.org/package/async-pool
11:30:20 <davean> because if oyu start throwing around a LOT of background tasks, you should take care with resource management
11:30:44 <davean> noan: yielding tasks?
11:30:53 <noan> ah, async doesn't manage pooling?
11:31:01 <noan> davean, tasks which yield a result.
11:31:12 <noan> Promise in JS, Future/IO/Task in Scala, etc.
11:31:26 <davean> noan: no its lower level than that
11:31:51 <geekosaur> there are multiple modules implementing different kinds of pooling
11:32:04 <geekosaur> packages, not modules
11:32:19 <davean> Control.Concurent specifies how stuff happens, it doesn't specify what you want to do with the tools
11:32:30 <davean> Async is an implimentation of one thing you might want to accomplish
11:33:15 <cocreature> a let in core that binds an unlifted type (e.g. Int#) does not correspond to a heap allocation, right?
11:33:44 <mniip> depends
11:33:57 <mniip> it could grow the stack
11:35:56 <cocreature> right but it’s not a heap allocation in the sense that a let that binds a lifted type, e.g., Int is
11:39:20 <noan> thanks for the great info guys
11:39:32 <noan> async.pool will be where I start then when I get to that part
11:40:25 <davean> noan: you might also want to look at concurrent-machines
11:41:30 <davean> noan: it might define away a lot of what you'd want to program
11:45:53 <dtornabene> hey all, is there a package or setting to get a working install of a Haskell 98 compliant compiler _without_ having to setup a virtual environment of some kind (a la docker or whatever)?
11:46:42 <davean> dtornabene: hum?
11:46:43 <dtornabene> I've got an older text that uses that (and some software from the period) and I'd like to be able to run through it without having to setup a new image
11:47:16 <davean> I mean, you could install an old compiler directly.
11:48:00 <dtornabene> yeah, I'm hoping to be able to do that
11:48:41 <dtornabene> and I'm a moron, because I've already got Hugs on this laptop
11:48:47 <dtornabene> sorry for the bother....
11:48:53 <davean> In general though you can even use a modern one mostly. Just use the haskell98 package.
11:49:01 <dtornabene> Ah!
11:49:10 <dtornabene> that was the information I was looking for
11:49:23 <dtornabene> a specific package that would make it easier
11:49:33 <davean> don't use base, use haskell98
11:50:02 <davean> but its a bit out of date, you can't use an entirely modern compiler
11:50:16 <davean> (AMP broke that)
11:50:45 <dtornabene> so this package ? https://hackage.haskell.org/package/haskell98
11:51:24 <davean> Yes, it won't work past GHC 7.8 though I think is where the break is
11:51:59 <dtornabene> and I should be able to get GHC to 7.8 via stack, no?
11:52:12 <davean> (Fixing Monad isn't possible to patch around and share any compatability with other Haskell packages)
11:52:54 <davean> no idea about stack, I avoid it. It definately still runs on a bunch of modern stuff though without issue and a number of libraries support back to it for some reason
11:53:08 <davean> Its still in the "stuff kinda works with it" window
11:53:41 <dtornabene> cool, definitely need to jump on it and finish this book while I can easily build the software for it
11:53:51 <dtornabene> thanks for the help davean
11:54:03 <davean> What book?
11:54:39 <davean> (Also, the changes to make it Haskell2010 or even post-AMP are generally minor)
11:54:59 <davean> (though maybe not the easiest ot have extra issues while learning, in this case I don't think it should be a deal killer)
11:55:18 <dtornabene> http://www.dcs.gla.ac.uk/~jtod/discrete-mathematics/ though its the second edition
11:55:25 <dtornabene> came out in 2006
11:55:38 <dtornabene> https://www.amazon.com/Discrete-Mathematics-Using-Computer-ODonnell/dp/1846282411
11:55:42 * hackage numbers 3000.2.0.2 - Various number types  http://hackage.haskell.org/package/numbers-3000.2.0.2 (JohnWiegley)
11:56:29 <davean> oh wow! I never heard of that
11:56:31 <davean> neat
11:58:28 <dtornabene> i'll write up something when I'm finished, at the very least to get a page with directions for others to set up a working system
11:58:52 <sm> stack --resolver lts-2 ... will get ghc 7.8.4
11:59:21 <dtornabene> sm: thanks!
12:13:09 <Ariakenom> > [5|False]
12:13:12 <lambdabot>  []
12:20:08 <jle`> > [5|5||False]
12:20:10 <lambdabot>  error:
12:20:10 <lambdabot>      • Could not deduce (Num Bool) arising from the literal ‘5’
12:20:10 <lambdabot>        from the context: Num a
12:20:40 <jle`> > [5|5||False]
12:20:42 <lambdabot>  []
12:22:08 <cocreature> do GC copies not count as allocations in the +RTS -s output?
12:22:23 <cocreature> the number of bytes allocated is lower than the number of bytes copied during GC
12:26:58 <trcc> Hi everyone. I have an issue with aeson. I keep running into Data.Text.Internal.Text, and I cannot figure out how to avoid this. I would like to work on strings instead. Any ideas? Here is my particular case: https://pastebin.com/5er3Lz1r (I am using pastebin instead of lpaste because lpaste gives an sql disk space error)
12:27:44 <sm> aaah my eyes
12:28:51 <infinisil> trcc: May I recommend https://gist.github.com/ instead then, everything is better than pastebin
12:29:07 <monochrom> Oh, so lpaste is just having a full disk.
12:29:18 <sm> http://hastebin.com is great too
12:29:33 <monochrom> Data.Text.Internal.Text = Data.Text.Text
12:30:08 <infinisil> trcc: You should learn how do notation works, you need `result <- updateFmuPaths fmus` and `print result` instead
12:30:25 <monochrom> You should keep it Text most of the time.  There are fewer and fewer legit reasons to convert to String.  But when you really need it, Data.Text has "unpack".
12:30:42 <int-e> sm: too much javascript
12:30:46 <infinisil> And there he goes
12:31:03 <monochrom> hastebin crashes their computer :)
12:32:05 <sm> int-e: ah.. works for me, sometimes less distraction is good
12:32:21 <trcc> ah okay
12:32:32 <trcc> monochrom: why should I do that?
12:32:58 <monochrom> My complaint about hastebin is that its low brightness colouring seems to assume that you're coding in your mom's basement with all lights off.
12:33:37 <monochrom> String = [Char] is an extremely inefficient way to store strings.
12:34:24 <sm> and: updateFmuPaths fmus  returns an IO action, you have to run that action to get something you can print
12:34:49 <EvanR> yes List is bad for storage of anything
12:34:49 <davean> trcc: because String is terrible.
12:34:54 <trcc> okay thanks
12:34:58 <monochrom> [Char] was a cute idea 30 years ago when people were still thinking more or less theoretically.
12:35:00 <davean> trcc: String is a chained list
12:35:04 <EvanR> its good for representing "loops" though
12:35:12 * sm refrains from defending String in any way
12:35:14 <davean> trcc: its slow, its bloated, theres nothing good about it
12:35:24 <trcc> Okay. Thanks. Good to know :)
12:35:28 <geekosaur> oddly, that's one thing I like about hastebin. (not in mom's basement, but prone to visual hypersensitivity. which means, yes, lights as low as I can get them)
12:35:28 <infinisil> davean: That's not true
12:35:31 <EvanR> the real problem with String is that it exists at the same time as Text
12:35:32 <infinisil> Linked lists have their uses
12:35:40 <EvanR> so you have 2x api entropy
12:35:50 <davean> infinisil: Whats wrong about it?
12:36:07 <infinisil> wrong about what?
12:36:07 <EvanR> but wait there are like 5 other string types to choose from!
12:36:12 <davean> infinisil: I didn't say linked lists didn't have their uses, I said String was one and it was bad
12:36:18 <infinisil> Ah yeah
12:36:19 <davean> infinisil: you siad what I said wasn't true
12:36:25 <davean> I wnat to know what wasn't true
12:36:27 <Ke> geekosaur: with modern display brightnesses you don't really have to be that sensitive to have them at minimum most of the time
12:36:37 <geekosaur> trust me, I;ve noticed
12:36:46 <infinisil> davean: Yeah no i misunderstood, linked lists are bad for strings
12:36:59 <infinisil> Disregard
12:37:02 <geekosaur> pisses me off that every new monitor has its lowest brightness cranked higher than its predecessors
12:37:08 <geekosaur> stabbing headaches are no fun
12:37:11 <monochrom> OK if hastebin provides a button to turn it brighter, as a non-default, I'm happy too.
12:37:11 <davean> infinisil: linked lists are amazing :)
12:37:23 <davean> geekosaur: I don't get why monitors are doing that lately
12:37:27 <geekosaur> there is a theming button somewhere. also try userstyles.org
12:37:31 <trcc> Couldn't match type ‘Hm.HashMap Text’ with ‘IO’
12:37:31 <trcc>       Expected type: IO (IO Value)
12:37:31 <trcc>         Actual type: Hm.HashMap Text (IO Value)
12:37:35 <trcc> Ah sorry
12:37:46 <trcc> infinisil: I still get the error that I just pasted on 3 lines
12:37:47 <davean> geekosaur: this new laptop, on its minimum setting, when showing a white background lights up my entire room more then I want it light
12:37:53 <geekosaur> davean, because the drive is for displays that are usable in direct sunlight, and LEDs don't have a lot of dynamic range
12:37:55 <sm> String has simplicity, low cognitive load, and is always available, which can be nice when learning or code golfing or solving puzzles fast
12:38:06 <geekosaur> so make them bright enough for daylight and the minimum's at least full moon or worse
12:38:08 <davean> geekosaur: Sure, which is why you use thousands of LEDs :)
12:38:16 <infinisil> trcc: Well what's the code now?
12:38:26 <trcc> I just made the change you described
12:38:30 <davean> geekosaur: turns out we can dither ;)
12:39:00 <trcc> I am just interested in printing within updateFmuPaths, such that I can see what I am doing
12:39:12 <geekosaur> it's worse than that, really. if you put an individual LED behind each pixel you might be able to do that. and draw as much power as the CPU
12:39:52 <infinisil> trcc: Wait, are you sure you want a `HashMap Text (IO Value)`?
12:39:57 <geekosaur> monitors require "interesting" design tradeoffs in a bunch fo places
12:40:26 <trcc> infinisil: no. I am not sure. What I basically want is to return the same type as passed in, but with an altered value field
12:41:25 <trcc> The scenario is this: Read the json file, convert the value field of {crtl} and {wt} to some other text and return it, store the json file and finished
12:42:15 <monochrom> I'm pretty sure IO (HashMap Text Value) suffices.
12:42:17 <infinisil> trcc: If you just want to modify it, then you want `HashMap Text Value`, and `IO (HashMap Text Value)` if you want to print something in that method
12:42:21 <monochrom> Even IO Object
12:42:28 <infinisil> Or yeah IO Object
12:42:57 <sm> I think hastebin has no options.. but you can get black on white view by pressing C-S-r
12:43:25 <monochrom> readMyFile :: IO (HashMap Text Value).   writeMyFile :: HashMap Text Value -> IO ()
12:43:33 <trcc> Then I get this: Couldn't match expected type ‘IO Object’  with actual type ‘Hm.HashMap Text (IO Value)’
12:43:43 <monochrom> See also my IO tutorial http://www.vex.net/~trebla/haskell/IO.xhtml
12:44:25 <monochrom> Here is a very dumb analogy. If you write a program that reads a list of int's from a file, it's IO [Int] not [IO Int]. Clearly.
12:45:56 <infinisil> trcc: Whats your current code?
12:48:10 <zfnmxt> Is it possible to have an unnamed field in a record? data MyType = MyType {field1 :: Int; _ :: Int} something like that.
12:48:29 <monochrom> Oh I guess Object is a data constructor, the type I want is Value.
12:48:56 <monochrom> Err no, Object is also a type name.  Gosh this is confusion.  Why do people do that?!
12:49:14 <monochrom> data Ta = Ta Ta
12:50:06 <monochrom> zfnmxt: I think no.
12:50:13 <zfnmxt> Bummer.
12:50:39 <zfnmxt> Also, I'd like to add a position to the various components of my AST for my compiler: https://github.com/zfnmxt/TigerHaskell/blob/master/compiler/src/AST.hs
12:51:02 <zfnmxt> Is the best way to do that just to manually add a "Pos" field (where Pos = Int or something) to each type?
12:51:14 <zfnmxt> Just a huge pain in the ass...I have like 40 unit tests I'd have to change :(
12:51:49 <monochrom> Oh interesting, { foo :: ! X -> Y } is not allowed.
12:51:50 <zfnmxt> Since changing the AST types changes the result of my tests, etc. So if anyone has other ideas, I'm all ears :)
12:52:17 <trcc> infinisil: code here: https://hastebin.com/wozawasofi.hs (I had to spray poison into a bee hive..)
12:53:17 <cocreature> monochrom: do you mean foo :: !(X -> Y)?
12:54:03 <infinisil> trcc: And you get the error where exactly?
12:54:08 <infinisil> Full error would be nice
12:54:21 <monochrom> Oh! The grammar wants me to do that.
12:54:27 <infinisil> I can't see anything obviously wrong with your code trcc
12:54:37 <trcc> https://hastebin.com/jehocomici.hs
12:54:40 <trcc> error at top
12:55:03 <monochrom> I was reading part of the grammar but not fully enough to notice that venue.
12:55:21 <trcc> With imports: https://hastebin.com/keyohejobo.hs
12:55:33 <infinisil> trcc: Oh, well you didn't post your createFullPath function, its type signature doesn't match
12:55:46 <cocreature> hm is there a pinned Array#?
12:55:55 <infinisil> Oh wait
12:55:58 <infinisil> It's below
12:56:31 <infinisil> :t HashMap.mapM
12:56:32 <lambdabot> error:
12:56:32 <lambdabot>     Not in scope: ‘HashMap.mapM’
12:56:32 <lambdabot>     No module named ‘HashMap’ is imported.
12:56:58 <fishythefish> zfnmxt: change `data Expr = ...` to `data Expr' = ...` and add `type Expr = (Pos, Expr')`?
12:57:03 <fishythefish> i'm not sure what your precise constraints are
12:57:04 <int-e> cocreature: what would be the use of that?
12:57:04 <infinisil> Oh hashmap doesn't have a mapM :/
12:57:27 <trcc> any ideas?
12:57:47 <cocreature> int-e: avoiding copies for large arrays
12:58:03 <zfnmxt> fishythefish: Sorta works in a coarse way. Maybe I'll try that as a lazy intermediate. :)
12:58:08 <monochrom> trcc: I am wonder why it doesn't suffice to just "print fmus".
12:58:42 <zfnmxt> Still ruins all my testing though >.<
12:58:42 <trcc> monochrom: what I am really interested in is printing within the updatefmupaths
12:58:47 <cocreature> int-e: probably it doesn’t make sense but I don’t understand why it doesn’t make sense :)
12:58:51 <zfnmxt> Does a compiler really need positional error reporting :D
12:59:15 <monochrom> I'm pretty sure you need to reveal what other things you want updatefmuspaths to do.
12:59:30 <trcc> I have, further up. I'll find it agian
12:59:34 <monochrom> Because where to go from here really depends.
13:00:08 <monochrom> At any rate the current code won't even print anything.
13:00:24 <trcc> The scenario is this: Read the json file, convert the value field of {crtl} and {wt} to some other text and return it, store the json file and finished. updatefmupaths should perform this change, and I an interested in priting both the key an value within updatefmupaths
13:00:34 <infinisil> monochrom: He just wants to map over a hashmap and execute some IO action along that
13:00:48 <infinisil> But HashMaps don't have mapM
13:00:51 <infinisil> So that's unfortunate
13:01:14 <trcc> updatefmupaths should change the value field, and return the new key-value pairs
13:01:28 <monochrom> I guess it's because order is important for mapM but HashMap doesn't offer a predictable order.
13:01:31 <int-e> cocreature: I think it makes sense in principle... but at a glance ghc's RTS doesn't support pinned objects that may contain pointers to the heap, only bytearrays. https://github.com/ghc/ghc/blob/master/rts/sm/Storage.c#L964-L986
13:02:36 <trcc> monochrom: order is not important
13:02:59 <trcc> I do not care which pair comes first
13:04:18 <int-e> cocreature: (but I may be missing something)
13:05:00 <infinisil> trcc: The only thing I can think of is converting the hashmap to a list first, map over it with mapM, then convert the result back to a hashmap
13:05:11 <infinisil> :t mapM
13:05:12 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
13:05:35 <trcc> infinisil: does it matter much if I skip the printing part and just update the value?
13:05:43 <trcc> would that make the whole thing easier?
13:06:00 <infinisil> If you can update the value outside of IO then it's easy
13:06:16 <trcc> okay. I will try that first then.
13:06:23 <trcc> Thank you for your effort
13:06:52 <trcc> how come hashmap does not have mapM?
13:09:42 * hackage GHood 0.0.7 - A graphical viewer for Hood  http://hackage.haskell.org/package/GHood-0.0.7 (HugoPacheco)
13:10:05 <tdammers> :t mapM
13:10:07 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
13:10:18 <cocreature> int-e: thanks! I’m glad I’m at least not missing something completely obvious :)
13:12:08 <zfnmxt> Does hspec/hunit support any sort of wildcards for `shouldBe`?
13:15:12 * hackage th-lift 0.7.10 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.7.10 (MathieuBoespflug)
13:17:41 <isovector> edwardk: is there a reason why Yoneda.fmap isn't marked as INLINE?
13:18:06 <Boomerang> zfnmxt: You could try with `shouldSatisfy` then you have more control for wilcards
13:18:09 <isovector> after yonedafying my expensive ghc.generics i'm now just spending all of those expenses inside of Yoneda.fmap :/
13:19:01 <fatahland> hello can you give a hint how to proceed? https://pastebin.com/4AjHgLE4
13:21:20 <infinisil> fatahland: Recursion
13:21:22 <isovector> fatahland: try adding a case for `insert l (Node left msg right)`
13:22:30 <isovector> then think about how you can maintain your timestamp ordering invariant
13:25:06 <fatahland> if i understand well. the LogMessage TimeStamp always need to be bigger than left and smaller than right so it will always be sorted if i always insert it in those terms isnt it?
13:26:08 <fatahland> i just need to place it in the right place and not worry avout the other Node's in the future because they also be insert in the right place.
13:26:37 <fatahland> (the LogMessage of course will be inserted in the right place)
13:28:14 <isovector> fatahland: you might want to work through an example on paper
13:28:24 <isovector> starting from an empty tree, how do you insert a few messages into it
13:28:40 <fatahland> my base cases are good?
13:30:10 <fatahland> i take your advice to do this on paper. maybe there i'll found something :-)
13:30:20 <fatahland> thanks!
13:30:28 <isovector> good luck
13:30:33 <fatahland> :-)
13:36:42 * hackage aws 0.20 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.20 (AristidBreitkreuz)
13:36:44 * hackage sdl2-fps 0.0.0 - Run of the mill, frames per second timer implementation  http://hackage.haskell.org/package/sdl2-fps-0.0.0 (jxv)
13:40:27 <shapr> Why is there both aws and amazonka?
13:47:45 <phadej> why thereis hspec, tasty and test-framework? :)
13:48:50 <sm> why is there chocolate, vanilla, and salted-caramel ?
13:49:16 * sm gets hungry
13:49:58 <sm> via https://www.snoyman.com/blog/2018/05/guide-to-matrix-riot I finally get this "matrix" business.. pretty slick
13:49:59 <geekosaur> because each has a different focus, and not all test scenarios are created equal
13:50:55 <sm> it seems the #haskell:matrix.org room is a superset this channel plus about 600 non-IRC users ?
13:51:02 <sm> superset of
13:51:27 <sm> 300
14:00:24 <davean> pacak: well theres tasty becayse there was test-framework, and I don't know why theres hspec ... people haven't realized they want more yet? ;)
14:09:42 * hackage self-extract 0.1.0.0 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.1.0.0 (brandonchinn178)
14:18:29 <lambdafan> I'm trying to write a function "Event t Foo -> Event t Bar -> Event t (Foo,Bar)". Event is defined in the Reflex library. It's not applicative so I cannot do "(,) <$> foo <*> bar"
14:20:06 <mpickering> How does persistant deal with fields which are lists? For example "answers [Answer]", I suppose that is quite different to "answers [AnswerID]"
14:20:13 <davean> lambdafan: merge
14:22:04 <davean> lambdafan: one could also use push with hold, but that would be different!
14:22:48 <davean> I do wonder why you're zipping on events though. Its an odd decision
14:23:59 <lambdafan> davean, I have a widgetHold that will be using a pair of events
14:24:12 * hackage affine 0.1.0.0 - Affine spaces (generalized)  http://hackage.haskell.org/package/affine-0.1.0.0 (MatthewFarkasDyck)
14:24:38 <davean> lambdafan: yah, but why do you think they'll occure together?
14:24:40 <lambdafan> davean, also merge does not construct a pair, nor does it have two Events as parameters
14:25:08 <davean> lambdafan: merge has any number of events as a parameter, and it performs a function on them
14:25:32 <davean> So yes, it does, when parameterized correctly
14:25:54 <davean> You may want EitherTag for a pair
14:26:41 <davean> lambdafan: I do think you've mistaken something though, the reasons this isn't obvious to you is because its basicly not how Events work
14:27:46 <lambdafan> davean, ah I see. You're right!
14:28:07 <lambdafan> I had to think about what you said. What I am trying to accomplish is cleaerer now.
14:28:27 <davean> lambdafan: :)
14:28:42 * hackage sdl2-fps 0.0.1 - Run of the mill, frames per second timer implementation  http://hackage.haskell.org/package/sdl2-fps-0.0.1 (jxv)
14:31:18 <camsbury> is there a function for hspec that basically just says this failed with some string as to why?
14:31:44 <davean> lambdafan: one CAN easily use Applicative (you're welcome)
14:31:55 <davean> (on Dynamic)
14:34:52 <EvanR> huh
14:35:20 <EvanR> > (toDyn id) <*> (toDyn 3)
14:35:22 <lambdabot>  error:
14:35:22 <lambdabot>      • Couldn't match expected type ‘f (a1 -> b)’
14:35:22 <lambdabot>                    with actual type ‘Dynamic’
14:36:18 <davean> EvanR: Wrong Dynamic?
14:36:34 <davean> Dynamic can't be a functor, it has no parameter
14:36:39 <davean> (http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Dynamic.html)
14:37:15 <EvanR> right
14:37:30 <davean> We're talking about Reflex, which has a different Dynamic
14:37:32 <EvanR> but how do you use Applicative on Dynamic then
14:37:33 <EvanR> oh
14:37:55 <davean> its Dynamic is Dynamic t a
14:39:05 <lin_> i installed stack, than i installed cabal-install with stack install cabal-install, but if I want to install for exapmle xmonad, ghc is required and that is not provided. how do i install ghc using stack? Or how can i let cabal-install use stack ghc instead of ghc?
14:40:18 <davean> lin_: you can tell cabal-install what compiler to use easily enough, "cabal new-install --with-compiler=PATH"
14:40:36 <lin_> davean: thanks
14:41:55 <davean> lambdafan: you know theres a dedicated reflex channel, right? #reflex-frp
14:42:28 <MarcelineVQ> but stack does provide ghc,  stack install xmonad   will fetch ghc if you don't have it and build and install xmonad to ~/.local/bin
14:46:37 <lin_> MarcelineVQ: what if I join a project, that so far has been developed using cabal, should i just use stack instead?
14:46:52 <sclv> there's no reason to do that in particular
14:47:09 <sclv> if the devs prefer a certain approach its better to stick with what they're doing
14:47:12 <sclv> to minimize confusion
14:48:39 <sclv> (xmonad is actually a special case, because you recompile it from within itself to reconfigure it. so you need to configure it specially if you want your auto-reconfiguration stuff to work with stack instead of a system ghc)
14:48:52 <slevin> Is there a clever way of doing `if (isNothing acc) then Map.lookup id s else acc`
14:49:19 <davean> sclv: not ENTIRELY true! it'll build its self with a script
14:49:41 <davean> sclv: my xmonad recompiles its sellf using a cabal new-build based project that modernizes a bunch of dependencies
14:49:47 <davean> particularly due to OneTuple issues
14:50:03 <lemmih> slevin: Looks a bit like 'fromMaybe'.
14:50:14 <sclv> davean: but you have to set it up with a special script depending on how you build it, right?
14:50:22 <sclv> i think that's all i meant
14:50:32 <davean> xmonad looks for a ~/.xmonad/build
14:50:34 <infinisil> :t fromMaybe
14:50:35 <lambdabot> a -> Maybe a -> a
14:50:38 <davean> if that exists, it uses that to rebuild its self
14:51:09 <slevin> lemmih: Yeah, but in this case i dont want to return what in the Just, I want the whole thing
14:51:14 <davean> and the compilation doesn't happen from "within its self"
14:51:36 <slevin> Not obvious to me how that can be done with fromMaybe
14:51:38 <davean> It may not trigger a recompilation at all when you just call your built executable directly
14:51:43 <sclv> davean: ok, sloppy wording. i meant there's a command you run in xmonad that rebuilds itself
14:51:51 <davean> ... sorry, I jist redid all my xmonad config
14:52:03 <lemmih> slevin: mplus then?
14:52:05 <davean> I actualy debated not involving the rebuilding at all
14:52:22 <lemmih> > Nothing `mplus` Just "something"
14:52:24 <lambdabot>  Just "something"
14:52:26 <sclv> the only point i was making was to warn lin_ that if you don't have a system ghc, there's a few extra steps to get the reconfig stuff working
14:52:30 <davean> and just directly executing my personal project version and using it, but I liked the quick reconfiguration
14:52:40 <davean> Yes, thats true
14:52:42 * hackage kanji 3.4.0 - Perform 漢字検定 (Japan Kanji Aptitude Test) level analysis on Japanese Kanji  http://hackage.haskell.org/package/kanji-3.4.0 (fosskers)
14:53:21 <slevin> lemmih: Ooh, thank you
14:59:13 <atchoum> it's crazy how better versions of my code are on the internet
14:59:30 <atchoum> like I am totally unable to write good code
15:01:18 <Adluc> atchoum: like?
15:24:31 <EvanR> introducing the fold-while/until-then loop http://codepad.org/OSdRVj1o
15:24:46 <EvanR> no more juggling mutable variables manually
15:30:12 * hackage SciFlow 0.6.2 - Scientific workflow management system  http://hackage.haskell.org/package/SciFlow-0.6.2 (kaizhang)
15:32:42 * hackage monoid-extras 0.5 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.5 (BrentYorgey)
15:34:42 * hackage htoml-megaparsec 1.2.0.2 - Parser for TOML files  http://hackage.haskell.org/package/htoml-megaparsec-1.2.0.2 (vmchale)
15:35:24 <EvanR> or using side effecting operators
15:40:12 * hackage diagrams-contrib 1.4.3 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.4.3 (BrentYorgey)
16:04:42 * hackage tomlcheck 0.1.0.29 - Command-line tool to check syntax of TOML files  http://hackage.haskell.org/package/tomlcheck-0.1.0.29 (vmchale)
16:47:12 * hackage twilio 0.2.0.1 - Twilio REST API library for Haskell  http://hackage.haskell.org/package/twilio-0.2.0.1 (andrus)
17:18:34 <vtomole> I'm trying to make this: https://github.com/thephoeron/quipper-language, but i'm getting this error:  https://pastebin.com/NjRyDDMi. I'm a Haskell newbie.
17:21:02 <Axman6> vtomole: um, try adding {-# LANGUAGE OverlappingInstances #-} as the first line of the file it's complaining about... but it looks like someone's doing something _very_ strange in that code - that language extension might let it compile but who knows if it'll actually do anything useful
17:21:34 <hpc> in more detail, all class instances need to be non-overlapping
17:21:42 * hackage yarn-lock 0.4.1 - Represent and parse yarn.lock files  http://hackage.haskell.org/package/yarn-lock-0.4.1 (Profpatsch)
17:21:54 <vtomole> "  -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS"
17:21:57 <hpc> only type constructors can determine overlap
17:22:10 <hpc> so a type variable like in "instance Show s" is going to overlap with everything
17:22:33 <hpc> even "instance SomethingSpecific s => Show s" will overlap with everything, the extra constraint doesn't help
17:23:18 <hpc> OverlappingInstances lets you write instances that overlap, as long as there is a clear ordering of specificity, which i suggest you read about in the docs
17:24:18 <hpc> the set of extensions that deals with instance resolution has a lot of nuance
17:25:58 <vtomole> I'm on GHC 8.0.2 so I can't use "{-# LANGUAGE OverlappingInstances #-} " cause it's deprecated.
17:27:17 <hpc> https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#overlapping-overlappable-overlaps-and-incoherent-pragmas
17:28:53 <Axman6> vtomole: where is this code from anyway? it looks to me like it's doing really odd stuff
17:29:15 <vtomole> https://www.mathstat.dal.ca/~selinger/quipper/
17:30:42 <vtomole> It's not being maintained, hence the problems i'm having building it.
17:31:50 <vtomole> "  parse error on input ‘{-# Overlapping’"
17:39:12 * hackage iproute 1.7.5 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.7.5 (KazuYamamoto)
17:40:02 <vtomole> hmm weird, works now hpc: Thanks
17:40:42 * hackage easy-file 0.2.2 - Cross-platform File handling  http://hackage.haskell.org/package/easy-file-0.2.2 (KazuYamamoto)
17:41:24 <iqubic> Anyone know how to get ghci to start-up when using emacs and haskell-mode?
17:42:03 <dmj`> iqubic: by default it will use cabal repl iirc
17:42:34 <iqubic> What's the keybinding to pull it up though?
17:43:21 <iqubic> And does said ghci support doing things like testing functions using IO?
17:45:09 <dmj`> iqubic: M-x customize <enter>, then search for “haskell-process-type"
17:45:49 <dmj`> 0 = auto, 1 = ghci, 2 = cabal-repl, 3 = stack-ghci, 4 = cabal-new-repl
17:46:03 <iqubic> All I want now is a repl that I can start uo which will let me work with IO.
17:47:55 <dmj`> iqubic: any of the above should do that
18:00:49 <EvanR> testing IO?!
18:00:59 <EvanR> madness
18:04:42 * hackage dns 3.0.3 - DNS library in Haskell  http://hackage.haskell.org/package/dns-3.0.3 (KazuYamamoto)
18:10:01 <iqubic> dmj`: I tried whatever the default was with getLine.
18:10:19 <iqubic> I was able to enter one character before emacs froze up.
18:10:38 <iqubic> Like I had to shut it down via the command line it was so stuck.
18:11:12 * hackage animate-preview 0.1.2.3 - Preview tool for sprite animation  http://hackage.haskell.org/package/animate-preview-0.1.2.3 (jxv)
18:12:44 <iqubic> So, do you know what may have caused that?
18:22:57 <dmj`> iqubic: so no error showed up? Did the haskell process interactive mode start? Did you see a buffer for *haskell-process-log* ?
19:13:46 <centril> what's the syntax for  injective associated types?
19:57:43 * hackage shake-ats 1.8.0.5, hs2ats 0.3.0.2 (vmchale): https://qbin.io/shield-launch-hf8s
20:02:32 <jchia> Question about Data.Data, particularly gmapM. Is there a variant of gmapM that takes "forall d. Data d => [d] -> m [d]" instead of "forall d. Data d => d -> m d"? My m is an IO that does some lookup, and instead of doing many single-item lookup I want to do one multi-item lookup.
20:02:47 <jchia> Or something to that effect that lets me do only one lookup.
20:29:40 <jle`> jchia: `(a -> m b) -> ([a] -> m [b])` sounds like `traverse` ?
20:36:02 <iqubic> Is it a travers?
20:36:09 <iqubic> :t traverse
20:36:11 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
20:36:41 <iqubic> jle`: Only if m is an applicative though.
20:37:01 <jchia> jle`: How does traverse help? I would like to use a ([a] -> m [b]) and gmapM requires a (a -> m b). My m is IO.
20:38:27 <iqubic> jchia: traverse can take you ([a] -> m [b]) and give you back a (a -> m b)
20:38:40 <iqubic> s/you/your/
20:40:51 <jchia> iqubic: I only see the other direction. Apply traverse to "(a -> IO b)" to get "[a] -> IO [b]"
20:43:43 <aarvar> jchia: pick a different m
21:01:24 <glguy> jchia: https://gist.github.com/glguy/eaaa22435ceb3c4d73a5a79938c9179c
21:02:48 <glguy> over whatYouCameHereFor (reverse :: [Char] -> [Char]) ('a',True,'b')
21:02:48 <glguy> ('b',True,'a')
21:06:22 <woodson> How can one define a type at to be used at runtime? So, for example I am building a small yaml <-> xml generator and parser
21:07:17 <woodson> for me to know which type that will be generating the xml I will be reading an attribute value in the Value that I get from the yaml
21:07:26 <glguy> You'll have to give more information about what you're trying to do, types are a compile-time concern
21:08:30 <EvanR> decodeXml :: (x :: Xml) -> f x
21:10:05 <woodson> ok, say I got data CustomObject and data ActionOverride. Someone can give me a yaml file that can give me details about the CustomObject or ActionOverride
21:10:21 <woodson> when I receive the file I do not know what the user is giving me
21:10:35 <woodson> so, I can just perform Aeson.decode
21:10:53 <woodson> since I need to tell aeson what type I want it to decode to correct?
21:12:37 <EvanR> if you dont know what type it will return until runtime, youll have to return a sum type with cases for all the possible results, including CustomObject and ActionOverride
21:13:07 <EvanR> then you can choose which one to return at runtime, and whoever consumes the result can detect which one it is
21:14:59 <woodson> EvanR, so I will have to wrap each types that I have within a new constructor to make a sum type?
21:15:31 <woodson> Data MySum = Sum1 CustomObject | Sum2 ActionOverride | ...
21:15:36 <EvanR> right
21:16:14 <EvanR> see how they did it in juicy pixels http://hackage.haskell.org/package/JuicyPixels-3.2.9.5/docs/Codec-Picture.html#t:DynamicImage
21:16:38 <EvanR> you "just load an image" without knowing ahead of time what format it is in, and you get that DynamicImage sum as a result
21:18:29 <jle`> jchia: ah i see what you mean, gmap *takes* such a function, so it's in the negative position
21:18:48 <woodson> EvanR, I was looking at Data.Proxy and I thought that Proxy was what I needed
21:19:09 <woodson> Since, I just need some info about the type
21:19:10 <jle`> Proxy was only used in the past to help the typechecker
21:19:11 <EvanR> proxy is used when you are dealing with type classes
21:19:17 <jle`> it doesn't actually give you info about the type at runtime
21:19:22 <iqubic> jle`: I kinda stated that like 30 minutes ago.
21:19:23 <jle`> proxy is still a compile-time thing
21:20:10 <jle`> woodson: what you are looking for is some sort of sum
21:20:47 <jle`> also since 8.0 or 8.2, Proxy is no longer necessary for providing information about type variables you want
21:21:16 <jle`> it was always just a typechecker trick in any case, and doesn't really have any magical abilities :)
21:21:29 <woodson> ok, guys so question still related to what I am asking. I understand the sum type It just will get tedious wrapping my types in other constructor.
21:21:39 <woodson> Do we lose our types at runtime?
21:21:51 <EvanR> there are no types at runtime
21:22:01 <jle`> you can simulate types-at-runtime using sums
21:22:01 <woodson> I never question myself related to this
21:22:05 <EvanR> there is Typeable
21:22:12 <EvanR> but it doesnt help you here
21:22:31 <EvanR> you are asking for type information at runtime of stuff, but you dont actually have stuff yet
21:22:31 <woodson> ok, no types at runtime.
21:22:34 <glguy> Typeable doesn't give us types at runtime, it gives us some alternate representation and some coercions
21:22:35 <EvanR> you are trying to construct stuff
21:22:47 <jle`> woodson: you can effectively simulate types at runtime using sums, that's what the singletons library does
21:22:56 <jle`> and things like juicypixel's image type
21:23:18 <jle`> woodson: the thing you are thinking of is some sort of anonymous existential
21:23:25 <EvanR> o_O
21:24:03 <EvanR> woodson is trying to take a string, and get something of type that depends on the value of the string
21:24:10 <EvanR> i.e. dependent types
21:24:20 <jle`> yeah, the most straightofrward way to do that is some sort of sum
21:24:23 <jle`> dependent or otherwise
21:24:31 <jle`> but woodson wants to avoid having to work with the sum directly
21:24:43 <jle`> really, the sum isn't too bad.  the sum effectively gives you 'types at runtime'
21:25:00 <jle`> as in, types that depend on runtime results
21:25:03 <EvanR> woodson you can generate the sum with TH or something
21:25:18 <johnw> although, dependent types and "types at runtime" are not quite the same thing
21:25:31 <jle`> woodson: this isn't "no types at runtime", this is literally types at runtime :)
21:25:44 <EvanR> if you had dependent types, you would not technically need the sum
21:25:53 <jle`> as in, results whose types depend on runtime values
21:25:55 <EvanR> but thats getting crazy
21:26:03 <woodson> ok, so can you guys explain something for me. We agreed that we do not have types at runtime. However, we are agreeing that we can simulate types at runtime with Sum types
21:26:08 <woodson> how?
21:26:16 <jle`> see JuicyPixel's solution
21:26:19 <EvanR> the sum gives you "dynamic types"
21:26:29 <EvanR> like javascripts value, its basically a sum
21:26:38 <jle`> by "types at runtime", i mean "types that depend on values received at runtime"
21:26:46 <mniip> data Value = AnInt Int | AString String | ...
21:26:59 <jle`> there is another interpretation of "types at runtime", which is probably what the "no types at runtime" might have meant
21:27:13 <jle`> it's sort of a statement in the other direction, though
21:27:16 <woodson> Should I care to know how that works under the hood?
21:27:17 <EvanR> the tag is carried around at runtime so code can determined what is being contained
21:27:31 <jle`> woodson: Aeson has the same thing
21:27:49 <jle`> data Value = String Text | Object (Map Text Value) | Array [Value]
21:28:08 <jle`> essentially a function of type ByteString -> Value, the result's actual type depends onthe contents of the ByteString
21:28:09 <iqubic> How do types at runtime work in things like Java or c++? Like what is the haskell equivalent of "instanceof"?
21:28:32 <EvanR> > typeOf [1,2,3]
21:28:34 <jle`> iqubic: Typeable is essentially runtime reflection; values all carry around an extra implicit token
21:28:34 <lambdabot>  [Integer]
21:28:47 <iqubic> :t typeOf
21:28:48 <lambdabot> Typeable a => a -> TypeRep
21:28:53 <iqubic> Oh, I see.
21:29:07 <jle`> if you have a Typeable a => ... constraint, it's basically taking an implicit token that identifies the type
21:29:28 <jle`> you can implement something similar in plain Haskell
21:29:48 <jle`> @let class ShowType a where showType :: p a -> String
21:29:50 <lambdabot>  Defined.
21:29:57 <jle`> @ instance ShowType Int where showType _ = "Int"
21:30:04 <jle`> @let instance ShowType Int where showType _ = "Int"
21:30:06 <lambdabot>  Defined.
21:30:22 <jle`> > showType (Proxy :: Proxy Int)
21:30:24 <lambdabot>  "Int"
21:30:28 <EvanR> woodson: you can also use Dynamic instead of making a more targeted, more appropriate sum type of your own
21:30:35 <EvanR> > toDyn 5
21:30:37 <lambdabot>  <<Integer>>
21:30:40 <EvanR> > toDyn 'c'
21:30:42 <lambdabot>  <<Char>>
21:30:56 <iqubic> > typeOf "Hello World!"
21:30:58 <lambdabot>  [Char]
21:30:58 <jle`> woodson: look at how the `aeson` library handles its 'dynamic parsing', and how a bytestring can be interpreted as a string, array, or object
21:31:09 <EvanR> > reverse [toDyn 'c', toDyn 5, toDyn id]
21:31:10 <lambdabot>  error:
21:31:11 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘toDyn’
21:31:11 <lambdabot>      • In the expression: toDyn id
21:31:11 <jle`> iqubic: that's essentially the same thing as ShowType
21:31:35 <EvanR> > reverse [toDyn 'c', toDyn 5, toDyn chr]
21:31:37 <lambdabot>  [<<Int -> Char>>,<<Integer>>,<<Char>>]
21:31:53 <jle`> woodson: when we say 'no types at runtime' in haskell, what we really mean is the other direction --- you can't directly pattern match on types
21:32:21 <jle`> meaning you can't write directly code that can branch on what type variable you use
21:32:27 <jle`> without typeclasses or something like that
21:32:35 <glguy> We mean you can only make sense of the values if you statically know that types at compile time, the runtime representations will make sense if you know the types but won't help if you don't
21:33:02 <woodson> hmm I see
21:33:08 <EvanR> when i say no types at runtime, i think at runtime the computer is moving raw bytes around, no indication of what the source code said exists (except Typeable stuff)
21:33:26 <woodson> EvanR: same here
21:33:39 <glguy> and typeable is its own parallel thing you have to thread around yourself, it's not really related to the types directly
21:34:01 <jle`> woodson: the problem you are solving is more or less similar to the Value type in aeson
21:34:16 <jle`> the only thing about the aeson method is that the set of types you're allowed to return is closed
21:34:32 <jle`> but in your case, that sounds like a reasonable thing as well
21:34:41 <woodson> jle`: Yes, I will try to find the example that you mentioned
21:34:49 <woodson> But I would still like to know
21:35:15 <jle`> woodson: http://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson-Types.html#t:Value
21:35:20 <woodson> the options that we have in Haskell
21:35:27 <woodson> so, to make things a bit clearer
21:35:41 <woodson> If I need to know something at runtime
21:35:47 <woodson> which is related to a type
21:35:53 <woodson> I have Sum types
21:36:01 <woodson> dynamic?
21:36:06 <woodson> such as toDyn?
21:36:11 <woodson> singleton?
21:36:17 <jle`> it's a bit fuzzy since you need to define what you mean by "know"
21:36:18 <woodson> which is pretty dependent type
21:36:31 <woodson> I know this because of your blog jle`
21:36:38 <jle`> if you want to "defer" knowing a type until runtime (which is what you seem to be doing), then you need to use some sort of sum yes
21:36:53 <woodson> jle`: ok
21:36:56 <jle`> even in idris this is done using sums, except idris has anonymous dependent sums which makes it a bit syntactically simpler
21:37:17 <EvanR> i think its possible that what you want doesnt make sense
21:37:34 <EvanR> like, you the programmer dont even know what the type will be?
21:37:46 <EvanR> at all, no constraints
21:37:53 <EvanR> then who does
21:38:19 <EvanR> and how would code make use of the result
21:39:31 <woodson> EvanR, at this point I know how to resolve the issue I just wish to better understand the other options that we have
21:39:50 <EvanR> all the other options dont really apply or apply backwards
21:39:56 <woodson> just to have a better sense later on
21:40:33 <woodson> Ok, then the clear and only option when you need to deal with types that you wish to know at runtime
21:40:41 <woodson> is to use sum types?
21:40:48 <woodson> is that what you are saying?
21:40:59 <EvanR> yes
21:41:44 <woodson> Ok
21:41:55 <woodson> what about typeclasses?
21:42:03 <EvanR> thats backwards
21:42:21 <EvanR> you get an instance when you decide which type you want
21:44:11 <EvanR> but you said, you arent picking the type, the text file is
21:44:17 <EvanR> its not up to you
21:45:15 <woodson> EvanR: Well there must be a specific field that well let me know which type I should be picking
21:45:28 <woodson> so, something like
21:45:36 <woodson> type: CustomObject
21:45:38 <woodson> or
21:45:42 <woodson> type: ActionOverride
21:46:40 <EvanR> so you use that string to pick a parser
21:46:50 <EvanR> the function that does that picking has what type
21:46:51 <glguy> :t let parse "True" = Left True; parse "False" = Left False; parse "Hello" = Right "Hello" in parse
21:46:52 <lambdabot> [Char] -> Either Bool [Char]
21:47:15 <crestfallen> hi on line 58 is the combine' function. what should the arguments look like there for (l , x) (r, y)?  I've tried matching everything there. thanks     https://gist.github.com/varreli/ab982f58f0cec59ff5f073bbbe58eca2
21:47:52 <EvanR> String -> Parser CustomObject... no String -> Parser ActionOverride.... no... String -> Parser (CustomObject|ActionOverride|...) yeah
21:48:02 <woodson> EvanR: so far, I was thinking about something along these lines
21:48:03 <woodson> determineType :: FromJSON a => Value -> Maybe a
21:48:14 <EvanR> so, there you go again.
21:48:34 <EvanR> to use that, you the caller must choose a
21:48:39 <EvanR> then it will succeed or fail
21:48:45 <EvanR> based on the field
21:48:51 <jared-w> crestfallen: what's the result type?
21:49:10 <EvanR> the field will not pick the right a that gives you a Just
21:50:09 <jared-w> Also is that entire assignment supposed to be nothing but list comprehensions? o.O
21:50:20 <crestfallen> I tried matching arguments to that type, everything I could think of jared-w
21:50:39 <jared-w> Do you know what that type is, though? It's not defined anywhere in the file so idk what it is
21:50:42 <cocreature> crestfallen: which error message do you get?
21:51:00 <cocreature> jared-w: huh? Result is defined as a type synonym
21:52:04 <crestfallen> ln 64.    I guess its too low it should be above ln 58
21:52:34 <crestfallen> that's a typo sorry.. changing
21:55:15 <jared-w> ahh there we go, I couldn't see the type synonym at first
21:55:32 <jared-w> (you can set the file type of the gist to haskell if you want; it makes things a lot easier to look at)
21:55:46 <crestfallen> sorry one sec
21:56:35 <crestfallen> ok changes made :    https://gist.github.com/varreli/ab982f58f0cec59ff5f073bbbe58eca2
21:57:35 <crestfallen> any way I spent plenty of time but couldn't write valid arguments for combine'
21:59:31 <jared-w> So what, in a high level, is combine' _supposed_ to do?
21:59:42 <jared-w> (that is, can you explain combine' in just english?)
22:00:11 <cocreature> crestfallen: are the arguments you’re using in line 72 not valid? if so what’s the error message?
22:02:36 <crestfallen> (with different args :)   results [3,2]   returns [(3+2,5), (3-2,1), ( 3*2,6)]
22:03:04 <cocreature> crestfallen: sry I’m sitll confused. it seems like your code already compiles so what exactly is the problem you’re trying to solve?
22:03:07 <cocreature> *still
22:04:06 <jchia> glguy: Thanks. Works when there's only one type that I want to modify. I suppose when there are two types I can use the gtraverse' twice. The solution looks very abstract to me. I'll have to read that paper some time.
22:04:17 <crestfallen> when combine' take an argument, what exactly would (l, x) and (r, y) look like, given the output of results ?
22:04:29 <crestfallen> takes *arguments
22:05:47 <cocreature> crestfallen: take a look at line 68, results will return (in some cases) a list containing a single element (Val n, n) so that could be "lx" which is then passed to combine' in line 72
22:06:47 <crestfallen> I tried multiple ways to write the Expr , Int types properly to get combine' to run alone. right cocreature so for example (2,2) , right?
22:07:26 <cocreature> crestfallen: I don’t know how Expr is defined but 2 is probably not of type Expr
22:07:34 <cocreature> you need something of type (Expr, Int)
22:07:49 <crestfallen> one moment please
22:07:51 <cocreature> (Val 2, 2) should typecheck
22:12:04 <crestfallen> cocreature   here is the ShowExpression module     https://gist.github.com/varreli/ab300fb7647e15c3ae382cf2cc1306ff
22:12:44 <cocreature> crestfallen: alright so you need something of type Result which is just a type synonym for (Expr, Int)
22:12:51 <cocreature> so (Val 2, 2) would work
22:13:10 <cocreature> as would (App Add (Val 2) (Val 2), 42)
22:14:14 <crestfallen> thanks do I need deriving Show somewhere? I'm a bit confused
22:14:18 <crestfallen> cocreature,
22:14:46 <cocreature> no, you already have an explicit Show instance for Expr
22:15:01 <EvanR> show o, but Op is not an instance of Show
22:15:13 <cocreature> Op is an instance of Show
22:15:20 <cocreature> it’s defined in line 5-9
22:15:20 <EvanR> oh
22:15:28 <jared-w> It just doesn't have a deriving show :p
22:15:56 <crestfallen> I'm getting No instance for (Show (Result -> [Result])) arising from a use of 'print'
22:16:16 <crestfallen> with > combine' (Val 2, 2)
22:16:17 <cocreature> probably means that you have applied combine' to only one instead of two arguments
22:18:18 <EvanR> ghci hates you when you try to evaluate a function
22:19:00 <jared-w> Most things hate that, GHCi just hates it in a particularly confusing way :p
22:19:42 <cocreature> jared-w: huh? GHC is happy to evaluate functions for you
22:19:43 <crestfallen> if results returns a single non negative int, it would look like (Val 2, 2) right? combine' needs two args so I don't know how this works
22:19:56 <EvanR> ghci
22:20:03 <EvanR> > id
22:20:05 <lambdabot>  error:
22:20:05 <lambdabot>      • No instance for (Typeable a0)
22:20:05 <lambdabot>          arising from a use of ‘show_M8914423714795599642691’
22:20:18 <cocreature> crestfallen: try something like "combine' (Val 2, 2) (Val 4, 4)"
22:20:35 <EvanR> other than lambda bot which is cheating by using Typeable without a constraint
22:20:51 <EvanR> hmm or maybe its not
22:22:02 <crestfallen> so wait, if it's a single non-neg int, then combine is not called on line 72?
22:22:18 <crestfallen> combine'
22:22:49 <cocreature> crestfallen: if the input to results is a list containing a single integer, regardless of whether it’s positive or negative, you fall into the case in line 68
22:23:04 <cocreature> if the integer is positive, the resulting list will be non-empty, otherwise it will be empty
22:23:10 <crestfallen> btw thanks yes this does work : combine' (Val 2, 2) (Val 4, 4)
22:23:55 <crestfallen> right, so it never makes it to the comprehension part  ...
22:24:19 <cocreature> line 68 is a list comprehension as well :)
22:24:19 <crestfallen> that is correct cocreature right?
22:24:30 <cocreature> but yeah it never hits the one in line 69-72
22:24:42 * hackage wolf 0.3.45 - Amazon Simple Workflow Service Wrapper.  http://hackage.haskell.org/package/wolf-0.3.45 (markfine)
22:26:22 <crestfallen> ok got it . thanks . but how do you figure using  (App Add (Val 2) (Val 2), 42) as an argument, is that a typo there cocreature
22:26:23 <crestfallen> ?
22:26:56 <crestfallen> is 42 a typo
22:28:24 <zenspider> beginner here. working my way through Hutton's book. I'm trying to figure out how to find things. How does one go about looking at (hopefully haskell) implementations of the core functions? eg, I want to look at the source for iterate. Is there tooling or something that'll hunt down the definition of something?
22:28:51 <zenspider> (hopefully w/o needing a separate checkout of the source since I'm not building my own ghc)
22:30:18 <jared-w> Haskell's prelude is in Base
22:30:26 <zenspider> also would love some help with trying to figure out how to trace or otherwise see some iterations of execution to help me 1) understand wtf is going on at all and 2) debug my crap
22:30:28 <jared-w> which is in hackage, along with damn near everything else ever written in Haskell :)
22:31:09 <jared-w> There's a module called Debug.Trace that has a few functions in there that allow you to peek under the hood pretty well
22:31:40 <jared-w> It essentially allows you to "printf debug" haskell without having to rewrite your functions to be impure
22:31:49 <cocreature> crestfallen: no, what I meant was that it’s a valid argument in the sense that it typechecks not in the sense that it’s an argument that would be used by the call from results
22:32:15 <jared-w> http://hackage.haskell.org/package/base-4.11.1.0/docs/Debug-Trace.html
22:32:55 <jared-w> http://hackage.haskell.org/package/base-4.11.1.0  and this is base, zenspider. Click on any module you want, and then click on "source" in the top right and you'll see the source code for all of it
22:32:58 <crestfallen> cocreature, thanks kindly, I see how this works now
22:33:38 <crestfallen> zenspider, good luck hutton's book is tough but I'm not a programmer.
22:33:54 <crestfallen> (going through it now)
22:34:28 <zenspider> crestfallen: thanks!
22:34:56 <jared-w> (PS: Base version 4.0 has *much* more readable code)
22:35:12 <jared-w> http://hackage.haskell.org/package/base-4.0.0.0
22:36:31 <cocreature> zenspider: I generally just type the function name in hoogle, e.g., https://hoogle.haskell.org/?hoogle=iterate then click on the link that looks right (in this case the first) and then there is a “source” link at the right
22:37:16 <cocreature> jared-w: 4.0? you sure seem to like archeology :)
22:56:23 <zenspider> it might be more readable (not for me yet) but it doesn't matter at the level I'm at. Neither help me very much. :P
22:56:26 <zenspider> (yet)
22:56:52 <zenspider> I have hoogle as a cmdline tool... but the output seems? kinda not useful?
22:57:01 <zenspider> is there a phase 2 to running it?
22:57:02 <jared-w> cocreature: do you know any other just as readable versions of Base? :p
22:57:04 <cocreature> zenspider: anything specific that’s confusing you about the source of "iterate"?
22:57:24 <jared-w> By the time we got to 4.11.1 we have some pretty nifty magic and optimizations in half the libraries that make 'em fairly unreadable at times
22:57:34 <jared-w> (at least it seems to be that way to me ¯\_(ツ)_/¯)
22:57:44 <zenspider> cocreature: probably... but right now I need more metadiscussion rather than concrete stuff. How to figure shit out on my own, etc.
22:58:02 <cocreature> jared-w: most of the time I care way more about seeing the source of the code that I’m actually using rather than some simplified version of that
23:02:57 <zenspider> cocreature: sure. but sometimes you need babysteps for the understanding to catch up
23:04:48 <jared-w> cocreature: that's fair :)
23:05:07 <jared-w> I'll have to side with zenspider on this one, though; there's no way I could've read base 4.11 and had any idea wtf I was looking at the first 3 months of my haskell journey lol
23:05:14 <jared-w> (brb bedtime; see y'all later)
23:05:16 <dminuoso> zenspider: As a rough estimation you can also use @src here. Note that it will not show you the actual source for some function, but rather one that should be roughly equivalent.
23:05:23 <dminuoso> zenspider: (Or in a PM with lambdabot)
23:05:24 <zenspider> ok. so... I wasn't aware of the source thingy on the right. that helps. dash apparently downloaded the whole damn thing locally so it is REALLY fast. `eww` emacs integration is really really slow.
23:05:59 <zenspider> which is a shame. I'd love to stay entirely inside emacs for this
23:06:47 <cocreature> there are at least two reasons why you would want to look at the source of something: 1. to see how the function _could_ be implemented 2. see how it’s actually implemented so that you can better reason about its performance and similar stuff
23:07:08 <cocreature> for 1. looking at an older version is obviously fine, for 2. it’s pretty much useless
23:07:30 <cocreature> although for the particular case of "iterate", the version in 4.11 is about as simple as you can get :)
23:09:41 <zenspider> I've read about this some before but it has been a while... Does WHNF basically just mean "in a lazy-able state"?
23:10:33 <dminuoso> zenspider: One way to think about WHNF is that it's evaluated just enough to see the next constructor/function, but no more.
23:10:59 <cocreature> I’m not sure what a “lazy-able state” is but it sounds wrong :)
23:12:37 <zenspider> iirc... one of the examples was something like (+) (2 * 3 * 4) -- the (+) leaves it hanging and it doesn't need to evaluate the product yet as a result
23:13:34 <aleator> zenspider: One possible way to think about this is that expressions is WHNF if it starts with a constructor. (The root node of ast is a constructor application, to be exact)
23:13:47 <zenspider> OK. I'm confused. what the hell is the point of the hoogle cmdline? There's M-x haskell-hoogle and it is the same output. It isn't cross-linked... it just shows the library name and the type... but so does :info
23:13:47 <aleator> Your example is not whnf since + is not a constructor
23:14:29 <cocreature> zenspider: :info only work for things in modules that you have already imported
23:14:29 <zenspider> if there was further cross linking, I could understand the point... but meh?
23:14:38 <zenspider> aleator: "Similarly, (+) (2 * 3 * 4) is WHNF, even though (2 * 3 * 4) could be reduced to the normal form 24." from the wiki
23:14:39 <cocreature> but either way, I just use the web version
23:14:48 <dminuoso> aleator: It is WHNF.
23:14:50 <zenspider> cocreature: good point.
23:15:05 <aleator> zenspider: Oops. I thought it had one more argument sorry. Read bit too fast
23:15:06 <cocreature> also hoogle can search for things by type signature
23:15:08 <dminuoso> aleator: If you rewrite it into `\x -> x + (2 * 3 * 4)` it might be more obvious
23:15:08 <zenspider> wow. I actually remembered the code too. :P
23:15:29 <cocreature> but personally, I never managed to really get a lot of benefit from that
23:15:55 <aleator> dminuoso: Yeah, I just thought that the plus was pulled in front instead of the expression being fully applied.
23:16:06 <aleator> s/fully/partially
23:17:14 <aleator> Another formulation for whnf (for intuition) is that it is whnf if you can only compute on the sub-expressions and not the expression itself.
23:17:56 <aleator> Like in the example you could compute the sub-expression with multiplications but not the plus itself.
23:20:23 <cocreature> aleator: that sounds like a pretty weird formulation, if I have (1,1) why can I compute on 1 but not on (1,1)?
23:21:50 <aleator> cocreature: Well thats a normal form :)
23:21:56 <cocreature> aleator: it’s also whnf
23:22:23 <cocreature> whnf does not mean that it’s not in nf
23:24:45 <aleator> cocreature: Of course. That's why I said, for intuition. Normal form: you can't compute anymore. WHNF: you can only compute on the sub-expressions. Sounds not too unreasonable alternative way of thinking about this.
23:25:38 <dminuoso> aleator: That's not accurate enough.
23:25:49 <dminuoso> aleator: Every expression that is in NF is also in WHNF.
23:25:51 <zenspider> is there a comment or marker or something I can do to turn off a lint warning on a particular line? rather than turning off the whole class of warnings?
23:26:05 <dminuoso> (Because NF is more restricted than WHNF)
23:26:21 <dminuoso> aleator: It's not about what you can do, it's about what you cant do.
23:26:45 <zenspider> (I'm intentionally leaving some code with warnings--to document learning steps)
23:27:53 <aleator> dminuoso: Well, not my native language so.. What I was aiming at, is that in whnf you can _possibly_ compute the subexpressions, whereas in nf there is nothing to compute.
23:28:06 <dminuoso> zenspider: {- ANN f "HLint: ignore Use string literal" -}
23:28:27 <dminuoso> aleator: Like I said. Since NF is also in WHNF that sounds misleading.
23:28:56 <aleator> Well. sorry about that
23:29:17 <dminuoso> zenspider: where `f` could be some identifier
23:29:34 <dminuoso> zenspider: oh and I missed some `#` there of course
23:29:41 <dminuoso> {-# ANN f "HLint: ignore Use string literal" #-}
23:29:47 <dminuoso> Used too much to my emaacs magic. =)
23:30:12 <dminuoso> zenspider: also check http://community.haskell.org/~ndm/darcs/hlint/hlint.htm at the section "Ignoring hints"
23:31:47 <cocreature> you might want to use https://github.com/ndmitchell/hlint#readme instead. I don’t think that website is updated anymore
23:34:26 <zenspider> I'm trying: {-# ANN concat'3 "HLint: ignore" #-} to no avail
23:35:38 <zenspider> I tried more specific using the warning msg and that didn't work either.
23:35:55 <zenspider> Given output: programming_haskell.hs:116:12: Warning: Use concat
23:36:42 <dminuoso> aleator: A term is in WHNF if it does not contain a beta regex in head position, or if it is a lambda abstraction or a data constructor.
23:36:48 <dminuoso> I think that captures it accurately
23:37:23 <dminuoso> The point being that WHNF is not about what you can reduce, it's rather about what has been fully reduced.
23:38:56 <dminuoso> It's not an evaluation strategy, it's a form
23:40:32 <aleator> dminuoso: Or if it is a (tuple) section etc. My point was that, well, obviously the one who is asking has seen the definition, but has difficulties in grasping it, so an alternative approximation would be helpful. Sorry if this was not appropriate
23:41:48 <aleator> If we go splitting hairs, `f 1` is not a beta redex either, etc.
23:43:04 <aleator> in lc and I don't think there is a definition for haskell.
23:43:20 <aleator> But that all is likely just irrelevant to the idea
23:44:45 <butterthebuddha> How do I curry the mod function and input the "base" as the first parameter?
23:45:19 <butterthebuddha> i.e. create a function that returns the remainder mod 10 for example
23:45:36 <cocreature> (`mod` 10) 11
23:45:39 <cocreature> > (`mod` 10) 11
23:45:41 <lambdabot>  1
23:45:43 <cocreature> ^ butterthebuddha
23:46:42 <zenspider> butterthebuddha: it's like (+1) vs (1+)
23:48:00 <zenspider> ok. cool. all intentional warnings are culled. thanks. I forget the ##s
23:54:36 <zenspider> I'm learning a fair amount from hlint. I've turned off some higher order stuff and turned on some others. Is there ... what am I asking... a good progression to go through for learning more and/or tightening up my code?
23:55:57 <shachaf> whoa, hi zenspider
23:57:08 <zenspider> 'lo
23:58:27 <[exa]> zenspider: point-free is a nice exercise (though pointless sometimes)
23:58:44 <Ariakenom> the eternal pun
23:59:07 <dminuoso> I should practice writing arbitrary expressions into point free notation to get more comfortable..
23:59:20 <[exa]> Ariakenom: it just won't go away :D
