00:00:03 <EvanR> but thats not what a handler is...
00:00:18 <EvanR> i mean, not Exception e *> e
00:00:21 <cocreature> dminuoso: a good way to think about it is that if you pattern match on Handler, the code that operates on that result needs to be polymorphic in e
00:01:03 <cocreature> all it gets to know about "e" is that it is an instance of Exception
00:01:12 <dminuoso> cocreature: Well it needs to carry the evidence for `e`
00:01:17 <dminuoso> or `Exception e` rather
00:01:29 <dminuoso> But I think I understand what you mean
00:01:40 <cocreature> not sure what your point is tbh?
00:01:58 <dminuoso> Nevermind its all good :)
00:02:56 <cocreature> dminuoso: it might be helpful to take a look at how you can encode existentials using RankNTypes
00:02:58 <EvanR> when you unwrap Handler, you get an Exception e *> (e -> IO a)
00:03:59 <EvanR> whoever create the Handler chose which e at some point
00:04:17 <cocreature> e.g. rather than "data X = forall a. C a => X a" you can use data X = X (forall r. (forall x. C x => x -> r) -> r)
00:05:00 <cocreature> the "forall x. C x => x -> r" is the polymorphic code that I was referring to earlier
00:08:52 <EvanR> yeah so the procedure of unwrapping, taking a SomeException, doing fromException to get Maybe e, case analysis to get e, then applying the (e -> ...)  works no matter what e is
00:09:37 <EvanR> it better, because e is something, and we dont know what
00:13:37 <dminuoso> EvanR: But we have proof of an instance Exception, so we can use that interface at least.
00:14:00 <EvanR> yeah thats how you even got the e
00:14:33 <EvanR> otherwise youre sitting there with (e -> ...) like a goober
00:15:49 <Axman6> dpyro: btw, all functions take exactly one argument, this is universally true in Haskell
00:16:00 <Axman6> so, the "class" for this is "functions"
00:18:34 <dpyro> so functions as the concept, not some kind of defined class of Functions?
00:20:17 <cocreature> dpyro: it seems like you are asking for something like ‚Äúfunctions that return a primitive value‚Äù
00:20:25 <cocreature> so you want (+) 1 but not (+)
00:20:36 <cocreature> but then you need to ask yourself what a ‚Äúprimitive value‚Äù is
00:21:04 <cocreature> e.g. it seems like you don‚Äôt want to count functions as primitive values (otherwise (+) would fall into that class) while Int should be a primitive value
00:21:20 <cocreature> but what about something like "data X = X (Int -> Int)"?
00:22:37 <dpyro> no, not necessarily primitive
00:23:00 <dminuoso> dpyro: (->) is a type constructor that just has some special syntax rules. It's not too different from Either. Both require two types, and then you get a type back.
00:23:17 <dpyro> ‚Üí is a type too?
00:23:19 <EvanR> functions that return data
00:23:25 <dpyro> ü§Ø
00:23:26 <dminuoso> dpyro: Just like `Either Int Int` is a type, `((->) Int String)`, or written in infix form, `(Int -> String)` are types
00:23:31 <EvanR> functions arent data
00:23:32 <centril> :k (->)
00:23:33 <lambdabot> TYPE q -> TYPE r -> *
00:23:34 <EvanR> lisp be damned
00:24:01 <cocreature> dpyro: if you don‚Äôt care about it being primitive then Axman6 is right that all functions in Haskell take only one argument and you don‚Äôt need to make any more restrictions than ‚Äúit is a function‚Äù
00:24:07 <EvanR> data X = X (Int -> Int) isnt fair
00:24:20 <dminuoso> dpyro: So (->) is a type constructor in some sense.
00:24:32 <dpyro> that actually clarifies things a bit then
00:24:33 <centril> wait wat. TYPE q? ghci says (->) :: * -> * -> *
00:24:34 <cocreature> EvanR: life is not fair!
00:24:47 <dminuoso> dpyro: In fact you can even use it in prefix form.
00:24:47 <cocreature> centril: upgrade your ghci :)
00:24:52 <dpyro> :k (‚Üí) gives me (->) :: TYPE q -> TYPE r -> *
00:24:53 <centril> cocreature: thought so :P
00:24:54 <lambdabot> error: parse error on input ‚Äò::‚Äô
00:25:08 <dminuoso> dpyro: Don't worry about the details. Just assume it says `* -> * -> *`
00:25:36 <dminuoso> (It's a safe assumption for the beginning)
00:25:42 <cocreature> centril: q and r indicate the runtime rep https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#t:RuntimeRep
00:25:54 <dminuoso> dpyro: You could think `(->) :: * -> * -> *` =)
00:26:27 <centril> cocreature: interesting!
00:26:31 <dminuoso> > let a = (+1) :: ((->) Int Int) in a 5
00:26:33 <lambdabot>  6
00:28:04 <Ariakenom> dminuoso: "the beginning" Basically as long as you'd like.
00:28:34 <centril> anyways; what happens to (->) in a dependently typed setting (i.e: Idris)?
00:29:24 <EvanR> in idris, its no longer a type constructor
00:29:37 <EvanR> its part of syntax for pi types
00:29:48 <EvanR> which is a binding form
00:30:23 <dpyro> is there such a thing as a kind constructor?
00:30:28 <EvanR> similar to forall a . _ and \x -> _
00:31:21 <centril> EvanR: right; it was some time ago that I read goldfirere's PhD thesis; what happens to this when we get DependentHaskell?
00:31:49 <EvanR> dependent haskell has pi syntax... several of them
00:31:59 <centril> EvanR: 12 of them, yes? =P
00:32:08 <EvanR> i dont remember
00:32:08 <centril> or 12 arrows
00:32:28 <centril> https://github.com/ghc-proposals/ghc-proposals/pull/102
00:32:53 <EvanR> the real question is what happens when a relativistic linear haskell collides with dependent haskell
00:34:13 <centril> EvanR: I don't even want to look at that table of 12 quantifiers; adding linear types... just stop :/ :P
00:34:26 <dpyro> what's the importance of dependent haskell?
00:34:38 <dpyro> type all thing things? üòú
00:34:39 <EvanR> the linear haskell paper has a few more arrows
00:35:05 <centril> EvanR: well, then you have all the combinations... ;)
00:35:08 <dminuoso> dpyro: Well if you want, (->) in kind signatures can be thought of a kind constructor. It's a different (->) than in the type world.
00:35:31 <dpyro> is there a reason kinds aren't treated the same as types though?
00:35:35 <EvanR> (->) -> (->)
00:35:38 <dminuoso> dpyro: But I dont think that becomes a first-class thing anymore
00:35:59 <centril> dpyro: that's a proxy question for "what's the importance of dependent types" ;)
00:36:06 <dpyro> ooo
00:36:10 <dminuoso> dpyro: Other languages like idris have an infinite tower: `value > type > kind > ...`
00:36:29 <dminuoso> dpyro: Haskell seems to be moving into the direction to conflate them all into types (TypeInType)
00:36:40 <Ariakenom> type 0 > type 1 > type 2 > ... > type n
00:36:40 <EvanR> not values
00:37:01 <EvanR> values are never types
00:37:02 * centril tried Idris; centril was disappointed...
00:37:04 * hackage classyplate 0.3.1.0 - Fuseable type-class based generics  http://hackage.haskell.org/package/classyplate-0.3.1.0 (lazac)
00:37:35 <EvanR> for example 1 -> 3 makes no sense
00:37:47 <EvanR> where 1 and 3 are numbers
00:37:53 <EvanR> (not datakinds)
00:38:39 <EvanR> (that confused me a lot when trying to learn dependent types)
00:38:53 <centril> EvanR: you tried to learn it via Haskell?
00:39:04 <EvanR> no, idris, or hott
00:39:32 <centril> EvanR: ah; I learned it via Agda, which was a nice experience
00:39:42 <EvanR> yeah i have done some agda
00:39:42 <centril> Idris is full of bugs and crap documentation atm
00:40:38 <centril> EvanR: A dependently typed Rust would be pretty nice
00:41:06 <Ariakenom> lean is also a choice
00:41:14 <Ariakenom> that I've never used
00:42:10 <cocreature> lean is more aimed at theorem proving than writing programs that you can actually run :)
00:42:36 <centril> cocreature: Same with Agda tho ;)
00:42:45 <cocreature> sure
00:43:09 <centril> cocreature: there doesn't seem to be a great dependently typed language for use in production atm :/
00:44:18 <cocreature> yeah, idris is probably closest to that atm but depending on your usecase it‚Äôs still quite far off
00:44:50 <tdammers> "but is it production ready?" is a running gag in Idris by now
00:44:53 <EvanR> the ease of use of dependent types plus the ease of use of rust
00:45:24 <cocreature> something that people often forget about Haskell is that we don‚Äôt just have a pretty decent type system but also a great RTS. moving to something with a better type system but with a worse RTS isn‚Äôt necessarily a win
00:46:05 <centril> is there something fundamental in the type theory of dep-types that requires you to define function A before function B if B uses A?
00:46:53 <centril> i.e: > Functions and data types must be defined in the source file before it can be used.
00:47:45 <centril> cocreature: also, the error messages of Haskell aren't shit -- they are pretty awesome compared to Idris and even Rust
00:47:49 <jesyspa> Well, you cannot have cyclic typing derivations, though a particularly smart implementation could reorder them.
00:47:51 <EvanR> type checking happens in a typing context, which is a sequence of names
00:48:13 <EvanR> the type rules refer to stuff thats in the context
00:48:29 <centril> EvanR, jesyspa: right; that makes sense
00:48:37 <EvanR> if you add more definitions, you can only check them if the stuff it refers to exists
00:49:04 * hackage jukebox 0.3.7 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.3.7 (NickSmallbone)
00:49:08 <EvanR> but idris still allows mutually recursive definitions with a special form
00:49:10 <jesyspa> Don't forget that if B uses A, whether B typechecks may depend on the definition of A.
00:49:41 <EvanR> i imagine if the special form were always active, the type checker would become slow as dirt
00:50:39 <Ariakenom> couldn't you can gather names into the context first and resolve types later?
00:50:52 <EvanR> knowing just names isnt enough
00:51:04 <EvanR> for dependent types you will need the definitions to check types
00:51:14 <cocreature> Ariakenom: as jesyspa mentioned, the type can involve calls to other functions so you need the definitions
00:51:37 <centril> One thing that was particularly annoying in Idris was the constant warnings about implicits when you did something like:  'foo : Whatever; foo = stuff; bar : Stuff foo; bar = ...;'
00:51:44 <EvanR> and calls to functions can even be attempted without them being well typed first!
00:51:47 <EvanR> cant*
00:52:58 <centril> EvanR: could Idris possibly recognize that a certain function / function's type is not dependently typed and then relax rules?
00:53:57 <jesyspa> centril: Why, though?  I've been working in Agda quite a bit lately, and I've not found this restriction to be particularly limiting.
00:54:12 <centril> jesyspa: it interrupts writing flow tremendously
00:55:09 <centril> every time you try compile only to realize "eff, I wrote it in the wrong order" your train of thought gets slowed down a lot
00:55:40 <centril> jesyspa: sure; you can get used to it eventually, but... it takes some doing
00:56:18 <jesyspa> Hm, okay, to be honest I've never had any issue with it.
00:56:39 <centril> jesyspa: not even when starting?
00:57:51 <EvanR> idris the high level language gets "elaborated" into a core dependently typed language, with bare bones rules
00:58:03 <jesyspa> No, I had a lot of issues when starting, but definition order really wasn't one of them.
00:58:47 <EvanR> i kind of like stuff to be defined before its used, if possible
00:58:48 <jesyspa> I guess it might just be a matter of being used to different things; I come from C++, so maybe I automatically pay more attention to that stuff.
01:00:11 <cocreature> heh I was just about to mention that order-dependent declarations bring us back to the good old days of writing C/C++ :)
01:00:36 <centril> cocreature: yes, the "good" old days ;)
01:01:07 <EvanR> if its recursive, thats an issue yes
01:01:30 <centril> EvanR: I typically put the important API stuff early in a file, and helper functions in later parts
01:01:54 <jesyspa> To be honest, I find Agda code hard enough to read without having to jump back and forth. :P
01:02:00 <centril> (I avoid 'where' like the plague...)
01:02:00 <tdammers> or the good old days of writing template haskell
01:02:02 <jesyspa> centril: Have you tried splitting those out into their own file?
01:02:14 <centril> jesyspa: those being?
01:02:18 <jesyspa> The helper functions.
01:02:27 <EvanR> because 'where' doesnt really work that well in idris anyway
01:02:39 <jesyspa> I find that a common pattern I have with agda code is Definition.agda, Helpers.agda, Logic.agda
01:02:42 <EvanR> jesyspa: the module system in idris is pretty bad :)
01:02:50 <jesyspa> Ahh, that's a bummer.
01:03:21 <centril> jesyspa: well; the module would be too thin then; my Haskell workflow is to have super small eta-reduced functions at the top level, with some helpers as top level functions; and then I use the module system for defining APIs
01:03:41 <centril> my modules are pretty small as it is
01:03:58 <EvanR> centril: sounds like you want a flag to reverse the definition read-order, rather than "allow whatever"
01:04:07 <centril> EvanR: could be ;)
01:04:20 <EvanR> but jesyspa is right, if they can be untangled, would be nice for the compiler to do it for you
01:04:33 <centril> EvanR: tho I suspect that flag would never make it into the language and nor should it be cause a language shouldn't cater to my strange whims
01:04:46 <EvanR> but if the untangling changes semantics that would be b ad
01:05:48 <centril> EvanR: maybe it would be an idea to have some sort of "non-dependent mode" for some files; {-# LANGUAGE NoDepTypes #-}
01:06:11 <EvanR> i doubt thats possible, like i said, the core language is dependently typed, there is no "NoDepTypes"
01:06:56 <EvanR> youd need to come up with a new type theory, one that plays nice with the existing theory
01:07:13 <centril> EvanR: well, there should be some parts of the core language that makes it dependently typed, yes? Remove some of those rules and..? OK maybe it would be ridiculously restrictive.
01:07:33 <EvanR> the core language is very small
01:07:52 * centril needs to read up on the core language of Idris
01:08:25 <jesyspa> To be honest, I'm spoiled by Agda's module system; if there was one feature from there I could bring to Haskell, it would definitely be that.
01:08:28 <EvanR> core type theories tend to be so simple it hurts :)
01:09:00 <EvanR> if you can even understand how it works, you may find its impossible to modify
01:09:24 <EvanR> like the hydrogen atom
01:09:58 <centril> EvanR: you could perhaps do some sort of surface-level thing where you simply forbid the syntactic forms  (foo: bar ** P(foo)) and (foo: bar) -> P(foo) ?
01:10:10 <EvanR> why...
01:10:34 <EvanR> better idea, ask #idris
01:10:49 <centril> EvanR: true :)
01:12:28 <jesyspa> If it's just a matter of sorting them in order of usage, with no mutual dependencies, then it seems to me like that should be doable without all too much trouble.
01:15:49 <EvanR> though you might find failures confusing
01:16:37 <EvanR> dependent haskell should be interesting
01:17:55 <centril> jesyspa, EvanR: maybe it's for the best to not do sorting and such; failing with a simpler rule is more robust than failing with a hard to understand rule
01:20:04 * hackage weigh 0.0.12 - Measure allocations of a Haskell functions/values  http://hackage.haskell.org/package/weigh-0.0.12 (ChrisDone)
01:20:35 <tdammers> centril: it's not like "dependently typed" is somehow "a type system, but then add dependentliness"
01:21:10 <centril> tdammers: sure
01:25:35 <jesyspa> Kind of off-topic, but I was wondering if anyone knew on any work on morphisms between (McBride-style) indexed monads?  In particular, I'm curious what they should look like when the index set changes.
01:34:14 <centril> jesyspa: so this would be: (forall a. m a :-> t n a) -> (t m b :-> t n b)  ?
01:34:46 <centril> type f :-> g = forall state. f state -> g state
01:35:27 <jesyspa> Hm, not 100% sure I follow, what are t, m, and n in your example?  (I can guess at least one is the indexed monad, but which? ^^)
01:35:48 <jtojnar> Parsec prints unexpected "\8804", expecting space, white space or "\8901"
01:35:50 <jtojnar> Is there a way to make it show the Unicode character itself other than rewriting showErrorMessages completely?
01:36:39 <centril> jesyspa: 'm' and 'n' would be the indexed monads I think; thinking in terms of 'embed' in http://hackage.haskell.org/package/mmorph-1.1.0/docs/Control-Monad-Morph.html
01:37:21 <jesyspa> Ah, I see
01:37:37 <jesyspa> Well, I don't think we have a t here.
01:38:28 <jesyspa> If we have index types I and J, we m has kind (I -> *) -> (I -> *), and n has idem but with s/I/J/.
01:39:21 <jesyspa> So basically, the :-> you're suggesting wouldn't work, because f and g don't have the same kind (one is I -> *, the other J -> *).
01:39:40 <centril> jesyspa: also relevant:  https://stackoverflow.com/questions/28690448/what-is-indexed-monad
01:39:55 <centril> :-> is Conor's notation from that question
01:40:24 <centril> jesyspa: so I'm not getting exactly what you mean by "morphisms between MonadIx"
01:42:28 <jesyspa> centril: Basically, I am looking for an (interesting) category structure on MonadIx instances.  I think this is reasonably straightforward if we keep the state type fixed, but becomes harder if we allow it to vary.
01:43:13 <centril> jesyspa: so you are kinda looking for some equivalent for MonadIx of http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Arrow.html#t:Kleisli  ?
01:44:17 <jesyspa> I would say, I'm looking for a MonadIx equivalent of :->
01:44:34 <jesyspa> Since I think :-> are (up to laws) monad morphisms.
01:45:25 <centril> sure,  returnIx :: a :-> m a  has the structure of a monad morphism
01:46:32 <centril> jesyspa: so is this "A MonadIx in the category of MonadIx"?
01:50:00 <jesyspa> centril: I don't think it needs to have a MonadIx structure itself.
01:51:15 <centril> jesyspa: well; you lost me :)
01:51:29 <jesyspa> Ah, sorry ^^;
01:51:39 <jesyspa> Do you think putting it in category theory terms would help?
01:52:18 <centril> jesyspa: perhaps; but Haskell would be best ^,-
01:53:22 * centril laughs at Kmett's joke about Coat
01:54:40 <jesyspa> centril: Okay, maybe it's more approachabel from this perspective: we can regard a morphism from a monad M to a monad N as an "interpretation" of M in N.  For normal monads, this is just a function forall a. M a -> N a.
01:54:59 <jesyspa> For indexed monads, if the index types are the same, we can also just say forall a s. M a s -> N a s.
01:56:01 <jesyspa> But suppose now that we want to generalise this notion to when the index types are different.  Basically, my question is, does anyone have any idea/intuition/existing work on what "reinterpretation" means when the index types may vary?
01:56:18 <centril> jesyspa: so "interpretation" == natural transformation I take it
01:57:06 <jesyspa> Yes, I suspect it'll be a natural transformation in some form (probably with one side precomposed).
01:58:09 <jesyspa> https://github.com/jesyspa/master-thesis/blob/multiplayer/src/Algebra/Indexed/MonadMorphism.agda Here are two ideas I had (sorry, Agda, not Haskell), maybe that helps.
02:01:34 * hackage postgresql-binary 0.12.1.1 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.12.1.1 (NikitaVolkov)
02:02:15 <centril> jesyspa:  So   M ~> N = forall a. M a -> N a   for normal monads; and  M :~> N = forall a. M a :-> N a   for MonadIx
02:03:38 <jesyspa> Yep, that's right for any fixed index type.
02:03:55 <centril> jesyspa: but you want something like    forall a i o. M a i -> N a o   ?
02:04:10 <jesyspa> Yeah, with some restriction on the relation between i and o.
02:04:55 <dpyro> is there anything like "t (a -> b) -> a -> t b" ?
02:05:10 <centril> jesyspa: so,  forall a i o. Restriction i o => M a i -> N a o  ?   ;)
02:05:13 <dpyro> i tried hoogle but the closest i got was <*> but its not the same
02:05:29 <infinisil> :t <*>
02:05:29 <jesyspa> dpyro: Do you know anything about t?
02:05:30 <lambdabot> error: parse error on input ‚Äò<*>‚Äô
02:05:35 <infinisil> :t (<*>)
02:05:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:05:51 <infinisil> :t pure
02:05:52 <lambdabot> Applicative f => a -> f a
02:05:57 <dpyro> yes its a literal list of a -> b where the types a and b are the same
02:06:02 <infinisil> dpyro: Combining these two should work
02:06:10 <dpyro> i want to apply one a to all those functions and get all the results
02:06:19 <centril> :t  \fab a -> fab <*> pure a
02:06:20 <lambdabot> Applicative f => f (a -> b) -> a -> f b
02:06:29 <dpyro> ooo
02:06:37 <dpyro> let me try that, tyvm!
02:06:39 <jesyspa> centril: Yes... but I want composability, so not any Restriction will work.  Basically, my question is what Restrictions are well-behaved.
02:06:49 <infinisil> @pl \fab a -> fab <*> pure a
02:06:49 <lambdabot> (. pure) . (<*>)
02:06:50 <centril> :t  \fab -> (fab <*>) . pure
02:06:51 <lambdabot> Applicative f => f (a -> b) -> a -> f b
02:07:06 <centril> infinisil: for the love of god, don't write it that way ;)
02:07:21 <dpyro> that is a pointless pointfree üòÇ
02:07:21 <infinisil> death to all lambdas
02:08:05 <centril> infinisil: I've also signed the "Death to all lambdas" manifesto, but I'm practical about it ;)
02:08:08 <dpyro> if you hate lambdas just think of this http://www.globalnerdy.com/wordpress/wp-content/uploads/2008/11/halflife-gordon-freeman.jpg
02:08:15 <dpyro> it helps with lambda-tolerance
02:08:46 <infinisil> Oh, and I'm a big NixOS user, whose logo consists of 6 lambdas, so I guess death to all but 6 lambdas
02:10:35 <infinisil> (kind of ironic, because Nix doesn't even have function composition to avoid lambdas)
02:11:03 <centril> :t  let (.$) f g a = f a . g in (<*>) .$ pure
02:11:04 <lambdabot> Applicative f => f (a -> b) -> a -> f b
02:11:13 <dysfun> how can i accept a self-signed certificate as a client with Network.TLS ? the (docker-generated) cert has no common name
02:11:18 <centril> infinisil: ^  you need to extend your pointfree toolbox!
02:11:31 <centril> :t (.) . (.)
02:11:32 <dysfun> it complains that the hostname doesn't match (because there isn't one)
02:11:32 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
02:11:37 <centril> especially with ^
02:11:50 <centril> jesyspa: ill mull this over later :P
02:12:06 <infinisil> centril: True, but Nix can't define new operators, so it would be a pain to use
02:12:25 <jesyspa> centril: Thanks :)  Random thoughts on it are always welcome.
02:12:51 <centril> infinisil: well, either you have Nix or New custom operators; one has to go; hmm... which one to pick?
02:13:23 <infinisil> Nooooooooo
02:21:33 <xpika_> how do I enable interactive mode in emacs?
02:24:34 * hackage indexed-list-literals 0.2.1.1 - Type safe indexed list literals  http://hackage.haskell.org/package/indexed-list-literals-0.2.1.1 (DavidMD)
02:27:22 <infinisil> :t curry $ uncurry (<*>) . second pure
02:27:23 <lambdabot> Applicative f => f (b1 -> b2) -> b1 -> f b2
02:27:39 <infinisil> centril: dpyro: Aw yeah, how about that one instead ^^
02:28:05 <centril> infinisil: https://ro-che.info/ccc/12
02:28:24 <centril> infinisil: I wrote this a while back:  https://gist.github.com/Centril/4b8fa94514971a101caf59fc02f90cd1
02:28:37 <dpyro> üôÉüî´
02:28:55 <infinisil> Lol
02:29:04 <infinisil> Needs more symbols as functions
02:30:32 <infinisil> Hmm.. Would it make sense to have IO be an Arrow instead?
02:31:00 <centril> infinisil: got a lot of mileage of that gist for getting rid of do notation everywhere; code became a lot more readable; believe me!
02:31:13 <infinisil> centril: Yeah.. sure
02:31:33 <centril> infinisil: ^,-
02:37:44 <infinisil> Lol, just look at these operators: https://hackage.haskell.org/package/AFSM-0.1.3.1/docs/Control-AFSM.html#v:composeSM
02:39:00 <centril> infinisil: I think this goes under "eff software engineering, we are computer scientists"  ;)
02:39:04 * hackage ecstasy 0.1.1.1 - A GHC.Generics based entity component system.  http://hackage.haskell.org/package/ecstasy-0.1.1.1 (isovector)
02:56:15 <merijn> infinisil: What do you mean by "Would it make sense to have IO be an Arrow instead?"
02:57:19 <infinisil> Why is IO just a monad and not an arrow?
02:57:52 <quicksilver> because IO has the wrong kind to be an arrow
02:58:00 <quicksilver> however a -> IO b is a perfectly good arrow
02:58:04 <quicksilver> so maybe IO is an arrow?
02:58:42 <infinisil> I'm thinking maybe all process inputs could be the input
02:59:12 <infinisil> So main would be something like "IO Inputs ExitCodr"
02:59:43 <quicksilver> or it could be Inputs -> IO Exitcode
03:01:04 * hackage layered-state 1.1.3 - Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.  http://hackage.haskell.org/package/layered-state-1.1.3 (danilo2)
03:01:07 <infinisil> I guess
03:02:47 <fvr> If I find myself needing to simulate a singleton, am I doing something wrong in haskell?
03:03:07 <dysfun> a singleton is pretty bad in any language
03:03:44 <kuribas> dysfun: void in C/C++
03:04:22 <kuribas> but it's more like IO void
03:04:49 <infinisil> fvr: What exactly are you using it for?
03:05:43 <fvr> I want to open a db connection once and use it subsequently for any function with a constraint `HasDbConnection`
03:06:06 <fvr> assuming that the type class has a function `withDbConnection`
03:07:51 <tdammers> then pass the connection around explicitly
03:08:23 <tdammers> or use a Reader(T) to thread it through your calls
03:08:47 <fvr> if it was instead a transaction, I'd want to make sure that there isn't a transaction already open
03:08:58 <tdammers> same, really
03:09:15 <tdammers> doTheThing :: DbConnection -> IO ()
03:09:42 <tdammers> no need for a typeclass
03:10:13 <tdammers> or you could do: doTheThing :: (MonadReader DbConnection m, MonadIO m) => m ()
03:10:51 <tdammers> or declare a specific monad stack: doTheThing :: ReaderT DbConnection IO ()
03:11:21 <tdammers> for the transaction, you can even make sure that your functions cannot be called without an open transaction, it's easy:
03:11:36 <tdammers> make a module that declares a Transaction type, which wraps a connection
03:11:45 <tdammers> but do not export its constructor
03:12:19 <tdammers> instead, only provide a function withTransaction :: (Transaction -> IO a) -> DbConnection -> IO a
03:12:34 <tdammers> and do not export any other function that can construct a Transaction
03:13:00 <tdammers> and then you provide a function to pull the connection handle out of the transaction
03:13:36 <tdammers> as long as you don't close the transaction on purpose, this would automatically open and close transactions as needed
03:13:51 <tdammers> (provided withTransaction does the right thing, of course)
03:16:30 <maerwald> I always found it confusing why people use monads to hide function arguments :D
03:17:35 <maerwald> after all, haskell is all about monads?!
03:23:08 <infinisil> maerwald: It gets annoying when almost every function needs that argument
03:25:13 <maerwald> no idea what "annoying" means in that regard. You're just moving it to the monad stack, the type signature doesn't even become shorter, unless you hide everything behind a type synonym to improve unreadability
03:25:53 <infinisil> maerwald: Yeah that's what I'm implying
03:26:05 <maerwald> implying what?
03:26:07 <infinisil> E.g. for the configuration, provide a Config type that bundles the various settings
03:26:21 <maerwald> so you hide information?
03:27:02 <infinisil> Yeah, I mean I don't want to have to pass my config around all the time, that gets annoying, programming is all about not repeating yourself
03:27:37 <maerwald> I don't know what Config means here
03:27:43 <dysfun> really? i thought it was about finding good abstractions
03:27:59 <maerwald> dysfun: many people confuse deduplication with abstraction
03:27:59 <Logio> not to mention that by passing a explicit parameter around you invite a possibility of passing the wrong parameter
03:28:16 <maerwald> Logio: ??
03:28:27 <infinisil> maerwald: Config means e.g. the parsed config file of a CLI program
03:28:42 <infinisil> The program configuration
03:30:30 <maerwald> there are many ways to model configuration
03:31:24 <infinisil> Suppose your whole project is structured like this, having `MonadReader Config m` on every function you need to access your config
03:31:49 <maerwald> e.g. implicit parameter or reflection
03:32:05 <infinisil> Adding a new config option is really easy, all you do is add a field to Config, and use it wherever you need, no need to refactor method signatures
03:32:11 <kuribas> passing parameters is what functional programming is about
03:32:20 <maerwald> @hackage reflection
03:32:21 <lambdabot> http://hackage.haskell.org/package/reflection
03:32:26 <kuribas> so you have no hidden effects or inputs
03:32:32 <maerwald> right
03:32:44 <kuribas> I don't mind passing a config parameter at all
03:33:06 <maerwald> infinisil: there surely are use cases for monad stacks with reader, but I just think it's generally overused
03:33:37 <maerwald> primarily I model functions, not monad stacks :>
03:33:43 <infinisil> I'll use it whenever I need the same monads in a lot of places
03:34:14 <maerwald> I use monad stacks/mtl when I don't really know what effects I will need in the future
03:34:19 <Logio> abstracting the parameters to a monad is about abstracting the composition of the functions in a safe way
03:34:30 <maerwald> Logio: what?
03:34:41 <infinisil> I use IO everywhere so I am as flexible as needed /s
03:36:25 <maerwald> infinisil: well, if your inner monad is IO everywhere, then all that reader whatnot "abstraction" around it is basically moot
03:36:33 <Logio> maerwald: if two functions both need some state/environment, and require it to be the same, having the environment specified once as part of the monad is an advantage
03:37:29 <Logio> when composing said functions, that is
03:37:32 <infinisil> maerwald: (was a joke)
03:37:42 <maerwald> Logio: for that to be a problem you have to have a serious design error in your call stack. Which is silly
03:37:48 <maerwald> not a problem.
03:39:01 <Logio> I do not see what this has to do with call stacks
03:39:12 <Logio> I'm talking about reducing human error
03:39:13 <maerwald> err
03:39:23 <maerwald> you are talking about passing arguments -> callstack
03:39:40 <Logio> sure, but that's not the point
03:39:47 <maerwald> you're saying the implicit monad stack is safer than the explicit call stack
03:40:01 <maerwald> which is something totally clinical-theoretical
03:40:36 <Logio> I'm saying that fixing a parameter at a type level makes it (in some cases) more explicit, that only a single parameter can be utilized
03:40:56 <jhrcek> I've got this script based on fsnotify, to watch for changes to filesystem. https://gist.github.com/jhrcek/b763bf2979a1e294db6246534c280093 But when the FS events are coming too rapidly, the output of print for different events is interleaved. Is there a way to prevent that interleaving?
03:41:52 <infinisil> jhrcek: Single thread that prints stuff from a channel
03:43:39 <merijn> infinisil: FWIW, in older versions of Haskell IO used to be done via "main :: [IOEvent] -> [IOActions]"
03:43:51 <merijn> (related to the earlier question of IO as arrow)
03:44:02 <merijn> Monadic IO wasn't invented until several years later
03:44:03 <infinisil> Oh interesting
03:44:18 <reactormonk> With making field lenses, I currently have the issue that two files declare the same field, but since they don't know about each other, they generate two classes. What's the common workaround to deal with that?
03:44:57 <merijn> infinisil: I believe the Haskell Report 1.3 or 1.4 was the last one to have that, after that it switched to Monadic IO because it's so much more convenient to work with
03:48:01 <mbwgh> Does anybody use stack and cabal simultaneously? Up until now, I always used stack, because it worked fine for me when I started out, while cabal as it was back then seemed to require more mental overhead, with cabal hell and all that. Now I would like to try the new-* set of commands. I know I could just `stack install cabal-install` or something like that, but in the past that has lead to problems for me
03:48:07 <mbwgh> with things like ghc-mod and intero when I upgraded lts and GHC versions. So I am not sure what would be the best way to proceed here. I currently do not have cabal in $PATH.
03:52:38 <cocreature> mbwgh: "stack install cabal-install" should work just fine
03:52:59 <cocreature> note that especially for the new-* commands you want to make sure you‚Äôre using the latest versiron
03:54:17 <isovector> is there a common abstraction for divide and conquer?
03:54:48 <isovector> i think i want `Divisible` but for a semigroup instead of a contravariant?
03:55:30 <mbwgh> cocreature: So you think I can't mess things up by stack not knowing anymore which cabal-install to choose when building something, things like that? And considering the version, would that entail choosing the latest stackage nightly, or running some cabal upgrade command afterwards?
03:56:16 <cocreature> mbwgh: stack doesn‚Äôt use cabal-install so no you can‚Äôt mess that up
03:56:24 <cocreature> the latest stackage nightly should work
03:56:27 <mbwgh> isovector: I don't know if there is a curated typeclass, but I always thought divide and conquer was deeply related to monoid (homo-)morphisms
03:57:19 <Taneb> isovector: there's a Divisible instance for Monoid r => Op r, which is newtype Op b a = Op {getOp :: a -> b}
03:57:30 <Taneb> Which may be close to what you want
03:57:37 <isovector> i think what i want is actually just a hylo
03:57:47 <isovector> trying to do merge-sort-y kinds of things
03:58:06 <Taneb> Yeah, merge sort is a hylomorphism :)
03:58:10 <mbwgh> cocreature: I assume my previous bad experiences regarding editor plugins was related to having globally installed "Cabal", the library, in addition to cabal-install. Could that be?
03:58:23 <huxx> Hey everyone :P
03:58:38 <huxx> I'm facing a problem with a pattern
03:58:45 <huxx> Can anyone help me
03:59:55 <mbwgh> huxx: Sure, just ask your question.
04:00:21 <Taneb> huxx: generally people are more likely to know if they can help if they know what the problem is ;)
04:00:43 <Taneb> But if you have a problem with some Haskell, this is a great place to ask for help
04:00:59 <huxx> mbwgh: okay, I have a tuple (a, b), a function f :: MonadIO m... => b -> m c
04:01:19 <huxx> i would like to bimap on right
04:01:24 <huxx> second f tuple
04:01:32 <huxx> and get back m (a, b)
04:02:06 <huxx> I tried with Kleisli but It can't infer m for f if I let x = Kleisli f
04:02:49 <isovector> huxx: are you using x anywhere? it'll probably get inferred at a later time if it's actually used
04:02:56 <huxx> i did (\(t, p) -> pure (,) <*> pure t <*> loadShaderSource p)
04:03:00 <huxx> but its uglu
04:03:02 <huxx> but its uglu
04:03:06 <mbwgh> huxx: Since you want to map over the second tuple element you don't really need Bifunctor, Functor should suffice.
04:03:06 <huxx> ugly*
04:03:52 <huxx> isovector: not yet, you think using it will make it more general because im in a constrained context instead of concrete ?
04:04:00 <Ariakenom> :t liftA2
04:04:01 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:04:07 <Ariakenom> :t liftA2 (,)
04:04:08 <lambdabot> Applicative f => f a -> f b -> f (a, b)
04:04:24 <huxx> Ariakenom: yes but still ugly theses liftA1234 ^^^
04:04:39 <Taneb> :t \f (a, b) -> fmap ((,) a) (f b)
04:04:41 <lambdabot> Functor f => (t -> f b) -> (a, t) -> f (a, b)
04:04:50 <Ariakenom> trulyElegantName = liftA2
04:04:56 <isovector> huxx: yeah. if it can't infer m that's because it's not being used in a context that will allow it to unify that m to the monad you wanna use it
04:05:04 <mbwgh> liftA2 is rather unobstrusive I think
04:05:05 <Taneb> :t \f (a, b) -> (,) a <$> f b
04:05:06 <lambdabot> Functor f => (t -> f b) -> (a, t) -> f (a, b)
04:05:14 <huxx> isovector: will try that
04:05:20 <huxx> then fmap
04:05:21 <mbwgh> and logical, given that liftA1 = fmap
04:05:22 <huxx> then lift
04:05:34 <huxx> thanks guys
04:06:47 <isovector> huxx: also, `\(a,b) -> (,) <$> pure a <*> f b` is `traverse f (a,b)`
04:07:35 <isovector> minus the (a,b) application at the end :)
04:08:01 <Taneb> isovector: ooh nice, I forget that that works
04:08:06 <huxx> isovector: because fmap map right, right ?
04:08:22 <isovector> `traverse f = sequenceA . fmap f`
04:08:56 <huxx> isovector: this wil obfuscate my code lol
04:09:27 <isovector> huxx: maybe, but traversals are super common idioms. they're worth getting to know, and it's reasonable to assume other people do know them
04:13:34 <huxx> isovector: i've done what you said, pretty clear i have to say
04:14:43 <huxx> thanks again!!
04:15:18 <isovector> glad to help :)
04:16:45 <iron_houzi> Does stack have support for changing the LICENSE?
04:21:31 <mbwgh> Ok, I installed cabal globally, but it requires ghc to be in $PATH. Apparently, `stack install ghc` does not actually do anything, i.e. it does not copy ghc to ~/.local/bin.
04:22:02 <isovector> mbwgh: try `stack exec -- which ghc`
04:22:24 <mbwgh> Well, I could of course just update $PATH to point somewhere deep inside <the command isovector just gave>...
04:22:41 <isovector> :) also you can call `stack exec -- cabal` which will set path for you
04:23:13 <tdammers> `stack install ghc` installs the `ghc` package into the current project, but unfortunately, the `ghc` package is not the compiler itself, but the GHC API library
04:23:17 <tdammers> https://hackage.haskell.org/package/ghc
04:23:40 <tdammers> you cannot install GHC itself with stack (or cabal, for that matter) - GHC has its own build system and installation procedure
04:24:38 <tdammers> stack can, however, download and install a precompiled GHC for you (stack setup will do that unless there is already a GHC version available that matches the selected resolver), but it will not expose these GHC's system-wide
04:26:08 <mbwgh> I just want to be able to use both stack and cabal. For instance, I am not sure if liquidhaskell plays nicely with stack and editor plugins, but from what I have read it does with cabal
04:28:29 <tdammers> that should be absolutely no problem
04:29:00 <tdammers> stack does not touch any of cabal's stuff, nor the global GHC package DB
04:29:05 <mbwgh> `stack exec -- cabal install liquidhaskell` does not work, it complains about GHC_PACKAGE_PATH being incompatible with Cabal.
04:29:26 <tdammers> well, using them both together like this is probably not a great idea
04:30:31 <mbwgh> Well since liquidhaskell isn't on stackage from what I have seen, `stack install liquidhaskell` doesn't work. How should I install it then, if not via cabal?
04:32:26 <tdammers> have you read this: https://github.com/ucsd-progsys/liquidhaskell/blob/develop/INSTALL.md ?
04:33:23 <dminuoso> infinisil: One major useful reason I recently discovered for ReaderT is the Alternative instance you get. If you use asum or <|> a lot, then it greatly reduces the clutter. :)
04:33:48 <mbwgh> ugh
04:34:03 <mbwgh> I have brought shame over my family
04:40:15 <mbwgh> Ok, this seems to work so far. Thanks for your help.
04:44:34 * hackage diagrams-cairo 1.4.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.4.1 (BrentYorgey)
04:48:09 <iron_houzi> I want to create a type ParsedSyllable that is a set of SyllableComponent's, but each SyllableComponent needs to be mapped to a Letter. A set of ParsedLetter achieves the mapping, but now the set constraint is broken. Is the idiomatic solution to use a Data.Map in conjunction with the Set? I get a feeling there's a better way that I'm ignorant to due to my limited experience.
04:48:23 <iron_houzi> Code: https://github.com/ironhouzi/hstib/blob/dev/src/Main.hs
04:48:34 * hackage hw-prim 0.6.0.0 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.0.0 (haskellworks)
04:51:32 <Guest2329> I am writing wrapper fucntion for genereation of secretkey using this library https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html, is it good idea to throwCryptoError and just return SecretKey or return  CryptoFailable SecretKey ?
04:55:53 <iron_houzi> I guess my question is if it's possible to have a Set of tuples, where the set constraint is only applied to the first element of each tuple.
04:56:17 <Guest2329> I am writing wrapper fucntion for genereation of secretkey using this library https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-Ed25519.html, is it good idea to throwCryptoError and just return SecretKey or return  CryptoFailable SecretKey ?
04:58:04 <bartavelle> Guest2329: it depends I suppose :)
04:58:36 <Guest2329> bartavelle: can you elaborate?
04:59:51 <dminuoso> Guest2329: What reason do you have to not use CryptoFailable?
05:00:34 <Guest2329> dminuoso : some other function accepts just SecretKey with out CryptoFailable
05:01:10 <dminuoso> Guest2329: Is that function under your control? Are you in IO?
05:01:16 <bartavelle> Guest2329: explicit result types are useful when you want to compose function, or prefer to pattern match on the results
05:01:33 <Guest2329> dminuoso : yes
05:01:34 <bartavelle> exception is "nice" if you want to handle them all at an "upper" level
05:01:43 <`Guest00000> could dependent type systems be something like a monad for modeling?  in a dependent type system you're able to express a model and then use it in the same lexical level in which you defined it
05:01:49 <dminuoso> Guest2329: You can work with the CryptoFailable monad to pass a SecretKey just fine.
05:02:03 <dminuoso> Guest2329: Just use the Functor instance for example.
05:02:25 <bartavelle> oh, but ignore my answer, I did not know this was a monad
05:07:55 <dminuoso> Guest2329: Think of it as just an `Either CryptoError a`. The Functor interface lets you manipulate the secret key, the Monad interface lets you compose multiple crypto operations each of which could fail.
05:08:27 <dminuoso> Or rather not just the secret key. Whatever the result it.
05:09:08 <dminuoso> I'd be really curious why they didn't use `Either` to begin with
05:11:46 <exarkun> did someone already glue Servant and BSON together or do I get to do that?
05:12:32 <cocreature> exarkun: looks like you‚Äôre the lucky one that gets to do that :)
05:16:40 <exarkun> :)
05:17:27 <exarkun> Kinda have the same question about Capn but it looks like there aren't even any complete Capn implementations for Haskell, let alone Servant integrations.
05:18:27 <ysangkok> a post about linear types claimed that it will help zero-copy deserialization
05:19:09 <ysangkok> iirc, capnproto focuses on performance and not copying
05:19:34 * hackage bits-extra 0.0.1.0 -   http://hackage.haskell.org/package/bits-extra-0.0.1.0 (haskellworks)
05:31:14 <Guest2329> dminuoso : bartavelle: thank you
05:37:31 <ontanj> Hi! I have a `newtype T = T [Statement.T]` and am now trying to apply a function to each element (statement). But I can't seem to make Haskell understand this is a list. Any hints for me?
05:37:55 <isovector> ontanj: that's because it's not a list! :)
05:38:20 <isovector> ontanj: the most canonical way would be to write (or derive) a Functor instance for T
05:39:16 <isovector> oh nevermind, it's the wrong kind to be a functor. in that case you can just wrap and unwrap it:
05:39:37 <isovector> mapT f (T stmnts) = T $ fmap f stmnts
05:47:31 <ontanj> isovector: i couldn't make work but i should look into functors. thanks!
05:48:22 <codedmart> Anyone who can help me understand conduit. I want to stream a file and calculate the CRC32 checksum. It works fine if I readFile and digest it, but fold in Conduit.List gives me a different result then I expect. https://gist.github.com/codedmart/99de7e143241adbb2f74a565153e3b95
05:49:31 <cocreature> codedmart: can you show us the definition of digest and updateDigest?
05:50:02 <codedmart> cocreature: https://hackage.haskell.org/package/crc-0.1.0.0/docs/Data-Digest-CRC32.html
05:51:19 <codedmart> I can also do `fle <- readFile fp` then `foldl updateDigest initCRC [fle]` in the naiveCRC and it works.
05:51:22 <codedmart> As expected.
05:53:40 * hackage hexmino 0.1.0.0 - A small game based on domino-like hexagonal tiles  http://hackage.haskell.org/package/hexmino-0.1.0.0 (pasqu4le)
05:54:37 <int-e> codedmart: updateDigest32 crc = xorFinal . BS.foldl go crc <-- the xorFinal will be a problem when one does this in several chunks
05:57:44 <exarkun> trying to follow http://hackage.haskell.org/package/servant-0.13.0.1/docs/Servant-API-ContentTypes.html to support a new content-type, having trouble making MimeRender and MimeUnrender instances
05:58:22 <exarkun> `instance MimeUnrender CBOR a where` leads to Illegal instance declaration for ‚ÄòMimeUnrender CBOR a‚Äô (Only one type can be given in an instance head.  Use MultiParamTypeClasses if you want to allow more, or zero.)
05:58:28 <exarkun> What's an "instance head"?
05:59:27 <cocreature> exarkun: the instance head is basically the thing that comes after the typeclass name
05:59:31 <cocreature> so CBOR a in your case
05:59:46 <exarkun> So ... Just use MultiParamTypeClasses?
06:00:00 <cocreature> yes
06:00:01 <isovector> just use it!
06:00:32 <exarkun> :)
06:04:56 <cocreature> codedmart: to expand upon int-e‚Äôs answer, something like foldl' (\acc x -> updateDigest (CRC32 (crc32 acc `xor` 0xffffffff)) x) (CRC32 (crc32 initCRC `xor` 0xffffffff)) should work
06:05:07 <cocreature> codedmart: test that you get the same result for ["abcdef"] and ["abc", "def"]
06:06:22 <int-e> codedmart: and it's really a bug; the crc32 of an empty string is supposed to be 0xffffffff
06:07:33 <cocreature> int-e: you sure about that? the algorithm on wikipedia would return 0 as well
06:08:30 <cocreature> and some random websites seem to agree
06:15:37 <int-e> cocreature: no, I'm not certain... I find conflicting information now, i.e., several things called crc-32.
06:16:21 <codedmart> cocreature int-e: OK thanks I appreciate it.
06:17:30 <cocreature> int-e: life would be way too simple if people could actually agree on the meaning of terms :)
06:19:18 <doraemon> Hi everyone!
06:19:27 <williamtucker> hey
06:22:59 <doraemon> Maybe someone out here could help me with a question (or a problem) I stumbled upon? :) Let me know if my wording is not correct. I am trying to implement a function that has constraints on it's input and produces a value using functions from the typeclasses. For example, a function `f :: (Monoid m, Show m) => m -> String` that ignored first argument and returns `show mempty`. In this case both of the functions could not be deduced.
06:23:14 <doraemon> Is it possible to somehow tell the compiler that I want the `mempty` of `m`?
06:24:19 <Cale> Using ScopedTypeVariables, you can write  f :: forall m. (Monoid m, Show m) => m -> String; f _ = show (mempty :: m)
06:24:31 <doraemon> Here is a link to the code that doesn't work: https://lpaste.net/7844973334847553536
06:24:57 <int-e> codedmart: so to correct myself, the package should define its initCRC as 0 (which, after all, is the intended crc32 for the empty string), and updateDigest32 to do an xor 0xFFFFFFFF on both ends rather than just on the result.
06:25:12 <Cale> If you don't somehow specify what the type of mempty is, there's no way for the compiler to know which type you'd want it to have of course.
06:25:31 <awesomeaniruddh> https://pastebin.com/raw/hJ1YEQqJ
06:25:41 <codedmart> int-e: Good to know. Thanks!
06:25:45 <awesomeaniruddh> http://www.cis.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf <- solution to exercise 1 here
06:25:51 <awesomeaniruddh> Can I get rid of the indexing somehow?
06:25:55 <Cale> Oh, lpaste.net is back online?
06:25:57 <Cale> nice
06:26:03 <doraemon> Cale: wow, it did work. I tried writing `mempty :: m`, but it didn't work. Didn't know about ScopedTypeVariables. That really fixes the problem.
06:26:23 <awesomeaniruddh> Cale: lpaste.net is offline
06:26:38 <Cale> https://lpaste.net/ -- seems to be up for me
06:26:42 <geekosaur> doraemon, there's also asTypeOf
06:26:55 <awesomeaniruddh> Hmm, the link in the channel topic isn't working
06:27:04 <int-e> (so now I'm wondering why people don't streamline this a bit further... reverse the crc32 table and xor all the entries with FF000000... and then one can drop the initial and final xor?)
06:27:08 <awesomeaniruddh> https://lpaste.net/4923531241464004608
06:27:52 <Cale> awesomeaniruddh: I'd probably write something like:
06:27:57 <Cale> case x of
06:28:55 <geekosaur> hm, this does not look like the old lpaste. it looks like an ancient lpaste
06:29:02 --- mode: ChanServ set +o geekosaur
06:29:11 <cocreature> heh I thought it‚Äôs a new lpaste
06:29:11 <Cale>   ('E' : u : v : rs) -> LogMessage (Error (read u)) (read v) (concat rs)
06:29:15 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html' by geekosaur
06:29:22 --- mode: geekosaur set -o geekosaur
06:29:35 <Cale> oh, sorry, case words x of
06:29:50 <Cale> you get the idea, just use pattern matching
06:29:58 <awesomeaniruddh> I see, yep
06:30:17 <Cale> also, this way you avoid recomputing words x repeatedly
06:30:36 <doraemon> geekosaur, I didn't know about asTypeOf either. Thanks for the hint. I'll try to solve my problem using this function as well :heart:
06:30:54 <geekosaur> aaaaand an old paste I had saved is indeed gone. ah well
06:31:13 <Cale> Yeah, I wonder what happened
06:31:38 <Cale> At least something is better than nothing here.
06:31:50 <Cale> (with respect to lpaste.net)
06:32:12 <cocreature> the github repo is gone
06:32:41 <awesomeaniruddh> https://lpaste.net/5645889902508769280
06:32:43 <cocreature> ah it‚Äôs here https://github.com/lpaste/lambda-paste
06:32:45 <awesomeaniruddh> This is _much_ nicer
06:32:53 <cocreature> ‚ÄúNew, simpler codebase for lpaste.net‚Äù
06:33:21 * geekosaur verifies the other one is saved somewhere and then nukes the tab
06:34:25 <geekosaur> of course the other wasn't saved unless someone else still has a copy
06:40:09 <int-e> codedmart: https://lpaste.net/8496214724814307328
06:48:04 * hackage hw-rankselect-base 0.3.1.0 - Rank-select base  http://hackage.haskell.org/package/hw-rankselect-base-0.3.1.0 (haskellworks)
06:48:53 <iron_houzi> Is there a more idiomatic way to get to the set data in a data type that contains a set (https://github.com/ironhouzi/hstib/blob/typing/src/Main.hs#L58). The only thing I have so far is an additional function: `getset (SyllableComponents x) = x`, but is there a better way (TM) ?
06:54:21 <pavonia> iron_houzi: `newytpe SyllableComponents = SyllableComponents { getSet :: Set.Set SyllableComponent }' is the most common way, I think
06:55:00 <pavonia> Note the newtype to get rid of the extra runtime constructor
06:56:49 <iron_houzi> pavonia: Thanks!
06:57:35 <iron_houzi> will this `newtype` be equivalent to the datatype I had in all other ways though?
06:59:24 <dminuoso> iron_houzi: newtype is strict in its constructor
06:59:42 <dminuoso> iron_houzi: which is just to say that it doesn't add any runtime behavior
07:02:04 * hackage testing-feat 1.0.0.0 - Functional Enumeration of Algebraic Types  http://hackage.haskell.org/package/testing-feat-1.0.0.0 (JonasDuregard)
07:09:58 <iron_houzi> What if I want SyllableComponents to basically be an alias for Set SyllableComponent, so that I can do Set operations directly on a SyllableComponents instance, instead of accessing the set via `getset`?
07:10:06 <iron_houzi> Is that possible?
07:13:00 <byorgey> looks like suddenly haddock-api-2.19.0.1 won't build with GHC 8.4.2 because it requires ghc ==8.4.1 ?  Has anyone else run into this?
07:13:03 <byorgey> see e.g. https://travis-ci.org/diagrams/diagrams-svg/jobs/380167551
07:14:59 <byorgey> hvr: ping, do you have any ideas why the above would be happening?
07:17:31 <`Guest00000> iron_houzi: do you want "type SyllableComponents = Set SyllableComponent" ? you can define type aliases with "type"
07:18:14 <iron_houzi> Aha
07:18:22 <`Guest00000> also, you probably meant "value" instead of "instance", "instance" has a different meaning
07:20:55 <iron_houzi> `Guest00000: How would I create a new SyllableComponent then?
07:23:49 <electrocat> byorgey: because someone make the cabal file to strict? :p
07:25:38 <electrocat> made*
07:25:52 <geekosaur> looks deliberate, which is presumably why byorgey is asking hvr: http://hackage.haskell.org/package/haddock-api-2.19.0.1/revisions/
07:25:55 <davean> electrocat: given that they did change it to require exactly that, one would suppose it isn't because they made it too strict
07:26:05 <davean> electrocat: one would presume it goes bad with 8.4.2
07:26:17 <geekosaur> I would guess something unexpectedly broke ^
07:26:26 <electrocat> sure, one simply has to release a version for 8.4.2
07:26:34 <geekosaur> "simply"
07:26:38 <byorgey> oh, good sleuthing geekosaur
07:26:39 <davean> hvr: We should have a notes field on revisions
07:26:45 <geekosaur> becuase its always trtansparently obvious what change is needed
07:27:17 <davean> electrocat: haddock-api dies deeply into the compiler
07:27:35 <davean> electrocat: I think you might be unfamiliarwith the particular package(s) in discission here
07:27:52 <jlamothe> Has anyone ever successfully managed to deploy a wai/warp cabal package to Heroku?
07:27:54 <electrocat> davean: i am :p
07:28:00 <davean> electrocat: its showing :-p
07:28:01 <electrocat> unfamiliar that is
07:28:49 <davean> electrocat: haddock(-api) basicly acts internally to the compiler
07:30:32 <cocreature> byorgey: 8.4.2 ships with haddock 2.20. it has just not been uploaded to hackage so far
07:30:59 <byorgey> cocreature: ah, OK.  Do you know when it will be uploaded?
07:31:14 <byorgey> i.e. should I just wait for it to come out, or should I change my travis tests to use GHC 8.4.1 for now
07:31:21 <cocreature> byorgey: iirc the last hing I heard was something like ‚Äúwhen I find the time‚Äù :)
07:31:37 <byorgey> oh, so, like, three months then
07:32:31 <cocreature> byorgey: it isn‚Äôt clear to me why this is happening though. do you depend on haddock-api directly?
07:33:41 <byorgey> my travis tests install haddock explicitly.  I don't remember why, but I remember adding that at some point
07:34:12 <cocreature> you might want to try regenerating your travis config using https://github.com/haskell-CI/haskell-ci
07:35:02 <cocreature> oh no looks like your config is more complex
07:35:10 <cocreature> well you might still want to look at how that handles haddock
07:35:17 <cocreature> because it definitely does work with 8.4.2 for me :)
07:35:19 <byorgey> yes, I know about haskell-ci, and I use that for most projects, but the diagrams project specifically has a complicated homegrown travis setup
07:35:34 <byorgey> but yes, I should try taking a look at how it handles haddock
07:36:26 <reactormonk> With TemplateHaskell, how do I define a method name? I get "Left-hand side of type signature is not a variable: $(splicedName)"
07:39:23 <cocreature> byorgey: is there a reason why your travis setup is so complicated? I assume it‚Äôs because you want to test against unreleased versions?
07:42:26 <geekosaur> reactormonk, can you show example code of what you are trying to do?
07:42:26 <byorgey> cocreature: that's the primary feature that we would lose by switching to circle-ci, yes.  Each repository can specify other repositories it depends on, and a test build on branch 'foo' will build against branch 'foo' of those other repositories from github (if such a branch exists) instead of from Hackage
07:42:59 <`Guest00000> iron_houzi: you create a value of type SyllableComponents by just creating a value of type (Set SyllableComponent), type aliases are really the same types
07:43:05 <reactormonk> geekosaur, https://gist.github.com/reactormonk/6b49eedeaf215c74a1309d22d5f71c51
07:43:15 <byorgey> I meant haskell-ci, not circle-ci
07:43:36 <cocreature> byorgey: seems like things might be easier if you just add deps as a submodule and use new-build
07:43:56 <byorgey> cocreature: it might be, if I knew anything about submodules
07:44:22 <`Guest00000> but then you can't create a typeclass instance for an alias for a type without creating the exact same instance for that type
07:44:30 <cocreature> byorgey: heh fair enough, just a suggestion :)
07:44:47 <byorgey> I have always gotten the impression that they are complicated and tricky so I have just stayed away.
07:45:24 <byorgey> but I am definitely open to suggestions on how to simplify our travis configuration.  It is a pain in the neck to maintain.
07:45:57 <`Guest00000> if you want to use a different instance for a type in some places than it already has, you will have to use newtype wrappers
07:46:38 <davean> byorgey: can you not do that with submodules for any given CI system that supports git?
07:46:54 <davean> byorgey: they're quite trivial
07:47:07 <davean> They're just a git repo that gets checked out at a specific commit in a subdirectory
07:47:51 <byorgey> davean: who decides which specific commit they get checked out at?
07:48:04 * hackage propellor 5.4.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-5.4.0 (JoeyHess)
07:48:11 <davean> whatever commit you commit them as being checked out as?
07:48:24 <davean> byorgey: its part of them being commited in git, just like the contents of any file
07:49:19 <byorgey> the nice thing about our current system is that if you want to make parallel changes in two repos, you just make a branch of the same name in both, make your changes, and if Y depends on X then the test build for Y will automatically build against the same branch of X
07:49:42 <byorgey> but it sounds like with submodules you'd need to do all that *and* remember to update the X submodule inside Y to the right commit on the right branch
07:49:52 <davean> Yah, where as with submodules you'd make said branches, and then in the one that uses the other you'd just updated what it refered to
07:50:03 <cocreature> byorgey: it seems like you can do that with just a few git clones in the travis config before you call new-build?
07:50:08 <davean> byorgey: but, consider with yours
07:50:16 <davean> byorgey: for a given commit, which state of the other does it work with?
07:50:25 <davean> byorgey: its very lossy-goosy versioning what you're talking about
07:50:34 <davean> byorgey: hardly reliable
07:50:39 <byorgey> davean: yes, I see what you're saying
07:51:15 <davean> Not that you care about reliability of course.
07:51:25 <davean> Thats not a decision I can guide you on :)
07:51:57 <geekosaur> reactormonk, sorry. I vaguely recall some gotcha here where mkName gives you a new name instead of the existing method name
07:52:15 <geekosaur> but don't recall details
07:52:51 <reactormonk> geekosaur, got me a hint where to look for
07:52:52 <davean> byorgey: All you have to do though, to keep them updated, is git pull in hte submodule and then if you commit -s they'll just get updated
07:53:09 <davean> byorgey: any you have to pull in the other repos somehow to keep up to date with them
07:53:21 <geekosaur> no, I'm recalling haskell-cafe (I think) from some time back but don't recall when
07:53:27 <davean> so I expect its actually exactly the same amount of work when working on the repos as you do now
07:54:08 <byorgey> davean: what is commit -s ?
07:54:22 <byorgey> davean: and thanks for the suggestions, I will look into it
07:54:24 <davean> byorgey: When you checkout the repo initially, the submodules will be a detached head (obviously - they're a specific commit) but if you just change to the branch you want, then they act as normal git repos, other than tagging the link in the super repo
07:54:30 <davean> byorgey: commit -a and a typo
07:54:36 <byorgey> ah, ok
07:55:09 <davean> byorgey: yah, just remembver oyu can use the submodules as normal git repos to do your dev in - thats something people somehow miss
07:55:31 <davean> and a fact that makes all the use of submodules effectively 0 overhead for a lot of cases
07:55:33 <exarkun> How do I go from a Value to the corresponding FromJSON a with Aeson?
07:56:15 <davean> exarkun: parseJSON?
07:56:28 <davean> exarkun: the member function of FromJSON
07:56:31 <byorgey> davean: right, I see, though it seems that would only be helpful if your dependency graph is a tree rather than a general DAG
07:57:23 <davean> byorgey: well, its most useful as a Tree. though generally you can transform any DAG into a Tree ...
07:57:26 <exarkun> davean: `parseJSON :: Value -> Parser a` - how do I go from `Parser a` to `a`?
07:58:16 <davean> exarkun: parseJSON
07:58:22 <exarkun> :(
07:58:39 <davean> exarkun: you might want fromJSON which ties them together
07:58:50 <davean> exarkun: parse
07:59:04 <davean> exarkun: you're familiar with parsers?
07:59:17 <exarkun> not particularly
07:59:42 <exarkun> not in Haskell
08:00:10 <geekosaur> exarkun, parseJSON does not give you a value, it gives you a function that can parse a value (Parser _). you have to use parse to apply it to a JSON stream and extract the value
08:00:12 <davean> Haskell is basicly irrelivent here
08:00:25 <davean> Just the general theory
08:00:36 <exarkun> okay maybe I don't know anything about parsers in general then
08:00:57 <barrucadu> exarkun: Use `decode` or `eitherDecode`
08:01:04 <barrucadu> http://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#v:decode
08:01:27 <exarkun> I don't have a ByteString, I have a Value
08:02:09 <barrucadu> Oh, I see
08:03:04 <geekosaur> Value is a tagged value, take a look at its definition. you can pattern match to see if it has the right thing in it and extract it if so
08:03:31 <davean> geekosaur: I mean, that doesn't get him to a given 'a'
08:03:49 <exarkun> I think I understand how to do that but I would have to do it a lot of times
08:04:31 <geekosaur> something doesn't make sense here. why do you have a Value?
08:04:59 <exarkun> https://gist.github.com/exarkun/baa04fe463beda35dc318f23fc0ff716
08:05:11 <geekosaur> normally you use decode or eitherDecode at some type, Value is usually used when you're not sure what you are getting and need to inspect it
08:05:14 <exarkun> see 53-54
08:05:37 <exarkun> I lied, I do have a ByteString but it contains CBOR-encoded data.
08:05:58 <davean> exarkun: oh well thats different!
08:06:31 <exarkun> And I have a bunch of types that have FromJSON instances
08:06:53 <exarkun> And cborg-json defines `decodeValue :: Encoding -> Value`
08:07:13 <exarkun> uhh sorry that was totally the wrong signature
08:07:45 <exarkun> https://hackage.haskell.org/package/cborg-json-0.2.0.0/docs/Codec-CBOR-JSON.html
08:08:54 <exarkun> Maybe I have all the wrong pieces here, I dunno.  But it seemed like `ByteString` to `Value` to `FromJSON a` sort of made sense (since on the encoding side I went `ToJSON a` to `Value` to `Encoding` to `ByteString`)
08:10:34 <cocreature> exarkun: it does make sense (except for the part that you can get some errors in between which slightly complicates types). have you looked at the "parse" function that has been recommended multiple times by now?
08:11:48 <exarkun> I have but I don't quite understand what to do with it.
08:12:26 <exarkun> I get a `Result a` at the end
08:12:41 <exarkun> Maybe I can pattern match on the Result constructors to get the a out?
08:12:46 <cocreature> exactly
08:13:01 <cocreature> Result is just like Either String
08:13:59 <Taneb> exarkun: Result is so you get something useful (like an error message) when the JSON is correct JSON but doesn't correspond to your type
08:14:06 <awesomeaniruddh>  
08:14:19 <cocreature> exarkun: so if you set a = Value in the type of "parse" you get something of type (Value -> Parser b) -> Value -> Result b
08:14:30 <cocreature> exarkun: any idea what you could be using for the Value -> Parser b function?
08:15:27 <exarkun> That looks like parseJSON
08:15:32 <cocreature> exactly!
08:15:57 <cocreature> so "parse parseJSON" will give you a FromJSON a => Value -> Result a
08:16:10 <cocreature> which seems to be exactly what you‚Äôre looking for if I understood you correctly
08:17:04 <cocreature> there is also parseEither which will give you Either String a instead of Result a which might be convenient if you want to compose it with other code working in Either
08:17:05 <exarkun> It seems to be.  I'll give it a try in a minute.  That pattern is a little off-putting... "parse parseJSON".  From the types, I see why it should work, it's just the naming strikes me as odd.
08:17:36 <davean> exarkun: parseJSON is the JSON parser for the type you want, parse runs a parser
08:17:49 <cocreature> yeah the naming is a bit weird. what aeson calls Parser is an encoding of the parse result rather than an encoding of the parser itself like you might find in parsec
08:18:13 <davean> there are functions that combine them - fromJSON
08:19:28 <exarkun> well ... it compiles
08:25:34 * hackage extensible-effects-concurrent 0.1.0.0 -   http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.0.0 (SvenHeyll)
08:26:29 <exarkun> I don't know if it works, though, because the code using it doesn't compile
08:26:38 <exarkun> because the basic premise of my efforts is flawed.
08:26:43 <exarkun> oops.
08:26:48 <cocreature> if it compiles it obviously works
08:27:09 <exarkun> :)
08:27:28 <exarkun> The reason I am messing with CBOR is that JSON cannot encode binary strings
08:27:50 <exarkun> So defining CBOR support in terms of FromJSON and ToJSON was quite stupid, I guess.
08:28:56 <cocreature> if you really want to go down the json route you can always base64-encode your binary strings :)
08:29:03 <exarkun> I really don't want to do that.
08:29:25 <exarkun> But Aeson seems to have much nicer facilities for marshalling records.
08:30:09 <cocreature> have you looked at the "serialise" library?
08:30:17 <exarkun> Yes, I accidentally started with that one.
08:30:33 <exarkun> But I want interchange between different languages and "serialise" warns that this isn't what it's for.
08:30:59 <exarkun> Taking some non-standard shortcuts that are safe if you only use "serialise" for encoding and decoding, I guess, but that may break other implementations.
08:33:10 <exarkun> Should I try to force these ByteStrings through Aeson into the CBOR encoder?  I think I could give ByteString an instance of ToJSON/FromJSON that would be invalid for actual JSON but maybe valid-enough to get it over to the CBOR layer.  Or should I throw this away and pick a new approach...
08:33:34 * hackage extensible-effects-concurrent 0.1.0.1 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.0.1 (SvenHeyll)
08:33:55 <davean> exarkun: you can just duplicate the idea in Value
08:34:57 <exarkun> davean: can you expand on that a bit?
08:35:15 <cocreature> I would probably just use "serialise" anyway and deal with the fact that encodings might change with new versions or not rely on the builtin encodings for any non-trivial types (e.g. the encoding of Int is probably unlikely to change)
08:35:43 <AWizzArd> Foundation vs. Protolude? Is there a clear winner on which the community is settling?
08:35:53 <glguy> The community mostly isn't using either
08:36:28 <AWizzArd> glguy: great :-)
08:36:36 <cocreature> ‚Äúprotolude‚Äù is also not really something that the community needs to settle on since it‚Äôs mostly just reexports
08:37:23 <cocreature> so in most cases, even if you use protolude in your library, that won‚Äôt change anything for the users of your library
08:39:44 <sm[m]> AWizzArd:  see also rio
08:39:52 <davean> AWizzArd: Control.Lens I think is hte most common prelude replacement ;)
08:40:22 <EvanR> so Writer... am i missing something obvious in how to use this to efficiently emit 1 item at a time. which monoid do i use?
08:41:15 <centril> EvanR: Writer + difference lists work well together iirc
08:41:38 * EvanR looks up which direction the <> happens
08:42:05 <centril> Using [a] as the monoid is terrible because you're doing ++ all the time, which kills perf
08:42:22 <EvanR> what about Map union
08:42:47 <EvanR> or give up and use strict state
08:42:53 <glguy> Writer isn't particular good for a type like Map with a strict union
08:43:24 <glguy> You'll build up the whole map as a gigantic thunk with no opportunity to stream the result
08:44:06 * centril gets why people don't like lazy evaluation; reasoning about it and perf is hard
08:44:08 <quicksilver> > take 5 . snd . runWriter . forever $ (tell "a")
08:44:10 <lambdabot>  "aaaaa"
08:44:17 <quicksilver> ^^ [] is fine as the Monoid
08:44:23 <quicksilver> it right-associates the ++ anyway.
08:44:33 <glguy> it only right-associates if you right associate
08:44:34 <quicksilver> (if it didn't right associate that code wouldn't terminate)
08:44:46 <glguy> and you right-associated by choosing forever
08:44:55 <quicksilver> ok, fair point
08:45:08 <quicksilver> but common recursion patterns often to that
08:45:16 <EvanR> is that lazy writer?
08:45:17 <quicksilver> it would be a very poor choice for binary-descent certainly
08:45:29 <centril> My favorite use of writer is: 'Writer Any'
08:45:36 <glguy> That's a bad choice for writer
08:45:42 <glguy> (writer any)
08:45:54 <centril> glguy: how so?
08:45:57 <EvanR> ok wait... how is it posssible to decide the associativity?
08:46:06 <glguy> It builds up the any as a huge thunk when you could have evaluated to a single bool along the way
08:46:17 <quicksilver> EvanR: it is following the associativity of the way I used >>
08:46:32 <quicksilver> because forever is defined as "forever f = f >> forever f"
08:46:42 <EvanR> oh the monad action itself has some parentheses o_O
08:46:43 <centril> glguy: right, you'd like to force the <> of Any at each step
08:46:44 <quicksilver> eierything recurses down the right hand side and the associativity is fine
08:46:53 <glguy> centril: and you can't
08:47:13 <EvanR> wow so the efficiency of writer is a function of your recursion details
08:47:24 <centril> glguy: elaborate?
08:47:40 <quicksilver> EvanR: but that is fairly common - because the most common recurision primitives also associate that way
08:48:03 <glguy> I suppose Any could work if you make sure to only evaluate the Any value and throw away the result and don't use it with a strict >>= monad like IO underneath
08:48:23 <EvanR> when you monoid-together difference lists, how does that become more efficient with the arbitrary parentheses?
08:48:45 <centril> glguy: "throw away the result" meaning that you throw away the  'a' in 'Writer Any a' ?
08:48:49 <glguy> yeah
08:48:56 <centril> well that's no good
08:49:30 <EvanR> i'm hearing, give up and use a strict state with a "log" action
08:49:31 <glguy> Just keep in mind that the time to use a write isn't for "write only" outputs as a policy, it's for when you want to build up an expression using <> while doing something else, too
08:50:08 <centril> glguy: I used    'Writer Any a'   as a normalization monad to track change/no-change
08:50:14 <EvanR> what about strict writer?
08:50:37 <centril> glguy: so it is doing something else... normalizing 'a' (possibly)
08:50:39 <glguy> EvanR: strict writer is like strict state, it's strict in the bind, not the state or accumulated value
08:50:46 <EvanR> :(
08:51:09 <centril> I feel like laziness is one of the least understood parts of Haskell among Haskellers
08:51:11 <glguy> centril: as long as you're doing it in really small scales then it'll be fine and the bad performance won't matter
08:51:18 <EvanR> so to do it with strict state i also have to manually evaluate the state at each step
08:51:49 <EvanR> modify'
08:51:53 <centril> glguy: well... I'm using  Control.Lens.Plate + that to rip through Java ASTs
08:52:56 <glguy> centril: Yeah, it probably works great, it's just not as memory efficient as it could be
08:53:31 <centril> glguy: we never perf tested it ;) had more pressing concerns :P
08:54:22 <centril> glguy: so... is it possible to build a monad which works (from the POV of an API user) like  Writer Any  but is strict in the accumulation of the 'Any' ?
08:55:03 <glguy> As a user of Writer I expect and like having access to the lazy behavior, so in that respect no you can't do it because then it wouldn't have the advantages that writer has
08:55:28 <glguy> If what you want is a State monad with a state that you update using <> then of course you can do that
08:56:37 <EvanR> 1. i am looking at teh code for Strict Writer(T), in transformers. the comment says that this "is strict but cannot achieve constant space behavior", but i dont understand from the Monad instance how it is considered strict
08:56:41 <centril> glguy: right; then would it be strict in 'a' also?  having your cake and eat it too would be strict in 'Any' but lazy in 'a'
08:57:17 <EvanR> theres no seq or ! anywhere
08:57:58 <glguy> EvanR: it's strict in matching on the (,)
08:58:00 <EvanR> its strict in the sense that they didnt do ~(a,w) <- runWriterT m ?
08:59:00 <dyl> Please submit/vote for Haskell IRC community tropes, for the purpose of assembling the official #haskell bingo board: https://goo.gl/forms/a1RucqfwL6dK7JKc2
08:59:18 <EvanR> indeed i see it in lazy
08:59:27 <EvanR> 2. *checks out state*
08:59:50 <dyl> Er, better link: https://goo.gl/forms/dVRaMXUPc7P3yiPE2
08:59:56 <quicksilver> you can even make a MonadWriter instance for your StateT based solution
09:00:31 <EvanR> so much laziness going on
09:00:53 <centril> dyl: there's no entry about pointless stuff; I am disappoint.
09:00:55 <glguy> With lazy writer this works:
09:00:56 <glguy> >>> let ((), Dual (y:_)) = runWriter (undefined >> tell (Dual "a")) in y
09:00:56 <glguy> 'a'
09:01:37 <dyl> centril you can add it!
09:01:49 <centril> dyl: I shall!
09:01:51 <thebnq> how would irc bingo work
09:02:11 <dyl> I'm just going to make a bingo board.
09:03:19 <centril> dyl: Other: "The pointlessness of Haskell"
09:03:38 <EvanR> quicksilver: shouldnt this come up often enough that somebody has done that already
09:03:53 <thebnq> Oh i see
09:04:03 <dyl> The free space is "Adjoint Functors".
09:04:08 <dyl> Because they arise everywhere.
09:05:01 <centril> nice to see that edwardk has his own bullet
09:06:44 <dyl> I felt that was appropriate.
09:07:04 <dyl> I want these to be common enough that you could realistically get bingo in a day.
09:09:18 <centril> dyl: it is :)
09:10:18 <edwardk> dyl clearly there should be two free spaces on the sides of the central space labeled as Free -| Forget -| Cofree clear across the central space, with one per space. well one free space and one cofree space
09:11:09 <nsnc> "troll"
09:11:13 <dyl> So the free one is free in bingo
09:11:22 <dyl> And the cofree is free in cobingo?
09:11:22 <nsnc> "may I ask a question?"
09:11:41 <dyl> edwardk wait, can we derive cobingo rigorously?
09:11:51 <thebnq> i got lost at coffee.
09:12:04 <edwardk> re haskell bingo the quchen troll conversion chatlog comes up rather frequently
09:12:11 <dyl> I don'
09:12:14 <dyl> I don't know that one.
09:13:43 <edwardk> https://gist.github.com/quchen/5280339
09:15:29 <edwardk> it's led to an endlessly trying procession of copycats
09:16:23 <dyl> Did he actually come back to try to learn Haskell?
09:16:47 <edwardk> no idea
09:17:39 <centril> > xQuasar: We'd love to help you make your first steps.
09:17:42 <lambdabot>  <hint>:1:54: error:
09:17:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:17:51 <centril> that is just gold
09:20:43 <centril> edwardk: thanks for sharing that <3
09:21:05 <KernelBloomer> I am so weak in maths
09:21:16 <KernelBloomer> I am afraid I cant learn haskell ever :(
09:22:30 <byorgey> KernelBloomer: nonsense. Learning Haskell will help you get stronger in maths, not the other way around
09:22:36 <byorgey> maths is not necessary for learning Haskell.
09:23:08 <KernelBloomer> reallu
09:23:18 <KernelBloomer> really. good to hear that. thanks for the motivation byorgey
09:23:38 <KernelBloomer> byorgey, where did you learn haskell from
09:23:48 <KernelBloomer> or your recommended tutorials /  books / guides etc.?
09:23:54 <dyl> Data point: I got into Haskell during high school, and ended up getting my bachelor's in mathematics. (There were other factors involved there as well though.)
09:24:12 <centril> KernelBloomer: there's always http://learnyouahaskell.com/chapters
09:24:21 <KernelBloomer> oh centril how are you
09:24:31 <electrocat> "I don't blame him, I'd be this angry too if I had to write javascript all day too" this is gold :D
09:24:37 <centril> KernelBloomer: good thank you, and you?
09:24:39 <KernelBloomer> I got the book of graham, its an amazing book. thanks for recommendation centril
09:24:49 <centril> :)
09:24:57 <byorgey> KernelBloomer: https://github.com/bitemyapp/learnhaskell/blob/master/README.md
09:25:01 <Taneb> KernelBloomer: Programming in Haskell? That's a great book, I've got a signed copy
09:25:32 <KernelBloomer> Taneb, yup that one
09:27:02 <byorgey> agreed re: the Hutton book.  I am not such a fan of LYAH, I think it introduces things in an unhelpful order.  Though it does have cute pictures.
09:27:30 <Taneb> LYAH was how I learnt originally, followed by a long time browsing the Haskell wiki and trying random stuff out
09:28:53 <Taneb> But I think if I was learning now I'd use Programming in Haskell or the Haskell book
09:30:05 <Taneb> (probably the former because I actually have a copy)
09:32:31 <KernelBloomer> anyone using archlinux here? should I install stack package from main repo or AUR?
09:34:02 <electrocat> KernelBloomer: i suggest AUR
09:35:40 <dyl> There should be an arch package repository specifically for "gold" releases (stable, LTS)
09:35:40 <KernelBloomer> which package
09:35:42 <dyl> Call it "AuR"
09:35:52 <KernelBloomer> static or ...
09:35:53 <electrocat> KernelBloomer: stack-static
09:35:53 <KernelBloomer> bin
09:36:07 <KernelBloomer> electrocat, why not static from main repo? just curious
09:36:47 <electrocat> is there a static in the main repo these days? o.O
09:36:54 <electrocat> haven't used arch in a while
09:37:28 <electrocat> i only see the 'stack' package, which clearly isn't static
09:40:53 <KernelBloomer> electrocat, are you using windows now?
09:41:04 <electrocat> lol
09:41:08 <electrocat> no, gentoo
09:41:49 <KernelBloomer> why gentoo over arch lol
09:41:58 <KernelBloomer> its more maintenance, isnt it
09:42:23 <electrocat> depends on what you want from your operating system
09:42:35 <KernelBloomer> is it worth the switch for you
09:42:36 <glguy> Linux distro chat in general is better for #haskell-offtopic
09:42:41 <KernelBloomer> yea sorry
09:42:57 <KernelBloomer> electrocat, please come offtopic. need to ask you
09:43:01 <electrocat> ok :p
09:53:17 <EvanR> noooo
09:53:21 <EvanR> Perhaps you meant ‚ÄòM.!‚Äô (imported from Data.Map)
09:53:30 <EvanR> parse error on input ‚ÄòM.!‚Äô
09:58:15 <EvanR> its like talking to a computer
09:59:07 * Clint shudders.
10:02:34 * hackage testing-feat 1.0.1.0 - Functional Enumeration of Algebraic Types  http://hackage.haskell.org/package/testing-feat-1.0.1.0 (JonasDuregard)
10:06:56 <Ariakenom> ghci is complaining at my "set = S.fromList". ambiguous type variable for the element type. why?
10:07:36 <mniip> Ariakenom, paste the exact error message?
10:07:56 <glguy> If that's in a file then it's due to the monomorphism restriction
10:08:14 <glguy> You can either add a type signature, or add a function parameter: set x = Set.fromList x
10:08:36 <glguy> https://www.haskell.org/onlinereport/decls.html#sect4.5.5
10:10:35 <Ariakenom> yes glguy thanks
10:17:25 <Ariakenom> Adding the NoMonomorphismRestriction incantation to the file should fix it?
10:18:18 <glguy> Yes, but you shouldn't do that
10:18:45 <glguy> the monomorphism restriction is a good thing eliminating surprise inefficiencies
10:20:23 <Ariakenom> I read that but wasn't something I am concerned with
10:20:31 <Ariakenom> can't get it to work though
10:25:17 <Ariakenom> So I'll reluctantly do the right thing
10:27:35 <Ariakenom> is the english alphabet :: String in some module?
10:28:09 <athan> Ariakenom: there's Data.Char.isAlpha
10:28:10 <glguy> No, but you can make the part you need:
10:28:16 <glguy> > ['a'..'z']
10:28:19 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
10:29:54 <mniip> > filter isAlpha $ enumFromTo minBound maxBound
10:29:56 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
10:32:57 <johnw> I don't remember \170\181\186 from my kindergarten class
10:33:09 <johnw> must have missed that day
10:33:17 <Ariakenom> glguy: thanks again
10:35:04 <wz1000> TIL unicode has egyptian hieroglyphs. and my terminal can render them. ìÑÅìÑÇìÑÉìÑÑìÑÖ
10:35:34 * hackage data-filter 0.1.0.0 - Utilities for filtering  http://hackage.haskell.org/package/data-filter-0.1.0.0 (boonami)
10:37:09 <exarkun> wz1000: TIL my terminal can't
10:37:47 <byorgey> exarkun: it's probably not your terminal's fault. Maybe you need to install some more fonts.
10:38:33 <Ariakenom> johnw: I take it you weren't raised in greece then
10:38:48 <johnw> he was asking for "english alphabet"
10:41:32 <EvanR> > text 3\19...
10:41:35 <lambdabot>  <hint>:1:7: error: parse error on input ‚Äò\‚Äô
10:41:36 <EvanR> dammit
10:41:51 <EvanR> text "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193"
10:41:56 <EvanR> > text "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193"
10:41:58 <lambdabot>  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz¬™¬µ¬∫√Ä√Å
10:42:05 <Ariakenom> johnw: i was.
10:42:07 <EvanR> looks greek to me
10:42:08 <Ariakenom> indeed
10:47:11 <byorgey> > length (filter isAlpha [minBound .. maxBound])
10:47:14 <lambdabot>  102725
10:50:14 <EvanR> > isAlpha 'ÂõΩ'
10:50:16 <lambdabot>  True
10:50:20 <EvanR> that explains that
10:50:41 <EvanR> if the "alpha" designator is wildly culturally inappropriate
10:51:11 <Ariakenom> > maxBound :: Char
10:51:13 <lambdabot>  '\1114111'
10:52:05 <johnw> in all fairness, "alpha" does come from there
10:52:25 <EvanR> huh
10:53:03 <EvanR> the word alpha comes from china ? O_o
10:54:16 <johnw> greek!
10:55:22 <EvanR> i imagine most of the 102725 alpha chars are east asian
10:55:34 <EvanR> in 4018 they will be wondering what we were smoking
10:56:14 <mniip> > length (filter isDigit [minBound .. maxBound])
10:56:16 <lambdabot>  10
10:56:24 <EvanR> hahaha
10:56:26 <mniip> that was anticlimactic
10:57:29 <EvanR> there are 10 kinds of digits in the world
10:57:32 <wz1000> > text $ putStrLn $ filter isAlpha $ enumFromTo 'ìÄÄ' 'ìêÆ'
10:57:34 <lambdabot>  error:
10:57:34 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòIO ()‚Äô with ‚Äò[Char]‚Äô
10:57:34 <lambdabot>        Expected type: String
10:57:42 <wz1000> > text $ filter isAlpha $ enumFromTo 'ìÄÄ' 'ìêÆ'
10:57:44 <lambdabot>  ìÄÄìÄÅìÄÇìÄÉìÄÑìÄÖìÄÜìÄáìÄàìÄâìÄäìÄãìÄåìÄçìÄéìÄèìÄêìÄëìÄíìÄììÄîìÄïìÄñìÄóìÄòìÄôìÄöìÄõìÄúìÄùìÄûìÄüìÄ†ìÄ°ìÄ¢ìÄ£ìÄ§ìÄ•ìÄ¶ìÄßìÄ®ìÄ©ìÄ™ìÄ´ìÄ¨ìÄ≠ìÄÆìÄØìÄ∞ì
10:57:45 <lambdabot> Ä±ìÄ≤ìÄ≥ìÄ¥ìÄµìÄ∂ìÄ∑ìÄ∏ìÄπìÄ∫ìÄªìÄºìÄΩìÄæìÄøìÅÄìÅÅìÅÇìÅÉìÅÑìÅÖìÅÜìÅáìÅàìÅâìÅäìÅã...
10:57:52 <EvanR> there are also 10 kinds of bits
10:58:28 <EvanR> looks like a bunch of diamonds
10:58:45 <wz1000> it is supposed to be the unicode hieroglphics block
10:58:54 <wz1000> > text $ enumFromTo 'ìÄÄ' 'ìêÆ'
10:58:56 <lambdabot>  ìÄÄìÄÅìÄÇìÄÉìÄÑìÄÖìÄÜìÄáìÄàìÄâìÄäìÄãìÄåìÄçìÄéìÄèìÄêìÄëìÄíìÄììÄîìÄïìÄñìÄóìÄòìÄôìÄöìÄõìÄúìÄùìÄûìÄüìÄ†ìÄ°ìÄ¢ìÄ£ìÄ§ìÄ•ìÄ¶ìÄßìÄ®ìÄ©ìÄ™ìÄ´ìÄ¨ìÄ≠ìÄÆìÄØìÄ∞ì
10:58:57 <lambdabot> Ä±ìÄ≤ìÄ≥ìÄ¥ìÄµìÄ∂ìÄ∑ìÄ∏ìÄπìÄ∫ìÄªìÄºìÄΩìÄæìÄøìÅÄìÅÅìÅÇìÅÉìÅÑìÅÖìÅÜìÅáìÅàìÅâìÅäìÅã...
10:59:12 <wz1000> lambdabot is screwing up
10:59:22 <KernelBloomer> l0000l
10:59:26 <EvanR> https://www.reddit.com/r/ProgrammerHumor/comments/7gztuf/%F0%93%82%80%F0%93%81%9F%F0%93%8C%8Dhs/ (lol hieroglyphs in the url)
10:59:43 <EvanR> ìÇÄìÅüìåç.hs
11:00:13 <wz1000> reminds me of "those aren't angle brackets"
11:00:58 <wz1000> "they're actually characters from the australian aborignal block"
11:03:11 <wz1000> https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/dcsgk7n/
11:03:22 <wz1000> *canadian
11:07:29 <`Guest00000> how to define instances for "type family Map (x :: (Int, Int)) :: Cell", where "data Cell = X | Y | Z" ?
11:08:19 * `Guest00000 rolls eyes at "expected kind (Int, Int), but (0, 0) has kind *"
11:09:31 <`Guest00000> how to specify a promoted Int at type level?
11:10:07 <`Guest00000> and (,)
11:10:10 <hexagoxel> does '(0, 0) work?
11:10:32 <wz1000> do you have DataKinds enabled?
11:10:39 <`Guest00000> nice
11:10:52 <`Guest00000> hexagoxel: it shows a different error now, it seems this worked
11:11:09 <`Guest00000> wz1000: of course
11:15:04 * hackage pure-zlib 0.6.3 - A Haskell-only implementation of zlib / DEFLATE  http://hackage.haskell.org/package/pure-zlib-0.6.3 (AdamWick)
11:17:32 <subfactorial> got a problem with KnownNat constraints.  Can someone check out https://lpaste.net/4592523420540862464 I'm trying to express the sum of two KnownNats being greater than a constant but not getting the results I'm expecting
11:19:04 <`Guest00000> can an equation/case for a type family "shadow" another equation/case just like function definitions?
11:19:18 <subfactorial> that is to say: what I want to do doesn't typecheck
11:20:03 <crestfallen> little confused about why perms doesn't terminate here if I run say, > perms [2,3]      https://gist.github.com/varreli/13eb5adcddc52ae87847156389b0f5e1
11:20:24 <crestfallen> read: permutations
11:21:26 <wz1000> subfactorial: you're options are using a typechecker plugin or using unsafeCoerce (Refl :: (i+f) >=2)
11:21:40 <wz1000> see https://github.com/wz1000/HMat/blob/master/src/Proofs.hs#L15
11:22:57 <wz1000> or https://hackage.haskell.org/package/typelits-witnesses
11:23:59 <subfactorial> wz1000: Thanks.  I'll check those out.  All this type level manipulation is still pretty deep magic to me
11:24:36 <awesomeaniruddh> Sooo, I want a function that does something similar to "iterate"
11:25:02 <awesomeaniruddh> I want the first iteration to drop 0 items from a list, the second iteration to drop 2, the third to drop 4 and so on
11:25:45 <`Guest00000> awesomeaniruddh: iterate (drop 2 .) id
11:26:15 <`Guest00000> "elegant", but not efficient
11:26:42 <awesomeaniruddh> `Guest00000: are you sure there isn't a syntax error there?
11:27:00 <`Guest00000> yes
11:27:04 <crestfallen> it has a base case perms [[]] = []  so I can't see why there isn't termination
11:27:18 <`Guest00000> it's a section of (.)
11:27:43 <awesomeaniruddh> `Guest00000: I'm not sure how to call that :/
11:27:46 <`Guest00000> > zipWith ($) (iterate (drop 2 .) id) "Hello World"
11:27:49 <lambdabot>  error:
11:27:49 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòChar‚Äô with ‚Äò[a]‚Äô
11:27:49 <lambdabot>        Expected type: [[a]]
11:28:06 <`Guest00000> > ($ "Hello World") <$> (iterate (drop 2 .) id)
11:28:08 <lambdabot>  ["Hello World","llo World","o World","World","rld","d","","","","","","","",...
11:29:46 <mniip> :t iterate (drop 2)
11:29:51 <lambdabot> [a] -> [[a]]
11:29:53 <mniip> why not this
11:30:25 <johnw> > takeWhile (not . null) $ zipWith drop [0,2..] (cycle ["Hello World"])
11:30:27 <lambdabot>  ["Hello World","llo World","o World","World","rld","d"]
11:30:48 <crestfallen> also why people dislike using list comprehensions (see two editions of choices    https://gist.github.com/varreli/13eb5adcddc52ae87847156389b0f5e1
11:31:33 <johnw> i don't dislike them, I just think in terms of composition first
11:32:07 <crestfallen> johnw, really cool thanks I've heard varying degrees of dislike
11:32:34 <johnw> I usually have to remind myself, "Oh yeah, this would be really simple and compact to say as a list comprehension"
11:32:55 <crestfallen> but anything that is composed can be expressed in a list comprehension and visa versa?
11:33:32 <johnw> if you think of a list comprehension as sugar for the list monad, then the Wadler paper shows the connection
11:33:47 <johnw> they aren't really separate constructions
11:34:21 <awesomeaniruddh> Also, is there a nice way of unwrapping Just's from a list of Justs?
11:34:27 <johnw> catMaybes
11:34:59 <crestfallen> that's interesting johnw also plenty over my head
11:35:18 <johnw> crestfallen: just consider me as confirming your intuition then :)
11:35:32 <crestfallen> good call much appreciated
11:35:45 <`Guest00000> hmmmm
11:36:00 <crestfallen> but johnw ..
11:36:07 <`Guest00000> sequence multiplies/binds elements
11:36:20 <`Guest00000> but can there be a msum-like sequence?
11:36:35 <crestfallen> my initial question re: that paste is why perms won't terminate if you run it alone such > perms [3,4]
11:37:23 <crestfallen> since it has a base case
11:37:37 <crestfallen> or is that a base case...
11:37:54 <`Guest00000> simultaneously  [Just 5, Nothing, Just 6, Nothing, Just 7] === Just [5, 6, 7]
11:38:03 <johnw> add tracing
11:38:34 <johnw> > Just (catMaybes [Just 5, Nothing, Just 6, Nothing, Just 7])
11:38:36 <lambdabot>  Just [5,6,7]
11:39:17 <`Guest00000> noo, that's cheating, i meant that as a general function
11:39:26 <crestfallen> add tracing is advice to me johnw ?
11:39:33 <johnw> crestfallen: yes, Debug.Trace
11:40:04 <`Guest00000> mplus can't do anything to "wrapped values" of a monad
11:40:11 <crestfallen> I never no where to add it or how. it seems to always be different
11:40:13 <`Guest00000> but what if it could mappend them
11:40:21 <crestfallen> know*
11:40:23 <johnw> `Guest00000: so, LogitT Maybe would do the trick
11:40:48 <johnw> > observeAllT $ select [pure 5, mzero, pure 6, mzero, pure 7]
11:40:50 <lambdabot>  error:
11:40:50 <lambdabot>      Variable not in scope: observeAllT :: t0 -> terror:
11:40:50 <lambdabot>      Variable not in scope: select :: [f0 Integer] -> t0
11:40:55 <johnw> where select = msum . map pure
11:41:08 <johnw> oh, sorry, not select there
11:41:12 <johnw> just msum
11:41:27 <johnw> but LogicT isn't in scope for lambdabot
11:41:40 <johnw> anyway, if you simply use MonadPlus
11:41:55 <johnw> then most of the major streaming library can be chosen as the monad, as you'll get a "stream" of all the non-mzero results
11:42:17 <johnw> `Guest00000: see http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html
11:42:36 <johnw> where LogicT is just one such choice of MonadPlus
11:43:25 <awesomeaniruddh> https://pastebin.com/raw/RFiUi5nw
11:43:30 <awesomeaniruddh> http://www.cis.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
11:43:35 <awesomeaniruddh> ^ That's my solution to exercise 1 above
11:43:38 <awesomeaniruddh> Any way to make it shorter?
11:44:04 <johnw> you can use listToMaybe
11:44:07 <johnw> instead of writing 'sh'
11:45:32 <crestfallen> so far I have Debug.Trace at the top level johnw
11:45:44 <johnw> now use trace "got here" (....)
11:45:56 <johnw> and put lots of those (with more descriptive text) throughout your code
11:46:09 <johnw> this will let you watch the evaluation, basically
11:46:23 <johnw> though, because of laziness, you'll be watching in the order of demand, not the order of construction of thunks
11:46:38 <johnw> (which takes getting used to)
11:46:41 <benzrf> i wanna write a template haskell widget that automatically generates wrapping cases for extracting necessary instances from (:-) values
11:46:59 <benzrf> is there any way i can probe a quoted argument to see what constraints itll need :\
11:47:03 <awesomeaniruddh> Any other tips?
11:47:52 <johnw> awesomeaniruddh: skips+e feels like it could be done with inits instead
11:48:01 <johnw> or tails
11:48:55 <johnw> and monad-loops contains a whileJust function
11:48:58 <awesomeaniruddh> I'm not sure, they're both quite similar to what I want
11:49:34 <johnw> i have a sense that a list comprehension + tails would make what you're doing here much clearer
11:49:46 <johnw> i can't tell just from reading what the intention is
11:51:34 * hackage katip 0.5.5.0 - A structured logging framework.  http://hackage.haskell.org/package/katip-0.5.5.0 (MichaelXavier)
11:53:04 <EvanR> "kat IP"? "kaytip"? "Kati P"?
11:53:13 <johnw> K atip!
11:55:52 <crestfallen> johnw trace is not showing as a keyword . still have no clue where I put trace phrases ?
11:56:02 <johnw> import Debug.Trace
11:56:07 <johnw> later, trace STRING EXPR
11:56:44 <johnw> foo x = trace ("foo:x = " ++ show) (... what you were doing before ...)
11:56:53 <johnw> show x, I meant
11:59:40 <crestfallen> johnw working.. thanks kindly
12:02:00 <EvanR> cool msg x = trace (msg ++ ": " ++ show x) x
12:02:02 <EvanR> sometimes works
12:03:56 <Ariakenom> Any nice way to change a list into groups of 3 [a]->[[a]] ?
12:04:10 <EvanR> > chunksOf 3 [0..]
12:04:11 <johnw> in the 'split' package there is
12:04:12 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,2...
12:04:24 <EvanR> > chunksOf 3 [0..3]
12:04:26 <lambdabot>  [[0,1,2],[3]]
12:04:31 <johnw> that's where chunksOf is defined
12:04:42 <EvanR> if that were in prelude
12:04:45 <EvanR> omg
12:05:08 <johnw> i think it's just that no one has ever created a pull request to put that function in Data.List
12:05:19 <EvanR> haskell extension... -XUsable
12:06:00 <Ariakenom> no packages
12:06:41 <EvanR> in the next programming language after haskell, packages will contain 1 function each
12:07:08 <crestfallen> i.e. I was working on it not that it was working .. :)
12:07:44 <Ariakenom> can't install on target machine
12:08:41 <crestfallen> this is what I did. still don't get it though it does terminate. how would you change this johnw :   https://gist.github.com/varreli/13eb5adcddc52ae87847156389b0f5e1
12:09:08 <johnw> add tracing within the expression, not just at the end
12:09:17 <johnw> also, you need to parenthize the expression
12:09:25 <johnw> otherwise, you're just tracing the evaluation of "concat" itself
12:09:52 <crestfallen> ok trying that...
12:09:59 <johnw> add it everywhere
12:10:03 <johnw> that's what I would do
12:10:15 <crestfallen> hmm
12:15:40 <crestfallen> johnw sorry very confused. why does trace allow the prog to terminate and give a result?
12:16:00 <johnw> hmm... that's interesting
12:16:24 <johnw> i don't know, I'm only paying fractional attention here
12:16:49 <EvanR> % trace "hmm" (2 + 2)
12:16:50 <yahb> EvanR: hmm; 4
12:16:50 <kittykitty> anyone know anything about yesod? Their channel seems to not be very active
12:17:09 <EvanR> % trace (error "fruitcakes") (2 + 2)
12:17:09 <yahb> EvanR: *** Exception: fruitcakes; CallStack (from HasCallStack):; error, called at <interactive>:18:8 in interactive:Ghci8
12:18:02 <crestfallen> johnw would you mind taking a ny minute and editing that the way you would do it? https://gist.github.com/varreli/13eb5adcddc52ae87847156389b0f5e1
12:18:30 <johnw> sorry, crestfallen, I'm up against a deadline here, and so probably leave IRC altogether rather than tease you. Hopefully someone else can help.
12:18:45 <crestfallen> excellent thanks johnw
12:22:49 <Ariakenom> can rewrite rules or similar change separate div and mod to divmod? or take and drop?
12:26:13 <Ariakenom> I remembered where some of the annoying Data/Control prefixes went. woo
12:26:33 <EvanR> what is the separate div and mod pattern
12:33:06 <Ariakenom> EvanR: what do you mean?
12:33:29 <ph88> hey guys, i created this setup-info https://bpaste.net/show/8549ae3dcf67 how do i specify a ghc version with ghc-variant now?  https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-variant
12:33:30 <EvanR> what does that look like
12:33:54 <Ariakenom> I was wondering if you could get the compiler to rewrite d=div x and m=mod x to (d,m)=divmod x
12:34:10 <EvanR> "d=div x and m=mod x" ? :)
12:34:41 <EvanR> if it looks more like (q,r) = (a div b, a mod b) then now i think were getting somewhere
12:35:00 <EvanR> the rhs is equal to a divMod b
12:36:22 <ph88> oh seems this flag is better perhaps
12:37:38 <shapr> Is there already a Haskell library for doing FPGA place-and-route ?
12:45:10 <ph88> what happened to ghc 8.1 ?
12:46:07 <davean> ph88: what do you mean?
12:46:13 <davean> ph88: 8.1 isn't a thing
12:47:14 * davean is confused
12:47:30 <davean> 1 is an odd number
12:48:56 <ph88> davean, why shouldn't there be an odd number ?
12:49:05 <ph88> it's one higher than 0
12:49:21 <davean> Yes, theres a stnadard convention about odd numbers being developement sequences
12:49:29 <davean> not just for GHC, its a very traditional thing
12:49:37 <davean> odds don't exist, they're stand ins
12:49:50 <davean> That even use to be the standard with Linux
12:50:12 <ph88> never seen
12:50:58 <davean> en.wikipedia.org/wiki/Software_versioning#Odd-numbered_versions_for_development_releasesen.wikipedia.org/wiki/Software_versioning#Odd-numbered_versions_for_development_releases
12:51:02 <davean> en.wikipedia.org/wiki/Software_versioning#Odd-numbered_versions_for_development_releases
12:51:31 <tdammers> everyone used to do it
12:51:31 <davean> Its pretty standard for long-release-cycle software
12:51:49 <davean> (and linux dropped it when they speed up the release cycle for reference)
12:52:08 <tdammers> and then things happened, and now we have sixty different standards for version numbers, none of them work, and none of them mean anything useful anymore
12:53:50 <davean> Its not uncommon in the modern era either
13:08:44 <pdxleif> Got a weird error. Given the type sig "Device -> ByteString -> IO Int", it tells me "Not in scope: type constructor or class ‚ÄòByteString‚Äô"
13:09:43 <pdxleif> Oh - I guess it's a type constructor of zero arguments.
13:09:56 <Adluc> shapr: how do you imagine that place-and-route?
13:10:00 <pdxleif> I was used to just calling them "types".
13:11:39 <noan> is it possible for my to elevate the way the haskell compiler treats non-comprehensive functions?
13:11:50 <noan> I would like a complete compile failure in such cases
13:13:11 <noan> ah, ghc-options in cabal
13:14:25 <crysikrend> hey there! So I think its time to start looking for space leaks in my program. I get around 10k fps when I render one guy, but I get around 8k when I render 10 of them. I want to know if my code is inefficient and if there's anything I can do, you know? Are there any tools such as valgrind for haskell?
13:15:01 <noan> -Wall -Werror <3
13:16:16 <davean> noan: non-comprehensive?
13:17:27 <noan> as in incomplete. so like foo True = 5, no definition provided for foo False
13:17:34 <davean> non-total
13:17:47 <davean> and, its impossible tell that something is non-total or total in the non-trivial case
13:17:56 <noan> the runtime error used the term comprehensive so I actually backspaced the word non-total and said that instead
13:17:57 <noan> :3
13:18:02 <davean> thats the halting problem perforce
13:18:18 <noan> I mean in the trivial cases
13:18:25 <noan> specifically with simple ADTs
13:19:04 <davean> case The exhaustiveness checker
13:19:11 <davean> The exhaustiveness checker
13:19:11 <noan> I don't expect a solution to the halting problem, but I do like compilers to tell me I'm being stupid
13:19:35 <davean> Yah, they're so different I don't even think of them as related :)
13:20:21 <noan> but yeah, -Wall and -Werror should give me sufficient wrist slapping, right?
13:20:39 <davean> yep
13:20:48 <noan> perfect
13:20:49 <davean> you don't even need -Wall, tohugh its a good idea
13:20:59 <noan> I always get puzzled why this is not the default for langauges.... -_-
13:21:30 <davean> Its not even -Wall
13:21:37 <davean> I should say -Wall isn't even -Wall
13:21:50 <davean> Theres a lot more warnings then in there :)
13:22:18 <noan> Where can I go like a pokemaster to catch them all?
13:22:35 <davean> The GHC manual?
13:22:52 <noan> lets hope it's written in a non-eyebleeding way :3
13:23:29 <davean> downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#warnings
13:24:04 <davean> noan: for example -Wcompat isn't in -Wall (and you probably don't want it to be)
13:24:53 <davean> noan: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#options-sanity specificly lists some of the tihngs not in -Wall
13:25:20 <noan> <3
13:25:28 <davean> If you're a masochist, use -Weverything
13:25:42 <davean> I'm not sure you CAN be -Weverything clean though in some cases
13:25:47 <hvr> davean: well, by -Wcompat not being in -Wall, almost nobody pays attention to it unfortunately
13:25:51 <davean> I think there are cases you have to pick between warnings
13:25:58 <davean> hvr: I do!
13:26:05 <hvr> davean: hence "almost" :)
13:26:14 <noan> -Weverything
13:26:16 <noan> YOLO
13:26:49 <davean> hvr: I'm almost all daveans, the rest don't program Haskell as far as I know.
13:27:30 <davean> noan: if you can't be -Wwhatever clean, you might learn to ignore warnings and that tends to be a bad road to go down ... just a word of -Warning
13:27:56 <nsnc> -What?
13:28:12 <noan> oh, I turned on -Weverything and my code was clean.
13:28:13 <noan> NICE
13:28:29 <nsnc> -Wcorrect
13:28:51 <nsnc> warns if your code is correct
13:28:56 <noan> :3
13:29:30 <davean> noan: if you're code is -Weverything clean, maybe you need more interesting code ;)
13:30:00 <noan> davean, maybe. it's a very new project.
13:30:35 <davean> noan: what are you working on?
13:30:37 <Ariakenom> games in reflex, good idea?
13:30:58 <noan> davean, game thing in helm
13:31:02 <davean> Ariakenom: Maybe
13:31:17 <Ariakenom> pong? multiplayer?
13:33:24 <crysikrend> Ariakenom: I'm currently making a game in reflex, beginner and in the starting stages, but so far its been fun. I need to optimise and look for spaceleaks before I see if this is worth it or not
13:33:31 <crysikrend> but look into reflex-sdl for bindings :)
13:33:43 <davean> Ariakenom: It should be fine for that
13:34:01 <glittershark> crysikrend: run with `+RTS -p -h`, look at the profile output for cost centres and the heap output for space leaks
13:34:03 <davean> Ariakenom: I ran into performance issues using GHCJS around 20k tiles in a tile based game without a whole lot of changes happening
13:34:32 <davean> I've never had a space leak issue in reflex, but I also probably know more than average about how to work with reflex (though far from an experct)
13:35:33 <Gurkenglas> https://pastebin.com/iWh8dCz1 :DDD
13:36:07 <davean> lol stack
13:36:23 <albeit> I have an application that sends and receives messages, and the messages it can receive are defined in a very large data type. All the types that are in the message also need to be defined, so I have basically one giant Types.hs file. Is there any way to fix this?
13:36:45 <crysikrend> glittershark: Sorry, I'm using stack so I'm not sure how to run those commands with it? >< Is it --ghc-options?
13:36:47 <albeit> Like for individual modules to be able to define their own messages?
13:37:01 <glittershark> http://bahr.io/pubs/files/bahr11wgp-paper.pdf lol
13:37:14 <davean> albeit: they certainly don't have to be in the same module
13:37:19 <glittershark> crysikrend: `stack build --profile`, then pass the above flags to the exe itself
13:37:47 <crysikrend> glittershark: Is that when I do stack exec?
13:38:05 <glittershark> yeah `stack exec -- my-program +RTS -h -p
13:38:19 <crysikrend> thanks! Will let you know when I do it
13:38:22 <glittershark> every exe built with GHC supports the special `+RTS` flag for runtime options
13:38:27 <glittershark> well, you can turn it off
13:38:42 <glittershark> or maybe it's off by default. but either way stack enables it
13:38:51 <Gurkenglas> https://lpaste.net/6865173088540033024 ? :(
13:38:54 <albeit> davean: But regardless, if I make a change to a module it imports, I still need to recompile the file that has "data Message = ..." in it, no?
13:39:17 <davean> albeit: sure, so?
13:41:23 <albeit> Just feels very tightly coupled. A module can't make their own message type without everything having to include it as well globally
13:41:29 <Gurkenglas> https://lpaste.net/259694707926368256 how do I tell it to disregard those upper bounds?
13:41:49 <davean> albeit: so don't export a giant sum
13:41:54 <davean> why does the giant sum exist anyway?
13:42:01 <davean> Why aren't they just decoding their specific type of message?
13:42:57 <albeit> I have no good reasons ;). Trying to figure out how to make it better
13:43:27 <albeit> So each modules declares their message type, then some core network code tries to decode messages into each of the modules types, and passes it that module?
13:43:37 <albeit> *passes it to that
13:43:38 <davean> albeit: don't do anything without a reason then? :-p
13:43:40 <crysikrend> glittershark: https://gist.github.com/Crysikrend/4039d0cc85582a21d34048d449994bf6
13:43:55 <crysikrend> it doesn't look like there's anything on there that's my function, its all SDL?
13:44:21 <crysikrend> byebye haha
13:52:13 <pindab0ter> So in pattern matching `[x]` and `x:[]` are the same. The latter can be read as "take the head of the list, after which you are left with an empty list". This seems to make sense. How can the first pattern be read?
13:54:12 <glguy> The same way
13:55:41 <albeit> davean: Is a better idea to have module define its own message type, and have each module try to parse (and process) new messages until one succeeds?
13:57:06 <pindab0ter> glguy: No, you're not taking the head of a list in the first definition. I think I might be overthinking it and it could just be read as "a list that has exactly one element which we will call x"
13:57:38 <biglambda> Hi, I‚Äôm attempting to port a project to windows and we get this strange error when loading a from the cmd prompt: https://pasteboard.co/HlEc11o.png
13:57:50 <glguy> pindab0ter: They both match in exactly the same way, you can use both descriptions for each
13:58:25 <biglambda> It works fine from msys2 but unfortunately the profiling tool we want to use has the same error as cmd.
13:58:47 <pindab0ter> glguy: What about "[x]" indicates taking an element? I get that the effects of the patterns are the same, but their phrasing is different, no?
13:59:52 <glguy> pindab0ter: You can describe them however you like, there's no reason to think of the two patterns differently
14:00:19 <Gurkenglas> Is it just me or should stack be printing more here? https://lpaste.net/8774948361338880000
14:00:50 <davean> albeit: either the dispatch is tightly coupled int othe message options or it isn't?
14:00:59 <pindab0ter> glguy: I disagree with you there. When you're reading code you have to make sense of what it's saying. I think I got it though.
14:00:59 <davean> albeit: like you can't have it be tightly coupled but not
14:01:24 <davean> albeit: you seem to be wanting a contradiction
14:01:41 <Gurkenglas> How do I "set allow-newer:true" for a script? https://lpaste.net/6594864769100939264
14:01:49 <davean> albeit: OTOH, most protocols tag messages
14:02:11 <davean> albeit: and theres not just 2 options, theres a pile of ways one can do the dispatch
14:02:22 <davean> but they'll all directly reflect at least how tightly coupled they are
14:03:16 <awesomeaniruddh> https://lpaste.net/7339000207121580032
14:03:32 <awesomeaniruddh>  
14:03:39 <Gurkenglas> What is "stack test.hs" desugared to? So I can add --package
14:04:02 <Gurkenglas> awesomeaniruddh, asking for review?
14:05:02 <davean> they left
14:06:06 <int-e> Gurkenglas: they were here earlier... they're working on http://www.cis.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
14:07:18 <davean> "Type signatures don't count towards the length of your solution"
14:07:22 <davean> Well ... thats easy
14:08:11 <int-e> I wondered how ' ' is counted :)
14:08:37 <gywos> Hello, Could someone enlighten me by proving "getConst . traverse (Const . f) = foldMap f" ?
14:10:30 <glguy> gywos: That's easy, it's documented in the class that that has to be the case: In the Foldable instance, foldMap should be equivalent to traversal with a constant applicative functor (foldMapDefault).
14:11:05 <pdxleif> @hoogle IO a -> IO (Chan a)
14:11:06 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
14:11:06 <lambdabot> Control.Concurrent.FiniteChan dupChan :: Chan a -> IO (Chan a)
14:11:06 <lambdabot> UnliftIO.Chan dupChan :: Chan a -> IO (Chan a)
14:11:18 <gywos> Right..
14:11:58 <davean> gywos: its trivial to prove the givens
14:12:02 <davean> You just state them
14:12:06 <davean> end of proof
14:13:07 <biglambda> Is there an RTS option that determines what file descriptor hFlush uses?
14:13:42 <gywos> But I can't work out how, for example, "traverse (Const . Sum) [1, 2, 3]" becomes "Const (Sum 6)"
14:13:54 <glguy> biglambda: No, that's determined by hFlush's argument
14:14:24 <glguy> gywos: unfold the definition of traverse on []
14:14:50 <biglambda> I see, somehow hFlush is getting called but it doesn‚Äôt appear anywhere in my codebase.
14:15:16 <biglambda> Even if I set my main function to: putStrLn ‚Äúhello‚Äù it gets tripped.
14:15:34 <glguy> traverse (Const . Sum) [1,2,3] === (Const (Sum 1) :) <$> traverse (Const . Sum) [2,3]
14:16:25 <glguy> err
14:16:29 <gywos> <glguy> Thanks a lot. I think that should help me to work it out
14:16:36 <glguy> well, like I did but correct
14:17:34 * hackage shapes 0.1.0.0 - physics engine and other tools for 2D shapes  http://hackage.haskell.org/package/shapes-0.1.0.0 (ublubu)
14:17:59 <glguy> so it comes out first as: foldr (\x ys -> liftA2 (:) (Const (Sum x)) ys) (pure []) [1,2,3]
14:18:11 <glguy> and then work through the foldr
14:19:43 <gywos> <glguy> Cool. Thanks again.
14:20:34 * hackage shapes-math 0.1.0.0, shapes-demo 0.1.0.0 (ublubu): https://qbin.io/death-pest-e4mf
14:20:44 <davean> gywos: many IRC clients denote user named by encoding them in '<>'s, where that is just visual seperation to make reading easier.
14:22:06 <gywos> Yep, thanks. I'm pretty new to irc as well :)
14:36:12 <paraseba> I'm using pattern synonyms and COMPLETE pragmas, I'm getting "pattern match checker exceeded iterations" warning. And yet, my function has a catch all pattern at the end (foo _ _ _ = ...). Shouldn't that trivially be a complete pattern match? Why is it trying so hard?
14:36:33 <glguy> paraseba: That catch-all might be redundant
14:36:40 <paraseba> increasing max-pmcheck-iterations to ridiculous levels doesn't help
14:37:19 <paraseba> glguy: it's not, but even if I delete it, same warning
14:37:51 <glguy> paraseba: No, the reason it keeps trying hard is that it has to determine if it is redundant or nto
14:37:53 <glguy> not*
14:38:04 <paraseba> oh I see what you mean
14:38:53 <paraseba> it's weird that I have 9 cases, if I comment all but 3, things work. As soon as I enable a forth case (pretty much any one) iterations blow up and not even with 4M iterations it can resolve it
14:42:14 <paraseba> is there a way to turn off case redundancy check?
14:44:31 <glguy> paraseba: You can look through: ghc --show-options | grep pattern
14:44:53 <glguy> and turn warnings off with -Wno-something
14:46:52 <paraseba> --show-options, nice. I'll try that, thanks!
14:50:56 <paraseba> -Wno-overlapping-patterns didn't help. It gave me hope for a second though
14:58:34 * hackage expressions-z3 0.1.5 - Encode and Decode expressions from Z3 ASTs  http://hackage.haskell.org/package/expressions-z3-0.1.5 (jakubdaniel)
14:59:43 <glguy> a more ambitious name for that package might have been "package"
14:59:48 <dyl> Evil plan:
15:00:03 <dyl> Sneak into CMU, quietly alias all sml binaries to GHC.
15:00:11 <dyl> Flee country to avoid Harperite fury.
15:00:38 <dyl> Note: don‚Äôt do that.
15:03:46 <[exa]> dyl: so you're sneaking at CMU now?
15:05:17 <ph88> what's a fast http request response parser ?
15:06:19 <davean> ph88: id
15:06:20 <Cale> Is whatever's in http-conduit not fast enough?
15:06:54 <ph88> was just curious how it compare to this rust parser http://unhandledexpression.com/general/2018/05/14/nom-4-0-faster-safer-simpler-parsers.html
15:07:22 <dyl> [exa]: I used to walk over to play pool in the game room under Entropy all the time.
15:07:39 <dyl> When I was in high school.
15:07:45 <dyl> I‚Äôve also taken some summer classes there for kicks during undergrad.
15:09:30 <dyl> ph88: if you want to parse faster, you may have to sacrifice robustness.
15:09:42 <dyl> (Be liberal in what you accept, conservative in what you emit)
15:10:15 <dyl> That is, you might choose to be very strict in your parsing. But this isn‚Äôt going to matter in terms of raw speed with well formed requests.
15:10:34 <manek> Hi guys! I'm pretty sure my monadic, tail-recursive function is not optimized to a tight loop by ghc. I'm wondering when GHC could not do it. The monad is State over IO. Is looking at the core the only option to get know if my assumptions are correct here?
15:10:47 <dyl> Also: faster isn‚Äôt necessarily better, consider resource limits and such.
15:12:07 <EvanR> as i understand it, core does not show if things get compiled into a loop at that level
15:12:51 <EvanR> functions that tail call themselves may get compiled into a loop, i saw in the ghc manual the other day
15:13:40 <Cale> manek: looking at the core is probably your best bet
15:14:10 <ph88> can't find the parsing function in http-conduit :/
15:14:38 <Cale> Yeah, you won't necessarily be able to tell that it's going to be compiled to a tight loop
15:14:59 <manek> EvanR: oh, ok. So what can I do to know whats happening? Im eveluating everything 10^times. The function without recursive call takes 1ms to execute. With recursive call over 40ms, while only a single such call is made. Everything is strict and evaluated to NF. The function itself just reads few pointers. If I check for breaking the evaluation on the "next funciton iteration" it takes 60ms, so it seems that this time cames from funct
15:15:45 <manek> Cale, EvanR, why GHC could not optimize sometimes tail recursion in a monad? Is it even possible ?
15:16:03 <Cale> That question is too vague to make sense
15:16:14 <Cale> "a monad" is too broad to say anything about generally
15:16:35 <manek> Cale: Of course, I was earlier describing it a little better - Ive got a StateT over IO
15:16:44 <ph88> manek, sometimes an optimization can prevent another optimization
15:16:55 <ph88> manek, you can use perf
15:17:31 <Cale> The other thing is that tail recursion optimisation doesn't really make sense, because there's no call stack.
15:18:05 <ph88> manek, you can compile with dwarf symbols and match assembly with your function source code line
15:18:51 <manek> ph88: interesting, I have to give it a shot!
15:19:15 <ph88> manek, here you can see an example https://www.schoolofhaskell.com/user/bitonic/perf-for-low-level-profiling
15:19:20 <ph88> i didn't try this, i just read it
15:19:34 <ph88> it seems right for you
15:21:17 <pdxleif> @hoogle IO a -> IO () -> IO a
15:21:17 <lambdabot> Control.Concurrent.Async race_ :: IO a -> IO b -> IO ()
15:21:17 <lambdabot> Control.Concurrent.Async concurrently_ :: IO a -> IO b -> IO ()
15:21:17 <lambdabot> Data.TCache setConditions :: IO () -> IO () -> IO ()
15:22:03 <manek> ph88: oh this blog post is awesome, thank you so much for the link!
15:22:21 <MarcelineVQ> :t finally
15:22:22 <lambdabot> IO a -> IO b -> IO a
15:22:29 <pdxleif> @hoogle IO a -> (a -> IO ()) -> IO a
15:22:30 <lambdabot> Control.Monad.Loops forkMapM__ :: (a -> IO b) -> [a] -> IO ()
15:22:30 <lambdabot> Network.Transport.Internal asyncWhenCancelled :: forall a . (a -> IO ()) -> IO a -> IO a
15:22:30 <lambdabot> System.Console.Readline callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
15:22:38 <fishythefish> :t flip (>>)
15:22:39 <lambdabot> Monad m => m b -> m a -> m b
15:26:41 <pdxleif> @djinn Monad m => m a -> (a -> m ()) -> m a
15:26:42 <lambdabot> f a _ = a
15:26:57 <pdxleif> @hoogle Monad m => m a -> (a -> m ()) -> m a
15:26:58 <lambdabot> Data.GI.Base.Utils whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
15:26:58 <lambdabot> Language.C.Analysis.TravMonad maybeM :: (Monad m) => (Maybe a) -> (a -> m ()) -> m ()
15:26:58 <lambdabot> Control.Monad.IfElse awhen :: Monad m => Maybe a -> (a -> m ()) -> m ()
15:27:51 <glguy> pdxleif: Please use /msg for that kind of flooding
15:27:57 <pdxleif> It's do x <- a; f x; pure x.
15:28:09 <pdxleif> It just bugs me to see x <- f followed by pure x, I guess.
15:29:49 <EvanR> @pl \f x -> do x <- a; f x; pure x
15:29:49 <lambdabot> (line 1, column 18):
15:29:50 <lambdabot> unexpected ';'
15:29:50 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
15:32:53 <fishythefish> :t \a f -> a >>= liftA2 (>>) f pure
15:32:55 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a1
15:36:31 <pdxleif> fishythefish: Nice! And certainly more inscrutable than the do-notation version.
15:37:41 <EvanR> hey, if code were easy to read everybody would do it (tm)
15:39:02 <fishythefish> if you want clarity, just use the do-notation :P
15:40:03 <fishythefish> if you want to express everything concisely in terms of existing combinators, odds are you'll wind up with something inscrutable
15:41:41 <pdxleif> Like the APL implementation of Conway's game of life, e.g. "‚Üë1 ‚çµ‚à®.‚àß3 4=+/,¬Ø1 0 1‚àò.‚äñ¬Ø1 0 1‚àò.‚åΩ‚äÇ‚çµ" ?
15:41:54 <EvanR> :|
15:42:17 <EvanR> and you thought regex was bad
15:42:29 <fishythefish> cue dyl
15:42:35 <pdxleif> At least in J you don't have the crazy glyphs: ((]+.&(3&=)+)(+/@(((4&{.,(_4&{.))(>,{,~<i:1))&|.)))~
15:42:42 <pdxleif> But it's more verbose, sadly.
15:42:49 <EvanR> that looks kind of a like a bash script
15:43:16 <pdxleif> I know the "+/" part means "fold with +", aka sum.
15:45:02 <Tuplanolla> It's nice how `fmap` and `liftA2` are implicit.
16:07:34 * hackage hw-rankselect-base 0.3.2.0 - Rank-select base  http://hackage.haskell.org/package/hw-rankselect-base-0.3.2.0 (haskellworks)
16:58:04 * hackage extensible-effects-concurrent 0.1.1.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.1.1.0 (SvenHeyll)
17:48:34 <ph88> does using a higher ghc version also cause update in some packages ?
17:49:05 <ph88> i get an error that cabal needs some version of process   and  quickcheck-instances needs time package
17:50:51 <geekosaur> there are some packages that come with ghc and should relaly be kept in sync with it, yes
17:51:43 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
18:09:02 <jackdk> haskell/nix question: I have a package set up in the style of https://github.com/qfpl/sv (I'm not hacking on `sv`, but that `packagename.nix`/`default.nix`/`shell.nix` split). I've been told that calling `ghcWithHoogle` instead of `ghcWithPackages` would let me run `hoogle` and get searchable docs. how do I pass the correct environment to a `nix-sh
18:09:02 <jackdk> ell` invocation?
18:17:29 <blankhart> i have found the nixos channel more responsive on nix questions, jackdk, but there is a section on this in the nixpkgs manual (section 9.5.2.3).
18:18:59 <jackdk> okay, thanks
18:19:11 <adetokunbo> hello!
18:37:16 <lambdabot> Hello.
18:40:26 <EvanR> World.
18:40:50 <EvanR> whats this "Dial L for Lambdabot" ?
18:46:22 <ph88> wow parsec comes with ghc o_O
18:47:14 <ph88> since 8.4.1
18:47:18 <ph88> strange
18:47:21 <duncan^> parsec sounds like some illicit thing one should not consume
18:48:27 <ph88> ghc must have a dozen parsers by now
18:51:10 * hackage verifiable-expressions 0.4.0 - An intermediate language for Hoare logic style verification.  http://hackage.haskell.org/package/verifiable-expressions-0.4.0 (madgen)
18:54:36 <ph88> so ... if i keep my code the same and all my deps but upgrade ghc from 8.0.2 to 8.2.1 then compiling gets stuck at "Called arity analysis"  ..  i'm not sure what to do about this. Seems like a bad ghc regression to me
18:59:32 <benzrf> do we get KnownNat (n * m) from KnownNat n and KnownNat m
19:02:35 <ph88> benzrf, you can do calculations with typelits of thats what youre asking
19:03:10 <ph88> ?? https://hackage.haskell.org/package/ghc-typelits-natnormalise
19:03:10 <lambdabot>  https://hackage.haskell.org/package/ghc-typelits-natnormalise
19:03:17 <benzrf> well im asking specifically abt whether we get knownnat constraints
19:05:01 <ph88> i dunno
19:05:09 <benzrf> it looks like the answer is no ;A;
19:05:17 <benzrf> thats b.s.
19:14:51 <ph88> thought you wanted to do artheritmic
19:34:59 <rszibele[m]> has anyone written a haskell program with hsqml and can give some insight if it's good or not?
19:41:55 <crestfallen> hi if you run ghc stack ./executable is there a unix command to copy the output to the next cl ?
19:42:19 <crestfallen> sorry stack ghc ./executable
19:43:16 <crestfallen> or would you just manually cut and paste
19:43:23 <crestfallen> copy/paste
19:46:53 <sm> rszibele[m]: not me, but it sounded great
19:47:10 <sm> crestfallen: cl ?
19:48:52 <crestfallen> scratch that sm just a unix command that will copy the output of the prior command onto the command line
19:50:00 <sm> like cmd2 `cmd` ?
19:50:31 <sm> though I'm wondering how useful the output of stack ghc could be
19:51:09 <sm> but that's none of my business :)
19:51:27 <glguy> Kermits the best
19:52:25 <crestfallen> sm its a function that results in a long output, so I was tinkering and thought I could run a unix command that copies the output, onto the clipboard or preferably to the cursor sm
20:03:34 * hackage fortran-src 0.2.1.1 - Parser and anlyses for Fortran standards 66, 77, 90 and 95.  http://hackage.haskell.org/package/fortran-src-0.2.1.1 (madgen)
20:15:25 <woodson> is it bad to create an empty class to categorize data types together?
20:16:04 <glguy> Yeah, probably
20:20:18 <woodson> glguy: Say I have a data type
20:20:29 <glguy> I have a data type
20:21:00 <woodson> data Metadata = M1 SomeDataType1 | M2 SomeDataType2 | BadMetadata Text
20:21:24 <woodson> i do not wish to use the M1 and M2 wrapper
20:21:38 <woodson> so another option that I thought of was this approach
20:21:53 <woodson> data Metadata a = Metadata a | BadMetadata Text
20:22:54 <woodson> but the compiler doesnt know what 'a' is when using decode function from aeson package
20:23:24 <glguy> You'd have to tell it
20:23:37 <woodson> if  I were to put a constraint on a with a typeclass
20:23:50 <woodson> Can I avoid the M1 and M2 wrapper ?
20:23:54 <glguy> no
20:23:56 <woodson> or am I still SOL
20:24:26 <glguy> This new metadata type doesn't allow the same things as the old one
20:24:47 <glguy> Simple example, you can't have a [Metadata] with the new one that supports both types of metadata 1 and 2
20:25:01 <glguy> if you were to switch to this new type
20:26:21 <woodson> with the old type I am obligated to always pattern match to get the value
20:27:08 <woodson> I could use the record syntax with just one field but then I have to use different names for the field so the compiler doesnt complain
20:27:43 <woodson> M1 { unwrap1 :: SomeDataType1 } | M2 { unwrap2 :: SomeDataType2 }
20:28:04 <glguy> Using record like that is ill-advised
20:28:47 <woodson> glguy: What would be a suggested approched? The thing is that I have aeson select which type to return based on a string value
20:28:53 <woodson> when parsing the json
20:29:34 <woodson> So I am kinda simulating the selection of a type at runtime
20:29:43 <glguy> Your original definition was correct
20:32:20 <benzrf> god
20:33:01 <benzrf> Data.Data.Lens implementation details are deeply deeply horrifying
20:33:34 <woodson> glguy, so my only choice is to unwrap by pattern matching
20:34:32 <woodson> I just wish that there was a way to abstract the unwraping side of it
20:43:09 <glguy> benzrf: Don't look upon upon
21:23:01 <sssilver> hey, anyone here likes HTTPS?
21:24:13 <nsnc> http all the way
21:24:38 <sssilver> nsnc: why?
21:24:56 <Axman6> I love me some HTTPS
21:25:19 <nsnc> "Some compiles of lynx will not support it."
21:26:17 <sssilver> Axman6: high five!
21:39:09 <Axman6> sssilver: Was that just a general question about the technology?
21:39:30 <sssilver> Axman6: well
21:39:49 <sssilver> the correct answer to your question would be "yes", but the "just" part makes it interesting
21:40:26 <sssilver> so what happened is I could swear that lpaste.net was just plain HTTP as of a few days ago
21:40:37 <sssilver> and that seemed weird, annoying, and to some extent outrageous
21:40:51 <sssilver> so I wanted to test the waters and see if that's just a general Haskell community attitude towards HTTPS
21:40:56 <sssilver> or a one-off lpaste thing
21:41:01 <sssilver> but then I went there
21:41:04 <sssilver> and it seems to be HTTPS now
21:41:09 <sssilver> what gives?
21:41:30 <nsnc> It doesn't have hsts perhaps?
21:42:03 <Axman6> Warp supports HTTP/2, so it's a good option for TLS
21:42:46 <sssilver> I do believe that as a community we should support HTTPS
21:42:54 <sssilver> disregard me
21:44:14 <nsnc> try using http who needs tls
21:44:32 <Axman6>  IIRC Warp‚Äôs work on HTTP/2 lead to some canges in the standard too
21:44:53 <sssilver> nsnc: TLS is important
21:44:55 <sssilver> everyone needs it
21:45:04 <sssilver> encryption is a thing
21:45:08 <nsnc> sssilver: no it's useless
21:45:13 <sssilver> err no
21:45:16 <sssilver> it's actually useful
21:45:26 <nsnc> My passwords are encrypted anyway
21:45:33 <nsnc> And it uses extra computation
21:45:40 * sssilver squints
21:45:50 <nsnc> Squint harder
21:45:57 <sssilver> this isn't about passwords my friend
21:46:08 <Axman6> Don't feed the troll :)
21:46:09 <boj> maybe offtopic, this is
21:46:22 <nsnc> Anyway, Haskell is already unencrypted (GitHub), so https doesn't even do anything
21:46:33 <nsnc> And mitms are a hoax anyway
21:46:41 <nsnc> ^ pun
21:46:54 <sssilver> You remind me of a certain gentleman by the name of donald
21:47:03 <boj> not worth it
21:47:10 <nsnc> How so?
21:47:24 <sssilver> alright fine let's discuss haskell
21:47:24 <nsnc> I would argue that I'm more reasoned
21:47:46 <nsnc> Yeah, Haskell isn't tls or https.
21:47:56 <nsnc> So we keep to hhtp
21:48:03 <sssilver> anyone else have this problem where every time you return a function you feel weird about it?
21:48:10 <Axman6> hyper-hyper-text protocol
21:48:10 <dibblego> sssilver: No.
21:48:17 <sssilver> nsnc: I'm afraid you don't fully understand the subject matter
21:48:22 --- mode: ChanServ set +o dibblego
21:48:26 --- kick: sssilver was kicked by dibblego (No.)
21:48:31 <Axman6> ...
21:48:31 <nsnc> sssilver: I understand, you don't.
21:48:34 <nsnc> Haha
21:48:35 <nsnc> Rofl
21:48:38 <nsnc> Huh?
21:48:40 <Axman6> mate you kicked the wrong person
21:48:49 <sssilver> =/
21:48:55 --- kick: nsnc was kicked by dibblego (nsnc)
21:48:58 <dibblego> sssilver: Sorry.
21:49:02 <Axman6> heh
21:49:14 <dibblego> I didn't read the scrollback properly.
21:49:20 <nsnc> Sorry bout that sssilver.
21:49:25 <Axman6> sssilver: I take it you're somewhat new toi Haskell/FP then?
21:49:44 <sssilver> every time I return a function, I always think to myself "if this function is so great, why not just invoke it"
21:49:48 <sssilver> "if it's not so great, why return it"
21:50:09 <Axman6> double = map (*2) -- pretty handy
21:50:12 <nsnc> dibblego: do I not even get a warning?
21:50:26 <nsnc> Anyway, what was wrong with my conversation?
21:50:29 <sssilver> so let me internalize that Axman6
21:50:32 <Axman6> nsnc: there was a clear warning shot that hit sssilver in the head :P
21:50:32 <dibblego> nsnc: kicking sssilver was your warning. Stop being a dick head.
21:51:00 <sssilver> nsnc: you don't understand end to end encryption fully, it has very little to do with passwords
21:51:08 <sssilver> nsnc: plus it's offtopic at this point
21:51:56 <sssilver> Axman6: double x = x * x -- why not
21:52:05 <sssilver> I'm kinda new to fp but not really new to it
21:52:07 <sssilver> just bad at it
21:52:13 <sssilver> I mean I love my pure functions
21:52:17 <sssilver> and love my maps and reduces and filters
21:52:23 <sssilver> I even love my maybe monads
21:52:40 <sssilver> really the only thing that stands between me and enlightenment is the whole returning functions thing
21:56:04 * hackage ipcvar 0.1.1 - Simple inter-process communication through IPCVars.  http://hackage.haskell.org/package/ipcvar-0.1.1 (JohnWiegley)
22:01:34 <Axman6> sssilver: the whole returning functions thing i s fundamental
22:04:24 <sssilver> Axman6: I know, that's why I hate myself
22:04:35 <sssilver> and frequently drown my hatred in alcohol
22:04:40 <iqubic> Don't beat yourself up though.
22:04:50 --- mode: dibblego set -o dibblego
22:06:09 <Axman6> sssilver: there's an organisation called Data61 which has a really great course which contains a lot of exercises using higher order functions, maybe you could try some of that out
22:06:19 <Axman6> >_>
22:10:39 <iqubic> my favorite use of higher order functions is continuation, but I feel like that is too advanced for sssilver to look at right now.
22:11:16 <iqubic> s/continuation/contiuations/
22:18:18 <Ptival> is there a type-level operator that takes two functors, and return a functor (as if paired)?
22:18:37 <johnw> you mean, Product?
22:19:08 <bspar> what exactly is https used for?
22:19:44 <Ptival> johnw: probably, but I can't find it on hackage haha
22:19:54 <johnw> bspar: that question may be off-topic for this channel
22:20:41 <Ptival> hmm it might be in transformers
22:20:45 <Ptival> will look into it, thanks
22:21:15 <johnw> it's in base
22:21:17 <johnw> Data.Functor.Product
22:22:48 <benzrf> hey edwardk i decided that waiting for qualifiedconstraints was boring so i wrote this instead https://benzrf.com/uploads/fa3046fea4e0772b.png
22:22:50 <benzrf> : >
22:23:26 <johnw> if only AppT were called :$ ...
22:24:11 <benzrf> e.g. https://benzrf.com/uploads/1ae6f421fd7a2559.png
22:29:17 <jordenlam> does anyone know of an untyped lambda calculus term that is extensionally equal to the term \x.x ? i.e. a function that is the same as identity on all inputs
22:31:59 <jordenlam> oh and also the term should be in normal form
22:38:04 <EvanR> is that a homework question
22:38:38 <benzrf>  ok wow i made a blatant mistake in the screenshot i posted
22:38:43 <benzrf> how did i miss that
22:38:57 <benzrf> copy'd/paste'd code & forgot to change a thing ;-;
22:39:38 <EvanR> jordenlam: as a hint... the I (identity) combinator is equal to SKK
22:42:26 <benzrf> i dont think thats in normal form, EvanR
22:42:41 <benzrf> however
22:42:44 <EvanR> well put it in normal form?
22:43:49 <EvanR> Abby Normal form
22:45:28 <jordenlam> hehe it does sound like a homework question but it's not
22:46:41 <cocreature> jordenlam: just apply the identity function to the result instead of returning it directly
22:49:13 <jordenlam> EvanR: thanks for the hint, but I don't see how that works because SKK reduces to \x.x
22:49:24 <EvanR> or apply something arbitrary to const it
22:49:41 <jordenlam> cocreature: not sure what you mean
22:50:04 <cocreature> jordenlam: \x.(\x.x)x
22:50:22 <jordenlam> cocreature: there's a beta redex in that term, so it's not in normal form
22:50:34 <cocreature> oh I missed the second part of that question, sry
22:50:45 <jordenlam> cocreature: no worries
22:51:24 <jordenlam> EvanR: something arbitrary? const?
22:51:57 <benzrf> well uhhh this is worrying on /several/ levels https://benzrf.com/uploads/dbe4aa43eca0b9b3.png
22:53:12 <jordenlam> oh, i guess \y.\x.y x works, though thats beta-eta equivalent to \x.x
22:53:44 <jordenlam> or i guess i should say it has an eta redex, or something like that
22:54:16 <EvanR> how else do you define equivalence of lambdas
22:54:42 <jordenlam> was trying to think if theres an interesting normal term that is extensionally equivalent to \x.x
22:55:07 <jordenlam> and \y.\x.y x seems somewhat not interesting
22:55:49 <EvanR> the interesting lambda term paradox
22:56:57 <[exa]> jordenlam: did you consider the possibility that it's a tricky question?
22:57:59 <jordenlam> [exa]: it seems like it might be. but I swear I've seen an example of this before, but maybe I'm misremembering
22:59:04 <[exa]> jordenlam: well, okay. What's the only way to delay the computation so that your term doesn't collapse to I right away?
22:59:37 <jordenlam> [exa]: it seems like you'd have to apply the argument
23:01:10 <EvanR> if you do that, then the user can pass in whatever they want, which does wildly different things with the argument
23:01:21 <[exa]> well yes, you need to abstract a new variable and put it on the left side of application somewhere in the inner term so that you can't reduce it
23:02:08 <jordenlam> EvanR: yeah, it could do anything
23:02:48 <jordenlam> [exa]: yeah, perhaps returning an abstraction is the only way
23:06:11 <[exa]> jordenlam: in what order do you need the lambdas? (you'll certainly need one for the identity variable, and one for the thing that's going to halt the reduction)
23:07:15 <[exa]> s/lambdas/abstractions/
23:07:48 <jordenlam> [exa]: I think the first abraction needs to abstract over the "identity" variable
23:08:10 <[exa]> yes, so that the argument order is preserved
23:09:00 <jordenlam> I guess I should improve the specifics of the question
23:09:25 <[exa]> now you need to satisfy an equation that (\x.\y.  ???) a b c d ... == x y a b c d ...
23:09:36 <EvanR> whats a lambda term that doesnt normalize to \x -> x, but is the identity function anyway
23:10:33 <[exa]> (btw forgot the x y in the LHS)
23:10:33 <jordenlam> [exa]: hmmm, ok, I'll think about that
23:11:17 <[exa]> jordenlam: in fact your uninteresting solution is valid, but seeing it like this you can generate infinitely many more
23:13:21 <jordenlam> [exa]: right, so (\x.\y.x y) x y a b c d ... == x y a b c d ....
23:13:52 <jordenlam> [exa]: and also, (\x.\y.\a.x y a) x y a b c d ... == x y a b c d
23:14:02 <[exa]> yeah, uninteresting. :D
23:14:10 <jordenlam> and so on...
23:14:17 <jordenlam> hehe yeah
23:14:59 <jordenlam> [exa]: so all those solutions disappear if we define '==' module eta equality
23:15:10 <[exa]> it's certainly eta-reducible to I, yes.
23:15:42 <jordenlam> so then, the new question would be, is the following true: t is beta-eta equivalent to \x.x iff t is extensionally equivalent to \x.x
23:16:45 <[exa]> iirc the Barendregt book should clarify that on the first few pages
23:17:19 <jordenlam> [exa]: oh, good point, I should really buy that book if I'm going to be thinking about stuff like this
23:17:27 <[exa]> it's free for download somewhere
23:17:31 <[exa]> "free"
23:17:34 <jordenlam> I've been meaning to study it
23:19:12 <[exa]> jordenlam: http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf
23:19:14 <jordenlam> [exa]: thanks for the help. I'm guessing that proposition is true, I'll have to go grab that book tomorrow and double check
23:19:20 <[exa]> church-rosser theorem is probably related
23:19:44 <jordenlam> [exa]: oh nice, thanks.
23:54:49 <Ariakenom> is there a nice way to make function that puts 4 elems in a list? a->-a->a->a->[a]
23:59:34 <zincy> How do I flip a function of more than two arguments so the argument order is reversed?
23:59:36 <cocreature> Ariakenom: what‚Äôs wrong with \a b c d -> [a,b,c,d]?
