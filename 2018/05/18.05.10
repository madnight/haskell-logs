00:01:53 <jchia> jle`: Thanks. It looks like Foo3 still needs manual definition because LongName is not Name.
00:02:04 <jchia> cocreature: How do I do that?
00:02:08 <jle`> yeah; that can be handled nicely with one-liner or GHC Generics though
00:02:15 <cocreature> jchia: just use "biplate"?
00:03:06 <woodson> Hi everyone, is it possible to generate a cabal file from a stack project?
00:08:41 <jle`> woodson: what do you mean exactly by 'stack project'?
00:08:50 <jle`> a stack project should already include a cabal file, or at least a package.yaml
00:09:35 <jchia> jle`, cocreature: Anything I need to know about run-time performance costs from using Data and Typeable? I don't understand how they work under the hood.
00:10:19 <jle`> Data+Typeable i think are all basically doing runtime reflection on types and, for plated etc, checking which branches to go down at runtime
00:10:51 <jchia> Is there additional storage cost for values to support the reflection?
00:11:42 <cocreature> Typeable is relatively cheap, Data.Data does incur a non-trivial runtime cost
00:11:45 <jle`> they essentially carry around a runtime token
00:11:52 <cocreature> iirc lens also has a version based on Generics but I can’t find it
00:16:51 <woodson> jle`: Because this new thing with the package.yaml I forgot that by just building the project it will generate the cabal file.
00:17:17 <jle`> ah, you really wanted to generate a cabal file from a package.yaml, you mean?
00:17:41 <woodson> exactly
00:17:44 <jle`> did you figure out how to fix your problem?
00:17:50 <woodson> yes
00:17:58 <jle`> nice :)
00:18:09 <woodson> jle`: by the way nice blogs on dependent types
00:18:19 <woodson> very clear and precise
00:18:20 <jle`> thanks!  i should probably get on finishing those serieses haha
00:18:29 <Axman6> welcome jared-w!
00:18:33 <woodson> Yes, still waiting
00:19:39 <woodson> jle`: I still need to re-read it but I like how you are showing that you can still have your types during runtime
00:26:17 <jle`> thanks! i'm happy it was helpful :)
00:54:39 <jchia> cocreature: I played around with gmapT. I think's more concise and cleaner than what I had before, with the downside of requiring Data instance, but I haven't quantified the actual cost. The Data.Data haddock looks very abstract but I think I at least figured out how to use gmapT.
01:19:20 <AWizzArd> I am looking at this little example: https://github.com/acowley/concurrent-machines/blob/master/examples/Pipeline.hs
01:19:23 <AWizzArd> And I wonder what `await` is. The imports hint that it may come from https://hackage.haskell.org/package/concurrent-machines-0.3.1.3/docs/Data-Machine-Concurrent.html – but I don’t find it on that doc page.
01:21:12 * hackage battleplace 0.1.0.5 - Core definitions for BattlePlace.io service  http://hackage.haskell.org/package/battleplace-0.1.0.5 (quyse)
01:35:55 <geekosaur> AWizzArd, https://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-Plan.html#v:await
01:36:10 <geekosaur> you don't see it because the top line of that doc says the entire Data.Machine module is exported
01:36:22 <geekosaur> which itself reexports a bunhc of others, including Data.Machine.Plan
03:36:51 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
03:36:51 --- topic: set by geekosaur on [Sat Feb 03 00:04:44 2018]
03:36:52 <electrocat> technically you could get haskell working on there
03:37:42 <kuribas> https://www.scade.io/
03:37:54 <kuribas> electrocat: ghc on ios?
03:37:56 <electrocat> tnx to angerman
03:38:00 <electrocat> yeah
03:38:15 <kuribas> Then eta on android.  That would be cool :)
03:38:31 <electrocat> ghc works on android too
03:38:31 <shiona_> I too dislike the lack of compile time checks in clojure, but that was the only thing I came up about mobile development with functional programming
03:39:09 <kuribas> shiona_: yeah, I should have said FP with static types
03:39:37 <kuribas> I shouldn't assume they go together...
03:39:42 <electrocat> ah
03:39:44 <electrocat> http://hackage.mobilehaskell.org/
03:39:49 <electrocat> this was what i was looking for
03:41:07 <Noob> > 3
03:41:10 <lambdabot>  3
03:41:14 <Noob> ?src iso
03:41:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:41:24 <Noob> ?src ($)
03:41:24 <lambdabot> f $ x = f x
03:41:33 <Noob> > import Control.Lens.Iso
03:41:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
03:41:50 <Noob> > :m +Control.Lens.Iso
03:41:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:41:56 <jcjf> Hi clever folks! I have a data modelling question, not really specific to Haskell
03:42:05 <kuribas> is IOS VM based, like android?
03:42:15 <kuribas> or machine code?
03:42:18 <Noob> ?src Control.Lens.Iso.iso
03:42:18 <lambdabot> Source not found. You type like i drive.
03:42:19 <electrocat> ios is native i believe
03:42:27 <Noob> ?src Control.Lens.Combinators.iso
03:42:27 <lambdabot> Source not found. That's something I cannot allow to happen.
03:43:04 <kuribas> electrocat: going via the ndk seems a bit hairy.  eta might be a good solution for that
03:43:14 <jcjf> Suppose I'm given a JSON file, and I want to validate that the set of keys in some part of the JSON and the set of (string) values in another part of the JSON are the same
03:43:22 <electrocat> yeah, it's not very convenient yet, but it's possible at least
03:44:03 <jcjf> If this "set of strings" is open (I haven't predefined it ahead of time), is there a type-level representation of this constraint?
03:44:33 <kuribas> jcjf: not if you use Value
03:44:46 <kuribas> jcjf: are you translating to a ADT?
03:45:09 <jcjf> e.g. { "objects": { "obj1": "one", "obj2": "two" }, "listOfValues": ["one", "two", "two", "one"] }
03:45:55 <jcjf> Something to say that the possible values under the listOfValues key can only be {"one", "two"}, because that's all that existed under "objects"
03:46:06 <kuribas> jcjf: if they are the same, they are redundant?  Why do you need them at all?
03:47:02 <jcjf> listOfValues is in some sense a list of references to the other objects
03:47:30 <jcjf> Maybe it's something like an arrival pattern
03:48:10 <jcjf> Hmm maybe I should have done
03:48:20 <kuribas> jcjf: if you have an enum, you could do type MyType a = Map String a
03:48:28 <jcjf> { "objects": { "obj1": "one", "obj2": "two" }, "listOfValues": ["obj1", "obj2", "obj2", "obj1"] }
03:48:32 <kuribas> jcjf: then you use the type of a to reduce the number of values
03:49:21 <kuribas> jcjf: so "Map a String"
03:50:09 <kuribas> for exampe: data Objects = Obj1 | Obj2 deriving (Eq, Ord, Show) type MyType  = Map Objects String
03:50:26 <jcjf> I don't know that they're going to be specifically called "obj1" and "obj2" ahead of time - does that break everything?
03:51:03 <kuribas> jcjf: in that case you can validate them after reading in the Json, the discard listOfValues
03:51:27 <kuribas> jcjf: you can retrieve them with keys
03:51:33 <kuribas> :t keys
03:51:34 <jcjf> Right, so there's nothing I can say a priori in type land
03:51:34 <lambdabot> error:
03:51:34 <lambdabot>     • Variable not in scope: keys
03:51:34 <lambdabot>     • Perhaps you meant one of these:
03:52:10 <jcjf> Because the "enum" is defined by the provider of the data
03:53:52 <jcjf> Thanks for the help kuribas
03:54:08 <kuribas> jcjf: listOfValues looks redundant to me
03:55:02 <jcjf> It could be represented differently, but my problem is I'm dealing with a JSON-based data model defined by someone else
03:55:29 <kuribas> jcjf: I would validate the JSON, then make a haskell type of it.
03:55:45 <kuribas> jcjf: so at least the haskell code is typesafe
03:56:39 <jcjf> Makes sense. I was just wondering if the validation constraint (based on not knowing the exactly key names ahead of time) was expressible as a type
03:56:51 <kuribas> jcjf: then when you need to interface, you turn it into the JSON again.
03:56:59 <jcjf> Sounds like even if it was, it wouldn't be worth that effort
03:57:12 <kuribas> jcjf: I don't think it is possible
03:57:40 <kuribas> jcjf: perhaps with type level lists.
03:57:49 <kuribas> jcjf: but not worth the effort I think
03:58:27 <jcjf> If there isn't a simple well-known abstraction then I'll prepared to abandon that idea
03:58:41 <jcjf> The fact that nothing immediately jumps to your mind is enough for me!
03:58:49 <jcjf> Thanks once again
04:01:57 <kuribas> jcjf: if you have validate :: Value -> MyType, what would the type of MyType be?
04:02:06 <kuribas> since you only know it at runtime.
04:02:16 <kuribas> you cannot derive the constraints
04:03:05 <cocreature> the fact that I need to enable TypeInType to GND Prim instances bugs me way more than it probably should
04:03:40 <jcjf> (EnumLike a) => Value -> MyType a
04:04:20 <jcjf> I dunno, I barely understand basic Haskell, but I know you aficionados are very clever data modellers!
04:04:39 <kuribas> jcjf: so use (Enum a)?
04:06:14 <kuribas> jcjf: but if, as you say, you don't know at compile time what the constraints will be, you cannot derive the right a at compile time!
04:06:36 <kuribas> jcjf: and if you do know it, you can pick the right enum for it.
04:09:29 <jcjf> A twist on the original question: what if I knew ahead of time the structure was { "objects": { /* some object with keys */ }, "listOfValues": [ /* those keys, possibly repeated, but nothing else */ ] }
04:10:10 <jcjf> Can I express the constraint now? The user is still providing the keys (strings)
04:11:14 <kuribas> jcjf: yes, turn listOfValues into an Enum
04:13:31 <kuribas> though you can have a key which isn't in listOfValues...
04:13:40 <kuribas> I seems like an xy problem
04:14:21 <jcjf> data UserData = UserData { objects:: ObjectMap, listOfValues:: Enum String }
04:14:27 <dminuoso> Gah.. cryptonite refusing so unpad my string. Nothing is so informative...
04:14:50 <jcjf> I'm not a Haskeller and I won't be writing this in Haskell unfortunately - I'm trying to flesh out the concept
04:15:30 <kuribas> jcjf: http://xyproblem.info/
04:16:33 <iv> Anybody know how can i contact hackage admin ? They does not respond by email for several days.
04:19:06 <jcjf> kuribas: Point taken, I'll shut up now.
04:20:25 <kuribas> jcjf: xy problem means you should ask about the real question X, not your solution Y, which likely isn't a good solution for X
04:21:40 <kuribas> jcjf: it doesn't mean you cannot ask questions, but rather that you should provide enough context, so we can understand the big picture
04:21:56 <kuribas> jcjf: and give a more meaningful answer
04:45:37 <Athas> Has anyone here succesfully used GHC 8.4.2 on Travis?
04:45:51 <Athas> I get strange errors when trying to 'stack setup' it.
04:48:20 <cocreature> Athas: I’ve used it on travis but not with stack. what’s the error?
04:49:43 <Athas> cocreature: 'Received ExitFailure 2 when running
04:49:43 <Athas> Raw command: /usr/bin/make install
04:49:43 <Athas> Run from: /home/travis/.stack/programs/x86_64-linux/ghc-8.4.2.temp/ghc-8.4.2/'
04:49:59 <Athas> 'stack setup' downloads the binary tarball, unpacks it, then runs 'make install'.
04:50:14 <Athas> I wonder if I can force it to produce some more output.  Looks like it's hiding the stderr.
04:50:44 <cocreature> that does look weird indeed, sry not sure what’s going on there
04:50:51 <Turion> gloss is nice for functional 2d pictures. What about 3d? Is there anything similar?
04:51:58 <onsed> hey, i have a question about converting numbers. I want to define a function {fun :: (Num a, Fractional b) => [a] -> b ; fun l = someConverterFunction (sum l) / 5}. I don't quite understand how to convert the type a into a Fractional b. E.g. if I want to do the same thing with an Int, I would use fromIntegral, which returns a Num b and that b can than be interpreted as a Fractional. But here i already have a Num which is no
04:52:01 <onsed> t necessarily a Fractional, how do I convert it to a fractional? Is there something like (Num a, Num b) => a -> b that would then allow me to then interpret b as a Fractional?
04:56:09 <Turion> onsed: I don't think this would work in general. There's no (Num a, Num b) => a -> b. How would you transform Complex a into a?
04:57:46 <Turion> Num is a numeric class that always contains the integers. Fractional is a class that always contains Ratio Integer.
04:58:37 <Turion> But it can have much more numbers than that. Double is Fractional, but how to transform [Complex Int] to Double? You need to assume more about your a
04:59:29 <Turion> What prevents you from assuming Real a? Then you can use realToFrac
05:04:44 <onsed> Hm, but then i would not be able to put in a Fractional, that is not also a Real, right?
05:05:44 <onsed> Also i dont understand why it is possible to convert an Int to a Fractional using fromIntegral (which gives Num b) but not a type that is already Num c
05:06:28 <Turion> because every Fractional is also a Num
05:06:33 <michalrus> Can I match multiple patterns in a single do-notation binding? I think I’ve seen that somewhere, but can’t find it. :c
05:06:59 <Turion> onsed: See it like this: The integers are required to be contained in any Num type
05:07:08 <cocreature> michalrus: what exactly do you mean by that? something like a disjunctive pattern?
05:07:21 <Turion> michalrus, like do (a, b) <- readLn?
05:07:49 <michalrus> No, more like handling `Just a | Nothing`, hmmmmmm, but that would bind different symbols.
05:07:51 <michalrus> I don’t know.
05:08:07 <cocreature> there is a GHC proposal for “or-patterns” but you can’t do that atm
05:08:07 <michalrus> But I remember I’ve seen some alien construct like that not long ago.
05:08:13 <michalrus> Okay. :]
05:08:15 <michalrus> Thank you.
05:08:25 <cocreature> but they will require that you bind the same symbols
05:08:29 <michalrus> +
05:09:18 <onsed> Turion: I don't understand.
05:09:47 <Turion> michalrus: What's the problem with case?
05:10:08 <Turion> do
05:10:08 <Turion>   value <- action
05:10:08 <Turion>   case value of
05:10:08 <Turion>    Just a -> ...
05:10:08 <Turion>    Nothing -> ...
05:10:19 <michalrus> Yes, I’m using that. ^^,
05:10:54 <Turion> Ah you mean you don't want to repeat whatever you have for ...? Hmm, let bind it somewhere before..?
05:10:55 <michalrus> I don’t know what I could’ve seen then. It was some network library code, I think.
05:11:25 <michalrus> I could also do action >>= \case Just a -> … without binding value.
05:11:57 <Turion> onsed: Whenever you or someone else defines a type satisfying Num a, you also need to define how the integers embed into a
05:12:15 <Turion> that's how fromInteger works
05:12:49 <Turion> michalrus: Oh that's nice, didn't know that syntax
05:12:56 <michalrus> -XLambdaCase ^^
05:13:12 <Turion> Ah ok :)
05:13:19 <juri_> if i have two functions that are identical, except what function they call, and the type of argument they return (generated by the function they call), is there a 'simple' way to make them one function?
05:13:50 <juri_> If this were C, i'd just pass the function pointer in as a parameter... and let the caller decide the type of the return..
05:14:05 <Turion> juri_ depends on your function. But if it's not too complicated, they should have a common type.
05:14:36 <Turion> Just for fun, leave out the type signature, just define the function and see what type the type checker derives
05:14:43 <juri_> I can make them have a common type, but by default, they're a different number of floats.
05:15:14 <cocreature> juri_: can’t you do exactly the same in Haskell? take the function as an argument?
05:15:45 <juri_> ccreature: sure, but i don't know what to do about the differing resulting type.
05:16:37 <Turion> juri_, can you post the functions?
05:16:42 * hackage simple-vec3 0.4.0.3 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.3 (DmitryDzhus)
05:16:46 <cocreature> juri_: just make it polymorphic and use the same type variable in the result type as well as the type of the function that you take as the argument
05:18:02 <onsed> Turion: ah, I think I understand.
05:21:09 <juri_> um. the pastebin site is broken?
05:21:24 <juri_> SqlError {sqlState = "53100", sqlExecStatus = FatalError, sqlErrorMsg = "could not extend file \"base/16389/63782\": No space left on device", sqlErrorDetail = "", sqlErrorHint = "Check free disk space."}
05:21:41 <cocreature> juri_: use github gists instead
05:21:48 <cocreature> or some other pastebin site
05:22:59 <juri_> https://pastebin.com/dCkT6z3M
05:24:11 <cocreature> juri_: what’s the type of getSquareTriangles and getSquareLineSegs
05:24:21 <cocreature> juri_: also a pastebin that supports Haskell highlighting would be nice :)
05:25:32 <onsed> Turion: Only problem with using Real a as an assumption is that i can't use a fractional that is not also a real, there i would have to define the function again assuming (Fractional a) => [a] -> a and not use the realToFrac conversion. that a little unfortunate, but i guess there is no other way?
05:25:52 <juri_> cocreature: getSquareLineSegs :: ℝ2 -> ℝ2 -> Obj2 -> [Polyline] vs getSquareTriangles :: ℝ2 -> ℝ2 -> Obj2 -> [Polytri]
05:26:43 <juri_> so the number and function of arguments is the same, the only real difference is how many floats are in the tuples in the arrays they return.
05:26:46 <cocreature> juri_: alright so make something like "getContour :: (R2 -> R2 -> Obj2 -> [a]) -> R2 -> R2 -> Obj2 -> [a]
05:27:04 <cocreature> then you can apply this to getSquareTriangles to get the first function and getSquareLineSegs to get the second function
05:28:53 <juri_> I'll give that a shot. thanks. :)
05:30:44 <Turion> onsed: Why not realToFrac . sum :: (Real a, Fractional b) => [a] -> b?
05:34:25 <onsed> Turion: because I can't input e.g. data F = F Int ; instance Num F ; instance Fractional F, because it has no real instance. Thats sucks, because all relevant function: (/) and sum would gladly use that type as an input, but my function does not because i restrict it to Real a
05:35:17 <onsed> recall, function i want to implement is: sum l / 5
05:36:21 <Taneb> onsed: what about fromIntegral (sum l) / 5
05:36:56 <Taneb> I've probably missed something, I haven't read back
05:37:40 <onsed> if i use fromIntegral, then i can't use Float as an input.
05:38:54 <onsed> no matter how i restrict my input, there is no way to get all the types that should be possible into one function
05:40:34 <onsed> If i use Real a i can't use my type F as an input. but if i don't use realToFrac, i can not use Integers etc as an input. But it should be possible, right?
05:41:06 <Taneb> Eh. fractional division and integral division are quite different behaviours
05:42:01 <onsed> I'm not talking about that, integer should be converted before calling (/)
05:42:12 <cocreature> I would go so far as to say that in a lot of cases numeric functions that accept very polymorphic input and output types only to then convert these to specific types are an anti pattern
05:42:29 <Turion> What is your type F?
05:42:34 <cocreature> all of these conversions come with their own problems so just let the caller convert its input instead
05:43:06 <onsed> an imaginary data F = F Int with isntances in Num and Fractional
05:43:26 <Turion> cocreature: +1
05:43:33 <Turion> onsed: How's that a Fractional?
05:43:46 <Turion> What's F 1 / F 2?
05:44:11 <onsed> cocreature: so i basically define multiple functional to cover all possible input types?
05:44:34 <cocreature> onsed: no you define a single function and then let the caller use the appropriate conversion when they call your function
05:44:44 <Turion> onsed: No, you define the most general one, but you might have to convert a few types before calling it
05:44:53 <onsed> Turion: doesn't matter how it a fractional, F1 / F2 could be undefined, thing is it should be possible to use it as in input type
05:45:53 <Turion> onsed: This is precisely what matters, I think. I'd say if F just wraps an integer, it can't be Fractional. F 1 / F 2 shouldn't be undefined.
05:46:29 <onsed> ah so i define fun :: (Fractional a) => [a] -> a and caller has to convert to fractional if its not?
05:46:37 <Turion> Define your function foo as = realToFrac (sum as) / 5, and then call it as foo $ fromIntegral <$> [F 1, F 2, F 3]
05:46:51 <Turion> Yes, for example
05:47:56 <onsed> okay, thanks.
05:50:19 <hazyPurple> Client: HexChat 2.14.1 • OS: ArchLinux • CPU: Intel(R) Core(TM) i5-3317U CPU @ 1.70GHz (1.06GHz) • Memory: Physical: 7.5 GiB Total (545.9 MiB Free) Swap: 8.8 GiB Total (7.1 GiB Free) • Storage: 474.0 GB / 527.5 GB (53.5 GB Free) • VGA: Intel Corporation 3rd Gen Core processor Graphics Controller @ Intel Corporation 3rd Gen Core processor DRAM Controller • Uptime: 2w 2d 6h 31m 12s
05:58:29 <onsed> Turion: cocreature: That actually makes a lot of sense to me now. Thanks for explaining.
06:01:12 * hackage ecstasy 0.2.0.0 - A GHC.Generics based entity component system.  http://hackage.haskell.org/package/ecstasy-0.2.0.0 (isovector)
06:06:19 <shiona_> Any good advice on how to send my types over the network? At the moment I'm using Data.Aeson (as a temporary choice) for serialization and just Network.Socket to send these around. However decoding breaks if two json objects are appended on the wire. I could just separate them with zero bytes, but I guess this would be a great time to learn of a highed level networking library if there is a good one
06:07:10 <shiona_> I do wish to do {,de}serialization by hand at some point to mimize traffic and to learn how to do it, so that's kind of a requirement
06:10:41 <exarkun> shiona_: HTTP is a pretty popular protocol.  It includes framing and some other conveniences.  Also, a new rev has recently gained widespread adoption.  https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
06:11:12 <exarkun> If you have any particular goals or requirements for your network interactions, those might inform your choice of protocol.
06:12:18 <exarkun> One of its conveniences is a framework for encoding negotiation.  So, for example, you could support JSON _and_ BSON (with BSON giving you the more compact representation it sounds like you might want).
06:12:54 <exarkun> Cap'n Proto is another likely option.  https://github.com/zenhack/haskell-capnp
06:13:50 <shiona_> good point, I forgot about capnp and the likes
06:14:30 <shiona_> http sounds rather bloated considering my messages are closer to the order of bytes than tens of bytes
06:15:46 <exarkun> There are many pros and cons to many different protocols.
06:16:07 <exarkun> Often they can only be evaluated and weighed in the context of a specific project.
06:17:13 <shiona_> I guess I'll try first just rolling out one of my own. see where that gets me
06:17:33 <exarkun> Inventing your own as a first attempt doesn't _seem_ like a wise choice to me.
06:18:27 <exarkun> I guess technically it may be your second attempt at this point.
06:18:37 <exarkun> Still, not what I'd recommend.
06:19:06 <shiona_> I might be wrong, but isn't capnproto just a tool for creating a protocol of your own (with addition of some constraints that make making errors harder)
06:19:55 <exarkun> Maybe I misunderstood your "rolling out one of my own" comment.
06:29:37 <gobert> After putting the `DeriveGeneric` pragma, and adding `deriving Generic` at the end of my datatype, GHC complains with `Not in scope: type constructor or class ‘Generic’`
06:30:42 <gobert> don't worry got it
06:30:46 <gobert> left out `import GHC.Generics (Generic)`
06:34:56 * hackage llvm-hs-pretty 0.3.0.0 - A pretty printer for LLVM IR.  http://hackage.haskell.org/package/llvm-hs-pretty-0.3.0.0 (sdiehl)
06:40:37 <exarkun> How do I handle error responses when making queries with servant-client?
06:41:04 <exarkun> For example, if a post to create a resource fails because the resource already exists, handle that case to do a post to update the resource instead
06:41:34 <exarkun> And where in the servant-client docs is this information about error handling?
06:56:10 <vidlew> hellou
06:57:47 <dmj`> vidlew: hello
06:59:12 <vidlew> dmj: hellou
06:59:20 <vidlew> dmj`: hellou
07:00:54 <jhrcek> Can someone please explain how it's possible that this works (OverloadedString enabled)?
07:00:56 <jhrcek> -- httpLBS :: MonadIO m => Request -> m (Response ByteString)
07:00:58 <jhrcek> httpLBS "http://httpbin.org.get"
07:01:00 <jhrcek> BUT Request is not instance of IsString..
07:02:16 <infinisil> jhrcek: Link to docs?
07:02:30 <jhrcek> Sorry, forgot: https://www.stackage.org/haddock/lts-11.8/http-conduit-2.3.1/Network-HTTP-Simple.html#v:httpLBS
07:03:30 <dmj`> exarkun: posting to an already existent resource wouldn’t be an error per se. The server could return an unmodified response code, 304. Only 400+ codes would cause a Left case to be returned. You’d have to handle that logic client side. A PATCH would be good for incremental updates. PUT for overwriting existing resources.
07:05:17 <exarkun> It's not my API.  Someone else invented it.  I just want to use it.
07:05:35 <exarkun> It does return a 400 when the resource already exists.
07:05:44 <exarkun> My question is about what Haskell I write to be able to handle that 400
07:07:30 <jhrcek> infinisil: Here's a standalone example of it workign, but I don't get how that String literal url gets accepted as a Request: https://gist.github.com/jhrcek/1247d436ccb6d074ac553489ca59d9e3
07:09:12 <infinisil> Huh, that's odd
07:11:38 <infinisil> jhrcek: On the top of the docs it does say "Important note: Request is an instance of IsString" though
07:12:22 <EvanR> it is an instance of IsString in older versions of http-conduit
07:12:29 <EvanR> according to old docs
07:13:43 <jhrcek> infinisil: Is it a haddock bug, that it doesn't show that instance in the Request docs? Or was it somehow hidden by the docs author?
07:13:50 <jhrcek> EvanR^
07:14:22 <EvanR> would not be surprised
07:17:14 <EvanR> i am still trying to find the code for Request
07:18:37 <jhrcek> Weird is that when I load that code in ghci, and type :info Request, it's also not showing IsString instance.
07:18:38 <EvanR> https://github.com/snoyberg/http-client/blob/master/http-client/Network/HTTP/Client/Request.hs#L296
07:19:02 <EvanR> you might not have a module with the instance loaded
07:19:14 <EvanR> ghci :i only shows  instances that are loaded
07:21:33 <jhrcek> So if I load that script `:l script.hs` and then run the main successfully, its imports are not loaded? I wonder how GHCI then finds the IsString instance? :)
07:22:56 <EvanR> try leaving ghci and rebooting it
07:25:24 <shapr> ricky_clarkson: you still writing Haskell?
07:26:44 <jhrcek> infinisil, EvanR: thanks for pointers..
07:26:47 <dmj`> exarkun: can you paste your code
07:28:04 <exarkun> dmj`: https://github.com/LeastAuthority/leastauthority.com/blob/chargebee/ops/chargebee/create-plans/src/Lib.hs#L112-L113
07:31:45 <dmj`> exarkun: case match on the Left constructor, find the response code, check if it’s 400.
07:32:33 <exarkun> dmj`: case match against what?
07:33:02 <exarkun> And whatever it is, how could matching against Left work when there's no sign of an Either anywhere?
07:38:10 <dmj`> exarkun: https://hackage.haskell.org/package/servant-client-core-0.13.0.1/docs/Servant-Client-Core-Internal-Request.html#t:ServantError
07:38:24 <dmj`> There’s a Response in there
07:38:34 <exarkun> I don't know what function returns a ServantError :/
07:42:11 <exarkun> Okay..  I see `ClientM :: ReaderT ClientEnv (ExceptT ServantError IO) a -> ClientM a`
07:42:28 <exarkun> And the query function returns `ClientM a`
07:43:46 <exarkun> I don't know what ReaderT and ClientEnv are but I see that ExceptT ServantError IO in there
07:49:21 <dmj`> exarkun: https://hackage.haskell.org/package/servant-client-0.13.0.1/docs/Servant-Client.html#v:runClientM
07:50:16 <exarkun> Okay...  So if I have error handling to do, I can't do it "inside" a single ClientM?  I should use runClientM multiple times and do the error handling outside of ClientM?
07:50:31 <electrocat> no
07:50:57 <electrocat> :t catchError
07:50:59 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
07:51:21 <electrocat> ClientM is an instance of MonadError
07:52:57 <exarkun> If I `catchError (runClientM do_a_and_b) (\e -> do_c)` and a fails then b doesn't happen, only c, right?
07:53:41 <electrocat> right, but my point is that you can use catchError inside runClientM
07:54:36 <electrocat> don't know if you should though, i'm not familiar with servant
07:58:59 <exarkun> electrocat: okay ... I'll give that a try (I have never used ExceptT or catchError before so I have a lot of learning to do here)
08:00:21 <exarkun> How did you know ClientM is an instance of MonadError?
08:00:51 <electrocat> exarkun: the link for runClientM
08:01:02 <electrocat> look at the instances for the ClientM definition
08:01:25 <electrocat> https://hackage.haskell.ohttps://hackage.haskell.org/package/servant-client-0.13.0.1/docs/Servant-Client.html#t:ClientMrg/package/servant-client-0.13.0.1/docs/Servant-Client.html#t:ClientM
08:01:37 <electrocat> woops
08:01:40 <electrocat> https://hackage.haskell.org/package/servant-client-0.13.0.1/docs/Servant-Client.html#t:ClientM
08:01:43 <electrocat> sorry
08:02:23 <electrocat> exarkun: also, because of the ExcepT in there
08:03:52 <electrocat> i suggest reading about monad transformers :p
08:04:26 <exarkun> cool, thanks
08:10:48 <kuribas> wouldn't it be possible to allow template haskell in cross compilation by making the compile pretend it's running on the host?
08:13:50 <shapr> that's a neat idea
08:15:01 <shapr> TH has a loop of emit->check->compile, but I don't know enough about cross compiling to know if that would work
08:16:05 <electrocat> why does it need to know at all on what it's running?
08:17:01 <c_wraith> electrocat: One major use of TH generates system-specific code.  If it's running on the wrong system, it will generate the wrong code.
08:17:30 <c_wraith> kuribas: have you looked at how ghcjs handles TH?
08:17:48 <kuribas> c_wraith: no
08:18:42 <kuribas> I wonder how practical haskell on mobile devices is...
08:18:48 <c_wraith> "GHCJS uses an external process to run Template Haskell code. It compiles each splice to JavaScript, collects its dependencies and runs it on a node.js server. The server stays active between splices to support persistent state in the Quasi monad."
08:19:19 <electrocat> it should be defined as 'target' instead as 'currect' than
08:20:07 <Cale> kuribas: It's reasonably decent. At Obsidian, we build our reflex-dom applications for Android and iOS, and they actually run significantly faster than on a desktop machine in a web browser (compiled to javascript) :)
08:20:54 <kuribas> Cale: using ghcjs?
08:21:08 <Cale> We use ghcjs for the web versions, eay
08:21:10 <Cale> yeah*
08:21:46 <kuribas> Cale: how is that possible?
08:21:47 <Cale> For mobile, we compile to ARM code
08:21:54 <Cale> How is what possible?
08:21:58 <kuribas> Ah...
08:22:04 <kuribas> The arm code is faster than the JS
08:22:09 <Cale> yes :)
08:22:13 <kuribas> makes sense
08:22:17 <kuribas> ghcjs code is rather slow
08:22:37 <kuribas> plain JS is slow compared to native ghc
08:22:58 <kuribas> Cale: so you are using the ndk for android?
08:22:59 <Cale> Well, and javascript in general is much slower than native code, even if the javascript is running on a desktop machine and the native code on a phone
08:23:28 <Taneb> Very few JavaScript engines are optimized for code generated by GHCJS
08:24:12 * kuribas didn't know reflex works an native...
08:25:53 * hackage dmcc 1.0.0.0 - AVAYA DMCC API bindings and WebSockets server for AVAYA  http://hackage.haskell.org/package/dmcc-1.0.0.0 (DmitryDzhus)
08:27:14 <kuribas> Cale: how do you run reflex natively?  Is it a webserver?
08:30:43 --- mode: ChanServ set -q hibou!*@*
08:31:08 --- mode: ChanServ set -q *!*@139.162.161.37
08:31:19 <Cale> kuribas: jsaddle has a bunch of ways
08:33:47 <kuribas> is jsaddle a JS interpreter writting in haskell?
08:43:19 <Cale> https://github.com/ghcjs/jsaddle -- It's sort of a unified library for interacting with JS
08:43:27 <Cale> https://github.com/ghcjs/jsaddle-dom
08:43:51 <kuribas> or does it bind to a system specific JS interpreter?
08:44:46 <Cale> Yeah, it abstracts over different ways of running bits of javascript
08:45:00 <Cale> depending on which version of it you're compiling against
08:47:23 * hackage herms 1.9.0.0 - A command-line manager for delicious kitchen recipes  http://hackage.haskell.org/package/herms-1.9.0.0 (JackKiefer)
08:47:32 <Cale> https://github.com/ghcjs/ghcjs-dom -- this library sort of caps everything off, and is what you use directly
08:47:40 <shiona_> using Network.Socket.ByteString.Lazy I should be able to do things like "recv sock 1024 >> Binary.decode" and only the decoded element worth of bytes should disappear from socket stream. right?
08:48:03 <exarkun> Probably not
08:48:15 <exarkun> What's `recv`?
08:48:47 <exarkun> Network.Socket recv reads up to the number of bytes you asked for
08:48:56 <exarkun> doesn't matter if you then choose to drop most of them on the floor
08:49:10 <c_wraith> note the "up to"
08:49:33 <exarkun> You don't really want to use the socket receive buffer as your parse buffer anyway
08:49:50 <exarkun> It's a super expensive buffer to access and it has all kinds of weird extra rules to trip over
08:50:29 <exarkun> Plus you want all of your protocol logic decoupled from your I/O logic, to the maximum extent possible
08:50:53 <exarkun> You never want `recv` lexically adjacent to some parsing code
09:06:25 <shiona_> exarkun: if you have some feedback on what to do, then I would be happy to put it to use, but I really can't consider "don't do X" useful when I just trying to learn.
09:06:52 <shiona_> I can learn if someone teaches me, or by finding some good material that teaches me, or by doing mistakes and learning from them
09:07:01 <shiona_> but I really can't learn by "not doing a thing"
09:17:43 * hackage dmcc 1.0.0.1 - AVAYA DMCC API bindings and WebSockets server for AVAYA  http://hackage.haskell.org/package/dmcc-1.0.0.1 (DmitryDzhus)
09:24:24 <arkeet> isn't that what things like pipes/conduit are for?
09:38:49 <kuribas> Cale: so for windows you need ghcjs?  But for linux you can use webkitgtk?
09:41:09 * hackage log-effect-syslog 0.1.0 - Syslog functions for log-effect  http://hackage.haskell.org/package/log-effect-syslog-0.1.0 (sickmind)
09:41:17 * hackage htoml-megaparsec 1.2.0.1 - Parser for TOML files  http://hackage.haskell.org/package/htoml-megaparsec-1.2.0.1 (vmchale)
09:47:30 <iqubic> Let's say I have a default function in a typeclass (I.E. The definition is in the "Class Foo a where...). Can I call that function from an instance of that type class?
09:48:11 <iqubic> Sorta like "super.foo()" in an OOP language.
09:48:50 <lyxia> no
09:49:26 <arkeet> if you want to access that default definition, put it in a separate function outside the class definition
09:49:37 <glguy> If you don't provide your own definition you'll get the default one, and you can use that default one when defining other methods of the class
09:50:44 * hackage ip 1.2.1 - Library for IP and MAC addresses  http://hackage.haskell.org/package/ip-1.2.1 (andrewthad)
09:50:55 <iqubic> Let's say this default function calls a function that is only defined in the actual instances. Is that fine?
09:51:00 <arkeet> yes
09:51:23 <arkeet> it's as if the default definition were copy-pasted into each instance definition.
09:51:29 <iqubic> Oh, nice.
09:51:53 <arkeet> (unless overriden, of course. and unless it has an unsatisfied constraint.)
09:52:48 <iqubic> What is an unsatisfied constraint?
09:52:49 <glguy> If you're talking about constraints added by DefaultSignatures you still get the definition copy/pasted in, but you also get a type error in that case :)
09:53:02 <arkeet> yeah I'm talking about DefaultSignatures, and ok :)
09:53:58 <iqubic> What is DefaultSignatures?
09:54:06 <glguy> It's in the GHC User's Guide
09:54:19 <arkeet> https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/type-class-extensions.html#class-default-signatures
09:54:20 <glguy> there's a search box on the right side
09:55:14 <iqubic> How does that lead to type errors?
09:55:42 * hackage log-effect 1.0.1 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-1.0.1 (sickmind)
09:56:54 <arkeet> I guess, in the user's guide example, if you make an Enum instance on a type that doesn't satisfy GEnum, then it will try to insert the default definition but fail.
09:57:10 <iqubic> Oh, I see.
09:58:11 <iqubic> Now, the parameters of type classes must be concrete data types that exist.
09:58:45 <iqubic> If I have "Class Foo a where..." I can't try to unify a to (Int -> Bool) can I?
09:59:17 <iqubic> I can't write "Instance Foo (Int -> Bool) where..."
09:59:22 <iqubic> Is that right?
10:00:01 <iqubic> :t (Int -> Bool)
10:00:02 <lambdabot> error:
10:00:02 <lambdabot>     Pattern syntax in expression context: Int -> Bool
10:00:17 <glguy> Not without the FlexibleInstances extension, otherwise instance heads need to be a single type constructor applied to 0 or more type variables
10:01:39 <iqubic> Now, why the heck might someone use type families and associated types? Does that give any real benefits?
10:03:10 <iqubic> > foldr (,,) 0 [1,2]
10:03:12 <lambdabot>  error:
10:03:12 <lambdabot>      • Occurs check: cannot construct the infinite type:
10:03:12 <lambdabot>          b ~ c -> (a, b, c)
10:03:22 <iqubic> what?!?!
10:03:29 <iqubic> > foldl' (,,) 0 [1,2]
10:03:31 <lambdabot>  error:
10:03:31 <lambdabot>      • Occurs check: cannot construct the infinite type:
10:03:31 <lambdabot>          a ~ c -> (a, b, c)
10:03:42 <iqubic> What?!?! What is the issue there?
10:03:57 <glguy> what type do you think foldr has there?
10:04:53 <iqubic> I'm not sure.
10:05:00 <glguy> that's the problem
10:05:00 <lavalike> :t foldr
10:05:01 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:05:04 <fresheyeball> Anyone have strong options on a good logging framework?
10:06:17 <EvanR> > signum ((-0) :: Double)
10:06:19 <lambdabot>  -0.0
10:06:20 <iqubic> Let's say I have a constructor that takes N arguments, and a list of length N. Is it possible to apply the constructor to all N arguments?
10:06:25 <EvanR> o_O
10:07:06 <glguy> You'd need to use a typeclass
10:07:21 <iqubic> glguy: How would you do it with a typeclass?
10:07:54 <glguy> maybe give it a shot, it'll be an interesting puzzle
10:08:16 <iqubic> Well, I tried foldr and foldl, and those failed.
10:08:38 <iqubic> I kinda have no other ideas.
10:09:16 <glguy> It's not a good idea in general, so if you can't figure it out that's not the end of the world
10:09:36 <iqubic> why is it not a good idea? What's wrong with my idea?
10:09:42 <Clint> > let iqubic (a:b:c:[]) = (,,) a b c in iqubic [1,2,3]
10:09:43 <lambdabot>  (1,2,3)
10:10:16 <iqubic> But Clint, that doesn't generalize to other things.
10:10:41 <iqubic> > let iqubic (a:b:c:d:[]) = (,,,) a b c d in iqubic [1,2,3,4]
10:10:43 <lambdabot>  (1,2,3,4)
10:11:01 <lyxia> iqubic: the fact that you can't think of a type for it is a pretty strong indicator
10:11:02 <mnoonan_> >iqubic [1,2,3]
10:11:09 <iqubic> I had to add the d parameter to that to it it to work.
10:11:13 <Clint> yes, you did
10:11:25 <iqubic> @let iqubic (a:b:c:d:[]) = (,,,) a b c d
10:11:27 <lambdabot>  Defined.
10:11:38 <iqubic> > iqubic [1,2,3]
10:11:40 <lambdabot>  *Exception: /tmp/mueval11235-0.hs:169:1-49: Non-exhaustive patterns in funct...
10:11:50 <iqubic> Huh, what just happened?
10:11:59 <iqubic> > iqubic [1,2,3,4,5]
10:12:01 <lambdabot>  *Exception: /tmp/mueval11260-0.hs:169:1-49: Non-exhaustive patterns in funct...
10:12:12 <iqubic> Huh, the heck is going on there.
10:12:19 <infinisil> pattern matching?
10:12:37 <iqubic> Yes, but why is it failing?
10:12:44 <Clint> because you only gave it the 4-element case
10:13:13 <iqubic> Can I give a kind signature to a parameter in a typeclass header?
10:13:18 <infinisil> [1,2,3,4,5] = 1:2:3:4:[5] ~/~ a:b:C:d:[]
10:13:26 <iqubic> :t iqubic
10:13:27 <lambdabot> [d] -> (d, d, d, d)
10:13:40 <iqubic> @undefine iqubic
10:13:40 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
10:13:53 <iqubic> Well, that's a thing.
10:13:58 <iqubic> @undefine
10:13:58 <lambdabot> Undefined.
10:14:23 <iqubic> Sorry if that breaks other people's examples.
10:15:16 <iqubic> Is this a valid signature: "* -> Int
10:15:41 <iqubic> Or is that mixing values and types in a way that shouldn't be mixed?
10:16:16 <arkeet> what would it mean?
10:16:36 <iqubic> I don't know.
10:16:44 <iqubic> What does * -> * mean?
10:16:55 <infinisil> Lookup "kinds"
10:17:08 <infinisil> There is plenty of info online
10:17:46 <glguy> iqubic: Have you started writing your program yet?
10:18:28 <iqubic> I have started a program, but I'm getting heavily bogged down by trying to reduce code reuse in the program.
10:18:37 <glguy> cool, what's it do now?
10:19:42 <iqubic> Not much at all. I'm just defining a typeclass and a two instances. I then noticed that the two instances where quite similar, so I'm trying to reduce the code reuse.
10:20:26 <iqubic> What bugs me is that you can't have a datatype and a typeclass with the same name.
10:20:48 <glguy> What's the program going to do when it works?
10:21:21 * arkeet
10:21:31 <arkeet> whoops
10:21:48 <iqubic> I'm recreating a popular game called 2048 in haskell. https://gabrielecirulli.github.io/2048/
10:22:11 <glguy> You probably don't need to worry about using any typeclasses at all
10:22:29 <arkeet> is there some saying about premature abstraction like the one about premature optimization?
10:22:47 <iqubic> But I'm trying to make it modular by adding a typeclass for tiles so that you can change the behavior of the tiles. I know that's overkill but I want to do it for learning purposes.
10:23:22 <glguy> Does it already work other than that?
10:23:35 <iqubic> However, I should focus on the actual game logic before I get to adding fancy new tiles to the program.
10:24:08 <arkeet> haskell is one of the easier languages to refactor so it's maybe worth getting something that just works and then adding from there.
10:32:49 * hackage servant-quickcheck 0.0.4.1 - QuickCheck entire APIs  http://hackage.haskell.org/package/servant-quickcheck-0.0.4.1 (parsonsmatt)
10:34:57 * hackage servant-quickcheck 0.0.7.2 - QuickCheck entire APIs  http://hackage.haskell.org/package/servant-quickcheck-0.0.7.2 (parsonsmatt)
10:50:27 <tromp> mv ghc 8.2.2 cannot find module Data.DList that i just installed with stack install dlist
10:50:33 <tromp> mv->my
10:51:21 <cocreature> tromp: stack doesn’t install packages in a way that just running "ghc" will pick them up
10:51:27 <cocreature> you have to use "stack ghc"
10:52:28 <cocreature> also `stack install` is the wrong command for installing libraries. just use `stack build` for that. `stack install` is just `stack build` followed by copying the executables in the package to ~/.local/bin
10:54:47 <tromp> stack build dlist quietly and instantly finished, but nothing seems to have happened. i tried going back to cabal
10:55:05 * shapr hugs tromp
10:55:06 <tromp> cabal install dlist says dlist-0.8.0.3 alread installed
10:55:12 <tromp> hug shapr
10:55:15 <shapr> yay!
10:55:18 * hackage aeson 1.3.1.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-1.3.1.1 (AdamBergmark)
10:55:19 <tromp> hi Shae
10:55:29 <shapr> hi John, how's life?
10:55:42 <cocreature> tromp: have you tried using "stack ghc" instead of "ghc"?
10:55:43 <tromp> wonderful. moved back to Amsterdam
10:55:56 <shapr> Yeah, you told me about that, sounds like what you want.
10:56:01 <tromp> enjoying the relaxed life
10:56:10 <shapr> I'll have to come by and visit soon.
10:56:18 <shapr> haven't been to europe in a few years.
10:56:57 <tromp> stack ghc -O2 -Wall --make Main.lhs -o blc   comaplains of invalid options
10:57:38 <cocreature> tromp: try separating the arguments to GHC with a double dash, i.e., stack ghc -- -O2 …
10:57:52 <sm> have a look at --help. You can't use ghc options directly with stack ghc
10:58:09 <tromp> with just stack ghc Main.lhs it complains about Failed to load interface for ‘Control.Monad.Writer’     let me try fix that
10:58:09 <sm> oh, that sounds good
10:58:41 * sm didn't know -- OPTS that was an alternative to --ghc-options
11:00:05 <tromp> wonder what happened to Control.Monad.Writer
11:01:02 <EvanR> i still see it
11:01:18 <cocreature> tromp: "stack build mtl"
11:01:46 <tromp> ok, success at last!
11:01:49 <tromp> thanks, all!
11:02:00 <tromp> i'm just not used to stack...
11:02:34 <tromp> afk to chess club...
11:17:22 * hackage duckling 0.1.6.0 - A Haskell library for parsing text into structured data.  http://hackage.haskell.org/package/duckling-0.1.6.0 (patapizza)
11:18:42 * hackage jmacro 0.6.15 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.15 (GershomBazerman)
11:26:16 * hackage xeno 0.3.4 - A fast event-based XML parser in pure Haskell  http://hackage.haskell.org/package/xeno-0.3.4 (ocramz)
11:42:47 <noan> anyone know of a decent example of how to use data-dir/data-files and getDataFileName for a cabal project? I'm a bit uncertain of how to put some things together
11:53:58 <noan> hmm, nvm I think I understand enough to sort it out the shit way
11:54:59 <infinisil> Is there a filterM :: (a -> m Bool) -> Set a -> m (Set a) ?
11:59:31 <paidnode> so I've got data Tile = Tile { tileType :: TileType, coordinates :: Coordinates } and data TileType =  Bear | Lumberjack | Tree Tree | Empty. I find it a bad strcture if I want to have functions that only accept e.g. trees. I would however need a tile like type for parametrizing my matrix, and the fact  Ican define the coordinates there is also handy, avoids repetition. Any suggestions of how to define these types to have all these
11:59:32 <paidnode> benefits?
12:00:11 <paidnode> time for a typeclass maybe?
12:01:28 <paidnode> I started off with a design relying on typeclasses, but as it seemed like the typeclass didn't really have anything to do with its instances, I concluded it is overengineering, or wrong for another reason
12:01:33 <dmj`> :t filterM
12:01:34 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
12:01:55 <cocreature> infinisil: sadly there is no monadic API for Set
12:02:07 <infinisil> :(
12:02:16 <infinisil> Now I gotta figure out how to write it myself..
12:02:20 <lyxia> paidnode: if your function only accepts trees, then why not take a Tree argument?
12:02:31 <johnw> paidnode: been there ;)
12:02:44 <arkeet> it can't be that bad to convert a Set to a list, filterM that, and convert back to a Set, can it?
12:02:59 <cocreature> infinisil: fmap Set.fromAscList . filterM f . Set.toAscList
12:03:14 <infinisil> Um..
12:03:23 <johnw> missing some parens there...
12:03:34 <johnw> oh, no
12:03:37 <infinisil> cocreature: Is there nothing better?
12:03:38 <johnw> module names!
12:03:51 <johnw> https://stackoverflow.com/questions/26907427/filterm-for-containers-like-data-map-map-or-data-set-set
12:04:04 <johnw> "I did a benchmark between different implementations of filterMapM. It turns out that the round-trip through a list is actually pretty good."
12:04:31 <cocreature> infinisil: it’s not so bad, fromAscList and toAscList are O(n) and you can’t be faster than linear time anyway
12:04:53 <infinisil> Hmm.. I guess
12:05:16 <arkeet> it would seem like filterM should exist in Data.Set
12:05:37 <johnw> heck, I just want concatMapM to exist
12:05:48 <arkeet> what's concatMapM?
12:05:53 <johnw> fmap concat $ mapM
12:05:54 <infinisil> johnw: Interesting
12:06:06 <arkeet> :t \f -> fmap concat . mapM f
12:06:06 <johnw> i use it a lot
12:06:07 <lambdabot> (Monad f, Traversable t) => (a1 -> f [a2]) -> t a1 -> f [a2]
12:06:08 <dmwit> Seems like the only obvious place to win (compared to the "via lists" solution above) would be in deforesting. That seems like it would be very finicky code to write.
12:06:25 <dminuoso> Sigh.. Im getting this huge pile of mess. Lazy and strict bytestrings.. :|
12:06:54 <paidnode> well, according to its type it currently accepts all tiles.
12:07:25 <ZeuPiark> hello
12:09:19 <dmwit> paidnode: Consider `data Located a = Located { coordinates :: Coordinates, value :: a }` or similar.
12:09:58 <dmwit> paidnode: Now you can distinguish between `Located TileType`, `Located Tree`, and `TileType` -- each useful in different situations.
12:11:19 * hackage texmath 0.11 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.11 (JohnMacFarlane)
12:11:43 <infinisil> johnw: Heh, you won't be happy about what I'm currently coding
12:11:54 <johnw> infinisil: what is that?
12:12:33 <infinisil> A function that determines free variables of Nix expressions, by calling nix-instantiate
12:12:38 <johnw> hahaha
12:12:55 <johnw> https://github.com/haskell-nix/hnix/blob/pending/src/Nix/TH.hs#L37
12:13:22 <infinisil> Heh
12:13:37 <infinisil> Well it was fun anyways, but I should probably use that one instead
12:13:45 <infinisil> It works though!
12:14:18 <infinisil> (Well with a minor restriction)
12:14:36 <infinisil> johnw: Why is that function in TH though?
12:17:07 <paidnode> dmwit: great, solves exactly what my issue is. I don't ften write code as I find it difficult to find hobby projects... it's a pity, no reading/learning makes up for it indeed (not haskell specific). thanks for the suggestion
12:17:11 <xliii> are foldl and foldr confusing in the beginning?
12:20:03 <jle`> they are commonly confusing in the beginning yes
12:22:20 <paidnode> on the other hand though, using data Tile a = Tile { tileType :: a, coordinates :: Coordinates } now I can only construct matices of where all elements are of the same tiletype: Matrix (Tile a)
12:23:18 <lyxia> paidnode: Matrix (Tile TileType)
12:26:00 <paidnode> lyxia yeah, so I can have e.g. Matrix (Tile Bear), but that way there are only bears in my matrix
12:26:18 <paidnode> maybe Im misunderstanding what you're trying to say
12:27:04 <lyxia> paidnode: It looks like you want to get rid of your TileType type for some reason
12:27:32 <lyxia> but if you keep it, then (Matrix (Tile TileType)) is a fine way to represent a matrix of different tiles
12:28:46 <lyxia> Things may be confusing because the word "type" is used in two ways here. There is Haskell's notion of type, and your game's notion of tile type.
12:29:39 <paidnode> it would've helped if I had tried your example without a typo in TileType haha
12:31:53 <chessandgo> how are you supposed to manage threads in haskell? Anything deeper than one level seems to turn into a horrible mess
12:32:29 <paidnode> chessandgo: are you aware of Simon Marlow's book on the matter?
12:32:46 <johnw> infinisil: only because right now it's the sole user of that function; and I need to not consider it free *in that context* if there's no Haskell binding available, which would allow `with` to provide the symbol at runtime
12:33:11 <chessandgo> Real World Haskell, or is that someone else?
12:33:18 <paidnode> someone else
12:33:25 <electrocat> Parallel and Concurrent Programming in Haskell
12:33:30 <electrocat> chessandgo: ^
12:33:31 <shapr> best answer
12:33:34 <infinisil> johnw: Ah yeah
12:33:52 <infinisil> Oh no, hnix doesn't compile with my dependencies :(
12:34:02 <johnw> what are they?
12:34:21 <infinisil> lts-11.7
12:34:26 <electrocat> oh
12:34:28 <electrocat> bullshit
12:34:28 <infinisil> Along with a bunch of extra-deps
12:34:51 <electrocat> the book is no longer available to read without buying
12:35:14 <infinisil> johnw: "Exception when trying to run compile-time code:            data/nix/corepkgs/derivation.nix: hGetContents: invalid argument (invalid byte sequence)"
12:35:33 <johnw> infinisil: very odd; have you pulled submodules?
12:35:49 <paidnode> electrocat: I didn't know it was ever available for free online. Anyway, not long ago it ws part of the functional programming humble bundle, pretty good deal.
12:36:01 <infinisil> johnw: I'm just using stack
12:36:03 <chessandgo> rip. I'll have to look into it
12:36:04 <electrocat> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/ch01.html
12:36:12 <electrocat> nvm, it just moved somewhere else
12:36:17 <paidnode> I read some of it, it really makes the topic very accessible even to beginners
12:36:25 <infinisil> johnw: How are you compiling it normally?
12:36:33 <electrocat> yeah, it was one of my first haskell books
12:36:51 <johnw> infinisil: just "nix-build"
12:37:26 <infinisil> I guess I could try that, but I honestly have little idea how I could use a package from source with stack
12:37:57 <infinisil> It's sad that it doesn't work with stack right now at least :/
12:38:08 <johnw> infinisil: once I'm off the phone, I'll help you get this working
12:38:20 <chessandgo> well he links to the online version on his site for free, so It doesn't seem he must mind very much on people reading it for free https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
12:38:40 <infinisil> johnw: If you have the time, sure :)
12:41:40 <electrocat> i've read it, but i might just buy it later because it was so useful
12:45:28 <paidnode> lyxia: "It looks like you want to get rid of your TileType type for some reason" - I think you are right. Now I can have tiles of tiletypes, but still cant specify tiles of e.g. bears only in the type signature. On the other hand, I can have tiles of something other than tiletypes, but unless I have separate Bear/tree etc data types there's no need for that ability
12:46:21 <zenwanderer> hi! a yet another noob question: i'm implementing a stateful algorithm in the ST monad (hopcroft-karp namely). What would be an appropriate way to pass an STUArray from the main ST action to a sub-function/subprocedure, without freezing/with no extra copying.
12:46:25 <paidnode> having separate bear/tree etc data types come with a need to have coordinates fields for each, which is the kind of repetition im trying to avoid
12:46:34 <paidnode> i guess im still at square one
12:46:41 <paidnode> tile one haha
12:48:11 <zenwanderer> afaik, an STUArray can't simply be passed from one ST s thread to another because of rank-2 types (besides all the other problems with that). So how would one divide an ST computation into several blocks?
12:48:57 <arkeet> what do you mean by blocks?
12:48:57 <paidnode> it just feels like inheritance would be a good answer here. what is the functional alternative though?
12:49:21 <arkeet> they can't be bassed between different invocations of runST/runSTArray
12:49:44 <glguy> So don't pass them between uses of runSTUArray, just pass the STUArray as a function parameter
12:49:54 <arkeet> but you can split up ST computations
12:50:09 <zenwanderer> one solution would be to define the sub-functions in a where block in the same runST*, with the arrays remaining in scope
12:50:22 <glguy> subprocedure :: STUArray s i e -> This -> That -> ST s Theother
12:50:47 <zenwanderer> glguy: right, that's obvious. don't know what I was thinking. thanks
12:52:19 <lyxia> paidnode: I don't think having a big sum type (TileType) that lists all of your individual tile types is that bad of a repetition.
12:53:32 <paidnode> so essentiall Bear {coordinates :: Coordinates} | Tree {coordinates :: Coordinates}, this is what I meant, is this what you mean too?
12:53:48 <paidnode> it's not like it is not survivable
12:54:25 <paidnode> just thought there is a better solution
12:54:38 <paidnode> class Locatable a where coordinates :: a -> Coordinates
12:54:46 <lyxia> paidnode: wait, what's wrong with separating the tag and the coordinate
12:54:49 <paidnode> is this typeclass idiomatic?
12:55:05 <paidnode> because it doesn't really care about its type parameter
12:55:39 <paidnode> the reason why I discarded my typeclass based approach
12:56:18 <paidnode> dik, just felt like it's not the way typeclasses are supposed to be used
12:57:12 <lyxia> If the only thing that distinguishes a bear from other tiles is the tag, then a function of a bear only needs the coordinates as an argument
12:57:37 <lyxia> funBear :: Coordinate -> Thing
12:57:57 <lyxia> would be your function that does something about a bear on the given coordinates.
13:01:09 <paidnode> what I'm trying to achive, is that if  I have a function Bear -> Matrix -> Matrix that represents the bear moving in the forest, it is impossible to pass a tree to it and move that tree to another tile
13:01:37 <paidnode> the function signature is for illustration purposes only haha
13:03:03 <[exa]> so it represents the bear's movement right?
13:03:31 * [exa] kindof puzzled about the type signature
13:03:55 * arkeet too
13:04:05 <arkeet> which bear?
13:04:31 <paidnode> that example, yes. then of course trees have other behaviors like aging, spawning samplings, so similar restrictions would need to be enfrced by a  Tree -> Matrix -> Matrix functions
13:05:00 <paidnode> *saplings
13:05:32 <[exa]> Matrix is some kind of linear-algebra-related matrix?
13:05:59 <[exa]> (sounds kindof like a managed alternative of the RealWorld)
13:05:59 <paidnode> it's what I chose for the 2d plane representing the forest
13:06:12 <[exa]> oh okay
13:06:18 <paidnode> https://www.reddit.com/r/dailyprogrammer/comments/27h53e/662014_challenge_165_hard_simulated_ecology_the/
13:07:00 <paidnode> its Data.Matrix from the matrix package
13:07:18 * [exa] smells markov chains
13:08:21 <aarvar> paidnode: hmm, seems a bit like critters
13:09:08 <[exa]> paidnode: it's kindof not right to represent objects by functions, functions are computations or "changes"
13:09:50 <[exa]> paidnode: but if you meant the 'change that some tree will do in the forest in time X" then yes it can probably be irght
13:10:02 <paidnode> getOlder:: Tree -> Matrix -> Matrix
13:10:09 <paidnode> spawnSapling :: Tree -> Matrix -> Matrix
13:10:22 <[exa]> the tree is already in the matrix?
13:10:50 <[exa]> (because if so, the first argument is mostly irrelevant)
13:10:53 <paidnode> yes, the trees, bears, etc are already elements of the matrix
13:12:56 <dminuoso> If I have a ReaderT and I want to drag two environments into my stack, would I just use a `ReaderT (A, B) ..` ?
13:13:35 <lyxia> yes
13:13:57 <[exa]> ReaderT in ReaderT is a nightmare
13:14:00 <paidnode> the first argument is irrelevant? I mean, sure there is going to be a timeStep:: Matrix -> Matrix somewhere around the top level, but once that passes control to functions that manipulate the matrix based on each tiles actions, where the e.g. the tree on the tile can change (age) itself...
13:14:09 <[exa]> (not sure if it's even possible)
13:14:35 <glguy> ReaderT in ReaderT is fine, you just use an extra lift to ask it, and all that should be hidden behind your top-level newtype around the monad transformers
13:14:36 <[exa]> paidnode: you can just give it the coords of the Tree/Bear/Lumberjack you are updating
13:15:27 <dminuoso> lyxia: Fair enough. Is it common or reasonable to start exporting composed lenses for things I somewhat frequently need to access? Or is it more common to compose lenses on the spot when I need them to read from my ReaderT?
13:15:37 * aarvar recently defined a reader transformer that adds to the environment
13:16:35 <aarvar> dminuoso: or try classy lenses
13:20:52 <dminuoso> aarvar: Oh that looks pretty nifty. :)
13:24:34 <paidnode> so I would have something like data Bear = Bear,  Tree = Tree Treetype and e.g. spawSapling :: Coordinates -> Tree -> Matrix -> Matrix??
13:25:08 <paidnode> *data Bear = Bear,  data Tree = Tree Treetype, just to disamiguate
13:25:50 <paidnode> I guess that would work, altough I don't know yet how the coordinates would be kept track of
13:26:20 <paidnode> but yes, it seems to solve both my type safety and repetition concerns
13:26:52 <ggVGc> sorry to ask, but for various reasons I have to ask. Do almonds form a monad?
13:27:51 <MarcelineVQ> idk but I have seen them used as a Comonad over Veganism
13:28:10 <ggVGc> good enough
13:28:11 <ggVGc> thanks
13:30:53 <paidnode> well i mean it would push the repetition from my data types to the types of my functions. Not sure why I find it intuitively so much more acceptable, in reality it would mean much more repetition than  Bear {coordinates :: Coordinates} | Tree {coordinates :: Coordinates}
13:32:37 <glittershark> the documentation for "unsafeLocalState" says "it is expected that this operation will be replaced in a future revision of Haskell". Does that mean I should be using unsafePerformIO instead?
13:32:38 <paidnode> ah, you meant spawSapling :: Coordinates -> Matrix -> Matrix and grab the tree from there...
13:32:38 <johnw> infinisil: you still here?
13:32:44 <infinisil> Yeah
13:33:11 <johnw> infinisil: do you use https://gitter.im/haskell-nix? We have others there who might be able to help too
13:33:29 <infinisil> I do not
13:33:35 <johnw> ok, no biggie, I'll privmsg you
13:48:26 * hackage ecstasy 0.2.0.1 - A GHC.Generics based entity component system.  http://hackage.haskell.org/package/ecstasy-0.2.0.1 (isovector)
13:51:06 <dmwit> paidnode: Re: "how do I make a tile with only Bears?", you might like my discussion on having app-level types and values without too much duplication here: https://stackoverflow.com/q/49946389/791604
13:51:25 <dmwit> I encourage you to read the question, then the second answer on that page, then the first answer.
13:52:04 <dmwit> (The first answer is how an expert would do it from the get-go, but for a new Haskell programmer, the second answer is a good stepping stone to understanding what problems are being solved by the language extensions.)
13:54:00 <electrocat> glittershark: it's implemented als unsafePerformIO, so yes
14:01:42 <tdammers> I'd say it means you should maybe revisit your design
14:01:48 <aarvar> dmwit: why have FilterType at all?
14:01:59 <EvanR> strong vs weak typing reference of the day "An implementation of a language is strongly typed if a compiler guarantees that the program it accepts will run without type errors"
14:02:09 <EvanR> (dragon book)
14:02:10 <aarvar> type Filter = ReportId -> IO (Record -> Bool)
14:02:23 <tdammers> EvanR: that's a weird notion of "type"
14:02:44 <EvanR> just keeping it weird over here
14:02:47 <electrocat> a well-typed program will run without type errors..
14:02:51 <EvanR> lol
14:02:56 <electrocat> that's basically preservation
14:02:58 <tdammers> EvanR: here in Haskell land, we say "type errors are axiomatically compile-time errors", and then we cover our ears and start singing loudly
14:03:26 <EvanR> the statement is in the section on type checking too so...
14:03:32 <tdammers> seriously though, that's not a very useful definition of anything there
14:03:54 <electrocat> the more formal definition is nicer
14:03:55 <EvanR> they are referring to dynamic type errors at runtime though
14:04:02 <EvanR> in the second half of the sentence
14:04:28 <tdammers> yeah, but when discussing type checkers, using the word "type" for one thing in one half of the sentence and for another thing in the second half is kind of confusing
14:04:39 <EvanR> "type error" is actually a method of the English typeclass :)
14:04:58 <tdammers> the English typeclass has no lawful instances
14:05:01 <EvanR> typeerror . typeerror (typeerror typeerror), could be four different things
14:05:24 <EvanR> haha
14:05:39 <aarvar> oh no, you're going to start another debate about whether words should be used correctly
14:05:48 <EvanR> goddammit :(
14:06:28 <EvanR> if anything weird uses of words are there to convince you no one is right
14:07:34 <tdammers> aarvar: no, this is more about whether it's OK to mix two incompatible usages of the same word within one sentence
14:07:52 <tdammers> aarvar: completely agnostic to the individual "correctness" of either usage
14:08:21 <tdammers> anyway, the definition can be read two ways
14:08:46 <EvanR> > [mempty, mempty, mempty] :: [String, Sum Int, All]
14:08:48 <lambdabot>  error:
14:08:48 <lambdabot>      • Expected a type, but ‘'[String, Sum Int, All]’ has kind ‘[*]’
14:08:48 <lambdabot>      • In an expression type signature: [String, Sum Int, All]
14:08:58 <aarvar> mathematical appropriation is not okay
14:09:03 <EvanR> mein leben
14:09:27 <electrocat> EvanR: o.O
14:09:40 <tdammers> if you use the type-theory definition of "type", then it becomes a tautology: in a strongly-typed compiler, the type checker guarantees that the compiler output will behave according to the type system
14:09:43 <EvanR> > (mempty, mempty, mempty) :: (String, Sum Int, All)
14:09:45 <lambdabot>  ("",Sum {getSum = 0},All {getAll = True})
14:10:12 <EvanR> the issue was supposed to be with "strongly typed" not "type error" :(
14:10:51 <aarvar> it's almost like "strongly" and "weakly" typed aren't particularly useful terms
14:10:53 <EvanR> imagine you are on a safari to the galapagos islands and you want to see all the different things strong and weak typing could be
14:10:56 <tdammers> right
14:11:10 <aarvar> nor are "static" and "dynamic" types
14:11:22 <[exa]> EvanR: that's where duck typing went extinct?
14:11:23 <EvanR> hey... whats wrong with that
14:11:35 <electrocat> usually "weakly" is referred to type systems that to implicit type conversions, no?
14:11:39 <tdammers> "strongly typed" is so ill-defined and means so many different things to different people
14:11:48 <dminuoso> electrocat: Yes.
14:12:07 <aarvar> but what is an implicit type conversion
14:12:20 <tdammers> aarvar: "type", here, usually means "tag"
14:12:25 <electrocat> a type conversion not explicitly mentioned by the programmer?
14:12:31 <EvanR> an implicit conversion where the source and dest happen to have different types >:)
14:12:33 <aarvar> so it means "not type", got it
14:13:14 <EvanR> warning lifeguard not on duty; define stuff at your own risk
14:13:19 <[exa]> btw guys why don't you use the implicit explanation of static/dynamic and strong/weak types by CH and models?
14:13:23 <tdammers> textbook example: you have a string concatenation operator, let's say it's ~; and you pass it two arguments that happen to be not strings
14:14:02 <electrocat> that could also be seen as ad-hoc polymorphism
14:14:15 <tdammers> in a "strongly typed" language, that's an error; in a "weakly typed" language, it would result in both arguments implicitly being converted into strings
14:14:17 <EvanR> no no...
14:14:20 <dminuoso> electrocat: Except no.
14:14:44 <[exa]> tdammers: isn't that subtyping? :D
14:14:47 <EvanR> please no Object which everything inherits "toString" from
14:14:52 <aarvar> (id :: forall a. a -> a) :: String -> String
14:14:54 <electrocat> wel it's implicit conversion if the type of -; is String -> String -> String
14:14:56 <aarvar> omg, type conversion
14:15:04 <dibblego> EvanR ♥ Java
14:15:08 <[exa]> :D
14:15:09 <tdammers> again, different meaning of "type"
14:15:38 <aarvar> tdammers: oh, sorry, I thought you meant "type" when you said "type"
14:15:41 <aarvar> my bad
14:15:44 <electrocat> lol
14:16:05 <EvanR> a literal definition of implicit type conversion, your value stays the same but compiler inserts unsafeCoerce in the most unreasonable places
14:16:17 <EvanR> thus converting the type
14:16:33 <tdammers> aarvar: I already said that in this context, "type" means "tag", and the only reason I'm using the word "type" here is because the established terms are "strongly/weakly typed"
14:16:38 <aarvar> could we just call it unsound typing?
14:16:51 <tdammers> aarvar: I am fully aware that from a type theoretical point of view this is utter nonsense
14:17:37 <electrocat> well i only have one definition of "type"
14:17:39 <EvanR> "in theory, all type errors could be caught at runtime. if the types were carried along during runtime" wahaha
14:17:41 <tdammers> if you prefer, we could use a hypothetical Haskell unitype like data Variant = Int Integer | String Text
14:17:59 <electrocat> but i live in a fantasy world where only haskell exists
14:18:02 <EvanR> you cannot deny a parallel world of usage
14:18:12 <aarvar> would it be accurate to say that "weak typing" is where something of type T can evaluate to something that's not of type T?
14:18:13 <monochrom> My algebraic data types are strongly tagged. :)
14:18:30 <EvanR> algebraic data tags
14:18:58 <electrocat> aarvar: not really, i would say ocaml is strongly typed, but things can 'evaluate' to super types
14:19:22 <tdammers> well, it's not even a black-and-white thing
14:19:50 <tdammers> most languages are neither fully strong nor fully weak
14:20:15 <[exa]> guys let's focus on fixing the wiki page on strong vs weak typing, which is rubbish
14:20:29 <aarvar> electrocat: what do you mean?
14:20:33 <monochrom> Is it rubbish? I think it's quite OK.
14:20:33 * hackage stratosphere 0.22.3 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.22.3 (jdreaver)
14:20:42 <tdammers> it's rubbish because the whole concept is ill-defined and fairly useless
14:20:46 <monochrom> But what is your fix?
14:20:52 <electrocat> oh yes
14:20:56 <aarvar> [exa]: maybe start with the wikipedia page on "monad (functional programming)"
14:20:56 <tdammers> the fix is to stop using the terms
14:21:04 <[exa]> lol
14:21:11 <tdammers> "this language is strongly typed" helps absolutely nobody
14:21:11 <electrocat> lets all agree the wiki page is stupid
14:21:17 <aarvar> https://en.wikipedia.org/wiki/Monad_(functional_programming)
14:21:20 <[exa]> +1
14:21:42 <aarvar> Someone listened to too much Douglas Crockford
14:21:46 <electrocat> omg
14:21:46 <EvanR> tdammers: another aspect of the ref is... they are defining strongly typed as a property of implementations
14:21:50 <tdammers> what you really need to know is which kinds of implicit conversions it allows, what its tag conversion semantics are in general, whether it does static type checking, etc. etc.
14:21:56 <electrocat> the monad page is actually worthless
14:21:58 <EvanR> not languages
14:22:02 <[exa]> it should clearly say that the concept is so ill-defined it leads to flamewars on irc
14:22:03 <aarvar> or Crockford based his talk on that page
14:22:05 <[exa]> :D
14:22:05 <monochrom> But I like Liskov and Jackson.
14:22:07 <aarvar> I'm not sure which came first
14:22:17 <aarvar> too lazy to check the history and figure it out
14:22:18 <tdammers> EvanR: yes, but as long as you roll with the cringeworthy definition given, that part at least makes sense
14:22:23 <EvanR> [exa]: honestly more things should be defined that way in encyclopedias
14:22:25 <monochrom> Especially Liskov in this context.
14:22:52 <tdammers> EvanR: because the definition is about how static type checker guarantees relate to runtime behavior, and that *is* first and foremost a property of the implementation
14:23:04 <tdammers> although of course many languages explicitly define this relationship
14:23:06 <EvanR> yeah i am still trying to grok the definition as is
14:23:13 <EvanR> not metadecompile the linguistics
14:23:16 <aarvar> EvanR: an implementation is strongly typed if it actually correctly implements the type system, and weakly typed if it's totally broken
14:23:18 <aarvar> duh
14:23:44 <electrocat> or maybe weakly typed means broken by design
14:23:48 <tdammers> I think what the definition tries to define is actually "typed"
14:23:48 <[exa]> :D
14:24:13 <EvanR> in other words, reading between the lines, it defines a property of an implementation if the type system stops runtime type errors from ahppening
14:24:24 <aarvar> "a monad defines what it means to chain operations together"
14:24:35 <electrocat> a monad is just pipes guys
14:24:39 <electrocat> or a burrito
14:25:04 <tdammers> EvanR: stops a certain class of runtime errors from happening. But otherwise, yes.
14:25:13 <EvanR> expanding on that, ghc haskell is not stringly typed
14:25:19 <EvanR> uhg
14:25:22 <EvanR> not strongly typed
14:25:23 <electrocat> stringly :p
14:25:27 <electrocat> like bash? :p
14:25:55 <tdammers> "Monads are smart pipes with effects" -- Uncle Bob. I rest my case.
14:25:57 <EvanR> because! you could express your problem with sum types standing in for dynamic types, and then be forced to crash when things dont match up, at runtime
14:26:14 <EvanR> the implementation did not stop it
14:26:36 <tdammers> EvanR: well, if you interpret it this way, then the definition is 100% useless, or 100% tautological.
14:26:46 <aarvar> ah, strongly typed is where your program never produces any runtime errors ever
14:26:48 <EvanR> thats the beauty of it
14:27:03 <aarvar> coq is strongly typed
14:27:34 <EvanR> or PHP with errors turned off
14:27:46 <aarvar> (especially since you never run the programs anyway)
14:27:57 <EvanR> its a white screen not an error
14:28:42 <aarvar> just do what my CS teacher taught us and catch all exceptions asap
14:28:52 <electrocat> something something progress, something something preservation
14:28:54 <aarvar> now I get it, he was showing us how to write strongly typed code
14:28:58 <tdammers> well, technically you can just run your code in a VM - as long as the VM host process is programmed well, the code will only ever crash the VM, but from the point of view of the host OS, that's not a runtime error
14:30:31 <EvanR> hold on, if errors are so easy to make. why dont we rethink our problems so that the errors are what we want. failure would be any NON error
14:30:44 <EvanR> according to the spec
14:30:49 <electrocat> yeah
14:30:52 <electrocat> just change the spec
14:30:54 <dminuoso> aarvar: Ah I dont know whether classy lenses _actually_ help. Im getting some bizarre problems
14:31:02 <electrocat> we have been fixing bugs all wrong guys
14:33:14 <EvanR> if murphys law applies, then youd probably find it hard to make these errors when you want to. but its ok, because behind this door you have the original spec, which has been fulfilled with your new "errors" (original successses)
14:33:30 <EvanR> universe fooled
14:33:38 <electrocat> checkmate universe
14:34:22 <aarvar> hm, are there any FP pages on wikipedia that *aren't* terrible?
14:34:33 <EvanR> not that i have seen
14:34:45 <EvanR> c2wiki has been catching up on that front though
14:35:48 <aarvar> dminuoso: such as?
14:44:00 <electrocat> aarvar: do you still have those FD examples?
14:44:12 <electrocat> the issues you had with the liberal coverage condition
14:44:12 <aarvar> electrocat: sure, why?
14:44:24 <aarvar> you want to submit a bug report?
14:44:29 <electrocat> might include them in my research
14:44:36 <aarvar> hm
14:44:41 <aarvar> one sec
14:45:20 <aarvar> electrocat: here's the most outrageous example https://gist.github.com/aaronvargo/b055acdf10e9cc63d14b4bfdc7695759
14:45:35 <aarvar> same situation if you replace Rep with Rep1
14:45:47 <aarvar> though with Rep it might actually be correct for it to fail. I have no idea
14:45:58 <aarvar> (in which case the instance succeeding is the bug)
14:46:35 <aarvar> electrocat: also had another example where I had code which I think violated the fundeps but still passed
14:46:58 <aarvar> think I deleted it, but I could write it again
14:47:19 <electrocat> note that you are using UndecidableInstances :p
14:47:39 <electrocat> your example probably violates some termination condition
14:47:50 <aarvar> electrocat: why does a type alias change it
14:47:57 <aarvar> it's a bug either way
14:48:09 <dminuoso> aarvar: For some really strange reasons Im having trouble using `type Handler s = ReaderT Env (MaybeT IO) s` in my signatures.
14:48:37 <dminuoso> Im getting so many weird ambiguous type variable errors that seem to disappear when I switch from `Handler Foo` to `MonadReader Env => m Foo`
14:48:45 <tdammers> EvanR: this isn't even an outrageous idea, it's been mused about before. Unfortunately, it turns out that besides "programs that provably do something desirable" and "programs that provably do something undesirable", there is a third category, "programs of which we cannot prove either"
14:48:47 <aarvar> electrocat: and afaiu Undecidable instances does let you violate fundeps
14:48:54 <aarvar> dont know if that's on purpose or not
14:49:16 <tdammers> and that third category is what we want to tackle - but simply flipping "desirable" and "undesirable" does nothing for those nasty fuckers
14:49:22 <aarvar> years ago I played with using broken fundeps to fake injective type lambdas or something
14:50:20 <glguy> dminuoso: You should "eta convert" type synonyms when possible, so: type Handler = ReaderT Env (MaybeT IO)
14:51:03 <aarvar> glguy: that can't cause ambiguous type errors though
14:51:28 <glguy> I don't know what dminuoso's particular problem is, this is probably orthogonal
14:52:15 <electrocat> aarvar: exactly, it lets you violate some conditions, which can brake things even more
14:52:36 <aarvar> electrocat: still doesn't explain why a type alias would change anything
14:52:45 <electrocat> break*
14:54:22 <aarvar> electrocat: and does UndecidableInstanes not disable termination conditions?
14:54:42 <electrocat> i don't get your point
14:54:55 <aarvar> oh, nvm
14:55:38 <aarvar> I guess you meant that not meeting the termination conditions is perhaps what causes the bug
14:55:54 <electrocat> oh no
14:56:13 <aarvar> why would it fail due to not meeting a termination condition if UndecidableInstances is enabled?
14:56:36 <aarvar> I thought that was the point of the extension
14:58:02 <electrocat> my point is that regardless of the bug, your instance might cause other problems
14:58:22 <aarvar> well, so far it hasn't, and I don't think it should
14:58:31 <electrocat> i used my FD implementation on your example and i ran into termination issues
14:58:40 <aarvar> well, maybe if there's no definition of Rep
14:58:53 <aarvar> In my actual code Rep has an implementation
15:00:09 <electrocat> that shouldn't matter
15:00:16 <aarvar> why not?
15:00:22 <aarvar> I would think it should matter
15:00:48 <aarvar> If it's undefined then Rep may not be injective
15:00:51 <electrocat> oh
15:00:53 <electrocat> it might
15:00:57 <aarvar> but I don't know
15:01:04 <aarvar> can you treat a stuck type family as being injective?
15:01:08 <aarvar> maybe
15:01:38 <aarvar> but the problem isn't related to this, since Rep1 definitely is injective, and has the same problem
15:02:29 <electrocat> or my implementation might just be broken
15:03:09 <aarvar> well, ghc's certainly is
15:03:24 <electrocat> lol :p
15:03:40 <aarvar> but it's okay, we have type families!
15:03:49 <aarvar> which were a mistake, but oh well!
15:03:57 <electrocat> mistake o.O
15:04:06 <aarvar> at least, the way they work now, yes
15:04:18 <electrocat> what makes you say that?
15:04:28 <aarvar> stuck type families for one
15:05:03 <aarvar> electrocat: https://gist.github.com/aaronvargo/46dcf7c08a90bb41818cd8fb41d9a6b1
15:05:12 <aarvar> there's a gist I apparently made a month ago
15:05:44 <johnw> all happy type families are alike
15:06:23 <arkeet> dminuoso: how about type Handler = ReaderT Env (MaybeT IO) ?
15:06:35 <aarvar> electrocat: every kind is inhabited by an infinite number of types!
15:06:38 <aarvar> isn't that wonderful?
15:07:01 <aarvar> and now there's also data families of any kind, so you don't even need to resort to such tricks
15:07:15 <aarvar> and data families are also allowed to be stuck
15:07:27 <aarvar> data family Foo :: Void
15:07:45 <aarvar> data family FileNotFound :: Bool
15:08:41 <dminuoso> glguy / arkeet: Sigh... turns out intero was borked up completely again..
15:08:44 <aarvar> type family Not (x :: Bool) where Not True = False; Not False = True; Not FileNotFound = lolwat
15:08:56 <dminuoso> Should pratice typing `SPC m i k` when seeing error...
15:09:08 <aarvar> should practice not using intero
15:09:13 <dminuoso> Heh
15:09:13 <electrocat> aren't these promotion related issues? :p
15:09:26 <johnw> does ghc-mod work with Nix yet?
15:09:36 <electrocat> well ghc-mod doesn't work with ghc yet :p
15:09:40 <Clint> zing
15:09:45 <aarvar> electrocat: they're "the type system is a mess" issues
15:09:47 <johnw> lol
15:11:11 <aarvar> then type families also lead to all the type roles uglyness, but so does global typeclass coherence, so no loss there really
15:14:41 <aarvar> electrocat: would make much more sense to have associated types which are constrained like normal class members are
15:15:09 <electrocat> like we used to have?
15:15:17 <electrocat> but we made them open in 2008
15:15:59 <aarvar> `class Foo a where type Bar a` should create a type family Bar (a :: Type) :: Foo a => Type
15:16:02 <aarvar> or whatever
15:16:09 <aarvar> I don't know, I didn't know how to program in 2008
15:17:16 <electrocat> the class constraint is not required
15:17:25 <electrocat> and that's how they used to work
15:17:41 <aarvar> the constraint should be required
15:17:46 <aarvar> then you can't have stuck type families
15:17:56 <aarvar> (well, unless you have non-termination)
15:18:33 <electrocat> the constraint would be implicitly guaranteed?
15:18:43 <aarvar> type families are just broken promoted type classes
15:18:50 <aarvar> er, type-level typeclasses
15:18:58 <aarvar> electrocat: what do you mean?
15:19:14 <electrocat> well Bar is defined in terms of Foo
15:19:22 <aarvar> I mean, type Baz (a :: Type) :: Type where Baz x = Bar x would be illegal
15:19:31 <aarvar> because the constraint Foo a isn't satisfied
15:19:37 <aarvar> for example
15:20:02 <aarvar> and saying foo :: Bar String would be illegal if there's no `Foo String` instance
15:20:03 <electrocat> aha
15:20:17 <aarvar> then the thing in my gist wouldnt work
15:20:37 <aarvar> you wouldn't be able to instantiate ANY to any kind (e.g. Void)
15:22:37 <aarvar> that would also mean that ghc wouldn't be able to just instantiate ambiguous type variables with Any
15:22:55 <aarvar> instead it would have to search for a legal value
15:23:36 <electrocat> we used to have an instance context restriction
15:23:59 <aarvar> what did that do
15:24:30 <electrocat> the type class constraint
15:24:38 <electrocat> it had to be satisfied
15:24:44 <electrocat> but it was formalized some other way
15:25:21 <electrocat> but you suggest some hybrid solution
15:25:30 <aarvar> what's hybrid about it
15:25:56 <aarvar> on the other hand, all this weirdness enables certain hacks which can be useful for working around other problems with the type system
15:29:10 <electrocat> ough
15:29:14 <electrocat> this has been a while
15:29:19 <electrocat> don't feel like rereading the papers
15:34:57 <electrocat> baz x = bar x is illegal btw
15:35:30 <aarvar> electrocat: what?
15:36:11 <electrocat> it violates termination conditions
15:36:21 <electrocat> which you can lift with UndedicableInstances, nvm
15:36:25 <aarvar> ^
15:36:41 <aarvar> pretty much any significant use of type families requires UndecidableInstances
15:37:02 <aarvar> to the point where DecidableInstances are practically useless
15:38:29 <aarvar> Can UndecidableInstances even cause type families to loop?
15:38:34 <aarvar> don't they just get stuck?
15:38:44 <aarvar> which they can do even without the extension?
15:40:34 <jared-w> All UndecidableInstances does is tell the compiler to not try to guess whether or not the type family code halts, iirc
15:40:54 <jared-w> (it has a really dumb and overly simplistic heuristic, currently; that's not necessairly bad though)
15:42:22 <aarvar> jared-w: are there type families which don't halt?
15:42:28 <electrocat> not sure if the implementation is capable of looping
15:42:43 <aarvar> pretty sure it just gets stuck
15:42:44 <jared-w> type families are essentially functions at the type level, are they not?
15:42:54 <aarvar> which is why it can handle infinite data structures
15:43:15 <aarvar> jared-w: not in the same sense as functions on the term level
15:43:20 <lyxia> there are no infinite structures at the type level
15:43:39 <aarvar> jared-w: afaik type families are reduced via constraint solving rather than evaluation
15:43:43 <aarvar> lyxia: yes there are
15:44:16 <jared-w> ah, gotcha. Yeah, I knew that bit; but might the constraint solving never halt in some cases with enough kitchen sink stuff turned on?
15:44:20 <aarvar> type family Infinite :: Nat where Infinity = S Infinity
15:44:32 <aarvar> foo :: Vect Infinity Int
15:44:35 <aarvar> I think that works
15:44:42 <aarvar> yay infinite vectors
15:44:58 <trcc> Hi guys. My question concerns nested maybes. Function A ( A :: IO (Maybe String) ) invokes function B ( B :: IO (Maybe String) ), and if there is a string (Just "yadayada") , then it should invoke function C ( String -> IO (Maybe String) ) with this string. If there is not a string, then Nothing should be returned. Same goes for function C and D. Any help on what I can do to avoid nested case expressions?
15:45:10 <aarvar> lyxia: of course, infinite lists work as well, etc
15:46:06 <aarvar> trcc: fwiw, IO values aren't functions
15:46:17 <aarvar> so A and B aren't functions
15:46:17 * hackage haskell-igraph 0.6.0 - Haskell interface of the igraph library.  http://hackage.haskell.org/package/haskell-igraph-0.6.0 (kaizhang)
15:46:27 <lyxia> aarvar: have you tried that definition
15:46:35 <aarvar> trcc: but you want MaybeT
15:47:05 <aarvar> trcc: http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html
15:47:36 <aarvar> I think
15:48:11 <aarvar> lyxia: no
15:48:16 <aarvar> I invite you to do so
15:48:21 <aarvar> pretty sure it works
15:48:21 <lyxia> I get a reduction stack overflow error
15:48:26 <aarvar> huh
15:48:30 <aarvar> maybe I'm wrong
15:48:32 * aarvar goes to check
15:49:37 <lyxia> https://gist.github.com/Lysxia/d6f76ae009dfb387fd573e89412e34f1
15:49:58 <aarvar> dang
15:50:03 <electrocat> ah
15:50:10 <electrocat> that's the infinite loop error :p
15:50:13 <aarvar> I thought infinite lists worked
15:50:20 <aarvar> at least at some point, some time ago
15:50:33 <trcc> Sorry, values
15:50:33 <trcc> maybeT, thank you. I will ook it up
15:50:37 <aarvar> maybe the final type still has to be finite
15:50:43 <aarvar> or maybe something changed
15:50:47 <aarvar> or maybe I remember wrong
15:51:00 <lyxia> well how do you unify two infinite lists
15:51:30 <aarvar> okay, nvm, it can loop
15:51:35 <aarvar> but it doesn't necessarily have to
15:51:45 <lyxia> If we don't unfold and try to be smart, we may get quite inconsistent behavior.
15:52:54 <aarvar> lyxia: I'm guessing it's still okay to use Take with an infinite list though
15:53:17 <aarvar> hm, I wonder if there's a way to make x type check
15:53:40 <lyxia> I think everything breaks as soon as there is a loop anywhere.
15:54:19 <lyxia> OCaml has equirecursive types, that gives you a subset of that, including that example above.
15:54:35 <jared-w> equirecursive types? Oooh, shiny
15:54:36 <lyxia> but it's hidden behind a flag.
15:54:43 <jared-w> Why does haskell not have that? Just curious
15:54:56 <aarvar> lyxia: equirecursive types are presumably a terrible idea
15:57:23 <electrocat> o.O
15:57:49 <electrocat> subsumption fucks up with type families
15:58:27 <lyxia> if Vec could be indexed by Infinity, wouldn't we have the same problems?
15:58:41 <aarvar> lyxia: yes
15:58:45 <aarvar> I didn't say it was a good thing
15:58:46 <aarvar> lol
15:59:10 <electrocat> ghci is not type checking my whole file
15:59:15 <lyxia> okay sorry I misunderstood!
15:59:20 <electrocat> it gives type errors when i call a function
15:59:56 <aarvar> lyxia: you should be able to define infinity, but only with a codata type :)
16:08:22 <orbisvicis> recommendations for json-rpc server/client ?
16:53:13 <ertes> orbisvicis: scotty + aeson, http-conduit + aeson respectively
16:53:49 <ertes> i believe there is a generic json-rpc library on hackage that you could use
16:55:25 <pavonia> electrocat: Do you have -fdefer-type-errors enabled by chance?
17:18:20 <loqoman_> Hey all, i'm a juinor in high school, taking honors algebra 2. I've been teaching myself Haskell through 'Real World Haskell'. In our class we recently started a project where we cover any mathimatical topic of our chosing, and present on it. I want to do my project involving Haskell, but i'm having trouble with inspiration. Any ideas?
17:22:51 * hackage inline-c-cpp 0.2.2.1 - Lets you embed C++ code into Haskell.  http://hackage.haskell.org/package/inline-c-cpp-0.2.2.1 (FrancescoMazzoli)
17:24:07 <replay> loqoman_: maybe this will help https://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
17:36:48 <Axman6> loqoman_: would logic count? the curry-howard correspondence might be interesting: discussing the correspondence between types and programs with logical propositions and proofs of those propositions
18:20:45 <sayola> using IncoherentInstances is ok, right? :p
18:22:26 <Welkin> the name of that extension makes me think it is a joke
18:22:28 <Welkin> like acme
18:23:04 <geekosaur> it's not a joke. sometimes it's necessary, but really, try anything else first
18:23:27 <geekosaur> especially sine it's really easy to get wrong, see for example the recent thread about trying to get at existence of typeclass instances
18:23:36 <geekosaur> (on -cafe)
18:27:05 <sayola> i would have to add one more complicated contraint on all related functions to get rid of this extension. but on the other hand, the only way this seem to go wrong, is when someone actually instances another unfitting type for my class.
18:29:36 <geekosaur> almost sounds to me like you want a closed type family instead
18:31:54 <sayola> hmm maybe
18:40:37 <sayola> geekosaur: so, closed type families do some kind of pattern matching on constraints?
18:41:01 <geekosaur> no. but neither does anything else
18:41:12 <geekosaur> you're making the very mistake I mentioned
18:41:17 <geekosaur> you *can;t get at* the constraint
18:41:35 <sayola> wouldn't try
18:41:37 <geekosaur> IncoherentInstances can sometimes appear to "help" but can easily bite you
18:42:10 <sayola> i guess so
18:44:54 <sayola> i got only one working instance. even though ghc is complaining about overlapping instances, but they are a) out of scope, b) couldn't be used, because of other constraints of the function. e.g. would only break, if someone writes an instance to fit the contraint.
18:49:21 <sayola> but tbh, i'm never totally sure what which extensions can do. so, i'd like to ask for details, i might have missed.
18:51:07 <glguy> sayola: You'd get more help if you could put the code up on a pastebin
18:51:48 <glguy> Generally if you're turning on IncoherentInstances you're doing something wrong
18:55:42 <sayola> someone knows, what happened to lpaste.net ?
18:55:58 <monochrom> Brain concussion.
18:56:02 <glguy> gist.github.com
18:56:45 <sayola> glguy: too mainstream. :D
18:57:21 <Welkin> so is git
18:57:38 <Welkin> use darcs
18:58:06 <monochrom> http://ix.io/
18:59:08 <sayola> https://gist.github.com/Vektorweg/7d05698325aa930b250a11080fc00d0b
18:59:35 <sayola> still had some github acc.
19:01:01 <glguy> sayola: Instead of this: instance (Vector v, Num a) => Num (v a); you should have one instance per type
19:01:09 <glguy> This overlaps with far too much
19:02:01 <sayola> but if i can generalize it that way, it works.
19:02:22 <Welkin> that makes me cringe
19:02:28 <Welkin> why would you want to overload so much?
19:02:32 <Welkin> that is just a big mess
19:02:44 <monochrom> At some point you have to answer "OK it works, problem solved, ticket closed".
19:02:51 <Welkin> treating vectors as numbers? O.o
19:02:58 <Welkin> just use vector-specific functions
19:03:31 <sayola> ok, maybe i shouldn't do that.
19:05:01 <Welkin> I feel there is a reasonable limit to generalization
19:05:14 <Welkin> at some point, you just have a ball of mud that is impossible to do anything with
19:05:19 <Welkin> like a god function
19:07:38 <sayola> i guess i dont want to end up like javascript. :p
19:07:49 <glguy> Popular?
19:07:53 <sayola> wasn't sure about a Num instance either.
19:08:19 <sayola> glguy: widely typed
19:10:38 <sayola> you know, where math operators work for every type.
19:13:05 <sayola> Welkin: is id a god function? because it works for every type. :p
19:14:57 <geekosaur> a god function tries to *do* everything. id tries to *be* everything but do nothing
19:15:13 <geekosaur> id isn't a god function, it's a zen function :p
19:15:34 <monochrom> Wait, in some religions, god is supposed to be everything and do nothing...
19:18:17 * hackage irc-client 1.1.0.3 - An IRC client library.  http://hackage.haskell.org/package/irc-client-1.1.0.3 (barrucadu)
20:04:14 <arahael> ring-zero is God.
20:08:48 * hackage unbound-generics 0.3.3 - Support for programming with names and binders using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.3.3 (AlekseyKliger)
21:00:52 * hackage monad-logger-prefix 0.1.10 - Add prefixes to your monad-logger output  http://hackage.haskell.org/package/monad-logger-prefix-0.1.10 (parsonsmatt)
22:05:21 <pavonia> Does anyone know of more complex GUI application written using the plain Haskell Win32 API?
22:08:04 <geekosaur> that sounds moderately horrific. there's a reason everyone wraps the win32 api
22:09:27 <geekosaur> (just like everyone uses a toolkit over xlib or xcb. if you need the low level stuff, sure, but it's painful for anything large.)
22:09:30 <pavonia> What kind of wrapper do you mean?
22:13:38 <pavonia> The thing is just, I'm trying to write a really, really simple GUI app using that API and already found a bug and undocumented behaviour for very essential features of the Win32 API. So I'm wondering if anyone has ever actually written any GUI app using that API port
22:15:58 <cocreature> I wouldn’t be surprised if nobody has :)
22:17:10 <jchia> Is there a function to convert between different integral types and errors or produces Nothing when the value cannot be represented?
22:18:52 <jchia> fromIntegral will just silently drop most-significant bytes
22:20:14 <jchia> I guess I'll just have to write the function myself and add it to my custom prelude
22:24:31 <jle`> is there an uncons but like for init/last
22:25:05 <cocreature> jle`: there is an "unsnoc" in various packages, e.g., extra and protolude
22:25:38 <pavonia> jchia: The convertible package seems to have that
22:31:24 <Cale> snoc is the sound effect that it makes when you add something to the end of a list
22:31:49 <jle`> cocreature: ah thanks
22:37:32 * hackage aeson-decode 0.1.0.0 - Easy functions for converting from Aeson.Value  http://hackage.haskell.org/package/aeson-decode-0.1.0.0 (chris_martin)
22:37:50 <dminuoso> Good morning folks. If for some sum type `data R = ...`, how can I enforce in the type system that only some `f :: R -> R` functions are allowed for some correct choices of the constructor?
22:37:58 <jchia> pavonia: Thanks
22:38:03 <dminuoso> This gist (hopefully) illustrates my problem: https://gist.github.com/dminuoso/269fbe2900cc733736e0a419634a8cae
22:38:23 <dibblego> you'd make a different data type
22:38:38 <dibblego> then you use classy prisms for compatibility between the two
22:40:35 <dminuoso> dibblego: Can you elaborate on how that would look like? Im a bit unsure how to express this. Would I have to look at GADTs for this?
22:41:39 <dibblego> data S = AccRej' | AccAcc'; data ActRes' = ActRes'; data SrvSta' = SrvSta'
22:41:57 <dibblego> then for each of those constructors: class AsAccReq a where _AccReq :: Prism' a ()
22:42:12 <dibblego> instance AsAccReq R where … -- the prism for the AccReq constructor
22:42:34 <dibblego> class AsAccRej a where _AccRej :: Prism' a ()
22:42:39 <dibblego> instance AsAccRej R where …
22:42:46 <dibblego> instance AsAccRej S where …
22:42:50 <dibblego> etc etc
22:45:10 <dibblego> you'll need to import Control.Lens to get Prism'
22:45:55 <pavonia> dminuoso: Do you want to chain requests and responses, or why do they have the same parameter type?
22:48:16 <dminuoso> pavonia: It's part of a protocol specification. You get a `Packet` and you have to respond with a `Packet`. R represents a tag for differnet packet types
22:50:22 <dminuoso> dibblego: You kind of lost me completely.
22:50:55 <dibblego> dminuoso: hmm ok, I am about to do a call, but I can expand a little later
22:55:47 <dibblego> dminuoso: I have 3 minutes, let's do it
22:55:47 <jackdk> dminuoso: https://pastebin.com/P0SkLvWE , does something like this help? I think some of it would be better done with `singletons`
22:56:15 <jackdk> but the gist is that it tags the packet with a "colour" and then the type family decides what the correct response "colour" is
22:56:37 <dminuoso> jackdk: But let's say that both G and B are valid responses for R.
22:56:47 <dminuoso> jackdk: The main problem I have is finding a way to express this sum in all of this
22:58:13 <jackdk> rereading your `f.hs`, the equivalent "colour" would represent both response types and the two response types will have the same "colour" in teh gadt.
22:59:13 <dibblego> dminuoso: https://gist.github.com/dminuoso/269fbe2900cc733736e0a419634a8cae#gistcomment-2585746
23:04:12 * hackage status-notifier-item 0.2.2.0 - A wrapper over the StatusNotifierItem/libappindicator dbus specification  http://hackage.haskell.org/package/status-notifier-item-0.2.2.0 (eyevanmalicesun)
23:08:42 * hackage gtk-sni-tray 0.1.2.1 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.2.1 (eyevanmalicesun)
23:11:14 <dminuoso> dibblego: I think you may be overestimating my grasp on Haskell or lens.
23:12:09 <dminuoso> jackdk's gist seems more approachable for me right now
23:18:25 <dibblego> ok
23:27:09 <jackdk> dminuoso I fear that it won't scale if you have a more complex protocol - if a packet type could be returned in two different responses you'll have a bad time
23:28:12 <jackdk> I tried to put something together with type-level lists (returned by the `NextPacket` family but properly named `Response`) and it started to get hairy.
23:31:12 * hackage json-tracer 0.0.3.0 - A polymorphic, type-safe, json-structured tracing library  http://hackage.haskell.org/package/json-tracer-0.0.3.0 (autotaker)
23:33:12 * hackage data-index 0.1.0.0 - Extending the concept of indices for lists and other containers  http://hackage.haskell.org/package/data-index-0.1.0.0 (IlyaPershin)
