00:00:05 <dminuoso> gonz_: why is OCaml a terrible language to learn?
00:00:46 <gonz_> dminuoso: For a programmer looking to enter the job market with it? Because there is almost no job market for it. To say that Haskell has too little use in industry and then turn around and say OCaml is a better alternative is misguided.
00:01:10 <gonz_> OCaml sees next to no use in industry and given what it gives up to "pragmatism" that's a massive loss compared to Haskell
00:01:45 <gonz_> If the measuring stick is "How good will it be on the job market?", OCaml loses to even Haskell
00:02:06 <gonz_> That was the argument given by marxS against learning Haskell; it's not used enough in industry.
00:02:21 <marxS> sure, but it wasn't my argument to go toward ocaml
00:02:23 <gonz_> Look at even one job board and you'll notice Haskell consistently has ~3 times more listings
00:02:58 <kuribas> monad: curry is interesting, as it combines FP with logic programming.
00:03:51 <kuribas> monad: but it isn't really useful for practical projects
00:04:00 <gonz_> marxS: Like I said, if this is mostly a business decision to you, learn Scala or something. It's super popular and you'll use a lot of FP. If you want to go into the deep end and learn to think differently I don't think there is a better language for doing that than Haskell. Perhaps Idris and friends, but I assume we're not quite talking that hardc
00:04:00 <gonz_> ore.
00:04:08 <rotcev> i've been seeing some languages pop up here and there which are basically haskells on the jvm
00:04:51 <jchia> Can I convert a Ptr to a Addr#? I'm trying to use copyAddrToByteArray#.
00:04:51 <gonz_> rotcev: Eta is one, yeah. It seems to try to "do it all", but the target is GHC 7.10 as far as I know.
00:05:08 <rotcev> gonz_: There is also one called Frege, but I stopped following it
00:05:12 <monad> and when someone says 'haskell' is slow, does that mean 1. 'haskell' the language is slow or 2. the compiler doesn't generate fast code?
00:05:55 <MarcelineVQ> it means whatever that specific person meant
00:06:09 <kuribas> monad: ghc isn't slow by any standard
00:06:24 <systemfault> Usually it means "using the canonical compiler, when I compile my code, I get slow execution"... but the cause could really be anything.
00:06:57 <kuribas> the compiler gets criticised for being slow, but so is C++.
00:07:10 <gonz_> monad: It means whatever someone was doing wasn't able to be optimized correctly, likely, in practice. GHC does a shitload of stuff to optimize stuff, but there are cases where it just can't
00:07:18 <monad> i am asking can haskell be faster than c or any other "fastest" programming language?
00:07:25 <systemfault> monad: No.
00:07:48 <systemfault> C and C++ are much lower level.
00:07:51 <tdammers> that is a completely meaningless question
00:08:11 <monad> lol tdammers why?
00:08:12 <kuribas> monad: theoretically yes, in practice no.  Rewrite rules should be able to generate code that is faster than C, but the compiler is simply not fast enough.
00:08:25 <cocreature> jchia: GHC.Ptr exposes the constructor
00:08:28 <MarcelineVQ> ", but the compiler is simply not fast enough." ???
00:08:28 <tdammers> because it doesn't matter how fast you can make something given infinite effort
00:08:31 <monad> ok got it
00:08:49 <kuribas> MarcelineVQ: I mean the code generation is not as advanced as in gcc
00:08:52 <monad> ah i see
00:08:56 <systemfault> monad: Does it matter though? Depends on what you're writing.
00:09:00 <tdammers> what you're really interested in is how much effort it takes to achieve the performance, reliability, and features that you need
00:09:05 <tdammers> for any given project, that is
00:09:06 <jchia> cocreature: Thanks. Didn't notice that.
00:09:18 <gonz_> monad: I think the value proposition of Haskell is correct, concise code that executes *very* fast, not C-fast.
00:09:22 <monad> i was looking at haskell GPipe and quake3 in haskell
00:09:25 <systemfault> Haskell programs don't usually segfault as much.
00:09:31 <monad> would be good for gaming
00:09:42 <cocreature> jchia: generally clicking on the “source” link and seeing where it takes you is a pretty good first step if you are trying to figure out the module that exposes a constructor
00:09:51 <tdammers> also, there are (at least) two conflicting metrics when it comes to "execution speed": latency and throughput
00:10:16 <tdammers> GHC-Haskell performs well on the throughput front, but latency can be an issue due to garbage collection
00:10:26 <monad> cool
00:10:36 <Ariakenom> "conflicting"
00:10:52 <monad> yeah probably not conflicting
00:10:59 <tdammers> well, somewhat conflicting
00:11:17 <tdammers> you can usually achieve better throughput by sacrificing latency, and vv.
00:11:31 <monad> physical and engineering tradeoffs rather than conflicts
00:11:51 <EvanR> were not dealing with quantum incompatible variables yet
00:11:58 <EvanR> but decades of cruft
00:12:01 <tdammers> if you prefer to word it that way, sure
00:12:40 <monad> cool
00:13:19 <kuribas> tdammers: I heard conflicting opinions about latency, some people say it works for them, others say it's a problem.
00:13:52 <Ariakenom> I mean there are probably several things that improve or impair both. But some that improve one and impair the other.
00:14:03 <iqubic> Why is haskell not low level?
00:14:04 <tdammers> kuribas: well, depends how tight you need it to be, and what exactly it is your code is doing. The main issue is that you can't reliably control it very well.
00:14:07 <cocreature> kuribas: I’m not sure those are conflicting opinions. some people just don’t have tight latency requirements or their code puts less stress on the GC
00:14:27 <kuribas> yeah, that could be it
00:14:54 <dminuoso> Why does <$> use the characters it uses? Was that choice intentional to look similar to ($) ?
00:15:27 <tdammers> dminuoso: I think so, yes. < > for applicative style syntax, $ to mimic $
00:15:30 <EvanR> that might have been a bad choice
00:15:37 <EvanR> since <*> is the analog to $
00:15:57 <marxS> what's best resource for learning haskell? in college we used LYAH but last I heard people were saying not to use it
00:15:59 <kuribas> dminuoso: ($) :: (a -> b) -> (a -> b), (<$>) :: (a -> b) -> (f a -> f b)
00:16:09 <dminuoso> marxS: CIS194 is probably most frequently named in this channel
00:16:16 <kuribas> dminuoso: <$> is more general than $
00:16:17 <Ariakenom> except to look like $ not ($)
00:16:27 <marxS> ok thanks kuribas will check it out
00:16:27 <gonz_> marxS: People say good things about http://haskellbook.com/
00:16:32 <systemfault> CIS194 is probably the best free resource.
00:16:34 <monad> marxS maybe try this https://www.schoolofhaskell.com/school/starting-with-haskell/haskell-fast-hard
00:16:55 <kuribas> marxS: it's interesting how they use logic variables for channels
00:17:11 <iqubic> What is CIS194?
00:17:12 <geekosaur> marxS, LYAH is fine (*if* you get exercises to go with it from somewhere (which is why it was ok for a college course). I'd probably go with CIS194
00:17:16 <geekosaur> @where cis194
00:17:16 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
00:17:35 <kuribas> dminuoso: $ is <$> with Identity
00:17:38 <marxS> any reason why the spring 13 one?
00:17:44 <marxS> as opposed to fall 16
00:17:49 <dminuoso> Part of the reason Im asking, is because lens defines (&) = flip $; (<&>) = flip <$>
00:17:49 <geekosaur> later ones changed it and it doesn't seem to work as well
00:17:51 <kuribas> dminuoso: well, upto isomorphism
00:17:51 <rotcev> i was going to say - when I first toyed with haskell LYAH is what everyone suggested
00:17:54 <marxS> oh ok
00:17:55 <dminuoso> kuribas: Right.
00:18:24 <geekosaur> I mean, you can try it if you want but spring13 seems to get the best reviews / be ,ost effective for learning
00:18:41 <geekosaur> rotcev, for a long time lyah was aboutt he only real option
00:18:49 <geekosaur> but it's kinda useless without exercises
00:19:10 <rotcev> yeah i guess that was my problem when i used that book
00:19:23 <kuribas> dminuoso: of course bind (<<=) is a generalisation of apply ($
00:19:34 <kuribas> dminuoso: ($) as well
00:19:49 <geekosaur> so you can learn how to read haskell code, but are still lost about writing it
00:20:08 <dminuoso> kuribas: Just to avoid confusion. When you say `bind (<<=)` - is there a typo in that?
00:20:13 <systemfault> When I personally was done with LYAH, I knew a few haskell constructs and ideas... but still couldn't write anything using them, so I felt lost.
00:20:17 <dminuoso> (because that looks like extend)
00:20:19 <kuribas> dminuoso: yeah, I mean (=<<)
00:20:27 <kuribas> dminuoso: the flipped version of (>>=)
00:20:29 <marxS> for what it's worth, the haskell course from my school is here: https://www.inf.ed.ac.uk/teaching/courses/inf1/fp/ (and it has problem sets - with solutions, and all lecture notes, books etc)
00:20:34 <marxS> and was designed by phil wadler
00:20:41 <marxS> might be a useful resource to some people
00:20:51 <gonz_> marxS: Thanks. :)
00:21:05 <monad> thnx marxS
00:21:34 <tdammers> I think the main reason why people recommends against LYAH is because it is sloppy in explaining things, and that can easily bite you later
00:21:39 <dminuoso> marxS: Ultimately the best resource depends a bit on you really, your existing background.
00:21:44 <kuribas> dminuoso: ($) :: (a -> b) -> (a -> b); (=<<) :: (a -> m b) -> m a -> m b
00:21:59 <marxS> dminuoso,  well believe it or not I took the above course before
00:22:08 <marxS> although it was 3 years ago
00:22:16 <kuribas> dminuoso: weren't you the one to explain to me why monad is a monoid?
00:22:47 <dminuoso> kuribas: yeah
00:22:55 <rotcev> LYAH seems like a 10000ft overview of a lot of things
00:23:06 <kuribas> dminuoso: so then this should be familiar :)
00:23:55 <monad> monad is a monoid?
00:24:06 <kuribas> monad: are you?
00:24:12 * rotcev laughs
00:24:23 <monad> i am interested too
00:24:27 <monad> can you explain
00:24:37 <rotcev> you learn something new about yourself every day
00:24:39 <dminuoso> monad: how well versed are you in category theory?
00:24:46 <kuribas> monad: in the category of endofunctors
00:24:54 <monad> good
00:24:55 <dminuoso> *the monoidal category of endofunctors
00:25:07 <dminuoso> monad: are you familiar with monodical categories?
00:25:13 <dminuoso> *monodial
00:25:35 <kuribas> dminuoso: right :)
00:25:38 <monad> nah
00:25:59 <dminuoso> monad: a monoidal category is a category equipped with a bifunctor (and some laws)
00:26:27 <Ariakenom> "a monad is a monoid in the category of endofunctors, what's the problem?"
00:26:54 <dminuoso> monad: Let our category be the category of endofunctors with natural transformations as morphisms. The bifunctor we equip this category with, is the functor composition, named (:.:) in the following.
00:26:56 <monad> ah ok
00:27:04 <monad> ariakemon thnx
00:27:40 <Ariakenom> monad: popular quote from a funny blog http://james-iry.blogspot.se/2009/05/brief-incomplete-and-mostly-wrong.html
00:28:15 <dminuoso> monad: So an object in our category of endofunctors is monoid when it is equipped with two morphisms μ : (M :.: M) -> M and η : I -> M
00:28:28 <monad> the terminology gets me confused haha
00:28:28 <dminuoso> monad: where I is an identity (up to iso) with respect to :.:
00:28:47 <dminuoso> *An object M
00:29:29 <dminuoso> monad: So the monoid we have lies in "smashing" layers of functor composition together, or being able to craft a layer out of thin air, that acts as an identity with respect to that smashing
00:29:30 <kuribas> dminuoso: that must sound chinese to monad.  Unless he is actually chinese ...
00:29:43 <dminuoso> (IO :.: IO) a -> (IO a)
00:29:52 <dminuoso> Which is just join
00:30:06 <monad> it does sound like chinese, i am not chinese
00:30:09 <dminuoso> Haha.
00:30:15 <dminuoso> monad: I thought you said you were well versed in category theory.
00:30:25 <lamba_> hello, If I had a datatype X taking around 14 values of different types and I had a list of 14 strings to be parsed to those types (with correct Read instances). I want to end up with a Maybe X but without manually passing the 14 values. Can applicatives do this?
00:31:09 <cocreature> lamba_: not sure how applicative comes into play here. can’t you just use "readMaybe"?
00:31:37 <monad> i said that
00:31:47 <monad> haha
00:31:54 <lamba_> I can't
00:31:59 <lamba_> it's a list of strings
00:32:30 <cocreature> lamba_: oh then you can use "traverse readMaybe" to get Maybe [a]
00:32:31 <lamba_> and X holds 14 things
00:32:39 <cocreature> (or mapM)
00:32:47 <lamba_> but it's not a Maybe [a]
00:32:52 <lamba_> different types
00:32:58 <Ariakenom> lamba_: maybe like this? Construct <$> maybeRead str1 <*> maybeRead str2
00:33:06 <lamba_> yes
00:33:19 <cocreature> I’m confused, you said you have 1 type "X" that can take 14 values, now you say you have different types?
00:33:20 <rotcev> general question: Are most of you haskell 'experts' (sorry, i don't know a better term to use) coming from a mathematical background or a computer science background?
00:33:21 <lamba_> but i didn't want to write 14 values I was asking if i can fold it somehow
00:33:47 <lamba_> 14 values of different types
00:33:50 <dminuoso> monad: In rough terms you could think that `join :: Monad m => (m :.: m) a -> m a` and `return :: Monad m => Identity a -> m a`. Now remember that a monoid is just a binary associative operation with an identity.
00:34:08 <kuribas> rotcev: I don't (I don't think I'm an export though...)
00:34:23 <cocreature> lamba_: so what’s the result type that you would like to end up with?
00:34:28 <lamba_> Maybe X
00:34:54 <cocreature> ah I think I got it
00:35:03 <cocreature> I don’t think there is really a nice way to avoid this
00:35:17 <lamba_> I was thinking maybe Hlists?
00:35:17 <kuribas> lamba_: easier to just write it out I think.
00:35:31 <kuribas> lamba_: any workaround is going to be more complicated
00:35:42 <cocreature> yeah I’d say hlists are not worth the complexity here
00:35:45 <lamba_> Just curious because writing it out isn't a real problem right now
00:35:52 <monad> dminuoso, i read it but i'll tell you when i get it. haha
00:35:59 <dminuoso> monad: Do you know what a Monoid is?
00:36:39 <elvishjerricco> I've read that Stackage pins cabal file revisions, but I don't see any evidence of this in the lts yaml files here: https://github.com/commercialhaskell/lts-haskell
00:36:59 <elvishjerricco> Does anyone know where to find what they're pinned to?
00:37:26 <monad> yeah
00:37:39 <dminuoso> monad: do you know what function composition is?
00:37:44 <monad> yeah
00:37:55 <dminuoso> monad: Alright, so let (:.:) be a type level composition
00:38:14 <dminuoso> monad: such that `IO (IO a) = (IO :.: IO) a` (up to an isomorphism)
00:38:23 <dminuoso> monad: so far so good?
00:38:45 <monad> yeah
00:39:24 <kuribas> rotcev: I don't have a formal education in anything IT related, though I like math.  You don't really need more math for haskell than for any other language.
00:39:44 <hc> kuribas: just curious, do you have a job writing haskell code? :)
00:39:47 <geekosaur> elvishjerricco, you sure that's not the version key under the package name?
00:39:51 <rotcev> kuribas: same here
00:39:53 <kuribas> hc: no
00:40:09 <elvishjerricco> geekosaur: I'm looking for the *revision*, not the version.
00:40:10 <rotcev> kuribas: but i think you know a substantial amount more about haskell than I :)
00:40:11 <lamba_> cocreature: thanks!
00:40:21 <dminuoso> monad: So Monad is equipped with a function called `join` that now does this: It takes some `(m :.: m) a` and turns it into `m a` right?
00:40:31 <lamba_> how does one reference someone else in irc?
00:40:41 <elvishjerricco> geekosaur: Hackage lets you add revisions of your cabal file without changing the version in order to update metadata
00:40:41 <dminuoso> lamba_: tab completion works on most respectable IRC clients
00:40:48 <cocreature> lamba_: just like you did :)
00:41:07 <sclv> elvishjerricco: look at the top of https://raw.githubusercontent.com/commercialhaskell/lts-haskell/5eb9385a84d363aa35125cf3fa4fcab9333e13a0/lts-11.8.yaml
00:41:09 <kuribas> rotcev: just be reading blogs, papers, learning from these guys, writing code.
00:41:10 <lamba_> ah thx
00:41:24 <sclv> see the no-revisions stuff
00:41:26 <monad> yes
00:41:26 <kuribas> rotcev: A good introductory book helps as well
00:41:36 <rotcev> kuribas: i am also doing that process - but i am more near the start of my journey
00:41:54 <cocreature> sclv: that’s just for opting out of revisions. I thought stackage also pinned down the revision that is used if you don’t opt out?
00:41:56 <geekosaur> looking, might be done the hard way: they have cabal file checksum info, might match a specific revision
00:41:57 <elvishjerricco> sclv: Does that mean that only those few packages are pinned?
00:42:29 <sclv> elvishjerricco: actually i think cocreature is right in general though
00:42:30 <monad> isn't m (m a) more readable than (m :.:m ) a?
00:42:34 <kuribas> rotcev: don't let people convince you haskell is hard.
00:42:37 <sclv> since each package also has a hash of the cabal file
00:42:43 <sclv> you can use that to match to a revision
00:42:46 <dminuoso> monad: Yes but the point is to shift the perspective.
00:42:57 <dminuoso> monad: It's to see that `(m :.: m) -> m` is being done
00:43:01 <dminuoso> monad: monad https://gist.github.com/dminuoso/9e6790bd50d1ec677d33e70a17109bfd
00:43:04 <elvishjerricco> Are revisions content addressable like that?
00:43:05 <kuribas> rotcev: C++ is hard.  Making a well designed program in Python is hard.
00:43:14 <elvishjerricco> Or do they just iterate over them all and find the right one?
00:43:23 <rotcev> kuribas: i don't think it's so hard to write a program in haskell, but to really understand the language seems like a fun challenge
00:43:26 <dminuoso> monad: do you see the semigroup structure in this?
00:43:27 <sclv> elvishjerricco: in the tarball they're not content addressable
00:43:42 <sclv> i think stackage was talking about having some layer for that
00:43:53 <sclv> (and there's some ideas for that for hackage too, but nothing in the immediate works)
00:44:07 <dminuoso> monad: By law this must be associative. That is, if you have `(IO :.: (IO :.: IO)) a` or `((IO :.: IO) :.: IO) a` and join twice you get the same result.
00:44:09 <elvishjerricco> sclv: So they're probably doing the iteration thing, then. Gross
00:44:27 <elvishjerricco> Dunno why they couldn't have just pinned the revision number
00:44:31 <dminuoso> monad: Part of the reason expressing this with :.: is that that _that_ is exactly what the monoid is about
00:44:43 <monad> ok
00:45:13 <kuribas> rotcev: it is :)  The language is constantly evolving, and few people know it all.
00:45:27 <monad> cool still the same thing isn't it
00:45:35 <rotcev> dminuoso: what is the identity of a monad, then?
00:45:50 <taumuon> a semigroup is described as a set with an associative binary operation.  Can anyone tell me what an associative binary operation is in this context?
00:46:05 <Ariakenom> kuribas: By that definition does anyone?
00:46:21 <monad> a -> ma
00:46:38 <kuribas> Ariakenom: maybe Edward Kmett?
00:47:30 <kuribas> rotcev: Identity
00:47:50 <kuribas> I think...
00:47:55 <monad> lol i need to change my name
00:48:31 <marxS> do you guys/girls use haskell for everything you do?
00:48:37 <marxS> or do you have specific tasks for which you use it
00:48:38 <kuribas> taumuon: the same as in any context?
00:48:54 <phadej> marxS: /almost/
00:49:16 <marxS> phadej, care to elaborate?
00:49:17 <dminuoso> rotcev: the monoid is not on monad itself, its on the layers of composition
00:49:35 <kuribas> taumuon: an operation for wich (a `op` (a `op` a)) == ((a `op` a) `op` a)
00:49:36 <phadej> as far as programming language is used, it's usually haskell :)
00:49:41 <Ariakenom> kuribas: Have to ask him at some point then. :)
00:50:38 <rotcev> dminuoso: i think you lost me, but i will just continue to read your discussion
00:51:21 <taumuon> kuribas: roughly speaking, it means that the order of operations doesn't give a different result?
00:51:35 <rotcev> taumuon: yes, for example, addition
00:52:10 <kuribas> taumuon: better example: (a `op` (b `op` c)) == ((a `op` b) `op` c)
00:52:15 <dminuoso> rotcev: The identity is inserted by pure
00:52:28 <dminuoso> rotcev: pure :: (Monad m) -> Identity a -> m a
00:52:39 <dminuoso> rotcev: The layer it inserts acts as an identity wrt to the smashing
00:53:19 <dminuoso> rotcev: that is you could say: join . pure = id
00:53:33 <kuribas> taumuon: for addition (1 + (2 + 3)) == ((1 + 2) + 3)
00:53:34 <monad1> i think haskell has been so successful in avoiding success because of the jargon, haha
00:53:50 <dminuoso> monad1: its in no way necessary for anything
00:54:01 <Myrl-saki> Are both FlexibleInstances and FlexibleConstraints good?
00:54:03 <Axman6> it's not "jargon", we just use the names for things which best express what they are
00:54:11 <kuribas> taumuon: you cann swap the arguments without commutativity though
00:54:38 <monad1> yeah, to academics it may sound natural
00:55:00 <Axman6> why pick new names for things which already have names?
00:55:00 <rotcev> monad1: https://github.com/hemanth/functional-programming-jargon ;)
00:55:16 <cocreature> Myrl-saki: I’d say so. they make it slightly easier to get yourself into situations where you are tempted to use overlapping instances but you still need to opt into those separately so I wouldn’t count that as a downside
00:55:39 <Myrl-saki> cocreature: Thanks.
00:55:48 <dminuoso> taumuon: The binary associative operation is the smashing of :.:
00:55:52 <Myrl-saki> I need someone to help me with type fu here.
00:55:58 <Myrl-saki> https://github.com/reflex-frp/reflex-dom/blob/develop/reflex-dom-core/src/Reflex/Dom/Prerender.hs#L44
00:56:07 <dminuoso> taumuon: that is in some sense you have a kind of `m :.: m -> m` going on
00:56:07 <Axman6> monad1: part of being a professional in any field is learning the common langiage of that field. Haskell takes concepts frequently from mathematics and as such we speak that common language
00:56:18 <dminuoso> taumuon: so `two layers of m` are combined into one m
00:56:55 <Myrl-saki> If I inline what I made, then it works, but if I don't, then I'd have to specify the type with a custom constraint. The problem is... the Constraint is not exported.
00:57:15 <Myrl-saki> Technically, I can just copy the constraint definition, but that seems ugly, and I doubt that that's what the authors were going for.
00:57:28 <monad1> axman6 i guess so, but it hinders information exchange i think
00:58:15 <taumuon> thank you dminoso.  im not familiar with :.: notation so I cant understand
00:58:35 <dminuoso> taumuon: :.: is just Compose, that is type level composition
00:58:42 <rotcev> dminuoso: i think i actually got it
00:58:45 <geekosaur> didn't this whole thing start by defining :.: ?
00:58:46 <dminuoso> taumuon: :.: is to type constructors what . is to functions
00:58:56 <Axman6> do you expect engineers to speak about rocks, and sometimes talk about squishy rocks, because people have experienced rocks before? or should they talk about cement and concrete? what about blood tsting rocks turned into weird sticks? or girders and beams, trusses and steel?
00:59:24 <rotcev> dminuoso: monad is a monoid confirmed :-)
01:00:18 <monad1> hahaha
01:00:22 <geekosaur> monad1, if that was aimed at 'associative', pretty sure I learned that one in grade school
01:00:23 <dminuoso> rotcev: Note that Im doing a lot of handwaiving, because the reality requires me to talk about commuting diagrams.
01:00:30 <kuribas> dminuoso: so :.: is Compose?
01:00:32 <Axman6> We're in a very young field, the vocabulary is only just being invented compared to other fields - for some reason people seem to have an aversion to learning the precise language this field has to offer - we can leaverage hundreds of years of work in the field of maths, and get precision for free, why wouldn't we do that? the idea that programming isn't maths is pretty anti=productive :)
01:00:39 <dminuoso> kuribas: Yes. Infix Compose
01:00:52 <dminuoso> kuribas: For the purpose of this discussion only available for Functors.
01:01:00 <kuribas> dminuoso: is it used in any libraries?
01:01:05 <rotcev> (IO :.: IO) a == IO (IO a) right
01:01:11 <dminuoso> rotcev: up to iso, yes
01:01:25 <rotcev> dminuoso: what does 'up to' mean?
01:01:29 <tdammers> well, one issue is that our field is closely related to other fields that are less keen on the theory and invent their own incompatible vocabulary
01:01:30 <taumuon> how come you can compose a type in the same way as you can compose a function?
01:01:42 <Axman6> they are isomorphic but not exactly equal
01:02:09 <Axman6> taumuon: because many types are just functions which work on other types too, they're not special
01:03:29 <kuribas> taumuon: http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor-Compose.html
01:04:57 <kuribas> Axman6: sadly, most programmers think that using math is unpractical, and an ivory tower mentality.
01:05:18 <kuribas> Axman6: because *real programmers* have to deal with mundane stuff, where math doesn't matter.
01:05:30 <EvanR> "up to" is pretty idiosyncratic jargon
01:06:50 <monad1> tdammers actually academics should be free to experiment with whatever they like, including vocabulary
01:07:29 <dminuoso> monad1: Mathematicians do that, which is why every paper in the world makes up their own vocabulary and symbols...
01:07:43 <dminuoso> Luckily for the most part they agree on most things.
01:07:55 <monad1> but a product should use useful vocabulary i guess
01:08:10 <Ariakenom> monad1: Those damn alien academics
01:08:13 <geekosaur> define useful
01:08:20 <geekosaur> does it mean what you happen to already know?
01:08:32 <geekosaur> does it mean trying to juess what a JS programmer might think of when they discover a concept?
01:09:09 <Unhammer> for things like (\a b -> a { cfQt = cfQt a + cfQt b }), do I need lenses in order to say something like "sumThe cfQt" ?
01:09:39 <monad1> well i think a picture would do
01:09:40 <Unhammer> or is there a way to do it with "regular" haskell (I don't have have fields)
01:09:47 <Unhammer> *don't have nested fields
01:09:49 <monad1> if i can see the stuff i can understand it better
01:10:07 <cocreature> Unhammer: lenses won’t help you much either since they don’t do the “zipping” part
01:10:51 <EvanR> theres a += type thing in that .field preprocessor package
01:11:11 <EvanR> its not really a zip, its a a.field += b.field
01:11:14 <monad1> brain likes connecting new information with already known information, so that helps too
01:15:09 <cocreature> hm yeah I guess you could do that with a lens but tbh I wouldn’t bother if your real code is as simple as that
01:15:14 <Unhammer> preprocessors :(
01:15:22 <Unhammer> ok
01:15:44 <marxS> are there any known haskell bitcoin libraries? google returns nothing apart from some weird haskell blockchain implementation
01:15:51 <marxS> I assume a bitcoin library may be difficult without mutability
01:16:08 <marxS> given the process of signing inputs of transactions etc
01:16:41 <Ariakenom> marxS: Well you can mutate things in Haskell
01:17:12 <marxS> I found this which is somewhat interesting https://libraries.io/github/solatis/haskell-bitcoin-script
01:17:42 <cocreature> marxS: the first google hit is https://github.com/haskoin/haskoin which seems like it might be what you’re looking for?
01:17:59 <marxS> cocreature, nah - that's what I meant by " google returns nothing apart from some weird haskell blockchain implementation"
01:18:14 <marxS> cocreature, I was hoping for something to interact with bitcoin specifically
01:18:32 <marxS> looks like that may be my first project if I learn some haskell :p
01:19:23 <Ariakenom> I'm curious. From where did you get that Haskell couldn't mutate stuff?
01:19:53 <marxS> cocreature, oh actually, haskcoin doesn't look too bad, would be useful to use as a base layer
01:20:12 <marxS> Ariakenom, I just assumed immutability was an inherent feature given the preaching of lack of side-effects
01:20:34 <kuribas> Unhammer: that looks more like functor and applicative
01:21:42 <kuribas> Unhammer: erm no, never mind
01:21:48 <Ariakenom> marxS: I see. Well there are effects. They're just not _side_ :)
01:24:13 <rotcev> Ariakenom: i like the way you put that
01:24:52 <dminuoso> marxS: Haskell is pure in the evaluation only. But we have IO to encapsulate effects - so things like database accesses, disk IO or even mutable data structures work just fine in Haskell.
01:25:28 <marxS> ah okay
01:27:19 <mstruebing> can someone ban creatpotsics93?
01:27:53 <dminuoso> mstruebing: There is #haskell-ops if you have the need to get the attention of an op.
01:30:11 <Ariakenom> rotcev: Thanks!
01:32:14 <taumuon> Axman6: when I think of a type, I imagine a set of possible values.  To think about a type like a function - i need to think about a type as a function that con produce that set of possible values?
01:32:27 <taumuon> can*
01:32:46 <dminuoso> taumuon: a function is a value too.
01:33:37 <dminuoso> taumuon: Think of `Maybe` as a type level "function" that takes a type and gives you a type back.
01:34:56 <dminuoso> :k Maybe
01:34:57 <lambdabot> * -> *
01:35:07 <dminuoso> taumuon: See how `Maybe` is a kind of function that takes one type, and gives a type back?
01:35:12 <dminuoso> :kind Either
01:35:19 <dminuoso> :k Either
01:35:20 <lambdabot> * -> * -> *
01:35:34 <dminuoso> This is a type level "function" that takes two types and gives a type back
01:36:04 <dminuoso> :k StateT
01:36:05 <lambdabot> * -> (* -> *) -> * -> *
01:36:24 <dminuoso> This takes one type, and one type level function (which takes one type), and another type, and gives you a type back
01:36:54 <lamba_> cocreature: I realized I could write a liftA that is variadic and use that
01:37:01 <lamba_> do you think this exists somewhere?
01:37:38 <sclv> r
01:37:40 <lamba_> again I'm just messing about I know my case isn't really worth the trouble
01:38:13 <cocreature> lamba_: I don’t think a liftA that’s variadic will work out like you think it does. return types in Haskell can be functions as well so you can’t infer from the type how many arguments should be lifted
01:38:32 <cocreature> so you probably end up with something that’s quite fragile when it comes to type inference and is more confusing than helpful
01:40:40 <rotcev> taumuon: these kinds that dminuoso is talking about is sort of like a 'type system for a type system'
01:41:12 <lamba_> cocreature: inference was indeed painful last times I wrote variadic functions
01:41:21 <lamba_> so what do you think is the best solution here?
01:41:34 <cocreature> just bite the bullet and have a bit of boilerplate
01:41:45 <cocreature> Haskellers are mostly way too obsessed with avoiding boilerplate imho :)
01:41:46 <lamba_> I already have the boilerplate :p
01:42:09 <lamba_> I don't mind it really
01:42:14 <lamba_> Just find this a bit interesting
01:43:26 <lamba_> can rankNtypes help here?
01:44:03 <cocreature> I don’t see how
01:45:44 <lamba_> the problem is I can't fold this because they don't have the same type right?
01:46:20 <lamba_> so if it was hidden under a rankNtype with Parsible a => a (something like this not sure)
01:46:24 <lamba_> maybe I could?
01:46:39 <lamba_> String -> a sorry
01:47:05 <cocreature> you still have the problem that your list can contain an arbitrary number of element but your constructor accepts a fixed number of arguments
01:47:13 <lamba_> yes ofcourse
01:47:26 <lamba_> im assuming I have the right number
01:47:27 <cocreature> and once you introduce a list that tracks the length you might as well go full hlist
01:47:35 <cocreature> sure but the type system doesn’t know that
01:47:38 <lamba_> I could  unify it with a length indexed vector
01:47:55 <lamba_> ya maybe full hlist is the right way here
01:48:23 <cocreature> hlists should work, I just don’t think they’re an improvement over the boilerplate
01:48:43 <lamba_> how so?
01:48:59 <cocreature> like is liftVariadicA f (x :| y :| z :| []) really that much better than f <$> x <*> y <*> z?
01:49:13 <lamba_> oh no not that
01:49:28 <lamba_> you don't have to write out every value do you?
01:49:49 <taumuon> do these type systems that have functions as possible values always "end up" with some concrete primitive when you evaluate them?
01:50:10 <cocreature> depends on where these values come from
01:50:20 <lamba_> I'm gona have to play around this a bit more in a bit
01:50:35 <lamba_> but I have Strings and they can be converted to the right types
01:50:38 <cocreature> but regardless, if f really takes such a large number of arguments that this becomes a problem, you should probably refactor "f" rather than try to automate the boilerplate of arguments
01:50:53 <cocreature> *of applying it to the arguments
01:51:50 <lamba_> hmm
01:52:40 <rotcev> taumuon: for example, in the case of Maybe, it has a kind of * -> *, which means it can take some type with the kind * and return a kind *
01:52:43 <rotcev> for example:
01:52:47 <rotcev> :k Maybe
01:52:48 <lambdabot> * -> *
01:52:55 <rotcev> :k Int
01:52:56 <lambdabot> *
01:52:59 <rotcev> :k Maybe Int
01:53:00 <lambdabot> *
01:53:16 <rotcev> You can't evaluate Maybe Int any further, so it has kind *
01:54:15 <merijn> rotcev: I don't think you should use evaluate there, because it doesn't quite make sense in Haskell and if we generalise to something more flexible to Haskell it'd be wrong due to being misleading
01:54:26 <taumuon> so i have to kind of unlearn this notion that all data are concrete values in memory?
01:54:59 <merijn> taumuon: You can keep that notion, you just have to unlearn the idea that you get to know *where* and *how* they are in memory ;)
01:55:05 <rotcev> merijn: okay, sorry, i was explaining the way i understood it, but perhaps i could use better wording, i don't mean to be confusing
01:55:52 <merijn> Actually, if you start diving into operational details of GHC you can actually get quite a decent grip on more detailed memory info, but as a beginner that will just get you more confused
02:02:56 <rotcev> merijn: just out of curiosity, how would you have rephrased my statement?
02:04:26 <merijn> rotcev: Just skip any notion of evaluating and just talk in terms of application (similar to function application). So 'Maybe :: * -> *' can be applied to an argument of kind * to get a type of kind * and "Maybe Int :: *" is fully applied
02:04:38 <rotcev> merijn: thanks
02:04:52 <rotcev> i knew there was a better word
02:29:57 <dminuoso> One cool way to think of Maybe, is that it adds () to an arbitrary type (up to an isomorphism).
02:31:11 <dminuoso> `Maybe Int` is a kind of `Int + ()`
02:32:24 <hc> heh
02:37:49 <dminuoso> taumuon: So in that sense Maybe and Either let you add types together.
02:40:52 <cocreature> I think I’ll never be able to remember if the explicit import list comes before "as" or after
02:41:06 <merijn> cocreature: Story of my life
02:41:26 <cocreature> it’s just impossible
02:43:05 <phadej> `Maybe a =~ Either () a`
02:46:15 <lavalike> cocreature: make a post it not visibile from the loo :P
02:50:12 <cocreature> lavalike: why should it not be visible from the loo? I think I’m missing the joke here :)
02:54:00 * hackage numhask-prelude 0.0.5.1 - A numeric prelude  http://hackage.haskell.org/package/numhask-prelude-0.0.5.1 (tonyday567)
03:01:12 <lavalike> cocreature: so you end up having to look at the syntax every time you end up there, can't forget it if you see it on the regular (:
03:01:23 <mjoldfield> If you're used to lists of things, you can think of Maybe as a list which has either 0 items (when it's called Nothing), or one item (when it's Just ..)
03:07:02 <dminuoso> mjoldfield: [] is isomorphic to ()
03:08:36 <capisce> dminuoso: how so?
03:10:56 <dminuoso> capisce: [] is basically the thing you can create out of thin air with no information in it.
03:11:05 <dminuoso> and that is unit.
03:11:13 <dminuoso> and that is Nothing
03:14:29 <dminuoso> capisce: Consider how a list works. It's a nesting of cons, terminated with some thing that carries no information. 1:(2:(3:[]))
03:16:56 <dminuoso> capisce: f () = []; f' [] = ()
03:19:48 <lavalike> they are even homeomorphic, see, you just straighten the parens and ding them at the tip
03:20:29 <crng_init> I'm trying to learn how to use less parentheses, with (.) and ($). How could I rewrite the following function without parentheses and x parameter?
03:20:40 <crng_init> myButLast :: [a] -> a
03:20:43 <crng_init> myButLast = last . init
03:20:45 <crng_init>  
03:20:47 <crng_init> myButLast' x = reverse x !! 1
03:20:48 <rotcev> hi guys, i am reading about the DataKinds extension at the moment, specifically from this article: http://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html . In this article, they define a data type `data Nat = Zero | Succ Nat` which with the DataKinds extension produces the new kind Nat, and makes Succ of kind Nat -> Nat. The thing that is confusing me is the introduction of 'Succ, which seems to also have
03:20:49 <crng_init>  
03:20:51 <crng_init> myButLast'' [x,_]  = x
03:20:53 <crng_init> myButLast'' (_:xs) = myButLast'' xs
03:20:55 <rotcev> could someone help me understand the difference?
03:20:55 <crng_init>  
03:20:57 <crng_init> myButLast''' (x:(_:[])) = x
03:20:58 <dminuoso> crng_init: Please use a pasting service
03:20:59 <crng_init> myButLast''' (_:xs) = myButLast''' xs
03:21:01 <crng_init>  
03:21:03 <crng_init> myButLast'''' = head . tail . reverse
03:21:05 <crng_init>  
03:21:07 <crng_init> lastbut1 :: Foldable f => f a -> a
03:21:07 <capisce> dminuoso: f () = [1, 2, 3]; f' xs | xs == [1,2,3] = ()
03:21:09 <crng_init> lastbut1 = fst . foldl (\(a,b) x -> (b,x)) (err1,err2)
03:21:11 <crng_init>   where
03:21:13 <crng_init>     err1 = error "lastbut1: Empty list"
03:21:15 <crng_init>     err2 = error "lastbut1: Singleton"
03:21:17 <crng_init>  
03:21:19 <crng_init> lastbut1safe :: Foldable f => f a -> Maybe a
03:21:21 <crng_init> lastbut1safe = fst . foldl (\(a,b) x -> (b,Just x)) (Nothing,Nothing)
03:21:23 <capisce> dminuoso: so [1,2,3] is also isomorphic to (), no?
03:21:23 <crng_init>  
03:21:25 <crng_init> myButLast''''' [] = error "Empty list"
03:21:27 <crng_init> myButLast''''' [x] = error "Too few elements"
03:21:29 <crng_init> myButLast''''' (x:xs) =
03:21:30 <taumuon> crng stahp
03:21:31 <crng_init>   if length xs == 1 then x
03:21:33 <crng_init>   else myButLast''''' xs
03:21:35 <crng_init>  
03:21:37 <crng_init> myButLast'''''' = head . reverse . init
03:21:39 <crng_init> oops didn't mean to do that
03:21:41 <crng_init> yes I am so sorry it should only be 2 lines.
03:21:51 <dminuoso> capisce: Yes.
03:21:55 <cocreature> rotcev: I think your message got cut off
03:22:47 <rotcev> cocreature: sorry
03:23:06 <crng_init> myLength :: [a] -> Int
03:23:24 <dminuoso> capisce: This comes from the fact that a^1 = a
03:23:32 <crng_init> myLength x = foldr1 (+) (map (const 1) x)
03:23:33 <dminuoso> capisce: and in Hask 1 is ()
03:23:46 <rotcev> cocreature: basically, my question is what is the difference between 'Succ and Succ when they both have the same kind, why is 'Succ needed
03:24:01 <crng_init> how can I avoid parentheses?
03:24:03 <dminuoso> capisce: the important thing about [] however, is that unlike [1,2,3], [] is part of the very definition of lists.
03:24:07 <rotcev> my question is what is 'Succ and 'Zero
03:24:40 <dminuoso> capisce: that is, you could say: data [a] = (:) a [a] | []
03:24:47 <dminuoso> (If the syntax allowed such a thing)
03:24:54 <cocreature> rotcev: the primes are required to avoid ambiguities
03:25:20 <cocreature> rotcev: you can defined "data X = X". if you know use X as a type, should it be the constructor lifted to the type level or the X type?
03:26:25 <rotcev> so the ones with the prime are the type level constructors
03:26:41 <cocreature> exactly
03:27:19 <rotcev> i am trying to read this stuff so i can understand the magic that goes on within servant with the type level strings and the Symbol kind
03:27:21 <cocreature> you can omit the primes if it’s not ambiguos but GHC warns about that (at least with -Wall)
03:27:37 <cocreature> so for consistency it’s better to just always use primes when you want to refer to the lifted version
03:27:51 <dminuoso> crng_init: Repaste on to the site linked in the topic
03:28:24 <rotcev> ah alright cocreature
03:28:25 <rotcev> thanks
03:28:34 <crng_init> dminuoso: I'm putting it on lpaste. Currently struggling with my clipboard
03:30:26 <crng_init> https://lpaste.net/1714481348913135616
03:31:21 <crng_init> How could I avoid parentheses and get rid of the x parameter?
03:32:26 <cocreature> crng_init: myLength = foldr1 (+) . map (const 1)
03:32:32 <dminuoso> crng_init: You could drop the map entirely
03:32:49 <cocreature> that function will crash when given an empty list
03:32:56 <cocreature> and you want a foldl' here instead of a foldr1
03:33:11 <dminuoso> crng_init: Try to think about passing a different function to foldr (and dont use foldr1 for the reason just said)
03:33:27 <dminuoso> crng_init: maybe write it with a lambda first, and then make that point free
03:34:08 <crng_init> Why could I drop the map?
03:34:31 <crng_init> because I already do a fold?
03:34:35 <dminuoso> Right.
03:35:28 <cocreature> you don’t need to drop the map, GHC will probably optimize it to the same code
03:35:38 <cocreature> but you should handle empty lists and use foldl' :)
03:36:16 <dminuoso> cocreature: Oh that thought was just provoked by: "It should be the goal for practice"
03:37:20 <crng_init> The difference between foldr and foldl' confuses me. I read somewhere foldl' is better for performance.
03:38:37 <cocreature> foldl' will walk through the list and calculate the current length at each step. foldr will walk through the list build up a giant term of the form "1 + (1 + (1 + …))" and then start evaluating that term
03:38:50 <cocreature> that’s worse both in terms of memory usage and in terms of performance
03:39:01 <dminuoso> crng_init: Usually `foldr` is the right fold to pick. If however you dont mind that the list is (in effect) reversed, foldl' can be faster. So things that are arguments against foldl' are: "You need the list order", "You want to work with infinite lists"
03:39:34 <merijn> crng_init: foldl doesn't reverse the list
03:39:36 <merijn> eh
03:39:43 <merijn> s/crng_init/dminuoso
03:39:58 <rotcev> is it possible to define foldr in terms of foldl?
03:40:00 <merijn> foldl just associates the other way, which is completely unrelated to the order of processing
03:40:35 <rotcev> or the other way around, even
03:40:54 <merijn> You can define foldl via foldr, not sure of the other way around
03:41:02 <cocreature> foldl in terms of foldr works, the other way doesn’t work at least not if you want the same semantics when it comes to laziness and infinite lists
03:42:05 <dminuoso> merijn: I feel that in effect the list order is reversed. Kind of.
03:42:08 <dminuoso> > foldl (flip (:)) [] [1,2,3]
03:42:10 <lambdabot>  [3,2,1]
03:42:22 <Eduard_Munteanu> With foldl, the outermost operation involves the last element, so with respect to lazy evaluation the order may be regarded as reversed in a way.
03:43:02 <crng_init> so foldl would do something like "((base) + 1) + 2)"?? What does foldl' do?
03:43:27 <Eduard_Munteanu> Yes, and foldl' is just strict in the accumulator.
03:43:37 <cocreature> foldl' ensures that instead of building up ((… + 1) + 1)) + 1 you collapse the intermediate results at each step
03:45:12 <crng_init> Then why would you ever use foldl? Because you might not want everything to be evaluated?
03:45:53 <tdammers> yes, pretty much
03:46:07 <tdammers> but "don't use foldl at all" is a pretty good starting point
03:46:08 <cocreature> foldl has very few useful usecases
03:46:08 <Eduard_Munteanu> Good question, foldl is kinda rare.
03:46:13 <cocreature> usually you either want foldl' or foldr
03:46:39 <crng_init> Any idea of an example where foldl would be useful?
03:49:49 <[exa]> crng_init: if the operator can ignore an error in the left parameter?
03:50:15 <tdammers> or, more generally, if the operator can ignore something inconvenient in the left parameter
03:50:19 <tdammers> like expensive evaluations
03:51:01 <[exa]> generally anything that you wold foldr, but are too lazy to flip+reverse
03:51:05 <[exa]> *would
03:51:54 <crng_init> I think I understand now, thanks a lot!
03:54:03 <merijn> dminuoso: that's revered because of the flip, not because of foldl
03:54:58 <merijn> crng_init: tbh, IMO foldl is *never* useful and the only reason it hasn't been removed and replaced with foldl' is a bunch of people being overly paranoid of it breaking hypothetical code that in all likelihood does not exist
03:58:22 <[exa]> ok well TBH, if you're writing a haskell compiler then the lists of lambda-applied terms can be combined by something like foldl1 Ap
03:59:08 <cocreature> [exa]: why would that be preferable over foldl1'?
04:00:39 <[exa]> good point. Probably only the "don't care" reasons.
04:02:41 <cocreature> I would expect that building up thunks that represent Ap (Ap (Ap a b) c) d is probably still more expensive than building up the actual terms
04:03:03 <cocreature> so while it probably doesn’t make a huge difference here, foldl1' might still be the better choice
04:04:34 <yuuki_> 1
04:04:37 <yuuki_> sorry
04:04:50 <yuuki_> missed a slash
04:05:39 <int-e> merijn: the point is moot with Foldable anyway, where foldl is suddenly useful in the same way that foldr is.
04:05:53 <int-e> (not for lists of course, but generally speaking)
04:06:57 <cocreature> int-e: we could still change the foldl implementation on lists to be foldl'
04:06:57 <int-e> :t foldl (flip (:)) []
04:06:58 <lambdabot> Foldable t => t a -> [a]
04:07:07 <int-e> cocreature: right
04:07:10 <merijn> int-e: I'm not sure I agree, why would foldl be better than foldl' for Foldable?
04:07:48 <cocreature> merijn: if you have a snoc list then foldl has the nice laziness properties that you get from a foldr on regular lists
04:08:30 <int-e> merijn: Because foldables like Data.Sequence.Sequence and Data.Map.Map have efficient ways of accessing the last element.
04:08:49 <int-e> (and yeah, snoc lists are an obvious example, but arguably artificial)
04:41:33 <tdammers> hmm, do we have something akin to this anywhere in base or a commonly used library? data StrictList a = SCons !a !StrictList a | SNil
04:41:42 <tdammers> seems to be a logical thing to have, but I can't find anything
04:42:02 <merijn> tdammers: At that point why not just vector? :p
04:42:30 <tdammers> constant-time cons?
04:43:00 <merijn> tdammers: Couldn't you just accomplish that with regular list + strictness
04:43:06 <rotcev> what does that `!` syntax mean?
04:43:12 <merijn> rotcev: Strictness annotation
04:43:24 <merijn> rotcev: i.e. that field is evaluated to WHNF when applied
04:44:44 <lamba_> tdammers: Could be called a Stack if it does
04:45:16 <tdammers> merijn: I believe a regular list wouldn't automatically force its tail
04:45:53 <tdammers> hmm, also the code I'm looking at is in base, so it really cannot depend on anything else
04:45:55 <lamba_> tdammers: http://hackage.haskell.org/package/strict-base-0.4.0.0/docs/Data-Strict-List.html
04:46:01 <lamba_> what's wrong with this?
04:46:11 <lamba_> oh
04:46:19 <merijn> tdammers: It doesn't, but you can just wrap (:) with seq
04:46:36 <merijn> tdammers: And/or ($!) in the right spots
04:46:52 <tdammers> merijn: probably not worth it then. just trying to understand someone else's code here
04:46:54 <rotcev> merijn: thanks, i'll add that to my things to read about
04:47:03 * hackage purescript-bridge 0.13.0.0 - Generate PureScript data types from Haskell data types  http://hackage.haskell.org/package/purescript-bridge-0.13.0.0 (eskimo)
04:47:08 <blackbriar> hi
04:47:28 <merijn> rotcev: WHNF (weak head normal form) is basically "evaluate this *just* enough to tell what the outermost constructor is"
04:48:39 <rotcev> merijn: i read the WHNF page on the haskell wiki, the one example that confused me there was "True" is in WHNF
04:49:00 <tdammers> rotcev: well, True *is* the "outermost constructor"
04:49:02 <merijn> rotcev: Which can help avoid space-leaks due to thunk buildup. For example, the classic "foldl (+) 0 [1..100]" spends a lot of time building 100 thunks for addition, before eventually collapsing all of them again. This is rather inefficient. If you'd immediately evaluate every addition you'd 1) avoid wasting all that memory 2) make it easier for the compiler to optimise
04:49:26 <tdammers> rotcev: it's just that True is a trivial constructor in that it takes no arguments
04:49:39 <tdammers> rotcev: so evaluating to WHNF amounts to evaluating fully
04:49:39 <merijn> rotcev: "data Bool = False | True", so True is just another constructor and thus True is trivially in WHNF
04:50:22 <merijn> Heinrich Apfelmus's guide on laziness is pretty good: https://hackhands.com/guide-lazy-evaluation-haskell/
04:51:16 <dminuoso> rotcev: Every NF is also in WHNF
04:51:58 <rotcev> so `Just (square 42)` is WHNF because it's known that the outermost constructor is Just
04:52:26 <merijn> rotcev: Correct
04:52:28 <rotcev> same as `(:) 1` is WHNF because the compiler can tell the outermost is Cons
04:52:29 <rotcev> or something
04:53:00 <merijn> That one's ambiguous
04:53:26 <merijn> As the result of "(:) 1" has a function type and it's quite tricky to define the WHNF of a function
04:53:44 <dminuoso> rotcev: Is `(Just 3) + (Just 4)` in normal form (assuming there was an appropriate Num instance of course)?
04:53:53 <dminuoso> or WHNF?
04:54:04 <merijn> But "? : ?" (where ? is some unknown thunk which may or may not be evaluated) would be in WHNF, though, yes.
04:54:30 <rotcev> dminuoso: i am not sure what the difference is between normal form and WHNF ( i just learned about these terms now)
04:54:47 <merijn> rotcev: normal form means "nothing is left to evaluate" in the expression
04:54:48 <dminuoso> rotcev: NF is if there's no reducible expressions left.
04:55:11 <merijn> rotcev: So clearly if nothing is left to evaluate, then for sure we know the outermost constructor and are thus automatically ALSO in WHNF
04:55:21 <merijn> rotcev: But read the laziness guide I linked, it's pretty good
04:55:42 <rotcev> okay so then I think (Just 3) + (Just 4) is WHNF because if there was an appropriate num instance we could evaluate to Just 7 and that would be NF
04:56:04 <merijn> rotcev: "Could evaluate" means we haven't yet, and thus it's not in WHNF
04:56:51 <cocreature> rotcev: not being in nf, does not mean that it’s in whnf
04:58:58 <rotcev> well, individually speaking, Just 3 is in NF, and Just 4 is in NF, correct?
04:58:59 <dminuoso> rotcev: An term is in HNF if it has no reducible expression in head position. An term is in NF if it has no reducible expression anywhere. Thus every term that is in NF is trivially in WHNF too.
04:59:07 <rotcev> meaning individually, they are both in WHNF
04:59:09 <dminuoso> *or every term that is in NF is trivially in HNF
04:59:42 <dminuoso> (Because if it has no reducible expressions anywhere, then it certainly has none in the head position)
04:59:52 <dminuoso> So NF is a stronger claim than HNF
04:59:59 <dminuoso> And HNF is a stronger claim than WHNF
05:01:44 <rotcev> dminuoso: i am having trouble with your example for some reason
05:02:10 <rotcev> i think i understand your rule, but what is confusing me is the + operator, which could technically reduce them further
05:03:09 <cocreature> I don’t think it’s helpful to think about things that you could possibly do to the term. whnf is defined by the current state of the term
05:03:09 <merijn> rotcev: + is not a constructor and it's in the outermost position
05:03:34 <rotcev> merijn: ah true
05:03:38 <dminuoso> rotcev: WHNF is about "where you cant do things anymore", rather than "where can you still do things"
05:03:48 <rotcev> (+) (Just 3) (Just 4)
05:04:13 <cocreature> whnf basically means that it’s sufficiently evaluated that you can evaluate a pattern match (that kind of breaks down since you have nested pattern matches in Haskell but if you assume those don’t exist it’s still helpful)
05:04:28 <rotcev> i guess this means it is indeed in WHNF
05:04:36 <dminuoso> And it breaks down for partially applied operators, and for lambda expressions.. :|
05:04:58 <cocreature> dminuoso: well it depends on how you define pattern matches on functions :)
05:05:31 <dminuoso> cocreature: You piqued my interest. How would you define pattern matches on functions to make sense in that statement?
05:06:33 <dminuoso> rotcev: So from the outermost position there's nothing you could further evaluate?
05:06:41 <cocreature> > case (undefined :: Int -> Int) of f -> ()
05:06:43 <lambdabot>  ()
05:06:48 <cocreature> hm I thought that crashed
05:07:04 <dminuoso> cocreature: why would it? f is irrefutable
05:07:11 <rotcev> dminuoso: i don't think so
05:07:20 <dminuoso> rotcev: Is + a data constructor?
05:07:57 <cocreature> dminuoso: well on the core level a "case" does force evaluation in this case afaik
05:09:46 <dminuoso> > case ((+1) :: Int -> Int) of !f -> ()
05:09:48 <lambdabot>  ()
05:09:50 <dminuoso> > case (undefined :: Int -> Int) of !f -> ()
05:09:52 <lambdabot>  *Exception: Prelude.undefined
05:10:09 <dminuoso> cocreature: Okay that's pretty cool.. no idea what I would do with this knowledge sadly though.
05:10:36 <rotcev> dminuoso: i am kind of confused by this
05:11:09 <cocreature> dminuoso: my point is if you use semantics like core where "case" forces evaluation then functions will also be evaluated to whnf for evaluating case statements
05:11:24 <rotcev> (+) is a data constructor because it takes two numbers and gives a new one, to my knowledge this can be considered a data constructor
05:11:38 <dminuoso> rotcev: a data constructor is something you can pattern match on
05:11:48 <dminuoso> rotcev: can you pattern match on `(+) 3 4` ?
05:11:50 <cocreature> (+) is just a regular function
05:12:06 <rotcev> okay then my definition of data constructor was wrong
05:12:40 <rotcev> Just is a data constructor, but Maybe is a type constructor for example
05:12:47 <rotcev> but you can't pattern match on (+) 3 4
05:12:53 <dminuoso> rotcev: Correct. `3` is also a data constructor, and so is (:)
05:13:16 <dminuoso> [] and () are also data constructors (for the empty list and unit respectively)
05:13:38 <ventonegro> rotcev: A data constructor behaves like a function, but you don't get to write the function body, just the signature (and even that only with GADTs)
05:13:57 <dminuoso> I think the definition "a data constructor is something you can pattern match on" is universally true, right?
05:14:09 <dminuoso> Or are there any counter examples?
05:14:50 <rotcev> (:) is a data constructor because it's equivalent to Cons which is a data constructor, right
05:15:05 <cocreature> (:) _is_ Cons
05:15:07 <dminuoso> rotcev: (:) is a data constructor because its defined as one.
05:15:18 <ventonegro> dminuoso: The case statement is by definition the elimination rule of data, so yes, it's true
05:15:33 <rotcev> okay
05:16:06 <merijn> rotcev: Fun fact, you can even define your own "operator" constructors
05:16:59 <merijn> rotcev: custom operators can be any sequence of symbol characters. Constructors have to start with a capital letter so : was (arbitrarily) defined as *the* uppercase symbol character
05:17:07 <dminuoso> rotcev: data [] a = [] | a : [a]
05:17:25 <merijn> @define data InfixTuple a b = a :*: b deriving (Show)
05:17:27 <lambdabot>  Defined.
05:17:35 <merijn> :t True :*: 'c'
05:17:36 <lambdabot> InfixTuple Bool Char
05:17:40 <merijn> > True :*: 'c'
05:17:42 <lambdabot>  True :*: 'c'
05:18:15 <dminuoso> rotcev: So there's two data constructors for lists: `[] and :` the exact two things you can use for pattern matching. The [...] syntax is just visual sugar. Same thing goes for string literals which are just sugar for 'f':('o':('o':[]))
05:18:32 <merijn> So any operator starting with : (including : itself) *must* be a constructor as non-constructors can't start with an uppercase letter (same a variables and "regular" constructors)
05:19:50 <rotcev> okay, thanks guys
05:20:06 <dminuoso> rotcev: So is this in WHNF? (+) (Just 4) (Just 3)
05:20:21 <rotcev> i don't think so
05:20:28 <dminuoso> rotcev: What about Just (3 + 4)
05:20:33 <rotcev> yes it is
05:21:06 <rotcev> we don't technically know what (+) does in the first example, right? so we don't know what the outer most constructor is
05:21:34 <dminuoso> rotcev: We just need to know whether (+) is a data constructor or not. We dont need to know what it does.
05:21:35 <merijn> rotcev: Also, one of the things I always recommend people when they start getting a little comfortable with the basic in Haskell is to read the Haskell 2010 Report. It's very readable and for some reason many people overlook it. One of the nice things about reading it is that you find that many things that seem "inconsistent special cases" actually end being very consistent, just not the way you initially
05:21:41 <merijn> expect
05:22:21 <rotcev> merijn: thanks, i will do that
05:23:16 <rotcev> dminuoso: so since the outside is not a data constructor it means it's not in WHNF, which implies its also not in NF
05:23:17 <dminuoso> ventonegro: "case statement is by definition the elimination rule" what does that mean?
05:23:44 <dminuoso> rotcev: to which term are you referring to?
05:24:01 <ventonegro> dminuoso: data constructors are introduction rules, and their counterparts are case expressions, which are elimination rules
05:24:51 <dminuoso> ventonegro: That's some interesting choice of words. Where does it come from?
05:24:59 <ventonegro> dminuoso: Sorry, these "rules" are type system rules
05:25:18 <ventonegro> type judgment rules*
05:27:04 <rotcev> dminuoso: (+) (Just 3) (Just 4), the outside is (+) and it's not a data constructor, so it can't be in WHNF
05:27:25 <dminuoso> rotcev: *data constructor or lambda abstraction
05:27:37 <dminuoso> rotcev: For example: (\a -> a + 2) is in WHNF
05:28:02 <rotcev> dminuoso: Just (3 + 4) is in NF though, correct?
05:28:13 <dminuoso> rotcev: Is there anything you can further reduce in that term?
05:28:21 <crng_init> I came up with another function to calculate the function of a list. How could I improve it syntactically and performance-wise?
05:28:21 <dminuoso> rotcev: NF means "you cant reduce anything anywhere"
05:28:39 <dminuoso> rotcev: HNF means "you cant reduce anything in head position"
05:28:50 <crng_init> myLength = foldl' (\x y -> x + 1) 0
05:28:50 <cocreature> crng_init: what do you mean by “calculate the function of a list”?
05:28:57 <cocreature> oh the length :)
05:29:00 <crng_init> length sorry
05:29:01 <rotcev> dminuoso: well technically, i could do the addition operation, but i thought that doesn't really matter
05:29:08 <dminuoso> rotcev: You could! And thats the entire point.
05:29:18 <rotcev> it's equivalent to Just ((+) 3 4) == Just 7
05:29:32 <rotcev> so Just ((+) 3 4) is in WHNF and Just 7 is in NF
05:29:34 <cocreature> crng_init: looks pretty good, I would write the lambda as (\x _ -> x + 1) to make it clear that the second parameter is not used
05:29:39 <dminuoso> rotcev: Right on. :)
05:29:59 <dminuoso> rotcev: You can observe this in fact
05:30:47 <crng_init> cocreature: Thanks, is the '_' just a convention or is it handled differently by the compiler?
05:31:07 <cocreature> crng_init: it’s handled by the compiler. if you use _ you can’t refer to the argument
05:31:20 <dminuoso> rotcev: If you run the following, you will notice that it will not crash. Just (undefined + 3) `pseq` ()
05:31:39 <cocreature> crng_init: apart from that I don’t think there is anything I would change in that definition
05:31:40 <dminuoso> rotcev: the reason is that while pseq will force the evaluation of the left hand side, it will only do so until WHNF is reached. So it wont touch the innards of the data constructror
05:31:44 <Boomerang> You also don't get a warning for unused variable if you use '_'
05:31:52 <rotcev> crng_init: a cool way to calculate the length of the list is `foldr (const (+ 1)) 0`
05:31:59 <merijn> Boomerang: That works for any variable starting with _
05:32:03 <cocreature> rotcev: no it’s not
05:32:17 <cocreature> rotcev: that has way worse performance than the foldl' version
05:32:29 <rotcev> i didn't say it was good performance, i just thought it was cool
05:32:34 <merijn> Boomerang: Which is a good trick if you're writing code and plan to use a variable later, but not yet. Just use _sensibleName as variable name and get no warnings and let you easily refactor
05:32:44 <cocreature> I guess our definitions of cool code differ :)
05:32:57 <dminuoso> also inside get monads it lets you document things like seeking.. :P
05:33:15 <dminuoso> do { _lenField <- getWord8; ... }
05:33:19 <Boomerang> Yeah _name is also useful when used as a hole to differentiate between multiple holes :)
05:33:31 <rotcev> :t pseq
05:33:32 <lambdabot> error:
05:33:32 <lambdabot>     • Variable not in scope: pseq
05:33:32 <lambdabot>     • Perhaps you meant ‘seq’ (imported from Prelude)
05:33:37 * hackage tomland 0.2.1 - TOML parser  http://hackage.haskell.org/package/tomland-0.2.1 (shersh)
05:33:37 <dminuoso> rotcev: Its part of GHC.Conc
05:34:20 <cocreature> that reminds me that I still don’t understand seq vs pseq :)
05:34:42 <dminuoso> cocreature: seq has no order in which the fields will be evaluated. they might be in a different order or in parallel afaik
05:34:54 <dminuoso> which truly sucks when you expect the LHS to be evaluted before the RHS
05:35:07 <cocreature> dminuoso: right but if that was actually the case 95% of our uses of seq for strictness would be wrong
05:35:39 <cocreature> so either we’re all just using the wrong thing all the time and happen to get lucky or there is something more to it
05:36:03 <merijn> cocreature: heh?
05:36:20 <merijn> cocreature: I fail to see how seq ordering effects anything in 95% of usecases
05:36:28 <merijn> Unless you're fucking about with unsafePerformIO
05:37:38 <cocreature> merijn: well if you implement sum as foldl' (+) 0 you really want the first argument to be evaluated first, no? at least simon marlow also seemed to agree with that at some point https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-November/011480.html
05:37:39 <dminuoso> merijn: Simons example of `foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs` is rather telling
05:37:45 <merijn> He's right that order of execution of seq is not guaranteed and is perfectly allowed to be non-deterministic
05:38:16 <dminuoso> cocreature: Is it possible that GHC has some missing optimizations/bug that prevents reordering seq from kicking in? Or maybe we just get lucky because GHC rarely finds a good reason to do so?
05:38:29 <cocreature> if the seq in foldl' is wrong, then that already covers quite a significant number of uses of seq.
05:38:42 <merijn> cocreature: Well, his first line literally says what I say :)
05:38:45 <merijn> cocreature: "The report is in general very careful to say absolutely *nothing* about "
05:38:48 <merijn> evaluation order, leaving the implementation free to choose, either at compile
05:38:51 <merijn> time or possibly even runtime.
05:39:32 <cocreature> merijn: right, so why don’t we use pseq for foldl' which gives us the semantics that we want here?
05:39:46 * dminuoso thinks oversight
05:40:02 <merijn> cocreature: I dunno
05:40:29 <cocreature> it seems pretty much every case where we try to prevent space leaks which I’d say is a pretty large number of usecases of seq would be better served by pseq
05:40:29 <dminuoso> At least 457 uses of seq in the GHC code base..
05:40:56 <merijn> cocreature: It depends how strong the recursion is too
05:41:22 <cocreature> merijn: what do you mean by that?
05:42:58 <merijn> cocreature: Well, if the right hand side of seq doesn't immediately force another layer of recursion then the order of seq wouldn't matter either
05:43:29 <cocreature> ah yeah
05:43:37 <dminuoso> By that logic foldl' would be pathological
05:43:53 <merijn> cocreature: So I think foldl' might actually be fine?
05:44:29 <merijn> cocreature: Because I think the recursion case only gets forced after seq returns (and thus the left-hand has already been forced)
05:44:40 <merijn> But I'm not 100% sure
05:47:57 <cocreature> I don’t think so, let’s say you use foldl' (+) 0 [x,y,z], then you could end up with "let a = 0 + x in `seq` foldl' (+) a [y,z]" → "let a = 0 + x in a `seq` let b = a + y in b `seq` foldl' (+) b [z]" → "let a = 0 + x in a `seq` let b = a + y in b `seq` b + z" and only then start forcing things
05:48:17 <cocreature> which is exactly what you’re trying to prevent by using foldl' instead of foldl
05:49:00 <merijn> cocreature: Except, you assume it starts forcing the 2nd "let-in" and I don't see why it'd have too?
05:49:29 <cocreature> merijn: it doesn’t _have_ to but it would be consistent with the semantics guaranteed by `seq` afaict
05:49:40 <dminuoso> rotcev: If you think about it, this is what allows you to have infinite lists.
05:50:20 <cocreature> so at that point you’re relying on the compiler recognizing that that would be a bad idea and I’m not sure that’s such an improvement over hoping the strictness analyzer transforms foldl to foldl'
05:50:41 <rotcev> dminuoso: i am not really familiar with seq or pseq yet
05:50:50 <dminuoso> :t seq
05:50:52 <lambdabot> a -> b -> b
05:51:07 <dminuoso> rotcev: pseq has the same signature. Its a primitive that forces the evaluation of the left argument, and then produces the right argument
05:51:37 <merijn> cocreature: tbh, I'd like a "Haskell" with better built-in support for manual memory layout (like Habit, which never went anywhere, afaict) and more focus on control over code-generation rather than relying on optimisation
05:51:46 <dminuoso> rotcev: Just (undefined + 3) `pseq` ()
05:51:54 <cocreature> merijn: right that’s exactly why this is annoying me so much :)
05:52:09 <rotcev> dminuoso: so it evaluates to Just, and returns ()
05:52:14 <cocreature> but I see remarkably little people complain about this, so I feel like I’m still missing something here
05:52:15 <merijn> cocreature: I often think I'd prefer a language with more room for specific control/hinting over optimisation
05:52:22 <rotcev> dminuoso: i.e WHNF
05:52:34 <dminuoso> rotcev: Right, it wont crash because "undefined" is never evaluated
05:52:34 <merijn> cocreature: Sadly no one's going to pay me to invent this language >.>
05:52:54 <merijn> cocreature: And there's more to life than write that shit as open source in my free time :)
05:53:25 <cocreature> merijn: :(
05:54:23 <merijn> cocreature: Well, if you know someone that has money to burn on that, I'm all ears :p
05:54:34 <cocreature> merijn: heh sadly not
05:55:17 <rotcev> dminuoso: im not making the connection to infinite lists, however
05:55:33 <dminuoso> rotcev: think of a list as just nested constructors
05:55:33 <rotcev> i guess [1..] is in WHNF
05:55:59 <dminuoso> (:) 1 ((:) 2 ((:) 3 [])
05:56:06 <merijn> rotcev: Well "[1..]" is sugar for "enumFrom 1", but you can evaluate it to WHNF in finite time, yes
05:56:57 <rotcev> > [1..] `pseq` ()
05:56:59 <lambdabot>  error:
05:56:59 <lambdabot>      • Variable not in scope: pseq :: [Integer] -> () -> t
05:56:59 <lambdabot>      • Perhaps you meant ‘seq’ (imported from Prelude)
05:59:23 <dminuoso> rotcev: This is the evaluation of that infinite list: https://gist.github.com/dminuoso/6ed305a6f3544b668d265ace4a07d3d0
05:59:44 <dminuoso> All you get to see is just the outermost (first) cons constructor.
06:06:27 <rotcev> dminuoso: i'm not sure that entirely makes sense to me right now... but i think my brain is boggled enough for today... thanks for trying to teach me all this stuff
06:23:31 <veverak> I have data type 'D'
06:23:46 <kabo> hi all~ :D
06:23:53 <veverak> can I somehow create [D] with 'D' initialized with all possible constructors?
06:24:31 <veverak> or, to be more precise, I have a datatype 'D' and I would like to print all it's constructors
06:26:53 <hpc> > [minBound .. maxBound] :: [Bool]
06:26:56 <lambdabot>  [False,True]
06:27:00 <hpc> > [minBound .. maxBound] :: [Ordering]
06:27:02 <lambdabot>  [LT,EQ,GT]
06:27:05 <hpc> > [minBound .. maxBound] :: [Int]
06:27:07 <lambdabot>  [-9223372036854775808,-9223372036854775807,-9223372036854775806,-92233720368...
06:27:17 <jaseemabid> @veverak, So you want `Just` and `Nothing` out of `Maybe`?
06:27:17 <lambdabot> Unknown command, try @list
06:27:26 <hpc> veverak: derive Enum and Bounded
06:27:27 <dminuoso> rotcev: maybe this simple example might help: https://gist.github.com/dminuoso/fcba7061ce5844fac9c77907d2e3e146
06:27:28 <veverak> jaseemabid: for example, yeah
06:27:48 <veverak> hpc: !!
06:27:53 <veverak> hpc: that sounds promising
06:28:21 <hpc> just be aware that it's not enumerating constructors, it's enumerating values
06:28:31 <hpc> > [minBound .. maxBound] :: [Either Bool Ordering]
06:28:33 <lambdabot>  error:
06:28:33 <lambdabot>      • No instance for (Enum (Either Bool Ordering))
06:28:33 <lambdabot>          arising from the arithmetic sequence ‘minBound .. maxBound’
06:28:41 <hpc> > [minBound .. maxBound] :: [Maybe Ordering]
06:28:43 <lambdabot>  error:
06:28:43 <lambdabot>      • No instance for (Enum (Maybe Ordering))
06:28:43 <lambdabot>          arising from the arithmetic sequence ‘minBound .. maxBound’
06:28:46 <hpc> :(
06:29:00 <jaseemabid> veverak, I don't know. That sounds like meta programming territory I usually avoid in Haskell.
06:29:13 <dminuoso> jaseemabid: Generics are kind of simple :)
06:29:21 <hpc> anyhoo if those worked, it'd be something like [Nothing, Just LT, Just EQ, Just GT]
06:29:31 <rotcev> dminuoso: why would you only want to evaluate to WHNF and no further?
06:29:51 <jaseemabid> dminuoso, I just never learned Data.Generics enough. Maybe.
06:29:52 <dminuoso> rotcev: If you were forced to evaluate into NF that list becomes useless
06:30:01 <dminuoso> rotcev: But if you only evaluate until WHNF, you can suddenly...
06:30:04 <dminuoso> `take 5` from that list
06:30:16 <rotcev> dminuoso: so for example take will evaluate 5 times into whnf
06:30:21 <rotcev> or something
06:30:25 <rotcev> take 5 ***
06:30:38 <dminuoso> rotcev: look at the definition of `take`, and use it with `take 2`. evaluate by hand.
06:31:53 <lortabac> veverak: this should be possible with Data.Data or GHC.Generics
06:32:01 <dminuoso> jaseemabid: They are really simple.
06:32:54 <lortabac> dminuoso: for a strict definition of simple :)
06:34:08 <lortabac> they can be very hard if you are not at ease with type-level programming
06:34:49 <dminuoso> lortabac: they taught me type level programming :P
06:34:54 <lortabac> :)
06:36:09 <rotcev> dminuoso: well i can see how take works but i don't think i fully grasp how WHNF comes into play
06:36:28 <jaseemabid> So a quick question to all haskellers here. I was trying to understand the 'trees that grow paper' recently because I have faced all the problems they were trying to solve like anyone else who has written a non trivial interpreter/compiler in Haskell. I found the paper fairly hard to understand, particulurly because it required a deep understanding of type families, which I haven't completely groked yet. Did anyone else here read it and feel the
06:36:28 <jaseemabid> same?  What material would you recomend me learn before I jump into this again?
06:37:21 <dminuoso> @src take
06:37:21 <lambdabot> take n _      | n <= 0 = []
06:37:21 <lambdabot> take _ []              = []
06:37:21 <lambdabot> take n (x:xs)          = x : take (n-1) xs
06:38:28 <dminuoso> rotcev: So here's the cool thing: if you take `take 2 list` and evaluate it, you will get some (:) back with thunks inside.
06:38:32 <dminuoso> So that happens instantly.
06:39:26 <dminuoso> The reason you get that back, is because `take 2 list` - by application, will pattern match until it matches on the third (because our `list` is not empty). And you get `(x : take (1-1) xs)` back - which is in WHNF already.
06:39:51 <veverak> lortabac: thanks, what hpc provided however fits more
06:40:03 <veverak> hpc: thanks, this is more 'kiss' solution than I anticipated
06:40:28 <dminuoso> rotcev: So its not until you try and access the second element of _that_ list, that it will unravel and evaluate our `list` one cell further
06:41:54 <merijn> jaseemabid: I haven't read it, but the "Fun with Type Functions" paper was a pretty good intro to type families for me
06:42:03 <merijn> jaseemabid: So maybe try reading that one first?
06:43:48 <veverak> one more thing O:) with Options.Applicative, is it somehow possible to force help :: String -> Mod f a, to honor '\n' chars or I have to use helpDoc?
06:44:23 <EvanR> jaseemabid: problems like performance problems? (i am on a toy compiler right now)
06:47:57 <jolster> I'm loading my tests in ghci via `stack ghci path:to:tests --test`, however I can't seem to use the functions defined in my test modules
06:48:15 <jolster> even after importing the modules in ghci via `import`
06:52:52 <infinisil> Whoaaa
06:53:09 <infinisil> The amount of comments in the source code of GHC is orgasmic
06:54:12 <hpc> infinisil: they link to papers explaining the algorithms and everything
06:54:19 <infinisil> I think I've never seen a project so well documented
06:54:37 <infinisil> hpc: Nice
06:54:59 <hpc> (at least in base they do)
06:55:34 <infinisil> I'm just looking through here: https://github.com/ghc/ghc/tree/master/compiler
06:55:49 <cocreature> jolster: do these modules have an export list and if so are the functions you are trying to use in that list?
06:55:51 <infinisil> almost every file is filled with comments
06:56:02 <cocreature> infinisil: https://ghc.haskell.org/trac/ghc/wiki/Commentary is also helpful
06:56:50 <infinisil> cocreature: Damn, that's amazing
06:56:56 <dminuoso> infinisil: If you think about it, when you implement an advanced type system with more extensions than GCC has compiler flags - documentation becomes nice!
06:57:10 <dminuoso> Also Ive endured the pain of working in GCC a few times. Thats fun.
06:57:24 <jolster> cocreature: I got it, I added it to the exposed-modules: in the library section of the cabal file
06:57:47 <jolster> idk why i couldnt just load the test suite in ghci and play with it
06:58:09 <infinisil> dminuoso: Because it's not as well documented, huge and C?
06:58:26 <cocreature> jolster: that should work afaik but it’s a bit hard to say what’s going wrong without knowing more information
06:58:27 <jolster> cocreature: actually...its not working still
06:58:41 <merijn> infinisil: For the longest time GCC's IR was intentionally obfuscated to make it harder for closed source tools to hook into it
06:58:43 <jolster> cocreature: the modules do have an export list
06:58:44 <dminuoso> infinisil: C++ and some C. It's documentation is poor and bad.
06:58:56 <cocreature> jolster: and are the functions you are trying to use in that list?
06:59:30 <jolster> cocreature: and the functions im trying to access are exported, ghc complains about unknown field: exposed-modules if I try to put it in the test suite section of the cabal file
06:59:52 <cocreature> jolster: is your project publically available somewhere?
07:00:05 * hackage unliftio-pool 0.2.1.0 - Data.Pool generalized to MonadUnliftIO.  http://hackage.haskell.org/package/unliftio-pool-0.2.1.0 (BardurArantsson)
07:00:20 <infinisil> dminuoso: merijn: Sounds pretty bad indeed..
07:00:31 <jolster> cocreature:  one sec
07:01:36 <dminuoso> infinisil: Plus GCC is filled with so much cruft.. and ancient things..
07:01:40 <glguy> Test suites wouldn't expose any modules
07:03:01 <glguy> You'd use other-modules
07:03:09 <dminuoso> infinisil: Just to give you a taste. GCC has an infrastructure known as FIXINCLUDES which will completely transparently "fix" (= search+and+replace) code in system headers that come from the system. For you. Silently. Sometimes.
07:03:43 <dminuoso> I happened to have triggered that machinery for some bizarre reasons. The debugging session that ensued drove me nearly into insanity.
07:04:18 <simon> is there a tutorial for having 'stack test' run in some container or on a server every time I push to GitHub?
07:05:03 <infinisil> dminuoso: So it rewrites the code??
07:05:23 <infinisil> Like a stage before the horrible string macro substitution?
07:05:35 <dminuoso> infinisil: Brilliant, isnt it?
07:05:43 <infinisil> Truly
07:05:51 <hpc> this is why naming things is the hardest problem in CS
07:07:17 <cocreature> simon: usually you would use some existing CI system for that. for open source projects travis-ci.org is quite popular and easy to set up for Haskell projects
07:07:21 <infinisil> I mean rewriting code isn't too bad for a compiler I think
07:07:39 <infinisil> It can be used to transform the program into a simpler core language
07:07:45 <dminuoso> infinisil: Except it does things like.. "turn char into int on that function argument"
07:07:46 <infinisil> But using it for imports doesn't feel right..
07:07:52 <dminuoso> infinisil: on your system headers.
07:08:03 <infinisil> Oh lol
07:10:18 <dminuoso> infinisil: https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=fixincludes/inclhack.def;h=42853da71b469ce00cc30abe1942aebe46c874e6;hb=HEAD
07:10:52 <dminuoso> That's the sort of mentality GCC is largely written in.
07:11:00 <glguy> Simon: https://github.com/haskell-CI/haskell-ci
07:11:09 <infinisil> Lol, regex
07:11:40 <infinisil> Oh boy that's pretty bad
07:12:51 <dminuoso> I mean I can partially understand the reasoning. When you have a quirky-as-heck architecture that ships wrong headers (and equally wrong compilers), then you're kind of forced to make due with that.
07:13:22 <dminuoso> Users wont care if GCC is compliant if it cant compile their programs on their exotic machines.
07:13:40 <infinisil> Hmm yeah I guess gcc does have to support a lot
07:15:00 * infinisil washes the C off his eyes and looks at some Haskell to hopefully fix the damage
07:18:56 <srk> :))
07:19:38 <srk> infinisil: I only generate C from haskell now :D
07:19:58 * hackage Hastodon 0.6.0 - mastodon client module for Haskell  http://hackage.haskell.org/package/Hastodon-0.6.0 (syucream)
07:20:37 <infinisil> The only sane way to use C
07:20:42 <merijn> srk: Just use Ptr and write your C directly in Haskell :)
07:21:18 <srk> merijn: I'm using ivory-tower for generating embedded C code, bit more heavyweight :D
07:21:21 <merijn> Storable vectors and Storable Ptr everywhere! :p
07:22:02 <cocreature> merijn: Storable vectors? you’re thinking way too high-level. ByteArray# is where it’s at!
07:23:02 <merijn> cocreature: Depends how you make your storable vectors!
07:23:37 <dminuoso> merijn: Can Haskell do inline assembly?
07:23:39 <merijn> cocreature: If you don't need MagicHash, you're not doing it right! https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs
07:23:45 <jolster> cocreature: you there still?
07:23:49 <merijn> dminuoso: "It Depends"
07:24:03 <merijn> dminuoso: Not really, but you can implement custom Cmm primitives for the compiler to use
07:24:09 <cocreature> jolster: yep
07:24:24 <merijn> dminuoso: And I think there's some C FFI stuff that lets you use C inline assembly via FFI
07:24:26 <cocreature> merijn: reminds me of https://github.com/andrewthad/packed/issues/4
07:25:59 <merijn> cocreature: In the end ByteString and Storable vectors are just Addr#, which is almost as good as ByteArray#
07:26:27 <merijn> Except slightly easier to deal with in terms of data coming from other libraries/code
07:27:29 <jolster> j
07:32:16 <jolster> cocreature: this is the branch https://github.com/input-output-hk/cardano-sl/compare/jordan/CDEC-336
07:32:48 <cocreature> jolster: alright so which commands do I need to run to reproduce the issue=
07:32:52 <cocreature> s/=/?/
07:37:28 <jolster> cocreature: from the core folder `stack --nix ghci cardano-sl-core:test:hedgehog --test `
07:38:24 <cocreature> jolster: alright, give me a few minutes. apparently that repo depends on all of hackage and uses an old compiler for which I don’t have any deps cached
07:39:23 <jolster> cocreature: yeah its a beast to build
07:48:33 --- mode: ChanServ set +o glguy
07:48:33 --- mode: glguy set +b *!*@*/ip.37.45.199.143
07:55:55 <jolster> cocreature: You need to remove `cardano-sl-txp` from the build depends of test-suite hedgehog in the cardano-sl-core.cabal
07:56:36 <jolster> before you try to repoduce my problem
07:56:43 <jolster> cocreature: You need to remove `cardano-sl-txp` from the build depends of test-suite hedgehog in the cardano-sl-core.cabal
07:57:36 <lortabac> veverak: it depends on the data-type. You cannot derive Enum if you have constructors with arguments
07:57:57 <jolster> cocreature: I just solved it, sorry for the trouble :P
07:58:06 <cocreature> jolster: great! what was the problem?
07:58:46 <veverak> lortabac: yeah, but it turned I don't need any arguments, but I understand that limitation of Enum,Bounded
08:00:14 <jolster> a dependency in my cabal file, `cardano-sl-txp` was causing the build to act strangely, sometimes allowing me to load the test suite into ghci, other times not
08:00:21 <jolster> once I removed that all was well
08:00:28 <cocreature> huh weird
08:00:41 <lortabac> veverak: ok, then generics are overkill
08:00:55 <veverak> lortabac: exactly my thinking, but I will keep them in mind
08:01:09 <exarkun> How does stdio interact with HSpec?  If I litter my code with `putStrLn` and run `stack test` to run my HSpec suite, I don't see any of the output I am expecting.
08:15:01 <[exa]> what's your favorite package to typeset haskell in latex? I'd especially like to _not_ have some identifiers (e.g. map, fold, ...) typeset as italic (as is standard with variable names), just the obvious variable names like x/y/a/b/c/...
08:17:29 <[exa]> (otherwise haskell.sty would probably be good enough)
08:22:32 <__monty__> For code listings?
08:29:09 <phadej> lhs2TeX, I like the defaults, and it's quite tweakable
08:34:41 <gobby> im trying to get hedgehog to print newlines in its error message
08:35:06 <gobby> but it will only print the newline character "\n"
08:35:33 <gobby> when using (===)
08:38:13 <geekosaur> gobby, you need to write your own replacement for (===) that doesn't use Show
08:38:20 <geekosaur> no, you cannot change the Show instance
08:39:03 <gobby> geekosaur: so I basically have to reimpliment (===) and all the underlying functions
08:39:41 <gobby> geekosaur: Which typeclass should I reimplement it with?
08:40:13 <geekosaur> that's not for me to determine
08:40:31 <geekosaur> you know what your needs are, I don't
08:41:56 <gobby> geekosaur: Do you have any suggestions? I'd just like to allow newlines to be printed
08:42:15 <gobby> geekosaur: i.e allow "\n" to format the output to terminal
08:42:35 <gobby> geekosaur: I'm genuinely unsure
08:45:54 <kaol> gobby: Perhaps this fits your use better: https://hackage.haskell.org/package/data-textual
08:48:53 <exarkun> Test.Hspec.Wai request is hanging my test suite, probably.  I'm stuck trying to figure out why.
08:53:49 <dmwit> gobby: I'm a bit confused. `(===)` doesn't appear to have a way to set the error message at all. Where are you putting newlines?
08:54:45 <dmwit> (Not familiar with hedgehog, so forgive me if that's a dumb question.)
08:56:28 <gobby> dmwit: `(===)` has `failDiff` which is where the items you are comparing are converted to `String`
08:57:29 <gobby> dmwit: The issue for me is changing `String` to another type that will allow pretty printing at the terminal, in my specific case the newline character
08:57:42 <gobby> changing that type however then means
08:57:52 <gobby> I have to modify a few other functions
08:59:31 <Boomerang> I don't know hedgehog, but quickly looking at the docs, would the functions `annotate` and `footnote` be useful for you to add debug info to test failure. Or do you want to print something that depends on what is computed in the tests?
09:01:03 * hackage bank-holidays-england 0.1.0.7 - Calculation of bank holidays in England and Wales  http://hackage.haskell.org/package/bank-holidays-england-0.1.0.7 (dcturner)
09:01:48 <gobby> Boomerang: Basically the error message prints the RHS of my (===) expression. The RHS contains newline characters which, when the test fails, also gets literally printed out
09:02:12 <dmwit> gobby: `newtype IPPrint a = IPPrint a; instance Show a => Show (IPPrint a) where show = pshow` ;-)
09:02:19 <dmwit> https://hackage.haskell.org/package/ipprint-0.6/docs/IPPrint.html
09:02:43 <the_2nd> is there a function similar to isInfixOf, but returning the index if found?
09:03:02 <glguy> the_2nd: You can use findIndex, isPrefixOf, and tails
09:03:12 <gobby> dmwit: I'll give it a go,
09:03:52 <the_2nd> glguy, searching for [a], not for a, tho
09:03:56 <glguy> right
09:03:57 <gobby> dmwit: I'm still unsure which function does the printing however
09:03:57 <dmwit> I mean, I happen to like IPPrint. But you can inject arbitrary code into a Show instance by adding a suitable newtype.
09:03:58 <the_2nd> so findIndex would be wrong
09:04:02 <glguy> no
09:04:30 <Boomerang> If you use `findIndex` after `tails` it'll work :)
09:04:54 <dmwit> :t \x -> findIndices (x `isPrefixOf`) . tails
09:04:55 <lambdabot> Eq a => [a] -> [a] -> [Int]
09:05:26 <the_2nd> ah, tails, not tail
09:05:31 <the_2nd> never used that, good to know
09:05:36 <Boomerang> :t tails
09:05:37 <lambdabot> [a] -> [[a]]
09:05:38 <the_2nd> that's why I was confused
09:05:44 <Boomerang> > tails [1,2,3]
09:05:46 * hackage alarmclock 0.4.0.4 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.4.0.4 (dcturner)
09:05:47 <lambdabot>  [[1,2,3],[2,3],[3],[]]
09:08:39 <rotaerk> :t sonic
09:08:41 <lambdabot> error: Variable not in scope: sonic
09:16:07 <EvanR> rotaerk please
09:16:36 <cheater> Sonic :: Mickey -> Felix -> Sonic
09:31:33 * hackage ixset 1.1 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.1 (DavidFox)
09:33:18 <Peaker> hey, in brick, what's the point of Widget's type parameter?
09:37:12 <rotaerk> EvanR, lol
09:38:06 * hackage milena 0.5.2.2 - A Kafka client for Haskell.  http://hackage.haskell.org/package/milena-0.5.2.2 (adamflott)
09:39:13 <hexagoxel> Peaker: it is a name/identifier type. some functions allow you do look up/affect a resource by that name.
09:39:51 <glittershark> Does anyone have a good example of a typeclass that provides an endomorphism?
09:39:52 <hexagoxel> Can make it a simple String, or just () if you don't need the functionality.
09:39:55 <glittershark> need it for a doctest
09:40:04 <Peaker> hexagoxel, thanks
09:40:11 <glittershark> `class Blah a where foo :: a -> a
09:40:44 <glittershark> was thinking `negate` from Num but not sure how well that reads in a doctest
09:41:48 <glittershark> succ or pred from enum might work too
09:42:27 <exarkun> Can I see what was derived as a result of a `deriving` clause?
09:43:32 <glittershark> exarkun: -ddump-deriv
09:44:50 <exarkun> thanks
09:45:51 * hackage tintin 1.4.6 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.4.6 (NickSeagull)
09:53:00 <dmwit> glittershark: Sounds like you answered your own question...?
09:53:14 * hackage edit 0.0.1.1 - A monad for rewriting things.  http://hackage.haskell.org/package/edit-0.0.1.1 (theindigamer)
09:53:16 <dmwit> Or if not, you should say what you don't like about your proposals, because it's a bit unclear to me what you're after.
10:01:38 <Gurkenglas> I have a function f :: [a] -> [a] with the fixpoints _|_ and one per spine shape. How do I get the non-_|_ ones?
10:03:45 <hpc> per spine shape, you mean for every length of the input list?
10:03:48 <Gurkenglas> yes
10:04:10 <Gurkenglas> One function with this property, for example, would be "map (0:)"
10:04:13 <exarkun> Text.Read operates on String instead of Text? :/
10:05:09 <dmwit> Gurkenglas: Write a function `forceLength :: [a] -> [a]` that pads (with `undefined`) or cuts short its input list.
10:05:20 <dmwit> Gurkenglas: Then `fix (f . forceLength)`.
10:06:02 <hpc> heh, i guess that counts
10:06:07 <Gurkenglas> 'kay
10:06:19 <hpc> even if you'll probably just get [bottom, bottom, bottom {x n}]
10:07:12 <dmwit> > let forceLength 0 xs = []; forceLength n xs = head xs : forceLength (n-1) (tail xs) in fix (map (0:) . forceLength 2)
10:07:14 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:07:44 <hpc> > let forceLength 0 xs = []; forceLength n xs = head xs : forceLength (n-1) (tail xs) in fix (map (const 0) . forceLength 2)
10:07:46 <lambdabot>  [0,0]
10:07:57 <dmwit> That's pretty neat!
10:08:50 <dmwit> exarkun: Much of the Text.* hierarchy predates Data.Text.
10:09:07 <hpc> it gives me some neat ideas about generalizing forceLength to create a "bounds" in which to find the least fixed point
10:09:24 <hpc> "find the least fixed point that's shaped like this"
10:09:50 <hpc> :t let forceLength 0 xs = []; forceLength n xs = head xs : forceLength (n-1) (tail xs) in forceLength
10:09:51 <lambdabot> (Eq t, Num t) => t -> [a] -> [a]
10:10:52 <dmwit> Now I'm imagining a Java person reading `.forceLength 2` as a method call on an otherwise apparently unremarkable function and getting hecking confused.
10:11:16 <hpc> class LimitedFix a where type Selector a; bounds :: Selector a -> a -> a
10:12:07 <Gurkenglas> I previously did something like that for many https://lpaste.net/150858
10:12:54 <hpc> instance LimitedFix Int where type Selector Int = (Int, Int); bounds range n = if inRange range n then n else undefined
10:13:05 <hpc> or something like that?
10:13:20 <hpc> that wouldn't work though, it'd be strict in n
10:15:30 <Gurkenglas> (a -> a) -> a -> a `flip (::)` \f x -> least fixed point of f no less defined than x
10:15:30 <dmwit> fix doesn't work super great on `Int`.
10:16:03 <dmwit> `const e` might be the only lazy function of type `Int -> Int`.
10:16:06 <hpc> yeah
10:16:29 <Gurkenglas> That one's a -> Int though :D
10:16:43 <dmwit> `e :: Int`. ;-)
10:16:51 <Gurkenglas> still a -> Int
10:16:55 <dminuoso> When I punch `runQ [d| f = 1 |]` into GHCi, what mechanism shows me the syntax tree? It does not appear to be through some `show`
10:17:00 <dmwit> Oh. Yes, but it also has type `Int -> Int`. =)
10:17:00 <EvanR> allowed to use I# or
10:17:01 <dminuoso> Or is that wired into GHCi?
10:17:02 <hpc> e = 3 -- rounded up
10:17:51 <EvanR> dminuoso: should be the show instance for whatever the return type is right
10:18:21 <dminuoso> EvanR: return type of what exactly?
10:18:29 <EvanR> runQ [d| f = 1 |]
10:18:30 <dminuoso> I mean this does not seem to be an IO action
10:18:34 <dminuoso> oh
10:18:46 <EvanR> s/return type/type/
10:18:50 <geekosaur> instance Language.Haskell.TH.Syntax.Quasi IO
10:18:56 <geekosaur> ghci would be fine with it
10:19:37 <dmwit> dminuoso: Why do you believe it is not some `show`?
10:20:03 <dminuoso> geekosaur: Ahh that's it. So it fits into `IO [Dec]`, and that's what I guess Im seeing?
10:20:11 <dminuoso> That is the [Dec] result of the IO action
10:20:12 <geekosaur> yeh
10:20:14 <dmwit> yes
10:20:18 <dminuoso> Gotcha thanks :)
10:20:47 <dmwit> Using unionWith to delete things from a `Map k (Set v)` feels wrong.
10:23:03 <lando_> Hello Guys. I have a question about "history" in some way.
10:23:34 <hpc> lando_: pipe through grep if there's too much output :P
10:23:42 <lando_> How programmers started to do type level programming in Haskell?
10:23:43 <lando_> The old fashioned way (no typefamilies, no datakinds, etc) to do nontrivial computations in compiling time was more or less using MultiParamTypeclasses and FunctionalDependencies.
10:23:43 <lando_> Were this extensions programmed knowing that someone could use them to, for example encode Size indexed vectors or it was a hack discovered after them?
10:24:33 <hpc> lando_: people already had ideas about the type-level language being the same as the value-level language
10:24:57 <hpc> so when experienced haskellers look at an extension, they see what value-level code it's able to express
10:25:34 <hpc> so you start with the regular type system being able to express natural numbers, for instance
10:25:40 <hpc> data Z = Z
10:25:43 <hpc> data S n = S n
10:26:06 <hpc> and then you see something that gets you something like pattern matching in the type system, and combine that with natural numbers
10:26:38 <hpc> and what's a useful thing to do with natural numbers? array indexing is pretty common
10:27:24 <tdammers> particularly enlightened haskellers will quickly realize the usefulness of all that and proceed to inventing Idris
10:28:53 <lando_> so the reason to add multiparamTypeclasses and fundeps was ad-hoc polymorphism, right?
10:29:15 <lando_> then some guys encoded functions and data at type level
10:29:48 <tdammers> I think those efforts were somewhat orthogonal and happened in parallel
10:29:55 <hpc> MPTC arguably doesn't need to be an extension, and limiting the language to single-param type classes was an arbitrary design choice
10:30:10 <tdammers> multi-param typeclasses are kind of an obvious solution to a common problem
10:30:28 <tdammers> or, indeed, just the removal of a pragmatic design decision
10:30:30 <hpc> fundeps solved a couple of problems
10:30:48 <hpc> mathematically functional dependencies were a pre-existing idea
10:31:21 <tdammers> practical fundeps follow logically from mptc, in that, well, you often want to express that the types in a multi-param typeclass instance depend on one another
10:31:45 <hpc> but when applied to the problem of class instance resolution, having "a implies b" makes certain things able to resolve to a unique instance
10:32:39 <tdammers> but I don't believe any of this came about based on the observation that the type-level and term-level languages are isomorphic
10:32:45 <hpc> i don't know if someone jumped specifically from "i can't write this type class" to "functional dependencies would solve this"
10:32:55 <hpc> or someone saw a dozen people with the same problem and got the idea that way
10:33:09 <hpc> or if someone just went "i wonder what functional dependencies would be good for" and implemented it
10:33:18 <tdammers> maybe a combination of all of them
10:34:17 <hpc> lando_: something you may find is that a lot of what looks like incredible leaps from useful thing to useful thing, are actually obvious logical progressions if you have the right variety of prior knowledge
10:35:27 <hpc> and learning enough variety to find those logical progressions is just a matter of time and breadth of attention
10:37:59 <lando_> thank you guys
10:45:41 <EvanR> hpc: great so nobody in particular invented advanced haskell
10:46:01 <EvanR> nobody is to blame
10:46:09 <byorgey> actually it was Oleg.
10:46:28 <EvanR> figures
10:46:33 <Clint> which haskell is advanced haskell
10:47:10 <EvanR> advanced dungeons and haskell
10:47:13 <hpc> turbo haskell
10:47:24 * Clint nods.
10:47:51 <ddellacosta> any Haskell library without documentation
10:48:17 <ddellacosta> and some with
10:48:40 <byorgey> Clint: advanced haskell is whichever haskell you can't understand at the moment
10:49:08 <maerwald> and chances are good you don't even need it
10:49:13 <hpc> TIL advanced haskell is windows haskell
10:49:22 * Clint shudders.
10:49:27 <glguy> hpc: In that case maerwald was right
10:49:40 <hpc> glguy: your @ is showing :P
10:49:46 <glguy> good eye!
10:51:10 <EvanR> the @ of sauron
10:51:43 <capisce> it's the thrill of the fight
10:52:54 <dminuoso> I have some `data S = A String | B String | C String | D Int | E Int ...` - Im trying to figure out how to pass a dictionary along the lines of [(1, A), (2, B), (3, C), (4, D), (5, E), ...] into TH to generate some boilerplate `toS` and `fromS` with
10:53:00 <pikajude> what's the shorthand name for foldr (<|>) empty?
10:53:01 <pikajude> i forgot
10:53:05 <hpc> capisce: lol
10:53:10 <dminuoso> pikajude: concat
10:53:12 <dminuoso> :t concat
10:53:14 <lambdabot> Foldable t => t [a] -> [a]
10:53:18 <glguy> :t asum
10:53:19 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:53:21 <dminuoso> Or that!
10:53:26 <pikajude> asum
10:53:28 <pikajude> yeah
10:53:31 <pikajude> thanks
10:53:43 <dminuoso> Can someone give me a pointer how I would pass that mapping between Int and constructors?
10:57:26 <EvanR> come asum (duke nukem or ash writing haskell)
11:02:43 <infinisil> Oh, the runtime system of Haskell is written in C?
11:02:48 <infinisil> I did not know that
11:05:28 <infinisil> Is there a technical reason this can't be done in Haskell?
11:05:38 <liste> infinisil: Haskell requires GC
11:05:46 <liste> which is kinda bad for *implementing* gc
11:05:49 <[exa]> infinisil: run a GC on GC on GC on GC ...
11:06:05 <[exa]> infinisil: it could be done in ivory or something like that though.
11:06:06 <EvanR> management the memory of the memory manager with itself
11:06:09 <infinisil> Oh right..
11:06:19 <EvanR> sounds good to me
11:06:48 <infinisil> Okay let's make the GC in C, is there a reason I can't do the rest in Haskell?
11:06:59 <infinisil> E.g. the STM implementation in the rts?
11:07:18 <[exa]> infinisil: some lowlevel linkage stuff must be in C because haskell has no language constructions that would make any sense that way
11:09:03 <[exa]> infinisil: otherwise the thing _could_ be done in Haskell (e.g. thread support, even STG evaluator) but it would be grossly impractical. C is good for writing VM support.
11:09:50 <infinisil> [exa]: What requires such lowlevel linkage for example?
11:10:17 <[exa]> infinisil: also there's the LHC project that takes an interesting way of destroying the runtime
11:10:41 <[exa]> infinisil: loading modules and linking to libc
11:11:02 <infinisil> Large Hadron Collider? :P
11:11:10 <[exa]> Large Haskell Compiler
11:11:30 <[exa]> no it's not large
11:11:44 <[exa]> (maybe lemmih is somewhere around)
11:14:31 * hackage snap 1.1.1.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-1.1.1.0 (DougBeardsley)
11:14:44 <infinisil> Looks interesting
11:18:15 * [exa] wishes ghc internals would be better for whole-program transformation
11:19:31 <atchoum> do you think it would be possible to implement a Haskell interpreter in Python ?
11:19:49 <atchoum> I have a question about functors
11:19:56 <[exa]> ad python: yes why not
11:19:58 <hpc> impossible, python would have to be turing-complete for that to work :P
11:20:03 <[exa]> lol
11:20:26 <EvanR> i tried implementing a compiler in python once... once
11:21:58 <infinisil> Does python have sum types?
11:22:00 <[exa]> notice how each sufficiently large project in python contains an ad-hoc, informally specified, bug-ridden slow implementation of a type system.
11:22:05 <liste> atchoum: yes, but why?
11:22:18 <liste> infinisil: not really... it has no types
11:22:23 <hpc> ^
11:22:25 <infinisil> Oh haha right
11:22:37 <infinisil> Yeah then you'd have to force me to write a compiler in it
11:22:38 <hpc> it doesn't have sum values either
11:23:01 <hpc> unless you do stuff with classes maybe
11:23:15 <hpc> and literally have a value that could be an object of one class or another
11:23:16 <EvanR> a higher order class
11:23:18 <liste> you can have "if isinstance(x, str): .... if isinstance(x, int): ... "
11:23:31 <liste> and then have wrapper objects with that pattern
11:23:41 <liste> to make them "sum" instead of "union"
11:25:35 <[exa]> learn2python way: replace the global isinstance with a wrapper that does it right
11:25:42 <maerwald> it's easy to emulate sum types in python
11:26:24 --- mode: glguy set -o glguy
11:31:14 <dmwit> atchoum: If you tell us what the question is, somebody might be able to answer it.
11:33:52 <[exa]> atchoum: anyway, I can imagine that Core interpreter can be coded easily in Python, if you can cheat a bit and use ghc as a frontend
11:34:38 <maerwald> https://docs.python.org/3/library/typing.html#typing.Union
11:36:25 <maerwald> it even has an Optional type, so there you have your sum types
11:40:55 <EvanR> probably going crazy here but... asm code is usually the prime example of an imperative language... but the more i look at it the more its turning into a "log" of what the computer is doing / did
11:41:05 <EvanR> dunno if thats the same thing or what
11:41:06 <glguy> maerwald: What was the name of the typechecker?
11:41:21 <maerwald> glguy: there are multiple
11:42:34 <byorgey> EvanR: I don't see the difference between a log and an imperative program
11:42:40 <maerwald> type annotations are part of the python standard
11:43:34 <EvanR> ok, when you get down to the goto line-numbers, then its not really a log anymore
11:43:42 <glguy> maerwald: Yeah, I just seemed to remember that the standard specified them but not how to use them and then the plan was to have other tools use them
11:43:52 <maerwald> there is mypy and pytype
11:44:02 <EvanR> but i have those represented as sub-logs which split into alternative realities
11:44:35 <EvanR> conditional branch
11:44:44 <maerwald> there's also coconut, which is a superset of python and has functional syntax
11:44:55 <maerwald> a bit, at least
11:45:49 <maerwald> coconut + mypy is funny, but don't expect too much
11:50:09 <atchoum> https://stackoverflow.com/questions/356950/c-functors-and-their-uses <- are they similar to functor instances in Haskell ?
11:51:16 * maerwald sees C++, instantly closes browser window
11:51:49 <EvanR> no they are not related
11:52:18 * hc likes c++
11:52:19 <atchoum> not even remotely ?
11:52:24 <EvanR> no
11:52:28 <hc> it has a turing complete typesystem, just like haskell ;)
11:52:49 <EvanR> a c++ functor is just an object which you can call, because it has overloaded ( )
11:53:14 <alp> C++ "functor" means "function like", because of the overloaded () as EvanR pointed out
11:54:21 <alp> Haskell's functors come from mathematics (category theory, as you've probably heard), the term was borrowed from there as well.
11:54:38 <EvanR> a haskell functor is a type that implements Functor. the type doesnt have to be like a function at all
11:54:39 <sinetek_> it has a preprocessor, unlike Haskell :-)(
11:54:48 <EvanR> or an object
11:55:54 <EvanR> you could read Functor as "map overable", as in the list map function
11:56:11 <EvanR> :t fmap
11:56:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:58:43 * hackage exp-cache 0.1.0.1 -   http://hackage.haskell.org/package/exp-cache-0.1.0.1 (ChrisCoffey)
12:02:23 <dmwit> How does one remove intervals from an IntervalMap? http://hackage.haskell.org/package/fingertree-0.1.4.1/docs/Data-IntervalMap-FingerTree.html
12:03:47 <dmwit> Something tells me this module has not seen much use.
12:04:06 <lyxia> splitAfter+leastView+union
12:04:25 <lyxia> indeed
12:05:15 <dmwit> Ugh. That seems quite inefficient if I have a specific interval I want to delete that isn't necessarily the smallest one starting at its lower bound.
12:06:01 <dmwit> But it is at least possible, which is better than what I believed when I stepped into the channel, so thanks for that. =)
12:08:22 <__monty__> hc: Haskell type system isn't TC thought?
12:08:30 <sqzlh> hm. When defining a mathematical function, which divides by zero, I would remove the 0 element from its domain e.g.  f: R \ {0} -> R
12:08:31 <sqzlh> It would be nice, if i could prevent division by zero (and similiar situations) in Haskell on a type level, for example by creating a float type with the zero element removed.
12:08:31 <sqzlh> What are your thoughts? I guess the custom float type might cause too much overhead..
12:08:38 <hc> __monty__: not by default, but with a few (standard) extensions
12:08:39 <sqzlh> err which divides by its parameter
12:08:50 <__monty__> hc: Which ones?
12:08:54 <sqzlh> *
12:09:35 <hc> __monty__: https://github.com/seliopou/typo
12:09:39 <lyxia> sqzlh: there's not much you can do with such a type though, since adding/subtracting will put the zero back in the domain
12:10:36 <__monty__> So you'd just end up moving the check out of the function definition and into the call site?
12:10:38 <dmwit> sqzlh: Some discussion on SO: https://stackoverflow.com/q/19730031/791604 https://stackoverflow.com/q/42341535/791604 https://stackoverflow.com/q/11910143/791604
12:10:44 <dmwit> sqzlh: Summary: use a newtype and smart constructors.
12:10:50 <infinisil> sqzlh: In Idris I'd do it with a function that requires a proof that the second operator isn't 0, which can be as simple as a test for y == 0 before calling the function
12:12:33 <phadej> does people really do it, aren't you "immediately" burried with proof obligations if you are actually doing some numeric calculations?
12:13:08 <dmwit> If you're doing a lot of numeric calculations in Idris, you're gonna have a bad time.
12:13:14 <phadej> fair point
12:13:55 <sqzlh> __monty__: True. Returning a Maybe would have almost the same effect while allowing the user to work with the Maybe monad....
12:16:30 <EvanR> Maybe ...
12:16:31 <EvanR> no
12:16:47 <EvanR> if you ensured that its impossible for the divisor to be zero, then what would you do with Nothing
12:16:58 <sqzlh> dmwit: Thanks for the links
12:17:12 <__monty__> EvanR: Maybe instead of requiring that proof.
12:17:33 <EvanR> thats like doing validation in rails at the very end of the request, when you put stuff in the database
12:17:47 <sqzlh> infinisil: I guess I have to take a look at Idris some time :)
12:17:47 <EvanR> when it makes the least sense
12:18:01 <dminuoso> EvanR: That's not entirely correct though. You're overexaggerating that bit on rails.
12:18:18 <EvanR> for division by zero, you need that proof whether the type system wants it or not
12:18:45 <EvanR> unless this is a special situation where you defined div by zero to be something
12:18:52 <hc> __monty__: and, what do you think? :)
12:19:11 <__monty__> Why exclude using Nothing as NaN?
12:19:46 <EvanR> having the entire program become a white screen of death in case of a bug
12:19:49 <__monty__> hc: It sounds cool, couldn't find which extensions it used though and a statement about it being TC.
12:19:56 <EvanR> the absolute worst case scenario
12:20:27 <dmwit> yeesh, extra drama today
12:20:34 <__monty__> EvanR: Why would Nothing be any worse than NaN?
12:21:35 <EvanR> its not even as convenient as NaN because you have to refactor all code that touches this code which cannot even return it, because there are no bugs
12:22:04 <__monty__> EvanR: To be clear, I wouldn't do this with Floats, I could see something like div :: Rationl -> Rational -> Maybe Rational though.
12:22:12 <EvanR> you could add a NaN or nothing to every expression in every program, but youd rather not, right?
12:22:58 <EvanR> in the case that Nothing is impossible, that will add performance overhead and wrist strain to the code writer
12:23:01 <EvanR> for no reason
12:23:23 <EvanR> if its an expected failure thats different
12:24:01 <hc> __monty__: undecidableinstances for example
12:25:39 <lukelau> Is it possible to return two different types that are both instances of the same class? https://lpaste.net/7524885051662663680
12:25:49 <dmwit> no
12:26:12 <lukelau> What would be a good way to work around this?
12:26:22 <geekosaur> Either?
12:26:31 <lukelau> Hm ok, thanks
12:26:46 <geekosaur> but you might also ask yourself if this is the right way to go about whatever you're doing
12:26:52 <__monty__> hc: Yeah, came across that in a HN thread. And it sounds TC but I don't think undecidability implies TC does it?
12:27:04 <Cale> lukelau: Your type says that the function can return a value of type a, for any a which is an instance of HasUri that the user of the function might want
12:27:12 <Cale> (which isn't true)
12:27:19 <dmwit> lukelau: Perhaps just return a `Uri` instead?
12:27:23 <geekosaur> in haskell, the caller decides the return type; if you say Fooa => ... -> a, that means the caller picks the a and you have to abide by it
12:27:35 <Cale> Yeah, it makes much more sense just to produce a Uri here.
12:27:40 <__monty__> EvanR: I still don't understand your objection tbh. Why is safeDiv objectionable when safeHead isn't?
12:28:47 <dmwit> (One can also return an existential. But then you lose everything about the type except that it is an instance of the given typeclass.)
12:28:53 <EvanR> i could erect the whole situation and known pitfalls with that approach again, perhaps as a blog post
12:29:49 <EvanR> and i didnt say anything about safeHead, it would have the same problem given the same circumstances
12:30:29 <__monty__> EvanR: And what are these problematic circumstances?
12:31:13 <EvanR> my spam credits in here are almost up so, ill have to repeat myself in another format at some point
12:31:46 <__monty__> EvanR: Feel free to PM me or ping me in offtopic.
12:32:03 <Cale> lukelau: I don't know what the methods of the HasUri type class are, but if it's anything like how it sounds, all you'd be able to do with something of an unknown type that is an instance of HasUri is to get a Uri anyway, right?
12:32:50 <lukelau> Yeah it’s the generated classes from Lens
12:33:26 <lukelau> I want to be able to both read and write to the object though
12:33:44 <lukelau> I was thinking of returning a lens, but then I lose the decoded instance of the object
12:33:48 <dmwit> What else do you want to be able to do with the object?
12:33:55 <Cale> But once you forget its type, there's no point in writing to it, since the only thing you can do is still just get the Uri back.
12:35:08 <Cale> (unless you mean write in the sense of mutation perhaps, in which case something else which knows its type might be able to do more than that)
12:35:25 <sqzlh> Another question, but somewhat reverse:  Is there some concept of "combined" types? For example: https://pastebin.com/vcYYtH3P
12:35:26 <sqzlh> Creating RGB and HSL as their own types allows for functions, which handle just RGB or HSL colors as their domain. Having a combined Color type then allows for functions, which can handle both representations. However, the Color type is rather clumsy.
12:35:27 <sqzlh> Any thoughts? Maybe I should just go with one color type and then use maybes again, when a function can only handle the HSL representation, etc.
12:35:38 <lukelau> Those types are also instances of ToJSON from Data.Aeson
12:36:02 <lukelau> The plan is to decode a bunch of objects, get and set their `uri` properties if they have them, and then encode them again
12:36:09 <dmwit> sqzlh: http://hackage.haskell.org/package/colour works this out in detail
12:39:06 <lukelau> Maybe I’ll do something like this instead
12:39:07 <lukelau> https://lpaste.net/1523445447014744064
12:39:51 <Cale> Yeah, you could do something like that.
12:40:11 <Cale> You could also just decode to Value
12:40:44 <Cale> (though that would mean something slightly different)
12:41:06 <lukelau> Originally I’ve been decoding down to just Object, and then working through it as a hashmap
12:41:15 <lukelau> Since these types can be nested indefinitely
12:41:38 <lukelau> And I need to modify all instances of these types wherever they occur
12:42:26 <sqzlh> dmwit, thx
12:42:27 <sqzlh> dmwit, thx
12:43:47 * hackage snaplet-postgresql-simple 1.1.0.0 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-1.1.0.0 (DougBeardsley)
12:44:09 <lukelau> Does Aeson have any function like (Object -> Maybe a) for converting it to a type?
12:45:06 <clever> lukelau: one min
12:45:54 <clever> lukelau: i think this is doing something close to what you want: https://github.com/input-output-hk/cardano-sl/blob/develop/tools/src/launcher/Main.hs#L188-L200
12:46:46 <clever> lukelau: line 188 decodes the json/yaml into a Value object, 195 recursively mutates the Value, returning a new Value (you can skip that), and then 196 calls fromJSON to turn the Value into a normal type
12:47:42 <lukelau> Thanks
12:47:42 <lyxia> lukelau: fromJSON . Object   ?
12:50:16 <lukelau> clever: I’m currently doing something similar with working with raw Values
12:52:10 <lukelau> lyxia: I’ll try that!
12:55:12 <Gurkenglas> https://lpaste.net/1523445447014744064 seems like it ought to look like "foo = over (prismSum (encoded @VersionedTextDocumentIdentifier) (encoded @TextDocumentIdentifier)) doStuff" but that'll run into the same problems map show does :I
13:01:04 <Gurkenglas> I suppose you could do "uriVia x = encoded x . uri" (not that encoded or uri aren't invented on the spot) (also I don't know if type annotation passing works that way)
13:01:38 <Gurkenglas> -"annotation"+ ... symbol? label?
13:03:32 <EvanR> lukelau: theres withObject for interpreting a Value as an object in such a way. By running the resulting Parser you get your maybe
13:03:59 <ZeuPiark> hell
13:04:09 <ZeuPiark> o
13:05:19 <EvanR> parseMaybe (withObject "MyCoolType" (\o -> ...)) myValue :: Maybe MyCoolType
13:06:15 <hc> __monty__: something that's undecidable to me by definition means turing complete
13:06:44 <sqzlh> ..I guess my previous question boils down to determining, whether HSL, RGB and Color really are distinct types
13:06:45 <hc> __monty__: https://en.wikipedia.org/wiki/Halting_problem
13:08:04 <EvanR> you could think of them as different views of the same type
13:08:25 <EvanR> like polar vs rectangular representation of complex numbers
13:15:54 <trcc> Hi Guys, I have some issues working with aeson and Object. I know Object is a type synonym of HashMap Text Value. I have updated the Value part, and know I am trying to insert it using HashMap.strict.insert. I am getting the error: Expected type HashMap Text Object  Actual type: Object. However, my object is a HashMap Text Object, or should be
13:16:03 <trcc> any way to convert between the two?
13:16:39 <__monty__> hc: There's undecidable problems on CFGs which is less powerful than a TM.
13:18:05 <EvanR> trcc: its a little confusing, Object is a type synonym and a constructor for the Value type
13:18:19 <trcc> It really is
13:18:25 <trcc> I haven't quite figured it all out yet
13:18:31 <EvanR> to promote an Object to a Value, wrap it in the Object constructor
13:18:54 <Cale> Yeah, sounds like you want to fmap Object
13:19:56 <trcc> EvanR: that gives me expected type: Hashmap k Value, actual type: Value
13:19:58 <EvanR> yeah fmap Object myHashMap will wrap every element of the hashmap with Object
13:20:27 <EvanR> youll probably have to gist some actual code
13:21:11 <int-e> __monty__: That's a tricky claim. For example, the undecidability of universality of a CFG is proved by reduction from the halting problem.
13:21:21 <trcc> A really close now! Expected: HashMap Text Object - actual: HashMap Text Value
13:21:50 <trcc> EvanR: I'll create a gist
13:23:17 <trcc> EvanR: https://lpaste.net/5991413566136123392
13:24:18 <EvanR> you should also include the error
13:25:20 <trcc> EvanR: new one: https://lpaste.net/1027796815077965824
13:25:49 <EvanR> ;_; if you put the error at the bottom, the line numbers will work
13:25:52 <__monty__> int-e: Maybe I should've said *deterministic* CFGs?
13:26:10 <trcc> haha obviously..
13:27:25 <EvanR> i think you wanted Hm.insert "fmus" (Object result)
13:27:53 <EvanR> er
13:28:10 <trcc> https://lpaste.net/4643585702607454208 - put errors in bottom
13:28:20 <trcc> still need the original hashmap in between right?
13:28:37 <EvanR> the original hashmap goes at the end
13:28:41 <EvanR> third argument to insert
13:28:46 <trcc> oh god
13:28:51 <trcc> I messed up the order of arguments
13:28:54 <trcc> Thank you
13:28:57 <EvanR> thats one issue
13:29:23 <trcc> It is because result is a object, and I need to convert it to a Value?
13:29:33 <EvanR> youre trying to insert an Object... which is not a Value, until you wrap it with Object
13:29:58 <EvanR> its gotta be a Value
13:30:25 <trcc> ah so Object is both a type and a constructor of Value
13:30:48 <EvanR> for future reference you can save some headache by putting more type annotations to sanity check what types you think things are
13:31:05 <EvanR> Object is a synonym and a constructor
13:31:07 <trcc> EvanR: I already did, the thing that really messed me up was the mix up of arguments
13:31:46 <AdituV> hiya.  I'm using stack with hpack, how do I set a flag for a dependency?  In particular, I want to use diagrams with -frasterific
13:32:32 <EvanR> and the String constructor is even potentially more confusing :)
13:33:09 <trcc> Guess i'll see that when I get to it EvanR :)
13:33:58 <EvanR> the haddock for Value is your friend http://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#t:Value
13:38:09 * hackage multiset 0.3.4 - The Data.MultiSet container type  http://hackage.haskell.org/package/multiset-0.3.4 (TwanVanLaarhoven)
13:43:19 <byorgey> AdituV: on the command-line, you can do  stack build --flag diagrams:rasterific
13:43:32 <byorgey> AdituV: I think there is a way to set it in stack.yaml but I don't know the syntax off the top of my head
13:43:37 <byorgey> AdituV: see here: https://github.com/commercialhaskell/stack/issues/191
13:44:32 <AdituV> byorgey: thanks!
13:47:27 <Gurkenglas> These days, the extra work in https://github.com/OlafChitil/hat/blob/master/HowToBuild.txt should be able to be automated, right? With some extra lines in some setup file
13:50:52 <Gurkenglas> What does it mean if stack install gives me output like "ghc-pkg.EXE: cannot find package stm-2.4.4.1"?
13:51:47 <Gurkenglas> (Ah, probably that stack remembers building that package but just not being able to find it in the folders that I deleted some old builds from)
13:51:49 <phadej> Gurkenglas: yes and no, you really really really should reconsder if you are considering build-type: Custom
13:52:17 <phadej> they are PITA for any tooling
13:52:54 <Gurkenglas> phadej, what should one do instead? Rebuild the files manually, as the HowToBuild says? Desperately refactor to not have the problem in the first place?
13:53:40 <phadej> Gurkenglas: what hat asks you to do sounds more like "bootstrapping of hat usage", than "building the hat package"
13:53:40 <Gurkenglas> (What is this tooling you speak of?)
13:54:44 <Gurkenglas> You mean the non-.cabal parts are only of relevance to the maintainer?
13:55:27 <phadej> Gurkenglas: Cabal/cabal-install/stack/... all what is "builds Haskell". I seriously recommend to use something else to orchestrate "builds of bigger systems (with not-Haskell)", i.e. if automate than not with Setup.hs but via shake/bash/whatever script
13:55:28 <Gurkenglas> so should be named HowToMaintain.txt, or the task handed to travis :D
13:56:56 <phadej> I'm not sure what hat does.
13:57:31 <dmwit> hc: Equating "undecidable" and "Turing complete" just seems like a category error to me. "undecidable" is a property of sets of strings. "Turing complete" is a property of computational models.
13:57:39 <Gurkenglas> Neither am I! There's bits of info spewed around
13:57:41 <phadej> when the extra build-steps are irrelevant of target platform, than it makes sense to have a "Makefile (or Shakefile or ...)" to prepare them so, `cabal sdist` can pick all the ready stuff
13:58:17 <Gurkenglas> There's allegedly outdated docs in the docs folder
13:58:19 <phadej> but if they are target platform dependent, than things are hairy, and luckily I haven't need to go there
13:59:51 <Gurkenglas> https://github.com/OlafChitil/hat/blob/master/docs/tutorial1.tex this appears relevant. *googles how to view .tex files on github*
13:59:55 <phadej> on the other news, linkedin's "top job picks for you" are entertaining. Clearly there's a lot to do in the AI land.
14:00:10 <dmwit> AI. So hot right now.
14:00:38 <dmwit> Deep learning! GPUs! What if we mix TensorFlow and Bitcoin??!?
14:00:46 <phadej> Gurkenglas: similarly as some of us can type-check polymorphic recursion and HKT in our heads, some have developed a so called rendered tex-vision.
14:01:29 <phadej> dmwit: well, it would be nicer if the PoW actually did something relevant, than a crypto-puzzle
14:01:37 <__monty__> dmwit: You're right of course. But don't you agree that "UndecidableInstances" sounds like it might imply turing completeness of the class system?
14:01:50 <EvanR> AI, does this mean a resurgence in popularity for LISP
14:01:54 <__monty__> phadej: PoS ftw, if only for the acronym ; )
14:02:08 <phadej> I have no stake.
14:02:27 <phadej> seeking for work.
14:02:35 <phadej> (not true though, just to complete the joke)
14:04:21 <dmwit> __monty__: With my poor faulty wetware, definitely. But with careful thought I can remind myself that the implication goes the other way.
14:05:16 <dmwit> "This thing is undecidable" is a pretty decent heuristic for "I can encode all computations in this thing somehow". But it is just a heuristic, and sometimes wrong.
14:07:20 <Gurkenglas> The set of turing-complete undecidable languages is countable, the set of undecidable languages is uncountable
14:07:29 <phadej> there are Lambda calculus evaluators on type-level in Haskell. QED.
14:08:17 <__monty__> phadej: But what extensions do they require?
14:08:45 <Gurkenglas> (actually I suppose if the reduction needn't be surjective, you can enter the infinite by reading between the lines)
14:08:50 <__monty__> Gurkenglas: That gets us closer but we need to know whether TC is the weakest thing in that set or not : )
14:09:02 <haskell_noob1> I need some help with debugging wss connections... the server is sending a bad request back. I have the wireshark output..is it something that someone can help me with?
14:09:51 <EvanR> is this haskell related
14:10:14 <haskell_noob1> yeah..sorry the client is network websockets. I can see the python client connect correctly.
14:10:19 <EvanR> tickets please, tickets
14:10:56 <Gurkenglas> haskell_noob1, the server is not haskell, and you have a haskell client and a python client
14:11:19 <Gurkenglas> and the python client sends correctly and receives correctly, and the haskell client sends correctly and receives incorrectly?
14:11:24 <haskell_noob1> yeah: to set a context: the server is a kube pod and i need to connect to it.
14:12:05 <Gurkenglas> Surely there must be some difference between what the clients send if there's a difference in what they receive. Try inspecting what the clients send on wireshark.
14:12:06 <haskell_noob1> yep..of course there could be a few bugs along the way in the way I am forming the requests...i need some insight into how to go about debugging this.
14:12:44 <haskell_noob1> i have the comparable output..and yeah they are different at a point that the client is resetting the connection.
14:13:15 <haskell_noob1> what i was hoping to see is whether the tls parameters that i am setting are being sent to the server?
14:14:22 <haskell_noob1> gurkenglas : https://lpaste.net/2749949405078487040 the relevant code.
14:14:34 <Peaker> If only a few SCC's are used and no -prof-all, should building with profiling significantly affect performance? Does profiling cancel any optimization flags or anything like that?
14:15:00 <phadej> __monty__: not sure, https://wiki.haskell.org/Type_arithmetic#A_Really_Advanced_Example_:_Type-Level_Lambda_Calculus
14:15:21 <phadej> functionaldependencies at least
14:15:46 <Gurkenglas> "hat-make.exe: Please give the name of the file to hat-make on the command line" shouldn't be accompanied by a stack trace, right?
14:16:57 <geekosaur> Peaker, it disables most optimizations including cross-module inlining
14:17:36 <Gurkenglas> haskell_noob1, shouldn't any present tls parameters be visible in the packets wireshark sees?
14:18:09 <Peaker> geekosaur, why? Wouldn't it make more sense to just count costs at the SCC's specifically?
14:18:23 <Gurkenglas> Apparently hat assumes ghc is on the path. How do I make stack make that available? stack install ghc or something?
14:18:38 <geekosaur> more precisely it disables all inlining, because you get miscounts otherwise
14:18:56 <geekosaur> Gurkenglas, stack exec hat-make ...
14:19:08 <haskell_noob1> gurkenglas : let me chk again. I couldnt see the strings related to my CA when i ran the WS.runClientWithStream call.
14:19:37 <geekosaur> Peaker, beyond that ask over in #ghc
14:19:53 <Peaker> geekosaur, ok thanks
14:20:22 <Gurkenglas> Ah :D cute, geekosaur
14:25:45 <Gurkenglas> https://lpaste.net/8543403255617552384 how do I troubleshoot this? Should I make a github issue for this?
14:27:09 <geekosaur> is hat installed in that ghc? if not, where?
14:29:01 <Gurkenglas> I'm not sure what you mean by "in that ghc". I installed hat by cloning https://github.com/OlafChitil/hat/tree/master/Hat and running stack init and stack install in there
14:29:31 <Gurkenglas> Do I need to use the same resolver hat used for programs hat is to work on?
14:33:31 <geekosaur> yes, and same ghc, etc.
14:33:51 <geekosaur> if you did stack init in there then it's going to be easiest to run it in there
14:38:34 <Gurkenglas> All else equal, resolver determines ghc, yes?
14:40:17 <geekosaur> yes
14:42:40 <Gurkenglas> geekosaur, I changed the resolver of the target project to the one hat used to be installed and rehatted it, with a stack build thrown in for good luck, and still those errors
14:43:14 <geekosaur> yes, you'd also need to add it to the project since hat isn't in the resolver proper
14:43:29 <Gurkenglas> How do I "add it to the project"?
14:43:36 <geekosaur> alternately you reinstall without stack init so it goes to the global project, then edit the global project to include hat
14:44:02 <geekosaur> stack.yaml
14:44:21 <geekosaur> as an extra-deps presumably
14:44:50 <geekosaur> but from here you probably need someone with more stack experience
14:45:05 <Gurkenglas> Added "extra-deps: [hat]", no change. Is that the right sort of name?
14:45:17 <geekosaur> programs like hat don't play well with sandboxes in general and "smart" sandboxing like stack's in particular
14:46:16 <geekosaur> sigh. anyone around with actual stack experience?
14:46:29 <Gurkenglas> (Perhaps hat should go in the .cabal and then I rerun stack init?)
14:47:17 <__monty__> phadej: Thanks. Is LC with only one variable TC though?
14:47:27 <Gurkenglas> Perhaps I should take the union of the hat and target project folders and concatenate the config files?
14:47:42 <geekosaur> sigh
14:48:00 <Gurkenglas> (with appropriate fusing of one-of fields)
14:48:06 <geekosaur> do I need to go learn how to do this, since you've decided I didn't actually mean "but from here you probably need someone with more stack experience"
14:48:39 <Gurkenglas> No, my ranting is not focused on you
14:49:18 <Gurkenglas> (maybe I should start putting names in front of each line so i can stop doing that at a dramatic time)
14:50:26 * hackage enum-subset-generate 0.1.0.0 - Generate an ADT being a subset of another ADT, and the corresponding mappings.  http://hackage.haskell.org/package/enum-subset-generate-0.1.0.0 (0xd34df00d)
14:52:47 <iqubic> Is Haskell a low level language?
14:53:13 * Clint chuckles.
14:53:44 <__monty__> iqubic: Yes, because it doesn't escape Set 2.
14:54:08 <iqubic> __monty__: Lol. I see. So Kinds are level 2?
14:54:18 <iqubic> s/level/kind/
14:54:30 <iqubic> *set
14:54:39 <iqubic> level should be set
14:54:43 <__monty__> Yes, at least that's the correspondence with agda afaiu.
14:55:14 <Tuplanolla> We're just waiting for Eisenberg to make Haskell a real high-level language.
14:55:52 <__monty__> Aren't they planning Idris-like Type in Type? That traps us at the lower levels forever : (
14:55:54 <EvanR> in 9018 they will dust off haskell and boggle at our ignorance
14:57:44 <iqubic> If I create a typeclass, and a few instances of this typeclass what will I need to export from this file? Export being the stuff here "module Foo where (EXPORTS HERE)"?
14:58:14 <iqubic> And is it possible to export only some of the functions defined in the typeclass, and not all of them?
14:59:29 <iqubic> I want to be able to use the instances in another file, but only be able to call a certain subset of the functions defined in the typeclass definition.
15:02:14 <__monty__> I don't think such a restriction'd make sense.
15:03:29 <hpc> iqubic: class functions are exported like normal functions
15:04:01 <hpc> module Foo (ClassName, functionName) where class ClassName a where functionName :: a, function2Name :: a
15:04:22 <iqubic> What is that showing?
15:04:49 <hpc> the answer to your question
15:04:55 <iqubic> I can just export individual functions from inside typeclass?
15:04:57 <hpc> it exports instances, the class name itself, and one of the functions
15:05:01 <__monty__> Wrong again...
15:05:24 <hpc> (instances are always exported, to do otherwise breaks the global nature of instance resolution)
15:05:43 <hpc> __monty__: eh?
15:06:14 <__monty__> hpc: Just that I was wrong again with my assumptions.
15:06:26 <hpc> oh, i see
15:07:00 <hpc> i agree that it doesn't entirely make sense though, usually the point of a type class is to let other people write instances
15:07:07 <hpc> and private class functions runs counter to that
15:07:08 <iqubic> Let's say I have a data type like "data bar x = baz x x". can I prevent people from directly making an instance of that type, and just export a smart constructor?
15:07:39 <__monty__> I figured ghc'd check the constraint, lookup the class definition and add those functions to the names available in the function.
15:07:47 <hpc> iqubic: that's not a type class
15:08:09 <iqubic> No, but I still want to do it.
15:08:15 <__monty__> iqubic: Yeah, you can just not export constructors.
15:08:18 <hpc> well, it's a different question
15:08:44 <iqubic> __monty__: Oh, I see. That works than.
15:09:01 <hpc> module Foo (TypeName, function) where data TypeName = Something; function :: TypeName
15:09:22 <hpc> just don't add (..) after TypeName
15:09:37 <iqubic> Cool. And will people be able to write functions using TypeName as a constraint?
15:09:51 <hpc> no, because it's a data type
15:09:59 <iqubic> Right. I get that.
15:10:32 <hpc> if you mean "is Something in scope", it is not in scope
15:10:44 <iqubic> That's good.
15:11:37 <iqubic> I know have a much better understaning of how the export system works.
15:12:14 <iqubic> If I hae File A and File B in the same folder Foo, do I still need exports to share functions between them?
15:12:26 <iqubic> I assume yes, but I just want a sanity check.
15:13:04 <hpc> you have modules Foo.A and Foo.B in that case
15:13:12 <hpc> one of them has to import the other to use things defined in it
15:13:17 <hpc> but not both, or you have cyclic imports
15:13:28 <hpc> modules are modules :P
15:13:35 <iqubic> That is exactly what I expected. Thank you.
15:14:28 <__monty__> iqubic: You don't need explicit exports. But it's best practice.
15:14:39 <iqubic> Cool.
15:32:20 <rotaerk> any idea if there's some way to say "if file A changes, consider file B dirty when rebuilding"?
15:33:41 <rotaerk> e.g. I have some GLSL shader files, and in a haskell source file I put some TH that will call out to a program that compiles GLSL into SPIR-V, and then it takes the result and embeds it directly into the haskell file
15:33:58 <Gurkenglas> https://lpaste.net/4345316836833755136 "stack exec hat-make editdistancearrayreview.hs" produces errors such as "Failed to load interface for Hat.Hat". How do I get this working?
15:34:11 <rotaerk> but if I build successfully, and then modify the shader file without modifying the haskell file it would get embedded in, it doesn't recompile the shader file
15:34:17 <rotaerk> I have to rebuild all, or touch the haskell file
15:34:43 <Gurkenglas> Perhaps I could have a cabal sandbox with multiple projects in it, and use cabal instead of stack?
15:34:51 <Myrl-saki> I just realized how close Bash's conditional statements is to idiomatic Haskell.
15:43:51 <isd> Hey all. I'm getting a confusing error re: overlapping instances; here is a minimal version of the code: https://lpaste.net/8306177033445048320
15:43:58 <isd> The error message is in the comment at the bottom.
15:44:53 <isd> I don't understand why it things Super a => Sub a is a candidate in this case; the constraints fro that one shouldn't be satisfied, since there's no Super instance.
15:45:01 <isd> Any ideas?
15:46:18 <Myrl-saki> isd: interfaces are made with extensibility in mind. If you can extend it so that it overlaps, then it's an overlapping instance.
15:46:39 <Myrl-saki> At least that's how I understood it.
15:47:59 <isd> Ok, that makes some sense.
15:48:16 <lyxia> isd: instances are chosen without looking at their constraints.
15:52:18 <Gurkenglas> Will "stack exec cabal build" cooperate with my previous "cabal sandbox init"? Alternatively, how do I troubleshoot "cabal: The program 'ghc' version >=6.4 is required but it could not be found."?
15:55:47 <Gurkenglas> (oh right, stack exec cabal build says "cabal.EXE: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible")
15:56:40 <Gurkenglas> (stack install ghc does nothing to "cabal build" going "cabal: The program 'ghc' version >=6.4 is required but it could not be found.")
16:22:26 <exarkun> How do I get better failure messages out of Test.QuickCheck.monadic.assert?
16:27:30 <Gurkenglas> exarkun, replace 'assert b' with 'unless b $ fail "Better error message"'
16:28:20 <Gurkenglas> (which I derived by finding http://hackage.haskell.org/package/QuickCheck-2.11.3/docs/src/Test-QuickCheck-Monadic.html#assert )
16:28:48 <exarkun> Where is `unless` from?
16:29:40 <exarkun> Control.Monad?
16:30:04 <Gurkenglas> http://hayoo.fh-wedel.de/?query=unless yes
16:30:51 <exarkun> thank you
16:31:48 <Gurkenglas> Further investigation reveals that https://stackoverflow.com/questions/31701863/test-quickcheck-monadic-why-is-assert-applied-to-bool-not-testable-a-a also would have hinted at unless by using it the way I did
16:32:34 <Gurkenglas> First and last link have googling 'test quickcheck monadic assert' to get there in common
16:35:00 <Gurkenglas> A neat story for why googling is an art would be that whenever someone figures out science parts to it, Google notices them and then they dont work anymore and the search engine works a little better.
16:53:35 * hackage numhask-range 0.2.2.1 - Numbers that are range representations  http://hackage.haskell.org/package/numhask-range-0.2.2.1 (tonyday567)
16:54:46 * hackage numhask-histogram 0.1.2.1 - See readme.md  http://hackage.haskell.org/package/numhask-histogram-0.1.2.1 (tonyday567)
17:05:34 * hackage quickselect 0.1.0.0 -   http://hackage.haskell.org/package/quickselect-0.1.0.0 (oisdk)
17:39:50 <marxS> why doesn't "mod (f . g . h x) 10" work, when "mod (f (g (h x))) 10" does?
17:39:54 <marxS> aren't they doing the same thing?
17:41:00 <marxS> since . is just composition of functions
17:41:11 <marxS> and the composition should be bounded by the final bracket
17:42:21 * slack1256 is marvelled at how nice yi is
17:46:27 <marxS> ah nevermind, I figured it out
17:46:29 <rotaerk> marxS, (f . g . h x) a is equivalent to \a -> f (g (h x a))
17:47:02 * hackage backprop 0.2.4.0 - Heterogeneous automatic differentation  http://hackage.haskell.org/package/backprop-0.2.4.0 (jle)
17:47:16 <rotaerk> if you put a $ between the h and x, then it'll work like you expected
17:47:45 <marxS> the $ ends at the closing bracket, right?
17:47:49 <marxS> so it ends after the x
17:48:10 <rotaerk> mod (f . g . h $ x) 10
17:48:17 <marxS> ye
17:48:41 <EvanR> ok. no, $ is low precedence application
17:49:01 <EvanR> so that gets grouped as mod ((f . g . h) $ x) 10
17:49:11 <rotaerk> yes, that's what he wanted
17:49:22 <EvanR> you might like to try mod ((f . g . h) x) 10 instead
17:49:45 <rotaerk> that's the same thing
17:49:47 <EvanR> or let e = f . g . h in mod (e x) 10
17:50:07 <EvanR> these are other less intimidating styles
17:50:43 <EvanR> rotaerk: i was just mildly enraged by "$ ends at ..."
17:51:18 <EvanR> and similar folk theories on $, like "it makes it right to left"
17:52:11 <mniip> "multiplication is executed before addition"
17:55:19 <rotaerk> lol
17:55:56 <rotaerk> I basically just ignored his wording and explicitly stated what I meant
17:56:06 <rotaerk> I wasn't sure what he meant by that
17:56:50 <EvanR> haskell conservative party, reduce spending $ on code
17:56:55 <rotaerk> :P
17:59:07 <slack1256> haskell conservative party doesn't like big import lists
17:59:28 <EvanR> agreed
19:02:04 * hackage fsnotify 0.3.0.0 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.3.0.0 (thomasjm)
21:04:50 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
21:04:50 --- topic: set by geekosaur on [Thu May 17 06:28:54 2018]
21:13:12 <hololeap> so, i would expect this to count numbers infinitely (one per second) and then exit immediately when a key is pressed, but it doesn't exit: http://dpaste.com/300V6ME
21:14:00 <hololeap> any help understanding why would be appreciated
21:14:12 <glguy> hololeap: Does it help if you add "hSetBuffering stdin NoBuffering" ?
21:14:40 <EvanR> #haskell where the same question is asked in full stereo
21:15:05 <hololeap> oh lol... i forgot about buffering
21:18:40 * hackage fast-tags 1.4.2 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.4.2 (EvanLaforge)
21:19:13 <EvanR> finally an EvanL
21:19:49 <hololeap> the prophecy is complete
21:19:52 <EvanR> opposite chirality
21:21:28 <hololeap> i would expect this version to say "Bye!" after hitting a key, but instead it just outputs "conc1.hs: AsyncCancelled": http://dpaste.com/3QPSB7T
21:23:11 <EvanR> theres a lot going on here
21:25:52 <hololeap> wow, ok... i'm going to repeat my question in case it got buried in all of that
21:25:57 <hololeap> i would expect this version to say "Bye!" after hitting a key, but instead it just outputs "conc1.hs: AsyncCancelled": http://dpaste.com/3QPSB7T
21:29:20 <nshepperd> irc is much more usable when you have join/parts filtered
21:29:46 <slack1256> hololeap: cancel a is sending an async exception to the thread a. For those the default action is to kill the thread
21:30:43 <slack1256> meanwhile the thread-a is expecting a sync exception on its loop to be triggered (ExitAction) such that when it recives it will print on screen Bye
21:31:03 <slack1256> Let me try to modify it so it does what you want.
21:31:32 <EvanR> why is the handle not catching AsyncCancelled
21:32:37 <EvanR> (not that youd want to do this in real life, rather use a finaler or monitor wrapper around the async to deal with its success or failure)
21:37:48 <hololeap> EvanR: do you mean doing something like `handle exitAction $ wait a` instead of having it within async?
21:38:03 <EvanR> no
21:38:20 <hololeap> i'm just trying to build my intuition on how to do concurrency by making simple toys
21:38:23 <EvanR> waitCatch
21:39:01 <EvanR> aha figured it out
21:39:15 <EvanR> you used handle from Control.Exception.Safe which does not catch async exceptions
21:39:24 <EvanR> tricky tricky
21:39:38 <arahael> That's why it's "safe"? :)
21:39:59 <EvanR> yeah not sure what the deal is
21:41:03 <slack1256> I think it has to do with masking. Specifically the use of async vs asyncWithUnmask
21:41:10 <slack1256> I am compiling a test case now
21:41:31 <hololeap> this library was recommended in a blog somewhere. you can read more about it here: https://github.com/fpco/safe-exceptions#readme
21:41:43 <EvanR> the point of catch is to indeed catch async exceptions
21:42:05 <EvanR> if you didnt want to deal with them, you could use try (from the normal Control.Exception module)
21:42:05 <hololeap> but waitCatch seems to be the way to go
21:42:16 <EvanR> waitCatch is also good, its like try
21:43:38 <EvanR> Control.Exception is boss
22:02:27 * hackage deferred-folds 0.4.1 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.4.1 (NikitaVolkov)
22:10:08 <hololeap> this seems to work as expected: http://dpaste.com/3B9QYX1
22:20:43 <EvanR> huh
22:21:22 <EvanR> youre reacting to the termination of a, if it was cancelled, by cancelling  it ?
22:21:39 <EvanR> oh i see
22:22:01 <sebastianrkg> I'm trying to use `inline-c` to use the Chipmunk2D physics engine, and I'm having a massive amount of linker errors
22:22:27 <sebastianrkg> I don't need to compile the c code externally first, and then have the .o files available, right?
22:22:59 <boj> sebastianrkg: the library and its headers need to be available to the linker
22:23:56 <sebastianrkg> I have the whole repository included inside my Haskell repo, and I'm using a relative include inside my Haskell file: C.include "../../Chipmunk-7.0.2/include/chipmunk/chipmunk.h"
22:24:56 <sebastianrkg> I have a feeling I'm doing something ridiculous, since I am such a C novice
22:24:59 <EvanR> hololeap: IRL i imagine you want to do cleanup regardless of why the task died
22:25:22 <EvanR> and if you want something special to happen when its cancelled, do it in the canceller (after cancel returns)
22:25:55 <boj> sebastianrkg: you need to be able to link the Chipmunk shared objects as well
22:26:09 <boj> sebastianrkg: have you built the C library?
22:26:26 <sebastianrkg> ah. No, I haven't
22:27:10 <boj> sebastianrkg: that is a necessary step, since you'll be relying on all the C logic to do the work :)
22:27:47 <sebastianrkg> I wrote a little test where I only used the C struct definitions, and that worked fine without building, but I guess that makes sense
22:28:37 <sebastianrkg> will I need to point to the .so files in the package.yml/cabal file, or is it sufficient just to build them in their default location?
22:29:09 <boj> sebastianrkg: you will have to tell cabal/stack where the libs are if it isn't a default system location
22:30:05 <sebastianrkg> nice, okay, thanks. And if I want to upload this to Hackage or something down the line, I would need a custom Setup.hs that runs cmake as part of this package's build process?
22:30:20 <sebastianrkg> (Chipmunk2D uses cmake to build)
22:30:37 <boj> sebastianrkg: ideally you would have the user build against a system installed Chipmunk2d library
22:32:02 <sebastianrkg> boj: Got it. Thanks a million, so much easier than mucking around until I figure it out myself
22:32:03 <boj> sebastianrkg: maybe look at the SDL2 project(s) to see how they do it
22:32:16 <boj> yep, good luck :)
22:34:34 <hololeap> EvanR: do you mean adding an extra handler instead of a throw, like this? http://dpaste.com/1R5F10D
22:35:48 <EvanR> i was suggesting a simplification, assuming hypothetical real life
22:38:57 <EvanR> need sleep
22:41:40 * hackage hw-fingertree-strict 0.1.1.0 - Generic strict finger-tree structure  http://hackage.haskell.org/package/hw-fingertree-strict-0.1.1.0 (haskellworks)
22:53:02 <hololeap> i'm a bit confused about the SomeException interface. why this type signature? fromException :: SomeException -> Maybe e
22:53:20 <hololeap> when/why would fromException return Nothing?
22:56:14 <hololeap> also, how can i handle (e :: Exception e => e) differently depending on what type it is (e.g. IOError is handled differently than AsyncCancelled)?
22:56:19 <cocreature> hololeap: if the exception that you call it on is not "e"
22:56:52 <cocreature> you can use "catches" to supply different exception handlers
22:57:38 <EvanR> Exceptions are deeply magical
22:57:50 <EvanR> well, Typeable
22:58:49 <hololeap> is there a version of catches that takes a SomeException directly?
22:59:17 <EvanR> the handlers let you catch any Exception you want, including SomeException
22:59:24 <cocreature> how did you end up in a situation where you have a SomeException value?
22:59:26 <cocreature> that sounds weird
22:59:43 <EvanR> async returns SomeException
22:59:56 <hololeap> waitCatch from Control.Concurrent.Async
23:00:08 <EvanR> in which case you dont need to catch anymore
23:00:25 <EvanR> your current code is way complex for what its doing
23:02:41 <mniip> EvanR, ...but not unlifted
23:03:58 <dminuoso> Style question: When you append bytestrings, would you prefer to use `append` or <>?
23:03:58 <hololeap> EvanR: i'm trying to build up to something more complex that runs a different action based on if the thread exited on its own, was cancelled, threw an IOException, or threw any other exception
23:04:22 <Axman6> usually <>
23:05:09 <hololeap> concurrency and exceptions are something i haven't really gotten an intuition for in haskell, and i'm trying to work on that
23:05:11 <dminuoso> Axman6: Do you have a reason for that choice?
23:05:28 <Axman6> shorter and more generic, in case you decide to change the type later
23:05:41 <EvanR> hololeap: you can inspect the SomeException in the monitor thread however you want and branch whichever way
23:06:13 <EvanR> the tests on exceptions are a bit unergonomic, but exist
23:06:32 <cocreature> fromException is not that bad
23:06:46 <EvanR> fromException followed by some bool tests
23:07:30 <hololeap> but how would i write a case statement that matches different data types? is that where the typeable trickery comes into play?
23:07:41 <EvanR> you can also create your own exceptions and throw those at the thread to kill it instead of ASyncCancelled
23:08:17 <cocreature> hololeap: f e | Just (e' :: IOException) <- fromException e = …; | Just (e' :: SomeOtherException <- fromException e = …
23:09:47 <hololeap> cocreature: oh, does that require a language extension?
23:10:02 <cocreature> no pattern guards are part of Haskell 2010
23:10:19 <EvanR> what about pattern type annotations
23:10:26 <hololeap> i meant having the type annotations within the pattern guards
23:10:28 <cocreature> oh yeah that needs ScopedTypeVariables
23:10:36 <hololeap> ok, thanks
23:10:54 <hololeap> this is getting me a lot closer
23:11:19 <cocreature> ofc you don’t need to use pattern guards and ScopedTypeVariables here, you can also just use a regular pattern match or try some Alternative magic or whatever
23:15:28 <hololeap> does IOException even have a constructor that can be pattern matched normally?
23:16:15 <cocreature> sadly not, you have to deal with the various boolean checks https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO-Error.html#g:2
23:16:36 <Axman6> LEns provides some nice abstractions for exceptions
23:16:39 <Axman6> Lens*
23:16:57 <cocreature> yeah but I wouldn’t recommend picking up lens just for that :)
23:28:58 <hololeap> cocreature: i hate to be a bother, but would you mind finishing this function for me so i can see what you're talking about? i tried what you said and it wouldn't compile (parse error on input ‘<-’ Perhaps this statement should be within a 'do' block?) ... unfinished function: Perhaps this statement should be within a 'do' block?
23:29:07 <hololeap> oops... unfinished function: http://dpaste.com/13VRQDE
23:36:44 <cocreature> hololeap: https://gist.github.com/cocreature/79853f2df247b8d5e436a5bc9bb7604a works for em
23:36:46 <cocreature> *me
23:38:18 <hololeap> cocreature: thanks a lot. i'm not sure what wasn't working for me before, but your code works
