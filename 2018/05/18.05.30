00:05:34 <statusbot> Maintenance update: restarting Hackage now -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5b0e4c1d14e6d951ef3f01c3
00:10:30 * hackage stocks 0.2.0.0 - Library for the IEX Trading API  http://hackage.haskell.org/package/stocks-0.2.0.0 (davidb)
00:11:33 <statusbot> Maintenance update: Hackage up & operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5b0e4c1d14e6d951ef3f01c3
00:14:07 <merskiasa> PM me if you want to make some extra money for a small python project - you must be proficient in either python or perl or haskell
00:18:56 <arahael> sounds like a perl project!
00:30:15 <merskiasa> arahael, It can be in Haskell
00:30:27 <merskiasa> doesnt have to be in python or perl
00:30:36 <merskiasa> 100-200 lines of code max
00:30:40 <merskiasa> a small project
00:31:09 <Axman6> is it homework by any chance?
00:32:18 <merskiasa> No definitely not
00:32:57 <arahael> merskiasa: why does it matter what language it is in then?
00:33:02 <merskiasa> If youre interested I will tell you in PM what the project/script is about
00:33:25 <merskiasa> It doesnt thats why I listed 3
00:33:55 <Axman6> well, you initially said it was specifically a small python project
00:34:00 <merskiasa> any of which you can choose
00:34:08 <merskiasa> I made a mistake there
00:34:08 <Axman6> anyway, the way you're behaving is pretty shady
00:34:19 <merskiasa> How?
00:35:00 <arahael> why not write it out yourself? 200 lines is tiny.  failing that! why not just describe the project?
00:35:42 <Axman6> i mean, you should at least mention the general topic is relates to so people don't waste their time asking you for details of something they may not have appropriate skills for
00:36:40 <merskiasa> arahael, because im paying for the project to be mine
00:37:04 <arahael> so?
00:37:36 <merskiasa> the jist of the project involves security
00:37:54 <arahael> so its even more important for it to be public.
00:37:57 <merskiasa> computer security
00:38:10 <merskiasa> why?
00:38:19 <Axman6> indeed, security in secret is not security
00:38:24 <veverak> because 'security through hiding the thing' always worked ;)
00:38:31 <veverak> hmm
00:38:53 <merskiasa> im paying for a service
00:39:08 <arahael> it isnt by accident that secure algorithms are done via major research competitions.
00:39:12 <merskiasa> ill tell the project in PM
00:39:34 <merskiasa> only if you are interested
00:39:43 <Axman6> Good luck, but no one's going to offer without at least some sort of detail
00:39:47 <arahael> nah, not interested.
00:39:56 <Axman6> "security" is too broad of a topic
00:40:18 <Axman6> "I want to hack into this specific bank" is also unlikely to get you much inrterest
00:41:10 <dminuoso> Also Im curious how you know that the project will be 100-200 lines of code.
00:41:14 <dminuoso> In any of these three languages.
00:41:39 <kuribas> Hi, I'd like to add info support for haddock.  Would it be more useful to generate it directly, or via texinfo.
00:41:40 <kuribas> ?
00:41:53 <cocreature> dminuoso: hacking backs always requires 100-200 lines of code. that’s common knowledge!
00:42:08 <arahael> import merskiiiiiineprimes; merskiiiiiineprimes.main() # 2 lines!
00:42:55 <merskiasa> .....
00:43:07 <merskiasa> That was just a guesstimate
00:43:17 <tdammers> based on what?
00:43:27 <merskiasa> To illustrate its not a hard or time intensive project
00:43:29 <merskiasa> its small
00:43:35 <tdammers> also, 100-200 lines says absolutely nothing meaningful about the project
00:43:37 <merskiasa> it could be shorter
00:43:38 <Axman6> then why not do it yourself?
00:43:45 <dminuoso> 100-200 lines of code can be incredibly hard to write.
00:43:46 <merskiasa> I dont program
00:43:48 <arahael> merskiasa: the number of lines is unrelated to the difficulty.
00:43:55 <tdammers> I have written 200-line scripts that were the result of weeks of research and design efforts
00:44:03 <dminuoso> 100-200 lines of source code in Hask or crypto might take me a week to come up with
00:44:36 <merskiasa> This is not hard to a programmer as I have resources i can give you to which i want it based on
00:44:38 <tdammers> I have also done projects where I would quickly scaffold / generate thousands upon thousands of lines of code in a matter of minutes
00:44:43 <merskiasa> In which code is already given
00:44:44 <arahael> took me a day to *delete* 100-200 lines of code.
00:44:50 <tdammers> that too
00:45:07 <dminuoso> arahael: you should try `rm` - that does the job *much* faster
00:45:10 <kuribas> writing 2 lines of internal lens code may require you to be a haskell expert.
00:45:12 <tdammers> in fact, when working on GHC, it's quite common to spend weeks on a commit that ends up being a single-line change
00:45:24 <kuribas> not to mention negative lines
00:45:25 <arahael> dminuoso: a "friend" of mine did just that on my computer at uni.
00:45:45 <arahael> i once spent a week on a code change that involved a single char!
00:46:01 <dminuoso> arahael: In reality `rm` is the `real mode interpreter`. It takes a program and runs it on a synthesized CPU in real mode. It does this so fast, that it finishes execution before you can even blink.
00:46:02 <merskiasa> Ok so no one is interested in earning a little money on the side for a simple project?
00:46:06 <arahael> well! 6 hours for the change itself! but i digress.
00:46:09 <rotcev> apparently not
00:46:24 <merskiasa> Thankyou for your time
00:46:31 <dminuoso> merskiasa: 150 bucks is hardly worth the effort, and 100-200 lines of code likely take more than an hour to write.
00:46:40 <kuribas> merskiasa: not without more info?
00:46:56 <Axman6> merskiasa: this is just not how finiding developers is done
00:47:17 <kuribas> dminuoso: 150 € for an hour work isn't too bad?
00:47:49 <Axman6> you sound like the sort of people who thinks "I'm going to start a new crypto currency, I'll just pay some chump to make it for me but it;s my idea so I'll keep all the money"
00:48:13 <dminuoso> kuribas: Im just saying that it's unlikely you can finish this in an hour.
00:48:33 <merskiasa> Axman6, isnt that what codemonkeys are for
00:48:34 <merskiasa> ?
00:48:48 <dminuoso> kuribas: I just spend a good hour on 20 lines getting a quickcheck property right.
00:48:49 <Axman6> I will happily give over whatever I have written within an hour for that sort of money
00:49:14 <Axman6> merskiasa: If that's what you think we are then that's the sort of people you'll get
00:49:23 <merskiasa> If youre serious PM me otherwise im done here
00:49:28 <arahael> merskiasa: dont forget: that hour also includes describing the problem.
00:49:45 <dminuoso> and asking/answering questions about the problem
00:49:46 <merskiasa> Iv written the problem
00:49:46 <arahael> merskiasa: and reviewing potential solutions.
00:49:49 <dminuoso> then theres infrastructure bits
00:49:56 <dminuoso> and then there's the assessment of the product
00:49:59 <arahael> testing...
00:50:03 <merskiasa> Iv written a whole description already of the task
00:50:16 <merskiasa> this is not SDLC
00:50:22 <Axman6> why does the description need to be secret?
00:50:23 <dminuoso> why are you refusing to share that description then?
00:50:23 <merskiasa> this i a simle script
00:50:25 <merskiasa> jeez
00:50:28 <merskiasa> simple
00:51:09 <merskiasa> dminuoso, because i want it done privately
00:51:27 <cocreature> so you’re willing to share it with strangers on the internet via pm but not here?
00:51:36 <cocreature> that seems like a great way to keep information secret
00:51:58 <tdammers> so you're not a programmer, you can't do this yourself, you seem to have little clue as to how programming generally works, but you are absolutely sure that this will be about 200 lines of python or perl or haskell, that those languages are the best options, and that it will take no more than an hour total. that's very peculiar.
00:52:22 <tdammers> you will have to forgive people for being skeptical for this alone
00:52:53 <arahael> and that it requires what seems to be an NDA.
00:53:11 <arahael> i aint singing an NDA for 150 euros.
00:53:24 <tdammers> I would
00:53:36 <tdammers> but $150 would buy you pretty much just me signing the NDA
00:53:45 <merskiasa> NDA?
00:53:57 <tdammers> Non-Disclosure Agreement
00:54:01 <merskiasa> non disclosure agreement
00:54:05 <merskiasa> figured
00:54:29 <merskiasa> do you get paid for sitting on irc?
00:54:32 <arahael> hmm.
00:54:51 <arahael> merskiasa: no...  ive been doing the dishes here.
00:54:52 <Axman6> yeah I'm pretty sure my 10 years of haskell experience and my university degree make that a pretty unappealing proposal - more money maybe, but the way you are trying to conduct your business makes you look exceptionally dodgy
00:54:54 <merskiasa> because in the time we have been speaking you coudlve made some money
00:54:59 <dminuoso> Id be willing to sign an NDA for 150 eur.
00:55:11 <Axman6> merskiasa: yeah, I'm sitting at work right now, writing Haskell, and being paid for it
00:55:16 <tdammers> I get paid for making software, which involves waiting for compilers to compile stuff, scripts to test stuff, etc.
00:55:33 <merskiasa> Axman6, youre on rc talking to me and other people
00:55:36 <merskiasa> irc*
00:55:41 <Axman6> Indeed I am
00:55:46 <arahael> the work chat system is slack, not irc.  im on irc anyway :)
00:55:55 <Axman6> while also sortingout database migrations for one of our apps
00:56:13 <tdammers> I'm currently sorting out test failures
00:56:24 <Axman6> and building some tools to automate some AWS tasks
00:56:27 <tdammers> they're trivial, but I have to run a lengthy build to verify them
00:56:32 <Axman6> tdammers: simple, don't write tests
00:56:44 * jackdk twitches
00:56:47 <gentauro> I will pay haskellers 1 USD if they write some code that can solve NP-Hard problems in polynomial-time. No NDA needed :P
00:56:53 <tdammers> Axman6: I don't think running a project like GHC without tests would be prudent
00:57:17 <tdammers> gentauro: can I pick a specific NP-hard problem?
00:57:39 <Axman6> gentauro: I can do this for you, any problem in O(1) time, but the constants might be high
00:57:50 <jackdk> the problem is people "solving" problems with tests that are better solved with types. if you don't do that and get the benefit of types, you write a lot more meaningful tests
00:58:06 <gentauro> Axman6: :)
00:58:18 <arahael> jackdk: still gotta design the api, and compile the test.
00:59:11 <jackdk> I have written tests that have no runtime component :-)
00:59:25 <gentauro> speaking about the lack of tests ... I would like to get some review on this :P https://github.com/spisemisu/cleanse-facebook (slides http://blog.stermon.com/assets/talks/2018-05-29_How_to_remove_Facebook_content_programmatically.pdf)
00:59:32 <gentauro> :D
00:59:33 <Axman6> IIRC you have written tests that certain things do not compile too!
00:59:49 <gentauro> Boomerang is not here today right?
01:00:16 <Axman6> gentauro: I would not be accepting passwords via the command line
01:00:21 <kuribas> Wouldn't you like haddock to produce gnu info docs?
01:00:24 <Axman6> since that ends upo in your history
01:00:38 <jackdk> Axman6: nah that test didn't work because the lib that implemented it uses -fdefer-type-errors
01:01:18 <Axman6> ah yeah, that was a fun catch 22
01:01:39 <jackdk> kuribas: my experience writing texinfo from way back is that at most I'd want haddock to produce the cross-referenced reference section only, and would still expect to have to write proper high-level docs to have a proper manual
01:01:42 <arahael> Axman6: configuration files.
01:02:19 <Axman6> or simply requesting the password on a non-echoing stdin
01:02:41 <arahael> or, config files.
01:02:43 <Axman6> https://stackoverflow.com/a/4064482/19872
01:03:02 <kuribas> jackdk: I mean instead of html output, info docs with an index.
01:03:16 <Axman6> (macOS will even insert a character on the terminal showing that it is "safe" to enter a password if you follow that)
01:03:34 <jackdk> I personally like reading things in emacs' info reader, but apparently most people don't care enough
01:04:15 <kuribas> jackdk: I am not sure what you mean
01:04:44 <kuribas> jackdk: you read the docs from top to bottom?
01:06:23 <jackdk> not often, no, but info often wants some extra structure
01:07:08 <gentauro> Axman6: I use this approach -> https://github.com/spisemisu/cleanse-facebook/blob/sync/cleanse.bash
01:07:09 <jackdk> because we don't have the structure of printed manuals in haddock (at least not chapters), that high-level stuff (which is often nice to read in a first pass) is pushed into .Tutorial modules if it exists at all
01:07:38 <gentauro> https://github.com/spisemisu/cleanse-facebook/blob/sync/cleanse.bash#L3-L12
01:07:55 <gentauro> by doing this, the pwd is not stored in history
01:07:57 <Axman6> that also works. might want to run that through shellcheck, I thnk you probably want something like --pwd="${password}"
01:08:30 <gentauro> I had to find a way for me to run the scripts in front of an audicence
01:08:38 <gentauro> so they didn't see me typing my code ;)
01:09:16 <arahael> gentauro: my password is usually something like: johnny d999!(f00D
01:09:23 <cocreature> does that also avoid the problem of cli args being visible to other processes?
01:09:25 <arahael> gentauro: note the space.
01:10:02 <kuribas> jackdk: you have sections in haddock
01:10:20 <kuribas> jackdk: the modules can be chapters
01:11:32 <gentauro> arahael: which space?
01:12:22 <arahael> gentauro: between the 'y' and 'd'.
01:12:39 <Axman6> hence my suggestion
01:12:42 <gentauro> arahael: oh, in your pwd?
01:12:48 <arahael> yes!
01:13:18 <gentauro> and will that not work with --pwd=`echo $password`?
01:14:15 <jackdk> I suspect you'll be able to make it work, but it will involve adding extra metadata that people won't remember to fill, and you may find the endeavour has an unsatisfying effort:payoff ratio. I wish you the best of luck as an info fan.
01:14:26 <jackdk> I have no further time today so will have to leave the discussion at that
01:16:07 <arahael> gentauro: no, it wont wokr.
01:16:15 <arahael> gentauro: no, it wont work.
01:17:31 <gentauro> arahael: hmmmm, that is spooky :(
01:17:56 <arahael> gentauro: shellcheck.
01:19:23 <gentauro> arahael: good to know :)
01:20:20 <Axman6> gentauro: clense looks like a cool tool, nice work
01:21:13 <Axman6> gentauro: like I said, --pwd="${password}" is what you want IIRC
01:21:33 <gentauro> Axman6: thx, are expecting FB hitting my GH repo in 3,2,1 :D
01:22:41 <gentauro> and I will fix the .bash script.
01:22:51 <gentauro> arahael: I also get this msg -> "SC2162: read without -r will mangle backslashes."
01:23:09 <Axman6> not a big deal for a demo, but it's worth knowing how shell scripts can go wrong in fun and exciting ways
01:24:00 <[exa]> gentauro: that thing with echo is a nice way of broadcasting your password everywhere. Suggest looking at 'sshpass' program that is trying to solve the same problem
01:24:16 <simon> gentauro, I like the granulated effects!
01:24:52 <gentauro> simon: so why didn't you come yesterday :P
01:24:58 <gentauro> (slacker) :D
01:25:02 <simon> gentauro, just came home from vacation :o
01:25:17 <simon> gentauro, you might export Cleanse as 'Cleanse(..)' instead of listing all its parts.
01:25:19 <gentauro> that's a fair excuse ;)
01:25:22 <simon> hehe
01:25:44 <simon> I've seen granulated effects in an online talk on testing
01:25:52 <simon> but I haven't done anything like it myself yet.
01:26:01 <gentauro> simon: this "script" is also meant as a "learning" approach to Haskell, so I really tried to write "readable" code
01:26:22 <simon> gentauro, hmm okay.
01:26:36 <gentauro> yeah, "granulated effects" is probably "that one feature" that is in Haskell, and is sometimes underseeing
01:26:48 <cocreature> gentauro: code style is obviously subjective but if you’re looking for an opinion: I would not use Data.Default and instead just make something like defUsr :: User. separating type signatures from the definitions is also at least fairly unconventional in Haskell
01:27:45 <simon> cocreature, when *would* you use Data.Default then?
01:27:52 <cocreature> simon: never :)
01:27:55 <simon> cocreature, oh :)
01:28:07 <simon> cocreature, it's too vague like Show?
01:28:40 <simon> like, what's a default even. I sometimes have 'initialEnv', sometimes 'emptyEnv'. they might not be the same.
01:28:57 <cocreature> it’s even worse imho. for Show you actually often have polymorphic code that uses a Show constraint. you basically never use it in a polymorphic way
01:29:39 <cocreature> where it = Data.Default
01:30:40 <simon> https://www.youtube.com/watch?v=RhvIISDoarU
01:30:40 <simon> ChillYourMind Radio • 24/7 Music Live Stream | Deep & Tropical House | Chill Music, Dance Music, EDM
01:30:43 <simon> ChillYourMind
01:30:45 <simon> 6.2K watching
01:30:48 <simon> LIVE NOW
01:30:50 <simon> 8:10
01:30:53 <simon> The 5 Types of Animation
01:30:55 <simon> Bloop Animation
01:30:58 <simon> 2M views
01:31:00 <simon> 9:56
01:31:03 <simon> Judge Morty: State of Georgia VS Denver (Rick) Allen UNCENSORED [Best Vers. 07/2017]
01:31:06 <simon> 〈desired name〉
01:31:07 <cocreature> …
01:31:08 <simon> 3.2M views
01:31:11 <simon> 1:02
01:31:13 <simon> Speed Holes
01:31:16 <simon> Sam Thorogood
01:31:18 <simon> 126K views
01:31:21 <simon> 16:58
01:31:23 <simon> Ed Edd N Eddy - How To End A Cartoon
01:31:26 <simon> 24 Frames Of Nick
01:31:28 <simon> 955K views
01:31:31 <simon> Homer Encounters Giant Spider
01:31:33 <simon> ActaiosReborn
01:31:36 <simon> 31K views
01:31:38 <simon> Top 10 Criminally Underrated Cartoon Series
01:31:41 <simon> WatchMojo.com
01:31:43 <simon> 3.9M views
01:31:44 <cocreature> someone needs to get an IRC client that warns on multiline pastes :)
01:31:46 <simon> 1961 Movie Predicts Bitcoins?
01:31:48 <simon> Sol Grinder
01:31:51 <simon> 3.5K views
01:31:53 <simon> Progressive House · Relaxing Focus Music · 24/7 Live Radio
01:31:56 <simon> The Grand Sound
01:31:58 <simon> 962 watching
01:32:01 <simon> LIVE NOW
01:32:03 <simon> 10 Times The Simpsons Predicted The Future
01:32:06 <simon> MindChop
01:32:08 <simon> 18M views
01:32:11 <simon> TOONED UP  S3 • E45
01:32:13 <simon> The Simpsons - Then VS. Now - Evolution of The Simpsons (Tooned Up S3 E45)
01:32:16 <simon> ChannelFrederator
01:32:18 <simon> 597K views
01:32:21 <simon> The Leader Is Good, The Leader Is Great!
01:32:23 <simon> Pete Kent
01:32:26 <simon> 86K views
01:32:28 <simon> 10 Simpsons Jokes That Came True
01:32:31 <simon> Alltime10s
01:32:33 <simon> 12M views
01:32:36 <simon> oh fuck
01:32:38 <simon> I'm sorry.
01:32:41 <simon> I was going to copy-paste "Default? The two sweetest words in the English language"
01:32:44 <simon> I thought I did...
01:32:46 <simon> but that feature seems to not always work across SSH.
01:33:19 <cocreature> at least weechat warns about multiline pastes. you might be able to configure your irc client to do the same :)
01:33:41 <tdammers> e.g. by replacing it with weechat
01:34:16 <gentauro> damn, simon that was a lot of text :D
01:34:38 <simon> I did try to replace irssi with weechat some years ago, but it turns out weechat doesn't support the way I configure my windows/channels.
01:35:56 <cocreature> is your window config really more important than not spamming #haskell? :)
01:37:07 <simon> cocreature, haha. well, this is the first time I accidentally pasted something on IRC in at least a handful of years. I bet there's an irssi script that will prompt if I really want to paste something.
01:37:55 <[exa]> irssi has it by default?
01:38:51 <[exa]> (or at least I thought it is default because it works here for me)
01:38:58 <simon> [exa], irssi has paste_detect_time that will add delays between lines, and it has paste_join_multiline that will chomp stuff together, which won't work when I paste lines of code (which is an acceptable norm on some channels I frequent). so I'm looking for something like a script that prompts me if I'm really sure.
01:40:01 <simon> [exa], in either case, those two would not have saved me here, it'd just have either prolonged the annoyance (unless I quit before it finished) or garble it into a few lines (which would have been more tolerable, but would interfere with how I normally paste code.)
01:40:05 * [exa] sees Pasting 10 lines to [exa]. Press Ctrl-K if you wish to do this or Ctrl-C to cancel.
01:40:10 <simon> oh.
01:40:35 <simon> [exa], what is paste_detect_time, paste_join_multiline and paste_verify_line_count set to in your client?
01:42:20 <[exa]> simon: lemme copypaste the config to you to test again
01:42:32 <simon> [exa], setting paste_detect_time to something non-zero enables that feature for me, I can see. thanks!
01:42:49 <gentauro> Axman6: thx for feedback -> https://github.com/spisemisu/cleanse-facebook/blob/sync/cleanse.bash#L13
01:42:59 <[exa]> simon: cool
01:44:59 <simon> gentauro, ideally, according to Axman6, you shouldn't put passwords in command-line arguments at all. (they show up in `ps`, /proc, etc.) I've experienced similar problems with putting passwords in environment variables (e.g. #diku's concieggs command 'doas export' will show a bunch of stuff related to SSH sessions of whoever is logged in as the user running the bot, whoops. :D)
01:45:23 <mxf> simon, you could also leave it at 0 and use bracketed paste mode, if your terminal supports it. That has the advantage that pasting tabs f.e. just works
01:45:50 <simon> mxf, ah, thanks.
01:46:34 <mxf> simon, see paste_use_bracketed_mode on https://irssi.org/documentation/settings/
01:47:45 <gentauro> simon: good point
01:49:23 <mxf> btw, is there a ghc beginners channel?
01:51:44 <[exa]> mxf: like for beginners in compiler hacking?
01:51:54 <mxf> [exa], yes
01:52:34 <[exa]> afaik not, but people on #ghc respond well to well-asked questions. There's also a very informative ghc wiki page 'Commentary'
01:53:14 <[exa]> also, chances are that your question will be answered here as well
01:53:21 <mxf> ah, okay. Yeah, I found the Commentary, currently reading Compiler/GeneratedCode :)
01:53:36 <[exa]> also also, don't ask to ask just ask
01:54:37 <Ariakenom_> join :: Ask (Ask x) -> Ask x
01:54:37 <mxf> haha, yeah, I don't have any concrete questions yet, I just wondered if such a channel existed.
01:55:46 <[exa]> Ariakenom_: :D
01:56:08 <mxf> Ariakenom_, that's clever :)
01:56:51 <Ariakenom_> Thanks! I've probably posted it 4 times without responses. Finally one who appreciates fine jokes :)
01:57:09 <mxf> hehe
01:59:21 <[exa]> let's write a book of haskell proverbs
02:00:17 <Ariakenom_> Well we do have a bot-handled collection of quotes at least?
02:00:23 <quicksilver> we used to
02:00:31 <quicksilver> @quote quicksilver
02:00:31 <lambdabot> quicksilver says: probably using javscript to make the user-modified version fold into the screen in 3D whilst playing 'Dies Irae'
02:00:53 <quicksilver> @remember Ariakenom join :: Ask (Ask x) -> Ask x
02:00:54 <lambdabot> Okay.
02:01:03 <quicksilver> @quote Ask.Ask
02:01:03 <lambdabot> No quotes match. Are you typing with your feet?
02:01:06 <quicksilver> @quote Ask.*Ask
02:01:07 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
02:01:17 <quicksilver> not sure that works the way I thought :)
02:01:22 <quicksilver> @quote Aria Ask
02:01:22 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
02:01:24 <simon> Ariakenom_, perhaps Question q => Ask (Ask q) -> Ask q
02:01:50 <quicksilver> @quote Ariakenom
02:01:50 <lambdabot> Ariakenom says: join :: Ask (Ask x) -> Ask x
02:01:53 * quicksilver shrugs
02:02:10 <simon> then again, why'd one ask a non-question.
02:02:23 <simon> it happens, but it's silly.
02:02:26 <[exa]> simon: oh people!
02:02:42 <simon> like those talks where someone gets the mic and continues to rant for minutes with no clear indication of the end or any actual question.
02:03:26 <Ariakenom_> quicksilver: "we used to"?
02:03:40 <quicksilver> we used to, and we do, apparently
02:03:46 <quicksilver> I wasn't sure if it still works
02:03:50 <quicksilver> I don't hang out here much these days
02:05:37 <Ariakenom_> Oh like "I used to not write js. I still don't but I didn't use to either."
02:06:04 <rotcev> thats a good one
02:09:47 <ZeuPiark> hello
02:12:26 <Ariakenom_> Greetings and welcome to the #haskell IRC channel!
02:13:44 <arahael> join :: Ask (Solution x) -> Ask y
02:14:17 <Ariakenom_> *xkcd ?
02:14:19 <opqdonut> :D
02:19:28 <simon> arahael, the joke is that Control.Monad.join :: Monad m => m (m a) -> m a
02:19:51 <[exa]> Anyway, what's the best way to issue various admin commands to a servant-based app?
02:20:16 <Eduard_Munteanu> forall x y. (y ~> x) -> Ask x -> Ask y
02:20:37 <simon> Eduard_Munteanu, what does ~> do?
02:21:01 <Eduard_Munteanu> simon, you *think* y needs/implies x
02:21:09 <[exa]> like, there is stuff that HTTP API is good for (talking to clients), and stuff for which HTTP API is problematic (like a sysadmin telling the server to reload the config, or look at some local file)
02:21:11 <simon> [exa], ummm, besides having a restricted section of the API?
02:21:27 <[exa]> yeah, ideally something completely inaccessible from HTTP
02:22:14 <[exa]> not implying that it has to be "served by servant", just trying to find a good way to integrate the command-line-like handlers with HTTP handlers
02:22:19 <simon> [exa], you could put the admin commands on a different listening port or restrict the address in a proxy. but other than that, maybe make the program respond to SIGHUP?
02:23:12 <[exa]> hm yes a management port could be a viable thingy
02:23:14 <simon> [exa], I mean, there are other protocols for communicating with programs that aren't as easily wired online by accident. like system calls, IPC, unix sockets.
02:23:41 <[exa]> can servant listen on unix socket?
02:23:52 <dminuoso> servant uses warp so..
02:24:00 <simon> [exa], Haskell can? I wasn't thinking of exposing it as an HTTP API via Servant.
02:24:28 <simon> [exa], but can your browser connect to a website via unix sockets? :P
02:24:46 <Eduard_Munteanu> You could ghci into a management module.
02:25:11 <Eduard_Munteanu> Assuming you can make things work with multiple concurrent instances.
02:25:14 <[exa]> no, but some teensy commandline script can (the admin interface is browserless, think stuff like apachectl or unbound-control)
02:25:57 <dminuoso> [exa]: Why is HTTP problematic for such things?
02:26:53 <[exa]> dminuoso: I'd like to pipe files in that, not sure if I want to push that through http post data.
02:26:54 <simon> [exa], I guess the whole "keeping administration hard to access by accident" is a subject in security. HTTP on a local interface should be quite safe.
02:27:03 <dminuoso> [exa]: whats wrong with http post data?
02:27:23 <[exa]> dminuoso: not much actually, just 1 more encoding/decoding layer
02:28:08 <simon> [exa], but it all depends on how the system is managed. I have tried to run virtualisation kernel modules for Linux that gave one interface to its client nodes that were public by default.
02:28:45 <[exa]> on the second thought, screw that, HTTP on restricted port is just right
02:28:53 <[exa]> thanks guys!
02:29:08 <Eduard_Munteanu> Should work with UNIX socket too.
02:29:34 <[exa]> simon: it's a mail handling thing, it pushes raw mail data between mailserver, mailboxes and indexer db
02:30:10 <Eduard_Munteanu> [exa], you don't really need an extra port btw, you could just restrict access to certain URLs
02:30:58 <[exa]> access restrictions are a call for going around the access restrictions, having something absolutely-not-reachable-from-wrong-person helps a lot
02:31:01 <simon> Eduard_Munteanu, assuming he's got a reliable layer of authentication at the application level.
02:31:40 <[exa]> I like the security models that don't check for authentication, but instead simply don't give capability
02:31:45 <Eduard_Munteanu> Or some Apache or something else in front checking the source IP.
02:31:53 <[exa]> oh noes
02:31:54 <dminuoso> [exa]: Or both? :)
02:32:17 <simon> Eduard_Munteanu, the problem with that is that if you re-deploy your app on another server, you're relying on that configuration to be in place.
02:32:20 <Ariakenom_> source IP is not reliable
02:32:28 <[exa]> Eduard_Munteanu: not that it wouldn't work but 10 years of seeing broken software tells me that I shouldn't repeat that :D
02:32:55 <[exa]> Eduard_Munteanu: you need the verification as simple and as close to point where unverified stuff would hurt
02:33:03 <Eduard_Munteanu> Ariakenom_, ideally you want to restrict it to the loopback interface, although source IP is sorta reliable for that
02:33:14 <dminuoso> Cut off network access, add 2FA - and then delay commands for 2 weeks while you get a daily email notifying you about pending email actions.
02:33:28 <dminuoso> On the day before the admin command is executed, you get a call from Apple support staff verifying your identity.
02:33:43 <[exa]> Eduard_Munteanu: which can be broken by anyone with CAP_NET_ADMIN
02:34:13 <Eduard_Munteanu> True, I wasn't even considering local attack vectors.
02:34:23 <simon> I wasn't either. :D
02:34:39 <Eduard_Munteanu> In that case a UNIX socket with the proper permissions is probably best.
02:34:51 <[exa]> 'local mistake vectors' are far worse :D
02:35:37 <simon> [exa], like, oh, was that file readable because the default umask was different on this system?
02:36:49 <[exa]> simon: "I can renumber the loopback temporarily, that shouldn't break anything right"
02:37:16 <Eduard_Munteanu> You kinda need a capability-based system with deep semantics to make things secure and idiot-proof locally.
02:37:29 <[exa]> yeah, like unix. :D
02:37:30 <simon> [exa], when you start to consider local attacks, you're more into configuration management and operating system security, I think. from the application's perspective, simply exposing the admin API "elsewhere" (whether that's on a different interface or port) should be sufficient, right?
02:37:49 <Eduard_Munteanu> [exa], ew, no. Like some research microkernels.
02:38:16 <Ariakenom_> just redeploy your server to seL4
02:38:26 <[exa]> simon: there aren't many local attacks (at least on real hardware, not sure about kernels). but as I said, there are local mistakes. Having the security as tiny local and predictable as possible helps avoiding lots of that
02:38:34 <[exa]> s/kernels/clouds/
02:38:44 <[exa]> Eduard_Munteanu: ^
02:38:51 <simon> modern Unix is more like an experiment in how to make anything executable everywhere. you can't copy-paste things without risking code execution.
02:39:20 <[exa]> simon: what's modern unix btw?
02:39:50 <simon> [exa], I just mean the Linuxes and BSDs we have today.
02:40:15 <Eduard_Munteanu> For example, I was considering how you could prevent applications from downloading random executable code and running it. It doesn't really help that the OS knows nothing about HTTP and can't enforce an encryption policy.
02:41:38 <[exa]> Eduard_Munteanu: that's why there's selinux etc. but at the first place, the point of unix is that you should have a reasonable administrator who burns such app alive before entering the system
02:42:20 <[exa]> ok guys lets stop offtopic :]
02:42:43 <Eduard_Munteanu> [exa], SELinux can't really do that. There's just not enough semantics to network access to enforce such a policy if anything can open remote connections arbitrarily.
02:43:17 <[exa]> Eduard_Munteanu: block access to IP sockets?
02:44:12 <Eduard_Munteanu> [exa], that works, but it breaks applications. All applications just use a HTTP library which open black box TCP connections.
02:45:06 <Eduard_Munteanu> You can't really express a policy in terms of HTTP details.
02:45:24 <[exa]> Eduard_Munteanu: you need to trust the user right?
02:45:37 <Eduard_Munteanu> Or the developer.
02:45:44 <[exa]> you can't trust the developer
02:45:48 <[exa]> it's not his box
02:46:19 <Eduard_Munteanu> Besides, people are goddamn stupid at security stuff.
02:46:52 <dminuoso> Security is not that hard if you keep your tinfoil hat on.
02:46:56 <dminuoso> I mean its still hard, but its manageable.
02:47:35 <[exa]> I'd like to start linux security rant but that would be a massive OT now
02:47:46 <Eduard_Munteanu> Ok, ok. :)
02:48:04 <dminuoso> [exa]: Linux security from the "usual admin" perspective or the kernel perspective?
02:48:19 <[exa]> from the 'linux on desktop yes!' perspective
02:49:20 <dminuoso> [exa]: As long as you have morons flinging around root in an OS where root can trivially do ring escalation, it's a security desaster waiting to ahppen.
02:49:28 <Eduard_Munteanu> I think Android is much better at this.
02:49:31 <[exa]> it kindof historically turns out that you can't have a secure system without a sysadmin.
02:50:30 <dminuoso> Eduard_Munteanu: Android is just offensive to technologically inclined people.
02:53:21 <Ariakenom_> [exa]: You can always hold a rant at #haskell-offtopic, I'd listen.
02:54:17 <[exa]> I'm going to implement that admin interface instead to see what happens :D
02:56:18 <[exa]> any favorite configuration file parser?
02:56:46 <Eduard_Munteanu> YAML
02:57:22 <[exa]> ok
02:57:26 <Axman6> I quite like the configuration-tools package for app config
04:00:12 <tdammers> dminuoso: iOS isn't any better, fwiw
04:04:29 * hackage rattletrap 4.1.0 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-4.1.0 (fozworth)
04:07:17 <freusque> hey. Did anyone here write haddock rules for hakyll?
04:54:24 <gentauro> Boomerang: You missed my talk :'( http://blog.stermon.com/assets/talks/2018-05-29_How_to_remove_Facebook_content_programmatically.pdf
04:55:03 <gentauro> this time the script works and therefore, I was able to showcase my "granulated effects" ;) (actually, the main point of the talk) ;)
04:59:30 <jsjolen> Hey, I'm collecting summer reading as a break from uni :-). I'm looking for cool papers to read, currently I've got "FP w/ Bananas, Lenses, Envelopes nad Barbed Wire". Do you guys have any things that you think I'd enjoy? I think compilers, GC, Lisp and FP is cool, but I'm open to suggestions!
05:00:12 <ventonegro> jsjolen: The Original Lambda Papers
05:00:32 <jsjolen> ventonegro: By Steele and (if I remember correctly) Sussman?
05:00:41 <ventonegro> jsjolen: Yep
05:01:19 <dstolfa> jsjolen: i also quite like papers like "An axiomatic basis for computer programming" by Tony Hoare and the Pi calculus paper by Milner
05:01:35 <dstolfa> from the newer ones, a set of papers about Orc are pretty cool
05:01:54 <dstolfa> and there's also papers talking about coeffects and how they relate to comonads + how they can be used in programming
05:02:05 <simon> gentauro, your monad transformers are suffixed with 'M', but isn't it the convention to use 'T'?
05:02:43 <simon> gentauro, or 'Monad' as a prefix? like MonadIO.
05:05:13 <jsjolen> dstolfa: I got myself the Hoare paper :), I'm mostly looking for stuff around 30 pages because I'm gonna print them out haha
05:06:36 <Ariakenom> I recently enjoyed SPJ's build systems a la carte. What makes a build system had always been vague to me.
05:06:43 <quicksilver> simon: Monad as prefix is for the type classes, not the transformers.
05:06:53 <dstolfa> jsjolen: fair enough :). if you're interested in a more broader topic of logic, i recommend "A Logic of Authentication" by Burrows, Abadi and Needham which develops a higher order logic, not too much unlike Hoare logic to reason about the security of authenatication protocols like the Needham-Schroeder protocol, Kerberos, ...
05:07:56 <dstolfa> Ariakenom: yeah, SPJ writes nice & legible papers. i liked the imperative functional programming one :)
05:07:57 <gentauro> simon: I think the convention is to use M ;)
05:08:19 <jsjolen> dstolfa: Do you know anything decent on garbage collection? Specifically concurrent GC, those are a bit of a mystery to me
05:08:23 <gentauro> But I would like "best practices" or convenctions, to be built-in to the language (I'm not a fan of Hungarian Notation)
05:08:26 <jsjolen> Ariakenom: That looks cool!
05:08:58 <dstolfa> jsjolen: Azul might be interesting from the perspective of traditional languages like Java. otherwise, the actor model and different process calculi offer much better capabilities when it comes to GC. look up Erlang's GC or Pony for reference
05:09:09 <Ariakenom> imperative functional programming is indeed a classic
05:10:28 <merijn> I don't know that paper, but sounds good. Haskell is my favourite imperative language :)
05:10:41 <Ariakenom> Just print the entire SPJ collection. And then you're out of paper :)
05:11:07 <dminuoso> Why exactly is the type system erroring out on this? https://gist.github.com/dminuoso/fec521266595b1c5032b45d79e8042a9
05:11:14 <merijn> Any specific context we're recommending papers in? Or is it just "nice and interesting papers related to Haskell"?
05:11:50 <merijn> dminuoso: Wild guess: Inability to prove 'a' is Typeable?
05:12:09 <jsjolen> Alright phew, I think I've got enough material now! Thank you for the help, I think this'll be a good summer!
05:12:25 <dminuoso> merijn: well it just needs to know that `RadiusAttribute a` is typeable, but RadiusAttribute is a type family
05:12:41 <dminuoso> I would expect it to require proof of Typeable on usage
05:12:42 <maerwald> merijn: rust is a nicer imperative language imo
05:13:02 <merijn> dminuoso: Well, that's also a problem, type families are open world, how would you prove "RadiusAttribute a" is Typeable without knowing 'a'?
05:13:54 <dminuoso> merijn: well I get the same issue if I use a closed type family
05:14:15 <merijn> jsjolen: I dunno if anyone recommended the STG paper, but that's pretty good. Also the STM paper, extensible exceptions, Lazy Functional State Threads, and Fun With Type Functions
05:14:30 <dstolfa> maerwald: rust is nice, but i don
05:14:39 <dstolfa> maerwald: i don't find it nice for the same reason people usually do
05:14:48 <dstolfa> maerwald: i find it nice because it's basically separation logic in the type system
05:15:03 <dstolfa> and if you treat it that way, some things can be written quite intuitively and unambiguously
05:17:26 <maerwald> It's simply better at imperative than haskell
05:18:01 <maerwald> And as a haskeller you don't get annoyed too much by the type system
05:18:51 <dstolfa> maerwald: i don't think the type system is annoying at all tbh, but that may just be me
05:19:16 <maerwald> That's what I just said
05:19:25 <dminuoso> merijn: Naively I'd think that if the type family is closed, and it always maps to something that is Typeable, couldn't it deduce that `Typeable (Family a)` must hold?
05:19:25 <dstolfa> maerwald: well, you said "too much", i said "at all" :>
05:19:47 * dstolfa nitpicks words while waiting for a build
05:19:57 <nshepperd> dminuoso: even with a closed type family it won't be able to reduce Typeable (RadiusAttribute a) to something
05:20:55 <reactormonk> Can I use constraints inside type families to infer types?
05:20:56 <nshepperd> it doesn't just need to believe that Typeable (Family a) is true, it needs a deterministic way to generate the dictionary
05:21:03 <nshepperd> without pattern matching on a
05:22:04 <dminuoso> nshepperd: Can you elaborate on why/how that is? Why does it need to know `Typeable` before its even used?
05:22:23 <dminuoso> I thought the burden of proof that a dictionary exists is delegated to the consumer
05:22:37 <merijn> dminuoso: You could just add a constraint for the type family, though?
05:22:53 <dminuoso> you can what? :o
05:22:55 <nshepperd> you're using it here, with fromDynamic
05:23:02 <dminuoso> nshepperd: Ahhh.
05:23:02 <merijn> dminuoso: "(Typeable (RadiusAttribute a), KnownNat a) =>"
05:23:10 <nshepperd> and yeah, that just means you need to add that constraint to your function
05:23:20 <nshepperd> like merijn says
05:23:44 <dminuoso> Okay that's pretty cool. :)
05:25:37 <merijn> dminuoso: Typeclass constraints (and really any constraint) just takes a type as input, whether that's written directly or result of a type family is irrelevant
05:26:31 <dminuoso> So by specifying `Typeable (RadiusAttribute a)` I delegate the burden of proof to the consumer of `grab`
05:26:47 <merijn> dminuoso: Right
05:28:06 <dminuoso> Thank you both nshepperd and merijn. This was so much easier than I thought :)
05:35:59 * hackage b9 0.5.48 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.48 (SvenHeyll)
05:46:54 <exarkun> anyone have any examples of Test.Hspec before, around, etc?
06:16:30 * hackage refined 0.2.1.0 - Refinement types with static and runtime checking  http://hackage.haskell.org/package/refined-0.2.1.0 (chessai)
06:30:33 <latk> Can anyone point me to some beginner resources about type systems?
06:30:49 <latk> E.g. specific definitions, advantages/disadvantages of different systems
06:33:01 <merijn> latk: What kinda focus are you looking for? Interested in, for example, "how do I implement one?"
06:33:24 <merijn> latk: Because if so, the de facto standard introduction text for type systems would be Pierce's "Types and Programming Languages"
06:33:41 <latk> Much more basic. I realise I have programmed for quite a while now, but I actually don't know the specific definition of static/dynamic, the different underpinnings of those systems etc.
06:33:57 <merijn> latk: Which starts from untyped lambda calculus and dives into lots of different extensions and how you would implement those
06:35:02 <shiona_> latk: have you programmed in both a statically and dynamically typed languages?
06:35:12 <latk> Yes
06:35:27 <latk> I have even programmed a bit in haskell :)
06:35:47 <latk> but I think I really don't understand much about the fundamental differences between languages
06:36:01 <merijn> latk: That'd be because if we're talking formal definitions there is no such thing as "dynamic typing"
06:36:19 <hodapp> Software Foundations, also by Pierce, is another good book to look at.
06:36:26 <merijn> latk: In computer science terminology typing and type systems are, by definition, static lexical properties of a program/expression
06:36:28 <latk> As in, haskell compiles and points out some categories of mistakes that I have made. But python now has the option of adding types, and I'm assuming this has to be a much weaker notion of types than in haskell.
06:36:46 <hodapp> adding types?
06:36:56 <merijn> hodapp: Yeah, they have optional annotations
06:37:18 <hodapp> oh, I thought 'adding types' meant some janky sum type nonsense
06:37:26 <hodapp> yeah, I've heard of the annotations
06:38:00 <merijn> latk: Anyway, I'd *still* recommend TaPL. If you're at least somewhat familiar with Haskell you should be fairly well equipped to read at least a third to one half of that book, which, already covers more than you ever wanted to know ;)
06:38:25 <latk> merjin: If a type system has to be static, does that mean e.g. javascript does have a static type system?
06:38:29 <latk> or it doesn't have a type system?
06:38:36 <latk> Maybe reading this book is the best idea :p
06:38:56 <merijn> latk: The type theoretic view of things like Python and JS is that they have exactly 1 type and literally all expressions have that 1 type
06:39:13 <shiona_> merijn: If I'm not mistaken: when a programmer speaks of dynamic types, they more often than not mean some extra data bundled with the value so that the interpreter can do its work
06:39:51 <merijn> latk: Python also has "runtime tags" which are checked (as the name implies, at runtime) to verify that you're adding "sensible things" (for some value of sensible) which is often described as "strongly typed" (another term which does not have a well-defined meaning)
06:39:53 <latk> merijn: I guess I find that confusing, because you can try to perform operations in python that are invalid due to types.
06:39:57 <simon> merijn, unityping, right?
06:39:58 <latk> Ah :)
06:41:13 <merijn> latk: Anyway, that books was written to be suitable for (under)grad students, so it starts very gentle. There's a bunch of proofs (which you can easily gloss over/skip when reading the first time) and exercises
06:41:46 <latk> merijn: Yeah, I am just looking at the table of contents. Looks like, as you said, it will tell me all I wanted to know and more :).
06:41:50 <merijn> latk: Additionally it has sample implementations of all type systems discussed in the book (in OCaml, but it's such simple OCaml that basic haskell knowledge should be more than enough to read them)
06:42:36 <merijn> The Software Foundations book hodapp mentioned is also really nice, but focuses more on proving things about programs, rather than type systems
06:43:38 <merijn> latk: Getting halfway through TaPL should get you far enough to basically implement Haskell2010 (without extensions...) yourself, which is a rather doable goal
06:44:03 <simon> latk, you can write meaningful programs in Python that rely on encountering type errors and catching them as part of their expected execution. if you compare that behavior to more formally defined type systems, then that's more like values than types.
06:44:34 <merijn> (Well, it's doable, if you don't pretend your code will be optimised or efficient. Hindley-Milner style type inference and compiling to actually runnable code is not as challenging as it seems)
06:45:27 <merijn> simon: unityping, unit typed, something along those lines, yeah
06:45:59 * hackage b9 0.5.49 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.49 (SvenHeyll)
06:46:02 <latk> simon: That is an interesting point.
06:46:22 <shiona_> Before I make a fool out of myself: Does C have a type system in mathematical sense? If not, what languages do?
06:46:51 <hodapp> unless you are Bob Harper, in which case any code you write takes far, far longer because you have to write another blog post about how Haskell is stupid because here is this pathological case that can circumvent it, therefore you may as well just cash in your stock options and go write everything in JavaScript instead
06:47:16 <hodapp> but I digress
06:47:34 <merijn> shiona_: C's type system is static, so yes
06:47:42 <merijn> hodapp: Harper's just mad ML lost :p
06:47:53 <latk> I guess a lot of my confusion comes from things like flowtype for js, and these optional python types.
06:48:22 <hodapp> merijn: I still have a quote I saved from him: "There are few things more stupid in the world than code that compares a pointer for equality with null, then branches on the outcome, and then finds itself needing a sat solver or model checker to propagate the provenance of a boolean that should never have been computed in the first place!"
06:48:27 <hodapp> he has since removed it
06:48:28 <latk> If you had a fully flowtyped js codebase for example, do you have the same level of guarentees that you would have from haskell?
06:48:33 <merijn> latk: Programmers, especially those in JS, python, Ruby, etc. ecosystems, are notoriously sloppy when it comes to terminology
06:48:44 <simon> merijn, ML didn't lose!!! (is something one would say in denial.)
06:48:58 <latk> merijn: I definitely am, but would like to be less so :)
06:49:12 <simon> merijn, it's not dead! it's just sleeping.
06:49:23 <merijn> latk: Which makes discussions very confusing and tedious, hence why people tend to get so pedantic about terminology
06:49:24 <shiona_> Ok, so how is C's type system so inherently different from a "annotation checker" that produces Python's "type" errors? Is it that python "type checks" only the code paths it runs?
06:49:41 <hodapp> shiona_: that is one way, yes
06:49:43 <merijn> shiona_: And only at runtime
06:50:15 <merijn> shiona_: type checking (and static analysis in general) is about "what can I tell about a program without running it?"
06:50:25 <merijn> shiona_: In the case of python the answer is often "not very much"
06:50:49 <shiona_> merijn: so the definition of a "type system" depends on a definition of "running an application"?
06:50:51 <hodapp> a lot of statically-typed languages also remove all information at runtime about the types of anything
06:51:05 <latk> hodapp: Really?
06:51:10 <latk> hodapp: I did not know that.
06:51:28 <hodapp> since a lot of the point of checking types in the first place is effectively that it establishes a proof that you can throw that information away
06:51:30 <latk> Although I guess, if you are already sure it is correct, why would you keep the info around?
06:51:38 <mnoonan> that's part of the appeal: a cost up front when compiling, but then zero-cost in the resulting code
06:52:04 <merijn> latk: Yes, Haskell for example has no notion of types at runtime
06:52:21 <hodapp> it's not 100% true (some languages require dynamic dispatch in various forms) but in general it is
06:52:52 <merijn> latk: In fact, most languages that do not do runtime type dispatch do this, it's called "type erasure"
06:52:59 * hackage refined 0.2.2.0 - Refinement types with static and runtime checking  http://hackage.haskell.org/package/refined-0.2.2.0 (chessai)
06:54:24 <hodapp> merijn: doesn't Haskell still keep some information around for certain usages of typeclasses?
06:54:27 <merijn> latk: In haskell we go: Haskell -> Core (an internal representation of GHC, which actually has types as explicit arguments passed to functions and constructors) -> STG (another internal representation, here all of Haskell's notions of type are already thrown out) -> Cmm (basically LLVM assembler, but slightly different) -> machine code
06:54:41 <hodapp> or, GHC at least
06:54:48 <dminuoso> ^- that distinction we tend to forget at times.
06:54:53 <merijn> hodapp: Type-classes are done via explicit dictionaries, so you don't actually need type information for that, just passing the dictionaries around
06:55:01 <quicksilver> hodapp: what actually happens is that using those type classes reifies that information at compile time into actual values
06:55:03 <merijn> hodapp: (at least, GHC does it via explicit dictionaries)
06:55:13 <merijn> hodapp: So at that point it's just values
06:55:26 <quicksilver> but it's a cost you only pay if you use the type classes
06:55:35 <latk> When you have a static system like haskell, what are the kinds of constraints you prove hold called?
06:55:39 <merijn> quicksilver: if you use the type classes AND it can't be specialised
06:55:40 <quicksilver> and you therefore only pay it on those functions which actually use them
06:56:07 <latk> (since definitions seem to be important)
06:56:38 <merijn> You *could* argue Typeable and Dynamic keep type information at runtime, but they do it the same as other typeclasses, "manually" encodig it and explicitly passing it along at runtime
06:57:14 <merijn> latk: I don't think there's a specific name for "constraints that hold", because in compiled all constraints must hold (else it wouldn't compile ;))
06:57:34 <latk> merijn: Hah, well in that case how can you compare two type systems?
06:57:40 <merijn> So you don't often have a use for refering to "constaints that hold"
06:57:50 <merijn> latk: Compare them along which axis?
06:58:11 <dminuoso> merijn: by the way, what I wrote earlier - Ive thought about it a bit and come to realize that this is actually just a somewhat changed version of a sum type with pattern matching.
06:58:34 <hodapp> latk: well, there's the lambda cube I guess...
06:59:08 <latk> merijn: I'm not really sure :). But, can you say that the type systems of e.g. java and haskell are equivilant?
06:59:19 <latk> Or does one somehow provide more guarentees than the other
06:59:40 <latk> I maybe should just read this book, as I think I'm too ignorant to even frame questions in a useful way.
06:59:42 <dminuoso> latk: there's worlds between them.
06:59:47 <hodapp> latk: https://en.wikipedia.org/wiki/Lambda_cube :)
07:00:07 <hodapp> that gives some very broad idea of what a type system can do
07:00:20 <kuribas> latk: not at all similar
07:00:27 <hodapp> and for instance in C you can't really have a type that's parametrized over a type
07:00:32 <hodapp> while in Java you can
07:00:46 <hodapp> and in Go you... can't... except for when you can... or something...
07:00:57 <dminuoso> latk: ADTs/GADTs. Typeclasses. HKTs. (Mutually) recursive types. Existential types. Indexed type families. Type promotion
07:01:03 <dminuoso> There's just so many things you wont find in mainstream languages.
07:01:22 <dminuoso> Though I think Java has some version of typeclasses, but they are somewhat weaker from what I understand
07:02:10 <hodapp> with what, interfaces + parametric polymorphism?
07:02:45 <merijn> latk: You need a meta framework to compare these sorts of things
07:03:01 <latk> merijn: I start to see this.
07:03:12 <merijn> latk: i.e. you need a framework for describing type systems that can describe both systems before you can compare them :)
07:03:21 <merijn> Commonly called a "meta-theory"
07:03:27 <bodisiw> latk, you want to look at liquid haskell and idris too
07:03:38 <merijn> Of course, there's many different meta-theories and comparing *those* requires meta-meta-theories ;)
07:03:48 <merijn> latk: It's meta all the way up! ;)
07:03:51 <latk> Hehe
07:04:14 <hodapp> hmm. this is reminding me that my book on HoTT has been collecting dust for awhile now >_>
07:04:24 <merijn> latk: But yes, in practice that's how we compare systems, by mapping them to the same meta-theory
07:05:41 <merijn> latk: For example, GHC uses System F_ω as underlying theory for it's implementation of Haskell which is far more flexible than Haskell requires, but that's what allows use to hack in all these extensions GHC has
07:06:10 <latk> merijn: Is it possible to assign e.g. javascript to one of the parts of the cube?
07:06:20 <latk> or it requires a different framework entierly?
07:06:43 <hodapp> does Haskell have dependent types yet? I was promised dependent types.
07:07:08 <merijn> latk: Well, javascript doesn't really guarantee much at "compile" time, so you could just map it to a type system with just a single type :)
07:07:18 <latk> merijn: Ok then, flowtype :)
07:07:28 <merijn> I don't know enough about flowtype to comment
07:07:44 <merijn> hodapp: *Clippy mode*: Did you mean "/join #idris"? ;)
07:07:44 <latk> I can sorta see that probably things like ocaml, haskell etc are similar in some way
07:07:58 <latk> but php?
07:08:13 <hodapp> merijn: doesn't guarantee much at runtime either
07:08:25 <dminuoso> latk: flowtype is essentially a raw type system.
07:08:31 <merijn> latk: Right, OCaml (being an ML) and Haskell are all based on Hindley-Milner, hence the similarity
07:08:49 <latk> Or, there is some idea of a hierarchy of languages that are "good" or "bad". People often think of rust/haskell as being good, and JS as bad. Is there some formal reason to think this, or it is just how people feel?
07:08:50 <dminuoso> latk: it's actually an interesting choice because it demonstrate that a type system may not have anything to do with behavior/runtime
07:09:02 <hodapp> merijn: fine, I'll just go re-read the Hasochism paper for a 7th time and cry
07:09:04 <roconnor> Soooo. Is there  a type isomorphic to (Either String) that is an appropriate instance of MonadFail?
07:09:07 <latk> dminuoso: Really? What is the point then?
07:09:30 <merijn> latk: Well, he didn't say those type systems were very useful :)
07:09:30 <dminuoso> latk: TaPL defines a typing system as follows: A type system is a tractable syntactic method for proving the absence ofcertain program behaviors by classifying phrases according to the kinds of values they compute
07:10:26 <latk> dminuoso: That seems to make sense
07:10:33 <merijn> latk: To expand on dminuoso's quote above, TaPL defines "type-safe" to mean "given a specific operational model, a well-typed will not perform a set of "bad" behaviours"
07:11:09 <merijn> latk: Now, this means (obviously) that the usefulness of the type system and type-safety is completely dependent on the model you're using and which "bad behaviours" you're guaranteeing won't occur
07:11:17 <__monty__> hodapp: You have an industrial use for dependent types? If not, why not use agda, idris, coq, etc.?
07:11:34 <merijn> latk: In, for example, Java and Haskell one of the obvious bad behaviours not allowed is "segfaulting"
07:11:47 <exarkun> What is a Test.Hspec "SpecM"?
07:11:59 <hodapp> __monty__: ehhh, when I did I mostly just used the hacked methods that were used in Ivory
07:12:10 <merijn> latk: A "well-typed" C program does not guarantee "no segfaults", so clearly C's type-safety is less useful than Haskell's if we use the common operational models
07:12:28 <hodapp> not full dependent types but still pretty workable for modeling C's types and memory semantics within Haskell types
07:12:54 <latk> merijn: Ahh, so this is what I wanted to get at
07:12:59 * hackage monadiccp-gecode 0.1.3 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-gecode-0.1.3 (JanTikovsky)
07:13:06 <merijn> latk: But many people ignore the that type-systems are always accompanied by a model about behaviour that people like to gloss over. The usefulness of the type system is strongly dependent on both the model AND the type system, not just one
07:13:21 <dminuoso> latk: (To expand on my previous comment: That doesnt mean you cant utilize information from a type system, but all of that is just an added bonus and not what a type system is about)
07:13:45 <merijn> latk: So we can easilly describe JavaScript as having a type system of "all expressions are unit", but this also means that the type of expressions tells us basically 0 about the operational model
07:14:35 <merijn> latk: However, given the definition of JS execution it is *incredibly* hard to define a type system that accurately captures everything allowed AND gives useful knowledge about what happens at runtime
07:15:21 <bodisiw> latk, what i find interesting about the type systems (in theory) is the extra guidance they give to the compiler for optimizations ... like 'stream fusion'... but i admittedly am unsure about the gains in practice
07:15:28 <merijn> latk: So the thing that makes people say "Haskell is good" is that, since the type system was designed in from the start together with the behaviour, it's much easier to give an operational model for Haskell that lets you learn interesting things from the types
07:15:40 <latk> merijn: Is this the case because you can't infer the types in JS? Or for some other reason?
07:16:02 <dminuoso> latk: Even with Flow JS has too many escape hatches to break any assumption.
07:16:22 <dminuoso> latk: You give me a flowtype checked program with some assumption you think the type system has verified - and I can break that assumption.
07:16:34 <merijn> latk: No, it's because we defined the behavioural model of Haskell and it's type system at the same time, so we took care to define only behaviour with properties easily described by types
07:16:34 <latk> dminuoso: But presumably if I sat you down and said, ok you are inheriting a codebase, and it can either be JS or flowtype, you would choose flowtype?
07:16:36 <Younder> I use koffe-script which is slightly nicer to work with than java-script. Read java-script the good parts. Koffescripi is a kind of Python that compiles to java-script. I like the list comprehensions.
07:16:51 <latk> merijn: I think I see.
07:16:55 <dminuoso> latk: its not "JS or flowtyp9e"
07:17:02 <merijn> latk: Compare JS, where at time point 1 variable 'a' might contain one "type" of value and time point 2 'a' contains something different entirely
07:17:19 <latk> dminuoso: Ok, a js codebase with full flowtype coverage (or whatever is the correct term).
07:17:22 <merijn> latk: How would you describe that sensibly in a type system? It's nightmarish to try and formulate a type system for that
07:17:32 <Younder> Hakellers seem to hate JSON mostly because it doesn't map well into Haskell.
07:18:00 <dminuoso> latk: Some information is better than no information.
07:18:01 <tdammers> oh?
07:18:17 <tdammers> I thought Haskellers would rather think badly about JSON for its typelessness
07:18:18 <dminuoso> Younder: aeson would like to disagree.
07:18:33 <latk> merijn: Is it fair to say that javascript is inconsistent with itself in some way?
07:18:33 <bodisiw> Younder, if there was a good coffeescript dialect with typescript's types, i'd be happier
07:18:38 <tdammers> also, I am unaware of a general dislike of JSON among Haskellers
07:18:55 <merijn> latk: There's also another reason Haskell is "good" in a way that JS is not. Which is most accurately described by Wadler's: "Haskell was discovered, most other languages were invented"
07:18:58 <Younder> Well there is a JSON parser in 'Real world Haskell' and it is a pain to implement.
07:19:03 <ventonegro> I would suggest disengaging the troll
07:19:34 <hodapp> what troll?
07:19:34 <latk> merijn: Ha, my instinct would have been to say it the otherway around - haskell was designed, whereas js evolved or something. Perhaps that shows how little I know.
07:19:35 <merijn> latk: There's an excellent and accessible talk by Wadler on the history of computation and why Haskell is not like C/JS/etc.
07:19:40 <merijn> latk: https://www.youtube.com/watch?v=IOiZatlZtGU
07:19:41 <Younder> troll? :)
07:19:54 <dminuoso> Younder: the full json grammar fits on a regular screen: https://www.json.org/
07:20:02 <merijn> latk: I meant discovered in the way math is discovered :)
07:20:04 <dminuoso> its ridiculously simple to parse.
07:20:08 <latk> merijn: Ah, fair enough :)
07:20:14 <dminuoso> (parsing it efficiently takes some creativitiy though)
07:20:27 <bodisiw> i recently wrote my first actually useful haskell program for a work colleague, and i used aeson... it was fun :-)
07:20:36 <dminuoso> Younder: RWH is somewhat old, and the parsing techniques it advocates are not good.
07:20:38 <merijn> latk: The talk is basically about the intriguing and interesting relation between Haskell, OCaml/ML and formal logic
07:20:50 <latk> merijn: I will watch it over dinner.
07:21:06 <Younder> dminuoso, I agree, but it is tricky to get it to parse in Haskell's type system.
07:21:17 <tdammers> writing a simple json parser in, say, megaparsec, is not difficult at all
07:21:18 <dminuoso> Younder: Its quite easy with generics or TH.
07:21:24 <dminuoso> Younder: Oh the parsing is easy.
07:21:34 <tdammers> and no, Haskell's type system is absolutely not a show stopper
07:22:07 <tdammers> in fact, writing a type that accurately reflects JSON data is pretty straightforward, almost a literal translation of the JSON spec
07:22:13 * ventonegro watches
07:22:30 <tdammers> (with the caveat that the spec itself is awkwardly silent about the matter of numeric types)
07:22:41 <dminuoso> merijn: To me one of the coolest things in Haskell is the fact that so many things are discovered that have such deep laws and connections.. `lens` is a prime example of this, there appears to be so much depth that it really makes you wonder "this might be the right abstraction"
07:22:50 <merijn> tdammers: If you pretend there is no problem it will automatically go away!
07:23:03 <dminuoso> Rather than "here look at how we shoehorn your solution into class based OOP"
07:23:24 <bodisiw> i like the module system
07:23:28 <dminuoso> but "look how it seamlessly fits into functional programming" with laws and connections to homotopy, algebra, category theory..
07:23:40 <bodisiw> which i guess doesn't have any major mathematical theory behind it... but still feels right
07:23:50 <tdammers> in fact I would argue that Haskell's algebraic data types are a better fit for representing JSON than JavaScript's weird objects, or Java's classes
07:23:50 <merijn> dminuoso: Sure, after 3 years of failed experimentation to make it fit ;)
07:24:12 <merijn> I would argue that ADTs are a better fit for representing 90% of things :p
07:24:21 <Younder> To me different design philosophies make things that look great in one language seem awkward in another. This is not an error in one of the other language per se, just that they are different.
07:24:29 <hodapp> I assume ADT = algebraic data type, not abstract data type
07:24:37 <tdammers> hodapp: why not both!
07:24:44 <dminuoso> hodapp: right
07:24:50 <hodapp> tdammers: well, because "abstract data type" is sort of literally the opposite of algebraic
07:25:11 * dminuoso ponders on the choice of the word "literally" in there
07:25:21 <hodapp> in terms of what can be done statically
07:25:58 <tdammers> algebraic on the inside, abstract on the outside
07:26:10 <hodapp> algebraic in the streets, abstract in the sheets
07:26:12 <hodapp> er... what...
07:26:14 * hodapp runs away
07:26:28 <tdammers> probably the other way around though
07:26:32 <hodapp> TMI
07:28:56 <siraben> What is a Haskeller's favorite food?
07:28:58 <Younder> Thou shalt have 3 meta-levels of abstraction. That is always necessary and sufficient. data,record,schema - music,note,harmony-teaching - points,algebra,topology etc.
07:29:41 <tdammers> what
07:29:56 <siraben> I don't know, I was expecting someone would know.
07:30:19 <siraben> What would be a fitting food?
07:30:30 <hodapp> curry.
07:30:34 <siraben> Yes.
07:30:37 <mnoonan> (nobody say burritos, nobody say burritos, nobody say..)
07:30:43 <hodapp> not a joke either. I love curry.
07:30:44 <MarcelineVQ> curry isn't food it's sauce
07:30:51 <siraben> is offended
07:30:54 <hodapp> YOU PUT IT IN YOUR MOUTH, BRAH
07:31:01 <tdammers> curry transcends classifications like "sauce"
07:31:05 <ventonegro> Curried burritos
07:31:06 <siraben> Anything you put in your mouth has type "food"
07:31:13 <siraben> ventonegro: +1 for any curried foods.
07:31:27 <MarcelineVQ> it's technically a roux
07:31:29 * hackage summoner 1.0.0 - Tool for creating completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.0.0 (shersh)
07:31:38 <hodapp> ehh?
07:31:44 <MarcelineVQ> but once you put it on something it's a sauce
07:31:44 <siraben> Out of context?
07:31:45 <tdammers> MarcelineVQ: except thai curry, and also curry isn't just about the fluid part
07:32:11 <hodapp> 'roux' and 'sauce' aren't really exclusive of each other
07:32:15 <hodapp> nor of 'food'
07:32:27 <hodapp> plenty of things from French cooking are simultaneously all three
07:32:31 <siraben> What is the origin of the burrito programming metaphor?
07:32:41 <hodapp> indeed many a great sauce starts with a roux
07:32:41 <MarcelineVQ> siraben: people had enough of bananas
07:32:49 <Younder> I'd say Haskell's Curry was the best is he wasn't so lazy ;)
07:32:59 <siraben> *drum beat*
07:33:00 <hodapp> Curried-Herring Isomorphism
07:33:20 <tdammers> also, uhm, #-blah? maybe?
07:33:34 <hodapp> no hashtags please
07:34:18 <siraben> C people have seafood
07:34:39 <tdammers> hodapp: it's a channel name, not a hashtag.
07:39:39 <mnoonan> a favorite food of ghc developers: https://www.allfreeslowcookerrecipes.com/Slow-Cooker-Casserole-Recipes/Magic-Hash-Brown-Casserole
07:40:09 <siraben> Curried hash brown burritos
07:40:23 <mnoonan> sounds not bad, tbh
07:40:32 <siraben> On the other side, what would a Haskeller hate eating?
07:40:43 <MarcelineVQ> snake
07:40:46 <siraben> Probably a food with side effects
07:40:52 <siraben> Beans
07:41:06 <tdammers> glass shards
07:41:17 <tdammers> because those are dangerous
07:41:27 <ventonegro> I want to say spaghetti but I love it
07:41:29 <exarkun> How do I see which version of a library is actually being used with stack?
07:41:53 <siraben> I wonder if they serve curry at Haskell conferences...
07:41:58 <MarcelineVQ> exarkun: look up your resolver https://www.stackage.org/
07:42:12 <mnoonan> tdammers: those are just a sound composition of safe components, so surely they must also be safe.
07:43:08 <mnoonan> exarkun: you can do "stack --list-dependencies"
07:43:16 <siraben> I think I found the origin of the burrito meme: https://blog.plover.com/prog/burritos.html
07:43:23 <siraben> "Monads are like burritos"
07:43:32 <mnoonan> sorry, just "stack list-dependencies"
07:43:43 <exarkun> mnoonan: It seems incomplete?  Specifically, I am looking for the version of hspec - and hspec does not appear in the output of list-dependencies.
07:44:13 <mnoonan> exarkun: it might just list for the default target unless you specify
07:44:17 <exarkun> ah
07:45:11 <exarkun> indeed, thanks
07:45:27 <mnoonan> np
07:45:38 <exarkun> MarcelineVQ: thanks, that's good to know about too.  is there an index of resolvers on the website?  I seem to be using 11.9 and I don't see a way to query that version without manual url hacking.
07:46:38 <MarcelineVQ> yeah though not an especially searchable one https://www.stackage.org/snapshots
07:46:58 <exarkun> ah.  thanks.
07:47:26 <MarcelineVQ> idk if there's some json query tricket a person could do on that website to search it more nicely
07:48:34 <exarkun> now if only http://hspec.github.io/ had a version number on it somewhere ... :/
07:51:29 <mxf> https://twitter.com/ReinH/status/1001634903388123136
07:51:43 <mxf>                  haskell type level.
08:00:30 * hackage tintin 1.7.0 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.7.0 (NickSeagull)
08:02:10 <JonnyRaa> Hi! I've run into a bit of an issue trying to write a fancier version of sortOn.  Basically I want to pass in Ord b => [a->b] but where b isn't always the same.  I've never used forall with a class before and don't know where to put the brackets! https://pastebin.com/TSguzAhA
08:03:40 <mnoonan> you need your Ord b constraint inside the forall b
08:04:03 <mnoonan> otherwise, you're really talking about two different things named b there
08:05:15 <JonnyRaa> like this? sortOnMultiple :: [a -> ((Ord b) =>forall b . b)] -> [a] -> [a]
08:05:27 <mnoonan> and I think you'll have to pack the thing into a newtype or something
08:05:56 <byorgey> the forall goes before the Ord b,   forall b. Ord b => b
08:06:25 <mnoonan> data SomeOrd = forall b. Ord b => SomeOrd b   -- you'll need something like this, I think
08:06:25 <byorgey> JonnyRaa: what is this function supposed to do?
08:06:58 <byorgey> I am not convinced the way you are approaching it can possibly work
08:07:59 <JonnyRaa> haha, it seems plausible looking but I might be wrong!
08:08:04 <byorgey> SomeOrd = forall b. Ord b => SomeOrd b  is completely useless because you can never compare any two of them (because the type system can't tell whether they are the same type)
08:08:23 <mnoonan> too true
08:08:25 <ReinH> mxf: yes hello
08:08:34 <byorgey> and  a -> (forall b. Ord b => b)  is also useless because you can never write a function of that type
08:09:20 <byorgey> it's not possible to construct something of type   forall b. Ord b => b, which would have to be some value which can have *any* Ord type that anyone chooses
08:09:50 <ReinH> JonnyRaa: what are you trying to do with this?
08:10:47 <JonnyRaa> is that what that's saying?  I want to say b can be anything but it has to be Ord - I want to support multiple b's
08:12:02 <byorgey> JonnyRaa: data SomeOrd = forall b. Ord b => SomeOrd b   would say that, but as I said above, you can't use it
08:12:10 <JonnyRaa> I'm thinking of something like (c#) somelist.orderBy(SomeProperty).thenBy(SomeOtherProperty)
08:12:15 <byorgey> if b can be anything, there's no way to ever compare two of them, because you don't know whether they are the same type
08:13:20 <Paweded> what is this page? https://tinyurl.com/ya79dnx5
08:13:23 <mnoonan> This is building some kind of dictionary ordering, right? I think you're better off converting each comparator into an (a -> a -> Ordering) first, and passing in a list of those.
08:14:00 <JonnyRaa> that's sortof what I was going for with the fold
08:14:41 <dminuoso> cocreature: Okay I think I realized _why_ the Monoid constraint was introduced.
08:14:43 <dminuoso> :t view
08:14:44 <lambdabot> MonadReader s m => Getting a s a -> m a
08:15:36 <dminuoso> :t (both . to (>= 1) . to Any)
08:15:37 <lambdabot> (Num a, Ord a, Contravariant f, Applicative f, Data.Bitraversable.Bitraversable r) => (Any -> f Any) -> r a a -> f (r a a)
08:16:14 <byorgey> JonnyRaa: I agree with mnoonan.  You will have to write a function of type   [a -> a -> Ordering] -> [a] -> [a]
08:16:26 <dminuoso> The argument to the topic has an Applicative `f` constraint - and because view applies this to `Const`, it needs to unify
08:16:28 <dminuoso> :t Const
08:16:29 <lambdabot> forall k a (b :: k). a -> Const a b
08:16:37 <dminuoso> with the above (Any -> f Any)
08:16:42 <byorgey> then you can call it like   sortOn [comparing f, comparing g, ...]
08:16:55 <byorgey> JonnyRaa: there's really no way to write the types so you can say  sortOn [f, g, ...]
08:16:56 <dminuoso> And the only way Const has an Applicative instance, is if there is a Monoid instance on `a`
08:17:02 <mnoonan> JonnyRaa: you could simulate the syntax somewhat by defining "thenBy :: Ord b => (a -> a -> Ordering) -> (a -> b) -> (a -> a -> Ordering)"
08:17:32 <mnoonan> that would let you write "sortBy (comparing foo `thenBy` bar `thenBy` baz)"
08:17:59 <byorgey> thenBy c f = c <> comparing f
08:18:06 <shiona_> :t mconcat [undefined, undefined :: (a -> a -> Ordering)]
08:18:07 <lambdabot> a -> a -> Ordering
08:18:27 <mnoonan> you just can't fold over a list of them, because you can't get all the different "b"s into one (useful) list
08:19:24 <byorgey> > sortBy (comparing length <> comparing last) ["hello", "there", "hi", "world", "zoo", "bar"]
08:19:27 <lambdabot>  ["hi","zoo","bar","world","there","hello"]
08:19:33 <shiona_> :t mconcat . map comparing
08:19:35 <lambdabot> Ord a => [b -> a] -> b -> b -> Ordering
08:20:07 <byorgey> wait, JonnyRaa left =P
08:20:33 <mnoonan> he'll never know what color the bikeshed is!
08:22:52 <Sonarpulse> edwardk: it's Ericson2314 know what the GHC bounds should be?
08:23:00 <Sonarpulse> for bytes for semigroup
08:26:45 <mrUnkn4> p
08:27:39 <mrUnkn4> hello
08:41:51 --- mode: glguy set -o glguy
08:43:31 <dmwit> Did anybody suggest `sortOn (\x -> (foo x, bar x, baz x))` yet?
08:48:29 * hackage tintin 1.7.1 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.7.1 (NickSeagull)
08:50:05 <lortabac> hello
08:50:36 <lortabac> is anyone familiar with the future -XDependentHaskell extension, or dependent typing in general?
08:51:02 <dminuoso> Today is dependent typing day.
08:51:15 <lortabac> I would like to know if something like this will be possible https://lpaste.net/1965620847058092032
08:53:11 <glguy> lortabac: to do that you'd need a new GADT "singleton" type corresponding to your Color type
08:53:41 <dmwit> lortabac: https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Type-Equality.html#v:testEquality
08:54:05 <glguy> lortabac: The package for writing this kind of code is http://hackage.haskell.org/package/singletons-2.4.1/docs/Data-Singletons.html
08:55:07 <lortabac> glguy: thanks, I will have a look
08:55:49 <lortabac> dmwit: how do I go from proving equality to producing a value?
08:56:28 <glguy> lortabac: To use the class dmwit linked to you'll need to the corresponding singleton types as I've linked to
08:57:00 <lortabac> ok
08:57:51 <lortabac> glguy: does your solution allow me to pattern-match from top to bottom?
08:59:30 * hackage self-extract 0.2.1 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.2.1 (brandonchinn178)
09:00:16 <lortabac> glguy: the problem with type-classes is that I cannot say in which order instances should be tried
09:00:36 <lortabac> so I was thinking whether -XDependentHaskell will provide a solution to this
09:02:00 <dmwit> lortabac: You'll be pattern matching on the results of `testEquality`, which lets you say what order to try your patterns in.
09:02:23 <glguy> You won't need test equality in this case single you'll have the singleton values individually
09:02:26 <dmwit> e.g. `data ColorRepr a where BlackRepr :: ColorRepr Black; WhiteRepr :: ColorRepr White`.
09:02:35 <glguy> testEquality is for comparing two different singleton values for equality
09:02:39 <glguy> in this case you'll just pattern match
09:03:06 <dmwit> Or yes, you can skip `testEquality` if you have just one that you want to match on as in your example code.
09:03:11 <lortabac> great, it sounds exactly what I was looking for
09:03:12 <dmwit> So my suggestion wasn't super great. =P
09:06:09 <lortabac> dmwit: glguy: do you know of a good resource to learn about singletons? are the papers mentioned in the haddocks still useful?
09:06:42 <glguy> I don't know that any of this is "useful" but the papers should be a great place to start
09:06:52 <dminuoso> Mmm. Is there a elegant mechanism to take a list [1..] and fill some `a :: Tree Char` with values from that list?
09:07:03 <dminuoso> (Assuming there's an appropriate Traversable instance of course)
09:07:12 <glguy> :t mapAccumL
09:07:14 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:07:15 <lortabac> glguy: thanks
09:07:22 <glguy> dminuoso: If it's traversable, you can use that
09:08:05 <dminuoso> glguy: ah that looks about right thanks
09:11:29 * hackage summoner 1.0.1 - Tool for creating completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.0.1 (shersh)
09:11:36 <glguy> lortabac: https://gist.github.com/glguy/f07795de32da4ffd05cc3a586a0747ee
09:14:47 <lortabac> glguy: so, the user of my library does not need to use singletons, right? They should be able to use colorName2 with just a proxy?
09:15:09 <glguy> No, the proxy isn't really doing anything
09:15:21 <glguy> Haskell doesn't really have dependent types, so you'll be hacking around the issue like this
09:16:42 <lortabac> glguy: ok
09:17:01 <lortabac> glguy: thanks, I need to do some reading now :)
10:03:53 <exarkun> Can Test.Hspec.QuickCheck.property be combined with Test.Hspec.before?  (Sorry if that's a dup)
10:24:02 <JonnyRaa> mnoonan: thanks for the help - I ended up going with something like your suggestion... I think the thing that was wrong with my approach was basically you can't put functions of different types in a list, which I did know but thought some extension hackery might make work for some reason!
10:24:02 <JonnyRaa> also thanks to the other people who replied aswell :) problem solved now
10:39:49 <krokodil> Hi everyone! Is there any way to run `stack build` in a way that doesn't freeze my computer?
10:40:18 <krokodil> I'm using UndecidableSuperClasses, and GHC freezes (I guess it enters an infinite loop during typechecking)
10:40:27 <krokodil> It forces me to constantly reboot my computer
10:41:08 <glguy> You could set a memory limit with ulimit while you debug your class definitions
10:41:33 <krokodil> glguy: does ulimit set only memory limits or CPU limits too?
10:41:45 <glguy> Enabling the Undecidable extensions is your way of telling GHC you already checked that checking your definitions won't loop
10:42:09 <glguy> even better would be to correct whatever it is about your program that's requiring you to turn that on
10:47:05 <lyxia> exarkun: it seems simplest to try a simple example
10:56:25 <exarkun> lyxia: it might be "simplest" but that doesn't necessarily make it "simple" ;)  and even if it is simple, it may not be easy.
10:56:47 <exarkun> however, I did step back and start from the simplest _possible_ hspec definition and then slowly build it up
10:57:04 <exarkun> which worked pretty well until I got to the QuickCheck part ;)  but I did eventually figure that out as well
11:00:30 * hackage binary-ext 2.0.1 - An alternate with strong-typed errors for `Data.Binary.Get` monad from `binary` package.  http://hackage.haskell.org/package/binary-ext-2.0.1 (warlock)
11:01:08 <lyxia> exarkun: you may be right :)
11:01:36 <Bingo> Could someone please explain how to download a package from Hackage onto my local Windows machine without messing anything up?
11:02:29 * hackage hackport 0.5.6 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.5.6 (SergeiTrofimovich)
11:03:54 <exarkun> Bingo: You just want to download it?  Package pages on Hackage have a "Downloads" section with download links.
11:05:44 <glguy> For getting a local copy of a package's source code you can use the "cabal get" command
11:06:06 <glguy> installing a package as a dependency is automatically handled with "cabal new-build"
11:06:47 <Bingo> exarkun: Where do I unzip the tarball? Is there a specific directory so that GHC will find it upon compilation?
11:08:16 <exarkun> Bingo: Ah.  You want to do more than download it.  You want to compile it?  To what end?
11:08:22 <glguy> Bingo: The best way is to list any packages you need in the build-depends: section of your package's .cabal file
11:08:41 <glguy> then "cabal new-build" will automatically download and compile your dependencies and make them available for you
11:09:08 <glguy> "cabal init" can make a skeleton package if you don't have one already
11:10:14 <Bingo> exarkun: I'm trying to get System.Random so I can run a simple example from Learn You a Haskell.
11:10:40 <Bingo> glguy: Do those commands work on Windows as well, or only Linux?
11:11:11 <glguy> Bingo: The Haskell Platform has installers on Windows, Mac, and Linux and is how you get GHC and the cabal command
11:16:54 <noan> I'm currently trying to wrap me head around this: http://hackage.haskell.org/package/elerea ... and I'm starting to suspect it involves a sort of global state engine. Am I kind of right here?
11:17:06 <Bingo> glguy: I realized I don't have a good handle on how cabal works. I've found a tutorial and will work through it. Thank you for your help.
11:17:38 <glguy> Bingo: The shortest way to get System.Random available in your GHCi is "cabal install random"
11:18:03 <glguy> That's not as good for actually developing a package but is handy for playing around in GHCi in isolation
11:23:06 <Bingo> glguy: I tried that command, but I still receive the error " Failed to load interface for `System.Random' "
11:23:24 <glguy> Did you close and reopen ghci?
11:23:35 <Bingo> Yes
11:24:00 <glguy> I don't know, you can paste as much of the output of the commands you ran and the output you got to a pastebin if you need help understanding it
11:35:46 <shapr> Does anyone know if there's a more recent language-go library? I've found https://github.com/remyoudompheng/hs-language-go and https://hackage.haskell.org/package/language-go
11:47:30 * hackage primitive 0.6.4.0 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.6.4.0 (CarterSchonwald)
12:05:36 <danilo2_> Hi guys! I've got such simple TypeInType using program that does not compile and I completely dont get why. Is it GHC bug / missing feature ? https://lpaste.net/8740093542090670080
12:35:28 <exarkun> is there something like System.FilePath.(</>) that doesn't allow ".." and "/"?
12:37:29 * hackage vault 0.3.1.1 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.3.1.1 (HeinrichApfelmus)
12:52:01 <zvectorspace> When using "stack ghci" and not currently in a project directory, is it possible to import modules like System.Random or Data.List.Split? I'd like to quickly utilize ghci on occasion without having to create a temporary project and fiddle with package.yaml
12:53:55 <sm> zvectorspace: does adding --package PKG do it ?
12:54:06 <sm> or, stack install PKG first ?
12:56:35 <zvectorspace> sm: That's the ticket! --package PKG is the secret sauce. Thank you!
13:03:56 <krokodil> I'm really confused by overlapping instances
13:04:13 <krokodil> Specifically, when `class C a a where` doesn't work, but `class (a ~ b) => C a b where` does
13:04:17 <krokodil> Where can I read more about this?
13:05:50 <WarzoneCommand> hmm question. I'm trying to build some rewrite rule that specializes a lens based on its type. But somehow I'm not getting this working. It seems that GHC is "forgetting" about the functor constraint in Lens'? Anyone an idea of why that is happening exactly? https://lpaste.net/2012142966440722432
13:06:49 <lyxia> krokodil: https://chrisdone.com/posts/haskell-constraint-trick https://www.reddit.com/r/haskell/comments/4yl9je/collection_of_type_class_and_constraint_tricks/
13:30:53 <habolabo> you know how it's one, one and a half, two, two and a half...
13:31:22 <krokodil> lyxia: awesome links thanks!
13:31:30 <habolabo> solve for ...: A, ..., B, ..., C, ...
13:40:59 * hackage diagrams-html5 1.4.1 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-html5-1.4.1 (BrentYorgey)
13:55:41 <crysikrend> Hey everyone, does anyone here use hakyll? I could do with some help with pagination, the following code just shows the root of my site without a website (displaying the files and stuff, which is what happens when there's no index.html to load I think). I'm new to hakyll and I was following this guide: https://dannysu.com/2015/10/29/hakyll-pagination/   but it doesn't say HOW to use the code provided. Here's
13:55:43 <crysikrend> my code: https://pastebin.com/65jMY8Un
13:56:01 <crysikrend> any help would be really appreciated - I'm not getting many answers in the hakyll irc
14:00:25 <crysikrend> can someone ping me if you have any idea on how to do this, im really stretched here as im not getting errors ><
14:06:29 * hackage descrilo 0.1.0.6 - Loads a list of items with fields  http://hackage.haskell.org/package/descrilo-0.1.0.6 (mgmillani)
14:07:00 * hackage simtreelo 0.1.1.3 - Loader for data organized in a tree  http://hackage.haskell.org/package/simtreelo-0.1.1.3 (mgmillani)
14:07:07 <sm> crysikrend: not too many folks around that understand hakyll well I think.. you'll probably find most help from other guides/discussion out there
14:08:52 <crysikrend> sm: I thought it was pretty popular for blogging to be honest, didn't expect this
14:09:06 <crysikrend> I think the documentation could be a lot better tbh
14:09:22 <crysikrend> When I've cracked it I'll probably do some PRs to improve it
14:10:05 <sm> it has been pretty popular among haskellers setting up a blog, but I think few people understand it well. Yes, that could be a lot better.
14:10:50 <sm> to get real traction and improvement for it, I think will take a serious effort by a new [co]maintainer
14:11:23 <sm> I'm in process of replacing it by pandoc and shake
14:12:21 <sm> (in my own sites)
14:13:10 <crysikrend> I wouldn't be able to fill in a role like that, but I really like jekyll and if there's a way to use haskell to immprove the control I have I'd love it :)
14:14:08 <crysikrend> sm: so you're trying to remove hakyll from your sit?E
14:14:11 <crysikrend> site?
14:14:21 <sm> well, some docs and website improvements will certainly help
14:14:30 <crysikrend> thats the plan
14:14:31 <sm> yes
14:15:10 <doelie> hi. is there a way to constrain an Applicative such that it guaranteed to be 'zipping', preserving the sizes of input and output?  I.e would reject [] but allow ZipList.
14:15:29 * hackage boomange 0.1.3.6 - A bookmarks manager with an HTML generator  http://hackage.haskell.org/package/boomange-0.1.3.6 (mgmillani)
14:15:57 <glguy> doelie: Have the function specifically use ZipList
14:16:09 <glguy> rather than an arbitrary Applicative instance
14:16:29 <doelie> glguy: is there anything more generic?  E.g. I'd like to use custom functors.
14:22:44 <fishythefish> doelie: you could do something like `class Applicative f => Zipplicative f where` and make your requirement a programmer-checked law of the class, but this has the obvious drawback that you're not actually enforcing anything
14:36:50 <doelie> fishythefish: I think Representable functors might solve it.  For my case it's ok to have only one shape.
14:40:39 <jbgi> @pl \f (a, b) -> f a
14:40:39 <lambdabot> (`ap` snd) . (. fst) . (const .)
14:41:11 <johnw> @pl \(a, b) -> f a
14:41:11 <lambdabot> f . fst
14:43:55 <jbgi> is there any simpler point-free expression for \f (a, b) -> f a ??
14:44:18 <Corwinoid> does where x | any f xs = f xs evaluate f twice?
14:44:56 <fishythefish> jbgi: why use a point-free expression when the lambda is so short and clear?
14:45:35 <glguy> Corwinoid: Probably since the only way what you wrote makes sense is if f is either not doing anything or is using typeclasses to dispatch to an implementation
14:46:31 <johnw> jbgi: (fst .) . first will do it
14:46:41 <johnw> i don't think @pl takes Control.Arrow into account
14:48:33 <Corwinoid> glguy: sorry there's a missing set of parenthases there I guess, should be any (f xs)
14:48:56 <glguy> Corwinoid: That doesn't seem to help, either
14:51:14 <c_wraith> Corwinoid, it should. you don't want CSE on lists.
14:51:17 <Corwinoid> you are right, I've over simplified... the actual line is "where x | any (not . null) $ f xss = f xss", so I want the result of f xss if any of the mapped values are not nulll
14:52:06 <c_wraith> Corwinoid, so ghc almost never does CSE on lists. if you only want it calculated once, bind it to a name.
14:52:08 <Corwinoid> CSE?
14:52:10 <glguy> Corwinoid: f xss will most likely be recomputed
14:52:29 <c_wraith> common subexpression elimination
14:52:31 <glguy> also, any (not . null) (f xss) is better, don't go overboard on the $s
14:54:31 <jbgi> johnw: right, \f -> f . fst will do.
14:55:15 <Corwinoid> glguy thanks, c_wraith thanks for answering the question I didn't know I wanted to ask
15:07:59 * hackage gnss-converters 0.3.35 - GNSS Converters.  http://hackage.haskell.org/package/gnss-converters-0.3.35 (markfine)
15:16:55 <damian> #haskell
15:31:35 <djbeau>  /buffer clear
15:31:57 <djbeau> sorry for the IRC noise
16:14:07 <TommyC> How dare you disturb our great slumber. It's fine. :P
16:14:17 <i0-dfn> got a typeclass question, this either asks me to add AllowAmbiguousTypes or fails when I do add it https://lpaste.net/9198026545782849536
16:14:33 <i0-dfn> writing a typeclass to decode from one type and encode into another type
16:16:20 <glguy> i0-dfn: You can make two separate typeclasses: one for encode and one for decode
16:18:17 <i0-dfn> that bloats up the "real code" a bit though :(
16:18:21 <i0-dfn> any reason this one doesn't work?
16:18:51 <glguy> Because it's not possible to know what instance was intended when you use one of encode or decode since each of those two only mentions one of input or output
16:19:06 <glguy> and the instance selection depends on both input *and* output
16:23:09 <i0-dfn> could the compiler not just treat it as the equivalent of (ClassA input a, ClassB output a) whenever it gets mentioned, and perform instance selection the usual way?
16:23:32 <glguy> no
16:23:44 <i0-dfn> what would the problem be with that
16:23:59 * hackage bond 0.11.0.0 - Bond schema compiler and code generator  http://hackage.haskell.org/package/bond-0.11.0.0 (chwarr)
16:24:08 <glguy> the chosen instance depends on both input and output, so you can't split it up
16:25:03 <i0-dfn> is that not also true for the constraint (ClassA input a, ClassB output a) ?
16:25:08 <glguy> Given: instance FunnySerialize Char Int Bool; instance FunnySerialize Char () Bool;
16:25:28 <glguy> there's no way to know which instance to pick if I have: decode :: Char -> Maybe Bool
16:26:24 <bkc`> do you actually need that much generality? you could also make it compile without ambiguous types by adding i -> o, o -> i to the dependencies
16:26:42 <i0-dfn> i see that, but when i split it as you say, the code seems to have the same problems
16:26:53 <glguy> bkc`: It's worth understanding why this doesn't work first. The class is probably a mistake on its own
16:27:11 <glguy> rather than skipping the process of understanding and making a different class
16:27:15 <fishythefish> i0-dfn: how are you splitting it up?
16:27:22 <i0-dfn> for example this code https://lpaste.net/8065479940826464256 compiles but if i define the extra instances as you say, is it not also ambigious?
16:28:00 <glguy> No, now it's not ambiguous because you can't have more than one implementation of decode to pick from
16:29:17 <i0-dfn> ah fair enough, i see the error comes back when i remove both fundeps
16:29:49 <glguy> When you remove the fundeps on 'a' you get a different ambiguity
16:30:25 <glguy> instead of the class definition being guaranteed to be ambiguous you'll get an ambiguity at the use-site of encode and decode on line 14
16:33:11 <bkc`> you can mimic what you wanted with constraint kinds: type Serialize i o a = (FunnySerialize i a, Y o a)
16:33:38 <glguy> as long as you actually use i and o wherever you use that constraint kind
16:33:42 <bkc`> then f :: (Serialize i o a) => i -> Maybe o
16:33:44 <glguy> otherwise it will be ambiguous again
16:33:55 <bkc`> right
16:41:09 <i0-dfn> i guess the main part i'm missing is how the instance is "picked"
16:46:00 <i0-dfn> when GHC says "could not deduce (Constraint x0 a) arising from a use of <function> from the context (Constraint x a)" it's unclear why x can't be unified with x0
16:48:36 <lyxia> This ensures instance resolution makes consistent choices when the visible instances in the context change.
16:49:51 <lyxia> This ensures that if your program type checks, and you import a new module with more instances, then it will still type check.
16:50:01 <lyxia> with the same choice of instances
16:50:47 <lyxia> if we did unification there, that property would be lost.
16:54:00 * hackage shelly 1.8.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.8.1 (GregWeber)
16:59:32 <i0-dfn> "as long as you actually use i and o wherever you use that constraint kind" -- what is meant by "actually use"?
16:59:37 <i0-dfn> glguy: ^
17:00:03 <i0-dfn> (i'm still trying to understand why the 2-constraint case works, but not the case where both are included in the same typeclass)
17:00:31 <i0-dfn> in both cases i have the input, output types functionally dependent on the data type
17:00:40 <i0-dfn> er, other way around i mean
17:04:13 <fishythefish> i0-dfn: when you split it up into two typeclasses, the typechecker doesn't have to know what `input` is when you call `encode` (resp. `output` and `decode`)
17:04:38 <fishythefish> if you use a single typeclass and only call `encode`, for example, it's totally ambiguous what type `input` was supposed to be
17:05:25 <i0-dfn> i sort of get that, but i thought if i used AllowAmbigiousTypes and only ever used both together in a function, it would be possible to resolve the ambiguity
17:05:43 <i0-dfn> since "input" has to be whatever makes the thing type-check
17:05:59 <i0-dfn> is this what runs into the consistency issue mentioned just above?
17:06:40 <fishythefish> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ambiguous-types-and-the-ambiguity-check
17:07:00 * hackage notzero 0.1 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.1 (qfpl)
17:07:45 <i0-dfn> thanks, i'll have a read
17:08:14 <fishythefish> it's worth understanding what that extension actually does; in general, it'll just shift your problem around somewhere else and your code still won't compile
17:34:41 <nconroy> hello
17:35:32 <nconroy> does anyone know the place to discuss the Haskell Cabal project?
17:36:50 <nconroy> hello :)
17:37:39 <sclv> nconroy: the #hackage channel
17:38:40 <nconroy> thanks sclv
17:45:30 * hackage gmpint 0.1.0.14 - GMP integer conversions  http://hackage.haskell.org/package/gmpint-0.1.0.14 (vmchale)
17:47:00 * hackage fast-arithmetic 0.6.0.7 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.0.7 (vmchale)
18:13:30 * hackage speechmatics 0.2.0.0 - Speechmatics api client  http://hackage.haskell.org/package/speechmatics-0.2.0.0 (Jappie)
18:48:07 <Morno> A while back there was a Haskell infographic with different "levels" of subjects, does anyone happen to have a link to it?
18:55:19 <moet> any idea how to stop `stack test` from executing all the tests in directories under `packages:` ?
18:57:28 <moet> err. i guess the answer is to move the dependency from `packages:` to `extra-deps:`, both of which takk paths
19:22:04 * hackage gitlib 3.1.2 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.1.2 (JohnWiegley)
19:24:21 <oisdk> Morno this? http://lambdaconf.us/downloads/documents/lambdaconf_slfp.pdf
19:27:17 <blankhart> idris the singing dragon is not depicted here.  choir practice, too busy to participate.
20:38:43 <buhman> I'm reading my book that told me "evaluate simple expressions involving add/multiply of two numbers, one expression per line, evaluating each line as it is entered". I came up with: https://lpaste.net/6897278574668021760 but I notice I only get the lazy evaluation when I use `stack runghc` but not `stack ghc`: https://lpaste.net/2316978429188112384
20:39:50 <buhman> is this related to `show :: [a] -> String` ?
20:41:08 <mud> buhman: I'm not sure, but that could just be different buffering modes there, line buffering vs block buffering.
20:50:39 <buhman> very unhelpfully, the book's solution is objectively incorrect :(
20:51:08 <buhman> https://lpaste.net/3791292190525751296
21:03:55 <Axman6> Does anyone know what the current state of the art for parsing XML data into haskell data structures a la aeson's FromJSON is? I have never worked withXML in Haskell (nor elsewhere really) so I'm struggling to understand how to best approach its more flexible data model
21:04:33 <Axman6> (not necesarilly looking for a type class, just how one writed parsers
21:04:34 <Axman6> )
21:13:19 <JuanDaugherty> so in computing you have subcultures
21:13:42 <JuanDaugherty> with the normal things subcultures have, beliefs, prejudices, etc
21:14:35 <JuanDaugherty> in the hs culture, XML is generally considered clumsy and archaic, an impression partly due to the fact that it is turn of the century technology
21:15:11 <JuanDaugherty> to my mind and in actual practice, the best tools for it are those in heavy use Xerces and soforth
21:16:22 <JuanDaugherty> but it's ubiguity means that there are versions of them in essentially every major subculture that isn't too stuck on itself to deal with the larger world
21:16:52 <JuanDaugherty> iirc there are at least 3 or 4 well used hs pkgs
21:17:34 <JuanDaugherty> the great thing about it is it's dead so you don't have to worry about change
21:18:01 <JuanDaugherty> dead in the sense of not growing like hs is as a lang
21:18:59 <JuanDaugherty> and partly due to the fact that it is clumsy and verbose
21:20:35 <JuanDaugherty> which is a big clash with hs which strives for the ultra terse
21:23:32 <Axman6> JuanDaugherty: makes sense to me (and apology for not reply sooner, was afk). Amy partticular libraries you've used, and any tutorials on how to design parsers?
21:24:08 <JuanDaugherty> hs ones no, I use Xerces with an DNS/EPP thing I have
21:24:44 <JuanDaugherty> also have used xmlrpc c++ and others
21:25:15 <Axman6> Also I believe schema documents exist for the particular standard we're looking to implement, and was wondering if things like xsd documents are well supported by anything. I have found one package which claim to support xsd, but its code generation side of things breaks in ways I don't understand (possible because I am not feeding it enough xsds)
21:25:21 <JuanDaugherty> I wouldn't use hs because I'm not locked into any lang
21:25:31 <JuanDaugherty> yes that's why I use it for EPP
21:25:40 <Axman6> EPP?
21:26:10 <JuanDaugherty> EPP is defined by an XML schema which I pull directly from the RFC and use with the XML tools
21:26:27 <cocreature> I’ve used xml-conduit and have been quite happy with it, both with the streaming interface and the non-streaming interface (which is nice for things like scraping html)
21:26:56 <JuanDaugherty> Extensible Provisioning Protocol it's what DNS uses to operate at the registry to registrar level though it has other uses
21:28:18 <JuanDaugherty> no reason not to use a reasonably well worked out hs pkg if that's your pref
21:28:39 <JuanDaugherty> but nothing is going to be comparable to the solidity of Xerces et. al.
21:28:53 <buhman> JuanDaugherty: do you also think that other standards built on top of XML like XACML are also transitively clumsy and archaic?
21:29:17 <buhman> I've wondered for awhile if there was some similar spec that didn't represent itself in XML
21:29:53 <JuanDaugherty> well it's a value judgement that comes from a certain perpective which I was echoing
21:29:55 <Axman6> part of my problem is that I'm so unfamiliar with XML that I don't know where to start with fixing erros I'm running into, like nout being able to resolve namespaced entities (I think...)
21:31:05 <Axman6> I have been looking at https://hackage.haskell.org/package/fadno-xml-1.1.1/docs/Fadno-Xml-ParseXsd.html for processing an xsd files, but trying to generate code from what's parsed is not wokring due to unresolved referneces
21:31:06 <JuanDaugherty> have seen it's origin from SGML and even before that dwscript that was only available inside IBM, i have a somewhat different perspective
21:31:40 <suzu> you might want to take a look at HXT
21:31:44 <JuanDaugherty> *having seen. Certainly compared to json or the like it could seem overmuch
21:32:05 <suzu> https://hackage.haskell.org/package/hxt
21:32:51 <suzu> i believe this is the "state of the art" for manipulating xml documents
21:33:11 <buhman> and it's from the year 20161
21:33:15 <suzu> and is very well features
21:33:18 <suzu> featured*
21:33:26 <suzu> yes, it also holds copyright into the far future!
21:33:31 <buhman> how do you get more state of the art than 18,145 years from now?
21:33:39 <suzu> ^
21:33:46 <JuanDaugherty> Axman6, well one good thing that should be reassuring is that XML is basically unchanged in like 15 years so finding stuff out and orienting yourself should be easy
21:34:00 <JuanDaugherty> the new things are derivatives like html5
21:54:06 <dminuoso> What is a simple example of a polymorphic prism?
21:54:27 <dminuoso> Ive been going through this page over the paper maybe 10 times now, and I think Im getting too confused
21:55:20 <cocreature> dminuoso: what exactly do you mean by “polymorphic prism”?
21:55:50 <cocreature> you mean an actual Prism rather than a Prism'?
21:55:54 <dminuoso> Right
21:56:06 <cocreature> :t _Left
21:56:07 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
21:56:15 <cocreature> is that simple enough? :)
21:56:40 <dminuoso> cocreature: Ah.. I think so. Let me quickly line that type up with `Prism` :)
21:57:06 <cocreature> I wish ghci wouldn’t unfold type synonyms here
22:00:03 <cocreature> oh :i doesn’t unfold it
22:00:31 <dminuoso> cocreature: Ahh thats great to know, that helps :)
22:01:07 <cocreature> apparently there is also -fno-print-expanded-synonyms but whatever that is supposed to do it doesn’t help with :t
22:01:21 <dminuoso> cocreature: Oh I think Im getting an idea.. so when `s !~ t` and `a !~ b` they must still in some way be interrelated, right?
22:03:57 <dminuoso> :t put `asAppliedTo` _Just
22:03:59 <lambdabot> (Applicative f, Choice p, MonadState (p a (f b) -> p (Maybe a) (f (Maybe b))) m) => (p a (f b) -> p (Maybe a) (f (Maybe b))) -> m ()
22:04:14 <dminuoso> :t put `asAppliedTo` _Left
22:04:15 <lambdabot> (Applicative f, Choice p, MonadState (p a (f b) -> p (Either a c) (f (Either b c))) m) => (p a (f b) -> p (Either a c) (f (Either b c))) -> m ()
22:07:55 <iqubic> :t asAppliedTo
22:07:56 <lambdabot> (a -> b) -> a -> a -> b
22:08:10 <iqubic> Huh? What is the point of that?
22:08:24 <dminuoso> iqubic: If you use it with :t it lets you see how the LHS is unified
22:08:38 <dminuoso> I just wanted to see how
22:08:58 <dminuoso> :t put
22:08:58 <dminuoso> Is unified with _Left as its first argument
22:08:59 <lambdabot> MonadState s m => s -> m ()
22:09:21 <iqubic> huh? I'm not understanding why asAppliedTo is useful.
22:09:48 <dminuoso> iqubic: Its not useful for actually writing code. It's just useful when you want to know how types unify
22:10:31 <iqubic> Can I see an example, without weird type synonym unfolding?
22:10:31 <dminuoso> iqubic: look at the type signature
22:10:54 <dminuoso> :t fmap `asAppliedTo` (+1)
22:10:56 <lambdabot> (Num b, Functor f) => (b -> b) -> f b -> f b
22:11:16 <iqubic> What does that show?
22:11:25 <dminuoso> :t fmap
22:11:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:11:32 <dminuoso> iqubic: This is the fully polymorphic type right?
22:11:36 <iqubic> Yeah.
22:11:53 <dminuoso> iqubic: If you apply `fmap` to (+1) it has to unify both types together. So perhaps you might ask yourself "how is the type of fmap restricted"
22:12:02 <iqubic> Right.
22:12:09 <iqubic> :t (+1)
22:12:10 <cocreature> dminuoso: depends on what you mean by “related” I suppose
22:12:10 <lambdabot> Num a => a -> a
22:12:25 <dminuoso> iqubic: maybe a simpler example is
22:12:28 <iqubic> Where did the num constraint go in the asAppliedTo?
22:12:37 <dminuoso> iqubic: Its still there
22:12:42 <dminuoso> 07:10       lambdabot | (Num b, Functor f) => (b -> b) -> f b -> f b
22:12:52 <dminuoso> if you look at the original type
22:12:52 <dminuoso> 07:11       lambdabot | Functor f => (a -> b) -> f a -> f b
22:13:16 <iqubic> What is the other example?
22:13:16 <dminuoso> after type unification it has figured out that `a ~ b` and (Num a)
22:13:24 <iqubic> I see.
22:13:45 <iqubic> What is the simpler example?
22:14:14 <dminuoso> :t (+1) `asAppliedTo` id
22:14:15 <lambdabot> Num (a -> a) => (a -> a) -> a -> a
22:14:57 <dminuoso> :t id `asAppliedTo` (+1)
22:14:58 <lambdabot> Num a => (a -> a) -> a -> a
22:15:27 <iqubic> What the heck? Num (a -> a) => ... Is that valid Haskell?
22:16:06 <dminuoso> iqubic: (->) is just a type constructor, similar to Either
22:16:11 <iqubic> Is there even an instance Num ((->) a)?
22:16:29 <nisstyre> maybe for church numerals
22:16:50 <nisstyre> I don't think that would actually work though, would it?
22:16:59 <nisstyre> or maybe it would
22:17:11 <iqubic> > (+1) `asAppliedTo` id $ +2
22:17:13 <lambdabot>  <hint>:1:25: error: parse error on input ‘+’
22:17:33 <iqubic> > (+1) `asAppliedTo` id $ (+ 2)
22:17:35 <lambdabot>  error:
22:17:35 <lambdabot>      Precedence parsing error
22:17:35 <lambdabot>          cannot mix ‘asAppliedTo’ [infixl 0] and ‘$’ [infixr 0] in the same i...
22:17:44 <iqubic> Grr.
22:17:57 <simon> > asAppliedTo (+1) id (+2)
22:17:59 <lambdabot>  error:
22:17:59 <lambdabot>      • No instance for (Num (Integer -> Integer))
22:17:59 <lambdabot>          arising from a use of ‘e_112’
22:18:06 <iqubic> ((+1) `asAppliedTo` id) $ (+ 2)
22:18:29 <iqubic> I see. So how does one find a valid instance of (Num (a -> a))?
22:18:36 <iqubic> Does one even exist?
22:19:53 <dminuoso> Lets say you accidentally wrote this code
22:20:08 <dminuoso> > (+1) id
22:20:10 <lambdabot>  error:
22:20:10 <lambdabot>      • No instance for (Typeable a0)
22:20:11 <lambdabot>          arising from a use of ‘show_M23626493673163026231514’
22:20:22 <iqubic> :t (+1) id
22:20:24 <lambdabot> Num (a -> a) => a -> a
22:20:54 <iqubic> fmap :: (a -> b) -> Maybe a -> Maybe b
22:20:59 <simon> :t (+1)
22:21:01 <lambdabot> Num a => a -> a
22:21:25 <iqubic> fmap f = maybe Nothing (Just . f)
22:21:33 <iqubic> Does that type check?
22:21:47 <simon> so the point is that you can make functions that take type class constraints for which there exists no instances of that type class, and you'd only have a problem applying that function, not writing it?
22:22:03 <iqubic> I suppose so. How odd.
22:22:12 <dminuoso> asAppliedTo has no point beyond giving you a tool to ask the compiler and unify types for you
22:22:20 <simon> I came in late, so I'm not sure if this is a build-up to something. :)
22:22:21 <dminuoso> "if you were given this, how would it unify"
22:22:25 <dminuoso> That's all its for.
22:22:38 <dminuoso> It's not about whether instances exist, whether you could implement it.
22:23:15 <iqubic> Does my fmap written with maybe (the maybe catamorphism) actually work?
22:23:53 <iqubic> :t \f -> maybe Nothing (Just . f)
22:23:54 <dminuoso> :t maybe
22:23:54 <lambdabot> (a1 -> a2) -> Maybe a1 -> Maybe a2
22:23:55 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:24:25 <iqubic> :t \f -> maybe Nothing (Just . f)
22:24:27 <lambdabot> (a1 -> a2) -> Maybe a1 -> Maybe a2
22:24:38 <iqubic> If that works, why not write fmap that way?
22:25:06 <geodesic[m]> Is this package dead?
22:25:07 <geodesic[m]> https://hackage.haskell.org/package/haskell-mpi
22:25:09 <dminuoso> iqubic: that is a valid implementation for `fmap` in the instance Maybe
22:25:19 <iqubic> :t \f -> either (Left . f) (Right . f)
22:25:19 <dminuoso> *instance Functor Maybe
22:25:20 <lambdabot> (a -> b) -> Either a a -> Either b b
22:25:40 <iqubic> Is that how the Either functor works?
22:25:48 <dminuoso> iqubic: Nope and you should be able to say why
22:25:52 <dminuoso> :kind Functor
22:26:00 <iqubic> :k Functor
22:26:02 <lambdabot> (* -> *) -> Constraint
22:26:22 <dminuoso> :t fmap
22:26:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:26:40 <iqubic> I'm not sure how my thing is failing to work. Is it not possible to have an Either functor, because the kinds don't line up?
22:26:48 <aarvar> :t join bimap
22:26:50 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
22:26:57 <dminuoso> iqubic: Right.
22:26:57 <dminuoso> But!
22:27:00 <iqubic> :t bimap
22:27:02 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
22:27:13 <dminuoso> iqubic: What you could do is state "for every choice of type `a` we have have a Functor (Either a)
22:27:24 <iqubic> yeah, that would work.
22:27:40 <iqubic> What does Functor (Either a) look like?
22:27:46 <dminuoso> iqubic: You tell me
22:28:05 <iqubic> Is it what I just wrote? I think It's what I just wrote.
22:28:10 <dminuoso> Nope its not.
22:28:15 <iqubic> Why not?
22:28:39 <dminuoso> iqubic: Assume that `a` is some specific type. Say write an instance Functor (Either Int)
22:29:14 <dminuoso> And then look at the type of `fmap`.
22:34:14 <iqubic> :t fmap `asAppliedTo` (Either Int a)
22:34:15 <lambdabot> error:
22:34:15 <lambdabot>     • Data constructor not in scope: Either :: t0 -> Expr -> a -> b
22:34:15 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
22:34:21 <iqubic> Yeah, that didn't work.
22:34:50 <iqubic> (a -> b) -> Either c a -> Either c b
22:35:00 <iqubic> How do I write that?
22:36:28 <dminuoso> iqubic: You tell me. =)
22:37:04 <dminuoso> You've been long enough at this that I can expect you to work on it.
22:37:15 <iqubic> I'm not sure what to do if I'm passed (Left c)
22:38:00 <iqubic> fmap f = either Left (Right . f)
22:38:07 <iqubic> I like point free.
22:39:03 <iqubic> And as soon as I wrote that hlint came in and said "Why not use fmap f" So I feel that I did it right.
22:39:19 <dminuoso> iqubic: Test it and verify that `fmap id = id`
22:39:33 <dminuoso> (parametricity guarantees that when this is satisfied, its a functor)
22:39:54 <iqubic> I do get that result.
22:40:13 <iqubic> Right . id is just Right.
22:40:19 <dyl> :t fmap
22:40:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:40:26 <dyl> :t fmap id
22:40:28 <lambdabot> Functor f => f b -> f b
22:40:30 <iqubic> and "either Left Right" is clearly id
22:40:42 <dyl> Let c = f b
22:40:53 <dyl> fmap id :: c -> c
22:40:59 <dminuoso> iqubic: Here's how I like to think of a Functor. It's a _pair_ of mappings.
22:41:04 <iqubic> \f -> either Left (Right . f)
22:41:06 <dminuoso> One maps a type to a different type
22:41:11 <dyl> ?free foo :: c -> c
22:41:11 <lambdabot> f . foo = foo . f
22:41:11 <dminuoso> and one maps a function to a different function
22:41:23 <dminuoso> iqubic: `Maybe :: * -> *` is the type mapping
22:41:32 <dyl> :t id . fmap
22:41:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:41:35 <iqubic> :t \f -> either Left (Right . f)
22:41:37 <lambdabot> (a1 -> b) -> Either a2 a1 -> Either a2 b
22:41:49 <iqubic> That looks like the right signature.
22:41:57 <dminuoso> iqubic: So every Functor must be equipped with some `* -> *` (that is a mapping of types)
22:42:09 <iqubic> And I verified that "fmap id = id" for my definition
22:42:10 <dminuoso> This is expressed in this
22:42:10 <dminuoso> :t Functor
22:42:11 <dyl> When the function hits your eye like a big lawful type
22:42:11 <lambdabot> error: Data constructor not in scope: Functor
22:42:13 <dyl> Thaaaaaaats
22:42:16 <dyl> A mooooonad
22:42:17 <dminuoso> :k Functor
22:42:18 <lambdabot> (* -> *) -> Constraint
22:42:25 <dyl> (Ignore me.)
22:42:33 <iqubic> dyl: What are you saying?
22:42:55 <dyl> Nothing relevant except before :t id . fmap
22:43:06 <dyl> That part might be helpful but otherwise, no.
22:43:06 <dminuoso> iqubic: So a clean way to say it, is `Either` is not a functor. Also `Either a b` is not a functor.
22:43:09 <dminuoso> But `Either a` is a functor
22:43:16 <dminuoso> But that means you cant change that `a` anymore
22:43:28 <dyl> A functor has to have kind * -> *
22:43:36 <dyl> It has one type parameter.
22:44:08 <iqubic> So today I finally figured out what an endofunctor is. It's a functor that, instead of mapping from Catagory C to Catagory D, it maps from Catagory C to other objects in Catagory C
22:44:10 <dyl> \a -> Either a b is also a functor over b. Assuming that syntax existed.
22:44:19 <dyl> But note that the same is not true of Validate.
22:44:25 <iqubic> What is Validate?
22:44:47 <dyl> It is like Either but the left side is a mono is.
22:44:51 <dyl> Monoid*
22:44:52 <dminuoso> iqubic: Right. In Haskell all our Functors are actually Endofunctors.
22:44:58 <iqubic> Yes, I get that.
22:45:17 <iqubic> I'm currently reading the ebook Catagory Theory for Programmers.
22:45:19 <dyl> It does not form a monad though, for some subtle but irrelevant reasons
22:45:32 <dyl> Obligatory: Category theory won’t teach you Haskell.
22:45:39 <dyl> It will only help you understand what you know better.
22:45:45 <iqubic> And I just now got to the part where they define functors using catagory theory.
22:45:55 <dminuoso> Obligatory: category theory won't really improve your haskell
22:46:04 <dminuoso> But if you have personal curiosity, by all means carry on.
22:46:10 <iqubic> dyl: I know. I just like learning about catagory theory.
22:46:12 <dyl> Absolutely
22:46:16 <dyl> CT is super cool
22:46:19 <dyl> Don’t be discouraged.
22:46:41 <dyl> It’s the Dewey decimal system of algebra, in some sense.
22:46:48 <dyl> It’s a way of reasoning about mathematical patterns.
22:46:50 <dyl> Super valuable.
22:46:56 <dyl> But it won’t teach you Haskell.
22:47:08 <iqubic> I also learned about why Algebraic Data Types are called Algebraic. It's because Sum types and Product types actually correspond to adding and multiplying.
22:47:19 <iqubic> Very enlightening.
22:47:20 <dyl> What is differentiation then :)?
22:47:40 <iqubic> I don't know.
22:47:43 * dyl gestures towards a rabbit hole.
22:48:00 <siraben> iqubic: I am also reading that book.
22:48:04 <siraben> It's enlightening.
22:48:08 <iqubic> The most elightening thing I did recently was prove this isomorphism:
22:48:09 <siraben> Makes the math notation less scary too.
22:48:11 <iqubic> Either a a ~ (Bool, a)
22:48:29 <dyl> That makes sense if you think only in terms of entropy.
22:48:31 <iqubic> siraben: I'm only reading this book because you suggested it.
22:48:37 <siraben> Haha
22:48:45 <iqubic> dyl: Why do you say that.
22:49:03 <iqubic> :t either (\x -> (False, x)) (\y -> (True, y))
22:49:04 <lambdabot> Either b b -> (Bool, b)
22:49:07 <dyl> Because the left side carries however much entropy an “a” does plus the position (left or right)
22:49:14 <dyl> A bool carries one bit,
22:49:21 <dyl> and the a carries as much as an a does.
22:49:23 <dyl> Same thing.
22:49:32 <siraben> Learning Haskell is not for the weak minded, it seems.
22:49:37 <iqubic> :t (\(x, a) -> bool (Left a) (Right a) x )
22:49:38 <lambdabot> (Bool, b) -> Either b b
22:49:41 <dyl> Same amount of information/entropy in both expressions.
22:49:51 <iqubic> There. Isomorphism proved.
22:49:59 <dyl> Sure.
22:49:59 <siraben> Wow
22:50:16 <dyl> siraben: what’s “weak minded” supposed to mean?
22:50:21 <dyl> Haskell is for the children.
22:50:28 <dyl> Like Wu Tang.
22:50:29 <siraben> Minds accustomed to weak typing nonsense
22:50:36 <dyl> Don’t be like that.
22:50:36 <iqubic> Yeah, I like eliminating parameters from the LHS when ever it makes sense to me.
22:50:37 <siraben> Strong types make a strong mind.
22:50:47 <dyl> Ah, to be a neophyte again.
22:51:05 <iqubic> I also like the bool function. It's literally the church encoding of the Bool datatype.
22:51:39 <dyl> What about the other direction iqubic?
22:51:49 <dyl> You haven’t shown the entire isomorphism yet...
22:52:02 <iqubic> I did actually.
22:52:02 <siraben> He did, didn't he?
22:52:17 <dyl> My bad
22:52:19 <iqubic> :t (\(x, a) -> bool (Left a) (Right a) x )
22:52:20 <lambdabot> (Bool, b) -> Either b b
22:52:29 <dyl> ?genie Either b b -> (Bool, b)
22:52:29 <lambdabot> Unknown command, try @list
22:52:33 <iqubic> :t either (\x -> (False, x)) (\y -> (True, y))
22:52:35 <lambdabot> Either b b -> (Bool, b)
22:52:35 <dyl> Is that command gone?
22:52:46 <iqubic> That is the entire isomorphism.
22:52:56 <dyl> Oh right
22:53:12 <siraben> What is the type of a type?
22:53:12 <dyl> @djinn Either a a -> (Bool, a)
22:53:12 <lambdabot> f a =
22:53:12 <lambdabot>     case a of
22:53:12 <lambdabot>     Left b -> (False, b)
22:53:12 <lambdabot>     Right c -> (False, c)
22:53:22 <iqubic> siraben: that's a kind.
22:53:31 <dyl> @djinn (Bool, a) -> Either a a
22:53:31 <lambdabot> f (a, b) =
22:53:32 <lambdabot>     case a of
22:53:32 <lambdabot>     False -> Left b
22:53:32 <lambdabot>     True -> Right b
22:53:35 <dyl> :)
22:53:42 <siraben> Looks like Coq to me
22:53:46 <iqubic> Well it did half of the conversion correctly.
22:53:56 <iqubic> The second half.
22:54:00 <dyl> Yeah. It messed up the first half.
22:54:08 <dyl> Should be True/False respectively.
22:54:14 <iqubic> Yeah.
22:54:15 <dyl> I mean it’s correct but not the correct correct.
22:54:22 <dyl> It’s incorrect correct.
22:54:36 <iqubic> I also showed that types distribute.
22:54:43 <dyl> We’re just feeding it one edge of a commutative square.
22:54:49 <iqubic> :t either (\(x, b) -> (x, Left b)) (\(y, c) -> (y, Right c))
22:54:50 <lambdabot> Either (a1, a2) (a1, b) -> (a1, Either a2 b)
22:54:56 <siraben> iqubic: Is there something higher than a kind?
22:54:56 <dyl> So it’s not concerned with both commuting.
22:55:01 <dyl> A sort
22:55:12 <iqubic> :t \(x, y) -> either (\b -> Left (x, b)) (\c -> Right (x, c)) y
22:55:13 <lambdabot> (a, Either b1 b2) -> Either (a, b1) (a, b2)
22:55:17 <dyl> Or in Agda, Set0, Set1, Set2, ....
22:55:35 <dyl> You can have infinite layers if you so please.
22:55:51 <iqubic> Roughly corresponds to a * (b + c) = a * b + a * c
22:56:00 <dyl> But value, type, kind, and *maybe* sort is plenty in 99% of cases.
22:56:35 <dyl> The other 1% only matter if you’re edwardk.
22:56:41 <dyl> Otherwise, don’t worry about it.
22:57:08 <dyl> Or maybe if you’re conal or Cale.
22:57:11 <dyl> But stills
22:57:15 <dyl> still.*
22:57:29 <iqubic> So I like proving things using Haskell.
22:57:38 <siraben> Haskell as a theorem prover?
22:57:38 <dyl> You should play with Agda.
22:57:42 <dyl> You’d enjoy it.
22:57:50 <dyl> Agda is cool.
22:58:12 <siraben> Wow I just looked it up.
22:58:12 <iqubic> Agda sounds complex.
22:58:23 <dyl> It’s even worse.
22:58:25 <dyl> It’s simpler.
22:58:28 <siraben> "Agda is also a proof assistant, but unlike Coq, has no support for tactics, and proofs are written in a functional programming style."
22:58:33 <iqubic> dependent types confuse the heck out of me.
22:58:40 <siraben> Yes!  Tactics always confused me in Coq
22:58:58 <dyl> Agda is Haskell with no standard library at all, dependent types, and an infinite stratification of types, kinds, sorts, .......
22:59:18 <dyl> And it has sexy mixfix.
22:59:32 <iqubic> Like could I make a type that was (a, b) where a > b?
22:59:36 <dyl> It’s just pure programs-are-proofs.
22:59:46 <dyl> You want to prove something? State the theorem as a type.
22:59:50 <dyl> Now construct a value of that type.
22:59:53 <dyl> There’s your proof.
23:00:02 <dyl> Actually making it accumulate the steps is a bit trickier.
23:00:08 <iqubic> Or a strictly ascending list? Is that possible to do with depnedent types?
23:00:20 <dyl> What does > mean,
23:00:22 <dyl> ?*
23:00:22 <lambdabot> Maybe you meant: v @ ? .
23:00:28 <iqubic> dyl: I think you just describe the Curry-Howard isomorphism.
23:00:34 <dyl> Exactly.
23:00:42 <dyl> Agda is just that, pretty much.
23:00:43 <iqubic> > is greater than, provided that a and b can be compaired.
23:00:46 <lambdabot>  <hint>:1:16: error: parse error on input ‘,’
23:00:59 <dyl> But how?
23:00:59 <iqubic> Stupid bot.
23:01:06 <iqubic> I'm not sure.
23:01:11 <dyl> Agda won’t give you any presupposed means of comparing them.
23:01:16 <dyl> If you can define a way to do it
23:01:19 <dyl> then sure.
23:01:32 <iqubic> Can I use dependent types to make a type that is a list of Ints all ascending?
23:01:42 <dyl> A type,
23:01:44 <dyl> ?*
23:01:44 <lambdabot> Maybe you meant: v @ ? .
23:02:00 * hackage perf-analysis 0.0.1.0 - analysis example using perf  http://hackage.haskell.org/package/perf-analysis-0.0.1.0 (tonyday567)
23:02:04 <dyl> You could of course make a type that is inductively defined.
23:02:15 <dyl> But... idk what you mean to get at.
23:02:30 <dyl> Agda isn’t a general purpose language.
23:03:02 <iqubic> what I don't understand is why dependent types are helpful at all. Every time I enter that rabbit hole, I wind up with more questions than answers.
23:03:07 <dyl> That said: https://github.com/larrytheliquid/Lemmachine
23:03:12 <dyl> Don’t overthink it
23:03:19 <dyl> DT just completes the cube.
23:03:30 <dyl> Think about a type of fixed length vectors.
23:03:43 <dyl> Vec (n :: Nat) a
23:03:43 <iqubic> I don't get what that would be.
23:03:48 <iqubic> Oh, I see.
23:03:52 <dyl> a type of vectors of exactly size n
23:03:55 <iqubic> I undestand that.
23:04:04 <dyl> That’s basically a good example.
23:04:11 <dyl> But it gets complex fast.
23:04:19 <dyl> DT = types that depend on values
23:04:28 <dyl> Google “lambda cube”
23:04:31 <iqubic> So bascially you could write a version of head that wouldn't be compilable if you tried to call "head []"
23:04:54 <dyl> Yeah but you’d have to always know the length at compile time.
23:04:57 <dyl> Which isn’t always helpful.
23:05:11 <siraben> It's amazing that so many things in theoretical computer science are so amazingly simple you can explain them to a child.
23:05:13 <iqubic> Doesn't that involve running the program at compile time?
23:05:35 <iqubic> Also, you can't have a lazy dependently typed language can you?
23:05:50 * dyl points at Agda
23:06:07 <dyl> Sure you can.
23:06:10 <iqubic> Because what is the type of "let ones = 1:ones in ones"?
23:06:13 <dyl> Again, look up the lambda cube
23:06:20 <iqubic> What is the length of ones?
23:06:31 <dyl> That depends on the signature of :
23:06:42 <iqubic> Right. I see.
23:06:44 <dyl> If it’s a -> List a -> List a
23:06:53 <dyl> Then the type of ones is List a
23:06:54 <siraben> What is the type of a quine?
23:06:55 <dyl> Clearly.
23:07:18 <iqubic> What if it is "a -> List n a -> List (Succ n) a"?
23:07:26 <dyl> siraben: a -> IO a?
23:07:38 <iqubic> Where n :: Nat
23:07:59 <dyl> iqubic: then that must be (if it’s nontrivial) append.
23:08:11 <dyl> I see what you mean.
23:08:14 <dyl> Try it out :).
23:08:25 <iqubic> I don't know Agda, I can't do that.
23:08:41 <dyl> Maybe the type is just List (Fix Succ) a or such.
23:08:57 <dyl> (Fix Succ) n*
23:09:04 <dyl> Types can be recursive too.
23:09:11 <dyl> Something like that. I forget.
23:09:42 <dyl> How would you express it if you DIDN’T have lazyness?
23:09:56 <dyl> Types can be lazy too, so can sorts, etc...
23:10:05 <iqubic> Alright, besides length indexed lists, what other dependent types are there?
23:10:06 <dyl> If you have a language that allows for that.
23:10:15 <dyl> iqubic: whatever you want.
23:10:30 <dyl> If you have a type that depends on a value...
23:11:27 <iqubic> is 1 a value?
23:12:17 <dyl> Depends on how you define it.
23:12:28 <dyl> Agda really starts you with nothing.
23:12:36 <dyl> Just the set hierarchy and the ability to define GADTa.
23:12:39 <iqubic> like why does Agda use Nat instead of Int to index list lengths?
23:12:42 <dyl> GADTs*
23:12:49 <dyl> it doesn’t have either natively.
23:12:56 <dyl> You have to define them.
23:13:07 <dyl> You start with Set0, Set1, Set2, ...
23:13:33 <iqubic> Can Agda create recursive ADTs?
23:13:55 <dyl> Why not?
23:15:57 <dyl> Agda isn’t useful for general purpose programming though.
23:16:03 <dyl> If you want that look at Idris.
23:16:09 <iqubic> Does Agda have IO?
23:16:13 <dyl> Or enable a lot of GHC extensions.
23:17:46 <dyl> Wouldnt be very useful if it did.
23:17:49 <glguy> Yes, Agda has IO.
23:17:58 <dyl> It does. But...
23:18:00 <dminuoso> dyl: *if it didnt
23:18:07 <dyl> Yes.
23:18:19 <dyl> But Agda isn’t useful in the sense Haskell is.
23:18:31 <dyl> It’s useful for a different sort of programming.
23:19:32 <geodesic[m]> a quine just prints itself
23:19:40 <geodesic[m]> io
23:25:06 <iqubic> What's the shortest Haskell Quine that exists?
23:25:20 <siraben> A number
23:26:06 <dminuoso> > (\a -> a ++ show a) "(\\a -> a ++ show a) "
23:26:09 <lambdabot>  "(\\a -> a ++ show a) \"(\\\\a -> a ++ show a) \""
23:26:09 <opqdonut> ghci quines are cheating a bit though
23:26:25 <iqubic> I want the shortest quine that will work if you compile and run the code.
23:26:33 <dminuoso> iqubic: I found this one: main = (putStr . ap (++) show) "main = (putStr . ap (++) show) "
23:26:47 <iqubic> How does that work?
23:26:59 <dminuoso> iqubic: It took you 1s to give up and ask instead? :p
23:27:07 <geodesic[m]> I guess it kinda looks like (\  x1 -> x1 x1 ) (\   x1 -> x1 x1 )
23:27:08 <dminuoso> iqubic: Try to work it out.
23:27:14 <geodesic[m]> or something
23:27:14 <iqubic> :t ap
23:27:16 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:27:19 <siraben> What's the shortest twine?
23:27:33 <siraben> e.g. x evaluates to y which evaluates to x
23:28:05 <geodesic[m]> does this even work lmao
23:28:13 <dminuoso> siraben: `fix id`
23:28:23 <iqubic> So running program a prints the source of b, and running b prints the source of a?
23:28:27 <siraben> Yes
23:28:37 <siraben> This is glorious: https://github.com/mame/quine-relay
23:28:50 <siraben> 128 language quine relay
23:29:35 <geodesic[m]> ye
23:30:32 <iqubic> How does that even work?
23:30:48 <siraben> I still don't know.
23:30:50 <siraben> Some magical code gen
23:31:07 <siraben> I wish I understood Ruby...
23:31:26 <siraben> https://github.com/mame/quine-relay/blob/master/src/code-gen.rb
23:31:43 <siraben> Line 620 is Haskell
23:34:32 <geodesic[m]> how did they even make that
23:34:34 <geodesic[m]> lmao
23:34:38 <iqubic> What is that Haskell code even do?
23:35:18 <siraben> Apparently print something to the screen
23:35:27 <siraben> It's a bit of a mystery.
23:35:32 <iqubic> yeah, but what?
23:35:39 <jle`> iqubic: i know one way to find out :)
23:35:51 <siraben> A haskeller's nightmare: figuring out what things do at runtime
23:36:11 <siraben> Looks like the only way is to run through the relay.
23:36:15 <siraben> only way to know*
23:36:27 <jle`> there is probably more than one way, but the easiest way would be to use a tool
23:36:34 <jle`> a tool specifically designed to take haskell source code
23:36:40 <jle`> and output the thing it prints out
23:36:47 <jle`> i wonder if anyone has developed anything like that :)
23:36:56 <siraben> Any examples of amazing obfuscated Haskell code?
23:37:06 <siraben> I saw an implementation of map that uses hieroglyphs
23:37:37 <siraben> There's x=fix(((<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2)))1)
23:38:38 <iqubic> What is that doing?
23:38:44 <siraben> You have to import Control.Applicative
23:38:48 <siraben> and Data.Function
23:38:53 <siraben> Then try running take 10 x
23:39:41 <iqubic> :t fix(((<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2)))1)
23:39:42 <lambdabot> Num t => [t]
23:39:48 <iqubic> Huh?
23:39:59 <siraben> Yes
23:40:20 <siraben> x becomes an infinite stream of the powers of two
23:40:20 <iqubic> > fix(((<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2)))1)
23:40:22 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
23:40:32 <iqubic> How the heck does that work?
23:40:42 <siraben> https://stackoverflow.com/a/12660526
23:40:49 <jle`> i would start by adding back in the points
23:41:05 <jle`> if i wanted to understand it
23:41:13 <jle`> or at least start replacing the function calls with definitions
23:41:53 <siraben> https://wiki.haskell.org/Obfuscation
23:42:01 <dminuoso> jle`: Hey. You talked about Day a few months ago. Is there any correlation between `Day convolution` and convolution in the signal processing sense?
23:42:15 <siraben> I'm surprised they didn't use the full power of unicode for confusion
23:42:29 <dminuoso> (Im trying to fully grasp what Day really is)
23:42:54 <jle`> dminuoso: good question
23:43:29 <siraben> i = g(1,180,60,2) where
23:43:30 <siraben>   g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t))
23:43:30 <siraben>                in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1)
23:43:37 <siraben> This one is pretty basic, it's just the Pi spigot algorithm.
23:43:44 <siraben> There's one in C, and this is just a hand translation
23:44:37 <jle`> dminuoso: on the surface they seem to have the same "types"
23:45:01 <jle`> dminuoso: a spatial or temporal convolution takes two functions and returns a third function
23:45:10 <jle`> dminuoso: a day convolution takes two functors and returns a third functor
23:45:40 <dminuoso> jle`: right - in some sense it's a kind of "product" right?
23:46:15 <dminuoso> Which would even hold true for say a spatial convolution
23:47:19 <dminuoso> jle`: It was triggered when you said that `Day` can be thought of a delayed liftA2 - I then realized that in some sense :.: can be thought of a delayed join, but you have to squint *really* hard for that perspective
23:47:31 <jle`> yeah, i remember vaguely from my DSP classes that convolutions provide a group (or at least monoid) structure for functions
23:47:58 <iqubic> What is Day?
23:48:08 <iqubic> :k Day
23:48:09 <lambdabot> error:
23:48:09 <lambdabot>     Not in scope: type constructor or class ‘Day’
23:49:19 <jle`> data Day f g c = Day (f a) (g b) (a -> b -> c)
23:49:42 <jle`> in pseudo-haskell
23:50:38 <dminuoso> Day :: f a -> g b -> (a -> b -> c) -> Day f g c
23:50:52 <jle`> dminuoso: convolutions are definitely interpreted as a sort of product, since the symbol used for them is commonly *
23:51:17 <jle`> and it looks like yeah, in a lot of contexts, it gives you an group on functions
23:51:33 <dminuoso> iqubic: Day is to Applicative what Compose is to Monad. :P
23:51:38 <jle`> i remember doing something fancy where (+)/(*) created a ring for my R -> R functions
23:52:06 <jle`> (+) being point-wise addition
23:52:15 <jle`> (f + g)(x) = f(x) + g(x)
23:52:21 <jle`> this class was a long time ago haha.
23:53:14 <jle`> hm, okay, i think i have the link
23:53:20 <jle`> or a potential link
23:53:34 <jle`> for `Day f g c`, you existentially quantify over 'a' and 'b'
23:53:57 <jle`> existential quantification is related to sums
23:54:08 <jle`> (sum types)
23:54:54 <jle`> so a functional analysis convolution is an integral/sum over many possible inputs to f and g
23:55:24 <jle`> it sums f(k)*g(x-k), for all k
23:56:15 <jle`> in a day convolution of `Day f g`, you "sum over" (existentially quantify) all possible inputs to 'f' and 'g'.  you sum over `f Int` and `g Bool`, `f Double` and `g String`...basically all possible combinations of 'a' and 'b'
23:57:19 <jle`> `Day f g c` is essentially a sum (+) of `(f a, g b, a -> b -> c)` for all possible 'a' and 'b'
23:57:51 <jle`> so this is a little bit different from a normal convolution, since the inputs to 'f' and 'g' have to be linked somehow.
23:58:17 <jle`> ah, okay, we can bridge that gap with a slightly different rephrasing of Day
23:58:59 <jle`> `data Day f g b = forall a. Day (f (a -> b)) (g a)`
23:59:34 <jle`> then yeah, that's exactly what we have here in the case of a normal convolution.  `Day F G X` is a sum of (f (a -> X), g a), summed over all 'a'
