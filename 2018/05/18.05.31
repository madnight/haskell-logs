00:00:10 <jle`> and for the normal convolution, you have (f(t - k) * g(t)), summed over all k
00:00:30 <jle`> it's the exact same thing :)  except replace (-) with (->) hehe.  add a ">" ;)
00:01:03 <jle`> * f(t-k) * g(k)
00:01:09 <siraben> brb restarting erc
00:08:32 <jle`> dminuoso: summarized my rambling and confusion into a tweet https://twitter.com/mstk/status/1002083992743505920
00:09:42 <dminuoso> jle`: You kind of lost me half way through, but Ive written down notes. Just like your original hint regarding `Day = delayed liftA2` this will linger in my head for a while until I have the necessary basics to make sense of it =)
00:10:12 <jle`> yeah, it made more sense once i rewrote day in a parallel way
00:10:37 <jle`> type Day f g t = exists k. (f k, g (k -> t))
00:10:51 <jle`> (f * g)(t) = sum k. f(k) * g(t-k)
00:11:03 <jle`> so exists plays the role of sum, tupling plays the role of multiplication
00:11:12 <jle`> i just don't get how (k -> t) is linked to (t - k)
00:11:14 * jle` shrugs
00:55:14 <zvectorspace> ]/part
01:07:00 * hackage sixty-five-oh-two 1.2.0.0 - An eDSL for writing 65(C)02 bytecode.  http://hackage.haskell.org/package/sixty-five-oh-two-1.2.0.0 (aearnus)
01:10:59 * hackage zephyr 0.1.4 - Zephyr tree shaking for PureScript Language  http://hackage.haskell.org/package/zephyr-0.1.4 (coot)
01:18:22 <tsahyt> is there any article or paper on how Applicative/Monadic parsers correspond to context-free/context-sensitive grammars respectively?
01:18:56 <tsahyt> intuitively it seems that there is some correspondence, since an Applicative parser does not give me access to previous derivations (i.e. no context), whereas with a monadic parser I can do that
01:20:03 <dminuoso> tsahyt: regular parser combinators are just tools to construct recursive descent parsers from
01:20:17 <aleator_> tsahyt: Alos, correspondence might not really exist as you can make "infinite" applicative parsers, which pushes them out of context-free zone.
01:20:25 <dminuoso> tsahyt: that is, if you wrote a recursive descent parser and refactored enough, you might get a form using parser combinators back
01:20:57 <quicksilver> tsahyt: the intuition is broadly sound but technically wrong
01:21:08 <quicksilver> there is quite a nice discussion in byorgey's blog here : https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
01:21:53 <quicksilver> and by discussion, I'm referring to the comments section on that post
01:22:07 <tsahyt> ah, damn infinities always messing up my intuition
01:22:21 <tsahyt> thanks for the input! I'm off to read this post then
01:28:29 * hackage binary-ext 2.0.2 - An alternate with strong-typed errors for `Data.Binary.Get` monad from `binary` package.  http://hackage.haskell.org/package/binary-ext-2.0.2 (warlock)
01:30:29 * hackage cabal-rpm 0.12.4 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.12.4 (JensPetersen)
03:00:34 <jle`> don't mind us, just moving a conversation over from #haskell-beginners :)
03:00:47 <jle`> % import Control.Applicative.Backwards
03:00:48 <yahb> jle`:
03:01:10 <jle`> % forwards $ empty <*> Backwards (putStrLn "hello")
03:01:11 <yahb> jle`: hello; *** Exception: user error (mzero)
03:01:15 <dminuoso> :t (<**>)
03:01:16 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
03:01:24 <jle`> ^ that's a situation where `empty <*> x` is not `empty`
03:01:45 <dminuoso> jle`: gah.
03:02:04 <jle`> so, left zero is not something you can say about Alternatives and Applicative/<*>
03:02:15 <jle`> but it *is* something you can safely say about MonadPlus and `ap`
03:02:17 <dminuoso> Backwards is a cool thing though.
03:02:32 <jle`> yeah, it's actually pretty useful
03:02:52 <jle`> i use it all the time with traverse, to traverse a structure in reverse order
03:03:06 <jle`> % forwards $ traverse (Backwards . print) [1..10]
03:03:07 <yahb> jle`: 10; 9; 8; 7; 6; 5; 4; 3; 2; 1; [(),(),(),(),(),(),(),(),(),()]
03:04:01 <jle`> %let reverseTraverse f = forwards . traverse (Backwards . f)
03:04:06 <jle`> % let reverseTraverse f = forwards . traverse (Backwards . f)
03:04:06 <yahb> jle`:
03:04:10 <jle`> % :t reverseTraverse
03:04:11 <yahb> jle`: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:04:21 <dminuoso> % :t traverse
03:04:21 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:04:32 <dminuoso> Wow this is. Cool.
03:05:02 <jle`> yeah, it's useful when you get some traversal that only goes one direction, or your type's 'traverse' gives you the wrong order of traversal that you need
03:05:56 <jle`> it's analogous to the `Dual` monoid transformer
03:06:12 <jle`> that lets you 'mconcat' backwards
03:06:32 <jle`> % let import Data.Semigroup
03:06:32 <yahb> jle`: ; <interactive>:43:5: error: parse error on input `import'
03:06:36 <jle`> % import Data.Semigroup
03:06:37 <yahb> jle`:
03:06:54 <jle`> % let reverseFoldMap f = getDual . foldMap (Dual . f)
03:06:55 <yahb> jle`:
03:07:00 * hackage summoner 1.0.2 - Tool for creating completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.0.2 (shersh)
03:07:01 <jle`> % :t reverseFoldMap
03:07:01 <yahb> jle`: (Foldable t, Monoid c) => (a -> c) -> t a -> c
03:07:16 <jle`> it's just like foldMap except the items get accumulated in reverse order
03:07:43 <jle`> again useful for those pesky situations where a type's foldMap instance gives the wrong order from the one you need :)
03:08:18 <jle`> % reverseFoldMap show [1..5]
03:08:19 <yahb> jle`: "54321"
03:10:27 <dminuoso> jle`: This is starting to feel familiar - it nicely fits into my current reading into profunctor optics.
03:10:43 <dminuoso> foldMap f = getConst . traverse (Const . f)
03:11:45 <jle`> hmmmmm
03:12:57 <jle`> % let reverseFoldMap :: forall t. (Foldable t, Monoid c) => (a -> c) -> t a -> c; reverseFoldMap = coerce (traverse @t @(Const (Dual c)))
03:12:57 <yahb> jle`: ; <interactive>:48:53: error: Not in scope: type variable `c'; <interactive>:48:60: error: Not in scope: type variable `a'; <interactive>:48:65: error: Not in scope: type variable `c'; <interactive>:48:73: error: Not in scope: type variable `a'; <interactive>:48:78: error: Not in scope: type variable `c'; <interactive>:48:132: error: Not in scope: type variable `c'
03:13:11 <jle`> % let reverseFoldMap :: forall t a c. (Foldable t, Monoid c) => (a -> c) -> t a -> c; reverseFoldMap = coerce (traverse @t @(Const (Dual c)))
03:13:12 <yahb> jle`: ; <interactive>:49:102: error:; * Couldn't match representation of type `t a0' with that of `t a' arising from a use of `coerce'; NB: We cannot know what roles the parameters to `t' have; we must assume that the role is nominal; * In the expression: coerce (traverse @t @(Const (Dual c))); In an equation for `reverseFoldMap': reverseFoldMap = coerce (traverse @t @(Const (Dual c)));
03:15:15 <dminuoso> %let f = getDual . getConst $ traverse (Const . Dual)
03:15:32 <dminuoso> % let f = getDual . getConst $ traverse (Const . Dual)
03:15:32 <yahb> dminuoso: ; <interactive>:50:30: error:; * Couldn't match expected type `Const (Dual c) b1' with actual type `[a0] -> Const (Dual a0) [b0]'; * Probable cause: `traverse' is applied to too few arguments; In the second argument of `($)', namely `traverse (Const . Dual)'; In the expression: getDual . getConst $ traverse (Const . Dual); In an equation for `f': f = getDual . getConst $ traver
03:15:39 <jle`> % let reverseFoldMap :: forall t a c. (Foldable t, Monoid c) => (a -> c) -> t a -> c; reverseFoldMap = coerce (traverse @t @(Const (Dual c)) @a)
03:15:39 <yahb> jle`: ; <interactive>:51:110: error:; * Could not deduce (Traversable t) arising from a use of `traverse'; from the context: (Foldable t, Monoid c); bound by the type signature for:; reverseFoldMap :: forall (t :: * -> *) a c. (Foldable t, Monoid c) => (a -> c) -> t a -> c; at <interactive>:51:5-82; Possible fix:; add (Traversable t) to the context of;
03:15:44 <jle`> sorry :)
03:15:53 <jle`> % let reverseFoldMap :: forall t a c. (Foldable t, Monoid c) => (a -> c) -> t a -> c; reverseFoldMap = coerce (traverse_ @t @(Const (Dual c)) @a)
03:15:53 <yahb> jle`:
03:15:57 <jle`> okay that's it :)
03:16:06 <dminuoso> % let f = getDual . getConst . traverse (Const . Dual)
03:16:06 <yahb> dminuoso:
03:16:07 <jle`> essentially `reverseFoldMap = coerce traverse_`
03:16:54 <jle`> ooh
03:17:07 <dminuoso> % f ["foo", "bar", "quux"]
03:17:08 <yahb> dminuoso: "quuxbarfoo"
03:17:17 <jle`> instead of `Const (Dual c)`, you can also do `Backwards (Const c)`
03:17:21 <jle`> they're equivalent ~
03:17:30 <dminuoso> o_o
03:17:54 <jle`> % let f' = getConst . forwards . traverse (Backwards . Const)
03:17:54 <yahb> jle`:
03:18:03 <jle`> > f' ["foo", "bar", "quux"]
03:18:06 <lambdabot>  error:
03:18:06 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M263793675481...
03:18:06 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
03:18:35 <jle`> oh interesting
03:18:51 <jle`> i would have expected defaulting to kick in
03:19:12 <dminuoso> jle`: it works on my machine
03:19:23 <dminuoso> Is there some interference with the extensions it has enabled?
03:19:38 <jle`> % let f'' = getConst . forwards . traverse (Backwards . Const @_ @())
03:19:39 <yahb> jle`:
03:19:39 <dminuoso> or does yahb have different defaulting settings?
03:19:46 <jle`> > f'' ["foo", "bar", "quux"]
03:19:48 <lambdabot>  error:
03:19:48 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M627641117952...
03:19:48 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
03:20:05 <jle`> hm, i'm not sure what settings would cause defaulting to fail here
03:20:24 <jle`> :t f'
03:20:26 <lambdabot> FromExpr a => a
03:20:30 <dminuoso> Well. The yahb issues aside, this is truly remarkable.
03:20:35 <jle`> % :t f'
03:20:36 <yahb> jle`: (Traversable t, Monoid c) => t c -> c
03:21:14 <dminuoso> @let f' = getConst . forwards . traverse (Backwards . Const)
03:21:15 <jle`> yeah, Backwards/Dual really hammer in the close connection between Applicative and Monoid to me
03:21:16 <lambdabot>  .L.hs:163:17: error:
03:21:16 <lambdabot>      Variable not in scope: forwards :: f0 (t b2) -> Const c b0
03:21:16 <lambdabot>      |
03:31:29 * hackage baserock-schema 0.0.1.5 - Baserock Definitions Schema  http://hackage.haskell.org/package/baserock-schema-0.0.1.5 (locallycompact)
03:31:36 <dminuoso> 12:06            jle` | % let reverseFoldMap f = getDual . foldMap (Dual . f)
03:31:39 <dminuoso> I dont fully grasp this one.
03:31:51 <dminuoso> Ohh nevermind!
03:32:03 <dminuoso> I kept reading foldMap but reading traverse. That was a waste of 5 minutes.
03:32:10 <dminuoso> *reading foldMap but thinking traverse
03:32:14 <jle`> heh, i've been there :)
04:34:00 * hackage tintin 1.8.0 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.8.0 (NickSeagull)
05:01:39 * hackage fswatch 0.1.0.3 - File System watching tool with cli and slave functionalities.  http://hackage.haskell.org/package/fswatch-0.1.0.3 (kelemzol)
05:06:53 <dminuoso> Wow this is crazy..
05:06:56 <dminuoso> :t view
05:06:57 <lambdabot> MonadReader s m => Getting a s a -> m a
05:08:53 <dminuoso> :t view `asAppliedTo` (undefined :: Traversal' s m)
05:08:54 <lambdabot> (Monoid a, MonadReader s m) => Getting a s a -> m a
05:09:46 <gnzazazaa> :t ($)
05:09:47 <lambdabot> (a -> b) -> a -> b
05:11:01 <dminuoso> :t view . each
05:11:02 <lambdabot> (Each (a1 -> Const a1 a1) (Const a1 s) a2 b, MonadReader s m) => (a2 -> s -> b) -> m a1
05:11:13 <siraben> :t <$>
05:11:14 <lambdabot> error: parse error on input ‘<$>’
05:11:28 <dminuoso> cocreature: So I think Im getting a good idea why I dont need to know profunctor optics to understand how this works in principle.
05:11:32 <dminuoso> This is extremely cool
05:12:07 <siraben> I don't really get how game programming is possible in haskell without state
05:12:20 <dminuoso> siraben: We can do state in Haskell
05:13:25 <dstolfa> :t State
05:13:27 <lambdabot> error:
05:13:27 <lambdabot>     • Data constructor not in scope: State
05:13:27 <lambdabot>     • Perhaps you meant one of these:
05:13:29 <dstolfa> :<
05:13:33 <dstolfa> :t StateM
05:13:34 <lambdabot> error:
05:13:34 <lambdabot>     • Data constructor not in scope: StateM
05:13:34 <lambdabot>     • Perhaps you meant one of these:
05:13:37 <dstolfa> really?
05:13:59 <dstolfa> how does this work
05:14:08 <dstolfa> :t State a b
05:14:08 <dminuoso> dstolfa: State is a _type_
05:14:09 <lambdabot> error:
05:14:09 <lambdabot>     • Data constructor not in scope: State :: Expr -> Expr -> t
05:14:09 <lambdabot>     • Perhaps you meant one of these:
05:14:11 <dminuoso> :k State
05:14:12 <lambdabot> * -> * -> *
05:14:14 <dminuoso> :k StateT
05:14:15 <lambdabot> * -> (* -> *) -> * -> *
05:14:16 <dstolfa> dminuoso: i thought :t was for types
05:14:19 <dstolfa> AH.
05:14:19 <dstolfa> okay.
05:14:23 <dminuoso> dstolfa: :t is for _values_
05:14:26 <dstolfa> dminuoso: TIL
05:14:39 <dminuoso> dstolfa: :t = give me the type of
05:14:43 <dstolfa> ah alright
05:14:44 <dstolfa> thanks
05:14:44 <dminuoso> dstolfa: :k = give me the kind of
05:16:15 <gnzazazaa> take 2 [1,2,3,4,5,6]
05:16:23 <gnzazazaa> mmm
05:17:01 <gnzazazaa> does anyone knows a online console with haskell?
05:17:03 <dminuoso> siraben: Take a look at the State monad. It's the principle how we represent state in Haskell programs.
05:17:40 <gnzazazaa> im at work and i cant run GHCi and need to try some things
05:19:25 <dminuoso> gnzazazaa: You could talk to lambdabot in a private chat
05:19:38 <dminuoso> repl.it also has a GHCi shell but I dont know how well that works
05:19:52 <siraben> What if we run a coordinated attack against lambdabot by running [1..]
05:20:02 <phadej> > [1..]
05:20:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:20:09 <quicksilver> gnzazazaa: or https://repl.it/languages/haskell
05:22:37 <gnzazazaa> ohhh right dminuoso
05:22:52 <gnzazazaa> o forget to put ">" after declarations :D
05:22:55 <gnzazazaa> thks
05:25:04 <Psybur> Test
05:25:28 <Psybur> Hmm don't know if you guys can see this. Stupid Android clients
05:25:34 <srhb> Psybur: We can.
05:25:49 <Psybur> I can't see anything for this channel :D
05:26:43 <Psybur> A hop fixed it. Strange
05:27:57 <sm> gnzazazaa: repl.it
06:14:03 <paolino> hi, is there a way to derive Generic for NominalDiffTime , which doesn't export the constructor ?
06:21:49 <dminuoso> paolino: Why do you want to break the privacy of a data type?
06:25:13 <paolino> dminuoso: I'm using Serialise which can derive its instance if I have a Generic
06:25:59 <dminuoso> paolino: Write your own instance then. Use any of the instances you get access to, like Fractional perhaps or Show.
06:27:09 <dminuoso> paolino: nominalDiffTimeToSeconds effectively lets you deconstruct it into picoseconds
06:28:17 <paolino> dminuoso: POSIXTime is deep down in the data structure, if I loose Generic for it I have to Serialise everything above it by hand
06:29:01 <Boarders> Hi I was trying to follow the tutorial for hakyll here: https://jaspervdj.be/hakyll/tutorials/01-installation.html
06:29:58 <Boarders> but if I try running 'stack exec site watch' from a Makefile it says: "Downloaded lts-10.10 build plan.     InvalidYaml (Just (YamlException "Yaml file not found: [filepath]"
06:30:24 <Boarders> it works fine from the command line though
06:30:32 <paolino> dminuoso: I see there is a Data instance for it, do you know if I can use it to write a Generic one ?
06:30:35 <Boarders> any ideas why make has this behaviour?
06:32:40 <dmwit> paolino: Are you sure? When I write `data Foo = Foo; data Bar = Bar Foo deriving Generic` it works fine here.
06:33:11 <dmwit> paolino: (Are you sure that if you don't have `Generic` for `NominalDiffTime` you can't have it for types containing `NominalDiffTime`, that is.)
06:33:57 <paolino> dminuoso: I'm not sure, but deriving has access to the Foo constructor there
06:35:07 <dmwit> paolino: It works even without access to the Foo constructor. (Just checked.)
06:35:19 <paolino> It's not working with POSIXTime don't know why
06:35:28 <dmwit> Time to make an MCVE and show us.
06:35:50 <dmwit> No, wait, you misunderstood.
06:36:21 <dmwit> You write the Serialize instance for NominalDiffTime or POSIXTime or whatever by hand. Then you just derive Generic and Serialize for the types containing it.
06:37:09 <paolino> mhh, hyper confuse now
06:37:38 <paolino> it's because it uses Generic only if Serialize is not there
06:37:55 <dmwit> Yes. For the container types, you will not (yet) have a Serialize instance.
06:38:34 <mbwgh> I am encountering "Exception: test/data/mails/Mail/cur/mymail1: hGetContents: invalid argument (invalid byte sequence)", most likely due to `readFile` expecting utf-8, but getting iso-8859-1 (latin1) instead. I encountered this before and could work around it by decoding the ByteString manually. The point is, if I execute my test with profiling enabled and +RTS -xc, the stack trace isn't really helpful.
06:38:40 <mbwgh> readFile doesn't show up, but ok, I might be wrong. But hGetContents doesn't show up either. Am I profiling "not deeply enough" somehow? The trace seems to go only from `main` to `assertFailure`, but not below.
06:39:08 <dminuoso> dmwit: How would that help though?
06:39:12 <paolino> dmwit: how can it derive Generic for a type if it has inner types without it ?
06:39:24 <merijn> mbwgh: You're locale is messed up
06:39:28 <dmwit> paolino: I don't know. But it does work. I did science to it to determine this fact.
06:39:38 <merijn> mbwgh: Your locale is set to utf-8, but the file is apparently latin1
06:39:44 <dmwit> dminuoso: Why wouldn't it help?
06:40:06 <merijn> mbwgh: Are you using a profiled version of your code?
06:40:32 <merijn> mbwgh: Stack traces generally only work "right" with profiling versions of code
06:40:39 <dmwit> dminuoso: I'm assuming the Serialize class has a default implementation of its methods that relies on Generic existing.
06:40:47 <dmwit> dminuoso: Generic can exist even if the contained types aren't Generic.
06:41:04 <dminuoso>  Serialize a => GSerializePut (K1 * i a)
06:41:07 <dminuoso> Ah you are right.
06:41:10 <dmwit> dminuoso: Presumably in such base cases, it will use the Serialize instance of the base case.
06:41:14 <merijn> It would, presumably, be easier to just manually write A serialise instance
06:41:26 <dminuoso> merijn: well as it has been pointed out its in some nested structure.
06:41:28 <dmwit> dminuoso: So, in the "base case" -- here, NominalDiffTime -- it would use the hand-written Serialize instance.
06:41:41 <merijn> Relatedly, I would (currently) probably recommend binary over using cereal by now (which doesn't really solve this issue)
06:42:00 <dminuoso> dmwit: Oh yeah. I just didn't realize there was an `instance Serialize a => GSerializePut (K1 * i a)`
06:42:09 <dminuoso> merijn: What's the rational for that?
06:42:29 * hackage contiguous 0.1.0.0 - Unified interface for primitive arrays  http://hackage.haskell.org/package/contiguous-0.1.0.0 (andrewthad)
06:42:34 <merijn> dminuoso: cereal got made as alternative for binary when dealing with strict ByteString and incremental decoding
06:42:47 <merijn> But binary has since been extended with support for incremental and strict decoding
06:42:59 <merijn> So binary can handle both strict and lazy and cereal only strict
06:43:01 <mbwgh> merijn: I know that. I have to work with files both in utf-8 and latin1. Generally speaking, if I were to publish the code, someone else's locale may be configured incorrectly as well. I was only referring to the unsatisfying stack trace, and I am indeed running with profiling enabled. But it might be that I didn't recompile base with profiling. I used `stack test --profile --trace` and `stack test
06:43:07 <mbwgh> --executable-profiling --library-profiling --trace`, which resulted in the same behavior as far as I can tell.
06:43:21 <dmwit> mbwgh: You can dynamically control GHC's chosen encoding.
06:43:25 <merijn> mbwgh: Then you need to explicitly set the GHC RTS locale to the right encoding before opening them
06:43:45 <merijn> I have no clue what stack does, so I can't comment on that
06:44:30 <dmwit> mbwgh: ...mmm, but only on a per-handle basis, so if you don't know where the handle is getting created, that doesn't help. =P
06:44:42 <dmwit> mbwgh: Anyway, I have some SO writing on "not profiling deep enough", let me see if I can dig it up.
06:45:19 <dmwit> mbwgh: https://stackoverflow.com/q/10838785/791604
06:46:44 <dmwit> paolino: So, are you sorted? Or are you still having trouble/confused about the game plan?
06:46:54 <paolino> https://lpaste.net/6125340035223912448
06:48:32 <dmwit> what the heck is up with that paste
06:48:37 <dmwit> pipes and numbers everywhere
06:49:06 <mbwgh> dmwit: I guess the "old style" traces could work, yes. But I guess this is kind of a last resort.
06:49:11 <merijn> dmwit: Looks like missing CSS?
06:50:15 <mbwgh> Could it be that if `tasty` catches a `SomeException` and doesn't rethrow, that this will influence the trace?
06:50:38 <dmwit> paolino: What package provides Codec.Serialise?
06:51:03 <paolino> serialise
06:51:26 <paolino> sorry for the paste, tmux and vim
06:51:53 <Boomerang> Is it possible to give a default implementation for an associated type? I am trying to get Generic instances for my class
06:52:19 <merijn> Boomerang: Don't think so, and not sure that even makes sense?
06:52:31 <dmwit> paolino: That file compiles fine for me. Does it not for you?
06:52:48 <dmwit> paolino: (After turning on TypeSynonymInstances, DeriveFunctor, and DeriveGeneric.)
06:52:49 <paolino> no
06:53:02 <dmwit> Okay, well... what error do you get?
06:53:25 <Boomerang> merijn: Well in my case I should be able to derive the associated type just from the structure of the instances
06:53:41 <Boomerang> I basically want to represent nested product types as nested tuples
06:54:01 <Boomerang> and come back from the tuple representation to the original types
06:54:13 <dmwit> Boomerang: You could consider providing a separate type family (named, say, `type family FooDefault a`) that does the needful that folks can drop in when it's the Right Thing.
06:55:22 <Boomerang> Yeah maybe a type family would be better. I'm not sure how to make that work with Generic though. Would I give an implementation of my type family to say :*:?
06:55:36 <paolino> dmwit it does now, I don't know why I had this cannot derive Generic POSIXTime and now it's gone
06:55:48 <Boomerang> This is all fairly new to me so I'm probably going the wrong way about it
06:55:55 <dmwit> paolino: Because you can't derive Generic POSIXTime, and shouldn't be trying to.
06:56:05 <dmwit> (And that file doesn't try to.)
06:56:12 <dmwit> Perhaps you forgot to delete a standalone deriving clause?
06:56:22 <paolino> yeah
06:57:00 <paolino> and ghcid + nvim are playing tricks on me, compiling old stuff
06:58:21 <merijn> I'm working on an ghcid alternative for getting vim to highlight warnings, but I keep getting sidetracked with actual work ;)
06:58:46 <paolino> dmwit how can it derive Generic (Timed v) without asking the Generic for the inside ? Now I notice it was not asking even for 'v' , my bad
06:59:36 <paolino> I guess I have to understand what Generic is at some point
06:59:59 * hackage primitive-sort 0.1.0.0 - Sort primitive arrays  http://hackage.haskell.org/package/primitive-sort-0.1.0.0 (andrewthad)
07:00:35 <zxtx> hey, I'm trying to represent a language in Haskell with a GADT where I carry the type of the expression in Haskell. What's the standard way to handle user-defined datatypes in this setting?
07:01:38 <dmwit> paolino: I don't know, but I suspect the Generic representation has, besides the recursive cases like "product" and "sum", some base cases like "and this thing which should be taken as a non-Generic chunk".
07:02:02 <dminuoso> paolino: there is an: instance Serialize a => GSerializePut (K1 * i a)
07:02:16 <dminuoso> paolino: So if the inner thing is serializable, it knows how to handle that
07:02:55 <dmwit> zxtx: You will need a type-level representation for the user-defined types, naturally. Perhaps type-level strings are a good choice.
07:03:05 <dminuoso> paolino: the generic representation is basically just a leaf valued tree with nodes consisting of :+: and :*:
07:03:18 <glguy> Generic only handles one layer, all of the fields will use their normal types
07:03:56 <zxtx> dmwit, will typelevel strings help preserve nominal typing?
07:04:59 <dmwit> The question sounds weird to me. I think the answer depends on what the types of your GADT constructors look like.
07:05:40 <dmwit> You can probably make whatever (computable) equivalence relation on types you want... some relations will require more effort than others, of course.
07:06:59 * hackage boltzmann-brain 1.3.1.3 - Boltzmann sampler compiler for combinatorial systems.  http://hackage.haskell.org/package/boltzmann-brain-1.3.1.3 (mbendkowski)
07:07:42 <zxtx> I mean can I enforce that Exp (UserDefined "Maybe" Int) is the same type as Exp (UserDefined "Maybe" Int)
07:08:28 <dmwit> Did you intend to write the exact same thing twice? If so, yes, I think you will be able to enforce that.
07:09:11 <zxtx> I'm thinking about a setting where multiple definitions of Maybe, and how much can I use the type system to tell them apart or not at all
07:09:30 <dminuoso> paolino: Generic is only used to figure out the structure of that :+: / :*: tree
07:09:40 <dminuoso> paolino: But the leafs, that is the actual values, you need a Serializable instance.
07:09:51 <dmwit> If you'd like to distinguish between different definition sites, you will then of course need a type-level representation of creation sites...
07:09:56 <dmwit> (Sound familiar?)
07:10:08 <zxtx> dmwit, yep
07:10:26 <zxtx> Ok, I think I have a sense of what I need to do
07:10:30 <zxtx> thanks dmwit
07:10:38 <dmwit> yay! g'luck
07:10:58 <paolino> ok dminuoso, dmwit ,glguy , kind of make sense , thanks
07:11:10 <zxtx> next time I get stuck it'll likely involve showing code and type error messages
07:11:30 * hackage generic-random 1.2.0.0 - Generic random generators  http://hackage.haskell.org/package/generic-random-1.2.0.0 (lyxia)
07:12:53 <dminuoso> paolino: Very roughly speaking https://gist.github.com/dminuoso/375473790081d1da932751ea268fc151
07:13:22 <dminuoso> paolino: The above is a graph representation of your ADT. Generic is used to figure out how to traverse the tree. But you need actual instance Serializable Bool; instance Serializable Int; etc
07:18:05 <paolino> I see, I'm still not sure how the instances of the classes play together but the idea is great
07:18:56 <paolino> GSerializePut is introced ad hoc to use the Generic one
07:19:28 <dminuoso> paolino: the concept is actually easy to understand
07:20:30 <dminuoso> paolino: `instance (GSerializePut a, GSerializePut b) => GSerializePut ((:*:) * a b)` means "If we know how to handle both subnodes of :*:, we know how to handle :*:
07:20:59 * hackage yaml-pretty-extras 0.0.1.0 - Extra functionality for pretty printing Yaml documents.  http://hackage.haskell.org/package/yaml-pretty-extras-0.0.1.0 (locallycompact)
07:22:07 <dminuoso> paolino: `instance Serialize a => GSerializePut (K1 * i a)` means "If we have the an instance for the type of the field a, we know how to handle this node"
07:22:20 <dminuoso> *an instance Serialize
07:37:35 <chalo> hi
07:37:49 * dmwit waves
07:38:28 <chalo> has left
07:38:59 * hackage Villefort 0.1.2.11 - Villefort is a task manager and time tracker  http://hackage.haskell.org/package/Villefort-0.1.2.11 (ChrisReuter)
07:40:29 * hackage forest 0.2.1 - Tree and Forest types  http://hackage.haskell.org/package/forest-0.2.1 (ShaneOBrien)
07:41:29 * hackage yaml-pretty-extras 0.0.1.1 - Extra functionality for pretty printing Yaml documents.  http://hackage.haskell.org/package/yaml-pretty-extras-0.0.1.1 (locallycompact)
07:52:30 * hackage language-docker 6.0.0 - Dockerfile parser, pretty-printer and embedded DSL  http://hackage.haskell.org/package/language-docker-6.0.0 (lorenzo)
07:53:45 <dmwit> That `forest` package has an impressive instance list.
07:56:00 <dmwit> I wonder why it uses standalone deriving for Eq,Ord,Read,Show.
07:57:50 <dminuoso> dmwit: Can you express a deriving instance with an arbitrary context without it?
07:58:35 <dminuoso> dmwit: The GHC manual states that standalone deriving gives you more freedom, such as using FlexibleInstances with it
07:59:26 <dminuoso> % let data Foo a = Bar a | Baz String
07:59:26 <yahb> dminuoso: ; <interactive>:58:5: error: parse error on input `data'
07:59:49 <dminuoso> % data Foo a = Bar a | Baz String
07:59:49 <yahb> dminuoso:
07:59:55 <dminuoso> % deriving instance Eq a => Eq (Foo [a])
07:59:55 <yahb> dminuoso:
08:00:00 <dminuoso> % deriving instance Eq a => Eq (Foo (Maybe a))
08:00:00 <yahb> dminuoso:
08:00:26 <dmwit> % let data Tree f s a = Leaf a | Branch (f (Tree f s a)) deriving (Eq, Ord, Read, Show)
08:00:27 <yahb> dmwit: ; <interactive>:62:5: error: parse error on input `data'
08:00:33 <dmwit> % data Tree f s a = Leaf a | Branch (f (Tree f s a)) deriving (Eq, Ord, Read, Show)
08:00:33 <yahb> dmwit: ; <interactive>:63:62: error:; * Could not deduce (Eq (f (Tree f s a))) arising from the first field of `Branch' (type `f (Tree f s a)'); from the context: Eq a bound by the deriving clause for `Eq (Tree f s a)' at <interactive>:63:62-63; Possible fix: use a standalone 'deriving instance' declaration, so you can specify the instance context yourself; * When deriving the instance for
08:00:49 <dmwit> dminuoso: That does indeed seem to be the explanation. Thanks!
08:01:59 * hackage constrictor 0.1.2.0 - strict versions of many things in base  http://hackage.haskell.org/package/constrictor-0.1.2.0 (chessai)
08:04:04 <mbwgh> What is the cabal equivalent of building and running a test-suite with stack traces enabled? That is, I would like to run `stack exec -- cabal [..]`, preferrably using a sandbox or new-build.
08:05:39 <dmwit> Dunno about stack. cabal.project files let you add ghc-options to specific packages.
08:05:52 <dmwit> I don't think there's an option (yet) for adding a ghc-options for all packages.
08:07:36 <mbwgh> dmwit: The stack part probably isn't important anyway. The project contains a .cabal file. Assuming that I have tweaked it correctly, would I just run `cabal new-build` on it?
08:07:50 <dmwit> So something like `cabal new-test --ghc-options=-whatever test:whatever` if you only need the option added to the test suite itself. It's more involved if dependencies need the GHC option.
08:11:24 <mbwgh> dmwit: Yeah, the last part is kind of the point. But now that I think about it, this is all starting to become a time sink, with little for me to gain. It might be a documentation issue, or stack traces not being quite there yet. Or me being stupid.
08:11:56 <dmwit> mbwgh: Okay. If you need it for deps, you would add a cabal.project or cabal.project.local file. There's documentation online about the syntax.
08:11:59 * hackage HsOpenSSL 0.11.4.14 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.11.4.14 (VladimirShabanov)
08:15:54 <mbwgh> dmwit: I see. Although I don't intend to spend more time on this for now, thanks for pointing out .project files.
08:19:53 <mbwgh> One more question though: Could this https://ghc.haskell.org/trac/ghc/ticket/12096 have anything to do with it? I am pretty sure I saw tasty catching a `SomeException`. Maybe this causes the stack trace to stop there?
08:21:29 * hackage hsx-jmacro 7.3.8.1 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.8.1 (JeremyShaw)
08:23:43 <dyl> jle`: what about Night?
08:24:07 <dyl> Night must be co-Day right?
08:25:10 <dminuoso> > view _Just $ Just (Sum 5)
08:25:12 <lambdabot>  Sum {getSum = 5}
08:28:40 <dmwit> mbwgh: You're asking whether a feature that does not exist yet could be causing a problem for you now?
08:29:16 <dyl> I really need to get back to doing my Aluffi exercises.
08:29:24 <dyl> In a routine.
08:31:28 <mbwgh> dmwit: I am asking whether a library catching and not rethrowing SomeException might affect the visible stack trace
08:33:44 <dmwit> If it's not rethrown, I don't imagine you get a visible stack trace at all. So I'm a bit confused. But whatever you're asking I suspect you can answer it with one or two quick test programs.
08:34:38 <dmwit> I think the most likely thing is that you're incorrectly expecting to see stack traces that mention places with no `HasCallstack` constraint.
08:37:42 <mbwgh> dmwit: Okay, this is most likely it
08:45:46 <habolabo> x_x
08:45:56 <habolabo> does anyone have experience with GLFW on linux?
08:46:12 <habolabo> race condition..? :/
09:05:54 <exarkun> what do I need in an import list to get an instance definition?
09:06:33 <Cale> exarkun: Nothing.
09:06:50 <Cale> exarkun: If you only want to import instances, you can write something like  import Module.Name ()
09:07:00 <Cale> It's impossible not to import instances.
09:13:51 <lukelau> Is there a setting in Data.Aeson to encode a type data Foo = Dog | Cat as “dog” or “cat” strings?
09:14:59 * hackage gnss-converters 0.3.36 - GNSS Converters.  http://hackage.haskell.org/package/gnss-converters-0.3.36 (markfine)
09:16:02 <hexagoxel> lukelau: seems to match the description of `allNullaryToStringTag`
09:17:39 <exarkun> Cale: thanks
09:18:59 * hackage exinst 0.6 - Dependent pairs and their instances.  http://hackage.haskell.org/package/exinst-0.6 (RenzoCarbonara)
09:19:09 <lukelau> hexagoxel wow I need to read the docs better, thanks!
09:19:22 <lukelau> And I think its in the default options so I can just derive this
09:41:51 <dmj`> I have a monomorphic AST that is mutually recursive. I’d like to traverse it and construct a new value that is structurally equivalent to the shape of the original AST. How can I do this without resorting to explicit recursion? (my current approach). All the recursion schemes literature I see assumes a higher-kinded type, or force a user to define an IR that mirrors the AST (my AST is too big). Any pointers would be great.
09:44:52 <sras> In the source of GHC.TypeNats, I can see the type families that lets one to do type level arithemetic. But where are the instances for these families defined?
09:45:23 <mnoonan> dmj`: there is some template haskell you can use to get the base functor automatically from your AST, so you don't have to do the mirroring manually.
09:45:32 <glguy> sras: They aren't defined anywhere; the compiler handles them internally
09:46:49 <sras> glguy: thanks.
09:52:52 <dmj`> mnoonan: ooooh where is this defined
10:01:00 <mnoonan> dmj`: https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable-TH.html
10:01:44 <mnoonan> I was writing essentially the same thing myself as a library, went to a recent recursion-schemes for reference, and poof! there it was :)
10:03:17 <mnoonan> looks like micro-recursion-schemes has it too, if you want a smaller dependency footprint
10:13:12 <dmwit> mnoonan: neato
10:14:54 <dmwit> I wonder what it would do for `data B a = Z a | S (B (a, a))`.
10:16:08 <dmwit> Come to think of it, I wonder how DeriveFunctor handles that. It does appear to, which seems... kind of magical to me.
10:16:45 <mnoonan> my guess is it won't do polymorphic recursion, but I'm not sure.
10:17:22 <mnoonan> dmwit: agreed! I was originally going to say that it only does about as much as DeriveFunctor does, but then I saw that you can derive Functor for that type just fine, so.. ?
10:18:10 <noipmups> Hi, I have a function which returns `Either a b` and using it inside `ExceptT e IO a` monad transformer. How can I lift that returned value into that monad transformer?
10:18:40 <lyxia> noipmups: (ExceptT . return)
10:19:26 <lyxia> called liftEither in mtl
10:20:19 <quicksilver> dmwit: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor
10:20:29 <quicksilver> tl;dr : it handles tuples specially
10:21:19 <noipmups> lyxia: Thanks. Is `transformers` package just lightweight version of `mtl`?
10:21:56 <lyxia> no they do different things
10:23:22 <mnoonan> quicksilver: ah, good call. "data Pair a b = Pair a b; data B' a = Z' a | S' (B (Pair a a))" fails to derive Functor.
10:24:11 <quicksilver> yeah it's a bit odd
10:24:17 <quicksilver> I don't claim to know the thinking behind it
10:24:49 <lyxia> noipmups: Monad transformers extend a monad with new effects, whereas mtl classes provide common interfaces for those effects. It happens that transformers is the standard way to instantiate that interface.
10:25:09 <exarkun> Base32 as a type alias of ByteString seems kind of questionable, doesn't it?  This allows "safe" coercion with :: that is not really safe.
10:25:45 <lyxia> exarkun: right
10:26:41 <noipmups> laxia: Got it, thank you again.
10:30:53 <exarkun> urgh.  "undefined reference to 'bswap32'"
10:31:15 <Adluc> Hello, not sure if its such trivial problem, but does anyone have a functioning parFold ?
10:31:20 <Adluc> or any kind of parallel fold
10:33:14 <johnw> maybe what you want is mapReduce
10:33:43 <johnw> if your job can be done in two passes: one to apply some 'f' to every element, and then to monoidally combine all the results into a final avlue
10:33:57 <Adluc> johnw: exactly
10:34:09 <johnw> there is just such a function here: http://hackage.haskell.org/package/async-pool-0.9.0.2/docs/Control-Concurrent-Async-Pool.html
10:34:38 <johnw> note that it not only makes the mapping concurrent (up to N workers), it exploits the nature of monoids to make the reduction concurrent as well
10:53:11 <glittershark> Does anyone know of any existing GHC proposals to allow let-binding for type synonyms?
10:53:20 <glittershark> was just thinking about how nice that'd be with ScopedTypeVariables
10:55:00 <quicksilver> glittershark: https://ghc.haskell.org/trac/ghc/ticket/4020
10:55:20 <glittershark> oh sweet
10:56:22 <Adluc> johnw: thanks, it works :)
11:07:13 <noipmups> Does GHC has feature similar to type holes, but which will allow me to inspect type of arbitrary expression?
11:08:52 <geekosaur> just wrap the expression in ( ... expr here ... :: _)
11:09:04 <geekosaur> I don't think you need to enable PartialTypeSignatures for that
11:11:02 <noipmups> geekosaur: Works great, thank you.
11:16:07 <dminuoso> geekosaur: Wow that's pretty cool.
11:19:43 <dmj`> mnoonan: turns into a lot of TH declarations :)
11:26:30 <lyxia> glittershark: One thing you can do to approximate a let is to use a type equality:  "forall b. (b ~ foo bar baz) => b -> b -> b"  stands for  "let b = foo bar baz in b -> b -> b"
11:27:17 <exarkun> I don't get it :/ https://gist.github.com/exarkun/668fcfdf6eb585b94d72d6244be6a5d6
11:28:05 <exarkun> of course one second after posting it I do.
11:28:49 <lyxia> I don't get it https://lpaste.net/4121584499962150912
11:29:04 <lyxia> damn, that trick doesn't work for me
11:29:24 <exarkun> maybe if you keep practicing
12:03:57 <plugin> Does anyone know how I might distribute the `Maybe` in  `ColFun Maybe MyRecord` and then `fromJust` a single column while still returning the whole record?  (This is the `Frames` library though I think `vinyl` is the same).
12:05:13 <tdammers> OK so this is embarrassing: I realized what the vinyl library's name is about approximately 8 seconds ago
12:06:29 <dmj`> vinyl records… that’s so punny.
12:07:09 <tdammers> I can't complain, I named my haskell implementation of jinja, "ginger"
12:07:38 <dmj`> touché
12:08:17 <tdammers> although I do like both vinyl records and ginger as a cooking ingredient
12:13:19 <geekosaur> now I want to see if it's got a mater combinator called deejay
12:17:00 * hackage taffybar 2.1.1 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-2.1.1 (eyevanmalicesun)
12:25:03 <exarkun> when using :trace and :list do the arrows indicate the expression to be evaluated when the next :step happens or do they indicate the last expression which was evaluated?
12:43:37 <Boomerang> Has the cabal Path_ module changed in 8.4.3?
12:43:44 <Boomerang> (from 8.2.1)
12:44:07 <Boomerang> Where can I find documentation about the generated module?
12:47:28 <lyxia> I don't think there's much outside of the cabal user guide
12:47:58 <Boomerang> I'll have a look :)
12:57:43 <mxf> okay, I give up. How do I build or install happy with stack?
12:58:58 <mxf> I have tried different stack versions and snapshots, and it looks like it unlink the executable.
12:59:05 <mxf> *unlinks
13:01:51 <lyxia> mxf: doesn't "stack install happy" copy happy to some bin directory?
13:02:15 <lyxia> I see "copied executable to .../bin"
13:02:37 <mxf> I should be able to find it via `find . -name happy\*`, no?
13:02:50 <mxf> where . is either .stack-work or ~/.stack
13:03:34 <mxf> I know it's very vague
13:04:39 <lyxia> I guess that's right
13:05:10 <lyxia> what do you need happy for? what are you trying to do?
13:05:22 <mxf> okay, trying lts-11.11.
13:05:30 <mxf> I was trying to build hadrian to build ghc
13:10:36 <mxf> huh, I guess, I tried using `stack build happy && stack install happy` the whole time. For some reason that couldn't produce an executable.
13:11:25 <geekosaur> that seems odd, it should just do some extra work I think? but I think 'stack copy' in place of 'stack install' would work there
13:11:44 <mxf> I wish I could be more specific, but to be honest my nerves are wrecked, I need to get on with what I was trying to do.
13:11:55 <mxf> I will try to reproduce it tomorrow
13:12:12 <mxf> geekosaur, but build should produce a happy executable, non the less?
13:12:31 <geekosaur> it should but it will be hidden away
13:12:56 <geekosaur> stack copy "deploys" it, and "stack install" iirc is just "stack build" followed by "stack copy"
13:13:29 <geekosaur> which may mean that stack install there is skipping a step it shouldn't be (but that would be a bug, I think)
13:14:04 <geekosaur> rather, skipping a step something else inappropriately depends on (like it's tryig to copy from a private work dir instead of the install dir)
13:17:25 <mxf> geekosaur, stack build should build an executable somewhere in .stack-work, no?
13:18:03 <geekosaur> "somewhere", yes
13:18:09 <geekosaur> hm, actually, maybe not
13:18:35 <geekosaur> mrrr. no, it should, somewhere. possibly not .stack-work
13:19:26 <geekosaur> it will be somwwhere where 'stack exec' will find it
13:19:39 <geekosaur> you may be able to inspect config somewhere to find out where
13:19:56 <geekosaur> but you should not expect it to be runnable without proper setup as done by 'stack exec'
13:19:57 <mxf> I think I still have some strace outputs which I can look at tomorrow
13:20:17 <mxf> (it's late around here)
13:20:41 <geekosaur> (for example if it needs data files it may not find them if run 'blind'. or if it uses ghc in any way, which, well, it is a parser generator, it might)
13:21:05 <geekosaur> 'stack install' might or might not be better in that regard. I'd consider a wrapper script
13:21:13 <geekosaur> that uses stack exec
13:21:55 <mxf> guess I have to look at the source at some point
13:23:27 <mxf> *sigh* I wish ghc was faster. I have compiled Cabal for the umpteenth today…
13:24:18 <dmj`> mnoonan: opted for explicit bottom-up recursion, the AST is small enough, 10 TH declarations rubbed me wrong
13:25:01 <butterthebuddha> https://lpaste.net/4563066967161831424
13:25:03 <butterthebuddha> Anybody got any style feedback from my code ^
13:25:10 <butterthebuddha> (my own code starts after line 59)
13:25:53 <glguy> butterthebuddha: (\_ -> ()) <$> x   is   () <$ x     is    void x
13:26:06 <zvectorspace> mxf: `stack build && stack exec happy-exe` ?
13:26:21 <glguy> (<|>) (Parser p1) (Parser p2) =    should be      Parser p1 <|> Parser p2 =
13:26:24 <butterthebuddha> Ah. void :: f a -> f () then?
13:26:36 <mxf> zvectorspace, I will try that out tomorrow, thanks.
13:26:39 <glguy> (\c1 -> (\c2 ->     is    \c1 c2 ->
13:27:11 <mxf> geekosaur, lyxia: thanks for making me keep my sanity :)
13:28:02 <glguy> butterthebuddha: lines 70-75 can be cleaned up using do notation instead of cases on Maybe
13:28:35 <dmj`> butterthebuddha: I might rethink your parser defintion, for example, how do you handle multiple succesful parses
13:28:37 <dmj`> butterthebuddha: http://dev.stephendiehl.com/fun/002_parsers.html
13:29:52 <dmj`> butterthebuddha: the type sdiehl writes is really just StateT String [] a
13:29:58 <dmj`> @unmtl StateT String [] a
13:29:58 <lambdabot> String -> [] (a, String)
13:30:25 <dmj`> @unmtl ExceptT String (StateT String []) a
13:30:25 <lambdabot> ExceptT String (StateT String []) a
13:32:06 <mnoonan> mxf: try "stack exec -- which happy" or so
13:38:44 <fabaz> :t foldl
13:38:45 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:51:02 <nshepperd> I wrote a variadic version of asAppliedTo https://lpaste.net/1500871738857095168
13:51:16 <nshepperd> > :t unApply (apply fmap undefined (undefined :: Either Int a))
13:51:19 <nshepperd> :: (a -> b) -> Either Int a -> Either Int b
13:51:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
14:31:06 <dminuoso> dmj`: Stehen really needs to fix some of the bugs in there.
14:57:22 <mbwgh> Does anybody know where you can learn more about parsing vs. lexing in a Haskell context? Most of what I can find about it is either purely theoretical, or concerned with technologies like lex and yacc, or using regexp while rolling your own FSA or something about that. How does the distinction play together with parser generators like megaparsec? In the context of happy-go-lucky casual parsing, not
14:57:28 <mbwgh> defining your own programming language or something like that.
14:57:39 <mbwgh> *something like that
14:58:53 <replay> mbwgh: https://leanpub.com/alexandhappy
14:59:56 <qqwy> mbwgh: The difference between lexing and parsing is a lot less necessary in a parser combinator than it is in a parser generator
15:00:08 <geekosaur> happy is probably not the way to go for casual parsing. you can think of megaparsec as being a more verbose (and far more readable) regex
15:00:26 <qqwy> Lexing is using a 'dumb parser' to reduce the complexity (both the mental as well as the computational one) of the 'smart' _real_ parser.
15:00:43 <geekosaur> ^ pretty much
15:01:23 <glguy> Lexing is still pretty handy when using parser combinators. It can result in simpler to understand parser code, parser logic, and error messages
15:01:24 <EvanR> tokenize
15:01:50 <glguy> megaparsec makes it harder than it is with parsec, but it's still possible
15:01:57 <EvanR> i still dont fully understand where tokenization comes in when space matters
15:02:27 <EvanR> or sometimes matters
15:02:40 <geekosaur> it was inda a hack for the way pdp11 memory management worked
15:03:01 <qqwy> Yes, lexing in the sense of 'tokenization' might still be useful in a parser combinator setting because it makes it easier to write out e.g. clear pattern matches
15:03:02 <geekosaur> you could run the tokenizer phase and give it all of address space, then 'swap it out' and run the parser phase on the result
15:03:33 <qqwy> (you restrict the number of possible inputs from 'all possible strings' to 'all possible tokens')
15:04:12 <geekosaur> which why lex and yacc exist; that separation was the only way to fit a full compiler into a process's address space. (think x86 small model, but this took advantage of a set of architecture specific hacks)
15:04:38 <qqwy> EvanR: I expect in the same way that Symbols/Atoms are more space efficient than strings.
15:04:44 <mbwgh> Could you perhaps give an example of what thinking in terms of lexing/tokenizing and parsing what look like for something that is typically done in a more ad-hoc manner using combinators?
15:04:55 <geekosaur> and then your parser gets things like <keyword:foo> <string> <number> already processed for it instead of having to recognize them itself
15:05:02 <EvanR> qqwy: erm what. i mean, whitespace
15:05:18 <geekosaur> and you concentrate on what the language structure is instead of the textual representation of e.g. strings
15:05:33 <qqwy> EvanR: What geekosaur says here ^
15:05:35 <qqwy> is what I mean
15:05:43 <qqwy> (but his sentence is probably more clear :p )
15:05:53 <EvanR> im just not sure what youre responding to
15:06:05 <EvanR> "the same way..." what  ...
15:06:08 <qqwy> Ah
15:06:09 <qqwy> ...
15:06:35 <qqwy> I see. I was indeed thinking you were referring to 'space' as in (not having much) RAM or ROM space.
15:06:49 <geekosaur> so was I
15:06:53 <EvanR> the final frontier
15:06:58 * qqwy grins
15:07:05 <geekosaur> whitespace is a different thing, but handled similarly, just less real gain by doing so
15:07:09 * qqwy goes boldly where no man has gone before
15:07:27 <geekosaur> it's the more complex stuff like numbers that can have multiple formats (3, 0.1, 7e6, etc.)
15:07:46 <geekosaur> and the lexer deals with that so the token-based parser doesn't need to care
15:07:56 <geekosaur> it just has to know <number> tokens
15:07:56 <EvanR> > map read ["3","0.1","7e6"] :: [Scientific]
15:07:59 <lambdabot>  error:
15:07:59 <lambdabot>      Not in scope: type constructor or class ‘Scientific’
15:08:03 <EvanR> fruitsticks
15:14:53 <mbwgh> Ok, but if a lexer is just a "dumb"/"pre" parser, why this what it seems like a strict two-phase distinction? Why not three, or an n-depth parser stack system?
15:15:16 <EvanR> hysterical raisens
15:15:22 <glguy> Because 2 phases works well in practice for many languages
15:15:31 <glguy> sometimes a 3 phase works well, lexing, layout, parsing
15:16:01 <mbwgh> So the two-phase system is just the "most formalized"?
15:16:14 <mbwgh> And practical
15:17:00 <EvanR> there is no theoretical difference between parsing the token stream and parsing the character stream directly
15:17:06 <geekosaur> it's a tradeoff that works well in general
15:17:11 <EvanR> its the same thing
15:17:17 <EvanR> parsing
15:17:18 <geekosaur> and solved memory problems back in the 70s/80s
15:17:33 <geekosaur> these days it matters less, but since the tech is already nature it's still used a lot
15:17:37 <geekosaur> *mature
15:17:47 <geekosaur> it's well understood, etc.
15:18:08 <EvanR> lexers give people an excuse to use regex
15:18:23 <EvanR> since the pattern for tokens is probably not a bad regex
15:18:39 <geekosaur> and because on unixes you have both regex and 2-stage parsing around, and the first stage historically was done with regexes (lex)
15:18:52 <geekosaur> so you see both being used, and regex abused for simple parsing
15:19:03 <EvanR> but then again... nested string literals....
15:19:25 <geekosaur> then in haskell you see branching out to parser combinators, and in perl you see regex evolving toward egneral parsing (perl 5's /x and perl 6's grammars)
15:19:41 <mbwgh> Are there some rules of thumb concerning the level of complexity that mandates this? For instance, there are distinctions like chomsky levels of regular, context-free, context-sensitive and unrestricted grammers, which seems very formal. But I kind of get the feeling that regarding the lexing/parsing distinction, it (nowadays) seems to boil down to a matter of taste
15:19:45 <EvanR> "hello #{ puts "world" }"
15:20:20 <geekosaur> it used to be process memory concerns, these days it's largely what one is confortable with
15:20:29 <geekosaur> they're equivalent in expressiveness
15:20:39 <geekosaur> they just shuffle around where various things happen
15:21:26 <mbwgh> Sounds a little like thinking in terms of top-down or bottom-up
15:22:47 <geekosaur> if you want to tink fit that way, 2-level parsers require a bottom-up level and a top-down level, otherwise it's alll the same level with no well defined top or bottom
15:23:00 <geekosaur> which can help you structure things, which is why 2-level tends to help error reporting
15:23:32 <geekosaur> (but it can also hurt it unless you carry extra information around: you tend to lose what the programmer actually wrote when you turn it into a fixed token)
15:23:59 * hackage bioinformatics-toolkit 0.5.1 - A collection of bioinformatics tools  http://hackage.haskell.org/package/bioinformatics-toolkit-0.5.1 (kaizhang)
15:25:23 <mbwgh> What would a token actually look like in Haskell. A sum type ala `data Token = Identifier X | Keyword Y` ? And would X/Y again be types, or just the literal string that was consumed?
15:25:50 <iqubic> Depends on what you want to do I suppose
15:26:26 <EvanR> identifiers tend to be strings
15:26:47 <EvanR> keywords are fixed symbols
15:27:25 <geekosaur> it could be that, it could be something else
15:27:44 <geekosaur> I think there's some discussion in the happy documentation about what works best with it when used with alex
15:27:55 <geekosaur> and it's usually a sum type iirc
15:28:21 <iqubic> geekosaur: A sum type was suggested.
15:28:46 <geekosaur> in lex/yacc it's a union with an external tag
15:28:55 <dmj`> dminuoso: which ones?
15:30:14 <mbwgh> The concrete example I am currently interested in is parsing email headers and sorting out my messed up maildir. I feel that megaparsec is overkill, but hey, I can learn something. I definitely don't think I need alex/happy for this. The format is probably strictly regular anyway. But what would tokens be in this context? Say, I only want to extract To/From information for simplicity?
15:30:42 <EvanR> megaparsec is easy to deploy for simple stuff
15:30:58 <EvanR> if youre comfortable with it. not sure what overkill means here
15:31:15 <mbwgh> I actually thought I had implemented most of it, but now that I have to refactor I hate every single line I wrote :(
15:31:19 <geekosaur> happy would be overkill. one advantage of parsec / megaparsec is that it scales
15:31:36 <EvanR> regex is overkill in terms of technology being leveraged for many tasks... but its built in so probably doesnt get labeled that much :)
15:31:37 <mbwgh> Overkill in the sense that I could probably have used regex-applicative
15:32:06 <mbwgh> Or use some other regex package, and yolo the rest via string splitting on lines etc.
15:32:17 <EvanR> regex is light weight, parser combinators is overkill?
15:32:36 <geekosaur> regex is lightweight in terms of library size, heavy in terms of cognitive overhead, imo
15:32:57 <geekosaur> parser combinators (including regex-applicative in at least some usage styles) often strike a nice balance there
15:34:52 <mbwgh> Ok, then it's not overkill. It's just that I still have to get comfortable with it. I've worked through a few Parsec tutorials when I started learning Haskell, but forgot the lot of it because I never needed it. The concepts are easy, but I have gotten myself into infinite loops via nested manys a few times. I'm sure once I get the hang of it, I would be more reluctant to call it overkill.
15:35:51 <geekosaur> keep in mind parsec has evolved as well
15:36:12 <geekosaur> I mean, large chunks of what back when were parsec tutorial are now applicative tutorial
15:36:17 <mbwgh> I have implemented my unit tests, and want to start iteration two. I thought maybe I should introduce lexing, but wouldn't know what this should look like here
15:37:09 <EvanR> "left recursion" is still tricky
15:37:15 <EvanR> as in yacc
15:37:44 <mbwgh> I don't have a bias against Parsec. But the libraries are supposed to be similar anyway, so I don't see much reason to switch now
15:38:09 <EvanR> megaparsec is like a modernized streamlined parsec
15:38:19 <EvanR> i think parsec is not being worked on anymore?
15:38:46 <mbwgh> I believe there was a new release at the end of last year or so, maybe even only a few months ago.
15:38:50 <EvanR> megaparsec docs claim that you dont even need attoparsec anymore
15:39:29 * hackage invertible-grammar 0.1.0 - Invertible parsing combinators framework  http://hackage.haskell.org/package/invertible-grammar-0.1.0 (EugeneSmolanka)
15:52:51 <mbwgh> geekosaur: Where can I read more about what you said that lexing historically was a necessity in the 70s? Tried to google it
15:53:10 <geekosaur> you probably want to look at the history of lex and yacc
15:53:44 <geekosaur> since they were developed speciifcally to fit parsers into pdp11 split-I-and-D address space
15:54:57 <mbwgh> You've been around, right?
15:56:08 <mbwgh> I think I found something. Thanks
16:00:29 * hackage sexp-grammar 2.0.0 - Invertible grammar combinators for S-expressions  http://hackage.haskell.org/package/sexp-grammar-2.0.0 (EugeneSmolanka)
16:03:34 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/11-applicative2.pdf
16:03:41 <butterthebuddha> I'm working on implementing "zeroOrMore"
16:04:10 <butterthebuddha> I'm not sure how to work with the call to oneOrMore to add a check for Nothing though :/
16:07:27 <butterthebuddha> Considering I'm not allowed to use details of the Parser type
16:11:28 <glguy> butterthebuddha: You'll use <|> to provide alternate behaviors to be used if a parser fails
16:12:21 <glguy> The "hint" to the right tells you almost exactly what the code will look like
16:39:21 <butterthebuddha> glguy: I'm not sure how to construct a parser that always returns the empty list given what I have
16:39:39 <glguy> Use the Applicative instance
16:41:42 <butterthebuddha> Ah of course
17:37:02 <exarkun> where is NoSuchThing defined
17:39:39 <lyxia> @hoogle NoSuchThing
17:39:39 <lambdabot> System.IO.Error.Lens _NoSuchThing :: Prism' IOErrorType ()
17:42:24 <tabemann> question
17:42:35 <geekosaur> confusing pedanticism
17:42:37 <tabemann> are values given by typeOf comparable across different machines?
17:43:23 <tabemann> like let's say I use typeOf to get a representation of a value's type and package it along with data generated with Binary and push it out across a socket
17:43:51 <tabemann> can someone on the other end compare the type they are expecting with the value I sent via typeOf?
17:44:04 <tabemann> to confirm that the data I sent is actually the data they are expecting
17:45:21 <tabemann> anyone?
17:46:51 <geekosaur> I have no answer and would like to hear one since we have a quasi-related issue open in xmonad (this against changes across compiler versions, or even compiles)
17:47:16 <nshepperd1> Seems unlikely
17:48:02 <tabemann> in my case I can assume that the binaries running on each machine are identical
17:48:38 <tabemann> because things will break horribly for other reasons anyways if one attempts to do it with mismatched versions
17:48:55 <exarkun> lyxia: So it doesn't exist at all?
17:48:56 <nshepperd1> First, are TypeReps even serializable?
17:49:15 <exarkun> lyxia: I did ask Hoogle first.  It returned no results, not even the _DoesNotExist result.
17:49:24 <exarkun> er _NoSuchThing
17:49:31 <geekosaur> via Show but that's where xmonad gets in trouble since the Show instance doesn't help usually
17:50:00 <geekosaur> exarkun, which hoogle did you ask? there's two: one with old database but working type search, one with new database but broken type search
17:50:27 <exarkun> geekosaur: :(
17:50:38 <geekosaur> and then there's the stackage bhoogle search
17:50:39 <exarkun> I asked https://www.haskell.org/hoogle
17:50:41 <geekosaur> *hoogle
17:50:41 <exarkun> which is that?
17:50:43 <tabemann> I use hayoo
17:50:44 <geekosaur> that's the old db
17:50:49 <geekosaur> may not have lens in it
17:50:55 <geekosaur> hoogle.haskell.org is the newer one
17:51:01 <exarkun> okay I don't think the lens result is relevant anyway
17:51:17 <geekosaur> and I also like hayoo but it gets confused by package updates sometimes
17:51:45 <exarkun> I am lhttps://hackage.haskell.org/package/directory-1.3.2.2/docs/System-Directory.html#v:listDirectory says "NoSuchThing"
17:51:49 <exarkun> I just want to handle that case
17:52:07 <exarkun> I eventually went with `tryJust (Just . isDoesNotExistError) $ listDirectory storageIndexPath`
17:53:01 <tabemann> screw it
17:53:07 <tabemann> I'm not gonna fuck with Typeable
17:53:22 <tabemann> I'm just going to assume that both sides can use Binary like adults
17:54:30 <tabemann> because I might want to have similar but still slightly heterogeneous versions on different nodes
17:54:52 <tabemann> which might still work if both sides are using Binary with the right types
17:54:56 <geekosaur> exarkun, I am guessing it's a win32 error and goes missing because all the doc builders are linux
17:55:14 <tabemann> but likely will break if I use typeOf
17:57:27 <tabemann> yay you can derive Binary! (I thought this was true, but I just confirmed that it is)
17:59:51 <exarkun> geekosaur: huh, ok
18:00:12 <geekosaur> actually I'm trawling ghc source, that may be wrong
18:00:38 <geekosaur> it's the lowest level error type, which you normally don't work with directly
18:01:10 <geekosaur> the higher level interface is testing the raw Exception value with e.g. isDoesNotExistError
18:19:17 <rasusto> If I'm working inside the `List` monad, I'm able to express a `List` with a single item `a`, using `return a`. Is there anyway that I can express an empty `List` using `return`?
18:20:16 <mniip> rasusto, not with monadic operations
18:20:24 <mniip> you need Alternative or MonadPlus
18:20:34 <mniip> empty and mzero respectively
18:21:50 <rasusto> Is it considered best practice to use `return a` over `[a]` whenever possible?
18:22:18 <mniip> if you're in a do-block, yes
18:23:03 <rasusto> thanks, mniip
18:33:21 <CuriousErnestBro> hello
18:37:55 <Axman6> o/
18:47:12 <Gonz4> :t map
18:47:13 <lambdabot> (a -> b) -> [a] -> [b]
18:52:29 * hackage serverless-haskell 0.5.2 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.5.2 (AlexeyKotlyarov)
19:01:43 <EvanR> % :t map
19:01:43 <yahb> EvanR: (a -> b) -> [a] -> [b]
19:01:57 <EvanR> what is this monomorphic CRAP
19:03:21 <Axman6> just use traverse like a real programmer
19:04:18 <mniip> EvanR, fmap :: (Functor f, Category (Cod f), Category (Dom f)) => Dom f a b -> Cod f (f a) (f b)
19:07:41 <dmj`> cool homomorphism bro
19:26:29 <mniip> dmj`, no homo
19:32:52 <chalin> :t sum
19:32:54 <lambdabot> (Num a, Foldable t) => t a -> a
19:34:54 <dmj`> mniip: my bad
20:53:30 * hackage ShellCheck 0.5.0 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.5.0 (vidarhol)
21:24:00 * hackage espial 0.0.1 - Espial is an open-source, web-based bookmarking server.  http://hackage.haskell.org/package/espial-0.0.1 (jonschoning)
21:34:08 <ddellacosta> is there a more general form of takeWhile I can use for monadic or applicative values? like `(Applicative f, Foldable t) => (f a -> Bool) -> t (f a) -> t (f a)`
21:34:26 <dminuoso> ddellacosta: liftA2
21:36:03 <ddellacosta> dminuoso: hmm, not quite seeing it
21:37:28 <dminuoso> :t liftA2 takeWhile
21:37:30 <lambdabot> Applicative f => f (a -> Bool) -> f [a] -> f [a]
21:38:01 <suzu> :t takeWhile
21:38:02 <lambdabot> (a -> Bool) -> [a] -> [a]
21:38:26 <dminuoso> ddellacosta: Also take note of the subtle mistake you made, a function of the signature with `Applicative f => f a -> Bool` can't exist
21:38:48 <ddellacosta> dminuoso: good point! That may be why I'm having trouble with this
21:38:48 <suzu> why not? const True
21:39:02 <suzu> though it doesnt do the right thing. lol
21:40:01 <dminuoso> suzu: I just informally assumed he actually wanted it to do something useful, and not an arbitrarily restricted version of `const True` =)
21:40:12 <suzu> :P
21:40:21 <iqubic> So today I learned that bifunctors are basically the greatest thing ever,
21:40:23 <ddellacosta> so, then, I still need it swapped like: Applicative f => f (a -> Bool) -> [f a] -> [f a]
21:40:37 <suzu> what'd you solve with a bifunctor today?
21:40:43 <dminuoso> iqubic: You may be ready to look at profunctors then.
21:40:47 <ddellacosta> but now I'm not sure that makes much sense
21:40:48 <dminuoso> bifunctors are boring.
21:40:59 <iqubic> dminuoso: profunctors are great.
21:41:04 <suzu> profunctor
21:41:11 <suzu> thats the bifunctor where the second map is backwards?
21:41:17 <iqubic> The only profunctor I know is (->).
21:41:18 <suzu> contravariant iirc
21:41:18 <dminuoso> suzu: Yeah
21:41:46 <iqubic> Are there other useful profunctors besides (->)?
21:42:09 <iqubic> Because dimap with (->) is like a long pipeline.
21:42:25 <dminuoso> iqubic: Monad m => Profunctor (Kleisli m) comes to mind
21:42:40 <iqubic> How is that a profunctor?
21:43:15 <dminuoso> iqubic: if `_ -> _` is a profunctor, then so is `(Monad m) => _ -> m _`
21:43:36 <suzu> why?
21:43:49 <iqubic> Kleisli is the one that implements "(>=>) :: (a -> m b) -> (b -> m c) -> a -> m c" right?
21:43:52 <dminuoso> :t putStrLn
21:43:53 <lambdabot> String -> IO ()
21:44:03 <suzu> how do you guys know all this shit
21:44:10 <suzu> is there some big cat theory thing i'm missing
21:44:12 <dminuoso> iqubic: right
21:45:00 <iqubic> String -> IO () is only a contravarient functor at best.
21:45:08 <iqubic> I can't see how it would be anything else.
21:45:30 <dminuoso> iqubic: `putStrLn` - make that produce 10 as a result without changing its behavior.
21:46:03 <iqubic> \x -> putStrLn x >> return 10
21:46:07 <iqubic> done.
21:46:45 <iqubic> Is that what you were expecting?
21:47:46 <iqubic> Wait... That shows that String -> IO () is a profunctor.
21:47:57 <iqubic> But I knew that already.
21:48:01 <dminuoso> iqubic: Strictly speaking no
21:48:09 <iqubic> What? No to what?
21:48:11 <dminuoso> iqubic: For the same reason that `Maybe Int` is not a functor
21:48:16 <dminuoso> It's `Maybe` itself that is the functor
21:48:16 <iqubic> Oh. I see.
21:48:39 <iqubic> I already knew that (->) was a profunctor. What were you tryin to show me?
21:49:15 <dminuoso> :t Kleisli
21:49:16 <lambdabot> (a -> m b) -> Kleisli m a b
21:49:33 <dminuoso> newtype Kleisli m = Kleisli { runKleisli :: a -> m b }
21:49:51 <dminuoso> iqubic: Sometimes you call things of that shape kleisli arrows
21:50:16 <iqubic> Sure. I understand that. What is exciting about that?
21:50:44 <dminuoso> iqubic: They form a category.
21:50:50 <iqubic> And >=> is a composition of Kleisli arrows.
21:51:05 <iqubic> dminuoso: I suppose that is true. What is your point there?
21:51:26 <dminuoso> iqubic: They form profunctors?
21:51:42 <iqubic> How do you know that?
21:52:15 <iqubic> Oh, actually that's just a special case of (->). Nothing to fancy there.
21:52:17 <dminuoso> iqubic: Because Hom(_, _) is a profunctor
21:52:30 <dminuoso> And if these kleisli arrows form a category, that follows trivially
21:52:40 <iqubic> What is Hom(_, _) again?
21:52:57 <platz> i heard Hom might be some kind of fish egg once
21:53:18 <platz> Eric Meijer has a way with words
21:53:42 <dminuoso> iqubic: Hom(A, B) is the set of morphisms between two objects A and B in a locally small category.
21:53:55 <dminuoso> iqubic: We express this concepts as `A -> B` in Haskell.
21:54:07 <iqubic> Oh, right.
21:54:11 <dminuoso> the type `Int -> Bool` is the set of all functions going from A to B
21:54:26 <iqubic> Where A is Int and B is Bool.
21:54:32 <dminuoso> Oh right
21:54:53 <iqubic> You seem shocked.
21:55:49 <dminuoso> iqubic: From that notion two Hom functors arise, namely Hom(A, _) and Hom(_, B)
21:56:12 <iqubic> Isn't that what defines a functor?
21:56:20 <dminuoso> no, they are particular functors
21:56:25 <iqubic> I see.
21:56:27 <dminuoso> they are functors that talk about hom sets
21:56:48 <iqubic> So it's a functor from one catagory to another?
21:56:51 <Eduard_Munteanu> A functor is a map between categories, not objects.
21:57:03 <iqubic> Yeah. That's right.
21:57:14 <butterthebuddha> https://github.com/bitemyapp/fp-course/blob/master/src/Course/Applicative.hs
21:57:28 <butterthebuddha> I'm not sure what "*>" is supposed to do
21:57:34 <dminuoso> iqubic: If you take Hom(A, _) in arbitrary category C
21:57:42 <dminuoso> (locally small)
21:57:57 <dminuoso> That is, fix on some object A
21:58:11 <iqubic> That's a mapping from from A to anyother object? Right?
21:58:19 <dminuoso> Not quite
21:58:34 <iqubic> What does Hom(A, _) mean?
21:58:52 <dminuoso> iqubic: That's the name of the functor C -> Set
21:58:52 <Eduard_Munteanu> Hom(A, -) is the category of arrows from A to any object.
21:59:18 <dminuoso> iqubic: Basically you fix some object A in C. It does not matter which, you can pick any.
21:59:26 <dminuoso> From then you then start building hom sets with all other objects
21:59:39 <Eduard_Munteanu> (yes, arrows as objects)
22:00:07 <iqubic> I see. So it's a catagory that contains as objects all the morphisms from A to _?
22:00:19 <dminuoso> iqubic: No, it's the category Set.
22:00:46 <iqubic> So why are we referring to it as Hom(A, _)?
22:01:01 <butterthebuddha> Are we talking about slice categories?
22:01:16 <iqubic> I'm not sure *what* we are talking about.
22:01:32 <Eduard_Munteanu> Not really.
22:01:51 <butterthebuddha> From the description above, it seems Hom (A, -) is notation for the slice category of an object A in some category
22:01:57 <dminuoso> iqubic: A functor is a composition preserving mapping of objects and morphisms between categories right?
22:02:19 <dminuoso> iqubic: So in order to make that mapping, you need to find some way to map all objects from C to some objects in Set, and all morphisms in C to some morphisms in Set.
22:02:24 <dminuoso> In such a way that compositionality is maintained
22:02:34 <iqubic> Yes. That is right. A functor maps objects from C to objects in D.
22:02:42 <dminuoso> iqubic: In our case D = Set
22:03:12 <iqubic> What is Set? Is that the catagory of all valid Haskell types, barring bottom?
22:04:20 <dminuoso> Hask can be thought of a subcategory of Set I think
22:04:23 <butterthebuddha> iqubic: the category where the objects are sets and the morphisms are functions between the sets
22:04:25 <Eduard_Munteanu> Set is the category of sets with functions between them.
22:04:42 <butterthebuddha> Honestly, I wouldn't try to learn category theory unless you know _a lot of_ algebra
22:04:56 <dminuoso> butterthebuddha: Nah. You can learn this stuff relatively easily witohut any algebra
22:05:00 <dminuoso> You just need to know what a monoid is :P
22:05:03 <butterthebuddha> You don't really appreciate what anything really means
22:05:21 <iqubic> Doesn't Set form a monoid?
22:05:37 <butterthebuddha> iqubic: you deeply misunderstand what monoid means
22:05:56 <butterthebuddha> A monoid is a set paired with an associative binary operation that has an identity
22:06:09 <iqubic> That's what I thought it was.
22:06:18 <butterthebuddha> A priori, a "set" is not a monoid
22:06:32 <iqubic> Right. That makes sense.
22:06:53 <butterthebuddha> It's a monoid in the context of a binary operation; the same set can form multiple monoids
22:07:17 <dminuoso> iqubic: A category can be thought of as a relaxed kind of monoid in where not all functions compose.
22:07:51 <butterthebuddha> dminuoso: how so, I'm confused?
22:08:19 <Eduard_Munteanu> With respect to function composition.
22:08:35 <dminuoso> butterthebuddha: A monoid is a special case of a category.
22:08:37 <Eduard_Munteanu> Identity arrows being identity elements.
22:09:03 <Eduard_Munteanu> Some used to call categories monoidoids. ;)
22:09:24 <butterthebuddha> Ah, of course
22:11:24 <Eduard_Munteanu> s/function/arrow/
22:12:17 <dminuoso> This is even reflected in Haskell
22:12:20 <butterthebuddha> I'm trying to implement "*>" as an exercise, but I don't understand what it actually does. Can someone explain that?
22:12:21 <dminuoso> We have an `instance Monoid (Endo a)`
22:12:39 <dminuoso> :t (*>)
22:12:40 <lambdabot> Applicative f => f a -> f b -> f b
22:12:47 <dminuoso> :t (<*>)
22:12:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:12:56 <dminuoso> butterthebuddha: Would it help if I told you its a specialized form of <*>
22:13:36 <Eduard_Munteanu> It's like (<*>) but it "ignores" what's on the left.
22:13:55 <butterthebuddha> That makes it sound you would just return the right argument
22:14:04 <dminuoso> butterthebuddha: Not quite!
22:14:04 <butterthebuddha> Which is obviously incorrect
22:14:15 <dminuoso> butterthebuddha: but lets take that appraoch. What would that function be called?
22:14:17 <Eduard_Munteanu> Well, perhaps it makes more sense to think about (<*) first.
22:14:48 <iqubic> So I know what a functor is. What is the point of teaching about functors?
22:15:02 <dminuoso> iqubic: Bread and butter of category theory
22:15:19 <iqubic> Right. I know that. Now, what is Hom(A, -)?
22:15:43 <Axman6> butterthebuddha: print True *> print False should print out "True\nFalse" - ie, it should make the effects of the first argument happen but oinly return the result of the second (as well as having its effects occur)
22:15:45 <iqubic> :t fmap
22:15:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:16:07 <butterthebuddha> iqubic: from a math perspective, functors were born in algebraic toplogy; from a haskell perspective, they're a simple generalization of the "map" function for lists
22:16:08 <iqubic> Technically that's an Endofunctor from Hask -> Hask
22:16:28 <hololeap> iqubic: hom-functor paramatized with A... or Reader A in haskell
22:16:29 <dminuoso> butterthebuddha: A function that disregards the first argument is called `const` - and what you are looking for is an effectful const. Think of it as an applicative const.
22:17:14 <dminuoso> :t const
22:17:16 <lambdabot> a -> b -> a
22:17:18 <dminuoso> :t (*>)
22:17:19 <lambdabot> Applicative f => f a -> f b -> f b
22:17:25 <dminuoso> :t const id
22:17:26 <lambdabot> b -> a -> a
22:17:27 <iqubic> hololeap: I see. So "Hom(A, -)" is basically ((->) a)?
22:17:30 <dminuoso> :t flip const
22:17:31 <lambdabot> b -> c -> c
22:17:44 <dminuoso> iqubic: Yes.
22:17:52 <iqubic> Oh, I see.
22:18:17 <dminuoso> iqubic: Hom(B, -) is just `(Op a)`
22:18:37 <butterthebuddha> I don't understand: how do I actually "apply" the inputs
22:19:24 <iqubic> So if I'm understanding things correctly a Bifunctor is the cartesian product of the catagories C and D. Basically C*D=E for some catagories C, D, and E.
22:20:04 <Eduard_Munteanu> C x D -> E
22:20:24 <dminuoso> iqubic: Now what I described is finally a non-endo functor
22:20:31 <dminuoso> iqubic: Namely a functor from Kleisli to Hask
22:20:44 <iqubic> What was that again?
22:21:15 <iqubic> the "_ -> m _"?
22:21:26 <Eduard_Munteanu> @src Kleisli
22:21:26 <lambdabot> Source not found. Maybe you made a typo?
22:21:42 <Eduard_Munteanu> Bleh, newtype Kleisli m a b = Kleisli (a -> m b)
22:22:03 <iqubic> I get that.
22:22:45 <dminuoso> iqubic: The relevant point is, Hom(-, -) is not (->), and Hom(A, -) is not ((->) A)
22:22:55 <dminuoso> Its only when your source category is Hask
22:22:57 <dminuoso> but it doesnt have to be
22:23:11 <iqubic> Right. The mapping operation can be whatever you want it to be.
22:24:12 <dminuoso> iqubic: The cool thing about the hom functors is that they can map any locally small category to set. You get a covariant functor, a contravariant functor and a profunctor each time.
22:24:25 <dminuoso> *to Set
22:24:30 <iqubic> How so?
22:25:17 <Eduard_Munteanu> I can see how I was confusing people above with one statement about Hom, but nevermind.
22:25:43 <Axman6> butterthebuddha: to walk throught his a bit, let's start with what you  know about *>; does it have any particular constraints?
22:26:12 <Axman6> through this*
22:26:19 <dminuoso> iqubic: The recipe is exactly the same as ((->) A)
22:26:33 <dminuoso> iqubic: Just dont think in terms of function composition, think in terms of morphisms.
22:26:48 <Eduard_Munteanu> iqubic, Hom is contravariant in the first argument and covariant in the second.
22:27:11 <iqubic> Oh, right.
22:28:54 <dminuoso> iqubic: It might be helpful to pick some category other than Hask you are comfortable with
22:29:04 <dminuoso> and work out the Hom functor(s) on paper
22:29:32 <iqubic> What other catagories are there?
22:32:11 <Eduard_Munteanu> Hask-based, there's Kleisli m for a monad m. Outside Haskell, there are many categories, like Set, Mon, Vect etc.
22:32:28 <Eduard_Munteanu> (*Vect_K for some field K)
22:33:11 <mathZ> After installing haskell-mode, M-x run-haskell reports it canot find hugs. But i want to run ghci not hugs.
22:33:39 <iqubic> If kleisli m is a catagory than what are the morphism and identity function?
22:33:48 <Eduard_Munteanu> You also have newtype Op a b = Op (b -> a), which is Hask^op.
22:34:05 <dminuoso> iqubic: Assume `f` is a functor
22:34:42 <Eduard_Munteanu> iqubic, the identity arrow is return
22:35:16 <dminuoso> iqubic: In `Kleisli m` objects are still types from Hask, but morphisms are kleisli arrows.
22:35:31 <dminuoso> For some functor m (the fact that you obtain a category updates that functor to monad)
22:35:42 <iqubic> And the morphisms are "(>=>) :: (a -> m b) -> (b -> m c) -> a -> m c"?
22:36:13 <Eduard_Munteanu> (<=<) is composition, if that's what you mean.
22:36:23 <dminuoso> iqubic: `a -> m b` is mapped to `a ~> b` in (Kleisli m)
22:36:48 <dminuoso> Here I used ~> to denote a morphism in )Kleisli m)
22:37:09 <iqubic> Eduard_Munteanu: (<=<) = flip (>=>) right?
22:37:16 <Eduard_Munteanu> Yes.
22:37:28 <dminuoso> :t return
22:37:30 <lambdabot> Monad m => a -> m a
22:37:33 <iqubic> dminuoso: I actually defined kleisli for Maybe the other day.
22:37:43 <iqubic> Want to see that?
22:38:45 <butterthebuddha> Axman6: I'm not sure what you mean by "constraints"
22:39:15 <iqubic> https://lpaste.net/7379721384760442880
22:39:38 <butterthebuddha> My biggest confusion is with the fact that this is supposed to represent the "application" of the particular object I'm dealing with, even though it's not a function
22:40:15 <iqubic> https://lpaste.net/382854170744455168
22:40:28 <iqubic> So that works. I'm not sure what else there is to learn.
22:43:03 <iqubic> Interesting side note: A Sum type can also be called a Coproduct type.
22:43:25 <iqubic> (a, b) -> a, (a, b) -> b
22:43:39 <iqubic> a -> Either a b, b -> Either a b
22:44:13 <iqubic> Note that the arrows are turned around, and the names changed to get from one to the other.
22:47:16 <dminuoso> iqubic: Bartosz recorded lectures are pretty good if you haven't checked these out yet (because its clear that you are at least reading his material)
22:48:04 <iqubic> dminuoso: Is he the one that did the "Crash Course on Cat Theory" lecture? I think I've actually seen part of that.
22:48:29 <dminuoso> iqubic: No. It's a rather long series of actual lectures.
22:48:43 <iqubic> Oh. I see.
22:48:45 <hololeap> speaking of... do ends and coends have any practical applications to haskell, because my eyes have been glazing over in that section of the book
22:48:50 <dminuoso> iqubic: https://www.youtube.com/watch?v=I8LbkfSSR58 it starts there
22:49:28 <dminuoso> iqubic: I found them to be more approachable than his reading material since I dont have a mathematical background.
22:49:44 <dminuoso> He made Yoneda so simple. :o)
22:51:05 <iqubic> Yoneda?
22:51:25 <hololeap> Yoneda's lemma
22:51:41 <iqubic> I'll have to look at that later I suppose.
22:54:39 <hololeap> i like to hop over to a "hardcore" CT resource (like nLab) while looking at his material, just to see how much i understand and get myself more comfortable with the more formal notation
22:54:45 <jesyspa> hololeap: I recently used Kan extensions, which are based on ends and coends, to construct a certain monad.
22:54:58 <iqubic> What monad?
22:55:11 <hololeap> right... Kan extensions do require ends and coends... that is a motivation to learn them
22:55:24 <nshepperd> kliesli... it's the fish category!
22:55:40 <iqubic> Yes.
22:55:47 <nshepperd> a school of compositions: >=> >=> >=>
22:56:02 <jesyspa> iqubic: Given a J-indexed monad M and a function I -> J, I constructed an I-indexed monad that can be seen as a reindexing of M.
22:56:29 * hololeap zones out
22:56:30 <jesyspa> If you recognise any classical construction in this, please tell me, by the way. :D
22:56:31 <iqubic> That sounds hard.
22:57:15 <dminuoso> hololeap: nlab is really extreme
22:57:36 <dminuoso> hololeap: I hear that even mathematicians sometimes have a hard time reading it :P
22:57:49 <hololeap> it is extremely exteme, but i'm surprised with how much i can understand now... granted, it's like 10% of it, but more than i would expect
22:58:50 <hololeap> well, 10% of the articles that i even recognize the names of
22:59:07 <iqubic> dminuoso: When I said "Crash Course in Catagory Theory" I was refering to this. https://www.youtube.com/watch?v=iJ7V1KXJpsE&t=1708s
22:59:18 <iqubic> It's the same guy.
23:00:05 <iqubic> I've seen the first half of that already I need to find a time to view the rest.
23:00:35 <hololeap> now i just need a book on topology for programmers...
23:00:51 <hololeap> if that even makes sense...
23:01:09 <iqubic> A donut is a coffee mug. 'nuff said.
23:01:26 <iqubic> That's like the one piece of tpology I know
23:02:55 <jared-w> ah but it's like the most fun part of topology...
23:02:58 <dminuoso> iqubic: View the lectures instead.
23:03:07 <dminuoso> iqubic: Crash coureses are only meant to pique an interest. ;)
23:03:18 <iqubic> And I certainly have interest.
23:04:23 <hololeap> presheaves? ¯\_(ツ)_/¯
23:08:07 <hololeap> i'd also be very interested in finding an explanation of what homotopy type theory even is that i can understand
23:08:33 <dminuoso> hololeap: Very easy. Its all in here https://homotopytypetheory.org/book/
23:08:40 -hololeap(~hololeap@unaffiliated/hololeap)- AVATAR
23:09:20 <jared-w> But the understandable bit...
23:09:34 <hololeap> hey, at least they have a free pdf :)
23:11:13 <jared-w> I mean, honestly, my understanding of it so far is "dependent types where 'equality' means ``you can find a path from one thing to another'' where that path--in a programming language sense--is essentially a program that round-trips between two things"
23:11:55 <jared-w> idk how spot on that is, though
23:23:36 <dminuoso> Servant question: I want to introduce a database handle to every handler
23:23:56 <dminuoso> Now I realize I could simply pass a resource pool, and have each handler pull one database connection from it.
23:24:05 <dminuoso> But I'd prefer if that happened implicitly.
23:24:20 <dminuoso> Been looking at Context, but Im not sure whether that's a suitable approach
23:24:33 <alp> nope, context is for when you want to pass data to the combinators themselves
23:24:38 <Axman6> do it with a ReaderT
23:24:39 <alp> for your case, reader will do
23:25:33 <alp> https://haskell-servant.readthedocs.io/en/latest/cookbook/db-postgres-pool/PostgresPool.html shows how you can do it without ReaderT. for doing it with ReaderT, you just need to follow this example: https://haskell-servant.readthedocs.io/en/latest/cookbook/using-custom-monad/UsingCustomMonad.html
23:25:36 <Axman6> our app uses ReaderT context (ExceptT err IO) a (newtyped) and the connection pool is part of the context
23:25:41 <alp> except that the "state" in your case will be the connection
23:26:10 <iqubic> Isn't ReaderT basically just a Kleisli arrow?
23:27:13 <alp> yes
23:27:30 <alp> ReaderT r m a  ~  r -> m a
23:28:22 <dminuoso> Axman6: Okay Im not sure where the ReaderT dependency would be filled in
23:28:28 <dminuoso> Is that covered in the links alp send me?
23:30:01 <alp> https://haskell-servant.readthedocs.io/en/latest/tutorial/Server.html#using-another-monad-for-your-handlers explains in general how you can use a custom monad for your handlers, you'll likely want to read this before the cookbook example
23:30:39 <dminuoso> alp: Alright, Ill give that a thorough read. Thanks. :)
23:43:57 <kuribas> does there exists a library that can do equality on GADTs?
23:44:00 * hackage binary-ext 2.0.3 - An alternate with strong-typed errors for `Data.Binary.Get` monad from `binary` package.  http://hackage.haskell.org/package/binary-ext-2.0.3 (warlock)
23:44:09 <kuribas> and generate instances?
23:46:04 <mathZ> After (require 'haskell-mode-autoloads), how to start or jump to ghci buffer ?
23:46:35 <kuribas> mathZ: C-c C-l
23:48:06 <mathZ> kuribas: if no *.hs is open ?
23:49:57 <mathZ> kuribas: Whether or not i need to open a haskell file before C-c C-l ?
23:50:31 <kuribas> mathZ: run-haskell
23:51:19 <mathZ> I ever tried 'run-haskell, but it reports cannot find hugs
23:52:20 <zincy> How should I understand this servant-docs related compiler error -  No instance for (Docs.HasDocs       (AuthProtect "JWT" :> Get '[JSON] UserTypes.UserProfile))
23:53:39 <mathZ> kuribas: Can i make it use ghci instead of hugs ?
23:53:56 <kuribas> mathZ: yes
23:54:08 <mathZ> how ?
23:54:39 <kuribas> mathZ: through customization probably
23:55:16 <mathZ> thx, i
23:55:23 <mathZ> am googling now
23:55:36 <kuribas> or try haskell-interactive-switch
23:57:00 <mathZ> how to use it ? M-x haskell-interactive-switch ?
