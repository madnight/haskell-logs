00:09:22 <johnw> does any one have a good intuition for sheaves as they occur in Haskell?
00:09:25 <dminuoso> jackdk: That's actually the full scope of it already.
00:10:15 <dminuoso> jackdk: In fact I could probably live with ignoring the SrvSta/SvrReq since that's under my control - and I could live with not enforcing that part.
00:11:04 <shachaf> Sheaves occur in Haskell?
00:11:12 * hackage potoki-core 0.9 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-0.9 (NikitaVolkov)
00:11:13 <dminuoso> So if you like the problem is reducible to `AccReq -> AccRej/AccAcc` and `ActReq -> ActRes`
00:11:48 <dminuoso> In fact user shouldn't even have an option to ever specify a SvrSta -> SvrReq handler
00:13:21 <johnw> shachaf: ok, let me step back; do they?
00:14:05 <johnw> are they just contravariant functors with additional restrictions?
00:16:55 <sclv> johnw: i've never seen any proper definition of sheaves in haskell
00:17:12 * hackage potoki-core 0.9.1 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-0.9.1 (NikitaVolkov)
00:17:43 <sclv> i think that even doing presheaves as functors doesn't make much sense in haskell tbh
00:18:17 <sclv> for presheaves i think of them as r -> a for some r, and they're 'a-valued presheaves over r'
00:18:48 <sclv> the problem with presheaves as (contravariant) functors is they're all endofunctors
00:18:55 <sclv> and that cuts out most useful cases
00:19:11 <johnw> I'm not actually wanting this in Haskell per se, but find that looking how the idea has been approximated in Haskell often gives some insight
00:19:18 <johnw> if it has been
00:20:07 <sclv> you _can_ think of "internal sheaves" as induced by idempotent monads, but we really don't even have anything nontrivial that's a proper idempotent monad
00:21:02 <johnw> so, from what literature I've been able to find, a sheaf is a presheaf if it satisfies the adidtional conditions of "uniqueness" and "gluing"
00:21:14 <sclv> its more complicated
00:21:27 <johnw> but that takes me down the road of covers and sites, from which my sanity has yet to recover
00:21:27 <sclv> in particular, sheaves do so with regards to a given topology
00:21:31 <sclv> right
00:21:51 <sclv> so you get a free family of sheaves given the "natural" topology on presheaves
00:22:38 <sclv> so its not like sheaves are special presheaves per se. rather you specify a topology, and with regards to that topology you can then pick out the presheaves which are sheaves
00:23:01 <sclv> if you start with the purely topological intuition and forget categories per se it helps
00:23:58 <sclv> like just start with bundles over a space
00:24:42 <johnw> for example, this almost makes sense: A sheaf on a site S = (C, χ) is a functor B : C^op ⟶ Set such that for each χ-covering family ( f_i : U_i → U | i ∈ I) and compatible family {b_i | i ∈ I}, there exists a unique b ∈ B(U) such that B( f_i )(b) = b_i for each i ∈ I.
00:24:55 <sclv> https://ncatlab.org/nlab/show/%C3%A9tal%C3%A9+space
00:25:23 <johnw> (this is Schultz and Spivak)
00:25:39 <johnw> sclv: sadly, I know zero topology
00:25:54 <johnw> let me resume this with you tomorrow?  I have to write something before unconsciousness takes me
00:26:18 <johnw> this was all just a rabbit hole to research a point, but I feel the need to understand this now; it's not the first time sheaves have come up
00:26:42 <sclv> sure, we can pick up tomorrow :-)
00:26:47 <johnw> great, thanks!
00:26:53 <shachaf> I suspect learning some topology would be helpful.
00:27:09 <johnw> yeah, I think you're very right shachaf; any good book suggestions?
00:27:11 <shachaf> Why else would sheaves come up?
00:27:21 <shachaf> I like the book _Topology via Logic_ by Vickers a lot.
00:27:34 <sclv> i've been learning from Sheaves in Geometry and Logic. chapter 2 does this stuff from the ground up
00:27:45 <sclv> I've been meaning to look at Vickers which I hear good things about
00:27:56 <shachaf> It's a pretty unusual perspective on topology that made a lot more sense to my CS-twisted mind than any of the usual approaches.
00:28:10 <johnw> that title sounds quite promising
00:28:32 <sclv> one can start with locales too i guess, which i assume is what vickers does?
00:28:35 <johnw> shachaf: sheaves come up today while talking about parsers, strangely enough
00:28:46 <sclv> makes perfect sense to me :-)
00:29:04 <sclv> i suppose that you can bodge your way to an intuition of toposes by just concerning yourself with localic ones
00:29:06 <sclv> at first
00:29:15 <sclv> and then it really lets you scale up from logic directly
00:29:16 <shachaf> He gets to frames and locales and all that later on.
00:30:05 <sclv> johnw: yeah, once you see the core ideas behind topos theory you see it everywhere, just like a lot of other categorical stuff :-)
00:30:33 <johnw> ok, on shachaf's recommendation I think I'll buy this buy then; my mind is CS-twisted as well
00:30:36 <sclv> (it beautifully synthesizes and generalizes a ridiculous chunk of modern logic)
00:31:47 <johnw> ordered :)
00:32:07 <johnw> let me read that when it comes next week, and then we'll talk sclv
00:33:01 <shachaf> The general idea can be summarized pretty concisely.
00:33:08 <shachaf> But is a little beyond the scope of this channel probably.
00:33:37 <johnw> if you know of a better channel, I can join you there
00:33:42 * hackage hierarchy 1.0.2 - Predicated traversal of generated trees  http://hackage.haskell.org/package/hierarchy-1.0.2 (JohnWiegley)
00:33:55 <sclv> sgtm
00:35:10 <shachaf> I'm in all the channels.
00:35:14 <johnw> haha
00:35:48 <Axman6>  /j #haskell-*
00:38:48 <MarcelineVQ> do feel free to say it here tho, cause I'm not in all the channels
00:40:04 <shachaf> No way, this channel is publicly logged. Gotta watch your step.
00:40:58 <johnw> the last time shachaf said something inaccurate about topoi was... well, wait. Maybe he had that expunged.
00:41:47 <shachaf> I don't know anything about what a topos is. Not even how to pluralize the word.
00:42:19 <johnw> you just say topii within earshot of pretty much anyone, in a tone of voice that suggests authority, and wait for the correction
00:42:39 <MarcelineVQ> a topos is a spot where reality got bent 'cause of all the reality juice was spilling all over, if you're worried about public logs keep in mind lambdabot is watching you too
00:42:43 <MarcelineVQ> @quote shachaf
00:42:43 <lambdabot> shachaf says: You can never escape having learned monads. If you learn two monads, though, you can go back to only knowing one.
00:43:01 <johnw> lol
00:45:57 <sclv> there's no one way to pluralize it
00:46:01 <sclv> people argue about it all the time
00:46:12 <johnw> topae
00:46:16 <sclv> lol
00:46:32 <dodong> uit
00:46:34 <dodong> quit
00:46:41 <shachaf> I suppose I can talk about it in #-offtopic or #-overflow
00:47:01 <dminuoso> Given `u :: Maybe ByteString` and `ms :: [ByteString]`, is there a more elegant solution to this? `do { u' <- u; asum (stripSuffix u' <$> ms) }` ?
00:47:11 <sclv> there's also ##category-theory
00:47:20 <dminuoso> I feel like there must be some way to utilize traverse, but I dont know how to do this with the `Maybe` of u in the way.
00:48:12 * hackage potoki-core 0.9.2 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-0.9.2 (NikitaVolkov)
00:51:28 <sclv> dminuoso: how would you write it if u was not a maybe
00:53:06 <cocreature> dminuoso: that seems pretty elegant to me tbh
00:56:52 <dminuoso> cocreature: Heh fair enough. My golf instinct took me a bit too far. asum is a blessing, ever since you recommended I started finding uses all over the place. :)
00:57:12 * hackage chatwork 0.1.3.3 - The ChatWork API in Haskell  http://hackage.haskell.org/package/chatwork-0.1.3.3 (matsubara0507)
00:58:16 <cocreature> do we have a package that provides unboxed immutable sets based on an unboxed vector/ByteArray?
00:58:42 * hackage rakuten 0.1.1.2, servant-kotlin 0.1.1.1 (matsubara0507): https://qbin.io/crack-works-1i7r
01:05:38 <cocreature> hm I guess andrew’s primive-containers is what I’m looking for. but I can’t use backpack for this so I guess I’ll just inline and specialize the code I want
01:12:01 <dminuoso> ReaderT is actually not so bad =)
01:18:30 <dminuoso> The MonadPlus instance is what brought me over :)
01:20:52 <dminuoso> Speaking of which, Stephen Diel's guide on parser combinators uses different implementations for Alternative and MonadPlus, is this allowed?
01:22:26 <cocreature> would be pretty awkward now that Alternative is a superclass of MonadPlus
01:22:37 <cocreature> MonadPlus is just redundant at this point
01:36:02 <jle`> i think mplus = (<|>) is actually a law
01:36:35 <cocreature> jle`: no, at least not one mentioned in the docs
01:36:40 <cocreature> but it’s the default implementation
01:36:45 <jle`> boo
01:37:03 <cocreature> huh IntSet beats the shit out of a ByteArray + binary search
01:37:07 <jle`> boo i say
01:37:23 <jle`> but yay to IntSet performance
01:38:32 <jle`> i'm always impressed by containers
01:38:37 <cocreature> and I thought I was being clever since the cache effects of just having a linear array surely outweigh the cleverness of IntSet :)
01:40:12 * hackage ez3 0.1.0.0 - Z3 bonds with pure interface  http://hackage.haskell.org/package/ez3-0.1.0.0 (MatthewFarkasDyck)
01:40:22 <jle`> isn't it frustrating when you leave something to be optimized later because you don't want to prematurely optimize
01:40:27 <jle`> and then later you go back in an optimize it
01:40:45 <jle`> and it turns out the original version was already crazy fast and changing it didn't help
01:40:59 <cocreature> heh, you’re describing my life for the past few days :)
01:41:04 <jle`> it's like you were banking on yourself being incompetent
01:41:12 <jle`> but it turns out past you was too smart
01:41:22 <jle`> :(
01:42:13 <cocreature> let’s see if I can at least beat IntMap, surely I can do better™
01:54:14 <gentauro> I have a question about Showable
01:54:49 <gentauro> if I do the following: "data Foo a = Foo a a" and "instance Show a => Show (Foo a) where show (Foo x y) = show x ++ show y"
01:55:53 <gentauro> it seems to work correctly with Integers: "λ Foo 1 2" -> "12", but for strings, it looks horrible: "Foo "1" "2"" -> ""1""2""
01:56:32 <gentauro> how can I implement Showable so strings actually are printed like "12" instead of ""1""2""?
01:57:12 * hackage websockets 0.12.4.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.12.4.1 (JasperVanDerJeugt)
01:57:20 <dminuoso> gentauro: You're not supposed to.
01:57:37 <dminuoso> gentauro: Show is for generating valid haskell code that if you copy and paste it into say GHCi you will get the same object basically
01:57:53 <dminuoso> gentauro: Show is not meant for pretty prenting.
01:58:09 <gentauro> so Show is a serializer?
01:58:24 <dminuoso> gentauro: It's a `value -> Haskell Code` serializer basically
01:58:28 <gentauro> and Readable is a deserializer?
01:58:45 <cocreature> it’s more for debugging purposes than a serializer that you would actually want to use for anything else
01:58:46 <simon> to the extent that they can be serialized, I guess. not strictly enforced.
01:59:24 <simon> normally you'd wanna write a set of PP functions next to Show.
01:59:26 <ventonegro> Most usages I see is for debugging
01:59:56 <gentauro> simon, but wouldn't those PP funs also run into the same problem?
02:00:18 <dminuoso> gentauro: Show is for generating a string that itself is valid Haskell code.
02:00:20 <dminuoso> gentauro: PP is not.
02:00:27 <gentauro> the reason I'm using show, is because it's show :: a -> String
02:00:40 <jle`> gentauro: yes, show isn't really meant to be able to print something in a nice way
02:00:42 <simon> gentauro, it depends. I suppose you'd only write a pretty-printer to something that can be pretty-printed, whereas the Show instance can be used for non-serializable data types for debugging purposes.
02:01:09 <jle`> gentauro: if show "1" is "1", then how would you disinguish show "1" from show 1 ?
02:01:19 <jle`> it's mostly meant to just be for debugging
02:01:23 <gentauro> so I'm guessing that I need to implement a type-class right? Which one should it be instead of Show then?
02:01:29 <gentauro> PrettyPrint? :)
02:01:31 <jle`> you don't need to implement a typeclass
02:01:34 <jle`> you can just use normal functions
02:01:44 <jle`> if you have a string, instead of using 'show', just use 'id' :)
02:02:07 <dminuoso> Is it reasonable to say that Show should satisfy `evalThroughHint . show = id`?
02:02:17 <jle`> making a new typeclass is 90% of the time the wrong thing to do, heh, and will usually cause much more problems than it's worth
02:02:31 <simon> gentauro, https://hackage.haskell.org/package/pretty doesn't appear to use type classes.
02:02:42 * hackage csg 0.1.0.1 - Analytical CSG (Constructive Solid Geometry) library  http://hackage.haskell.org/package/csg-0.1.0.1 (DmitryDzhus)
02:02:59 <dminuoso> gentauro: Ah well in the end `read . show = id` must hold
02:03:09 <simon> gentauro, I guess you might want a type class if you have a lot of different ASTs in your project. :)
02:03:10 <jle`> making a new tpyeclass should always be a last resort, and always be done knowing how much worse you are making things for yourself, heh
02:03:37 <jle`> only after knowing how much trouble making a new typeclass would be could you actually start assessing if the benefit is worth it
02:03:47 <jle`> (and it almost always isn't)
02:04:06 <simon> og hej gentauro :) what are you up to?
02:04:12 <gentauro> https://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint.html#g:3
02:04:41 <gentauro> hej simon
02:04:55 <gentauro> (do we know each other?) :)
02:05:03 <simon> (Simon Shine from DIKU)
02:05:19 <gentauro> shine like a diamond !!! :D
02:06:26 <gentauro> And I'm actually "playing around with the LC" written in BirdPaterson99DeBruijn.pdf
02:07:06 <gentauro> they implement LC with variable types V
02:07:22 <gentauro> which could be Chars, Ints and even Strings
02:07:35 <simon> what's LC?
02:07:41 <simon> oh, lambda calculus.
02:07:50 <gentauro> but when I make the type Showable, I get lambdas like -> ^"x"."x" for the identity function
02:08:23 <simon> ah. yeah, just write a pp :: Lambda -> String
02:08:53 <gentauro> https://dl.acm.org/citation.cfm?id=968702
02:09:15 <gentauro> simon, that's why I have done, but, I was relaying on "show" to handle "v"
02:09:36 <geekosaur> you will want your own prettyprinter typeclass
02:09:44 <geekosaur> (or find one that someone else already wrote)
02:09:53 <geekosaur> > text $ show "a"
02:09:55 <lambdabot>  "a"
02:10:00 <gentauro> geekosaur: that's what I'm implying
02:10:24 <geekosaur> String gets wrapped in quotes. So does Char, with single quotes, so you probably want to replace that in yours as well
02:10:56 <gentauro> > I get lambdas like -> ^"x"."x" for the identity function
02:10:58 <gentauro> can confirm
02:10:59 <lambdabot>  <hint>:1:20: error: parse error on input ‘->’
02:11:23 <gentauro> who is lambdabot ?
02:11:48 <geekosaur> "ho"?
02:11:49 <geekosaur> er
02:11:51 <geekosaur> "who"?
02:12:01 <geekosaur> it's a bot
02:12:08 <gentauro> btw simon, are you coming? https://www.meetup.com/MoedegruppeFunktionelleKoebenhavnere/events/250240206/
02:12:25 <ventonegro> Someone that types your code very fast to check it, and pastes the result here
02:12:45 <simon> gentauro, I signed up, yes.
02:13:24 <gentauro> niceness :)
02:14:34 <cocreature> so looking at the Core/STG of this code, I’m seeing something like "case f x of I# i -> i". does this mean that I’m paying for the allocation of the Int box?
02:15:41 <simon> is hackage experiencing problems?
02:15:50 <simon> question: is there an Hspec combinator for asserting that something isRight? (I can't seem to access the docs.)
02:16:38 <cocreature> simon: https://www.stackage.org/haddock/lts-11.8/hspec-expectations-0.8.2/Test-Hspec-Expectations-Contrib.html
02:18:39 <simon> cocreature, thanks.
02:18:40 <geekosaur> cocreature, that would seem to say it thinks it needs to unbox something, yes. which would imply there that it thinks f is of type Int. (but you said "like", and I'm assuming core-style case)
02:18:45 <simon> shouldSatisfy
02:19:06 <cocreature> geekosaur: right I’m seeing this both in core and stg
02:19:41 <cocreature> not sure why though, f is indexByteArray# from the Prim instance of Int which seems to have INLINE pragmas on everything
02:35:56 <CoolerZ> anyone familiar with formal languages and ogden's lemma?
02:41:29 <reactormonk> I get a warning that both GND and DAC can be used to derive a class - can I specify which one to use?
02:41:50 <cocreature> reactormonk: with a suffiently new GHC (iirc 8.2) you can use DerivingStrategies
02:44:51 <cocreature> ah at -O2 it kills the allocation, I was only testing -O1
02:45:14 <cocreature> ofc I only realized that after I’ve manually written the code that uses indexIntArray# directly :)
02:52:12 * hackage alg 0.2.4.2 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.4.2 (MatthewFarkasDyck)
02:53:12 * hackage alg 0.2.5.0 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.5.0 (MatthewFarkasDyck)
03:00:58 <gentauro> so I tried to implement the pretty printer -> https://gist.github.com/gentauro/cf84bbfa8f9befa37cb27cb7c58c9fab
03:01:08 <gentauro> I still get the same result as I get with Show ...
03:01:10 <gentauro> :\
03:04:07 <jle`> it's sort of considered bad practice to give a Show instance that isn't a direct representation of the data type in haskell code
03:04:24 <jle`> if you write a pretty printer for your type, don't call it 'show'; just write a function with a normal name :)
03:04:34 <jle`> like ppTerm :: Term a -> String, or -> Doc
03:07:26 <gentauro> jle`: well the problem for me, is that it's actually a representation of the type in Haskell code ;)
03:07:40 <gentauro> but good to know that it needs to go in a separate function
03:08:27 <gentauro> what I'm asking for, is how can I pretty print (Lam "x" (Var "x")) to become "^x.x" instead of "^"x"."x""
03:09:01 <gentauro> I don't really see what "Text.PrettyPrint" brought to the table ...
03:15:12 * hackage interlude-l 0.4.0.0 - Prelude replacement based on protolude  http://hackage.haskell.org/package/interlude-l-0.4.0.0 (darwin226)
03:26:29 <reactormonk> I have some json decoding that's pretty well working with auto-derivation - except for one field, which is delivered as string, but I'd need it as a number. How can I modify that one field with a minimum number of boilerplate?
03:28:44 <kuribas> reactormonk: create a new type with a string there, and write a conversion function?
03:28:50 <kuribas> in the Result monad
03:29:25 <reactormonk> kuribas, I was hoping to avoid that. Alas, no extensible records
03:29:30 <kuribas> OTOH it may be just as much work to write a parser yourself
03:29:37 <jchia> It seems that the constraint for fromIntegral would be more useful if it were like this: fromIntegral :: (Num b, Integral a) => a -> b. Then you can use TypeApplications with the target type to say what target type you want. Because a comes first, you have to use '@' twice.
03:29:58 <jchia> I mean fromIntegral :: forall b a.(Integral a, Num b) => a -> b
03:29:59 <reactormonk> Or write a parser that accepts both?
03:30:06 <kuribas> reactormonk: aeson (which I assume you use), doesn't have capability to change one field.
03:30:20 <kuribas> In the TH or generic derivation
03:30:20 <reactormonk> kuribas, yes, I know :-(
03:30:52 <kvothe176> the documentation for lazy bytestring says that it is not completely loaded into memory. Is the remaining part stored in disk?
03:31:18 <reactormonk> kuribas, if you want to have a glance at future splendor - https://gist.github.com/justinwoo/9d0bb67a84c227f327da7171bb7105c2
03:31:44 <reactormonk> kvothe176, ... or wherever you data comes from.
03:32:21 <reactormonk> I'd presonally recommend conduit (or machines, or pipes) if you wanna do streaming IO
03:32:44 <kuribas> reactormonk: it's probably not so much boilerplate, unless that ADT is huge
03:33:33 <reactormonk> kuribas, 15 :-/
03:34:16 <kuribas> fields?
03:35:29 <kuribas> reactormonk: write a function Value -> Result Value, that turns the string into number
03:35:51 <kuribas> reactormonk: then compose your own parser with the generated one.
03:36:14 <reactormonk> kuribas, also considered that, but it's pretty hard to get right
03:37:12 <kuribas> or use higher kinded wizardry
03:39:41 <kvothe176> reactormonk, what if I created a lazy bytestring from a bunch of strict bytestrings? Where does the part which isn't in memory go?
03:40:31 <reactormonk> kvothe176, what are the options?
03:40:42 <cocreature> kvothe176: in that case everything is already in memory
03:40:53 <kuribas> reactormonk: you can use genericParseJSON
03:41:03 <cocreature> kvothe176: a lazy bytestring is just a list of strict bytestrings
03:41:29 <reactormonk> kuribas, and do fun stuff with generics? Hmm
03:41:34 <kuribas> reactormonk: so genericParseJSON defaultOptions . numerifyValue
03:41:47 <jbetz> I've been going through gabriel's example-nix project, and now trying to run ghcid inside of a nix-shell, but it's failing with command not found
03:42:25 <jbetz> I thought it'd be there because the docs say that ghcid is provided by nix
03:42:48 <jbetz> so, why isn't it available in the shell, and how do I get it there?
03:42:53 <kuribas> reactormonk: or mkParseJSON from TH
03:43:06 <cocreature> jbetz: can you give us a link to the example-nix project?
03:43:32 <cocreature> jbetz: you probably need to add something like -p ghcid to your invocation of nix-shell
03:44:14 <jbetz> https://github.com/shajra/example-nix <-- oops, confused it with gabriel's `haskell-nix` project, but yeah, this is what I'm looking at
03:44:28 <cocreature> try -p haskellPackages.ghcid
03:48:29 <jbetz> cocreature: how would I combine that with `nix-shell --attr env release.nix`?
03:48:46 <cocreature> nix-shell --attr env release.nix -p haskellPackages.ghcid
03:49:25 <jbetz> okay, that's what I did, but it failed with `error: attribute 'env' in selection path 'env' not found`
03:49:47 <jbetz> but it works without `-p ...`
03:52:10 <kuribas> reactormonk: better: numerifyValue >=> genericParseJSON defaultOption
03:52:30 <cocreature> jbetz: maybe try swapping the order of the arguments such that release.nix comes last? I seem to recall that this worked somehow but maybe I’m misremembering
03:52:46 <kuribas> reactormonk: since numerifyValue can fail
03:53:32 <jbetz> cocreature: yeah, I tried that. same error :/
03:54:21 <cocreature> jbetz: I would just install ghcid with nix-env tbh
04:17:09 <jbetz> yeah, that worked :}
04:18:52 <jbetz> cocreature: do you know of any working nix + haskell ide setups? I tried to get vscode + hie + nix working to no avail, and now back to ghcid in a terminal
04:19:13 <cocreature> no, sry. I’m only a very occasional nix user
04:19:27 <cocreature> and I use ghcid as well :)
04:19:53 <cocreature> I got too annoyed with Haskell tooling that broke
04:23:54 <zenwan> greetings. I'm getting the following error: "qualified name in binding position" as i'm trying to pattern match against a DS.empty, with Data.Sequence imported qualified as DS. Anyone knows why?
04:24:31 <simon> I'm trying to add QuickCheck-GenT as a dependency in package.yaml under tests. I get "QuickCheck-GenT must match -any, but the stack configuration has no specified version (latest matching version is 0.2.0)". if I add QuickCheck-GenT-0.2.0 instead, it says: Error in $.tests.unit.dependencies[6]: invalid dependency "QuickCheck-GenT-0.2.0" -- what am I missing? should this be in stack.yaml?
04:25:04 <fishythefish> zenwan: DS.empty isn't a constructor
04:26:03 <zenwan> fishythefish: thanks
04:26:16 <cocreature> zenwan: if you have a somewhat recent version of GHC and containers you can match against the Empty pattern synonym
04:28:23 <zenwan> cocreature: thank you.
04:29:45 <lyxia> simon: yes, add an extra-dep to stack.yaml. This file specifies exactly the versions of your dependencies. For many packages this is implicit by the choice of the resolver, and you have to add packages that are not part of the resolver explicitly as extra-deps.
04:30:46 <dminuoso> dibblego: Heh I addressed the issue by not solving the problem - but changing the problem into one that can easily be modelled by the type system.
04:31:46 <dibblego> ok cool
04:31:51 <dminuoso> dibblego: Now I simply have `data ActResponse = Packet` and `data AccResponse = Packet` and my entry function roughly has some `f :: Handler ActResponse -> Handler AccResponse -> Handler Packet` :)
04:32:32 <dminuoso> It's not as expressive, but I couldn't get a grasp on how to utilize Prisms the way you mentioned
04:32:59 <dminuoso> That should be `data ActResponse = ActResponse Packet` and `data AccResponse = AccResponse Packet` of course
04:33:25 <dminuoso> I then dont export the data constructors and just provide smart constructors. Problem solved.
04:33:52 <simon> lyxia, and so if I put QuickCheck-GenT-0.2.0 in extra-deps in stack.yaml, isn't there still a point in adding a more flexible range like QuickCheck-GenT >= 0.2 && < 0.3 in package.yaml? (assuming this package respects API compliance in this range)
04:35:29 <JonnyRaa> Hi!  I've been looking over some stuff to do with lenses this morning and have hit a bit of a wall - I'm trying to use some types that don't have lenses defined on them and would like to create some setters for some fields.  With getters there is the function `to` which lets you pass a vanilla haskell getter and it makes you a lensy getter.... but with setters the closest thing I can find is `sets` but I can't understand how to use it t
04:35:29 <JonnyRaa> o make a setter and can't find any examples online.  Could anyone provide any help?  I realise I could use `lens` to create something that can be used as both a setter and a getter but I don't care about getting in this case.  I was sortof expecting something in the type signature like `s -> a -> t`
04:35:40 <lyxia> simon: yes, because your package might work with more than one version of packages
04:36:05 <lyxia> simon: not everyone wants to use the same resolver as you do
04:36:42 <simon> lyxia, anarchy!
04:39:44 <lyxia> JonnyRaa: use `setting`
04:40:51 <lyxia> actually they seem pretty much the same, specializing `sets` with p ~ q ~ (->)
04:42:08 <CoolerZ> can someone help me with this proof? https://screenshots.firefox.com/WteEz5GUlNGJhNXa/www.classes.cs.uchicago.edu
04:44:08 <cocreature> CoolerZ: that doesn’t look very Haskelly
04:44:15 <lyxia> JonnyRaa: interesting, it seems a Setter is not equivalent to (s -> a -> t)
04:44:59 <CoolerZ> cocreature, its about context free languages
04:45:13 <cocreature> CoolerZ: right but this channel is about Haskell
04:46:08 <GobiGobi> has anybody ever written golden tests for binary serializations?
04:46:46 <cocreature> GobiGobi: I haven’t but tasty-golden operates on ByteString so that should just work
04:46:51 <CoolerZ> cocreature, nvm i figured it out
04:46:58 <JonnyRaa> lyxia: thanks for the response :) yeah I think it might be because they can also read the value and then modify it.  I suppose you need full lens powers to do that, but it's niggling me that I don't really understand what that sets function is for
04:47:04 <CoolerZ> cocreature, isn't there like haskell overflow or something?
04:47:12 <CoolerZ> for more in depth discussions
04:47:19 <CoolerZ> off topic stuff
04:47:26 <cocreature> there is #haskell-blah and #haskell-offtopic
04:47:34 <GobiGobi> cocreature: I'm looking more for an example of this to figure out the best way to structure it
04:48:27 <GobiGobi> tried looking up reverse dependencies for both `binary` and `tasty-golden` but that is the needle in a haystack approach
04:49:23 <cocreature> GobiGobi: anything specific that you’re having trouble with? I don’t really see how the fact that it’s binary serialization changes a whole lot
04:50:28 <GobiGobi> cocreature: I'll give it a go and if I run into something specific I'll come back, thanks.
04:52:41 <[exa]> CoolerZ: maybe just ask what the exact problem with the proof is (the answer is very probably not going to cause flood here)
04:54:12 <dmwit> ?tell aarvar (re: https://stackoverflow.com/q/49946389/791604 and your followup question, "Why have FilterType at all?") Presumably the different types of filters  behave differently. Why do you believe FilterType can be omitted?
04:54:12 <lambdabot> Consider it noted.
05:03:10 <GobiGobi> cocreature: For a golden test say I want to be sure a specific data type remains unchanged (wrt to types), how do I enforce this?
05:03:45 <cocreature> GobiGobi: you mean you want to ensure that it’s serialized to the same value?
05:04:05 <GobiGobi> cocreature: yes the same value but with respect to its types
05:04:17 <cocreature> I’m not sure what you mean by “with respect to its types”
05:05:33 <GobiGobi> cocreature: e.g `data Test = Test String`, I want to test that the type remains `Test String` so that if anybody comes along and tries to change `Test String` to say `Test Int`, the golden test will fail
05:06:44 <cocreature> GobiGobi: I don’t see what golden tests have to do with this. just put some code somewhere that uses the Test constructor with a string argument and it will fail to compile if you try to change it
05:24:29 <zezeri> hello :)
05:26:28 <zezeri> https://pastebin.com/fDcqb97s
05:26:48 <zezeri> Can anyone explain to me why just adding two space characters makes compiling impossible?
05:27:57 <alexad> zezeri, whitespace has syntactic meaning in haskell. The compiler thinks mycompare is part of the previous function's scope, and that violates da rules
05:28:33 <zezeri> thank you very much for a concise and quick explaination, alexad :)
05:28:42 <alexad> no worries
05:37:37 <tian_> :t (flip . flip) return
05:37:38 <lambdabot> c -> a -> c
05:37:59 <tian_> :t return
05:38:00 <lambdabot> Monad m => a -> m a
05:38:15 <tian_> :k Monad
05:38:16 <lambdabot> (* -> *) -> Constraint
05:39:23 <tian_> why the information of monad lost after twice flip?
05:40:11 <lyxia> because return must be specialized with m ~ (->) a
05:41:16 <tian_> lyxia: What does "m ~ (->) a" mean?
05:41:38 <lyxia> tian_: (->) is a type constructor
05:41:46 <lyxia> (->) a  is (->) applied to "a"
05:42:19 <lyxia> ~ is type equality.   m ~ (->) a   means "m" equals "(->) a"
05:42:29 <tian_> :k (->)
05:42:30 <lambdabot> TYPE q -> TYPE r -> *
05:42:39 <tian_> :k (~)
05:42:40 <lambdabot> k -> k -> Constraint
05:43:50 <tian_> :i (->)
05:45:09 <tian_> lyxia: Thanks so much!
05:46:22 <tian_> (Still thinking...
05:46:39 <fishythefish> :t flip
05:46:40 <lambdabot> (a -> b -> c) -> b -> a -> c
05:46:49 <fishythefish> ah, nvm, he left
05:46:57 <dminuoso> :t (flip . flip)
05:46:58 <lambdabot> (b -> a -> c) -> b -> a -> c
05:51:52 <infinisil> Haha, why is every other package written by Edward Kmett
05:52:25 <AnaValencia> hi
05:55:56 <alexad> AnaValencia, hi
05:58:42 * hackage int-multimap 0.3 - A data structure that associates each Int key with a set of values  http://hackage.haskell.org/package/int-multimap-0.3 (OShev)
06:39:17 <athan> Can I case match totally on all imported instances of a data family? S.t. I can treat it exactly like data, and potentially make a discrete newtype wrapper around those potential case values? I'm just looking to make all instances of a persistent EntityField JSON {en,de}codable
06:39:40 <lyxia> no
06:40:59 <athan> lyxia: why not? :( shoot
06:42:30 <athan> Like, the instances themselves are values, inhabiting the same higher-kinded type, right?
06:42:41 <athan> Or is a data family kinda treated like a type alias in that regard?
06:43:42 * hackage HSlippyMap 3.0.1 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-3.0.1 (apeyroux)
06:44:52 <fishythefish> athan: the instances of a data family are types
06:44:56 <athan> if I have some instance FooField :: EntityValue Foo Int, and some FooField2 :: EntityField Foo Bool, could I in some way at least capture the distinguished possibilities in a data type then? Like data FooFields = FooField (EntityField Foo Int) | FooField2 (EntityField Foo Bool) or some crud like that?
06:45:39 <athan> hrm, yeah sorry I'm just thrashing I guess. I'm just trying to shoehorn extra instances on the faint data family instance itself
06:46:53 <lyxia> I guess there's the same open world assumption with data instances as with class instances
06:47:28 <lyxia> we don't want the meaning of a program to depend on the absence of an instance, because it could simply be that it's not visible but exists somewhere.
06:48:05 <fishythefish> yup, data families are open
06:48:11 <fishythefish> you can have closed type families, however
06:48:25 <athan> yeah exactly, hrm. Something something closed type instances but for data families perhaps? :D
06:48:37 <athan> thanks yall!
06:49:09 <fishythefish> er, if you want to add instances, then you *don't* want it to be closed
06:49:16 <fishythefish> (and fortunately, it's open)
06:50:54 <athan> fishythefish: Yeah I mean, ideally I would like it to be closed. Or really, persistent should make them closed somehow
06:51:21 <athan> that would make sense, wouldn't it? Because the record types are being generated by the persistent TH code, and wouldn't cause for an orphan instance anywhere else
06:51:46 <athan> Er shoot, sorry I keep forgetting that persistent also expects to be the only user of a generic EntityField... hm
06:52:11 <athan> sorry I'll keep poking this
06:52:32 <lyxia> it's open so that persistent can define instances with TH
06:52:57 <lyxia> TH only does things you could have done by hand
06:54:07 <athan> But I couldn't do something weird like `ToJSON (EntityField Foo Int) =>`
06:54:13 <athan> well I mean, I could try and expect it
06:54:19 <athan> but I don't think it could ever be satisfied
06:54:39 <athan> because you can't make an instance of a data family an instance of something else... right?
06:55:00 <athan> because data family instances have no owning data type
06:55:08 <athan> inhabited*
06:55:15 <lyxia> I don't understand why you would want to do something weird like that
06:55:30 <athan> lyxia: communicating the field that changed
06:55:48 <athan> like over 0mq or a websocket or somethin
06:56:49 <lyxia> I think I missed a step between "ToJSON (EntityField Foo Int) =>" and "communicating the field that changed"
06:57:16 <athan> EntityField Foo Int is a value-level symbol representing a field of a persisted record type
06:57:59 <athan> like `data Foo = Foo {field :: Int, field2 :: Bool}`'s `field` would be represented as `data family instance EntityField Foo Int where FooField :: EntityField Foo Int` or something iirc
06:58:36 <athan> s.t. `FooField` /could/ be used as a literal value to represent the field's label
06:59:15 <lyxia> data instances are really just data types, you can definitely define an instance of ToJSON for an EntityField.
06:59:46 <athan> lyxia: but it would be monomorphic, right?
07:00:03 <athan> like `instance ToJSON (EntityField Foo Int) where; toJSON FooField = ...`?
07:01:52 <athan> shoot, well I think I'm on to a good start. Thank you for your help lyxia and fishythefish!
07:02:10 <lyxia> @tell athan I don't think so. It can be:  data instance EntityField Foo a where FooField :: EntityField Foo Int ;   instance ToJSON (EntityField Foo a) where toJSON FooField = ...
07:02:10 <lambdabot> Consider it noted.
07:31:16 * hackage acquire 0.1, acquire 0.2 (NikitaVolkov): https://qbin.io/human-scenic-rd8y
07:38:39 <jchia_> aeson question: Is there a way to specify Options so that the parsing skips decoding of fields of types () and Const () a, so that the input JSON doesn't need to have these fields? E.g. the decoding for "data Foo { a :: (), b :: Const () Int, c :: Int }" requires only 'c'?
07:39:54 <jchia_> I happen to have something like "data Foo f = Foo { a :: f Int, b :: f Char, c :: Int }", and I need to decode "Foo (Const ())" and "Foo Identity".
07:44:37 <robstr> jchia_: I'm quite new and maybe misunderstood your question but you are free to generate your own FromJSON instance ignoring all the fields you are not interested in
07:44:57 <jchia_> robstr: I'm trying to avoid hand-crafting the decoding code myself.
07:45:48 <robstr> jchia_: I see, then I'm out :P
07:46:53 <jchia_> robstr: I think the derived instance will look for an empty array for 'b' when decoding "Foo (Const ())"
07:46:58 <lyxia> jchia_: unfortunately the only fields handled specially are Maybe and Option
07:49:14 <lyxia> aeson's generic implementation breaks down quite quickly if you have specific requirements about how to encode your types
07:53:39 <jchia_> lyxia: Well, I actually only have Foo Identity and Foo (Const ()) in my use case, so I'll just make unparameterized Foo1 and Foo2 instead.
07:54:12 * hackage servant-aeson-specs 0.6.2.0 - generic tests for aeson serialization in servant  http://hackage.haskell.org/package/servant-aeson-specs-0.6.2.0 (scottfleischmanplow)
07:56:18 <hyperisco> RIP lpaste.net ?
07:56:34 <hyperisco> HTTP 301
07:57:20 <hyperisco> trying: ghc-mod-5.8.0.0 (user goal) next goal: base (dependency of ghc-mod-5.8.0.0) rejecting: base-4.10.1.0/installed-4.1... (conflict: ghc-mod => base<4.10 &&
07:57:31 <jchia_> hyperisco: I switched to gist
07:57:32 <hyperisco> ghc 8.2.2
07:58:41 <jchia_> lpaste hasn't work for me for quite a while
08:01:09 <cocreature> hyperisco: there is a branch for 8.2 iirc
08:01:52 <hyperisco> compiling and installing a cabal package locally? pretty advanced, not sure I am up to it
08:05:03 <hyperisco> I have been mortified by bower when doing that
08:09:42 * hackage potoki-core 0.10 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-0.10 (NikitaVolkov)
08:13:42 * hackage nuxeo 0.2.0.2 - Nuxeo  http://hackage.haskell.org/package/nuxeo-0.2.0.2 (apeyroux)
08:17:45 <mad_> hi
08:18:01 <mad_> in this code, please
08:18:35 <mad_>  tyrionResearch :: Reader WineData Int
08:18:37 <humanoyd> phadej: out of interest: how long will the countdown be for this: https://github.com/haskell-infra/hackage-trustees/issues/155 ?
08:18:59 <mad_> how can I read this definition
08:19:35 <mad_> I mean the definition of tyrionResearch in tyrionResearch :: Reader WineData Int
08:19:52 <mad_> I found it here : http://www.pxlet.com/detail.php?src=https://www.snoyman.com/blog/2016/11/haskells-missing-concurrency-basics&title=Haskell%27s%20Missing%20Concurrency%20Basics
08:27:21 <lyxia> mad_: "tyrionResearch has type 'Reader WineData Int'"
08:41:15 <getJiggyWMe> so... are true dependent types coming ever coming to haskell? and if so, will there be any reason to flirt with idris anymore?
08:42:24 <c_wraith> The way DT is projected to land in Haskell still leaves them far short of what they can prove in other languages.
08:42:34 <c_wraith> There's no termination checking, for instance.
08:43:14 <c_wraith> The plans for a dependent Haskell extension are 99% about making the things you can already do in Haskell much more pleasant to work with.
08:44:52 <getJiggyWMe> hmm, so idris won't become obsolete after all
08:44:58 <c_wraith> Not at all. :)
08:48:21 <phadej> humanoyd: "unfortuntely" two weeks
08:49:15 <phadej> humanoyd: https://github.com/haskell-infra/hackage-trustees/blob/master/policy.md#3-source-changes-simple-patches
08:54:42 <noan> cabal new-install should in principle copy over data-files, correct?
08:55:40 <humanoyd> phadej: Thanks!
08:56:07 <sclv> noan: new-install and datafiles are a bit weird
08:56:13 <sclv> i confess i don't understand it yet
08:56:26 <sclv> you're likely better served asking in #hackage (where cabal devs hang)
08:59:35 <phadej> noan: new-install has data-files somewhere in ~/.cabal/store
08:59:49 <gmorpheme> I can't find any haskell regex libs that support named groups. Am I missing any?
08:59:52 <phadej> noan: but package/executable is compiled so Paths_{pkg}.hs has right locations
09:00:04 <phadej> i.e. if you don't destroy ~/.store data-files are there
09:00:43 <phadej> (note that new-install also only links the executable to --symlink-bindir, so destroying store destroys the binary too)
09:01:14 <phadej> err* ~/.cabal/store
09:05:34 <tnks> jbetz: I saw you mention my project, but I don't have irssi set up well enough to find the surrounding context.
09:05:53 <tnks> My project is in need of a touch up.  I have changes to update it, but the basic setup would remain similar.
09:07:11 <lyxia> gmorpheme: parser combinators are usually preferred over regexps.
09:12:04 <gmorpheme> lyxia: sure, thanks - I don't want to use regexes for myself, but pass the capability up to users... a facility a bit like grok/logstash log matching.
09:14:42 * hackage errors 2.3.0 - Simplified error-handling  http://hackage.haskell.org/package/errors-2.3.0 (GabrielGonzalez)
09:26:12 * hackage mapalgebra 0.1.1 - Efficient, polymorphic Map Algebra.  http://hackage.haskell.org/package/mapalgebra-0.1.1 (fosskers)
09:41:35 <crysikrend> Hey, does anyone have experience with using getDataFileName to retrieve files from built projects? i've just deleted my .stack-work folder to try and get a fresh build going to debug this, and it's built folders in dist and install WITHOUT -nopie, but doing stack exec (or running the exec in the bin normally) is showing that it's looking for the project inside a folder with -nopie at the end. Really not sure
09:41:37 <crysikrend> what's going on
09:45:35 <cocreature> crysikrend: are you sure you’re running the newly built executable and not an old version?
09:45:43 <cocreature> crysikrend: also can you show us your cabal file
09:46:21 <jacereda> Can I "cabal sandbox init" programmatically using Cabal library (without cabal-install)?
09:46:51 <crysikrend> cocreature: I deleted the old executable and deleted the entire stack-work folder so it should be all fresh
09:47:16 <cocreature> jacereda: sandboxes are not a Cabal feature but a cabal-install feature so no
09:47:33 <jacereda> cocreature: oh... ok, thanks
09:47:34 <phadej> jacereda: sandboxes are cabal-install purely
09:47:42 <phadej> Cabal- the-lib doesn't know about them
09:48:00 <crysikrend> something to note though, that Intero is using the CORRECT path (I copied the Paths_myProj out of the dist folder and into my src folder so intero can build my project with the autogenned file properly while I'm coding), but this doesn't work when I'm doing stack exec
09:49:13 <phadej> and your copied Paths_nyProj doesn't have "-nopie" ?
09:49:31 <crysikrend> the copied Paths does not contain any -nopie in it
09:49:36 <crysikrend> This is my cabal file https://pastebin.com/ZPMAvKH0
09:49:56 <phadej> (in general, "helping" build tool hardly "helps" ;)
09:50:15 <oo_miguel> I do not understand the error produced by: data Foo = forall a.(Num a) => Foo a deriving Show
09:50:33 <oo_miguel> it tells me to use a "standalone derving declaration" as a fix
09:51:08 <phadej> it's confused, it says yo use standalone deriving declaration so you can provide the context yourself
09:51:12 <oo_miguel> also I am not sure if I reaaly need the forall a.(Num a) constraint
09:51:15 <phadej> i.e. deriving Show a => Show (Foo a)
09:51:35 <cocreature> you can’t make a Show instance for this type that actually shows the "a"
09:51:43 <cocreature> all you get to know about it is that it’s an instance of Num
09:51:44 <phadej> ah sorry, indeed
09:52:03 <oo_miguel> I want a data type , where I can throw in instances of different types (that all will support some common functionality)
09:52:21 <phadej> crysikrend: So I'd recommend to delete your copied Paths_myProj and rather figure out how to make them correct
09:52:21 <oo_miguel> Is it correct to use ExistentialQuialification here?
09:52:38 <phadej> ... them=paths in the Paths_*.hs
09:53:03 <crysikrend> oh phadej you think that the autogenerated paths are incorrect? Even though the ones in there show the right path?
09:53:04 <phadej> crysikrend: also, if you look at the file, you see that it optioanlly reads environment variables, which are useful when developing
09:53:07 <oo_miguel> cocreature: I tried to constraint via (Show a) but this does not let me derive Showing either
09:53:41 <phadej> oo_miguel: then you can try `deriving instance Show Foo` which may work
09:53:50 <iu> Hello! Does (Nothing :: Maybe a) has same representation as (Nothing :: Maybe b)?
09:54:31 <phadej> > unsafeCoerce (Nothing :: Maybe  Int) :: Maybe Char
09:54:33 <lambdabot>  error:
09:54:34 <lambdabot>      Variable not in scope: unsafeCoerce :: Maybe Int -> Maybe Char
09:54:36 <phadej> :(
09:55:54 <crysikrend> okay I'll commit this and work through it phadej
09:55:57 <crysikrend> thanks
09:56:01 <ski> > cast (undefined :: Int) :: Maybe Char
09:56:02 <lambdabot>  Nothing
09:56:48 <phadej> :t cast
09:56:49 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
09:57:02 <hydraz> > coerce (Nothing :: Maybe Int) :: Maybe Char
09:57:03 <lambdabot>  error:
09:57:03 <lambdabot>      • Variable not in scope: coerce :: Maybe Int -> Maybe Char
09:57:03 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
09:57:46 <hydraz> oh that won't work, grr roles
09:57:49 <phadej> (IIRC someone said that Nothing's are the same, and you could even express that in STG, but not before it, i.e. not in Core0
09:59:01 <phadej> (so in general unsafeCoerce'ing of "phantom" branches of sum types should work - but dont' take my word on it)
09:59:09 <hydraz> pretty sure they all are the same, but they're distinguished in Core because of the type applications
09:59:30 <phadej> I.e .you can unsafeCoerce (Left 'a') :: Either Char Int to Either Char WhatEver
10:00:04 <iu> phadej: Great!
10:00:22 <phadej> ... but if you get segmentation fault, blame yourself ;)
10:00:48 <iu> Actually, I have much more complicated task.
10:00:58 <ski> well, if you do `case x of Nothing -> ... ; Just y -> ..y..', then one could argue that the type of `x' in `...' ought to be `forall a. Maybe a', rather than `Maybe T' for some particular type `T'
10:01:32 <ski> (then `Just x >>= k = k x; m >>= _ = m' would work ..)
10:01:33 <iu> Does anyone know any way to create superrecord full of Nothing?
10:01:58 * ski doesn't know what "superrecord" means
10:02:15 <iu> See hackage package "superrecord"
10:02:29 <iu> I is solution for ad-hoc records.
10:02:31 <iu> it*
10:03:21 <iu> It is created like #foo := (10 :: Int) & #bar := "txt & rnil
10:03:34 <EvanR> something like "foo" := Nothing & "bar" := Nothing & ...
10:04:22 <EvanR> the actualy question is what you want the type of this thing to be
10:05:57 <iu> EvanR: I am writing client to REST api. I have superrecord, that represent huge list of optionals.
10:06:02 <EvanR> if you already had a record, you could map each field to Nothing :: Maybe a where a was the type of that field
10:06:32 <iu> EvanR: But I need /some/ value of that type, to start with.
10:06:42 * hackage nuxeo 0.2.0.3 - Nuxeo  http://hackage.haskell.org/package/nuxeo-0.2.0.3 (apeyroux)
10:07:04 <EvanR> for each endpoint in your rest API youll have to specify the big record type somewhere
10:07:50 <iu> EvanR: In case of traditional records, like data Foo = Foo { i :: Maybe Int, s :: Maybe String, d :: Maybe Double }
10:08:07 <iu> EvanR: I could create value full of Nothing with TH
10:08:09 <EvanR> charming
10:08:35 * ski . o O ( `data Foo f = MkFoo {i :: f Int,s :: f String,d :: f Double}' )
10:08:41 <dyl> https://i.pinimg.com/originals/8c/9a/0d/8c9a0d6aca0bbd2e6560f71ce59caf08.jpg
10:08:42 <iu> So I am looking for a way to do the same with superrecord's
10:09:00 <EvanR> and if you had a Record [Maybe Int, Maybe String, Maybe Double] you could also
10:09:09 <ski> dyl : in OCamel ?
10:10:16 <EvanR> i havent seen superrecord be that compelling, i've had some success with vinyl
10:12:08 <iu> I is possible to make what I want with vinyl?
10:12:36 <EvanR> either i explained two ways to do it already or you havent been specific enough with what you need
10:12:56 <EvanR> if you have some record type, you can create a value of one with all Nothings easily
10:13:14 <iu> Let me try explain myself again.
10:13:37 <EvanR> in vinyl to
10:14:55 <iu> With regular data Config = { i :: Maybe Int, s :: Maybe String ... many, many fields }, I can write TH function mkEmpty
10:15:04 <iu> such that (mkEmpty ''Config) :: Config.
10:15:21 <iu> Instead of (Config Nothing Nothing Nothing ...)
10:16:03 <iu> Is there some similar shortcut for vinyl/superrecord?
10:16:37 <EvanR> why TH
10:16:42 * hackage jmacro-rpc 0.3.3 - JSON-RPC clients and servers using JMacro, and evented client-server Reactive Programming.  http://hackage.haskell.org/package/jmacro-rpc-0.3.3 (GershomBazerman)
10:17:32 <EvanR> oh because its a long list. and you have a list of fields somewhere?
10:17:37 <EvanR> field names
10:17:45 <EvanR> is that what youre getting at?
10:18:29 <iu> Well, I have list of fields in type signature.
10:18:36 <EvanR> so you have a type signature
10:19:02 <iu> foo :: Int -> State (Rec '[#foo := Int, #bar := Double]) () -> IO ()
10:19:11 <iu> For example.
10:19:23 <iu> foo :: Int -> State (Rec '[#foo := Maybe Int, #bar := Maybe Double]) () -> IO ()
10:19:31 <EvanR> and its very long?
10:19:42 <iu> Yes, tens of fields.
10:20:31 <iu> And I want some want default value of type Rec '[#foo := Maybe Int, ...] full of Nothing
10:21:28 <crysikrend> phadej: Okay, so on closer inspection the directory returned from getDataFileName can be overriden with an environment variable, so I need to find a way to automatically set the environment variable to wherever the executable is, right? Is there an easy way to do that?
10:24:16 <EvanR> iu: you could do some typeclass and maybe type family magic to construct such a record of your type
10:24:27 <iu> crysikrend: In general, there is no way for compiled binary to locate itself.
10:24:31 <EvanR> i dont see a thing ready made
10:25:14 <iu> crysikrend: for example, because binary may not exist on disk ;)
10:25:15 <EvanR> class BeNothing a where beNothing :: a
10:25:37 <EvanR> instance Rec '[]
10:26:01 <EvanR> instance Rec ts => Rec (t :' ts)
10:26:14 <EvanR> er
10:26:21 <EvanR> instance BeNothing (Rec '[])
10:26:31 <crysikrend> iu: I know there's a way to get the executable path, but I'm not sure if messing with environment variables is necessary? I just want to make my game use assets that are packaged with the executable, but it seems to be a bit tricky? Using getdatafilename right now but without environments it just returns the one in my documents
10:26:36 <iu> EvanR: Thank you for discussion. Will try write class.
10:26:42 <EvanR> instance Rec ts => BeNothing (Rec (Maybe t :' ts))
10:27:38 <Lears> I don't know if this is a good idea or if it will work in your situation iu, but I gather you can derive Default instances with DeriveGeneric/DeriveAnyClass.
10:28:24 <EvanR> iu: with vinyl, this pattern is already defined as RecApplicative
10:28:32 <EvanR> rpure :: (forall x. f x) -> Rec f rs
10:28:54 <EvanR> if f = Maybe, then, rpure Nothing has type Rec Maybe rs
10:29:03 <crysikrend> iu: Looks like file-embed might be what I need instead actually
10:31:40 <EvanR> but by itself that doesnt give you labels
10:38:05 <EvanR> in vinyl you could create a sort of mirror of ElField specialization which allows an f to be applied to all the payload types, but also has a Symbol for lookup
10:41:59 <EvanR> oh nice... vinyl has gotten 'ARec' in a recent update
10:42:09 <EvanR> array backed records
10:44:03 <dyl> Drawing implicit surfaces is fun.
10:44:13 <dyl> Just got my polygonalizer working, now I'm making fun quartics.
10:45:01 <dyl> Goursat's and Chmutov's surfaces (Chmutov is more general) are especially neat.
10:59:10 <jacereda> In .cabal file, how can I make the test suite depend on an executable in that same package? I've tried adding something like exe:foo to the test dependencies but it failed miserably...
11:00:43 <cocreature> jacereda: use build-tool-depends
11:00:48 <cocreature> jacereda: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-tool-depends
11:01:14 <jacereda> cocreature: oh, thanks!
11:14:19 <EvanR> the choice of '=' to mean assignment has caused fake confusion among functional programmers for generations. but <- is two keystrokes (3 on my keyboard for shifting)
11:14:32 <Gobert> is there a way to load two packages in `stack ghci` at the same time?
11:14:34 <EvanR> solution... ⇇
11:16:39 <Gobert> without modifying the .yaml file
11:19:42 * hackage transformers-compat 0.6.2 - A small compatibility shim for the transformers library  http://hackage.haskell.org/package/transformers-compat-0.6.2 (ryanglscott)
11:19:49 <tzh> hi, i've been using LambdaCube for some rendering stuff, and I haven't been able to figure out how to get uniforms to work correctly in shaders, outside of the trivial 'time' one used in all the demos; they all just kinda fail in the shader for reasons i can't figure out. does anybody here have any experience with actually using LambdaCube for anything?
11:20:36 <EvanR> what is the difference between what youre doing and the time examples, also what is the error message if any
11:20:53 <getJiggyWMe> what do you haskellers think about clojure?
11:21:12 <johnw> i generally don't think about clojure
11:22:19 <Tuplanolla> I used it once and found it mediocre, getJiggyWMe.
11:23:01 <jackhill> getJiggyWMe: I like the focus on immutability, but I miss thinking in terms of types. For JVM work there is now Frege and Eta-lang
11:23:21 <EvanR> i was frustrated that even the dynamic type of things was unclear
11:23:44 <EvanR> when you have a "seqqable", its not clear what that is
11:23:58 <EvanR> where as in haskell you know if you have a list, or a vector, or...
11:24:32 <EvanR> i believe the distinction matters
11:25:49 <Tuplanolla> The problem with dynamic types isn't the lack of types itself, but rather the way it doesn't guide people to good designs.
11:26:29 <dyl> Tuplanolla: also lack of documentation of constraints for parameters.
11:26:56 <EvanR> i feel like thats an issue with all lisp based systems
11:27:00 <dyl> You end up with “implicit” overloads where the same function behaves differently with no indication.
11:27:04 <dyl> And JS
11:27:06 <EvanR> even more so that say ruby
11:27:11 <dyl> Massive problem in JE
11:27:12 <dyl> JS*
11:27:30 <EvanR> its not even "arguments can be whatever makes sense to you", its "arguments must be something, but I'm not going to tell you what"
11:29:01 <exarkun> Tuplanolla: By implication, static types _do_ guide people to good designs?
11:29:33 <exarkun> The consequence of which should be that all software written in languages with static typing have good designs?
11:29:50 <exarkun> That verges on being a testable hypothesis...
11:32:23 <tzh> re: LambdaCube uniform shader problems, https://pastebin.com/HyHXyVKY
11:32:39 <tzh> (i tried to make an lpaste but got 'A web handler threw an exception. Details:
11:32:39 <tzh> SqlError {sqlState = "53100", sqlExecStatus = FatalError, sqlErrorMsg = "could not extend file "base/16389/63782": No space left on device", sqlErrorDetail = "", sqlErrorHint = "Check free disk space."}')
11:34:21 <EvanR> lpaste is dead
11:34:35 <tzh> rip
11:34:42 <EvanR> exarkun: people dont have to follow guides, of course
11:35:00 <EvanR> but if there are no guides... that explains a lot of what you see
11:35:23 <tzh> also whoops in my example what i'm actually currently using is that `V3 1.0 0.94 0.88` line, but when i'm trying to get the uniform working i replace that with `Uniform "bgcolor"`, which seems like it ought to work but doesn't
11:36:12 * hackage dotenv 0.5.2.5 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.5.2.5 (camm)
11:39:27 <EvanR> best of both worlds, looks kind of like an equals sign, but arrows are indicating something more sinister is going on http://codepad.org/DAyqAkLP
11:40:00 <exarkun> EvanR: I'd argue there are plenty of guides for plenty of languages with dynamic type systems.
11:40:52 <exarkun> And I don't know how you would differentiate between "guides exist and are largely ignored" and "there are no guides".
11:41:07 <EvanR> that exist as software systems? that are something other than basically a type checker?
11:42:05 <EvanR> guides in dynamic languages stand out to me as word of mouth advice
11:42:27 <EvanR> which can be unreliable!
11:42:56 <EvanR> given just the language itself, indeed, you will have no guidance
11:43:10 <exarkun> Well, I know about prose documentation explaining how to design things.  I know that it exists and what it looks like.
11:43:14 <EvanR> the docs might even explain how "you can do anything"
11:43:19 <exarkun> What does the guidance in Haskell for good design look like?
11:43:19 * shapr hugs exarkun 
11:43:30 <EvanR> scala is unusual in this regard, it says "you can do anything, but you probably shouldnt"
11:43:54 <shapr> exarkun: have you seen matt parson's three layer cake design?
11:44:07 <exarkun> That sounds familiar
11:44:31 <shapr> http://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
11:44:46 <exarkun> oh that's too recent, I couldn't have seen it
11:44:56 <exarkun> shapr: but waaaaaiiiiit
11:44:58 <shapr> ???
11:45:24 <exarkun> shapr: this is just a bunch of english words smashed up next to each other inside an html document served to me over a super outdated network protocol (http/1.1)
11:45:29 <shapr> oh no!
11:45:39 <exarkun> this _isn't_ a static typing system built in to a language
11:45:42 <shapr> pokey will save you!
11:46:04 <exarkun> So ... whatever this essay is discussing, why isn't it just self-evident from the type system?
11:46:24 <shapr> now that I read the backlog, I realize you are trying to prove a point, rather than looking for well written essays on design of haskell apps
11:46:30 <exarkun> shapr: >:)
11:46:43 <exarkun> Only half trying to prove it.  Half interested to hear the other side disprove it.
11:46:47 * shapr destroys another of exarkun's hard drives
11:47:06 <exarkun> still have the pointy shards of the last one?
11:47:21 <shapr> it's been ten years or so, I finally got rid of 'em
11:47:32 <EvanR> if someone in here says "ReaderT MyCrap IO a" that goes a long way because of the ocean of software leading up to that sequence of ascii
11:47:44 <monochrom> shapr: Nice, interesting 3-layer-cake story.
11:47:56 <shapr> now I have a taste for hard drives, like mr croup for ancient figurines
11:48:02 <EvanR> if you take and run with it, you are guided
11:48:42 * hackage pandoc 2.2.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-2.2.1 (JohnMacFarlane)
11:49:02 <shapr> monochrom: I especially like the part where you make a DSL and the interpreter that executes is either your 'mock' or it's the real environment.
11:49:06 <Tuplanolla> What is there to disprove, exarkun? Static types offer principled ways to rule out many bad programs and some good ones, but most importantly limit your creativity. Whether they solve every single problem you have is inconsequential.
11:49:42 <monochrom> Yeah that's where all the dependency injection frenzy happens.
11:49:48 <exarkun> Tuplanolla: "principled"?  That is not a technical term, is it?
11:50:05 <monochrom> I actually taught that technique in my course.
11:50:06 <exarkun> (If it is, where can I read about its meaning?)
11:50:33 <Tuplanolla> They're principled in that they tend to be rooted in mathematical logic.
11:51:08 <exarkun> Okay, here's another way to frame my question
11:52:19 <monochrom> Extremely smart people such as Alan Kay are happy to trash static typing (and generally static anything).  And they are right --- for themselves.  They are too smart to need discipline and checks and balances.
11:52:28 <exarkun> I wrote Python for 19 years (after some C, C++, Java, a few other sundries).  I'm just starting with Haskell.  How do _I_ get clued in to the magic of Haskell's type system so all my designs are good?  I don't want to end up some rube who misses the guidance and produces only junk.
11:52:53 <monochrom> Exactly what's wrong with opinion leaders' opinions.  Only work for such smart people.
11:52:58 <exarkun> monochrom: trouble with "right for themselves" is that most software needs to get maintained and most people eventually die or at least get bored and move on.
11:53:27 <exarkun> So "right for themselves" has extremely limited utility
11:53:37 <Tuplanolla> I should note that types aren't the only way to impose such restrictions. If you write your C programs without using `malloc` for the most part, they tend to turn out much better.
11:53:42 <exarkun> And "process X works fine on my brain for reasons I can't explain" is kind of a cop out anyway.
11:53:52 <veverak> Tuplanolla: true to that
11:54:01 <dyl> monochrom Python is one counterpoint.
11:54:11 <monochrom> Similarly when a humanity prof asserts that human are intelligent and innovative and all those nice things (esp. compared to computers), they only have other profs in mind.
11:54:11 <dyl> Despite having a BDFL, it's pretty usable for the vast majority of people.
11:54:15 <Tuplanolla> Niklaus Wirth has written a lot about this.
11:54:36 <dyl> Types are a *statically enforced* discipline.
11:54:50 <dyl> If you always work on C with address sanitization, guard malloc, valgrind, etc
11:54:58 <exarkun> Tuplanolla: I assume you mean "without heap memory allocation" and not "and write your own heap allocation manager and call an alloc function from that"
11:54:59 <dyl> Then you're probably going to end up writing much better code and waste less time.
11:55:27 <dyl> A typechecker is particularly useful in that it provides value not only to the programmer, but also their users, and the compiler itself.
11:55:33 <exarkun> dyl: Okay, I buy all that.
11:55:40 <exarkun> Was "good design" just a poor choice of words?
11:55:46 <exarkun> Are we just talking about "less buggy software"?
11:55:53 <dyl> No, "good design" is just exceptionally vague.
11:55:55 <exarkun> You can have software with few bugs but totally awful design.
11:56:01 <dyl> You can't talk about what "good design" is without talking about the user.
11:56:09 <dyl> Design does not exist in isolation from the user.
11:56:36 <Tuplanolla> Well, there's no concept of "heap" in the language, but you understood what I'm saying anyway, exarkun.
11:56:48 <exarkun> I don't know if Tuplanolla agrees since he said types offer a way to rule out problems with a basis in math (and math is universal).
11:57:24 <exarkun> Tuplanolla: I had to think about what you said three times to come up with an interpretation that seemed to make sense in context.  So I really did want clarification.
11:57:35 <dyl> Engineering constraints offer a way to rule out problems in a building with a basis in math and physics.
11:57:44 <dyl> but if you make the door two feet fall, it doesn't matter how stable it is.
11:57:50 <dyl> No one can get through the damn door.
11:58:05 <EvanR> shapr yeah that post points out the "submonads ala carte" pattern... i wonder...
11:58:20 <shapr> dyl: I'd argue that the developer is also a user of the software, but from the perspective of changing the source
11:58:29 <dyl> I think the problem is that when we talk about the goodness w.r.t "design" of a program, we're not really talking about the *design* itself, but how consistent the design principles in use are.
11:58:30 <EvanR> at least they recommend keeping that layer as thin as possible
11:58:36 <dyl> We're using "design" as a proxy word for other things.
11:58:42 <monochrom> dyl: I have a conjecture from a different angle, basically reversing the cause and effect. Python enjoys a vast majority because it takes that many people to do so little. I would say the same about C before Python came about.
11:58:49 <exarkun> dyl: many, many people have a dimension that measures less than 2'
11:59:13 <shapr> how about replacing "design of software" with "ease/speed of changing the source to meet changing business requirements" ?
11:59:19 <dyl> The only 2' door I can think of that people regularly go through is that of a crematory.
11:59:31 <dyl> [macabre intensifies]
11:59:34 <monochrom> I.e., a language that attracts more bugs also causes companies to hire more people to fight it, therefore the mind share balloons!
11:59:37 <tdammers> most people don't do that more than once though
11:59:45 <dyl> tdammers ...most people?
11:59:47 <shapr> playground equipment often has two foot doors
11:59:56 <shapr> dyl: somebody has to clean that thing
11:59:57 <dyl> I mean, I assume someone's faked their death in this manner.
12:00:02 <monochrom> Hey I think I've just nailed the reason why horrible languages are more popular!
12:00:04 <dyl> shapr oh, yeah.
12:00:05 <fishythefish> shapr: stop playing in crematoriums
12:00:19 <shapr> nah, good friend of mine works at one
12:00:49 <monochrom> To be sure, absolutely no data to support it, but hey, people also get to say crap like "in theory, theory is the same as practice" and face no scrutiny, right? RIGHT?
12:00:53 <dyl> monochrom http://www.stokely.com/lighter.side/stroustrup.html
12:01:21 <dyl> "First, I've put in enough pitfalls to make sure that only the most trivial projects will work first time. Take operator overloading. At the end of the project, almost every module has it, usually, because guys feel they really should do it, as it was in their training course. The same operator then means something totally different in every module. Try pulling that lot together, when you have a hundred or so modules. And as
12:01:21 <dyl>  for data hiding. God, I sometimes can't help laughing when I hear about the problems companies have making their modules talk to each other. I think the word "synergistic" was specially invented to twist the knife in a project manager's ribs." - "Stroustrup"
12:01:44 <dyl> "Remember the length of the average-sized "C" project? About 6 months. Not nearly long enough for a guy with a wife and kids to earn enough to have a decent standard of living. Take the same project, design it in C++ and what do you get? I'll tell you. One to two years. Isn't that great? All that job security, just through one mistake of judgement."
12:01:46 <shapr> I do believe that types in Haskell prevent some flavors of bugs I've seen in Python code.
12:02:40 <tdammers> types in Haskell make it easier to avoid some flavors of bugs more easily than in Python
12:02:54 <dyl> Haskell also requires more up-front architecting before you can solve a problem though.
12:03:02 <shapr> really?
12:03:03 <tdammers> nah
12:03:05 <dyl> It depends.
12:03:11 <exarkun> dyl: I've heard that idea before
12:03:14 <dyl> For a nontrivial problem?
12:03:19 <shapr> I've often advertised Haskell as compile-time Python.
12:03:20 <exarkun> dyl: And that's getting back to my original question
12:03:21 <tdammers> I rarely architect my Haskell code beforehand
12:03:28 <tdammers> architecture unravels as I code along
12:03:28 <dyl> You have to spend at least three days meditating under a waterfall.
12:03:30 <exarkun> dyl: What is this up-front architecting?
12:03:35 <dyl> Then fifteen minutes emitting fold expressions.
12:03:44 <exarkun> What if you don't have a waterfall?  Can you still be a Haskell programmer?
12:03:58 <dyl> tdammers Haskell is much nicer to do refactoring in though.
12:04:01 <dyl> An order of magnitude or two.
12:04:13 <shapr> I just get my code ugly-hack working, then come back and simplify/improve.
12:04:23 <dyl> exarkun just run a hose out of your upstairs window and sit on the lawn
12:04:24 <fishythefish> up-front architecting is fixing your types in order to compile rather than in reaction to runtime errors
12:04:27 <EvanR> i want the non trivial problem presented as a series of trivial problems
12:04:27 <monochrom> Just take a shower. :)
12:04:30 <tdammers> I basically think about the problem for a while, until I go "oh, hey, let's see, what have we got", and then I write down some code
12:04:39 <EvanR> then i will trivially solve it with haskell
12:04:52 <dyl> I've been trying to figure out if I can stick a waterwheel in my bathtub, run the faucet over it, and use it to charge my phone for free.
12:04:56 <EvanR> because in other languagse trivial problems have to be solved with non trivial means
12:04:58 <dyl> I don't pay for water, but electricity is expensive.
12:05:07 <tdammers> and then I play with it, change it, add stuff, generalize, reduce, refactor, and structure appears as a result
12:05:22 <dyl> If I run a hose over the curtain bar, the additional height should also help.
12:05:25 <monochrom> Haha dyl
12:05:35 <opsman> Learning Haskell: head . tail . words "The second word is" ; results in error. But (head . tail . words) "The second word is" executes correctly. What's the significance of the paren?
12:05:49 <tdammers> opsman: precedence.
12:06:00 <tdammers> opsman: function application binds more tightly than any operator
12:06:07 <dyl> > head . tail . words $ "The second word is"
12:06:08 <lambdabot>  "second"
12:06:11 <monochrom> x . y z = x . (y z) ≠ (x . y) z
12:06:15 <dyl> Remember, dot dot goose.
12:06:16 <EvanR> you wrote head . tail . (words "the second word is")
12:06:30 <shapr> exarkun: that's a good question, have you found any resources for getting clued into good ways to write Haskell?
12:06:39 <EvanR> which is busted because the last arg to . is not a function
12:06:54 <dyl> :t ($)
12:06:55 <lambdabot> (a -> b) -> a -> b
12:07:10 <dyl> head . tail . words $ "The second word is" === (head . tail . words) "The second word is"
12:07:12 <dyl> In effect.
12:07:30 <shapr> exarkun: I've been learning some rust recently, most code I've seen is the opposite of Haskell in terms of 'control flow'
12:07:31 <exarkun> shapr: not really.  I started reading _Haskell Programming (from first principles)_ but I haven't gotten very far yet.
12:07:41 <opsman> dyl...i like that better
12:07:56 <opsman> thanks
12:08:05 <exarkun> shapr: And I just spent 3 weeks reading/learning ocaml instead and also had some other non-haskell distractions before that.
12:08:08 <shapr> exarkun: for smaller apps, I see lots of Haskell code with a single top level loop that does IO stuff, and that calls pure functions
12:08:10 <dyl> Where did I hear it as dot dot goose?
12:08:15 <exarkun> I hope learning ocaml hasn't ruined all my haskell understanding.
12:08:16 <dyl> I think someone here right now said that ~6 years ago.
12:09:20 <shapr> rust code is the other way around, all the 'real stuff' happens deep inside the code, I hear they want memory allocation and collection to happen as close as possible to use of the data
12:10:17 <EvanR> RIAA
12:10:22 <EvanR> waits thats something else
12:10:27 <exarkun> shapr: what I know about rust seems to mesh with that
12:10:41 <exarkun> all those different variable types carrying allocation information
12:10:44 <fishythefish> get your code certified RAII platinum
12:10:52 <danilo2_> Hi guys! Are there any tools that would allow me to discover where my programs lose strictness? sometimes values get boxed and unboxed and im loosing performance. analysing it by hand is tedious and error prone
12:11:39 <shapr> danilo2_: have you tried profiling?
12:12:03 <exarkun> shapr: So maybe Rust is a better "system programming" language than Haskell.  If "system programming" actually means anything.  Also maybe it's not, who knows.  Does anyone actually know what techniques result in better results?  Probably not.  I'm betting on Haskell because I think it's more expressive so at worst ghc will emit Rust-competitive native code in 10 years (if not today).
12:12:10 <danilo2_> shapr: are there any profiling options which could tell me where exactly in the code (which variable) causes the problem ?
12:12:22 <shapr> I don't know
12:12:33 <danilo2_> shapr: maybe I just dont know the exact tool that is available (that would be awesome to have one).
12:12:56 <EvanR> theres something called retainer profiling which tells you what is holding memory
12:13:09 <danilo2_> Right now Im just putting bangs here and there in the code and benchmark it constantly. But often I just forget to put it somewhere and I see my benchmarks drop down
12:13:09 <shapr> exarkun: I think part of the divide between Python and Haskell is similar to the divide between vim and emacs, it's a 'workflow' thing.
12:13:16 * hackage tasty 1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-1.1 (RomanCheplyaka)
12:13:39 <shapr> vim users I know change into a dir and edit a file, and loop
12:13:50 <exarkun> shapr: well, it's clearly possible to write acceptable software in both vim and emacs and it's clearly possible to write acceptable software in both python and haskell.
12:13:52 <danilo2_> EvanR: actually in my examples nothing is holding memory (unless im wrong). The values are boxed and unboxed unnecessary between funciton calls and it couses slowdown + probably more GC
12:13:55 <shapr> emacs is usually a long running process that has all the files in a project open
12:14:26 <exarkun> shapr: I suspect our difficulty comes in an inability to measure much more precisely than "acceptable" or "not acceptable" (and, frankly, even that bar is too high for us).  How can you evaluate tools if you can't evaluate outcomes?
12:15:02 <tdammers> I think Python vs. Haskell is a bit deeper than vim vs. emacs
12:15:13 <shapr> exarkun: I agree, the 'engineering' part of SE is a lie
12:15:18 <exarkun> +1
12:15:38 <shapr> exarkun: my solution to that problem is to try to learn as many different tools and choose for myself
12:15:40 <EvanR> software interpretive dance
12:16:14 <exarkun> shapr: my solution is that I wrote "Computer Programmer" instead of "Software Engineer" whenever it comes up.
12:16:54 <shapr> yeah, I also prefer 'coder' or 'programmer' because that's the action, and I don't see much feedback in software companies.
12:17:07 <EvanR> coder < programmer < engineer
12:17:10 <monochrom> Programmers cannot have quantitative skills or even minds.  Those who have go to more profitable and pleasant careers.
12:17:22 <dyl> coder < programmer < engineer < sleep deprivation specialist
12:17:50 <dyl> monochrom Sure we do. Our ability is quantified by how rapidly we can program ourselves out of our own job.
12:17:52 <dyl> ;)
12:17:54 <EvanR> class Coder a => Programmer a where
12:18:09 <dyl> class Der a ⇒ Coprogrammer a where
12:18:10 <EvanR> hey ive done that
12:18:17 <EvanR> do i get a gold watch
12:18:37 <dyl> No, that's in 20 years. For now you get a bag of hershey's kisses and a laminated paper plaque
12:18:51 <dyl> Now here's a box, have everything gone by 4PM.
12:18:57 <EvanR> can i at least get a gift card to long john silvers
12:19:11 <dyl> No, but you can have one for the Cracker Barrel
12:20:33 <dyl> EvanR and here's an expired massage coupon
12:21:38 <shapr> exarkun: do you have any hand wavey thoughts comparing Python and Haskell?
12:21:42 <shapr> perhaps a blog post?
12:22:08 <dyl> I would love to see a collaborative blog or aggregator a la LtU called "The Hand Wave"
12:22:52 <tdammers> I got around the problem quite elegantly - my current job title is "Haskell Consultant"
12:22:53 <tdammers> whee
12:23:11 <dyl> At one point my job title (per by business card) was “Mathemagician”
12:23:58 <dyl> For whatever reason they let me review the InDesign layout before we send it out for print, and the designer didn’t mind. 500 cards later and it was too late to undo.
12:24:45 <exarkun> shapr: I have so many thoughts
12:24:54 <exarkun> shapr: I think them almost continuously, you know
12:25:10 <exarkun> shapr: If you can recommend anything for this, I would appreciate it
12:26:20 <EvanR> "Software Interpretive Dancer"
12:26:24 <dyl> exarkun: a keyboard is a good start
12:26:43 <dyl> EvanR: “Cyber Entomologist”
12:26:53 <EvanR> lol
12:27:24 <exarkun> I liked Vinge's notion, Software Archeologist.
12:27:41 <exarkun> dig through all those old layers of trash, see if you find anything good
12:27:47 <exarkun> or at least anything you can make sense of
12:27:47 <EvanR> Web Janitor
12:29:00 <EvanR> layers on a good day
12:29:10 <EvanR> spaghetti on a slightly worse day
12:29:27 <shapr> exarkun: I write down my thoughts, that gets them out of the way and makes space for new thougths!
12:29:30 <EvanR> probably looks more like compost
12:30:18 <exarkun> shapr: Sometimes I contemplate doing that again but not online.  I can't imagine any of the things I think actually proving interesting to anyone.
12:30:28 <EvanR> hasn't stopped most people
12:30:37 <exarkun> Yes, well, I rather wish it would.
12:30:44 <EvanR> haha
12:31:18 <tdammers> running kind of works for me
12:31:46 <tdammers> shuts up the thoughts that are useless, leaving me with just the important & productive ones
12:35:03 <exarkun> I dug a bunch of holes this morning, that was pretty nice
12:48:12 * hackage simple-vec3 0.4.0.4 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.4 (DmitryDzhus)
13:00:05 <aarvar> exarkun: try twitter
13:04:16 <ertes> exarkun: our guides are mathematics, especially algebra…  most of the dynamic world is guided by OO patterns that is mostly busy solving problems OO introduced in the first place
13:05:15 <ertes> if OO is the solution to everything, then obviously AbstractServiceManagerFactory is part of that solution
13:05:31 <ertes> it doesn't do much, but **it's the right way**!!!!!!!
13:11:30 <paidnode> I think I found the base question I tried to get an answer for here in the last couple of days
13:12:12 * hackage btree 0.3 - B-Tree on Unmanaged Heap  http://hackage.haskell.org/package/btree-0.3 (andrewthad)
13:14:19 <paidnode> Say you have f :: Maybe a -> b. you pattern match on the argument and if it's just a... I want to have a function just a -> b that I can call there. So that I can guarantee that there's always going to be a value passed to it, e.g. because Im calling fromjust (doesnt necessarily makes sense with Maybe, but it's the simplest example)
13:14:39 <eacameron> Is there a simple function like concatMapStringsSep but takes an attrset instead?
13:14:52 <eacameron> Whops wrong channel
13:15:21 <ertes> :t maybe
13:15:22 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:15:27 <ertes> paidnode: ^
13:15:40 <noan> paidnode, fmap thefunc theMaybe
13:15:56 <noan> :t fmap
13:15:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:16:10 <paidnode> I dont think I can make my type into a functor
13:16:20 <noan> paidnode, Maybe is a functor
13:16:35 <ertes> fmap preserves the 'Maybe' though
13:17:00 <noan> oh, did you want a default value, paidnode?
13:17:35 <noan> in which case, yes, you want the maybe function
13:17:37 <noan> :t maybe
13:17:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:18:24 <jle`> i'm not even sure what the question is
13:18:41 <ertes> me neither, it just screams 'maybe' at me =)
13:18:51 <jle`> it's not quite clear, and i don't think there is evena  question in those sentences
13:19:03 <noan> da
13:19:15 <ertes> ok, i admit: in reality it screams "catamorphism!" at me
13:19:46 <jle`> it's a haskell rorschach test
13:19:59 <ertes> heh
13:20:20 <noan> jle`, It's clearly an inappropriate sexual image involving my mother, thanks Freud.
13:20:21 <paidnode> that example backfired slightly, the suggestion is great for functors, but I have a simple enum like data type A | B | C and would like a function that e. g. only accepts As
13:20:29 <ertes> "what do you see in this pattern?" – "free monads" – "what?"
13:20:46 <jle`> paidnode: what is your actual question?
13:21:28 <noan> paidnode, I think that's a type error. Like... it's analogous to a function that doesn't accept booleans, it only accepts True
13:21:32 <ertes> paidnode: if your function takes a Bool, but only really wants to deal with False, why does it take the Bool in the first place?
13:22:24 <noan> a function can provide different implementations based on the value from pattern matching, but it still needs to handle all potentialities or default the others.
13:22:46 <paidnode> (context: https://www.reddit.com/r/dailyprogrammer/comments/27h53e/662014_challenge_165_hard_simulated_ecology_the/)
13:24:41 <paidnode> say A is a bear and has Coordinates. Want to change the coordinates, and want to change accordingly where the bear is stored in a 2d matrix (just starting to think the 2 are redundant, ignore the redundacy of the bear having coordinates and being stored in a matrix for now)
13:25:41 <paidnode> reason why I want this... with data Bear | Tree | Lumberjack I would like to be able to guarantee that I do not accidentally move a tree, as an example
13:26:12 * hackage simple-vec3 0.4.0.5 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.5 (DmitryDzhus)
13:26:30 <jle`> what is a 'three dimensional vector'? ;)
13:27:04 <jle`> oh it's actually a three-vector like it should be
13:27:10 <jle`> neat
13:29:18 <paidnode> I must be missing something because although I kind of understand why I can't do this, the requirement feels extremely basic
13:31:06 <noan> paidnode, https://pastebin.com/xBHCVjRd
13:31:06 <noan> ?
13:33:56 <paidnode> noan yes, that's where  I started, the problem is the type of the doThingWithTree function
13:34:18 <noan> paidnode, I'd need a more specific example honestly.
13:34:58 <noan> obviously that function isn't really a function. that's the result value. and since it is mapping a constant value, the result is constant.
13:35:02 <noan> so it's still kind sillies
13:35:15 <monochrom> paidnode: If you need a function that accepts x and not y, and you want to enforce this by static typing, then logically x and y cannot have the same type.
13:35:22 <noan> da
13:35:32 <crestfallen> hi is Test.QuickCheck not in the stock ghci ? .. ie do I need to run a stack project ?
13:36:08 <dyl> Ok so...
13:36:18 <dyl> Do we really not have up to date Haskell SIMD bindings?
13:36:18 <noan> crestfallen, I think ghci only includes the Prelude by default?
13:36:19 <dyl> https://hackage.haskell.org/packages/search?terms=simd
13:37:07 <dyl> Looks like there's this: https://ghc.haskell.org/trac/ghc/wiki/SIMD
13:37:07 <monochrom> Your other choice is to give up static enforcement.
13:38:16 <dyl> Kinda looks like that fizzled.
13:38:22 <crestfallen> noan: thanks, yeah ' import Test.QuickCheck ' won't work
13:38:24 <ZeuPiark> hello
13:38:30 <AndreasK> dyl:  There is a gsoc project about simd this year
13:38:36 <dyl> Neat!
13:39:01 <AndreasK> crestfallen: You need to tell ghci to load the quickcheck package (assuming that's installined in your global package space)
13:39:29 <AndreasK> crestfallen: eg ghci -package QuickCheck (or however it is spelled)
13:40:02 <crestfallen> AndreasK: so odd, it's working now with import Test.QuickCheck    thanks
13:40:29 <paidnode> noan https://pastebin.com/2a8t7a8T
13:41:01 <AndreasK> dyl: https://summerofcode.withgoogle.com/projects/#5641742712307712
13:41:32 <dyl> Bah! It's not parallelizing :p.
13:41:34 <dyl> It's vectorizing.
13:42:32 <aarvar> @tell dmwit in your answer the only things you can do with a FilterType are (simplfying slightly) `makeFilter :: FilterType a -> IO a` and `filter :: FilterType a -> a -> Filter`. What's the point of `a` then? Why not just have a non-gadt FilterType with `makeFilter :: FilterType -> IO FIlter`? Or even just define `type FilterType = IO Filter`?
13:42:33 <lambdabot> Consider it noted.
13:43:22 <noan> paidnode, https://pastebin.com/WRRh63vA I halfassed it
13:43:33 <AndreasK> Yeah vectorize would be better, but I don't know much more than what is on that page about it
13:44:10 <noan> paidnode, but I imagine what you need is not a function Whatever -> Whatever, since you're doing repositioning of elements of a greater context.
13:44:22 <noan> unless I'm wrong about the problem, I haven't read it
13:45:18 <aarvar> @tell dmwit er, by Filter there I mean Record -> Bool, not your Filter type
13:45:18 <lambdabot> Consider it noted.
13:45:54 <paidnode> noan tbh although this is pretty much equivalent to case statements that I used, it feels much closer to what I want
13:46:13 <paidnode> because... separate function bodies for the patterns
13:46:34 <noan> paidnode, haskell magic
13:47:36 <paidnode> the problem was I wanted to pass control from a case statement, to a function that accepts only Trees, to not have all the logic in a case statment. Theoretically, if it would be a lot to cram all in there
13:48:15 <paidnode> now doing absolutely the same thing using pattern matching... it kinda solves the problem
13:49:45 <paidnode> also somewhere along the way I probably lovked my mind into a data Superclass = SubclassA | SubclassB thing, to me the problem screamed subtypee polymorphism / OOP
13:51:09 <aarvar> first rule of OOP: every problem screams OOP, whatever OOP is
13:51:55 <dyl> pass the message on aarvar
13:53:36 <trcc> Is there a datatype in Haskell with just Success or Failure?
13:54:10 <paidnode> jesus, this suddenyl started to feel so unidiomatic: https://pastebin.com/1RuJtuAv
13:54:16 <aarvar> trcc: like Bool but not?
13:54:23 <trcc> hehe aarvar yes
13:54:35 <aarvar> trcc: I actually defined that type like a week ago
13:54:49 <paidnode> yeah well no s..., it can't even be done properly, how could it be idiomatic then
13:54:57 <monochrom> I'm pretty sure subclassing is wrong for this too.
13:55:01 <aarvar> trcc: also considered using Either () ()
13:55:15 <monochrom> I mean if "move" is a method in the superclass.
13:55:17 <trcc> aarvar: me too, just looks a bit awkward
13:55:23 <aarvar> or And Bool
13:55:25 <aarvar> or whatever
13:55:40 <infinisil> trcc: Just `data Result = Success | Failure`?
13:56:10 <trcc> infinisil: ya. Just do not want to create my own, if there is also one supported by several modules
13:56:11 <aarvar> pattern Success = Left () ?
13:56:11 <paidnode> with Subclassing you can have an upper leve function taking a superclass and passing it to functions taking only one of the subclasses
13:56:40 <monochrom> Tree and bear have vastly different properties (for all practical purposes). It is questionable to put them under the same type, even if it just means the same superclass.
13:57:13 <aarvar> er, Right
13:57:19 <aarvar> pattern Failure = Left ()
13:57:34 <paidnode> monochrom what if you need to jold all that in a list or a matrix?
13:57:42 <paidnode> that was the plan
13:57:50 <aarvar> hold all what?
13:58:03 <trcc> Thanks
13:58:09 <aarvar> just have a matrix of the sum type?
13:58:50 <monochrom> Well then, that forces the same-type-ness and so now you have to do run-time checks of "oh this is a tree, moving is a run-time error".
13:59:41 <monochrom> Or worse, "moving is an error but we ignore it silently so as to confuse the rest of the code"
13:59:43 <paidnode> monochrom, yes, but isn't that what pattern matching is (among other things)? This is done routinely in FP, although considered antipattern in pure OOP
14:00:18 <paidnode> I meant the type checks
14:00:25 <paidnode> oc
14:02:32 <monochrom> I might not care about "I have a grid containing a few trees, bears, and dwarfs" as a premise in the first place.
14:03:55 <monochrom> Depending on the application, I might model "I have a bear. What things nearby can it interact with?" instead.  Then I don't store a grid at all.  I store a network.
14:04:10 <monochrom> And also write down the axioms of the interactions.
14:05:06 <monochrom> And then depending on what axioms I end up with, I may or may not need a sum type for those nearby things.
14:06:38 <monochrom> Whether I store a grid or I store a network depends on the application and what it asks for and what it doesn't.
14:07:33 <monochrom> But my point is just because a problem statement contains the catch-phrase "grid" in it doesn't mean I'll code up like that.  The actual axioms are more important then the intuitive story-telling.
14:07:46 <monochrom> In fact screw intuition. Always.
14:11:47 <paidnode> monochrom yeah I said earlier that the grid / matrix is probably redundant if my "entities" are going to store their coordinates. although I'd still need to store them in a list, so... but the network suggestion and acess to e.g. pos(0,0) it would work
14:12:05 <paidnode> anyway, I brought up the grid for the sake of argument
14:12:17 <monochrom> Perhaps separate into list of bears, list of trees, and list of zombies.
14:13:04 <monochrom> And perhaps the only thing common in all three types is that all have an ID. The ID is useful for the following:
14:13:49 <monochrom> For the sake of "someone cannot move into a place already occupied by someone else", you keep a dictionary from occupied positions to IDs.
14:14:17 <monochrom> So this happily avoids a sum type or superclass.
14:15:58 <enterprisey> How would I make a Hedgehog generator like "pick 30 arbitrary elements from this list"?
14:16:24 <enterprisey> Gen.subsequence would be ideal for this except I can't tell it a desired number of elements
14:16:25 <monochrom> What is Hedgehog?
14:17:03 <enterprisey> A very cool library that lets you make randomized tests
14:17:19 <Ariakenom> It's quickheck
14:17:24 <Ariakenom> afaik
14:17:40 <enterprisey> yeah
14:17:50 <monochrom> I only know how to make a random permutation. I might just do that first then "take 30".
14:17:58 <enterprisey> this is an infinite list
14:18:28 <monochrom> Infinite list eh? Is this equivalent to "pick a natural number randomly with uniform distribution"?
14:18:35 <monochrom> I.e., DNE
14:18:35 <enterprisey> not really
14:18:51 <enterprisey> the specific use case here is generating 30 random identifiers to create a program
14:18:54 <jle`> enterprisey: how can you take 30 arbitrary elements from an infinite list
14:19:05 <jle`> what sort of distribution would you want
14:19:05 <enterprisey> I am now realizing that my question was silly
14:19:10 <enterprisey> lol
14:19:42 <monochrom> You are supposed to confess, for example, that shorter names are more likely than longer names. Because uniform distribution for this DNE.
14:20:04 <Tuplanolla> What actually is the natural answer there, jle`?
14:20:39 <enterprisey> (I'm just going to constrain the list so that it's like 300 elements and then do monochrom's approach
14:20:41 <enterprisey> )
14:20:49 <Zemyla> :t \m -> ContT $ \f -> fmap Free $ traverse f m -- I'm kind of wondering what exactly this sort of thing does.
14:20:50 <lambdabot> error:
14:20:50 <lambdabot>     Data constructor not in scope: Free :: t b -> b
14:21:01 <Zemyla> @let import Control.Monad.Free
14:21:02 <lambdabot>  Defined.
14:21:06 <Zemyla> :t \m -> ContT $ \f -> fmap Free $ traverse f m
14:21:08 <lambdabot> (Applicative f2, Traversable f1) => f1 a1 -> ContT (Free f1 a2) f2 a1
14:21:08 <jle`> Tuplanolla: there's no way to uniformly pick so you can do something like a geometric poissony thing
14:21:17 <jle`> and bias towards a given center
14:21:20 <monochrom> I'm going to do one in which earlier items are more likely than later items.  For each item in the infinite list in that order, toss a coin to decide whether you adopt it or skip it.  Do this until you collect 30.
14:21:28 <dyl> jle` Poisson makes me hungry.
14:21:40 <jle`> enterprisey: where are you getting your list from?
14:21:53 <enterprisey> jle`: because it's identifiers, I'm just gonna do "x" plus a number
14:21:55 <jle`> dyl: poisson distribution is a fish market app
14:22:01 <enterprisey> actually my question is even sillier than I thought
14:22:07 <jle`> enterprisey: are you trying to make a random identifier?
14:22:11 <enterprisey> I should just do x0 .. x30
14:22:18 <monochrom> :)
14:22:20 <enterprisey> big facepalm
14:23:19 <jle`> love seeing classic XY problems in the wild :)
14:23:34 <hololeap> i've read some things saying that ghc has an easier time optimizing higher-order functions as opposed to explicit recursion. can this function be improved in this way or is it pretty much idiomatic as it is? http://dpaste.com/2HFD755
14:24:34 <jle`> i think it's idiomatic as it is
14:25:00 <jle`> > let xs = [1..10] in zip xs ((Just <$> tail xs) ++ [Nothing])
14:25:02 <lambdabot>  [(1,Just 2),(2,Just 3),(3,Just 4),(4,Just 5),(5,Just 6),(6,Just 7),(7,Just 8...
14:25:06 <monochrom> Naw. Instead, GHC has an easier time optimizing functions in the standard library that come with rewrite rules.
14:25:10 <jle`> > let xs = [1..3] in zip xs ((Just <$> tail xs) ++ [Nothing])
14:25:12 <lambdabot>  [(1,Just 2),(2,Just 3),(3,Nothing)]
14:25:36 <monochrom> In other words if you have a higher-order function you wrote yourself and no one endowed it with rewrite rules for fusion for example, then no optimization happens.
14:25:55 <Tuplanolla> I'd guess negative binomial distribution, jle`.
14:26:11 <dpyro> is there any standard way to swap monads? something like m a → n a?
14:26:22 <jle`> dpyro: no
14:26:25 <jle`> every monad is different
14:26:34 <dpyro> that's what i was suspecting
14:26:58 <jle`> but the general pattern of swapping functors is called a natural transformation
14:27:04 <jle`> :t listToMaybe
14:27:05 <lambdabot> [a] -> Maybe a
14:27:09 <jle`> :t maybeToList
14:27:10 <lambdabot> Maybe a -> [a]
14:27:11 <jle`> ^ like those
14:27:25 <monochrom> Is there a specialized name for XY problems in which Y is too much more general than X? Or is it in practice all XY problems are like that so no need for a second name?
14:27:49 <jle`> i think normally XY problems are not necessarily more general, just different
14:28:36 <hololeap> thanks everyone
14:29:01 <monochrom> I might coin "XH problems" to hyperbole that when Y is too general it is like (or can be exaggerated to) "I need to solve X, I think I can solve it after solving the Halting Problem".
14:29:03 <jle`> hololeap: if you use zip then it will fuse with other list functions etc.
14:29:30 <jle`> but also the zip solution i used earlier sort of breaks fusion in one direction since it duplicates usage of xs
14:29:48 <monochrom> For example in math channels students ask "how do I solve equations?" when they just need linear equations in one variable.
14:30:15 <jle`> heh
14:30:28 <jle`> like a terminal object in the category of XY problems
14:31:19 <jle`> where morphisms are generalizations
14:31:38 <sm> hey all, is there a trick to passing RTS options from ghci ? having trouble
14:31:41 <monochrom> Some people had actually asked "is there a general method for integrals?"
14:32:15 <monochrom> Like this? ghci +RTS -M3M
14:32:36 <monochrom> Who is the intended audience for the options?
14:32:43 <sm> no I mean from the ghci prompt, like :main ... +RTS ...
14:32:55 <sm> +RTS gets treated as a regular argument in that case
14:33:18 <monochrom> I see, but that can't be done because :main doesn't enjoy a separate run-time system.  It uses the same run-time system as ghci's.
14:33:49 <sm> drat. I want to run the program from GHCI, and see GC stats. So I guess that's not supported
14:33:53 <paidnode> monochrom et. al. thanks for all the thoughts and suggestions, got some stuff to think about now.
14:34:05 <monochrom> So for example if you want your program to run under 3MB memory then you have to confine the whole ghci to 3MB memory (or 3MB + whatever you think ghci needs)
14:34:18 <sm> or.. I see. Do what you said
14:35:13 * sm experiments
14:35:15 <monochrom> For profiling purposes it is best to profile compiled code instead. Because in ghci it's hard to separate ghci's own work and your code. The nature of interpreter.
14:35:32 <monochrom> At least not how ghci is written.
14:36:50 <monochrom> Although, ghci can count some kind of "memory used and # of steps used" for your program (and not mixed up with ghci's own work).
14:37:12 * hackage hslua 0.9.5.2 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.9.5.2 (tarleb)
14:37:35 <monochrom> Turn on by :set +s
14:38:16 <monochrom> But do read the GHC user's guide on what statistics it gives. It is pretty treacherous actually.
14:38:20 <hololeap> i'm actually a bit lost on what list/stream fusion is, how to use it, and whether or not it's implemented in the standard base functions. i read this SO answer, and it made sense, but it's also 9 years old: https://stackoverflow.com/a/580172
14:38:43 <dyl> hololeap best example is map map fusion.
14:39:14 <dyl> map f1 (map f2 xs)) === map (f1 . f2) xs
14:39:20 <dyl> Basically. I might have screwed that up a bit.
14:39:26 <monochrom> List fusion is implemented as rewrite rules for most standard-library list functions.
14:39:51 <monochrom> Stream fusion for vectors is also implemented in the vector library.
14:40:07 <sm> monochrom: thanks. Just a little bit of info while optimising would help. Actually I was hoping to get it working from ghcid --test
14:40:22 <monochrom> When I need to be sure I read core code.  Benchmarking is also informative.
14:40:28 <hololeap> dyl: that makese sense
14:40:39 <hololeap> monochrom: so is the stream-fusion basically obsolete then?
14:40:46 <monochrom> I don't know.
14:40:51 <hololeap> *stream-fusion package
14:40:54 <dyl> Oh good, in GHC the RULE pragma For map/map is forall f g xs. map f (map g xs) = map (f.g) xs
14:40:57 <dyl> So I was correct haha
14:40:57 <monochrom> I think I haven't even known that library at all.
14:41:08 <dyl> hololeap here’s some more https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
14:41:39 <sm> I have a benchmarking script that reports times nicely as you edit, using ghcid dev.hs -T ':main'. I guess the best thing is to add weigh or something to that
14:41:49 <monochrom> I think "foldr op z (map f xs)" is also one of those things fused.
14:41:51 <dyl> But the idea of fusion is using expression rewriting to turn one expression into another which is equivalent but more efficient to compete.
14:42:12 <monochrom> And if xs is [m .. n], that also is fused.
14:42:21 <dyl> Wait why is this one used?
14:42:23 <dyl> map f (xs ++ ys) = map f xs ++ map f ys
14:42:35 <hololeap> dyl: ok, thanks for the official resource. i was getting lost in what a search was turning up
14:42:38 <dyl> That seems a little odd.
14:42:45 <monochrom> There are also equivalent fusions hardcoded in GHC for equivalent list comprehensions.
14:42:52 <dyl> But I guess it makes sense for if map is parallelized.
14:43:09 <monochrom> (need to hardcode this one because list comprehension is not a user-definable library thing)
14:50:23 <EvanR> dyl: how would it be parallelized
14:50:59 <dyl> I mean that if you have two things to be appended,
14:51:03 <Eduard_Munteanu> Lately I was wondering if conduits (or alternatives) could make good replacements for lists generally. Might even do away with some laziness.
14:51:13 <dyl> you can operate over both halves in parallel and then concat
14:51:20 <EvanR> o_O
14:51:20 <dyl> Versus concat and then operate over one
14:51:31 <dyl> The former has a parallelizable phase
14:51:35 <dyl> The latter does not
14:51:40 <EvanR> xs ++ ys makes a second copy of the entirety of xs
14:51:53 <dyl> That too. Reducing copies is good.
14:51:57 <ggVGc> sometimes I wish I had a gradually typed haskell
14:52:03 <Eduard_Munteanu> (since stuff like [1..] could work with some kind of eager conduits)
14:52:11 <aarvar> and map f xs ++ map f ys makes a second copy of map f xs
14:52:12 <dyl> Just make everything Dynamic ggVGc!
14:52:15 <EvanR> map f xs ++ map f ys makes a second copy of map f xs
14:52:18 <ggVGc> yeah, I was just thinking that..
14:52:25 <ggVGc> wonder how that'd turn out
14:52:26 <ggVGc> might be nice
14:52:32 <dyl> Look man
14:52:35 <dyl> Computers suck
14:52:35 <EvanR> lol
14:52:49 <rupert> how do you generate arbitrary instances with  instances such as the following: `instance (HasProtocolMagic, Bi a, Arbitrary a) => Arbitrary (Signature a) where`
14:52:53 <Eduard_Munteanu> ggVGc, something like, um, TypeScript is for JavaScript?
14:52:57 <EvanR> i was actually going for, the second list may compute bottom
14:52:57 <aarvar> gradual typing? you mean like, static typing (i.e. typing) ?
14:53:10 <EvanR> how would you even...
14:53:30 <rupert> I have tried `generate arbitrary :: IO (Signature a)` replacing the a with the required type
14:54:04 * dyl :: Void
14:54:11 <dyl> Now what, huh?
14:54:25 <glittershark> > absurd dyl
14:54:27 <lambdabot>  error: Variable not in scope: dyl :: Void
14:54:37 <EvanR> poser
14:55:43 <dyl> > @let dyl :: Void = undefined
14:55:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
14:55:55 <dyl> @let dyl :: Void = undefined
14:55:56 <lambdabot>  Defined.
14:56:01 <dyl> > absurd dyl
14:56:03 <lambdabot>  *Exception: Prelude.undefined
14:56:09 <dyl> > fix dyl
14:56:11 <lambdabot>  error:
14:56:12 <lambdabot>      • Couldn't match expected type ‘a -> a’ with actual type ‘Void’
14:56:12 <lambdabot>      • In the first argument of ‘fix’, namely ‘dyl’
14:57:44 <dyl> “fix error” still hasn’t gotten old to me.
14:58:46 <Rembane_> +1
15:02:31 <noan> just a random-ish-question, how hard is it generally to build a cabal package as a binary I could send to someone, like a tarball? Especially cross-compiling to other architectures.
15:02:55 <Rembane_> noan: Are they running Linux on ARM64?
15:03:24 <noan> Rembane_, sorry, other architectures and/or kernels.
15:03:49 <noan> I'm thinking about making a little game and I wonder how hard it's going to be go say, give to windows users for starters
15:04:47 <noan> am also thinking about 32bit users maybe
15:11:12 * hackage inflections 0.4.0.3 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.4.0.3 (camm)
15:14:32 <Rembane_> noan: I've been having a hard time achieving that, but it was quite a long time ago I gave up the last time, so it might be worth reinvestigating.
15:17:08 <noan> ty
15:17:22 <noan> now if only I could figure out how to fix my keybinds for spacemacs -_-
15:18:35 <monochrom> @src ++
15:18:36 <lambdabot> []     ++ ys = ys
15:18:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:18:36 <lambdabot> -- OR
15:18:36 <lambdabot> xs ++ ys = foldr (:) ys xs
15:19:59 <EvanR> i'm wrong
15:20:35 <monochrom> \∩/  (++) is a foldr on the first list.  So (++) (map f xs) foo = foldr (:) foo (map f xs) enjoys foldr-map fusion.  map f xs won't be duplicated; hell it won't exist in the first place.  Literally first place.  Haha.
15:21:16 <EvanR> existence is overrated
15:43:12 * hackage Persistence 1.0 - Quickly detect clusters and holes in data.  http://hackage.haskell.org/package/Persistence-1.0 (Ebanflo)
16:17:28 <crestfallen> hi when you have a list comprehension like beginning on ln 17, you don't call those expressions predicates that are separated by commas, right?
16:17:31 <crestfallen> https://gist.github.com/varreli/eabdbfa6edb6241d101b16280961fef3
16:19:38 <crestfallen> since there are no (==) operators
16:20:33 <crestfallen> what are they called?
16:20:39 <crestfallen> conditions?
16:20:57 <crestfallen> no never mind sorry I get it
16:22:27 <crestfallen> but in this case, do the commas act like ($)  ?
16:22:35 <EvanR> no
16:23:03 <EvanR> the haskell report here refers to the commas separated expressions as the qualifier list
16:23:30 <Welkin> EvanR: you should have stopped at "no"
16:23:33 <EvanR> _ <- _ are called generators, and bool expressions are called boolean guards
16:23:36 <Welkin> that was the answer to everything
16:24:15 <Welkin> list comprehensions are syntactic sugar for bind and monad guards o.o
16:24:35 <crestfallen> qualifiers , thanks but if you had a (==) would that boolean need to go in the first qualifier place at the top (ie the leftmost place) EvanR
16:24:58 <crestfallen> within the ls comprehension
16:25:10 <EvanR> if it refers to variables bound with _ <- _, then no
16:25:14 <EvanR> you need to put it after
16:26:05 <EvanR> Welkin: according to this report... it can be desugared to ifthenelse, lets, and concatMap
16:26:23 <Welkin> concatMap is bind for lists
16:26:25 <EvanR> rather than monads, though it probably isnt because of monad comprehensions
16:27:04 <crestfallen> ok when you say variables bound to _ <- _   ...
16:27:11 <EvanR> bound with
16:27:20 <crestfallen> right..
16:27:44 <EvanR> > [(x,y) | x==y, x<-[1..4], y<-[1..4]]
16:27:45 <lambdabot>  []
16:27:55 <EvanR> im wrong
16:28:17 <EvanR> > [(x,y) | x<-[1..4], y<-[1..4], x==y]
16:28:19 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
16:28:23 <EvanR> how does that even ...
16:28:29 <Welkin> I believe the filters come at the end
16:28:36 <EvanR> me too, until now
16:28:37 <Welkin> but list comprehension syntax is all messed up anyway
16:28:46 <Welkin> I avoid it whenever possible
16:28:46 <crestfallen> oh boy..
16:28:56 <EvanR> it says this
16:29:23 <EvanR> [ e | b, Q ] ===> if b then [e | Q] else []
16:30:26 <EvanR> > if x==y then [(x,y)|x<-[1..4],y<-[1..4]] else []
16:30:28 <lambdabot>  []
16:30:35 <nshepperd> in [(x,y) | x==y, x<-[1..4], y<-[1..4]] you are fooled by the fact that x and y are already in scope in lambdabot
16:30:36 <EvanR> :t x
16:30:37 <lambdabot> Expr
16:30:43 <EvanR> ;_;
16:30:52 <nshepperd> > x == y
16:30:54 <lambdabot>  False
16:31:02 <EvanR> > x == x
16:31:04 <lambdabot>  True
16:31:12 <EvanR> i refudiate this
16:32:00 <nshepperd> > ["yes" | 1+1 == 2]
16:32:02 <lambdabot>  ["yes"]
16:32:48 <EvanR> I'm sure crestfallen is now completely cleared up
16:33:09 <crestfallen> um..
16:33:16 <nshepperd> success
16:33:59 <infinisil> That [ foo | condition ] trick is very nice
16:35:52 <crestfallen> within the ls comprehension , there is nothing resembling eval order I assume
16:36:27 <EvanR> > [(x,y) | x<-[1..4], y<-[4..1], x==y]
16:36:29 <lambdabot>  []
16:36:37 <EvanR> > [(x,y) | x<-[1..4], y<-[4..1]]
16:36:38 <lambdabot>  []
16:36:49 <nshepperd> > [4..1]
16:36:51 <lambdabot>  []
16:36:55 <EvanR> i cant continue
16:37:01 <nshepperd> > [4,3..1]
16:37:03 <lambdabot>  [4,3,2,1]
16:37:23 <infinisil> > reverse [1..4]
16:37:25 <lambdabot>  [4,3,2,1]
16:37:26 <EvanR> > [(x,y) | x<-[1..4], y<-[4,3..1], x==y]
16:37:28 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
16:37:36 <EvanR> > [(x,y) | y<-[1..4], x<-[4,3..1], x==y]
16:37:37 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
16:37:57 <EvanR> bogus proof that order does not matter
16:38:23 <crestfallen> working on that..
16:38:47 <infinisil> > [(x, y) | x<-[1..2], y<-[3..4]]
16:38:49 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
16:38:50 <EvanR> crestfallen: check out this "translation" window here https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
16:38:59 <infinisil> > [(x, y) | y<-[3..4], x<-[1..2]]
16:39:00 <lambdabot>  [(1,3),(2,3),(1,4),(2,4)]
16:39:06 <infinisil> But it does!
16:39:29 <EvanR> thats what i was going for but i ran out of lambdabot credits
16:39:38 <crestfallen> thanks kindly ALL a bit confused esp by this one  [(x,y) | y<-[1..4], x<-[4,3..1], x==y]
16:39:42 <infinisil> lambdabot has credits? :O
16:39:57 <crestfallen> > [(x,y) | y<-[1..4], x<-[4,3..1], x==y]
16:39:59 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
16:40:03 <EvanR> isnt that were all getting paid in?
16:41:26 <EvanR> crestfallen: thats simply [(x,y)|y<-[1..4],x<-[4,3..1]] followed by a filter
16:42:35 <crestfallen> a filter? I would have expected that to return a Bool. Is that like forcing it?
16:42:58 <EvanR> its filtering by the condition x==y
16:43:29 <EvanR> > filter (\(x,y) -> x==y) [(4,1),(3,1),(2,1),(1,1)]
16:43:31 <lambdabot>  [(1,1)]
16:43:49 <crestfallen> interesting
16:59:41 <athan> If a GADT alters its resulting type via a phantom variable or something (i.e. `data Foo x where; Foo :: Foo Int; Bar :: Foo Bool`), does it become impossible to case-match polymorphically for any `x`, because you can't skolemize the right scope?
17:01:53 <EvanR> it works for me
17:02:24 <EvanR> http://codepad.org/QASjRqpX
17:03:01 <EvanR> what i did in the two branches was very simple, but not everything is allowed because of what youre saying
17:03:13 <EvanR> i believe you will sometimes get a "my brain just exploded" error
17:04:47 <EvanR> also works http://codepad.org/EYJ8WQ3X
17:07:05 <athan> agh jeez thanks EvanR
17:09:35 <EvanR> its polymorphic by a technicality, the caller can choose any a they want. but they will never be able to produce a Foo a unless a is Int or Bool
17:09:45 <EvanR> so they cant actually call it
17:14:46 <athan> glorious: http://codepad.org/OtIeLEUv
17:14:55 <athan> I mean, for me :D
17:15:09 <Welkin> athan: habari
17:15:27 <athan> Welkin: suhhhh
17:15:53 <EvanR> where are your GADTs
17:18:44 <Welkin> athan: now prove the riemann hypothesis!
17:19:00 <athan> who is your dependent type and what does he do
17:19:10 <EvanR> oh didnt see the error
17:19:18 <athan> oh sorry
17:19:23 <athan> no it's a data family :)
17:19:26 <athan> same thing kinda
17:21:22 <enterprisey> what's that bot command where you search for a function with a specific type signature
17:21:22 <mleone> Hi all - first time caller, hoping to get some help/ideas from the community.
17:23:14 <mleone> At run-time my haskell app fails to find a library and I get an error
17:23:26 <mleone> UnsuccessfulReturnCode "odbc_SQLDriverConnect" (-1) "[unixODBC][Driver Manager]Can't open lib '/opt/ibm/iaccess/lib64/libcwbodbc.so' : file not found
17:24:22 <mleone> the file exists, and everything checks out when I run >ldd /opt/ibm/iaccess/lib64/libcwbodbc.so
17:24:46 <monochrom> enterprisey: @hoogle
17:24:56 <enterprisey> monochrom: wonderful, thanks
17:25:12 <mleone> and I've made sure /opt/ibm/iaccess/lib64 is loading in the PATH
17:25:53 <monochrom> I would think that that check is irrelevant, the relevant check is "ldd your_executable"
17:28:42 * hackage Enum 0.1.0.0 - Non-crashing `Enum` operations  http://hackage.haskell.org/package/Enum-0.1.0.0 (MatthewFarkasDyck)
17:34:35 <sayola> glguy: Welkin: geekosaur: linear is instancing Num for its vectors, pretty much like i did yesterday: https://hackage.haskell.org/package/linear-1.20.7/docs/src/Linear-V2.html#line-181
17:34:47 <mleone> monochrom: everything is loaded when I run it on the exe, shows that nothing is missing
17:34:52 <sayola> now i'm really uncertain about whats the right way, when even kmett thinks its okay.
17:51:17 <mleone> is there somewhere else other than LD_LIBRARY_PATH that I need to include /opt/ibm/iaccess/lib64?
18:40:32 <pavonia> Catching all kind of exceptions looks so wrong here http://hackage.haskell.org/package/Enum-0.1.0.0/docs/src/Util.Enum.html#opMay
18:45:42 <geekosaur> smells like a spoon (see the package by that name)
18:45:59 <geekosaur> it's a (possibly over)reaction to things being exceptions that really should have been Maybe or Either
18:46:09 <glguy> pavonia: It doesn't catch all kinds, just lots of ones that are common in pure code
18:46:40 <glguy> It's not a good idea to use catch functions like this no matter what they catch, in any case
18:49:46 <pavonia> Yes, that's what I mean. It silences actual programming errors
18:57:27 <glguy> MatthewFarkasDyck seems to be in the process of flooding hackage with packages like that
18:59:38 <Welkin> who is that?
18:59:41 <Welkin> a troll?
19:00:30 <glguy> I don't know his intent. I don't really have any reason to believe there's malice involved
19:02:36 <Welkin> someone who thinks every language is java?
19:03:33 <aarvar> Don't java programmers like it when things crash?
19:04:06 <Welkin> no, they think exceptions are a good idea
19:04:09 <Welkin> you are thinking of erlang
19:06:49 <mniip> you're thinking of C
19:07:03 <glguy> Welkin: Ooh, do me! What number am I thinking of?
19:08:26 <mniip> glguy, an integer
19:08:41 <Welkin> glguy: 7, obviously
19:08:47 <glguy> No, the answer was 0.19 (it was my IRC ping time), good guess though!
19:08:54 <mniip> you likely just lied
19:09:50 <glguy> I wouldn't lie about a mediocre ping time :)
19:10:21 <mniip> mediocre? mine's 0.4
19:10:21 <shachaf> 0.19 is pretty close to an integer
19:11:02 <mniip> got 3 hops between me and the server
19:11:19 <glguy> Does that give you a high IBU?
19:13:02 <mniip> what does that stand for
19:13:06 <glguy> International Bitterness Units
19:13:30 <glguy> IBU is an abbreviation for the International Bitterness Units scale, a gauge of beer's bitterness. What IBUs measure are the parts per million of isohumulone found in a beer. Isohumulone is the acid found in hops that gives beer its bitter bite.
19:14:00 <mniip> that's 0.2 on funniness scale
19:32:12 * hackage hunit-dejafu 1.2.0.1, tasty-dejafu 1.2.0.1, dejafu 1.6.0.0 (barrucadu)
19:51:37 <anon136> hey guys, I feel like there should be a way to define the functionality of zip using nothing but either a standard list comprehension or nested list comprehensions but if it's possible I just can't figure it out.
19:52:04 <glguy> anon136: No, that's not possible
19:52:12 <anon136> well that makes me feel better!
19:52:33 <crestfallen> hi is there a -02 flag for optimization in stack? ' > stack ghc -02 filename.hs ' I get 'invalid option ' running this
19:52:37 <anon136> bad that my intuition was wrong but atleast I didn't fail in the inability to produce it.
19:52:55 <anon136> thanks
19:53:47 <crestfallen> the textbook is not featuring stack: ' > ghc -02 filename.hs '
19:54:23 <glguy> You can add ghc-options: -O2 to your .cabal file
19:54:32 <glguy> and it's -O2 Oh, not Zero
19:54:37 <crestfallen> great thanks glguy
19:54:59 <crestfallen> oh ok thanks
20:00:41 <`Guest00000> anon136: there is a way, though an inefficient one
20:01:47 <anon136> Can you show me? for curiosities sake?
20:02:19 <anon136> ooh I think I figured out the way you are going to show me.
20:03:57 <anon136> Basically where you add a filter for all of the x outputs in the tupple that repeat, so it still iterates through it all but throws it away rather than adding it to the list.
20:05:45 <`Guest00000> anon136: and what are you going to compare the old x to?
20:05:52 <glguy> and would that produce the correct output for zip [1,1] [1,1,1] ?
20:06:26 <glguy> :t zip
20:06:27 <lambdabot> [a] -> [b] -> [(a, b)]
20:06:32 <anon136> well I'm not sure, I had an idea along those lines, but I knew it would be inelgant so I didn't pursue it, I was only wondering if there is an elegant solution,
20:06:34 <glguy> You don't get to compare the elements for equality
20:07:10 <`Guest00000> > let xs = "Hello"; ys = "World....." in [ (x, y) | i <- [0 .. length xs `min` length ys - 1], let x = xs !! i; y = ys !! i ]
20:07:12 <lambdabot>  [('H','W'),('e','o'),('l','r'),('l','l'),('o','d')]
20:07:39 <glguy> Using !! isn't using list comprehensions
20:07:51 <`Guest00000> but here is a comprehension
20:07:56 <anon136> length also
20:08:22 <glguy> that's like saying: [ x | x <- zip xs ys ] is a solution :)
20:08:34 <`Guest00000> glguy: no, that reuses zip ;)
20:08:36 <anon136> glguy: rofl
20:09:49 <anon136> thanks though guest, for taking a look at my question.
20:49:59 <aarvar> is this a bug? https://gist.github.com/aaronvargo/0f0f7882c9cfb711715a722b01ed795b
20:56:04 <S11001001> aarvar: I think so, derive* typically proactively rejects decls that it can't support e.g. GADTs
20:56:36 <S11001001> aarvar: maybe you should use GND here, there's a completely uncontroversial extension if there ever was one :)
20:57:12 <aarvar> S11001001: unfortunately my real use case is different
20:58:03 <aarvar> S11001001: GND fails too!
20:58:16 <S11001001> aarvar: can you factor out the forall'd bit?
20:58:33 <aarvar> "Cannot instantiate unification variable ‘f0’ with a type involving foralls: (->) (forall α. α -> α)"
20:58:43 <aarvar> using GND
20:58:59 <aarvar> S11001001: I could, but it doesn't really matter
20:59:12 <aarvar> I'm going to implement monad anyway, so fmap will still be free
21:00:26 <aarvar> guess I'll report a bug though
21:00:38 <aarvar> if I can remember the username for the account I made and never used
21:01:25 <aarvar> oh well, I'll make a new one
21:08:12 * hackage hOpenPGP 2.6.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.6.2 (ClintAdams)
21:23:42 * hackage animate 0.6.1 - Animation for sprites  http://hackage.haskell.org/package/animate-0.6.1 (jxv)
22:01:53 <`Guest00000> insertLookup = insertLookupWithKey (\_ a _ -> a)
22:01:59 <`Guest00000> adjustLookup f k m = let (Just a, m') = insertLookup k (f a) m in (a, m')
22:02:03 <`Guest00000> ^ is this fine to do?
22:02:43 <`Guest00000> it works fine on a one-element test map
22:04:39 <xpika1> Has anyone noticed that you can do perform the same tasks with the list monad with the writer monad by replacing the -> with forM and return x with tell [x]?
22:05:23 <mathsguysoon> Hi I am here thinking many maths guys might be here,  I want to get started with maths then apply that maths in various areas like trading etc ...where should I start with?
22:09:06 <xpika1> eg. do {  x <- [[1],[2],[3]] ; y <- x ; return (x,y) }
22:09:06 <xpika1> or
22:09:07 <xpika1> execWriter $ forM [[1],[2],[3]] $ \x -> forM x $ \y -> tell [(x,y)]
22:14:38 <aarvar> S11001001: yikes, I found another case where GHC successfully derives the instance, but when you dump the code, the dumped code results in an error
22:15:47 <aarvar> S11001001: nvm, that's my editor being stupid
22:44:42 * hackage Fin 0.2.1.0 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.1.0 (MatthewFarkasDyck)
22:46:36 <KernelBloomer> hi haskellers
22:47:01 <KernelBloomer> is anyone of you coding in linux? Please tell me where to get ghc package other than official repository??
22:47:31 <KernelBloomer> since all haskell packages are closely dependent, it might break if I get it from repo
22:48:34 <mniip> stack?
22:48:48 <mniip> also I use the arch haskell packages with almost no issues
22:48:59 <KernelBloomer> mniip, are you oon arch?
22:49:04 <mniip> debian has also been known to handle systemwide + cabal instal fine
22:49:07 <KernelBloomer> as main OS or VM? mniip
22:49:19 <mniip> it's running natively if that's what you're asking
22:49:36 <KernelBloomer> yea so using arch packages instead of official has no harms?
22:49:49 <mniip> you might want to install the static version
22:49:57 <mniip> otherwise you have to write -dynamic nearly everywhere
22:50:06 <KernelBloomer> why do you use repo and not static instead?
22:50:46 <mniip> static *is* from the repo
22:50:48 <mniip> and I have both
22:51:09 <mniip> well the static package is *just* the static libraries
22:51:38 <KernelBloomer> I see
22:51:47 <KernelBloomer> mniip, what desktop environment thou?
22:52:10 <mniip> awesomewm
22:52:39 <KernelBloomer> tried i3?
22:53:35 <KernelBloomer> mniip, thanks for static recommendation. getting it installed. fortunately I am on the same distro so your help is really appreciated.
22:53:35 <mniip> yes
22:53:41 <c_wraith> KernelBloomer: if you're using ubuntu, hvr maintains a PPA that is just recent version of ghc & cabal that haven't been mangled by standard ubuntu packaging
22:53:43 <p0a> Hello I'm interested in writing some code that parses an HTML file and does some things there. any good tutorials?
22:53:49 <c_wraith> https://launchpad.net/~hvr/+archive/ubuntu/ghc
22:54:08 <KernelBloomer> c_wraith, thanks but I dont use ubuntu because of PPA
22:54:23 <KernelBloomer> mniip, why awesome over i3? just curious.
22:54:59 <mniip> C plugins ;)
22:55:15 <KernelBloomer> can you share your dotfiles please?
22:56:13 <KernelBloomer> c_wraith, I use arch btw.
22:59:55 <mniip> KernelBloomer, the only useful awesome-related dotfiles I could share are my own battery/network plugins: https://bpaste.net/show/b40be29155f1
23:03:05 <KernelBloomer> mniip, cool! can you show how your desktop looks like
23:05:01 <bendo> some time ago I had issue with arch packages so I switched to stack as wm I am using xmonad
23:05:24 <mniip> KernelBloomer, http://tcpst.net/in2d.png
23:06:21 <KernelBloomer> wow really cool. what font is that. its so sharp. mniip
23:06:37 <KernelBloomer> bendo, mind showing your desktop?
23:07:48 <bendo> hm, where can I put screenshot?
23:08:06 <jchia_> Is there a way to derive things like Eq1 and Ord1? I suppose GHC can't do that yet? Would Data.Eq.Deriving from deriving-compat work?
23:08:31 <KernelBloomer> bendo, imgur.com
23:09:18 <mniip> KernelBloomer, DejaVu Sans Mono Book
23:09:28 <mniip> bendo, nc auto.tcpst.net 7777 <
23:09:33 <mniip> :p
23:10:50 <bendo> http://tcpst.net/9sd3.png
23:11:00 <bendo> mniip nice :)
23:11:17 <KernelBloomer> cool cool. arch linux as well? ben
23:11:19 <KernelBloomer> bendo,
23:11:32 <mniip> is that really hanging in the middle of nowhere
23:11:38 <mniip> how do you know where the left/right margins are
23:12:11 <KernelBloomer> mniip, whats this application beside discord in your tray? status bar
23:12:24 <bendo> yep arch linux
23:12:37 <mniip> keybase
23:13:28 <bendo> there is plugin for vim - distraction free writing in vim
23:13:44 <bendo> https://github.com/junegunn/goyo.vim
23:14:23 <KernelBloomer> mniip, dejavu sans mono book is in AUR?
23:14:57 <mniip> I'm fairly sure it's in the base repo
23:15:29 <KernelBloomer> cant find it :(
23:15:39 <mniip> /usr/share/fonts/TTF/DejaVuSansMono.ttf is owned by ttf-dejavu 2.37-2
23:16:10 <KernelBloomer> I see
23:16:22 <mniip> note that sharpness may vary if you're not using a 4K screen :)
23:16:32 <KernelBloomer> you on 4k?
23:16:52 <mniip> if it wasn't apparent from the screenshot
23:16:59 <KernelBloomer> :D
23:17:00 <mniip> (3840x2160)
23:17:06 <KernelBloomer> laptop or desktop?
23:17:08 <mniip> laptop
23:17:12 <KernelBloomer> xps/
23:17:13 <KernelBloomer> ?
23:17:19 <mniip> no
23:17:57 <KernelBloomer> what laptop do you use as main computing horse?
23:18:01 <mniip> may I suggest we take this to #haskell-offtopic
23:18:53 <KernelBloomer> yea sorry. lets talk there
23:22:12 * hackage diff 0.1.0.0 - Diff and patch  http://hackage.haskell.org/package/diff-0.1.0.0 (MatthewFarkasDyck)
23:56:12 <`Guest00000> Data.Map dosmth-and-lookup functions are wicked
23:57:08 <`Guest00000> no plain updateLookup, insertLookup, no adjustLookup*, updateLookup returns new value (unless deleting!) but insertLookup always returns old one
