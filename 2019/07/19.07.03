00:00:34 <Rembane> That's one of the best footnotes I've ever seen.
00:02:10 <sclv> teto: the log levels were chosen basically iirc to differentiate between blockers for upload and things that are not blockers for upload
00:02:24 <sclv> and so they really are policy questions
00:07:05 <simon> using Network.HTTP.Client and Servant.Client, I'm getting an UnsupportedContentType application/octet-stream (Response { ... }) because the Content-Type doesn't appear to serialize trivially to Data.Text; I know the encoding of the request, so I could use Data.Text.Encoding to pack a Text value, but I wonder if I can tell the HTTP client to do that for me?
00:21:25 <Nevoic> Does anyone have any suggestions for JSON libraries? I'm thinking about dead-simple-json
00:21:33 <simon> Nevoic, Aeson :)
00:21:55 <Nevoic> Is aeson simple?
00:22:45 <Nevoic> https://github.com/bos/aeson/blob/master/examples/Simplest.hs this is their "simplest" example XD, do they have a default instance at least?
00:23:03 <Nevoic> where I could do `data User = User { stuff } deriving ToJson`
00:23:38 <dminuoso> Nevoic: Its still almost as simple.
00:23:54 <dminuoso> Nevoic: data User = User { ... } deriving Generic; instance ToJSON User;
00:23:57 <xacktm> https://artyom.me/aeson#records-and-json-generics
00:24:12 <Nevoic> Just those two lines? That's not bad.
00:24:34 <Nevoic> I take it I also need a separate line for FromJSON?
00:25:04 <simon> Nevoic, if you read the Aeson tutorial ( https://artyom.me/aeson ) while building your parser, and your data type models the JSON object closely, it's close to two lines. but yeah, there's a bit of navigation.
00:25:17 <dminuoso> Nevoic: Yes.
00:25:43 <dminuoso> Nevoic: Though you could put it on a single line like that of course. People just don't do that outside IRC. :)
00:25:51 <Nevoic> does Aeson have built in support for saving json to a file?
00:26:08 <Nevoic> Yeah I wouldn't use `;`, don't worry lol
00:26:40 <simon> Nevoic, no, but it has a function for encoding your JSON value as Text, which Haskell then has a function for saving to a file. :)
00:27:21 <Nevoic> üëç
00:28:14 <EvanR> i usually miss the opposite, other languages often give you a thing that combines "does what this lib is supposed to do, and reads/writes to a file" for your convenience
00:28:28 <EvanR> and i'm like... is there a non file version... no
00:28:46 <simon> Nevoic, I was wrong. Aeson does have a function that does both: http://hackage.haskell.org/package/aeson-1.4.4.0/docs/Data-Aeson.html#v:encodeFile
00:29:07 <Nevoic> oh, nift!
00:29:29 <Nevoic> might still do it the other way, we'll see how I feel lol
00:29:57 <simon> Nevoic, yeah, for playing around you usually don't need saving to file.
00:30:25 <dminuoso> Nevoic: I would still use non-aeson file utilities.
00:30:54 <dminuoso> I dont know what aeson `encodeFile` does exactly, and it'd be annoying to learn the exact IO semantics of each library.
00:31:46 <dminuoso> Learning a single `writeFile` (or equivalent) is easier and more powerful than each library having its own version, but doing "magic additional bits" alongside.
00:32:00 <simon> Nevoic, also, it seems that most Aeson encoding happens to ByteString (you'll probably get a little confused at all the lazy/strict combinations of Text and ByteString in various places, sorry.)
00:32:19 <simon> dminuoso, yes.
00:34:18 <simon> Nevoic, I'm building a REST client using servant-client that automatically generates API functions that de/serialize to/from JSON. I have to write the FromJSON/ToJSON instances because the REST API uses keys that aren't valid data type fields.
00:34:56 <simon> (and also I want to change the internal representation of some of the fields, so e.g. I get an offset as an Int, but I want to convert it to a coordinate (Int, Int).
00:35:15 <dminuoso> Nevoic: By the way, you will need 2 additional lines I didnt mention. You will also need to `import GHC.Generics (Generic)` and enable the {-# LANGUAGE DeriveGeneric #-} pragma.
00:35:42 <dminuoso> (Which is needed to enable the `derive Generic` part of that)
00:36:22 <Nevoic> Yeah I noticed on the generic page, added the Language pragma to my cabal file actually.
00:36:24 <simon> EvanR, or in the general case, "is there a side-effect-free version of that? no."
00:36:24 <comerijn> aeson encoding to/from ByteString is one of the most annoying things, because it means you can't actually parse any JSON written in anything other than UTF-8 :\
00:36:37 <Nevoic> The thing I'm running into is `encodeFile` doesn't exist, which I assume is because I'm on an old version of Haskell.
00:36:44 <Nevoic> Going to a new version would break my tooling.
00:39:21 <dminuoso> merijn: At the very least changing from UTF-8 to say UTF-16 is not the biggest of all problems.
00:39:29 <dminuoso> If I recall correctly JSON mandates just unicode.
00:39:40 <simon> Nevoic, so use Data.Aeson.encode and Data.ByteString.Lazy.writeFile
00:41:09 <simon> encode :: ToJSON a => a -> ByteString   ;   writeFile :: FilePath -> ByteString -> IO ()   ;    so: writeFile "foo.json" (encode someValue)
00:42:06 <dminuoso> merijn: So at worst its a minor inconvenience. :)
00:44:32 <merijn> dminuoso: I would say it's rather problematic if you ALWAYS have to decode/recode unicode to utf-8 before processing
00:45:14 <dminuoso> merijn: What actual *problems* do you experience from that?
00:45:27 <dminuoso> It's an annoyance, sure. It's not clean, I agree. But I dont see any technical problems stemming from this.
00:46:58 <simon> merijn, ohhh, this is caused by Aeson assuming UTF-8 and Data.Text assuming UTF-16?
00:47:09 <dminuoso> simon: Data.Text makes no assumptions.
00:47:24 <dminuoso> simon: Aeson parses only UTF-8 and produces only UTF-8.
00:47:33 <dminuoso> The latter could probably be fixed relatively trivially, but the parser not.
00:47:33 <merijn> dminuoso: Performance loss is a problem in lots of situations
00:47:33 <simon> dminuoso, ok.
00:47:44 <dminuoso> merijn: Ah fair.
00:48:00 <merijn> simon: Data.Text doesn't assume anything, it's an in memory representation of unicode text
00:48:11 <Axman6> y'all need the text-utf8 package
00:48:19 <merijn> Axman6: Why?
00:48:56 <Axman6> it's a drop in replacement for Text which uses utf8 internally, avoids a lot of the reencoding that happens in things like Aeson
00:49:28 <merijn> Axman6: Except it doesn't solve the problem I mentioned at all
00:49:46 <merijn> And last I checked the utf8 clone of utf16 was on hold due to being less performant on many benchmarks
00:50:04 <dminuoso> Axman6: If your remote service requires utf16 you still have the issue.
00:50:32 <merijn> Axman6: text-utf8 only works if: 1) my JSON data is coming from my own Haskell process and 2) I don't have to talk to any library expecting regular Text
00:50:34 <Axman6> whose remote service wqould need utf16 though, that's madness
00:50:46 <dminuoso> Why is it madness?
00:50:57 <dminuoso> It's pretty crazy to assume that the entire world uses nothing but utf8.
00:51:13 <dminuoso> One of the more annoying things in this world is having to talk to APIs with undocumented encoding.
00:51:42 <Axman6> it's not that crazy, it's certainly the most common encoding of text between services. I've never seen utf16 used outside an application
00:51:43 <merijn> I mean, I *wish* we were in a world where everything is utf8, but we don't live in that world
00:52:09 <dminuoso> Axman6: UTF16 is very widely used in the windows world.
00:52:47 <Axman6> on the network?
00:52:52 <dminuoso> Axman6: In fact this "pseudo monopogy" is the major issue.
00:53:02 <dminuoso> It leads everyone to assume that "only utf8 exists" until it doesnt.
00:53:33 <dminuoso> Axman6: No internally, but you may be writing an application that interfaces with windows programs.
00:53:52 <Axman6> sure, then be explicit about using utf16
00:54:31 <dminuoso> Axman6: Now assume that for some reason you want to talk to say MSCV, and it demands a UTF16 encoded JSON serialized object.
00:54:33 <merijn> Axman6: Which brings us back to "a library that conceptually works on unicode text *requiring* utf8 input is stupid"
00:54:42 <dminuoso> *MSVC
00:55:14 <Axman6> then use Data.Aeson.Text and the appropriate things in Data.Text to ensure you communicate with it via utf16
00:55:47 <dminuoso> Axman6: And now you receive a response.
00:56:26 <Axman6> as utf16?
00:56:30 <dminuoso> Yes.
00:58:37 <Axman6> then reencode it as utf8 and parse it. I agree it's not idea that Aeson requires utf8, but it's a) certainly the most common encoding for JSON data, and b) it is not diffidult to do the required encodings and decodings if necessary in the cases where someone is doing something out of the norm, such as uzsing utf16 for JSON. yes it's valid but it's also not common
01:01:28 <Nevoic> Random question, is there a way to truly "replace" prelude? I see people using `NoImplicitPrelude`, but I think this assumes that in every single file you have to import your "custom prelude".
01:01:47 <Nevoic> Is there any way to get the functionality of Prelude (where you don't have to import it) but with a custom prelude? (like classy prelude etc.)
01:03:50 <Nevoic> I may have found it, actually.
01:14:00 <marmulak> <gabbiel "i would love to learn it, but th"> Imperative programmer spotted
01:15:23 <tdammers> personally, I think that Aeson parsing bytestrings rather than strings/text is incorrect
01:15:54 <tdammers> Nevoic: AFAIK you can't, but if you have a solution, I'm (morbidly) curious
01:16:32 <Nevoic> Apparently you can replace base with `base-noprelude` and then create a Prelude module, and reexport the custom prelude you're using.
01:16:43 <Nevoic> I'm not even able to compile base-noprelude for some reason though.
01:17:13 <Nevoic> parse of field `reexported-modules` failed
01:17:16 <merijn> Honestly, I've long ago abandoned the idea of custom preludes
01:17:25 <Nevoic> this happens if I do nothing except import `base-noprelude` instead of base.
01:17:30 <Nevoic> So maybe base-noprelude is just broken?
01:17:34 <Nevoic> Are there broken packages on hackage?
01:17:42 <Axman6> many
01:17:44 <merijn> Maybe if you're in a company setting with a huge codebase where everyone uses it, but other than that
01:18:06 <merijn> Hackage is an immutable package repo, so any package that was uploaded and later broke is still there, so "almost certainly"
01:18:40 <tdammers> I do like custom preludes, but I prefer tailoring them to the project at hand, and making them fairly nonintrusive - extending the standard prelude more than replacing it
01:18:55 <Nevoic> I'm not a fan of type signatures that lie.
01:18:59 <Nevoic> like `head :: [a] -> a`
01:19:07 <tdammers> Nevoic: it doesn't lie
01:19:17 <tdammers> bottom inhabits all types
01:19:40 <merijn> If you consider that a lie, then I have some bad news about Haskell and basically all Turing complete languages
01:19:57 <tdammers> and because Haskell is Turing complete, there cannot be a way to completely get rid of all bottoms
01:20:29 <Nevoic> We have different definitions of lying, apparently.
01:20:37 * Axman6 I like big bottoms and I cannot lie...
01:20:49 <Nevoic> If your definition of lying is "isn't valid", then of course you're right.
01:20:57 <tdammers> or, put differently; you cannot classify all Haskell functions into "partial" and "total", and then outlaw the partial ones, because there is also a third one, "possibly partial, but we cannot tell"
01:21:23 <Nevoic> tbh I hope we move away from turing complete languages.
01:21:31 <Nevoic> agda ftw
01:21:37 <tdammers> so you *could* have type signatures that don't lie for the "definitely partial" and "definitely total" functions, but you'd still be left with the "we don't know" ones
01:21:40 <Nevoic> compilers just need to get smarter.
01:21:44 <Nevoic> for that to be practical.
01:22:09 <merijn> tdammers: tbh, I think we can gain a lot from just having "definitely total" in the type system
01:22:10 <marmulak> Why wouldn't you want your language to be turing complete
01:22:31 <merijn> marmulak: Better question: Why would you want it to be Turing complete?
01:22:32 <tdammers> marmulak: because of the undecidability problem, basically
01:22:34 <Nevoic> markmulak: So we can enforce totality at compile time.
01:22:37 <Axman6> Nevoic: use Idris
01:22:42 <Nevoic> Idris is still turing complete.
01:22:48 <Axman6> Halt right there, we have a problem!
01:22:50 <tdammers> merijn: I think I actually agree
01:22:55 <merijn> Axman6: Isn't Blodwen the new hipness right now? ;)
01:22:57 <bollu> neobrain just to play devil's advocate, ackernann is total, but effectively bottom for reasonably small inputs
01:23:03 <Nevoic> I like it, but the library support for Idris is pretty poor too.
01:23:04 <Axman6> never heard of it
01:23:10 <Nevoic> Blodwen is Idris 2.0 right?
01:23:36 <merijn> Axman6: It's Edwin's new toy, possible precursor to Idris 2.0
01:23:56 <Nevoic> tdammers: You can model undecidability/non-totalness in total/non-turing complete languages with monads.
01:24:03 <Nevoic> similar to how we model state with monads without actually having state.
01:24:17 <Axman6> merijn: nice - any highlights?
01:24:18 <tdammers> we don't model state "with monads"
01:24:28 <tdammers> we model state by passing and returning additional values
01:24:39 <Nevoic> I was referring to the State monad, but mkway.
01:24:53 <tdammers> I was also referring to State
01:24:59 <merijn> marmulak: In my experience most programmers learn about Turing completeness and somehow manage to learn "we need Turing completeness for *real* programming languages", but the more I learn, the more I think Turing completeness is overrated
01:25:01 <tdammers> but it being monadic is not what allows it to model state
01:25:10 <Nevoic> I didn't say that was the case.
01:25:21 <tdammers> oh. that's how I read "we model state with monads"
01:25:35 <merijn> marmulak: What we *want* is "a sufficiently expressive language to describe all problems we care about", but I'm not convinced we really need Turing completeness for that
01:25:58 <Nevoic> We model state with monads != being monadic is what allows it to model state.
01:26:12 <tdammers> Nevoic: technically you are right
01:26:29 <dminuoso> Nevoic: You still dont use "monads" to do state.
01:26:30 <Axman6> main = invokeWebserverUpTo (maxBound :: Word64) webServer
01:26:35 <tdammers> Nevoic: technically right much like the teacher who says "don't worry, I always wear a condom while teaching"
01:26:50 <dminuoso> Nevoic: A monad is not something you can hold in your hand and apply it to a problem./
01:26:51 <Nevoic> I use monads to "do state".
01:27:13 <Nevoic> A monad is an abstraction. I use abstractions.
01:27:21 <dminuoso> Nevoic: no, you would use a *function* to do state, and use monad to abstract over that. :)
01:27:29 <tdammers> "state" is not the thing Monad abstracts over though
01:27:48 <dminuoso> Nevoic: Functions `a -> (a, b)` is what models stateful `a`.
01:27:53 <tdammers> ^ this.
01:28:09 <Nevoic> Ah, I see what you guys are saying.
01:28:16 <O45> so yeah, how do I unfuck my arch setup? https://www.reddit.com/r/archlinux/comments/7jtemw/which_package_do_you_hate_the_most/drar5ph/
01:28:19 <Nevoic> I wish I wasn't retarded.
01:28:28 <Nevoic> xd
01:28:33 <tdammers> it's similar to why people keep demanding you stop saying "IO Monad"
01:28:48 <tdammers> because the "Monad" part is not what makes IO magical, the "IO" part is
01:28:50 <merijn> O45: For doing Haskell development, you mean?
01:29:05 <O45> Yeah, I want something at least slightly sane.
01:29:12 <tdammers> and similarly, the part that makes "State Monads" stateful is not the "Monad" part, but the "State" part
01:29:45 <merijn> O45: Nuke everything, install GHC-static (I think?). Alternatively, nuke everything and install via GHC binary distributions
01:29:50 <O45> I was thinking of bootstrapping by stack binary, but it just feels dirty to prepend anything haskell related with stack
01:29:59 <merijn> O45: The bindist approach has the advantage of working identically on every *nix platform
01:30:29 <merijn> O45: https://www.haskell.org/ghc/download_ghc_8_6_5.html#binaries
01:30:32 <O45> and so whats the deal with stack vs cabal
01:30:44 <dminuoso> Nevoic: So the trick here is, we can represent functions `s -> (s, a)` behind a `newtype State s a = State { runState :: s -> (s, a) }`, and it turns out this type conforms to some highly generic interface.
01:31:18 <O45> binary ghc is basically what I get with stack by default, right?
01:31:34 <merijn> O45: tbh, I don't really know what stack does :)
01:31:37 <dminuoso> O45: "stack vs cabal" has historically changed much. 
01:31:53 <DigitalKiwi> with stack you can get lots of ghc you don't want for free
01:31:55 <sclv> ghcup is a nice way to get binary ghc
01:32:05 <merijn> DigitalKiwi: You can do the same with bindists, tbh
01:32:23 <dminuoso> O45: stack consists of 'stackage' which is a curated hackage and sandboxed projects. That last part is important because it used to be that raw `cabal` couldn't do this nicely.
01:32:33 <tdammers> "stack vs cabal" is a proxy war for "fpcomplete vs the established community around ghc / cabal"
01:32:51 <O45> so cabal is the way to go?
01:33:06 <dminuoso> O45: If you prefer it, sure.
01:33:07 <DigitalKiwi> do you want to buy an fpcomplete support contract?
01:33:10 <Axman6> ,y rule of thumb is stack for apps, cabal for libraries
01:33:22 <dminuoso> O45: Since `cabal v2-*` many the advantages of stack have disappeared.
01:33:24 <merijn> This discussion reminds me that just this morning I decided to write a "cabal FAQ"
01:33:48 <tdammers> so the most important difference these days is stack's "snapshot" model vs. cabal's "resolver" model
01:33:56 <dminuoso> O45: Neither is honestly better. cabal proponents will tell you its great and simpler, stack proponents will do the same. Id say both are good and pick whatever is easier for you.
01:34:05 <O45> no, I don't need fpcomplete support contract
01:34:15 <tdammers> with stack, you pin down the entire library ecosystem, and stackage sort of guarantees that you won't get any conflict
01:34:15 <DigitalKiwi> you can use the versions in stackage from cabal easily enough, no?
01:34:37 <O45> and wont htere be any clash in using both?
01:34:45 <dminuoso> O45: There's also a third option, which is `nix + cabal v1-*`
01:34:46 <tdammers> with cabal, you set version ranges for all your immediate dependencies, and cabal figures out the best versions for your entire dependency graph based on what's available on hackage
01:34:54 <Axman6> O45: DigitalKiwi was being facetious
01:35:06 * DigitalKiwi uses nix and cabal new-
01:35:14 <tdammers> both can also sort of do the other, if you coerce them hard enough
01:35:18 <tdammers> but that's the basic model
01:35:19 <dminuoso> DigitalKiwi: Well that's equivalent to just `cabal new-*`
01:35:19 <DigitalKiwi> Axman6: only ever so slightly but yeah :)
01:35:47 <dminuoso> DigitalKiwi: Because you defer the entire dependency resolution to cabal.
01:35:56 <tdammers> the advantage of the stack model is that it "just works" without any effort on your part, you just say "I want package X" and it'll get you whatever version stackage has
01:36:15 <DigitalKiwi> dminuoso: nix-shell does a bit more than that
01:36:16 <dminuoso> tdammers: `cabal v2-*` "just works" without any effort too. :p
01:36:33 <Axman6> as someone who us writes haskell applications in a commercial setting, I find stackage snapshots reduce the pain of managing library bounds until a time we're ready to deal with the problems of upgrading much easier. though the cabal new-* stuff should give basically the same benefits these days
01:36:34 <dminuoso> DigitalKiwi: That'd all be outside cabal though.
01:36:43 <dminuoso> DigitalKiwi: nix-shell likely only sets up your cabal and native dependencies right?
01:36:44 <tdammers> dminuoso: yes, but you should set version bounds usually, which is a tiny bit of extra effort
01:36:49 <Axman6> dminuoso: that's not been my experience
01:37:06 <dminuoso> Axman6: Im genuinely curious, what issues did you have?
01:37:07 <DigitalKiwi> but yes it's largely the same as using new cabal in practice
01:37:37 <O45> alright, cool, thanks, I am gonna give it a spin and hopefully wont be here in half a month
01:37:42 <dminuoso> DigitalKiwi: That'd rather be the discussion `nix vs apt`, which is still a useful discussion, but somewhat orthogonal to the one we are having.
01:37:49 <DigitalKiwi> you can do more complicated things
01:37:50 <Axman6> it's been too long to remember the details, but I definitely had more failedures to build using new-* then I ever did with stack
01:38:00 <dminuoso> Axman6: Its been the opposite for me.
01:38:01 <dminuoso> :)
01:38:31 <dminuoso> O45: One motivating factor for some stack users is `hie` by the way, I think.
01:38:33 <DigitalKiwi> i've just been happy with new cabal and nix-shell makes it a bit easier
01:38:39 <dminuoso> Which afaik does not work with `cabal v2-*`?
01:38:44 <tdammers> the big disadvantage of the stack model is that upgrading things can be extremely contagious. you want to upgrade one library, but the new version is not in your current stackage snapshot, and just surgically upgrading this one library cascades through your dependency graph, and then you end up having to switch to a newer stackage snapshot, which means you'll be using a different GHC version, different base,
01:38:45 <dminuoso> DigitalKiwi: Yes, I do the same. :)
01:38:46 <tdammers> newer versions of a dozen libraries that you didn't actually want to touch at all, and if you're really lucky, some libraries won't be in the newer snapshot at all, and you need to rewrite some parts of your codebase that worked perfectly fine just because you need to fit them onto a different, API-incompatible, library
01:38:55 <Axman6> yeah no hie is a dealbreaker for me
01:39:06 <dminuoso> DigitalKiwi: It was too much work to constantly fix derivations for libraries, so I adopted the same style. :)
01:39:18 <tdammers> whereas with cabal, you just upgrade that one dependency, and if at all possible, cabal will figure out how to upgrade it without touching anything else
01:40:09 <dminuoso> Axman6: I was pretty annoyed by the pain and effort I invested into `ghc-mod` so I stopped caring about `ide` features and use nothing but ghcid now.
01:40:33 <O45> yeah, so what if I want to use mostly cabal, but there are some apps that use stack (hie, ihaskell)? What to do sanely with them
01:40:36 <dminuoso> And the stories of people trying to get `hie` working in vain in #haskell repeatedly tell me that Im right.
01:40:45 <dminuoso> O45: `ghcid` 
01:40:47 <tdammers> O45: you can install both stack and cabal side by side
01:40:56 <dminuoso> O45: Oh I misread heh.
01:40:58 <Axman6> types on hover and inline docs are hard to live without these days
01:41:06 <dminuoso> I actually read between your and mine line.
01:41:16 <tdammers> O45: but if you want to use development tools tailored for a stack workflow, then that will only work with stack
01:41:29 <Axman6> though the LSIF stuff coming in GHC 8.8 should make that a moot point
01:41:50 <DigitalKiwi> dminuoso: you can use hie without stack, i use it with cabal, it's just slightly annoying that i have to make it work with cabal v1- too
01:41:53 <Axman6> O45: under the hood stack uses cabal, btw
01:41:59 <Axman6> they're not incompatible
01:41:59 <dminuoso> DigitalKiwi: Oh really? :)
01:42:32 <Axman6> it's mostly a question of which you use day to day, there's very little difference between a projet which uses one or the other
01:43:28 <tdammers> in fact, as a library author I try to make my things work with both
01:43:36 <DigitalKiwi> not really a big deal i didn't have to change much if anything to make both work but it doesn't yet work with cabal new- afaik dante sometimes had similar problems. still better than intero stack or gtfo
01:43:38 <tdammers> it's not usually a problem at all
01:44:03 <O45> I know I can install both, I am just more than overwhelmed by where is everything scattered throughout the filesystem. .cabal, .ghc, .stack
01:44:59 <Axman6> cabal is almost certainly the way to go for library only projects
01:45:24 <tdammers> IMO cabal is the way to go for almost anything; I really only use stack when people ask me to
01:45:31 <DigitalKiwi> https://github.com/Infinisil/all-hies
01:46:26 <lavalike> what is a "primitive state transformer action"? (in the description of Control.Monad.Primitive.PrimMonad)
01:46:47 <Axman6> IO or ST
01:47:57 <dminuoso> lavalike: Its a slight abstraction over things that can manipulate memory afaik.
01:48:47 <lavalike> I was wondering if it wasn't something about "Primitive State" which gets compressed to Prim and Primitive but really means "using State#"
01:49:08 <dminuoso> lavalike: It'd be RealWorld in case of IO, and the `s` from `ST s`
01:49:40 <lavalike> yeah there's also the PrimState type which I understand would be those two
01:49:57 <dminuoso> lavalike: Oh I thought you were talking about that associated type family. :)
01:50:14 <lavalike> oh no, really the name of the class, and the description of the class
01:51:22 <dminuoso> lavalike: Im guessing its to allow code that works on mutable memory to not care whether its in IO or in ST.
01:51:34 <dminuoso> So yeah, what Axman6 said. :)
01:52:10 <lavalike> so you don't have to commit to either for your own monad
01:52:20 <Axman6> botyou'll see it used every where in the vector package
01:52:20 <quchen> I remember there was a CPS-y way to convert a right-associative function chain to a left-associative one,
01:52:20 <quchen> x (y z) ==> (f x) (f y) (f z) id
01:52:20 <quchen> Does anyone know how to do someting like that?
01:52:32 <quchen> (RIP IrcBrowse) :-(
01:53:39 <lavalike> ah interesting I never used the vector package, I see that, thanks
01:54:00 <simon> F* has "Tot" as part of function signatures.
01:54:16 <dminuoso> lavalike: http://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Mutable.html#v:new
01:55:05 <lavalike> or freeze/thaw/copy in Data.Vector.Unboxed yeah it's all over the place
01:55:15 <Axman6> this gets put to good use in the serialise package too, where its decoders essentially run inside ST, so you can internally do mutation when deserialising data structures
01:56:29 <lavalike> I used the same approach in some AoC problems last year! never knew there was an abstraction for that
01:58:35 <lavalike> it was complicated enough to make ST types work
01:59:54 <lavalike> this in particular: http://www.cs.toronto.edu/~trebla/personal/haskell/annote-STArray.xhtml
02:01:25 <merijn> Right, the questions earlier this morning finally motivated me to write what I decided had to be written a long time ago. The big "cabal" disambiguation guide for beginners: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
02:09:53 <Ariakenom> merijn: you didnt mention cabal2
02:13:54 <merijn> Ariakenom: v2-build is still cabal-install and doesn't really conceptually affect how it works, though. The only thing that changes is some details of how it computes a build plan
02:14:00 <dminuoso> And you didnt mention `cabal` the term referring to a group of people!
02:28:52 <maerwald> anyone using aeson-typescript and knows hot to flatten a product type? E.g. data A = A { foo :: String, bar :: ProductType } ... inserting foo as another record into bar and returning that
02:30:51 <maerwald> the library doesn't even export the constructors for TSDeclaration
02:35:11 <infinisil> merijn: Nice overview. One minor suggestion: You mention Stackage without explaining what that is, might be a good idea
02:38:39 <simon> I'm trying to debug an Aeson parser that contains 'withArray' because I don't really understand it; how can I run 'withArray' on a JSON list [1,2,3,4] and a function that encodes this with (== 3) to [False,False,True,False]?
02:40:03 <dminuoso> simon: Maybe the usage is helpful: withArray "Name for diagnostic purposes in case parsing fails" (\hereIsTheArray -> ... continue doing stuff) value`
02:40:27 <dminuoso> simon: So withArray will parse the value, and if its an array it will feed it to your function. If not it will fail.
02:40:44 <dminuoso> If it fails, it can use the specified name for diagnostics purposes.
02:42:34 <dminuoso> `withArray "foo" (\a -> continueStuff...) value` is basically just short for `case value of Array li -> continueStuff...; _ -> "failed to parse \"foo\", its not an array"
02:43:33 <dminuoso> simon: https://hackage.haskell.org/package/aeson-1.4.4.0/docs/src/Data.Aeson.Types.FromJSON.html#withArray
02:44:56 <disconsis> Hi everyone. I'm going through the book Principles of Programming Languages, and looking for answers to some questions. Could someone direct me to some forums for this (I don't know any :(), or entertain my doubts for a bit :) ?
02:45:17 <disconsis> Any help would be really appreciated :)
02:45:55 <Rembane> disconsis: Ask questions here! 
02:46:00 <ski> perhaps it would be better if you stated the questions
02:46:28 <disconsis> Awesome, thanks!
02:46:58 * ski idly wonders who the author(s) of this book might be
02:49:10 <disconsis> First off, I‚Äôm not yet confident with rule induction. The concept of a property of a judgment doesn‚Äôt really make sense to me.
02:49:33 <disconsis> Could you guys please explain it to me?
02:54:47 <simon> :o
02:55:08 <ski> i wonder if they mean structural induction on the derivation of some judgement, proved in some inference system
02:55:32 <simon> disconsis, rule induction rather than rule deduction?
02:56:07 <disconsis> simon: yeah
02:57:44 <disconsis> ski: could you expand on that?
02:58:52 <simon> disconsis, structural induction is explained in Types and Programming Languages by Benjamin Pierce.
03:00:34 <Nevoic> I'm getting an interesting type mismatch, being unable to match `Data.Text.Internal.Text` with `Data.Text.Internal.Lazy.Text`.
03:01:04 <tdammers> what's interesting about that? they're different types, using one where the other is expected won't work
03:01:29 <Nevoic> I never instantiate a "text" type directly, I'm using libraries that apparently are using conflicting versions.
03:01:35 <Nevoic> And "OverloadedStrings" is choosing them at different times.
03:01:40 <dminuoso> Nevoic: Imagine you had two types TextLazy and TextStrict.
03:01:56 <dminuoso> Nevoic: Would you agree that you cant apply `f :: TextLazy -> Int` to `x :: TextStrict` ?
03:02:08 <ski> disconsis : which part of it were you unsure about ?
03:02:24 <Nevoic> I mean I understand they're different types, what I don't understand is why there are 5 string types I have, and why this is a problem I uniquely experience in Haskell.
03:02:33 <Nevoic> Does everyone in Haskell just get used to constantly wrangling with String types?
03:02:34 <Shoubit> Nevoic, maybe TypeApplications can help?
03:02:51 <dminuoso> Nevoic: What are the 5 types to you?
03:03:04 <tdammers> there's only 2, really - Text and lazy Text
03:03:08 <dminuoso> And String.
03:03:11 <disconsis> ski: the structural induction is the part that I do understand
03:03:11 <dminuoso> So there's 3 total.
03:03:18 <tdammers> the ByteString flavors aren't strings, they're byte arrays (the name is a bit misleading)
03:03:21 <Nevoic> Strict Text, Lazy Text, String, Strict ByteString, LazyByteString
03:03:31 <Nevoic> Well `OverloadedStrings` would disagree with you.
03:03:33 <dminuoso> Nevoic: ByteString are just binary data.
03:03:40 <Nevoic> I can make a ByteString with ""
03:03:41 <dminuoso> Nevoic: That IsString instance is unfortunate.
03:03:41 <disconsis> ski: what I'm having trouble with is the examples of any property
03:03:42 <ski> disconsis : what is "induction", in your context ?
03:03:49 <tdammers> OverloadedStrings means overloaded string literals, not overloaded strings (another misnomer)
03:04:05 <Nevoic> Alright, my bad. I should really stop speaking English, I'm apparently terrible at getting my point across.
03:04:14 <dminuoso> Nevoic: The IsInstance morally considers it unicode text and then *encodes* it into a byte array
03:04:19 <Nevoic> I don't like that there are 5 types that are expressed by " "
03:04:19 <dminuoso> Nevoic: *IsString
03:04:21 <disconsis> ski: not sure what you mean. mathematical induction over the rules, I think...
03:04:25 <Nevoic> I call " " strings in every other language.
03:04:34 <dminuoso> Nevoic: That's OverloadedStrings for you
03:04:34 <Nevoic> But in Haskell apparently that's not the case.
03:04:39 <dminuoso> Nevoic: You are not required to use that extension. :)
03:04:54 <dminuoso> Nevoic: So are you familiar with the difference between String and Text?
03:04:56 <ski> disconsis : ok. i assume you know about induction over the natural numbers then. do you know about induction over lists ? trees ?
03:05:01 <Nevoic> dminuoso: yup.
03:05:09 <Nevoic> And I understand strict/lazy versions of Text.
03:05:13 <Nevoic> I also understand what ByteString is.
03:05:32 <Nevoic> Not using OverloadedSTrings won't fix the fact that I have 4 different libraries that are all using different "string implementations"
03:05:40 <dminuoso> Nevoic: Its not a string implementation.
03:05:51 <Nevoic> Notice the quotes. I'm aware.
03:05:53 <Nevoic> String is the only String.
03:05:58 <disconsis> ski: I do, but the induction here is over any arbitrary set of rules. I should be able to explain my confusion better with an example
03:06:04 <Nevoic> They're all using different "quote implementations".
03:06:16 <dminuoso> Nevoic: they dont use, you do.
03:06:27 <Nevoic> I didn't make these libraries.
03:06:35 <dminuoso> Nevoic: Basically, with OverloadedStrings enabled, a string literal: "foo" :: IsString a => a
03:06:48 <Nevoic> Some of them require LazyText, some of them require StrictText, some of them require String, some of them require ByteString.
03:06:51 <dminuoso> Nevoic: Its just like how numeric literals are also polymorphic: 5 :: Num a => a
03:08:21 <dminuoso> Nevoic: Now the trick is as follows: `text` provides a datatype called `Text` and it provides for an `instance IsString Text`, now you can use polymorphic values of type `IsString a => a` in place of Text.
03:08:39 <dminuoso> Nevoic: Saving yourself from having to introduce an additional function `stringToText "foo"`
03:08:59 <Rembane> Nevoic: Do you have an example on these libraries?
03:09:04 <yushyin> Nevoic: in python I also have b(" ") which is a bytestring and " " which is a unicode string. So no it isn't unique to haskell. it is similar in c++ and rust too.
03:09:42 <dminuoso> Nevoic You are however, at no point, required to use the IsString interface.
03:09:50 <dminuoso> (Unless the library has no other mechanism)
03:10:00 <Nevoic> yushyin: I've used Python, Haskell, Kotlin, Ruby, Rust, and Java for writing web applications at this point.
03:10:00 <dminuoso> % :t Data.Text.pack
03:10:00 <yahb> dminuoso: String -> Data.Text.Internal.Text
03:10:11 <Nevoic> The only language in that group that I've ever had to do string conversions is Haskell.
03:10:12 <dminuoso> Nevoic: ^- so you can use this instead of OverloadedStrings if you like.
03:10:13 <Nevoic> out of that bunch.
03:10:33 <dminuoso> Nevoic: Try elixir or erlang. ;)
03:10:41 <dminuoso> They have the same "mistake" that we do.
03:11:06 <Nevoic> Nobody is actually answering the question I have, which is how do you all deal with this? Do you just constantly do conversions from different types depending on the libraries you're using?
03:11:08 <dminuoso> Nevoic: Essentially the main issue is just having [Char] when we probably ought to be using Text in most places.
03:11:15 <Nevoic> I don't like having to use `pack` `unpack` `convert` etc. constantly.
03:11:17 <Rembane> Nevoic: I do conversions all the time. 
03:11:20 <Nevoic> But if I need to, I'll accept it.
03:11:23 <Nevoic> Rembane: Good to know.
03:11:28 <Rembane> Nevoic: Where all the time is less times than you might think. 
03:11:34 <dminuoso> Nevoic: I try to avoid it by having as much text as possible.
03:11:52 <Nevoic> I literally replaced my prelude with a prelude that replaces `String` with `Text` to cut down on conversions as well.
03:11:58 <dminuoso> And conversions between lazy and strict text - those are just artifacts of optimizations.
03:11:58 <Nevoic> And I'm running into a *new* type of conversion.
03:12:09 <Nevoic> I don't even know how to convert lazy text -> strict text tbh.
03:12:20 <Rembane> Nevoic: toStrict iirc
03:13:03 <dminuoso> Nevoic: Or rather, you have these strict/lazy optimizations in every setting where you make use of lazyness and strictness.
03:13:16 <dminuoso> You'd have the same problem in Java if you did enough streaming.
03:13:27 <dminuoso> Where you might convert streams into concrete containers and back again depending on the needs.
03:13:36 <dminuoso> They call it streams, we call it lazy.
03:13:57 <dminuoso> (Its not exactly equivalent, but its similar)
03:14:25 <Nevoic> Yeah I'm not a fan that Java 8 requires conversions to streams compared to like Kotlin/Ruby/Python etc. that have higher order functions on all their strict types.
03:14:30 <disconsis> /buffer 1
03:14:34 <Nevoic> Like 99% of the time idgaf if what I'm doing is lazy or strict.
03:14:37 <Nevoic> I just do the language default.
03:14:49 <Nevoic> Haskell's default laziness is cool sometimes, that's about the extent I care.
03:14:50 <sm[m]> Nevoic: you might be doing more conversions due to the combination of libs you are using. I think most of us have to throw in the occasional pack or unpack, not more than that
03:14:51 <dminuoso> Nevoic: Ruby requires conversions too.
03:15:50 <Nevoic> I know other languages have bytestrings, you guys have pointed that out to me a relentless number of times.
03:15:58 <Nevoic> I've never interacted with them though, because idiomatically no libraries use them.
03:16:09 <Nevoic> The JSON library that was suggested to me in here uses bytestrings.
03:16:10 <Nevoic> Aeson.
03:16:22 <dminuoso> Nevoic: The word "bytestring" is poor really. What they mean by bytestrings is something different.
03:16:29 <Nevoic> Every word I use is poor.
03:16:32 <dminuoso> Nevoic: ByteString ought to be understood as ByteArray, or Binary perhaps.
03:16:44 <dminuoso> BunchOfBitsAndBytes
03:17:06 <Nevoic> So what did you mean by "ruby requires conversions too"?
03:17:12 <Nevoic> What two string types are you referring to?
03:17:30 <dminuoso> Nevoic: When you want to have access to a raw bytearray, ruby wont do that magically for you.
03:17:42 <Nevoic> I don't mess with bytearrays in Ruby.
03:17:48 <dminuoso> "foo" in ruby is not a bytearray, its a text type akin to Haskell's Text.
03:18:15 <Nevoic> Ruby's "foo" is like Haskell's Text type *and* Haskell's String type.
03:18:17 <dminuoso> Nevoic: In some sense you could say that the `instance IsString ByteString` is convenience in case you are working with textual data encoded into utf8.
03:18:24 <dminuoso> Nevoic:no its just like Haskell's Text.
03:18:39 <Nevoic> If you do "potato" in Haskell, that'll be a String.
03:18:39 <dminuoso> Nevoic: ["f", "o", "o"] is the equivalent to Haskells String
03:18:51 <Nevoic> if you do "potato" in Ruby, that'll be a String as well.
03:19:09 <Nevoic> There's more to this than just the theory behind it. Sometimes I actually program.
03:19:14 <Nevoic> "this is a string"
03:19:16 <Nevoic> in my head.
03:19:23 <dminuoso> Nevoic: The term string is just very overloaded.
03:19:52 <Nevoic> Only in Haskell terminology, I think.
03:19:59 <dminuoso> Nevoic: No in every terminology.
03:20:04 <Nevoic> I've never had trouble speaking to OO programmers about strings.
03:20:27 <dminuoso> Nevoic: You should try and find a definition for "what is a string" with your partner.
03:20:29 <Nevoic> We all had a common understanding that there's *a string* type in whatever language we're working in. Sometimes there are implementation details about *that string* type that we have to concern ourselves with.
03:20:37 <Nevoic> I don't care about the definition if I'm able to talk to them.
03:20:45 <Nevoic> "That's a string, that's an int", the words go across and they make sense.
03:21:33 <Nevoic> In Haskell, this term that I use as commonly as "Int" is super overloaded and complex to talk about.
03:21:50 <dminuoso> Nevoic: If a string is a series of characters, then how do we represent it?
03:21:56 <Nevoic> no clue.
03:21:59 <Nevoic> Really don't care, either.
03:22:05 <Nevoic> The language maintainers usually figure that out for me.
03:22:07 <Nevoic> That's the cool part.
03:22:25 <dminuoso> Nevoic: But you should, because the implementation imposes limitations and performance considerations.
03:22:33 <Nevoic> If I was programming in C I would care.
03:22:47 <dminuoso> Nevoic: The most naive way is to see if you have any list-type flying around, and then just stick "characters" (whatever a character is) inside that list.
03:22:50 <dminuoso> That's what Haskell did.
03:22:55 <dminuoso> type String = [Char]
03:22:56 <Nevoic> I don't care about optimizing my strings in a high level language, generally speaking.
03:23:05 <Nevoic> And by "generally speaking" I mean 99% of the time I'm programming.
03:23:06 <saurabhnanda> is there any "for dummies" tutorial about MonadBaseControl?
03:23:20 <Nevoic> It feels akin to not using classes in Python to eek out the extra performance of not using `self`.
03:23:31 <Nevoic> Like you can do it, but you wouldn't, because you're using Python, nobody cares about that small amount of performance.
03:23:40 <Nevoic> If I'm coding in Kotlin, I don't care about if my strings are lazily or strictly evaluated.
03:23:47 <Nevoic> They're strings. They're a sequence of characters.
03:23:48 * ski . o O ( `char str[len + 1];' )
03:23:54 <saurabhnanda> I've spent an hour on https://www.stackage.org/haddock/lts-12.1/monad-control-1.0.2.3/Control-Monad-Trans-Control.html and cannot make any sense of it whatsoever
03:24:13 <dminuoso> Nevoic: Here comes the catch, in Haskell [] is implemented as a singly linked list
03:24:14 <Nevoic> If I lose 450 nanoseconds of performance because a sequence of characters was evaluated strictly instead of lazily, I'll be fine.
03:24:45 <marmulak> Um that's what you think
03:25:08 <Nevoic> marmulak: That's what I value, not what I think.
03:25:44 <yushyin> sequence of _what_ characters? unicode characters? because that's a tricky one.
03:25:45 <Nevoic> .00045 milliseconds isn't that big of a deal to me.
03:26:14 <dminuoso> yushyin: Indeed, character set becomes an interesting part now.
03:26:20 <marmulak> Lazy evaluation is best evaluation
03:26:22 <dminuoso> yushyin: And then once we write that to the disk we need to talk about encoding too.
03:26:53 <dminuoso> Many languages let you ignore this by making blind assumptions.
03:26:59 <dminuoso> And you end up with mojibake frequently.
03:27:08 <Nevoic> I have an idea. Why don't we introduce *more* string types that explicitly declare what kind of encoding & character sets they use?
03:27:18 <Nevoic> I'll use a LazyUTF8ASCIIString
03:27:34 <dminuoso> Nevoic: The encoding is irrelevant for holding it in memory.
03:27:54 <Nevoic> The lazy/strict evaluation is irrelevant for everything I do.
03:28:09 <Nevoic> But that irrelevancy doesn't stop me from having to think about it explicitly.
03:28:30 <dminuoso> Nevoic: You are not the sole user of a library. Some libraries are designed to allow for chewing through large amounts of data, where lazyness really improves performance by a lot.
03:28:47 <ski> (TIL "mojibake")
03:28:49 <Nevoic> Yeah, apparently every library I've ever used.
03:29:18 <Nevoic> Either I'm just terrible at choosing libraries (i.e listening to people's suggestions), or the Haskell community by and large is processing massive amounts of strings at different times that either require strict or lazy evaluation.
03:31:20 <Nevoic> how would you convert a `Data.Text.Internal.Text` to a `Data.Text.Internal.Lazy.Text`?
03:31:36 <Nevoic> couldn't find a toLazy.
03:31:56 <Nevoic> `fromStrict`, got it.
03:36:06 <simon> Nevoic, those who don't care for performance usually use String (aka [Char]); when you venture into production-ready packages, they use whatever makes sense (ByteString, Text, strict/lazy).
03:40:38 <simon> Nevoic, for example, I realized earlier today that Network.HTTP.Client + Servant.Client couldn't automatically convert an application/octet-stream into a Text; I *know* it's just ASCII, but the sane library default would necessitate ByteString. since it's the entire message body of a response, it would be natural to use a lazy ByteString, because what if the user doesn't need to actually read it or all of i
03:40:44 <simon> t? so now I both gotta make it strict, and decode it as UTF-8.
03:41:35 <Shoubit> Nevoic, Lazy.Text is internally represented as chunks of strict Text so you can use `Data.Text.Internal.Lazy` and its `chunk :: Text -> Lazy.Text -> Lazy.Text` as `chunk strictText mempty`, for example.
03:44:24 <dminuoso> Nevoic: You could pretent that `data Text = Text [S.Text]` (the actual implementation is subly different, but it's just that basically)
03:46:09 <dminuoso> Nevoic: But I understand your frustration, I felt the same when I was new to Haskell. For me it changed once I understood why the conversions were necessary - and now I honestly dont notice it happening much anymore.
03:46:55 <dminuoso> (Frequent mismatches between String/L.Text/S.Text/L.ByteString/S.ByteString appear to be indicative of a misdesign or thinking about them wrongly)
03:47:36 <dminuoso> Now Im just annoyed by the String <> Text mess we have, but things are what they are.
03:50:35 <Nevoic> I'll get used to it, no language is perfect, and Haskell is probably my favorite language atm.
03:50:50 <yushyin> yeah, that's unfortunate and it doesn't help much that we often use String while we teach haskell to others.
03:51:43 <dminuoso> Nevoic: If you want to uncover some of the subtleties about strings, try C++ strings for a while.,
03:51:44 <yushyin> of course I also understand why we do that
03:51:45 <Nevoic> I think Prelude could use an overhaul tbh. Partial functions in the prelude are blegh IMO and the usage of String over Text is also blegh.
03:52:59 <infinisil> String is nice for manipulation though, a list of chars you can pattern match on
03:53:12 <dminuoso> Nevoic: I mean here comes a fun question: You have a string (Im not defining this word any further) `faeŒª` - how many characters does this have?
03:53:16 <infinisil> But then again, one could just use [Char] for that
03:53:38 <Nevoic> 4, although I'm sure "I don't know" is the proper answer.
03:54:12 <alp> simon, that should be fixable with a suitable MimeUnrender instance for Text or a wrapper around it.
03:56:09 <dminuoso> Nevoic: Lets presume we are talking about unicode (first assumption!). Are we talking about characters in the unicode set? Or perhaps we are thinking about some concrete encoding, but what does "next character mean"?. Is it the next byte? Multi byte characters makes this fun. Or perhaps we mean the glyph representing it? But depending on the language, `ae` might be a ligature and visualized as `√¶`
03:56:18 <simon> yushyin, I made an effort to go through the early String exercises on Exercism.io and add optional Data.Text extensions; might as well learn early. :-)
03:56:45 <simon> alp, nice, thanks! I figured I had bigger problems, but I'll look into it.
03:56:48 <dminuoso> Nevoic: Strings are a very messy business.
03:57:06 <Nevoic> dminuoso: So is managing memory addresses.
03:57:13 <Nevoic> And I feel blessed that I don't have to actively deal with that in Haskell.
03:57:22 <dminuoso> Nevoic: memory management is simple and easily definable at least. :)
03:57:52 <Nevoic> Surely you see my point, though.
03:58:15 <cspollard> hi! I'm just wondering if there is already a "canonical" library with free profunctors that are also arrows similar to https://elvishjerricco.github.io/2017/03/10/profunctors-arrows-and-static-analysis.html?
03:58:55 <cspollard> I can reinvent the wheel fairly straightforwardly, but I prefer not to if it already exists.
03:59:03 <simon> alp, d'oh, turns out I had put '[JSON] when I should have put '[PlainText] -_-
03:59:26 <alp> simon, well, you'll want to put OctetStream instead, I suppose :)
03:59:51 <dminuoso> Nevoic: My point is, you have characters, codepoints, bytes and glyphs at play. People talking about strings are usually very fuzzy and mix them up.
04:00:23 <simon> alp, you're right. and then a MimeUnrender. even though it didn't complain with an UnsupportedContentType when asking for '[PlainText] on an octet-stream.
04:00:27 <alp> simon, https://hackage.haskell.org/package/servant-0.16.1/docs/Servant-API-ContentTypes.html#t:OctetStream <- it can only be decoded from/encoded to strict and lazy bytestrings
04:00:40 <Nevoic> dminuoso: If my entire exposure to strings was this IRC chat, I'd definitely agree.
04:01:20 <alp> but you can write an additional instance or two for Text or a wrapper around it, or whatever is appropriate for you, that implements the utf8 decoding
04:01:35 <dminuoso> Nevoic: And I made my own mistake. In unicode you have code points that are represented as code units, which are encoded into single or multi bytes, which are rendered into glyphs.
04:01:54 <dminuoso> And then you have the abstract concept of `character` ontop of it.
04:02:34 <dminuoso> And even that is fuzzy and hard to define.
04:03:26 <dminuoso> Nevoic: For example, how many "characters" does the following string have: `‰Ω†Â•ΩÔºå‰Ω†Â•ΩÂêó`
04:03:41 <Nevoic> And yet, despite all that complexity that you can rattle on and on about, I'm still able to use strings.
04:03:46 <dminuoso> The truth is, we cant talk about it, we can only talk about how many code units are in there.
04:03:47 <Nevoic> The power of abstraction.
04:04:18 <Nevoic> I don't usually write in Japanese, or whatever language that is.
04:05:33 <dminuoso> Nevoic: If you live under the assumption that a string must be composed of code units (and we call those code units `characters`), and that the only encoding is UTF-8, and the only valid implementation is some densely packed binary representation, then yeah - you talk talk to millions of programmers and fling around the word "String" and you will be on the same frequency. :)
04:06:08 <dminuoso> And additionally assume that the only code units that the string can contain are those used by your western language..
04:06:13 <alp> simon, feel free to ping me here or on #servant if you can't get it to work
04:06:34 <Nevoic> I live under the assumption that I'm able to use something without having to explicitly account for every possible edge case, and that on top of that a lot of edge cases can be caught generally by the language I'm in.
04:07:01 <Nevoic> I write absolutely no code, generally speaking, to handle Japanese characters. I don't need to handle them, and yet, if I came across them, magically, the language I'm in would do something with them.
04:07:16 <dminuoso> "something"
04:07:21 <Nevoic> yup.
04:07:46 <simon> alp, I got it to work! and I'm joining #servant. ;-P
04:07:57 <Nevoic> i.e the app wouldn't blow my computer up. An exception would be thrown, the characters would be handled, something.
04:07:57 <dminuoso> Nevoic: Strings are not something intrinstic in programming that exists in all programming languages and must be the same. The concept is way too complex for that. :)
04:08:20 * ski . o O ( "We must do something ! This is something. We must do this !" )
04:08:48 <Nevoic> dminuoso: I don't remember using a language where "potato" isn't a valid expression.
04:08:56 <Nevoic> I'm sure there is one, I probably just haven't used it.
04:09:47 <dminuoso> Nevoic: What is "potato" supposed to produce though? Should it produce a list of characters? Some binary unicode representation? Or should it perhaps render that unicode representation, encode it into JPG, and give you the binary data back?
04:09:54 <Nevoic> A string.
04:10:07 <dminuoso> Nevoic: All three would be valid notions of what a string could be.
04:10:29 <Nevoic> Yup, and that language would decide which notion it wants to play with internally.
04:10:50 <dminuoso> Nevoic: IsString is the observation that you can turn a list of unicode characters into some data. It's basically a sort of Read.
04:11:38 <dminuoso> Nevoic: So it gives *you* the freedom to say how that list should be interpreted.
04:11:41 <Nevoic> I'm used to languages making the determination that "some data" is the type "String". Not `String | Text | ByteString | etc.`
04:11:49 <Nevoic> Yeah, that freedom is literally going to kill me.
04:11:50 <ski> (hm, wasn't there some language where double quotes delimited comments ?)
04:12:14 <dminuoso> Nevoic: Then dont turn OverloadedStrings on. 
04:12:25 <dminuoso> ski: vim config files?
04:12:33 <dminuoso> Its called vimscript I think?
04:12:42 <Nevoic> All that does for me is make it so I have to manually convert `String` into other, used "String" types.
04:12:44 <Nevoic> It saves me nothing.
04:12:58 <ski> hm, i'm not a Vim user
04:13:23 <Nevoic> If turning it off made it so nobody else used it and everybody used `String` to the same degree that `String` is used in Kotlin or `str` in Python, I'd do it in a heartbeat.
04:14:12 <hpc> even in python you're dealing with multiple types of string
04:14:12 <Nevoic> If someone honestly asked me "What's the string type in Kotlin?" I'd say `String`. If they asked me in Haskell, I'd say `String or Text, but also if you turn on this common language extension, there are a few other types as well, and a lot of libraries use that, and end up using these other types that fall under the isString abstraction`
04:14:16 <hpc> you just don't have "types" to help you out
04:14:28 <hpc> see also, differences between python2 and python3
04:14:55 <Nevoic> `str` is the string type in Python. If I want to see if something is a string, I do `isinstance(name, str)` or whatever the call order is on that method.
04:15:03 <Nevoic> Haskell has at least two, equally valid string types.
04:15:05 <Nevoic> Text and String.
04:15:21 <Ariakenom> hpc: which do you mean?
04:15:24 <dminuoso> Nevoic: Should "foo" be a list of characters? Or a dense efficient unicode representation? Or an utf-8 encoding of that unicode? Or maybe a font rendering of that unicode text? Or maybe something else entirely?
04:15:24 <Nevoic> The Prelude will use entirely String, and entire libraries will interface with Text.
04:15:30 <dminuoso> Nevoic: Which one should it be in your language?
04:15:40 <dminuoso> Nevoic: What do you want "foo" to mean exactly?
04:15:44 <Nevoic> dminuoso: I'm not a language designer, so I haven't thought about it.
04:15:58 <Nevoic> I'll offload that responsibility onto people who design languages.
04:15:59 <hpc> Ariakenom: python2 has strings default to being a sequence of bytes, but you can choose to use unicode strings if you explicitly decode a regular string
04:16:13 <Nevoic> I also generally don't think about what kind of pavement I'm driving on while going to work.
04:16:14 <hpc> Ariakenom: python3 is the opposite, unicode by default and you can choose to encode it
04:16:19 <Nevoic> It's cool to be able to offload that responsibility to someone else.
04:16:24 <Nevoic> Even if I prefer one kind of pavement to another.
04:16:29 <Nevoic> I just generally don't think about it.
04:16:44 <Ariakenom> hpc: agree for python 2. as far as I see it python 3 has one string type and one byte type.
04:16:44 <dminuoso> Nevoic: Try putting yourself into the language designer position for a moment to truly appreciate the complexity of this.
04:17:05 <dminuoso> Nevoic: And try and answer my question above. :)
04:17:10 <Nevoic> I've been reading and comprehending what you're saying, the answer is truly I don't know.
04:18:31 <simon> in Emacs haskell-mode, it seems to warn me when I put my LANGUAGE pragmas in package.yaml rather than as {-# LANGUAGE ... #-} at the top.
04:18:54 <Nevoic> I like a `list of characters` so I can pattern match on the characters, I like efficient representations. I also like accurate representations of unicode.
04:20:02 <dminuoso> Nevoic: Personally I think QQ gives you the better flexibility and more rigid semantics.
04:21:04 <hpc> Ariakenom: it could be argued that Text corresponds to python3 strings, and String corresponds to iterators/generators
04:21:32 <Nevoic> dminuoso: Here's the interesting thing though. I have no idea how `String`s are represented internally in Kotlin, and yet I can pattern match on them and they accurately represent unicode characters.
04:21:52 <simon> Nevoic, most likely as sequential allocations.
04:21:56 <Ariakenom> im gonna have to see that argument.
04:22:25 <hpc> for example, maybe you get surprised in haskell by wanting String and getting Text
04:22:28 <simon> Nevoic, and surely you do care about this when you recursively/iteratively append strings?
04:22:29 <hpc> or wanting Text and getting String
04:22:48 <dminuoso> Nevoic: So in Haskell we have an additional consideration, because at any of the levels above you also have lazyness.
04:22:50 <hpc> in python, i am constantly surprised by wanting just a plain string, and getting an iterator
04:22:54 <hpc> maybe i want to map over a string
04:22:59 <hpc> well now i don't have a string anymore
04:24:01 <Nevoic> simon: Generally no. I have used StringBuilder before, and that's a fair point, but very, very rarely. And that optimization can just be pushed to the compiler, anyway.
04:24:25 <dminuoso> Nevoic: So now you end up with "is this a list of characters", "is this a list of chunks each representing unicode characters", "is this a unicode character representation", "is this a list of chunks each consisting of utf-8 encoded unicode characters", "is this utf-8 encoded unicode characters", "or is this something else"
04:24:43 <dminuoso> Nevoic: So once you get there you may realize that locking into any one usecase might be overly limiting, because many of these are interesting.
04:24:49 <Ariakenom> hpc: sure you get another type. wouldnt call it a string, or String, though
04:24:55 <simon> Nevoic, I agree on your argument that if a language provides sane defaults, unknowing programmers can do many things right.
04:25:03 <simon> Nevoic, I think Java has progressed well here for strings.
04:25:05 <hpc> well, String isn't really String
04:25:08 <hpc> it's [Char]
04:25:11 <hpc> and guess what:
04:25:15 <hpc> >>> map(lambda x: x, "test")
04:25:15 <hpc> ['t', 'e', 's', 't']
04:25:22 <Nevoic> simon: Thank you. That's pretty much my entire point.
04:25:24 <hpc> <type 'list'>
04:25:43 <dminuoso> Nevoic: And for what its worth, even my list is incredibly limited, because I blindly assumed we can only talk about Unicode, and we can only talk about UTF-8.
04:25:49 <maerwald> "sane" is a pretty open definition
04:26:03 <Nevoic> dminuoso: Would you support having a String type for every possible representation of String?
04:26:04 <Ariakenom> hpc: not sure what you mean. I meant in python you get another type
04:26:10 <Nevoic> Say like 40/50 different Strings?
04:26:16 <dminuoso> Nevoic: You mean a different type?
04:26:19 <Nevoic> yup!
04:26:23 <dminuoso> Nevoic: That's what we have EXACTLY.
04:26:24 <merijn> Nevoic: If accompanied with something like Backpack to make it manageable, then yes
04:26:50 <Nevoic> dminuoso: But have them all being equally used. You can represent characters however you want. I'm talking practically speaking.
04:26:57 <dminuoso> Nevoic: We have `String`, `L.Text`, `S.Text`, `S.ByteString`, `L.ByteString`, `IP`, `IPv4`, `AddrRange IPv4`, `AddrRanve IPv6` and many many many more.
04:26:58 <Nevoic> You could form a lazy String in Kotlin, they have lazy sequences.
04:27:04 <dminuoso> Nevoic: No wait!
04:27:09 <dminuoso> Nevoic: You are conflating two things here.
04:27:10 <Nevoic> mmkway
04:27:12 <simon> maerwald, I suppose Java also has byte[] and string, just not the lazy alternatives.
04:27:16 <maerwald> dminuoso: don't forget funny type aliases like FilePath =)
04:27:21 <dminuoso> Nevoic: No library should mandate you use IsString.
04:27:37 <hpc> simon: don't forget char[]
04:27:41 <dminuoso> Nevoic: The IsString is just for your convenience to reduce the pain to convert a string into that other representation.
04:28:06 <dminuoso> Nevoic: For example you can write:
04:28:11 <dminuoso> "foo" :: Text
04:28:11 <Nevoic> That convenience leads to more types of strings, which generates the need for more conversions.
04:28:16 <dminuoso> "foo" :: Strict.ByteString
04:28:28 <merijn> dminuoso: Horrible example, shame on you
04:28:33 <dminuoso> merijn: Hah. :p
04:29:00 <Nevoic> The reason Haskell probably has literally 800,000 commonly used String types, as opposed to the one in Kotlin, isn't because Kotlin can't support Lazy Text strings, or whatever, it's because the language linguistically forces all `" "` to be of type String.
04:29:03 <dminuoso> Nevoic: The notion of string is not introduced by IsString, its by the existance of fuctions `f :: String -> T`
04:29:19 <simon> Nevoic, if you don't count the lazy ones, Haskell has about as many as Java.
04:29:19 <hpc> Nevoic: to my memory, IsString postdates all of its instances
04:29:21 <dminuoso> Nevoic: So every time you have a function `f :: String -> T` for some type T, you could say that `T` is a representation of a string.
04:29:33 <Ariakenom> dminuoso: that's a bold definition
04:29:52 <dminuoso> Ariakenom: You give me a String, I give you a T representation for it.
04:29:57 <dminuoso> And I do it purely.
04:30:02 <ski> (`f' should probably be injective ?)
04:30:25 <dminuoso> ski: I dont see why.
04:30:33 <simon> Nevoic, you think that because Haskell has overloaded string literals, one hasn't dominated them all?
04:30:43 <merijn> dminuoso: User sanity
04:30:49 <Ariakenom> dminuoso: you were being pedantic about unicode a second ago. and now you have it equivalent to String
04:31:01 <ski> dminuoso : representations of distinct strings are not guaranteed to be distinct ?
04:31:03 <Nevoic> The crucial point literally everyone here is missing is the practical side of this. By the very fact that "potato" is one type, and only ever one type, is the reason why I don't have to convert between string types in other languages nearly as often.
04:31:07 <Nevoic> As in literally never.
04:31:10 <dminuoso> ski: They are certainly not.
04:31:26 <Nevoic> simon: yes
04:31:27 <dminuoso> ski: Consider if we assume the representation of a string to be the font rendering of it.
04:31:37 <dminuoso> ski: Then two different unicode strings could produce the same rendering.
04:32:01 <ski> ok. so you meant something else by "representation" than i thought you was
04:32:07 <merijn> dminuoso: They can
04:32:38 <merijn> dminuoso: In fact, there are often MANY different sequence of unicode codepoints rendering identically
04:32:45 <Nevoic> saying `val name = "potato"` in Kotlin is a non-ambiguous statement.
04:32:48 <dminuoso> Ariakenom: Its a good point, but IsString is the selection of all those functions where you would honestly think of that `T` as being some sort of "representation" of that String.
04:33:04 <dminuoso> Nevoic: Its also non-ambiguous in Haskell, as long as `names` type can be inferred.
04:33:07 <merijn> wait, I think I missed a comment
04:33:09 <simon> Nevoic, so, regardless of whether you code Python, Java, Perl or Haskell, you have to convert between byte sequences and encoded strings. this creates at least two types; adding laziness this adds at least another two. if you notice this more in Haskell, it is probably because one has to think about laziness.
04:33:20 <ski> Nevoic : fwiw, i don't follow "That convenience leads to more types of strings, which generates the need for more conversions."
04:33:26 <Nevoic> dminuoso: It being inferred doesn't make it non-ambiguous *to the user*.
04:33:33 <Nevoic> I am not a compiler.
04:33:39 <dminuoso> Nevoic: That's why you should write type annotations. ;)
04:33:44 <merijn> Nevoic: That is just an argument against OverloadedStrings
04:33:51 <simon> dminuoso, I'm not a compiler!
04:33:54 <merijn> Nevoic: Which, sure, I agree with. OverloadedStrings is mostly bad
04:33:55 <Nevoic> merijn no, not just.
04:34:01 <ski> (specifically, the "which generates the need for more conversions" is doubtful, or at least unclear, to me)
04:34:02 <maerwald> merijn: +1
04:34:14 <simon> dminuoso, surely the compiler will write my type annotations! ;)
04:34:15 <Nevoic> OverloadedStrings are super commonly used, which allowed for people to openly use whatever "String" type they wanted.
04:34:17 <merijn> Nevoic: In the absence of OverloadedStrings string literals have 1 single unambiguos type
04:34:20 <Ariakenom> dminuoso: you said notion of string. not definition of IsString
04:34:26 <Nevoic> merijn I know.
04:34:30 <maerwald> what does ByteString instance of IsString do :>
04:34:40 <merijn> Nevoic: Your complaint was "ambiguity" that eliminates the ambiguity
04:34:55 <merijn> Nevoic: You can't get rid of "different string types", because different string types are good for different things
04:35:10 <dminuoso> Ariakenom: Perhaps I was careless and should have used [Char] instead of String.
04:35:12 <Nevoic> That wasn't the point.
04:35:13 <simon> Nevoic, also, since I'm also playing around with JSON, I was recommended https://hackage.haskell.org/package/string-conversions/docs/Data-String-Conversions.html just a moment ago. it handles string conversion quite seamlessly.
04:35:23 <Nevoic> I said this a while earlier, and I feel like nobody read it.
04:35:44 <Nevoic> But the fact that Haskell has OverloadedStrings makes it so people can define their own types of strings, or stray from the "norm" super easily.
04:35:53 <Nevoic> It's allowed `Text` to soar in popularity.
04:36:03 <simon> Nevoic, which is good!
04:36:05 <dminuoso> Nevoic: The popularity of `text` is a good thing.
04:36:09 <Nevoic> No!
04:36:12 <Nevoic> Holy crap XD
04:36:17 <simon> haha
04:36:18 <merijn> Nevoic: Text is popular, not because of overloadedstrings, text is popular because Text is better at many things than String is
04:36:22 <dminuoso> String has mindboggingly bad performance in many situations.
04:36:32 <maerwald> I want ByteStrings always with encoding statically checked =)
04:36:35 <dminuoso> It has tremendous memory usage (you wouldn't believe it)
04:36:38 <simon> Nevoic, before OverloadedStrings we just did T.pack "Wat!"
04:36:40 <Nevoic> This is a short coming of Haskell's string implementation. Haskell introduced a problem that it then fixed, which introduced more problems.
04:36:47 <merijn> maerwald: That doesn't make sense, ByteString doesn't have an encoding
04:36:51 <maerwald> exactly
04:36:55 <hpc> another point missed in this conversation is that OverloadedStrings is a relatively new extension
04:37:01 <maerwald> That's why it makes sense
04:37:14 <dminuoso> merijn: I think they meant that the IsString instance should do compile-time checking.
04:37:18 <maerwald> there is unknown encoding and known encoding 
04:37:30 <simon> Nevoic, Data.Text does string fusion. it is one of the coolest things I can think of about Haskell, that a random third-party package can extend this kind of compiler optimization.
04:37:34 <Nevoic> It's like me starving a group of African children then flying in with a helicopter of bananas and being praised as a god for giving the starving children food.
04:37:36 <merijn> Clearly we should just remove OverloadedStrings, add a different syntax for Text and then point everyone else at my validated-literals library ;)
04:38:08 <simon> Nevoic, but yes, we fixed one problem and introduced another with Data.Text. you're right about it.
04:38:10 <dminuoso> merijn: But we have that already.
04:38:13 <dminuoso> merijn: Its called QQ.
04:38:22 <dminuoso> [t| some densely packed text ]
04:38:27 <merijn> dminuoso: QQ are super freaking slow, though
04:38:33 <maerwald> merijn: https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html
04:38:44 <maerwald> so instead of that, I want encoding info on top
04:38:56 <dminuoso> merijn: So perhaps a different syntax for invoking IsString?
04:39:03 <maerwald> without going Text or something else that is unnecessary
04:39:06 <lyxia> Nevoic: what's the oblem with Tex
04:39:14 <merijn> dminuoso: Most non-Text instance of IsString are bad anyway
04:39:23 <merijn> dminuoso: Name one non-Text instance that isn't bad
04:39:26 <dminuoso> merijn: That I wholeheartedly agree with.
04:39:35 <merijn> dminuoso: Ergo, we should just get rid of IsString
04:39:41 <merijn> And support Text natively
04:39:58 <Nevoic> All I know is that simply put:
04:39:58 <Nevoic> I'm never sitting in Java thinking "god DAMN IT! these strings are slow, I wish I could develop my own string type and use it instead of the default string".
04:39:58 <Nevoic> I'm always sitting in Haskel lthinking "god DAMN IT! I need to do another conversion of Data.Text.Internal.Lazy.Text to Data.Text.Internal.Text again" or "damn it I need to `pack` my string, or `convert` it, or `toStrict` it, etc.
04:40:01 <Ariakenom> rename IsString to StringOrText
04:40:03 <dminuoso> merijn: Isnt text already maintained by the ghc team?
04:40:25 <dminuoso> I thought it was a core library
04:40:37 <merijn> No it's not, afaik
04:40:59 <dminuoso> merijn: But yeah, Ive had 2 issues involving silently swallowed encoding errors in `instance IsString ByteString` 
04:41:01 <Nevoic> The only reason I'm talking about this is because Haskell introduced a complexity that was so odd and unknown to me that I have come searching for help multiple times because it baffles me that "String"s are not figured out in this community.
04:41:21 <Nevoic> The only solution is "welp do the conversions"
04:41:21 <dminuoso> merijn: I still remember sitting there, wondering "wait a moment... what exactly does it mean - how does one come from string to binary data without specifying an encoding..."
04:41:27 <merijn> Nevoic: No one has figured out String's, other language just more blatantly lie about it
04:41:28 <simon> Nevoic, I never think about inventing my own string type in Haskell, because I have Data.Text. ;-) also, I never think I need to do another conversion, because I have the string-conversions package. ;-)
04:41:43 <dminuoso> merijn: Amusingly Erlang has *exactly* the same problem that we are in.
04:41:48 <dminuoso> merijn: And they havent fixed it up until today.
04:42:11 <simon> dminuoso, Erlang has real strings now?
04:42:17 <dminuoso> simon: what is a "real" string?
04:42:23 <simon> dminuoso, not [Int].
04:42:42 <Nevoic> f (pack name) (toStrict color) (convert favoriteWord) vs. f(name, color, favoriteWord) is still extra complexity.
04:42:43 <dminuoso> simon: Sure, <<"foo">>
04:42:54 <Nevoic> Even if the conversions are "handled for me" and the string types are "already made".
04:43:21 <Nevoic> If I wanted to micromanage string performance, I'd use a lower level language.
04:43:24 <dminuoso> simon: They basically have ByteString and String floating around.
04:43:35 <dminuoso> Have had it for a long time.
04:43:40 <merijn> Nevoic: The complexity exists everywhere, other languages haven't "solved" it or "found a solution" they all either 1) lie and do the wrong thing in many cases or 2) have multiple string types, those are the only two known options
04:43:44 <dminuoso> They dont have actual unicode strings, but oh well
04:44:04 <dminuoso> Nevoic: string performance happens in large scale systems easily.
04:44:05 <Nevoic> merijn I strongly disagree about that. It's not lying. They made a decision.
04:44:23 <dminuoso> Nevoic: Take for instance browsers.
04:44:28 <Nevoic> A decision that saved actual developers a crack ton of headaches.
04:44:35 <dminuoso> Nevoic: Or web servers. :)
04:44:55 <dminuoso> Nevoic: Unless they tell you how they implemented it and what the limitations are, they are just lying.
04:45:14 <dminuoso> And language vendors have a tendency to not tell you about the issues of a language.
04:45:28 <Nevoic> Lying would be "we solved Strings" I've never heard any language designer or group claim that.
04:45:34 <Nevoic> They just say "here's our string type" and then we use the string type.
04:45:42 <simon> the Perl web framework at work has something called a Mojo::ByteStream, which is actually just a reference to a Perl string, so there's not much Byte or Stream over it. but it is Mojo.
04:47:52 <simon> not that everyone is lying, of course.
04:47:54 <dminuoso> Nevoic: Or people dont care about using efficient/the right tool.
04:48:03 <yushyin> If I have text I use Text, it is that easy. And I don't pretend chunks of Bytes (bytestring) are strings.
04:48:18 <dminuoso> Nevoic: The lack of a lazy string type does not mean they are lying. Its just that people dont randomly expose streams over strings because they are so unwieldy to use in Java.
04:48:34 <simon> I pretended that Content-Type: application/octet-stream is UTF-8 as soon as two hours ago.
04:48:43 <dminuoso> So you write everything strict and dont care if your program takes 10s.
04:49:27 <Nevoic> dminuoso: It strongly encourages everyone to use the same single String type, do you see *any* advantage in that at all?
04:49:40 <Nevoic> or do you think that is just entirely pointless and there's absolutely no reason to have a single, standardized string?
04:50:28 <dminuoso> Nevoic: But why bother with things like Int then? 
04:50:39 <dminuoso> Nevoic: I mean we could just store integral types as their string representation and be happy right?
04:50:41 <merijn> I hardly ever use lazy Text/ByteString anymore, so there's really just 2 relevant string types "String" and "strict Text"
04:50:43 <dminuoso> Less types means less hassle.
04:51:00 <merijn> ByteString isn't a string, so it doesn't count anyway
04:51:07 <dminuoso> Nevoic: But yes, in that sense Haskell has solved it largely because `Text` exists.
04:51:14 <dminuoso> Nevoic: And indeed its annoying that String is still so widely used.
04:51:16 <simon> Nevoic, I did some data munching yesterday of 2.6GiB data with Java yesterday; because I needed to read lines, but didn't want to read the entire file, and because some files contain character set encoding errors, I could use BufferedReader#lines(), but not Files#lines().
04:51:17 <Nevoic> I disagree with that statement. Less conversions between things that are conceptually the same at the level I'm programming at means less hassle.
04:51:39 <lyxia> dminuoso: That's a bad slippery slope argument.
04:51:43 <Nevoic> I actually strongly enjoy statically typed languages with more complex type systems that can support more things.
04:51:53 <Nevoic> dependent typing etc.
04:52:05 <simon> Nevoic, this kind of thinking about laziness, encoding and reading exists in all languages; in Haskell's ecosystem it's expressed as types.
04:52:09 <dminuoso> lyxia: In what sense?
04:52:25 <dminuoso> lyxia: Oh in that its not solved because we still have String?
04:52:53 <lyxia> dminuoso: in that the question is about the friction of having multiple string types
04:53:04 <Nevoic> simon even in Java laziness is expressed by a (overly verbose IMO) type
04:53:12 <lyxia> and you're trying to justify that by comparing it to the distinction between strings and integers
04:54:31 <Nevoic> My problem isn't with things being typed. My problem is with unnecessary distinctions, for me. Maybe nobody else finds this problematic, and I'm the only person who has ever wrestled with different string types in Haskell being annoying.
04:54:38 <simon> Nevoic, but as merijn says: either you lie, or you have to verbosely present the many ways of strings. Haskell does both lie (with String being in Prelude) and is verbose (with extended libraries). :-D
04:54:59 <dminuoso> Nevoic: Which exact distinction appears as unnecessary to you?
04:55:03 <Nevoic> It's a costful abstraction, it's not a lie.
04:55:03 <simon> Nevoic, no, it is annoying.
04:55:15 <Nevoic> Not all abstractions are zero-cost abstractions.
04:55:22 <Nevoic> But it's an abstraction, nonetheless.
04:55:30 <Nevoic> One that most other languages I work in take, and one that I appreciate greatly.
04:55:33 <Nevoic> The cost is worth it.
04:55:35 <Nevoic> to me.
04:56:13 <Nevoic> dminuoso: The distinction between any two sequences of characters, for exactly the type of coding I'm doing rn.
04:56:23 <simon> Nevoic, some custom preludes eliminate String mostly in favor of Text. then you only have the lazy/strict distinction.
04:56:28 <Nevoic> I need to distinguish between "characters" and "numbers", for example.
04:56:38 <merijn> Nevoic: THen use strict Text and done
04:56:58 <Nevoic> Sadly I use libraries and the Prelude.
04:57:05 <Nevoic> I use Text absolutely everywhere I can.
04:57:15 <merijn> Most libraries support Text or have an equivalent that can
04:57:20 <lyxia> dminuoso: and you keep mentioning lazy strings, but I find them a questionable abstraction as opposed to proper streaming abstractions.
04:57:34 <merijn> lyxia++
04:57:37 <simon> lyxia, good point.
04:57:42 <merijn> Lazy Text is dead to me
04:57:43 <Nevoic> I find myself converting between Strict/Lazy text, as well as String/Text to interop with prelude functions.
04:57:56 <Nevoic> Strict/Lazy text was a new thing with Aeson, but it's a thing nonetheless.
04:58:01 <Nevoic> before that I didn't have to worry about that conersion.
04:58:05 <merijn> Nevoic: Most prelude functions on String have Text equivalents inside the text package
04:58:31 <J_Arcane> I am completely failing to configure Haddock paths or path output in Stack. something seems to have changed in 2.0 so that all my output HTML uses full file-path links that break once uploaded to a server. Andi t seems to totally ignore the "haddock-arguments" setting in stack.yaml, or the --haddock-arguments CLI arg.
04:58:50 <Nevoic> merijn my largest problem, by far, is interoping with libraries.
04:59:00 <merijn> Nevoic: Which ones?
04:59:01 <Nevoic> like I said previously, I use Text absolutely everywhere I can.
04:59:09 <Nevoic> Scotty, Aeson, Blaze, are the main libraries I'm using.
04:59:15 <Nevoic> Scotty and Aeson use different kinds of Text.
04:59:29 <Nevoic> They both use `Data.Text.Internal.etc` but one uses Strict and the other uses Lazy.
04:59:43 <Nevoic> Actually Aeson uses ByteString.
04:59:49 <Nevoic> Which I know I will be literally killed if I pretend that that is a string.
04:59:59 <simon> haha
05:00:07 <yushyin> Aeson has strict encode/decode variants, or not?
05:00:10 <simon> that's like byte[] is a string.
05:00:11 <Nevoic> But I have to convert between it and "real" string types.
05:00:14 <merijn> blaze seems to suppor Text just fine?
05:00:25 <Nevoic> merijn they support Text just fine, yes.
05:00:38 <Nevoic> It's about the kind of Text.
05:00:52 <Nevoic> Because of course you need a strict and lazy variant of Text.
05:00:55 <merijn> blaze has functions for both strict and lazy text
05:01:45 <Nevoic> I'm importing `Data.Text` and then creating a method that calls a blaze function, it's type annotated as requiring `Text`.
05:02:04 <Nevoic> I take a piece of `Text` from Scotty, and I have to convert it when I pass it in.
05:02:08 <Nevoic> It complains about a type mismatch.
05:02:36 <Nevoic> A type mismatch between two Text types.
05:03:05 <simon> lyxia, would you see Data.Text.Lazy as a prototypical streaming abstraction?
05:03:36 <lyxia> simon: when I said "lazy string" I meant lazy anything that looks like a string
05:03:38 <merijn> simon: I just use strict Text with conduit/pipes/machines/whatever nowadays
05:04:26 <simon> merijn, could everyone always do that? I kind of avoided Data.Text.Lazy and haven't used conduit/pipes for anything yet.
05:04:54 <merijn> simon: I don't see many cases where you couldn't?
05:05:11 <merijn> simon: Conduit is really nice for anything where you have large streams/sequences of data/input
05:06:16 <simon> Nevoic, so maybe all this mess is caused by Haskell still being researchy. most of the researchy stuff can be completely ignored if not enabled. not strings.
05:07:09 <lyxia> Yeah I like that explanation, Haskell wants to get string right, not good enough.
05:07:24 <merijn> honestly, I don't like that explanation
05:07:57 <merijn> Because it's not true. More proper solutions will break tons of code so face an uphill battle to adoption
05:08:29 <merijn> Maybe we can get a nicer solution/worlf if backpackified base takes over, but that's a big if
05:08:44 <simon> "backpackified base"?
05:08:51 <merijn> @where backpack
05:08:51 <lambdabot> I know nothing about backpack.
05:08:54 <merijn> hmm
05:09:08 <merijn> http://blog.ezyang.com/category/haskell/backpack/
05:10:10 <eacameron> Coming from Python, Haskell strings are annoying. Coming from C++ they are normal. In high performance scenarios you can't just pick one representation
05:10:13 <simon> merijn, maybe if e.g. Scotty and Aeson both decided to use strict Text and the same streaming mechanism for laziness in a backwards-compatible way, Nevoic would be happy.
05:10:19 <merijn> simon: That would allow people to write code parameterised over string types
05:11:13 <merijn> eacameron: Pfft, C++ only has...4 or so string types ;) Not counting the million custom ones out there too :p
05:12:22 <infinisil> I once used a (Word32, Word32, Word32, Word32, Word32) to represent a string lol
05:13:05 <eacameron> merijn: my point exactly
05:13:49 <eacameron> And all of them have tradeoffs
05:13:52 <simon> infinisil, why not a Data.Word.General.Word 160? ;) https://hackage.haskell.org/package/word
05:14:04 <tdammers> I find Python's "strings" a lot more confusing and brittle than Haskell's
05:14:23 <tdammers> in Python, you have "unicode strings" and "bytestrings", and it's very easy to accidentally mix them up
05:14:37 <simon> infinisil, a friend used a (Word32, Word32, Word32, Word32, ...) to represent a 512-bit word in his BSc project, ha.
05:14:44 <eacameron> Honestly I think it's just "Myths programmers believe: text is simple"
05:14:51 <marmulak> It's easy to do strings wrong I guess
05:15:24 <eacameron> tdammers: yes that's true nowadays
05:15:30 <marmulak> There are many myths
05:15:36 <tdammers> eacameron: always has been
05:15:59 <hpc> before text was complicated, it was /even more complicated/
05:16:02 <tdammers> eacameron: it's just that Python 3 is more picky about them, so your code blows up a bit earlier instead of silently producing incorrect resultrs
05:16:06 <eacameron> Didn't used to be before bytes came along... But that's kinda my point... They needed bytes and now it's no longer easy
05:16:58 <marmulak> I posted on my Facebook page that I'm learning Haskell and I explained why Haskell is actually worth learning, and all I got was comments like "I heard C is a good language" and "just use C#"
05:17:39 <simon> it was much easier when we didn't allow people to speak in their native languages on the internet.
05:18:05 <ski> marmulak, ok ?
05:18:09 <tdammers> the main things that made text difficult were two developments: one, when they started exchanging data between machines, and two, when they started using languages that use more characters than you can fit in 7 bits minus control codes
05:18:13 <marmulak> ok
05:18:22 <ski> (perhaps you shouldn't use Facebook ?)
05:19:00 <marmulak> I like utf8
05:19:04 <simon> marmulak, doesn't it become more of a namedropping programming languages conversation?
05:19:26 <simon> I üí© UTF-8
05:19:27 <marmulak> Yeah
05:19:33 <simon> (seen on a t-shirt)
05:20:22 <marmulak> One time in ACM club one of my friends gave a presentation why utf16 is much superior to utf8
05:22:19 <dminuoso> tdammers: Ive started to appreciate strings when I learned C++ and had discrepancies in std::string::length 
05:23:17 <tdammers> dminuoso: std::string has always annoyed me for not actually being able to represent non-8-bit encodings correctly
05:23:29 <sm[m]> wow.. strings discussion still going!
05:23:31 <tdammers> I remember thinking, why the fuck did they not do it right
05:23:55 <tdammers> why is there no 32-bit-character string type in the standard library
05:24:32 <marmulak> Asking the big questions
05:25:18 <lavalike> sm[m]: it's being strung along
05:25:23 <lyxia> If we took out the lazy strings, we're left with mostly Text and ByteString, I think that would satisfy most people.
05:25:31 <ShereKahn> playing with the latest stacks (2.1.1) and following the user guide, I just realized that --solver was removed. What is exepected to be used instead ? 
05:26:07 <lyxia> I mean, we do have other types, but they also don't matter to many applications.
05:26:44 <sm[m]> lavalike: now I feel a bit ropy
05:31:27 <sm[m]> ShereKahn: can stack init help ?
05:35:06 <merijn> ShereKahn: Isn't "stack --solver" basically what cabal-install does? >.>
05:36:13 <ShereKahn> could be, I admit I am very new to both tools ... 
05:36:35 <sm[m]> yes, so cabal install --dry, copy packages into stack.yaml extra-deps, could be another option
05:37:09 <merijn> ShereKahn: I'm not a stack user, but my understanding is that "stack --solver" just tries to dynamically compute a dependency build plan from Hackage, which is basically what cabal-install does anyway
05:38:05 <ShereKahn> ok thanks for the clarification
05:47:13 <Axman6> tdammers: there is, it's called String
05:48:30 <Axman6> oh, in C++, itt's probably called list_without_pushback<std::char32> or some other nonsense
05:49:01 <Axman6> marmulak: the problem is that it isn'
05:49:03 <Axman6> t
05:50:29 <Axman6> IMO UTF-16 doesn;'t solve any of the problems with UTF-8 in any meaningful way
05:53:56 <merijn> Of course it doesn't, utf-8 was invented later
05:57:18 <marmulak> oic
06:07:48 <infinisil> simon: on and btw this 5x Word32 representation for strings was transposed
06:08:25 <infinisil> Like, the first Word32 represented the first bit of the 32 letters
06:09:05 <infinisil> This was therefore limited to 32 chars with only 5 bits each
06:12:24 <samlamamma> Hi, can someone explain to me how the commented line works? https://paste.ubuntu.com/p/th4tksfF8N/ I don't understand how the LHS can have a different signature to the class definition
06:15:39 <delYsid> The instance is a function, thats is where the additional arg comes from
06:15:54 <ski> shutdown_-h_now : if you turn on the `InstanceSigs' language extension, you can write type signatures like that `lit :: Integer -> Ctx -> repr' inside the `instance' declaration
06:15:58 <ski> er
06:15:59 <Logio> the repr in the comment refers to a part of the repr in the class definition
06:15:59 <ski> samlamamma ^
06:17:18 <dminuoso> samlamamma: When you have a `class Foo x where f :: Integer -> x`, then inside an `instance Foo Bar` you set x at `Bar`
06:17:59 <ski> if we rename `class ExpSYM repr where ..repr..' to `class ExpSYM repr0 where ..repr0..', then the signature of `lit' in there is `lit :: Integer -> repr0'
06:18:36 <ski> now in the `instance ExpSYM repr => ExpSYM (Ctx -> repr) where ...' declaration, this `repr0' becomes `Ctx -> repr', and so the `lit :: Integer -> repr0' that you're to define becomes `lit :: Integer -> Ctx -> repr' in there
06:18:51 <ski> samlamamma : does that ^ help ?
06:20:19 <samlamamma> "instance ExpSYM repr => ExpSYM (Ctx -> repr) where" means "given repr being ExpSYM then Ctx -> repr is ExpSYM given the following definitions", right? 
06:20:59 <samlamamma> ski: Aah yes! Okay!
06:21:02 <ski> i'd say "being/is an instance of" or "being/is in", rather than just "being/is"
06:21:23 <ski> and yes
06:21:32 <dminuoso> samlamamma: It may be confusing to reuse the same variable name "repr" in each case. You could think the instance being written as `intance ExpSYM foo => ExpSYM (Ctx -> foo) where lit :: Integer -> Ctx -> foo`
06:22:10 <ski> you tend to get used to this kind of reuse of name
06:22:31 <ski> (in Agda it happens all the time)
06:23:01 <ski> samlamamma : do you know how to turn on that language extension, btw ?
06:23:24 * dminuoso is a great fan of learning Haskell with InstanceSigs turned on
06:23:32 <ben`> xk
06:23:37 <samlamamma> ski: I guess the same way as Flexible instances?
06:23:45 <ski> yes
06:25:41 <samlamamma> Anyway, it makes a bit more sense now :), at least enough for me to be able to think about it for a bit!
06:26:46 <dminuoso> ski: If I was to write an instance sig for `lit`, from the perspective of `lit`, what kind of a variable is `repr` exactly? Is that a skolem from that perspective?
06:27:42 <ski> yes, because `lit' has no control over which type `repr' is
06:28:05 <ski> the one which selects the instance to use, will pick `repr'
06:57:00 * quchen is looking for a function ¬ªx¬´ and some ¬ªeof¬´, such that (x f) (x g) (x h) eof = f (g h), but cannot find it :-(
06:57:19 <quchen> Basically it‚Äôs converting a left-associative function application chain into a right-associative one.
07:01:10 <bollu> quchen hello :D 
07:01:37 <quchen> o/
07:03:03 <algoholic1> a
07:09:28 <lyxia> some kind of CPS transformation seems involved.
07:10:05 <Taneb> quchen: I don't think *exactly* what you want is possible, but there'll be something similar
07:10:28 <quchen> Taneb: FWIW f, g and h have the same type
07:10:33 <quchen> ‚Ä¶if that helps
07:10:48 <algoholic1> q
07:11:01 <quchen> But I‚Äôll take anything similar too :-) The goal is to eliminate the parentheses, so that I can just write
07:11:12 <quchen> f' g' h' foo   instead of  f (g h)
07:11:25 <quchen> (for reasons‚Ñ¢)
07:11:28 <Taneb> quchen: ...if they're the same type it's a type error?
07:12:02 <quchen> Okay, full problem ‚Äì I have this code: H (e (l (l (o (, (space (w (o (r (l (d (! (newline hask_eof)))))))))))))
07:12:13 <infinisil> Oh no!
07:12:22 <quchen> I want to write it as H e l l o , space w o r l d ! etc
07:12:31 <quchen> Assuming command and stuff are valid variable names ;-)
07:12:48 <infinisil> Why are you trying to abuse Haskell as lisp?
07:13:01 <ski> hm, i think there was some article about writing forth-like concatenative stuff in Haskell, with juxtaposition
07:13:26 <quchen> infinisil: For fun and profit of course
07:13:36 <ski> infinisil : trying to get away from the superfluous parens, it seems to me
07:14:15 <Taneb> quchen: why not something like "H . e . l . l . o . newline $ eof"
07:14:36 <quchen> Because I don‚Äôt have infix operators in my obscure little ŒªC compiler :-E
07:15:01 <Taneb> Well, that's a whole other kettle of fish
07:15:03 <quchen> ski: Riiight concatenative is an excellent catchword
07:15:27 <hyperisco> quchen, this may be doable with foldApp. I'd start there.  ,  will have to be  comma  and  !  will have to be  exclaim
07:16:00 <hyperisco> quchen, also, capitals will have to be done differently
07:16:00 <ski> it's easy enough to do concatenative in Haskell, Taneb-style
07:17:08 <hyperisco> e = "e"; l = "l"  and so on
07:17:29 <quchen> Well, then let‚Äôs make it‚Ä¶
07:17:41 <quchen> (char 'H') (char 'e') (char 'l') ‚Ä¶ eof
07:17:48 <hyperisco> then  foldOf e l == "el"
07:17:52 <quchen> That way we get around the syntax limitations.
07:18:26 <hyperisco> you can do uppercase with some notation like _H
07:19:11 <hyperisco> so,  foldOf _H e l l o comma space w o r l d exlaim :: String  is  "Hello, world!"
07:19:38 <hyperisco> Good enough? :)
07:21:16 <hyperisco> You can also make each letter a combinator, but you'll still need some extra symbol to terminate it
07:21:55 <quchen> foldOf‚Äôs implementation would be interesting here ‚Äì specialized to this use case
07:22:02 <quchen> ‚Ä¶so I can understand how it works
07:22:18 <dminuoso> quchen: What was your special excel-kind of combinator called again?
07:22:22 <quchen> loeb
07:22:26 <dminuoso> Cheers.
07:22:33 <hyperisco> quchen, you can just think of  foldOf  as an n-ary mappend
07:22:39 <quchen> https://github.com/quchen/articles/blob/master/loeb-moeb.md
07:23:11 <dminuoso> quchen: Oh yeah found it as well, just wasnt sure what to google for.
07:23:15 <hyperisco> _H = mappend "_H"  and so on  then  _H e l l o ""  is  "Hello"
07:23:47 <hyperisco> oh that has wrong associativity doesn't it
07:23:52 <infinisil> quchen: Ohh you're the guy who wrote the loeb article!
07:24:00 <quchen> O:-)
07:24:01 <infinisil> I just used loeb in one of my projects recently :)
07:24:16 <quchen> Really? I didn‚Äôt realize it was actually useful in practice :-D
07:24:41 <quchen> The article is the result of an IRC session years ago ;-)
07:24:47 <ski> `loeb' is more or less folklore, no ?
07:24:50 <Taneb> quchen: some say the same thing about Haskell as a whole
07:24:59 <infinisil> I think it's like a generalized fix that also works over functions, and that makes it sound a lot more practical than "loeb" tbh
07:25:07 <infinisil> s/functions/functors
07:25:49 <quchen> fix and loeb have the same power, only that loeb is hard to understand compared to fix ;-)
07:25:57 * ski can't recall when `loeb' was first discussed in here .. must've been years ago .. more than ten ?
07:26:21 <quchen> Eh wait ‚Äì moeb and fix have the same power.
07:26:25 <quchen> I should read my own article.
07:26:53 <quchen> ski: Well, my article is 6 years old, so that‚Äôs your lower bound.
07:27:40 <infinisil> I also saw a monadic moeb/loeb somewhere online which I almost used
07:27:58 <Taneb> quchen: well, fix is loeb @Identity
07:28:16 <Taneb> With some coercing
07:29:00 <ski> quchen : hmm, i wonder whether that `moeb' is related to `grzegorczyk'
07:29:26 <infinisil> Guys, I know naming is one of the hardest problems, but "grzegorczyk"???
07:29:40 <Taneb> Looks like a Polish name
07:29:43 <quchen> head -100 /dev/urandom | tr -dc a-z
07:30:10 <algoholic> hey
07:30:19 <ski> George Boolos mentions it (together with `loeb') in his "The Logic of Provability"
07:30:40 <Taneb> ...it IS a Polish name https://en.wikipedia.org/wiki/Andrzej_Grzegorczyk
07:30:51 <dminuoso> int-e: By the say, sad that vault is still not updated on hackage :(
07:31:06 <dminuoso> int-e: Especially because I just saw that the updated version committed...
07:31:15 <infinisil> ski: Is that the guy who invented Boolean logic? Because his name sure sounds like it
07:31:15 <int-e> dminuoso: Yeah I saw your comment. I have a hard time believing that I missed the patch (I thought I'd checked that...)
07:31:28 <int-e> dminuoso: though maybe it was pushed later?
07:31:51 <int-e> But I probably missed it.
07:32:01 <ski> hm, <https://en.wikipedia.org/wiki/Andrzej_Grzegorczyk> suggests `grzegorczyk :: f (f (a -> f a) -> a) -> a'
07:32:40 <ski> infinisil : thinking of George Boole ?
07:33:10 <dminuoso> int-e: Im fairly sure it was there at the time, I remember that while you were writing the issue I was too, and there was some package where exactly that was the case.
07:33:17 <infinisil> ski: Damn, I had no idea
07:33:55 <Taneb> How come there are two prominent logicians called George Bool_
07:36:27 <ski> perhaps we need `Boole' and `Boolos' types in programming ?
07:36:51 <Taneb> :P
07:46:07 <unclechu> hey there, if there's anyone here who likes UnicodeSyntax (such as me) and at the same time a Vim user, please add more likes here https://github.com/neovimhaskell/haskell-vim/pull/106
07:46:08 <unclechu> i believe there's not even one central repo of a vim-plugin with unicode syntax support, i personally use my own fork for years alread.
07:46:09 <unclechu> it's gotta be fixed
07:47:35 <quchen> ski: Bool has two values, Boole includes ‚ä•?
07:48:22 <ski> hm, perchance ?
07:48:43 <infinisil> unclechu: Tbh ligatures seem like a better solution than unicodeSyntax
07:50:10 <__monty__> Conceals is another option.
07:50:26 <__monty__> Though I don't see why there *shouldn't* be editor support for UnicodeSyntax.
07:51:31 <unclechu> infinisil: well, it's not a topic about what's better, if you don't support it, just don't hit like button. anyway, it's better to have ability to render it properly since you won't loose anything if you don't use this feature
07:52:54 <unclechu> infinisil: and ligatures still takes more than one column which affects code formatting and aligning. what i personally like in UnicodeSyntax is that i can use one symbol instead of 3 or four
07:53:15 <dminuoso> Error parsing LDAP entry: Error while parsing "radiusFramedAppleTalkLink": Prelude.read: no parse
07:53:30 <dminuoso> Can we please banish this typeclass Read?
07:53:39 <Rembane> +1
07:53:48 <unclechu> when i write /servant/ routing i tend to replace :<|> with some single unicode symbol
07:53:49 <__monty__> unclechu: Conceals do get you that with the tradeoff that the alignment will be off for people who don't like unicode symbols.
07:54:09 <dminuoso> unclechu: Oh wow, that's a neat idea. But GHC wont accept that, will it?
07:54:20 <dminuoso> unclechu: I mean type operators are required to start with `:` no?
07:54:30 <ski> people should learn to use `reads' rather than `read'
07:54:43 <merijn> ski: You mean readMaybe :p
07:54:48 <dminuoso> readsMaybe.
07:54:56 <unclechu> dminuoso: use readMaybe or readEither from Text.Read
07:54:59 <ski> or that. but they should learn `reads' anyway
07:55:12 <merijn> ski: reads is super confusing and verbose to use
07:55:13 <dminuoso> unclechu: You misunderstand. This is not my fault.
07:55:37 <dminuoso> unclechu: I just tapped into a library that uses read somewhere.
07:55:45 <unclechu> dminuoso: no, type operators just like term-level operators
07:56:48 <dminuoso> % type (+) a b = Either a b
07:56:48 <yahb> dminuoso: 
07:57:21 <unclechu> __monty__: conceals are pretty local to specific setup of a programmer, and alignment will look broken on another's setup
07:57:54 <unclechu> dminuoso: GHC fine with those operators, what you GHC is supposed to not accept?
07:58:31 <dminuoso> Mmm, I recall there's a specific reason why servant has them start with `:`
07:58:37 <texasmynsted> Chris Smith gave a talk at Compose Conference here https://www.youtube.com/watch?v=7ayVB5C6A9w 
07:58:42 <__monty__> unclechu: Yeah but they also have a *choice* not to use your unicode symbols which are probably foreign and hard to enter for them. OTOH realigning is almost as easy as gg=G.
07:58:53 <ski> dminuoso : infix type constructors ?
07:59:08 <texasmynsted> In that talk he mentioned a comic where kids find a robot that speaks only in GHC error messages. Anybody know where to find that?
07:59:34 * ski misses not being able to use `(~>)' as a type variable
07:59:49 <unclechu> __monty__: i will never rely alignment of my code on conceals, it will defnitely lead to a code-style mess
08:00:23 <__monty__> ski: Variable? Not an operator?
08:00:31 <tdammers> :t reads
08:00:37 <lambdabot> Read a => ReadS a
08:00:40 <ski> __monty__ : `~>' would be the variable operator
08:01:06 <unclechu> conceals are only for "not aligned" programming languages or just data formats only
08:01:06 <dminuoso> % data a + b = a :+ b
08:01:06 <yahb> dminuoso: 
08:01:09 <ski> @src ReadS
08:01:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:01:23 <__monty__> unclechu: Hmm, according to the haskell report constructor symbols *do* have to start with ':'. Maybe UnicodeSyntax changes that.
08:01:23 <unclechu> like json for example
08:01:23 <ski>   type ReadS a = String -> [(a,String)]  -- anyway
08:01:30 <dminuoso> ski: Ignoring the semantic error here, seems to work just fine.
08:01:45 <dminuoso> ski: Ah I think I know why. It's so you can explicit import/export it I think.
08:01:47 <ski> > (reads :: ReadS Integer) "123.45"
08:01:50 <__monty__> Though dminuoso Just showed that's not the case?
08:01:50 <lambdabot>  []
08:02:03 <dminuoso> __monty__: Huh? The type constructor is infix just fine.
08:02:07 <ski> > (reads :: ReadS Integer) "  123 blah"
08:02:10 <lambdabot>  [(123," blah")]
08:02:13 <dminuoso> % :t (1 :+ 2)
08:02:13 <unclechu> __monty__: maybe TypeOperators changes that?
08:02:13 <yahb> dminuoso: (Num a, Num b) => a + b
08:02:44 <asheshambasta> https://gist.github.com/asheshambasta/ed0329fa8ffa2bbf163770a1b7b29527 -- is something like this doable? 
08:02:48 <dminuoso> The reason I used `(+)` there is because I didn't want to trigger -Wstar-binder
08:03:26 <__monty__> dminuoso: I'm referring to this line from the lexical structure: "consym‚Üí( : {symbol})‚ü®reservedop‚ü©"
08:03:28 <unclechu> __monty__: i'm defining type operators without `:` on projects where UnicodeSyntax isn't used
08:03:42 <ski> __monty__ : you used to be able to say stuff like `blah :: Category (~>) => (Foo ~> Bar) -> (f Foo ~> Baz)'
08:04:27 <__monty__> ski: Oh, cool. I can imagine that making some types easier to read.
08:05:04 <ski> hm, perhaps if we didn't have implicit `forall', then type variables and type synonyms could have been in the same namespace ?
08:05:11 <dminuoso> ski: I guess you would be able to write code like `dimap :: forall a b c d (~>). Profunctor (~>) => (a -> b) -> (c -> d) -> b ~> c -> a ~> d 
08:05:16 <dminuoso> That'd be very nice. :)
08:05:25 <ski> yes. also `Bifunctor'
08:06:01 <ski> dminuoso : i don't recall exactly when they changed it
08:06:06 <reallymemorable> I have this import: `import Data.Dependent.Map as DM (Some(..), (!), fromList, lookup)` but when I try to use or :i DM.lookup it says it's not in scope.  There was a competing lookup from Data.Csv, which I hid.
08:06:24 <reallymemorable> Does anyone have ideas of why something that is explicitly imported would not be considered in scope?
08:07:18 <merijn> reallymemorable: A minimal reproducing example and/or full error would help...
08:07:20 <ski> hm, is that `import' in the interactor, or in the module ?
08:07:35 * ski assumed the latter
08:07:38 <reallymemorable> in the .hs file
08:07:57 <merijn> reallymemorable: Things imported in modules are not in scope on the ghci repl
08:08:03 <ski> and did you make that module available in the interactor, with `:m', or with `import' ?
08:08:10 <merijn> reallymemorable: Only thing imported in the ghci repl are in scope in the repl
08:08:29 <ski> (well, or `:l')
08:08:34 <reallymemorable> so importing it in my .hs file doesn't make it available in ghci?
08:08:37 <merijn> (The exception is if you load the code via ":load" instead of import)
08:09:00 <reallymemorable> yes I did `:l My.File.Identifier`
08:09:02 <merijn> reallymemorable: If you do ":load" in the repl, then that is equivalent to "pretend I just typed this entire file into ghci"
08:09:09 <reallymemorable> yes
08:09:11 <reallymemorable> thats what i did
08:09:12 <merijn> hmm
08:09:44 <[Leary]> There's some weird flexibility in import syntax. Shouldn't that need a `qualified`?
08:09:45 <Welkin> don't use ghci
08:09:50 <ski> (hm, i think if there's no source, only the exported stuff is made available in the interactor ?)
08:09:55 <Welkin> write your program and then test it by running it
08:10:02 <Welkin> otherwise, you have to manually import anything you need
08:10:09 <merijn> [Leary]: No
08:10:22 <merijn> [Leary]: "qualified" means you HAVE to use qualification
08:10:39 <merijn> [Leary]: "as" introduces an aliasing for full qualification
08:10:45 <merijn> [Leary]: Those two things are orthogonal
08:10:49 <Welkin> import by itself imports fully qualified and unqualified
08:11:02 <asheshambasta> (updated gist)
08:11:28 <merijn> [Leary]: With  "import Foo.Bar" I can still refer to identifiers as "Foo.Bar.xyzzy"
08:11:37 <merijn> [Leary]: (as well as just "xyzzy")
08:12:05 <merijn> [Leary]: "import Foo.Bar as Quux" just means I can use "Quux.xyzzy" as well as "xyzzy" (not sure if the original full qualification *also* works)
08:12:09 <[Leary]> I've been hacking in Haskell for like 7 years and I had no idea. >.>
08:12:31 <Welkin> it is a bad idea to import everything unqualified
08:12:45 <Welkin> import specific things from a module using () or import qualified
08:12:50 <merijn> [Leary]: "import qualified Foo.Bar" just makes it mandatory to write "Foo.Bar.xyzzy" and "as Quux" you again introduce an alias for "Foo.Bar" :)
08:13:41 <reallymemorable> I tried this and i am getting the same error
08:13:42 <reallymemorable> `import qualified Data.Dependent.Map`
08:13:56 <reallymemorable> <interactive>:1:1: error: Not in scope: ‚ÄòDM.lookup‚Äô
08:14:11 <Welkin> you didn't import that as DM
08:14:52 <reallymemorable> `import qualified Data.Dependent.Map as DM`
08:14:54 <reallymemorable> same error
08:15:59 <Welkin> does that module even have that function?
08:16:19 <reallymemorable> http://hackage.haskell.org/package/dependent-map-0.2.4.0/docs/Data-Dependent-Map.html
08:16:59 <Welkin> this happens when you run your compiled program?
08:17:07 <reallymemorable> yes
08:17:09 <reallymemorable> it compiles
08:17:22 <Welkin> and how are you running it?
08:17:28 <reallymemorable> in ghci
08:17:37 <Welkin> several people already explained the problem
08:17:55 * ski . o O ( `import ... as Main' )
08:18:04 <reallymemorable> ?
08:18:08 <reallymemorable> i read everything here
08:22:04 <dmwit> reallymemorable: If you do your reproducing sequence in ghci -ignore-dot-ghci, what is the content of your ghci prompt?
08:23:02 <dmwit> (I would like to check whether ghci believes it is interpreting the module with the import statement, or merely importing it -- perhaps because -fobject-code is on and you have already compiled it.)
08:23:29 <dmwit> (Or some other weird collection of circumstances that I can't predict because I don't know every corner of ghci yet.)
08:23:33 <reallymemorable> sorry im not familiar with that
08:23:43 <reallymemorable> how do i use -ignore-dot-ghci
08:23:57 <dmwit> It's a flag. You pass it to ghci when you start it.
08:24:09 <dmwit> Instead of typing `ghci` at the command prompt, you type `ghci -ignore-dot-ghci`.
08:25:01 <reallymemorable> hmm shit i am loading this project by loading a directory in my computer `./dir/name/file`
08:25:04 <reallymemorable> and it doesnt like the flag
08:25:22 <dmwit> What does "loading a directory" mean?
08:25:37 <dmwit> What is the "it" in "it doesnt like the flag"?
08:25:51 <Welkin> Cousin It
08:27:50 <reallymemorable> in bash
08:28:07 <reallymemorable> I go to the directory of the project and I type `./dir/name/file`
08:28:21 <reallymemorable> thats how ghci starts when working on this project
08:28:25 <Welkin> what
08:28:32 <dmwit> What is the contents of dir/name/file?
08:28:45 <dmwit> Perhaps it is a shell script, e.g.?
08:28:51 <Welkin> sounds really odd
08:28:56 <Welkin> just use ghci directly
08:29:10 <reallymemorable> i am new to haskell and this is how the project has been set up
08:29:10 <Welkin> or use cabal to load it via `cabal repl` or `cabal ghci`
08:29:29 <Welkin> someone must be playing a joke on you
08:29:50 <reallymemorable> dude Welkin you are not helpful at all
08:30:12 <Welkin> find the cabal file, go there, and type `cabal repl`
08:30:36 <reallymemorable> dmwit - `./dire/name/file` and `file` is an unix executable
08:30:40 <Welkin> it sounds like this is way to complicated for a first timer
08:30:52 <Welkin> you should start with your own project built from scratch
08:30:54 <Welkin> too*
08:31:00 <reallymemorable> yes i get that this is not ideal
08:31:09 <Welkin> don't waste your time with someone else's junky setup
08:31:12 <reallymemorable> all of your suggestions are just counterfactuals that are completely  unhelpful
08:31:29 <Welkin> I told you what to do
08:31:38 <Welkin> you can either try it or not
08:36:26 <kuribas> is it possible to convert a Double directly to a Word64 ?
08:36:31 <kuribas> and the other way?
08:37:07 <Welkin> floating point to integral
08:37:18 <Taneb> :t round
08:37:21 <lambdabot> (Integral b, RealFrac a) => a -> b
08:37:24 <Taneb> :t fromIntegral
08:37:26 <lambdabot> (Num b, Integral a) => a -> b
08:37:31 <tdammers> try `less ./dir/name/file` - if the first line is something like #!/usr/bin/env ghci, then that's how it starts ghci
08:37:36 <ski> @type floor
08:37:38 <lambdabot> (Integral b, RealFrac a) => a -> b
08:37:39 <ski> @type ceiling
08:37:41 <Taneb> kuribas: unless you mean the evil way, that's the best you can do, really
08:37:41 <lambdabot> (Integral b, RealFrac a) => a -> b
08:37:47 <kuribas> Taneb: yes, the evil way
08:37:48 <ski> @type truncate
08:37:50 <lambdabot> (Integral b, RealFrac a) => a -> b
08:38:20 <kuribas> Taneb: the ieee754 representation
08:38:27 <kuribas> as a 64 bit word
08:39:37 <bollu> kuribas theres are primitives in GHC.Prim
08:39:47 <bollu> kuribas decodeDouble_Int64#
08:39:54 <bollu> for example, gives you mantissa and exponent
08:42:01 <kuribas> not quite a no-op, but better than the other alternatives
08:42:16 <ski> @type encodeFloat
08:42:18 <lambdabot> RealFloat a => Integer -> Int -> a
08:42:23 <ski> @type decodeFloat
08:42:26 <lambdabot> RealFloat a => a -> (Integer, Int)
08:42:36 <kuribas> and unsafeCoerce?
08:42:39 <kuribas> :t unsafeCoerce
08:42:41 <lambdabot> error: Variable not in scope: unsafeCoerce
08:44:03 <kuribas> (unsafeCoerce (2.0 :: Double)) :: Word64
08:44:09 <kuribas> => 4611686018427387904
08:44:15 <kuribas> seems to work :-)
08:44:22 <kuribas> probably compiler dependend though...
08:46:26 <kuribas> I don't think haskell garantees Double is stored as a ieee754 format
08:46:49 <Welkin> what
08:46:54 <Welkin> how do you even know that's right?
08:48:12 <phadej> there is primops to do that conversion
08:48:27 <kuribas> Welkin: by testing it :)
08:48:47 <phadej> e.g. https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#v:word2Double-35-
08:49:48 <phadej> so Haskell standard doesn't say anything, but GHC implementation is quite honest.
08:50:04 <ski> > decodeFloat 2.0
08:50:07 <lambdabot>  (4503599627370496,-51)
08:50:15 <int-e> > 42
08:50:19 <lambdabot>  42
08:50:38 <kuribas> phadej: that's much better!
08:50:55 <Taneb> kuribas: that's what I call the evil way
08:51:07 <Taneb> (fun fact: unsafeCoerce can be used as a lens)
08:51:11 <phadej> or wait, maybe that's not coercion
08:55:45 <kuribas> is there something higher level that uses GHC.Prim?
08:56:36 <kuribas> phadej: how do I get an Int# or Word# from an Int
08:56:39 <kuribas> ?
08:57:42 <phadej> kuribas: that's wrong primop
08:59:04 <phadej> Prelude GHC.Float> :t castWord64ToDouble 
08:59:05 <phadej> castWord64ToDouble :: GHC.Word.Word64 -> Double
08:59:05 <phadej> Prelude GHC.Float> :t castDoubleToWord64 
08:59:05 <phadej> castDoubleToWord64 :: Double -> GHC.Word.Word64
08:59:18 <phadej> so not primops, but stuff in GHC.Float
08:59:38 <phadej> since base-4.10.0.0
08:59:42 <bollu> kuribas unbox it
08:59:42 <kuribas> ah nice
08:59:53 <Taneb> phadej: ooh, that's nice
08:59:56 <bollu> oh, yes, that's probably the sane way :) 
09:00:57 <phadej> I really don't remember where I saw those used, but it's saner than what `binary` or `bytestring` do (look if you are brave and curious)
09:01:39 <phadej> maybe it was cborg...
09:02:39 <kuribas> this is why I like haskell, it allows me to be unsafe and performant when I want it
09:03:09 <phadej> that's not really unsafe
09:03:20 <phadej> low-level, not unsafe :)
09:03:28 <kuribas> yeah
09:04:04 <kuribas> common lisp doesn't even allow me to convert Int32 to Word32
09:04:12 <kuribas> without bit bashing
09:05:42 <EvanR> what kind of bit bashing would "convert" a Int32 to Word32
09:06:01 <xlxs4> kuribas: why compare clisp to haskell? they are quite different
09:06:13 <EvanR> i assume you mean reinterpret cast
09:06:51 <ski> s/clisp/cl/
09:07:11 <ski> (clisp is a specific implementation of common lisp)
09:07:13 <kuribas> EvanR: (dpb (ldb (byte 31 0) x) (byte 31 0) (- (ldb (byte 1 31) x)))
09:07:22 <xlxs4> ski: yes yes
09:07:59 <kuribas> xlxs4: because these things annoy me in lisp
09:08:52 <kuribas> EvanR: actuall it's the other way around
09:09:06 <kuribas> EvanR: Int32 to Word32 is easy
09:10:58 <EvanR> i can't grok that code
09:12:30 <kuribas> EvanR: it takes the sign bit, and converts it to 0 and -1, and then inserts the other bits
09:21:44 <kuribas> I suppose that historical lisp was the high-level language
09:22:55 <Taneb> (with its "content of the decrement part of the register number" instruction)
09:26:25 <kuribas> those were different times
09:28:31 <kuribas> Taneb: that wasn't an instruction
09:30:07 <kuribas> A time when high level languages could still name functions after hardware features, and dared to do mutation
09:31:35 <kuribas> No whiny hipsters complaining about the evils of side effects.
09:32:31 * ski . o O ( "my other rest is a cdr." )
09:40:19 <damnhere> hi
09:42:39 <wildtrees> hello damnhere 
09:47:58 * xlxs4 greets damnhere
10:02:16 <EvanR> is there a way to hook when gc has just completed
10:31:18 <halogenandtoast> Does using this style https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs#L127-L129 have any drawbacks
10:31:42 <halogenandtoast> I tend to avoid using `type` but I imagine it is perhaps useful here?
10:32:22 <halogenandtoast> To that point, those that have used Opaleye, do you use this style
10:38:17 <halogenandtoast> And a tangential question, do people still use Opaleye these days or is there a more general Postgres SQL solution (did persistant win out?).
10:38:42 <boj> halogenandtoast: i haven't used that library in awhile, but "that style" is how you can differentiate between read/write types
10:39:27 <boj> i think opaleye is still widely used. in our case we use 'beam' though
10:40:45 <halogenandtoast> boj: Is there something in particular that drove you to use beam?
10:41:38 <halogenandtoast> I am trying to decide on a database solution and haven't deviated too far from persistant, but since I am not using Yesod for this project, I thought it might be worthwhole to look at the other options
10:41:46 <boj> my group was a little too new to haskell, so something like opaleye and Arrow syntax was a bit much. beam had an API that was easier for them to grasp, and we've stuck with it since because it is pretty nice
10:42:23 <boj> you can't go wrong with either project though, they are both solid choices
10:43:49 <boj> and by solid i mean well documented, active, and are used in production
10:44:21 <halogenandtoast> boj: Any other libraries you know of that I should give a glance to?
10:45:10 <boj> halogenandtoast: i think there are a handful of other libraries, but a lot of them seemed more like experiments last i looked
10:46:40 <halogenandtoast> boj: thanks, I think I will vet opaleye, beam, and squeal then
10:46:49 <cocreature> selda also seems to be somewhat popular or at least was at some point
10:47:40 <halogenandtoast> Interesting name, and related icon...
10:47:55 <cocreature> and if you‚Äôre looking for low-level options there is postgresql-simple and hasql. all the high-level libs build upon one of those
10:48:33 <halogenandtoast> cocreature: thanks
10:53:15 <lavalike> there is a fun package that queries postgres when you compile your haskell source, devises a series of types from the tables it finds, and uses them to type check your queries, I always thought it was a neat idea
11:06:18 <Lycurgus> http://hackage.haskell.org/package/postgresql-typed that one?
11:07:47 <lavalike> yup
11:16:00 <lavalike> glad to see it's actively developed
12:03:33 <bobajett> Could somebody help me figure out how to chain function calls? (Noob question). Specifically I'm translating this toy ReasonML snippet to Haskell (https://pastebin.com/GRDShEgV) and would like some help with idiomatic Haskell translation (especially how to chain (>>=) in here).
12:06:24 <bobajett> I only want to translate the "readDoubleValue" function to Haskell - the rest are helper functions for background.
12:09:47 <boj> bobajett: do you have a semi-working haskell version?
12:10:57 <bobajett> boj: I do. But I constructed it out of trial and error and to me it looks ugly. I'll paste it here. It's a one liner.
12:13:06 <Berengal> I'm wondering about how vector fusion works. I've got basically "let vector = stuff in if foo then Left $ sum vector else Right $ map bar vector", and 'vector' doesn't get fused with the sum or the map
12:14:18 <Berengal> It works if I manually inline it, but not otherwise, even if I make it a function of the inputs
12:14:49 <bobajett> readDoubeVaue s = resultText $ (toFixedWithPrecision 3) <$> cube <$> ((toFloat s) >>= reciprocal)
12:17:08 <boj> bobajett: <$> is just infix 'fmap', you could use the (.) composition operator instead to make it more readable
12:17:13 <[Leary]> Perhaps `resultText $ toFixedWithPrecision 3 . cube <$> (reciprocal <=< toFloat) s` is a litlet better.
12:17:14 <boj> (f . g . h) x
12:17:41 <boj> hmm
12:19:14 <[Leary]> Or you can always just write a do-block. Something like `resultText $ do { fl <- toFloat s; rcp <- reciprocal fl; pure (toFixedWithPrecision . cube $ rcp) }`.
12:19:35 <lavalike> finally a readable one
12:21:47 <bobajett> [Leary]: ok cool. I think that makes sense. The reasonML one (imo) reads real easily from left to right, and I think for clarity your do-block is probably the most readable way to present the logic in Haskell. Thanks everyone!
12:22:30 <ski>   resultText (liftM (toFixedWithPrecision 3 . cube) . reciprocal =<< toFloat s)
12:23:22 <ski> ReasonML is an OCaml variant ?
12:23:52 <bobajett> ski: yes. It's actually just a different syntax for OCaml
12:24:09 <ski> Camlp4 / Camlp5 ?
12:24:30 <bobajett> I believe it uses ppx not camlp
12:24:35 <ski> ok
12:24:50 <ski> (not sure i've ran into "ppx" before)
12:27:23 <bobajett> "OCaml 4.02 and OCaml 4.03 introduce the PPX system to replace Camlp4." http://ocamllabs.io/doc/ppx.html
12:36:01 <ski> ok, ty
12:42:24 <Noughtmare[m]> Is it possible to specialize functions to certain values of their arguments? I know we can specialize typeclass instances, so I could encode my arguments as typeclass instances, but that doesn't seem like it is intended. (I have a benchmark where it does give me a speedup)
12:43:03 <merijn> Noughtmare[m]: You can specialise to certain *types*, but not certain values, afaik
12:44:13 <Noughtmare[m]> That is unfortunate. It seems like a pretty easy feature to implement.
12:45:38 <ski> Noughtmare[m] : partial application ?
12:46:11 <Noughtmare[m]> @ski What do you mean?
12:46:11 <lambdabot> Maybe you meant: wiki src ask
12:46:24 <merijn> Noughtmare[m]: I mean, sounds more like partial application + inlining
12:46:50 <ski> perhaps they're more thinking of partial evaluation / program specialization
12:46:57 <ski> (or meta- / staged programming)
12:47:38 <ski> Noughtmare[m] : do you know what "partial application" is ?
12:47:44 <Ariakenom> Noughtmare[m]: iirc functions are optimized based on how many arguments they are defined with
12:47:49 <merijn> right, but that'd be more along the lines of inlining than specialisation
12:48:00 <Ariakenom> so something like f constant = \more args -> result
12:48:06 <Ariakenom> might be different
12:48:08 <ski> Noughtmare[m] : perhaps you could elaborate more on what you had in mind with "specialize functions to certain values of their arguments" ?
12:48:34 <ski> merijn, which ?
12:51:12 <Noughtmare[m]> https://pastebin.com/nGpVW1tt
12:51:13 <Noughtmare[m]> Here's my code
12:51:45 <Noughtmare[m]> I created the Alphabet class to specialize the printRandomFasta function to certain values.
12:51:49 <Noughtmare[m]> But that looks very ugly
12:52:34 <Noughtmare[m]> I wondered if there is a better way to do this.
12:54:10 <dmwit> You can just pass in an `Int -> Word8` and a `[Double]`...?
12:55:23 <Noughtmare[m]> dmwit: No, I tried that and it runs about 2x slower.
12:58:11 * dmwit gives it a shot
12:59:26 <Noughtmare[m]> I compiled it with -fllvm
12:59:31 <Noughtmare[m]> and -O2 of course
12:59:43 <Noughtmare[m]> Maybe that makes a difference
13:01:25 <merijn> Noughtmare[m]: -fllvm has a good shot at being better at optimising numerical code
13:02:18 <Noughtmare[m]> Yeah, I noticed that it gives a very good speedup for this code.
13:07:00 * Noughtmare[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/VKagRgqLGWnezCpRueKtTEJw >
13:13:40 * brew australians == douchebags
13:14:15 * jgt is Australian and agrees to an extent
13:15:58 * brew screw you dax
13:26:26 * israel twkm is a douchebag too
13:27:47 * ski thinks those people are not in this channel
13:28:44 <wildtrees> it's some guy mass spamming channels it seems
13:31:33 --- mode: ChanServ set +q *!*@p13237-ipngn10501marunouchi.tokyo.ocn.ne.jp
13:46:18 * thoma fuck you #gentoo
13:46:47 <Vq> :'(
13:49:14 --- mode: ChanServ set -q *!*@p13237-ipngn10501marunouchi.tokyo.ocn.ne.jp
14:13:01 <dmwit> Noughtmare[m]: What's up with the `n` parameters to printRandomFasta and mainLoop?
14:14:47 <Noughtmare[m]> dmwit: that is work in progress.
14:15:34 <Ankhers> Can anyone explain what cabal does with FFI information? As an example, lets say my program required zlib. If I forget to put that in my cabal file, what would happen? Similarly, if I DID put it in my cabal file, but did not have it installed, what would happen?
14:15:52 <Noughtmare[m]> dmwit: Eventually I want that to hold the number of characters that have to be printed.
14:17:47 <dmwit> Noughtmare[m]: Also, did you notice that your iub-labeled test passes Homo? =P
14:17:55 <Noughtmare[m]> dmwit: I'm trying to improve this program: https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fasta-ghc-1.html
14:18:38 <Noughtmare[m]> dmwit: Oops, I will fix that.
14:19:02 <dmwit> Ankhers: If you forget to put it in your cabal file, you will likely get a linking error... eventually? Not sure when. If you put it in but don't have it installed, the configure step will fail and print a mildly confusing error message.
14:19:31 <Ankhers> dmwit: That makes sense. Thank you!
14:21:02 <solonarv> I vaguely remember that cabal will use pkg-config to look for it
14:22:15 <dmwit> Specifically: it will use pkg-config if you tell it via pkg-config-depends.
14:23:51 <solonarv> ah, right
14:24:02 <solonarv> I was mostly remembering the song-and-dance to make that work on windows
14:25:40 <merijn> Ankhers: If you use pkg-config then it will complain at build time that it can't find the dependency, else as others said it will probably fail at link time
14:32:22 <argent0> hi, is there something like `validation` but with partial success? `data Validation e v = Success v | PartialSuccess e v | Failure e`
14:58:19 <ski> argent0 : how would that work ?
15:03:54 <argent0> ski: Some thing that you could use to validate JSONs but sitll recover from errors. https://bpaste.net/show/4Sbq
15:08:14 <solonarv> that looks like 'These' in a trenchcoat
15:09:16 * argent0 didn't check if it verifies the laws
15:10:55 <argent0> solonarv: I don't see them as the same. http://hackage.haskell.org/package/these-1/docs/src/Data.These.html#line-227
15:11:57 <Nevoic> Does anyone know how to add session data to Scotty? It seems like there's no native support for it.
15:12:38 * argent0 they do look the same
15:13:29 <ski> argent0 : the brackets around the operand patterns (and the single instance context) there are redundant, btw
15:15:04 * argent0 the this ` This  a   <*> _         = This a` is not the same in `These`
15:17:26 <ski> argent0,solonarv : that instance for `These' is not the same. specifically the `This a <*> This b' and `This a <*> These g x' cases
15:17:35 <ski> aye
15:30:33 <higherorder> Hi! Is anybody here well familiar with Vinyl, the records library? (by Jon Sterling)
15:32:23 <higherorder> perhaps acowley ?
15:33:42 <EvanR> what is the question
15:34:38 <higherorder> I am wondering if there is a non-convoluted approach to dealing with "selections" of a sub-schema in Vinyl, in a way similar to Clojure's spec: https://github.com/clojure/spec-alpha2/wiki/Schema-and-select#select
15:34:45 <higherorder> EvanR: ^
16:35:01 <koz_> I've just read https://github.com/ChrisPenner/comonads-by-example, and I think I finally get what comonads are for. However, I had a question: If Store is co-State, Env is co-Reader and Traced is co-Writer, is there a co-Cont, and if so, what is that?
16:35:53 <Axman6> I don't know what it is, but there definitely is one
16:35:56 <Axman6> @src Cont
16:35:56 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
16:36:19 <koz_> I _guess_ the 'reverse all arrows' thing gives us something like r -> (a -> r) ?
16:36:26 <koz_> Or do I reverse the other arrow too?
16:37:24 <ChrisPenner[m]> koz_: not sure if you saw, but the first videos for my talk are up now too! https://youtu.be/HOmOQnQGtPU
16:37:50 <koz_> ChrisPenner[m]: I didn't - I prefer written to auditory information delivery. However, your talk is well-motivated and interesting, even from the slides alone.
16:38:01 <koz_> It's like, _the_ missing piece of 'what on earth is a comonad good for' puzzle for me.
16:38:51 <ChrisPenner[m]> koz_: Glad it worked out for you ; I'm particularly pleased with the comonad transformers example I ended up finding ‚ò∫Ô∏è
16:39:09 <koz_> The whole 'comonads are queries' analogy was what did it for me.
16:40:02 <koz_> Maybe you can shed a light on what co-Cont is?
16:40:44 <hpc> i vaguely remember Cont being its own dual, but i can't find why with google
16:43:57 <sarahzrf> is (_ -> r) self-adjoint. is that where the monad comes from
16:44:12 <hpc> when reversing "the arrows", it's referring to more like these diagrams - https://en.wikipedia.org/wiki/Dual_object
16:44:26 <sarahzrf> well not literally *self*-adjoint since itd be a contravariant adjunction
16:44:40 <sarahzrf> actually uh wait
16:44:45 <sarahzrf> well damn ive confused myself
16:44:51 <koz_> hpc: I figured it meant it in a category-theoretical sense, but I dunno any category theory.
16:45:02 <hpc> i am pretty bad at it too
16:45:04 <koz_> It'd be nice if someone gave a 'how to 'reverse the arrows' in Haskell' explanation someplace. :P
16:45:23 <hpc> constructing that diagram, would be what you would need i think
16:45:57 <koz_> Yeah, but, for example, what's the diagram of (a, b)?
16:46:02 <hpc> anyway, i think we can all agree that cocont is nt
16:46:06 <koz_> (since I believe its dual is Either a b)
16:46:09 <koz_> NT?
16:46:15 <hpc> because duals cancel out ;)
16:46:26 <koz_> Oh, lol.
16:46:38 <edwardk> ChrisPenner[m]: foldl/moore is probably my favorite example
16:46:51 <koz_> edwardk: I was _just about_ to ask you!
16:46:59 <sarahzrf> oh fuck
16:47:02 * sarahzrf tabs out before edwardk spoils it
16:47:04 <koz_> I figured if you want something explained, you could do worse than lighting the Kmett Signal.
16:47:09 <edwardk> sarahzrf: hahhaha
16:47:31 <edwardk> sarahzrf: (_ -> r) -| (_ -> r) but one of those is from Hask -> Hask^op and the other from Hask^op -> Hask.
16:47:41 <koz_> So my question is this: If Store is co-State, Env is co-Reader and Traced is co-Writer, what is co-Cont?
16:47:45 <sarahzrf> yeah i was just writing that up in vim and about to check that there was a transformation
16:47:53 <sarahzrf> then i was about to type up something like
16:48:00 <sarahzrf> "there IS a comonad, but it's on Hask^op"
16:48:03 <edwardk> you get a monad on Hask when composing GF out of that F -| G pair. and a comonad on hask^op which is the same monad on hask when composing FG
16:48:15 <lyxia> oh that is fun
16:48:26 <edwardk> so there is no 'Cocont' or 'nt' comonad
16:48:31 <koz_> Ah.
16:48:33 <edwardk> at least that is distinct from the Cont monad
16:48:41 <koz_> So Cont is it own dual?
16:48:45 <edwardk> yep
16:48:54 <koz_> So I guess there's a Comonad instance for Cont r?
16:48:59 <sarahzrf> only in Hask^op
16:49:05 <sarahzrf> it's just the Monad instance from Hask
16:49:14 <edwardk> koz_: Cont r is a comonad in _hask^op_ not hask
16:49:17 <hpc> what is hask^op?
16:49:19 <edwardk> so its the same monad
16:49:23 <sarahzrf> the opposite category of Hask
16:49:28 <sarahzrf> the one where the arrows go the other way
16:49:34 <edwardk> yeah just flip all the haskell arrows around
16:49:55 <koz_> I still don't think I get the whole Hask^op thing.
16:49:56 <edwardk> newtype Op k a b = Op { getOp :: k b a }
16:50:02 <edwardk> now look at Op (->)
16:50:13 <edwardk> in it, you can talk about sums like you do products in hask, and vice versa
16:50:30 <sarahzrf> koz_: generally speaking, a monad M : C -> C on some category C comes from composing a pair of adjoint functors F : C -> D and G : D -> C, and the corresponding comonad comes from composing them in the opposite order, so it's D -> D
16:50:39 <edwardk> Op fst :: Op (->) a (a, b)
16:50:50 <sarahzrf> *if* both functors are actually endofunctors, then composing them in either order gets you C -> C
16:50:50 <edwardk> looks like "Left" if you squint
16:50:58 <sarahzrf> so the monad and comonad will be on the same category
16:50:59 <hpc> ah that's cool
16:51:08 <sarahzrf> but for Cont, you go through Hask^op
16:51:43 <edwardk> off to see a man about a horse er .. house.
16:51:50 <koz_> edwardk: Neither of those would surprise me.
16:52:02 <sarahzrf> horses
16:52:04 <koz_> I expect a detailed talk about how horses are really coalgebraic structures of some sort.
16:52:09 <koz_> (in the future)
16:52:18 <hpc> hope it's in a good neigh-borhood
16:52:24 <sarahzrf> idk about horses, but i can tell you that a mouse is a kind of first-order structure
16:52:26 * turab wants to be as cool as edwardk when he grows up
16:52:39 <sarahzrf> https://en.wikipedia.org/wiki/Mouse_(set_theory)
16:52:57 <koz_> sarahzrf: TIL.
16:53:51 <sarahzrf> i heard some theory that they needed some adjective for describing a model that's desirable in this way, so in typical mathematical fashion they said "models with these properties will be called 'nice'"
16:53:56 <sarahzrf> but n is next to m
16:54:00 <sarahzrf> this is probably not true
16:54:46 <koz_> sarahzrf: Naming anecdotes are best anecdotes.
16:54:52 <edwardk> sarahzrf: nice is a pretty common term in math for ‚Äúi need to state conditions but i‚Äôm too afraid i‚Äôll specify something too restrictive and miss some cases‚Äù
16:54:52 <Axman6> so, just continuing on from the previous discussion, what are the two functors in Cont? I assume one is ((->) a)
16:55:09 <sarahzrf> edwardk: oh i know
16:55:18 <edwardk> not functions from a, functions to a
16:55:21 <sarahzrf> Axman6: wrong argument, you have to fix the second one
16:55:28 <sarahzrf> it's right in front of you :D
16:55:33 <sarahzrf> -> r
16:56:42 <Axman6> ag, because the (a -> r) is in negative position, that makes it (-> r) and (-> r)?
16:58:22 <sarahzrf> yeah
16:58:41 <Axman6> :mindblown:
16:59:19 <koz_> Axman6: I had a similar mindblow in recent memory when I was trying to come up with the functor instance of the push array.
17:00:02 <Axman6> push array?
17:00:28 <koz_> Axman6: Let me dig out that paper real quick again.
17:01:03 <Axman6> yeah a quick google search returns a lot of javascript and PHP. I feel Rick Rolled
17:01:19 <sarahzrf> Axman6: the fact that it's (-> r) and not (r ->) is why u dont get a comonad - (-> r) is contravariant, iow it's Hask^op -> Hask rather than Hask -> Hask
17:01:24 <koz_> Axman6: Lol, nothing of the kind.
17:01:54 <sarahzrf> you can equivalently view it as Hask -> Hask^op
17:02:09 <koz_> data Push a = Push ((Ix -> a -> CM ()) -> CM ()) Length
17:02:16 <sarahzrf> viewing it in these two types gives u an adjunction from Hask to Hask^op and back, so you get a monad on Hask and a comonad on Hask^op
17:02:17 <koz_> Where CM is a 'compilation monad' of some kind.
17:02:31 <Axman6> hmm, I thought that to have a monad, you had to have two functors which were adjoint, and combining themone way gives a monad and the other gives a comonad. is that wrong?
17:03:16 <sarahzrf> nope thats correct - was what i just said confusing or did you just type that before i said it
17:03:44 <Axman6> but why don't we get a comonad then...
17:03:58 <sarahzrf> we do!
17:04:01 <sarahzrf> it's on Hask^op
17:04:11 <Axman6> I don't remember what that means
17:05:10 <edwardk> fun part of this is that given an adjuction F -| G, and Monad M, GMF is a monad too
17:05:17 <sarahzrf> well, the types for an adjunction in general look like this: to say "F -| G (F is a left adjoint to G)", you need: C and D are categories, F : C -> D and G : D -> C are functors,
17:05:32 <edwardk> but now M lives in hask^op
17:05:50 <edwardk> so you get a comonad to monad transformer from that adjunction
17:06:44 <sarahzrf> given an adjunction F -| G, composing GF gives you something C -> C, and you can equip that as a monad; composing FG gives you something D -> D, and you can equip that as a comonad
17:06:57 <edwardk> if you the quantify away the r you get the Co comonad to monad transformer from the article i wrote way back when
17:07:05 <sarahzrf> *if* you're considering an adjunction where C and D are the same category, then you'll get a monad and a comonad on the same category
17:07:16 <monochrom> Yikes, GMF.
17:07:17 <sarahzrf> but if they're different categories, you'll get a monad on C and a comonad on D
17:08:10 <edwardk> monochrom that is how StateT works for instance
17:08:21 <edwardk> here its how ‚ÄúCo‚Äù works
17:08:42 <edwardk> which lets you do things like Co (Store s) ~ State s
17:08:56 <edwardk> yo turn comonads into the corresponding monads
17:09:02 <edwardk> er to
17:09:10 <sarahzrf> Axman6: so in this example, (-> r) can be considered as both Hask -> Hask^op and as Hask^op -> Hask, so we can use Hask as C and Hask^op as D, and in fact this forms an adjunction
17:09:21 <sarahzrf> and then we get a monad on Hask and a comonad on Hask^op
17:09:33 <edwardk> i mostly lobbed that one out for sarahzrf
17:09:47 <sarahzrf> hmm? which one?
17:09:59 <Axman6> What's Hask^op again? it's the category Hask where app the arrows are revered yeah?
17:10:02 <sarahzrf> yeah
17:10:38 <edwardk> http://comonad.com/reader/2011/monad-transformers-from-comonads/
17:11:01 <Axman6> We had a good talk recently at CanFP about comonadic UIs, which use the adjunt monad as a selector for how the comonad behaved. it was a little mindblowing
17:11:23 <sarahzrf> oh neat
17:11:26 <sarahzrf> i had not heard of this
17:11:28 <koz_> Axman6: Slides available anyplace?
17:11:51 <sarahzrf> lately i probably know more category theory than category-theory-applied-to-haskell
17:12:27 <koz_> I know basically zero of the former and slightly-less-than-zero of the latter.
17:12:35 <koz_> s/less/more/
17:12:35 <sarahzrf> :)
17:12:37 <koz_> Argh.
17:18:29 <ski> are there qualifying names for the two kinds of antitone galois connection ?
17:20:17 <sarahzrf> "the two kinds"?
17:20:20 <sarahzrf> which two kinds do u mean
17:21:49 <ski> for a monotone galois connection between `F' and `G' you have `F x =< y' iff `x =< G y', for all `x',`y'. this corresponds (generalizes) to the usual (covariant) notion of adjunction
17:24:28 <ski> for an antitone galois connection between `F' and `G', i see it stated that you have `y =< F x' iff `x =< G y', for all `x',`y'. this corresponds (generalizes) to the contravariant notion of adjunction that edwardk mentioned in the blag the above one continued
17:26:58 <ski> if you consider `F' and `G' as going inbetween the opposite categories (so really `F^op' and `G^op'), then in the monotone case you get `x =< F y' iff `G y =< x', for all `x',`y'. iow a (monotone) galois connection between `G' and `F' (really `G^op' and `F^op')
17:28:34 <ski> however, if you do the same in the antitone case you get `F x =< y' iff `G y =< x', for all `x',`y'. which is now the previous notion of an (antitone) galois connection between `G' and `F' (really `G^op' and `F^op') (nor in the opposite order)
17:31:03 <ski> so there's three conditions of interest here. in the first one we have
17:31:37 <ski>   F : O >---> P  ;  G : P >---> O
17:32:40 <ski> where `O' and `P' are preorders, and `F',`G' are order-preserving (so morphisms in the category of preorders. btw, each preorder is also a (thin) category (and vice versa))
17:32:47 <ski> and the condition is
17:33:45 <ski>   F x =<_P y  <=>  x =<_O G y   (forall x : O , y : P)
17:34:29 <ski> in the two latter cases, we still have
17:34:34 <ski>   F : O >---> P  ;  G : P >---> O
17:35:22 <ski> where `O' and `P' are preorders, but where `F',`G' are order-reversing
17:36:58 <ski> i suppose we can consider this as
17:37:43 <ski>   F^* : O^op >---> P  ;  G_* : P >---> O^op
17:39:37 <ski> being a pair of "opposing" morphisms (order-*preserving* functions) between `O^op' and `P' in the category of preorders (where `O^op' is the opposite (reversed) ordering to `O'. this corresponds to "opposite category", considering preorders as categories)
17:39:44 <ski> or as
17:40:03 <ski>   F_* : O >---> P^op  ;  G^* : P^op >---> O
17:40:39 <ski> (still being a pair of "opposing" morphisms (order-preserving), between `O' and `P^op' this time, in the category of preorders)
17:41:28 <ski> anyway, here the two latter considered conditions are
17:44:51 <ski>   F x =<_P y  <=>  G y =<_O x   (forall x : O , y : P)
17:46:42 <ski> or, if we want to be more explicit (which probably doesn't help much in this galois connection case. maybe more in the adjunction case ?)
17:48:30 <ski>   F^op ~x =<_P y  <=>  ~(G_op y) =<_O x   (forall x : O , y : P)
17:50:10 <ski> (where by `~(...)' i mean the value `...', but considered as a value in the opposite preorder (or object consider as an object in the opposite category, in the generalization to adjunctions))
17:51:12 <Axman6> koz_: I've asked about the slides, I'll let you know
17:51:12 <ski> er, sorry, i meant to write
17:51:19 <ski>   F^* ~x =<_P y  <=>  ~(G_* y) =<_O x   (forall x : O , y : P)
17:51:22 <koz_> Axman6: Thanks!
17:51:32 <ski> there (too many similar-looking notations !)
17:52:02 <ski> which, in terms of the preorders `O^op' and `P', and the ordinary (i.e. monotone) galois connection between `F^*' and `G_*' is the condition
17:52:54 <ski>   F^* ~x =<_P y  <=>  ~x =<_{O^op} G_* y   (forall ~x : O^op , y : P)
17:53:30 <ski> now, the last condition of the three is
17:54:24 <ski>   y =<_P F x  <=>  x =<_O G y   (forall x : O , y : P)
17:54:32 <ski> or, if we want to be more explicit (which probably doesn't help much in this galois connection case. maybe more in the adjunction case ?)
17:55:39 <ski>   y =<_P ~(F_* x)  <=>  x =<_O G^* ~y   (forall x : O , y : P)
17:56:24 <ski> which, in terms of the preorders `O' and `P^op', and the ordinary (i.e. monotone) galois connection between `F_*' and `G^*' is the condition
17:57:56 <ski>   F_* x =<_{P^op} ~y  <=>  x =<_O G^* ~y   (forall x : O , ~y : P^op)
17:58:30 <ski> summarizing the main points here about the three conditions, in the first one we have
17:58:55 <ski>   F : O >---> P  ;  G : P >---> O    -- order-preserving
17:59:09 <ski>   F x =<_P y  <=>  G y =<_O x   (forall x : O , y : P)
17:59:33 <ski> while for the latter two we have
17:59:46 <ski>   F : O >---> P  ;  G : P >---> O    -- order-reversing
17:59:56 <ski> with
18:00:20 <ski>   F x =<_P y  <=>  G y =<_O x   (forall x : O , y : P)
18:00:23 <ski> respectively
18:00:30 <ski>   y =<_P F x  <=>  x =<_O G y   (forall x : O , y : P)
18:00:59 <ski> the first of these three is called a (monotone) galois connection between `F' and `G'
18:01:21 <ski> the last one is what was stated as an antitone galois connection between `F' and `G'
18:02:20 <ski> but the middle one also strikes be as earning the name antitone. so i'd like some qualification to be able to distinguish between these two (closely related) cases
18:04:49 <ski> if we tentatively call the middle condition "lower-heavy" and the last one "higher-heavy"
18:05:18 <ski> then a lower-heavy (antitone) galois connection between two (order-reversing) functions between two partial orders `O' and `P' is an upper-heavy ditto between `O^op' and `P^op'
18:05:42 <ski> (and, obviously, an upper-heavy (antitone) galois connection between two (order-reversing) functions between two partial orders `O' and `P' is a lower heavy ditto between `O^op' and `P^op')
18:07:48 <ski> (also, the order between `F' and `G' in the antitone galois connection case (both variants) doesn't matter. but the order matters in the monotone case. if we swap the order there, then we have to swap the order of the two partial order, while also exchanging each for its opposite (and we have to `^op' the functions `F' and `G'))
18:08:58 <ski> the `Cont o' case, where both `F' and `G' are `(-> o)', would be an "upper-heavy" contravariant adjunction between `F' and `G'
18:10:37 <ski> (oh, perhaps i should also state that the traditionally studied galois connections are (usually ?) the antitone ones. i suppose usually the "upper-heavy" variant ?)
18:14:11 <crestfallen> hi not sure what is happening on lines 81-88 , the last function listed. The first line of the if statement is ... && all isDigit xs .. that doesn't look right to me        https://github.com/varreli/haskell/blob/master/hutton/84_chapt11/ticTacToe.hs 
18:15:47 <Axman6> what's wrong with it?
18:17:06 <Axman6> xs is :: String, a.k.a, :: [Char]. The if statement checks that the string isn't empty, and that all the Chars in the String are digits
18:17:50 <c_wraith> crestfallen, is it failing to work somehow, or are you unsure why it works?
18:17:54 <ski> (in your case, `[]' can be written as `""', in `xs /= []'. however, generally, `xs /= []' is better written as `not (null xs)'. but if you can sensibly use pattern-matching instead, that's commonly even better than `null')
18:18:49 <crestfallen> Axman6, thanks but it seems to only take a one-digit string like "4". But there is the all predicate there
18:18:59 <crestfallen> c_wraith, ^
18:19:16 <ski> @src intersperse
18:19:16 <lambdabot> intersperse _   []     = []
18:19:16 <lambdabot> intersperse _   [x]    = [x]
18:19:16 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
18:19:22 <Axman6> what happens when you put in 44?
18:20:02 <c_wraith> crestfallen, is that observed behavior or what you think?
18:20:48 <crestfallen> I understood mostly everything up to this point in the program.
18:21:19 <ski> > Data.List.Split.chunksOf 3 "abcdefgh"
18:21:22 <lambdabot>  ["abc","def","gh"]
18:21:31 <Axman6> > read "123" :: Int
18:21:34 <lambdabot>  123
18:21:38 <c_wraith> crestfallen, in what way does what it does differ from what you expected? is observed, expected, or neither of the above correct?
18:22:46 <crestfallen> one moment please
18:23:06 <c_wraith> crestfallen, try to be specific. it really helps us figure out how to fill in the gaps. when you tell us the gap is "I don't get it," that's too big to quickly help with.
18:23:25 <crestfallen> understood one moment please
18:23:44 <c_wraith> if the gap is "I don't understand how it handles multi-digit numbers", that's much easier to approach.
18:25:09 <ski> instead of `valid :: Grid -> Int -> Bool', you could have `update :: Int -> (Player -> Maybe Player) -> Grid -> Maybe Grid' (e.g.). then you wouldn't need the `splitAt' in `move', in addition to the `(!!)' in `valid'
18:27:20 <MarcelineVQ> To add something I think is helpful, all sides of a conversation should strive to avoid the word 'it'
18:29:09 <crestfallen> so basically all is does is make sure the player's input is a digit, to indicate the space on the game board
18:29:34 <c_wraith> well. it makes sure the input is *all* digits.
18:29:44 <Axman6> it makes sure that all the characters in the player's input are digits, and that they input something
18:30:12 <c_wraith> remember, getLine :: IO String
18:30:17 <crestfallen> right in the case where it's a 4X4 board you would have two digit inputs
18:30:29 <Axman6> if you entered the string 123, it would recieve '1':'2':'3':[], a.k.a, "123"
18:31:07 <crestfallen> so Axman6 that is a very large ticTacToe board right?
18:31:08 <Axman6> which is not empty, and all the characters are digits. so read "123" returns 123
18:31:28 <Axman6> I guess... I  guess I don't understand what problem you're having
18:31:51 <crestfallen> we are looking at coordinate spaces on a ticTacToe board are we not?
18:31:54 <c_wraith> crestfallen, that function isn't concerned with the number fitting on a board.
18:32:09 <c_wraith> crestfallen, all it does is prompt until you input a number.
18:32:23 <c_wraith> bounds checking must be done by the caller.
18:33:53 <crestfallen> hold on so if we are playing on a normal ticTacToe board with 9 boxes, and you want to put your "O" in the last space at bottom right, you wouldn't enter a 9 ?
18:35:20 <Axman6> are you expecting to now understand this whole program and not just the function getNat?
18:35:24 <crestfallen> anyway I can figure that out later. you helped me see that the all function is returning a Bool. I thought there was a mapping or a functor or something else going on. thanks ALL I can move on.
18:35:27 <Axman6> expecting us*
18:35:48 <c_wraith> heck, it doesn't even prevent negative inputs...
18:35:51 <c_wraith> > read "9223372036854775808" :: Int
18:35:53 <lambdabot>  -9223372036854775808
18:36:04 <Axman6> D:
18:36:12 <c_wraith> it just makes you encode them in a funny way. :)
18:37:20 <MarcelineVQ> Was your questions actually"what is all?"
18:38:17 <Axman6> it was either that or "how does this whole program work", and somehow not somewhere inbetween
18:38:27 <crestfallen> well I see what all is doing in any case. also ...
18:38:38 <Axman6> :t all
18:38:39 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:38:49 <Axman6> % :t all @[]
18:38:49 <yahb> Axman6: (a -> Bool) -> [a] -> Bool
18:38:52 <crestfallen> yes thanks .. also ..
18:39:04 <crestfallen> I don't think isDigit will accept a negative digit
18:40:04 <Axman6> :t isDigit
18:40:06 <lambdabot> Char -> Bool
18:40:14 <Axman6> > isDigit '-'
18:40:17 <lambdabot>  False
18:40:20 <Axman6> > isDigit '1'
18:40:23 <lambdabot>  True
18:40:38 <Axman6> > map isDigit "-123"
18:40:41 <lambdabot>  [False,True,True,True]
18:40:46 <Axman6> > all isDigit "-123"
18:40:49 <lambdabot>  False
18:40:51 <Axman6> > all isDigit "123"
18:40:55 <lambdabot>  True
18:41:05 <crestfallen> that is helpful, interesting. one moment
18:42:23 <c_wraith> technically, there arent negative digits. at least in the most common systems.
18:42:44 <c_wraith> (balanced base 3 is cool, but not common)
18:42:45 <crestfallen> so wait then you couldn't enter a negative number in any way right?
18:42:49 <Axman6> c_wraith: until read is call, everything is Chars
18:43:07 <Axman6> there's no such thing as a negative string
18:43:08 <dmwit> crestfallen: c_wraith already showed you how to get around it.
18:43:18 <c_wraith> crestfallen, that's the intention, though it's technically incorrect because of how read works.
18:43:25 <c_wraith> see my example above.
18:43:35 <crestfallen> sorry may have missed it..
18:43:52 <c_wraith> > read "9223372036854775808" :: Int
18:43:55 <lambdabot>  -9223372036854775808
18:44:12 <c_wraith> that's how read handles Int overflow
18:44:12 <pong> nice symmetry
18:44:42 <Axman6> > read "10e10"
18:44:45 <lambdabot>  *Exception: Prelude.read: no parse
18:44:46 <Axman6> > read "10e10" :: Int
18:44:49 <lambdabot>  *Exception: Prelude.read: no parse
18:46:13 <crestfallen> > read "9223372036854775808" :: Int
18:46:17 <lambdabot>  -9223372036854775808
18:46:50 <crestfallen> I'm not getting that in prelude
18:47:08 <crestfallen> I'm getting 0 .. sorry don't know what's going on
18:47:30 <ski> > 10e10 :: Int
18:47:31 <dmwit> If you are using a 32-bit GHC (you are), try reading 4294967296.
18:47:34 <lambdabot>  error:
18:47:34 <lambdabot>      ‚Ä¢ No instance for (Fractional Int) arising from the literal ‚Äò10e10‚Äô
18:47:34 <lambdabot>      ‚Ä¢ In the expression: 10e10 :: Int
18:47:42 <ski> % :set -XNumDecimals
18:47:42 <yahb> ski: 
18:47:51 <ski> % 10e10 :: Int
18:47:51 <yahb> ski: 100000000000
18:48:01 <dmwit> Sorry, I mean 2147483648, not 4294967296.
18:48:40 <crestfallen> working..
18:49:23 <crestfallen> dmwit, yeah that works so I don't have the firepower
18:49:28 <crestfallen> thanks
18:50:10 <crestfallen> thanks ALL calling all tutors in the SF Bay Area
18:55:02 <crestfallen> ok so now, why does this evaluate to a negative number? :
18:55:11 <crestfallen> > read "2147483648" :: Int
18:55:14 <lambdabot>  2147483648
18:55:21 <crestfallen> wtf
18:56:33 <crestfallen> > read "9223372036854775808" :: Int
18:56:36 <lambdabot>  -9223372036854775808
18:56:59 <crestfallen> what's going on
18:57:10 <turab> So, I have been reading about dynamic vs static linking to try to understand some issues I was having
18:57:47 <turab> One main issue was the cabal new-install {package} would fail to install some dependency because Prelude wasn't found
18:57:48 <c_wraith> crestfallen, look up "2's complement signed integers"
18:57:51 <turab> Which seems odd
18:57:56 <c_wraith> (it's a big topic)
18:58:02 <crestfallen> > read "2147483648" :: Int
18:58:05 <lambdabot>  2147483648
18:58:34 <turab> Then after some Googlefu, I found out that I can toggle dynamic linking by default in lib/ghc/platformConstants
18:58:45 <turab> Is it okay to do that?
18:59:13 <crestfallen> c_wraith thanks will do. that number resolves to negative in prelude .. :/
19:01:39 <dmwit> turab: Is it possible you're on Arch?
19:01:51 <turab> Manjaro (so yes I guess)
19:02:12 <dmwit> If so, I think there's some pretty detailed info on the Arch wiki about what to do. But you might consider just installing your own GHC not through the package manager as a simple way to get everything Just Working.
19:03:32 <c_wraith> crestfallen, you're on a 32-bit build of ghc. lambdabot is using a 64-bit build. one of the few places you can see the difference easily is the behavior of Int on overflows.
19:05:01 <c_wraith> crestfallen, and specifically, when overflows happen. with 32 bits, it's a little over 2 billion. with 64...uh ,its bigger. I never bothered to memorize it. :)
19:05:18 <crestfallen> c_wraith thanks kindly. I'll climb that mountain when I get to it. appreciated..
19:06:07 <Slyda1> I am facing malicious activity by the Government and have the proof. I need help tracing their IP's, can someone help?
19:09:21 <turab> dmwit: Thanks for the response. Once I have time I will give that a shot. Arch wiki has been detailed about the linking issue but I couldn't really find a good way to have dynamic linking by default.
19:09:50 <turab> Wait, maybe adding the -dynamic in .cabal file might help?
19:14:04 <turab> nvm
19:17:20 <lyxia> The first section mentions .cabal/config
19:26:36 <turab> A question about cabal. From my understanding, once a cabal sandbox is setup, all cabal installs should install in the sandbox. However, I can see some binaries under ~/.cabal/bin. Is this normal?
21:00:57 <Engkol> helpp
21:04:19 * ski blinks
21:09:05 <dmwit> turab: Sandboxes are old tech. However, "once a cabal sandbox is set up, all cabal installs should install in the sandbox" is not correct.
21:09:42 <dmwit> The truth is that "all cabal v1-installs started from a directory with a cabal.sandbox.config pointing to a sandbox will install to that sandbox".
21:10:20 <dmwit> (For now, I believe all released versions of cabal have install aliased to v1-install, or else don't know the difference between v1- and v2- anyway so effectively do a v1-install.)
21:10:49 <turab> Thanks for responding, I thought my question got lost in there :)
21:10:55 <turab> I think I used new-install when this happened
21:11:31 <dmwit> new-install is v2-install. It doesn't do sandboxes. It's the new tech, and sandboxes shouldn't be needed.
21:12:29 <turab> I honestly should read about all installs properly instead of jumping around
21:13:15 <dmwit> Stick with v2-* stuff. It's the future, and it's generally cleaner anyway. It solves a very real and very annoying problem with complicated dependency trees.
21:13:34 <maerwald> cleaner? :>
21:13:46 <maerwald> better user experience probably, but not cleaner
21:14:38 <turab> I can look this up and its totally fine if no one feels like discussing, but how would one describe all versions of install in a nutshell?
