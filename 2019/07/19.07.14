01:14:31 <jackdk> I'm trying to compose rotations specified by two quaterions from the `linear` package. I'm sure the function I want is in one of its instances, but I can't find it. Can someone please help? I've been able to get by applying rotate separately, but that feels like it misses the point
01:15:33 <jackdk> oh, is it just the Num instance? https://hackage.haskell.org/package/linear-1.20.9/docs/src/Linear.Quaternion.html#line-245
01:24:07 <[exa]> jackdk: unit quaternion rotations are composed just by multiplication, so I guess Num instance (*) is just right
01:24:21 <jackdk> thanks [exa]
02:22:06 <sullyj3> Anyone got a nicer way of writing this? It feels ugly:
02:22:10 <sullyj3> getPort :: IO Int
02:26:49 <hc> What don't you like about it?
02:30:44 <sullyj3> I can't really justify it honestly, partially because I don't know what an alternative would look like. Just an intuitive thing. 
02:30:50 <sullyj3> do you think it's fine?
02:31:30 <hc> Well, what's the function supposed to do, exactly?
02:32:14 <merijn> It's not a function ;)
02:32:20 <merijn> </pedantism>
02:34:15 <sullyj3> use the PORT env variable as the port number, or the value of default_port if it's not set
02:34:59 <sullyj3> I'm writing a scotty JSON api
02:35:09 <merijn> sullyj3: Right, reading the environment is inevitably going to be IO
02:35:29 <sullyj3> Yes
02:35:55 <merijn> sullyj3: Seems reasonable enough to me, tbh
02:36:28 <sullyj3> Haha ok cool
02:37:26 <hc> merijn: right, it's not a function and that's not even pedantism ;)
02:41:58 <sullyj3> You could call it a nullary function! Kind of
03:05:27 <matheus23> Hi! Is there a channel I should look out for regarding questions about stack, or can I post them here?
03:06:12 <ziman> you can also read the environment at the start of your program and then keep it around in a pure structure
03:06:26 <ziman> i mean, read the environment, construct a config record and then keep that
03:08:07 <ziman> then you also have all logic pertaining to configuration in one place, as opposed to having it spread across many similar IO functions
03:10:15 <matheus23> I have a stack project (elm-reduce) that depends on "elm-format", which has a Setup.hs script that calls "git describe" (see https://github.com/avh4/elm-format/blob/master/Setup.hs). When I try to compile elm-format by cloning and "stack install"ing it works. When I add elm-format as a dependency to my stack.yaml in elm-reduce like so: https://pastebin.com/raw/5NdwCLpi It fails, because "git describe" is now
03:10:18 <matheus23> executed from outside a git directory... Why is that? What is the working directory for the Setup.hs script then? Or is the project cloned without a .git directory?
03:15:49 <hexagoxel> matheus23: Maybe add a `putStrLn =<< getWorkingDirectory` in elm-format/Setup.hs and see for yourself. Might have to push that to github if it needs to be an external dependency to occur.
03:16:20 <hexagoxel> Or directly try to use the variant of readProcess that sets the CWD to avoid the problem
03:16:57 <hexagoxel> (might be workarounds for a stack issue, but who cares if it works)
03:17:03 <matheus23> hexagoxel: Yes. good ideas. I guess I need to fork to check this
03:27:57 <kuribas> dependent types are so much easier than haskell's type system.  No need for type families, type synonyms, ..., you just use functions on types.
03:30:37 <matheus23> kuribas: Type synonyms can still be useful. There is a difference between
03:31:02 <__monty__> kuribas: Sure but you lose inference, which is haskell's foundation.
03:31:09 <matheus23> type MyInt = Int; f :: MyInt -> Int; f = id
03:31:24 <kuribas> __monty__: Couldn't you have a haskell type inference for a subset of dependent programs?
03:31:32 <matheus23> and \(MyInt : Type) -> (x : MyInt) -> x
03:31:43 <kuribas> __monty__: then require annotations when you go outside of that subset?
03:34:12 <__monty__> kuribas: Basically the answer is *no*.
03:34:37 <kuribas> __monty__: as in provably no, or as in there hasn't been research to find that out?
03:35:08 <kuribas> I mean you already lose type inference with many extensions
03:35:52 <__monty__> kuribas: As in, there's fundamental reasons why not. I don't 100% grok them. I myself thought *some* inference must still be possible. My advisors told me it's not viable. I didn't have time to further look into what might be a deadend.
03:37:53 <kuribas> __monty__: well, it has been said that sub-typing and inference don't go together, but then there is a paper that does exactly that: https://www.cl.cam.ac.uk/~sd601/thesis.pdf
03:39:54 <__monty__> Yeah, but dependent types are a whole 'nother ballpark.
03:40:32 <Lycurgus> a ballpark too far instead of bridge to something practical
03:41:52 <__monty__> kuribas: Note that I'd love to be proven wrong.
03:46:20 <__monty__> kuribas: Article linked here suggests inference is still possible if there's sufficient annotations: https://cs.stackexchange.com/questions/12691/what-makes-type-inference-for-dependent-types-undecidable
03:54:21 <kuribas> __monty__: yeah, something like that was what I had in mind.
03:54:53 <kuribas> __monty__: even in haskell you need to add annotations when you use one of the many type extensions.
03:55:23 <kuribas> __monty__: I'd also be happy with it not infering the most general thing.
03:58:15 <Ariakenom> there's some of that in haskell too. I think it infers Type sometimes when any kind works
03:59:08 <__monty__> kuribas: I know. But I vaguely remember a conversation with my advisors where the conclusion was that the inference that's possible is basically useless.
03:59:41 <kuribas> __monty__: are you researching dependent types?
03:59:58 <__monty__> No.
04:00:22 <__monty__> Did my MSc thesis using Agda.
04:00:38 <kuribas> nice
04:01:05 <kuribas> There are so many lanugages, idris, agda, coq, ...
04:03:05 <__monty__> Yeah, blodwen/idris2 is interesting. I think it's not fully dependently typed anymore?
04:04:25 <kuribas> it's still called " a dependently typed programming language"
04:05:25 <__monty__> Yeah, idris2's still pre-alpha. So I doubt they'd change the slogan already. But it's based on "Quatitative Type Theory." Haven't looked into the implications really.
04:10:59 <lyxia> https://bentnib.org/quantitative-type-theory.pdf that seems to be what you get when you mix dependent types and linear types.
04:11:36 <no-n> where can I find a good introduction to type theory?
04:12:20 <ski> no-n : do you mean type systems for programming languages ? or type theory as a possible foundation of mathematics ?
04:12:30 <merijn> no-n: Pierce's TaPL
04:12:32 <merijn> @where tapl
04:12:33 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
04:12:35 <__monty__> no-n: Pierce's Types and Programming Languages is usually the recommended work.
04:12:42 <ski> that ^ for the former question
04:13:01 <no-n> ski: both, I think :I
04:13:05 <merijn> Honestly, TaPL for both I think :p
04:13:18 <no-n> ahh, cool. that's alreayd on my reading list.
04:13:30 <ski> if you're coming from programming, then i think it makes sense to start with getting to know type systems better, first, yes
04:13:37 <ski> you could perhaps try
04:13:45 <ski> @where polymorphic-type-inference
04:13:45 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
04:13:51 <merijn> no-n: Goes from untyped lambda calculus up to way more than you ever needed for any language you wanna implement ;)
04:13:54 <ski> @where on-understanding
04:13:54 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
04:14:19 <no-n> merijn: nice :)
04:14:29 <no-n> ski: thanks
04:14:31 <ski> to get *some* general info about how the former may relate to the latter
04:14:42 <merijn> no-n: I got about halfway through and that's enough for like "haskell98"
04:15:00 <merijn> no-n: Example implementations too
04:15:18 <no-n> fun
04:15:22 <__monty__> Also, ,software-foundations
04:15:23 <merijn> (in ocaml, but should be readable with just haskell knowledge)
04:15:28 <__monty__> ,software-foundations
04:15:36 <ski> @where SF
04:15:36 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
04:15:36 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
04:15:58 <__monty__> Thank you.
04:16:40 <ski> __monty__ : you're not in #emacs, anymore :)
04:17:03 <ski> (or perhaps there's other channels where the bot escape prefix is also a comma)
04:17:21 <__monty__> Yeah #nix-* : )
04:17:40 <ski> interesting
04:30:15 <kuribas> merijn: TaPL has only four pages on dependent types though
04:34:03 <kuribas> and a large part of that is an explanation why having proofs as first class values isn't that easy to use.
04:35:08 <kuribas> But that looks more like a tooling issue to me, you just need tools that can guide you into combining proofs, or even writing them for you.
04:38:51 * ski thinks equality proof support could be better
04:41:32 <__monty__> @where attapl
04:41:32 <lambdabot> "Advanced Topics in Types and Programming Languages" edited by Benjamin C. Pierce in 2004-12-23 at <https://www.cis.upenn.edu/~bcpierce/attapl/>
04:41:39 <__monty__> kuribas: Maybe this has more.
04:55:12 <kuribas> __monty__: 43
04:55:56 <__monty__> kuribas: Fwiw, I don't think you'll need many pages on dependent types once you've read all these books. It's not like they're radically different.
04:56:13 <kuribas> __monty__: I just finished the little typer :)
04:57:13 <kuribas> it's a great introduction to dependent types
04:57:28 <kuribas> and it doesn't require a background in PL theory
04:57:41 <kuribas> although knowing haskell helped me a lot
05:00:54 <__monty__> kuribas: Fwiw, anything you can find by Pigworker SO answers, blog posts, papers, is worth a read.
05:01:07 <kuribas> right :)
05:11:03 <kuribas> __monty__: this answer is pure gold: https://stackoverflow.com/questions/12961651/why-not-be-dependently-typed/13241158#13241158
05:12:13 <kuribas> __monty__: "But proponents of less radical approaches have been known to stoke fear of dependent types without always making sure the facts are wholly with them. I won't name names. These "undecidable typechecking", "Turing incomplete", "no phase distinction", "no type erasure", "proofs everywhere", etc, myths persist, even though they're rubbish."
05:12:49 <__monty__> Oh, reminds me. Someone said dependent types make type classes redundant earlier? I don't think that's true. Agda has instance arguments to achieve a similar mechanism.
05:13:01 <kuribas> __monty__: idris has interfaces
05:13:08 <kuribas> which are type classes basically
05:13:46 <kuribas> I also wonder if you cannot just write something in idris, with proofs, etc, then port it to haskell
05:13:54 <kuribas> since haskell and idris are similar enough
05:14:22 <__monty__> Agda has some haskell extraction facilities. As does coq, though it might be ML rather than haskell?
05:15:21 <__monty__> But if you're doing that you might as well never bother with the dependent types and just use various other formal modelling languages which are usually more convenient.
05:15:30 <__monty__> The manual translation, not extraction.
05:18:50 <lyxia> Coq can extract to OCaml, Haskell, and Scheme, in decreasing order of reliability.
05:25:10 <turion> Where can I read up on how to use RebindableSyntax with Arrows? I can't find any resources on that. My first puny attempts didn't work
06:01:29 <kuribas> __monty__: which languages?
06:02:25 <__monty__> kuribas: Was thinking things like TLA+.
06:17:09 <duncan> Is there anything built in to QuickCheck that would allow me to view all the values that failed for a given test run?
06:17:47 <duncan> I was using sample' to generate a list of values, and then running that against them, but it doesn't actually fail for any of these. 
06:18:30 <duncan> The value  that QuickCheck is spitting out upon falsifying a given value actually passes the test in the property I'm testing, so it would be useful to see everything that failed.
06:21:15 <sicklorkin> duncan: you can stuff all the things in counterexample
06:22:21 <duncan> Would I need to make an instance of Testable for my datatype in order to use counterexample?
06:22:44 <sicklorkin> now, just showable
06:22:53 <sicklorkin> No, just takes a string
06:23:46 <sicklorkin> I recently ran into this problem and I just stuffed everything into a tuple.. e.g. show (a,b,c,e,f)
06:38:01 <duncan> sicklorkin: That makes sense. Thanks! :)
06:51:18 <hvim> How do I make an EitherT monad tranformer, I keep trying newtype-ing it like newtype EitherT m a b = EitherT { runEitherT :: m (EitherT a b)}, but I'm getting an error probably cause Either a b is not concrete, any tips on sloving this issue? 
06:53:37 <lavalike> hvim: do you mean m (Either a b) 
06:56:56 <sicklorkin> duncan: if that doesn't work i've found quickCheckWithResult useful - give you access to the seed used amongst other things to makes tests repeatable 
06:57:13 <hvim> The error states: cannot construct an infinite kind k0 ~ (k0 -> *) -> * In first argument of 'm', namely '(Either a b)'. I know a monad must be * -> * (taking one type parameter), but don't know about (k0 -> *) -> *.
06:57:31 <lavalike> hvim: yeah you are defining it recursively by accident
06:58:27 <hvim> Haven't noticed you removed the T, thanks.
06:58:47 <duncan> Further to QuickCheck, I've got some property I'm testing, which is something like prop :: Int -> Bool -> Bool. I can do something like `quickCheck prop`, but I can also do something like `quickCheck (prop 6 True)`. In the altter case, some of my tests only pass with that (which is fine), but some of them don't.
06:59:11 <duncan> How can I tell quickCheck to use a range of values for that particular test?
06:59:31 <sicklorkin> duncan: suchThat
07:00:05 <sicklorkin> `suchThat arbitrary (>1)` 
07:00:42 <sicklorkin> or `==>
07:02:13 <sicklorkin> e.g. property $ \(i :: Int) -> i > 1 && i < 100 ==> i === 2
07:19:04 <kosmikus> mpickering: no, I don't think a Top-equivalent exists for use with AllZip, if that's what you've been looking for. would make sense to me to add it.
07:39:49 <hvim> If I have type defined as TypeName m a b where m is a monad, as far as I know has kind (* -> *) -> * -> * -> * ->, to write an instance of MonadTrans I need kind (* - > *) -> * -> *. However if I try instance Typeclass a where ... ghc assumes a stands for m and I get kind * -> * - > *. How do I tell it to make a fixed in the instance not m? 
07:40:53 <hvim> I mean 'instance MonadTrans (TypeName a) where ...'
07:40:53 <lavalike> hvim: you got an extra -> in the first kind, but that is just a typo I guess?
07:41:47 <mpickering> kosmikus: How do you define it? Does `type C a b = ()` work? (I haven't tried anything myself yet)
07:43:04 <hvim> lavalike: yes that is typo 
07:45:16 <lavalike> hvim: so those kinds match, if you saturate all but the very last type parameter
07:46:54 <lavalike> err, nevermind that, they don't, one needs to move 'a' at the beginning I guess? weird!
07:49:06 <lavalike> hvim: for example StateT is newtype StateT s m a
07:50:44 <lavalike> :k forall s. StateT s
07:50:46 <lambdabot> (* -> *) -> * -> *
07:51:25 <hvim> lavalike: that works thanks
07:55:33 <ski> hmm, that's strange
07:55:47 <ski> @type return () :: Monad m => (forall s. StateT s) m ()
07:55:50 <lambdabot> error:
07:55:50 <lambdabot>     • Cannot instantiate unification variable ‘m0’
07:55:50 <lambdabot>       with a type involving foralls: (forall s. StateT s) m1
07:55:56 <ski> @let type AnyStateT = forall s. StateT s
07:55:59 <lambdabot>  Defined.
07:56:03 <ski> @type return () :: Monad m => AnyStateT m ()
07:56:06 <lambdabot> error:
07:56:06 <lambdabot>     • Cannot instantiate unification variable ‘m0’
07:56:06 <lambdabot>       with a type involving foralls: (forall s. StateT s) m1
07:56:38 <ski> why is `forall s. StateT s' even allowed, if neither of those two work ?
08:12:20 <cocreature> ski: RankNTypes are still quite useful even without impredicative polymorphism
08:20:58 <ski> cocreature : yea, but this wasn't about `RankNTypes'
08:22:01 <cocreature> ski: how is this not about RankNTypes? "forall s. StateT s" looks very much like RankNTypes
08:22:07 <cocreature> (the way you’re using it)
08:23:21 <ski> there's no `->' in that type
08:24:12 <cocreature> hm yeah you’re right
08:25:20 <cocreature> but I’m still not sure why "forall s. StateT s" should be forbidden completely. writing something like "(forall s. StateT s Int) -> Int" should work just fine
08:25:52 <ski> yes, but that's completely different
08:26:24 <cocreature> Then I’m not sure what exactly you want to disallow
08:26:27 <ski> (hint : what's the kind of `StateT s' ?)
08:28:11 <sicklorkin> :~>
08:30:48 <cocreature> ugh, looks like it’s one of those days where I should just stop looking at code :)
08:32:10 <sicklorkin> cocreature: good opertunity to clean house :P
08:32:53 <hpc> this is why i never read code, i only write it :P
08:34:20 <cocreature> sicklorkin: I think I’ll go for “eat icecream and watch netflix” instead ;)
08:34:56 <kori> hey #haskell
08:34:59 <kori> what text editors do you use?
08:35:05 <sicklorkin> ed
08:35:21 <ski> (careful with too chilly icecream, you could get a cold)
08:35:52 <ski> kori : Emacs
08:36:37 <realloc> hi, is it possible in GHCi to save all definitions in <interavtive> to a file? 
08:36:39 <kori> ski: nice
08:37:08 <sicklorkin> kori: what editor do you use?
08:37:25 <kori> neovim :>
08:37:38 * ski idly recalls chatting with an ex troglodyte
08:37:40 <kori> (and vis, sometimes)
08:38:03 <ski> (that's their description, btw)
08:39:12 <kori> troglodyte, i.e. someone who uses vi?
08:39:25 <sicklorkin> ski: ed not ex
08:40:27 * sicklorkin was tought vi the hard way
08:41:10 <ski> sicklorkin : yes, this person is not you :)
08:42:30 <sicklorkin> https://en.wikipedia.org/wiki/Editor_war
08:42:55 <ski> ed is the standard editor
08:43:04 <sicklorkin> kori:  always a good conversation starter
08:43:07 <[exa]> the wikipage is obsolete, there might be a different editor number now
08:43:24 <kori> sicklorkin: :D I didn't mean to start an editor war
08:43:41 <kori> i just thought there might be some ~weird~ answers
08:43:52 <kori> someone made their own text editor in python and they use that
08:44:06 <kori> https://github.com/Akuli/porcupine this
08:44:07 <ski> i think there are, or at least there have been, some Haskellers using Yi
08:44:17 <kori> yi is cool
08:44:21 <ski> (and where's Peaker when you need him ?)
08:45:07 <[exa]> there are people who implemented text editing in emacs lisp
08:45:10 * [exa] dodges
08:45:18 <ski> (i'd ask preflex about when they last saw him, except that preflex also went MIA, years ago ..)
08:45:22 * ski grumbles
08:45:49 <sicklorkin> I do a lot of pairing and recently found atom has a way to share screen via http (browser), rather than what i tend to do (tmux shared host)
08:46:00 <ski> [exa] : Vade Retro !
08:46:11 <kori> I don't really write haskell... but #haskell is one of the cooler channels I know so that's why I asked here
08:46:22 <[exa]> ski: I couldn't resist
08:46:38 <sicklorkin> dont' you hate it when your machines restarts
08:46:54 <kori> yes i do
08:47:02 <sicklorkin> the world is gone..
08:47:05 <ski> kori : perhaps you *read* Haskell then .. would balance up some czars who only write (grm)
08:47:19 <kori> write-only haskell?
08:47:22 <[exa]> sicklorkin: it runs its own http server?
08:47:27 <kori> ski: sometimes i try
08:47:34 <[exa]> sicklorkin: it would be perfect for the classes
08:47:38 <kori> i got my head buried deep into Scheme 
08:47:41 <kori> but sometimes I try...
08:47:43 <wroathe> Anyone here succeed in getting GHCI's :doc command to work with dependencies through stack?
08:48:01 <ski> kori : Scheme is a nice little language ..
08:48:01 <sicklorkin> [exa]: i'm not 100% on the details, but i was inspecting a collegue donig it.
08:48:38 <kori> ski: yes it is :>
08:48:56 <Lycurgus> no machine under my control restarts without my permission, except for dos 10 upgrades
08:49:02 <sicklorkin> wroathe: someone here tried and gave up.. but it's 100% possible according to their docs
08:49:23 <Lycurgus> or scheduled maint at hosting vendors
08:50:04 <sicklorkin> Lycurgus: i recently saw a machine that had an uptime of 900+ days
08:50:08 <Lycurgus> the what editor do you use thing addressed to #haskell, is sensitive
08:50:22 <Lycurgus> especially when it gets to IDE
08:50:51 * sicklorkin set -o vi
08:51:01 <Lycurgus> yeah some special situation machines, mostly old mainframes running decades are not unheard of
08:51:28 <[exa]> sicklorkin: do you remember the name of the sharing plugin?
08:51:51 <sicklorkin> no, but I can ask.. thier in Asia and I'm in NA.. so i'll get back to you on that
08:52:06 <[exa]> (I found atom-pair and the teletype thingy, but not much more)
08:56:09 <sicklorkin> [exa]: that's it..  it uses webRTC
08:57:07 <sicklorkin> my memory is shit.. when I said recently, i found my lots about this discussion and it was back in 2015 :| man i'm getting old.. seemed like just yesterday
08:57:15 <sicklorkin> *logs
08:57:38 <sicklorkin> [exa]: the other one I have written down is screenhero
08:57:48 <[exa]> ok nevermind, thanks :]
08:57:58 <[exa]> perhaps atom-webrtc-chat?
08:59:06 <sicklorkin> seems more likely.. the person who introduced it was in JP
08:59:44 <sicklorkin> [exa]: but i'll ask him later when when he wakes
09:00:04 <[exa]> yeah the github page is very JP.
09:02:24 <sicklorkin> [exa]: another option, depending on your setup, would be CRD
09:03:43 <sicklorkin> it's really fast and it's free..
09:04:27 <sicklorkin> (and you would be bound to one editor)
09:04:32 <sicklorkin> *wouldn't*
09:04:59 <sicklorkin> [exa]: https://remotedesktop.google.com/headless
09:20:52 <unfixpoint> If I was to implement a DSL that does type inference with something similar to type classes, what's a proper way of doing so? I looked at [Deconstraining DSLs][http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf] but don't really understand it, when I do parsing of the constant string `fold add 0 [1,2,3]` (where `data Exp ts t where {AbsT :: (t
09:20:52 <unfixpoint>  ∈ ts) => t -> Exp ts t; AppT :: (t ∈ ts) => Exp ts (t -> u) -> Exp ts t -> Exp ts u, ...}` is the parsers output) I won't be able to `eval` it without specifying `Exp '[Int,[Int],Int → Int → Int,[Int] → [Int], (Int → Int → Int) → Int → [Int] → Int] Int`.
09:21:11 <unfixpoint> Here's an example of that: https://tio.run/##lVbNcts2EL7jKXYUz5BsKdlOmrbxWJpxbMX11LE9jdIcVB0gEozYkABDgpY1dXtMc@z0Zfo@eRF3FwBpypbTNJ6IAPbv228XSy549U5k2c0NNP9@6z@C04Oz49cHx2M44pr/mMq4gkf939m6SJTppXhRy0ir8r74RSau0nkmDpXU4kpXD2ucyEpzGYkNKscHR5MNx6c8n8f8kFfivuxlnen0gpc8n6wKcZjxqtrkmYTnhSg5gt8gfi3TSMXi1UpqfmXELFdxnQl4yVMJy4UoBWNpXqhSG5IGhohUSfCVDNYkp2mlw
09:21:12 <unfixpoint> U9UFmdeK5kgJwOEWYmIsX4fkqSCOSbE0sSDOVzBCq7xOcTVNSiN8ZYppjuEFTP6hB@WqZaiqlL5FiJKFHgUqTKmvVaw0LrY295eLpeDWEWDNBrwaFC/2/5jmf2683Q7STNRbR@JSCH/JWaFZoMiTsi7H/EsEzGML9NYYGmAAIiA2SgaPn38CFhSywPBwJN/4A0@8a9iLMa8261jC@CHuKPma9hDYYDnk8yc@43fAD79@XejVjs1gnUidamgxDJUkGDTufxFxVLXQ6Z7z38e/3R6cHFxcnZMpXN4m4Ad0EOEdGvapkXRnU29wWaSGTCLPM/Bj5WopKdhqcp3AR53gXRwIIw195T
09:21:12 <unfixpoint> rB4wSNIeWI3TrgtQyFkkqxS1lvkYLNCB@UY@uBvAKGjXsyoJjQwM2lkDjGOYr8Pe2AluM8VVBYXRbjIN5NTG@G1yMLr9LHaE1Bng8fm81/fF70GFrEMJzpbKmZq15G6nrpbshK9TGwRBP1gv/eY9W9uELIhBoSn1zfk7JlaAOHnRTM8aLYp2l/@vBOBjaQpi6jS95VnNNd5RLLFZR0g1WkgkUmFBrjrQ9H8IvEU0HV7dLI7t0taFhQXsaPsNhAMYCD1uS52sqNGG2rNJ8TTmBvS1ckp45TcC3Ugf9qM7zFXYZDq2SaRpAZoCVwBGfnWXwSpeUmh8AZ4xm3oUtsT83fjn0RxSV1
09:21:13 <unfixpoint> vZkymd2F9zWiTh2rv2G6y9wELiAQ6gsih7tezAaQVHj9fUNd80gZjxuwOFcMS46z/9As8kisB5vo@P2bnD/a1Rjkmsb2blFa3s2hFLwGPa3RpjwXmAWSorzBKberjcYeM@8Gex/NYKcyxXE6dsUge5fj2AHVdu4Oz3GMnzpuOymetbeL7NBBvERdO5ZJ0VN4jvpkrbzWCBGk4mFBnOhl0JIiBa8BG/qgTfzwK9EMZbx89Uu6uOaQtgJihsiqOD0usc8rFnoYVLulLGqzpumeaAynYMpLmZ3ixZ@tqShPWwZaT2Y1a2WE2wiqSGGvFq8Q4gVXSFsLtjvm@cF7qlOuzYz3KkC4/w
09:21:13 <unfixpoint> F1Cb3ZCsjaqmldrinY4aJ@ZKgm4re8Hdlu8RWx1iZu3oqtIczROCnB8vpk4UIPTnHi2m3Dm@BHaObaWBbtKqjiBzbfn1iDS17djZ5REyI/5EzQ5FhASATmgCYz51hF1DzZdnpeN86MhSH5rc/Mo@Zq8JdbJSjmTxtiJ5b9KA33Q0fh0/CWQ@tMPez88l4D94ssC2l0sieiNJkZb6KFviap8GF79Pum3tTNN@GM9Xt0W/PzhMqH943F/Ob8Gn4bfhd@H34LNzdmfUsSyl9L9lcx2Wp2nyJOJvzhv4M73Tig138UPvbSgQ3N/8C
09:22:06 <unfixpoint> So basically my question is: Is there a common pattern to this type of a DSL?
09:23:41 <ski> hm. perhaps you should have pasted that link somewhere ..
09:25:17 <unfixpoint> Did the link not arrive?
09:25:41 <cocreature> it’s split over multiple messages which makes it unclickable in a lot if not all clients
09:26:04 <unfixpoint> one sec, will fix - sorry!
09:26:09 <Phyx-> Wow what a link
09:26:31 <unfixpoint> https://bit.ly/2XPno5g
09:26:31 * ski can't recall ever before suggesting to paste a link
09:27:08 <unfixpoint> Phyx-: Yeah, it basically encodes the complete program
09:28:52 <unfixpoint> Would this perhaps work: parse ~> type check ~> typed GADT ~> eval with something `data Exp t where { EqT :: Eq t => Exp t -> Exp t -> Exp Bool, AppT :: _, AbsT :: _, ...}`
09:30:40 <Ariakenom> me once pasted an image embedded in a link. resulting in a ban from freenode
09:31:13 <dmwit> unfixpoint: Is the question here about how to write the parser? Or something else?
09:32:10 <unfixpoint> Not really, but rather how to dynamically generate such an expression
09:33:08 <ski> Ariakenom : ouch
09:33:19 <dmwit> If you would like to be allowed to choose a type parameter at runtime -- i.e. you don't know at compile-time which one it should be because it depends on the string you read from a file or something -- then you want to look at existentials.
09:33:26 <unfixpoint> Like now, I cannot write a sensible parser because I'm unable to specify all type constraints. The program fails as soon as I change somewhere a constraint `_ ∈ _`..
09:33:41 <ski> Ariakenom : i think i've been K-lined once, from explaining something to a beginner
09:33:57 <dmwit> But I'm still not really sure I understand what you're after, so take this advice with some salt, I guess.
09:34:29 <ski> (Sigyn thought i was repetitive, when i was trying to show some fine point pertaining to small differences in variations of some line of code, or somesuch)
09:34:44 <ski> (and i've also seen this happen several times to other people)
09:37:03 <sicklorkin> ski: do you request freenode ops to monitor your channel? or do they just monitor all of them all of time?
09:37:23 <ski> Sigyn is in here
09:37:32 <dmwit> I believe you request it.
09:37:37 <dmwit> To answer the question as asked.
09:38:03 <sicklorkin> dmwit: thanks
09:40:32 <ski> (i suppose i've asked three or four times in #freenode about lifting what i considered to be an misfiring of Sigyn .. and was granted that)
09:41:37 <sicklorkin> i've received several warning here but never kicked off.
09:41:41 <Ariakenom> I was unbanned quite fast by a human too
09:41:56 <dmwit> I have been k-lined, too, and like ski I found freenode's staff quite responsive and helpful.
09:42:48 <unfixpoint> So,  `data T = forall a. Constraints a => MkT a` with atomic types instancing `Constraints` and then parametrise the data type with T instead?
09:42:58 <ski> dmwit : indeed
09:43:18 <unfixpoint> :S
09:44:04 <ski> sicklorkin : yes, it appears that nowadays it also takes into account how long you've been in the channel (measured, i don't know how)
09:44:37 <sicklorkin> ski: yeah, usually the msg says something along those lines..
09:45:27 <ski> hm, actually, i think i may have been K-lined two times. the second time, it was because i was using unicode math symbols in ##math
09:50:24 <Ariakenom> heh I've sure seen msgs from ski with the main part consisting mostly of empty squares in my font
09:51:50 <sicklorkin> glyphes will get you banned
09:54:14 * sicklorkin knows zalog will get you banned too http://www.eeemo.net/
09:57:21 * ski grins at Ariakenom
11:59:06 <shafox> newtype MyType = MyType { fv :: [Fields] } deriving (Show, Read) And newtype MyType = MyType [Fields] deriving (Show, Read) , what is the difference between these two ? 
12:00:00 <merijn> shafox: The automatic generation of the "fv" accessor function :p
12:00:15 <MarcelineVQ> shafox: https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_(Record_Syntax)
12:00:21 <merijn> shafox: other than that, they're identical
12:00:50 <Heffalump> merijn: and the ability to use record update syntax
12:00:55 <shafox> merijn, thanks :) 
12:01:08 <Heffalump> which I guess it a bit pointless with a newtype
12:04:12 <MarcelineVQ> Heffalump: why pointless?
12:05:37 <ski> heya Heffalump :)
12:06:16 <ski> shafox,MarcelineVQ : well, the derived `Show' and `Read' instances will also be different, actually
12:06:36 <ski> merijn ^
12:07:41 <ski> MarcelineVQ : well, there's only one field, so either you update nothing (so `id'); or you update that field, and so there's no other fields to carry over, might just as well have called the plain data constructor, without record syntax
12:08:29 <wroathe> Say I've got a configuration data structure with fields of variable types, like data Config = Config (HashMap Text Text) (Maybe Port) (Maybe HostName) etc, and I want to write a function that implements merging two values of this type with particular merging strategy for each field dependent on it's type. What typeclass would be best to semantically model an operation like this? Semigroup, Alternative, 
12:08:36 <wroathe> something custom like Mergeable?
12:09:06 <wroathe> i.e. merge c1 c2 where c2's individual fields are preferred to c1
12:10:00 <wroathe> In this particular example I'd want my map field to use union, and the two Maybe fields to use <|>
12:11:44 <MarcelineVQ> Sounds like a Monoid/Semigroup, the problem might need to be specified or exampled further though
12:12:48 <wroathe> I put my library I was working on to implement this on hold, and now I'm just working on building an app that sources configuration from multiple sources on startup
12:13:07 <wroathe> optparse-applicative, env variables, json configuration files
12:13:19 <wroathe> and each is going to parse into a value of this Config type
12:13:48 <wroathe> and I want to do something like: let finalConfig = c1 `merge` c2 `merge` c3
12:14:04 <merijn> wroathe: parameterise each field with First and use Monoid/Semigroup? :)
12:22:00 <solonarv> you don't need a First wrapper, just write the Semigroup instance you want (and Monoid as well if there is a sensible "empty" configuration, in your case that would be Config (HashMap.empty) Nothing Nothing)
12:23:09 <ski> (no brackets)
12:23:37 <solonarv> oh, oops
12:25:03 <wroathe> While a useful abstraction, it almost always seems like Monoid and Semigroup are too abstract. There are lots of binary operations that make sense for custom data types, and dubbing just one of those to be the Semigroup definition seems somehow silly :P
12:25:16 <wroathe> But I think I'll just bite the bullet and do that
12:26:03 <ski> which other ones do you think could be handy on `Config' ?
12:26:03 <int-e> wroathe: you can always do it properly... which means to use a newtype wrapper for the specific algebraic structure at hand.
12:26:29 <wroathe> int-e: true
12:26:32 <int-e> at the very least, left-biased and right-biased for the maybes?
12:26:49 <ski> isn't that just a `Dual' away ?
12:27:00 <MarcelineVQ> ski: But record syntax lets you update values, so you can avoid the constructor wrapping/unwrapping. when foo is some MyType, foo { fv = [1,2] } is the update that is agnostic to wrapping
12:27:41 <MarcelineVQ> It's in this way it's not pointless to me
12:28:10 <ski> i don't know what you mean by "agnostic to wrapping"
12:28:34 <ski> i'm wondering why not just `MkMyType [1,2]', in that case
12:29:07 <ski> or you want to get bottom, in case the input was bottom ?
12:29:34 <wroathe> Doesn't it somehow seem ugly to have N newtype wrappers for N semigroup definitions for your datatype?
12:29:35 <ski> (hmm .. i wonder)
12:30:44 <ski> > undefined {out = Nothing} :: Mu Maybe  -- ok
12:30:48 <lambdabot>  In {out = Nothing}
12:30:52 <merijn> wroathe: What's the alternative?
12:31:16 <wroathe> the alternative is to not formalize this semigroup abstraction
12:31:20 <wroathe> Which isn't a good choice either
12:31:29 <solonarv> what other semigroup operations do you intend to define on your config type?
12:32:04 <solonarv> that seems to me like exactly the sort of operation you would want to define centrally so that your program behaves consistently
12:32:17 <wroathe> I don't. I'm just thinking out loud about what happens when I've got other binary operations that could define a semigroup with this type
12:32:17 <[exa]> wroathe: newtypes were made for this. you can even define some shortcut function that adds the correct newtype for you, so that the code is generic
12:32:48 <ski> i'm wondering what those other binary (associative) operations would be
12:32:58 <MarcelineVQ> ski: By wrapper agnostic I mean I don't have to remove the fv field from the MyType value constructor and rewrap it when I'm done. I see what you mean with MyType [1,2] though, I guess I hadn't considered that when I was thinking in terms of 'updating'. Another consideration, though I'm not sure how useful this is in general haskell use, foo { fv = [1,2] } works for any foo with the field name fv.
12:33:04 <wroathe> Like int-e said, left bias or right biased merge
12:33:07 <wroathe> are two
12:33:23 <wroathe> In this case I'm defining it as right biased
12:33:33 <wroathe> But this is a way more general thought than my silly Config type :P
12:33:47 <int-e> for configurations I would probably go with the right-biased monoid as the default one as well...
12:34:01 <MarcelineVQ> In some magical future when record namespace resolution is nicer this might matter for code-reuse
12:34:06 <ski> MarcelineVQ : i'm sorry, i still don't follow "remove the fv field from the MyType value constructor and rewrap it when I'm done" (perhaps because i'm tired ?)
12:34:22 <int-e> basically it's a case where (I think) it's fairly clear which semigroup (perhaps monoid) will be the most commonly used one.
12:34:31 <int-e> :t Sum
12:34:34 <lambdabot> a -> Sum a
12:34:47 <ski> MarcelineVQ : yea, if Haskell had light-weight records (like TRex in Hugs, e.g.), that "foo { fv = [1,2] } works for any foo with the field name fv" would be more relevant
12:35:08 <int-e> (I would hesitate to make a default monoid for (Num a => a)s)
12:35:31 * ski doesn't think `Monoid (Num a => a)' makes sense
12:35:59 <solonarv> and for the specific case of left- vs. right-biased merging, those are easily expressed in terms of one another
12:36:06 <wroathe> I'm sure everyone here has had a point when using someone else's library code where you wanted their definition of <> to behave differently than it does
12:36:26 <wroathe> Like, "why did you pick THAT definition of <> :/"
12:37:33 <MarcelineVQ> ski: remove in the sense of "baz (MyType fv) = MyType (update fv)" we're unwrapping fv, operating on it, and rewrapping
12:38:09 <wroathe> The alternative to that with newtypes is that they define a newtype for the subset of possible binary operations on their datatype that they think their consumer might want, which seems somehow worse than just defining them as regular ole functions and ignoring the Semigroup formalism all together
12:38:45 <ski> MarcelineVQ : ok. or as `MyType (update (fv mt))'
12:38:52 <solonarv> wroathe: yes, I agree
12:39:25 <MarcelineVQ> And while that's subsumed by fmap it also doesn't have to be. I don't have a particularly strong stance here other than record syntax for newtypes doesn't seem useless to me
12:39:43 <solonarv> but your points are mostly valid for some generic structure, like Map or Set
12:39:47 * ski somehow feels like the whole using `newtypes' to select different instances is the wrong approach
12:39:54 <solonarv> not so much for a concrete choice of keys, values etc
12:39:59 <ski> (i dunno what would be a better way, though)
12:40:16 <ski> MarcelineVQ : only if it's parametric
12:40:34 <ski> (`MonoFunctor', i suppose, if you wish)
12:40:52 <MarcelineVQ> yeah good point
12:41:10 <ski> anyway, the whole field selection function syntax is wrong to begin with ..
13:46:46 <monochrom> ski: What do you think of my crazy https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html  >:)
13:50:22 <[exa]> ski: the newtypes are kinda implicit way of sending the instance dictionary along; would explicit be better?
13:50:57 <monochrom> Sometimes explicit is better. Always having a choice is better. :)
13:52:11 <[exa]> monochrom: reading your post now :]
13:55:34 <fragamus> Hey I’m trying to use Generic lens with  parseFileContents but I am suffered big because srcSpanInfo does not have Deriving Generic. Is there anything I can do about it?
13:55:42 <int-e> monochrom: you can add  instance MyOrd resolver a => Ord (Resolve resolver a)  where  newtype Resolve resolver a = Resolve a  is a copy of `Tagged`. You're pretty close to implicit configurations territory, including the `reflection` package.
13:59:43 <monochrom> But I want to avoid newtype.
14:00:15 <monochrom> But you get to say reflection will remove the newtype behind the scene so it's fine.
14:00:39 <monochrom> But I don't like the behind-the-scene-expose-the-dictionary...
14:03:33 <fragamus> I mean toListOf (types @String) foo   Wont compile because the algebraic data type pertaining to foo includes SrcSpanInfo
14:04:19 <fragamus> It makes me want to cry
14:13:29 <fragamus> And SrcSpanInfo needs deriving generic in order for it to work. Is there any way to get the parsing thing to bind the type variable l with some other type
14:13:49 <fragamus> Is there any approach that you guys can see
14:16:59 <fragamus> For the love of God
14:17:06 <[exa]> monochrom: isn't the concept in your post somehow generalizable as a construction for all functors? it's kindof like patternmatching on Compose, except you require 'g' to be Ord1 or so
14:17:42 <[exa]> fragamus: that seems tricky
14:18:11 <int-e> monochrom: Well, I wouldn't want to write all these instances and come up with new 'resolver' types all the time.
14:19:09 <[exa]> fragamus: wasn't haskell-src-exts going to be replaced directly by ghc parser?
14:19:25 <fragamus> Oh?
14:19:40 <int-e> monochrom: Oh, there's also  GHC.Exts.magicDict  which exposes the same functionality but in a way that yields unsafeCoerce-free Core!
14:20:30 <int-e> monochrom: That magicDict function is something I discovered 4 weeks ago while looking at the GHC.TypeLits source code.
14:20:30 <fragamus> Exa: That’s news to me where can I learn more about that
14:20:57 <[exa]> fragamus: not sure, I heard it somewhere in neighborhood of this issue https://github.com/chrisdone/hindent/issues/530
14:22:06 <fragamus> Ok I’m going to go look at that but it means leaving the room BRB
14:22:40 <int-e> monochrom: I even made a ticket to change `reflection` to use it, here: https://github.com/ekmett/reflection/issues/44 ... only to realize that it had no tangible benefit (other than having unsafeCoerce in the Core code; ghc's optimizer is surprisingly smart when dealing with unsafe coercions...).
14:24:02 <[exa]> fragamus: anyway what version of src-exts are you using?
14:24:45 <fragamus> Well I am free to use any version
14:24:57 <[exa]> I though Generic was there
14:34:36 <fragamus> exa: I am using haskell-src-exts 1.18.2
14:34:54 <N3RGY> I am running into some problems attempting to (de)serialize GADTs. The problem is described in detail at https://gist.github.com/wyager/92f9cec60f6940990de630415e4d8c57 . Would appreciate any suggestions!
14:38:11 <N3RGY> I think if anyone is an expert on singleton types, that might be one solution to my problem, but I was not able to get it to work
14:43:24 <sclv> N3RGY: you can try to combine closed type families with typeclasses
14:44:19 <c_wraith> I've parsed GADTs into an existential.  It's not awful, because you can pattern-match to recover the actual type.
14:44:56 <N3RGY> c_wraith: Then I would need to store a tag as well, right?
14:45:06 <c_wraith> the GADT is already the tag
14:45:07 <sclv> yeah the general approach uses an existential
14:45:17 <sclv> but i think in this case closed type families might suffice
14:45:27 <N3RGY> What do you mean "the GADT is already the tag"?
14:45:47 <N3RGY> sclv: Could you give an example of the type family thing? I'm not sure what you mean
14:46:12 <sclv> here's an old answer where i showed the technique. i think i had a better answer somewhere but can't find it https://stackoverflow.com/questions/35290516/how-to-define-these-overlapping-instances-with-type-families
14:47:11 <sclv> basically instead of making Frob a class, make it a type family
14:47:54 <sclv> and then using closed type families you can solve the "open world" assumption that makes yr example fail
14:48:08 <sclv> but type families don't generate code, unlike typeclasses
14:48:08 <N3RGY> Unfortunately I don't have a lot of flexibility in choosing the structure of Frob. I want to make my GADT an instance of "Store"
14:48:23 <sclv> so you need a type family to pick the result
14:48:44 <sclv> then you use a twiddle to match that result to a concrete class instance
14:49:33 <N3RGY> Ah ok, I think I might see what you are suggesting
14:49:36 <N3RGY> let me give that a shot
14:51:33 <N3RGY> The argument to the type family should, I think, be :: Nat. But what should the result be?
14:54:21 <N3RGY> Actually, I'm a bit surprised the example in the stackoverflow post works. Won't the "VectorSpace a" instance get everything? As I understand, GHC matches on the RHS of the instance and will not backtrack if a constraint in the LHS (like a twiddle) is unsatisfiable, but will just fail to satisfy the constraint. is that wrong?
14:55:43 <dfeuer> The constraints for Magnify seem to get really awful when the monad is polymorphic....
14:55:49 <dfeuer> Is there a way to get a handle on that?
14:56:08 <sclv> you don't need to backtrack in that part, that's the gimmick. instead you rely on the closed behavior to do the search
14:56:27 <sclv> the instance with the twiddle just promises the search will succeed
15:01:30 <N3RGY> sclv: Could you explain to me the process the constraint solver would follow, given a `VectorSpace v` constraint (for some v)? I am not sure how the solver interacts with closed TFs
15:02:02 <sclv> i wrote that answer 3 years ago -- not sure i remember all the details tbh
15:02:21 <sclv> my advice is mainly to play with closed type families to try to understand them better on their own
15:03:07 <sclv> the thing is it'll immediately match on the instance and unequivocally accept it, then try to satisfy the constraints. 
15:03:21 <sclv> then because of the twiddle, it'll try to solve the subconstraint for GroundField
15:04:07 <sclv> hrm, that's not correct actually
15:04:52 <sclv> it tries most to least specific
15:05:05 <sclv> so it tries the pair first. and failing that it tries the general case
15:05:19 <sclv> but then when it hits the general case, then it tries to discharge the twiddle
15:05:56 <sclv> and because that's closed, it can always do so
15:06:32 <sclv> and use that to guide the dictionary lookup on Fractional (Groundfield a)
15:10:29 <sclv> N3RGY: oh found my answer with a better example of this https://stackoverflow.com/a/36168097/371753
15:18:04 <fragamus> exa: I updated haskell-src-exts and it works now
15:18:22 <fragamus> thanks for pointing out the new version derives generic
15:22:27 <N3RGY> Ok thanks sclv. My brain is too fried to think about this right now, but I will give it a shot later
15:29:48 <ecx86> i learned about convolution today
15:30:06 <ecx86> is it inaccurate to say that convolution is kind of like an inverse fourier decomposition?
15:30:22 <ecx86> instead of breaking down a signal into a series of copies of a function
15:30:51 <ecx86> convolution is taking an input signal and adding copies of a function?
15:31:11 <ecx86> i guess that's why deconvolution often uses FT?
15:31:35 <solonarv> sounds sensible to me!
16:05:28 <turab> How do we pronounce GADTs?
16:05:52 <slack1256> WATS
16:06:35 <sicklorkin> [exa]: https://floobits.com/
16:07:08 <bandali> turab, i’ve heard two versions: spelling it out, or saying “gadet”
16:07:10 <int-e> turab: I spell it out...
16:08:33 <turab> Gadet is easier on my tongue
16:08:36 <turab> Thanks all
16:17:41 <turab> slack1256: How do you pronounce WATS? :)
16:20:11 <ekboo`> what is latest version of haskell
16:20:22 <ekboo`> I hear many good things about haskell
16:21:36 <hpc> the latest version of "haskell" is the 2010 standard, but the latest ghc is 8.6.5
16:22:04 <hpc> you probably don't need the absolute latest, unless it's for something specific
16:22:39 <ekboo`> how long 2010 is supported this is almost 2020
16:24:04 <hpc> let's go with just short of forever :P
16:24:11 <hpc> haskell is different from something like say, python
16:24:20 <hpc> it has the standard, and it has implementations
16:24:26 * nshepperd2 pronounces it 'gadt'
16:24:36 <hpc> implementations are free to do whatever as long as they meed the standard, and the standard is written very generically
16:25:29 <hpc> the standard tends to change very conservatively
16:26:12 <ekboo`> how much math do I need to start with haskell, I keep hearing it is for and by math people
16:26:31 <dmj`> ekboo`: none
16:26:38 <hpc> you need about the same kind of math background as any other programming language
16:27:21 <hpc> haskell isn't "for" math people so much as math people found it interesting or useful
16:27:27 <slack1256> turab: I am spanish, I don't know how to say it
16:27:42 <hpc> re GADTs, i just say the letters
16:29:46 <turab> I was pronouncing it "Gads" with a really really subtle T but that just felt wrong
16:29:52 <ekboo`> haskell is more theory based programming language or not
16:30:59 <hpc> it's whatever you want it to be
16:31:02 <turab> ekboo`: I think haskell enables people to explore the more "mathy" side of programming language theory more easily.
16:31:26 <turab> As hpc said, you don't need to know all that, but it's nice if you feel like going on an adventure :D
16:33:00 <MarcelineVQ> stephanie says gad-it so I tend to just say that. Though I said GMAW as geemaw one time and got laughed at so it's all relative.
16:35:20 <ekboo`> Evaluation in haskell is different than normal programming, is it how haskell different and good?
16:35:41 <turab> What's GMAW? (I pronounced that as Guhmaw)
16:36:28 <hpc> ekboo`: that's one part of it
16:36:48 <dmj`> ekboo`: pros and cons, it's extremely convenient, but often times harder to reason about. GHC Haskell is really multi-paradigm, you can perform strict mutation w/ certain features (ST, vectors), but laziness is the default.
16:36:59 <hpc> there's 4 or 5 other design decisions like that which all feed into each other and make something quite nice to work with
16:37:03 <turab> ekboo`: That's one difference, yes. Once you start learning more, you will discover more differences
16:43:28 <ekboo`> I randomly watching haskell tutorials and the concept of currying is good
16:43:36 <ekboo`> I did understand nothing
16:45:26 <ekboo`> sum :: Int -> (Int->Int) sum x y = x+y
16:45:45 <ekboo`> what is currying there 
16:47:00 <turab> I will suggest one part of the following wiki: https://wiki.haskell.org/Currying
16:47:22 <turab> Start reading from "In Haskell, all functions are considered curried"
16:48:01 <ekboo`> hmm turab
16:48:25 <turab> And this chapter: http://learnyouahaskell.com/higher-order-functions#curried-functions
16:49:11 <ekboo`> https://wiki.haskell.org/Section_of_an_infix_operator  
16:49:48 <MarcelineVQ> turab: gas metal arc welding
16:51:06 <ekboo`> haskell on default infix or no
16:53:21 <dmwit> Identifiers are either all-punctuation or no-punctuation. All-punctuation identifiers default to infix, and the others default to prefix.
16:53:31 <dmwit> > 3 + 4 -- infix
16:53:34 <lambdabot>  7
16:53:40 <dmwit> > const 3 4 -- prefix
16:53:43 <lambdabot>  3
16:54:19 <dmwit> ("What is punctuation?" Consult the Haskell Report for the full details.)
16:54:45 <Axman6> > 1 + 3 == ((+) 1 2)
16:54:49 <lambdabot>  False
16:54:55 <Axman6> > 1 + 2 == ((+) 1 2)
16:54:57 <lambdabot>  True
16:55:15 <Axman6> > (1 `const` 2) == const 1 2
16:55:19 <lambdabot>  True
16:58:29 <ekboo`> thank you
17:03:33 <int-e> So contrary to popular belief, semicolons are not punctuation.
17:05:58 <heatsink> They're diacritics?!
17:07:21 <int-e> > let (;) = id in succ ; 2 -- they are not valid in infix operators, so they can't be punctuation.
17:07:23 <lambdabot>  <hint>:1:6: error: parse error on input ‘;’
17:08:24 <heatsink> Oh, that.
17:12:09 <infinisil> "Mathematically, it is a strong lax symmetric semi-monoidal comonad on the category Hask of Haskell types. That it to say that w is a strong lax symmetric semi-monoidal functor on Hask, where both extract and duplicate are symmetric monoidal natural transformations."
17:12:14 <infinisil> Ah yes of course
17:12:23 <infinisil> (from https://hackage.haskell.org/package/comonad-5.0.5/docs/Control-Comonad.html#t:ComonadApply)
17:12:37 <MarcelineVQ> infinisil: It was obvious to everyone.
17:13:13 <infinisil> Yeah, not sure why they write it even down there, that's so common knowledge
17:19:32 <fragamus> https://gist.github.com/fragamus/dfe57cd6cb1a29f7cf96a6cc1dcd5094
17:20:15 <edwardk> infinisil: glad i could help
17:21:07 <heatsink> That's quite an error message golf
17:21:55 <infinisil> ':)
17:23:10 <heatsink> Are toListOf and types library functions?
17:23:24 <fragamus> thats from generic lens
17:23:28 <infinisil> The type of kfix in that module actually reminded me of loeb
17:23:37 <infinisil> kfix :: ComonadApply w => w (w a -> a) -> w a 
17:23:38 <fragamus> https://hackage.haskell.org/package/generic-lens-1.1.0.0#readme
17:23:44 <infinisil> loeb :: Functor f => f (f a -> a) -> f a
17:27:19 <fragamus> incidentally, the sub-expression starting with (UnQual does not have any problems
17:27:53 <fragamus> the expression starting with (TyCon does have problems
17:28:34 <fragamus> I am guessing that it has to do with the other type constructors in the ADT called Type
17:30:11 <fragamus> https://hackage.haskell.org/package/haskell-src-exts-1.21.0/docs/src/Language.Haskell.Exts.Syntax.html#Kind
17:31:47 <int-e> @unpl fix . (. flip id) . flip fmap
17:31:47 <lambdabot> (\ x -> fix (\ x0 -> fmap (\ y -> y x0) x))
17:32:29 <fragamus> @pl (\ x -> fix (\ x0 -> fmap (\ y -> y x0) x))
17:32:29 <lambdabot> fix . flip (fmap . flip id)
17:33:01 <fragamus> that looks nicer
17:35:24 <griddle> So I know you can represent `map` with `>>=` over lists: `[1..20] >>= \s -> [square s]`, but I am not totally sure why you need to return a list from that function
17:36:04 <dmwit> One answer is because the type of `(>>=)` says you must.
17:36:11 <dmwit> (>>=) :: [a] -> (a -> [b]) -> [b]
17:36:16 <griddle> ah I see
17:36:32 <dmwit> But then one might ask, "Why does the type of (>>=) say you must return a list?".
17:36:47 <argent0> hi, is there a way to make these instances work? https://bpaste.net/show/szo9 ?
17:36:49 <griddle> isn't it `m a -> (a -> m b) -> m b`?
17:36:53 <slack1256> I remember a book on practical depedent programming with ghc extensions, does anybody remember the name?
17:37:36 <dmwit> And to answer that you must look at the behavior of the (>>=).
17:37:38 <griddle> dmwit: does it also allow the list comp sugar to use filtering and return `[]` in cases of predicates failing?
17:38:09 <dmwit> It allows you to return [] to represent failure, yes. I think the question about list comprehensions are a red herring.
17:38:14 <dmwit> Sort of.
17:38:17 <dmwit> Sort of not.
17:38:41 <heatsink> argent0: You need to write HasGreenTag instances for the monad transformers
17:38:42 <dmwit> I don't know. List comprehensions as they exist today are a separate feature that do not use (>>=) in their implementation in GHC.
17:40:37 <griddle> though it seems simple to 'desugar'
17:40:38 <argent0> heatsink: :kind! (GreenIsh (WriterT String [] ))
17:40:51 <griddle> list comp down into `>>=`s
17:41:16 <argent0> that's is 'False
17:41:42 <argent0> shouldn't that match with: instance {-# OVERLAPS #-} (GreenIsh (f `Compose` g) ~ 'False, HasGreenTag g) => HasGreenTag (f `Compose` g) where
17:43:19 <dmwit> griddle: I agree. And there even is a version of them (enabled by the MonadComprehensions extension) that works for arbitrary Monads. But by default, that is not how list comprehensions work in GHC.
17:43:50 <dmwit> (It may incur a MonadFail constraint if you write an incomplete patter match.)
17:44:09 <heatsink> The type you have is (WriterT _ _), which doesn't match (_ `Compose` _).
17:44:35 <heatsink> You could try calling the Compose constructor to convert it to Compose.  Not sure if that'll make it work.
17:44:48 <Axman6> slack1256: was it isovector (Sandy Maguire)'s book?
17:44:48 <argent0> heatsink: Oh, let me check that out
17:46:23 <griddle> haha, that extension is cool: `[a * a | a <- Just x]`
17:46:35 <slack1256> Axman6: Maybe it was, I will check it out
17:47:43 <slack1256> Axman6: this is it!
17:48:05 <dmwit> argent0: Why ```instance GreenIsh (f `Compose` g) ~ True) => HasGreenTag (f `Compose` g)``` instead of ```instance HasGreenTag (Tagged Green `Compose` g)```?
17:48:28 <turab> How big is Thinking with Types? (asking cus I want to judge how long it will take me to finish it)
17:50:12 <dmwit> argent0: I'm also curious why you don't write `GreenIsh (Tagged Green) = True; GreenIsh a = False` and then ```instance (GreenIsh f ~ False, HasGreenTag g) => HasGreenTag (f `Compose` g)```.
17:57:29 <argent0> dmwit: I was having trouble with overlapping instances. And I thought first with `Compose` but application should be the same.
18:24:42 <Axman6> > (foldr f z [a,b,c], foldl f [a,b,c]) :: (Expr, Expr)
18:24:46 <lambdabot>  error:
18:24:46 <lambdabot>      • Couldn't match expected type ‘Expr’
18:24:46 <lambdabot>                    with actual type ‘[()] -> [Expr]’
18:24:54 <Axman6> > (foldr f z [a,b,c], foldl f z [a,b,c]) :: (Expr, Expr)
18:24:57 <lambdabot>  (f a (f b (f c z)),f (f (f z a) b) c)
18:39:54 <sicklorkin> turab: https://github.com/isovector/thinking-with-types
18:40:55 <turab> Wow didn't know it was open
18:41:05 <turab> Thanks sicklorkin 
19:03:06 <turab> :t flip
19:03:08 <lambdabot> (a -> b -> c) -> b -> a -> c
19:32:25 <fragamus> hi I made a lot of progress by getting the latest versions of my packages in my stack project BUT
19:32:37 <fragamus> I need the latest of GHC.Real.Ratio
19:32:57 <fragamus> which is apparently not in hackage
19:36:38 <fragamus> well I guess I have bas 4.12 which I think is the latest
19:36:56 <fragamus> but the error I'm trying to resolve is     • | No instance for ‘Generic (GHC.Real.Ratio Integer)’
19:37:37 <fragamus> base 4.12
19:41:59 <glguy> fragamus: I wouldn't expect Ratio to get a Generic instance
19:46:23 <fragamus> but for some reason when I parse the ADT called Type in this file: https://github.com/haskell-suite/haskell-src-exts/blob/master/src/Language/Haskell/Exts/Syntax.hs
19:49:09 <fragamus> let me start over.  When I do this: toListOf (types @(Name SrcSpanInfo)) foo    I have problems if foo contains anything of type "Type" as defined in https://github.com/haskell-suite/haskell-src-exts/blob/master/src/Language/Haskell/Exts/Syntax.hs
19:50:29 <fragamus> and I can not even identify where it uses Ratio
19:52:04 <fragamus> the foo that fails in this way is of type TyCon
19:52:38 <fragamus> which refers to ADT Type in some of its constructors
19:54:56 <MarcelineVQ> Is it perhaps some way you're handling % This symbol is used to create Ratio values
19:56:00 <fragamus> If there is any use of % it is referenced by Type but I dont see that in Syntax.hs
19:56:39 <fragamus> This problem manifests in the type system at compile time
19:58:22 <MarcelineVQ> That's all I got :X You'll need to be more specific about what steps you're taking, to give people more leads
20:06:31 <fragamus> MarcelineVQ: https://gist.github.com/fragamus/2ce047f46eefe5e6eadde586538e3694
20:06:55 <fragamus> the rest of you people: https://gist.github.com/fragamus/2ce047f46eefe5e6eadde586538e3694
20:24:50 <fragamus> updated: https://gist.github.com/fragamus/2ce047f46eefe5e6eadde586538e3694
20:32:03 <fragamus> MarcelineVQ: I can see no earthly reason that Ratio would be pulled in by    data Type
20:37:45 <MarcelineVQ> It don't think it is, but there's too many parts involved for me to narrow it down much. I get a lot more information in my error than you seem to be getting though: https://gist.github.com/MarcelineVQ/07c4ca27cf76bddc03424e5c159f5717
21:41:05 <fragamus> https://gist.github.com/fragamus/2ce047f46eefe5e6eadde586538e3694
21:42:41 <fragamus> If anyone can solve that ^ I will wash your car and walk your dog
22:15:28 <int-e> fragamus: Rational comes up because of Template Haskell, e.g., TySplice () (ParenSplice () (Lit () (Frac () 1 "1.0"))) :: Type ()  contains a 1 :: Rational.
22:16:04 <fragamus> yeah I just updated my gist because I discovered that at the same moment
22:16:54 <fragamus> so since I cant get ridof that I need a way to conjure a Generic instance for that and anything else that Exp pulls in
22:18:30 <fragamus> generics are great but if everything has an instance
23:17:28 <dminuoso> Is there a way to have a global -Wall while disabling orphan warnings per module?
23:17:52 <dminuoso> (Global via .cabal I mean)
23:18:38 <jackdk> {-# OPTIONS_GHC -Wno-whatever #-}?
23:20:33 <dminuoso> jackdk: Huh, I thought that didn't work if I had ⌜-Wall⌝ in ⌜my.cabal⌝
23:21:35 <dminuoso> Mmm. Did this get changed in a recent GHC version?
23:22:56 <jackdk> I have no idea.
23:25:11 <hvim> Hello. If I have a wrapper for a monad transformer stack like 'Parser a { runP :: EitherT String (State ParseState) a } derinving (Functor, Applicative, Monad)' how should I call get on the state part so the result will be Parse ParseState? I'm  try to use just 'get' but it probably requires Parse to be an isntance of MonadState is there a way to lift get into the wrapper? I tried lift . get but the types 
23:25:17 <hvim> don't match.
23:26:01 <ski> hvim : derive `MonadState ParseState' ?
23:26:54 <dminuoso> hvim: You could use generalied newtype deriving to avoid handwriting such instances.
23:27:06 <ski> they already are
23:27:29 <hvim> ski: I tried that but GHC complains 'no instnace for (MonadState ParseState (EitherT String (State ParseState)))
23:29:09 <dminuoso> hvim: Mmm, where is that EitherT from?
23:29:10 <ski> hvim : hm, why are you using `EitherT' rather than `ExceptT' ?
23:30:48 <hvim> dminuoso: EitherT is 'newtype EitherT a m b = EitherT { runEitherT :: m (Either a b) }' with instance for Functor, Applicative, Monad, MonadTrans 
23:31:02 <hvim> dki: It's custom MT exercise from real world haskell
23:31:22 <hvim> ski*
23:31:31 <dminuoso> hvim: Then you have to write an appropriate MonadState instance for that.
23:32:05 <dminuoso> hvim: Something like ⌜instance MonadState s m => MonadState s (EitherT e m)⌝
23:32:47 <dminuoso> You could of course just write it manually on your Parser stack, but you'll get more reuse if you write it on EitherT instead.
23:34:01 <hvim> dminuoso: if I write instance for 'MonadState s m' will I be able to use EitherT with other monad, not state but perhaps IO? 
23:35:44 <dminuoso> hvim: You can use EitherT regardless. That instance is just a way of saying "if that inner layer has an instance for ⌜MonadState s⌝, we can make ⌜EitherT e⌝ ontop of that layer conform to ⌜MonadState s⌝ as well.
23:37:38 <hvim> Ok I get it, thanks for help.
