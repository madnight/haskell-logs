00:37:06 <[exa]> sicklorkin: oh great thanks
03:05:22 <maerwald> is it a known issue that entropy doesn't build on alpine?
03:10:04 <sicklorkin> maerwald: does ti have any moving parts?
03:11:53 <maerwald> moving parts?
03:13:23 <sicklorkin> i was thinking it might be an embedded system
03:13:37 <sicklorkin> in which case entrophy would be limited
03:14:20 <sicklorkin> you can try install some prorams like timr_ent.. 
03:14:41 <sicklorkin> ahh i see, alpine is just a barebones distro
03:17:57 <sicklorkin> maerwald: https://wiki.alpinelinux.org/wiki/Entropy_and_randomness
03:18:30 <sicklorkin> they mention timer_entrophy 
03:18:39 <dminuoso> sicklorkin: I think you may be confusing the term entropy with the package entropy. maerwald is likely referring to the package "entropy" http://hackage.haskell.org/package/entropy
03:18:51 <sicklorkin> lol.. totally
03:21:35 <[exa]> haskell are many
03:22:24 <Iceland_jack> ^
03:22:27 * [exa] seriously surprised by the random middleclick in irssi window, sorry
03:22:49 <maerwald> yeah, entropy package doesn't build
03:23:12 <sicklorkin> [exa]: i played around with floobits; https://floobits.com/code_roulette
03:23:40 <int-e> maerwald: there are some fiddly c bits in there, it's hard to say anything without an actual build error. (oh and platform... (g?)cc version, ghc version, etc)
03:25:40 <int-e> (The fiddly bits are a result of trying to use the x86(_64) `rdrand` instruction.)
03:27:49 <maerwald> I get a segfault
03:29:35 <ski> [exa] : oh, i thought it was a sophisticated comment pertaining to the discussion at hand ..
03:30:56 <[exa]> ski: I can't deny it carries a bit of spirit
03:30:59 <maerwald> I don't see any logs
03:31:20 <ski> maerwald : try entering `19.07.15'
03:31:43 <ski> or .. were you not referring to the channel logs ?
03:31:50 <maerwald> no, build logs
03:32:37 <ski> oic
03:33:13 <int-e> maerwald: hmm I'd probably  cabal unpack entropy, then cabal configure -v2, cabal build -j1 -v2
03:40:24 <maerwald> int-e: yes, that doesn't give ma anything either. it just segfaults.
03:40:48 <maerwald> cabal: Failed to build entropy-0.4.1.4. The failure occurred during the configure step. The build process segfaulted (i.e. SIGSEGV).
03:44:50 <int-e> maerwald: so does ghc --make Setup.hs  also segfault?
03:52:16 <Zer0xp> Does anyone here work with Purescript ? Looking to convert a program from Purescript to Haskell but I don't know the Haskell equivalent libraries to be used.
03:53:38 <MasseR> I don't know purescript at all, but I might be able to help with haskell side. Also stackage.org/lts and hoogle might help if you equivalent type signatures
03:54:25 <merijn> Zer0xp: Depends on what those libraries have to do ;)
03:54:51 <Zer0xp> These are the libraries:
03:54:52 <Zer0xp> import Control.Monad.Aff (Aff)import Control.Monad.Eff.Console (log, CONSOLE)import Data.Array (mapWithIndex, (!!))import Data.Maybe (Maybe(..), fromMaybe)import Data.Tuple (Tuple(..))import Halogen as Himport Halogen.HTML as HHimport Halogen.HTML.Events as HEimport Halogen.HTML.Properties as HPimport Math (cos, sin)import Svg.Attributes as SAimpor
03:54:53 <Zer0xp> t Svg.Elements as SE
03:55:36 <Zer0xp> It's basically to render a 3-D object
03:56:47 <MasseR> Hmm... Maybe diagrams?
03:57:48 <tdammers> do you want it to run in the browser? with a GUI? CLI rendering into an image file?
03:58:14 <tdammers> either way, Halogen does not have a perfect equivalent in Haskell, so you will probably have to rewrite the GUI part
03:58:36 <MasseR> Diagrams is probably closest to the 'Render a 3d object' and your svg imports
03:58:49 <tdammers> and then you will most likely also have to toss the Eff/Aff stuff, because Haskell's execution and concurrency models are different
03:59:51 <tdammers> there are effect systems, but they are still different from purescript's Eff, and while you can have continuation-based concurrency a la Aff, it's generally considered more idiomatic to use Haskell threads (and probably STM)
04:04:23 <Zer0xp> tdammers: Yes, the output will run in a browser
04:04:57 <MasseR> Are you hoping to have ghc provide something for the output, or have a backend that's generating a svg for a separate frontend to show?
04:09:09 <Zer0xp> You can take a look at the code here. There are 2 files: https://pastebin.com/vc5wLa6W
06:02:41 <liceoprova> ciao
06:02:46 <liceoprova> !list
06:02:46 <monochrom> liceoprova: http://lpaste.net/browse
06:06:18 <liceoprova> !list
06:06:18 <monochrom> liceoprova: http://hackage.haskell.org/packages/
06:20:10 <dminuoso> Servant is fun. ⌜hoistServerWithContext api context nt server⌝ -- so I've had the strangest type bug where a mistake in ⌜server⌝ lead to a completely nonsensical type error in ⌜nt⌝
06:28:50 <AWizzArd> A monad is a monoid in the category of endofunctors. Okay. But does this mean that every monad is always a monoid?
06:29:08 <int-e> :t (>=>)
06:29:10 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:30:12 <Taneb> AWizzArd: only if you squint a bit
06:30:36 <dminuoso> AWizzArd: The monoidness is sort of 90 degrees flipped.
06:31:43 <dminuoso> AWizzArd: ⌜join :: (M :.: M) a -> M a⌝ so the monoid lies in "smashing" the composed functor composition layers. There you have the monoid laws.
06:32:12 <Iceland_jack> AWizzArd: Yes, monoid is more general than Monoid
06:34:55 <Zer0xp> This example is from learnyouahaskell.com: removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   --My question is how is 'elem' used to remove the non-uppercase if it only returns values of type Bool ?
06:35:17 <Iceland_jack> Zer0xp: It's used to "guard" which elements are kept / dropped 
06:35:38 <Iceland_jack> > [ n | n <- [0..10], even n ]
06:35:39 <ski> AWizzArd : every monad is a monoid object
06:35:41 <lambdabot>  [0,2,4,6,8,10]
06:36:31 <Iceland_jack> similarly
06:36:32 <Iceland_jack> > filter even [0..10]
06:36:34 <lambdabot>  [0,2,4,6,8,10]
06:37:10 <ski> Zer0xp : when that boolean expression ("guard") is `True', the current item `c' is kept, otherwise it's discarded
06:37:32 <Zer0xp> Oh okay. Also, Haskell states that the value of a variable cannot be changed (immutability and all) so what does the c <- st mean ?
06:38:20 <ski> Zer0xp : there will be as many "`c' variables" as there are elements in the list `st'
06:38:23 <dminuoso> Zer0xp: Are you familiar with the set builder notation in math?
06:38:33 <Zer0xp> I've been trying to get rid of this imperative way of thinking ever since I started learning Haskell but it's hard :|
06:39:07 <Zer0xp> dminuoso: I know what a set is, not sure about a set builder.
06:39:13 <sicklorkin> dminuoso: ahha! i never put the two and two together until you just said that.
06:39:14 <Iceland_jack> Zer0xp: Here is your example with 'filter'
06:39:14 <Iceland_jack> > filter (`elem` ['A'..'Z']) "topSECreT"
06:39:16 <dminuoso> Zer0xp: Then disregard what I said. :)
06:39:16 <lambdabot>  "SECT"
06:39:21 <Iceland_jack> Zer0xp: Here is your example with 'filter'
06:39:22 <Iceland_jack> > filter (`elem` ['a'..'z']) "topSECreT"
06:39:24 <lambdabot>  "topre"
06:39:28 <ski> Zer0xp : consider calling `removeNonUppercase "foo"', vs, calling `removeNonUppercase "bar"'. the variable `st' (the formal parameter) in the definition of `removeNonUppercase' can't change -- still, in one case, `st' means the string `"foo"', while in another case, it means the string `"bar"'
06:39:34 <Iceland_jack> oops didn't mean to repeat :)
06:39:50 * ski isn't sure whether Zer0xp has seen `filter' yet
06:40:07 <Iceland_jack> I'll keep to list comprehensions
06:40:15 <Zer0xp> I know how filter works
06:40:16 <ski> Zer0xp : "but it's hard" -- but worth it, imho
06:40:39 <ski> Zer0xp : do you know how `map' works ? `concat' ? `concatMap' ?
06:40:41 <Zer0xp> Yes, I've heard
06:41:40 <Zer0xp> > map(+2) [1,2,3]
06:41:42 <lambdabot>  [3,4,5]
06:41:57 <Zer0xp> I have a simple idea of how it works
06:42:38 <ski> Zer0xp : in math you can describe the set of all even integers as ⌜{n | n ∈ ℤ,2 ∣ n}⌝. this is called "set builder" or "set comprehension" or "ZF comprehension" notation
06:42:46 <AWizzArd> What is the neutral element in a monadic monoid?
06:43:34 <ski> > [n | n <- [0 ..],n `mod` 2 == 0]  -- the list of all even (non-negative !) integers, in Haskell. this is a "list comprehension"
06:43:36 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
06:43:40 <ski> AWizzArd : `return'
06:43:59 <dminuoso> AWizzArd, sicklorkin: https://gist.github.com/dminuoso/2a9ec97bce0adfe0aa4096a4a57037ff
06:44:22 <ski> Zer0xp : did you follow my "calling `removeNonUppercase'" example ?
06:44:23 <Zer0xp> ski: z,2 as in z 'mod' 2 ?
06:44:29 <fnurglewitz> <
06:44:42 <dminuoso> Note that Im handwaving a little about identity and isomorphic, with the intention of giving you the idea without focusing too much on subtle details.
06:45:10 <AWizzArd> And join is the „concat” op?
06:45:12 <sicklorkin> dminuoso: nice diagram
06:45:14 <ski> Zer0xp : no. ⌜ℤ⌝ is the common math symbol for "the set of all integers". in Haskell, it corresponds to the type `Integer'
06:45:23 <ski> AWizzArd : yep
06:45:35 <Iceland_jack> AWizzArd: join is the mappend, but you have to twist the types
06:45:35 <AWizzArd> k
06:45:48 <dminuoso> AWizzArd: My diagram, hopefully, illustrates it a bit. :)
06:46:08 <Iceland_jack>   mappend :: (,)     a a -> a
06:46:08 <Iceland_jack>   join    :: Compose m m ~> m
06:46:24 <Iceland_jack> and
06:46:25 <Iceland_jack>   mempty :: ()       -> a
06:46:25 <Iceland_jack>   return :: Identity ~> m
06:46:47 <Iceland_jack> (with Monoid a and Monad m constraints)
06:47:02 <AWizzArd> dminuoso: thx!
06:47:04 <ski> dminuoso : such diagram, very category
06:47:11 <sicklorkin> > join (***) sort ([1,23,3,4],[23,2,3,23])
06:47:13 <lambdabot>  ([1,3,4,23],[2,3,23,23])
06:47:40 <sicklorkin> join has much use
06:47:57 <ski> Zer0xp : so, you should read ⌜{n | n ∈ ℤ,2 ∣ n}⌝ as ⌜{n | (n ∈ ℤ),(2 ∣ n)}⌝. the ⌜,⌝ here means "and", i could have used ⌜∧⌝ instead
06:48:05 <dminuoso> AWizzArd: There's an equivalent formulation that int-e hinted at, which is a bit easier to talk about in Haskell terms: kleisli arrows
06:48:21 <sicklorkin> dminuoso: ext construct?
06:48:41 <dminuoso> :t (>=>)
06:48:43 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:48:53 <ski> Zer0xp : ⌜n ∈ ℤ⌝ correponds to `n <- [0 ..]' -- almost. the latter only considers non-negative integers (exercise, write a list that contains all integer !)
06:49:03 <dminuoso> This is a composition that is associative and has an identity (pure/return)
06:49:55 <ski> Zer0xp : while ⌜2 ∣ n⌝ (read "two divides ⌜n⌝") corresponds to  n `mod` 2 == 0  -- if we wanted to, we could define
06:50:25 <dminuoso> ski: This diagram is very very handwavy. :(
06:50:34 <ski> @let divides :: Integral i => i -> i -> Bool; d `divides` n = n `mod` d == 0
06:50:38 <lambdabot>  Defined.
06:50:59 <ski> > [n | n <- [0 ..],2 `divides` n]  -- the list of all even (non-negative !) integers
06:51:05 <lambdabot>  mueval-core: Time limit exceeded
06:51:11 <ski> @botslap
06:51:12 <lambdabot> Unknown command, try @list
06:51:19 <ski> @botsmack
06:51:19 <lambdabot> :)
06:51:31 <ski> > [n | n <- [0 ..],2 `divides` n]  -- the list of all even (non-negative !) integers, try again, pretty please ?
06:51:35 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
06:52:04 <ski> or, we could just as well have used
06:52:07 <ski> @type even
06:52:09 <lambdabot> Integral a => a -> Bool
06:52:16 <ski> here, to check whether `n' was even
06:52:30 * ski looks at Zer0xp
06:52:30 <Zer0xp> I have a basic idea of set theory. But from what I've learned, defining a set of all positive even integers was denoted by 
06:53:14 <ski> dminuoso : it's still nice :)
06:54:13 <Zer0xp> {n ∈ Z | n mod 2 = 0}
06:54:35 <Zer0xp> But you're right
06:54:42 <Zer0xp> I just read what you said after
06:55:01 <Zer0xp> 2|n is 2 divides n which means n is divided by 2
06:55:25 <ski> Zer0xp : replace ⌜n mod 2 = 0⌝ with ⌜n = 0 (mod 2)⌝ -- one typically doesn't much use a "modulo operator" in math, rather a (ternary) relation
06:56:01 <zzz> > Just (Just 7) >>= id
06:56:03 <lambdabot>  Just 7
06:56:27 * ski joins zzz with the `Maybe' monad
06:57:05 <zzz> :t (>>=)
06:57:05 <Zer0xp> ski: I'm sorry but I didn't really get this. consider calling `removeNonUppercase "foo"', vs, calling `removeNonUppercase "bar"'. the variable `st' (the formal parameter) in the definition of `removeNonUppercase' can't change -- still, in one case, `st' means the string `"foo"', while in another case, it means the string `"bar"'
06:57:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:57:10 <dminuoso> AWizzArd: If you want a full whirl, Applicative too is a monoid in a similar way.
06:57:15 <sicklorkin> join (Just $ Just 11)
06:57:32 <ski> dminuoso : i suppose i've been considering syntices to express these relations in a more formal manner .. but not quite as visually :/
06:57:36 <sicklorkin> > join (Just $ Just 11)
06:57:40 <lambdabot>  Just 11
06:59:11 <ski> Zer0xp : if you start evaluating/reducing the expression `removeNonUppercase "foo"', then, because `removeNonUppercase' is defined by `removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]', this will continue by reducing `[ c | c <- st, c `elem` ['A'..'Z']]', where the variable `st' now means / refers to / is bound to the string `"foo"'
06:59:16 <ski> Zer0xp : agree ?
07:00:13 <Zer0xp> Yes
07:00:17 <ski> > (join . Just . Just) 11
07:00:19 <lambdabot>  Just 11
07:00:40 * ski . o O ( Let's kill the `$'. )
07:00:49 <zzz> join is (>>= id)
07:01:03 <ski> Zer0xp : similarly, if you evaluate `removeNonUppercase "foo"'
07:01:20 <ski> Zer0xp : similarly, if you evaluate `removeNonUppercase "bar"', then `st' will instead become `"bar"'
07:01:33 <ski> Zer0xp : but `st' is an immutable variable, it can't be changed !
07:01:37 <ski> how does this work ?
07:01:43 <ski> zzz : yep
07:01:57 <Zer0xp> ski: Yes, that's a valid point.
07:02:18 <Zer0xp> Now I'm curious to know how it works 
07:02:19 <ski> zzz : can you prove `(join . return . return) 11 = return 11', using monadic laws ?
07:02:40 * zzz clicks
07:02:58 <ski> Zer0xp : conceptually, each time you call `removeNonUppercase', you'll get a *new* variable, referred to as `st', bound to the incoming parameter value that is passed to `removeNonUppercase'
07:03:49 <sicklorkin> eta (a) >>= f(x) <->
07:03:54 <ski> Zer0xp : similarly, in `[ c | c <- st, c `elem` ['A'..'Z']]', each element of the list `st' will conceptually make a *new* variable `c' (bound to that element)
07:03:59 <Zer0xp> ski :Oh is that because it was a function definition ?
07:04:24 <sicklorkin> Just a >>= f(x)
07:04:32 <sicklorkin> f(a)
07:04:33 <ski> Zer0xp : more or less .. but, as i just noted, something similar happens with generators, in list comprehensions
07:04:57 <ski> sicklorkin : are you zzz ? :)
07:05:14 <Zer0xp> Ah,.
07:05:35 * sicklorkin going back to typing dollar signs
07:06:03 <ski> Zer0xp : in fact, if you have function values, it's even possible to check whether it's the same variable that is changed (assigned to), or whether it's a new variable
07:06:48 <ski> sicklorkin : anyway, that's roughly the idea, yea
07:07:45 <Zer0xp> Is there any material you would recommend where I can learn all this ?
07:08:57 <Zer0xp> ski: there will be as many "`c' variables" as there are elements in the list `st' --- The most interesting thing I've learned all day, so thank you for this.
07:10:05 <dminuoso> AWizzArd: https://gist.github.com/dminuoso/01f628d81cecf600e6f0aaca0a9470b0
07:10:19 <dminuoso> AWizzArd: Just as a teaser. I dont expect you to make sense of it.. :)
07:10:52 <Zer0xp> ski: Also is it necessary for me to learn category theory before I learn Haskell ?
07:11:02 <merijn> Zer0xp: Naah
07:11:14 <merijn> Zer0xp: I don't even think it would help you
07:11:19 <Zer0xp> Oh
07:11:41 <ski> Zer0xp : no
07:11:52 <mmaruseacph2> if you want to learn it, it's actually easier to learn it after you know some Haskell
07:12:00 <mmaruseacph2> your mileage might vary, but that's my experience
07:12:08 <merijn> Zer0xp: Despite lots of people online claiming "Haskell is based on category theory", that's absolute nonsense. We pilfered a few terms from it, but it hasn't really impacted the language all that much directly
07:12:09 <ski> you don't need to learn Category Theory, to learn Haskell
07:12:43 <Zer0xp> Oh okay
07:12:47 <dminuoso> Zer0xp:  Here's a list of things you don't need at all to learn haskell: Math. Type theory. Category Theory.
07:13:05 <merijn> Zer0xp: If anything, Haskell is based on lambda calculus (and some core libraries pilfer a bunch of basic algebra notions like semigroups/monoids), but even that is basic enough you can learn it in less than an hour
07:13:12 <dminuoso> Zer0xp: Haskell has the same "difficult requirements" that any other language has, really.
07:13:54 <merijn> Learning lambda calculus might help a little, but on the other hand you could see Haskell as a tool for learning lambda calculus, so the benefit is...limited/tangential at best
07:14:12 <Zer0xp> I've learned Lamda calculus from the book: Haskell Programming from First Principles
07:14:14 <dminuoso> That is, if you have the basics to learn Python, you have the background to learn Haskell as well. In some sense it's just easier if you dont have as much experience in imperative languages.
07:14:28 <dminuoso> You do not even need lambda calculus either, if we are being strict. :)
07:14:32 <merijn> Zer0xp: You might also benefit from reading this (very short!) thing: https://patrickmn.com/software/the-haskell-pyramid/
07:14:35 <ski> @where prerequisite
07:14:35 <lambdabot> "Prerequisite for Learning Haskell" <http://www.vex.net/~trebla/haskell/prerequisite.xhtml>
07:15:10 <_d0t> ohai. I've got a question about Persistent. Is there a way to derive instance PersistEntity for existing data types?
07:15:21 <ski>   >>> [f(1) for f in [lambda y: x+y for x in range(10) if x % 2 == 0]]
07:15:25 <ski>   [10, 10, 10, 10, 10]
07:15:31 <ski> ^ that's Python
07:15:33 <merijn> _d0t: Is there *a* way? I think you can do it. Should you? Oh god, no
07:15:37 <ski> > [f 1 | f <- [\y -> x+y | x in [0 .. 9],x `mod` 2 == 0]]  -- Haskell
07:15:42 <lambdabot>  <hint>:1:28: error: parse error on input ‘in’
07:15:48 <ski> > [f 1 | f <- [\y -> x+y | x <- [0 .. 9],x `mod` 2 == 0]]  -- Haskell
07:15:50 <merijn> _d0t: Just write a new persistent datatype and a conversion function between that and what you want
07:15:50 <lambdabot>  [1,3,5,7,9]
07:16:05 <_d0t> merijn: could you explain more on why I shouldn't do that?
07:16:34 <_d0t> because, honestly, this looks quite cumbersome
07:16:42 <fragamus> is it possible to derive an instance of Generic for GHC.Real.Ratio
07:16:43 <ski> Zer0xp : notice how we get different results. this is because in Python, there is a single variable `x' in the list comprehension, which is assigned to, while in the Haskell version, there's a new variable `x' for each list element
07:17:02 <dminuoso> Zer0xp: Amusing story. When I learned Haskell I fell into the trap of "category theory makes haskell easier". So I spend 2 months learning the basics of category theory until I understood the joke "A monad is just..."
07:17:03 <_d0t> fragamus: should be possible with standalone deriving.
07:17:15 <merijn> _d0t: Because there are a lot of assumptions about what entities look like is baked into persistent and trying to fight to retrofit existing data into it is a real bother
07:17:16 <fragamus> where can I read up about that
07:17:30 <merijn> _d0t: Admittedly, I wouldn't even recommend using persistent at all at this point in time
07:17:36 <_d0t> fragamus: https://wiki.haskell.org/GHC/Stand-alone_deriving_declarations
07:17:38 <dminuoso> Zer0xp: After those 2 months I went back. Couldn't even do the most simplistic things. Had I spend those 2 months just writing Haskell programs, I would have gotten much faster. :)
07:17:46 <_d0t> merijn: what would you suggest I use?
07:18:00 <merijn> _d0t: Probably one of the *-simple libraries
07:18:01 <_d0t> I just need persistent storage with simple querying
07:18:03 <ski> fragamus : <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#stand-alone-deriving-declarations>
07:18:05 <Zer0xp> Wow
07:18:16 <merijn>  sqlite-simple, postgresql-simple, etc. 
07:18:22 <_d0t> merijn: alright. But why?
07:18:29 <fragamus> awesome thanks _d0t and ski
07:18:31 <_d0t> I've used persistent with esqueleto before and it was quite nice.
07:18:32 <Zer0xp> ski: what does f 1 mean in that list ?
07:18:43 <ski> Zer0xp : call the function `f' with input `1'
07:18:43 <dminuoso> `f applied to 1`
07:19:07 <dminuoso> Zer0xp: we just dont write parens, instead we juxtapose the function and their arguments.
07:19:14 <merijn> _d0t: I've used it too and it's too much work to migrate away from it, so I'm working on a PR for persistent as we speak :p
07:19:55 <_d0t> merijn: i guess depends on how you use it. I prefer abstracting away the storage stuff with some internal api.
07:19:58 <merijn> _d0t: I feel persistent has too much opaque TH, it is very inflexible if you want to do something "non-persistent-like", I find the generated boilerplate cumbersome to work with
07:20:16 <_d0t> hmm...
07:20:18 <_d0t> ok
07:20:37 <merijn> _d0t: My compile times with the persistent schema are...not great
07:21:04 <_d0t> merijn: that I don't really care about as long as there is at least some benefit.
07:21:18 <merijn> _d0t: I often find myself wanting complex queries I can't express directly in persistent (especially joins). I looked at esqueleto, but tbh the types signatures of that are insane and confusing
07:21:27 <_d0t> although ToRow and FromRow from postgresql-simple seems to be what I need
07:21:44 <merijn> _d0t: Not to mention it's not hard to generate unsafe things via esqueleto as it's not as safe as it claims
07:21:57 <_d0t> merijn: esqueleto can be that, yes. But after some getting used to I find it quite nice to work with.
07:22:16 <_d0t> merijn: the biggest problem for me is that esqueleto doesn't always keep up with changes in persistent.
07:22:17 <merijn> _d0t: I agree with abstracting the storage stuff, but I've become convinced that, in the end, it's just easier to write a very thin layer on top of the *-simple ones myself, instead of persistent :)
07:22:51 <Zer0xp> I just understood that example and my mind is blown by what you can do in Haskell.
07:23:14 <merijn> _d0t: Selda might be worth a look, as it does allow you to abstract a bunch of stuff, but it's design is more flexible and principled than persistent, I haven't had a chance to use it yet, though. So your mileage may vary
07:23:26 <_d0t> merijn: true. Although sometimes this can be bothersome as well. I wanted to write a simple abstraction with existential datatypes a few days ago and discovered with some help here that you just can't match on existentially quantified constructors with let expressions.
07:24:38 <_d0t> thanks, but I don't really need sqlite. I was aiming towards postgresql/mongodb pair just for the sake of comparing the two with my workloads.
07:24:45 <_d0t> but postgresql alone would be enough.
07:24:51 <Zer0xp> ski++
07:24:56 <Zer0xp> dminuoso++
07:24:57 * ski twitches
07:25:26 <dmwit> ski-- does this help
07:25:48 <ski> dmwit : sortof, but not really
07:25:49 <dmwit> ...you know what. I'm sorry. That was really nonconstructive.
07:26:02 <dmwit> It was a dumb joke, and I should have thought a few seconds more before making it.
07:26:02 * ski doesn't mind
07:26:04 <_d0t> merijn: anyway, thanks for the discussion
07:26:30 <ski> (i don't mind the joke. i do mind karma)
07:27:02 <Zer0xp> How do you increase someone's karma ?
07:27:23 <Zer0xp> I'm assuming it's a good thing over here, right ?
07:27:46 <ski> well, imho you should not do that, but if you really have to, you can use `@karma+ <nickname>' or `<nickname>++'
07:28:29 <Zer0xp> Cause I just did it to you but your karma didn't increase
07:28:34 <ski> it did
07:28:51 <Zer0xp> Oh okay, I didn't see it
07:29:05 <ski> (and i don't really like it :)
07:29:13 <Zer0xp> merijn++
07:29:31 <Zer0xp> Are there any perks to having more of it ?
07:29:38 <merijn> Not really :p
07:29:41 <dminuoso> No, and that's probably part of why it's silly.
07:29:59 <Zer0xp> Oh okay :D
07:30:07 <ski> (it would be worse if it had a more real influence)
07:32:18 <zzz> ski: return a >>= f = f a ; return a >>= id = (join . return) a = a ; (join . return . return) a = return a
07:33:12 <Zer0xp> Are there ways of representing complex numbers in Haskell ?
07:33:19 <ski> zzz : yes
07:33:34 <ski> > sqrt (-1 :+ 0)
07:33:38 <Boarders> Should I expect to gain anything from having a data type which is a constructor into an unboxed sum as opposed to just writing the sum?
07:33:39 <lambdabot>  error:
07:33:39 <lambdabot>      Precedence parsing error
07:33:39 <lambdabot>          cannot mix prefix `-' [infixl 6] and ‘:+’ [infix 6] in the same infi...
07:33:42 <fragamus> calooh callay it works!!!! thanks!
07:33:44 <ski> > sqrt ((-1) :+ 0)
07:33:49 <lambdabot>  0.0 :+ 1.0
07:34:02 <ski> > sqrt (-1 :: Complex Double)
07:34:05 <lambdabot>  0.0 :+ 1.0
07:34:54 <Zer0xp> Haskell has a built-in type called Complex ?
07:34:59 <c_wraith> is there a more modern PEG parsing library than frisby available?
07:34:59 <ski> @index Complex
07:34:59 <lambdabot> Data.Complex
07:35:05 <ski> yes
07:35:48 <ski> Boarders : i dunno. perhaps you should elaborate
07:36:16 <merijn> Zer0xp: Define "built-in"
07:36:36 <Boarders> I mean if I have Data Foo =  (# F1 | F2 | F3 #), Data Bar = Bar Foo
07:36:39 <Boarders> vs writing
07:36:42 <fragamus> haha my source file takes over two minutes to compile
07:36:49 <merijn> Zer0xp: Most types are defined in libraries (libraries that come with GHC, in case of Complex and many common ones), but they're not really special. You could define the same thing in your own library, tbh
07:36:51 <Boarders> data BarBoxed = F1 | F2 | F3
07:38:18 <ski> Boarders : i don't think the former is legal
07:38:30 <Zer0xp> built-in as in pre-defined
07:38:48 <ski> defined in "standard libraries"
07:39:27 <Zer0xp> Yea
07:39:34 <Boarders> ski: why not?
07:39:47 <Boarders> apart from perhaps the lack of hash
07:39:56 <dminuoso> Boarders: You need a data constructor name at the very least.
07:40:16 <ski> (it's not clear to me whether you intended `data' or `type')
07:40:33 <dminuoso> ⌜data Foo = Foo (# Int, Float #)⌝ would be a valid thing.
07:40:45 <ski> s/,/ |/
07:40:48 <Zer0xp> What is the difference between (x:y:[ ]) and (x:y:_) ?
07:41:01 <int-e> Zer0xp: the former is a length 2 list
07:41:08 <merijn> Zer0xp: The former matches only lists of *exactly* 2, vs *at least* 2
07:41:10 <dminuoso> Zer0xp: The first matches a 2 element list.
07:41:13 <ski> Zer0xp : the former is a two-element list, the latter matches lists of length at least two
07:41:25 <dminuoso> Point goes to int-e.
07:41:34 <Zer0xp> So what about (x:y) ? Isn't that the same as (x:y:[ ]) ?
07:41:41 <dminuoso> Zer0xp: It's not.
07:42:06 <Zer0xp> Oh x is the first element in the list
07:42:11 <Iceland_jack> > [x,y] == x:y:[]
07:42:13 <ski> Zer0xp : in `x:y', `y' is a list. in `x:y:[]', `y' is an element
07:42:14 <Zer0xp> And y is the remaining elements ?
07:42:14 <lambdabot>  True
07:42:17 <dminuoso> Zer0xp: Yes. And `y` is the tail
07:42:23 <Zer0xp> Yes
07:42:25 <dminuoso> Zer0xp: The tail itself is necessarily a list.
07:42:26 <int-e> now... x:[y] would be the same as x:y:[].
07:42:32 <dminuoso> Zer0xp: Are you familiar with data constructors already?
07:42:34 <Zer0xp> I remember learning this
07:42:37 <Iceland_jack> > x:[y] == [x,y]
07:42:40 <lambdabot>  True
07:42:54 <dminuoso> Iceland_jack: Huh. What magic is this?
07:43:00 <int-e> :t x
07:43:02 <lambdabot> Expr
07:43:16 <Zer0xp> dminuoso: Not really
07:43:17 <Iceland_jack> > foldr (+) e [a,b,c,d] 
07:43:21 <lambdabot>  a + (b + (c + (d + e)))
07:43:41 <Iceland_jack> check out https://hackage.haskell.org/package/simple-reflect-0.3.3/docs/Debug-SimpleReflect.html
07:43:52 <ski> > foldl (**) e [a,b,c,d]
07:43:55 <lambdabot>  (((e**a)**b)**c)**d
07:43:56 <Rembane> Lovely! 
07:44:21 * ski . o O ( "Luvly Jubly!" )
07:44:26 <dminuoso> Zer0xp: The list construction is recursive in essence. A list is either ⌜the empty list⌝ or ⌜an element prepended to a list⌝. That "prepended" is denoted as : in Haskell. So `x:y` denotes `x prepended to a list y`
07:44:49 <Zer0xp> >foldl (**) 2 [3,4]
07:44:50 <int-e> > x^10
07:44:56 <lambdabot>  mueval-core: Time limit exceeded
07:45:03 <int-e> > x^10
07:45:06 <lambdabot>  x * x * (x * x) * (x * x * (x * x)) * (x * x)
07:45:16 <dminuoso> Iceland_jack: Cheers. That's some magic there. :)
07:46:08 <Iceland_jack> Lists are distinguished with +s: 'ys', then it's clearer that 'a' and 'as' have different types in a:as 
07:46:24 <Iceland_jack> and [a,b,c] would be a:b:c:[]
07:46:37 <Iceland_jack> if we defined cs = [c], then a:b:cs
07:46:44 <dminuoso> +
07:50:03 <ski> the "s" in "xs","ys",&c. is "plural". like "many `x's","many `y's"
07:50:32 * ski thinks Iceland_jack meant `cs :: [c]'
07:51:35 <Iceland_jack> I was thinking of (let cs = [c] in a:b:c) instead of (a:b:c:[])
07:52:10 <dminuoso> Iceland_jack: `let cs = [c] in a:b:cs` ?
07:52:30 <Iceland_jack> > let cs = [c] in a:b:cs
07:52:34 <lambdabot>  [a,b,c]
07:52:36 <Iceland_jack> yes :)
07:53:07 <Iceland_jack> where is irc edit
07:53:17 <Iceland_jack> ..
07:54:27 <ski> ok :)
07:55:28 <foldr> Iceland_jack: thanks for mentioning me! Now I know I typed my nick wrong (was supposed to be rfold)
07:56:15 * ski disputes `foldr' being "wrong"
07:59:09 <Zer0xp> addNum :: Int -> Int -> IntaddNum x y = x + yaddTuples :: (Int,Int) -> (Int,Int) -> (Int,Int)addTuples (x1,y1) (x2,y2) = (addNum(x1 x2),addNum(y1 y2))I tried that last line and it's not workingIs that even possible or do I have to do this instead:addTuples (x1,y1)(x2,y2) = (x1+x2,y1+y2)
07:59:58 <Zer0xp> Can I use multiline in this chat ?
08:00:16 <fragamus> It takes GHC 3.5 minutes to compile half a page of code
08:00:21 <fragamus> bahahahaha
08:00:40 <Iceland_jack> rfold: :D
08:01:27 <Iceland_jack> Zer0xp: you have to write 'addNum y1 y2'
08:02:02 <Iceland_jack>  addTuples :: (Int,Int) -> (Int,Int) -> (Int,Int)
08:02:02 <Iceland_jack>   addTuples (x1,y1) (x2,y2) = (addNum x1 x2,addNum y1 y2)
08:02:30 <Zer0xp> Oh
08:03:10 <Iceland_jack> With TypeApplications you can define: addNum = (+) @Int
08:03:35 <Iceland_jack>   >> :set -XTypeApplications
08:03:36 <Iceland_jack>   >> addNum = (+) @Int
08:06:31 <ski> Zer0xp : you can write multiple lines into this channel
08:07:34 <merijn> fragamus: Datatype with lots of different constructors?
08:08:02 <hc> Zer0xp: what's multiline?
08:08:03 <ski> (but don't write too many at a time, you might get K-lined by Sigyn, our watchful ásynja)
08:08:10 <hc> is it a new IRC RFC?
08:08:20 <fragamus> merijn: yeah man it's recursive and difficult for the type system
08:08:46 <merijn> fragamus: Are you using "deriving"?
08:08:54 <fragamus> you betcha
08:09:08 <fragamus> and generic lens
08:09:09 <merijn> fragamus: There are some known issues with the code generated by deriving leading to some horrible slowdown on datatypes with lots of constructors
08:09:28 <fragamus> it's ok with me
08:09:37 <fragamus> I love torturing GHC
08:11:11 <merijn> fragamus: If you get good enough you can have a dedicated error message, like Iceland_jack ;)
08:12:08 <Zer0xp> ski: What is getting K-lined ? And who is Sigyn ?  *palms sweating*
08:12:27 <dminuoso> Zer0xp: Freenode mechanisms to deal with spamming users.
08:12:42 <Zer0xp> Oh
08:12:48 <fragamus> that's my new goal in life
08:12:53 <Zer0xp> So I would get banned for pasting code ?
08:13:08 <merijn> fragamus: https://twitter.com/Iceland_jack/status/949221173052747781
08:13:18 <dminuoso> Zer0xp: If you overdo it, yes. It's better to use pasting services like gist from github or pastie.org
08:13:32 <Zer0xp> Cool
08:14:35 <ski> Zer0xp : a few lines is probably okay. but for longer stuff, it's better to host the code somewhere (e.g. a paste site), and give the link to it here
08:15:00 <ski> (btw, if the link is very long, it may be better to host it somewhere (e.g. a paste site), and give the link to it here)
08:16:18 <neobrain> dminuoso: fyi, pastie.org has been dead for a while
08:16:39 <dminuoso> neobrain: Ah, that's a shame.
08:16:44 <neobrain> indeed :(
08:16:53 <ski> (e.g., if the link is 1686 characters long, that's definitely too long to paste into the channel)
08:17:06 <dminuoso> ski: By the way, do you approve of this? https://gist.github.com/dminuoso/01f628d81cecf600e6f0aaca0a9470b0
08:18:04 * ski . o O ( Psych. : "And you dreamt about this, this night ?" ; Patient : "No, this *happened* yesterday !" -- "Pondus" )
08:19:35 <dminuoso> For both diagrams I think I should replace the lower case ⌜a⌝ with some uppercase letter ⌜A⌝ instead. Otherwise it's even more inconsistent.
08:23:20 <ski> and ⌜M⌝ ?
08:24:46 <dminuoso> ski: Would you prefer ⌜M⌝ over ⌜T⌝?
08:27:08 <ski> just saying you had (lower case) `m' in the former paste
08:27:19 <dminuoso> ski: Oh yeah, I've upgraded that to M already.
08:27:23 <ski> ah, okay
08:27:30 <dminuoso> Or T rather.
08:27:32 <dminuoso> https://gist.github.com/dminuoso/d5ab4ba5d8a5142dde9f4d4c736e3ecb
08:27:33 <ski> should the arrow be in the opposite direction ?
08:27:53 <dminuoso> Which arrow?
08:28:03 <ski> in the definition of `Day'
08:28:34 * ski . o O ( is there an appropriate type we could call `Night' ? )
08:29:08 <dminuoso> ski: no
08:29:39 <dminuoso> ski: It's in the sense of ⌜class Functor f => Monoidal f where unit :: f (); (><) :: f a -> f b -> f (a, b)⌝
08:30:18 <dminuoso> Ohh wait! Wow good cathc.
08:30:22 <dminuoso> That's contravariant day
08:30:33 <Zer0xp> Can someone explain currying to me in the most simplest way possible ?
08:30:49 <ski> dminuoso : okay
08:30:50 <dminuoso> Zer0xp: The idea is that every function takes only a single argument.
08:31:34 <Zer0xp> So instead of sum(a,b) -> c it would be sum:: a -> b-> c ?
08:31:39 <ski> Zer0xp : Haskell only has "single-argument functions". in order to represent "multiple-argument functions", we must encode them, somehow. there's two common encodings, "curried style", and what might be called "tupled style"
08:31:53 <dminuoso> Zer0xp: Right.
08:32:00 <Zer0xp> Can we use tupled style instead of curried ?
08:32:07 <ski> yes
08:32:12 <dminuoso> Zer0xp: This is not just a syntactic feature. In fact `sum` is a function that takes one argument and returns a function.
08:32:33 <ski> also, note that Haskell doesn't "have" currying. currying is in out heads, when we represent multiple-argument functions, in Haskell
08:32:39 <dminuoso> `sum 1 2` can be thought of as two separate applications. First `sum` is applied to `1` to obtain a function, and that function is again applied to `2`.
08:33:00 <ski> (but Haskell *does* have syntactic support which makes it more convenient to use curried style, than would otherwise be the case)
08:33:16 <Zer0xp> dminuoso: What about the operator ? Where is that applied ?
08:33:24 <dminuoso> Zer0xp: Which operator?
08:33:26 <ski> s/out heads/out heads/
08:33:27 <Zer0xp> +
08:33:39 <Zer0xp> for sum
08:33:39 <dminuoso> Zer0xp: Infix operators can be applied manually by wrapping them in parens.
08:33:44 <dminuoso> Zer0xp: (+) 1 2
08:33:53 <ski> > let addFive = (+) 5 in (addFive 3,addFive 8)
08:33:59 <lambdabot>  (8,13)
08:34:18 <ski> > ((+) 5 3,(+) 5 8)
08:34:22 <lambdabot>  (8,13)
08:34:24 <ski> > (((+) 5) 3,((+) 5) 8)
08:34:28 <lambdabot>  (8,13)
08:34:29 <dminuoso> Zer0xp: ^- this is one of the motivations. The idea that a function accepts only one argument lets you "apply fewer arguments than are needed" and obtain a function for the remaining arguments.
08:34:38 <ski> > map ((+) 5) [3,8]
08:34:41 <lambdabot>  [8,13]
08:34:48 <ski> > map (5 +) [3,8]
08:34:50 <lambdabot>  [8,13]
08:34:56 <Zer0xp> The struggle to type that without the emoticon is real.
08:35:19 <ski> > map (max 3) [0 .. 9]
08:35:20 <Zer0xp> But thanks for the effort in making me understand.
08:35:25 <lambdabot>  mueval-core: Time limit exceeded
08:35:28 <int-e> > (:[]) 1
08:35:32 <lambdabot>  [1]
08:35:40 <ski> > map (max 3) [0 .. 9]  -- lambdabot, try harder !
08:35:45 <lambdabot>  [3,3,3,3,4,5,6,7,8,9]
08:35:51 <ski> @botsnack
08:35:51 <lambdabot> :)
08:36:30 <ski> > map (map (^ 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
08:36:35 <Zer0xp> So the bot doesn't evaluate all functions ? You have to ask it to try harder ?
08:36:36 <lambdabot>  [[],[0],[1,4],[9,16,25],[36,49,64,81]]
08:36:59 <ski> ^ that's some example of what gains writing in curried style can have
08:37:10 <ski> @help run
08:37:10 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
08:37:20 <ski> `> ...' is short for `@run ...', in lambdabot
08:37:28 <int-e> Sigh. It may be time to look for another VPS provider. (The running time for a single mueval, running all by itself, fluctuates between 2 seconds and 6 seconds (at which point the hard timeout kicks in.))
08:37:38 <merijn> int-e: Which one are you using now?
08:38:01 <int-e> ramnode currently
08:38:38 <ski> note the "3 seconds" part. if lambdabot is busy doing something else (like talking to OEIS about math sequences, perhaps), it may run out of time, and fail to complete your query
08:38:42 <ski> Zer0xp ^
08:38:57 <Zer0xp> Oh
08:39:12 <Zer0xp> The bot is running out of a VPS ?
08:39:14 <ski> (s/it/she/)
08:39:23 <int-e> Zer0xp: Yes.
08:39:51 <dminuoso> int-e: How much computing power are we talking about?
08:40:02 <int-e> (It's also a disgrace that mueval is so slow, but that would be fine if the runtime was more consistent. I can increase the timeout though.)
08:40:40 <Zer0xp> int-e: And you are the creator of the bot ?
08:41:09 <int-e> Zer0xp: No, I'm just running it at the moment.
08:41:38 <sicklorkin> int-e: iv'e got spare machine and bw if you need something
08:42:04 <sicklorkin> it's an old i7 32GB rab
08:42:05 <sicklorkin> ram
08:42:12 <int-e> dminuoso: It doesn't take much CPU power (you have those 2s bursts of activity). It needs 1G of memory to run smoothly.
08:42:27 <int-e> dminuoso: (which is a factor when looking at usual VPS plans)
08:43:36 <int-e> (Currently it has 2GB, which means I can actually (barely!) compile everything on the same VPS if required. But I suspect everything is fairly heavily overcommitted... hence the fluctuations.)
08:50:34 <AWizzArd> Is every type constructor of kind * -> * with a Functor implementation an endofunctor?
08:51:13 <dminuoso> AWizzArd: Functor is in fact short for "Endofunctor"
08:51:36 <dminuoso> AWizzArd: We just drop the "Endo" prefix since having non-endofunctors is not trivial in Haskell. :)
08:51:54 <AWizzArd> dminuoso: I see. So non-endofunctors do exist, in principle.
08:54:54 <dminuoso> AWizzArd: Type constructors are by design endofunctors. The reason for this is that they are type constructors parametrized over types.
08:55:09 <int-e> sicklorkin: I'm debating whether I want to go through the installation effort just for this... nuisance. I think I don't feel enough pain just yet.
08:56:25 <sicklorkin> int-e: no worries.. just let me know whenever the need arises and i'll see what I have kicking around..
08:56:46 <dminuoso> AWizzArd: So you have this shape of "taking types to types", which is why they are called endofunctors.
08:57:18 <AWizzArd> ic
08:57:36 <dminuoso> (And relatedly, taking functions to functions via `fmap` of course)
08:58:06 <halogenandtoast2> AWizzArd: I believe there is this https://hackage.haskell.org/package/categories-1.0/docs/Control-Categorical-Functor.html
08:59:02 <AWizzArd> halogenandtoast2: geez, that looks mathematical :-)
09:00:25 <dminuoso> AWizzArd: The entire package is about how to play Category Theory in Haskell.
09:00:29 <dminuoso> It's both a game and field in mathematics.
09:01:51 <AWizzArd> Why is there MonadPlus?
09:01:55 <AWizzArd> Why not just Monoid?
09:02:37 <AWizzArd> If pure&join already provide what is needed, then MonadPlus seems unnecessary.
09:02:43 <duncan> I have another question about QuickCheck. For a given test, I have a property to test, which is a boolean function, i.e. prop :: Int -> Int -> Property. I need to be able to generate test cases where one of the arguments is greater than zero, and one of them is less than zero. I can do it for one value with something like `prop x y = forAll (suchThat arbitrary (\x -> x > 0)) $ \ ...`...
09:02:57 <duncan> However it's not clear to me how I can put that constraint on the generaztion of the second value.
09:03:01 <int-e> AWizzArd: MonadPlus is a particular monoid that has laws about how it interacts with Monad.
09:03:13 <duncan> There doesn't seem to be a good way to combine different forAll declarations.
09:03:32 <dminuoso> AWizzArd: pure/join give you a monoid on a completely different level
09:03:33 <sicklorkin> duncan: Positive Negative
09:03:42 <sicklorkin> have a look at the newtype modifiers
09:03:52 <dminuoso> AWizzArd: Monoid would have been certainly a possible typeclass instead of MonadPlus.
09:04:25 <sicklorkin> duncan: https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck-Modifiers.html
09:04:36 <dminuoso> AWizzArd: https://wiki.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/558px-FunctorHierarchy.svg.png
09:05:01 <duncan> sicklorkin: Ah, that's really nice. That's just what I'm looking for. Thanks!
09:06:18 <dminuoso> AWizzArd: One interesting perspective is that MonadPlus gives you a sort of right-seminearring (in case you are familiar with the algebraic notion of rings)
09:11:06 <ski> dminuoso : type constructors need not be endofunctors
09:11:17 <dminuoso> ski: In Haskell?
09:11:22 <ski> yep
09:11:28 <int-e> AWizzArd: there's also the fact that MonadPlus is part of the Haskell 2010 report, whereas Monoid is not...
09:11:30 <dminuoso> ski: Oh I see what you are on about.
09:11:37 <dminuoso> ski: That was indeed poor phrasing by me.
09:11:59 <ski> (they needn't even be functions, except in a trivial sense, from a discrete category)
09:12:11 <ski> (er, s/functions/functors/. sorry)
09:12:25 <dminuoso> If a type constructor in Haskell is functorial, it is necessarily a an endofunctor.
09:12:26 <dminuoso> Is thi sbetter?
09:12:43 <ski> sorry, no
09:12:54 <dminuoso> Then I do not think I understand.
09:12:59 <ski> `MaybeT' is "functorial"
09:13:22 <dminuoso> % :t MaybeT
09:13:23 <yahb> dminuoso: ; <interactive>:1:1: error:; * Data constructor not in scope: MaybeT; * Perhaps you meant variable `maybe' (imported from Prelude)
09:13:27 <ski> @kind MaybeT
09:13:30 <lambdabot> error:
09:13:30 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
09:13:30 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
09:13:38 <dminuoso> Brb getting off the train.
09:13:49 <fragamus> I dont know how we ever got along without generic lens
09:14:04 <ski> @let import Control.Monad.Trans.Maybe
09:14:06 <lambdabot>  Defined.
09:14:09 <ski> @kind MaybeT
09:14:10 <lambdabot> (* -> *) -> * -> *
09:15:17 <ski> oh, sorry. i should have gone with my initial example (which i didn't write, because it's a little bit more involved to explain). `MaybeT' *is* an endofunctor
09:15:39 <ski>   newtype List f a = MkList (f (ListCell f a))
09:15:47 <nshepperd2> from * -> * to * -> *, heh
09:15:54 <ski> or, say
09:16:06 <ski>   newtype IntList f = MkList (f (IntListCell f))
09:16:12 <ski>   data IntListCell f = Nil
09:16:26 <ski>                      | Cons Int (IntList f)
09:17:16 <ski> you can write `forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> IntList f -> IntList g'
09:18:24 <ski> (in fact, you only need one of those two `Functor' constraints, because parametric polymorphism in Haskell yields (di)natural transformations)
09:19:17 <ski> (s/parametric polymorphic in Haskell/parametricity/ is perhaps more accurate)
09:20:02 <ski> anyway, `IntList' here is a functor from `{f :: * -> * | Functor f}' to `*'
09:20:09 <ski> iow, not an endofunctor
09:21:42 <ski> hm, perhaps a better example could be something like
09:22:28 <ski>   data Config f = MkConfig {name :: f String,path :: f FilePath,...}
09:23:19 <ski>   sequenceConfig :: Config Maybe -> Maybe (Config Identity)
09:37:24 <dminuoso> ski: Mmm
09:45:35 <Iceland_jack> Thinking of functoriality as a process: Associate each argument and result kind with an 'arrow' (Category)
09:45:35 <Iceland_jack>   Either :: Type -> Type -> Type
09:45:35 <Iceland_jack>             ^^^^    ^^^^    ^^^^
09:45:35 <Iceland_jack>             (->)    (->)    (->)
09:46:26 <Iceland_jack> We could for example associate it with
09:46:26 <Iceland_jack>   Either :: Type  -> Type -> Type
09:46:26 <Iceland_jack>             ^^^^^    ^^^^    ^^^^
09:46:26 <Iceland_jack>             (:~:)    (->)    (->)
09:47:13 <kaol> Interesting. I used cycle in my program (with a take further along, not actually passing an infinite list from the function). It works with ghci but in the compiled program it consumes all memory. I added another take and that behavior went away. Does that sound like a bug?
09:47:54 <Iceland_jack> That we associate with a mapping function
09:47:54 <Iceland_jack>  mapEither :: (a :~: a') -> (b -> b') -> (Either a b -> Either a' b')
09:47:54 <Iceland_jack>  mapEither Refl _ (Left  a) = Left  a
09:47:57 <Iceland_jack>  mapEither Refl f (Right b) = Right (f b)
09:50:16 <Iceland_jack> Any type constructor 'F :: k -> j' can be viewed as a FunctorOf (:~:) (:~:) F
09:50:16 <Iceland_jack>   F :: k     -> j     -> Type
09:50:17 <Iceland_jack>        ^^^^^    ^^^^^
09:50:17 <Iceland_jack>        (:~:)    (:~:)
09:50:19 <Iceland_jack> resulting in
09:50:37 <Iceland_jack> never mind the -> Type
09:50:46 <Iceland_jack>   mapF :: (a :~: a') -> (F a :~: F a')
09:51:04 <EvanR> kaol: you'd need to post some more specific steps you took to get that behavior for anyone to comment
09:51:53 <mniip> Iceland_jack, :~: is a subcategory of -> though
09:52:03 <mniip> discretization thereof
09:52:23 <kaol> I'll finish what I'm doing and then see about coming up with a smaller example.
09:53:08 <mniip> also there are stronger statements that you can make about GADTs than what discrete categories allows you to
09:54:44 <Iceland_jack> I could use good examples of GADTs-as-Functors
09:55:36 <mniip> I've had some developments regarding this in the past let me look it up
09:56:02 <Iceland_jack> yes please!
09:57:31 <Iceland_jack> code I just wrote: Tru | True <- f True -> Tru
09:57:48 * Iceland_jack *what even*
09:58:08 <EvanR> seems legit
10:00:10 <mniip> so ekmett argued that if you have a quatified type  forall a. ... (a :~: ...) ...
10:00:35 <mniip> then you can't really treat it as a profunctor Type^op x Type -> Type and take an end of it like you would with a normal haskell98 type
10:01:05 <mniip> instead you would have to consider a profunctor |Type|^op x |Type| -> Type where |C| = Disc(Ob(C))
10:01:51 <mniip> roughly stating the fact that (a :~: b) can be realized as a subcategory of (a -> b) if you only take the identity functions
10:02:08 <mniip> however you can do a slightly trickier construction
10:02:16 <Iceland_jack>  Tru | True  <- f True  -> Tru
10:02:16 <Iceland_jack>  Tru | False <- f True  -> Fls
10:02:16 <Iceland_jack>  Fls | True  <- f False -> Tru
10:02:16 <Iceland_jack>  Fls | False <- f False -> Fls 
10:02:19 <Iceland_jack> Sorry for the spam but it's a good aesthetic
10:03:58 <mniip> so if you have a category C let's construct a category EC with objects Ob(EC) = CxC, and morphisms Hom((a,b), (c,d)) = {* | a =/= b \/ c = d}
10:04:11 <bollu> What is `Disc` and `Ob` in the above?
10:04:33 <mniip> the object functor Ob : Cat -> Set, and its left adjoint Disc : Set -> Cat
10:04:50 <Cale> The discrete category on a set of objects
10:05:00 <Cale> i.e. it's the one with only the identity arrows, and no others
10:05:43 <mniip> EC would be a more correct description of morphisms involving  forall a b. ... (a :~: b) ...
10:05:48 <mniip> than |Type| x |Type|
10:05:58 <Iceland_jack> Can you realize EC in Haskell? data EC :: (Ob, Ob) -> (Ob, Ob) -> Type ..?
10:06:05 <mniip> I don't think so
10:06:11 <mniip> inequality is tricky
10:06:37 <bollu> Ah
10:06:57 <Iceland_jack> How should I understand the description of EC, how were those inequalities chosen?
10:08:12 <mniip> it's so that :~: is a functor from EC
10:08:23 <Iceland_jack> Hm. 
10:08:25 <mniip> when does  a:~:b -> c:~:d  exist ?
10:08:41 <mniip> when a=/=b or c=d
10:09:11 <Iceland_jack> Well it exists exactly when ((a~b) => (c~d))
10:09:34 <mniip> assume LEM :P
10:09:36 <Iceland_jack> so is -XQuantifiedConstraints a help here
10:09:41 <Iceland_jack> fine :) 
10:09:47 <mniip> -XQC is somewhat broken
10:09:55 <Cale> mniip: Well, those are the two trivial cases, but there may be dependency between a,b and c,d
10:10:06 <Cale> e.g. a:~:b -> [a]:~:[b]
10:10:13 <Iceland_jack> ^
10:10:18 <Iceland_jack> QC works well for me, but yes it is broken
10:10:22 <Iceland_jack> but it's broken in a nice way
10:10:36 <mniip> it was supposed to be Great but it wasn't
10:10:46 <Iceland_jack> H
10:10:47 <Cale> How is it broken?
10:10:55 <mniip> Cale, the statement you're trying to make is about naturality in a,b
10:11:03 <mniip> I'm talking about fixed values of a,b,c,d
10:11:17 <Cale> mniip: Well, fair enough :)
10:11:47 <Cale> I was just talking about types in a general context, which may involve variables, and where we might know arbitrary things about them
10:12:01 <mniip> Cale, you have to impose all the same restrictions on local implicational assumptions that you do on global instances or the typechecking doesn't terminate
10:12:03 <Cale> Not really trying to say anything categorical in nature
10:12:33 <mniip> hmm
10:12:38 <mniip> that reminds me about that paper
10:12:45 <mniip> bifibrational semantics of parametric polymorphism
10:13:11 <solonarv> "assume LEM" - in Haskell? perish the thought!
10:13:23 <mniip> types are functors |C|^|Gamma| -> C
10:13:26 <mniip> or something like that
10:13:33 <Cale> solonarv: It's provable :D
10:14:01 <solonarv> oh?
10:14:08 <solonarv> I don't count 'undefined' as a proof, btw :P
10:14:15 <mniip> type equality is not a decidable predicate in haskell
10:14:44 <mniip> or maybe it is
10:14:46 <Iceland_jack> mniip: It's forms an Category EC with QuantifiedConstraints
10:14:48 <mniip> depending on how you look at it
10:14:59 <mniip> hmm
10:15:03 <mniip> okay
10:15:17 <Iceland_jack> But you need a lot of acrobatics, because you can't constrain objects in Category
10:15:24 <Iceland_jack> and that you can't use type families in quantified constraints
10:15:27 <Iceland_jack> data EC :: Cat (k, k) where EC :: (a ~ Fst ab, b ~ Snd ab, c ~ Fst cd, d ~ Snd cd, (a~b) => (c~d)) => EC ab cd 
10:15:44 <mniip> sure
10:15:46 <Iceland_jack> instance Category EC where id = EC; EC . EC = EC 
10:16:10 <Cale> :t lem
10:16:12 <lambdabot> Either (a -> Void) a
10:16:28 * solonarv squints
10:17:00 <mniip> > either (const "L") (const "R") lem
10:17:02 <lambdabot>  "L"
10:17:24 <solonarv> what, is it just implemented as 'Left (const undefined)'
10:17:39 <Iceland_jack> this works also
10:17:39 <Iceland_jack>   test = EC :: EC '(a, b) '([a], [b])
10:17:42 <Cale> not quite :D
10:17:48 <mniip> > case lem of Left f -> f () `seq` ()
10:17:54 <lambdabot>  mueval-core: Time limit exceeded
10:18:18 <Cale> (but basically)
10:18:23 <Cale> I used fix id instead
10:18:29 <Iceland_jack> Which means.. test . test :: EC '(a, b) '([[a]], [[b]])
10:18:49 <Cale> Oh, I have an idea for a more fun one...
10:19:26 <mniip> Iceland_jack, I don't remember the details exactly but I think the next step is to consider EC f g h k a b c d = (f a ~ g b) => (h c ~ k d)
10:19:30 <mniip> or something stupid like that
10:19:36 <solonarv> Cale: fix error ?
10:19:44 <mniip> then you can talk about ends of profunctors EC^op x EC -> C
10:19:57 <Cale> solonarv: Mutual recursion between always successful and always unsuccessful LEMs
10:20:23 <Iceland_jack> oomp I was thinking Functors-of-GADTs like Expr or Fin or 
10:20:29 <mniip> in my formulation with disjunction the statements you got were basically typecases
10:20:43 <mniip> either a=/=b and then you treat :~: as Void, or c=d and you treat :~: as ()
10:20:54 <Iceland_jack> Right
10:20:56 <mniip> well uhh
10:21:05 <Iceland_jack> ^^
10:21:47 <mniip> I want to learn enough CT one day to understand the current landscape wrt parametric polymorphism and category theory
10:21:56 <mniip> cause fitting GADTs into the picture sounds like an interesting problem
10:22:15 <mniip> and as far as I know an unsolved one
10:22:23 <Cale> er, I shouldn't be spending time on this
10:22:24 <Cale> lol
10:23:18 <mniip> I should be studying :(
10:23:21 <Iceland_jack> You can define something like
10:23:22 <Iceland_jack>   mapExp :: (a -> a) -> (Exp a -> Exp a)
10:23:22 <Iceland_jack>   mapExp f = \case Int  n -> Int  (f n)
10:23:22 <Iceland_jack>                    Bool b -> Bool (f b)
10:24:13 <Iceland_jack> and with more advanced source categories I have found some interesting applications for FunctorOf _ (->) Exp
10:27:38 <Iceland_jack> I think 
10:27:39 <Iceland_jack>   subst :: Exp ctx a -> Exp (a:ctx) b -> Exp ctx b
10:27:39 <Iceland_jack> from glambda (https://github.com/goldfirere/glambda/blob/master/src/Language/Glambda/Shift.hs) can be thought of as fmap
10:43:54 <kaol> EvanR: https://pastebin.com/YXewNzEa
10:44:21 <orion> General survey question: Of the people who use Haskell with a relational database in production, how many write raw queries, and how many use something like persistent or esqueleto?
10:45:00 <kaol> I use raw queries (with hasql).
10:45:18 <saml> i use raw queries (with python)
10:45:56 <mniip> a mix but mostly raw queries with quasiquoters
10:46:29 <sicklorkin> orion: esqueleto
10:47:05 <orion> sicklorkin: Are you using sqlite, postgresql, or something else?
10:47:26 <sicklorkin> orion: connecting to sqlite and MsSql
10:49:41 <orion> sicklorkin: Are there features in mssql that you can't use because esqueleto doesn't support it?
10:49:53 <orion> (And that you want to use)
10:50:42 <sicklorkin> orion: i have one raw query 'cause there are a few tricks to querying millions of records w/tmp tables.. but otherwise I just had to add support for LOCKs and such.. that's all upstream now
10:51:19 <orion> Oh cool, thank you for your service.
10:51:20 <sicklorkin> orion: i would never suggest using MSSQL
10:51:50 <orion> I'm a postgres guy.
10:52:32 <sicklorkin> orion: I fully understand that choice..
10:55:15 <sicklorkin> orion: i'm also using ODBC and hav eno idea what the state of the native postgres driver is
10:56:07 <sicklorkin> I know that all datatypes are supported though, MSSQL has about 70% implemented
11:44:29 <Boarders> Is there any particular reason why haskell tends to mainly use Int to index into a structure as opposed to Word?
11:45:12 <merijn> Boarders: Historical reasons combines with "Word is really annoying when you want to do arithmetic"
11:45:28 <mniip> is Word even in the 98 standard
11:45:47 <Boarders> why is Word annoying for arithmetic, just because of the Num typeclass or something more fundamental?
11:46:14 <mniip> there's no negative numbers
11:46:16 <glittershark> overflow?
11:46:17 <glittershark> yeah
11:46:18 <glguy> Boarders: Word has just as many invalid indexes for most case as Int but hides more mistakes
11:46:37 <Boarders> glguy: how so?
11:46:42 <glittershark> !(0 :: Word) - 1
11:46:45 <glittershark> er
11:46:52 <glittershark> > (0 :: Word) - 1
11:46:54 <lambdabot>  18446744073709551615
11:46:58 <glittershark> not ideal
11:47:48 <merijn> underflow, but yes
11:47:51 <mniip> if you have a list of particular length (<2^31) then it doesn't matter whether yiu index with Int or Word
11:48:17 <Boarders> yes, I understand
11:48:26 <mniip> negative indices will go into very large indices and will still be invalid
11:50:07 <cocreature> "[0 .. n - 1]" is a particularly common error when you use Word as indices
11:52:03 <Boarders> that seems more something to do with Enum than indexing
11:53:34 <cocreature> not really the issue is that 0 - 1 will overflow
11:53:39 <cocreature> Enum can’t do anything about that
11:54:09 <Boarders> well by indexing I mean like the Key from the keys library
11:54:28 <Boarders> so I mean the type sig of ! 
11:54:42 <Boarders> what you have written desugars to enumFromTo 0 (n - 1)
11:55:07 <Boarders> so I don't see it as directly in line with indexing per se
11:55:19 <cocreature> I guess I was more thinking of vectors
11:56:12 <cocreature> and then [0 .. n - 1] is a very natural thing to write if you want to iterate over indices (ofc you can often get away with higher-level functions that avoid that issue)
11:56:39 <Boarders> yeah that makes sense
11:58:44 <monochrom> > let n=0 in [0 .. n-1] :: [Word8]
11:58:49 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:58:53 <monochrom> \∩/
12:03:30 <mniip> init [0 .. n]
12:03:55 <monochrom> Hrm that's interesting.
12:04:06 <merijn> With v2-build how can I add a lower bound for a dependency somewhere in the dependency graph?
12:04:46 <monochrom> > let n=256 in init [0 .. n] :: [Word8]
12:04:49 <lambdabot>  []
12:04:53 <monochrom> >:)
12:05:14 <mniip> n=0 though
12:05:18 <monochrom> I guess [0..n-1] doesn't fare well either.
12:05:20 <mniip> I don't see a problem
12:05:38 <mniip> if you want a vector of length 256 then you can't store the length in a Word8
12:05:40 <monochrom> > let n=256 in init [0 .. n-1] :: [Word8]
12:05:46 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:25:09 <orion> Is there a function in base that looks like: Monad m => (m a, m b) -> m (a, b) ?
12:25:22 <orion> Or do I have to use a list instead?
12:25:49 <merijn> :t uncurry (liftA2 (,))
12:25:52 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
12:25:57 <merijn> boom
12:27:16 <orion> Thank you, merijn.
12:27:49 <cocreature> :t bisequence :: Applicative f => (f a, f b) -> f (a, b)
12:27:50 <lambdabot> error:
12:27:51 <lambdabot>     • Variable not in scope:
12:27:51 <lambdabot>         bisequence :: (f1 a1, f1 b1) -> f1 (a1, b1)
12:27:57 <cocreature> % import Data.Bifunctor
12:27:57 <yahb> cocreature: 
12:28:00 <cocreature> % :t bisequence :: Applicative f => (f a, f b) -> f (a, b)
12:28:01 <yahb> cocreature: ; <interactive>:1:1: error:; * Variable not in scope: bisequence :: (f1 a1, f1 b1) -> f1 (a1, b1); * Perhaps you meant one of these: `sequence' (imported from Prelude), `sequence_' (imported from Prelude), `sequenceA' (imported from Prelude)
12:28:08 <cocreature> % import Data.Bitraversable
12:28:09 <yahb> cocreature: 
12:28:10 <cocreature> % :t bisequence :: Applicative f => (f a, f b) -> f (a, b)
12:28:10 <yahb> cocreature: Applicative f => (f a, f b) -> f (a, b)
12:28:21 <cocreature> ^ orion if you want it even shorter :)
12:28:36 <orion> Oh, nice.
12:30:37 <cocreature> orion: fwiw, hoogle actually works here quite nicely https://hoogle.haskell.org/?hoogle=Applicative%20f%20%3D%3E%20(f%20a%2C%20f%20b)%20-%3E%20f%20(a%2C%20b)
12:31:38 <orion> This is the query I used before asking here: https://www.stackage.org/lts-13.28/hoogle?q=%28m+a%2C+m+b%29+-%3E+m+%28a%2C+b%29&exact=on
12:32:41 <cocreature> hm maybe that’s still the old hoogle 4
12:43:51 <dmwit> % :t traverse @Pair -- in case you would actually be okay with (m a, m a) -> m (a, a)
12:43:51 <yahb> dmwit: Applicative f => (a -> f b) -> Pair a -> f (Pair b)
12:43:58 <dmwit> % :i Pair
12:44:00 <yahb> dmwit: data Pair a = Pair {pFst :: a, pSnd :: a} -- Defined in `Pair'; instance Applicative Pair -- Defined in `Pair'; instance Functor Pair -- Defined in `Pair'; instance (Semigroup a, Monoid a) => Monoid (Pair a) -- Defined in `Pair'; instance Semigroup a => Semigroup (Pair a) -- Defined in `Pair'; instance Traversable Pair -- Defined in `Pair'; instance Foldable Pair -- Defined in `Pair'
12:44:24 <dmwit> Oh, well, sequence instead of traverse. But you get the idea.
13:28:20 <solonarv> @tell merijn https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-constraints
13:28:20 <lambdabot> Consider it noted.
13:28:44 <solonarv> @tell merijn goes in your cabal.project file, note that you can also specify flags that way
13:28:45 <lambdabot> Consider it noted.
14:09:24 <jgt> I'm trying to get a Bool out of a nested JSON object, with: conversionData conversion ^. key "billing_details" . key "paperless_billing" . _Bool
14:09:36 <jgt> it's failing with" No instance for (Monoid Bool) arising from a use of ‘key’
14:09:57 <jgt> why would that be? I'm able to pull strings out of the same level of nesting with _String
14:11:53 <jgt> I'm using lens-aeson, if that wasn't clear
14:12:09 <solonarv> jgt: this is a traversal, not a lens
14:12:19 <solonarv> which means it may have 0, 1, or many results
14:12:36 <solonarv> these need to be combined somehow - that's where the Monoid constraint comes from
14:13:53 <solonarv> you probably don't want to use ^. , but instead use ^? which gives you Nothing if there was no result, or Just the first result if there were many
14:17:45 <jgt> solonarv: ah, that makes sense. Thanks!
14:21:01 <solonarv> (and of course String is a monoid, and you were probably testing on nice input data, and this particular traversal can't actually find more than one target)
14:21:17 <jgt> yeah that's accurate
14:21:22 <solonarv> so you didn't notice this when you were getting a String
14:29:16 <dmwit> % :t key
14:29:16 <yahb> dmwit: ; <interactive>:1:1: error:; * Variable not in scope: key; * Perhaps you meant one of these: `M.keys' (imported from Data.Map), `IM.keys' (imported from Data.IntMap)
14:29:24 <dmwit> % import qualified Control.Lens as L
14:29:25 <yahb> dmwit: 
14:29:28 <dmwit> % :t L.key
14:29:28 <yahb> dmwit: ; <interactive>:1:1: error:; Not in scope: `L.key'; No module named `L' is imported.
14:30:05 <dmwit> :t (L.^.)
14:30:06 <lambdabot> error:
14:30:06 <lambdabot>     Not in scope: ‘L.^.’
14:30:07 <lambdabot>     No module named ‘L’ is imported.
14:30:15 * dmwit facepalms and takes it top privmsg
14:32:35 <EvanR> PRIVMSG, the thing that sends to public channels (or directly to users) haha
14:32:59 <solonarv> key :: (FromJSON v, ToJSON v') => Text -> Traversal Value Value v v'
14:33:10 <solonarv> btw I don't think lambdabot has lens-aeson anyway
14:33:12 <solonarv> dmwit: ^
14:53:42 <Boarders> I was told that System.Random is terribly slow and so I switch over to System.Random.MWC and in all tests this produced even slower results
14:54:01 <Boarders> is it the case that indeed System.Random is not very fast or just that MWC did not fit my purpose or?
14:57:20 <EvanR> there could be many reasons for the slowness unrelated to the RNG
14:57:36 <Boarders> I swapped out equal implementations
14:57:47 <Boarders> it could be hardly anything else than that
14:58:31 <EvanR> by rng i guess i mean the core formula used
14:59:58 <EvanR> i think many haskell rng libs do their own thing and don't adhere to the System.Random interface
15:00:48 <EvanR> also make sure you compile with optimizations
15:04:58 <Boarders> could someone tell me with cabal how to build the tests with -O2
15:05:39 <solonarv> just pass -O2 to cabal
15:05:42 <solonarv> that should do it
15:06:50 <Boarders> ah, thank you
16:12:52 <BoredTeen98> Hi all. I will go Live in a few minutes. I can send 2 Free invitations for my Private Live. Be among the fastest and get one of the invitations. Enter the site and write in the chat "Free Invite", so I can send it to you::: https://cutl.xyz/g4xv15Ee
16:49:17 <janat08> Is this haskell or belisk question: https://stackoverflow.com/questions/56951959/cant-install-packages-to-nix-build-project? I don't think obelisk is in hackage.
16:57:48 <jackdk> I'm about to dash out but there's not enough information there. Sounds like a reflex-platform thing, maybe?
16:58:27 <jackdk> I haven't used obelisk but I would imagine you'd use its ob commands instead of calling nix-build etc directly
16:58:29 <jackdk> okay, gotta run
16:59:52 <boj> janat08: obelisk is not a hackage thing - https://github.com/obsidiansystems/obelisk
17:07:54 <fred-fri> I'm stuck on a simple type question... I have a List<Either<Error, User>> and I need to turn it into Either<(the first) Error, List<User>>. Easy enough to do imperatively but there should be some declarative functional way to do it...
17:12:44 <boj> are you stuck on the type, or how to process the list to get your desired result?
17:14:08 <fred-fri> how to process it
17:14:24 <fred-fri> actually i think this would be trivial with a fold, maybe that's what i need to do
17:14:39 <boj> give it a shot and see what you come up with :)
17:14:45 <EvanR> maybe sequence is the answer
17:14:49 <wildtrees> you might not have any errors 
17:15:15 <EvanR> if there are no errors, that is when you get a list of users
17:15:41 <fred-fri> i mean i could filter the original list of either error user, see if the result has the same size in which case i can just make a list of all the users
17:15:48 <fred-fri> but this feels imperative
17:16:15 <wildtrees> @type either 
17:16:17 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
17:16:33 <wildtrees> oh that could work with a sum type 
17:16:38 <EvanR> convince yourself that sequence has the type [Either Error User] -> Either Error [User]
17:17:04 <fred-fri> my brain XD
17:32:06 <fred-fri> right so this is the fold version, it's pretty hard to read
17:32:09 <fred-fri> https://pastebin.com/UsXWKrwD
17:32:51 <EvanR> especially since this is not haskell 
17:34:06 <EvanR> for edumucation purposes try writing the answer using fold in haskell
17:34:20 <EvanR> then see my previous answer
17:35:41 <EvanR> you can also look at an implementation of my answer with @src sequence (in a PM)
17:35:47 <EvanR> with lambdabot
17:38:31 <fred-fri> I'm trying to push for Haskell at work but so far have only been able to get takers on Kotlin with Arrow (a Haskell-y library), which does get clos*er* than regular Java
17:39:05 <EvanR> pushing haskell would probably work better if you knew haskell ;)
17:39:31 <fred-fri> Maybe, but part of the fun is learning it together and starting small
17:39:53 <fred-fri> We're never going to hire someone who knows Haskell already
17:40:08 <fred-fri> and no one who knows Haskell already would want to work for a Java shop anyway lol
17:40:32 <EvanR> a broke one might
17:40:48 <fred-fri> anyhow, I'm reading up on Sequence but struggling to piece together how to do it using Sequence, any hints?
17:41:07 <EvanR> sequence lower case, i'm not sure what Sequence is in kotlin
17:41:17 <fred-fri> I doubt a Haskell verison of the fold would be much more readable, the solution would be fundamentally exactly the same, only the syntax would differ
17:41:36 <xyggos> Syntax matters.
17:42:06 <EvanR> i can't decide if this challenge should be accepted
17:42:50 <EvanR> fred-fri: i suggested sequence because it does exactly what you asked, and would look like this <code>sequence myListOfErrorsOrUsers</code>
17:43:07 <EvanR> > sequence [Right 1, Right 2, Right 3]
17:43:10 <lambdabot>  Right [1,2,3]
17:43:19 <EvanR> > sequence [Right 1, Left "error!!!", Right 3]
17:43:22 <lambdabot>  Left "error!!!"
17:44:19 <EvanR> so the answer is either, yes the implementation of this method with a foldr would look a lot smaller, or it doesn't matter because its already a function in haskell
17:44:42 <EvanR> when you doubt haskell you haskell your doubts!
17:44:48 <fred-fri> EvanR ah I was reading around on https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html but you're referring to the library function sequence
17:45:04 <fred-fri> I'm dense, patience required
17:45:11 <EvanR> ah yes, Data.Sequence is a data structure, unrelated
17:49:57 <EvanR> another thing, algorithms in haskell are going to look a lot different than kotlin unless I google it and find that kotlin is a lazy-by-default language
17:50:09 <fred-fri> it's not lazy by default
17:50:43 <fred-fri> kotlin itself isn't that great tbh, it's really just sugar on top of java, everything else fundamentally the same, strong bias towards imperative stateful style with all that entails etc
17:50:59 <fred-fri> but with arrow you can approximate functional style a lot more
17:51:27 <EvanR> on this front, in my town people are pushing for clojure more
17:51:46 <EvanR> the how to stand java front
17:55:10 <fred-fri> types dho
17:55:58 <EvanR> yes...
17:59:58 <EvanR> in your kotlin version, will your fold stop early when it finds an error
18:04:27 <fred-fri> Doesn't that make sense though? It will evaluate to a Left<the error>
18:06:13 <EvanR> yes it makes sense, but does your fold thing have an early stopping condition 
18:06:35 <EvanR> or will it try to combine everything past the first error, getting the first error every time
18:06:52 <EvanR> same result but worse performance
18:10:10 <fred-fri> yeah it will keep going and pick the last error which isn't great
18:10:47 <fred-fri> since it didn't come out that well i'm not actually going to use it, just wanted to implement it as a little exercise
18:10:47 <EvanR> even if you got it to pick the first error, not being able to quit earlier isn't great
18:10:53 <fred-fri> true
18:11:08 <fred-fri> i'm researching whether kotlin has a sequence function but even if it does it's cheating for exercise purposes
18:11:26 <fred-fri> so what's the haskell way of exiting a fold early
18:11:39 <EvanR> well, foldr allows this by being a right fold
18:12:10 <EvanR> each step it consumes 1 item from the lazy list
18:12:28 <EvanR> it can yield something any time, or continue consuming
18:12:56 <EvanR> so it can even work on infinite lists
18:13:30 <EvanR> (but after some thought you could see that the "find the first error" can not work on an infinite list)
18:14:52 <fred-fri> right, in this case it didn't really matter, it's basically give me either "any error"/"first encountered error irrespective of order" or the list of users
18:15:55 <EvanR> yeah so the best you can do here is to quit building a list if you find an error, otherwise look at the entire list of users before returning
18:17:51 <EvanR> an arguably simpler thing to do is separate the list into two lists, one list of errors another list of users
18:18:31 <EvanR> > partition isRight [Right 1, Right 2, Left "ERROR!", Right 4]
18:18:33 <lambdabot>  ([Right 1,Right 2,Right 4],[Left "ERROR!"])
18:18:37 <EvanR> hmm...
18:20:53 <dmwit> > sequence (Right 1:Right 2:Left "ERROR!":error "if sequence evaluates any part of the list past the Left you will see this exception")
18:20:55 <lambdabot>  Left "ERROR!"
18:21:25 <EvanR> > partitionEithers [Right 1, Right 2, Left "ERROR!", Right 4]
18:21:25 <dmwit> Or have I misunderstood the question?
18:21:27 <lambdabot>  (["ERROR!"],[1,2,4])
18:21:40 <EvanR> you got it dmwit. 
18:21:44 <dmwit> Do you want Left "ERROR!" or Right [1,2]?
18:22:23 <dmwit> :t foldM
18:22:25 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
18:22:25 <EvanR> i was just side tracking into a realm where you want all the errors
18:23:30 <EvanR> > paritionEithers (cycle [Right "user", Left "error"]) -- which should also allow streaming the processing...
18:23:33 <lambdabot>  error:
18:23:33 <lambdabot>      • Variable not in scope:
18:23:33 <lambdabot>          paritionEithers :: [Either [Char] [Char]] -> t
18:23:44 <EvanR> > partitionEithers (cycle [Right "user", Left "error"]) -- which should also allow streaming the processing...
18:23:46 <lambdabot>  (["error","error","error","error","error","error","error","error","error","e...
18:23:56 <dmwit> > foldM (\vs e -> case e of Right v -> Right (v:vs); Left _ -> Left vs) (Right []) [Right 1, Right 2, Left "ERROR!", Right 4]
18:23:59 <lambdabot>  error:
18:23:59 <lambdabot>      • Couldn't match expected type ‘[a]’
18:23:59 <lambdabot>                    with actual type ‘Either a0 [a1]’
18:24:07 <dmwit> oops
18:24:15 <dmwit> > foldM (\vs e -> case e of Right v -> Right (v:vs); Left _ -> Left vs) [] [Right 1, Right 2, Left "ERROR!", Right 4]
18:24:19 <lambdabot>  Left [2,1]
18:24:30 <EvanR> yeah at this point were making a balls of it
18:24:46 <dmwit> This gets you the [1,2] if you want that instead. =)
18:25:11 <dmwit> ski showed me this trick.
18:29:24 <Zer000> I need a f :: Maybe a -> Maybe b -> Maybe (a, b)
18:29:43 <Axman6> @hoogle Maybe a -> Maybe b -> Maybe (a, b)
18:29:44 <lambdabot> Control.Concurrent.Async.Lifted concurrently :: MonadBaseControl IO m => m a -> m b -> m (a, b)
18:29:45 <lambdabot> Control.Concurrent.Async.Lifted.Safe concurrently :: forall m a b . (MonadBaseControl IO m, Forall (Pure m)) => m a -> m b -> m (a, b)
18:29:45 <lambdabot> Control.Invertible.Monoidal pairADefault :: Applicative f => f a -> f b -> f (a, b)
18:30:00 <Axman6> I forgot hoogle isn't very smart.
18:30:19 <Axman6> Zer000: do you know about Applicative?
18:30:40 <Zer000> Kind of? I know fmap == <$>
18:31:05 <Axman6> well that's Functor, Applicative introduces <*>:
18:31:10 <Axman6> :t (<*>)
18:31:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:31:13 <Zer000> oh my bad
18:31:36 <Zer000> :t fmap
18:31:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:31:43 <Axman6> that doesn't looj very useful, but I can give you some hints
18:31:46 <Axman6> :t (,)
18:31:48 <lambdabot> a -> b -> (a, b)
18:32:01 <Axman6> :t fmap (,)
18:32:03 <lambdabot> Functor f => f a -> f (b -> (a, b))
18:32:47 <Axman6> that doesn;t look all that useful, but its result has the shape we need for <*>, f (a -> b)
18:33:18 <Axman6> (Where b is actually (a,b))
18:33:36 <Axman6> :t fmap (,) Just True
18:33:40 <lambdabot> b -> (Maybe Bool, b)
18:33:44 <Axman6> :t fmap (,) (Just True)
18:33:46 <lambdabot> Maybe (b -> (Bool, b))
18:34:01 <Axman6> :t (fmap (,) (Just True) <*>)
18:34:02 <lambdabot> Maybe a -> Maybe (Bool, a)
18:34:45 <Zer000> :t (fmap (,) (Just True)) <*> Just "asdf"
18:34:47 <lambdabot> Maybe (Bool, [Char])
18:34:49 <Zer000> nice
18:34:54 <EvanR> Zer000: the final answer to this may amaze you
18:35:06 <Axman6> :t \ma mb -> fmap (,) ma <*> mb)
18:35:08 <lambdabot> error: parse error on input ‘)’
18:35:12 <Axman6> :t (\ma mb -> fmap (,) ma <*> mb)
18:35:13 <lambdabot> Applicative f => f a1 -> f a2 -> f (a1, a2)
18:35:30 <Axman6> as you said earlier, ($) = fmap, so you can instead write:
18:35:40 <Axman6> :t (\ma mb -> (,) <$> ma <*> mb)
18:35:42 <lambdabot> Applicative f => f a1 -> f a2 -> f (a1, a2)
18:35:58 <Axman6> if you need to put three things into a three-tuple:
18:36:12 <Axman6> :t (\ma mb mc -> (,,) <$> ma <*> mb <*> mc)
18:36:15 <lambdabot> Applicative f => f a1 -> f a2 -> f a3 -> f (a1, a2, a3)
18:36:32 <Axman6> there are also the functions liftAN:
18:36:36 <Axman6> :t liftA2
18:36:38 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:36:38 <Axman6> :t liftA3
18:36:40 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
18:36:41 <Axman6> :t liftA4
18:36:43 <lambdabot> error:
18:36:43 <lambdabot>     • Variable not in scope: liftA4
18:36:43 <lambdabot>     • Perhaps you meant one of these:
18:36:47 <Axman6> uwot
18:36:57 <EvanR> not sure if liftA4 exists
18:37:19 <EvanR> so basically... liftA2 (,)
18:38:14 <Axman6> well that's fune, because liftA(N) f ma .. mn-1 mn = liftA(N-1) f <*> mn
18:38:37 <jackdk> yeah so if you have Applicative you can get any liftA(N)
18:38:57 <jackdk> fmap is kinda like a lift1, and pure (also from Applicative) is like a lift0
18:39:45 <Axman6> :t pure
18:39:47 <Axman6> :t fmap
18:39:48 <lambdabot> Applicative f => a -> f a
18:39:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:39:53 <Axman6> :t liftA2
18:39:56 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:39:58 <Axman6> :t liftA3
18:40:00 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
18:40:14 <Zer000> that's pretty cool! Thanks for explaining that guys
18:41:02 <EvanR> Applicative when you don't need Monad FTW
18:55:07 <dmwit> alias cba='cabal v2-build all' was the greatest decision I ever made
18:56:48 <glguy> That's an interesting upper-bound
18:58:36 <dmwit> I am sad that `[a,b,c,d] <- mapM f [e,f,g,h]` incurs a MonadFail constraint.
18:58:38 <dmwit> What can I do?
18:58:50 <dmwit> mapM f [e,g,h,i], ok
18:58:51 <glguy> add a ~?
18:59:03 <dmwit> Oh yeah??
18:59:38 <dmwit> Oh yeah!!
18:59:52 <dmwit> loophole
19:08:44 <monochrom> Yikes haha loophole, probably intentional too.
19:10:49 <glguy> Yeah, it's intentional
19:13:19 <jackdk> use a tuple?
19:13:54 <monochrom> Don't use a tuple.
19:16:08 <dmwit> jackdk: How?
19:17:07 <jackdk> er, brainfart. sorry. if you use each from lens or whatever you're gonna get a list anyway, hey?
19:17:13 <dmwit> % :t \f -> do { [x,y,z] <- mapM f [1,2,3]; return x }
19:17:13 <yahb> dmwit: (Monad m, Num a) => (a -> m b) -> m b
19:17:25 <dmwit> yahb: You're living in the past!
19:18:04 <dmwit> I guess I could `data Four a = Four a a a a deriving (Foldable, Traversable)` and `Four a b c d <- mapM f (Four e g h i)`.
19:18:10 <dmwit> Perhaps GHC is smart enough to know this pattern cannot fail.
19:19:27 <dmwit> (Seems it is smart enough, yes.)
19:19:47 <dmwit> I'm not going to do that, though.
19:20:51 <dmwit> ?unmtl StateT s m a
19:20:51 <lambdabot> s -> m (a, s)
19:21:03 <Nolrai> Can you define operators as pattern synonyms?
19:21:32 <jackdk> Nolrai: yes: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Cons.html#v::-62- 
19:22:46 <Nolrai> Ah, that syntax makes sense.
19:22:49 <Nolrai> Thanks!
20:15:24 <Nevoic> Is there any common idiom in Haskell to represent an abstraction layer? I've been creating `data` that holds a list of methods (pretty much akin to an interface) and then "implementing" that interface by just making a function that returns that type.
20:15:43 <Nevoic> I.E `data UsersDatastore` and `usersJSON = UsersDatastore { .. }`
20:15:53 <Nevoic> Is it more common to use typeclasses for this type of thing?
20:16:02 <Nevoic> or some other pattern?
20:16:37 <fred-fri> Nevoic is the purpose to be able to swap out implementations at runtime?
20:17:40 <Nevoic> That's one of the benefits. Readability and decoupling are pretty big benefits as well.
20:17:51 <Nevoic> I don't want to have ties to JSON in my web code, for example.
20:18:02 <Nevoic> Rather just have it require a "Userstore"
20:20:28 <lyxia> I think record-of-functions is a fine way to do things.
20:20:46 <lyxia> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
20:22:54 <Nevoic> Cool. I didn't really like typeclasses because I needed to have it "over" something if that's how you describe that.
20:22:58 <Nevoic> i.e UsersDatastore a
20:23:18 <Nevoic> and that "thing" pretty much was just like self/this which wasn't necessary for the type of abstractions I was doing.
21:21:02 <Nevoic> Another random question, what's the reason that all the functions that mimic traditional imperative concepts have odd character sequences after it? Is it primarily to deter beginners?
21:22:18 <Nevoic> I.E someone who isn't familiar with Haskell would understand:
21:22:18 <Nevoic> while (1 < 2) $ do
21:22:18 <Nevoic> but they wouldn't understand whileM_ (1 < 2) 
21:23:11 <Nevoic> I realize the difference between whileM and whileM_ (same with forM and forM_), but wouldn't for and for_ be more clear? Or does the `M` have some meaning that's lost to me?
21:23:20 <sarahzrf> monad, in theory
21:23:55 <sarahzrf> the underscore has a convention of meaning "and also we don't care about the results, only the effects"
21:24:04 <Nevoic> Are there other types of `for` that aren't over a monad?
21:24:07 <sarahzrf> compare the types of forM and forM_
21:24:11 <Nevoic> like a forT or forR?
21:24:13 <sarahzrf> yeah, that's a reasonable point :)
21:24:20 <sarahzrf> don't ask me!
21:25:03 <Nevoic> Plus `forM` doesn't really seem to be over a Monad. It's "over" a traversable.
21:25:19 <sarahzrf> the M refers to the fact that the thing you're mapping produces an action in a monad
21:25:30 <sarahzrf> the for is in a monad,
21:25:36 <sarahzrf> not "over" one
21:25:36 <Nevoic> hmm
21:26:09 <sarahzrf> it may just be for symmetry with mapM
21:26:13 <sarahzrf> since it's a flipped version of mapM
21:26:30 <Nevoic> How does mapM differ from fmap?
21:26:35 <sarahzrf> :t mapM
21:26:37 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
21:26:38 <sarahzrf> :t fmap
21:26:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:27:11 <Nevoic> :t map
21:27:14 <lambdabot> (a -> b) -> [a] -> [b]
21:27:53 <sarahzrf> you actually only need applicative for mapM
21:28:03 <sarahzrf> but i think it was invented so early that it was before applicatives were popular
21:29:06 <Nevoic> TBH I have a love/hate relationship with Haskell.
21:29:24 <Nevoic> I love its conciseness and syntax, but sometimes the std lib just vibe with me.
21:29:29 <Nevoic> doesn't
21:29:32 <Nevoic> just doesn't vibe with me*
21:29:43 <sarahzrf> use it more? :)
21:30:46 <Nevoic> Idk if usage is the issue. I don't know if `forM_` will ever feel as clean as `for`. Or like how `head` returns an `a` instead of `Maybe a` like Elm.
21:31:02 <Nevoic> I also don't like how general functions have more specific names than their less general counterparts (fmap vs map for example)
21:31:19 <Nevoic> fmap should be a type of map, as it's a "functor map" and map is a map.
21:31:23 <Nevoic> But that's not the case.
21:31:55 <sarahzrf> oh sure, those last 2 things are gross
21:32:43 <Nevoic> I've talked with haskellers that like that `map` is specific to lists. Shrug
21:32:52 <Nevoic> It used to not be, it was like an explicit to change that.
21:32:57 <Nevoic> `map` used to be on functor iirc
21:33:07 <sarahzrf> i don't think that's true
21:34:13 <Nevoic> "What happened was that the type of map was generalized to cover Functor in Haskell 1.3. I.e., in Haskell 1.3 fmap was called map. This change was then reverted in Haskell 1.4 and fmap was introduced."
21:34:28 <Nevoic> https://stackoverflow.com/questions/6824255/whats-the-point-of-map-in-haskell-when-there-is-fmap#comment-8112310
21:35:01 <sarahzrf> oh huh
21:35:46 <sarahzrf> well it's not like they started the other way, then
21:37:53 <dogydogedoger> hello
21:40:55 <xacktm> hi
21:41:40 <dogydogedoger> Every channel I join seems dead.. Am I doing something wrong?
21:42:00 <dogydogedoger> Should I be using SSL or something?
21:44:02 <Axman6> it’s probably just the time of day. do you have a question about Haskell?
21:45:23 <dogydogedoger> I just saw this channel recommended online for it's friendly community. What is the purpose of this channel?
21:46:48 <dogydogedoger> Thanks for the response btw
21:47:36 <Axman6> to talk about the the Haskell programming language
21:48:03 <dogydogedoger> oh ok cool. Thanks.
21:51:08 <Axman6> farewell...
21:55:11 <slack1256> Sometimes I want to encode invariants as a newtype with a smart constructor that checks it, but I don't like adding modules to a project just for that. Is there some TH magic that gives me namespaces?
21:59:59 <nolrai> !pl ($ seconds) <?> streamf
22:00:43 <nolrai> :pl ($ seconds) <?> streamf
22:00:47 <sarahzrf> nolrai: it's @pl
22:01:21 <nolrai> @pl ($ seconds) <?> streamf
22:01:21 <lambdabot> ($ seconds) <?> streamf
22:01:57 <nolrai> @pl ($ seconds) <$> streamf
22:01:57 <lambdabot> ($ seconds) <$> streamf
22:03:19 <sarahzrf> :t (<&>)
22:03:21 <lambdabot> Functor f => f a -> (a -> b) -> f b
22:03:38 <sarahzrf> % :i (<&>)
22:03:38 <yahb> sarahzrf: (<&>) :: Functor f => f a -> (a -> b) -> f b -- Defined in `Data.Functor'; infixl 1 <&>
22:04:01 <sarahzrf> oh wait thats not the right thing
22:19:22 <hvim> dminuoso ski: So I manged to fix the 'get' and 'put' definitions I asked about yesterday, turns out it was enough to leave the '.' out of the 'get' definition so now it's 'get = lift get' I presume this is because 'get' in State monad returns a value which is passed to the 'lift' function to make it the transformed monad. The other definition is 'put = lift . put' in this case looks like 'put' returns a 
22:19:28 <hvim> function s -> m () so I guess that one has to be composed with 'lift' instead of being passed to it as a value. I found it out looking at the MaybeT MonadState instance decalration in docs. 
22:20:56 <gabbiel> why isn't foldl (+) 0 the same as foldl' (+) 0
22:21:18 <gabbiel> since (+) is strict, there shouldn't be an accumulation 
22:26:21 <nnnxx> hello how do i use optparse-applicative to take atleast one of several options
22:29:47 <c_wraith> gabbiel: (+) being strict isn't relevant unless something requires it to be evaluated.
22:30:16 <c_wraith> gabbiel: strict only means that if it's evaluated, so are its arguments.
22:30:22 <c_wraith> gabbiel: *if* it's evaluated.
22:31:21 <c_wraith> gabbiel: so the difference between foldl and foldl' is that foldl doesn't cause the evaluation of the intermediate states.  foldl' does.
22:31:59 <gabbiel> oh i see. why isn't there a foldr' ?
22:32:53 <c_wraith> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:foldr-39-
22:33:01 <c_wraith> But it isn't very useful for []
22:33:15 <c_wraith> It's much more useful for types that associate the opposite direction.
22:35:39 <c_wraith> for [], foldr is generally fine.  It results in nice laziness properties
22:36:24 <gabbiel> isn't foldr (+) the same as foldl' (+) in the sense of strict evaluation?
22:36:41 <c_wraith> No, foldr can produce incremental results
22:37:01 <c_wraith> > foldr (const $ const False) True [1..]
22:37:05 <lambdabot>  False
22:37:25 <c_wraith> there is no way to pass an infinite loop to foldl that doesn't loop forever.
22:37:27 <gabbiel> what does that mean
22:37:30 <c_wraith> err, infinite list
22:37:56 <c_wraith> which part?
22:38:15 <gabbiel> incremental results
22:38:20 <nolrai> Well it looks like my programing is working, my math on the other hand..I tried to do fouire aproximation to the square wave in the real dimension, and instead I got a very nice saw tooth wave in the imaginary. :/
22:38:42 <c_wraith> > foldr (\x r -> show x : r) [] [1..]
22:38:45 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17"...
22:38:46 <nnnxx> any help here with how to make Parser take atleast one of several options?
22:38:57 <gabbiel> the definition of foldr is this right: foldr f a (x:xs) = f x (foldr f a xs)
22:39:15 <gabbiel> but if f is (+), then it will be strict
22:39:21 <nolrai> nnnxx: Parser from what package?
22:39:37 <Axman6> nnnxx:  many (asum [the,options])
22:40:02 <nnnxx> optparse
22:40:03 <c_wraith> gabbiel: sure.  And it will have stack use that's as bad as foldl.  But foldr' would have the exact same bad stack use.
22:40:32 <c_wraith> gabbiel: the thing is, there is no way to make foldl not consume the entire list before it has a result
22:40:56 <gabbiel> but in foldr's case the (+) is the outermost thing evaluated, therefore it should be strict yes?
22:40:58 <c_wraith> gabbiel: but in the opposite direction, foldr has no such problem
22:41:11 <gabbiel> yeah I know that about foldl
22:41:27 <c_wraith> gabbiel: won't help with stack space.  it still needs to calculate the sum of the rest of the list
22:41:58 <c_wraith> so you get something like 1 + (2 + (3 + (4 + (....  however far you went
22:42:14 <gabbiel> oh i see, it makes sense
22:42:47 <nnnxx> Axman6 thanks i needed some but i found out about asum thanks to you :)
22:43:48 <sicklorkin> > foldr (+) e [a,b,c,d]
22:43:50 <lambdabot>  a + (b + (c + (d + e)))
22:44:30 <sicklorkin> > foldl (+) e [a,b,c,d]
22:44:33 <lambdabot>  e + a + b + c + d
22:44:39 <sicklorkin> does that help?
22:44:56 <c_wraith> not really :)
22:45:53 <slack1256> > foldl const e [a,b,c,d]
22:45:56 <lambdabot>  e
22:51:28 <gabbiel> sicklorkin: i knew about argument order regarding foldl and foldr, i was just confused on strictness  
22:54:12 <gabbiel> shouldn't that be const e (const a (const b (const c (const d))))
23:06:53 <Axman6> @src const
23:06:53 <lambdabot> const x _ = x
23:46:26 <dminuoso> Does every adjunction induce a free functor?
