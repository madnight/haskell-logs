00:13:37 <tdammers> v2 is conceptually cleaner in the sense that it elegantly solves the problem of isolating projects without causing a truckload of redundant work
00:14:16 <tdammers> v1 without sandboxes doesn't isolate problems, and you get into cabal hell because dependencies between projects may conflict, but you have to have one global package database that is internally consistent
00:14:46 <tdammers> v1 with sandboxes solves the isolation problem, but at the expense of having a separate package database for each project, so build artifacts cannot be shared between projects at all
00:15:36 <tdammers> v2 solves both, by storing build artifacts globally, but tagged with a hash to disambiguate versions, and then linking them into separate per-project environments
00:43:37 <dminuoso> ski: Okay so I have set up ‚åú.XCompose‚åù now. Typing ùñãùñÜùñìùñàùñû characters is easier than ever. I can only recommend this to you, if you haven't tried it out. :)
00:47:19 <Rembane> dminuoso: Activate fracture mode! 
00:48:33 <maerwald> tdammers: sandbox is much cleaner, you can delete a sandbox and create a new one :)
00:49:32 <maerwald> v2 solves an optimisation problem
00:50:18 <maerwald> and it's rather hard to reason about what it does
00:50:51 <maerwald> higher usability (for the standard use case) at the expense of cleanliness, imo
01:01:51 <koz_> I have a small (perhaps 10-15) bunch of magic numbers (C library argh), which I wanna associate with values of a Haskell sum type. I also need to be able to, given a value of one kind, quickly produce a value of the corresponding kind (so, magic number -> sum type and vice versa). What's the easiest way to do this?
01:02:15 <ski> dminuoso : those five characters all turn up as (inverted) question marks, to me :)
01:03:11 <dminuoso> ski: Oh bummer, those are fraktur codepoints. I suppose your font might be missing some unicode codepoints.
01:04:08 <ski> koz_ : are they consecutive ?
01:04:14 <koz_> ski: Not even close.
01:04:39 <ski> you could define two conversion functions, i suppose ?
01:05:05 <koz_> ski: I was thinking some kind of two-way table, so that I don't have two gigantic case-matching structures in my code. :P
01:05:12 <koz_> I'm just unsure what I could use for that.
01:05:21 <koz_> (well, other than two separate Maps or something)
01:05:43 <dminuoso> ski: But at least some of the things I use frequently like ‚åú‚àÄ ‚àÉ ‚ä•‚åù are in there now, or greek letters Œ±Œ≤ŒæŒ¥ŒµœÜ ....
01:05:56 <dminuoso> Those Im sure your font can display. :)
01:07:06 <dminuoso> I mostly just did it for ‚åú and ‚åù though.
01:07:48 <dminuoso> Ever since you mentioned it, I've preferred it as a means to interpolate another language into my sentences.
01:08:39 <tdammers> maerwald: idk, I've never really felt I couldn't tell what v2- was doing, or why
01:08:48 <ski> dminuoso : aye :)
01:09:12 <maerwald> tdammers: well, if you get a weird failure, what do you do :)
01:09:30 <tdammers> maerwald: I don't know, I'll see about that when I get one, which hasn't happened so far.
01:09:36 <sicklorkin> I estimate that stack probably adds an extra ~15s of build time for each binary - for a dev's typical edit/build/test cycle this additional time adds up to a lot of coffee breaks.. has anyone else experienced this pain? Any well known ways of dealing w/this? 
01:10:10 <sicklorkin> each s/binary/executable/
01:10:12 <maerwald> tdammers: cabal sandbox delete
01:10:19 <maerwald> with v2... dunno
01:10:46 <tdammers> rm -rf ./dist-newstyle
01:10:59 <maerwald> in case your store is not messed up yeah
01:11:10 <tdammers> sure, if the store ever gets messed up, you'd delete that too
01:11:18 <ski> dminuoso : i've noticed i tend to be lazy/conservative/patient/late with introducing these kinds of conveniences. but perhaps i'll look into `.Xcompose' soon :)
01:11:19 <maerwald> and now you deleted it for everything
01:11:23 <tdammers> but AFAICT, that's not very likely to happen
01:11:40 <tdammers> well, if it was messed up, then it was messed up for everything
01:11:46 <maerwald> Exactly
01:11:58 <maerwald> I don't think that is "cleaner" :)
01:12:00 <tdammers> but unlike the old global package database, the store is really just that, a build artifact store
01:12:11 <tdammers> so you can "mess it up" in the sense of storing a broken build artifact in it
01:12:21 <tdammers> but you cannot mess it up in the good old cabal hell kind of way
01:12:45 <tdammers> because the store doesn't care much about dependencies, really
01:13:13 <ski> koz_ : it's a good question. i'm not sure whether such a two-way map exists. i suppose i'd consider attempting to derive one `Map' from the other
01:13:53 <tdammers> to accidentally break the store, you would have to somehow make GHC produce a broken build of a package, but such that it's still tagged with the package and GHC versions that you are going to use later
01:13:54 <ski> (in logic programming, this would be a simple reversable predicate, defined by a "table" of facts)
01:15:01 <tdammers> so you would have to compile it with a GHC that is broken such that it produces incorrect output (which has happened before), but also reports an incorrect version for itself (which seems unlikely to me), and *then* you would have to replace that GHC with another one that doesn't produce incorrect output, but reports as the same, broken version
01:15:04 <ski> perhaps there ought to be language support for defining (potentially partial ?) bijections ? (this is something i've been pondering a little, though from a more type theoretical motivation)
01:15:05 <maerwald> tdammers: every other week there are such problems ime
01:15:22 <tdammers> I haven't seen GHC incorrectly report its own version yet
01:15:25 <maerwald> switching branches, rebuilding, etc etc
01:15:37 <maerwald> GHC panic, some dyn files missing
01:16:00 <tdammers> still doesn't report incorrect versions though
01:16:02 <maerwald> should probably report more bugs
01:16:10 <tdammers> and yes, please do
01:16:24 <maerwald> but then I'm forced to reproduce it :P
01:16:46 <maerwald> otherwise it will just be an anecdote on the issue tracker
01:18:06 <koz_> ski: Seems like the numbers were more sequential than I realized. A bit of toEnum/fromEnum hackery and maths fixed me right up.
01:18:27 <maerwald> my suspicion is that a lot of (file) operations are not atomic and depending on when you cancel something, you may get mixed results
01:18:48 <ski> koz_ : nice :)
01:19:06 <sicklorkin> koz_: it's not great but what' about an enum instance? 
01:19:29 <sicklorkin> koz_: sorry ignore that, sounds like you already got yourselft sorted..
01:19:33 <koz_> sicklorkin: I pretty much did that. It's a very unpretty hack, I agree.
01:19:58 <koz_> What's an even _more_ unpretty hack is how this library decides to (re)define strerror_r.
01:20:07 <tdammers> sicklorkin: why do you think stack does that? can you provide a reproduction case? I just timed stack build on a project that doesn't need any work done, and stack finishes in under 0.4 seconds
01:20:32 <koz_> It behaves differently (in a very nontrivial way) depending on the platform you're on, whether you're triggering a system or library error, and, I kid you not, whether you're on glibc or not.
01:21:54 <sicklorkin> tdammers: do you have any tests? iirc stack will not run tests until it first compiles all execs (which involves a little more than just compiling them)
01:23:29 <tdammers> sicklorkin: ah, so it's the testsuite that eat up the time
01:23:32 <tdammers> sicklorkin: let me chek
01:25:35 <sicklorkin> tdammers: I believe that's where it's happening..
01:25:44 <tdammers> ah
01:25:46 <tdammers> hmm
01:26:07 <tdammers> unfortunately my project doesn't build with stack anymore, now that I have set proper bounds on my dependencies
01:26:18 <sicklorkin> tdammers: shake is good at dealing with this.. stack not so much
01:27:19 <tdammers> hmm, apparently tasty >= 1.2.0 excludes tasty-1.2
01:27:54 <sicklorkin> tdammers: hpack is telling you this?
01:28:12 <tdammers> no, stack is
01:28:36 <sicklorkin> i didn't realize stack touched package.yaml
01:28:39 <tdammers> changing the bound from >=1.2.0 to >=1.2 makes it build
01:28:45 <tdammers> it's in the .cabal file
01:28:55 <tdammers> I don't use hpack, don't really see the point
01:29:07 <sicklorkin> ahh.. yes.. no point I suppose
01:29:39 <sicklorkin> stack dosn't just let cabal deal w/the dependancies?
01:29:48 <ski> koz_ : if there's any gaps, did you make sure the other methods of `Enum' is doing the right thing ?
01:30:10 <koz_> ski: I'm using an Enum instance only on my sum type.
01:30:23 <koz_> The magic numbers are _directly_ dealt with as CInts.
01:30:44 <ski> yes, but what if you say `[A .. C]', and there's no `B', so to speak ?
01:31:03 <sicklorkin> ski: koz_: I usually deal with this by adding types like RESERVED_2
01:31:10 <ski> if your sum type is an instance of `Enum', then a user could reasonably expect that to work, no ?
01:31:28 <ski> (unless the sum type is private/internal or not exported)
01:31:39 <koz_> ski: It's internal.
01:31:45 <sicklorkin> oh.
01:31:50 <ski> sicklorkin : sounds problematic, if there's large gaps
01:32:11 <sicklorkin> aye
01:32:45 <ski> koz_ : ok, not so bad in that case. you might want to place a comment (say for your own sake) saying that methods other than `fromEnum' and `toEnum' aren't guaranteed to work properly
01:32:48 <tdammers> sicklorkin: stack uses cabal-the-library under the hood, but it doesn't normally use cabal's dependency resolution. IIRC, it pins all dependencies to the versions found in the stackage snapshot, which essentially disables the cabal resolver
01:33:03 <koz_> Yeah, I'll definitely do that. Thanks!
01:33:15 <koz_> This is my first attempt at interfacing with a C library.
01:33:21 <koz_> So far, it's been (relatively) painless.
01:33:31 <sicklorkin> tdammers: can't imagine any issues doing that :|
01:33:34 <dminuoso> koz_: Why use Enum in the first place then?
01:34:11 <tdammers> anyway, build's done; touching one test source file and then re-running stack test takes 6 seconds, and it looks like most of that is spend actually compiling and linking the test
01:34:34 <dminuoso> It's like writing an instance for Monad but admitting you can't implement ‚åúreturn‚åù.
01:34:55 <tdammers> btw., I had this idea the other day that one could embed tests into the source code such that they run at compile time; then you could have ghcid report not only type errors, but also test failures
01:35:01 <sicklorkin> tdammers: how many execs do you have? I see it building/linking, copying
01:35:04 <koz_> dminuoso: Mostly so that I don't have to write two conversion functions with like 20 cases each.
01:35:12 <tdammers> just the test binary
01:35:25 <tdammers> there's also a CLI, but it doesn't get rebuilt when I touch a test
01:35:32 <tdammers> idk, they might add up
01:35:59 <sicklorkin> tdammers: In the past I've experimented w/exactly that.. I would expoert _unitTest files..
01:36:03 <tdammers> if you build 3 binaries and don't parallelize, and those 6 seconds are in fact mostly spent linking, then 15 seconds sounds plausible
01:36:09 <sicklorkin> s/file/functions/
01:36:33 <tdammers> yeah, something like that
01:36:54 <tdammers> I was thinking I might just call Tasty tests from template haskell
01:37:02 <tdammers> feels a bit gross, but it should work
01:37:10 <tdammers> not sure what that would do to compiler performance though
01:37:53 <sicklorkin> tdammers: haha.. yu're describing what I did
01:38:30 <sicklorkin> tdammers: whatever works right :P
01:39:13 <sicklorkin> tdammers: and it was nice to have unit/quick/whatever tests in the module you were testing..
01:41:52 <sicklorkin> koz_: another option is PatternSynonyms
01:42:34 <kuribas> what's better, a state monad transformer over the ST Monad, or ST Monad + STRef?
01:42:54 <kuribas> For performant code
01:43:10 <kuribas> Isn't there some overhead for STRefs?
01:43:20 <ski> sicklorkin : hm, good point
01:44:34 <sicklorkin> kuribas: i've never used STRef but isn't that just State Monad with IORef?
01:44:58 <kuribas> sicklorkin: no, it's more like IO that State
01:45:10 <kuribas> Except it hides the fact that it's IO
01:45:25 <sicklorkin> kuribas: how many threads are going to write?
01:45:31 <kuribas> one
01:45:41 <ski> `ST' is like `IO', but only having `IORef' and `IOArray'. also you can "escape" `ST', unlike `IO'
01:47:03 <sicklorkin> kuribas: I'm not sure what's faster - is speed your issue right now?
01:47:24 <kuribas> sicklorkin: I want the best speed :)
01:48:22 <sicklorkin> kuribas: I would do whatever is simplier now.. changing this later ('cause you're bound by performance) woudn't be a big change.. imo
01:48:36 <ski> `State' gives you a single state value, a single mutable location, if you will. of course you can update individual parts of that (with lenses if you like), so that it behaves as multiple mutable locations. but, unless you run a subaction only on a part of the state, each action will take in the whole state, and may conceptually affect any part of it (and all these individual updates, possibly to different parts, will be fully sequentialized, wrt each other
01:48:57 <ski> (er, cut off near ".. (and all these individual updates, possibly to different parts, will be fully sequentialized, wrt each other, modulo such \"focusing\" of state for subactions)")
01:49:58 <ski> with `ST', you can dynamically allocate new mutable locations, of *whatever* type you like. it's like if you had an `IntMap X' in your `State', except that that would only allow "locations" of a single type, `X'
01:50:46 <kuribas> sicklorkin: yeah, it's probably easy to change and benchmark
01:51:21 <ski> (with `unsafeInterleaveST', you can remove some of the over-sequentialization of "parallel updates". but then it's on you to ensure that the separated subactions are really operating on disjoint parts of the state. `unsafeInterleaveST' is definitely more "unsafe" than `unsafeInterleaveIO')
01:57:17 <dminuoso> ski: A motivating example for ST is implementing an efficient quicksort, which requires inplace memory manipulation.
01:57:56 <dminuoso> But it's also obvious that you wouldn't want full-blown IO for that, because that forces IO on you.
02:00:11 <koz_> Where's (>=>) from again?
02:00:26 <sicklorkin> control.monad I think
02:00:31 <dminuoso> koz_: Ask hoogle?
02:00:57 * sicklorkin wonders if many people use it..
02:01:21 <Rembane> :i (>=>)
02:02:04 <sicklorkin>  Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:04:45 <Rembane> sicklorkin: I use it when I do monadic stuff in a pointfree fashion.
02:05:21 <koz_> I am doing exactly this, in fact.
02:06:50 <sicklorkin> I see..  I odn't use it.. looks like flip(.)
02:07:03 <koz_> sicklorkin: flip (.) is (>>>).
02:07:11 <koz_> (from Control.Category, plus a tonne of generality)
02:07:28 <Rembane> :t (>>>)
02:07:31 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
02:07:36 <Rembane> Oh god
02:07:46 <koz_> Although technically I think I could use >>> instead of >=>, since Kleisli is totes a category.
02:07:49 <sm[m]> Ha ha, calling tests with TH is a good idea, and sounds faster than doctest. Might try that
02:08:07 <sicklorkin> sm[m]: :)
02:08:47 <sm[m]> sicklorkin: got an example you could share ?
02:09:23 <sicklorkin> sm[m]: I wish I could, but don't would on that code base anymore
02:10:14 <sicklorkin> sm[m]: i can try to cons something up if you're unsure of how to do it
02:10:41 <sm[m]> No worries, not urgent. Thanks
02:10:48 <sm[m]> Would make a nice blog post!
02:11:15 <ski> dminuoso : perhaps tell that to kuribas ? :)
02:14:23 <sicklorkin> sm[m]: are you already using doctest discover?
02:15:09 <sm[m]> Eh.. I‚Äôm using doctest, not sure what doctest discover is
02:16:33 <sm[m]> And when I say ‚Äúusing‚Äù, I mean ‚Äúonce in a great while I bother to check the sloow doctest build‚Äù
02:16:55 <koz_> Dayum, Hoogle got so much better.
02:18:39 <sicklorkin> sm[m]: understood.. for personal projects I'd rather unittests over docktests for this reaons.. imo they solve the exact same problem.. the overhead of having comments it's not worth it for me
02:20:15 <sm[m]> I find doctests easier to write since they are close to GHCI
02:21:44 <sicklorkin> sm[m]: I guess I don't understand how this differs from running tests in ghci.
02:22:39 <sm[m]> What this do you mean ?
02:23:20 <sicklorkin> sm[m]: this === doctests
02:23:26 <sm[m]> Doctest are like your interactive ghci experiments, but repeatable and doc-generating
02:28:19 <tdammers> so what I want is something that I can keep running in an off-hand terminal, that will wait for changes to my source files, and whenever it sees any, it will produce feedback on it
02:28:20 <dminuoso> ski: Oh actually I meant to write that to sicklorkin. Tab completion mishap.
02:28:34 <tdammers> ghcid does that for compiler errors already, and it's pretty damn fast
02:28:50 <tdammers> (faster than running cabal v2-build or sth in an inotify-driven loop anyway)
02:28:53 <dminuoso> ghcid is unbelievably quick indeed. :)
02:29:02 <dminuoso> Not sure what makes it so fast, but Ill take it.
02:29:12 <sm[m]> Ghcid does that for tests as well
02:29:39 <sicklorkin> sm[m]: it does? 
02:29:47 <tdammers> hmm, you could probably just feed something appropriate as -c
02:30:01 <sm[m]> Sure does!
02:30:15 <sm[m]> It‚Äôs in the readme
02:30:24 <sm[m]> I use it all the time
02:30:59 <sicklorkin> sm[m]: something like `run-after`???
02:31:03 <dminuoso> What exactly is ghcid? It seems to be mainly just an fsnotify wrapper that executes some command (with some neat tooling to automatically call ghc for you)
02:31:24 <Rembane> And it does it in a pretty way.
02:31:36 <sm[m]> ‚Äîtest ‚ÄòGHCICMD‚Äô
02:31:47 <sicklorkin> dminuoso: what I thought it did was load all your sources and use -fnocode...
02:32:05 <dminuoso> sicklorkin: ghci is what does the "load the sources"
02:33:11 <dminuoso> sicklorkin: As far as I can make it out, it's a really thin fsnotify wrapper with some good defaults to parse and interact with ghci. :)
02:33:54 <dminuoso> Ah it seems that it at least expects to run with `ghci`
02:33:55 <sicklorkin> `"--make -no-hs-main -fno-code" "-j8"` if you wanna typecheck quciley..
02:34:23 <sicklorkin> dminuoso: and ghcid takes ghci as an argument
02:35:30 <phadej> does -j work with GHCi?
02:35:31 <phadej> TIL
02:35:57 <dminuoso> I should look into a tighter integration of ghcid into emacs, just to directly point me at the lines of code where stuff went wrong.
02:36:18 <dminuoso> At first glance it doesn't seem like a difficult thing to do.
02:36:23 <sicklorkin> phadej: not that I know of..
02:36:34 <sm[m]> dminuoso: yes please do, I need that
02:36:46 <sm[m]> I think it doesn‚Äôt run with compile-mode, but maybe I‚Äôm wrong
02:36:55 <kuribas> dminuoso: I require the ST monad, since the algorithm (fpc floating point compression) requires a mutable table.  But I have also other state, which I can do by adding a State transformer on top of the ST Monad, or using a STRef.
02:37:33 <dminuoso> sm[m]: https://github.com/ndmitchell/ghcid/blob/master/plugins/emacs/ghcid.el
02:37:35 <dminuoso> sm[m]: Mmmm.
02:37:37 <sicklorkin>  `ghc <sources> <build opts> <libs> --make -no-hs-main -fno-code -j8`
02:38:00 <sm[m]> Nice!
02:38:01 <dminuoso> sm[m]: Would need some really minor tweaks so work with cabal instead, but this looks like a decent place to start.
03:16:33 <t0by> Hey guys, I'm trying to brush up my Haskell skills after having my brain destroyed by 3 years of *thunderclap* Python
03:17:09 <t0by> I'm having a go at some simple HackerRank exercises, but I'm not happy with this solution: https://pastebin.com/raw/KYWDAs4V
03:17:18 <t0by> (Problem statement: https://www.hackerrank.com/challenges/jumping-on-the-clouds/)
03:17:37 <t0by> I don't like the explicit recursion, and I _know_ there is a better way, but I can't quite get to it
03:17:41 <t0by> any hints, please?
03:18:27 <kuribas> t0by: my condolances
03:18:29 <t0by> lol
03:18:47 <Taneb> :t replicateM
03:18:49 <lambdabot> Applicative m => Int -> m a -> m [a]
03:20:18 <kuribas> t0by: y:z:[] = [y, z]
03:20:43 <kuribas> t0by: I find guards a bit easier to read
03:20:47 <kuribas> than if
03:21:05 <Taneb> In that case, a pattern match can be used
03:22:53 <ski> t0by : that's not an array, but a list
03:22:56 <t0by> errr
03:23:16 <t0by> sorry, did I mention I've spent three years in a language in which arrays are called lists?
03:23:24 <t0by> now I'm overcompensating :)
03:23:31 <t0by> yes, a linked list, of course
03:23:57 <ski> and, as Taneb indicated, `readMultipleLinesAsStringList' can be written very simply, using `replicateM'
03:24:11 <t0by> ski, that's the canned boilerplate
03:24:32 <t0by> my code is `jump`, and `jumpingonColuds`, sorry
03:25:04 <t0by> kuribas, right, thanks, excellent point
03:25:23 <kuribas> t0by: minor syntactic nitpick :)
03:25:57 <ski> i'd probably use pattern-matching (on `1'), rather than even a guard, there
03:27:16 <kuribas> indeed.  In general I prefer pattern matching over guards, and guards over if.
03:27:37 <ski> (that's a relatively long sequence of `import's, btw. i suppose there's more to the file than's in the paste)
03:28:36 <t0by> (no, it's the whole file)
03:28:53 <t0by> (the boilerplate on that site does often look a bit funny to me, but whatever)
03:29:17 <kuribas> (ghc should warn about redundant imports)
03:29:54 <kuribas> (the boilerplate hackerrank inserts isn't always the best)
03:30:17 <t0by> Taneb, I'm thinking about how Applicative is relevant to this, thanks
03:30:18 <kuribas> (also, why are we talking in parens?)
03:30:21 <t0by> don't tell me anything yet
03:30:35 <ski> ok, the boilerplate isn't provided by you, and i assume you can't change it ?
03:30:41 <Taneb> t0by: I was trying to improve the boilerplate with my replicateM hint
03:30:41 <kuribas> ski: yes you can
03:30:48 <t0by> oh lol
03:31:02 <ski> well, instead of `hPutStrLn' and `show', you could use `hPrint'
03:31:17 <nullnullnull> guys, I tried adding "timeout" to the ConnectTo host (Portnumber) but timeout didnt work there, is there any alternative way?
03:31:38 <ski> and i suppose if you have line buffering, then `hFlush' won't be needed
03:31:40 <nullnullnull> to reduce the timeout wait between connections
03:31:46 <t0by> I don't remotely care about the boilerplate, really, the point is jumpingOnClouds :: [Int] -> Int
03:32:14 <ski> okay
03:32:46 <ski> it might be more idiomatic to have `jump' be written in curried style, rather than in tupled style
03:33:44 <ski> (but there might be reasons why you might want to keep it in tupled style. e.g. if you're going to `iterate' it, or passing the input pair to it from some other function producing a pair as output)
03:34:13 <kuribas> t0by: sounds like a dynamic programming problem.
03:34:22 <kuribas> t0by: which usually can be solved using lazyness.
03:40:38 <t0by> kuribas, indeed it is
03:42:21 <t0by> ski: so jump :: Int -> [Int] -> Int ? 
03:43:26 <t0by> aaaah
03:45:45 <t0by> https://pastebin.com/raw/fcCBGDFk
03:45:53 <t0by> looks at least more tolerable now
03:46:55 <t0by> kuribas, using lazyness sounds good, using lazyiness is pythoni... *cough* sounds like idiomatic haskell, but I don't see it in here. Any small pointer?
04:01:49 <lavalike> 0x02a
04:03:24 <thosgood[m]> <lavalike "0x02a"> haha
04:04:11 <jgt> I don't know anything about pointers, but I sense a tremendous dad joke here
04:04:46 <[exa]> it's less pointy but more hexy
04:05:33 <t0by> nope, not getting it
04:16:37 <t0by> kuribas, now this indeed is a one-liner thanks to laziness: https://www.hackerrank.com/challenges/repeated-string/problem
04:22:21 <ski> t0by : that would be the curried style version of `jump', yes
04:22:57 <ski> (btw, did you understand kuribas' first suggestion)
04:23:00 <ski> (?))
04:23:54 <ski> you could also replace the variables in the patterns, that are not mentioned in the corresponding body, with the "wildcard"/"don't care"/"ignore", `_'
04:24:07 <nullnullnull> why "timeout" doesnt work with ConnectTo host (Portnumber)? to reduce the timeout between connections
04:26:07 <kuribas> t0by: clouds = last jumps where jumps = zipWith3 (\x y z -> (min x y) + 1 + z*100) (-1:0:jumps) (0:jumps) clouds
04:26:14 <kuribas> t0by: something like that, I didn't test it.
04:53:53 <kuribas> > let cloudJumps clouds = last jumps where jumps = zipWith3 (\x y z -> (min x y) + 1 + z*100) (-1:0:jumps) (0:jumps) clouds in cloudJumps [0, 1, 0, 0, 1, 0] -- t0by 
04:53:55 <lambdabot>  3
04:54:18 <kuribas> t0by: in this case a simple foldl would run in constant space
04:54:37 <kuribas> t0by: where the accumulator is that past two values
04:58:33 <dminuoso> nullnullnull: Do you have a code example?
04:59:23 <kuribas> > let cloudJumps = snd . foldl (\(x, y) z -> (y, min x y + 1 + z*100)) (-1, 0) in cloudJumps [0, 1, 0, 0, 1, 0] -- t0by 
04:59:27 <lambdabot>  3
05:00:50 <nullnullnull> dminuoso, yes here:
05:01:16 <nullnullnull> main=withSocketsDo $ do
05:01:25 <nullnullnull> s <- try $ connectTo "google.com" (PortNumber 82) :: IO (Either SomeException Handle)
05:02:02 <nullnullnull> the line above will make the program stuck in timeout (trying to connect) for long time
05:02:14 <nullnullnull> i wanted to reduce the timeout , for example to 2 secs 
05:02:23 <nullnullnull> and throw an exception
05:03:30 <dminuoso> nullnullnull: Which `connectTo` is that exactly?
05:04:11 <nullnullnull> from this:
05:04:12 <nullnullnull> import Network(connectTo, PortID(..), withSocketsDo)
05:28:18 <nullnullnull> nvm , another question: I have this main
05:28:31 <nullnullnull> main=do
05:28:37 <nullnullnull> async $ t
05:29:12 <nullnullnull> I put this thread:
05:29:12 <nullnullnull> t = do
05:29:13 <dminuoso> nullnullnull: Please try to use `gist` or some equivalent website to paste your code to, then just share the link with us.
05:29:27 <nullnullnull> putStrLn "Main is still running..."
05:29:44 <nullnullnull> sec 
05:29:48 <nullnullnull> i will put it on pastebin
05:30:13 <nullnullnull> im trying to understand why the app is not getting terminated
05:30:17 <nullnullnull> when using async
05:31:44 <nullnullnull> https://pastebin.com/5Gtx6SuE
05:34:17 <nullnullnull> the code above is stuck on "Main is still running..."
05:34:29 <nullnullnull> it doesnt exit 
05:37:54 <exarkun> nullnullnull: Do you know what the type of `t` is?
05:38:16 <exarkun> nullnullnull: It looks like `IO ExitFailure` to me, I guess
05:38:20 <nullnullnull> im not sure but async should be a thread right?
05:38:41 <exarkun> nullnullnull: And the type of `async` is `IO a -> IO (Async a)`
05:39:12 <nullnullnull> yeah but why when i put "exitfailure" it doesnt exit the program?
05:39:14 <exarkun> nullnullnull: so `async $ t` (same as `async t`) has type `IO (Async a)` and `a` is `ExitFailure`
05:39:31 <exarkun> nullnullnull: so `IO (Async ExitFailure)`
05:39:59 <exarkun> nullnullnull: but to have any effect I think you probably need `IO ExitFailure`
05:40:16 <nullnullnull> hmmm
05:40:20 <exarkun> nullnullnull: `wait` has type `Async a -> IO a`
05:41:24 <exarkun> nullnullnull: And other helpers like `waitEither` or `waitAny` might also help since you have a second Async you care about
05:41:55 <exarkun> Or, at least, you _could_ have a second Async
05:42:08 <nullnullnull> so I need to use waitEither?
05:42:54 <exarkun> nullnullnull: If you put the connectTo into an Async as well, then you have two Asyncs and you can use something like waitEither to get the first result that's available
05:42:59 <exarkun> nullnullnull: And I think that might be what you want?
05:43:39 <exarkun> As written now, connectTo just blocks until it connects - so you aren't able to react to `async t` completing
05:43:58 <nullnullnull> hmmm 
05:44:21 <nullnullnull> so what can i do to stop the timeout?
05:46:55 <nullnullnull> i mean, im trying to find a way to stop the "timeout" from keep the program stuck on background
05:47:27 <nullnullnull> thats why i used async, to make it stop after 2 sec if the connection didnt succeed
05:49:04 <exarkun> Reading https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:async
05:49:13 <exarkun> There's also `waitEitherCancel` which cancels the Async that doesn't finish first
05:49:15 <exarkun> So perhaps that
05:56:43 <exarkun> let me know if it works, if you don't mind :)
06:00:49 <nullnullnull> hmm
06:01:06 <nullnullnull> i will try it , thanks mate :)
06:16:12 <asheshambasta> is something like this achievable? https://gist.github.com/asheshambasta/7b13882d2423105cfb7dbc72c49898b2
06:17:11 <dminuoso> asheshambasta: Yes.
06:17:34 <dminuoso> asheshambasta: You could do `(SubAffectedReport (id :: v))` and then use `v` 
06:18:23 <dminuoso> where resourceName' (SubAffectedReport (id :: v)) = resourceName (Proxy @v)
06:18:28 <asheshambasta> dminuoso: ah, nice, thanks! 
07:28:02 <cjay-> is there a lib that uses the same trick as the ST monad to restrict IORefs to a certain thread so that they can't escape to another thread?
07:28:51 <cjay-> should be trivial to implement
07:34:45 <kuribas> cjay-: do you want MVars perhaps?
07:38:33 <cjay-> kuribas: no. IORefs are faster, and it would be nice to have the type system esure that they can't leak to other threads by accident
07:48:07 <dmwit> cjay-: I don't know of such a library. It should be pretty easy to implement in user-land with no compiler magic, though.
07:48:14 <Taneb> Something like newtype TL s a = TL {unTL :: IO a}; forkTL :: (forall s. TL s a) -> TL s () with similar warppers for IORef, I guess
07:48:23 <dmwit> Right.
07:48:48 <dmwit> forkTL :: (forall s. TL s a) -> IO a -- would be my preferred type
07:49:08 <dmwit> (What does TL stand for?)
07:49:17 <cjay-> thread local?
07:49:28 <dmwit> (or maybe forkTL :: (forall s. TL s a) -> IO (a, ThreadId) ?)
07:49:29 <Taneb> Thread Local was my intention
07:49:45 <Taneb> Didn't think about it for any more than 20 seconds
07:53:52 <Taneb> dmwit: I'm not sure it makes sense to return the a there, it might not be computed until the next full moon or whatever
07:53:59 <Taneb> ThreadId makes sense though
07:55:58 <Taneb> And on reflection I think you're right about IO
08:10:21 <hxxxrz> Can you explain please: as I see, there is only one argument (b -> c) in the type declaration. And the result of applying the function is ((a -> b) -> (a -> c)). So where is type declarations for 'g' and 'x'?
08:10:25 <hxxxrz> comp :: (b -> c) -> ((a -> b) -> (a -> c))
08:10:29 <hxxxrz> comp f g x = f (g x)
08:10:57 <hpc> you've just encountered currying
08:11:31 <hpc> basically, a -> b -> c is actually a -> (b -> c)
08:11:38 <hpc> functions always take only one argument
08:11:50 <hpc> and maybe they produce another function
08:12:03 <hpc> and when you write comp f g x = f (g x), you're writing the same thing as
08:12:13 <hpc> comp = \f -> \g -> \x -> f (g x)
08:15:43 <hxxxrz> but dont i have to declare types of g and x? 
08:17:56 <hpc> you already have
08:18:06 <hpc> g is the parameter to the function produced by (comp f)
08:18:23 <hpc> so if you read through the type signature of comp to that position, it's (a -> b)
08:19:58 <hxxxrz> thanks
08:28:45 <dminuoso> Mmm, so injective type families are basically sort of like fundeps where knowing "part of an equation" lets the type checker infer other types?
08:29:47 <dminuoso> Or let me reformulate: Are injective type families to assist type inference, or do they exist to rule out bugs (by forbidding that two types in the domain map to the same type)
08:30:36 <d34df00d> I might not be the best one to answer, but in my experience it's both.
08:36:29 <cocreature> yeah I think ‚Äúboth‚Äù is a fair answer
08:37:20 <dminuoso> I see. :)
08:54:25 <dmwit> Taneb: Of course, the `a` is completely nonsensical!
09:36:36 <Jinna> Where can I find a good description (a comparison table/matrix) of the different deriving strategies? No specifier, anyclass, newtype and stock.
09:50:15 <portnov> hi all
09:52:19 <portnov> I ran a program with +RTS -pj, and in prof file I see cost centre named IDLE, which consumes about 50% of ticks.
09:52:21 <portnov> what is it?
10:01:26 <ianliu> I'm trying to write a simple testable program like this:
10:02:06 <ianliu> class Monad m => Console m where, println :: String -> m ()
10:02:22 <ianliu> getline :: m String
10:02:40 <ianliu> How would you instance this Console for testing?
10:03:01 <ianliu> I would like the println to do nothing, and getline to return "foo"
10:06:31 <lavalike> ianliu: m = Identity ?
10:13:20 <ianliu> lavalike, hmm, I don't think I got it yet. Will go back to learning
10:14:39 <sicklorkin> ianliu: does m need to run in IO?
10:14:47 <dmwit> Jinna: The GHC manual has the full details.
10:15:45 <dmwit> ianliu: instance Console Identity where println _ = Identity (); getline = Identity "foo"
10:22:40 <sicklorkin> portnov: What's your programs' mem usage?
10:24:14 <portnov> sicklorkin: I think less than 1 gigabyte, since it works well with -H1G
10:24:22 <portnov> though  ¬†¬†"total_alloc" : 31064691408 ...
10:25:00 <portnov> ah, that I think just amount of memory allocated, without considering memory being freed from time to time
10:25:23 <ianliu> dmwit: thanks!
10:27:43 <Clint> win go #linguistics
10:27:48 * Clint sighs.
10:29:20 <intimidated> Hi, I'm having an issue using cabal to use the package provided by a book (Vitaly Bragilevsky's Haskell in Depth). I had previously tried to use stack, but this runs into a known stack bug (#4564), so cabal is basically my only option here.
10:30:07 <intimidated> Is there a way for me to break lines on this chat without sending the message? If not, what's the best way for me to format a long-ish message with terminal output and stuff?
10:31:01 <Clint> depends on your irc client
10:31:13 <intimidated> I'm on a web client.
10:31:17 <sclv> for terminal output and stuff you may want to put it in a pastebin
10:31:20 <sclv> and then paste the link
10:31:29 <sclv> if you have a github account, people often use gists
10:31:29 <argent0> intimidated: use a gist
10:31:42 <intimidated> OK, thanks.
10:35:50 <sicklorkin> portnov: your mem usage seems high, but I haven't a clue what your program is doing.. Are you storing large objects in memory?
10:36:16 <portnov> no, just a lot of small objects :)
10:36:51 <sicklorkin> portnov: my guess IDLE == GCs
10:37:16 <sicklorkin> portnov: s/guess/arm waving guess/
10:37:57 <portnov> well, it is possible... though there is specific "cost centre" named GC in the prof file, with some non-zero ticks (about 7% or something like that)
10:38:55 <sicklorkin> portnov: try profiling with -h.. see the users guide for all avail opts.
10:39:38 <portnov> also, my program is not actually computing during all it's run time ‚Äî it waits for user input (more precisely, waits for http request) for some time
10:39:49 <portnov> maybe IDLE is that time that it is waiting
10:40:43 <portnov> I'm just confused because this cost centre is not present in text prof file, but it is present in json prof file
10:40:53 <sicklorkin> portnov: Another metric you might consider looking at is productivity? I'm not sure if i've got that right.. sorry.. i'm pretty much useless when it comes to profiling in the dark :P
10:41:28 <portnov> thanks anyway :)
10:43:39 <intimidated> OK, my terminal output is here: https://gist.github.com/brunoparga/d5aa2d64e50fe4d1619c8c8097dc2120.
10:44:07 <intimidated> Apparently the issue is that the version of base the course requires does not match the one that came with my GHC install.
10:45:54 <sclv> intimidated: yep. you need a newer ghc
10:46:09 <sclv> that said, don't mix sandbox and vw-install
10:46:13 <sclv> v2-install, rather
10:46:20 <cocreature> portnov: IDLE is when a capability doesn‚Äôt have any task scheduled
10:46:39 <cocreature> portnov: the reason you don‚Äôt see it in the text profile is that GHC suppresses a bunch of builtin cost centres in the regular profile output but shows them in the json output
10:46:44 <sclv> v2-install ignores sandboxes. so to follow the course _as is_ use v1- commands. or learn the v2- way and use that uniformly :-)
10:46:52 <portnov> aha
10:46:58 <portnov> cocreature: thanks!
10:47:26 <intimidated> sclv: There's a new-sandbox command as well, isn't there? I don't remember which one I used. How do I solve this issue I wasn't aware of?
10:47:40 <cocreature> portnov: I think with +RTS -pa you can always enable all of them
10:47:49 <sclv> in your output you did 'sandbox init'
10:47:54 <intimidated> How do I get a newer ghc in a way that won't mess up other things (not that there are many, but I want it to be as future-proof as possible)
10:48:10 <sclv> intimidated: how did oyu install this ghc?
10:48:19 <sclv> on what os?
10:48:29 <intimidated> The book says 'sandbox init', I don't remember if that itself worked or if it told me to do 'new-sandbox'. I think it was the former.
10:48:42 <intimidated> I think this ghc came from the cabal-install Ubuntu package.
10:49:09 <sclv> ok, so just use ghcup https://www.haskell.org/ghcup/
10:49:18 <intimidated> There were other installs before because I was using stack so I'm basically not sure at this point what came from where.
10:49:27 <sclv> it manages multiple ghc versions in a location seperate from that provided by your os install
10:49:42 <intimidated> And will cabal be able to access those versions?
10:49:44 <sclv> stack also manages its own ghc, so that doesn't overlap either
10:49:55 <sclv> intimidated: you either make sure your path is pointing to the one you want
10:49:58 <intimidated> I don't have stack anymore, I was only using it for this book
10:50:18 <sclv> or you can pass the --with-compiler flag (shorthanded -w i think) to cabal
10:50:25 <sclv> and just explicitly point it to what ghc you want
10:50:45 <sclv> so its very conveninent when working with multiple versions to use ghcup or another tool to put them all in different versioned directories
10:50:59 <intimidated> with either option, this should be the directory where the ghc binary I want is located, right?
10:51:02 <sclv> and explicitly pass the -w flag (or with v2 project files, just put that in the .project file for each project)
10:52:03 <sclv> i think this is the full path to the binary, not just the directory containing it
10:52:20 <intimidated> OK, I'll try that. Thank you very much!
10:53:13 <intimidated> Since ghcup installs cabal, should I uninstall the Ubuntu package version?
10:53:29 <sclv> not unless you want to upgrade it
10:53:39 <intimidated> And delete my ~/.cabal folder?
10:53:41 <sclv> i.e. its up to you
10:53:44 <intimidated> I think I don't need these
10:53:45 <sclv> no need to do that either
10:53:51 <sclv> i mean... you can :-)
10:54:45 <intimidated> If ghcup already installs the same things but better, I don't want to have these other things confusing me. It was already bad when 'ghci' and 'stack ghci' used different ghci versions.
10:57:45 <sclv> sure then
11:01:38 <intimidated> Ugh. ghcup says it requires a package that's not listed in the repos I'm using (realpath). I have to go look for that first. This is frustrating, it is not the first nor the second time today that this happens.
11:01:47 <intimidated> Next thing you know I'll be shaving a yak.
11:26:19 <intimidated> OK, I've just installed ghcup and added the required folders to my PATH: ...$ echo $PATH/home/username/.cabal/bin:/home/username/.ghcup/env
11:26:42 <intimidated> But 'cabal new-install cabal-install' won't work.
11:27:01 <intimidated> zsh: command not found: cabal
11:27:09 <sclv> you need to use ghcup to install cabal
11:27:17 <intimidated> how?
11:28:00 <sclv> https://github.com/haskell/ghcup#usage
11:28:01 <intimidated> I ran the script that was on the page you sent me and I thought that installed cabal already. I'm running this from the ~/.cabal folder, which I'm pretty sure gchup created.
11:28:14 <intimidated> aha
11:28:19 <sclv> ok maybe your terminal doesn't have the path you updated in it yet
11:28:21 <sclv> fresh terminal?
11:28:57 <intimidated> ghcup install-cabal - zsh: command not found: ghcup
11:29:13 <sclv> so does the path actually point to ghcup's folder?
11:29:19 <sclv> and if so do you have a fresh terminal with the new path?
11:30:29 <intimidated> My path does have ~/.ghcup/env
11:30:58 <intimidated> ~/.ghcup/env contains this: export PATH="$HOME/.cabal/bin:${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/bin:$PATH"
11:31:30 <intimidated> so I'm not really sure how it says ghcup is not found.
11:32:34 <sclv> i don't know what to tell you. this is just a sort of "is your linux configured sanely and do you know how its working" question
11:35:15 <intimidated> My Linux works just fine otherwise. It is just Haskell that keeps getting this wrong.
11:36:22 <hpc> wait, so ~/.ghcup/env is on your path
11:36:26 <sclv> i mean just literally its a question about paths
11:36:29 <hpc> but it's a file containing bash?
11:36:32 <alx741> intimidated: are you sourcing it though? `source ~/.ghcup/env` 
11:37:08 <hpc> it's $HOME/.cabal/bin:${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/bin that you need on your path, not the env script itself
11:37:13 <alx741> that env shouldn't be in the path, it should be sourced, the path it *contains* gets appended to your path
11:37:22 <intimidated> Wait, too many questions at once. I changed the path (and checked it with echo $PATH, and restarted zsh so it should be sourced if I understand it correctly)
11:37:58 <hpc> open a fresh zsh, and print the path again
11:38:05 <hpc> it won't have the directory that the ghcup binary is in
11:38:59 <intimidated> My ~/.zshrc has the following line: export PATH="/home/bruno/.ghcup/bin:$PATH"
11:39:30 <alx741> intimidated: in my ~/.zshrc I have `source $HOME/.ghcup/env`
11:39:36 <intimidated> the output of 'echo $PATH' begins: /home/bruno/.ghcup/bin:./bin:./node_modules/.bin (yadda yadda)
11:39:56 <intimidated> With the backticks included?
11:40:05 <hpc> without the backticks
11:40:08 <alx741> intimidated: no, without the backticks
11:40:27 <hpc> oh, i misspoke as well
11:40:52 <hpc> "it won't have the directory that the ghcup binary is in" should be the directory for the stuff ghcup installs, not ghcup itself
11:41:03 <intimidated> Wait, this current setup works.
11:41:30 <intimidated> I was switching between changing stuff on .zshrc and posting here and hadn't tried it.
11:41:44 <intimidated> Thank you, everyone! Let's see where I get stuck next :(
11:42:47 <intimidated> The other times I had tried installing cabal it often got stuck on the output line that says: 'Completed    HTTP-4000.3.14 (lib)'
11:43:06 <intimidated> I did ^C on that. If I wait long enough will it work this time?
11:43:29 <sclv> you don't need to install cabal again
11:43:34 <sclv> you literally just installed it with ghc-up
11:43:50 <masaeedu[m]> edwardk: Do you think it makes sense to talk about comonads on Kleisli categories?
11:44:28 <sclv> its a concept that exists, sure
11:44:30 <masaeedu[m]> For example `[]` is not quite a comonad on Hask. But it is a comonad on the Kleisli category of Maybe
11:45:08 <masaeedu[m]> sclv: would you have some pointers to existing resources on the concept?
11:45:22 <intimidated> sclv the installer output told me to update cabal to the latest version, so did the how-to you sent me.
11:45:27 <intimidated> (or someone else did)
11:45:30 <sclv> idk if its been much studied. i just meant it made sense abstractly
11:45:59 <sclv> ghcup should give you a very recent cabal already
11:46:03 <sclv> so you don't need to build a new one
11:46:05 <dmwit> intimidated: Including relative directories in your PATH is a pretty serious security hazard, by the way. You probably shouldn't do that.
11:46:29 <masaeedu[m]> a few people in the slack room were having a discussion about this yesterday, and it seems like certain things that you'd intuitively want very much to be comonads aren't comonads only because you can't extract them into `Identity`
11:46:39 <dmwit> (Probably isn't related to whatever trouble you're having right now, though.)
11:47:18 <masaeedu[m]> but in an appropriate Kleisli category (and the Kleisli category can be of a monad constructed by mixing together various monad transformers), lots more things seem like they would be comonadic
11:47:20 <intimidated> I don't understand where I did that.
11:47:48 <dmwit> I can't answer that. But I can see that you did, because your PATH includes ./bin and ./node_modules/.bin which are both relative.
11:49:04 <turab> dmwit: Why is it a sec hazard? just curious
11:49:09 <intimidated> Hm... this is from a setup script from work. Would you have a link for more information on the security risk of relative directories on PATH?
11:50:14 <intimidated> The comment above it on zshrc says '# Rails and Ruby uses the local `bin` folder to store binstubs. So instead of running `bin/rails` like the doc says, just run `rails` Same for `./node_modules/.bin` and nodejs'
11:51:11 <intimidated> OK, now I apparently have a new GHC and cabal. Let's see if the book thing works.
11:51:26 <dmwit> turab: Because that means that any program which is allowed to touch any directory at all can leave a ticking timebomb behind named `ls` that does something nasty and hides its own tracks.
11:51:57 <dmwit> Or `echo` or `date` or whatever.
11:52:28 <turab> Oof, good to know
11:52:33 <turab> Thanks for sharing that!
11:53:45 <intimidated> That makes sense. How would I find a source corroborating that so I can share it at work?
11:53:54 <masaeedu[m]> i tried it out for `[]` and (with some help from people in the slack room) am convinced that the concept works fairly rigorously at least in that case: https://gist.github.com/masaeedu/d391fb8d7d4da8bb7473fe833a6a8c7f
11:54:22 <dmwit> What more source do you need? That's... just describing in text the way that PATH works. You could point to the man pages for your shell or something I guess....?
11:54:43 <intimidated> googling 'relative directory path' talks about relative paths, not PATH
11:55:10 <intimidated> how do I refer to this PATH thing (I don't know how it's called - an environment variable?) in a Googlable way?
11:55:29 <turab> https://serverfault.com/questions/776187/security-implications-of-using-relative-paths-in-the-path-enivronmental-variable
11:55:57 <intimidated> Thanks, I was just going to post that same link here.
11:56:18 <turab> :)
11:58:14 <edwardk> masaeedu[m]: yes. i advocate this as way better practice than the stuff where folks try to find distributive laws of comonads over monads
11:58:24 <edwardk> the kleisli story is at least useful!
11:59:16 <lyxia> masaeedu[m]: are you sure about the laws, I thought it had to fail at least one of them
12:00:05 <masaeedu[m]> lyxia: see my message to you yesterday, it was broken with `traverse`, but i used a different `fmapMaybe`
12:00:52 <lyxia> Let me brute force it in Coq.
12:01:44 <intimidated> So the problems in the question turab linked to are that there's a relative path that begins with `apps`, and also that it comes before `/bin` on the PATH. Is this understanding correct?
12:01:54 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/rNUYGHBhxbyJnGjtmhVSXKQb >
12:02:40 <masaeedu[m]> `catMaybes . fmap` as i wrote actually obscures a nice insight, because it's the same as `mapMaybe`, which in turn is a functor from Kleisli Maybe to Hask (as witnessed in the Compactable package)
12:02:43 <intimidated> Do I need to do anything besides removing the relative directories from my PATH?
12:12:04 <lyxia> masaeedu[m]: it seems to fail the duplicate-duplicate law
12:12:42 <masaeedu[m]> `duplicateM <=< duplicateM =/= fmapM duplicateM <=< duplicateM`?
12:13:15 <lyxia> try that with [].
12:23:41 <masaeedu[m]> hmm, that's right. the `duplicateM <=< duplicateM` ends up producing `[[[]], []]`
12:34:01 <argent0> HI, so 'Data.Foldable.foldl1' is "A variant of foldr that has no base case, and thus may only be applied to non-empty structures.". Is there a better way to write: `(Semigroup a) :: NonEmpty a -> a = foldl1 <>` ?
12:34:24 <argent0> s/foldr/foldl/
12:34:29 <ddellacosta> is there anything like the `maybe` function that I can use with lens? That is, I don't want a Maybe value back, I want to be able to provide a default when I get Nothing or apply a function otherwise, so I don't want e.g. ^?
12:36:39 <ddellacosta> I guess I'm looking for some kind of prism
12:37:42 <argent0> ddellacosta: that sound like a lens
12:38:29 <argent0> foo :: b -> Lens (Maybe b) b
12:38:35 <argent0> Lens'
12:40:02 <argent0> `bar ^. foo default` would do the trick
12:40:39 <argent0> bar :: Maybe b, default :: b, `bar ^. foo default :: b`
12:41:40 <ddellacosta> argent0: thanks!
12:43:10 <dmwit> That isn't a lawful lens.
12:43:34 <dmwit> But if you're okay with that, see also non.
12:43:40 <dmwit> :t non
12:43:42 <lambdabot> (Functor f, Profunctor p, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
12:44:13 <ddellacosta> dmwit: I'm still crap enough at lens that I'm simply trying to understand how that works :-(
12:44:32 <ddellacosta> but thank you
12:44:34 <dmwit> What is "that"?
12:44:52 <ddellacosta> the foo type sig argent0 just gave me
12:45:19 <dmwit> Well, I mean, they didn't give you an implementation. I think they assumed you'd be able to write it yourself.
12:45:39 <dmwit> I inferred from your reply that you agreed with that assessment, but if not, may I recommend the tutorial "Lenses over tea"?
12:45:40 <ddellacosta> yes, I figured
12:46:37 <dmwit> (It is the tutorial that elevated me from "don't understand at all" to "mostly don't understand". =P)
12:46:54 <ddellacosta> dmwit: do you know how many different lens tutorials I've done? I've gone so far as to implement lens using Identity and Const functors with a friend's guidance...but it hasn't stuck yet. But I guess one more tutorial can't hurt, haha
12:47:23 <ddellacosta> more to the point, it seems like I have to relearn it every time (the pitiful amount that I did understand at one point)
12:47:46 <dmwit> Is somebody forcing you to use lens or something?
12:47:47 <ddellacosta> anyways, I'll shut up now and dig in again, heh
12:48:00 <ddellacosta> nope
12:48:12 <dmwit> Turning the thumbscrews when you try to write a pattern match on Maybe's.
12:48:35 <dmwit> Waving a gun around and ranting madly as you pull out some curly braces for a record.
12:48:40 <argent0> dmwit: It would be a `Getter` right?
12:48:57 <ddellacosta> hard knocks school of learning lens, that
12:49:14 <dmwit> You should be able to make a lawful Getter, yes.
12:49:41 <dmwit> Which is just another way of saying function, at which point why not just use fromMaybe?
12:50:08 <glguy> Are there unlawful getters?
12:50:24 <ddellacosta> dmwit: no I was just kind of hoping there was some lens magic that would let me replace the `maybe "whatever" (doStuff . show)` kinda thing I had with something more concise. As usual I got in over my head though, haha
12:52:04 <dmwit> glguy: Nope!
12:52:34 <dmwit> The contrast I was drawing was "lawful Getter" vs "lawful Lens", not "lawful Getter" vs "unlawful Getter".
12:57:31 <ddellacosta> dmwit: actually "Lenses over tea" is way more thorough than anything I've seen so far, thanks a lot for cluing me in to its existence
12:59:46 <dmwit> \o/
13:17:14 <sethetter> I'm a pretty beginner level haskeller, and wondering how important others here find it to have "go to definition" functionality in their editor. Is there a good alternative to this that's not editor tooling dependent? Does hoogle cut it?
13:18:26 <Rembane> sethetter: I use hoogle instead of go to definition. 
13:18:39 <sethetter> Trying to get hie installed and working with the vim language server plugin in a local nix-shell is proving more challenging that I care to struggle with, lol.
13:18:43 <Rembane> sethetter: I also use typed holes quite extensively. 
13:19:04 <sethetter> I've seen typed holes mentioned before, but not familiar with the concept yet.
13:19:20 <hpc> it's pretty simple
13:19:39 <hpc> write your code as usual, but then instead of some part of an expression you don't know yet, maybe you write undefined
13:19:42 <hpc> and get back to it later
13:19:44 <hpc> instead, write _
13:20:10 <hpc> that's a hole, and you'll get a warning that includes the type and such
13:20:17 <dmwit> sethetter: I use hasktags and I am pretty sure I could not do my job without it.
13:20:48 <hpc> if you're writing stuff from scratch, a nice workflow is write out what you want in types only, and put a hole for every definition
13:21:04 <dmwit> sethetter: You might also like http://github.com/dmwit/cabtags
13:21:06 <hpc> then iteratively refine each definition by making the holes deeper and deeper into the definitions
13:21:09 <hpc> until you're done
13:23:19 <Rembane> sethetter: Have you checked out cachix? 
14:09:14 <jgt> cachix is great, and so are its creators
14:17:16 <janat08> Line 23 produces m(dynamic t (a0 -> Text)). instead of Text for dynText. Functions with dyn produce m(dynamic), this reflex-frp specific question. https://www.irccloud.com/pastebin/46K0DkVq/
14:21:50 <turab> Can someone lead me in the right direction to use ExcepT and mtl properly?
14:22:20 <turab> https://github.com/trajafri/Pref/blob/master/src/Pref.hs
14:22:53 <turab> I am concerned about the monadT stack on line 64. Currently, I have to use lifts to throw errors
14:23:31 <turab> From my understanding, I shouldn't have to use lift if I am using mtl correctly
14:25:35 <DigitalKiwi> puffnfresh uses type holes a lot in his data61 fp-course videos https://www.youtube.com/playlist?list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW it's a good watch
14:40:52 <fragamus> hi I have enormous strings with which I am working and I need to get a lot of substrings out of them, indexed by Ints for start and end
14:41:13 <fragamus> what is the preferred way to achieve good performance?  ByteString?
14:42:16 <fragamus> I know what you're thinking and it is not Text
14:42:37 <fragamus> it is [Char] 
14:42:59 <lyxia> ByteString sounds like a good starting point
14:43:04 <fragamus> ok
14:43:43 <fragamus> is there a nice way to get from [Char] to ByteString
14:44:45 <fragamus> :t ByteString.pack
14:44:46 <lambdabot> error:
14:44:46 <lambdabot>     Not in scope: ‚ÄòByteString.pack‚Äô
14:44:46 <lambdabot>     No module named ‚ÄòByteString‚Äô is imported.
14:46:00 <Cale> fragamus: If you're starting with [Char], it might be more correct to first use Data.Text.pack, and then encodeUtf8 to get to ByteString
14:46:42 <Cale> fragamus: Of course, I'd have to ask where you're getting the [Char] from in the first place -- there are ways to do I/O to get ByteStrings directly usually
14:47:26 <masaeedu[m]> is there a way to implement a `Category` instance for `Coercible` itself?
14:48:05 <fragamus> I found this in MissingH:     s2w8 :: String -> [Word8]
14:49:06 <fragamus> I'm getting it from the haskell parser
14:51:13 <Cale> It's worth thinking about *which* ByteString you want in general. Of course, if your string is guaranteed to be entirely ASCII 7-bit characters, you can just use Data.ByteString.Char8.pack and it's valid latin-1 / utf-8 and a bunch of other things, but if there might be other characters in there, you have to care about which text encoding you're using.
14:51:13 <fragamus> well no, I am getting an AST and then applying show
14:51:21 <bandali[m]1> hi all, would anyone be able to help me bridge a matrix room with a freenode channel like #haskell currently is?
14:52:32 <Cale> I'd probably T.pack and then T.encodeUtf8
14:52:41 <fragamus> ok
14:53:21 <fragamus> maybe I'll just let it be [Char]
14:53:39 <fragamus> it's a holiday here and we had an earthquake
14:53:52 <fragamus> I could have been killed
14:54:13 <fragamus> and the earth is tilted
14:54:35 <bandali> are any of the matrix admins/mods of this room active here?
14:56:20 <Cale> I'm a mod here, but I have no idea about how the matrix bridge works
14:59:19 <bandali> ah
14:59:30 <bandali> Cale, do you know who set it up? or who i could ask about it?
15:02:00 <Cale> I think it's configured more from the matrix side of things. If you type "matrix irc bridge" into google, a handful of things show up
15:02:46 <Cale> Also, I think it might be the case that you can join any freenode IRC channel from matrix.org
15:06:11 <bandali> thanks
15:06:21 <bandali> i‚Äôm aware of the latter approach (with ‚Äúportal‚Äù rooms)
15:06:43 <bandali> but we‚Äôd like a so-called ‚Äúplumbed‚Äù bridge like #haskell‚Äôs
15:06:59 <bandali> i‚Äôll look more, and if can‚Äôt sort out our issues, i‚Äôll try getting in touch with the matrix devs
15:07:00 <bandali> thanks
15:14:44 * ski thinks it's slightly annoying that (sometimes), when <matrix.org> users reply to other people in here, the initial part of the message is a truncated version of the message being replied to
15:15:17 <ski> (oh, and the "long message" thing, requiring one to go to some webpage)
15:15:56 * DigitalKiwi thinks matrix is annoying
15:16:44 <ski> (supposedly it's better than Slack or Discord or something ?)
15:17:09 <Clint> in many ways it is
15:17:11 <bandali> yes i hate that too
15:17:19 <DigitalKiwi> a bucket of <profanity> is better than slack
15:17:22 <bandali> but some insist on using it or having it as an option
15:17:26 * ski smiles
15:18:27 <DigitalKiwi> irc4lyfe
15:18:46 <bandali> ^
15:19:36 <Clint> good luck with that
15:20:11 <bandali> i‚Äôm thinking of giving up on the whole matrix bridge, and instead host an instance of The Lounge and point users to that
15:20:57 * ski . o O ( <https://xkcd.com/1782/> )
15:21:00 <MarcelineVQ> ski: some normal irc clients do the long message link as well
15:21:20 <DigitalKiwi> the only one i know of is irccloud
15:21:24 <ski> MarcelineVQ : hm, how does that work. upload on some central server, where ?
15:21:49 <MarcelineVQ> I think it's more like an ephemeral pastebin sort of thing
15:21:55 <ski> okay
15:22:10 <ski> not really good for logs
15:22:12 <MarcelineVQ> I've never gone back to see if the links still work
15:26:02 <MarcelineVQ> ski: first example I see in my logs, looks like it lasts, https://www.irccloud.com/pastebin/pII8XTVL/Parsnip.hs At the same time revealing which client does this. I guess we'd have to ask someone who uses it whether long-messages turning into url's is automatic or not to be sure
15:26:27 <MarcelineVQ> The bin suggests it is
15:27:03 <ski> ok
15:27:46 <DigitalKiwi> but you can't grep a log for the contents of the paste
15:28:11 * ski nods
15:28:58 <MarcelineVQ> with a sufficiently advanced grep, say from some agency, I bet you can
15:30:02 <DigitalKiwi> or if you wrote a plugin for your client that expanded the contents of the url into the logs
15:30:09 <DigitalKiwi> OR irc clients could stop doing dumb shit
15:30:24 <DigitalKiwi> specifically irccloud and matrix
15:32:36 <turab> I believe I have confused myself. Is it correct that in ghci, transformers from Control.Monad and Control.Monad.Trans are different?
15:34:01 <MarcelineVQ> Which transformers from Control.Monad?
15:34:35 <dmwit> turab: There are no transformers in Control.Monad.
15:35:50 <dmwit> Maybe you mean e.g. Control.Monad.State vs Control.Monad.Trans.State? If so, generally the mtl package (which provides Control.Monad.State) is re-exporting stuff from the transformers package (which provides Control.Monad.Trans.State), so State(T) is the same from both of those modules.
15:36:14 <turab> Yes exactly, sorry about that
15:36:25 <turab> Ohhhh
15:37:12 <turab> Correct me if I am wrong. If I use Control.Monad.Trans.* transformers in a do block, then I will have to call `lift` to use stacked monads, correct?
15:37:21 <lavalike> yeap
15:38:16 <lavalike> it's "customary" to define new actions, maybe with names closer to your specific problem domain, which embed the calls to lift, so that your do blocks look like they are talking about your problem domain and not about monad transformers
15:38:21 <turab> That's what I think I understand after experimenting with Monad.State vs Monad.Trans.State
15:40:41 <dmwit> The mtl is, in short, about writing classes that call lift for you.
15:41:37 <dmwit> :t Control.Monad.Trans.State.get
15:41:39 <lambdabot> Monad m => StateT s m s
15:41:52 <dmwit> No class: only works for StateT.
15:41:56 <dmwit> :t Control.Monad.State.get
15:41:58 <lambdabot> MonadState s m => m s
15:42:09 <dmwit> Yes class: works for StateT, and also for transformed versions of StateT.
15:42:19 <dmwit> The non-StateT instances call lift.
15:42:20 <lavalike> and then there's the problem of which monad in the stack gets targeted
15:42:52 <dmwit> oh
15:45:07 <turab> whoops, got disconnected so not sure if someone replied
15:45:16 <jpg> Hello guys. Is there a way to select a set of libraries to use dinamically when compiling a Haskell program with ghc? The motivation is: I'm getting a huge binary, If I compile it using -dynamic it gets really small, but I'm sending it to a VM where some shared libraries are not installed. So I would like to link dinamically to the ones that are avaiable there such as glibc
15:49:33 <lavalike> jpg: maybe -staticlib gives you a way?
15:49:44 <lavalike> no, nevermind
15:51:11 <lavalike> jpg: there is -optl to pass options to the linker, *that* should give one a way to add more static libs in I think
16:18:31 <dmwit> turab: What's the latest reply you saw?
16:19:20 <dmwit> turab: https://gist.github.com/dmwit/6f99261fa7671671f5bba323b6dcbe9e is everything in my log.
16:20:43 <turab> dmwit: It was you explaning that C.Monad reexports C.M.Trans stuff
16:21:32 <turab> I think that also answers my questions for why explicit lifts are required for transfrom from Control.Monad.Trans (because they are not from mtl :) )
16:36:05 <dmwit> turab: N.B. this is about the actions available from those modules, not about the transformers themselves.
16:36:16 <dmwit> As I said before: the transformers are the same.
16:39:37 <turab> Talking about transformers, I read that if one uses lift, then the transformer is used incorrectly. Is this really true? I have two instances where I am not sure how to avoid using lifts
16:40:49 <turab> Which makes me think that I might be using the wrong stack
16:41:44 <solonarv> masaeedu[m]: you can define the following: data Coercion a b where Coercion :: Coercible a b => Coercion a b; and try to write a Category instance for that (but I'm not sure if GHC will let you)
16:43:18 <gbowen> QUIT
16:43:25 <gbowen> #QUIT
16:43:36 <turab> slash
16:44:06 <MarcelineVQ> #slash
16:45:37 <solonarv> masaeedu[m]: ah, seems to work just fine. in fact I seem to remember Coercion already being defined somewhere
17:00:27 <dmwit> turab: Uh, what?
17:00:46 <dmwit> Where did you read that? Are you sure you remember it correctly?
17:01:16 <dmwit> solonarv: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Coercion.html
17:01:29 <turab> http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/
17:02:01 <turab> I am most probably misunderstanding what exactly they mean here
17:02:06 <dmwit> This blog post is just saying to use the mtl.
17:02:47 <dmwit> Which is great. But the mtl is implemented using lift.
17:03:26 <turab> Is it possible to avoid lift if my stack looks somethings like this:
17:03:27 <dmwit> IDK. Show us some code that you like that has lift, and we can talk about whether it's doable with mtl stuff instead that doesn't include the literal text "lift".
17:03:39 <turab> Okay cool, one sec
17:04:13 <turab> https://github.com/trajafri/Pref/blob/master/src/Pref.hs
17:04:34 <turab> function on line 58 is used multiple times
17:05:14 <turab> https://github.com/trajafri/Pref/blob/master/src/Transform/CPS.hs
17:05:20 <turab> line 87
17:06:13 <dmwit> The mtl way would be `liftEither :: MonadError a m => Either a b -> m b; liftEither (Left a) = throwError a; liftEither (Right b) = pure b`.
17:07:41 <dmwit> The mtl doesn't have a good answer for your cpsApp, but see https://gist.github.com/dmwit/ce531720746377e683385341071d0318 which I should really flesh out into a complete package.
17:09:40 <turab> Thanks a lot! I really really appreciate the feedback
17:10:07 <turab> Finally feel like I am getting used to the more advanced haskell stuff :) (until I try using Lenses I guess)
17:46:32 <Axman6> koz_: https://github.com/MitchStevens/ComonadicUITalk
17:48:55 <koz_> Axman6: Thanks!
18:01:04 <sethetter> dmwit, hpc, Rembane: thanks for the input earlier! Been exploring using type holes and it's been enlightening.
18:09:24 <dmwit> turab: https://hackage.haskell.org/package/effect-stack-0.1.0.0
18:11:06 <dmwit> turab: Then your cpsApp would be have a type like `(MonadState Int m, StackStack m, MonadState [Exp] (PopState m)) => [Exp] -> m ((Exp -> Exp) -> Exp)` and instead of `lift get` you would `liftState get`.
18:11:20 <dmwit> s/StackStack/StateStack/
18:13:24 <Axman6> clever: from our talk the other day, you might find this interesting: http://hackage.haskell.org/package/feldspar-language-0.7
18:15:03 <turab> Nice :D
18:15:11 <turab> dmwit: Thanks again!
18:17:07 <clever> Axman6: neat
18:32:59 <Axman6> also Atom is worth looking at 
18:46:10 <koz_> Can I do something like line continuations in a cabal file? I have a very long entry, and I don't want to have one massive line if I can help it.
18:50:03 <koz_> Also, for ld-options, I need to pass a GNU-style --option. Will the cabal file treat it as a comment?
18:51:11 <Axman6> it shouldn't
18:51:19 <Axman6> comments are "-- "
18:51:20 <koz_> Axman6: OK, that's good to know.
18:51:24 <heatsink> Cabal allows line breaks.  Subsequent lines need to be indented as much as the first line
18:51:24 <Axman6> iirc
18:51:34 <koz_> heatsink: OK, thanks. Axman6: I shall try and see then!
18:56:50 <koz_> Axman6: It appears you are correct.
18:57:05 <koz_> So it's a bug in vim's ... whatever the thing that determines comments.
19:28:53 <butterth_> What's a good book for intermediate haskell?
19:29:33 <butterth_> I have a good understanding of what a monad is, but I want to understand how exceptions work, how transformers work, how continuations work (especially in parsing), and so on
19:32:51 <nfd9001> butterth_: i read endorsements of this one quite regularly http://haskellbook.com/
19:33:04 <nfd9001> though i haven't personally gotten to it yet
19:33:58 <butterth_> nfd9001: hmm, that's targeted towards complete beginners though, right?
19:34:27 <nfd9001> for specifically pinning down exceptions/transformers/continuations/..., you may do just fine filling in your understanding with a range of tutorials
19:34:52 <nfd9001> i don't know of one specific book to suggest that would hit all of those, but i'm also not a Top High Expert
19:35:30 <maerwald> and its not free
19:35:51 <nfd9001> yeah
19:36:10 <nfd9001> https://wiki.haskell.org/Typeclassopedia is a good read in my experience and it covers some of those questions
19:38:13 <nfd9001> specifically transformers, and it kind of does give you enough knowledge to begin to approach exceptions
19:39:23 <nfd9001> not necessarily the way Control.Exception does it, but it does discuss how Alternative can be used to propagate errors
19:42:29 <butterth_> nfd9001: thanks for the recommendation, I'll take a look
19:50:00 <DrDuck> Could anyone explain what such a type does? Seems wild to me. (a -> b) -> a -> b
19:51:23 <Cale> DrDuck: A function of that type more or less has to be the identity function on functions.
19:51:54 <Cale> i.e. it's taking a function (of some arbitrary type a -> b), and producing a function of that same type
19:52:11 <Cale> Alternately, it's taking such a function, and an argument of type a, and producing a result of type b
19:52:48 <Cale> (the only difference is how you choose to think about it, these are the same thing)
19:52:59 <maerwald> deriveJSON doesn't work with type aliases or parametrised types?
19:53:36 <Cale> That sounds plausible to me
19:54:04 <maerwald> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Pico
19:55:50 <Cale> Shouldn't be too hard to write an instance by hand at least
19:55:59 <maerwald> well, it's not json, but yeah
19:56:19 <maerwald> using https://hackage.haskell.org/package/aeson-typescript-0.2.0.0/docs/Data-Aeson-TypeScript-TH.html
19:56:47 <maerwald> still not sure it was a good decision to pick that library :>
19:57:10 <DrDuck> That is whacky. Thanks, Cale.
20:17:35 <nfd9001> Anyone have any experience porting old base Data.Hashtable code to the new hashtables library?
20:19:05 <nfd9001> I'm having some trouble coercing the types into checking out
20:22:57 <nfd9001> forgive me for sending the context this way; everything was just lined up right and then I believe I managed to freeze Vim
20:23:08 <nfd9001> https://files.catbox.moe/36d2x3.png
20:24:26 <Guest_33> I am a new user on mac and am having trouble with the installation process. I followed the steps on https://www.haskell.org/ghcup/ and the installation completed. I am unable to run ghci. 
20:24:31 <Guest_33> I am running zshell
20:24:41 <Guest_33> Is there anyone that can give me some guidance?
20:25:16 <nfd9001> i'm trying to get an IOHashTable from hashtables into log, but when I key everything in, it begins to expect a different type
20:28:02 <nfd9001> e.g. log <- HT.new :: CuckooHashTable Int TupleServerMsg causes GHC to complain that it was expecting a different type
20:28:15 <nfd9001> Guest_33: what are you trying to do to run it? what happens?
20:30:12 <nfd9001> (specifically, when I do that, GHC expects an IO TupleServerMsg and i'm not sure why
20:31:11 <Guest_33> I am just trying to run the interactive shell using ghci (I am reading Learn You a Haskell by Lipovaca)
20:31:27 <nfd9001> cool. how are you trying to launch it?
20:31:36 <Guest_33> I don't know that I have my PATH set up correctly in ~/.zshrc
20:31:41 <Guest_33> I'm just typing ghci
20:32:44 <nfd9001> Guest_33: https://stackoverflow.com/questions/32920452/how-to-run-haskell-on-osx-el-capitan#32920645 any of these appear relevant?
20:34:04 <nfd9001> also, https://wiki.haskell.org/Mac_OS_X under GHC
20:34:59 <maerwald> Guest_33: what is your PATH
20:35:09 <nfd9001> (if none of those end up relevant, cool, just covering some bases)
20:40:39 <Guest_33> Installation done!Don't forget to source /Users/adammartin/.ghcup/env in your ~/.bashrc or similar. This is what I got when the installation completed.
20:40:59 <nfd9001> Oh, do that!
20:41:55 <Guest_33> I tried adding export PATH=$PATH:"/users/adammartin/.ghcup/env:$PATH" to my ~/.zshrc
20:42:03 <Guest_33> Is that what it is telling me to do?
20:42:16 <nfd9001> looks about right, yeah
20:42:47 <nfd9001> then do "source ~/.zshrc" and try ghci again
20:43:05 <Guest_33> I did that and it still does not work.
20:43:19 <nfd9001> hmm. does launching ghci fully-qualified work?
20:43:32 <Guest_33> When I run echo $PATH it does appear to be in the path
20:43:38 <nfd9001> like, go visit ~/.ghcup/env/
20:43:42 <nfd9001> and ./ghci
20:46:54 <Guest_33> Oh shit I don't actually have the .ghcup directory
20:47:02 <Guest_33> The install said it would create the directory
20:47:05 <nfd9001> that's... concerning!
20:47:17 <nfd9001> seems like the install may have quietly failed, then?
20:47:48 <nfd9001> perhaps try reinstalling and see if that fixes it
20:48:28 <nfd9001> (i don't have a mac handy with which to test that install script, so i'm just operating on intuition here)
20:48:49 <maerwald> Guest_33: the installation failed? Show the output
20:48:54 <maerwald> Otherwise we are just guessing
20:49:39 <Guest_33> Ok I redid the install and I do now have that directory and I can launch ghci from ~/.ghcup/env/
20:49:48 <nfd9001> and unqualified?
20:50:03 <nfd9001> that is, by writing "ghci" from another folder
20:50:28 <Guest_33> Still nothing.
20:50:56 <nfd9001> try doing "source ~/.ghci" one more time
20:51:01 <nfd9001> then do it
20:51:02 <maerwald> what?
20:51:10 <nfd9001> sorry
20:51:12 <nfd9001> lol
20:51:13 <maerwald> what is ~/.ghci?
20:51:19 <maerwald> don't source random files
20:51:20 <nfd9001> "source ~/.zshrc"
20:51:23 <nfd9001> qwertial aphasia
20:51:28 <nfd9001> XD
20:51:51 <Guest_33> I have run the source command and was still unable to launch it else where.
20:52:04 <maerwald> then your PATH is incorrect
20:52:10 <maerwald> show your PATH
20:55:56 <Guest_33> .
20:56:19 <maerwald> what is that
20:56:40 <Guest_33> I'm not sure if there is a limit on how many characters can be in this chat but the path is not posting. I will break it up
20:56:50 <maerwald> use a pastebin
20:57:03 <nfd9001> https://paste.ubuntu.com/
21:00:32 <nitrix> Can someone confirm the last line is saying `use a pastebin`? My bouncer seems to be dropping messages from some unknown reason.
21:00:45 <nitrix> I think I just caught it doing it.
21:01:01 <nfd9001> second-to-last was. i linked a pastebin right after
21:01:14 <nfd9001> about 41 seconds past the minute
21:01:29 <maerwald> nitrix: isn't that what a bouncer is for? not let everyone in? :>
21:01:32 <maerwald> badum-tss
21:01:55 <nitrix> Ah! Definitely has an issue! That's useful, thanks nfd9001.
21:02:00 <nfd9001> no prob
21:05:13 <Guest_33> https://paste.ubuntu.com/p/cZRnRsk47q/plain/
21:05:38 <Guest_33> I've never used a pastebin before that may have been wrong
21:06:02 <nfd9001> yeah, i was not expecting to be asked to log in
21:06:31 <nfd9001> links should look like this
21:06:31 <nfd9001> https://paste.ubuntu.com/p/bGPRwRTyHz/
21:06:52 <Guest_33> Gotcha maybe this one
21:06:53 <nfd9001> so https://paste.ubuntu.com/p/cZRnRsk47q/
21:06:54 <Guest_33> https://paste.ubuntu.com/p/cZRnRsk47q/
21:06:55 <nfd9001> that works
21:07:38 <nfd9001> that is one clumsy-looking path
21:07:59 <Guest_33> Yes it is
21:07:59 <nfd9001> honestly kind of impressive ngl
21:08:22 <nfd9001> it definitely seems to have the important bits...
21:08:25 <maerwald> your PATH is incorrect, you didn't follow the instructions
21:08:57 <maerwald> https://gitlab.haskell.org/haskell/ghcup/tree/master#installation
21:09:14 <nfd9001> the right dir is in there, but it's a wee bit messy
21:09:27 <maerwald> source "$HOME/.ghcup/env"
21:09:28 <maerwald> ^ Add this to your ~/.zshrc
21:09:45 <maerwald> nfd9001: no
21:09:48 <nfd9001> add the cabal part too
21:10:43 <nfd9001> maerwald: huh, does it really mandate that you use $HOME and not the full path?
21:12:35 <Guest_33> That worked. I had not been to the repo only haskell.org. Thank you so much for your help you two!
21:12:50 <nfd9001> glad it's working :D
21:41:36 <doughmouse> ...I have a Question About Types, if this is the right sort of place for that
21:44:34 <c_wraith> doughmouse: if it's about Haskell in particular, 100%.  If it's near haskell, it's usually fine
21:45:49 <doughmouse> yes, it's definitely Haskell. I've ended up with a `type Lift n t kind m = (MonadTrans t, kind n, m ~ t n)` type, mainly because I was curious if it would work, for default signatures in MTL. but now my default signatures start with "Lift n t MyMonad m" and n and t appear nowhere else, which seems a bit silly
21:46:00 <doughmouse> is there forall trickery or something that could get rid of the extra variables?
21:52:08 <doughmouse> I'm sure the main answer is "well don't do that." I'm just curious if it can be done
21:54:06 <c_wraith> May not get a lot of answers right now.  The most awake region that contributes here right now is north america, and it's currently a USA holiday.
22:31:12 <maerwald> c_wraith: don't forget Singapore :P
22:32:08 <Axman6> or 'straya
22:32:35 <Axman6> thought the Queensland lot tend to stick to their own channel
22:34:46 <koz_> Is there a reason why Data.ByteString.Unsafe.unsafePackC* functions are in IO?
22:35:36 <cocreature> koz_: the contents at the pointer you are reading from can change
22:35:49 <koz_> cocreature: Ah, OK, so that's why.
22:35:53 <koz_> Makes sense, thanks.
22:38:51 <Nevoic> Does anyone know of a type that allows you to "traverse" or "consume" two monads at once? Right now I have a monad that encapsulates IO, so I'm able to do `liftIO`, but I don't like having every other statement be `liftIO`, it impairs readability IMO.
22:39:08 <Sir_Cheer> .OMI ytilibadaer sriapmi ti ,`OItfil` eb tnemetats rehto yreve gnivah ekil t'nod I tub ,`OItfil` od ot elba m'I os ,OI setaluspacne taht danom a evah I won thgiR ?ecno ta sdanom owt "emusnoc" ro "esrevart" ot uoy swolla taht epyt a fo wonk enoyna seoD
22:39:10 <Nevoic> I'd prefer to be able to execute IO statements in the `do` block, as well as statements in the monad I'm in without having to lift either one out into the other.
22:41:57 <doughmouse> A lot of libraries like classy-prelude replace most IO functions with MonadIO equivalents
22:42:08 <doughmouse> Dunno if that helps
22:43:20 <Axman6> If you have lots of IO statements being lifted into your monad consequtively, then just out them in a do block: liftIO $ do ...
22:44:59 <Axman6> put*
22:48:03 <suzu> i can't make these existential types unify
22:48:38 <suzu> err one esc
22:48:42 <suzu> let me figure out how to phrase my problem
22:48:47 <dminuoso> % :i Bitraverse -- Nevoic 
22:48:47 <yahb> dminuoso: ; <interactive>:1:1: error: Not in scope: `Bitraverse'
22:48:59 <dminuoso> % import Data.Bitraverse
22:49:00 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Data.Bitraverse'; Perhaps you meant Data.Bitraversable (from base-4.12.0.0)
22:49:13 <dminuoso> % import Data.Bitraversable
22:49:13 <yahb> dminuoso: 
22:49:15 <dminuoso> % :i Bitraverse -- Nevoic 
22:49:16 <yahb> dminuoso: ; <interactive>:1:1: error: Not in scope: `Bitraverse'
22:49:18 <cocreature> dminuoso: that doesn‚Äôt seem to actually help with the question if you read it to the end ;)
22:49:23 <dminuoso> Oh lord. :<
22:49:40 <dminuoso> cocreature: Huh?
22:49:45 <Axman6> % :i Bitraversable
22:49:45 <yahb> Axman6: class (Bifunctor t, Data.Bifoldable.Bifoldable t) => Bitraversable (t :: * -> * -> *) where; bitraverse :: Applicative f => (a -> f c) -> (b -> f d) -> t a b -> f (t c d); -- Defined in `Data.Bitraversable'; instance Bitraversable Either -- Defined in `Data.Bitraversable'; instance Bitraversable Const -- Defined in `Data.Bitraversable'; instance Bitraversable ((,,,,,,) x y z w v) -- Defined in `Da
22:50:04 <suzu> so i'm using beam
22:50:05 <cocreature> dminuoso: I don‚Äôt see how Bitraversable helps you avoid having to call liftIO
22:50:07 <suzu> there's this function
22:50:08 <Sir_Cheer> aD` ni denifeD -- (v w z y x (,,,,,,)) elbasrevartiB ecnatsni ;'elbasrevartiB.ataD` ni denifeD -- tsnoC elbasrevartiB ecnatsni ;'elbasrevartiB.ataD` ni denifeD -- rehtiE elbasrevartiB ecnatsni ;'elbasrevartiB.ataD` ni denifeD -- ;(d c t) f >- b a t >- (d f >- b) >- (c f >- a) >= f evitacilppA :: esrevartib ;erehw (* >- * >- * :: t) elbasrevartiB >= (t elbadlofiB.elbadlofiB.ataD ,t rotcnufiB) 
22:50:08 <Sir_Cheer> ssalc :6namxA
22:50:17 <suzu> insertExpressions :: forall syntax table s. (Beamable table, IsSql92InsertValuesSyntax syntax) => (forall s'. [table (QExpr (Sql92InsertValuesExpressionSyntax syntax) s')]) -> SqlInsertValues syntax (table (QExpr (Sql92InsertValuesExpressionSyntax syntax) s)) 
22:50:17 <Axman6> @where ops
22:50:17 <dminuoso> cocreature: Oh I just couldn't connect the first part to the second part.
22:50:18 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
22:50:38 <suzu> it wants this: (forall s'. [table (QExpr (Sql92InsertValuesExpressionSyntax syntax) s')])
22:50:43 <suzu> and im pretty sure i have it
22:50:46 <dibblego> Axman6: wtf is this?
22:50:51 <suzu> but it says s' doesnt match s0
22:51:03 <Axman6> dibblego: Sir_Cheer ^
22:51:13 <suzu> plz kick this stupid reversing bot
22:51:21 <dminuoso> cocreature: Oh now I just parsed it proprely, I see.
22:51:36 * Sir_Cheer sniffs glue
22:51:37 <dminuoso> Nevoic: You could also look into writing your code polymorphic over MonadIO and ensure your monad has an instance MonadIO.
22:51:54 <dibblego> Sir_Cheer: stop please
22:56:28 <suzu> wtf
22:56:58 <dminuoso> suzu: Those are not existentials, those are universal quantifications.
22:57:10 <suzu> i don't understand
22:57:15 <dminuoso> suzu: The function demands a polymorphic value.
22:57:30 <suzu> so, it needs this: (forall s'. [table (QExpr (Sql92InsertValuesExpressionSyntax syntax) s')])
22:57:44 <suzu> and i have one. let's call it `bar`
22:57:57 <suzu> if i do `let bar = ...; insertExpressions bar`
22:58:07 <suzu> it says nah sorry s' doesn't match s0
22:58:18 <suzu> but if i do `insertExpressions ...` directly, without the `let`
22:58:21 <suzu> it will typecheck.
22:58:29 <dminuoso> suzu: Monomorphism restriction?
22:58:47 <suzu> is it picking an `s` for me?
22:59:16 <suzu> i tried `let bar = ... :: forall s. FooType s`
22:59:18 <suzu> deliberately
22:59:20 <suzu> it didn't like that
22:59:24 <suzu> as in, same error
22:59:30 <dminuoso> suzu: Can you gist the code?
23:00:10 <suzu> i'll pastebin it, with some notes
23:00:21 <suzu> first let me try turning off the monomorph restriction
23:00:26 <suzu> and see if that makes GHC happy
23:00:49 <dminuoso> suzu: if it does, that's not a good fix - but it may be the easier way to test if thats the issue.
23:02:41 <suzu> that didn't help
23:03:33 <suzu> dminuoso: this is almost exactly the kind of code i have
23:03:39 <suzu> https://github.com/tathougies/beam/issues/364#issuecomment-480244118
23:03:47 <suzu> Beam.insertExpressions [notebook]
23:03:49 <suzu> this works
23:03:58 <suzu> `let foo = [notebook]; Beam.insertExpressions foo`
23:04:00 <suzu> this does not
23:04:37 <suzu> it claims that the `s` in :: Db.CachedNotebookT (Beam.QExpr Beam.Sqlite s) can't be matched against some other `s`
23:05:38 <dminuoso> suzu: Can you perhaps share the code you have, and not reference code that is almost like the one you have?
23:05:55 <suzu> okay, i'll be less lazy :)
23:06:02 <suzu> one moment
23:11:25 <suzu> dminuoso: https://pastebin.com/JNqWQySD
23:13:09 <dminuoso> suzu: Can you include the full diagnostic please? Im curious about the detailf of `relevant bindings include...`
23:13:53 <suzu> that's actually all of it
23:14:06 <dminuoso> suzu: Fair enough. How and where is ‚åúorders‚åù defined?
23:14:12 <suzu> there is the single relevant binding and it doesnt print th erest
23:14:20 <dminuoso> oh wait, it's above interesting.
23:14:23 <suzu> `orders` is the comment
23:14:24 <suzu> s
23:14:37 <dminuoso> suzu: Heh I mentally skipped those comments. :)
23:14:47 <suzu> :)
23:15:08 <dminuoso> suzu: Try giving orders an explicit type signature.
23:15:50 <suzu> what signature should i give it?
23:16:41 <suzu>       let orders = (flip fmap (rights processing) $ \(pgs, sid) -> makeOutOrder m acc num pgs sid targete164) :: forall ss. [OutboundOrderT (Beam.QExpr Beam.SqliteExpressionSyntax ss)]
23:16:46 <suzu> this doesn't change anything
23:17:02 <dminuoso> suzu: Not on the right hand side expression. Put it on the binding orders
23:17:10 <dminuoso> let orders :: ...; orders = ....
23:17:12 <suzu> oh. is that different?
23:17:19 <dminuoso> suzu: Yes.
23:17:27 <dminuoso> suzu: Im still thinking it's MMR.
23:17:52 <suzu> now i get new errors!
23:18:22 <suzu> ill paste
23:18:50 <suzu> dminuoso: https://pastebin.com/raw/MuEDNPHa
23:21:02 <dminuoso> suzu: Thats something different again!
23:21:38 <suzu> i don't know how to get these to match
23:21:55 <dminuoso> suzu: Try two separate lines like you usually do.
23:21:58 <suzu> i tried doing `makeOutOrder ::   Mail -> Account -> Number -> Integer -> Text -> Text -> forall s. OutboundOrderT (Beam.QExpr Beam.SqliteExpressionSyntax s)`
23:22:02 <dminuoso> suzu: orders :: ...; orders = ....
23:22:30 <suzu> err i did that
23:22:34 <dminuoso> suzu: No you did not.
23:22:40 <suzu>       let orders :: forall ss. [OutboundOrderT (Beam.QExpr Beam.SqliteExpressionSyntax ss)] = (flip fmap (rights processing) $ \(pgs, sid) -> makeOutOrder m acc num pgs sid targete164) 
23:22:41 <dminuoso> suzu: You wrote a pattern type annotation.
23:22:46 <dminuoso> suzu: That's not the same thing.
23:22:49 <suzu> oh im blind
23:23:05 <suzu> ok that worked
23:23:11 <suzu> can you explain wtf just happened
23:23:17 <dminuoso> suzu: MMR happened
23:23:46 <dminuoso> suzu: What you wrote is a pattern type annotation, like `Just (x :: Int) = ...`
23:24:10 <suzu> ghc dropped the "pick any ss you'd like, as many times as you'd like" for "pick an ss once"?
23:24:12 <dminuoso> suzu: Remember that `orders` is strictly speaking a pattern (it's an irrefutable pattern, but a pattern nonetheless)
23:24:34 <dminuoso> suzu: Then the subtleties of monomorphism restriction punched you in the face.
23:25:01 <suzu> could you explain in a little more detail please
23:25:10 <suzu> im still a bit confused what ghc did here and what information was lost
23:25:33 <suzu> so every time i did `let orders = ...` ghc just threw away the forall?
23:25:40 <suzu> because of the mmr?
23:25:47 <dminuoso> suzu: So I dont fully understand why the pattern type annotation went wrong, I just recall helping another person that did the exact same mistake.
23:26:16 <dminuoso> In a similar situatoin.
23:26:45 <suzu> are `forall s. Foo s` and `Foo s` the same type?
23:27:05 <dminuoso> suzu: No necessarily, but that's not the issue here.
23:27:21 <suzu> ghc picked an s
23:27:23 <dminuoso> suzu: (well they are the same type, but they could have different meanings in some situatoins)
23:27:35 <suzu> right, scopedtypevariables would let you refer to that `s`
23:27:39 <suzu> if you are explicit about it
23:27:39 <dminuoso> suzu: Right.
23:27:52 <dminuoso> suzu: And depending on how you set parens, they could be very different things.
23:28:03 <suzu> a -> (forall b. a -> b)
23:28:11 <dminuoso> Right.
23:28:29 <dminuoso> suzu: So the thing about MMR is about the generalization step of type inference.
23:28:35 <suzu> okay
23:30:49 <suzu> is there a more pleasing way to write `let orders :: ...; orders =`
23:30:58 <dminuoso> suzu: During type inference GHC will replace type variables by meta variables, end up with a bunch of equations. The type checker solves that equatoin system.
23:30:58 <suzu> instead of this one long line
23:31:15 <suzu> ah so..
23:31:16 <dminuoso> suzu: And now comes the trick: Any meta variables without a solution are generalized.
23:31:24 <dminuoso> suzu: With one restriction:
23:31:35 <suzu> and somehow it found a solution for s prematurely..?
23:31:42 <dminuoso> No.
23:32:28 <dminuoso> suzu: GHC is not allowed to generalize a meta variable if its "restricted"
23:33:07 <dminuoso> or rather.. its not allowed to generalize meta variables for type variables of a restricted declaration group.
23:33:20 <dminuoso> And `orders` as you had it originally is a restricted declaration group.
23:33:34 <suzu> why is it a restricted declaration group?
23:34:09 <suzu> why didn't it leave `s` general
23:36:10 <dminuoso> suzu: So the haskell report doesnt specify when a group is unrestricted, it specifies when it is.
23:37:02 <dminuoso> suzu: And the specification is roughly: a decl group is unrestricted if its a function binding or a simple pattern binding in which a type annotation is given for every variable bound by that simple pattern binding
23:37:54 <dminuoso> For a decl group to be unrestricted its necessary to satisfy either condition.
23:38:33 <suzu> so if i deliberately give a type signature then it'll be unrestricted
23:38:51 <dminuoso> Exactly.
23:39:04 <suzu> otherwise the mmr is allowed to keep type variables non-general
23:39:11 <dminuoso> Worse.
23:39:16 <dminuoso> It's not allowed to generalize.
23:39:30 <suzu> so then what was the type coming out of `orders`?
23:39:36 <suzu> if it didn't have a free `s`
23:40:02 <dminuoso> suzu: That I dont fully understand, honestly.
23:40:14 <suzu> okay
23:40:23 <suzu> so the mmr was swallowing that somehow
23:40:29 <suzu> somewhere a choice of `s` was made
23:40:36 <suzu> or ghc at least thought such
23:40:41 <dminuoso> suzu: re generalization: the type inference generalizes everything without a solution, the MMR restricts what may be generalized.
23:41:03 <dminuoso> suzu: There's then a second rule that says any monomorphic type variable at the end is subject to defaulting rules
23:41:16 <dminuoso> So if its left monomorphic, it will then get defaulted.
23:41:57 <dminuoso> suzu: Ohh I see it now!
23:42:08 <suzu> ??
23:42:09 <dminuoso> suzu: The type defaulting happens when type inference for the entire module is complete.
23:42:20 <dminuoso> suzu: So `s` is a monomorphic type variable at that point, not yet defaulted.
23:42:37 <suzu> ???
23:43:01 <dminuoso> suzu: Type inference is checking `orders`, it ends up with no solution for some meta variable _s.
23:43:12 <suzu> right
23:43:13 <dminuoso> Because the decl group is unrestricted, its not allowed to generalize that type variable.
23:43:16 <dminuoso> Its left monomorphic
23:43:27 <suzu> monomorphic with no instance?
23:43:35 <dminuoso> suzu: It will fix that issue later.
23:43:41 <suzu> lol i see
23:43:41 <dminuoso> Once the whole module is complete, it would use type defaulting rules.
23:43:44 <dminuoso> But we dont get that far.
23:43:46 <suzu> right
23:44:19 <suzu> its decided that theres a single instance that fits. so it's not going to fit where a polymorphic s is needed
23:44:38 <suzu> if it got further, would it complain that `s` is ambiguous?
23:48:29 <suzu> how come turning the mmr off doesnt fix it
23:53:44 <dminuoso> suzu: How did you turn it off?
23:54:06 <dminuoso> suzu: By the way, the reason its delayed that far, is to allow for bindings to make sense.
23:54:24 <dminuoso> suzu: Imagine you wrote `a = 5; f :: Float; f = a * 2`
23:54:41 <suzu> with {-# LANGUAGE NoMonomorphismRestriction -#} at the top of the module
23:54:58 <dminuoso> suzu: Did you perhaps forget to save the buffer?
23:55:12 <suzu> maybe? dont think so though
23:55:47 <suzu> ill just assume that i did
23:55:53 <suzu> thats the easier explanation. lol
23:58:13 <suzu> thanks for your help dminuoso! this was really show-stopping me
