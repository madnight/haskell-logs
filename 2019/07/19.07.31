00:24:51 <mniip> wasn't there a package that implemented race :: a -> a -> a
00:25:07 <Axman6> unamb?
00:25:25 <mniip> yes!
01:15:17 <Mo0O> Hi there, I'm using lens-aeson to decode json and want to decode something like "[{\"foo\": 1},{\"bar\":2}]" to [Just 1, Nothing] extracting "foo" values
01:17:39 <Mo0O> but using using `^.. values` doesn't return maybes
01:19:35 <lavalike> Mo0O: I'm gonna guess there's a variant including the character '?' that does
01:23:58 <Mo0O> lavalike: that's exactly what I'm looking for:)
01:24:36 <lavalike> I wonder if combining ^.. and (^? _Foo) is what you want? I don't have enough practice with lens
01:26:11 <Mo0O> that's what I'm trying, but there looks not compatible
01:26:16 <lavalike> ^.. preview _Fold ?
01:26:30 <lavalike> I don't have the necessary packages to test it locally
01:26:52 <lavalike> there are a bunch of variants of preview maybe it's one of those (:
01:28:01 <Mo0O> will try on that direction, thanks lavalike 
01:28:16 <lavalike> np!
01:40:41 <libertyprime> hey guys. if i were to get an error such as the following (which i did) cabal: Encountered missing dependencies: logict -any, regex-tdfa -any, sbv ==5.*, stream-monad -any
01:40:48 <libertyprime> how would i go about compiling this bad boy
01:41:29 <libertyprime> tried the following commands: cabal configure; cabal install --only-dependencies; cabal build; cabal install
01:42:54 <merijn> libertyprime: Can you pastebin the entire error, because that's not enought o go on
01:43:38 <libertyprime> 1 sec
01:47:16 <libertyprime> merijn: id like to but ive noticed cabal install --only-dependencies was hanging
01:47:19 <libertyprime> http://ix.io/1Q8h
01:47:20 <libertyprime> i have done an strace
01:47:29 <libertyprime> it is looking for something called greencard
01:53:11 <merijn> libertyprime: You can run cabal with -v3 to get more verbose output of what's going on. Unrelatedly to your problem "cabal sandbox" has basically been 100% obsoleted by v2-build
01:53:54 <int-e> except for having a terrible clean-up-the-mess story.
01:54:07 <sclv> the greencard thing is unrelated
01:54:18 <sclv> it searches for a bunch of utils it might possibly need, just to see if they're around
01:54:23 <sclv> some, like greencard, are ancient
01:54:38 <merijn> the strace output doesn't really tell me much/anything, tbh
01:57:34 <libertyprime> merijn: thanks for -v3 tip. i found the reason it was hanging!
01:59:00 <merijn> libertyprime: Anyway, I would recommend seriously considering dropping sandbox for v2-build (after checking/ensuring you have updated to cabal-install 2.4)
02:00:47 <libertyprime> merijn: thanks for that tip also :)
02:01:45 <merijn> libertyprime: It's basically "automatic, transparent, shared sandboxes for everything" https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
02:02:02 <libertyprime> awesome!
02:03:41 <fog> i am trying to build a cabal project with 2 executables and libraries which are supposed to work together 
02:04:13 <fog> the project uses mixins via backpack
02:04:19 <fog> the cabal file is here;
02:04:20 <fog> https://github.com/fog-hs/rotate/blob/master/src%20-%20Copy/rotate.cabal
02:04:43 <fog> with the directory above containing the code
02:05:09 <fog> the buld fails with;
02:05:10 <fog> cabal.exe: Cannot process the executable 'vect-rotate' because this package
02:06:01 <fog> its trying to copy from; https://hackage.haskell.org/package/unpacked-containers-0/src/unpacked-containers.cabal
02:06:52 <fog> can anyone that knows how to build a cabal project explain what the error means and how to fix it?
02:12:45 <fog> cabal.exe: Cannot process the executable 'vect-rotate' because this package
02:13:09 <fog> was configured only to build lib. Re-run configure with the argument executable 'vect-rotate'
02:14:36 <fog> is that meaning that it wants extra flags to; cabal configure rotate
02:14:43 <fog> or that the cabal file is wrong?
02:15:30 <sclv> you need to run configure with arguments for all the targets
02:18:10 <fog> there seems to be a list of flags from running cabal configure --help
02:18:24 <fog> but it isnt at all clear which of those it might need
02:18:34 <sclv> Not flags, targets
02:18:58 <fog> for the multiple exes?
02:19:47 <fog> wouldnt they only be specified at cabal run linear-rotate
02:20:01 <fog> vs cabal run vect-rotate
02:20:15 <sclv> you need to tell it which components to configure for
02:20:21 <fog> ie, at `cabal run' and not `cabal configure'
02:20:48 <sclv> it picks a build plan based on targets
02:21:09 <sclv> So you need to specify all targets at configure time
02:21:13 <fog> oh right like a makefile option like make clean
02:22:42 <fog> if i write; "cabal configure vect-rotate
02:22:47 <fog> it says;
02:22:51 <fog> cabal.exe: Encountered missing dependencies:
02:23:11 <fog> example -any, rotate -any
02:23:33 <sclv> yah you need to specify all targets at once
02:28:46 <fog> cabal configure rotate example vect-rotate linear-rotate
02:28:57 <fog> fails with;
02:28:58 <fog> cabal.exe: Can only configure either single component or all of them
02:29:08 <fog> but just; cabal config
02:29:11 <fog> seems to work
02:29:23 <fog> then it throws errors to do with the source code
02:29:25 <fog> thanks!
02:30:32 <fog> oh wait, no its not config that throws those errors but trying to write; run linear-rotate
02:31:12 <fog> something to do with the mixins probably...
03:13:09 <fog> I have managed to get the backpack example to build!
03:13:13 <fog> it is here; https://github.com/fog-hs/rotate
03:13:44 <fog> it should be possible to download it and build it with cabal
03:17:04 <jgt> in a Yesod app, there's a Widget type defined somewhere, but I can't find where it's defined
03:17:08 <jgt> how do I find it?
03:27:14 <__monty__> @hoogle Widget
03:27:15 <lambdabot> module Yesod.Core.Widget
03:27:15 <lambdabot> module GI.Gtk.Objects.Widget
03:27:15 <lambdabot> GI.Gtk.Objects.Widget newtype Widget
03:28:23 <__monty__> jgt: If you mean how do you get your editor to be able to find it easily, look into "ctags", hasktags is the equivalent for haskell, I personally prefer fast-tags.
03:28:27 <__monty__> @hackage hasktags
03:28:28 <lambdabot> http://hackage.haskell.org/package/hasktags
03:28:31 <__monty__> @hackage fast-tags
03:28:31 <lambdabot> http://hackage.haskell.org/package/fast-tags
03:28:33 <jgt> ah, that's helpful
03:28:36 <jgt> thanks __monty__ 
04:58:47 <inad_smarkets922> Hi
04:58:57 <inad_smarkets922> When I have partial function applications in haskell
04:59:08 <inad_smarkets922> How are they optimized in machine code?
04:59:31 <inad_smarkets922> I mean I can pass around functions which I get from applying the first argument on another function
05:00:27 <merijn> inad_smarkets922: "It Depends (TM)"
05:00:58 <jgt> inad_smarkets922: there are notes on this at least with regards to pointfree style in a chapter towards the end of HPFFP
05:01:05 <jgt> other than that, I don't know
05:01:31 <jgt> the question sounds very open-ended for irc
05:01:47 <merijn> There's also no real single answer, because it depends on lots of things
05:02:50 <merijn> Like: Is the partial application just getting inlined in some other function and just optimised away completely? Is it compiled in a way that it is a partial application at all? (what you consider partial and what looks partial inside generated code might differ quite a bit), etc.
05:03:25 <merijn> In all likelihood this is the wrong question to ask, but the right question depends on what "What do you want to know/learn?"
05:04:30 <inad_smarkets922> merijn, Well, what I would like to know is how machine code is generated from my haskell code since otherwise there is no way to reason about performance
05:06:11 <__monty__> I fear you're in for a very hard time if you want to reason about haskell performance via generated assembler.
05:06:13 <merijn> inad_smarkets922: Reasoning about the performance of lazy code is rather tricky in general and not something you should be doing regularly when you're writing Haskell. I'd focus more on using higher level profiling tools and learning Core if you want to reason about the performance
05:06:56 <merijn> inad_smarkets922: The best pointers for getting a basic, high-level (not quite accurate) view of how GHC produces machine code from Haskell, I'd recommend the STG paper
05:06:59 <merijn> @where stg
05:07:00 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
05:07:08 <__monty__> And you can definitely start from the other end, things like "Don't worry about recursion cause it all boils down to tail-calls." (at least to a good first approximation)
05:07:14 <merijn> inad_smarkets922: That one covers "how do you compile a lazy functional language to x86?"
05:07:34 <jgt> inad_smarkets922: are you actually seeing performance issues in your work? Or is this purely academic?
05:07:35 <merijn> inad_smarkets922: There's also the "How to make a Fast Curry" paper which deals with "how do you compile closures and partial function applications"
05:07:48 <merijn> inad_smarkets922: Both should be very readable if you're used to thinking in terms of machine code
05:08:08 <merijn> The fast curry paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf
05:08:13 <inad_smarkets922> jgt, Well, it's not purely academic. I mean we use haskell at work. I just want to have a better understanding of how this works
05:08:38 <inad_smarkets922> merijn, Thanks merijn! I'll have a read of these papers.
05:09:41 <merijn> inad_smarkets922: They won't be "now I know the assembly code this turns into!" (then again, you don't know that for modern C compilers either :p), but it will give you some intuition for "how do you even compile a lazy language to a strict sequential machine?!"
05:10:26 <inad_smarkets922> Yeah I guess the intuition is a good first step
05:11:44 <maralorn> inad_smarkets922: I think a reasonable but not definite approach would be to learn about core and ghc optimiser passes. That will give you at least a better understanding about what questions to ask. I just watched a very nice talk about it by simonpj: https://www.youtube.com/watch?v=uR_VzYxvbxg
05:12:19 <merijn> maralorn: Right, but I'd definitely do STG paper *first*, then dive deeper into that stuff ;)
05:12:57 <maralorn> merijn: I don‘t know that paper so I can‘t tell.
05:13:35 <maralorn> merijn: So I am pretty sure you are right. ;-)
05:21:11 <maralorn> Does anyone know when the Zurihac talk recordings will be online? I am very much looking forward to it.
05:25:37 <kuribas> :t mconcat
05:25:40 <lambdabot> Monoid a => [a] -> a
05:25:56 <kuribas> why not Monoid a, Foldable t => t a -> a ?
05:26:31 <kuribas> @hoogle (Monoid a, Foldable t) => t a -> a
05:26:32 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
05:26:32 <lambdabot> Protolude fold :: (Foldable t, Monoid m) => t m -> m
05:26:32 <lambdabot> RIO.Prelude fold :: (Foldable t, Monoid m) => t m -> m
05:26:35 <merijn> kuribas: Because Foldable wasn't in prelude at the time
05:26:54 <kuribas> ah, it's called fold :-)
05:27:39 <maralorn> @hoogle (Semigroup a, Foldable t) => a -> t a -> a
05:27:40 <lambdabot> Data.Semigroup.Foldable intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m
05:27:40 <lambdabot> Rebase.Prelude intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m
05:27:40 <lambdabot> Data.Foldable1 intercalate :: (Foldable1 f, Semigroup a) => a -> f a -> a
05:28:28 <maralorn> Hm, not sure if that was what I was looking for.
05:29:35 <maralorn> :t fold1
05:29:36 <lambdabot> error:
05:29:37 <lambdabot>     • Variable not in scope: fold1
05:29:37 <lambdabot>     • Perhaps you meant one of these:
05:30:03 <maralorn> :t Data.Semigroup.Foldable.fold1
05:30:06 <lambdabot> (Data.Semigroup.Foldable.Class.Foldable1 t, Semigroup m) => t m -> m
05:30:46 <kuribas> maralorn: you want fold f (<|> x) ?
05:31:14 <kuribas> erm fold f t <|> x ?
05:32:00 <kuribas> ah I see, you want it over a semigroup
05:32:17 <phadej> type of fold is often too polymorphic, leaves ambiguous type variables behind
05:32:25 <maralorn> kuribas: Yeah, but then you need an initial akkumulator.
05:33:28 <maralorn> Interestingly intercalate1 would actually simplify to fold when used with mempty on a monoid. But it does not do the right thing for non monoids.
05:45:14 <kuribas> what's a good base version for ghc that you could use?  I'd like to pin down a version with stack, so I don't need to worry about conflicting libraries, etc...
05:45:27 <xsperry> @hoogle [(Maybe a, Maybe b)] -> [(a, b)]
05:45:28 <lambdabot> No results found
05:45:38 <kuribas> obviously the latest ghc would be to bleeding edge
05:46:18 <Rembane> Well, the last 8.4? 
05:46:31 <Rembane> I always use the latest, but I've been lucky so far.
05:46:31 <kuribas> Rembane: is it stable?
05:46:37 <Rembane> kuribas: I think so. 
05:47:09 <Rembane> kuribas: It was last time I used it. Now I use the latest version that stack gives me when I run a LTS from Stackage.
05:47:19 <maralorn> kuribas: Not using the latest ghc sounds to me like not using the latest firefox.
05:47:40 <kuribas> maralorn: so a good idea?
05:47:58 <maralorn> kuribas: I don‘t see a reason to.
05:49:05 <maralorn> kuribas: I think the pain happens when switching major versions. But unless there is a known regression which affects your usecase in the current stable ghc I don’t see a reason not to use it.
05:49:26 <kuribas> maralorn: the latest ghc releases often have bugs
05:50:02 <maralorn> kuribas: More bugs then older versions?
05:50:06 <kuribas> yes
05:50:23 <kuribas> well, I hope bugs in older versions get fixed
05:50:55 <xsperry> all older versions were latest at some point
05:51:31 <maralorn> xsperry: But they get bug fix releases.
05:52:29 <kuribas> :t mapMaybe (uncurry (liftA2 (,)))
05:52:31 <lambdabot> [(Maybe a, Maybe b)] -> [(a, b)]
05:52:44 <xsperry> :t mapMaybe
05:52:46 <lambdabot> (a -> Maybe b) -> [a] -> [b]
05:53:13 <xsperry> :t mapMaybe id
05:53:15 <lambdabot> [Maybe b] -> [b]
05:53:29 <kuribas> :t catMaybes
05:53:31 <lambdabot> [Maybe a] -> [a]
05:57:20 <xsperry> full context: mapMaybe (uncurry (liftA2 (,))) $ zip xs ys
05:57:33 <xsperry> can that be cleaned up further?
05:58:13 <Rembane> :t zipWith
05:58:15 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:58:47 <Rembane> :t ((.).(.)) mapMaybe (zipWith liftA2)
05:58:49 <lambdabot> error:
05:58:49 <lambdabot>     • Couldn't match type ‘[f b -> f c]’ with ‘a1 -> Maybe b1’
05:58:49 <lambdabot>       Expected type: [a -> b -> c] -> [f a] -> a1 -> Maybe b1
05:58:58 <Rembane> Bah. 
06:00:30 <kuribas> :t \xs ys -> catMaybes $ zipWith (liftA2 (,)) xs ys
06:00:34 <lambdabot> [Maybe a] -> [Maybe b] -> [(a, b)]
06:01:03 <kuribas> xsperry: ^^ ?
06:01:10 <xsperry> types look good
06:02:01 <xsperry> > catMaybes $ zipWith (liftA2 (,)) [Nothing, Just "foo", Just "bar"] [Just 10, Nothing, Just 20]
06:02:08 <lambdabot>  mueval-core: Time limit exceeded
06:02:09 <fendor> >  (\xs ys -> catMaybes $ zipWith (liftA2 (,)) xs ys) [Just 2, Nothing, Just 3] [Just "t", Just "v", Nothing]
06:02:14 <lambdabot>  [(2,"t")]
06:02:27 <xsperry> time limit exceeded?
06:03:13 <xsperry> it works correctly
06:03:21 <merijn> xsperry: lambdabot's server is a bit slow these days
06:03:31 <merijn> xsperry: So sometimes it times out on small/reasonable things
06:07:20 <maralorn> kuribas: I just read "In particular, LTS Haskell will often—but not always—avoid upgrading to the first point release of GHC releases (e.g., 8.2.1) to allow further testing and to get the benefits of the first bugfix release (e.g., 8.2.2)." on Stackage.
06:08:02 <maralorn> From that I would I deduce: Use 8.6.x because it already had some bugfix versions.
06:13:02 <c_wraith> isn't 8.8 still in release candidates anyway?
06:13:25 <merijn> It is
06:14:00 <c_wraith> So yeah, use 8.6 unless you're updating libraries for 8.8 compatibility or testing a new feature.
06:22:15 <nxz> hello what logging library supports ansi terminal codes with color?
06:22:45 <nxz> i am looking at monad-logger but it doesn't support it :(
06:23:30 <merijn> nxz: monad-logger provides two completely separate things
06:23:59 <nxz> there is LoggingT in it 
06:24:00 <merijn> nxz: It provides an abstract logging class for doing logging AND LoggingT which is one possible implementation of it
06:24:11 <nxz> it has concrete implementations
06:24:28 <merijn> nxz: You can use the monad-logger interface without LoggingT by writing your own instance that implement coloured terminal output
06:25:11 <merijn> nxz: Hell, you could even use LoggingT if you implement an approriate functions to unwrap it with
06:25:19 <nxz> merijn: okay but are there any library that do that? or any supporting library
06:25:31 <merijn> Maybe, I don't know?
06:25:41 <kuribas> maralorn: sounds good :)
07:14:18 <Darwin226> Is there a way to have guards in a unidirectional pattern synonym?
07:14:35 <Darwin226> Basically I want `pattern Pat n = n | n >= 100 && n < 200`
07:15:05 <Darwin226> that first `=` should be `<-`
07:18:27 <lyxia> ViewPatterns allow patterns with arbitrary logic
07:19:07 <Darwin226> and I guess I can combine that with Maybe to get what I want
07:19:12 <lyxia> yes
07:19:13 <Darwin226> but it sounds overheady
07:19:23 <merijn> pattern guards >= ViewPatterns
07:19:32 <merijn> If only because the former is not an extension
07:19:49 <Darwin226> I'm trying to define a pattern synonym anyways so extensions are already in play
07:56:01 <inad_smarkets922> Is there a way to get the source code of the implementation of a typeclass for a specific type in ghci? For example "instance Eq Int"
07:56:26 <xsperry> I don't think there is
07:56:40 <merijn> inad_smarkets922: Not in ghci, but the Haddock documentation on hackage has source links
07:57:38 <merijn> Underneath the class where it lists instances, the instance should have a #source link that, well, links to the source :p
07:57:49 <inad_smarkets922> merijn, Is there a cli version of this lookup?
07:57:59 <inad_smarkets922> I use the source links quite often
07:58:09 <inad_smarkets922> It's just a hassle to click through the links all the time
07:58:10 <merijn> Not that I know off?
07:58:44 <mmaruseacph2> :info ?
07:59:01 <mmaruseacph2> oh, I don't think it works for a specific instance
07:59:44 <xsperry> what tor package do you recommend for fetching html through tor network? I see several on hackage
08:01:25 <geekosaur> hm. at least hypothetically there might be a way to use local haddock / hoogle
08:01:59 <geekosaur> sadly, haddock's gotten more and more js-happy over the years, which makes it rather less cli-friendly
08:07:59 <inad_smarkets922> merijn, Seems like there is something similar -> https://wiki.haskell.org/Hoogle#GHCi_Integration
08:08:08 <inad_smarkets922> Still no source code though 
08:09:39 <merijn>  That's because Hoogle only deals with names and types
08:18:56 <geekosaur> but it can link to haddocks, which is what I could see someone figuring out how to feed to a cli browser or something, maybe
09:16:28 <wroathe> megaparsec is awesome
09:16:58 <ovitus> anyone know how to create a markov chain randomizer?
09:17:54 <__monty__> ovitus: I have a markov chain message generator if that's what you're after.
09:19:17 <ovitus> basically looking on how to write a simple function that takes # of possible events, but then randomizes it
09:19:34 <ovitus>          [ [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         , [0,0,0,0,0,0,0,0]         ] 
09:19:54 <ovitus> that has 8 events
09:19:56 <ovitus>          [ [2,0,1,0,3,0,4,0]         , [0,0,0,0,4,0,6,0]         , [0,6,0,3,0,1,0,0]         , [4,0,1,1,2,0,0,2]         , [0,3,1,0,3,0,3,0]         , [2,0,0,0,8,0,0,0]         , [0,1,1,2,2,0,4,0]         , [4,0,0,2,0,0,3,1]         ]
09:20:33 <ovitus> something that can randomize chains like that
09:26:29 <infinisil> ovitus: Fill it with random numbers?
09:27:55 <infinisil> I don't know much about markov chains though, why do all of them sum to 10?
09:29:27 <infinisil> I'd imagine they should sum to 1, since it's a probability
09:37:36 <argent0> P(X|Y) = P(X,Y)/P(Y) so you could just generate P(X,Y), normalize, and compute P(Y), then P(X|Y). X,Y \in the state space.
09:42:53 * argent0 🤔
09:52:36 <oats> are there any resources for understanding how haskell (or functional languages in general) can be compiled to imperative languages, like assembly?
09:53:21 <boj> oats: maybe take a look at https://ivorylang.org
09:53:56 <dmwit> oats: The STG machine paper is very approachable, and is exactly about that. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&rep=rep1&type=pdf
09:54:15 <dmwit> Plus at the end of it, you'll have a very good mental model of how GHC in particular works!
09:54:34 <oats> dmwit: that looks very cool, thanks :)
09:54:52 <oats> boj: that also looks cool, but I'm not sure what it has to do with what I asked about
09:55:15 <boj> oats: it is the application of what you asked about, and likely has related material to read through
09:57:36 <oats> boj: cool, I'll check it out more closely. thanks :)
10:03:11 <wroathe> I'm trying to define an operator: &t and getting a parse error on my fixity declaration, is &t not valid?
10:03:19 <wroathe> infixr 7 &t
10:05:39 <nshepperd> Ivory is more compiling an imperative DSL within haskell to imperative languages than compiling haskell itself
10:07:55 <Boarders> Is there a standard way to show a Word8 as bits?
10:09:34 <Boarders> or as [Bool]
10:09:37 <dmwit> wroathe: Correct: only punctuation may be used in infix operator names.
10:09:55 <dmwit> Boarders: showInt
10:10:03 <dmwit> Boarders: showIntAtBase, I mean.
10:10:46 <dmwit> You may also enjoy using its Bits instance.
10:11:33 <Boarders> thanks
10:11:39 <infinisil> Boarders: A somewhat ugly alternative is to use `printf "%08b" word`
10:11:49 <Boarders> I was using Bits but just need a way to debug
10:12:16 <ovitus> they are just probability chains
10:13:01 <dmwit> I know what Markov chains are. But I don't know what a "Markov chain randomizer" is, and I don't know what "probability chains" are.
10:13:10 <ovitus> i guess I could just fill them with random numbers, but ofcourse I'm looking for a more automated approach 
10:14:14 <ovitus> just trying to describe that I wanted to produce the probability lists with random values
10:14:28 <ovitus> without having to do it myself, I'd like to test out different chains and values quickly
10:17:54 <dmwit> Why do you consider "just fill them with random numbers" to be not automated?
10:20:11 <ovitus> well that might be possible, but they would need to amount to 10
10:20:32 <ovitus> my haskell coding skills are rudimentary
10:24:40 <infinisil> ovitus: Generate a list of 10 random numbers in the range [0..7]
10:25:06 <infinisil> Then count how many times each of them occurs, those are your values
10:35:11 <infinisil> % randomthing = (\list -> let m = M.fromListWith (+) $ map (,1) list; in [ M.findWithDefault 0 i m | i <- [0..7] ]) <$> replicateM 10 (randomRIO (0, 7))
10:35:11 <yahb> infinisil: 
10:35:49 <infinisil> % replicateM 8 randothing
10:35:49 <yahb> infinisil: ; <interactive>:199:14: error:; * Variable not in scope: randothing :: m a; * Perhaps you meant one of these: `Ghci71.randomthing' (imported from Ghci71), `randomthing' (line 197)
10:35:53 <infinisil> % replicateM 8 randomthing
10:35:54 <yahb> infinisil: [[1,0,2,0,3,0,1,3],[1,0,2,2,1,1,1,2],[1,3,2,1,3,0,0,0],[3,3,0,1,2,0,1,0],[0,0,2,1,1,3,2,1],[2,3,1,0,2,1,1,0],[3,2,2,2,0,1,0,0],[1,0,1,3,3,1,1,0]]
10:36:00 <infinisil> ovitus: ^
10:37:12 <fog> how do we do "plugins" with backpack? like, if there is a signature which provides an interface, such as that required by some simple algorithms, and then a more complex algorithm being developed needs an extra function, how do we "extend" the signature to include eg an extra module of functions or "plugin"
10:38:20 <fog> eg supposing i want to add matrix multiplication to this signature;
10:38:21 <fog> https://github.com/fog-hs/rotate/blob/master/src/src/Rotate.hsig
10:38:37 <fog> but without changing it - just to extend it with a booster package
10:38:58 <fog> an expansion pack...
10:39:23 <fog> "sims united + reinforcements..." sorry...
10:42:14 <fog> the idea is supposed to be copying from matlab again - where the idea is to have the basic matrix multiplication etc work with the core interface, a bit like prelude, and the other addons as optional, eg "machine learning toolbox" which would have all the usual functions in there 
10:43:25 <ovitus> thanks for the infinisil, but why are they all in the range of 0-3? there are no chains like this for instance: [0,0,0,8,0,2,0,0] or [0,0,0,4,0,0,6,0]
10:44:06 <infinisil> ovitus: That's what you get from this kind of random selection, it's random :)
10:44:36 <infinisil> ovitus: You could also implement a different way of generating these that would have more such big numbers
10:44:38 <ovitus> replicateM 8 randomthing
10:44:44 <ovitus> % replicateM 8 randomthing
10:44:45 <yahb> ovitus: [[1,1,1,1,2,0,1,3],[1,1,2,1,1,1,2,1],[2,0,2,1,1,1,2,1],[0,1,2,2,2,1,0,2],[1,1,1,1,2,2,1,1],[3,1,0,0,1,3,0,2],[2,1,2,1,1,1,0,2],[1,2,1,2,1,1,1,1]]
10:44:50 <ovitus> % replicateM 8 randomthing
10:44:50 <yahb> ovitus: [[0,3,0,3,1,0,2,1],[1,0,1,2,2,3,1,0],[4,1,2,0,1,1,1,0],[0,0,2,2,2,1,3,0],[2,0,2,2,0,2,2,0],[1,0,2,0,2,2,0,3],[0,0,2,2,2,2,0,2],[3,1,2,1,0,1,1,1]]
10:44:52 <ovitus> % replicateM 8 randomthing
10:44:52 <yahb> ovitus: [[2,1,2,0,2,0,1,2],[1,1,0,3,2,1,2,0],[1,0,0,2,3,1,1,2],[1,3,2,0,1,1,2,0],[1,1,1,1,1,2,2,1],[0,1,2,2,1,2,1,1],[1,1,3,0,4,1,0,0],[1,1,2,3,0,0,2,1]]
10:45:27 <ovitus> hmm
10:45:29 <fog> :t flip replicateM randomthing
10:45:32 <lambdabot> error:
10:45:32 <lambdabot>     Variable not in scope: randomthing :: m a
10:45:38 <fog> % :t flip replicateM randomthing
10:45:38 <yahb> fog: Num a => Int -> IO [[a]]
10:46:26 <infinisil> ovitus: Having a "4" there is like rolling an 8-sided die 10 times and getting "5" 4 times in total
10:46:33 <infinisil> Which is not very likely
10:46:54 <fog> % replicateM 1000 randomthing >>= return . maximum . map maximum
10:46:54 <yahb> fog: 6
10:47:42 <fog> % replicateM 10000 randomthing >>= return . maximum . map maximum
10:47:42 <yahb> fog: 7
10:49:19 <infinisil> There's many ways you can generate random things though
10:49:48 <fog> is it possible to have signatures which import other signatures? does that get complicated with the cabal build? like would it have to make a sequence of libraries or something...
10:50:30 <ovitus> ok, Ill probably just type them out by hand, thanks for the help and function 
10:52:21 <fog> how would two seperate packages on hackage have one "extending" the signature of another? is that possible with the cabal file?
10:53:41 <fog> i guess this should go on hackage for this part of the project but its here for now; https://github.com/fog-hs/rotate/tree/master/src
10:54:23 <fog> the idea would be to write another such a backpack that would add the extra functionality, eg matrix multiplication. and have another example 
10:54:45 <sclv> i don't think there are nested signatures.
10:54:59 <fog> it should just work like modules right?
10:56:21 <sclv> fog: there _is_ signature inheritance https://ghc.gitlab.haskell.org/ghc/doc/users_guide/separate_compilation.html#module-signatures
10:56:26 <fog> the only problem seems to be wrangling the cabal file... like how would something be hooked up to implement both signatures when one is built partially on top of the other (eg, sharing the definition of a matrix, but adding the extra function)
10:56:58 <fog> sclv: oh awesome reference
10:57:08 <fog> didnt realise it was part of the ghc offical docs
10:57:28 <fog> wow just since 8.2
10:57:49 <sclv> yeah, all this stuff is still semi-experimental which is why there's not much in the way of posts or external docs
10:58:58 <fog> you see what i mean though about how it seems complicated to have 2 different hackage projects with one extending the other because of the different cabal files?
10:59:30 <sclv> i guess if one depend on the other it infers inheritence
11:02:34 <fog> ok i think ill try and add vector scalar multiplication as an "extension" to the Rotation signature example
11:03:18 <fog> bit confused about first steps to doing this though, not used to structuring projects using cabal... it would have to be like a local library right? 
11:04:21 <fog> thats the problem then, the "implementations" of the signature are only built for the example executable, not a library...
11:04:34 <fog> so confusing...
11:05:19 <fog> the only thing which currently imports the abstract signature before its implemented by a particular backend is this;
11:05:20 <fog> https://github.com/fog-hs/rotate/blob/master/src/src/TestRotate.hs
11:06:08 <fog> so i guess you just import Rotate and the mixins will swap that whenever someone actually goes to use the extended interface/signature
11:06:55 <fog> but i cant import Rotate in ghci... so i guess that ghci isnt really going to be a part of the development tools for signatures...
11:08:39 <fog> the thing is i need to check to see that its visible as a successfully built library, which is why I was trying to import it in ghci
11:09:42 <fog> i guess i just have to trust that cabal has built it and it can be referenced in another projects cabal file as build-depends
11:17:13 <heath> https://medium.com/97-things/optional-is-a-law-breaking-monad-but-a-good-type-7667eb821081
11:18:38 <EvanR> medium has haskell "articles" now?
11:19:51 <hyperisco> Is that C#?
11:20:02 <hyperisco> Oh, no, it is Java.
11:24:04 <hyperisco> They don't provide the definition of isPresent so I don't know what is actually going on.
11:24:05 <EvanR> i think i understand it, but i don't know what "null safety" means
11:24:27 <davean> EvanR: Its a blogging platform. So the same way wordpress does
11:24:40 <davean> also, that article says "no math" then directly jumps into math?
11:25:06 <EvanR> it's not math because they don't use math syntax, no one will notice
11:25:21 <hyperisco> I respect peanut allergies but not math allergies. I'll lie to get someone to swallow.
11:25:23 <davean> ... ok
11:25:45 <EvanR> so what is null safety?
11:26:07 <davean> Never dereferencing null
11:26:23 <hyperisco> In languages where null inhabits every ref type, "null safety" means the program will never throw an uncaught "null reference exception".
11:26:52 <EvanR> so NRE-freeness
11:26:58 <dmwit> Unpopular opinion: the real return-analog is of, not ofNullable, and the arrows in the source category are just the functions that do not check for null.
11:27:10 <dmwit> Then Optional is a fine monad.
11:27:20 <hyperisco> I am guessing isPresent checks if this.value is null or not…
11:27:35 <dmwit> hyperisco: I think so, yes.
11:27:53 <hyperisco> That is a classic mistake and I disagree with the author. Not that my answer to null is much better.
11:28:14 <hyperisco> When I programmed C#, I just said that null shall not exist.
11:28:40 <EvanR> so you rewrote the stlib
11:29:03 <hyperisco> There's some nulls you have to live with at the periphery, but the bulk of the program can be null-free.
11:30:26 <heath> somewhat related: https://www.reddit.com/r/haskell/comments/763su7/in_which_rich_hickey_questions_the_value_of/dob5nl4/
11:30:29 <hyperisco> The alternative is lousy because there is no way to keep track of what should expect nulls and what shouldn't. To me it is all or nothing, and all is hopeless.
11:30:31 <heath> https://www.reddit.com/r/haskell/comments/763su7/in_which_rich_hickey_questions_the_value_of/doejz84/?context=8&depth=9
11:31:11 <heath> the comment below this comment linked 
11:31:11 <EvanR> how do you question the value of pattern matching...
11:31:19 <hyperisco> Just imagine Maybe was inescapable, so there was no Int, there was only Maybe Int, and binding on Maybe Int gave you a Maybe Int… Maybes everywhere. That is what null is like once it leaks into your program.
11:31:19 <EvanR> i need them in clojure so bad
11:35:15 <hyperisco> A lot of arguments for dynamicism are that the world is complicated and hard to model with static types, so therefore we shouldn't bother with any of it.
11:35:57 <hyperisco> Which is to me like saying… the world is hard to reason about, so lets not bother reasoning about it.
11:36:12 <__monty__> "Let's pretend we got it right for things we didn't expect in the first place."
11:36:17 <geekosaur> …have you *seen* the kind of code that's actually out there?
11:38:32 <EvanR> the haskell world is complicated and hard to model with dynamic types
11:39:08 <dmwit> Hm. I suppose you must also demand that the arrows in the source category use every argument. Gross.
11:39:49 <EvanR> dmwit: is this all a roundabout way to make presence of nulls cause an insta crash
11:40:11 <dmwit> Yes.
11:40:41 <hyperisco> When in .NET you can use F#, which does not suffer from null pervasion.
11:41:33 <fog> argh! it says; Non-library component has unfilled requirements: Rotate
11:41:56 <fog> something to do with mixins not going through the 2 packages...
11:42:00 <fog> :'(
11:42:51 * EvanR rereading the backpack paper
11:43:14 <Lycurgus> mixins in haskell?
11:43:35 <hyperisco> How else do you compose traits?
11:46:37 <EvanR> i've talked to a lot of clojure people and i'm pretty sure rich hickey's views are his own and don't reflect on the opinion of that community
11:46:52 <fog> here is the code;
11:46:53 <fog> https://github.com/fog-hs/rotatePlugin/tree/master
11:47:02 <fog> its to extend;
11:47:02 <EvanR> why people like this end up being the language creator is unfortunate
11:47:03 <fog> https://github.com/fog-hs/rotatePlugin/tree/master
11:48:10 * Lycurgus .oO( appears to be reified typeclasses )
11:48:16 <fog> no, its supposed to exted;
11:48:17 <fog> https://github.com/fog-hs/rotate
11:48:24 <fog> which works ok as an intro to backpack
11:49:56 <hyperisco> Don't you need an opinionated person to make a new language in the first place?
11:53:58 <fog> did anyone manage to build the example or reproduce the error?
11:54:01 <hyperisco> My favourite was this game dev who showed up at a C++ conference to say how C is better :P
11:55:31 <wildtrees> does anyone know how to override cabal tests for all the packages needed by a custom package of mine in nixos using nix-build with a default.nix and customPackageNameHere.nix ? 
11:56:54 <merijn> hyperisco: I mean, Ryan Newton had a keynote at C++ conference on Haskell :p (admittedly, he didn't explicitly say Haskell was better than C++ :p)
11:57:27 <hyperisco> wise
11:58:12 <infinisil> wildtrees: Gotta give a bit more info than that
11:58:31 <cocreature> how do you debug low productivity? just regular profiling and try to cut allocations or is there some other trick?
11:59:24 <merijn> cocreature: Step 1: Ensure parallel GC is disabled? ;)
11:59:39 <cocreature> merijn: yeah I know that one and it is disabled :)
12:00:04 <merijn> cocreature: Generally I start out with -sstderr and see if anything obvious jumps out before moving on to various heap graphs, etc.
12:00:45 <cocreature> merijn: well -s is what showed me that my productivity is suspiciously low but I’m not sure how I can figure out why that is the case from the +RTS -s output
12:01:48 <infinisil> Um, what's productivity? Is this some performance metric I've never seen before?
12:02:07 <merijn> infinisil: Percentage of time spend doing useful stuff relative to time spend running GC
12:02:16 <cocreature> +RTS -s will show it
12:02:21 <merijn> infinisil: So 50% productivity = 50% of time is spent on GCing
12:02:27 <infinisil> Ah I see, neat
12:02:36 <cocreature> 50% is fairly shitty :)
12:03:24 <infinisil> I've once had a program that used all 8 cores fully, was quite proud until I learned the majority was just GC..
12:03:34 <infinisil> s/I've/I
12:03:40 <cocreature> that’s why merijn’s point 1 was disable parallel gc :)
12:03:42 <merijn> infinisil: Parallel GC is notoriously slow and for many usecases doesn't gain much improvement
12:04:02 <merijn> infinisil: Because the parallelism leads to lots of having to synchronise, which leads to lots of slowdown
12:04:16 <hyperisco> You probably spend a good chunk of your time dereferencing memory. Not sure how you can measure that.
12:04:16 <infinisil> (I knew it was mostly GC because when I ran it single-threadedly, it ran faster..)
12:04:26 <__monty__> Wasn't there recent work on a better parallel GC?
12:04:35 <merijn> infinisil: I had a program with -threaded that had like 37% productivity with parallel GC. Disabling parallel GC I got like 95% productivity
12:04:54 <merijn> __monty__: There was recent work on a low latency GC, I'm not sure whether it was parallel
12:05:06 <EvanR> someone working on fortran code asked me about performance, saying they suspected a lot of time was spent accessing memory... i was like...
12:05:16 <__monty__> Ah, low latency, might have misremembered.
12:05:20 <fog> whats that like to do with some kind of race condition on threads?
12:05:38 <EvanR> i mean other than cache issues, what are you supposed to do about that even if its the problem
12:05:57 <davean> EvanR: I mean I'd expect they're correct - when I did high performance code I mostly looked at memory access (And sometimes pipeline, but the memory bandwidth is a hard limit)
12:06:03 <__monty__> EvanR: Not allocate any : )
12:06:03 <merijn> infinisil: "+RTS -qg" is the magic invocation
12:06:07 <hyperisco> That's legitimately a common source of efficiency problems. What do you do? Well, in Haskell it is tough, but you start using unboxed types.
12:06:08 <davean> EvanR: you change your data design
12:06:15 <infinisil> merijn: Ah I was just searching for that, thanks
12:06:18 <EvanR> they didnt allocate any
12:06:39 <merijn> EvanR: False sharing is also a memory issue in parallel settings
12:06:49 <infinisil> hyperisco: I feel bad about it, but I've started using mutable arrays more freely
12:06:55 <merijn> I wonder if anyone investigated if there's any false sharing in the parallel GC...
12:07:04 <EvanR> haskell has the "problem" of having to follow pointers, but when you are just accessing stuff directly all the time?
12:07:42 <hyperisco> I am not even necessarily referring to indirection though EvanR
12:07:42 <EvanR> it seems like worrying about the speed of arithmetic
12:07:52 <cocreature> EvanR: you can still layout your data or change your access patterns so that they are more cache friendly and things like that
12:07:56 <hyperisco> Any memory load is among the slowest of instructions unless it is cached in the CPU
12:07:59 <EvanR> cache, right
12:08:14 <davean> you cna also make ring buffers between the CPUs so you feed directly without really touching memory
12:08:20 <merijn> hyperisco: You can measure it with Intel VTune :)
12:08:53 <merijn> Like, if you ever need to investigate performance on an Intel CPU, just get your boss to pony up the 1K for the commercial use license of VTune and thank me later :p
12:09:13 <hyperisco> good to know
12:09:40 <fog> i guess the problem is it needs to do the mixins for both signatures from the plugin cabal 
12:10:00 <merijn> hyperisco: Abouter ~10% performance overhead when using it to profile and it will show you *everything* to the point of "percentage of cache miss for each of L1, L2, and L3 cache" for specific instructions
12:10:14 <hyperisco> that's pretty slick
12:10:26 <merijn> hyperisco: Also things like pipeline stalls, branch prediction failures, etc.
12:10:51 <hyperisco> does it tell you how many times you've been hit by spectre? :P
12:10:56 <cocreature> merijn: do you use vtune to optimize Haskell code or just for c/c++/…?
12:11:07 <merijn> cocreature: I've only used it for C++
12:11:18 <merijn> cocreature: Mostly because I haven't had a reason too with Haskell
12:11:26 <infinisil> davean: Ring buffers between CPUs? How does that work?
12:11:31 <merijn> But I've wondered how well it'd work with GHC's DWARF symbols :)
12:13:02 <hyperisco> now just add that as feedback into dynamic program compilation
12:13:08 <davean> infinisil: You can setup ring buffers that are friendly to MESI (or other protocols) that involve trading off exclusive cache lines in a cycle between the CPU cores to ship data across.
12:13:25 <merijn> hyperisco: So, yeah, it understands DWARF symbols too, so if you compile with -g it can even attribute hotspots to specific lines/expressions of C/C++ code (and vice versa you can look up metrics for specific source lines)
12:13:44 <cocreature> merijn: yeah I really would like a nice statistical profiler based on GHC’s DWARF debug symbols
12:13:49 <davean> infinisil: some CPUs have cache memory you can use and not have to worry about aliasing too
12:13:58 <infinisil> davean: Ah, so that doesn't sound like something you could do with Haskell heh
12:14:01 <davean> which is super nice but only generally in the embeded or specialized cases
12:14:15 <davean> infinisil: uh ... hum. No I think you could ... It wouldn't be easy
12:14:29 <davean> infinisil: a mutable byte array MIGHT be able to accomplish it
12:14:34 <davean> you'd have to read the assembly though
12:14:54 <davean> I definately wouldn't recomend it
12:15:07 <hyperisco> It isn't nice when your high-level language becomes an Assembly facade
12:15:28 <fog> hmm, but the original signature is implemented by things in the "example" directory which the cabal file says is built as a library, but then how can that be added to the build depends?
12:15:37 <fog> the overall library is rotate
12:15:44 <fog> would that make this rotate-example?
12:15:52 <infinisil> davean: Gotcha
12:15:57 <infinisil> Also: http://www.d-e-f-i-n-i-t-e-l-y.com/
12:16:18 <monochrom> Defiantly >:)
12:16:45 <fog> well that doesnt work...
12:16:55 <davean> infinisil: If I wanted it in Haskell I'd want to make something like a Chan that was cross thread and built into the primative layer of the compiler.
12:17:04 <fog> i doubt this random itterative process is going to converge
12:17:12 <fog> where is the extra missing info!?
12:17:43 <merijn> cocreature: Non-commercial use of VTune is free, iirc
12:17:50 <davean> infinisil: often with Haskell you can just trust your cache coherency protocols enough if you do a sensible handoff
12:17:52 <hyperisco> If convergence is possible, then a random process has a nonzero chance of converging, surely?
12:18:12 <davean> infinisil: Look into cache oblivious datastrcutures for the rest of cases.
12:18:13 <hyperisco> I guess it could be a zero chance, but still possible.
12:18:17 <merijn> cocreature: (although the definition of non-commercial use is: you can't be paid to work on this code), but that'd be fine for playing with it on open source Haskell outside of work :)
12:18:32 <fog> i was working off the unpacked-containers example for the previous version which works
12:18:49 <fog> but i dont have an example of this "extension" process
12:18:53 <davean> infinisil: if you just allocate, write, and pass a pointer thats *mostly* cache coherency friendly if the origional writer never looks at it again - or at least never writes when you can have read-shared
12:19:01 <fog> where the mixins are split over 2 seperate projects
12:19:21 <davean> infinisil: so really in Haskell's case what you're paying is GC and the performance peneltry of your channel
12:19:27 <davean> also the lack of backpressure.
12:19:41 <hyperisco> The problem with getting too fancy with hardware optimisations is that your program becomes less portable.
12:20:00 <davean> hyperisco: Yah, which is why cache oblivious is god
12:20:01 * infinisil nods, pretending to get everything davean is saying
12:20:22 <fog> im going to link them again as the channel is pretty fast moving atm and it has got lost in the scroll up... https://github.com/fog-hs/rotate (works) - https://github.com/fog-hs/rotatePlugin (has error)
12:20:28 <davean> *good
12:20:37 <Lycurgus> it's easier than ever though with the elimination of diversity and dominance of intel arch
12:20:45 <davean> though I guess claiming it has devine power isn't so off base given how useful it has been to some projects
12:21:22 <davean> infinisil: just read about cache oblivious stuff. Its the level you should go to in Haskell
12:21:24 <Lycurgus> if you still to the core arch
12:21:35 <Lycurgus> s/still/stick/
12:22:26 <Lycurgus> i.e. the thing conserved across intell, amd, and arm, et. al
12:22:36 <Lycurgus> *intel
12:22:47 <davean> Lycurgus: Haha, what do you tihnk is conserved? ;)
12:23:15 <fog> its basically a simple cabal problem a more experienced user of cabal should be able to answer - it needs to fetch the mixins (the implemntations of the ratate.hsig) from the rotate project, but i dont know how to add that as build-depends
12:23:20 <Lycurgus> yes compared to days of yore when there were really distinct archs, yes
12:23:35 <Lycurgus> like on my ref card page
12:23:41 <wildtrees> infinisil, I tried building my custom haskell package from .nix file generated cabal2nix and a default.nix I got off the web, using nix-build, it went off and built happy and stuff, it wouldnt be too bad but it was runnign tests for every single package that had them in the depedendcy tree, how do I disable runnings tests for the whole depdendency tree?
12:24:04 <davean> Lycurgus: I guess it depends on the level you look at.
12:24:25 <infinisil> wildtrees: Ah I see, hold on
12:24:26 <davean> That memory ordering thing ... I don't personally think GHC has it fixed yet.
12:24:41 <Lycurgus> https://en.wikipedia.org/wiki/User:Lycurgus/MoCA
12:25:16 <fog> if a cabal file rotate.cabal exports "example" as a library, how is this added as a build depends in rotatePlugin.cabal ?
12:25:17 <bifunc2> Have you seen something like library-generating "library templates"?
12:25:17 <bifunc2> You would pass into it stuff (both at the type and value levels) to "fill in" the template, and boom. Out comes a library (even including a test suite).
12:25:17 <bifunc2> Is there any cool "Haskell" way to do this - as opposed to writing some custom shell script?
12:25:47 <infinisil> wildtrees: Add a haskell overlay like this: `self: super: { mkDerivation = args: super.mkDerivation (args // { doCheck = false; }); }`
12:25:52 <davean> fog: rotate:example I think
12:25:59 <wildtrees> infinisil, it spent 17+ hours doing builds and tests in a constrained vm environment, till it failed by running out of space, I hope I freed enough space now, but still dont want the build to take that long 
12:26:07 <davean> fog: sorry, I've not touched it in a while, so I'm not 100% sure but htats the general pattern.
12:26:22 <fog> no then it says unexpected :
12:26:27 <wildtrees> infinisil, do I put that in my packageName.nix or default.nix?  
12:26:31 <infinisil> wildtrees: And you can also avoid profiling builds by also doing `enableLibraryProfiling = false`
12:26:43 <infinisil> wildtrees: No idea what those files look like
12:26:56 <infinisil> (disabling profiling builds can also save a whole bunch of time)
12:27:20 <fog> maybe i should return in a while when the other conversation is over
12:27:24 <davean> if people are asking nix questions - what nix-shell would I use to get something to compile that used zlib from TemplateHaskell?
12:27:27 <wildtrees> oh, would I want to put that wrapping my normal mkDerivation? 
12:27:54 <Lycurgus> people ask nix questions in #nixos
12:27:55 <infinisil> wildtrees: That's what it would do, but not the main mkDerivation, but the haskell one
12:27:57 <wildtrees> davean, I heard zlib is a pain, the other day 
12:28:16 <davean> wildtrees: it sucks but its critically important so it doesn't matter if it sucks or not :)
12:28:29 <davean> It absolutely has to be solved.
12:28:30 * Lycurgus wonders if stack runs under nix, doubts 
12:28:40 <davean> Lycurgus: it does. uh, enjoy that :-p
12:28:51 <wildtrees> infinisil, thank you for your help, i gotta go afk for awhile I will try that out 
12:29:08 <Lycurgus> yeah, I guess it would work pretty easy
12:29:18 <infinisil> wildtrees: Probably best to ask in #nixos if you're having problems with that :)
12:29:19 <__monty__> davean: I assume you've tried the straightforward solution?
12:29:34 <davean> __monty__: zlib.dev or whatnot?
12:29:42 <Lycurgus> isolation within isolation, not the actual antipattern which is pkg mgr collision
12:29:48 <davean> __monty__: that solves the static linking case but templatehaskell is dynamicly linked.
12:30:20 <__monty__> Ah, you need the library. Then you'll have to specify it in your buildInputs.
12:30:32 <davean> __monty__: nix-shell I said.
12:30:42 <Lycurgus> isn't TH compile time only?
12:30:48 <davean> Lycurgus: yep, exactly.
12:31:13 <__monty__> davean: Yeah, you can have buildInputs in a shell.nix.
12:31:27 <davean> __monty__: could you give me an example?
12:32:00 <davean> I don't want my hamfisting the nix to be the source of confusion here.
12:32:10 <davean> I want more interesting sources of confusion :)
12:32:35 <geekosaur> nix is often an interesting source all by itself >.>
12:32:38 <__monty__> Start from this, I guess: https://github.com/Gabriel439/haskell-nix/blob/master/project2/README.md
12:32:53 <Lycurgus> https://www.youtube.com/watch?v=-9poCAuYT-s
12:33:25 <geekosaur> it's a very clever hack. sadly, it's still a hack… and always will be, given what it has to work with and what it's trying to do
12:34:39 <davean> geekosaur: I really want a build mode for it where it just makes the dev parts available.
12:34:50 <davean> "No seriously, I'm trying to get work done"
12:36:58 <__monty__> davean: I just have a "myEnvFun" that provides any and all haskell packages my projects depend on. I think that might work with non-haskell deps too.
12:37:29 <davean> __monty__: I can't use nix's model of haskell packages.
12:37:52 <davean> As for the second half ... maybe? I'd just need to figure out getting it. And manageing it.
12:38:40 <boj> davean: we use this to drop into a nix-shell and do incremental cabal dev, which then we hand off to our build server which just uses cabal - https://gist.github.com/boj/fb268565752d0ee856efd45e0b41c2be
12:38:44 <__monty__> Not, sure what you mean. Want to move to -offtopic or #nixos?
12:39:13 <boj> not sure if that is useful or not, just throwing it out there
12:39:13 <davean> boj: Let me try that!
12:41:18 <davean> boj: I tihnk you've given me something meaningful to look at. __monty__: I'm going to play with boj's thing for a bit because it verly likely deeply changes my questions.
12:45:27 <fog> https://github.com/fog-hs/rotate/blob/master/src/rotate.cabal
12:45:28 <fog> https://github.com/fog-hs/rotatePlugin/blob/master/src/rotatePlugin.cabal
12:45:35 <__monty__> davean: Fwiw, my myEnvFun does the same thing. The difference is I can load that up for any project, no copying shell.nix's around. Oh, and it's a gcroot so I never lose my environment because I ran out of space.
12:45:43 <fog> these are the 2 cabal files im trying to get to talk to each other nicely
12:46:04 <fog> im new to haskell cabal and some help would be appreciated 
12:48:41 <fog> it complains about not being able to use the mixins from rotate.cabal in the rotatePlugin.cabal
12:49:02 <fog> it needs to get at; exposed-modules: LinearRotate, VectRotate
12:49:48 <Cale> fog: Almost nobody uses this mixin stuff yet and it's not even properly documented in the Cabal user's guide, you might need to talk to ezyang or one of the people involved in implementing it.
12:49:57 <fog> in order to patch them through 
12:50:21 <fog> Cale: its just i dont know how to get at the modules
12:50:31 <fog> thats something normal to do with cabal builds
12:51:03 <Cale> Usually, when you add packages to your build-depends, they become available to import in your sources.
12:51:05 <fog> the reason i was putting together concise examples was with the hope of being able to make a good reference
12:51:08 <Cale> and that's all there is to it :)
12:51:28 <fog> but in the absence of such, because of the lack of users of a tool without reference, its a pretty difficult learning process
12:51:46 <fog> and because i dont know how to use cabal to beigin with, im asking for help from cabal users
12:52:08 <Cale> Well, I use Cabal a bunch
12:53:01 <monochrom> But there is a disparity between "I use cabal-install all the time" and "I use backpack all the time".
12:53:10 <fog> so in rotate.cabal; "library example" has "exposed-modules: LinearRotate, VectRotate"
12:53:25 <monochrom> Frequency of former: 99.99%.  Frequency of latter: 0.1%.
12:53:28 <fog> an example of a mixin that uses this is;
12:53:29 <fog> mixins: rotate (TestRotate as Linear.TestRotate) requires (Rotate as LinearRotate)
12:54:53 <bifunc2> Can I somehow create library-generating "library templates"? You would pass into it stuff (both at the type and value levels) to "fill in" the template, and boom. Out comes a library (even including a test suite). Is there any cool "Haskell" way to do this - as opposed to writing some custom shell script?
12:54:55 <fog> that is, the exposed modules mentioned are used to replace the signature Rotate, and are given to the module that requires it 
12:55:25 <bifunc2> Actually, is Stack or Nix templates what I'm looking for?
12:55:25 * monochrom wonders if he should mention "backpack" to bifunc2 now...
12:55:30 <bifunc2> hmm
12:55:56 <merijn> monochrom: I don't think he wants that
12:56:10 * geekosaur was wondering that as well, but seems like "not quite"
12:56:29 <merijn> I think he just wants like the library scaffolding stuff? Making directories, etc. but I could be wrong
12:56:35 <monochrom> Actually associated type family (type class + type family) can get you a long way.
12:56:54 <geekosaur> stack has project templates. cabal doesn't yet last I checked
12:56:57 <merijn> Oh, no, I need to read better :p
12:57:05 <geekosaur> (last I checked was a couple months ago...)
12:57:38 <merijn> geekosaur: I don't think that makes sense for cabal anyway, there's so little boilerplate needed...
12:57:47 <monochrom> haha
12:58:29 <fog> when it says; TestRotate as Linear.TestRotate, this means that the Main.hs example of rotate can import TestRotate (a module which was written in terms of the signature Rotate) with the Rotate signature implemented using LinearRotate, where the module imported by Main.hs is Linear.TestRotate - the TestRotate.hs file but with the backend implemented
12:58:30 <fog>  by LinearRotate
12:59:21 <fog> now for the plugin module, it needs to do this same process, but it cant get at the LinearRotate found in src/rotate/example
12:59:33 <fog> to be able to patch it through 
13:00:55 <fog> my most recent attempt was this;
13:00:55 <fog> https://pastebin.com/raw/5vWEmyXc
13:01:46 <fog> oh it changed to try and import rotate:example from a suggestion before but thats wrong 
13:09:51 <__monty__> bifunc2: Maybe summoner? https://github.com/kowainik/summoner
13:10:06 <xxStarAngelxx> Hello. Come and watch my Live Show (Username: xxStarAngelxx) and let's have fun together ----> https://3no.ro/XXXCams ♥
13:19:24 <jgt> fun with monoids?
13:23:40 <pyBlob> the function parseAtom at https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing has a let, that defines the atom variable, yet there is no "in" keyword like in the examples at haskell.org
13:25:09 <merijn> pyBlob: "let ... in ..." is an expression, "let" without in is part of the do notation syntactic sugar
13:25:36 <merijn> @undo do { foo; bar; let quux = 3; baz quux }
13:25:37 <lambdabot> <unknown>.hs:1:39:Parse error: }
13:25:47 <merijn> @undo foo; bar; let quux = 3; baz quux
13:25:47 <lambdabot> <unknown>.hs:1:4:Parse error: ;
13:25:51 <merijn> mmm, what?
13:25:59 <EvanR> let in do will be desugared to a let expression, complete with an "in", behind the scene
13:26:31 <Lears> @undo do { foo; bar; let { quux = 3 }; baz quux }
13:26:32 <lambdabot> foo >> bar >> let { quux = 3} in baz quux
13:27:41 <pyBlob> merijn: thanks, that makes sense
13:29:00 <EvanR> > (length "do { foo; bar; let { quux = 3 }; baz quux }", length "foo >> bar >> let { quux = 3} in baz quux") -- which is superior
13:29:03 <lambdabot>  (43,41)
13:32:57 <EvanR> let's say you run a haskell company, or you are the programming manager. You hire a guy who, news to you, prefers to write haskell code with { } and ;. What do you do, let them? Intervention? Reverse the hiring process?
13:33:51 <davean> EvanR: Have you seen GHC?
13:33:55 <EvanR> lol
13:34:01 <davean> EvanR: you just make them work on GHC
13:34:08 <davean> They're now your GHC hacker
13:35:04 <EvanR> haskell companies all need their own GHC hacker? : (
13:35:46 <sclv> tell em u have a style
13:35:49 <davean> EvanR: no, but we need more GHC hackers.
13:35:57 <sclv> Style guide
13:36:06 <davean> EvanR: and I thought it was funny
13:36:18 <c_wraith> take inspiration from the history of ghc and just rewrite each other's code all the time.
13:36:22 <davean> its the only major code base I know with a significant amount of that.
13:37:25 <EvanR> style guide, very diplomatic
13:37:27 <c_wraith> iirc, spj and sm used to spend some amount of time looking for things to fix in each other's code so they could fix the code style there as well. 
13:38:05 <davean> c_wraith: That can be productive to a point
13:38:53 <c_wraith> that point is probably "two people who get along well"
13:40:10 <mdunnio> EvanR: we run a haskell company and we have an extensive style guide. we debate it all the time though. i think most developers are happy to conform to a guide at work and do their own style on their personal projects. if one of our devs has a very strong opinion we openly discuss it and see it makes sense to change our guide.
13:40:43 <mdunnio> EvanR: at the same time, we make sure during our interview process that the individual plays well with others, so that helps
13:47:18 <fog> there is a best style, and we should find it
13:48:13 <fog> idk, maybe its not your job to understand all the arguments for and against everything, but it would be a weak team and a weak language that didnt basically have it down
13:48:46 <fog> justifications are usually enough
13:49:27 <fog> i dont think calling it an opinion after that point is really respectful 
13:50:21 <fog> thats why you need old dogs in the team, because they have seen the same arguments play out time and again and they can just shortcut to the conclusion
13:50:41 <fog> but that said, maybe they are all C coders!
13:51:23 <srid> mdunnio: what's the name of your company? 
13:51:55 <mdunnio> fog: well, we certainly think we have found the "best style", but I'm being humble in irc.
13:52:04 <fog> and is "argh, all those curly braces hurt my eyes" really just an oppinion? it says something about convention, standards and acclimatisation 
13:52:16 <srid> at my company we have a style guide, which I find to be eminnently sensible. stuff like avoiding indentation alignment is common sense i think, and not controversial due to differing opinions.
13:53:24 <srid> the comment about curly brances is subjective opinion, yes. but the one about indentation alignment is not (as there is an actual reason behind it; not messing up diffs)
13:53:27 <fog> some stylistic differences are ok, its when they are so jarring as to make an incompatability between teammates that it becomes an issue
13:54:36 <jgt> in my opinion, *this* is the best Haskell formatting style: https://www.waltons.co.uk/_imagesWT/products/2018-SI-001-001-0011%20(1).jpg
13:54:38 <fog> the comment about the comment about curly braces being a subjective opinion is a subjective opinion 
13:55:29 <monochrom> jgt: How do I do that formatting style?
13:56:02 <srid> "hurt *my* eyes" - the word "my" indicates the subject, and not an object. :P
13:56:08 <jgt> basically keep talking about what you believe makes sense philosophically, and should be strictly adhered to by all your peers
13:56:42 <jgt> also, a tab is five spaces
13:56:48 <monochrom> Err, do bicycles and a shed mean talking about what you believe makes sense philosophically?
13:57:14 <monochrom> The average programmer uses tab for 3.7489 spaces
13:57:47 <EvanR> clearly the diff tool needs to understand indentation
13:58:11 <monochrom> Use proportional fonts.
13:58:31 <jgt> a level of indentation is determined by the roll of one D10
13:59:38 <monochrom> Does D10 exist? I thought there are only Platonic solids.
14:01:01 <monochrom> I just have a feeling that those bicycles are actually transformers.
14:01:19 <infinisil> monochrom: You can get dice for any number, doesn't have to be a platonic solid
14:01:27 <jgt> yeah, D10 exists. Personally I think they were making better music when they were D12, but Eminem had other obligations
14:03:36 <geekosaur> these days you ask the computer for Dsome_n
14:04:47 * jgt giggles and applauds
14:04:48 <geekosaur> @roll 1d10
14:04:49 <lambdabot> geekosaur: 4
14:05:34 <monochrom> Boo, people already indent by 4 without that random number.
14:05:52 * geekosaur should check if lb got it from xkcd
14:06:13 <jgt> monochrom: hey man I found your band https://www.youtube.com/watch?v=ttSd_RqAMTY
14:06:25 <fog> did anyone manage to build this backpack example? https://github.com/fog-hs/rotate/
14:06:46 <fog> it would be good if there were someone who understands it to help with the next step
14:16:13 <dmwit> monochrom: There is a beautiful construction for creating a die of n sides that is obviously uniformly distributed: create a pyramid whose base is an n-gon; mirror the shape over its base. This gives a polyhedron with 2n sides; for 1..n pick any two unlabeled sides and label them with the current number.
14:16:56 <dmwit> (Sorry, a die with n labels that is uniformly distributed.)
14:17:00 <bifunc2> How smart is Stack? If I include a single small module from some huge library (with lots of dependencies) into my project, will building my project have to download and build all those dependencies (even if that single module doesn't use most of them)?
14:17:01 <dmwit> (Not n sides.)
14:17:16 <dmwit> bifunc2: It will need to download and build all those dependencies.
14:17:31 <bifunc2> wow...
14:18:19 <bifunc2> so now either i have to break my library into smaller libraries (who wants that?) or we need some way to do multiple libs in a single cabal file, or...
14:18:23 <bifunc2> are there any workarounds?
14:19:37 <krackhead> Tru. Sign up for mint mobile, sir. http://fbuy.me/m4BqI That link gets you $30 off. Cheapest and best service around. $60 for 6 months 8gb data per month unlimited calls and texts. Then $30 off your renewal after that. When you renew 3gb is $15 per month and 8gb is $20. Its a steal. http://fbuy.me/m4BqI
14:19:47 --- mode: ChanServ set +o dmwit
14:20:00 --- mode: dmwit set -o dmwit
14:20:29 <fog> i cant figure out these errors... https://pastebin.com/raw/8VvKX3jS
14:22:37 <EvanR> monochrom: i have these, don't be jealous http://www.gamescience.com/assets/images/unlaunched/d7%20pair.jpg
14:22:50 <EvanR> plato rolling over in his grave 
14:24:03 <dmwit> Have you tested them for uniformity?
14:24:45 <EvanR> having a hard to piping them into diehard
14:26:11 <Lears> bifunc2: I don't know how usable it is atm, but you can try snack. It should ignore package boundaries and only build the modules that the target module depends on.
14:29:32 <bifunc2> Lears thanks for pointing me in the right direction!
14:30:09 <bifunc2> over and over again i keep getting evidence i should ditch stack
14:30:15 <wroathe> So I'm about done writing a lexer using the Megaparsec Lexer routines, which is nice and easy to do... But compared to flex, which takes a set of regular expressions and generates a DFA, this approach with try/backtracking seems like it would be dog slow for a large enough set of tokens
14:31:43 <wroathe> I wonder if it would be possible to write a parser combinator style API that makes an efficient DFA behind the scenes
14:31:52 <EvanR> haskell has alex
14:32:23 <wroathe> Yeah, I saw that. My lexer doesn't need to be super performance intensive, and so I'll just stick with the parser combinator route for now
14:32:47 <wroathe> I'm just lamenting that it's not truly superior to alex for this task
14:32:53 <fog> what does; other-modules mean in https://gitlab.haskell.org/ghc/ghc/wikis/backpack
14:32:54 <fog> ?
14:34:17 <phadej> non-exposed ones
14:34:35 <fog> this is making me dizzy
14:34:38 <Guest_57> hello how do i solve this
14:34:57 <Guest_57> curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to downloads.haskell.org:443 Failed to downloadFailed to install cabal-install"ghcup --cache install-cabal" failed!
14:35:22 <Guest_57> when trying to install Haskell it keeps show me this... any ideia?
14:35:35 <fog> why are you using curl?
14:35:54 <wroathe> Guest_57: You're getting an error establishing an SSL connection to downloads.haskell.org
14:39:23 <Guest_57> i am using curl because they suggest to use 
14:39:24 <Guest_57> Run the following in your terminal, then follow the onscreen instructions.curl https://get-ghcup.haskell.org -sSf | sh
14:40:07 <Guest_57> how can i solve the SSL connection?
14:40:31 <fog> but why not just use the haskell-platform ?
14:41:11 <fog> are you trying to build an old version or hack ghc or something?
14:41:39 <davean> I'm wondering if his system somehow lacks the LE root cert or something
14:41:42 <fog> im not sure if this is the place to ask about curl ssl issues
14:41:47 <davean> It doesn't say what sort of failure it is
14:42:00 <davean> though actually, one second I'm not sure he'd see the LE cert on DHO
14:42:23 <Guest_57> i tried this also brew cask install haskell-platform^[[CError: Cask 'haskell-platform' is unavailable: No Cask with this name exists.
14:42:25 <davean> No, he'd get the fastly served one
14:42:38 <davean> which ... maybe his SSL is too older to do TLS 1.2 or newer?
14:42:54 <davean> Though LibreSSL shouldn't have existed long enough ago to lack that
14:43:49 <fog> the haskell platform is here; https://www.haskell.org/platform/
14:44:17 <davean> Guest_57: can you try download.haskell.org directly and see what the more detailed error is?
14:44:52 <Guest_57> yes i have done that
14:45:00 <davean> and?
14:45:13 <fog> the haskell platform page has instructions using eg. apt-get for linux
14:45:34 <__monty__> fog: You don't have to push the platform on people who don't want it.
14:45:37 <Guest_57> there is no direct download 
14:45:51 <Guest_57> theres that curl to copy to terminal
14:46:22 <Guest_57> Run the following in your terminal, then follow the onscreen instructions.curl https://get-ghcup.haskell.org -sSf | sh
14:46:41 <__monty__> Guest_57: You can simply visit that url in a browser.
14:46:41 <fog> monty: but there was an earlier attempt to obtain the platform above using some unfamiliar tool
14:46:47 <davean> Guest_57: And if you look in the file - or even just do any conncetion to DHO - you'd be able to specify you want a more specific error
14:47:08 <davean> Theres nothing magic about a shell file - other than its unsafe to run like that :/
14:47:45 <davean> a shell file is just shell commands
14:48:00 <wroathe> Guest_57: Run "brew update"
14:48:07 <Guest_57> okay i am going to be honest i am a noob studying computer science and am just trying to install Haskell on my Mac
14:48:07 <__monty__> davean: Not really though. It's provided using https and presumably the server's not compromised.
14:48:41 <wroathe> Then do: brew --version and tell us what version you're on
14:49:02 <__monty__> davean: Or do you not install software from servers out there ever?
14:49:18 <Guest_57> 2.1.9 brew version!!
14:49:58 <davean> __monty__: Not like thta I don't.
14:50:26 <wroathe> Guest_57: Run: brew install ghc cabal-install haskell-stack
14:50:37 <davean> __monty__: thats a targetted attack vector. Its too high risk.
14:51:03 <__monty__> davean: Packages get compromised too though. There's not any more risk.
14:51:06 <wroathe> Actually, you might need to do those separately with homebrew, so it would be: brew install ghc, brew install cabal-install, and brew install haskell-stack
14:51:18 <__monty__> It's actually *easier* to audit than apt.
14:51:19 <davean> __monty__: package comprimised are general risk, not targetted
14:51:29 <davean> __monty__: no, actually its harder
14:51:42 <__monty__> No, you can fetch, check, then run.
14:51:47 <davean> __monty__: yes
14:51:51 <davean> but thats NOT whta that does
14:51:52 <__monty__> With apt you'd have to audit apt.
14:51:57 <davean> you can't download, check, and then run that
14:52:02 <davean> becuase what you request is often switched out
14:52:09 <davean> this is a very standard attack
14:52:14 <davean> active in the wild regularly
14:52:21 <davean> you need to ru nthe one you check.
14:52:22 <__monty__> What? The thing that's on your disk is what you check and execute.
14:52:29 <davean> __monty__: not with that ocmmand it isn't
14:52:32 <__monty__> Let's go to offtopic though.
14:53:16 <__monty__> curl https://get-ghcup.haskell.org -sSf -O; sh get-ghcup.haskell.org # Literally all you have to change.
14:53:27 <__monty__> You can do all the auditing you want in between.
14:53:30 <davean> __monty__: its a very critical change
14:54:12 <wroathe> Guest_57: Working?
14:54:27 <Guest_57> no..
14:54:35 <wroathe> What's not working about it?
14:54:51 <wroathe> What does, "brew install ghc" tell you?
14:55:13 <Guest_57> it just crashed the terminal
14:55:28 <davean> ... how can a terminal crash?
14:55:34 <wroathe> wat
14:55:35 <davean> something is wrong with your system.
14:55:49 <wroathe> This looks like a job for watman
14:55:55 <davean> No terminal out there is so shoddy it'll crash under any normal cases
14:56:25 <Guest_57> i am going to try again the same 
14:56:27 <davean> you'd have to be one some seriously nitch, untested software, or theres something wrong on your system.
14:59:05 <Guest_57> okay it worked i think
14:59:11 <Guest_57> thanks a lot!!!
14:59:38 <wroathe> You'll probably want at least cabal-install too if you're just starting out
14:59:48 <wroathe> haskell-stack can probably wait
15:00:05 <Guest_57> how do i know it works ? just typing gchi?
15:00:20 <davean> thats a good start. That shows ghc works
15:00:22 <wroathe> what does: which ghc output?
15:01:48 <Guest_57> it tells me the place where ghc is
15:02:11 <Guest_57>  thanks!
15:07:56 <fog> anyone had any joy with the backpack struggle?
15:10:38 <Cale> fog: Are you still really sure you want backpack for this?
15:11:22 <Cale> Or was it the whole point all along? I don't know that I'd bother with it for abstracting over different implementations of linear algebra stuff vs. just using ordinary functional programming methods.
15:12:08 <fog> hmm, ok. so the example yeasterday worked well, it showed the rotate example performing better than overlapping classes
15:12:20 <fog> so for that example yes, backpack seemed like the best tool
15:13:24 <fog> but it certainly seems unwieldy and with uninformative errors and poor documentation, so maybe not great at this stage in its development for incorporating into serious projects
15:13:37 <fog> however, i do still think its worth trying to complete this example 
15:13:55 <fog> if it can work, then a clean writeup might make a good resource for the community
15:14:08 <fog> and help backpack gain traction
15:14:30 <fog> the example was devised to try and use it in a way that seems like a common aim
15:14:51 <__monty__> Cale: Wouldn't backpack minimize overhead? Considering we're talking about math libraries.
15:14:54 <davean> fog: the writeups on backpack are bad. GHC tickets might be some one the better sources.
15:14:55 <fog> to modularise the signatures between projects like regular haskell projects seems to manage
15:15:36 <fog> monty: it seemed like the unpacked-containers mentioned some performance increase which seemed promising
15:18:37 <fog> davean: cant seem to glean much from there
15:18:59 <fog> it seems like it should be fairly straitforward for someone that understands how to use cabal
15:19:21 <fog> i think the reason i am failing is because im struggling to learn both those tools at the same time
15:19:23 <davean> fog: its just where everyone I know who actively uses it seems to have learned it.
15:20:03 <fog> the module was supposed to be structured so that all that needed was for someone to help write the cabal file, with everything else being as simple as possible
15:21:16 <fog> this is a good place to start if you havnt checked it yet; https://github.com/fog-hs/rotatePlugin/blob/master/src/src/TestRotatePlugin.hs
15:22:04 <glguy> DigitalKiwi: Hi
15:22:27 <fog> this section of the project on which it depends builds successfully and can serve as an introduction to backpack  
15:22:27 <fog> https://github.com/fog-hs/rotate
15:22:27 <DigitalKiwi> hi glguy
15:32:55 <electricityZZZZ> so i think that i understand algebraic data types but i am not understanding the breadth of the relevance of rings, groups, etc to code in a broad sense
15:33:31 <electricityZZZZ> i do have a maths background so i know what those are, but i still haven't quite pierced this whole so-called "category theory" aspect of programming
15:36:45 <fog> functors is the key point there
15:36:50 <davean> electricityZZZZ: well, do you see how say, monoids, abstract over lists, maps, etc?
15:37:10 <fog> monoids and monads too to a lesser extent (wrt to understanding)
15:37:25 <fog> but understanding fmap via a communting diagram is ok
15:37:42 <davean> electricityZZZZ: or how everything that works in distributed systems is a semilattice?
15:38:46 <davean> electricityZZZZ: in a merge structure DB I have, I have indexes which are any semigroup for example.
15:39:07 <davean> generated as a monoid, finalized into a semigroup.
15:39:26 <electricityZZZZ> i am a step below that insofar as i dont know what the claim is--
15:39:42 <davean> sorry, which part?
15:39:52 <electricityZZZZ> am i supposed to be able to represent all of my program execution as a collection of rings, groups, etc?
15:39:59 <davean> Not generally.
15:40:12 <electricityZZZZ> or are these things just convenient structures for helping with typing
15:40:20 <davean> What those do is all you to abstract over what your functions use so you can decide that at a later time (late binding) while being correct.
15:40:28 <fog> i think the transformation semigroups community would have you believe so yes
15:40:34 <davean> they give late binding and abstraction without sacrificing correctness
15:41:03 <davean> The use of them enables massive code reuse.
15:41:14 <davean> In a way I've never seen in another system.
15:41:24 <electricityZZZZ> okay which is convenient, it sounds like
15:41:25 <fog> but that does not take into account the language itself
15:41:43 <fog> but the underlying computations certainly
15:42:44 <fog> i guess the idea is that by having the language expressing this underlying fact that it makes it more formal and then you get some theorems for free 
15:42:49 <electricityZZZZ> my mind is still very much in the imperative space
15:43:04 <davean> electricityZZZZ: Thats why I was giving actual examples
15:43:24 <davean> like the DB where I indexes for data ranges are clearly any semigroup over the subranges.
15:43:33 <davean> er, over indexes of the subranges
15:43:41 <davean> and distributed systems
15:43:48 <davean> where *any* alg is exactly a semilattice.
15:44:11 <electricityZZZZ> i think i can say that imperative programs essentially are loops, variables, mutations of those variables, and control flow
15:44:17 <EvanR> group would be a tall order for many things in computing to support
15:44:27 <EvanR> most things arent reversible
15:44:36 <davean> Yah, group is less common
15:44:55 <EvanR> since a ring is like two groups, even worse
15:45:00 <electricityZZZZ> so i think that i am trying to see how that would translate into rings
15:45:18 <davean> functor, monoid, applicative, semigroup, monad, semilattice, theres lots that are easily used. Not all fit often though. Don't force them, use them becuase they're right.
15:45:40 <electricityZZZZ> yes you are naming various algebraic structures,
15:45:47 <electricityZZZZ> i can also say "loops"
15:45:51 <davean> I was naming ones that often do fit.
15:45:59 <electricityZZZZ> but loops alone doesn't give me a program, i can't make a turing machine
15:46:11 <davean> Right but you're not forming the program with these
15:46:24 <electricityZZZZ> so then what forms the program,
15:46:26 <davean> you're forming the constraints and interfaces 
15:46:28 <davean> electricityZZZZ: code.
15:46:29 <electricityZZZZ> and what are these things
15:46:55 <davean> electricityZZZZ: a given monad provides the control flow for some monadic thing.
15:47:09 <davean> electricityZZZZ: some things work on any monad, those tihngs specifty monad as a constraint
15:47:22 <davean> a given monad provides the monad interface in the way that it is a monad
15:47:30 <gabbiel> is there a function akin to printf but instead collects the output to a string (sprintf) ?
15:47:40 <hpc> yes
15:47:43 <hpc> printf, funny enough
15:47:50 <gabbiel> huh
15:47:51 <davean> hpc: infact printf
15:47:59 <monochrom> Yes, our printf doubles as sprintf, use String rather than IO ().
15:48:00 <EvanR> > printf "%d" 5 :: String
15:48:03 <lambdabot>  "5"
15:48:07 <davean> electricityZZZZ: lets look at "when"
15:48:21 <davean> electricityZZZZ: when :: Applicative f => Bool -> f () -> f ()
15:48:25 <gabbiel> that's pretty cool, thanks guys
15:48:32 <infinisil> I think that's pretty ugly tbh
15:48:36 <EvanR> electricityZZZZ: you were naming imperative programming statements. You'l get futher in haskell by thinking of code as expressions
15:48:38 <davean> electricityZZZZ: see when is something that has a semantics on any Applicative structure.
15:48:57 <monochrom> Codomain polymorphism is always convenient and tricky.
15:49:09 <monochrom> Just look at maxBound and default >:)
15:49:10 <davean> like with my DB example, my DB knows how to manipulate a semigroup but the user provides the semigroup that leads to the results they want
15:49:19 <infinisil> monochrom: codomain just means the domain of the result?
15:49:28 <monochrom> Yeah!
15:49:37 <monochrom> In "X->Y", Y is the codomain.
15:49:39 <gabbiel> infinisil: printf is ugly?
15:49:49 * monochrom is not thrilled with the term "return type".
15:49:57 <electricityZZZZ> i don't know the difference between an expression and a statement
15:50:07 <infinisil> monochrom: But like, it being able to both be an IO action, an a pure result is kind of bugging me
15:50:10 <electricityZZZZ> i guess you are talking about a collection of assertions which have no chronological order
15:50:12 <monochrom> Math functions don't "return". They are.
15:50:12 <gabbiel> electricityZZZZ: expressions have values
15:50:18 <EvanR> this calls for a statement vs expression musical number
15:50:23 <gabbiel> electricityZZZZ: statements dont necessarily have values
15:51:03 <monochrom> Ah this one you probably want to view IO() as "recipe for the printing, not the printing itself".
15:51:20 <electricityZZZZ> i've deferred trying to understand IO for now, it gives me a headache
15:51:44 <EvanR> e := constant | x | e + e | -e | e(e) | \x -> e   -- basic expression language, notice how you can build arbitrarily complex expressions
15:51:56 <EvanR> you usually can't combine statements so easily
15:52:04 <gabbiel> its easy pham, just do them ; do a < getLine ; putStrLn a
15:52:27 <monochrom> Printing is effectful, but we are safe if we retreat to the recognition that based on the format string and the other arguments, what to print is purely determined.
15:53:09 <EvanR> in math and in haskell, evaluating expressions has no side effects. Statements usually are executed for their effects
15:53:34 <electricityZZZZ> okay so statements are effectful but expressions are not by this definition
15:54:28 <hpc> EvanR: almost
15:54:41 <EvanR> well, it's not really a definition, it's crossing various realms
15:54:55 <EvanR> haskell doesn't have statements, other languages have expressions that can cause side effects
15:54:58 <hpc> it's still sort of confusing, IO actions are expressions
15:55:03 <gabbiel> what if haskell had multiple values?
15:55:19 <monochrom> Then it would be Lisp.
15:55:47 <monochrom> I am not a fan of Lisp's multiple value mechanism, mind you.
15:56:04 <gabbiel> monochrom: to each their own, but it has uses
15:56:46 <oats> gabbiel: what do you mean by "multiple values"?
15:56:49 <electricityZZZZ> okay so i have expressions
15:58:11 <gabbiel> oats: functions can output multiple values; f(x) => y,z just as sqrt(4) => 2,-2
15:58:46 <oats> gabbiel: I mean, we have tuples
15:58:52 <oats> or do I misunderstand
15:59:06 <electricityZZZZ> so my code is expressions, and then the group ring etc defines... interfaces?
15:59:19 <oats> electricityZZZZ: hi there! it sounds like you're still pretty early in your haskell journey. can I recommend this? https://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
15:59:32 <davean> electricityZZZZ: Yes, they are like unto interfaces though it doesn't translate across perfectly.
15:59:34 <monochrom> I believe it's a pretty involved story for why you would use multiple values instead of lists or tuples.
15:59:44 <oats> electricityZZZZ: it starts explaining haskell from first principles; functions, types, and expressions
15:59:55 <electricityZZZZ> i can stop talking if i am bugging people. yes i have been through some tutorials like that
16:00:02 <davean> electricityZZZZ: you're definately not.
16:00:05 <gabbiel> oats: that's different for example, with multiple values, we can do; 1 + sqrt(4) => 3 ; but if it were a tuple, an error would arise
16:00:06 <hpc> they're interfaces in the "general term, not specifically how OOP defines it" sense
16:00:09 <oats> electricityZZZZ: lol, you aren't bugging people :)
16:00:11 <oats> we are here to be bugged
16:00:13 <EvanR> using tuples would seem to be slower, but that's why you have a compiler
16:00:20 <hpc> or APIs perhaps
16:00:25 <EvanR> and an underlying language with a fast multiple return
16:00:44 <oats> gabbiel: ah, I see. seems like that would require dynamic typnig
16:00:46 <gabbiel> im just wondering if multiple values are doable, or if they would cause conflict
16:00:50 <hpc> oats: does that mean electricityZZZZ is doing it wrong by not sufficiently bugging us? :D
16:01:45 <EvanR> gabbiel: returning a pair is more consistent with the rest of the language, and thanks to compilation, not necessarily slower
16:01:46 <oats> gabbiel: typeclasses define interfaces. for example, Show defines an interface for turning things into strings
16:01:52 <monochrom> They conflict with the fundamental Haskell premise that functions are really functions.
16:01:52 <oats> er, sorry, electricityZZZZ ^
16:01:55 <electricityZZZZ> i have crashed ghc a couple of times playing around with it... basically right away
16:02:10 * infinisil presses X to doubt
16:02:14 <electricityZZZZ> ghci, i should say
16:02:23 <oats> electricityZZZZ: a crash, or an exception? :)
16:02:27 <electricityZZZZ> it was a full on segfault
16:02:33 <oats> ooh, a segfault
16:02:35 <oats> those are fun
16:02:53 <electricityZZZZ> it was simple code,... enough to scare me away
16:02:56 <monochrom> Actually to be more precise, s/really/semantically/
16:02:59 <gabbiel> monochrom: its still a function, because there is unique output for each input
16:03:03 <davean> electricityZZZZ: thats ... interesting
16:03:06 <oats> electricityZZZZ: could you share that code with us?
16:03:30 <electricityZZZZ> i dont have it anymore but if you follow a bunch of simple haskell tutorials you'll eventually find it if it is any kind of persistent defect
16:03:39 <electricityZZZZ> i would guess it was like evaluating fibonacii 
16:03:39 <davean> electricityZZZZ: Thats not a reasonable tihng unless you're playing with sometihng low level. At the level you're at that should represent an issue with the install or something I'd think.
16:03:41 <monochrom> No I thought the whole point of Lisp multiple values was non-uniqueness.
16:03:49 <electricityZZZZ> with maybe fib(100) recursively or something to that effect
16:03:58 <electricityZZZZ> no this was super basic stuff
16:04:15 <oats> might've overflowed the stack?
16:04:19 <oats> too many thunks
16:04:30 <electricityZZZZ> okay but why would you guys let that segfault
16:04:34 <davean> perhaps. Thats generally not a segfault though last I checked (haven't done it recently)
16:05:07 <gabbiel> monochrom: i dont think so, multiple values are used for convenience, for example, (floor 3.4) => 3, 0.4
16:05:24 <oats> electricityZZZZ: fwiw, I've never encountered a segfault with a haskell program. I don't think anyone *lets* anything segfault, it's just that software is really hard to write and sometimes you can't iron out all the wrinkles
16:05:34 <EvanR> just wondering, what advantage do you see in doing that vs using (3, 0.4)
16:05:35 <davean> electricityZZZZ: running out of c-stack is inherarnly a segfault because theres a guard page at the limit.
16:05:41 <electricityZZZZ> happened to me within like 15 minutes of starting :-P i swear
16:05:44 <davean> but it has to be the system stack not the haskell stack.
16:06:01 <davean> oats: no people do let things segfault, its semanticly correct in some cases.
16:06:06 <davean> oats: and that really important.
16:06:13 <gabbiel> oats: I thought haskell was segfault proof, as long as you write legal code of course
16:06:14 <oats> davean: good point
16:06:31 <oats> gabbiel: hmm, I don't think haskell's ever claimed to be segfault-proof
16:06:36 <electricityZZZZ> also there seems to be an obsession with lists in haskell code but i have been taught that lists are bad, cache unfriendly etc
16:06:37 <davean> gabbiel: segfault can be related to system limits and protection.
16:06:41 <oats> if you run out of memory, you run out of memory
16:06:49 <electricityZZZZ> this was on a system with 16gb of ram
16:06:52 <oats> a cool type system doesn't let you escape the bounds of hardware
16:07:03 <electricityZZZZ> running nothing but ghci and plain old linux
16:07:29 <davean> descending a lot of unevaluated thunks COULD have blown out the system stack in some edge cases ... seems odd
16:07:30 <oats> electricityZZZZ: again, it's really hard to diagnose what went wrong if we don't know what code you ran. we believe you, there's just... not much we can do about it
16:07:44 <fog57> ok, i have tried something more simple
16:08:05 <fog57> which also does not work, but might be easier to help with from a purely cabal perspective
16:08:07 <gabbiel> when i mean segfault free, I mean segfaults caused by things it can control (i.e. bugs in the compiler). haskell cannot control memory, so it wouldn't qualify as a segfault
16:08:12 <fog57> https://github.com/fog-hs/rotateDistributed
16:08:24 <EvanR> if it says segfault, it's a segfault
16:08:31 <EvanR> qualified or not
16:09:12 <fog57> cabal install works in the rotate directory, but fails with an error in the "rotate use" directory, saying that it cant see the other build. i tried adding it to the path but that did not help 
16:09:13 <monochrom> Gosh why is everyone so anal.
16:09:22 <gabbiel> ok, aside from terminology, are there cases where segfaults happen because of bugs?
16:09:40 <EvanR> yep
16:09:41 <monochrom> I mean I am only anal about when to use the word "function" meh.
16:09:54 <EvanR> if you misuse the FFI, it's really easy
16:10:08 <electricityZZZZ> no FFI
16:10:09 <davean> the FFI is actually haskell now too
16:10:19 <fog57> is there a flag to give the location of the directory?
16:10:30 <davean> FFI made it into the report :)
16:10:31 <electricityZZZZ> anyway,... but i was trying to get a picture of how this "category theory" stuff fit in with how i define my program
16:10:46 <gabbiel> what are your guy's thoughts on the book "haskell from first principles"?
16:10:57 <oats> gabbiel: I've heard nothing but good things about it :)
16:10:59 <electricityZZZZ> it looks like you guys are saying that it is a constraint on the code but not fundamental to the control flow
16:11:05 <fog57> is there another chat i could ask about these cabal specific issues?
16:11:31 <oats> electricityZZZZ: I don't know any category theory, and I've never felt like I need to understand it to be productive
16:11:39 <gabbiel> oats: i was talking here a while ago and someone said the book was garbage, is he a loner or what
16:11:47 <oats> gabbiel: ¯\_(ツ)_/¯
16:11:50 <oats> first I've heard it lol
16:11:53 <electricityZZZZ> oats: which is why i am putting it in quotes,... ok
16:12:27 <monochrom> Cartesian-closed categories are very good models of lambda calculi.  Apart from that IMO don't expect category theory to tell you much about programming.
16:12:32 <EvanR> you don't need category theory to use haskell, but you could learn it separately for fun (and profit?)
16:12:37 <electricityZZZZ> https://ocw.mit.edu/courses/mathematics/18-s097-applied-category-theory-january-iap-2019/lecture-videos-and-readings/
16:12:49 <gabbiel> the book claimed that recursive functions are done through the Y combinator, is that so?
16:13:05 <gabbiel> *recursive functions are implemented
16:13:23 <monochrom> No.
16:13:26 <EvanR> that'd be a pretty lousy way to do it
16:13:32 <fog57> what are you doing?
16:13:33 <monochrom> And Y isn't possible in Haskell (or any typed language)
16:13:41 <davean> electricityZZZZ: the type with that property is what provdes the control flow
16:13:52 <davean> those constraints are HOW it provides the control flow.
16:14:04 <gabbiel> then the book is lying?
16:14:23 <fog57> just making it seem more difficult than nesacary
16:14:44 <monochrom> But in untyped lambda calculus, you may use Y for recursion. But even then it is not the only way. (I prefer diagonal instead.)
16:14:59 <fog57> jibberish
16:15:20 <electricityZZZZ> davean: the type with "that" property--what does "that" refer to?
16:15:22 <oats> but from what little I understand, category theory is mostly about abstracting away from the specifics of operations, trying to get a better picture of a problem by going higher up, and I encountered something the other day where abstraction was really useful. I've got a toy thing I'm working on where I use a lot of Text strings, but some String strings snuck in and I have to concatenate both frequently. I
16:15:24 <oats> was getting annoyed about having both (++) and (T.append) strewn all around, but I remembered that Text and String are both Semigroups, and so I could replace the use of both with <>. The same task is accomplished, and the program is now easier to read
16:15:26 <monochrom> Or the book doesn't know everything.
16:15:27 <gabbiel> monochrom: how so, there certainly exists a version where there's no need for names. 
16:15:39 <gabbiel> i.e. just an anonymouse function
16:15:44 <davean> electricityZZZZ: whatever Monad/Applicative/Monoid/etc that the code ends up specialized to to actually be produced/run
16:16:07 <maralorn> gabbiel: Y is the standard way off introducing recursion in untyped lambda calculus. So the book is not stupid. But it is not used in Haskell, if it says that it‘s wrong.
16:16:12 <Lears> monochrom: Y is perfectly doable in Haskell, you just need a newtype to "equate" the types `Y a` and `Y a -> a`.
16:16:18 <davean> electricityZZZZ: functions are proofs given properties, the thing with those properties and the rules for it control the result.
16:16:34 <electricityZZZZ> "given properties"?
16:16:34 <davean> hum not rules, semantics I guess
16:16:53 <fog57> its just unnecessary and unintuitive terminology
16:16:55 <texpat[m]> gabbiel I'm on page 1194 of 1257 and can recommend it. I have talked to one person who didn't like it, but when I asked them why, I found their answer lacking.
16:16:56 <davean> electricityZZZZ: given a semigroup, and instances for subranges, I can give you a semigroup for an overall range.
16:17:11 <davean> er
16:17:19 <monochrom> OK I concede that one.
16:17:19 <davean> I can give you *that* semigroup for an overall range
16:17:21 <davean> to be clear
16:17:22 <gabbiel> texpat[m]: im on page 1k, I intend to finish it
16:17:23 <EvanR> i read through all of "category theory for programmers" and i did not see any point where anything applied to programming, i was lied to
16:17:33 <EvanR> i think the relationship as over emphasized
16:17:46 <gabbiel> texpat[m]: but I skipped the chapter 13 and 14 lol
16:17:47 <fog57> what, ol' bartoz? nah, top reference
16:18:19 <EvanR> it's a good intro to CT but
16:18:37 <fog57> but nothing, waste of time any other way
16:18:44 <EvanR> having been raised on a bookstore aisle dedicated to "how to code", i felt tricked
16:18:45 <monochrom> "for programmers" simply means programmers may be able to understand.
16:18:52 <maralorn> I think it‘s like mathematics and physics. You can‘t do physics without math. Doesn’t mean you have to understand and talk about like a mathematician.
16:19:21 <monochrom> Like if I wrote a "Haskell for Javascript programmers" I am not going to tell you how to use Haskell to write Javascript code now, am I?
16:19:21 <electricityZZZZ> you can't do physics with math either ;-P
16:19:28 <fog57> no then you reinvent the wheel
16:19:28 <texpat[m]> gabbiel I've read all of the chapters but have skipped a few exercises. I'm solving most of the exercises in PureScript.
16:19:44 <gabbiel> texpat[m]: lmao aren't you supposed to use haskell?
16:19:56 <davean> gabbiel: supposed to?
16:20:03 <davean> gabbiel: I see we're being proscriptive :-p
16:20:04 <maralorn> electricityZZZZ: Not sure what you are aiming at.
16:20:16 <electricityZZZZ> davean: so i write expressions which are generic over these algebraic structures
16:20:21 <EvanR> same thing with "softare foundations", this is not the foundations of software, at all
16:20:40 <electricityZZZZ> like this question is very basic and high level here, probably much simpler than you are thinking it is
16:20:44 <fog57> total shambles 
16:20:47 <gabbiel> texpat[m]: but seriously, some exercises I've found are easier to do my way.
16:20:50 <davean> electricityZZZZ: yes, and then you provide various algebraic structures that get the results you want at various times
16:21:11 <gabbiel> I hope the book covers GADTs though.
16:21:13 <fog57> what like schemes?
16:21:37 <electricityZZZZ> davean: "get the results" is i think where i am stuck
16:21:46 <texpat[m]> gabbiel PureScript shares a lot of similarities with Haskell, so the solutions often look very similar (sometimes even identical).
16:22:01 <monochrom> OK my "Haskell for Javascript programmers" will be full of exercises that are better done in Javascript than in Haskell >:)
16:22:06 <fog57> haskell is just a section of a stable vector bundle in the moduli space of topological sheves  
16:22:07 <davean> electricityZZZZ: the genericised thing doesn't in a sense exist - you can't run it genericly you have to run it with a given structure.
16:22:07 <gabbiel> tell me about PureScript
16:22:22 <davean> electricityZZZZ: which given structure may change at runtime
16:22:22 <electricityZZZZ> perhaps part of it is that i can model the program state in a single threaded BASIC program as just like the line number jumping around plus global variables in memory
16:22:34 <texpat[m]> gabbiel the book only touches on GADTs lightly. They call them an intermediate topic, out of scope of the book.
16:23:01 <gabbiel> texpat[m]: wtf, but aren't GADTs part of haskell programming?
16:23:15 <davean> electricityZZZZ: while technically you could do that with Haskell, you very much shouldn't because it doesn't closely relate to the code and theres a lot of options as to which variation of that a compiler puts it into
16:23:25 <fog57> anyone trying to develop haskell with the help of others is stuck in the past and should just give up on life
16:23:33 <electricityZZZZ> davean: "do that"?
16:23:36 <gabbiel> how does threading work in haskell btw
16:23:49 <davean> electricityZZZZ: model it as line numbers, jumping around, and variables in memory
16:23:52 <monochrom> GADTs are pretty learnable from just the GHC user's guide.
16:24:04 <gabbiel> do I just use the concurrency and parralellism modules or is it an IO thing?
16:24:05 <electricityZZZZ> davean: i am giving that as an example of something which haskell is not
16:24:20 <electricityZZZZ> davean: my question is, what is the equivalent in "haskell-BASIC"
16:24:35 <davean> electricityZZZZ: any given run of a haskell program ends up as basicly that, but what basicly that is very open
16:24:47 <davean> electricityZZZZ: there isn't really.
16:24:53 <davean> electricityZZZZ: wrong terms.
16:24:59 <infinisil> monochrom: Would it be correct to say that the thing GADTs provide over normal data declarations is that they allow constructor arguments to influence the resulting type? 
16:25:05 <nkaretnikov> hi! any cryptol users around? the #cryptol channel is silent :(
16:25:08 <texpat[m]> gabbiel PS transpiles to JS. It's a pure, strict language that is largely based on Haskell, but has (from what I hear), learned from some of Haskell's warts and avoided them.
16:25:18 <davean> electricityZZZZ: implimentations can vary a lot.
16:25:49 <davean> electricityZZZZ: its equations that provide computations that are only required to be done if their results are needed but may or may not be 
16:26:01 <electricityZZZZ> gabbiel: i found PS hell to install and they had an exploit in a recent installer but yeah the language looks cleaner and it emphasizes strictness by default
16:26:07 <xsperry2> hi. is there a safeWriteFile function in prelude or some third party package? (that writes to a temp file first)
16:27:24 <monochrom> infinisil: Yes. But need to be more refined and say you're defining a parametrized type, and the constructor can choose or narrow down the type parameter.  And then you can also have an existential constructor, orthogonally.
16:28:07 <texpat[m]> gabbiel there's a PS discord channel and a couple of active PS channels at functionalprogramming.slack.com if you're interested in learning more. (also several active Haskell channels on the fp slack server).
16:28:32 <davean> electricityZZZZ: It thought it was only an exploit against the installer?
16:29:46 <electricityZZZZ> davean: yeah it made the install fail,... not sure about what else
16:30:00 <electricityZZZZ> also it can run on the erlang VM so that's pretty neat
16:31:45 <xsperry2> if not is temporary-rc the package to use for creating a temporary file portably?
16:32:00 <texpat[m]> gabbiel I had no problem installing PS on the first try, and the 'exploit' was not harmful to anyone trying to install it. Rather, the 'exploit' consisted of malicious code that made the installer fail to install. I'm pretty sure 'exploit' is not the correct word to describe it.
16:32:06 <infinisil> monochrom: How do you mean an existential constructor?
16:32:14 <davean> xsperry2: theres one for doing atomic writes if thats what you mean.
16:32:44 <electricityZZZZ> https://www.categoricaldata.net/aql.html there also is a "categorical query language" but what advantage this has over sql i haven't yet understood
16:32:55 <xsperry2> davean, I guess? I want to avoid losing original file I'm overwriting if writing wasn't completed for whatever reason
16:33:11 <davean> xsperry2: http://hackage.haskell.org/package/atomic-write
16:33:54 <xsperry2> "Atomically write to a file on POSIX-compliant systems while preserving permissions." <- does that eliminates windows? :). I have to support linux, OS X and windows
16:34:13 <davean> Oh god, windows? I can't help you and no one can :)
16:34:43 <monochrom> "data X = forall a. Show a => Ctor a" can be rewritten as "data X where Ctor :: Show a => a -> X"
16:35:02 <xsperry2> I haven't had any issues yet. can't be that hard to open a temp file in a portable way
16:35:22 <davean> xsperry2: the temp file isn't the hard part.
16:35:30 <hpc> xsperry2: windows has been "posix-compliant" since 1988 - https://en.wikipedia.org/wiki/Microsoft_Windows#Early_versions_2
16:35:38 <xsperry2> davean what part is?
16:36:00 <davean> xsperry2: the atomic rename, or use of a filesystem transaction, at least without leaving temp files randomly around.
16:36:26 <xsperry2> hpc, I know it is in theory. but when a library claims it supports POSIX-compliant OSes it usually means *nix. I can try it though
16:36:57 <davean> xsperry2: it calls through to unix-compat's rename
16:37:06 <davean> so I think its good
16:37:12 <davean> but it could leave a mess on failures.
16:37:16 <xsperry2> davean, I don't need to go that far.. just writing to a temp file, and using plain non-atomic rename function will be good enough
16:37:35 <orion> haskellstack.org is down.
16:37:36 <hpc> this might also help to understand the value of writing to a temp file first - https://danluu.com/deconstruct-files/
16:37:37 <davean> xsperry2: well writing that temp file, if it has a name, can leave random files around.
16:37:57 <davean> xsperry2: and a non-atomic rename leaves several error cases.
16:38:04 <xsperry2> such as?
16:38:06 <davean> xsperry2: I agree you probably won't often see an issue though.
16:38:08 <hpc> wait, wrong link
16:38:16 <davean> xsperry2: non atomic rename can sometimes lose BOTH files.
16:38:23 <davean> as an extreme example.
16:38:41 <xsperry2> when would that happen?
16:39:03 <xsperry2> how about writing to a temp file, copy the temp file to destination file, delete temp file?
16:39:10 <hpc> imagine rename from to = do {delete to; lowerlevelrename from to}
16:39:12 <davean> how are you doing that copy?
16:39:40 <davean> now I think rename on windows is atomic and you'e fine.
16:39:42 <xsperry2> actually that is probably even worse
16:39:48 <davean> but the temp file can leak potentially.
16:39:51 <davean> you'd have to check the semantics.
16:40:15 <xsperry2> ok. I'm curious though, in what cases could non-atomic rename lose both files?
16:40:20 <davean> On a POSIX system you can do it at the Fd level so you never have a name until you link.
16:40:30 <davean> xsperry2: he just described one (hpc that is)
16:41:19 <davean> xsperry2: really you're probably fine. You're not talking weird systems there.
16:41:22 <xsperry2> I see how to is lost, but not sure how from is
16:41:30 <davean> your worst case is temp files leaking on fault.
16:41:35 <dexterfoo> phadej: hi, i have pinged you on github on your servant pull request (#1137), at your earliest convenience i would be utmost appreciative if you would take a look. thanks you
16:41:39 <davean> xsperry2: from never hit disk.
16:41:43 <davean> xsperry2: theres no sync.
16:42:01 <davean> from exists only in memory.
16:42:06 <davean> it isn't commited.
16:42:20 <davean> filesystems aren't strictly ordered.
16:42:43 <xsperry2> atomic-write depends on unix-compat, which depends on Win32
16:42:47 <xsperry2> maybe it does work on windows
16:43:46 <SolarAquarion> hi, trying to wrangle with package of a cabal only (nix-style) packages on arch
16:44:22 <davean> xsperry2: filesystems are generally designed to be fast, not preserve data. You only have guarrentees about data when they're specificly required to. In in cases like atime not always then :)
16:45:16 <davean> xsperry2: do be aware of temp file leaks.
16:46:04 <xsperry2> I just had a real-world case where I lost my entire database (thankfully I had a backup). some parsing failed, and because of laziness, it was only evaluated during writeFile.. reducing entire database to 0 bytes :)
16:46:15 <dada_cetacean> i have a datatype List' = {head :: a, tail :: [a]} for nonempty lists; can i construct a lens which targets head:tail?
16:46:19 <Maxdamantus> Regarding filesystems and "designed to be fast", it should be noted that unless you're doing CoW or journalling of the data you need ordered or synchronising after each write, you're basically not guaranteed an ordering.
16:46:52 <Maxdamantus> also note that journalling filesystems normally only journal metadata by default, so data itself is not ordered.
16:46:53 <davean> xsperry2: even postgresql had a major issue with this recently.
16:47:14 <xsperry2> I'm using aeson. it rewrites entire json each time
16:47:17 <davean> xsperry2: They assumed on a failed fsync they could fsync again and get success and have it do the data that had failed.
16:47:29 <Maxdamantus> (journalling everything effectively halves your throughput, since you're writing everything twice)
16:47:33 <davean> but fsync only syncs data *since the last fsync*
16:47:37 <hpc> which is another lesson, don't think fsync can save you from filesystem unpredictability
16:47:41 <davean> so the failed data has to be rewriten entirely.
16:47:50 <davean> so oyu can't fsync without whole program knowlege.
16:48:22 <davean> Maxdamantus: its worse than halves effectively.
16:48:55 <xsperry2> I'm pleasantly surprised.. atomic-write compiles on windows
16:48:57 <phadej> dexterfoo: I'm not working on servant atm, so completely phased out the context. Probably you'll need to reimplement a Link intepretation to be more like Docs and "zip" the routes. But really, I cannot help right now. I hope there are other people who can help with servant.
16:48:57 <davean> Maxdamantus: Because it adds seeks or page swaps depending on hard disks or solid state.
16:49:23 <davean> xsperry2: Oh it was definately going to compile. the question is are the semantics correct to avoid things like temp file leaks.
16:49:53 <davean> and how rename is implimented
16:49:55 <xsperry2> I can't say I care too much about some temp files remaining on disk until they are collectively purged
16:49:56 <davean> is it atomic or not
16:50:06 <davean> xsperry2: Theres nothing to purge them.
16:50:22 <xsperry2> I'm assuming they got semantics write. otherwise why support windows
16:50:40 <xsperry2> davean, purged by the system or script that deletes all temp files periodically
16:50:49 <xsperry2> write=right
16:50:53 <davean> xsperry2: you can't tell a file is a temp file other than its name.
16:51:12 <xsperry2> surely is uses system wide temp directory?
16:51:17 <davean> can't
16:51:19 <xsperry2> everything in there is a temp file
16:51:22 <xsperry2> why not?
16:51:25 <davean> rename only works for sure in the same directory.
16:51:34 <davean> you can't safely rename across directories.
16:51:49 <hpc> specifically across filesystem boundaries, but guess what signifies those
16:52:04 <davean> hpc: thats the most common case of issue but actually its worse than that.
16:52:21 <hpc> oh wait, right i remember this
16:52:22 <davean> rename is ONLY specified in important ways in a directory.
16:53:01 <hpc> directory and filename info can be two different pieces of data
16:53:06 <hpc> and you can't work with that atomically
16:53:29 <davean> hpc: welcome to filesystems.
16:53:37 <davean> hpc: life here sucks.
16:53:55 <davean> he world's shittiest databases
16:54:14 <oats> lol, I hadn't thought of filesystems in that way
16:54:17 <xsperry2> what naming convention does atomic-write use for temp files?
16:54:20 <mniip> davean, debatable
16:54:29 <davean> xsperry2: "atomic.write" as the tempfile base name.
16:54:31 <hpc> nah, it's tied at worst - think of all the databases that depend on having a filesystem
16:54:56 <davean> oh, oh
16:54:58 <davean> and you know what?
16:55:11 <davean> On linux and some other systems rename isn't even reliable in a directory! Because of overlays
16:55:12 <xsperry2> ok.. so worst case scenario, on write fail the original file will be deleted, and atomic.write* will exist in the same directory?
16:55:18 <mniip> just store the entire thing in RAM
16:55:43 <hpc> davean: does that mean it's not even reliable if you rename a file to itself?
16:55:51 <davean> hpc: hum ... I think so
16:56:37 <davean> hpc: Ok yah
16:56:57 <davean> hpc: in an overlay a rename ot its self can make there be a different file at that name unrelated to the origional file even.
16:57:04 <hpc> amazing
16:57:04 <davean> I think
16:57:09 <davean> heres how
16:57:13 <davean> say you have 3 layers
16:57:21 <davean> the bottom layer has that file, lets call it f0
16:57:33 <davean> the second layer has that name also, lets call that f1
16:57:38 <davean> then the third layer doesn
16:57:40 <davean> t
16:57:47 <davean> a rename will move it to the 3rd layer, but thats not atomic
16:58:05 <davean> so that COULD potentially lead it to not being in the 3rd layer, being removed form the second layer, and exposing f0
16:58:30 <davean> via the whiteout property
16:58:53 <davean> hpc: scared yet?
17:01:07 <hpc> that rename could also delete f0, i think?
17:01:23 <hpc> the more layers you have, the less you know about which combination of layers still has the file
17:01:30 <davean> hpc: Not with the whiteout and not in a standard overlay but yes it could.
17:01:44 <davean> hpc: I was putting together the worst situation I could think of.
17:01:53 <davean> I figured losing the file was better than having the wrong file there.
17:02:04 <hpc> that's true
17:02:41 <davean> Now one would never have to worry about such a weird scenerio of course because overlays are rare
17:02:48 <davean> oh wait ... docker :-p
17:03:03 <hpc> doesn't the boot process use an overlay too?
17:03:20 <davean> yep but not in a way that should lead to problematic renames.
17:03:28 <davean> it uses swap_root
17:03:35 <davean> which is specificly safe for that
17:03:45 <davean> having it be its only real purpose :)
17:03:54 <davean> so yah, rename based safety is lost in docker.
17:04:07 <davean> thats great. Thanks hpc you've made me ruin my own day. Glad I don't use docker.
17:04:19 <hpc> anytime
17:04:59 <davean> I'm sticking to jails.
17:05:09 <Lears> Honestly overlays are underused, they're really convenient for uniting /read only/ media collections spread out over different drives or the network, etc.
17:05:15 <Maxdamantus> 11:53:33 < davean> he world's shittiest databases
17:05:28 <Maxdamantus> eh, ime database are all pretty shitty at this stuff.
17:05:47 <davean> Maxdamantus: they're not great but a lot have a decent query system and reasonable atomics.
17:06:03 <davean> They also are less context senstive in what does what
17:06:16 <davean> the rules might be unkind but they're generally not contextual.
17:06:26 <xsperry2> I replaced writeFile with atomicWriteFile. database is no longer flattened on the same error. :)
17:06:28 <Maxdamantus> Even the one that offer serialisability usually don't have it enabled as the default, and the way they support it seems to usually be quite strange.
17:06:32 <davean> xsperry2: :)
17:06:53 <davean> Maxdamantus: Sure but you specify what you want and often you don't want serializability.
17:07:06 <davean> Maxdamantus: I can recomend some good papers on the various implications if you like
17:07:20 <davean> (and why the SERIALIZABLE isn't always strong enough)
17:07:58 <Maxdamantus> davean: mm, I think I'm reasonably aware, but I suspect the vast majority of developers who interact with databases aren't.
17:08:23 <xsperry2> I do get atomic*.write remaining on error. not sure if that is expected
17:08:46 <davean> range locks and such are fun
17:08:56 <davean> xsperry2: Yes it sadly is.
17:09:08 <xsperry2> ok. I can live with that
17:09:08 <davean> you need to use a Fd and link to avoid it which isn't portable.
17:10:13 <davean> Maxdamantus: my distributed systems group had great fun with the various isolation level edge cases and disproofs.
17:13:46 * Maxdamantus had something that might be though of as "fun" implementing serialisable MVCC transactions on top of database without multi-key transactions.
17:14:34 <davean> Maxdamantus: which strength of serialisable?
17:15:07 <Maxdamantus> davean: what do you mean by "strength"?
17:15:25 <davean> Maxdamantus: there have been two definitions, one of which had issues with range queries.
17:16:14 <Maxdamantus> davean: this isn't something that has range queries. Each transaction manipulates (reads and/or writes) a discrete set of keys.
17:16:31 <davean> Maxdamantus: ah ok
17:16:58 <davean> Maxdamantus: in the SQL standard the theorticians lost the definition battle, and came back a decade later and showed there was actually a hole in the definition :)
17:17:40 <davean> Maxdamantus: this is the snapshot vs. serializable issue in the SQL standard.
17:18:26 <Maxdamantus> I haven't looked too much into how SQL tends to handle this, but aiui there have historically been issues around databases doing things like saying "serializable" but meaning "snapshot isolation"
17:18:44 <davean> yep because SQL specified a disalowed annomoly set
17:19:11 <Maxdamantus> afaict though, MariaDB does implement serialisability if you say "serializable"
17:19:21 <Maxdamantus> (fork of MySQL)
17:19:42 <davean> MySQL now thats an early 2000s thing
17:19:49 * Maxdamantus hasn't done much with that, but has done less with anything else.
17:20:31 <davean> Isn't MySQL only defined on various backends, so wouldn't you say its MyISM or whatever that does the serializability?
17:20:49 <davean> I thought MySQL only did the frontend part.
17:21:47 <davean> Sorry, I'm thinking back like 20 years now
17:21:52 <Maxdamantus> though speaking of MariaDB, as an example of the unclarity you get around this stuff with typical databases, MariaDB has some sort of cluster mode called "galera" which used to be documented as providing "snapshot isolation" when you ask for "serializable", but after jepsen figured out that it didn't even provide that, they just removed that part of the documentation.
17:22:11 <davean> lol
17:22:34 <davean> Thats really the sort of claim you check before you say it.
17:22:52 <Maxdamantus> anyway, gotta work
17:43:33 <Boarders> I am trying to do an operation on bytestrings that works on chunks of k Word8's at a time where k is variable
17:43:38 <Boarders> does anyone know a good approach to this
17:43:46 <Boarders> or is it easiest to just convert to a list and work like that
17:47:07 <Axman6> Does anyone know of a rope like array/vector structure? Looking for something which allows insertion into the middle without O(n) work
17:47:14 <Axman6> (insert and delete really)
17:54:21 <MarcelineVQ> requirments unclear :o
17:55:44 <argent0> Hi, any idea why can't GHC find the instance? https://bpaste.net/show/F0gE
17:59:31 <lyxia> argent0: Frob's first argument in the instance (r) has kind ((Nat,Nat) -> Type -> Type), but in someFunc, (Box ...) has kind Type
18:01:57 <argent0> 🤔 I think I'll drop all the whole `Foo` and just admit it is just a Box. Thanks
18:05:15 <Axman6> MarcelineVQ: An ordered array type which allows insertion in the middle efficiently. I may just use an IntMap, since it's going to be ordered by Word's
18:08:58 <infinisil> Axman6: Possibly Seq
18:09:20 <infinisil> Axman6: Yeah, see https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html#v:insertAt
18:14:25 <infinisil> Or from a hackage search, https://hackage.haskell.org/package/yi-rope looks promising
18:16:28 <infinisil> Or https://hackage.haskell.org/package/fingertree-0.1.4.2/docs/Data-FingerTree.html which yi-rope is implemented upon
18:18:34 <infinisil> Which apparently is just a generalization of Seq
18:22:00 <Axman6> yeah I was hoping for something which uses arrays internally, since I'm looking at having something like half a million elements, so am hoping to reduce memory usage as much as I can
18:26:05 <c_wraith> Unless you're on embedded hardware, half a million is small.
18:26:18 <Axman6> looks like it allocates about 200MB
18:26:25 <EvanR> an array based structure that lets you insert into the middle?
18:26:28 <c_wraith> but anyway, a rope should have array segments
18:26:47 <infinisil> Axman6: I'm thinking maybe a B-tree
18:28:21 <Axman6> YiString is implemented as a FingerTree Size Text, roughly, which is close to what I want. I think I'll try uding IntMap though, it's at least got arrays of keys internally
18:29:46 <infinisil> Axman6: Can't confirm, IntMap just looks like a normal tree to me, no arrays there
18:29:56 <Axman6> I asked a question in here the other day about sorting an array of words after their bits has been rotated left one bit
18:30:02 <infinisil> https://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.IntMap.Internal.html#IntMap
18:30:14 <Axman6> yeah, IntMap isn't what I thought, but  is still probably a good choice
18:31:08 <Axman6> anyway, turns out that the answer to my problem of sorting the result of rotating all words by 1 bit is to partition based on the low order bit, and then merge (a la merge sort) the two halves
19:38:44 <siraben> What's a good purely functional alternative to skip lists?
19:38:57 <siraben> I have to maintain a very large list of ordered elements and be able to insert new values, and delete old ones
19:38:59 <Axman6> what properties do you need?
19:39:04 <siraben> Where insert and delete return new copies of course
19:39:33 <siraben> Red-black trees, maybe?
19:39:46 <monochrom> Data.Map.Strict
19:40:03 <siraben> Also with a skip list I can do pred and succ in O(1) time, maybe log is a good compromise
21:43:59 <nullnullnull> guys, is there a way to include the sockets module together with the new haskell releases?
21:44:12 <nullnullnull> import Network.Socket
21:44:45 <nullnullnull> the old versions comes with Socket module installed
22:00:01 <heatsink> nullnullnull: You can run `cabal install network` to install it globally
22:02:21 <Cale> Yeah, that one is in the network package, as it has been for a very long time, though I think the network package might've been distributed with GHC quite a long while back.
22:02:43 <Cale> The "Network" module is just gone though.
22:02:58 <Cale> but "Network.Socket" is still there
22:03:37 <Cale> Also Network.BSD is in the network-bsd package, and Network.URI has moved to network-uri
22:03:50 <Cale> (those modules used to be in the network package)
22:17:14 <nullnullnull> hmm
22:17:46 <nullnullnull> this is confusing a bit 
22:17:47 <nullnullnull> sec
22:18:16 <nullnullnull> so which package i need to use to make my script work for all haskell-versions?
22:18:34 <nullnullnull> without installing extra stuff
22:19:09 <Cale> What's a haskell-version? There are various different haskell compilers. GHC is the most popular. You need the network package if you want Network.Socket.
22:19:25 <nullnullnull> ghc
22:19:46 <Cale> Probably what you ought to do is write a .cabal file for your project
22:20:08 <nullnullnull> to make the auto install package?
22:20:10 <Cale> So that you can specify its dependencies, and let cabal-install build
22:20:12 <nullnullnull> like shellscript
22:29:27 <Cale> nullnullnull: It's not really possible to assume that any particular package will be installed, but there are various tools that can help install packages needed to compile something.
22:30:34 <Cale> nullnullnull: However, the result of compilation is generally going to be statically linked against those libraries, so it should be fairly portable.
22:31:11 <nullnullnull> ah
22:31:44 <gabbiel> should haskell support multiple values or not?
22:31:54 <Cale> multiple values?
22:32:00 <nullnullnull> Cale, btw mate, you mentioned something about other compilers (not ghc). maybe the other compilers are different? (pre-installed packages)
22:32:19 <nullnullnull> modules
22:33:03 <Cale> nullnullnull: They will be somewhat different, but as to which packages specifically, I couldn't tell you.
22:33:34 <Cale> I mostly use GHC and GHCJS. There are some other compilers which aren't as ready for production use.
22:34:30 <nullnullnull> Cale, ah thanks 4 info mate :) 
22:35:03 <Cale> You might be able to consider Eta a Haskell compiler (targetting Java) -- I don't have much experience with that though.
22:36:19 <Cale> gabbiel: Could you explain more about what your question means?
22:36:19 <nullnullnull> I will try GHCJS ;) 
22:36:48 <Cale> nullnullnull: Well, it's not really suitable for using Network.Socket at all...
22:37:18 <Cale> nullnullnull: It's a Haskell to Javascript compiler -- we use it where I work for building web applications.
22:37:56 <nullnullnull> yes for full stack stuff
22:38:25 <nullnullnull> maybe I will find something there related to connections (other than network)
22:38:30 <gabbiel> cale: f(k) -> x,y
22:39:01 <Cale> If you're interested in playing with that, I'd recommend trying reflex-platform (which will use nix to get you all the dependencies, since it's a bit of a hassle to get everything set up), or else Obelisk (which is built on top of reflex-platform, and gives you a nice little application setup with a frontend and backend, static rendering with hydration, and a story for generating mobile applications from the same code)
22:39:18 <Cale> gabbiel: Haskell has tuples
22:39:39 <Cale> > let f x = (x^2, x^3) in map f [1..10]
22:39:42 <lambdabot>  [(1,1),(4,8),(9,27),(16,64),(25,125),(36,216),(49,343),(64,512),(81,729),(10...
22:39:49 <gabbiel> cale: tuples won't let me do this, 1 + f(k)
22:40:03 <Cale> What would you hope for that to mean?
22:40:18 <Cale> Is 1 added to one of the results of f, or both?
22:40:23 <int-e> . o O ( Haskell has tuples, but only of length 1. )
22:40:27 <int-e> > length (1,2,3)
22:40:30 <lambdabot>  error:
22:40:30 <lambdabot>      • No instance for (Foldable ((,,) Integer Integer))
22:40:30 <lambdabot>          arising from a use of ‘length’
22:40:31 <gabbiel> 1 is added to the firstmost value
22:40:32 <Cale> haha
22:40:37 <gabbiel> so x in this case
22:40:40 <int-e> > length (1,3)
22:40:44 <lambdabot>  1
22:40:52 <Cale> Well, you can write first (+1)
22:40:56 <int-e> Oh, it's only pairs.
22:40:58 <Cale> Or just use a lambda
22:41:04 <gabbiel> multiple values aren't tuples though
22:41:15 <gabbiel> that's why there's no parenthess
22:41:24 <Cale> Yeah, but that's a syntactic difference
22:41:57 <gabbiel> they still wouldn't be represented as tuples though
22:42:11 <Cale> I don't understand
22:42:12 <int-e> (I've just been bitten by this; I changed a function producing a list to return an additional value in a pair... and one of the things I did with this function was get the length of the result list. grr.)
22:42:27 <Cale> int-e: hah
22:42:45 <Cale> int-e: It does make sense because of how the Functor instance works though
22:42:52 <Cale> > fmap (+1) (10,20)
22:42:54 <lambdabot>  (10,21)
22:43:22 <Cale> gabbiel: If you're okay with acting on the second component rather than the first, that's what fmap will get you.
22:43:54 <Cale> But there are explicit first and second functions hanging out in Control.Arrow which you might use for applying a function to either component of a pair.
22:45:33 <Cale> gabbiel: I think it might be good to think about firstly what the type of "multiple results" would be, and how it would differ in any way from the pair type.
22:45:46 <gabbiel> cale: there woudldnt be fmapping
22:46:03 <gabbiel> cale: the function returns multiple values
22:46:09 <gabbiel> not tuples
22:46:24 <Cale> How does multiple values differ from a single tuple?
22:46:40 <Cale> The components of a tuple are each values
22:46:51 <Cale> So by returning a tuple, you are returning multiple values
22:47:09 <gabbiel> multiple values can be 1 or more 
22:47:43 <Cale> ... sure
22:47:52 <gabbiel> it differs because if f(x) = (a,b), I coudln't add 1 to f(x)
22:48:16 <gabbiel> but if f(x) = a,b then I can simply add 1 to f(x) and I would get 1 + f(x) = 1 + a
22:48:23 <gabbiel> notice the b gets dropped
22:48:27 <Cale> Well, only because there's no instance of Num for pairs
22:48:35 <gabbiel> its not a pair though
22:49:00 <Cale> Why would we want the b to get dropped?
22:49:42 <Cale> Presumably if f is producing that information, it's doing so for a reason, and destroying it probably shouldn't be so quiet
22:49:58 <gabbiel> its the default operation, we can choose b if we want to
22:50:11 <heatsink> This description reminds me of how Lua's functions discard excess return values
22:50:12 <Cale> You can already write something like  let (y,_) = f x in 1 + y
22:50:33 <gabbiel> that's a hassle
22:50:36 <Cale> is it?
22:50:43 <Cale> I don't consider it a hassle at all
22:50:44 <gabbiel> yes
22:50:47 <Cale> You can also write
22:50:56 <Cale> 1 + fst (f x)
22:50:59 <gabbiel> what if f(x) = a,b,c,d,e,f,g,h...,z
22:51:11 <Cale> Nobody uses tuples much larger than pairs
22:51:18 <heatsink> In that case, you probably should redesign your data structure
22:51:23 <Cale> If you have a large number of things you define a proper data type
22:51:40 <Cale> Probably with named fields, and probably structured into smaller types
22:51:53 <gabbiel> but that's just an excuse to not do it
22:51:56 <heatsink> It's quite likely that you will lose track of whether you took the eighteenth value from the tuple, or the nineteenth
22:52:01 <Cale> (because even record types are annoying with large numbers of fields)
22:52:25 <Cale> Nobody wants to remember what that many things mean positionally
22:52:49 <Cale> I don't even think tuples larger than maybe 4 should exist.
22:52:57 <gabbiel> its not about whether its appropriate, but wether its possible
22:53:13 <Cale> In fact, 3 is already pushing it, we could drop support for everything but pairs, and it would probably be for the best
22:54:12 <Cale> and just say, if you want to collect more things together, write a data declaration for your new type
22:54:54 <Cale> Obviously anything whose semantics can be specified is possible
22:55:05 <Cale> You'd have to come up with something at the type level for those things
22:55:37 <Cale> But the real question is whether having some weird kind of tuple most of whose elements will implicitly be discarded at the drop of a hat is really a good idea
22:55:53 <Cale> That seems like a great way to help people write bugs to me
22:57:19 <gabbiel> how so
22:57:28 <gabbiel> the firstmost value is always chosen
22:57:40 <gabbiel> the rest are forgotten except if you need them
22:58:22 <gabbiel> everything would behave the same except you now have the added choice of choosing which 
22:59:56 <heatsink> It's pretty common to write a function, use it for a while, and then change your mind about what the function returns
23:00:27 <heatsink> If your function originally returned one value, but now returns two, and if those values are both important, then probably all callers should be changed to accept two values
23:00:47 <heatsink> In that case, it's not good for a caller to silently discard one value because you didn't change it to accept two values
23:01:22 <Cale> ^^ exactly this
23:03:00 <gabbiel> heatsink: that's the thing, the second value is barely important, but still useful
23:03:50 <Cale> Well, if the second value is possibly useful, probably after changing f to produce it, you want to have a look at every place where f is used to see if the value can be leveraged
23:04:35 <Cale> The compiler will help you do that, if doing something about the value is mandatory (even if that's as little as pattern matching it away with a wildcard, or applying "fst" to discard it)
23:04:55 <gabbiel> only if you need it, not every place, chances are most functions wont change at all, except if they need it for sure
23:04:56 <Cale> It'll point out every location throughout your codebase where the change in type affected the code.
23:05:15 <Cale> This is a good thing -- it's extremely helpful.
23:06:19 <gabbiel> remember, if f(x) = a,b, where a and b are numbers, b will by default get dropped and a will be returned, thus, we can add with f(x)
23:06:40 <Cale> Yeah, I understand the feature you're proposing
23:06:42 <gabbiel> old functions will continue to work because a will be used, b will just get dropped
23:06:44 <Cale> I just don't think it's a good idea
23:06:55 <Cale> There's a reason that f produced b as well
23:07:06 <Cale> and we're very quietly ignoring it
23:07:35 <Cale> *too* quietly
23:07:51 <gabbiel> we're ignoring it because its not as important
23:09:34 <gabbiel> for example, in f(x) = sqrt(x), -sqrt(x), most people would use the positive root, as seen in the order, but -sqrt(x) is still a root
23:09:42 <Cale> Note that we can just as well define a second version of f which doesn't produce b for those would-be users of f who aren't interested in the second value
23:09:59 <gabbiel> they dont have to be interested, b gets dropped
23:10:32 <Cale> We can also define a version of f which is polymorphic in its result type
23:10:48 <gabbiel> and given haskell's infinite shenanigans, infinite return values would be interesting
23:10:56 <Cale> So that if the user of f demands a pair, they get one, and if they don't then they won't.
23:12:34 <Cale> (though then you have to deal with ambiguity, which may require explicit type signatures some of the time)
23:12:54 <gabbiel> the problem is you're confusing multiple return values with tuples
23:13:05 <Cale> I'm not confusing anything
23:13:09 <Cale> I understand what you're proposing
23:13:17 <Cale> I'm just saying that I don't want it.
23:13:30 <gabbiel> but its a cherry on top, why not want it?
23:13:35 <gabbiel> and the cherry can be ignored
23:13:39 <gabbiel> it changes nothing about haskell
23:13:42 <Cale> Because it can't "just be ignored"
23:13:58 <gabbiel> it can, that's the usefulness of multiple values
23:14:31 <Cale> I can mistakenly ignore these additional results, resulting in bugs. A library author can change the type of a function in a way which tacitly makes my program incorrect because I'm ignoring values I shouldn't be ignoring, and I won't be notified in any way
23:15:18 <davean> Yah, very much what Cale is saying
23:15:24 <davean> it totally breaks the safety properties
23:15:34 <davean> It negates the point
23:15:48 <Cale> *I* might think that it's okay to make a function produce a second optional result, and not think about everything that my change impacts
23:16:03 <Cale> and the compiler will be of no help to me
23:16:05 <gabbiel> those values aren't important though, but they are useful
23:16:21 <Cale> I'll just discover a month later that oops, that actually loses important data in some case
23:16:37 <Cale> They may or may not be important!
23:16:52 <davean> gabbiel: you can't provide a proof of that
23:16:58 <davean> gabbiel: thats subjective and thats the problem
23:17:12 <Cale> If they're unimportant, then why make f produce them at all? They're obviously unneeded.
23:17:14 <davean> its a ruinusly bad feature.
23:17:58 <gabbiel> they are useful though
23:18:04 <gabbiel> thats why they are also returned
23:18:09 <Cale> gabbiel: Consider the example you already gave before, the multiple solutions to an equation thing
23:18:50 <gabbiel> sure
23:19:00 <Cale> Maybe I use this function and forget to use the second root in some case, and because of that, my search for solutions is incomplete, and I write a buggy numerical algorithm
23:19:40 <Cale> The compiler isn't going to warn me "hey, you didn't use this thing", and in the code, it will be just look like I'm dealing correctly with a single number
23:19:43 <gabbiel> in that case, you wrote it knowngly that you ignored the second solution
23:19:47 <Cale> -be
23:19:52 <gabbiel> and the fault lies with you
23:19:56 <Cale> Not necessarily
23:20:24 <Cale> I might've forgotten that it produces a second value
23:20:51 <Cale> I mean, that's a fault that lies with me, but it's a fault that if I'd been using tuples, the compiler would have corrected me on.
23:21:20 <gabbiel> thats just negligence, obviously there would be a way to tell if a function returns multiple values, and it would be the responsibility of the programmer to find out
23:21:35 <Cale> So I get to safely be dumb in that way without it causing any problems. I like languages and compilers which allow me to be dumb and point out all my mistakes before letting me get away with them.
23:22:18 <Cale> I frequently neglect to make types match while programming, and let the compiler sort things out and tell me what I've got to do.
23:22:41 <gabbiel> but if you want to be allowed to forget, surely some a pragma would tell you
23:22:42 <Cale> That's sort of the point of having a static type system that you can get away with that
23:24:19 <gabbiel> i understand that point, but this can be easily fixed with pragmas that warn you
23:24:35 <Cale> Instead of that, how about we just use tuples, and then it's always an error?
23:24:58 <davean> you're taking a good, solid, system and making it leaky and conditional on being used correctly to work.
23:25:18 <davean> where the entire point is to avoid you having to use it correctly to avoid errors.
23:25:27 <Cale> and I can, with like 4 keystrokes either tell it explicitly where I'd rather ignore the excess values, or else deal with the problems
23:26:55 <gabbiel> cale: tuples are cumbersome, and can't have infinite aritiy
23:26:57 <Cale> A good programming language is one where it's not only easy to express what you want to do, but also hard not to express what must be done.
23:27:18 <Cale> Well, what would it mean?
23:27:39 <Cale> You'd need a way to generate an infinite sequence of types at compile time to check the code
23:27:51 <Cale> and then it would take forever to check
23:28:09 <gabbiel> davean: there wouldn't be errors, just neglect of the rest of the values, like I said. most functions depending on functions that return multiple values would work fine
23:28:21 <davean> gabbiel: neglect of the rest of the values *is* errors
23:28:42 <Cale> If you want to produce an infinite list of values of the same type, or an infinite list of values of more-specified types, that's perfectly doable by either using lists, or some custom datatype
23:29:09 <Cale> (and tuples aren't really special in any way apart from the concrete syntax of using commas and parens like they do)
23:29:15 <gabbiel> yes, generate a sequence of values, but you know they are all of some type a, which is easy to check 
23:29:21 <Cale> [a]
23:29:30 <Cale> Or Stream a
23:29:45 <Cale> data Stream a = Cons a (Stream a)
23:30:11 <Cale> There's your infinite tuple of values of type a
23:31:48 <gabbiel> but now I must work with tuples (and change every function that ever used it), where I can just return multiplee values (and have old definitions keep working)
23:34:17 <gabbiel> if lisp did it, I don't see why haskell can't either (and improve upon it of course)
23:34:27 <Cale> But that's actually a bad thing, mostly. Those functions were written to work with particular types, and nobody has thought through the implications that there's all this extra data available that will be thrown away.
23:34:37 <Cale> Just because lisp did a thing doesn't make it a good idea
23:34:57 <Cale> (Various lisps have done almost everything at one point or another)
23:35:15 <Cale> (Well, that's not true, they've done a lot of things though)
23:35:18 <davean> gabbiel: theres a strong reason we don't use lisp. And why most of the world has abandoned it.
23:36:11 <gabbiel> davean: lisp usage has nothing to do with its power
23:36:39 <davean> power and wisdom are unrelated, and actually many of the complaints about LISP related to that so ... no.
23:37:31 <Cale> I've spent some time writing programs in Scheme and Common Lisp, and found it largely incredibly frustrating to write real programs, because I'd spend three hours tracking down some incredibly fiddly bug where data was being produced incorrectly in one place and causing bad effects far downstream from there, and I'd realise that a typechecker would have caught it before I'd run my program once.
23:37:39 <MarcelineVQ> it's not the topic but scheme and clojure enjoy a lot of attention and innovation still
23:38:05 <davean> MarcelineVQ: scheme has a lot of acadmic attention
23:38:08 <Cale> and I just couldn't stand to have my time wasted like that
23:38:13 <gabbiel> cale: the data is uninmportant and will be thrown away, code will still work f(x) = a,b will still have type :: Int
23:38:39 <Cale> gabbiel: That's even *more* terrible than I suspected you wanted it to me
23:38:41 <Cale> be*
23:39:06 <Cale> Not reflecting the presence of that data in the type of the function would mean that it's as if Int is not just Int
23:39:26 <Cale> Int becomes effectively a union of all the tuple types which begin with Int
23:39:35 <gabbiel> a and b are ints so f :: Int -> Int
23:39:48 <Cale> There might be hidden values in there, and you might accidentally throw them away, and the type won't tell you anything about them
23:40:41 <davean> an I really wish there was a "dup" function in the standard library :(
23:40:55 <gabbiel> like I said, this can change with type declarations
23:40:59 <Cale> davean: I'm sorry, but that thread is dumb :P
23:41:08 <Cale> davean: Why not write (\x -> (x,x))?
23:41:15 <gabbiel> i just said that to highlight that f(x) will either way return an Int, the leftmost by default
23:41:38 <davean> Cale: Because thats a long mess and I'm tired of writing it 5 or 6 times a day and then having to read it?
23:41:53 <Cale> davean: You write that thing 5 or 6 times a day?
23:41:59 <davean> Cale: at least.
23:42:01 <heatsink> > runState get 3
23:42:04 <lambdabot>  (3,3)
23:42:05 <Cale> What?
23:42:23 <davean> Cale: its an extremely useful basic function?
23:42:32 <Cale> davean: How does that arise?
23:43:01 <Cale> I've had that function show up now and then, but maybe like 5 or 6 times a *year*
23:43:07 <Cale> and I'm a full time Haskell programmer
23:43:24 <davean> Cale: well right now I want to split smething into two processings of it.
23:44:10 <Axman6> join (,)
23:44:10 <davean> so I'll end up using &&& in this case
23:44:11 <Cale> Maybe it's just because I don't do points-free code golf, and don't mind naming things and using let
23:44:33 <Cale> I would bind the thing I'm processing twice in a let
23:44:51 <davean> Cale: Yah I find that annoying and ugly personally since then my eyes have to jump around
23:44:57 <davean> I like the code structured how I think
23:46:18 <Cale> Or at the very least, I'd write a more elaborate lambda
23:46:29 <Cale> something along the lines of (\x -> (f x, g x))
23:46:59 <Cale> at which point, if I *was* golfing, I might write f *** g
23:47:07 <Cale> er, f &&& g rahter
23:47:50 <davean> &&& and *** have just never read right to me but I like them more than the lambda
23:47:53 <Cale> But yeah, I wouldn't ever actually do that, because it's harder to manipulate.
23:48:38 <davean> I think what I don't like about them is that I have to come back to what the structure is in the middle
23:48:39 <Cale> Well, unless I needed the generality of Arrow / monoidal category operations
23:48:53 <Cale> which is pretty rare
23:49:02 <gabbiel> cale: funny, i used somthing like that in lisp, i call it gxfx, and i also have xfx and fxx
23:49:03 <davean> I want the structure and then to move on to what I'm doing with it
23:49:06 <Cale> or if I really thought the code I was writing was never going to change
23:49:49 <Cale> A large portion of the code I write is subjected to arbitrary customer whims
23:50:03 <davean> Cale: Sometimes I come back and rewrite it into lets and such but I find it much harder ot get the code writen the first time that way
23:50:10 <davean> I mean often I come back and rewrite it
23:50:13 <Cale> and so any premature attempt to abstract will just make me look dumb :D
23:50:19 <davean> but I really like things like dup for figuring it out in the first place
23:50:32 <Cale> That seems weird to me
23:51:27 <Cale> It implies that you're thinking about the need to use a value more than once, before thinking about what things you want to do with the value
23:51:34 <Cale> Seems backward :)
23:52:02 <davean> I guess its not how you think
23:52:26 <Cale> I usually don't know how many times I'll need a value before I actually work out what they are
23:53:39 <Cale> It might make sense in some sort of substructual logic kind of setting to be so concerned with the explicit duplication
23:54:11 <Cale> But usually it's not even something I think about -- if I have a value once, I have it as many times as I need it
23:55:16 <Cale> But I suppose that happens more automatically, if you're binding the thing to a variable to start with
23:55:45 <davean> I consdier more than half the work those steps of figuring out variables and such
23:55:48 <Cale> and then proceeding to write the terms that use that variable -- you don't have to know ahead of time then how many occurrences you'll have
23:55:51 <davean> that comes after figuring out how to do what I want
23:56:26 <Cale> Whereas if you're trying to write your whole expression points-free, you sort of need to know
23:57:48 <davean> I usually work out the flow and then figure out what I have in the various parts.
23:58:22 <davean> I can easily know how things relate before I fully know what they are
