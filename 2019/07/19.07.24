00:22:04 <phaul> hi, any intero users here? with newer stack snapshots stack exec intero gives me Executable named intero not found on path even though it's succesfully built, I can even find the binary under different sha. Last one working fine was lts-9.21, btw im trying intero-neovim 
00:32:12 <sicklorkin> phaul: does `stack path` give you any insight?
00:33:09 <sicklorkin> phaul: check that bin-path: contains the path to your newly built intero executable
00:33:49 <phaul> it doesn't. how do I control that?
00:35:00 <phaul> intero bin is now under two different shas under .stack/snapshots/x86_64-linux-tinfo6/<SHA....>/8.6.5/bin/intero but bind path is a third sha
00:35:06 <sicklorkin> what happens wen you `stack clean && stack build --fast` inside your inforno checkout
00:35:57 <phaul> I don't check out, but I can try. the vim plugin installs intero in a stack project
00:37:02 <sicklorkin> I see.. are you using Plug?
00:37:08 <phaul> yes
00:37:34 <sicklorkin> did you try PlugClean?
00:37:47 <phaul> I can try..
00:38:12 <phaul> it's response: Already clean. 
00:38:21 <sicklorkin> PlugStatus?
00:39:01 <phaul> Finished 0 errors. - intero-neovim: OK  
00:39:40 <sicklorkin> Odd.. well it appearrs to me that it's not rebuilting.. maybe there's a different inferno dir it's using.. 
00:40:45 <sicklorkin> sorry, it's not linking to the correct binary is what I meant
00:40:57 <phaul> I can repatedly reproduce: project with old lts snapshot it works. with new lts snapshot it gets as far as printing Intero built succesfullly. and I can indeed find the bin under .stack/snapshots... with the new ghhc
00:41:06 <phaul> but that path is not in PATH
00:41:47 <phaul> I can execute that binary sucessfully to with explicit path, but stack exec doesn't work with it
00:41:56 <phaul> too*
00:43:25 <sicklorkin> `which stack && stack --version`
00:44:07 <phaul> >> /usr/bin/stack
00:44:22 <phaul> >> Version 2.1.3, Git revision 636e3a759d51127df2b62f90772def126cdf6d1f (7735 commits) x86_64 hpack-0.31.2
00:45:27 <sicklorkin> do you have a stack in `ls ~/.local/bin/stack`
00:46:06 <phaul> no
00:54:55 <sicklorkin> phaul: you might want to try moving ~/.stack to ~/.stack-old and install inferno again and check that the paths are updated..
00:56:27 <phaul> thanks, but I went more drastic, it does the same after rm -rf ~/.stack ~/.ghc
00:58:10 <sicklorkin> what command do you use to install inferno? `stack install inferno`?
01:01:42 <phaul> for sake of correctness it's intero. You are not supposed to install it yourself. The vim plugin installs it when you open a haskell file, using stack. If I execute stack install intero then it installs but then the plugin dies
01:05:36 <phaul> if this helps: https://gist.github.com/phaul/0e6343690c105f831d522be452767fa5
01:08:29 <phaul> yeah I just tried: stack new blah; cd blah; stack build intero; stack exec intero => wrong path. I changed 1 thing: lts-13.29 -> lts-9.21 in stack.yaml. repeating the same commands, and stack runs
01:11:08 <sicklorkin> https://github.com/Fyrbll/intero-vim/blob/65a1335c89be8bc78a2443ec419067c5723b14ac/autoload/intero/process.vim#L330
01:11:29 <reactormonk> I need to parse a somewhat straightfoward string-based file. Which parser library should I use?
01:11:53 <merijn> megaparsec
01:12:24 <merijn> Assuming it's human-written and you need somewhat reasonable error messages
01:12:28 <phaul> could it be that that the newer snapshot on stackage does not contain the intero package but 9.21 does? But then why does it build succesfully
01:12:54 <phaul> and why do I get so many different sha folders under snapshots
01:14:16 <sicklorkin> phaul: you mean different versions of intero?
01:16:06 <phaul> I mean the difference I can see is that https://www.stackage.org/lts-13.29 doesn't have intero listed, https://www.stackage.org/lts-9.21 does. Can this be the root cause?
01:16:46 <merijn> Random neat thing I learned: packdeps has an RSS feed for when there's newer versions released of your direct dependencies, so you can use these RSS feeds to easily track when you should look into relaxing upper bounds :)
01:17:46 <sicklorkin> i dont' know if that's a problem. you just want to build a binary right? once it's built w/the correct dependencies then it shouldn't matter.. but I've never used intero so i'mn the last person that should be making arm-waving assumptions.
01:18:39 <phaul> sicklorkin: I appriciate your efforts.
01:18:54 <sicklorkin> phaul: what I was gonna suggest is you add intero to stack.yaml extra-deps and try stack build 
01:18:54 <phaul> thanks. 
01:21:33 <phaul> usually stack tells me what I need to add but with intero stack build just tells me nothing. https://gist.github.com/phaul/fe89398b4ba9160f445dc70dac1fad7f
01:23:11 <sicklorkin> phaul: did you add `- git: https://github.com/Fyrbll/intero-vim\n  commit: dfcaca099a1e96146665e09b48eb0184b49` under extra-deps:?
01:23:38 <sicklorkin> wait.. that's not the corect repo haah
01:24:25 <merijn> Does anyone know if there's an easy way to build C++ code from Cabal or do I need to resort to a custom setup for that?
01:24:27 <sicklorkin> https://github.com/chrisdone/intero and 61caa798bd385acf918b3639cf03f336b618e78b
01:31:09 <phaul> running ...
01:32:24 <phaul> yep, stack exec started working this way
01:32:31 <phaul> let me try it in vim
01:32:58 <phaul> this did the trick. thank you
01:33:04 <sicklorkin> phaul: cool
01:33:07 <sicklorkin> have fun
01:33:44 <phaul> I don't think it was supposed to be put in there when intero-neovim was designed, but oh well..
01:34:18 <sicklorkin> phaul: no it wasn't.. but after reading the sources i ealized that this would be a nice way to get around th efact that it's not in the latest snapshot
01:34:44 <sicklorkin> that's it's perfectly reasonable to use extra-deps this way.. 
01:34:54 <jackdk> merijn: I think that's supported. check the cabal user guide, there's a big list of config options: https://www.haskell.org/cabal/users-guide/developing-packages.html#developing-packages
01:44:01 <dminuoso> Do you think it's good style when a library requires you to explicitly depend on ⌜data-default⌝ rather than re-exporting ⌜def⌝? I'm somewhat annoyed by this.
01:46:12 <sicklorkin> dminuoso: Default is easily abused I think.. maybve that's why? 
01:47:16 <merijn> jackdk: Building *C* code is supported, but to the best of my knowledge there's no direct way of compiling C++
01:47:39 <sicklorkin> merijn: what are the cpp-options used for?
01:48:10 <sicklorkin> (or cxx-options.. i can't remember what they are called)
01:48:46 <merijn> sicklorkin: Ah...looks like those got snuck in after last time I needed this
01:48:59 <merijn> sicklorkin: cpp-options is for the C preprocessor
01:49:16 <sicklorkin> cxx- then
01:50:01 <merijn> Oh! Even has asm-options and asm-sources know for if I ever wanna be really hardcore!
01:50:15 <sicklorkin> l337
01:55:05 <Phyx-> d
01:55:39 <merijn> Well, this makes my live dramatically simpler :)
02:42:50 <himekami> im going home
02:42:51 <himekami> bye
03:41:44 <Mo0O> Hi there, how can I know which base versioni is currently used by ghc?
03:42:32 <Mo0O> found: ghc-pkg list
03:42:34 <Mo0O> :)
03:45:11 <Mo0O> I've got a wierd error: conflict: ghc -buildable => base<0
03:45:18 <Mo0O> base<0 ???
03:45:24 <Mo0O> strange not ?
03:46:26 <lyxia> strange yes
03:47:23 <merijn> That looks like a package that was made intentionally unbuildable?
03:47:30 <merijn> Which package is it?
03:47:42 <Mo0O> ghc has been installed using: curl https://get-ghcup.haskell.org -sSf | sh
03:47:56 <Mo0O> merijn: it's my own package/project
03:48:31 <merijn> Mo0O: What's the full error?
03:49:08 <Mo0O> merijn: https://paste.steeve.io/5dik
03:49:53 <sicklorkin> Mo0O: are you running this inside docker or something?
03:50:06 <Mo0O> sicklorkin: yes, inside a docker container
03:50:34 <Mo0O> ubuntu image
03:51:41 <merijn> Mo0O: ccp-tools is your project?
03:51:45 <Mo0O> yes
03:52:22 <sicklorkin> I wonder if you'd be better off building from a stackage docker image 
03:52:34 <merijn> Mo0O: The problem is this: You require containers >=0.6.2 *and* the GHC library, but the ghc lib of your GHC version uses an older version of containers and you can't combine those two
03:52:51 <merijn> Mo0O: So it's trying the (experimental, new) reinstallable ghc-lib and that's failing
03:53:16 <merijn> Mo0O: So, most likely the easiest solution is to lower your version bound on containers so the one the GHC ships with works
03:54:46 <Mo0O> merijn: that make sense, localy I use the same version of cabal/ghc, but containers-0.6.0.1 is installed, I'm going to force that version in the cabal file
03:55:08 <Mo0O> thanks for pointing that merijn, I better understand this error message right now
03:56:15 <merijn> Mo0O: The most important thing of these build plan failures is to look at the conflicts (from the top, because early conflicts are likely to lead to more obscure build-plans and thus even *more* obscure errors)
03:56:57 <Mo0O> got the idea
03:57:21 <Mo0O> this is my first haskell projet… so I'm still learning by failing :D
03:59:17 <merijn> Mo0O: Linking "ghc" (the library) is notorious for complicating your dependencies as GHC uses some core libraries (like containers and bytestring, directory, etc.) and those cannot be upgraded without updating GHC
04:03:52 <Mo0O> I see, so it's mandatory to keep the same GHC version
04:04:02 <Mo0O> thx for all those advices
04:05:19 <merijn> Mo0O: Well, the "ghc:buildable" stuff is trying to use (the experimental) work to make GHC (the library) separately buildable/installable from GHC (the compiler you're using), at least from what I can tell, but being experimental means it doesn't seem to be working for you ;)
04:10:23 <Mo0O> it looks like :D
05:40:08 <merijn> Anyone here happen to know how cabal-install determines which C/C++ compiler to use?
05:44:10 <noipmusp> Is there any simple way to load all package modules into "cabal new-repl"?
05:44:12 <Axman6> tries "cc", if that doesn't work, it tries acc, then bcc, then ccc anf so on, until it finds something
05:45:11 <merijn> noipmusp: what happens if you pass in multiple files when you run it?
05:45:31 <merijn> noipmusp: Of course there's always the ghetto solution of "define a .ghci file that imports them all"
05:45:48 <noipmusp> merijn: It's fine, but it's exhausting.
05:46:06 <noipmusp> merijn: I didn't know about .ghci. Thanks!
05:46:36 <merijn> noipmusp: That's how everyone sets up their cool prompts and stuff!
05:47:03 <merijn> noipmusp: You can even make a global one for often imported modules: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci
05:49:22 <julianleviston> hiya… I’m still having some issues with getting some generic functions up for some STM code… does anyone have any suggestions for how to make my generic typeclass constrained code work equally with TVar STM IO as with a pure instance? https://gist.github.com/JulianLeviston/fe48b26e228880ddd1ef88e6eaa5ef5a#file-overlygeneric-hs-L19
05:50:13 <julianleviston> I understand why I’m getting that error, but I don’t really know how to tell GHC “trust me that the types match” for my use of “atomically”.
05:51:43 <merijn> julianleviston: They happen to accidentally match in all cases in your current code
05:51:47 <noipmusp> merijn: And is there any way to load hidden package? I have one package and executable in same project, but I'm unable to load hidden package using either ":m +Foo.Bar" or "import Foo.Bar" in .ghci.
05:51:56 <julianleviston> I tried using fundeps, and I’ve been switching the function around… what I’m after is the ability to write a pure version of my code in something like State so I can test out some variables around propagation speeds, etc, as well as the one I’ve got already which is using TVar, STM & IO.
05:51:56 <merijn> julianleviston: But typeclass constraints are about *all* possible future instances too
05:52:05 <julianleviston> Yeah…
05:52:27 <merijn> julianleviston: Your atomically requires "HasAtomically", so that function need a HasAtomically constraint
05:52:34 <julianleviston> yup
05:52:40 <merijn> julianleviston: but, tbh, I think the classes you're writing right now are the wrong way to go anyway
05:52:47 <julianleviston> ooh teach me :)
05:52:53 <julianleviston> (please) :)
05:53:07 <reactormonk> I'm looking for a library for undirected, weighted graphs - any recommendations?
05:53:10 <julianleviston> very much interested in hearing a good way to do this.
05:53:22 <merijn> julianleviston: You can replace your VarMonad class just with a VarMonad datatype/record and make the entire thing explicit
05:53:40 <julianleviston> merijn: but then I don’t get the ability to have two variants of it
05:53:45 <reactormonk> preferably with a shortest path algorithm.
05:53:48 <merijn> julianleviston: You do :)
05:53:58 <julianleviston> merijn: how?
05:56:31 <merijn> julianleviston: What you write is: "data Var t m = VarInstance { newVar :: a -> m (t a); modifyVar :: t a -> (a -> a) -> m (); getVar :: t a -> m a }". Then you do "mvar :: Var MVar IO; mvar = VarInstance { newVar = newMVar, modifyVar = {- something using modifyMVar -}, getVar = takeMVar }"
05:56:41 <julianleviston> Oh an explicit dictionary
05:57:14 <merijn> julianleviston: You can also make the actual var implicit
05:57:55 <julianleviston> Ok I’ll give that a go thanks :)
05:58:09 <merijn> "data Var m a = VarInstance { getVar :: m a, modifyVar :: (a -> a) -> m (), getVar :: m a }"
05:59:58 <merijn> julianleviston: Then "mvarImpl :: IO (Var IO a); mvarImpl = newEmptyMVar >>= \var -> return (VarInstance { modifyVar = \f -> modifyMVar var f, getVar = readMVar var })"
06:00:38 <merijn> julianleviston: Then the entire implementation becomes opaque and you can write generic Var code via "myCode :: Monad m => Var m a -> m Foo"
06:00:41 <julianleviston> Yup. Gotcha. That’d be my newMemberList.
06:00:55 <merijn> julianleviston: And if you've got STM, then you can just manually use atomically on myCode
06:01:40 <merijn> julianleviston: I like to think of that pattern as "OO" Haskell, since you treat records as some opaque implementation of an interface and then you can just instantiate that record (interface) with different implementations
06:01:44 <julianleviston> I also want to genericise the async part out somehow too, so I think taht’ll help with that.
06:02:05 <julianleviston> as well as the HTTP effect, too.
06:02:08 <julianleviston> That’s pretty interesting.
06:02:40 <julianleviston> I’ve experimented with doing that before, but never thought of it as an alternative to effects, TBH
06:03:22 <merijn> julianleviston: In practice I find it far easier/more flexible/more robust than inventing endless "single use" typeclasses, because inference always becomes a nightmare or you make wrong assumptions, etc.
06:03:51 <julianleviston> helluva lot simpler which I really like
06:04:39 <julianleviston> Exciting :) now I’ve got some homework to do :) woo glad I asked tonight thanks merijn :)
06:06:02 <reactormonk> Is there a combinations like https://apidock.com/ruby/Array/combination somewhere out there?
06:07:24 <julianleviston> reactormonk: there’s a few things like that in Data.List aren’t there? like permutations I think
06:07:27 <julianleviston> :t permutations
06:07:31 <lambdabot> [a] -> [[a]]
06:08:46 <julianleviston> :t subsequendes
06:08:48 <lambdabot> error:
06:08:49 <lambdabot>     • Variable not in scope: subsequendes
06:08:49 <lambdabot>     • Perhaps you meant ‘subsequences’ (imported from Data.List)
06:08:51 <julianleviston> :t subsequences
06:08:53 <lambdabot> [a] -> [[a]]
06:09:02 <julianleviston> > subsequences [1,2,3]
06:09:08 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
06:09:25 <reactormonk> > filter (\x -> length x == 2) $ subsequences [1, 2, 3]
06:09:31 <lambdabot>  [[1,2],[1,3],[2,3]]
06:09:35 <reactormonk> I mean...
06:09:41 <reactormonk> Works in a pickle
06:10:37 <merijn> filtering on length is expensive, though :)
06:11:17 <merijn> Probably want to replace it with "\x -> case x of [x,y] -> True; _ -> False" which is more efficient :)
06:12:23 <julianleviston> wonder how you’d do the int parameterized version?
06:24:00 <dmwit> > let f xs = [[a,b] | a:as <- tails xs, b:bs <- tails as] in f [1,2,3]
06:24:03 <lambdabot>  [[1,2],[1,3],[2,3]]
06:25:38 <dmwit> > let f 0 xs = [[]]; f n xs = do a:as <- tails xs; rest <- f (n-1) as; return (a:rest) in f 2 [1,2,3]
06:25:41 <lambdabot>  [[1,2],[1,3],[2,3]]
06:25:44 <dmwit> julianleviston: ^
06:25:53 <dmwit> reactormonk: ^ too
06:27:44 <julianleviston> :+1:
06:31:29 <julianleviston> merijn: what do I do when I want `newVar` to be polymorphic in its `a` parameter? do I use rankNtypes?
06:33:42 <julianleviston> ohhh nevermind — you use your impl above… to create a new one.
06:34:00 <reactormonk> dmwit, put it in a library :puppyeyes:
06:35:30 <julianleviston> merijn: but then it’s not generic now :lol: 
06:35:43 <julianleviston> ah I’ll have to think about this some more
06:41:03 <merijn> julianleviston: Generic how?
06:42:42 <julianleviston> merijn: all good — I updated my gist with a comment of what I mean
06:42:43 <julianleviston> https://gist.github.com/JulianLeviston/fe48b26e228880ddd1ef88e6eaa5ef5a#file-overlygeneric-hs-L19
06:43:12 <julianleviston> It works if I do that — pass the method dictionary explicitly.
06:43:51 <julianleviston> doesn’t exactly read beatufiully, but I suppose I could use record “destructuring” on the argument list if I wanted it to look nice :)
06:45:34 <Taneb> When should I expect GHC 8.8.1 to be released for real?
06:45:40 <julianleviston> Yeah, named field puns
06:46:02 <merijn> julianleviston: I don't see it in that link?
06:46:13 <julianleviston> It’s in the comment at the bottom
06:46:56 <julianleviston> using RankNTypes and NamedFieldPuns. I added that one to the bottom, too
06:47:30 <julianleviston> very nice! thankyou :)
06:48:23 <merijn> julianleviston: The parentheses are redundant :)
06:48:53 <julianleviston> around the field? keeps me from going insane :)
06:48:54 <merijn> julianleviston: Function application is left associative, so "(newVar varInst) nodes_empty" is identical to "newVar varInst nodes_empty"
06:49:34 <julianleviston> oh… up there. Right, yeah obviously :) I was using it as a clarifying tool to show that they were “method function fetches” :)
06:50:40 <julianleviston> First time I’ve ever used rank n types :) and the other day was the first time I ever used fundeps. Gosh this language is great.
06:55:08 <dmwit> Taneb: word on the #ghc street is never, it's cursed, and they're jumping straight to 8.10
06:55:58 <Rembane> That seems to happen now and then, what black magic do the ghc-dev-team use?
06:59:15 <julianleviston> RC1 was out a couple days ago I thought
06:59:21 <julianleviston> https://www.haskell.org/ghc/blog/20190722-ghc-8.8.1-rc1-released.html
07:00:38 <julianleviston> I think a couple of months or something? it’s two releases per year roughly, right? was a bit of a roadbump because of switching to gitlab this year
07:08:11 <julianleviston> merijn: the only trouble with this style is… if I have one method dictionary (ie record) for each “effect” I want to encapsulate, then I have to add one argument in to each function for each effect I’m using… which is kind of… not great. Maybe I should look into `extensible`.
07:08:28 <julianleviston> http://hackage.haskell.org/package/extensible
07:09:17 <hvim> :t runSTUArray
07:09:19 <lambdabot> error: Variable not in scope: runSTUArray
07:09:31 <hvim> :t Data.Array.ST.runSTUArray
07:09:34 <lambdabot> (forall s. ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
07:09:38 <merijn> julianleviston: Yeah, this approach doesn't work really for "effects" it works better for, well, "objects" (so variables, sockets, etc. any sort of thing that consists of "an interface" plus "implemenetations"
07:09:59 <julianleviston> right…
07:10:14 <julianleviston> I’ve been researching oleg’s stuff over the last two weeks
07:10:44 <merijn> Oh dear :p
07:10:58 <julianleviston> Reading all of it. It’s really good… and this was my first kind of step into that world… just using classes, but I think perhaps I need to embrace the idea of requests and handlers, maybe?
07:11:09 <julianleviston> why oh dear? ):
07:11:11 <julianleviston> :)
07:11:38 <julianleviston> Honestly I think this is a huge problem in Haskell… composing effects together is kind of… *difficult*.
07:11:49 <merijn> julianleviston: Oleg is known for...rather excessively complex type hackery :)
07:12:05 <julianleviston> hehe :) fair.
07:12:07 <merijn> @quote millioleg
07:12:07 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
07:12:20 <merijn> (The Oleg being the unit of "type hackery")
07:12:34 <julianleviston> lol
07:12:56 <julianleviston> I definitely think we is on to something with the end of his journey there, tho...
07:13:09 <merijn> Don't get me wrong, I *like* type hackery, etc. But I feel many people come to think they *have* to use all sorts of type hackery
07:13:13 <julianleviston> the idea that effects kind of depend on scoping...
07:13:22 <hvim> Hello. I have a problem with runSTUArray function. I get an error message from GHC saying expected type is not matched by the actual type of the value passed to the function. However, the error message says the actual type of the value is the right type acording to :t Data.Array.ST.runSTUArray and list a different type in 'expected:' as is document and returned by :t is this a bug?
07:13:26 <julianleviston> I don’t want to use hackery… but I do want to program to a nice interface.
07:13:29 <merijn> Like, you can be incredibly productive just writing dumb IO based code in Haskell :)
07:13:59 <julianleviston> Yeah, I have been :)
07:14:22 <julianleviston> … and if that’s all I wanted to do at the moment, I’d be happy doing that… but it’s pretty untestable… and it’s also pretty difficult to do what I want to do — which is to have two implementations.
07:15:49 <merijn> julianleviston: So for the Var stuff, what's the problem that stops you from having 2 implementations and what exactly makes it untestable?
07:16:12 <julianleviston> No it’s the other way around — I want to write generic code and then test that :)
07:16:36 <julianleviston> there’s nothing wrong with doing what you were suggestng for *one* thing. the problem happens when I want to layer another effect on, then another, then a fourth.
07:16:51 <merijn> julianleviston: Which affects are you wanting to layer in?
07:17:02 <merijn> And why would they need to affect the Var stuff?
07:18:29 <julianleviston> Ok so there’s the one we were talking about - having variables. Then there’s “doing network things” (ie serving and communicating)… then there’s randomness… and timers
07:18:45 <julianleviston> oh and errors
07:20:05 <julianleviston> they don’t affect it… but if I have to pass an argument around for each effect, and thread them through all the functions, it will get pretty tedious. (ie a way to compose them is what I’m after)
07:23:18 <infinisil> hvim: The chance of this being a bug is pretty much zero. Best to show your code and the error
07:23:30 <infinisil> (a bug in the array package that is)
07:28:57 <julianleviston> merijn: thanks tho. I’ll stack them up for now and see how I go :)
07:29:09 <julianleviston> merijn: thanks very much for your help.
07:31:27 <merijn> np
07:35:03 <Taneb> dmwit: that surprises me, after there's been a release candidate
07:37:09 <dmwit> ...is joke
07:39:15 <adamCS> An FFI/unsafePerformIO question:  I have a numerical optimizer that expects (Vector Double -> Double), and, for FFI reasons, I have (Vector Double -> IO Double).  I can do unsafePerformIO here and I think (yikes!) it's okay but I don't really understand the FFI stuff well enough to be sure.  If I'm willing to call the optimizer from within an IO action, is there a way to do this without unsafePerformIO?  I feel like there
07:39:15 <adamCS>  must be and I'm feeling silly for not being able to figure it out...
07:40:07 <merijn> adamCS: You can just foreign import without IO in the signature IFF you know that's safe
07:40:52 <merijn> adamCS: Only you know what you're calling via the FFI and whether that's safe
07:41:06 <adamCS> merjin: if I knew that was safe then so is unsafePerformIO, right?
07:41:08 <adamCS> yeah
07:41:16 <adamCS> merijn: ^
07:41:30 <merijn> Sure
07:41:38 <kuribas> adamCS: was Data.Vector not performant enough?
07:41:51 <kuribas> adamCS: it also allows mutable operations, and does stream fusion etc...
07:42:13 <adamCS> kuribas: I'm doing a Cholesky decomposition via the CHOLMOD library in C
07:42:24 <kuribas> adamCS: ah :)
07:43:05 <adamCS> It would certainly be cool to have that all in haskell.  But I'm not up to porting that! 
07:45:39 <adamCS> It's not the FFI I find problematic, though I need to understand it better.  I was just hoping I was missing a something like f :: (x -> IO y) -> IO (x -> y), which would let me just keep this all in IO without unsafePerformIO.  I see why that function can't exist (or be useful anyway) for a general monad but I thought maybe for IO?
07:45:54 <merijn> adamCS: That function can't exist
07:46:06 <merijn> adamCS: Because the IO that happens can depend on the value of 'x'
07:46:31 <adamCS> ah.  That's good way to explain it!  Thanks
07:46:33 <merijn> adamCS: It's not that it can't exist for Monad in general, it can't meaningfully exist for IO either
07:48:21 <adamCS> merijn: Does that also give me a good way to think about whether unsafePerformIO is safe?  If the IO which occurs doesn't depend on the value of x?  I'm not sure that's actually true in my case since there are allocations that might depend on x.  But I might be able to fix it so that the allocations all happen in other calls and the thing in the optimizer just re-uses that space.
07:49:28 <merijn> adamCS: Whether unsafePerformIO is safe is a matter of asking yourself: "Am I ok with this code being called 0, 1, or more times?"
07:49:45 <merijn> adamCS: If the answer is that any of those 3 options is not acceptable, then no, it's no safe
07:54:47 <kuribas> adamCS: it's safe if it doesn't do any side effect besides returning a value (and the same one for the same inputs).
07:54:57 <adamCS> merijn: That's helpful.  And I need to think harder about it.  The underlying C allocates a couple of things which different routines can modify as they do their work.  I think the function in question is only modifying that stuff in a way that it is then indifferent to on a subsequent call.  As long as this is all on one thread. 
07:55:26 <adamCS> and I can set up separate structures if I want to use multiple threads.
07:55:39 <merijn> adamCS: And who frees those allocations?
07:57:44 <adamCS> merijn: Thats' a really good question!  I am using hcholmod and then I added my own FFI bits where hcholmod didn't have what I needed.  And I don't yet understand how the allocation and freeing works along with the ForeignPtr stuff.  I'm planning to learn and then re-write as appropriate.  But for now, I am trusting that hcholmod (https://github.com/tdox/hcholmod) does the right thing. 
08:03:39 <c_wraith> adamCS: I'm a bit worried by how much that library uses newForeignPtr_  Not that it's necessarily wrong, but it's unsettling to see things that at least superficially look like allocating foreign resources and not setting up the appropriate frees
08:04:52 <adamCS> c_wraith: Yes!  I sort of get the ForeignPtr is meant to handle finalizing but I couldn't see the finalizers.  So I figured I would circle back around and re-do a bunch of that once I get the functionality I need a little clearer.  Plus it'll be a good excuse to learn more about FFI stuff.
08:05:43 <c_wraith> adamCS: well, the low-level module is nice enough to bind all the necessary finalizers.  But it really looks like a lot of ForeignPtr values are being created without the appropriate finalizers.
08:07:03 <c_wraith> roughly, you can think of ForeignPtr as a combination of a Ptr and a list of actions to run when the ForeignPtr gets collected.
08:07:37 <adamCS> c_wraith:  Yeah.  I was wondering.  But I also figured there could be some magic I didn't understand yet.  And it's a small lib so I will likely redo from scratch and build it into an interface with the sparse-linear-algebra library.
08:08:11 <adamCS> Is ForeignPtr like bracket?  But handled by the runtime?
08:08:57 <merijn> adamCS: It's not like bracket in the sense that it's lifetime isn't decided by control flow, but by the GC
08:09:06 <adamCS> ah
08:09:31 <merijn> adamCS: So when the final copy of a ForeignPtr is GCed the GC sees "there's nothing else, time to run the finalizer!"
08:11:05 <hvim> hello. Why does GHC say runSTUArray expect a different type than what is reutrned using :t ? 
08:11:25 <infinisil> hvim: I already asked you earlier to show the code and error
08:11:28 <hvim> :t Data.Array.ST.runSTUArray
08:11:31 <lambdabot> (forall s. ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
08:11:54 <c_wraith> hvim: are you aware of what that forall is doing there?  It's a very important part of ST
08:11:55 <hvim> sry didn't see. How do I paste here?
08:12:03 <hvim> I don't konw what forall is doing.
08:12:11 <hvim> I see it for the first time.
08:12:28 <infinisil> paste link is in the topic (gist.github.com)
08:13:44 <adamCS> merijn, c_wraith: Thanks for the help!  I think I now see that I can probably do what I want to but I'll have to work a little harder to know that it's safe.  Which should be sort of fun to do!
08:13:47 <sicklorkin> I have `instance Serialize (InHand Day)` but it's unable to create get/put 'cause that's no instance for (Generic Day).. What is the standard appraoch for dealing with this? Role my own instances or is there a simplier apporach?
08:14:06 <hvim> If you know the book real world haskell, it's one of the examples. Bloomfilter.
08:15:33 <merijn> sicklorkin: You could standalone derive Generic...
08:17:00 <sicklorkin> merijn: ahh.. thanks
08:17:44 <infinisil> hvim: You'll have a hard time getting help if you can't paste your code and error
08:17:49 <geekosaur> hvim, this is key to ST. the forall is inside a parenthesis that limits its scope, which means the type described by "s" only is "reachable" within that scope.
08:18:16 <geekosaur> you can't talk about it elsewhere, so you can't elak stuff from one ST expression to another
08:18:38 <geekosaur> "what happens in a runST... stays in the runST..."
08:18:45 <nshepperd1> hvim: https://paste.debian.net/
08:18:51 <sicklorkin> merijn: Are there any undesirable sideaffects with that extension?
08:19:28 <merijn> sicklorkin: It makes it easy to create orphan instances (like here) and orphans are bad? :p
08:19:44 <sicklorkin> what' about compliation behaviour?
08:19:56 <geekosaur> you can extract only results that don't mention the s. this is a way to "hide mutability" by making it depend on that "s", then it can't infect anything else
08:20:26 <sicklorkin> merijn: nm i've found the wiki page about this
08:20:52 <geekosaur> sicklorkin, sometimes you can use standalone deriving (StandaloneDeriving and DeriveGeneric extensions). it depends on whether the instance is derivable, which depends on among other things whether Day has hidden components or not
08:22:35 <geekosaur> orphan instances are the main one, because they lead to spooky action at a distance
08:26:36 <hvim> Is there a command to paste the clipboard to irssi? shift+insert or middle mouse aren't working.
08:28:45 <nshepperd1> Depends on your terminal. Gnome-terminal does ctrl-shift-v iirc
08:30:03 <butterthebuddha> I know a bit of haskell (comfortable with monads, etc.), and would like to read/write some real-world code. Are there any recommended open-source projects I could contribute meaningfully to?
08:31:15 <merijn> butterthebuddha: pandoc?
08:32:21 <merijn> Can someone see if "cabal v2-update" works for them? I get "truncated tar archive"
08:33:01 <maerwald> merijn: ok here
08:33:07 <hvim> paste.debian.net/hidden/74f2d2f3 paste.debian.net/hidden/25f52485 paste.debian.net/hidden/ed374fb2
08:33:35 <hvim> First file imports second and third.
08:33:53 <merijn> maerwald: Which cabal-install version?
08:34:15 <maerwald> 2.4.1.0
08:34:24 <merijn> It works on my macbook where I have 3.0, but on the linux server where I have 2.4.1.0 it repeatedly fails
08:35:46 <maerwald> is it running in docker? :P
08:35:50 <merijn> No
08:36:06 <merijn> I'm just gonna nuke the local index and see if that fixes things
08:36:08 <adamCS> merijn: I think that sometimes happens because an update gets interrupted and then something is corrupted.  I think to fix it once I had to delete the entire package db?  But I can't remember exactly.  It was deeply annoying at the time.  I remember that.
08:36:59 <merijn> ok, that seems to have fixed it
08:37:21 <merijn> adamCS: Next time only nuke ".cabal/packages/hackage.haskell.org/01-index.*" ;)
08:37:36 <adamCS> merijn: Thanks!
08:39:02 <hvim> nshepperd1 infinisil: Links to code are a little higher.
08:40:35 <infinisil> hvim: And what about the error?
08:42:29 <hvim> infinisil: paste.debian.net/hidden/2447873f
08:43:18 <infinisil> (Not sure how you're pasting those links without a https:// prefix, I can't click on them like this and have to copy paste them manually)
08:44:44 <hvim> infinisil: Should I repaste them? 
08:45:15 <infinisil> Nah, but for the future
08:48:47 * infinisil looks at the code and error
08:50:33 <infinisil> That is indeed a bit odd
08:51:49 <infinisil> hvim: Try making a function that returns the result of `runSTUArray` directly, like `f :: (a -> [Word32]) -> Word32 -> [a] -> UArray Word32 Bool`
08:52:54 <infinisil> Although, that `.` is weird
08:53:30 <infinisil> hvim: Hold on, try `B hash $ runSTUArray $ do ...`
08:53:36 <infinisil> Instead of `B hash . runSTUArray $ do ...`
08:55:05 <geekosaur> ghc impredicativity hack strikes again
08:55:36 <geekosaur> basically ($) works, (.) won't
08:57:21 <infinisil> geekosaur: I don't see how (.) could have ever worked. B just needs a second argument, which is what you can do with ($)
08:57:44 <hvim> infinisil: That works! thx.
08:58:42 <geekosaur> hm, maybe I misread
08:59:17 * geekosaur has been in less than ideal conditions for the past several months, irc is iffy at best, many things are rther up in the ir
08:59:19 <geekosaur> air
09:03:12 <infinisil> hvim: So yeah, this looks like an error in Real world haskell
09:04:13 <infinisil> You could submit this error here: https://www.oreilly.com/cs/catalog/create/errata/?b=3206
09:04:38 <infinisil> But then again, that's for the printed version, which might not have the error
09:04:57 <infinisil> hvim: Or do you have the printed version?_
09:06:27 <EvanR> geekosaur, dang sorry to hear that
09:26:41 <hvim> infinisil: I was reading it online until the page started redirecting somewhere else. After that I found a github project trying to update the book to current haskell, since some chapters need update.
09:27:26 <dminuoso> dmwit: Turns out I ended up using Tagged with DataKinds for type level string literals by the way. So thanks for the suggestion.
09:27:47 <dmwit> ^_^
10:28:23 <`Guest00000> main = putStrLn $ let (q, c, c1, c2, c3) = (['"'], ", ", "main = putStrLn $ let (q, c, c1, c2, c3) = (['", "'], ", ") in concat [c1, q, c2, q, c, q, c, q, c1, q, c, q, c2, q, c, q, c3, q, c3]") in concat [c1, q, c2, q, c, q, c, q, c1, q, c, q, c2, q, c, q, c3, q, c3]
10:58:29 <wroathe> Im about to starting writing some stuff using beam. Before I go down that road can anyone here vouch for it mostly working?
10:58:34 <wroathe> to start writing*
10:59:06 <merijn> wroathe: I know some people love beam
10:59:15 <boj> wroathe: we use it in production with zero trouble
10:59:25 <merijn> Personally the types scare the bejesus out of me and I'll probably never consider it for that reason
10:59:26 <boj> very easy to write and understand
10:59:40 <wroathe> boj: How about the migrations? Working?
11:00:04 <boj> wroathe: we never bothered with that since we use a different tool, so no input i can provide there
11:00:12 <wroathe> What do you use?
11:00:17 <boj> the db-migrations library
11:00:30 <merijn> "join_ :: (Database be db, Table table, BeamSqlBackend be) => DatabaseEntity be db (TableEntity table) -> (table (QExpr be s) -> QExpr be s Bool) -> Q be db s (table (QExpr be s))" <- sorry, *what?!*
11:00:46 <wroathe> http://hackage.haskell.org/package/dbmigrations this?
11:01:00 <boj> yep
11:01:20 <boj> there is a postgresql wrapper for it
11:01:39 <EvanR> merijn: well. i can tell right now what that does except for what a TableEntity is
11:01:46 <boj> not gonna say one way is better, we just tend to prefer absolute control
11:02:04 <wroathe> as opposed to the solver based approach beam uses?
11:02:08 <boj> yeah
11:02:13 <wroathe> That makes me nervous too
11:02:15 <merijn> EvanR: So can I just from the name of the function, but that doesn't make error messages from types like that any better >.>
11:02:25 <EvanR> well theres that
11:03:01 <EvanR> i can feel smug about haskell advanced error messages by comparing and contrasting to several other compiled languages though
11:03:20 <EvanR> or at least not feel inferior
11:03:25 <boj> the query builder types are a bit daunting, but we've found that you just use one as a template and copy/paste it for everything else :p
11:03:26 <wroathe> we write Haskell just to feel smug
11:03:28 <wroathe> That's the entire point
11:03:33 <infinisil> Lol
11:03:51 <merijn> I write Haskell because I want to write C with a better build tool ;)
11:04:44 <boj> one of my guys back-ported 800 tests to an older project we had. he only found 3 minor bugs. our takeaway was that the type system saved us from a large class of bugs
11:07:40 <pyan> If types can catch most of your bugs, then maybe you are only using extremely simple algorithms? I can't imagine how types would help you, say, if you were implementing a number theory library, where everything is various flavors of Integer^m -> Integer^n.
11:08:23 <pyan> (And hence most of what is interesting cannot be captured by types.)
11:08:42 <boj> pyan: to be fair we are doing very boring data manipulation, but have still observed a large class of errors avoided that come up in large modular web api projects
11:09:52 <wroathe> Also this: https://tathougies.github.io/beam/schema-guide/library/
11:10:33 <wroathe> beam-migrate hasn't been touched in 4 months
11:11:10 <boj> that could just mean it is stable
11:12:50 <geekosaur> pyan, you might note that a number of things in number theory are captured by typeclasses?
11:13:07 <geekosaur> that said, probably you do need dependent types to do the really interesting stuff
11:13:29 <geekosaur> (or singletons and urgh)
11:19:59 <phadej> or rather, you should not try too hard to formalise math in Haskell
11:20:08 <phadej> Haskell isn't optimised (as a language) for that
11:21:31 <infinisil> boj: The thing is, errors that you avoided aren't really noticed
11:22:20 <phadej> on the other hand, in number theory library (or linear algebra or ...)
11:22:40 <infinisil> boj: Oh, I read that wrong, ignore me
11:23:05 <phadej> there isn't thingle type "Integer" (or Matrix), but there are various subsets of integers and matrices; and it's engineering part, to come up with safe, performant and convinient APIs
11:23:42 <phadej> and IMHO, you can even in Haskell98
11:23:47 <wroathe> boj: https://www.reddit.com/r/haskell/comments/94q97e/pragmatic_haskell_iii_beam_postgres_db/e3ntddd/
11:26:24 <EvanR> i got good enough to make sure no bugs in local code. Then you have non local code, then you have "someone comes in an must work on bug free code later"
11:26:57 <EvanR> i'm not sure what bad ass could do the last thing without a type system
11:27:03 <EvanR> or test harness
11:27:52 <EvanR> at least if you come in and work on buggy code, it won't obviously be your fault
11:28:59 <EvanR> how persistent buggy code can keep the workplace civil : )
11:31:14 <boj> wroathe: well there you go, even the author is opposed to it :)
11:53:21 <Lycurgus> phadej, what IS haskell optimized for?
11:53:32 <Lycurgus> (if anything)
11:54:30 <Noughtmare[m]> Lycurgus: Writing other languages
11:54:45 <Lycurgus> no need to reply if for "optimize" you meant "has accomodations for"
11:54:56 <phadej> The committee’s primary goal was to design a language that satisfied these constraints:
11:54:59 <phadej> 1. It should be suitable for teaching, research, and applications, including building large systems.
11:55:02 <phadej> 2. It should be completely described via the publication of a formal syntax and semantics.
11:55:05 <phadej> 3. It should be freely available. Anyone should be permitted to implement the language and distribute it to whomever they please.
11:55:09 <phadej> 4. It should be based on ideas that enjoy a wide consensus.
11:55:11 <phadej> 5. It should reduce unnecessary diversity in functional programming languages.
11:55:29 <Lycurgus> when was that?
11:55:40 <merijn> Lycurgus: 1989-1990
11:55:44 <phadej> also in 2010
11:56:06 <EmilKarlson> new language to reduce diversity ^^
11:56:12 <Noughtmare[m]> A pretty good history can be found  here: https://www.youtube.com/watch?v=re96UgMk6GQ
11:57:41 <Lycurgus> Noughtmare[m], "writing other languages" would be more apropos lisp (in principle) or C/C++ (in fact)
11:57:43 <phadej> you can have different opinions on how well Haskell performs in these 5 goals, but they didn't include "formalising math" :)
11:58:03 <phadej> yet on the other hand, proof assistants __are__ made for that
11:58:46 <Lycurgus> interesting since there's a common belief that hs's model of computation is pure mathematics
11:59:21 <phadej> so what, RDBS are based on pure math relational algebra
11:59:35 <Lycurgus> in the way smalltalk's is communicating objects, lisp lambda calc, etc
11:59:35 <phadej> but their goal isn't "be the math"
12:00:01 <Lycurgus> rdbs are indeed based on relational algebra
12:00:41 <merijn> Lycurgus: The model of computation in Haskell is lambda calculus which is pure math, sure. But that doesn't mean that "describing all math" was a goal
12:00:59 <merijn> Car engines are based on engineering, but cars don't exist to implement all engineering
12:01:14 <Lycurgus> iow, some brand of relational algebra is what's commonly observed to be given as the mathematical model of rdbms
12:01:49 <Lycurgus> i didn say the model of computation of hs was lambda calc, i said lisp
12:02:50 <Noughtmare[m]> Lycurgus: I meant "writing other languages" as "writing compilers for other languages". According to https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#compilers haskell is "best in class".
12:03:12 <Lycurgus> if it's not ct or math in general, i dunno
12:03:33 <Noughtmare[m]> Of course that overview has mostly been written by Haskellers, so take it with a grain of salt.
12:03:42 <Lycurgus> best in class by somebody's expert opinion
12:03:46 <merijn> Lycurgus: Haskell is definitely not remotely based or even inspired by CT, I don't really know how popular opinion became that it was :)
12:03:59 <Lycurgus> the truth is in what's observed
12:04:10 <merijn> Noughtmare[m]: There's a reason I can think of, like, 6 languages written in Haskell (not counting Haskell implementations...) ;)
12:04:42 <Lycurgus> like perl6?
12:05:38 <Noughtmare[m]> merijn: That page lists 13
12:05:48 <Noughtmare[m]> Of which one is no longer being developed.
12:06:16 <merijn> It doesn't even list UHC :O
12:06:38 <merijn> There's also edwardk's language, forget what it was called
12:07:01 <geekosaur> ermine?
12:07:27 <merijn> Ah, yes
12:07:31 <merijn> It doesn't list Clash either
12:08:28 <Noughtmare[m]> Isn't Kmetts language called coda?
12:08:43 <merijn> I would not be remotely surprised if he had multiple
12:08:46 <Noughtmare[m]> https://github.com/ekmett/coda
12:08:47 <merijn> @quote merijn oleg
12:08:48 <lambdabot> merijn says: If Oleg is the unit of type hackery I propose Edward as the unit of haskell productivity.
12:09:25 <geekosaur> at oen point he had a haskelly thingy and a scalay thingy
12:12:30 <Logio> Edward as a unit of productivity seems like Tesla as a unit for magnetic fields, one must go to quite some length to reach even a single unit's worth
12:13:20 <Logio> most people will probably encounter only milliEdwards at most
12:13:34 <BLBUWA> A magnet can easily be made to have a force of one (1) Tesla with enough magnet wire.  :^)
12:16:30 <merijn> Logio: The same can be said about Oleg as unit of type hackery :p
12:18:51 <ski> @quote 2.years.of
12:18:51 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
13:33:25 <merijn> So...is there a standard for writing out paper references in markdown/rST? I wanna include some references in my README, but I'm used to just blindly using whatever bibtex produces :p
13:55:37 <sicklorkin> merijn: [latencies we see now were well known since 2003][1];.. .. .. somehwere near the bottom [1]: https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html
13:57:20 <merijn> sicklorkin: I meant for citing papers, urls are easy/clear
13:57:59 <sicklorkin> oh i think you use a ^ then
13:58:14 <sicklorkin> it has been some time since I read the spec
13:58:27 <merijn> sicklorkin: No, I mean, what do I include? Just authors and title? Venue? What order, etc.
14:02:05 <sicklorkin> merijn: does this help? https://scholar.google.com/scholar/inclusion.html
14:03:35 <sicklorkin> fwiw <cite> not `[n]`
14:29:38 <MrFantastik> hey there fellas, I'm looking to model this list in haskell [1/2,1/4,1/8...] kind of like zeno's paradox, is there a way to do that?
14:31:23 <dminuoso> MrFantastik: Do you mean the Dichotomy paradox?
14:31:51 <MrFantastik> I'm more trying to see if i can represent a infinite series converging to one in haskell
14:32:00 <MrFantastik> idk the dichotomy paradox
14:32:30 <dminuoso> MrFantastik: Yeah there's a multitude of simple ways of encoding such a list.
14:32:51 <MrFantastik> do you have an example or a place that i can find one? 
14:33:36 <MrFantastik> i tried googling and wasn't sure how to word it, i tried zenos paradox represented in haskell and couldn't find anything
14:33:50 <MrFantastik> I just know that you can do infinite series in haskell lol
14:34:11 <dminuoso> MrFantastik: You could just take [1..] and fmap over that.
14:34:37 <dminuoso> Or you could construct it recursively
14:39:48 <dminuoso> % series :: [Rational]; series = go 1 where go n = let q = n / 2 in q : go q
14:39:58 <yahb> dminuoso: 
14:40:02 <dminuoso> % take 10 series
14:40:02 <yahb> dminuoso: [1 % 2,1 % 4,1 % 8,1 % 16,1 % 32,1 % 64,1 % 128,1 % 256,1 % 512,1 % 1024]
14:40:16 <MrFantastik> thanks!!
14:40:23 <MrFantastik> i was struglling to figure that out
14:41:12 <sicklorkin> or iterate?
14:41:40 <dminuoso> Oh, indeed.
14:42:10 <dminuoso> % series :: [Rational]; series = iterate (/2) 1
14:42:11 <yahb> dminuoso: 
14:42:15 <dminuoso> % take 10 series
14:42:15 <yahb> dminuoso: [1 % 1,1 % 2,1 % 4,1 % 8,1 % 16,1 % 32,1 % 64,1 % 128,1 % 256,1 % 512]
14:42:29 <dminuoso> Good one, sicklorkin :)
14:56:28 <gscorp> Hello, I recently upgraded to ghc 8.6.3 (Haskell Platform).  I have a package I wrote that I need to upgrade.   When I run "runhaskell Setup configure", I get an error saying that Distribution.Simple is not exposed.  The command recommended would be called from ghci but that has no effect once you leave.  I'm wondering what I should do know.  Thank
14:56:29 <gscorp> s
14:59:43 <wildtrees> gscorp, cabal and maybe cabal install? cabal install pkgname? 
15:00:56 <dmwit> gscorp: If you want to continue using Setup.hs (why?), then please show us the output of `ghc-pkg list Cabal`.
15:01:58 <dmwit> If you do not need to continue using Setup.hs, I recommend running `cabal v2-build` instead of `runhaskell Setup configure`.
15:02:58 <dmwit> (Not sure if the Platform you installed has a new enough cabal-install, but probably it does...? If not, then `cabal v2-build` will tell you it doesn't know the command v2-build and we can go from there.)
15:11:41 <gscorp> Thanks, will try
15:14:20 <manuganji> hey, I'm yet to learn Haskell completely but I wonder if I should make the investment. Are there decent consulting opportunities?
15:14:47 <dminuoso> manuganji: Probably not.
15:15:16 <dminuoso> manuganji: The biggest value of learning Haskell is perhaps personal advancement. Gaining new perspectives can drastically change the way you think about code and writing programs.
15:15:23 <Rembane> manuganji: don't learn Haskell for the money. 
15:15:39 <dminuoso> Haskell has affected how I write non-Haskell code, so even if I didn't write Haskell in my day job - I'd still consider having learned Haskell worth it
15:15:57 <manuganji> cool, I really like what I have learned so far
15:16:08 <dminuoso> manuganji: If you enjoy it, then carry on.
15:16:16 <manuganji> some of these ideas I have never thought of
15:17:42 <manuganji> I know this is not a great question. But do you think Go is a good investment to make?
15:17:52 <manuganji> I know this is not a great question. But do you think learning Go is a good investment to make?
15:18:50 <manuganji> what is your favourite non-haskell language where you use your insights?
15:19:02 <gscorp> dmwit, I ran cabal v2-build and cabal v2-install successfully.  I opened ghci and tried to import my module but it couldn't find it. 
15:19:07 <manuganji> and it pays
15:20:08 <dminuoso> manuganji: I think any language that changes the way you think about programming is worth learning. Also if you enjoy or require it, then it's worthwhile learning.
15:20:10 <EvanR> go is not especially different from anything that came before it
15:20:39 <EvanR> so shouldn't take too much to absorb the basics and move on
15:20:41 <dminuoso> manuganji: Go just doesn't bring much new to the table. It is, basically, an improved version of C that addresses some of its shortcomings.
15:21:05 <manuganji> (y) :] 
15:21:36 <glguy> That's not really fair to C
15:21:42 <pyan> EvanR: Hey, distinct types of nil is an interesting idea!
15:21:45 <dmwit> gscorp: Correct; with v2-* stuff you must do everything through cabal. To open ghci, use `cabal v2-repl`.
15:21:53 <dminuoso> manuganji: But if you wanted to broaden your horizon, then Prolog might be an interesting candidate to pick up either alongside or after Haskell.
15:22:04 <dmwit> gscorp: (You may also `cabal v2-exec ghci`.)
15:24:33 <dmwit> gscorp: ...and to use v2-repl in that way you must be in the context of a project that uses your package (e.g. in the directory where the package lives).
15:25:21 <dmwit> gscorp: I haven't used v2-install much; I think there should be a suitable workflow that uses it to make your package available in other contexts, but I don't know much about it.
15:26:12 <solonarv> oh, I can help with this!
15:26:34 <dmwit> Yooooo: for the first time, I just read the definition of Cont's bind and *believed* it, rather than just mentally typechecking it!
15:26:35 <gscorp> Thanks, I was able to run v2-repl from the base directory.  I'm wondering how I can have it be a first class module.  It's a minor change so it's not a biggie. I'm not sure if promoting to hackage has changed in the meantime, though.
15:26:42 <gscorp> (dmwit)
15:27:00 <gscorp> dmwit: Thanks
15:27:15 <dmwit> gscorp: Stick around, it sounds like solonarv is planning to say a bit that might help you.
15:27:25 <solonarv> gscorp: you can say 'cabal v2-install --lib --package-env MYENV.env foo bar' to build packages foo and bar and record them in the file MYENV.env
15:27:56 <dmwit> ("foo" and "bar" can be directories that contain a cabal file -- including . for the current directory)
15:28:07 <solonarv> then you can do 'ghci -package-env MYENV.env' to tell GHC to use it
15:29:34 <solonarv> you can also leave out the package-env arguments and the environment will instead be recorded somewhere in ~/.ghc
15:30:31 <solonarv> note: cabal v2-install and cabal v2-install --lib do very differnt things!
15:31:15 <solonarv> the first form builds executables and symlinks them into ~/.cabal/bin
15:31:29 <solonarv> the second form builds a library and records it in some package environment
15:32:30 <Zer000> I'm copy pasting my question: for fun I decided to see if my project compiles with the llvm backend. It's saying it can't execute opt and to make sure I have LLVM 6.0 installed. opt --version gives "LLVM version 6.0.1" though, as someone who doens't use llvm normally I'm not sure what to do about this
15:32:42 <ski> dmwit : you believe in `Cont', now ?
15:33:12 <dmwit> Not sure yet. But I believe in Cont's bind!
15:33:20 * solonarv is a member of the Holy Church of Codensity, which brands ContT as heresy
15:33:38 <glguy> Why are those incompatible?
15:37:50 <dmwit> glossy eyes for `reset = return . flip runCont id` and `shift = Cont . (flip runCont id .)` still, though =(
15:37:51 <glguy> Zer000: Figure out what your local ~/.ghcup/ghc/8.6.5/lib/ghc-8.6.5/settings is for the GHC you're using and make sure it has the correct path to opt and llc and clang
15:37:57 <dmwit> Perhaps tomorrow night.
16:08:55 <turab> Hello. I have been playing around with Cabal, hackage etc to get comfortable with these tools, however, I feel like I am doing something wrong (silently).
16:09:22 <turab> One issue is that ~/.cabal/store has multiple copies of same version of certain packages, but with different hashes
16:09:23 <davean> turab: ok, why do you feel that?
16:09:25 <turab> https://gist.github.com/trajafri/179a4b9ef675c89eed9b327bbbf2b1fc
16:09:30 <davean> turab: yes, it should
16:09:38 <davean> Those represent different build configurations
16:09:54 <turab> davean: I feel like I am misunderstanding what is described in the documentation
16:09:58 <turab> Ahh
16:10:13 <davean> From different options to different dependency versions
16:10:38 <turab> What exactly counts as an 'option'
16:11:04 <davean> theres build flags, for example
16:11:39 <davean> As an example, some packages have support for native instruction implimentations like AES-NI, which CPUs may or may not support. They're enable via cabal flags.
16:11:41 <davean> Thats one example
16:12:06 <turab> I see
16:12:40 <davean> also different GHC versions can be used to compile packages
16:13:11 <turab> The presence of multiple AC-Angle package listing kinda spooked me since it's not a super popular package, and I used it in one of my package
16:13:12 <davean> turab: configuration options are a standard comcept across build systems
16:13:42 <davean> turab: Sure, but did you compile your package with different version constraints or across multiple GHC compilers at any point in the history of this store?
16:14:15 <turab> I might have compiled with different constraints
16:14:39 <turab> But, I think I just misunderstood what was going so thanks for clearing that :)
16:14:55 <davean> It would only get a new AC-Angle package if you changed a constraint that AC-Angle also depended on and it resolved to a different version, or caused that throh a constraint that transatively caused that
16:15:47 <Zer000> Thanks glguy, I don' thave a .ghcup but I will go find how my distro installs ghc.
16:16:16 <davean> turab: so out of curisority, what did you think?
16:17:13 <turab> I think I missed the part where flags etc are also considered when the hash is computed
16:17:31 <davean> well if they weren't you'd get bad builds!
16:17:59 <davean> any piece of the build enviroment you leave out of the hash *will* lead to build errors
16:18:27 <sofiama> If we rewrite Applicative as { pure :: () -> f (); (<*>) :: (f a, f b) -> f (a, b) }, and then *remove* the Functor superclass, there's still some useful instances if we have GADTs.
16:18:54 <sofiama>  For example: data Tree a where { node :: Node -> Tree Node; nil :: Tree (); cons :: Tree a -> Tree b -> Tree (a, b) } gives us a Tree indexed by its shape...
16:19:22 <sofiama> We can use a right? kan extension to recover functoriality
16:20:07 <turab> davean: Still getting used to build systems so hopefully I will have the concept internalized soon :)
16:20:13 <sofiama> We might also introduce ap :: Tree (a -> b) -> Tree a -> Tree b to give a form of "typed (syntax) trees"
16:21:01 <sofiama> Has this sort of thing been tried before? And sorry if I interrupted a convo :P
16:21:04 <gscorp> Thanks, solonarv 
16:28:30 <turab> davean: Also, this comment prompted me to check my store:
16:28:34 <turab> https://github.com/haskell/cabal/pull/5395#issuecomment-400270169
16:29:11 <turab> If I understand correctly, that's because of new haddock flags being added?
16:29:19 <davean> turab: also --enable-profiling and --enable-coverage
16:29:23 <davean> those lead to different builds
16:29:27 <davean> turab: yes
16:29:31 <davean> the build is litterly different
16:29:54 <davean> They are *not* compatible
16:30:50 <turab> Oh whoops, didn't notice those flags
16:31:47 <turab> I do understand that the bulid is different, but why exactly just changing a single flag guarantee it's incompatible? 
16:32:56 <turab> Might be dumb question but just curious
16:33:18 <davean> coverage and profiling change the RTS interactions and related.
16:33:49 <davean> at best you'd get a link failure
16:34:21 <griddle> Im trying to call a haskell function from a cmake c++ project, is this doable and if so are there docs for setting up cmake?
16:35:46 <turab> Understood
16:36:41 <ysangkok> griddle: did you see https://github.com/nh2/call-haskell-from-anything
16:39:07 <griddle> I mean the big thing Im looking to do is write an llvm compiler in haskell, then pass the module pointer off to c++ for jit and runtime stuff. llvm-hs allows exporting the `llvm::Module*`, but im not totally sure how to setup the stack build step to build the library and link it into the c project
16:39:15 <nh2> griddle: yes, totally doable. You can build your haskell code into a .so/.dll/.dylib shared object, link against it (or load it dynamically at run-time using `dlopen()`), call hs_init() and call functions from it
16:40:01 <griddle> can I tell stack to build into a certain directory?
16:40:14 <nh2> griddle: yes
16:43:25 <nh2> griddle: `stack install --local-bin-path` (from `stack --help`)
16:44:03 <griddle> ah, I see, smart
16:44:04 <nh2> griddle: this new `foreign-libraries` may also be useful to you: https://www.haskell.org/cabal/users-guide/developing-packages.html#foreign-libraries I haven't used them yet
16:45:28 <griddle> oh nice
16:45:33 <griddle> that might be exactly what Im looking for
16:46:49 <nh2> griddle: nice! I go to bed now, write me anything if you need to know something
16:51:15 <ski> sofiama : by right Kan extension, do you have `Yoneda' in mind ? or a more general `Ran' ?
16:52:39 <solonarv> (co)yoneda is the left/right kan extension along Identity
16:53:27 <solonarv> if you pick something other than Identity you get a different result; for example if you pick the same functor again you get co/density, which is a monad/comonad - much more powerful than a mere functor!
16:55:07 <edwardk> fun choices include [LR]an f Id and [LR]an Proxy f
16:55:46 <edwardk> giving adjoints and (co)limits respectively
16:58:21 <Mirela99> If you are h0rny right now, check what I have prepared for you! --> https://nullurl.xyz/WsHdL9KG ♥
16:58:37 --- mode: ChanServ set +q Mirela99!*@*
16:58:51 --- mode: ChanServ set -q Mirela99!*@*
17:03:05 <turab> I am confusion. I tried building documentation for a package, and documentation for all dependencies were linked properly except for the ones coming from GHC (Float, Bool, Eq, IO etc).
17:03:51 <turab> From my search online, some suggestions for users on Ubuntu is to install haskell-platform-doc, but I don't think this applies to me
17:05:24 <turab> Do I need to do something else to link these dependencies properly?
17:47:14 <sicklorkin> turab: I jsut built docuemntation on a ubuntuo machine and it has no issues
19:07:20 <zzz> is there a program that can automatically trace reduction of expressions?
19:10:43 <Axman6> I believe the ghci debugger can do something like that
19:12:33 <zzz> cant find it
19:14:13 <Axman6> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger
19:16:58 <Axman6> :print is particularly useful for seeing how things get evaluated
19:23:26 <ski> @where stepeval
19:23:26 <lambdabot> <http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi>,<https://github.com/bmillwood/stepeval>
19:29:02 <zzz> hey thanks
21:55:24 <Hazalo1122> Hi
23:17:12 <wz1000> Is it possible to write `absurd :: (True :~: False) -> Void`?
23:18:28 <Lycurgus> did not just?
23:18:36 <Lycurgus> *you
23:19:38 <chloekek> type role B phantom; data A = A {-# UNPACK #-} (forall a. B a); -- why can't I unpack this field?
23:20:15 <chloekek> Nevermind, I can.
23:24:53 <sicklorkin> Does anyone know of a commandline program that will let me use hasekll expressions? e.g. cat nums | hask 'mapMaybe (+1) . maybeRead'
23:25:32 <pyan> ghc -e ?
23:26:05 <sicklorkin> oh.. deos that take care of the standard imports?
23:26:51 * pyan just ran “ghc -e 'foldl1 (+) [1,2,3,4,5]'”, and it worked.
23:26:53 <sicklorkin> humm. that didn't work very well
23:27:05 <sicklorkin> pyan: but I wawnt to take stdin
23:27:10 <pyan> Oh.
23:27:15 <sicklorkin> like unix pipes
23:27:40 <sicklorkin> someone must have written this
23:28:55 <pyan> ghc -e 'getLine >>= putStrLn' seems to work as expected.
23:29:17 <jackdk> `echo -e 'main = putStrLn "sup"' | runghc`
23:29:21 <sicklorkin> pyan: yeah, just looking for sometihg polished
23:30:04 <pyan> sicklorkin: What does your “nums” file look like?
23:30:30 <sicklorkin> jot 10 1
23:30:41 <pyan> If it contains a separate number in each line, of course you have to feed ghc a program that reads line by line.
23:31:31 <sicklorkin> pyan: if it were a csv or whatever, would be nice to have 'all-of-the-thing' imported.. 
23:32:29 <sicklorkin> pyan: I typically use awk for more complex thigns like take some averages or what not.
23:32:44 <sicklorkin> pyan: was just thinking, "how nice would it be if i could use haskell'
23:32:57 <pyan> Ah, I see.
23:33:41 <pyan> In any case, runghc, rather than ghc -e, seems to take an actual program as argument, rather than just a single expression.
23:35:34 <sicklorkin> pyan: cheers.. it might me an all-nighter  ;)
23:35:41 <sicklorkin> s/me/be
23:36:18 <pyan> :-)
23:37:24 <suzu> sicklorkin: you could try `interact`
23:38:08 <suzu> @type interact
23:38:10 <lambdabot> (String -> String) -> IO ()
23:38:35 <suzu> it takes a function that takes stdin as a string and returns stdout as a string
23:40:42 <sicklorkin> huh.. never even noticed that function before
23:50:33 <dani_> Hi
23:50:46 <Axman6> Hello!
23:50:58 <sicklorkin> Yo firefighter
23:53:42 <dani_> I would like to understand how (fmap . fmap) has a type of "(Functor f1, Functor f2) => a -> b -> f2 (f1 a) -> f2 (f1 a)". Where "(.)" is defined as "(.) f g = \x -> f (g x)". I mean I understand how function composition works for one variable functions or at least when the outer(f) only takes one variable but this is not the case with fmap. Could someone explain this?
23:54:15 <dminuoso> dani_: Imagine how (fmap . fmap) is used.
23:54:30 <dminuoso> dani_: ⌜(fmap . fmap) f⌝ - then replace (.) with its definition.
23:55:03 <Axman6> (fmap . fmap) === \x -> fmap (fmap a)
23:55:08 <Axman6> uh, x
23:55:17 <dminuoso> Axman6: Yeah I kind of wanted them to do that.. :)
23:55:39 <dminuoso> dani_: One useful intuition is that `fmap` does not take two arguments, but one argument - a function - and it returns a new lifted/changed function.
23:56:06 <dminuoso> So `fmap f` gives you a new lifted function back. Since that's a function itself, you can lift that again into a doubly lifted function.
23:56:18 <dani_> So what you're saying is that
23:56:30 <Axman6> it's worth noting that the type isn't "(Functor f1, Functor f2) => a -> b -> f2 (f1 a) -> f2 (f1 a), it's "(Functor f1, Functor f2) => (a -> b) -> f2 (f1 a) -> f2 (f1 a)
23:57:49 <dminuoso> % :t fmap
23:57:49 <dani_> fmap f some_functor is really fmap = \f -> \some_functor -> f some_functors_extracted_version?
23:57:49 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
23:58:25 <dminuoso> If you add extra parens, this becomes ⌜fmap :: Functor f => (a -> b) -> (f a -> f b)⌝
23:58:27 <dminuoso> As you can see "takes a function and returns a function"
23:58:49 <dminuoso> dani_: That second argument is not called a functor.
23:59:27 <dminuoso> dani_: For example the Maybe type constructor itself is what we call a functor. In your case it's values of that functor applied to some type.
23:59:34 <dminuoso> Or the list type constructor.
23:59:45 <dani_> Ok, but suppose I have an "fmap (fmap f)" and I apply this one on x which has the right type. I still have something like fmap (fmap f x) no?
23:59:59 <dminuoso> dani_: No
