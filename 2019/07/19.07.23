00:07:18 <maerwald> anyone knows how to get the path of the spec executable?
00:07:49 <maerwald> new-exec doesn't add the PATH for the test targets
00:14:23 <Axman6> cabal new-exec which spec perhaps?
00:14:36 <Axman6> I guess that's what you mean by your second comment
00:15:22 <maerwald> Axman6: that doesn't work, only for real exec targets
05:22:14 <Ferdirand> i'm slightly confused by the new interface for modular arithmetic in arithmoi, that uses KnownNat
05:29:55 <Ferdirand> if I have a polymorphic expression (forall m. KnownNat m => Mod m), how do I coerce it at runtime if i have the desired Natural ?
05:32:04 <ski> coerce ?
05:32:29 <Ferdirand> or instanciate, not sure of the proper terminology here
05:32:43 <ski> just use it, at the desired type ?
05:32:48 <Ferdirand> yes
05:33:35 <Ferdirand> but i cannot use a variable inside a type annotation, can I ?
05:33:38 <ski> if you want to pick `m' as `n' (where `KnownNat n' is known), then simply use the polymorphic value of type `forall m. KnownNat m => Mod m', in a context that expects a result of type `Mod n' ?
05:33:57 <ski> you can use a tyvar there, if it's bound properly
05:34:04 <ski> where does `n' come from ?
05:34:43 <Ferdirand> there's this function getVal :: Mod n -> Integer
05:34:55 <Ferdirand> i'd like to write a function foo :: Nat -> Integer
05:35:09 <Ferdirand> foo n = getVal (some expression :: Mod n)
05:35:34 <ski> oh, so `n' is a value there, not a type
05:36:21 <Ferdirand> i guess
05:36:22 <ski> maybe you can use `someNatVal' ?
05:36:47 * ski isn't quite sure what `foo' is supposed to do
05:37:43 <ski>   case someNatVal n of SomeNat (Proxy :: Proxy n) -> getVal (some expression :: Mod n)
05:37:47 <ski> perhaps something like that ?
05:38:14 <Ferdirand> yes, thanks a lot
05:38:15 <Ferdirand> let me test
05:39:47 <ski> you'll need `ScopedTypeVariables', i think
05:40:18 <kuribas> would it be possible to formally proof a haskell program correct using liquid haskell (or something else)?
05:40:44 <kuribas> In particular, we have a compression algorithm that we want to be correct, to avoid losing data (currently in lisp and java).
05:40:57 <kuribas> I wonder if it would be feasable to verify in LH.
05:41:05 <hyperisco> I have never used LH but if you can express the property you want in LH and it can solve it, sure, yes.
05:41:09 <Ferdirand> ski: it works, thanks a lot. I'll try to wrap my head around this
05:41:12 * ski doesn't know that much about LH
05:41:26 <kuribas> hyperisco: It's mostly bit shifting, and (de)constructing bytestrings.
05:41:41 <hyperisco> Okay, well, hopefully they have those theories included.
05:41:42 <kuribas> ski: what would you use then?
05:41:56 <ski> Ferdirand : matching on `SomeNat' brings the `KnownNat n' constraint "into scope", provides it for use in the body of the branch
05:42:21 <hyperisco> You could do it in Coq and I think they have a Haskell transpiler… :P
05:42:58 <kuribas> hyperisco: there is also correctness.
05:43:08 <hyperisco> You can also get out a pencil and paper and brew a cup of coffee.
05:43:26 <ski> Ferdirand : matching the contained `Proxy n' with the (type ascribed) pattern `Proxy :: Proxy n' brings (the tyvar) *`n'* into scope, so that we can use `Mod n' in the type ascription on the `getVal' argument, so that the system knows to implicitly provide the `KnownNat n' evidence to `getVal'
05:43:33 <kuribas> hyperisco: but if I could prove a simpler version correct (say using lists + append), then rewrite that to bytestrings.
05:43:46 <hyperisco> Yeah.
05:44:06 <hyperisco> There are other formal provers for C and Java, say.
05:44:08 <ski> Ferdirand : er, sorry, not provide to `getVal', but to `some expression', of type `forall m. KnownNat m => Mod m'
05:44:14 <hyperisco> If LH cannot do what you want…
05:44:26 <kuribas> there's this for java: https://www.key-project.org/
05:44:30 <kuribas> but I never used it
05:44:46 <hyperisco> For automated proofs you're at the mercy of whatever theories they have preprogrammed.
05:45:57 <hyperisco> So, you need a bitshifting theory and a bytestring theory if you want to prove stuff about them, or an equivalent theory.
05:51:04 <literallyCrevice> Hey, I'm making a word game and not sure what data structure to use for my "dictionary. I need to be able to concat them in a pretty quick manner
05:51:17 <literallyCrevice> Wait, fuck. I entered too quickly
05:51:43 <literallyCrevice> Hey, I'm making a word game and not sure what data structure to use for my "dictionary". I need to be able to concat them in a pretty quick manner and be able to select randomly from it as well.
05:52:01 <hyperisco> Dictionary? Reflex says trie.
05:52:23 <dminuoso> literallyCrevice: Data.Map ?
05:52:43 <literallyCrevice> Oh, I wasn't clear enough. It's not a dictionary in the pythonic sense, just a list of words.
05:52:43 <kuribas> hyperisco: sadly it doesn't seem to support it
05:53:16 <literallyCrevice> But perhaps a Data.Set would do me good, now that I think about it
05:54:50 <hyperisco> kuribas, I wager a C prover would :)
05:58:10 <infinisil> literallyCrevice: You can select a random element from a Data.Set in O(log(n)) so that might work
05:58:35 <infinisil> Or alternatively you could just vectors/arrays actually
05:59:42 <merijn> literallyCrevice: I would start with a Set (possibly newtyped so it could be swapped out more easily in the future) and then consider switching latter if/when necessary
06:00:31 <literallyCrevice> I'll start with a set and see how it goes from there, thanks!
06:05:07 <Axman6> literallyCrevice: what operations do you need to be able to perform? lookup :: Dict -> Text -> Bool? add :: Dict -> Text -> Dict?
06:06:15 <literallyCrevice> I'll need to load the dict at compile time from a file, then each game I'll have to take 25 random words from it and run lookups on them
06:07:04 <Axman6> what sort of lookups?
06:07:18 <Axman6> you're not being very clear about your requirements
06:14:07 <literallyCrevice> Axman6: Dict -> Text -> Bool for instance
06:14:22 <Axman6> so set membership?
06:14:43 <Axman6> any other operations?
06:14:48 <literallyCrevice> That's it I think
06:15:24 <infinisil> So set membership, selecting a random element, and joining dicts together?
06:15:24 <Axman6> so you need [Text] -> Dict and Dict -> Text -> Bool - Data.Set or Data.HashSet from unordered containers should work
06:15:55 <Axman6> newtype Dict = Dict (Set Text) -- (or HashSet Text)
06:16:14 <literallyCrevice> And if I needed them ordered, what would you choose then?
06:16:27 <Axman6> Set
06:16:36 <literallyCrevice> Wait what
06:16:44 <literallyCrevice> Sets in haskell are ordered?
06:16:51 <kuribas> ski: is coq the standard tool for software verification?
06:16:52 <Axman6> Data.Set is
06:16:59 <literallyCrevice> Huh, didn't know that
06:17:05 <merijn> literallyCrevice: Same as C++ ;)
06:17:10 <Axman6> that's why you need Ord to add something to a set
06:17:19 <merijn> literallyCrevice: It's a binary tree based Set, hence why you need Ord
06:17:32 <infinisil> Axman6: If he needs to select random elements, I think HashSet won't be very good
06:17:37 <infinisil> s/he/they
06:17:49 <dminuoso> kuribas: The "standard" tool for software verification is a type system. Standard by frequency and spread of use.
06:17:56 <literallyCrevice> Got it, set it is. Thanks!
06:18:09 <Axman6> infinisil: take n . toList will be fairly random =)
06:18:38 <dminuoso> I suppose tests also go into the "software verification" department.
06:18:48 <literallyCrevice> Also, in this project I have a server and a client. How would I structure those in cabal/stack?
06:18:58 <infinisil> Axman6: Lol
06:19:01 <kuribas> dminuoso: that will not prove bit twiddling right
06:19:15 <__monty__> kuribas: You could also look into approaches like TLA+. Not sure how suitable that is for compression algorithms but in my head it seems plausible : )
06:19:24 <dminuoso> kuribas: What do you mean?
06:19:58 <kuribas> dminuoso: I cannot prove that my bitwise shifts, ands, etc;... produce the right result
06:20:02 <Axman6> literallyCrevice: they can be separate executabls in the cabal file (you can have as many as you want). any data types which will be shared between the two should go in the library and app specific stuff in the app's folder
06:20:07 <kuribas> dminuoso: using only types
06:20:35 <hyperisco> kuribas, I know it isn't Haskell but for bitwise operations I really think you could have success with https://frama-c.com/
06:20:37 <__monty__> kuribas: Then coq wouldn't work : >
06:20:49 <hyperisco> Or even an Assembly prover, but I don't know names
06:21:18 <bollu> bitwise is actually quite pleasant to do proofs in coq
06:21:27 <infinisil> literallyCrevice: I'd write a library component that contains things shared by client and server, then have two executable components for server and client
06:21:28 <bollu> they have a module with a bunch of proofs and tactics
06:21:48 <infinisil> Oh Axman6 already said that
06:21:49 <Axman6> cryptol is also quite nice for bitwise stuff
06:22:00 <Axman6> @quote stereo
06:22:00 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
06:22:05 <__monty__> I'm also thinking SMT but no experience.
06:22:10 <Axman6> so meta
06:22:16 <dminuoso> kuribas: My point is just that software verification is just a mechanism to ensure your software behaves correctly/does not behave incorrectly according to some specification. Since you weren't any more specific, the standard toosl to do that are types and tests. coq just gives you formal verification down to everything.
06:22:56 <__monty__> I was thinking of cryptol but wouldn't that be too harsh? I assume it has some timing attack checking built-in.
06:23:20 <bollu> __monty__ you can also use SBV to verify predicates quickly
06:23:28 <dminuoso> kuribas: What you seem to be asking for is formal verification, which is a very specific subset of software verification. :)
06:23:36 <bollu> kuribas* ^
06:23:38 <literallyCrevice> Alright, thanks again everyone!
06:24:17 <kuribas> dminuoso: right
06:24:52 <__monty__> bollu: Hmm, the example on the homepage is pretty encouraging : )
06:25:10 <__monty__> kuribas: http://leventerkok.github.io/sbv/
06:25:58 <bollu> kuribas Z3 is quite good at proving bit-things, and SBV is a nice interface to it
06:28:09 <kuribas> yeah, I already looked a bit into it
06:28:34 <dminuoso> Mmm, do we have set equality on lists in base?
06:28:39 <bollu> kuribas it doesn't fir the bill?
06:29:02 <bollu> fit*
06:29:37 <literallyCrevice> Also - I have a Game { gameState :: State } and a function (Something -> State -> State), what's the best way to create (Something -> Game -> Game)?
06:30:43 <dminuoso> literallyCrevice: coerce?
06:31:30 <jackdk> literallyCrevice: if you write functions: updateState :: (State -> State) -> Game -> Game, and updateSomething :: (Something -> Something) -> State -> State, then they compose nicely with (.) to give you a function (Something -> Something) -> Game -> Game
06:31:32 <literallyCrevice> dminuoso: The game isn't just a newtype State, it also has more stuff that I didn't bother listing (thought it wasn't relevant, sorry)
06:31:35 <kuribas> bollu: dunno, I'd like to proof the whole program correct, not just one bit
06:31:57 <bollu> kuribas I see
06:31:57 <jackdk> (you can then recover a function that does setting only by passing (const whatever) into your update function)
06:32:26 <jackdk> I find this a useful idiom in languages/projects/teams where I don't have access to lens
06:33:01 <literallyCrevice> jackdk: So are you saying between the lines that lens is a better solution here?
06:35:50 <Axman6> if you had lenses, you would be able to write theGameState & gameState %~ myModificationFunction
06:36:24 <literallyCrevice> That's too much for me now ahah, maybe later
06:36:50 <dminuoso> literallyCrevice: Honestly aside from manually composing those functions, there's not much you can do then.
06:36:59 <jackdk> literallyCrevice: I really like lens and think that it would be the best solution I know of, provided you were willing to pay the cost to learn it. But I'm reading between the lines that you might want a simpler solution that gets you nested record updates to begin with
06:37:01 <literallyCrevice> Alright, that's what I'll do then
06:37:42 <literallyCrevice> As for the updateBoard function, is there anything simpler/other than "updateBoard fn g = Game { gameBoard = fn (gameBoard g) }"?
06:37:43 <dminuoso> literallyCrevice: ⌜lens⌝ solves dealing with querying and manipulating deeply nested structures in a way that is unparalleled in Haskell. 
06:38:18 <jackdk> literallyCrevice: that's what I would write, were I writing that manually
06:38:58 <literallyCrevice> Oh sorry, instead of Game I meant to write g there
06:39:24 <jackdk> oh yeah I glazed over that bit yes
06:40:02 <jackdk> dminuoso is correct. lens is the best tool for your problem, but if you want to keep moving you can do something simpler today and come back and refactor later
06:40:09 <dminuoso> literallyCrevice: Perhaps the liberate use of operators in Axman6's example scared you off though. Here's an operator free version: ⌜over gameState modFun currentState⌝
06:40:52 <dminuoso> Where currentState is the current state you want to modify, modFun is the modification function that you want to apply at some nested value, and gameState is a first-class representation of the location you want to update
06:41:37 <literallyCrevice> Know what then, I'll try lens. Doing this to learn anyway
06:43:17 <jackdk> https://github.com/qfpl/state-machine-testing-course/blob/master/Lens_Cheatsheet.md may help, but I don't think it's been tested on new-to-lens people
06:43:45 <dminuoso> ⌜lens⌝ comes with its own tutorial, actually http://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html
06:44:50 <jle`> literallyCrevice: also one interesting thing is that updateBoard is just 'over gameBoard' (the lens gameBoard) if you use lens
06:45:08 <jle`> which makes it kind of nice, conceptually
06:45:57 <dminuoso> For maximum pleasure, you get these nice MonadState instances...
06:46:19 <jle`> over <myLens> gives you a way to lift a function over any field, given a lens into that field
06:46:48 <jackdk> I would also say, don't aim to swallow the entire library whole. You can get a lot of power just by taking little nibbles from it
06:47:07 <dminuoso> ^^^
06:47:26 <dminuoso> Just basic lenses and prisms can get you very far :)
06:48:12 * ski idly wonders why people write `==' when `=' would seem more appropriate
06:48:17 <ski> (at least to me)
06:49:46 <moet> hey, following up on some advice i got here last week
06:49:54 <jle`> 🎿 (x == y) = True
06:50:03 <dminuoso> Haha.
06:50:23 <moet> i switched all my Control.Monad.Except.Except code to Control.Monad.Except.ExceptT over a generic monad `m` .. it's much nicer, thanks!
06:50:39 <jle`> moet: nice :D
06:50:43 * ski . o O ( "U+FFFD REPLACEMENT CHARACTER" ? )
06:51:55 <ski> moet : were you using `m (Except e a)' much, with nested `case' to short-circuit ?
06:52:16 <dminuoso> moet: You could also use the MonadError interface, by the way.
06:52:22 <dminuoso> Making it even more generic
06:53:35 <moet> i was using `Except MyError a` and having trouble running it in `ExceptT AnotherError IO a` ... switching the former to `ExceptT MyError m a` made it so all I needed to run in the latter was a `withExceptT ErrWrappingConstructor`
06:54:24 <moet> dminuoso: i'll look at monaderror; i've been meaning to do that
06:55:06 <ski> moet : oic
06:55:07 <infinisil> moet: Relevant I think: https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html
06:55:49 <moet> infinisil: yeah, i've been thinking about this problem.. thanks for the link.. i'll check it out
06:56:35 <infinisil> A recent package that might also be useful for error handling: https://hackage.haskell.org/package/world-peace
06:57:02 <dminuoso> ski: Mmm Ive really been pondering about using + and * as type aliases for a while now.
06:57:15 <dminuoso> Sometimes Either is annoyingly verbose.
06:57:39 <ski> the MLs use `*' for tuple types
06:58:32 <merijn> So, I have an algorithmic problem: I have a sequence/stream of N data points and I want to filter a uniform random subset of that stream, ideally without keeping the entire sequence in memory
06:58:48 <ski> (`(int * char) * bool' is different from `int * char * bool' is different from `int * (char * bool)')
06:58:58 <merijn> I was thinking of some RNG based approach, but that makes it hard to guarantee I actually get the right number of filtered elements
06:59:57 <dminuoso> ski: Interesting, how is that different? 
07:00:15 <oats> is there a special Functor-like thing for when you're mapping from one type to the same type?
07:00:15 <infinisil> merijn: A set of a specific size?
07:00:25 <infinisil> merijn: Or uniform across all potential set sizes too?
07:00:26 <ski> dminuoso : in Haskell, `((Int,Char),Bool)' vs. `(Int,Char,Bool)' vs. `(Int,(Char,Bool))'
07:00:41 <dminuoso> ski: Ohh I see. I was suspecting something more elaborate.
07:01:14 <merijn> infinisil: I want it to work across all set sizes, but the set size is known ahead of time
07:01:25 <dminuoso> oats: What exactly are you looking for?
07:01:28 <infinisil> merijn: Then you can use a neat algorithm
07:02:20 <dminuoso> oats: A generic function mapping from the a type to the same type is described by the type signature ⌜a -> a⌝ with only one possible implementation (ignoring bottom)
07:02:24 <infinisil> merijn: Select the first element with probability k/n  (where k is the number of samples you want), if you choose it, select the next one with (k-1)/(n-1) probabilyt, if you didn't choose it select the next one with k/(n-1)
07:02:24 <oats> dminuoso: something like `fmap` except of type `(a -> a) -> f a -> f a`, and I'm just wondering if such a typeclass already exists
07:03:24 <dminuoso> oats: Same rules. That would only admit lifting ⌜id⌝
07:03:46 <dminuoso> Or.. no.
07:03:51 <dminuoso> Any endofunction actually, sorry.
07:03:54 <oats> I don't understand. Would not something like (+1) work there?
07:03:56 <moet> ok, i read the post from infinisil about the error handling
07:04:17 <dminuoso> oats: Got confused by which things are quantified where for a second.
07:04:30 <oats> dminuoso: ah, sure. no worries :)
07:04:33 <moet> i think for monadic actions that might be nice.. 
07:04:34 <moet> thanks
07:04:39 <something_else> hi, i just wanted to check something. does the block sort have worst-case space complexity O(1) and worst-case performance O(n log(n)) when using linked lists?
07:04:45 <merijn> infinisil: The problem with that approach is that it becomes hard to guarantee exactly k values. That will average to k values, but I'm not sure I'll end up with *exactly* k
07:05:08 <infinisil> merijn: It will actually!
07:05:45 <ski> dminuoso : i suppose one could imagine `T + U + V' being distinct from both `(T + U) + V' and `T + (U + V)'
07:05:52 * ski . o O ( `UnboxedSums' )
07:06:04 <infinisil> merijn: The thing is, if you don't select any for a long time, eventually n will be equal to k, which means the probability of selecting it is 1
07:06:08 <merijn> infinisil: In mathematical world, yes. But in "dirty IEEE-754 float world"? :)
07:06:26 <Axman6> something_else:  what do you mean by block sort?
07:06:51 <Axman6> ski: I want UnboxedSums so bad :(
07:07:02 <ski> ?
07:07:07 <something_else> Axman6 this sort, https://en.wikipedia.org/wiki/Block_sort . I don't fully understand it yet but was just curious
07:07:20 <dminuoso> oats: I cant think of any such class.
07:07:37 <dminuoso> oats: If you have some specific data type or class you can equip it with a specialized fmap that prevents changing the inner type.
07:07:45 <oats> dminuoso: alrighty then, I'll just implement it myself :)
07:08:01 <oats> dminuoso: would this be like an endofunctor though?
07:08:09 <dminuoso> oats: That's what Functor already captures.
07:08:17 <oats> ah, ok
07:08:21 <dminuoso> oats: It'd be lifting of endofunctions.
07:08:25 <Axman6> something_else: I believe it likely would have those bounds - though it gets a little more difficult to reason about when you have laziness
07:08:39 <infinisil> merijn: I don't think it's a problem. The only place where inaccuracies can occur is for the division, which isn't a problem with IEEE
07:08:52 <infinisil> merijn: Then just compare that with a uniformly distributed Double
07:09:42 <Lears> oats: You might be interested in MonoFunctor, which is essentially this in another form.
07:09:48 <Axman6> something_else: hmm, maybe not, I misunderstood the algorithm
07:09:55 <merijn> Generating a uniform distributed Double is tricky business too ;) Although I suppose someone has hopefully already implemented that
07:10:21 <ski> merijn : hm, i was thinking about splitting `n' into `n0 + n1', of roughly the same size, while uniformly splitting `k' into `k0 + k1' ensuring `k0 =< n0 /\ k1 =< n1'. then apply this recursively to determine which elements to keep around
07:10:41 <dminuoso> oats: However, it would be a full fleged endofunctor in a subcategory of Hask.
07:10:49 <ski> but if what infinisil is describing works, that's probably the simpler route
07:11:05 <merijn> ski: Any form of splitting means having all of N in memory, which is a no go
07:11:11 <noipmusp> Is there an elegant pointfree version of "\x -> foo x || bar x || baz x"?
07:11:12 <ski> merijn : why ?
07:11:18 <merijn> ski: Because N is *big*
07:11:29 <ski> i mean why would it mean having all the elements in memory ?
07:11:34 <merijn> ski: I currently have a solution that keeps N in memory and it's becoming cripplingly slow :)
07:11:45 <dminuoso> oats: The subcategory would be compromised of types and endofunctions as morphisms.
07:11:54 <ski> or are you saying that the *number* `N' is too big to keep in memory ?
07:12:05 * ski would find that hard to believe, so nevermind
07:12:13 <merijn> ski: Wait, then I don't understand how I'd select elements with your logic?
07:12:25 <infinisil> ski: merijn: Yeah so I'm 99.9% sure what I described works reliably (I even did the maths at some point to make sure it's uniform), and it only uses constant memory and works online
07:12:53 <infinisil> I also have it implemented somewhere, can't find it though
07:12:57 <dminuoso> oats: So if we term that subcategory Endohask, then such a class RFunctor would be endofunctors on Endohask.
07:13:05 <ski> merijn : what i described is a binary tree with leaves containing `Keep' or `Skip'. now to a depth-first traversal of this (lazy) tree, while walking your stream ?
07:13:31 <something_else> Axman6 it is actually for a DSL so it is strict. could you recommend a replacement algorithm for insertion sort with the same space complexity?
07:13:40 <merijn> infinisil: Yeah, I think it works in 99% of cases, but I'm worried about the consuming code (which expects exactly K elements) will break if I end up an element short or over
07:14:06 <merijn> ski: Ah, but if K is also big that trees becomes problematic too :)
07:14:14 <something_else> Axman6 since programs may be written in it I want something faster but not necessarily taking up more memory
07:14:18 <something_else> thanks
07:14:31 <something_else> although i think i might be looking for fool's gold
07:14:51 <infinisil> merijn: Yeah but there's no way this can happen, implement it and test it to make sure yourself :)
07:14:58 <ski> merijn : the tree should, i hope, be possible to traverse so that the seen parts of it can be GCed, while the non-seen parts are not yet materialized
07:14:59 <infinisil> Best to plot the values for k and n too
07:15:12 <ski> merijn : possibly one could also fuse the tree away completely
07:15:38 <ski> (by hand, or maybe automatically)
07:15:39 <merijn> ski: But at that point isn't the tree essentially copying infinisil's approach?
07:16:19 <ski> merijn : as soon as `n = k' for a subtree, you know that you can keep those `k' elements at that point
07:16:31 <oats> dminuoso: so would my customized fmap make for not a true Functor implementation, since you couldn't supply it any function of `a`?
07:16:59 <ski> merijn : you'd be ensured that you don't end up near the tail, and haven't enough elements left to fill your `K' quota
07:17:33 <ski> (but possibly infinisil's version ensures that as well ?)
07:17:38 <infinisil> It does
07:17:57 <ski> i'm not sure which one would be using more random bits
07:18:36 <ski> (certainly the random choices are structured differently. linearly vs. in a binary tree)
07:18:57 <dminuoso> oats: Well Functor in the sense of the specific typeclass called Functor.
07:19:08 <dminuoso> oats: It would still be a functor in a category theory sense
07:19:21 <dminuoso> Assuming you require ⌜ymap id = id⌝
07:20:36 <infinisil> merijn: ski: Oh and actually, no double's are needed even, you can implement my approach with Int's too
07:20:42 <infinisil> I'll go implement this now, hold on
07:21:12 <ski> (doubles ?)
07:21:19 <infinisil> floating point numbers
07:21:34 <ski> they were mentioned ?
07:21:49 <merijn> ski: For computing the probabilities
07:21:53 <infinisil> Well I don't think I mentioned them, but that's what I thought of using for division
07:22:05 <merijn> ski: "n/k" kinda implies using doubles for computing the probabilities :)
07:24:10 <ski> well, you could just generate a random integer `i', uniformly selected with `0 =< i < n', and then check `i < k' ?
07:24:27 <ski> (that wastes some random bits, of course)
07:25:17 <merijn> ski: I don't care about wasting random bits, plenty of those around :p
07:25:20 <ski> hm, perhaps there already are pre-made operations for this type of use-case ?
07:25:53 <merijn> ski: oh...that's actually kinda similar to the partial Fisher-Yates shuffle method of selecting k over n
07:27:18 <ski> merijn : the tree thing i described ?
07:27:46 <merijn> ski: No, the "0 <= i < n" and checking "i < k"
07:28:04 <ski> oats : is there a reason why you'd want `(a -> a) -> (f a -> f a)' ?
07:28:24 <merijn> ski: I think that one even trivially guarantees exactly k elements
07:28:52 <merijn> ski: Just means I need to figure out a way to adapt the parameterised number generation to a seedable version
07:30:21 <ski> hm, does Fisher-Yates involve an inequality checking ?
07:30:44 <ski> "parameterised number generation" ?
07:30:57 <merijn> ski: "between 0 and N"
07:31:33 <ski> but that's a range, not a boolean check ?
07:31:55 <ski> (unless you're talking about how one could implement randomly selecting from such a range, perhaps)
07:32:05 <merijn> ski: That's what I mean, yes
07:32:21 <ski> okay
07:33:00 <merijn> ski: Fisher-Yates does the following. Given an N element array. Start with offset (N-1). Pick a random number between 0 and offset. Swap the generated number and offset. Decrement offset by one. Repeat
07:33:19 * ski nods
07:33:54 <merijn> ski: Since the "selected" element is swapped out of the "selectable range" it guarantees each number is only randomly selected once for a proper shuffle. But you can just run a partial one and use the K last elements of the area as a method for selecting K over N uniform randomly
07:34:53 <merijn> ski: Your logic of generating between 0 and N and then checking the number is < K (well, assuming you decrement K by 1 every selection) seems to follow somewhat analogue logic
07:35:33 <merijn> oh, wait, I think you want to generate between "0 and remainder of N"
07:35:38 * ski . o O ( "Provably perfect random shuffling and its pure functional implementations" by Oleg in 2002-07-14 at <http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle> )
07:35:52 <merijn> Because then at some point N will be K and the selection is always true
07:36:06 <merijn> Which I think boils down to infinisil's idea?
07:36:24 <merijn> Except getting rid of the ugly floating points and keeping it nice and discrete with integers
07:36:45 <moet> how can i suppress the orphan instance warning for a single instance?
07:36:52 <merijn> I'd need to do some scary math to check if that's right, though...
07:36:58 <merijn> moet: You can't atm, sadly
07:37:00 <EvanR> getting rid of ugly floating point and switch to nice exact real numbers!
07:37:08 <moet> ok, that's fine. i'll put it in its own file and turn off for the file
07:37:17 <merijn> moet: Probably the best option
07:37:20 <ski> "But you can just run a partial one and use the K last elements of the area as a method for selecting K over N uniform randomly" -- i see, but then the ordering wouldn't necessarily be kept. but if we could instead mark the original elements, that'd work, i suppose
07:37:28 <dminuoso> moet: You can disable it module wide at least with {-# OPTIONS_GHC -fno-warn-orphans #-}
07:37:31 <ski> (i'm not sure it'd stream well)
07:37:36 <merijn> I've proposed an ADOPT pragma, but that got rejected in favour of more fine-grained warning pragmas
07:37:52 <merijn> ski: Ordering is, tbh, not quite relevant to me
07:38:16 <ski> merijn : "well, assuming you decrement K by 1 every selection" -- rather, i was splitting `K'
07:38:20 <ski> ok
07:38:30 <infinisil> merijn: ski: Got it implemented, not 100% sure about bug-freeness, but tests seem to be promising: https://gist.github.com/Infinisil/500ae6cb4d18a9f4a819baeabfd004ce
07:38:44 <infinisil> This is based on lists, but should be easy to extend to whatever stream library you need
07:38:45 <merijn> ski: But I'm getting data from an SQL query, currently I materialise and shuffle for selection, but I wanna try to avoid materialising the dataset :)
07:39:11 <merijn> infinisil: I think we just independently reinvented this approach in the chat? ;)
07:39:14 <ski> merijn : "Because then at some point N will be K and the selection is always true","Which I think boils down to infinisil's idea?" -- in infinisil, that may happen at the end. in my case, it may happen at any subtree (corresponding to contiguous subsequence)
07:40:14 <infinisil> merijn: (not sure, I haven't looked at the chat, I implemented what I said in the start)
07:40:36 <infinisil> With Int's instead though
07:40:40 <ski> merijn : anyway, then `0 <= i < n' and checking `i < k' i mentioned was just a way to do a random bit, with probability `k / n'. not directly connected to my tree idea. it was more a response to how to do infinisil's suggestion, without floarint-point
07:41:26 <merijn> infinisil: Start with N (set size) and K (number of elements). For each element seen, generate x between 0 and N-1. If x < K, keep the element and decrease K. Then decrease N
07:42:00 <infinisil> Ah yeah that's exactly what I implemented, it's the same as the floating point thing, just factoring out the division
07:42:10 <infinisil> But my implementation is not quite correct
07:42:16 <infinisil> Investigating..
07:42:20 <merijn> ski: I like integers, because I will most likely implement the RNG logic in C, rather than passing an FFI wrapped foreign function to SQLite :)
07:44:52 <infinisil> Ah, just mixed up a 0 with k
07:45:43 <infinisil> And another mistake
07:46:19 <Raylier> Hello people
07:46:50 <ski> infinisil : `v > 0' will do a Bernoullit trial with probability `1/len', rather than `k/len', no ?
07:47:00 <ski> ah, you said
07:47:12 <ski> hello Raylier
07:47:14 <infinisil> Yeah
07:47:22 <infinisil> Just updated the gist with a better version
07:47:30 <infinisil> And more bug-free one
07:47:37 <ski> should be `v >= k', i think
07:47:45 <infinisil> Yup :)
07:47:56 <infinisil> (realized it after testing that v > k wasn't correct)
07:48:34 <ski> you could use `xs0@(x:xs)' rathre than `x:xs', i suppose
07:48:38 <ski> why use a pair ?
07:48:42 <infinisil> True
07:48:49 <Raylier> Want to start learning Haskell and maybe make some real stuff with it. Looking at the haskell-platform packages on debian it's almost a Gig
07:48:50 <infinisil> To not have to calculate the length all the time
07:49:13 <ski> no, i mean why not curried
07:49:16 <Raylier> Is there a more lightweight version of Haskell I can use as I dount I'll be using all that fancy stuff in Haskell just for learning
07:49:33 <infinisil> ski: Ah, no particular reason
07:49:47 <infinisil> Grouping them together like this kinda makes sense
07:49:51 <infinisil> Won't be confusing with the other Int
07:51:29 <merijn> Raylier: Well, there's several repl sites that support it and lambdabot, but there isn't really a smaller install of GHC
07:51:33 <infinisil> ski: Is there a technical reason one might prefer one over the other?
07:51:44 <infinisil> I guess currying could be
07:51:53 <infinisil> But not here
07:51:59 <merijn> Raylier: Making a smaller/more minimal GHC install is complicated work that requires significant effort that is better spend on other tasks, since disk space is cheap these days
07:52:04 <ski> (could be what ?)
07:52:33 <ski> (not using a tuple here might be slightly more efficient)
07:53:22 <Raylier> Ah alright, I am one of those minimal shills usually but I just downloaded everything at once:)
07:53:56 <Raylier> Any tips on how to really start learning and using Haskell? I know about the Books online but I rarely follow through and complete stuff using the Book
07:53:57 <ski> (also, i'd possibly consider passing in a `gen' where `RandomGen gen', instead)
07:55:05 <ski> Raylier : probably depends on your learning style
07:55:17 <infinisil> ski: Yeah, was just using IO for demonstration purposes
07:55:24 <ski> some people like learning by attempting small, practicalish projects
07:55:35 <ski> others want to dive into the theory and the concepts
07:55:54 <ski> infinisil : yea, thought so. it's just a minor comment
07:56:30 <infinisil> ski: I don't mind code reviews, thanks :)
07:56:50 <Raylier> For me Haskell will be the intro to Functional Programming since till now, I've only done procedural some OOP(disgusting), and scripting
07:57:57 <EvanR> install GHC and try not to turn on any extensions, now youre using lightweight haskell
07:58:04 <ski> infinisil : did you look at that Oleg article, at some point, btw ?
07:58:29 <ski> Raylier : anyway, you're welcome to ask beginner questions in here
07:59:02 <ski> (and, if you want to, you could also lurk around, see what people discuss, and see if you can understand and learn from some of it)
07:59:12 <Raylier> Thanks ski :)
07:59:15 <infinisil> ski: Ah nope, you mean <http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle>?
07:59:18 <ski> yes
08:00:30 <EvanR> but i found lightweight haskell somewhat more confusing or surprising than "welterweight haskell", namely restrictions on contexts and instances
08:00:42 <infinisil> Neato
08:00:44 <ski> infinisil : there's one version in there in which the algorithm is passed an input which is supposed to be a list of randomly selected integers. so, that'd be an off-line random generation, rather than the on-line you had in your paste
08:00:45 <EvanR> also non-gadt syntax
08:01:06 <ski> infinisil : i was wondering whether it would be possibly to reformulate your (on-line) to an off-line version
08:01:44 <infinisil> I mean you can always go from online to offline by just feeding all values in sequence
08:02:23 * ski idly wonders whether Raylier knows about BNF (Backus–Naur Form / Backus Normal Form) notation for grammars 
08:02:28 <infinisil> (well you can also go the other way at a loss of efficiency)
08:03:58 <ski> Raylier : anyway. i would suggest coming at FP with a fresh mind. it's more like learning to program from scratch all over again, than learning yet another procedural or OOP language
08:04:10 <ski> (though obviously some things do carry over)
08:05:00 <infinisil> Oh, this select function would be a great use case for dependent vectors
08:05:59 <ski> Raylier : you will possibly (well, probably) have to unlearn some conceptions and habits that you have acquired. i'd suggest not trying to compare FP concepts too much with concepts you know from other languages, until you have a bit more understanding under your belt
08:07:20 <ski> (it has been suggested that it may be easier to learn FP, if you have no prior exposure to imperative programming beforehand. i'm not sure whether there has really been any attempts at verifying this, though)
08:07:51 <ski> infinisil : mhm ?
08:08:39 <infinisil> In idris the function could be written with this type:
08:08:41 <infinisil> select : { auto smaller : LTE k n } -> (k : Nat) -> Vect n elem -> Vect k elem
08:09:19 <infinisil> Which would ensure and encode that it returns k elements
08:09:20 <dminuoso> ski: I know of some anecdotes, and I must admit I recall myself telling this with no basis in fact..
08:09:47 <infinisil> Oh, except it needs some way to get randomness
08:10:10 <ski> infinisil : ah, ok
08:10:18 <ski> (what's the `auto' ?)
08:11:05 <infinisil> ski: auto tries to find a value in the scope to use automatically, so you don't need to pass it yourself. Very useful for filling out types representing proofs like the LTE here
08:11:23 <ski> oic
08:11:44 <merijn> cabal has no way to compile C++ code, right?
08:12:05 <ski> (i didn't really follow "you can always go from online to offline by just feeding all values in sequence", btw)
08:13:06 <merijn> ski: That online methods also automatically function as offline methods, so you can just loop over the offline data set :)
08:13:08 <infinisil> ski: If you know all the data beforehand (offline algorithm), you can "simulate" it being online by passing values one-by-one to the online algorithm
08:16:52 <Cale> Raylier, EvanR: Yeah, there are very few extensions which really need to be avoided. If GHC suggests an extension to you, it's usually fine to just switch it on, with few exceptions. (I'd also recommend reading about what it does in the GHC User's Guide first too.) Mostly I would recommend avoiding OverlappingInstances, IncoherentInstances, and ImpredicativeTypes (and there's nothing morally wrong with this third one except that its 
08:16:52 <Cale> implementation is pretty incomplete).
08:17:15 <dminuoso> Cale: "incomplete and buggy" you mean.
08:17:24 <Cale> yes
08:17:46 <Cale> Really, it should probably have been switched off altogether until it worked properly again
08:18:11 <dminuoso> Cale: Supposedly SPJ once said that the main problem with ImpredicativeTypes was that nobody even knows what type inference in the world of impredicativity would even mean, so nobody knows what a correct implementation would be.
08:19:06 <Cale> That's an entirely fair thing to say, though I think the current state of affairs is more broken than it could be even so.
08:19:24 <merijn> Cale: Well, it's not incomplete, no one knows what it should do, so it's impossible to say if it's complete and/or correct :p
08:19:42 <merijn> There was talk on the ghc-devs on fixing a limited form of impredicativity
08:20:09 <dminuoso> I mean impredicativity itself is just fine. After all core has impredicative types..
08:20:55 <ski> infinisil : yes, but what you said sounded to me like the opposite
08:21:45 <infinisil> ski: Ah, yeah so I meant "if you have an online algorithm, you can get an offline algorithm"
08:21:55 <ski> merijn : "That online methods also automatically function as offline methods" -- that sounds like the opposite, to me :)
08:22:07 <merijn> ski: Why?
08:22:11 <ski> infinisil : yes, that's backwards, to me :)
08:22:30 <merijn> ski: offline algorithms are algorithms that require access to the full dataset
08:22:48 <merijn> ski: You can't automatically recover an online (i.e. streaming in finite memory) algorithm from that
08:23:22 <merijn> ski: Whereas converting an online (i.e. streaming in finite memory) algorithm into an offline one just means "I'm just gonna apply this to the dataset I already had"
08:23:32 <ski> by "offline", i mean preparing the randomly generated input before commencing processing the data. while by "online" i mean that you do random generation during that processing (and possibly *which* intervals you select in depends on that data)
08:23:57 <ski> so, you can trivially pretend an offline algorithm is online, but not the other way around
08:24:25 <michalrus> ( Is there an alternative pattern-matching function definition syntax, where the function name doesn’t have to be repeated? )
08:24:42 <ski> (i'm not talking about online vs. offline for the data stream. i'm talking about online vs. offline for the random generation)
08:24:55 <lavalike> michalrus: f ... = case ... of { <cases> }
08:25:03 <merijn> ski: You can't pretend an offline algorithm is online
08:25:12 <merijn> ski: huh?
08:25:16 <michalrus> lavalike: ok!
08:25:29 <merijn> ski: online/offline generally only refers to the input data of an algorithm
08:25:32 <dminuoso> michalrus: Or equivalently ⌜f = \case -> ...⌝ with LambdaCase
08:25:37 <infinisil> Yeah what merijn said
08:25:46 <infinisil> Not sure how random generation is relevant
08:25:46 <dminuoso> Err ⌜f = \case ...⌝ :)
08:26:03 <michalrus> Mhm. :) Thanks.
08:27:43 <ski> merijn : "online/offline generally only refers to the input data of an algorithm" -- i was specifically applying the terms here to the random generation (also input), not to the input stream
08:28:39 <ski> iow, we seem to be using the terms to refer to different aspects of the algorithm, talking past each other
08:28:50 <infinisil> You probably shouldn't call this online/offline then, because that will confuse everybody :)
08:29:04 <ski> i'm just applying the terms to *another* input
08:29:31 <infinisil> I'm not sure randomness can be considered an input
08:29:46 <infinisil> I mean technically yes, but it's very irrelevant to the algorithm
08:30:12 <ski> well, when i made the comment, i was specifically commenting on the randomness, how it was used
08:30:24 <ski> in your paste, you make calls to `randomIO', as you go
08:30:36 <ski> rather than making all calls to it, initially, before traversing the input list
08:30:51 <ski> the former, i called "online", while i called the latter "offline"
08:32:21 <ski> and i was mentioning this, because one of Oleg's versions is "offline" in this sense, being passed a list of already randomly selected integers
08:33:26 <dminuoso> Does anyone have an idea what pattern this is and how I can abstract over it in a clean fashion?
08:33:28 <dminuoso> https://gist.github.com/dminuoso/edef49b1060637c9ea706541e4424f3f
08:33:40 <infinisil> ski: Hm I see
08:33:42 <nshepperd> the thing that prevents you from turning that algorithm into an 'offline' one is that it's fused more than that it's 'online'
08:34:07 <sclv> dminuoso: cont monad?
08:35:11 <nshepperd> calling randomIO as you go has fused the generator and consumer of random numbers
08:36:11 <sclv> in my mind offline/online is about memory usage fwiw -- an online algo can run in space that's less than O(n), typically constant or log(n)
08:37:28 <ski> the terms "offline" vs. "online" are also being used e.g. in the context of partial evaluation. it's not like there's a single context of interpretation of them
08:37:31 <dminuoso> sclv: Mmm. I was actually wondering about how to capture these pattern matching in that weird position into some `withSome` from which I can derive all other versions of it. Is cont still your answer?
08:38:29 <nshepperd> if it was calling getRandom in an abstracted MonadRandom monad you could describe it as being 'online' in about the same way, but you could then define a type implementing MonadRandom which would pass numbers from your preexisting list
08:38:42 <ski> nshepperd : i suppose. by the "offline" vs. "online" distiction i'm after here is a bit akin to the "static" vs. "dynamic" sequencing distinction between idioms and monads
08:39:22 <infinisil> In an algorithmic context, this one surely is the by far most widely used interpretation: https://en.wikipedia.org/wiki/Online_algorithm
08:40:07 <sclv> dminuoso: why not do withSomeService :: Uid -> (MailService -> InternetService -> FreyjaM a) -> (MailService -> FreyjaM a) -> (InternetService -> FreyjaM a) -> FreyjaM a
08:40:52 <ski> dminuoso : it looks pretty `ContT'y .. i'm not sure to which extent that'd help with expressing whatever you want to express, though
08:42:20 <ski> dminuoso : `FreyjaM a' is a synonym for `IO (..a..)' ?
08:42:55 <dminuoso> ski: newtype FreyjaM a = FreyjaM{ runFreyjaM :: LoggingT (ReaderT Env IO) a} 
08:43:27 <dminuoso> With GND bringing me all the fancy instances.
08:44:02 <dminuoso> sclv: Huh I think that could actually work!
08:44:15 <dminuoso> sclv: So basically the solution is to apply more cont thinking.
08:44:33 <dminuoso> I think I could make something happen with that.
08:52:06 <ski> dminuoso : so how are those `throwIO' calls not type errors, assuming `Control.Exception.throwIO :: Exception e => e -> IO a' ?
08:53:13 <ski> sclv, nice :)
08:53:13 <dminuoso> ski: That's a really good catch.
08:53:18 <dminuoso> ski: Im using UnliftIO.Exception.
08:54:08 <ski> dminuoso : i was just wondering whether you couldn't write those functions in DS, using `ContT'
08:54:25 <dminuoso> ski, sclv: So this is what I have now: https://gist.github.com/dminuoso/f3f7d2b608dc93624e6f1d757181b452
08:54:40 <dminuoso> I could probably rewrite this with ContT like you both implied already, not sure whether that's worth it though
08:54:47 <ski> (dminuoso : also, presumably several of those error messages are inaccurate, but i assume you already know)
08:54:58 <dminuoso> ski: Oh yeah.
08:55:11 <ski> dminuoso : "not sure whether that's worth it though" *nod* (as i remarked)
08:55:42 <dminuoso> This right now has a good amount of readability, and its decently concise.
08:56:19 * ski nods
09:15:56 <dminuoso> infinisil, nshepperd: I apologize if I killed your discussion. Please carry on.
09:16:58 <infinisil> I don't think there was much left to discuss, no worries
09:42:05 <ski> nshepperd : "if it was calling getRandom in an abstracted MonadRandom monad you could describe it as being 'online' in about the same way, but you could then define a type implementing MonadRandom which would pass numbers from your preexisting list" -- yes, that's basically what i meant by "so, you can trivially pretend an offline algorithm is online, but not the other way around" (minus not having `MonadRandom', in particular, in mind)
09:54:58 <nshepperd1> Actually i don't think it's really accurate to describe the version calling randomIO as 'online' at all
09:55:18 <nshepperd1> The difference is incremental vs non incremental consumption of input
09:56:36 <ski> the main difference i was after, was deciding beforehand which random trials you're going to, versus only deciding the trials after (incrementally) seeing the data
09:57:23 <nshepperd1> But calling a hardcoded algorithm to generate numbers is not input, from the point of view of any other haskell code
10:00:50 <ski> the PRNG depends on the seed, which would be input
10:01:17 <ski> (and `shuffle1' doesn't call a PRNG)
10:01:31 <nshepperd1> Well, any algorithm is trivially both offline and online is the input is a single Int
10:03:19 <ski> i don't follow
10:04:17 <ski> what i'm talking about is whether one can reformulate two interleaves processes, which handle different concerns, into two separate stages, one coming before the other
10:06:59 * ski suspects they're, somehow, explaining this wrong
10:19:39 <nshepperd1> With ordinary online algorithms like kahan summation, the caller decides the length of the input. "Here are some numbers, please give me their sum"
10:20:05 <nshepperd1> Providing them in a stream or all at once as an array makes no difference
10:21:05 <nshepperd1> But algorithms that use random numbers typically get to demand arbitrary quantities of random numbers, which the caller must provide
10:21:27 <nshepperd1> Is that what you were getting at?
10:22:19 <ShalokShalom> is stack-static supposed to provide ghci?
10:25:12 <dminuoso> ski: Yay I realized I can get rid of those intermediate data types ⌜data SomeMail = MailMixed MailService | MailPure MailService⌝ as well and encode this with CPS as well. I was going to encode this knowledge what kind of service it was inside an ADT and immediately pattern match to re-learn what I already know.
10:26:00 <dminuoso> https://gist.github.com/dminuoso/f0697696a2cc4cfa45e960b91741e0a5 this is my final version I think. (The Pure/Mixed newtype wrappers are just a barrier to communicate clearly which continuation is for which case)
10:26:56 <dminuoso> Thank you and sclv again, this is great.
10:27:54 <ShalokShalom> Hnn: 
10:27:55 <ShalokShalom> No setup information found for ghc-8.6.5 on your platform.This probably means a GHC bindist has not yet been added for OS key 'linux64-ncurses6'.
10:28:01 <dmwit> dminuoso: You might also like Tagged
10:28:08 <ShalokShalom> I use a pretty rare OS
10:28:50 <solonarv> ShalokShalom: I have not used stack-static, but based on the name I would guess that it is just stack itself, so I don't see why it would provide ghc
10:28:59 <solonarv> anyway, what's the OS you're using?
10:29:09 <ShalokShalom> Its kaosx.us
10:29:13 <ShalokShalom> I package it for it
10:29:17 <dminuoso> dmwit: Tagged would communicate it only on the definition side, not the call-site though, wouldn't it?
10:29:23 <ShalokShalom> As a custom user package
10:30:20 <dminuoso> dmwit: I mean I'd just say ⌜withSomeInet uid (\(Tagged f) -> ...) (\(Tagged g) -> ...)⌝ leaving the possibility of mixing the both sides up.
10:30:50 <ShalokShalom> How to configure that setting?
10:31:32 <ShalokShalom> It says: Supported versions: ghc-7.10.3, ghc-8.0.1, ghc-8.0.2, ghc-8.2.1, ghc-8.2.2
10:32:10 <ShalokShalom> So 8.6 seems to be not supported
10:32:19 <solonarv> hmm, looks like GHC HQ (or wherever stack gets its binaries) stopped providing binaries for that configuration
10:32:38 <ShalokShalom> It is supposed to have GHCI: https://docs.haskellstack.org/en/stable/README/
10:32:44 <ShalokShalom> Aha, ok
10:32:46 <ShalokShalom> Thanks
10:32:49 <solonarv> which seems strange
10:32:54 <ShalokShalom> ok?
10:33:11 <ShalokShalom> Its still active: https://github.com/commercialhaskell/stack/
10:33:44 <solonarv> well, let's see if we can sidestep this issue
10:33:52 <solonarv> is there any particular reason you're using stack?
10:34:13 <ShalokShalom> Yep. Haskell is a hell to build :P
10:34:30 <ShalokShalom> We are a small distribution. 
10:34:46 <ShalokShalom> And I like to contribute something into the community repos
10:35:17 <ShalokShalom> I think all the subpackages required to build Haskell alone are around 200 or so
10:35:35 <ShalokShalom> I guess thats for what stack is
10:35:41 <ShalokShalom> While I will ask there, thanks :)
10:35:58 <solonarv> so.. you are using a smallish distribution, and want to package "haskell" for it? or you want to package a bunch of the Haskell development tools (ghc, cabal, stack) ?
10:38:02 <ShalokShalom> The first one
10:38:15 <ShalokShalom> While the second one is also nice
10:38:25 <solonarv> there isn't really a monolithic "haskell" that you could package
10:38:27 <ShalokShalom> The ultimate goal is to package Eta, what just happens :)
10:38:34 <ShalokShalom> It is already installed :D
10:38:50 <ShalokShalom> I just like to find a way for the ghci
10:39:24 <dmwit> dminuoso: The communication would be optional, I suppose, which perhaps isn't what you want.
10:39:28 <solonarv> ghci comes with ghc
10:39:29 <gobby> Is there a way to pattern match on type constructors?
10:39:44 <solonarv> so if you have figured out how to install GHC, congratulations - there's ghci!
10:39:46 <dmwit> dminuoso: (As in Tagged @Pure \f -> ... if you choose to exercise the option.)
10:40:06 <ShalokShalom> I have already printed the error message :D
10:40:36 <ShalokShalom> No setup information found for ghc-8.6.5 on your platform.This probably means a GHC bindist has not yet been added for OS key 'linux64-ncurses6'.Supported versions: ghc-7.10.3, ghc-8.0.1, ghc-8.0.2, ghc-8.2.1, ghc-8.2.2
10:40:36 <dmwit> I am using cabal-install 2.4.1.0 (the latest). When I cabal v1-exec ghci, it can't see modules installed into the sandbox. Is something strange on my system, or is this a regression?
10:42:33 <solonarv> dmwit: just a guess, but perhaps there is a rogue environment file skulking about?
10:44:04 <dmwit> There is no file with a name beginning with .ghc (except for ~/.ghc and ~/.ghci) in any of the ancestor directories of the sandbox.
10:45:04 <dmwit> (Yes, even if you consider the sandbox directory to be an ancestor of itself.)
10:46:36 <dmwit> ShalokShalom: What is the command you run that produces that error?
10:46:45 <ShalokShalom> stack ghci
10:47:21 <dmwit> But the analogous command to ask stack to run ghc works?
10:47:38 <ShalokShalom> yep
10:47:42 <ShalokShalom> I build Eta with it
10:48:06 <ShalokShalom> Hnn, no
10:48:20 <ShalokShalom> No setup information found for ghc-8.6.5 on your platform.This probably means a GHC bindist has not yet been added for OS key 'linux64-ncurses6'.Supported versions: ghc-7.10.3, ghc-8.0.1, ghc-8.0.2, ghc-8.2.1, ghc-8.2.2
10:48:25 <dmwit> Are you running stack ghci from within the directory that you can successfully build Eta?
10:48:26 <ShalokShalom> But why did it build with the script
10:48:38 <ShalokShalom> Eta has another issue, later in the build
10:48:50 <dmwit> Probably because Eta specifies a resolver that uses a different GHC version than 8.6.5, would be my guess.
10:49:01 <ShalokShalom> stack build and stack install works
10:49:04 <ShalokShalom> could be
10:49:15 <ShalokShalom> correct
10:49:26 <ShalokShalom> those two commands in the terminal also show that error
10:50:41 <dmwit> (Therefore, one way forward would be for you to also use a resolver that uses an older GHC.)
10:50:45 <ShalokShalom> So Eta uses another version
10:50:51 <ShalokShalom> I see
10:51:06 <ShalokShalom> I already raised an issue in the stack repo about that
11:14:44 <literall1Crevice> Alright, I'm having a bit of trouble with this. There's this game where there are 25 cards laid out on the table, preferably ordered (in a manner of my choosing) but it's fine if not. Each card has text (unique) and some other properties. I'll need to take a Text and modify/return a new deck of cards that has the card with this text on it but modified slightly. What data structure should I use 
11:14:50 <literall1Crevice> for this and how would I perform the second part, generally?
11:16:59 <phadej> hmm, I remember a paper of encoding SystemF in Haskell, which made a trick to embed forall types
11:17:14 <phadej> does anyone remember what that paper was about
11:17:19 <phadej> my google-fu is failing me
11:20:40 <solonarv> literall1Crevice: the super basic approach is to put them in a list, and just iterate through to produce the new list
11:21:16 <literall1Crevice> solonarv: Isn't there a better approach though? I'd like to imagine there's one at least
11:21:33 <solonarv> like this: newCards = [ if cardText c == chosenText then modify c else c | c <- oldCards ]
11:21:43 <Raylier> Hey does anyone use Emacs here?
11:21:53 <Raylier> (for haskell if that's not clear)
11:21:59 <monochrom> Yes.
11:22:16 <Raylier> Do you use Vanilla or a specific config for Emacs
11:22:17 <solonarv> sure, mostly it boils down to using a different data structure - perhaps a Map, using the card text as a key since it's unique
11:22:30 <monochrom> I use the haskell-mode.
11:22:43 <Raylier> I am new to Emacs, and was wondering what all I need
11:22:51 <monochrom> Very little.
11:23:15 <Raylier> I have haskell mode(I think). Is HSlint helpful?
11:23:24 <Raylier> I am running Doom Emacs right now
11:23:35 <monochrom> I don't know. Never tried, never needed.
11:25:51 <hellp> hello
11:25:58 <learningHaskell> hey guys, i'm learning haskell and trying to create a data type containing a list, but things like data myType = myType (List) don't work - what am i doing wrong?
11:26:32 <hellp> This is a helpful tutorial: http://learnyouahaskell.com/introduction#about-this-tutorial
11:26:53 <monochrom> There is no such thing as "List" in code.
11:27:35 <monochrom> Or rather, there is no such thing called "List" in code.
11:28:16 <hellp> monochrome++
11:31:44 <learningHaskell> ah, okay - so i should just define it recursively like data myType = Empty | Element a (myType a) right?
11:31:45 <phadej> found: http://homepages.inf.ed.ac.uk/slindley/papers/embedding-f.pdf "Embedding F"
11:37:06 <EvanR> [B[B
11:39:06 <EvanR> uhg
11:50:16 <ski> dminuoso, ok
11:54:05 <Raylier> Hey people so I just did a cabal install hlint
11:54:10 <Raylier> Now I am getting this error
11:54:12 <Raylier> Warning: could not create a symlink in /home/ray/.cabal/bin for hlint because
11:54:12 <Raylier> the file exists there already but is not managed by cabal. You can create a
11:54:12 <Raylier> symlink for this executable manually if you wish. The executable file has been
11:54:24 <Raylier> installed at /home/ray/.cabal/bin/hlint
11:55:32 <sclv> sounds like a pretty helpful message to me!
11:56:32 <Raylier> Hi, sorry, I am not sure why symlinks or from what and to what I am supposed to create
11:56:39 <Raylier> I don't know anything about it right now
11:57:33 <EvanR> my theory is that hlint is already installed
11:57:42 <Raylier> Ah
11:57:57 <Raylier> I delted that in .bin and reinstalling it right now
11:58:03 <Raylier> Let it be managed by cable
11:58:13 <EvanR> i hope that was the only file
11:59:06 <Raylier> In .bin?
11:59:37 <Raylier> No, I am guessing hlint pulled in some dependencies
12:00:07 <Raylier> Hmm, I get the same message again
12:00:19 <sclv> so is hlint on your path?
12:00:31 <Raylier> Hmm good catch
12:01:20 <Raylier> Ok added $HOME/.cabal/bin to $path
12:02:44 <Raylier> Doesn't seem to work
12:03:01 <monochrom> Possibly because it should be PATH not path.
12:03:28 <sclv> ok does /home/ray/.cabal/bin/hlint exist, and can you run it explicitly?
12:06:38 <Raylier> monochrom, It was PATH, sorry I typed Incorrectly
12:07:03 <Raylier> sclv, Went to .cabal/bin and ran ./hlint seems to work
12:07:17 <sclv> ok then you just need to fix your path and start a terminal with it
12:07:33 <Raylier> Yep sourced it
12:08:43 <Raylier> hlint seems to work now, but now it's Emacs that can't find it
12:08:45 <Raylier> Hmm
12:09:07 <monochrom> emacs doesn't have the updated PATH
12:09:26 <monochrom> You know how environment variables work and not work, right?
12:10:21 <Raylier> I updated the enviroment variables
12:10:22 <monochrom> But personally I wouldn't even use bother with hlint. Despite the name, it is not analogous (even anti-analogous) to C's lint.
12:11:17 <Athas> Raylier: changing environment variables does not affect any already running process, like your Emacs.
12:11:28 <monochrom> C lint points out objectively questionable code smells. hlint points out subjectively preferential personal coding style that completely doesn't matter.
12:11:28 <Athas> For Emacs specifically, you can update it there with M-x setenv.
12:11:41 <Raylier> I feel bad for looking a noob here
12:11:48 <Raylier> Just bear me with me for a while
12:12:00 <dmwit> Athas: Curious. What does M-x setenv do?
12:12:03 <saml> I'm a bear
12:12:31 <Athas> monochrom: amusingly, I suspect that the only objective qualitative changes hlint makes are for the worse!  (Some of its rewrites change strictness.)
12:12:39 <saml> M-x setenv sets a variable
12:12:45 <Athas> dmwit: sets an environment variable.
12:13:01 <Athas> Like the C function.
12:13:14 <dmwit> Much less magical than I had imagined. Too bad.
12:14:08 <Athas> Well, reading the source, it is more magical than I had expected.  Looks like Emacs has a pretty sophisticated system (well, 200 lines of Lisp) for managing its own idea of an environment, which I guess it then propagates to subprocesses.
12:14:22 <monochrom> Never trust meaningful oh-so-helpful names.  In the days of Apple II, there was a "Beagle Brothers BASIC compiler".  It didn't do what you think.  It did a bytecode thing only.
12:15:46 <Raylier> I have regenerated my envvar file
12:16:19 <Raylier> Still can't find it
12:16:37 <monochrom> Reboot.
12:16:48 <Raylier> no
12:26:10 <dmwit> I don't even know what "regenerated my envvar file" means.
12:27:05 <dmwit> The actions I would imagine taking to update my editor's environment certainly could not be described that way.
12:28:16 <dmwit> (What is "your envvar file", and why should I believe that emacs cares if you change it?)
12:29:51 <monochrom> Also the fine distinction between "currently running processes care" vs "future processes will care".
12:31:51 <monochrom> The reason I brought up the brutal "reboot" is because in lieu of a Unix expert who gets paid to remotely access your computer, take a look around, and come up with a minimal non-disruptive solution that fits your setup, the only reliable fix given almost-zero information is "reboot".
12:33:30 <monochrom> Like, no one even telepathically knows whether it's Linux, Mac, WSL, or Solaris.
12:34:29 <monochrom> Yes I have a ton of students using WSL for my Unix course, despite me advice against it. Anything can happen. You never know you may be talking to someone holding on to a Xenix on a 286.
12:35:36 * boj pokes a stick at a cricket
12:36:02 <monochrom> (Much confusion ensued because WSL still produced files that use \r\n and so the shell scripts they handed in confused the hell out of sh and bash on real Linux.)
12:37:20 <EvanR> i singled handedly fixed the \r\n vs \n problem by starting to use unicode newline character
12:37:29 <monochrom> haha
12:50:50 <Raylier> Sorry I am using a Doom config which gives me a choice to refresh my envvar
12:52:04 <Raylier> Let's ignore stupid editor stuff and so I can learn some real haskell
12:52:18 <Raylier> (in the best way possible)
12:52:20 <Raylier> :)
12:52:28 <Raylier> (sorry didn't mean to sound like a dick)
12:53:20 <EvanR> agreed
13:26:39 <duncan> In Haskell-mode for Emacs, is there a command for inserting a comment enclosed by {- -} or {-# #-} etc?
13:29:54 <dada_cetacean> what's the idiomatic way to write `foldr op (f x) (f xs)`?
13:30:58 <EvanR> that looks good to me
13:31:22 <EvanR> the alternatives may serve to incriminate you
13:31:50 <lavalike> how does f apply both to x and xs
13:32:17 <dada_cetacean> oops, i meant foldr op (f x) (map f xs)
13:32:30 <EvanR> oh, well then you can use foldr1 
13:32:40 <dada_cetacean> i was wondering if there was a 5 character applicative cryptogram for doing this
13:32:46 <EvanR> :t foldr1
13:32:49 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
13:32:56 <EvanR> foldr1 op xs
13:33:18 <EvanR> foldr1 op (map f (x:xs))
13:33:41 <lavalike> :t foldMap -- if f turns the items into a monoid
13:33:45 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:34:23 <ryandv> suppose we have `newtype Identity a = Identity a`. from an algebraic data types/type theory perspective, could this be considered a product type? in particular, the product of the type variable `a` with the unit type?
13:34:31 <ryandv> sorry if this question is way off base, not great at type theory
13:34:48 <dada_cetacean> thanks, those are helpful
13:36:00 <infinisil> ryandv: Well there's no unit type anywhere here
13:36:25 <infinisil> ryandv: The only way this can be considered a product type (I think) is as a one-dimensional one
13:36:29 <infinisil> Like a 1-tuple
13:36:53 <infinisil> But I guess that's no real product type
13:37:44 <ryandv> infinisil: I guess by product type I meant whatever the identity is for product-ing types together. I was thinking it was also something like a 1-tuple, which is vacuously a product type (?)
13:38:02 <lavalike> without getting too deep isn't a product with a unit going to give you something that is equal to what you put in, by definition
13:38:07 <ryandv> what about something like `newtype Wrapper a = Wrapper a String`? Is this now a product of `a * String`?
13:38:22 <ryandv> lavalike: yeah, I was using unit in that sense
13:38:48 <infinisil> ryandv: Yeah that one for sure is a product type
13:39:04 <dmwit> :t \op f x xs -> foldr op (f x) (map f xs)
13:39:06 <lambdabot> (a -> a -> a) -> (t -> a) -> t -> [t] -> a
13:39:40 <infinisil> ryandv: I'd say `Identity a` is isomorphic to a product between `a` and `()`, but not the same
13:40:01 <dmwit> :t \op f x xs -> foldr (op . f) xs -- dada_cetacean 
13:40:02 <infinisil> I'm no great category theorist though, so don't rely on what I say
13:40:03 <lambdabot> Foldable t => (b1 -> b2 -> b2) -> (a -> b1) -> p -> b2 -> t a -> b2
13:40:10 <dmwit> err... no
13:41:38 <ryandv> infinisil: in which case could I use distributivity to deduce the following? let's say we have a union, `data U = A | B | C`. now `Wrapper U = Wrapper U String = Wrapper (A | B | C) String` could be considered the product `(A + B + C) * String`, which by distributivity is the same as `(A * String) + (B * String) + (C * String)`, correct?
13:41:39 <dmwit> :t \op f x xs -> foldr (op . f) (f x) xs -- dada_cetacean, corrected
13:41:42 <lambdabot> Foldable t => (b -> b -> b) -> (a -> b) -> a -> t a -> b
13:41:43 <lavalike> :t \op f -> foldr (op `on` f)
13:41:50 <lambdabot> Foldable t => (b -> b -> a) -> (a -> b) -> a -> t a -> a
13:42:22 <ryandv> and so `Wrapper U = Wrapper A | Wrapper B | Wrapper C`?
13:42:53 <infinisil> ryandv: I think it should be `Wrapper = Wrapper U String = Wrapper (A | B | C) String`
13:43:02 <infinisil> Because U isn't a type argument, but a type itself
13:43:43 <ryandv> infinisil: sorry yes, that sounds correct to me
13:43:48 <dmwit> ryandv: I think `A * String` is mixing up levels. `A` is a computation, not a type.
13:44:15 <dmwit> ryandv: Similar objections apply to your `Wrapper A` and infinisil's `Wrapper (A | B | C)`.
13:44:59 <dmwit> ryandv: (Perhaps you wanted `data U = MkA A | MkB B | MkC C`?)
13:45:29 <dmwit> (Better names than `MkA` could be chosen. Perhaps `UofA`, `UofB`, `UofC`.)
13:46:12 <ryandv> dmwit: I suppose so? I'm not really familiar with that pattern. I do see what you're saying in that the particular variants of the union (the data constructors) are not really on the type-level (I think?)
13:46:41 <dmwit> Right. There is no type whose only inhabitant is the constructor `A`.
13:46:52 <dmwit> We can of course make a type that is isomorphic to such a hypothetical one.
13:47:10 <dmwit> Or we could imagine working in a different type system than Haskell's, so that we could introduce such a type.
13:47:39 <dmwit> But if we're going to do that we should agree on a syntax that makes it clear when you're making that switch between computation and type levels. =)
13:48:48 <ryandv> ok. I suppose ultimately what I was wondering is that, if I have a newtype wrapper around a union/sum type, is that somehow equivalent to a union of newtype wrappers? (I may be mixing up levels again here - maybe `MkA A` is what I'm thinking? But I don't know what that actually means)
13:49:28 <dmwit> I think you'll have to say what you mean by "equivalent".
13:49:34 <dmwit> There's a couple sensible choices.
13:50:14 <dmwit> One would be alpha equivalence; another might be the existence of an isomorphism between them.
13:51:33 <ryandv> um, I guess alpha equivalence? where I can substitute one type for the other & everything still typechecks
13:51:46 <dmwit> As for your "I don't know what `MkA A` means": `data U = UofA A | UofB B | UofC C` says that `U` is a tagged union of the (presumably already-existing) types `A`, `B`, and `C`, with `UofA` etc. being the value-level tags. Meanwhile `data U = A | B | C` says that `U` is a type with just three inhabitants, the literal values `A`, `B`, and `C`.
13:52:16 <dmwit> ryandv: No, a newtype wrapper around a sum type is not alpha equivalent to that sum type with newtype wrappers in it instead.
13:53:38 <dmwit> ryandv: e.g. Identity (Either Int Bool) is not the same type, as far as Haskell's type-checker is concerned, as Either (Identity Int) (Identity Bool).
13:53:53 <dmwit> (They are definitely isomorphic types, though.)
13:55:26 <ryandv> dmwit: ok, this was immensely helpful. thanks for walking through that with me =) the Identity/Either example was very useful
13:56:24 <ski> ryandv,infinisil : the `=' in `newtype Wrapper a = Wrapper a String' and `data U = A | B | C' does not mean "equals". the notation is inspired by BNF. one could perhaps read `=' as "consists of" or "can be (one of)"
13:57:02 * ski idly wonders whether ryandv,infinisil are, at least a little bit, familiar with BNF notation for grammars
13:57:07 <ryandv> yes, I was crossing wires there... I guess it's almost more like `:=`
13:57:22 <ski> (if not, you can probably ignore that comparision)
13:57:25 <infinisil> ski: I am :)
13:57:45 <infinisil> But yeah that's a good clarification
13:57:46 <ryandv> superficially aware at least
13:57:51 <ryandv> (me)
13:58:03 <infinisil> "=" is too easily misused
13:58:15 <ski> if you say
13:58:22 <ski>   data Person = MkPerson Name Age
13:58:50 <ski> then the `MkPerson Name Age' part here is a (shorthand) "template", that says what this form of value, of type `Person' can look like
13:59:09 <ski> it means that if `x' has type `Name', and `y' has type `Age', then `MkPerson x y' has type `Person'
13:59:17 <ski> if you say
13:59:24 <ski>   data IntTree = Leaf Int
13:59:36 <ski>                Branch IntTree IntTree
13:59:47 <ski> (er, missing a `|' just before `Branch')
14:00:30 <infinisil> ski: Oh, I think I finally understand what's up with GADT's
14:00:31 <ski> then this is saying that values of type `IntTree' can be of two alternative forms, (a) `Leaf n', where `n :: Int'; or (b) `Branch l r', where `l,r :: IntTree'
14:00:37 <eacameron> Is there a searchable history of this channel? Someone sent me a link to a sample of uniqueness types via indexed monads last week and I forgot to save the link... :(
14:01:14 <infinisil> eacameron: /topic
14:01:27 <infinisil> Ah
14:01:29 <infinisil> Not searchable
14:02:25 <ski> infinisil,ryandv : you can think of `Person',`Name',`Age',`IntTree',`Int' here, roughly as "nonterminals" in a grammar
14:02:46 <dmwit> eacameron: https://gist.github.com/Lysxia/6be7bd107e2b5863140acaa7556aa3a1
14:02:56 <ski> while i suppose `MkPerson',`Leaf',`Branch' could be sortof thought of as "terminals"
14:03:03 <eacameron> dmwit: Aha! Thank you so much!
14:03:26 <ski> however, the `data' (and `newtype') notation specifies *trees*, not sequences
14:04:16 <infinisil> eacameron: No logs in your irc client?
14:04:59 <eacameron> infinisil: Hm... I didn't realize irccloud lets me download the logs. So...YES :D
14:06:03 <infinisil> Man, Haskell sure is nice with purity and everything. I'm a bit sad that I have to use mutable arrays with my current project
14:06:32 <EvanR> why do you have to? performance?
14:06:33 <eacameron> The use case we encountered was the need to take a lock and fork a thread which would then take ownership of that lock. If we failed to fork a thread, we should of course keep ownership and unlock it ourselves.
14:07:23 <infinisil> EvanR: Yeah, it's like an 8kb array that gets modified like 10000 or more times (the more the better)
14:07:53 <infinisil> Can run up to 1'000'000 times right now in a minute or so
14:08:01 <eacameron> So simple bracketing was not sufficient. We needed first-class ownership
14:08:21 <EvanR> i'm always interesting in haskell performance on intense mutable array 
14:08:29 <EvanR> interested
14:10:55 <infinisil> Right now the most problematic thing for performance is polysemy hehe
14:12:04 <EvanR> but it says zero-cost on the tin
14:12:32 <infinisil> Yeah, but unfortunately that's only with GHC >= 8.9
14:12:48 <dmj`> haskell projects say a lot of things 
14:12:52 <infinisil> Yeah
14:13:00 <infinisil> I don't fully trust it yet either
14:13:19 <infinisil> Especially how it claims being zero-cost already, even though nobody uses 8.9 yet
14:15:31 <infinisil> I might have to switch to fused-effects eventually if more perf is needed
14:15:50 <dmj`> is perf really needed though
14:16:44 <infinisil> Yeah definitely
14:18:25 <infinisil> Well it's finite computations. So I could just let my computer run 10 times longer or so, but I'd rather not, because I might have to run this a whole bunch of times :)
14:25:24 <infinisil> Oh neat, I just updated my dependencies, including polysemy from 0.3 to 0.7 and this sped up my program by like 40%
14:25:39 <infinisil> I'll take it
14:25:55 <EvanR> i love it when performance is proportional to version
14:26:01 <EvanR> not inversely
14:26:23 <infinisil> Hehe yeah
14:27:30 <EvanR> if you update both ghc and the lib, improvement becomes quadratic
14:28:08 <infinisil> Oh I could try the 8.8.1 rc
14:28:22 <infinisil> The latest one
15:00:11 <infinisil> EvanR: dmj`: This might interest you: https://github.com/polysemy-research/polysemy/issues/184
17:41:50 <orzo> if i cut and paste the exact same data declaration into a different module with the same set of language extensions enabled, and import them both, can the compiler infer Coercible?
17:42:38 <c_wraith> no, Coercible instances only exist for things that are the same type or differ only by newtypes.
17:43:08 <c_wraith> (with appropriate consideration of roles)
17:43:22 <orzo> would it break anything if that changed?
17:46:21 <orzo> since coercible lets the programmer avoid run-time costs, it seems like it would be benificial for the compiler to be as liberal with it as it could get away with
17:46:58 <c_wraith> as you point out though, flags can impact how types are compiled.
17:47:58 <c_wraith> it would introduce a new kind of case where something could suddenly fail to compile based on flag changes, despite types not changing.
17:50:11 <orzo> well, the programmer essentially opted-in to that issue when he used coercible on non newtypes
17:50:42 <c_wraith> but it's a new kind of failure. why introduce a new way for programs to fail to compile?
17:51:42 <orzo> failing to compile is usually helpful
17:51:46 <dmwit> Should `data Bool = False | True` and `data Strategy = Keep | Elide` be coercible?
17:52:19 <dmwit> (And why?)
17:52:46 <c_wraith> the thing is, whether it fails or not has nothing to do with correctness
17:53:05 <c_wraith> *that's* what's new and not worth doing.
17:53:57 <orzo> iduno id it's worth doin, but if it's trivial, it has benifits and is thus worth doing
17:54:29 <dmwit> I find "I don't know if it's worth doing" and "it has benefits and is thus worth doing" a strange pair of utterances to put together at once.
17:54:29 <orzo> benefit = annotating zero cost coercians exactly the same as the benifit of inteoducig Coercible for newtypes
17:54:45 <orzo> i said "if it's trivial"
17:54:55 <dmwit> Good point.
17:55:04 <orzo> to implement and maintain
17:55:12 <dmwit> I'm still curious about what you think of my `Bool`/`Strategy` question.
17:55:24 <orzo> i think yes to that
17:55:25 <c_wraith> I think introducing *uncertainty* into type checking is a new and very dangerous precedent
17:55:36 <orzo> but maybe it should require a language pragma
17:58:39 <orzo> i'm not sure you're objection is not some kind of conservative bias, c_wraith.  If you try to formally specify what is bad and new about this, i think you'll have trouble
18:00:11 <c_wraith> non-locality.
18:01:09 <c_wraith> you can break code with zero source changes, and the compiler flags for the module that fails to compile not changing
18:01:25 <c_wraith> this is a situation that does not currently exist.
18:02:25 <pyan> The language shouldn't expose its implementation details too much.
18:02:29 <jackdk> I can do that today with CPP
18:02:56 <pyan> newtype is kind of an exception, because it's already specified to be a mere syntactic wrapper with no runtime representation.
18:03:53 <c_wraith> jackdk, can you do it without CPP changing the code that ghc sees?
18:04:41 <orzo> what's changing, c_wraith, the compiler?  Code breaks when we change compiler and nothing else all the time in practice
18:05:33 <c_wraith> orzo, compiler *flags*. turn off unpacking of strict small fields in a module, or something.
18:05:51 <jackdk> no. the example I was thinking of was being asked to conditionally do MonadFail fiddling depending on MIN_VERSION_base, to avoid bumping versions on hackage. I declined to do this
18:06:06 <orzo> okay, well, flags changes can obviously cause code to fail to compile also
18:06:19 <c_wraith> orzo, at the moment, only locally.
18:06:37 <c_wraith> orzo, you're asking for non-locality to be introduced.
18:07:09 <jackdk> my point is it's not a flag change. I change no source, cabal finds a different version of the package and GHC gets nonsense
18:07:26 <c_wraith> jackdk, CPP is changing the source.
18:07:58 <c_wraith> that's why it's there, but that makes it different from what I'm talking about.
18:08:44 <jackdk> ok
18:11:39 <orzo> c_wraith: is a deprecated pragma or really any non-compatible change to a library api considered non-locality?
18:21:10 <dmwit> Okay, I have a real objection.
18:21:20 <dmwit> Currently we can use pattern synonyms to fake an interface.
18:21:43 <dmwit> If you allow Coercible to know the difference between pattern synonyms and real constructors, you can use that to pierce abstraction boundaries.
18:21:49 <dmwit> That seems pretty dodgy to me.
18:24:05 <orzo> but that barrier is already pierced by explicit import/export lists
18:24:23 <dmwit> Really? How?
18:25:08 <orzo> the user has to know it's a patten synonym to import it properly
18:25:14 <dmwit> That is not correct.
18:26:05 <orzo> import Mod ( Foo(C) ) -- wont work on patten C
18:26:16 <orzo> afaik
18:26:18 <dmwit> Correct. It also works if C is a constructor of Foo.
18:26:26 <dmwit> That is: you use the same syntax for constructors and patterns.
18:26:32 <orzo> no, i said wont
18:26:49 <dmwit> Okay, then you are incorrect.
18:27:10 <dmwit> (Try it yourself and see!)
18:27:20 <orzo> i will
18:28:59 <orzo> main.hs:1:13: error: Module ‘Mod’ does not export ‘Foo(C)’
18:29:32 <orzo> my attempt confirmed my current understanding
18:29:37 <orzo> should i paste somewhere?
18:30:49 <orzo> dmwit: are you sure? maybe you should try too
18:31:41 <dmwit> https://gist.github.com/dmwit/dfcfda7cb79a14a9ed8084dae61df311
18:31:44 <dmwit> very sure
18:32:16 <orzo> thats exactly what i have as far as i can tell
18:32:19 <orzo> what ghc version?
18:32:26 <orzo> i'm using 8.4.4
18:32:48 <dmwit> Tried in 8.2.2, 8.4.3, 8.6.5, all the versions I have installed on this machine.
18:32:59 <dmwit> But it should work as far back as PatternSynonyms is supported.
18:33:03 <dmwit> Perhaps you'd better paste after all.
18:34:22 <dmwit> My guess is you did not export your pattern synonym.
18:35:09 <dmwit> e.g. by writing your analog of Foo(..) in the export list, or by not writing an export list.
18:36:32 <orzo> https://glot.io/snippets/fed8iiay62
18:36:46 * dmwit called it
18:37:21 <dmwit> `module Mod (Foo(C)) where` will fix it.
18:37:22 <orzo> i dont see
18:37:50 <orzo> you need an explicit export to enable this?
18:38:51 <orzo> you are right it works with that
18:39:09 <monochrom> Or "module Mod where" export everything
18:39:15 <orzo> i have some code where i used pattensyms that i should update heh
18:39:35 <orzo> no, monochrom, that's what i had initially
18:40:01 <dmwit> It seems you need an explicit export. I don't understand why. Perhaps it is a bug.
18:40:49 <orzo> i've noticed haddock distinguishes patterns and constructors.  With this style of explicit export though, maybe it does not?
18:42:38 <dmwit> I believe it is possible to request that haddock not distinguish your pattern synonym. Perhaps this explicit export mechanism is the way; I don't know.
18:43:01 <dmwit> https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms/associating-synonyms has some details on how the export stuff works, but not a lot of rationale.
18:43:32 <pyan> Is it possible to export pattern synonyms without exporting whatever they stand for?
18:44:43 <dmwit> Yes. That is sort of their whole point.
18:45:22 <monochrom> I cannot reproduce.
18:45:40 <dmwit> What thing can you not reproduce, specifically?
18:46:08 <monochrom> {-# LANGUAGE PatternSynonyms #-} module M where { data Foo = Foo; pattern C = Foo }
18:46:17 <monochrom> module N where { import M; f C = 0 }
18:46:28 <orzo> what ghc ver, monochrome?
18:46:33 <dmwit> monochrom: Yes, but: module N where import M (Foo (C)) -- is an error
18:46:37 <monochrom> "ghci N.hs" works, testing "f C" and "f Foo" work, no error.  8.6.3
18:46:46 <monochrom> Oh, that.
18:46:52 <dmwit> monochrom: And my claim at the beginning was that the writer of M could make it transparent to N whether C was a pattern or a real constructor.
18:47:17 <dmwit> monochrom: (Your M doesn't, but a suitably modified M should.)
18:51:55 <dmwit> (...and further that because the goal of pattern synonyms is to enable that feature, it would be bad to allow coerce to convert between two data types declared in separate modules with the same text, because this would allow from outside for one to detect whether a given pattern was a synonym or a true constructor.)
18:57:14 <orzo> i dont think that's the only goal of patten syms, i've used them and wasnt even aware i could do this
18:57:38 <c_wraith> hiding representation changes was absolutely an intended use
18:58:14 <orzo> well, i mean, it was still useful even if it didnt hide it from the import/export lists
18:59:34 <c_wraith> if changing  name from a constructor to a pattern requires importing it differently, it's not hiding the change very well.
19:00:19 <orzo> it's letting use-sites be oblivious
19:01:24 <orzo> similar to the usefulness of distinct library modules exporting the same interface
19:01:37 <orzo> allowing you to change only the import list to switch implementation
19:05:39 <orzo> it's a real cost to the generalized coercible extension, but in practice this abstraction-peircing is restricted to a pretty peticular case where the user is using Coercible in a particular and fragile way and probably wouldn't be very significant in practice
19:13:55 <orzo> I've an idea to get most of the benefit of my proposal without the cost that dmwit pointed out.  Data.Data could export a function to convert equivalent types, but the function could also act as a hint to the compiler to attempt opportunistic costless run-time coercion.
19:14:59 <orzo> it'd not work on lambdas or on types that happen not to provide a Data instance
19:15:12 <orzo> but otherwise, it does the job
20:28:32 <hatds> Am I crazy or is "getLazyByteString" from Data.Binary.Get not lazy at all.  https://pastebin.com/ZzHXMkps  I guess I was supposed to know that intuitively?  Also, the paste is a toy example that mimics what the riff library on hackage is doing under the hood.  It seems like the package author thought that 'getLazyByteString' was lazy too.
20:33:38 <himekami> hallo
20:37:38 <himekami> anyone can point me to how/where should i learn about "state transformer"? or any transformer for that matter. Thanx
20:39:42 <hatds> himekami: perhaps this blog post? http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html  although I haven't read it in a while
20:40:33 <himekami> thanx hatds.. gonna check it out now
20:48:00 <dmwit> himekami: I liked this one:
20:48:02 <dmwit> ?where aam
20:48:02 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
20:50:36 <Vikfret> fight me lambdabot
20:52:30 <dmwit> ?slap Vikfret
20:52:30 * lambdabot karate-chops Vikfret into two equally sized halves
20:52:30 <himekami> lambdabot, i have checked that out many times over. couldnt wrap my head around it
20:55:14 <himekami> lambdabot, gimme another
20:59:05 * lambdabot shakes head
21:00:00 <zeta_0> hello guys, i am currently learning category theory, i cannot find a good definition on what `covariant` and `contravariant` mean in terms of `category theory`, could you guys give my literal translations for `co`, `contra`, and `variant` and how they are used in category theory?
21:01:36 <pyan> zeta_0: “covariant” means “preserves the direction of the arrows”, and “contravariant” means “reverses the direction of the arrows”
21:01:54 <ski> "covariant" here means "varies in the same direction", while "contravariant" means "varies in the opposite direction"
21:03:00 <ski> say `C',`D' are categories, `A',`B' are objects of `C', and `f : A >---> B' is a morphism of `C'
21:03:33 <ski> if `F' is a (covariant) functor from `C' to `D', then `F f : F A >---> F B'
21:04:04 <ski> if `F' is a contravariant functor from `C' to `D', then `F f : F B >---> F A', or, if you prefer, `F f : F A <---< F B'
21:05:22 <ski> so, if `F' is a covariant functor, then applying it to a morphism preserves the direction, in the sense that if the morphism (in `C') goes from `A' to `B', then applying the functor to the morphism will be a morphism (in `D') that goes from `F A' to `F B'
21:05:58 <ski> while if `F' is a contravariant functor, then applying it to a morphism reverses the direction, in the sense that if the morphism (in `C') goes from `A' to `B', then applying the functor to the morphism will be a morphism (in `D') that goes *to* `F A' *from* `F B'
21:08:13 <ski> (btw, note that this use of "co-" is not directly related to the "co-" that is used in "coproduct","coequalizer","colimit","cocone","comonad","comonoid",&c. .. there is no "cofunctor")
21:08:48 <ski> now, if `F' is a (covariant) functor from `C' to `D', we write `F : C >---> D'
21:10:13 <ski> while, if `F' is a contravariant functor from `C' to `D', it corresponds exactly to a *covariant* functor from `C^op' to `D' (or, if preferred, from `C' to `D^op'). if we write this functor as `F^', then we'd have `F^ : C^op >---> D'
21:12:54 <Zer000> for fun I decided to see if my project compiles with the llvm backend. It's saying it can't execute opt and to make sure I have LLVM 6.0 installed. opt --version gives "LLVM version 6.0.1" though, as someone who doens't use llvm normally I'm not sure what to do about this
21:12:56 <zeta_0> i got disconnect for some reason anyways:
21:15:06 <zeta_0> literal translations: `co` means `preserve`, `contra` means `reverse` right? and what is the literal translation for `variant` in terms of category theory?
21:16:24 <zeta_0> i am very visual so i am following along these lectures: https://www.youtube.com/user/DrBartosz/playlists
21:16:28 <ski> perhaps "direction of variation", in that case ?
21:16:35 <ski> zeta_0 : see PM
21:17:36 <pyan> zeta_0: the trouble is that “co” means several things
21:18:36 <zeta_0> he mentions `covariant` and `contravariant` a few times, but when i search for definitions, it gives me them for other branches of mathematics but not anything specific for category theory?
21:20:14 <zeta_0> if i understand correctly, `contra` means reverse and `co` means `preserve`, in terms of category theory that is?
21:21:42 * ski idly wonders whether zeta_0 wants to answer
21:27:30 <zeta_0> so: `contra-variance reverses composition` and `covariance turns the morphisms around(opposite)? is this correct?
21:27:41 <zeta_0> https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance
21:28:11 <zeta_0> i'm confused
21:28:14 <zeta_0> :(
21:28:22 <ski> no
21:29:48 <ski> "contravariant functors reverses arrow direction, and (therefore) reverses composition"
21:30:05 <ski> "covariant functors preserves arrow direction, and (therefore) preserves composition"
21:30:30 <MarcelineVQ> zeta_0: I disconnected in the middle of this convo but the start of it ski seemed to lay out exactly what these things meant :X in case you dc'd and missed it: https://gist.github.com/MarcelineVQ/ba8cf604628cc049cc03129b22e708a1
21:30:55 <ski> MarcelineVQ : i already PMed zeta_0 about it, but they haven't responded ..
21:30:59 <MarcelineVQ> oh okay
21:31:26 <zeta_0> oh
21:31:33 <zeta_0> thanks
21:32:01 * ski idly wonders whether zeta_0 has them on ignore or something
21:32:26 <zeta_0> ski: what?
21:32:40 <ski> you haven't answered my PM
21:33:36 <zeta_0> ski: PM? sorry i am still pretty new to irc.
21:33:51 <ski> "Private Message"
21:34:23 <zeta_0> oh ok, one second !!!
21:34:23 * ski doesn't know how rcirc handles this, if it opens a new buffer, and in that case, if it displays it in a window or not
21:35:31 <zeta_0> ski: well i exited emacs and then came back and signed into rcirc, i am not sure if the pm is saved, so how do i check?
21:36:10 <pyan> what is your client?
21:36:12 <ski> i PMed you after you reconnected
21:36:16 <ski> pyan : rcirc
21:36:19 <pyan> oh
21:37:05 <pyan> This seems to be an Emacs client, so plain cycling through buffers should work.
21:37:14 <ski> zeta_0 : i'd *guess* that perhaps rcirc made a new buffer whose name contains "ski" ?
21:38:26 <zeta_0> ski: ok, i found the buffer with the PM
21:38:30 <ski> (or maybe rcirc handles all interaction in a single buffer ? or maybe there's a "server buffer" where PMs also get sent, unless you open a separate "query" buffer with someone .. i'm just guessing)
21:38:34 <ski> ok
21:39:47 <pyan> Anyhow. Are there any interesting uses of several categories and functors between them in Haskell, rather than just Hask -> Hask endofunctors? I get that this is not to easy, given the forceful separation of type-land and value-land, but still...
21:40:47 <ski> pyan : you can have functors from `{f :: * -> * | Functor f}' to `*', e.g.
21:41:22 <zeta_0> ski: what do you mean by `preserve` for covariant, keep arrows the same(static)?
21:42:18 <pyan> zeta_0: It means that if you have some object A and B (needn't be types), and some arrow f : A -> B (needn't be a function), then the functor maps f to some arrow F(f) : F(A) -> F(B) in the same direction as the original arrow f.
21:42:51 <pyan> zeta_0: A contravariant functor instead would give you an arrow F(f) : F(B) -> F(A).
21:44:41 <zeta_0> thanks, i think i need to re-watch the video by bartosz milewski on these topics. that guy explains things in a way that i can understand.
21:44:57 <zeta_0> where did you guys learn category theory?
21:46:07 <pyan> ski: Mmm. I was expecting something that *doesn't* live in type-land. Because, by http://math.andrej.com/2012/03/30/the-topology-of-the-set-of-all-types-2/ , the type language is very sterile, if you are seriously committed to not doing things that allow you to distinguish between isomorphic types.
21:46:47 <pyan> zeta_0: I thought I learnt it by using Haskell, but then I actually learnt it by studying algebraic topology.
21:47:23 <pyan> (Yeah, knowing category theory is not really necessary for using Haskell.)
21:47:36 <ski> zeta_0 : see PM
21:49:02 <zeta_0> pyan: well, haskell never made sense before, but after learning a little bit of category theory and lambda calculus it makes a lot more sense
21:49:27 <zeta_0> pyan: does category theory use algebraic topology?
21:49:45 <pyan> More like the other way around. When studying algebraic topology, category theory helps.
21:50:42 * ski borrowed various CT books at the library
21:51:09 <ski> (and read some papers, like by the ADJ group, e.g.)
21:51:31 <pyan> zeta_0: The best way to learn something is to have an actual use case. Say, write an interpreter for a toy language.
21:53:01 <pyan> zeta_0: Incidentally, the same remark also applies to category theory: Haskell didn't give me much of a use case for category theory. Algebraic topology did.
21:53:30 <zeta_0> i thought category theory is the most abstract branch of mathematics(a universal language), so you are standing on mt. everest looking with a birds eye view of the structure of all the other areas of mathematics?
21:53:54 <c_wraith> another way of saying "most abstract" is "least useful" :)
21:53:59 <pyan> lol
21:55:16 <ski> pyan : *nod* (i've seen that paper before). were you thinking more of say finitely presented categories, with objects and morphisms being Haskell values ?
21:55:52 <ski> (such as the book "Computational Category Theory" by Rydeheard & someone develops, in SML)
21:56:03 <pyan> Yeah.
21:56:09 <pyan> Will check that book.
21:56:54 <ski> David E. Rydeheard, Rod M. Burstall, 1998
21:57:52 <ski> (there's also a "Categories and computer science" by R. F. C. Walters in 1991, that i found interesting)
21:59:17 <ski> (and there's a book "Categories for Software Engineering" by José L. Fiadeiro in 2004)
21:59:42 <zeta_0> categories for the working mathematician is the original but i hear it is hard to understand, i am pretty good at math but still struggle with proofs
22:00:41 * ski . o O ( "An introduction to Category Theory for Software Engineers" (slides) by Steve Easterbrook in 1999 at <https://www.cs.toronto.edu/~sme/presentations/cat101.pdf> )
22:01:51 <ski> zeta_0 : "Conceptual Mathematics: A First Introduction to Categories" by William ("Bill") F. Lawvere,Steven Schanuel is a quite slow-going book, which doesn't assume much math knowledge
22:01:57 <pyan> ski: Yeah, given a category with a finite presentation, it would be nice, say, to automatically compute limits and colimits, and so on.
22:01:58 <pyan> zeta_0: It is not a book for someone who hasn't gone through, at the very least, the undergraduate mathematics curriculum.
22:04:52 <pyan> ski: Thanks for the references, by the way!
22:07:01 <zeta_0> well i am self taught, so i am learning from home(internet), it's hard to gauge my skills, i passed calculus 2 about 4 years ago so my math skills have improved a lot since then (proofs are my weakness still)
22:08:57 <Zer000> zeta_0, I'd recommend this book, it uses haskell for examples https://www.blurb.com/b/9008339-category-theory-for-programmers
22:09:49 <zeta_0> thanks, i'll take a look
22:10:07 <ski> yea, that's Milewski
22:10:15 * ski hasn't checked it out
22:10:23 <ski> @where CTFP
22:10:23 <lambdabot> "Category Theory for Programmers" by Bartosz Milewski in 2018-10-21 at <https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>,<https://github.com/hmemcpy/milewski-ctfp-
22:10:23 <lambdabot> pdf>
22:11:17 <zeta_0> Zer000: when i finish watching bartosz milewski's youtube videos, i'll check that book out
22:12:23 <zeta_0> i'm currently at monads: https://www.youtube.com/watch?v=gHiyzctYqZ0&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_&index=19
22:12:58 <ski> "Basic Category Theory for Computer Scientists" by Benjamin C. Pierce in 1991 is a rather thin book
22:13:19 <Zer000> ohya having a pirate explain category theory is great
22:13:30 <ski> "Categories, Types, and Structures : An Introduction to Category Theory for the Working Computer Scientist" by Andrea Asperti,Giuseppe Longo in 1991 has more meat
22:13:31 <zeta_0> is algebraic topology actually useful for haskell? how?
22:13:51 <pyan> zeta_0: Not really.
22:13:54 <ski> probably not that much, no
22:14:22 <jusss> “monads do not compose.” this is right or wrong?
22:14:37 <jusss> from here https://blog.tmorris.net/posts/monads-do-not-compose/
22:14:54 <pyan> jusss: The (functor) composition of two monads need not be a monad again.
22:14:59 <sicklorkin> Just found some interesting code that took a while to find.. Consider what kinda horror this might cause.. flip (maybe (return Nothing)) (Just (-2)) $ \n-> do guard (n >= 0) >> return Nothing
22:15:05 <zeta_0> pyan: why did you tell me to learn algebraic topology then?
22:15:20 * sicklorkin plans a shaming sessions tmrw
22:15:21 <pyan> zeta_0: I did not tell you to learn algebraic topology.
22:15:41 <pyan> zeta_0: I said that algebraic topology gave *me* an actual use case for category theory.
22:15:48 <jusss> pyan: is that composeM ?
22:16:02 <pyan> jusss: I cannot make heads or tails of Scala code, sorry.
22:16:13 <jusss> pyan: and in haskell?
22:16:15 <zeta_0> pyan: oh, my bad
22:18:18 <zeta_0> so people basically translate structures from category theory into haskell right, these terms such as object, morphism, fuctor, monad, make a lot more sense now after studying category theory
22:18:49 <ski> sicklorkin : seems relatively straightforward ?
22:19:17 <jusss> composeM :: (a->m b) -> (x-> m a) -> (x -> m b)
22:19:54 <sicklorkin> ski: under extreme circumstances it was killing the program.. it took a while to find..
22:20:28 <ski> sicklorkin : well, it depends on which alternative idiom you're using there ..
22:20:29 <sicklorkin> ski: IOException of type UserError
22:20:56 <ski> yea .. i don't really recommend using the `Alternative' or `MonadPlus' instances of `IO'
22:21:14 <zeta_0> so what are all the maths that are fundamentally(1st principles) to haskell? i am currently learning lambda calculus and category theory?
22:21:15 <pyan> Wait, what do IO's Alternative and MonadPlus instances do?
22:21:21 <pyan> Swallow the exception and try the next thing?
22:21:26 <ski> yes :/
22:21:29 <pyan> That is awful.
22:21:31 <ski> indeed
22:21:34 <sicklorkin> ski: yeah. i'll add it to the list of 'what-not-to-do'
22:24:00 <ski> @type (<=<)  -- jusss
22:24:02 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
22:24:36 <jusss> ski: can we say kleisli composition is used for compose Monads?
22:24:58 <ski> jneira : and that's not what pyan was talking about, with "The (functor) composition of two monads need not be a monad again.", no. this `(<=<)' is Kleisli composition
22:25:02 <pyan> jusss: No.
22:25:03 <ski> jneira : no
22:25:09 <ski> er, jusss ^
22:25:13 <pyan> Poor jneira, wrongly tagged.
22:25:16 <ski> jneira : sorry
22:25:48 <jusss> pyan: ski what's proper way to describe what kleisli composition is used for?
22:26:15 <ski> Kleisli composition is used to define composition of *morphisms* (not monads) in the Kleisli catagory of a monad, say `T'
22:27:48 <ski> note that e.g. `getLine' (of type `IO String') is not a monad. it's a monadic action, an `IO'-action. `IO' itself (together with its implementation of `return' and `(>>=)', satisfying the laws) is a monad
22:28:34 <ski> you don't pass around monads like `IO' at run-time in Haskell. `IO' is a type-level thing
22:28:50 <ski> what you do pass around is monadic *actions*
22:29:06 <ski> and `(<=<)' composes functions whose results are monadic actions
22:29:27 <zeta_0> ski: thanks for the covariant and contravariant explanation, it makes a little bit more sense now
22:32:18 <ski> (i could try to explain what the Kleisli category of a monad is, but i suspect it would be better if you first would got basics a bit more firm)
22:32:28 <jusss> ski: so what's 'compose monad' look like in haskell? 
22:32:49 <ski> what do you mean by that ?
22:33:17 <jusss> 'cause "Monads do not compose" I wonder if monads can do compose?
22:33:20 <ski> <jusss> “monads do not compose.” this is right or wrong?  <jusss> from here https://blog.tmorris.net/posts/monads-do-not-compose/
22:33:23 <ski> <pyan> jusss: The (functor) composition of two monads need not be a monad again.
22:33:50 <jusss> ski: yeah, what this monad look like for compose monad
22:34:00 <jusss> what its type
22:34:07 <ski> if you define `newtype Compose f g a = MkCompose (f (g a))', then even if `Monad m' and `Monad n', `Monad (Compose m n)' needn't hold
22:34:35 <ski> iow, `Compose m n' is not a monad (in general), even if both `m' and `n' are monads
22:34:48 <ski> so, i don't know what you mean by "compose monad"
22:35:53 * glguy has an Agda proof showing there can be no general way to implement Monad on Compose in terms of the underlying Monad instances
22:36:19 <ski> (and asking for the type of a monad, doesn't seem to make sense to me, here. a monad *is* a type (together with some more things). you could ask about the *kind* of a monad, though)
22:36:22 <sicklorkin> ski: Is it possible then to compose the coproduct of two monads?
22:36:40 <ski> compose it with what ?
22:37:01 <jusss> ski: the type is for functions, which monads are in
22:37:07 <ski> (and compose it, in which way ?)
22:37:18 <zeta_0> i still haven't figured out how to get hasklig-mode working in emacs(the ligatures just turn invisible) why is this happening and how do i get it to work?
22:37:30 <zeta_0> https://github.com/minad/hasklig-mode/tree/386c098c93a744f6b30ad937d193eebf0fd79e1b
22:37:34 <ski> jusss : can you rephase that message ? i can't parse it
22:38:00 * ski has never heard of this mode before ..
22:38:07 <jusss> ski: sorry, my English is not good, 
22:38:32 <sicklorkin> ski: with another monad
22:39:03 <ski> sicklorkin : i don't think so, in general
22:40:40 <zeta_0> ski: do you have any idea on why this is not working in emacs? https://github.com/minad/hasklig-mode/tree/386c098c93a744f6b30ad937d193eebf0fd79e1b
22:40:41 <ski> sicklorkin : assuming there is an initial monad, every monad would be a coproduct of itself and the initial monad. so being able to compose that coproduct with another monad then degenerates to composing the first monad with the other monad, which can't be done, in general
22:40:50 * ski has never heard of this mode before ..
22:41:45 <sicklorkin> ski: thanks.. just a random thought
22:42:29 <zeta_0> ski: ok, it's fine
22:42:34 * ski isn't convinced using ligatures in Haskell codes is sensible anyway ..
22:43:20 <ski> (unless maybe if some extra (only visual) spaces were inserted, to not mess up layout and alignment)
22:44:40 <julianleviston> I’ve written some code using STM, and I’m trying to make it more generic so I can have two interpretations/variants of it (one will be pure using lists as logs, for testing things out in GHCi, and the other is using async, exceptions, IO and STM).
22:45:11 <julianleviston> I’ve thought about doing this in various ways, one of which is the current implementation… I’m trying to extract out the generic pieces into typeclasses… however, I’m getting into type ambiguities and I feel a bit like I’m fighting Haskell.
22:46:25 <zeta_0> ski: i have no idea how though, i just installed the package and added the default configuration code to .emacs but when i type the ligatures they turn invisible, how would i fix this and add extra (only visual) spaces as you suggest?
22:46:38 <zeta_0> ski: https://github.com/minad/hasklig-mode/tree/386c098c93a744f6b30ad937d193eebf0fd79e1b
22:46:44 <ski> zeta_0 : if you're interested in learning more about stuff that Haskell is somewhat based on, then perhaps Type Theory could be worth checking out some
22:47:11 * ski doesn't know that much about how to write Emacs modes
22:48:15 <zeta_0> ski: oh ok, i forgot about type theory, i'll learn that when i give idris a try, probably not for a while though
22:48:17 <julianleviston> This is the current issue I’ve got: https://gist.github.com/JulianLeviston/82cddf2361114fbb78e765309118f156
22:48:24 <jackdk> I think there are ligature fonts that don't need an emacs mode to drive them, and they manage to not give up monospacing. I don't know more than that because I use the one true font, PxPlus VGA9 from int10h.org
22:50:24 <ski> jackdk : i suppose i was thinking of adding some extra (virtual) spaces, after the token, to make up for ligatures eating some of the token width ..
22:50:36 <julianleviston> Is what I’m trying to do insane? Weird thing is, it seems like it’s a pretty common thing to want to do — I could use Free monads to do it, or extensible effects, but I’d thought I could just use typeclasses. Only, specifying the dependencies between the pieces seems to be causing me pain. I guess I didn’t ask this very well.
22:51:13 <jackdk> ski: some of the better ligature fonts do this by shifting the combined char into the middle. so <> would render as a 2-char wide diamond and still look ok if you're into that sort of thing
22:52:23 <ski> julianleviston : i would probably move `atomically' to a subclass
22:53:02 <julianleviston> what’s a subclass?
22:53:13 <julianleviston> a class that is constrained by another class?
22:53:55 <julianleviston> Oh, like move atomically into HasMemberList ?
22:53:57 <ski> i'm not sure i'd say it's a constraint, but yes
22:54:07 <julianleviston> Oh a class of its own?
22:54:11 <ski> no, move it into a new class
22:54:24 <julianleviston> right yes :) that makes sense :) I’ll try that :) thanks! 
22:54:39 <ski> `IORef' and `STRef s' doesn't have any `atomically'
22:55:30 <julianleviston> yup.
22:56:31 <ski> there's also stuff like
22:56:32 <ski> @type Data.IORef.atomicModifyIORef
22:56:33 <julianleviston> I want to avoid rewriting newMemberList for every instance
22:56:35 <lambdabot> GHC.IORef.IORef a -> (a -> (a, b)) -> IO b
22:57:07 <ski> jackdk : i see
22:57:08 <julianleviston> and it’s *almost* generic — just has that call to atomically — my plan was to make it be id in the case that it didn’t make sense
22:57:44 <ski> btw, it's not clear to me at all that `HasMemberList' needs to be a thing
22:57:53 <julianleviston> oh i’ve only shown part of it.
22:58:14 <julianleviston> it has two methods in it that still have a lot of IO and STM related code I want to extract out
22:58:40 <ski> are you going to have at least two instance of `HasMemberList' ?
22:58:48 <julianleviston> yep
22:58:57 <julianleviston> one will be pure, the other messy :)
22:59:06 <ski> and you're overriding those defaults somewhere, i hope
22:59:15 <julianleviston> the defaults? no
22:59:38 <julianleviston> I want to do experiments with the pure one to see how the messy one will turn out on a real network
22:59:46 <ski> then why does `newMemberList' need to be a method of the class at all ?
22:59:54 <julianleviston> it doesn't
23:00:05 <ski> (and similarly for the other method, if you don't override its default either)
23:01:18 <julianleviston> yup.
23:42:07 <maerwald> how can I control where the ghc environment file will be saved to?
