00:03:03 <Axman6> that's not really the right way to think about things...
00:03:42 <Axman6> just because pure code gets called from IO doesn't mean there isn't pure code
00:06:50 <lldd> i was talking about this specific case not in general
00:07:07 <lldd> here i can write 20 more lines or leave the two lines as it is :)
01:24:04 <kuribas> java forcing you to handle exceptions is actually a good design.  We should have something like that in haskell...
01:24:41 <kuribas> but with lazyness that could be impossible...
01:24:55 <merijn> kuribas: Well, I've been saying that for years and working for a design that'd work with Haskell, but no one wants to pay me to work on it :p
01:25:06 <merijn> kuribas: I disagree, I think it's totally doable even with laziness
01:25:27 <merijn> It just cannot/won't be entirely backwards compatible with the current exception approach
01:27:07 <merijn> kuribas: Basically, what I want/envision is "checked, but inferred" exceptions. So like java's checked exceptions in that you can never have an exception that is thrown without knowing about it from the type, but you also don't have to manually write down the exceptions that can be thrown like you have to in Java
01:27:34 <merijn> kuribas: I'm pretty convinced it can be made to work, but even a minimal prototype would be quite a lot of work to implement
01:28:08 <merijn> So unless someone offers me a postdoc position or something to pay me to work on that, it's not going anywhere anytime soon :p
01:28:29 <kuribas> merijn: count me as a supporter :)
01:28:36 <merijn> I should start a kickstarter...
01:28:45 <merijn> :p
01:29:02 <merijn> Well, maybe I should finish my thesis first... >.>
01:29:28 <kuribas> merijn: first, you'ld need support from the community
01:29:40 <kuribas> it would have to be backwards compatible
01:29:52 <merijn> kuribas: That's just fundamentally not going to work, tbh
01:30:14 <kuribas> merijn: so basically break all existing code :-P
01:30:21 <merijn> kuribas: I didn't say that :p
01:30:28 <merijn> kuribas: Just break *some* existing code :p
01:31:11 <merijn> kuribas: tbh I think the first thing to do is write a non-Haskell prototype just to proof the typing/semantics sound, before thinking about integrating with Haskell/GHC
01:33:28 <kuribas> prove it in idris :)
01:42:29 <petercommand> what's the recommended way to add an inequality type constraint in haskell (to avoid overlapping instances)?
01:42:59 <ski> merijn : hm, sortof similar to the implicit parameter constraints ?
01:43:06 <dminuoso> petercommand: Via a type family.
01:43:31 <dminuoso> petercommand: Though that won't help much. merijn has a trick ready for you.
01:44:10 <petercommand> what trick?
01:45:12 <dminuoso> petercommand: https://gist.github.com/dminuoso/a1299fa4ab2019ea7b399db79c5ac6fd
01:45:20 <dminuoso> petercommand: You can use a type equality constraint with this type family/
01:45:33 <dminuoso> Such that ⌜type TypeNeq a b = TypeEqF a b ~ False⌝
01:45:58 <dminuoso> Originally I thought merijn had a gist outlining this, just couldn't find it.
01:46:07 <petercommand> thanks, will try this :D
01:47:30 <merijn> dminuoso: You mean https://gist.github.com/merijn/6130082 ?
01:47:40 <merijn> I should update to use the new custom type error stuff
01:47:43 <dminuoso> merijn: Ohh yes. 
01:48:13 <rsoeldner> srhb, Now I encounter `error: infinite recursion encountered, at undefined position` when using `nix-env -iA nixos.influxdb` with the following setup https://gist.github.com/rsoeldner/46877301df7c9f34884bd39b76cdcea9
01:48:58 <dminuoso> "at undefined position", what a wonderful diagnostic.
01:49:21 <rsoeldner> dminuoso, ^^
01:50:26 <dminuoso> petercommand: Though I dont think you will achieve the desired result with that.
01:51:22 <merijn> ski: Yes, no, maybe? I don't know/understand those well enough
01:51:29 <srhb> rsoeldner: You seem to ahve slipped into the wrong channel :-)
01:52:00 <merijn> petercommand: Anyway, this seems unlikely to help a problem that comes from overlapping instances, as it doesn't change/affect overlap at all
01:52:12 <Ariakenom> it's the one other lazy language :p
01:53:18 <rsoeldner> srhb, whop :)
01:53:44 <petercommand> dminuoso, merijn: I got the error 'Duplicate instance declarations' if I have one instance with the constraint "TypeEq a b ~ True" and another instance with the constraint "TypeEq a b ~ False"
01:56:19 <merijn> petercommand: constraints don't affect instance selection or overlap
01:56:25 <merijn> petercommand: They only affect type checking
01:56:37 <petercommand> merijn: ah..
01:56:40 <merijn> petercommand: Hence why I said this seems unlikely to help any problem involving overlapping instances
01:56:41 <petercommand> :(
01:57:52 <merijn> petercommand: Let's rewind: What instances are you trying to define and why are they overlapping?
01:59:44 <dminuoso> 10:55:58         merijn | petercommand: constraints don't affect instance selection or overlap
01:59:49 <dminuoso> ^- let this sink in deep. :)
02:00:08 <ski> merijn : i was thinking stuff like `div :: Integral i => i -> i -> i <| ?DivideByZero', or something like that
02:00:21 <petercommand> merijn: https://pastebin.com/iZnZBxyN
02:00:42 <petercommand> merijn: basically I am trying to extract a tag from a datatype
02:00:52 <merijn> ski: Several years ago, by now, I wrote this position paper where I argued that what we want/need is "more typesystems"
02:00:54 <petercommand> merijn: through generics
02:01:05 <noipmusp> Is there anyone who can help me with SmallCheck? I need to define Serial instance for identifiers (any char followed by zero or more digits or chars), but I'm completely lost.
02:01:10 <merijn> ski: This thing in Haskell where we try and bolt everything into one type is unscalable and doomed
02:01:42 <ski> merijn : hm, like a parallel type ?
02:01:58 * ski is reminded of mode declarations in Mercury
02:02:04 <merijn> ski: When I write a (let's call it "functional") type signature I wanna describe the functionality. I may also want to describe other properties, but those don't affect the functional type
02:02:22 <merijn> In Haskell we tend to stuff all those things in the same type (see also effects, etc.) rendering the types just more painful to deal with
02:03:02 <merijn> ski: Yes, I was calling it "orthogonal type system", but parallel works too, I suppose. I just meant we want to describe certain properties independently of each other
02:03:03 <petercommand> merijn: this is what I am trying to do https://github.com/AndyShiue/ende/blob/ast/frontend/src/Ast.hs#L149
02:03:35 <merijn> Wow, that code is frightening :)
02:04:33 <merijn> ski: Other things you'd (potentially) want to track this way is: strictness. Like, why can't I write code that is "strictness polymorphic"? Why do I have to write either strict OR lazy?
02:04:37 <merijn> ski: We can infer that stuff
02:04:43 <merijn> ski: Exceptions are another example
02:05:21 <lortabac> petercommand: you can't select an instance based on the context
02:05:32 <ski> i'm not quite sure how exceptions fit in, there
02:05:36 <merijn> ski: If we want to get really interesting: GC domains. Right now GHC is stop the world because we can communicate (by reference) between threads, so there's no other way. Erlang is not stop the world because all communication is "by value", but that means communication is slow
02:05:55 <lortabac> petercommand: this page shows a couple of workarounds https://wiki.haskell.org/GHC/AdvancedOverlap
02:06:15 <merijn> ski: Whether an expression can throw an exception and what those exceptions can be is completely independent to "what it computes if it doesn't throw"
02:06:34 <ski> merijn : in Clean, uniqueness is part of types. but in Mercury, it's separate, being part of "inst"s (instantiation states). which are part of the "mode" descriptions of functions and predicates (separate from type signatures)
02:06:40 <merijn> ski: Like, the fact that "div x 0" can throw DivisionByZero doesn't really affect that it returns an Int *if* it returns
02:07:42 <kuribas> so div is not total
02:07:43 <ski> merijn : yea, but a side-effect is just an effect from another POV :)
02:08:01 <dminuoso> petercommand: Instance selection happens soley based on the head of an instance.
02:08:10 <merijn> ski: Anyway, back to the GHC domains. We could make the GHC domain of values part of (yet another) type, and track it and have different communication primitives that are either by value or reference in a type-safe way
02:08:19 <merijn> s/GHC/GC
02:08:42 <merijn> ski: It wouldn't be a side-effect, though, because it's still tracked
02:08:50 <ski> merijn : re GC domains, do you mean things like in region-based memory management, a function could be passed a region in which to allocate something (e.g. a closure)
02:09:17 <merijn> ski: It's just separating "What type of value is this?" from "What can this do when evaluated?", you want to track both in the type system, but do we really want that to be *the same* type system?
02:09:20 <dminuoso> petercommand: That is, if you specify some `instance (Ctxt ...) => Head ...`, then just the Head is considered for the decision of "which instance should be picked"
02:09:45 <merijn> ski: I want a hierarchy of capabilities so we can have GCs restricted to threads, groups of capabilities, etc.
02:10:26 <ski> merijn : well, afaiac, there's two parts. (a) explicit tracking in types/interfaces/whatever; and (b) some kind of syntactic distinction in code, that distinguishes it from "normal code" without any effect
02:11:00 <merijn> ski: So we can do more fine-grained/independent GCs instead of relying on always doing global stop-the-world. If we assume that "global" communication is fairly rare (seems like a reasonable assumption), we can do away with most global GCs and thus most world stops
02:11:10 <dminuoso> petercommand: That means if you have two conflicting `instance (SomeCtxt ..) => T H` and `instance (AnotherCtxt ..) => T H` for some suitable `T` and `H`, then those overlap. Neither is better because the heads are the same.
02:11:14 <kuribas> If I write a function over numbers, say Int -> Int, does ghc create a unboxed version for when the first int is known to be evaluated?
02:11:29 <merijn> ski: Anyway, I've got a lot of ideas of what a purely functional systems language would look like to me, but sadly no one wants to pay me to try this stuff out ;)
02:11:39 <kuribas> Or does it force a check every evaluation?
02:11:41 <merijn> kuribas: Yes, no, maybe, it depends :)
02:11:48 <ski> merijn : (re separating) one could argue something similar for monadic,idiomatic, and "functoriadic" effects (and i've done so -- at least, one could construe it in those terms)
02:12:05 <merijn> ski: Anyway, I think this entire space is underexplored
02:12:26 <ski> merijn : agreed
02:12:27 <merijn> kuribas: The strictness analyzer (tries to) detect those situations and unbox things if possible
02:12:48 <petercommand> dminuoso: yeah
02:13:00 <merijn> kuribas: So whether it happens depends on whether it succeeds in detecting your situation
02:13:02 <petercommand> lortabac: thanks for the link
02:13:12 <merijn> kuribas: If you *really* care you can just write the unboxed code yourself :p
02:13:31 <merijn> Just enable -XMagicHash and feel like a real hacker!
02:14:43 <ski> merijn : my "reflective syntax" ideas, with (*locally*) side-effectful expressions (in Haskell !), where `MkPerson [{parseName}] [{parseAge}] :: Person  -- with `Parser' side-effects' is what i was thinking of. you could possibly think of this as separating the `Parser' part from the `Person' part. the type of the expression is `Person'
02:15:07 <dminuoso> petercommand: To understand the subtleties, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances gives some details
02:15:11 <ski> merijn : but there's a related expression, which has type `Parser Person'
02:15:12 <merijn> ski: That sounds similar to idiom brackets?
02:15:34 <ski> merijn : yes, this idea grew out of idiom brackets, wanting to address a perceived problem with them
02:16:13 <ski> (it also took inspiration from Andzej Filinski's "Reflecting Monads", and also quasiquotation in the Lisps, and in MetaML/MetaOCaml)
02:16:53 <merijn> ski: tbh, the main thing I dread in trying to play with this is having to implement all the compiler optimisation stuff to get reasonable performance from generated code. I feel the reason GHC is stuff full with so many extensions is that no one wants to have to reinvent it's optimisations/backend just to get a working language >.>
02:17:02 <ski> (sorry, s/Andzej/Andrzej/)
02:17:16 <merijn> ski: But GHC has to much baggage to easily experiment with some of these ideas
02:17:18 <dminuoso> petercommand: Mind my asking, what exactly do you intend to do in that line of code that requires oerlapping instances? 
02:17:43 <ski> merijn : i understand
02:20:13 <petercommand> dminuoso: trying to get a tag from AST https://github.com/AndyShiue/ende/blob/ast/frontend/src/Ast.hs#L149
02:21:10 <dminuoso> petercommand: yes but that code does not seem motivating yet.
02:21:44 <petercommand> dminuoso: how so?
02:23:19 <dminuoso> petercommand: https://gist.github.com/dminuoso/84fe5155f74072e010859890ccc16e2c they are the same?
02:23:49 <petercommand> no
02:24:00 <dminuoso> Then you have to help me here.
02:24:46 <dminuoso> petercommand: If you can reduce `tag :: *` to a closed set, you can use type equality by the way.
02:26:00 <petercommand> dminuoso: I was hoping that tag can be any type
02:28:10 <petercommand> dminuoso: so, what I am trying to do is sth like this if the current subtree has type tag, I would be able to actually extract the tag
02:28:26 <petercommand> dminuoso: and if it's not, I won't be able to get anything
02:29:22 <petercommand> dminuoso: does this make sense?
02:31:35 <petercommand> dminuoso: and yeah, I might be able to get away with `tag` being a closed set..
02:37:35 <dminuoso> petercommand: Unrelatedly, instead of (K1 r tag) you can just write (Rec0 tag)
02:39:14 <petercommand> yeah, using Rec0 is probably better (easier to read)
02:41:45 <petercommand> dminuoso: turns out I can avoid this overlapping mess by removing the second constraint from the :*: instance
02:42:01 <petercommand> dminuoso: I would still want to know how sth like this can be solved in haskell though
02:42:19 <petercommand> these equality stuff
02:46:39 <dminuoso> petercommand: You could write the instances manually.
02:47:37 <petercommand> dminuoso: yeah, that's one way to do it
02:48:05 <dminuoso> petercommand: one thing Im wondering about, is what `tag` ends up in the end?
02:48:51 <dminuoso> petercommand: `getTagged @Statement someStmt` what should that produce?
02:49:13 <dminuoso> Consider that a tag may not be present. Or in `ConstrPat` there may be multiple tags.
02:50:08 <petercommand> dminuoso: basically the type and/or location of the terms
03:23:30 <lyxia> what do you do if the tag is not present
03:35:00 <Zer0xp> Hey so what does this mean [[Float]] ?
03:37:35 <Taneb> Zer0xp: a list of lists of floating point numbers
03:38:08 <hgrsd> ~~~~~~~~~~
04:23:36 <nakkle> Hi guys, I've been playing around with Data.Conduit.Network, and I'm seeing odd behavior with its `runTCPServer` function. Internally, it creates a thread for every new connection, but when I kill the thread that originally called `runTCPServer`, all the spawned threads continue to run, and connected clients can still communicate with them.. That doesn't make a lot of sense to me. Does anyone know if there's a way to kill the se
04:23:37 <nakkle> cluding the already established connections?
04:25:37 <hpc> if you want it to exit completely, you should be able to just end the main thread
04:25:59 <hpc> make it reach the end of main, use exitWith, etc
04:26:34 <hpc> alternatively, keep track of all the spawned threads so you can kill them as well
04:28:23 <nakkle> hpc: I can't exit the program, because it's intended to be a small part of a larger service. 
04:28:43 <nakkle> hpc: not sure what you mean, the `runTCPServer` does all the threading internally, I don't have access to any spawned IDs
04:32:22 <hpc> ah, i see
04:32:24 <hpc> hmm
04:32:53 <dibblego> in template haskell, the InstanceD constructor for writing an instance, where is the T given to the constructor in "instance C T where"? https://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec
04:34:31 <ski> dibblego : hm, i'd guess the `Type' part will include the whole `C T' ?
04:34:39 <dibblego> ah!
04:35:02 <dibblego> ah yeah you're right, cheers
04:35:14 <dibblego> AppT x y
04:35:20 <ski> (i guessed that before i checked that page, and the page didn't seem to suggest otherwise)
04:35:38 <dibblego> yeah I just wasn't thinking of the existence of MPTC :)
04:36:12 <ski> they could have had a list of types, i suppose, in addition to the class name
04:42:38 <maerwald> anyone knows why cabal new-update is trying to open .git/FETCH_HEAD in read-write mode?
04:46:56 <multithreadz0r> Hello, What package is best suited for multi-threaded programs?
04:47:43 <Ariakenom> multithreadz0r: Hi! You should probably be more specific.
04:48:07 <Ariakenom> async and stm are nice
04:49:32 <merijn> "best suited" to do what?
04:52:02 <multithreadz0r> Sure thing: Moslty starting watchers that perform different tasks such as synchornizing database collections across replicas, external api requests that might fail or not. I need to trap exceptions/ error messages and perform extra logic based on this
04:53:05 <merijn> async is pretty good about trapping/relaying exceptions for spawned threads. The timer/watcher stuff doesn't exist yet, but shouldn't be hard to implement something yourself, I think
04:54:04 <multithreadz0r> Good, thanks, I will read Parrallel programming in haskell page 400 first, and also look into Control Concurent before deciding, thanks for the input
05:03:55 <Ariakenom> multithreadz0r: Parallel and Concurrent Programming in Haskell is great. I only have the online version so I don't know pages but sounds good.
05:13:59 <ski> @where PCPH
05:13:59 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
05:13:59 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
05:31:53 <Ariakenom> ski: all but 2 of those links are broken?
05:36:24 <jumper149> Hi I'm trying to understand 
05:36:40 <jumper149> Hi, I'm trying to understand Monads in terms of category theory
05:37:10 <merijn> jumper149: Why?
05:37:25 <tdammers> category theory monads are not the same thing as haskell monads, and understanding the category theory concept won't help you much with understanding haskell monads
05:37:35 <merijn> Because, unless the answer is, "I'm learning category theory for fun", that won't help you
05:37:47 <jumper149> merijn: Yep its for fun
05:37:51 <tdammers> it may be amusing though, and maybe provide some fun insights down the road
05:37:56 <dminuoso> jumper149: How firm is your grasp on category theory?
05:37:58 <merijn> jumper149: You know Bartosz' book?
05:38:01 <dminuoso> jumper149: Do you know what monoidal categories are?
05:38:42 <jumper149> I'm watching I'm watching Bartosz lecture on youtube and have finished part 1
05:39:04 <dminuoso> jumper149: Then keep watching. He builds up to the necessary knowledge.
05:40:21 <jumper149> At the end of part one he did one lecture on monads but what I took away from it is just 'return = eta' and 'join = mu'
05:40:41 <jumper149> if u define monads like here https://en.wikipedia.org/wiki/Monad_(category_theory)
05:40:43 <dminuoso> jumper149: I could offer you a pair of diagrams to compare that might help
05:41:28 <dminuoso> jumper149: Consider just the diagrams under 2. Definition, and this gist https://gist.github.com/dminuoso/2a9ec97bce0adfe0aa4096a4a57037ff
05:41:28 <jumper149> Well I have tried around on paper a little bit, but Im not sure if my conclusions are correct
05:42:22 <dminuoso> jumper149: Can you share what you have?
05:42:28 <dminuoso> And perhaps formulate any question you have?
05:42:28 <jumper149> Can I say that >>= is a natural transformation from T -> T
05:42:41 <ski> no
05:42:49 <dminuoso> jumper149: its easier to ignore >>= honestly.
05:42:58 <dminuoso> jumper149: talk in terms of `return` and `join`
05:43:38 <dminuoso> return :: Monad m => Identity a -> m a
05:43:53 <dminuoso> join :: Monad m => (m :.: m) a -> m a
05:44:08 <jumper149> what is (m :.: m)
05:44:17 <ski> composition
05:44:19 <dminuoso> jumper149: :.: is just composition on a type level, like (.) on the value level
05:44:25 <jumper149> oh ye im stupid :D its join
05:44:43 <jumper149> is that actual haskell notation? :.:
05:44:56 <dminuoso> jumper149: Yes, there exists an actual type operator
05:45:16 <dminuoso> jumper149: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#t::.:
05:46:06 <ski>   eta : Id    >---> M
05:46:06 <ski>   mu  : M . M >---> M
05:46:37 <ski> are the two natural transformations that you need to equip an (endo)functor `M' as a monad
05:46:42 <dminuoso> % newtype (:.:) f g p = Compose { getCompose :: f (g p) }
05:46:43 <yahb> dminuoso: 
05:46:56 <dminuoso> That's just composition of endofunctors. :)
05:47:02 <ski> (and then you need three laws, in addition to the two naturality laws those NTs satisfy)
05:47:43 <dminuoso> In Haskell the naturality comes from a free theorem, which is why we dont need to talk about them I think?
05:48:53 <jumper149> What are the three laws?
05:50:12 <dminuoso> jumper149: Essentially commutatity of the diagrams under "2. Definition"  in https://ncatlab.org/nlab/show/monad
05:50:18 <jumper149> ike (.) on the value level
05:50:18 <jumper149> 14:44 < jumper149> oh ye im stupid :D its join
05:50:24 <dminuoso> *commuting of the diagrams
05:50:31 <ski>   mu_A . eta_{M A}  =  id_{M A}
05:50:34 <dminuoso> jumper149: Yes, it's like (.) on the value level.
05:50:45 <ski>   id_{M A}  =  mu_A . M eta_A
05:50:50 <dminuoso> jumper149: So `(T :.: T) a ~~~ T (T a)`
05:51:14 <dminuoso> jumper149: Part of the motivation to use the notation using composition, is because the monoidal structure of monad operates on endofunctor composition.
05:51:15 <ski>   mu_A . mu_{M A}  =  mu_A . M mu_A
05:51:38 <ski> jumper149 ^
05:51:48 <ski> in Haskell terms, those become
05:51:56 <ski>   join . return  =  id
05:52:08 <ski>   id  =  join . fmap return
05:52:19 <ski>   join . join  =  join . fmap join
05:53:27 <dminuoso> https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Coherence_law_for_the_multiplication_of_a_monad.svg/225px-Coherence_law_for_the_multiplication_of_a_monad.svg.png
05:53:29 <dminuoso> https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Coherence_law_for_the_unit_of_a_monad.svg/225px-Coherence_law_for_the_unit_of_a_monad.svg.png
05:53:36 <dminuoso> Those two pictures illustrate the laws ski stated using commuting diagrams.
05:53:47 <jumper149> well isnt 'm (m a) == (m :.: m) a' just functor composition? Then it would have nothing to do with monads but functors in general?
05:53:55 <dminuoso> jumper149: Right.
05:54:07 <dminuoso> jumper149: And note that I used ~~~ to denote isomorhic, since they are not truly identicaly.
05:54:13 <dminuoso> *identical.
05:55:02 <dminuoso> So ⌜T (T A)⌝ is isomorphic to ⌜(T :.: T) A⌝. Thus, we could pretend that ⌜join :: Monad m => (m :.: m) a -> m a⌝
05:55:27 <dminuoso> And equivalently ⌜Identity A⌝ is trivially isomorphic to ⌜A⌝, which is why we can pretend that ⌜return :: Monad m => Identity a -> m a⌝
05:56:27 <ski>   return :: Monad m => Identity ~> m
05:56:28 <ski>   join   :: Monad m => m :.: m  ~> m
05:56:31 <ski> given
05:56:44 <ski>   type f ~> g = forall a. f a -> g a
05:57:11 <Drezil> anyone here who can answer a "simple" question regarding recursion schemes?
05:57:19 <dminuoso> Drezil: Just ask and find out :)
05:58:33 <Drezil> I have an f a and basically just want to map an "a -> IO b" over it, but the function would require to make a call to a foreign server.. so i would prefer to have some thing like "[a] -> IO [b]" which does the mapping, but batches the call out tho the other node.
05:59:22 <Drezil> i could do a toList, call everything and then basically just use a lookup for modifying the structure
05:59:32 <dminuoso> jumper149: The reason we talk about endofunctor composition is basically related to a common joke: "All told, a monad is just a monoid in the category of endofunctors" which is just very poorly phrased. A more accurate description would be "A monad is a monoid in *a* monoidal category of endofunctors equipped with endofunctor composition as its tensor"
05:59:42 <Drezil> but i thought that there is maybe a combinator doing this for me ..
06:00:39 <jumper149> dminuoso: every category is monoidal regarding composition of morphisms isnt it?
06:00:39 <dminuoso> jumper149: The natural transformation ⌜mu⌝ is that sort monoidal operation, and ⌜eta⌝ is that unit with respect to that monoidal operation. The associativity/identity laws are described by the diagrams linked above and described by ski.
06:00:59 <dminuoso> jumper149: A monoidal category is a special construct in CT.
06:01:16 <dminuoso> jumper149: It's when the category is equipped with a bifunctor satisfying certain coherence laws.
06:01:26 <dminuoso> (:.:) is a bifunctor that satisfies these laws.
06:02:51 <dminuoso> The coherence laws are basically associativity up to isomorphism (this is different, but related, to the associativity of ⌜mu⌝/⌜join⌝ above), and identity up to isomorphism (again different, but related, to the associativity of ⌜eta⌝/⌜return⌝ above.
06:03:34 <jumper149> What is the monoid exactly? I mean set and operation
06:03:44 <dminuoso> jumper149: https://gist.github.com/dminuoso/2a9ec97bce0adfe0aa4096a4a57037ff
06:04:13 <dminuoso> jumper149: The operations are special natural transformations, and its objects are endofunctors.
06:04:24 <nil> Drezil: mapM perhaps?
06:04:40 <pong> nil: hi
06:04:49 <nil> hi pong
06:05:02 <Drezil> nil: nah .. that would fire a request for every entry and not batch them up beforehand..
06:05:17 <dminuoso> jumper149: Basically you need to juggle that there's two concepts of monoid being thrown again.
06:05:46 <dminuoso> jumper149: First there's the monoidal category of endofunctors. Being a category of endofunctors its objects are endofunctors themselves. Morphisms between them are natural transformations.
06:06:16 <jumper149> one monoid is the conjunction of endofunctors giving back an endofunctor. The other is the composition of 2 monads giving back a monad?
06:06:57 <dminuoso> jumper149: I urge you to not call the former a monoid. The term "monoidal category" is a very distinct term, because it sort of reminds of a monoid.
06:07:44 <ski> Drezil : you would probably have to tell more about this batching, and what type of operations should be batched
06:07:49 <dminuoso> jumper149: Given that above category, we can equip it with a tensor/bifunctor: (x) : C x C -> C
06:07:58 <dminuoso> jumper149: That bifunctor is endofunctor compositoin.
06:08:19 <dminuoso> jumper149: We denote it with (:.:) in Haskell. It too is a Bifunctor in Haskell.
06:08:43 <dminuoso> jumper149: Equipping that category with that tensor is not enough. For it to be a monoidal category, we need to have special coherence laws.
06:08:54 <jumper149> eta and mu ?
06:09:02 <dminuoso> No. We are not there yet
06:09:23 <dminuoso> Namely, ⌜(T :.: (T :.: T))⌝ needs to be isomorphic to ⌜((T :.: T) :.: T)⌝
06:09:34 <jumper149> thats one of the diagrams
06:09:39 <dminuoso> jumper149: Differnet world.
06:09:43 <dminuoso> Perhaps what Im saying is just too confusing.
06:09:49 <dminuoso> I tried to make a link via a different definition.
06:10:20 <jumper149> https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Coherence_law_for_the_multiplication_of_a_monad.svg/225px-Coherence_law_for_the_multiplication_of_a_monad.svg.png
06:10:22 <dminuoso> jumper149: Going back to ski's definition, a monad is just defined in terms of endofunctor composition.
06:10:25 <ski> jumper149 : there's (a) monoidal categories; and (b) monoid objects in a monoidal category. dminuoso is still at (a)
06:10:26 <dminuoso> It's part of its definition.
06:10:38 <Drezil> ski: i have a tree of text-nodes and a service that can annotate each of them. I could just mapM and this would be fine for local computations, but the computation is done on another machine, so i want to collect all beforehand, do one http-call and make a 1-on-1 replacement of the results instead of firering one call per node in my tree.
06:11:18 <Drezil> i think it could be done with http://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#v:transverse .. but i still have to ponder about it..
06:12:04 <dminuoso> jumper149: So the monoid is basically like this, you can hae some `(T :.: T) A`, the monoidal operation lies in smashing these two `T` layers together.
06:12:59 <dminuoso> jumper149: And that smashing together must be associative, such that when you smash `(T :.: T :.: T) A` into `T A` via two smashing operations, it doesnt matter whether you smash the left two layers first, or the right two layers first.
06:13:13 <jumper149> I have trouble drawing the line between functor composition and composition of monads, especially since monads are special functors
06:13:13 <dminuoso> jumper149: And you can introduce "neutral" layers that act as an identity with regards to that smashing.
06:14:01 <jumper149> Are monads all endofunctors in haskell?
06:14:04 <dminuoso> Yes.
06:14:11 <jumper149> but not in general?
06:14:14 <dminuoso> They are in general.
06:14:17 <dminuoso> Every monad is an endofunctor.
06:14:26 <dminuoso> Its an endofunctor with some special functions.
06:14:30 <dminuoso> Those special functions are join/return.
06:14:33 <dminuoso> Or eta/mu.
06:14:41 <jumper149> i mean is every endofunctor a monad?
06:14:44 <dminuoso> No.
06:14:53 <dminuoso> Not every endofunctor can be equipped with those two operations.
06:14:53 <jumper149> also not in haskell?
06:14:57 <dminuoso> jumper149: Also not in Haskell.
06:15:08 <[exa]> Drezil: you can traverse the tree viewed through toListOf/chunked lenses, which should be able to hold the structure
06:15:52 <dminuoso> jumper149: And endofunctor composition comes for free, basically.
06:16:01 <dminuoso> jumper149: If you have endofunctors, you can talk about composing them.
06:16:58 <ski> Drezil : perhaps, but then `f' will surely not be `IO'
06:18:27 <ski> Drezil : you need to think about what you can transmit to this other maching, and batch up that data. presumably that will not be an `IO'-action ?
06:19:07 <dminuoso> jumper149: So the trick is this: If you take your endofunctor T, and you can equip it with an operation that can smash composition layers together associatively, and you can make up "neutral" layers that act as an identity wrt to that smashing - then its called a monad.
06:19:20 <[exa]> ...is there some iso/lens alternative of chunksOf?
06:19:34 <dminuoso> jumper149: The category theory terms is, that smashing is described as a natural transformation
06:19:38 <dminuoso> 14:56:05            ski |   return :: Monad m => Identity ~> m
06:19:41 <dminuoso> 14:56:06            ski |   join   :: Monad m => m :.: m  ~> m
06:20:13 <jumper149> Well it really does come back down to return and join / mu and eta
06:20:19 <dminuoso> jumper149: ^- ⌜join⌝ lets you smash two layers together into a single layer. ⌜return⌝ lets you create "neutral layers" that act as an identity with regards to join
06:20:24 <dminuoso> jumper149: Yes.
06:21:11 <dminuoso> jumper149: The (>>=)/(>>) part of Monad are just combinations of ⌜fmap⌝, ⌜join⌝ because for the way we write programs, they are more convenient to use than ⌜join⌝
06:22:04 <ski> (you could coyoneda `(>>=)' back to `join')
06:23:11 <Drezil> ski: basically i need a fixpoint-structure-preserving IO-mapping
06:23:37 <ski> hm, sounds more complicated
06:23:44 <jumper149> ski: I have no idea about coyoneda atm
06:23:48 <dminuoso> jumper149: Now the terms "smashing" is very handwavy, but perhaps more intuitive at first glance.
06:24:09 <dminuoso> jumper149: If we consider: ⌜jon :: Monad m => m :.: m  ~> m⌝
06:24:23 <dminuoso> In some sense "it smashes layers of endofunctors together", but it's really just a natural transformation
06:24:43 <jumper149> I do understand each concept of join and mu, I think so atleast
06:24:43 <dminuoso> It's a natural transformation because ⌜m :.: m⌝ is an endofunctor as much as ⌜m⌝ is.
06:25:02 <dminuoso> (well and because naturality laws are satisfied of course)
06:25:16 <dminuoso> But in Haskell we get naturality laws as a free theorem. Lucky us.
06:25:55 <dminuoso> jumper149: And ⌜return⌝ is too a natural transformation, but we need to think about it in terms of ⌜Identity⌝.
06:25:58 * ski celebrates parametricity
06:26:32 <dminuoso> jumper149: Because also, Identity is an endofunctor.
06:26:42 <dminuoso> So ⌜return :: Monad m => Identity ~> m⌝ is a natural transformation.
06:27:09 <jumper149> I would really like to see >>= in terms of join and return
06:27:23 <ski> (or, `return :: Identity ~> m' is one, for every `m' satisfying `Monad m')
06:27:31 <jumper149> I think Bartosz did that in his lecture
06:27:39 <dminuoso> jumper149: Write it yourself.
06:27:46 <dminuoso> jumper149: Its not hard and probably a good excercise.
06:27:51 <jumper149> I will try
06:28:01 <ski> you're also allowed to use `fmap'
06:28:54 <dminuoso> ski: I just had this thought that the monoidal category of endofunctors equipped with endofunctor composition is a bit like a free monoid, isn't it?
06:30:05 <ski> free over `Cat' ?
06:30:35 <dminuoso> ski: Im struggling to formalize this right now.
06:32:42 <dminuoso> ski: What does "free over ..." mean exactly?
06:32:47 <ski> there's obviously `U : MonCat >---> Cat'. you're suggesting `F : Cat >---> MonCat', with `F ---| U', i suppose. so `F C >---> D' ought to be isomorphic to `C >---> U D', naturally in `C : Cat' and `D : MonCat'
06:33:10 <ski> dminuoso : domain of the free functor
06:33:16 <dminuoso> Ah
06:33:31 <dminuoso> ski: Then yes.
06:33:59 <jumper149> is `join` not in scope of prelude?
06:34:13 <dminuoso> jumper149: Nope. You have to import Control.Monad
06:34:29 <ski> e.g., given any set `S', there's a free abelian group `G', generated by `S'
06:34:39 <dminuoso> jumper149: Like I said, ⌜join⌝ is ergonomically not ideal in programming situations. :)
06:35:01 <ski> however, given any group `G', there's also a free abelian group `G/[G,G]', its abelianization
06:35:11 <jumper149> Well I didn't test it because I didnt want to think of an example but this is what I got:
06:35:14 <jumper149> bind :: Monad m => m a -> (a -> m b) -> m b
06:35:16 <jumper149> bind t f = join (fmap f t)
06:35:22 <dminuoso> There you go. :)
06:35:33 <ski> so, just saying "free abelian group" is ambiguou, if you don't specify the type (the category) of the object you start from
06:36:07 <ski> (it's common that you start with `Set'. or in your case, `Cat'. but that needn't be the case)
06:36:16 <dminuoso> jumper149: The reason `join` is not part of the actual class definition is an unfortunate accident and extremely subtle limitations of things that you can ignore.
06:36:38 <dminuoso> jumper149: In the near future we will have new extensions that will let us put `join` into the class Monad.
06:36:56 <dminuoso> The details here are somewhat complicated.
06:37:04 <jumper149> So i can choose whether to define >>= or join and return?
06:37:19 <dminuoso> jumper149: Not right now.
06:37:27 <dminuoso> because `join` is formally no longer a class method.
06:37:28 <reallymemorable> I am trying to define default instance for Show1 for a custom monad: `instance Show1 MyMonad where`
06:37:38 <reallymemorable> are there default versions listed somewhere
06:37:38 <dminuoso> The reasons for this is because of another extension.
06:37:46 <dminuoso> But it's completely unrelated to this discussion.
06:37:50 <dminuoso> You can assume that it was.
06:37:58 <jumper149> ok I think I am gonna ignore that it seems distracting from my troubles
06:38:35 <dminuoso> Indeed.
06:38:58 <ski> you can define `(>>=)' and `return', and then you can use default implementations of `fmap',(`pure',)`(<*>)' (namely `liftM',(`return',)`ap')
06:39:58 <ski> you can define `join' (currently as a separate function),`fmap' and `return', and then you can use the above default implementation of `(>>=)' in tems of `join' and `fmap', and then proceed as before
06:40:11 <arianvp> how do I partially apply type synonyms? (Can I?)
06:40:23 <arianvp> I want to thread through both an Eq and an Ord constraint in generics-sop library
06:40:24 <arianvp> bu
06:40:26 <arianvp> type C a = (Eq a, Ord a)
06:40:28 <arianvp> type Stuff xs = All C xs
06:40:35 <Taneb> arianvp: you cannot
06:40:37 <arianvp> this gives me an error that "C" needs another argument :(
06:40:42 <ski> (if you're making an instance of `Applicative', without an instance of `Monad', then you can use `liftA' as default implementation of `fmap')
06:40:48 <arianvp> Taneb: darnit
06:40:56 <arianvp> so how do I thread through two constraints in generics-sop ?
06:41:00 <Taneb> You can do "class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a"
06:41:08 <dminuoso> jumper149: Just to give you some peace of mind, it blocked GeneralizedNewtypeDeriving on Monad. It was deemed more important to be able to use GND with Monad than to have `join` in Monad, it was moved out.
06:41:29 <dminuoso> jumper149: The details are really not important. Just felt it might be useful to know that the motivations were completely unrelated to this topic.
06:42:01 <arianvp> Taneb:thanks!
06:42:03 <arianvp> that did the job
06:42:57 <dminuoso> jumper149: In the near future (perhaps its already in?) we will have some additional extensions that will let us have `join` as a class method *and* have GeneralizedNewtypeDeriving work with Monad. For you, you could just write your own `Monad'` that has `join` as a class method.
06:43:17 <dminuoso> And experiment with that, it'll not create any problems as long as you don't use GND with it.
06:46:41 <jumper149> Is Bartosz book on category theory available or do I have to buy it? 
06:48:22 <dmoerner> jumper149: This book? https://github.com/hmemcpy/milewski-ctfp-pdf
06:49:28 <jumper149> I guess? I just knew there is a book out there. I shouldve googled myself tho x)
06:53:24 <jumper149> dminuoso: ski: Thanks for your help regarding Monads :)
07:06:59 <kosmikus> arianvp: there's also http://hackage.haskell.org/package/sop-core-0.5.0.0/docs/Data-SOP-Constraint.html#t:And
07:18:16 <ski> @where CTfP
07:18:16 <lambdabot> I know nothing about ctfp.
07:18:21 <ski> @where+ CTfP "Category Theory for Programmers" by Bartosz Milewski in 2018-10-21 at <https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>,<https://github.com/hmemcpy/milewski-ctfp-pdf>
07:18:21 <lambdabot> I will never forget.
07:19:38 <saml> is it good
07:19:52 * ski hasn't checked it out
07:20:22 <ski> i've liked the videos he's made about CT, though
07:21:55 <merijn> saml: Depends what you hope to get out of it? :)
07:34:02 <dminuoso> Okay. I shot myself into the foot bigtime. Wrote a continuation based parser, there's some control flow bug.
07:34:07 <dminuoso> And I have no frigging clue where.
07:34:30 <dminuoso> Dont even understand how my own CPS code works.
07:34:59 <Ariakenom> :D
07:36:31 <merijn> You don't understand CPS code
07:36:37 <merijn> You just avoid thinking too hard about it
07:36:45 <merijn> @quote didn't.you.write.it
07:36:45 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:36:48 <merijn> hmm
07:37:07 <merijn> @quote autrijus and.it.works
07:37:07 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
07:37:07 <lambdabot> just don't know what it means.
07:37:18 <dminuoso> Yeah. Im sort of in that same boat.
07:37:52 <merijn> I feel this quote deeply anytime I work with ContT
07:38:14 <Taneb> @unmtl ContT r (ReaderT x IO) (ReaderT x IO x)
07:38:14 <lambdabot> ((x -> IO x) -> x -> IO r) -> x -> IO r
07:38:38 <Ariakenom> that is a great quote
07:38:43 <dminuoso> Though I think I understand my problem is.
07:38:49 <dminuoso> Something is triggering bottom. Somehow.
07:39:11 <dminuoso> Somewhere.
07:46:03 <dminuoso> Wahh. fail is not fail.
07:47:54 <merijn> -XMonadFailDesugaring ;)
07:48:18 * ski . o O ( <https://www.linusakesson.net/programming/kernighans-lever/index.php> )
07:49:20 <dminuoso> merijn: Better. I defined a MonadFail instance, but not the fail method of Monad.
07:49:48 <dminuoso> And `fail` has this juicy default instance doing almost certainly the wrong thing.
07:49:52 <dminuoso> *default implementation
07:50:15 <dminuoso> So I thought I was using `fail` from MonadFail in all my code, and in some cases I was because of qualified imports.
07:50:26 <dminuoso> But in this particular spot I was accidentally tapping into Monad.fail
07:50:42 <dminuoso> Producing an unfortunate bottom in the middle of CPS weirdness.
08:26:45 <dminuoso> -- Given a string, replaces every word "the" with the word "a"
08:26:58 <dminuoso> Can you pull this off with lens?
08:28:12 <merijn> dminuoso: Can I? No. Can someone? Almost certainly :p
08:32:18 <Taneb> > "the fox is in the box" & iso words unwords . traversed . filtered (== "the") .~ "a"
08:32:21 <lambdabot>  "a fox is in a box"
08:32:24 <Taneb> dminuoso: how's that
08:32:55 <dminuoso> Taneb: impressive.
08:36:29 <Ariakenom> dminuoso: https://hackage.haskell.org/package/lens-regex-pcre
08:38:24 <Ariakenom> txt & regex [rx|the] . match .~ "a" -- or something
08:45:25 <Boarders> does anyone know a place that describes how to go about updating a package on hackage (all the work is already on github I just need to know what I need to do at the end)
08:46:03 <heatsink> Do you want to update your own package or someone else's?
08:46:09 <Boarders> my own
08:46:45 <heatsink> http://hackage.haskell.org/upload describes it
08:47:25 <merijn> Boarders: tbh, you can just run "cabal sdist" (or "cabal v2-sdist", as appropriate) and then use "cabal upload" :p
08:47:56 <Boarders> merijn : :)  thanks!
08:47:58 <merijn> That will upload a candidate package, you'll either have to publish the candidate from the webpage or explicitly publish when doing upload
08:48:39 <merijn> Boarders: Also, you can generate docs via "cabal v2-haddock --haddock-for-hackage" (dunno the pre-v2 equivalent) and upload the docs (also candidate by default) so you can check those out online too
08:48:58 <gentauro> finally found a good usage for `stack` v.2.x :o
08:50:12 <gentauro> install `git clone https://github.com/commercialhaskell/stack/ --branch v1.9.3` xD
08:57:53 <fuzzy_id> any ideas how i can decod a HashMap from a JSON object?
08:58:44 <heatsink> fuzzy_id: You could use the aeson library
08:59:12 <fuzzy_id> never mind, the problem lies somewhere else
09:10:43 <fragamus> regarding nomenclature, when I have a piece of data of type a, I want to call it an object of type a but object has other meaning. What is the preferred term?
09:11:36 <geekosaur> value, generally
09:11:37 <ski> fragamus : "value" ?
09:11:38 <dminuoso> fragamus: value or thing perhaps?
09:12:59 <fragamus> OK yeah I should have said value
09:13:15 <fragamus> thank you
09:13:22 <fragamus> I value your opinion
09:13:30 * ski objects
09:35:33 <duncan> Is there a way to constrain the type of a given datatype without using something like GADTs?
09:36:01 <saml> use kind?
09:36:12 <saml> what kind of constraints do you want?
09:36:36 <duncan> For instance, let's say I want to defined data `N t = N Q`
09:36:39 <duncan> whoops
09:36:55 <ski> @let data Foo = forall a. Eq a => MkFoo [a]
09:36:56 <lambdabot>  Defined.
09:36:57 <ski> @let data Bar a = Eq a => MkBar [a]
09:36:59 <lambdabot>  Defined.
09:37:03 <ski> like those ?
09:37:04 <duncan> For instance, let's say I want to defined `data N t = N t`, and I wanted to have that only for t being showable...
09:37:33 <duncan> s/defined/define/
09:37:38 <ski> (that's `ExistentialQuantification', btw)
09:38:08 <ski> @type MkFoo
09:38:09 <lambdabot> Eq a => [a] -> Foo
09:38:10 <ski> @type MkBar
09:38:14 <lambdabot> Eq a => [a] -> Bar a
09:40:15 <ski> @let fromFoo :: Foo -> [[Bool]]; fromFoo (MkFoo xs) = [[x == y | y <- [ys]] | x:ys <- tails xs]
09:40:18 <lambdabot>  .L.hs:165:29: error:
09:40:19 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
09:40:19 <lambdabot>      • In the second argument of ‘(==)’, namely ‘y’
09:40:30 <ski> er, sorry
09:40:33 <duncan> I think the latter would be more appropriate, as I'd prefer to avoid existential qualification
09:40:34 <ski> @let fromFoo :: Foo -> [[Bool]]; fromFoo (MkFoo xs) = [[x == y | y <- ys] | x:ys <- tails xs]
09:40:40 <lambdabot>  Defined.
09:41:20 <ski> @let fromBar :: Bar a -> [(a,[Bool])]; fromBar (MkBar xs) = [(x,[x == y | y <- ys]) | x:ys <- tails xs]
09:41:23 <lambdabot>  Defined.
09:42:24 <ski> > (fromFoo . MkFoo) "mississippi"
09:42:28 <lambdabot>  [[False,False,False,False,False,False,False,False,False,False],[False,False,...
09:42:29 <ski> > (reverse . fromFoo . MkFoo) "mississippi"
09:42:34 <lambdabot>  [[],[False],[True,False],[False,False,True],[False,False,False,False],[True,...
09:42:40 <ski> > (fromBar . MkBar) "mississippi"
09:42:46 <lambdabot>  [('m',[False,False,False,False,False,False,False,False,False,False]),('i',[F...
09:42:48 <ski> > (reverse . fromBar . MkBar) "mississippi"
09:42:52 <lambdabot>  [('i',[]),('p',[False]),('p',[True,False]),('i',[False,False,True]),('s',[Fa...
09:43:24 <ski> duncan : anyway, it's not really the datatype which is restricted, but the data constructor
09:43:39 <ski> (and yes, `ExistentialQuantification' is a misnomer)
09:44:29 <duncan> That is still appropriate, since I will be dealing with a set of things that are constrained in a class already.
09:44:41 * shapr hops quietly
09:44:45 <shapr> Good morning #haskell !
09:45:17 <ski> good evening, shapr :)
09:45:40 <duncan> Madainn mhath!
09:46:04 * ski mops quitely
09:46:36 <shapr> hyvää huomenta!
09:46:59 <duncan> Thanks ski - I'll play with that.
09:47:30 * ski idly misses esap
10:12:14 <halogenandtoast> I have a scotty app I want to test and I'd like to setup a sqlite database for the tests, I am using views and I'd like to run a sql file to generate them since I am using persistent and it knows nothing about views. I have the following: https://gist.github.com/halogenandtoast/123959cbc09a0065d756cc6713eacb25
10:12:22 <halogenandtoast> But it never looks like the migration file content is run
10:13:21 <Boarders> is there any way to have syntax highlighted examples at the top of a hackage library
10:13:49 <halogenandtoast> Actually using runStdoutLoggingT I do see the query in stdout
10:13:51 <Boarders> I tried putting it in the description code blocks but it doesn't syntax highlight
10:13:59 <halogenandtoast> but it doesn't appear in the sqlite file, hmmm
10:15:29 <sicklorkin> halogenandtoast: you may want to use ":memory:" isntead of creating and removing a file everytime..
10:15:52 <halogenandtoast> sicklorkin: is there an easy way to do that if app expects a connection pool?
10:15:52 <sicklorkin> halogenandtoast: what does doMigrations do?
10:16:08 <halogenandtoast> runs persistent's auto generated migrations from mkMigration
10:16:33 <Boarders> alternatively does anyone know how I can get proper spacing in a code block?
10:16:34 <sicklorkin> halogenandtoast: sure.. it's jsut the same as specifying a filename, or am I mis-remembering?
10:17:05 <halogenandtoast> quote> Note that this should not be used with the :memory: connection string, as the pool will regularly remove connections, destroying your database.
10:17:38 <halogenandtoast> That's my main concern there
10:17:53 <sicklorkin> halogenandtoast: I see.. but if you only have 1 worker it might work.. I think I used a top-level mvar for dealing with this
10:18:55 <halogenandtoast> sicklorkin: even using :memory: the view doesn't end up existing
10:21:33 <sicklorkin> halogenandtoast: I suggest selecting from those tables at each step - it' would be helpful to know if those migrations are commited.
10:22:34 <sicklorkin> halogenandtoast: afteer each runDb, are you able to insert into the tables added by the previous migration?
10:22:47 <chreekat> Boarders: https://haskell-haddock.readthedocs.io/en/latest/markup.html#code-blocks
10:22:59 <chreekat> not sure about "spacing"
10:23:13 <chreekat> and I don't think the hackage server does syntax highlighting, no
10:23:43 <chreekat> * or haddocks standalone, for that matter
10:23:57 <phadej> Boarders: something like https://hackage.haskell.org/package/vec ?
10:24:27 <phadej> https://hackage.haskell.org/package/vec-0.1.1.1/vec.cabal the trick is to say \ at the beginning of the line
10:25:46 <sicklorkin> halogenandtoast: Does sqlite supporting pooled collections?
10:26:43 <phadej> I fixed that in cabal-version: 3.0, but that one isn't yet released https://cabal.readthedocs.io/en/latest/file-format-changelog.html
10:26:49 <phadej> e.g. stuff like https://github.com/haskell/cabal/blob/master/Cabal/tests/ParserTests/regressions/indentation.cabal will work
10:27:31 <phadej> (reformatting roundtrips it to https://github.com/haskell/cabal/blob/master/Cabal/tests/ParserTests/regressions/indentation.cabal
10:27:43 <phadej> sorry, https://github.com/haskell/cabal/blob/master/Cabal/tests/ParserTests/regressions/indentation.format
10:28:53 <halogenandtoast> sicklorkin: the tables from persistent exist, the view from my custom migration does not
10:30:52 <sicklorkin> halogenandtoast: Does rawExecuteCount return a count > 0?
10:31:26 <Boarders> could someone remind me what I have to do to upload a candidate release?
10:32:58 <sicklorkin> halogenandtoast: I'm also wondering if you need to wrap the rawExecute in a transaction, or call transactionSave 
10:32:59 <halogenandtoast> sicklorkin: it returns 0, but I don't know that it would be modifying any rows by creating a view.
10:33:49 <sicklorkin> can you paste  the contents of genearte_rollup?
10:34:40 <shapr> ski: I miss lots of people, esap is one, musasabi, so many more
10:34:42 <halogenandtoast> sure, 1 sec, I know generate_rollup works, because I can .read it via sqlite and it does the right thing.
10:34:55 <shapr> tmoertel, martin sjögren, lots more people come to mind
10:35:49 <halogenandtoast> sicklorkin: https://gist.github.com/halogenandtoast/8d4f161edc5de0fed0f170e35301736a
10:36:47 <halogenandtoast> sicklorkin: the only thing I can think of is rawExecute only does the first line somehow.
10:38:14 <ski> shapr : oh, i had forgotten musasabi :/
10:38:31 <ski> shapr : StarvinMarvin
10:39:10 <shapr> ski: I remember too many people who aren't here, best I can do is celebrate the people who are here, new and old
10:41:40 * ski nods
10:42:39 <sicklorkin> halogenandtoast: where does foo_bar_consumptions come from?
10:49:21 <halogenandtoast> sicklorkin: I think the issue was what I described, I am not getting the issue anymore once I split on ";" and ran each line separately
10:53:41 <sicklorkin> halogenandtoast: fun.. :)
11:03:43 <rsoeldner> Someone here is using NixOS for iterative haskell development ? I do not want to always use cabal2nix. Can I enter a default dev. environment, is it possible to use an overlay ?
11:04:28 <boj> rsoeldner: we drop into a nix-shell and then use cabal v2-* commands to iterate on things
11:05:42 <rsoeldner> boj, and where did you specify ghc and packages ?
11:05:58 <boj> rsoeldner: let me show you an example shell.nix, one sec
11:07:04 <boj> rsoeldner: https://gist.github.com/boj/fb268565752d0ee856efd45e0b41c2be
11:08:02 <rsoeldner> boj, I see thanks
11:09:48 <boj> rsoeldner: you can easily pin to a non-system specified channel by invoking the shell with  nix-shell -I nixpkgs=https://github.com/nixos/nixpkgs-channels/archive/nixos-19.03.tar.g
11:12:45 <rsoeldner> boj, I see :-)
11:47:00 <VSpike> If I have an algebraic data type say `data Foo = Bar | Baz`, how can I filter a list of Foo only to get the Bars? Or check if they are all one type?
11:47:18 <VSpike> What I'm missing is the expression that says if this a Bar or a Baz?
11:47:28 <dminuoso> VSpike: You can use a list comprehension as the most compact way.
11:48:15 <dminuoso> % let ms = [Just 3, Just 1, Nothing, Just 10] in [x | Just x <- ms]
11:48:15 <yahb> dminuoso: [3,1,10]
11:49:16 <dminuoso> VSpike: Possibly with as-patterns if you want to preserve them
11:49:26 <dminuoso> % let ms = [Just 3, Just 1, Nothing, Just 10] in [e | e@(Just _) <- ms]
11:49:27 <yahb> dminuoso: [Just 3,Just 1,Just 10]
11:49:56 <dminuoso> Or if you want to write it in such a way that doesn't care about the arguments
11:50:03 <dminuoso> % let ms = [Just 3, Just 1, Nothing, Just 10] in [e | e@(Just{}) <- ms]
11:50:04 <yahb> dminuoso: [Just 3,Just 1,Just 10]
11:50:52 <dmwit> VSpike: The answer to the more general question is that the canonical way to branch on data is using `case`/`of` to pattern match on it.
11:51:11 <dmwit> (List comprehensions are a convenient syntax that are desugared by the compiler into `case`/`of` pattern match under the hood.)
11:51:51 <Ariakenom_> VSpike: you can always just write the function \foo -> case foo of {Bar -> True; Baz -> False}
11:55:56 <EvanR> "is" functions. 
11:55:59 <EvanR> :t isLeft
11:56:04 <lambdabot> Either a b -> Bool
11:56:48 <EvanR> usually i noticed another way to go about doing the discrimination, but that is a last resort
12:22:18 <gobby> When you specify a version in your cabal file for a direct dependency eg aeson, does this also force indirect dependencies on aeson to use the same version specified? 
12:23:09 <Philonous> gobby, Yes. cabal will try to find a set of versions that is mutually compatible. 
12:23:35 <gobby> Philonous, thanks
12:56:46 <dasli> I'm new to strictness optimizations
12:57:22 <dasli> Can somebody tell me if the expression x `seq` x makes sense?
12:59:15 <lyxia> it makes as much sense as "x"
12:59:38 <sclv> dasli: it doesn't do anything
12:59:59 <sclv> seq says "force the first before the second"
13:00:04 <sclv> but since they're the same, it doesn't help
13:01:19 <dasli> so when it's evaluated, it will just evaluate x as usual
13:01:24 <dasli> ok, makes sense
13:01:47 <dasli> ty
13:05:31 <c_wraith> sclv, sometimes it matters that seq doesn't actually imply an order. only "when this returns, both of its arguments will have been forced"
13:05:58 <c_wraith> sclv, usually that matters specifically for the cases pseq was added for. it does enforce an order.
13:09:01 <Ariakenom_> sclv: do you know the  difference between WHNF and NF?
13:09:52 <dasli> This must sound naive, but is there a way to force a value in the middle of any expression?
13:10:11 <dasli> That was my intention with "x `seq` x"
13:10:15 <merijn> Yes, no, maybe, depending on what exactly you want
13:10:25 <merijn> dasli: x `seq` x is a no-op
13:10:55 <int-e> a common case is  f $! x, which evaluates x before passing it on to f, when the (sub)expression (f $! x) is evaluated.
13:11:01 <int-e> @src ($!)
13:11:01 <lambdabot> f $! x = x `seq` f x
13:11:09 <merijn> "seq x y" means "IFF neither x nor y are bottom THEN when the result of "seq x y" is evaluated, both x and y will be evaluated"
13:11:34 <glguy> f $! x   doesn't promise to evaluate x before passing it on, it promises that evaluating the result of (f x) will also evaluate x
13:11:37 <merijn> dasli: Consequently "seq x x" means "IF the result of "seq x x" is evaluated, both x and x will be evaluated"
13:11:47 <int-e> (or, with BangPatterns: f $! (!x) = f x -- the parentheses are optional, only there for clarification
13:11:50 <int-e> )
13:11:58 <merijn> dasli: Of course, "seq x x" is only evaluated by the time 'x' would be evaluated *anyway* so it does literally nothing
13:12:19 <c_wraith> dasli, the only real way to make progress on evaluation order is to think in terms of dependencies.  when you evaluate an expression, what does that cause to get evaluated? seq is a tool for creating those dependencies.
13:12:34 <merijn> dasli: Essentially, seq is for tying the evaluation moment of some value to the evaluation of some other value
13:13:08 <dasli> OK, very interesting
13:13:37 <merijn> dasli: (Note the "if both x and y are not bottom" clause is relevant, because seq does *not* guarantee in which order x and y are evaluated)
13:13:49 <dasli> Right, I've read about that.
13:14:16 <merijn> dasli: It does not even guarantee that the order is static, so the compiler could even randomly pick one to evaluate first (that seems unlikely in the real world, but that's the only guarantee you get!)
13:14:43 <EvanR> so is there a way to evaluate one then another reliably
13:15:04 <dasli> I fixed a memory leak with a bang pattern (in an arrow syntax binding)
13:15:07 <EvanR> in case the order matters
13:15:19 <glguy> pseq
13:15:49 <int-e> merijn: I guess the compiler could realisitically duplicate the code (distributing over a 'case', say) and make different decisions for the order of evaluation for each copy. That could look random from the outside.
13:15:52 <dasli> I'm trying to see if I can move that down a level, so that every binding of the output of that action is forced.
13:16:23 <dasli> Is there a way to do that?
13:16:36 <sclv> Ariakenom_: is that a question you're asking because you want to know, or are you quizzing me or?
13:16:56 <sclv> i mean.. yes, i do. do you want an explanation or is there a specific question you're trying to sort out?
13:18:18 <merijn> dasli: If you want a truly big hammer, there's deepseq
13:18:23 <merijn> @hackage deepseq
13:18:23 <lambdabot> http://hackage.haskell.org/package/deepseq
13:18:30 <dasli> I guess the bang pattern is creating a dependency between the whole action and the bound output of that sub-action...
13:18:30 <merijn> dasli: But you should think long and hard before using that
13:18:59 <merijn> dasli: You could use strict fields in your datatypes
13:19:46 <merijn> dasli: "data Foo = Foo !Int" for example, makes the Int strict (i.e. "When you pattern match on Foo the Int will be forced too")
13:20:25 <EvanR> is there a performance difference between a strict pair and a regular pair that you only construct on pre-evaluated data
13:20:35 <merijn> dasli: Depending on what caused the space leak that can help. Useful (for example) for datatypes that you use when aggregating data in a fold or something
13:21:01 <dasli> This is just a Double. It gets packed up in a tuple, so I don't think I have any data structure fields to make strict
13:21:15 <merijn> EvanR: No, but if you use strict pair you could UNPACK and that has performance implications
13:21:31 <EvanR> ah so you need UNPACK
13:21:50 <merijn> dasli: You could always consider replacing the tuple with a datatype for this :)
13:21:58 <phadej> EvanR: yes, kind of. AndreasK is working on something which will make that difference more clear
13:22:12 <merijn> EvanR: UNPACK basically inlines the value inside the datatype, which removes a pointer indirection
13:22:36 <EvanR> does that only work on primitives
13:22:51 <phadej> (when you don't UNPACK)
13:23:01 <merijn> EvanR: No, but it only works on non-polymorphic fields
13:23:04 <dasli> ha, I guess that action's output type could be some custom wrapper around a Double
13:23:22 <EvanR> do you lose anything by unpacking then?
13:23:26 <dasli> Well thank you all, this was enlightening
13:23:30 <EvanR> why isn't it automatic
13:23:38 <merijn> EvanR: The ability to have lazy/infinite expressions in the field
13:23:55 <EvanR> you lose that when you put strict
13:24:24 <merijn> EvanR: True, but you can have strict, polymorphic values, and not unpacked polymorphic values
13:24:37 <merijn> Although I gues you could demand the compiler to take care of that
13:24:45 <EvanR> right so... if its not polymorphic (programmers choice, compiler knows) why no UNPACK automagically
13:24:59 <merijn> EvanR: Good question, I don't know the answer :)
13:25:42 <EvanR> maybe something to do with libraries
13:26:15 <EvanR> ABI stuff
13:27:23 <EvanR> binaries already out there which use indirection, and you wouldnt be able to tell whether or not it did by looking at the interface file
13:29:21 <EvanR> otoh you recompile everything anyway right
13:34:45 <Ariakenom_> sclv: sry i meant to ask dasli  ofc
13:38:22 <c_wraith> for what it's worth, ghc has automatically unpacked "small" strict data fields for several versions.
13:39:10 <c_wraith> where "small" roughly meant "has a single constructor with a single argument to that constructor."
13:41:37 <merijn> EvanR: GHC doesn't really have any ABI guarantees acros versions anyway :p
13:41:58 <merijn> Unless "ahahahaha" is a guarantee...
13:55:17 <Boarders> is there a good reason why Control.Parallel.Strategies doesn't define some parFmap :: Traversble t => Strategy b -> (a -> b) -> t a -> t b
13:55:24 <Boarders> entirely analogously to parMap
13:55:59 <Boarders> i.e. parFmap strat f = (`using` parTraversable strat) . fmap f
13:57:33 <lyxia> I think there's no good reason :)
14:10:59 <[exa]> Boarders: parFmap is hardly derivable from functor, but parTraverse could work
14:11:19 <Boarders> I never said it was derivable from functor
14:11:33 <Boarders> my implementation explicitly uses parTraversable...
14:11:50 <Boarders> the type signature does not have Functor in it
14:18:41 <[exa]> Boarders: btw someone mentioned a similar problem here today, with applying a function in chunks of tree contents
14:19:36 <[exa]> anyway, could you use the parMap over a lens?
14:21:59 <lyxia> I don't see how or why you would do that through a lens.
14:24:20 <lyxia> parFmap seems like a pretty good candidate for a patch to parallel.
14:33:14 <fresheyeball> what causes sparks to fizzle?
14:33:21 <fresheyeball> its lots of fizzle a bad thing worth addressing?
14:34:37 <c_wraith> a spark fizzles is the value is reduced to whnf before the spark starts.
14:34:40 <c_wraith> *if
14:35:03 <c_wraith> lots of fizzles means you're wasting time scheduling tasks that never get to run.
14:36:56 <infinisil> I'd like to thank whoever came up with this analogy with fire
14:37:06 <infinisil> Because it makes it very easy to understand :)
14:37:50 <int-e> it's called burning CPU cycles for a reason?
14:38:15 <VSpike> dminuoso dmwit Ariakenom : thanks all!
14:38:30 <infinisil> int-e: It all makes sense now
14:53:53 <eacameron> Is there a way to encode uniqueness types in Haskell? I looked briefly at regions but they didn't seem immediately useful for this, but I didn't spend long.
14:59:57 <lyxia> you can hide stuff in monads to ensure a particular usage pattern
15:02:16 <hpc> i think it's coming soon?
15:02:56 <hpc> https://github.com/ghc-proposals/ghc-proposals/pull/111
15:03:16 <Boarders> hpc: do you mean in the form of linear-haskell or something else?
15:03:34 <lyxia> eacameron: a poor man's lifetime tracker using indexed monads https://gist.github.com/Lysxia/6be7bd107e2b5863140acaa7556aa3a1
15:04:19 <eacameron> lyxia: Whoa amazing.
15:04:36 <dasli> exit
15:05:25 <hpc> nice
16:02:13 <wroathe> Is there a Monad m => t m a -> m a?
16:03:54 <wroathe> Actually, ignore that. I'm just seeing crosseyed.
16:23:23 <dminuoso> If we define a limit using a diagram D and a constant functor delta_c, how do you obtain a terminal object given a diagram from an empty category? The reason I ask, is because the constant functor wouldn't map to any apex, since it doesn't have any objects in its domain.
16:24:16 <dminuoso> It seems that this wouldn't be an issue if we defined it via kan extensions, but what about that route?
16:48:35 <EDM_Phd> 11,1 hey guys :))) have a great day and please have a look at my friends mixsets and house music productions!!!! THANKYOU so much!!! https://soundcloud.com/zilvr
16:48:35 <EDM_Phd> 8,1 hey guys :))) have a great day and please have a look at my friends mixsets and house music productions!!!! THANKYOU so much!!! https://soundcloud.com/zilvr
17:26:54 <dmwit> dminuoso: It's okay that the functor doesn't map to any object, because a limit is a cone, and a cone is an object together with a collection of morphisms.
17:27:13 <dmwit> dminuoso: So it is the cone, and not the diagram, that gives us the terminal object.
17:27:25 <sarahzrf> https://twitter.com/reduct_rs/status/1152008090650210304
17:27:29 <sarahzrf> er, wrong channel
17:27:43 <dmwit> dminuoso: Sorry, it is the cone, and not the *functor*, that gives us the terminal object.
18:23:24 <Axman6> )is there a package which can generate catamorphisms for a given data type? $(makeCata 'Maybe) => <define maybe>, data Foo a = Nope | Error String | Ok a; $(makeCata 'Foo) => foo :: b -> (String -> b) -> (a -> b) -> Foo a -> b; foo = ...
18:27:46 <c_wraith> Axman6, I'm sure there is. somewhere.
18:28:31 <Axman6> https://hackage.haskell.org/package/catamorphism
18:28:41 <Axman6> annoyingly searching hackage for just cata didn't find that
18:29:15 <c_wraith> I mean, I'm sure I've seen a library that did that. but I can't remember the name.
18:30:26 <c_wraith> well, you could use the recursion-schemes package. it has th to make base functors, which gives you cata
18:34:54 <yoav__> Say I want to use interact with a function of type `String -> IO String`. Is there a way to do so?
18:35:16 <Axman6> :t interact
18:35:19 <lambdabot> (String -> String) -> IO ()
18:35:23 <Axman6> nope
18:35:32 <Axman6> but you can use getContents
18:35:37 <yoav__> Yeah, I know of other ways
18:35:40 <Axman6> :t getContents
18:35:43 <lambdabot> IO String
18:35:52 <Axman6> you _could_ use unsafePErformIO, but don't
18:36:07 <yoav__> I thought maybe there was a way to "bind" the return value of my function for use with interact
18:36:15 <yoav__> But I guess that's just unsafePerformIO
18:36:16 <yoav__> thanks!
18:38:59 <___laika> im getting heap overflows in ghc 865 when i new-build a module with a type hole in it...
18:45:01 <Axman6> It's very hard to allocate a hole, malloc(-sizeof(blackhole))
18:47:29 <yoav__> I don't know why, but you just reminded me of an intern trying to allocate a 20MB char[] on the stack
18:47:48 * ___laika sweats
19:05:39 <cheater> i have 5 different ADTs. each has ~10 constructors, and each of these constructors contains another ADT. So there's data Foo = FooA FooATy | FooB FooBTy | ... | FooJ FooJTy, and then I have data Bar, data Baz, etc. The types Foo, Bar, and Baz have somewhat different constructors, and FooA and BarA are different. I want to make data Quux together with data QuuxA ... data QuuxJ so that Foo, Bar, Baz ...
19:05:45 <cheater> ... can be converted to Quux recursively, and also I want to be able to convert FooA, BarA, BazA to QuuxA and so on. how do I best go about this?
19:10:17 <jackdk> a typeclass HasQuux a which provides a Lens' a Quux?
19:11:12 <cheater> i'd like to not use lens
19:12:37 <jackdk> I disagree with that preference, but you could have the typeclass define a function instead. It's lawless though, I think
19:13:23 <jackdk> If the typeclass defines an update :: Quux -> a -> a then you at least have lens-style laws for it?
19:17:57 <cheater> i'll think about this, thanks
19:18:11 <cheater> but tbh i think i'm looking for something different
19:22:51 <lyxia> Is FooA a type or a constructor? I'm a bit confused about your description.
19:24:01 <lyxia> It sounds related to generics, but I'm also biased since I solve everything with generics.
19:42:09 <shafox> in ghci how do i see what is the generated code for the deriving Eq ? 
19:48:12 <halogenandtoast> I have a couple of questions here: https://gist.github.com/halogenandtoast/eeacb03708a7c92bb602ad1cbc1bb9e5, firstly trying to better understand the error, I am not sure what causes the SpecWith type issue and was wondering if anyone could help me to grok it
19:48:31 <halogenandtoast> Secondly, I wonder if I am just setting this up entirely wrong and if there is a better way to do this
19:49:47 <halogenandtoast> updated to have the Config definitions
19:50:04 <halogenandtoast> If they weren't obvious
19:51:46 <cheater> lyxia: FooA is a constructor that contains a single value of type FooATy.
19:52:06 <cheater> sorry, let me reword what i wrote.
19:52:50 <cheater> I want to make data Quux together with data QuuxATy ... data QuuxJTy so that Foo, Bar, Baz can be converted to Quux recursively, and also I want to be able to convert FooATy, BarATy, BazATy to QuuxATy and so on. how do I best go about this?
19:53:03 <cheater> ^ corrected version of my question
19:53:42 <cheater> shafox: i don't know about in ghci, but maybe you could look at the core?
19:55:13 <gabbiel> so I have this class: class TooMany a where tooMany :: a -> Bool
19:55:51 <halogenandtoast> I solved my issue
19:56:05 <gabbiel> and I wanted to instance (Int,String) for it, but it won't allow me even though (Int,String) has kind *, it instead says I need to use FlexibleInstances
19:56:07 <halogenandtoast> I forgot to remove the pure at the end of my spec
19:56:57 <gabbiel> why can't I just instantiate the class normally
20:01:08 <glguy> gabbiel: instances are for types of the form of a type constructor applied to zero or more type variables
20:01:21 <glguy> So you can make an instance for (a,b)
20:02:18 <glguy> Int is a type constructor and String is a type synonym and also not a variable
20:06:08 <gabbiel> but (Int,String) is a type, whose constructor has 0 variables
20:07:24 <glguy> (Int, String) is: (,) Int String
20:07:50 <glguy> You can only make instances for types, so that doesn't help us
20:08:01 <glguy> There are 3 constructors there: (,), Int, and String
20:08:15 <gabbiel> they are called type constructors right?
20:08:17 <glguy> To make an instance you get one constructor first followed by variables
20:08:27 <gabbiel> (,) constructs a new type
20:09:02 <glguy> They are types and they are constructors, two different categories of things
20:10:10 <glguy> (,) Int String  isn't of the form: constructor applied to variables, it's: (constructor applied to constructor) applied to constructor
20:11:14 <ski> (well, `String' is two constructors .. not that it matters much, here)
20:11:28 <glguy> Yeah, that's the type synonym aspect I mentioned earlier
20:11:44 <glguy> type synonyms don't feature in instances without extensions
20:12:40 <lyxia> shafox: there's the -ddump-deriv command line option
20:13:34 <shafox> lyxia, that would be while building the project/module right ? 
20:13:36 <gabbiel> i just did this and it allowed me: newtype Foo = Bar (Int,String) 
20:13:50 <gabbiel> instance TooMany Foo where tooMany _ = True
20:14:27 <glguy> Yup, Foo is a type constructor and it's applied to zero type variables, so that works
20:15:36 <sarahzrf> gabbiel: note that if you did "type Foo = (Int, String)", that wouldn't work, because you wouldn't be introducing a new type constructor
20:16:14 <halogenandtoast> I've updated my gist (hspec, scotty, persistent), are there any suggestions for how to clean this up? https://gist.github.com/halogenandtoast/eeacb03708a7c92bb602ad1cbc1bb9e5
20:16:29 <lyxia> shafox: yes. I thought you meant seeing the result of a deriving clause you type into ghci. 
20:17:15 <shafox> lyxia, alright. let me try that.
20:17:16 <gabbiel> so I can instantiate (,) a b but not (,) Int String 
20:18:16 <gabbiel> I guess there would be a problem if (,) a b was instantiated but then I instantiated (,) Int String too
20:18:39 <gabbiel> how do I enable FlexibleInstances in the repl?
20:18:48 <halogenandtoast> :set -XFlexibleInstances
20:18:58 <gabbiel> thanks
20:19:16 <halogenandtoast> No problem, always happy when I know the answer to a question here.
20:21:28 <Saulzar_> Hm. if I use cabal new-build foo --constraint='foo +debug'  - it does not complain if the flag debug does not exist?
20:22:18 <Saulzar_> Nor --flag this_flag_does_not_exist.. 
20:22:50 <gabbiel> I see the merit behind banning instantiation of constructed types
20:27:55 <heatsink> What do you call a type that's not in Type, like Either Int?  Is it still called a type?
20:28:09 * ski would say, yes
20:28:34 <gabbiel> heatsink: its not a type, its a constructor
20:28:35 <ski> (a non-concrete type. a type function, in this case)
20:28:38 <glguy> gabbiel: no
20:28:49 <glguy> gabbiel: being a constructor doesn't have to do with a type's kind
20:28:56 <ski> imho, `Either' and `Int' are type constructors, but `Either Int' isn't
20:29:09 <ski> (but in older terminology, it would be called a "type constructor", yes)
20:29:32 <gabbiel> glguy: how so, :k (,) is * -> * -> *, right, then, :k (,) Int is * -> *
20:29:36 <ski> (hence calling `Functor',`Monad' "constructor classes")
20:29:57 <glguy> gabbiel: the kind doesn't matter, Int is a constructor and its kind is *
20:30:18 <glguy> There are constructors and there are variables
20:30:21 <heatsink> Alright, I like "concrete" and "non-concrete"
20:30:25 <glguy> Constructor variable
20:30:41 <gabbiel> * means a concrete type
20:30:58 <gabbiel> a type which has values
20:31:26 <ski> (a type which is *capable* of having values, i'd say)
20:31:36 <gabbiel> Int is a nullary constructor, aka a concrete type
20:31:41 <ski> (see `Void')
20:31:51 <glguy> But "(,) Int" is not a constructor
20:31:54 <ski> s/aka/and/
20:31:57 <glguy> it's a type expression of one constructor applied to another
20:32:16 <gabbiel> it is, its waiting for a concrete type as input in order to construct a type
20:32:23 <glguy> No, that's a category error
20:32:29 <glguy> constructor tells us what kind of name something is
20:32:34 <glguy> (,) Int isn't a single name
20:32:40 <glguy> it's two names
20:33:01 <ski> `f', in `f a', isn't a constructor
20:33:26 <glguy> Yeah, good contrasting example
20:33:36 <gabbiel> thats like saying "(\x -> \y -> x + y) 1" isnt a function
20:33:44 <glguy> neither the f nor the whole of 'f a' are "constructors"
20:33:51 <ski> that `f' *is* a type function, though
20:33:54 <ski> as is `(,) Int'
20:34:15 <gabbiel> glguy: its an anonymouse constructor
20:34:18 <glguy> gabbiel: You've got the terminology mixed up, try and work with us to understand what's happening her
20:34:20 <glguy> here
20:34:28 <glguy> gabbiel: No, there are no anonymous constructors
20:34:35 <gabbiel> what do you mean category error
20:34:38 <ski> glguy : you might just as well say `Just False' is an "anonymous (data) constructor"
20:34:38 <glguy> constructor doesn't mean 'function'
20:34:49 <glguy> glguy: I wouldn't say that
20:34:51 <glguy> ski*
20:35:02 <ski> er, sorry, that was meant for gabbiel
20:35:07 <glguy> gabbiel: names can be constructors or variables
20:35:16 <glguy> gabbiel: so you can't apply the "constructor" label to something that isn't a name
20:35:24 <ski> (a single name)
20:35:51 <glguy> (Maybe Int) also isn't a variable
20:37:41 <gabbiel> why are they called constructors if they dont construct types then
20:38:17 <glguy> Similar to how True is a constructor of type Bool, it constructs a Bool
20:38:23 <glguy> Int is a constructor of kind *
20:38:32 <gabbiel> im talking about type constructors, not data constructors
20:38:40 <glguy> It works the same at both levels
20:39:31 <glguy> The distinction between constructor and variable is useful because in pattern contexts we know which thigns are being bound and which are being matched
20:39:45 <glguy> so whether that's a pattern in a case or a pattern in a typeclass instance
20:40:04 <gabbiel> what's the takeaway here, that applied constructors arent constructors because they have no name?
20:40:47 <glguy> because constructor is a property of names and a name applied to a name isn't a name
20:40:57 <ski> constructors are supposed to be "atomic"
20:41:24 <ski> `Just False' is not a constructor, it's a constructor applied to a constructor
20:41:35 <ski> `Maybe Bool' is not a constructor, it's a constructor applied to a constructor
20:41:44 <gabbiel> and you're saying it's useful to think of it this way because of patterns?
20:41:49 <gabbiel> explain more of these patterns
20:42:20 <ski> patterns mostly consist of constructors and variables, applied to each other
20:42:26 <gabbiel> ski: I agree because at that point, you just have a fully realized value or type
20:42:46 <gabbiel> but when Either Int still awaits another type
20:42:47 <ski> `Node False' is not a constructor, it's a constructor applied to a constructor
20:42:57 <ski> `Either Int' is not a constructor, it's a constructor applied to a constructor
20:43:20 <ski> both of these happen to be *functions* (one a value function, the other a type function)
20:43:33 <ski> but that's not a syntactic issue
20:43:34 <gabbiel> I kind of understand now
20:43:46 <ski> whether something is a variable, or is a constructor, is a syntactic issue
20:44:00 <gabbiel> because if Either Int was a constructor, then I should be able to do this f ((Either Int) a) = undefined
20:45:03 <ski> @let class Foobar a
20:45:04 <lambdabot>  Defined.
20:45:06 <ski> @let instance Foobar ((Either Int) a)
20:45:07 <lambdabot>  Defined.
20:45:21 <ski> the latter is the same as `instance Foobar (Either Int a)'
20:46:05 <ski> @type Node
20:46:08 <lambdabot> a -> Forest a -> Tree a
20:46:56 <gabbiel> my example was bad, I meant to show a function type 
20:47:19 <gabbiel> but then how could I take a (Either Int) as input
20:47:36 <ski> you can't take an input of that type, since that's not a concrete type
20:49:01 <ski> just as you can't say `foo :: Maybe' or `bar :: []'. you have to say `foo :: Maybe T' or `bar :: [] U' (which can be written with syntactic sugar as `bar :: [U]'), for some (concrete) types `T' or `U'
20:49:23 <ski> you can't say `bar' is a "list of". a list of *what* ?
20:50:37 <ski> `[]', and `Maybe', are "incomplete types", or "non-concrete types", they're still missing some specification of some parameter type(s), after which they'll describe concrete types, which are capable of being inhabited, which are inhabitable
20:51:28 <ski> (similarly `Either Int' is incomplete in the same sense. is a parameterized type. is a type function. is not a concrete type)
20:51:29 <gabbiel> but what if we could take constructors as inputs, what are the ramifications of that
20:51:35 <gabbiel> *type constructors
20:51:45 <ski> see the `Foobar' type class above
20:54:19 <gabbiel> so applied Constructors aren't constructors because they can't represent a type which we can work with
20:55:22 <ski> i don't know what you mean by that
20:55:37 <ski> constructors are names. applied things are not names
20:56:30 <gabbiel> yeah like applied Either, Either is a name, right
20:56:53 <ski> you could represent types in an ADT, like `data Typ = Var TyVar | Con TyCon | App Typ Typ'
20:57:19 <ski> `Var tyvar' represents type variables, like `a',`f',`foo'
20:57:44 <ski> `Con tycon' represents type variables, like `Int',`Either',`(->)',`[]',`(,,)'
20:58:08 <ski> er, sorry, the latter should be "represents type constructors"
20:59:19 <ski> `App ty ty0' represents type applications (of two types, whatever they might be), like `Maybe Int',`Either a ((->) b Bool)',`f []'
20:59:46 <ski> `Either' is a name, yes. a type constructor
21:01:13 <gabbiel> if its applied then its not a real type, isnt that what you guys have been saying all along
21:01:20 <gabbiel> i get the first two parts though
21:04:42 <ski> i don't see how you could get from what we've been saying, to "if its applied then its not a real type"
21:05:05 <ski> what's a "real type" ?
21:08:31 <gabbiel> a set that can have more than 0 elements
21:09:10 <ski> `Maybe Bool' clearly has more than zero inhabitants
21:09:20 <ski> (yet, it's an "applied type", no ?)
21:09:48 <gabbiel> i said that because u said that Either Int isn't a constructor, yes, therefore its not a type
21:10:12 <ski> it is a type
21:10:36 <gabbiel> how so, what values does it have
21:10:37 <ski> `Just False' isn't a data constructor, but it's still a value. ditto for `Node EQ'
21:11:12 <ski> not all types are inhabitable
21:11:14 <gabbiel> Maybe in Maybe Bool is fully applied, so it is a type
21:11:17 <ski> only concrete types are
21:11:23 <glguy> gabbiel: No, that's not how "type" works
21:11:26 <ski> `Maybe' is also a type, but not a concrete type
21:13:00 <gabbiel> so if types have type constructors, and partially applied constructors are types, then why can't partially applied constructors have type constructors 
21:13:32 <ski> what do you mean by "types have type constructors" ?
21:13:52 <gabbiel> data Bool = True | False
21:14:01 <gabbiel> Bool is a type, with type constructor Bool
21:14:26 <ski> `Bool' is a type, that is also a type constructor
21:14:35 <ski> i wouldn't say it "has" a type constructor
21:14:52 <gabbiel> its a nullary type constructor
21:15:19 <ski> if you insist on using that terminology, sure
21:15:30 <gabbiel> and also, if partially applied constructors are types, then why can't I take them in as input to functions
21:15:33 <ski> (that's a separate issue)
21:15:54 <glguy> You can take "partially-applied" constructors as arguments to functions
21:16:05 <ski> because `(->)' is a type function that expects *concrete* types as arguments
21:16:23 <glguy> If you had a type A :: (* -> *) -> * ; then you could have:   A (Either Int)
21:16:26 <ski> you can't say `(->) [] Maybe', that's a kind error. `[]' and `Maybe' doesn't have kind `*'
21:16:59 <ski> but `(->) Int (Maybe Bool)' is fine, of course
21:17:49 <ski> it's okay to say `foo :: Int -> Maybe Bool', having input of type `Int', and output of type `Maybe Bool' (both those must be concrete types, since we're potentially talking about values of these types)
21:18:00 <gabbiel> Maybe is fully applied there though
21:18:09 <ski> sure
21:19:40 <gabbiel> my head is spinning. thanks for the lessons ski & glguy
21:19:53 <ski> unlearning can be hard
21:19:59 <ski> np, yw
21:20:36 <nshepperd> for the terminology, i would like to call both Maybe and Maybe Int 'types' but say that only Maybe Int is a 'habitable type'
21:21:04 * ski nods
21:51:53 <monochrom> At some point you have to use kinds.
21:52:52 <monochrom> Just like after saying "f is a function, g is a function, now pass g to f, f g is still a function..." for several years, it stops scaling and you need to use actual types.
21:54:12 <int-e> monochrom: Just pick a domain with D isomorphic to D -> D.
21:54:45 <monochrom> There you don't even say "f is a function".
21:55:13 <int-e> f is a value, g is a value, f g is still a value
21:55:21 <int-e> you're right of course.
21:56:46 <monochrom> I haven't seen an unkinded type system such that if T, U are types than T U is a legal type no questions asked.
21:57:40 <int-e> Well, models of untyped lambda calculus don't need types.
22:05:26 <fresheyeball> is there a way I can say "if any of these patterns match x else y"?
22:05:46 <fresheyeball> I would prefer not to have a giant case statement where every branch is the same
22:10:52 <ggole> Or-patterns? I don't think they've made it into Haskell yet.
22:11:19 <fresheyeball> ggole: like a firstclass pattern
22:11:45 <fresheyeball> I would like something like `all (isMatch x) (ps :: [Pattern])`
22:12:01 <heatsink> The usual workarounds are, have all the branches call an an auxiliary function
22:12:14 <fresheyeball> actually `any (isMatch x) (ps :: [Pattern])` in my case
22:12:16 <heatsink> or have an auxiliary function that returns True for the matching cases and False otherwise
22:12:42 <int-e> patterns certainly aren't first class
22:12:53 <ggole> Yeah, reifying the match result as a datatype is probably reasonable
22:13:33 <int-e> Hmm is Arcaelyx just messaging me or are they spamming people?
22:15:57 <Arcaelyx> Nope, just a message. You helped out with a math problem earlier.
22:28:48 <fresheyeball> ggole: what would that look like?
22:32:27 <ggole> A pattern C a b becomes a function \x -> case x of C a b -> Just (a, b) _ -> Nothing (or something like that)
22:34:33 <fresheyeball> ggole: you mean make a `maybe` style eliminator function for my data type that has a function for each pattern
22:35:08 <ggole> Yep.
22:36:11 <ggole> You can bundle multiple matches within the same function, too (as long as they have the same result)
22:38:12 <fresheyeball> ggole: I think that is worse actually
22:38:28 <fresheyeball> If I use a case statement where all branches match except for thlast
22:38:35 <fresheyeball> I have _ as a wildcard
22:39:03 <fresheyeball> if I make a function for each pattern, then I end up with having no _ and need to pass True or False for each member
22:39:11 <fresheyeball> my whole goal is to have less redudancy 
22:39:18 <fresheyeball> oh wait
22:39:23 <fresheyeball> I bet TH can do this
22:39:49 <MarcelineVQ> so what is the actual code
22:40:35 <ggole> _ -> foo is \_ -> foo
22:40:59 <ggole> No, sorry, \_ -> Just foo
22:41:40 <fresheyeball> https://lpaste.com/Pv0S2Aem3I
22:41:55 <fresheyeball> I have a bunch of functions like this
22:42:09 <fresheyeball> its just describing that some of these constructors are in certain set
22:42:16 <fresheyeball> in this case the set of all long commands
22:42:33 <fresheyeball> it works fine but is not ergonimic 
22:42:50 <ggole> Or-patterns would be nice there, for sure
22:49:20 <fresheyeball> ggole: https://hackage.haskell.org/package/OrPatterns-0.1/docs/OrPatterns.html
22:49:54 <dminuoso> dmwit: Mmm, so in Bartosz lectures the cone was defined as a natural transformation between ⌜delta_c :: I -> C⌝ and ⌜D : I -> C⌝
22:51:21 <gabbiel> is there a function like filter but it does the opposite (i.e. deletes items from a list)
22:51:54 <dminuoso> gabbiel: Invert the filter function using `not`
22:52:24 <dminuoso> % filter (not . even) [1,2,3]
22:52:24 <yahb> dminuoso: [1,3]
22:52:46 <dminuoso> Or I guess predicate is a more suitable name than "filter function".
22:54:06 <gabbiel> i did that initially, but just for style purposes, i'd rather have remove (==1) xs than filter (not . (==1)) xs
22:54:30 <dminuoso> gabbiel: Then write ⌜remove p = filter (not . p)⌝ ?
22:55:02 <int-e> . o O ( filter (/=1) )
22:55:15 <gabbiel> yeah i have it in my local where clause: remove = filter . not
22:55:43 <dminuoso> gabbiel: That wouldn't even typecheck.
22:56:02 <dminuoso> gabbiel: I urge you to ponder about what's wrong with that.
22:56:05 <gabbiel> i meant negate or something
22:56:32 <gabbiel> i was thining lisp
22:57:15 <gabbiel> is there a function that does the predicate inverse of another in haskell?
22:57:38 <gabbiel> i.e. negate f = not . f
22:57:42 <dminuoso> gabbiel: Precomposing with ⌜not⌝
22:57:57 <int-e> :t negate -- beware of potential confusion
22:57:59 <lambdabot> Num a => a -> a
22:58:22 <gabbiel> yeah sorry its cause negate in lisp does this. i recalled that negate is for numbers in haskell
22:59:06 <int-e> We can write  (not .)  or  (.) not, it doesn't really deserve a name. (A similar argument can be made (and most likely has been made) against `remove`)
22:59:36 <dminuoso> For what its worth, I think ⌜filter⌝ has a relatively poor name leading to easy boolean blindness/confusion
23:00:04 <gabbiel> int-e: then why does /= exist when == does
23:00:43 <dminuoso> gabbiel: Mostly because asking for inequality is a frequent thing to do?
23:00:56 <int-e> gabbiel: good question. But /= is very common and not (a == b)  needs annoying parentheses. It pulls its weight.
23:01:06 <jackdk> There's a "someone-or-other threshold" that describes this, but I can't remember the name
23:01:11 <gabbiel> dminuoso: yeah filter is confusing. filter even makes me think its filtering out the evens and leaving the others 
23:01:23 <cocreature> jackdk: fairbairn threshold?
23:01:28 <dminuoso> ^-
23:01:32 <jackdk> yeah
23:01:43 <gabbiel> that argument for /= is why remove needs to exist
23:01:58 <jackdk> https://wiki.haskell.org/Fairbairn_threshold
23:02:01 <jackdk> thanks cocreature 
23:02:29 <dminuoso> gabbiel: The thing is, it's too trivial to use existing combinators that exist on the spot.
23:02:53 <dminuoso> gabbiel: For predicates that are commonly negated it's usually customary to also provide the negated predicate.
23:03:20 <dminuoso> gabbiel: e.g. we provide you with both `==` and `/=`. We also provide you with both `odd` and `even`
23:03:22 <gabbiel> dminuoso: its also trivial to compose (==) with not
23:03:34 <int-e> gabbiel: it needs parentheses
23:03:38 <cocreature> we provide you with null but you don’t get notNull (in base) :)
23:03:46 <int-e> Though that may not seem awful to somebody with a Lisp background.
23:04:07 <gabbiel> int-e: now you know why i need remove, its annoying having to type parentheses
23:04:17 <dminuoso> gabbiel: My point is, if that precomposition is a common thing then you might as well give it a slightly more concise name.
23:04:20 <int-e> gabbiel: There's no hard rule here, obviously. Just various tastes and conventions and a lot of history.
23:04:47 <gabbiel> int-e: touche. but parentheses in lisp are different to me than parentheses in haskell
23:04:57 <int-e> By now it's a safe bet that we'll never have `remove :: (a -> Bool) -> [a] -> [a]` in Data.List.
23:05:24 <int-e> Maybe you'd still have had a chance in 1997.
23:05:40 <dminuoso> I suppose it's a difficult thing to decide which combinator to add, and which not.
23:05:44 <int-e> :t nub
23:05:47 <lambdabot> Eq a => [a] -> [a]
23:06:00 <dminuoso> I have a feeling that people frequently propose combinators be added to base on the basis that they are using them a lot in that current project.
23:06:11 <int-e> (still one of the most obscure names in the standard library to my mind)
23:06:28 <glguy> :t until
23:06:30 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
23:06:34 <dminuoso> For me at least, a lot of projects have certain "attitudes", where in any given project there's one particular set of combiantors I use very frequently.
23:07:06 <int-e> :t forM -- we got this though, long after mapM. (And I'm a happy user of forM)
23:07:10 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
23:07:21 <int-e> :t mapM
23:07:23 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:08:47 <gabbiel> can't wait to learn about Monads and use those
23:09:12 <dminuoso> gabbiel: I wouldn't worry too much about that M word. There's too much unhelpful fuzz on the internet about it. :(
23:09:34 <dminuoso> gabbiel: Im willing to bet you can use monads *just fine* already.
23:12:53 <gabbiel> dminuoso: Only IO a little bit but only using the do syntax. I want to understand them without the do syntax
23:13:11 <dminuoso> gabbiel: It's just visually different.
23:13:51 <dminuoso> ⌜do { x <- getLine; putStrLn ("Hello, " ++ x) ⌝ is the same as ⌜getLine >>= \x -> putStrLn ("Hello, " ++ x)⌝
23:14:14 <dminuoso> gabbiel: In fact, you can line things up, such that it just looks like <- is flipped and becomes >>=
23:16:51 <jackdk> There are rules about how to turn do-notation into calls to >>= or >>: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14 (read the "Translation:" box and the example immediately above it). It's syntactic sugar but not magic
23:16:59 <dminuoso> gabbiel: https://gist.github.com/dminuoso/96ff841d49a6f36df51804b6d1e1f775
23:17:53 <gabbiel> i understand bind just fine. I just want to know what monads really are, why they are bound by the monad laws, when to make something a monad, etc.
23:18:19 <dminuoso> gabbiel: The best advice I can give you, is keep using different monad instances.
23:18:31 <dminuoso> Over time you will develop intuition what the common pattern is.
23:18:45 <jackdk> use _and write_ the functor/applicative/monad instances for different types
23:19:29 <dminuoso> gabbiel: And as for the last part, it's not about when to "make something a monad"
23:19:37 <gabbiel> dminuoso: It seems thats the only path to real understanding. I hope to do some projects that will help me achieve that
23:19:46 <dminuoso> gabbiel: It's rather that you write a set of 2/3 functions, and realize that this is actually the Monad interface.
23:20:11 <dminuoso> So "making a monad" is something you do by writing 2 functions that follow a certain shape and have some properties.
23:20:14 <int-e> Learn examples first. Reader, State, Writer, List... those are all very useful monads, and you don't really have to know what a monad is in order to use them.
23:20:35 <int-e> (IO is an example, of course, but not an instructive one.)
23:21:47 <jackdk> getting practiced with the instance for ((->) t) is really useful, IMO
23:22:01 <int-e> And then transformers, which is the first time monad laws really start to matter (since transformers should better preserve those...).
23:22:13 <gabbiel> functions are monads? what?
23:22:13 <jackdk> oh, and proving the (>>=), (>=>) and join are equivalent, by writing each in terms of the others
23:22:16 <int-e> jackdk: Yeah that's the reader monad.
23:22:33 <dminuoso> gabbiel: It's sort of when you write a function ⌜thingsAreEqual :: a -> a -> Bool⌝, at which point I will tell you "Hey, what you wrote is actually a valid implementation for Eq!"
23:22:44 <int-e> (though it may be easier to first deal with the newtype version: newtype Reader r a = Reader { runReader :: r -> a }.
23:22:45 <dminuoso> gabbiel: You don't ever thing about "how do I turn something into Eq" right?
23:23:01 <jackdk> int-e: yes, and working through it with in the ((->) t) form means internalising that (->) is a type constructor
23:23:17 <dminuoso> gabbiel: A monad could be thought of as just a pair of two functions, yes.
23:23:41 <dminuoso> gabbiel: A monad is completely defined by having two functions of a particular shape with some properties.
23:23:48 <dminuoso> Nothing more.
23:23:56 <dminuoso> It's just an interface, and instances serve as implementations of that interface.
23:23:58 <int-e> > join (*) 5 -- understanding the (->) r  version of the reader monad is essential for understanding pointless, err, pointfree code.
23:24:00 <lambdabot>  25
23:24:57 <dminuoso> gabbiel: The difficult part is understanding what that interfaces abstracts over, and that is actually difficult and very hard to explain. Luckily you don't need to understand that at all in order to use any particular implementation, and the understanding comes on its own without you trying to learn it.
23:25:15 <gabbiel> im saving this convo, will be helpful later for sure
23:25:41 <dminuoso> But like int-e said, you need to write instances and use them in order to build up intuition.
23:27:46 <gabbiel> im scared of monads though. people make it seem that it's real hard to understand
23:27:54 <int-e> dminuoso: I think that was jackdk 
23:28:04 <dminuoso> @where monad.tutorial.fallacy
23:28:04 <lambdabot> I know nothing about monad.tutorial.fallacy.
23:29:09 <dminuoso> gabbiel: But yes, many people do. 
23:29:25 <int-e> https://wadler.blogspot.com/2013/11/the-monad-tutorial-fallacy.html
23:29:55 <int-e> (love the picture)
23:30:03 <jackdk> yeah don't be scared. Just write some instances of different types - ((-> t) (or Reader), Maybe, [], and State would be a good start - and write some combinators from Control.Monad as well (this practices using the interface without thinking about any particular implementation)
23:30:05 <dminuoso> gabbiel: ^- this might help you understand why so many monad tutorials are terrible/hard/useless.
23:30:11 <dminuoso> The link that int-e shared I mean. :)
23:30:22 <int-e> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ is the right link
23:30:25 <dminuoso> Oh.
23:30:27 <dminuoso> That. :)
23:30:43 <jackdk> I would also suggest that repeating this strategy for Functors and Applicatives first builds the intuition in smaller chunks
23:31:06 <dminuoso> Possibly learning Semigroup/Monoid might help you build up skills in understanding abstract patterns as well.
23:31:14 <int-e> The(!) other good monad tutorial is http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html ;-)
23:31:27 <gabbiel> that's the thing, I thought I understood Functors, but apparently they aren't containers like I thought they were
23:31:38 <dminuoso> gabbiel: Honestly, this learning in stages is normal!
23:31:40 <gabbiel> so I'm going to have to start over from there
23:31:51 <jackdk> from the yorgey post > The heart of the matter is that people begin with the concrete, and move to the abstract. < this is so true
23:31:57 <dminuoso> gabbiel: You have some revelation, realize your older models were somewhat incorrect not ideal, you adjust your mental model, you develop new trains of thoughts..
23:32:09 <jackdk> gabbiel: don't think of it as "start over" - you've learned some things, and now you learn more things
23:32:12 <dminuoso> And then after some time, you have another and reach a new plane of understanding.
23:32:18 <int-e> jackdk: That is why I stressed the examples.
23:32:33 <dminuoso> gabbiel: It's an integral part of learning.
23:32:59 <jackdk> int-e: yep, I agree with you that it's a good idea
23:34:47 <dminuoso> gabbiel: Im for example currently at the brink of breaking into a new level of understanding of some other pattern/typeclass. It took me months of writing different code, exchanging thoughts with people, studying some category theory. My old thoughts will not be invalidated, it's just that I gain the ability to look at things from a different perspective.
23:35:19 <dminuoso> gabbiel: Over the past 12 months I must have had at least half a dozen "Ohh.. now I think I understand" moments when my horizon broadened.
23:35:30 <dminuoso> But I didn't force it, it just happened on its own. :)
23:36:17 <gabbiel> hope it doesnt take me long to get it though
23:36:27 <gabbiel> i wont force it though
23:36:35 <dminuoso> gabbiel: The beauty is, whether you understand Monad or not, you can write production code without knowing what Monad abstract over.
23:36:55 <dminuoso> It's sort of like basic algebra.
23:37:09 <dminuoso> Using basic algebra (+, -, *, /) is very simple.
23:37:33 <int-e> jackdk: Btw if you look at the possible functions of type Monad m => m a, you can quickly conclude that monads are useless. ;-)
23:37:48 <dminuoso> In order to calculate with numbers you dont need to understand how math generalizes and captures it all. You dont need to understand the deep, almost philophical, connections between all the fields in math.
23:38:18 <dminuoso> You dont need to know what an abelian group is, but I promise you have been using it all your live since 5th grade.
23:38:43 <gabbiel> so focus on practical examples like reader, writer, etc
23:38:48 <dminuoso> Exactly.
23:39:41 <int-e> dminuoso: Nice one. And you've probably at least once wondered why A*B = B*A isn't true for 2x2 matrices. :)
23:41:06 <gabbiel> thanks for the tips everyone , ill certainly focus on practical monads when I get to it
23:58:46 <dminuoso> int-e: Geometric interpretation of matrix transformation helped put that nail into the wall a long time ago.
23:59:04 <dminuoso> Guess doing OpenGL stuff was useful after all.
