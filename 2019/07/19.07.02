00:00:06 <ski> olligobber : try `Data.Array' ?
00:00:36 <olligobber> ski, I'll probably just leave it off my list for now
00:00:57 <ski> hm, what list ?
00:29:08 <teto> to be able to upload a package, I should first send a request to admin@hackage.haskell.org, right ?
00:33:08 <merijn> teto: There is *someone* you have to email and that address looks like a likely candidate, yes
00:35:01 <teto> merijn: ty, I'll wait for an answer then. I think I forgot the "please", so I feel kinda anxious :)
00:37:09 <merijn> teto: The only reason you need to email is because at some point in the past few years spambots started namesquatting and uploading packages that were entirely spam, so the "email us" bit only exists so people can check that you seem like an actual human instead of a spambot :p
01:46:38 * jgt yawns, waves goodmorning to fellow Haskellers, and subsequently drowns in coffee
01:54:26 <kuribas> tdammers: I listened to your improvisations :)
01:55:15 <kuribas> tdammers: do you have also jazz or classical recordings?
01:58:50 <sm[m]> Hello jgt
02:12:11 <jgt> Good morning!
02:31:25 <merijn> kuribas: That sounds like -offtopic material ;)
02:31:35 <kuribas> merijn: yeah sorry
02:31:38 <kuribas> wrong channel
02:33:12 <__monty__> Clearly irc needs a stronger type system to prevent such errors in the future.
02:47:40 <jgt> Clojure Fanatic: well ACTUALLY there is NO empirical evidence that type systems something something!
02:48:07 <kuribas> jgt: is there?
02:52:01 <jgt> there have been some "studies" attempted, but the results are always discarded by people who have to much of thier own personal identity invested in the idea that a type system has no benefit
02:52:08 <jgt> s/to/too/
02:52:42 <kuribas> jgt: sounds like you are biased towards type systems
02:53:37 <kuribas> jgt: I mean, that argument can easily be turned around
02:55:16 <int-e> jgt: You have to understand... it's always annoying when the type system doesn't let you write the buggy code that you wanted to write!
02:56:11 <saurabhnanda> with sum-type (using DataKinds), is it possible to convert runtime values to type-level terms? for example, if I have `data Permission = PermA | PermB` and, at runtime I have a list of type `[Permission]`, is it possible to "construct" a type `ps` of _kind_ `[Permission]`? Can the singletons library help me somehow?
02:56:29 <kuribas> int-e: a clojurist will say that it doesn't matter because they will catch the bugs when testing
02:57:36 <kuribas> But as I am writing clojure profesionally now, I seriously doubt it
02:57:51 <kuribas> I often find bugs that are easily cought by the type system
02:58:18 <kuribas> And fixing a type error is so much faster than debugging
02:58:20 <int-e> kuribas: Obviously I've drunk the cool-aid and believe in typoes being beneficial. So there's no argument I can make that would convince that clojurist.
02:59:00 <kuribas> I wish clojurists would just be honest and say they don't like the learning curve and complexity of types.
02:59:06 <int-e> (I also believe that there's a limit to the usefulness of types; dependent types tend to be much more hassle than they're worth.)
02:59:11 <kuribas> Instead of going into bullshit arguments against types.
02:59:20 <jgt> kuribas: yes, I am biased towards type systems. That's after years of living without one.
02:59:39 <kuribas> It's fair to say that the haskell type system is complex
02:59:47 <jgt> kuribas: but for the fanatics, even my anecdotes are too offensive
03:00:06 <aldum> people hate strong type systems because they've been led to think Java is an example of that
03:00:22 <jgt> \
03:00:41 * jgt thanks cat for walking on keyboard
03:03:22 <kuribas> Also the idea that writing types is a redundant effort is wrong IMO, it helps structuring the application.
03:04:13 <jgt> _and_ the whole types vs tests thing is a total false dichotomy
03:06:43 <aldum> I'm a newb, but my understanding is that you have to write less tests manually, because the type system does a lot of it quasi-automatically for you
03:07:40 <aldum> e.g. not having to deal with nulls, because that information is in the type already
03:19:08 <jgt> aldum: yes
03:22:10 <lyxia> saurabhnanda: singletons has a "toSing" function
03:22:49 <saurabhnanda> lyxia: thanks - let me check it out
03:43:52 <dTal> kuribas: what if a) your language is smart enough to infer types, and b) your IDE is smart enough to show you type annotations that you didn't have to manually type? Is there any benefit to manually adding types in that instance?
03:46:03 <kuribas> dTal: of course
03:46:51 <kuribas> int-e: how much did you do with dependend types to come to the conclusion is just a hassle?
03:47:12 <kuribas> int-e: honest question.  I am currently reading "the little typer".
03:49:05 <kuribas> int-e: couldn't it be it's just a matter of getting of the learning curve?
03:51:16 <lortabac> I agree that faking dependent types in Haskell tends to be a hassle, but I don't think dependent types are not worth in general
03:52:42 <merijn> dTal: Yes, because the inferred type can be more general than what you intend
03:53:25 <merijn> I'm undecided about dependent types in general, but in Haskell it's not worth it for now, tbh
03:54:38 <merijn> aldum: I wouldn't really describe it as "you don't need tests", but more nuanced. The golden principle is "make illegal states irrepresentible" (i.e., only non-wrong values/states can happen), this reduces the amount of silly tests you need to write, but it doesn't really eliminate testing itself
03:55:12 <int-e> kuribas: I'm probably wrong in blaming dependent types here... there's a question of moderation when using them and finding the right balance between statically ensured properties and effort spent on proving them. 
03:55:13 <merijn> aldum: "this thing can never be null/None" is one example of an illegal state you want to make impossible so you don't have to test it
03:55:17 <lyxia> There's more to it than a learning curve, there are also usability concerns.
03:55:57 <merijn> aldum: I don't think anyone in the Haskell world seriously thinks you don't need tests. It's just that you can focus on different kinds of tests
03:56:50 <merijn> property based testing, like quickcheck, for example is a thing that's fairly rare (and much less useful) outside of Haskell(-like) languages
03:57:09 <merijn> Usable dependent types are pretty much an open question, yes
03:57:11 <int-e> kuribas: In a slogan, I don't want to have to prove non-emptiness of lists whenever I use 'tail'. So the problem with dependent types is that they tempt people to express everything they know about an interface in the type, making it hard to use.
03:57:24 <merijn> pigworker's thesis is pretty interesting (if intimidating)
03:57:42 <int-e> kuribas: (to be clear, that's an opinion.)
03:58:51 * int-e has indeed spent too little time with dependent types outside of working with Coq (which is different from programming in that proving properties is usually the sole point of the exercise.)
03:59:44 <aldum> well yeah, the point is you need less of the trivial tests
03:59:51 <aldum> still need to test functionality
04:09:05 <earthy> https://files.gotocon.com/uploads/slides/conference_14/813/original/aslak-goto.pdf <- interesting presentation on speeding up tests, with key insight: it all depends on the specific confidence you want to obtain on your system. this insight also holds for type systems.
04:09:28 <int-e> kuribas: I guess some well-designed casting mechanism would go a long way towards changing my opinion. Something that allows skipping proofs that are irrelevant to run-time representation of values, for example. And some mechanism that alleviates the pain from connecting code that works on plain lists, to code that works on lists-with-length ("vectors") and perhaps non-empty lists. (That's...
04:09:34 <int-e> ...another aspect... with dependent types different library authors will choose different levels of detail for the invariants and preconditions of their interface...)
04:14:13 <__monty__> int-e: Seems to me like it's just *harder* if those assumptions are *not* explicit in the type system. You still have to fulfil them, you just don't have a computer to check your work.
04:16:26 <int-e> __monty__: There are two angles to this. a) testing. There's no point in spending effort on proving code correct that doesn't even pass simple test cases.
04:17:06 <argent0> int-e: "skipping proofs", you could use partial functions
04:17:23 <int-e> __monty__: b) The invariants that ensure correctness of code (non-empty lists) are often subtle, and more complicated than the code itself. In such cases, proving them is far more effort than just writing the code.
04:20:15 <int-e> (This is also why I focus on the run-time representation of types... obviously as long as that is not ensured, running the code may just crash, which makes it useless for testing and shipping.)
04:21:07 <int-e> Maybe "managing the level of detail [of types/proofs]" is a good term for what I want.
04:31:00 <simon> how do I figure out what the external dependencies are to the Haskell package postgresql-libpq?
04:31:04 <int-e> Ah, one more thing... separating code that has operational effects from code that just proves type correctness would be great, too.
04:32:37 <int-e> simon: I'd use https://hackage.haskell.org/package/postgresql-libpq-0.9.4.2/postgresql-libpq.cabal as a starting point; namely, the Pkgconfig-depends field.
04:33:27 <int-e> (so development packages for libpq and potentially some transitive dependencies...)
04:33:52 <simon> int-e, excellent, thanks. and this is 'libpq-dev' on Ubuntu. should have figured the '-dev' part :)
05:03:26 <marmulak> so the other day I mentioned my exercise about extracting emails from a raw text that are enclosed by < and >
05:03:31 <marmulak> and it was suggested that I do this using break/span
05:05:16 <marmulak> I realized I could use break if the solution were recursive which I'm not used to but after an hour of hair pulling and a massive headache I somehow managed to make it work
05:05:21 <marmulak> in the way that I wanted
05:05:38 <jgt> marmulak: blog about it
05:06:04 * marmulak sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/ftchdLdCwUoJbLhYSHjlHagZ >
05:06:25 <marmulak> should I really blog about it
05:09:25 <marmulak> I just feel proud that I somehow managed this. It's possibly the best code I've written in years
05:09:37 <marmulak> well, considering that I don't code anymore
05:10:38 <marmulak> I think I can modify this to use span instead of drop
05:12:12 <marmulak> hmm no wait that doesn't seem like it works either. Maybe the drop is inevitable
05:12:36 <marmulak> because the < has to be included in the second part of the result
05:12:52 <__monty__> Marmulak would that work on "Didn't you rather mean '<'? Contact me at <president@pedantics.org> for discussion."
05:13:51 <marmulak> definitely not :)
05:14:21 <jgt> marmulak: yes, I'd read that blog, as would most people interested in Haskell
05:14:28 <marmulak> to make the solution easy the data is sanitized, so my next step is to figure out solutions that work with more terrible input
05:14:46 <marmulak> that's kind of you; I'm sure you know a lot more than I do already :)
05:15:20 <jgt> you'd be surprised
05:16:58 <kuribas> int-e: AFAIK in idris functions can be non-total
05:17:05 <kuribas> int-e: proving properties is optional
05:17:55 * ski . o O ( ".. This cult of artificiality culminates in bleak competitions of the form : « My logic is terrible... Sorry, mine is definitely worse ! »." )
05:20:27 <kuribas> The little typer is a nice book, though the emphasis is on types for proving properties.
05:20:46 <kuribas> But I suppose that's the main use of dependent types right now
05:20:46 <marmulak> __monty__: I have an imperative solution I wrote in C++ many years ago that is clever enough to handle such unusual cases. Basically what it does is walk through the input character by character and copy each one over to a temporary buffer until it hits a "bad" character like < or > or ,'"/ and so on. It also has a boolean switch for whether or not it's encountered @, so if a bad (or let's say delimiting) character is
05:20:47 <marmulak> encountered it wipes the buffer and starts fresh unless it happens to contain @ in which case the buffer is printed before clearing it, and in this way the results are nearly perfect. There's no algorithm that validates whether an e-mail is properly formed but if it has an @ in it then it's assumed to be good
05:21:00 <marmulak> not perfect but for my uses it took a bit of abuse and kept working
05:21:04 <int-e> kuribas: That's part of a solution. But if I have to use them explicitly (littering the code), and if they are named individually (increasing vocabulary size) I'll still be unhappy.
05:21:56 <kuribas> int-e: can't you have type inference for non-dependent parts?
05:22:03 <int-e> kuribas: I'm biased, obviously but I honestly believe that Hindley-Milner types sit in a very sweet spot.
05:22:31 <int-e> obviously -> obviously,
05:22:32 <kuribas> haskell isn't hindley millner either
05:22:41 <kuribas> well anymore.
05:22:44 <__monty__> marmulak: Yeah, I admit it's *really* difficult. If not impossible. As long as some string has an @ in it it's almost impossible to determine whether it's a valid email address.
05:23:24 <marmulak> I'd just have to write a whole other program that validates them haha
05:25:22 <marmulak> the good thing is when doing your own personal projects you know your input in advance so the more assumptions you can make the better
05:25:59 <marmulak> but if you're writing code for other people to use then can be certain they'll break it
05:34:22 <merijn> kuribas: I come from the other extreme, I think Hindley-Milner inference is overrated, there's pretty much consensus on "annotate all top-level bindings" and personally I annotate even all/most bindings in where blocks, so I think the ability to infer everything is overrate
05:34:50 <merijn> __monty__, marmulak: Technically it's possible to have an email adress without an @
05:34:58 <merijn> Bang paths are still legal, per the RFC
05:35:03 <kuribas> merijn: must be a long time since you did Java/C then...
05:35:31 <merijn> kuribas: I said *full* inference is overrated, I didn't say C/Java style types were a good idea
05:35:37 <kuribas> or scala
05:36:13 <marmulak> an e-mail address...... without @ ...
05:36:28 <marmulak> good to know
05:36:37 <merijn> marmulak: Yes, lookup "bang paths" :)
05:37:29 <merijn> marmulak: It boils down to: There's only a single way to validate that an email address is sensible: "send an email and ask for a code"
05:37:44 <merijn> marmulak: For example, did you know it's legal to have newlines in email addresses?
05:38:01 <kuribas> merijn: yeah I think so too
05:38:23 <kuribas> merijn: though sometimes it's nice to have a the compile generate the type, then refine it yourself
05:38:34 <kuribas> merijn: even if you keep the anotation
05:38:56 <kuribas> merijn: also typed holes work well because of inference. Well... reasonably well.
05:39:02 <marmulak> newlines? I'm shocked
05:39:30 <marmulak> although you may find this interesting, but now that I look at these bang paths it reminds me of how postal address evolved
05:40:08 <__monty__> merijn: See, things like this is why I covered my ass and said it's almost impossible to tell whether something's an email address *iff* it has an @, rather than "All valid emails must have an @."
05:40:17 <marmulak> I mean like snail mail
05:41:08 <jgt> surely if people stick newlines in their email addresses they're going to be functionally broken anyway since half the world's software isn't going to adhere to the spec that strictly
05:41:32 <marmulak> the bang paths which indicate hops on a route are like how addresses are sometimes written in some countries, where's the "address" is basically directions from a main street
05:41:42 <marmulak> I couldn't believe such a thing existed until I actually saw it
05:42:29 <merijn> :)
05:42:34 <merijn> Learn something new every day ;)
05:42:41 <day> do these bangpath address still work?
05:42:44 <marmulak> "something boulevard, side street #12, second left, first right, end of the alley"
05:42:48 <day> es*
05:43:04 <marmulak> indeed
05:43:13 <merijn> day: Depends on whether the mail server supports them, I know last time I ran my own mailserver (postfix) it did have support for them in the configuration
05:43:22 <bollu> does anyone know of work trying to extend FRP to PDEs?
05:43:26 <marmulak> if I were a mail daemon I'd reject them
05:43:31 <merijn> bollu: What's PDE stand for?
05:43:39 <bollu> merijn partial differential equations
05:43:54 <bollu> you can view a traditional FRP system as defining a system of ODEs
05:44:00 <bollu> with respect to time, right?
05:44:00 <merijn> I'm not sure how to connect those two things together...
05:44:11 <bollu> Indeed, which is why I'm asking
05:44:31 <bollu> intuitively, if you can have "reactivity" against multiple variables, instead of just against "time"
05:44:37 <merijn> bollu: I don't think you can say "FRP can be viewed [..] with respect to time"
05:44:44 <bollu> how so?
05:44:48 <merijn> bollu: FRP is an attempt to *define* what time means
05:45:06 <merijn> bollu: FRP isn't "reactivity against time"
05:45:32 <merijn> bollu: FRP is "what if time was a first-class value like functions"
05:46:47 <bollu> merijn admittedly I have used very little of FRP, but IIRC, the original formulation of FRP did not make "time" first order, they made "time evolution" first order
05:46:53 <bollu> so you could talk about `Signal` and whatnot
05:47:27 <merijn> bollu: What is the difference between "time" and "time evolution"?
05:48:05 <bollu> you already have a notion of time, it's not trying to "define time" as far as I can see. You define how things "evolve with respect to this thing"
05:48:14 <bollu> idk, maybe we are squabbling about language here :) 
05:48:19 <bollu> and I'm not educated on the topic
05:49:01 <bollu> merijn so, to borrow your terminology for a bit, you can think of no sensible way to port FRP to a situation where you not only define "time", but also some other variable?
05:50:11 * ski . o O ( Fran )
05:50:15 <merijn> bollu: But you can already define other variables in code? Unless you want to evolve across 2 dimensions simultaneously, in which case I can't even see what that would even mean...
05:50:35 <bollu> merijn yes
05:50:49 <bollu> merijn what do you mean by "you can't see what that would mean"?
05:51:11 <bollu> merijn I mean, is it not like I give you a differential equation and the initial conditions and say "evolve"?
05:51:19 <merijn> bollu: Well, if there's a 2nd dimension separate from time that can evolve, what would that even mean?
05:51:37 <bollu> merijn it's just a dimension
05:51:58 <bollu> merijn like, maybe I'm writing the evolution of my system in position-momentum space, and not position-time ?
05:52:13 <merijn> bollu: Yeah, but how would you evolve it independently of time on a computer?
05:52:30 <merijn> bollu: But then we're not remotely talking about FRP anymore?
05:52:39 <bollu> by following however the FRP system tells me to evolve it?
05:52:42 <bollu> just like we do with time?
05:53:01 <merijn> bollu: The only primitives that FRP adds/provides are time related, though
05:53:31 <merijn> bollu: Basically, what part of FRP does your described system use?
05:54:01 <merijn> if the answer is "nothing", then why are we trying to relate to FRP? If the answer is "something", then how can we possibly detach from time?
05:54:06 <bollu> merijn I guess I'm asking if we can expand the set of primitives to not be "time" but any "X"
05:54:18 <bollu> merijn I'm trying to borrow the way in which FRP describes systems
05:54:27 <bollu> describes time-evolving systems
05:54:33 <bollu> to a more general setting
05:54:35 <ski> i suppose a separate dimention could be spatial
05:54:36 <bollu> if that makes sense?
05:54:49 <merijn> bollu: But then we just have "mapping a parameter X to either 1) a value (also known as "a function") or 2) to a behaviour (also known is "a program"/"IO")? :)
05:54:49 <bollu> I'm more interested in talking about phase-space evolution
05:55:21 <bollu> merijn yes :) But I still have many primitives that I can define for my "new system" that are not as general as IO :D 
05:55:33 <merijn> bollu: But I think only "Behaviours" make sense in that scenario
05:55:41 <merijn> I think Events only make sense in time
05:56:16 <merijn> But "Behaviours over some dimension" just sounds like "function" to me :)
05:56:25 <bollu> merijn :) 
05:56:32 <bollu> merijn OK, let me think about this. 
05:57:44 <ski> (perhaps an "event" on the plane could be a curve ?)
05:57:44 <bollu> merijn I think you can have reasonable events over an arbitrary space of parameters. Does your intuition say otherwise?
05:58:13 <merijn> bollu: What would an event mean in that case?
05:59:00 <bollu> merijn if I understand "event" correctly, it's like a discrete value right?
05:59:06 <bollu> as in, a thing that evolves discretely over time?
05:59:37 <bollu> so for example, if you imagine the position-momentum space, then an Event could be every time two particles come within epsilon distance to each other
05:59:46 <bollu> and we have data structures that let us deal with such information
05:59:52 <bollu> kinetic data structures
05:59:55 <merijn> bollu: No, Event are things that happen
06:00:01 <merijn> bollu: Behaviours can already be discrete
06:00:12 <bollu> yes, "two particles came within epislon distance of each other" is a thing that happened
06:00:16 <merijn> bollu: Events are things that are only define at a concrete input in time
06:00:33 <bollu> "concrete input in time"?
06:00:53 <merijn> s/input/instant
06:01:12 <bollu> yes, so the fact that, say, two particles collided is something that happens at an instant in time
06:01:17 <bollu> it is not something that is "always defined"
06:01:21 <bollu> like the position of a particle
06:01:35 <merijn> bollu: But you originally suggested you want to talk about parameters that were "not time"'
06:02:18 <bollu> Right, this was an example. I might be interested in a case where something happens to the energy of the system as it evolves in position/momentum space, with no reference to time at all?
06:03:29 <EvanR> .oO events are functions of time where each occurrence has a finite window around it where there are no other occurrences
06:03:55 <merijn> EvanR: No, that's not true
06:04:03 <merijn> EvanR: Events can be simultaneous
06:04:36 <EvanR> depending on the library
06:04:43 <ski> if we discard time, an event in the plane could perhaps also be a local maximum or local mimimum of some "potential" thingy in the plane ?
06:04:55 <bollu> ski yeah, or a level set more generally
06:05:15 <merijn> EvanR: No, I don't care about implementation details, I'm talking about "the semantics of FRP", that some libraries implement FRP wrong is irrelevant 
06:05:41 <EvanR> yeah i would do T -> [a]
06:05:42 <ski> (with "curves as events", i was thinking of something which can happen discretely (crossing the curve), if you imagine moving along some path in the plane)
06:06:11 <ski> bollu : ok, so you're back to the curve idea, then ?
06:06:42 <ski> (or submanifolds of codimension one or something ?)
06:07:05 <EvanR> curve crossing would need some fiddly condition too to ensure the isolation
06:07:58 <bollu> ski I am not precisely sure what I want. What I really want is a way to describe the evolution of a lagrangian, which is in position-momentum coordinates, using FRP-like syntax
06:08:05 <bollu> I should probably have started with that ;) 
06:08:26 <bollu> but I can't talk about that "inside FRP" unless I am mistaken
06:08:33 <bollu> since FRP only allows me to talk about "time-evolution"
06:11:09 <bollu> merijn can this be expressed inside some FRP-style framework? Or am I completely misguided?
06:11:14 <bollu> I'd like some perspective
06:11:23 <merijn> bollu: FRP doesn't really have syntax, though? I think you're confusing "the APIs of common libraries (attempting to) implement FRP" and "what FRP means"? FRP is just some semantics for "what would it mean if we could talk about time?" and trying to define what those semantics would look like
06:11:36 <merijn> bollu: All FRP implementations are just trying to give shape to those semantics
06:12:00 <bollu> hm
06:12:16 <merijn> bollu: Reverse engineering those implementations and trying to twist the semantics into being about something else is just not very sensical if you still wanna use the term FRP
06:12:41 <bollu> so what would you suggest that I do, in order to express what I want?
06:13:02 <merijn> bollu: I think what you *want* is to formulate your own semantics for "what would it mean to talk about "position-momentum space as first class thing", then after defining those semantics, think about how one would write it down
06:13:47 <merijn> bollu: So, what I'd suggest is "Do what conal did with FRP, but for "position-momentum space" or whatever dimension interests you" ;)
06:13:56 <merijn> bollu: Have you read conal's original FRAN paper?
06:13:57 <bollu> So you mean, like, abstractly sketch a DSL / what operators I would need? or an even higher level?
06:14:06 <bollu> merijn no, I've only read the later yampa paper.
06:14:10 <bollu> Is FRAN the original?
06:14:21 <bollu> like, where it all started?
06:14:24 <merijn> bollu: Yes
06:14:26 <merijn> bollu: http://conal.net/fran/tutorial.htm?
06:14:46 <bollu> cool :)
06:14:49 <bollu> OK, I'll read it. 
06:14:52 <bollu> thank you!
06:14:58 <merijn> bollu: It started with conal wondering "what if I could describe animation as first class values, instead of sequential manipulation of bits in sequence"
06:15:11 <bollu> right. 
06:15:17 <bollu> So, is there a paper? or is it just that link?
06:15:29 <merijn> bollu: There's several papers, they should all be on his website
06:15:42 <bollu> found the link.
06:16:00 <merijn> bollu: He also has some stuff on applying this to UIs
06:16:50 <bollu> merijn thanks a lot for the pointers ^_^ 
06:20:55 <br377>  /buffer 10
06:21:08 <br377> darn spaces
06:51:34 <merijn> hmm, I'm getting weird kind errors when switching from GHC 8.4 to 8.6...
06:51:36 <merijn> https://github.com/NLeSC-AAA2/etherpacket/blob/master/EncodeBits.hs#L153
06:52:00 <duairc> I'm trying to use compact regions for a big data structure and I keep getting "compaction failed: cannot compact functions". But I'm sure there are no functions in there, just a load of vectors and HashMaps? I can derive Eq and Read and Show for it, if there were functions in there somewhere I'd know surely?
06:52:04 <merijn> It works fine with 8.4, but in 8.6 I get: http://dpaste.com/2MZ845M
06:52:09 <merijn> Anyone got any clues?
06:58:01 <merijn> Ugh...this is going to be some StarIsType/StarIsn'tType fuckery that's changed how things parse, isn't it... >.>
07:04:47 <int-e> Oh. What happened to TypeOperators implying NoStarIsType?
07:09:13 <merijn> No clue what happened, but the error is super unhelpful
07:09:43 <segeljakt> is this true? "In Brooklet, commutativity analysis can be performed with a simple code inspection. Since a pure function always commutes, and all state in Brooklet is explicit in an operator’s signature, a sufficient condition for introducing data-parallelism is that an operator does not access variables"
07:09:48 <merijn> I only just realised it's tryin to parse it as "n applied to * and BitSizeField and a" instead of type level multiply
07:10:03 <merijn> segeljakt: No, that's bogus
07:10:09 <merijn> segeljakt: Like, trivially so
07:10:21 <merijn> segeljakt: Consider ++ (i.e. list append)
07:10:24 <segeljakt> haha, I sensed something was wrong
07:10:33 <merijn> Clearly a pure function, *definitely* not commutatitve
07:10:41 <merijn> > (++) [1,2] [3,4]
07:10:43 <lambdabot>  [1,2,3,4]
07:10:46 <merijn> > flip (++) [1,2] [3,4]
07:10:50 <lambdabot>  [3,4,1,2]
07:12:16 <int-e> segeljakt: check what they mean by "commutativity"
07:12:40 <segeljakt> I thought commutativity was only for binary operators, but they seem to use it in the context of unary operators
07:12:45 <int-e> I suspect it means that it doesn't matter which operation you do first.
07:13:21 <int-e> (especially given the keyword "data-parallelism" in there)
07:13:58 <segeljakt> they say that if you have a pure unary function, like `map`, then you can execute it data-parallel over a collection
07:14:48 <segeljakt> "The input data set is partitioned, and copies of the map operator process the partitions in parallel. In general, the challenge in exploiting such data parallelism is determining if an operator commutes"
07:15:28 <int-e> (there's also a commutativity notion for functions: f and g commute if f(g(x)) = g(f(x)). If you think of computations as functions on a shared state, it becomes a pretty close match.)
07:16:10 <segeljakt> ok, interesting
07:19:47 <Ariakenom> random inaccurate musings; Behavior a = Time -> a; Event a = [(Time, a)] where time is ordered, not decreasing; XTBehavior a = X -> T -> a; XTEvent a = [(X,T,a)] where we need a useful order for (X,T);
07:22:16 <ski> why order for `(X,T)' ?
07:23:25 <segeljakt> I'm trying to document properties of unary/binary/ternary functions, this is what I have: Semi/Quasi/Bi-Quasi-Associativity, Binary/Unary-Commutativity, Invertibility, Left/Right-Cancellativity, Left/Right/Anti-Distributivity, Injectivity, Surjectivity, Bijectivity, are there any obvious or less obvious missing?
07:23:25 <kuribas> some people think using FRP for user interfaces is overkill
07:23:40 <dminuoso> some people think using a type system for programs is overkill.
07:24:09 <kuribas> As it is enough to be reactive
07:24:25 <merijn> kuribas: Is it, though?
07:24:33 <kuribas> merijn: I don't know...
07:24:49 <duairc> Is there any way to introspect the bounds of a Vector to tell if it's a slice of something larger or not?
07:24:50 <merijn> kuribas: All inputs might be discrete, but can you assume that all outputs (i.e. the entire UI) is discrete?
07:24:50 <kuribas> I haven't done a comparison
07:25:17 <kuribas> merijn: discrete as in not continuous?
07:25:27 <duairc> I've tried messing about with unsafeCoerce but I haven't had much luck :P
07:25:33 <merijn> kuribas: Simple example: Suppose you want to have any form of animation (rendering a graph, animating a menu, etc.) then you already want continuous behaviour, so proper FRP
07:25:42 <kuribas> merijn: true
07:25:57 <merijn> duairc: I don't think it's part of the API, no?
07:26:02 <merijn> duairc: Why do you wanna know?
07:26:24 <kuribas> merijn: but you could model that with a timer
07:26:44 <merijn> duairc: Do you just wanna "break" slices to avoid holding on to huge amounts of memory?
07:26:49 <kuribas> merijn: so the animation responds to the ticks and values of the timer
07:27:00 <dminuoso> % :t flip (<*>)
07:27:01 <yahb> dminuoso: Applicative f => f a -> f (a -> b) -> f b
07:27:02 <merijn> kuribas: Sure, if you're ok with throwing out all FRP stands for, then yes you can approximate it
07:27:19 <merijn> kuribas: The entire point of FRP was to have a vocabulary to talk about these things without hacky approximations
07:27:36 <kuribas> merijn: for example Streamly claims to be able to implement reactive programming
07:28:02 <dminuoso> kuribas: RP in a hacky way is what you have with React.
07:28:04 <merijn> kuribas: Most things called reactive (and even FRP) are very different from what conal wrote (and meant) when he coined the term
07:28:05 <duairc> merijn: I'm trying to compact a large data structure and I keep getting "Data.Vector.Mutable: uninitialised element" among other errors and I can't think of what would be causing it other than if one of the vectors was a slice and the elements outside that slice were never initialised. Even that seems a bit of a stretch. DeepSeq has no problem with this data
07:28:38 <merijn> duairc: The "force" function returns a new Vector that's guaranteed to not be a slice
07:28:55 <duairc> Ah, I didn't know that. Well it can't be that so then.
07:28:58 <merijn> duairc: But if you were accessing a slice out of bounds, you should get an out of bounds error
07:29:16 <merijn> duairc: Unless you're using unsafeIndex, in which case...stop doing that until you find your bug ;)
07:33:15 <Ariakenom> ski: Same reason Time needs an order. Which I'm a bit hazy on, I don't remember where I got these definitions, but probably because we want to simulate it as T increases (well non decreases ...)
07:34:21 <duairc> merijn: It seems I was right, https://github.com/haskell/vector/issues/220
07:34:41 <duairc> merijn: You are right about force, but I assumed the NFData instance for Vector used force, but it doesn't
07:35:20 <merijn> >.<
07:35:25 <merijn> At least you found it!
07:35:38 <duairc> It's going to be messy to update everything that uses anything that goes through fromList to use force but it's doable
07:36:03 <merijn> duairc: Can't you use fromListN?
07:36:10 <merijn> That should avoid the overallocation
07:36:33 <duairc> Well I'm doing a filter (actually a wither), so not in general
07:36:46 <duairc> But I don't mind just copying everything again
07:38:38 <__monty__> A wither?
07:38:50 <merijn> @hackage witherable
07:38:50 <lambdabot> http://hackage.haskell.org/package/witherable
07:39:03 <Ariakenom> ski: it was Conal's push pull frp http://conal.net/papers/push-pull-frp/push-pull-frp.pdf
07:39:08 <__monty__> Ah, thanks.
07:39:32 <merijn> __monty__: Essentially "mapMaybeM" or "traverseMaybe" or whatever
07:45:01 <tdammers> kuribas: nope; I've never done anything serious enough in those directions. "Classic jazz" (i.e., early swing through hardbop), jazz fusion, and classical technique were part of the curriculum, but none of that has ever truly been "my thing"
07:47:25 <maerwald> tdammers: I play accordeon you the saxophone :)
07:48:04 <tdammers> saxophone? nope
07:48:12 <tdammers> way too many buttons
07:48:15 <tdammers> woodwinds confuse me
07:48:30 <tdammers> piano is doable, because the keys are laid out somewhat logically
07:48:42 <tdammers> but flute, sax, clarinet, oof
07:58:31 <Boarders> I have something that throws an unitialised element error but only if I build without profiling, does anyone know anyway to debug it since I can't get a callstack?
08:02:27 <cinimod> Where should I look to see how to add a package to a package environment?
08:03:26 <merijn> cinimod: What do you mean by package environment?
08:03:39 <cinimod> ghci -package-env foo
08:03:51 <cinimod> So foo is the package environment I believe
08:04:11 <merijn> Ah...I've never really used that, I saw an email on it on haskell-cafe, though
08:04:32 <cinimod> There is a shell script that produces one for you: https://github.com/hvr/cabal-env/blob/master/cabal-env.sh
08:04:38 <merijn> cinimod: If you use v2-build than cabal should generate them for you dynamically too
08:04:45 <merijn> s/than/then
08:05:55 <cinimod> I don't understand
08:06:18 <cinimod> v2-build will produce a package environment somehow?
08:06:35 <merijn> cinimod: v2-build will (by default) generate a .ghc.environment which ghci will use
08:06:38 <d34df00d> This is probably a well-known and answered problem, but... Let's say I'm writing an action of type MonadReader Foo m => m Bar, and then inside that action I want to run another action that needs a different reader context. I can't just runReaderT can I?
08:06:46 <merijn> (at least in cabal-install 2.4)
08:06:55 <d34df00d> What's the right/idiomatic way to do this?
08:07:11 <merijn> d34df00d: Does the the new context have the same type?
08:07:22 <d34df00d> Nope.
08:07:30 <merijn> Then you can't sensibly do that
08:08:14 <d34df00d> :(
08:08:46 <merijn> cinimod: So if you use v2-build you should have a .ghc.environment in your package directory and ghci will automatically use that. I know you can also use explicitly managed package-envs, but I don't know how that works :)
08:08:58 <merijn> d34df00d: It depends a bit on what you're trying to accomplish
08:09:48 <d34df00d> Well, in my particular case I just noticed I don't need the surrounding context immediately before calling the child action, so I managed to get this typechecking by moving stuff to a separate function.
08:09:57 <cinimod> I am using lhs2tex so it seems I have to tell it an explicit package environment
08:09:59 <d34df00d> But I"m curious how one does this in general (if this question makes sense).
08:10:25 <merijn> cinimod: You can try pinging hvr, he's usually around
08:10:57 <cinimod> This seems to work: ghci -package-env .ghc.environment.x86_64-darwin-8.6.3
08:11:03 <cinimod> But it feels wrong
08:12:38 <hvr> cinimod: quickndirty docs for telling ghc which env file to use: https://github.com/hvr/cabal-env/blob/master/cabal-env.sh#L29-L35
08:13:16 <d34df00d> Uh, interesting.
08:13:30 <cinimod> So this works for me but trying to get someone else to build my document will be challenging
08:13:36 <cinimod> Anyway one step at a time
08:15:29 <d34df00d> merijn: now I wonder how this works: https://bpaste.net/show/-ia6 . Note the runReaderT, and the inner CompileContext has a different type.
08:16:45 <dmwit> d34df00d: The usual way is to make your monad transformer have a more sensible, domain-specific API. You can of course use the general-purpose MonadReader API for implementing it.
08:17:11 <d34df00d> dmwit: well... how do you make a domain-specific API?
08:17:12 <merijn> d34df00d: That's because the runReaderT is returning some other monad which is an isntance of MonadReader
08:17:44 <dmwit> For example, `newtype MyContextT m a = MyContextT (ReaderT Context m a); class GetContext m where getContext :: m Context; instance GetContext (MyContextT m a) where getContext = MyContextT ask`
08:18:04 <d34df00d> merijn: but why doesn't it violate fundeps requiremennt on MonadReader?
08:18:30 <merijn> d34df00d: Because they aren't executing in the same do-block/bind
08:18:42 <dmwit> You'll also want `instance MonadReader r m => MonadReader r (MyContextT m) where ask = MyContextT (lift ask)`, but you can derive most of the other general-purpose APIs.
08:18:44 <merijn> d34df00d: When you do "runReaderT" you just get back some value
08:19:00 <d34df00d> Alright, I realized I don't understand fundeps.
08:19:06 <d34df00d> When does the check happen?
08:19:22 <merijn> d34df00d: This is unrelated to fundeps or anything
08:19:33 <dmwit> Each time it sees an instance declaration, it checks the fundeps. But I agree this line of questioning is a red herring.
08:19:39 <merijn> d34df00d: The do block is "some MonadReader"
08:19:40 <kosmikus> cinimod: you mean "building" your document in the sense of running lhs2tex+latex on it? or compiling it as Haskell?
08:20:01 <merijn> d34df00d: "runReaderT" takes "ReaderT r Foo a" and returns "Foo a"
08:20:15 <d34df00d> So it doesn't care that Foo is also a MonadReader?
08:20:24 <merijn> d34df00d: So the only thing checked is "Is 'Foo a' an instance of MonadReader?"
08:20:30 <merijn> d34df00d: It does, but that's not relevant
08:20:40 <merijn> d34df00d: runReaderT doesn't operate on "MonadReader"
08:20:48 <merijn> It operates on "ReaderT r m a"
08:21:00 <merijn> The fact that 'm' is an instance of MonadReader is irrelevant
08:21:04 <d34df00d> But ReaderT is an instance of MonadReader.
08:21:04 <d34df00d> Ah.
08:21:20 <dmwit> I just had a wicked idea.
08:21:21 <cinimod> kosmikus: building the document which runs ghci to produce values which are rendered in the document
08:21:54 <kosmikus> cinimod: ah, ok, inline ghci. I should fix that so that it works with 'cabal new-repl' or 'stack ghci', assuming it currently doesn't.
08:21:57 <cinimod> It's not my top priority at the moment - I need to produce a document for my biss
08:22:11 <d34df00d> dmwit: the problem is that I want different contexts for different parts of my stuff (for testability/modularization purposes).
08:22:13 <cinimod> \documentclass[]{article}
08:22:13 <cinimod>  
08:22:13 <cinimod> %include polycode.fmt
08:22:13 <cinimod> %options ghci -package-env /Users/dominic.steinitz/.ghc.environment.x86_64-darwin-8.6.3
08:22:16 <cinimod>  
08:22:21 <d34df00d> And this is where the original problem comes from.
08:22:54 <d34df00d> merijn: but in this case, back to my original question, why can't I do that? I'd just runReaderT in pretty much the same way from within another MonadReader.
08:22:55 <kosmikus> cinimod: yes, that looks like a good option right now.
08:22:56 <d34df00d> What'd break?
08:23:30 <cinimod> I think the tool hvr has produced does the trick - it's just that I didn't know how to get it to use my locally modified packages rather than the ones on hackage
08:23:39 <kosmikus> cinimod: what tool?
08:23:43 <merijn> d34df00d: You can't "runReaderT" a "MonadReader" you can *only* runReaderT a concrete, non-abstract monad stack that has ReaderT on the outside
08:23:43 <cinimod> Any my immediate problem is solved
08:23:57 <cinimod> https://github.com/hvr/cabal-env/blob/master/cabal-env.sh
08:24:20 <cinimod> I meant Anyway
08:24:34 <kosmikus> cinimod: ok. good to know.
08:25:43 <kosmikus> cinimod: let me know if you run into more trouble. as I said, in principle support for using "cabal v2-repl" and "stack ghci" rather than "ghci", if needed, would be desirable, also from my side.
08:26:16 <kosmikus> cinimod: (as in: I could be convinced to add this.)
08:26:23 <d34df00d> merijn: hmm, interesting.
08:26:30 <d34df00d> So this means I got my original problem wrongly.
08:26:41 <d34df00d> Cause https://wandbox.org/permlink/r7kenbT3kOk2Qo1Y typechecks.
08:27:31 <cinimod> kosmikus: :thumbsup:
08:29:08 <dmwit> merijn: For your consideration: https://gist.github.com/dmwit/ce531720746377e683385341071d0318
08:29:37 <dmwit> d34df00d: I don't understand why that's a problem with the approach I proposed.
08:30:08 <dmwit> d34df00d: (It's also not a problem if you have a particular monad transformer stack, rather than using mtl-style stack polymorphism.)
08:30:21 <dmwit> d34df00d: (But I don't recommend the latter approach. It's very fragile.)
08:31:52 <d34df00d> dmwit: actually, as  I try to grasp your suggestion... What'd be the benefits of it compared to just living with MonadReader Context or something similar?
08:32:50 <dmwit> The benefit is that you can have `MonadContext` and `MonadOtherContext` as constraints, but cannot have `MonadReader Context` and `MonadReader OtherContext` as constraints because fundeps prevent both from holding simultaneously.
08:33:30 <dmwit> For clarity: you can have a single monad m which satisfies moth MonadContext m and MonadOtherContext m, but cannot have a single monad that satisfies both MonadReader Context m and MonadReader OtherContext m.
08:35:49 <d34df00d> Ah, that makes sense indeed!
08:35:54 <d34df00d> Yeah, no problems anymore.
08:35:58 <d34df00d> Thanks!
08:56:44 <solonarv> cinimod: you can run the following to have cabal build some libraries and add them to an env file: cabal v2-install --lib --package-env filename-here.env <packages here>
08:59:12 <solonarv> no need for extrtnal scripts :D
08:59:22 <solonarv> s/external/extra/
09:01:20 <cinimod> solonarv: :thumbsup:
09:04:09 <solonarv> since it's natively supported by cabal it doesn't need to juggle dummy projects in temporary directories like that script does ;)
09:19:34 <dminuoso> d34df00d: The MonadX typeclasses are nowadays not directly related to transformer stacks.
09:20:49 <dminuoso> d34df00d: For example, `MonadState` tries to capture all the monads that have some notion of state, not just monad transformers. `MonadIO` tries to capture all the monads that can execute IO actions.
09:23:31 <cinimod> kosmikus: if I want to \eval e.g. x :: IO Double, I thought I just did \eval{x} but nothing is being printed
09:24:00 <dminuoso> d34df00d: The relationship to monad transformers is that `StateT` layered stacks happen to have state, so they conform to MonadState. Stacks ontop of IO happen to have the capability to execute IO actions, so they conform to MonadIO.
09:24:04 <dminuoso> etc.
09:25:02 <dminuoso> d34df00d: So at some point you may decide that you dont care about what monad you have (whether its a transformer stack, or how that stack is layered, or whether its a different monad altogether). Sometimes some region of code just cares about the "its a monad with state" part.
09:58:41 <marmulak> does cabal always install to the user's home directory or is it just doing that because I ran it without root privileges?
09:59:12 <sclv> there's a "--global" flag in v1 install
09:59:20 <simon> I'm trying to figure out how Servant.Client works when I have a GET and a POST route with overlapping endpoint names; the tutorial at https://docs.servant.dev/en/stable/tutorial/Client.html suggests: type API = "foo" :> ... :> Get '[JSON] GetFoo :<|> "foo" :> ... :> Post '[JSON] PostFoo -- and then: api :: Proxy API; api = Proxy; (foo :<|> foo???) = client api
09:59:21 <sclv> not sure what it does in new-install tbh
10:00:07 <simon> so if it were "foo" and "bar", I could construct (foo :<|> bar) = client api to get query functions for those endpoints. but for overlapping names?
10:00:52 <simon> oh! the Hackage example actually has an example of overlaps.
10:01:18 <simon> I realize that I can name them anything, so (getFoo :<|> postFoo) = client api.
10:05:21 <solonarv> marmulak: cabal lives in your home directory by default
10:05:41 <solonarv> I'd guess it would just end up in /root (the root user's home directory) if you ran it as root
10:06:08 <marmulak> then I shall be content
11:01:54 <remexre> is lens-action what I'd want for doing lenses on MVectors?
11:01:58 <marmulak> I feel so dumb
11:02:06 <marmulak> It took me so long to write the code that does what splitOn does
11:10:07 <dmwit> marmulak: Hey, nice, you're probably a bit better at writing Haskell code now!
11:12:34 <marmulak> a bit
11:13:25 <marmulak> I'm starting to feel like writing haskell code is the same as writing C++ code, except that I'm just forced to put the expressions somewhere else in the code lol
11:13:36 <marmulak> damn haskell, forcing me to be organized
11:24:45 <philmoe81> hey guys/girls, I'm wondering what three consecutive colons do mean in a type signature, e. g. this one: acceptConv :: UserId ::: Maybe ConnId ::: ConvId -> Galley Response
11:24:50 <philmoe81> thx in advance
11:25:44 <jose_zap> philmoe81 looks like a type operator, it will depend from what package you imported it
11:25:51 <jose_zap> here's a list of where it may be coming from https://hoogle.haskell.org/?hoogle=%28%3A%3A%3A%29&scope=set%3Astackage
11:26:04 <lavalike> maybe this? https://www.stackage.org/haddock/lts-13.26/monoid-extras-0.5/Data-Monoid-MList.html#t::::
11:26:49 <philmoe81> ah, nice - that was very quick. thx a lot, I'll dive into this :)
11:26:56 <lavalike> so it would be kinda like (UserID, Maybe ConnId, ConvId) -> Galley Response
11:27:24 <lavalike> or maybe a little more, if it adds that Option
11:28:54 <philmoe81> thanks, lavalike it becomes a bit clearer now
11:29:14 <__monty__> philmoe81: Hoogle's pretty good at answering such questions. It's an invaluable resource.
11:31:34 <philmoe81> thanks, monty for pointing out to hoogle
11:44:20 <d34df00d> Is there any monad that'll allow me to model something like a sequence of optimization passes?
11:44:54 <d34df00d> I need some state, a notion of early return, logging and repeating a sequence of actions until a fixpoint (the latter may be done externally, though).
11:45:29 <d34df00d> I could surely construct that from StateT, ExceptT (which looks like a smell for this task), WriterT and so on, but maybe there's something more reasonable.
11:47:33 <EvanR> WriterT seems to usually be a bad idea for logging
11:48:28 <lavalike> d34df00d: maybe it's a good place for a free monad?
11:48:47 <d34df00d> EvanR: well, I mostly care about saving somewhere a trace of what's been done to my inputs, and just `tell`ing looks handy.
11:48:56 <d34df00d> lavalike: oh, I don't have much experience with them!
11:49:15 <EvanR> you'd think, but just telling seems to have an unavoidable performance issue
11:49:37 <d34df00d> EvanR: hmm, do I have better options?
11:49:41 <lavalike> d34df00d: the basic idea is you define a datatype that lists all of the various actions you want to do, then you write one (or more) interpreters for it
11:49:45 <solonarv> the performance issue is with the usual implementation of WriterT
11:50:00 <solonarv> not with the concept of MonadWriter itseld
11:50:01 <EvanR> for pure logs, you can put an appendable log in the state instead
11:50:10 <d34df00d> lavalike: ah... I don't think the sorts of optimizations I'm doing fits that model well enough.
11:50:12 <bollu> how does one debug a <<loop>
11:50:16 <bollu> <<loop>>* 
11:50:24 <solonarv> EvanR: yes, that is an alternative implementation of MonadWriter
11:51:29 <boj> bollu: likely you ended up referencing something you didn't intend to (an x vs x' for example)
11:52:04 <EvanR> ok yeah WriterT is bad but tell is MonadWriter
11:52:09 <cocreature> bollu: +RTS -xc works iirc
12:01:24 <Geekingfrog> Is there a better monad than the one from cereal (Data.Serialize.Get) where I can compose it with other things? I want to be able to throw various errors instead of having the built-in functions calling `fail` with unhelpful messages.
12:01:56 <davean> Geekingfrog: you can put transformers over it
12:02:01 <davean> making a new monad
12:03:11 <lavalike> Geekingfrog: I wonder if this is an answer https://github.com/ekmett/bytes
12:03:13 <Geekingfrog> I have this so far: `newtype FooM a = FooM { runFooM :: Ex.ExceptT MyError SG.Get a }`, but when I run the whole thing, I end up with `Either String (Either MyError ())`
12:04:58 <Geekingfrog> lavalike, I've been looking into that, but the innermost monad must always be the one from cereal, and I'll end up with an outermost `Either String ...`
12:05:34 <Geekingfrog> I guess I could merge the two either at the end with a constructor like `data MyError = Foo | Bar | Unhandled String`
12:07:38 <EvanR> i see, so Control.Monad.Trans.Writer.CPS exists
12:18:43 <Synthetica> I'm trying to write a Monad instance for a type `data Label f e v = Label e (f v)`, but my test suite (based on genvalidity-hspec) keeps complaining that it doesn't satisfy the Monad laws. Can this type be made a Monad? What I currently have: https://gist.github.com/Synthetica9/8e738fe989f570f46af38df1dab99382
12:30:31 <remexre> is there any way to drop into a ghci somewhere deep in a call stack, analogously to IPython.embed() ?
12:34:28 <segeljakt> ?
12:35:18 <high_shoes> Hi, I was talking to someone and they mentioned a more abstract notion of a fold like function. They had a function with a type signature like (b -> a -> (b -> b) -> b) -> b -> [a] -> b which could be used to implement foldl, foldr and an early terminating fold
12:35:23 <high_shoes> Does anyone know what this might be called?
12:36:17 <__monty__> @hoogle (b -> a -> (b -> b) -> b) -> b -> [a] -> b
12:36:19 <lambdabot> Data.List.HT outerProduct :: (a -> b -> c) -> [a] -> [b] -> [[c]]
12:36:19 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
12:36:19 <lambdabot> UnliftIO.Foreign withMany :: () => (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
12:36:38 <__monty__> Well, not one of those : )
12:37:14 <high_shoes> Thanks anyway :)
12:37:19 <__monty__> I don't see how the (b -> b) can make it more powerful though.
12:37:40 <boj> :t id
12:37:43 <lambdabot> a -> a
12:38:00 <__monty__> Strictness maybe?
12:38:37 <high_shoes> apparently you can write functions of signatures like (b -> a -> Maybe b) -> b -> [a] -> b and fold normally until you get a None then end the fold there when you get None
12:39:16 <boj> :t foldr
12:39:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:39:38 <__monty__> high_shoes: Yeah, but not with the signature you shared.
12:40:28 <high_shoes> __monty__ that makes a lot more sense, now I was very lost. what function would you recommend for this purpose (also able to make foldl and foldr)?
12:40:44 <comerijn> high_shoes: foldr can already do both foldr and foldl :p
12:40:46 <__monty__> Pretty sure foldr can express foldl.
12:40:49 <high_shoes> yes
12:41:21 <__monty__> high_shoes: Maybe you're looking for recursion schemes?
12:42:23 <__monty__> high_shoes: This is a good series of posts on the topic: https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
12:42:24 <jle`> high_shoes: the person probably was referring to foldr, but with a different encoding than how it usually is
12:43:27 <jle`> foldr is the 'early terminating fold' that can be used to implement foldl
12:44:10 <dmwit> remexre: don't think so
12:45:03 <dmwit> ?unmtl ErrorT e Get a
12:45:03 <lambdabot> Get (Either e a)
12:45:12 <remexre> dmwit: darn
12:45:25 <high_shoes> __monty__ and co, thanks for all the help. i'll look into recursion schemes
12:45:34 <dmwit> Geekingfrog: Can you say what you mean carefully? ExceptT doesn't appear to have an outermost Either, but an innermost one.
12:45:49 <dmwit> Geekingfrog: So if ExceptT does not do what you want, I'd be interested to hear some details on what you *do* want.
12:47:07 <dmwit> Ah, perhaps your real objection is "having the built-in functions calling `fail` with unhelpful error messages".
12:47:22 <comerijn> That's solvable, though :)
12:47:27 <dmwit> If so, I'm afraid you can't have your cake and eat it too: you may either use the built-in functions, or you may call `fail` with helpful error messages.
12:47:28 <Geekingfrog> dmwit, exact. When I call functions from cereal like getWord8, this can result in `fail`, and I'd like something more expressive, like a custom sum type or something.
12:48:04 <dmwit> So nothing short of reimplementing all the core operations will get you where you need to go.
12:48:10 <comerijn> You can tag failures, but that doesn't reall give you a su,type
12:48:35 <Geekingfrog> Damn, I was really hoping there was another way.
12:49:12 <EvanR> bollu: i just noticed a page in the ghc manual talking about debugging a loop using the ghci break-on-exception feature combined with tracing history
12:49:15 <merijn> Use megaparsec with a custom stream for bytes?
12:49:25 <merijn> Geekingfrog: ^^
12:49:33 <EvanR> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#debugging-exceptions
12:49:34 <merijn> Geekingfrog: megaparsec supports custom error types, iirc
12:49:41 <Geekingfrog> attoparsec-binary seems more suited
12:49:48 <Geekingfrog> but yes, that's probably the other sane option
12:50:29 <monochrom> Does getWord8 actually call "fail", or are you using "fail" as an informal English word?
12:51:00 <merijn> Well, getWord8 returns mzero and so does fail, so that's what I was guessing happens
12:51:03 <Geekingfrog> it actually call `fail :: Monad m => String -> m a`
12:51:14 <Geekingfrog> uhm, yes, what merijn said
12:52:06 <jle`> Synthetica: one thing that might not be obvious is that you aren't actually writing a monad
12:52:12 <jle`> Synthetica: you're writing a *family* of monads
12:52:35 <jle`> Synthetica: namely, for every choice of f and e, you get a different monad
12:52:58 <jle`> so while your instance might be valid for some specific choice of f and e, it might not be valid for all f's and all e's
12:53:35 <jle`> Synthetica: you say that your hspec suite fails? does it specify what 'f' is a counter-example?
12:53:53 <jle`> the type
12:54:19 <Synthetica> I tried it on `Label [] [Int]`
12:54:28 <Synthetica> (Which failed)
12:54:31 <int-e> http://paste.debian.net/1090087/ is a digestable counterexample
12:54:43 <int-e> (also for Label [] [Int])
12:56:45 <jle`> so your question "can this type be made a monad" is *yes*, for some choices of 'f' and 'e'. (one example: f ~ Identity)
12:56:54 <jle`> and if e has a Monoid instance
12:57:14 <jle`> but you probably can't have an instance that works for *all* Traversable f...since Traversable laws are pretty weak
12:57:36 <jle`> they don't really guarantee enough things so that you can ensure something like this is a monad
12:58:39 <jle`> for *every* instance
12:59:13 <Synthetica> Well, I don't really "want" traversable, but `traverse` was a pretty natural fit for a hole
12:59:22 <jle`> right, so what do you really want?
12:59:45 <jle`> do you want an instance that works for all f and e?  if so, then this is definitely impossible (ie, f ~ IO)
13:00:05 <jle`> do you want many different instances that work for specific choices of f and e? if so, this is definitely possible
13:00:07 <int-e> For lists, rather than `traverse` I guess one needs some kind of `unzip` (f (Label e v) -> Label (f e) (f v)), which would cure the duplication of leafs in the join . join result... at which point I suppose we are still left with the evaluation order problem that the list monad transformer has.
13:00:11 <jle`> (ie, f ~ Identity, e ~ ())
13:00:28 <jle`> (or f ~ Identity, and e is any Monoid)
13:01:08 <Synthetica> Ideally, it would work for all f and e
13:01:15 <jle`> right, but that is definitely impossible :)
13:01:26 <int-e> ah unzip can of course be built on top of Functor, no trouble there.
13:01:29 <Synthetica> (possibly with some extra constraints?)
13:01:31 <jle`> (it can definitely never work for f)
13:01:34 <butterth_> Is there a combinator in Data.Text to split a Text into two Texts,one containing all the characters of the original string at even entries, and one at odd
13:01:36 <jle`> * definitely never work for IO
13:01:48 <int-e> (we'll need Foldable instead for compressing f e down to e)
13:02:01 <jle`> Synthetica: "some extra constraints" could be interpreted as "f is constrained to be specifically Identity"
13:02:42 <jle`> so in the end it depends on what you really actually want to do with this type
13:02:52 <jle`> if constraining f to be specifically Identity always is ok, then that works.
13:03:41 <jle`> you miiight be able to get a meaningful family of instances using 'Distributive'
13:03:48 <jle`> https://hackage.haskell.org/package/distributive/docs/Data-Distributive.html
13:04:04 <lyxia> butterth_: that sounds too oddly specific to be found in such a place.
13:04:23 <jle`> but i can't guarantee to you that this would be the correct instance for *every* meaningful 'f' you could pick
13:04:41 <jle`> that is, all distributive f might give you monad label, not not all monad label might come from distributive f
13:04:48 <jle`> this makes such an instance less than ideal
13:05:01 <dmwit> butterth_: Probably not. But `unfoldrN` might be useful to you.
13:05:10 <Synthetica> jle`: I'll see if I can make it work
13:05:30 <jle`> one of the reasons why we have Monoid e => Monad (Writer e) is that Monoid e is *exactly* the constraint you need to get Monad (Writer e)
13:05:41 <jle`> that is, all monoids on e give you an instnaace
13:05:45 <jle`> and all instances arise from a monoid on e
13:06:00 <jle`> Synthetica: it might be able to compile, but...it might not be useful to you
13:06:04 <int-e> Synthetica: http://paste.debian.net/1090090/ is closer to law-abiding, but has the order-of-evaluation weakness that I anticipated.
13:06:41 <c_wraith> which follows from the monad laws being the same as the category laws, and categories being a kind of generalization of monoid.
13:06:59 <jle`> the reason why Monoid e => Monad (Writer e) is something we're happy with is because it perfectly describes *all* possible Monad instances for Writer e
13:07:04 <jle`> and not just some subset of them
13:07:15 <butterth_> dmwit: Ah, repeatedly chop off the first two characters in the input text to generate the next seed value?
13:08:27 * dmwit nods
13:09:58 <jle`> something like this sounds a lot like the common haskell trap of fauly over-abstraction
13:11:02 <int-e> Synthetica: To be more precise, I conjecture that this defines a monad if the Monoid e is commutative. But I'm probably making some hidden assumption about the relationship of the Monad and Foldable instances of f, which I haven't pinpointed yet.
13:11:52 <int-e> (and of course the restriction Foldable + Monad seems rather restrictive...)
13:14:08 <dmwit> Synthetica: Would you consider `data Label f e v = Label (f e) (f v)`?
13:14:55 <dmwit> (I assume that you will not consider `data Label f e v = Label (f (e, v))`; but if I am wrong then you can just use WriterT.)
13:15:10 <Synthetica> dmwit: I think that would give some strange results
13:15:16 <dmwit> I do, too!
13:15:22 <dmwit> But you are asking a strange question.
13:15:27 <dmwit> So you have to expect some strange answers.
13:16:03 <Synthetica> I didn't know it was such a strange question 😅
13:16:19 <dmwit> Here is why it is strange: you are asking that the `e` part of the label be computable without doing any effects.
13:16:46 <dmwit> But because you ask for a `Monad` instance, you ask that `(>>=)` be allowed to compute some parts of the `e` bit wrapped in an `f`.
13:17:01 <dmwit> And, generally: once in a Monad, always in. There's no generic way to get back to pure land.
13:17:46 <Synthetica> Right, when you put it like that it does make sense
13:18:06 <dmwit> (Is this clear? For `(>>=)`, you are given a function `v -> Label f e v'`. But you only have an `f v`, not a `v`. So you must be getting something like an `f (Label e v')` out. And how are you going to unwrap the `e` part of that from the `f`?)
13:18:55 <dmwit> But! Maybe the Applicative instance already does enough things for you and you don't actually need Monad!
13:19:57 <dmwit> (If so, you might also consider using `Compose ((,)e) f`, which has the appropriate Applicative instance as well as a bunch of other handy ones, and means you don't have to think carefully about whether you got the code write enough to satisfy the laws.)
13:20:47 <jle`> Synthetica: in the end, it all depends on what you actually what to do, and what f you want to actually use, if any
13:21:22 <jle`> if you give us a specific f then we can help guide you through making a monad instance for Label e (MyF a)
13:21:28 <jle`> if it is possible
13:23:26 <dmwit> It's pretty tricky to think of a choice of f for which this could sensibly be done.
13:24:25 <jle`> Identity :D
13:24:44 <dmwit> Possibly Maybe and Either?
13:25:28 <jle`> maybe data Pair a = Pair a a
13:25:51 <jle`> but i just listed off two Distributive's
13:25:53 <int-e> Anything branching will suffer from the evaluation order problem that lists have.
13:26:06 <dmwit> I think you get into trouble with deciding which e should come first with Pair.
13:26:27 <dmwit> Well. My statement wasn't precise.
13:26:42 <Synthetica> jle` That would actually be one of the main values for f
13:26:45 <dmwit> int-e's was better.
13:26:54 <jle`> hm, wouldn't that be handled by associativity of e?
13:27:08 <halogenandtoast> I can't quite piece this together, so I am wondering if I am missing something and maybe someone could help with an example. Given a list of URLs, I want to download their contents concurrently, I was thinking I could use conduit to do this, but I don't know how to build such a pipeline.
13:27:34 <Synthetica> I think I'm going to try to write a distributive instance
13:27:35 <jle`> halogenandtoast: sounds like maybe the async library does what you want?
13:27:41 <Rembane> halogenandtoast: I use async for that. 
13:27:52 <lavalike> it's definitely an example on Marlow's book
13:28:02 <jle`> conduit is more of the opposite of concurrency
13:28:04 <monochrom> halogenandtoast: Does it help to use async for multiple concurrent IO actions, then in each IO action you use conduit?
13:28:05 <int-e> jle`: see the examples at http://paste.debian.net/1090087/ or http://paste.debian.net/1090090/
13:28:16 <monochrom> Like, each IO action uses conduit separately.
13:28:29 <jle`> you can think of conduit as a disciplined way to handle sequentiality
13:28:48 <halogenandtoast> monochrom: I may not need conduit if I use async, I will check it out, thanks jle`, Rembane, and monochrom 
13:28:57 <lavalike> @where parconc
13:28:57 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
13:29:50 <jle`> int-e: the instance for Pair is different from list though, it's not cartesian producty
13:29:58 <int-e> jle`: (Intuitively, the labels 1, 2, and 3 are at depth 1, 2 or 3 of the tree defined by the Label [] [Int] functor.)
13:30:40 <jle`> the Monad instance for Pair 'throws away' most of the results
13:30:54 <int-e> jle`: take the second paste then.
13:30:54 <jle`> whereas the Monad instance for lists keeps all of them
13:31:30 <int-e> (hmm)
13:31:36 <jle`> my gut says that both would return Label [1,2,3] (Pair 0 0)
13:32:17 <int-e> Right, that should work.
13:32:50 <monochrom> Yeah I worked out "instance Monad Pair" once by way of "this is composing two adjoint functors, let's see what it says about join". I got "join (Pair (Pair a b) (Pair c d)) = Pair a d".
13:33:04 <jle`> yeah Pair is just `Reader Bool`
13:33:24 <monochrom> Oh darn that's much simpler than my laborous calculation!
13:33:47 <halogenandtoast> jle`, Rembane, monochrom: Async worked very well, thanks for the suggestion
13:34:06 <jle`> heh, the only way i stumbled onto that is by trying to understand Monad for fixed-length vectors in general
13:34:17 <int-e> jle`: but wait, shouldn't both components of the pair produce their own label?
13:34:31 <Rembane> halogenandtoast: np. :D
13:34:32 <int-e> jle`: (I'm thinking about a single join)
13:34:36 <jle`> yeah, the instance would have to throw away two labels
13:34:47 <int-e> icky.
13:34:55 <jle`> but monadic bind is allowed to destroy structure as long as it does it in an associative way
13:35:05 <monochrom> Then again good exercise in adjoint functors.
13:35:06 <jle`> that's what it does for Maybe, Either, list, etc.
13:35:25 <sarahzrf> monochrom: whats the adjunction for Pair
13:35:44 <monochrom> IIRC product functor and diagonal functor.
13:36:13 <ski> yes
13:36:19 <sarahzrf> ah
13:37:24 <int-e> jle`: you should keep one of the labels to be consistent with the Applicative instance.
13:41:17 <int-e> And I guess that demand rules out Maybe... consider  Label e Nothing <*> Label e' Nothing, where there's no place for e' when doing things monadically.
13:41:39 <int-e> (And it rules out lists as well. Beautiful.)
13:43:12 <jle`> hm, yeah it's trickier than i thought now that i'm actually writing the instances out
13:44:20 <jle`> > LabelPair [0] 1 1 >>= \y -> LabelPair [y] 2 2
13:44:23 <lambdabot>  LabelPair [0,1,1] 2 2
13:44:34 <jle`> > join . join $ LabelPair [0] 1 1 >>= \y -> LabelPair [y] 2 2
13:44:37 <lambdabot>  error:
13:44:37 <lambdabot>      • No instance for (Num
13:44:37 <lambdabot>                           (LabelPair [Integer] (LabelPair [Integer] ())))
13:44:44 <jle`> oh
13:45:51 <jle`> > join . join $ LabelPair [1] (LabelPair [2] (LabelPair [3] 'a' 'b') (LabelPair [4] 'c' 'd')) (LabelPair [5] (LabelPair [6] 'e' 'f') (LabelPair [7] 'g' 'h'))
13:45:55 <lambdabot>  LabelPair [1,2,5,3,7] 'a' 'h'
13:46:04 <jle`> > join . fmap join $ LabelPair [1] (LabelPair [2] (LabelPair [3] 'a' 'b') (LabelPair [4] 'c' 'd')) (LabelPair [5] (LabelPair [6] 'e' 'f') (LabelPair [7] 'g' 'h'))
13:46:07 <lambdabot>  LabelPair [1,2,3,4,5,6,7] 'a' 'h'
13:46:08 <jle`> welp
13:46:24 <jle`> hm, but my monad instance was a little wonky, it kept both of the results
13:46:54 <jle`> > join . join $ LabelPair [1] (LabelPair [2] (LabelPair [3] 'a' 'b') (LabelPair [4] 'c' 'd')) (LabelPair [5] (LabelPair [6] 'e' 'f') (LabelPair [7] 'g' 'h'))
13:46:56 <lambdabot>  LabelPair [1,2,3] 'a' 'h'
13:47:00 <jle`> > join . fmap join $ LabelPair [1] (LabelPair [2] (LabelPair [3] 'a' 'b') (LabelPair [4] 'c' 'd')) (LabelPair [5] (LabelPair [6] 'e' 'f') (LabelPair [7] 'g' 'h'))
13:47:02 <lambdabot>  LabelPair [1,2,3] 'a' 'h'
13:47:13 <jle`> ah, if you throw away one of them and keep the other then it seems to work
13:47:17 <jle`> after my very scientific investigation
15:03:48 <vertti> would this be a good avenue to ask for help as a novice?
15:04:21 <monochrom> Yes.
15:05:29 <vertti> I'm 2 weeks into Haskell and trying to build a multi-node tree. I'm managing to pull the tree itself together but I struggle to understand how to traverse it
15:05:45 <vertti> multi-node, I mean that a node can have any number of children
15:06:27 <c_wraith> what kind of traversal are you looking for?
15:06:32 <ski> what kind of traversal are you thinking of ?
15:06:53 * ski smiles
15:07:08 <jle`> also, what is your tree type?
15:07:28 <vertti> simplified, like this:
15:07:28 <vertti> data Tree = Tree { elem :: Value, children :: [(Tag, Tree)]}
15:07:56 <c_wraith> labeled edges. how fun!
15:08:21 <vertti> Ideally, I'd like to derive an instance of Functor, Traversable
15:08:35 <ski> then you need to parameterize that data type
15:08:36 <c_wraith> you need to change the type for that.
15:08:39 <vertti> But they expect  * > * whereas mine is just... *
15:08:47 <ski> (probably you already did, but simplified that away)
15:08:53 <jle`> what do you want the 'fmap' to map over?
15:08:55 <jle`> the elements?
15:09:14 <vertti> yes elements, but in specific order
15:09:15 <jle`> the tags?
15:09:26 <jle`> ah, if it's the elements, then you can parameterize on the elem type
15:09:36 <jle`> data Tree a = Tree { elem :: a, children :: [(Tag, Tree a)] }
15:09:42 <c_wraith> which order? the default is depth-first, left-to-right
15:09:43 <jle`> then you can derive Functor :)
15:09:46 <ski> vertti : i assume you've seen parameterized data types before ? you know how to .. what jle` just said :)
15:10:12 <jle`> sorry, maybe i'll back out -- lots of chefs here today :)
15:10:47 * ski puts more nails in the soup pot
15:11:25 <jle`> note that you can also now derive Foldable and Traversable, but the default derived instance is a "pre-order" traversal
15:11:29 <vertti> hehe yes the type system keeps tripping me, particularly when there are type as well as value constructors
15:11:42 <jle`> and you might not be aware, but it's a subtle point that functor's fmap is necessarily independent of 'order'
15:11:45 <vertti> depth first, left to right is precisely what I need
15:12:01 * ski would probably rename the data constructor there, to `Node' or `MkTree' or something
15:12:02 <c_wraith> then you can just derive them! :)
15:12:38 * ski imagines vertti actually wants to know how to write the traversal code, not merely getting it served by the implementation
15:13:05 <jle`> the default instance is pre-order (if you derive Traversable), which would do something like Tree 'a' [Tree 'b' [Tree 'c' []], Tree 'd' []] => a, then b, then c, then d
15:13:36 <jle`> post-order you can trick ghc into deriving automatically if you switch the order of elem and children, which is admittedly kind of weird
15:13:47 <jle`> (weird that the order of the fields changes how the effects are ordered, but oh well)
15:14:18 <c_wraith> say what? that should not happen.
15:14:31 <jle`> but it'd definitely be instructive to try to figure out how to write them by hand as well
15:14:50 <c_wraith> that would be a bug in deriving Foldable and Traversable
15:14:57 <jle`> @let data Tree1 a = T1 a [T1 a] deriving Foldable
15:14:59 <lambdabot>  .L.hs:173:22: error:
15:14:59 <lambdabot>      • Data constructor ‘T1’ cannot be used here
15:14:59 <lambdabot>          (it is defined and used in the same recursive group)
15:15:06 <jle`> @let data Tree1 a = T1 a [Tree1 a] deriving Foldable
15:15:09 <lambdabot>  Defined.
15:15:28 <vertti> jle` you mean it would be a good learning experience to write the traversal functions by hand for now?
15:15:36 <ski> yes
15:15:38 <jle`> > toList $ T1 1 [T1 2 [T1 3 []], T1 4 []]
15:15:44 <lambdabot>  error:
15:15:44 <lambdabot>      Ambiguous occurrence ‘toList’
15:15:44 <lambdabot>      It could refer to either ‘F.toList’,
15:15:49 <jle`> > F.toList $ T1 1 [T1 2 [T1 3 []], T1 4 []]
15:15:54 <lambdabot>  [1,2,3,4]
15:16:02 <vertti> yes you probably have a point there, although my struggle is with the type system, particularly typeclasses for now
15:16:07 <jle`> @let data Tree2 a = T2 [Tree2 a] a deriving Foldable
15:16:10 <lambdabot>  Defined.
15:16:41 <jle`> > F.toList $ T2 [T2 [T2 [] 3] 2, T2 [] 4] 1
15:16:46 <lambdabot>  [3,2,4,1]
15:16:52 <vertti> Those elems are actually questions of a conditional questionnaire
15:16:59 <jle`> different field ordering => different traversal
15:17:04 <vertti> the user answers them in a conditional sequence
15:17:25 <jle`> T1 gives you a pre-order traversal and T2 gives you a post-order traversal
15:17:31 <ski> the `Tag' are the answers, i suppose
15:17:40 <vertti> so I just thought a tree structure would fit the best, but I also need to store the answers and also keep track of what's answered and what's not yet (=what to ask next)
15:17:52 <jle`> that's not too bad, i think
15:17:52 <vertti> Tag means the ID of next question to ask
15:17:56 <c_wraith> vertti, do you understand why the compiler says your original type can't be an instance of Functor?
15:18:21 <vertti> c_wraith because I don't have Tree a = .. but Tree = ... instead
15:18:32 <vertti> And Functor requires * -> *
15:18:33 <c_wraith> vertti, but do you understand why that's a problem?
15:19:03 <vertti> Because Functor is more generic than my data type? So that it could accept any value in place of a
15:19:26 <c_wraith> jle`, that really looks like a bug in the derived instance.
15:19:28 <ski> what would be the type signature of `fmap', in your `Tree' case ?
15:19:45 <jle`> c_wraith: honestly i don't see how it would work any other way
15:19:45 <ski> c_wraith : what's a bug ?
15:19:56 <vertti> That's what I've been trying to figure out, well, say I got
15:20:22 <ski> do you know how the `Functor' type class is defined ?
15:20:41 <vertti> data QuestionTree a = QuestionTree { question      :: a, answers       :: [(AnswerChoice, QuestionTree a)] } deriving (Generic)
15:20:44 <vertti> This is what I got now
15:21:13 <vertti> To have an instance of Functor it needs to know how to map over elements, right? So it needs to know what the "boxes" are
15:21:33 <ski> "boxes" ?
15:21:53 <vertti> yeah something to be mapped over, applied a function on something
15:21:55 <c_wraith> jle`, I can see how it ends up that way, but it seems like it ignores the part of Foldable/Traversable that says the instances should visit the elements in a particular order.
15:22:18 <jle`> in this case the particular order is determined by the order of the fields
15:22:31 <jle`> and not by the actual semantics of the type
15:22:54 <jle`> but i don't know how you could have it work nicely the second way, barring some ad-hoc DerivingVia stuff maybe
15:23:13 <c_wraith> it just seems like the rule in the class would suggest that it should recurse last. 
15:23:35 <jle`> oh, you mean that it has to necessarily be pre-order?
15:23:40 <ski> (`(<**>)' is distict from `flip (<*>)'. or `liftA2 . flip f' is distinct from `flip . liftA2')
15:24:06 <jle`> that is, that all lawful Traversable instances are pre-order traversals?
15:24:10 <jle`> hm
15:24:11 <c_wraith> that would be my reading of the rule, but it's probably vague.
15:24:12 <ski> (er, s/ f//)
15:24:51 <jle`> what rule are you referring to in specific?
15:24:55 <vertti> wait I'm getting confused, jle` what you said before about pre-order traversal still holds for Traversable? So I could assume the order of traversal is default right for me
15:24:58 <c_wraith> "representing data structures that can be traversed from left to right." is pretty vague, alright
15:25:24 <jle`> vertti: yeah, Tree a [Tree a] is pre-order
15:25:28 <jle`> if you derive traversable
15:25:35 <vertti> like depth first before siblings
15:25:47 <c_wraith> I guess that doesn't imply *what* is left and right, just that something is.
15:25:55 <jle`> vertti: as in, touch the element before recursing down to touch the children
15:26:31 <jle`> c_wraith: hm yeah, it makes me wonder why 'left to right' is even such a prominent part of the description
15:26:34 <vertti> yes great. But also go all the way to the bottom before going back to the next siblings, if any
15:26:36 <jle`> if it isn't formalized anywhere
15:26:47 <jle`> vertti: yes, that too
15:27:14 <vertti> would it be stupid to also store answers with Maybe Answer in such tree? I was told I should probably keep them separate
15:27:15 <c_wraith> jle`, well, the use of Applicative implies something must be declared to be left and right. I think it was just an explicit acknowledgement of that
15:27:18 <jle`> c_wraith: "left to right" shows up 7 times in the documentation
15:27:45 <vertti> traversal just skipping over to the next unanswered
15:27:58 <jle`> c_wraith: maybe "in some deterministic order" is more appropriate
15:28:22 <gabbiel> should I learn about type theory?
15:28:22 <jle`> because it is important that the order of the traversal is determined by the structure of the Traversable, and not by any results of the traversing actions
15:28:33 <jle`> gabbiel: if you want to!
15:28:39 <jle`> or maybe if you are studying to be a professional type theorist
15:29:13 <jle`> 'should' here implies some moral judgment or context, and it's not clear what is relevant based on just your question
15:29:37 <jle`> i would not consider someone who learns type theory to have any moral superiority over someone who doesn't
15:29:49 <gabbiel> I just want to understand the type system in haskell, and I feel type theory is the foundation of that
15:30:15 <vertti>  I could certainly use some good online resources to learn the type system better too
15:30:17 <jle`> hm, if you want to understand the type system in haskell, then i don't think learning type theory would be very helpful
15:30:21 <xlxs4> I'd go with category theory myself, check out Bartosz Milewski
15:30:36 <jle`> i also think learning category theory is a very inefficient way to learn about the type system of haskell 
15:30:49 <jle`> the best way is probably with some haskell introductory course
15:30:49 <gabbiel> then what use is it?
15:30:52 <xlxs4> Why's that?
15:31:10 <jle`> xlxs4: well, there are much more direct ways to learn about haskell type system
15:31:17 <jle`> it's kind of like learning marine biology in order to learn how to fish
15:31:25 <jle`> i mean sure you can sink 4 years into a marine biology phd
15:31:32 <jle`> but you can also just like, read a fishing tutorial
15:31:43 <jle`> marine biology also doesn't directly teach you anything about fishing
15:31:46 <gabbiel> is that an accurate analogy though
15:31:50 <c_wraith> xlxs4, type theory is for proving properties of type systems. it's really cool, but it's way more than is necessary to use Haskell.
15:31:57 <jle`> if anything it gives you some context in which fishing was developed
15:32:07 <xlxs4> If you've found such a tutorial please let me know
15:32:08 <jle`> but it doesn't actually directly teach you about fishing itself in a way you can use to begin fishing
15:32:28 <xlxs4> No, but if you already know how to fish, it makes you a way better fisherman
15:32:43 <jle`> indeed, which is why i say it is not a good way to learn the haskell type system
15:32:51 <jle`> it's useful if you already know about the haskell type system
15:32:58 <jle`> it is not useful if you do not
15:33:21 <xlxs4> ok I got your point
15:33:22 <vertti> hey by the way, what does ::: mean in Haskell? I assume it's from some extension
15:33:50 <c_wraith> it's just a library defined data constructor
15:34:01 <jle`> it's a valid user-defined identifier for a data constructor
15:34:12 <jle`> is it a good idea to name a data constructor (:::)? debatable
15:34:14 <jle`> but it's legal ;)
15:34:17 <vertti> Someone wrote something like this to me
15:34:18 <vertti> instance Prompt Bool where    prompt _ = "no" ::: "yes" ::: VNil
15:34:33 <vertti> and I just don't get how this translates to english
15:34:43 <EvanR> maybe it is a variable-type list
15:34:45 <jle`> if we give it a reasonable name, like Dotty
15:34:53 <jle`> then it's prompt _ = Dotty "no" (Dotty "yes" VNil)
15:34:54 <EvanR> ::: = VCons
15:34:56 <gabbiel> I just dont want to come across things like "GADTs" and not have a clue
15:34:57 <ski> <philmoe81> hey guys/girls, I'm wondering what three consecutive colons do mean in a type signature, e. g. this one: acceptConv :: UserId ::: Maybe ConnId ::: ConvId -> Galley Response
15:35:01 <c_wraith> that looks like some HLisy
15:35:02 <ski> <jose_zap> here's a list of where it may be coming from https://hoogle.haskell.org/?hoogle=%28%3A%3A%3A%29&scope=set%3Astackage
15:35:08 <ski> <lavalike> maybe this? https://www.stackage.org/haddock/lts-13.26/monoid-extras-0.5/Data-Monoid-MList.html#t::::
15:35:25 <jle`> as far as data constructor names go, (:::) is probably as confusing as it gets
15:35:31 <ski> (that's from four hours ago)
15:35:38 <vertti> I see, calling it Dotty certainly makes it seem more familiar
15:36:03 <vertti> here I was confusing it with type signatures
15:36:16 <c_wraith> gabbiel, the ghc user manual is often a little on the terse side, but it's also a nice intro to most extensions.
15:36:17 <jle`> gabbiel: hm, i guess GADTs are usually outside of the normal introductions to haskell types, but things at that level are usualyl self-contained enough to learn on their own
15:36:40 <jle`> for example if you already know what an ADT is, then a GADT isn't too hard to just look up
15:36:44 <jle`> on a case-by-case basis
15:36:49 <ski> i think "GADT" isn't a standard term in type theory ?
15:36:55 <gabbiel> I know now there's nullary types, i.e. (data Type = Type), sum types (data Sum = Type | Type2), product types (data Product = Type1 Type2)
15:37:19 <c_wraith> nullary would actually be (data Type)
15:37:28 <c_wraith> no constructors at all
15:37:37 <ski> gabbiel : i'd call that "nullary type" a "unit type", actually
15:37:47 <gabbiel> oh ok
15:38:07 <ski> (and your sum and product types are missing data constructor names)
15:38:36 <gabbiel> yeah sorry
15:38:42 <philmoe81> thanks for having a look, ski
15:39:14 <vertti> thanks guys for helping me too the community is certainly making learning far more pleasant
15:39:20 <gabbiel> and the final, (data ADT = C1 Type1 | C2 Type2 Type3
15:40:13 <gabbiel> but im confused by stuff like (data Type a = C a)
15:40:21 <gabbiel> is it still an ADT?
15:40:54 <Welkin> yes
15:40:57 <Welkin> why wouldn't it be?
15:41:03 <Welkin> it's a product
15:41:09 <gabbiel> and what about stuff like this (data [] a = [] | a : [a]
15:41:18 <Welkin> sum of products
15:41:32 <gabbiel> so its just that the type is variable that is the difference?
15:41:50 <Welkin> even without type variables it's still an ADT
15:41:55 <Welkin> algebraic data type
15:41:58 <Welkin> data A = A
15:42:02 <Welkin> that's a valid ADT
15:42:12 <gabbiel> it doesnt matter that its recursive?
15:42:18 <Welkin> it's not
15:42:24 <Welkin> the A on the left is a Type
15:42:24 <jle`> i think you might be overcomplicating things :)
15:42:26 <gabbiel> [] is recursive
15:42:30 <Welkin> the A on the right is a data constructor
15:42:41 <Welkin> not the same A
15:42:43 <EvanR> yep list is a recursive data type
15:42:52 <EvanR> it's also parameterized by some other type
15:43:18 <gabbiel> i thought the (:) was the constructor
15:43:29 <jle`> "a" constructor, but yeah
15:43:42 <jle`> it seems like you understand things, but are doubting your understanding
15:43:56 <gabbiel> i want to fully understand it, no doubts
15:44:07 <jle`> an algebraic data type in this context is any type that is made of a sum or product of other types
15:44:26 <ski> philmoe81 : don't thank me, thank jose_zap and lavalike
15:45:09 <gabbiel> what other types are there other than sum, product, nullary, and unit?
15:45:15 <c_wraith> jle`, data Foo a = Empty | Nested a (Foo a) a -- here's an especially ugly one for any variant of Foldable
15:45:52 <EvanR> gabbiel: how about function type
15:45:55 * ski . o O ( `Foo a = 1 + a * Foo a * a' )
15:46:28 <gabbiel> I thought function types were product because (a -> b) means any a and any b
15:46:35 <EvanR> nope
15:46:56 <EvanR> a -> b means functions from a to b
15:47:08 <jle`> tuples are products :) and i think you already said this earlier
15:47:14 <Welkin> a evolves into b
15:47:18 <jle`> (a,b) means "any a and any b"
15:47:27 <jle`> (a -> b) is something different, right?
15:47:32 <gabbiel> the type is still (->), right?
15:47:36 <Welkin> use a leaf stone to evolve `a` into a `t`
15:47:39 <gabbiel> and (->) takes any a and any b
15:47:46 <EvanR> no pokemon
15:47:46 <gabbiel> therefore, it's a product type
15:48:02 <Welkin> all types are products
15:48:11 <Welkin> they can have zero fields
15:48:13 <jle`> ah, when i say (a,b) takes any a and any b, i mean that *values* of type (a,b) can take any value of type a, and any value of type b
15:48:19 <jle`> s/can take/contain
15:48:33 <Welkin> () for instance
15:48:42 <gabbiel> yes, any type a, and any type b
15:48:53 <gabbiel> () is a unit type, correct
15:48:54 <jle`> gabbiel: but that's not true for values of type (a -> b)
15:49:09 <EvanR> () is the 0-ary product, but Void would be the 0-ary sum (not a product of anything)
15:49:13 <jle`> you might be confusing values with type parameters
15:49:44 <gabbiel> a function of type (Int -> Int) takes an int and outputs an int 
15:50:02 <jle`> yes
15:50:10 <jle`> it does not take an int and an int
15:50:11 <gabbiel> a function of type (a -> b) takes a value of type a, and outputs a value of type b
15:50:36 <jle`> yeah. that's different than a value of type (a, b), which containes an a and a b
15:50:37 <gabbiel> (->) a b is a type, where a and b are types
15:50:50 <jle`> yes, it's a type, but it's not a product type
15:50:51 <gabbiel> a and b can be any any type 
15:51:01 <jle`> by that logic, Either a b is a product of a and b ;)
15:51:26 <gabbiel> it is
15:51:31 <gabbiel> Either is a product type
15:51:32 <jle`> what you are describing are type parameters, but product/sum/etc. are not about what type parameters you take in, but rather the structures you create with them
15:51:45 <jle`> `Either a b` is the sum of a and b :)
15:51:49 <jle`> not the product of a and b
15:51:57 <gabbiel> oh wait
15:52:11 <gabbiel> data Either a b = Left a | Right b
15:52:15 <gabbiel> you're right for the Either case
15:52:17 <EvanR> Either is not a product, not all types are products
15:52:33 <jle`> product/sum/etc. doesn't have to do with "what" type parameters you take in
15:52:39 <jle`> it has to do with the actual data type that you create
15:52:49 <jle`> the values of that data type
15:53:22 <gabbiel> so you're saying (a -> b) doesn't imply a product type
15:53:24 <jle`> (a,b) is a product of 'a' and 'b' because values of type 'a' and 'b' contain both a value of type 'a' and a value of type 'b'
15:53:40 <jle`> yeah, a -> b is actually often called an exponentiation
15:53:45 <jle`> if you follow the cardinality guidelines/rules
15:53:59 <jle`> if A has 3 possible values, and B has 2 possible values, then (A, B) has 6 possible values
15:54:06 <gabbiel> this is why I wanted to learn type theory, does it cover stuff like this?
15:54:07 <jle`> 3 * 2 = 6. product :)
15:54:35 <jle`> hm, it covers it in the sense that calculus covers addition
15:54:39 <EvanR> if someone gives me an (a,b) then i know i can get an a and a b. If someone gives me a a -> b then for any a I pick I can get a b.
15:55:03 <jle`> if you just want to learn what the "A" in ADT means, then you can look up ADT tutorials
15:55:17 <jle`> like this one https://gist.github.com/gregberns/5e9da0c95a9a8d2b6338afe69310b945
15:55:24 <gabbiel> im more confused now
15:55:26 <ski> `data IntOrDouble = ItsInt Int | ItsDouble Double' defines `IntOrDouble' to be a sum (not product) of `Int' and `Double'
15:55:50 <gabbiel> ok I get that
15:55:56 <ski> (it doesn't matter that `IntOrDouble' is not a parameterized data type)
15:56:57 <ski> gabbiel : how many values are there of type `Bool -> Ordering' ?
15:56:57 <jle`> gabbiel: try checking out the tutorial i linked :) it's the one that helped it all click for me
15:57:03 <gabbiel> I get that too, in this case, IntOrDouble is like an instance of Either 
15:57:15 <jle`> one easy thing in haskell is that you see a mathy term and think that you need to learn math to know how to use it or to understand it
15:57:19 <jle`> but in reality you don't
15:57:23 <jle`> you just need to learn the thing itself
15:57:23 <gabbiel> not instance, a smaller version
15:57:32 <jle`> *learn some entire abstract branch of math, i mean
15:57:38 <gabbiel> well, idk the terminology
15:57:38 <ski> a specialized version
15:58:21 <gabbiel> ski: what do you mean about how many values of type Bool -> Ordering
15:58:40 <gabbiel> well, Bool has 2 values
15:58:52 <gabbiel> Ordering has 3 I think
15:58:57 <hpc> right so far
15:59:51 <gabbiel> but it only always returns Ordering
15:59:59 <gabbiel> *always
16:00:18 <ski> can you describe (or define) one example value of that type ?
16:00:39 <ski> if you want to, you could consider the type `Bool -> Bool' first
16:01:02 <gabbiel> ok, here we go
16:01:09 <gabbiel> Bool -> Bool is a type
16:01:20 <gabbiel> a type can have a value
16:01:28 <gabbiel> unless its nullary
16:01:32 <gabbiel> but it's not here
16:01:55 <ski> which value, e.g. ?
16:02:13 <gabbiel> its value is a function
16:02:29 <ski> yes, values of the type are functions
16:02:42 <gabbiel> which is we can think of as mapping from sets to sets
16:02:53 <gabbiel> *if
16:02:57 <hpc> can you write a specific function?
16:03:26 <gabbiel> idBool = (\x -> x) :: (Bool -> Bool)
16:03:42 <ski> okay
16:03:54 <ski> are there any more values of this type ?
16:04:06 <gabbiel> yes
16:04:15 <c_wraith> Bool -> Bool is a bit limited, as 2+2 = 2*2 = 2^2. hard to see which it is, offhand.
16:04:29 <gabbiel> I know there's a formula to find how many possible functions
16:04:38 <ski> c_wraith : yes, which is why i mentioned `Bool -> Ordering', at first
16:05:05 <c_wraith> I like that example a lot more.
16:05:11 <gabbiel> let me think, if there are 2 possible inputs, and 3 possible outputs, then 
16:05:12 <ski> gabbiel : perhaps you could even reconstruct the formula, after you think about the possible values of types like this
16:05:17 <jle`> gabbiel: one basic way to write a function in haskell is by pattern matching
16:05:20 <hpc> c_wraith: i think the plan is how to list all of them first, then get to the algebraic way
16:05:23 <jle`> for example:
16:05:28 <jle`> myFunc False = ???
16:05:31 <jle`> myFunc True = ???
16:05:32 <hpc> to keep the explanation grounded
16:06:07 <jle`> gabbiel: every way you fill in `myFunc False = ???; myFunc True = ???` gives you a new function
16:06:12 <gabbiel> but that's just one func, there are more yes?
16:06:17 <jle`> so, the question becomes "how many ways can you fill it in?"
16:06:26 <jle`> gabbiel: actually, all (total) functions look that way :)
16:06:33 <jle`> that's the beauty of it all
16:06:36 <gabbiel> let me get paper and pen so I can do it easier
16:06:48 <hpc> jle`: no spoilers ;)
16:09:30 <gabbiel> its it 3^2 possible functions for Bool -> Ordering
16:09:42 <gabbiel> ?
16:09:55 <hpc> oh damn
16:09:57 <hpc> that's correct
16:10:06 <hpc> what was your reasoning?
16:10:39 <gabbiel> there are 3 Orderings to choose for True, and there are 3 ordering to choose for False
16:10:45 <gabbiel> 3 * 3 = 3^2
16:10:48 <ski> yes
16:10:52 <ski> how about `Ordering -> Bool' ?
16:11:37 <gabbiel> hmm, itd be 2 * 2 * 2 = 2^3
16:11:58 <gabbiel> i see why its an exponentiation type
16:13:15 <gabbiel> what was originally being discussed? ADTs?
16:14:48 <hpc> it was something about why they're "algebraic", i think?
16:14:50 <hpc> or that was part of it
16:14:54 <gabbiel> can there be more types of types?
16:15:16 <gabbiel> so far, there are nullary, unit, sum, product, exponentiation types
16:15:29 <jle`> there are a bunch of types
16:15:43 <jle`> Data.Map from Map is not easily expressible as an algebraic data type
16:15:52 <gabbiel> do all I listed are ADTs?
16:15:53 <jle`> that is, a sum or product or exponentiation of any other types
16:16:00 <ski> gabbiel : if we write `Bool' as `2', and `a -> b' as `b^a', then `Bool -> a' is `a^2', which is "equal to" `a * a', iow `(a,a)' in Haskell type syntax
16:16:02 <jle`> same for Set from Data.Set
16:16:07 <hpc> Data.Map is complicatedly expressible as an algebraic data type though
16:16:19 <ski> gabbiel : so a value of type `Bool -> a' contains the same info as one of type `(a,a)'
16:16:22 <jle`> not in any way natural to its parameters, i think
16:16:38 <jle`> it's easily expressed as a 'quotient' of an adt though
16:16:45 <jle`> it's some quotient of [(k,v)]
16:17:21 <jle`> but it's not very simple to express in terms of sums and products, so there is no benefit in thinking of it in terms of sums and products
16:17:32 <ski> gabbiel : in `myFunc False = x0; myFunc True = x1' (where `x0' and `x1' are any values of some type `T'), the value `myFunc', of type `Bool -> T', corresponds to the value `(x0,x1)', of type `(a,a)'
16:17:39 <gabbiel> ski: what are you implying with the (a,a)
16:17:51 <hpc> gabbiel: a tuple
16:18:11 <jle`> gabbiel: in haskell we sometimes make an informal separation of types into "algebraic data types" and "abstract data types"
16:18:12 <gabbiel> is it technically a product?
16:18:17 <hpc> yes
16:18:18 <jle`> (even though they aren't formally distinct concepts)
16:18:43 <jle`> in haskell, if a type and its API isn't nicely directly expressable as an ADT, we call it 'abstract'
16:19:03 <jle`> just informally though, in casual conversation
16:19:22 <hpc> or if the implementation doesn't allow you to see it
16:19:27 <jle`> and Data.Map is one such data type: we think about it in terms of its API (insert, lookup, delete, toList, etc.) and not in terms of being composed of sums or products
16:19:40 <hpc> Data.Ratio iirc is an example of that, it's pretty simple but hidden so it can reduce the fractions
16:20:39 <gabbiel> I haven't dealt with Data.Set or Data.Map yet
16:20:55 <jle`> Data.Set represents an unordered collection without duplicates 
16:20:57 <hpc> other examples of an abstract data type you probably wouldn't think about - Int or (->) themselves
16:21:18 <ski> > 1%2 + 1%3
16:21:21 <lambdabot>  5 % 6
16:21:39 <jle`> > S.size (S.fromList [1,2,3,1])
16:21:42 <lambdabot>  3
16:21:48 <jle`> (it ignores the duplicated 1)
16:25:01 <hpc> here's a nice practical application of knowing how to do algebra with ADTs
16:25:07 <hpc> imagine if haskell allowed values to be null
16:25:09 <gabbiel> so some types, although ADTs are better thought of as abstract data types
16:25:21 <hpc> that'd add one to the "number" for every type
16:25:33 <hpc> how many values would (Bool -> Bool) have in that scenario?
16:26:07 <gabbiel> well if its 3 values for Bool now
16:26:14 <hpc> there's a sneaky trick here btw
16:26:15 <gabbiel> then it'd be 3^3
16:26:36 <hpc> so not only does each Bool have a null
16:26:36 <jle`> gabbiel: i'd say non-algebraic abstract data types, to be exact, since algebraic data types can be considered abstract. but it's just that ADTs are so common in haskell that anything non-ADT gets looked at funny
16:26:41 <hpc> but the whole function can be null too
16:26:44 <hpc> 10 total values :D
16:27:14 <jle`> D:
16:27:23 <hpc> even for something as simple as boolean logic, null nearly triples the amount of thinking you have to do
16:27:43 <gabbiel> wait, im confused. so every value can be either the value or null, or is null just a value
16:28:47 <jle`> we're talking about some languages where every type A has an extra value, 'null_A', alongside its normal values
16:28:53 <hpc> ^
16:29:01 <EvanR> null, Bjarn Stroustup's biggest mistake
16:29:05 <hpc> "null" is a common name for the extra element of every type
16:29:17 <hpc> or if you're feeling particularly casual, "null" is a value of any type
16:29:38 <jle`> so where in haskell |A^B| = |B|^|A|, in those languages, |A^B| = |B|^|A|+1
16:29:56 <jle`> and |(A,B)| = |A|*|B|+1, etc.
16:30:18 <jle`> so it just makes the concept of 'type algebra' way too complicated to be worth using as a tool
16:30:22 <EvanR> Maybe Bool = Just True | Just False | Just null | Nothing | null    :(
16:30:26 <gabbiel> jle`: didn't you say that maps are composed of sum and product types, therefore algebraic?
16:30:40 <jle`> gabbiel: sum and products of what?
16:31:07 <jle`> when you try to actually express it in terms of sums and products, that's where you will run into trouble
16:31:25 * ski . o O ( "Null References: The Billion Dollar Mistake" by Charles Antony ("Tony") Richard Hoare in 2009 at <https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/> )
16:31:55 <jle`> gabbiel: oh, i misread what you said. hm, i don't recall ever saying that
16:31:58 <jle`> unless i wrote a typo
16:32:00 <EvanR> Tony Hoare, really
16:32:22 <ski> jle` : s/A^B/B^A/ (or s/A^B/A -> B/)
16:32:27 <gabbiel> maybe I misunderstood, but I recall somebody saying that Map could be expressed as an ADT
16:32:36 <jle`> oops, thank you
16:32:38 <EvanR> right Stoustrup's mistake was C++
16:32:59 <jle`> gabbiel: ah yeah, someone did say that you could maybe do it in a very complex and not-very-useful way
16:33:00 <gabbiel> seems that having null as a value is not a good idea
16:33:08 <EvanR> ^
16:33:10 <hpc> :D
16:33:34 <hpc> gabbiel: technically, https://hackage.haskell.org/package/containers-0.6.2.1/docs/src/Data.Map.Internal.html#Map
16:33:55 <hpc> but the "legal" values are fewer because you're not supposed to have duplicate keys and whatnot
16:34:09 <jle`> yeah, so that rep doesn't respect the cardinality rules
16:34:25 * ski . o O ( "I Did It For You All...", interview with Bjarne Stroustrup in 1998-01-01 at <http://harmful.cat-v.org/software/c++/I_did_it_for_you_all> )
16:34:35 <jle`> so it's not an actual product/sum, even though it might be implemented at the byte level in some vaguely familiar way 
16:34:39 <hpc> if you naively math out that ADT, Map () () = infinite
16:34:44 <hpc> in practice, Map () () = 2
16:34:52 <hpc> empty and fromList [((), ())]
16:35:13 <gabbiel> that data declaration looks weird, I've never seen anything like that 
16:35:33 <hpc> it does a lot of things you shouldn't try to emulate right away
16:35:51 <jle`> it's actually not that bad 
16:36:01 <hpc> yeah
16:36:13 <jle`> data Map k a = Bin Int k a (Map k a) (Map k a) | Tip
16:36:18 <jle`> not too different from everyone's favorite binary try
16:36:34 <jle`> data Tree a = Node a (Tree a) (Tree a) | Leaf
16:36:55 <jle`> remember that syntactically, {-# ... #-} is a comment
16:37:10 <jle`> it's just not a very common comment syntax, people usually use line comments like -- blah blah
16:37:14 <hpc> the ! and such, are visual noise for this purpose
16:37:21 <jle`> ah yeah, i missed that part
16:37:26 <jle`> i guess my eyes just glossed over them haha
16:37:30 <jle`> sorry
16:37:30 <hpc> {- ... -} is a block comment
16:37:40 <jle`> (ah yeah, that too)
16:37:51 <hpc> the # around it mean it's got some compiler magic inside
16:38:00 <hpc> which doesn't matter for this
16:38:25 <gabbiel> I didn't know that
16:38:29 <ski> gabbiel : `[a] = 1 + a * [a]', so `[a] - a * [a] = 1', hence `(1 - a) * [a] = 1', and so `[a] = 1 / (1 - a)'. but `1 / (1 - a)' is the "closed formula" for the geometric series `1 + a + a^2 + a^3 + ...'
16:38:31 <gabbiel> what is that !
16:38:35 <ski> gabbiel : conclusion : `[a] = 1 + a + a^2 + a^3 + ...'. in words : a list of elements of type `a' is either no `a's, or one `a', or two `a's, or three `a's, or ...
16:38:37 <hpc> they'll be interesting to you if you ever are interested in implementation details like memory layout and evaluation strategies
16:39:22 <gabbiel> sorry just read ur comment about !, ok ill ignore it
16:40:21 <gabbiel> ski: is that an expression for determining how many types of a Map? 
16:40:45 <hpc> ski switched to talking about lists there
16:40:49 <gabbiel> oh ok
16:40:54 <ski> no, that's about lists
16:41:34 <gabbiel> let me see: data [] = [] | a : [a]
16:41:48 <gabbiel> which would be 1 + a * [a]
16:42:06 * hpc . o O ( quotient types -> [] -> taylor series -> https://sociorocketnewsen.files.wordpress.com/2016/07/mind-blown.gif?w=580&h=435 )
16:42:09 <gabbiel> opps, data [a]
16:42:25 <gabbiel> oh i see, it makes sense looking at your expression
16:42:34 <ski> the data constructor `[]' corresponds to the `1' (an "empty product") in the sum, while the `(:)' data constructor, joining `a' and `[a]', corresponds to `a * [a]' (a binary product)
16:43:00 <ski> (the former data constructor is nullary, takes zero arguments, while the latter is binary, takes two arguments)
16:43:53 <ski> anyway, the fun part about my "derivation" above is that it's not at all clear what, if anything, subtraction and division of types is to mean, but we still get something that looks sensible in the end ;)
16:44:49 <gabbiel> yeah I was going to ask, what [a] meant if it = 1/(1-a)
16:45:26 <gabbiel> oh ok, i see now
16:45:31 <gabbiel> that's pretty cool
16:46:50 <ski> if you have `data Tree a = Leaf a | Branch (Tree a) (Tree a)', then you get `Tree a  =  a + Tree a * Tree a  =  a + Tree a ^ 2'
16:49:14 <gabbiel> so, Tree a means 'an a' or ???
16:49:59 <ski> iirc, if you (putting `t = Tree a') solve (for `t') the quadratic equation `t = a + t^2', getting something involving a square root, you can then do a fourier expansion of that, getting `Tree a = t = a + a^2 + 2*a^3 + 5*a^4 + 14*a^5 + ...', where `1',`1',`2',`5',`14',&c. are the Catalan numbers, which count how many binary trees which a particular number of leaves (in this case) there are
16:50:21 <ski> `Tree a' means the type of binary trees with elements of type `a' in the leaves
16:50:28 <ski> (in this case)
16:51:08 <hpc> well now you're at /my/ limit ;)
16:52:19 <gabbiel> yeah I know about what Tree a means in Haskell, but not in this algebraic expression
16:52:30 <gabbiel> much less Tree a^2
16:56:02 <gabbiel> its just weird, I thought types with recursive definitions weren't ADTs, but now I see it doesn't matter, because Leaf a | Node (Tree a) (Tree a) is a sum type of product types, therefore ADT
16:56:21 <ski> gabbiel : you could write `tree(a)' instead, if you prefer that more traditional function application notation in math
16:57:05 <gabbiel> tree(a) = leaf(a) | node(tree(a), tree(a)) ?
16:58:10 <ski> rather `tree(a)  =  a + tree(a) * tree(a) =  a + tree(a) ^ 2', then
16:58:56 <ski> (the `data ... = ... | ...' notation is Haskel algebraic data type notation, not math notation)
17:01:09 <gabbiel> i see. I think I understand ADTs a little bit more now. thanks for the help guys
17:02:57 <Squarism> Anyone tried using WebGHC?
17:29:13 <suzu> hmm
17:29:15 <suzu> today is july 2
17:29:27 <suzu> GHC building with WASM as a Target is to be complete by today
17:35:24 <Jake> Hi, I'm new to Haskell
17:35:42 <Guest54745> I was wondering if anyone could explain to me what the following is saying
17:36:24 <Guest54745> When defining a function that maps from lists to a double type they used; x:xs -> x * product xs
17:36:34 <Guest54745> I don't know what x:xs means
17:36:43 <turab> : is the "Cons" function
17:36:45 <suzu> it desugars a list
17:36:52 <turab> Are you familiar with that?
17:36:55 <suzu> into the first element, `x`, and the remainder of the list, `xs`
17:37:01 <Guest54745> No
17:37:01 <turab> ^
17:37:13 <ski> > let tree x = 1/2 + sqrt (1/4 - x) in [tree (x :+ 0) | x <- [0 .. 3]]  -- gabbiel
17:37:17 <lambdabot>  [1.0 :+ 0.0,0.5 :+ 0.8660254037844386,0.5 :+ 1.3228756555322954,0.5 :+ 1.658...
17:37:21 <turab> Cons, meaning construct
17:37:22 <suzu> > let x:xs = [1..3] in x
17:37:27 <lambdabot>  1
17:37:28 <turab> cons constructs a list
17:37:29 <suzu> > let x:xs = [1..3] in xs
17:37:34 <lambdabot>  [2,3]
17:37:39 <suzu> it works like that
17:37:51 <ski> > 2 : [3,5,7]
17:37:54 <lambdabot>  [2,3,5,7]
17:38:32 <ski> `x:xs' is the (non-emtpy) list whose first element is `x', and whose remaining elements (possibly none) are all the elements of the list `xs'
17:38:54 <Guest54745> Ok, this is starting to make sense
17:39:02 <ski> > 2 : 3 : 5 : 7 : []
17:39:05 <lambdabot>  [2,3,5,7]
17:39:08 <ski> > 2 : (3 : (5 : (7 : [])))
17:39:12 <lambdabot>  [2,3,5,7]
17:39:53 <ski> every list is either the empty list `[]', or a non-empty list of the form `x:xs', for a first element ("head") `xs', and list of remaining elements ("tail") `xs'
17:40:15 <Guest54745> Ok, so when it says "x:xs -> x * product xs", it's saying with some list that has first element x and the rest of the list is xs, multiply element x by the product xs
17:40:17 <Guest54745> ?
17:40:26 <ski> yes
17:40:32 <Guest54745> Wonderful, thank you
17:40:42 * ski assumes that's a branch in a `case' expression
17:40:50 <suzu> it'll die if the list is empty
17:40:59 <Guest54745> It is in this case
17:41:10 <suzu> i assumine [] -> 1?
17:41:11 <ski> in that case, `x:xs' is a pattern, used to take apart a list into its first element, and list of remaining elements
17:41:23 <Guest54745> So how do you read "x:xs" in English? Is it add the element x to the list xs?
17:41:38 <suzu> i read it as "x followed by exes"
17:41:54 <Guest54745> Great!
17:41:58 <suzu> it is the element x on the list xs, yes
17:42:04 <suzu> that is perfectly fine too
17:42:11 <ski> > let x = 2; xs = [3,5,7] in x:xs  -- here `x:xs' is not a pattern, but an expression, used to *construct* (not deconstruct) a list, from an element that's to be the initial one, and a list whose elements will be the remaining ones
17:42:13 <lambdabot>  [2,3,5,7]
17:42:27 <ski> Guest54745 : or "`x' cons `xs'"
17:43:04 <Guest54745> Yep, that makes sense. Thanks all!
17:43:13 <thosgood[m]> is there some standard/good introductory reference to haskell's type system? trying to understand it as a mathematician who knows a bit about general abstract type theory
17:43:35 <suzu> yeah
17:43:47 <suzu> it's called the Hindley-Milner type system
17:43:47 <c_wraith> thosgood[m], look for descriptions of System F(omega)
17:43:58 <suzu> but it can be extended to a larger system called System F
17:44:31 <suzu> if you're interested in type systems in general, you will want to look at Types and Programming Languages by Benjamin Pierce
17:45:01 <suzu> The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators
17:45:23 <suzu> This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations
17:45:27 <suzu> https://www.cis.upenn.edu/~bcpierce/tapl/
17:47:57 <ski> @where TaPL
17:47:57 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
17:48:06 <suzu> oh TIL
17:48:22 <ski> you could perhaps also try looking at
17:48:30 <ski> @where polymorphic-type-inference
17:48:31 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
17:49:02 <ski> and maybe also (at least the initial parts of)
17:49:04 <ski> @where on-understanding
17:49:04 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
17:49:14 <ski> thosgood[m] ^
17:53:00 <ski> thosgood[m] : maybe you could also be interested in taking a look at the book "Proofs and Types" by Proof and Types (translated and with appendices by Paul Taylor,Yves Lafont) in 1989,1990,2003 at <https://www.paultaylor.eu/stable/prot.pdf> ..
17:54:00 <nullnullnull> guys, anyone know how to set timeout for connectTo host (PortNumber port) ?
17:54:54 <turab> ski: If you don't mind me asking, are you a grad student?
18:01:48 <xlxs4> nullnullnull: millisecondsBeforePingTimeout controls the amount of time the ping timer will wait after sending a ping request before the bot recieves a pingTimeout event.
18:02:24 <xlxs4> nullnullnull: taken from node irc documentation 
18:07:23 <nullnullnull> xlxs4, thanks mate ;) I will read about it
18:34:28 <midi[m]> Wdu guys think of the split of distributed haskell and cloud haskell? Just wanting some other opinions
18:38:48 * dmwit doesn't think of it
18:39:13 <Axman6> I don't understand the question. is there anything inparticular you want comment on?
18:39:34 * DigitalKiwi too doesn't know what you're asking enough to have an opinion
18:39:48 <Clint> i don't know what either of those things is
18:40:56 <midi[m]> Axman6: There just tends to be a bit of separation going on lately. I don't know how to feel about it. Also, a non Erlang redesign is going to take place. It looks interesting
18:42:12 <Axman6> do you have some references or something? I don't think anyone has any idea what you're talking about
18:42:36 <midi[m]> Clint: Check out https://wiki.haskell.org/Cloud_Haskell and http://haskell-distributed.github.io/
18:43:11 <midi[m]> Axman6: yeah, sec. I'll send a link
18:44:00 <midi[m]> Axman6:  Here: https://github.com/haskell-distributed/distributed-process/wiki/Cloud-Haskell-3.0-Proposal
18:45:03 <midi[m]> <Axman6 "do you have some references or s"> Thoughts?
19:08:17 <gabbiel> can someone tell me why this doesn't work?: integrate f a b = sum . map ((*dx) . f) $ [a, a+dx .. b] where dx = 0.1 
19:08:44 <gabbiel> integrate (\x -> x ^ x) 0 1
19:08:57 <Axman6> "doesn't work"
19:09:08 <gabbiel> the second line
19:09:09 <Axman6> without more information, no
19:10:37 <Axman6> do you get an error? does it compile? what is the problem
19:11:30 <gabbiel> it only works for id so far, I tried the second line there, but it gives an error
19:11:45 <Axman6> ... what error
19:12:10 <gabbiel> ambiguous type variable
19:12:25 <Axman6> mate, this is like pulling teeth, do you want help or not?
19:12:30 <turab> :t ^
19:12:32 <lambdabot> error: parse error on input ‘^’
19:12:36 <turab> :t (^)
19:12:39 <lambdabot> (Num a, Integral b) => a -> b -> a
19:12:46 <Axman6> :t (**)
19:12:48 <lambdabot> Floating a => a -> a -> a
19:14:18 <gabbiel> I think it means that (integrate (\x -> x^x) 0 1) is ambiguous
19:14:37 <turab> gabbiel: It would be nice if you can share the exact error message
19:15:00 <gabbiel>  • Ambiguous type variable ‘a0’ arising from a use of ‘print’
19:15:13 <gabbiel>       prevents the constraint ‘(Show a0)’ from being solved.
19:15:40 <gabbiel> error is too big to share here
19:16:44 <Axman6> then paste it somewhere
19:17:26 <Axman6> asking good questions is an extremely valuable skill, give the people you want help from as much help as you can give them - share the code _and_ the error
19:18:34 <Axman6> going to a mechanic and saying "My car doesn't work" gets you nowhere. Saying "My right front blinker isn't working, I have tried replacing the bulb but it still doesn't work" gets your car fixed
19:18:37 <gabbiel> https://pastebin.com/ztPNzMrV
19:19:04 <Clint> gabbiel: what do you imagine the type signature of "integrate" is?
19:19:13 <gabbiel> I said it didnt work for (\x -> x^x), I was specific
19:19:49 <gabbiel> clint: a function and two numbers
19:20:01 <Axman6> ok, I'm done, find someone else with the patience to extract information from you
19:20:01 <gabbiel> and returns another number
19:20:43 <Axman6> That isn't a type, that's english
19:22:09 <gabbiel> I did :t on ghci, and it returns this, like I suspected: (Fractional c, Fractional a, Enum a) => (a -> c) -> a -> a -> c
19:24:08 <Clint> gabbiel: and what is the type signature of (\x -> x ^ x) ?
19:25:31 <gabbiel> Integral b => b -> b
19:26:50 <gabbiel> guess I'll use (**) from now, didn't know (^) only worked with integers, thanks clint
19:34:16 <turab> Is it bad practice to have functions that would trigger -Wincomplete-patterns?
19:34:56 <turab> For example, I currently have a function that takes care of one of the patterns in my data type to avoid duplication
19:35:00 <Axman6> generally yes
19:37:57 <turab> Any general tips to avoid doing something like that?
19:38:21 <Axman6> can you show the code?
19:38:26 <turab> Yes, in a second
19:42:41 <midi[m]> Axman6: did you get a chance,to look at the Cloud Haskell 3 proposal?
19:44:39 <Axman6> not yet
19:54:42 <Squarism> suzu, where do you read that about ghc wasm target?
19:55:11 <suzu> on the ghc wasm website
19:55:51 <Squarism> my google skills lack it seems. Where is that?
19:57:18 <Squarism> ah you mean webghc right
19:57:57 <turab> Axman6: https://github.com/trajafri/Pref/blob/master/src/Transform/CPS.hs
19:58:04 <turab> Line 9
20:00:39 <Axman6> I'd just add letToApp x = x at the end
20:00:42 <Axman6> also, 
20:00:45 <Axman6> :t unzip
20:00:49 <lambdabot> [(a, b)] -> ([a], [b])
20:00:55 <turab> Ahh thanks
20:03:25 <cohn> hi, is there a simple way to create a function pattern for negative integers?
20:03:46 <cohn> so, e.g. foo (-n) = 0 doesn't work
20:04:36 <Axman6> foo n | n < 0 = 0 | otherwise = n
20:05:19 <Axman6> in the past, when we had n+k patterns, that code would have just negated n, not matched on negative numbers
20:05:57 <cohn> ah perfect! Thanks Axman6!
20:13:21 <ContessaTP> Hello. Not sure if this is the proper channel for Stack-related questions, but I have Stack installed on Windows 8 through MSYS2. Whenever I encounter a build failure, I can see the line number but no reason for the error (http://prntscr.com/o9tkii). However, I do see a reason when the build error is due to indentation issues. I also do not see any error messages when I try building through Stack in a regular Windows Command Prompt window.
20:13:51 <ContessaTP> Has anyone encountered this before, and would you know how to turn on error reporting?
20:38:53 <___laika> ?
20:38:57 <___laika> oops
20:39:06 * ___laika hides
20:39:11 <ContessaTP> Does anyone here have experience with Stack's build error reporting functionality? I am unable to see any build errors except for basic indentation-related issues: http://prntscr.com/o9tkii. This is occurring on a Windows 8 machine
20:42:02 <ContessaTP> The version of Stack I am running is Version 2.1.1, Git revision f612ea85316bbc327a64e4ad8d9f0b150dc12d4b (7648 commits) x86_64 hpack-0.31.
20:44:15 <cocreature> ContessaTP: maybe try invoking it via powershell?
20:44:24 <ContessaTP> hmm, let me try that
20:44:51 <cocreature> stack should handle msys implicitly so you shouldn’t need to enter an msys shell
20:45:34 <ContessaTP> I get the same result in Powershell too
20:45:54 <ContessaTP> I upgraded my Stack version recently. I wonder if it's a bug with this latest release?
20:46:03 <ContessaTP> I never encountered this issue before
20:46:17 <cocreature> sounds at least plausible, maybe look at the issue tracker?
20:46:23 <ContessaTP> sounds good
20:46:55 <ContessaTP> btw if you have Stack installed, what version are you running cocreature ?
20:47:17 <cocreature> 2.1.1.1 but I rarely use it and I’m on Linux
20:47:27 <ContessaTP> hmm, ok
20:47:34 <ContessaTP> Thanks, I'll take a look at the issue tracker
20:48:07 <Axman6> Simple solution: Don't write broken code =)
20:48:15 <ContessaTP> :-P
20:48:24 <gabbiel> what's the deal with 1/0 returning Infinity, why not just return an error?
20:48:43 <Axman6> because it's not erroneous
20:49:13 <monochrom> Read up IEEE 754.
20:49:23 <cocreature> that’s the default behavior defined in IEEE754 which is the standard that defines how floating points work in most languages
20:49:34 <cocreature> note that it depends on the type what actually happens here
20:49:34 <monochrom> Or "what every computer scientist should know about floating point"
20:49:38 <cocreature> > 1 / 0 :: Rational
20:49:42 <lambdabot>  *Exception: Ratio has zero denominator
20:49:49 <cocreature> > 1 / 0 :: Double
20:49:54 <lambdabot>  Infinity
20:50:35 <gabbiel> oh I see, it doesn't give error for floats because of the standard
20:51:19 <gabbiel> Why can't I pattern match on "Infinity" then, if its a valid value
20:53:10 <monochrom> The Show instance uses the "Infinity" string but it was not made a valid identifier or constructor.
20:54:12 <monochrom> Instead, use isInfinite
20:54:42 <monochrom> s/identifier/literal/
20:56:48 <monochrom> Bear in mind that only literals and constructors are eligible for patterns. That actually rules out a whole ton of values.
20:57:08 <monochrom> For example all function values cannot be used in patterns.
20:57:32 <monochrom> For example values of abstract types cannot be used in patterns.
21:00:16 <gabbiel> are these "abstract types" not created with the data keyword? 
21:00:30 <gabbiel> aren't data created types Pattern matcheable?
21:00:48 <jle`> some of them are made using data but hidden by export
21:00:54 <jle`> others, like Double, are implemented via the FFI
21:01:11 <monochrom> "Abstract type" means the constructors are not exported to you. Therefore you have no access.
21:01:23 <monochrom> Yes this is a subjective notion.
21:01:34 <jle`> actually i'm not sure if Double is FFI or built into the language. maybe the latter
21:01:51 <jle`> an example of an FFI-based type is Data.Vector's Vector
21:02:00 <monochrom> The same type can be concrete to me because I'm the implementer, and abstract to you because you're the user and I control exports.
21:03:27 <gabbiel> i'm not familiar with exports. is that a module thing?
21:03:34 <monochrom> Yes.
21:06:50 <monochrom> Rational is an example of an abstract type for most of us. 2%4 is a valid term but not a valid pattern.
21:08:39 <monochrom> In fact we can prove that there is no pattern that matches one third.
21:08:42 <gabbiel> that feels weird to me, it should be a pattern
21:09:09 <gabbiel> oh wait nvm, you're right, cause 3%9 is 1%3
21:09:20 <clever> i'm having trouble finding the actual definition of Double!
21:09:31 <clever> i can see a number of its instances, and functions, but not the type
21:09:43 <gabbiel> it'd be a hassle to the compiler
21:09:44 <monochrom> Perhaps it's in GHC.Types
21:09:48 <clever> jle`: some of the things like isInfinite are ffi
21:09:50 <Axman6> @src Double
21:09:50 <lambdabot> data Double = D# Double#
21:10:20 <clever> Axman6: was expecting it to be something like that, but cant find that in the src
21:10:42 <jle`> gabbiel: some types are 'built into' the compiler, and some types are implemented by the FFI (implemented in C, and their interface is a wrapper around C functions)
21:10:51 <jle`> so for these you will not find any in-haskell implementation
21:11:20 <clever> but nearly all of the things baked into the compiler have a # in their name
21:11:24 <gabbiel> makes sense
21:11:35 <clever> and you need to turn on the magichash language feature, to allow you to even touch them
21:12:06 <clever> ghc-prim/GHC/Types.hs:data {-# CTYPE "HsDouble" #-} Double = D# Double#
21:12:13 <clever> aha, its not in base, its in ghc-prim
21:12:55 <clever> https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Types.hs#L141-L164
21:13:00 <monochrom> You will also need to read compiler source code (not just library source code), because the whole point is to bake them into the compiler.
21:13:21 <jle`> gabbiel: just for some context, at this point we're getting into territory that most haskellers never need to touch or understand
21:13:33 <clever> it looks like D# is the raw constructor, and Double# is the primitive type
21:14:06 <monochrom> Yeah D# is actually not special. Just a data constructor with a funny name. But Double# is.
21:14:34 <jle`> but, things like IEEE float behavior (ie, what does 1/0 evaluate to) does probably count as something every programmer should know
21:14:40 <jle`> independent of programming language
21:15:04 <monochrom> D# is strongly ordinary, to the point if I defined my own "data Foo = F Double#" I would get the equivalent of Double.
21:15:21 <clever> https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm#L903-L917
21:15:40 <clever> monochrom: but you wont have the instances of things like Num, Eq, Show, and many others
21:15:41 <jle`> yes, strongly ordinary, as opposed to just weakly ordinary
21:16:21 <monochrom> Oh Num instance of Double is writable in Haskell given Double# operations.
21:16:33 <clever> monochrom: yeah
21:16:53 <monochrom> Double# is not a Num instance anyway. Wrong kind.
21:17:35 <clever> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Float.hs#L462
21:18:05 <clever> addition maps to a function that uses the +## operator
21:18:25 <monochrom> \∩/ the Delegate Pattern
21:18:31 <clever> compiler/prelude/primops.txt.pp:primop   DoubleAddOp   "+##"   Dyadic
21:18:49 <clever> compiler/codeGen/StgCmmPrim.hs:translateOp _      DoubleAddOp    = Just (MO_F_Add W64)
21:19:20 <clever> compiler/cmm/CmmMachOp.hs:  | MO_F_Add  Width
21:19:25 <clever> and i think we should stop before we get any deeper, lol
21:19:55 <monochrom> Oh it stops at FADD alright. That's not too bad.
21:20:33 <clever> well, thats just an opcode in the cmm i believe
21:20:42 <clever> and then the cmm stuff encodes it to something else, platform dependant
21:21:03 <monochrom> Yeah something turns cmm into assembly. That's all.
21:21:20 <clever> compiler/nativeGen/X86/Ppr.hs:                   text " ; fadd ", greg src2 1, text ",%st(0)",
21:21:23 <clever> i think
21:21:40 <clever> oh, fadd is an actual x86 opcode
21:21:57 <monochrom> Yes I did learn my x86 asm!
21:22:10 <clever> so cmm has to do more work for non-x86 in this case
21:22:24 <gabbiel> ok, I feel a little comfortable with haskell and its time to write a real program. I want to fetch data from a user given link, but i dont know any standard library modules for that, what do you guys recommend?  
21:22:50 <monochrom> I think in practice every platform has a floating-point add, it's a one-to-one mapping.
21:22:56 <ContessaTP> Would that be a standard HTTP link gabbiel ?
21:23:10 <clever> gabbiel: https://hackage.haskell.org/package/http-client or https://hackage.haskell.org/package/wreq would be a starting point
21:23:21 <clever> monochrom: AVR
21:23:37 <gabbiel> ContessaTP: it might be https too
21:23:41 <monochrom> You would need to revive PC XT 8088 without 8087 to enjoy doing extra work for floating point.
21:23:46 <clever> monochrom: it doesnt even have 32bit registers, and the 16bit ops use up 2 registers
21:23:53 <gabbiel> thanks clever
21:24:03 <monochrom> Does GHC compile to AVR?
21:24:10 <clever> monochrom: one of my older desktops lacks the fpu, discovered that when i tried to boot linux with loadlin
21:24:18 <monochrom> heh yeah
21:24:23 <clever> monochrom: AVR also typically has <2kb of ram, so i would say no ghc for you :P
21:24:28 <jle`> i just use curl for simple http things, but i wonder if it is not cross-platform
21:25:35 <monochrom> Anyway yeah my "in practice" had an implicit "those that run GHC".
21:28:27 <monochrom> One day our grandchildren are going to ask us "what do you mean your older computer doesn't support this universally standardized GPU instruction?!"
21:29:26 <clever> monochrom: on the flip side, i have played with an avr simulator, written in haskell
21:29:41 <monochrom> Haha that's literally the flip side.
21:29:47 <clever> and i have been wanting something that can auto-generate avr assembly from haskell code, that doesnt involve a heap and rts
21:30:01 <clever> so i can get type safety, without the bloat of the rts
21:30:21 <monochrom> Maybe it is easier to aim for an interpreter instead.
21:30:36 <monochrom> Look at how Hugs is much smaller.
21:30:47 <clever> i'm thinking the nsis monad may be a good example
21:30:59 <clever> http://hackage.haskell.org/package/nsis
21:31:12 <clever> this is a monad, that will generate nsis scripts, for the nsis installer generator
21:31:45 <clever> so i could make a similar monad, that implements basic actions like IO, and then somehow serialize it to assembly
21:32:13 <clever> i may need custom int types, so when i do foo <- bar ; baz (foo + 5) it can serialize right
21:32:33 <clever> so foo+5 turns into a data record describing the action, rather then a bit of cmm
21:35:37 <clever> bbl
21:55:47 <gabbiel> what am I supposed to use for serialization if read and show aren't supposed to be used?  
21:57:57 <monochrom> I would consider Data.Binary (package "binary", comes with GHC).
21:58:32 <EvanR> you can also use aeson, but that raises the question of what the serialization is for
21:58:33 * Axman6 would use serialise
21:59:14 <gabbiel> aeson? isn't that for json?
21:59:42 <Axman6> you don't think JSON is for serialisation?
22:00:11 <monochrom> Someone has to ask the philosophical question "what is serialization?"
22:00:22 <Axman6> you have _a lot_ of options, if you tell us more about what you want to do with your serialised data we can narrow the options down
22:00:23 <EvanR> what is serialization
22:00:29 <monochrom> :)
22:00:36 <Axman6> a misspelling of serialisation
22:00:45 <gabbiel> for example, I made this program with lisp that stores recipe objects. fortunately, serializing objects in lisp is easy. but if I wanted to rewrite this program in haskell. what would I use to serialize my own custom "Recipe" type
22:00:48 <monochrom> Curses.
22:00:56 <MarcelineVQ> the more philisophical question is "but is it serialization?"
22:01:23 <EvanR> well you can easily write a thing that outputs S expressions
22:01:35 <EvanR> or use a package
22:01:41 <monochrom> I wouldn't rule out Show and Read this early either.
22:01:56 <gabbiel> so parse it myself?
22:02:17 <EvanR> yeah if you want the same level of functionality as lisp, Show and Read are basically that
22:02:20 <gabbiel> like, write a line that represents a "recipe" and then have a custom function returning a recipe value
22:02:31 <EvanR> for basic data structures
22:04:12 <gabbiel> Axman6: I mean I guess it is serialization, but isn't it mostly used to exchange data between languages?
22:04:29 <rotaerk> I like cereal
22:04:36 <rotaerk> not sure about the package by that name though...
22:05:18 <EvanR> the good thing about serializations for exchange between languages is there are so many ways
22:05:29 <Axman6> IMO, both binary and cereal have/should be replaced by serialise when it comes to binary serialisation of Haskell types. cerial or binary are fine for parsing arbitrary binary data, though so is attoparsec
22:05:30 <gabbiel> EvanR: i only used s-expressions because thats what lisp works best with. im not sure if they are appropriate here
22:05:55 <EvanR> s-expressions are really easy, which is why lisp uses them
22:06:13 <EvanR> but they are not space efficient
22:06:17 <EvanR> or readable
22:06:29 <monochrom> Axman6: Why?
22:07:23 <gabbiel> EvanR: are they any less space efficient than JSON or YAML
22:07:30 <Axman6> uses a standard encoding, is much faster and better thoughtout than the adhoc serialisation used by binary
22:07:42 <EvanR> depends
22:08:08 <EvanR> but all three are not as space efficient as possible
22:08:26 <Axman6> it may also be more space efficient (though the standard encoding adds some overhead which negates the more efficient encoding of tags)
22:09:02 <monochrom> Hrm I am not happy, Decoder is not an Alternative! Just a MonadFail.
22:09:58 <Axman6> it's designed to not need to use alternative
22:10:37 <Axman6> constructors are tagged so you know which you're going to decode without having to try multiple alternatives
22:11:24 <monochrom> Is that peekTokenType?
22:13:12 <Axman6> https://hackage.haskell.org/package/serialise-0.2.1.0/docs/Codec-Serialise-Tutorial.html
22:15:39 <clever> gabbiel: acid state may be nice
22:16:06 <clever> gabbiel: it handles serialization and syncing to disk
22:16:27 <Axman6> someone a few months ago was working on a rewrite of acid-state which looked interesting, acid-state is effectively dead as far as I can tell
22:17:26 <gabbiel> ill check it out
22:17:57 <clever> gabbiel: basically, you define a type for your database, and some functions to modify it or read from it
22:18:27 <clever> gabbiel: and then you tell acid state to run add_recipe with a recipe object, and it will deal with saving it to disk and loading it next time you open the app
22:19:28 <rotaerk> huh, I never knew you were in #haskell, clever
22:19:50 <clever> gabbiel: https://gist.github.com/cleverca22/bf8c4bdd77129a5d3dd1e740050b002a is a util i wrote, when i was reverse engineering how acid-state serializes
22:19:53 <EvanR> hey unless all acid-states created up to this point are also dead, acid-state lives
22:20:09 <clever> gabbiel: but its also a simple demo of how to add rows and list rows
22:21:12 <clever> rotaerk: the guy that got me into nixos also got me into haskell :P
22:22:40 <MarcelineVQ> so there were two motives for the murder
22:23:18 <gabbiel> nice, ill most likely use that
22:25:04 <rotaerk> ah heh
22:25:40 <clever> MarcelineVQ: yeah, its that bad, i'm now devising ways to use functional programming to auto-generate avr firmware, lol
22:27:10 <EvanR> seems fun
22:28:49 <Axman6> clever: there's a few interesting projects for doing that, copilot comes to mind
22:29:15 <Axman6> Galois were using that for a NASA project to monitor hard realtime systems
22:30:21 <clever> Axman6: ah
22:30:43 <clever> Axman6: funnily enough, i was helping a galois guy debug halvm, before i knew haskell
22:30:54 <clever> so for a time, i knew more about ghc internals, then haskell itself
22:31:35 <Axman6> I can't remember the library it's built on, but you can use it for non-constant time and space stuff (the domain copilot targets)
22:31:57 <clever> kind of learned haskell from the wrong end, starting at the internals of the compiler, lol
22:32:15 <Axman6> we need more halvm in the world. so much promise but I haven't seen it used anywhere outside galois
22:32:38 <clever> one heavy limitation is that it needs a xen host
22:32:47 <clever> one project i worked on, was adding xen support to qemu
22:33:02 <Axman6> We've got plenty of things which are essentially lambda-esque workloads, which need no disk or other things provided by an OS
22:33:36 <clever> Axman6: https://github.com/cleverca22/nix-tests/tree/master/haskell-init
22:33:47 <clever> Axman6: this is an entire linux "distro" in a single ~3mb initrd
22:34:01 <clever> pid 1 is haskell and it contains zero other executables, not even dynamic libraries
22:34:39 <clever> its not as extreme as halvm, but it does get rid of the entire disk, and can then take advantage of all linux drivers
22:35:04 <Nevoic> This might be a generally vague question, but how do you guys "separate" concerns? I'm running up against an IO wall right now.
22:36:44 <clever> Axman6: oh, copilot may be perfect for solving my stationeers problems!
22:37:12 <Nevoic> I have a web server, the "main" method for the webserver is of type `start :: App ()`, and it's called from my actual `main :: IO ()`. The `start` app interfaces with controllers, which retrieves data from a "datastore" (a `data` type with functions on it saving/getting data).
22:37:22 <clever> Axman6: https://gist.github.com/cleverca22/465314761110b26e65383289f2dc10f5
22:37:24 <jle`> Nevoic: i have a different hamper for my different concerns and i make sure to sort them as i use them
22:37:27 <Axman6> stationeers?
22:37:38 <clever> Axman6: basically, this game took mips assembly, and then used it as a basis for an ingame scripting language
22:37:57 <Nevoic> The datastore necessarily returns `IO` things (saving is an IO action, for example), but I want to `save` in my `App()` without having to manage a State monad or doing unsafe perform IO.
22:38:04 <nshepperd> i separate my concerns with a wall of denial and wishful thinking, personally
22:38:06 <Axman6> crazy
22:38:20 <clever> Axman6: you can have up to 128 lines of "assembly", that is based on mips opcodes, no ram, 16 slots in the stack, all registers are floats, and all registers/stack are nvram
22:38:30 <clever> Axman6: comments and blank lines impact addressing (its more line# then address)
22:38:32 <Axman6> nshepperd: mtl style tagless final encoding can make this a lot cleaner
22:38:49 <Axman6> uh, Nevoic
22:38:49 <clever> Axman6: ive been wanting to use haskell to generate this code, and copilot sounds like an answer
22:39:14 <Axman6> not sure copilot would be the right thing for that
22:39:28 <clever> Axman6: https://stationeering.com/tools/ic is an online simulator for the language
22:39:56 <jle`> i don't even see any potential issues with what Nevoic is talking about
22:39:59 <clever> Axman6: the example on the front page of https://copilot-language.github.io/ is a heater control loop, a very common need in stationeers
22:40:40 <Nevoic> jle` the issue is that the code doesn't compile XD. When I try to execute a datastore action in a controller, I'm in an `App` monad or a `Handler` monad and not an `IO` monad.
22:41:08 <Nevoic> I could use the `State` monad and wrap literally all my controllers in IO, but then pretty much 100% of my app is IO.
22:41:17 <saurabhnanda> in ghc, how do I convert a specific warning to an error, eg. -Wincomplete-patterns
22:41:30 <Nevoic> and all my methods would look like `State App IO ()` or something confusing like that.
22:41:40 <clever> Axman6: main problem i can see being timing, in stationeers, you can run up to 128 opcodes per half second, and there is a yield opcode to stall until the next half second, and in some cases you must stall to wait for external devices
22:41:42 <jle`> well it makes sense for the IO portion of your app to be IO
22:42:33 <jle`> also it's not quite clear what you mean by State
22:42:48 <gabbiel> what's the use of :sprint if all it does is print _
22:42:50 <jle`> because App and IO are two different monads/contexts, neither is a "state" of the other
22:42:51 <Nevoic> https://wiki.haskell.org/State_Monad
22:43:07 <jle`> yeah, i'm just not sure how it can accomplish what you claim it can
22:43:24 <jle`> gabbiel: it can print other things, too :)
22:43:29 <Nevoic> Oh yeah, I'm probably thinking of `StateT`.
22:43:37 <Nevoic> Monad transformers.
22:43:42 <jle`> if so, same deal
22:43:43 <nshepperd> Nevoic: what actually is App?
22:43:48 <jle`> i'm not sure how StateT can do what you claim it can
22:43:52 <Nevoic> A monad provided by a library that I have to mess with.
22:43:57 <Nevoic> It's literally called `App`.
22:44:07 <MarcelineVQ> gabbiel: no use, if that's all it did. if you're using it to test a list and just getting _ make sure the list type doens't involve typeclasses. As in use something like [Int] rather than Num a => [a]
22:44:07 <Nevoic> it's how I interface with routes, pretty much.
22:44:13 <nshepperd> usually, if someone has an 'App' monad of some kind, it's actually a monad transformer around IO
22:44:21 <jle`> it looks like this question isn't about high-level program design architecture, but rather about how to use this App type
22:44:25 <nshepperd> and you can just liftIO :: IO a -> App a
22:45:02 <MarcelineVQ> Otherwise I reccomend googling about using :sprint for examples
22:45:20 <nshepperd> same deal with 'Handler' monads, usually
22:46:10 <Nevoic> I can see if these are wrapped around IO, what do I need to import to get `lift`?
22:46:20 <Nevoic> mtl?
22:46:31 <jle`> you import modules, not packages :)
22:46:41 <Nevoic> yeah, semantics, my bad.
22:46:42 <jle`> and you'd import Control.Monad.IO.Class, from base
22:46:52 <jle`> ah, my point wasn't about semantics
22:46:58 <jle`> it is that by looking for modules, you'll find waht you need
22:47:03 <jle`> if you look for packages, you'll often come up empty handed
22:47:22 <jle`> so by looking for modules instead of looking for packages, it'll be easier to find what you are looking for
22:47:23 <Nevoic> Control.Monad.IO.Class doesn't have `lift`.
22:47:27 <nshepperd> it's liftIO, from Control.Monad.IO.Class
22:47:38 <Nevoic> what about the generalized version?
22:48:04 <nshepperd> 'lift' is a different thing
22:48:06 <jle`> what generalized version?
22:48:51 <Nevoic> Nevermind, liftIO worked either way. I think `lift` was a thing specifically surrounding `StateT` when I thought it was around `monads` in general.
22:48:53 <jle`> by the way, i wouldn't conflate MonadIO with monad transformers or lifting through monad transformers
22:49:11 <Nevoic> I don't think I'm conflating them, even if I don't understand them in their entirety.
22:49:11 <jle`> MonadIO is just a typeclass, like Functor or Show or Eq
22:49:15 <Nevoic> I know they're different things.
22:49:16 <MarcelineVQ> it's around monad transformers in general, but lift isn't liftIO
22:49:22 <jle`> i'm not talking about you conflating them, i'm talking about the discussion in general
22:49:34 <jle`> because 'liftIO' was brought up with respect to monad transformers earlier
22:50:02 <jle`> MonadIO just means something that you can 'embed' an IO action into
22:50:20 <Nevoic> I have no idea how MonadIO is different from IO.
22:50:22 <Nevoic> I thought IO was a Monad.
22:50:25 <jle`> MonadIO is a typeclass
22:50:31 <jle`> so it's like how Eq is different from Int
22:50:48 <jle`> or like how Show is different from String, maybe
22:50:57 <dminuoso> Nevoic: Well to extend what jle` said, MonadIO encompasses all the monads that you can execute IO inside.
22:51:00 <Nevoic> Yeah, I know what a typeclass is xd
22:51:18 <Nevoic> Ah alright, I see.
22:51:21 <jle`> Nevoic: right :) so if you know what a typeclass is, and what the difference between a typeclass and a normal type is, then that's the difference between MonadIO and IO
22:51:36 <jle`> in fact MonadIO and IO are sorta similar in this sense to String and Read
22:51:46 <Nevoic> I thought MonadIO was in general what I was missing. IO seemed like an unnecessarily hard problem to solve inside these frameworks when using `App`/`Handler`.
22:51:48 <jle`> liftIO :: MonadIO m => IO a -> m a
22:51:54 <dminuoso> Nevoic: MonadIO is the observation that not just IO can run IO actions, other things can do too. :)
22:51:59 <jle`> read :: Read a => String -> a
22:52:16 <jle`> so an instance of Read is something that you can 'parse' a String into
22:52:20 <gabbiel> wtf, what else can run IO if not IO itself
22:52:39 <jle`> yeah, i wouldn't use 'run' necessarily; the word i usually use is 'embed'
22:52:49 <jle`> it's any monad where you can embed an IO action into it
22:52:58 <EvanR> any MonadIO can run IO
22:53:09 <jle`> 'run' here is sort of a loaded term
22:53:14 <EvanR> haha
22:53:17 <Nevoic> Yeah I mean this all makes sense to me tbh, thanks for the help guys!
22:53:26 <clever> i think itsmore that the thing will hold a reference to the `IO` action
22:53:40 <dminuoso> Nevoic: Equivalently, MonadState encompasses all the monads that have some notion of state to them.
22:53:43 <gabbiel> why call it monadIO, why not something like IO, which encompass all types that can do IO?
22:53:43 <jle`> Nevoic: what it means for App to have a MonadIO instance is that App can sequence arbitrary IO actions within itself
22:53:48 <clever> and you usually have something like `runStateT` that will turn a `StateT` back into an `IO`, and return a list of all `IO`'s within it
22:53:57 <jle`> gabbiel: because IO is already taken
22:54:09 <Nevoic> jle` yeah I gathered that from all the discussion , thanks again!
22:54:11 <gabbiel> disclaimer, idk what monads are yet
22:54:16 <EvanR> gabbiel is referring to the fact that IO is also Applicative?
22:54:31 <Nevoic> dminuoso: good to know.
22:54:31 <jle`> gabbiel: MonadIO is a typeclass, IO is a specific type
22:54:37 <dminuoso> Nevoic: So the relationship between the StateT transformer and the MonadState typeclass, is that _all_ the transformed stacks involving StateT give rise to MonadState instances.
22:54:56 <dminuoso> But non-transformer instances exist. iow you can have stateful monads without StateT :)
22:54:57 <Nevoic> gabbiel: I generally disagree with some naming in Haskell, something I've found is the more conceptually "general" thing is sometimes more specifically named.
22:54:58 <gabbiel> I thought typeclasses could share names with modules and constructors and data types 
22:55:10 <nshepperd> 'what else can lay eggs if not a chicken?' 'a chicken wearing a hat'
22:55:13 <jle`> gabbiel: they can, but it's kind of confusing
22:55:19 <Nevoic> `map` being more specific than `fmap` for one, or `IO` being more "specific" than `MonadIO`.
22:55:21 <jle`> usually we like to give different things different names
22:55:37 <Nevoic> Yeah, I think different things having different names is good lol
22:55:41 <Nevoic> I just think general things should have more general names.
22:55:45 <nshepperd> I don't think typeclasses can share names with data types?
22:55:45 <dminuoso> Nevoic: The term "lift" is terribly overloaded as well, in all fairness.
22:55:46 <Nevoic> And specific things should have more specific thing.
22:55:52 <nshepperd> they both live in the type namespace
22:55:55 <Nevoic> Like `MonadIO` and `IO` should instead be `IO` and `DefaultIO` or something.
22:56:12 <jle`> nshepperd: i think gabbiel might be talking about using modules as namespacing
22:56:15 <Nevoic> I'm sure someone could come up with better names than me, but my point is that "general" things should be named in a more simple way, I think.
22:56:30 <MarcelineVQ> That really sounds like you didn't get it :X
22:57:04 <Nevoic> `IO` being a typeclass and `DefaultIO` being the default "implementation" of that typeclass. I know `implementation` is a very OO word, so it's a crappy thing to say.
22:57:10 <Nevoic> But I don't have a better word to use in my head rn
22:57:12 <dminuoso> Nevoic: There is no "default" implementation.
22:57:20 <clever> https://www.youtube.com/watch?v=ADqLBc1vFwI
22:57:21 <EvanR> MonadIO isn't a class for implementations of IO
22:57:22 <dminuoso> Nevoic: MonadIO is about "where can you embed IO into"
22:57:34 <dminuoso> Nevoic: It turns out that embeddeding IO inside IO is a trivial non-op.
22:57:54 <jle`> the idea that Nevoic is trying to capture might be an "initial" instance
22:58:05 <Nevoic> MonadIO is a typeclass, which means that `data` can "implement" it with the `instance` keyword to be able to "embed" IO inside of it, right?
22:58:11 <Nevoic> Or am I misunderstanding that?
22:58:12 <dminuoso> Embedding IO actions inside some `data App a = App { runApp :: Config -> IO a }` is not quite so trivial.
22:58:33 <jle`> Nevoic: right, but would you call String the DefaultRead ?
22:58:35 <dminuoso> Nevoic: The wording of that sentence is somewhat confusing.
22:58:46 <EvanR> not any monad can implement MonadIO
22:58:53 <dminuoso> If so, I demand its called DefaultShow instead of DefaultRead.
22:59:21 <Nevoic> If nothing else, `MonadIO` is a confusing name for a typeclass. Nothing about it screams "I'M A TYPECLASS!" to me.
22:59:27 <Nevoic> Especially since `IO` is a monad.
22:59:33 <Nevoic> `MonadIO` seems conceptually synonymous without it being explained to me.
22:59:39 <jle`> Nevoic: is...there any typeclass that screams "I'm a typeclass" ?
22:59:42 <dminuoso> Nevoic: the word Monad is because it has a Monad superclass constraint.
22:59:45 <dminuoso> % :i MonadIO
22:59:48 <yahb> dminuoso: class Monad m => MonadIO (m :: * -> *) where; liftIO :: IO a -> m a; {-# MINIMAL liftIO #-}; -- Defined in `Control.Monad.IO.Class'; instance [safe] (Monoid w, MonadIO m) => MonadIO (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] MonadIO m => MonadIO (StateT s m) -- Defined in `Control.Monad.Trans.State.Lazy'; instance [safe] MonadIO m => MonadIO (ReaderT r m) -- De
22:59:56 <jle`> where can i find these screaming typeclass names
23:00:02 <dminuoso> Nevoic: So MonadIO is all *monads* that you can embed IO into.
23:00:09 <Axman6> it's consistent with all the other MonadFoo classes, MonadState, MonadReader, MonadWriter, etc.
23:00:17 <dminuoso> Nevoic: If its not a monad, it cant be MonadIO.
23:00:44 <dminuoso> Nevoic: If you insist on an overly verbose name, perhaps IOEmbeddableMonad might be that
23:01:05 <jle`> Nevoic: no typeclass names 'scream' typeclass; the fact that you know they are a typeclass usually comes from familiarity with them, not from any screaming convention
23:01:18 <Nevoic> dminuoso: I was originally suggesting a less verbose name, not a more verbose name.
23:01:25 <Axman6> MonadsWhichOneMayAsk'PleaseExecuteThisIOAction'
23:01:39 <jle`> Nevoic: in this case actually MonadIO happens to follow a very prevalent typeclass naming convention in Haskell standard libraries
23:01:44 <Nevoic> jle`:  Yeah maybe you're right. I usually find typeclasses are actiony.
23:01:46 <Nevoic> like read/show etc.
23:01:49 <dminuoso> Axman6: Are ticks allowed in the middle of an identifier? :o
23:01:49 <gabbiel> everytime I hear see the word "Monad" I get a headache, idk why
23:01:59 <Nevoic> idk how prevalent that is as a convention.
23:02:07 <Nevoic> gabbiel: I was there 4 months ago.
23:02:09 <jle`> so if anything MonadIO is probably more of a typeclass naming convention than Read/Show/Eq/etc.
23:02:15 <Axman6> % let foo'bar = "Yes" in foo'bar
23:02:15 <yahb> Axman6: "Yes"
23:02:29 <jle`> Nevoic: what do you mean by "action" ?
23:02:33 <dminuoso> MonadIO, MonadState, MonadReader, MonadLogger, MonadXXX....
23:02:42 <Nevoic> jle' a verb.
23:02:51 <Nevoic> read show 
23:02:53 <Nevoic> was what I was thinking
23:02:56 <jle`> hm, how about Eq, Ord, Enum, Bounded
23:02:58 <EvanR> Read Show Floating Ord
23:03:00 <dminuoso> Nevoic: You can think of them as specialized monad typeclasses. So if you understand Monad, the step to Monad___ typeclasses is short.
23:03:12 <EvanR> RealFrac...
23:03:14 <jle`> or pretty much every single typeclass besides read and show :)
23:03:22 <Nevoic> jle`: Yeah like I said I didn't know how prevalent that was. You were definitely right.
23:03:27 <Nevoic> There's no convention.
23:03:32 * Axman6 has always hated the name RealFrac
23:03:36 <EvanR> if you go into kmettskell youll probably get every part of speech
23:03:36 <jle`> i can't think of any other verb typeclass name other than Read or Show, actually, heh
23:03:40 <jle`> maybe ToJSON ?
23:03:45 <dminuoso> Axman6: I hate Integral.
23:03:48 <Nevoic> jle` for sure
23:04:10 <Axman6> Integers are Integral to our application
23:04:17 <dminuoso> Touche.
23:04:23 <Axman6> also, poor integral XD
23:04:35 <dminuoso> Axman6: So Integral captures all the integral data types to our application!
23:04:37 <dminuoso> Got it!
23:04:43 <EvanR> Eqable, Ordable, Divisible, ToJSONable
23:04:52 <nshepperd> from a purist point of view, i would say that typeclass names should be nouns or adjectives
23:04:59 <dminuoso> EvanR: Bindable
23:04:59 <nshepperd> because they express facts
23:05:02 <dminuoso> Fmappable
23:05:07 <Axman6> yes, all other types are in the type class Superfluous
23:05:10 <jle`> yeah, Read/Show actually are kind of weird for typeclass names now that I think about it
23:05:16 <jle`> it should really be Readable or Showable, maybe
23:05:27 <dminuoso> nshepperd: facts? That sounds very off.
23:05:32 <EvanR> WhatThePointIsable
23:05:49 <nshepperd> dminuoso: yes
23:05:53 <jle`> typeclasses can be thought of as predicates
23:06:14 <EvanR> now make the convention that when every name ends in the same annoying pattern (able), you omit it. Now were back here! :)
23:06:17 <dminuoso> jle`: That fits how typeclasses can be used for logic programming. :)
23:06:18 <Axman6> IsFunctor? f
23:06:22 <nshepperd> fact: Int is printable (Show Int)
23:06:35 <dminuoso> nshepperd: The instance declaration is a fact.
23:06:38 <dminuoso> not the typeclass itself.
23:06:48 <jle`> EvanR: yeah, that's why i think it's a reasonable name, it's just some weird convention to drop the -able's
23:07:22 <dminuoso> nshepperd: And we should probably distinguish between `Foo` the typeclass and `Foo` the constraint.
23:07:28 <EvanR> yes -able would be the equivalent of calling every factory SomethingFactory
23:07:42 <EvanR> or every class SomethingClass
23:07:59 <dminuoso> And that's how Java was done. AbstractInterceptorDrivenBeanDefinitionDecorator
23:08:03 <nshepperd> `Foo` the typeclass and `Foo` the constraint are always both called Foo so that doesn't affect my argument in any way
23:08:10 <dminuoso> Or SimpleBeanFactoryAwareAspectInstanceFactory
23:08:19 <dminuoso> (An instance factory, what a name)
23:08:25 <nshepperd> the point is, when you see Show Int, that is a *fact*
23:08:32 <jle`> is there a haskell equivalent of -Bean ?
23:08:44 <dminuoso> nshepperd: No it is not, because seeing `Show Int` does not mean its true.
23:08:58 <nshepperd> it's not just some provided data, because instances are globally coherent
23:09:16 <dminuoso> nshepperd: My point is, its now the specificatoin of `f :: Show Int => ..` that makes it true.
23:09:36 <gabbiel> probably "Zygomorphism"
23:09:42 <nshepperd> nitpick more please
23:10:14 <gabbiel> but probably not that bad since it's not 4 long words concatenated
23:10:24 <EvanR> Show Int is true, and I saw it, so it must be true
23:10:25 <nshepperd> yes, writing "Show Int" on a piece of paper doesn't make the implementation come into existence
23:10:58 <jle`> MonadIO/MonadState/MonadWriter etc. might be one of the more comparable Bean/Factory conventions in Haskell
23:11:02 <jle`> MonadX
23:11:02 <EvanR> Show Int is true, and I saw it, so it must be true whenever I see it
23:11:04 <jle`> HasX
23:16:05 <EvanR> the wacky names of standard typeclasses reflects the fear that someone will want to name a data type something that collides with the standard ones, effectively causing keyword problems
23:16:40 <EvanR> i never ran into this problem in haskell. But try defining a type called World in idris
23:17:09 <nshepperd> does that destroy the World
23:17:44 <EvanR> it destroys your brain because the errors make no sense unless you realize World is already a thing
23:17:57 <jle`> one issue in idris that haskell doesn't have is that the value and type namespaces are the same (iirc)
23:18:14 <jle`> *data constructor and type constructor
23:18:24 <jle`> but i suppose that's more related to a different problem
23:18:53 <gabbiel> what?? that sucks, i was going to learn idris after haskell, thanks for the headsup
23:19:23 <MarcelineVQ> gabbiel: why does it suck?
23:19:30 <dminuoso> I guess its probably a consequence of not wanting a context sentitive grammar.
23:19:37 <jle`> heh yeah, why would you think it sucks?
23:19:43 <dminuoso> The mixing of value and type level is pretty much what Idris explores in the first place.. :)
23:20:19 <EvanR> there is an easy way around what jle` is mentioning, data Identity a = MkIdentity a, etc
23:20:22 <gabbiel> I can't use the same names for values and constructors
23:20:34 <dminuoso> gabbiel: One might argue it can be very confusing in Haskell for beginners.
23:20:35 <EvanR> put Mk on the ctor
23:20:59 <dminuoso> Since you need to juggle between "is Foo a type or data constructor" given some `newtype Foo = Foo ..`
23:21:27 <dminuoso> Idris does not have that problem. :)
23:21:29 <gabbiel> that's why you do :i Foo
23:21:32 <jle`> yeah, of all of the things to hold as valuable, naming data constructors and type constructors the same thing doesn't strike me with a very emotional reaction, heh
23:21:52 <dminuoso> It's a minor language detail you will learn to glance over.
23:21:57 <dminuoso> Just like many of the edges Haskell has.
23:22:00 <gabbiel> im not emotional about it
23:22:04 <jle`> gabbiel: doing ":i Foo" actually illustreates the problem with having data/types having the same name
23:22:19 <jle`> gabbiel: because then it's unclear if you mean Foo the data constructor, or Foo the type constructor
23:22:27 <dminuoso> gabbiel: If you have to ask the tooling because you are not sure, then the confusion happened already. :)
23:22:37 <marmulak> Who is Idris
23:22:51 <dminuoso> gabbiel: What happens actually is that you learn the type and value level namespaces that at some point you will instantly know "oh this has to be the type constructor"
23:23:03 <jle`> marmulak: he plays Heimdall in the Thor movie adaptations
23:23:14 <MarcelineVQ> some guy that wants you to do more upfront thinking while you program than even haskell does
23:23:25 <marmulak> I see
23:23:29 <jle`> gabbiel: i would consider "what?? that sucks" to be an emotional reaction, if i'm reading it properly ;)
23:23:43 <DigitalKiwi> egyptian god i think
23:23:47 <gabbiel> touche
23:23:47 <marmulak> We don't need no stinking constructors
23:24:04 <MarcelineVQ> DigitalKiwi: which one is that?
23:24:05 <dminuoso> jle`: Did you catch the Applicative <-> Monad connection by the way?
23:24:15 <jle`> the main reason it 'has' to be that way in idris is that types are first-class values in idris
23:24:20 <marmulak> If I wanted upfront thinking and whatnot I'd just learn Rust
23:24:21 <EvanR> T, MkT really helped me be not confused in idris
23:24:30 <gabbiel> but I still prefer namespace segregation
23:24:34 <jle`> so you can manipulate 'Identity' the type constructor the same way you can manipulate 'Identity' the data constructor
23:24:50 <jle`> there is no namespace segregation because they exist in the same semantic space
23:25:01 <jle`> dminuoso: i did! it was interesting
23:25:06 <jle`> and it makes sense i think
23:25:39 <gabbiel> well, then it'd be name morphism
23:26:01 <gabbiel> actually, I take that back, maybe the Idris approach is better
23:26:02 <dminuoso> gabbiel: Wh?
23:26:06 <jle`> in haskell types and terms occupy different parts of the language, but in idris the two are merged and both are first-class values, so separating the namespace would be weird
23:26:21 <jle`> that'd be like if ints and bools had different namespaces
23:26:22 <dminuoso> gabbiel: Or perhaps neither is really better or worse as long as suitable mechanisms exist to differtiate values.
23:26:23 <gabbiel> i'm probably just dismissing it because I haven't had experience with it
23:26:31 <jle`> so i could do `x = 10; x = True`, and that would be ok
23:26:34 <EvanR> i'm not sure you could separate the namespaces
23:26:35 <DigitalKiwi> MarcelineVQ: isis' cousin
23:26:37 <dminuoso> gabbiel: In Haskell it gets quite easy to visually recognize type and value namespaces.
23:26:44 <jle`> because if i used x as an Int i'd get 10, and if i used it as a Bool i'd get True
23:27:02 <jle`> (this is silly, and separating types/terms namespaces in idris like this would also be silly)
23:27:29 <marmulak> >Idris is named after a singing dragon from the 1970s UK children's television program Ivor the Engine.[5]
23:27:50 <DigitalKiwi> get out of here with those facts
23:27:51 <MarcelineVQ> marmulak: It's a nice little cartoon
23:28:00 <dminuoso> EvanR: Why not? I mean you could adapt the Haskell technique of using `@` (or equivalent) operator to lift types into the value world.
23:28:22 <dminuoso> e.g. `fmap @[] ...`
23:28:29 <EvanR> i'm not sure there is a specific "value world"
23:28:30 <marmulak> I had no idea
23:28:44 <dminuoso> EvanR: I meant if the value namespace existed.
23:28:46 <EvanR> you can also use "values" in type signatures for example
23:29:07 <jle`> there is some mixups between types, values, and terms here
23:29:10 <EvanR> youre always in the term world
23:29:17 <gabbiel> would be pretty cool to have x be 10 if I typed it as a Int but get True if I typed it as a Bool
23:29:29 <gabbiel> only values have types, and not variables
23:29:40 <dminuoso> gabbiel: That's blatantly false. :)
23:29:45 <dminuoso> gabbiel: It's *terms* that have types.
23:29:46 <jle`> gabbiel: maybe cool for making your code as difficult to read as possible :)
23:30:45 <jle`> i can't think of a more effective code obfuscation method
23:30:51 <jle`> well, maybe a couple
23:31:24 <dminuoso> gabbiel: One of the more widely accepted definitions for regular type systems is as follows by Pierce: A type system is a tractable syntactic method for proving the absence ofcertain program behaviors by classifying phrases according to the kindsof values they compute.
23:31:46 <dminuoso> gabbiel: Note the "classifying phrases" part. So it's phrases that are classified, not values
23:32:18 <EvanR> how did C go so wrong ...
23:33:03 <gabbiel> fine, i admit that was a bad idea
23:33:51 <marmulak> C was kind of an accident of history
23:34:48 <dminuoso> gabbiel: One good way to see this happening in Haskell is our kind system.
23:34:57 <dminuoso> gabbiel: Kinds form a type system of types themselves.
23:34:59 <marmulak> It's better than asm though
23:35:26 <dminuoso> marmulak: LLVM is the better asm abstraction though. :)
23:35:30 <marmulak> Haskell's type system is impressively elegant
23:35:41 <gabbiel> why not go higher than "types of types", why not do "types of types of types"
23:35:41 <marmulak> :)
23:35:51 <dminuoso> gabbiel: We have that too, we call it sorts.
23:35:58 <Ariakenom> marmulak: in the same way haskell is better than C?
23:36:16 <dminuoso> gabbiel: Though things get uninteresting since every kind in Haskell is considered to have the same sort called "Box"
23:36:17 <Ariakenom> dminuoso: and also types
23:36:20 <gabbiel> dminuoso: can we go higher
23:36:24 <marmulak> Somewhat
23:36:31 <marmulak> We are making more abstractions
23:36:40 <marmulak> The problem with too much abstractions is what's absent
23:36:44 <gabbiel> so currently there are sorts of kinds of types
23:36:52 <dminuoso> gabbiel: There's only singletons above that level conceptually. But we are in the process of crushing that tower into a single level.
23:36:58 <EvanR> the kind language is pretty simple, but you still see kinds need to be well formed
23:37:03 <EvanR> not sure if thats what BOX does
23:37:07 <dminuoso> gabbiel: Conflating even kinds into the type system. This is embodied by the extension TypeInType
23:37:09 <EvanR> or if BOX still exists
23:37:35 <Ariakenom> in agda they have type 1, type 2, type 3 ... I believe
23:37:58 <MarcelineVQ> "<gabbiel> why not go higher than "types of types", why not do "types of types of types"" in type theory this is called cumulative hierarchies of universes, the levels never end
23:38:40 <Ariakenom> with TypeInType; 1 :: Int; Int :: Type; Type :: Type
23:38:47 <MarcelineVQ> agda generally has explicit universe levels iirc, idris has inferred universe levels
23:38:54 <marmulak> But if you collect all four infinity stones you can master the universal type hierarchy
23:39:05 <gabbiel> type theory sounds cool
23:39:27 <dminuoso> gabbiel: It very much is. Ive only been scraping at the surface, but its very enjoyable fo rme.
23:39:57 <jle`> just remember not to fall into the common haskell trap: cool and fun, but not necessarily helpful and definitely not required
23:40:09 <gabbiel> people here told me that learning type theory is like a degree in microbiology for fishing, so im not sure if I should learn it
23:40:16 <EvanR> a long time ago there was this type theory called homotopy type theory, it was really cool
23:40:26 <dminuoso> gabbiel: Do it if you enjoy it. But only do it for yourself
23:40:43 <jle`> do it for the enjoyment, but don't be fooled into thinking it'll make you a better haskell programmer
23:40:50 <MarcelineVQ> or put another way: in general it's more useful to do something than to learn something
23:40:52 <dminuoso> EvanR: "a long long time ago" you mean?
23:41:09 <marmulak> Haskell is still hard for me so I don't really write anything that isn't necessary. I'm not even sure functional program allows for unnecessary code
23:41:16 <Ariakenom> you mean "learning type theory [for haskell] is like [...]"?
23:41:19 <jle`> if you've ever picked up a hobby just for fun, then you'd understand
23:41:22 <MarcelineVQ> EvanR: Is this leading to a joke? :>
23:41:44 <EvanR> no i just figure homotopy type theory is deprecated at this point
23:41:45 <dminuoso> I dont even remotely understand what HoTT is about at all.
23:41:48 <jle`> but nobody is out there watching netflix and pretending it's going to help them be a better carpenter
23:41:57 <MarcelineVQ> EvanR: oh, no. agda is being augmented with homotopy as we speak, cubical agda,
23:42:02 <dminuoso> It's this bizarre topic where I cant even understand what HoTT theorist are trying to solve..
23:42:05 <marmulak> It can if you watch carpentry shows
23:42:17 <jle`> you can watch netflix for fun, nobody is going to judge you for it. it's just not necessarily going to help you be a better airplane pilot
23:42:28 <gabbiel> MarcelineVQ: explain "inferred universe levels" and "explicit universe levels"
23:42:36 <marmulak> It can is you watch piloting shows
23:42:43 <dminuoso> jle`: I like the comparison.
23:42:50 <dminuoso> Henceforth I shall quote you on that.
23:42:51 <jle`> so "should" you watch Stranger Things? i can't answer that, it's mostly if you find it enjoyment and you have the spare time
23:42:59 <MarcelineVQ> gabbiel: Having to write what universe your types belong to vs having the compiler figure it out from what you wrote
23:43:08 <jle`> "should" you learn type theory? same answer
23:43:21 <EvanR> TT is like dwarves digging too deep into the foundations of the math world, you don't want to know what will be released
23:43:38 <marmulak> If something can be learned it has value
23:43:42 <jle`> marmulak: watching carpentry shows to learn how to be a better carpenter sounds like watching baseball movies to become a better baseball player
23:43:47 <dminuoso> EvanR: Perhaps we should have ethical discussions about whether HoTT is allowed to continue?
23:44:00 <MarcelineVQ> dminuoso: It's not just about solving things, it's about bringing things together. The inexhorible march towards universal theories
23:44:01 <dminuoso> Just like we had with CRISPR CAS9
23:44:06 <jle`> marmulak: yes, if something can be learned it has value. but the value it has depends on the specific thing being learned
23:44:28 <jle`> so learning type theory has value, and that value can be applied to things that aren't writing haskell
23:44:28 <MarcelineVQ> jle`: idk man, I learned a lot from carpentry shows
23:45:16 <jle`> but yeah, i get your point. you can't go through life judging whether or not to enjoy hobbies based on whether or not you "should"
23:45:23 <jle`> as if there was some moral imperative to learn or enjoy or pick up a hobby
23:45:38 <jle`> but, you should also be realistic with yourself as to what those hobbies might help you with
23:45:44 <jle`> and what they won't
23:46:14 <EvanR> cubic agda? really?
23:46:16 <jle`> so don't learn type theory because you think there is some moral imperative that means you "should" learn it
23:46:22 <jle`> just learn it because it's fun and enjoyable
23:46:35 <jle`> or don't :)
23:47:07 <MarcelineVQ> EvanR: ye
23:47:32 <jle`> learn it because it's fun and enjoyable, and also knowing that it won't help you with haskell
23:47:37 <gabbiel> i would love to learn it, but there is a moral imperative, that is, is learning this going to help me feed my family
23:48:08 <EvanR> just in time for linear haskell and dependent haskell, now we need to start waiting for cubical haskell
23:48:08 <MarcelineVQ> EvanR: people get excited about univalence, though I don't understand it myself. I still have trouble with definitional equality
23:48:21 <jle`> if your end goal is feeding your family, then i don't see how type theory could realistically contribute to that end goal in a way that other methods would be vastly more efficient in
23:48:40 <jle`> but, even those who need to feed their families deserve a fun hobby
23:49:30 <teto> while trying to push my package to hackage, I get "'include-dirs: headers' directory does not exist.". How can I tell cabal to put the "headers" directory in the tarball generated by `cabal sdist` ?
23:49:34 <EvanR> univalence is this law like function extensionality, two laws you usually state just because you want to. But in some type theories they are theorems, and this blows my mind
23:49:57 <gabbiel> I like programming for programming's sake, but of course, at some point, I need to make money through programming. maybe I should type theory after having found a job (for me at least) 
23:50:26 <sclv> teto: extra-source-files? 
23:52:08 <jle`> i wouldn't classify learning type theory as programming, heh
23:52:32 <jle`> well, what is programming, really
23:52:57 <gabbiel> haskell = programming; haskell = math; type theory = math; type theory = programming
23:53:49 <EvanR> QED
23:54:28 <teto> sclv: great that worked
23:54:45 <gabbiel> worst proof ever, notice math = programming
23:54:48 <EvanR> i would believe programming = math, but i wish programming were as ergonomic as math
23:54:51 <MarcelineVQ> All apples are fruit but not all fruit are apples.
23:55:05 <sclv> math is... not ergonomic
23:55:12 <EvanR> on paper it is
23:55:22 <EvanR> after a lot of thinking
23:55:35 <Ariakenom> oo double meaning
23:55:37 <sclv> i've been wading through classic papers from the late 60s all of which use different terminology and naming conventions
23:55:46 <teto> cabal is so weird though, it's like the log levels DEBUG / WARNING  were chosen at random. And hackage forcing me to use an upperbound ... gosh
23:55:51 <sclv> and of course conventions for notation and composition
23:56:20 <EvanR> notation smotation
23:56:27 <sclv> and also assume that you have three other relevant papers handy, all of which say "it is widely known that X"
23:56:47 <sclv> but X is not widely known because that's not how people tend to look at it today
23:56:56 <sclv> so not ergonomic
23:57:12 <MarcelineVQ> the worst part about papers from the 60's is the scan quality
23:57:21 <Ariakenom> legacy math
23:57:27 <sclv> also "we present three different theories which we don't fully relate because we don't now how, but all work pretty well, and seem to be doing the same thing"
23:57:44 <sclv> math in practice on paper is not ergonomic
23:57:55 <sclv> later once the story is figured out and somebody writes a beautiful textbook, yeah
23:58:20 <EvanR> at least, you dont even get that with software code
23:58:41 <sclv> at least you know it compiles
23:59:01 <EvanR> hopefully
23:59:27 <sclv> (one footnote: "Thanks to the person who retypeset this for pointing out that this notation makes no sense and i don't remember what i thought it was supposed to mean. Nonetheless this statement is printed as written for posterity"
23:59:31 <sclv> )
