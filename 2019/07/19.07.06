01:39:42 <afontain[m]> Hi, on my system, this holds true up to at least 10000
01:39:43 <afontain[m]> `test x = (take x (concat $ repeat [4,2])) == map fst [ System.Random.randomR (1,4) (mkStdGen x) | x<-[1..x] ]`
01:39:44 <afontain[m]> Do you think it is a bug is a bug
01:39:55 <afontain[m]> ?let test x = (take x (concat $ repeat [4,2])) == map fst [ System.Random.randomR (1,4) (mkStdGen x) | x<-[1..x] ]
01:39:58 <lambdabot>  Defined.
01:43:01 <afontain[m]> :s test 10000
01:43:28 <afontain[m]> test 10000
01:43:35 <afontain[m]> ?test 10000
01:43:36 <lambdabot> Maybe you meant: tell list let leet
01:43:52 <afontain[m]> ?show 10000
01:43:52 <lambdabot> "10000"
01:44:05 <afontain[m]> ?show test 10000
01:44:05 <lambdabot> "test 10000"
01:44:29 <afontain[m]> :-
01:46:15 <afontain[m]> ?print test 10000
01:46:15 <lambdabot> Not enough privileges
01:46:37 <lavalike> afontain[m]: you're clobbering 'x'
01:48:34 <afontain[m]> Oh, that's true, scoping made it work though
01:48:56 <afontain[m]> test x = (take x (concat $ repeat [4,2])) == map fst [ System.Random.randomR (1,4) (mkStdGen y) | y<-[1..x] ]
01:50:06 <lavalike> it's funny
01:50:16 <lavalike> > [ fst $ randomR (1,4) (mkStdGen y) | y <- [1..] ]
01:50:20 <lambdabot>  [4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2...
01:50:24 <lavalike> > drop 100000 $ [ fst $ randomR (1,4) (mkStdGen y) | y <- [1..] ]
01:50:27 <lambdabot>  [1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3...
01:50:30 <lavalike> xD
01:52:32 <afontain[m]> > (take x (concat $ repeat [4,2])) == map fst [ System.Random.randomR (1,4) (mkStdGen y) | y<-[1..x] ] where x = 10000
01:52:35 <lambdabot>  <hint>:1:102: error: parse error on input ‘where’
01:53:21 <lavalike> > findIndex (1==) [ fst $ randomR (1,4) (mkStdGen y) | y <- [1..] ]
01:53:25 <lambdabot>  Just 53667
01:53:32 <afontain[m]> ((take x (concat $ repeat [4,2])) == map fst [ System.Random.randomR (1,4) (mkStdGen x) | x<-[1..x] ]) where x=10000
01:53:50 <afontain[m]> >((take x (concat $ repeat [4,2])) == map fst [ System.Random.randomR (1,4) (mkStdGen x) | x<-[1..x] ]) where x=10000
01:54:04 <lavalike> afontain[m]: you can try in /query lambdabot
01:54:40 <afontain[m]> ^^
01:55:24 <afontain[m]> /query lambdabot x==1 where x=1
01:55:42 <afontain[m]> likely not what was meant :-/
01:55:47 <lavalike> afontain[m]: "/query lambdabot" on its own should open a windowd where you chat directly with it
01:55:55 <lavalike> then you can type "> expression" to evaluate it
01:57:01 <afontain[m]> I guess that works on IRC and on Matrix client that supports /join and the like
01:57:19 <lavalike> yeah
02:00:58 <afontain[m]> Well, in any case, if i'm making a random number generator, I sould make sure i'm not using microseconds without seconds ^^
02:56:27 <Amras> Why does it seem like every available FRP implementation insists on using frames -_-
02:59:52 <Amras> Yampa won't allow an Event to be triggered multiple times in a single interval using repeatedly, and Reflex literally refers to frames in its definition of Event
03:01:06 <Amras> There's nothing in the original semantics [(Time, a)] to prevent an Event being triggered multiple times in a single frame, but I can't find a robust implementation that allows it
03:09:44 <jackdk> What is the difference between triggering `Event [a]` and allowing multiple `Event a` firings in a single frame?
03:09:55 <jackdk> (er, `Event (NonEmpty a)`
03:13:12 <Ariakenom> Amras: I think I've heard you can accidentally create loops in reflex. Are you sure the same event can't trigger several times in a frame?
03:16:21 <jgt> in Yesod, request logging is done with WAI middleware. Does anyone know any reason not to do this with a Yesod middleware instead?
04:32:31 <cocreature> jgt: the advantage of doing it with WAI middleware is that it’s not tied to yesod. So unless there is an advantage to using yesod middleware for it, it seems like you are just restricting your logger arbitrarily
04:55:25 <foldup> Hi! I'm relatively new to Haskell and I have a question about data types. Is it possible to create a data type where one element is derived from another by applying a function? For example: `data Nametag = N {name :: String, size :: Int}`, where size is automatically derived from name by applying the function `length :: [a] -> Int` on name.
04:56:42 <cocreature> foldup: why do you want it to be part of the datatype instead of having a separate function `size :: NameTag -> Int; size n = length (nane n)`?
05:00:25 <jgt> cocreature: ok, but would it be sensible to move logging into Yesod if for example I'd like to include an authenticated user ID along with every log?
05:03:52 <cocreature> jgt: sounds reasonable
05:04:42 <jgt> ok, thanks for the reassurance
05:06:24 <ahri> given a bytestring Builder I'm using hPutBuilder to write to a file handle, but I'd like to discover what size has been written in that call - how can I achieve this?
05:07:39 <ahri> I only get `IO ()` back :\ I didn't want to fiddle too much with converting the Builder to a ByteString first, and calling `length` because I'm concerned that I don't understand the internals and may be slowing things down
05:10:34 <ski> cocreature : sometimes it would be nice to be able to have such "cached properties". especially for recursive data types
05:16:03 <ski> (one example would be caching the depth, or size, or a tree. it would be nice to be able to specify the depth computation separately, as a recursive pattern-matching function, but then get the behaviour of depth being a field, and when you construct new tree nodes, the depth of that would be computed directly from the fields of the children, rather than recursively again, from the leaves)
05:19:31 <ski> (i suppose one might ponder caching function properties, like e.g. having type `Integer -> Integer' as well, which could be used for state-threading computations. perhaps one'd also like to memoize those functions as well, then, in some cases. now this reminds me of attribute grammars, and also of adaptive/incremental computation)
05:21:12 <cocreature> ski: _I_ know some reasons, I was wondering which one applies to foldup or if it might just be a misunderstanding coming from OO languages where you are used to putting every functionality into the class itself
05:26:34 <ski> okay
05:28:04 <ski> (i'm sorry if it came off as me implying you hadn't thought of such situations. i think i was pondering how one could possibly make a language feature capable of expressing this)
07:01:20 <Amras> Ariakenom, I haven't actually tried to be fair; I was only working off the Hackage documentation, in which Events are defined as either having a value or not each "frame"
07:01:48 <Amras> it's possible the wording is misleading, I will have to take a look
07:02:20 <Ariakenom> Amras: You've probably read more of it than me
07:04:23 <jgt> is there any way to get the HTTP status code in a Yesod handler? Or is this impossible because the status code is determined later than the handler code is run?
07:13:12 <Amras> jackdk, Event [a] deviates from the semantics of FRP (namely, that `mu(Event a) = [(Time, a)]` ). This means that - in the main logic of my software - I have to "pack" and "unpack" events that happen each frame.
07:13:50 <Amras> What I want is an FRP solution which lets me forget about discrete frames entirely when building simulations
07:15:04 <Amras> Also, strictly speaking, if Events are labeled with Frames rather than with continuous Time, I should be using Event [(Time, a)] rather than Event [a]. And at that point I have to wonder why I'm using a library in the first place if I have to recreate the semantics on my end.
07:20:43 <jgt> can I even get a WAI Response in a Yesod handler?
07:23:16 <dmwit> halogenandtoast: Besides code simplicity, Map has another advantage: access time is logarithmic in the number of updates (rather than linear as your function approach is).
07:41:15 <turbo_MaCk> I have an issue with haskell-mode (Emacs) being slow for project that doesn't contain stack.yaml (not using Stack). Is this common issue or something wrong with my configuration?
07:41:57 <monochrom> I don't have that problem.
07:46:00 <turbo_MaCk> I'm going to try to remove some parts of configuration to see if it's not caused by something I have in init.el
07:49:54 <turbo_MaCk> this is really odd. The only configuration I have now is about key binding. Without stack.yaml it's slow as hell. When I run stack init it becomes snappy. 
07:53:06 <turbo_MaCk> just doing `$ touch stack.yaml` makes it snappy. It looks like withtout that it recourses filesystem to find such file...
07:53:29 <turbo_MaCk> it doesn't matter that that file is empty
07:59:16 <JappleAck> turbo_MaCk: do you have some mounted remote file systems? sshfs or something?
08:13:03 <turbo_MaCk> turned out it's not related to haskell-mode but to flycheck-haskell
08:16:55 <Amras> hm... are there any good vim solutions for haskell development? I've been trying to get haskell-ide-engine to work for a long time now with little luck and I can't find any other projects that do even completion and aren't dead
08:17:21 <Amras> looking at haskell-mode it looks useful enough that I am considering trying out emacs for the first time in my life
08:17:31 <Amras> but if there's something equivalent for vim I'd rather use that
08:20:02 <__monty__> Amras: I get usable completion. Run hlint on bufwrite and have ghcid open in a tmux pane.
08:20:46 <__monty__> Think I use neco-ghc for completion.
08:23:38 <fendor> Amras, what is the problem with hie? 
08:24:54 <Amras> it's incredibly heavy, takes a long time to install, and every time I try to configure it it throws a different error
08:25:04 <Amras> I got it working once for a few minutes then it silently stopped responding
08:26:32 <Amras> this could say more about my OS setups being fucked up than about any issues with hie though
08:27:19 <yushyin> Amras: same for me it occasionally stops working and I stopped investigating because it is so fragile
08:27:20 <jedai> Amras: Have you tried a guide like http://www.tpflug.me/2019/01/14/haskell-nix-vim/
08:27:31 <__monty__> Amras: Maybe you *should* give emacs a go though. It's pretty awesome in a different way. Reasons for learning haskell often apply to emacs or vim, whichever you don't know : )
08:28:12 <Amras> I'm just terrified of rewiring my brain away from vim hotkeys
08:28:14 <jedai> Amras: It talks about nix but all in all, I would say the last section is the most important
08:28:40 <yushyin> Amras: emacs has evil (emacs with vim mode)
08:29:11 <__monty__> Amras: Fwiw, I ripped out all the parts I liked from this: https://github.com/begriffs/haskell-vim-now
08:30:02 <Amras> jedai, that guide outright says it doesn't do code completion, which is fair enough but slightly dissapointing
08:30:42 <Amras> __monty__, looking at neco-ghc it seems to depend on ghc-mod which isn't supposed to work in modern ghcs
08:31:48 <yushyin> hie also uses ghc-mod, or not?
08:32:13 <Amras> I think it uses its own fork of ghc-mod
08:33:31 <yushyin> ok
08:35:29 <infinisil> Amras: If you have Nix you should be able to install HIE rather quickly with the prebuilt binaries I'm providing with https://github.com/infinisil/all-hies
08:55:59 <Amras> infinisil, I do not have nix, and it feels like overkill to configure it just for hie
08:56:25 <int-e> . o O ( "Please file a bug if you cannot replicate a working v1- use case with the new-style commands." -- I wonder what the reaction would be if I reported that there's no counterpart for v1-sandbox... )
09:03:16 <int-e> (The thing I like about sandboxes is that I perceive them as clean. Make a sandbox for something you're working on, hack, hack, ... and when you're done you can delete the sandbox and all compilation artefacts will be gone. No interference with other stuff you may also be working on. new-install has no good project-local cleanup story; instead the attitude is that cleanup isn't needed because ......
09:03:22 <int-e> ...err, why exactly? even with the attitude that disk space is cheap, providing a huge selection of installed packages, some of which may be broken (I'm working on `containers` right now...), to each build process seems untenable.)
09:04:17 <cocreature> int-e: can’t you get the behavior you want by changing the store location if you really prefer that?
09:04:53 <int-e> Hmm. Probably.
09:05:16 <monochrom> It is also no secret that v2-install puts docs in a random (even cryptographic strength!) location. This fails to replicate the behaviour of v1-install that puts the doc at a predictable location.
09:05:30 <int-e> So a v2-sandbox init should set up a local cabal configuration file with a .cabal-sandbox-relative store.
09:05:37 <monochrom> But no one cares about building local docs.
09:05:47 <int-e> (and clearing the symlink-dir setting)
09:06:21 <int-e> cocreature: thanks for the idea... I hope I'll remember when v1- support is eventually dropped.
09:06:35 <monochrom> And the attitude behind "no need to delete" is that every 3 years you buy a new computer anyway.
09:06:40 <int-e> (I suppose it's bound to happen sooner or later...)
09:07:43 <int-e> monochrom: I don't know how that is supposed to work. I always reach 90% disk usage quickly, and then I linger around there.
09:08:02 <monochrom> Web designers and cabal developers should be confined to 2010 12-inch 1GHz 4GB-RAM 20GB-disk netbooks.
09:08:49 <hexagoxel> they'd be waiting for Cabal to compile all day long
09:08:55 <monochrom> And stack developers should be additionally confined to 1Mbps wifi.
09:09:12 <int-e> hexagoxel: 4GB is enough. 2GB isn't though...
09:09:30 <int-e> (I'm assuming that you're not wasting half of the memory for a window manager ;-) )
09:09:53 <MarcelineVQ> monochrom: and OS UI devs, kde devs, gnome devs, etc
09:13:16 <monochrom> Anyway I think the cabal developers expect you to just scorch-earth erase $HOME/.cabal/store if you want to GC.
09:13:52 <monochrom> And yes after that next time you build some of your code, there will be much rebuilding of libs.
09:14:53 <monochrom> Hey that's a great idea for an April-1st-class Haskell implementation!
09:16:00 <monochrom> "GC is constant time. Just that after GC there will be much re-computation. Oh but it's OK, the re-computations are lazily done."
09:16:06 <hpc> haha
09:18:12 <cocreature> I don’t think deleting a directory is constant time at least on a lot of file systems
09:18:32 <monochrom> Yeah but a Haskell heap is not a directory.
09:19:06 <cocreature> oh I see, misread your joke :)
09:19:24 <hpc> it's constant time if you enumerate the whole space of inodes :D
09:19:32 <monochrom> Yikes.
09:20:21 <monochrom> I did give this food for thought to my students. "You are to sort an array of size n. But n <= 4G anyway. Is this O(1) time?"
09:27:27 <__monty__> Amras: Hmm, you might be right. Not sure where my completion's coming from then? GHCid replaced ghc-mod on bufwrite.
09:34:11 <int-e> monochrom: isn't that how you distinguish between a performance-aware software engineer from a theoretical computer scientist?
09:34:16 <__monty__> Amras: Maybe I still have some files ghc-mod produced hanging around.
09:37:44 <__monty__> monochrom: Any right answer? Big-O doesn't technically apply if your input is bounded but don't we *always* sweep that under the rug?
09:38:49 <monochrom> No right answer until you have a context and purpose.
09:39:38 <Ariakenom> monochrom: A student in my uni did argue, in an algorithms class, that if n=2³² then log_2(n) would just be 32 so the O(log(n)) algorithm that was supposed to be O(1) is fine. They passed with that argument.
09:40:17 <monochrom> This is what happens to theories aka models. Each serves a purpose within a context.
09:40:36 <Ariakenom> "all models are wrong but some models are useful"
09:41:57 <Ariakenom> int-e: did you mean that the theoretically minded would say that 4G is O(1) and the performance minded would not, or the opposite?
09:45:38 <Ariakenom> ... that teacher also said I would've gotten a greater score if I'd removed a correct table that was working against the, also correct, conclusion I argued below.
09:46:27 <marmulak> ...
09:47:16 <marmulak> I once had a math test in high school where I would have gotten a perfect score but the teacher marked one answer wrong because it was the correct answer but she just couldn't understand how I solved it
09:48:03 <__monty__> We had that too. It makes sense. Much harder to verify a number wasn't copied than a derivation.
09:49:48 <marmulak> it was a test where we were allowed to use calculators, and the problem was to take a trigonomic function and rewrite it so that the answer is given in the first quadrant instead of like the 3rd or whatever higher one. As we know, the calculator gives you the measurement in the first quadrant by default so I just entered the function in my calculator and did its inverse on the result
09:49:49 <Ariakenom> mmhm. I failed a question in numerical methods because I used the wrong variable names. I didn't remember having seen the right ones but maybe they were shown at some point.
09:49:54 * nshepperd once turned in a physics paper that included the line "now solve this integral with Mathematica...". the prof accepted it
09:50:01 <marmulak> She wouldn't award me for it until I explained to her how this works
09:50:09 <hpc> i had the opposite - for a midterm the first question was this big forall/exists mess that we had to rewrite without using logical negation
09:50:32 <Ariakenom> I was happier having derived it ofc
09:50:36 <jedai> As a teacher, apart from special circumstances, I wouldn't award points for an answer that is inadequately explained
09:50:36 <hpc> i didn't want to go through all the equalities to figure it out, so i just sat there and thought for a minute, then wrote "false"
09:50:39 <hpc> got full points
09:50:53 <marmulak> nshepperd: You were able to successfully tap into physicist's perennial contempt for mathematics
09:51:02 <Ariakenom> hpc: :D
09:51:02 <nshepperd> haha
09:51:22 <hpc> i actually got my test back with a red crossed out "?"
09:51:29 <hpc> it was awesome
09:52:35 <jedai> sometimes if the derivation is too annoying to write out and you insured there was no easy way to cheat, you can give full point for just the answer (but that would always be explicitly written, the default is "derivation needed")
09:52:38 <marmulak> Getting that question mark is what smartass students live for
09:53:00 <Ariakenom> for a 50-50 answer you may want a derivation 
09:54:16 <nshepperd> when I'm doing programming problems like code jam or advent of code, I calculate the big-O of my algorithm, then substitute in the actual n that is given. if the result is bigger than a few billion i need a better algorithm
09:54:34 <nshepperd> this is theoretical nonsense, but works in practice
09:55:01 <Ariakenom> marmulak: I did once turn in a formal language, DFA and such, task using the definitions (functions and sets, that were how it was introduced instead of a graph. No points and a question mark. I was a sad smartass
09:55:21 <Ariakenom> butitwasashoertersolution
09:55:22 <hpc> nshepperd: makes sense to me
09:55:43 <hpc> i imagine you'd pick different thresholds based on what operations are being performed, for other algorithms
09:56:29 <nshepperd> yeah
09:56:37 <Ariakenom> nshepperd: same, I was actually thought to do those things that way
09:58:00 <Ariakenom> at least the algorithms teacher said they would've given me the points if I'd been on the verge of failing
09:58:30 <marmulak> Sounds like theoretical sense
09:59:09 <Ariakenom> I would alter it to "theoretically nonsense but works in practice"
10:00:36 <nshepperd> well, if it works, it's gotta cash out to something that makes sense
10:00:45 <nshepperd> but i'm happy not to think too much about it
10:00:57 <hpc> it gets close enough
10:01:52 <Ariakenom> fixed format and grammar: I did once turn in a formal language task (DFA and such) using the definitions (functions and sets, that was how it was introduced) instead of a graph. No points and a question mark. I was a sad smartass
10:02:45 <Amras> Are you sure you didn't specify the grammar by accident instead of the DFA?
10:03:24 <Amras> or did you just write out like NEXT(state0, 'a') = state1?
10:03:46 <Ariakenom> Amras: yeah I wrote the transition function
10:04:03 <Amras> but that is a graph though, just without the visual bits :o
10:04:20 <Ariakenom> no comment
10:05:54 <Ariakenom> the pattern matching several definition style may have been confusing?
10:05:58 <Ariakenom> phi(0, 'a')=1;  phi(1, 'a') = 1
10:07:34 <Amras> I wonder why you bothered to write that in function notation rather than a table
10:08:01 <Amras> but it's pretty legible either way
10:10:43 <Ariakenom> Amras: I could abstract over nodes. I suppose there was some string notation that I used in the patterns and expressions
10:22:39 <Ariakenom> Amras: math notation can be different and ambiguous but I think I stuck to what was used in the course https://imgur.com/a/kJUFHkx
10:33:58 <fraktor> For a given integer `n`, I would like to get a list like `[2..ceil (n/2)]`. However, that expression causes a TypeError for some reason.
10:34:41 <ski> @type ceiling
10:34:42 <lambdabot> (Integral b, RealFrac a) => a -> b
10:34:59 <hpc> what's the error?
10:35:21 <ski> you could use `[2 .. (n+1) `div` 2]'
10:35:38 <hpc> :t \n -> [2..ceil (n/2)]
10:35:40 <lambdabot> error: Variable not in scope: ceil :: t -> a
10:35:51 <solonarv> it's called 'ceiling', I think
10:35:57 <ski> the error is that `n' is an integer, but `(/)' doesn't operator on integers, but rather on fractionals
10:35:59 <hpc> :t \n -> [2..ceiling (n/2)]
10:36:01 <lambdabot> (Integral a2, RealFrac a1) => a1 -> [a2]
10:36:08 <ski> s/operator/operate/
10:36:37 <ski> `div' is "integral division" (rounding towards negative infinity). `mod' is the corresponding "remainder" operation
10:36:57 <hpc> ah, so your problem is n is the wrong type then
10:37:18 <hpc> ski's suggestion with div will work
10:37:25 <hpc> or use fromIntegral n
10:37:26 <ski> > [(n+1) `mod` 2 | n <- [-6 .. 6]]
10:37:29 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1]
10:37:32 <fraktor> Yep! That sounds reasonable, if a little counter intuitive.
10:37:35 <ski> > [(n+1) `div` 2 | n <- [-6 .. 6]]
10:37:37 <lambdabot>  [-3,-2,-2,-1,-1,0,0,1,1,2,2,3,3]
10:37:41 <ski> > [(n+2) `div` 3 | n <- [-6 .. 6]]
10:37:43 <lambdabot>  [-2,-1,-1,-1,0,0,0,1,1,1,2,2,2]
10:37:51 <hpc> :t \n -> [2..ceiling (fromIntegral n/2)]
10:37:52 <lambdabot> (Integral a2, Integral a1) => a2 -> [a1]
10:37:58 <ski> > [(n+3) `div` 4 | n <- [-6 .. 6]]
10:38:01 <lambdabot>  [-1,-1,-1,0,0,0,0,1,1,1,1,2,2]
10:38:05 <ski> these all round up
10:38:59 <Ariakenom> why is there an Integral constraint on the result of ceiling?
10:39:27 <ski> fraktor : int-e's `fromIntegral' suggestion will allow you to convert from your integer `n' to a fractional, which you could then pass to `(/)'
10:39:39 <ski> Ariakenom : because it computes an integer as result ?
10:39:51 <ski> (as does `floor',`round',`truncate')
10:39:55 <Ariakenom> [2..ceil (n/2)] :: [Rational]    makes sense to me
10:40:31 <Ariakenom> well hrm hrm numbers in haskell hrm hrm
10:40:50 <ski> you'd need to use `fromIntegral' again
10:41:21 <ski> hmm .. i suppose the question is whether there's not just a `Num' constraint on the result
10:41:30 <ski> s/whether/why/
10:41:39 * ski can't type today, apparently
10:41:42 <jkachmar> phadej: I saw your comment on Reddit regarding my Alpine Haskell stuff; if I were to modify the base Docker images to provide versions of `cabal-install` as well would that help you?
10:42:02 <ski> @type genericLength
10:42:03 <lambdabot> Num i => [a] -> i
10:42:03 <ski> @type genericTake
10:42:05 <lambdabot> Integral i => i -> [a] -> [a]
10:42:20 <solonarv> now, that one makes sense
10:42:44 <ski> when `i' is output there, there's only a `Num' constraint, but when `i' is (only or also) an input, there's a (stronger) `Integral' constraint
10:42:51 <Ariakenom> ski: yes that was my question
10:43:02 <jkachmar> phadej: The only reason I made it `stack`-specific was that (a) I primarily use `stack` and (b) `stack`'s Docker integration made for a much smoother build pipeline for me.
10:43:05 <ski> so, why is that not the case with `ceiling' ?
10:43:16 <jkachmar>  If the project is useful for you to get small images then it shouldn't be much work to support building everything with `cabal-install` (and I can probably make it selectable by a Makefile argument)
10:43:18 <ski> Ariakenom : it's a good question
10:43:30 <monochrom> @type ceiling
10:43:32 <lambdabot> (Integral b, RealFrac a) => a -> b
10:44:23 <monochrom> Perhaps it's compromise with not having refinement types.
10:48:16 <ski> hmm, apparently the default definition of `ceiling',`floor',`round',`truncate' uses `properFraction'
10:48:21 <ski> @type properFraction
10:48:22 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
10:48:33 <ski> where the first component of the output is to be an integer
10:48:55 <ski> but would it have worked just as well to only have a `Num' constraint on `b' ?
10:49:33 <ski> with the understanding that even if the type `b' supports expressing non-integers, the (first component of the) result computed by `properFraction' should nonetheless be an integer
10:50:01 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/src/GHC-Real.html#RealFrac>
10:56:34 <dmwit> The implementation of properFraction (and ceiling, floor) for Double and Float at least seem to work fine with a Num constraint rather than Integral.
10:57:35 <dmwit> Ratio would be fine too. Not sure about Fixed but it seems like it should be possible to make it work.
10:58:32 <dmwit> :t fromInteger . ceiling -- ;-)
10:58:34 <lambdabot> (Num c, RealFrac a) => a -> c
10:59:20 <ski> yah, that's what spawned the question
10:59:39 <ski> (why you'd need to do that)
11:00:23 * dmwit nods
11:11:40 <phadej> jkachmar: not really, I'm fine with my setup. I think I mentioned in the post that I do value that there's a little of base system in the image, so I can go in and do something. That's a trade-off I'm happy to make.
11:16:45 <__monty__> ski: I guess there's no reason *not* to make the constraint stricter? Harder to go from Num to Integral without losing information.
11:20:03 <ahri> if I have a Word64 and an Int64 and I want to add them together, is there a neater way to do it than using `toInteger` on both, adding them, and then getting back a Word64?
11:21:14 <ski> __monty__ : but in that case, why does `genericLength' use `Num' rather than `Integral' ?
11:21:14 <jedai> :t fromIntegral
11:21:16 <lambdabot> (Num b, Integral a) => a -> b
11:21:34 <jedai> ahri: You can use fromIntegral to convert your Int64 to Word64
11:22:44 <ahri> oh, excellent, thank you!
11:24:03 <jkachmar> phadej: Makes sense. For what it's worth, my images do include a lot of the base system one would need for debugging (`stack` needs "shadow" and the bourne shell at a minimum), the significant benefit is that the images are much smaller
11:24:47 <jkachmar> e.g. if you're statically linking and use `upx` you can get images with large Haskell applications (e.g. nominally 70 MB) down to the 10 - 15 MB range.
11:26:33 <__monty__> ski: Because it's the point of genericLength? (Having some serious dejavu about this, let me check logs).
11:28:26 <__monty__> Nothing in the logs.
11:35:02 <phadej> jkachmar: but you don't include say `curl`. I'm just not convinced that making small images is the right solution for everyone. My setup is *simple*, it's essentially the same binary you would build if you use Ubuntu 18.04 on your development machine. (i.e. the one you do build during development and test)
11:35:12 <ski> __monty__ : i thought the point was to not insist on reault being an `Int'
11:35:42 <phadej> jkachmar: in my use case the image is distributed to at most two-three hosts, so 10MB vs 100MB doesn't really matter
11:35:49 <__monty__> ski: Yes, and if the point is to be flexible, why constrain it to Integral?
11:35:59 <ski> __monty__ : but if it's better for the methods of `RealFrac' to compute a result of an `Integral' type, rather than a `Num' type, then why not the same for `genericLength' ?
11:36:31 <ski> otoh, for the integral input of e.g. `genericTake', you do need something like `Integral'
11:36:54 <__monty__> It's not a bass ackwards design decision but I agree it's not consistent with "produce the most constrained type because it's easier to relax constraints than tighten them."
11:37:11 <ski> so. if it's an input, then it needs the extra constraint. but if it's only an output, then it doesn't need it
11:37:33 <ski> ("extra constraint" being to use `Integral', over using plain `Num')
11:37:46 <__monty__> It's pretty nice to have the guarantee that ceiling and floor result in an integral number though.
11:38:51 <ski> well, you can just pick a result type that is an instance of `Integral', if you want to use the more constrained functionality, no ?
11:38:59 <monochrom> This is why I said that it is a compromise for lack of refinement type.
11:39:10 <ski> you don't need the constraint on the results in `RealFrac' to be `Integral', for that
11:39:44 <__monty__> ski: Don't you need it when composing with a function that needs an Integral input?
11:39:59 <ski> monochrom : by "refinement type", do you mean something like LiquidHaskell ? or do you mean some kind of subtyping thing, but where you remove, rather than add ?
11:40:00 <monochrom> Ideally you would like (Fractional a, Num b) => a -> (b but the value is integral)
11:40:11 <monochrom> Same difference?
11:40:15 <ski> (because i always think of the latter, when i see "refinement type")
11:41:42 <ski> __monty__ : something being in `Integral' implies it being in `Num'
11:42:14 <ski> (or, perhaps, s/implies/presupposes/)
11:42:24 <__monty__> ski:  Yeah but (f . floor) where f :: Integral a => a -> b.
11:43:05 <Ariakenom> [2..ceil (n/2)] :: [Rational]    makes sense to me
11:43:07 <ski> you'll need to pick some specific type to avoid the ambiguity, of course ?
11:43:32 <ski> (because `a' isn't mentioned elsewhere in that type signature)
11:44:42 <monochrom> > [2..5] :: [Rational]
11:44:44 <lambdabot>  [2 % 1,3 % 1,4 % 1,5 % 1]
11:45:49 <ski> hmm .. could we way something like : if we have a polymorphic operation, polymorphic in some tyvar `a', which is constrained by `Num', and which (otherwise) only occurs positively, then any values of this type computed by this operation must be integers ?
11:46:59 <__monty__> Sounds like an Integral constraint?
11:47:42 <ski> monochrom, (quite possibly you're already aware, but i'll state it anyway, if for nothing else, then for lurkers) Ariakenom's point is that `ceiling' produces a result whose type is constrained by `Integral' (rather than `Num'), but `Rational' is not in `Integral'. however every integer potentially produced is conceptually a rational
11:48:33 <ski> __monty__ : `Integral' allows you to do "integral division", and to convert to `Integer'. already `Num' allows you to convert from `Integer'
11:49:16 <monochrom> Oh I was just testing what "instance Enum Rational" does.
11:50:05 <ski> okay
11:50:44 <__monty__> ski: Oh, now I get your point. If you can ask a function for an integer then surely it's already producing integers?
11:50:58 <ski> yes
11:51:10 <__monty__> Couldn't you return a random number from the domain of the return type?
11:51:26 <ski> how, using only the `Num' interface ?
11:52:09 <ski> the operations of `Num' are closed under "being an integer"
11:52:24 <__monty__> You didn't specify it had to be the only constraint though : )
11:53:02 <ski> (but not closed under "being a natural number", because we have subtraction there .. of course, probably the `Num' instance for `Natural' fails in that case)
11:53:04 <monochrom> "sort" could also give you an arbitrary permutation rather than the sorted permutation.
11:53:31 <ski> __monty__ : good point, that's the kind of nitpickery i like to see ;)
11:54:58 <ski> monochrom : yea. but i'd be very surprised if there was an instance of `Num' which would produce a result which wasn't either an integer or some partial version of that
11:55:22 <monochrom> Oh! I see.
11:55:47 <monochrom> Like how "Monad m => a -> m a" can only do one thing.
11:56:14 <ski> i suppose instances of `Num' are generally expected to correspond to rings ?
11:56:25 <ski> is there any octonion instance of `Num' ?
11:56:43 <monochrom> Yeah. Ring plus abs, so I think it's "valuation ring".
11:56:56 * ski nods
11:57:28 <monochrom> I think no one has bothered, but I wouldn't mind.
11:57:28 <ski> (and `fromInteger' is the canonical (unique) morphism from the initial object, the ring of integers)
11:58:31 <ski> what if there's implementations of `product' (or similar), that rely on associativity, for efficiency ?
11:58:47 <ski> (or what does it even mean, if we don't have associativity ?)
11:59:37 * ski idly ponders adding a class `Moufang'
12:02:07 <monochrom> I think product already relies on associativity by hooking up with Foldable which mentions foldMap and Monoid.
12:02:20 <monochrom> Or maybe s/relies on/assumes/
12:03:29 <ski> could well be
13:04:10 <shafox> intero 0.1.40 how do I build, stack 13.27 lts has 0.1.39. 
13:27:12 <statusbot> Status update: some haskell.org www services down due to block storage problems at our provider -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5d210409035f633b443a8476
13:45:29 <ahri> I was hoping to open a file multiple times with different read-only handles (as I could do in C) but I get a runtime exception - how can I work around this?
13:47:18 <jgertm> What are some good examples of high-level state management (dependencies, already compile modules) in compilers?
13:47:48 <dmwit> ahri: WFM. Can you show us what you tried, and what exception you got?
13:48:04 <solonarv> jgertm: GHC, obviously
13:48:20 <dmwit> ahri: Also, are you on Windows? The rules are different there (even for C, I think).
13:48:59 <ahri> I'm on linux, I'll stick it in a gist
13:49:05 <jgertm> dmwit: that's the one I haven't looked at yet :) the magnitude puts me off. I looked at Elm, Purescript and F# but it seems very ad-hoc. Does GHC compartmentalize compiler state in one place?
13:50:28 <jgertm> Eh, not dmwit, solonarv ^
13:50:35 <statusbot> Status update: Services are back, but we're not sure if storage issues are fully resolved yet. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5d210409035f633b443a8476
13:51:12 <solonarv> jgertm: I don't think it does
13:51:30 <solonarv> truth be told I have never looked at that part of its code either
13:52:44 <ahri> dmwit: https://gist.github.com/ahri/0226dca5cb0ee6773bdca585bd3cfe02 - code in body, error in comment
13:58:04 <dmwit> What the heck, why is it so complicated.
13:58:15 <dmwit> Debugging 101: minimize, man.
13:59:26 <dmwit> That said, you can't open a file for both reading and writing. That's probably happening here. I didn't read it carefully, but I do see both a ReadMode and a ReadWriteMode.
14:00:11 <int-e> (fmap.fmap.fmap) ...
14:03:04 <int-e> ahri: So main opens some files, and then readEventsFrom completely ignores the Handles in the MVars in the environment and tries to open the files again...
14:03:22 <int-e> ... completely in line with *** Exception: /tmp/foo/idx: openFile: resource busy (file is locked)
14:04:45 <int-e> (disclaimer: I have not run the code)
14:06:41 <ahri> dmwit: why can't I open a file both for ReadMode and ReadWriteMode?
14:07:37 <ahri> int-e: `writeEvent` uses those handles opened in main, `readEventsFrom` doesn't need write permissions (because it's only reading)
14:07:40 <dmwit> That's a question for #linux, I guess. I would guess it's just too easy to get race conditions.
14:08:41 <ahri> int-e: also, if there's a better approach than `(fmap.fmap.fmap)` I'm interested to know, though that's only in debug code
14:09:10 <int-e> ahri: Huh? Typical RW lock semantics would be that if a writer has the lock, then no reader is allowed.
14:09:50 <int-e> So I'd expect the open-for-read to produce that error. But I still haven't run the code.
14:10:18 <ahri> yes I'm aware of that, in this case race conditions are fine
14:10:43 * dmwit shrugs
14:10:46 <ahri> a read is fine at any time (or will be when I add `fsync`s)
14:10:48 <dmwit> Don't go via the filesystem, then.
14:11:12 <ahri> as for the linux aspect; afaik this scenario is ok
14:11:21 <stepcut> I wonder if grammatical framework would be good for building a site a bit like duo lingo. I want to generate phrases from a pool of words..
14:11:28 <merijn> Then try using the unix package's filesystem functions
14:11:58 <stepcut> in my case, I don't need to translate the phrases -- just generate them
14:13:17 <ahri> int-e: to elaborate; the semantics of my program will be that a read only looks at immutable portions of the file, and writes only append (this is a simplification, but suffices to address your outrage :))
14:22:09 <_deepfire> For some reason some of the individual pages of https://www.haskell.org/onlinereport/haskell2010/ do not open either in Chrome or Firefox -- like https://www.haskell.org/onlinereport/haskell2010/haskellch2.html
14:23:14 <sclv> _deepfire: almost certainly this is due to problems with our block storage
14:23:26 <sclv> h.org has a ticket with our provider right now
14:23:30 <merijn> _deepfire: Works fine in Chrome here
14:23:46 <merijn> oh, hmm that second link doesn't
14:24:13 <sclv> yeah, disks are funky
14:24:15 <_deepfire> merijn, right, the index page works fine, and chapter 1 and 3 do open too
14:24:15 <sclv> sigh
14:24:33 <_deepfire> chapters 2 and 5 do not, for me, though
14:24:37 <sclv> yes
14:24:41 <sclv> we have issues with our block storage
14:32:17 <turab> dmwit: I ended up using effect-stack but seems like it isn't that useful in my case. If I understand it correctly, usage of effect-stack will shine if my other StateT was deeper in the monad transformer stack.
14:33:28 <sofiama> Does Control.Monad.Cont form a comonad? If so, is there a standard package that provides the instance?
14:33:57 <c_wraith> how could it implement extract?
14:35:16 <sofiama> you pass the identity function as the continuation
14:35:27 <turab> sofiama: I don't know this stuff at all but I remember a discussion here a few days back where it was concluded that Cont is a comonad it self
14:35:31 <sofiama> So you need it to be appropriately polymorphic in r...
14:36:27 <c_wraith> that's not how instances work...
14:37:22 <solonarv> Cont is a comonad in Hask^op (not Hask) - which is not particularly useful, because when you write this down it turns out to be the same as being a monad in Hask (a plain old Monad)
14:59:46 <turab> Is there a reason for no MonadError instance of ContT?
15:00:39 <dmwit> turab: If it was deeper, or if the stack were to change in the future, yeah.
15:00:55 <turab> dmwit: Thanks
15:01:35 <dmwit> Dunno about the MonadError question, but ContT does weird things to control flow, so I wouldn't be surprised if the lack of instance was because of that.
15:01:42 <turab> Whoops, found the answer to MonadError/ContT question 
15:02:27 <int-e> I suppose you'd need a second continuation for processing the errors?
15:03:16 <dmwit> int-e: I guess turab was hoping it would hand off error-processing to the transformed monad.
15:03:22 <dmwit> (maybe?)
15:03:30 <int-e> Oh. Maybe.
15:05:58 <turab> dmwit: This is the same case I showed you a few days back.
15:07:15 <dmwit> I think you may be overestimating the strength of my memory.
15:08:47 <int-e> I guess this is where you want delimited continuations and codensity... a MonadError instance for ContT would catch all *future* errors.
15:11:27 <flyyte> hello first time in IRC just had a question about lenses please if anyone has experience
15:11:35 <flyyte> oops can't write multi line
15:13:36 <flyyte> you know what I'm good
15:13:55 <ahri> dmwit, int-e: just so you know, swapping to posix APIs does allow both an fd with rw and another with ro to be open on the same file at the same time - so this limitation is merely in Haskell's abstraction, probably catering for other operating systems I guess
15:15:11 <solonarv> flyyte: actually, you can write multiline messages, just depends on your IRC client
15:15:53 <solonarv> also you could just post the code to gist.github.com or hastebin.com or whichever you prefer, and link to that
15:17:08 <flyyte> alright alright I'll try hastebin but thinking about my question is making me more confused
15:21:13 <afontain[m]> Haha, I had that yesterday
15:37:06 <slack1256> I added some `seq` on a project to deal with a space leak. Given that the strictness analysis is always getting better, should I check in 2 years if the leak still manifest with the future release of GHC?
16:15:57 <solonarv> slack1256: that would certainly be an interesting bit of anecdata!
16:25:22 <fragamus> https://gist.github.com/fragamus/65b43876ffc202d25248d9243c9a7f38
16:31:24 <solonarv> fragamus: position @1 targets the first field of each constructor
16:31:40 <solonarv> this is fine, because all your constructors' first fields have the same type - namely, 'l'
16:31:43 <fragamus> oh so if it has consistent type
16:31:47 <fragamus> yeah
16:32:07 <fragamus> so I cant use position?
16:32:10 <solonarv> but the second fields have different types, so what should the type of the target of position @2 be ?
16:34:33 <solonarv> you could first select a constructor, and then the field: _Constr @"XmlPage" . position @2 -- should work
16:34:51 <fragamus> nice
16:34:58 <fragamus> I shall try it
16:35:02 <solonarv> or you can use: typed @[ModulaPragma _]
16:35:05 <dmwit> (Side note: even knowing how that works, that still blows my mind as mildly magical.)
16:35:54 * solonarv agrees violently
16:36:07 <subttle> Hi, I didn't see anyone mention in the recent scrollback so I'll go ahead and ask, should I expect this to work again soon? I'm getting a "500 Internal Server Error" on https://www.haskell.org/onlinereport/haskell2010
16:36:37 <Lycurgus> define "soon"
16:37:17 <solonarv> subttle: have you checked https://status.haskell.org/ ? there is also https://twitter.com/haskellstatus for live-ish updates
16:37:43 <subttle> lol as in: is this just someone needs to reboot the server  oor some other quick fix. Basically I'm wondering if I need to dig through harddrives to find a copy of 2010 report lol
16:37:48 <subttle> solonarv: Ah, thanks
16:38:04 <subttle> Active incident
16:38:17 <subttle> so it's known then, cool, thanks!
16:38:25 <solonarv> try web.archive.org for a backup copy, that should work
16:38:34 <solonarv> it's not like the report is updated frequently :P
16:38:43 <subttle> solonarv: appreciate it :)
16:39:15 <solonarv> in fact here is a working link: http://web.archive.org/web/20190704232255/https://www.haskell.org/onlinereport/haskell2010/
16:39:41 <subttle> solonarv: <3
16:44:34 <fragamus> i love this generic lens thing
16:47:25 <fragamus> omg constructors with multiple fields can be accesses as a tuple
16:51:05 <fragamus> how does it do all of this
16:53:17 <hpc> what is (,) but a constructor with multiple fields?
17:11:45 <fragamus> Is there a way to get a list of constructor names for an algebraic data type
17:14:17 <monochrom> GHC.Generics could.
17:24:21 <solonarv> I think there might even be a helper function/typeclass alrady made for that
17:28:16 <fragamus> If I manage to get a list of those constructor names, can I use them with generic lens 
17:28:19 <fragamus> putStrLn $ show $ ast ^? _Ctor @"Module"
17:28:46 <fragamus> so "Module" would be a variable at runtime
17:29:01 <fragamus> or is this all done at compile time
17:29:12 <isovector1> can anyone verify for me that `cabal new-haddock` will return code 0, even if it fails to build haddocks?
17:29:17 <phadej> isovector1: yes
17:29:38 <isovector1> phadej: is there a way to make it return 1? :)
17:29:39 <phadej> https://github.com/haskell/cabal/issues/5977
17:29:50 <isovector1> perfect, thanks
17:30:22 <isovector1> haddock is getting on my nerves today!!
17:30:36 <isovector1> i can't even write CI to convince myself i've solved the last problem :(
17:30:47 <phadej> probably the most effective way is to fix it yourself, where "most effective" doesn't mean it's will take only a little of your resources
17:32:27 <isovector1> phadej: i think i'm just going to grep for "failed to build" in the output :)
17:32:45 <phadej> ... and that's why core issues aren't never fixed
17:32:51 <phadej> (or fixed way later...)
17:33:07 <isovector1> okay fine i'll fix it
17:33:09 <isovector1> sheesh
17:33:16 <isovector1> but i'm going to make my CI green first :p
17:33:29 <phadej> I don't mean that.
17:34:00 <phadej> I mean that often enough, people struggle with the same problems someone (and also often me) have opened issues
17:34:09 <phadej> but as only few (i.e. me) keep nagging there, I'm the nagger
17:34:29 <isovector1> yeah, fair. 
17:34:29 <phadej> and things are forgotten
17:34:34 <isovector1> but you're right
17:34:35 <isovector1> i'll just fix it
17:34:56 <isovector1> i bet it'll take ten minutes
17:35:15 <phadej> there's an issue that you don't want builds to fail, when a user have documentation: True in global cabal.config
17:35:22 <phadej> I think the regression was introduced when fixed that
17:35:30 <phadej> I cannot find an issue/PR though
17:36:53 <phadej> https://github.com/haskell/cabal/pull/5459
17:37:31 <phadej> I wonder if haddock will fail if you revert that patch
17:37:44 <phadej> if it's so, that would be helpful input on #5977
17:39:13 <isovector1> i have no idea how to run cabal
17:39:53 <phadej> cabal can be built with `cabal v2-build cabal`
17:40:00 <phadej> and it will print the path at the end, where it is
17:40:04 <isovector1> yeah but i don't use cabal! :D
17:40:09 <phadej> you should
17:40:21 <phadej> polysemy e.g. builds fine with cabal
17:40:28 <phadej> (and someone added cabal.project there!)
17:40:31 <isovector1> stack is a great wrench that has been working well for me since '15
17:40:41 <isovector1> i don't like changes!!
17:41:31 <phadej> I have tried stack around that time, it was nice for a while, but then cabal won
17:42:08 <phadej> and stack-2 is so different, that you can just change to cabal ;_
17:42:10 <phadej> ;)
17:42:51 <vaibhavsagar> I also have complaints about stack 2
17:43:08 <vaibhavsagar> had to pin to 1.9.3 so my builds would keep working
17:43:10 <fragamus> it'd be nice to parameterize the constructor name in this generic lens expression: ast ^? _Ctor @"Module"
17:43:37 <fragamus> Am I going to have to resort to template haskell
17:44:31 <phadej> vaibhavsagar: aren't you a nix user
17:44:39 <isovector1> fragamus: no. you can put a type variable of kind Symbol there
17:44:44 <phadej> nix and stack feels like unholy alliance
17:45:04 <fragamus> isovector1: awesome
17:45:33 <vaibhavsagar> phadej: yes, but my users are not necessarily, so I make sure that the software I help maintain builds with Stack
17:45:49 <vaibhavsagar> I never mix Stack and Nix though, they're like oil and water
17:45:55 <phadej> vaibhavsagar: :)
17:46:32 <vaibhavsagar> if I have to use Stack on NixOS I make it pretend it's Ubuntu, it's the only thing that works reliably
17:46:53 <vaibhavsagar> https://vaibhavsagar.com/blog/2018/03/17/faking-non-nixos-stack/
17:46:59 <phadej> for OSS stuff I might have (outdated) stack.yaml files lying around
17:47:09 <fragamus> isovector1: can you point me to some doc or example
17:47:12 <phadej> never got a mode to cleanup them
17:47:24 <vaibhavsagar> same
17:47:39 <isovector1> fragamus: well it depends on how you want to actually specify that thing. whta do you have in mind?
17:48:21 <phadej> vaibhavsagar: though IHaskell is probably a project which definitely benefits with supporting all ways one might want to build it with
17:48:34 <fragamus> I want to somehow interrogate an algebraic data type for the symobols for all of its constructors and then use those symbols in expressions like the one above
17:48:47 <vaibhavsagar> phadej: yeah, unfortunately I reached the same conclusion
17:49:12 <vaibhavsagar> it means I'm doomed to know the most intricate details of how stack works for as long as I help maintain the project
17:49:24 <phadej> vaibhavsagar: should I make another haskell build tool ;)
17:49:49 <vaibhavsagar> oh god please no
17:50:28 <vaibhavsagar> the other day I had to come up with instructions for cabal sandbox
17:50:34 <fragamus> I think he prefers a capital g
17:50:36 <phadej> oh dear
17:50:42 <phadej> that one should be banished as well
17:50:54 <vaibhavsagar> cabal is already three different build tools wearing a trenchcoat
17:51:11 <phadej> % cabal sandbox
17:51:11 <phadej> cabal: unrecognised command: sandbox 
17:51:21 <yahb> phadej: ; <interactive>:1:1: error: Variable not in scope: cabal :: t0 -> t; <interactive>:1:7: error: Variable not in scope: sandbox
17:51:37 <vaibhavsagar> % cabal help sandbox
17:51:37 <yahb> vaibhavsagar: ; <interactive>:2:1: error: Variable not in scope: cabal :: t0 -> t1 -> t; <interactive>:2:7: error: Variable not in scope: help; <interactive>:2:12: error: Variable not in scope: sandbox
17:51:38 <isovector1> fragamus: okay, no problem. so you want to turn on ScopedTypeVariables and kind sigs and allow ambiguous types; then make your type `forall (ctor :: Symbol) whatever other tyvars. your type` then: `ast ^? _Ctor @ctor`
17:52:02 <isovector1> fragamus: then you can use the C1 constructors via GHC.Generics to get your hands on the constructor names
17:52:32 <phadej> vaibhavsagar: so cabal sandbox will be still there in cabal-install-3.0 but renamed
17:52:44 <phadej> so people would realise, it's not a preferred way of doing things
17:52:46 <isovector1> someone really smart and cool and handsome wrote a book on doing this sort of thing. i'd recommend picking up a copy. https://thinkingwithtypes.com/
17:52:53 <MarcelineVQ> fwiw I've never had an issue using sandboxes which I can't say for the other things
17:52:55 <phadej> (anymore)
17:53:37 <phadej> MarcelineVQ: yes, sandboxes are "reliable", but it's always begin from zero effort
17:53:53 <phadej> makes people be afraid depending on `lens` and all that kind of sillyness
17:53:59 <solonarv> % :! cabal sandbox
17:53:59 <yahb> solonarv: cabal: error while loading shared libraries: libresolv.so.2: cannot open shared object file: No such file or directory
17:54:04 <solonarv> aww :/
17:54:26 <vaibhavsagar> phadej: I don't understand the motivation for deprecating (but not actually deprecating) things
17:54:39 <fragamus> isovector1: thanks I have recorded your words on this and I shall attempt to do it
17:54:46 <phadej> vaibhavsagar: you mean deprecating, but not removing?
17:54:59 <vaibhavsagar> no, because they're still supported
17:55:11 <phadej> vaibhavsagar: if you ask me v1- commands are not supported
17:55:26 <phadej> if you have a problem with them, "fix yourself, or change to use v2- commands"
17:55:30 <vaibhavsagar> hmm, unfortunately those are the ones I use most often :)
17:56:05 <phadej> IMO nix users should only use `cabal act-as-setup`
17:56:19 <fragamus> isovector1: where am I importing Symbol from?
17:56:19 <phadej> everyhing else is in away or another waiting for problems to happen
17:56:57 <solonarv> I suppose there could be a nix layer that just hands cabal a store with everything it needs
17:57:26 <phadej> solonarv: nope, cabal wants to manage its own stuff
17:57:38 <isovector1> fragamus: from `GHC.TypeLits`
17:57:43 <phadej> solonarv: and this pulling back and forth between nix and cabal is not good
17:57:45 <vaibhavsagar> I haven't heard of `cabal act-as-setup`
17:57:51 <fragamus> isovector1: Thanks
17:58:09 <phadej> vaibhavsagar: that's compiled in ./Setup.hs, without anything fancy
17:58:16 <phadej> as nix is the one providing fancy stuff
17:59:01 <vaibhavsagar> that's exactly what I want :)!
17:59:18 <vaibhavsagar> it would be nice if Cabal improved support for Nix
17:59:33 <vaibhavsagar> instead of going off and doing the same thing as Stack
17:59:50 <vaibhavsagar> i.e. 'all your base are belong to us', even when using Nix
18:00:46 <phadej> vaibhavsagar: the non-nix users are quite important demographic of users
18:01:00 <vaibhavsagar> I'm not disputing that
18:01:47 <phadej> and making v2-build and nix interact well is a goal, but _all_ nix users complains does sound like "nix is the only thing people should use"
18:02:01 <phadej> which makes me see red and ignore those
18:02:22 <vaibhavsagar> that's fair
18:02:24 <vaibhavsagar> but I didn't say that
18:02:25 <phadej> s/complains/feature requests/
18:02:33 <isovector1> phadej: that commit you pointed to is definitely the culprit. any idea what the fix should be?
18:02:40 <phadej> isovector1: nope
18:02:55 <phadej> isovector1: I just know that reverting it will break something else :/
18:03:09 <phadej> vaibhavsagar: the problem is finding the right things to do
18:03:46 <phadej> vaibhavsagar: and there's unfortunately very little people who know nix well enough, and understand cabal too
18:04:02 <vaibhavsagar> that makes sense
18:06:45 <phadej> also "nix" isn't a single thing too, as in nixpkgs way to handle haskell stuff is not the only one (though definitely the most common people use)
18:06:59 <isovector1> phadej: are you familiar with this codebase at all? i think the fix is to keep the current logic _unless the command executed was v2-haddock_. Is that information I have access to anywhere?
18:07:16 <phadej> isovector1: I really don't know anything about cabal-install codepaths
18:07:25 <isovector1> no worries. i'll play around
18:07:39 <isovector1> there's a thing called CurrentCommand in scope which looks like a pretty promising avenue!
18:08:26 <phadej> vaibhavsagar: i.e. I cannot say for nix+cabal interaction problem, whether the issue is more on Cabal or more on nix setup of things side
18:08:42 <phadej> isovector1: that looks promising, indeed
18:17:20 <isovector1> phadej: https://github.com/haskell/cabal/pull/6136
18:17:32 <isovector1> any tips on testing this thing would be appreciated!
18:18:15 <eigentourist> anyone awake? I'm trying to find out a few things about lazy bytestrings. Bit of a beginner yet, I'm afraid, but starting to like a lot of what I'm seeing about this language.
18:19:18 <isovector1> eigentourist: what do you want to know?
18:20:51 <eigentourist> well, i'm looking at the specs for data.bytestring.lazy and data.bytestring.lazy.search on haskell.org, and wondering if they're capable of letting me search for a sequence of bytes in a stream without having to do all the work of chunking and buffering myself.
18:21:38 <eigentourist> from what i read, i thought i saw a hint or two that it might be possible, but i'm having a bit of a tough time finding any code examples anywhere.
18:28:44 <vaibhavsagar> phadej: I don't want us to end up in a situation where the behaviour changes so drastically that things no longer build with Nix. Things like the environment file stuff seem like moves in that direction
18:28:45 <isovector1> eigentourist: hmm. i'm surprised there's no isInfixOf for bytestrings
18:29:46 <isovector1> eigentourist: oh there is! but only for strict bytestrings
18:29:55 <eigentourist> i'm afraid i'm way too new at this to be surprised at that. I've done plenty of C, Java, Perl, and lately Python, but pure functional things are still deep water for me.
18:29:58 <isovector1> i guess that makes sense, otherwise you'd have to force the entire thing
18:30:34 <isovector1> in other words, you lose all of the value of having it be lazy if you need to look for a substring
18:31:34 <eigentourist> well, what i'm hoping to do is hook up a pipeline to a file, and use bytestrings to scan it for a consecutive series of bytes. I saw Data.ByteString.Lazy.Search on hackage.haskell.org and got a bit excited.
18:31:54 <phadej> vaibhavsagar: thats why nix should imo operate on lower level, eg using act-as-setup command
18:32:32 <phadej> nix doesn't care about a lot of features (like solver!), and cherry-picking is teicky
18:32:40 <phadej> tricky*
18:33:34 <isovector1> eigentourist: is there a reason you want to use lazy bytestrings instead of strict? searching this thing is fundamentally a strict operation
18:33:34 <phadej> so "starting barebones and adding" is probably better way than "starting with all features and removing badly interracting ones"
18:34:50 <monochrom> "strict" bytestring has the disadvantage that the prefix you have looked at and no longer needs is still kept.
18:34:52 <eigentourist> well, i'm hoping to be able to read potentially large files, that's the only reason.
18:35:02 <MarcelineVQ> megaparsec and attoparsec work with lazy bytestrings
18:35:19 <eigentourist> indeed? I haven't looked into those yet.
18:37:06 <eigentourist> I've had to do this sort of thing in C/C++ before, but of course, I had to allocate buffer memory, read a chunk from the file, and keep a counter into my search string to track how much of it has been found in the buffer, so that an occurrence that lies across two different buffer iterations can be found.
18:39:22 <eigentourist> i think i saw something indicating that the search string needs to be strict, but it would be convenient if the target string can be lazy. I'm about to try Data.ByteString.Lazy.readfile and see what happens...
18:39:28 <sclv> vaibhavsagar: if you have a list of concrete concerns with cabal v2 its worth going through it, including, i think with some of your coworkers?
18:39:49 <sclv> I _think_ that there are sufficient flags in cabal at this point to get v2 and nix playing properly in every regard
18:40:06 <sclv> and I thought that there was work underway to provide nix-cabal integration using v2 exclusively
18:40:21 <sclv> i.e. you can turn off looking for env files, you can point to a custom config that disables hackage downloads, etc
18:40:38 <sclv> or maybe the act-as-setup thing is sort of like that...
18:41:04 <sclv> and importantly, you can do all that stuff via env-vars rather than cmd line flags, which is the more nixy way
18:41:47 <sclv> and my point being that I think I talked this all out with john, gabriel, and some other people some months ago
18:42:00 <sclv> and we went down the list of things necessary and made sure they were all there
19:13:01 <vaibhavsagar> sclv: I'm glad you're keeping an eye on it :)
19:13:42 <eigentourist> is there a pastebin or some such where folks can post a bit of code for someone to have a quick look at? i'm having a ridiculous time with a simple little indentation error.
19:14:38 <eigentourist> or at least, the compiler seems to think that's what it is.
19:19:16 <eigentourist> wait a minute. i -have- a pastebin account. okay, i just posted the code here: https://pastebin.com/41XvPpNN
19:19:42 <c_wraith> eigentourist: you don't have an else for the if on line 33
19:19:52 <c_wraith> eigentourist: whenever ghc complains about indentation, look at the previous definition
19:21:03 <c_wraith> eigentourist: you probably want the when function instead of an if there, anyway
19:21:05 <c_wraith> :t when
19:21:07 <lambdabot> Applicative f => Bool -> f () -> f ()
19:21:08 <eigentourist> right... i've been fooling with that for several minutes now, but didn't know i needed an else. Haskell demands that i always have an else?
19:21:25 <c_wraith> Yes, every branch must result in a value
19:21:39 <eigentourist> *&#, right.
21:13:47 <eigentourist> i think it might be working.
21:13:49 <eigentourist> phew.
21:15:19 <eigentourist> had to use stack to go install some things, but now i have a haskell program that will iterate down through subdirectories and search every file for a given sequence of bytes.
21:16:19 <eigentourist> i loaded up the compiled executable into a hex editor, picked out eight consecutive bytes from it, and tried it out. It finds the executable and a bunch of intermediate object files as well.
21:19:02 <MarcelineVQ> eigentourist: neat stuff
21:19:26 <MarcelineVQ> Gonna use it to make a booru organizer? :>
21:19:57 <marmulak> I don't always moditfy my code, but when I do I modify the executable with a hex editor
21:20:12 <eigentourist> that's an interesting thought.
21:22:48 <eigentourist> have to get it running a bit faster. Hopefully there's a buffer size somewhere in bytestring or the searchstring package that i can increase.
21:23:26 <MarcelineVQ> give it a pool of files to work on at once
21:25:19 <eigentourist> hadn't even thought of parallelizing yet but yes, that sounds like a good next step.
21:26:10 <MarcelineVQ> My own forways into that territory revealed that you can ask for too many files at once really easily so you'll want a cap on requests, qsemaphor or resource pool or whatever
21:27:16 <Fuchs_Staffbot> Greetings! I am Fuchs from Freenode Staff.
21:27:16 <Fuchs_Staffbot> Freenode had problems with disruptive elements and trolls trying to derail our crusade for free and universally accessible software.. Despite this, we are the premier FOSS collaboration platform on the Internet.  Our team of staffers have worked dilligently to ensure Freenode remains a safe, supportive platform where the FOSS commununity can thrive absent of scams and hate speech.  The costs of network monitoring and the lawsuits mounted by 
21:27:16 <Fuchs_Staffbot> Larry Ellison and Oracle have presented challenges to Freenode's very survival.
21:27:16 <Fuchs_Staffbot> Mark Shuttleworth and Freenode staff have now unveiled the Freenode Fortress Project!  Partnering with Huawei, we are in the process of installing an intelligent firewall that will defend against any DDOS or massive spambot operation using Huawei's predictive computing technology, the same software used to track and control China's Uighur Muslim minority.
21:27:16 <Fuchs_Staffbot> Trolls will be recognized based on these predictive patterns and automatically blocked. This system, however, will be costly, and we need your help paying for licensing and installation.
21:27:17 <Fuchs_Staffbot> If every active member on Freenode were to pledge just $20 USD, we could pay for this system and our hosting fees for an entire year. Remember that the defense of FOSS is possible thanks to your efforts.
21:27:17 <Fuchs_Staffbot> Payment information
21:28:00 <eigentourist> that was interesting.
21:28:14 <MarcelineVQ> Come back Fuchsbot where oh where do I send my money to? ;>
21:28:56 <el> MarcelineVQ: can you PM me what was sent?
21:29:18 <MarcelineVQ> sure
21:30:01 <eigentourist> it rapidly leads to a sort of ideological conundrum: who is more evil, huawei or larry ellison?
21:30:51 <cdsmith> Who is the right person to notify that https://downloads.haskell.org/ seems to be down?  (And/or, are they already aware?)
21:32:00 <MarcelineVQ> #haskell-infrastructure I think but there's some ongoing service provider hardware problems today, a report wouldn't hurt though
21:32:34 <eigentourist> are you getting a 500 internal server error from xginx when you try to download something?
21:32:56 <eigentourist> that's what i'm seeing.
21:33:37 <cdsmith> @eigentourist I'm seeing "Error 503 Backend is unhealthy" for most things hosted there (although, oddly, https://downloads.haskell.org/~ghc/latest/docs/users_guide.pdf workedjust fine...)
21:33:37 <lambdabot> Unknown command, try @list
21:33:41 <MarcelineVQ> I get 503 for that page, and occasionally today hoogle doens't load at all, though hackage has been okay
21:33:46 <eigentourist> ran across a fair number of broken links on hackage today as well. maybe same problem.
21:34:03 <MarcelineVQ> content delivery is a strange beast
21:34:10 <eigentourist> "backend is unhealthy" is a new one to me.
21:35:37 <cdsmith> Okay, just checking that people are aware.  Unfortunately, I can't join #haskell-infrastructure (something about registration with nickserv being required), but if someone else can and wants to pass along the news, thanks!
22:17:45 <fragamus> > pi
22:17:48 <lambdabot>  3.141592653589793
22:26:58 <cocreature> c_wraith: https://status.haskell.org/
22:37:09 <fragamus>    
23:16:30 <fragamus> :t const
23:16:33 <lambdabot> a -> b -> a
