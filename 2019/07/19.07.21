00:30:12 <slack1256> > data SProxy k (a :: k) = SProxy
00:30:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
00:30:37 <slack1256> If I define SProxy as above, it has the following kind signature 
00:31:01 <slack1256> SProxy :: forall k -> k -> *
00:31:35 <slack1256> I don't understand that `forall k ->`, it a requirement of an explicit Type Application?
00:43:16 <slack1256> nvm, these are visible type quantification
04:20:55 <Mrbuck> I am not able to think recursively :(
04:21:05 <Mrbuck> how to develop recirsive thinking
04:23:22 <hpc> first you must develop recursive thinking
04:24:08 <Mrbuck> ha ?
04:24:11 <Mrbuck> how?
04:24:29 <Mrbuck> and recursion needs more memory and time how is it used here without loops
04:28:09 <hpc> so, if you're thinking recursion like in java or C, recursion does have extra overhead compared to loops
04:28:39 <hpc> but in other languages there are optimizations you can do
04:29:02 <hpc> if the recursive call is always the last thing in the function, then that bit of code ends up compiling to something like
04:29:29 <hpc> do function bookkeeping; call the function; return and undo function bookkeeping
04:29:35 <hpc> which can be optimized to
04:29:42 <hpc> set new function parameters; goto start of function
04:30:30 <hpc> ghc has an even more different way of doing things
04:30:51 <hpc> the stack isn't the function call stack, it's the evaluation stack
04:31:21 <ski> (well, that ought not be an optimization, but a guarantee. the asymptotical operational behavior, not the particular details of how it happen to be implemented. in Scheme, this property is called "proper tail recursion" (somewhat of a misnomer, since it doesn't have to do with recursion, per se))
04:31:23 <hpc> and it works out that function calls are basically free, and that's how we write all our loops
04:31:54 <hpc> as long as you don't build up data structures in certain unfortunate ways
04:31:55 <ski> Mrbuck : iteration is a special case of recursion
04:33:06 <ski> Mrbuck : to learn recursion, you must learn to let go of wanting to determine "what will happen next/now", iow operational thinking, and learn to trust that the recursive calls will do their job, if you do your job
04:33:13 <hpc> anyway, the upshot of it is, since you understand for loops and such
04:33:50 <hpc> if you can work out how to write the same thing recursively then you've understood one form of recursive definitions
04:34:09 <Mrbuck> ok hpc ski  tahnks for good response
04:35:30 <ski> Mrbuck : you must learn to be able to spot instances of the same general problem you're trying to solve
04:36:54 <ski> e.g., you know `[0,1,2] ++ [3,4]' (list concatention, "append") is supposed to compute `[0,1,2,3,4]'
04:37:18 <ski> when defining `(++)' (or say `append', if we rename it to not clash with the one already defined), we can start like
04:37:34 <ski>   append :: [Integer] -> [Integer] -> [Integer]
04:37:41 <ski>   append xs ys = ..xs..ys..
04:38:13 <ski> where `..xs..ys..' is just a pseudo-code notation i use for "please fill in the blanks here, possibly using the variables `xs' and `ys'"
04:38:40 <ski> you might be able to code this, by deferring to some other functions on list
04:38:51 <Mrbuck> ok 
04:39:04 <ski> however, lists are a defined data-type in Haskell (albeit they have some syntactic sugar)
04:39:07 <ski> @src []
04:39:07 <lambdabot> data [] a = [] | a : [a]
04:40:15 <ski> this means that if you have a list of type `[Integer]' (say), then it must either be of the form `[]' (the empty list), or of the form `x : xs' (a non-empty list, with first element `x', and *list* of remaining elements `xs') (here `x' would be of type `Integer', and `xs' of type `[Integer]')
04:41:18 <ski> so, sooner or later, if you want to do something interesting with lists, you'll have to inspect them, somehow. and the basic way to inspect a list is to check whether it's the empty list, or a non-empty list (and in that case, what's the first element, the head; and what's the list of remaining elements, the tail ?)
04:41:59 <ski> so, assuming we want to inspect lists in `append' itself (rather than deferring to other functions, which, in the end, will have to inspect to be able to do anything nontrivial)
04:42:12 <ski> we decide we want to actually look at the inputs of `append', here and now
04:42:29 <Mrbuck> Ok, I will follow your instructions when I read the code fro the sources I am learning
04:42:32 <ski> but, there's two inputs, `xs' and `ys', which of them do we inspect ?
04:42:41 <ski> we could possibly inspect both
04:42:59 <ski> it's not obvious, at the outset, which of them we should inspect, or if we should inspect both
04:43:09 <ski> but, we could try inspecting the first one, `xs'
04:43:14 <ski> so, we had
04:43:19 <ski>   append xs ys = ..xs..ys..
04:43:50 <ski> to inspect `xs', we'll have to replace the pattern `xs' (to the left of the `=' sign), with one of the two forms of list (empty vs. non-empty)
04:43:59 <ski> in the empty case, we'd write
04:44:07 <ski>   append [] ys = ..ys..
04:44:15 <ski> in the non-empty case, we'd write, say
04:44:27 <ski>   append (x:xs) ys = ..x..xs..ys..
04:45:35 <ski> (note that this `xs' is not the same as the one we just had before. i could have chosen to name this `xs', e.g. `zs'. but since the earlier `xs' is no longer here, i chose to reuse the same name, for a different thing)
04:46:09 <ski> (the previous `xs' was the (whole of the) first argument. *this* `xs' is the *tail* (the remainder) of the first argument, in case it's a non-empty list)
04:46:26 <ski> anyway, taken together, we'd now have the code
04:46:28 <ski>   append :: [Integer] -> [Integer] -> [Integer]
04:46:35 <ski>   append [    ] ys = ..ys..
04:46:40 <ski>   append (x:xs) ys = ..x..xs..ys..
04:47:12 <ski> so, we have two cases, two "branches", one of which will be chosen, depending on whether the first argument is empty or not
04:47:27 <ski> Mrbuck : am i making any sense ? would you like me to continue ?
04:48:55 <Mrbuck> thanks a lot ski, I am saving your logs and will re0read but for now I am not able to follow completely  but I feel i am wasting your time sorry
04:49:09 <ski> it'a okay
04:49:42 <ski> (if you have any questions, just ask)
04:50:39 <Sose> sorry to ask again, but anyone know of any fix to this problem? QuasiQuotes extension with VSCode + HIE plugin and HIE.. https://gist.github.com/Sose/c84016268ea1c1dbe3327086bd83ff9f
04:50:46 <Mrbuck> Sure the problem I have now is I am doing recursion in other language and so wanted to know how its used here as it causes more memory consumption I understand it is optimized]
04:50:54 <Mrbuck> I understand 
04:51:09 <Mrbuck> Thanks a lot for the help again 
04:51:40 <ski> Mrbuck : perhaps that other language (implementation) doesn't afford tail calls
04:53:07 <Mrbuck> ok ski thank you
05:01:58 <sicklorkin> hnra: Sose what version of glib do you have on your system?
05:05:02 <sicklorkin> Sose: ^ oops
05:05:22 <Sose> sicklorkin: pacman -Qs glibc responds local/glibc 2.29-3.1 (base)
05:05:45 <sicklorkin> Sose: objdump -p /path/to/hie
05:06:45 <sicklorkin> Sose: did you build the binaries on the same machine your running VSCode?
05:07:07 <Sose> sicklorkin: no.. I got hie with Nix using cachix for prebuitl binaries
05:07:38 <Sose> https://gist.github.com/Sose/fe5b08f1a00c202bfc674206d5145afc er
05:08:08 <sicklorkin> Sose: hummm... are you running VSCode under nix-shell?
05:08:27 <Sose> no. VSCode is from manjaro's repos and I just run it with "code"
05:09:05 <sicklorkin> Sose: i'm not familar with nix, but iirc you're gonna have to run all the things under nix-shell..
05:09:08 <portnov> https://github.com/portnov/ghcprofview-hs
05:09:25 <sicklorkin> portnov: nice
05:09:32 <kuribas> how do you mix ST monad with a serialisation monad (like Binary or Perist)?
05:10:16 <sicklorkin> kuribas: MonadBaseControl perhaps?
05:10:27 <lyxia> kuribas: to do serialization purely??
05:10:29 <Sose> sicklorkin: I'm not familiar with nix either =( using it was just the first option for installation of haskell-ide-engine on their github page
05:10:49 <kuribas> lyxia: yeah, serialise to a bytestring
05:11:12 <Sose> sicklorkin: it's weird because the hie and the plugin and everything work great except when I enable quasiquotes, then it just crashes
05:11:14 <sicklorkin> Sose: that's unfortuante, can you just build it from sources instead?
05:11:14 <kuribas> lyxia: and from a bytestring
05:11:42 <kuribas> lyxia: I couldn't find a way, other than creating my own serialisation monad transformer.
05:11:43 <sicklorkin> Sose: oh.. i see.. i'm out to lunch then.. 
05:11:55 <Sose> sicklorkin: thanks anyways 
05:11:56 <lyxia> I don't think you can do this safely unless the libraries use PrimMonad, and I bet they don't.
05:12:08 <kuribas> lyxia: since the serialisation monads I saw didn't support transformers.
05:13:43 <kuribas> lyxia: and in IO
05:13:44 <kuribas> ?
05:13:51 <kuribas> lyxia: I could use unsafePerformIO
05:16:50 <lyxia> yes you could
05:17:20 <sicklorkin> what's wrong with using MonadBaseControl?
05:17:53 <sicklorkin> then you can liftBaseWith
05:19:24 <sicklorkin> There's also stToIO
05:23:53 <lyxia> MonadBaseControl is to lift through transformers, that's not what stToIO does.
05:24:19 <kuribas> sicklorkin: I don't see support for the ST monad in MonadBaseControl
05:24:46 <sicklorkin> kuribas: roll your own? :P 
05:27:16 <infinisil> kuribas: https://hackage.haskell.org/package/STMonadTrans
05:27:38 <infinisil> But this is only safe with certain monads
05:27:41 <kuribas> infinisil: it doesn't support vector
05:27:50 <kuribas> although I could use array possibly...
05:28:06 <infinisil> What do you mean it doesn't support vector?
05:28:25 <infinisil> Ah the specialized runSTArrays 
05:28:34 <kuribas> infinisil: Data.Vector
05:28:46 <kuribas> http://hackage.haskell.org/package/vector
05:29:14 <infinisil> You can still use mutable vectors inside, just make sure to freeze them inside the STT before returning it
05:29:36 <infinisil> And use runSTT
05:30:26 <kuribas> infinisil: I don't see any PrimMonad instance for STT
05:30:47 <lyxia> A serialization library is most likely going to give you some (IO ByteString), you can unsafePerformIO that and you're done.
05:31:19 <lyxia> STT or stToIO are no safer
05:31:43 <infinisil> Ah darn
05:31:48 <lyxia> uh, ioToST
05:32:13 <kuribas> lyxia: but how do I get a stack out of that?
05:32:42 <lyxia> what do you need a stack of monad transformers for
05:33:36 <lyxia> If I'm feeling snarky I would say you can put "return (unsafePerformIO _)" in any monad.
05:34:32 <infinisil> kuribas: Ah, you should be able to use https://hackage.haskell.org/package/STMonadTrans-0.4.4/docs/Control-Monad-ST-Trans-Internal.html#v:liftST
05:34:49 <infinisil> But guarantees for any of this to be safe are getting lower and lower
05:35:09 <lyxia> kuribas: also if you're using transformers, why not put IO at the base
05:35:17 <infinisil> Although the usual monads are probably safe
05:35:43 <kuribas> infinisil: ah nice, I missed that :)
05:36:39 <kuribas> lyxia: because I want to get/write a bytestring purely?
05:36:59 <kuribas> actually I may even avoid the stack by using lazyness...
05:37:22 <kuribas> I have a predictor which uses a mutable vector, but I could communicate with it using lazy lists...
05:39:42 <kuribas> but then there is more overhead, I'll stick with monadTrans
05:39:50 <kuribas> sttrans
07:24:33 <nil> is  id = \x -> x  the only possible term with most general type  forall a. a -> a  ?
07:24:45 <nil> if so, can we derive this from the free theorem?
07:24:51 <nil> @free id :: a -> a
07:24:51 <lambdabot> f . id = id . f
07:27:41 <lyxia> let f = const a,     const a . id = id . const a     (\_ -> a) = (\_ -> id a)     a = id a
07:28:45 <nil> nice, thanks
07:29:38 <nil> wait, how did you reduce  const a . id  to  (\_ -> a)  ?
07:29:44 <nil> oh, nevermind.
07:34:32 <travis_> Im relatively new to haskell (and surrounding tools).  Curious if ghci has a way of (or a plugin for) finding a concrete example of a type with a kind  like "* -> *"
07:38:44 <Noldorin> Hey. Does anyone know how the ghci backend works at a high level?
07:42:09 <shapr> Noldorin: https://mgsloan.com/posts/ghcinception/ ?
07:42:48 <shapr> travis_: I know there's hoogle and typed holes if you want to partially match concrete type signatures, but I don't know if there's anything for matching kinds
07:43:49 <travis_> shapr yah, im looking for something that you can do from ghci for a smother workflow
07:44:14 <Noldorin> shapr, that has a little info, but leaves some questions unanswered... it seems the actual REPL doesn't do codegen, but interprets some bytecode or similar, I presume?
07:44:28 <shapr> Noldorin: eh, I forget
07:44:31 <ski> @kind Maybe
07:44:34 <lambdabot> * -> *
07:44:45 <Noldorin> heh okay
08:31:44 <wroathe> So are generics or template haskell the only way to auto derive Semigroup/Monoid for data types?
08:32:21 <Ariakenom> wroathe: newtype deriving
08:34:08 <wroathe> How would that work if I've got a data type with multiple fields?
08:34:57 <Cale> It wouldn't.
08:35:08 <Cale> (but if you have a newtype, it works)
08:56:54 <vivekramaswamy> Hello All, any ideas on how to get Haskell running on a Raspberry pi 4
09:01:10 <dmj`> vivekramaswamy: you can cross compile haskell to ARM with a special GHC in nixpkgs
09:03:33 <vivekramaswamy> Thanks let me try that
09:11:56 <dmj`> vivekramaswamy:  pkgsCross.iphone64.haskell.packages.integer-simple.ghc865.callPackage
09:27:47 <gentauro> dmj`: w8 a second
09:27:55 <dmj`> gentauro: sup
09:28:18 <gentauro> `pkgsCross.iphone64.haskell.packages.integer-simple.ghc865.callPackage` can you build native binaries for an iPhone? :o
09:28:32 <gentauro> binaries = apps?
09:28:35 <gentauro> if yes, how?
09:30:11 <dmj`> gentauro: that's what I'm doing, just put one on my phone this morning
09:30:34 <gentauro> dmj`: :o
09:30:44 <gentauro> do you have a tutorial? :D
09:31:05 * dmj` reaches deep into his bag of tricks
09:33:16 <dmj`> gentauro: run this 5 line script on an OSX machine, https://gist.github.com/dmjio/a522a290d46367c8f222f2ac1ffbd358#file-build-sh
09:34:00 <dmj`> gentauro: let me know when you've done that, but it shouldn't take long with the cache. Cachix holds the precompiled deps. for darwin, linux and ARM.
09:34:33 <dmj`> gentauro: the hardest part is signing the the app, and applying for the apple developer program
09:34:45 <dmj`> for that I have some bespoke scripts
09:34:56 <gentauro> dmj`: I don't have an OSX laptop (but an iPHone) :D
09:35:58 <dmj`> gentauro: well.... then you're up a creek for building, what I could do is just push the ios binary to the cache, then you could curl it out
09:36:35 <dmj`> gentauro: you'd still need a way to put the binary on the phone though, for that there's ios-deploy, but it probably requires Darwin
09:36:51 <dmj`> gentauro: go drop $2.5k on a mac and come back
09:36:57 <dmj`> :P
09:37:07 <gentauro> dmj`: I had a MBA which I donated to kids to they could code ...
09:37:12 <gentauro> I should ask for it back :D
09:37:31 <gentauro> (laught in evil villain mode) 
09:38:18 <infinisil> @help set-topic
09:38:18 <lambdabot> Set the topic of the channel, without using all that listy stuff
09:38:47 <gentauro> dmj`: reminds of elm or is it just me? https://github.com/dmjio/miso#sample-application
09:38:49 <infinisil> I hope that has authentication, right?
09:39:30 <MarcelineVQ> infinisil: only one way to find out
09:41:09 <infinisil> @set-topic #haskell https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org
09:41:34 <infinisil> (nothing happened)
09:44:12 <gentauro> infinisil: needs more links :D
09:44:40 <infinisil> Okay maybe it didn't work because the topic is exactly the same
09:44:51 <gentauro> `Paste code/errors: https://gist.github.com/` <- shouldn't this be GitLab now that the GHC move to GL?
09:46:32 <infinisil> @set-topic #haskell If you see me in the topic, lambdabot does not have set-topic authentication
09:46:51 <infinisil> Well whatevs
09:48:53 <solonarv> gentauro: nah
09:49:16 <solonarv> GHC is on its own gitlab instance (not the public one), which you need to make a fresh account on
09:49:53 <solonarv> also (IMO, at least) gitlab's UI for snippets is significantly worse than github's gist UI
09:52:09 <dmj`> gentauro: yea, the goal is speed, simplicity, purity, testability but you still get all of Haskell's abstraction powers.
09:55:30 <dmj`> gentauro: sample app is down to 200kb closure compiled w/ advanced opts
10:03:16 <maerwald> solonarv: github is proprrietary though
10:04:27 <gentauro> solonarv: I don't have a GH account ...
10:05:40 <gentauro> dmj`: so essencially it's a swift wrapper around Haskell (FFI) that targets JS?
10:08:07 <dmj`> gentauro: yea, I'd say it's a Haskell executable that FFI's into Apple's UIKit libraries to create an objective-c application that executes both js and ARM machine code in a webview, specifically WkWebView
10:08:40 <dmj`> gentauro: but you can compile just to javascript for the web, you don't have to use the apple stuff
10:11:23 <dmj`> gentauro: you can't really use template haskell for it yet, that would require an iphone running ghc's iserv that compiles TH snippets on the fly
10:11:52 <dmj`> so I guess you can, it's just extremely inconvenient, maybe there's an iPhone emulator that can do it
10:20:18 <gentauro> dmj`: that is fair enought :)
10:20:34 <gentauro> at the moment I'm looking for a Nokia N9 (Meego)
10:20:56 <gentauro> which is a "proper" Linux, which you just can SSH into and then place the cross-compiled binaries
10:21:13 <gentauro> but there will still be some wrapping with their QT-UI/UX stuff
10:40:32 <dmj`> gentauro: that's cool
11:08:06 <portnov> https://imgprx.livejournal.net/eb8363a606e8ee3d9295207c5f93d446a6b3c338/sprZHGEQXsPIWn3eiUS9Hl7RzF6a_6KLBcr0CEAnm8xeViArJXqa7voZgtpQqTmSRt_ifn36ziaBD61kQFq1ojbJ3HjLorPUQEN7QOKpSTg
11:09:54 <bitonic> is there an existing `Generic` or `syb` based library to give you all the types transitively mentioned by a given type?
11:14:14 <rsoeldner> Is there a consensus regarding groundhog vs beam ?
11:45:41 <phadej> beam
11:47:50 <rsoeldner> phadej, ty
11:53:59 <lyxia> bitonic: I don't think so but generic-lens does something like that internally for its "types" traversal
12:17:32 <phadej> lyxia: types give a traversal to a type, doesn't give "all the types"
12:24:19 --- mode: ChanServ set -o glguy
12:25:04 --- mode: ChanServ set -o glguy[m]
12:26:22 <crestfallen> hi quick question: I have these notes on logical constructors. on line 47 is that how I would express Nothing: " Left () (True) " , at least in the context of those notes preceding? thanks     https://github.com/varreli/haskell/blob/master/logic/03.txt
12:30:26 <crestfallen> i.e. is (True) ~ a      in that line?
12:30:47 <crestfallen> that looks wrong to me
12:34:11 <ski> crestfallen : i have no idea why they wrote `(True)' on that line
12:35:10 <slack1256> What are the common complains against the singletons kind (heh) of type level programming? I've been playing with agda lastly and surely it's more ergonomic to refer to the same `f` at term level and type-level, but it makes difficult to know when types are erased
12:35:29 <ski> crestfallen : ignoring that, i'd say `Nothing ~ Left ()' and `Right a ~ a' is misleading, since they used `~' before for isomorphism, but here it clearly doesn't mean that
12:36:11 <Cale> slack1256: It's just awkward to the point that what it's buying you typically isn't worth what it's costing you. Haskell's type level is not an ergonomic place to program.
12:36:57 <ski> crestfallen : also i have no idea why they wrote `Bool = R unit T | L unit F' (in particular), it looks weird to me
12:37:39 <crestfallen> ski thanks kindly one moment
12:39:24 <ski> crestfallen : writing the sum notation as `oo Sum n = 0  a^n' looks confusing to me. i think they should either use something like the LaTeX notation, or just law it out two-dimensionally (in ascii)
12:40:16 <ski> crestfallen : oh, and in the end, they say e.g. `1 + a + 2a + 3a (...)', but surely they really meant `1 + a + a^2 + a^3 (...)' ?
12:40:26 <Cale> slack1256: Also, usually in cases where it *is* getting you something, there tends to be a way to use GADTs and end up with something much nicer. I use a lot of DMap and DSum, but avoid singletons.
12:41:53 <ski> (crestfallen : and why do they say `[singleton]' instead of `[a]' ? .. but they haven't explained the notation like `[a,a]',`[a,a,a]', what it's meant to denote)
12:42:58 <ski> crestfallen : perhaps they have the right ideas (probably they have at least some), but at least the presentation looks confused to me. which suggests that perhaps also some of the thinking may be confused
12:43:43 <ski> crestfallen : this is of course not a whole-sale criticism, they do show they have gotten some ideas (right)
12:44:36 <ski> (crestfallen : also, it's often not that simple to explain things. especially not to an audience you're not used to addressing)
12:45:15 <crestfallen> ski thanks some of that notation is my own little private sort.. including singleton [there] .. I will fix the a^2,a^3 part ... let me fix line 47 if you're still on the channel in a bit .. thanks
12:45:32 <crestfallen> oops I meant [singleton]
12:47:08 <crestfallen> ski so if I get rid of (True) on line 47 ... thats what looked wrong..
12:48:27 <ski> crestfallen : the connection between the (binary) sum type being associative, and this `Triple' type (which really ought to include the `data' keyword in its definition, since it's using the Haskell Algebraic Data Type syntax) isn't clear
12:49:21 <wroathe> Is there a way to configure how record accessors get generated in Haskell?
12:49:38 <ski> (also, sometimes `=' seems to be used for type isomorhism, sometimes `~' ? is there a reason for having two notations for what seems to be the same thing ? if they're meant to be the same, it would be less confusing to consistently use the same notation, in the document)
12:49:46 <wroathe> Like if I have a data Foo f = Foo { a :: f Int, b :: f String }
12:49:54 <wroathe> and a function that goes from a Foo Maybe -> Foo Identity
12:50:24 <wroathe> I'd prefer a and b to implicitly runIdentity, rather than having to deal with Identity in the consuming code
12:51:21 <ski> (i'm not sure why some of the type equations are commented out)
12:52:05 <ski> also, perhaps `()  +  ()' ought to be `Either () ()' ? why mix the mathy notation of `+' with the non-mathy Haskell notation of `()' ?
12:52:48 <Cale> wroathe: You can do some BS with a type family that special-cases Identity, but I don't think I can recommend it.
12:53:27 <crestfallen> ski thanks one sec you've given me a lot to consider.
12:53:35 <Cale> (It will make it more annoying to write programs which operate on general Foo f values)
12:53:51 <ski> crestfallen : btw, the `Nothing ~ Left ()' and `Right a ~ a' suggests thinking about the correspondence at the level of values, for the isomorphism in question. but then i'd rather rename `a' to `x' there, to stress that it's not a type (variable) (not being the same as the tyvar `a' just mentioned before)
12:54:34 <ski> crestfallen : unless the reader is already clear with this distinction, not using a separate name there may well continue to confuse this matter in their head
12:54:39 <wroathe> Cale: Yeah... I think I might just need to have two ADTs, one pre-validation with Maybe fields, and one post-validation
12:55:01 <wroathe> Config and ValidConfig, or something like that
12:55:07 <ski> crestfallen : similarly, i think the notation `[a,a]',`[a,a,a]' seems to suggest a similar confusion between types and values of those types
12:55:13 <crestfallen> ski which lines are you referring to here? :     the connection between the (binary) sum type being associative, and this `Triple' type (which really ought to include the `data' keyword in its definition, since it's using the Haskell Algebraic Data Type syntax) isn't clear
12:57:00 <ski> crestfallen : the only lines that mention "associative" and `Triple', close to the top
12:58:13 <ski> crestfallen : oh, and `(+)   a  ()  = a' is actually incorrect (apart from using a confusing mix of notations)
12:59:23 <ski> hm, and `data Either () a' should probably not use the `data' keyword, since it's not a `data' type definition
12:59:25 <wroathe> Cale: Actually nevermind. I'm being dumb. I just need to stop with this Semigroup Maybe stuff and that'll solve all my problems :P
12:59:52 <crestfallen> oh man ..
13:00:45 <ski> (the last derivation with `L(a)' is missing a closing bracket .. and i'm not quite sure what the `OO' at the end is supposed to mean. presumably it has something to do with infinity, but what ?)
13:01:38 <crestfallen> I was trying to emulate the math notation in vim editor. it just means infinite list I guess
13:02:26 <ski> i would probably just have written `= ...' on the next row, if they just meant to suggest that we can expand this further, along the same pattern
13:02:53 <ski> (and then perhaps follow that with `= 1 + a + a^2 + a^3 + ...' on the next row)
13:03:40 <ski> `(a, (List a) )' could be just `(a,List a)' (redundant brackets in the former)
13:04:40 <ski> crestfallen : i suppose those are most of the things that immediately strike my mine as being strange in this text
13:04:53 <ski> s/my mine/me/
13:06:00 <ski> (then, one could perhaps argue about related things that could be added, perhaps structure of the presentation, perhaps explanations or elaborations)
13:07:11 <crestfallen> ok I'm going to fix everything you've mentioned to the best of my knowledge. though I'm still sketchy on your comments re: isomorphism. 
13:07:13 <crestfallen> ski
13:07:37 <ski> do you mean re `Triple' ?
13:08:36 <ski> crestfallen : not all of the things i mentioned are necessarily bad things about the presentation. but may require further elaboration about what you intend
13:09:03 <crestfallen> well, when I wrote "up to isomorphism", I was just parroting the speaker on a video. so I don't really understand that section with Triple.
13:09:59 <ski> oh .. also, i suppose usually one'd say "commutative", rather than "symmetric", for non-relations
13:10:27 <crestfallen> I was sort of trying to get the notes down . the speaker used symmetric .. non-relations ??
13:10:38 <ski> anyway, commutativity of addition in math is usually expressed like `x + y = y + x'. and associativity like `(x + y) + z = x + (y + x)'
13:10:50 <crestfallen> copy that
13:11:06 <ski> you could talk about what the latter equation would mean, in terms of `Either'
13:11:29 <ski> then, to what extent this would be related to this `Triple' type, would perhaps be a further comment
13:11:31 <crestfallen> yes that last point I get
13:12:35 <crestfallen> second to last*
13:16:49 <ski> well, if you say, in an integral domain, that `m | n' ("`m' divides `n'") is to mean that there is some `k' such that `k * m = n'. and then further you define `m ~ n' ("`m' is associated to `n'") to mean that both `m | n' and `n | m'
13:17:27 <ski> then this `~' relation satisfies `m ~ n  <=>  n ~ m'. we would say that the relation is symmetric
13:17:42 <ski> we could also say it is commutative
13:18:23 <ski> but, as far as i have seen, people tend to (mostly ?) reserve the term "symmetric", when they talk about relations
13:19:02 <ski> (well, there's stuff like "symmetric polynomials", which would seem to violate this)
13:20:00 <crestfallen> ski well at least I am motivated to get this stuff. But in the larger picture, I understand why logical OR and logical AND are important data types, but in terms of logical reasoning, why is an infinite list important?
13:21:44 <crestfallen> like i.e. how would you use a list in implication, or a simple example?
13:22:31 <ski> crestfallen : infinite list ?
13:22:37 <Cale> crestfallen: Well, [a] is trivial as a proposition.
13:22:47 * ski didn't see any mention of infinite lists, in that document
13:22:55 <Cale> [] is a proof of it, so if all we care about is truth, it's uninteresting
13:24:57 <lyxia> phadej: I meant that to do whatever generic-lens "types" does, it has to crawl recursively through all the types that are involved in a given type, that's at least 50% of what is needed to implement what bitonic is looking for.
13:26:05 <crestfallen> yeah an infinite list like the example that the algebra for an infinite list : L(a) = 1 + a * L(a)   
13:26:13 <crestfallen> that is*
13:26:47 <ski> that type equation is satisfied by a type `L(a)' of *finite* lists of elements of type `a'
13:27:15 <ski> (it's also satisfied by a type of infinite lists. the equation has more than one solution)
13:27:23 <sicklorkin> Does anyone know of a library like `auto-update` but Lifted?
13:28:14 <ski> `L(a) = 1 + a + a^2 + a^3 + ...' doesn't mean we're talking about infinite lists. it just means every finite length is allowed
13:28:42 <ski> (so, that would be unbounded (but finite) lists, in that case)
13:28:58 <Cale> sicklorkin: can't you just apply liftIO yourself?
13:29:11 <crestfallen> huh?
13:29:50 <crestfallen> I couldn't have gotten it that wrong. That's why I was using OO there
13:30:05 <sicklorkin> Cale: humm... do you mean liftbase?
13:30:23 <ski> crestfallen : oh, so you did mean ``L(a) = 1 + a + a^2 + a^3 + ... + a^oo', then ?
13:31:11 <Cale> sicklorkin: no, just liftIO
13:31:20 <Cale> sicklorkin: What thing are you trying to lift?
13:31:26 <crestfallen> yeah I'm pretty certain the video (watched months ago) was describing the algebra of an infinite list
13:32:03 <crestfallen> so the notation is wrong it should be a^oo
13:32:49 <sicklorkin> Cale: auto-update (Reaper) has a reaperAction function that runs in IO. Inside that IO function I want to run some function that are higher on the stack, specifiy ClientF Free
13:33:18 <ski> the type of potentially finite lists (also including the infinite ones), is constructed as a coalgebraic type, not an algebraic type
13:34:05 <ski> the type of finite lists would be `mu r. 1 + a * r', while the other one i just mentioned would be `nu s. 1 + a * s'
13:34:22 <ski> (the important difference being `mu' vs. `nu'. least vs. greatest fixed point)
13:34:32 <Cale> sicklorkin: That might not be meaningful -- you'd need to reinterpret your Free ClientF into an IO action
13:34:39 <Cale> (it's just a weird data structure)
13:35:41 <sicklorkin> Cale: if Reaper ran in MonadBaseControl IO m; for exqample, i'd be fine
13:36:13 <crestfallen> ski uh oh now the fixed point aspect ...
13:36:15 <Cale> Would you?
13:36:20 <sicklorkin> Cale: does that make sense or should I get my rubber ducky out and 
13:36:44 <Cale> Free isn't an instance of MonadBaseControl IO
13:37:37 <Cale> The thing about MonadBaseControl IO is that it only ever does in a confusing way things that you can easily do by hand.
13:37:47 <ski> crestfallen : well, the mention of "infinite list" more or less automatically tailed into that :)
13:37:53 <Cale> (by running monads)
13:38:20 <Cale> and it often does almost but not quite the right thing
13:38:27 <Cale> in ways that are hard to predict
13:38:37 <sicklorkin> Cale: I'm confusing you.. 
13:39:17 <Boarders> I was testing some benchmarks and came across this behaviour: https://gist.github.com/Boarders/007002d32abf91d10ac12af8335f1fd1
13:39:29 <Cale> I pretty much always recommend against MonadBaseControl/MonadTransControl because they're an abstraction too far -- making more specific type classes for the higher order operations we want to operate across different monads tends to produce a better result and is less bug-prone.
13:39:43 <Boarders> The second function here is about four times faster than the first and I wonder if anyone who understand performance matters knows why
13:40:04 <ski> crestfallen : also, perhaps it should be stated, that when we're doing this type algebra thing, we're glossing over that Haskell is not a total language, that there are partial values (like "bottom") in the language. taking these into account the type `Maybe ()' doesn't allow for the same information to be expressed as does `Bool'. because the former has `_|_',`Nothing',`Just _|_',`Just ()' as inhabitants, while the latter only has `_|_',`False',`True'
13:40:56 <ski> however, you could perhaps check out
13:40:57 <ski> @google fast loose morally correct
13:40:58 <lambdabot> https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf
13:41:23 <Cale> So, it could be that you really want this Reaper thing to be lifted, but the right way to do that likely isn't to have it use MonadBaseControl/MonadTransControl, but rather for it to have its own type class.
13:41:40 <Cale> But it's unclear that's really necessary yet :)
13:42:01 <crestfallen> yes I vaguely follow that. as for fixed-point I understand it as generalized recursion and have an example where I evaluated something by hand.
13:42:16 <sicklorkin> not Free CLientF.. my stack is `M s = FooT (Bar Baz s)` where Bar has MOnadBase, MOnadBaseControl, MOnadUnlifeIO 
13:43:56 <Boarders> could someone remind me how I do -ddump-simpl to a file
13:44:10 <Cale> -ddump-to-file I think
13:44:36 <sicklorkin> Cale: I think my best option will be to roll my own task scheduler.
13:44:41 <crestfallen> ski something like this though I haven't looked at it in a while :   https://github.com/varreli/haskell/blob/master/handEval/fixpoint.hs
13:45:17 <sicklorkin> Cale: going back to my original query.. are there any other packages that do task scheduling that aren't restricted to IO
13:45:25 <Cale> sicklorkin: Maybe... but my first question would be "how can I remove this awful dependency on MonadUnliftIO, MonadBaseControl, etc." :D
13:46:36 <sicklorkin> Cale: Serialise, Async-pool are the main reasons for the monstrosity
13:47:01 <sicklorkin> and Stream
13:47:16 <Cale> Well, I've definitely used serialise without...
13:47:39 <sicklorkin> Cale: yes.. you're right.. i'm miss remembering..
13:48:06 <sicklorkin> Cale: i'm not sure i'm ready for that refactor quiet yet.
13:48:07 <Cale> async is exactly the kind of thing I would be extremely worried to use with MonadBaseControl
13:48:42 <sicklorkin> Cale: tests pass - i made sure to cover this very carefully
13:48:47 <Cale> Concurrency + running monad transformers automatically is a recipe for making incorrect things happen
13:49:02 <sicklorkin> mvars
13:49:10 <Cale> It's maybe possibly okay if they're all MonadReaders for things that don't involve mutable state
13:49:48 <crestfallen> tbh ski  ,  I cannot read that article. that is way over my head
13:49:50 <sicklorkin> my types protect me mostly.. forcing readers on one end, writers on the toher
13:50:12 <crestfallen> but thanks kindly for your help and patience !!
13:51:56 <solonarv> Cale: MonadUnliftIO is fine, all its instances are ReaderT-like
13:52:05 <solonarv> in fact that is a large portion of why it exists
13:52:55 <Cale> Even ReaderT-like things aren't necessarily a good idea to auto-lift through
13:53:33 <Cale> You have to think about what the operations you're lifting really mean, and what the instances are doing.
13:54:17 <d34df00d> Hi!
13:54:27 <sicklorkin> Cale: Fortunately for me i'm not performing rocker surgery, so a few hand jerks isn't the end-all.
13:54:53 <sicklorkin> but all of your points are valid
13:55:09 <d34df00d> I'm trying to write a Generic implementation for a type class that projects some value of a given type out of a data structure (think the Has pattern for MonadReader).
13:55:11 <Boarders> I am doing: cabal new-build --ghc-options="-ddump-simpl -ddump-to-file"
13:55:23 <Boarders> but this produces nothing, could someone let me know what I am doing wrong
13:55:37 <d34df00d> What'd be the right way to handle product types (:*:), going left if the LHS supports this extraction, and going right otherwise (assuming the RHS supports this extraction)?
13:56:39 <wroathe> Is there something different about performing surgery on rockers than regular surgery?
13:57:04 <sicklorkin> wroathe: one you kill the person the other you kill yourself.
13:57:04 <d34df00d> wroathe: different neck structure from all the head banging.
13:58:49 <Boarders> reposting: does anyone know why the let rather than case binding goes about 4 times faster: https://gist.github.com/Boarders/007002d32abf91d10ac12af8335f1fd1
13:58:50 <sicklorkin> wroathe: furthermore rocket surgery requires several disaplines 
14:01:10 <d34df00d> Well, in other words, how do I write an instance of some GClass (l :*: r) that requires either `l` or `r` to implement GClass (but not necessarily both at the same time), and recurses on the corresponding part of the structure depending on which one supports GClass?
14:01:18 <lyxia> d34df00d: use a type family to compute a boolean that tells you which way to go
14:01:48 <sicklorkin> Boarders: that's interesting.. can you paste the core too?
14:01:59 <Boarders> yep, just renaming it from the generated names
14:01:59 <mpickering> How do I define a fixpoint data type for a data type with two recursive positions?
14:02:04 <d34df00d> lyxia: hmm, I haven't thought about that, that's an interesting angle, let me think!
14:02:24 <mpickering> I'm sure lyxia knows..
14:02:47 <mpickering> *two types of recursive positions
14:04:15 <infinisil> mpickering: Is that even possible?
14:04:43 <mpickering> Conceptually it is? As I could have defined a mutually recursive data type to begin with
14:04:43 <lyxia> mpickering: newtype Fix (f :: (k -> *) -> k -> *) (a :: k) :: * = MkFix (f (Fix f) a)   then "two types of recursive positions" is given by an indexed type (Bool -> *)
14:05:54 <mpickering> hmm, thanks
14:06:05 <d34df00d> lyxia: hmm, what'd be the syntax for computing that bool based on just the constraint?
14:06:08 <mpickering> does that mean I have to define my mutually recursive types in one gadt?
14:06:14 <mpickering> not ideal is it
14:06:57 <lyxia> that's true, it might not be so convenient.
14:06:58 <d34df00d> I mean something like `type family ComputeDirection l r where CompureDirection (GClass l) => l r = l
14:06:59 <d34df00d> Or something
14:07:03 <d34df00d> Dunno
14:10:08 <infinisil> Is there an effects library that parametrizes effects by a symbol, such that you can have an effect row of `[ "foo" :-: State Int, "bar" :-: State Int ]`?
14:10:11 <lyxia> mpickering: a specialized construction for 2 types is to use two Fixes:     Fix1 (f :: * -> * -> *) (g :: * -> * -> *) :: * = MkFix1 (f (Fix1 f g) (Fix2 f g))     Fix2 f g = MFix2 (g (Fix1 f g) (Fix2 f g))
14:10:14 <infinisil> Aka have multiple effects with the same type?
14:10:37 <mpickering> lyxia: Thanks, that will work I think.
14:11:44 <infinisil> I think a lot of problems would be solved if we could just name effects
14:11:50 <Boarders> sicklorkin: I added the main difference in the core between the two workers: https://gist.github.com/Boarders/007002d32abf91d10ac12af8335f1fd1
14:12:10 <Boarders> btw the unboxed stuff is a red herring, GHC will produced the unboxed code even from using ordinary tuples
14:12:13 <Boarders> it is just about let vs case
14:13:46 <Nolrai> @pl (f a, f b)
14:13:46 <lambdabot> (f a, f b)
14:14:03 <Nolrai> @pl \f (a, b) -> (f a, f b)
14:14:03 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
14:14:07 <Nolrai> ...
14:14:48 <dmwit> infinisil: Not that I know of, but I'd like to see one, too.
14:14:50 <lyxia> d34df00d: how do you tell whether a field does or does not support extraction? If you want to be able to search recursively it's going to be a pain.
14:14:53 <dmwit> infinisil: In the meantime, you might like
14:14:57 <dmwit> ?hackage effect-stack
14:14:57 <lambdabot> http://hackage.haskell.org/package/effect-stack
14:15:24 <infinisil> dmwit: Just looked at that earlier
14:15:40 <infinisil> dmwit: Feels very dirty, having to know what level your desired effect is
14:15:44 <d34df00d> lyxia: I'd do this bottom-up — and then if the first field supports extraction, I'd recurse into it, otherwise I recurse into the right one (or fail).
14:16:25 <lyxia> d34df00d: what do you mean "bottom up"
14:16:27 <infinisil> dmwit: Glad I'm not the only one with this wish though
14:18:04 <d34df00d> lyxia: I can write what looks like a reasonable algorithm down with pen and paper: I have a base case where the extracted type matches the object type (and the extraction is `id`). Then I build the function for extraction recursively: K1 and M1 are obvious, and for `l :*: r` I take `l` if `l` supports extraction (which I can decide by the recursive assumption), I take `r` if `r` supports extraction (similarly), and I error otherwise.
14:18:14 <d34df00d> lyxia: this looks like a perfectly reasonable and well-founded/terminating thing.
14:18:44 <d34df00d> I actually have a few more base cases where a type "just implements" the non-generic typeclass, but that's not as interesting.
14:18:58 <dmwit> Nolrai: join (***)
14:19:40 <lyxia> d34df00d: My question is whether you only want one of the fields to be the type you want to extract, or whether you may need to look recursively inside a field. 
14:19:40 <dmwit> Actually, join bimap is probably better. Arrows are sort of out of favor these days for demanding that all Haskell functions be embeddable.
14:19:44 <dmwit> :t join bimap
14:19:47 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
14:20:32 <d34df00d> lyxia: I may need to look recursively. 
14:21:52 <d34df00d> lyxia: consider this (pseudo)code: https://bpaste.net/show/0w20 . The only problem is that instances on lines 10 and 12 overlap.
14:21:58 <d34df00d> But if there was a way to distinguish between those...
14:22:41 <d34df00d> Well... 10 and 13.
14:23:41 <d34df00d> (I hope I got your question right)
14:23:44 <dmwit> Are you the same person that was trying things like `instance FHas part l ~ True => GHas part (l :*: r)` the other day?
14:24:18 <d34df00d> dmwit: hm, nope.
14:24:23 <sicklorkin> Boarders: how large is the [a] your passing in?
14:24:24 <d34df00d> I don't have other nicks :(
14:24:35 <d34df00d> But... Great minds think alike!
14:24:37 <dmwit> Proposal: `gextract :: r p -> [part]`
14:24:52 <dmwit> `instance (GHas part l, GHas part r) => GHas part (l :*: r)`.
14:25:01 <Boarders> sicklorkin: [1..10^6] I can post the critereon output if you are interested
14:25:12 <dmwit> ...where gextract (l :*: r) = gextract l ++ gextract r
14:25:15 <lyxia> dmwit++
14:25:27 <d34df00d> dmwit: but that'd allow deriving instances of Has/GHas for types that cannot possibly have the field in question.
14:25:31 <d34df00d> Which I'd like to avoid.
14:25:36 <dmwit> Correct.
14:25:47 <sicklorkin> Well LclId may hav eosmething to do with is.. but i'm not familiary enough w/those types of optimization to be useful
14:26:05 <sicklorkin> you notice how LclId is local there in the Let version
14:26:10 <dmwit> Why would you like to avoid it?
14:26:53 <d34df00d> dmwit: because I like to have more checks at compile time rather than writing nonsense (which I do, cause my attention span is tiny) that explodes at runtime.
14:27:14 <dmwit> But there already may be many parts in your structure, and you're not planning to check that.
14:27:38 <d34df00d> Asking one field out of many makes more sense than asking one field out of none.
14:27:48 <dmwit> How about asking many fields out of many instead?
14:28:03 <d34df00d> (although it'd be nice to ensure that only one branch of the structure has the field in question)
14:28:05 <dmwit> In other words: just admit there may be many, and force your users to write code that can handle them all... including none.
14:28:35 <Boarders> does anyone know how to write something that is as fast as scanl1 (+) but which also returns the total at the end?
14:29:06 <dmwit> Boarders: Why is that hard?
14:29:25 <d34df00d> dmwit: this Has stuff is for generalizing my functions living in MonadReader, and I'm not sure it makes sense to require handling "sorry, there is no config that you're asking" in them.
14:29:33 <Boarders> dmwit: because every naive version I wrote is 3 times as slow
14:29:45 <d34df00d> I mean, I cannot think of any other reasonable handling besides throwing an `error`.
14:29:48 <Boarders> and I want to know if someone can write something actually as fast
14:29:58 <Boarders> if it is easy you are welcome to do it
14:29:59 <d34df00d> And at this point I might as well just write Python if I give up compile-time checks. 
14:30:45 <dmwit> d34df00d: I still don't agree that it's sensible to just completely ignore one of the configs if there are multiple. That seems just as prone to confusing bugs, and probably harder to debug than a crash.
14:31:37 <sicklorkin> Boarders: this patterns works very well. https://pastebin.com/1FZdpqaK
14:31:39 <d34df00d> dmwit: I totally agree this is a problem, but my ideal resolution is for GHash part (l :*: r) to fail to typecheck if both `l` and `r` have `part`.
14:31:47 <dmwit> So I don't really understand your motivation. If you're gonna demand that you can't screw up "exactly one" by having fewer, you should demand that you can't screw up "exactly one" by having more, too.
14:31:50 <d34df00d> But this seems harder that what I currently try to do.
14:32:04 <infinisil> dmwit: Oh I found a library that has named effects!
14:32:09 <mpickering> lyxia: Thanks, that worked. I just completed the first recursive heap traversal from within a Haskell program. 
14:32:10 <EvanR> theres a third option, do the confusing non-crashing ignoring, but log the abnormality
14:32:13 <d34df00d> Damn, why do I keep writing GHash instead of GHas.
14:32:24 <infinisil> dmwit: https://hackage.haskell.org/package/extensible-0.6/docs/Data-Extensible-Effect.html
14:32:30 <infinisil> Along with a blog post: https://www.schoolofhaskell.com/user/fumieval/extensible/named-extensible-effects
14:32:41 <infinisil> It seems to work, but be pretty slow and unergonomic
14:32:58 <dmwit> Extensible effects are slightly different.
14:33:17 <infinisil> They are?
14:33:28 <infinisil> Different than what exactly?
14:33:33 <EvanR> a framework for taking some default action that is probably wrong but emitting a warning log, ala Id Software's Principles of 90s Game Development, would be interesting
14:36:32 <sicklorkin> Boarders: Adding Specialize rules should also help.
14:36:34 <infinisil> dmwit: (I've been using extensible effects for a while now with polysemy, so I just assumed we talked about that)
14:36:49 <Boarders> sicklorkin: it doesn't seem to, GHC does the specialise in this case
14:36:53 <infinisil> Well, a while, it's a new library, but I've used it a lot recently
14:36:55 <EvanR> maybe a wrapper type that like Either which either gives you a normal answer, or shortcircuits with a different answer that only IO (or App monad) can unwrap, which causes a log
14:37:11 <Boarders> you can see in the Core that it has just put those Int arguments and Int primitive operations
14:38:17 <sicklorkin> Boarders: Ahhh.. right.. go has Int in the sig.
14:38:49 <Boarders> in my experience GHC is usually very good at specialising
14:40:27 <dmwit> Boarders: https://gist.github.com/dmwit/fe96f4a2ac769029e57f0019d642c34c
14:40:43 <dmwit> line 6: 0.08s, line 8: 0.14s
14:41:16 <dmwit> (Little Internet connection burp there, sorry.)
14:41:53 <sicklorkin> dmwit: what' `~` do?
14:41:56 <dmwit> Compiled both with -O2. -fllvm probably changes things because the test is too simple.
14:41:57 <Boarders> dmwit: your version has mean time of 78.11ms over [0..10^6] and scanl1 (+) has mean 10.85ms
14:42:28 <Boarders> I can write a version that takes 33.22 ms
14:42:43 <dmwit> Can I see your test setup, please?
14:42:55 <Boarders> yep let me link you to a gist of it
14:43:00 <Boarders> it is pretty bare bones
14:43:17 <dmwit> sicklorkin: It's a lazy pattern match. In this case it probably does nothing, because lets are already lazy, but it's a habit I've gotten into when writing recursive tuple calculations.
14:43:53 <dmwit> sicklorkin: It's roughly equivalent to binding a single name to the whole tuple and writing `fst` and `snd` everywhere instead of `v` and `vs`.
14:45:06 <sicklorkin> dmwit: I see. that's useful
14:45:10 <turab> dmwit: What would be it's equiv when you don't use `~`?
14:45:27 <Boarders> dmwit: this is how I am benching: https://gist.github.com/Boarders/4d96add5e7b57480a825d71cc3db82cc
14:45:39 <Boarders> I'm not saying it is ideal but I would not expect a 7x slow down
14:46:42 <lyxia> d34df00d: https://gist.github.com/Lysxia/e02e587ca1a08e5373301dc7d7f6a8be
14:47:18 <d34df00d> Yay!
14:47:26 <d34df00d> lyxia: that looks awesome! Thanks!
14:47:29 * d34df00d digs into reading.
14:47:31 <Boarders> dmwit: the version you wrote is also the backwards scan
14:48:30 <dmwit> lyxia: nice!
14:49:03 <d34df00d> So you're basically expressing just that — you search the structure without trying to define the corresponding instances at the same time.
14:49:10 <d34df00d> Beautiful!
14:49:21 <lyxia> yeah
15:00:18 <turab> What's the best way to start getting comfy with generics?
15:00:42 <turab> Currently planning on reading SYB papers, not sure where to go after that
15:01:06 <lyxia> turab: https://hackage.haskell.org/package/generics-eot
15:04:05 <turab> Thanks lyxia!
15:10:21 <sicklorkin> Boarders: have you tried writing a version that uses foldr/build?
15:10:46 <Boarders> sicklorkin: no, it's quite hard to write a right way around scan with fold
15:10:53 <Boarders> I'll benchmark doing it the wrong way around to see
15:19:05 <Boarders> sicklorkin: writing the naive fold performs horribly
15:22:29 <sicklorkin> Boarders: Is this code part of the hot path? 
15:25:13 <Boarders> sicklorkin: not really, it is mostly curiosity driven
15:26:21 <sicklorkin> i'd be interested to know if you find anything faster than scanl1.. 
15:26:48 <Boarders> I'm a bit baffled that it is not easy to write something close to as good
15:27:14 <sicklorkin> far greater minds have gazed at this for decades..
15:27:23 <Cale> Which scan are you writing?
15:27:30 <Cale> It's easy to write scanl with foldr
15:27:41 <Boarders> the one that returns both the list and the total of the list i.e. the last element
15:27:51 <Boarders> but I want the performance not to be worse
15:28:05 <Cale> Well, that I'm not as sure about
15:28:09 <Boarders> I have asked a lot of people this and they have said it is easy and then produced versions that are several orders of magnitude slower
15:28:39 <Boarders> which is just strange
15:28:45 <Cale> > foldr (\x xs s -> s : xs (x + s)) (\s -> s) [1..10] 0
15:28:48 <lambdabot>  error:
15:28:48 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ [t]
15:28:48 <lambdabot>      • In the expression: s
15:28:50 <Cale> oops
15:28:59 <Cale> > foldr (\x xs s -> s : xs (x + s)) (\s -> []) [1..10] 0
15:29:02 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
15:29:09 <Cale> > foldr (\x xs s -> s : xs (x + s)) (\s -> [s]) [1..10] 0
15:29:12 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
15:29:17 <Cale> yeah, there we go
15:29:26 <Cale> Is that the one you were trying?
15:29:30 <sicklorkin> Cale: insert a build in there.
15:29:52 <Boarders> well I want it to return ([a], a) or similar
15:30:08 <sicklorkin> Boarders: you can call last
15:30:22 <Boarders> that defeats the purpose as that will make it slower
15:30:38 <Boarders> at least naively you shouldn't have to traverse the list twice
15:30:42 <ski> Boarders : oh, you want `O(1)' access to the last ?
15:30:47 <Boarders> yeah
15:30:51 <sicklorkin> dlist
15:32:38 <nfd9001> is there a nice, idiomatic way to make something like a newtype wrapper with a type constraint? figured I'd check before reaching for a data declaration
15:33:35 <nfd9001> so if ZipList is "newtype ZipList a = ZipList { getZipList :: [a] }" followed by "instance Applicative ..."
15:35:09 <nfd9001> do I need data to do something like the pseudocode "newtype MaybeUnit a { getMU :: Monoid a => Maybe a}" or etc.
15:35:58 <monochrom> You actually need GADTs.
15:36:11 <monochrom> newtype and ordinary data do not take constraints.
15:36:30 <nfd9001> motivated by the idea that reimplementing (>>=) to use empty instead of Nothing could be a fun pattern
15:36:36 <nfd9001> awesome, thanks
15:40:05 <ski> @let runningSums :: Num a => [a] -> ([a],a); runningSums [    ] = ([],0); runningSums (x:xs) = (v0:vs,v0) where (vs,v) = runningSums xs; !v0 = x + v
15:40:07 <lambdabot>  Defined.
15:40:09 <ski> > runningSums [2,3,5,7]
15:40:13 <lambdabot>  ([17,15,12,7],17)
15:41:34 <charukiewicz> Is there any way to pipe the output of a forked process stemming from ghcid back into the ghcid output? I'm using yesod's DevelMain.update. When I run it with cabal new-repl or ghci, it logs the web requests. When I run it via ghcid, it doesn't.
15:41:43 <charukiewicz> Here's the ghcid command I'm running: ghcid --command="ghci -ilib -isrc app/DevelMain.hs" --reload="src/*" --run="DevelMain.update"
15:41:46 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f; cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
15:41:48 <lambdabot>  Defined.
15:42:02 <ski> > (graph head . scanr1 (+)) [2,3,5,7]
15:42:05 <Boarders> thanks ski! This version is still about 7 times slower on a benchmark than scanl1 (+)
15:42:05 <lambdabot>  ([17,15,12,7],17)
15:43:11 <ski> Boarders : that version is the same as dmwit's, i just made a few surface stylistic changes
15:43:17 <Boarders> I see
15:43:27 <Boarders> my version is:
15:43:30 <ski> Boarders : note that the second example says `scanr1', not `scanl1' (and `head', not `last')
15:45:11 <ski> nfd9001,monochrom : well, you can add them (for `data'), with `ExistentialQuantification'
15:45:13 <Boarders> ski: https://gist.github.com/Boarders/0647cddf82eef5fd084b107d6cc50f43
15:46:27 <monochrom> But existential quantification cannot do "data X a where Ctor :: Monoid a -> X a"
15:46:35 <dmwit> Boarders: If you are including me in "a lot of people", then please don't misrepresent what I said. I didn't say it was easy.
15:46:39 <monochrom> s/->/=>/
15:46:52 <ski> nfd9001 : if you indeed wanted to pack evidence for a constraint into the stored data, rather than *require* such evidence when extracting from the data (which your `MaybeUnit' example seemed to suggest)
15:46:58 <monochrom> err that still doesn't fix everything
15:47:10 <monochrom> data X a where Ctor :: Monoid a => a -> X a
15:47:16 <ski> monochrom : `data X a = Monoid a => Ctor (X a)' ?
15:47:33 <ski> or rather `data X a = Monoid a => Ctor a', i suppose
15:47:37 <monochrom> That one is banned by Haskell2010
15:48:20 <Boarders> dmwit: you did ask what was hard about it, but I did not mean to include you
15:48:33 <Boarders> I meant people I personally know
15:49:53 <ski> monochrom : seems to work fine here, with `Haskell2010' and `ExistentialQuantification' ?
15:50:17 <dmwit> Boarders: Yes, I asked what was hard about it, because your original question was sort of... bad.
15:50:43 <Boarders> ok thanks
15:50:45 <dmwit> Boarders: "Here's my attempt, why is it three times slower" is a much better question than "can you do it for me?".
15:51:54 <ski> dmwit : did you see the `scanr1' ?
15:52:12 <dmwit> I haven't been following along, no.
15:52:56 <ski> well, if you feel like, you may want to compare the two examples i gave
15:53:22 * ski looks at nfd9001
15:54:36 <ski> sicklorkin : hm, how would a diff. list help ?
15:55:58 <Boarders> btw ski: scanr is also much slower than scanl for this sort of thing
15:56:22 <Boarders> just scanl1 (+) vs scanr1 (+) is 16 times slower on my test
15:56:28 <ski> Boarders : my point is more that `scanr' computes something different than `scanl'
15:56:45 <Boarders> I see
15:57:19 <ski> Boarders : anyway, given a result of type `([a],a)', how are you intending to use the two components ?
15:58:00 <Boarders> I want to use the total in order to generate a random number that then indexes into that point in the list
15:58:10 <Boarders> so finds the first index that exceeds that amount for example
15:58:20 <ski> will you only look at the latter component, after either having traversed the former (perhaps in another part of the code) to the end, or else discarded the remainder after traversing some (or none) of it ?
15:58:21 <cheater> if i have a data type data FooTy = FooA | FooB | FooC and a gadt: data FooData (foo :: FooTy) { ... -> FooData 'FooA; ... -> FooData 'FooB; ... -> FooData 'FooC } and then I see data SomeFooData = forall a. SomeFooData (FooData a), why is the last data type declared? what does it do?
15:59:01 <ski> Boarders : ok, so the answer is "no", then
15:59:14 <Boarders> if I am following you then I think so yes
15:59:52 <ski> Boarders : i don't think what you want would fuse well (unless you recompute from scratch, not sharing any computation between the two parts, perhaps)
16:00:36 <Cale> cheater: As to why they're not using the more general Some FooData, I can't tell you
16:00:51 <Cale> cheater: But this effectively forgets which type of FooData you have.
16:01:13 <Cale> (a piece of information which will be recovered when pattern matching on one of the data constructors of the GADT)
16:01:15 <ski> Boarders : if you compute the last element, while keeping around the option to look at the generated list, that will probably cause that list to be fully materialized, rather than fused away (or at least getting GCed at the start, as you're traversing it)
16:01:38 <cheater> what is Some?
16:01:49 <Cale> data Some f where
16:01:57 <Cale>   Some :: f a -> Some f
16:02:02 <Cale> (more or less)
16:02:15 <Boarders> ski: interesting
16:02:25 <Boarders> btw the fastest version I have come across for this problem is:
16:02:33 <Boarders> dumb xs = let adds = scan_add xs in (sum xs, adds)
16:02:36 <cheater> ok so basically if i want to do data MyFoo = MyFoo FooData, then I couldn't, but I could do data MyFoo2 = MyFoo2 SomeFooData?
16:02:40 <Cale> It's in dependent-sum
16:02:49 <Boarders> where scan_add  = scanl1 (+)
16:02:49 <Cale> yeah
16:02:52 <ski> cheater : `SomeFooData' is `exists (foo :: FooTy). FooData foo'
16:03:04 <cheater> thanks, that explains everything
16:03:11 <cheater> ski: i don't know what "exists" does. is this new?
16:03:45 <ski> cheater : it's conceptual pseudo-code, for discussing what things like `SomeFooData' express (or encode)
16:04:09 <ski> it's what the "existential" in `ExistentialQuantification' (a misnomer, imho) stands for
16:04:27 <cheater> ok... that ad hoc syntax confused me, but ok, i understand what you mean now
16:06:13 <ski> cheater : if you want to write a function (say `frob') that will accept a `FooData foo' as input, as long as there is *some* such "tag" `foo', then that's `frob :: (exists foo. FooData foo) -> ...' .. but this is the same thing as `frob :: forall foo. (FooData foo -> ...)'
16:07:13 <ski> cheater : otoh, if you want to write a function (say `barf') that will produce a `FooData foo' as *output*, as long as there is *some* such "tag" `foo', then that's `barf :: ... -> (exists foo. FooData foo)'
16:08:35 <ski> cheater : in the case of `frob', it's the caller who will decide which `foo' to use, will pick some input of type `FooData foo', for some `foo'. and the callee itself, `frob' will have to accept inputs for any possible `foo', can't pick and choose
16:10:02 <ski> cheater : in the case of `barf', it's the *callee*, `barf' itself, who will decide which `foo' to use (possibly depending on run-time data, e.g. parameters, or perhaps I/O, if we had wrapped the `exists ...' thing in `IO'). and the *caller* will have to accept whatever `foo' was picked, can't be picky and choose for itself
16:10:44 <ski> cheater : anyway, since Haskell doesn't (at least currently) have any support for this `exists' syntax, we'll have to *encode* it, somehow
16:11:22 <ski> cheater : there's two basic ways to do that. one is the "existential data constructor" way, which in your case is to define `SomeFooData', and then say `barf :: ... -> SomeFooData'
16:11:58 <cheater> mhm
16:12:59 <ski> cheater : the other is the CPS/Church/callback encoding, which would be `withBarf :: forall o. ... -> (forall foo. FooData foo -> o) -> o' (a rank-2 operation)
16:13:45 <cheater> i don't know how the church encoding works here.
16:14:16 <cheater> i get an o out. why does o matter?
16:14:38 <ski> `(exists a. ..a..) -> ...' is logically equivalent to `forall a. (..a.. -> ...)'. does that make sense ?
16:14:51 <ski>   length :: forall a. ([a] -> Int)
16:15:14 <ski> says that, for all types `a', if you call `length' with a list of elements of type `a', you'll get an `Int' back as result
16:15:24 <ski>   length :: (exists a. [a]) -> Int
16:16:20 <cheater> yeah, i understand the exists-forall transformation
16:16:35 <ski> says that, calling `length' will result in a an output of type `Int', if you call it with an input being a list of elements of type `a', for *some* type `a'
16:16:41 <cheater> i mean, i understood it first like 10 years ago in terms of haskell, and then i forgot it :-) and now it's uploaded again
16:16:47 <ski> these express the same thing, in slightly different ways
16:17:01 <ski> ok, next is CPS
16:17:03 <cheater> what do you mean by "these"?
16:17:09 <cheater> ah
16:17:13 <cheater> the two definitions. ok.
16:17:14 <cheater> never mind.
16:17:28 <ski> (type signatures, rather than definitions. but yea)
16:17:31 <ski> @unmtl Cont o a
16:17:31 <lambdabot> (a -> o) -> o
16:18:28 <ski> the type `a' is not equivalent to the type `(a -> o) -> o' (or `Cont o a'). you can go from the former to the latter, via `return', but generally you can't go from the latter to the former (and even if you can, they may not be inverses of each other)
16:19:12 <cheater> ok, go on
16:19:26 <ski> part of the reason is that we can write a function of type `(a -> o) -> o', for some particular (`a' and) `o', that takes advantage of knowing which type `o' we are using (unlike `return', which doesn't care)
16:19:40 <ski>   return x = Cont (\k -> k x)
16:19:42 <ski> given
16:19:51 <ski>   newtype Cont o a = Cont ((a -> o) -> o)
16:20:15 <ski> @type any
16:20:16 <ski> @type all
16:20:17 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:20:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:20:31 <ski> @type cont . flip any
16:20:33 <lambdabot> Foldable t => t a -> Cont Bool a
16:20:34 <ski> @type cont . flip all
16:20:36 <lambdabot> Foldable t => t a -> Cont Bool a
16:21:07 <ski> these will call the continuation (of type `a -> Bool') multiple times, once for each element of type `a' in the input collection of type `t a'
16:21:40 <ski> and them combine the resulting `Bool'eans with `(||)' respectively `(&&)' (using `False' respectively `True', in case of empty collection)
16:21:54 <cheater> aha
16:22:18 <ski> so, these are examples of "continuation operations" which *do* take into account the particular "(final) result/answer/output" type `o' that we're using
16:22:52 <cheater> why is a the output here?
16:22:57 <cheater> i thought a would be the input.
16:23:52 <ski> values of type `a' are being passed to the continuation
16:24:20 <ski> so, when using `Cont Bool', `a' will appear as the "monadic result", of those `Cont Bool'-actions
16:24:24 <ski> @type Foreign.Marshal.Utils.with
16:24:26 <lambdabot> Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
16:24:31 <ski> @type cont . Foreign.Marshal.Utils.with
16:24:33 <lambdabot> Foreign.Storable.Storable a => a -> Cont (IO b) (GHC.Ptr.Ptr a)
16:25:06 <ski> is another example, where, while not caring about what `b' is, we do care about the `IO' part of the "final answer" type (`IO b')
16:25:37 <ski> one somewhat nicer way to wrap `with' in a CPS thingy monad is to do
16:25:44 <ski> @type ContT . Foreign.Marshal.Utils.with
16:25:46 <lambdabot> Foreign.Storable.Storable a => a -> ContT r IO (GHC.Ptr.Ptr a)
16:26:15 <ski> but anyway, all these are examples of "continuation effects", doing something nontrivial with continuations
16:26:42 <cheater> yes so why does withFoo take e.g. Cont b a and give us an a?
16:27:06 <ski> do you mean `with' above ?
16:27:30 <cheater> no, i mean this 01:12 <       ski > cheater : the other is the CPS/Church/callback encoding, which would be `withBarf :: forall o. ... -> (forall foo. FooData foo -> o) -> o' (a rank-2 operation)
16:27:57 <ski> oh, i'm working my way towards that (but haven't arrived, yet)
16:28:11 <ski> (and, fwiw, it doesn't take anything like a `Cont b a' as input)
16:28:13 <cheater> ok
16:28:16 <cheater> let's go then :)
16:28:58 <ski> now, if instead of `(a -> o) -> o' (for some particular choice of `o'), we used `forall o. (a -> o) -> o', insisting on being generic/parametric in the answer type `o', that would be a different thing
16:29:34 <ski> then, we *couldn't* depend on the particular answer type being used, because we promise to work for all possible choices of the answer type
16:30:33 <ski> (this is also because of "parametricity" : in Haskell we can't query the type at run-time. in e.g. Java, we could use `instanceof' and casts, to (at least sometimes) handle some types differently than others, despite using generics)
16:31:00 <ski> (Java doesn't enjoy "parametricity", despite having "parametric polymorphism" (aka generics). but Haskell does)
16:31:18 <travis_> hoping someone can help me out with a problem i'm running into going through the "write you a scheme in 48 hours tutorial".  relevant gist: https://gist.github.com/travisb/ca694f2ea3c131c4f0a07c8b6576d964
16:32:01 <ski> (parametricity is what tells you that `mystery :: [Int] -> [a] -> [[a]]' can't actually look at the inputs of type `a', and that all the outputs of type `a' must come from this input list (or else bottom computations, like `error'))
16:33:12 <ski> cheater : anyway, going from the (particular) type `a' (i'm not talking about `forall a. a'. `a' is whatever type we decide to pick it as, in the context) to `forall o. (a -> o) -> o', is simple. it's the `return' i showed above
16:33:27 <cheater> ski: ok, so in our earlier example with any/all, we can't expect the result type to be Bool, right?
16:33:51 <ski> cheater : but, going the other way is also simple, given an input of type `forall o. (a -> o) -> o', pick `o' to be `a', getting a `(a -> a) -> a', then pass `id' to that, getting an `a' back
16:34:19 <jackdk> just gonna point out that travis_ ' snippet has a lot of good context in it and isn't just a code dump
16:34:47 <ski> cheater : right, those examples couldn't be expressed in this `forall o. (a -> o) -> o' thing
16:35:02 <cheater> ok ski
16:35:10 <cheater> so how is that relevant to FooData?
16:35:22 <ski> cheater : now, going from `a' to `forall o. (a -> o) -> o', and back, it's not hard to show that we must get back the original input of type `a'
16:35:30 <cheater> here's my original question so it's back on the screen: if i have a data type data FooTy = FooA | FooB | FooC and a gadt: data FooData (foo :: FooTy) { ... -> FooData 'FooA; ... -> FooData 'FooB; ... -> FooData 'FooC } and then I see data SomeFooData = forall a. SomeFooData (FooData a), why is the last data type declared? what does it do?
16:35:41 <cheater> ski: ok
16:36:11 <ski> cheater : in the other direction, starting at `forall o. (a -> o) -> o', going to `a', and then back, we must argue that every value of the former type basically looks like `\k -> k (...)', where `...' (of type `a') doesn't depend on `k'
16:36:23 <jackdk> travis_: I think you don't want the >> between `parse` and `symbol`, and then the parens become redundant
16:36:29 <ski> cheater : parametricity is what allows us to make this argument. i won't go into details
16:36:54 <ski> cheater : the result of this is that a type `...' is isomorphic to `forall o. (... -> o) -> o'
16:37:03 <cheater> ok
16:37:46 <ski> cheater : it's possible to generalize this stuff a bit. getting to `Yoneda', and `Codensity' .. but let's skip that, presently
16:38:07 <ski> cheater : now, pick `...' to be our existential type `exists a. ..a..'
16:38:37 <ski> cheater : so, `exists a. ..a..' is iso to `forall o. ((exists a. ..a..) -> o) -> o'
16:39:02 <ski> cheater : but `(exists a. ..a..) -> o' is (by previous logical equivalence) iso to `forall a. (..a.. -> o)'
16:39:18 <ski> cheater : therefore, `exists a. ..a..' is iso to `forall o. (forall a. ..a.. -> o) -> o'
16:39:29 <ski> cheater : and that's your `withBarf', essentially
16:40:01 <ski> (i also used that `... -> (forall o. ..o..)' is iso to `forall o. (... -> ..o..)', but that should hopefully be pretty obvious)
16:40:24 <ski> cheater : just rename `a' to `foo', and pick `..foo..' as `FooData foo'
16:40:35 <cheater> gotcha
16:40:46 <cheater> i can follow the isomorphisms but i can't really assign meaning to them
16:41:03 <travis_> jackdk: didn't fix it, any other thoughts?
16:41:09 <ski> cheater : in some cases, the encoding via a datatype is to be preferred. in some other cases, the CPS/callback encoding is to be preferred
16:41:23 <jackdk> travis_: did on my machine. post another gist?
16:42:28 <ski> cheater : both are useful to know about (and to disabuse oneself of the notion that `data SomeFooData = forall foo. MkSomeFooData (..foo..)' somehow "is" existential quantification (which the extension name `ExistentialQuantification' might delude you into thinking))
16:43:40 <cheater> i didn't get that last part but otherwise i agree
16:43:58 <ski> cheater : a value of type `exists foo. FooData foo' (or `SomeFooData') conceptually consists of two parts : (a) a hidden/abstract/opaque/forgotten type `foo'; and (b) a value of type `FooData foo'
16:44:03 <cheater> ok, thanks a lot for explaining this to me
16:44:18 <cheater> aha
16:46:12 <ski> (but the type part is "invisible", isn't written explicitly. but conceptually, it's there. however, due to type erasure, it doesn't have any run-time cost or representation (similarly to how `length :: forall a. [a] -> Int', with type erasure, doesn't actually get passed a hidden type argument, even though it *conceptually* is passed one))
16:48:37 <travis_> jackdk: https://gist.github.com/travisb/e3ceb23d577939e099d88a6b139645c5
16:50:43 <ski> travis_ : where did `spaces' come from ?
16:51:47 <jackdk> travis_: that snippet is different. I think you want to now compose the two parsers `spaces` and `symbol`, which is where you'd use `>>` viz. `(spaces >> symbol)`
16:52:02 <ski> oh, there's a second version of `parseExpr', in which it says `parse (spaces >> symbol) "lisp" input'
16:52:30 <jackdk> which is what they do in https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Whitespace
16:52:38 <ski> travis_ : you either copied a version of `parseExpr' incorrectly, or managed to mix up two versions
16:55:59 <ski> travis_ : `>>' is (in this context), being used to sequence parsers together, combining them into larger parsers. `spaces' and `symbol' are parsers. `spaces >> symbol' is a larger, combined, parser (that first will parse according to `spaces', and, if that succeeds, will discard the parse result from `spaces' (as an intermediate value), and continue parsing with `symbol')
17:00:10 <ski> `parse' is not a parser, it's a function that, given a parser, and parse input to feed it (and a name to use for diagnostic purposes), will attempt to parse the given input with the given parser. `parse >> symbol' doesn't make sense, since `parse' is not a parser
17:06:23 <sicklorkin> Boarders: what version did you use to run those benchmarks?
17:07:54 <Boarders> sicklorkin: version of what sorry?
17:08:09 <sicklorkin> Boarders: GHC sorry.
17:08:18 <Boarders> oh, this was 8.6.5
17:08:52 <sicklorkin> Boarders: are you able to test w/other versions w/o much effort?
17:09:00 <Boarders> I should be able to yes
17:09:09 <Boarders> did you want me to try 8.8?
17:09:18 <sicklorkin> 8.4.4
17:09:30 <sicklorkin> and 8.8 sure.
17:10:02 <sicklorkin> got 7.10?
17:11:38 <Boarders> just installing 7.10
17:14:02 <Nolrai> So how does one do QuickCheck style generation and shrinking on mandatoryly infinite data structures?
17:17:12 <sicklorkin> Nolrai: Can you give me an example?
17:18:22 <ski> hm, interesting question
17:18:42 <Nolrai> Like I have a function "scan :: (b -> a -> b) -> b -> Stream a -> Stream b" where "data Stream a = a :> Stream a"
17:19:45 <Nolrai> But of course if I just use standard generators and shrinkers, both operations take infinite time..
17:21:20 <Nolrai> And I need to figure out how to show the results without showing an infinite stream as well.
17:22:49 <maralorn> What commandline argument parsing package would you recommend?
17:22:59 <Boarders> sicklorkin: it doesn't build with 8.8 but here are the numbers for the versions you mentioned:
17:23:05 <Boarders> https://gist.github.com/Boarders/206fec0fc08090c2b97902338263a9d6
17:23:15 <Boarders> looks pretty consistent to me
17:24:26 <cjh`> 2
17:30:07 <sicklorkin> Boarders: gonna see what I get on my machine
17:30:24 <Boarders> cool, I'd be interested to know
17:30:50 <sicklorkin> Boarders:  Intel(R) Core(TM) i9-7920X CPU @ 2.90GHz
17:32:44 <sicklorkin> Boarders: I'm not sure how you've got your benchmark rigged, but I'm building a single binary -O2
17:33:15 <sicklorkin> I forgot now many dependencies criterion has....
17:33:31 <Boarders> I used criterion and just ran it as main, I had options for building with optimisations set
17:47:00 <ski> Nolrai : fwiw, generating doesn't seem to be a problem
17:59:32 <Nolrai> ski: interesting.
18:07:29 <ski> there's even an `infiniteList :: Arbitrary a => Gen [a]' in `Test.QuickCheck.Arbitrary'
18:08:23 <ski> for shrinking, perhaps you'll want to try something akin to what `Test.QuickCheck.Function' does for functions (which would often contain infinite amounts of information)
18:08:27 <Nolrai> Huh, so then its the shrinking? Or my function might be too strict.
18:09:45 <ski> iow, try to devise some (finite) representation that is enough to represent the infinite lists you want to be able to generate
18:10:00 <ski> (which can then be inspected, and shrunk)
18:10:47 <ski> i don't recall in detail how the shrinking works, but i would suspect that shrinking of infinite streams/lists would be the culprit here, yes
18:14:44 <ski> (hm, obviously you can't generate all possible (denumerable many) infinite streams, from only finite information. but i suppose since any observation on them can (appeal to Brouwer's bar induction, or at least fan principle. Double-Negation Shift ?) only depend on a finite fragment (prefix) of them, it may, probabilistically speaking, be good enough to have a sensible distribution among these (lawful/algorithmic) streams (or even a subset thereof))
18:24:36 <Nolrai> ski: I mean finding violations is a search problem, so any fixed property we should be able to exaustively search, the problem is most interesting properties aren't fixed..though because the structure of Stream a doesn't change, we can try to construct a prefix that fails.
18:26:12 <ski> Nolrai : hmm .. i wonder whether any Escardian techniques could help with that
18:26:38 <Nolrai> Escardian?
18:29:36 <nfd9001> alright, popping back in from my question earlier
18:30:18 <nfd9001> haven't worked with GADTs much so i'm not sure how to massage the type system into being happy with this
18:30:32 <nfd9001> I'm starting with the GADT data UnitMaybe a where { UNothing :: Monoid a => UnitMaybe a; UJust :: Monoid a => a -> UnitMaybe a}
18:31:29 <turab> @pl \ i1 -> f i1 x y
18:31:29 <lambdabot> flip (flip f x) y
18:31:51 <nfd9001> and i'm trying to give it a Monad instance where (>>=) acts like you'd expect for UJust, then pushes the result of mempty forward instead if it gets a UNothing
18:32:16 <nfd9001> again, pseudocode: instance Monad UnitMaybe where { return = UJust; (UJust x) >>= f = f x; UNothing >>= f = f (mempty)}
18:33:06 <nfd9001> now statically I know that the GADT is sure that UnitMaybe may only be a lifted Monoid
18:33:18 <nfd9001> but i don't know how to massage the type system into believing this
18:35:12 <Nolrai> Hmm. So trying to use GADTs to make a restricted monad?
18:35:49 <nfd9001> Yeah. I could come up with some circumstances where a structure like this could be useful
18:36:22 <nfd9001> (not, like, where you absolutely need one, but i'm having fun with it)
18:37:23 <Nolrai> I mean making a Monad instance for Set is the clasic case.
18:37:27 <nfd9001> an injection from (Monoid a) => Maybe a -> MaybeUnit a is easy to write, and then you would mostly use it the same way
18:38:29 <nfd9001> the doMaybeUnit function is then pretty obvious
18:38:58 <ski> @where impossible
18:38:58 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
18:39:00 <ski> Nolrai ^
18:39:07 <nfd9001> Nolrai: ...Set, like the category set?
18:39:32 <nfd9001> or for some concrete set class
18:39:34 <Nolrai> Set like Data.Set.
18:39:38 <nfd9001> cool
18:40:22 <nfd9001> I don't immediately see the connection
18:40:53 <Nolrai> Set a requires Ord a to implement bind.
18:40:57 <ski> nfd9001 : did you see monochrom's and my responses to your question ?
18:41:14 <ski> (approx. three hours ago)
18:41:32 <nfd9001> ski: i saw the responses to "can you do this with just newtype wrappers", yes
18:41:45 <nfd9001> now i'm trying to figure out how to do it with a gadt
18:41:59 <nfd9001> ahhhh, i missed part of your answer, actually, ski
18:42:11 <nfd9001> and it's juuuust out of my scrollback buffer XD
18:44:21 <nfd9001> (they've got me covered)
18:44:38 <Nolrai> Do GADTs bring typeclass dictionaries into scope?
18:46:11 <ski> Nolrai : matching on their data constructors can do that, if they have packed evidence for such constraints
18:46:42 <ski> (but my point was that you don't need `GADTs', you just need `ExistentialQuantification', to get this)
18:46:45 <Cale> Nolrai: yes, if the constructor is constrained, the dictionary will be included alongside its other arguments, and a requirement for that constraint can be discharged by pattern matching on it
18:47:04 <nfd9001> so I did successfully construct the GADT, at the very least
18:47:14 * ski is still not sure whether nfd9001 wants to pack evidence, or require evidence, though
18:47:33 <nfd9001> do you expect it to be easier to construct a constrained typeclass instance one way or the other here?
18:48:04 <Nolrai> Oh, use ExistentialQuantification but have the type still in the Existential? 
18:48:23 <ski> "have the type still in the Existential" ?
18:49:03 <ski> <monochrom> But existential quantification cannot do "data X a where Ctor :: Monoid a -> X a"  <monochrom> s/->/=>/  <monochrom> err that still doesn't fix everything  <monochrom> data X a where Ctor :: Monoid a => a -> X a
18:49:11 <ski> <ski> monochrom : `data X a = Monoid a => Ctor (X a)' ?  <ski> or rather `data X a = Monoid a => Ctor a', i suppose
18:49:54 <Nolrai> IIRC, normally existential types look like data Example where Pack :: FooClass a => a -> Example.
18:50:00 <nfd9001> i'm not particularly sure which i'd want insofar as i'm not sure of all of the implications
18:50:08 <ski> nfd9001 : hm, if i'm reading that `Monad UnitMaybe' instance right, it looks like you want to pack evidence into the data. so `GADTs' or `ExistentialQuantification' would probably help, then
18:50:39 <nfd9001> evidence meaning evidence that 'a' actually is Monoidal?
18:51:15 <Nolrai> But in this case you'd use "data Example a where Pack :: FooClass a => a -> Example a"
18:51:18 <ski> nfd9001 : your original `newtype MaybeUnit a { getMU :: Monoid a => Maybe a}' is sortof the opposite of your later `data UnitMaybe a where { UNothing :: Monoid a => UnitMaybe a; UJust :: Monoid a => a -> UnitMaybe a}', jfyi
18:51:58 <nfd9001> yes
18:52:18 <nfd9001> once i was thinking "can I thinly wrap an existing class with an extra constraint and use that?"
18:52:49 <Nolrai> Man I just can not tell if what you want to do makes sense.
18:52:59 <nfd9001> then I thought "would it just be easier to reinvent Maybe anyway, and write the simple injection from the existing one unto this one?"
18:53:17 <ski> Nolrai : `data Example where Pack :: forall a. FooClass a => a -> Example' is the same as `data Example = forall a. FooClass a => Pack a'
18:53:48 <ski> Nolrai : `data Example a where Pack :: FooClass a => a -> Example a' is the same as `data Example a = FooClass a => Pack a'
18:54:30 <ski> Nolrai : the former, `Example', expresses `exists a. FooClass a *> a' (yes, `*>', not `=>'). the latter, `Example a', expresses `FooClass a *> a'
18:55:24 <nfd9001> Nolrai: the idea behind the structure is that Maybe propagates errors through a computation for you, stopping early if you hit a snag. You could hypothetically have cases where data bubbling through a computation after a failure are still useful, though; for Monoids, there's a sensible "restarting point" for the computation
18:55:54 <nfd9001> is it a little contrived? Yeah. But I thought it'd be a fun problem to work out
18:57:01 <Nolrai> Sorry ski, my irc is putting everything from each ` to the next ` highlighted and its making hard to read. But I think I see what you are saying.
18:58:46 <ski> nfd9001 : "do you expect it to be easier to construct a constrained typeclass instance one way or the other here?" -- i suspect that one is what you want, and the other is definitely not what you want. if you mean the `data PackBlah a = Blah a => MkPackBlah (..a..)' vs. `data ReqBlah a = MkReqBlah (Blah a => ..a..)' distinction, which can also be expressed as the `data PackBlah a where MkPackBlah :: Blah a => ..a.. -> PackBlah a' vs. `data ReqBlah a where M
18:59:04 <ski> er, let me repeat the last part, which presumably got cut off :
18:59:15 <ski> if you mean the `data PackBlah a = Blah a => MkPackBlah (..a..)' vs. `data ReqBlah a = MkReqBlah (Blah a => ..a..)' distinction, which can also be expressed as the `data PackBlah a where MkPackBlah :: Blah a => ..a.. -> PackBlah a' vs. `data ReqBlah a where MkReqBlah :: (Blah => ..a..) -> ReqBlah a' distinction
19:00:05 <ski> (`PackBlah a' expresses `Blah a *> ..a..' (yes, `*>', not `=>'), while `ReqBlah a' expresses `Blah a => ..a..')
19:00:58 <nfd9001> what's '*>'? a forall implication?
19:01:28 <nfd9001> ...i'm not even 100% on what that would practicaly mean, actually. maybe i shouldn't have phrased that question like that
19:01:44 <Axman6> :t (*>)
19:01:46 <lambdabot> Applicative f => f a -> f b -> f b
19:01:55 <Axman6> (Guessing it's not that)
19:02:03 <Nolrai> I think ski is using like its used in coq.
19:02:04 <ski> nfd9001 : otoh, the `GADTs' vs. `Existential' distinction is basically just a syntactical, stylistic matter. `data PackBlah a = Blah a => MkPackBlah (..a..)' is the same thing as `data PackBlah a where MkPackBlah :: Blah a => ..a.. -> PackBlah a'. and `data ReqBlah a = MkReqBlah (Blah a => ..a..)' is the same thing as `data ReqBlah a where MkReqBlah :: (Blah => ..a..) -> ReqBlah a'
19:02:07 <nfd9001> i was also guessing it wasn't that, because i thought we were talking type sigs
19:02:21 <Nolrai> To mean something like superclass?
19:02:23 <ski> Nolrai : i dunno how it's expressed in Coq
19:02:35 <ski> Axman6 : nope :)
19:03:11 <ski> nfd9001 : `*>' is pseudo-syntax (like `exists'), that i've introduced to be able to talk more conveniently about this conceptual point
19:05:20 <ski> nfd9001 : a value of type `forall a. ..a..' is a polymorphic value (and vice versa). for any type `T', it can be treated as having type `..T..' (specialization). conceptually, it's like a function that given a *type* `T' (not a value of type `T'), will produce a value of type `..T..'. however the passing of this conceptual type parameter is implicit in the syntax. also, in an implementation (with type erasure), it will correspond to a no-op
19:05:24 <nfd9001> ski: the "one way or the other" i meant was wrapping Maybe vs. reimplementing most of Maybe in whichever way
19:06:59 <nfd9001> the first thing I thought of when I thought "how do you usually provide other implementations of a typeclass where multiple sensible answers exist?" was to use a newtype wrapper
19:07:04 <ski> nfd9001 : a value of type `exists a. ..a..' is an "abstract value" (and vice versa). there *exists* some hidden/abstract/opaque/forgotten/skolem type `T', such that the value was constructed from a value of type `..T..'
19:07:07 <nfd9001> Like List vs. ZipList
19:07:43 <nfd9001> yeah, and when it comes down to brass tacks, we actually need that essential 'T'ness in this monad
19:08:33 <nfd9001> insofar as we need to know who to ask what mempty means
19:08:43 <ski> nfd9001 : conceptually, a value of type `exists a. ..a..' is like a pair of a type `T' (not a value of type `T'), and a value of type `..T..'. conceptually, the type part of this pairing is implicit. and a corresponding (type erasure) implementation will also have this (constructing such a value) as a no-op
19:09:39 * ski nods to nfd9001 re `newtype' and multiple sensible instances of a type class
19:10:00 <ski> nfd9001 : do these descriptions of `forall' and `exists' make sense to you ?
19:10:13 <ski> here's a silly example of `exists', btw
19:10:31 <ski>   mystery :: Bool -> exists a. (a,a -> a,a -> String)
19:10:46 <ski>   mystery False = (False,not,show)
19:11:07 <nfd9001> i believe it
19:11:21 <ski>   mystery True  = ("True",\xs -> xs ++ xs,id)
19:11:29 <nfd9001> also believe that!
19:11:49 <ski> in this case, which type `a' is selected, depends on run-time input (the `Bool')
19:12:26 <ski> in the first case, we have a triple of type `(Bool,Bool -> Bool,Bool -> Show)', which by "abstraction" also has type `exists a. (a,a -> a,a -> String)'
19:12:44 <ski> er, s/Show/String/
19:12:57 <nfd9001> and the second specializes a to [Char]
19:13:32 <ski> (it also has type `exists a. (Bool,Bool -> Bool,Bool -> Show)', and has type `exists a. (Bool,a -> Bool,a -> Show)', &c. -- we can decide how many of the `Bool's we want to "hide" behind the existentially quantified `a'. in this case, we want to hide all of them)
19:13:36 <nfd9001> there does in fact exist some a where those ensuing types make sense
19:14:46 <ski> in the second case, we have a triple of type `(String,String -> String,String -> String)', which is also (by abstraction) of type `exists a. (a,a -> a,a -> String)' (in this case we don't want to abstract the final `String', since otherwise we couldn't get out any useful information from the hidden state .. and it wouldn't match the type of the other case)
19:15:05 <nfd9001> right.
19:15:20 <ski> now, Haskell doesn't have `exists' (at least not current Haskell. perhaps there will be some kind of support in the future)
19:15:36 <ski> however, i think it's still useful to be able to reason, *conceptually*, at this level
19:16:13 <nfd9001> exists a. (...) packs little information as to what you can do with a, yeah
19:16:19 <ski> because it's easier (imho) to write down the intended types, in terms of `exists', than have to fool around with encoding (with a new `data' type, say)
19:16:27 <nfd9001> it just packs information about the shape of what you're getting back
19:17:12 <nfd9001> you could generically unpack that tuple and stuff the first parameter into the second one and see what falls out; you just don't know what you get to do with the result
19:17:15 <ski> also, because there's *two* basic ways of encoding ("existential data constructor", which is `ExistentialQuantification' (a misnomer, imho). the other way is the CPS/Church/callback encoding, which requires `Rank2Types')
19:17:31 <ski> nfd9001 : anyway, now `=>' vs. `*>'
19:18:45 <ski> nfd9001 : a value of type `Cxt => ...' is a value such that, if the consumer *provides* evidence for the constraint `Cxt', then they can use it as if it had type `...'. otoh, the producer of this value can just *assume* that they'll be handed evidence of `Cxt', when constructing a value of type `...'
19:19:46 <ski> nfd9001 : iow, a value of type `Cxt => ...' acts, conceptually, like a function from evidence of `Cxt', to a value of type `...'. however, in the syntax, the propagation of this evidence is implicit (but in the implementation, this is *not* a no-op ! hence e.g. the DMR)
19:20:32 <nfd9001> DMR?
19:21:10 <ski> nfd9001 : otoh, a value of type `Cxt *> ...' is a value that *packs* (or provides) evidence for `Cxt', together with a value of type `...'. so a consumer can just *assume* that it'll contain the evidence, while a produce will have to *provide* the evidence, together with the value of type `...'
19:21:26 <ski> Dreaded Monomorphism Restriction
19:21:27 <ski> @where DMR
19:21:27 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
19:21:32 <nfd9001> thank you
19:22:05 <nfd9001> i have some basic passing familiarity with that restriction but not quite the nuts-and-bolts
19:22:23 <ski> nfd9001 : so, a value of type `Cxt *> ...', conceptually, is like a pair of evidence for `Cxt', and a value of type `...'. however, the packing of evidence for `Cxt' would be implicit in the syntax (but not a no-op in an implementation !)
19:22:32 <ski> nfd9001 : does that make sense ?
19:23:04 <nfd9001> it feels close to making sense, at least
19:23:11 <ski> nfd9001 : `forall' typically goes together with `=>', as in `forall a. Blah a => ..a..'. while `exists' typically goes together with `*>', as in `exists a. Blah a *> ..a..'
19:23:13 <sarahzrf> it's just function vs pair :P
19:23:13 <nfd9001> how 'bout we prove me wrong
19:23:19 <nfd9001> sarahzrf: yeah
19:23:44 <sarahzrf> except that the {argument,first item} is "implicit"
19:23:55 <nfd9001> yeah
19:24:23 <nfd9001> my mental model of => may have been a little different, and maybe wrong
19:25:07 <ski> nfd9001 : now, notice that, `MkPackBlahFoo :: Blah a => Foo a -> PackBlahFoo a' is basically the same as `MkPackBlahFoo :: (Blah a *> Foo a) -> PackBlahFoo a' (you could think of this as "uncurrying", of a sort)
19:26:20 <ski> (cf. how `forall a. (..a.. -> ...)' is basically the same as `(exists a. ..a..) -> ...'. e.g. `length :: forall a. ([a] -> Int)' expresses the same possibilities as `length :: (exists a. [a]) -> Int')
19:26:47 <nfd9001> it was something like "Ctx a => ...a..." means that if the compiler looks up the concrete type of a it will be able to deduce answers to the responsibilities defined in Ctx for all such 'a's it encounters in the implementation
19:27:11 <nfd9001> (yeah, we're kinda just talking about the type system and not how it connects to implementation right now)
19:27:44 <nfd9001> Convincing all parts of the type system of that fact is a different problem than convincing all of the implementation of that fact, also
19:28:46 <ski> nfd9001 : well, at run-time, there is no such looking up, in general. in *general*, the evidence for `Ctx a' would have to be passed as a run-time input, to an implementation of such an operation. however, in many common cases, the Haskell implementation *would* be able to decide statically / at compile-time which evidence would be passed, and inline it, rather than passing at run-time
19:29:03 <nfd9001> i also assumed that those foralls operate under the constraints of the type dependencies they're given
19:30:00 <ski> (but, for polymorphic recursion (was even in Haskell 98), and for existentials (language extension), you really need this run-time passing. you can't inline/expand in this general situation (like you would with templates in C++))
19:30:01 <nfd9001> my vague mental model of how the runtime could work need not be how it actually works, so long as they have the same consequences
19:30:23 <nfd9001> all this high-level language stuff is analogy anyway; what matters is that my analogies work
19:30:47 <ski> nfd9001 : well, i'm also (a little bit) talking about how implementations would typically handle such constructs
19:31:16 <ski> it would be possible (i believe) to have an implementation which did *not* use type erasure. there you would actually pass some information representing types, at run-time
19:31:20 <nfd9001> which may well sanity-check my analogies
19:31:58 <ski> e.g. it could be used to be able to unbox values, even in polymorphic settings. so a run-time type-info for a type could be the size of values of that type
19:32:55 <ski> or, it could be a reference to some structure detailing the layout of values of that type (knowing which parts are pointers/references, e.g.), for accurate GC purposes
19:34:40 <ski> in the Melbourne Mercury Compiler, it is also used to hold generic equality checking routines (and also order comparision, for some reason. and even some more stuff related to reflection capabilities. these things, unfortunately, serve to break parametricity in Mercury)
19:34:56 * ski nods to nfd9001
19:35:23 <nfd9001> i'm totally unfamiliar with Mercury, hah
19:35:43 <nfd9001> probably ancillary
19:36:23 <hololeap> what are some interesting use-cases for IVar? it seems like it's pretty much analagous to a thunk, or am i missing something?
19:37:15 <ski> Mercury is a logic programming language (a more modern descendant of Prolog), which adds support for functional programming (also including real higher-order programming support), has a reasonable module system, a static type system (with algebraic data types, parametric polymorphism, type classes, existentials), and in particular static mode & inst (instantiation state), and static determinism, systems
19:38:36 <maerwald> is getErrno thread safe?
19:38:52 <ski> hololeap : hmm .. i think `simple-ivar' could be used to have identities to nodes in a graph (with possible sharing or even cycles), so that one can detect sharing&cycles, and probably also preserve that when "mapping/traversing"
19:39:06 <Axman6> is it ever?
19:39:18 <nfd9001> ski: i took the initiative and googled it XD
19:40:31 <hololeap> ski: can't fgl do that?
19:40:36 <maerwald> Axman6: was that to me?
19:40:49 <Axman6> yes
19:40:59 <maerwald> Well yes it is. It is well defined for OS threads
19:41:06 <maerwald> I do not know what happens with green threads
19:41:14 <maerwald> Documentation doesn't really tell me
19:42:05 <ski> hololeap : including dynamically allocating heterogenous identities (a la `IORef' and `STRef') ? i highly doubt it
19:42:21 <ski> nfd9001 : search for what ?
19:42:56 <Axman6> I feel like you'd need to use forkOn or whatever it's called so that you kinew the green thread was running on the same capability then. and even then wouldn't it depend on if another green thread had set errno between it being set by your thread, and when you get it?
19:43:05 <nfd9001> ski: Mercury, the language
19:43:11 <Axman6> @hoogle getErrno
19:43:12 <lambdabot> Foreign.C.Error getErrno :: IO Errno
19:43:12 <lambdabot> UnliftIO.Foreign getErrno :: MonadIO m => m Errno
19:43:12 <ski> ah, ok
19:43:35 <nfd9001> alright, so, the consequences of this type erasure...
19:43:36 <ski> nfd9001 : there is a channel #mercury (there's also ##prolog, if you're interested in that)
19:44:04 <nfd9001> i actually have no experience with logic programming in general
19:44:05 * ski thinks having at least a passing familiarity with basic prolog is useful, in languages with type inference, and also languages with type classes
19:44:09 <nfd9001> maybe just some of the broad strokes
19:44:47 <ski> (and, logic programming is a nice and interesting paradigm to learn about. quite similar to functional programming, in some way, but different in other ways)
19:44:58 <nfd9001> this is true. i know there's a book on logic programming behind me. (probably from the late eighties. some faculty member in the cs dept at my alma mater was getting rid of it)
19:45:14 <hololeap> ski: what do you mean by hetergeneous identities?
19:45:26 <nfd9001> i've briefly studied the consequences of linear proofs as far as they apply to the likes of Clean
19:45:49 <nfd9001> but that's damn close to the most I know about it
19:46:09 <nfd9001> my coursework was pretty strongly biased towards systems and away from languages
19:46:18 <ski> (also, constraint programming is commonly (and synergistically (sp?)) combined with logic programming, into CLP, constraint logic programming. several Prolog systems have CLP solver support in libs)
19:46:27 <nfd9001> now the big question is "will i ever stop wishing i could go back"
19:46:37 <nfd9001> heh
19:46:51 <nfd9001> i should flip through that book
19:46:55 <ski> hololeap : not all "nodes-with-identity" need to have the same type. and you can allocate new such nodes at any time, of any type you like
19:47:14 <ski> hololeap : cf. `newIORef',`newSTRef'
19:47:39 <hololeap>  i see. thanks, ski
19:47:42 <nfd9001> ah, i was wrong, it was written in '82
19:48:09 <nfd9001> mostly covers stuff in prolog, some lisp
19:48:41 <ski> nfd9001 : well, Clean (and Mercury) uses uniqueness, not linearity, to manage mutable state, and I/O. however, i believe semi-recent papers with Peyton-Jones,et al. does indicate how one could possibly be similated in terms of the other
19:48:54 <ski> nfd9001 : ooc, which book would that be ?
19:49:16 <ski> iirc, AIMA only has a little Prolog in it (more Lisp, istr)
19:49:35 <ski> @where AIMA
19:49:35 <lambdabot> "Artificial Intelligence: A Modern Approach" by Stuart Russell,Peter Norvig in 1995,2003,2009-12-11 at <http://aima.cs.berkeley.edu/>,<https://people.eecs.berkeley.edu/~russell/aima1e.html> (1st ed.)
19:50:16 <ski> nfd9001 : "could go back" to what ?
19:50:53 <nfd9001> school. Graduated in December
19:52:15 <ski> ok
19:52:20 <ski> and the book ?
19:52:30 <nfd9001> I'm familiar with how it uses uniqueness; there was some small facet of how the type system logic works as a consequence of used-once types that connected to some theory that used the word "linear" in some way
19:52:42 <nfd9001> this was, uh, over six months ago that I briefly read of this
19:53:37 <nfd9001> Logic Programming. Looks like an essay compilation of uses of the same. 0-12-175520-7
19:54:17 <ski> (i believe kmett expressed the difference between uniqueness and linearity in that with the former, you keep track of references that haven't been shared yet, in the past; while with the latter, you keep track of references that you have promised you won't share more, in the future)
19:54:21 <nfd9001> might not be the best modern intro, but it probably was a decent intro in the 1980s!
19:54:29 <ski> nfd9001 : authors ? or editors ?
19:55:14 <nfd9001> Edited by K.L Clark, S.-A.Tarnlund
19:55:40 <ski> ok
19:56:29 <nfd9001> i have a habit of taking weird old books when i see them laying out with "FREE" signs and they look non-useless
19:58:17 <nfd9001> date the first owner wrote on the cover page of that particular one is 12 years before I was born
19:58:34 <nfd9001> hahaha
19:58:50 <ski> oh, Tarnlund was a cofounder of LPA Prolog
20:00:19 <ski> i found a cute old Prolog book, at a thrift store, "Prolog vs. You", by three scandinavian ladies. i had previously seen it at a library, many years ago. i bought it immediately
20:00:37 <Nolrai> That is a very cute name.
20:01:25 <nfd9001> ^
20:01:28 <MarcelineVQ> Turns out it was actually about kids making a unique cabbage dish to defeat a monster but it was still an engaging read.
20:03:00 <nfd9001> alright, let's talk ignorant-young-programmer consequences of this type erasure
20:03:44 <nfd9001> say I define that structure I was talking about as a GADT the way I did
20:03:46 <nfd9001> that is, data UnitMaybe a where { UNothing :: Monoid a => UnitMaybe a; UJust :: Monoid a => a -> UnitMaybe a}
20:04:07 <ski> (the front cover of the swedish version is more fun than the english version. it depicts Prolog as an Ásynja (i think), in a boxing ring together with lumpy old FORTRAN, COBOL, and maybe LISP (i don't recall), looking like Æsir. some of the examples in the book is family relations, but also attributes of, areas of protection, &c., of Ásynjur and Æsir, as well as comparisions and translations to greek and roman pantheon)
20:04:34 <nfd9001> and I want to use those constraints that I know exist on the inside of the GADT to implement a typeclass instance
20:05:34 <ski> (the book also goes into quite a bit about how to reason about logic programs, proving properties, and how to derive a more efficient (or even working) implementation, from a more declarative specification)
20:06:13 <nfd9001> sounds like a good book :D
20:06:28 <ski> nfd9001 : do you ever need `mappend', and not just `mempty' ?
20:07:29 <nfd9001> I guess not; you could use any other such typeclass that insists on the presence of some empty element
20:08:00 <ski> MarcelineVQ : hm, which book would that be ?
20:08:25 <MarcelineVQ> ski: nevermind me, appearantly I'm hungry
20:08:25 <nfd9001> i would read a prolog book that involves cabbage dishes, ngl
20:08:42 <ski> nfd9001 : it also looked like you only needed the constraint on `UNothing', not on `UJust'. but perhaps there's other situations in which you'd also want to have the latter ?
20:11:46 <MarcelineVQ> Missed it if it was mentioned but just for curiosity's sake what is this type being used for?
20:12:26 <ski> hm, good question :)
20:12:35 <nfd9001> MarcelineVQ: random idea I had, basically. 
20:12:49 <ski> nfd9001 : you ought to check that the monad laws are satisfied, for your `Monad' instance
20:12:53 <nfd9001> you could use something shaped like that to resume a computation after an error
20:13:14 <ski> nfd9001 : also, perhaps you'd be interested in looking into `Validation'
20:13:28 <nfd9001> ski: yeah. when you asked "are both constraints necessary?" i thought "it sounds like it would be easier to prove monad laws with both"
20:13:43 <ski> @hackage validation
20:13:43 <lambdabot> http://hackage.haskell.org/package/validation
20:13:44 <nfd9001> but i haven't thought carefully about it, i'll admit
20:14:33 <ski> nfd9001 : nah, tbh i didn't think that much about what you were doing (iow a `Monad' instance). i was just pondering how you seemed to want to handle the constraint evidence
20:14:41 <nfd9001> that package makes way more sense than whatever I've been going on about, and I still wanna know if you can actually write the damn thing I've been going on about
20:14:53 <nfd9001> specifically the part about getting the constraint evidence in the right place, yes
20:15:53 <nfd9001> if i write the code and i then use it to prove to myself that my Monad instance is unreasonable, well, cool
20:16:07 <ski> nfd9001 : what if you used `[]' instead of `Maybe' ? would you have a use for `mappend' then, if you tried to do something similar to what you're currently doing for `Maybe' ?
20:18:18 <nfd9001> do you mean "what if you were were aggregating answers in a list, then discarding the list and starting over at an error"?
20:18:56 <nfd9001> i imagine i'd probably implement that with (>>=), which has to do with (++), which has to do with 'mappend'
20:19:13 <nfd9001> when specialized to []
20:19:39 <nfd9001> if i'm just using [] in a way isomorphic to a sum type, no
20:20:03 <nfd9001> i would just be using it as an additive zero
20:20:55 <nfd9001> what i'm imagining is a little more generic than aggregation
20:21:10 <nfd9001> but, yeah, it could totally be used in order to aggregate things
20:23:32 <nfd9001> ski: as an equivalent idea, think of the Either monad
20:24:08 <nfd9001> on the rhs of each bind, if we get Left () as an input, treat our input as some sensible "zero" value
20:24:17 <nfd9001> else use the right value
20:24:48 <Nolrai> Hmm. Thats an interesting idea..we would want to keep the Left () some how though, no?
20:26:05 <nfd9001> Maybe! If so, you probably wouldn't want to use this
20:26:49 <ski> nfd9001 : hm, just realized that your definition of `return' probably will not work, with the constraint on `UJust'
20:26:57 <nfd9001> (or break a monad law and do some logging side-effect in (>>=), or constrain the structure further to require the correct value to have something monoidal and something loggy...)
20:27:53 <nfd9001> yeah. i need to constrain 'return' also
20:27:56 <ski> <nfd9001> do you mean "what if you were were aggregating answers in a list, then discarding the list and starting over at an error"?
20:27:59 <ski> no
20:28:14 <nfd9001> which i was seriously doubting you could do
20:28:23 <nfd9001> without really massaging the type system in some funny way
20:28:28 <ski> rather combining the elements with `mappend'/`mconcat', then pass the result to the continuation
20:28:31 <ski> or somesuch
20:29:20 <nfd9001> 'Maybe' usually doesn't do much combining
20:29:54 <ski> @tell Nolrai "Hmm. Thats an interesting idea..we would want to keep the Left () some how though, no?" -- have you seen the `validation' package ?
20:29:54 <lambdabot> Consider it noted.
20:29:56 <nfd9001> Think back to that Either instance, which just takes a little more burden off the user
20:31:00 <nfd9001> that is, MaybeUnit would take some burden off the user, sorry
20:31:04 * ski wouldn't recomment breaking monad laws .. people doing refactoring (often without thinking about it) might become angry at behaviour mysteriously changing
20:31:21 <nfd9001> insofar as the default behavior is already defined by the recipient type
20:31:46 <nfd9001> (fwiw I wrote "or break a monad law..." with the intent of it being read facetiously)
20:32:39 <ski> @hackage rmonad
20:32:39 <lambdabot> http://hackage.haskell.org/package/rmonad
20:33:00 <ski> you could look into that, if you want to be able to require `Monoid', for `return' say
20:33:21 <nfd9001> i see no reason why this MaybeUnit would break the monad laws
20:33:31 <ski> (this was mentioned earlier, i think, at least indirectly referred to. someone mentioned `Data.Set.Set', which requires `Ord')
20:33:56 <nfd9001> huh, fancy
20:34:24 <nfd9001> i saw that a bunch of behavior in Data.Set required Ord, but not that its Monad had anything to do with it
20:34:38 <nfd9001> pretty much just confusedly glanced at Data.Set's docs
20:35:11 <ski> anyway, for reference, we had
20:35:18 <ski> <nfd9001> again, pseudocode: instance Monad UnitMaybe where { return = UJust; (UJust x) >>= f = f x; UNothing >>= f = f (mempty)}
20:35:22 <ski> <nfd9001> that is, data UnitMaybe a where { UNothing :: Monoid a => UnitMaybe a; UJust :: Monoid a => a -> UnitMaybe a}
20:35:42 <ski> (btw, the brackets around the `UJust x' pattern there are redundant)
20:37:10 <ski> (and the brackets around `mempty' are also redundent, perhaps more obviously)
20:37:21 <nfd9001> yes
20:37:38 <nfd9001> And, also just for reference, the semantics would be something like this
20:37:57 <ski> anyway, consider the law `ma >>= return = ma'. you have `UNothing >>= return = return mempty = UJust mempty'. so if the law is to hold, we ought to have `UJust mempty = UNothing' ?
20:38:24 <nfd9001> this is true!
20:39:01 <ski> if you make `UnitMaybe' an abstract data type, you can (effectively) make it into a factor/quotient type, where (hopefully) one can't, externally, tell the difference between `UJust mempty' and `UNothing'
20:39:18 <nfd9001> so right-identity breaks and we ought to just do this the long way
20:39:47 <ski> however, then `f mempty = UNothing >>= f = UJust mempty >>= f = f mempty' .. hm, that seems to work out fine
20:40:42 <ski> (that attempt to break stuff didn't work !)
20:41:58 <nfd9001> ok so takeaways: type erasure happens, rmonad exists and is relevant to the Big Question at hand, and we probably ought to get a little more abstract than what I was initially imagining in order to avoid creating what you could charitably call a mathematical abomination
20:42:06 <nfd9001> what a productive evening i've had :D
20:43:15 <ski> well, *may* be relevant
20:43:51 <ski> at least it appears to me that it might be in the same ballpark of what you were attempting to do (afaiui)
20:44:08 <ski> (oh, and i include `validation' there, as well)
20:44:39 <nfd9001> 'validation' does look like a more practical library in general, yeah
21:25:35 <nfd9001> http://blog.omega-prime.co.uk/2011/09/10/constraint-kinds-for-ghc/ hmm, looks like extensions to do stuff like this have existed for a while
21:25:43 <nfd9001> (not that i should use them, natch)
21:49:30 <MarcelineVQ> nfd9001: on the subejct there's QuantifiedConstraints as well
23:19:04 <remexre> what're best practices for building binary packages with cabal v2-* commands? there doesn't seem to be a cabal v2-copy, at least
23:20:40 <dminuoso> remexre: You can trivially extract a build artifact by ⌜cp $(cabal new-exec -- which your-exe) ...⌝
23:20:56 <dminuoso> remexre: There's also ⌜cabal-plan⌝ which might help you if you have something non-trivial
23:21:22 <remexre> oh, didn't realize I could run "normal" programs with v2-exec; thanks!
23:22:10 <dminuoso> remexre: It lets you execute shell commands with the build artifact directory prepended to the PATH
23:22:28 <dminuoso> (It possibly does additional environment variables, I dont really know the details too well)
