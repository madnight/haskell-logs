00:08:10 <aleator> Hi! Does anyone know how I can dig up OPTIONS_GHC-pragma values from ModSummary or HsParsedModule (or anything that ghc plugin can touch)?
01:39:28 <dminuoso> Why is maybeM not in base :S
01:40:10 <Taneb> Fairbairn threshold?
01:41:19 <merijn> dminuoso: What type would that have?
01:41:40 <dminuoso> maybeM :: Monad m => m b -> (a -> m b) -> m (Maybe a) -> m b
01:41:58 <dminuoso> Perhaps its just my problem domain where I see this popping up so frequently. 
01:43:57 <merijn> dminuoso: THat just looks like "maybe" with >>=?
01:44:27 <merijn> :t maybe (undefined :: m b) (undefined :: a -> m b)
01:44:30 <lambdabot> forall k a (m :: k -> *) (b :: k). Maybe a -> m b
01:44:39 <merijn> :t (>>= maybe (undefined :: m b) (undefined :: a -> m b))
01:44:41 <lambdabot> Monad m => m (Maybe a) -> m b
01:44:53 <dminuoso> merijn: maybeM f a = maybe f pure =<< a 
01:45:14 <dminuoso> Taneb: But I guess you have a point.
01:48:41 <ski> no `pure'
02:10:42 <dminuoso> ski: Mmm?
02:11:30 <ski> your stated signature doesn't match your definition
02:12:05 <dminuoso> ski: oh right
02:12:36 <dminuoso> % maybeM d f a = maybe d f =<< a 
02:12:36 <yahb> dminuoso: 
02:12:39 <dminuoso> % :t maybeM
02:12:39 <yahb> dminuoso: Monad m => m b -> (a -> m b) -> m (Maybe a) -> m b
02:12:46 * ski nods
02:13:08 <ski> @pointless maybeM d f a = maybe d f =<< a
02:13:08 <lambdabot> maybeM = ((=<<) .) . maybe
02:13:27 <dminuoso> ski: I alt-tabbed from emacs after I wrote `maybeM` specialized with `return` - my mind was still locked in that though I suppose.
02:13:47 * ski nods
02:52:01 <ibloom> What is the fastest way to make a Data.Vector (Linear.V4 Word8) into a Data.Vector Word8? 
02:53:15 <Taneb> ibloom: with what semantics? "const 0" fits your specification, but I don't think it's what you want
02:53:51 <ibloom> I just need to concatenate them in element order.
02:54:13 <nakkle> I'm trying to think of a Functor for which I can't reasonably define return and join / bind. Anyone got an example for that?
02:54:46 <Taneb> nakkle: Const [Int]
02:54:54 <ibloom> Dumping to a data buffer basically.
02:55:20 <Taneb> ibloom: So, Vector (V4 Word8) -> Vector Word8 ?
02:55:34 <ibloom> Yes
02:56:45 <ski> nakkle : `Coyoneda IORef'
02:57:12 <Taneb> ibloom: "Vector.concatMap (Vector.fromList . Foldable.toList)" should be pretty good
02:57:33 <nakkle> ok, gotta wrap my head around these functors first
02:58:32 <ibloom> Taneb: Do you think that will generate the intermediate lists or will the compiler remove the intermediate structure?
02:58:35 <Taneb> nakkle: one to think about: "data VoidF a" (which has no constructors)
02:59:07 <Taneb> ibloom: honestly I don't know, but it's certainly possibl
02:59:43 <ski> nakkle : my example is basically `IOReadRef', you can read, but can't write. imagine `newRWIORef :: a -> IO (IOReadRef a,IOWriteRef a)', `readIORRef :: IOReadRef a -> IO a', `writeIOWRef :: IOWriteRef a -> a -> IO ()'
03:00:06 <ski> s/RWIO/IORW/
03:00:30 <nakkle> Yeah ok, if I have a data type without constructor, I can't define return. But you could argue that an implementation of fmap is then quite esoteric 
03:02:07 <Taneb> nakkle: I'd argue it's trivial ;)
03:02:26 <ski>   data IOReadRef a = forall b. FMapReading (b -> a) (IORef b)
03:02:27 <ski>   data IOWriteRef a = forall b. OpFMapWriting (a -> b) (IORef b)
03:03:10 <ski>   fmap :: (a -> b) -> (VoidF a -> VoidF b)
03:03:13 <ski>   fmap f v = case v of {}
03:03:24 <ski> nakkle : ^ simple, right ?
03:03:29 <dminuoso> nakkle: It's not exactly about being able to "package something into a data type"
03:03:45 <dminuoso> nakkle: Remember that `return` must satisfy an identity law.
03:03:59 <ski> (two, in fact)
03:04:15 <nakkle> ah right, I totally forgot about the monad laws. 
03:04:26 <Ferdirand> is there a way to write it without EmptyCase ?
03:04:35 * ski schemes for absurd patterns
03:04:50 <Taneb> Ferdirand: "fmap f v = v `seq` fmap f v" works pretty well
03:04:57 <ski> Ferdirand : i suppose you could fake it with `seq' and `undefined' ?
03:05:25 <nakkle> ok brb, gotta work through that when I get back lol
03:06:03 <ibloom> Ok thanks. I think I should probably use a Storable instance.
03:06:05 <ski>   fmap f ‾ = ‾  -- how i might prefer to write it
03:06:27 <ski>   fmap _ ‾ = ‾  -- or even
03:06:42 <Taneb> Hmm, is VoidF on Hackage anywhere?
03:07:10 <Ferdirand> what's the purpose of seq here ?
03:07:36 <Taneb> Ferdirand: it means if you pass in a call to error, that call to error might get forced
03:07:40 <ski> Ferdirand : to expose the fake input someone passed it ?
03:07:54 <Ferdirand> ah yes
03:07:58 <Ferdirand> those pesky bottoms
03:08:26 <Lears> If you define like `newtype VoidF a = VoidF { absurd :: forall r. r }` then you can write `fmap _ = absurd`, but that requires RankNTypes instead of EmptyCase.
03:09:09 <Ferdirand> that's clever
03:09:30 <ski> > case undefined of {}
03:09:33 <lambdabot>  *Exception: Prelude.undefined
03:09:49 <ski> > case undefined of _ | False -> undefined
03:09:49 <absence> is "MVar ()" the best way to have a thread wait for another (e.g. init during startup), or are there better alternatives?
03:09:53 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
03:10:20 <dminuoso> nakkle: It's particularly interesting because there are some ways to write invalid monad instances (that is they typecheck but violate monad laws)
03:10:20 * ski . o O ( `PolymorphicComponents' )
03:12:26 <dminuoso> Another interesting example I picked up on SO is ⌜data P a = Nil | P (a, a)⌝ which is impossible to write a lawful Monad instance for.
03:12:34 <Taneb> VoidF is in some ways dual to Proxy
03:37:24 <maerwald> hsc2hs: dist/build/Basement/Terminal/Size_hsc_make: runProcess: runInteractiveProcess: exec: permission denied (Permission denied)
03:37:57 <maerwald> anyone knows what could cause this? It doesn't happen on new-install. The filesystem of the source files is read only (dist/dist-newtyle and home directory are writable)
03:38:02 <maerwald> this never happened before
03:38:38 <adziahel[m]> is it executable as well?
03:39:15 <adziahel[m]> assuming from the message it's *nix
03:39:27 <maerwald> what is executable?
03:42:00 <adziahel[m]> the filesystem `dist*` is on
03:42:24 <adziahel[m]> BTW what does  `ls -l --directory dist*` say?
03:43:06 <adziahel[m]> <adziahel[m] "BTW what does  `ls -l --director"> nevermind that though
03:44:06 <ski> adziahel[m] : perhaps you're looking for a channel like ##unix, ##linux, ##bsd ?
03:45:11 <adziahel[m]> <ski "adziahel : perhaps you're lookin"> no, why?
03:45:35 <maerwald> adziahel[m]: yeah, it could be that it is noexec indeed
03:45:52 <maerwald> (docker tmpfs is noexec by default it seems then)
03:46:14 <ski> adziahel[m] : this is a channel for discussing topics related to the Haskell programming language
03:46:27 <ski> adziahel[m] : do you have a question related to Haskell, perhaps +
03:46:36 <ski> ?
03:47:17 <maerwald> am I on skis blacklist? :)
03:47:50 <ski> er, no ?
03:48:08 <ski> is what you're talking about related to what adziahel[m] is talking about ?
03:48:11 <maerwald> ski: he is talking to me 
03:48:14 <maerwald> :D
03:48:26 <adziahel[m]> <maerwald "hsc2hs: dist/build/Basement/Term"> ski: that's the message I was replying to
03:48:36 <ski> sorry, i didn't realize. i only payed attention to what happened after adziahel[m] joined the channel
03:49:49 <ski> (i suppose this is <matrix.org> tripping up ingrained IRC habits. *grmbl* ..)
03:51:05 * ski hangs head in shame
03:57:01 <maerwald> So cabal doesn't use /tmp to build dependencies
04:17:15 <inad_smarkets922> hi
04:17:42 <inad_smarkets922> How can one tell if a given 2 argument function which can be used as operator is left or right associative
04:17:43 <inad_smarkets922> ?
04:18:19 <dminuoso> inad_smarkets922: Mmm, this is a good question actually. Look into the source code of the module defining it, and look for an infixl/infixr declaration.
04:18:32 <dminuoso> inad_smarkets922: Ah, haddock actually tells you.
04:18:52 <dminuoso> inad_smarkets922: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:-60--62-  if you look closely you will see it says ⌜infixr 6⌝
04:19:22 <dminuoso> ghci can also tell you if the identifier is in scope if you ask with ⌜:i (<>)⌝
04:19:28 <dminuoso> % :i (<>)
04:19:28 <yahb> dminuoso: class Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
04:22:25 <inad_smarkets922> dminuoso, Thank you! I'll use ghci then. That seems to be the most convenient
04:25:06 <dminuoso> inad_smarkets922: In general haddock is probably faster if you have it as a search engine in your browser. :)
04:25:13 <inad_smarkets922> Probably a stupid question but say I have op1 and op2 with infixl 1 and infixl 2. Then the operation 'a `op1` b `op2` c' is equivalent to ((a `op1` b) `op2` c) or (a `op1` (b `op2` c))?
04:26:08 <dminuoso> inad_smarkets922: ((a `op1` b) `op2` c) associates to the left
04:26:15 <inad_smarkets922> I use the  !h bang pattern for hoogle.
04:26:15 <dminuoso> And (a `op1` (b `op2` c)) associates to the right
04:26:23 <merijn> dminuoso: He asked about different fixities
04:26:37 <merijn> inad_smarkets922: It's the latter, higher fixity binds tighter
04:26:37 <dminuoso> merijn: I know.
04:26:41 <inad_smarkets922> merijn, Yep, the fixity is something that I don't understand
04:26:47 <inad_smarkets922> I mean what numbers mean there
04:26:52 <dminuoso> merijn: Oh, I misunderstood doubly then. :)
04:26:55 <merijn> inad_smarkets922: Higher number = binds more tightly
04:27:17 <inad_smarkets922> that means it's closer to the leaves in the AST?
04:27:22 <merijn> So op2 has "infixl 2" means it binds more tightly than "op1" so groups first
04:27:32 <inad_smarkets922> Ah ok
04:27:40 <merijn> inad_smarkets922: No, when grouping expressions the highest fixity is grouped first
04:27:59 <merijn> So (b `op2` c) *then* we look at op2
04:28:36 <dminuoso> inad_smarkets922: The real question is, if you have ⌜infixl 1 op1⌝ and ⌜infixr 1 op2⌝ and you have ⌜x `op1` y `op2` z⌝
04:28:44 <dminuoso> inad_smarkets922: What do you think?
04:28:50 <merijn> inad_smarkets922: Operators go from 1 to 9, function application binds with fixity 10, record syntax at fixity 11
04:29:12 <inad_smarkets922> What is record syntax?
04:29:27 <merijn> inad_smarkets922: If you haven't encountered it yet, forget about that for now :)
04:29:51 <inad_smarkets922> merijn, Ok. :)
05:08:14 <Sose> I'm trying to follow https://haskell.fpcomplete.com/library/rio . Trying to build rio with stack gives this error: https://gist.github.com/Sose/ef4c8f5da04fd5ab8f08ad51bef17fef
05:10:19 <dminuoso> Sose: What command did you use? Is that the full output?
05:10:57 <Sose> dminuoso: I added rio to build-depends in cabal file and ran `stack build` which is how I've normally installed dependencies
05:11:02 <Sose> and yes that's the full output 
05:11:26 <Sose> I also tried the haskell script that's on the fpcomplete site
05:11:43 <Sose> it uses a different resolver than what my installation defaults to, and that didn't work either if that matters
05:12:22 <dminuoso> Sose: Knowing that you are fresh beginner, why do you want to use rio at all?
05:13:07 <Sose> I'm just exploring things
05:13:26 <dminuoso> Sose: Fair enough. Can you share your cabal file?
05:14:19 <dminuoso> I find the dependency onto ⌜rio-0.1.0.0⌝ quite curious.
05:14:29 <Sose> ooh
05:14:56 <Sose> I did a dumb thing, I named my own project "rio" :D
05:15:03 <Sose> changed it to something else and it works
05:15:04 <Sose> thanks
05:15:06 <dminuoso> :)
05:39:00 <irdonhairz> Hi, when using Control.Monad.Parrallel,  more specifically mapM_ from the module, what happens if I do not specify any ghc flags for the numbers of threads/ cores to be used? Will it automatically use as much parallelism as possible, or just treat it as a Prelude.mapM_
05:41:04 <dminuoso> irdonhairz: The library appears to be just a thin wrapper around Control.Parallel using par/pseq a bit.
05:41:13 <dminuoso> irdonhairz: I invite you to take a look at the source code.
05:43:08 <dminuoso> (Well at least the mapM_ side of it, is)
05:44:00 <Ariakenom> you do need -threaded to get parallelism. then it defaults to the same nr of OS-threads as HW-threads I'd think
05:46:11 <dminuoso> @where PCPH -- irdonhairz 
05:46:12 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
05:46:12 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
05:46:31 <dminuoso> This book goes into much better detail about how Control.Parallel works, how to use it, etc..
05:48:17 <Ariakenom> dminuoso: half of those links are broken
05:48:20 <irdonhairz> Thank you both for the replies, i have omitted from my project the use of -threaded flag. I am got the 2013 version of Parrallel and Concurrent Programming in Haskell - Simon Marlow
05:48:34 <dminuoso> Ariakenom: the archive.org link should not be.
05:48:43 <dminuoso> irdonhairz: Ah perfect then. :)
05:48:50 <Ariakenom> archive and this one works https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/
05:49:10 <Ariakenom> great book
05:54:52 <Ariakenom> there should be some way to change those though
05:55:53 <irdonhairz> yes I agree about the book, I have tried to cut some corners, as I am not the only contributor of the project, and when I have raised the parallelism question with the lead developer, he just poiinted to the scotty web framework. As far as Simon Marlow's book, it is suggested to start a thread for each client connection. I can't seem to figure out 
05:55:54 <irdonhairz> if the scotty webserver does that. I am inclined to guess that it does not (due to the fact that I cannot see it mentioned in their docs, nor that we have considered using appropriate compiler flags)
05:56:32 <Rembane> irdonhairz: The scotty webserver does that, so you can do all kinds of blocking stuff for each connection and it won't effect other connections. 
05:56:39 <Rembane> *affect
05:56:43 <dminuoso> Rembane: Wouldn't that be a warp feature though?
05:56:51 <dminuoso> Rembane: I mean scotty just sets up a WAI application
05:57:20 <Rembane> dminuoso: Yeah, so that works with any other web server implementing WAI.
05:57:25 <Rembane> ...too.
05:57:35 <dminuoso> irdonhairz: ^-
05:58:48 <Rembane> But I have only seen this when using Scotty, which is why I wrote as I did. 
05:59:01 <dminuoso> irdonhairz: https://github.com/scotty-web/scotty/blob/master/Web/Scotty/Trans.hs#L80
05:59:15 <dminuoso> irdonhairz: Here you can see it just uses the warp server, so dig there. :)
05:59:35 <irdonhairz> Understood, thank you!
06:00:36 <dminuoso> irdonhairz: https://hackage.haskell.org/package/warp-3.3.0/docs/Network-Wai-Handler-Warp-Internal.html#v:settingsFork
06:00:41 <dminuoso> There you go. :)
06:01:51 <dminuoso> irdonhairz: Since scotty accepts different warp settings that are passed down, you get direct control over this - everything is kept at default though unless explicitly overwritten.
06:12:21 <thosgood[m]> what do exclamation marks mean in record structures? do they just automatically give you getters?
06:14:45 <dminuoso> thosgood[m]: They are strictness annotations.
06:15:13 <dminuoso> thosgood[m]: Without strictness annotation, a thunk if forced is only evaluated into WHNF, which essentially means "just until the outermost constructor shell"
06:15:24 <thosgood[m]> <dminuoso "Tim: They are strictness annotat"> what does this mean?
06:16:14 <Ariakenom> irdonhairz left but I will clarify that you need -threaded for parallelism but not concurrency
06:16:58 <dminuoso> thosgood[m]: With a strictness annotation, you can tie additional internal fields into that, such that when a value of that data type is evaluates, not only is the expression up until the data types data constructor evaluated, but some fields as well.
06:16:58 <dminuoso> Imagine you have:
06:16:58 <dminuoso> data Foo = Foo { bar :: Int; quux :: String }
06:17:31 <dminuoso> And you construct some ⌜x = Foo { bar = someExpensiveCalculation; quux = "foo"}⌝ and at some point you force the evaluation of x, then neither the field `bar` nor the field `quux` will actually be evaluated.
06:18:05 <dminuoso> If however you had constructed that with ⌜data Foo = Foo { bar :: !Int; quux :: String }⌝ and you forced `x`, then the field `bar` would be evaluated (so it sort of lets you weaken lazyness in some fields)
06:18:37 <dminuoso> Such that evaluation can go "a bit further than WHNF/outermost data constructor"
06:24:03 <dminuoso> thosgood[m]: Equivalently one may specify strictness annotations in function arguments using some extension, which gets you "evaluate the argument before entering the function" semantics. So these bangs as we call them give you fine grained control over where you want strictness and where you want lazyness.
06:40:11 <thosgood[m]> dminuoso: that makes sense, thanks :-)
06:50:59 <inad_smarkets922> Do I understand that right that the record syntax is tainting the namespace around it in the sense that it automatically define accessor functions for the fields in the given datatype
06:51:00 <inad_smarkets922> ?
06:51:27 <dminuoso> inad_smarkets922: Indeed.
06:51:39 <merijn> inad_smarkets922: Sadly, yes
06:51:52 <merijn> There's a proposal to (optionally) allow record syntax without accessors, though
06:53:57 <inad_smarkets922> I think scoped accessors would be better. Say I have "data Person = Person {blah :: String}" then I would get a Person.blah accessor for the blah field.
06:54:07 <ski> field names ought to be in a separate namespace, imho
06:54:16 <dminuoso> inad_smarkets922: In fact, that's sort of the custom
06:54:32 <merijn> inad_smarkets922: The problem is that that conflicts with (.) and module qualification
06:54:48 <ski> like `#blah myPerson' in SML, (or even `myPerson .blah' in O'Caml)
06:55:09 <dminuoso> inad_smarkets922: When you have some ⌜data User = User { usAge :: Int, usFirstName :: Text, usLastName :: Text ..⌝ so we kind of do this out of convention to avoid possible clashes.
06:55:34 <dminuoso> (Not that this is a real solution, but it's what haskell users currently do)
06:55:35 <inad_smarkets922> dminuoso, But how do you put this in a namespace?
06:55:55 <dminuoso> inad_smarkets922: By just using sensible prefixes
06:56:10 <ski> (putting it in a different module ?)
06:56:13 <dminuoso> Or that.
06:56:26 <inad_smarkets922> dminuoso, Ah, like the Hungarian notation?
06:56:31 <ggole> Record access as functions doesn't really play nice with records as arguments to sum types, either
06:56:47 <dminuoso> inad_smarkets922: Sort of, yes.
06:57:18 <dminuoso> My best guess is, the primary focus on Haskell was elegance around functions... so records were a bit looked over?
06:57:19 <inad_smarkets922> dminuoso, That's bad. I like the idea of a separate module better.
06:57:26 <ski> ggole : you mean the strange mix we've got in using record syntax in algebraic data types ?
06:57:28 <dminuoso> inad_smarkets922: You can use a separate module just fine.
06:57:35 <merijn> inad_smarkets922: Essentially, all the (proposed) solutions have their own warts and problems and the problem isn't painful enough to do something majorly backward incompatible
06:57:42 <dminuoso> inad_smarkets922: It's just not always convenient for some reasons.
06:57:53 <ski> nested modules ought to be a thing
06:57:55 <merijn> ggole: Yes, hence why I can't wait for the "record syntax without accessors" proposal
06:58:10 <ggole> It's not really the syntax that's the problem
06:58:11 <inad_smarkets922> merijn, What's the drawback of adding data definitions in a separate module?
06:58:15 <dminuoso> ski: It was actually discussed during last munihac around the GHC developers.
06:58:22 <inad_smarkets922> And then like do a qualified import
06:58:24 <ski> dminuoso : which ?
06:58:36 <dminuoso> ski: It was during dinner, so no recording exist.
06:58:39 <merijn> inad_smarkets922: extra imports can be annoying :)
06:58:47 <ski> dminuoso : yes, but which topic ?
06:58:49 <inad_smarkets922> merijn, Haha. I can live with that.
06:59:05 <dminuoso> ski: oh, nested modules.
06:59:09 <ski> ah. ok
06:59:11 <merijn> inad_smarkets922: But yes, that's one work around. The other is prefixing as dminuoso proposed
06:59:39 <ski> (that wasn't what i was suspecting, so ..)
07:00:29 <dminuoso> inad_smarkets922: And if you are not careful, splitting too much into modules can create headaches when circular imports arise.
07:00:58 <dminuoso> Which is another big painful part of Haskell.
07:01:23 <dminuoso> Since we have, borderline, no real support to deal with circular imports.
07:01:34 <merijn> dminuoso: Correction: Painful part of GHC
07:01:42 <merijn> dminuoso: Haskell deals with circular imports just fine
07:02:01 <dminuoso> merijn: Apologies. I sometimes conflate the two.
07:02:07 <dminuoso> merijn: Yeah I'm aware.
07:03:17 <ski> anyway, i think it's silly that with `data User = MkUser { usAge :: Int,... }', we get not `usAge :: Int' but `usAge :: User -> Int'. this is causing problems with `NamedFieldPuns',&c. .. imho, confusing newbies and non-newbies alike
07:04:20 <dminuoso> ski: How would you use such ⌜usAge⌝?
07:05:21 <ski> (e.g. `myUser { usAge = succ (usAge myUser) }' or `myUser { usLastName = usLastName myOtherUser }' makes no sense to me)
07:06:07 <ski> dminuoso : `usAge' should be the field name, not the field accessor function
07:06:09 <dminuoso> ski: Ah so you propose something like ⌜myUser { usAge = succ usAge }⌝ ?
07:06:10 <maralorn> I was really intrigued by how https://github.com/willtim/Expresso used rowtypes for a really nice module system structure.
07:06:54 <ski> `foo (MkUser {usAge = usAge,...}) = ..usAge..' should be fine, and should not shadow one from referring to the field `usAge', or its field accessor function, in the body
07:08:15 <ski> dminuoso : well, then `usAge' would have to be a variable in scope (presumably bound to the `usAge' field of `myUser'). if it isn't, then something along the lines of `myUser { usAge = succ (#usAge myUser) }' or `myUser { usAge = succ (myUser .usAge) }' should still be possible
07:09:19 <maralorn> I love the concept of having first class dictionaries in which you can but functions, types and values. A bit like in nix or javascript (besides the types) BUT only in way that every access can and will be checked for existence at compiletime.
07:09:20 <ski> (i'm not saying that the concrete syntax `#usAge' or `.usAge' should be used. i'm saying that we need *some* syntactical distinction between a field, and its corresponding field accessor function (or operator, if you wish))
07:10:07 <merijn> ski: OverloadedFields or whatever that extension is called, no?
07:10:18 <nshepperd1> Record update should support lens style modification. myUser { usAge %= (+1) }
07:11:00 <ski> lens is an interesting direction to go. but it would go a long way if basic record syntax was more sane
07:11:25 <ski> i'm not sure i want overloaded fields
07:12:36 <ski> maralorn : well, functions are values :) .. but i suppose you're thinking of (some aspects of) dependent types (or maybe first-class modules ?) if you want types in there as well ?
07:12:40 <nshepperd1> The majority of record updates i do are record { someField = f (someField record) }. How repetitive!
07:13:02 <ski> yep
07:14:15 <ski> what if we want to update multiple fields of a record, each value update depending on multiple of the fields of the record (possibly overlapping with the updated fields) ?
07:15:23 <ski> what if we want to do this for nested records, or "parallel" records, with dependencies of new values on old going across record boundaries ?
07:16:00 <ski> (and we don't want to sequence the updates, we want them to be collateral, all "happen at the same time")
07:16:23 <nshepperd1> That sounds a bit too complicated to add new syntax for
07:17:05 <nshepperd1> RecordWildcards though probably
07:17:11 <ski> possibly .. but these are the sort of things i'd like to see thought about, in a more advanced record proposal
07:17:12 <Lears> With NamedFieldPuns and the occasional fix, imo the current syntax is actually pretty good for that.
07:17:34 <Lears> It's the simpler cases that are unnecessarily clumsy.
07:18:07 <ski> but basic things like not simultaneously claiming `usAge :: Int' and `usAge :: User -> Int' seems like obvious low-hanging fruit (or rather clean-up)
07:18:35 <merijn> Lears: NamedFieldPuns + current syntax - accessors would be good for me
07:19:18 <Rembane> Is there a way to turn off accessors?
07:19:41 <merijn> Rembane: Not yet, proposal in progress
07:19:41 <ski> (i only brought the more advanced stuff up, because the discussion veered into changes/extensions to record syntax, and because, afaik, lens doesn't really provide a convenient and helpful solution to the more advanced stuff i was talking about (please correct me if i'm wrong, there))
07:19:57 <Rembane> merijn: Sweet! 
07:20:00 <dmwit> maralorn: What does it mean to put a type in a record? Do existentials get you where you want to go?
07:20:22 <ski> Lears : "It's the simpler cases that are unnecessarily clumsy." -- agreed
07:21:13 * ski . o O ( translucent modules )
07:21:13 <merijn> Rembane: https://github.com/ghc-proposals/ghc-proposals/pull/160
07:22:15 <Rembane> merijn: Thank you! 
07:38:07 <maralorn> ski: dmwit: I mean using records as a replacement for the module system. Or making them one and the same thing. Like having a record Control.Monad which contains the typeclass Monad and the function >>=.
07:39:40 <maralorn> Ah, know I read it. Yep, first class modules is the thing.
07:40:35 <maralorn> I think thats conceptually much easier and it also should bring qualified import as a default.^^
07:44:08 <maralorn> But I think the basic requirement is a field access syntax. So that the Typechecker can do thinks like: f x :: { HasField "name" r String, HasField "age" r Int } => r -> a.
07:47:14 <maralorn> I mean that is actually valid GHC Haskell. But the Compiler will not derive this type.
07:54:24 <ski> maralorn : hm, a believe Cayenne did that ("records = modules")
07:55:26 <ski> (Cayenne was a dependently typed language which allowed general recursion anywhere. in some regards, it was similar to Agda)
07:56:37 * jumper
07:56:50 * ski
07:57:28 <Taneb> skijumper?
07:59:45 <ski> maralorn : there has also been experiments with "lacks" rather than "has" field predicates on record types (or rows). e.g. TRex in Hugs <https://www.haskell.org/hugs/pages/hugsman/exts.html#trex>,<https://www.haskell.org/hugs/pages/users_guide/hugs-only.html#TREX>
08:05:58 <infinisil> ski: That sounds like a bad idea
08:06:05 <ggole> 1ML also does the records = modules thing
08:08:06 <ski> infinisil : elaborate ?
08:12:17 <infinisil> ski: Changing behavior depending on what *doesn't* exist. It almost feels like checking for null values. Goes more towards the dynamic nature
08:12:22 <infinisil> I didn't take a look at your links though
08:12:27 <fragamus> howdy I heard there is some talk of deprecating src exts and using the ghc ast instead... is there any info about that
08:12:28 <infinisil> So just a feeling
08:15:04 <infinisil> Also, when you go from a record that has "foo" and "bar", this is also a record that has "foo", this way always makes sense. But when you have a record that has "foo" and "bar" it doesn't lack "bar", whereas one with just "foo" *does* lack "bar"
08:16:04 <infinisil> It's just kinda weird
08:16:24 <infinisil> But then again, proof of non-existence exist in mathematics too
08:19:47 <c_wraith> fragamus, it's the direction everyone wants to head, but there is still ongoing work.
08:20:27 <fragamus> c_wraith: is the reason that src exts lags behind ghc changes
08:21:41 <c_wraith> that's part of it. there's also the duplication of work, and all the potential issues with things going out of sync in other ways
08:25:19 <fragamus> Is the schema roughly the same 
08:26:26 <fragamus> for manipulating haskell source it would need to be similar
08:26:29 <ski> infinisil : with TRex, `\(x = x0,y = y1) -> sqrt (x0 ^ 2 + y0 ^ 2)' would have type `Floating a => Rec (x :: a,y :: a) -> a', while `\p -> sqrt (#x p ^ 2 + #y p ^2)' would have type `(Floating a,r \ x,r \ y) => Rec (x :: a,y :: a | r) -> a' (allowing a record with additional fields to be passed as input)
08:27:35 <ski> infinisil : from a type POV, the `r \ x' constraint serves to ensure that there isn't already a field named `x', among the remaining fields. in terms of implementation, the evidence for `r \ x' could carry the offset at which to access the `x' field in the record
08:28:21 <c_wraith> fragamus, iirc, it's moving to a Trees That Grow representation... if they can make it compile fast enough.
08:28:51 <isovector1> i have a data type parameterized with a type variable, whose records are type families over that tyvar. stock deriving doesn't work --- it requires standalone deriving for concrete instantiations of the tyvar. wondering if there's a way to convince GHC to standalone derive the cartesian product of constraints and tyavrs. eg: https://github.com/JonathanLorimer/weft/blob/c0aa5a823b5d82ef779e6d7e5ce76f39
08:28:52 <isovector1> a0f5f824/src/TestData.hs#L14-L41
08:28:55 <isovector1> https://github.com/JonathanLorimer/weft/blob/c0aa5a823b5d82ef779e6d7e5ce76f39a0f5f824/src/TestData.hs#L14-L41
08:29:36 <infinisil> ski: Wait what does  `\p -> sqrt (#x p ^ 2 + #y p ^2)' do? It takes a record, then returns the sqrt of the sum of the squares of the fields x and y from p?
08:30:06 <ski> (btw, fwiw, `\(x = x0,y = y1 | r) -> sqrt (x0 ^ 2 + y0 ^ 2)' would also have type `(Floating a,r \ x,r \ y) => Rec (x :: a,y :: a | r) -> a')
08:30:27 <ski> infinisil : yep, same as the other example really
08:30:46 <ski> (er, s/y1/y0/ .. sorry)
08:30:52 <infinisil> ski: So the x and y get "used up"?
08:31:06 <ski> i'm not sure what you mean
08:31:46 <wroathe> So from what little I understood of the Applicative and Monad papers I boiled it down to "sequencing effects", and "sequencing effects which choice of what to do next" in my head, but this paper starts by contradicting that by saying that the motivation for using Applicative notation in their example is to allow for parallelization: https://simonmar.github.io/bib/papers/applicativedo.pdf
08:31:50 <infinisil> ski: So this function only takes a record and uses x and y of it to return a number. Where does the type `r \ x` come in play?
08:31:55 <fragamus> c_wraith: where can I learn about trees that grow representation
08:31:59 <ski> `Rec (x :: a,y :: a | r)' is the type of a record that has at least fields `x' (of type `a') and `y' (of type `a'), remaining fields-with-types being described by the "row" variable `r'
08:32:00 <wroathe> So it sounds like my understanding was way off
08:32:20 <infinisil> ski: Oh, I think I get it
08:32:59 <c_wraith> fragamus, that's the name of the paper.
08:33:05 <ski> infinisil : `r \ x' is a constraint, not a (concrete) type. evidence for it consists in the offset for `x', iirc
08:33:47 <wroathe> Basically, I was under the impression that with (λfx fy → length (intersect fx fy)) <$> friendsOf x <*> friendsOf y, the two friendsOf actions would be sequenced by <*>
08:34:04 <c_wraith> fragamus, https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf
08:34:25 <ski> wroathe : i'd say that both monads and idioms are about sequencing (dynamic sequencing, vs. static sequencing, more specifically). but that doesn't mean that for a *particular* monad, or idiom, the sequencing must be of any import
08:34:26 <infinisil> ski: So the function really says "I take an x, y and maybe more fields none of which can be x or y, and return a number (or an 'a')?
08:34:34 <ski> infinisil : yep
08:35:20 <infinisil> ski: Ah, and the r \ x constraint is infered from the definition?
08:35:21 <ski> wroathe : they are sequenced. but what "sequencing" means depends on the particular monad or idiom (in this casE) being used
08:35:53 <wroathe> are you using "idiom" in a general sense or some specific technical sense?
08:36:12 <c_wraith> it's the old term for Applicative
08:36:20 <ski> wroathe : consider `x * y * z'. where `*' is any binary associative operator, and `x',`y',`z' are some values. in `x * y * z', i'd say these three values are "sequenced" or "ordered"
08:37:24 <ski> wroathe : however, whether this sequencing/ordering *matters* depends on what kind of things we're talking about. if we're talking about multiplication of real numbers (or say complex numbers), then the order/sequencing doesn't matter, because multiplication (of reals or complex numbers) is commutative
08:37:55 <ski> wroathe : but if we're talking about quaternions, or matrices, then the order *does* matter
08:38:33 <ski> wroathe : the idea of a monoid *allows* order to matter, but doesn't require it. there are both commutative and non-commutative monoids
08:39:15 <c_wraith> fragamus, see also https://gitlab.haskell.org/ghc/ghc/wikis/implementing-trees-that-grow
08:39:20 <wroathe> Oh, you know what, now that I think about it more it makes sense to think about Monads as being explicitly sequenced because of that choice aspect I mentioned earlier. We can't determine what to do next until we have the output of the previous computation.
08:39:27 <ski> wroathe : i'd argue that (the abstract idea of) monoids expresses a kind of sequencing, or order, even those that may not matter in particular instances
08:39:27 <wroathe> But Applicatives would have no such requirement
08:40:10 <c_wraith> some Monad instances don't have any data dependency. well. Proxy, at least.
08:40:28 <lortabac> isovector1: is your link correct? I cannot open it
08:40:32 <c_wraith> ... that's probably the only one.
08:40:35 <ski> wroathe : similarly. monads (and also idioms) *allow* sequencing to matter, but doesn't require it. the abstract idea of monads (and also idioms) "expresses sequencing" ("by omission", so to speak, because we've not included any "commutativity axioms" among the laws)
08:41:10 <ski> wroathe : yea. i'm using "idiom" interchangably here with "applicative functor"
08:41:12 <isovector1> lortabac: i think github just went down
08:42:07 <ski> infinisil : yes, the `r \ x' constraint is inferred (by either using a field extractor function `#x', or matching on a record pattern which explicitly mentions the field `x')
08:42:19 <wroathe> ski: so you're saying that because we haven't said Monads must/must not be commuative they give us the option of either choice
08:42:33 <wroathe> ski: What would be an example them of a Monad for which sequencing doesn't matter?
08:42:44 <wroathe> Other than Proxy, which I'm just learning exists
08:42:57 <wroathe> Of our standard Haskell Monads
08:43:14 <wroathe> an example then*
08:43:29 <ski> wroathe : "Monads [..] being explicitly sequenced because of that choice aspect I mentioned earlier. We can't determine what to do next until we have the output of the previous computation.","But Applicatives would have no such requirement" -- this is the "static vs. dynamic" distinction of sequencing i mentioned
08:44:20 <ski> wroathe : "What would be an example them of a Monad for which sequencing doesn't matter?" -- `Identity',`Reader r'
08:44:39 <infinisil> ski: Sounds pretty neat then yeah
08:44:52 <wroathe> Oh, duh, Identity
08:45:17 <ski> infinisil : i'm not saying "lacks" is the best way to go about this. i'm just pointing out it's a serious alternative that people have thought about
08:45:40 <infinisil> Well I'm still not sure why that's really useful, but I bet it can be
08:45:47 <infinisil> And I'm also not sure what alternative you mean
08:45:56 <ski> wroathe : also `Writer m', if `m' is a commutative monoid ..
08:46:30 <ski> @where applicative-vs-monadic
08:46:30 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
08:46:42 <ski> wroathe : if you haven't yet, you might be interested in checking out ^
08:46:57 <wroathe> But wait, couldn't you still make the argument that: pure 5 >>= \x -> pure (x^2) we're still introducing a dependency and an order here?
08:47:15 <wroathe> For Identity Int
08:47:25 <wroathe> Thanks, I'll check it out
08:47:58 <ski> wroathe : there's still a data dependency, sure
08:48:15 <ski> but the sequencing we're talking about, re monads and idioms, are sequencing of *effects*
08:48:41 <wroathe> Ah, so you've got to be careful to mentally distinguish the two
08:48:46 <wroathe> Got it. Thank you!
08:49:09 <ski> (also note that "sequencing" might not look like sequencing, in operation terms. "sequencing", for the list monad, will look more like "loop nesting", if you look at operational details)
08:51:01 <ski> (`Identity' has no (non-trivial) effects, so there's nothing really to sequence. `Reader r' has effects, but they commute with each other always, so this is like the "multiplication of reals is commutative" case)
08:52:12 <ski> (one can also talk about whether effects are discardable, and whether they're copyable/duplicable, in addition to whether they commute with each other)
08:52:42 <wroathe> ski: Is there a paper or book you read to acquire this knowledge you can point me to?
08:52:52 <wroathe> ski: About this deeper theory behind effects
08:52:53 <ski> (a "central" effect would be one which commutes with every expressible effect (in the monad or idiom))
08:53:52 <ski> re this "static vs. dynamic sequencing", it's something which i've realized more and more, after discussion on this channel (and reading stuff like ndm's article above) .. and of course attempting to reflect on the matter
08:55:16 <ski> some people did claim that monads were not about sequencing at all .. and i suppose i did go along with, or entertain, that viewpoint a bit. but as i've been attempting to reflect more on it, it does seem to me that there really is something to talking in terms of "sequencing" here
08:56:31 <ski> (i don't claim i'm done thinking about this. one could probably formulate things more cogently, to the relevant points, perhaps emphasizing things a bit differently, or even introduce new aspects into the conception. this is a work-in-progress)
08:57:08 <ggole> You could say that it's composition that is about (or induces) sequencing, and monads are just an instance of that.
08:57:29 <ski> i suppose, but what do you have in mind with "composition", in that case ?
08:57:41 <ski> function composition as in `f . g', or a more general conception ?
08:58:04 <ggole> I did have f . g (tellingly, often pronounced "f after g") in mind
08:58:27 <ski> (in Haskell, perhaps it ought to be pronounced "`f' before `g'" ;)
08:59:30 <ski> anyway, function composition is the basis for abstraction in category theory. a category can be seen as a generalization of a monoid (i mentioned both monoids and monads before)
08:59:42 <ski> so, yes, there's at least that connection there
09:03:29 <phadej> rather, monoid is a special kind of category
09:08:38 <wroathe> What got me down this road was just thinking about the implications behind applicative style used in things like optparse-applicative. This notation Config <$> option ... <*> option ... <*> option ... is just crazy elegant
09:12:45 <Cale> wroathe: Also, Reader e is unconditionally commutative, and Writer w when w is a commutative monoid.
09:13:11 <Cale> "Commutativity" means something weird here
09:13:31 <isovector1> can i tell derivingvia to use the stock deriving machinery? without having the underlying instance there?
09:18:12 <Cale> isovector1: I don't believe so. (took me a while to figure out what your question meant)
09:18:45 <Cale> isovector1: What you could do is to define another newtype which has the underlying instance you're going to use.
09:20:24 <Cale> (and use ordinary deriving to derive its instances)
09:21:37 <isovector1> Cale: alas, i'm trying to give stock derived instances of `f a` for `newtype Foo f a = Foo (f a)`, and then use derivingvia to give an an instance of `f a` in temrs of `Foo f a`....
09:22:02 <isovector1> Cale: the roundabout meaning I can put generic `GWhatever` constraints on `Foo` to guide the stock deriving, and have that never show up user-facing code
09:23:39 <isovector1> (i am deeeep in type families)
09:25:23 <ski> phadej : that's another way to put it, yea :)
09:26:48 <ski> wroathe : yea .. except .. i tend to think something like my "reflective syntax" mumblings would be even neater, at least for larger cases
09:26:54 <phadej> ski: I have to agree that starting to seeing "categories" in everything takes time, yet IMHO if something to be seen, it's better to see categories (than e.g. monoids)
09:26:59 <ski> (or even just idiom brackets)
09:27:09 <Cale> wroathe: Oh right, I was going to say, in the case of a monad, "commutative" means that for any x, y, f, we have (do u <- x; v <- y; f u v) = (do v <- y; u <- x; f u v)
09:29:53 <ski> phadej : hm, istr reading that it can be quite useful to generalize from monoid actions to "category actions"
09:31:15 <unyu> ski: What do categories act on?
09:32:21 <ski> wroathe : another way of expressing what Cale just said is `liftA2 . flip = flip . liftA2'
09:32:54 <Cale> unyu: Other categories
09:32:59 <Cale> (by way of a functor)
09:33:49 <Cale> It's really just another way of thinking about particular functors.
09:34:30 <ski> yes
09:34:34 <Cale> A group action is a functor from the one-object category representing the group to the category of sets.
09:35:38 * Lycurgus thought they operating on the objects in question
09:35:43 <unyu> Ah, okay, so basically, an action “gives a semantics” to the thing that acts, right?
09:35:44 <Lycurgus> *operated
09:35:52 <Cale> yeah, basically
09:36:06 <Lycurgus> like rings and shit
09:36:44 <Cale> Lycurgus: We can of course generalise both the domain and codomain of that functor...
09:37:02 <Cale> You can have a group acting on a ring such that each group element corresponds to a ring homomorphism
09:37:22 <Lycurgus> also wrt seeing cats everyplace, seeing things is the cray cray, innit?
09:37:58 <unyu> A group action is a group homomorphism G -> Aut(X) such that G x X -> X a “good map” (e.g., smooth, if G is a Lie group). A category action should be a functor C -> [D,D] such that C x D -> D is a “good bifunctor” in some sense?
09:38:49 <ski> (copyable/duplicable is `liftA . join = join . liftA2', while discardable is `liftA . const = const . pure')
09:41:50 <Cale> unyu: There's a notion of "actegory" which is pretty much what you just invented there.
09:43:00 <Cale> (In which C is required to be a monoidal category)
09:43:02 <Cale> https://ncatlab.org/nlab/show/actegory
09:52:08 <isovector1> is there some way to get ghc to dump what constraints are in scope with `-ddump-deriv`?
10:34:01 <maralorn> Is there anywhere some resource about stupid code transformations between a (b (c d))  or  a $ b $ c $ d  or  a . b . c $ d  or  d & (a . b . c)  or   d & (c >>> b >>> a). I feel like I shouldn‘t care. But I can‘t decide what to settle for and waist far to much time with doing pointless refactoring.
10:37:24 <stilgart> > :t (&)
10:37:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:38:42 <stilgart> :t (&)
10:38:45 <lambdabot> a -> (a -> b) -> b
10:39:38 <stilgart> (okay, it's from Data.Function)
10:40:00 <sicklorkin> null (Nothing) <&> always exists..
10:40:09 <sicklorkin> whoops..
10:40:12 <sicklorkin> <&>
10:43:04 <inad_smarkets922> What does (..) means in import statements?
10:43:44 <alx741> inad_smarkets922: import the constructors of a datatype
10:44:30 <inad_smarkets922> alx741, Thank you!
10:53:40 <hyperisco> maralorn, use which feels easiest. That can vary by instance.
10:54:06 <hyperisco> I think the problem is adherence to just one style, actually, rather than using each where it is strong.
11:18:19 <Noughtmare[m]> Is there a way to give a thread priority when doing `forkIO`?
11:18:44 <Noughtmare[m]> With priority I mean that it will not be interruped by lower priority forks.
11:20:23 <Noughtmare[m]> I have one thread that takes a long time. And many little threads that are quick. So I don't want the long thread to be interruped.
11:21:40 <koala_man> you want strictly priority based scheduling?
11:22:45 <EvanR> i hate being the guy who just wants a coffee, along with 9 other people, behind the one chick who is ordering a double espresso grande moche cherry frappe
11:23:27 <Noughtmare[m]> koala_man: I don't really know what you mean by that.
11:24:15 <EvanR> if you can't interrupt a long lived thread then, on 1 cpu, nothing happens
11:24:17 <__monty__> EvanR: The only way to win is not to play the game.
11:24:43 <MarcelineVQ> Or play it better. Use the drive-through to get priority.
11:25:07 <__monty__> MarcelineVQ: No, that's strictly worse. Then you're waiting in line *and* ruining the planet.
11:25:09 <MarcelineVQ> Added bonus being that you don't know what the person ahead is ordering so you can't get upset by it.
11:25:12 <Noughtmare[m]> Oh, I have 4 cores available.
11:25:27 <__monty__> In this case though, I meant only start the threads after the long task is finished.
11:25:44 <MarcelineVQ> No one's ever not ruining the planet __monty__
11:25:47 <koala_man> caffeine pills are $0.07 per starbucks-cup-equivalent with no lines
11:25:58 <__monty__> MarcelineVQ: It's a question of degrees.
11:26:11 <EvanR> lock long lived thread to one of the cpus?
11:26:55 <Noughtmare[m]> EvanR: How? using `forkOn`?
11:28:33 <EvanR> looks right
11:29:15 <Noughtmare[m]> Does that stop other threads from being run on that cpu?
11:30:06 <EvanR> no
11:31:30 <Noughtmare[m]> Does it discourage the scheduler to run other threads on that cpu?
11:31:45 <Noughtmare[m]> Otherwise I don't see how that helps me.
11:33:13 <Noughtmare[m]> I tested it and it does seem to help.
11:34:40 <EvanR> if the long lived thread is on that capability, and you have free ones, it stands to reason your "just a coffee please" threads will use the free ones. Unless the policy is really confused
11:34:50 <Noughtmare[m]> Oh, wait. It doesn't really help.
11:35:14 <EvanR> but whether that matters to the whoel application no idea
11:35:48 * Noughtmare[m] uploaded an image: image.png (20KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/pzXEZIVOvkEcjVRNYbtenCvh >
11:35:49 <__monty__> The scheduler will do its best to balance the load but if there's a ton of shortlived threads some'll still end up on the same CPU.
11:35:54 <Noughtmare[m]> Here's the threadscope view.
11:36:32 <EvanR> is 9 supposed to be the long lived thread
11:36:34 <Noughtmare[m]> The 9 is the long thread.
11:36:39 <EvanR> it doesn't seem that long
11:36:46 <Noughtmare[m]> Notice how some 18's are in the same capability
11:37:09 <EvanR> oh multiple 9s is just interruptions
11:37:24 <Noughtmare[m]> Yeah, I think so.
11:40:58 <nnnz> hello, i want the following: `ConduitT i Int m () -> n -> IO a -> ConduitT i a m ()` where i want to do the IO action concurrently with max n workers
11:41:07 <nnnz> any async/conduit experts here?
11:41:43 <nnnz> IO a should be (Int -> IO a) 
11:43:21 <nnnz> currently i am chunking the conduit and using runConcurrently with a applicative for but then i have to wait for all of them before i start producing values
11:58:40 <dmwit> Perhaps your async jobs could decrement a TVar, and your forker could wait for the TVar to be possitive to make an async call.
11:59:29 <dmwit> (So that you can read one thing at a time off the conduit, but still only have n jobs in flight at once.)
13:15:07 <maralorn> hyperisco: So you say I shouldn‘t try to use a consistent style?
13:17:50 <hyperisco> In a sense, yes, that is what I am saying. If you had a style which did not use function composition, it would be unnatural to eta expand a definition just for the sake of avoiding function composition.
13:18:39 <hyperisco> Similarly, if you had a style which always used function composition, it would be unnatural in many cases to rearrange the definition so it can be eta reduced
13:19:29 <hyperisco> So, if function composition is easy, use that, and if it isn't, do not. If using parentheses is easy, use that, and if it isn't, use $
13:20:03 <monochrom> Micromanaged consistency vs holistic consistency.
13:21:20 <EvanR> lisp is the logical conclusion of consistency
13:21:24 <EvanR> therefore consistency is bad
13:21:40 <monochrom> Everyone can consistently complete and include their TPS Report Cover Sheets, and that still doesn't mean the company as a whole is consistent.
13:21:40 <EvanR> qed
13:21:46 <monochrom> haha
13:23:18 <maralorn> Do you have any opinion on the readflow? In monadic composition the controlflow goes from left to right in function composition it goes from right to left. That‘s why I made the d & (c >>> b >>> a) suggestion.
13:23:54 <EvanR> yeesh
13:24:20 <EvanR> when the variables are single letters like this... what does that gain over (a <<< b <<< c) d
13:24:39 <EvanR> also if you move the final application to another binding, you dont need parens
13:24:47 <EvanR> which help sput longer names on separate lines
13:25:03 <EvanR> or longer subterms
13:25:18 <hyperisco> "in monadic composition the controlflow goes left to right" I am not sure in what sense you mean that
13:25:31 <EvanR> ^ wasn't going to go there, can of worms
13:25:36 <monochrom> :)
13:25:42 <maralorn> EvanR: I didn‘t want my message to get long so I used short names in my example.
13:25:42 <hyperisco> whoops
13:25:48 <Cale> I'd usually write either  a . b . c $ d  or  a . b $ c d
13:26:05 <Cale> In do notation, the arrows are <- 
13:26:25 <Cale> and so if you're going to use one of >>= or =<< it's the latter which is more likely to read nicely
13:26:39 <Cale> Usually I try to avoid both
13:26:45 <maralorn> I mean with do notation as well as with >>= or >> composition "values go" from top left to bottomright more or less.
13:26:50 <Cale> Occasionally, >>= is nice alongside \case
13:27:14 <maralorn> Cale: You‘d recommend to always use do?
13:27:16 <Cale> yes
13:27:22 <Cale> Pretty much always use do
13:28:03 <maralorn> Has the disadvantage to be less pointfree though.^^
13:28:14 <Cale> Sure, but that can also be an advantage
13:28:28 <maralorn> Probably is.
13:28:32 <Cale> You have the opportunity to name the things you're talking about, which can help explain the code to the reader if done well.
13:44:26 <tabaqui> oh, hey, Prelude on base-4.12.0.0 doesn't export sconcat from Semigroup
13:44:53 <tabaqui> while it does similar method for Monoid
13:44:59 <tabaqui> not very consistent, as I think
13:48:09 <hyperisco> Alternatively to forgetting, maybe the export of mconcat was regrettable
13:49:32 <hyperisco> Alternative to that, people fight to keep Prelude simple, and so perhaps adding sconcat was not deemed essential
13:49:43 <tabaqui> it has (<$) but not ($>)
13:50:11 <tabaqui> concat (which isn't much usefull, imo) and mconcat but not sconcat
13:50:34 <hyperisco> Alternative to that, some people use unqualified wildcard imports, and so adding definitions to Prelude can be breaking.
13:50:53 <hyperisco> Particularly, Prelude tends to get that treatment.
13:52:23 <hyperisco> I've just accepted a life of abundant and verbose imports.
13:53:25 <hyperisco> Rather than hoping to golf imports with preludes and other definition bags.
13:53:52 <hyperisco> (Also helps if you don't have to manage the imports yourself)
14:07:31 <dmj`> partitionEithers is underrated
14:39:13 <hexagoxel> try to generalize it to arbitrary sums though, and you fall into a hole of TypeFamilies
14:41:02 <hexagoxel> partitionSum :: forall ts . (a -> HSum ts) -> [a] -> HProd (HMap [] ts)
14:41:21 <wroathe_> Anyone know of a function like try/catch/handle that doesn't pass the exception to the handler?
14:41:37 <wroathe_> I just want to know that an exception occurred, I don't care what type it is
14:41:48 <glguy> wroathe_: You have to know what type it is to know if you should catch it
14:42:18 <glguy> If you want to catch all exceptions then you need to specify a type they can all be which is SomeException
14:43:08 <wroathe_> :t try
14:43:11 <lambdabot> Exception e => IO a -> IO (Either e a)
14:43:17 <wroathe_> :t catch
14:43:20 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
14:43:31 <wroathe_> :t onException
14:43:33 <lambdabot> IO a -> IO b -> IO a
14:43:47 <wroathe_> what I'm looking for is something like onException that doesn't propagate the exception
14:43:57 <glguy> there isn't that
14:45:02 <wroathe_> hrm :(, thanks
14:45:24 <Iceland_jack> What about something like
14:45:25 <Iceland_jack>   popcorn :: forall expt a. Exception expt => IO a -> IO a -> IO a
14:45:25 <Iceland_jack>   popcorn as bs = catch @expt as (const bs)
14:45:41 <Iceland_jack> You must use it with visible -XTypeApplications
14:57:20 <EvanR> if the exception doesn't propagate doesn't that mean you need to come up with a default answer
15:00:33 <wroathe_> Well, the situation is that I'm using the postgresql-simple query_ function to check database connectivity at the startup of my application
15:00:44 <wroathe_> and if query_ fails it throws an exception
15:01:08 <wroathe_> So if it throws an exception I want to just log a warning, otherwise I want to log a message with the result of the query
15:05:36 <c_wraith> how is try not appropriate
15:05:37 <c_wraith> ?
15:07:20 <EvanR> try :: IO a -> IO (Either SomeException a)
15:07:42 <EvanR> will let you do anything basically
15:10:53 <mwelt> hi! Is there an easy uptodate lib for drawing random samples from lists / Arrays?
15:11:56 <EvanR> as to "easy", you could write a 2 line function for that
15:12:57 <sofiama> How does extensible-effects compare to polysemy?
15:12:57 <mwelt> then I would be interested in these two lines :)
15:14:17 <mwelt> random drawing w/o replacement.
15:15:26 <monochrom> I wouldn't believe that query_ really throws "very arbitrary" exceptions.
15:15:53 <monochrom> If anything it's most likely IOException.
15:16:42 <EvanR> mwelt, using IO for the random number or an explicit generator, or what
15:17:42 <mwelt> EvanR: IO would be sufficient
15:19:18 <wroathe_> Sorry, looked away from this for a bit
15:20:01 <wroathe_> I understand how for type safety requiring me to specify the type of exception is great, but in this case I really don't care what the type is
15:20:08 <wroathe_> I'll post code, one sec
15:20:42 <wroathe_> https://gist.github.com/JustinChristensen/30efce0064a02248a18d1bc643c3b87b
15:21:15 <wroathe_> Line 7 offends my senses
15:21:16 <EvanR> well, i am having a bit of trouble accessing a paste site
15:22:04 <EvanR> (i.e. the proof to fermats last theorem)
15:22:54 <monochrom> Sorry why does github require me to sign in to see that gist?
15:23:20 <EvanR> mwelt: example https://gist.github.com/evanrinehart/576aa1f90199273b618e0c167d567e12
15:23:22 <monochrom> OK accessible now.
15:23:37 <wroathe_> https://gist.github.com/JustinChristensen/30efce0064a02248a18d1bc643c3b87b
15:23:39 <wroathe_> Try again
15:23:45 <mwelt> EvanR: thanks I'll take a look 
15:24:24 <mwelt> /media/HD2/welt/pubmed_data2/pubmed19n0823.xml.gz
15:24:25 <monochrom> I would turn on ScopedTypeVariables and put the SomeException type in the Left pattern: Left (_ :: SomeException) -> ...
15:25:01 <wroathe_> Yeah, but this seems like I shouldn't even have to say it's going to be a SomeException
15:25:21 <wroathe_> That's implied by the fact that I'm not handling it in any meaningful way
15:25:33 <EvanR> if theres no information about e, it's ambiguous
15:25:57 <EvanR> the type system doesn't know SomeException is the top of some dynamically typed hierarchy
15:26:14 <EvanR> unlike the defaulting to Integer thing in the Num class
15:26:23 <mwelt> EvanR: would you be so kind to paste the gist link again, my irssi was having trouble with display glitches
15:26:35 <EvanR> https://gist.github.com/evanrinehart/576aa1f90199273b618e0c167d567e12
15:26:39 <monochrom> You are spoiled by the fact that if you write "0" there is a defaulting mechanism plus a monomorphism restriction mechanism such that you do not have to say "it's Integer".
15:27:03 <wroathe_> True, and I'll keep on being spoiled :D
15:27:09 <wroathe_> Kidding of course
15:27:30 <EvanR> if you make a helper function for this, you can put SomeException in the signature and sort that out
15:28:06 <monochrom> But the exception system is in the same boat as maxBound, read, and show.  Even if you don't care, the compiler needs your help to resolve "which instance do you want?"
15:28:16 <EvanR> on the subject of SQL query throwing some specific exceptions... i am skeptical that is easy to define which
15:28:38 <monochrom> In particular "print []" demonstrates the exact same problem.
15:28:42 <EvanR> i found a list somewhere of the 10 or so kinds of exception anything network related may throw
15:29:25 <monochrom> Although there are no elements to print, therefore you may deduce "so it doesn't matter which Show instance", the compiler still needs it.
15:29:42 <mwelt> EvanR: thanks a lot
15:30:15 <monochrom> EvanR: But it's possible they're all using the IOException type.
15:30:18 <wroathe_> monochrom: This is true, but if there was no mention of an exception in a try-like function I wouldn't have to declare the type at all
15:30:26 <wroathe_> Which is why I was looking for an onException that didn't propagate
15:30:29 <wroathe_> :t onException
15:30:34 <lambdabot> IO a -> IO b -> IO a
15:30:43 <EvanR> mwelt: oops.. fixed the xs typo
15:30:51 <monochrom> No, the type determines which other exceptions to not catch.
15:31:11 <monochrom> Someone has to say "none" if you want none.
15:31:33 <EvanR> even onException is potentially selective
15:32:26 <monochrom> You may not believe it --- author bias and all --- but this is telepathy.
15:33:40 <monochrom> Just like even with "print []" someone has to say 'this is not a string, print []' vs "this is a string, print "" '
15:33:44 <hpc> actually
15:33:54 <hpc> even for [] y... that
15:34:00 <monochrom> :)
15:34:56 <wroathe_> Lol, aeson parse errors are hilarious: user error (Error in $: Failed reading: satisfy)
15:34:59 <monochrom> Polymorphism is greatly misunderstood, generally speaking.
15:35:07 <wroathe_> It's like, "great, I'll get right on that"
15:35:27 <EvanR> for giggles look at errors from the json decoder in your javascript browser console
15:36:17 <EvanR> as important as json parsers are in the universe... the tooling is terrible
15:36:20 <monochrom> Sometimes people are insensitive to caller-choose vs callee-choose.  And sometimes people downright superstitious believe that they get the "best" of both.
15:37:31 <hpc> in the absence of type classes programmers are pretty pampered, to be fair
15:38:28 <wroathe_> There's technically no reason Exception e couldn't default to SomeException like the Int example though, right? Just that we don't like making exceptions to the rule?
15:38:39 <monochrom> Haha
15:38:56 <EvanR> this is a case of do what i mean
15:39:04 <monochrom> Technically defaulting can be done, yes.
15:39:23 <monochrom> I am a bit skeptic of the value of doing it.
15:40:42 <hpc> it doesn't fit with the current justification for defaulting
15:40:52 <hpc> (which is avoiding dictionary lookups for all-too-common numeric operations)
15:41:21 <monochrom> I am less skeptical of defaulting exception types if the default is all-sync-exceptions.
15:41:55 <EvanR> defaulting to "all exceptions ever" does sound really suspicious in retrospect
15:42:08 <hpc> some sort of typed exceptions would be nice
15:42:14 <EvanR> i have cursed anyone who inserted and left a "catch all exceptions here" implicitly in the code
15:42:14 <hpc> (typed like java's checked exceptions)
15:42:38 <EvanR> which i just found out is what guards do in elixir
15:42:55 <EvanR> exception in a guard is a silent failure of the guard, not an error
15:43:18 <wroathe_> What I really want in this case is a version of query_ that returns an IO (Maybe [r])
15:43:28 <wroathe_> Rather than throwing an exception in the first place
15:43:53 <monochrom> For async exceptions, in most handwritten code you don't want to catch, you want them to fly right through, hit an outer bracket which cleans up and re-throw (and terminate the thread).  So it's a bad idea to include them in the default.
15:45:33 <EvanR> erase the exception? ok you just need to write the wrapper for that
15:45:48 <EvanR> its what try does
15:45:50 <wroathe_> And if I wanted to be really correct about this I'd actually inspect the exception to ensure it IS a connection failure: http://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/src/Database.PostgreSQL.Simple.Internal.html#libPQError
15:46:06 <EvanR> oh, you only want connection failures??
15:46:12 <monochrom> :)
15:46:13 <EvanR> changes everything
15:46:14 <wroathe_> Yeah, I suppose you're right. I'm just being really lazy
15:46:25 <monochrom> Yes I recommend narrower.
15:46:26 <wroathe_> Why won't Haskell let me be lazy
15:46:44 <monochrom> But IOException is a good middle ground
15:47:13 <mwelt> j
15:47:36 <wroathe_> This compiler insists on type checking everything I do
15:47:38 <wroathe_> Real pain
15:47:39 <dmwit> (Why doesn't postgresql-simple define a new exception type?)
15:48:00 <monochrom> Is it a new exception type? Isn't it GHC's?
15:48:12 <dmwit> It is GHC's, and I think that's a mistake.
15:49:03 <dmwit> A design mistake, I mean. It's cheap to define new exception types, and much better for the person trying to catch them.
15:50:18 <monochrom> Oh! I misread "Why doesn't" as "Why does".
15:50:40 <EvanR> how old is postgresql-simple, maybe it predates exceptions
15:50:43 <c_wraith> yeah, it should define its own parent exception type.
15:50:51 <c_wraith> iirc, it does not.
15:50:57 <c_wraith> I thi k
15:51:17 <wroathe_> ScopedTypeVariables is good enough, thanks for that monochrom 
15:51:17 <monochrom> Worse, it goes out of its way to exploit IOException internals.
15:51:27 <wroathe_> I'm not nearly as offended by the code now
15:51:30 <c_wraith> I think new exceptions were built shortly before I started using Haskell, postgres-simple a year or so after
15:52:25 <dmwit> EvanR: Version 0.0 was uploaded in 2011; I haven't checked how far back the Exception class goes, but base-4.2.0.0 already has it and that was 2009.
15:52:40 <EvanR> then they have no excuse!
15:54:19 <monochrom> Ah they do have their own "instance Exception SqlError" "instance Exception FormatError"
15:55:50 <monochrom> I kind of respect that IOException is used for connection error. I am just annoyed that they write like IOError{ioe_handle = ..., ioe_type = ...} i.e. tie in to an implementation detail that shouldn't be relied on.
15:57:25 <EvanR> what is the proper way to construct your own IOError though
15:57:51 <monochrom> mkIOError at least.
15:59:38 <EvanR> i see
16:01:37 <wroathe_> Hah, apparently a connection failure is something other than an IOException
16:01:40 <wroathe_> FOr some reason it didn't catch
16:01:50 <monochrom> Yikes
16:01:54 <EvanR> not surprised
16:04:11 <monochrom> You could try my trick at http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#supertyping to print out the exception type you're looking for.
16:06:50 <wroathe_> Likes like phadej is maintaining this too these days: https://github.com/phadej/postgresql-simple
16:06:53 <wroathe_> Busy guy
16:08:25 <hpc> jeez, 474 repos
16:08:57 <xsperry> hello. I added a field to my type that is stored in json with Aeson library. I thought I edited (by hand) the json correctly, but apparently I didn't, and Data.Aeson.decode gives me unhelpful "Exception: Could not decode test.json JSON file". any tips on debugging this?
16:09:46 <suzu> use the decodeEither
16:09:51 <suzu> instead of 'decode'
16:10:08 <suzu> which is just a better thing to do in any case - decode throws exceptions and decodeEither won't
16:10:36 <xsperry> won't the error message be the same? except it will be returned as Left instead of as exception
16:10:40 <suzu> err wait a minute
16:11:00 <suzu> latest aeson doesn't throw anything on any decode function
16:11:24 <suzu> so i'm not sure how this is happening in the first place
16:11:28 <suzu> what version of aeson is this?
16:12:12 <wroathe_> Oh, DUH, I'm catching query_ not connect. I've been at this too long.
16:13:50 <xsperry> suzu aeson 1.1.2.0
16:15:23 <xsperry> this is an old project, using ghc 8.0.2, and I just need add some small additional functionality
16:15:47 <suzu> decode can't throw anything
16:15:57 <suzu> your exception can't be coming from Data.Aeson.decode
16:16:39 <xsperry> oh! you're right, my aesonDecodeFile throws.
16:16:49 <xsperry> I don't see decodeEither
16:17:03 <xsperry> it doesn't exist in aeson version I'm using?
16:17:16 <suzu> it's actualy
16:17:19 <suzu> actually * 
16:17:21 <suzu> eitherDecode :: FromJSON a => ByteString -> Either String a
16:17:25 <suzu> and not decodeEither :P
16:17:28 <suzu> my mistake
16:17:33 <xsperry> :) np. let me try
16:17:42 <suzu> something else is wrong though. can you paste the code for your aesonDecodeFile function someplace?
16:17:45 <suzu> like on gist or pastebin
16:18:02 <suzu> aeson does not throw exceptions
16:18:06 <xsperry> I'll do it if this doesn't fix my problem. it will take a while to make a example
16:18:19 <xsperry> you're right. I did this project over a year ago, my own function is throwing that exception
16:18:29 <suzu> yeah so the problem lies elsewhere
16:18:46 <suzu> so the amount i can help is pretty limited unless i can see how that exception is being made
16:19:18 <xsperry> I am doing throwIO $ MyException "Could not decode " ++ path ++ " JSON file". :)
16:19:51 <suzu> yeah so.. that's not illuminating
16:19:53 <suzu> lol
16:20:04 <xsperry> I was mistaken, and thought that aeson is throwing it. let me try eitherDecode real quick
16:20:08 <suzu> if you're using decode then it just gives you a Maybe
16:20:18 <suzu> which is cool unless it fails - you won't know why it failed, just that it failed
16:20:28 <suzu> eitherDecode will provide something helpful in the Left on failure
16:21:31 <xsperry> not much better
16:21:34 <xsperry> *** Exception: "Error in $: Failed reading: satisfy"
16:21:44 <xsperry> (that is Left, I'm just throwing it)
16:22:03 <suzu> yep
16:22:06 <suzu> that's a proper error
16:22:11 <suzu> k now the issue is aeson errors actually suck
16:22:34 <suzu> this error means the json is malformed
16:22:53 <suzu> like it has an extra open brace or a bad key in an object
16:22:55 <suzu> iirc
16:23:00 <xsperry> the actual json, or the json structure that aeson expects given my data types?
16:23:07 <suzu> the actual json
16:23:12 <suzu> like the string is just plain wrong
16:23:25 <suzu> perhaps it's like "[1,2," or "{"key
16:23:31 <suzu> {"key": 
16:23:45 <suzu> at this point, just throw your json into a better validating tool than aeson
16:23:51 <suzu> like jsonlint.com or something
16:23:55 <xsperry> ok, that's quite possible, since I edited json with vim.
16:24:29 <suzu> yeah its a parsing error not a conversion/validation error
16:25:01 <EvanR> this situation is similar to getting "sorry, database file corrupted"
16:25:22 <EvanR> not something you really debug usually
16:25:33 <suzu> "sorry but things are broken glhf"
16:26:16 <EvanR> "next time don't close vim so you can undo"
16:26:23 <suzu> iirc aeson parse errors are bad in exchange for aeson being fast
16:26:54 <suzu> attoparsec eagerly forgets things as it parses and can't give a good error when things go wrong
16:27:01 <EvanR> that, and raw data files usually don't have extensive support for doing manual edits
16:27:39 <suzu> in other news, i've decided that doing technical interviews in haskell is stupid, dont ever do it
16:27:58 <Iceland_jack> "What better way to learn something about a function than looking at its inferred type?" (http://www.janis-voigtlaender.eu/ifip66-slides.pdf)
16:31:51 <jackdk> suzu: Can you elaborate?
16:31:53 <xsperry> suzu, thanks! I figured it out, I left a trailing comma on the last field
16:32:18 <suzu> xsperry: great! :)
16:32:23 <suzu> jackdk: it simply just doesn't explain well
16:32:47 <jackdk> as the candidate or as the employer?
16:32:52 <suzu> as the candidate
16:33:19 <suzu> however you try to explain it, if there's too much to explain because of the haskell-ness you'll just, more often than not, look dumb
16:33:56 <suzu> it does depend
16:33:59 <suzu> but i think it's strictly a risk
16:34:38 <EvanR> haskellers looking dumb, well, that may be a sign of language maturity
16:34:55 <EvanR> people other than computer science experts use it
16:34:56 <suzu> this is also assuming the employer is familiar with imperative programming and only gently familiar with FP
16:35:49 <suzu> "ok so to solve this problem, we'll define a datatype for the tree like this, and we'll also make it a Functor because that'll be useful later"
16:35:59 <suzu> "uhh well so a functor is anything that's.. mappable. ish"
16:36:24 <suzu> "trees are functors and so are lists. but also functions are functors because.."
16:36:36 <suzu> => thanks for your time i have no clue what yhou were saying please reapply in 6mo
16:37:01 <EvanR> this person is probably in and you're making them cry
16:37:03 <EvanR> in here
16:37:09 <suzu> well, this person was me
16:37:16 <EvanR> case in point
16:37:25 <suzu> im studying algorithms and such, for upcoming interviews
16:37:29 <suzu> and i'm practicing in python
16:37:43 <suzu> because everyone can read it, get it, and understand what i'm doing when it doesn't go right and i have to debug it
16:37:54 <suzu> if i did haskell it'd look like arcane magicks
16:38:02 <suzu> sad
16:38:29 <suzu> also, some kinds of things are turing tar-pits in haskell and it takes more work to do them
16:38:31 <EvanR> when python code is the gold standard in non-magick, i cry
16:38:38 <suzu> same
16:38:46 <suzu> i'd never use it for a real software application
16:38:54 <suzu> but it's pretty good when you want to write bad programs. aka, scripts
16:38:58 <suzu> ;)
16:39:09 <dmwit> I mean.
16:39:12 <Lycurgus> sad indeed
16:39:17 <dmwit> You can just write a mapping function without calling it Functor.
16:39:25 <dmwit> Which is presumably what you've done in the Python equivalent.
16:39:40 <suzu> well, no. in the python equivalent i don't define any new types
16:39:46 <EvanR> rename Functor to Mappable, Monad to Chainable
16:39:48 <suzu> "we'll represent this as a dict of dicts"
16:39:59 <suzu> "where keys are like this and values are like that"
16:40:04 <Lycurgus> as if in 6 mo you would stop talking like that
16:40:18 <suzu> the real solution is, don't use haskell
16:40:23 <suzu> in an interview
16:40:30 <dmwit> ??
16:40:34 <dmwit> A dict of dicts is not a tree.
16:40:36 <EvanR> were you interviewing for a job totally unrelated to haskell
16:40:41 <EvanR> and pulled haskell out
16:40:41 <suzu> yeah
16:40:43 <EvanR> nice
16:40:45 <suzu> y..es i have done so
16:40:48 <suzu> years ago
16:40:52 <suzu> don't do it y'all
16:41:04 <EvanR> now the story makes sense
16:41:19 <suzu> if you're interviewing for a haskell job, they probably want you to show them some haskell
16:41:22 <jackdk> counterpoint: I've had it work pretty well, but that was before I knew a lot of advanced features
16:41:22 <suzu> and they know it themselves
16:41:48 <EvanR> it sounds like you went to the steak restaurant and ordered the fish
16:41:51 <suzu> i suppose you could do fine if you don't (flip . (<$> . <$>) . (***)) and make their head explode
16:41:59 <EvanR> or vice versa
16:42:16 <suzu> pretty much
16:44:50 <dmwit> I dunno. If you're implementing Functor by hand, you can just explain what fmap does as you write it. And if you're not, presumably that's because it's not the focus of what you're doing, and an English sentence or two saying "Functor lets you modify all the contained elements" will get you where you need to go?
16:45:35 <suzu> that will probably be fine
16:45:49 <EvanR> relating some concept via an alien language probably requires extra special care to "getting to the point"
16:46:07 <suzu> but alternatively i can just ramshackle some python together and move on
16:46:09 <EvanR> no whirlwind tour of everything
16:46:10 <suzu> :/
16:48:27 <dmwit> There's probably a lot of stuff where there's large inferential differences between your interviewer and you.
16:48:32 <dmwit> That seems understandable to me.
16:49:09 <dmwit> ...I don't know. I was going to make a suggestion about how to deal with that, but I've never tried it, so never mind.
16:49:23 <dmwit> If I ever do try it, I'll argue more vehemently next time. =P
16:56:45 <kwak> has anyone used kmett's `bound` package? i would like to use it to represent pi-calculus terms
16:57:27 <kwak> but there is no valid `Applicative` instance for it, because a single name is not a valid term on its own
17:19:12 <oats>  :t (flip . (<$> . <$>) . (***))
17:19:17 <oats> :t (flip . (<$> . <$>) . (***))
17:19:20 <lambdabot> error: parse error on input ‘.’
17:19:27 <oats> huh
17:19:29 <jackdk> :t ((<$>) . (<$>))
17:19:31 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
17:20:10 <oats> so that's what you gotta use if you've got a functor in a functor :P
17:20:23 <oats> I'm not familiar enough with arrows to know what (***) is
17:24:00 <lavalike> oats: just substitute (->) for a
17:24:10 <pyan> Apparently, it is a parallel composition.
17:28:49 <oats> :t (***)
17:28:51 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:29:30 <oats> interesting
17:29:37 <oats> I really should try to learn arrows
17:29:50 <oats> :t (<$> . <$>) . (***)
17:29:53 <lambdabot> error: parse error on input ‘.’
17:30:02 <oats> wonder why it doesn't like that
17:31:28 <lavalike> because infix . infix 
17:34:50 <pyan> :t (***) ($) ($)
17:34:52 <lambdabot> (a1 -> b1, a2 -> b2) -> (a1 -> b1, a2 -> b2)
17:35:32 <oats> well that's not an extremely useful function, is it :p
17:35:42 <pyan> Yeah, not terribly exciting.
17:35:47 <pyan> Also, I misread. You said <$> rather than $.
17:36:10 <lavalike> > ((^2) *** negate) (10,10)
17:36:17 <lambdabot>  mueval-core: Time limit exceeded
17:36:18 <lavalike> it's handy at times
17:36:27 <lavalike> @botsnack
17:36:28 <lambdabot> :)
17:36:35 <lavalike> > ((^3) *** negate) (10,10)
17:36:37 <lambdabot>  (1000,-10)
17:39:02 <c_wraith> pyan, fun thought experiment from that... ($) is actually just id with a more restricted type.
17:45:43 <infinisil> @src ($)
17:45:43 <lambdabot> f $ x = f x
17:46:44 <infinisil> I guess using `f = id` would be probably be slower
17:48:18 <dmwit> :t ((<$>) . (<$>)) -- oats, this is the correct syntax
17:48:20 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
17:48:33 <oats> oh, of course
17:48:33 <dmwit> :t flip . ((<$>) . (<$>)) . (***) -- can't imagine this was anything but a joke
17:48:35 <lambdabot> (Functor f, Arrow a) => a b1 c -> b2 -> (b2 -> f (a b' c')) -> f (a (b1, b') (c, c'))
17:48:41 <oats> dmwit: I realize that lol
17:48:54 <oats> I just couldn't be arsed to figure out that type in my head
17:50:07 <infinisil> Haskellers are using one-letter type variables because otherwise the types would be way too long, eh
17:50:30 <infinisil> (And I guess the constraints should be the focus, not the names)
17:50:49 <hpc> there's not much meaning you can assign to those variable names anyway
17:52:03 <infinisil> Ah yeah, but there are cases where it would make a lot of sense
17:52:20 * infinisil is thinking of lens
17:54:21 <infinisil> Although, maybe not
17:54:26 <hpc> i could see it
17:55:06 <hpc> get :: Lens infield outfield invalue outvalue -> (something with outfield in the type)
17:55:21 <hpc> wait crap, that's backwards
17:55:26 <hpc> Lens invalue outvalue infield outfield
17:55:37 <infinisil> Hehe
17:56:04 <hpc> it's harder to do that for say, fmap
17:56:12 <infinisil> :t fmap
17:56:17 <infinisil> > :t fmap
17:56:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:56:24 <lambdabot>  mueval-core: Time limit exceeded
17:56:44 <infinisil> Yeah
17:57:00 <infinisil> I guess the more general a type, the harder it is to assign meaningful names
17:57:25 <hpc> yeah
17:57:33 <hpc> or the less purpose you can assign to it, perhaps
17:57:41 <c_wraith> infield and outfield? when did lens add baseball combinators
17:57:56 <hpc> the lens types are pretty damn general in isolation, but being used in such a specific way helps
18:00:10 <hpc> you get sort of the same problem with operator names
18:00:24 <hpc> except without the benefit of language to help you out with things that are really specific
18:00:41 <hpc> so you can do (+) and (<$>) fine
18:00:44 <jackdk> only sortof. good libraries choose the operators in such a way that they form their own minilanguage
18:00:57 <hpc> but once you get into (~.-<<^&) you start losing me
18:01:54 <infinisil> Yeah I don't like libraries with many weird operators, makes it hard to jump into the library and codebases that use it
18:02:10 <hpc> jackdk: i have yet to encounter a piece of documentation explaining a package's operator minilanguage
18:02:19 <jackdk> even in lens, anything with = in it works on MonadState, anything with ? in it involves maybe, a leading < means also return the value you set, << means return the old value etc
18:02:34 <hpc> if i am lucky it has something like lisp's caaaadaar crap where i can infer meaning for some things from the repetition
18:02:59 <jackdk> hpc, I wish it was spelled out, too, but the consistency is there and it is useful
18:03:16 <hpc> heh, "spelled out"
18:03:26 <hpc> when talking about operators
18:03:32 <c_wraith> I'm sure I've seen the lens operator vocabulary written out specifically before.
18:03:35 <jackdk> the irony is not lost on me
18:03:44 <hpc> c_wraith: in haddock? :P
18:03:56 * infinisil checks whether https://github.com/well-typed/optics has loads of operators
18:03:58 <infinisil> too
18:04:06 <jackdk> I saw a linear algebra lib where the operators were like ^+. etc, and the ^ meant "I take a vector on that side" and . meant "I take a scalar on that side"
18:04:13 <c_wraith> not all documentation needs to be in haddock
18:04:49 <hpc> where else would it be?
18:04:54 <ski>   fmap :: Functor f => (a0 -> a1) -> (f a0 -> f a1)
18:07:38 <dmwit> hpc: fmap :: Functor container => (input -> output) -> container input -> container output
18:07:59 <lavalike> > ((*5) ~.-<<^& (^2)) 7
18:08:03 <lambdabot>  (105,50)
18:10:34 <oats> wait for real
18:10:38 <oats> that's a real function?!
18:11:07 <lavalike> of course
18:11:38 <oats> :t (~.-<<^&)
18:11:41 <lambdabot> (Num c, Enum c') => (b -> c) -> (b -> c') -> b -> (c, c')
18:11:51 <no-n> :(
18:12:01 <no-n> that's more perl than perl
18:12:06 <ski> presumably someone just defined it
18:12:09 <oats> oh
18:12:14 <oats> yeah, I can't find it on hoogle
18:12:53 <ski>   (f ~.-<<^& g) x = (f x * 3,succ (g x))  -- or somesuch
18:20:31 <EvanR> i'll be sure to use ~.-<<^& in the next haskell presentation to good effect
18:26:02 * ski . o O ( "Iteratees" by Maria Kovalyova,Roman Cheplyaka in 2012-10-20 at <https://ro-che.info/ccc/15> )
18:27:52 <EvanR> ... leftovers ...
18:29:42 <EvanR> too bad this web comic ended
18:29:47 <hpc> heh
18:59:49 <janat08> So how does `hold never . leftmost $ [ "etc" ]` work, with 2 params for hold, and one for leftmost. What is that function composition period doing?
19:01:35 <sarahzrf> janat08: well, we have `hold never . leftmost' being applied to `[ "etc" ]'
19:02:17 <sarahzrf> this means `hold never' is applied to `leftmost' applied to `[ "etc" ]'; that is, `hold never (leftmost [ "etc" ])'
19:02:32 <EvanR> to answer what . does on a function of two arguments... you just remember all functions have 1 argument, i.e. all functions are curried
19:03:59 <EvanR> so hold never is really just a regular function of 1 arg
19:06:17 <janat08> I suspect that hold winds up taking  "never .". Are you trying to say that  "hold never" is being composed with leftmost?
19:06:46 <dmwit> > (f ~.-<<^& g) x
19:06:47 <janat08> because the list is a bunch of function
19:06:50 <lambdabot>  error:
19:06:50 <lambdabot>      • Ambiguous type variable ‘c0’ arising from a use of ‘show_M138011974681...
19:06:51 <lambdabot>        prevents the constraint ‘(Show c0)’ from being solved.
19:06:55 <dmwit> > (f ~.-<<^& g) x :: Expr
19:06:57 <lambdabot>  error:
19:06:57 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘(c0, c'0)’
19:06:57 <lambdabot>      • In the expression: (f ~.-<<^& g) x :: Expr
19:07:04 <dmwit> > (f ~.-<<^& g) x :: (Expr, Expr)
19:07:07 <lambdabot>  (f x * 3,succ (g x))
19:07:13 <dmwit> ski: Nice guess. =)
19:07:44 <dmwit> You even got the same spacing as lambdabot's golden answer. =)
19:08:00 <monochrom> haha
19:10:55 <oats> I don't understand
19:10:56 * ski smiles
19:11:01 <oats> dmwit: what were you trying to accomplish there?
19:11:10 <ski> (it's the one true spacing)
19:12:28 * ski didn't even think of `Expr'
19:12:45 * ski eyes oats
19:13:33 <oats> oh, were they trying to guess the type of the expression?
19:14:44 <ski> no, getting at the implementation (more or less)
19:14:49 <janat08> is there like a tool to understand how something like `hold never . leftmost $ [ "func"]` works? They call them lexer or something.
19:17:52 <janat08> oh right its literally just (hold never) . leftmost $
19:18:20 <turab> :k Expr
19:18:22 <lambdabot> *
19:20:35 <oats> what is Expr?
19:21:03 <ski> @hackage simple-reflect
19:21:03 <lambdabot> http://hackage.haskell.org/package/simple-reflect
19:22:33 <Cale> janat08: Yeah, the most important thing to remember about precedence in Haskell (which ironically is not actually about operator precedence as much as just how things parse) is that whitespace binds more tightly than any infix operator
19:23:41 <Cale> The second most important thing to remember is that $ binds as weakly as possible to its arguments (so it's almost but not quite the same thing as putting parens around the expressions on either side of it)
19:23:58 <ski> (how would operator precedence not be about how things parse ?)
19:24:28 <Cale> ski: It would, but function application isn't formally an operator
19:26:26 <ski> it's useful to consider it as one (just as you can consider `@',`=>',`::' as ones)
19:27:25 <ski> (for the purpose of precedence comparision. one might term them "syntax operators", maybe)
19:34:51 <monochrom> Sometimes these distinctions hurt rather than help.
19:35:58 <monochrom> Remember last time on haskell-cafe someone tried to chastise me about "Pascal's ; is a delimiter, Prolog's , is a logical connective, C's && is an operator, they're all oh-so different!"
19:36:20 <maerwald> only from compiler perspective
19:36:26 <monochrom> Like who cares, you use the same chainl or chainr to parse.
19:36:32 <maerwald> I'm a programmer, not a compiler :P
19:38:02 <monochrom> and completely missing the point that all of them have the same semantics: sequential execution until you hit a condition, then abandon the rest.
19:38:27 <monochrom> and therefore it completely doesn't matter whether you call them left-assoc, right-assoc, or flat list.
19:38:27 <maerwald> well, there are two types of programmers (simplified): intuitional and analytical
19:38:36 <maerwald> I guess these distinctions may help the analytical type
19:39:05 <maerwald> like, C++ developers need to understand how laziness is implemented, otherwise they get confused
19:39:47 <pyan> maerwald: What is an expression template if not hand-rolled and hand-tuned laziness?
19:39:58 <pyan> I would expect C++ programmers to know this very well.
19:40:44 <monochrom> I don't dispute your dichotomy. But I have an orthogonal dichotomy that explains this better. Red tape vs cutting to the mustard.
19:41:29 <monochrom> Because I am analytical and anti-intuition, but I use my analysis to deconstruct the red tape and cut to the mustard.
19:42:33 <monochrom> The red-tape difference between built-in function application and $, for example, is that $ is user-definable but the other isn't.
19:42:50 <monochrom> Sometimes this is useful, sometimes it isn't.
19:43:21 <monochrom> It actually takes a really good analytic mind to analysis when and when not to emphasize it.
19:45:00 <maerwald> I think that distinction gets easily lost in internet dispute ;D
19:47:45 <monochrom> Well it's always easier to pretend to be analytic and methodological by up-playing TPS Cover Sheets, the "difference" among semicolon comma &&, and other peripheral technicalities.
19:49:14 <maerwald> heh
21:29:44 <eacameron> Is there a safe version of fromIntegral that checks for over/underflow?
21:43:40 <koala_man> what's the difference between Phase 1 and Stage 1 when building GHC?
23:33:16 <dminuoso> With servant, is there a way to annotate an endpoint in such a way that I can attach documentation to it?
23:34:55 <Axman6> Has anyone used the LLVM backend on macOS recently? I'm getting assembler errors: https://gist.github.com/axman6/d7244c5610dcbbaf84bf8030f55d67d0
23:35:31 <Axman6> I found https://translate.google.com.au/translate?sl=auto&tl=en&u=https%3A%2F%2Fmizunashi-mana.github.io%2Fblog%2Fposts%2F2019%2F05%2Fghc-with-llvm%2F but doing what I believe is the stack equivalent of setting those flags fails
23:36:37 <Axman6> dminuoso: yes!
23:36:56 <Axman6> dminuoso: https://hackage.haskell.org/package/servant-0.15/docs/Servant-API-Description.html
23:37:22 <Axman6> and things like servant-swagger support those annotations
23:37:54 <dminuoso> Axman6: Ahh. I was browsing through servant-docs until I was very confused.
23:38:03 <dminuoso> Cheers, that looks exactly what I was looking for.
