00:00:29 <dminuoso> akr: Is this what you meant? https://gist.github.com/dminuoso/90271d742ed2ce46161a141a3acffbb3
00:02:16 <akr> dminuoso: hm, not exactly, I want the type to depend on a value
00:02:20 <akr> Not type
00:02:44 <akr> So one of the fields of my record is an enum
00:02:47 <dminuoso> akr: Ohh, I misread that.
00:02:54 <dminuoso> akr: Take a look at singletons
00:03:13 <akr> Alright, will do 
00:59:18 <MasseR> What's the difference between `module Foo.Bar where` and `module Foo.Bar ( module Foo.Bar ) where` ?
00:59:36 <MasseR> The latter one explicitly exports the same module, but there seems to be some difference in behavior
01:01:46 <MasseR> Ah, I didn't notice that there was an import a few lines below which is qualified to Foo.Bar: `import Foo.Bar.Internal as Foo.Bar`
01:03:31 <comerijn> MasseR: If that import was missing there wouldn't be a real difference, but there's still a reason to export like that
01:04:14 <comerijn> MasseR: Namely, you can only do re-exports if you have an explicit export list, so if you wanna export the entire module *and* re export some stuff, then that approach avoids having to explicitly list all definitions of the current module
01:04:44 <MasseR> Sure, `module Foo.Bar (module Foo.Bar, module Bar) where` would make sense I agree
01:05:02 <MasseR> In fact I modified this to be `module Foo.Bar (module Foo.Bar, module Foo.Bar.Internal) where` to be more explicit
01:05:09 <merijn> MasseR: That approach of import Foo.Bar.Internal as Foo.Bar is kinda questionable, yeah
01:05:23 <Axman6> I recently came across something I found really surprising about module exports. If you export a module from another module, only things which were imported from that second module unqualified are exported
01:05:51 <merijn> Axman6: Well, yeah, how would you possibly do a "qualified export"?
01:06:19 <Axman6> so if you have module A (a,b,c) where ...; module B (moudle ToExport) where import B as ToExport; import B (a); only a is exported from B
01:06:53 <Axman6> import qualified B as ToExport*
01:08:17 <Axman6> merijn: see the esmaple, my intuition was that whe using import qualified Foo as Bar, and then exporting Bar, everything from Foo would be reexported
01:08:25 <Axman6> example - one day I'll learn to type
01:11:35 <merijn> Axman6: That's brittle in many cases, though. For example, if you qualified import Bar because the current module happens to have many similar identifiers, then what should happen?
01:13:24 <Axman6> the point is that just given the lines module Foo (module Bar) where import qualified Bar as Bar, you can't immediately tell what will be exported by that module Bar export (in fact, without any other imports of Bar, nothing at all is exported by the module export)
01:14:30 <Axman6> which I'm sure I'm not the only person who would find that unexpected - I have explicitly imported and named a module, and then exported it, therefore the content of that module is what I expect to be exported
01:15:23 <Axman6> but it actually depends on a second import, which doesn't mention that explicit name at all, whether something is exported or not by the export of that explicit name
01:39:02 <dminuoso> In general, would you place instances inside the module that defines the class, or inside the module that defines the data type? Are there non-obvious implications for chosing one over the other?
01:41:22 <merijn> dminuoso: If you control both it doesn't really matter
01:41:35 <merijn> dminuoso: If you don't control both, the answer's already decided for you :p
01:41:41 <dminuoso> Obviously, heh.
01:41:56 <dminuoso> merijn: What about avoiding circular dependencies?
01:42:17 <merijn> I guess that could factor in, but I've never really run into that
01:42:27 <merijn> I'm not sure if it could even happen?
01:43:00 <dminuoso> merijn: Thing is, inside my current project I've had to refactor a few times because circular dependencies kept popping up.
01:43:21 <merijn> I wish GHC would just support circular imports like the spec says it should
01:43:22 <dminuoso> I've been trying to understand whether that's just "Haskell", or whether I might be misdesigning things.
01:43:38 <merijn> dminuoso: I'd say "neither"
01:55:24 <yorick> does Hadrian scale well over more than 4 cores? I know ghc --make doesn't :/
01:58:05 <Jinna> In a case of block I have three cases for which I want to run the same body. Is there a syntax that allows me to connect these three options via OR?
01:58:48 <merijn> Jinna: Sadly, not really. I usually move the block into a let/where and use it by name in each branch
01:58:50 <dminuoso> Jinna: No.
02:06:23 <haskelllisp[m]> stack haddock --keep-going<br />
02:06:24 <haskelllisp[m]> Can I skip the failed package?
02:11:05 <jgt> I'm looking at some code like `mbChat <- lift $ lift $ runDB $ DB.getChat uuid`. Is the double lift a code smell?
02:13:34 <MasseR> I would almost go to the extreme and using lift is already a code smell
02:14:01 <dminuoso> MasseR: Why? Just because they didn't write some MonadFoo instance to do the lifting implicitly?
02:14:15 <MasseR> dminuoso: exactly
02:14:27 <dminuoso> MasseR: If follow that thought to its extreme you'd end up arguing that monad transformers are a smell, no?
02:14:40 <MasseR> How come?
02:14:42 <dminuoso> In principle explicit is always better than implicit.
02:15:18 <MasseR> I would argue that more polymorphic is better 
02:16:16 <MasseR> lifts are a sign you're using concrete types 
02:16:17 <jgt> I'm using Yesod, so throwing all the monad transformers away is not really a solution
02:16:34 <dminuoso> MasseR: I dont think writing mtl-style code is inherently better.
02:16:39 <merijn> MasseR: I would say the opposite, concrete stack > mtl
02:16:44 <dminuoso> Indeed.
02:17:09 <dminuoso> I mean there may be cases where writing fragments using mtl-typeclasses is advantageous (especially if you want to reuse some code fragment in various places)
02:17:45 <MasseR> More generic signature can describe more. More generic signatures allows functions to be used in different situations. More generic signatures allows for better testability
02:18:23 <merijn> More generic (in the mtl style, not parametric polymorphism) cannot be run without fixing a concrete stack and also lead to horrifying error messages
02:18:31 <MasseR> `MonadChat m => m UUID` is more telling than `AppM UUID`
02:18:44 <maerwald> Less generic = better documentation in terms of type signature
02:18:44 <dminuoso> MasseR: When the only way you use that through AppM its not.
02:19:34 <dminuoso> That being said, I've resorted to using mtl-style code to break cyclic dependencies in the project Im in..
02:19:47 <dminuoso> And I felt really shabby.
02:20:50 <merijn> dminuoso: Join my quest to convince GHC maintainers to finally implement the report and add support for circular imports!
02:22:07 <dminuoso> merijn: There was this fun converation during last munihac when half a dozen GHC core members were sitting at the table, and someone asked "who here is using boot modules?" - and everyone just stared in silence..
02:22:33 <merijn> I have literally NEVER succeeded in making boot modules work, despite 10 attempts
02:23:22 <dminuoso> merijn: You just didn't try hard enough. If you randomly type things, then boot modules will eventually work.
02:23:53 <dminuoso> That's the Shakespear Boot thereom.
02:24:07 <dminuoso> "Infinite Boot Module theorem"
02:53:08 <sm[m]> g'day all.. any idea how hard it would be to add unix socket support to a yesod app ?
02:54:14 <dminuoso> sm[m]: That's unrelated to yesod.
02:54:42 <dminuoso> sm[m]: yesod just sets up a WAI compatible application, so it depends on which server you are using to serve that WAI app.
02:55:11 <dminuoso> sm[m]: If you are using ⌜warp⌝ for instance, you can run it via https://hackage.haskell.org/package/warp-3.3.0/docs/Network-Wai-Handler-Warp.html#v:runSettingsSocket
02:56:52 <sm[m]> dminuoso:  cool, thanks. I also found https://stackoverflow.com/questions/22621623/warp-binding-to-unix-domain-sockets and https://www.yesodweb.com/book/deploying-your-webapp#deploying-your-webapp_nginx_fastcgi
02:57:29 <dminuoso> sm[m]: To understand the reason a bit better, ⌜type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceivedUses⌝
02:58:16 <dminuoso> sm[m]: So yesod exposes a simple function that needs to be fed a request, and some callback for the response. It doesn't care how the request comes into existence, or what happens with the response. :)
03:01:21 <sm[m]> yup
03:01:44 <sm[m]> I mentioned yesod just to be concrete
03:02:01 <sm[m]> so it sounds pretty easy
03:02:47 <sm[m]> yay typesafe reusable code
03:39:07 <fuzzy_id> is there some flag to tell stack to include `Paths_library_name` into the exposed modules list?
03:40:58 <sm[m]> fuzzy_id: it seems automatic if you are using a package.yaml file ?
03:41:43 <fuzzy_id> the generated cabal file lists the Paths_* module in `other-modules`
03:42:35 <sm[m]> ahh
03:42:56 <sm[m]> I would guess you have to manually put it under exposed in package.yaml
03:43:06 <sm[m]> but I really don't know, so ignore me
03:43:17 <sm[m]> if there is, it'll be in --help
03:44:25 <fuzzy_id> i actually can't even find an `exposed-modules` section in the package.yaml config
03:44:52 <sm[m]> it may be optional.. I have one
03:55:52 <bachibuzuk> Hi, the command "cabal v2 run" does not work, only "cabal
03:55:52 <bachibuzuk> run". Even though cabal --version yields 2.0.0.1. Any idea why ?
03:56:11 <bachibuzuk> only "cabal run" works I mean
03:58:57 <bachibuzuk> I'm under Fedora. 
03:59:14 <Taneb> bachibuzuk: try "cabal v2-run" (note the hyphen)
03:59:52 <bachibuzuk> yes this is what I did, just not reported it correctly here
04:00:21 <hexagoxel> v2-run seems only present in cabal-2.4+
04:01:06 <maerwald> how did you install cabal and ghc?
04:01:11 <bachibuzuk> hum ok. I've done cabal install Cabal cabal-install very recently though
04:01:43 <maerwald> is ~/.cabal/bin/ in your PATH?
04:02:07 <hexagoxel> fedora cabal-install is still on 2.0.0.1, i just checked
04:03:01 <hexagoxel> (but yeah, what maerwald says)
04:03:20 <bachibuzuk> I've followed this page https://www.haskell.org/cabal/
04:03:39 <merijn> More imprtantly, did you run "cabal update" before running cabal install? ;)
04:06:17 <maerwald> alternatively, you could try ghcup: https://www.haskell.org/ghcup/
04:06:24 <maerwald> should work well on fedora
04:07:16 <bachibuzuk> Indeed, not sure I've done cabal update; i'm doing it right now
04:11:38 <bachibuzuk> strange, I've updated, done cabal install, have the msg that I've
04:11:38 <bachibuzuk> cabal install 2.4.1.0 but cabal --version still yields 2.0.0.1
04:12:24 <merijn> What does "type cabal" report when run in your shell?
04:14:02 <bachibuzuk> cabal is usr/bin/cabal
04:16:08 <maerwald> maerwald: is ~/.cabal/bin/ in your PATH?
04:23:01 <Zer0xp> Can someone reply to this message ? Need to check if I've set up my IRC correctly.
04:23:31 <hexagoxel> Zer0xp: you can send something to lambdabot ;D
04:24:15 <Zer0xp> >1+1
04:24:27 <hexagoxel> > 1+1
04:24:30 <lambdabot>  2
04:24:35 <Zer0xp> > 1+1
04:24:39 <lambdabot>  2
04:24:44 <Zer0xp> LOL
04:24:48 <Zer0xp> Thanks guys
05:24:55 <kuribas> what's an efficient way to generate unboxed vectors?
05:25:03 <kuribas> for example of doubles
05:25:32 <kuribas> could I generate a list of doubles, then use Vector.fromList, and hope stream fusion eliminates the list?
05:26:08 <varikvalefor> kuribas: The text at http://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Unboxed.html might be of assistance to you.
05:29:47 <merijn> kuribas: Most vectors have multiple initialisers for creating them "in-place"
05:30:00 <merijn> kuribas: So youd' just rewrite your list generation to fit the in-place creation
05:30:14 <kuribas> varikvalefor: there's nothing about fusion there
05:31:35 <kuribas> merijn: I don't know the length beforehand
05:31:42 <Lycurgus> ur hopes were dashed
05:32:18 <merijn> kuribas: The fusion framework of vector is exported so you can just write a chunked/fusion supporting generator yourself
05:32:30 <merijn> kuribas: What are you doing that you don't know the length ahead f time?
05:32:38 <kuribas> merijn: decompression
06:06:30 <nakkle> Hi guys. Got a bit of a problem here: I'm building a stateful REST API with servant to manage a few resources, and I'm managing the internal state with an IORef pointing to a list of resources. API endpoints use atomicModifyIORef to read and modify the internal state in a thread-safe manner. Now my problem is that a few API endpoints should be using IO functions, e.g., to spin up a thread after checking whether a given resource is free,
06:06:30 <nakkle>  and saving the respective thread handle in the internal state. That doesn't seem possible with IORefs because atomicModifyIORef only takes a pure function to modify the internal state. I've seen more sophisticated libraries than IORef for that, namely STM and MVar. MVars seem to allow IO functions to modify the internal state, but aren't thread safe if I understand it correctly. STM on the other hand seems to have the same problem as I
06:06:31 <nakkle> ORef, can't do IO in there. Any tips how to solve this problem?
06:09:01 <MasseR> Anyone familiar with beam (the sql library)? By default if you have an entity name like 'userName' it will drop the 'user' part of it and just use 'name' as the sql column name. Can I override this behaviour? I know I can override each field individually, but that gets repetitive
06:10:42 <dminuoso> nakkle: What do you mean by "[MVars aren't threadsafe]"?
06:12:12 <merijn> nakkle: WHether MVar's are threadsafe depends on how you define threadsafe
06:12:25 <nakkle> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent-MVar.html says `modifyMVar_` is only atomic if there are no other producers for this MVar. I do have potentially multiple producers if I have multiple API calls at the same time.
06:12:40 <dminuoso> MVars are, in the end, primitives to construct larger abstractions with.
06:13:15 <merijn> nakkle: MVars have pretty simple semantics. "If you take on an empty one, you block until it's not empty" "if you put a full one, you block until it's emptied"
06:13:57 <merijn> nakkle: The problem is that "take, modify, put back" while another thread also writes to it, means you can get blocked on the "put back" step, because it's now full
06:14:26 <merijn> nakkle: modifyMVar literally just does those "take, modify, put back" steps, so hence it's unsafe if something is putting new data in
06:15:36 <nakkle> yeah exactly. I'm wondering whether I have any good way of managing this internal state over thread-boundaries, if I need to do "take, modify with IO, put back" in a thread-safe manner.
06:16:02 <merijn> nakkle: If there is only ever one item in the MVar that multiple threads are taking/putting back, that's fine
06:16:06 <dminuoso> nakkle: If every thread conforms to this style, its safe.
06:16:29 <merijn> nakkle: Because in the case all the other threads will just be blocked until you finish processing and put it back
06:17:08 <dminuoso> nakkle: If every thread promises to take before putting, then that acts as a mutex.
06:18:04 <nakkle> ah I see. so as long as every thread always uses `modifyMVar`, instead of lower level primitives like `takeMVar` and `putMVar`, I'm good?
06:18:56 <merijn> nakkle: Right
06:19:12 <nakkle> cool, makes sense. Thanks for your help!
06:19:15 <merijn> nakkle: The real problem is that this doesn't scale to multiple MVars
06:19:21 <dminuoso> nakkle: Or better yet, expose your own interface and dont show the MVar.
06:19:33 <merijn> nakkle: (because then you need to guarantee everyone accesses the same MVars in the same order)
06:19:56 <dminuoso> And only expose some `modifyState :: (S -> IO S) -> IO S` type of function that gives mutex guarantees.
06:20:56 <dminuoso> (And know that it can block)
06:21:01 <nakkle> merijn: Yeah, multiple MVars is not a problem for me right now, but I see the problem. Thanks for the heads-up. 
06:21:38 <dminuoso> nakkle: In principle you could still do something similar with STM if you had multiple memory locations.
06:22:13 <dminuoso> TMVar is basically MVars for STM.
06:22:30 <merijn> Not quite
06:22:49 <merijn> MVars have some guarantees that TVars (and thus TMVars) don't
06:22:53 <nakkle> TMVars don't allow IO in the modify step, or did I get that wrong?
06:23:06 <merijn> Specifically, MVars guarantee fairness
06:23:15 <dminuoso> nakkle: You dont need that. You could still just grab them inside a single transaction, do your IO, then execute another transaction putting them back.
06:23:36 <dminuoso> merijn: Ah okay. Which exact fairness guarantees is that?>
06:23:59 <dminuoso> Oh you mean the FIFO fairness guarantees?
06:24:03 <nakkle> dminuoso: right, but would only make things more complicated for a single MVar
06:24:18 <merijn> dminuoso: "fairness" is the guarantee, i.e. every take *will* eventually succeed
06:24:30 <dminuoso> nakkle: My point is just, that you could do this inside STM (or with multiple memory locations) if you needed to.
06:24:53 <dminuoso> nakkle: If you had multiple locations and you sometimes only need to modify some, then you could use TMVars in STM in principle. Though merijn is pointing out that this has subtle differences.
06:25:52 <nakkle> dminuoso: right. thanks for the details guys, learned quite a bit :)
06:27:33 <dminuoso> merijn: I see, and I dont have that guarantee in stm, in which theoretically a take could be blocked forever because it has bad luck?
06:28:06 <dminuoso> (I suppose it'd be more realistic that a take could spontaneously take an unreasonably long time)
06:29:16 <merijn> dminuoso: Yes
06:29:25 <merijn> dminuoso: Also, STM suffers from stampeding herd problems
06:29:58 <merijn> MVar (and as a result also Chan) guarantee single wake-up
06:30:15 <dminuoso> merijn: So in STM it's basically a race when the herd wakes up?
06:30:35 <merijn> dminuoso: Yeah
06:31:08 <merijn> All blocked transactions that reference a TVar will be woken up and try again and depending on their logic will be doing so uselessly
06:54:40 <Dark_Furia> Hello! I'm a total newbie in haskell. I've implemented my own version of reverse, and I can't undestand, why we should use this :  reverse' xs ++ [x] instead of reverse' xs : x. Can somebody explain it for me?
06:55:14 <dminuoso> Dark_Furia: What is the type of (:) ?
06:56:22 <Dark_Furia> a -> [a] -> [a] Understood:) Thank you
06:56:35 <dminuoso> You are welcome. :)
07:13:41 <mexonius> hi all!
07:13:47 <mexonius> someone alive?
07:13:47 <dminuoso> Hello mexonius.
07:13:50 <mexonius> :D
07:14:29 <mexonius> Dminuoso can I ask you a question?
07:14:54 <dminuoso> mexonius: Feel free, but direct it to the channel please.
07:15:30 <mexonius> sorry, to the channel or in pm?
07:16:01 <dminuoso> Just here is fine.
07:17:33 <mexonius> ok :) this is the first time learning about haskell and functional programming in general. For college purpose I need to install it on Arch linux based Manjaro: how can I do it?
07:17:48 <mexonius> general guide on off site will explain it?
07:18:29 <dmwit> The GHC website has a binary distribution that I strongly recommend.
07:18:38 <Sose> Manjaro should have packages for ghc or stack. I think just installing stack is recommended(?)
07:18:42 <dmwit> The Arch package manager has a package which I strongly disrecommend.
07:18:49 <Sose> oh?
07:19:04 <dmwit> Yes, in their push for dynamic-linking-only, they broke GHC and shipped it.
07:19:14 <dminuoso> ghcup is a fine option for getting the official binary distributions up quickly.
07:19:15 <dmwit> It has caused a lot of headaches.
07:19:28 <mexonius> https://www.haskell.org/ghcup/ 
07:19:31 <mexonius> this?
07:19:41 <dmwit> yep
07:19:55 <mexonius> ok i'll try it now
07:20:05 <mexonius> and keep you update
07:23:13 <moet> hello.. how do i run a `Control.Monad.ExceptT e Identity a` in the context of a `Control.Monad.ExceptT e IO a`?
07:23:27 <merijn> moet: Looks like you want
07:23:30 <merijn> @hackage mmorph
07:23:30 <lambdabot> http://hackage.haskell.org/package/mmorph
07:23:45 <merijn> hoist or generalize is what you want, probably
07:24:07 <moet> ah, ok.. i was doing something weird with `mapExceptT (return . runIdentity)` but it's good to know something more general is out there
07:24:13 <moet> i'll check out mmorph .. ty
07:24:16 <dmwit> moet: I recommend modifying the implementation of your ExceptT e Identity a action so that it is polymorphic over the contained monad.
07:24:39 <merijn> That also works, but only if you wrote that action :)
07:24:40 <dmwit> moet: This is usually possible by simply replacing explicit errors with the polymorphic `throwError` and explicit successes with the polymorphic `pure` or `return`.
07:25:03 <merijn> If the offending code is in a dependency mmorph is a good solution
07:25:43 <moet> the existing code is written by me, and it's written in an `Except e a` which hardcodes  `ExceptT e Identity a` unfortunately
07:26:27 <dmwit> moet: If it's written by you, and you agree it's unfortunate, why not fix it?
07:26:41 <moet> i might
07:26:59 <moet> but it's kind of weird that Except is defined in the same module as ExceptT, but doesn't "play well" with it
07:27:30 <dmwit> :t either throwError pure . runExcept
07:27:33 <lambdabot> MonadError e m => Except e a -> m a
07:29:13 <moet> hmm, that's much nicer than the mapExceptT that i pasted above
07:29:34 <aoeu256> (newbie here) How do you debug pure functions quickly, other than decomposing the functions into little functions and checking the outputs?
07:30:02 <mexonius> ok folks! i'll execute it, and copied the export line into the .bashrc file. so now all it's done?
07:31:06 <merijn> @quote refreshing.desert
07:31:06 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:31:10 <merijn> aoeu256: ^^ that
07:31:21 <merijn> aoeu256: Debug.Trace is the module you want
07:31:44 <dminuoso> aoeu256: Another good technique is actually decomposing the functions and writing *tests* for them.
07:31:45 <merijn> aoeu256: ghci also has a debugger, but it's...something
07:31:56 <dminuoso> And then training yourself to write tests while you write complex functions.
07:32:17 <merijn> @quote cmccann stream.of
07:32:17 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
07:35:22 <Taneb> Does GHC or cabal have a way to emit a graphviz graph of the modules in a package and what imports what?
07:36:08 <Ariakenom> looks to be lots of new folk? people having some time to spend during summer perhaps. That's great!
07:49:30 <aoeu256> Thanks guys!
07:57:10 <dmwit> Taneb: https://hackage.haskell.org/package/graphmod
07:58:24 <Taneb> dmwit: ah, thanks, that's exactly what I was looking for
08:03:09 <merijn> Whoo! "It's discover crucial bug right after release onto Hackage"-o'clock
08:03:37 <ski> dmwit : hm, i showed you which trick ?
08:04:21 <dmwit> ski: Hijacking Left to be used not as an error, but as a successful (but early) exit.
08:04:37 <ski> oh
08:05:08 <ski> what's the difference between an exception, and an early ("succesful") exit ?
08:05:23 <hvim> Hello. What if in a do block I have a case expersion and I need to do 2 in one case. For example if I have to update the State monads state and also recurse into the next iteration. How am I to do that can one case execute more than one experssion? Eample: case a of { b -> "more than one experssion"} ? 
08:06:14 <ski> hvim : just put another `do'-expression in the branch of the `case' ?
08:06:37 <dmwit> ski: It is a difference in intent only, not in computational power.
08:06:49 <dmwit> s/power/content/ maybe
08:06:52 <ski> but if all branches end in the same way, you can probably pull that out and put it after the `case'
08:07:11 <ski> dmwit : i suppose
08:07:40 <ski> (does it show that i don't believe in "exceptions are for exceptional cases" ?)
08:09:05 <mantasg> Hi Haskellers. I'm trying to combine two Conduits into one in a zip like manner: ConduitM i o1 m r -> ConduitM i o2 m r -> ConduitM i (o1, 02) m r
08:09:22 <mantasg> Did anyone succeeded in doing that?
08:10:51 <bitonic> mantasg: `zipConduit c1 c2 = await >>= 
08:10:54 <bitonic> oops
08:11:18 <hvim> ski: thanks that helps.
08:12:00 <bitonic> https://www.irccloud.com/pastebin/zzZss08x/
08:12:07 <bitonic> mantasg: something like the above?
08:12:21 <bitonic> not sure if a combinator exists
08:14:17 <mantasg> bitonic, certainly looks promising. I will give it a go. Thanks!
08:15:21 <bitonic> mantasg: actually sorry, that makes no sense at all :P
08:16:15 <bitonic> mantasg: this looks like what you want: http://hackage.haskell.org/package/conduit-1.3.1.1/docs/Data-Conduit-Internal.html#v:zipSources
08:16:34 <AWizzArd> I `import qualified Data.Map.Strict as M` and run `M.insertWith (+) eventWeek 1 frequencyMap` – is this all strict?
08:18:51 <lavalike> what's strict is the map values are not thunks, they are evaluated
08:19:02 <mantasg> bitonic, zipSources in Data.Conduit.Internal seems to only work with Sources (i.e. ConduitM () a m r)
08:19:09 <lavalike> (by the strict version of insertWith you used there)
08:22:40 <bitonic> mantasg: then I _think_ that `getZipConduit ((,) <$> ZipConduit conduit1 <*> ZipConduit conduit2)` might do the trick, although I'm not very  confident about it
08:22:42 * bitonic goes to try
08:24:12 <bitonic> nope, that does something different again
08:24:32 <mantasg> Yeah, it fuses return value, not the output
08:24:39 <bitonic> right
08:26:10 <mantasg> Basically the whole reason I'm doing that is because of conduitParserEither in https://hackage.haskell.org/package/conduit-extra-1.3.4/docs/Data-Conduit-Attoparsec.html not giving very good error reporting
08:26:51 <mantasg> So I just kind of want to fork it into conduitParserEither and identity and merge their output into tuple 
08:27:30 <mantasg> So I have both useless error reported by attoparsec and the actual data that caused it
08:28:20 <bitonic> mantasg: I'm not sure that works though. The conduit there is free to break down or buffer the chunks of data it gets as much as it likes, or in other words there is no real relations between the number of input and outputs. If I understand what you are asking anyway
08:29:09 <mantasg> Well yeah, I think I understand that
08:29:29 <mantasg> But in my case any amount of data is more useful than nothing
08:29:57 <bitonic> mantasg: well, you could just save the last chunk of data sent out to the conduit, that ought to be pretty easy. Or just buffer the data sent so far
08:30:44 <bitonic> e.g. you can have a passthrough conduit buffering the data in a mutable reference, or wrap everything in a state monad
08:31:04 <mantasg> I was thinking about that, but was really hoping there's some nice way using pure conduit combinators
08:31:20 <Philonous> I'm wondering how this hypothetical zipConduit should work. Suppose you have a Conduit A that produces one output for every 10 input it reads and another Conduit B that produces one output for each input. Would you pair the first output of A with the first output of B, then the second output of A with the second output of B? Even though they are at different "positions" in the input? Also, how do you deal with the ever-increasing stream of 
08:31:21 <Philonous> inputs you need to keep in memory because B is "lagging behind" ?
08:33:39 <mantasg> Well that certainly wouldn't work in general case
08:33:54 <mantasg> But could there be some kind of Conduit wrapper
08:34:23 <mantasg> ... that would run underlying conduit and zip its output value with some extra data?
08:53:57 <mantasg> I think I can get it working with peeking the value and then composing conduitParserEither with other conduit that I pass that peeked value to
08:57:58 <wroathe> Say I've got a bunch of functions of type a -> f a, how would I go about composing them together?
08:59:12 <chreekat> wroathe: depends on the f :) `<=<` works for monads
08:59:35 <wroathe> a -> IO a
09:00:14 <wroathe> Oh, perfect
09:00:19 <wroathe> That'll work just fine. Thanks.
09:03:09 <chreekat> Np, <=< is one of my favorite things
09:15:45 <infinisil> % :t (<=<)
09:15:45 <yahb> infinisil: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:16:14 <infinisil> Ah it's like a monadic (.)
09:18:42 <infinisil> Or the same as (<<<) with the kleisli arrow
09:22:42 <Zer0xp> Hey guys, if I wanted to build a rotating cube, which packages would I require to use to write a program in Haskell ?
09:23:17 <Zer0xp> It should be a very simple cube, black lines, completely transaparent in a white background.
09:23:53 <EvanR> you could use SDL and OpenGL
09:24:32 <EvanR> or GLFW and OpenGL
09:27:18 <moet> there's also https://tobbebex.blogspot.com/2015/09/gpipe-is-dead-long-live-gpipe.html Zer0xp 
09:27:31 * ski idly wonders why inverted colors
09:28:33 <moet> which somebody actually implemented quake with https://github.com/csabahruska/gpipe-quake3
09:29:25 <moet> hey, i have a question about using applicative .. the answer might be "use a monad"
09:29:29 <moet> :t ((,) <$> return <*> return)
09:29:31 <lambdabot> (Monad m1, Monad m2) => a -> (m1 a, m2 a)
09:29:41 <moet> how can i get the m's outside the (,) ?
09:29:46 <moet> they're the same m
09:30:11 <ski> @type pure . join (,)
09:30:15 <lambdabot> Applicative f => a -> f (a, a)
09:30:56 <EvanR> gpipe looks great at first glance
09:32:05 <moet> ski: that looks like the right type, except now i'm wondering where i put my "returns" .. (actually two different operations)
09:32:15 <ski> oh, you didn't say that
09:32:26 <moet> :heh: yeah, poorly specified question
09:32:45 <AWizzArd> I have a memory leak and wonder which is the best way to detect *where* it is. I have just those three lines of code:
09:32:49 <AWizzArd> let !events = computeEvents accumulatedEvents currentRealtimeWeek prevRealtimeWeek
09:32:50 <ski> so .. what is it that you actually want to reexpress, then ?
09:32:56 <AWizzArd> let !debug = ("Row 1: " ++ show serialnum ++ "/" ++ show (length events))
09:33:04 <AWizzArd> liftIO $ putStrLn debug >> hFlush stdout
09:33:12 <AWizzArd> And when the program runs I see this output:   Row 1: 1264/
09:33:22 <AWizzArd> Does this indicate that the leak is in `computeEvents`?
09:33:55 <moet> :t \x -> do { a <- return x; b <- return x; return (a, b) } -- ski, i'm doing two different operations where the first two `returns` are.. i'm wondering if this can be made applicative
09:33:57 <lambdabot> Monad m => b -> m (b, b)
09:34:07 <moet> (mainly because i don't know applicative)
09:34:45 <ski> so, you're asking about `(,) <$> foo <*> bar', for two operations `foo' and `bar' ?
09:34:57 <moet> EvanR: I know the dev if you have feedback i'm sure he'd be happy to start working on it again .. he just kind of stopped but i think he's still really interested in it
09:35:17 <moet> ski: yes, that's what i think i'm asking about.. but it didn't seem to work
09:35:32 <ski> you can always say `\x -> liftA2 (,) (foo x) (bar x)', of course. and then that is the same as `liftA2 (,) <$> foo <*> bar'
09:35:44 <ClaudiusMaximus> you could try to see if -XApplicativeDo works (maybe need to replace return with pure)
09:36:07 <ski> yea, that could also work
09:36:33 <ski> (it's not totally clear whether you're looking for a pointless way to do it, or if any way would be fine)
09:36:41 <cyris212> Does someone have a good example on how to parse JSON into a mixed type using Aeson?
09:37:37 <moet> i think lift2A is what i want, but again, i'm really not familiar with applicative. maybe this will help me to understand it. thanks!
09:37:47 <cyris212> I would like to parse `data State = Unscheduled | Scheduled UTCTime` and I don't get how to do it.
09:38:18 <ClaudiusMaximus> AWizzArd: try heap profiling to see what is taking up the space
09:39:14 <ski> moet : well, there's two idioms there. one is whatever idiom `foo' and `bar' are actions of. the other is environment, which often can just feel like gymnastics without a point (at least if overdone)
09:39:34 <AWizzArd> ClaudiusMaximus: are there graphical tools for that?
09:40:24 <ski> moet : oh, and `\x -> liftA2 (,) (foo x) (bar x)' is also the same as `\x -> (,) <$> foo x <*> bar x' .. but then that's harder to make pointless
09:40:48 <ClaudiusMaximus> AWizzArd: yes, heap profiles .hp are text files, there are various tools for generating graphs (hp2ps bundled with ghc, hp2pretty (which i wrote) generates SVG, others generate zoomable web api stuff iirc)
09:40:59 <ski> moet : but if you don't care for making it pointless, that might be considered more readable than, or as readable as, the `\x -> liftA2 (,) (foo x) (bar x)' version
09:41:54 <ClaudiusMaximus> AWizzArd: https://downloads.haskell.org/~ghc/8.6.5/docs/html/users_guide/profiling.html#rts-options-heap-prof
09:42:35 <AWizzArd> ClaudiusMaximus: okay thanks, will have a look!
09:42:36 <moet> i kind of like pointless (as it were) style, though it is sometimes a time sink
09:43:24 <moet> ilike the liftA2 definition because it makes clear that this is a construction operation that's composed of other smaller operations on an existing datum
09:43:31 <EvanR> hopefully pointless isn't like mountain hiking, every second you spend writing it takes a second for someone to decode it later
09:45:26 <moet> EvanR: i use it mainly so that i can write sequences of operations that read left to right using >>= and >=> and .> (reversed composition operator) and sometimes & (feeding inputs in)
09:46:02 <ski> EvanR : writing mountain hiking .. huh ?
09:46:17 <EvanR> every step you take uphill means a step back down
09:46:17 <moet> you can do all the same with =<< <=< . $ etc, which seems to be preferred, but then mixing right-to-left order with DO syntax makes things a pain
09:46:26 <ski> oh
09:46:30 <EvanR> yeah i have found that is counterculture in haskell to do everything left to right
09:47:07 <moet> but do notation is (in my mind) left-to-right .. 
09:47:12 * ski was wondering whether EvanR meant leaving cryptic messages for later travellers at a campsite, or summit, or something
09:47:16 <moet> so mixing R2L and L2R seems unavoidable :P
09:47:21 <EvanR> haha
09:47:46 <EvanR> do notation is like another universe you temporarily step int
09:47:50 * ski idly recalls doing that, once
09:48:26 <moet> yeah, i'd rather peel away the syntax as much as possible and go back to plain old functions
09:48:33 <moet> (the do syntax)
09:48:46 <moet> mainly because i don't like introducing names that are only used once
09:48:49 <ski> `do' is like `let'
09:49:21 <ski> (in my reflective syntax sketch thing, `do' basically *is* `let')
09:49:39 <moet> right, but you don't `let` where you can simply (.) usually... i feel i shouldn't `do` where i can <=< or something
09:50:03 <ski> you'll have to decide, on a case-by-case basis, imho
09:50:28 <ski> (there are perhaps some more general guidelines which could be drawn)
09:50:39 <EvanR> variables defined then used once, at which point you must predict whether they will always be used once
09:51:15 <ski> hmm, perhaps we should invent linear scope. where a linearly scoped variable can only be used once
09:51:37 <ski> if you use it, then any shadowed identifier will come back into scope !
09:51:51 <EvanR> oh god
09:52:03 <ski> would make for great obfuscated code ;)
09:52:37 <moet> please no
09:52:39 <moet> lol
09:53:04 <moet> -Wall and never shadow lol
09:53:16 <Ariakenom> let x = _ in let x = _ ... in x x x x x
09:53:22 <ski> right
09:53:53 <ski> i think it's fairly common in OCaml to shadow, with `let foo = ... in let foo = ... in ...'
09:54:09 <ski> and in Haskell, we have `do foo <- ...; foo <- ...; ...'
09:54:45 <ski> (but we have better support for stateful effects, so that's probably not as common)
09:55:56 <hyperisco> ski, I adore that idea
09:56:24 <hyperisco> except it becomes impossible to duplicate anything
09:57:05 <AWizzArd> Is it, in principle, possible, to resolve memory leaks via the use of traceShow?
09:57:25 <hyperisco> maybe a strict limit of 2 uses
09:57:45 <ski> hyperisco : i didn't say every variable would have linear scope
09:58:06 <hyperisco> misery must be enforced
09:58:14 <EvanR> if you had a limit of 2, that effectively restores your full power
09:58:33 <EvanR> except for the ability to use it zero times
09:59:08 <hyperisco> okay, zero, once, or twice, then it is out of scope :P
09:59:38 <hyperisco> does the scope change left-to-right and top-to-bottom or how does that work? lol
09:59:50 <moet> i hope this inspires some great research, but never makes it into the language .. i can't think of a practical use case other than, as mentioned above, obfuscating perfectly good code
09:59:56 <Ariakenom> let (x,x) = x in -- one use but 4 bindings so 2*6-1 left?
10:00:23 <EvanR> i'm going to veto hyperisco's idea
10:00:31 <ski> hyperisco : let's say that `x : T' can (must) be used one time, but that `{x} : [m .. n] T' can be used any number of times inbetween `m' and `n'
10:00:54 <Ariakenom> eh 2*3-1
10:00:57 <hyperisco> oh there we go, generalised
10:02:09 <hyperisco> linear typing gone wrong
10:02:37 <nil> Girard would be proud
10:02:41 * ski . o O ( "Linear Types can Change the World" -- Wadler )
10:02:54 <hyperisco> the fun is that there would be no error for using a variable the wrong number of times
10:02:58 <hyperisco> there would only be out of scope errors! :P
10:03:22 <lauraaaah> Hi
10:03:34 <ski> hello lauraaaah
10:03:48 <hyperisco> ah well I guess if you use a variable less than the minimum amount that would be a use error
10:03:54 <lauraaaah> :)
10:04:45 <ski> lauraaaah : if you have any (Haskell-related) question(s), feel free to ask
10:04:53 <dmwit> % data Foo a = Foo; instance Monad Foo where m >>= f = Foo @b
10:04:53 <yahb> dmwit: ; <interactive>:36:59: error: Not in scope: type variable `b'
10:05:20 <lauraaaah> Thanx, tho I'd better Google what it is first lol
10:05:35 <dmwit> Can I access a type variable from a class method's declaration somehow?
10:05:37 <ski> lauraaaah : there are links in the topic of this channel
10:05:59 <hyperisco> dmwit, you can put the type sig in the instance… might require an extension
10:06:03 <dmwit> % data Foo a = Foo; instance Monad Foo where (>>=) :: forall a b. Foo a -> (a -> Foo b) -> Foo b; m >>= f = Foo @b
10:06:03 <yahb> dmwit: ; <interactive>:37:53: error:; * Illegal type signature in instance declaration: (>>=) :: forall a b. Foo a -> (a -> Foo b) -> Foo b; (Use InstanceSigs to allow this); * In the instance declaration for `Monad Foo'
10:06:04 <ski> dmwit : try `InstanceSigs' and `ScopedTypeVariables' ?
10:06:12 <dmwit> % :set -XInstanceSigs
10:06:12 <yahb> dmwit: 
10:06:15 <dmwit> % data Foo a = Foo; instance Monad Foo where (>>=) :: forall a b. Foo a -> (a -> Foo b) -> Foo b; m >>= f = Foo @b
10:06:15 <yahb> dmwit: ; <interactive>:39:28: error:; * No instance for (Applicative Foo) arising from the superclasses of an instance declaration; * In the instance declaration for `Monad Foo'
10:06:22 <dmwit> Nice, thanks!
10:06:23 <lauraaaah> Oh programming 
10:06:28 <lauraaaah> Nope
10:06:29 <hyperisco> the other way is by using a proxy
10:06:46 <dmwit> Using a proxy requires changing the class, though?
10:06:50 <hyperisco> yes
10:06:50 <dminuoso> dmwit: Yes.
10:06:54 <dmwit> (Not objecting, just checking that I understand.)
10:06:56 <ski> lauraaaah : if there's some other topic you'd prefer, perhaps we could point you in the right direction ..
10:07:14 <lauraaaah>  Not done any programming in yeeears
10:07:25 <ski> time to start again ?
10:07:35 <lauraaaah> 😖
10:07:38 <dminuoso> dmwit: Just be aware that whether a type variable is quantified or a skolem is not very obvious in instance sigs.
10:07:50 <dminuoso> (In case you trip into strange type unification bugs down the road
10:07:51 <lauraaaah> I think uni put me off programming:|
10:08:01 <lauraaaah> I should probably leave it in the past lol 
10:08:05 <ski> yea, uni courses can be bad
10:08:14 <ski> especially if there's too much Java
10:08:34 <lauraaaah> Yea was java and c++mostly. But that was q long time ago now.
10:08:35 <Lycurgus> and you think haskell will put you back on it?
10:09:01 <lauraaaah> No.. I'd never heard of Haskell before
10:09:07 <Lycurgus> ah
10:09:12 <dminuoso> Im guessing lauraaaah somehow discovered this channel by some list displaying the most popular channels on freenode.
10:09:12 <ski> lauraaaah : Haskell will probably be much more fun than those :)
10:09:15 <Lycurgus> it's super hard
10:09:28 <dminuoso> And strangely #haskell is one of the most popular channels on freenode.
10:09:36 <dminuoso> Despite having a less than 1% stake of programming languages in the world. :)
10:09:44 <ski> dminuoso : sounds likely
10:10:04 <moet> stake measured by ..?
10:10:26 <EvanR> chat is cheap, code is not
10:10:50 <Lycurgus> lauraaaah, fun like in solving integro differential equations
10:10:56 <dminuoso> EvanR: We could be having smalltalk and be productive at the same time.
10:11:05 <ski> dminuoso : well, i suppose we do try to make it a friendly environment, conducive to learning
10:11:13 <lauraaaah> I think I'll leave that to all of u
10:11:15 <Lycurgus> which prolly most here would consider fun
10:11:27 <dminuoso> lauraaaah: Feel free to hang around. Perhaps you might generate some interest. :)
10:12:06 <ski> Lycurgus : i'm not that thrilled about analysis, actually :)
10:12:12 <Lycurgus> :)
10:12:21 <ski> (to each their own)
10:12:51 * ski . o O ( Max Stirner )
10:13:05 <Lycurgus> stochastic integro differential equations underly many natural phenomena
10:13:33 <Lycurgus> i was recently think of Max Stirner vs what ... ?
10:13:44 <Lycurgus> oh yeah
10:14:15 <Lycurgus> the wikipedia Employment Contract article which some were claiming was heutzutagige Anarchisten
11:30:25 <Boarders> does anyone know how I add a link in haddock? (not internally to a definition but to a website)
11:31:08 <cocreature> Boarders: look at the cheatsheet on https://hackage.haskell.org/package/haddock
11:31:22 <Boarders> thanks
11:31:25 <Boarders> that is useful
11:32:32 <cocreature> Boarders: if you’re looking for more detailed documentation make sure you end up on the new RST based docs https://haskell-haddock.readthedocs.io/en/latest/index.html instead of the old one which still hangs around
11:32:53 <Boarders> cocreature: thanks very much!
11:33:28 <dmj`> does it make sense that `Proxy :: Proxy a` would work, but `Proxy @ a` wouldn't in a certain function
11:33:54 <dmj`> think this is another type applications bug
11:34:33 <dmj`> https://gist.github.com/dmjio/2e30fc47758a3f55a4391a0c6ce33908
11:35:11 <Boarders> interesting, what error do you get?
11:36:05 <glguy> dmj`: (Proxy @Type @API)
11:37:48 <dmj`> glguy: whaaat 
11:38:22 <dmj`> there is another implicit forall in there for specifying the kind ?
11:38:24 <cocreature> % :t +v Proxy
11:38:32 <glguy> dmj`: You declared it as: data Proxy (a :: o) = Proxy
11:38:40 <Boarders> I guess polykinded types do that
11:38:45 <dmj`> glguy: omg
11:38:47 <glguy> The explicit kind variables pop out first
11:38:53 <cocreature> huh what happened to the bot
11:38:56 <Boarders> since when could we do kind applications like that?
11:39:30 <dmj`> glguy: never would have caught that in a million years
11:39:48 <dmj`> glguy: but now I know kind applications come first 
11:39:55 <dmj`> huge
11:40:15 <glguy> dmj`: spoiler, I ran this in GHCi to get a hint about what was happening: :t (Proxy @API :: Proxy API)
11:41:30 <ski> cocreature : seems to move out of phase, now and then
11:41:32 <wroathe> https://github.com/kowainik/co-log
11:41:56 <wroathe> "Composable contravariant combinatorial comonadic configurable convenient logging component" D_:
11:42:02 <wroathe> Just why
11:42:26 <cocreature> wroathe: because someone likes words starting with “co”
11:42:43 <ski> CCCCCCLC, that's DCLC, or 650
11:42:44 <EvanR> should have been about cologging
11:43:49 <ski> (the dual is "Mposable ntravariant mbinational monadic nfigurable nvenient cologging mponent" ?)
11:53:05 <EvanR> MNMMNNCM
12:06:01 <[exa]> wroathe: made a less dual variant foy you-- mposable ntravariant mbinatorial monadic nfigurable nvenient cologging mponent
12:06:26 <[exa]> oh, /me too late
12:06:58 * ski smiles
12:07:00 <ski> you're welcome
12:07:27 <[exa]> the cojokes are so ntraproductive
12:09:44 <kuribas> why does the assembler output contain no calls
12:09:45 <kuribas> ?
12:09:51 <kuribas> but only jumps?
12:10:09 <merijn> kuribas: For (GHC) Haskell you mean?
12:10:13 <kuribas> merijn: yeah
12:10:17 <[exa]> kuribas: calls are jumps
12:10:23 <merijn> kuribas: Because GHC doesn't use a function call stack
12:10:29 <merijn> kuribas: So there's no point in using call
12:10:37 <kuribas> merijn: where does it store the return?
12:10:46 <merijn> kuribas: It doesn't, because they never return
12:10:49 <[exa]> kuribas: it is passed by CPS thing
12:10:52 <merijn> kuribas: *mind blown*
12:11:20 <kuribas> in CPS the continuation is the return...
12:11:35 <[exa]> in CPS you return by calling
12:11:42 <davean> kuribas: calls are inefficient in that they specify how the call is done when often thats more than you need. Even C compilers often elide it in highly optimized parts
12:11:43 <merijn> aka more jumps
12:11:45 <[exa]> except it's tail call, which is jump
12:11:54 <davean> kuribas: No its not
12:12:00 <davean> kuribas: You could have many continuations for example
12:12:26 <kuribas> so instead of having a callstack it's creating closures?
12:12:28 <davean> and, return restores, which is not what happens with a continuation
12:12:46 <davean> a continuation enters a new context so things like old register state are not applicable
12:13:21 <[exa]> kuribas: the closures are somewhere else but basically yes, its navigating through the closures
12:13:43 <kuribas> and every closure takes an explicit continuation?
12:13:44 * ski iterates "calls are jumps"
12:14:08 <merijn> Completely unrelatedly: I forgot what the flag for GHC to return errors in reverse order was?
12:14:11 <[exa]> kuribas: there's a point in compilation where all code is CPSed
12:14:12 <davean> kuribas: not a final one.
12:14:53 <[exa]> kuribas: but that may disappear completely in assembly; much of the code gets inlined out and the closure structure mostly disappears, unless the closures get materialized on stg heap
12:15:39 <kuribas> that's pretty neat
12:15:59 <kuribas> I am trying to understand the generated assembly
12:16:19 <davean> GHC's assembly generation is pretty straight line
12:16:35 <[exa]> it is certainly different to what gets produced from C's; there the functions usually correspond to assembly calls (unless they get inlined)
12:16:38 <merijn> ANyone have a clue, I can't find it in the GHC user guide :\
12:17:03 <int-e> kuribas: you'll notice that every chunk of code ends in a jump (most of the time an indirect jump) ... that's passing control to a continuation.
12:17:19 <kuribas> int-e: right
12:17:46 <kuribas> int-e: jmp *-16(%r13)
12:18:15 <kuribas> so each closure is just there to evaluate a thunk
12:18:49 <kuribas> when the thunk is evaluated it passes the result to the continuation?
12:19:59 <kuribas> I suppose that's where lazyness is inefficient, you need to check every thunk over again to see if it's already evaluated.
12:20:11 <int-e> Yes. (But I don't know what the convention for passing the arguments is.)
12:20:25 <[exa]> kuribas: if the code decides it needs to evaluate some thunk, it just jumps to its evaluator and passes it where to continue
12:20:37 <kuribas> right
12:20:54 <[exa]> but the decisions are often left out, strictness analysis works pretty good in usual cases
12:21:49 <[exa]> you really might want to read SPJ's paper on the STG
12:24:15 <dmwit> merijn: -freverse-errors
12:24:18 <int-e> and there's pointer tagging, so you'll have code that tests whether the lowest bit of a pointer are non-zero, and only does an indirect jump (entering the closure) if they are zero; otherwise, it'll start accessing data fields of a constructor directly.
12:25:25 <[exa]> btw I remember there has been some kind of stack only for continuations (causing fun overflows with lazy scanl), is that done differently now?
12:25:33 <merijn> dmwit: Weirdly seems to not work in GHC 8.6 and no mention in the user guide either
12:25:46 <merijn> [exa]: There's a pattern match stack
12:26:03 <merijn> [exa]: Because if you pattern match on either you need to remember "what to do if Left" and "what to do if Right"
12:26:43 <dmwit> merijn: Are you using cabal? I have found that it does funny things with -freverse-errors; specifically, turning it on in cabal.project.local might not get picked up for a package until its recompilation checker discovers that package should be rebuilt.
12:27:00 <merijn> dmwit: Yeah, I would be to blame for that :)
12:27:05 <Zer0xp> If anyone here has the time, could you please explain this 80-lines of Haskell code to me ? https://pastebin.com/zPdQUbvh
12:27:17 <merijn> dmwit: But in my case my code doesn't compile so it should always run
12:27:33 <dmwit> merijn: But I'm saying when it reruns the compiler, it will rerun it *with the old flags*.
12:27:44 <dmwit> merijn: Until it decides that something in the code has changed.
12:27:58 <[exa]> Zer0xp: looks like a tiny gloss game, right?
12:28:02 <merijn> dmwit: In #ghc infinisil suggests it was, for some reason, deleted in ghc 8.4
12:28:03 <dmwit> merijn: Try deleting the appropriate subdirectory in dist (or dist-newstyle) and see if that helps.
12:28:12 <dmwit> ok!
12:28:28 <Zer0xp> [exa]: It's a cube rotation program.
12:28:28 <ski> [exa] : yes, there's still a stack (and hence tail calls still make sense). it's just that which subexpressions are reduced when an expression is reduced is a bit different than in cbv
12:29:14 <dmwit> merijn: -freverse-errors works for me in 8.6.3
12:29:16 <[exa]> oh so
12:29:44 <[exa]> Zer0xp: there's the gloss package that provides 90% of the program functionality; you might want to google it up and see some examples
12:30:00 <dmwit> merijn: in 8.4.2, too
12:30:15 <merijn> dmwit: I'll try nuking dist-newstyle
12:30:31 <merijn> Super confusing if that doesn't get picked up, though
12:30:37 <[exa]> Zer0xp: the rest are standard event handlers and a drawing tool; do you want something particular explained?
12:30:48 <dmwit> merijn: Yes, I consider it a bug in cabal.
12:30:59 <[exa]> ski: cbv?
12:31:13 <dmwit> call by value, probably
12:31:22 <[exa]> aah yes
12:31:30 <[exa]> makes sense, thanks all.
12:31:34 <hexagoxel> it works for me on 8.0, 8.2, 8.4, 8.6, 8.8
12:31:34 <Zer0xp> [exa]: Is Point a built-in Haskell type ?
12:31:45 <merijn> dmwit: No, I mean "superconfusing" in the sense of *I* wrote the cabal code that avoids triggering recompilation for superfluous flags and I don't udnerstand why it could possibly rerun with an old flag config...
12:31:49 <[exa]> Zer0xp: not built-in but it's defined by some library they import there
12:32:14 <[exa]> Zer0xp: quite possibly by Gloss
12:32:40 <dmwit> http://hackage.haskell.org/package/gloss-1.13.0.1/docs/Graphics-Gloss-Data-Point.html#t:Point
12:32:45 <merijn> dmwit: Like, cabal should either not rebuild at all, or run with the right flags. I don't know how it could ever run with an old config instead...
12:33:17 <dmwit> merijn: If we're running elections for tracking down the problem, I vote for you.
12:33:32 <merijn> dmwit: I'm already 20 yaks in >.>
12:33:44 * dmwit nods in sympathy
12:33:46 <merijn> On the bright side, nuking dist-newstyle has fixed it
12:34:07 <dmwit> told ya =)
12:34:13 <hexagoxel> did you nuke your reproduction case? beginner mistake
12:34:14 <hexagoxel> :p
12:34:23 <dmwit> It's very easy to repro.
12:34:43 <dmwit> Make any package with two errors, turn on -freverse-errors in your cabal.project.local, and you're off.
12:34:59 <Zer0xp> [exa]: You're right, it's defined in Gloss.
12:35:01 <dmwit> (Or if it was already on, turn it off.)
12:35:33 <[exa]> Zer0xp: much of library stuff can be found on hoogle btw; if you didn't use it yet, you want to try :]
12:35:53 <[exa]> Zer0xp: see https://hoogle.haskell.org/?hoogle=play&scope=set%3Astackage
12:36:38 <Zer0xp> [exa]: Oh cool, thanks.
12:38:08 <infinisil> I wish more Haskell libraries annotated their functions with time and space complexity
12:38:22 <merijn> infinisil: That's frequently not really possible, though
12:38:44 <infinisil> Well, maybe not exact, but even a general idea of "Is this function horribly inefficient or not?" would be nice
12:38:45 <Athas> I just found some Haskell code where the entire module body is indended (after 'where').  I didn't even know that was allowed.  Have any of you seen that style before?
12:39:09 <Athas> infinisil: what is the complexity of 'cycle'?
12:39:22 <merijn> Athas: No, but I'm frequently conflicted between "that is obviously the right way to indentic systematically" and "oh god, that's ugly and inconvenient"
12:39:54 <infinisil> Athas: Well it doesn't make sense for that particular function
12:39:59 <Athas> merijn: maybe it's a case of conspicuous consumption!  Wealthy people with wide monitors who can afford to just throw four columns in the trash.
12:40:24 <Athas> infinisil: it makes sense for relatively few functions once laziness is involved.
12:40:34 <Athas> Of course, the insiduous thing is that very often, we don't actually use that laziness.
12:40:53 <ski> Athas : i always do that (except if i'm leaving out the `module ... where' part)
12:40:55 <infinisil> Hm, I guess that's one point for strict languages
12:41:04 <Athas> ski: really?  Why?
12:41:08 <ski> consistency
12:41:36 <dada_cetacean> is there a function "succeeds m" which returns true iff the monadic computation m succeeds?
12:41:55 <Athas> dada_cetacean: m >> return True
12:42:11 <ski> dada_cetacean : "succeeds" meaning ?
12:42:31 <dada_cetacean> doesn't fail
12:42:46 <hexagoxel> "fail" meaning?
12:42:49 <ski> not all monadic computations are of a type which allows failure
12:42:50 <oats> I don't think there's a universal way to determine whether a monadic computation has succeeded or not
12:43:06 <dada_cetacean> hexagoxel, uh... succeeds? :^)
12:43:11 <ski> presumably "failure" suggests `MonadPlus' ?
12:43:12 <dada_cetacean> uh, not succeeds*
12:43:23 <monochrom> Maybe don't make it a generalized question. Which specific monad is it?
12:43:33 <dada_cetacean> let's say IO
12:43:50 <dada_cetacean> well i guess i can't leave the IO monad, so any bool would have to be wrapped in IO
12:43:53 <ski> oh, then it's less clear what "failure" means
12:43:54 <[exa]> dada_cetacean: how do you recognize it has failed?
12:44:26 * ski was going to suggest `optional', if dada_cetacean was fine with `Alternative', rather than `MonadPlus'
12:44:32 <hexagoxel> "well, you recognize it by checking whether it succeeds, an inverting the result"
12:44:48 <dada_cetacean> uh, let's say P fails if P <|> Q always runs Q
12:45:00 <ski> hexagoxel : hm, now you're reminding me of `LogicT'
12:45:15 <monochrom> Then build upon what Athas said?
12:45:33 <monochrom> (m >> return True) <|> return False
12:45:40 <ski> also
12:45:42 <ski> @wiki MonadPlus reform proposal
12:45:42 <lambdabot> https://wiki.haskell.org/MonadPlus_reform_proposal
12:45:59 <ski> monochrom : or with `Maybe'
12:46:03 <ski> @hoogle optional
12:46:04 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
12:46:04 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
12:46:04 <lambdabot> Text.Parsec optional :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m ()
12:53:40 <Athas> Cool, IO has MonadPlus and Alternative instances now!
12:54:34 <ski> i don't think they're particularly cool
12:54:38 <Athas> And has had for three years, apparently.
12:54:57 <ski> (hm, feels like it would have been longer ..)
12:55:33 <Athas> It's a natural instance, I feel.  It does exactly what you'd expect.
12:57:37 <ski> hm, perhaps it would be more reasonable to have a `MonadPlus' instance for something that's equivalent to `ReaderT exn IO', given `Exception exn' ?
12:58:03 <ski> discarding whatever exception you get doesn't seem so natural, to me
13:04:19 <untseac> hey
13:04:56 <untseac> what's the easiest way of reading two integers like so "123 678"? With a parser or just using something else will do?
13:05:27 <untseac> I managed to hack around with 'read' but that's kind of clunky
13:05:51 <infinisil> > read <$> words "123 678" :: [Int]
13:05:54 <lambdabot>  [123,678]
13:06:09 <untseac> oh ok, that's better than what I did
13:06:13 <untseac> thx
13:06:23 <infinisil> (note that this will crash if it can't parse it)
13:06:29 <ski> > (`runStateT` "123 678") (replicateM 2 (StateT (reads :: ReadS Integer)))
13:06:33 <lambdabot>  [([123,678],"")]
13:07:05 <untseac> crashing isn't really a problem. It's just to learn so.
13:07:38 <untseac> that one with state is interesting. I'll have to investigate
13:07:45 <untseac> thanks
13:10:14 <untseac> either way from what I gather either splitting and reading or using a "scanner" (which will give the parsed thing and the remainder of the string) are the two ways to do it right? parsec uses the later?
13:10:15 <infinisil> And with megaparsec, it would be "decimal `sepBy` space1"
13:11:04 <untseac> megaparsec? is that the latest and greatest parsec lib?
13:11:34 <lavalike> it's like parsec, but MEGA
13:11:40 <ocharles> How do I use cabal with GHC 8.9 (HEAD)?
13:11:44 <infinisil> Eh, these parser combinators libraries work pretty much all the same, it's probably also decimal `sepBy` space1  in parsec
13:11:45 <merijn> It's like parsec, but actively developed :p
13:11:52 <ocharles> "Warning: Unknown/unsupported 'ghc' version detected (Cabal 2.4.1.0 supports 'ghc' version < 8.7)"
13:12:08 <merijn> ocharles: Probably by using cabal 3.0 from git?
13:12:21 <infinisil> untseac: An alternative to parsing that would be to write a recursive function that takes one character at a time
13:12:32 <ocharles> URGH
13:12:36 <untseac> meaning megaparsec is the decent version. that's good to know
13:13:05 <merijn> untseac: basically, parsec has been in "bare minimum maintenance" mode for over a decade now
13:13:16 <infinisil> merijn: I don't like how you can't really use arbitrary list-like things as streams in megaparsec though (without significant pain)
13:13:21 <lavalike> it it works don't fix it >:)
13:13:25 <merijn> untseac: And parts of the API conflict with modern Haskell (i.e. some combinators conflict with Alternative, etc.)
13:13:40 <ocharles> oh wait, it does work, it's just rejecting my `base` version
13:14:19 <untseac> bah sometimes haskell has such weird quirks lol. still the best language I've found so far.
13:14:33 <merijn> untseac: megaparsec started as a fork of parsec with the combinators/API update to just use/re-export various combinators from Alternative, etc. since then it's gotten some more features/improvements (and dropped some awkward confusing parts of the API, i.e. the operators parsing stuff)
13:14:53 <untseac> infinisil, yeah that's one option. character by character is painful though :|
13:14:56 <vaibhavsagar> ocharles: `dontCheck` 4 lyf
13:15:04 <merijn> untseac: So parsec is fine for existing parsec code, but I would recommend megaparsec for any new parser code
13:15:12 <vaibhavsagar> actually, `doJailbreak`
13:15:27 <infinisil> untseac: Would probably be a good exercise for writing a recursive function though :)
13:15:47 <untseac> infinisil, true. maybe I'll give it a try just because
13:16:04 <untseac> anyway I got my answer and more useful info. thanks.
13:16:13 <infinisil> Hm, there's also attoparsec
13:16:17 <infinisil> Never looked into that one
13:16:23 <infinisil> But it seems to be even more popular than megaparserc
13:16:51 <merijn> attoparsec is a different use case, though
13:16:55 <untseac> megaparsec is a better name :D
13:16:59 <Cale> attoparsec is good for applications where a human isn't usually going to be looking at the parse errors
13:17:02 <merijn> attoparsec was designed for "speed > error messages"
13:17:31 <Cale> Also, it has symmetric choice, which is nice.
13:17:33 <merijn> So it's good for network protocols, file formats, etc. as long as you never show parse errors to users just "corrupt file" or "protocol error"
13:17:59 <merijn> megaparsec is intended for "human writable input" (i.e. "human readable parse errors")
13:18:05 <gaze__> Hey y'all, if you wanted a quick and robust route to having a parser that can be used to sorta... grok a config file and edit various settings inside it while retaining formatting and comments and everything, how might you do that?
13:18:14 <infinisil> Gotcha, so I'll probably stick with megaparsec unless I gotta go fast
13:18:37 <merijn> infinisil: tbh, megaparsec has been catching up with attoparsec's performance, so... :p
13:18:37 <gaze__> I was here yesterday asking about reversable parsers... I'm wondering if there's a simpler route, since reversable parsers don't seem to be on very strong foundation yet 
13:18:50 <vaibhavsagar> gaze__: my impression is that you are asking for a simple solution to a very hard problem
13:19:00 <infinisil> merijn: Ahh right, the 7 update did some perf improvements, I remember that
13:19:01 <Cale> Usually unless I want to produce a parser that a human will be interacting with a lot, I default to attoparsec.
13:19:14 <gaze__> vaibhavsagar what makes this problem particularly hard?
13:19:19 <vaibhavsagar> I find attoparsec very pleasant to use
13:19:23 <Cale> (because not dealing with 'try' is really nice)
13:19:31 <vaibhavsagar> Cale: agreed
13:19:41 <infinisil> Why no need for try in attoparsec?
13:19:55 <merijn> infinisil: It always backtracks
13:19:56 <Cale> Because it always backtracks on failure
13:20:04 <infinisil> O
13:20:06 <infinisil> Oh
13:20:30 <infinisil> Hm, what's the disadvantage to that?
13:20:46 <vaibhavsagar> gaze__: what if you change a setting in a way that introduces a linebreak
13:21:06 <merijn> infinisil: Worse error messages :p
13:21:20 <vaibhavsagar> infinisil: sometimes you don't want to backtrack
13:21:21 <Cale> infinisil: Committing to a branch when input is consumed means that things can potentially be garbage collected more aggressively
13:21:29 <gaze__> vaibhavsagar What makes linebreaks more special than other characters?
13:21:37 <merijn> infinisil: Since you never commit to a certain branch of parsing, you can't really tell "what's wrong", only "nothing worked"
13:21:45 <merijn> Also the GC stuff, yes
13:21:50 <infinisil> I see, good arguments
13:21:55 <vaibhavsagar> gaze__: screws up your formatting
13:22:00 <infinisil> I think I'll stick with megaparsec, I don't mind manually try'ing
13:22:13 <infinisil> (and I'm used to megaparsec)
13:22:26 <gaze__> let's suppose you never introduce line breaks to existing lines
13:22:30 <vaibhavsagar> gaze__: try using literally any parser library, keeping track of how many spaces are in between your tokens
13:22:31 <gaze__> you only edit existing lines
13:23:15 <vaibhavsagar> it's a pain in the butt to keep track of position offsets, but you can definitely do it
13:23:32 <vaibhavsagar> then you need to update them in response to changes
13:23:55 <vaibhavsagar> IMO what makes it hard is that it's tedious and easy to get wrong
13:24:11 <gaze__> yeah that seems like exactly like what I wanna do... in other words I have a file, a parse tree, where the leaves of the parse tree contain the character extents of each leaf, and then construct a patch in the end
13:24:34 <gaze__> or alternatively I have a parser/unparser pair
13:24:44 <gaze__> where the intermediate repr is nondestructive
13:24:51 <gaze__> so unparse.parse is idempotent
13:25:05 <c_wraith> Unless something would benefit from monadic parsing, I really prefer Earley
13:25:19 <c_wraith> I hate left-factoring
13:25:45 <vaibhavsagar> c_wraith: many things benefit from monadic parsing
13:26:19 * ski nods to c_wraith
13:28:33 <[exa]> c_wraith: this is good
13:29:20 <hyperisco> The way I did it made the factoring straight-forward, or at least I figured
13:30:06 <[exa]> c_wraith: is there a way to avoid the 'mdo' there?
13:30:41 <c_wraith> only in the technical sense of "use do rec instead" :P
13:31:24 <ski> or `mfix'
13:31:43 <c_wraith> but bidirectional references to rule bindings are usually necessary, and that's what you get from mfix (or any of its sugars)
13:38:05 <monochrom> "do rec" is probably nicest.
13:47:39 <[exa]> oic it captures the recursion on purpose. the best I could do is probably working with earley's FixBind manually
13:50:59 <elated> is a combinator library for game level/map generators (tile-based in this case) a sane idea? has it been done?
13:56:23 <merijn> elated: Sane idea? Sure. Has it been done? No clue.
13:56:44 <elated> I'll have a go then :)
13:56:46 <merijn> Not sure how generic you could make it
14:02:13 <EvanR>  every data structure is a language
14:02:22 <EvanR> some better than others
14:06:46 <EvanR> strikethrough, you also need to interpret the language somehow to make use of it
15:08:37 <crestfallen> hi while trying to do ' $ cabal configure ' in a project directory I get the error clang: error: unknown argument '-no-pie' `gcc' failed in phase `C Compiler'. (Exit code: 1)            also ...
15:09:33 <crestfallen> I'm using Main.hs in the main-is:   field
15:10:26 <crestfallen> I also thought ' unknown flag ' came up in the error message on an earlier try. odd...
15:12:29 <crestfallen> so to run that command and ' cabal build ' I'm correct to be just in the project directory , right?
15:13:10 <Cale> You should be in a directory which has a .cabal file in it
15:13:21 <Cale> So yeah, probably
15:13:40 <crestfallen> Cale thanks yes I'm in such a directory
15:13:54 <crestfallen> so I'm getting that error..
15:14:03 <Cale> What platform is this?
15:14:12 <crestfallen> OSX
15:15:04 <Cale> https://github.com/tidalcycles/Tidal/issues/309 -- there's a workaround given here you might want to try
15:15:59 <crestfallen> also I have this dist directory with a build directory and an empty build directory, already. is that right? Cale
15:16:32 <crestfallen> I mean one empty build directory
15:16:47 <Cale> That's normal enough
15:16:59 <crestfallen> ok checking link thanks
15:17:04 <Cale> The dist directory is just build outputs
15:17:45 <Cale> cabal will have created it when it started trying to build, and since it failed early on, you didn't get anything interesting in there
15:17:59 <crestfallen> ok thanks
15:18:51 <Cale> Which version of ghc is it? You might just want to try a newer one if it's 8.4.x like the bug suggests
15:20:29 <crestfallen> checking
15:24:56 <crestfallen> Cale if I use stack upgrade --binary-only will that also upgrade the cabal package?
15:25:41 <crestfallen> I hope to use cabal commands and not stack .
15:27:57 <crestfallen> yeah I upgraded stack but have version 8.4.3 now
15:30:47 <crestfallen> also I tried to run ' cabal install Cabal cabal-install ' and got the same '-no-pie' error 
15:34:31 <cheater> if i have fm :: Maybe (ByteString -> IO ()), and an x :: ByteString, and I'm in an IO () do block, what's the most elegant way to run that function on x if it exists, or do nothing?
15:34:58 <lavalike> doing it while wearing a tuxedo
15:35:54 <Cale> cheater: I would just use a case expression personally
15:36:00 <Cale> But you could use for
15:37:01 <cheater> personally i was considering maybe
15:37:07 <cheater> but it's awkward
15:37:13 <cheater> i thought there might be something better
15:37:38 <Cale> :t for ?fm $ \f -> f ?x
15:37:39 <lambdabot> (Traversable t1, Applicative f, ?fm::t1 (t2 -> f b), ?x::t2) => f (t1 b)
15:38:36 <Cale> also forM etc. would work too because they've been generalised to Traversable
15:38:40 <Cale> :t forM
15:38:40 <lavalike> :t (sequence .) . (. return) . ap
15:38:42 <cheater> yeah, i appreciate that for is a more general version of maybe
15:38:43 <lambdabot> (Traversable t, Monad m, Monad t) => t (a1 -> m a2) -> a1 -> m (t a2)
15:38:43 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
15:39:01 <lavalike> >:)
15:39:14 <Cale> heh
15:39:29 <Cale> But yeah, I would honestly just write  case fm of ...
15:39:35 <Cale> and not worry about it
15:39:49 <cheater> but they would require something like..... maybe (return ()) ($ x) fm, which is awkward
15:39:52 <cheater> yeah
15:40:00 <cheater> i'll do that :)
15:47:41 <dada_cetacean> let P : a -> Bool, and let xs :: [a], what is the idiomatic way to check that there exists an element of xs on which P is true?
15:48:06 <Cale> any p xs
15:48:08 <dada_cetacean> my guess is map P, then fold boolean OR, but that's probably wrong
15:48:13 <dada_cetacean> thanks
15:48:19 <Cale> any = or . map p
15:48:32 <crestfallen> Cale sorry seems I still have ghc 8.4.3    I also ran this :  ' cabal new-install Cabal cabal-install ' and seem to have version2.2
15:49:15 <crestfallen> 8.4.3 after updating stack
16:04:04 <lavalike> :t (getAny .) . foldMap . (Any .)
16:04:08 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:04:37 <EvanR> yeesh
16:04:45 <EvanR> squint and it makes sense
16:07:55 <dmwit> % :t foldMap @Any
16:08:29 <sarahzrf> :t ala Any foldMap
16:08:35 <lambdabot> Foldable t => t Bool -> Bool
16:08:52 <Cale> crestfallen: Also see this merge request by abrar https://gitlab.haskell.org/ghc/ghc/merge_requests/1394
16:09:07 <crestfallen> thanks Cale I'm having a hell of a time
16:09:47 <Cale> (He's a coworker of mine and fixed this issue for our iOS builds to work)
16:10:01 <Cale> oh, also android apparently!
16:10:09 <Cale> It's really a clang thing
16:10:25 <crestfallen> I just added ' resolver: lts-9.0 ' to my config.yaml file   Cale
16:10:42 <crestfallen> trying to update stack now with that added
16:11:58 <Cale> okay -- I have no clue about stack, I'm afraid, never really had a chance to use it.
16:13:02 <Cale> (These days I use nix to install everything Haskell-related because that's what we use where I work, and before that I would just install GHC directly by hand.)
16:13:38 <nullnullnull> when I install haskell (ghc) on fedora, it doesnt come with the main libraries (like Network), is this normal?
16:14:15 <crestfallen> I have a debian machine. I really don't like learning haskell on mac
16:14:23 <crestfallen> debian machine as well*
16:14:26 <Cale> I don't think Network is a library that comes with ghc
16:14:48 <nullnullnull> hmmm
16:14:58 <nullnullnull> but it worked with ubuntu
16:15:17 <Cale> Which version of GHC?
16:15:24 <Cale> A long time ago, I think it was.
16:15:43 <nullnullnull> version 8.0.2
16:16:10 <nullnullnull> in fedora: it's version 8.4.4
16:16:22 <nullnullnull> so they removed it?
16:18:37 <Cale> Old versions of the 'network' package had a module called simply 'Network'
16:19:10 <nullnullnull> ah so they renamed the package right?
16:19:19 <Cale> https://hackage.haskell.org/package/network-2.6.3.6 -- it looks like this was the latest version to have it
16:20:07 <Cale> oh, no, it was actually there all the way through 2.7
16:20:21 <Cale> er, and 2.8.0.1 had Network.hs as well
16:20:24 <nullnullnull> hmm
16:20:28 <Cale> just, the docs failed to generate
16:20:48 <Cale> In 3.0, "Network" is gone, indicated by the italics
16:20:53 <Cale> https://hackage.haskell.org/package/network-3.0.0.0
16:21:04 <nullnullnull> but why it's gone? 
16:22:10 <Cale> I think it may have been deprecated for a long time
16:23:25 <Cale> Yeah, it was deprecated in network 2.7
16:25:35 <nullnullnull> I'm new to Haskell, trying to write a simple code (with sockets and network) but it should support all versions of haskell (I used only ghc to compile)
16:25:51 <nullnullnull> so I need to add packages with cabal right? for network, to support all versions of haskell
16:26:01 <Cale> https://hackage.haskell.org/package/network-3.1.0.1/docs/Network-Socket.html
16:27:44 <Cale> Network.Socket is a slightly lower-level, but much more complete interface than the Network module was. I think it's a bit of a shame to see the old Network module go honestly, as it was nice for really small dumb things, but I can see why people wouldn't like it.
16:31:52 <EvanR> go? is it gone? I see a deprecation message
16:32:12 <nullnullnull> hmm yeah, I'm confused a bit with the version changes, my code will not support all versions of haskell cuz of missing libraries
16:32:30 <hpc> whenever i deal with network stuff i still always try to get it as a Handle instead of anything else
16:32:35 <hpc> because of how handy Network was
16:32:58 <hpc> it just makes more sense to me
16:33:08 <hpc> stdin/stdout/stderr are character streams, they're Handles
16:33:16 <hpc> open files are character streams, they're Handles
16:33:28 <hpc> a network connection is a character stream, it's... not a Handle?
16:33:36 <hpc> but you can still make it one with a bunch of other rigamarole
16:33:49 <EvanR> plan 9 called
16:34:07 <EvanR> to make fun of all of us
16:40:43 <Cale> nullnullnull: To be honest, it's pretty much impossible for networking-related code to support "all versions of Haskell" given that nothing in the Haskell Report describes how networking is to take place.
16:41:54 <Cale> Also, Haskell is a much less stable language -- it's changing all the time, and unless you pin all your dependencies, it's quite hard to get old code to build.
16:42:25 <Cale> (The best tool for this at present is probably nix)
16:42:29 <hpc> alternatively, haskell is a much /more/ stable language, it just pins less stuff down for the implementations ;)
16:43:12 <EvanR> that is an interesting bit, i know ghc is supposed to be able to build one or two future versions of itself. But can you go back in time and work back to really old versions of haskell (starting from current versions)
16:43:49 <hpc> ooh
16:43:50 <EvanR> or do you need a working ML compiler from the mid 80s and start from scratch
16:43:57 <hpc> what if you started with current ghc
16:44:03 <hpc> went as far backwards as possible, then went forwards
16:44:08 <EvanR> lol
16:44:09 <hpc> and checked to see if the output was the same
16:44:29 <Cale> Also, if you wanted to try to check that GHC doesn't have a virus in it, how do?
16:44:53 <EvanR> McAfee obviously
16:45:02 <Cale> lol
16:45:30 * EvanR exits stage left
16:46:14 <turab> Nice one
16:46:16 <hpc> i kind of want to see the opinion on bootstrapping change, from being a long history that you just keep going
16:46:35 <hpc> to maintaining the full pipeline starting from... somewhere low level
16:46:45 <hpc> maybe a platform-appropriate assembler
16:48:42 <nullnullnull> yeah, thanks guys :) I will see what I can do
17:00:44 <turab> @pl \i1 x y i2 -> f i1 x y 0 0 i2
17:00:44 <lambdabot> flip flip 0 . (flip .) . flip flip 0 . (flip .) . f
17:00:48 <turab> heck
17:01:26 <turab> One day I will use something you suggest
17:09:56 <ysangkok> EvanR: did you see this? https://www.joachim-breitner.de/blog/748-Thoughts_on_bootstrapping_GHC
17:12:53 <EvanR> thanks for the link
17:13:02 <EvanR> i love craziness
17:13:22 <ysangkok> regarding the NHC approach that Breitner mentions, I installed RedHat 9 and tried that, bug I ran into problems. So I emailed rekado but he said he had given up on the approach, and he suggested to "build GHC with an older GCC". I assume he is talking about building generated C-- sources...
17:21:16 <fragamus> hi is it possible to have an array of arrays of string with varying depth of nesting? my guess is no
17:22:16 <Axman6> data ArrayOrString = Array (Vector (Either ArrayOrString String))
17:22:18 <fragamus> I can't imagine what the type would look like
17:22:31 <fragamus> oh nice
17:22:50 <crestfallen> hi I'm getting an error from line 203 ' NoBuffering '   http://sprunge.us/aaG1MG I tried to compile with and without a  'module Main where ' statement
17:23:43 <crestfallen> sorry its not lined on the paste
17:23:52 <crestfallen> its the last few lines
17:24:48 <crestfallen> this is another book example and that is the main definition
17:24:54 <hpc> redhat 9?
17:25:00 <hpc> ysangkok: is that an old quote?
17:26:09 <Axman6> crestfallen: you need to indent everything inside main
17:27:15 <Axman6> main = do\n  hSetBuffering stdout NoBuffering\n  play empty 0
17:27:32 <Axman6> that would be the usual indentation
17:27:34 <crestfallen> dang ok yeah I though that might be an printing error in book thanks hold on
17:37:04 <crestfallen> hi Axman6  I ran cabal configure build and install. shouldn't there be a red executable in the directory?
17:41:03 <crestfallen> Axman6: thanks never mind finally got it to work. gratzie!
17:59:49 <ysangkok> hpc: what do you mean? i wasn't quoting anybody. yes, i used redhat 9. if you are building ancient software, why not build on ancient OS'es? also, redhat 9 was my first distro, so it was real nostalgic :P
18:02:29 <ysangkok> yes, i could try to get gcc 3.3 running on my modern linux. oh, then it breaks because it doesn't like new glibc. then i would need two parallel glibc installations. probably something would break because i am on linux 5 and not linux 2, etc etc. too old for this shit :)
18:43:19 <jle`> fragamus: some libraries (like containers) use mutually recursive types for this kind of thing, which might be easier to work with
18:43:58 <jle`> fragamus: data Val = More Vals | Here String; type Vals = [Val]
19:03:22 <gbowen> \partall
19:17:44 <lldd> hello, i see my binary linked to libffi, but not directly to the required libraries
19:20:19 <lldd> nvm it's direct-sqlite not using system-lib by default
19:48:06 <turab> @pl \i1 x y i2 -> f i2 x y i1
19:48:06 <lambdabot> flip (flip . (flip .) . flip . flip f)
21:22:01 <___laika> does anyone have a preference or suggestion for something to replace Make as a task runner and general build tool (eg, to give me a single point of entry to both haskell and nix stuff)
21:22:36 <___laika> im looking into using shake, but it seems like it might be overkill? (the homepage suggests that if my project is simple, a Makefile will do, i just hate the Make language :) )
21:24:32 <Cale> Well, if you're using nix, then nix is your build tool usually
21:26:06 <___laika> yeah im not looking for a build tool so much as a task runner
21:26:07 <Cale> (in turn, it uses cabal to build things, but always puts their dependencies in scope ahead of time so that cabal-install never needs to solve any dependencies)
21:26:23 <___laika> by "general build tool" i more meant something to glue together cabal-install and nix for dev purposes
21:26:43 <Cale> But... nix will run cabal-install for you
21:27:10 <___laika> during development, i make extensive use of other cabal commands
21:27:14 <___laika> the repl, tests, etc
21:27:38 <Cale> Right, so what I do is I ask nix for the shell in which it would build the package I'm working on
21:27:43 <Cale> and then I use cabal from in that shell
21:27:56 <___laika> as well as doing some housekeeping tasks like updating pinned versions of nix and haskell.nix
21:27:56 <Cale> (especially ghcid -c cabal repl)
21:28:32 <___laika> https://gist.github.com/matthewess/0f9410f8d6a0f7aa4223ef9798cd21fb
21:28:39 <___laika> heres my Makefile for reference
21:28:55 <___laika> basically i dont need a build tool so much as a programmable task runner thats more friendly than make
21:29:09 <Cale> hmm
21:29:53 <Cale> I think if I wanted something along those lines, I'd probably end up just writing something using optparse-applicative
21:30:47 <___laika> thats definitely an idea...
21:30:51 <Cale> We've got the ob command in obelisk, which is like a fancy version of that
21:31:35 <___laika> maybe i'll use ob as a model to make a similar tool for a personal project :D 
21:31:36 <Cale> https://github.com/obsidiansystems/obelisk/blob/develop/lib/command/src/Obelisk/Command.hs#L88
21:32:20 <Cale> (of course, it does some stuff other than command parsing as well ;)
21:34:17 <maerwald> ___laika: why do you want to replace make?
21:34:28 <lldd> i would personally just use make
21:34:53 <maerwald> if you are just using for interesting technology, you are not solving a problem and your decision will likely turn out arbitrary
21:35:05 <maerwald> s/using/looking/
21:41:10 <___laika> id rather be able to do certain things like the prefetch rules i have defined in that makefile in a more aesthetic way
21:41:26 <___laika> im mostly looking for interesting / neat technology to satisfy my own weird desires :D 
21:41:46 <___laika> also i find the boilerplate of PHONY rules to be pretty tiresome
21:41:56 <maerwald> ok, so you are not solving a problem
21:41:57 <heatsink> I don't get what you mean by a task runner
21:42:13 <___laika> dispatching commands to the shell, more or less
21:42:25 <heatsink> If you want a makefile without the dependency-ordering feature, it sounds like a shell script to me
21:42:42 <maerwald> then you may as well check out shake if you are just looking for neat technology
21:42:56 <___laika> maerwald: ill probably do that
21:43:40 <maerwald> I haven't found it that useful in real world, because most things already have caching (cabal, docker, ...)
21:43:57 <___laika> heatsink: yeah ive thought about just putting it in a shell script as well, but i always get into an internal struggle about whether to write bash scripts for compatibility or fish scripts for my primary shell usage
21:44:06 <___laika> that makes sense
21:44:24 <___laika> ultimately, the best direction to go is probably just to implement a tool myself that fits my exact wants
21:44:34 <maerwald> bash is a great language
21:45:10 <maerwald> especially if you are not shipping your script
21:45:57 <___laika> im not a huge fan of bash, personally, mostly for syntax reasons
21:46:01 <___laika> but im also a major bash novice
21:46:13 <___laika> so maybe i just havent seen it in the right light
21:47:01 <___laika> i like how problem minded this channel is ;)
21:47:01 <heatsink> I've found shake useful for doing actual programming in my build scripts.  Even something like "partition this list of filenames into a list of .c files and a list of non-.c files" is painful in make
21:47:11 <___laika> heatsink++
21:47:14 <___laika> i think thats the main thing
21:47:29 <maerwald> that sounds like a very weak argument to me
21:47:48 <___laika> my prefetch rules are about as complex as ive ever successfully gotten a make rule to be
21:48:15 <maerwald> the additional complexity you introduce with the haskell language compared to make is unproportional to the "partition this list of filenames" problem
21:48:30 <___laika> definitely for most cases, probably
21:48:36 <maerwald> and you are making your build script harder to run
21:48:42 <maerwald> and it may just fail to compile too
21:48:44 <___laika> in personal projects i might like to have shake over make
21:55:19 <heatsink> maerwald, the benefit of shake over make has more to do with maintenance
21:55:30 <heatsink> My make-based solution to that problem would be to manually write the two lists instead of partitioning them.
21:56:20 <heatsink> Updating those lists becomes a maintenance overhead that doesn't go away
22:04:57 <maerwald> heatsink: not sure you are using all the power of make then
22:05:58 <maerwald> https://www.gnu.org/software/make/manual/html_node/Wildcard-Function.html
22:06:01 <heatsink> maerwald, if I do use all the power of make, then I have to deal with its lack of debugging facilities
22:06:23 <maerwald> debugging shake is even worse, you cannot even list available rules :P
22:06:41 <maerwald> and how does using wildcard function affect debugging?
22:08:03 <heatsink> if this function is being called inside a macro, and I want to see what its result was in one specific instance of the macro, it's hard to do that
22:08:33 <maerwald> all quite theoretical
22:09:02 <maerwald> don't overuse macros :)
22:09:13 <heatsink> What is theoretical, maerwald?
22:09:19 <heatsink> Are you telling me that the code I've written is theoretical?
22:10:21 <maerwald> no, the reasons you are preferring shake over make are more preference in my opinion, less technical
22:10:22 <maerwald> which is fine
22:10:44 <maerwald> partitioning list of filenames is fine in make
22:10:52 <maerwald> not a hard reason to pick something as powerful as shake
22:12:19 <heatsink> If you look at each problem in isolation, none of them looks compelling.
22:14:15 <maerwald> powerful technology is fun... unless you have to rely on it 
22:14:40 <heatsink> Fragile technology is worse
22:15:16 <heatsink> Getting a makefile to recompile C files when any of their header files have changed is doable, but very tricky
22:15:53 <heatsink> It's also easy to do it in a way that's almost right, and seems to work, but causes mysterious errors every few days
22:17:26 <heatsink> Getting a makefile to treat all .o files as out-of-date if you've modified CFLAGS may be doable--I haven't tried--but it's not easy
22:20:23 <heatsink> I would rather have powerful technology than fragile technology
22:53:05 <jackdk> afaik the only correct way to get proper dep tracking while compiling in make, is to make dep generation a side-effect of compilation using gcc's -MMD flag etx
23:08:17 <sicklorkin> when will i shoot myself in the foot with this `showStr :: (Show a, IsString b) => a -> b` and `showStr = fromString . show`
23:08:39 <dminuoso> sicklorkin: Very early.
23:08:46 <sicklorkin> `(str 5) <> "A" :: Text` is what i'm after..
23:09:13 <dminuoso> What is ⌜str⌝ here?
23:09:22 <sicklorkin> dminuoso: Text 
23:09:35 <sicklorkin> but it could be a ByteString 
23:09:42 <Axman6> str = showStr?
23:09:49 <sicklorkin> yes
23:09:52 <dminuoso> sicklorkin: So ⌜str :: Text⌝ ?
23:10:03 <dminuoso> Ah.
23:10:28 <dminuoso> sicklorkin: IsString has some very poor instances, honestly.
23:10:33 <sicklorkin> I'm tried of typing T.pack (show 5)
23:10:35 <dminuoso> ByteString is one particular example.
23:10:45 <Axman6> I think there's a text-show package or something
23:10:56 <Axman6> so you can at least do tshow 5
23:10:58 <dminuoso> sicklorkin: If you dont instantly see why, ask yourself what the ⌜instance IsString ByteString⌝ actually does. How is it supposed to work?
23:11:01 <Axman6> or use the formatting package
23:11:58 <dminuoso> sicklorkin: Don't get tricked into ever thinking of ByteString as strings.
23:12:55 <Axman6> but it's, like, right there in the name!
23:13:12 <dminuoso> Yeah one of the unfortunate accidents of Haskel history. :(
23:13:13 <lldd> what's wrong with bytestrings as strings?
23:13:29 <dminuoso> lldd: ByteString should have been called ByteVector.
23:13:29 <lldd> it is like a string?
23:13:38 <dminuoso> lldd: No, it's a bunch of binary data.
23:13:52 <Axman6> it it nothing than a bunch of bytes in order
23:13:52 <lldd> dminuoso: and? string is the same?
23:14:08 <dminuoso> lldd: String is something in the world of characters/codepoints/graphemes
23:14:12 <sicklorkin> dminuoso: Yes, I know.. i'm trying to think of an example where this causes havok.. I hate this function myself but in this code review i have a very stubborn individual that insists on keeping it.. however i'm unable to find an example that proves him wrong.
23:14:24 <lldd> dminuoso yeah so the difference is the encoding is known
23:14:41 <sicklorkin> he's replaced my Text.tshow with `toStr`
23:14:44 <Axman6> those bytes may encode a string, but they aren't a string until you've checked it's a valid sequence of bytes for the type of string you think it is
23:14:55 <dminuoso> lldd: Is it? Or maybe it render the codepoint according to some font, and give you binary bmp data?
23:15:00 <lldd> you could display the bytes as it is
23:15:35 <lldd> dminuoso: yeah so show should display the bytes as 0xx, ..
23:15:43 <dminuoso> lldd: IsString is the opposite
23:15:52 <dminuoso> lldd: It lets you treat "foo" as binary data. But what is "foo" as binary data?
23:16:29 <sicklorkin> oh wait.. i'm a moron.. I have found some very nice examples :)
23:16:35 <dminuoso> lldd: If you go down that road you will notice that implicitly it assumes unicode encoding with utf8, and it begs the question "what happens if that encoding fails?" or "is utf8 actually what I want?"
23:16:54 <lldd> dminuoso: i see it has fromString, which is weird
23:16:57 <lldd> my bad
23:17:12 <dminuoso> lldd: IsString is what happens when you use OverloadedStrings.
23:17:23 <lldd> i thought it would be like a collection typeclass
23:17:54 <lldd> yeah is it common to use that?
23:18:11 <dminuoso> lldd: Sadly, yes. Mostly because for convenience when working with ⌜text⌝
23:18:25 <dminuoso> But there exist numerous morally questionable instances.
23:18:52 <dminuoso> For instance ⌜iproute⌝ promotes using IsString instances for IPv4 and IPv6.
23:18:55 <lldd> yeah ByteString seems very questionable indeed
23:19:06 <dminuoso> So you can write `f :: IPv6; f = "2001::1/128"
23:19:35 <Axman6> sadly those fail at runtime, not compile time
23:19:53 <lldd> how do you get compile time checks for those?
23:20:01 <dminuoso> lldd: merijn has a package to do that.
23:20:29 <Axman6> using quasiquotes traditionally
23:20:42 <dminuoso> https://hackage.haskell.org/package/validated-literals
23:20:43 <lldd> ah TH
23:20:55 <Axman6> [ip6|2001::1/128]
23:21:04 <dminuoso> Or, using merjins package:
23:21:35 <dminuoso> $$(valid "...")
23:21:48 <dminuoso> e.g. f = $$(valid "2001::1/128")
23:22:08 <dminuoso> His package is a nice dropin solution without having to write QQ for everything.
23:22:45 <lldd> is there a ci template for building static haskell binaries?
23:23:04 <lldd> i read somewhere that binaries get smaller if built statically
23:23:39 <Axman6> not that I've found. it's noty too difficult to do using docker, I used to build 8MB or less docker images with statically linked haskell binaries on Alpine
23:24:24 <dminuoso> lldd: I actually once spent a fair amount tracking down an invalid literal for IPv6. It blew up my surrounding server thread, and I didn't bother to catch exceptions from pure code since I assumed it was so trivial it couldn't throw
23:24:43 <dminuoso> Catching bottom crawling up from pure code can be a fun excercise.
23:24:52 <sicklorkin> dminuoso: +1
23:25:10 <MarcelineVQ> It's unfortunate that bottom is so convenient
23:25:58 <Axman6> ;)
23:26:12 <lldd> yeah i hate how toEnum is partial 
23:26:51 <dminuoso> lldd: ToEnum is actually not an issue, but bad instances are.
23:27:15 <dminuoso> lldd: Enum is frequently abused for when you want some "number to value" mapping
23:27:17 <Axman6> I'm not sure I've ever used toEnum in the 10 years I've been using Haskell
23:27:30 <lldd> dminuoso: what's the alternative
23:27:41 <lldd> i am guilty of doing so :[
23:27:48 <dminuoso> lldd: Writing your own typeclass IsoInt or whatever.
23:28:17 <dminuoso> Oh well wait. Yeah, toEnum is probably partial in many csaes.
23:28:20 <dminuoso> Sorry. :)
23:28:28 <dminuoso> Never used that method myself heh
23:29:00 <Axman6> just write the functions of type Foo -> Int and Int -> Maybe Foo
23:29:46 <lldd> ,e toEnum 2 :: Bool 
23:29:52 <dminuoso> Axman6: They'd likely still be partial.
23:30:07 <dminuoso> Axman6: I mixed up what I consider wrong with Enum with what lldd was complaining about. :)
23:30:30 <dminuoso> Oh but yeah.
23:30:53 <lldd> dminuoso: i use toEnum for the unary constructor only datatype
23:31:17 <dminuoso> lldd: This is what I do https://gist.github.com/dminuoso/0b6356de3302461ae8cc8823f2937511
23:31:37 <dminuoso> (I should probably write a TH helper function for this)
23:31:52 <sicklorkin> dminuoso: Can you use Bounded?
23:31:53 <lldd> dminuoso: your deserialize is partial
23:32:03 <dminuoso> lldd: It's not. :)
23:32:18 <dminuoso> lldd: See the last line.
23:33:11 <dminuoso> class NumSerializable a where serialize :: (Integral n) => a -> n; deserialize :: (MonadFail f, Integral n, Show n) => n -> f a
23:34:18 <Axman6> would that also have the law: deserialise . serialise = pure?
23:34:22 <dminuoso> sicklorkin: Nope, sadly.
23:34:25 <dminuoso> Axman6: Yes.
23:34:52 <lldd> never used MonadFail, let me see
23:35:23 <Axman6> MonadFail is Monad without return and (>>=)
23:35:33 <dminuoso> Axman6: I dont test this directly, but it's implicitly covered by other quickcheck tests.
23:35:41 <Axman6> (with a Monad m constraint =)
23:36:34 <dminuoso> Axman6: ⌜getPutIsPure a = (runGet get . runPut . put) a == Right a⌝
23:36:43 <dminuoso> That's the single test above that covers this.
23:36:58 <dminuoso> Or rather the property (being part of some other test)
23:39:38 <lldd> `try (return $! toEnum x)` <- i have this for x deriving Enum
23:41:01 <lldd> i guess deserialize is more general 
23:43:03 <dminuoso> lldd: Your code has race potential.
23:43:27 <dminuoso> lldd: You probably want to use ⌜evaluate (toEnum x)⌝  than ⌜try (return $! toEnum x)⌝
23:43:59 <dminuoso> So yeah, exceptions in pure code is bad style.
23:46:14 <dminuoso> lldd: Specifically, your code does not, but the style of ⌜return $! toEnum x⌝ if used in different spots could hit you back because of imprecise exception semantics.
23:46:19 <lldd> dminuoso: thanks didn't know the subtle difference
23:46:41 <lldd> https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:evaluate
23:47:28 <lldd> btw i only do this inside an already IO action (it is deserialized from a file)
23:47:34 <lldd> so there is no pure code
