01:03:34 <phaazon> hey
01:07:10 <lortabac> hello phaazon :)
01:07:24 <phaazon> oh hey lortabac! long time no see! :)
01:57:16 <ski> @where burrito
01:57:16 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
01:57:22 <ski> int-e ^
02:09:17 <dminuoso> ski: Ah I think that was for me, rather.
02:09:19 <dminuoso> But thanks.
02:09:46 <dminuoso> Curiously, the more I understand about Monad, the harder I realize it is to teach.
02:14:00 <dminuoso> % class Functor f => Monoidal t i f where unit :: i ~> f; join :: f `t` f ~> f
02:14:00 <yahb> dminuoso: ; <interactive>:49:51: error:; Not in scope: type constructor or class `~>'; Perhaps you meant one of these: `->' (imported from GHC.Prim), `~~' (imported from GHC.Exts); <interactive>:49:73: error:; Not in scope: type constructor or class `~>'; Perhaps you meant one of these: `->' (imported from GHC.Prim), `~~' (imported from GHC.Exts)
02:14:14 <dminuoso> % type (~>) f g = forall a. f a -> g a
02:14:14 <yahb> dminuoso: 
02:14:16 <dminuoso> % class Functor f => Monoidal t i f where unit :: i ~> f; join :: f `t` f ~> f
02:14:16 <yahb> dminuoso: ; <interactive>:51:41: error:; * Could not deduce (Monoidal t0 i f); from the context: Monoidal t i f; bound by the type signature for:; unit :: forall (t :: (* -> *) -> (* -> *) -> * -> *) (i :: * -> *) (f :: * -> *). Monoidal t i f => i ~> f; at <interactive>:51:41-54; The type variable `t0' is ambiguous; * In the ambiguity check for `unit'; To
02:18:40 <dminuoso> Im curious, should this not type check?
02:18:42 <dminuoso> % class Functor f => Monoidal t i f | f -> i where unit :: i ~> f; join :: f `t` f ~> f
02:18:42 <yahb> dminuoso: ; <interactive>:61:50: error:; * Could not deduce (Monoidal t0 i f); from the context: Monoidal t i f; bound by the type signature for:; unit :: forall (t :: (* -> *) -> (* -> *) -> * -> *) (i :: * -> *) (f :: * -> *). Monoidal t i f => i ~> f; at <interactive>:61:50-63; The type variable `t0' is ambiguous; * In the ambiguity check for `unit'; To
02:19:33 <dminuoso> Ah, missing one fundep
02:19:35 <dminuoso> % class Functor f => Monoidal t i f | f -> i, f -> t where unit :: i ~> f; join :: f `t` f ~> f
02:19:35 <yahb> dminuoso: 
02:20:40 <dminuoso> It's a bit strange, because the diagnostic said "... In the ambiguity check for `unit'"
02:23:15 <ski> the signature of `unit' doesn't mention `t'
02:24:06 <dminuoso> ski: Ah, and the type variable is from the context `Monoidal t i f => ...` ?
02:24:38 <dminuoso> Right it makes sense. If I used unit, it couldn't infer the instance because it would need to know about that `t`
02:27:41 <ski> anyway, `Monoidal' doesn't describe a monoidal category. it seems to describe a monoid object, if `i' and `t' make the category of endofunctors (on `*') a monoidal category
02:38:47 <ski> % class Category hom => MonoidalCategory hom neut comb | hom comb -> neut where neutL_ :: hom (comb neut i) i; neut_L :: hom i (comb neut i); neut_R :: hom i (comb i neut); neutR_ :: hom (comb i neut) i; assocLR :: hom (comb (comb i j) k) (comb i (comb j k)); assocRL :: hom (comb i (comb j k)) (comb (comb i j) k)
02:38:47 <yahb> ski: 
02:57:52 <dminuoso> ski: Oh its not intended to describe a monoidal category.
02:58:53 <dminuoso> ski: Perhaps the name was a bit misleading, but Monoid is already taken - so..
02:59:37 <dminuoso> ski: Its surprisingly hard to read the definition of MonoidalCategory in Haskell, I must say.
03:01:28 <ski> dminuoso : would have been simpler if we still could use type variable operators
03:01:45 <dminuoso> ski: Cant you use type variables in infix notation at least?
03:05:01 <dminuoso> % class Category hom => MonoidalCategory hom neut comb | hom comb -> neut where neutL_ :: (neut `comb` i) `hom` i; neut_L :: i `hom` (neut `comb` i); neut_R :: i `hom` (i `comb` neut); neutR_ :: (i `comb` neut) `hom` i; assocLR :: ((i `comb` j) `comb` k) `hom` (i `comb` (j `comb` k)); assocRL :: (i `comb` (j `comb` k)) `hom` ((i `comb` j `comb`) k)
03:05:01 <yahb> dminuoso: ; <interactive>:67:339: error: Operator applied to too few arguments: comb
03:05:43 <dminuoso> % class Category hom => MonoidalCategory hom neut comb | hom comb -> neut where neutL_ :: (neut `comb` i) `hom` i; neut_L :: i `hom` (neut `comb` i); neut_R :: i `hom` (i `comb` neut); neutR_ :: (i `comb` neut) `hom` i; assocLR :: ((i `comb` j) `comb` k) `hom` (i `comb` (j `comb` k)); assocRL :: (i `comb` (j `comb` k)) `hom` ((i `comb` j) `comb` k)
03:05:44 <yahb> dminuoso: 
03:06:00 <dminuoso> ski: It's not too bad actually with infix type variables.
03:08:41 <ski> perhaps not
03:09:11 <dminuoso> ski: Okay this is interesting, what is `hom` exactly?
03:09:37 <dminuoso> I've seen this style of "category in haskell" a few times, but Im unsure what an instance of this class would look like
03:09:39 <ski> the hom-functor of the category in question ?
03:10:03 <dminuoso> ski: Ah, so a hom-functor is considered representative of that category?
03:10:37 <dminuoso> I guess it is, because it has a fixed domain..
03:10:38 <ski> that's what `Category' does, yes
03:10:54 <ski> % :k Category
03:10:55 <yahb> ski: Category :: (k -> k -> *) -> Constraint
03:10:59 <dminuoso> I see
03:11:47 <ski> `k' is the kind of objects. `hom', of kind `k -> k -> *' represents each morphism type (given two objects)
03:13:17 <dminuoso> ski: So if we let Category be limited to small categories, we could have some `enumerate :: 
03:13:29 <dminuoso> Oops, I actually wanted to strike that. Weird key combinations here.
03:15:28 <ski> i was just pondering finitely presented categories, and that one possibly would want a different type for the identity there
03:40:04 <ski> % data RetractObj = Retract | Sect
03:40:04 <yahb> ski: 
03:40:23 <ski> % data RetractHom :: RetractObj -> RetractObj -> * where Id :: forall i. RetractHom i i; Retraction :: RetractHom Sect Retract; Section :: RetractHom Retract Sect; Idem :: RetractHom Sect Sect
03:40:23 <yahb> ski: 
03:40:50 <ski> % instance Category RetractHom where id = Id; Id . m = m; m . Id = m; Retraction . Section = Id; Section . Retraction = Idem; Retraction . Idem = Retraction; Idem . Section = Section; Idem . Idem = Idem
03:40:50 <yahb> ski: 
03:41:08 <ski> ok, that did seem to work out, without changing/adapting `id'
03:42:45 <ski> hm, trying to find some reasonable example where the blind `id' wouldn't work
03:45:00 <ski> hmm .. now it occurs to me that this category looks like the subobject classifier of (directed multi-)graphs (which doesn't have composition, since it's only a graph)
03:46:02 <ski> (the free category on that graph is not the above category. however, the underlying graph of this category is that graph)
03:48:05 <mniip> there's a monad on Cat that's like the kleene star
03:48:28 <mniip> Cat --Forget-> Grph --Free-> Cat
03:50:04 <ski> yea, so morphisms become composable sequences of morphisms
03:53:03 <ski> just pondering what actually composing such a sequence would be
03:57:20 <ski> if we call this monad `FU', then we should have a functor `compose : FU C >---> C' (an `FU'-algebra ?), for any cat `C', presumably natural in `C'. so `FU >---> Id_Cat' would then be a natural transformation. a monad morphism ?
03:58:22 <ski> (i suspect much of this is trivial, but i don't see it)
04:18:51 <cheater> hi
04:19:59 <cheater> i have 5 different ADTs. each has ~10 constructors, and each of these constructors contains another ADT. So there's data Foo = FooA FooATy | FooB FooBTy | ... | FooJ FooJTy, and then I have data Bar, data Baz, etc. The types Foo, Bar, and Baz have somewhat different constructors, and FooATy and BarATy etc are different. I want to make data Quux together with data QuuxATy ... data QuuxJTy so that Foo, ...
04:20:05 <cheater> ... Bar, Baz can be converted to Quux recursively, and also I want to be able to convert FooATy, BarATy, BazATy to QuuxATy and so on. how do I best go about this?
04:21:42 <lyxia> Have you tried writing the functions by hand
04:37:28 <siraben> Any papers one would recommend to help me understand how to convert lambda calculus to SK combinators?
04:37:41 <siraben> I want to implement a compiler for the lambda calculus into say Z80 assembly
04:40:41 <ski> perhaps <https://users.ece.cmu.edu/~koopman/tigre/> could be interesting to check
04:40:46 <ggole> You don't need combinators for that, though?
04:44:00 <siraben> https://crypto.stanford.edu/~blynn/lambda/sk.html is good but his code is dense
04:44:30 <siraben> ski: I'll take a look, thanks.
04:55:12 <cheater> lyxia: i could write those functions by hand but i was wondering if it would be possible to leverage some functionality of haskell to do this more elegantly than that.
05:11:38 <[exa]> siraben: compiling to combinators is a completely different direction than compiling into assembly
05:14:26 <ski> (combinator graphs could be implemented as nodes of machine code, calling each other)
05:14:44 <ski> (self-modifying, of course)
05:23:30 <lyxia> cheater: have you looked at syb (Scrap your boilerplate) and GHC.Generics
05:41:48 <siraben> [exa]: to combinators then using assembly to run it
06:34:04 <moet> hello! does anyone know how to use `network-uri` correctly to handle both `http://host:port` and also `host:port` style URLs? (Subtext: there seems to be no way to parse the second style URI correctly with that library. It usually treats "host:" as the scheme)
06:34:22 <moet> > uriScheme <$> parseURI "host:port/path#frag"
06:34:25 <lambdabot>  error:
06:34:25 <lambdabot>      Variable not in scope: uriScheme :: a0 -> berror:
06:34:25 <lambdabot>      Variable not in scope: parseURI :: [Char] -> f a0
06:34:49 <moet> (oops, i don't know how to ask lambdabot to import things)
06:35:12 <moet> in any case, the problem could be easily avoided by detecting the presence of a scheme in the string, and then optionally prepending a default scheme ..
06:36:40 <ski> @let import Network.URI
06:36:43 <lambdabot>  Defined.
06:36:50 <ski> > uriScheme <$> parseURI "host:port/path#frag"
06:36:56 <lambdabot>  mueval-core: Time limit exceeded
06:37:08 <ski> > uriScheme <$> parseURI "host:port/path#frag"
06:37:12 <lambdabot>  Just "host:"
06:37:44 <moet> > uriScheme <$> parseURI "scheme://host:port/path#frag"
06:37:46 <lambdabot>  Nothing
06:38:22 <moet> oops, that second example doesn't show anything useful
06:39:41 <moet> here's a better example (working example first):
06:39:46 <moet> > uriAuthority <$> parseURI "http://host:80/path?query=x#frag"
06:39:51 <lambdabot>  Just (Just (URIAuth {uriUserInfo = "", uriRegName = "host", uriPort = ":80"}))
06:39:56 <moet> > uriAuthority <$> parseURI "host:80/path?query=x#frag"
06:39:59 <lambdabot>  Just Nothing
06:40:24 <moet> so in the second example, it finds `Nothing` for uriAuthority (host and port) because they were consumed by the part of the parser that searches for the scheme
06:40:48 <moet> > uriScheme <$> parseURI "host:80/path?query=x#frag"
06:40:51 <lambdabot>  Just "host:"
06:41:38 <moet> so as far as i can tell, the library is written to handle only strings with schemes.. none of the functions handle strings w/o schemes correctly.. also, none of the functions facilitate detecting the absence of a scheme so that a default one can be prepended
06:42:13 <moet> i know there are newer libraries out there, but i was wondering whether there's a way to do this using network-uri that i've missed!
06:42:55 <josiah_sama> I'm having some difficulty using the Frames library.
06:42:56 <josiah_sama> I'd like to create a function that can dynamically calculate the entropy of a set where the targetFeature and the set (as a Frame) are provided to the function as parameters.  I can't really figure out how to express this in the type system
06:43:57 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/ReFbSjFJtgUhTYDTYQWpzkuT >
06:45:16 <josiah_sama> I'm not totally uninitiated to Haskell, but some of these types are pretty intimidating
06:49:50 <dminuoso> That is indeed a bit scary. :)
06:50:22 <dminuoso> josiah_sama: Which problem are you trying to solve?
07:10:58 <josiah_sama> So, let's say the target feature column is called "Spam Classification" and the dataset is called SpamOrHam. I have already been successful is writing a non generic function that calculates the set entropy via...
07:13:49 <josiah_sama> `entropy (frameLength spamorham) $ map snd $ count (F.toList $ view spamClassification <$> spamorham`
07:16:08 <josiah_sama> Where `spamClassification` is a function that was generated by the Frames library, and `spamorham` is the type ``SpamOrHam`, which is an auto vegetated type by Frames as well for referencing the entire dataset that was loaded from CSV
07:16:52 <josiah_sama> <josiah_sama "Where `spamClassification` is a "> *auto-generated*
07:16:54 <josiah_sama> Sorry, I'm on my phone
07:18:18 <josiah_sama> I'm trying now to make this a generic function that an take any Frame and any column of that frame and calculate the set entropy based on that column
07:18:59 <ski> josiah_sama> :t spamClassification
07:19:10 <ski> josiah_sama> :t spamorham
07:19:28 <ski> josiah_sama> :t entropy (frameLength spamorham) $ map snd $ count (F.toList $ view spamClassification <$> spamorham)
07:20:37 <ski> oh, i suppose you mean `spamorham :: SpamOrHam' ? is `SpamOrHam' equal to `Frame T' for some type `T' (which ?) ?
07:24:41 <josiah_sama> Yes
07:27:14 <moet> I switched to using `Servant.Client.parseBaseUrl` for what it's worth.. it handles the parsing easily
07:27:51 <josiah_sama> And there's a column of SpamOrHam named "SpamClassification", so Frames generates some function called "spamClassification" with a really daunting type that, when sent to Data.Lens.Extras.view, returns that column of the SpamOrHam only
07:30:00 * ski is still wondering about the answers to the given questions would be
07:31:02 <[exa]> josiah_sama: a slightly longer code example would be cool, we do not have any definitions for half of the stuff you use
07:32:37 <josiah_sama> I'll have to get that to you later then. Sorry about that. This is a personal exploratory project and I'm currently working and away from my personal machine
07:32:57 <ski> josiah_sama : would you like to answer my questions ?
07:33:16 <josiah_sama> I definitely appreciate everyone jumping on and being willing to help though
07:33:45 <josiah_sama> ski I'll answer your questions as soon as I'm able
07:34:25 <ski> fair enough
07:34:32 <[exa]> wow, Frames look like R
07:34:45 * sicklorkin wonders if there are any green eggs to go with all that sp(h)am
07:37:23 <[exa]> mhm, tinking about that, is there some general construction for converting datatypes and their operations to vectorized fields?
07:37:54 <heatsink> By vectorized, do you mean using vector instructions? 
07:38:03 <heatsink> for an array of datatypes?
07:38:55 <[exa]> say the data is of type '(A,B)' with operation 'f', the usual vector of that is 'Vector (A,B)' with operation 'V.map f', I'd like some simple transform to '(Vector A, Vector B)' with operation 'XXXmap f'
07:39:16 <heatsink> Data Parallel Haskell does that
07:39:45 * [exa] eyes that
07:40:00 <heatsink> Also, IIRC Vector's internal representation of (A, B) is like (Vector A, Vector B)
07:40:14 <artem> mpickering: (or anyone proficient in Nix)  I do `nix run -f https://github.com/mpickering/ghc-artefact-nix/archive//master.tar.gz` and it fails with a strange error: "Please be informed that this pseudo-package is not the only part of Nixpkgs that fails to evaluate." Do you have an idea what might help?
07:41:02 <mpickering> artem: Because you are trying to evaluate the whole of nixpkgs!
07:41:18 <mpickering> `nix run -f https://github.com/mpickering/ghc-artefact-nix/archive//master.tar.gz -c ghc-head-from` should work
07:41:33 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/OTjMFIXjZTzhPMFyixxFiLMS >
07:42:04 <mpickering> or rather `nix run -f https://github.com/mpickering/ghc-artefact-nix/archive//master.tar.gz  nixpkgs.ghc-head-from -c ghc-head-from
07:42:18 <mpickering> or without the nixpkgs
07:42:32 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/vYqAQobAiXIEsgkeLaQeadcq >
07:42:35 <mpickering> maybe there is an example in the readme
07:42:43 <infinisil> mpickering: Btw, I recently found out that instead of `/archive/<ref>.tar.gz` one can just use `/tarball/<ref>` with github, makes it a tiny bit smaller :)
07:43:49 <mpickering> infinisil: Oh right thanks. I always go to the page, copy the "download zip" URL and modify the end to `.tar.gz` which is undocumented but works..
07:44:16 <ski> josiah_sama : should `spamClassification' be `spamClassCol', or vice versa ?
07:44:38 <heatsink> [exa], It turns out that vectorization introduces overhead for conditionals and nested loops, which a lot of algorithms use, so Data Parallel Haskell is limited as a way of making algorithms faster
07:44:54 <josiah_sama> [exa]: What I'm trying to do is make the `totalSpamOrHamEntropy` function generic so that it could be passed any `Frame a` and any column of that frame to calculate the entropy with respect to the column provided.
07:46:00 <[exa]> josiah_sama: what happens if you try to just abstract out the column selectors? (like, spamClass and perhaps also spamClassification)
07:46:53 * [exa] just realized that the compiled source depends on CSV file contents
07:47:16 <josiah_sama> ah, shoot, I thought I edited everything I needed to.  I pulled what I had on GitHub and tried to get it up to date with where I left things an hour ago.  
07:47:17 <josiah_sama> `count spamClassification` should be `count spamClassCol` and `view spamClass` should be `view spamClassification`
07:47:48 <ski> i suspected so
07:48:15 <ski> you still haven't answered by question about `spamClassification', though
07:49:14 <[exa]> josiah_sama: what does ghci say about the types of the spam* accessors?
07:49:38 <josiah_sama> `count` returns a `[(Text, Int)]` that groups the column values and then provides the number of times each value occurs in the column.  For calculating entropy, we only care about the number of occurrences, not about the values themselves.
07:50:27 <josiah_sama> let me dig that out of my editor, one sec
07:50:37 <[exa]> josiah_sama: :t in ghci should work just right
07:52:04 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/kcLYYWfZEIiThoKbgmsKwrPa >
07:52:44 <[exa]> oh cool, it is a lens!
07:52:55 <josiah_sama> yes
07:53:22 <josiah_sama> I get the functional idea of lenses, but I don't understand them well enough to get how to follow Lens types yet
07:54:10 <josiah_sama> at least, not without help
07:54:36 <[exa]> you probably do not need to worry about lens type internals. I get it that you are aiming to make a function that works with any supplied column identifier?
07:55:10 <josiah_sama> yes, and also any supplied `Frame a`
07:55:43 <[exa]> so let's work in steps, replace the spamClassification with a variable and pass it in as a parameter
07:56:08 <josiah_sama> the ultimate aim in the end will be to build an engine that can take a dataset and some criteria (like the targetFeature) and build a decision tree on it using the ID3 algo
07:56:45 <josiah_sama> @[e
07:56:45 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
07:57:01 <josiah_sama> [exa]:  That what I was attempting to do this morning, but I couldn't figure out what the type should be
07:57:30 <josiah_sama> but I had an idea as I was driving into work that looking at the type signature of the `view` function might assist me with that
07:57:36 <[exa]> you can just use a type hole
07:57:44 <[exa]> the compiler error will guide you to the correct type
07:58:09 <ski> [exa] : i was wondering whether they wanted `Rank2Types'
07:58:10 <[exa]> like, totalSpamOrHamEntropy :: _   ; totalS...ntropy col = your definition with the parameter
07:58:56 <josiah_sama> ah, and let GHC or Intero tell me what the type should be?
07:59:03 <artem> mpickering: thanks it helped. I just copied it from the mail thread on Guarded impredicativity, and it seems that the mail client/server hard wrapped the command leading me into the confusion
07:59:37 <[exa]> josiah_sama: no idea about intero, but if you compile the thing in ghc, the error message will basically tell you the whole type that is expected there
07:59:59 <mpickering> artem: Are you specifically trying to get the guarded impredicativity patch?
08:00:00 <josiah_sama> haha, amazing
08:00:50 <[exa]> josiah_sama: anyway, it should very probably compile even without the type signature
08:01:35 <artem> mpickering: yes. It seems that if remove all the \n then the command from the mail thread work
08:01:51 <[exa]> ski: rank2types certainly imminent.
08:03:08 <mpickering> artem: Glad to have another happy customer!
08:03:27 <josiah_sama> I've learned quite a few languages.  Haskell certainly has a bit of a learning curve (but I really like it).
08:03:28 <mpickering> (You might need to run the compiler in a shell with ncurses available)
08:05:59 <_nir_> Hello! I'm ALT Linux maintainer and I'm going to bootstrap GHC on exotic architecture. Is it possible to bootstrap it using Hugs98 or other Haskell interpreter?
08:06:26 <_nir_> There is lack of cross-compiling tools for architecture I'm going to work with.
08:06:43 <_nir_> So I want to perform native build somehow.
08:06:44 <[exa]> josiah_sama: regarding lens types, you probably noticed that the basic pattern is to 'zoom out' a function that wraps tiny stuff with functor (Text -> f Text) to create a function that works with something bigger (Record rs -> f (Record rs))
08:06:49 <merijn> _nir_: You can (painfully) bootstrap via the old C backend
08:06:57 <merijn> _nir_: You might wanna ask/hang around in #ghc
08:07:06 <Athas> _nir_: it is maybe possible if you go back to very old versions of GHC and build your way up; see https://www.joachim-breitner.de/blog/748-Thoughts_on_bootstrapping_GHC
08:07:18 <_nir_> Thanks!
08:07:52 <josiah_sama> [exa]:  ah, hence the term "Lens"
08:07:58 <[exa]> josiah_sama: the rest of the type signature you see there is just a type requirement that 'rs' type really contains the column
08:08:47 <vaibhavsagar> nir: you're attempting to do something that nobody else has ever done before, just so you know
08:10:28 <mpickering> and something that will be very painful
08:10:38 <[exa]> _nir_: seriously, good luck. (What's the architecture anyway?)
08:11:00 <_nir_> VLIW, e2k.
08:11:19 <[exa]> oooh where did you get that?
08:11:50 <_nir_> I can't say much about architecture itself.
08:12:01 <_nir_> Just want to bootstrap GHC. -_-
08:12:08 <_nir_> It's my personal initiative.
08:12:18 <[exa]> well it's certainly not a CPU where running compilers would be common I guess
08:12:22 <_nir_> Although I'm not experienced in Haskell.
08:13:04 <[exa]> does it have a reasonable gcc or other compilers?
08:13:17 <Athas> _nir_: you'd also need to write a GHC backend, or use the "unregistered" one.
08:13:47 <[exa]> with a bit of luck that can be done by cmm/llvm
08:15:01 <_nir_> Athas: I plan to build "unregistered" build and implement a backend only on final stages.
08:15:56 <_nir_> [exa]: Yes, C/C++ compiler is not a problem.
08:16:26 <[exa]> cool
08:17:02 <_nir_> So... I plan to sit in this conference for a while (maybe months or years -_-) so I'll be able to ask somebody questions about Haskell and GHC. >_<
08:17:53 <[exa]> _nir_: certainly ask about errors, either here or in #ghc (friendly ghc devs are scattered everywhere)
08:21:52 <ski> @where C/C++
08:21:52 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
08:23:21 <artem> mpickering: it worked, thanks a lot!
08:27:25 <heatsink> ski: I hope it's a joke
08:33:36 <[exa]> heatsink: it's an ecmascript draft
08:35:45 <heatsink> oh my
08:45:07 <laserpants> In the Thinking with Types book, it says that newtype T3 a = T3 (a -> a) is not a (covariant) functor, but fmap f (T3 g) = T3 id seems to satisfy the laws to me. What am I missing here?
08:47:36 <merijn> laserpants: Suppose we have "T3 Int"
08:47:46 <merijn> laserpants: And I want to fmap "even :: Int -> Bool"
08:47:50 <merijn> laserpants: What happens?
08:49:08 <laserpants> merijn: Thanks for the reply. Let me think about that one. hehe
08:51:08 <Lears> laserpants: You don't have fmap id = id.
08:55:29 <c_wraith> laserpants, another way to say that is "did you check with the compiler to see if that has the right type?"
08:58:23 <artem> Lears: if we imagine a simple pure language (instead of haskell), than parametricity suggests that the above defn. of fmap preserve: fmap id = id. This is because T can only hold id's. for it's the only inhabitant of `a -> a`.
09:00:18 <Lears> If that was `newtype T3 a = T3 (forall a. a -> a)` then the definition would indeed be lawful, but the type param is phantom.
09:01:13 <artem> do you think there may be other values handed over to T3?
09:01:52 <halogenandtoast> Isn't T3 not covariant because (a -> a) isn't covariant
09:01:55 <Lears> Something like `T3 (+1) :: T3 Int`?
09:02:39 <halogenandtoast> Sorry ignore what I said
09:02:47 <halogenandtoast> Coffee hasn't kicked in
09:02:50 <artem> Lears: I see, thanks!
09:05:25 <halogenandtoast> (a -> a) is obviously covariant in it's second argument, and contravariant in it's first 
09:05:55 <[exa]> how many arguments does (a->a) have?
09:06:24 <halogenandtoast> s/argument/position
09:07:15 <[exa]> so with a functor, can we say it's both co- and contra-variant?
09:07:57 <roconnor> we'd call T3 an invariant functor because it is neither co-variant nor contra-variant.
09:08:15 <roconnor> (phantom parameters are the only ones that are both co-variant and contra-variant)
09:08:28 <[exa]> that's a good name
09:14:39 <laserpants> but let (T3 x) = fmap even (T3 id) in x False works
09:15:22 * ski . o O( redundant brackets detected )
09:16:27 <ski> @let newtype T3 a = MkT3 (a -> a)
09:16:29 <lambdabot>  Defined.
09:16:54 <ski> @let instance Functor T3 where fmap f (MkT3 g) = MkT3 id
09:16:56 <lambdabot>  Defined.
09:17:55 <ski> > let T3 x = fmap id (MkT3 not) in x False
09:17:59 <lambdabot>  error:
09:17:59 <lambdabot>      Not in scope: data constructor ‘T3’
09:17:59 <lambdabot>      Perhaps you meant variable ‘_3’ (imported from Control.Lens)
09:18:06 <ski> > let MkT3 x = fmap id (MkT3 not) in x False
09:18:12 <lambdabot>  mueval-core: Time limit exceeded
09:18:18 * ski sighs
09:18:26 <ski> > let MkT3 x = fmap id (MkT3 not) in x False
09:18:28 <laserpants> oh no
09:18:33 <lambdabot>  mueval-core: Time limit exceeded
09:18:51 <ski> well, it seems lambdabot is not cooperating, atm
09:18:56 <ski> > let MkT3 x = id (MkT3 not) in x False
09:19:01 <lambdabot>  True
09:19:07 <ski> try those two out for yourself
09:21:19 <laserpants> but the first law, holds, right?
09:21:48 <Lears> No, a counterexample was just given.
09:22:20 <laserpants> oh I see
09:46:13 <_nir_> Yay! I was able to bootstrap old version of Hugs98! Now need to bootsrap newer versions!
09:47:04 <monochrom> Sounds like the Death March. >:)
09:47:05 <_nir_> And I also plan to mail authors of articles about GHC bootstrap to coordinate the comminuty efforts. :)
09:47:49 <_nir_> Maybe I'll need a public resource for bootsrap process description.
09:48:19 <monochrom> Oh, you're doing it on another architecture.
09:48:23 <merijn> _nir_: You should probably mail the ghc-dev mailing list about your efforts/work
09:48:34 <merijn> _nir_: Pretty sure some people will be interested
09:50:05 <_nir_> merijn: Thanks! Will try this approach.
09:54:56 <VSpike> Why would running `stack test` cause me to get the error `thread blocked indefinitely in an STM transaction`?
09:55:47 <VSpike> Seems to work in other projects so I think stack is functioning correctly
09:56:14 <VSpike> I'm doing some exercism.io problems, so I wrote the code being tested but not the tests themselves
09:56:57 <sicklorkin> VSpike: you have a reader but no writer?
09:57:27 <sicklorkin> stack test first compile your project then your tests.
09:58:12 <VSpike> *facepalm* thanks
09:59:16 <monochrom> The triumph of tests.
09:59:21 <VSpike> Nice that the code actually worked first time (and passed tests first time once you unblocked me there). I felt like I made heavy weather of figuring out how to solve the problem though. Couldn't get away from imperative thinking.
09:59:40 <VSpike> Does seem like the type system will often ensure that simple code will work first time once it compiles
10:00:05 <EvanR> maybe where "work" means, does not throw an exception
10:00:18 <VSpike> Are maps/hashes/dictionaries commonly used in Haskell?
10:00:35 <monochrom> Yes. BST is as popular as hashing.
10:00:57 <EvanR> though simple code can still easily go into an infinite loop 
10:01:06 <EvanR> the poor type system can't stop it
10:02:08 <monochrom> Data.Map uses BST, Data.HashMap uses hashing and a high-degree tree. (For Data.HashMap be sure to get it from unordered-containers not other lesser packages!)
10:02:59 <EvanR> what about Data.Set
10:06:09 <EvanR> ok also a BST
10:56:12 <dada_cetacean> how do you set a custom binding level for custom notation declarations?
10:57:34 <ski> do you mean precedence levels for user-defined operators ?
10:57:35 <pavonia> What is a binding level?
10:57:59 <dada_cetacean> i mean precedence level
10:58:03 <dada_cetacean> thanks
10:58:08 <ski> for operators ?
10:58:38 <dada_cetacean> yeah, like if i define (|+|) to be myCrazyAddition and want it have higher precedence than normal addition or something like that
10:58:52 <ski> there are `infixl',`infixr',`infix' declarations
10:59:23 <ski> you'll have to decide whether you want the operator to be "left-associative","right-associative" or "non-associative"
11:00:01 <ski> so that, if you write `x |+| y |+| z', is that supposed to mean `(x |+| y) |+| z' or `x |+| (y |+| z)', or perhaps it shouldn't be allowed ?
11:00:44 <ski> `+' is declared with `infixl 6 +'. a higher precedence level means that the operator "binds more tightly"
11:01:35 <ski> (`*' is at `7', and `^',`^^',`*' are at `8')
11:01:48 <ski> dada_cetacean : does that help ?
11:08:37 <dmwit> dminuoso: Hm, okay. I think that natural-transformation definition of a cone is probably just a tiny bit too cute for its own good.
11:11:46 <dmwit> dminuoso: Are you sure you didn't misunderstand the definition? Wikipedia has a definition of cones as natural transformations, but it's not from a constant functor to the diagram, it's from the diagonal functor to the diagram.
11:13:24 <dmwit> err, hm
11:14:22 <dmwit> No, it is I who misunderstood Wikipedia.
11:14:34 <dmwit> I am confused as you are: that definition appears to have a problem with empty diagrams.
11:14:47 <dmwit> (That the cone definition does not have.)
11:16:17 <oats> would it be accurate to say that MonadPlus is just a Monad with a Monoidal interface?
11:24:39 <dada_cetacean> ski, yes that does help! thank you
11:25:02 <ski> np
11:25:13 <uzuki> oats: By Monoidal, do you mean monoidal category or monoidal functor? In the former case, Monoidal instances would have kind * -> * -> *, whereas Monad instances have kind * -> *, so no type constructor can be simultaneously an instance of both. In the latter case, you would have to require compatibility axioms between two separate type classes, and that is probably best done by defining a third type class.
11:25:48 <uzuki> Actually, no, in the latter case, it still doesn't work.
11:31:00 <uzuki> oats: A monoidal functor should be, first and foremost, a functor. So, how on Earth does the extra structure in a MonadPlus, not present in a Monad, provide anything vaguely resembling a fmap?
11:33:11 <int-e> . o O ( Haskell vs. Kant: The categorical declarative. )
11:42:55 <oats> uzuki: I'm not sure
11:44:52 <solonarv> oats: it's certainly true that the laws for <+> and mzero are exactly monoid laws, so in that sense MonadPlus does define a monoidal operation.
11:44:59 <oats> all I know is `mzero` looks a lot like `mempty` and `mplus` looks a lot like `<>`
11:45:56 <Boarders> if I have a weighted vector corresponding to probabilities of indicies which I wish to update after each sample is there a good probability monad framework that allows me to do that?
11:46:47 <oats> solonarv: yeah, that's basically what I was wondering
11:48:23 <solonarv> oats: in fact for some MonadPlus instances there is a corresponding Monoid instance with (<>) = (<+>), mempty = mzero
11:48:27 <solonarv> [] for example
11:49:29 <cheater> lyxia: some time ago, but i haven't considered it for this, yet.
11:54:26 <dmwit> oats: In fact an infinite family of monoidal interfaces, one for each contained type.
11:55:05 <oats> dmwit: woah
11:55:11 <dmwit> Compare, e.g. `instance Semigroup a => Monoid (Option a)`, which doesn't promise to make a monoid for *any* contained type, but only those contained types that themselves implement Semigroup.
12:22:23 <gabbiel> really surprised there isn't an function of type a -> [(a,b)] -> (a,b) in the standard library
12:24:31 <cjay-> :t lookup
12:24:33 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:25:09 <cjay-> gabbiel: is that what you want? you would know the a already
12:25:23 <Gurkenglas> Let "Graph a" be the type of graphs with node set a, and perhaps colors on the nodes and labels on the edges. An automorphism is a bijection on a that preserves edges/colors/labels. I need the theorem that for any polymorphic function f :: Graph a -> Graph a, every automorphism on x is an automorphism on f(x). Does this happen to be the free theorem of Graph a -> Graph a?
12:25:45 <gabbiel> cjay-: yea something like that
12:26:11 <gabbiel> thanks
12:26:14 <ski> @type \k -> find ((k ==) . fst)
12:26:16 <lambdabot> (Foldable t, Eq a) => a -> t (a, b) -> Maybe (a, b)
12:26:22 <Gurkenglas> "An automorphism on x :: Graph a is a bijection on a that ..."
12:45:14 <dmwit> Unfortunately, the standard collection of free theorems is stated about algebraic types, and graphs are not algebraic.
12:45:25 <dmwit> So it probably depends critically on exactly what API your Graph type exposes.
12:46:17 <dmwit> For example, if I can get a list of the nodes, I expect I can break that property.
12:48:27 <dmwit> (Start with a two-node discrete graph with both nodes labeled green. All bijections are isomorphisms. Now write the function that takes a graph, gets its list of nodes, and constructs a new discrete graph where the first node in the list (if any) is colored red and the remaining ones (if any) are colored green.)
12:48:40 <dmwit> s/isomorphisms/automorphisms/
12:50:20 <dmwit> On the othe hand, perhaps `data Graph a = Graph { color :: a -> Color; label :: a -> a -> Maybe Label }` or something, and then I expect the free theorem *will* get you where you want to go, but every graph update operation you try to write will be stupidly slow.
12:52:40 <dmwit> I doubt you'll be able to achieve both "API that lets you write the fast algorithms" and "API for which the free theorems give you the thing you want", although that's a gut feeling more than anything.
13:22:56 <nate_> I have a typeclass instance that requires a constraint not demanded by the class; to satisfy this, I've resorted to using GADTs.  GHC complains that it still can't infer that constraint until I do a ccase analysis, at which point it is duly satisfied.  Anyhow, this takes up a lot of space, since I do the same thing for all cases (all ctors of the GADT have the same constraint).  Is there a short hand for 
13:23:02 <nate_> this that people commonly use, or must I break out into that entire case analysis?
13:23:24 <glguy> nate_: You could name that pattern as a single function and use it
13:24:08 <glguy> nate_: Do you have an example of the code you can share on a pastebin like gist.github.com?
13:24:26 <nate_> Sure, just a second.
13:26:52 <dmwit> (Can you just put the constraint in the instance context instead?)
13:29:11 <glguy> nate_: https://gist.github.com/glguy/1c314ff38a16ea07ba70b416fbd708b8
13:31:36 <nate_> dmwit: orry, should have specified.  I cannot, because the typeclass is on kind (* -> *)
13:31:49 <nate_> s/orry/Sorry/
13:34:36 <nate_> glguy: https://pastebin.com/vbqNFtT8
13:34:57 <nate_> glguy: I'm not sure I understand how I would use the code in that gist.
13:35:47 <glguy> nate_: you'd write a `aTOaTOa` b = withConstraint (C1  (myTypeAtoA a) (myTypeAtoA b))
13:36:19 <glguy> Where: withConstraint :: MyType a -> (Constraint a => b) -> b; withConstraint C1{} x = x; withConstraint C2{} x = x 
13:40:53 <nate_> glguy: Ah, so, does this trick specifically rely on RankNTypes?  As in, can't be done without it?  If so I think I may not understand RankNTypes as well as I thought I did.
13:41:23 <glguy> This uses the rank-n types extension but it isn't really a rank-n type
13:42:59 <nate_> Interesting.  It's just used to scoot the constraint in.  I'm not sure I totally grok it, but this is much cleaner.  Thank you!
14:04:28 <nate_> glguy: Okay, that worked until it didn't.  I hit one case that was unhappy: a ctor with no arguments.  If I put the constraint on the constructor, the typeclass can't satisfy the constraint.  If I leave off the constraint on the constructor, withConstraint rejects that casee.  Any advice?
14:11:28 <glguy> nate_: having arguments isn't necessary as you can see from my example where I had none
14:11:49 <glguy> nate_: If you have some code that doesn't work and an error message to paste I'd look at it
14:14:43 <nate_> glguy: Sorry---I undespecified.  I have a second type class: `class C3Wrapper f where c3wrap :: f a`
14:15:33 <nate_> The complaint is in `instance C3Wrapper MyType where c3wrap = C3`
14:15:51 <nate_> Does that clarify?
14:18:27 <glguy> Oh, in that case you don't have any proof that there's an instance of that constraint
14:18:36 <glguy> so you'll need to do something else
14:18:53 <glguy> like change the type of c3wrap :: Constraint a => f a
14:23:07 <nate_> Ah.  That is sad.
14:23:17 <nate_> I had hoped to avoid that fate.
14:26:14 <nate_> glguy: is there a trick on the other side?  That is, in the type definition?  I actually don't control the type of `c3wrap`, which means I'm sort of stuck with it.
14:27:41 <glguy> nate_: you'll just have to decide to want something else; what you're asking for doesn't make sense
14:27:53 <nate_> Yeah, okay.
14:27:54 <glguy> The first step is understanding why it doesn't make sense
14:28:11 <glguy> so that you can start to think about how you could change it
14:28:49 <nate_> I think I do understand, and that I am stuck with it.  I was actually hoping maybe that I didn't understand it after all.
14:30:47 <nate_> Well, thanks anyhow.
14:45:47 <oofp33> Hello, what is right way to convert type level string to  Language.Haskell.TH.Name? I only was able to convert using type alias: 
14:46:14 <oofp33> I would like to create Name directly from string
14:46:59 <glguy> You can use "symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String" and template-haskell's "mkName"
14:49:25 <oofp33> glguy, Thanks, but I guess I was not clear in my question. The name that I need is name of type of Kind Symbol
14:49:47 <oofp33> so it is name of type
14:51:04 <glguy> There's no Name that corresponds to an arbitrary Symbol
14:54:53 <oofp33> glguy, so the solution with type alias is my only option? 
14:55:36 <glguy> Or change whatever wanted a Name to want a Type
15:00:19 <oofp33> glguy, can you please show how it should look?
15:00:39 <glguy> How what should look?
15:08:09 <sicklorkin> Can i safe restict the bounds of a value inside a QC.property? For example I want to restrict my property only accept values between -1 .. 1.
15:08:18 <sicklorkin> *safely
15:09:55 <dada_cetacean> hello, i'm back and still puzzled about how to assign a fixity/precedence to a symbolic operator, e.g. infixr 3 `(|+|)
15:10:30 <dada_cetacean> this works if i replace the operator with `foo`, but if i then try to alias |+| for foo, Haskell automaticlaly assigns it `infixl 9`
15:12:30 <dada_cetacean> oh nevermind, i was being stupid
15:25:08 <lyxia> sicklorkin: have you seen the forAll function
15:30:56 <sicklorkin> lyxia: Yes, i was staring at it, seems like the only thing that takes a Gen
16:29:15 <rosterok> i've installed ghc with ghcup.  now i'm trying to install haskell-ide-engine, which i heard to do with `stack install haskell-ide-engine:hie-wrapper`.  i don't have stack.  should i remove ghcup to install stack with curl -sSL https://get.haskellstack.org/ | sh
16:30:00 <sicklorkin> rosterok: I think there's a cabal/shake installer too
16:30:11 <sicklorkin> ./install --help
16:30:17 <rosterok> thanks
16:30:19 <glguy> You don't need to remove ghcup to use stack, ghcup will be good to have around for everything else that dosen't use stack
16:30:54 <infinisil> And if you have Nix you can use https://github.com/infinisil/all-hies, which is probably the fastest and most reliable way to get HIE
16:31:22 <rosterok> i don't, but i think i should
16:32:53 <infinisil> Whatever works for you :)
16:32:59 <sicklorkin> infinisil: I was a little surprised to see hie is only packed as nix build.
16:33:12 <infinisil> sicklorkin: As prebuilt binaries you mean?
16:33:21 <sicklorkin> yeah.. dist is gone
16:33:46 <infinisil> dist?
16:34:14 <sicklorkin> hie has a release tarball but was nixed
16:34:22 <sicklorkin> s/has/had
16:36:46 <cole> is there a function of type `Foldable t => t a -> Seq a` or a simple single-pass implementation? it feels kind of awkward to use `fromList . toList`
16:37:30 <cole> i looked at `Seq.fromList` and its implementation is kind of gnarly, so i guess i wouldn't be surprised if it isn't simple
16:38:36 <infinisil> sicklorkin: Hm I see
16:39:03 <spoonm> hey guys, is there a better way to do this last line? http://ix.io/1OWw
16:39:38 <infinisil> cole: You can probably use the unfold: https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html#v:unfoldr
16:39:46 <sicklorkin> zip3
16:39:55 <infinisil> Hm although maybe not no
16:39:57 <glguy> cole: fromList . toList is fine
16:40:09 <spoonm> sicklorkin: I actually do want them to be ((a,b),c), though
16:40:27 <spoonm> I have some function a -> b -> c -> [...] and infinite lists [a], [b], [c], ...
16:40:48 <spoonm> I want to apply them in order like [f a1 b1 c1 ..., f a2 b2 c3 ..., ...]
16:41:00 <cole> glguy: ok, thanks
16:41:02 <sicklorkin> spoonm: first second form arraow?
16:41:13 <spoonm> sicklorkin: sorry?
16:41:23 <spoonm> do you mean a list comprehension?
16:42:06 <cole> sicklorkin: is this not liftA3 under ziplist?
16:43:13 <spoonm> cole: whoa, you might be right
16:44:27 <spoonm> cole: oh, wait, no, doesn't seem to be the case
16:44:44 <rosterok> nix failed when sourcing nix.sh with some python3 and ownership errors.  stack install haskell-ide-engine:hie-wrapper failed with 
16:44:46 <rosterok> rts-1.0: Warning: .:739:1: The field "hugs-options" is deprecated. hugs isn't supported anymore\n Error parsing targets: Unknown local package: haskell-ide-engine
16:44:58 <rosterok> i should probably stop for the day
16:45:16 <spoonm> I don't want the function to be applied over all possible combination of arguments, but as if the arguments were in each index of the lists
16:45:19 <sicklorkin> rosterok: i have some old binaries around I think\
16:46:10 <spoonm> for what I want to do but with only "two arguments": let f :: a -> b -> c, x :: [a], and y ::[b], I do it with `map (uncurry f) $ zip x y'
16:46:21 <rosterok> sicklorkin: thanks.  i'm going to try to get nix working tomorrow
16:46:32 <spoonm> I want similar behavior but for any number of arguments/lists
16:47:07 <cole> spoonm: i don't know how to lambda bot, but isn't this the desired behavior (pasting code...)
16:47:40 <cole> > (\x y z -> [x,y,z]) <$> ZipList "abc" <*> ZipList "def" <*> ZipList "ghi" = ZipList {getZipList = ["adg","beh","cfi"]}
16:47:42 <lambdabot>  <hint>:1:75: error:
16:47:42 <lambdabot>      parse error on input ‘=’
16:47:42 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
16:47:52 <cole> sorry ;_;
16:48:16 <spoonm> that's exactly it
16:48:18 <infinisil> rosterok: Feel free to ping me regarding Nix tomorrow if you remember :)
16:48:23 <spoonm> huh
16:48:41 <cole> map (uncurry f) $ zip x y is equivalent to zipWith f x y
16:49:13 <cole> and ZipList generalizes that kind of behavior
16:49:18 <spoonm> I really should know my functions
16:49:32 <spoonm> zipWith3 should do what I want, but yeah, I should look into that
16:49:34 <spoonm> thanks, cole 
16:49:45 <cole> np
16:50:21 <cole> if you want higher arity zipWiths you may end up having to use ZipList at some point fyi
16:50:49 <spoonm> yeah, I'm gonna look that up now before I encounter this problem again
16:53:26 <cole> spoonm: fwiw you were essentially doing what `liftA3` does in your code, but in a backwards order. you built up the list and then mapped over it, when instead what `f <$> l1 <*> l2 <*> l3` does is map `f` over `l1`, giving a list of partially applied functions, then applies those functions pairwise with `l2`, giving another list of functions, etc.
16:55:00 <spoonm> cole: yeah, my problem with that is the fact that when the list of partially applied f over l1's elements meets <*> l2, it'll have its elements applied to every element of l2 and whatnot, in a cartesian product sort of way
16:55:17 <spoonm> rather than just the corresponding index
17:45:48 <turab> @pl \x -> txt ++ x ++ txt2
17:45:48 <lambdabot> (txt ++) . (++ txt2)
17:46:08 <turab> Beautiful
18:27:22 <nitrix> Hi. Apologies for asking here since Haskell is more "applicative" than "concatenative", but how do stack-based languages (e.g. forth/factor/cat/joy) model state? Like, if I want long lasting stateful information and modifying it, you can't possibly shuffle the stack that much without going nuts.
18:27:36 <nitrix> Is there some monad trick there too?
18:28:36 <josiah_sama> ski:  [exa] 
18:28:55 <josiah_sama> The solution to the problem earlier ended up being this function:
18:29:17 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/EdXTGlZAqJoHkaWudVuARpgO >
18:30:47 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/iqRpiDIjifEoJGJxPoZgxXJY >
18:33:07 <josiah_sama> Reading the type of `Lens.Micro.Extras (view)` was more helpful than using the type hole approach.  GHC wasn't able to narrow the type down far enough for me to figure it out based on its output.
18:36:57 <turab> Hello. I feel like the way I am writing tests are not good. It's working fine for me but I am not even half way done testing this function and the test is looking ugly as heck
18:37:01 <turab> https://gist.github.com/trajafri/c353759c53b59856f7b0d5a583564bc7
18:37:34 <turab> Is there something better that can be done here?
18:41:05 <dmwit> turab: Almost certainly. But without knowing more about shapes and placeImage it's pretty tough to say.
18:42:09 <turab> Alrighty I guess I can push these changes now. Will send you a link in a sec.
18:45:03 <turab> The tests I have so far only test the following function (It's really bad, so feel free to roast pls)
18:45:14 <turab> https://github.com/trajafri/htdp-image/blob/55dee9f946f772744cd15b4d1108ac4b867588cf/src/Graphics/Combinator.hs#L82
18:45:54 <turab> shapes: https://github.com/trajafri/htdp-image/blob/master/src/Graphics/Data/Image.hs#L9
18:58:04 <dmwit> Yeesh, that's... quite a complicated function.
18:59:43 <turab> I am sorry :(
19:00:42 <dmwit> Can you say in English what it's supposed to do?
19:02:15 <turab> Yes. I am goona explain it in the gist I posted above
19:04:51 <dmwit> (Perhaps we can help you make a quickcheck-based test that will generate hundreds of tests for you. ;-)
19:10:15 <turab> https://gist.github.com/trajafri/c353759c53b59856f7b0d5a583564bc7
19:11:02 <turab> Ha, that would be cool. I started using HUnit because of multiple corner cases and I wanted to be sure that this function works properly.
19:22:25 <glguy> I like using tasty as it has adapters for HUnit and QuickCheck so I can combine all my tests into one framework
19:23:57 <turab> glguy: I actually read about tasty today and was wondering when I would get to use it :)
19:31:00 <sicklorkin> glguy: had you used hspec much before tasty? 
19:32:01 <hatds> How does one format inline code again?
19:32:24 <monochrom> What is inline code?
19:32:44 <hatds> this "let x = 3 in x+x" is an expression
19:32:55 <hatds> `let x = 3 in x+x` is an expression
19:32:57 <hatds> hmm
19:33:15 <hatds> like [code] tags for message boards
19:34:03 <monochrom> But not for message boards? For where?
19:34:13 <hatds> for the IRC channel
19:34:25 <monochrom> Just write "let x = 3 in x+x"?
19:34:49 <hatds> Heh okay maybe I'm misremembering then.  I thought there was a fancier way.
19:34:51 <monochrom> IRC has no bell and whistles for code, picture, sound bites.
19:35:21 <monochrom> IRC is just string.
19:35:27 <int-e> > "is an expression"
19:35:32 <lambdabot>  "is an expression"
19:36:58 <glguy> sicklorkin: I've looked at it but I don't care for the way you specify things with it
19:37:32 <hatds> Can one convert a lazy bytestring into a lazy list of Word32's without involving other packages besides binary & bytestrings?  The Get monad seems like where I should be looking, and runGetOrFail does indeed return the unconsumed/leftover bytestring in a lazy fashion, but "runGetOrFail (many getWord32le) bs" doesn't give a lazy list of Word32's (the "unconsumed" input is still lazy, but...
19:37:33 <hatds> ...'many getWord32le' is going to consume the entire input in this case)
19:38:23 <monochrom> unpack is lazy.
19:38:34 <monochrom> Err nevermind, that's Word8
19:39:10 <hatds> yeah, I'm trying to write unpack32 basically
19:39:19 <janat08> how to do you know to install mtl package if importing control module?
19:41:44 <monochrom> I think think I would loop over runGetOrFail, using getWord32le for the "Get a" parameter.
19:41:47 <turab> janat08: Could you rephrase the question?
19:42:49 <janat08> In development it appears like it doesn't matter if I installed a package or not, imported modules don't throw errors, in production I have to actually tell where modules come from and install them
19:43:06 <janat08> sure enough I just assumed that control module comes from control package
19:46:00 <monochrom> But there is no "control module".
19:47:22 <hatds> monochrom: ah, you mean something roughly like this?  
19:47:27 <hatds> runGetOrFail (getWord32le) bs of
19:47:28 <hatds>       Left -> <error out>
19:47:30 <hatds>       Right (ys,offset,a) -> a : <recurse runGetOrFail on ys>
19:47:36 <monochrom> Yeah
19:47:49 <hatds> ^should have started with "CASE runGetOrFail (getWord32le bs) of"
19:47:57 <hatds> that was easy
19:47:59 <hatds> thanks
19:49:52 <halogenandtoast> I know this is relatively arbitrary, but I am trying to write an hspec spec where I hit an API endpoint and then check the contents of my database and I wanted to see if the way I am doing it seems reasonable: https://gist.github.com/halogenandtoast/ba40189d6eadb6a2ac16d6965a90c72b
19:50:06 <halogenandtoast> the API endpoint is a scotty application
19:51:20 <sicklorkin> halogenandtoast: you can use before or beforeAll and drop the setup
19:51:42 <sicklorkin> it "generate a montly rollup entry" $ \(web, cfg) -> do
19:52:11 <sicklorkin> head no good :(
19:52:33 <halogenandtoast> sicklorkin: thanks, that is probably a good idea, and sure head isn't good, but the validation above should "guarantee" the length is 1
19:54:42 <janat08> monochrom: I imagine there's no control.monad.trans package either
19:54:52 <janat08> or control.monad
19:55:26 <halogenandtoast> sicklorkin: I mean I guess I could use safeHead and add a Just on the right side of the expectation
19:56:04 <halogenandtoast> or something similar
19:57:34 <janat08> so do you tell which module belongs to what package
19:58:43 <monochrom> I do the opposite direciton. I find out which package I like to use first.
20:00:44 <janat08> looks like entering the module name helps
20:00:49 <janat08> into hackage
20:01:40 <turab> So, I would like to use QC but I hesitate to use it. I prefer HUnit since I know how good the tests are and what exactly is tested. With QC, I fear that I might get lucky
20:03:29 <turab> By lucky, I mean that the property tests might miss some cases that have not been implemented correctly
20:03:35 <lyxia> they do different things though
20:03:57 <lyxia> if you don't have unit tests for the bad cases they won't catch it either
20:04:28 <halogenandtoast> sicklorkin: I got rid of the head and just fmap entityVal onto a safeHead implementation. Would you just write your own safeHead or would you use Data.List.Safe from listsafe or Safe from safe?
20:05:05 <halogenandtoast> At the moment I feel like an extra package for a simple function isn't justified
20:06:20 <turab> That's true. I am mostly wondering if there are some ways to maximize the benefits of property based testing since I am not that experienced with them
20:06:47 <turab> It's going to save me hella time tho so I might as well start using QC tongiht :)
20:09:07 <halogenandtoast> turab: you can always have both test types if you are really concerned, HUnit for the things you want to guarantee, QC for the unknowns
20:10:09 <halogenandtoast> If you are "really concerned" otherwise just use QC where it makes sense.
20:10:34 <turab> halogenandtoast: Just started looking into tasty and gonna try doing both HUnit and QC
20:10:50 <lyxia> halogenandtoast: yes define safeHead in two lines and be done with it.
20:10:59 <halogenandtoast> lyxia: :+1:
20:11:24 <halogenandtoast> I did 3 lines because of the type signature, but same difference I suppose
20:12:34 <lyxia> 2 hard problems in computer science :)
20:13:49 <halogenandtoast> naming, busting cache, and off by one errors?
20:14:29 <halogenandtoast> s/busting/invalidating/
20:22:16 <monochrom> 10 bits in one byte.
20:25:54 <halogenandtoast> I forget, is there some function in base (or a common package) that is (fmap . fmap) or is it only <<$>> from protolude?
20:28:52 <halogenandtoast> I think the answer is no, and I should just write fmap . fmap
20:42:03 <lyxia> right
21:02:20 <solonarv> halogenandtoast: oh, it is also available in reflex as 'ffor' IIRC
21:02:35 <solonarv> if you happen to be using reflex already, of course
21:02:48 <Cale> ffor is just flip fmap
21:06:12 <solonarv> ah, I misremembered what the name was
21:16:43 <sarahzrf> shdnt it be forF logically
21:16:44 <sarahzrf> :V
22:14:06 <gabbiel> imo, a pattern like "f (x:x:ys) = undefined" should be allowed in haskell
22:14:35 <gabbiel> of course, it implies that x's type has to be an instance of Eq
22:15:00 <gabbiel> but it would be very useful
22:16:50 <sarahzrf> gabbiel: you could accomplish that by "f (x:x':ys) | x == x' = undefined"
22:17:56 <gabbiel> there should at least be an extension
22:18:05 <sarahzrf> ¯\_(ツ)_/¯
22:19:09 <gabbiel> i guess I could do that, but the above is more readable
22:22:13 <gabbiel> what are the odds this would be made into an extensions if I made enough fuss about it 
22:31:04 <EvanR> gabbiel: also called non linear pattern matching
22:31:15 <EvanR> some languages have it
22:32:13 <gabbiel> which languages
22:32:20 <gabbiel> hope idris has it
22:32:26 <EvanR> i'm not sure it's worth the development effort, assuming it makes sense, and not totally sure there isn't some terrible gotchas which you'd run into
22:33:55 <EvanR> elixir...
22:33:58 <gabbiel> where do I request for this implementation
22:34:07 <EvanR> it indeed implies an equality test as you said
22:35:16 <gabbiel> just elixir, ok, at least that language is in my backlog of languages to learn
22:35:58 <EvanR> no, probably a few
22:36:12 <EvanR> this SO post mentions Curry https://stackoverflow.com/questions/35891663/what-are-nonlinear-patterns
22:36:21 <heatsink> Maude has nonlinear pattern matching IIRC
22:39:27 <gabbiel> hmm, im reading that post and it says what would \x x -> x mean
22:39:55 <gabbiel> clearly it means to to match on two arguments that are equal and to return it
22:40:27 <gabbiel> as for \x -> \x -> x, im sure that it'd mean the innermost x
22:42:12 <gabbiel> nvm read that wrong, its saying what would it mean in that case
22:45:33 <EvanR> that's confusing since you'd expect \x y -> z to be the same as \x -> \y -> z
22:47:04 <EvanR> also \x x -> x still has to decide which one to return, since == could be define in any wonky way
22:48:20 <EvanR> in a language like idris where there is some hard = between all terms, it might make more sense
22:48:51 <gabbiel> yeah i forgot all functions in haskell are unary
22:49:59 <gabbiel> hard = ?
22:50:19 <EvanR> idris can tell you if two terms are the same
22:50:56 <EvanR> that's how Refl : a = a works
23:01:44 <hololeap> does haddock add the appropriate Functor/etc. instances if you derive them on a newtype using Derive* language extensions?
23:21:26 <gabbiel> weird how I'm not able to do this f (-1) = '*' ; f = head . show
23:30:12 <hololeap> gabbiel: all of the different definitions of a function have to have the same arity
23:34:28 <gabbiel> hololeap: (head . show)'s arity is 1, just as f's arity is 1 too
23:38:01 <hololeap> the first definition is defined point-wise, while the second is point-free... i'm sure someone else can explain it properly with all the appropriate technical jargon :/
23:41:10 <gabbiel> its fine hololeap, you're right regardless since it ghc won't let me do it 
23:50:19 <maerwald> I remember someone saying that `gettErrno` is not thread safe or something? 
23:56:24 <maerwald> Does it only work reliably for OS threads? 
