00:52:36 * jgt waves good morning to the OG Haskellers
01:36:05 <maerwald> dminuoso: I wish I would know what that questions means xD
01:36:16 <maerwald> (or maybe not)
01:56:06 <phadej> dminuoso: adjunctions induce monads
01:57:30 <phadej> or rather "Every monad arises from some adjunction"
01:59:49 <bahamas> hello. anyone who uses yesod, do you have a setup where you use postgres as a docker container?
02:02:17 <Taneb> dminuoso: there's no real definition of a free functor, other than a left adjoint to a forgetful functor
02:02:30 <Taneb> (There's also no real definition of a forgetful functor)
02:02:40 <Taneb> Because of this, you could call any left adjoint a free functor
02:15:01 <jgt> bahamas: I use Yesod and Postgres, but not Docker
02:16:48 <bahamas> jgt: do you just install postgres on your development system?
02:17:45 <bahamas> I just found out it's easy to install postgres with nix. now I need to figure out how I can do everything with nix and take stack out of the equation
02:22:49 <dminuoso> Taneb: What's the usefulness of "free/forgetful" then?
02:24:04 <Taneb> They're a pattern that we humans can spot with our human eyes and human brains
02:24:35 <dminuoso> Taneb: But is that pattern not already captured by the adjunction itself?
02:24:36 <Taneb> And it's easy to describe, eg. "the forgetful functor Group -> Set"
02:24:55 <Taneb> In a way that's more intuitive than "Some functor Group -> Set which is a right adjoint"
02:26:20 <dminuoso> Well forgetfulness at least is a property that could exist without an adjunction - I could talk about it in terms of non-faithful functors.
02:26:57 <maerwald> how do you build "setup" binary with debug symbols?
02:27:39 <dminuoso> Taneb: I guess what Im trying to ascertain, is whether free/forgetfulness is just a different/intuitive angle to think about adjunctions in general.
02:28:17 <dminuoso> That is, could one say "a free functor is just a left-adjoint functor" and "a forgetful functor is a right adjoint"?
02:28:41 <dminuoso> (The definitions Ive seen rather mix both together in some "a free functor is a left-adjoint to a forgetful functor" and "a forgetful functor is a right adjoint to a free functor", giving me no useful definition.
02:28:59 <dminuoso> Am I making any sense here?
02:30:36 <Taneb> More or less, it's valid to think of a free functor as simply a left adjoint and a forgetful functor as a right adjoint
02:34:44 <jgt> bahamas: yeah, I do everything with Nix
02:35:31 <jgt> and I'm not using Stack
02:35:47 <jgt> (not that I think Stack is bad or anything, I just don't need it)
02:36:06 <jgt> bahamas: also, I'd recommend against using yesod-devel if you can help it
02:36:10 <jgt> it's craaaaazy slow
02:37:00 <bahamas> jgt: what should I use instead?
02:37:08 <jgt> bahamas: much quicker just to use GHCi
02:38:02 <bahamas> jgt: ok. thanks for the tips! you still build with cabal, right?
02:38:33 <jgt> bahamas: all Haskell projects use cabal
02:38:44 <jgt> I don't use the cabal-install tool directly; maybe Nix uses that under the hood
02:39:21 <bahamas> jgt: I meant that you run cabal new-build. ah, so you use cabal2nix to generate the nix files and build everything with nix, right?
02:39:28 <jgt> correct
02:39:44 <jgt> and here is my .ghci file http://ix.io/1KPT
02:40:23 <bahamas> jgt: you set that in the project or in HOME?
02:40:27 <jgt> and my shell.nix http://ix.io/1ODS
02:40:46 <jgt> I use per-project .ghci files
02:41:12 <bahamas> ok
02:42:02 <jgt> you'll also want to modify your app/DevelMain.hs
02:42:08 <jgt> it needs foreign-store
02:42:31 <jgt> here's mine: http://ix.io/1ODT
02:43:53 <jgt> hopefully that's enough to get you going
02:44:10 <dminuoso> bahamas: I use nix-shell to provide cabal/GHC/native libraries in the required versions and then build the project itself with ⌜cabal v2-*⌝ - so that's an option as well.
02:44:50 <bahamas> dminuoso: that's what I was thinking of doing. I remember something about nix not caching built modules while cabal does. is that still the case?
02:45:06 <bahamas> jgt: thanks for the examples!
02:47:26 <dminuoso> bahamas: nix shares build modules as much as v2-* does.
02:47:32 <dminuoso> bahamas: In fact, cabal v2-* is nix-inspired.
02:50:15 <dminuoso> My main reason for doing this is because it was less Alice in the Wonderland for me. At some point I just couldn't go down the nix rabbit hole any further.
02:53:25 <bahamas> dminuoso: so what is says here about incremental compilation doesn't apply any more? https://github.com/Gabriel439/haskell-nix
02:54:37 <dminuoso> bahamas: Ah that's a different issue. What I meant is, if you have a dependency on some package `foo` at some version - then nix will reuse the built version from the store instead of rebuilding it from scratch.
02:55:15 <bahamas> ah, yes. that I know
05:36:28 <dminuoso> Mmm, is there a way to take some servant type and transform it in such a way to replace all occurences of `NoContent` with `()`?
05:37:09 <alp> yes, with a type family
05:37:45 <alp> type family NoContentToUnit (api :: *) :: *
05:38:49 <dminuoso> alp: So there's no typeclass mechanism that would do this for me?
05:39:13 <alp> something ready to you use? nope, not yet
05:39:31 <alp> we could offer a generic ReplaceResponse type family or something
05:39:53 <alp> it's just never been requested, IIRC
05:40:19 <dminuoso> I see. What's the motivation behind ⌜NoContent⌝ over ⌜()⌝ if you don't mind my asking?
05:40:52 <dminuoso> It kind of forces me to issue ⌜pure NoContent⌝ in a lot of places, which seems slightly inconvenient.
05:43:40 <alp> dminuoso, https://github.com/haskell-servant/servant/pull/276 see this PR and the issues it links to
05:48:02 <edwardk> dminuoso: re forgetful functors folks basically recognize those by them just throwing away “structure” somehow then define free and cofree relative to that
05:49:10 <edwardk> dminuoso: the sloppy part is that you can eventually see how _every_ right adjoint works kind of like this but “forgetting” a comonad seems more forgetful than constructing a cofree one
05:54:41 <dminuoso> edwardk: Then I wonder, is calling a right adjoint a forgetful functor similar how we call some F:C^op -> Set a presheaf on the basis of some particular perspective of it?
05:58:06 <dminuoso> nlab calls this "concept with an attitude", heh. :)
05:58:17 <jgt> is there a traversal for bifunctors?
05:58:39 <edwardk> you may need to seriously contort your thinking to see some right adjoints as “forgetful” so yeah
05:58:51 <jgt> I was thinking of something like `traverse (bimap id id) (Just 1, Just 2)` to hopefully get `Just (1, 2)`
05:59:00 <edwardk> jgt: Data.Bitraversable
05:59:13 <jgt> ah. Thanks edwardk!
05:59:22 <edwardk> jgt is in base these days, bifunctors before that
06:00:06 <jgt> as of when? I'm guessing not 8.4.3
06:00:17 <merijn> jgt: As of 8.0 or 8.2, afaik
06:00:20 <jgt> oh right
06:02:58 <jgt> basically I wanted to write this comment: https://news.ycombinator.com/item?id=20449507
06:03:10 <jgt> because I am fighting the good fight
06:03:29 <dminuoso> edwardk: Do you have any example from the top off your head?
06:04:34 <edwardk> dminuoso: well, the one i gave. a forgetful functor from the category of comonads to the category of functors that has a right adjoint, which gives you the cofree comonad.
06:05:06 <dminuoso> Ah, indeed. Cheers, I shall ponder about this for a while.
06:07:35 <edwardk> dminuoso: there are other structures. like if you think of a forgetful functor U that takes haskell Functor instances and forgets the Functor, just remembering the type constructor of kind * -> *, you get a left adjoint F -| U to that so that when you round trip through that adjunction you get coyoneda as FU, and a right adjoint G, such that U -| G to that so that when you round trip through that adjunction you get yoneda as UG
06:07:54 <SquidDev> jgt: There's also bisequence, which is equivalent to 'bitraverse id id`.
06:07:57 <edwardk> So Yoneda is "Cofree Functor"
06:08:05 <jgt> SquidDev: nice!
06:08:56 <edwardk> dminuoso: http://comonad.com/reader/2015/categories-of-structures-in-haskell/ might help
06:12:44 <edwardk> dminuoso: to get a better sense of it, think of why the free monad is the 'free' monad. You need to look at the forgetful functor U that takes monads to functors. Free -| U, so monad homomorphisms (Free f ~> m) are in one to one correspondence with natural transformations (f -> Um), or rather a natural transformation f to the underlying functor that m is made out of. It says something about how all monad homomorphisms from Free f must be
06:12:44 <edwardk> constructed.
06:12:55 <edwardk> similarly you get a relationship for the cofree comonad.
06:13:12 <edwardk> You have a forgetful functor U that forgets the comonad part and just remembers the underlying functor
06:14:31 <edwardk> and comonad homomorphisms (w -> Cofree g) are all in one to one correspondence with natural transformations (U w -> g) . natural transformations from functor underlying the comonad w to the functor g.
06:14:52 <edwardk> U is clearly "forgetful" in the colloquial sense, but it has a right adjoint nonetheless
06:15:33 <edwardk> (note both of these Us are different functors, I'm just calling them U by convention)
06:15:48 <edwardk> dminuoso: is that helping?
06:15:54 <dminuoso> Oh yeah, I'm fine with reusing letters here.
06:16:52 <edwardk> Another example.
06:17:39 <edwardk> You can take a functor from C -> C*C that computes the diagonal. f takes objects to pairs of objects, arrows to pairs of the same arrow.
06:17:49 <edwardk> this doesn't sound forgetful in that it is "constructing" something
06:18:00 <edwardk> but you can view it as forgetful by treating C*C as C^2 here
06:18:07 <edwardk> then it is "forgetting" the index
06:18:15 <edwardk> and just giving you constant functors
06:20:02 <edwardk> now we can look at the left and right adjoints to this forgetful Δ and you get Σ -| Δ -| Π
06:20:14 <dminuoso> edwardk: Hold on one sec, which index exactly is that forgetting?
06:20:30 <edwardk> view it as C -> [I, C] -- where it forgets to use I for anything
06:20:42 <edwardk> the constant functor
06:20:43 <dminuoso> Ohh.
06:20:48 <dminuoso> I see what you are on about.
06:21:03 <edwardk> this is what i mean about how you may need to contort your thinking to see some of these as forgetful
06:22:19 <edwardk> colim -| Δ -| lim
06:23:54 <edwardk> you can look at post composition by a functor p, which you can squint at as forgetting all the rest of the functors or some nonsense and at its left and right adjoints to find Ran p and Lan p respectively
06:24:17 <edwardk> not sure how useful these other examples are for you
06:24:21 <edwardk> just trying to be complete
06:24:54 <dminuoso> edwardk: Oh this is very helpful. Im beginning to understand why you say that ones thinking may need some contortion. 
06:25:53 <dminuoso> edwardk: The diagonal functor example seems to have made most of the impact. I really need to let this sink in and think about it tonight.
06:25:58 <edwardk> i tend to just think in terms of "obviously forgetful" and then define free/cofree relative to that, and just smile and nod when folks insist their other things are "forgetful"
06:26:16 <dminuoso> Yeah this makes sense.
06:26:48 <edwardk> basically oh it is a right adjoint, ok, there must be some sense in which you are correct, so let's move on
06:28:42 <dminuoso> So freeness is really just a perspective of a left adjoint when you can attribute this "obvious forgetfulness" to its right adjoint.
06:29:11 <dminuoso> Where `free` is just in relation (via an adjunction) to `forgetful`
06:29:43 <dminuoso> It's still somewhat annoying to not be able to define this in formal terms.
06:29:58 <edwardk> yep
06:31:28 <edwardk> like i said, i tend to stick to "obviously forgetful" in the sense that you can view, say, the functor from comonads that takes objects (W,extract,extend) to W as just "forgetting" part of the object, and taking a comonad homomorphism to a natural transformation is just forgetting some properties of the mapping.
06:32:56 <edwardk> but then you start needing to talk about how forgetful a thing is, is it forgetting stuff, structure, properties. etc.
06:33:02 <edwardk> http://math.ucr.edu/home/baez/qg-spring2004/discussion.html might be insightful for you
06:34:08 <edwardk> https://ncatlab.org/nlab/show/stuff,+structure,+property is the grown-up ncatlab version of that link, but i think the original discussion is easier to follow
06:38:52 <dminuoso> edwardk: Thank you, the resources you mentioned should be an interesting read. You have been more than helpful. :)
06:44:57 <wroathe> Not that foldl <|> isn't concise enough, but is there a function that already implements alternative over arrays?
06:45:17 <merijn> :t asum
06:45:19 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:45:53 <wroathe> merijn: gracias
06:47:23 <wroathe> Oh, it's even in Data.Foldable. I should've just looked there before asking IRC D:
07:03:25 <dmwit> :t (getAlt.) . foldMap . (Alt.)
07:03:28 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Foldable t, Monoid (Alt f a1)) => (a2 -> f a1) -> t a2 -> f a1
07:04:16 <dmwit> That Monoid (Alt f a1) constraint becomes Alternative f if it can figure out that f :: * -> *.
07:04:25 <dmwit> (Is there a way to do "kind applications"?)
07:05:48 <Taneb> dmwit: it infers Alternative for me (GHC 8.6.5)
07:06:00 <Taneb> Ah, not with PolyKinds
07:06:34 <Taneb> dmwit: but @Type works on the first getAlt
07:08:32 <dmwit> :t (getAlt @Type .) . foldMap . (Alt.)
07:08:38 <lambdabot> error:
07:08:38 <lambdabot>     Pattern syntax in expression context: getAlt@Type
07:08:38 <lambdabot>     Did you mean to enable TypeApplications?
07:08:42 <dmwit> Oh, sure.
07:08:50 <dmwit> Anyway, nice!
07:09:08 <dmwit> % :t (getAlt @Type .) . foldMap . (Alt.)
07:09:08 <yahb> dmwit: (Foldable t, Alternative f) => (a1 -> f a2) -> t a1 -> f a2
07:09:14 <dmwit> yay
07:45:47 <moet> what's `flip (.)`? is there a tool like hoogle that i can use to answer this kind of question online?
07:46:19 <dminuoso> moet: Refer to the implementation of `flip`
07:46:34 <dminuoso> moet: And if need be, the implementation of `(.)`
07:46:42 <moet> dminuoso: no, i'm not asking what it does..
07:46:50 <dminuoso> @src flip
07:46:50 <lambdabot> flip f x y = f y x
07:46:54 <lyxia> > flip (.) f g x
07:46:58 <lambdabot>  error:
07:46:58 <lambdabot>      • Could not deduce (FromExpr b0) arising from a use of ‘f’
07:46:58 <lambdabot>        from the context: FromExpr c
07:47:03 <lyxia> > flip (.) f g x :: Expr
07:47:09 <lambdabot>  error:
07:47:09 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘f’
07:47:09 <lambdabot>        prevents the constraint ‘(FromExpr b0)’ from being solved.
07:47:12 <moet> i'm asking if there's already a defined `flip (.)` out there
07:47:13 <dminuoso> moet: flip takes a function and two arguments, and applies them in the flipped order. So you could think of `flip` as taking a function and flipping its arguments aroud. :)
07:47:22 <moet> dminuoso: i'm not asking what it does
07:47:48 <dminuoso> moet: Ah I see. Then using hoogle to search for the resulting type signature is your best bet.
07:47:49 <moet> i'm asking what the "name" of `flip (.)` and in which package a canoncal implementation might be found
07:47:57 <lyxia> There's Control.Category.>>>
07:48:00 <moet> yeah .. i did https://hoogle.haskell.org/?hoogle=%28a+-%3E+b%29+-%3E+%28b+-%3E+c%29+-%3E+a+-%3E+c&scope=set%3Astackage
07:48:15 <moet> Control.Arrow.>>> has the wrong precendence
07:48:22 <moet> I'll look at Control.Category.>>>
07:48:41 <moet> none of the hoogle results looked canonical
07:48:42 <dminuoso> moet: You could of course define it on the spot.. :)
07:49:08 <lyxia> it's the same as Control.Arrow.>>> 
07:49:11 <dminuoso> moet: Well "canonical" might mean "is in base", in which case (>>>) is the only comparable operator.
07:49:35 <moet> yeah, that's all i could uncover ..so i came hare
07:49:43 <moet> came here* ....anyway, thanks for confirming!
07:50:00 <wroathe> Anyone know where the syntax Record{..} is documented?
07:50:06 <wroathe> I can't seem to find it in the user guide
07:50:08 <moet> RecordWildCards
07:50:16 <wroathe> Thanks
07:50:31 <moet> check user guide under extensions
07:51:11 <wroathe> Found it. Thanks!
07:51:34 <moet> woo! you should also consider using NamedFieldPuns instead because RecordWildCards can lead to some unexpected things
07:52:02 <wroathe> Yeah, jury is out for me on this. I'm just reading someone elses code and came across it
07:52:22 <wroathe> Now to figure out my stance on whether or not it's a good idea :P
07:52:48 <moet> RecordWildCards sometimes reduces readability.. good luck!
07:53:52 <dminuoso> moet: RecordWildCards has, in my opinion, one major valid usecase. And that's when you have some monadic/applicative code that builds up to some large record that you want to return in the end.
07:53:59 <dminuoso> In particular if you have the same type in the record multiple times.
07:54:26 <dminuoso> e.g. ⌜do {a <- foo1; b <- foo2; c <- foo3; ...; pure T{..}}⌝
07:54:53 <wroathe> can't you just do pure $ T a b c ...
07:55:12 <wroathe> Although {..} does have the advantage of not needing to remember order
07:55:25 <wroathe> field order*
07:55:39 <dminuoso> wroathe: It's rather about ensuring that screwing up the order is much harder.
07:56:23 <dminuoso> wroathe: ⌜f <$> g <*> h <*> i <*> j <*> k⌝ if ⌜f⌝ accepts two Int next to each other, then mixing up the order is really easy to do and really hard to spot.
07:56:29 <wroathe> Yup
07:57:09 <moet> yeah, constructing things with RecordWildCards is very convenient for the writer & maintainer, but maybe annoying to understand for the reader
07:57:38 <wroathe> Well, it just seems like a syntactic extension that just be part of the language proper
07:57:39 <moet> deconstructing things with RecordWildCards is very convenient for the writer but maybe annoying for the maintainer and for the reader :P
07:57:51 <wroathe> The fact that it's an extension makes it more difficult for the reader
07:58:10 <dminuoso> moet: Reconstructing thiings with RecordWildCards is indeed a recipe for bugs. :)
07:58:14 <wroathe> that should just*
07:58:16 <dminuoso> Or debugging annoyance.
08:01:12 <dminuoso> 16:54:31          wroathe | can't you just do pure $ T a b c ...
08:01:27 <dminuoso> wroathe: Yes you can. If you have 20 fields and each field name is moderately long, this becomes very repetitive for no good reason.
08:01:57 <dminuoso> And again introduces the same ordering problems.
08:02:35 <arianvp> I'm trying to use hpc for a long running service. but when I terminate the service the .tix file gets corrupt sometimes
08:02:47 <dminuoso> In principle RecordWildCards for returning data types should not really hamper readability.
08:02:58 <arianvp> how do I do coverage reports for haskell binaries that dont exit by themselves?
08:03:01 <wroathe> dminuoso: Yeah, I already backpedaled on that statement
08:03:06 <dminuoso> wroathe: Oh fair enough.
08:04:58 <moet> arianvp: i'm not familiar with hpc.. aren't coverage reports usually produced as part of tests, not as part of production/long-running processes?
08:05:15 <arianvp> moet: both
08:05:30 <arianvp> so if you compile with coverage support on, then an executable will produce a coverage report
08:05:35 <arianvp> regardless if it's a test or not
08:06:09 <arianvp> this is useful for example when you have a http service, and you have some external smoke test
08:06:28 <arianvp> test-suites just happen to be specialised executables
08:08:10 <moet> hmm.. ok, i'm not familiar with that use case or the library itself, so i'll defer to somebody else to answer.. thanks for explaining
08:09:59 <coldpress> does comparing two infinite streams by bisimulation diverge?
08:14:53 <EvanR> > min (repeat 2) (repeat 1)
08:14:53 <heatsink> I suppose it terminates if the streams are not equivalent, and diverges if they are equivalent
08:14:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:16:57 <EvanR> > min (repeat 1) (repeat 1)
08:17:04 <lambdabot>  mueval: ExitFailure 1
08:17:08 <EvanR> > min (repeat 1) (repeat 1)
08:17:15 <lambdabot>  mueval: ExitFailure 1
08:17:21 <EvanR> o_O
08:17:46 <EvanR> what bollocks is this
08:18:19 <heatsink> min (replicate 1000000 1 ++ [2]) (replicate 1000000 1 ++ [1])
08:18:29 <heatsink> > min (replicate 1000000 1 ++ [2]) (replicate 1000000 1 ++ [1])
08:18:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:18:34 <haskellNewv> Hey, I want to write a client for a json api and Servant looks promising for that. However, the API works in a weird way - all queries go to the same url (domain.com/api) and you supply an argument "cmd=apiResourceYouWant". How can I still modify/extend servant client with this in mind?
08:19:44 <coldpress> > (replicate 10000 1 ++ [2]) (replicate 10000 1 ++ [1])
08:19:48 <lambdabot>  error:
08:19:49 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
08:19:49 <lambdabot>                    with actual type ‘[Integer]’
08:20:01 <coldpress> > (replicate 10000 1 ++ [2]) == (replicate 10000 1 ++ [1])
08:20:03 <lambdabot>  False
08:20:39 <EvanR> comparison isn't decidable for infinite stream, but min and max ought to be, if defined right
08:21:45 <tdammers> how?
08:22:18 <EvanR> similarly exact reals have decidable min and max
08:24:56 <Shoubit> Won't it just never terminate if they're exactly the same (undecidable?)
08:25:12 <EvanR> if x[i] < y[i], then x < y. ditto for >. otherwise check x[i+1] and y[i+1]
08:25:49 <EvanR> this defines an undecidable ordering, but it still lets you define min and max by just doing zipWith min or zipWith max
08:25:52 <tdammers> EvanR: but if ∀ i. x[i] == y[i], then that will never terminate
08:26:08 <EvanR> yeah compare would freeze
08:26:19 <tdammers> so would min
08:26:22 <EvanR> no
08:26:35 <tdammers> oh wait, I see what you mean
08:26:44 <EvanR> since the answer is not a bool
08:27:08 <EvanR> or whatever
08:27:38 <tdammers> it will produce incorrect results though
08:27:51 <tdammers> > min [1,3,2] [2,1,1]
08:27:51 <EvanR> the target space is not discrete so it allows interesting results
08:27:55 <lambdabot>  [1,3,2]
08:28:03 <tdammers> > zipWith min [1,3,2] [2,1,1]
08:28:05 <lambdabot>  [1,1,1]
08:28:11 <Shoubit> I that's productivity of corecursion? Does productivity make it decidable?
08:28:40 <EvanR> ok zipWith min is wrong
08:29:23 <EvanR> need to whip up a snazzy foldr
08:31:33 <EvanR> haskell still has no paste site?
08:33:05 <mmaruseacph2> it had lpaste.net
08:33:30 <mmaruseacph2> still has but now needs login and I'm not going to install Slack to get account
08:33:34 <lortabac> haskellNewv: probably the simplest way would be to define a Cmd sum type (with a FromHttpApiData instance) representing all the possible commands, and then have a single handler that handles all the different constructors
08:34:35 <EvanR> https://gist.github.com/evanrinehart/b014ca31f2a949a90695f1456de27887
08:37:48 <haskellNewv> lortabac: I'm not entirely sure what you mean by that, could you perhaps show a small example? Thanks a lot
08:41:20 <EvanR> tdammers: hey are you still working in clojure
08:43:34 <tdammers> EvanR: nope, not if I can avoid it, and I generally can these days
08:43:44 <EvanR> nice
08:45:21 <tdammers> I'd be a lot more comfortable if clojure had turned out being a refreshing, nice experience, but it hasn't
08:46:36 <EvanR> i can see that. I still wonder if haskell would be a refreshing nice experience in a "work" setting
08:46:55 <EvanR> i mean other than secret one off scripts that arent actually approved
08:47:02 <lortabac> haskellNewv: something like this: https://pastebin.com/b0ZBLST4
08:47:38 <coldpress> EvanR: illegal classified scripts
08:47:54 <coldpress> :^)
08:47:54 <tdammers> well, haskell *is* a refreshing nice experience in a work setting for me
08:48:10 <lortabac> EvanR: it has been in my experience FWIW
08:48:12 <EvanR> nice so you convinced them 
08:48:47 <EvanR> do you use an alternative prelude?
08:50:07 <tdammers> I didn't convince anyone, I joined a Haskell-only company
08:50:14 <EvanR> ah
08:50:36 <coldpress> tdammers: which one is that?
08:50:42 <tdammers> well-typed
08:52:48 <johnw> Did pandoc used to handle asciidoc, but now it doesn't?
08:53:01 <johnw> https://pandoc.org/demos.html shows an example of translating asciidoc, but it's not in the --list-input-formats
08:55:18 <tdammers> I think --list-input-formats might be incomplete
08:55:22 <tdammers> not sure though
08:55:32 <johnw> when I try anyway, it claims "no reader: asciidoc"
08:55:50 <tdammers> hmm
08:55:55 <johnw> yeah, it's odd
08:55:59 <tdammers> or maybe the library supports it, but the cli doesn't
08:56:01 <johnw> I was hoping to use pandoc to "wash" some asciidoc files
08:56:43 <tdammers> hmm, the current hackage version shows an asciidoc writer, but no reader
08:57:45 <tdammers> ah yes, right - the demo showcases *output* formats, not *input*
09:12:06 <wroathe> Is there a class in Base that has a binary operation that picks the left value, unless the left value is "falsy", then pick right?
09:12:24 <yitz> "or"
09:12:31 <yitz> Sorta...
09:13:16 <wroathe> Specifically I'm thinking about a more general form of: Nothing `pick` b = b; a `pick` _ = a
09:13:24 <yitz> if a then a else b ?
09:13:50 <heatsink> :t maybe
09:13:52 <yitz> https://wiki.haskell.org/If-then-else
09:13:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:14:09 <dmwit> wroathe: <|>
09:14:16 <dmwit> > Nothing <|> Just "hi"
09:14:20 <lambdabot>  Just "hi"
09:14:23 <dmwit> > Just "hi" <|> Just "bye"
09:14:30 <lambdabot>  mueval-core: Time limit exceeded
09:14:33 <dmwit> ...
09:14:34 <dmwit> > Just "hi" <|> Just "bye"
09:14:37 <wroathe> Yup
09:14:38 <lambdabot>  Just "hi"
09:14:47 <wroathe> But that doesn't work for 
09:14:51 <wroathe> > Just 3 <|> Just 4
09:14:56 <lambdabot>  Just 3
09:15:01 <wroathe> :O
09:15:02 <dmwit> Looks like it works to me?
09:15:54 * dmwit thought you'd pull out the list instance and say it doesn't do what you want =P
09:16:01 <dmwit> > [] <|> "hi" -- good
09:16:07 <lambdabot>  "hi"
09:16:11 <wroathe> Ok, it's time to take a break
09:16:13 <dmwit> > "hi" <|> "bye" -- maybe not what you want, maybe yes what you want, depending
09:16:20 <lambdabot>  mueval-core: Time limit exceeded
09:16:20 <wroathe> for a second I was thinking the implementation of <|> was the same as <> for Maybe
09:16:24 <dmwit> ffs
09:16:25 <dmwit> > "hi" <|> "bye" -- maybe not what you want, maybe yes what you want, depending
09:16:28 <lambdabot>  "hibye"
09:16:31 <wroathe> So ignore me
09:17:05 <dmwit> int-e: Are you still the one in charge of lambdabot? If so, do you think you could look into why even really simple stuff is timing out?
09:30:46 <haskellNewv> lortabac: Still don't quite get it, I mean I have this part that I copied from you http://ix.io/1OFt but not sure about the Handlers and how they work
09:30:56 <int-e> dmwit: there is no such thing as a "simple thing" here; lambdabot invokes mueval, which loads whatever is currently in L.hs, including all the interface files and shared libraries attached to that. That takes 2s, best case; unfortunately, it takes much longer sometimes. (As I said yesterday, lambdabot is running in a VPS, so there's outside memory pressure not under my control, and I believe...
09:31:02 <int-e> ...that's a major factor. Another factor is that sometimes, two mueval processes are running at the same time which slows both of them down.
09:38:49 <solonarv> int-e: hm, could it be modified/rewritten to keep a persistent interactive session (via the GHC API) and add to that as needed? surely that would be a lot faster
09:44:08 <int-e> solonarv: maybe. but how do you keep memory use under control then?
09:45:01 <solonarv> you could still run the part that interfaces with the GHC API in a separate process and use some form of IPC
09:45:19 <solonarv> then the usual mechanisms for limiting memory usage should work
09:45:47 <dmwit> Can we... just bump up the length of the timeout?
09:46:05 <int-e> solonarv: wouldn't that just replace one source of unreliability with another though...
09:50:01 <int-e> solonarv: I've thought about this... my ideal solution would be to load a well controlled state (lambdabot's Pristine.hs) using the ghc API, then suspend the RTS completely in a way that it can be worken up again after doing a fork()...
09:50:21 <lavalike> nice idea
09:51:23 <phadej> bandali: ping, finally oleg.fi certificate got A-grade from ssllabs's ssltest.
09:52:49 <phadej> bandali: (I accidentally tested setup against production let's encrypt server, so had to wait until rate-limiter cools down)
09:53:48 <int-e> solonarv: But the RTS is an intricate beast... I saw that it uses pipes to communicate between threads, among other things. So I got discouraged before I even started.
09:55:16 <int-e> dmwit: I have actually bumped the timeout a bit (closer to 8 seconds now). Maybe it'll help.
09:55:45 <bandali> phadej, nice! i’ll regenerate the planet and see if the error i used to get for your site goes away
09:56:26 <dmwit> int-e: Thanks!
09:56:39 <int-e> There may be a low hanging fruit here... lambdabot should really sequentialize its own mueval invocations.
09:58:05 <solonarv> that too!
10:19:42 <duncan> In Data.Time, the UTCTime type records a time of day as well as Day (which, as I understand it, is a given modified Julian day)
10:19:53 <duncan> Why is this? Is it not sufficient to just record TimeOfDay?
10:20:27 <duncan> It appears to be the same for LocalTime - it seems counter-intuitive given we may not have that information, at least to my mind.
10:21:04 <haskellNewv> Well, time consists of a date and a time on that date. the UTCTime type is meant for an absolute point in time.
10:21:45 <duncan> So it's more accurate than just 'a given time of the day'?
10:22:33 <phadej> yes
10:22:40 <phadej> 03:00 can be twice in a local time
10:22:41 <phadej> DST
10:23:29 <phadej> (and/or not-continuous)
10:23:38 <duncan> So it would make more sense to consider it as analagous to a timestamp?
10:23:58 <phadej> UTCTime is a timestamp yes (a point in time)
10:24:40 <phadej> for which you can define reasonable diffUTCTime function
10:24:52 <phadej> yet, diffing LocalTime (or TimeOfDay) doesn't make sense
10:26:52 <phadej> it might help to not look inside of UTCTime but treat it as an opaque type
10:27:11 <phadej> (which you need to convert to localtime to show to humans, even the localtime is in UTC timezone)
10:29:35 <phadej> (concept of a day is quite difficult, if you try to be pedantic, results in e.g  https://en.wikipedia.org/wiki/Anywhere_on_Earth things)
10:30:59 <phadej> sadly, wikipedia doesn't say whether AOE was ever something else than UTC-12:00 (e.g. if -13:00 or something like that timezone existed)
10:33:42 <duncan> I suppose it would be appropriate to express my collections of hours, minutes and seconds in terms of diffTime, then.
10:33:56 <duncan> or DiffTime, to be exact
10:35:29 <merijn> Oooh...time zones, one of my favourite topics to be pedantic about!
10:35:41 <merijn> What was the original question?
10:36:52 <merijn> Because "you need to convert to localtime to show to humans" indicates "storing as UTC", which, is wrong in many cases
10:41:12 <gentauro> merijn: always store as UTC
10:41:20 <gentauro> and format date based on users location
10:41:35 <gentauro> otherwise store date as ISO-8601
10:41:45 <gentauro> everything else, it's a wrong approach
10:41:52 <merijn> gentauro: *bzzt*
10:41:59 <merijn> gentauro: This is incorrect
10:42:13 <merijn> gentauro: It is, in fact, *impossible* to correctly store a future date as UTC
10:42:33 <merijn> You can *only* store in UTC if the date/time is in the past
10:43:45 <phadej> depends what you are you storing
10:44:02 <merijn> Because the UTC time of a date in the future cannot be known ahead of time, since timezones can (and do) change between date of storing and the actual event
10:44:18 <vaibhavsagar> merijn: because of leap seconds?
10:44:27 <merijn> vaibhavsagar: No, because timezones are not fixed
10:44:57 <phadej> merijn: you confuse everyone by mixng up storing "moment of time" and "dates"
10:45:01 <merijn> vaibhavsagar: For example, the whole of the EU is considering abolishing DST in the coming 2 years, so a good number of countries will change their timezone
10:45:05 <vaibhavsagar> isn't UTC the timezone?
10:45:27 <merijn> vaibhavsagar: No, UTC time is timezone less
10:45:30 <vaibhavsagar> how does that change the UTC datetime?
10:45:58 <vaibhavsagar> oh, I think I understand now
10:46:26 <merijn> vaibhavsagar: Because *as far as we know right now* "July 20th, 2023 at 15:00" in Amsterdam is at UTC+2, but it might not be in 2 years :)
10:46:26 <shafox> In which cases I should be using StandaloneDeriving ? Is there any effect of using StandaloneDeriving language extension ? 
10:46:42 <merijn> vaibhavsagar: So you can't correctly store that timepoint in UTC *now*
10:46:55 <phadej> merijn: yo should have started with that
10:47:10 <phadej> "store future _calendar dates_ in their timezone"
10:47:15 <merijn> vaibhavsagar: Once the date has passed you the UTC point is unchangeable (you know what the timezone was at that moment"
10:47:16 <phadej> calendar dates /= moments of time
10:47:26 <merijn> phadej: Debatable
10:47:39 <phadej> TL;DR read the backlog,don't confuse people
10:47:51 <merijn> I would consider "15:00, July 20, 2023" a moment in time
10:48:02 <merijn> Which moment in time isn't fixed yet
10:48:15 <phadej> yes, ambiguous moment of time
10:48:17 <gentauro> merijn: I live in CPH
10:48:20 <merijn> phadej: I don't have a backlog, hence why I asked what the original question was
10:48:26 <gentauro> right now we are in CEST (UTC + 2)
10:48:35 <gentauro> but normally we are in CET (UTC + 1)
10:48:39 <phadej> merijn: and you didn't wait for an answer, do you?
10:48:52 <merijn> phadej: gentauro commented, I replied to his comment
10:49:37 <phadej> I'm not sure this derail of conversation helped with originalquestion (it didn't, but now this is meta, so I'll leave)
10:49:38 <solonarv> shafox: you should use it when you want to write a so-called "standalone deriving instance". Its only effect is that it allows you to write these instances.
10:49:51 <dmwit> shafox: Have you tried consulting the fine documentation...?
10:50:38 <solonarv> a standalone deriving instance looks like this: deriving instance Stuff => Class Foo; and this is mostly equivalent to adding 'deriving Class' to Foo's definition
10:50:49 <shafox> dmwit, I have. I am just not sure where to use it. 
10:51:05 <phadej> when GHC is silly (e.g deriving instances for GADTs)
10:51:12 <dmwit> When the time comes, you will know. =P
10:51:18 <merijn> shafox: You use it when you *have* to, because deriving breaks in a bunch of cases
10:51:33 <dmwit> (Because the compiler will tell you.)
10:51:38 <solonarv> yes: the main use is specifying additional constraints that are needed for the instance (the 'Stuff' in the template I posted above)
10:51:58 <solonarv> GHC does in fact tell you this when you are in a situation where it is needed.
10:52:15 <shafox> merijn, I have a record which is nested, and need to use equality for the record, however ghc complains the nested ones are not of Eq class. 
10:52:37 <dminuoso> shafox: That means you need to also define or derive Eq instances for those types.
10:53:08 <dminuoso> Say if you have `data Foo = Foo { someStuff :: Stuff } deriving Eq` then your datatype Stuff also needs to have an `instance Eq`
10:53:10 <merijn> ^^ that, or handwrite the Eq instance using a custom comparison for the nested records
10:53:17 <shafox> alright. Thanks dminuoso merijn solonarv :) 
10:54:49 <shafox> merijn, I only need one parameter from the record to be checked btw. 
10:55:37 <merijn> shafox: You can always handwrite it to do what you need :)
10:56:15 <dminuoso> shafox: `deriving` is just a mechanism to have GHC generate some sensible default instances. If you need a behavior that differs from the "deriving" generated behavior, then by all means write your own instance.
10:56:55 <shafox> However I still to derive the nested records Eq.
10:57:40 <merijn> If you need to compare those, yes
11:02:54 <halogenandtoast> Can anyone explain why this (https://gist.github.com/halogenandtoast/583a0586c78ec401707355cd1867d678) doesn't work, but it would work if we wrapped our Chuch type in a newtype and did explicit wrapping/unwrapping
11:03:00 <halogenandtoast> where is the type system breaking down?
11:09:18 <dada_cetacean> is cases .. of the correct way to define a map out of a custom datatype foo = a | b | c ... | d?
11:10:43 <hyperisco> dada_cetacean, yes
11:12:12 <dminuoso> hyperisco: the typesystem is not breaking down.
11:12:53 <dminuoso> hyperisco: The problem has to do with how forall quantification expands in type synonyms.
11:13:21 <infinisil> dminuoso: (you're pinging the wrong person)
11:13:32 <dminuoso> Oh shoot.
11:13:40 <dminuoso> It looked so right, but mixed them up.
11:13:47 <hyperisco> I was looking forward to seeing how long it would go
11:14:04 * halogenandtoast hides from dminuoso
11:15:14 <halogenandtoast> dminuoso: and there is no way to "fix" that aside from wrapping and unwrapping a newtype a la https://github.com/Risto-Stevcev/haskell-church-encodings/blob/master/RankNTypes/Church.hs#L145-L148 ?
11:15:14 <dminuoso> halogenandtoast: ahh wait, no I looked at it wrong. There's nothing wrong with the type systme.
11:15:22 <dminuoso> halogenandtoast: Heh. you just missed some backticks there ``
11:15:41 <dminuoso> halogenandtoast: Possibly?
11:15:44 <halogenandtoast> cpred is not infix, if that is what you mean
11:16:31 <dminuoso> halogenandtoast: Ah well then yeah. forall quantification is off.
11:17:09 <dminuoso> halogenandtoast: If you expand the type synonyms, you'll observe that `cpred :: (forall a0. (a0 -> a0) -> a0 -> a0) -> (forall a1. (a1 -> a1) -> a1 -> a1)
11:17:15 <halogenandtoast> but then I guess I don't understand why the newtype wrapper "fixes" it
11:17:29 <halogenandtoast> dminuoso: right
11:17:40 <dminuoso> Oh mmm.
11:17:59 <dminuoso> halogenandtoast: Perhaps I dont understand it well enough after all.
11:19:37 <dada_cetacean> what is the behavior of a function which is only defined on some, but not all constructors of a custom datatype?
11:24:59 <gabbiel> so i have this: let de :: (a -> a) -> (Int, Bool); de id = (id 3, id True)
11:25:15 <gabbiel> but it's giving me a type error because Int isn't a
11:25:35 <infinisil> dada_cetacean: It's a partial function then and will crash at runtime if an unimplemented branch is called
11:26:17 <infinisil> Fyi you can also just try this out yourself to know this
11:26:43 <solonarv> % let partial b = case b of True -> "okay"
11:26:43 <yahb> solonarv: 
11:26:48 <solonarv> % partial True
11:26:49 <yahb> solonarv: "okay"
11:26:53 <solonarv> % partial False
11:26:53 <yahb> solonarv: "*** Exception: <interactive>:26:17-40: Non-exhaustive patterns in case
11:27:00 <solonarv> dada_cetacean: a simple example ^
11:27:05 <gabbiel> shouldn't that code work, im confused
11:27:53 <solonarv> gabbiel: no; with the explicit forall inserted that type is de :: forall a. (a -> a) -> (Int, Bool)
11:28:05 <solonarv> which means that the caller of de chooses what 'a' should be
11:28:18 <solonarv> and the implementation of de has to work for any choice of 'a'
11:28:32 <solonarv> so it can't choose 'a' to be Int, or Bool
11:28:56 <solonarv> if you instead write the type: de :: (forall a. a -> a) -> (Int, Bool)
11:29:40 <solonarv> then de gets as an argument 'id :: forall a. a -> a', and since the implementation of de is calling 'id' it can choose 'a' to be whatever you want
11:30:25 <solonarv> conversely, this argument must be supplied (= implemented) by de's caller, and must work for all choices of 'a'
11:30:29 <gabbiel> what is this forall thing, i've never heard of it
11:30:45 <gabbiel> oh i see you inserted the forall inside and that made the code work?
11:31:51 <solonarv> the type you gave for 'de' is incorrect (because of what I explained in my first bunch of messages); I explicitly gave a different, correct type
11:32:42 <solonarv> very roughly, the placement of 'forall' is about who gets to choose what the type variables in a type stand for
11:32:49 <solonarv> I'll let someone else explain the details
11:33:59 <gabbiel> it makes sense to me now
11:35:09 <gabbiel> so everytime i call de i have to do this: de (id :: (forall a. a->a))
11:37:12 <gaze__> hey all, has anyone given much thought to parsing files in such a way that you can mostly generate the same file, with identical formatting, up to some patches?
11:37:36 <gaze__> in other words a parser A and "unparser" B such that B.A is idempotent
11:37:46 <gaze__> including whitespace, comments, etc.
11:38:13 <hyperisco> halogenandtoast, for what it is worth, I have also had higher rank types fail to type check
11:38:14 <wildtrees> gaze__, you would have to store all the "whitespace" in your parse tree that A generates I would guess 
11:38:20 <wildtrees> if it could be variable 
11:38:28 <hyperisco> halogenandtoast, I wasn't aware that newtyping could resolve the issue though so thans.
11:38:41 <wildtrees> could store it as a number maybe , if you dont allow tabs 
11:38:57 <nil> hi, is there any way to turn something like  f (\a -> g (\b -> h a b))  into something like  do { a <- f; b <- g; return (h a b) }  ?
11:39:01 <gaze__> wildtrees oh I see, that makes sense
11:39:14 <hyperisco> gaze__, reversible parsing and yes, there is a hackage package for that
11:39:35 <hyperisco> https://hackage.haskell.org/package/syntax is one
11:39:39 <nil> note that this would mean  (>>=) = ($)  , so  f id = f  , which looks impossible
11:44:28 <dada_cetacean> solonarv, thanks
11:45:20 <nil> nevermind, i'll read up on the relationship between monads and CPS -- seems like there's been a ton of writing on that subject
11:46:42 <hyperisco> one is an example of the other
11:57:25 <halogenandtoast> hyperisco: no problem! Just wish it wasn't the case, or that there was a clean way around it here.
11:58:56 <hyperisco> :t id :: a -> a
11:58:59 <lambdabot> a -> a
11:59:01 <hyperisco> :t id :: (forall a. a -> a) -> a -> a
11:59:03 <lambdabot> (forall a1. a1 -> a1) -> a -> a
12:00:04 <hyperisco> :t id :: ((forall a. a -> a) -> (forall a. a -> a)) -> a -> a
12:00:07 <lambdabot> error:
12:00:07 <lambdabot>     • Couldn't match type ‘a1’ with ‘forall a2. a2 -> a2’
12:00:07 <lambdabot>       ‘a1’ is a rigid type variable bound by
12:00:25 <halogenandtoast> Would ScopedTypeVariables help there?
12:00:34 <hyperisco> nope
12:01:54 <CrazyPython> I'm confused, I want to be able to set some global variables in main. How do I turn the variables into Monads?
12:02:08 <hyperisco> :t id :: ((forall a. a -> a) -> (forall a. a -> a)) -> (forall a. a -> a) -> (forall a. a -> a)
12:02:09 <lambdabot> error:
12:02:09 <lambdabot>     • Cannot instantiate unification variable ‘a1’
12:02:10 <lambdabot>       with a type involving foralls: (forall a. a -> a) -> a0 -> a0
12:02:10 <halogenandtoast> sounds like you want a ReaderT
12:02:14 <hyperisco> I think I was supposed to say that
12:02:24 <hyperisco> but w/e, something like that by my memory wasn't working
12:03:02 <halogenandtoast> CrazyPython: do you mean to say you just want variables you can pass around in main, or you want some sort of "global" state
12:03:13 <halogenandtoast> CrazyPython: let x = 5, would work in main for instance
12:03:41 <hyperisco> :t (\f -> f f) :: (forall a. a -> a) -> (forall a. a -> a)
12:03:42 <lambdabot> (forall a1. a1 -> a1) -> a -> a
12:03:45 <hyperisco> discovered after solving that
12:13:24 <dada_cetacean> is there a way to enable the (++) sugar for Data.Text.append?
12:13:43 <gabbiel> haskell is beautiful, but really hard to understand
12:13:45 <solonarv> gabbiel: oh, just saw that - no, whem calling it you don't need to go 'de (id :: ...)', 'de id' is just fine
12:13:52 <lyxia> import Prelude hiding ((++))  import Data.Text ((++))
12:14:13 <lyxia> ah it doesn't have ++
12:14:32 <lyxia> well there's no sugar, operators are identifiers.
12:14:38 <lyxia> (++) = Data.Text.append
12:14:56 <solonarv> dada_cetacean: my suggestion: write (<>) instead
12:15:02 <solonarv> that is already polymorphic
12:15:04 <gabbiel> so foldr' exists, that does mean that arguments are forced regardless of the function's strictness.
12:15:11 <lyxia> Oh yeah, that's much better
12:15:15 <solonarv> it exists, yes
12:15:25 <solonarv> I don't recall ever seeing a use for it though
12:15:44 <gabbiel> so in the case of foldr' const 0, it would evaluated like so  
12:15:50 <davean> dada_cetacean: use <>
12:15:57 <davean> dada_cetacean: <> is the general append operator
12:16:06 <gabbiel> const a (const b (const c 0))
12:16:28 <dada_cetacean> aha, it's monoid append
12:17:02 <davean> dada_cetacean: (++) is just legacy cruft.
12:17:27 <davean> Doesn't really have a reason to exist any more other than not breaking old code
12:17:31 <gabbiel> what other types of morphisms are used besides catamorphisms (foldr) and anamorphisms (unfoldr)
12:17:41 <gabbiel> within haskell?
12:18:23 <gabbiel> im debating wheter to learn stuff like zygomorphisms and mutumorphisms
12:19:55 <solonarv> (semigroup append actually, not monoid)
12:24:20 <infinisil> davean: It's a bit easier for beginners too I'd say
12:25:01 <solonarv> yeah, because you can use it without having to touch typeclasses at all
12:25:34 <halogenandtoast> gabbiel: pretty sure there are some isomorphisms too
12:27:12 <Boarders> is there an easy way to get the a get a pair of Word32 from a Word64?
12:28:40 <infinisil> Boarders: Well, for a fast and unsafe way, there would be https://hackage.haskell.org/package/base-4.12.0.0/docs/Unsafe-Coerce.html
12:29:36 <Boarders> if I do unsafeCoerce will that give me back (# Word32#, Word32 # ) on the underlying Word64#
12:29:49 <__monty__> gabbiel: You would surely not wanna miss out on zygohistomorphic prepromorphisms! https://wiki.haskell.org/Zygohistomorphic_prepromorphisms
12:29:55 <Boarders> or does it even make sense to do it at the level of unlifted types
12:30:35 <infinisil> Boarders: No idea, but this should be easy to find out by just testing it
12:30:48 <infinisil> Boarders: Alternatively there's https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bits.html for a safe but slower way
12:31:21 <Boarders> I know the bits library...
12:32:48 * infinisil looks if lens has to offer an Iso for that
12:33:51 <infinisil> Nope
12:41:49 <solonarv> Boarders: just tried it - unsafeCoerce# gives a compiler panic
12:42:10 <Boarders> they are both represented as Word#
12:42:18 <Boarders> so they actually don't have the same memory layout
12:42:38 <solonarv> they are not actually
12:42:45 <solonarv> % :k Word64#
12:42:46 <yahb> solonarv: Word64# :: TYPE 'Word64Rep
12:42:58 <solonarv> % :k Word# -- the internal representation of Word32
12:42:59 <yahb> solonarv: Word# -- the internal representation of Word32 :: TYPE 'WordRep
12:43:10 <solonarv> % :i Word32
12:43:11 <yahb> solonarv: data Word32 = W32# Word# -- Defined in `GHC.Word'; instance Eq Word32 -- Defined in `GHC.Word'; instance Ord Word32 -- Defined in `GHC.Word'; instance Show Word32 -- Defined in `GHC.Word'; instance Read Word32 -- Defined in `GHC.Read'; instance Enum Word32 -- Defined in `GHC.Word'; instance Num Word32 -- Defined in `GHC.Word'; instance Real Word32 -- Defined in `GHC.Word'; instance Bounded Word32 -- Defi
12:43:13 <Boarders> oh well Word64 has Word64#
12:43:17 <Boarders> but on most machines Word will be the same
12:43:18 <solonarv> yes, this confused me too
12:43:35 <Boarders> I don't know why we have Word for Word8
12:43:39 <Boarders> seems strange to me
12:43:44 <Boarders> Word#
12:43:47 <solonarv> it makes sense if you remember about aligned memory access
12:44:14 <Boarders> I do not remember about that because it has never been in my brain 
12:44:32 <solonarv> you can't just index halfway into a 4/8-byte (on 32-/64-bit platforms); memory access must be aligned to a multiple of 4/8
12:46:13 <Boarders> could you not partially automate the handling of memory layout to be a bit more efficient though?
12:46:18 <Boarders> does GHC do that?
12:47:02 <c_wraith> unpacked vectors do that.
12:48:03 <Boarders> ah ok, so if I do an unpacked vector of two Word32's it stores them in 64 bits?
12:48:35 <davean> Boarders: I mean, that would be architecture dependant?
12:48:49 <davean> Boarders: That could count as an unaligned access on some systems
12:49:05 <Boarders> this irc channel is extremely pedantic sometimes
12:49:08 <Boarders> it is very annoyinng
12:49:38 <Boarders> it would be pleasant if people didn't assume you were a thudding idiot constantly
12:49:48 <davean> Well I mean you asked a question
12:50:06 <Boarders> thanks
12:50:07 <c_wraith> err, unboxed. yes, unboxed vectors trade better space use for potentially doing extra operations to avoid bus errors.
12:52:39 <halogenandtoast> I often find this irc channel to have just the right amount of pedanticness
12:53:06 <halogenandtoast> It often points out that I am not asking the right question
12:53:22 <halogenandtoast> But I've learned to avoid anything category theory related if I can ;)
12:53:28 <Boarders> that is not my experience, I find a few of the regulars here are very helpful but the other day someone pointed out that you don't have negative values in Word
12:53:39 <Boarders> when it is plainly obvious from the question I understood that
12:53:43 <Boarders> and it is just insulting
12:55:11 <c_wraith> for the sake of pedentry: whether an unboxed vector uses a compact representation  depends on the Unbox instance for the type. but iirc, it's true for numeric types.
12:55:11 <halogenandtoast> Perhaps I have it easier, because I decide not to be insulted by such things? It's easy for people to misread or misunderstand the impetus for a question.
12:56:27 <Boarders> I don't know what that means so I will just let it stand
12:57:53 <halogenandtoast> Boarders: no worries, I hope your time here improves in the future.
12:59:22 * shapr agrees
12:59:50 <davean> Boarders: So I just looked up that instance. You asked why people find Num annoying. Its litterly the answer. Should they have said nothing?
13:00:03 <shapr> what's the issue?
13:00:04 <davean> er, Num for Word annoying
13:00:11 <Boarders> can you drop it
13:00:19 <Boarders> I am not going to argue with some random pleb on irc
13:00:24 <shapr> Boarders: hey, be nice
13:00:27 <davean> shapr: he's complaining people in this channel are too pedantic.
13:00:42 <davean> shapr: he cited a specific example from a couple days about about indexing using Int vs. Word
13:00:49 <davean> "why is Word annoying for arithmetic, just because of the Num typeclass or something mor
13:00:51 <davean> e fundamental?
13:01:13 * shapr shrugs
13:01:19 <davean> Yah, not sure whats up.
13:01:26 <shapr> sounds like past frustration being expressed
13:01:31 <davean> Think they're just upset
13:01:35 <shapr> I hope boarders finds what they want
13:01:52 <davean> Looks like they were mostly asking about interesting things too
13:01:57 <shapr> too bad :-(
13:02:00 <davean> yah
13:02:03 * shapr digs further into gitit configs
13:02:14 <shapr> I like interesting questions
13:02:24 <davean> I've actuallyed learned a bit reading through their questions this month!
13:02:32 <shapr> that's good!
13:04:08 <halogenandtoast> davean: s/bit/word/ ftfy
13:04:38 <davean> halogenandtoast: Well it was mostly about levity polymorphis in a single case :)
13:05:33 <halogenandtoast> I know the second word, but not the first, and not what they mean together
13:05:50 <halogenandtoast> > It's a way to make functions polymorphic over lifted and unlifted types, which is not possible with regular functions.
13:05:52 <halogenandtoast> hmm
13:05:52 <lambdabot>  <hint>:1:72: error: parse error on input ‘,’
13:07:36 <davean> halogenandtoast: I doesn't come up much.
13:07:40 <halogenandtoast> ($) :: forall (w :: Levity) a (b :: TYPE w). (a -> b) -> a -> b
13:07:45 <halogenandtoast> I use that all the time ;)
13:07:49 <davean> halogenandtoast: oh god yes, tha
13:07:58 <davean> That type is horrible :)
13:08:05 <carter> word and Int are annoying 'cause they're WordGHCPtrSize and IntGHCPtrSize :0 
13:08:32 <carter> nhellow everyon
13:08:38 <halogenandtoast> hello carter 
13:08:49 <shapr> greetings carter
13:08:52 <carter> halogenandtoast:  i can't see most of your spectrum but it smells good :) 
13:08:56 * shapr hops frustratedly
13:08:56 <davean> halogenandtoast: I think its even more special than that still. Or maybe that was the fix? ($) is deep magic.
13:09:20 <carter> $ the only impredicative thing in haskell :) 
13:09:28 <halogenandtoast> davean: TYPE is the deep magic
13:09:31 <carter> davean:  so yes its still hella special in the type checker
13:09:32 <shapr> dang, there's not a #gitit irc channel
13:09:49 <carter> halogenandtoast:  Type :: RuntimeRep -> Type ?
13:09:54 <carter> or is that its kind
13:10:08 <shapr> I think I should send an email to the author of gitit and ask for advice on how to structure this
13:10:09 <davean> halogenandtoast: Haskell actually has a wonderful spectrum of tools for making machine-exact code these days, levity polymorphism among them - we have unboxed sums now too
13:10:21 <davean> halogenandtoast: its a VERY rare haskeller that heads down that road though.
13:10:21 <halogenandtoast> davean: it redfines the kind `*` abd `#` to `type * = TYPE Lifted` abd `type # = TYPE Unlifted`
13:10:28 <carter> yes
13:10:33 <carter> halogenandtoast:  ghci just confirmst this
13:11:02 <shapr> is there any SIMD support in GHC?
13:11:10 <carter> shapr:  not the good part
13:11:23 <carter> shapr:  do you know how to use SIMD stuff in c / asm?
13:11:24 <davean> shapr: shut up, shut up ... go away .. thats a sore point
13:11:29 <carter> davean:  halogenandtoast l https://github.com/cartazio/unboxed/tree/master/src/Data/Unboxed 
13:11:43 <shapr> heh, fair enough
13:11:46 <davean> shapr: "yes it exists" "No you can't really use it"
13:11:54 <shapr> carter: yes, I've used C++ intrinsics for simple SIMD stuff
13:12:11 <davean> shapr: It sorta has an intrinsics level support but with bad/fragile handling :/
13:12:16 <shapr> aw, too bad
13:12:19 <carter> shapr:  you're gasslighting us by asking that question
13:12:24 <shapr> er, I am?
13:12:24 <davean> I'm not at ALL a fan of the SIMD implimentaiton
13:12:26 <shapr> how so?
13:12:34 <carter> shapr:  only if you hang irl
13:12:36 <davean> shapr: its carter and to some degree mine, bugbear
13:12:38 <carter> i get too bad otherwise
13:12:42 <shapr> carter: ha, fair enough
13:12:43 <carter> mad
13:12:53 <davean> shapr: there was a GSoC about it for example
13:12:57 * shapr checks calendar
13:12:58 <davean> shapr: carter is bitter
13:13:05 <carter> shapr:  basically theres a lot of things in code gen that need to be fixed up / plus type system
13:13:05 <davean> I might come down for this one ...
13:13:08 <AndreasK> There is limited SIMD support with the LLVM backend.
13:13:12 <shapr> carter: thursday evening?
13:13:15 <carter> if you want sne / good perf / etc
13:13:17 <carter> shapr:  sure
13:13:35 <davean> AndreasK: uh, yah, but that gets you too much cruft IIRC
13:13:41 <carter> yup
13:13:43 <carter> and its a lie
13:13:53 <carter> "portable simd" is a huge lie
13:13:56 <davean> it only gives you SIMD acceleration instead of performance loss for some VERY specific code types/structures
13:14:10 <davean> carter: I don't think thats true ...
13:14:12 <carter> unless you dedicate huge amounts of work to some sort of hyper focused optimization middle ware
13:14:20 <carter> davean:  ARM vs Intel simd
13:14:20 <davean> you just need an antirely different pattern for it
13:14:24 <carter> yes
13:14:33 <shapr> ok I see why I should not have asked
13:14:34 <carter> you need to write different simd per platform / micro arch if you want good perf
13:14:35 <davean> carter: ARM's variable-width SIMD stuff seems to point a reasonable direction
13:14:39 <carter> yes
13:14:42 <carter> that stuff is promising
13:14:44 <davean> you have to tell the compiler what code to construct not dada_cetacean irectly do it
13:15:04 <davean> So we need a language for describing SIMD operations across widths
13:15:05 <carter> RISC V is gonna be similar to the good ideas in next gen ARM
13:15:12 <carter> and have compile time fixed widths
13:15:22 <carter> and ability to generate code for different micro arch feature sets
13:15:27 <carter> and sanely branch into them
13:15:28 <davean> Plus we need to fuse the code neough we're not stack pumping ...
13:15:50 <davean> carter: Yah, arch-custom code on dynamic link is critical for portable *executables* but not compilation
13:15:54 <davean> I don't need portable executables
13:15:59 <davean> I can compile for each system directly.
13:16:03 <carter> davean:  depends on distor model but yeah
13:16:06 <carter> *distribution model
13:16:13 <davean> carter: Source code or GTFO
13:16:19 <carter> hehe
13:16:24 <davean> I only need half the solution here
13:16:30 <davean> I don't need an ICC level solution
13:16:49 <halogenandtoast> IceCrown Citadel?
13:16:58 <davean> Intel C Compiler
13:17:00 * shapr ducks and runs back to the gitit repo
13:17:40 <davean> halogenandtoast: Intel ships a very high performance C compiler with the load-time path optimization functionality.
13:18:08 <halogenandtoast> I was just making a world of warcraft joke. ICC is a pretty famous raid.
13:18:14 <davean> It is used for a lot high performance code to get a good bit more performance.
13:18:21 <davean> Ah, well I don't WoW so I wouldn't know :)
13:18:24 <davean> sorry
13:19:14 <carter> horrifying fact: majority of how people play MMORPG games... i  know from reading too much LITRPG fiction
13:19:30 <carter> hvr:  i'm gonna try to prototype a utf32 text library on top of vector today :) 
13:20:56 <carter> AndreasK:  is there any clever stuff in the low level half of Chez Scheme we could borrow?
13:21:17 <carter> or would it just be a hillariously faster O1 to feed O0 core into?
13:21:39 <AndreasK> carter: I have no idea about that sorry :)
13:21:55 <carter> https://github.com/cisco/ChezScheme 
13:22:02 <carter> it does double boot strap in < 1-5 minutes
13:22:45 <davean> carter: scheme is tiny.
13:26:51 <infinisil> Idris 2 uses chez scheme as the main compiler backend https://github.com/edwinb/Idris2
13:26:59 <infinisil> For now at least
13:27:11 <infinisil> "New Chez Scheme based back end which both compiles and runs faster than the default Idris 1 back end. (Also, optionally, Chicken Scheme and Racket can be used as targets)."
13:29:00 <carter> infinisil:  racket's old compiler / RTS was scary looking
13:29:01 <carter> :)
13:46:55 <halogenandtoast> dminuoso: hyperisco I found a solution to my issue earlier, don't write type signatures...
13:48:03 <halogenandtoast> then I get the ever so enjoyable type sub :: t1 -> (((((t2 -> t3) -> (t3 -> t4) -> t4) -> (p1 -> p2) -> (p3 -> p3) -> t5) -> t2 -> p2 -> t5) -> t1 -> t6) -> t6
13:55:57 <dmwit> ?djinn sub :: t1 -> (((((t2 -> t3) -> (t3 -> t4) -> t4) -> (p1 -> p2) -> (p3 -> p3) -> t5) -> t2 -> p2 -> t5) -> t1 -> t6) -> t6
13:55:57 <lambdabot> Cannot parse command
13:56:03 <dmwit> ?djinn t1 -> (((((t2 -> t3) -> (t3 -> t4) -> t4) -> (p1 -> p2) -> (p3 -> p3) -> t5) -> t2 -> p2 -> t5) -> t1 -> t6) -> t6
13:56:04 <lambdabot> f a b = b (\ c d e -> c (\ f g -> g (f d)) (\ _ -> e) (\ h -> h)) a
13:56:09 <dmwit> computers, man
13:56:17 <halogenandtoast> that looks about right
13:56:36 <halogenandtoast> given cpred n f x = n (\g h -> h (g f)) (\u -> x) (\u -> u)
14:14:53 <infinisil> @pl cpred n f x = n (\g h -> h (g f)) (\u -> x) (\u -> u)
14:14:53 <lambdabot> cpred = flip flip id . (flip .) . flip flip const . ((.) .) . (. ((flip id .) . flip id))
14:15:11 <infinisil> Um, yes much better
14:15:33 <infinisil> @pl \g h -> h (g f)
14:15:33 <lambdabot> flip id . ($ f)
14:16:01 <dmwit> The problem with computers is that the refuse to reject code like flip flip id . (flip .) . flip flip const . ((.) .) . (. ((flip id .) . flip id)).
14:18:01 <Rembane> They don't have taste! 
14:24:01 <infinisil> %t (>>>)
14:24:07 <infinisil> % :t (>>>)
14:24:08 <yahb> infinisil: forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
14:24:19 <infinisil> % :t (\g h -> h (g f))
14:24:19 <yahb> infinisil: ; <interactive>:1:15: error: Variable not in scope: f
15:10:40 <gabbiel> > 1+2
15:10:44 <lambdabot>  3
15:10:54 <gabbiel> >help
16:22:43 <turab> @pl \x y -> f x
16:22:43 <lambdabot> const . f
16:22:58 <turab> @pl \x y -> f y
16:22:58 <lambdabot> const f
16:24:54 <gabbiel> hey guys what's a function like words but for any predicate? i.e. wordsBy (==' ') xs = words xs
16:28:16 <gabbiel> also, does ghci allow for easily telling whether a function is "strict" or not?
16:29:34 <hpc> trivially
16:29:47 <hpc> for any function f, f is strict if (f undefined) is undefined
16:30:05 <hpc> denotationally, anyway
16:31:12 <hpc> also https://hackage.haskell.org/package/pandoc-2.7.3/docs/Text-Pandoc-Shared.html#v:splitBy for the first question
16:31:30 <hpc> though there's probably a better place to import that from than deep into pandoc
16:35:12 <gabbiel> hpc: (const undefined) isnt strict though, but it passes that test
16:40:48 <hpc> in denotational semantics, what i said above is the definition of strictness
16:41:16 <hpc> so (const undefined) fits, even though it doesn't technically have to evaluate its argument
16:42:47 <hpc> trying to find a good link explaining it
16:43:04 <gabbiel> idk what denotational semantics are
16:44:08 <hpc> can't find a good link
16:45:42 <gabbiel> thanks though
16:45:45 <hpc> it's basically a way of reasoning about expressions
16:46:17 <hpc> there's a number of things in haskell that take advantage of conclusions drawn from it
16:46:58 <hpc> like the fusion optimizations take advantage of (\_ -> undefined) being denotationally indistinguishable from undefined
16:54:35 <gabbiel> hpc: i see what you mean. but for strictness, I wish there was a more concrete way of reasoning regarding. that example with (\_ -> undefined) made sense 
16:57:12 <dada_cetacean> is there a way to fold over the fields of a record?
17:01:33 <hpc> dada_cetacean: not in the kind of trivial way that you'd get with foldr over a list - what are you trying to accomplish?
17:04:23 <Axman6> depends a lot on what the record looks like, but in general, no.
17:05:22 <Axman6> if it has a Generic instance it's possible to do things like fold over all fields as long as they all are members of a certain class
17:05:42 <Axman6> dada_cetacean: do you have an example of what you want ot do?
17:08:56 <jackdk> also maybe crazy Data.Data fun?
17:09:01 <jackdk> :t gfoldr
17:09:02 <lambdabot> error:
17:09:02 <lambdabot>     • Variable not in scope: gfoldr
17:09:02 <lambdabot>     • Perhaps you meant one of these:
17:09:19 <jackdk> % :i Data.Data.Data
17:09:20 <yahb> jackdk: class Typeable a => Data a where; gfoldl :: (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a; gunfold :: (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a; toConstr :: a -> Constr; dataTypeOf :: a -> DataType; dataCast1 :: Typeable t => (forall d. Data d => c (t d)) -> Maybe (c a); dataCast2 :: Typeable t => (forall d e. (Dat
17:16:55 <dmwit> gabbiel: const undefined is not undefined
17:17:01 <dmwit> > const undefined `seq` ()
17:17:03 <lambdabot>  ()
17:17:44 <dmwit> hpc is also incorrect about \_ -> undefined: it is denotationally distinguishable from undefined.
17:18:52 <erisco> hpc wouldn't say that
17:19:13 <dmwit> empirically false
17:19:40 <erisco> analytically implausible
17:20:23 <dmwit> gabbiel: (Ah, perhaps I misunderstood your objection to the definition of strict. Perhaps you agree that const is not strict, and you don't like the fact that const undefined is considered strict.)
17:21:32 <dmwit> gabbiel: In that case, perhaps you will be surprised to learn that GHC is within its rights if it compiles `const (error "A") (error "B")` into something that throws exception B!
17:22:00 <dmwit> So it is good to consider `const undefined` to be strict.
17:22:54 <hpc> dmwit: it is?
17:23:04 <hpc> i thought seq was outside denotational semantics
17:23:31 <gabbiel> i dont understand that example. do you mean const (error "a") (error "b") will compile an into an error inducing expression? 
17:23:43 <hpc> > const (error "a") (error "b")
17:23:47 <lambdabot>  *Exception: a
17:24:02 <hpc> gabbiel: ^ that could be "b", is what he means
17:24:20 <erisco> I think throwing exception c is also acceptable, so maybe a herring
17:24:41 <gabbiel> why would would it arise error b even though its not evaluated
17:24:58 <hpc> because it doesn't matter either way in that case
17:25:20 <hpc> for an analogy in C, you might as well ask why it does half the crap it does
17:25:29 <hpc> er, it being gcc
17:25:43 <erisco> error "a"  is denotationally equivalent to  error "b"  because the throwing effect is not described by the denotation
17:25:47 <erisco> corrections welcomed
17:26:55 <hpc> gabbiel: "how" the evaluation order for that expression works isn't defined
17:27:00 <gabbiel> is error a bottom?
17:27:02 <dmwit> Corrections available at https://www.microsoft.com/en-us/research/wp-content/uploads/1999/05/except.pdf
17:27:04 <hpc> the only thing that has to happen is it produces some bottom result
17:27:08 <hpc> :t error
17:27:14 <lambdabot> [Char] -> a
17:27:16 <dmwit> Haskell's exception semantics do distinguish between different exceptions.
17:27:21 <hpc> gabbiel: error is a function that takes a message and makes a bottom value that crashes the program
17:27:38 <dmwit> Error c would not be allowed.
17:27:38 <erisco> okay well the "corrections" is about I may be using a different denotation than others :P
17:27:42 <hpc> (another example of bottom is an infinite loop that produces nothing)
17:27:56 <erisco> I didn't read the Haskell report to see how it describes things
17:28:16 <dmwit> gabbiel: You might enjoy https://stackoverflow.com/q/11070690/791604
17:28:46 <gabbiel> erisco: what, how can error a denote the same as error b, b and a might be different
17:29:35 <dmwit> gabbiel: In many denotational semanticses, all errors have the same denotation, and implementations which allow you to observe their differences are not conforming to the semantics.
17:29:35 <erisco> because in the denotation I am using they are both just ⊥
17:29:55 <gabbiel> hpc: but isnt const x _ = x, therefore the second argument isnt evaluated, therefore there is an evaluation order implied?
17:29:59 <dmwit> The obvious end result of this is that no implementations actually conform to the semantics. =)
17:30:59 <erisco> so, an infinite loop would also be acceptable
17:31:36 <hpc> gabbiel: it doesn't have to evaluate the second paramter, but it can if it wants to, as long as the result is the same
17:31:41 <hpc> and all bottoms are the same
17:31:42 <gabbiel> so dmwit says errors can be distinguished but erisco says otherwise, which is it? 
17:31:49 <hpc> so if they're both bottom it can just pick one
17:31:55 <erisco> we're not saying anything different I don't think
17:32:30 <hpc> dmwit is saying they're distinguishable outside denotational semantics
17:33:02 <hpc> you have to go through some annoying hoops to make it work though
17:33:32 <erisco> I am sure the Haskell Report details what these are supposed to do, so the denotation will be augmented with these effects
17:33:36 <gabbiel> erisco: you said "error "a" is denotationally equivalent to error "b"", and dmwit just said that "haskells exception semantics do distinguish"
17:33:49 <hpc> it involves doing weird stuff to control when stuff gets evaluated, then catching the exception that it technically generates
17:33:51 <erisco> Yeah, they probably do. We all hope they do :P
17:34:04 <hpc> and then doing something with the fact that catching exceptions involves IO
17:34:12 <gobby>  I'm building an SPA that needs to access a database(read/write). I was going with sqlite but concurrency worries me(multiple writes). Would it be reasonable for the initial stage of the webapp to use sqlite? Or should I just use postgres from the start?
17:34:21 <dada_cetacean> Axman6, hpc: i don't remember why i didn't want to use a list for this, but say i have a record each of whose fields is a parser, and i want to fold <|> over them
17:34:56 <hpc> ah, i'd just write that explicitly
17:35:10 <erisco> > error "a" + error "b"
17:35:14 <hpc> data Foo = Foo (Parser Bar) (Parser Bar) (Parser Bar)
17:35:16 <lambdabot>  *Exception: b
17:35:21 <erisco> just sayin'
17:35:26 <hpc> parseFoo (Foo a b c) = a <|> b <|> c
17:36:24 <hpc> gobby: i don't trust sqlite either, but people seem to swear it's gotten better
17:37:07 <MarcelineVQ> It is reasonable
17:37:09 <hpc> it's all sql in the end, so i think all that's different between the two is how you connect
17:37:25 <gobby> hpc: hmm....I would in theory be able to implement my own concurrency in haskell though right?
17:37:28 <Axman6> has anyone seen anywhere an implementation of something like: applyTo :: (Fields rec ~ fs, FunctionFor hs r ~ funType) => rec -> funType -> r (take a record, and a function which accepts its fields a arguments and return the result)
17:38:01 <gabbiel> im even more confused now. so bottom is a value that can be any type??
17:38:08 <hpc> gabbiel: yep
17:38:15 <dmwit> gabbiel: 1. The implementation distinguishes. 2. The semantics in the "imprecise exceptions" distinguishes. 3. The standard denotational semantics does not distinguish.
17:38:20 <erisco> Well, how about all types are inhabited by bottom.
17:38:38 <gabbiel> why is bottom even allowed, it breaks the laws
17:38:39 <Axman6> gabbiel: bottom is anything which doesn't return a value (roughtly). so exceptions never return, and recursive functions which never terminate are also bottom
17:38:55 <Axman6> how do you propose to disallow bottom?
17:39:09 <Axman6> :t let x = x :: Int in x
17:39:10 <hpc> gobby: it sounds like the concurrency you're worried about is in the database itself
17:39:12 <lambdabot> Int
17:39:25 <erisco> I don't know of any reason each type could not have its own bottom
17:39:43 <dmwit> (It is probably best to think of each type having its own bottom, in fact.)
17:39:55 <hpc> which in your code that uses it, you'd deal with by removing concurrency from that layer, with something that makes the operations sequential again
17:40:07 <Axman6> SQLite is fine, if you're worried about concurrency (which IMO you shouldn't be), you can just fork a thread which is the only one which interacts with the database so all operations are serialised
17:40:11 <hpc> but you don't want to do that in either case, they handle concurrency reasonably well
17:40:18 <gobby> hpc: But couldn't I for instance bracket the sql write to my database?
17:40:26 <Axman6> I just turn on the WAL and go nuts with SQLite
17:40:52 <erisco> gabbiel, if there was no bottom then we couldn't have partial functions, or general recursion
17:41:35 <hpc> there is a type of language that does away with bottom to great effect - theorem provers
17:42:14 <erisco> or error :)
17:42:18 <hpc> there's a thing called the curry-howard isomorphism, which basically says programming with types corresponds to proving logical propositions
17:42:25 <hpc> types are propositions, values of those types are proofs
17:42:38 <hpc> if the system has bottom, all types have a value, so you can prove anything
17:43:03 <erisco> my ability to do proofs increased dramatically ever since I started using Haskell
17:43:04 <hpc> but you lose turing completeness
17:43:12 <gabbiel> it seems there are two types of bottom though
17:43:27 <hpc> and there's a lot of neat research going into getting as close as possible to turing completeness without losing that logical consistency
17:44:06 <lyxia> you can run the proofs to check them :)
17:44:19 <hpc> you don't run them, you just compile them
17:44:21 <erisco> well really just compile them
17:44:29 <erisco> running programs is so passé
17:44:54 <erisco> I just do all my effects through the type system
17:44:59 <lyxia> I mean in Haskell you can compile programs of any type, but not all of them will run silently.
17:45:07 <hpc> there is the idea though, that you can write a type that constrains what the program does as if you were writing a proof
17:45:17 <hpc> so say you have a data type for sorted lists
17:45:22 <hpc> sort :: List a -> SortedList a
17:45:48 <hpc> and using theorem proving techniques, you can make a guaranteed correct sort implementation
17:46:28 <erisco> gabbiel, if you view bottom as the least-defined value, then maybe that would help
17:47:00 <erisco> gabbiel, a function which recurses infinitely is no more defined than a function with no clause to match its argument
17:47:42 <erisco> and is no more defined than  error "a"
17:47:52 <gabbiel> but in the recursive case, it is defined, it just loops forever
17:48:05 <erisco> but what is the value?
17:48:28 <gabbiel> for example, f(n) = n*f(n-1)
17:48:34 <gabbiel> the value is n*f(n-1)
17:49:08 <erisco> yes, now keep going :)
17:49:31 <gabbiel> for f n | n > 3 = n, it can be seen that f is not defined for n <= 3
17:49:52 <erisco> ah well whether we can see it or not is a different problem
17:50:29 <gabbiel> i agree that it may never evaluate to something concrete that we can make sense of
17:50:38 <erisco> but we can also plainly see that  f n = n * f (n - 1)  recurses forever, assuming that is the only clause
17:51:12 <gabbiel> right
17:51:20 <erisco> if we try to figure out what the number is, we can't get there
17:51:32 <erisco> so, we just say such values are bottom
17:52:24 <erisco> so,  f n = ⊥
17:52:37 <gabbiel> is 1/0 a bottom?
17:52:43 <erisco> > 1/0
17:52:45 <lambdabot>  Infinity
17:52:48 <erisco> nope
17:52:56 <erisco> though that uses defaulting for Double I think
17:53:09 <erisco> > (1::Int)/(0::Int)
17:53:12 <gabbiel> thats only due to ieee standard right, its there by convention
17:53:12 <lambdabot>  error:
17:53:12 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
17:53:12 <lambdabot>      • In the expression: (1 :: Int) / (0 :: Int)
17:53:23 <erisco> guess we're not allowed :P
17:53:34 <erisco> yes, well, Infinity is not bottom :P
17:54:39 <erisco> The extended reals are a thing, and I can consider IEEE floats an approximation of such
17:54:44 <erisco> after we ignore NaN
17:54:51 <gabbiel> 1/0 should be a bottom
17:54:56 <erisco> not-a-number the number
17:55:04 <erisco> yes well thanks to computing history it isn't
18:03:50 <gabbiel> can someone help me understand why flip works for functions that arent binary?
18:04:04 <erisco> such as?
18:04:23 <erisco> the start to the answer though is that no function is binary
18:04:24 <gabbiel> sin, g a b c d = a + b + c + d
18:05:03 <gabbiel> i understand all functions are unary
18:05:42 <erisco> > :t let g a b c d = a + b + c + d in flip g
18:05:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:05:49 <erisco> did you mean like this?
18:05:51 <erisco> :t let g a b c d = a + b + c + d in flip g
18:05:55 <lambdabot> Num a => a -> a -> a -> a -> a
18:07:10 <gabbiel> i sort of understand now
18:07:54 <gabbiel> its just the b in flip is a function itself
18:08:04 <erisco> :t flip
18:08:06 <lambdabot> (a -> b -> c) -> b -> a -> c
18:08:14 <erisco> the c is
18:08:15 <gabbiel> *a function type
18:08:50 <erisco> :t flip id
18:08:52 <lambdabot> b -> (b -> c) -> c
18:09:22 <gabbiel> moral of the story: avoid flip for "non binary" functions
18:09:25 <gabbiel> thanks erisco
18:09:49 <erisco> mm, how sometimes not thinking of functions as binary
18:10:10 <gabbiel> i know they arent really binary
18:10:13 <erisco> sometimes helpful, sometimes limiting
18:11:15 <erisco> if you knew it deeply then flip wouldn't be surprising to you, and that moral would be unnecessary
18:13:30 <gabbiel> I understand flip for functions with more than 2 arguments, but not for unary ones
18:13:43 <gabbiel> flip requires a binary one as seen in the type
18:13:45 <gabbiel> >:t flip
18:14:04 <erisco> :t flip undefined
18:14:07 <lambdabot> b -> a -> c
18:14:22 <erisco> how about not even functions, supposedly :P
18:14:45 <erisco> :t id
18:14:47 <gabbiel> can't bottom be a function too though?
18:14:48 <lambdabot> a -> a
18:14:51 <erisco> choose something for  a  to make it binary
18:16:10 <gabbiel> flip undefined chooses undefined to be a function of type (a->b->c), it makes sense to me in this case
18:16:18 <gabbiel> since undefined can be any type 
18:20:15 <erisco> :t id `asAppliedTo` id
18:20:17 <lambdabot> (a -> a) -> a -> a
18:20:35 <gabbiel> weird, flip id seems to function as a reverse order evaluator 
18:20:44 <gabbiel> >flip id 3 (\x -> x + 1)
18:21:06 <gabbiel> but only for one argument
18:21:55 <erisco> :t flip (flip id)
18:21:56 <lambdabot> (b -> c) -> b -> c
18:24:57 <erisco> :t flip `asAppliedTo` id
18:24:58 <lambdabot> ((b -> c) -> b -> c) -> b -> (b -> c) -> c
18:26:46 <gabbiel> what is asAppliedTo
18:26:58 <erisco> :t asAppliedTo
18:26:59 <lambdabot> (a -> b) -> a -> a -> b
18:27:34 <hpc> in (flip `asAppliedTo` id), it tells you what type flip takes in order to be used in (flip id)
18:28:07 <erisco> now for dependent type annotations
18:28:36 <hpc> oh, while on the topic of flip id
18:28:42 <hpc> :t flip id 3
18:28:47 <lambdabot> Num b => (b -> c) -> c
18:29:16 <hpc> values of types that look like this would be an interesting thing for you to contemplate in the future :D
18:56:55 <turab> :t flip id
18:56:58 <lambdabot> b -> (b -> c) -> c
18:57:22 <turab> :t flip \x -> x
18:57:24 <lambdabot> error:
18:57:24 <lambdabot>     Unexpected lambda expression in function application:
18:57:24 <lambdabot>         \ x -> x
18:57:34 <turab> :t flip $ \ x -> x
18:57:36 <lambdabot> b -> (b -> c) -> c
19:01:37 <gabbiel> ive been challenged to write any using folds but in pointfree style, is that even possible
19:10:02 <dmwit> The documentation for unsafeFreeze in the vector package says, "Unsafe convert a mutable vector to an immutable one without copying. The mutable vector may not be used after this operation.".
19:10:21 <dmwit> Is it okay to start using the mutable vector again after I drop all references to the immutable one?
19:14:19 <nshepperd> dmwit: I would say yes, but it seems troublesome, since you'd have to ensure everything that depends on the immutable vector is fully evaluated
19:15:10 <nshepperd> so, as okay as any other activity that breaks referential transparency, i suppose?
19:21:05 <tolt> gabbiel: always ;) just might not make a ton of sense. Check out http://pointfree.io/ if you want to cheat
19:27:53 <dmwit> nshepperd: Yes, I'm willing to take on the proof burden that no closures are lying around that reference the immutable vector.
19:28:58 <dmwit> The thing I'm worried about is that there will be some oddity with GC? Like will the immutable vector going out of scope let GC do its thing and make future accesses to the mutable one segfaults or something? (Probably no...? But this is compiler magic land, so I feel unsure.)
19:55:01 <gabbiel> >@pl any
19:57:47 <oats> gabbiel: yeah, converting to pointfree can be quite the puzzle
19:58:00 <oats> are you just looking for an answer or do you want to figure it out yourself?
20:02:29 <gabbiel> pointfree.io helped, but I would have never come up with a solution
20:02:51 <oats> yeah
20:03:11 <oats> it's a fun exercise, but most of the time you get an answer you probably shouldn't use in code anyone else will see :p
20:03:57 <nshepperd> dmwit: i'm pretty sure unsafeFreeze just rewraps the ForeignPtr/bytearray so there shouldn't be any such issues
20:06:15 <oats> :t flip foldl False . flip ((.) . (||))
20:06:17 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:07:00 <oats> > (flip foldl False . flip ((.) . (||))) even [1,3,5]
20:07:04 <lambdabot>  False
20:07:07 <oats> > (flip foldl False . flip ((.) . (||))) even [1,3,5,4]
20:07:12 <lambdabot>  True
20:07:13 <dmwit> > any even [1,3,5]
20:07:17 <lambdabot>  False
20:07:20 <dmwit> > any even [1,3,5,4]
20:07:24 <lambdabot>  True
20:07:32 <gabbiel> yeah i got that answer by inputting "any f = foldr (\x r -> f x || r) False" into pointfree.io
20:07:39 <dmwit> oh
20:08:32 <infinisil> Note to self: mconcat [ x ] /= x    for a Monoid x
20:08:52 <dmwit> uh?
20:08:57 <dmwit> Why not?
20:09:12 <gabbiel> but i fear it wont work with infinite lists like the real any does 
20:09:45 <infinisil> mconcat [ x ] = x `mappend` mempty
20:10:08 <dmwit> infinisil: Yes, and x `mappend` mempty = x is a Monoid law.
20:10:24 <dmwit> :t flip (appEndo . foldMap (Endo . (||)) False
20:10:28 <lambdabot> error:
20:10:28 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:10:39 <dmwit> :t flip (appEndo . foldMap (Endo . (||))) False
20:10:41 <lambdabot> Foldable t => t Bool -> Bool
20:10:48 <infinisil> Ah yeah, I should've clarified: the evaluation of mconcat [ x ] evaluates more than just x 
20:11:11 <infinisil> And if your `mappend` has a memory leak this is bad
20:11:16 <dmwit> ah... heh
20:11:29 <glguy> infinisil: That's dependent upon the Monoid instance you're using
20:11:30 <infinisil> Because I just spent a couple hours trying to find the leak, I didn't even consider my mappend because of this..
20:11:39 <infinisil> Yeah it's my own instance
20:12:04 <glguy> you might even implement your mconcat not to do that
20:12:33 <infinisil> Ah yeah, but I will need to <> stuff together at some point (wouldn't be much of a Monoid/Semigroup without that)
20:12:42 <infinisil> So I still need to fix the leak in any case
20:15:54 <infinisil> There it is, my first memory leak fixed.. https://github.com/Infinisil/arvy/commit/c07db6e2f85ffc2b37899cf1aa38c8a7672ae208
20:16:07 <infinisil> Amazing how a single missing ! can ruin your night lol
20:36:46 <jusss> does haskell have Object type and null value ?
20:39:32 <jackdk> no
20:39:57 <koz_> That's an oddly-specific question, jusss.
20:40:03 <koz_> What do you wanna do?
20:41:10 <jusss> koz_: I'm learning java and kotlin just now, 
20:41:22 <jusss> so I wonder
20:42:40 <jusss> undefined in haskell is a value or a type? and what is bottom type?
20:43:46 <heatsink> jusss: In Java, there was no way to declare that a pointer cannot be null, and mistakes cause NullPointerExceptions.  Java introduced @nullable annotations to help deal with the problem, saying at least sometimes that a pointer can't be null
20:44:51 <Cale> jusss: undefined is a value, but it's a value which is indistinguishable from your program going into an infinite loop
20:45:02 <heatsink> jusss: Haskell comes from the opposite direction.  "Pointers" are always pointing to valid data.  If you want an maybe-present, maybe-absent value, like a pointer that can be null, you would use the Maybe data type.
20:45:15 <Cale> So, you don't "test for undefined" the way you might "test for null"
20:46:06 <M31violet13[m]> That's what the Maybe monad is for, no?
20:47:11 <glguy> The Maybe type at least
20:47:11 <Cale> Yeah, as heatsink mentioned.
20:47:34 <Cale> You might not bother using the Monad instance, just the type and pattern matching can be good enough a lot of the time.
20:47:48 <jusss> what we call Maybe a?  Maybe Int is a type, Maybe a is a type?
20:48:34 <M31violet13[m]> That is a type.
20:48:47 <jusss> ok
20:50:21 <EvanR> undefined is theoretically indisinguishable but...
20:50:41 <EvanR> you can do evil things like catch undefined exception
20:57:11 <jusss> haskell has Exception stuff?
20:57:46 <EvanR> yes
20:58:08 <jusss> I thought Haskell is like C, just have a static type system without OO
20:59:14 <EvanR> theres few ways haskell is like C
20:59:40 <glguy> EvanR: It's not relevant to this discussion, but catching undefined evaluation exceptions are much less precise than matching on null
20:59:52 <glguy> you can't tell where the undefined came from
21:01:14 <jusss> now I learn four kinds of languages, 1. dynamic type with OO like Python and Javascript,  2. static type without OO like C and Haskell, 3. static type with OO like Java and Kotlin, 4. dynamic type without OO, scheme...
21:02:32 <EvanR> yeah but haskell feels much different from python, javascript, C, Java, and scheme
21:02:53 <EvanR> so that 2-bit criteria seems like its missing something
21:04:41 <jusss> that 3. static type with OO was really make me confused a few days ago, 'cause they have type and class!
21:05:05 <___laika> im trying to define a HasHttp typeclass for my RIO app, but im having trouble figuring out what the type for the instance methods should look like. im currently working with the req library to make requests, but i don't know if it's a bad idea or not to couple my Http capability to the types of my library im implementing with? or maybe thats unavoidable...? :sweat:
21:05:06 <jusss> and they even have type inheritance!
21:05:45 <jusss> they can use class as type, or say type as class?
21:08:40 <heatsink> jusss: Besides those 4 kinds of languages, some programming languages are designed to help programmers prove that their code works correctly.  For example, some languages let you wrote proofs and code together; invalid proofs and invalid code alike are detected by the compiler.
21:08:51 <Cale> ___laika: What is HasHttp?
21:08:58 <heatsink> jusss: Haskell isn't really in that category of languages supporting formal proofs, but it's influenced by that domain
21:09:00 <Cale> ___laika: You're trying to define the class itself?
21:10:01 <___laika> i want HasHttp to be a capability that indicates that a function will be able to make requests
21:10:16 <___laika> im trying to write the type signature for its instance function(s)
21:10:20 <jusss> heatsink: you mean like @ annotation in java?
21:10:22 <Cale> Isn't there already a MonadHttp?
21:10:32 <Cale> http://hackage.haskell.org/package/req-2.1.0/docs/Network-HTTP-Req.html#t:MonadHttp
21:10:58 <Cale> http://hackage.haskell.org/package/req-2.1.0/docs/Network-HTTP-Req.html#v:req
21:12:01 <martinium> hello I am currently self-teaching how to create rest api libraries for consumption of said rest api in python and am curious if anyone has any similar examples for haskell?
21:12:18 <heatsink> jusss: Some Java tools use annotations to prove specific kinds of correctness, such as null-safety.  It's similar.
21:12:20 <Cale> It's all a bit silly... there's no apparent reason that req shouldn't just be producing an IO action.
21:12:41 <martinium> I am basically looking to see examples of code and how they structure the different responses/endpoints etc
21:12:50 <heatsink> jusss: The difference is, each tool proves just one thing.  If you want to prove that your program doesn't access arrays out of bounds, your @nonnull annotations won't help at all.
21:12:58 <___laika> i think the idea is to be more explicit about what functions have access to which capabilities
21:13:08 <heatsink> jusss: Proof-oriented languages try, more or less, to let you prove anything that's proveable
21:18:03 <dmwit> Cale: Wow, that really is silly.
21:19:36 <jusss> heatsink: decorator in python is a proof?
21:19:50 <EvanR> Req is a MonadIO
21:21:09 <___laika> ^
21:21:20 <heatsink> jusss: No
21:21:34 <___laika> and then not tying it to IO allows users to be more flexible about monad stack and such, i guess
21:22:39 <___laika> jusss: python decorators are just syntax sugar to make it easier to wrap top normal definitions
21:23:51 <jusss> heatsink: ___laika ok
21:24:07 <___laika> if you annotate a function foo with @bar
21:24:16 <___laika> thats the same as saying foo = bar(foo)
21:24:20 <___laika> err
21:24:28 <___laika> foo = bar(original definition of foo)
21:24:32 <___laika> it rebinds it to the same name
21:25:03 <jusss> ___laika: I wonder if decorator in python is like compose in haskell?
21:25:17 <jusss> function compose, of course
21:26:34 <___laika> not exactly i dont think
21:26:42 <jusss> ok
21:27:21 <___laika> a decorator basically extends an existing function with some given functionality
21:27:35 <___laika> in haskell it would look more like
21:27:56 <___laika> decorator = <some definition>
21:28:03 <___laika> f = <other>
21:28:06 <___laika> f' = decorator f
21:28:46 <___laika> function composition in python can be accomplished via a couple mechanisms https://mathieularose.com/function-composition-in-python/
21:43:49 <jackdk> in a similar vein, you can think of fmap, liftA(n), foldMap, >>=, traverse etc as "function transformers"
21:46:29 <gabbiel> why isn't Bool an instance of Foldable when the function bool is a catamorphism
21:47:19 <gabbiel> just as maybe is a catamorphism for Maybe and either is for Either
21:48:47 <Cale> gabbiel: Bool isn't even of the right kind to be an instance of Foldable
21:49:25 <Cale> gabbiel: Foldable isn't for types that have catamorphisms
21:50:11 <Cale> It's for types which support foldMap
21:50:13 <Cale> :t foldMap
21:50:16 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:50:22 <gabbiel> oh i see, since Bool is a sum type of unit values
21:51:16 <EvanR> this wouldn't make sense: (Foldable Bool, Monoid m) => (a -> m) -> Bool a -> m
21:51:26 <Cale> i.e. Given a function from a to some choice of monoid m, there's a canonical way to apply that function to the elements of the t a, and combine the results into some expression involving the monoid operation.
21:51:37 <EvanR> problem being the Bool a
21:53:47 <gabbiel> thanks guys
22:07:21 <marmulak> yw
22:37:04 <dmwit> gabbiel: It... isn't because it's a sum of units. `data NotBool a = NotTrue | NotFalse` is a sum of unit types, but it has a perfectly sensible `Foldable` instance.
22:38:24 <dmwit> It's for the reason Cale said: it isn't a parameterized type (and specifically not one which accepts another concrete type as a parameter).
22:51:44 <Saulzar> Does anyone have any reliable way of printf debugging across multiple libraries which use concurrency with ghc? 
22:52:48 <Saulzar> In a single library I just use a logging thread and we're happy... across multiple libraries stdio always gets mashed concurrently and nothing is readable.
22:54:09 <Cale> Perhaps you can write to distinct files?
22:55:04 <Saulzar> True, that may work.
22:59:24 <cocreature> Saulzar: there is also the “say” package https://hackage.haskell.org/package/say which while not being a proper solution (since it only works for short messages) might be good enough for debugging
23:12:49 <Saulzar> cocreature, Thanks, that seems to do the trick
23:47:50 <akr> Hi there, what's the syntax and necessary extensions have a record field whose type depends on another fields value?
23:50:04 <dminuoso> akr: Can you elaborate?
23:51:45 <dminuoso> akr: The closest way I can make sense of what you said, is via an injective type family, ⌜data Foo f = Foo { someField :: t, anotherField :: T f }⌝
23:52:23 <dminuoso> (Or equivalently via fundeps)
23:52:39 <akr> That could work, how do you define T?
23:52:51 <dminuoso> Oh, that should have read ⌜data Foo f = Foo { someField :: f, anotherField :: T f }⌝ of course.
23:52:59 <dminuoso> akr: Just as an injective type family.
23:53:52 <akr> Alright, I'll have to read up on that a little bit it seems. Thaks for pointing me in the right direction! 
23:54:43 <dminuoso> akr: Actually wait, the injectivity is not even necessary (since you didn't state that mapping to be unique)
23:54:51 <dminuoso> akr: So any type family would work.
23:55:02 <dminuoso> Equivalently you could use associated type families or fundeps.
23:55:38 <akr> Ah, alright, I'll check those out as well :)
23:56:17 <akr> Sometimes I wish Haskell was just a subset of agda 
