00:09:41 <fragamus> join lisp
00:13:04 <ski> join prolog
00:32:10 <roflik> https://www.haskell.org/onlinereport/haskell2010/ gives me 500 Internal Server Error
00:37:01 <ski> #haskell-infrastructure
00:37:08 <ski> it's a known issue
00:40:50 <ski> it's been mentioned at least twice within some hours (in here)
00:40:56 <ski> <https://status.haskell.org/>,<https://twitter.com/haskellstatus>
00:40:57 <ski> <http://web.archive.org/web/20190704232255/https://www.haskell.org/onlinereport/haskell2010/>
00:41:03 <ski> @where status
00:41:04 <lambdabot> <https://status.haskell.org>,<http://auto-status.haskell.org/>
00:41:18 <ski> @where+ status <https://status.haskell.org>,<http://auto-status.haskell.org/>,<https://twitter.com/haskellstatus>
00:41:18 <lambdabot> Good to know.
00:41:23 <ski> roflik ^
00:54:36 <no-n> I get this error when trying to compile hello world on OpenBSD 6.5 https://pastebin.com/EX7Wb4nC
01:02:14 <lavalike> no-n: maybe this is somewhat related https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=226872
01:03:41 <no-n> ahh
01:07:01 <roflik> ski: thx!
01:14:48 <ski> whee !
01:32:39 <lavalike> no-n: so it helped?
01:34:17 <no-n> it looks like ghc's porter will need to fix it unless it's already been done so in -current
02:02:47 <roflik> ski: is there a tarball with the html rendering of the report somewhere?  i'm on freebsd, tex4ht is not in packages and it looks a bit hairy to package.
03:49:40 <mpickering> If I make an FFI call to a C function, should the printf's in the C function still make it to stdout?
03:54:39 <cocreature> mpickering: yep (and it does ime)
03:55:11 <mpickering> I changed the printf to a barf and that triggered
03:55:26 <mpickering> so seems that the printf gets swallowed somewhere
03:56:12 <cocreature> maybe you messed with stdout somehow? you could try fprintf(stderr, …, …)
03:56:17 <cocreature> or buffering issues
03:57:43 <mpickering> how should I set buffering?
03:57:49 <mpickering> sorry I am a total C noob
03:59:10 <cocreature> fflush(stdout) after the printf is an easy way to test it
04:00:09 <cocreature> you can disable buffering completely with setvbuf iirc but that’s only allowed before you do any other operations on the stream
04:00:59 <mpickering> right thanks a flush made it print
04:03:05 <cocreature> mpickering: stdout is often line-buffered so it might be as simple as adding a \n to your printf
04:03:29 <mpickering> ah, yes, of course
04:03:48 <mpickering> right perfect
07:30:51 <jgt> is it a good idea to log response headers in request logs?
07:31:14 <jgt> I realise this isn't specific to Haskell, but I'm thinking of sending a PR to WAI to add this
07:31:53 <jgt> more specifically, wai-extra
07:31:54 <hpc> i like the idea of being able to log everything
07:32:20 <hpc> or well, having it available as an option
07:32:46 <jgt> what's motivating this change is I want to be able to log an associated user ID with every request log
07:32:56 <jgt> assuming the user is authenticated
07:33:22 <jgt> so on the WAI side, I'd add generic response header logging
07:33:52 <jgt> and on the Yesod side, I'd add a middleware which adds the user ID — if there is one — to a response header
07:40:34 <cocreature> jgt: do you really need to patch wai-extra for this? it seems like it already allows you to specify a custom output format
07:43:23 <jgt> cocreature: I _think_ so, but perhaps I'm wrong and you can point me to a better way to do this. I'll try and explain my thought process.
07:43:36 <jgt> if you look at mkRequestLogger here: http://hackage.haskell.org/package/wai-extra-3.0.26.1/docs/src/Network.Wai.Middleware.RequestLogger.html
07:44:06 <cocreature> jgt: https://hackage.haskell.org/package/wai-extra-3.0.26.1/docs/Network-Wai-Middleware-RequestLogger.html#t:OutputFormat
07:44:07 <jgt> you'll see the branch for CustomOutputFormatWithDetails, which I am using (and I think this is the expected way to write a custom formatter)
07:44:28 <jgt> it's hard-coded to use customMiddlewareWithDetails
07:44:52 <jgt> and I think this is the function I need to change, since this is the only place where I have access to the response
07:45:03 <cocreature> oh response headers not request headers, I should learn to read, sry :)
07:45:51 <jgt> I'm not sure of any other way to pass arbitrary data from Yesod out to the place where WAI does logging
07:46:30 <jgt> I was looking into Vault, but I don't think that's the right thing
07:47:14 <jgt> cocreature: has what I've said so far made sense?
07:48:37 <cocreature> yeah that does look like it needs patching (or your own middleware)
07:50:46 <jgt> Ok. I'll make those changes, and assuming it works, send a PR.
07:52:03 <cocreature> I guess one issue is that for `ResponseRaw` you can’t get the headers or at least not easily
08:27:51 <jgt> I think that's fine. That'll be the concern of the formatter anyway. I'll need to change the middleware, and the formatter. They're two different pieces but they're quite tightly coupled.
08:48:13 <AgentPidar> sf
08:57:20 <wroathe> Anyone in here right now a Haskell IDE Engine contributor?
08:59:49 <cocreature> wroathe: there is #haskell-ide-engine
08:59:59 <wroathe> cocreature: Thanks
09:07:24 <dmwit> Can I recurse on a KnownNat?
09:34:39 <phadej> dmwit: not without cheating
09:35:10 <dmwit> Damn. How do I cheat?
09:38:32 <dmwit> If I write `unsafeIDeclareThatMAndNAreEqual :: Dict (KnownNat m) -> Dict (KnownNat n); unsafe... m = unsafeCoerce n` does that actually do what I want it to do?
09:38:46 <dmwit> (That is, keep the dictionary intact and only change what type the compiler thinks it has?)
09:38:55 * ski . o O ( `KnownNat n => (n ~ 0 => p n) -> (forall m. (n ~ m + 1,KnownNat m) => p m -> p n) -> p n' )
09:39:11 <dmwit> ski: Yes, I wish something like that were exposed from GHC.TypeNats.
09:39:22 <dmwit> I haven't seen anything like that (or that would let me implement it, either).
09:39:38 <dmwit> There is a withSNat internally that basically does that, it seems. Dunno why it isn't exposed.
09:44:57 <dmwit> At! unsafeCoerce does seem to do what I want it to do.
09:45:05 * dmwit forges ahead
10:01:57 <quanti> Hi all, does anyone know where I'm going wrong implementing `pred` for Naturals with type-level parity checking? More description here: https://stackoverflow.com/questions/56924244/how-can-i-find-the-predecessor-of-a-natural-with-type-level-parity-checking
10:11:14 <dmwit> Damn, it's still not enough.
10:11:36 <cocreature> dmwit: more unsafecoerce!
10:11:39 <dmwit> Having KnownNat (n-1) in the context isn't enough to determine that n is apart from 0 and therefore the type family instance for 0 doesn't apply.
10:11:49 <cocreature> if unsafeCoerce doesn’t solve your problem you just need more of it
10:12:34 <dmwit> I was hoping I could bottle off the use of unsafeCoerce into `predNat :: KnownNat n => Either (n :~: 0) (Dict (KnownNat (n-1)))` though. =(
10:13:14 <cocreature> predNat = unsafeCoerce ()
10:14:09 <dmwit> no!
10:14:16 <dmwit> cocreature--
10:14:26 <cocreature> I deserved that ;)
10:16:30 <c_wraith> isn't there a type checker plugin specifically for doing KnownNat arithmetic?
10:17:36 * ski . o O ( arithmetic constraint solver )
10:34:18 <zacts> can Haskell be used to produce valid C code?
10:34:51 <zacts> Like I program in Haskell and it produces C code that runs
10:35:03 <zacts> something like chicken scheme but for Haskell
10:36:06 <Adeon> GHC has a C output but I think it may not be compiled in by default anymore and not sure if it's included in its code base
10:36:14 <Adeon> so this is possible but would be behind some hoops
10:37:08 <zacts> Ok
10:37:10 <zacts> cool
10:37:14 <dmwit> cocreature: I have inserted more unsafeCoerce. Thanks for the advice.
10:37:16 <Adeon> I think it's only used in special circumstances like porting or bootstrapping GHC to another platform
10:37:20 <Adeon> not really meant for general development
10:37:24 <zacts> I see
10:38:07 <dmwit> zacts: Out of curiosity, why do you want this?
10:38:17 <dmwit> (In fact, a bit more than curiosity: perhaps we can propose an alternate solution.0
10:38:26 <zacts> dmwit: I don't have a particular project I'm working on. I was more just curious.
10:40:09 <zacts> although, the idea of porting GHC to a new platform makes sense
10:40:29 <zacts> that's where I could see it being totally useful
10:41:37 <solonarv> dmwit: perhaps you can write predNat :: KnownNat n => Either (n :~: 0) (n :~: 0 -> Void, Dict (KnownNat (n-1))) and that would be enough
10:41:44 <Adeon> yeah C compiles to a whole lot of platforms
10:41:46 <cocreature> zacts: https://gitlab.haskell.org/ghc/ghc/wikis/building/unregisterised
10:41:52 <solonarv> zacts: I vaguely recall that the C backend is somewhat deprecated
10:41:57 <Adeon> with GHC you may or may not need to also port the RTS itself so it's not always that easy
10:41:59 <dmwit> solonarv: Would it? I don't see how.
10:42:13 <solonarv> there is also an LLVM backend which can be used for porting to new platforms
10:42:50 <solonarv> I think originally the main mode of operation for GHC was to produce C and then throw that a C compiler
10:42:57 <dmwit> (I'm happy to accept that I could implement that type.)
10:43:07 <dmwit> (With sufficient unsafe bludgeons.)
10:43:24 <solonarv> hmm, I suppose that would not actually get you apartness-from-0
10:43:35 <zacts> cool
10:43:38 <solonarv> oh! maybe you can produce (n :~: (n-1)
10:43:52 <solonarv> * (n :~: (n-1)+1)
10:44:05 <dmwit> Ah, that sounds plausible and useful.
10:44:17 <fragamus> hi I need some advice. I am working with ASTs produced by    parseFileContents :: String -> ParseResult (Module SrcSpanInfo)
10:44:52 <fragamus> hi
10:45:15 <ski> does it know addition is injective, in each parameter ?
10:45:38 <dmwit> solonarv: Hm, seems even ((n-1)+1) isn't obviously apart from 0 to GHC. =/
10:45:39 <fragamus> I am trying to write a traversal of the AST
10:46:43 <dmwit> (Nor n+1 for that matter.)
10:46:58 <cocreature> dmwit: even with ghc-typelits-knownnat and ghc-typelits-natnormalise?
10:47:06 <cocreature> typelits are basically unusable without those two plugins ime
10:47:35 <fragamus> I was able to use generic lens to get the data from the top level node which is constructed by the Module constructor
10:47:36 <dmwit> Dunno. Haven't tried them, but I've got something working so I'm sort of hesitant to Google that now.
10:48:18 <dmwit> But thanks for the tip, because if this infrastructure gets me where I want to go for creating the user-level API I'll try refactoring to use those, whatever they are, after.
10:48:44 <fragamus> I want to avoid writing by hand the recursive descent code for each type of node in the tree
10:52:03 <fragamus> So if I want to descend into [Decl l] 
10:52:27 <fragamus> I want to do it generically 
10:53:25 <fragamus> but it seems like I need to write nasty code that lists all the constructors for Decl
10:58:31 <cocreature> fragamus: sounds like something like uniplate or the lens variant of that might be what you are looking for
10:58:58 <fragamus> So the question is: given an AST node of type Module SrcSpanInfo
10:59:03 <fragamus> oh?
10:59:45 <fragamus> generic lens is definitely a helpful piece in this endeavor
10:59:57 <fragamus> i dont know uniplate
11:01:38 <cocreature> https://github.com/ndmitchell/uniplate#basic-optimisation has some examples for the kind of things that uniplate allows you to do. The lens variant is fairly similar
11:03:28 <fragamus> im reading up on uniplate now
11:30:43 <fragamus> hi I used uniplate's universe function on my ast but it returned a universe of just one subtree which is the root
11:32:57 <fragamus> the api seems really easy but it didnt seem to really traverse my ast
11:33:29 <fragamus> i verified that it has the deriving Data and Typable
11:34:12 <fragamus> which makes it seem like the GHC folks intended their ast to be traversed using universe
11:38:16 <Guest47286> hi
11:50:58 <fragamus> hmm Uniplate universe does not seem to work
11:54:42 <lyxia> How does it not work?
11:55:59 <fragamus> well it just returns an array of one element for my ast
11:56:22 <fragamus> but I expected many elements because my ast has many nodes
11:58:40 <lyxia> what's the definition of your AST
11:59:02 <fragamus> I tried the children function and it returned an empty array
11:59:21 <fragamus> my aske is that which is returned from parseFileContents
11:59:32 <fragamus> ast*
11:59:39 <lyxia> I mean the type defintion
12:01:00 <fragamus> https://gist.github.com/fragamus/0ce8acb05bdff088f1a9fb396aae8d73
12:01:52 <cocreature> using uniplate on the Module itself won’t work. That’s not a recursive AST
12:02:11 <fragamus> yeah
12:02:15 <fragamus> I see
12:02:46 <cocreature> also is that actually what you are using? you said you’re working with the GHC AST before but that looks like haskell-src-exts
12:03:04 <fragamus> I feel a painful hack coming on
12:03:27 <fragamus> yes it is haskell-src-exts
12:03:50 <cocreature> Something where uniplate could be helpful is if you want to apply it to "Expr l"
12:04:00 <cocreature> *"Exp l"
12:04:59 <fragamus> so I am doomed to write some recursive descent code here right
12:05:23 <cocreature> you should be able to use biplate to get a Traversal on Exp from your Module
12:16:55 <gabbiel> hello, what is the command used to install ghcup ?
12:18:57 <cocreature> gabbiel: have you tried the one in the readme? https://gitlab.haskell.org/haskell/ghcup#installation
12:21:38 <gabbiel> ill try that
12:27:34 <Guest69353> hi
12:30:26 <Guest69353> i have the error "cabal: No cabal file found.
12:30:26 <Guest69353> Please create a package description file <pkgname>.cabal", ~/.cabal is
12:30:26 <Guest69353> in my path. Any idea what shoud i do ?
12:30:58 <Guest69353> ~/.cabal is in my path though*
12:31:54 <merijn> Guest69353: It means "foo.cabal" where "foo" is your package name
12:32:00 <merijn> Guest69353: What are you trying to do?
12:32:50 <Guest69353> i shoud create a package description file? what for ? Sorry, a bit
12:32:50 <Guest69353> noob here
12:33:40 <Guest69353> I just wanted to compile with C-c C-c
12:33:49 <Guest69353> using emacs
12:34:18 <merijn> Guest69353: Looks like emacs is trying to use cabal to build your code, which only works for packages. If you want to use GHC directly, you'll have to change your emacs configuration
12:36:10 <Guest69353> ok thanks :merijn
12:47:57 <fragamus> cocreature et al: I have all these algebraic data types and each has multiple constructors and I want to traverse the thing. Is there any help from generics?
12:49:40 <fragamus> like I don't know which constructor was used, but I want to go down the right one and then iterate through all of the constructor arguments
12:50:45 <cocreature> I’m not sure what “the right one” is supposed to be
12:51:09 <fragamus> the constructor for that particular object
12:51:44 <fragamus> like I do a parse and get back a tree, and there's several alternatives of Module
12:52:19 <fragamus> only one is the right one for this particular piece of data
12:52:32 <cocreature> sry, I’m still not sure what exactly you are looking for but as I said before something like lens’ biplate (or the uniplate versions) allow you to traverse all childs that have a given child
12:53:07 <fragamus> yes that is the case with uniform types which is great
12:53:27 <fragamus> https://gist.github.com/fragamus/0ce8acb05bdff088f1a9fb396aae8d73
12:54:21 <cocreature> so what do you want to traverse in there? 
12:55:27 <fragamus> so I have the root of this data structure, and it is heterogeneous in nature
12:55:56 <fragamus> but say all of the nodes implement Show
12:56:32 <fragamus> argh I need to formulate a question
12:56:38 <fragamus> I will get back to you
12:56:57 <cocreature> you’ll have to get back to someone else, I have to leave now :)
12:57:12 <fragamus> yes I will get back to the universe
12:57:23 <fragamus> thanksall
13:05:45 <shadowdaemon> https://www.haskell.org/cabal/ is broken?
13:06:33 <sclv> shadowdaemon: https://status.haskell.org/
13:06:57 <shadowdaemon> Ah thanks.
13:07:18 <sclv> the main incident report: https://status.packet.com/incidents/s54kbw7yypsw
13:18:53 <alx741> hello all. What would be the equivalent of conduit/pipes in other languages? say python, java...
13:19:42 <Zemyla> Is there a library for RNG combinators?
13:20:25 <Zemyla> Like, combining the output of two generators to make one that's hopefully more random than either one individually?
13:25:28 <dmwit> Zemyla: I don't know of one.
13:34:57 <turab> A question about Parsec. Text.Parsec imports ParsecT which also has a field for "user state". Since it's a monad combinator, how is the usage of user state different from, say a monad transformer stack of ParsecT and State?
13:35:09 <turab> s/combinator/transformer
13:35:37 <dmwit> It interacts with parse failure differently.
13:35:59 <dmwit> The ParsecT state backtracks when the parser does; ParsecT applied to State doesn't.
13:38:34 <[exa]> Zemyla: pseudorandomness is usually measured in cryptographic terms, where such kinds of combinations are unpredictable in a wrong way
13:38:46 <turab> Huh interesting
13:39:30 <merijn> Zemyla: tbh, mixing RNGs is usually a great way to introduce subtle broken flaws into a RNG :p
13:39:38 <merijn> Zemyla: What do you need an RNG for?
13:40:29 <[exa]> like, who would say that 2DES is more breakable than 1DES and 3DES, right
13:41:48 <Zemyla> Pretty sure I read that if you have two separate RNGs with relatively prime periods and XOR them together, you get one that's more secure than either of them.
13:42:19 <merijn> Zemyla: "pretty sure" <- it depends a lot on details, and whether it matters depends on your end goal
13:43:00 <[exa]> Zemyla: generator periods are usually not a problem (they are impractically high in all reasonable RNGs I know)
13:43:26 <dmwit> Zemyla: What if I take an RNG, and the same RNG but just start cycling one element sooner than usual?
13:43:32 <[exa]> Zemyla: the other questions is "how sure am I that the generators won't in the same time generate sequences that XOR to 000000000" ?
13:43:35 <dmwit> Zemyla: Then I'm going to get all zeros for nearly one entire period.
13:44:32 <dmwit> (Even though the two periods are definitely relatively prime.)
13:45:22 <[exa]> Zemyla: anyway, which generators do you intend to use?
14:00:03 <Zemyla> [exa]: I figured it'd be parameterized on the generators.
14:29:58 <griddle> hmm, is there a decent way to implement Functor on a concrete type? 
14:30:13 <griddle> functor expects f to be of kind `* -> *`
14:31:18 <merijn> griddle: Depending on what you mean by "concrete type", no. But also, see: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
14:31:56 <griddle> I mean I have a type called `data Expr = ...`
14:32:13 <griddle> and I'd like to avoid having `data Expr a = ` just to implement Functor
14:32:38 <merijn> griddle: Well, what would happen if I call "fmap even" on your Expr?
14:32:41 <merijn> :t even
14:32:43 <lambdabot> Integral a => a -> Bool
14:32:44 <merijn> :t fmap even
14:32:45 <lambdabot> (Integral a, Functor f) => f a -> f Bool
14:32:57 <griddle> hmm, true. Maybe a new construct would better fit my situation
14:33:12 <griddle> Basically need to implement a pass system for a compiler, so maybe a `Passable a` class would be better
14:40:06 <dmwit> griddle: Are you sure you need a typeclass at all?
14:40:45 <griddle> not sure I do, yeah. Probably better just implementing each pass as a basic function and pattern matching on a per-pass basis
14:41:35 <dansho> does anyone know how to force a square aspect ratio in the chart library?
14:42:01 <dansho> i set the axis override dimensions to be square, but the chart still comes out kind of 'rectangular'
15:00:57 <diingus> Hi, I'm still learning Haskell, but I've got a solid grip on the semantics and compiler implementation of lazy evaluation. 
15:01:10 * dmwit waves
15:01:11 <diingus> However, I still have some issues understanding it
15:01:29 <diingus> In the example: isPalindrome xs = xs == reverse xs
15:01:47 <diingus> As far as I understand it, reverse will evaluate only when (==) evaluates
15:02:34 <diingus> And so the code generated by the compiler will iterate through the list until it hits the first difference or the end of the strings 
15:02:48 <diingus> Is my understanding correct?
15:05:30 <lavalike> diingus: that must be the definition of (==) is for Eq a => [a] yeah, the only delicate point is how reverse operates, it *has* to go through the entire list once to find the last element
15:05:37 <Mrbuck> hi hackers
15:06:52 <Guest93688> Hi guys - I just wanted to know if it was unrealistic to try to aim for a first job in haskell
15:07:19 <Guest93688> I'm not going to write a wall of text, but i have the work ethic
15:08:32 <diingus> lavalike: that would make isPalindrome O(n), right? 
15:08:42 <lavalike> diingus: yeah
15:09:18 <lavalike> diingus: worst case it *is* a palindrome, so it traverses it twice, otherwise 1 + the least index difference
15:15:57 <Mrbuck> Guest40906: not unrealistic at all
15:16:04 <Mrbuck> but no jobs in haskell :(
15:16:08 <Mrbuck> I mean not so many
15:16:25 <Mrbuck> tagged wrong on
15:16:48 <Mrbuck> he left 
15:20:14 <nshepperd> nothing encapsulates the pathos of things quite like answering carefully someone's question on irc only to realize that they already left
15:29:31 <t7> that is why you always tab complete their name first 
15:50:32 <hilmi2> \exit
16:01:30 <solonarv> lavalike: isPalindrome is always O(n) because reverse takes O(n) steps even just to return the first element
16:07:36 <dmwit> It is hard to imagine implementing isPalindrome in a way that was *not* O(n) (even theta(n)) unless you were actively trying to do stupid things.
16:14:01 <diingus> dmwit: Is there a concise bodge construct that would do it sub O(n)? All I can think of involves increased complexity due to setup function evals.
16:17:07 <dmwit> It cannot be done in sublinear time.
16:18:25 <solonarv> at least not with the [Char] representation of strings
16:19:18 <dmwit> I don't think the representation matters very much, so long as all strings are representable.
16:19:41 <Axman6> I feel like there should be a way to do it in linear time with a smaller constant, but it's too early in the morning to figure out how
16:20:08 <solonarv> if you use a flat representation (e.g. Text) you get theta(min(i, n-i)) where n is the length of the input and i is the index of difference closest to the end(s)
16:20:20 <dmwit> ...which is theta(n).
16:20:29 <dmwit> Because i can be as big as n/2.
16:20:44 <solonarv> the best-case performance is better though
16:21:03 * dmwit shrugs
16:21:05 <solonarv> because in the best case i=1
16:21:25 <dmwit> I think it's pretty unusual to care about best-case performance. Average-case or worst-case I can understand.
16:21:28 <solonarv> with [Char] your best case is also Theta(n)
16:22:16 <solonarv> this also translates to a better average depending on your input data's distribution
16:22:17 <dmwit> Certainly without saying which you mean, I would not assume best-case was meant, and I didn't see diingus say which they meant.
16:22:47 <solonarv> if you check all words in the english language, most of them are not palindromes and i will be a good bit smaller than n usually
16:23:07 <diingus> I was aiming for worst-case performance 
16:23:40 <solonarv> worst case is theta(n) and I don't see a way in which it could be faster
16:24:16 <solonarv> after all in the worst case you need to compare floor(n/2)-1 pairs of characters
16:24:24 <dmwit> Of course you could always choose the representation of strings which carries a Bool telling if it's a palindrome. ;-)
16:24:29 <solonarv> heh
16:24:54 <dmwit> Probably doesn't even change the asymptotics of any of the other operations of interest!
16:25:22 <solonarv> depends on the string abstraction you build it on top of
16:25:43 <solonarv> if you use [Char] then cons is now O(n) because you need to look at the end to update the flag
16:25:59 <dmwit> Oops, yes, cons is a killer.
16:26:28 <diingus> through my limited knowledge of the language, I'd imagine it's bounded to O(n) with (linked) lists
16:26:46 <diingus> So what other options are there?
16:27:07 <dmwit> I think what we are telling you is that it is lower-bounded by O(n) with any sane representation, not just linked lists.
16:27:08 <solonarv> and in general I don't think is-palindrome? interacts particularly well with any of the opeartions you'd want to do on a string: you just have to recompute it all the time
16:27:32 <dmwit> solonarv: agreed
16:27:32 <solonarv> yes, the worst case is always O(n) for any sane representation
16:27:56 <solonarv> linked lists just make the best (and therefore also average - no matter what your data looks like!) also O(n)
16:28:40 <diingus> it's a well worth trade-off
16:28:52 <solonarv> not really
16:29:06 <solonarv> there's not much of an advantage to String being a linked list of Char
16:29:37 <diingus> you'd be reconverting each string every time, though, when you'd mix representations 
16:29:54 <solonarv> oh, of course, but that's not something I would recommend
16:30:38 <diingus> yeah, it's probably best off to increase worst-case performance for the recurring conversion costs
16:30:39 <solonarv> my recommendation is to use Text all the time for pretty much everything
16:31:42 <diingus> ...from the "text" package?
16:31:47 <solonarv> yup!
16:32:04 <diingus> thanks, I'll definitely look into it :)
16:35:22 <heatsink> Speaking of that, what do you do about String-based library functions like in System.Process when you're using Text everywhere?
16:35:52 <solonarv> I just throw in Text.pack/unpack as needed
16:36:09 <heatsink> I see
16:36:27 <solonarv> or if they're short strings that came from another library function that returns String, I just don't bother converting to Text 
16:37:14 <dmwit> mmm
16:37:38 <dmwit> I think if you're communicating with other processes, you should be using ByteString. This will also force you to admit you must choose an encoding.
16:38:08 <solonarv> dmwit: I think they were talking about the functions for *creating* a process
16:38:12 <solonarv> those just take String
16:38:16 <heatsink> I had in mind short strings like file paths and command-line arguments
16:38:45 <solonarv> you get back Handle's which you can perfectly well use with the I/O functions from Data.ByteString
16:39:50 <dmwit> Ah, the whole FilePath part of that is distressingly hard to do both correctly and cross-platformly.
16:40:54 <dmwit> But staying in FilePath (and never being in Text for those bits, I think) gets you 99.99% of the way there.
16:41:03 <solonarv> I agree
16:41:56 <dmwit> I like you. We agree a lot.
16:56:36 <turab> I think I need help debugging this error: https://gist.github.com/trajafri/356de11603564a350a464283c967756e
16:58:34 <turab> I am expecting `vars` to be [String] since identifier is `Parsec String () String`
16:59:59 <turab> `many identifier` should be `Parsec String () [String]` according to https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec.html#v:many
17:01:14 <hpc> what's the type of parens?
17:01:49 <turab> forall a. ParsecT s u m a -> ParsecT s u m a  (from Parsec docu)
17:01:56 <turab> OH WAIT
17:02:00 <turab> Dammit
17:02:08 <turab> Thank you hpc
17:02:37 <hpc> :D
17:02:40 <turab> Parsec String () String -> Parsec String () String
17:02:45 <turab> I had that as parens haha
17:04:08 <turab> On other note, Parsec is amazing. So beautiful it makes me cry
17:04:26 <hpc> the big hint in that error message was the expected type, for future reference
17:05:25 <hpc> i once had to write parsing code in python
17:05:29 <turab> I couldn't figure out how it was expecting a type (which is why I put a type hole where I was gonna use vars). Thanks for the heads up
17:05:36 <turab> Oooof
17:05:43 <hpc> i ended up writing it in parser combinator style, then manually expanding what (>>=) would have been
17:05:57 <hpc> code was crazy verbose, but easy to read and worked perfectly on a pretty gnarly grammar
17:06:32 <hpc> it's definitely nice having it in haskell
17:06:44 <heatsink> Wouldn't monads in Python tend to overflow the stack?
17:06:47 <turab> How are megaparsec etc compared to parsec?
17:09:52 <hpc> heatsink: hence manually expanding it
17:10:11 <hpc> imagine using the Maybe "monad" in another language by putting if x == null then ... else ... everywhere
17:10:20 <heatsink> oh, I see
17:10:52 <dmj`> turab: think they have similar APIs, but megaparsec is faster
17:11:13 <hpc> also because python's facilities for functional programming are purposefully crippled, but that's a whole other thing
17:13:28 <solonarv> although most languages (including python) have a few crippled forms of do-notation that each work for one or two specific monads
17:14:37 <solonarv> try/except blocks are just Either e / ExceptT e in a trenchcoat
17:14:51 <hpc> in a program-wide trenchcoat
17:16:04 <solonarv> oh, sure
17:16:20 <solonarv> and there is some handwaving involved as to the exact exception type in question
17:19:41 <ski> should there be an `ST'-thing, for exceptions ?
17:20:05 <solonarv> wdym?
17:21:11 <solonarv> ah, actually I need to sleep
17:22:47 <ski> where you have something like `runET :: (forall e. ET e a) -> a' and `newExn :: ET e (ETExn e exn); throwExn :: ETExn e exn -> exn -> ET e b; catchBind :: ET e a -> ETExn e exn -> (exn -> ET e b) -> (a -> ET e b) -> ET e b'
17:23:51 <ski> so that you can dynamically allocate new exception labels, associated with any type you fancy, possibly determined at run-time, in each case, and then throw a value of that type with that label
17:23:58 <ski> solonarv ^
17:25:07 <turab> What exactly does it mean when Parsec says that a parser *consumes* the input
17:25:09 <ski> (in SML you can allocate a new exception constructor by `exception Exn of t', which gives you `val Exn : t -> exn'. you can even do this in local scopes, like in a `let'-`in'-`end', inside a function)
17:26:26 <ski> turab : matches the input. the input won't be considered by other parser combinators that are composed together (with the monadic or idiomatic operators, in sequence) with the current one
17:27:06 <turab> Thanks ski!
18:21:05 <Guest71883> Hi, I'm trying to understand errors in my code (I'm new to Haskell). What does this mean "-Wincomplete-patterns"?
18:21:48 <Axman6> That error says that you haven't match all possible patterns in your function
18:21:49 <monochrom> That would be explained in the GHC user's guide.
18:22:18 <Axman6> if you have foo (Just x) = x + x; you haven't matched on the Nothing case, and you'll get a warning
18:22:19 <monochrom> For a blanket answer you can ask a blanket question. For a customized answer you need a customized question.
18:24:14 <Axman6> Guest71883: -Wincomplete-patterns is the name of the flag to GHC which turns on the warning for incomplete pattern matches
18:24:29 <Guest71883> Ok, thanks
18:29:22 <halogenandtoast> For anyone that has used beam, is there a decent way to derive JSON $(deriveJSON defaultOptions ''User) gives me error: normalizeDecFor: DataD or NewtypeD required
18:30:12 <halogenandtoast> Obviously the issue here is that user is a type alias: type User = UserT Identity
18:30:13 <Axman6> is User a beam-y data type witrh a functor argument?
18:30:32 <halogenandtoast> Axman6: UserT is
18:31:48 <statusbot> Status update: All storage appears to be operational again, and hosted sites should be fully available. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5d210409035f633b443a8476
18:31:55 <Guest71883> I'm having troubles with this simple Haskell function I defined.
18:32:00 <Guest71883> availableMedia :: Library -> [Video]availableMedia lib = case lib of    [] -> []
18:32:43 <Guest71883> Where Library is type defined as [(Video, Availability)]
18:33:16 <Axman6> Jmm, I'm sure we did this last time I used Beam, but mayber we just separate types for serialisation
18:33:17 <halogenandtoast> Guest71883: what exactly is the issue?
18:33:32 <Guest71883> Though, putting aside that I haven't covered all cases of lib, I don't understand that when I go; availableMedia []
18:33:44 <Guest71883> It returns the following error "<interactive>:68:1: error:    • No instance for (Show Video) arising from a use of ‘print’    • In a stmt of an interactive GHCi command: print it"
18:33:57 <halogenandtoast> Guest71883: ghci tries to print results
18:34:08 <Axman6> you probably need to ass "deriving (Show)" to the definition of Video
18:34:22 <halogenandtoast> And it doesn't know how to `Show` a Video
18:34:40 <Guest71883> Wonderful!!! Thanks so much Axman6
18:34:47 <Guest71883> That works
18:34:56 <Guest71883> Thanks guys
18:35:37 <halogenandtoast> Axman6: I guess I probably need to do something like instance ToJSON User where toJSON = genericToJSON $ aesonPrefix camelCase
18:38:30 <Guest71883> I'm getting a warning when I compile my code and I want to know why. My code is:
18:38:47 <Guest71883> data Video = Movie Name Year | Show Name Year
18:38:53 <Guest71883> type Library = [(Video, Availability)]
18:39:22 <Guest71883> Then I use the availableMedia function (which I mentioned before); availableMedia :: Library -> [Video]availableMedia lib = case lib of    [] -> []    (video, avail):xs
18:39:45 <Guest71883> Though when I compile it, I receive a warning saying warning: [-Wincomplete-patterns]    Pattern match(es) are non-exhaustive    In a case alternative: Patterns not matched: ((_, _):_)
18:40:16 <Guest71883> However, I believe I have matched all the patterns, since the Library type can only be of the form [] or (video, avail):xs
18:40:22 <Guest71883> Q: Why am I getting this error?
18:41:12 <Axman6> are you missing the end of the function there? (video, avail):xs -> ???
18:41:38 <ski> bad layout, somehow ?
18:41:39 <Guest71883> (video, avail):xs        | avail == False  -> availableMedia xs        | avail == True  -> video:(availableMedia xs)
18:41:52 <Guest71883> Sorry for the poor layout, I'm using tabs ... I need to fix that
18:42:00 <Guest71883> Above is the rest of the function
18:42:04 <ski> don't say `blah == True', just say `blah'
18:42:13 <ski> don't say `blah == False', just say `not blah'
18:42:32 <Cale> You could also just pattern match the avail in-place
18:42:33 <ski> in this case, you can pattern-match on `True' and `False', instead
18:43:43 <Guest71883> Yep that works!
18:43:48 <Axman6> Guest71883: have you saved your code and recompiled it?
18:43:57 <Axman6> or that
18:43:57 <Guest71883> Yeah I just did
18:44:29 <ski> but the source of the warning is that GHC doesn't understand when guards are exchaustive, except when the last one is a catch-all (iow `otherwise'/`True')
18:44:29 <Guest71883> I think I have a poor understanding of guards, I'll have to read more on them
18:44:30 <Axman6> the other problem you have is GHCi doesn't know how to print out your result, since Video doesn't implement Show it doesn't know how to turn it into a String
18:44:44 <Axman6> If you write this it will: data Video = Movie Name Year | Show Name Year deriving (Show)
18:45:01 <Guest71883> Yep, I see both errors now. Thank you so much
18:45:35 <leifm> Something like `availableMedia = fmap fst . filter snd` might work
18:45:49 <ski> (or even `... deriving Show')
18:46:05 <Axman6> leifm: I would guess it's too soon to be showing solutions like that
18:46:24 <ski> leifm : or a list comprehension, yes .. but possibly the point was to gain practice with explicit recursion and pattern-matching, first
18:46:25 <monochrom> I bet there is a lens solution too...
18:47:27 <leifm> Right sorry
18:47:42 <Axman6> :t filtered (having _1) . _2
18:47:45 <lambdabot> error:
18:47:45 <lambdabot>     • Variable not in scope:
18:47:45 <lambdabot>         having :: ((a0 -> f0 b0) -> s0 -> f0 t0) -> a1 -> Bool
18:47:50 <Axman6> % :t filtered (having _1) . _2
18:47:51 <yahb> Axman6: ; <interactive>:1:11: error:; * Variable not in scope: having :: ((a0 -> f0 b0) -> s0 -> f0 t0) -> a1 -> Bool; * Perhaps you meant one of these: `hang' (imported from Text.PrettyPrint.HughesPJ), `taking' (imported from Control.Lens)
18:50:34 <Axman6> % :t each .filtered (view _1) . _2
18:50:34 <yahb> Axman6: (Applicative f, Each s1 t s2 s2, Field1 s2 s2 Bool Bool, Field2 s2 s2 a b) => (a -> f b) -> s1 -> f t
18:50:43 <Axman6> % :t toListOf (each .filtered (view _1) . _2)
18:50:44 <yahb> Axman6: (Each s1 s1 s2 s2, Field1 s2 s2 Bool Bool, Field2 s2 s2 b b) => s1 -> [b]
18:57:08 <Axman6> % :t toListOf (each .filtered (view _1) . _2) ([] :: [(Bool,Int)])
18:57:09 <yahb> Axman6: [Int]
19:04:00 <halogenandtoast> So I am trying to write servant APIs using different SQL libraries, so far I've done OpalEye, Selda, and Beam. Still planning on doing Persistant and maybe Postgresql-Typed, are there any others I should look at?
19:04:23 <Axman6> Hasql ftw
19:04:31 <Axman6> is fast, is good
19:04:50 <Axman6> more low level, but I really liked using it
19:04:59 <halogenandtoast> alrightly, I'll add it to my list to explore
19:07:45 <Axman6> you end up writing SQL queries, but often that's the most clear way to express the queries you want
19:13:40 <jackdk> also I like applicative/divisible interfaces more than lawless typeclassy ones
19:15:14 * Axman6 burnt jackdk badly with beam
19:15:35 <jackdk> also aeson
19:15:50 <monochrom> beam doesn't just burn and hurt. It can also save lives.
19:15:53 <jackdk> and I was thinking about cassava and the -simple DB libs
19:16:32 * monochrom improves jackdk's eye vision with beam operations on jackdk's lenses!
19:17:08 <monochrom> Actually when I wrote "save lives" I had using beam to cut out tumours in mind, but meh.
19:17:51 <jackdk> I'm down for anything that improves my ability to perform operations with lenses
19:46:45 <butterthebuddha> How do I put typeclass constraints on a type parameter in a newtype declaration?
19:47:48 <Axman6> you don't
19:48:18 <Axman6> it's not a good idea, type class constraints should go oni the functions that need them, not the data types (unless you're using GADTs)
19:49:50 <Axman6> I can't even remember how to add the constraint to a data type delcaration now
20:00:19 <jackdk> There used to be an extension for it, because lots of people think they need that but actually they didn't
20:02:42 <Axman6> It was valid without an extension
20:02:48 <Axman6> it was just a bad idea
20:15:55 <Cale> The problem was mainly that it restricted the type of the data constructor, while providing no information about the constrained type when that constructor was pattern matched. This is solved by GADTs, but they must be data, not newtypes, as the evidence for those constraints requires an additional pointer to a type class dictionary (or whatever other information is required)
20:17:17 <butterthebuddha> https://pastebin.com/ipgCnU2s
20:17:17 <Cale> i.e. data (Show a) => Foo a = MkFoo a  would result in  MkFoo :: (Show a) => a -> Foo a, but then wouldn't absolve you of the need for Show a constraints on functions that take values of type Foo a
20:17:34 <butterthebuddha> Can someone comment on my solution to day 01 of advent of code 2015?
20:17:39 <butterthebuddha> https://adventofcode.com/2015/day/1
20:18:58 <Cale> Just . f =<< x = fmap f x
20:20:16 <ski> (i suppose one could imagine `data Show a => Foo a = ...' being an abbreviation for the corresponding `GADTSyntax' declaration, with a `Show a' constraint on each constructor (with result type `Foo a'))
20:20:27 <Cale> yeah, that would be more useful
20:20:39 <Cale> You can now also write
20:20:47 <Cale> data Foo a = Show a => MkFoo a
20:20:57 <Cale> which is the same thing as the GADT
20:20:59 <ski> yea, right
20:21:12 * ski tends to forget :)
20:22:03 <ski> (the H98 solution felt like you really wanted to express `Foo :: (a :: *) -> Show a => *' aka `Foo :: {a :: * | Show a} -> *', iow `Show a' as a presupposition on `Foo a')
20:23:38 <Cale> Yeah
20:25:26 <ski> (otoh, it seems like one can interpret `class Eq a => Ord a where ...', either as expressing `forall a. Ord a => Eq a' (with arrow in other direction, confusingly, or as `Ord :: (a :: *) -> Eq a => Constraint' aka `Ord :: {a :: * | Eq a} -> Constraint' (presupposition))
20:25:27 <Cale> Ah, nice, you're using the same idea of constrained subkinds there that I asked SPJ about back in 2006 :D
20:25:35 <Cale> (and then never followed up on)
20:25:47 <ski> well, i've been thinking of this as presuppositions
20:26:26 <Cale> It does seem like being able to impose that sort of thing at the kind level would sometimes be helpful.
20:26:29 <ski> (and i don't know how many years since i got this idea in mind)
20:27:05 <Cale> (The only reason I know is that it came up the other day in a discussion and I searched my email)
20:27:27 <ski> compare how you could consider `A /\ B' or `A => B' well-formed logical formulae, iff `A' is wellformed, and `B' is wellformed under the assumption that `B' is *true*
20:27:40 <ski> s/`B' is *true*/`A' is *true*/
20:28:35 <ski> (so that's just special cases of `(_ : A) /\ B' and `(_ : A) => B', or `exists/sigma _ : A. B' and `forall/pi _ : A. B')
20:29:44 <ski> (e.g. `x =/= 0 => f(1/x) > 1' doesn't have a presupposition that `x =/= 0', while `f(1/x) > 1' itself does, allowing one to discharge presuppositions)
20:30:14 <Cale> Yeah, it's basically kind of wanting Sigma Type C for various classes C.
20:30:32 <ski> "Sigma Type C" ?
20:30:44 <ski> ah, right
20:30:58 <Cale> Or Sigma * C as it were
20:31:03 * ski nods
20:31:18 * ski initially read that as an english term
20:32:51 <ski> i wonder whether one could think up a situation where the two differing conceptions of superclasses would make a difference
20:33:13 * ski . o O ( "Information is a difference that makes a difference." -- Gregory Bateson )
20:44:50 <monochrom> Hey that's a great saying.
20:47:49 <ski> (<https://monoskop.org/Gregory_Bateson> has links to some books of his, like "Steps to an Ecology of Mind","Mind and Nature: A Necessary Unity",but not "Angels Fear: Towards an Epistemology of the Sacred","A Sacred Unity: Further Steps to an Ecology of Mind". he was a bit interested in the idea of language levels (as in meta, or perhaps universe levels))
21:16:50 <dmwit> :t find
21:16:52 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
21:17:10 <dmwit> :t findIndex
21:17:12 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
21:17:14 <dmwit> butterthebuddha: ^
21:17:47 <dmwit> If you're just going to convert to String, you might as well use Prelude.readFile instead of TIO.readFile.
21:18:21 <dmwit> TIO.readFile + a Text-based parser: good; Prelude.readFile + a String-based parser: good; TIO.readFile + a String-based parser: ???
21:19:02 <butterthebuddha> dmwit: My original intent was to create a Text-based parser, but that turned out to be more difficult to achieve by hand than I had imagined
21:20:02 <dmwit> :t Data.Text.foldr
21:20:03 <lambdabot> (Char -> a -> a) -> a -> Data.Text.Internal.Text -> a
21:20:55 <dmwit> :t Data.Text.foldr (\c mvs -> case c of '(' -> (1:) <$> mvs; ')' -> (-1:) <$> mvs; _ -> Nothing) (Just [])
21:20:58 <lambdabot> Num a => Data.Text.Internal.Text -> Maybe [a]
21:22:06 <dmwit> butterthebuddha: `sequence . map op` is also `traverse op`.
21:23:59 <dmwit> butterthebuddha: `Just . f =<< m` is also `f <$> m`.
21:24:22 <dmwit> (Applies to both `part_one` and `part_two`.)
21:25:19 <dmwit> I do think I'd parse to `[Floor]` (or call it `[DeltaFloor]` if you want) rather than `[Floor -> Floor]`. It's a lot easier to inspect in case you ever make a mistake and have to do some debugging.
21:26:02 <dmwit> Then you can `sum` for `applyOp`, and `scanr (+) 0` instead of `scanr ($) 0` for `scanOp`, so using it doesn't become much more complicated.
21:26:49 <dmwit> Hm.
21:27:05 <dmwit> > scanr ($) 0 [succ, succ, succ, pred, pred, succ]
21:27:08 <lambdabot>  [2,1,0,-1,0,1,0]
21:27:14 <dmwit> > scanr (+) 0 [1, 1, 1, -1, -1, 1]
21:27:16 <lambdabot>  [2,1,0,-1,0,1,0]
21:27:43 <dmwit> Oh, good. I momentarily got wary that scanr ($) might have to become a scanl to get associated correctly.
21:28:12 <dmwit> I think that's all my comments.
21:28:31 <butterthebuddha> Thanks!
21:39:21 <sofiama> I have a class with a functional dependency: class A b c | c -> b. And I want to make an instance of another class: instance (A b c) => Other c.
21:40:05 <sofiama> GHC says I should turn on UndecidableInstances: "Variable ‘b’ occurs more often in the constraint ‘A b c’ than in the instance head ‘Other c` (Use UndecidableInstances to permit this)
21:40:29 <jle`> sofiama: have you tried enabling UndecidableInstances
21:40:30 <sofiama> Shouldn't the functional dependency mean that it's not undecidable?
21:41:07 <sofiama> Other c should reduce to A b c, where b is inferred from the dependency c -> b
21:41:18 <sofiama> I think I'm missing something?
21:52:21 <lyxia> There are weird syntactic restrictions on instances, and FunctionalDependencies doesn't remove them.
22:16:37 <nshepperd> that message doesn't mean your constraints are undecidable, just that the method ghc uses couldn't prove them decidable
22:17:30 <nshepperd> (funnily enough, deciding whether something is undecidable or not, is itself undecidable)
22:30:22 <heatsink> I'm playing with the online demo of the GPT-2 language model
22:30:32 <heatsink> It can recognize Haskell code and extend it into a blog post about type-safe abstractions
22:31:48 <Axman6> I don;t know what that is but would like to
22:31:52 <heatsink> I was expecting syntax errors, but kind of surprised that it managed to balance all the parentheses
22:33:22 <heatsink> The demo is online at talktotransformer.com.  You can type some text and it will generate more text based on your prompt
22:33:33 <heatsink> The bottom of the page has a link with more technical details
22:35:02 <sullyj3> https://pastebin.com/uLVXSSLf Is there a nicer way to do this without writing the word "True"?
22:36:02 <Axman6> by using optparse-applicative? =)
22:36:10 <heatsink> You could use guards.  doIt args | isHelpSwitch args = putStrLn "help text"
22:37:08 <sullyj3> Thanks, both of those look nice
22:37:15 <sullyj3> guards was too obvious for me to think of it hahaha
22:37:46 <Axman6> yeah using the guard is definitely more idiomatic IMO
23:25:53 <butterthebuddha> Can I set GHC extensions I want globally in all projects in stack?
23:29:35 <Cale> butterthebuddha: Not sure that makes sense, how would anyone else build your projects?
23:30:04 <butterthebuddha> Stack would add them in every new project I build?
23:30:22 <Cale> Ah, so just changing the "skeleton" as it were
23:34:09 <butterthebuddha> yep
23:45:25 <tdammers> I'd strongly recommend doing this on a per-project basis. Most pragmatic way of doing that would be to just include the extensions you want in your project template (for whatever it is you use to scaffold a new project)
23:46:19 <tdammers> idk what the status of stack new is these days, whether you can provide your own templates etc.
23:55:31 <mmaruseacph2> you can provide templates
23:55:37 <mmaruseacph2> though the syntax is a little bit cumbersome
23:56:16 <mmaruseacph2> or maybe it feels like this because I haven't started a new project in months
