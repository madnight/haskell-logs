00:03:00 <cocreature> Is there any way to turn on profiling for only part of an executable’s runtime (controlled by the executable calling function to turn it on/off)? I have an application with a long and expensive startup but I’m interested in profiling the part after startup
00:03:19 <cocreature> They run through the same codepaths so they are hard to differentiate in the profile
00:15:01 <MarcelineVQ> cocreature: there's http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Profiling.html to at least get control over time info
00:19:09 <cocreature> MarcelineVQ: ah perfect, I thought I knew I had seen that before but failed to find it now. Thanks!
00:19:40 <Axman6> does any profiling info make it into event logs these days?
00:21:25 <Axman6> there's so much good stuff under the GHC namespace that I always forget about
00:21:25 <cocreature> Axman6: heap profiling does and mpickering’s eventlog2html visualizes it nicely and allows you to use markers
00:21:38 <cocreature> but afaik time profiling doesn’t make it into the eventlog
00:35:06 <sicklorkin> cocreature: can you marshall the data that's created at the startup and just load an existing state ? 
00:36:56 <rsoeldner> How could I use the `lookupContext` machinery to specify custom `MultipartOptions` https://github.com/haskell-servant/servant-multipart/blob/master/src/Servant/Multipart.hs#L266 ? I would like to specify different tmp path for the `TmpBackendOptions` flag
00:38:15 <alp> rsoeldner, are you using 'serve' or 'serveWithContext' to turn your servant app into a runnable wai application?
00:39:01 <rsoeldner> alp, `serve` atm
00:39:19 <alp> rsoeldner, okay, so 'serve' is a special case of 'serveWithContext', where the said context is empty
00:40:25 <cocreature> sicklorkin: not easily
00:40:31 <alp> what you'll essentially want to do is, turn your 'serve api handlers' call into 'serveWithContext api ctx handlers', and then you define 'ctx' separately, in a where clause or something
00:41:01 <rsoeldner> alp, I see let me try it :)
00:41:09 <alp> now, what's this Context thing? it's https://hackage.haskell.org/package/servant-server-0.16.1/docs/Servant-Server.html#t:Context - an heterogeneous list. Empty list is EmptyContext, ':' is :.
00:41:58 <alp> alright, fine by me =)
00:43:06 <sicklorkin> cocreature: you could print currentTime when you finish the startup process and drop all the profiling info from the hp file before that time..
00:43:39 * sicklorkin is having trouble finding a local hp file to confirm time is logged
00:45:11 <alp> rsoeldner, do feel free to ping me if you have other questions or have trouble getting the multipart options passing to work
00:45:48 <rsoeldner> alp, thank you very much, I will come back to you
00:46:16 <cocreature> sicklorkin: startProfTimer and stopProfTimer which MarcelineVQ linked me to do the trick just fine, thanks :)
01:36:22 <sphalerit> I'm a bit confused, ghc is complaining "Unexpected do block in function application" about https://gist.github.com/lheckemann/9e571298fb83ed3fb4ebe5887ac1cfa9 but I don't see what's wrong with the syntax
01:38:23 <merijn> sphalerit: It would help to have a full error and line number ;)
01:39:44 <merijn> Though I'm pretty confident that line 8 and 9 are wrong, regardless of what else may be going on
01:40:30 <srhb> Yeah, you're confusing the case herald with the let herald?
01:40:37 <srhb> Poor error message though.
01:57:55 <srhb> sphalerit: Also described here for improvement :) https://gitlab.haskell.org/ghc/ghc/issues/16097
01:58:49 <sphalerite> merijn: srhb: yep, putting more indent on the cases helped. Thanks!
02:00:37 <sphalerite> I see now there are lots of other problems with the code, but the compiler is better at explaining those ;)
02:27:34 <sm[m]> hey all. Would you know what (...) means in profiterole profiles ?
02:40:47 <kuribas> would you write differently if you know your coworkers are haskell newbees?
02:40:57 <kuribas> Like avoid monad transformers, etc...
02:41:16 <merijn> kuribas: I'd probably avoid too many extensions, etc.
02:41:44 <merijn> tbh, I think transformers are fine. It's big complex constraints of mtl style classes (and corresponding horrible errors) that confuse beginners
02:42:21 <kuribas> merijn: I have code that looks like: runMaybeT $ MaybeT (v .:? "paging") >>=  ...
02:42:42 <kuribas> merijn: it's a MaybeT over the aeson parser monad.
02:43:20 <merijn> tbh I find the .:? the most intimidating part of that
02:43:20 <kuribas> merijn: I could write it out with case, at the expense of brevity.
02:43:44 <kuribas> merijn: that's aeson
02:43:51 <merijn> kuribas: tbh, unless something is going to be 3+ nested cases I tend to prefer just using case directly (or using maybe)
02:44:10 <kuribas> merijn: it's 4...
02:44:56 <merijn> kuribas: I think the biggest thing is trying to keep the complexity orthogonal. i.e. complex confusing code is fine if restricted to small parts of the codebase and with a clean API
02:45:12 <kuribas> indeed
02:45:15 <merijn> kuribas: I think beginners struggle the most when the complexity starts bleeding out of the actually complex bits into everything else
02:45:30 <kuribas> that good design in general :)
02:45:33 <kuribas> not just for beginners
02:45:35 <merijn> Sure :)
02:47:16 <kuribas> I wonder if they would get lost in the layers of monads, but with a good IDE it can show the types.
02:52:25 <kuribas> what I like about MaybeT over Parser is that it shows the intent clearly.
02:52:37 <kuribas> You have maybe behaviour on top of parser behaviour.
02:53:19 <kuribas> the only complexity is using the right lifting combinator (MaybeT or lift)
03:00:24 <kuribas> merijn: do you think data families are problematic?
03:00:42 <kuribas> merijn: I found them easy to understand as "type level functions"
03:00:54 <merijn> Are you sure you're not thinking of type families?
03:01:20 <merijn> Type families are still fairly simple (but still not easy for beginners) I would say data families are one of the more complex things around, tbh
03:02:37 <kuribas> merijn: well data family as like a type level function, except that instead of giving another type, you give the data definition.
03:05:01 <kuribas> merijn: it looked scary when I didn't know it, but I never had much trouble understanding it.
03:06:02 <kuribas> IMO the hardest part of type level stuff is class instance resolution.
03:06:13 <kuribas> that's where it gets really hairy...
03:07:20 <statusfailed> are there any nice libraries for formatting text on the command line?
03:07:26 <statusfailed> e.g., bold, italics, etc.
03:11:15 <maerwald> yes: https://misc.flogisoft.com/bash/tip_colors_and_formatting
03:12:03 <dminuoso> maerwald: That is not a library.
03:12:14 <dminuoso> statusfailed: You can use ansi-terminal and write your own thin wrapper around it.
03:12:18 <maerwald> It's a library of knowledge
03:12:33 <statusfailed> lol
03:12:40 <dminuoso> maerwald: Please be constructive.
03:12:46 <maerwald> dminuoso: I am :)
03:12:52 <statusfailed> dminuoso: thanks, ansi-terminal looks like it might be good
03:12:53 <maerwald> It's very simple to create appropriate string wrappers
03:13:01 <statusfailed> maerwald: but why redo work :-)
03:13:07 <statusfailed> (poorly)
03:14:36 <statusfailed> dminuoso: yes, this looks perfect, thanks!
03:54:23 <sm[m]> do we have a tool that shows a profile as heatmap-colored source code yet ?
04:00:14 <sm[m]> and hmm.. what's faster than Data.List.Extra.nubSortBy ?
04:00:39 <merijn> sm[m]: Depends on the input and what you use it for?
04:00:41 <kuribas> sm[m]: we do
04:00:52 <kuribas> sm[m]: flamegraph
04:01:45 <sm[m]> merijn: ah yes.. well I want to remove the duplicates from a list of an ADT
04:02:11 <sm[m]> nubSortBy sounded right but looks suspiciously slow. Perhaps a set would be better
04:03:20 <sm[m]> kuribas: thanks, do you mean http://hackage.haskell.org/package/ghc-prof-flamegraph ? I'm looking for a screenshot
04:03:50 <sm[m]> if it wasn't clear, I want to see the original source code, coloured according to cost
04:04:06 <sm[m]> that
04:04:18 <kuribas> sm[m]: ah I see
04:05:07 <sm[m]> when we have that, optimising haskell will get easy, it seems to me
04:06:39 <merijn> I wonder how well Intel VTune works with Haskell code now that GHC can generate DWARF symbols
04:09:15 <sm[m]> more on nubSortBy: I guess I chose it because I want to (a) compare only on a certain field of the ADT (b) keep the first occurence of each, based on the original list order
04:17:13 <sm[m]> as in https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Valuation.hs#L123
04:39:28 <jholland> @run 1+1
04:39:35 <lambdabot>  2
04:49:47 <ski> @help run
04:49:47 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
04:51:47 <dminuoso> When people talk about denotational semantics in Haskell, what exactly do they mean by that? Is there a published formal relationship between Haskell and some mathematical constructions?
04:52:39 <dminuoso> Or is this something people would do with a subset of Haskell for the purpose of researching some properties of the language?
04:57:21 <merijn> dminuoso: They mean "the meaning of this code as written, detached from the consideration of any actual physical machine"
04:58:09 <dminuoso> merijn: I understand the concept of denotational semantics itself - but is there a formal specification of that meaning?
04:58:29 <merijn> Don't think so
04:58:58 <merijn> dminuoso: I meant that denotational semantics generally talks about specific mathematical objects
04:59:23 <merijn> dminuoso: And that in casual handwavey parlance it means "I'm talking purely about the abstract meaning of the code"
04:59:32 <dminuoso> merijn: Yeah, thats why I was wondering whether a paper exists that constructs mathematical objects to give Haskell a meaning.
05:00:00 <dminuoso> Or whether that's just something people pretend they *could* do but haven't actually done.
05:00:10 <merijn> the latter ;)
05:00:10 <dminuoso> (Much like Hask not being formally defined anywhere)
05:02:05 <ski> @where lazy
05:02:05 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
05:02:46 <dminuoso> ski: Mmm that seems to refer to just a subset.
05:02:54 <ski> Den. Sem. talks about ⌜⊥⌝, domain theory, &c.
05:03:14 <dminuoso> "Den. Dem."
05:03:15 <dminuoso> ?
05:03:20 <ski> Denotational Semantics
05:03:20 <dminuoso> Oh.
05:03:42 <ski> lazy / (call-)by-need reduction is a topic in Operational Semantics
05:03:53 <dminuoso> ski: Abstractly, denotational semantics could be applied to any part of Haskell though, couldn't it?
05:04:11 <ski> i'm not sure what you mean by "could be applied to any part of Haskell"
05:11:38 <hyperisco> I think it would only work on columns 12 through 36
05:14:11 <dminuoso> ski: Well, wouldnt denotational semantics assign meaning to every single syntactic entity of Haskell via some mathematical object?
05:22:29 <sphalerit> I've just finished a connect-four game in Haskell, and want to add a web frontend to see how that works in practice. Does anyone have a recommendation on how to approach this (framework? library?) I'm familiar with writing web applications in less functional languages and how HTTP works.
05:27:00 <dminuoso> sphalerit: There's a variety of options here. One option could be exposing a simple API with servant, and then writing some frontend that consumes said frontend.
05:27:09 <dminuoso> sphalerit: Another is handcrafting a miniature server with say scotty.
05:27:30 <dminuoso> sphalerit: Then there's the full blown rails-type-of "all batteries included" Yesod
05:29:00 <maralorn> dminuoso: I guess there might be den. sem. for core. But for Haskell (or every GHC feature) seems very tedious.
05:29:20 <sphalerite> dminuoso: the simple-servant-API option sounds nice. Do you have any particular recommendations for the frontend (want to use FP stuff too)? I know there's elm and purescript and ghcjs and stuff and am a bit unsure what to choose on that side as well.
05:29:41 <dminuoso> sphalerite: PureScript is a really decent language which I heard lots of good stuff about.
05:30:01 <dminuoso> sphalerite: There's also miso
05:30:28 <kuribas> is there a dead tree version of software foundations?  https://softwarefoundations.cis.upenn.edu/lf-current/toc.html
05:31:05 <kuribas> byorgey: I see you are an author of it :)
05:31:36 <maralorn> dminuoso: I think I remember some comment from simonpj (in the first video listed on the Haskell website) that the fact that Haskell is not defined from a formal model is done on purpose.
05:31:38 <dminuoso> maralorn: By "might be" do you mean it'd be a reasonable thing to do? Or that you reckon there might be some paper published with den sem?
05:31:57 <dminuoso> maralorn: Interesting, Ill have to look that up.
05:32:22 <maralorn> dminuoso: But it could be totally wrong about everything I just said.
05:33:05 <sm[m]> miso might be another nice option, helping you to generate the front end
05:33:17 <sm[m]> (sphalerite)
05:33:43 <maralorn> dminuoso: core is based on System-F. So I guess there a probably papers about the den. sem. of a big subset of core. Don‘t know about the additions that happened later in Haskell core.
05:33:59 <dminuoso> core has had additions?
05:34:05 <dminuoso> Oh you mean like coercions?
05:34:12 <dminuoso> Mmm
05:35:18 <sphalerite> dminuoso: sm[m]: right, do you have any resources that might help me choose?
05:35:42 <dminuoso> sphalerite: Im afraid not, I dont do web development in Haskell.
05:35:55 <dminuoso> servant is the extend of it :)
05:36:15 <sphalerite> dminuoso: it's a good start, thanks for the help there :)
05:37:33 <dminuoso> sphalerite: From what I have seen though, I'd instinctively grab PureScript (mostly because the ghcjs toolchain seems somewhat weird to set up)
05:37:43 <dminuoso> But that's just a personal opinion.
05:38:02 <sphalerite> I'm a nix person myself, maybe that plays into it in some way as well ;)
05:38:20 <sm[m]> sphalerite: I mention miso based on positive mentions in several similar past discussions, I don't have the links, sorry
05:38:46 <sm[m]> also, based on the quantity of working examples
05:39:04 <dminuoso> maralorn: Right thank you for the input.
05:40:56 <sm[m]> I have the idea that miso generates both the server and client apps, but perhaps I'm wrong
05:40:57 <kuribas> dminuoso: also purescript generates much less code than ghcjs and it is more readable
05:44:33 <Jonathan8> If I have a value defined in Haskell that can be evaluated at compile time, will it do so?  Like `a = 5+2` will be evaluated to `a=7`.
05:44:55 <int-e> it depends
05:45:27 <Jonathan8> Depends on what?  The level of optimization?
05:45:32 <int-e> If the type is known and it's one of the built-in numerical types then probably yes. If the type is unknown then no.
05:45:42 <dminuoso> Jonathan8: Not just the level of optimization, but the actual optimization passes.
05:46:07 <maralorn> sphalerite: You might wanna listen to one episode of the haskellweekly.news podcast.
05:46:14 <dminuoso> Note that "probably" here has some limitations.
05:46:15 <int-e> (I'm assuming -O in that.)
05:46:33 <dminuoso> Like if ⌜a⌝ remains polymorphic it cannot possibly be optimized.
05:46:37 <maralorn> sphalerite: https://haskellweekly.news/podcast/episodes/3.html
05:47:07 <int-e> :t 42 -- note that this is polymorphic
05:47:08 <Jonathan8> I will listen to that thanks.
05:47:11 <maralorn> sphalerite: They discusse Purescript vs. Elm vs. ghcjs.
05:47:11 <lambdabot> Num p => p
05:47:32 <Jonathan8> Oh right, because it does not know the actual type.
05:47:44 <dminuoso> Jonathan8: It's a bit more subtle than that.
05:47:59 <dminuoso> Jonathan8: In GHC a polymorphic value is implemented as a function taking a dictionary.
05:48:20 <int-e> Jonathan8: So the Num class could be instantiated in a way that 5+2 = 7 is false.
05:48:20 <dminuoso> In that sense you could think of => as a function and Num p as a dictionary.
05:48:32 <ski> dminuoso : well, basically, yes
05:48:46 <int-e> > 5+2 :: Expr -- case in point
05:48:49 <lambdabot>  5 + 2
05:49:03 <ski> (`a' is not polymorphic)
05:49:31 <dminuoso> ski: `a` is
05:49:38 <dminuoso> ski: Check the original example.
05:50:11 <dminuoso> ski: For what its worth, I double checked before I wrote that statement, hearing the conversation we had about "polymorphic values" and "polymorphic types" :)
05:50:39 <ski> oh, you're right, i'm sorry, i read too fast
05:50:51 <dminuoso> No worries.
05:51:31 <dmj`> Can executables compiled with no optimizations link with libraries that were compiled with optimizations? (and vice versa). I see --disable-optimization in Cabal but it isn't clear if this applies to libraries and/or executables as well. What's the relationship here
05:51:52 <dcoutts> dmj`: yes, does not affect the ABI.
05:52:32 <dmj`> dcoutts: great ! Thanks for the quick reply :) does --disable-optimization for *both* the executable and library to be compiled w/o optimizations ?
05:52:40 <dminuoso> Jonathan8: So if we consider ⌜a :: Num t => t; a = 5 + 2⌝ - then GHC will implement this as a function taking a Num dictionary. Any usage of ⌜a⌝ will implicitly be applied to an appropriate dictionary (GHC will do this internally). This function is already in weak head normal form, you cannot reduce it any further.
05:52:43 <dcoutts> it applies to both
05:53:45 <Jonathan8> Does the same logic apply to function calls?  D has a lot of fancy ct logic like there `static if`.  I want to define some global variable for whether the application is defined for 2d or 3d but I want it to be ct.  So would `if D2 then x else D3 y` optimize out the `if` and "tree shake the `y` out? 
05:53:51 <dmj`> dcoutts: Awesome, thanks again.
05:55:48 <Jonathan8> I guess C people would just use the preprocessor but I got spoiled with D and like it is ugly and not as functional (not referring to the paradigm).
05:57:43 <Jonathan8> I guess the simpler question is with the GHC Haskell optimizer remove function definitions that are never used? 
06:00:18 <merijn> Jonathan8: Unused and not exported, then maybe. Otherwise probably not, because some other code might use it
06:00:42 <merijn> Jonathan8: You can also compile via split-objs which will put every function in its own object, which can reduce the binary size considerably
06:01:17 <Jonathan8> I guess that make scene.
06:01:58 <Jonathan8> By export are you referring to the Haskell library export or somesort of DLL export?
06:02:25 <merijn> Jonathan8: I'm referring to modules exporting them
06:02:33 <infinisil> I think you could use TemplateHaskell to do stuff at compile time
06:02:51 <merijn> infinisil: That's almost certainly not worth it, though...
06:03:39 <Jonathan8> Right.
06:04:02 <Jonathan8> Thanks for y'all's help.
08:24:35 <sicklorkin> Does anyone know what canonator logic is? `sounds like he cares about the canonical / standard section stuff which is all canonator logic specifically
08:25:34 <u93> i wanna learn haskell how to start
08:25:56 <__monty__> @where learn
08:25:56 <lambdabot> https://wiki.haskell.org/Learning_Haskell
08:26:44 <u93> when reading a programming exercise I don't how to think to solve it any advice please
08:28:01 <__monty__> Do you have any programming experience?
08:29:03 <sicklorkin> i found a pdf of the little schemer on 7chan.. not going to paste any links here tho
08:30:23 <sicklorkin> u93: i found the little schemer a very good book to start with.. but it has nothing to do with haskell, more about thinking recurively 
08:30:49 <sicklorkin> it may or may not be for you tho.. 
08:40:43 <wroathe> https://gist.github.com/JustinChristensen/ec9182a5282a70d0dc0228dea9484fed
08:40:48 <wroathe> This is not the promised land
08:41:49 <u93> I have no background in programming 
08:42:00 <u93> I would like to learn to think like a programmer
08:42:21 <ski> a textbook may be a good start
08:42:23 <u93> @sicklorkin   can you write the name of the book and I will google it
08:42:23 <lambdabot> Unknown command, try @list
08:42:46 <ski> i learned from "Haskell: The Craft of Functional Programming" by Simon Thompson
08:42:54 <ski> i've also seen the following suggested
08:42:56 <ski> @where PIH
08:42:57 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
08:42:58 <wroathe> I like "The C Programming Language" for a starter text
08:43:03 <wz1000> wroathe: use type synonyms maybe?
08:43:04 <ski> @where HR
08:43:04 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/> (broken ?),<https://web.archive.org/web/20190528043209/https://homepages.cwi.nl/
08:43:04 <lambdabot> ~jve/HR/>
08:43:09 <ski> @where SoE
08:43:09 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
08:43:17 <wroathe> wz1000: This is someone elses library
08:43:24 <ski> @where HPFFP
08:43:24 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
08:43:29 <ski> you could also try
08:43:33 <ski> @where wikibook
08:43:33 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:43:36 <ski> @where HTaC
08:43:36 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
08:43:51 <ski> if you're looking for exercises, you can try
08:43:55 <ski> @where CIS194
08:43:55 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
08:44:01 <u93> Thank you so much!!
08:44:02 <ski> u93 ^
08:44:07 <wz1000> wroathe: you can still use type synonyms
08:44:22 <ski> u93 : oh, and if you have questions, or problems, come ask in here :)
08:44:45 <u93> sure ! :)  
08:47:22 <wroathe> I wonder if it's better to start an absolute beginner with imperative or functional programming?
08:48:40 * ski started with BASIC
08:48:44 <ski> @quote mutilated
08:48:44 <lambdabot> Dijkstra says: It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
08:48:45 <lambdabot> regeneration.
08:49:04 <wroathe> Hahahahaha. I hadn't heard that before. That's awesome.
08:49:30 <ski> there's also
08:49:32 <ski> @quote cripples
08:49:32 <lambdabot> Dijkstra says: The use of COBOL cripples the mind; its teaching should, therefore, be regarded as a criminal offense.
08:50:26 <ski> @quote synthetic
08:50:26 <lambdabot> minion says: PROGV is a testament to the success of synthetic methamphetamines in the rearing and education of the inveterately brain-damaged contributors to the X3J13 standardisation proceedings.
08:50:36 <ski> @quote limpid
08:50:36 <lambdabot> minion says: BOOLE is the crowning jewel perched precariously upon the perfect peak of programmer prowess, casting its limitless limpid light over the lands of those who scuff and wallow in the
08:50:36 <lambdabot> dreary dust of digital depravity and unbounded wilful ignorance of the testament of Our Lord God as channeled through the X3J13 committee.
08:51:41 <ski> (those are Common Lisp operations, which i guess whoever wrote those statements didn't like/appreciate)
08:52:25 <wroathe> It's still a valid question though. Imagine someone getting their start being exposed to the elegance of FP and then having their first introduction to being a professional developer be at a Java shop
08:53:04 <ski> apparently Julie Moronuki (see HPFFP above) was new to programming
08:53:53 <ski> i think i've also heard someone mention someone else here, who was shocked at assignment, when learning Python (i think ?) after Haskell
08:55:53 <u93> what is side effect in programming
08:56:30 <ski> something that happens "on the side", not as part of the "value" resulting from computing something
08:57:28 <ski> (in programming, unlike in medicine, a side effect can be something desirable. it can also be something undesirable. or it can have unforeseen consequences that one forgets about at another time, when restructuring code, thus causing code to not function properly)
09:00:39 <u93> @ski Thank you so much you gave very simple and understandable explanation!  :)  
09:00:40 <lambdabot> Maybe you meant: wiki src ask
09:01:32 <ski> u93 : some common examples of common kinds of effects (in other languages than, Haskell, usually side-effects) : changing (or just depending on) mutable state, randomness, communicating with the outside world (input/output), "exceptional situations", situations where there may be multiple choices for how to proceed (nondeterminism), changing where to proceed in the "recipe" (continuations)
09:02:03 <kuribas> python is far worse than BASIC
09:02:57 <kuribas> BASIC is brutally honest about being a beginner language, they even named the language so!
09:02:58 <ski> (in Haskell, these would merely be effects, not *side*-effects, because Haskell makes them part of the *value* computed by evaluating an expression. doing this has advantages, for reasoning about and restructuring code without as many surprises)
09:04:46 <kuribas> wroathe: I'd teach the beginner scheme, for example using SICP
09:04:48 <u93> for example if a user change password in haskell language this considered to be effects but in java or any OP language it is a side effect
09:05:27 <kuribas> wroathe: because it supports all paradigms.
09:05:33 <ski> u93 : btw, fyi, it's not IRC custom to adorn nicknames with sigils like `@'. (IRC is not Twitter.) if you want to refer to or address someone, you can just mention their nickname in the message. some IRC clients will highlight and possibly alert the user, when their nickname is mentioned in a message. more clients only (by default) does so, when the nickname is the first thing in a message
09:05:41 <kuribas> wroathe: then haskell (or another ML language) for learning about types.
09:06:28 <kuribas> wroathe: from there on, learning anything else is trivial
09:06:47 <u93> I didn't know that 
09:08:41 <ski> u93 : hence me informing you :)
09:08:56 <kuribas> wroathe: that is if you are serious about programming.  Otherwise I'd say just use python and flask to make a basic website, but then you should know you are programming in a toy language.
09:09:21 <kuribas> sadly all python beginner books will tell you that python is modern and industrial strength.
09:09:37 <u93> ski: yes thanks
09:11:36 <ski> u93 : programs are sometimes likened to recipes
09:12:34 <u93> I feel my mind strectcing when trying to read a code 
09:13:57 <u93> anyone know what language used to make this website?
09:18:30 <u93> is there here anyone will start computer science at chalmers in coming september
09:19:36 <sicklorkin> u93: what's the most common 4 letters you see at the end of a url?
09:19:58 <u93> .net
09:20:25 <sicklorkin> I was looking for `html`
09:20:37 <glguy> Have you tried the world wide web?
09:21:05 <u93> you mean this website is completly designer with html
09:21:42 <sicklorkin> https://tools.ietf.org/html/rfc1866
09:22:29 <u93> guys wow a book from 1995
09:29:10 <flebron> Hi folks :) If I have a Monoid a, is there a nice way to go from [a] to Maybe a? If the [] is empty, I want to say Nothing, otherwise Just mconcat all the things.
09:30:27 <glguy> maerwald: I asked you about it before but didn't actually execute on it. what's the right way for me to update ghcup's check_required_commands to not look for xz on darwin? The script is already smart enough not to call xz on darwin so I believe it just need to stop checking for it
09:30:36 <wildtrees> @type safeHead 
09:30:41 <lambdabot> error: Variable not in scope: safeHead
09:30:49 <ski> u93 : this is not a website, it's an IRC (Internet Relay Chat) network. you happend to be connected to it, via an IRC webclient (at a website), in your browser. however, many other of us are connected via standalone IRC clients, not running in a browser
09:30:50 <wildtrees> @type maybeHead 
09:30:55 <lambdabot> error: Variable not in scope: maybeHead
09:31:08 <glguy> maerwald: Should I just take it out of the list in the for loop and make it its own check that runs if my_distro isn't darwin?
09:31:20 <ski> @hoogle maybeHead
09:31:20 <lambdabot> HaskellWorks.Data.FingerTree.Strict maybeHead :: Measured v a => FingerTree v a -> Maybe a
09:31:22 <flebron> wildtrees: That wouldn't have the right semantics, it just picks the first thing :)
09:32:06 <ski> flebron : sounds more like a `Semigroup' operation, to me ..
09:32:14 <flebron> Interesting, why?
09:32:18 <wildtrees> flebron, yea :( 
09:32:50 <wildtrees> flebron, you could just code it up, it shouldn't be too large 
09:33:17 <ski> @type listToMaybe  -- `safeHead' ?
09:33:20 <lambdabot> [a] -> Maybe a
09:35:39 <jle`> flebron: fmap sconcat . NE.nonEmpty
09:35:54 <flebron> Yeah that works :)
09:35:59 <jle`> flebron: since you never ever use 'mempty'
09:36:12 <jle`> which is why it deoesn't feel monoidy
09:37:02 <ski> @hoogle nonEmpty
09:37:02 <lambdabot> Data.List.NonEmpty nonEmpty :: [a] -> Maybe (NonEmpty a)
09:37:02 <lambdabot> Data.List.NonEmpty.Compat nonEmpty :: () => [a] -> Maybe NonEmpty a
09:37:02 <lambdabot> Hedgehog.Gen nonEmpty :: MonadGen m => Range Int -> m a -> m (NonEmpty a)
09:39:16 <maralorn> flebron: If you really have a monoid you wouldn’t really need the Maybe. The concat of the empty list should be mempty.
09:40:35 <ski> well, there can be situations where one doesn't want that, even if one's semigroup is also a monoid
09:40:38 <jle`> yeah you're basically "substituting" mempty for Nothing
09:40:58 <maralorn> Of course.
09:41:04 <jle`> it's the same as \xs -> let result = mconcat xs in if result == mempty then Nothing else Just result
09:41:32 <maralorn> jle`: Well you could encounter [mempty].
09:41:56 <maralorn> So it‘s not exactly the same.
09:42:25 <jle`> ah, good point
09:51:13 <Lears> There's also `foldMap Just`, though its elegance is offset by needless inefficiency.
10:04:20 <gobby> is it possible for a function to hang because its returning a huge list? More than 200 items is being returned.
10:09:26 <boj> > [1..200]
10:09:34 <lambdabot>  mueval-core: Time limit exceeded
10:09:41 <ski> that, in itself, should be no problem
10:09:45 <ski> @slap lambdabot
10:09:45 <lambdabot> I'd rather not; lambdabot looks rather dangerous.
10:09:57 <hyperisco> Experimentally, it might be true :P
10:10:02 <boj> well, that was interesting
10:10:09 <hyperisco> Nah, lambdabot does that all the time.
10:10:19 <boj> "ironic"
10:11:00 <hyperisco> It runs on an Oster toaster, and it takes some time to warm up.
10:11:03 <boj> gobby: are you doing a lot of IO to build that list?
10:13:14 <sicklorkin> > take 200 $ iterate (+1) 0
10:13:20 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:13:55 <gobby> boj, I am
10:14:10 <gobby> boj, it may be a parser error (parsing .dot files)
10:15:05 <boj> gobby: perhaps your parser isn't moving forward due to broken input and unhandled errors?
10:15:22 <gobby> boj, I think that's more likely it, thanks
10:15:38 <boj> gobby: yep, good luck :)
10:28:49 <sicklorkin> flebron:  listToMaybe' = fmap fst . sequenceA . (id &&& listToMaybe )
10:29:37 <phadej> a
10:40:42 <gobby> I have another question. I'm using `Tree` from `Data.Tree` to track dependencies (parse the output of `stack dot` and build a dependency tree based on that). The trouble is I can build a Tree that terminates storing about 100 dependencies. However if I try to build a tree with 200 deps, it does not terminate.
10:40:52 <gobby> If I use a rose tree that stores its subtrees in a Set rather than a List (current implementation) will this help?
10:48:22 <infinisil> gobby: Data.Tree doesn't behave differently for 100 or 200 items
10:51:49 <cocreature> gobby: inserting a bit of debugging output via Debug.Trace can often help figuring out why you run into an infinite loop
10:54:46 <gobby> cocreature, I'll try it
11:02:46 <dmwit> gobby: 200 is not a big number for computers.
11:03:10 <gobby> I've narrowed it down to my algo, it's very naive
11:03:11 <dmwit> So I think your current guess about what the problem is is probably incorrect, and you should dig more carefully.
11:16:47 <dada_cetacean> i have an (m a) and an (m b), is there a nice applicative way to form the pair m (a, b)?
11:17:11 <merijn> dada_cetacean: liftA2 (,) ? :p
11:17:27 <merijn> or "(,) <$> myMA <*> myMB"
11:17:38 <merijn> > (,) <$> Just 3 <*> Just True
11:17:41 <lambdabot>  Just (3,True)
11:18:03 <dada_cetacean> omg... is (,...,) parsed as the n-ary tuple formation?
11:18:07 <dada_cetacean> or is it just (,) for pairs?
11:18:16 <merijn> > (,,) 1 True 'a'
11:18:23 <lambdabot>  mueval-core: Time limit exceeded
11:18:28 <merijn> > (,,) 1 True 'a'
11:18:31 <lambdabot>  (1,True,'a')
11:18:34 <merijn> Man, lambdabot is slacking sometimes
11:18:46 <merijn> dada_cetacean: Man, wait until you discover the TupleSections extension :p
11:18:59 <dada_cetacean> thanks merijn!
11:19:11 <merijn> > (,2,,True,) [1] 'a' 3.5
11:19:14 <lambdabot>  ([1],2,'a',True,3.5)
11:19:18 <merijn> Magic!
11:23:54 <ski> @slack lambdabot
11:23:54 * lambdabot secretly deletes lambdabot's source code
11:24:00 <lavalike> > (,,',',",,',',",) ',' ",," ",',,"
11:24:06 <lambdabot>  mueval-core: Time limit exceeded
11:27:01 <hyperisco> Oh, that's painful.
11:27:32 <rosterok> i'm not a haskell developer and often hear lenses mentioned as THE solution to a lot of problems in other typed languages, such as when working with deeply nested json.  what are some of the struggles with working with lenses?  are errors hard to catch?  how about when introducing this to new team members?
11:32:36 <hyperisco> rosterok, Complex types, byzantine errors (due to the types), and a zoo of operator names (which are not necessary but helpful).
11:34:12 * anton-latukha[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/SyHmYdRiqrbTWzAqbBhMFzFh >
11:34:26 <glguy> anton-latukha[m]: your message was too long
11:35:04 <anton-latukha[m]> Oh, as always.
11:35:24 <rosterok> hyperisco: thanks
11:36:40 <anton-latukha[m]> Org-mode Haskell dictionary, Cat terms, definitions, drill cards, html: https://bit.ly/2YqkTe2
11:42:07 <ski> (re cartesian product) `∀ a ∈ A, ∀ b ∈ B : A × B = \overset \rightharpoonup {(a,b)}' looks confused to me
11:44:02 <ski> (and the way you describe signatures of operations, under the category theory heading, looks confusing)
11:45:12 <anton-latukha[m]> <ski "(re cartesian product) `∀ a ∈ A,"> Yup, that deserves summ of all (a,b).
11:46:14 <anton-latukha[m]> <ski "(and the way you describe signat"> Well, the majority is Haskell, second biggest is Category, then other fields also. Cartesian is not under Category subheading.
11:49:39 <anton-latukha[m]> Ahh, I know that I made a more explicit notation in Category theory. It is because Category theory notation has different version of notation of:
11:49:41 <anton-latukha[m]> morphism, identity morphism, Hom set, Hom functor, functor... and so on and so on.
11:51:39 <anton-latukha[m]> Main category theory notation does not use superscript or subscript. Which is strange to omit. F: C -> D - is strange in-line writing, which mixes up with first-order logic expressions.
11:52:49 <anton-latukha[m]> And what is from I, T, Y, D, G is what. (It is obvious - right)
11:53:28 <ski> in `∀ a ∈ A, ∀ b ∈ B : A × B = ...', why are you mentioning `a' and `b' outside the equality at all ?
11:53:40 <ski> it's not like they are mentioned in the left hand side of the equality
11:54:33 <ski> mixes up with first-order logic notation, how ?
11:54:48 <anton-latukha[m]> So, probably the objects - as the smallest units - small letters.
11:54:49 <anton-latukha[m]> Largest abstraction - Categories - is in the special math font, that how they do in most other math theories.
11:55:22 <ski> anyway `(a, b)\mathcal{C} ˆ (b, c)\mathcal{C} ≡ (a, c)\mathcal{C}' looks confusing to me, especially as you later say `h ˆ (g ˆ f) ≡ (h ˆ g) ˆ f'
11:56:01 <anton-latukha[m]> \forall F: C \to D : x \in C, F: C \to D in X.
11:56:05 <ski> so, it appears you're using `ˆ' for composition of morphisms .. but then it's really confusing to also use it in `(a, b)\mathcal{C} ˆ (b, c)\mathcal{C} ≡ (a, c)\mathcal{C}' !
11:56:12 <anton-latukha[m]> Something like that.
11:56:35 <ski> presumably `(a, b)\mathcal{C}' and `(b, c)\mathcal{C}' and `(a, c)\mathcal{C}' are not morphisms, but *collections* of morphisms !?
11:56:40 <ski> that's completely different
11:57:24 <Boarders> could someone remind me how to pass command line options to cabal, I am trying to do cabal new-run --ghc-options="+RTS -T" --regress="allocated:iters" using the criterion library but it doesn't work
11:57:28 <ski> i can't parse `\forall F: C \to D : x \in C, F: C \to D in X'
11:59:30 <anton-latukha[m]> <ski "presumably `(a, b)\mathcal{C}' a"> Yep, some of it was before I established notation. Some rules of notation I do not know even now. I searched for it honestly. I am still learning, still reviewing, still writing, it was one-man effort.
12:00:25 * ski thinks <matrix.org>'s style of responding to messages is slightly annoying
12:01:44 * dmwit too
12:03:11 <anton-latukha[m]> Well, I am in for a critique. It would be some time until it gets polished better. The thing is - I need to become way better then beginner to really write-through & polish the notes perfectly.
12:05:03 <wroathe> Boarders: Seperate cabal args from prog args with --
12:05:19 <wroathe> i.e. cabal foo --ghc-opts... -- --my-prog-arg=foo
12:06:08 <anton-latukha[m]> I got everything up to special monads, and seen that that high-level topics become too deep&broad for me alone to write further, maintain it. So I am guessing to polish to monad transformers and lenses.
12:06:13 <Boarders> wroathe: thanks very much!
12:06:18 <wroathe> cabal new-run --help documents this behavior in the examples section at the bottom
12:06:35 <anton-latukha[m]> The volume of notes already a size of a big masters degree.
12:07:22 <sicklorkin> Does anyone know who developed the typeclasses courses?
12:07:29 <wroathe> Boarders: Also at the top: Usage: cabal new-run [TARGET] [FLAGS] [-- EXECUTABLE_FLAGS]
12:11:42 <u93> någon chalmister här
12:12:59 <Vq> Skulle förvåna mig om det inte fanns minst en.
12:19:11 <Boarders> wroathe: I'm still having trouble: should I expect: cabal new-run --ghc-options="+RTS -T" regress allocated:iters
12:19:13 <Boarders> to work or not
12:19:46 <merijn> Boarders: Which program do you expect to get the ghc-options?
12:19:58 <dcoutts> --ghc-options="+RTS -T" is almost certainly not what you mean/want
12:20:03 <Boarders> I see
12:20:13 <Boarders> I want the executable to get those options I believe
12:20:48 <Boarders> or perhaps I am not meant to write ghc-options
12:20:51 <dmwit> I suspect you'll have to do something like cabal new-run --RTS regress -- allocated:iters +RTS -T
12:21:16 <dmwit> --RTS to stop sending RTS options to cabal, -- to stop sending non-RTS arguments to cabal
12:21:27 <merijn> Boarders: Presumably you want "cabal new-run regress -- +RTS -T -RTS allocated:iters"
12:21:40 <Boarders> regress is supposed to be an option to criterion
12:21:56 <dmwit> merijn: Since the RTS argument parser runs before cabal's argument parser, I suspect that will pass +RTS -T -RTS to cabal's runtime rather than regress's.
12:21:59 <merijn> Boarders: Then what are you running?
12:22:02 <anton-latukha[m]> ski: Can you point to good First-order logic notation rules. Online or in books. If you do not know from the hip - then don't bother. I would continue search in my own time then, some day.
12:22:08 <dcoutts> you need the --RTS as dmwit says, or the RTS option will go to the RTS instance running cabal first
12:22:13 <merijn> Boarders: new-run expects an executables/test name
12:22:41 <Boarders> merijn: I have an executable performing benchmarks, there is only a single exe in the project
12:22:55 <dmwit> new-run demands an executable name even if there is just one executable.
12:22:59 <merijn> Boarders: I'm not sure cabal guess that you want that one
12:23:37 <dmwit> (If there are no arguments to the executable, *then* perhaps you may omit the executable name, I don't know.)
12:24:04 <anton-latukha[m]> <anton-latukha[m] "ski: Can you point to good First"> This looks good: http://www.cs.yale.edu/homes/piskac/teaching/decpro-729/fol.pdf
12:24:25 <Boarders> it does work if I just does cabal new-run so I  hadn't realised that was a problem, thanks dmwit
12:24:33 <AnnaAlexis> Hello. I am Live in XXX Cams site (Username: AnnaAlexis). My special show starts in less than 2 minutes. Come and watch me and let's have fun together ----> https://abar.in/45EMb
12:24:43 --- mode: ChanServ set +o dmwit
12:24:48 --- kick: AnnaAlexis was kicked by dmwit (AnnaAlexis)
12:25:01 --- mode: ChanServ set +o dcoutts
12:25:03 --- mode: ChanServ set -o dcoutts
12:25:45 --- mode: dmwit set +b *!*@173.44.36.162
12:25:54 --- mode: dmwit set -o dmwit
12:26:29 <dminuoso> See, finding a Haskell gig is so hard, that people resort to streaming erotic webcam shows because they can't find a job.
12:26:31 <dmwit> Too bad IRC doesn't have a way to signal to clients that it might be interested in retroactively removing a message.
12:26:36 <dminuoso> We need more Haskell jobs to stop these messages.
12:28:45 <dmwit> (...it occurs to me that --ghc-options="+RTS -T" probably wouldn't even properly pass +RTS -T to ghc, since it would try to pass that as a single argument rather than two.)
12:29:07 <dmwit> (...maybe. I don't know how smart --ghc-options tries to be.)
12:29:27 <dminuoso> dmwit: Is something like ⌜--ghc-options="+RTS" --ghc-options="-T"⌝ an option?
12:29:38 <dmwit> I believe that is the correct way, yes.
12:32:25 <Boarders> cabal new-run FoldlBench --RTS -- --regress allocated:iters  +RTS -T
12:32:32 <Boarders> this is what I wanted, thanks for the help
12:32:36 <Boarders> particularly dmwit!
12:33:13 <cocreature> dmwit: afaict it does split the argument to ghc-options on spaces but I might be misreading the code
12:33:26 <dmwit> OK!
12:34:26 <u93> vad plugar du
12:35:06 <dcoutts> Boarders: for future reference, it's much easier to build-in the rts flags into the executable binary
12:35:35 <Boarders> dcoutts: how do I go about doing that?
12:35:41 <dcoutts> use "ghc-options: --with-rtsopts=-T" in the section for your benchmark 
12:35:55 <Boarders> ah, thank you
12:35:57 <dcoutts> in your .cabal file I mean
12:36:33 <merijn> Boarders: There's also a neat shell script abuse trick to more easily new-run stuff :)
12:38:14 <merijn> Boarders: Just add something like http://dpaste.com/2KYB126 to your repository and make it executable
12:38:39 <Boarders> :)
12:38:46 <merijn> Boarders: I have more complicated ones that automatically determine the directory of the script, locate the project file relative to it and then run the executable
12:39:45 <u93> någon som plugar Datavetenskap här?
12:40:29 <dmwit> Boarders, merijn: I use dpaste.com/13E8DAP
12:41:21 <dmwit> It just adds exe: to your executable name (if it wasn't there already) and -- after the executable name (if there isn't one anywhere yet).
12:41:47 <dmwit> So `cabal new-run exe:foo -- bar baz` can just be `cr foo bar baz`.
12:42:25 <dmwit> (And there are manual escape hatches for when you need more complicated stuff: `cr foo --arg-for-cabal -- bar baz`, e.g.)
12:50:32 <literall1Crevice> I have a `data GameState = Running | GameOver Team`. I then have a function renderGame which takes a Game (includes the state and other stuff), and I want to "match" against the Team if the state is indeed GameOver. How would I do that in the most concise way?
12:52:12 <literall1Crevice> I know I can do that in a case, but that just adds nesting that I'm not interested in. Is there another way?
12:52:21 <hyperisco> literall1Crevice, function clauses
12:53:08 <literall1Crevice> hyperisco: I don't get what you mean
12:53:37 <hyperisco> f 0 = 1; f n = n * f (n - 1);  defines a function  f  with two clauses
12:53:37 <dmwit> literall1Crevice: case gameState of Running -> ...; GameOver RedTeam -> ...; GameOver BlueTeam -> ...
12:54:13 <literall1Crevice> dmwit: Yeah, as I said I know about case ofs. I was referring to maybe a better way using guards
12:54:33 <hyperisco> | GameOver team <- gameState
12:54:47 <dmwit> Oh, okay. I thought perhaps the complaint was that you need two separate `case`s, one for the `GameState` value and one for the `Team` value.
12:54:57 <dmwit> You can merge those pattern matches.
12:55:29 <dmwit> How are you currently matching on the game state?
12:55:35 <dmwit> (If not with a pattern match...?)
12:56:05 <literall1Crevice> Well, I'm not currently
12:56:09 <literall1Crevice> hyperisco: Amazing, ty!
12:56:35 <dmwit> I don't understand how hyperisco's suggestion addresses your concern here.
12:56:50 <literall1Crevice> I'll upload it in a second
12:56:52 <dmwit> I'd be interested to see some concrete code you don't like.
12:56:55 <EvanR> i don't understand hyperisco's suggestion really
12:56:55 <dmwit> ...yeah =)
12:57:17 <hyperisco> Years of SO has taught me how to give the one liner top-ranking answer :P
12:57:34 <dmwit> ("...yeah =)" is referring to "I'll upload it in a second", not "i don't understand hyperisco's suggestion")
12:57:41 <literall1Crevice> http://ix.io/1PDI
12:58:47 <hyperisco> Oh see there we go, because you cannot use a lens in a pattern. Well, there are view patterns, but someone else will have to guide you through those.
12:59:06 <dmwit> Depending on how Game is defined, you might consider the non-lensy version of this.
12:59:13 <literall1Crevice> hyperisco: What do you mean? The code I uploaded works
12:59:31 <dmwit> renderGame p (Game { gameState = GameOver RedTeam }) = ...; renderGame p (Game { gameState = GameOver BlueTeam }) = ...
13:00:02 <literall1Crevice> dmwit: Why's that better?
13:00:17 <hyperisco> I was just learning why my suggestion actually helped…
13:00:40 <EvanR> what is the full picture of your suggestion?
13:00:44 <hyperisco> In other words I was learning what the X was to your Y.
13:01:11 <dmwit> literall1Crevice: Because it doesn't require the introduction of an arbitrary name g that you don't care about and immediately throw away.
13:01:38 <literall1Crevice> Ah, I prefer it as it is
13:03:03 <literall1Crevice> Also, does anyone have a suggestion on beautifying the if condition there? Aside from creating another function, of course.
13:03:20 <hyperisco> Really you should usually avoid projecting arguments, because you've unnecessarily made your function more specific than it need be
13:03:51 <hyperisco> And so instead you'd map your function onto whatever larger structure you want to apply it to
13:04:45 <literall1Crevice> Once again, I'll need this explained in simpler words
13:05:05 <dmwit> Does the gameClue need to be preserved across the Spymaster's turn?
13:05:29 <hyperisco> Alright, well, one might wonder why you didn't define  renderGame  for  Player -> (Game, String) -> Text
13:05:50 <literall1Crevice> dmwit: No, when it's his turn the gameTurn doesn't mean anything
13:05:51 <hyperisco> You'd probably say "because what's the string for?"
13:06:28 <hyperisco> Well, then go through this same routine for Game. Why is it defined for Game if only the GameState is needed?
13:06:30 <dmwit> literall1Crevice: I understand it's not intended to be used *during* the turn. But it may need to be preserved anyway if it is to be re-introduced at the beginning of the next turn. So this is my question: does it need to be preserved *across* the Spymaster's turn?
13:07:46 <literall1Crevice> hyperisco: Well, if the gamestate isn't GameOver then I do need to access the rest of the game
13:08:20 <literall1Crevice> dmwit: The spymaster supplies a new clue, completely destroying the previous one
13:09:03 <dmwit> literall1Crevice: Very good. Then one way you could massage this would be to store the clue (if any) in the role. The Spymaster role would not contain one; all other roles would.
13:09:39 <dmwit> literall1Crevice: Then with the derived Foldable instance for this modified role type, you could `foldMap renderClue` to get either the result of rendering the clue (if it is not the Spymaster) or "" (if it is).
13:09:59 <dmwit> `foldMap renderClue (g ^. gameTurn.playerRole)`, more completely.
13:10:32 <literall1Crevice> dmwit: Hmm, interesting
13:10:36 <dmwit> % data Role a = Plebian a | Aristocrat a | Spymaster deriving Foldable
13:10:36 <yahb> dmwit: 
13:11:19 <dmwit> % data Role a = Plebian a | Aristocrat a | Spymaster deriving (Show, Foldable)
13:11:19 <yahb> dmwit: 
13:11:20 <ski> u93 : fråga i #haskell.se eller #haskell.scandinavian ?
13:11:22 <dmwit> % (foldMap unlines (Plebian ["hello,", "world"]), foldMap unlines Spymaster)
13:11:22 <yahb> dmwit: ("hello,\nworld\n","")
13:13:59 <texasmynsted> When I look in hackage etc, there many many options. If you were going to build a url redictor thing like bit.ly what library would you use?
13:14:32 <texasmynsted> Need to narrow my search a bit for smallest, lightest, most FP.
13:15:39 <texasmynsted> snap, servant, webapi, other?
13:16:15 <literall1Crevice> :q
13:18:30 <MarcelineVQ> even just spock or scotty would work
13:18:44 <texasmynsted> Yes many many working options.
13:19:15 <texasmynsted> in this case my goal is to find the smallest, lightest, most FP.
13:21:20 <MarcelineVQ> the first two are probably warp, the last is a bit vague as a requirement
13:22:36 <ski> u93 : fråga i #haskell.se eller #haskell.scandinavian ?
13:23:04 <u93> jag hittat inte de channel som du påpikar på :)
13:23:27 <ski> /join #haskell.se
13:24:32 <texasmynsted> Thank you. Yes, the last requirement was not helpful.
13:24:57 <ski> u93 : ^ that's an IRC command, if you type it into the Kiwi Freenode webchat client, then hopefully you'll join that channel
13:26:58 <u93> Thank you!
13:33:13 <texasmynsted> warp looks like a good fit.
13:33:58 <MarcelineVQ> it's what underlies the other options you were considering afaik
13:43:24 <literall1Crevice> If I want to use Parsec with Data.Text, from where am I supposed to import shit? I have Text.Parsec.Text and Text.Parser.Char imported, and when I do `p :: Parser Text; p = many1 letter` I get a mismatch between [Char] and Text.
13:44:07 <literall1Crevice> many1 coming from Text.Parsec, letter from Text.Parsec.Char, Parser from Text.Parsec.Text
13:47:28 <___laika> you need Text.pack to go from String -> Text 
13:47:43 <___laika> im unsure if parsec has a function that will parse characters directly into a Text value
13:47:55 <literall1Crevice> Is that the only option? I assumed Parsec would export Text versions of Text.Parsec.Char
13:48:06 <literall1Crevice> Welp, that's what I'll do for now I guess
13:48:34 <lavalike> many1 returns a list
13:50:40 <literall1Crevice> lavalike: Hmm, and that combined with "letter" which returns a Char is bound to give me a String. I see.
13:50:50 <literall1Crevice> are you aware of alternatives?
13:51:21 <lavalike> nope
13:54:16 <___laika> you could simply define your own combinator to automatically wrap a Parser [Char] with Text.pack?
13:54:43 <___laika> http://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/Data-Attoparsec-Text.html#g:3
13:54:51 <___laika> attoparsec has text parsing capability
13:55:46 <___laika> and i would think megaparsec's general Token type would not prevent you from using Text but i havent used it for that
13:56:04 <u9330> how long is the average for a person with no programming background should been learnt to program
13:56:33 <crestfallen> hi does anyone know where 'build-depends' option is in the .cabal file ? can't find it in config et al .. and I'd like to add 'random' to that. I guess it would look like this : ' build-depends: '    thanks 
13:56:58 <crestfallen> ' build-depends: random '
13:57:29 <crestfallen> or do I add it somewhere , the whole line
13:58:03 <literall1Crevice> crestfallen: It's inside the executable section
13:58:16 <literall1Crevice> I think it should be there by default, though
13:58:38 <crestfallen> executable? thanks checking that literall1Crevice
13:59:26 <crestfallen> that's in .cabal/config ? 
14:00:05 <literall1Crevice> Oh, I may have misled you. I'm using stack and have a file "projectname.cabal". Do you not have one?
14:00:37 <crestfallen> oh I see I removed stack but have that file thanks
14:04:16 <MarcelineVQ> usually when you see someone mention a .cabal file it's referring to the cabal file of a project you're working on, .cabal being a shortened form of myprojectname.cabal It's not usually referring to a file in ~/.cabal
14:04:41 <ski> u9330 : depends on how good you want to get at it
14:05:06 <ski> u9330 : it's not really like you're ever done learning, ..
14:05:48 <crestfallen> literall1Crevice: thanks I had to add " , random" with another entry...it compiled.    thanks MarcelineVQ
14:06:29 <u9330> i want to start understanding how to solve problems in first year computer science
14:07:09 <ski> @where 21-days
14:07:09 <lambdabot> I know nothing about 21-days.
14:07:24 <ski> @where+ 21-days "Teach Yourself Programming .." by Peter Norvig at <https://www.norvig.com/21-days.html>
14:07:24 <lambdabot> I will never forget.
14:07:49 <crestfallen> literall1Crevice:  I did $ cabal install random   but it didn't add it system-wide I believe.
14:10:55 <ski> u9330 : btw, that link was for you
14:11:09 <u9330> Thanks a lot ski :)
14:11:58 <ski> u9330 : my advice is : try to focus more on learning fundamental concepts properly, rather than learning particular technologies, or even programming languages. definitely don't be satisfied with learning only one, or even a few languages. the more different languages you learn, the better
14:13:07 <u9330> </3 
14:13:48 <EvanR> i should take ski's advice and go on a sojourn on more out-there languages
14:17:40 <crestfallen> u9330: I'm horrible at programming, but with haskell I enjoy writing out recursive evaluation steps by hand
14:18:51 <Logio> EvanR: have you heard of Tampio?
14:18:55 <u9330> the problem is I didn't understand recursion i have watched some videos on youtube but it still a mystery
14:19:02 <EvanR> ope
14:19:05 <EvanR> nope
14:19:58 <Logio> functional programming using natural language, with the twist that the language used is agglutinative
14:20:03 <Logio> namely Finnish
14:20:32 <EvanR> well this qualifies as out-there
14:21:19 <Logio> I found it funny and actually sort of enlightening since I realized I am practically programming in that language when I program Haskell
14:22:36 <EvanR> how so
14:23:42 <Logio> if I'm thinking about a statement such as "y = f x", I usually phrase it in my head as "y is the application of f on x"
14:24:00 <Logio> which in Finnish would be a valid Tampio statement
14:24:12 <EvanR> interesting
14:25:05 <crestfallen> << gluten-free
14:28:01 <Logio> I generally switch between thinking "x is f y" in Haskell to "things are done to y to make it x" in say, Python
14:29:14 <ski> u9330 : example of recursion : "The fast sleeping cat, which caught the curious mouse, who had scared the green hat off the sleepy guard in the closed museum, that peeked out under the cupboard, woke up with a start, when from the adjoining kitchen the sound of a can opening was heard suddenly."
14:29:31 <crestfallen> well I'm not sure how the randomizer function on this ticTacToe game works. It randomly chooses from the bestmoves grid, but if I begin the game with a nought in the first box (index 0) it always places and X in the 5th box (index 4). I don't see how it selects randomly at all.    https://github.com/varreli/haskell/blob/master/hutton/tester/Main.hs
14:30:29 <sicklorkin> crestfallen: bestmoves
14:30:39 <sicklorkin> https://github.com/varreli/haskell/blob/f77e3c6cd26a9f8ac642950ccccdf8de9e715be3/hutton/tester/Main.hs#L200
14:32:19 <u9330> =$ 
14:32:34 <dmwit> crestfallen: How many moves are available to randomly choose from in that situation?
14:33:15 <dmwit> crestfallen: (What is the length of the list produced by `bestmoves g p` with the `g` and `p` you are describing in your question?)
14:33:29 <crestfallen> dmwit: hold on thanks
14:33:45 <u9330> i think my mind is broken
14:36:19 <crestfallen> dmwit: I haven't written it out but I think I see where you're going with that.
14:38:48 <crestfallen> to be certain, you're not looking at the sample grid commented out on line 173, right? dmwit
14:41:01 <dmwit> I suspect you have not asked the question you intended to. (I am looking at my water bottle right now, so no, I am not looking at line 173 right now.) But I'm not sure what question you did intend, so I can't mentally correct it and answer the corrected version.
14:41:27 <literall1Crevice> If I have a [Bool -> Card], how can I apply False to all of them to get a [Card]?
14:41:47 <dmwit> :t \vs -> sequence vs False
14:41:50 <lambdabot> Traversable t => t (Bool -> a) -> t a
14:41:57 <literall1Crevice> ty1
14:42:04 <dmwit> :t map ($False)
14:42:06 <lambdabot> [Bool -> b] -> [b]
14:42:20 <literall1Crevice> Oh now that's even better
14:42:34 <EvanR> i would have thought of map ($ something) first
14:42:41 <dmwit> I'm interested to hear why you think it is better.
14:42:47 <literall1Crevice> dmwit: Prettier!
14:42:50 <dmwit> (Not saying I disagree. I'm just curious what *your* reasoning is.)
14:43:12 <EvanR> currently computing how sequence even does the same thing. And function monad
14:43:20 <EvanR> er Traversable
14:43:30 <dmwit> Prettier? Don't you find the ($) construction a bit of an eyesore?
14:43:50 <literall1Crevice> Nah, I really like it
14:43:54 <literall1Crevice> Maybe I'm fucked though?
14:44:00 <EvanR> yes $ is ugly
14:44:11 <dmwit> Dunno! Aesthetics are notoriously hard to agree on.
14:44:11 <crestfallen> dmwit I guess I don't understand lines 200-202 quite yet
14:44:17 <EvanR> it's a word in other languages : )
14:44:30 <Rembane> Isn't there a word for it in Haskell?
14:44:33 <Rembane> :t ap 
14:44:37 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:44:39 <Rembane> Nope. 
14:44:41 <EvanR> nope
14:45:06 <dmwit> id ;-)
14:45:18 <EvanR> $ might be what many people are complaining about wrt haskell has too many weird operators
14:45:24 <dmwit> :t map (`id`False)
14:45:27 <lambdabot> [Bool -> b] -> [b]
14:46:32 <literall1Crevice> Wait what
14:46:44 <Rembane> I dunno, YMMV. I'm quite fond of all operators in Haskell. :D
14:46:59 <literall1Crevice> How does the id thing work?
14:47:19 <dmwit> literall1Crevice: ($) f x = f x; by eta reduction, it follows that ($) f = f. This is exactly the same defining function as for id, namely, id a = a.
14:47:21 <EvanR> it's straight forward. id returns whatever is passed into it
14:47:54 <literall1Crevice> Wow, that's nice
14:48:05 <EvanR> it's a bit oblique to me
14:48:16 <EvanR> despite being perfectly obvious
14:48:35 <EvanR> double think
14:48:41 <Rembane> :t id 
14:48:44 <lambdabot> a -> a
14:48:56 <dmwit> :t id `asTypeOf` ($)
14:48:58 <Rembane> :t id False
14:49:00 <lambdabot> Bool
14:49:03 <lambdabot> (a -> b) -> a -> b
14:49:14 <dmwit> :t (`id`False)
14:49:17 <lambdabot> (Bool -> t) -> t
14:49:25 <dmwit> :t flip id False
14:49:28 <lambdabot> (Bool -> c) -> c
14:49:33 <EvanR> the type of id is kind of beside the point, but it adds up
14:50:54 <ski> u9330 : recursion is like "Matryoshka dolls" ("Ryska dockor")
14:52:39 <crestfallen> ok now I get what sicklorkin was showing me . thanks thats starting to look normal.
14:53:23 <zeta_0> have any of you guys tried `guihaskell` and how does it compare to `ihaskell`, i want a good repl for experimenting and learning? https://github.com/gibiansky/IHaskell https://hackage.haskell.org/package/GuiHaskell
14:56:57 <u9330> you mean that we take a step backwards to get to the starting point okey sounds easy but when applying it in any language here lays the struggel I can't understand the difference between recursion or loop 
14:58:45 <dmwit> What if I told you it isn't important to understand the difference between recursion and looping?
14:59:40 <u9330> maybe but all labs required to write the same program but once with recursion and other with looping
15:00:27 <u9330> in first year at computer science 
15:00:35 <dmwit> Okay. "Looping" means you use one of a small handful of syntactic constructs; each language has its own small handful. For example, in C, there is for, while, and do-while. That's it.
15:00:54 <dmwit> "Recursion" means some value -- usually a function -- is defined in a way that uses its own definition.
15:01:05 <dmwit> These two statements will let you distinguish between the two.
15:01:24 <Guest_32f> https://stackoverflow.com/questions/20842970/fix-curl-51-ssl-error-no-alternative-certificate-subject-name-matches
15:09:53 <crestfallen> u9330: on lines 11 and 12, see how the function name euclid is on the right hand side of the equal sign? depending on which case is true , s < t or s >t , euclid is called until line 10, the base case, is reached. s is congruent to t , so s is returned. each step is listed on lines 15 to 20      https://github.com/varreli/haskell/blob/master/handEval/euclid.hs
15:10:30 <aln> can i ask a question about stack-oriented paradigm languages here?
15:13:27 <glguy> aln: You can ask questions about Haskell, at least
15:14:07 <aln> glguy: any suggestions on general programming channels that might be a better place to speak about paradigms generally?
15:14:26 <glguy> No, but you can check out: /msg alis HELP LIST
15:14:37 <aln> all i could find were 'X-beginners' and 'X-developers' channels
15:14:49 <glguy> Ah, OK
15:15:31 <aln> i suppose i should try 'programming'
15:15:46 <ski> aln : have you tried #concatenative ?
15:16:08 <aln> ski: good shout :)
15:16:18 * ski idly wonders what aln's questions was about
15:17:07 <pyan> aln: You can reinvent concatenative programming in Haskell, poorly, using HLists and sticking to point-free style. (Except for the basic operators: “dup”, “drop”, “rot”, “unrot”, etc., of course)
15:17:22 <pyan> It could even be fun.
15:17:43 <aln> pyan: thanks, i appreciate the answer - i was wondering about specific stack/concat languages
15:25:47 <ski> pyan : hm, i did it in plain simple H98
15:27:55 <u9330>  does recursion has anything to do with pattern matching or they are tow seperate concepts
15:28:28 <ski> separate concepts
15:28:31 <dmwit> They are completely separate.
15:30:00 <u9330> aha thanks, everyone for bearing with my fabulous question
15:36:30 <ski> (pyan : but still allowing different types for the different items on the stack)
15:48:25 <pyan> u9330: The concepts are separate. However, it happens to be the case in Haskell (i.e., an engineering decision of language design, not a logical necessity) that recursion in types goes through sum types (declared with “data”), so it is common to see recursive function calls inside pattern matching branches.
15:48:31 <pyan> ski: Using (a,(b,(c,...))) ?
15:50:31 <sicklorkin> I forget, does makeLenses need to be defined in a different module from the type declaration ?
15:57:39 <sicklorkin> I need to be careful where it's placed, makelense ignores any datatype defined after.. so having it in a separate module that imports all the things is a clearer approach.
15:58:00 <sicklorkin> s/clearer/cleaner
16:09:47 <ski> pyan : no
16:10:51 * ski would say `data' types (algebraic data types) in Haskell are sum-of-product types
16:17:04 <ski> pyan : using CPS
16:17:52 <EvanR> does that include recursive types
16:36:24 <jumper149> moin
17:00:34 <ski> EvanR, no
18:17:02 <monochrom> "data F = Ctor Int F" and "f n = Ctor n (f (n+1))" are recursion without pattern matching.
18:17:48 <monochrom> And without sum type.
18:19:32 <monochrom> It is an engineering decision of strict languages that must tie up recursion with sum types because "but but but where is the base case?!"
18:19:35 <hpc> f doesn't even need to be a function
18:19:44 <hpc> f = Ctor 5 f
18:19:57 <monochrom> Yeah but I figured a lot of 5's is a bit boring.
18:20:28 <hpc> f = Ctor 4 f -- now it is random, as averaged from a 6-sided die :D
18:20:43 <monochrom> OK that's better.
18:21:05 <dmwit> Sometimes I wonder whether xkcd actually rolled a die, or just picked 4 himself.
18:21:39 <monochrom> I would expect nothing short of a Geiger counter from xkcd. >:)
18:21:49 <dmwit> Which is a sort of delicious meta-ization of the joke the comic made.
18:21:50 <hpc> i always get recursion and induction confused
18:22:29 <Lycurgus> well one is a special case/application of the other
18:22:35 <dmwit> Understandable. Induction is just a special case of recursion that we've acknowledged leads to good proofs.
18:22:36 <monochrom> I wouldn't work hard to separate induction from recursion.
18:23:12 <dmwit> I could forgive a middle-schooler for confusing parallelograms and rhombuses, e.g.
18:23:21 <dmwit> (What names we give to these things!)
18:24:09 <fragamus> why cant we call hydrogen "1" and helium "2"
18:24:28 <Lycurgus> prolly lojban does something like that
18:24:33 <monochrom> Only people who don't actually prove their code correct can afford to make a big fuzz about "recursion /= induction".
18:24:45 <hpc> oh snap
18:24:57 <Lycurgus> they are really distinct concepts
18:25:33 <monochrom> Those of us who actually write any proof find that recursion, induction, iteration are always used together and there is no point talking about it.
18:25:45 <Lycurgus> also only mathematical induction is a special case of recursion
18:26:01 <monochrom> Just like you don't make a big fuzz about touch pad vs touch screen.
18:26:04 <Lycurgus> in general induction could be generalization
18:26:17 <Lycurgus> fuss I take it
18:26:28 <Lycurgus> but fuzz could work
18:26:32 <monochrom> I mean touch pad and touch screen that are both hard-fused into your laptop.  It's one piece.
18:26:39 <Lycurgus> if ur fuzzy
18:27:56 <hpc> "big fuzz" sounds like a conspiracy theorist's name for security researchers who use fuzzers
18:28:25 <Lycurgus> or scianta if it had gone big time
18:28:42 <monochrom> A better way to say it is "if an exam paper has to ask you what's the difference, that means the teach has run out of actual proof questions".
18:28:53 <monochrom> s/teach/teacher/
18:30:15 <monochrom> An even better way to say it is that such a question is answerable by rote memorization, therefore cannot possibly measure understanding.
18:31:12 <Lycurgus> https://scianta.com/team-members-3 i guess they are big fuzz anyway
18:31:38 <monochrom> Even a question showing a figure asking you "does this qualify as a rhombus" at least requires you to compare angles and tests a little bit of understanding.
18:37:09 <Lycurgus> cidro and solnavi (lojban)
18:37:12 * ski . o O ( `datatype foo = Foo of unit -> int * foo' )
19:02:08 <pyan> ski: Or even “datatype foo = Foo of int lazy * foo lazy”.
19:04:23 <pyan> ski: I'm still undecided whether “'a lazy” should be an abstract type or a synonym for “unit -> 'a”. But, since I am in #haskell, “lol, what is abstract type?”
19:09:17 <ski> pyan : s/lazy/susp/ ?
19:09:43 <pyan> Yes, but I call is “lazy”, not “susp”.
19:09:46 * ski . o O ( <https://www.smlnj.org/doc/SMLofNJ/pages/susp.html> )
19:10:02 <ski> that caches the result
19:11:20 * ski . o O ( "Primitives for Expressing Iterative Lazy Algorithms" (SRFI 45) by André van Tonder in 2004-04-05 at <https://srfi.schemers.org/srfi-45/srfi-45.html> )
19:35:48 <zeta_0> hello guys, what is the current ghc long term support version?
19:38:30 <solonarv> zeta_0: there aren't really designated LTS versions
19:38:43 <solonarv> the latest release version is 8.6.5
19:42:25 <zeta_0> solonarv: oh ok, i currently have ghc 8.6.4, will ghc automatically upgrade or will i have to do it manually?
19:42:41 <solonarv> it does not update itself, no
19:43:06 <solonarv> I recommend upgrading to 8.6.5 as its only changes relative to .4 are bugfixes
19:46:14 <zeta_0> solonarv: that makes sense i guess i'll upgrade then
19:46:19 <zeta_0> solonarv: thanks
19:54:43 <justsomeguy> This may be a silly question, but I'm curious; Is Haskell well suited to tasks that system administrators might do? Usually when I think of sysadmins I think bash, python, c, and golang. Haskell seems to have all the same benefits of golang (concurrency, many libraries, easily distributed build artifacts), but is more expressive.
19:55:48 * justsomeguy is fairly proficient in JavaScript, Bash, and Python. Now he's trying to decide which compiled language to choose.
19:57:34 <justsomeguy> Maybe I shouldn't have asked, it's so subjective. Would be cool if there happened to be a sysadmin in the crowd to answer, though.
19:58:01 <DigitalKiwi> take a look at turtle and/or shelly
19:58:48 <justsomeguy> Turtle was my first exposure to Haskell <3
20:00:00 <DigitalKiwi> maybe take a script you have in python or bash and see if you can write it in haskell with or without turtle. depending on the length of the script it may or may not be shorter, but at least it'll be in haskell ;)
20:00:31 <DigitalKiwi> there may be a lot of imports
20:00:55 <DigitalKiwi> also checkout nix-shell and cabal shebangs
20:01:07 <solonarv> I'm not the biggest fan of Haskell as a scripting language - in theory it could be nice but in practice I have run into a lot of friction
20:01:40 <glguy> I script my Haskell program with Lua
20:02:14 <solonarv> cabal shebangs are cool but have a really long startup time IME, "raw" runghc has no way to manage dependencies, stack script is also not the fastest to start up and additionally I don't like stack
20:02:42 <justsomeguy> I'm mostly interested in using it to do text file manipulation, web scraping, parsing, and communicating with APIs online. Also, I'd like to get a better understanding of NixOS, which looks amazing.
20:02:46 <DigitalKiwi> i'm trying to find my example that uses both nix and cabal shebangs for kicks
20:02:49 <solonarv> oh, also cabal mangles $PWD which is extra annoying
20:03:28 <solonarv> if rather than scripts you are looking to write (possibly small!) tools then I think Haskell becomes a lot more valuable
20:03:44 <DigitalKiwi> <3 nixos
20:03:48 <solonarv> and of course if they only need to run on *your* system a lot of the problems sort of disappear
20:04:21 <solonarv> I mean, if you hand someone else a script you don't really want them to spend 3 hours installing dependencies first :P
20:04:22 <justsomeguy> DigitalKiwi:  That's a good idea about rewriting bash scripts with turtle. I've thought about it before, but haven't gotten into it. Could be a good gradual on-ramp for learning basic stuff. ...Even if it does feel wrong.
20:05:39 <justsomeguy> solonarv: As for distributing small tools -- wouldn't that be easy, if it's compiled?
20:06:19 <justsomeguy> I mean, can you just distribute the binary, or will you also need to distribute linked libraries?
20:06:23 <solonarv> sure, if you can just chuck a compiled binary at people you're in pretty good shape
20:06:34 <justsomeguy> Then we're good! 
20:06:47 <justsomeguy> :D
20:06:58 <solonarv> Haskell usually links statically to other Haskell libraries, so you do not need to ship them
20:07:52 <DigitalKiwi> https://dpaste.de/HfUS this particular one will take a while but you can modify it for your purposes
20:09:30 <justsomeguy> I must admit that I don't really understand how linking works -- a grave sin for a linux guy. How can I know how build C source and modify LD_LIBRARY_PATH and not know what a linker really does?
20:09:43 <justsomeguy> s/how build/how to build/
20:09:52 <DigitalKiwi> i don't know if this is good some people like it but it's a small program that does something useful https://mostlyabsurd.github.io/posts/2019/06/09/minimal-imports-maximal-imports-examples/
20:14:02 <justsomeguy> DigitalKiwi: Does that script install the packages for it to run, make cabal aware of the dependencies so it can build them, and then print"Success take 2"?
20:16:44 <DigitalKiwi> yeah pretty much
20:20:26 <justsomeguy> Cool! Weird, but cool!
20:20:41 <DigitalKiwi> let me find the better one
20:22:16 <DigitalKiwi> https://dpaste.de/ODeY
20:22:23 <DigitalKiwi> https://dpaste.de/RObX
20:40:49 <DigitalKiwi> mhr the limp-cbc example seems to be failing now anyway
20:42:54 <justsomeguy> Thanks for your thoughts solonarv and DigitalKiwi
20:49:30 <DigitalKiwi> yw
21:03:13 <libertyprime> any emacs users here? anyone know how to get docs within emacs for haskell functions. intero-mode can give me the type of the function at the cursor but not an explanation of what the function does
21:39:16 <libertyprime> for those interested, so far the best thing i have found is eww-mode with the dash package. there is hope that one day haskell docs can appear inside eldoc
