00:03:46 * bandali nods back
00:50:36 <asheshambasta> With -Worphans; do the warnings really make sense when I want to implement missing instances of types imported from other libraries? 
00:51:10 <merijn> asheshambasta: Define "make sense"
00:51:19 <merijn> Also, I would strongly encourage rethinking doing that
00:51:42 <asheshambasta> the warnings suggests I should wrap them inside a newtype or move the instance declaration to the module or class of the type; the former is cumbersome and the latter is not possible without modifying the code of the library. 
00:52:09 <merijn> asheshambasta: Which class and types are these?
00:52:10 <asheshambasta> merijn: I'd say; make sense = is feasible/and is important to pay heed to 
00:52:48 <merijn> asheshambasta: The problem with orphans is that if anyone else ever defines orphans for the same class and type you do, that do something different, everyone who depends on both that library and yours is screwed
00:53:05 <merijn> Things will break in completely unpredictable and non-deterministic ways
00:53:41 <asheshambasta> merijn: http://hackage.haskell.org/package/iso639-0.1.0.3/docs/Data-LanguageCodes.html -- implementing ToJSON/FromJSON for the ISO369_1 type; for example
00:54:31 <Axman6> the real fix is to submit a PR to the library
00:54:39 <merijn> Axman6: That's not a fix
00:54:50 <Axman6> but that's also the slowest and least likely to succeed
00:54:58 <merijn> Axman6: That means iso639 suddenly needs to depend on aeson
00:55:47 <merijn> tbh, I find it a failing of aeson that it relies entirely on typeclasses. An approach like binary/cereal/etc. where you have explicit Put and "Get a" types (and convenience classes for creating them) is much more solid approach
00:55:53 <Axman6> then we make aeson depend on iso639... (also no)
00:56:43 <merijn> asheshambasta: tbh, I don't even think you'd need ToJSON/FromJSON for that type, you can simply handwrite an instance for whatever datatype you have that contains ISO639_1 and explicitly encode there...
00:57:31 <Axman6> then use waagonaught
00:57:40 <asheshambasta> merijn: yeah, correct, but that was just an example; I also am deriving its opaleye DB enum type instance; which will be cumbersome to handwrite. 
00:58:04 <asheshambasta> but I guess, adding newtypes is the correct way to go 
00:58:07 <Axman6> mankyKitty has done a great job with it
00:58:24 <merijn> asheshambasta: Shouldn't be too hard to write TH to generate the enum instance for you at compile time :)
01:04:19 <asheshambasta> merijn: yeah; but thanks, this clarified why this warning is important. 
01:04:33 <asheshambasta> sometimes its hard to see why 
01:05:32 <merijn> asheshambasta: If you derive Generic for the newtype you can even just have the To/FromJSON instance derived for you using that
01:07:59 <sicklorkin> merijn: have you used the TH deriveJSON?
01:08:25 <merijn> sicklorkin: I've never used JSON, so no :p
01:08:44 <sicklorkin> merijn: thats' ahrd to believe...
01:09:09 <Axman6> I've rarely had a project where I didn't need to use JSON
01:09:22 <merijn> Axman6: How many projects of yours involve the web?
01:09:50 <Axman6> lots of them are API or talk to APIs
01:09:51 <sicklorkin> Axman6: have you used the TH method for deriving JSON instances?
01:10:15 <merijn> Axman6: I hate that at somepoint people started using "API" to mean "web/http API"
01:10:22 <sicklorkin> I wanna know if thre's a noticable difference in complation time.
01:10:27 <merijn> sicklorkin: You'd be surprised how few non-web projects use JSON :p
01:10:58 <Axman6> I'd love to be using CBOR everywhere but no one else is, it's like esperanto
01:11:23 <asheshambasta> Axman6: +1
01:11:24 <Axman6> "Did you know, that for every person that speaks Esperanto, no one else does"
01:11:30 * sicklorkin uses CBOR
01:11:33 <kuribas> why do I get "Defined but not used lookupCSVFile", but it's actually used?
01:11:38 <merijn> Most of my work has been on distributed systems, compilers, language runtimes, distributed language runtimes, GPU code, and experiment orchestration, none of those things generally involve JSON ;)
01:11:48 <Axman6> sicklorkin: still got some job openings? :P
01:11:55 <sicklorkin> Axman6: for you.. yes
01:12:02 <Axman6> ha
01:12:05 <kuribas> ah, because the function that uses it isn't used...
01:12:05 <merijn> kuribas: Clearly you have two different lookupCSVFile's defined, and only using one of them :p
01:12:16 <merijn> kuribas: Ah, or that, yes
01:12:32 <merijn> kuribas: I love that GHC's deadcode warnings are transitive, tbh
01:12:34 <Axman6> sicklorkin: let me know when you're opening up your .au office ;)
01:12:36 <kuribas> merijn: that would be a different error, no?
01:12:42 <sicklorkin> Axman6: everyone is remote
01:12:46 <kuribas> merijn: yeah, it's great
01:12:48 <merijn> kuribas: Only if in the same file :p
01:13:52 <asheshambasta> afaics, if the module exports something; its considered used, so I'm not sure if the deadcode warnings are project wide (if that were possible)
01:14:21 <Axman6> weeder can find those though
01:17:36 <kuribas> hmm, people who claim that there is no advantage to static types when refactoring are so full of sh**.
01:17:53 <Axman6> amen
01:18:07 <kuribas> I find it like an order of magnitude easier to have the compiler simply point you to where the code breaks.
01:18:41 <Axman6> somewhat ironically, strong static types let you be much more YOLO about writing code, "I'll just change this type, I wonder what breaks lol"
01:19:15 <kuribas> Axman6: indeed, this talk about types restricting you, dynmamic code is more natural, etc... I find it to be the opposite way.
01:19:41 <kuribas> types give you freedom, and code tends to be more reusable and easier to change.
01:21:13 <Axman6> merijn: what do you use to communicate between those concurrent systems btw?
01:21:49 <kuribas> actually, this "natural" coding never made any sense to me.
01:23:22 <Axman6> yeah it's not a thing, it's the name for "I oince didn't know a thing but have now forgotten that fact"
01:23:27 <Axman6> once*
01:24:59 <kuribas> it's true that dynamic is easier in the initial design phase, because you don't have to think how things fit together.
01:25:22 <kuribas> but only superficially because with types you can more easily make an iterative design.
01:26:52 <kuribas> in fact, design by types, where first create holes for functions that are trivial is really convenient.
01:27:06 <kuribas> there is no need to implement everything to see if it fits together.
01:27:39 <kuribas> just implement the complex parts, and leave the rest as holes, to fill in in the end.
01:29:27 <kuribas> also in the small level (functions), just write myFun = _ where helper1 = _  etc...
01:29:31 <kuribas> and fill in the holes
01:33:29 <merijn> Axman6: Eh, during my master's/research assistant job it was MPI based, during my internship it was mostly Infiniband using libibverb, for my GPU experiment orchestration I just use the cluster scheduler's executable to run processes and talk via stdin (since it just forwards stdin to the remote process)
01:34:34 <merijn> Axman6: And now I'm working on something that uses Trilinos (which is build on top of MPI), which is some C++ HPC template hell build by a bunch of the US national labs
01:35:43 <Axman6> I hope it better quality ocde than most of what I've seen come out of those sort of communities
01:35:44 <kuribas> merijn: you don't have a haskell program that can simplify that?
01:36:24 <merijn> kuribas: Somehow I don't think I'm going to replace a 20+ year old massive code base with Haskell overnight >.>
01:36:54 <merijn> There are comments in this thing that are older than I am (well, almost, anyway...)
01:38:41 <kuribas> are C++ templates so old already?
01:39:05 <merijn> kuribas: No, but some of this code is Fortran77
01:40:03 <kuribas> I heared fortran is faster than C
01:40:29 <merijn> Languages don't have a speed
01:40:40 <merijn> But Fortran is much easier for compilers to optimise, yes
01:40:54 <merijn> On account of having actual non-useless arrays
01:41:17 <kuribas> merijn: and no pointers?
01:41:30 <merijn> kuribas: I don't actually know Fortran well enough to say :p
01:41:30 <kuribas> pointer arithmetic is hard to optimize
01:41:41 <kuribas> because of the possibility of aliasing
01:41:52 <__monty__> I doubt it doesn't have pointers though.
01:42:50 <merijn> kuribas: Fortran has proper N dimensional arrays and since they're first class (i.e. don't decay to pointers like C) the compiler knows the bounds and whether there's any aliasing, which means that array based code in Fortran is much easier to vectorise and/or parallelise automatically
01:43:05 <__monty__> From a cursory inspection, seems like it *only* has pointers. No values.
01:55:52 <__monty__> Apparently it does have POINTER-based arrays but ALLOCATABLE arrays are preferred because they're deallocated when out of scope and contiguous in memory and indeed aliasing does not pose a problem.
02:00:11 <Rembane> __monty__: That sounds modern, when did ALLOCATABLE arrays show up in Fortran?
02:01:06 <merijn> Rembane: Fortran90, apparently
02:01:07 <Taneb> Rembane: 1991 according to Wikipedia
02:02:17 <Rembane> merijn, Taneb: Nice! 
02:03:44 <__monty__> I love fortran's array "slicing" (because I only know the python terminology).
02:03:47 <Saulzar> Axman6, I'm looking to switch all my JSON to CBOR, does it compress all the labels? My python code which interfaces with the Haskell takes way too long to download/parse dict labels when things get big..
02:05:43 <sicklorkin> Saulzar: several GB or ...?
02:07:09 <sicklorkin> Saulzar: CBOR encoded files are ~500MB, no noticable slowdowns
02:07:10 <Saulzar> Yeah, quite a bit of it is wasteful and I could cut it down in other ways... but switching to something binary seems like a good step too
02:12:50 <kuribas> merijn: fortran doesn't look like a bad language for its purpose.  It's overly simplistic, but maybe that's good for scientists :-P
02:13:10 <merijn> Certainly more sensical than C, tbh
02:17:13 <__monty__> kuribas: I think the simplicity is mostly because it's the oldest high-level programming language. (I don't count assembly languages as high-level.)
02:17:29 <__monty__> It's kinda surprising how many things it got right.
02:17:34 <merijn> __monty__: Excuse me?
02:18:08 <Saulzar> sicklorkin, Seems promising
02:18:18 <merijn> Oh, rats, the first version of FORTRAN does indeed predate LISP
02:18:34 <__monty__> I don't know why everyone thinks lisp came first : p
02:18:42 <merijn> Only by 1 year, though
02:19:11 <merijn> __monty__: Presumably because the first FORTRAN standard with a year in it was FORTRAN 66 :p
02:19:15 <__monty__> But if we're really being honest, didn't practical fortran predate practical lisp by quite a few more years?
02:20:01 * Rembane throws in APL and hopes for the best.
02:20:19 <merijn> __monty__: What's your defintion of practical lisp?
02:20:48 <__monty__> Solving problems that are not strictly theoretical CS?
02:21:03 <merijn> Rembane: APL was 1966 according to wikipedia
02:21:31 <merijn> __monty__: Lisp was mostly AI, which I wouldn't really call "theoretical CS"
02:21:47 <__monty__> I would though.
02:22:20 <__monty__> My favorite "How old is lang X?" resource: https://www.levenez.com/lang/
02:23:19 <merijn> __monty__: I prefer https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
02:23:38 <__monty__> That *is* more amusing.
02:24:15 <__monty__> Btw, from what I'm finding fortran predates lisp by 3 or 4 years.
02:33:54 <dansho> what no plankalkul?
02:35:10 <__monty__> dansho: Is that a GP language though?
02:35:47 <Rembane> merijn: Sweet! 
02:38:20 <merijn> dansho: Oh, I actually reference that in my thesis :p
02:38:27 <merijn> dansho: But it wasn't published until way later
02:40:55 <__monty__> Apparently plankalkul never had an implementation? So if we count that we might as well count Lady Lovelace's work.
02:41:03 <__monty__> Which predates it by a century.
02:41:28 <__monty__> And if we count that, surely we can't ignore the jacquard loom.
02:42:04 <Taneb> Jacquard loom was very much not general purpose
02:42:24 <__monty__> Neither was plankalkul from what I understand though.
02:43:10 <Taneb> From what I can see about it it looks fairly general
02:43:23 <Taneb> And Ada Lovelace I believe was writing in essentially assembly
02:43:57 <__monty__> But plankalkul was never actually used, hence it couldn't've been a GP language.
02:44:09 <merijn> __monty__: Plankalkul was GP, but no implementation, no
02:44:17 <Taneb> The P stands for "purpose", not "what it was actually used for"
02:46:24 <__monty__> GP *programming* language. If nothing was ever programmed using it, then it's not a programming language : )
02:46:37 <merijn> I *strongl* disagree with that
02:50:29 <__monty__> And that's fine, but easily circumvented by the fact that in your terminology what I said comes down to "Fortran was the first *practical* high-level programming language."
02:50:59 <EvanR> the starship enterprise was not on a 5 year mission, was not even a starship. Because it was never really built?
02:51:30 <Taneb> EvanR: this is getting dangerously close to the one philosphy lecture I attended
02:52:01 <EvanR> it seems hard to justify even philosophically
02:52:40 <int-e> __monty__: and a year later Lisp came around and moved the "high-level" milestone? :)
02:52:57 <__monty__> I don't see the problem. The SSE is only a spaceship *in-universe*.
02:53:24 <dandart> whoa I just rejoined here and we're getting all -XExistentialQuantification
02:53:29 <__monty__> int-e: I contend that both fortran and C are *still* high-level languages.
02:53:41 <EvanR> this plankalkul thing seems to have been designed... in THIS universe
02:53:59 <merijn> int-e: __monty__ was arguing Lisp wasn't a practical high level language because it wasn't used for "things that aren't theoretical CS"
02:54:10 <int-e> oh?
02:54:20 <merijn> int-e: I object to a substantial number of assumptions/assertions in that
02:54:24 <__monty__> No, that's not what I said.
02:54:25 <int-e> I'm using emacs every day.
02:54:36 <__monty__> I said lisp didn't become practical until much later than fortran.
02:54:40 <int-e> (and that's a niche application of lisp)
02:54:49 <EvanR> high level was clearly always not very specific, kind of like "high speed CMOS"
02:55:30 <int-e> __monty__: I think a dichotomy (high, low) is not working when it comes to what amounts to expressiveness of programming languages.
02:55:48 <__monty__> EvanR: Would you call a blueprint for a building a building? If so I have stacks of "houses" lying around for you to buy at 2-300k a pop.
02:56:36 <EvanR> formal languages merely exist, all they are is the definition
02:57:53 <__monty__> Let's move to OT? Like I said, in your terminology I would've had to say "*practical* high-level language."
03:44:57 <kuribas> merijn: didn't they use lisp for expert systems?
03:52:39 <merijn> Sure, since people used it for nearly everything :p
04:02:25 <libertyprime> a more civilized age
05:43:32 <milivoj> they even had lisp machines
05:56:27 <__monty__> I think everyone's missing the point of "later." Fortran was written to be used on existing machines from day 1. Lisp machines took a couple years to materialize and lisp wasn't very practical in the first few years. I'm not saying that's a bad thing. Just that fortran's lead on lisp is more than just a couple years depending on how you look at it.
06:25:12 <vukonen> Do I understand correctly that in runState :: State s a -> s -> (s, a) the second argument is the initial state value, and the first is the state processor that gives the result tuple after running its computations on the initial state value?
06:27:39 <merijn> vukonen: Yes
07:52:05 <fog> im trying to understand where to use backpack in a project of designing a linear algebra "midware" layer to provide a variable backend to implement the necessary functionality
07:53:02 <fog> the algorithm this interface is supposed to support uses SVD as a key step - so for a simplified example, simple matrix diagonalisation using SVD could be considered
07:53:53 <fog> then i would have a class "Diagonalisable" which could be implemented by anything implementing a class "SVD" and some other basic matrix opperations. 
07:54:40 <fog> hmatrix implements SVD, and to demonstrait a variable backend, it would be possible to copy this implementaion in eg repa or ekmetts linear algebra package
07:55:54 <fog> the "signature" for use with backpack is then those opperations needed in the steps of this implementation. note, its also nice to be able to provide alternative implementations to SVD as it is a commonly approximated calculation with a wide range of algorithms to do so
07:57:07 <fog> the question is about this hierarchy of choices - about the "class" interface to various algorithms performing the SVD, and the various "signature" backends provided via backpack
07:58:12 <Cale> fog: I'm not sure I understand why/how backpack would get involved here? I would think type classes is enough.
07:58:21 <fog> when do we make the choice to use backpack signatures, and when to use classes? is the idea of using a class for SVD really something that should go in the signature?
07:59:19 <fog> Cale: the idea is to be able to "swap out the backend" where we would have eg. Repa or hmatrix representations of the matricies and all the linear lagebra opperations - which seems too large for a class
07:59:31 <Cale> It doesn't seem too large to me.
07:59:44 <Cale> There are associated types
08:00:01 <fog> so when do we use backpack?
08:00:17 <Cale> Me, this year? Never.
08:00:20 <fog> the example was supposed to be constructed to demonstrait this choice, so might have to be addapted to do so
08:00:29 <phaul> is there an official shade of haskell purple? what's the #xxxxxx?
08:01:14 <fog> Cale: your saying you dont understand why there would ever be need to use backpack instead of a class?
08:01:15 <Cale> Backpack is an interesting research project
08:01:30 <Cale> But it's not really something I'd consider putting into production use yet.
08:02:32 <fog> it was suggested as a tool for use in this way of providing a way to swap the libraries providing basic matrix opperations to a midware layer which could support more complex algorithms, such as diagonaisation via SVD in this example
08:03:19 <fog> from what your saying it seems like a class would be the better approach 
08:04:25 <aoeu256> Haskell noob here, I was wondering if Monads and MonadTransformers can do the same thing as Lisp macro walker editing a do/progn list
08:05:01 <Cale> fog: Yeah, I'd just always use type classes for that kind of abstraction unless there was some really good reason that they weren't working out
08:05:04 <fog> Cale: it wasnt so much a case of "putting it into production", more like constructing an example to demonstrait its utility, if your saying there is none, i will abandon the idea
08:05:51 <Cale> fog: If your goal is to find potential example use-cases of backpack, then sure, it might make sense :)
08:06:02 <fog> but then there is always the possibility that there is a use for backpack instead of classes that this example fails to illustrait 
08:07:21 <fog> the reason i cant really understand how to construct such an example use-case is mainly because i think that it was to do with the size of a module being larger than that of a class, but you seem to think differently, and i cant argue with that
08:08:34 <merijn> aoeu256: Hard to say, because I'm not sure what a Lisp macro walker does :p
08:08:39 <Cale> Personally, I haven't yet been entirely convinced that backpack and fancier module systems in general is a direction that we even need to go in.
08:08:53 <Cale> But it's something which is definitely an option in the design space
08:09:16 <merijn> Cale: If it means we can get a proper Text/ByteString supporting version of base then that alone is enough to justify backpack to me, tbh
08:09:24 <fog> it would be somewhat of an arbitrary choice to just use backpack whenever a class seemed to be covering an entire module.
08:09:33 <Cale> merijn: Hm?
08:09:51 <fog> what would stop eg. putting the SVD class in a module of its own just to justify using backpack instead of a class for this
08:10:05 <merijn> Cale: All the broken low level OS bindings like environment manipulation, files, etc. all taking strings
08:10:30 <fog> merijn: like the various duplications of the functions from Data.List ?
08:10:36 <fog> like, why isnt that a class?
08:10:46 <Cale> merijn: Well, that's true. Maybe some fraction of Text/ByteString should be split out and put into base itself.
08:10:58 <merijn> fog: Because classes without laws are a PITA to work with
08:11:05 <Cale> merijn: I'm not sure I see how backpack helps with it though.
08:11:23 <Cale> You're just saying that base would become a function of a choice of ByteString/Text?
08:11:49 <merijn> Cale: That was a plan some people had, yes
08:12:50 <fog> merijn: but then that would mean you wouldnt support the idea of an SVD class? or is the unit test a sufficient "law"?
08:12:58 <Cale> Of course, module interfaces without laws are the same thing as classes without laws.
08:13:07 <merijn> fog: I have no idea what SVD even stands for
08:13:15 <Cale> SVD seems like it would have enough properties
08:13:29 <Cale> singular value decomposition
08:13:41 <aoeu256> merijin: a code walker is like umm eval or a parser or a compiler or a type checker or a refactoring tool;  something that walks both the heads and tails of lists.  im thinking monads are linear DSLs so sequence and traverse could convert one linear DSL to another (for example, adding a printf in between every statement or changing what assignment does).   
08:13:43 <fog> yeah, it has to do something very specific and there is no ambiguity about what it should do...
08:13:48 <merijn> Cale: Modules need to at least be explicitly opted into and type inference is simple in their presence
08:14:01 <merijn> Making everything typeclass polymorphic leads to hell-ish type errors
08:14:40 <Cale> merijn: I suppose I could believe that, but I haven't seen backpack's errors yet ;)
08:14:44 <merijn> aoeu256: You might be interested in the whole "free monad" and "tagless final" stuff :)
08:15:18 <merijn> Cale: I haven't either, but I have seen the errors from "too typeclassy code" and the result is I really don't like this overly typeclass polymorphic stuff
08:15:40 <Cale> aoeu256: You have to be very cautious about what it means to "add printf in between every statement"
08:15:55 <Cale> aoeu256: Because remember that return v >>= f is supposed to be equal to f v
08:17:06 <Cale> aoeu256: But apart from that, you can basically define a monad by saying that certain operations must exist, and you can change the implementations of those operations freely.
08:17:38 <Cale> (merijn also pointed you in that direction with the term "free monad")
08:18:03 <aoeu256> cale: haha types make my brain hurt i'll have to think for this for a while
08:18:35 <Cale> aoeu256: To get a handle on how you might start out, without going overboard with abstractions, let's consider the following datatype for terminal IO operations:
08:19:19 <Cale> data TermIO a = Done a | PutLine String (TermIO a) | GetLine (String -> TermIO a)
08:19:35 <Cale> i.e. any TermIO action having a result of type a is
08:19:44 <Cale> either Done, with some value of type a
08:19:59 <aoeu256> cale: also can you pattern match on IO like you can with list (:)
08:20:00 <Cale> or it begins by printing a string to the terminal, followed by some other TermIO a action
08:20:22 <merijn> aoeu256: No, but nothing is stopping you from defining something very similar to IO where you could do that
08:20:27 <Cale> or it begins by getting a line of text from the user, and determines which action to take based on a function of that line
08:20:35 <merijn> Anyway, gym time
08:20:37 <fog> merijn: so how would you approach the design of such a linear algebra midware layer, defined as that sufficient to implement diagonalisation via SVD, using various implementations of matrix and basic matrix functions - eg provided by repa or hmatrix 
08:21:11 <Cale> aoeu256: IO is abstract (and in fact, it's implemented internally via hackery, so sadly you can't pattern match to determine what an IO action will do ahead of time)
08:21:23 <fog> oh he ducked out, open question then
08:21:41 <aoeu256> anyway thanks merijin and cale, i think i know where to go next
08:22:43 <fog> Cale says; dont use backpack instead of classes, merijn says; dont use too many classes.... 
08:23:01 <Cale> fog: Well, a problem that you're going to have is that, for instance, Repa's types are likely different enough that it will be awkward to just abstract over them.
08:23:12 <Cale> But maybe not impossible
08:23:29 <fog> well specifically that is the exact challenge
08:23:32 <Cale> svd :: (Field t, Numeric t) => Array F DIM2 t -> (Array F DIM2 t, Array F DIM1 Double, Array F DIM2 t)
08:23:57 <Cale> http://hackage.haskell.org/package/repa-linear-algebra-0.3.0.0/docs/Numeric-LinearAlgebra-Repa.html#g:18
08:24:41 <fog> svd :: (Matrix m,MyMidwareMatrixExtras m) => m -> (m,m,m)
08:25:13 <fog> oh it changes the dimensions in the middle
08:26:03 <fog> ah, thats because its representing the diagonal matrix as just a vector
08:26:05 <Cale> actually, that does look close enough, given that this library was specifically written to be compatible with hmatrix
08:26:07 <Cale> svd :: Field t => Matrix t -> (Matrix t, Vector Double, Matrix t)
08:26:32 <Cale> So we could define something like
08:26:41 <Cale> class HMatrix where
08:26:44 <Cale> er
08:27:04 <Cale> hmm, how do I want to do this :)
08:27:08 <fog> yeah, just not sure without checking the implementation details all of the matrix opperations it uses
08:27:10 <Cale> class HMatrix k where
08:27:20 <Cale>   type Matrix k
08:27:25 <Cale>   type Vector k
08:27:55 <Cale>   svd :: (Field t, Numeric t) => Matrix k t -> (Matrix k t, Vector k t, Matrix k t)
08:27:59 <Cale> etc. etc.
08:28:42 <Cale> This would have to be tried to see if you end up with some issues with ambiguous types
08:28:43 <fog> well really it wants to take a list of dimensions as a parameter... eg an n by m matrix would be given [m,n], maybe with a fixed length list to give the rank of the "tensor"
08:29:41 <Cale> HMatrix doesn't put that kind of information at the type level
08:29:52 <fog> so then you would have instances for this Matrix class written in terms of the various backends, and then what, use type annotations to specify which version to use? 
08:30:11 <Cale> (apart from having Matrix and Vector types which reflect the rank)
08:30:22 <fog> isnt the idea that backpack would partion these into different modules so that the ambiguous instances would be respolved via qualified import
08:31:45 <Cale> Well, ambiguity is something that you can solve by fiddling with the type class, once you understand where it might come from
08:31:57 <Cale> I think with svd, things look fine enough
08:32:15 <fog> yeah but, you would have to supply a particular instance of Matrix
08:32:41 <Cale> another thing to consider is whether t there should be a parameter to the Matrix type, or just baked into the choice of instance
08:32:47 <Cale> Perhaps the latter would be better
08:32:53 <fog> so with backpack instead of having that as a constraint, it would literally just be Repa.Matrix
08:33:12 <Cale> Well, you get to write polymorphic functions, which is nice.
08:33:16 <fog> import qulified Data.LinearAlgebra.Repa as Repa
08:33:54 <Cale> But I'm also not especially convinced that this even needs to be abstracted over
08:34:38 <Cale> Usually you're choosing one linear algebra library or another, and the fact that they have similar-looking interfaces makes it not terribly hard to remake that decision..
08:34:44 <fog> i dont want to force the user to use a particular backend. which matrix library then use should be their choice, thats the whole point behind designing such a midware layer
08:34:56 <Cale> ah, I see
08:35:05 <Cale> Well, what stuff are you writing?
08:35:15 <Cale> Do you *just* need a choice of svd?
08:35:21 <fog> atm, just a diagonalisation via SVD for an example
08:35:36 <Cale> Simply taking a function parameter might be a better option than such a heavyweight answer
08:35:56 <Cale> (or a few function parameters, based on whatever operations you need)
08:36:02 <fog> but thats just because the SVD is a part of a more complex algorithm, which itself is part of a family called "sparse greedy convex optimisation routines" or something 
08:36:24 <fog> so basically, a midware layer for the implementation of these kinds of algorithms is the ultimate aim
08:36:41 <Cale> I'd start by implementing the algorithms
08:36:52 <Cale> then figure out what they need to assume about vectors/matrices/etc
08:36:57 <Cale> and then design the interface
08:37:31 <Cale> Maybe it's a typeclass, maybe it's a record of operations parametrised over matrix and vector types
08:37:32 <dmj`> It'd be hard to beat lapack, or array fire, and would probably take years
08:37:48 <fog> there are many, the first step is certainly the implementation of the midware layer, as its maintenance could be my job, whereas the implementation of particular algorithms would be part of various research projects
08:38:31 <Cale> fog: The problem is, you never really begin the job of abstracting in earnest until you have the things you're trying to abstract over
08:38:46 <fog> dmj` but there are people using matlab and python for this in a research setting where performance is not the critical issue, but instead is a user frindly interface, which it is the goal to provide via haskell
08:38:52 <Cale> You can try, but everything you do will almost always be junk
08:39:27 <fog> right, so after SVD, the CGIHT algorithm, which seems to be state of the art, would be a natural step
08:39:52 <fog> there is another group that have claimed to outperform it but by the looks of it they have made a mistake, and i would like to benchmark that
08:40:18 <dmj`> it's going to be very hard to convince someone who's used numpy / scipy suite of tools to use Haskell, and even if you do, hmatrix isn't that safe of an interface itself (lots of runtime exceptions). The plotting also sucks compared to matplotlib. 
08:41:01 <dmj`> like, do they care about PLT at all? probably not.
08:41:28 <dmj`> probably just care about the algorithm they're implementing from the journal of machine learning research
08:41:53 <fog> i think the other version was CGHTP, and i suspect the adjustment they made to the algorithm will cause it to "get stuck in a particular support" and waste computational time there
08:42:30 <dmj`> fog: I'm almost done with arrayfire bindings, they have decent plotting, and you can specify dimensions as an array, has svd, does everything on the gpu
08:42:43 <fog> dmj` right, but for my own use to do this benchmark i want to use haskell, and so seek to make a bare-bones midware interface to abstract away the complexities of any particular backend
08:43:46 <fog> wow dmj` that is really nice. 
08:43:51 <fog> good work!
08:45:05 <fog> yeah, i hadnt thought about a similar midware for plotting but i guess its an idea. was just getting stressed about the choice of backend and the development of a way to abstract over this. thought backpack seemed like a good option, was just discussing it compared with classes for the task
08:45:55 <dmj`> fog: soon we'll have that GPU goodness. Everything is a call out to C, doesn't rely on the Haskell heap for anything, all allocation, manipulation of arrays and even disk I/O / plotting is done with C. Haskell is just a syntactic layer over it. The only time the haskell heap gets involved is when you pull something into a storable vector.
08:46:10 <dmj`> which you don't have to do
08:46:47 <fog> thats the exact good thing about the midware concept, it can then serve as a way to choose between these FFI backends.
08:48:17 <dmj`> fog: will users be able to change between backends dynamically? if you can keep all the data on the C heap then I'd say go for it, but it sounds like a ton of work, and potentially a drain on performance if you start copying things into haskell.
08:48:44 <dmj`> even something as basic as file I/O isn't easy for data scientists
08:48:45 <fog> do i import Data.LinearAlgebra.DMJFire.GPU or .Repa or what... it shouldnt really matter... maybe there is some configuration to do with multiple cores or cloud server configuration that a particular option would use to give better performance, but that an undergrad might want to avoid and just stick with a slightly longer running time
08:48:57 <dmj`> in haskell that is
08:49:24 <dmj`> DMJFire, loool
08:50:03 <dmj`> I'd say just stick with hmatrix for now
08:50:04 <fog> no literally it would be the exact same interface (if using backpack instead of classes, else its just different instances) just with a different qualified import. converting between different implementation would be like using pack and unpack to change between different bytestrings
08:50:23 <dmj`> also think the type level api's for ML libs are overrated
08:51:01 <fog> dmj`. no hmatrix is definatly not a viable option. the whole idea is to implement a midware layer. there would obviously be a hmatrix backend option - but actually using their symbol for matrix multiplaction for example would not be the idea
08:51:44 <fog> its to make a common syntax interface to multiple backends
08:52:11 <fog> as a class would, but here the idea is to consider the viability of backpack for the task
08:53:34 <dmj`> fog: what do you stand to gain abstracting over different libraries like this? Also, isn't each one is too specific and different. String APIs are one thing, since the operations are all nearly identical, but hmatrix to another hmatrix-like lib are very different no
08:53:52 <fog> for instance, i can just use class functions eg. svd of the SVD class, without actually having implemented it. similarly, i want to be able to work with matricies without having to learn the different idioms and syntaxes of the various backends 
08:54:00 <dmj`> and munging the data between the backends would be crazy
08:54:26 <fog> i dont want to get used to one and then have the difficulty later of learning a different library. it would be easier at that point just to port this additional backend
08:54:29 <dmj`> fog: ok I guess if you can extract enough common functionality it could be a good idea
08:55:03 <fog> especially since the applications built on this midware layer are likely to only use a subset of the functions provided by any backend
08:55:34 <dmj`> yea, that could definitely work. 
08:56:14 <dmj`> maybe a typeclass then
08:56:19 <fog> yeah its almost like a standard of the smallest intersection of functionality defined by a limited use case 
08:56:50 <fog> well ok, so convinced now of the utility of the concept of a midware layer, we can question the use of classes to provide this
08:58:59 <fog> the basic issues seem to be 1. the number of functions (a large module, eg Data.List which we see duplicated all about the place) . 2. the ambiguity that is the various instances of the class, where instead with backpack we have various modules implementing a Signature - and partitioned neatly via qualified import. 3. the existences of classes in t
08:59:00 <fog> he modules we wish to abstract over, where these cannot appear in classes as the abstraction...
08:59:14 <fog> the third point i dont understand very well... might could do with an example
09:02:15 <Cale> Yeah, don't start by trying to figure out what stuff about matrices you want to abstract in a vacuum -- take concrete examples of algorithms that you want to be able to generalise to use these different libraries, and start by just turning them into functions of the algorithms that they are using.
09:02:41 <fog> yeah, the example was diagonalisation via SVD
09:02:57 <fog> thats literally the least complicated algorithm
09:03:21 <Cale> So that might just be a function of type (m -> (m,v,m)) -> m -> Maybe v
09:03:43 <fog> right, you can simply take the function as an argument
09:04:08 <fog> where then there is a discussion about this vs. placing this function as provided by a class in a constraint
09:04:23 <fog> HasSVD m => m -> Maybe v
09:04:56 <Cale> Yeah, you'll have a much better idea of how you want to break things into classes and stuff once you have a good bunch of examples of this
09:05:00 <fog> the idea being you dont want to have to take all the matrix opperations as arguments
09:05:37 <fog> unless then you have a record which is created by providing all these
09:05:56 <Cale> and maybe it's actually better just to have them as function parameters in some cases, because there are different algorithms for computing an svd
09:06:03 <fog> starting to get a confusing number of options
09:06:04 <Cale> even on the same matrix type
09:06:24 <Cale> Yeah, the record approach might be better simply because there are many such options
09:06:32 <fog> i think basically now we have backpack vs. classes vs. records 
09:06:37 <Cale> So you can pass a configuration for which algorithms to use, rather than needing to newtype things
09:08:10 <sicklorkin> fwiw fog this was my approach creating a middle layer betwen different trading activities and it has worked well.. 
09:08:14 <fog> right, a newtype for a matrix that would svd via a particular algo is no good
09:08:57 <fog> then you would end up with many such different things like svd that have several implementation choices and the number of newtypes would grow combinatorically
09:10:50 <Cale> Personally, I would try to stick with good ol' functions for as long as possible until it became painful, and use the precise form of that pain to decide what to do next.
09:11:36 <fog> so then its just a field of the record? eg data MyMatrixMidware m = LinAlg {muliplication :: m -> m -> m , svd :: m->(m,m,m) .... }
09:12:03 <Cale> fog: If you're taking the record approach, yeah.
09:12:36 <fog> but the functions as arguments approach is ridiculous if it was eg, taking all the functions of Data.List
09:13:00 <fog> basically now we are talking about putting whole modules as records
09:13:24 <fog> then how do we get associated types? as parameters like `m' above
09:13:47 <fog> certainly cant put classes in records...
09:14:11 <fog> guess then each class of a module you were "recordisng" would have to be recordised first...
09:14:22 <fog> seems horrible actually
09:15:28 <dmj`> would you need associated types, or could you get away with a multi parameter typeclass
09:15:34 <fog> i mean, the hope is that backpack actually provides a really nice solution to this
09:15:48 <Cale> fog: We're talking about putting lots of function parameters in -- that will likely get painful quickly, so we're probably going to start wanting to define record types, but we'll be better informed about what those records should be
09:16:17 <fog> dmj` how do you mean?
09:16:25 <Cale> fog: and then! If we find that we're passing the same records as arguments essentially all of the time (based on the type), that's what classes are for.
09:16:53 <Cale> I don't think backpack fundamentally changes what we can do here, or what the right decisions would be
09:16:56 <fog> but isnt that what qualified imports are for?
09:17:47 <fog> and then it saves having to try to translate top level haskell syntax into what it would be like if you tried to have whole modules as classes or records
09:17:50 <dmj`> fog: I agree with Cale on incrementally adding type level complexity. class instances desugar into records anyways, you can abstract out the type of the array from the underlying pkg
09:17:53 <Cale> You still need to write your signature, and in order to know what that signature *is*, you need enough experience with what operations are the right ones to abstract over
09:18:33 <fog> im not disagreeing about classes vs. records, just wondering about where backpack fits in
09:18:49 <Cale> fog: I largely wonder that as well, lol
09:19:07 <Cale> (not to be overly critical of Edward's work!)
09:20:04 <Cale> But yeah, it's not entirely clear why we shouldn't just solve the same problems with type classes. There may be some pragmatic reason involving the quality of generated code, but it shouldn't be a fundamental one.
09:20:04 <fog> it does seem unnatural to try to put the whole of a module into a record though, especially because of the problems of "recordising classes" and having to supply parameters instead of top level type / data declarations
09:20:24 <Cale> Right, you almost certainly don't want to do that
09:20:34 <fog> so then you would use backpack
09:20:39 <Cale> You want to figure out what the correct record types to define are based on experience
09:20:48 <Cale> They should not be especially large.
09:20:58 <fog> where then the requisite seems to be assocaited datatypes and classes
09:21:08 <Cale> and maybe in some cases they will even be simply newtypes
09:21:34 <Cale> But the idea is really just to group things together when they're often needed together
09:21:36 <fog> well if we are taking Data.List as an example, it seems more backpackable than recordisable
09:21:47 <fog> and that module doesnt even have many classes and newtypes
09:21:48 <Cale> I don't think Data.List should be abstracted over as a whole
09:22:37 <fog> just meaning about the numerous things implementing eg. `reverse' that need to be imported qualified to avoid clashes
09:22:53 <fog> seems like a classic use case for such a "midware layer"
09:23:10 <fog> you dont want to have to write a reverse class...
09:24:01 <fog> so all these commonly implemented things common to Data.List can be gathered together in a midware layer, where then it seems like backpack is a good option because it avoids the complications we have discussed
09:25:04 <Cale> fog: I don't particularly agree that it makes sense to just throw all that shit together and call that an abstraction though.
09:25:38 <fog> right, thats why the "greedy spare optimisation" midware layer was devised as an example
09:25:42 <fog> sparse*
09:26:14 <fog> because its the utility functions common to this family of algorithms that forms the specification for what is incorperated in the midware layer
09:26:40 <fog> ie. its more than just the combination of backend functionalities, it is specified in part by the frontend use cases aswell
09:27:13 <Cale> fog: Yeah, so just implement a bunch of optimisation functions, and start by just having them take parameters, honestly, that'll make everything clear.
09:27:30 <Cale> and that may even be the best possible form of the library
09:27:35 <fog> then even if most matrix packages defined some common opperation - but that was never used in spase optimisation, then it wouldnt appear as part of that midware layer
09:28:17 <Cale> Now, for stuff like matrix multiplication, or applying a matrix to a vector, you might want something a little more automatic than separate function parameters, but even that kind of stuff might want to be swapped out in general
09:28:18 <fog> Cale: i thought it was viable to just consider a simple example, eg diagonalisation via SVD.
09:28:50 <Cale> You really want a whole slew of examples, so that you can get a sense of what dependencies show up together consistently
09:28:55 <fog> instead of trying to actually write algorithms taking records, that it was better to try and get in the practice of writing midware using the best appraoch, instead of the clumsiest
09:29:58 <fog> Cale - oh right sure, to get an idea of the specification for a particular midware layer to depoly. but the task atm is to just write one very short midware layer, with no particular demand on its specification
09:30:14 <Cale> Function parameters are *often* the best approach. The cases where they're not is where you're always passing the same arguments, or where collections of arguments must always go together in a particular way (e.g. if you're using this particular version of algorithm A, it's necessary to use such and such implementation of algorithm B)
09:30:19 <fog> just to develop best practice in writing midware, basically to see if backpack is a good idea for this
09:31:28 <fog> yeah, so taking matlab as an example, they have "toolbox plugins". but basically the matrix multiplication is out of the box
09:32:08 <fog> you want to construct a matlab like environment one time, and then work within it
09:32:29 <bifunc2> With Stack, how can the test suite of library2 make use of functions within the test suite of library1?
09:32:29 <bifunc2> I don't want to put the library1 test functions into the main library1 itself, because that would mean all normal users of library1 would have to build unnecessary stuff with it like QuickCheck etc.
09:32:32 <fog> so you pass in the implementaion of matrix multiplication, and the basic algos offered by the package, such as into a record
09:32:45 <Cale> Yeah, for basic stuff like matrix multiplication, I can imagine it becomes annoying to take that as a parameter everywhere
09:32:57 <Cale> So you might almost immediately want a class for that.
09:33:07 <fog> typically yes..
09:33:55 <fog> ok, at this point it seems like an implementation of the SVD example using a class and backpack is needed, and since thats how the conversation started (with a description of such) then it seems like we are done
09:35:46 <fog> hmm, actually the most advanced point we reached was about how it was classes that backpack would support best compared to records or classes - cf. recordisation of a class. and the example we have didnt use classes
09:35:54 <fog> im still confused about that idea
09:41:07 <Cale> fog: Basically, backpack gives you the ability to pass a bunch of function parameters to everything in a module at once.
09:41:50 <Cale> fog: If you think about it that way, I think it gives a reasonable idea of what can be done.
09:42:23 <fog> can you explain that?
09:43:14 <Cale> fog: Well, all the stuff in your module is abstracted over those things, wherever they get used, and another module of code is used to supply those arguments.
09:43:25 <fog> oh, and as a class in the linear algebra setting we could have the metric - a notion of distance between arbitrary instances
09:43:56 <fog> and two candidate backends could eg. call this class something different
09:44:49 <fog> hmm, your explanation is still a bit abstract, how does that fit with the example?
09:47:31 <infinisil> bifunc2: You can use an internal library: https://www.haskell.org/cabal/users-guide/developing-packages.html#sublibs
09:51:14 <fog> Cale: so passing functions eg a particular implementation of svd as an argument seems fine, and embeding these functions into a record or class makes sense, but then what about classes? is that like passing functions which return a constraint?
09:52:14 <Cale> Type class constraints are effectively function parameters for records constructed from the type class instances.
09:52:36 <Cale> The main difference is that there's at most one instance per type
09:52:54 <fog> actually wait, that whole idea is broken because you can only write instances at top level
09:53:54 <fog> if passing functions as arguments or as being visible via a constraint is just a way to "get them in scope" then this idea doesnt work for classes, which we want to be in scope when we are writing instance, which we cant do inside functions
09:54:11 <Cale> You also can't control very precisely whether instances get exported, so type classes are used when there is a globally unique convention about how those operations are implemented
09:54:45 <Athas> Is there a type like IntMap, but where the keys are not necessarily Int themselves, but simply contain an Int?
09:54:47 <Cale> Newtyping is a thing you can do, though.
09:54:52 <Athas> (So really, an IntMap wrapper.  I could write it myself.)
09:55:07 <wroathe> I could've sworn that cabal v2-repl used to work with import/:module declarations in a .ghci file in the same directory, but it doesn't seem to be loading the default modules I request. Is there a new way to do this?
09:56:26 <Cale> Athas: kinda-sorta similar to HashMap
09:56:33 <fog> so it seems like there is a use case justifying backpack then
09:56:53 <wroathe> Oh, nvm. It doesn't show up on ":show modules"
09:56:57 <wroathe> But it does show up on imports
09:57:00 <Cale> fog: Which case are you referring to?
09:57:09 <fog> in order to abstract over the same class named differently in two different backends
09:57:37 <fog> to provide a "common" name, being the purpose of the midware layer
09:57:40 <Athas> Cale: yes, except that I think HashMap makes assumptions (like hashes being widely distributed) that IntMap does not.
09:57:45 <Cale> fog: You could abstract over that if you really wanted to...
09:58:17 <fog> yes, but only using backpack, not using classes, so classes then are not the right design choice for writing midware
09:58:17 <Cale> fog: There's ConstraintKinds, which gives you the ability to abstract over a type class constraint
09:58:34 <Cale> You can have constraint variables
09:58:43 <Cale> If you *really* need them
09:58:47 <Cale> Usually it doesn't come to that
09:59:02 <Cale> I'd be quite surprised
09:59:07 <fog> eh? like having two classes combined as one by making a class which provides dictionaries for them
09:59:09 <fog> urgh
09:59:37 <Cale> I mean like having your type class have a type family that specifies some constraints
09:59:38 <fog> ok, i suppose classes might be enough then
10:00:14 <Cale> Or just be directly parameterised over a choice of constraint
10:00:22 <fog> i dont know which to try and write first for comparison
10:00:31 <fog> both use techniques i have no experience with
10:01:07 <fog> either backpack or this use of ConstraintKinds to make classes have classes inside (which i was sure was impossible)
10:01:32 <Cale> Do you have an example of where you need this?
10:01:47 <Cale> I can show you how to do it, but I somewhat doubt you need it
10:02:10 <Cale> It's usually enough just to specify which specific functions and types you're abstracting over
10:02:17 <fog> hmm, the svd example wasnt enough and it doesnt use the distance metric class...
10:02:18 <Cale> and abstracting over constraints is a little weird
10:02:42 <Cale> (I've run into it though, but in a very very abstract case)
10:03:56 <Cale> It was in the context of abstracting over a thing we often need to do with GADTs, where, if we pattern match on each of the constructors of (f a), we'll discover that we always satisfy the constraint (c a)
10:04:11 <Cale> So that we can write a class like
10:04:19 <Cale> class Has c f where
10:04:28 <fog> well, ok, i guess two backends which could provide matrix multiplication, an svd implementation and an abstract class of seperation with instances for vectors and matricies. just length 3 for ease. and the use case is an algo which gets the diagonal from the svd of an input matrix, and computes the distance between the diagonal and the truncated ve
10:04:29 <fog> rsion of it with the 3rd entry set to 0
10:04:31 <Cale>   type ConstraintsFor f c
10:05:00 <Cale>   has :: (ConstraintsFor f c) => f a -> (c a => r) -> r
10:05:35 <fog> whats that some kind of a way of getting "the constraints that some type implements" ?
10:05:55 <Cale> So, for example, maybe we have some GADT like
10:06:04 <wroathe> Weird, cabal v2-repl seems to be loading my package's modules, but only importing the first module
10:06:04 <Cale> data APIRequest t where
10:06:54 <Cale>   GetEmployee :: EmployeeId -> APIRequest Employee
10:07:03 <Cale> etc. etc. various requests
10:07:05 <fog> oh, like where you have constraints on the fields of a GADT but not the whole thing
10:07:16 <Cale> and we want to know that it's always possible to convert the result of a request to JSON
10:07:32 <Cale> This gives us a way to say  Has ToJSON APIRequest
10:07:42 <Cale> which means that, given some value of type APIRequest t
10:07:47 <gentauro> dminuoso: <3 Edwards short explanation of INLINE/INLINABEL :) https://old.reddit.com/r/haskell/comments/cjkc3l/should_i_be_inlining_instance_implementations/
10:07:53 <Cale> we'll be able to discover an instance for ToJSON t
10:07:58 <gentauro> very relevant after yesterdays question :D
10:08:20 <Cale> So, the instance might look like:
10:08:35 <Cale> instance Has c APIRequest where
10:08:49 <Cale>   type ConstraintsFor f c = (c Employee, ...)
10:09:00 <Cale>   has k r = case k of
10:09:14 <Cale>     GetEmployee {} -> r
10:09:20 <Cale>     ...
10:09:37 <Cale> (It'll always just pattern match on all the constructors and produce the result)
10:10:46 <wroathe> Anyone know how to get cabal v2-repl to import all the loaded modules?
10:11:15 <Cale> wroathe: Has any GHCi ever done that?
10:11:24 <wroathe> https://github.com/haskell/cabal/issues/5374
10:11:37 <wroathe> Yeah, apparently that's default ghci behavior
10:11:39 <fog> im not sure how thats supposed to help with the midware implementation
10:11:54 <Cale> wroathe: The stuff that's in scope is whatever's in the module you loaded
10:11:54 <wroathe> My last repository was a stack project, and they seem to be doing something to make it work with stack repl
10:12:04 <Cale> wroathe: hmmm
10:12:16 <wroathe> This is just a regular cabal project
10:12:38 <wroathe> It's _loading_ modules just fine, but it only _imports_ the first, which seems to be default ghci behavior
10:12:56 <Cale> Well, there's one particular module which is loaded at any time
10:13:03 <Cale> Like, if you :l Foo
10:13:16 <sclv> iirc stack does something weird like actually sort of glue everything together 
10:13:29 <sclv> which occasionally has weird consequences
10:13:36 <wroathe> :show modules shows all 4 of my project's modules
10:13:46 <wroathe> :show imports only shows the first module imported, Cale
10:13:56 <sclv> yeah, you can get more just by going :mod +SomeOtherModule
10:14:19 <wroathe> sclv: That doesn't work with a .ghci file
10:14:37 <Cale> huh?
10:14:51 <Cale> You could certainly put that command into a .ghci file
10:16:27 <wroathe> The modules havent been interpreted yet by the time .ghci tries to import the module, so it chokes
10:16:58 <Cale> what message does it print?
10:17:26 <Cale> Putting stuff in your .ghci should be the same as typing those commands immediately after ghci loads, as far as I'm aware
10:18:20 <wroathe> Could not find module "foo", it is not a module in the current program or any known package'
10:18:32 <wroathe> Followed almost immediately by statements that it's compiling foo
10:20:54 <wroathe> Ah, just from a quick glance at Stack's source it seems that they compile a temporary main script that contains all of the imports and then they pass that to GHCI
10:21:22 <wroathe> They write it to the dist directory and then compile it, I should say
10:25:36 <sclv> note that this also brings in multiple components at once in stack iirc!
10:25:56 <sclv> which is sometimes nice, but also can lead to very unexpected behavior
10:28:18 <fendor> is there a text based alternative to the process package?
10:30:48 <bifunc2> infinisil but they say  "Internal libraries are only visible internally in the package (so they can only be added to the build-depends of same-package libraries, executables, test suites, etc.)"
10:31:06 <bifunc2> infinisil so it can't be used from the test suites of other libs can they?
10:31:49 <infinisil> Ah yeah
10:32:28 <infinisil> Another possibility might be to just share the hs file with the functions in it
10:32:41 <infinisil> Or just create a third library that has the helper functions
10:47:30 <gabbiel> how do I into serialization with the cereal package? I can't install Aeson because I don't have enough ram, so I have to use cereal. but I don't know how it's supposed to work and there's no tutorials
10:48:05 * Clint squints.
10:48:13 <Clint> gabbiel: do you want it to parse/emit json?
10:49:45 <gabbiel> i want to store data in files, I don't care for the method
10:49:55 <gabbiel> clint: store and retrieve
10:50:18 <Clint> gabbiel: so then you'll want to create/derive instances for serializing your data types
10:51:10 <Clint> though if you don't have a specific need for cereal you might be better off using binary
10:51:12 <gabbiel> something like that, yes
10:51:22 <boj> gabbiel: maybe look into cborg, it's built on CBOR and uses `serialize` the library - all written by Well Typed
10:51:38 <boj> has decent documentation
10:51:44 <monochrom> Yeah actually binary comes with GHC so you need no extra RAM or disk space.
10:51:47 <sclv> fendor: what do you mean
10:51:54 <sclv> oh Text vs String you mean?
10:52:07 <fendor> sclv, yeah, I want the stdout as a text instead of a String
10:52:30 <Cale> gabbiel: How much ram do you have? Not being able to install Aeson seems interesting.
10:52:52 <gabbiel> cbor or cborg?
10:52:52 <ysangkok> hmmm nix has binary package archives right? so are all haskell packages on nix available prebuilt?
10:53:01 <sclv> fendor: the process api lets you dig in to actually grab the handles
10:53:05 <sclv> so you can process them as you'd like
10:53:23 <gabbiel> cale: i have 1.5gig ram
10:53:47 <sclv> `binary` is almost certainly the easiest since its builtin
10:53:56 <Cale> ysangkok: For some value of "all" -- there is a curated buildable set in nixpkgs which will have been cached
10:53:59 <fendor> sclv, less comfortable than using an api
10:54:05 <sclv> cereal is very close to binary -- there's just a few design decisions separating them iirc
10:54:18 <Cale> ysangkok: You can set up your own binary caches as well
10:54:18 <sclv> fendor: sure, but you can wrap that stuff in an api yrself
10:54:26 <sclv> i do agree it would be nice if someone already had tho!
10:54:30 <sclv> i just don't know of it
10:54:42 <sclv> i find all the process apis tedious and irritating
10:55:06 <sclv> there's lots of knobs to twiddle and usually the standard functions aren't what i want but i also don't want 90% of the functionality of the complicated ones
10:55:06 <ysangkok> Cale: do you know where i can find the list?
10:55:11 <Cale> gabbiel: Ah, that does sound pretty restrictive.
10:55:12 <sclv> but each time its a different 90%
10:55:40 <fendor> sclv, yeah, maybe there is some room for improvements
10:55:51 <sclv> gabbiel: so with binary (or cereal) you can autoderive your instances. then just call decode or encode to go to/from bytestrings
10:56:12 <sclv> generics make it eaaasy
10:56:14 <ysangkok> https://cachix.org looks interesting since they provide 10GB storage for free. this should be enough for quite some haskell environment
10:56:18 <gabbiel> cborg looks as cryptic as cereal. i wish there were tutorials
10:57:22 <sclv> `data MyData (...) deriving Generic`. `instance SerializeMyData`
10:57:39 <gabbiel> i guess ill wait till they cover bytestrings in the book, ive never even heard of that
10:58:00 <sclv> gabbiel: if you're _just_ just starting and just want something to play with
10:58:06 <sclv> then just use Show and Read!
10:58:21 <sclv> `data MyData (..) deriving (Show, Read)`
10:58:23 <gabbiel> show is fine, but read is the problem
10:58:30 <sclv> why is read a problem
10:58:39 <gabbiel> i thought I could just implement read, but nope, it something like readSpec
10:58:46 <sclv> you don't need to implement it
10:58:47 <Cale> ysangkok: It's sort of implicitly defined by this code here: https://github.com/NixOS/nixpkgs/tree/master/pkgs/development/haskell-modules
10:58:49 <sclv> autoderive show and read
10:59:15 <Cale> ysangkok: See configuration-common.nix for a bunch of changes that get applied
10:59:30 <Cale> https://raw.githubusercontent.com/NixOS/nixpkgs/master/pkgs/development/haskell-modules/hackage-packages.nix is the starting point
10:59:31 <sclv> basically all serialization libs in Haskell (including the builtin show read stuff) will write the code for you
10:59:44 <Cale> (it gets generated from hackage)
11:00:06 <sclv> btw anyone have much experience playing around with aws lambda haskell stuff?
11:00:08 <Cale> You'll notice that a good number of the packages have "broken = true", and those won't have been built.
11:00:26 <gabbiel> I hope deriving is just enough
11:00:40 <sclv> if you derive read, make sure to also derive show
11:00:46 <sclv> since the two generated instances will always match
11:00:57 <sclv> but if you do something custom on one side, it won't typically match the other
11:04:26 <gabbiel> i guess Read and Show are good enough for now
11:04:28 <gabbiel> thanks guys
11:05:32 <saml> no problem
11:23:24 <sicklorkin> I have a bunch of types (>100) and I'm using Generics to derive JSON, I'm wondering does anyone know which is faster, in terms of compliation time, Generics or TH (derivingJSON)
11:31:44 <fog> trying to set up two backends for testing the linear algebra midware being developed. hmatrix needs c libraries which are not installed, and repa-linear-algebra has constraints on the version of base
11:32:16 <fog> these are the only 2 svd implementations i have managed to find so far, and neither of them builds using cabal install
11:32:52 <fog> i have located this document detailing how to implement SVD, and it is much more complicated than i first thought;
11:32:53 <fog> https://www.cs.utexas.edu/users/inderjit/public_papers/HLA_SVD.pdf
11:33:05 <sclv> sicklorkin: i would think generics are typically faster, since they don't involve an extra pass
11:33:26 <sclv> but both can be quite slow :-/
11:33:52 <sicklorkin> sclv: can you think of any OPTIONs to play around with to speed things up a bit? 
11:33:52 <sclv> fog: why don't you install the c libs?
11:34:53 <sclv> you can disable optimizations
11:35:02 <sclv> i.e. compile with -O0
11:35:07 <sclv> just for testing of coruse
11:35:17 <sicklorkin> sclv: yeah i'm already using -O0
11:35:29 <bifunc2> With Stack, how can the test suite of library2 make use of functions within the test suite of library1?
11:35:29 <bifunc2> I don't want to put the library1 test functions into the main library1 itself, because that would mean all normal users of library1 would have to build unnecessary stuff with it like QuickCheck etc.
11:35:30 <bifunc2> it was suggested i create a third library3 for the stuff used by library1 and library2 test suites. anyone have more elegant ideas?
11:35:34 <fog> several reasons. firstly, i want my example to build using cabal install, so people can easily use the demonstration. also, there are reasons haskell FFI might be a good idea, and other areas where pure haskell implementations might be desired
11:35:38 <sclv> this post also suggests ghc options: https://rybczak.net/2016/03/26/how-to-reduce-compilation-times-of-haskell-projects/
11:36:04 <sclv> fog: sure i mean your test suite can use the libs tho, and the main lib can not?
11:36:06 <sicklorkin> sclv: thanks
11:36:13 <sclv> then its still buildable vanilla
11:36:31 <fog> its nothing more than a test
11:37:16 <fog> anyway, at the moment there are exactly 0 backends that build vanilla
11:37:28 <sclv> https://hackage.haskell.org/package/linear or https://hackage.haskell.org/package/sparse-linear-algebra ?
11:37:48 <sclv> they're both very weak in terms of what they do compared to what you get from a full fledged binding
11:37:52 <fog> the first does not have svd?
11:37:57 <sclv> right
11:38:32 <fog> the second one seems ok, just building now
11:38:33 <fog> thanks
11:40:27 <fog> it builds ok, but it lists SVD as part of its "under development" functions...
11:40:36 <fog> ill check to see if it works
11:41:03 <fog> huh, if i can find it at all...
11:42:08 <fog> nope!
11:47:34 <fog> is there a way to set up a sandbox that can build http://hackage.haskell.org/package/repa-linear-algebra
11:48:09 <fog> it says;
11:48:10 <fog> rejecting: base-4.12.0.0/installed-4.1... (conflict: repa-linear-algebra
11:49:21 <fog> do i just set up a clean VM and install an old version of the haskell platform?
11:50:41 <phadej> repa-linear-algebra seems to advertise that it only works with GHC-7.10
11:51:15 <fog> seems like the way to go... thanks
11:51:45 <phadej> you may try `--allow-newer=repa-linear-algebra:base`
11:54:26 <fog> hmm then it makes similar complaints about the version of `vector'. --allow-newer seems to start it building
11:55:01 <fog> is there a way to include this in the cabal file for the project so it builds more easily?
11:56:10 <fog> brarg, it only goes and complains about no lapack
11:56:29 <fog> i cant believe nobody has ever implemented svd in pure haskell
11:56:39 <AWizzArd> Anyone here who logs to CloudWatch? If you do: do you use the agent or an API call to add logs?
11:57:50 <ystael> We use the agent, but that's because we use OpsWorks to manage our hosts so agent configuration happens almost for free.
11:59:10 <AWizzArd> ystael: so you log to HD and let the agent do the rest for you. Which lib do you use to actually write to disk? fast-logger?
11:59:14 <fog> man, these libraries are fortran!? this is some ancient legacy code for sure
11:59:59 <fog> recompiling those to pure haskell would be a pretty serious undertaking
12:00:07 <ystael> fog: linear algebra doesn't rot, and doing it well is hard
12:00:30 <fog> especially if the only reference is written in a language nobody could ever read...
12:01:51 <fog> its like a really brutal alternative to type safety. everything uses immutable libraries written before the dawn of time
12:01:56 <ystael> AWizzArd: Yes, fast-logger, though we didn't choose it directly, iirc that choice was made for us by Yesod
12:03:47 <fog> perhaps svd isnt the best example to use for this midware example, but thats what it was supposed to be used for in the long run... 
12:04:21 <fog> maybe if people like jle` that have built the clibs can work on it with me then it might be ok - but its less useful then for the wider audience 
12:10:24 <sicklorkin> AWizzArd: how much precision do you need in your timestamps?
12:12:10 <AWizzArd> sicklorkin: second resolution would be good
12:20:09 <gentauro> so the banquet for ICFP is cancelled :(
12:20:30 <gentauro> just got an e-mail earlier today from a "Mike Moshel"
12:33:14 <hyperisco> gentauro, I've heard of trolls doing that sort of thing, so maybe double check with another source
12:44:00 <gentauro> hyperisco: I mean, that person has access to my invoince for ICFP. I think it's "real"
12:44:13 <gentauro> all the other danes going, haven't recieved the e-mail though ...
12:44:42 * hyperisco shrugs
12:47:39 <gentauro> hyperisco: you going to ICFP?
12:48:01 <hyperisco> Nope. Don't know what it is.
12:48:20 <hyperisco> Guessing… International Conference for Functional Programming.
12:48:24 <sim590> What does hoogle does? Am I supposed to only get a list of function signatures or can I also get a text which says what the function does also?
12:48:29 <gentauro> hyperisco: https://icfp19.sigplan.org/
12:48:38 <gentauro> hyperisco: yeah
12:48:45 <gentauro> it's in Berlin this year so I had to go :)
12:49:21 <gentauro> sim590: yeah, you get that text as documentation when you click on the links
12:49:50 <gentauro> but you should actually be able to get "enough hints" from the signature ;)
12:51:04 <sim590> gentauro: I don't get any links in the output (this is the output of `hoogle map`): https://paste.debian.net/1093633/
12:51:53 <wildtrees> I need to use a slightly older version of ghc (8.4.4) for compiling some code I have cause a library has not been updated yet, I am on nix and using v1 cabal install with nix intergration enabled in my cabal config, and cabal installing warp, it can't find zlib, and its included in the nix-shell buildinputs, what do I do? :(
12:58:11 <gentauro> sim590: you shold get "links" like Google (that's why the name of Hoogle). Once you decide which signature you would like to use, click on it and you should arrive on hackage where you can read the documentation for the function as well as for the package
12:58:52 <gentauro> wildtrees: I'm on NixOS as well and zlib is a pain in the ass
12:59:50 <wildtrees> gentauro, really? idris needed it and it worked fine, I am trying zlib.dev and it still isnt working, what should I try next? does it depend on what I am installing?
13:00:19 <gentauro> wildtrees: I ended up making a dummy stack project
13:00:45 <gentauro> and I just typed `stack install zlib` so it was added to the `cache` under `~/.stack`
13:00:59 <gentauro> but my setup is very peculiar
13:01:14 <gentauro> cos I'm having some issues with stack v.2.x
13:01:32 <gentauro> so I downgraded to v.1.9.3 cos I have to give a talk and I would like my stuff to work
13:01:46 <gentauro> (once it's over, I will look into the new stack)
13:06:05 <wildtrees> gentauro, what makes zlib, specifically, a pain in the a**? 
13:07:15 <gentauro> wildtrees: the thing it's that it's a dependency for many projects and with some it just installs
13:07:21 <dmwit> sim590: I believe the command-line version doesn't give you doc links. But see also bhoogle, which I believe pulls together haddock and hoogle in the way you're hoping.
13:07:22 <gentauro> and with others it keeps failing ...
13:08:02 <gentauro> wildtrees: do you have this in your `~/.stack/config.yaml`?
13:08:03 <gentauro> nix:
13:08:03 <gentauro>   enable: true
13:08:03 <gentauro>   packages:
13:08:04 <gentauro>     - zlib
13:08:05 <dmwit> sim590: And there is an online version (hoogle.haskell.org) that definitely has links.
13:08:23 <gentauro> dmwit: I use the web version (hoogle.haskell.org)
13:08:36 <dmwit> Good for you?
13:08:48 <wildtrees> I am not using stack, I am using v1-cabal tools with nix integration in my cabal config and .cabal files
13:08:51 <gentauro> sim590: sry, I didn't read that you were refering to the command line. My bad ...
13:09:05 <gentauro> wildtrees: oh, I guess it's the same amirite?
13:09:08 <wildtrees> should I be using stack when on nix? 
13:09:14 <gentauro> wildtrees: Nope
13:09:21 <gentauro> at least not the stack v.2.0
13:09:50 <gentauro> it doesn't play well with NixOS as I keep getting the error message: "I can't find the Docker ..." 
13:09:59 <gentauro> I don't even have Docker on my NixOS :D
13:10:27 <gentauro> and I would expect that `stack` shouldn't have a dependency on Docker. That would be pretty bad
13:10:51 <sclv> wildtrees: is this with zlib the system lib or zlib the haskell lib?
13:11:10 <sclv> i guess that the nix configs for the haskell lib are smart enough to pick up the system lib dep too
13:11:58 <sclv> i guess i don't understand why you are cabal installing warp instead of putting it in your shell inputs as well?
13:12:43 <wildtrees> i dont know if the nix warp package will work with my older ghc 
13:14:21 <gentauro> wildtrees: btw, notice this:
13:14:29 <gentauro> 15:21 < gentauro> which GHC do you actually support for 19.03?
13:14:29 <gentauro> 15:22 < srhb> 822, 844, 864
13:14:45 <gentauro> there are only three version of GHC supported by NixOS (19.03)
13:14:56 <wildtrees> I am using 8.4.4 
13:14:56 <gentauro> so anything before those, will not work ...
13:15:05 <gentauro> wildtrees: oh, roger that
13:15:09 <wildtrees> :)
13:16:04 <gentauro> but sadly, I'm no cabal "aficionado" so I will not be able to help you further :D
13:16:37 <[Leary]> If you get 8.4.4 from nix, it should get a version of warp that builds with it.
13:17:03 <sclv> yeah. if you want to go out of the range and do things "yourself" you need to sort of do everything yourself. there's no middle ground
13:17:07 <sclv> but for 8.4.4 you should be fine
13:54:50 <rubik> does anybody of you know how i load just a directory specific .ghci file and not also the ~/.ghci?
13:56:01 <sicklorkin> man ghci shows `-ghci-script`
13:56:23 <sicklorkin> rubik: ^
13:58:39 <rubik> sicklorkin: ah thx, never tried it before
14:03:31 <maralorn> I met this Combinator S with the signature (a -> b -> c) -> (a -> b) -> a -> c. Does anyone have a Haskell based explanation why this thing is interesting or what interpretation it has?
14:04:19 <sicklorkin> what bird is that?
14:04:58 <Rembane> It looks like currying. 
14:06:01 <sicklorkin> AS?
14:06:12 <__monty__> maralorn: Programmable predicate?
14:06:51 <sicklorkin> sentential logic
14:07:39 <sicklorkin> maralorn: am I awrm?
14:07:40 <monochrom> S is most interesting when not considered alone, but rather considered together with K, in which case someone found out and proved that S and K together, when untyped, covers all of untyped lambda calculus.
14:08:16 <monochrom> Since that story is untyped, it is not Haskell based. In fact anti Haskell based
14:08:48 <monochrom> In Haskell, <*> for ((->) a) happens to be typed S.
14:12:02 <maralorn> monochrom: Thx.
14:12:18 <maralorn> sicklorkin: It‘s the starling. https://hackage.haskell.org/package/data-aviary-0.2.3/docs/Data-Aviary-Birds.html
14:14:49 <sicklorkin> :) www.starling-software.com/
14:14:57 <sicklorkin> long time ago
14:22:39 <maralorn> That question bugged me for quite a while. Glade I asked. Glad for the answers.
14:58:40 <sim590> gentauro dmwit: thanks for clarifications.
15:02:33 <infinisil> Just seen on reddit: "lens relies on using some pretty heavy compiler magic to make it so that even though there is a lot of abstract nonsense going on"
15:03:29 <infinisil> Wondering who is saying edwardk's library is a bunch of abstract nonsense, but then I checked the username, it's edwardkmett :)
15:03:39 <Rembane> ^___^
15:03:57 <infinisil> s/is/has
15:04:30 <argent0> hi, regarding the singletons library. Is there a way to create a Nat-indexed type (eg: Box (Nat, Nat)) or do I have to roll/import my own nats?
15:05:30 <argent0> I've CBox :: MySNat n -> MySNat m -> a -> Box '(n, m) a
15:05:43 <infinisil> https://www.reddit.com/r/haskell/comments/cjkc3l/should_i_be_inlining_instance_implementations/eveg13n/ btw
15:05:57 <argent0> but that is not "Inductive" on n nor m
15:06:23 <argent0> s/MySNat/SNat/g
15:46:35 <crestfallen> hi I cannot figure out how to prevent a ambiguous occurrence error. I guess I'm way off by trying to do something like   list :: []      ,    https://paste.ee/p/rTJoG
15:49:01 <argent0> crestfallen: How is your list type called ?
15:49:31 <crestfallen> argent0: yeah not sure I got stuck trying to define it
15:50:19 <crestfallen> sorry hold on just thought of something...
15:50:42 <argent0> crestfallen: How is your list type called ?
15:51:04 * argent0 oops
15:51:46 <argent0> crestfallen: I suspect you are reading a book. Do you think you know how would you define such a type?
15:53:09 <crestfallen> argent0: yes its a book. no not sure. could I do list (x:xs) = [x:xs]   or something I am foggy
15:55:34 <argent0> crestfallen: How would you define the Bool type? (tip: it involves the use of the `data` keyword)
15:56:43 <crestfallen> right yeah I'm looking at   '    data [a] = [] | a:[a]
15:57:47 <crestfallen> but wouldn't it need to be a function type that I name? no clue argent0
15:58:50 <xsperry> crestfallen they want you to define your own list type. for example:  data List a = Cons a (List a)     (or if you prefer infix constructor data List a = a :| List a)
15:59:15 <solonarv> (isn't that missing the Nil case ?)
15:59:17 <xsperry> (I'm missing | Empty or similar there)
15:59:18 <Cale> xsperry: Don't forget about the empty list
15:59:20 <Cale> yeah
16:00:25 <argent0> crestfallen: then you have to implement funtor instance for that type
16:00:46 <argent0> functor*
16:00:52 <crestfallen> sorry not sure what to do...
16:01:29 <crestfallen> data List a = Nil | Cons a (List a)        I'm familiar with that 
16:01:48 <crestfallen> so you integrate that into the functor definition?
16:02:24 <argent0> you have to write an _instance_ of functor for that
16:02:46 <crestfallen> ok one moment please
16:03:04 <Boarders> if I have a Vector from Data.Vector.Storable v :: Vector (# Word8, Word8 # ) , is there some way I can convert that to just a Vector Word8 of double the length?
16:04:42 <argent0> Boarders: if Vector is Foldable and Monoid that can be done with foldMap
16:05:27 <argent0> foldMap (\(x, y) -> x ++ y) vec
16:05:28 <Boarders> I was kind of hoping for something efficient
16:06:50 <EvanR> > foldMap (\(x,y) -> [x,y]) [(1,2),(3,4),(5,6)] // but yeah probably not what Boarders was asking
16:06:53 <lambdabot>  error:
16:06:53 <lambdabot>      • Variable not in scope:
16:06:53 <lambdabot>          but
16:07:07 <EvanR> > foldMap (\(x,y) -> [x,y]) [(1,2),(3,4),(5,6)] -- but yeah probably not what Boarders was asking
16:07:09 <lambdabot>  [1,2,3,4,5,6]
16:09:08 <xsperry> @hoogle Maybe (IO a) -> IO (Maybe a)
16:09:09 <lambdabot> Prelude sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
16:09:09 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
16:09:09 <lambdabot> Test.Hspec.Discover sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
16:09:54 <EvanR> whoa, @hoogle worked
16:10:48 <xsperry> I forgot that they made sequence generic. nice
16:11:19 <argent0> Boarders: Maybe convert it to a list in the middle. fromList $ foldl' (\acc (x,y) -> x:y:acc) $ toList vec -- O(n) (?)
16:11:36 <argent0> ^[]
16:12:02 <EvanR> Boarders: look at the runtime representation, if they are the same, use unsafeCoerce (or coerce?) and cross your fingers
16:15:33 <fog> I have made a simple example of trying to write "midware" using classes
16:15:34 <fog> https://gist.github.com/fog-hs/c2eece5458280ca2509f2ebfb350bfad
16:15:43 <fog> it does not seem to work, the classes overlap
16:16:01 <fog> but commenting out one of the imports allows the test for either backend to run
16:16:45 <crestfallen> argent0: working...
16:17:15 <EvanR> fog: how do yuo have a class and instance with no parameter...
16:17:30 <fog> yah, thats the problem
16:17:39 <EvanR> class with no parameter, instance for no type in particular
16:17:41 <fog> but it cant exactly take the module name as a parameter
16:17:51 <fog> it could have an arbitrary flag
16:18:04 <fog> but it shows maybe how backpack could be better
16:18:29 <fog> the idea was that the qualified import would allow them to not overlap, but thats not how it works
16:19:02 <crestfallen> argent0: aside from using AllowAmbiguousTypes, i'm not sure how to do it.
16:19:31 <crestfallen> I tried to rename List to Listt
16:19:50 <crestfallen> but it's fmap that is ambiguous so what to do..
16:21:07 <argent0> crestfallen: can you post your instance?
16:23:15 <fog> not sure if its easy to make a backpack example without a cabal file, like how to use it with ghci...
16:23:25 <crestfallen> well its surely wrong    https://paste.ee/p/cclB1
16:24:32 <EvanR> crestfallen: indent the definition of fmap
16:24:49 <crestfallen> ...
16:24:57 <EvanR> for starters
16:25:02 <argent0> crestfallen: and you have to use your own constructors
16:25:08 <argent0> to pattern match
16:25:44 <crestfallen> one moment please
16:29:16 <crestfallen> instance Functor [] where        << that remains unchanged?
16:30:26 <crestfallen> argent0: EvanR very sorry no clue
16:32:00 <argent0> crestfallen: your `instance Functor Listt where` line is fine
16:32:41 <crestfallen> so I put the data declaration within the where statement and ...
16:32:55 <crestfallen> indented and ...
16:33:19 <crestfallen> used Nil and Listt to pattern match the lhs
16:33:21 <xsperry> not sure why you renamed List to Listt. it won't change anything
16:33:37 <crestfallen> I don't know what I'm doing here :(
16:34:44 <argent0> crestfallen: take a look at (https://en.wikibooks.org/wiki/Haskell/Classes_and_types) and (https://en.wikibooks.org/wiki/Haskell/The_Functor_class)
16:34:48 <xsperry> Listt is a type, you can't use it to pattern match. You have to use constructors to pattern match (Cons and Nil)
16:35:16 <crestfallen> I see .. thanks one moment
16:36:17 <xsperry> Cons is equivalent to (:), Nil to [], and List a to [a]
16:38:19 <crestfallen> so those constructors go somehow in the fmap definition
16:41:07 <argent0> in the type of fmap `f a` is replaced by the constructors of the type you want to write an instance for
16:41:20 <xsperry> yes. deconstruct your list to head and tail, apply function to head, Cons it with recursive call to fmap f on tail
16:41:50 <argent0> in this case you have two _cases_ Nil :: Listt a and Cons :: a -> Listt a -> Listt a
16:42:23 <argent0> that's two ways of constructing a `Listt`
16:42:45 * sigmatau waves
16:43:17 <fog> EvanR: i cant figure out how to use backpack at all... is there any reason why simply importing one of these modules is a bad idea?
16:43:27 <argent0> so in general, `fmap :: (a -> b) -> f a -> f b` in the case of the `Listt` instance this becomes. fmap (a - > b) -> Listt a -> Listt b`
16:43:30 <fog> instead of trying to import both...
16:47:56 <crestfallen> argent0: geez. upwards to 2 hours on this since yesterday
16:48:37 <argent0> crestfallen: give it time, it all makes sence after a while
16:49:24 <crestfallen> no I haven't been able to do a problem the book mentions in passing 
16:50:12 <crestfallen> argent0: I don't understand your comment about having two cases..
16:50:13 <argent0> crestfallen: Which book are you reading?
16:50:26 <crestfallen> hutton
16:51:14 <xsperry> crestfallen do you know how to write mymap :: (a -> b) -> [a] -> [b]?
16:52:25 <argent0> crestfallen: the definition `data Listt a = Nil | Cons a (Listt a)` says that there are two ways of "constructing" a `Listt`. One is `Nil` and the other is `Cons`
16:52:56 <crestfallen> very sorry I'm getting confused. I tried fmap g Nil = [] : fmap g (Cons x (xs)) = fmap g xs ++ [g x]  . this apparently reverses the list
16:53:12 <argent0> when you want to write a instance of `Functor` you are required to write a function `fmap :: (a - > b) -> Listt a -> Listt b`
16:53:35 <argent0> crestfallen: the return type has to be `Listt b`
16:53:45 <crestfallen> ok
16:53:55 <xsperry> that should fail to compile. [] is not your List, and (:) is not your List constructor
16:54:15 <argent0> try as xsperry suggests. Write `mymap :: (a -> b) -> Listt a -> Listt b` as a different funtion
16:54:51 <fog> the notes in the page https://hackage.haskell.org/package/unpacked-containers are helpful for understanding backpack
16:55:19 <fog> i wonder if Edward Kmett is online as the page links this forum as his contact details!
16:55:21 <crestfallen> does the data Listt declaration go inside the where statement ?
16:55:33 <xsperry> actually I was curious if he can write mymap :: (a -> b) -> [a] -> [b]
16:55:53 <fog> if so, it would be great to get some tips on trying to convert the example here; https://gist.github.com/fog-hs/c2eece5458280ca2509f2ebfb350bfad
16:55:56 <fog> into a backpack!
16:56:03 <xsperry> map for built-in list. if not, then bringing in typeclasses, custom list type, will just confuse the issue even more
16:56:57 <fog> i have basically no experience working with cabal, other than for downloading from hackage
16:57:11 <argent0> crestfallen: nope
16:57:32 <edwardk> fog: usually i am
16:57:39 <crestfallen> there was a typo      fmap g Nil = [] ; fmap g (Cons x (xs)) = fmap g xs ++ [g x]
16:57:46 <crestfallen> the semicolon
16:58:29 <xsperry> crestfallen you can't use [g x], or ++, or []. they work with built-in list, not your own list
16:58:45 <argent0> crestfallen: that is a fmap :: (a -> b) -> Lista a -> [b]` which should not typecheck
16:59:09 <edwardk> fog: for backpack I'd probably do something like take Rotate.hs, which seems broken, but generally what you want to parameterize on and move the stuff out of the class to the top level
16:59:10 <argent0> *if it is inside the instance definition*
16:59:30 <edwardk> making it into a module signature
16:59:37 <edwardk> then parameterize the rest of the stuff on it
16:59:42 <fog> that was the idea yeah
16:59:45 <edwardk> by importing from the signature
17:00:03 <edwardk> you need to make sure you have separate source directories for each of the backpack modules you are using
17:00:11 <edwardk> otherwise ghc gets confused fast
17:00:31 <edwardk> other than that? github.com/ekmett/coda might be a more advanced backpack example to look at
17:00:50 <fog> maybe you could help walk me through it? i dont know how to write cabal files
17:01:21 <edwardk> i don't personally have the free time right now, but the one in coda has the right kind of structure for what you want and uses several layers of backpack
17:01:32 <edwardk> look at the 'dyck' library in there for inspiration
17:01:33 <fog> its a bit of a maze
17:01:54 <edwardk> it is parameterized on a Token signature which is like the one your Rotate
17:02:27 <fog> honestly, trying to extract the relevant info from that is a tall order 
17:02:30 <edwardk> then look at something like lexer which takes the dyck library and locks it down making a concrete instantiation of the backpack signature
17:02:47 <edwardk> fog: as is spending 2-3 hours walking you through the process =P
17:03:10 <fog> hmm, how long would it take to convert the gist into a working backpack thing?
17:03:21 <edwardk> not trying to be a dick, just offering what resources i can giventhat i'm in the midst of moving right now
17:03:25 <fog> which i probably still wouldnt be able to install...
17:03:37 <fog> yeah no worries
17:04:00 <edwardk> trying to think of smaller scale examples
17:04:07 <crestfallen> https://paste.ee/p/On0SI    argent0 xsperry    what I have so far
17:04:17 <fog> yeah, thats what this was supposed to be...
17:04:45 <hpc> fog: a good place to start is looking at stuff on hackage
17:05:01 <xsperry> crestfallen you can't use [g x], or ++, or []. they work with built-in list, not your own list
17:05:10 <fog> its not a source code issue though, its this crazy cabal process
17:05:29 <fog> i get that Rotate should become a "signature" instead of a module
17:05:39 <fog> but i just dont understand how i would build that
17:05:48 <xsperry> when writing a functor instance for List, fmap must return List a, not [a]
17:06:22 <fog> there are some example cabal files but they are fairly opaque having never really worked with them before
17:06:39 <fog> so trying to simultaniously learn backpack and cabal is a difficult thing
17:06:53 <fog> thought ed could help as he is able to use both!
17:07:14 <fog> difficult to know how to be time efficient though 
17:08:01 <argent0> crestfallen: on the rhs you have to only use either `Nil` or `Cons`. No `[]` or `++` allowed.
17:08:55 <argent0> line 9: should read: fmap :: (a -> b) -> Listt a -> Listt b
17:09:41 <xsperry> crestfallen do you know how to manually construct a List using Cons?
17:09:57 <xsperry> for example, to construct a list equivalent to [1,2,3,4] 
17:10:28 <crestfallen> yes 1:2:3:4:[]
17:10:45 <xsperry> no, that constructs built-in list, not List
17:10:58 <xsperry> you have to use Cons and Nil
17:11:04 <edwardk> fog: cabal files aren't that complicated and there is a ton of documentation on them in general if not much on backpack
17:11:28 <edwardk> once you have the basic cabal approach down layering backpack on isn't much to learn, just some funny extra stanzas to add
17:11:32 <fog> i was trying to work with this example, but the build instructions provided just threw an error. http://blog.ezyang.com/2017/01/try-backpack-cabal-packages/
17:12:03 <fog> i at least wanted something that i could build to start with
17:12:04 <edwardk> fog: not sure if any of the code in that example is legal haskell it was an early proposal as i understand it
17:12:15 <crestfallen> its like scheme  (Cons 1(Cons 2 (Cons 3  (Cons 4 (Nil))
17:12:24 <argent0> crestfallen: right
17:12:32 <fog> well it linked here which seemed legit; https://github.com/ezyang/backpack-regex-example/tree/multiple-packages
17:12:35 <xsperry> that is what you have to do in fmap
17:12:52 <edwardk> the stuff in coda and unpacked-containers uses the shipped syntax
17:12:54 <edwardk> http://hackage.haskell.org/package/unpacked-containers-0/unpacked-containers.cabal
17:12:57 <edwardk> lets skim that
17:13:17 <edwardk> library utils sets up a library for some common elements i want to use in several of these libraries
17:13:21 <fog> so you have the mixins stanzas
17:13:41 <edwardk> the unnamed library at the top is the main backpack package i expect users to instantiate
17:13:43 <fog> and there was mention of making a library
17:14:24 <fog> ok it says library ... signatures Key
17:14:25 <crestfallen> xsperry:   not sure I understand . I have this now with head and tail
17:14:36 <crestfallen> https://paste.ee/p/ddamo
17:14:38 <fog> so thats what would my Rotate module end up being like
17:15:01 <edwardk> executable unpacked-set-example uses a 'mixins' stanza to instantiate the backpack package unpacked-containers using the module named 'Int' from the 'example' package as the 'Key' signature that unpacked-containers expects
17:15:12 <edwardk> yes
17:15:23 <crestfallen> well do tail and head also go on the lhs?
17:15:37 <edwardk> and if you look in src there is a Key.hsig that has what goes in a signature file
17:15:45 <edwardk> its basically just haskell type signatures and some empty data decls
17:16:03 <xsperry> crestfallen, yes, it is common to name head x and tail xs
17:16:37 <xsperry> crestfallen, you don't need concat, just flip (g head) and (fmap g tail) and use Cons 
17:16:38 <fog> https://hackage.haskell.org/package/unpacked-containers-0/src/example/Int.hs
17:16:42 <argent0> crestfallen: I'll give you the pieces: Cons, Nil, (g x), fmap g xs
17:17:15 <edwardk> the tedium is that to _use_ the backpacked package you're going to need 2+ libraries on top of the basic thing you just packaged. unpacked-containers is the library parameterized on the Key type, example is the library that provides an instance of that signature, then the executable provides something that uses the former parameterized on the latter.
17:17:18 <fog> https://hackage.haskell.org/package/unpacked-containers-0/src/src/Key.hsig
17:17:55 <edwardk> Key.hsig describes what we expect of a Key module. some type named Key that is an instance of Eq and Ord
17:18:19 <fog> something like RotationMidware3d ?
17:18:23 <edwardk> Int.hs provides just the type synonym Key = Int -- and we can use the existing Eq Int and Ord Int instances
17:18:26 <fog> or is that the "module" ... 
17:18:44 <edwardk> drop the class you have completely, just move those definitions to the top of the signature
17:19:07 <edwardk> https://github.com/ekmett/coda/blob/master/src/dyck/Token.hsig is a more complicated signature
17:19:32 <edwardk> https://github.com/ekmett/coda/blob/master/src/layout/Dyck.hsig is another example
17:19:42 <edwardk> https://github.com/ekmett/coda/blob/master/src/layout/Parser.hsig
17:19:46 <fog> right, so while you just have "data Key", the Rotate.hsig would have all the things defined in the class
17:20:01 <edwardk> https://github.com/ekmett/coda/blob/master/src/rope/Summary.hsig
17:20:10 <edwardk> yeah
17:20:26 <edwardk> then you'd use it like any haskell module in the rest of your code in the backpacked library
17:20:37 <fog> so just like a class, it just provides type signatures... and instances apparently
17:20:48 <fog> (also a bit like a C header)
17:21:07 <edwardk> to _use_ that library then you first need another library (like the example one that supplies an Int key module) that provides a module that meets that signature
17:21:10 <edwardk> yep
17:21:35 <edwardk> then you can use a third library that has a mixin clause like the one in the unpacked-container example executable
17:21:46 <edwardk> or one of the several of them i use in coda
17:21:57 <fog> ok, so the gist had 2 backends that were implementing the class
17:21:57 <fog> https://gist.github.com/fog-hs/c2eece5458280ca2509f2ebfb350bfad
17:22:25 <fog> so there should be some way of choosing which of these to use to "implement the signature" (?)
17:23:02 <fog> "a module that meets a signature"
17:23:24 <crestfallen> argent0: very sorry. about to cry. gotta go
17:23:34 <edwardk> https://www.irccloud.com/pastebin/BqpAGsel/
17:23:36 <fog> so instead of writing instances for the class, we write modules
17:23:49 <crestfallen> argent0: thanks for the help
17:23:57 <Cale> crestfallen: You okay?
17:24:39 <edwardk> fog: yeah. then backpack compiles the backpack package in a sort of minimalist non-code-generating way to check the signature works and the backpack module typechecks
17:24:53 <fog> i saved that as Rotate.hsig
17:24:54 <edwardk> and then when you go to instantiate it it compileas it completely separately for each mixins stanza
17:25:04 <crestfallen> confused and annoyed Cale
17:25:04 <argent0> crestfallen: no pain, no gain. Take a break. Try another book. https://www.seas.upenn.edu/~cis194/fall16/
17:25:48 <Cale> crestfallen: Perhaps I could help explain something?
17:26:32 <edwardk> fog: i hope that at least gets you started
17:26:40 <edwardk> no good access to my compiler where i am
17:26:51 <fog> well no now i dont know how to instantiate that hsig 
17:27:01 <edwardk> see the unpacked-containers example
17:27:23 <fog> i was just looking for that part where you make Key = Int
17:27:39 <crestfallen> Cale sure
17:27:59 <edwardk> lets consider separate src directories for the backpack lib and the concrete types you might in instantiate it at, and finally for the third library that uses them
17:28:50 <edwardk> for lack of names: src/fog-rotate, src/fog-quat-base, src/fog-quat
17:28:57 <edwardk> in src/fog-rotate put Rotate.hsig
17:29:01 <Cale> crestfallen: It shouldn't be necessary to use the head and tail functions to define the fmap for your custom list type there (they only work on ordinary lists anyway) -- you've already pattern matched x (which is the head of your list) and xs (which is the tail)
17:29:07 <edwardk> and eventually put your other code that uses the signature abstractly
17:29:36 <edwardk> in src/fog/quat-base put a module that implements the signature. like your VectRotate.hs or whatever
17:29:38 <fog> so Key.hsig had; signature Key where
17:29:43 <edwardk> er src/fog-quat-base
17:30:11 <edwardk> in src/fog-quat we'd put whatever other code we're going to use that needs to be build on top of the instantiated backpack signature.
17:30:38 <fog> we could do this in a /query
17:30:55 <Cale> crestfallen: Your goal is that fmap f should be the function which applies f to each of the elements of a list. When you're defining it recursively for (Cons x xs), you're allowed to assume that fmap f xs will work, and figure out what result should be produced in terms of that.
17:31:06 <edwardk> then in the top level cabal project you'd need 3 libraries. one for the backpack library itself, one providing vectrotate and the other providing the mixin stanza and nothing else for the moment
17:31:12 <edwardk> fog: i'm about out of time
17:31:15 <fog> but ok ill follow those instructions
17:31:24 <fog> sure, no worries, whatever works
17:31:46 <edwardk> when in doubt, look at the unpacked-containers example as it matches almost one-to-one with what you want to do here
17:31:53 <fog> finally i guess id need a cabal new-build something.... call
17:31:59 <edwardk> the only thing is that the final instantiation is happening in an executable there not in a library
17:32:00 <crestfallen> Cale  without using concat there?
17:32:08 <Cale> crestfallen: Shouldn't need concat.
17:32:17 <Cale> crestfallen: But you will probably want to use Cons
17:32:19 <edwardk> others here can help out with the cabal basics
17:32:21 <fog> right, something about building libraries and executables
17:32:22 <fog> ok
17:32:45 <edwardk> just trying to get you the stuff you can't get elsewhere and by dumping it here i hope its visible to others who might help you out
17:32:48 * argent0 is it too early for holes?
17:32:53 <fog> ill put all that together in a gist and return soon maybe to ask how to build it
17:33:29 <fog> edwardk, not a bad idea actually, the documentation for using backpack isnt great, maybe this can be a good example
17:33:31 <crestfallen> Cale now I'm getting an infinite type error
17:34:03 <fog> ok, back soon
17:34:35 <Cale> crestfallen: You're trying to get a list where g has been applied to every element of (Cons x xs), you're allowed to assume that (fmap g xs) is the list where g has been applied to every element of xs
17:34:49 <Cale> crestfallen: and of course, you can apply g to x, it's just (g x)
17:35:34 <crestfallen> so this reverse the list correct Cale
17:35:38 <crestfallen> reverses
17:36:34 <Cale> crestfallen: It shouldn't
17:37:14 <xsperry> concat would, Cons won't
17:37:27 <crestfallen> the exercise is to reverse the list. 
17:37:30 <Cale> crestfallen: You should be producing a list where the elements are in the same order essentially, but where g has been applied to everything.
17:37:42 <Cale> Oh, well, usually fmap wouldn't do that
17:37:47 <Cale> But I guess it could?
17:38:08 <crestfallen> I'm clueless. if I may paste the section of the book .....
17:39:28 <argent0> Cale: that would mess up the laws. fmap id == id. (I think)
17:42:27 <crestfallen> argent0:  Cale yes thanks, that is the purpose of the exercise : here's what the book says    https://paste.ee/p/hX0w1
17:42:42 <crestfallen> argent0: correct
17:43:20 <xsperry> that's an odd excercise.. asking reader to write Functor instance that breaks laws
17:43:49 <crestfallen> sorry I thought that line 7 illustrates the reversal
17:44:11 <crestfallen> anyway no clue sorry if it wasn't clear
17:45:55 <Cale> argent0: yeah, it would
17:45:59 <crestfallen> it says further: This declaration is type correct, but fails to satisfy the functor laws, as shown (by following examples)
17:46:15 <crestfallen> > fmap id [1,2]
17:46:18 <lambdabot>  [1,2]
17:46:50 <crestfallen> well , thats what my modified example would do [2,1]
17:47:26 <crestfallen> ..> fmap id [1,2]
17:47:30 <crestfallen> [2,1]
17:48:42 <crestfallen> ..> fmap (not . even) [1,2]
17:48:48 <crestfallen> [False,True]
17:48:49 <hpc> that reads to me like it's part of some larger thing
17:48:49 <crestfallen> etc
17:48:52 <oats> what is ..> ?
17:49:05 <hpc> like you're not supposed to actually implement it, but imagine it's the case for the sake of an argument further down the page
17:49:11 <MarcelineVQ> just a prompt
17:49:21 <hpc> it keeps lambdabot from running it
17:49:40 <xsperry> crestfallen, try implementing lawful functor instance for your List. you don't need concat, just Cons
17:50:18 <crestfallen> xsperry: sorry appreciate it but I tried to be lawful . I'm doing something wrong
17:50:42 <xsperry> did you paste your latest attempt?
17:50:55 <crestfallen> one sec
17:52:29 <crestfallen> https://paste.ee/p/CtTX1
17:52:52 <xsperry> you reversed the argument order of Cons
17:53:15 <xsperry> g x should be first argument, fmap g xs second
17:53:32 <crestfallen> sorry but will that give the reversal behavior?
17:54:42 <xsperry> no. it will give correct and lawful behavior (and will compile, unlike your current code)
17:55:29 <argent0> crestfallen: If you want the unlawful behaviour (which you will never want) you need to implement (++) :: Listt a -> Listt a -> Listt a (with other name, like app)
17:56:09 <oats> > fmap id [1,2]
17:56:12 <lambdabot>  [1,2]
17:56:16 <oats> ..> fmap id [1,2]
17:56:32 <oats> oh, I see
17:56:34 <oats> I'm dumb lol
17:57:21 <crestfallen> argent0: please illustrate so I can catch the bus. :)
17:57:59 <argent0> crestfallen: "modify the above
17:58:01 <argent0> declaration accordingly"
17:58:13 <crestfallen> omgj
17:58:15 <crestfallen> omg
17:58:48 <argent0> in the book involves: defining the Listt type, writing a replacement for (++) and finally write the instace
17:59:32 <argent0> where [] will be replace by Nil, and [g x] by Cons (g x) Nil
17:59:40 <xsperry> not sure I like that the book encourages writing unlawful functor instance
17:59:57 <crestfallen> its to illustrate a point later on
17:59:59 <DigitalKiwi> what book is it
18:00:22 <crestfallen> I won't say its a good book. there's a reason I would have to transcribe it from kindle
18:02:41 <crestfallen> argent0: could you show it to me completed I've tried numerous times for nearly 3 hours
18:03:18 <argent0> crestfallen: just a sec
18:03:36 <Cale> Which book is this?
18:03:40 <sm[m]> Data.List.sort is O(n log n), am I right ? And sortBy too, assuming a constant-time compare function ?
18:03:47 <crestfallen> above I meant to say, "I won't disclose the books name because its a good book and I don't want people avoiding it. its highly regarded
18:04:04 <crestfallen> but if Cale asks I'll tell: G Hutton
18:04:28 <crestfallen> its not in the exercises, its given in passing in the monad chapter
18:04:59 <Cale> crestfallen: Ah, weird
18:05:19 <crestfallen> he's essentially showing how to break the functor rules
18:05:39 <Cale> Ah, if that's the point of the exercise, then fair enough :)
18:05:43 <crestfallen> I haven't read much further just stuck in the mud..
18:05:48 <dmwit> sm[m]: Right.
18:06:02 <Cale> crestfallen: I would start by implementing reversal for your list type separately though
18:06:13 <DigitalKiwi> that is a good book
18:06:24 <sm[m]> thanks. Also.. if I compose two O(n log n) functions, is the resulting function still O(n log n) ish ?
18:06:52 <crestfallen> I like it... drier than a rattlesnake tho
18:06:52 <dmwit> Sure it is.
18:07:31 <sm[m]> good
18:07:31 <Cale> Implement map and reverse, and put them together into your (broken) fmap, so that you can focus on one thing at a time
18:07:32 <argent0> crestfallen: https://bpaste.net/show/r3gP
18:09:51 <argent0> that's what the "modify the above declaration accordingly" involves
18:11:12 <crestfallen> argent0: thanks it compiles but doesn't do
18:11:21 <crestfallen> ..> fmap id [1,2]
18:11:25 <crestfallen> [2,1]
18:12:33 <fog> ok so i downloaded the tar.gz from https://hackage.haskell.org/package/unpacked-containers-0 ... then ran cabal new-build example and then cabal run example and it produced a list [1..10] but then after searching for where the exe was generated and running in it just returned True. why didnt the exe produce the list?
18:12:33 <argent0> ..> fmap (\a->a) (Cons 1 (Cons 2 Nil))
18:12:42 <argent0> Cons 2 (Cons 1 Nil)
18:12:43 <MarcelineVQ> This exercise is not using [1,2]
18:13:05 <oats> why is fmap altering the structure of the data
18:13:06 <argent0> bc, it is Listt all the time
18:13:53 <fog> oh, it was a different example.exe nvm! the actuall exe it produced works fine.
18:14:31 <fog> $ ./unpacked-set-example.exe
18:14:35 <jmcarthur> argent0: A good heuristic is to look for the line where the head and tail are swapped in the source code. In this case it looks like maybe it's line 6?
18:14:39 <xsperry> crestfallen declare list like this:  `data List a = Nil | Cons a (List a) deriving Show'  then try `fmap id (Cons 1 (Cons 2 (Cons 3 Nil)))'
18:15:01 <crestfallen> thanks working xsperry ..
18:15:49 <jmcarthur> oats: I meant to address you, not argent0 
18:15:50 <argent0> oats: jmcarthur: the point is an unlawfull functor instance. Which I do not condone. Please don't put it on my record.
18:16:06 <oats> gotcha :)
18:16:52 <crestfallen> the author's scottish for chrissakes. he must know this stuff    :)
18:19:59 <crestfallen> xsperry: yeah, I did a little scheme. looks familiar thanks ALL argent0 Cale MarcelineVQ   VERY KIND gotta go. Pax
18:20:17 <argent0> the point is that haskell let's you write unlawfull instances so you have to check them yourself
18:21:02 <crestfallen> cool I'll study the working program in the morning really appreciate it.
18:22:27 * MarcelineVQ sidles away from the teetering pile of dirty spoons.
18:50:30 <ejmqwr> Just had a basic question, I know that some function like f :: a -> a means that the arg and return value must have the same type, and that Maybe a = Nothing | Just a means a can be any type, but what is the use of "a" and "b" in Either a b = Left a | Right b? Can't it just be Either a = Left a | Right A?
18:51:17 <Clint> explain what you mean by that
18:52:45 <lyxia> How would you write Either Int Bool otherwise
18:55:42 <xsperry> ejmqwr, with your Either type this wouldn't compile: [Left "error message", Right 10]
19:06:54 <fog> https://github.com/fog-hs/rotate/tree/master/src%20-%20Copy
19:06:58 <fog> this builds wrong
19:07:01 <fog> any help?
19:07:15 <fog> cabal.exe: Cannot process the executable 'vect-rotate' because this package
19:45:34 <oats> I'm really tempted to start using <> everywhere instead of ++ or Text.(++) or ByteString.(++) or whatever
19:49:01 <EvanR> I'm really tempted to rename <> to ++ and drop original monomorphic ++
19:49:11 <oats> I'm down, let's do it
19:49:34 <suzu> straight to base lets go
19:59:09 * turab likes
20:03:52 <oats> all your lists are belong to us
20:04:07 <oats> this meme brought to you by the SemigroupGang
20:21:47 <argent0> why is `type TerminalState m :: Nat -> Nat -> Type
20:21:52 <argent0> ` non injective ?
20:22:59 <argent0> isn't injective: forall (a b : S) (f: S -> T), f(a) = f(b) -> a = b
20:58:27 <MarcelineVQ> argent0: injective type families have a specific syntax https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#injective-type-families
21:05:56 <sim590> jkI'm trying to understand the usage of . and $. How can I remove the parentesise here: https://paste.debian.net/1093668/ ?
21:07:06 <Cale> sim590: Honestly, I'd just move the parens
21:07:16 <sim590> I'm talking about parenthesese after the comma.
21:07:21 <Cale> sim590: x : operArray fct xs (fct init x)
21:07:30 <sim590> hmmm
21:08:02 <sim590> Why can I do that?
21:08:21 <Cale> Because function application binds more tightly than any infix operator
21:08:31 <Cale> in particular in this case, more tightly than (:)
21:09:02 <sim590> Why aren't the parenthesis just not needed if I have my $ after xs and before fct ?
21:09:10 <sim590> other way around
21:09:18 <sim590> huh
21:09:19 <Cale> Because $ has very low precedence
21:09:33 <Cale> the lowest possible, i.e. it binds more weakly to its arguments than : does
21:09:52 <Cale> So it would end up being  (x : operArray fct xs) $ (fct init x)  then
21:10:06 <Cale> but that probably doesn't even typecheck
21:10:52 <sim590> hmmm. OK. I didn't know about the order between tightness of associativity.
21:15:42 <argent0> MarcelineVQ: Thanks, I found out eventually
21:16:00 <MarcelineVQ> argent0: woo
