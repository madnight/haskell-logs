01:04:16 <dminuoso> cocreature, solonarv: https://github.com/travitch/haskell-pragma.el this is the final solution to "typos" in language pragmas. :)
01:18:03 <tdammers> there is no such thing as a "raw string". there's "raw bytes" (a.k.a. ByteString), which you can read with the IO stuff from Data.ByteString, e.g. Data.ByteString.readFile
01:18:58 <tdammers> and there's strings, but those aren't raw, and when you read those from a file (e.g. with Prelude.readFile), the data in the file is actually decoded according to the appropriate encoding, and what you get is not raw data, but an encoding-agnostic (or rather, encoding-transparent) unicode string
01:19:05 <tdammers> same for Data.Text.IO.readFile
01:19:31 * dminuoso .oO( ByteString might have been more appropriately named ByteVector )
01:19:43 <tdammers> ByteString is definitely a misnomer
01:20:03 <dminuoso> Or WordVector perhaps.
01:20:03 <tdammers> or maybe not, but it is definitely at odds with the common usage of the word "string"
01:20:18 <dminuoso> tdammers: Otoh it signifies that string is not a well-defined term.
01:20:24 <tdammers> it does
01:21:02 <tdammers> right up there with "function", "variable", "constant", "statement", "boolean", "number", and pretty much everything else in programming
01:21:55 <tdammers> but what I meant is that there are two commonly used meanings of "string" in programming: a) a sequence of things, typically supporting efficient concatenation and sub-sequencing; and b) a data structure designed for holding text
01:22:09 <dminuoso> tdammers: I really smiled during a recent discussion where the other person pointed out (roughly) "In all other langauges strings are simple. When I talk to fellow Java programmer, we dont need to define what a string is. They just understand"
01:22:12 <tdammers> ByteString is correct in the a) sense, but not in the b) sense
01:22:24 <dminuoso> It reminds me of how and why I'm an ignosticist.
01:22:33 <tdammers> ignosticist?
01:24:22 <tdammers> ah
01:24:31 <tdammers> definitely -blah material though
01:24:31 <dminuoso> tdammers: Ignosticism is defined by the idea that discussions about God are silly because there's no coherent definition of the term "god" that is shared beforehand.
01:24:58 <dminuoso> Somehow people just start talking and discussing "do you believe in god" without agreeing on a precise of the word.
01:25:05 <dminuoso> *precision definition
02:17:29 <jgt> dminuoso: that's applicable to many of today's more pertinent isms
03:05:23 <kuribas> I am reading the little typer.
03:05:30 <kuribas> It says "recursion is not an option".
03:05:33 <kuribas> I am now implementing recursion in Pie :)
03:05:34 <kuribas> (btw, is this off-topic ?)
03:07:18 <kuribas> IMO Pie is pretty neat for a toy language.  Constructing proofs can be cumbersome though...
03:07:52 <kuribas> I suppose it's easier in a "real" language like idris.
03:10:02 <ski> "is not an option", in which sense ?
03:10:33 <ski> they're thinking of total programming ?
03:10:46 <ski> posibly for the purpose of dependent types ?
03:10:52 <kuribas> ski: yeah, it doesn't have control structures
03:11:03 <kuribas> only eliminators, like induction over Nats or over lists.
03:11:17 <kuribas> Pie is total
03:11:30 <no-n> what does total mean?
03:11:43 <ski> every function, every expression, terminates
03:11:43 <kuribas> no-n: a function always returns a value for any of its arguments
03:11:58 <no-n> ahh
03:12:07 <ski> (and there's no pattern-matching failure causing the program to abort)
03:12:28 <kuribas> ski: so my idea is that recursion can be implemented as induction over Nats
03:12:43 <ski> which kind of recursion ?
03:12:50 <ski> (try implementing Collatz ?)
03:12:57 <kuribas> ski: recursion with a measure
03:13:03 <kuribas> and a proof of smallerness
03:13:13 <ski> well-founded recursion, then
03:13:49 <dminuoso> "object key > 34: Failed reading: satisfy"
03:13:57 <dminuoso> Now that's a diagnostic.
03:14:20 <kuribas> ski: Collatz is possible if you provide proof :)
03:14:20 <ski> sounds fun
03:14:36 <ski> kuribas : that's a big "if" :)
03:15:44 <kuribas> I wonder if you could plug in an smt solver to proof some equalities, and remove a lot of the tediousness of proving.
03:16:36 <kuribas> equality in Pie is syntactic equality (after normalisation)
03:16:53 <kuribas> It does do normalisation inside lambdas, which is neat.
03:23:14 <ski> eta ?
03:24:07 <ski> how does it do equality proofs ? combinators for `refl',`symm',`trans',`congr',`subst' ?
03:25:29 <kuribas> ski: refl is (same n), subst is replace, trans in trans, congr is cong
03:26:14 <kuribas> so (same Nat 2) is a (= Nat (+ 1 1) 2)
03:26:47 <kuribas> ski: https://docs.racket-lang.org/pie/index.html
03:27:20 <kuribas> ski see https://docs.racket-lang.org/pie/index.html#%28part._.Equality%29
03:27:29 <kuribas> ah it's (same 2), not (same Nat 2)
03:37:27 <cheater> is there a good function for repeating m Bool until it's False?
03:39:47 <yushyin> maybe Control.Monad.Loops.whileM and variants?
03:40:34 <cheater> tbh i'm looking for stdlib
03:41:35 <ski> kuribas : yea, i see
03:41:49 <Jinna> Using the `streaming` lib... Can I use this to filter time-series data? For example: I see a fresh timestamp and want to ignore all following timestamps that are not more than 3 seconds younger.
03:41:54 <ski> i've been pondering for some while now, how to make equality proofs more user-friendly
03:42:20 <Jinna> That would require some state, where I remember a “good” timestamp, while streaming.
04:09:44 <cheater> is it possible to pattern match a record on the left side of a <-? doing Foo {x, y, z} <- doBar doesn't work.
04:11:05 <maerwald> new-test doesn't show any output despite --jobs=1, anyone remembers how to force it?
04:14:35 <ski> cheater : forgot to turn on `NamedFieldPuns' ?
04:23:44 <dminuoso> cheater: For `stdlib` you could just copy the implementation of whileM
04:24:17 <dminuoso> cheater: https://gist.github.com/dminuoso/1f771753dccc430850f1a20904dc001b
04:25:35 <Jinna> dminuoso: is that preferrable over takeWhile?
04:25:59 <dminuoso> Jinna: It's different.
04:26:19 <dminuoso> Jinna: whileM' is a generalization of `while` in other languages.
04:26:43 <yushyin> monad-loops is a very small package and no dependencies besides base. I would just use it.
04:27:42 <dminuoso> Jinna: Imagine you wanted to do something like `while(f()) { f = fetch(); doThings(f) }` as you might do in a language like python.
04:27:58 <yushyin> there is a takeWhileM in Control.
04:28:07 <yushyin> +Monad.Loops
04:33:29 <Jinna> Basically I have pairs of a text and a timestamp.   ("abc", 10)   ("abc", 20)  and so on. I want to produce a frequencies list of how often each text, such as "abc" or "xyz" occurred, but ignoring when the sensors fired off too much within three seconds.
04:34:01 <Jinna> ("abc", 10),  ("abc", 12),  ("abc", 20),  ("xyz", 7)   =>    {"abc": 2,  "xyz": 1}
04:34:19 <Jinna> Because the 12 does not count, as it is within a 3-second range to the ("abc", 10).
04:50:42 <clever> Jinna: one idea i just had, is to first transform it into a Map, so "abc" is the key, and [ 10, 12, 20 ] is the value
04:51:40 <clever> Jinna: then you could have a recursive function in the form of `f first:second:rest = ...` that will check the first 2 items, and then do something with them, and then call itself with either `f rest` or `f second:rest` to skip the 2nd element
04:51:55 <clever> Jinna: and then normal recursion logic, append first to an accumulator thats also passed to f
05:07:20 <Jonathan86> Anyone around to give me a little advice on solving a problem in a Haskell way?
05:07:52 <Jonathan86> ...Are people on at this time in the morning?
05:08:12 <infinisil> There are people from all around the world here :)
05:08:26 <Jonathan86> Right...
05:08:44 <hexagoxel> it's always morning on irc
05:12:58 <Jonathan86> I have a game with networked clients.  The way the client protocol works they send some messages to the server to "subscribe" to a set of messages.  Currently I have each client on its own thread and it passes it's message chan to the logic thread when a "subscribe" message comes in.  The logic thread keeps a list of "subscribers".  How do I "unsub
05:12:58 <Jonathan86> scribe" when the client disconnects?
05:13:55 <Jonathan86> The client's thread is blocked reading from its message channel so it has no chance to check for a disconnect.
05:14:56 <kuribas> ski: couldn't you detect functions (like +, <), reformat the type as a SMT formula, and use the prover?
05:15:02 <hpc> when clients disconnect, do they send an "i am going away now" message?
05:15:42 <hpc> you probably want your protocol to have that, as well as "i am still here but nothing is happening"
05:15:54 <Jonathan86> No, especially not when it is a network forced disconnect.
05:15:57 <hpc> like irc's ping/pong if you are familiar with that
05:16:30 <Jonathan86> Okay.
05:16:34 <kuribas> ski: for example in Pie (+ a b) will reduce to (iter-Nat a (the Nat b) (λ (x) (add1 x)))
05:16:38 <hpc> then decide how frequently to send them, and if you don't get a ping/pong within some slightly longer time period handle the disconnect server-side
05:16:43 <kuribas> ski: so you can use that for +
05:17:34 <hpc> then for how to handle disconnecting, you remove the message chan from whatever data structure you're using, and kill the thread controlling the connection
05:17:59 <Jonathan86> Should I have 2 threads on the server for each client?  One sending reading from the messages from the server logic and one reading messages from the client over the network?
05:19:34 <hpc> maybe, but i would start with something simpler first
05:20:19 <Jonathan86> Reading messages from the chan blocks as well as reading messages from the network though?
05:21:27 <hexagoxel> don't you get an exception when reading on a socket that gets closed?
05:21:41 <hexagoxel> so you readLoop `finally` unsubscribe
05:21:47 <Jonathan86> I think so, yes.
05:22:18 <hexagoxel> that is, clientProcessLoop `finally` unsubscribeThisClient
05:23:15 <Jonathan86> I guess I need two threads though anyway for incoming and for outgoing messages, I just reuse the incoming thread for disconnects then?
05:24:08 <Jonathan86> Or, are you suggesting a better way to handle the two-way stream.
05:26:33 <infinisil> Well there are libraries like pipes or conduit that give a very nice way to work with bidirectional streams
05:27:00 <hexagoxel> you can just send from your main logic thread.
05:28:19 <hexagoxel> if you wrap it in an appropriate "catch" to prevent a disconnecting client from dragging the logic loop with it before the unsubscribe has reached the logic loop.
05:28:46 <Jonathan86> infinisil: I will look at those libraries thanks!
05:29:22 <Jonathan86> Hum, yesterday I was advised to put sending on the client thread because `send` can block.
05:32:09 <hexagoxel> then fork and send. don't need to maintain a separate sending thread per channel.
05:32:18 <hexagoxel> moooar threads
05:32:35 <hexagoxel> s/per channel/per socket/
05:33:03 <hexagoxel> or does that garble messages?
05:33:13 <Jonathan86> hexagoxel: Well that is a concept I never considered!  Them haskell's green threads... 
05:33:23 <Jonathan86> Could that rearrange messages?
05:33:52 <hexagoxel> yeah i dunno about that. might need a sending thread after all.
05:35:38 <Jonathan86> Okay, thanks for your advice! and help!  I have gotten a little logical lead.  I will poke around and see what I glean.  I really appreciate the guidance on how you Haskellers think (:
05:36:09 <dminuoso> Jonathan86: Having multiple TChans/TQueues and threads sinking/sourcing from them can also be an adequate technique.
05:37:21 <Jonathan86> dminuoso: Like this `TQueue`?  https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TQueue.html
05:37:58 <fragamus> hi is it possible to get an ADT object at retrieve its constructor name as a string
05:38:32 <hexagoxel> if you manage to also implement a clean server-side shutdown mechanism for the whole thing, please tell me. I had a websocket app where I tried that, but it still managed to not properly shut down certain sockets from time to time.
05:39:09 <fragamus> without writing code by hand to run through all of the constructors
05:40:04 <Jonathan86> hexagoxel:  Okay, it will probably be another day when I finally get it working,  just ping you here?
05:40:18 <hexagoxel> sure
05:40:29 <dminuoso> fragamus: Generics I guess?
05:41:12 <dminuoso> Or possibly
05:41:14 <dminuoso> % :t toConstr
05:41:15 <yahb> dminuoso: Data a => a -> Constr
05:41:29 <dminuoso> Yeah I think that's what you are asking for.
05:41:48 <dminuoso> % (show . toConstr) (Left 10)
05:41:49 <yahb> dminuoso: ; <interactive>:18:9: error:; * Ambiguous type variable `b0' arising from a use of `toConstr'; prevents the constraint `(Data b0)' from being solved.; Probable fix: use a type annotation to specify what `b0' should be.; These potential instances exist:; instance Data a => Data (Complex a) -- Defined in `Data.Complex'; instance (Data a, Data b) => Data (Either a b) --
05:41:49 <fragamus> dminuoso: ooh nice
05:41:55 <dminuoso> % (show . toConstr) (Left ())
05:41:56 <yahb> dminuoso: ; <interactive>:19:9: error:; * Ambiguous type variable `b0' arising from a use of `toConstr'; prevents the constraint `(Data b0)' from being solved.; Probable fix: use a type annotation to specify what `b0' should be.; These potential instances exist:; instance Data a => Data (Complex a) -- Defined in `Data.Complex'; instance (Data a, Data b) => Data (Either a b) --
05:42:16 <dminuoso> Well. You know, assume it does the right thing.
05:42:29 <hexagoxel> % (show . toConstr) (Just ())
05:42:30 <yahb> hexagoxel: "Just"
05:42:55 <hexagoxel> % (showConstr . toConstr) (Just ())
05:42:56 <yahb> hexagoxel: "Just"
05:43:19 <dminuoso> Oh that's a bit neater.
05:43:37 <fragamus> i love it
05:57:50 <cheater> dminuoso: thanks
05:58:13 <cheater> ski: hm maybe, thanks
06:25:21 <fragamus> :t _Ctor
06:25:27 <lambdabot> error:
06:25:27 <lambdabot>     • Found hole: _Ctor :: t
06:25:27 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
06:30:05 <fragamus> :t (^?)
06:30:08 <lambdabot> s -> Getting (First a) s a -> Maybe a
06:31:14 <ski> kuribas : well, i was more interested in how to actually spell out the equality proofs, but in a more userfriendly fashion
06:32:41 <kuribas> ski: what's not user friendly about them?
06:32:44 <kuribas> ski: the names?
06:33:06 <kuribas> ski: well same is friendlier than refl :)
06:33:27 <kuribas> I like symm and trans since that's what they are
06:34:46 <ski> kuribas : `(trans foo (trans bar (trans baz (trans quuz))))' is not usefriendly .. though i suppose `trans' in Pie can actually take multiple operands
06:34:59 <fragamus> :t toConstr
06:35:01 <lambdabot> Data a => a -> Constr
06:35:03 <kuribas> ski: no Pie is curried
06:35:23 <ski> however, `cong' isn't very userfriendly, either
06:36:21 <ski> my experimental syntax implicitly performs `refl',`trans' and `cong' (including multiple operand `cong') for you
06:37:12 <ski> (i have two versions. one of them displays the types (the equalities), in a format looking pretty close to traditional informal proofs)
06:44:20 <ski> kuribas : what do you mean by "Pie is curried" ?
06:44:38 <kuribas> ski: yeah, that's probably not relevant
06:44:42 <kuribas> ski: like in haskell
06:44:56 <ski> Haskell is not "curried"
06:45:09 <kuribas> functions are 
06:45:12 <ski> no
06:45:25 <ski> currying exists in your head, not in the language
06:45:40 <dminuoso> % :t curry
06:45:40 <yahb> dminuoso: ((a, b) -> c) -> a -> b -> c
06:45:59 <ski> currying is a way to represent/encode a multiple-argument function, in terms of only single-argument functions
06:46:07 <kuribas> I man (+ a b) == ((+ a) b)
06:46:14 <kuribas> which does exist in the language
06:46:19 <ski> "tupling" is another way to do the same thing
06:46:33 <ski> all functions in Haskell takes exactly one argument
06:46:37 <dminuoso> kuribas: add :: Num a => (a, a) -> a
06:46:39 <u-ou> I want ski to write a book on Haskell :(
06:46:42 <dminuoso> kuribas: This is uncurried.
06:46:51 <kuribas> and (lambda (a b c) ...) is the same as (lambda (a) (lambda (b) (lambda (c) ...)))
06:47:13 <kuribas> which is true of haskell but not say scheme
06:47:20 <dminuoso> kuribas: In Haskell `f (a,b,c) = ...` is not the same as `f a b c = ...`
06:47:34 <ski> `curry' is a function for converting a (two-argument) function, represented in tupled style, into a curried style representation
06:47:37 <dminuoso> It's just that "curried-style" functions have less syntax noise to create.
06:47:53 <dminuoso> You can have uncurried functions just fine too in Haskell.
06:47:54 <kuribas> dminuoso: fine, call it curried-style then.
06:48:03 <kuribas> dminuoso: sure
06:48:08 <ski> Haskell *does* have syntax that encourages using curried style, when encoding multiple-argument functions in it
06:48:10 <dminuoso> kuribas: My point is, its not functions that are curried, it's *specific* functions that may be.
06:48:17 <dminuoso> e.g. `fmap` is curried
06:48:18 <ski> but functions in Haskell are not "curried"
06:48:34 <dminuoso> % fmap' = uncurry fmap
06:48:35 <yahb> dminuoso: 
06:48:38 <dminuoso> % :t fmap'
06:48:38 <yahb> dminuoso: Functor f => (a -> b, f a) -> f b
06:48:45 <tdammers> IMO it's best to operate under the paradigm that all Haskell functions are unary
06:49:07 <tdammers> the next closest thing to an n-ary function in Haskell is a function whose argument is a tuple
06:49:18 <ski> when we say that some particular Haskell function "is curried", that is really short for "we have some multiple-argument function in mind, and we've *encoded* it, using curried style, into Haskell"
06:49:25 <dminuoso> ski: I was really baffled when I learned that the definition of an exponential object involves a morphism sometimes called "transpose", which essentially incorporates currying.
06:49:36 <dminuoso> It seems that the notion of currying is so deeply related to exponentials.
06:49:51 <dminuoso> That was a wonderful revelation. :)
06:50:00 <ski> it's not a property of the function (in Haskell) itself, but a property of the particular way you've decided to encode the multiple-argument function, inside Haskell
06:50:11 <ski> dminuoso : yes
06:50:42 <fragamus> dminuoso: hi thanks for the help earlier
06:50:53 <tdammers> you could also say that because all Haskell functions are unary, you cannot express n-ary functions in Haskell, so you have to curry them first
06:50:55 <ski> kuribas : otoh, Scheme *does* have real multiple-argument functions^Wprocedures. but you can of course also use curried, and tupled, style in it
06:51:08 <tdammers> (or tuple up the arguments)
06:51:19 <ski> kuribas : in Scheme, `(f x y)' is not the same as `((f x) y) -- but apprently that's the case in Pie, then ?
06:51:44 <ski> u-ou : hm ?
06:51:53 <dminuoso> tdammers: But is `f :: (a, b) -> c` not a 2 argument function? It guess it depends on how you view it.
06:52:20 <u-ou> nothin
06:52:21 <ski> (in Scheme, `(lambda (a b c) ...)' is not the same as `(lambda (a) (lambda (b) (lambda (c) ...)))' .. but it may be in Pie)
06:53:04 <dminuoso> Fun fact, in Haskell `f x y z = ...` is not the same as `f = \x -> \y -> \z -> ...` either..
06:53:08 <sarahzrf> mm, pie
06:53:13 <sarahzrf> dminuoso: ugh, don't remind me
06:53:32 <ski> dminuoso : depends :)
06:53:47 <dminuoso> ski: Not in general, I mean. :)
06:53:54 <ggole> Really? What's the difference?
06:54:04 <kuribas> sarahzrf: the little typer is full of food :)
06:54:08 <kuribas> hence "Pie"
06:54:22 <kuribas> ski: yes
06:54:23 <fragamus> I have this   a ^? _Ctor @"Module"    but I want to replace @"Module" with   whatever the constructor of a
06:55:00 <fragamus> its generic lens
06:55:16 <ski> dminuoso : `f :: (a, b) -> c' is the signature of a one-argument function
06:55:18 <dminuoso> % let f (!x) y = 1 in seq (f undefined) ()
06:55:18 <yahb> dminuoso: ()
06:55:22 <dminuoso> % let g = \(!x) -> \y -> 1 in seq (f undefined) ()
06:55:22 <yahb> dminuoso: ; <interactive>:26:34: error: Variable not in scope: f :: t0 -> a0
06:55:30 <dminuoso> % let f (!x) y = 1 in seq (g undefined) ()
06:55:31 <yahb> dminuoso: ; <interactive>:27:26: error: Variable not in scope: g :: t0 -> a0
06:55:34 <dminuoso> Oh gah
06:55:39 <dminuoso> % let g = \(!x) -> \y -> 1 in seq (g undefined) ()
06:55:39 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:28:36 in interactive:Ghci12
06:55:45 <dminuoso> Miscopy I apologize.
06:56:20 <sarahzrf> kuribas: she's been eating?
06:56:20 <dminuoso> ski: I guess it could be argued that the notion of "multiple argument function" does not really exist.
06:56:46 <ski> dminuoso : in some languages, it does. C,Java,Scheme,...
06:56:48 <dminuoso> ski: In our heads we just pretend that a function from the product of two domains is called a "two argument function"
06:57:27 <ski> "multiple argument function" is closely related to "expression which may depend on multiple free variables"
06:57:28 <kuribas> ski: I think of multiple arguments as lists
06:57:47 <kuribas> ski: so scheme has a unary function which always takes a list
06:57:50 <ski> kuribas : you don't write `(+ (list 2 3 5 7))' in Scheme
06:58:00 <ski> `(apply + (list 2 3 5 7))' is another thing
06:58:01 <kuribas> ski: because that's done implicitly
06:58:34 <kuribas> ski: the arguments are wrapped in a list by scheme before passing them on
06:58:35 <ski> `apply', and `(lambda args ..args..)' are ways to convert between multiple arguments, and a list of them
06:58:54 <dminuoso> ski: But isn't `int f(double, char);` just semantically f accepting a tuple of two arguments? In fact the syntax there is even hinting at it.
06:58:55 <ski> i don't care what an implementation does under the covers
06:58:57 <dminuoso> f (2, 'c')
06:59:07 <ski> i'm talking about reasoning on the surface level of the language
06:59:11 <kuribas> ski: so am I
06:59:24 <dminuoso> ggole: ^- did you see the example?
07:00:02 <ggole> I see, thank you.
07:00:07 <ski> dminuoso : that "semantically" includes an encoding/decoding step. you can't, at least not easily, have an "argument list" object that you can invoke a function with
07:00:55 <ski> in Haskell, you can say `foo (bar x)', where `x :: Int',`bar :: Int -> (Int,Int)',`foo :: (Int,Int) -> Int'
07:00:56 <dminuoso> ski: Ah because you couldn't do something along the lines of `auto c = (2, 'c'); f(c);` ?
07:01:03 <ski> this shows that `foo' is not a two-argument function
07:01:08 <ski> dminuoso : right
07:01:23 <ski> cf. with the case with `apply' in Scheme
07:01:41 <dminuoso> ski: In that sense currying/uncurrying does not exist at all in Haskell now does it?
07:01:50 <ski> kuribas : i see no argument list in `(f x y)'
07:02:01 <dminuoso> Because the notion of multiple argument functions is not part of our type system.
07:02:02 <ski> dminuoso : exactly. it's all in your head
07:02:30 <kuribas> ski: yes, it's (x y)
07:02:45 <ski> it's a part of how you represent/encoding "multiple-argument functions", in the language
07:03:07 <ski> kuribas : `(x y)' is not, syntactically speaking, a subphrase of `(f x y)'
07:03:49 <kuribas> ski: syntax is syntax.  I am speaking about the semantics
07:04:12 <kuribas> ski: semantically calling (f x y), is calling f with (list x y)
07:04:19 <dmwit> > seq ((\(!x) y -> ()) undefined) ()
07:04:21 <lambdabot>  ()
07:04:26 <ski> kuribas : and if you're thinking about the SExpr representation of programs (which Scheme doesn't mandate), iow thinking of `(f x y)' as `(f . (x y))', then you still can't have that `(x y)' being computed by a single expression
07:04:26 <dmwit> neat
07:04:57 <kuribas> ski: you can, using apply
07:05:01 <ski> kuribas : that "semantically" includes talking about encoding/representation, or about what an implementation may or may not do
07:05:51 <ski> an implementation is not required to call `list', or even construct list objects, when invoking multiple-argument functions, even in the general case (iow barring optimizations)
07:05:56 <dminuoso> ski: otoh I might want to ask "what does currying even mean"
07:05:57 <kuribas> ski: I am not speaking about an implementation, I am speaking about a model of function application in scheme, and I find this the simplest model.
07:06:07 <kuribas> ski: I am not saying other models cannot exist.
07:06:11 <ski> okay
07:06:23 <dminuoso> ski: And it might turn out that the only way to talk about currying is by defining an exponential, which requires defining a categorical product. At that point `curry/uncurry` are perfectly justified again.
07:06:47 <dminuoso> (If you excuse my handwaving shortcut I took, instead of rigorously laying it out with a diagram)
07:06:52 <ski> kuribas : if you intend to explain `(f x y)' in terms of `(list x y)', then how do you explain `(list x y)' ?
07:07:05 <ski> kuribas : circularly, in terms of `(list x y)' ?
07:07:33 <kuribas> ski: I am not explaining scheme in terms of itself
07:07:49 <ski> dminuoso : <https://en.wikipedia.org/wiki/Multicategories>
07:07:59 <dminuoso> ski: Ohh this is exciting!
07:08:03 <kuribas> although you could implement scheme in scheme, and use lists for arguments.
07:08:10 <dminuoso> ski: It seems that category theorists have thought of everything. :)
07:08:34 <ski> kuribas : ok, so that `(list x y)' there is not Scheme then, but some artefact about your semantic model. that's fine
07:08:46 <kuribas> yes
07:09:19 <ski> (be the model meta-circular or not, that doesn't matter)
07:18:04 <tempeh> I'm looking for a comparison of the streaming library options, anyone know a good article?
07:20:06 <davean> go cba
07:45:58 <dmwit> ski: How rude. They've generalized the input to be a sequence of objects, but not the output.
07:47:18 <kuribas> dmwit: scheme?
07:47:29 <kuribas> scheme can output multiple values
07:48:24 <kuribas> in scheme the output is a continuation which takes arguments like a function
07:48:25 <hyperisco> I have several types, call them T1, T2, … Tn, and then a sum of all T's, call it S, so S1 :: T1 -> S, S2 :: T2 -> S, ... Sn :: Tn -> S
07:48:36 <hyperisco> I have several functions  Ti -> Tj
07:48:48 <hyperisco> I want to map  Ti -> Tj  to  S -> S
07:49:21 <hyperisco> that doesn't work, so I want to map to, say,  S -> Maybe S
07:49:32 <dmwit> (Why doesn't that work?)
07:49:40 <hyperisco> Ti -> Tj  is not total on  S
07:50:00 <dmwit> You could make it total by e.g. making it the "identity" on Tk for k/=i.
07:50:17 <hyperisco> but anyways, the only way I can figure to do this conveniently is to define an overloaded function by class
07:51:02 <jgt> hooray! My wai-extra PR was merged!
07:51:09 <hyperisco> I don't want to do the footwork at each use site to apply Sj to Tj and to case Si to get Ti
07:52:11 <dmwit> Typeable can probably get you where you need to go with less than n^2 work.
07:52:30 <dmwit> You probably don't even need a new typeclass.
07:53:24 <dmwit> (The new reflection-capable version of Typeable, anyway.)
07:54:02 <higherorder> Hello! When using type families as "smart constructors", is there a way to force them to reduce asap so the type errors occur when the type family is used, and not at some point down the line?
07:54:07 <hyperisco> Well, the contravariant side could be a prism
07:55:18 <ski> dmwit : who ?
08:01:28 <dmwit> hyperisco: https://gist.github.com/dmwit/eddd0ff330fdec670857657c70e2599e
08:01:45 <hyperisco> hm
08:02:04 <Shoubit> Is there a type similar to `App :: (Type -> Type) -> Type -> Type` so that I can have a `Plus` instance for `Identity` – `Plus f => F Identity f`?
08:02:31 <dmwit> hyperisco: So merely O(n) work should be possible. =)
08:02:58 <dmwit> ski: The creators of multicategories.
08:03:23 <dmwit> (Easily automated work at that.)
08:03:27 <ski> ah
08:03:50 <Lycurgus> multicategory
08:04:25 <ski> now i'm reminded of a book called "Multiple-conclusion logic", in which they consider inference systems where an inference rule may have multiple conclusions. so we get a graph instead of a tree
08:04:29 <dmwit> hyperisco: Of course, you could just use Dynamic, in which case it's O(1) work, but you don't get the constraint that it's in your carefully curated, small set of types.
08:05:08 <Lycurgus> there's more than one name for that, defeasible, non monotonic, etc
08:05:47 <ski> i don't think the logical systems considered in that book are non-monotonic
08:06:46 <Lycurgus> not to mention the fully continuous fuzzy case
08:07:27 <ski> (also see <https://en.wikipedia.org/wiki/Operad_theory>)
08:08:00 <ski> Lycurgus : elaborate ?
08:08:10 <Lycurgus> on what?
08:08:15 <dmwit> hyperisco: If you're willing to change the definition of S you can probably do better still.
08:08:25 <Lycurgus> ensembles floues?
08:08:32 <Lycurgus> (or however it's spelled)
08:08:38 <hyperisco> I'm weighing this
08:08:44 <ski> Lycurgus : whatever you were commenting on just before ? :)
08:09:01 <Lycurgus> oh, non classical/binary logics
08:09:29 <ski> e.g., i was wondering what you meant by "multicategory", there
08:09:56 <Lycurgus> oh when something seems noteworthy i sometimes just repeat it
08:10:04 <ski> i see
08:10:14 <Lycurgus> haven't a clue what that might be and it sounds like a bogosity
08:10:31 <Lycurgus> or some over the top abstraction
08:10:42 <hyperisco> Another aspect is that if  f :: A -> B  and  g :: A -> B  then  f = g  which is "compact"?
08:10:51 <Lycurgus> s/over the top/superfluous/
08:10:54 <ski> i've run across defeasible, default, and non-monotonic reasoning before, and also fuzzy logic. but i don't know that much about these topics
08:11:15 <Lycurgus> fuzzy is the one I'm most familiar with
08:11:31 <hyperisco> So, there is a unique way to get from A to B, and it would be nice to not have to do the footwork to explain how every time
08:11:38 <Lycurgus> it may be the most developed too but it's out of fashion
08:12:09 <Lycurgus> and as much as you might like i don't think there's a pl pkg
08:12:28 <Lycurgus> i.e. one that you could find without an arduous search
08:12:58 <ski> Lycurgus : "Multicategory" is related to Category Theory. the latter can be seen as an abstract theory of "(single-argument) functions" (though they don't need to resemble functions at *all*) and compositions thereof (though one can simulate multiple-arguments, via product objects, like passing tuples). Multicategories then correspond to multiple-argument functions
08:13:18 <Lycurgus> ah
08:13:37 <ski> hyperisco : compact, huh ?
08:13:42 <Lycurgus> but that's not just currying is it
08:13:53 <hyperisco> I dunno, I have to get out my CT book again
08:15:04 <ski> Lycurgus : my vague feeling is that bayesian reasoning may often be more appropriate than fuzzy reasoning. but perhaps they cater to different use cases
08:15:23 <Lycurgus> they're different
08:15:23 <hyperisco> ski, or is that what they call "commutes"
08:15:25 <hyperisco> some c-word I am sure
08:15:29 <Lycurgus> fuzzy is more radical
08:15:52 <ski> Lycurgus : it's related to currying, sure. but note that the morphisms you deal with in CT doesn't have to be functions at all
08:16:02 <ski> hyperisco : hmm .. contractible ?
08:16:08 <Lycurgus> but yeah there's a probability fuzzy relation
08:16:22 <Lycurgus> ah
08:16:33 <ski> Lycurgus : yes, of course they're different. the question is more whether, or to which extent, they try to address the same kind of problems and situations
08:16:55 <hyperisco> ski, no pretty sure I just described commutativity, now that I read on it
08:17:13 <ski> hyperisco : as in "commutative diagram". ok
08:17:21 <hyperisco> yes
08:17:46 <Jinna> In postgresql-simple: how can I specify a parameter `where id in (10, 20, 30)` so that I can have my query `where id in ?`, and have pg-simple do the correct escaping? Do I need my own type to do that or is there something built in?
08:17:53 <dminuoso> Shoubit: Can you elaborate?
08:17:54 <Lycurgus> they definitely have a healthy intersection of applications, but they're quite different
08:17:56 <hyperisco> In graphs we'd say "strongly connected" if for all two objects A B there was a directed path from A to B
08:18:01 <hyperisco> not sure what that is in a category
08:18:11 <ski> Lycurgus : ty
08:18:22 <Lycurgus> and I would say the bayesian was a subset of the fuzzy applications
08:18:41 <dminuoso> Jinna: Is Database.PostgreSQL.Simple.SqlQQ what you are looking for?
08:18:53 <hyperisco> But, if it is commutative and is strongly connected, then you can just say where you want to go and regardless of where you are there is a unique way (up to "same result") to get there
08:19:08 <Jinna> dminuoso: I’ll have a look.
08:19:43 <hyperisco> Which is appealing for the sorts of state transitions I have here
08:20:12 <Jinna> Nah, this one I already am using. I would like to specify a `?` and give a list as parameter. And I want this list `[10, 20, 30] to be rendered as `(10, 20, 30)` in my query String. So that the PG `in` operation will work correctly.
08:20:50 <asymptotically> Jinna: i dont think you can use binded queries/prepared statements with PostgreSQL.Simple
08:20:54 <dminuoso> Jinna: Ah I see.
08:22:16 <hyperisco> Apparently just called a connected category… so I have a commutative connected category… fun with adjectives
08:22:19 <asymptotically> Jinna: whoops sorry I was wrong. did you want something like this? https://www.stackage.org/haddock/nightly-2019-07-07/postgresql-simple-0.6.2/Database-PostgreSQL-Simple.html#g:6
08:22:42 <dminuoso> Jinna: https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple.html#t:In
08:23:28 <ski> hyperisco : hm, a category in which there's at most one morphism between any two given objects is called thin
08:23:32 <Jinna> Yes, that works. Thx!
08:23:57 <hyperisco> ski, how is a commutative category not thin?
08:24:01 <dminuoso> Jinna: Please take extra note of the haddock comments for that.
08:24:31 <ski> i don't know what you mean by "commutative category"
08:24:51 <hyperisco> "commutative diagram" then
08:26:29 <hyperisco> thin could not commute though
08:27:04 <hyperisco> I guess commuting is just thinness over composition?
08:34:09 <hyperisco> Hrm, damn, instance resolution isn't going to be able to fill in the path for me though! D:
08:37:59 <hyperisco> I just want the type system to find the shortest path between two types and arbitrate ties. Come on.
08:40:37 <hyperisco> instance (T a b, T b c) => T a b where t = t . t   is a problem D:
08:45:40 <Jinna> What are `State#` and `#State#` and `a#`?    https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Conc.html#t:STM
08:46:13 <hyperisco> Jinna, that is (# #) and State# and a#
08:46:22 <hyperisco> And # just means "unboxed"
08:46:30 <hyperisco> sorry lol
08:46:35 <hyperisco> (# #) and State# and  a
08:46:56 <dminuoso> Jinna: The details you should really not look at. :)
08:47:31 <hyperisco> read # as "gotta go fast"
08:47:47 <Jinna> Why is this then not the default?
08:47:56 <dminuoso> Jinna: What do you mean?
08:48:23 <dminuoso> Jinna: The implementation details of STM you can glance over, they won't help you with how to use stm.
08:48:58 <hyperisco> You don't want this as the default because unboxed values can only be used in highly restrictive ways
08:49:30 <dminuoso> Jinna: What you see there is essentially just trickery, there's no values involved.
08:49:45 <dminuoso> Jinna: At least not in the sense that are usable to you.
08:50:44 <dminuoso> Jinna: What you have there is basically a function `() -> ((), a)` *roughly*
08:51:29 <dminuoso> It's basically just an `a` with some additional bits that are related to implementation details.
08:51:36 <int-e> . o O ( The state token is a lie. )
08:51:39 <hyperisco> State# is phantom, so there is nothing there at runtime, and (# #) is a "gotta go fast" 2-tuple
08:51:52 * ski wouldn't say `()'
08:53:05 <hyperisco> A gotta go fast tuple doesn't bother to make an actual tuple structure and instead returns the values directly to the stack of the caller
08:53:27 <hyperisco> though that's best answered by someone who knows something about the runtime
08:54:22 <ski> @quote RealWorld#.token
08:54:22 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
08:54:37 <Jinna> I see.
08:54:53 <dminuoso> Jinna: It's very deep trickery that is unrelated to Haskell really, and only makes sense from a GHC perspective.
08:55:08 <hyperisco> That implementation is still a bit trippy to me. I don't necessarily like my programs having to do with physics.
08:55:11 <dminuoso> Jinna: IO is also just `newtype IO = IO (State# RealWorld -> (#State# RealWorld, a#))`
08:55:24 <dminuoso> Jinna: But that notion will help you not at all when learning IO.
08:55:32 <Taneb> hyperisco: all programs do eventually
08:55:32 <dminuoso> It's just relevant if you want to learn how GHC implements IO
08:55:46 <hyperisco> Taneb, only to run them though :P
08:55:55 <MatthiasGoergens> IO should be learned just as you learn about Maybe and Lists and Numbers and Booleans: on its own.
08:56:03 <MatthiasGoergens> Later on, you can generalize some of these.
08:56:16 <ski> you can roughly think of `IO' as `State (State# RealWorld)' .. however, that doesn't account for e.g. forking of threads. so it's an incomplete, inaccurate model
08:56:29 <Jinna> I just thought that it might be interesting to use those hashed types myself.
08:57:06 <dminuoso> Jinna: The "hash" is just part of the name.
08:57:07 <dminuoso> Jinna: Like ' in foo'
08:57:08 <dminuoso> Jinna: It was conventionally chosen for unboxed types.
08:57:18 <MatthiasGoergens> The language Clean had the RealWorld object passed through explicitly.
08:57:19 <ski> dminuoso : i think it did help me, to some extent. but one should realize that it's at best a figure of speech, an analogy, a parable, a fairy tale, that has some grain of truth, but is inadequate for a more full understanding
08:57:52 <ski> MatthiasGoergens : called just `World', there. but they could also decompose it into independent subsystems, i think
08:57:55 <dminuoso> ski: Oh fair enough, I ought to generalize less.
08:58:19 <MatthiasGoergens> Yeah, it's been a while since I dabbled in Clean.
08:58:44 <dminuoso> Jinna: So while you have ⌜Int :: *⌝ you used to have ⌜Int# :: #⌝
08:58:44 <MatthiasGoergens> The decomposition is handy.  One of the few benefits over just always using the monadic interface instead.
08:58:55 <Jinna> So the # has no meaning, it is just a convention. People just use it, to hint something to the reader of the code.
08:59:07 <ski> MatthiasGoergens : Mercury also has this `io.state' passing around
08:59:28 <hyperisco> Jinna, it does have meaning. As I said, it means "unboxed", which has implications for how you can use the value.
08:59:28 <dminuoso> Jinna: Things have become more complicated because the kind system has evolved, but we could pretend it was still the case.
08:59:28 <dminuoso> Jinna: Right, it's a hint that the type likely is of kind ⌜#⌝ (assuming we still had that kind)
08:59:54 <dminuoso> % :set -XMagicHash
08:59:54 <yahb> dminuoso: 
09:00:03 <dminuoso> % newtype Foo# = Foo Int
09:00:03 <yahb> dminuoso: 
09:00:21 <ski> MatthiasGoergens : abstaining from the monadic interface also allows less over-sequentializing (but cf. `Control.Monad.ST.Lazy')
09:00:39 <dminuoso> Jinna: More generally # is chosen for primitive things.
09:00:43 <MatthiasGoergens> Yes.  Though haxl's applicative-do does that as well.
09:00:58 <ski> (and `unsafeInterleaveST' .. which is much more unsafe than `unsafeInterleaveIO' ever was)
09:01:01 <dminuoso> Jinna: So a ⌜#⌝ generally indicates you are holding some primitive thing in your hand, fsvo primitive.
09:01:24 <dminuoso> Jinna: Which is why http://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html is plastered with hashes.
09:02:10 <dminuoso> Jinna: In standard haskell # is not allowed for identifiers of values and types, so I guess that's part of the justification.
09:02:28 <Jinna> okay
09:03:05 <ski> Jinna : roughly, a type of kind `#' is an "unboxed type", a type whose values won't use a boxed representation, which doesn't include bottom
09:03:15 <dminuoso> I can recall at least one boxed but unlifted type with a ⌜#⌝ exist in GHC somewhere.
09:03:40 <ski> (yes, it's more complicated now than what it used to be)
09:04:19 <dminuoso> All unboxed types are unlifted, but not all unlifted types are unboxed. :)
09:06:03 <dminuoso> Jinna: The reason for # involved in STM/IO is unrelated to the motivation of unboxed things though.
09:06:13 <dminuoso> Jinna: IO/STM are deeply magical. :)
09:06:25 * ski . o O ( `ST' )
09:07:01 <dminuoso> Jinna: In short: In case of IO/STM it exists to avoid paying a penalty for a type machinery trick.
09:07:09 <Jinna> What is a lifted type?
09:07:19 <int-e> well, STM too... it's isomorphic to IO.
09:07:20 <dminuoso> Jinna: A lifted type is one that has bottom as an inhabitant.
09:07:23 <ski> one whose values include bottom
09:07:34 <int-e> (but with different semantics. fun.)
09:08:02 <ski> @remember int-e The state token is a lie.
09:08:03 <lambdabot> Done.
09:08:17 <dminuoso> ski: How do you recall specific quotes from lambdabot?
09:08:25 <hyperisco> ski, I'd double check lambdabot actually remembered that
09:08:32 <ski> @quote is.a.lie
09:08:32 <lambdabot> Twey says: <idnar> O(1) is a lie anyway <Twey> I just can't stand the constant lies!
09:08:33 <int-e> @quote token.is
09:08:33 <lambdabot> int-e says: The state token is a lie.
09:08:44 <int-e> @quote token
09:08:45 <lambdabot> napping says: I hear some Ethereum token things got hacked. The biggest bug bounty program in the world continues to pay out.
09:08:52 <hyperisco> Not all states are a lie then :P
09:08:53 <dminuoso> Ah, so it just searches for the best match?
09:08:58 <int-e> Now I have regrets.
09:09:06 <dminuoso> Can you attach tags/titles/keywords to quotes to make them easier to recall?
09:09:08 <hyperisco> dminuoso, it is random
09:09:16 <dminuoso> hyperisco: Ah. 
09:09:22 <hyperisco> Choose an unlikely word…
09:09:27 <hyperisco> @quote medfly>
09:09:27 <lambdabot> No quotes match. I am sorry.
09:09:35 <hyperisco> What a shame… and haven't seen medfly in over a year.
09:09:58 <ski> @quote separation
09:09:58 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
09:09:58 <lambdabot> state.
09:10:01 <int-e> @quote medfly
09:10:01 <lambdabot> medfly says: it's awesome not to be an expert here. you ask questions that you think are difficult and they are so easy to others that they are all excited to explain it to you.
09:10:12 <ski> @quote church.and.state!
09:10:12 <lambdabot> shapr says: Haskell separates Church and state!
09:10:18 <int-e> @quote >
09:10:18 <lambdabot> lament says: I never close <pedant> tags. I just nest them.
09:10:22 <ski> @quote rather.say
09:10:22 <lambdabot> ski says: I'd rather say that in Haskell, Church and State are dual
09:10:49 <ski> @palomer
09:10:49 <lambdabot> Hrmph, looks like I killed the channel
09:10:58 <int-e> lament, now that was a long time ago.
09:11:06 <ski> @keal
09:11:06 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
09:11:10 <hyperisco> Now to do the gauche thing
09:11:15 <hyperisco> @erisco
09:11:16 <lambdabot> Unknown command, try @list
09:11:23 <hyperisco> you primed me to get that wrong
09:11:28 <hyperisco> @quote erisco
09:11:28 <lambdabot> erisco says: programming typeless feels like navigating a room sightless
09:11:32 <ski> hyperisco : have you used Gauche ?
09:11:47 <hyperisco> I said that? wow what a clever cookie
09:12:18 <hyperisco> nope
09:20:23 <Jinna> I have a, b, c, d all  Maybe Text. I use `sequence [a, b, c, d]` to get a Maybe [Text]. Works. Now however I want a to be a Maybe Int. Is there still something like sequence that works, maybe on (,,,) instead of []?
09:21:12 <ski>   liftA4 (,,,) a b c d
09:22:46 <Jinna> Looks good.
09:25:07 <kuribas> each?
09:25:09 <kuribas> :t each
09:25:11 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
09:26:27 <kuribas> :t each id
09:26:29 <lambdabot> (Applicative f, Each s t (f b) b) => s -> f t
09:27:12 <kuribas> > each id (Just 1, Just 2, Just 3)
09:27:16 <lambdabot>  Just (1,2,3)
09:28:00 <shapr> ooh, I got quoted!
09:28:08 <shapr> but other people said that same thing long before I did
09:29:49 <Taneb> shapr: you're in a whole bunch of quotes in fact
09:30:59 <ski> % liftA4 (,,,) (Just (1 :: Int)) (Just ("b" :: Text)) (Just ("c" :: Text)) (Just ("d" :: Text))
09:31:00 <yahb> ski: Just (1,"b","c","d")
09:31:48 <ski> % :t each id (Just (1 :: Int),Just ("b" :: Text),Just ("c" :: Text),Just ("d" :: Text))
09:31:49 <yahb> ski: ; <interactive>:1:1: error:; * Couldn't match type `Int' with `Text' arising from a use of `each'; * In the expression: each id (Just (1 :: Int), Just ("b" :: Text), Just ("c" :: Text), Just ("d" :: Text))
09:35:09 <ski> @quote premature.initialization
09:35:09 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
09:35:17 <ski> bah!  an
09:36:00 <ski> some of the `@quote premature' entries are rather interesting
09:39:40 <tabaqui> % :t each
09:39:41 <yahb> tabaqui: (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
09:39:50 <tabaqui> % :i Each
09:39:53 <yahb> tabaqui: class Each s t a b | s -> a, t -> b, s b -> t, t a -> s where; each :: Traversal s t a b; default each :: (Traversable g, s ~ g a, t ~ g b) => Traversal s t a b; -- Defined in `Control.Lens.Each'; instance Each [a] [b] a b -- Defined in `Control.Lens.Each'; instance Each (Tree a) (Tree b) a b -- Defined in `Control.Lens.Each'; instance (a ~ Char, b ~ Char) => Each Text Text a b -- Defined in `Con
09:40:57 <tabaqui> % :t each id (1, 'a')
09:40:58 <yahb> tabaqui: ; <interactive>:1:1: error:; * Couldn't match type f b' with `Char' arising from a use of `each'; * In the expression: each id (1, 'a')
09:41:11 <tabaqui> % :t each (id :: forall a. a -> a) (1, 'a')
09:41:11 <yahb> tabaqui: ; <interactive>:1:1: error:; * Couldn't match type f b' with `Char' arising from a use of `each'; * In the expression: each (id :: forall a. a -> a) (1, 'a')
09:41:28 <jgt> cocreature: recently I said I'd send a PR to WAI which would add response headers for a custom log formatter. Here it is: https://github.com/yesodweb/wai/pull/762
09:42:53 <cocreature> jgt: nice!
09:53:00 <lavalike> jgt: missing a newline after return rspRcv *gasps*
10:07:49 <bbear> I'm having trouble to find where the 'name' attribute of an input field can be set up in django.
10:16:09 <dmwit> hyperisco: I think you're looking for thin, not connected.
10:16:20 <dmwit> ...oh, I see I was beat to it.
10:16:29 <hyperisco> orthogonal
10:16:38 <dmwit> "connected" says any two objects have at least one arrow. But they could have more.
10:16:46 <dmwit> "thin" says if there is an arrow at all, then it is unique.
10:16:52 <hyperisco> yes, both
10:17:12 <hyperisco> But as best I can tell, all commutative diagrams are thin
10:17:33 <dmwit> Diagrams are not categories, so "thin" is a type error for describing them.
10:17:46 <hyperisco> well, I don't know the difference
10:18:07 <hyperisco> As far as I can tell a diagram is just a way to notate a category
10:18:19 <dmwit> You don't know the difference between a category and a diagram? (Or is there some other two kinds of things you don't know the difference between?)
10:18:32 <hyperisco> the former
10:18:43 <dmwit> A diagram is a pictorial representation of a collection of equations.
10:19:07 <dmwit> For each pair of paths connecting two objects in a diagram, you get an equation saying that the composition of the arrows along those two paths are equal.
10:19:35 <dmwit> (On the left of the equation is the composition of the arrows along one path, on the right is the composition of arrows along the other path.)
10:19:51 <dmwit> Generally a diagram does not display the entire category. Just some objects and arrows of interest right now.
10:20:00 * ski . o O ( <https://en.wikipedia.org/wiki/Commutative_diagram#Diagrams_as_functors>,<https://en.wikipedia.org/wiki/Diagram_(category_theory)#Commutative_diagrams> )
10:20:48 <hyperisco> Okay, well, I still don't know what the difference is. If the diagram represents the whole category, and the diagram commutes, I don't see why it is then invalid to say the category commutes.
10:20:50 <dmwit> (And yes, the actual definition is via functors. But I think it's also good to have an intuition for how they're used/invented/thought about before diving into the technical details, because with the latter it can be hard to see the forest.)
10:21:45 <dmwit> hyperisco: 1. Generally a diagram does *not* represent the whole category. 2. We could surely define "commutes" to apply to categories in that way if we wanted, I just don't think it's common parlance.
10:22:12 <hyperisco> Okay, well this diagram does, and whatever the equivalent category jargon is is what I mean :P
10:23:35 <EvanR> so you're looking at the quiver of a category
10:23:39 <dmwit> A connected thin category is naturally isomorphic to the category with just one object and one arrow, so unless you are doing something Evil I think it's probably not a super interesting kind of category to consider.
10:24:04 <dmwit> er
10:24:14 <hyperisco> If thinness is defined on the closure of composition then sure, thin it is
10:25:13 <dmwit> er
10:25:33 <ski> a singular diagram is one which is non-injective
10:25:55 <dmwit> What do you mean by "defined on the closure of composition"?
10:26:24 <dmwit> Thinness is defined in basically the way you framed your original property: if f and g have the same type, then they're equal.
10:26:54 <hyperisco> How do you get to one object?
10:28:40 <dmwit> Let's call your thin, connected category C, and the category with one object and one arrow 1.
10:29:00 <dmwit> The functor F from C to 1 maps every object to the unique object of 1 and every arrow to the unique arrow of 1.
10:29:46 <dmwit> Then take any functor G from 1 to C (that is, pick any object and its identity arrow in C). Then FG and GF are both naturally isomorphic to the identity functor on the appropriate category.
10:30:58 <hyperisco> I don't understand that last part… if you don't end up with all the morphisms and objects of C then how is it isomorphic?
10:31:27 <dmwit> "naturally isomorphic" means the natural transformation picks out isomorphisms for every object.
10:31:38 <dmwit> Which... absolutely must hold, because in both categories all arrows are isomorphisms.
10:31:50 <hyperisco> Okay, I don't understand that then.
10:32:28 <dmwit> The intuition here is that there's no CT-based way to distinguish objects in C.
10:32:35 <dmwit> Because every object is isomorphic to every other one.
10:33:17 <wildtrees> would that be an equivalence class, from regular mathematics? 
10:33:29 <hyperisco> dmwit, Oh, yeah, that's fine then.
10:33:49 <dmwit> ...which means that if you find this a useful category, you are probably doing Evil.
10:34:05 <hyperisco> Mmmm… no :) The equivalence is also seen in how I am using it…
10:34:13 <hyperisco> It is the whole point =\
10:34:52 <hyperisco> It is all an elaborate way to do  State -> State
10:36:48 <hyperisco> That is interesting it comes out of the CT too though. Thanks dmwit
10:39:49 <EvanR> the thin connected category is naturally isomorphic to 1 theorem is a great example of category theory bringing you through many mental steps to arrive at something which ultimately seems trivial
10:40:23 <ski> hyperisco : for a more technical description of "evil", see <https://ncatlab.org/nlab/show/evil>
10:40:43 <hyperisco> Is there no TLDR?
10:45:02 <hyperisco> As far as they are categories I am not distinguishing them.
10:45:03 <ski> "distinguishing isomorphic things is evil"
10:45:16 <ski> hyperisco : ok ?
10:46:17 <ski> (at the level of categories, people commonly use the concept "equivalence", rather than mere (on the nose) "isomorphism" (but see HoTT and univalence))
10:47:13 <hyperisco> I have side effects, though, and so in that regard it is significant to do, say,  A -> B -> A  rather than  A -> A
10:47:35 <hyperisco> those concerns are separable
10:48:25 <vaibhavsagar> I'm trying to run `cabal new-build` but it's trying to access `/opt`, does anyone know why?
10:49:17 <ski> i suppose, in a `2'-category, you can talk about an "adjoint situation" (?) between two objects ?
10:49:30 <cocreature> vaibhavsagar: any specific part of /opt?
10:49:39 <ski> hyperisco : hm, elaborate ?
10:49:41 <fendor> > (reverse >>= (==)) "racecar"
10:49:43 <lambdabot>  True
10:49:52 <hyperisco> The only effect is the arrow of time, really
10:49:55 <cocreature> vaibhavsagar: my guess would be either something in your cabal config or something like the GHC (or another tool) in your PATH coming from /opt
10:50:09 <fendor> whose monad instance is that piece of code using?
10:50:24 <Cale> functions
10:50:31 <fendor> I thought, i must be function, but how can that result in a bool?
10:50:33 <hyperisco> Lets say every base morphism costs 1 time unit, and the composition of morphisms costs the sum of the morphisms
10:50:39 <vaibhavsagar> cocreature: I just deleted ~/.cabal and it still happened
10:50:40 <dmwit> vaibhavsagar: Perhaps you have something in cabal.project, cabal.project.local, or ~/.cabal that points to /opt.
10:50:49 <hyperisco> So,  A -> A  is 1 time whereas  A -> B -> A  is 2 time
10:50:51 <Cale> fendor: (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
10:51:07 <ski> hyperisco : what is the significant difference between going from `A' to `A', via `B', vs. directly ?
10:51:09 <Cale> fendor: It might help to see an example with do notation
10:51:11 <hyperisco> And at time 1  A -> A  is A  whereas  A -> B -> A  is B
10:51:25 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "racecar"
10:51:27 <lambdabot>  ("racecar","racecar","RACECAR")
10:51:29 <ski> hyperisco : oh, so these are progressing states, not types ?
10:52:07 <hyperisco> ski, erm, hm. Both?
10:52:16 <dmwit> hyperisco: You might like the free category on a graph. Objects are nodes of the graph; arrows are paths in the graph.
10:52:19 <ski> > (do y <- reverse; z <- map toUpper; (,y,z)) "racecar"
10:52:20 <Cale> > (do x <- reverse; y <- (==) x; return y) "racecar"
10:52:22 <lambdabot>  ("racecar","racecar","RACECAR")
10:52:23 <lambdabot>  True
10:52:25 <fendor> Cale, this is a mindfuck for me. but a really cool one
10:52:43 <Cale> It's the exact same thing as the reader monad, if you're familiar with that
10:52:46 <Cale> Just unwrapped
10:52:48 <dmwit> hyperisco: (e.g. perhaps start with a clique as your graph)
10:52:57 <ski> @quote is.the.solution
10:52:57 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
10:53:22 <vaibhavsagar> dmwit: I just deleted ~/.cabal
10:53:27 <vaibhavsagar> and the same thing happened
10:53:35 <fendor> Cale, I see, that makes sense... but for me, the reader monad holds a state(read only) while a function does not
10:53:36 <dmwit> hyperisco: The resulting category is connected if the graph was (a clique definitely is). Certainly not thin, but I think that's good: you have something you want to do to distinguish between compositions and (say) identities.
10:53:46 <dmwit> vaibhavsagar: And cabal.project, cabal.project.local?
10:53:47 <hyperisco> ski, time offset ignored though, A -> A brings me to the same state as A -> B -> A
10:53:49 <vaibhavsagar> I don't have a cabal.project.local and cabal.project doesn't have any absolute paths in it
10:53:54 <Cale> fendor: The "environment" is just the function's parameter
10:54:03 <dmwit> vaibhavsagar: Neat!
10:54:06 <ski> hyperisco : mhm
10:54:32 <vaibhavsagar> dmwit: I also removed ~/.ghc for good measure
10:54:45 <fendor> so, consequentially, the head of the monad instance of (->) must be instance Monad (e ->) where, right?
10:54:50 <dmwit> vaibhavsagar: Can you share the output of cabal new-build --verbose?
10:54:55 <Cale> Monad ((->) e)
10:54:55 <cocreature> vaibhavsagar: so what exactly is it trying to access? /opt itself or some file in /opt?
10:54:57 <Cale> but yeah
10:55:01 <ski> fendor : you can think of a value of type `r -> a' as a datastructure, which hold a slot containing a value of type `a', for each "index" of type `r'
10:55:11 <Cale> It would be (e ->) if you were allowed to have operator sections in types :)
10:55:20 <vaibhavsagar> dmwit: seems like `/opt` itself
10:55:24 <vaibhavsagar> "/opt: getDirectoryContents:openDirStream: permission denied (Permission denied)"
10:55:43 <dmwit> vaibhavsagar: I suppose another possibility is that there is some custom Setup.hs in one of your packages (or their dependencies).
10:55:46 <vaibhavsagar> I'm running NixOS, if that matters
10:56:52 <dmwit> hyperisco: (...and composition in the free category over a graph is just append the two paths.)
10:56:56 <Cale> vaibhavsagar: Does that happen for every cabal new-build everywhere, or just in your particular project?
10:57:22 <wildtrees> vaibhavsagar, did you read this and enable nix integration? https://www.haskell.org/cabal/users-guide/nix-integration.html
10:57:24 <vaibhavsagar> Cale: only in IHaskell
10:58:18 <vaibhavsagar> wildtrees: no, I don't want Nix integration
10:58:22 <cocreature> wildtrees: the nix integration doesn’t work with new-build anyway afaik
10:58:25 <hyperisco> dmwit, what to do about labeled edges?
10:59:09 <cocreature> vaibhavsagar: strace? :)
10:59:17 <fendor> Cale, thanks, I think, I understand! 
10:59:25 <cocreature> --verbose is probably a better first option
10:59:39 <Boarders> is there anything similar to sortBy for vector?
10:59:52 <fendor> ski, isnt that kind of like a Map? 
10:59:55 <dmwit> hyperisco: There's an almost identical construction for the free category over labeled graphs.
11:00:08 <Cale> fendor: Basically, a function "runs" another function by applying it to its own parameter :)
11:00:08 <vaibhavsagar> cocreature: I tried that! "openat(AT_FDCWD, "/opt", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = -1 EACCES (Permission denied)"
11:00:13 <dmwit> hyperisco: In short: the path contains the label on each edge.
11:00:33 <dmwit> hyperisco: (So identities are still the empty path, composition is still just append the two paths.)
11:00:51 <ski> fendor : a `Map k v' is a "finite map", a partial function (with "finite support", iow defined on finitely many inputs) from `k' to `v'
11:01:32 <fendor> Cale, and the second of param of `>>=` gets the original parameter and the result of the first fucntion? ok, i think, it makes sense :D
11:01:53 <Cale> Yeah, (f >>= g) x = g (f x) x
11:02:06 <hyperisco> dmwit, do you see where I am going with time? If I was to incorporate it into the category, I am not sure quite how that'd be done.
11:02:27 <dmwit> hyperisco: It's already available in the free category construction I described.
11:02:35 <fendor> ski, by definition of Map or just because happens in the implementation?
11:02:39 <dmwit> Given an arrow (a.k.a. path in the graph), its length is the time.
11:03:02 <hyperisco> What is the length of an arrow?
11:03:09 <ski> fendor : because of the abstract datatype idea that `Map' is an implementation of
11:03:10 <fendor> Also, this means, the function is like a Map, but hopefully totally defined? 
11:03:38 <fendor> Ok, understood. But a function may also be partially defined, right?
11:03:52 <dmwit> hyperisco: In this particular category, an arrow is a path in your original graph. A path is a list of edges (whose source and target line up in the right way). So the length of an arrow is literally just call `length` on it.
11:04:38 <vaibhavsagar> cocreature: https://pastebin.com/QYbeuGQ2
11:07:03 <jle`> Boarders: anything in vector-algorithms, maybe?
11:07:12 <cocreature> vaibhavsagar: hm nothing obvious, I’d try --verbose first before you stare at this too deeply
11:07:50 <Boarders> jle' : thanks, I realised I could just use minimumBy for what I wanted
11:08:00 <jle`> nice :)
11:08:15 <vaibhavsagar> cocreature: that gives me "Project settings changed, reconfiguring..." and then the same error
11:09:27 <cocreature> vaibhavsagar: which branch of IHaskell is that? And which nix-shell env?
11:10:04 <vaibhavsagar> cocreature: IHaskell master, `nix-shell -p ghc cabal-install`
11:11:18 <vaibhavsagar> it's not urgent or important, just weird that it's failing for me in this way
11:11:39 <cocreature> That fails trying to find ghc-parser for me
11:12:08 <vaibhavsagar> cocreature: it's in the `ghc-parser` folder, I thought `cabal.project` would take care of that
11:12:25 <vaibhavsagar> can you comment out the `ihaskell-display/*` packages?
11:12:37 <vaibhavsagar> `static-canvas` hasn't been updated in a while so it fails
11:12:43 <jgt> lavalike: yeah, I know I missed the newline. Didn't see that until after it was merged :(
11:13:01 <cocreature> ah yeah I think that’s it
11:16:05 <crestfallen> hi I have some questions about the structure of the list comprehension on line 146. the function 'prunes' the depth of a data tree. ts is named on the lhs and each t is then passed to the recursive part of the list comprehension. t looks strange to me because what's passed is not in notation similar to the x in (x:xs). so what does haskell do there to separate the nodes?    https://github.com/varreli/haskell/blob/master/hutton/84_c
11:16:05 <crestfallen> hapt11/ticTacToe.hs 
11:16:59 <crestfallen> for lack of a better way to ask it ...
11:17:13 <wildtrees> crestfallen, that link seems broken 
11:17:20 <crestfallen> dang
11:17:22 <wildtrees> oh
11:17:30 <wildtrees> it got split
11:17:43 <crestfallen> yeah can you get it?
11:17:53 <wildtrees> could just paste the link alone on a line? 
11:17:58 <crestfallen> sure
11:18:07 <crestfallen> https://github.com/varreli/haskell/blob/master/hutton/84_chapt11/ticTacToe.hs
11:18:34 <cocreature> vaibhavsagar: hm it got as far as trying to build zeromq which failed since I don’t have the things available in the nix-shell
11:18:51 <cocreature> vaibhavsagar: Do you have anything in your env vars? maybe try a "env | grep opt"
11:19:31 <vaibhavsagar> cocreature: nope
11:19:35 <vaibhavsagar> I just tried `env | grep opt`
11:19:52 <vaibhavsagar> good to know it worked for you though
11:20:31 <cocreature> weird :/
11:20:39 <wildtrees> crestfallen, starts at line 130, I believe that is called a rose tree, has an element at each node, and a list of other nodes, so I think the ts from 146 is just a list of nodes, its bound in the pattern match to the function
11:21:25 <crestfallen> wildtrees, one moment please
11:21:37 <vaibhavsagar> I also tried `nix-shell --pure -p ghc cabal-install` and that failed the same way, so I'm reasonably sure it's not environment variables
11:21:45 <wildtrees> afk a min
11:22:12 <cocreature> vaibhavsagar: which cabal and ghc version are you using?
11:23:17 <vaibhavsagar> cocreature: ghc 8.6.4, cabal-install 2.4.1.0
11:25:31 <cocreature> hm I have 8.6.5 but that hardly seems like it should be the difference here. fwiw in "nix-shell -p ghc cabal-install zlib pkg-config zeromq" I was able to run "cabal new-build exe:ihaskell" successfully after removing all the ihaskell-display stuff from cabal.project
11:28:14 <fragamus> hi I have an ADT and I need a tuple of the args of its constructor
11:28:56 <fragamus> I have a string identifying the constructor if that helps
11:29:45 <wildtrees> crestfallen, back for a few if you still need help, ping my name in the channel 
11:30:09 <crestfallen> yes thanks wildtrees, the rhs we have Node x which is like the head I suppose. 
11:30:12 <vaibhavsagar> cocreature: thanks :)! I do have some of that stuff in `stack.yaml`
11:31:09 <wildtrees> crestfallen, no Node is a constructor, prune is traversing a Tree recursively and reconstructing another tree that looks to be only so deep 
11:31:18 <fragamus> i am doing this     moduleArgsTuple = ast ^? _Ctor @"Module"     to get the tuple
11:31:25 <cocreature> vaibhavsagar: sorry for not providing any actual help. I’m a bit lost at this point :)
11:31:58 <fragamus> but the problem is that I dont know the constructor name until runtime
11:31:59 <vaibhavsagar> cocreature: no worries, something must be funky with my laptop
11:32:12 <crestfallen> ok, thanks wildtrees  so one thing is, is that technically lazy evaluation when we have a base case defined on line 145?
11:32:22 <vaibhavsagar> I was just trying to see how easy `cabal new-build` is to use
11:32:57 <solonarv> fragamus: can't be done. how should GHC figure out what type that returns?
11:33:09 <crestfallen> i.e. does that work just like take does in an infinite list say? 
11:33:19 <cocreature> vaibhavsagar: if it works it’s usually quite easy ;)
11:33:31 <solonarv> however I seem to recall that you are actually only interested in a specific field and you don't care at all which constructor you have
11:33:31 <wildtrees> crestfallen, should be, haskell is lazy by default, you can use seq and different datatypes for some strictness though
11:33:35 <solonarv> is that correct?
11:33:52 <fragamus> yes
11:34:46 <crestfallen> ok what I'm asking is , are lazy evaluation and setting a base case the same thing . because recursion is a different approach to termination I thought wildtrees 
11:35:05 <vaibhavsagar> cocreature: I tried building `ghcid` the same way, and you're right :)
11:35:06 <fragamus> well I want all of the fields
11:35:11 <solonarv> in that case you probably want to use 'typed @(TypeOfTheFieldYouWant)' instead of messing around with picking uot a specific constructor but actually deciding which constructor you're picking out based on which constructor you have
11:35:21 <solonarv> ...you want all the fields? how is that supposed to work
11:35:34 <fragamus> I guess it cant be dome
11:35:39 <fragamus> done even
11:35:59 <solonarv> well, I suppose it could be done if your constructors all have the same fields
11:36:06 <dmwit> No, lazy evaluation is not the same as creating a base case.
11:36:09 <fragamus> the dont
11:36:11 <dmwit> Heck, one is a noun and one is a verb.
11:36:54 <dmwit> Lazy evaluation is an order in which reductions are done. Choosing a base case identifies the result of a particular reduction.
11:37:20 <wildtrees> crestfallen, haskell will build up a series of "thunks" to evaluate latter to get an answer when requested, it will only recurse as far as you are requesting answers from the IO monad at the top, iirc, there are ways to force evaluation to different degrees but I am not up to speed on all of them
11:37:47 <solonarv> I would recommend the following: if you have 'ast' and you want the field of type 'Foo', just write 'ast ^? typed @Foo'; similarly if you want the field of type 'Bar' just write 'ast ^? typed @Bar'
11:37:51 <dmwit> It is a bit like asking "is writing right-to-left the same as deciding to write down the word 'reverse'?".
11:38:03 <wildtrees> crestfallen, you should be able to generate an infinite (rose) Tree as defined from a function and prune it to a required finite depth
11:38:13 <solonarv> (these expressions have types 'Maybe Foo' and 'Maybe Bar', respectively)
11:38:29 <jle`> crestfallen: lazy evaluation and having a base case isn't quite the same thing
11:38:34 <dmwit> One talk about a particular choice about how to write. The other talks about what to write using that choice.
11:38:48 <fragamus> solonarv: ok I was writing a log of code for all of the zoo of ADTs in the tree
11:39:03 <dmwit> Same with lazy evaluation vs. base cases. One is a choice about how to compute. The other says what to compute.
11:39:24 <fragamus> I learned a way to get the name of the constructor as a string and that was helpful in a small way
11:39:42 <fragamus> I guess I have to go back to writing the zoo code
11:39:59 <crestfallen> thanks a lot wildtrees jle`    one sec
11:40:16 <crestfallen> also dmwit  ...
11:40:48 <isovector1> does anyone know offhand whether text+bytestring are smart enough to fuse together?
11:40:53 <solonarv> you just want to log? as a first approach, what's wrong with simply 'show' ing the value you have?
11:40:56 <wildtrees> crestfallen, you are welcome :) 
11:41:00 <dmwit> isovector1: They do not fuse.
11:41:05 <fragamus> solonarv: I understand why it can't work
11:41:43 <isovector1> dmwit: thanks! i found slow af janky-ass code that converts willy-nilly between text.builders, lazy and strict texts, AND between all of the same bytestring concepts
11:41:52 <isovector1> i'll bet that's why
11:41:52 <jle`> crestfallen: looking at your original ink, lazy evaluation doesn't really have anything to do with what is going on, logically
11:42:18 <jle`> crestfallen: what's going on is just list comprehension syntax
11:42:45 <jle`> > let myFunc xs = [ negate x | x <- xs ] in myFunc [1,2,3,4]
11:42:48 <lambdabot>  [-1,-2,-3,-4]
11:43:00 <jle`> do you see how this is not passed in as "(x:xs)" ?
11:43:12 <jle`> that's just how list comprehension syntax works, you don't really need to pattern match on the input list to use it
11:43:57 <crestfallen> jle`, I don't think I've seen the recursive element inside the list comprehension. one moment please I'm looking at what dmwit said above    yes jle` I had an intuition about the distinction there
11:44:15 <jle`> crestfallen: right, but recursion doesn't have anything to do with it
11:44:21 <jle`> that's one of the nice things about list comprehensions
11:44:28 <jle`> you can be recursive in them and it doesn't matter, it's all the same
11:44:49 <crestfallen> has nothing to do with it in your example you mean?
11:45:04 <jle`> crestfallen: it has nothing to do with your example
11:45:11 <jle`> the fact that it's recursive doesn't change anything about the list comprehension
11:45:18 <jle`> it's still just a normal list comprehension :)
11:45:27 <jle`> it doesn't become magically different just because there is a recursive call
11:45:30 <fragamus> solonarv: so in the end, generics get me nowhere
11:46:11 <jle`> crestfallen: as for strict vs. lazy, one way to look at it might be that prune could be defined in this way for both strict and lazy contexts; the base case doesn't have anything to do with strict vs. lazy
11:46:25 <jle`> crestfallen: but we can imagine what the difference would be in a strict vs. lazy evaluation model
11:46:55 <jle`> crestfallen: in a strict model, the person who *uses* `prune 4 xs` would have to wait until the entire result tree was being finished pruning before being able to do anything with the resulting tree
11:47:05 <crestfallen> right so consuming a list or a tree what have you is just consuming. I think the author may have mentioned lazy in this function I have to go back and reread...
11:47:25 <jle`> crestfallen: in a non-strict or lazy model, the person who *uses* `prune 4 ts` can start using the parts of the tree (like the value in the node) without waiting for the entire tree to finish evaluating
11:47:35 <jle`> crestfallen: lazyness vs. strictness doesn't have anything to do with how 'prune' is written here
11:47:47 <jle`> prune can be written as-is in both a lazy and strict context
11:48:07 <jle`> you can have a base case in a strict evaluation setting, as well
11:48:19 <jle`> and unless your tree is infinite, they'll basically work both the same way
11:48:36 <jle`> so 'base case = lazy' isn't quite true.  you can have a base case in both lazy and strict settings
11:48:47 <jle`> they are unrelated concepts
11:49:22 <jle`> crestfallen: in this setting, when we are looking at how 'prune' is defined, looking at lazy/strict doesn't really matter
11:49:38 <jle`> it only matters at the places where you want to *use* prune
11:50:00 <crestfallen> ok that's a bit tricky. I was making a hard and fast distinction..   one moment please jle` trying to take that all in.
11:51:21 <jle`> i could define prune in the same way in ocaml, where everything is strict.  you can have a base case, a recursive case, and everything.
11:51:25 <dmwit> (I think it's a bit unusual to write `prune` like this in a strict language. In a strict language, one wants to `prune` while generating the tree, to avoid the extra work. However I agree it could be done.)
11:51:42 <solonarv> fragamus: I'm quite sure they could help you reduce boilerplate, but right now I don't know what you are trying to accomplish
11:52:09 <solonarv> so it is a bit difficult to say "ah, here is how you could do this"
11:54:06 <crestfallen> jle`, so when you said ' you don't really need to pattern match on the input list to use it '   above ...
11:54:32 <crestfallen> the <-    element of syntax is what is doing the work there
11:54:49 <crestfallen> 'element of' syntax*
11:55:12 <jle`> you can think of it that way, i suppose. it's what drives the iteration
11:55:40 <jle`> and semantically it binds a name to an item in the list
11:55:55 <jle`> so you can use that item
11:56:17 <jle`> s/use/refer to
11:56:21 * solonarv likes reading 'x <- blah' as 'x taken from blah' or 'take x from blah'
11:56:38 <crestfallen> thank you the syntax is arbitrary you could write tt <- ts there 
11:57:22 <tabaqui> but things are getting interesting in case of Arrows
11:57:32 <tabaqui> a <- func -< datum
11:57:43 <crestfallen> yes the syntax for a list is a little cleaner it seems (x:xs)
11:57:54 <tabaqui> it is almost the same
11:57:55 <dmwit> crestfallen: You could, provided you changed that name consistently in the rest of the comprehension.
11:59:35 <crestfallen> Ok, maybe this was answered above, but say in recursion theory, would the idea of lazy evaluation be considered as part of it theoretically ?
12:00:10 <kritzefitz> Is there something I can do when GHC doesn't inline `foo` marked with {-# INLINE foo #-}, but I REALLY want `foo` inlined?
12:01:44 <cocreature> kritzefitz: depends on why it doesn’t get inlined
12:01:57 <dmwit> You could always inline it yourself.
12:02:13 <cocreature> kritzefitz: possible reasons are: foo is recursive, your call to foo is not fully applied, …
12:02:15 <int-e> kritzefitz: maybe foo is recursive?
12:02:22 <kritzefitz> dmwit, inlining it myself actually gives the desired result.
12:02:58 <kritzefitz> But I wanted o avoid inlining myself.
12:03:06 * dmwit nods
12:03:14 <int-e> let foo = go where go = [definition]  may do the trick
12:04:59 <kritzefitz> `foo` doesn't take arguments, so it's definitely fully applied and I think it isn't recursive, because it's exported “inline definition“ consists of a single call to another function.
12:06:41 <dmwit> Is it class-polymorphic?
12:07:02 <dmwit> (Perhaps you also need to SPECIALISE it?)
12:08:52 <kritzefitz> `foo` itself is not polymorphic, but it passes polymorphic stuff around internally.
12:09:26 <kritzefitz> Though in the optimized code for `foo` (produced by GHC) the polymorphic stuff has been properly inlined.
12:09:46 <isovector1> kritzefitz: what's the definition of foo?
12:10:04 <kritzefitz> isovector1, give me a second, I'll post a snippet...
12:10:45 <Ariakenom> kritzefitz: interesting, how did u check the polymorphism was gone?
12:11:39 <kritzefitz> Ariakenom, I looked at the output of -ddump-simpl.
12:13:35 <dmwit> Wait. Is foo a CAF?
12:14:10 <dmwit> I wonder if GHC avoids inlining CAFs, since they're supposed to be memoized...?
12:14:15 <kritzefitz> I'm not sure I remember the exact meaning of CAF correctly, but I think it is.
12:14:30 <kritzefitz> Though I had no problem inlining other CAFs.
12:14:32 <Ariakenom> kritzefitz: nice
12:14:34 <dmwit> hrm
12:15:01 <kritzefitz> But GHC might deem this specific definition complicated enough to think that memoization is worth not inlining.
12:15:21 <crestfallen> jle`, so to be sure, whether the consumption of the list or tree is lazy or recursive with a base case written on the subsequent line, that doesn't define whether the function as a whole is seen as lazy or strict?  
12:16:05 <isovector1> kritzefitz: do `-fspecialise-aggressively` and/or `-flate-specialisation` help?
12:16:06 <kritzefitz> isovector1, https://gitlab.com/snippets/1873635 , I want the definition of `shownNaturals` to inline into `naturalsString`
12:17:03 <isovector1> kritzefitz: also can you share the dump-simpl?
12:18:03 <Ariakenom> would making it a () -> Infinite String do anything?
12:19:23 <isovector1> ^ that's my guess
12:19:51 <kritzefitz> isovector1, I added the compiler output as a comment below the snippet.
12:21:38 <Ariakenom> what about a rewrite rule to the definition?
12:21:57 <kritzefitz> Ariakenom, making it a `() -> Infinite String` worked.
12:25:05 <kritzefitz> Rewriting to the definition via rules also works.
12:25:09 <Ariakenom> :D
12:25:47 <kritzefitz> isovector1, dmwit, Ariakenom, int-e, cocreature Thanks for figuring this out!
12:28:14 <Ariakenom> now I'm interested in whether isovector1's flags work though
12:32:49 <Boarders> with a vector what is the fastest way to do \vs -> V.zip (V.fromList [0..]) vs?
12:33:03 <Boarders> i.e. give the pairs that have the index of the element
12:37:14 <fragamus> solonarv: I think I might be able to use generic lens constraint traversal
12:44:54 <kritzefitz> Ariakenom, -fspecialize-aggressively doesn't help and -flate-specialization is apparently not implemented in GHC 8.4.4.
12:45:07 <kritzefitz> I will try with a newer GHC and see what I can find out.
12:50:26 <bgamari> Boarders, I think there is an indexed combinator
12:50:51 <Boarders> bgamari: perfect, thank you!
12:55:06 <kritzefitz> Ariakenom, In GHC 8.6.5 the flags didn't help.
12:57:47 <Ariakenom> kritzefitz: interesting thanks a bunch
13:01:40 <Boarders> is there anything for vectors like a chunks function: chunks :: Vector a -> Int -> Vector (Vector a)
13:01:51 <Boarders> which cuts it up as best as possible into chunks of length the inut
13:01:53 <Boarders> input*
13:03:42 <bgamari> Boarders, you mean into n chunks of equal length?
13:04:19 <Boarders> I mean so that it would do say chunks [1..10] 3 === [[1,2,3], [4,5,6], [7,8,9], [10]]
13:04:50 <ski> > chunksOf 3 [0 .. 9]
13:04:53 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9]]
13:05:34 <Boarders> I don't think a roundabout into lists is good for what I am doing
13:06:04 <ski> i suppose you could do something with slices ?
13:09:08 <solonarv> if you can somehow figure out what the ranges should be, you can just combine that with 'slice'
13:09:26 <solonarv> oh, I see your example now
13:11:37 <solonarv> chunksOf xs n = generate ((len+2) `div` n) (\i -> slice (n*i) (max len (n*(i+1)) - 1) xs)
13:11:40 <solonarv> Boarders: ^
13:12:07 <solonarv> should work, but I just typed it out without any testing so there might be an off-by-one error hidden somewhere
13:12:53 <Boarders> Solonarv: thanks, I wrote the recursion by hand using slice
13:13:08 <solonarv> generate is nice because it preallocates a vector of the right size
13:13:22 <Boarders> I used a builder for it
13:13:32 <solonarv> ah, that should work too
13:14:33 <ski> `len+2' should be `len+n-1' ?
13:14:44 <solonarv> er, yes
13:15:04 <solonarv> that is a typo from when it was hard-coded for n=3
13:15:10 <hyperisco> but is it (len+n)-1 or len+(n-1)
13:15:17 <ski> `generate' is called `tabulate' in SML, and possibly also O'Caml
13:15:24 <ski> hyperisco, heh
13:16:01 <solonarv> ski: tabulate is taken by Data.Functor.Representable
13:16:02 <ski> i've defined `tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e' several times in the past
13:16:13 <solonarv> although, I don't remember if that is in base
13:16:23 <solonarv> ski: oh what? that really seems like it should be in array
13:16:34 <ski> (most probably that module didn't exist when i started doing that)
13:16:44 <ski> solonarv : yea, i know ..
13:16:59 <solonarv> one of the many reasons I don't use array :/
13:19:30 <freusque> does a good strict haskell prelude/base replacement attempt exist?
13:20:14 <solonarv> I'm not aware of a (public) one
13:20:27 <freusque> :)
13:21:42 <solonarv> and frankly I'm not sure why you would want that if you intend to compile it with GHC
13:22:05 <solonarv> making *everything* strict is not actually a good idea!
13:22:19 <davean> freusque: That would come at a high cost, but I guess I could see it helping very new people a little, but even then it would harm them a lot overall ...
13:22:35 <hyperisco> Read "!" as "gotta go fast"
13:23:17 <davean> freusque: I'd say its hard to get through writing such a thing and remain thinking its a thing you should inflict on the world :)
13:23:43 <freusque> I agree with your remarks regarding performance
13:23:54 <freusque> my understanding is that it would help reason about GC
13:23:55 <hyperisco> People seem to worry about speed more than average velocity. Did you know if you are born and die in the same hospital that your average velocity is about zero?
13:24:06 <solonarv> hyperisco: badFoldr f z (x:xs) = let !r = badFoldr f z xs in f z r; badFoldr _ z [] = z
13:24:06 <davean> freusque: By making it strictly worse?
13:24:41 <solonarv> that ^ is a great example of strictifying making things worse
13:25:01 <davean> Well not strictly, you CAN write lazy code that is worse, but thats sorta a special case.
13:25:27 <hyperisco> foldl seems salient in this moment
13:25:44 <davean> freusque: the "hard to reason about" GC thing is just non-locality. If you know what code is being run you can know the GC details also.
13:25:45 <solonarv> as a rule of thumb, strict evaluation sometimes makes you do unnecessary work but lazy evaluation sometimes makes you take more space
13:26:19 <solonarv> ...hm, actually I'm not sure the second half of that statement is entirely right
13:27:14 <hyperisco> it is overhead
13:27:36 <solonarv> ah yes, bookkeeping overhead
13:27:47 <davean> solonarv: there are encodings that take more space.
13:27:49 <freusque> thanks to the three of you for your remarks. is there any standard reading on GHC, GC and laziness I could look at?
13:27:52 <hyperisco> If a value is to be forced anyways, it should have just been reduced in the first place.
13:28:08 <solonarv> hyperisco: I was going to say that! :D
13:28:17 <freusque> I'm not familiar with GHC's runtime at all
13:28:26 <hyperisco> Problem is that you can't always know ahead of time which values will be needed.
13:28:43 <hyperisco> Hence laziness… it dynamically figures it out.
13:29:02 <EvanR> wait, does making everything strict really help reason about GC ?
13:29:23 <davean> EvanR: it means you can make local statements about how much garbage it produces at least? :)
13:29:36 <davean> Your milage may vary on if you consider that "helping"
13:29:43 <solonarv> it means data will not get retained as long, because you know better when things are evaluated
13:29:57 <EvanR> seems like you still have a lot of garbage and can't predict when gc happens and still have "pause time proportional to live data"
13:30:02 <hyperisco> I think GC can make it hard to reason about memory, so whatever :P
13:30:03 <solonarv> here is a paper on the GHC runtime's evaluation model: https://www.microsoft.com/en-us/research/uploads/prod/2016/07/eval-apply-icfp.pdf
13:30:14 <freusque> thanks solonarv 
13:30:23 <davean> EvanR: Right, there are parts of GC it doesn't help with at all.
13:30:34 <davean> IE "most of it"
13:30:54 <davean> If you were to try to compute a high water mark by summing functions? It could help with that
13:32:16 <EvanR> solonarv, lazy may take more space or less space depending
13:33:15 * ski . o O ( "this function runs in at most ⌜O(∞)⌝ space" )
13:34:49 <hyperisco> My analogy of speed vs average velocity is just that going fast and taking the best route are orthogonal.
13:36:47 <hyperisco> Or the mantra about efficiency vs effectiveness. Efficiency is doing things right; effectiveness is doing the right things. :)
13:38:20 <ski> @remember hyperisco <hyperisco> My analogy of speed vs average velocity is just that going fast and taking the best route are orthogonal.  <hyperisco> Or the mantra about efficiency vs effectiveness. Efficiency is doing things right; effectiveness is doing the right things. :)
13:38:20 <lambdabot> Good to know.
13:40:55 <hyperisco> When plotting a course, remember that the shortest distance between two points is a wormhole.
13:42:41 <hyperisco> If there is any wisdom to parse from that let me know :P
13:42:44 <Jonathan19> I have a program that uses `forkIO` to spawn another thread.  But that thread runs an infinite loop and the main thread does not.  It there a way I can keep program running until that thread terminates as well?
13:44:59 <Jonathan19> Or, I guess the second thread does not have an infinite loop but it has a longer average lifetime.
13:47:13 <solonarv> yes; the easiest way is to use the async package to spawn the thread
13:47:44 <davean> solonarv: that still requires modifying the main thread to wait on it.
13:47:44 <Jonathan19> Like http://hackage.haskell.org/package/async
13:48:21 <solonarv> the relevant functions are 'async :: IO a -> Async a' which replaces forkIO, and 'wait :: Async a -> IO a' which... waits :D
13:48:28 <solonarv> yep, that is the package I mean
13:48:45 <Jonathan19> Cool, thanks!
13:51:13 <Jonathan19> Another question if I may be so bold as to ask.  Will Haskells "Green Threads" ever run simultaneously on multiple CPU cores?  Or do they always run within a single OS thread?
13:52:08 <Athas> Jonathan19: GHC uses m:n, so multiple OS-level threads can be used.
13:52:35 <Jonathan19> m:n?
13:52:37 <solonarv> I *think* you need to use the threaded runtime for that to actually happen, but I'm not sure
13:52:41 <Athas> When launching a Haskell program, you can indicate (with an RTS option) how many physical threads to use.
13:52:53 <Jonathan19> Oh, nice.
13:52:53 <solonarv> m:n means any number of green threads running on any number of OS threads
13:53:22 <solonarv> a forkIO thread may even migrate between different physical threads!
13:54:46 <solonarv> (you can make a non-migrating thread using forkOS, and you can even tell it which capability to live on using forkOn)
13:54:49 <Athas> You can also directly create new threads that are guaranteed to keep to a single OS thread (this is mostly useful when calling foreign code or doing naughty low-level things).
13:55:36 <solonarv> for example if you want to do OpenGL calls you cannot switch threads ever
13:55:38 <Athas> I must caution that in my experience the GHC RTS is very good for multicore concurrency, but parallel computation easily becomes not all that fast.
14:37:32 <jgt> are True and False called "Data Constructors"? Or "Value Constructors"?
14:37:49 <hyperisco> jgt, data constructors
14:37:52 <jgt> I always get confused about the agreed-upon names
14:37:58 <jgt> hyperisco: thanks
14:41:28 <Amras> how do you read ()?
14:41:46 <Amras> ie, what's the English word for that type
14:41:52 <ski> "unit (type)"
14:42:02 <ski> or "empty tuple type"
14:42:20 <ski> ("nuple type" ??)
14:43:21 <Amras> unit type is what I was looking for, thanks :)
14:44:12 <jgt> hyperisco: is `Just` also a "data constructor"? Or does it need to be applied to its `a` before it's a "data constructor"?
14:44:49 <jgt> I'm writing an article about Yesod/WAI logging, and I don't want to use the wrong terminology for things
14:46:23 <ski> jgt : yes, `Just' is a data constructor
14:46:53 <ski> `Just False' is not a data constructor, though
14:47:09 * ski . o O ( "That's Just False, Man!" )
14:49:02 <jgt> `Just False` would just be a value, right?
14:53:56 <Amras> heh
14:58:25 <ski> jgt : yes. `Just' and `False' are also values, btw
14:59:10 <ski> (functions are values. data constructors are values. some, but not all, data constructors, are functions. some, but not all, functions, are data constructors)
15:02:50 <tabaqui> uh, can I use CPP macro from other module?
15:04:02 <tabaqui> I guess not
15:04:05 <monochrom> I think no. Unless you get GHC's "C API" extension involved.
15:04:32 <monochrom> Wait, that one presupposes C code rather than Haskell code.
15:05:41 <tabaqui> I suppose that all cpp defines dissapear after the module is compiled
15:05:50 <monochrom> Yeah.
15:09:01 <ski> in Lisp systems, you can commonly export macros from modules/structures/whatever
15:09:40 <monochrom> But C macros in Haskell are different from Lisp macros.
15:10:33 <ski> yes
15:10:35 <solonarv> tabaqui: however, #include works
15:10:40 <nisstyre> monochrom: you mean using the CPP in Haskell code?
15:10:48 <nisstyre> is that a thing people do?
15:10:49 <solonarv> I would not recommend #include-ing actual Haskell code
15:10:56 <solonarv> nisstyre: yep, it is
15:11:02 <nisstyre> cool I didn't know that
15:11:10 <tabaqui> C macro is just a joke, but not a macro
15:11:13 <nisstyre> major downside of CPP is that you can't generate fresh variables
15:11:16 <monochrom> Cabal does. Cabal pre-defines version-checking macros for you.
15:11:19 <tabaqui> lisp macro is more like haskell TH
15:11:34 <solonarv> but unlike in C land we do not usually have large amounts of code "inside" CPP
15:11:56 <solonarv> mostly it is used for broader version compatibility, AFAIK
15:12:00 <monochrom> We just use CPP for conditional compilation.
15:12:04 <solonarv> yup
15:12:56 <tabaqui> sure, I prefer to not use CPP at all, but sometimes you have to define instances for transformers
15:13:13 <solonarv> another use is to stay compatible with a wider range of compilers/libraries
15:13:18 <tabaqui> instance (MonadFoo m) => MonadFoo (IdentityT m) where foo = lift . foo; bar b = lift . bar b
15:13:21 <tabaqui> and so on
15:13:35 <solonarv> for example, Semigroup was added to base in GHC 8.0 (base-4.9)
15:13:45 <nisstyre> solonarv: if you're including Haskell code you have to worry about double includes obviously
15:13:55 <nisstyre> but I guess you could just use it for ifdef, and so on
15:14:00 <tabaqui> right, but consider to avoid #includes in case of different platforms
15:14:10 <tabaqui> using cabal include-dir is a better solution 
15:14:15 <solonarv> so at the top of your file you might have #if MIN_VERSION_base(4,9,0) import Data.Semigroup #endif at the top of the file
15:14:45 <solonarv> tbh the only #include I have ever seen in a haskell source file was including a header file with a bunch of macro definitions like
15:15:02 <solonarv> #define HAVE_SEMIGROUP MIN_VERSION_base(4,9,0)
15:15:08 <solonarv> and similar for other features
15:15:22 <solonarv> so in the actual source file you see the more informative #if HAVE_SEMIGROUP
15:15:44 <nisstyre> solonarv: on the C side of things, some people will actually put code in a header file, and then include it as a form of utility library
15:15:51 <nisstyre> in order to avoid the hassle of linking
15:15:57 <solonarv> instead of having to puzzle out why it is MIN_VERSION_base(4,9,0) and not (4,8,0) or (4,10,0)
15:16:01 <solonarv> nisstyre: yeah, I'm aware
15:16:41 <nisstyre> I wonder if something like that in Haskelll would make sense
15:16:50 <nisstyre> like if you have common boilerplate you put in all your modules
15:16:55 <nisstyre> not necessarily a utility library
15:20:42 <solonarv> sure, it makes sense - and you can do it with the module system
15:20:55 <solonarv> and/or template haskell
16:26:21 <sofiama> Can lens autoderive something like _Void for empty types?
17:25:15 <SoundLogic> Uh. Hi! I'm not sure if this is the right place, but I was wondering if I could get some help with things like making some code follow proper style and how I should put it online and so forth?
17:25:45 <Axman6> feel free to share the code and I'm sure we can give you some pointers
17:29:07 <SoundLogic> So I made a library for selecting and manipulating value level isomorphisms at the type level and a system for deriving instances of classes using those isomorphisms. I would like to put it on github or something but... I do not know style things or how to make it 'proper' or such. 
17:29:46 <Axman6> wsell definitely put it on github. whether it's ready for hackage is another question
17:34:09 <SoundLogic> Uh. I wasn't even thinking hackage really. Just trying to clean it up enough for github. I only just added a LICENSE and set it in the .cabal at all. It, uh, isn't actually currently a git repository either. >.>
17:35:05 <Axman6> there's no such thing as "clean enough for github"
17:35:29 <Axman6> "isn't actually currently a git repository either" u wot
17:35:45 <Axman6> time to learn some better habits ;)
17:36:25 <SoundLogic> Hence me asking for help >.>
17:36:31 <alx741> SoundLogic: checkout hlint and [stylish haskell, hindent, brittany]
17:38:25 <SoundLogic> Oh, hlint looks neat...
17:43:47 <infinisil> I wish I knew how to configure space width in brittany
17:44:11 <infinisil> Probably there's some option, but it always indents with 8 spaces which is horrible
18:44:56 <isovector1> anyone know if i can give a custom color blending function in diagrams? trying to implement metaballs
19:14:49 <Axman6> I don't the answer but I'd love to know what metaballs are isovector1
19:15:22 <Axman6> know*
19:16:15 <isovector1> Axman6: they're circles that merge together like a lava lamp when they get close together!
19:16:38 <Axman6> :o
19:16:44 <infinisil> I read meatballs and was slightly confused
19:16:49 <Axman6> me too
19:27:53 <isovector1> https://varun.ca/metaballs/ here's a good solution for n=2
19:28:10 <isovector1> but i doubt it would scale to more metaballs
19:31:04 <fragamus> isovector1: hey man did you write that book
19:32:50 <isovector1> fragamus: yeah ;)
19:33:19 <fragamus> isovector1: nice!
19:51:18 <Axman6> SoundLogic: don't forget to share your code once you get it in github
19:51:33 <Guest_78> hello
19:51:35 <SoundLogic> I got it to pass hlint
19:52:30 <Guest_78> trying to install haskell by curl but getting error like "xz"ghcup --cache install" failed!" 
19:52:37 <Guest_78> can anyone help please?
19:53:17 <Axman6> do you have xz installed?
19:54:27 <Guest_78> i think no
19:54:32 <Guest_78> whats XZ?
19:54:55 <slack1256> Guest_78: it's a command to compress files
19:54:57 <Axman6> a compression tool
19:56:22 <Guest_78> ok, 
19:56:25 <Guest_78> how to install it?
19:56:47 <Axman6> well, seeif you have it installed. it's about as old as time so it shoudl be installed
19:57:54 <Guest_78> "Following commands are required, but missing, please install:  xz" - this is what I'm getting when I try to install ghcup by curl
19:59:55 <heatsink> What operating system are you using?
20:00:49 <Axman6> generally when asking for help, if you have an error message it's a good idea to share it when you first ask for help
20:04:42 <Guest_78> this is the error: "Following commands are required, but missing, please install:  xz" when installing the ghcup
20:06:18 <Axman6> and which operating system are you using?
20:10:23 <Axman6> :\
20:11:15 <Guest_78> mac OSX
20:12:52 <heatsink> I also have OS X, xz doesn't come with the operating system
20:12:54 <Axman6> you probably need to instrall Xcode or the command line developer tools
20:13:08 <heatsink> I installed it with macports, though that's somewhat of a hassle
20:13:25 <Axman6> I appear to have it installed via homebrew
20:14:17 <Guest_78> ok will try to reinstall homebrew
20:25:29 <leifm> Is there a neat way to reverse a list with recursion schemes?
20:25:44 <heatsink> yes.
20:28:02 <dmwit> > foldr (\x xs -> xs . (x:)) id "hello" "" -- foldr is a recursion scheme, specifically, a catamorphism
20:28:05 <lambdabot>  "olleh"
20:30:04 <dmwit> > foldMap (Dual.pure) "hello"
20:30:07 <lambdabot>  error:
20:30:07 <lambdabot>      Not in scope: ‘Dual.pure’
20:30:07 <lambdabot>      No module named ‘Dual’ is imported.
20:30:11 <dmwit> > foldMap (Dual . pure) "hello"
20:30:14 <lambdabot>  error:
20:30:14 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M896371291966...
20:30:14 <lambdabot>        prevents the constraint ‘(Show (f0 Char))’ from being solved.
20:30:17 <dmwit> aww
20:30:26 <dmwit> > foldMap (Dual . pure) "hello" :: Dual String
20:30:30 <lambdabot>  Dual {getDual = "olleh"}
20:32:48 <leifm> That's inefficient, right? Same as foldr (\x y -> y <> [x]) []
21:14:40 <tommd> Sorry if it is already a topic: Is gitlab.haskell.org known expected down, unknown unexpected down, known unexpected down, or unknown expected down?
21:14:56 <tommd> It iterferes with ghcup which in turn breaks all sorts of automation.
21:20:02 <maerwald> hmmm
21:20:12 <jle`> @tell leifm no, it's O(n) :)
21:20:12 <lambdabot> Consider it noted.
21:22:53 <maerwald> tommd: https://github.com/haskell/ghcup/blob/master/ghcup#L127
21:23:26 <maerwald> change that to https://raw.githubusercontent.com/haskell/ghcup/master/
21:35:09 <tommd> maerwald: I appreciate the workaround, but that doesn't really fix the automation aspect.  Perhaps the correct automation is to not use get-ghcup.haskell.org at all and just use the github link directly.
21:43:06 <dmwit> jle`: Mmm, the Dual one might actually be inefficient.
21:43:24 <maerwald> tommd: I don't know what you eman with automation aspect
21:44:07 <dmwit> jle`: Depends which way foldMap associates its (<>) operation, and I'd bet the associating was chosen to make foldMap id cheap, which is exactly the bad case for Dual here.
21:44:19 <dmwit> (I mean foldMap pure, not foldMap id.)
21:45:27 <dmwit> ?tell leifm The catamorphism one I showed first (with `foldr (\x xs -> xs . (x:)) id`) is efficient, O(n). I think the Dual one I showed second is inefficient, O(n^2).
21:45:27 <lambdabot> Consider it noted.
21:45:38 <tommd> maerwald: I have CI scripts and dockerfiles that install ghc via ghcup.  These can, potentially, run at inopportune times and if I can expect significant down time then it would be worth while for me to use github+sed instead of the haskell.org script.
21:46:13 <tommd> maerwald: OTOH, the need to rebuild something that early in the system, vs using cache, is rare so hitting this failure is too.
21:46:20 <dmwit> > foldMap Dual [x,y,z]
21:46:23 <lambdabot>  Dual {getDual = ((mempty <> z) <> y) <> x}
21:51:23 <maerwald> tommd: yeah, I might have to switch to github again if these problems persist. The problem with github is, that it's proprietary and that caused problems in the past
21:52:27 <maerwald> but this seems to be gitlab specific right now, haskell.org is up, so that would be an alternative location to host all files
21:54:05 <jle`> dmwit: ah yeah, i didn't see that one
21:54:06 <jle`> for some reason
21:56:20 <Axman6> >  foldMap (Dual . Endo . (:)) "hello" :: Dual (Endo String)
21:56:23 <lambdabot>  error:
21:56:23 <lambdabot>      • No instance for (Show (Endo String))
21:56:23 <lambdabot>          arising from a use of ‘show_M38700530812742887336798’
22:47:21 <jle`> is there any way to have a conduit that can fork many threads and each thread can 'await' in parallel?
22:48:23 <Axman6> We do that using unagi-chan. I thought about using conduit but for our usecase it was easier to think about a producer and many workers
22:49:42 <cocreature> the two aren’t necessarily exclusive. You can have one conduit that writes to the chan as a sink and then a bunch of conduits that read from the chan
22:49:45 <Axman6> we have a function something like: processConcurrently :: Int {-n workers-} -> ((a -> m ()) -> m b) -> (m a -> m c) -> m (Async b, [Async c])
22:49:53 <cocreature> That’s roughly how pipes-concurrency works
22:50:00 <Axman6> yeah
22:50:20 <jle`> hm, i'm providing an api as a library author, so maybe there is no point in even concerning conduits in the first place then
22:51:03 <jle`> maybe i'm trying to shoe-horn it into a conduit framework
22:51:18 <jle`> hm, i suppose i could reframe it as a conduit transformer instead of a conduit itself, then i could do the chan thing.
23:21:32 <jle`> hm this wasn't as simple as i had thought
23:34:53 <jle`> nvm i got it :D
