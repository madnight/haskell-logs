00:40:15 <Aj50> Hi
00:40:49 <Aj50> I started learning haskell recently .... 
00:41:24 <Aj50> I dont really understand how lazy evaluations improve efficiency
00:41:42 <Aj50> Can you please point me to some example
00:43:07 <libertyprime> hey guys. noob question: how to install a package from hackage? http://hackage.haskell.org/package/Glob-0.10.0#readme
00:45:26 <Rembane> libertyprime: Do you want to run an executable or use Glob in your own project? 
00:47:31 <libertyprime> Rembane: I'd like to use it in my project
00:49:38 <Rembane> libertyprime: Then add it to your *.cabal-file and run cabal install 
01:00:33 <libertyprime> any way to list list all the modules for a given package?
01:00:41 <libertyprime> thanks btw
02:23:36 <radsmoo> > take 5 [1..] ==> [1,2,3,4,5]
02:23:40 <lambdabot>  error:
02:23:40 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Integer]’
02:23:40 <lambdabot>      • In the first argument of ‘(==>)’, namely ‘take 5 [1 .. ]’
02:24:07 <radsmoo> sorry, was checking if the lambdabot is working
02:25:31 <radsmoo> take 5 [1..] ==> [1,2,3,4,5]
02:27:37 <lavalike> @botsnack
02:27:37 <lambdabot> :)
02:56:51 <kuribas> @hoogle Monoid a => Bool -> a -> a
02:56:52 <lambdabot> Data.Monoid.HT when :: Monoid m => Bool -> m -> m
02:56:52 <lambdabot> Network.URI.Template.Internal whenM :: Monoid m => Bool -> m -> m
02:56:52 <lambdabot> Data.Semigroup stimesMonoid :: (Integral b, Monoid a) => b -> a -> a
02:57:34 <merijn> kuribas: Ah, one of my favorite functions :)
02:57:42 <kuribas> merijn: which one?
02:58:05 <merijn> kuribas: It doesn't have a name in base, sadly, but I love "Monoid a => Bool -> a -> a"
02:58:15 <kuribas> yeah :)
02:59:01 <kuribas> hmm, I could name it <>?
02:59:30 <merijn> That conflicts with Semigroup/mappend
02:59:46 <kuribas> oh...
02:59:55 <kuribas> :i (<>?)
02:59:59 <kuribas> @hoogle (<>?)
03:00:00 <lambdabot> Data.PartialSemigroup (<>?) :: PartialSemigroup a => a -> a -> Maybe a
03:00:00 <lambdabot> Data.PartialSemigroup.Generics (<>?) :: PartialSemigroup a => a -> a -> Maybe a
03:00:22 <kuribas> merijn: including the question mark?
03:00:34 <merijn> oh, that was part of the operator xD
03:01:27 <kuribas> not great, it's not really an mappend
03:03:41 <kuribas> maybe whenMono?
03:04:41 <ski> @type stimes . (fromEnum :: Bool -> Int)
03:04:44 <lambdabot> Semigroup a => Bool -> a -> a
03:05:05 <kuribas> ski: that's in base?
03:05:15 <ski> dunno
03:05:27 <kuribas> @hoogle stimes
03:05:29 <lambdabot> Data.Semigroup stimes :: (Semigroup a, Integral b) => b -> a -> a
03:05:29 <lambdabot> Data.Semigroup.Compat stimes :: (Semigroup a, Integral b) => b -> a -> a
03:05:29 <lambdabot> Protolude stimes :: (Semigroup a, Integral b) => b -> a -> a
03:06:19 <ski> oh, `Data.Semigroup' is in `base', if that's what you were asking about
03:06:39 <kuribas> is Bool Integral?
03:06:45 <kuribas> > 0 : Bool
03:06:48 <lambdabot>  error:
03:06:48 <lambdabot>      • Data constructor not in scope: Bool :: [a]
03:06:48 <lambdabot>      • Perhaps you meant variable ‘bool’ (imported from Data.Bool)
03:06:50 <kuribas> > 0 :: Bool
03:06:53 <lambdabot>  error:
03:06:54 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘0’
03:06:54 <lambdabot>      • In the expression: 0 :: Bool
03:07:05 <kuribas> it isn't...
03:07:35 <ski> (hence the `fromEnum' ?)
03:09:53 <kuribas> hm I like condMono
05:42:00 <black0range> Hey guys, does current haskell hav any way to pass type as argument such that something like the following psuedo haskell would be possible? "foo :: (A :: Set) -> Integer; foo A = fromIntegral (maxBound :: A)"
05:43:00 <cocreature> black0range: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=typeapplications#extension-TypeApplications
05:43:38 <cocreature> you’ll need ScopedTypeVariables as well
05:43:57 <cocreature> "foo :: forall a. Integer, foo = fromIntegral (maxBound @a)"
05:44:25 <black0range> cocreature: Sweet, thanks! :) 
05:52:53 <ski> i think you want `(Bounded a,Integral a) => ' in there, as well
05:53:37 <black0range> ski: yeah, just trying to figure out how to write the signature :( Where do i put the contstraints?
05:54:22 <cocreature> forall a. (Bounded a, Integral a) => Integer
05:54:22 <ski> an alternative would be
05:54:23 <ski> % let foo :: (Bounded i,Integral i) => Proxy i -> Integer; foo (Proxy :: Proxy a) = fromIntegral (maxBound :: i)
05:54:24 <yahb> ski: ; <interactive>:55:97: error:; * Could not deduce (Bounded i1) arising from a use of `maxBound'; from the context: (Bounded i, Integral i); bound by the type signature for:; foo :: forall i. (Bounded i, Integral i) => Proxy i -> Integer; at <interactive>:55:5-55; Possible fix:; add (Bounded i1) to the context of; an expression type signat
05:54:35 <ski> % let foo :: (Bounded i,Integral i) => Proxy i -> Integer; foo (Proxy :: Proxy i) = fromIntegral (maxBound :: i)
05:54:36 <yahb> ski: 
05:54:39 <ski> (sorry)
05:55:10 <ski> % let foo (Proxy :: Proxy i) = fromIntegral (maxBound :: i)
05:55:11 <yahb> ski: 
05:55:18 <ski> ok, also works without type signature
05:55:23 <black0range> https://paste.ee/p/R78lt
05:55:23 <ski> % :t foo
05:55:23 <yahb> ski: (Integral i, Bounded i, Num b) => Proxy i -> b
05:55:53 <black0range> I get a could not deduce integral a0 error 
05:57:49 <ski> % let foo :: forall i. (Bounded i,Integral i) => Integer; foo = fromIntegral (maxBound @i)
05:57:50 <yahb> ski: 
05:57:59 <ski> hm, that works with yahb
05:58:23 <cocreature> black0range: you need AllowAmbigousTypes
05:58:32 <cocreature> *AllowAmbiguousTypes
05:58:43 <cocreature> which should be part of the error message GHC gives you
05:59:20 <ski> ah, right
05:59:28 <black0range> Ah yes, sorry should have read the error message properly
06:09:21 <black0range> Unrelated question btw: I'm thinking about applying for a Phd in theoretical computer science with some kind of specialization related to functional languages / type theory. Does anyone good tips on universites / professors to contact and talk to?
06:09:59 <merijn> black0range: Depends on the location, I suppose
06:11:34 <black0range> merijn: Good point, I'm Swedish but willing to relocate, somewhere in europe would of course be ideal however it's not a must
06:11:55 <merijn> black0range: Tbh, there's some pretty good universities in Sweden for functional FP stuff
06:12:00 <merijn> Chalmers, for one
06:13:05 <black0range> Yeah Chalmers is already on my list :) What others are you thinking about?
06:14:57 <merijn> I don't remember the name of others, tbh. But I recall there were 2 or 3 (including Chalmers) FP-ish universities in Sweden. Some stuff in Scotland whereever it was that Edwin Brady and Connor McBride are/were working
06:14:57 * ski . o O ( #haskell.se,#haskell.scandinavian )
06:17:49 <black0range> merijn: Thanks will have a look at those!
06:18:36 <black0range> ski: There are subgroups? :O 
06:32:47 <ziman> i think that strathclyde has phd positions open atm
06:34:31 <ziman> https://twitter.com/bentnib/status/1135494594345472000
06:36:01 <black0range> ziman: Thanks! Will have a look! 
06:39:43 <ziman> ...as long as you count the UK as "somewhere in europe" :)
06:44:08 <black0range> ziman: Well, i guess time will tell :) But the application site says the funding is avaiable for anyone in the uk / eu. 
06:46:59 <ski> black0range : subgroups ?
06:48:03 * ski thinks there are subgroups in group theory
06:48:45 <black0range> ski: ok ok, sub channels is the proper term :)
07:10:15 * anton-latukha[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/pdYVydxScAJAdnVGYzRNGxzg >
07:26:12 <literall1Crevice> What's the prettiest way to take the min of two things based on a function? min `on` func gives the result of running the func, and I want the actual thing
07:26:49 <lavalike> as opposed to f (min x y) ?
07:27:00 <merijn> :t minBy
07:27:03 <lambdabot> error: Variable not in scope: minBy
07:27:05 <merijn> hmm
07:27:35 <merijn> @hoogle (a -> a -> Ordering) -> a -> a -> a
07:27:36 <lambdabot> Data.ListLike zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result
07:27:36 <lambdabot> Data.ListLike.Base zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result
07:27:36 <lambdabot> Data.ListLike.Utils zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result
07:29:14 <ggole> Wouldn't you want Ord b => (a -> b) -> a -> a -> a?
07:29:24 <merijn> oh, maybe
07:29:53 <ggole> @hoogle Ord b => (a -> b) -> a -> a -> a
07:29:54 <lambdabot> No results found
07:29:56 <merijn> Regardless it doesn't seem to exist, which is weird
07:29:57 <ggole> Hmph.
07:29:59 <ggole> Yeah.
07:30:44 <hpc> :t \f -> head . sortBy f
07:30:48 <lambdabot> (c -> c -> Ordering) -> [c] -> c
07:31:08 <hpc> > head . sortBy (`mod` 3) [6, 5]
07:31:11 <lambdabot>  error:
07:31:11 <lambdabot>      • Couldn't match expected type ‘a -> [c]’
07:31:11 <lambdabot>                    with actual type ‘[Integer]’
07:31:25 <merijn> hpc: I would *definitel* not call that the prettiest way :p
07:31:28 <lavalike> :t \f x y -> let (_,r) = min (f x,x) (f y,y) in r
07:31:30 <hpc> heh
07:31:31 <lambdabot> (Ord a, Ord b) => (b -> a) -> b -> b -> b
07:31:41 <merijn> literall1Crevice: I think you'll have to roll your own
07:31:54 <literall1Crevice> Yeah, I went the if/then/else route for this one
07:32:42 <merijn> literall1Crevice: You can do something nice with guards to make it cleaner
07:32:48 <merijn> But that's about it
07:38:42 <lavalike> > (\f x y -> snd $ getAlt $ min (Alt (f x, x)) (Alt (f y, y))) negate 1 10
07:38:48 <lambdabot>  10
07:39:10 <lavalike> argh still Ord b
07:41:11 <lavalike> I was wondering if there was an Ord instance that only looked at half the tuple
07:45:20 <int-e> lavalike: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Semigroup.html#t:Arg
07:46:08 <lavalike> int-e: appreciate it
07:46:58 <int-e> tbh I have no clue how to find this if one doesn't know about it already.
07:47:15 <lavalike> I couldn't!
07:49:18 <lavalike> :t \f x y -> let (Arg _ r) = getMin $ Min (Arg (f x) x) <> Min (Arg (f y) y) in r
07:49:20 <lambdabot> Ord a => (b -> a) -> b -> b -> b
07:54:28 <aveltras> anyone successfully using the base-noprelude method to use the relude package ?
07:55:02 <ski> @type \f x y -> let Arg z _ = getMin (((<>) `on` Min . liftA2 Arg f id) x y) in z
07:55:04 <lambdabot> Ord a1 => (a2 -> a1) -> a2 -> a2 -> a1
08:03:19 <lavalike> ski plus plus
08:05:17 * ski minus minus
08:05:41 <lavalike> I know I know
08:07:48 * monochrom times times
08:08:11 <monochrom> Oh hey what do you think if I improved Fortran and called it Fortan** >:)
08:08:17 <monochrom> err Fortran**
08:08:45 <hpc> Dowhiletran
08:14:36 <Lears> % :t liftA2 (<*>) bool . ((<) `on`)
08:14:36 <yahb> Lears: Ord a => (b -> a) -> b -> b -> b
08:14:45 <Lears> Just writing that makes me feel evil.
08:46:53 <hyperisco> Lears, you mean comparing?
08:47:47 <hyperisco> I suppose that is Ordering, lets think
08:48:55 <Lears> It looks similar but that's `maxBy`, following on from the discussion above.
08:57:48 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f  -- is something else
08:57:49 <lambdabot>  Defined.
08:57:54 <ski> @type comparing
08:57:57 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
08:58:51 <ski> @type minimumBy
08:58:52 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
08:58:54 <dminuoso> Lears: And here I was, thinking if/then/else was not available as function.
08:59:07 <dminuoso> Thanks, ⌜bool⌝ is a useful thing. :)
10:01:37 <wroathe__> window 4
11:01:15 <wildtrees> how do I apply a function n times, its not iterate ? 
11:04:47 <ski> @type let applyTimes f i x = iterate f x !! i in applyTimes
11:04:49 <lambdabot> (a -> a) -> Int -> a -> a
11:04:59 <ski> @type let applyTimes' f i x = iterate' f x !! i in applyTimes'
11:05:01 <lambdabot> (a -> a) -> Int -> a -> a
11:11:41 <orzo> I'm using a bang pattern in a where clause that looks like this: !nlegs = fromIntegral $ length legs.  I intend to use the result in a lazy field of a constructor, but i want the legs list consumed early rather than hanging about in a closure.  Is the bang pattern sufficient or do I need to use seq?
11:20:24 <orzo> experiment seems to indicate bang is sufficient.  I wish i was more clear when patterns were lazy or strict
11:25:40 <ski> are you using `nLegs' ?
11:28:48 <Cale> orzo: Pattern bindings are lazy (as if they had ~ on the front of them) by default, unless you explicitly add in a ! which mysteriously transforms the let into case (which I've found unusual ever since it was done)
11:29:10 <cocreature> orzo: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#dynamic-semantics-of-bang-patterns
11:31:33 <Cale> Patterns in function arguments are strict when they explicitly match against a constructor, or when they have a ! on the front of them.
11:32:31 <ski> > case undefined of Identity _ -> ()
11:32:33 <lambdabot>  ()
11:33:46 <orzo> it's where clause patterns that i'm confused with
11:34:08 <Cale> ski: ah, good point, newtype constructors don't count :)
11:34:14 <orzo> the bang makes it strict, but what if i did not even use the bound-variable?  Would it still be evaluated?
11:34:28 <ski> yes
11:34:31 <Cale> orzo: It would have to be, yes
11:34:37 <ski> > let !_ = undefined in ()
11:34:40 <Cale> Otherwise, it wouldn't have been strict in the first place
11:34:41 <lambdabot>  *Exception: Prelude.undefined
11:35:04 <orzo> let x = () where !_ = undefined
11:35:09 <orzo> > let x = () where !_ = undefined
11:35:13 <lambdabot>  <no location info>: error:
11:35:13 <lambdabot>      not an expression: ‘let x = () where !_ = undefined’
11:35:17 <ski> > let x = () where !_ = undefined in x
11:35:20 <lambdabot>  *Exception: Prelude.undefined
11:35:28 <ski> > let f !_ = () in f undefined
11:35:35 <lambdabot>  mueval-core: Time limit exceeded
11:35:42 <ski> bah
11:36:19 <orzo> > case () of () where !_ = undefined
11:36:23 <hyperisco> Where can we donate to double the lambdabot timeout
11:36:23 <lambdabot>  <hint>:1:15: error: parse error on input ‘where’
11:36:34 <orzo> > case () of () -> () where !_ = undefined
11:36:37 <lambdabot>  *Exception: Prelude.undefined
11:37:08 <hyperisco> … or make it twice as fast
11:38:57 <sarahzrf> :t bool
11:38:59 <lambdabot> a -> a -> Bool -> a
11:40:35 <merijn> hyperisco: I forgot who was hosting, but you'd have to discuss with them :p
11:45:40 <hyperisco> last time I did that for lpaste it wasn't a money issue but an effort issue
11:46:06 <hyperisco> well I guess at a certain level of funding you could pay someone to maintain it
11:46:44 <merijn> hyperisco: Lambdabot just runs on some cheap VPS
11:47:04 <merijn> I recall a discussion this or last week about looking for a new host, due to the weird latency spikes with the VM
11:47:53 <hyperisco> eh well depends who it is with
11:48:05 <hyperisco> you can get dedicated cores and memory
11:48:35 <merijn> Right, but those are less cheap :p
11:48:45 <hyperisco> I dunno, $5/mo?
11:49:12 <merijn> $5/mo won't get you dedicated cores/memory
11:49:45 <hyperisco> says who
11:49:51 <Lycurgus> where?
11:49:59 <merijn> hyperisco: Where? Because then I'd immediately switch :)
11:50:03 <hyperisco> I think many places do
11:50:06 <hyperisco> well where is it running now
11:50:24 <hyperisco> I had a VPS with upcloud at one point and they said that is what they do
11:50:27 <Lycurgus> 5 usd for 1 virtualized core, yeah
11:50:33 <Lycurgus> but that's not dedicated
11:50:51 <hyperisco> mm
11:50:54 <hyperisco> I'll dig up the email
11:51:40 <Lycurgus> also dumbasses with loss leaders that stay in biz for a few months don't count
11:51:49 <Lycurgus> *small time dumbasses
11:52:03 <merijn> Lycurgus: Yeah, that's what kept happening to me
11:53:14 <hyperisco> alright I think they only said "reserved resources" which doesn't imply dedicated
11:54:38 <hyperisco> that can just be saying they haven't oversold the crap out of the server your vm is on
11:54:40 <Lycurgus> capitalists are generally dull, transparent jerks
11:54:59 <hyperisco> yeah I guess Vultr has dedicated starting at $60/mo
11:55:13 <Lycurgus> you'd think their intellectual superiors would be able to deal with em but au contraire
11:55:27 <hyperisco> well tell you what, if it is really a problem, I have a computer running out of my apartment… no ECC memory, and residential Internet, but it'd be free ;)
11:55:35 <Lycurgus> i got over the dedicated fetish
11:55:46 <Lycurgus> got dedicated/real machines at home
11:56:02 <Lycurgus> about 3 ya
11:56:26 <hyperisco> well you get shared machines and you're at the mercy of the other users
11:56:46 <Lycurgus> (i.e stopped buying dedicated, ovh was last I tried actually think that was last year)
11:56:51 <hyperisco> no question lambdabot is suffering
11:57:23 <Lycurgus> not really, not on a 1st class operation like linode or AWS
11:57:51 <Lycurgus> some bumfuc operation, yeah maybe
11:58:35 <hyperisco> why is linode expected?
11:58:37 <hyperisco> excepted
11:59:19 <Lycurgus> i realized I was payin thru the nose for hosts where I rarely had more than 5% utilization
11:59:48 <Lycurgus> with virtualized ones I still have same utilization but not paying thru nose
12:00:02 <Lycurgus> dont wanna pay thru nose
12:00:25 <Lycurgus> for something I'm not even using
12:00:34 <hyperisco> Does Linode not charge for servers that are off?
12:00:49 <hyperisco> Or what exactly is the cost saving difference?
12:01:20 <Lycurgus> what's the point of a data center host that isn't on 24/7?
12:01:34 <hyperisco> Because the prices are pretty standard across the board, be it DO or Linode or Vultr or Upcloud or w/e… AWS is more pricey
12:01:52 <Lycurgus> i do that at AWS but basically because the AWS account is just to test ops there
12:02:09 <Lycurgus> it's less than 1 USD/mo with the S3 bucket
12:02:25 <hyperisco> Are you talking about serving static files?
12:02:33 <Lycurgus> but to answer the question
12:02:45 <Lycurgus> no, linode went to hourly billing a while back
12:02:58 <Lycurgus> so if the server is off you only pay for the storage
12:03:45 <hyperisco> A few do hourly billing… however with Upcloud you pay full price on or off, unless you switch to a "flexible" plan which is 50% more, about
12:03:59 <hyperisco> Maybe it is just Upcloud that is a bit screwy with how they do pricing
12:04:07 <Lycurgus> also if you need to do an experiment with like a 48 core host you can do that economically at AWS
12:05:00 <hyperisco> I figured out that they don't really tell you all the nuances up front :P
12:05:48 <Lycurgus> also the flexibility of virtualized hosting in great, just shut down, by more cores/memory, and reboot
12:05:57 <Lycurgus> *is great
12:06:02 <hyperisco> What I figured out is that if the several 9's of reliability isn't important then just running a server residentially can be way cheaper
12:06:39 <Lycurgus> that what a lot of people who aren't computing professionals seem to think
12:06:59 <hyperisco> … well I did several cost calculations. It depends on what one is trying to do.
12:07:06 <Lycurgus> that they can run their idea out of their home hosts and residential ISP
12:07:31 <Lycurgus> which I did to till maybe a decade or a lil more ago
12:07:36 <Lycurgus> *did too
12:07:56 <Lycurgus> *that's what
12:08:23 <hyperisco> I'm saying if you're doing hobbyist stuff, not professional
12:08:32 <Lycurgus> *buy more
12:09:23 <hyperisco> I bought a machine for $400 that is equivalent to about a $120/mo VPS
12:10:00 <Lycurgus> you have a fiber level ISP?
12:10:06 <hyperisco> yes
12:10:15 <Lycurgus> ah well that makes a diff
12:10:47 <hyperisco> another advantage of VPS is you can choose different locations, to minimise latency
12:11:34 <Lycurgus> yeah but there's a penalty if you spread functions across hosts and they communicate across distant data centers
12:11:51 <hyperisco> sure
12:12:09 <Lycurgus> at linode the inter center ping is sub millisecond
12:12:34 <Lycurgus> but it's a like 20 ms across distant centers
12:13:40 <Lycurgus> so i only have smtp and git at a separate center
12:14:05 <Lycurgus> db clusters wanna be in same center
12:14:32 <cocreature> this discussion seems to have moved outside of #haskell territory
12:15:08 * Lycurgus looks at hyperisco 
12:15:27 * hyperisco shrugs
12:18:59 <turab> I can't find the default implementation of (<|>) for IO. Is this the wrong place for that? http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Alternative
12:19:16 <hyperisco> Is there such a thing?
12:20:00 <turab> For IO, mplus = (<|>) which makes sense, but not sure what's the default for (<|>)
12:20:20 <hyperisco> :t print "Hello" <|> print "World!"
12:20:22 <lambdabot> IO ()
12:20:29 <hyperisco> interesting…
12:20:36 <cocreature> turab: for IO (<|>) = mplusIO
12:20:41 <cocreature> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-1371
12:21:09 <hyperisco> I am mildly concerned over what the implementation is
12:21:14 <turab> Thanks cocreature
12:21:31 <cocreature> I’m not really sure what you mean by “default implementation for IO”. IO has only one implementation for (<|>), there is no “non-default” implementation
12:22:34 <cocreature> hyperisco: a <|> b will try a and if it throws an IOException it will try b
12:23:17 <hyperisco> I am just not familiar with exceptions
12:23:49 <hyperisco> > empty :: IO ()
12:23:52 <lambdabot>  <IO ()>
12:24:07 <hyperisco> well obviously that has to throw then
12:24:31 <cocreature> one example where this is useful is if you have a bunch of locations for a file and you want to read from the first one that exists
12:24:40 <cocreature> lambdabot doesn’t execute IO
12:24:45 <cocreature> % empty :: IO ()
12:24:46 <yahb> cocreature: *** Exception: user error (mzero)
12:25:01 <cocreature> % empty <|> putStrLn "hello" :: IO ()
12:25:02 <yahb> cocreature: hello
12:25:06 <turab> I think I got confused by MPlus instance of IO and thought there is some default for (<|>). Me saying "default implementation for IO" was simply a mistake
12:25:44 <hyperisco> I thought people were on about these async exceptions or something
12:26:29 <hyperisco> anytime IO gets equivocated to serial instructions someone bashes that down
12:27:03 <turab> cocreature: Your example usage of mplus made me realize I was going for the wrong option
12:27:18 <cocreature> IOException is usually a synchronous exception
12:31:22 <turab> @pl \n -> guard $ n > 0
12:31:22 <lambdabot> guard . (> 0)
12:33:47 <ski> apparently `(<|>)' doesn't catch imprecise exceptions ?
12:34:42 <cocreature> as I said, it catches IOException
12:40:41 <cocreature> oh I see what you are saying
12:40:53 <cocreature> yeah, it forces the action before calling `catch`
12:40:58 <higherorder> Hi! Quick sanity check: `\f -> (sequenceA . fmap f)` is equivalent to `traverse`, right?
12:45:35 <turab> higherorder: If I remember correctly, that's how traverse is defined
12:45:52 <higherorder> turab: yeah actually I just looked up the source code; ty!
12:49:10 <turab> Is there a better way to verify that given numbers are within an expected bounds. I don't like how I am doing it: https://github.com/trajafri/tromino-tile/blob/a4feec77092d27fe42adba624fcda2e3d0aa7d8c/src/Main.lhs#L211
12:49:45 <turab> verify might be a strong word to use there
12:53:28 <cocreature> there is an inRange helper in Data.Ix which is even in base but nobody seems to use Data.Ix (probably because it was mainly intended for `array` and most people use `vector` instead these days)
13:13:26 <zeta_0> have any of you guys tried the `ihaskell` package? is it very useful?
13:15:11 <merijn> I've heard of it, no clue how useful it is
13:15:33 <merijn> But, I've never found ipython/notebook style stuff that useful either, tbh, so I might be the wrong person to ask :p
13:17:09 <dminuoso> jle`: So I've thought about what a monoid in the category of endofunctors equipped with Sum and Product would mean. The Product case (with Proxy as identity on the tensor) seems to give me a Monoid, whereas Sum seems to be a quirky Identity.
13:17:55 <dminuoso> jlamothe: This is the code, https://gist.github.com/dminuoso/86a576898e06763b9011646a80863e4a
13:18:43 <zeta_0> i hope `ihaskell` will make a good repl
13:19:56 <zeta_0> can i add functionality to ghci like autocompletion for parenthesis and braces, and autocompletion for syntax, that would make it a little easier to use as a repl
13:21:24 <moet> what's your favorite library that includes a proper-fraction type, a numeric value that ranges from 0..1
13:21:24 <dminuoso> zeta_0: Technically sure, it's "just a Haskell program". As for the effort...
13:22:58 <dminuoso> zeta_0: In the end Haskell is not well suited for repl. What exactly is it that you want?
13:37:57 <merijn> zeta_0: tbh, I almost never use the repl except for quickly looking up types and testing short snippets
13:38:27 <dminuoso> merijn: One might argue that it's also an artifact of GHCi not being the nicest of all tools.
13:38:58 <dminuoso> It's like we argue how well ghcid is, but in the end it's just because we don't have any superb emacs integration that "just works"
13:39:29 <merijn> dminuoso: tbh, I don't really like ghcid
13:39:37 <merijn> So I'd never argue that :p
13:40:05 <dminuoso> merijn: It's really useful to have it running - just to get faster feedback on errors you make.
13:40:13 <Rembane> Does this imply that we can never make GHCi better? 
13:40:15 <dminuoso> Unless you happen to use HSP or some equivalent..
13:40:25 <merijn> dminuoso: It takes up too much terminal space
13:40:35 <dminuoso> merijn: Get a bigger desk, will you.
13:40:56 <dminuoso> Google Glass would have been awesome for ghcid.
13:40:58 <merijn> dminuoso: I have a WIP (ghcid-the-library based) tool for myself, but I don't have a lot of time to devote to it
13:41:15 <dminuoso> merijn: You can rig ghcid into emacs with relatively little trouble.
13:41:30 <merijn> dminuoso: My desk is plenty big, but an entire terminal column for ghcid I'd rather spend it on irssi or another editor
13:41:33 <merijn> dminuoso: I don't use emacs
13:42:29 <dminuoso> merijn: Surely it could be done in vim too.
13:43:01 <merijn> dminuoso: Sure, but if I had the time to figure out how I might as well fix my own thing :)
13:46:43 <turab> dminuoso: How do you use ghcid? I just run ghcid in a shell but I would like to know if there are better ways
13:55:32 <dminuoso> turab: https://github.com/ndmitchell/ghcid/blob/master/plugins/emacs/ghcid.el this can be trivially adjusted to your needs.
13:55:43 <dminuoso> Then you just have a buffer to worry about.
13:57:00 <dminuoso> turab: The cool thing is you get things like jumping to offensive source locations from compilation mode for free.
13:58:51 <turab> Aye neat! I will give this a shot
14:02:57 <zeta_0> dminuoso: well just to quickly copy and paste haskell code and execute it, that way i can quickly experiment with code while i am learning haskell
14:04:21 <zeta_0> i just finished watching this youtube video on `ihaskell`, it looks very useful: https://www.youtube.com/watch?v=nYBW4ExtNvo
14:05:51 <merijn> zeta_0: Usually I will just do that in an open file and then reload set file in ghci
14:06:16 <merijn> zeta_0: That works fairly well for experimention, since you got all your regular editor conveniences too
14:07:18 <zeta_0> merijn: i do that too, but `ihaskell` looks like it will make things easier and simpler
14:09:03 <merijn> Ok, hope it works for you :)
14:09:51 <zeta_0> thanks, you too
14:45:40 <dave_uy> How do I determine what type of exception is being returned from a library function?
14:46:38 <dave_uy> print e just prints "FILE" where e :: SomeException
14:48:29 <dave_uy> Nevermind, I see now that FILE is the exception after looking at the docs for the library.
15:11:56 <sarahzrf> haha
15:26:19 <d34df00d> Hi!
15:26:38 <d34df00d> I'm thinking about the deployment process of my haskell stuff, and I've come across https://www.fpcomplete.com/blog/2017/12/building-haskell-apps-with-docker
15:26:53 <d34df00d> So, what assumptions does ghc make about the target CPU when it generates code?
15:27:24 <d34df00d> Can I build my code on a powerful Core i7 with all the recent x86 extensions and then run it on an older CPU?
15:35:44 <orzo> i7 is still considered powerful with all recent extensions?
15:35:57 <orzo> i've had my i7 for like 8 years
15:36:49 <orzo> d34df00d: yes you can. If it's compiled for 64-bit x86, then it will run on any such
15:37:13 <orzo> assuming you have the run-time depends
15:37:17 <d34df00d> Dunno I still run i7 3930k and I just started considering upgrading (to Ryzen 3 though)
15:37:20 <d34df00d> orzo: thanks!
15:37:29 <d34df00d> I guess stack docker willl sort the deps for me.
15:38:04 <orzo> is it for a linux server?
15:38:37 <orzo> probably libc will be different and be your real issue
15:38:57 <orzo> compile on an os that is as old or older than your target
15:39:02 <d34df00d> Yeah. Although it all runs gentoo so everything might be a bit ddifferent.
15:40:00 <d34df00d> I used to wrap my haskell apps into whatever the package manager supports, but I realized it just does not scale wrt the amount of haskell library dependencies (which I also have to wrap to do things right).
15:41:17 <orzo> make a chroot with your gentoo target and install ghc there
15:41:33 <orzo> then you can upload binaries to the server
15:57:49 <nathan-yukai> Hello Haskellers! I'm playing with Network.Socket, however I can't seem to find the 'withFdSocket' method, while the library documentation says it exist, anyone had similar problem? Thanks in advance
15:58:36 <EvanR> must be a version mismatch
15:58:55 <slack1256> https://hackage.haskell.org/package/network-3.1.0.1/docs/Network-Socket.html#v:withFdSocket
15:59:08 <slack1256> At least on network-3.1.0.1 exists
16:00:25 <nathan-yukai> but I got the same variable not in scope error even if I put network >= 3.1 in cabal
16:01:49 <EvanR> maybe you didn't import it
16:01:52 <slack1256> You're right, I imported Network.Socket and I don't have it available
16:03:02 <nathan-yukai> Thanks for the confirmation! 
16:04:44 <slack1256> Maybe it's not exported when it should be so? I am checking Network/Socket.hs now
16:05:07 <EvanR> so haddocks must be wrong
16:06:14 <nathan-yukai> It looks like it's exported( on github) how strange
16:06:21 <slack1256> Sorry! The network package version I was using is `network-2.8.0.1`. I didn't confirm anything!
16:06:53 <slack1256> But yes on Network.Socket `withFdSocket` it's exported
16:10:13 <nathan-yukai> it's only exported on version 3.1.0.1, not even 3.1.0.0 . However i'm specifying network>=3.1.0.1 now, and it still can't find it :(  
16:10:54 <EvanR> 3.1.0.0 haddock shows it exported
16:13:40 <nathan-yukai> Ah you are right, I'm saying that because I saw this change : https://github.com/haskell/network/commit/bbfbfc37d217d0bc5c1388d7e478f993589c80e0#diff-c10718b81fd35daeb0e6d4d78b6dbe92
16:22:57 <nathan-yukai> Ah I solved my problem. Basically I was using ghcid, so when I add the version constraint, it didn't warn me like 'stack build' would do.
16:23:22 <nathan-yukai> I need to add it in extra-deps :face_palm
16:23:41 <slack1256> lol
16:28:19 <nathan-yukai> I'm fairly surprised that it didn't default to the latest version though. Sign at stack
16:29:58 <nathan-yukai> sigh*
17:57:27 <panda_man> >
18:02:55 <panda_man> Hello
18:08:52 <solonarv> panda_man: hello!
18:13:37 <turab> Hello, I tried installing hlint after reinstalling ghc/cabal using ghcup but no idea why cabal is having issues resolving dependencies: https://gist.github.com/trajafri/179a4b9ef675c89eed9b327bbbf2b1fc
18:15:12 <solonarv> turab: hmm, it looks like hlint wants process-1.6.5.1 but you have process-1.6.5.0, and since process is bundled with GHC it isn't possible to use a different version
18:15:21 <turab> Looks similar to this I think: https://gitlab.haskell.org/ghc/ghc/issues/16199
18:16:00 <solonarv> yup, that looks related
18:16:00 <dmwit> What version of hlint are you trying to install? The latest one doesn't place any constraint on process.
18:17:50 <dmwit> I remember some time ago finding a package which provided an abstraction over STRef and IORef that would pick the right one for whichever of the two related monads it was run in.
18:18:04 <dmwit> I'm having a tough time finding it now, though; anybody know off-hand what I'm thinking of?
18:18:34 <solonarv> btw, the "sledgehammer" solution is to simply add '--allow-newer=process' to your cabal invocation, which allows the version bound to be ignored
18:19:25 <dmwit> But it's already demanding a too-new version, so how would allow-newer help?
18:19:38 <solonarv> whoops, I meant to type --allow-older ;)
18:19:50 <jackdk> dmwit: there are a few, but I think this is the most recent: https://hackage.haskell.org/package/ref-tf
18:20:08 <dmwit> jackdk: Thanks!
18:20:31 <turab> Tried the latest version and some others between 2.0 and latest. All are having similar issues
18:21:22 <dmwit> Yooo, it even does STM+TVar. Cute!
18:21:27 <turab> By latest I mean 2.2.2
18:21:50 <dmwit> (That seems super dangerous, though. Imagine accidentally using your MonadRef-polymorphic action in IORef and not getting synchronization.)
18:22:52 <dmwit> turab: I find that pretty odd. Is there any chance you're in the context of a cabal.project, cabal.project.local, or cabal.freeze file?
18:22:56 <solonarv> wouldn't that be a problem with *anything* that's polymorphic over IORef and STRef ?
18:23:12 <dmwit> Neither IORef nor STRef offer synchronization, so... no?
18:23:36 <solonarv> oh, do you mean because that particular package also has an instance for STM ?
18:23:52 <dmwit> Yes, which is why it was a follow up to "oh, it even does STM". =P
18:23:57 <solonarv> I see
18:24:01 <turab> dmwit: I tried in directories with no .cabal files and run into same issues
18:24:30 <solonarv> I think you would use this when you don't care about synchronization, and so if you happen to get sync anyway that isn't really a problem
18:24:47 <dmwit> (For what it's worth, I also find it odd that it considers process to be a user goal.)
18:25:10 <turab> That part confused me too
18:25:55 <solonarv> also worth noting that TVar is synchronized and STRef is sort of synchronized in that it cannot be sent to a different thread without unsafe* functions
18:26:25 <dmwit> turab: Oh, I have a guess, actually!
18:26:44 <dmwit> turab: Perhaps the way new-install works is to take the currently set of installed package/version pairs and set them as constraints, in addition to whatever you request.
18:27:07 <dmwit> turab: So it reports all the currently-installed packages as user goals.
18:27:28 <solonarv> that seems unlikely, because then it would never be able to install multiple versions of the same package
18:27:48 <dmwit> Err, does new-install allow that to happen?
18:27:56 <solonarv> it damn well should!
18:28:02 <dmwit> Are you sure?
18:28:22 <dmwit> N.B. I'm talking about the new-install library "sandbox", not the store.
18:28:22 <solonarv> the whole point of new-style is allowing multiple versions of the same package to be installed without crosstalk
18:28:38 <dmwit> That's the store. I'm not talking about that, where obviously it must allow multiple versions.
18:28:49 <solonarv> ah, then I agree with you
18:28:54 <turab> Wait there something other than the store?
18:29:00 <turab> there's*
18:29:05 <solonarv> yes, which is managed by new-install
18:29:08 <dmwit> Okay, so my hypothesis is that you've new-install'ed --lib process at some point in the past.
18:29:18 <dmwit> That was no problem until now, because no package needed both the ghc package and the process package.
18:29:21 <solonarv> 'cabal new-install' builds an executable and symlinks it
18:29:32 <dmwit> But now suddenly hlint needs it, and it is trying v. hard to select the version you new-install'd.
18:29:46 <solonarv> 'cabal new-install --lib' builds a library and adds it to an environment file GHC can pick up
18:29:55 <dmwit> This explains why base, ghc, process, etc. are considered user goals, and why you have a constraint that hlint doesn't make.
18:30:04 <turab> 100% correct
18:30:10 <turab> I think I did do that today
18:30:14 <dmwit> Great!
18:30:26 <dmwit> Now we just need solonarv to tell us how to cabal uninstall --lib process. ;-)
18:30:26 <turab> Good thing I ran into issues on the same day
18:30:47 <solonarv> it seems a bit odd that new-install --lib would interfere with new-install
18:31:00 <dmwit> It does. I might even consider it a bug.
18:31:15 <dmwit> Although I can see how somebody else might consider it a feature.
18:31:42 <solonarv> hm, maybe try adding '--constraint=process==1.6.5.1' to the command line to tell cabal that yes, you really do want it to use that version?
18:31:50 <dmwit> 1.6.5.0 *
18:32:09 <solonarv> 1.6.5.0 is the installed version
18:32:14 <turab> Checked my history and turns out it was both build and install with --lib.
18:32:28 <dmwit> solonarv: "constraint from user target requires ==1.6.5.1"
18:32:34 <solonarv> hm
18:32:40 <solonarv> try both I guess?
18:32:43 * solonarv shrugs
18:32:44 <dmwit> solonarv: So if my hypothesis is correct, 1.6.5.1 is the broken one, 1.6.5.0 (which shipped with GHC) is fine.
18:33:22 <dmwit> (Both are "installed" in different places -- one in the global package database, one in the cabal "new-sandbox" database.)
18:35:08 <turab> 1.6.5.1: rejecting: process-1.6.5.1 (conflict: ghc =>
18:35:10 <turab> process==1.6.5.0/installed-1.6...)
18:35:19 <turab> rejecting: process-1.6.5.1 (constraint from command line flag requires
18:35:21 <turab> ==1.6.5.0)
18:35:29 <dmwit> It probably isn't sensible to have process-1.6.5.1 installed in your new-database.
18:35:41 <dmwit> I don't know the new-install stuff well enough to tell you how to excise it, though.
18:36:59 <dmwit> From the documentation, perhaps deleting ~/.ghc/$ARCH-$OS-$GHCVER/environments/default is sufficient (though certainly is more than is necessary).
18:37:28 <solonarv> it's a plaintext file, you can edit it
18:37:40 <solonarv> (and just remove the one offending line, whatever it is)
18:37:55 <turab> Oh let's see if that works
18:39:31 <dmwit> (You should not need the additional --constraint afterwards.)
18:39:52 <turab> Bing?
18:39:58 <turab> Bingo
18:40:00 <turab> I think
18:40:04 <dmwit> Yay!
18:40:11 <turab> I didn't know about --lib doing that
18:40:27 <turab> Thank you so much, learned a few more things about cabal :)
18:40:32 <dmwit> I encourage you to consider reporting this as a bug. install --lib and install --executable shouldn't step on each others' toes like that.
18:41:19 <dmwit> Or maybe it should, I don't know; but it's definitely hecking confusing, and the cabal devs should be informed that it's hecking confusing so that they can make an informed decision about whether to keep that "feature".
18:41:35 <solonarv> I agree
18:41:45 <solonarv> Someone Else (Who Is Not Me) should open an issue
18:42:13 <turab> I can try but since I am new to cabal, it might be difficult for me to communicate the issue with the devs
18:42:43 <solonarv> that is valuable data: you are a newcomer and you were confused by this
18:43:36 <turab> Cool. I will give it a shot
18:51:21 <turab> dmwit: From cabal help, new-install --executable doesn't seem to be an option (there is executables which is for Haddock)
18:52:16 <turab> Just trying to understand what you said above about new-install --lib and --executable
18:57:07 <dmwit> I meant new-install with --lib and without --lib.
19:00:23 <turab> Ahh okay
19:21:16 <turab> Ha, my first issue. Feelsgud
20:35:42 <arsdragonfly> hey, how am I supposed to send EOF to a running program in ghci?
20:36:26 <Cale> arsdragonfly: Did you start that program? There are ways to run the program that will get you its stdin
20:36:28 <arsdragonfly> say if I run "interact id", nothing would happen if I press ctrl-d
20:36:37 <Cale> oh
20:37:23 <Cale> Well, interact doesn't come with any stopping condition.
20:38:54 <mpiechotka> @pl \s -> id =<< ((lift .) <$> view isObstruent ?? s)
20:38:54 <lambdabot> join . ((lift .) <$>) . (view isObstruent ??)
20:41:51 <sarahzrf> :t isObstruent
20:41:52 <lambdabot> error: Variable not in scope: isObstruent
20:41:56 <Cale> arsdragonfly: You can ctrl-C, but then you'll find that it kills ghci because stdin got semi-closed by the getContents inside the implementation of interact
20:42:53 <arsdragonfly> yup looks like it is
20:47:38 <Cale> It is interesting that ctrl-D doesn't seem to have its usual effect.
20:47:46 <Cale> I think that has something to do with the buffering mode
20:48:30 <Cale> yeah, if I  hSetBuffering stdin LineBuffering  before I do the  interact id  it'll have the same effect as Ctrl-C does.
20:49:22 <Cale> Unfortunately, interact semi-closes stdin, so no further input can happen after it.
20:49:39 <Cale> (including input to ghci, since it's all in the same process)
