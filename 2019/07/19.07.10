00:23:01 <Saulzar_> Is there any library which has a data structure for Maps with custom compare function? i.e. not an Ord instance 
00:25:24 <Axman6> what do you want the types to look like?
00:25:34 <yushyin> can you not just newtype your existing types for a different ord instance?
00:26:43 <Saulzar_> I have quite a few different compare functions I'd like to be able to use with the one type
00:27:39 <Saulzar_> I guess without a key you can't look up the item, which is problematic.
00:27:48 <Axman6> yes...
00:28:32 <Axman6> You can have write only maps if you like =)
00:28:58 <jle`> Saulzar_: the most sane way would be to use a newtype wrapper on the type, yeah
00:29:13 <Saulzar_> I'd like something ideally to be multi-indexed with a key and an ordering - I know there are multi-index containers for this. Maybe that would do actually, I can create a different kind of multi-index each time..
00:29:16 <jle`> Saulzar_: if there was an API that allowed you to pass a custom compare function, you'd run into coherence issues pretty quickly
00:29:33 <jle`> because you could pass a different compare function to look up on a map
00:29:43 <jle`> but the map would already be organized based on the previous compare function
00:29:59 <Axman6> the same coherence issues you run into with Scala implicits
00:30:01 <jle`> so it's clear that for any given type and any given map you'd only ever want to use one compare function throughout the entire lifetime of that map
00:30:12 <Saulzar_> Right
00:30:14 <jle`> which is something you can enforce via a newtype
00:30:26 <jle`> Saulzar_: you might be looking for a priority search queue
00:30:35 <jle`> Saulzar_: it allows for fast lookups on *two* keys
00:30:42 <Axman6> "How are your keys ordered?" "Let me look at the order of my imports in all my files and I'll tell you"
00:31:14 <jle`> so for a PSQueue it's basically like a `Map k1 k2 a`, where insert takes (k1, k2), but you can lookup using only one or the other
00:31:30 <jle`> and both lookups are fast-ish, optimized for different use cases
00:31:58 <jle`> lookupK1 :: Ord k1 => k1 -> PSQueue k1 k2 a -> Maybe a; lookupK2 :: Ord k2 => k2 -> PSQueue k1 k2 a -> Maybe a
00:32:00 <jle`> (i'm simplifying)
00:32:36 <jle`> insert :: k1 -> k2 -> a -> PSQueue k1 k2 a -> PSQueue k1 k2 a
00:34:07 <jle`> http://hackage.haskell.org/package/psqueues
00:35:17 <jle`> hm i guess lookupK2 is limited to only "look up the minumum k2"
00:35:32 <Saulzar_> Oh yes, I've used PSQueue before actually... for doing search queues unsurprisingly.
00:35:47 <Saulzar_> I think maybe they're not totally ordered though, right? They're optimised for findMin I think?
00:36:01 <jle`> ah yeah, that's the thing i just said
00:36:10 <jle`> so you can't look up arbitrary k2
00:38:05 <jle`> but, is that sort of dual-key thing the thing you were looking for?
00:39:33 <Saulzar_> Yeah, I think so. I have a set of records which can be ordered on different fields, and occasionally some of them are updated - but at the moment I'm re-sorting them all the time and that's getting really slow with ghcjs
00:42:08 <jle`> hm, i'm not aware of any optimized data structure for that, but if you are doing mostly reads then maybe having two duplicated maps wouldn't be too bad
00:42:26 <jle`> (Map k1 a, Map k2 a)
00:43:17 <jle`> and just make sure that they are both consistent
00:43:23 <jle`> or (Map k1 (k2, a), Map k2 (k1, a))
00:43:57 <Axman6> data MultiMap [ks :: *] a where Single :: Map k a -> MultiMap [k] a; MMCons :: Map k a -> MultiMap ks a -> MultiMap (k ': ks) a -- >_>
00:45:04 <jle`> that's just the same as Map (k1, k2, k3) a
00:45:12 <jle`> you can't look up on only one key, you'd always need all three
00:45:23 <Axman6> sure youy can
00:45:44 <jle`> oh, i misread :)
00:45:55 <jle`> ah yeah, you'd still need to make sure things stayed consistent
00:45:58 <Axman6> lookup :: (Member k ks) => k -> MultiMap ks a -> Maybe a
00:46:16 <Axman6> yeah, though that's just part of the library
00:46:47 <Axman6> insert :: HList ks -> a -> MultiMap ks a -> MultiMap ks a
00:47:03 <Axman6> (I'm not suggesting this is a good idea)
00:47:40 <jle`> looks good, ship it
00:47:59 <jle`> type MultiMap ks a = Vinyl (Flip Map a) ks
00:48:08 <jle`> er, Ref (Flip Map a) ks
00:48:21 <jle`> er, Rec
00:48:22 <yushyin> maybe not balanced tree maps but hashmaps where the secondary key maps to the primary key?
00:55:51 <Saulzar_> There are a few libraries around using Typeable .. e.g. ixset - but that looks better. Thanks I'll probably give something like that a go.. you also need to be able to go from a -> (k, k' ...) if you want to be able to modify anything
00:56:02 <sicklorkin> Axman6: ixset-typed?
00:56:19 <Axman6> yeah I was pretty sure it must exist already
00:56:19 <sicklorkin> guess I'm late to the party 
00:57:25 <sicklorkin> and there was tables but that got canned afaik
00:57:54 <sicklorkin> https://hackage.haskell.org/package/tables
01:01:41 <Axman6> does GHC float definitions in where clauses which don't close over any arguments to a function so they only get evaluated once?
01:02:42 <Axman6> so, foo xs = ... where someConstant :: ByteString; someConstant = BS.pack $ someComputationNotInvolvingXS
01:03:25 <Axman6> in particular foo here is recursive
01:05:28 <jle`> i wouldn't rely on it
01:05:40 <sicklorkin> Axman6: this was discussed a while back I think.. i'm trying to find the historical logs for this irc channel but not sure where these live..
01:05:57 <sicklorkin> iirc the answer is no
01:05:58 <jle`> explicit sharing is better than implicit sharing
01:07:44 <sicklorkin> http://tunes.org/~nef/logs/haskell/ <- does this work for anyone?
01:07:45 <c_wraith> Axman6: it certainly can.  it can cause space leaks when it does, so it's awkward as to whether it's actually a good thing
01:08:58 <c_wraith> see https://gitlab.haskell.org/ghc/ghc/issues/12620
01:09:09 <dminuoso> sicklorkin: Nope it stopped working a while ago.
01:09:18 <dminuoso> sicklorkin: Havent been able to find out who was even responsible for it
01:09:48 <jle`> and chris done's public logs are gone too
01:09:53 <jle`> well those have been gone for years
01:10:16 <sicklorkin> dminuoso: someone in seattle?
01:10:52 <dminuoso> sicklorkin: What do you mean?
01:11:19 <sicklorkin> the machine is located in seattle
01:11:27 <sicklorkin> not sure if that's useful or not.
01:12:18 <dminuoso> A bit of digging reveals that some chrisdoner might be responsible for it.
01:12:27 <sm[m]> I have an idea tunes.org was Brian Rice
01:13:38 <dminuoso> sm[m]: Oh :)
01:13:40 <sicklorkin> id' be happy to put up a mirror if it's not going to eat up much of my time.. got lots of bw and disk space 
01:14:06 <sm[m]> email to Chris Done is probably a good bet. It would be nice to have good logs working again. Otherwise you can join the channel via Matrix to get a searchable log from the time you joined
01:15:49 <dminuoso> sm[m]: I can already see the response "Wow. We still have IRC logging going on after 12 years? Sheesh I forgot this server even still existed. Who is even paying for it?"
01:19:54 <jle`> chris done was ircbrowse iirc
01:20:24 <sm[m]> Yup. Anyone could revive that app I’m sure
01:20:48 <dminuoso> Well chris done was at least involved with tunes.org, so he might at least know. Wrote a mail
01:21:40 <jle`> if we bring back logs then irc will no longer be like shipping channels in the ocean
01:22:03 <jle`> where we wouldn't be able to see them until a boat cuts into the water and leaves a wake
01:28:01 <jgt> jle`: that's irrelevant. There's nothing stopping anyone from writing a GUI interface in Visual Basic to try and track an IP address.
01:28:31 <jle`> fair point
01:28:40 <mniip> is there a tool that would look at interface files and construct a dependency graph between identifiers in a package or a set of packages?
01:31:29 <mniip> something like weeder but that will check exposed modules too for whether the identifiers are used in another package
01:31:33 <Axman6> you could probably die that using the new .hie files in GHC 8.8
01:32:45 <sicklorkin> How can I rewrite this ` mapMaybe ((sequenceA . second listToMaybe) . unzip) $ groupBy ((==) `on` snd) $ sortOn snd $ map (id &&& fst) [(1,2),(3,2),(3,1)]`
01:33:01 <sicklorkin> [([(1,2)],1),([(3,2),(3,1)],3)]
01:35:11 <jle`> what are you trying to do?
01:35:22 <lavalike> getting an headache
01:35:29 <sicklorkin> lol
01:35:49 <sicklorkin> i want to group things by some key.. in this case the key is fst
01:36:53 <Axman6> what's the type of that?
01:37:06 <Axman6> or, what's the type you want
01:37:22 * Axman6 resists recommending edwardk's discrimination package
01:37:29 <jle`> > M.fromListWith (++) . map (\i -> (fst i, [i])) $ [(1,2),(3,2),(3,1)]
01:37:32 <lambdabot>  fromList [(1,[(1,2)]),(3,[(3,1),(3,2)])]
01:37:43 <lavalike> > M.toList . M.fromListWith (++) . map (fst &&& pure) $ [(1,2),(3,2),(3,1)]
01:37:45 <lambdabot>  [(1,[(1,2)]),(3,[(3,1),(3,2)])]
01:37:57 <sicklorkin> jle`: i was hoping to avoid Map.. lo.l but seems like that's the consenus 
01:37:57 <Axman6> placing the key second definitely feels wrong
01:38:09 <jle`> why would you want to avoid map?
01:38:15 <sicklorkin> Axman6: I forgot to add fmap swap 
01:38:49 <Axman6> % import Data.Discrimination as Disc
01:38:49 <yahb> Axman6: ; <no location info>: error:; Could not find module `Data.Discrimination'; It is not a module in the current program, or in any known package.
01:39:01 <sicklorkin> jle`: I guess `import qualified Data.Map as Map` is slightly less keystrokes
01:39:06 <Axman6> % cabal install kmettverse
01:39:06 <yahb> Axman6: ; <interactive>:60:1: error: Variable not in scope: cabal :: t0 -> t1 -> t; <interactive>:60:7: error: Variable not in scope: install; <interactive>:60:15: error: Variable not in scope: kmettverse
01:39:14 <Axman6> >_>
01:39:23 <lavalike> what a beautiful sight
01:40:03 <sicklorkin> Axman6: i'm definitely not going to add a dependancy to solve this.. 
01:40:10 <sicklorkin> :P
01:40:37 <sicklorkin> Somehow I thought my version would fuse nicely
01:40:40 <jle`> honestly what you wrote originally is literally unmaintainable
01:40:52 <jle`> no offense :)
01:40:58 <sicklorkin> jle`: 100% agree.. 
01:41:04 <jle`> a single dependency sounds like a cheap price to pay for long-term maintainability
01:41:33 <jle`> re: Map, though, containers is actually more or less included with ghc, so it's not a real dependency :)
01:41:41 <sicklorkin> until you upgrade GHC.. anyway.. nothing to argue.. just thought there may be some nice way of doing this w/o using map
01:41:51 <lavalike> be sure to read the note at the top of Data.Map's docs
01:42:22 <Axman6> with Data.Discrimination it would be roughly groupWith snd
01:42:31 <jle`> if you upgrade ghc you're going to be upgrading containers too automatically
01:43:30 <Axman6> which also happens to be linear time
01:43:32 <lavalike> where is Data.Discrimination?
01:43:47 <sicklorkin> discrimination
01:43:49 <Axman6> https://hackage.haskell.org/package/discrimination-0.4/docs/Data-Discrimination.html
01:44:12 <Axman6> it's Kmett bladck magic for doing grouping and sorting in linear time
01:44:18 <Axman6> black*
01:44:43 <sicklorkin> Axman6: so groupWith doesn't use Eq right?
01:45:28 <Axman6> no
01:45:41 <Axman6> it uses Grouping
01:48:19 <sicklorkin> Axman6: do you know how groupingEq is meant to be used?
01:52:19 <sicklorkin> lavalike: which note would that be? An efficient implementation of ordered maps from keys to values (dictionaries).
01:52:58 <sicklorkin> lavalike: sounds like something I'm looking for O.o
01:54:44 <lavalike> sicklorkin: I just meant the note about .Strict
01:57:33 <sicklorkin> lavalike: it's likely that I wont' need the values for all the keys - and it should be small enough (<100 entries) so I'm leaning towards a lazy Map.. 
01:58:16 <merijn> FYI, there is only one Map in containers :)
01:58:34 <merijn> The difference between "lazy" and "strict" map is just the functions for interacting with them
01:58:54 <sicklorkin> yes. the lazy / strict interface?
01:59:45 <merijn> And the only real difference is that strict forces values before inserting them and lazy doesn't
02:00:31 <sicklorkin> is Data.IntMap.Lazy the same as well?
02:00:43 <merijn> sicklorkin: AFAIK, yes
02:01:05 <sicklorkin> then why is IntMap.Lazy better than Map.Lazy if my keys are Ints
02:01:24 <sicklorkin> both force the key I thought
02:01:54 <merijn> sicklorkin: Because IntMap uses the knowledge of keys to implement a more efficient lookup
02:02:04 <sicklorkin> ahh.. right..
02:02:11 <merijn> sicklorkin: With Map you only know one thing: "keys are pairwise comparable"
02:02:14 <jle`> the difference between intmap and map doesn't have to do with strictness
02:02:25 <merijn> sicklorkin: If you know keys are ints you can special case the lookup logic
02:03:24 <merijn> sicklorkin: For example, suppose instead of doing a comparison and putting elements "left is smaller, right if larger" we can do things like "first level compares first bit of integer, 0 goes left, 1 goes right, 2nd level compares the 2nd bit, etc."
02:03:50 <merijn> This means your lookup tree is guaranteed to never be more than 64 levels deep
02:04:15 <merijn> (Note, I'm not saying this is what IntMap does, I haven't looked at the internals, just a general idea how you can abuse "all keys are ints")
02:04:49 <merijn> sicklorkin: The IntMap docs should have a reference to a paper on patricia trees explaining what it actually does
02:06:46 <Jinna> With postgresql-simple I want to make a record R out of an sql result set which includes a UTCTime. I want a value of R to be Cassava NamedRecord. I get this error:
02:06:53 <Jinna> No instance for (Data.Csv.ToField UTCTime) arising from the 'deriving' clause of a data type declaration
02:07:30 <Jinna> Now I tried `deriving instance (Data.Csv.ToField) UTCTime` but this warns me:
02:07:31 <merijn> sicklorkin: Incidentally, edwardk's discrimination package mentioned earlier is basically based on this idea of "what if we knew more about the structure of data than just pairwise comparison?" which is why it can be more efficient for many algorithms
02:07:32 <Jinna> No explicit implementation for ‘Data.Csv.toField’
02:12:48 <sicklorkin> merijn: thanks.. 
02:28:30 <sicklorkin> Jinna: fwiw UTCTime's format doesn't get converted to a Time in any of the spreadsheet software I've used.. Something like https://pastebin.com/sVrZy9qu may be a better fit.
02:38:24 <Jinna> sicklorkin: looks good, thank you
03:37:02 <Jinna> Is it possible to declare a new data type in a `where`? I want to `where` a complex folding function and would like the accumulator have its own (but local) type.
03:38:35 <dminuoso> Jinna: No.
03:38:56 <dminuoso> Jinna: The best you can do is create a module wide data type but not export it.
03:43:09 <Jinna> That will do.
04:02:38 <tdammers> I would actually love having scoped data types
04:02:49 <tdammers> and actually, I'd also love anonymous data types
04:03:06 <tdammers> though I'm not 100% clear what the latter would look like in Haskell
04:34:04 <kiwi_62> Hi, in Haskell this works. "fix f = f (fix f)", "fac' f n = if (n==0) then 1 else n*f(n-1)", "fac = fix fac'" When I try to port it to OCaml I get a Stack overflow, can anyone explain please?
04:37:32 <jgt> I don't know OCaml, but my first guess is that it's something to do with OCaml being strict by default
04:37:41 <jgt> as opposed to Haskell being lazy
04:37:48 <ggole> Yeah, you need to eta-expand
04:38:23 <kiwi_62> ahh I see now, because it isn't call by need
04:38:30 <kiwi_62> it just infinitely calls fix f
04:39:13 <kiwi_62> thank you
04:40:32 <infinisil> I'm writing some Haskell to evaluate different algorithms, and part of it will be to generate a data series over time so I can plot it
04:40:51 <infinisil> I'm debating whether I should just output the data to a file and making the plots with gnuplot
04:40:56 <infinisil> Or plotting in Haskell directly
04:41:09 <infinisil> Either sounds good, makes it hard to pick
04:42:06 <infinisil> There does seem to be a lot of plotting/charting libraries in Haskell. But gnuplot is probably going to be more flexible and better maintained
04:42:27 <maerwald> pick the simplest solution
04:44:37 <merijn> infinisil: fwiw, I plot things by running a python matplotlib script via process :p
04:44:53 <merijn> (mostly because I had a working matplotlib script already)
04:45:17 <merijn> So calling gnuplot seems a reasonable way to go
04:45:39 <merijn> tbh I like Chart but it's not mature enough for me (missing some stuff I really want)
04:47:15 <infinisil> maerwald: I don't know what's the simplest solution yet :)
04:47:28 <infinisil> merijn: I see
04:47:56 <merijn> (specifically Chart can't do textured bars in barcharts because diagram doesn't support that)
04:56:37 <giuge> hi
04:56:54 <giuge> is this the right channel to ask for help as a beginner?
04:57:06 <merijn> giuge: SUre
04:57:50 <giuge> thanks merijin! I'm learning haskell and I'm coding a CSV parser that reads my bank account CSV and exports it to ledger (a double entry accounting system)
04:59:08 <giuge> here's the code: https://gist.github.com/giuge/411758df6a749cce36f905c50ca50329
04:59:40 <giuge> specifically I can't wrap my head around fmap
04:59:59 <giuge> I have this line: $ fmap toLedgerFormat input (parseLedgerFormat eitherJournal)
05:01:15 <giuge> this is the function signature: toLedgerFormat :: Input -> [[String]] -> String where Input is a Vector
05:02:25 <merijn> giuge: That fmap is just "map" :)
05:02:52 <giuge> I get the following error: Couldn't match expected type ‘[[String]] -> Vector String’ with actual type ‘Vector ([[String]] -> String)’ The function ‘fmap’ is applied to three arguments, but its type has only two
05:03:21 <merijn> giuge: parseLedgerFormat returns [[String]], so the <$> applies "fmap toLedgerFormat" to all [String] inside [[String]] (and fmap in turn applies toLedgerFormat to each String in that [String])
05:03:43 <merijn> oh, wait...I misparsed that
05:03:58 <merijn> giuge: What's "input" supposed to be there?
05:04:16 <giuge> yeah sorry toLedgerFormat takes an Input a [[String]] and returns a String
05:04:39 <giuge>      $ concat
05:04:39 <giuge>      $ sortBy (\ a b -> sortByDate a b)
05:04:39 <giuge>      $ V.toList
05:04:43 <giuge>      $ fmap toLedgerFormat input <$> parseLedgerFormat eitherJournal
05:04:45 <hpc> merijn: input :: Vector Input
05:04:46 <lyxia> I bet it should be   fmap (toLedgerFormat input)
05:04:56 <hpc> Input is on line 37
05:04:57 <merijn> lyxia: oh, good eye
05:05:17 <giuge> yes
05:05:40 <giuge> yeah the code is probably a mess xD
05:05:48 <giuge> first haskell program ever
05:05:49 <lyxia> it would have been easier to guess with the error message
05:06:01 <hpc> fmap (toLedgerFormat input) is better but not quite all the way to correct
05:06:05 <hpc> since input :: Vector Input
05:06:14 <merijn> giuge: Some other comments: The use of length on line 134-135 is pretty bad. Length is really inefficient
05:06:20 <merijn> giuge: You probably want "null"
05:06:24 <merijn> > null []
05:06:27 <lambdabot>  True
05:06:28 <merijn> > null [2]
05:06:30 <hpc> so you'll have to map or fold over it as well
05:06:31 <lambdabot>  False
05:06:34 <giuge> https://gist.github.com/giuge/78572f2a82dd357398620b84295f3e1b
05:06:42 <merijn> giuge: Since length walks the entire list (i.e. O(n) complexity)
05:07:43 <merijn> giuge: Similarly "head <$> words <$> show <$> getCurrentTime" can be "head . words . show <$> getCurrentTime" <- although manipulating time as String like that is kinda awful anyway >.>
05:07:49 <giuge> thanks merijin, I've added a comment and I'll change it when it works
05:08:39 <hpc> https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format.html#v:formatTime
05:09:32 <giuge> ok merijin, I'll add a comment for that too. Thanks!
05:10:57 <absence> when passing the same argument to multiple functions, one can use the applicative instance for functions, i.e. f (g a) (h a) = (f <$> g <*> h) a. but what about two arguments? f (g a b) (h a b) = ???
05:11:31 <hpc> @pl \a b -> f (g a b) (h a b)
05:11:31 <lambdabot> ap (ap . (f .) . g) h
05:11:34 <hpc> ew
05:11:44 <merijn> My answer would be "don't do that
05:12:10 <absence> if lambdabot's suggestion is the only way, then obviously not :)
05:12:28 <absence> it doesn't always find the most elegant way though
05:12:43 <hpc> you could always write it
05:12:48 <hpc> but just not have it be generic
05:13:09 <absence> not sure i follow
05:13:44 <giuge> yeah the issue I'm having is that I'm mapping the vector and I have to apply a function that takes two arguments
05:13:51 <giuge> and I don't know how to do that
05:14:00 <hpc> instead of (<$>) and (<*>), use your own operators basically
05:14:39 <hpc> basically copy their implementations but add another parameter
05:15:05 <dminuoso> absence: You could also consider curry2/uncurry2
05:15:30 <absence> hpc: ah. was hoping to learn some trick to layer two applicatives or something :)
05:15:58 <absence> :t curry2
05:16:00 <lambdabot> error:
05:16:00 <lambdabot>     • Variable not in scope: curry2
05:16:00 <lambdabot>     • Perhaps you meant ‘curry’ (imported from Data.Tuple)
05:16:09 <giuge> :t curry
05:16:10 <lambdabot> ((a, b) -> c) -> a -> b -> c
05:17:13 <dminuoso> absence: i.e. `uncurry (f <$> (curry g) <*> (curry h)) a b`
05:17:34 <dminuoso> :t \f g h a b -> uncurry (f <$> (curry g) <*> (curry h)) a b
05:17:36 <lambdabot> ((b1 -> c1) -> (b2 -> c2) -> b3 -> t1 -> t2) -> ((a, b1) -> c1) -> ((a, b2) -> c2) -> (a, b3) -> t1 -> t2
05:18:11 <dminuoso> Oh well, perhaps flipped around they make more sense. :)
05:18:19 <dminuoso> :t \f g h a b -> curry (f <$> (uncurry g) <*> (uncurry h)) a b
05:18:23 <lambdabot> (a1 -> a2 -> c) -> (a3 -> b -> a1) -> (a3 -> b -> a2) -> a3 -> b -> c
05:19:38 <giuge> I'm not getting it
05:19:55 <dminuoso> % :t curry
05:19:55 <yahb> dminuoso: ((a, b) -> c) -> a -> b -> c
05:19:58 <dminuoso> % :t uncurry
05:19:58 <yahb> dminuoso: (a -> b -> c) -> (a, b) -> c
05:20:19 <dminuoso> giuge: Turn a function taking a tuple of two arguments arguments into a function taking two arguments and back again.
05:20:52 <dminuoso> That way you can use the regular ((->) a) applicative instance since we could pretend a "function taking 2 arguments" as a "function taking 1 argument" if transformed with uncurry
05:24:14 <giuge> thanks dminuoso, I'll try with that
05:24:59 <dminuoso> giuge: It was just meant for absence really. :)
05:26:36 <kuribas> absence: better to never use the applicative instance like that
05:26:46 <kuribas> unless you are code golfing
05:27:11 <absence> dminuoso: i guess there's no readable way to somehow use the applicative instance for (a ->) twice
05:28:03 <giuge> I tried changing the signature of toLedgerFormat to  :: (Input, [[String]]) -> String
05:28:14 <Batholith> anyone know what happened to Real World Haskell's website?
05:28:15 <giuge> and doing that fmap toLedgerFormat (input, (parseLedgerFormat eitherJournal))
05:28:40 <dminuoso> absence: Well you could write a simple newtype wrapper of course.
05:29:10 <giuge> but it doesn't work
05:29:15 <dminuoso> % newtype Reader2 s t a = Reader2 { runReader2 :: s -> t -> a }; ... -- absence 
05:29:15 <yahb> dminuoso: ; <interactive>:63:64: error: parse error on input `...'
05:33:04 <giuge> I guess I can't solve this problem with my current knowledge
05:37:44 <dminuoso> giuge: Can you elaborate what your problem is?
05:39:36 <giuge> toLedgerFormat <$> input <*> pure (parseLedgerFormat eitherJournal)
05:39:39 <giuge> it works!
05:40:19 <dminuoso> giuge: Ah indeed! So Applicative can be thought of as "fmap for functions of arbitrary arity" :)
05:41:15 <giuge> I got there by hacking code together tho :D
05:41:59 <giuge> https://stackoverflow.com/questions/30792554/easier-way-to-apply-multiple-arguments-in-haskell
05:42:06 <dminuoso> giuge: What you could do instead though, is this:
05:42:45 <dminuoso> giuge: flip the argument order of toLedgerFormat, that way you could write: let toFormat = toLedgerFormat (parseLedgerFormat eitherJournal) in toFormat <$> input
05:45:21 <giuge> is it more readable this way?
05:47:51 <dminuoso> giuge: Well depending on your code you could move it into a where binding instead. Or perhaps something like `toLedgerFormat fmt <$> input where fmt = pargeLedgerFormat eitherJournal`
05:48:37 <giuge> yeah looks clean
05:48:42 <dminuoso> Or without flipping the definition of toLedgerFormat you could also do: (`toLedgerFormat` fmt) <$> input where fmt = pargeLedgerFormat eitherJournal 
05:49:50 <dminuoso> (assuming you are in a declaration somewhere, where a `where` is acceptable)
05:50:38 <giuge> yeah I'm in a Right -> block
05:56:14 <giuge> thank you for all the help guys!
05:56:30 <giuge> so happy it works now
06:57:31 <sm[m]> great work giuge. You probably know ledger and hledger have CSV converters built in, and there are a bunch of third-party ones, right
06:57:51 <sofiama> Is the Hat haskell tracer still maintained? Is it easy to integrate it into a cabal/stack build process?
07:00:04 <sm[m]> sofiama: both of those sound unlikely.. let us know
07:42:57 <realloc> hi, I'm trying to compile the "haskell ide engine", but it takes up a huge ammount of memory. Is it in general possible to instruct stack/ghc to use less memory (even if the build might take longer?). I already set -j1 and am currently observing, whether it helps, or not.
07:44:23 <glguy> realloc: Not that it's a great solution, but you could turn off optimizations
07:45:05 <realloc> glguy, thank you. I can try that
07:59:54 <realloc> nope, disabling optimizations with --fast wasnt enough
08:03:38 <xlxs4> realloc: If your problem is not having enough memory, you can make a swap (or increase its size). Maybe you'll need to play around with swapiness too, if that's the case
08:09:28 <realloc> xlxs4, well I guess I have to. Tried to avoid it because of SSD wear
08:10:59 <xlxs4> realloc: a quick internet search may also prove rather useful. There have been some bugs/issues with specific Ghc/Stack versions. Maybe see whether your versions match and either upgrade or downgrade accordingly?
08:15:19 <sm[m]> realloc: you can also try: building fewer packages at once (manually), eg starting with some of the deps; or passing +RTS -M 400m -RTS to ghc to influence its heap usage
08:15:54 <sm[m]> after xlxs4 's suggestion. I would try to avoid swap, it'll take forever
08:20:47 <realloc> sm[m]: All dependencies should have been built. Its only ghc-lib-parser that makes trouble. I'll try your suggested flags
08:20:53 <realloc> thanks
08:24:05 <cocreature> realloc: iirc --fast does not apply to your dependencies
08:26:12 <sm[m]> I see.. I wonder if https://github.com/digital-asset/ghc-lib/issues/39 helps
08:26:22 <sm[m]> how much is it using ?
08:27:24 <isovector1> do you hate not being able to write ghc proposals in markdown as much as i do? if so, i've got just the thing for you! https://github.com/ghc-proposals/ghc-proposals/pull/249
08:27:26 <realloc> sm[3] 3700MiB+
08:28:09 * xlxs4 thanks isovector1
08:29:08 <isovector1> xlxs4: please give it a thumbs up if you can! in my experience lots of these procedure things only get accepted if they have lots of support behind them!
08:29:30 <xlxs4> isovector1: I'm already on it ;)
08:30:11 <realloc> sm[m] interesting read, thx
08:30:13 <sm[m]> realloc: ouch. Re what xlxs4 said, if it's easy to try a different GHC version that's worth a try
08:32:23 <realloc> cocreature: good to know, thx
08:33:05 <realloc> sm[m] last resort, but I keep it in mind
08:34:06 <sm[m]> also, possibly reporting as a GHC bug
08:34:07 <cocreature> you don’t have a lot of choices regarding the GHC version here. ghc-lib only goes back to 8.4
08:34:15 <dmj`> would it be possible to have list that looked like: [1, 2, 4 .. 7, 12, 8 .. 10 ]
08:34:19 <dmj`> list syntax*
08:35:31 <dmj`> just cake on more sugar to lists
08:35:32 <xlxs4> realloc: IMHO increasing/adding swap should be the last resort. It's going to take an awful lot to get the job done
08:41:32 <xlxs4> realloc: can you run ghc with the -v flag and post a link to the log dump?
08:43:12 <dmwit> dmj`: Sure. Could even do it pretty straightforward with a quasiquoter. But: does that group as (4..7) or (2,4..7), e.g.? There are some design decisions to consider.
08:45:06 <dmj`> ah yea, that would get ambiguous hmmm.
08:45:09 <realloc> xlxs4: Yes, but it will take a while
08:45:36 <dmj`> dmwit: maybe we could make it whitespace sensitive somehow, like `[2,4..7]` vs. `[2, 4..7]` I imagine this would break a lot of code though
08:47:13 <dmwit> Just do a QQ and make whatever decision you want. Won't break any code, doesn't require the whole ungainly GHC-patching process, and you can do it today and be using it tomorrow.
08:47:30 <dmwit> [cake| 1,2,4..7,12,8..10]
08:47:54 <glguy> <3 quasiquoters
08:49:06 <dmwit> (...maybe don't use the name cake.)
08:56:57 <realloc> xlxs4: Added -v using ghc-options. Thought it would output more: https://pastebin.com/Y2Zk5a3b
08:57:24 <realloc> xlxs4: Unfortunately I cant rerun the build right now, since I need the memory for something else 
09:10:34 <dmj`> cake sounds nice :)
09:18:12 <halogenandtoast> Anyone who is familiar with Persistent, is there any way to get Persistent to not try to alter my column type, postgres says it is timestamp without time zone, but if I use UTCTime it tries to change it to timestamp with time zone. If I override sqltype to "TIMESTAMP WITHOUT TIME ZONE" it still tries to alter the column.
09:21:55 <halogenandtoast> I've asked in #yesod which may be a better place for that question (?)
09:42:57 <halogenandtoast> The answer seems to have been not to put quotes around the sqltype... :shrug:
10:45:29 <jle`> dmj`: the explicit way isn't too bad, concat[[1],[2,4..7],[12],[8..10]]
11:00:37 <dmwit> [1; 2,4..7; 12; 8..10]
11:00:59 <dmwit> almost even works with the "do-tell" idiom
11:01:40 <dmwit> Oh, no, there's way more boilerplate than I remembered for tha.t
11:05:48 <dmj`> > [ do 1, do 2 ]
11:05:51 <lambdabot>  [1,2]
11:05:54 <dmj`> heh
11:06:11 <hyperisco> > do [ do 1, do 2 ]
11:06:14 <lambdabot>  [1,2]
11:06:32 <hyperisco> > do do ()
11:06:34 <lambdabot>  ()
11:06:38 <hyperisco> hehe
11:07:22 <dmj`> > let { this = "did this"; that = "did that"; } in [ do this, do that ]
11:07:25 <lambdabot>  ["did this","did that"]
11:08:11 <tabaqui> % let this = ("foo" :: String) in [do this]
11:08:11 <yahb> tabaqui: ["foo"]
11:08:25 <tabaqui> % let this = (1 :: Int) in [do this]
11:08:25 <yahb> tabaqui: [1]
11:08:29 <tabaqui> oh
11:08:37 <tabaqui> ok, String is a monad, but not Int
11:08:57 <jle`> it might work with -XOverloadedLists
11:09:03 <tabaqui> do a; b == a >> b
11:09:18 <tabaqui> so a and b must have the type (Monad m) => m smth
11:11:23 <jle`> % import GHC.Exts
11:11:23 <yahb> jle`: 
11:11:52 <jle`> % instance IsList a => IsList (Const a b) where type Item (Const a b) = Item a; fromList = Const . fromList; toList = GHC.Exts.toList . getConst
11:11:52 <yahb> jle`: ; <interactive>:67:98: error:; Ambiguous occurrence `fromList'; It could refer to either `V.fromList', imported from `Data.Vector'; or `GHC.Exts.fromList', imported from `GHC.Exts'
11:12:02 <jle`> % instance IsList a => IsList (Const a b) where type Item (Const a b) = Item a; fromList = Const . GHC.Exts.fromList; toList = GHC.Exts.toList . getConst
11:12:02 <yahb> jle`: 
11:12:24 <jle`> % getConst $ do [1]; [2,4..7]; [12]; [8..10]    :: [Int]
11:12:24 <yahb> jle`: ; <interactive>:69:15: error:; * Couldn't match type `[]' with `Const a'; Expected type: Const a Integer; Actual type: [Integer]; * In a stmt of a 'do' block: [1]; In the second argument of `($)', namely; `do [1]; [2, 4 .. 7]; [12]; [8 .. 10] :: [Int]'; In the expression:; getConst; $ do [1]; [2, 4 .
11:12:36 <jle`> % :set -XOverloadedLists
11:12:36 <yahb> jle`: 
11:12:38 <jle`> % getConst $ do [1]; [2,4..7]; [12]; [8..10]    :: [Int]
11:12:38 <yahb> jle`: ; <interactive>:71:36: error:; * Couldn't match type `[]' with `Const a'; Expected type: Const a Int; Actual type: [Int]; * In a stmt of a 'do' block: [8 .. 10] :: [Int]; In the second argument of `($)', namely; `do [1]; [2, 4 .. 7]; [12]; [8 .. 10] :: [Int]'; In the expression:; getConst; $ do [1]; 
11:12:42 <jle`> :'(
11:13:05 <dmwit> tabaqui: There's no Monad constraint incurred by `do { e }`, it just becomes `e`.
11:13:23 <jle`> % (getConst $ do [1]; [2,4..7]; [12]; [8..10])    :: [Int]
11:13:23 <yahb> jle`: ; <interactive>:72:16: error:; * No instance for (Monad (Const [Int])) arising from a do statement; * In a stmt of a 'do' block: [1]; In the second argument of `($)', namely; `do [1]; [2, 4 .. 7]; [12]; [8 .. 10]'; In the expression:; (getConst; $ do [1]; [2, 4 .. 7]; [12]; 
11:13:35 <dmwit> tabaqui: (e.g. see hyperisco's `do do ()`; `()` doesn't even have a parameter, which is needed for `Monad`.)
11:13:35 <tabaqui> well, that is the only explanation
11:13:41 <jle`> % :set -XApplicativeDo
11:13:41 <yahb> jle`: 
11:13:45 <jle`> % (getConst $ do [1]; [2,4..7]; [12]; [8..10])    :: [Int]
11:13:45 <yahb> jle`: ; <interactive>:74:13: error:; * No instance for (Monad (Const [Int])) arising from a do statement; * In the second argument of `($)', namely; `do [1]; [2, 4 .. 7]; [12]; [8 .. 10]'; In the expression:; (getConst; $ do [1]; [2, 4 .. 7]; [12]; [8 .. 10]) ::; [Int]; 
11:13:51 <jle`> hm, this works on my machine
11:13:53 <jle`> oh well
11:14:04 <jle`> apologies for bot spam
11:14:12 <tabaqui> base version differs probably
11:14:23 <jle`> % (getConst $ do [1]; [2,4..7]; [12]; [8..10]; pure ())    :: [Int]
11:14:24 <yahb> jle`: [1,2,4,6,12,8,9,10]
11:14:27 <tabaqui> Const is not a Monad here
11:14:29 <jle`> ah you need the pure () at the end for some reason
11:14:41 <jle`> Const is never a Monad
11:15:08 <jle`> but it works :D
11:15:16 <tabaqui> hmm, I could define join operation for const
11:15:18 <jle`> i wonder if there is a way that doesn't require the pure ()
11:15:26 <jle`> tabaqui: would it be lawful?
11:15:28 <tabaqui> join $ Const a (Const b c) = Const a c
11:15:40 <tabaqui> or Const b c, whatever
11:16:00 <tabaqui> oh, but not "return" :)
11:16:01 <jle`> the easiest way to see how Const can't be a monad is that you can't implement (>>=)
11:16:09 <tabaqui> maybe if we add Monoid constraint
11:16:20 <jle`> 'pure' is legal, Const e is an Applicative for all Monoid e
11:16:32 <jle`> and you might be using a different Const, it's data Const a b = Const a
11:17:18 <tabaqui> instance (Monoid c) => Monad (Const c) where return = Const mempty; join (Const (Const a _) b) = Const a b
11:17:30 <tabaqui> oh, ok
11:17:36 <jle`> tabaqui: Const only has one field
11:17:38 <dmj`> which version of base began to re-export Data.Monoid from the prelude ?
11:17:42 <dmwit> jle`: It works, but it surely doesn't do what's wanted... does it?
11:17:42 <tabaqui> right
11:17:57 <tabaqui> instance (Monoid c) => Monad (Const c) where return _ = Const mempty; join (Const (Const a)) = Const a
11:18:00 <jle`> dmwit: are you talking about the do-block formulation? i think it's correct
11:18:01 <dmwit> > [1] >> [2,4..7] >> [12] >> [8..10] -- probably not the intended result
11:18:05 <lambdabot>  [8,9,10,8,9,10,8,9,10]
11:18:10 <jle`> tabaqui: doesn't quite typecheck, again :)
11:18:30 <jle`> % getConst (do [1]; [2,4..7]; [12]; [8..10]; pure ())    :: [Int]
11:18:30 <yahb> jle`: [1,2,4,6,12,8,9,10]
11:18:40 <jle`> dmwit: looks right :)
11:18:48 <dmwit> Oh, I didn't see the getConst.
11:19:02 <jle`> it's a particularly evil way to do it though
11:19:13 <dmwit> Huh, I'm surprised that type-checks.
11:19:17 <dmwit> :t [1]
11:19:18 <lambdabot> Num a => [a]
11:19:19 <dmwit> % :t [1]
11:19:20 <yahb> dmwit: (IsList l, Num (Item l)) => l
11:19:22 <dmwit> Okay. =)
11:19:40 <dmwit> Cute!
11:19:59 <jle`> not sure how to get rid of the final pure () though
11:20:08 <jle`> i feel like ApplicativeDo should be happy without it
11:21:05 <dmwit> ApplicativeDo is a gross syntactic hack.
11:21:14 <tabaqui> join = id; here
11:21:28 <tabaqui> err, not quite
11:21:33 <tabaqui> it changes the type
11:21:43 <tabaqui> join (Const x) = Const x
11:21:57 <tabaqui> instance (Monoid c) => Monad (Const c) where return _ = Const mempty; m >>= f = join (fmap f m)
11:21:58 <jle`> join = coerce hehe
11:22:04 <tabaqui> right :)
11:22:11 <jle`> but yeah, that breaks some of the laws
11:22:39 <tabaqui> well, actually Monoid c => Applicative (Const c) is already defined
11:22:59 <tabaqui> and I see the only sane "join" implementation
11:23:03 <jle`> indeed, that's actually one of my favorite instances of Applicative
11:23:50 <tabaqui> *the only one
11:24:01 <jle`> tabaqui: your instance breaks `join . pure = id`
11:24:14 <jle`> hm, is that a law
11:24:14 <dmwit> tabaqui: It's p. hard to satisfy the `return x >>= f = f x` law.
11:24:39 <jle`> trying to find a law in terms of join/pure to make it easier to directly see how the join doesn't work
11:25:04 <tabaqui> oh, I see
11:25:46 <dmwit> join (fmap f (pure x)) = f x -- I guess
11:25:46 <jle`> ah yeah, `join . pure = id`, and `join . fmap pure = id`
11:25:47 <tabaqui> pure wipes the data
11:26:06 <jle`> join . fmap pure = id is satisfied
11:26:10 <jle`> but join . pure = id is not
11:26:13 <tabaqui> so "pure (Const anything)" has no information about "anything"
11:26:41 <dmwit> tabaqui: right
11:26:47 <jle`> there is one 'e' that does give rise to Monad (Const e)
11:26:59 <jle`> or i should say one E that gives rise to Monad (Const E)
11:27:19 <jle`> then you could write instance (e ~ E) => Monad (Const e), heh
11:27:25 <jle`> but what is that mystery E ?
11:27:28 <dmwit> jle`: HTT equalities, right? ;-)
11:28:11 <jle`> there's a specific E in haskell
11:28:20 <jle`> but i don't really have an elegant formulation on why
11:28:39 <dmwit> Surely any one-inhabitant type will do.
11:28:39 <jle`> but it makes Const E equivalent to some other famous Monad
11:28:48 <jle`> yes, anything isomorphic to () :)
11:28:53 <jle`> Const () ~ Proxy
11:28:55 <dmwit> Which is sort of the joke I was making about HTT: univalence says all equalities are equal.
11:29:05 <sarahzrf> b-but it doesn't?
11:29:09 <jle`> hah
11:29:23 <sarahzrf> in fact it contradicts that
11:31:17 <sarahzrf> did i miss a joke >.> 
11:31:36 <dmwit> Yes. But it was a bad joke based on incorrect facts.
11:32:00 <sarahzrf> oof
11:33:16 * dmwit ponders the sanity of class KnownFinite a where type Size a :: Nat; size :: Dict (KnownNat (Size a))
11:33:41 <dmwit> instance Size a ~ 1 => Monad (Const a)
11:34:51 <sarahzrf> could you just write
11:35:05 <sarahzrf> class KnownNat (Size a) => KnownFinite a where type Size a :: Nat
11:35:16 <dmwit> Oh, yeah, much better.
11:35:46 <dmwit> I guess I'd also want a method like inhabitants :: Vector (Size a) a
11:36:56 <sarahzrf> then just use Bounded and Enum
11:37:00 * dmwit . o O ( instance Size a ~ 0 => KnownFinite [a] where type Size [a] = 1 )
11:37:23 <dmwit> sarahzrf: ^ an example of why Bounded and Enum probably won't do
11:37:41 <dmwit> I guess you could write an instance Size a ~ 0 => Bounded [a], actually.
11:37:42 <dmwit> Okay.
11:37:42 <sarahzrf> hah
11:45:53 <jle`> dmwit: something like a MonoRepresentable
11:46:04 <jle`> or i suppose MonoRepresentable is just an isomorphism
11:46:15 <jle`> if your type 'a' is isomorphic to 'Finite n'
11:46:24 <Boarders> if I am doing a traverse_ over a vector in the ST monad, is there any easy way to parallelise it?
12:27:04 <muzzle> hi, I am wondering if anyone here has worked with github's semantic library?
12:28:59 <muzzle> I can't exactly figure out how to pattern match on parsed AST's and I think I am missing something obvious
12:29:45 <JoeCordingley> Hi, If I'm using a stack project and I want to have some test resources, where are they normally kept? And do I have to add any config to make stack not consider them source files?
12:31:45 <muzzle> probably specify a data_dir in the cabal file?
12:31:58 <hyperisco> muzzle, they're using open unions? So there will be special definitions to pattern match on them rather than case/of. Though they may also have view patterns enabling that.
12:31:59 <muzzle> If you are using package.yaml I'm not exactly sure
12:32:52 <muzzle> hyperisco, I they are indeed using open unions but since the whole library isn't really documented that well I still have some problems in understanding.
12:33:07 <muzzle> hyperisco, is there some sort of standard construct to look for?
12:33:31 <JoeCordingley> yes I'm using package.yaml, it's a fresh stack project.
12:34:38 <JoeCordingley> if I add a test_resources folder on the same level as src and test will it get treated as a source dir as default?
12:34:43 <hyperisco> They link to a paper, so they may have used the same names for their definitions.
12:34:55 <muzzle> JoeCordingley: see also https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=paths_#accessing-data-files-from-package-code
12:35:10 <JoeCordingley> thanks, I'll look at that.
12:35:44 <muzzle> hyperisco, hmm I'll probably write this up in a blog post for any future coders :P
12:38:14 <ais_> .
12:40:37 <ais_> i'm trying hard for some time now to understand how the mutually recursive functions many and some from alternative actually stop
12:40:41 <ais_> https://paste.ubuntu.com/p/D5SyxbBZGv/
12:41:24 <ais_> does it somehow short circuit?
12:42:00 <monochrom> They actually don't terminate for several instanaces like Maybe and [].  But try a parser monad.
12:44:18 <ais_> monochrom, was this directed at me?
12:44:25 <monochrom> The exact criterion is that if you keep calling x multiple times, it eventually fails.
12:44:28 <monochrom> Yes.
12:45:24 <monochrom> "many Nothing" terminates, but "many (Just ())" non-terminates because "Just ()" doesn't eventually fail.
12:46:12 <monochrom> However, with a parser, you call it multiple times, usually it succeeds for the first few times, then it fails.  This is when many and some are actually useful.
12:46:28 <ais_> i'm currently following a book where the author is building a parse type
12:46:37 <monochrom> There you go.
12:46:40 <ais_> i tried emulating the some and many 
12:47:14 <ais_> by writing it out, but the abstraction is a bit too high for me to come to a conclusion 
12:48:07 <ais_> i don't have enough capacity to follow it through until it fails
12:48:11 <ais_> how does it fail?
12:48:31 <monochrom> A parser succeeds or fails based on input, no?
12:48:50 <ais_> yes
12:48:59 <ais_> it returns empty list in my case
12:49:06 <monochrom> There you go.
12:49:58 <ais_> ah, ok i see
12:50:10 <ais_> it does not evaluate "many x"
12:50:22 <ais_> if the preceeding parser is empty 
12:50:49 <ais_> when doing "empty result <*> many x"
12:51:17 <ais_> is my reasoning correct here?
12:52:28 <monochrom> Yes.
12:52:53 <ais_> thank you
12:54:07 <deltasquared> *reads backlog*
12:54:17 <deltasquared> open unions? whatnao? /me must google this
12:55:09 <solonarv> sarahzrf jle` dmwit: class KnownNat (Size a) => Finite a where type Size a; finiteIndex :: Iso' a (Fin (Size a))
12:55:43 <solonarv> or you could split the Iso into from/to functions, but that is too much typing for IRC!
12:56:29 <deltasquared> muzzle: ok so dumb question, what does open unions get us that simply not being exhaustive with type matches of regular unions doesn't? or am I barking up the wrong tree here
12:57:48 <monochrom> Open unions are extensible (add more cases as afterthought), closed unions aren't.
12:58:33 <monochrom> OTOH I wasn't following the discussion.
13:01:04 <deltasquared> oh, that's why there were search results about effects and exceptions then. I guess it's like how you can catch (or not catch) arbitary types of exceptions in other languages?
13:01:14 <deltasquared> s/other/imperative/
13:02:07 <monochrom> Yes. All exception mechanisms need to be open. Even SML has to do it. (And then SML's exception mechanism got hijacked for mimicking OO subclassing.)
13:02:39 <solonarv> well actually you can do exactly the same thing in Haskell - the standard library and runtime that ships with GHC uses a dynamically-typed (iow open union) exception system
13:04:24 <c_wraith> and there's nothing special about its implementation either - it's an existential + class
13:04:35 * deltasquared realises his clock is incorrect
13:04:46 <deltasquared> how long has that been like that... wtf did I do!?
13:04:50 <deltasquared> one sec, brb
13:05:27 <deltasquared> oh that's why. this itx board didn't have a way to update the clock in the firmware menu.
13:05:53 <monochrom> It's Stardate 283974.49851 now. >:)
13:05:55 <deltasquared> nvm, ignore my ramble, just saw the timestamps in the irc window
13:06:31 <deltasquared> nothing a quick poke of timesyncd won't fix as it were
13:11:23 <aldum> is there a more recent version of this out there? https://wiki.haskell.org/Roll_your_own_IRC_bot
13:16:30 <TheBrodmann> is there an under maintain module for graphql?
13:19:59 <dmj`> TheBrodmann: I have a good graphQL library
13:20:17 <dmj`> TheBrodmann: it uses alex and happy, proper compiler front end tools to correctly parse the context-free grammar
13:20:25 <dmj`> TheBrodmann: graphQL is a good spec
13:20:53 <dmj`> It's also flexible and supports dynamic schemas, and is updated to use the latest spec
13:21:02 <dmj`> per facebook's RFC
13:21:34 <dmj`> TheBrodmann: https://github.com/dmjio/graphql-meta
13:22:06 <dmj`> TheBrodmann: has roundtrip quickcheck tests too
13:30:41 <TheBrodmann> dmj`: I'm not pro in haskell. Is graphql-meta a GraphQL client? Am I right?
13:31:29 <dmj`> TheBrodmann: yea, it's a library you can use to implement GraphQL servers and / or clients.
13:37:16 <_d0t> ohai! What's the real different between pattern matching in let..in and case..of expressions assuming the latter has only one branch?
13:37:34 <_d0t> *difference
13:37:48 <AndreasK> The syntax I guess
13:38:07 <_d0t> Well, except for that.
13:38:30 <int-e> laziness.  let Foo a b = c in f a b  will only force c when one of a or b is forced.
13:38:43 <int-e> case c of Foo a b -> f a b  will force c immediately
13:38:44 <_d0t> The reason I'm asking is that GHC allows matching against existentially quantified constructors only with case but not let.
13:39:00 <_d0t> I guess this isn't related to laziness in this case.
13:39:48 <AndreasK> int-e: Good point
13:40:04 <int-e> Well, laziness is some part of it, clearly; without destructing c, there will be no type evidence for the value(s) contained in it.
13:40:29 <_d0t> How's that?
13:40:56 <_d0t> I mean, one thing is happening in build time, the other one is in run time.
13:41:07 <dmj`> TheBrodmann: don't need to be a pro to use it
13:41:28 <dmj`> TheBrodmann: just basics like Data.List, Control.Monad, Prelude should be all that you need, no type level chicanery
13:41:41 <dmj`> maybe some light bytestring usage
13:42:33 <Fare> stack 2.1.1.1 from a recent nixpkgs fails with "Cannot determine project root directory for Docker sandbox." I'm not using Docker. What does that mean?
13:42:53 <_d0t> Fare: that means there's a stack bug probably
13:42:54 <int-e> _d0t: it's not just types (you could invent a fresh typename at runtime)... there's class evidence to consider as well, say if you have  data Foo where Foo :: Show a => a -> Foo
13:43:05 <int-e> s/runtime/compile time/
13:43:16 <lyxia> _d0t: let Refl :: Int :~: Bool = undefined in (...) {- evidence that Int ~ Bool is available here -}
13:43:31 <_d0t> https://bpaste.net/show/kGTQ
13:43:33 <TheBrodmann> dmj`: thank you for sharing
13:43:36 <_d0t> I was thinking more about this example
13:43:56 <_d0t> Is there any thing preventing me from implementing a similar check for let..in that allows case..of to pass?
13:44:08 <lyxia> _d0t: and also let bindings being recursive you also have to do strange things and manage the scope before and after in differently.
13:44:34 <_d0t> I kind of forgot about recursion, yeah
13:46:10 <dmj`> TheBrodmann: of course !
13:54:07 <dmwit> _d0t: Besides laziness, let allows polymorphic bindings and case no.
13:54:23 * Fare searches github issues and finds https://github.com/commercialhaskell/stack/issues/4864 - I wonder whether the fix isn't in nixpkgs-unstable yet, or whether I'm seeing a different bug.
13:54:28 <dmwit> > let f = id in (f "hi", f ())
13:54:31 <lambdabot>  ("hi",())
13:54:35 <dmwit> > case id of f -> (f "hi", f ())
13:54:39 <lambdabot>  error:
13:54:40 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘()’
13:54:40 <lambdabot>      • In the first argument of ‘f’, namely ‘()’
13:55:56 <dmwit> And yes, existential quantification can only be unwrapped by case, not let.
13:56:49 <JoeCordingley> how would you diff two directories in haskell, I notice there is a filediff package but it's not on stackage.
13:56:52 <_d0t> hmm...
13:56:58 <_d0t> dmwit: thanks
13:57:44 <dmwit> The typing rules for the two are very different.
13:58:46 * dmwit shrugs towards JoeCordingley
13:59:00 <dmwit> If I found a package that did what I wanted, I would go ahead and use it even if it wasn't on Stackage.
13:59:36 <JoeCordingley> Ok, I guess so. Just wondering.
14:00:37 <_d0t> JoeCordingley: the fact that a package isn't on stackage doesn't really mean anything other than... well, it not being on stackage
14:00:52 <_d0t> there are lots of well-maintained packages that aren't there
14:01:51 <JoeCordingley> when using extra-deps in stack.yaml, is there an extra-test-deps or whatnot?
14:02:11 <_d0t> I don't think so. What do you want it to do?
14:03:03 <JoeCordingley> just to use that filediff to check two directories are the same
14:03:22 <_d0t> no, I mean extra-test-deps
14:04:20 <JoeCordingley> I don't know really, just only need it for the tests.
14:04:51 <dmwit> JoeCordingley: Having just looked at the source for filediff a bit, I recommend using Diff instead. It's more careful about efficiency.
14:04:52 <_d0t> I don't think stack makes a distinction
14:05:11 <JoeCordingley> dmwit: ok thanks
14:06:00 <JoeCordingley> _d0t: I see, it's not really important anyway.
14:08:00 <JoeCordingley> dmwit: I don't think Diff will diff two directories will it?
14:20:33 <lyxia> it won't
14:37:44 <dmwit> JoeCordingley: No, you'll have to bolt that feature on.
14:38:24 <dmwit> That's not really the algorithmically difficult part, though.
14:40:43 <JoeCordingley> OK thanks for your help. Bye.
16:38:22 <turab> @pl \f i1 x y i2 -> f i2 x y i1
16:38:22 <lambdabot> flip . ((flip . (flip .) . flip) .) . flip
16:38:34 <turab> @pl \f i1 x y i2 -> f i2 y x i1
16:38:34 <lambdabot> flip . ((flip . (flip .)) .) . flip . (flip .) . flip
17:19:48 <butterthebuddha> turab what is that monstrosity
17:24:04 <turab> Just a bunch of flips :)
17:24:25 <Axman6> flip!
17:26:07 <butterthebuddha> What does @pl do?
17:26:34 <turab> Pointless notation!
17:26:44 <butterthebuddha> @pl \x y -> x + y
17:26:44 <lambdabot> (+)
17:27:05 <butterthebuddha> @pl x >>= \y -> pure $ y + 1
17:27:05 <lambdabot> pure . (1 +) =<< x
17:27:32 <butterthebuddha> Does lambdabot implement the same algorithm as pointfree.io?
17:28:16 <Axman6> it's probably the same code
17:29:28 <jackdk> @pl \x y -> table y x
17:29:29 <lambdabot> flip table
17:29:33 <jackdk> I agree, lambdabot 
17:29:43 <butterthebuddha> Lmao
17:30:51 <turab> Hahah
17:30:52 <butterthebuddha> @pl \x -> what's good x
17:30:52 <lambdabot> what's good
17:31:41 <butterthebuddha> I wonder how far you can go, with trying to get lambdabot to print the appropriate punctutation
17:39:36 <dmwit> > text "pretty dang far <>'!@#$"
17:39:39 <lambdabot>  pretty dang far <>'!@#$
17:39:55 <dmwit> > text "> don't bother, they thought of it"
17:39:57 <lambdabot>  > don't bother, they thought of it
17:40:28 <jackdk> > text "% :t length"
17:40:35 <lambdabot>  mueval-core: Time limit exceeded
17:40:41 <iqubic> Huh?
17:40:43 <dmwit> lol
17:40:50 <iqubic> What the heck happened there?
17:40:51 <dmwit> > text "% :t length"
17:40:52 <Axman6> > text"> Maybe they did\n> or [True, False] -- did they?"
17:40:55 <lambdabot>  % :t length
17:40:58 <lambdabot>  mueval-core: Time limit exceeded
17:41:06 <Axman6> > text "> Maybe they did\n> or [True, False] -- did they?"
17:41:11 <lambdabot>  > Maybe they did
17:41:11 <lambdabot>  > or [True, False] -- did they?
17:41:15 <Axman6> yes
17:41:17 <dmwit> they diiiid
17:41:32 <jackdk> I was hoping to trigger yahb :(
17:41:33 <Axman6> there was another bot in here which didn't append the space though
17:41:38 <dmwit> jackdk: They thought of that, too.
17:41:44 <iqubic> I see.
17:41:59 <dmwit> Perhaps I am a bot that doesn't append spaces!
17:42:16 <iqubic> % text "> length [1]"
17:42:16 <yahb> iqubic: > length [1]
17:43:12 <iqubic> Appending the caller's name to the beginning of the message certainly stops one bot from calling another.
17:45:56 <Axman6> lambdabot: @nixon
17:45:56 <lambdabot> A man is not finished when he is defeated. He is finished when he quits.
17:46:24 <turab> Damn
17:48:51 <Axman6> % text "\nlambdabot: @nixon" -- pretty sure this won't work
17:48:51 <yahb> Axman6: ; lambdabot: @nixon
17:49:03 <Axman6> ah yes, I forgot about that!
17:57:11 <ski> of course, both lambdabot and yahb really ought to only respond by NOTICE, not PRIVMSG
18:08:02 <Jonathan> I have the need for `Map` type in an `MVar`.  Is there a good `MMap` type?
18:08:48 <Axman6> type MMap k v = MVar (Map k v)
18:08:52 <Axman6> ^ that one
18:09:08 <Jonathan> lol, yeah
18:09:57 <Jonathan> I was thinking there could be an optimized one.
18:10:29 <Jonathan> I thought I saw some sort of `MArray` but now I cannot find it to prove it...
18:11:05 <Jonathan> Oh, right `MVector` http://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Storable.html
18:11:33 <Jonathan> But I guess not for Map.  Thanks.
18:41:59 <dmwit> Jonathan: http://hackage.haskell.org/package/stm-containers
18:42:32 <Jonathan> dmwit: Nice!, Thanks!
18:45:40 <dmwit> Hm. Although that doesn't seem to do what I would want it to do.
18:45:58 <dmwit> Namely: it's analogous to TVar (Map k v), not TVar (Map k (TVar v)).
18:47:02 <Jonathan> Actually it is what I wanted...I think.
18:47:07 <dmwit> Even better would be to put TVars at the branching points so you could update independent branches simultaneously.
18:47:50 <Jonathan> That would make sense dmwit
19:07:57 <turab> :q
19:08:01 <turab> Whoops
19:50:50 * shapr hugs Fare
19:51:56 <turab> I spent a whole day on Haskell wiki's humor page and I saw a lot of stuff from shapr
19:52:00 <turab> Thanks for all that :)
19:52:39 <shapr> huh, I forgot about that...
19:53:05 * shapr looks
19:53:48 <shapr> turab: this one? https://wiki.haskell.org/Humor
19:54:00 <turab> https://wiki.haskell.org/QuotesPage
19:54:13 <shapr> ooh that one
19:54:41 <shapr> decades old quotes :-)
19:55:04 <turab> They live on for new users like me I guess :')
19:56:07 * shapr cackles much
19:56:15 <shapr> turab: I'd forgotten most of these :-)
19:57:50 <turab> Just today I went back and searched for all the stuff about Oleg. It was a good start of the day :D
20:07:04 <slack1256> I am confused by dependent types. I know predicative logic and the use of universal and existential quantification (over sets mainly). On type-systems I thought (x: N) meant that the term `x` is of type `N` but that `x` and `N` are "separated" by one level, so they don't intermingle and lead to paradoxes
20:07:18 <slack1256> What about dependent types? Having a depedent product (analogous to universal quantification) `B: A -> \mathcal U` seems to be a breach of the no intermingling of layers restriction, isn't that a problem?
20:09:44 <dmwit> What are: `B`, `A`, `\mathcal U`?
20:10:37 <dmwit> Or: why does that seem to be a breach to you?
20:12:08 <slack1256> B would be the name of an arbitrary dependent function type. A is a type, \mathcal U would be a "kind" in haskell parlance. B: A -> \mathcal{U} would map a term of A to a type of kind \mathcal{U}
20:12:38 <slack1256> I think there was a prohibition on breaching the layers as it could lead to paradoxes
20:13:49 <slack1256> I mean, types were introduced on lambda calculus to avoid Russel paradox
20:22:52 <slack1256> fellas? was nonsensical what I asked? ;_;
20:23:18 <sarahzrf> sorry i for one am too tired to think this thru
20:26:42 <c_wraith> whether the layers are kept separate from each other depends on the type system. an inconsistent type system isn't the end of the world.
20:27:57 <c_wraith> I mean, Haskell's type system is inconsistent and has been since the start.
20:29:05 <slack1256> That answer the haskell side, good! as we have computational concerns too!
20:29:21 <slack1256> But a a pure type-system can add dependent types and remain consistent?
20:34:36 <jle`> what is a pure type-system?
20:35:04 <jle`> ah, google is my friend
20:35:26 <slack1256> think typed lambda calculus with dependent types
20:35:30 <jle`> but it looks like a pure type system would already have dependent types
20:35:37 <jle`> so what would it mean to add dependent types to a pure type system?
20:38:27 <slack1256> I am fairly sure those are different
20:38:38 <slack1256> a pure type system (bare) is a the lower end of the lambda cube
20:38:56 <slack1256> a dependent type system add depedent types and is like moving on a axis of the lambda cube
20:44:49 <nshepperd> isn't coq dependently typed and also consistent?
20:45:03 <nshepperd> agda too
20:45:19 <nshepperd> not that i understand how either of them work
20:46:56 <slack1256> Exactly. You Need dependent type to formalize anything involving quantification, but those introduce these cross layers types relating for example types and kinds. I thought the original idea of introducing type for term was to disallow this intermixing as it could lead to russell paradox
20:46:57 <jle`> there are a bunch of dependently typed consistent type systems i believe
20:47:12 <jle`> i just don't know enough about pure type systems in specific
20:47:24 <slack1256> they are basically propositional logic
20:51:34 <nshepperd> well, russell's paradox involves a statement like U : U, right?
20:52:24 <nshepperd> i don't think that means you can't mix layers in expressions
20:55:34 <nshepperd> like, the very existence of F : Int -> Type doesn't imply paradox
20:56:19 <nshepperd> it's just that you can't have (Int -> Type) : Type
20:57:16 <nshepperd> but that's fine, because the theorem provers just invent another level of kinds, called Type1, and say Int -> Type : Type1
20:57:57 <nshepperd> hence the tower of universes
20:58:04 <nshepperd> something like that
20:58:10 <slack1256> !!!
20:58:59 <slack1256> interesting
20:59:23 <sarahzrf> in coq there is a cumulative hierarchy of universes but it prints them all as just "Type" and you cannot refer to any of them individually, it just errors out if you try to do something that would require two distinct ones to be the same
20:59:42 <Cale> http://liamoc.net/posts/2015-09-10-girards-paradox.html -- here's a bit of agda code showing how to turn Type : Type into a contradiction by implementing a form of Russell's Paradox
20:59:49 <sarahzrf> https://benzrf.com/uploads/e1fb9a1d3b4f0b30.png
21:00:39 <slack1256> Cale: That page is sooo classy
21:00:52 <sarahzrf> another, simpler approach is to just not have a type of types :-)
21:01:27 <slack1256> collapse everything to two levels, terms and types?
21:01:37 <sarahzrf> yeah
21:01:47 <Cale> Well, everything was already terms and types
21:01:58 <Cale> but just don't have a universe
21:02:04 <sarahzrf> Cale: idk what about something like the CoC where it was terms and terms
21:02:12 <sarahzrf> and : is a relation between terms and terms
21:02:30 <Cale> Well, that's fair :)
21:03:04 <sarahzrf> i dont think thats even being too pedantic, because coq was my first real exposure to dependent type theory, so i got used to the idea that a type is a kind of term :p
21:04:10 <Cale> If you don't have a universe, often you will want some judgment which says when some term is a type
21:05:49 <Cale> So that you can still give sensible formation rules for your type formers
21:14:59 <slack1256> Thank you guys for the link, really informative
21:15:08 <slack1256> specially you nshepperd!
23:15:40 <dansho> so i have something like (a -> b -> b) -> b -> [a] -> [b]
23:16:01 <dansho> i want to fold b, but also output the list of bs
23:16:31 <Ferdirand> that sounds like scanr
23:16:33 <Ferdirand> :t scanr
23:16:34 <Axman6> looks l a lot like scanr/l to me
23:16:35 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
23:16:42 <dansho> ty i'll try that
23:17:36 <dansho> oh, i input the arguments in a different order to hoogle, corrected it and it came up =)
23:35:27 <olligobber> it might be useful if hoogle could permute the inputs, so searching for a -> b -> c might give results for b -> a -> c
23:36:26 <dminuoso> olligobber: It's already searching only stackage due to performance issues, Im guessing this is not trivially possible.
23:42:38 <Cale> huh
23:42:48 <Cale> One of the original goals of hoogle was to do exactly that
23:44:38 <Cale> (and also deal with polymorphism)
23:47:47 <Cale> Perhaps a bunch of that stuff got disabled because it was too expensive to do publicly
23:49:55 <Cale> ah, apparently Hoogle 5 disabled a bunch of it?
