00:11:53 <fresheyeball> hey out there
00:11:57 <fresheyeball> I want my tests to run faster
00:12:16 <fresheyeball> I have all pure tests, in hspec with quickcheck
00:12:32 <fresheyeball> parallel execution appears to do very little in terms of speedup
00:12:45 <fresheyeball> and my 9900K cpu shows 6%
00:12:57 <fresheyeball> why? This is pure code! why can't I eat the cpu?
00:13:14 <joehh> has anyone used opaleye with postgis?
00:16:33 <Axman6> I wanted to but never did
00:17:07 <butterth_> What's the simplest way to parse some Text?
00:17:21 <Axman6> parse what?
00:17:40 <butterth_> Axman6: Well, I want to parse some simple input for an advent_of_code challenge
00:17:43 <joehh> thanks Axman6 - I think I'm just going to write my spatial queries by hand at this stage (postgresql-simple)
00:18:11 <butterth_> So I'm looking to write a function Text -> Maybe [(Int, Int) -> (Int, Int)]
00:18:29 <butterth_> Essentially each character of the input corresponds to an operation (Int,Int) -> (Int,Int)
00:21:29 <fresheyeball> butterth_: I don't understand your intention from that
00:27:49 <MarcelineVQ> butterth_: I'd probably go right to megaparsec, come back so you can see this response
00:28:03 <MarcelineVQ> fresheyeball: if you wanted an answer to your own question you'll need to provide more context. no one can respond to "why does my code ..." without code
00:28:22 <fresheyeball> MarcelineVQ: so I don't know what more I have to say
00:28:34 <fresheyeball> I used the parallel test combinator, but am missing something here
00:28:50 <fresheyeball> if I have all pure code, why it only eating 6%
00:30:21 <fresheyeball> if I run a loop over 10000000 records
00:30:29 <fresheyeball> would I not use 100% of a single core?
00:31:08 <tdammers> "pure code" does not imply "does not allocate"
00:31:24 <tdammers> you can easily write pure code that is RAM-limited rather than CPU-limited
00:31:30 <Lycurgus> depends on the system and if you mean haskell records in core or records requiring io
00:31:34 <fresheyeball> tdammers: are you suggesting that gc is getting pegged?
00:31:47 <tdammers> doesn't have to be GC
00:32:12 <tdammers> even if you don't allocate, just pumping data around RAM can easily stall the CPU
00:33:23 <tdammers> in fact, even just reads can do that, if they come out of order a lot (which tends to be a notorious problem with our beloved go-to data structure, the linked list)
00:33:31 <MarcelineVQ> That aside no one has any idea how you're running your tests, what the tests look like, where you're using the parallel combinator, etc. You say "<fresheyeball> MarcelineVQ: so I don't know what more I have to say" I say, ditto
00:33:54 <tdammers> ^ this, pretty much. Show some code and we might gain some insight.
00:34:12 <fresheyeball> MarcelineVQ: ok
00:34:18 <fresheyeball> so all my tests are property tests
00:34:25 <fresheyeball> and its a test tree build with hspec
00:34:43 <fresheyeball> if I put no parallelization, or parallelize every singe test
00:34:51 <fresheyeball> I get the same cpu usage, and little speedup
00:35:04 <fresheyeball> MarcelineVQ: is there a question I can answer?
00:35:16 <MarcelineVQ> bruh
00:36:00 <fresheyeball> MarcelineVQ: I don't understand what information I would need to provide
00:36:08 <fresheyeball> I think my question is more abstract
00:36:21 <fresheyeball> what would case a thread to use little cpu yet take much time
00:36:23 <fresheyeball> ?
00:36:35 <MarcelineVQ> "Why yes, I build my tests with +RTS -N -RTS and I run them with ./Spec +RTS -N -RTS, in addition here's a <link to my repo with the code I run>"
00:37:01 <fresheyeball> MarcelineVQ: I have confirmed that the threading does work. I run with -N
00:37:11 <tdammers> seriously, post some code
00:37:33 <tdammers> in fact, produce a minimal repro case and post that
00:37:52 <tdammers> chances are that while you're writing the minimal repro, you suddenly realize what the problem is, and we never hear from you again
00:37:59 <tdammers> (at least not on this particular matter)
00:38:15 <fresheyeball> https://pastebin.com/1ttyqjT1
00:38:18 <MarcelineVQ> tdammers already answered your question's abstract version but there's no way to know if that's the answer that applies here
00:38:41 <fresheyeball> MarcelineVQ: tdammers: https://pastebin.com/1ttyqjT1
00:38:53 <fresheyeball> describeP = describe . parallel
00:40:34 <tdammers> OK, not gonna study 300+ lines of that stuff in detail, but it looks like there are many many tests in there. First thing I would do is comment them out one by one to see which ones are slow
00:40:38 <tdammers> I bet it's not all of them
00:40:53 <fresheyeball> tdammers: I timed them individually
00:41:00 <fresheyeball> they are all around 30seconds
00:41:25 <fresheyeball> I found some slow tests, and used modifyMaxSize to speed em up to a more average speed with the rest of the tests
00:41:25 <tdammers> OK, can you write a module with just one of those tests, and only the absolute minimum required boilerplate?
00:41:29 <dminuoso> I want to be able to combine values of list/nonempty together in such a way, that nonempty propagates as a type. Is there a more canonical way than this? https://gist.github.com/dminuoso/e435caa40d56965681206e78255f0f40
00:42:43 <tdammers> dminuoso: I would rewrite the [] <?> NonEmpty instance to get rid of the error
00:43:26 <tdammers> NonEmpty has a Semigroup instance, no? So instead of converting both the list and the NE to [], I'd pattern-match on the list, and then either return the NE unchanged, or convert the list to a NE and use NE's semigroup <>
00:43:33 <MarcelineVQ> I've not used hspec but is this the right level to apply parrallel at? http://hspec.github.io/parallel-spec-execution.html is using it at the top. is it possible that these describeP aren't parallel at all but sequential, with their contents being parallel
00:44:00 <dminuoso> tdammers: Ah, that's a good idea indeed.
00:44:30 <MarcelineVQ> Though that should still result in some cpu useage, I would think
00:45:03 <fresheyeball> MarcelineVQ: I tried that, as well as making them all describeP, and none
00:45:11 <fresheyeball> none was 30% slower
00:45:22 <fresheyeball> all other variants no noticable differnce
00:45:30 <fresheyeball> always 6% cpu
00:45:49 <MarcelineVQ> over what time period? idk if that matters, just curious
00:46:30 <tdammers> it's also possible that whatever it is you're doing is inherently RAM-limited, so trying to achieve 100% CPU might be a futile endeavor
00:49:34 <fresheyeball> MarcelineVQ: 40s
00:49:48 <fresheyeball> tdammers: explain
01:10:43 <dminuoso> ttps://gist.github.com/dminuoso/df214a736fb10b0d2475ab06275f87d8  mm did the wording of this diagnostic get changed recently?
01:13:21 <dminuoso> I thought it read "... is no smaller than the instance head"
01:17:17 <tdammers> fresheyeball: some problems simply can't be solved without a lot of out-of-order memory access, but don't require much in terms of complex CPU processing
01:17:43 <tdammers> take, for example, parsing an ambiguous grammar into some sort of tree
01:17:52 <fresheyeball> go on
01:18:28 <tdammers> on the reading side of things, you have some memory to read from, and while you intend to traverse it sequentially, backtracking will occur often, potentially killing cache performance
01:18:43 <tdammers> and on the tree construction side, you jump around in memory as you extend your parse trew
01:18:48 <tdammers> s/trew/tree
01:19:18 <tdammers> meanwhile, there is no complex processing going on; at the nitty-gritty level, all you're doing is compare-and-jump
01:20:17 <tdammers> it's not like, say, a physics simulation, where you do a lot of numeric processing on flat data sets (which you can just pass over linearly, without ever jumping)
01:25:36 <dminuoso> Monad sans return, is that a thing?
01:25:58 <fresheyeball> dminuoso: yes
01:26:12 <fresheyeball> PureScript calls it bind
01:26:34 <dminuoso> https://hackage.haskell.org/package/semigroupoids-5.3.2/docs/Data-Functor-Bind.html#t:BindA
01:26:37 <dminuoso> Ah indeed.
01:26:47 <dminuoso> That NonEmpty instance is what I want. :)
01:27:15 <fresheyeball> dminuoso: NonEmpty is a monad though
01:27:26 <dminuoso> Oh. Heh.
01:27:30 <dminuoso> Yeah it is of course. :)
01:27:36 <fresheyeball> yeah
01:27:41 <lavalike> when I read Monad sans I thought it was a typeface
01:27:46 <fresheyeball> return x = x :| []
01:28:51 <Rembane> lavalike: It is. https://www.s-ings.com/projects/monad/
01:29:06 <dminuoso> Rembane: But does it come with ligatures for >>=?
01:29:24 <fresheyeball> dminuoso: fira code ftw
01:29:26 <Rembane> dminuoso: I haven't checked. I don't think it does. 
01:29:37 <fresheyeball> I use fira + kitty, so I get ligatures everywhere
01:29:39 <fresheyeball> including in this caht
01:29:42 <fresheyeball> chat*
01:29:56 <Rembane> What's kitty?
01:30:12 <fresheyeball> A gpu based terminal, with ligature support
01:30:25 * dminuoso uses kitty + fira as well
01:30:37 <marmulak> RTL support?
01:30:38 <fresheyeball> dminuoso: twinsees!
01:30:47 <Rembane> Nice! 
01:30:51 <fresheyeball> https://sw.kovidgoyal.net/kitty/
01:30:59 <dminuoso> fresheyeball: And best of all, it uses custom terminal that is not recognized by terminfo, and will likely never be accepted into the database as well 
01:31:08 <dminuoso> So every time you log onto different servers you have headaches.
01:31:19 <dminuoso> *custom term features
01:31:28 <fresheyeball> dminuoso: own all the servers I use
01:31:33 <fresheyeball> they are all nixos, and I fix it there
01:31:45 <fresheyeball> TERM=xterm is all that is needed
01:32:10 <dminuoso> So regarding NonEmpty and [], Im starting to sink deep into this mudhole.
01:32:21 <dminuoso> fresheyeball: Except that has the potential to break things.
01:32:23 <fresheyeball> dminuoso: whats up?
01:32:29 <dminuoso> It's incorrect to set TERM=xterm
01:32:39 <fresheyeball> it works fine for me so far :P
01:33:11 <dminuoso> "I dont care that type punning is undefined behavior. My program works fine so far"
01:33:18 <dminuoso> :p
01:33:31 <fresheyeball> I am not aware of a problem it causes
01:33:39 <fresheyeball> but I would rather help you with NonEmpty
01:33:42 <dminuoso> fresheyeball: Basically Im trying to find ways to mix [] and NonEmpty in such a way, that NonEmpty propagates outwards.
01:33:55 <fresheyeball> what do you mean by mix?
01:33:58 <dminuoso> Sort of like
01:34:18 <dminuoso> let x = 1 :| [1,2,3]; y = [4,5,6] in x <?> y
01:34:32 <dminuoso> So Ive started writing helper typeclasses using fundeps 
01:34:38 <dminuoso> But the more code I write, the more typeclasses I end up writing
01:34:43 <fresheyeball> what does <?> do?
01:34:49 <dminuoso> fresheyeball: <> basically
01:35:02 <fresheyeball> ok
01:35:05 <dminuoso> But in such a way that when you smash a NonEmpty with a list together that you get a nonempty back
01:35:15 <dminuoso> (Such that proof of NonEmpty propagates)
01:35:16 <fresheyeball> so <?> requires that atleast one side is a NonEmpty
01:35:20 <fresheyeball> and the result is NonEmpty
01:35:22 <fresheyeball> correct?
01:35:23 <dminuoso> fresheyeball: No, it works with [] just fine too
01:35:44 <dminuoso> fresheyeball: https://gist.github.com/dminuoso/0b0f06e350822355fda6b06680ac96f6
01:35:48 <fresheyeball> dminuoso: [] <?> [] would not be a nonempty though
01:35:59 <dminuoso> fresheyeball: Precisely.
01:37:15 <lavalike> Rembane: ha!
01:37:29 <MarcelineVQ> when does the mudhole appear
01:38:25 <__monty__> dminuoso: Fwiw I always do `env TERM=xterm256-color ssh` from kitty.
01:39:31 <fresheyeball> dminuoso: so what is wrong with your typeclass approach
01:39:34 <fresheyeball> ?
01:47:10 <MarcelineVQ> dminuoso: wake
01:48:13 <__monty__> Since fonts were mentioned, another nice ligature font is Monoid: https://larsenwork.com/monoid/
01:50:15 <jackdk> this is my favourite font in the history of ever, narrowly beating out even Courier New: https://int10h.org/oldschool-pc-fonts/fontlist/#ibm_vga9
01:51:18 <marmulak> not bad
01:52:40 <__monty__> I'm a dejavu type of guy, can't beat that unicode coverage. Let's take font discussion to #haskell-offtopic though.
01:53:07 <fresheyeball> dminuoso: https://repl.it/@IsaacShapira/PlasticPrimaryInverse
01:53:09 <fresheyeball> my encoding
01:53:19 <fresheyeball> just for fun
01:58:28 <comerijn> This HIE file stuff is looking promising for getting us out of the linter/editor integration breakage that v2-build introduced :>
02:00:46 <asheshambasta> https://pastebin.com/5HRzUikn -- anyone else seeing this? 
02:06:11 <fresheyeball> dminuoso: I made a fancy pants version https://repl.it/@IsaacShapira/PlasticPrimaryInverse
02:06:16 <__monty__> asheshambasta: https://github.com/commercialhaskell/stack/issues/3731
02:07:00 <__monty__> Real solution is to wait until it's fixed. You can workaround by ignoring the expiry though.
02:08:56 <asheshambasta>  
02:08:56 <asheshambasta>             https://github.com/commercialhaskell/stack/issues/3731 -- 12.19 (the resolver I was using) is no longer in this list. 
02:09:02 <asheshambasta> __monty__: thanks 
02:19:00 <asheshambasta> for now I've changed the resolver to 12.26; which works fine. 
02:21:12 <dminuoso> Sorry I had to drop out for a meeting (and will be out again in a moment)
02:21:28 <dminuoso> fresheyeball: That wont cover cases like `f <?> g` where `f :: [a]` and `g :: NonEmpty a`
02:27:45 <dminuoso> fresheyeball: So one problem I start experiencing is that if I start doing this trick across multiple typeclasses, its more comfortable to use associated type families instead (that makes deriving via easier to use)
02:28:47 <dminuoso> For example right now I have: class ToLdapAttr a where type LdFTy a :: * -> *; toAttr :: a -> LdFTy a ByteString
02:29:46 <dminuoso> With some suitable `instance ToLdapAttr Text where LdFTy Text = NonEmpty; ...`, in another remote module Im trying `newtype Alias = Alias Text deriving (..., ToLdapAttr, ...) via Text`, which requires UndecidableInstances apparently
02:37:12 <janat08> some asdf is not in scope with recursivedo, its used at top, defined at botoom: https://www.irccloud.com/pastebin/T2IRKpV9/
02:41:09 <Lears> janat08: Each do block is a new local scope, `asdf` can't escape the `el "span" $ do` block to be known to the one above it.
02:43:01 <janat08> so a way around this, is to to use more lets, and evaluate them within nested do?
02:43:13 <janat08> while placing them in outer do?
02:44:50 <janat08> or I suppose that the whole chain will just evalute when I use the end of it prematurely
02:46:04 <ski>   asdf <- elClass "div" "progress-bar" $ do
02:46:20 <ski>     elAttr "div" asdf $ do
02:46:30 <ski>       el "span" $ do
02:46:39 <ski>         t0 <- liftIO getCurrentTime
02:46:41 <ski>         ...
02:46:53 <ski>         -- attributes <- foldDyn progWidth (progWidth 0 0 ) evented
02:47:02 <ski>         pure (progWidth <$> timer)
02:47:09 <ski>   return ()
02:47:26 <ski> janat08, try something like that ^ ?
02:47:27 <janat08> oh right
02:47:42 <Lears> Yeah. If the constraints of your types don't prevent you from returning the value and binding it at the higher level, that's the way I'd go.
02:49:23 <ski> (yes, so this depends on whether the monadic return type of `el' and `elAttr' and `elClass' is variable or not)
03:14:34 <janat08> So the asdf is in scope, and is of the right type on outer do, yet it's still out of scope in nested do https://www.irccloud.com/pastebin/LFQZjXNO/
03:19:13 <Lears> I'm not sure that `rec` block isn't empty, though I'd think an empty rec block would be an error. Try indenting everything after `rec`, or removing it and changing the outermost do for `mdo`.
03:22:35 <janat08> it worked after indenting.
03:31:44 <MarcelineVQ> dminuoso: yeah that's unfortunate, had a go at it before finding https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-type-families which says why at the bottom but you've probably seen already
04:44:46 <merijn> hmm, does anyone know if packdeps has a way of notifying you by email about newer dependencies?
04:49:41 <merijn> Ah, there's an RSS feed, I suppose that works
04:55:40 <libertyprime> what reason would i be getting a ghc-pkg fork bomb? it only seems to happen on some repositories
04:55:43 <libertyprime> http://ix.io/1NpH
04:59:16 <libertyprime> ghc-pkg is a wrapper for "stack exec -- ghc-pkg"
05:02:11 <Jinna> Why does http://nikita-volkov.github.io/stm-containers/ suggest `TVar (HashMap (TVar a))` and not just `TVar HashMap`?
05:02:33 <Jinna> I can unbox the map, do certain inserts/deletes and compute a new map, which I then write back into the TVar.
05:02:41 <Jinna> Why should the keys also be TVared?
05:05:18 <hpc> it says in the very next sentence, so you can update individual items without a global transaction
05:07:09 <hpc> so, imagine the transaction you describe being performed multiple times simultaneously, on say {"a": 1, "b": 1}
05:07:21 <hpc> both transactions start with that as their perspective of the starting value
05:07:27 <Jinna> Yes.
05:07:33 <hpc> perhaps the first transaction produces {"a": 2, "b": 1}
05:08:13 <hpc> it changes out from under the second transaction, which would have made {"a": 1, "b": 2}
05:08:27 <hpc> so it starts over with {"a": 2, "b": 1} and makes {"a": 2, "b": 2}
05:08:50 <hpc> if starting over is expensive, that's bad
05:08:57 <hpc> especially if it only changes the one entry
05:09:18 <hpc> you could have independent transactions from 1 to 2, on TVars for each item in the HashMap
05:10:21 <Jinna> It seems though that the keys reside in a TVar. If the keys don’t change but only the values, wouldn’t then the outer TVar (which holds a reference to the full map) detect that something has changed, that it no longer is the original map?
05:10:51 <merijn> Jinna: The map hasn't changed
05:11:15 <merijn> Jinna: The map contains TVars, changing the content of the TVar doesn't change what's in the map (still the same TVar)
05:11:20 <Jinna> merijn: if the first map has a value of `1` under the TVared key "a", and now it has a 2 – then it must be a different map.
05:11:41 <Jinna> merijn: I would understand it if the values were TVars.
05:11:52 <Jinna> The TVars stay constant the whole time. Only what they reference changes.
05:11:53 <merijn> Jinna: No, there is no '1' in the map, there is just a TVar in the map
05:12:07 <merijn> hmm, lemme check the implementation
05:12:22 <Jinna> merijn: TVar (Map (TVar String) (TVar Int))    <-  here I could understand it.
05:12:36 <hpc> the HashMap's hashing algorithm for the TVar can't use the value of the TVar without dipping into STM
05:12:42 <Jinna> But the signature looks like:   TVar (Map (TVar a))    so the type of the values could be directly Int
05:13:03 <hpc> it's like you have a pointer to an int
05:13:15 <hpc> and instead of hashing the number 1, you're hashing 0x91726439821643 or whatever
05:13:29 <Jinna> hpc: wouldn’t it be like having a pointer to an int if the value had the type (TVar Int)  instead of just  Int ?
05:13:51 <hpc> if you mutate the 1, the pointer is still to the same address, it hasn't changed
05:13:57 <hpc> so its hash hasn't changed, so the map doesn't need to change
05:14:10 <Jinna> We have a map   `tvar({tvar("a"): 1,  tvar("b"): 2})
05:14:26 <Jinna> The keys stay constant, even if I change "a" to "c".
05:14:33 <merijn> Jinna: Sure, so?
05:14:38 <Jinna> It would still be the identical TVar.
05:14:53 <merijn> Jinna: You can't do lookups based on TVar contents with your example type
05:15:01 <Jinna> But if we now change the 1 in "a" to 20  => then the map would look like:   `tvar({tvar("a"): 20, tvar("b"): 2})`
05:15:06 <Jinna> This is different from `tvar({tvar("a"): 1, tvar("b"): 2})`
05:15:07 <Ariakenom> "TVar (Map (TVar a))" is a type error. you only applied one type to Map
05:15:25 <ski> Jinna : think of the values of type `TVar a' as merely "array indices". the "content of the TVar" isn't (conceptually) located "inside" the `TVar a'
05:15:32 <Jinna> Ariakenom: yes, it is a partially applied type. Let’s set the value to type Int then.
05:15:34 <Ariakenom> well not "you" it is what's in the article
05:16:08 <Jinna> ski: the type signature says that the _keys_ are what’s inside a TVar. What if now the values are Int?
05:16:19 <Jinna> And now one of the values change. Then it is a new map, no?
05:16:40 <Jinna> If the TVar that points to the string "a" now points to a string "c" then sure, the map is still identical.
05:16:40 <Ariakenom> Jinna: what makes you say that the keys are TVars?
05:17:20 <Jinna> Ariakenom: because the article gives the type `TVar (HashMap (TVar a))`
05:17:30 <Ariakenom> Jinna: which is a type error
05:17:32 <Jinna> I choose "String" for a.
05:17:39 <Ariakenom> and doesn't supply keys and values
05:17:55 <Jinna> Ariakenom: of course, it is only partially applied. We still need the type of the _values_. Let’s choose Int.
05:18:08 <Jinna> The article allows that. Instead it could have said:  `TVar (HashMap (TVar a) (TVar b))`
05:18:14 <Ariakenom> no. you can't make a correct type with that component
05:18:25 <Ariakenom> it looks like a typo to me
05:18:40 <Jinna> Then I would understand that I can „change” the values too without changing the outer hashmap.
05:18:49 <Ariakenom> they probably did mean "TVar (HashMap k (TVar a))"
05:19:00 <Jinna> Ariakenom:   `type MyMap a b = TVar (HashMap (TVar a) (TVar b))`
05:19:04 <ski> Jinna : hm, `HashMap' takes two type parametes, which of them (both ?) is the `TVar' thing ?
05:19:14 <Jinna> Ariakenom: yes well if the keys had just the type `k` then I would understand it.
05:19:27 <Ariakenom> because with TVars as keys you have to supply the same TVar. not a TVar with the same content
05:19:27 <Jinna> ski: the article only puts the _keys_ into a TVar.
05:19:42 <Jinna> Ariakenom: yes exactly.
05:20:56 <Ariakenom> % :k TVar (Map (TVar Int))
05:21:06 <yahb> Ariakenom: ; <interactive>:1:7: error:; Not in scope: type constructor or class `Map'; Perhaps you meant `M.Map' (imported from Data.Map)
05:21:14 <Ariakenom> % :k TVar (M.Map (TVar Int))
05:21:15 <yahb> Ariakenom: ; <interactive>:1:7: error:; * Expecting one more argument to `M.Map (TVar Int)'; Expected a type, but `M.Map (TVar Int)' has kind `* -> *'; * In the first argument of `TVar', namely `(M.Map (TVar Int))'; In the type `TVar (M.Map (TVar Int))'
05:21:24 <Jinna> So, I can understand the type `type MyMap k v = TVar (HashMap k (TVar v))`
05:21:25 <Ariakenom> % :k M.Map (TVar Int)
05:21:25 <yahb> Ariakenom: M.Map (TVar Int) :: * -> *
05:22:10 <Ariakenom> % :k TVar
05:22:10 <yahb> Ariakenom: TVar :: * -> *
05:22:35 * ski . o O ( composable continuations in types )
05:22:56 <Ariakenom> you can't apply (Type -> Type) to (Type -> Type)
05:23:04 <Ariakenom> Jinna: yes. it looks like that's what the article meant
05:23:18 <Jinna> The outer TVar makes sense, so that we can insert/delete keys.
05:23:28 <merijn> Jinna: The point is that changing the value a TVar points to, doesn't change the value (and thus ordering/sorting) of the TVar, so that map's structure is not affected
05:23:49 <Jinna> merijn: yes, I understand that part. So this signature allows us to change the _keys_ of the map.
05:24:04 <ski> which signature ?
05:24:05 <Jinna> {"a": 1,  "b": 2}  =>   {"c": 1, "b": 2}
05:24:13 <merijn> Not really, because you still need the exact same TVar to look up the value
05:24:41 <Jinna> merijn: it would be the same TVar. Exactly that TVar that first pointed to the string "a" which now points to the string "c".
05:24:53 <merijn> Yes, but what does that matter?
05:25:01 <Jinna> That is the same TVar, it did not change. But what it points to changed. That’s fine.
05:25:15 <Jinna> But now let’s assume that we do want to update the _value_ of the TVar which points to "a".
05:25:22 <Jinna> That value is the Int 1.
05:25:50 <Jinna> 1) {"a": 1, "b": 2}     2) {"a": 5, "b": 2}
05:25:57 <Jinna> Both maps have two keys, but they are different.
05:26:16 <Jinna> They keys were unchanged. Only one value was updated.
05:26:27 <Jinna> And that value, the 1, was not inside a TVar.
05:26:34 <Jinna> The full map is, and the keys are.
05:26:44 <ski> are you talking about `TVar (Map (TVar String) Int)', now ?
05:26:46 <Jinna> But the values are plain Ints.
05:26:53 <Jinna> ski: I am talking about that all the time.
05:27:25 <Jinna> How is `TVar (Map (TVar String) Int)` any better than `TVar (Map String Int)`?
05:27:38 <Jinna> Provided what I want to update is that Int.
05:28:03 <ski> (`TVar (HashMap k (TVar v))' and `TVar (HashMap (TVar a) (TVar b))' was also mentioned (by you). it wasn't clear (to me) which you were discussing now)
05:28:05 <Jinna> I can see that `TVar (Map String (TVar Int))` works better here.
05:28:20 <Ariakenom> Jinna: nobody wants "TVar (Map (TVar String) Int". You just interpreted that from a typo
05:28:25 <Jinna> ski: the article seems to allow `TVar (Map (TVar String) Int)`
05:28:36 <Jinna> Ariakenom: that would be fine then. If you agree that it is a typo then all makes sense.
05:29:13 <Ariakenom> .... the article's type is still an error. it's like "abs abs"
05:29:44 <Jinna> Ariakenom:  is   `type k v = TVar (Map k (TVar v))`   illegal?
05:29:50 <Jinna> Ariakenom:  is   `type MyMap k v = TVar (Map k (TVar v))`   illegal?
05:30:48 <Ariakenom> No. Am I looking at the wrong article? It just has TVar (HashMap (TVar a))
05:31:02 <Jinna> I think he just talks about partial type application. Essentially   `TVar (Map (TVar a) b)`
05:32:34 <ski> `TVar (HashMap (TVar a)) (TVar b)' is not `TVar (HashMap (TVar a) (TVar b))'
05:32:40 <ski> (the former is a kind error)
05:32:49 <Jinna> In my opinion the article mentions this incomplete signature to say: „Hey, a hashmap inside an outer TVar whose keys are TVars and the values are whatever you want, for example Ints”.
05:33:24 <Lears> Since what they've given is a kind error, I doubt there's more to it than "typo".
05:33:27 <ski> (or `TVar (HashMap (TVar a)) Int' vs. `TVar (HashMap (TVar a) Int)', if you prefer)
05:34:00 <Jinna> ski: yes, it is not valid Haskell code, but is understandable for what I just said. The reader will know it is a map inside a tvar, where the keys are tvars too and where we have a user-specific type for the values.
05:34:23 <Ariakenom> no, that's not what I read
05:34:50 <Jinna> Let me ask this then: why would anyone want this signature:   `TVar (Map (TVar String) Int)` ?
05:35:05 <Jinna> My answer would be: because this person expects that the _keys_ regularily change.
05:35:25 <ski> it wasn't clear to me whether they were using some notion of `HashMap' with a fixed key type, or intended the `TVar a' part to be the value, or the key, type
05:35:40 <Jinna> afk 1h
05:35:54 <Taneb> TVars don't have an ord instance so Map (TVar String) Int wouldn't be usable
05:36:27 <ski> Jinna : i think it would be pretty unusual to want to have the keys change, but not the values
05:46:55 <boomer> any ml developers?
05:47:53 <ski> perhaps you could try #sml,#ocaml or ##fsharp ?
05:54:03 <Ariakenom> ski: these days ml can mean machine learning :D
05:54:49 <ski> yes, or Machine Language
05:54:54 <marmulak> I started playing around with kitty and it appears to use 10x more CPU time than gnome-terminal
05:55:43 <marmulak> I'm a little disappointed since its claim that using the GPU offloads work from the CPU led me to believe it's lighter on the CPU
05:57:26 <ski> Ariakenom : i figured that if you join a Haskell channel, asking about ML, that might be what you're looking for. it would be better if they could have elaborated on what they were after, though
05:58:05 <ski> (they're in #sml atm, though. i'm still not sure what they're looking for)
06:00:53 <Ariakenom> ski: exiting, tell me if you find out 
06:01:23 <ski> they just said something which leads me to believe they're indeed looking for Machine Learning stuff
06:15:59 <ski> (fwiw, i pointed them in the direction of ##machinelearning and ##machinelearning-general, and they left. still dunno for sure whether that's what they were interested in)
06:51:11 <delYsid> Whats your favourite 2019 haskell talk on youtube, so far?
06:51:26 <roidusilence> hello ! I was wondering : Is it possible to use some arcane function to be able to execute a function under ghci and another under ghc ?
06:52:30 <rabbitonweb> @delYsid the ones i'm waiting for are not yet released :)
06:52:30 <lambdabot> Unknown command, try @list
06:52:56 <rabbitonweb>  delYsid the ones i'm waiting for are not yet released :)
06:54:28 <delYsid> Oh, comonad by example just popped up in my subscription stream, looks fair enough :-)
06:54:46 <d34df00d> There is no way to combine DerivingVia and StandaloneDeriving is it?
06:54:46 <rabbitonweb> can you share a link?
06:55:54 <delYsid> rabbitonweb: https://www.youtube.com/channel/UCCeiYYR2fCXarkfSqqFBwuA
06:56:10 <d34df00d> Ah, deriving via ... instance ...
06:56:35 <mniip> roidusilence, you can tell compiled thunks from interpreted
06:56:44 <mniip> unless they're loaded in ghci with -fobject-code
06:58:08 <merijn> So, on macOS what's the best way to install stack that 1) makes it easy to nuke and 2) doesn't involve curling a shell script from the web into bash? >.>
06:58:34 <mniip> use wget and/or zsh?
06:58:40 <roidusilence> mniip, not sure I follow. 
06:58:41 <merijn> mniip: >.>
06:59:13 <roidusilence> Also, I think I didn't specify what I was trying to achieve clearly enough : 
06:59:27 <merijn> roidusilence: I think you're right about that ;)
06:59:59 <roidusilence> I have a program in  which some functions use forkIO. As a result they don't correctly work under ghci
07:00:18 <roidusilence> I wanted to have some kind of way to say : if you're under ghc, use this. If not, use this instead
07:00:28 <roidusilence> ifReplThenElse lol
07:01:02 <merijn> Can you define how they don't work correctly in ghci?
07:01:17 <roidusilence> Sure. I'm using the SFML library
07:03:40 <roidusilence> when I call the function, which uses a forkIO to parse a file in the background and fill a TMVar, I get this : https://pastebin.com/Fnn9BfDH
07:03:46 <roidusilence> if I'm on ghci
07:03:53 <roidusilence> but it works fine when compiled.
07:04:25 <roidusilence> so I was thinking  maybe I can just make a alternative function that just parses the file in the main thread for ghci.
07:06:21 <roidusilence> Note : it
07:06:39 <roidusilence> actually works besides that annoying message, but I'd like to do w/o
07:13:16 <Ariakenom> roidusilence: I think you can only call openGL from the main thread. So I think your ghc code is wrong too. are you using the threaded runtime for ghc?
07:13:50 <yoav_> Hey, I have a function that turns a String into a Comic like so: "toComic s = (extractTitle s) (extractImages s) (extractAltText s) (extractExplanation s)". Is there a way to make it prettier?
07:14:00 <roidusilence> I believe the ghc code is fine, else I would get this warning (not the first time I see it)
07:14:01 <roidusilence> yep
07:14:18 <dminuoso> yoav_: Yes.
07:14:20 <yoav_> I forgot the "Comic" constructor at the beginning of the function I typed, but you get what I meant
07:14:42 <yoav_> dminuoso: and what would that way be?
07:14:44 <dminuoso> yoav_: Are you familiar with the Applicative instance of `((->) a)`?
07:14:58 <rabbitonweb> oh, monadic party videos are already online? polish community stronk!
07:15:07 <yoav_> dminuoso: Somewhat with the concept, not much with the practicality
07:15:58 <dminuoso> yoav_: Do you reuse extractTitle/extractImages/etc in other places?
07:16:22 <yoav_> dminuoso: Nope, toComic is the only place they're called
07:16:37 <dminuoso> yoav_: My personal preference would be local bindings that directly use `s` from the outer
07:16:39 <mniip> regarding the original question the closest solution would probably be,
07:16:44 <mniip> % $(location >>= \l -> if loc_package l == "interactive" then [|True|] else [|False|])
07:16:44 <yahb> mniip: True
07:16:49 <dminuoso> yoav_: e.g. `toComic s = Comic title ... where title = ...`
07:17:25 <roidusilence> Ariakenom : to clarify I'm not drawing anything in the forked function. I'm really just parsing files and collecting the results
07:17:55 <dminuoso> yoav_: Just for reference, the trick I was thinking of is: Comic <$> extractTitle <*> extractImages <*> extractAltText <*> extractExplanation $ s
07:18:02 <dminuoso> yoav_: But using where bindings is much cleaner :)
07:18:16 <yoav_> dminuoso: I absolutely love that trick :)
07:18:19 <yoav_> thanks!
07:20:41 <Ariakenom> roidusilence: oh. and whether or not you use forkIO for those changes OpenGL warnings? that's strange
07:20:51 <roidusilence> I know right ?
07:23:49 <d34df00d> Let's say I have the following instance declaration: instance (D1 t from ~ Rep parent', GCompile m parent' from to) => GCompile m parent (D1 t from) (D1 t to) where
07:24:54 <d34df00d> Do I understand correctly that it reads as "if the RHS matches — if the types are in the form of (D1 t from) and (D1 t to) — require that GCompile is also satisfied for (m, parent', from, to) where parent' is such that Rep parent' is D1 t from)"?
07:25:19 <d34df00d> s/in the form/of the form/
07:26:38 <mniip> yes
07:26:54 <d34df00d> Next question then: does it make sense?
07:27:07 <mniip> when solving for a constraint (GCompile _ _ _ _) it first only considers the RHSes of the instances
07:27:15 <mniip> then when one matches it adds its context to the wanted constraints list
07:27:27 <d34df00d> Cause I'm getting "Could not deduce: Rep parent'0 ~ M1 D t from from the context: (D1 t from ~ Rep parent', GCompile m parent' from to)"
07:27:50 <mniip> sounds like an ambiguity check failing
07:27:59 <dminuoso> yoav_: In essence, using the Applicative/Monad instance you can replace the `function needing an argument` with just the `function`, pretending that it's applied to an argument already.
07:28:04 <mniip> do you have a fundep that lets "parent'" be determined?
07:28:13 <dminuoso> yoav_: That's one of my mindmodels for the reader instance. :)
07:28:48 <d34df00d> mniip: nope. But isn't Rep injective so that I don't really need fundeps for this?
07:28:54 <d34df00d> GHC.Generics.Rep
07:29:02 <mniip> no
07:29:10 <d34df00d> Rats!
07:29:12 <mniip> I don't think there's anything that guarantees injectivety of Rep
07:29:20 <mniip> not even on an InjectiveTypeFamilies level
07:29:21 <d34df00d> Let me think where could I stick a fundep.
07:30:22 <nonzen> Could anyone here fix the certificate error on https://book.realworldhaskell.org ?
07:32:25 <d34df00d> mniip: I don't think I could reasonably have a fundep for the general case of GCompile.
07:32:42 <d34df00d> Though I can guarantee the fundep of parent on from for the case of D1.
07:32:51 <d34df00d> Can I somehow express this?
07:33:50 <mniip> type family F;  instance (D1 t from ~ Rep (F from), GCompile m (F from) from to) => ...
07:36:42 <d34df00d> mniip: I'm not sure how that works.
07:37:17 <d34df00d> Or shall I just write down the instances for the cases I care about?
07:37:30 <mniip> tbh I need more info
07:39:37 <jgt> rabbitonweb: Siema Paweł
07:39:41 <d34df00d> mniip: I'm having a Generics implementation of a type class Compile m from to with a method compile :: from -> m to: https://github.com/0xd34df00d/monoblock/blob/master/src/Web/Adblock/Interpreters/Compile.hs so that the client code only defines the specific transformations like https://github.com/0xd34df00d/monoblock/blob/master/src/Web/Adblock/Interpreters/Stupid.hs#L32-L33 and delegates the rest to it like https://github.
07:40:12 <d34df00d> mniip: now I'm trying to pass the parent object of a subobject currently being compiled.
07:41:04 <d34df00d> So I thought if I write a specific instance for D1 then I could just do smth like compile' _ p@(M1 x) = M1 <$> compile' (to p) x
07:42:20 <yoav_> if I have a function `addPrefix string = "prefix_" ++ string`, would it be better to write it as `'p':'r':'e':...:string` or does ghc optimise this?
07:45:35 <mniip> yoav_, doesn't matter
07:47:43 <Ariakenom> yoav_: if you want performance you should use Text instead of String
07:47:54 <lyxia> mniip: even though GHC can't inline ++ because it's recursive?
07:52:31 <Jinna> http://tunes.org/~nef/logs/haskell/   => 403  – is this new?
07:54:57 <yoav_> mniip: Ariakenom: alright, thanks!
08:02:02 <sclv> Jinna: yes. I don't know who to contact about it. if anybody does, it would be good
08:03:33 <d34df00d> mniip: well, looks like Rep (Proxy a) = Rep (Proxy b) for all a, b, so what I want is just not doable.
08:45:49 <Jinna> Is there a lib which can parse "2018-11-28T21:38:41 GMT" for me into msecs since 1970?
08:46:38 <Welkin> read a UTC time then convert to posix
08:46:54 <Welkin> use the time package
08:50:07 <merijn> Jinna: Depending on what exactly you mean: Yes, no, maybe
08:51:08 <Welkin> posic time is imcroseconds in the time package I believe
08:51:31 <Jinna> Welkin: microsecs are fine too. thx
08:58:40 <Ariakenom> Welkin: well seconds in fixed point to a precision of microseconds
08:59:33 <Ariakenom> no picoseconds
09:00:11 <Ariakenom> is it without leap seconds?
09:02:41 <nshepperd> depends what you mean by 'without'
09:03:57 <nshepperd> to get the actual physical number of seconds you'd need to download a leap second table from somewhere and use Data.Time.Clock.TAI.utcToTAITime
09:04:14 <nshepperd> to reverse the leap second mutilation of unix time
09:13:24 <hololeap> i'm looking for a way, in essense, to do this: ConduitT i o1 m () -> ConduitT i o2 m () -> ConduitT i (o1, o2) m ()
09:17:36 <Ariakenom> nshepperd: isn't that wrong. I thought unix time was with leap seconds ... the wiki article confuses me
09:22:52 <Ariakenom> (I mean "isn't the time library wrong")
09:23:34 <nshepperd> unix time is 'with' leap second mutilation
09:24:03 <nshepperd> it doesn't count the physical number of seconds since 1970
09:25:36 <Ariakenom> actual seconds since 1970 is a more useful metric. but that isn't really used, right?
09:27:57 <nshepperd> very rarely
09:31:26 <Welkin> it is used in elm as the standard time unit
09:31:32 <Welkin> milliseconds though
09:31:45 <hololeap> ok, i made a function that fits what i was asking for, but i'm wondering if this would work in the real world: http://dpaste.com/26PESQC
09:32:41 <nshepperd> it would be much saner to use actual seconds, but also a bunch of work to fix everything
09:33:08 <hololeap> if i did something like `(thisConduit `fanoutC` thatConduit)`, would there be a chance that one would grab a value from `await` and the other wouldn't?
09:37:19 <hololeap> or would it not behave as expected, due to some other reason?
09:37:38 <phadej> I think Jinna meant "convert to unix time" and not "convert to physical seconds since 1970-01-01T00:00:00Z"
09:41:21 <nshepperd> yes, probably. comparing to unix timestamps is the usual reason for getting seconds since 1970
10:00:57 <ahri> I was using `Identity` as the base monad in my `StateT` (for testing), but then I figured I'm using hspec so I may as well use its monad, but trying to swap out `Identity` for `SpecWith` results in a compile error telling me `SpecWith` should have 1 arg, but providing it with `()` gives me another error saying that `StateT` was expecting kind `* ->
10:00:57 <ahri>  *` and that `SpecWith ()` is of kind `*` (which is why I assumed `SpecWith` would work in the first place!) - what am I misunderstand?
10:04:58 <dminuoso> ahri: Did you perhaps forget to supply parens? :)
10:05:13 <dminuoso> e.g. `StateT (SpecWith ()) ...`
10:05:33 <dminuoso> Type applicatios is, like function application, left associative.
10:06:30 <ahri> I'm doing `StateT a (SpecWith ())`
10:07:09 <ski> maybe you meant `StateT a SpecWith ()' ?
10:08:57 <ahri> well I subbed out `Identity` from `StateT a Identity` in this situation, which was compiling
10:09:32 <ahri> I note that `SpecWith` is a type synonym defined as `type SpecWith a = SpecM a ()`
10:10:25 <ski> what you said seemed to imply `SpecWith' had kind `* -> *', which would render `StateT a (SpecWith ())' a kind error, but `StateT a SpecWith' would not be
10:10:33 <ski> (assuming `a :: *', of course)
10:11:36 <dmwit> ahri: Type synonyms can't be partially applied. This is independent of kinding concerns. So there's no conflict between "I need another argument for the type synonym to be fully applied" and "I need fewer arguments to have the right kind".
10:12:10 <ahri> I think that points me in the right direction, then
10:12:14 <dmwit> ahri: You may use a newtype wrapper instead, which can be partially applied; or, if it is possible to, you may expand the type synonym so that no partial application of type synonyms is needed.
10:12:39 <ahri> I guess a newtype is needed as I need to switch the order around
10:12:46 * dmwit nods
10:13:46 <ski> oh, right. missed that
10:13:51 <ahri> it's just weird to me because `:k SpecWith` tells me it's of kind `* -> *` so following the GHC errors gets me running in circles
10:14:18 <dmwit> Yeah. There is a special case in the implementation of :k for type synonyms.
10:14:23 <dmwit> It is lying just a tiny bit.
10:14:41 <ahri> hah, well that's good to know :)
10:14:54 <ahri> at least I'm not going (too) crazy
10:15:14 * ski tend to think of them as macros, sortof
10:15:48 <ski> (and then `LiberalTypeSynonyms' would give you higher-order macros)
10:25:51 <d34df00d> Are there any libraries for matching wildcards with * and ? in them against other strings?
10:26:04 <d34df00d> So that I don't go to C to call fnmatch.
10:26:31 <d34df00d> I googled a bit, but variations of "wildcard patterns" in haskell context isn't a particularly precise query.
10:32:08 <dmwit> d34df00d: shake has a thing for it, though that may be a bit of a heavy dependency just for that.
10:32:27 <dmwit> Oh, actually, it's in its own package now, nice!
10:32:45 <dmwit> It's specific to FilePaths though (so handles things like directory separators specially).
10:32:51 <dmwit> ?hackage filepattern
10:32:51 <lambdabot> http://hackage.haskell.org/package/filepattern
10:33:53 <dmwit> d34df00d: You might also like regexen. The regex corresponding to * is .* and the regex corresponding to ? is ., so it shouldn't be too hard to change your code to use those wildcards instead.
10:36:05 <d34df00d> dmwit: awesome, thanks a lot!
10:36:23 <d34df00d> I'm actually matching URLs that are quite directory-ish, so it's even better this way!
10:40:10 <dminuoso> d34df00d: regex-applicative is also an option.
10:40:30 <dminuoso> It's a wonderfully light solution.
11:04:29 <HenryCH> i was trying to use the state monad for something and halfway through realized maybe i just want to fold.. anyone care to explain when using state is decidedly better?
11:07:20 <boj> HenryCH: when you have a large number of functions and don't want to explicitly thread the state parameter through it all
11:07:43 <dmwit> :t foldr
11:07:45 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:08:01 <dmwit> `a -> b -> b` is *a bit like* `a -> State b ()`.
11:08:23 <dmwit> So if you only care about the end state, but not the computed value, perhaps `State` is indeed overkill.
11:08:39 <dmwit> But maybe you care about both, and then a direct fold isn't enough.
11:08:44 <dmwit> :t mapAccumL
11:08:46 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:09:09 <dmwit> This is a bit more like a stateful thing. By the time you're using this, I would recommend `traverse` in the `State` monad instead.
11:09:31 <dmwit> (`a -> b -> (a, c)` is *a bit like* `b -> State a c`.)
11:09:55 <dmwit> (Sorry, *a* `State` monad, not *the* `State` monad.)
11:11:04 <Rembane> There are many State-monads out there, but this State-monad is mine.
11:19:27 <HenryCH> thks
12:36:54 <Krisenceto_Love> I am super horny & wet. Let's have fun together. The fun is guaranteed, boys! Join & watch my Live ---> https://t.co/TSM79nBBmt
12:37:10 <phadej> 7kick ...
13:50:11 <sm> too many of those lately..
13:56:01 <int-e> what is the frequency, once a day?
13:56:38 <sm> feels like more than one a week, anway
13:56:43 <sm> anyway
13:57:43 <vktec> How should a literal backslash be matched in an alex lexer? I've managed to do it using [\\] but that seems like a strange method. Neither \\, "\\" nor '\\' seem to work
14:31:47 <__monty__> vktec: Hmm, afaiu according to the grammar it should be \\.
15:15:58 <jackdk> I
15:17:50 <Welkin> U
15:19:21 <ski>    O
15:28:12 <jackdk> whoever put the apostrophe next to the enter key has much to answer for
15:29:04 <hpc> i agree
15:29:49 <d34df00d> Oh the joy of having ergodox with custom layout.
15:29:50 <dmwit> ski: Why skip E? (Perfect spacing, by the way.)
15:29:50 <Welkin> that's a single prime mark! not an apostrophe!
15:29:54 <hpc> it's probably the same person who put ^K and ^J next to each other
15:30:46 <dmwit> (Joke: in QWERTY keyboards, U and O are next to I. But on Dvorak the left-hand part of the home row is IUEOA from right to left.)
15:33:09 <jackdk> d34df00d: I agree, but it's at work
15:33:11 <ski> dmwit : oh, i didn't think of that
15:33:30 <ski> (spacing was intentional, obviously)
15:36:57 <infinisil> Dvorak masterrace
15:37:10 <infinisil> Programmer dvorak
15:39:53 <hpc> let's not judge each other based on keyboard layouts
15:40:00 <hpc> let's judge based on choice of keycaps instead
15:40:49 <d34df00d> Switches pls.
15:41:02 * d34df00d recently changed his to Kailh Copper.
15:41:56 <jackdk> zealios of some sort, don't remember exactly which
15:43:00 <hpc> on a related note, out of curiosity is there a way to match the build environment hackage uses?
15:54:29 <topos> eacameron hey there
15:54:38 <topos> it's emily
16:18:17 <ski> eacameron has been idly for three days, apparently
16:27:26 <hpc> but he's been eacameron for longer then three days :P
16:52:29 <libertyprime> let's just say i have some imports in my ~/.ghci and these packages are not available to the specific stack project i am in, how would i resolve the import name to the package name that i need automatically and install what i need, without resorting to searching online the import name
16:52:49 <libertyprime> if its just on hackage
16:56:08 <libertyprime> another question: the :browse command of ghci appears to only give information on system modules. I can't list module properties of modules defined in the project i'm working on
16:56:27 <libertyprime> is there some way to get that information? I'd just like to list the contents of a module
17:01:41 <thosgood[m]> @pl \f g h i j -> f . h . j . i . x . g
17:01:41 <lambdabot> (. (flip ((.) . (.) . (.)) . (flip (.) .) . flip (.) . (x .))) . (.) . (.) . (.) . (.)
17:02:23 <thosgood[m]> @unpl (. (flip ((.) . (.) . (.)) . (flip (.) .) . flip (.) . (x .))) . (.) . (.) . (.) . (.)
17:02:23 <lambdabot> (\ x0 x1 x2 x3 x4 x5 -> x0 (x2 (x4 (x3 (x (x5 x5))))))
17:16:24 <thosgood[m]> hm that doesn’t seem right...
17:40:56 <infinisil> That's nasty!
18:00:07 <ski> should be `x1 x5'
18:06:06 <hpc> ski: the @pl/unpl commands are known to have iffy output if the input doesn't typecheck
18:06:18 <hpc> or, thosgood[m] i guess
18:07:42 <hpc> @pl \f g h i j -> f . h . j . i . g
18:07:42 <lambdabot> (. (flip ((.) . (.) . (.)) . (flip (.) .) . flip (.))) . (.) . (.) . (.) . (.)
18:07:52 <hpc> @unpl (. (flip ((.) . (.) . (.)) . (flip (.) .) . flip (.))) . (.) . (.) . (.) . (.)
18:07:52 <lambdabot> (\ x x0 x1 x2 x3 x4 -> x (x1 (x3 (x2 (x2 x4)))))
18:08:44 <hpc> oh, hmm
18:09:07 <hpc> :t \f g h i j -> f . h . j . i . g
18:09:08 <lambdabot> (b1 -> c) -> (a -> b2) -> (b3 -> b1) -> (b2 -> b4) -> (b4 -> b3) -> a -> c
18:09:24 <hpc> :t (\ x x0 x1 x2 x3 x4 -> x (x1 (x3 (x2 (x2 x4)))))
18:09:27 <lambdabot> (t1 -> t2) -> p -> (t3 -> t1) -> (t4 -> t4) -> (t4 -> t3) -> t4 -> t2
18:09:58 <hpc> neat
18:10:34 <hpc> :t (. (flip ((.) . (.) . (.)) . (flip (.) .) . flip (.))) . (.) . (.) . (.) . (.)
18:10:36 <lambdabot> (c1 -> c2) -> (a -> b1) -> (b2 -> c1) -> (b1 -> b3) -> (b3 -> b2) -> a -> c2
18:10:55 <hpc> so @unpl has a bug
18:13:43 <int-e> Eww, that code was no fun at all... I tinkered with it 3 years ago.
18:14:49 <int-e> Apparently it's still wrong :)
18:15:30 <hpc> that's the secret of programming
18:15:32 <hpc> it's always wrong
18:19:56 <ski> @type \f g h i j -> f . h . j . i . ?x . g
18:19:58 <lambdabot> (?x::b1 -> b2) => (b3 -> c) -> (a -> b1) -> (b4 -> b3) -> (b2 -> b5) -> (b5 -> b4) -> a -> c
18:20:51 <hpc> :t x
18:20:52 <lambdabot> Expr
18:21:09 <hpc> i guess pl/unpl treat it differently
18:22:01 <ski> it's probably not in scope there, i guess, just treated as an arbitrary free variable
18:22:35 <hpc> oh well
18:26:07 <int-e> @. unpl pl \f g h -> f . h . g
18:26:07 <lambdabot> (\ x x0 x1 x2 -> x (x1 (x2 x2)))
18:26:20 <int-e> (smaller example)
18:40:28 <ski> @. unpl pl \f g h -> f . g . h
18:40:28 <lambdabot> (\ x x0 x1 x2 -> x (x2 (x1 x2)))
18:59:28 <int-e> Hah, I found it.
19:09:22 <int-e> @. unpl pl \f g h -> f . h . g
19:09:30 <lambdabot> (\ x x0 x1 x2 -> x (x1 (x0 x2)))
19:12:15 <ski> najs
19:13:20 <int-e> It was a trivial one line change in the end: https://github.com/lambdabot/lambdabot/commit/ed7a3a7befad81da8870253284aa910de7e39cc3
19:14:07 <int-e> (but somebody should comment that code! ;-) )
19:17:31 <int-e> @. unpl pl \f g h i j -> f . h . j . i . g
19:17:31 <lambdabot> (\ x x0 x1 x2 x3 x4 -> x (x1 (x3 (x2 (x0 x4)))))
19:18:03 <int-e> looks good :)
19:18:42 <int-e> @. unpl pl \f g h i j -> f . h . j . i . x . g
19:18:42 <lambdabot> (\ x0 x1 x2 x3 x4 x5 -> x0 (x2 (x4 (x3 (x (x1 x5))))))
19:19:41 <int-e> thosgood[m], hpc, ski: thanks for the examples
19:24:27 <int-e> @unpl \x -> \x -> x
19:24:27 <lambdabot> \ x x0 -> x0
19:31:30 <int-e> @pl \x -> \x y -> x
19:31:31 <lambdabot> const (const id)
19:31:39 <int-e> @pl \z -> \x y -> x
19:31:39 <lambdabot> const const
19:53:36 <slack1256> When compiling with -prof, do I still incur a perfomance overhead even if I am not launching with +RTS -p --RTS?
19:55:10 <monochrom> Yes. The generated code is already instrumented.
20:56:52 <HaskellLord69> didn't get an answer in beginners, if im passing around a socket to multiple functions, should I have it wrapped in an IORef?
20:57:39 <Axman6> why would you need to do that?
20:58:19 <HaskellLord69> well I was passing it around in a brick app trying to report whenever something changed, and I ended up opening a bunch of connections
20:58:30 <HaskellLord69> so that made me think it was getting copied every time i passed it around
20:58:42 <Axman6> no
20:58:48 <Axman6> it must be something else
20:58:54 <Axman6> feel free to share the code
21:16:49 <orion> Is anyone else missing the "stack image container" command?
21:17:04 <orion> According to the changelog: "Remove the stack image command. With the advent of Docker multistage builds, this functionality is no longer useful. For an example, please see Building Haskell Apps with Docker."
21:17:46 <orion> The unfortunate side-effect of this is that my builds are no longer cached.
21:29:58 <Axman6> isn't that what mutlistage builds gives you though?
21:36:55 <nullnullnull> how to set timeout for connectTo?
21:58:12 <isovector1> is the `t` quasiquoter in TH available anywhere in source haskell?
21:58:34 <isovector1> i want to define another qq in terms of it
22:18:28 <MarcelineVQ> source haskell?
22:19:54 <isovector1> is there some `t :: QuasiQuoter`?
22:20:06 <isovector1> which is equivalent to the [t| |] thing used in templatehaskell?
22:24:18 <MarcelineVQ> t :: QuasiQuoter, somewhat equivalent to [t| |], is https://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Quote.html that only defines quoteType. You've probably seen that though so I might be missing the subtext
22:30:17 <isovector1> quoteType is what gets run for your own quasiquoters
22:30:33 <isovector1> but afaict there is no way to invoke `t` non-syntactically
22:31:14 <isovector1> which is to say i can't do this: `runT :: String -> Q Type; runT something = [t| something |] `
22:31:47 <c_wraith> you can do quoteExp t "foo"
22:32:17 <c_wraith> or quoteType, if you want to use the QuasiQuoter to generate a Type...
22:32:35 <isovector1> c_wraith: but t isn't in scope?
22:32:43 <c_wraith> it has to be
22:32:47 <isovector1> it's magic
22:32:50 <MarcelineVQ> So you want want [t| |]'s QuasiQuoter, hmm
22:32:52 <isovector1> which is my point
22:32:55 <c_wraith> Oh, I see
22:33:42 <isovector1> i have a function `Type -> Type` that i would like to compose with quoteType t to make a custom qq that parses a type and then mangles it
22:35:49 <isovector1> so right now i have to do `$(myFunction [t| some type |])` which is ugly and a bad ux
22:43:27 <MarcelineVQ> http://hackage.haskell.org/package/haskell-src-exts-qq does some interesting things
22:48:02 <isovector1> yeah and it breaks on every new release of ghc and depends on h-s-e which is no longer being supported :)
22:48:25 <isovector1> sorry, i'm just grumpy that this is syntactic magic
22:48:36 <isovector1> pretty bad design for a language that prides itself on compositionality
22:50:18 <MarcelineVQ> This is what you get for pushing the limits!
22:50:45 <MarcelineVQ> plugins and ghc additions, pretty soon you'll be requesting people call you simon :>
22:51:57 <hololeap> is it standard to add `deriving (Show, Eq)` to every data type that you can?
22:52:46 <Axman6> I usually do out of habit, but rarely use Eq
22:53:14 <hololeap> i had the impression that Eq was required for pattern matching. is that true?
22:53:20 <MarcelineVQ> no
22:53:40 <hololeap> heh, i've been adding that for a long time thinking that it was needed
22:53:56 <MarcelineVQ> Typically where you need Eq inpattern matches is for numeric literals because they don't really have constructors
22:54:11 <MarcelineVQ> So it's actually a guard
22:54:14 <hololeap> oh, maybe that's where i got the idea from
22:54:38 <hololeap> i remember some error in the past making me think that it was needed
22:55:00 <remexre> should aeson take a ungodly amount of time to build with profiling, or did I manage to diverge GHC?
22:55:11 <isovector1> MarcelineVQ: haha i'm so far down the rabbit hole these days. i've written a library for managing the type errors i generate in polysemy, and i need this to put a nice UX on writing those type errors
22:55:20 <MarcelineVQ> remexre: probably yes to the first, dunno about the second
22:55:34 <MarcelineVQ> But ungodly isn't a standard measure
22:56:35 <remexre> fair
22:56:47 <remexre> ungodly == longer than the entire build w/out profiling
22:58:11 <isovector1> i filed a bug: https://gitlab.haskell.org/ghc/ghc/issues/16896
22:59:49 <olligobber> seems redefining Bool was a bad idea lol
23:00:52 <olligobber> what's a good symbol other than | or || to use for "or"?
23:00:54 <MarcelineVQ> olligobber: It's only a bad idea if the wife finds out about it, now's your chance to create something unique and new
23:01:05 <olligobber> MarcelineVQ, I don't want to redefine Eq
23:01:42 <Axman6> \/
23:01:44 <olligobber> ; is also not available
23:01:53 <olligobber> I'd prefer a symbol on a standard keyboard...
23:02:05 <MarcelineVQ> \/ is on my kb
23:02:19 <olligobber> I'd prefer a symbol on my keyboard
23:02:24 <MarcelineVQ> It's on yours too.
23:02:31 <olligobber> where?
23:02:40 <Axman6> it's \ and /
23:02:43 <MarcelineVQ> above enter and below and to the left of it
23:02:48 <olligobber> wait is that valid?
23:02:59 <olligobber> wow
23:03:00 <olligobber> thanks
23:03:02 <Axman6> \o/
23:03:08 <MarcelineVQ> o7
23:04:38 <olligobber> actually, /\ is also valid :o
23:07:29 <isovector1> it's like ghc hates me
23:07:45 <isovector1> they also disable the varargs features in -XCPP so you can't even do proper macro-programming
23:37:47 <olligobber> is there a list of classes that can be derived in haskell?
23:38:20 <Axman6> with DeriveAnyCalss the list is infinite =)
23:38:37 <olligobber> what about without any extensions?
23:38:54 <Axman6> and there's differenty lists between "Haskell" and "GHC Haskell" and "GHC Haskell With Extensions"
23:39:05 <Axman6> the first should be in the report I believe
23:39:32 <olligobber> I haven't seen this report
23:43:37 <olligobber> looks like the list in the report is (Eq, Ord, Enum, Bounded, Show, Read)
23:43:53 <Axman6> sounds about right to me
23:45:04 <ski> also `Ix'
23:51:25 <olligobber> ski, Not in scope: type constructor or class ‘Ix’
